main
public static void zookeeper_f0_0(String[] args) throws IOException, ClassNotFoundException, SecurityException, NoSuchMethodException, IllegalArgumentException, IllegalAccessException
{    InputStream is = FatJarMain.class.getResourceAsStream("/mainClasses");    if (is == null) {        System.err.println("Couldn't find /mainClasses in classpath.");        System.exit(3);    }    BufferedReader br = new BufferedReader(new InputStreamReader(is));    String line;    while ((line = br.readLine()) != null) {        String[] parts = line.split(":", 3);        if (parts.length != 3 || (parts[0].length() > 0 && parts[0].charAt(0) == '#')) {            continue;        }        if (parts[0].length() > 0) {            cmds.put(parts[0], new Cmd(parts[0], parts[1], parts[2]));                                    order.add(parts[0]);        } else {                        order.add(parts[2]);        }    }    if (args.length == 0) {        doHelp();        return;    }    Cmd cmd = cmds.get(args[0]);    if (cmd == null) {        doHelp();        return;    }    Class<?> clazz = Class.forName(cmd.clazz);    Method main = clazz.getMethod("main", String[].class);    String[] newArgs = new String[args.length - 1];    System.arraycopy(args, 1, newArgs, 0, newArgs.length);    try {        main.invoke(null, (Object) newArgs);    } catch (InvocationTargetException e) {        if (e.getCause() != null) {            e.getCause().printStackTrace();        } else {            e.printStackTrace();        }    }}
doHelp
private static void zookeeper_f1_0()
{    System.err.println("USAGE: FatJarMain cmd args");    System.err.println("Available cmds:");    for (String c : order) {        Cmd cmd = cmds.get(c);        if (cmd != null) {            System.err.println("  " + c + " " + cmd.desc);        } else {            System.err.println(c);        }    }    System.exit(2);}
newOp
public static FilterOp zookeeper_f2_0(String op) throws FilterException
{    if (op.equals("or"))        return new OrOp();    if (op.equals("and"))        return new AndOp();    if (op.equals("not"))        return new NotOp();    if (op.equals("xor"))        return new XorOp();    if (op.equals("="))        return new EqualsOp();    if (op.equals("<"))        return new LessThanOp();    if (op.equals(">"))        return new GreaterThanOp();    throw new FilterException("Invalid operation '" + op + "'");}
addSubOp
public void zookeeper_f3_0(FilterOp op)
{    subOps.add(op);}
addArg
public void zookeeper_f4_0(Arg arg)
{    args.add(arg);}
toString
public String zookeeper_f5_0()
{    String op = "(" + getClass().getName();    for (FilterOp f : subOps) {        op += " " + f;    }    for (Arg a : args) {        op += " " + a;    }    return op + ")";}
matches
public boolean zookeeper_f6_0(LogEntry entry) throws FilterException
{    for (FilterOp f : subOps) {        if (!f.matches(entry)) {            return false;        }    }    return true;}
getType
public ArgType zookeeper_f7_0()
{    return type;}
getValue
public T zookeeper_f8_0()
{    return value;}
toString
public String zookeeper_f9_0()
{    return "[" + type + ":" + value + "]";}
matches
public boolean zookeeper_f10_0(LogEntry entry) throws FilterException
{    Object last = null;    for (Arg a : args) {        Object v = a.getValue();        if (a.getType() == FilterOp.ArgType.SYMBOL) {            String key = (String) a.getValue();            v = entry.getAttribute(key);        }        if (last != null && !last.equals(v)) {            return false;        }        last = v;    }    return true;}
matches
public boolean zookeeper_f11_0(LogEntry entry) throws FilterException
{    Arg first = args.get(0);    if (first != null) {        FilterOp.ArgType type = first.getType();        if (type == FilterOp.ArgType.SYMBOL) {            String key = (String) first.getValue();            Object v = entry.getAttribute(key);            if (v instanceof String) {                type = FilterOp.ArgType.STRING;            } else if (v instanceof Double || v instanceof Long || v instanceof Integer || v instanceof Short) {                type = FilterOp.ArgType.NUMBER;            } else {                throw new FilterException("LessThanOp: Invalid argument, first argument resolves to neither a String nor a Number");            }        }        Object last = null;        for (Arg a : args) {            Object v = a.getValue();            if (a.getType() == FilterOp.ArgType.SYMBOL) {                String key = (String) a.getValue();                v = entry.getAttribute(key);            }            if (last != null) {                if (type == FilterOp.ArgType.STRING) {                    if (((String) last).compareTo((String) v) <= 0) {                        return false;                    }                } else if (type == FilterOp.ArgType.NUMBER) {                                        if (((Number) last).longValue() <= ((Number) v).longValue()) {                        return false;                    }                }            }            last = v;        }        return true;    } else {        return true;    }}
matches
public boolean zookeeper_f12_0(LogEntry entry) throws FilterException
{    Arg first = args.get(0);    if (first != null) {        FilterOp.ArgType type = first.getType();        if (type == FilterOp.ArgType.SYMBOL) {            String key = (String) first.getValue();            Object v = entry.getAttribute(key);            if (v instanceof String) {                type = FilterOp.ArgType.STRING;            } else if (v instanceof Double || v instanceof Long || v instanceof Integer || v instanceof Short) {                type = FilterOp.ArgType.NUMBER;            } else {                throw new FilterException("LessThanOp: Invalid argument, first argument resolves to neither a String nor a Number");            }        }        Object last = null;        for (Arg a : args) {            Object v = a.getValue();            if (a.getType() == FilterOp.ArgType.SYMBOL) {                String key = (String) a.getValue();                v = entry.getAttribute(key);            }            if (last != null) {                if (type == FilterOp.ArgType.STRING) {                    if (((String) last).compareTo((String) v) >= 0) {                        return false;                    }                } else if (type == FilterOp.ArgType.NUMBER) {                    if (((Number) last).doubleValue() >= ((Number) v).doubleValue()) {                        return false;                    }                }            }            last = v;        }        return true;    } else {        return true;    }}
matches
public boolean zookeeper_f13_0(LogEntry entry) throws FilterException
{    if (subOps.size() != 1) {        throw new FilterException("Not operation can only take one argument");    }    return !subOps.get(0).matches(entry);}
matches
public boolean zookeeper_f14_0(LogEntry entry) throws FilterException
{    for (FilterOp f : subOps) {        if (f.matches(entry)) {            return true;        }    }    return false;}
matches
public boolean zookeeper_f15_0(LogEntry entry) throws FilterException
{    int count = 0;    for (FilterOp f : subOps) {        if (f.matches(entry)) {            count++;            if (count > 1) {                return false;            }        }    }    if (count == 1) {        return true;    }    return false;}
readUntilSpace
private String zookeeper_f16_0() throws IOException
{    StringBuffer buffer = new StringBuffer();    int c = reader.read();    while (!Character.isWhitespace(c) && c != ')' && c != '(') {        buffer.append((char) c);        c = reader.read();        if (c == -1) {            break;        }    }    reader.unread(c);    return buffer.toString().trim();}
readStringArg
private StringArg zookeeper_f17_0() throws IOException, FilterException
{    int c = reader.read();    int last = 0;    if (c != '"') {        throw new FilterException("Check the parser, trying to read a string that doesn't begin with quotes");    }    StringBuffer buffer = new StringBuffer();    while (reader.ready()) {        last = c;        c = reader.read();        if (c == -1) {            break;        }        if (c == '"' && last != '\\') {            return new StringArg(buffer.toString());        } else {            buffer.append((char) c);        }    }    throw new FilterException("Unterminated string");}
readNumberArg
private NumberArg zookeeper_f18_0() throws IOException, FilterException
{    String strval = readUntilSpace();    try {        if (strval.startsWith("0x")) {            return new NumberArg(Long.valueOf(strval.substring(2), 16));        } else {            return new NumberArg(Long.valueOf(strval));        }    } catch (NumberFormatException e) {        throw new FilterException("Not a number [" + strval + "]\n" + e);    }}
readSymbolArg
private SymbolArg zookeeper_f19_0() throws IOException, FilterException
{    return new SymbolArg(readUntilSpace());}
parse
public FilterOp zookeeper_f20_0() throws IOException, FilterException
{    int c = reader.read();    if (c != '(') {        throw new FilterException("Invalid format");    }    String opstr = readUntilSpace();    FilterOp op = FilterOp.newOp(opstr);    while (reader.ready()) {        c = reader.read();        if (c == -1) {            break;        }        if (c == '(') {            reader.unread(c);            op.addSubOp(parse());        } else if (c == ')') {            return op;        } else if (c == '"') {            reader.unread(c);            op.addArg(readStringArg());        } else if (Character.isDigit(c) || c == '-' || c == '+') {            reader.unread(c);            op.addArg(readNumberArg());        } else if (Character.isJavaIdentifierStart(c)) {            reader.unread(c);            op.addArg(readSymbolArg());        }    }    throw new FilterException("Incomplete filter");}
main
public static void zookeeper_f21_0(String[] args) throws IOException, FilterException
{    if (args.length == 1) {        System.out.println(new FilterParser(args[0]).parse());    } else {        System.out.println(new FilterParser("(or (and (= session foobar) (= session barfoo)) (= session sdfs))").parse());    }}
equals
public boolean zookeeper_f22_0(Message m)
{    return (m.from == this.from && m.to == this.to && m.zxid == this.zxid);}
txnEntry
public JSONObject zookeeper_f23_0(TransactionEntry e)
{    JSONObject event = new JSONObject();    event.put("time", Long.toString(e.getTimestamp()));    event.put("client", Long.toHexString(e.getClientId()));    event.put("cxid", Long.toHexString(e.getCxid()));    event.put("zxid", Long.toHexString(e.getZxid()));    event.put("op", e.getOp());    event.put("extra", e.getExtra());    event.put("type", "transaction");    return event;}
toString
public String zookeeper_f24_0()
{    return JSONValue.toJSONString(root);}
main
public static void zookeeper_f25_0(String[] args) throws Exception
{    MergedLogSource src = new MergedLogSource(args);    LogIterator iter = src.iterator();    System.out.println(new JsonGenerator(iter));}
getEntry
public String zookeeper_f26_0()
{    return (String) getAttribute("log-text");}
toString
public String zookeeper_f27_0()
{    return "" + getTimestamp() + "::::" + getNode() + "::::" + getEntry();}
getNode
public int zookeeper_f28_0()
{    return (Integer) getAttribute("node");}
getType
public Type zookeeper_f29_0()
{    return LogEntry.Type.LOG4J;}
overlapsRange
public boolean zookeeper_f30_0(long starttime, long endtime)
{    return (starttime <= this.endtime && endtime >= this.starttime);}
size
public long zookeeper_f31_0()
{    return size;}
getStartTime
public long zookeeper_f32_0()
{    return starttime;}
getEndTime
public long zookeeper_f33_0()
{    return endtime;}
getSkipList
public LogSkipList zookeeper_f34_0()
{    return skiplist;}
size
public synchronized long zookeeper_f35_0() throws IOException
{    if (LOG.isTraceEnabled()) {        LOG.trace("size() called");    }    if (this.endtime >= src.getEndTime()) {        return src.size() - skippedAtStart;    }    long pos = in.getPosition();    if (LOG.isTraceEnabled()) {        LOG.trace("saved pos () = " + pos);    }    LogEntry e;    LogSkipList.Mark lastseg = src.getSkipList().findMarkBefore(this.endtime);    in.seek(lastseg.getBytes());        buf = "";        long count = lastseg.getEntriesSkipped() - skippedAtStart;    while ((e = readNextEntry()) != null) {        if (LOG.isTraceEnabled()) {                }        if (e.getTimestamp() > this.endtime) {            break;        }        count++;    }    in.seek(pos);    buf = "";    if (LOG.isTraceEnabled()) {        LOG.trace("size() = " + count);    }    return count;}
readNextEntry
private synchronized LogEntryf36_1)
{    try {        try {            while (true) {                String line = in.readLine();                if (line == null) {                    break;                }                Matcher m = src.timep.matcher(line);                if (m.lookingAt()) {                    if (buf.length() > 0) {                        LogEntry e = new Log4JEntry(src.timestampFromText(dateformat, buf), src.getServerId(), buf);                        buf = line;                        return e;                    }                    buf = line;                } else if (buf.length() > 0) {                    buf += line + "\n";                }            }        } catch (EOFException eof) {                }        if (buf.length() > 0) {            LogEntry e = new Log4JEntry(src.timestampFromText(dateformat, buf), src.getServerId(), buf);            buf = "";            return e;        }    } catch (Exception e) {                return null;    }    return null;}
hasNext
public boolean zookeeper_f37_0()
{    return next != null;}
next
public LogEntry zookeeper_f38_0() throws NoSuchElementException
{    LogEntry ret = next;    LogEntry e = readNextEntry();    if (filter != null) {        try {            while (e != null && !filter.matches(e)) {                e = readNextEntry();            }        } catch (FilterException fe) {            throw new NoSuchElementException(e.toString());        }    }    if (e != null && e.getTimestamp() < endtime) {        next = e;    } else {        next = null;    }    return ret;}
remove
public void zookeeper_f39_0() throws UnsupportedOperationException
{    throw new UnsupportedOperationException("remove not supported for L4J logs");}
close
public void zookeeper_f40_0() throws IOException
{    in.close();}
toString
public String zookeeper_f41_0()
{    String size;    try {        size = new Long(size()).toString();    } catch (IOException ioe) {        size = "Unable to read";    }    return "Log4JSourceIterator(start=" + starttime + ", end=" + endtime + ", size=" + size + ")";}
iterator
public LogIterator zookeeper_f42_0(long starttime, long endtime) throws IllegalArgumentException
{    try {        return iterator(starttime, endtime, null);    } catch (FilterException fe) {                assert (false);        return null;    }}
iterator
public LogIterator zookeeper_f43_0(long starttime, long endtime, FilterOp filter) throws IllegalArgumentException, FilterException
{        if (endtime < starttime) {        throw new IllegalArgumentException("End time (" + endtime + ") must be greater or equal to starttime (" + starttime + ")");    }    return new Log4JSourceIterator(this, starttime, endtime, filter);}
iterator
public LogIterator zookeeper_f44_0() throws IllegalArgumentException
{    return iterator(starttime, endtime + 1);}
timestampFromText
private static long zookeeper_f45_0(SimpleDateFormat format, String s)
{    Date d = null;    try {        d = format.parse(s);    } catch (ParseException e) {        return 0;    }    Calendar c = new GregorianCalendar();    c.setTime(d);    return c.getTimeInMillis();}
init
private void zookeeper_f46_0() throws IOException
{    File f = new File(file);    RandomAccessFileReader in = new RandomAccessFileReader(f);    SimpleDateFormat dateformat = new SimpleDateFormat(DATE_FORMAT);    Pattern idp = Pattern.compile("\\[myid:(\\d+)\\]");    long lastFp = in.getPosition();    String line = in.readLine();    Matcher m = null;        if ((line != null) && (m = timep.matcher(line)).lookingAt()) {        starttime = timestampFromText(dateformat, m.group(1));    } else {        throw new IOException("Invalid log4j format. First line doesn't start with time");    }    /*	  Count number of log entries. Any line starting with a timestamp counts as an entry	*/    String lastentry = line;    try {        while (line != null) {            m = timep.matcher(line);            if (m.lookingAt()) {                if (size % skipN == 0) {                    long time = timestampFromText(dateformat, m.group(1));                    skiplist.addMark(time, lastFp, size);                }                size++;                lastentry = line;            }            if (serverid == 0 && (m = idp.matcher(line)).find()) {                serverid = Integer.valueOf(m.group(1));            }            lastFp = in.getPosition();            line = in.readLine();        }    } catch (EOFException eof) {        } finally {        in.close();    }    m = timep.matcher(lastentry);    if (m.lookingAt()) {        endtime = timestampFromText(dateformat, m.group(1));    } else {        throw new IOException("Invalid log4j format. Last line doesn't start with time");    }}
toString
public String zookeeper_f47_0()
{    return "Log4JSource(file=" + file + ", size=" + size + ", start=" + starttime + ", end=" + endtime + ", id=" + serverid + ")";}
main
public static void zookeeper_f48_0(String[] args) throws IOException
{    final Log4JSource s = new Log4JSource(args[0]);    System.out.println(s);    LogIterator iter;    if (args.length == 3) {        final long starttime = Long.valueOf(args[1]);        final long endtime = Long.valueOf(args[2]);        iter = s.iterator(starttime, endtime);        Thread t1 = new Thread() {            public void run() {                LogIterator iter = s.iterator(starttime, endtime);                System.out.println(iter);                try {                    iter.close();                } catch (IOException ioe) {                    System.out.println(ioe.getMessage());                }            }        };        Thread t2 = new Thread() {            public void run() {                LogIterator iter = s.iterator(starttime, endtime);                System.out.println(iter);                try {                    iter.close();                } catch (IOException ioe) {                    System.out.println(ioe.getMessage());                }            }        };        Thread t3 = new Thread() {            public void run() {                LogIterator iter = s.iterator(starttime, endtime);                System.out.println(iter);            }        };        t1.start();        t2.start();        } else {        iter = s.iterator();    }    /*while (iter.hasNext()) {	    System.out.println(iter.next());	    }*/    iter.close();}
run
public void zookeeper_f49_0()
{    LogIterator iter = s.iterator(starttime, endtime);    System.out.println(iter);    try {        iter.close();    } catch (IOException ioe) {        System.out.println(ioe.getMessage());    }}
run
public void zookeeper_f50_0()
{    LogIterator iter = s.iterator(starttime, endtime);    System.out.println(iter);    try {        iter.close();    } catch (IOException ioe) {        System.out.println(ioe.getMessage());    }}
run
public void zookeeper_f51_0()
{    LogIterator iter = s.iterator(starttime, endtime);    System.out.println(iter);}
getServerId
public int zookeeper_f52_0()
{    return serverid;}
getTimestamp
public long zookeeper_f53_0()
{    return (Long) getAttribute("timestamp");}
setAttribute
public void zookeeper_f54_0(String key, Object v)
{    attributes.put(key, v);}
getAttribute
public Object zookeeper_f55_0(String key)
{    return attributes.get(key);}
main
public static void zookeeper_f56_0(String[] args)
{    try {        MergedLogSource src = new MergedLogSource(args);        System.out.println(src);        Server server = new Server(8182);        server.setHandler(new LogServer(src));        server.start();        server.join();    } catch (Exception e) {                e.printStackTrace();    }}
getTime
public long zookeeper_f57_0()
{    return this.time;}
getBytes
public long zookeeper_f58_0()
{    return this.bytes;}
getEntriesSkipped
public long zookeeper_f59_0()
{    return this.skipped;}
toString
public String zookeeper_f60_0()
{    return "Mark(time=" + time + ", bytes=" + bytes + ", skipped=" + skipped + ")";}
addMark
public void zookeeper_f61_0(long time, long bytes, long skipped)
{    if (LOG.isTraceEnabled()) {        LOG.trace("addMark (time:" + time + ", bytes: " + bytes + ", skipped: " + skipped + ")");    }    marks.add(new Mark(time, bytes, skipped));}
findMarkBefore
public Mark zookeeper_f62_0(long time) throws NoSuchElementException
{    if (LOG.isTraceEnabled()) {        LOG.trace("findMarkBefore(" + time + ")");    }    Mark last = marks.getFirst();    for (Mark m : marks) {        if (m.getTime() > time) {            break;        }        last = m;    }    if (LOG.isTraceEnabled()) {        LOG.trace("return " + last);    }    return last;}
main
public static void zookeeper_f63_0(String[] args) throws IOException
{    MergedLogSource source = new MergedLogSource(args);    PrintStream ps_ms = new PrintStream(new BufferedOutputStream(new FileOutputStream("throughput-ms.out")));    PrintStream ps_sec = new PrintStream(new BufferedOutputStream(new FileOutputStream("throughput-sec.out")));    PrintStream ps_min = new PrintStream(new BufferedOutputStream(new FileOutputStream("throughput-min.out")));    PrintStream ps_hour = new PrintStream(new BufferedOutputStream(new FileOutputStream("throughput-hour.out")));    LogIterator iter;    System.out.println(source);    iter = source.iterator();    long currentms = 0;    long currentsec = 0;    long currentmin = 0;    long currenthour = 0;    Set<Long> zxids_ms = new HashSet<Long>();    long zxid_sec = 0;    long zxid_min = 0;    long zxid_hour = 0;    while (iter.hasNext()) {        LogEntry e = iter.next();        TransactionEntry cxn = (TransactionEntry) e;        long ms = cxn.getTimestamp();        long sec = ms / MS_PER_SEC;        long min = ms / MS_PER_MIN;        long hour = ms / MS_PER_HOUR;        if (currentms != ms && currentms != 0) {            ps_ms.println("" + currentms + " " + zxids_ms.size());            zxid_sec += zxids_ms.size();            zxid_min += zxids_ms.size();            zxid_hour += zxids_ms.size();            zxids_ms.clear();        }        if (currentsec != sec && currentsec != 0) {            ps_sec.println("" + currentsec * MS_PER_SEC + " " + zxid_sec);            zxid_sec = 0;        }        if (currentmin != min && currentmin != 0) {            ps_min.println("" + currentmin * MS_PER_MIN + " " + zxid_min);            zxid_min = 0;        }        if (currenthour != hour && currenthour != 0) {            ps_hour.println("" + currenthour * MS_PER_HOUR + " " + zxid_hour);            zxid_hour = 0;        }        currentms = ms;        currentsec = sec;        currentmin = min;        currenthour = hour;        zxids_ms.add(cxn.getZxid());    }    iter.close();    ps_ms.close();    ps_sec.close();    ps_min.close();    ps_hour.close();}
overlapsRange
public boolean zookeeper_f64_0(long starttime, long endtime)
{    return (starttime <= this.endtime && endtime >= this.starttime);}
size
public long zookeeper_f65_0()
{    return size;}
getStartTime
public long zookeeper_f66_0()
{    return starttime;}
getEndTime
public long zookeeper_f67_0()
{    return endtime;}
size
public long zookeeper_f68_0() throws IOException
{    long size = 0;    for (LogIterator i : sources) {        size += i.size();    }    return size;}
hasNext
public boolean zookeeper_f69_0()
{    for (LogEntry n : nexts) {        if (n != null)            return true;    }    return false;}
next
public LogEntry zookeeper_f70_0()
{    int min = -1;    for (int i = 0; i < nexts.length; i++) {        if (nexts[i] != null) {            if (min == -1) {                min = i;            } else if (nexts[i].getTimestamp() < nexts[min].getTimestamp()) {                min = i;            }        }    }    if (min == -1) {        return null;    } else {        LogEntry e = nexts[min];        nexts[min] = sources[min].next();        return e;    }}
remove
public void zookeeper_f71_0() throws UnsupportedOperationException
{    throw new UnsupportedOperationException("remove not supported for Merged logs");}
close
public void zookeeper_f72_0() throws IOException
{    for (LogIterator i : sources) {        i.close();    }}
iterator
public LogIterator zookeeper_f73_0(long starttime, long endtime) throws IllegalArgumentException
{    try {        return iterator(starttime, endtime, null);    } catch (FilterException fe) {                assert (false);        return null;    }}
iterator
public LogIterator zookeeper_f74_0(long starttime, long endtime, FilterOp filter) throws IllegalArgumentException, FilterException
{        if (endtime < starttime) {        throw new IllegalArgumentException("End time (" + endtime + ") must be greater or equal to starttime (" + starttime + ")");    }    return new MergedLogSourceIterator(this, starttime, endtime, filter);}
iterator
public LogIterator zookeeper_f75_0() throws IllegalArgumentException
{    return iterator(starttime, endtime + 1);}
addSource
public void zookeeper_f76_0(String f) throws IOException
{    LogSource s = null;    if (TxnLogSource.isTransactionFile(f)) {        s = new TxnLogSource(f);    } else {        s = new Log4JSource(f);    }    size += s.size();    endtime = s.getEndTime() > endtime ? s.getEndTime() : endtime;    starttime = s.getStartTime() < starttime || starttime == 0 ? s.getStartTime() : starttime;    sources.add(s);}
toString
public String zookeeper_f77_0()
{    String s = "MergedLogSource(size=" + size + ", start=" + starttime + ", end=" + endtime + ")";    for (LogSource src : sources) {        s += "\n\t- " + src;    }    return s;}
main
public static void zookeeper_f78_0(String[] args) throws IOException
{    System.out.println("Time: " + System.currentTimeMillis());    MergedLogSource s = new MergedLogSource(args);    System.out.println(s);    LogIterator iter;    iter = s.iterator();    System.out.println("Time: " + System.currentTimeMillis());    System.out.println("Iterator Size: " + iter.size());    System.out.println("Time: " + System.currentTimeMillis());    /*	while (iter.hasNext()) {	    System.out.println(iter.next());	    }*/    iter.close();    System.out.println("Time: " + System.currentTimeMillis());}
fill
private intf79_1) throws IOException
{    fileoffset = fp;    int read = file.read(buffer, 0, buffer.length);    if (LOG.isDebugEnabled()) {        String buf = new String(buffer, 0, 40, "UTF-8");            }    if (read == -1) {                buffersize = 0;    } else {        buffersize = read;    }    fp += buffersize;    bufferoffset = 0;    return buffersize;}
markSupported
public boolean zookeeper_f80_0()
{    return false;}
read
public synchronized int zookeeper_f81_0(char[] cbuf, int off, int len) throws IOException
{        byte[] b = new byte[2];    int bytesread = 0;    while (len > 0) {        int read = read(b, 0, 2);        bytesread += read;        if (read < 2) {            return bytesread;        }        cbuf[off] = (char) ((b[0] << 8) | (b[1] & 0xff));        off += read;        len -= read;    }    return bytesread;}
read
public synchronized int zookeeper_f82_0(byte[] buf, int off, int len) throws IOException
{    if (LOG.isTraceEnabled()) {        LOG.trace("read(buf, off=" + off + ", len=" + len);    }    int read = 0;    while (len > 0) {        if (buffersize == 0) {            fill();            if (buffersize == 0) {                break;            }        }        int tocopy = Math.min(len, buffersize);        if (LOG.isTraceEnabled()) {            LOG.trace("tocopy=" + tocopy);        }        System.arraycopy(buffer, bufferoffset, buf, off, tocopy);        buffersize -= tocopy;        bufferoffset += tocopy;        len -= tocopy;        read += tocopy;        off += tocopy;    }    if (LOG.isTraceEnabled()) {        LOG.trace("read=" + read);    }    return read;}
close
public void zookeeper_f83_0() throws IOException
{    file.close();}
getPosition
public long zookeeper_f84_0()
{    return bufferoffset + fileoffset;}
seek
public synchronized voidf85_1long pos) throws IOException
{    if (LOG.isDebugEnabled()) {            }    file.seek(pos);    fp = pos;        buffersize = 0;}
readLine
public synchronized String zookeeper_f86_0() throws IOException
{    StringBuffer s = null;        buffering: for (; ; ) {        if (buffersize == 0) {            fill();            if (buffersize == 0) {                break;            }        }        for (int i = 0; i < buffersize; i++) {            if (buffer[bufferoffset + i] == '\n') {                if (i > 0) {                                        if (s == null) {                        s = new StringBuffer();                    }                    s.append(new String(buffer, bufferoffset, i, "UTF-8"));                }                bufferoffset += i + 1;                buffersize -= i + 1;                break buffering;            }        }                if (s == null) {            s = new StringBuffer();        }        s.append(new String(buffer, bufferoffset, buffersize, "UTF-8"));        buffersize = 0;    }    if (s == null) {        return null;    } else {        return s.toString();    }}
readFully
public void zookeeper_f87_0(byte[] b) throws IOException
{    readFully(b, 0, b.length);}
readFully
public void zookeeper_f88_0(byte[] b, int off, int len) throws IOException
{    while (len > 0) {        int read = read(b, off, len);        len -= read;        off += read;        if (read == 0) {            throw new EOFException("End of file reached");        }    }}
skipBytes
public int zookeeper_f89_0(int n) throws IOException
{    seek(getPosition() + n);    return n;}
readBoolean
public boolean zookeeper_f90_0() throws IOException
{    return (readByte() != 0);}
readByte
public byte zookeeper_f91_0() throws IOException
{    byte[] b = new byte[1];    readFully(b, 0, 1);    return b[0];}
readUnsignedByte
public int zookeeper_f92_0() throws IOException
{    return (int) readByte();}
readShort
public short zookeeper_f93_0() throws IOException
{    byte[] b = new byte[2];    readFully(b, 0, 2);    return (short) ((b[0] << 8) | (b[1] & 0xff));}
readUnsignedShort
public int zookeeper_f94_0() throws IOException
{    byte[] b = new byte[2];    readFully(b, 0, 2);    return (((b[0] & 0xff) << 8) | (b[1] & 0xff));}
readChar
public char zookeeper_f95_0() throws IOException
{    return (char) readShort();}
readInt
public int zookeeper_f96_0() throws IOException
{    byte[] b = new byte[4];    readFully(b, 0, 4);    return (((b[0] & 0xff) << 24) | ((b[1] & 0xff) << 16) | ((b[2] & 0xff) << 8) | (b[3] & 0xff));}
readLong
public long zookeeper_f97_0() throws IOException
{    byte[] b = new byte[8];    readFully(b, 0, 8);    return (((long) (b[0] & 0xff) << 56) | ((long) (b[1] & 0xff) << 48) | ((long) (b[2] & 0xff) << 40) | ((long) (b[3] & 0xff) << 32) | ((long) (b[4] & 0xff) << 24) | ((long) (b[5] & 0xff) << 16) | ((long) (b[6] & 0xff) << 8) | ((long) (b[7] & 0xff)));}
readFloat
public float zookeeper_f98_0() throws IOException
{    return Float.intBitsToFloat(readInt());}
readDouble
public double zookeeper_f99_0() throws IOException
{    return Double.longBitsToDouble(readLong());}
readUTF
public String zookeeper_f100_0() throws IOException
{    int len = readUnsignedShort();    byte[] bytes = new byte[len + 2];    bytes[0] = (byte) ((len >> 8) & 0xFF);    bytes[1] = (byte) (len & 0xFF);    readFully(bytes, 2, len);    DataInputStream dis = new DataInputStream(new ByteArrayInputStream(bytes));    return dis.readUTF();}
main
public static void zookeeper_f101_0(String[] args) throws IOException
{    RandomAccessFileReader f = new RandomAccessFileReader(new File(args[0]));    long pos0 = f.getPosition();    for (int i = 0; i < 5; i++) {        System.out.println(f.readLine());    }    System.out.println("=============");    long pos1 = f.getPosition();    System.out.println("pos: " + pos1);    for (int i = 0; i < 5; i++) {        System.out.println(f.readLine());    }    System.out.println("=============");    f.seek(pos1);    for (int i = 0; i < 5; i++) {        System.out.println(f.readLine());    }    System.out.println("=============");    f.seek(pos0);    for (int i = 0; i < 5; i++) {        System.out.println(f.readLine());    }    long pos2 = f.getPosition();    System.out.println("=============");    System.out.println(f.readLine());    f.seek(pos2);    System.out.println(f.readLine());    f.close();}
handleRequest
 String zookeeper_f102_0(JsonRequest request) throws Exception
{    String output = "";    String file = request.getString("path", "/");    JSONObject o = new JSONObject();    try {        this.source.addSource(file);        o.put("status", "OK");    } catch (Exception e) {        o.put("status", "ERR");        o.put("error", e.toString());    }    return JSONValue.toJSONString(o);}
handleRequest
 String zookeeper_f103_0(JsonRequest request) throws Exception
{    String output = "";    JSONArray filelist = new JSONArray();    File base = new File(request.getString("path", "/"));    if (!base.exists() || !base.isDirectory()) {        throw new FileNotFoundException("Couldn't find [" + request + "]");    }    File[] files = base.listFiles();    Arrays.sort(files, new Comparator<File>() {        public int compare(File o1, File o2) {            if (o1.isDirectory() != o2.isDirectory()) {                if (o1.isDirectory()) {                    return -1;                } else {                    return 1;                }            }            return o1.getName().compareToIgnoreCase(o2.getName());        }    });    for (File f : files) {        JSONObject o = new JSONObject();        o.put("file", f.getName());        o.put("type", f.isDirectory() ? "D" : "F");        o.put("path", f.getCanonicalPath());        filelist.add(o);    }    return JSONValue.toJSONString(filelist);}
compare
public int zookeeper_f104_0(File o1, File o2)
{    if (o1.isDirectory() != o2.isDirectory()) {        if (o1.isDirectory()) {            return -1;        } else {            return 1;        }    }    return o1.getName().compareToIgnoreCase(o2.getName());}
handleRequest
 Stringf105_1JsonRequest request) throws Exception
{    long starttime = 0;    long endtime = 0;    long period = 0;    FilterOp fo = null;    starttime = request.getNumber("start", 0);    endtime = request.getNumber("end", 0);    period = request.getNumber("period", 0);    String filterstr = request.getString("filter", "");    if (filterstr.length() > 0) {        fo = new FilterParser(filterstr).parse();    }    if (starttime == 0) {        starttime = source.getStartTime();    }    if (endtime == 0) {        if (period > 0) {            endtime = starttime + period;        } else {            endtime = starttime + DEFAULT_PERIOD;        }    }    if (LOG.isDebugEnabled()) {            }    LogIterator iterator = (fo != null) ? source.iterator(starttime, endtime, fo) : source.iterator(starttime, endtime);    return new JsonGenerator(iterator).toString();}
getNumber
public long zookeeper_f106_0(String name, long defaultnum)
{    String[] vals = (String[]) map.get(name);    if (vals == null || vals.length == 0) {        return defaultnum;    }    try {        return Long.valueOf(vals[0]);    } catch (NumberFormatException e) {        return defaultnum;    }}
getString
public String zookeeper_f107_0(String name, String defaultstr)
{    String[] vals = (String[]) map.get(name);    if (vals == null || vals.length == 0) {        return defaultstr;    } else {        return vals[0];    }}
doGet
protected void zookeeper_f108_0(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException
{    response.setContentType("text/plain;charset=utf-8");    response.setStatus(HttpServletResponse.SC_OK);    try {        String req = request.getRequestURI().substring(request.getServletPath().length());        response.getWriter().println(handleRequest(new JsonRequest(request)));    } catch (Exception e) {        JSONObject o = new JSONObject();        o.put("error", e.toString());        response.getWriter().println(JSONValue.toJSONString(o));    } catch (java.lang.OutOfMemoryError oom) {        JSONObject o = new JSONObject();        o.put("error", "Out of memory. Perhaps you've requested too many logs. Try narrowing you're filter criteria.");        response.getWriter().println(JSONValue.toJSONString(o));    }}
handleRequest
 Stringf109_1JsonRequest request) throws Exception
{    String output = "";    long starttime = 0;    long endtime = 0;    long period = 0;    starttime = request.getNumber("start", 0);    endtime = request.getNumber("end", 0);    period = request.getNumber("period", 0);    if (starttime == 0) {        starttime = source.getStartTime();    }    if (endtime == 0) {        if (period > 0) {            endtime = starttime + period;        } else {            endtime = source.getEndTime();        }    }    LogIterator iter = source.iterator(starttime, endtime);    JSONObject data = new JSONObject();    data.put("startTime", starttime);    data.put("endTime", endtime);    long size = 0;    size = iter.size();    data.put("numEntries", size);    if (LOG.isDebugEnabled()) {            }    iter.close();    return JSONValue.toJSONString(data);}
doGet
protected void zookeeper_f110_0(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException
{    String path = request.getRequestURI().substring(request.getServletPath().length());    InputStream resource = ClassLoader.getSystemResourceAsStream("org/apache/zookeeper/graph/resources" + path);    if (resource == null) {        response.getWriter().println(path + " not found!");        response.setStatus(HttpServletResponse.SC_NOT_FOUND);        return;    }    try {        while (resource.available() > 0) {            response.getWriter().write(resource.read());        }    } finally {        resource.close();    }        response.setStatus(HttpServletResponse.SC_OK);}
handleRequest
public String zookeeper_f111_0(JsonRequest request) throws Exception
{    long starttime = 0;    long endtime = 0;    long period = 0;    long scale = 0;    starttime = request.getNumber("start", 0);    endtime = request.getNumber("end", 0);    period = request.getNumber("period", 0);    if (starttime == 0) {        starttime = source.getStartTime();    }    if (endtime == 0) {        if (period > 0) {            endtime = starttime + period;        } else {            endtime = source.getEndTime();        }    }    String scalestr = request.getString("scale", "minutes");    if (scalestr.equals("seconds")) {        scale = MS_PER_SEC;    } else if (scalestr.equals("hours")) {        scale = MS_PER_HOUR;    } else {        scale = MS_PER_MIN;    }    LogIterator iter = source.iterator(starttime, endtime);    long current = 0;    long currentms = 0;    Set<Long> zxids_ms = new HashSet<Long>();    long zxidcount = 0;    JSONArray events = new JSONArray();    while (iter.hasNext()) {        LogEntry e = iter.next();        if (e.getType() != LogEntry.Type.TXN) {            continue;        }        TransactionEntry cxn = (TransactionEntry) e;        long ms = cxn.getTimestamp();        long inscale = ms / scale;        if (currentms != ms && currentms != 0) {            zxidcount += zxids_ms.size();            zxids_ms.clear();        }        if (inscale != current && current != 0) {            JSONObject o = new JSONObject();            o.put("time", current * scale);            o.put("count", zxidcount);            events.add(o);            zxidcount = 0;        }        current = inscale;        currentms = ms;        zxids_ms.add(cxn.getZxid());    }    JSONObject o = new JSONObject();    o.put("time", current * scale);    o.put("count", zxidcount);    events.add(o);    iter.close();    return JSONValue.toJSONString(events);}
getClientId
public long zookeeper_f112_0()
{    return (Long) getAttribute("client-id");}
getCxid
public long zookeeper_f113_0()
{    return (Long) getAttribute("cxid");}
getZxid
public long zookeeper_f114_0()
{    return (Long) getAttribute("zxid");}
getOp
public String zookeeper_f115_0()
{    return (String) getAttribute("operation");}
getExtra
public String zookeeper_f116_0()
{    return (String) getAttribute("extra");}
toString
public String zookeeper_f117_0()
{    return getTimestamp() + ":::session(0x" + Long.toHexString(getClientId()) + ") cxid(0x" + Long.toHexString(getCxid()) + ") zxid(0x" + Long.toHexString(getZxid()) + ") op(" + getOp() + ") extra(" + getExtra() + ")";}
getType
public Type zookeeper_f118_0()
{    return LogEntry.Type.TXN;}
overlapsRange
public boolean zookeeper_f119_0(long starttime, long endtime)
{    return (starttime <= this.endtime && endtime >= this.starttime);}
size
public long zookeeper_f120_0()
{    return size;}
getStartTime
public long zookeeper_f121_0()
{    return starttime;}
getEndTime
public long zookeeper_f122_0()
{    return endtime;}
getSkipList
public LogSkipList zookeeper_f123_0()
{    return skiplist;}
isTransactionFile
public static boolean zookeeper_f124_0(String file) throws IOException
{    RandomAccessFileReader reader = new RandomAccessFileReader(new File(file));    BinaryInputArchive logStream = new BinaryInputArchive(reader);    FileHeader fhdr = new FileHeader();    fhdr.deserialize(logStream, "fileheader");    reader.close();    return fhdr.getMagic() == FileTxnLog.TXNLOG_MAGIC;}
size
public long zookeeper_f125_0() throws IOException
{    if (this.endtime >= src.getEndTime()) {        return src.size() - skippedAtStart;    }    long pos = reader.getPosition();    LogEntry e;    LogSkipList.Mark lastseg = src.getSkipList().findMarkBefore(this.endtime);    reader.seek(lastseg.getBytes());        long count = lastseg.getEntriesSkipped() - skippedAtStart;    while ((e = readNextEntry()) != null) {        if (e.getTimestamp() > this.endtime) {            break;        }        count++;    }    reader.seek(pos);    ;    return count;}
readNextEntry
private LogEntryf126_1)
{    LogEntry e = null;    try {        long crcValue;        byte[] bytes;        try {            crcValue = logStream.readLong("crcvalue");            bytes = logStream.readBuffer("txnEntry");        } catch (EOFException ex) {            return null;        }        if (bytes.length == 0) {            return null;        }        Checksum crc = new Adler32();        crc.update(bytes, 0, bytes.length);        if (crcValue != crc.getValue()) {            throw new IOException("CRC doesn't match " + crcValue + " vs " + crc.getValue());        }        TxnHeader hdr = new TxnHeader();        Record r = SerializeUtils.deserializeTxn(bytes, hdr);        switch(hdr.getType()) {            case OpCode.createSession:                {                    e = new TransactionEntry(hdr.getTime(), hdr.getClientId(), hdr.getCxid(), hdr.getZxid(), "createSession");                }                break;            case OpCode.closeSession:                {                    e = new TransactionEntry(hdr.getTime(), hdr.getClientId(), hdr.getCxid(), hdr.getZxid(), "closeSession");                }                break;            case OpCode.create:                if (r != null) {                    CreateTxn create = (CreateTxn) r;                    String path = create.getPath();                    e = new TransactionEntry(hdr.getTime(), hdr.getClientId(), hdr.getCxid(), hdr.getZxid(), "create", path);                }                break;            case OpCode.setData:                if (r != null) {                    SetDataTxn set = (SetDataTxn) r;                    String path = set.getPath();                    e = new TransactionEntry(hdr.getTime(), hdr.getClientId(), hdr.getCxid(), hdr.getZxid(), "setData", path);                }                break;            case OpCode.setACL:                if (r != null) {                    SetACLTxn setacl = (SetACLTxn) r;                    String path = setacl.getPath();                    e = new TransactionEntry(hdr.getTime(), hdr.getClientId(), hdr.getCxid(), hdr.getZxid(), "setACL", path);                }                break;            case OpCode.error:                if (r != null) {                    ErrorTxn error = (ErrorTxn) r;                    e = new TransactionEntry(hdr.getTime(), hdr.getClientId(), hdr.getCxid(), hdr.getZxid(), "error", "Error: " + error.getErr());                }                break;            default:                                break;        }        if (logStream.readByte("EOR") != 'B') {            throw new EOFException("Last transaction was partial.");        }    } catch (Exception ex) {                return null;    }    return e;}
hasNext
public boolean zookeeper_f127_0()
{    return next != null;}
next
public LogEntry zookeeper_f128_0() throws NoSuchElementException
{    LogEntry ret = next;    LogEntry e = readNextEntry();    if (filter != null) {        try {            while (e != null && !filter.matches(e)) {                e = readNextEntry();            }        } catch (FilterException fe) {            throw new NoSuchElementException(fe.toString());        }    }    if (e != null && e.getTimestamp() < endtime) {        next = e;    } else {        next = null;    }    return ret;}
remove
public void zookeeper_f129_0() throws UnsupportedOperationException
{    throw new UnsupportedOperationException("remove not supported for Txn logs");}
close
public void zookeeper_f130_0() throws IOException
{    reader.close();}
iterator
public LogIterator zookeeper_f131_0(long starttime, long endtime) throws IllegalArgumentException
{    try {        return iterator(starttime, endtime, null);    } catch (FilterException fe) {                assert (false);        return null;    }}
iterator
public LogIterator zookeeper_f132_0(long starttime, long endtime, FilterOp filter) throws IllegalArgumentException, FilterException
{        if (endtime < starttime) {        throw new IllegalArgumentException("End time (" + endtime + ") must be greater or equal to starttime (" + starttime + ")");    }    return new TxnLogSourceIterator(this, starttime, endtime, filter);}
iterator
public LogIterator zookeeper_f133_0() throws IllegalArgumentException
{    return iterator(starttime, endtime + 1);}
toString
public String zookeeper_f134_0()
{    return "TxnLogSource(file=" + file + ", size=" + size + ", start=" + starttime + ", end=" + endtime + ")";}
main
public static void zookeeper_f135_0(String[] args) throws IOException, FilterException
{    TxnLogSource s = new TxnLogSource(args[0]);    System.out.println(s);    LogIterator iter;    if (args.length == 3) {        long starttime = Long.valueOf(args[1]);        long endtime = Long.valueOf(args[2]);        FilterOp fo = new FilterParser("(or (and (> zxid 0x2f0bd6f5e0) (< zxid 0x2f0bd6f5e9)) (= operation \"error\"))").parse();        System.out.println("fo: " + fo);        iter = s.iterator(starttime, endtime, fo);    } else {        iter = s.iterator();    }    System.out.println(iter);    while (iter.hasNext()) {        System.out.println(iter.next());    }    iter.close();}
join
public static Credentials zookeeper_f136_0(Credentials a, Credentials b)
{    Credentials result = new Credentials();    result.putAll(a);    result.putAll(b);    return result;}
getContext
public String zookeeper_f137_0()
{    return context;}
getHostPort
public String zookeeper_f138_0()
{    return hostPort.toString();}
getCredentials
public Credentials zookeeper_f139_0()
{    return credentials;}
setCredentials
public void zookeeper_f140_0(String c)
{    this.credentials = new Credentials(c);}
setZooKeeperAuthInfo
public void zookeeper_f141_0(String digest)
{    zookeeperAuth = new Credentials(digest);}
getZooKeeperAuthInfo
public final Credentials zookeeper_f142_0()
{    return zookeeperAuth;}
equals
public boolean zookeeper_f143_0(Object o)
{    Endpoint e = (Endpoint) o;    return context.equals(e.context);}
hashCode
public int zookeeper_f144_0()
{    return context.hashCode();}
toString
public String zookeeper_f145_0()
{    return String.format("<Endpoint %s %s>", context, hostPort.toString());}
getHost
public String zookeeper_f146_0()
{    return host;}
getPort
public int zookeeper_f147_0()
{    return port;}
equals
public boolean zookeeper_f148_0(Object o)
{    HostPort p = (HostPort) o;    return host.equals(p.host) && port == p.port;}
hashCode
public int zookeeper_f149_0()
{    return String.format("%s:%d", host, port).hashCode();}
toString
public String zookeeper_f150_0()
{    return original;}
extractCredentials
private void zookeeper_f151_0()
{    if (cfg.containsKey("rest.http.auth")) {        credentials = new Credentials(cfg.getProperty("rest.http.auth", ""));    }}
extractEndpoints
private void zookeeper_f152_0()
{    int count = 1;    while (true) {        String e = cfg.getProperty(String.format("rest.endpoint.%d", count), null);        if (e == null) {            break;        }        String[] parts = e.split(";");        if (parts.length != 2) {            count++;            continue;        }        Endpoint point = new Endpoint(parts[0], parts[1]);        String c = cfg.getProperty(String.format("rest.endpoint.%d.http.auth", count), "");        point.setCredentials(c);        String digest = cfg.getProperty(String.format("rest.endpoint.%d.zk.digest", count), "");        point.setZooKeeperAuthInfo(digest);        endpoints.add(point);        count++;    }}
getPort
public int zookeeper_f153_0()
{    return Integer.parseInt(cfg.getProperty("rest.port", "9998"));}
useSSL
public boolean zookeeper_f154_0()
{    return Boolean.valueOf(cfg.getProperty("rest.ssl", "false"));}
getEndpoints
public final Set<Endpoint> zookeeper_f155_0()
{    return endpoints;}
getCredentials
public final Credentials zookeeper_f156_0()
{    return credentials;}
getJKS
public String zookeeper_f157_0()
{    return cfg.getProperty("rest.ssl.jks");}
getJKS
public String zookeeper_f158_0(String def)
{    return cfg.getProperty("rest.ssl.jks", def);}
getJKSPassword
public String zookeeper_f159_0()
{    return cfg.getProperty("rest.ssl.jks.pass");}
doFilter
public void zookeeper_f160_0(ServletRequest req0, ServletResponse resp0, FilterChain chain) throws IOException, ServletException
{    HttpServletRequest request = (HttpServletRequest) req0;    HttpServletResponse response = (HttpServletResponse) resp0;    String authorization = request.getHeader("Authorization");    if (authorization != null) {        String[] c = parseAuthorization(authorization);        if (c != null && credentials.containsKey(c[0]) && credentials.get(c[0]).equals(c[1])) {            chain.doFilter(request, response);            return;        }    }    response.setHeader("WWW-Authenticate", "Basic realm=\"Restricted\"");    response.sendError(401);}
parseAuthorization
private String[] zookeeper_f161_0(String authorization)
{    String[] parts = authorization.split(" ");    if (parts.length == 2 && parts[0].equalsIgnoreCase("Basic")) {        String userPass = Base64.base64Decode(parts[1]);        int p = userPass.indexOf(":");        if (p != -1) {            return new String[] { userPass.substring(0, p), userPass.substring(p + 1) };        }    }    return null;}
init
public void zookeeper_f162_0(FilterConfig arg0) throws ServletException
{}
destroy
public void zookeeper_f163_0()
{}
hashCode
public int zookeeper_f164_0()
{    return path.hashCode();}
equals
public boolean zookeeper_f165_0(Object obj)
{    if (!(obj instanceof ZChildren)) {        return false;    }    ZChildren o = (ZChildren) obj;    return path.equals(o.path) && children.equals(o.children);}
toString
public String zookeeper_f166_0()
{    return "ZChildren(" + path + "," + children + ")";}
hashCode
public int zookeeper_f167_0()
{    return path.hashCode();}
equals
public boolean zookeeper_f168_0(Object obj)
{    if (!(obj instanceof ZChildrenJSON)) {        return false;    }    ZChildrenJSON o = (ZChildrenJSON) obj;    return path.equals(o.path) && children.equals(o.children);}
toString
public String zookeeper_f169_0()
{    return "ZChildrenJSON(" + path + "," + children + ")";}
hashCode
public int zookeeper_f170_0()
{    return path.hashCode();}
equals
public boolean zookeeper_f171_0(Object obj)
{    if (!(obj instanceof ZPath)) {        return false;    }    ZPath o = (ZPath) obj;    return path.equals(o.path);}
toString
public String zookeeper_f172_0()
{    return "ZPath(" + path + ")";}
hashCode
public int zookeeper_f173_0()
{    return id.hashCode();}
equals
public boolean zookeeper_f174_0(Object obj)
{    if (!(obj instanceof ZSession)) {        return false;    }    ZSession s = (ZSession) obj;    return id.equals(s.id);}
toString
public String zookeeper_f175_0()
{    return "ZSession(" + id + ")";}
hashCode
public int zookeeper_f176_0()
{    return path.hashCode();}
equals
public boolean zookeeper_f177_0(Object obj)
{    if (!(obj instanceof ZStat)) {        return false;    }    ZStat o = (ZStat) obj;    return toString().equals(o.toString());}
toString
public String zookeeper_f178_0()
{    return "ZStat(" + path + "," + "b64[" + (data64 == null ? null : new String(data64)) + "]," + dataUtf8 + ")";}
getContext
public JAXBContext zookeeper_f179_0(Class<?> objectType)
{    return (typesSet.contains(objectType)) ? context : null;}
toResponse
public Response zookeeper_f180_0(KeeperException e)
{    Response.Status status;    String message;    String path = e.getPath();    switch(e.code()) {        case AUTHFAILED:            status = Response.Status.UNAUTHORIZED;            message = path + " not authorized";            break;        case BADARGUMENTS:            status = Response.Status.BAD_REQUEST;            message = path + " bad arguments";            break;        case BADVERSION:            status = Response.Status.PRECONDITION_FAILED;            message = path + " bad version";            break;        case INVALIDACL:            status = Response.Status.BAD_REQUEST;            message = path + " invalid acl";            break;        case NODEEXISTS:            status = Response.Status.CONFLICT;            message = path + " already exists";            break;        case NONODE:            status = Response.Status.NOT_FOUND;            message = path + " not found";            break;        case NOTEMPTY:            status = Response.Status.CONFLICT;            message = path + " not empty";            break;        default:                        status = Response.Status.fromStatusCode(502);            message = "Error processing request for " + path + " : " + e.getMessage();    }    return Response.status(status).entity(new ZError(ui.getRequestUri().toString(), message)).build();}
toResponse
public Response zookeeper_f181_0(RuntimeException e)
{        if (e instanceof WebApplicationException) {        WebApplicationException ie = (WebApplicationException) e;        return ie.getResponse();    }    return Response.status(Response.Status.INTERNAL_SERVER_ERROR).entity(new ZError(ui.getRequestUri().toString(), "Error processing request due to " + e)).build();}
keepAliveSession
public Response zookeeper_f182_0(@PathParam("session") String session, @Context UriInfo ui, byte[] data)
{    if (!ZooKeeperService.isConnected(contextPath, session)) {        throwNotFound(session, ui);    }    ZooKeeperService.resetTimer(contextPath, session);    return Response.status(Response.Status.OK).build();}
createSession
public Responsef183_1@QueryParam("op") String op,f183_1"5")f183_1"expire") String expire, @Context UriInfo ui)
{    if (!op.equals("create")) {        throw new WebApplicationException(Response.status(Response.Status.BAD_REQUEST).entity(new ZError(ui.getRequestUri().toString(), "")).build());    }    int expireInSeconds;    try {        expireInSeconds = Integer.parseInt(expire);    } catch (NumberFormatException e) {        throw new WebApplicationException(Response.status(Response.Status.BAD_REQUEST).build());    }    String uuid = UUID.randomUUID().toString();    while (ZooKeeperService.isConnected(contextPath, uuid)) {        uuid = UUID.randomUUID().toString();    }        try {        ZooKeeperService.getClient(contextPath, uuid, expireInSeconds);    } catch (IOException e) {                throw new WebApplicationException(Response.status(Response.Status.INTERNAL_SERVER_ERROR).build());    }    URI uri = ui.getAbsolutePathBuilder().path(uuid).build();    return Response.created(uri).entity(new JSONWithPadding(new ZSession(uuid, uri.toString()))).build();}
deleteSession
public void zookeeper_f184_0(@PathParam("session") String session, @Context UriInfo ui)
{    ZooKeeperService.close(contextPath, session);}
throwNotFound
private static void zookeeper_f185_0(String session, UriInfo ui) throws WebApplicationException
{    throw new WebApplicationException(Response.status(Response.Status.NOT_FOUND).entity(new ZError(ui.getRequestUri().toString(), session + " not found")).build());}
getSize
public long zookeeper_f186_0(ZError t, Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType)
{    return -1;}
isWriteable
public boolean zookeeper_f187_0(Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType)
{    return ZError.class.isAssignableFrom(type);}
writeTo
public void zookeeper_f188_0(ZError t, Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType, MultivaluedMap<String, Object> httpHeaders, OutputStream os) throws IOException, WebApplicationException
{    PrintStream p = new PrintStream(os);    p.print("Request " + t.request + " failed due to " + t.message);    p.flush();}
ensurePathNotNull
private void zookeeper_f189_0(String path)
{    if (path == null) {        throw new IllegalArgumentException("Invalid path \"" + path + "\"");    }}
existsZNode
public Response zookeeper_f190_0(@PathParam("path") String path, @Context UriInfo ui) throws InterruptedException, KeeperException
{    Stat stat = zk.exists(path, false);    if (stat == null) {        throwNotFound(path, ui);    }    return Response.status(Response.Status.OK).build();}
existsZNodeAsOctet
public Response zookeeper_f191_0(@PathParam("path") String path, @Context UriInfo ui) throws InterruptedException, KeeperException
{    Stat stat = zk.exists(path, false);    if (stat == null) {        throwNotFound(path, ui);    }    return Response.status(Response.Status.NO_CONTENT).build();}
getZNodeListJSON
public Response zookeeper_f192_0(@PathParam("path") String path, zookeeper_f192_0("callback") String callback, zookeeper_f192_0("data") zookeeper_f192_0("view") String view, zookeeper_f192_0("base64") zookeeper_f192_0("dataformat") String dataformat, @Context UriInfo ui) throws InterruptedException, KeeperException
{    return getZNodeList(true, path, callback, view, dataformat, ui);}
getZNodeList
public Response zookeeper_f193_0(@PathParam("path") String path, zookeeper_f193_0("callback") String callback, zookeeper_f193_0("data") zookeeper_f193_0("view") String view, zookeeper_f193_0("base64") zookeeper_f193_0("dataformat") String dataformat, @Context UriInfo ui) throws InterruptedException, KeeperException
{    return getZNodeList(false, path, callback, view, dataformat, ui);}
getZNodeList
private Response zookeeper_f194_0(boolean json, String path, String callback, String view, String dataformat, UriInfo ui) throws InterruptedException, KeeperException
{    ensurePathNotNull(path);    if (view.equals("children")) {        List<String> children = new ArrayList<String>();        for (String child : zk.getChildren(path, false)) {            children.add(child);        }        Object child;        String childTemplate = ui.getAbsolutePath().toString();        if (!childTemplate.endsWith("/")) {            childTemplate += "/";        }        childTemplate += "{child}";        if (json) {            child = new ZChildrenJSON(path, ui.getAbsolutePath().toString(), childTemplate, children);        } else {            child = new ZChildren(path, ui.getAbsolutePath().toString(), childTemplate, children);        }        return Response.status(Response.Status.OK).entity(new JSONWithPadding(child, callback)).build();    } else {        Stat stat = new Stat();        byte[] data = zk.getData(path, false, stat);        byte[] data64;        String dataUtf8;        if (data == null) {            data64 = null;            dataUtf8 = null;        } else if (!dataformat.equals("utf8")) {            data64 = data;            dataUtf8 = null;        } else {            data64 = null;            dataUtf8 = new String(data);        }        ZStat zstat = new ZStat(path, ui.getAbsolutePath().toString(), data64, dataUtf8, stat.getCzxid(), stat.getMzxid(), stat.getCtime(), stat.getMtime(), stat.getVersion(), stat.getCversion(), stat.getAversion(), stat.getEphemeralOwner(), stat.getDataLength(), stat.getNumChildren(), stat.getPzxid());        return Response.status(Response.Status.OK).entity(new JSONWithPadding(zstat, callback)).build();    }}
getZNodeListAsOctet
public Response zookeeper_f195_0(@PathParam("path") String path) throws InterruptedException, KeeperException
{    ensurePathNotNull(path);    Stat stat = new Stat();    byte[] data = zk.getData(path, false, stat);    if (data == null) {        return Response.status(Response.Status.NO_CONTENT).build();    } else {        return Response.status(Response.Status.OK).entity(data).build();    }}
setZNode
public Response zookeeper_f196_0(@PathParam("path") String path, zookeeper_f196_0("callback") String callback, zookeeper_f196_0("-1") zookeeper_f196_0("version") String versionParam, zookeeper_f196_0("base64") zookeeper_f196_0("dataformat") String dataformat, zookeeper_f196_0("false") zookeeper_f196_0("null") String setNull, @Context UriInfo ui, byte[] data) throws InterruptedException, KeeperException
{    ensurePathNotNull(path);    int version;    try {        version = Integer.parseInt(versionParam);    } catch (NumberFormatException e) {        throw new WebApplicationException(Response.status(Response.Status.BAD_REQUEST).entity(new ZError(ui.getRequestUri().toString(), path + " bad version " + versionParam)).build());    }    if (setNull.equals("true")) {        data = null;    }    Stat stat = zk.setData(path, data, version);    ZStat zstat = new ZStat(path, ui.getAbsolutePath().toString(), null, null, stat.getCzxid(), stat.getMzxid(), stat.getCtime(), stat.getMtime(), stat.getVersion(), stat.getCversion(), stat.getAversion(), stat.getEphemeralOwner(), stat.getDataLength(), stat.getNumChildren(), stat.getPzxid());    return Response.status(Response.Status.OK).entity(new JSONWithPadding(zstat, callback)).build();}
setZNodeAsOctet
public void zookeeper_f197_0(@PathParam("path") String path, zookeeper_f197_0("-1") zookeeper_f197_0("version") String versionParam, zookeeper_f197_0("false") zookeeper_f197_0("null") String setNull, @Context UriInfo ui, byte[] data) throws InterruptedException, KeeperException
{    ensurePathNotNull(path);    int version;    try {        version = Integer.parseInt(versionParam);    } catch (NumberFormatException e) {        throw new WebApplicationException(Response.status(Response.Status.BAD_REQUEST).entity(new ZError(ui.getRequestUri().toString(), path + " bad version " + versionParam)).build());    }    if (setNull.equals("true")) {        data = null;    }    zk.setData(path, data, version);}
createZNode
public Response zookeeper_f198_0(@PathParam("path") String path, zookeeper_f198_0("callback") String callback, zookeeper_f198_0("create") zookeeper_f198_0("op") String op, zookeeper_f198_0("name") String name, zookeeper_f198_0("base64") zookeeper_f198_0("dataformat") String dataformat, zookeeper_f198_0("false") zookeeper_f198_0("null") String setNull, zookeeper_f198_0("false") zookeeper_f198_0("sequence") String sequence, zookeeper_f198_0("false") zookeeper_f198_0("ephemeral") String ephemeral, @Context UriInfo ui, byte[] data) throws InterruptedException, KeeperException
{    ensurePathNotNull(path);    if (path.equals("/")) {        path += name;    } else {        path += "/" + name;    }    if (!op.equals("create")) {        throw new WebApplicationException(Response.status(Response.Status.BAD_REQUEST).entity(new ZError(ui.getRequestUri().toString(), path + " bad operaton " + op)).build());    }    if (setNull.equals("true")) {        data = null;    }    CreateMode createMode;    if (sequence.equals("true")) {        if (ephemeral.equals("false")) {            createMode = CreateMode.PERSISTENT_SEQUENTIAL;        } else {            createMode = CreateMode.EPHEMERAL_SEQUENTIAL;        }    } else if (ephemeral.equals("false")) {        createMode = CreateMode.PERSISTENT;    } else {        createMode = CreateMode.EPHEMERAL;    }    String newPath = zk.create(path, data, Ids.OPEN_ACL_UNSAFE, createMode);    URI uri = ui.getAbsolutePathBuilder().path(newPath).build();    return Response.created(uri).entity(new JSONWithPadding(new ZPath(newPath, ui.getAbsolutePath().toString()))).build();}
createZNodeAsOctet
public Response zookeeper_f199_0(@PathParam("path") String path, zookeeper_f199_0("create") zookeeper_f199_0("op") String op, zookeeper_f199_0("name") String name, zookeeper_f199_0("false") zookeeper_f199_0("null") String setNull, zookeeper_f199_0("false") zookeeper_f199_0("sequence") String sequence, @Context UriInfo ui, byte[] data) throws InterruptedException, KeeperException
{    ensurePathNotNull(path);    if (path.equals("/")) {        path += name;    } else {        path += "/" + name;    }    if (!op.equals("create")) {        throw new WebApplicationException(Response.status(Response.Status.BAD_REQUEST).entity(new ZError(ui.getRequestUri().toString(), path + " bad operaton " + op)).build());    }    if (setNull.equals("true")) {        data = null;    }    CreateMode createMode;    if (sequence.equals("true")) {        createMode = CreateMode.PERSISTENT_SEQUENTIAL;    } else {        createMode = CreateMode.PERSISTENT;    }    String newPath = zk.create(path, data, Ids.OPEN_ACL_UNSAFE, createMode);    URI uri = ui.getAbsolutePathBuilder().path(newPath).build();    return Response.created(uri).entity(new ZPath(newPath, ui.getAbsolutePath().toString())).build();}
deleteZNode
public void zookeeper_f200_0(@PathParam("path") String path, zookeeper_f200_0("-1") zookeeper_f200_0("version") String versionParam, @Context UriInfo ui) throws InterruptedException, KeeperException
{    ensurePathNotNull(path);    int version;    try {        version = Integer.parseInt(versionParam);    } catch (NumberFormatException e) {        throw new WebApplicationException(Response.status(Response.Status.BAD_REQUEST).entity(new ZError(ui.getRequestUri().toString(), path + " bad version " + versionParam)).build());    }    zk.delete(path, version);}
throwNotFound
private static void zookeeper_f201_0(String path, UriInfo ui) throws WebApplicationException
{    throw new WebApplicationException(Response.status(Response.Status.NOT_FOUND).entity(new ZError(ui.getRequestUri().toString(), path + " not found")).build());}
start
public voidf202_1) throws IOException
{    System.out.println("Starting grizzly ...");    boolean useSSL = cfg.useSSL();    gws = new GrizzlyWebServer(cfg.getPort(), "/tmp/23cxv45345/2131xc2/", useSSL);    for (Endpoint e : cfg.getEndpoints()) {        ZooKeeperService.mapContext(e.getContext(), e);        gws.addGrizzlyAdapter(createJerseyAdapter(e), new String[] { e.getContext() });    }    if (useSSL) {        System.out.println("Starting SSL ...");        String jks = cfg.getJKS("keys/rest.jks");        String jksPassword = cfg.getJKSPassword();        SSLConfig sslConfig = new SSLConfig();        URL resource = getClass().getClassLoader().getResource(jks);        if (resource == null) {                        System.exit(2);        }        try {            sslConfig.setKeyStoreFile(new File(resource.toURI()).getAbsolutePath());        } catch (URISyntaxException e1) {                        System.exit(2);        }        sslConfig.setKeyStorePass(jksPassword);        gws.setSSLConfig(sslConfig);    }    gws.start();}
stop
public void zookeeper_f203_0()
{    gws.stop();    ZooKeeperService.closeAll();}
createJerseyAdapter
private ServletAdapter zookeeper_f204_0(Endpoint e)
{    ServletAdapter jersey = new ServletAdapter();    jersey.setServletInstance(new ServletContainer());    jersey.addInitParameter("com.sun.jersey.config.property.packages", "org.apache.zookeeper.server.jersey.resources");    jersey.setContextPath(e.getContext());    Credentials c = Credentials.join(e.getCredentials(), cfg.getCredentials());    if (!c.isEmpty()) {        jersey.addFilter(new HTTPBasicAuth(c), e.getContext() + "-basic-auth", null);    }    return jersey;}
main
public static void zookeeper_f205_0(String[] args) throws Exception
{    RestCfg cfg = new RestCfg("rest.properties");    final RestMain main = new RestMain(cfg);    main.start();    Runtime.getRuntime().addShutdownHook(new Thread() {        @Override        public void run() {            main.stop();            System.out.println("Got exit request. Bye.");        }    });    printEndpoints(cfg);    System.out.println("Server started.");}
run
public void zookeeper_f206_0()
{    main.stop();    System.out.println("Got exit request. Bye.");}
printEndpoints
private static void zookeeper_f207_0(RestCfg cfg)
{    int port = cfg.getPort();    for (Endpoint e : cfg.getEndpoints()) {        String context = e.getContext();        if (context.charAt(context.length() - 1) != '/') {            context += "/";        }        System.out.println(String.format("Started %s - WADL: http://localhost:%d%sapplication.wadl", context, port, context));    }}
process
public synchronized void zookeeper_f208_0(WatchedEvent event)
{    if (event.getState() == KeeperState.Expired) {        close(contextPath);    }}
run
public voidf209_1)
{    if (LOG.isInfoEnabled()) {            }    ZooKeeperService.close(contextPath, session);}
reset
public void zookeeper_f210_0()
{    timer.schedule(this, delay);}
mapContext
public static synchronized void zookeeper_f211_0(String contextPath, Endpoint e)
{    contextMap.put(contextPath, e);}
resetTimer
public static synchronized void zookeeper_f212_0(String contextPath, String session)
{    if (session != null) {        String uri = concat(contextPath, session);        SessionTimerTask t = zkSessionTimers.remove(uri);        t.cancel();        zkSessionTimers.put(uri, new SessionTimerTask(t));    }}
close
public static void zookeeper_f213_0(String contextPath)
{    close(contextPath, null);}
close
public static synchronized voidf214_1String contextPath, String session)
{    String uri = concat(contextPath, session);    TimerTask t = zkSessionTimers.remove(uri);    if (t != null) {        t.cancel();    }    ZooKeeper zk = zkMap.remove(uri);    if (zk == null) {        return;    }    try {        zk.close();    } catch (InterruptedException e) {            }}
closeAll
public static synchronized void zookeeper_f215_0()
{    Set<String> sessions = new TreeSet<String>(zkMap.keySet());    for (String key : sessions) {        close(key);    }}
isConnected
public static synchronized boolean zookeeper_f216_0(String contextPath, String session)
{    return zkMap.containsKey(concat(contextPath, session));}
getClient
public static ZooKeeper zookeeper_f217_0(String contextPath) throws IOException
{    return getClient(contextPath, null);}
getClient
public static ZooKeeper zookeeper_f218_0(String contextPath, String session) throws IOException
{    return getClient(contextPath, session, 5);}
getClient
public static synchronized ZooKeeperf219_1String contextPath, String session, int expireTime) throws IOException
{    final String connectionId = concat(contextPath, session);    ZooKeeper zk = zkMap.get(connectionId);    if (zk == null) {        if (LOG.isInfoEnabled()) {                    }        Endpoint e = contextMap.get(contextPath);        zk = new ZooKeeper(e.getHostPort(), 30000, new MyWatcher(connectionId));        for (Map.Entry<String, String> p : e.getZooKeeperAuthInfo().entrySet()) {            zk.addAuthInfo("digest", String.format("%s:%s", p.getKey(), p.getValue()).getBytes());        }        zkMap.put(connectionId, zk);                if (session != null) {            zkSessionTimers.put(connectionId, new SessionTimerTask(expireTime, session, contextPath, timer));        }    }    return zk;}
concat
private static String zookeeper_f220_0(String contextPath, String session)
{    if (session != null) {        return String.format("%s@%s", contextPath, session);    }    return contextPath;}
setUp
public void zookeeper_f221_0() throws Exception
{    RestCfg cfg = new RestCfg(new ByteArrayInputStream(String.format("rest.port=%s\n" + "rest.endpoint.1=%s;%s\n", GRIZZLY_PORT, CONTEXT_PATH, ZKHOSTPORT).getBytes()));    rest = new RestMain(cfg);    rest.start();    zk = new ZooKeeper(ZKHOSTPORT, 30000, new MyWatcher());    client = Client.create();    znodesr = client.resource(BASEURI).path("znodes/v1");    sessionsr = client.resource(BASEURI).path("sessions/v1/");}
tearDown
public void zookeeper_f222_0() throws Exception
{    client.destroy();    zk.close();    rest.stop();}
createBaseZNode
protected static String zookeeper_f223_0() throws Exception
{    ZooKeeper zk = new ZooKeeper(ZKHOSTPORT, 30000, new MyWatcher());    String baseZnode = zk.create("/test-", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);    zk.close();    return baseZnode;}
process
public void zookeeper_f224_0(WatchedEvent event)
{}
data
public static Collection<Object[]> zookeeper_f225_0() throws Exception
{    String baseZnode = Base.createBaseZNode();    return Arrays.asList(new Object[][] { { MediaType.APPLICATION_JSON, baseZnode, "foo bar", "utf8", ClientResponse.Status.CREATED, new ZPath(baseZnode + "/foo bar"), null, false }, { MediaType.APPLICATION_JSON, baseZnode, "c-t1", "utf8", ClientResponse.Status.CREATED, new ZPath(baseZnode + "/c-t1"), null, false }, { MediaType.APPLICATION_JSON, baseZnode, "c-t1", "utf8", ClientResponse.Status.CONFLICT, null, null, false }, { MediaType.APPLICATION_JSON, baseZnode, "c-t2", "utf8", ClientResponse.Status.CREATED, new ZPath(baseZnode + "/c-t2"), "".getBytes(), false }, { MediaType.APPLICATION_JSON, baseZnode, "c-t2", "utf8", ClientResponse.Status.CONFLICT, null, null, false }, { MediaType.APPLICATION_JSON, baseZnode, "c-t3", "utf8", ClientResponse.Status.CREATED, new ZPath(baseZnode + "/c-t3"), "foo".getBytes(), false }, { MediaType.APPLICATION_JSON, baseZnode, "c-t3", "utf8", ClientResponse.Status.CONFLICT, null, null, false }, { MediaType.APPLICATION_JSON, baseZnode, "c-t4", "base64", ClientResponse.Status.CREATED, new ZPath(baseZnode + "/c-t4"), "foo".getBytes(), false }, { MediaType.APPLICATION_JSON, baseZnode, "c-", "utf8", ClientResponse.Status.CREATED, new ZPath(baseZnode + "/c-"), null, true }, { MediaType.APPLICATION_JSON, baseZnode, "c-", "utf8", ClientResponse.Status.CREATED, new ZPath(baseZnode + "/c-"), null, true } });}
testCreate
public void zookeeper_f226_0() throws Exception
{    WebResource wr = znodesr.path(path).queryParam("dataformat", encoding).queryParam("name", name);    if (data == null) {        wr = wr.queryParam("null", "true");    }    if (sequence) {        wr = wr.queryParam("sequence", "true");    }    Builder builder = wr.accept(accept);    ClientResponse cr;    if (data == null) {        cr = builder.post(ClientResponse.class);    } else {        cr = builder.post(ClientResponse.class, data);    }    Assert.assertEquals(expectedStatus, cr.getClientResponseStatus());    if (expectedPath == null) {        return;    }    ZPath zpath = cr.getEntity(ZPath.class);    if (sequence) {        Assert.assertTrue(zpath.path.startsWith(expectedPath.path));        Assert.assertTrue(zpath.uri.startsWith(znodesr.path(path).toString()));    } else {        Assert.assertEquals(expectedPath, zpath);        Assert.assertEquals(znodesr.path(path).toString(), zpath.uri);    }        byte[] data = zk.getData(zpath.path, false, new Stat());    if (data == null && this.data == null) {        return;    } else if (data == null || this.data == null) {        Assert.assertEquals(data, this.data);    } else {        Assert.assertTrue(new String(data) + " == " + new String(this.data), Arrays.equals(data, this.data));    }}
process
public void zookeeper_f227_0(WatchedEvent event)
{}
data
public static Collection<Object[]> zookeeper_f228_0() throws Exception
{    String baseZnode = Base.createBaseZNode();    return Arrays.asList(new Object[][] { { baseZnode, baseZnode, ClientResponse.Status.NO_CONTENT }, { baseZnode, baseZnode, ClientResponse.Status.NO_CONTENT } });}
verify
public void zookeeper_f229_0(String type) throws Exception
{    if (expectedStatus != ClientResponse.Status.NOT_FOUND) {        zpath = zk.create(zpath, null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);    }    ClientResponse cr = znodesr.path(zpath).accept(type).type(type).delete(ClientResponse.class);    Assert.assertEquals(expectedStatus, cr.getClientResponseStatus());        Stat stat = zk.exists(zpath, false);    Assert.assertNull(stat);}
testDelete
public void zookeeper_f230_0() throws Exception
{    verify(MediaType.APPLICATION_OCTET_STREAM);    verify(MediaType.APPLICATION_JSON);    verify(MediaType.APPLICATION_XML);}
data
public static Collection<Object[]> zookeeper_f231_0() throws Exception
{    String baseZnode = Base.createBaseZNode();    return Arrays.asList(new Object[][] { { baseZnode, ClientResponse.Status.OK }, { baseZnode + "dkdk38383", ClientResponse.Status.NOT_FOUND } });}
verify
private void zookeeper_f232_0(String type)
{    ClientResponse cr = znodesr.path(path).accept(type).type(type).head();    if (type.equals(MediaType.APPLICATION_OCTET_STREAM) && expectedStatus == ClientResponse.Status.OK) {        Assert.assertEquals(ClientResponse.Status.NO_CONTENT, cr.getClientResponseStatus());    } else {        Assert.assertEquals(expectedStatus, cr.getClientResponseStatus());    }}
testExists
public void zookeeper_f233_0() throws Exception
{    verify(MediaType.APPLICATION_OCTET_STREAM);    verify(MediaType.APPLICATION_JSON);    verify(MediaType.APPLICATION_XML);}
data
public static Collection<Object[]> zookeeper_f234_0() throws Exception
{    String baseZnode = Base.createBaseZNode();    String baseZnode2 = Base.createBaseZNode();    String baseZnode3 = Base.createBaseZNode();    String baseZnode4 = Base.createBaseZNode();    String baseZnode5 = Base.createBaseZNode();    String baseZnode6 = Base.createBaseZNode();    return Arrays.asList(new Object[][] { { MediaType.APPLICATION_JSON, baseZnode + "abddkdkd", ClientResponse.Status.NOT_FOUND, null, null }, { MediaType.APPLICATION_XML, baseZnode + "abddkdkd", ClientResponse.Status.NOT_FOUND, null, null }, { MediaType.APPLICATION_JSON, baseZnode, ClientResponse.Status.OK, baseZnode, Arrays.asList(new String[] {}) }, { MediaType.APPLICATION_XML, baseZnode, ClientResponse.Status.OK, baseZnode, Arrays.asList(new String[] {}) }, { MediaType.APPLICATION_JSON, baseZnode, ClientResponse.Status.OK, baseZnode, Arrays.asList(new String[] { "c1" }) }, { MediaType.APPLICATION_XML, baseZnode4, ClientResponse.Status.OK, baseZnode4, Arrays.asList(new String[] { "c1" }) }, { MediaType.APPLICATION_JSON, baseZnode2, ClientResponse.Status.OK, baseZnode2, Arrays.asList(new String[] { "c1", "c2" }) }, { MediaType.APPLICATION_XML, baseZnode5, ClientResponse.Status.OK, baseZnode5, Arrays.asList(new String[] { "c1", "c2" }) }, { MediaType.APPLICATION_JSON, baseZnode3, ClientResponse.Status.OK, baseZnode3, Arrays.asList(new String[] { "c1", "c2", "c3", "c4" }) }, { MediaType.APPLICATION_XML, baseZnode6, ClientResponse.Status.OK, baseZnode6, Arrays.asList(new String[] { "c1", "c2", "c3", "c4" }) } });}
testGetChildren
public void zookeeper_f235_0() throws Exception
{    if (expectedChildren != null) {        for (String child : expectedChildren) {            zk.create(expectedPath + "/" + child, null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        }    }    ClientResponse cr = znodesr.path(path).queryParam("view", "children").accept(accept).get(ClientResponse.class);    Assert.assertEquals(expectedStatus, cr.getClientResponseStatus());    if (expectedChildren == null) {        return;    }    if (accept.equals(MediaType.APPLICATION_JSON)) {        ZChildrenJSON zchildren = cr.getEntity(ZChildrenJSON.class);        Collections.sort(expectedChildren);        Collections.sort(zchildren.children);        Assert.assertEquals(expectedChildren, zchildren.children);        Assert.assertEquals(znodesr.path(path).toString(), zchildren.uri);        Assert.assertEquals(znodesr.path(path).toString() + "/{child}", zchildren.child_uri_template);    } else if (accept.equals(MediaType.APPLICATION_XML)) {        ZChildren zchildren = cr.getEntity(ZChildren.class);        Collections.sort(expectedChildren);        Collections.sort(zchildren.children);        Assert.assertEquals(expectedChildren, zchildren.children);        Assert.assertEquals(znodesr.path(path).toString(), zchildren.uri);        Assert.assertEquals(znodesr.path(path).toString() + "/{child}", zchildren.child_uri_template);    } else {        Assert.fail("unknown accept type");    }}
data
public static Collection<Object[]> zookeeper_f236_0() throws Exception
{    String baseZnode = Base.createBaseZNode();    return Arrays.asList(new Object[][] { { MediaType.APPLICATION_JSON, baseZnode, "utf8", ClientResponse.Status.OK, new ZStat(baseZnode, null, null) }, { MediaType.APPLICATION_JSON, baseZnode, "utf8", ClientResponse.Status.OK, new ZStat(baseZnode, null, "") }, { MediaType.APPLICATION_JSON, baseZnode, "utf8", ClientResponse.Status.OK, new ZStat(baseZnode, null, "foo") }, { MediaType.APPLICATION_JSON, baseZnode, "base64", ClientResponse.Status.OK, new ZStat(baseZnode, null, null) }, { MediaType.APPLICATION_JSON, baseZnode, "base64", ClientResponse.Status.OK, new ZStat(baseZnode, "".getBytes(), null) }, { MediaType.APPLICATION_JSON, baseZnode, "base64", ClientResponse.Status.OK, new ZStat(baseZnode, "".getBytes(), null) }, { MediaType.APPLICATION_JSON, baseZnode, "base64", ClientResponse.Status.OK, new ZStat(baseZnode, "foo".getBytes(), null) }, { MediaType.APPLICATION_JSON, baseZnode + "abaddkdk", "utf8", ClientResponse.Status.NOT_FOUND, null }, { MediaType.APPLICATION_JSON, baseZnode + "abaddkdk", "base64", ClientResponse.Status.NOT_FOUND, null }, { MediaType.APPLICATION_XML, baseZnode, "utf8", ClientResponse.Status.OK, new ZStat(baseZnode, null, "foo") }, { MediaType.APPLICATION_XML, baseZnode, "base64", ClientResponse.Status.OK, new ZStat(baseZnode, "foo".getBytes(), null) }, { MediaType.APPLICATION_XML, baseZnode + "abaddkdk", "utf8", ClientResponse.Status.NOT_FOUND, null }, { MediaType.APPLICATION_XML, baseZnode + "abaddkdk", "base64", ClientResponse.Status.NOT_FOUND, null } });}
testGet
public void zookeeper_f237_0() throws Exception
{    if (expectedStat != null) {        if (expectedStat.data64 != null || expectedStat.dataUtf8 == null) {            zk.setData(expectedStat.path, expectedStat.data64, -1);        } else {            zk.setData(expectedStat.path, expectedStat.dataUtf8.getBytes(), -1);        }    }    ClientResponse cr = znodesr.path(path).queryParam("dataformat", encoding).accept(accept).get(ClientResponse.class);    Assert.assertEquals(expectedStatus, cr.getClientResponseStatus());    if (expectedStat == null) {        return;    }    ZStat zstat = cr.getEntity(ZStat.class);    Assert.assertEquals(expectedStat, zstat);    Assert.assertEquals(znodesr.path(path).toString(), zstat.uri);}
setUp
public static void zookeeper_f238_0()
{}
tearDown
public static void zookeeper_f239_0()
{}
testCreate
public void zookeeper_f240_0() throws Exception
{    String path = "/";    String name = "roottest-create";    byte[] data = "foo".getBytes();    WebResource wr = znodesr.path(path).queryParam("dataformat", "utf8").queryParam("name", name);    Builder builder = wr.accept(MediaType.APPLICATION_JSON);    ClientResponse cr;    cr = builder.post(ClientResponse.class, data);    Assert.assertEquals(ClientResponse.Status.CREATED, cr.getClientResponseStatus());    ZPath zpath = cr.getEntity(ZPath.class);    Assert.assertEquals(new ZPath(path + name), zpath);    Assert.assertEquals(znodesr.path(path).toString(), zpath.uri);        byte[] rdata = zk.getData(zpath.path, false, new Stat());    Assert.assertTrue(new String(rdata) + " == " + new String(data), Arrays.equals(rdata, data));}
createSession
private ZSession zookeeper_f241_0()
{    return createSession("30");}
createSession
private ZSession zookeeper_f242_0(String expire)
{    WebResource wr = sessionsr.queryParam("op", "create").queryParam("expire", expire);    Builder b = wr.accept(MediaType.APPLICATION_JSON);    ClientResponse cr = b.post(ClientResponse.class, null);    Assert.assertEquals(ClientResponse.Status.CREATED, cr.getClientResponseStatus());    return cr.getEntity(ZSession.class);}
testCreateNewSession
public void zookeeper_f243_0() throws JSONException
{    ZSession session = createSession();    Assert.assertEquals(session.id.length(), 36);        Assert.assertTrue(ZooKeeperService.isConnected(CONTEXT_PATH, session.id));}
testSessionExpires
public void zookeeper_f244_0() throws InterruptedException
{    ZSession session = createSession("1");        Assert.assertTrue(ZooKeeperService.isConnected(CONTEXT_PATH, session.id));        Thread.sleep(1500);    Assert.assertFalse(ZooKeeperService.isConnected(CONTEXT_PATH, session.id));}
testDeleteSession
public void zookeeper_f245_0()
{    ZSession session = createSession("30");    WebResource wr = sessionsr.path(session.id);    Builder b = wr.accept(MediaType.APPLICATION_JSON);    Assert.assertTrue(ZooKeeperService.isConnected(CONTEXT_PATH, session.id));    ClientResponse cr = b.delete(ClientResponse.class, null);    Assert.assertEquals(ClientResponse.Status.NO_CONTENT, cr.getClientResponseStatus());    Assert.assertFalse(ZooKeeperService.isConnected(CONTEXT_PATH, session.id));}
testSendHeartbeat
public void zookeeper_f246_0() throws InterruptedException
{    ZSession session = createSession("2");    Thread.sleep(1000);    WebResource wr = sessionsr.path(session.id);    Builder b = wr.accept(MediaType.APPLICATION_JSON);    ClientResponse cr = b.put(ClientResponse.class, null);    Assert.assertEquals(ClientResponse.Status.OK, cr.getClientResponseStatus());    Thread.sleep(1500);    Assert.assertTrue(ZooKeeperService.isConnected(CONTEXT_PATH, session.id));    Thread.sleep(1000);    Assert.assertFalse(ZooKeeperService.isConnected(CONTEXT_PATH, session.id));}
testCreateEphemeralZNode
public void zookeeper_f247_0() throws KeeperException, InterruptedException, IOException
{    ZSession session = createSession("30");    WebResource wr = znodesr.path("/").queryParam("op", "create").queryParam("name", "ephemeral-test").queryParam("ephemeral", "true").queryParam("session", session.id).queryParam("null", "true");    Builder b = wr.accept(MediaType.APPLICATION_JSON);    ClientResponse cr = b.post(ClientResponse.class);    Assert.assertEquals(ClientResponse.Status.CREATED, cr.getClientResponseStatus());    Stat stat = new Stat();    zk.getData("/ephemeral-test", false, stat);    ZooKeeper sessionZK = ZooKeeperService.getClient(CONTEXT_PATH, session.id);    Assert.assertEquals(stat.getEphemeralOwner(), sessionZK.getSessionId());}
process
public void zookeeper_f248_0(WatchedEvent event)
{}
data
public static Collection<Object[]> zookeeper_f249_0() throws Exception
{    String baseZnode = Base.createBaseZNode();    return Arrays.asList(new Object[][] { { MediaType.APPLICATION_JSON, baseZnode + "/s-t1", "utf8", ClientResponse.Status.OK, new ZStat(baseZnode + "/s-t1", null, null), null }, { MediaType.APPLICATION_JSON, baseZnode + "/s-t2", "utf8", ClientResponse.Status.OK, new ZStat(baseZnode + "/s-t2", null, null), new byte[0] }, { MediaType.APPLICATION_JSON, baseZnode + "/s-t3", "utf8", ClientResponse.Status.OK, new ZStat(baseZnode + "/s-t3", null, null), "foobar".getBytes() }, { MediaType.APPLICATION_JSON, baseZnode + "/s-t4", "base64", ClientResponse.Status.OK, new ZStat(baseZnode + "/s-t4", null, null), null }, { MediaType.APPLICATION_JSON, baseZnode + "/s-t5", "base64", ClientResponse.Status.OK, new ZStat(baseZnode + "/s-t5", null, null), new byte[0] }, { MediaType.APPLICATION_JSON, baseZnode + "/s-t6", "base64", ClientResponse.Status.OK, new ZStat(baseZnode + "/s-t6", null, null), "foobar".getBytes() }, { MediaType.APPLICATION_JSON, baseZnode + "/dkdkdkd", "utf8", ClientResponse.Status.NOT_FOUND, null, null }, { MediaType.APPLICATION_JSON, baseZnode + "/dkdkdkd", "base64", ClientResponse.Status.NOT_FOUND, null, null } });}
testSet
public void zookeeper_f250_0() throws Exception
{    if (expectedStat != null) {        zk.create(expectedStat.path, "initial".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    }    WebResource wr = znodesr.path(path).queryParam("dataformat", encoding);    if (data == null) {        wr = wr.queryParam("null", "true");    }    Builder builder = wr.accept(accept).type(MediaType.APPLICATION_OCTET_STREAM);    ClientResponse cr;    if (data == null) {        cr = builder.put(ClientResponse.class);    } else {                                        cr = builder.put(ClientResponse.class, new String(data));    }    Assert.assertEquals(expectedStatus, cr.getClientResponseStatus());    if (expectedStat == null) {        return;    }    ZStat zstat = cr.getEntity(ZStat.class);    Assert.assertEquals(expectedStat, zstat);        byte[] data = zk.getData(zstat.path, false, new Stat());    if (data == null && this.data == null) {        return;    } else if (data == null || this.data == null) {        Assert.fail((data == null ? null : new String(data)) + " == " + (this.data == null ? null : new String(this.data)));    } else {        Assert.assertTrue(new String(data) + " == " + new String(this.data), Arrays.equals(data, this.data));    }}
testApplicationWadl
public void zookeeper_f251_0()
{    WebResource r = client.resource(BASEURI);    String serviceWadl = r.path("application.wadl").accept(MediaTypes.WADL).get(String.class);    Assert.assertTrue("Something wrong. Returned wadl length not > 0.", serviceWadl.length() > 0);}
initComponents
private void zookeeper_f252_0()
{    setSize(toasterWidth, toasterHeight);    message.setFont(getToasterMessageFont());    JPanel externalPanel = new JPanel(new BorderLayout(1, 1));    externalPanel.setBackground(getBorderColor());    JPanel innerPanel = new JPanel(new BorderLayout(getMargin(), getMargin()));    innerPanel.setBackground(getToasterColor());    message.setBackground(getToasterColor());    message.setMargin(new Insets(2, 2, 2, 2));    message.setLineWrap(true);    message.setWrapStyleWord(true);    EtchedBorder etchedBorder = (EtchedBorder) BorderFactory.createEtchedBorder();    externalPanel.setBorder(etchedBorder);    externalPanel.add(innerPanel);    message.setForeground(getMessageColor());    innerPanel.add(iconLabel, BorderLayout.WEST);    innerPanel.add(message, BorderLayout.CENTER);    getContentPane().add(externalPanel);}
animate
public void zookeeper_f253_0()
{    (new Animation(this)).start();}
animateVertically
protected void zookeeper_f254_0(int posx, int fromY, int toY) throws InterruptedException
{    toaster.setLocation(posx, fromY);    if (toY < fromY) {        for (int i = fromY; i > toY; i -= step) {            toaster.setLocation(posx, i);            Thread.sleep(stepTime);        }    } else {        for (int i = fromY; i < toY; i += step) {            toaster.setLocation(posx, i);            Thread.sleep(stepTime);        }    }    toaster.setLocation(posx, toY);}
run
public void zookeeper_f255_0()
{    try {        boolean animateFromBottom = true;        GraphicsEnvironment ge = GraphicsEnvironment.getLocalGraphicsEnvironment();        Rectangle screenRect = ge.getMaximumWindowBounds();        int screenHeight = (int) screenRect.height;        int startYPosition;        int stopYPosition;        if (screenRect.y > 0) {                        animateFromBottom = false;        }        maxToasterInSceen = screenHeight / toasterHeight;        int posx = (int) screenRect.width - toasterWidth - 1;        toaster.setLocation(posx, screenHeight);        toaster.setVisible(true);        if (useAlwaysOnTop) {            toaster.setAlwaysOnTop(true);        }        if (animateFromBottom) {            startYPosition = screenHeight;            stopYPosition = startYPosition - toasterHeight - 1;            if (currentNumberOfToaster > 0) {                stopYPosition = stopYPosition - (maxToaster % maxToasterInSceen * toasterHeight);            } else {                maxToaster = 0;            }        } else {            startYPosition = screenRect.y - toasterHeight;            stopYPosition = screenRect.y;            if (currentNumberOfToaster > 0) {                stopYPosition = stopYPosition + (maxToaster % maxToasterInSceen * toasterHeight);            } else {                maxToaster = 0;            }        }        currentNumberOfToaster++;        maxToaster++;        animateVertically(posx, startYPosition, stopYPosition);        Thread.sleep(displayTime);        animateVertically(posx, stopYPosition, startYPosition);        currentNumberOfToaster--;        toaster.setVisible(false);        toaster.dispose();    } catch (Exception e) {        e.printStackTrace();    }}
showToaster
public void zookeeper_f256_0(Icon icon, String msg)
{    SingleToaster singleToaster = new SingleToaster();    if (icon != null) {        singleToaster.iconLabel.setIcon(icon);    }    singleToaster.message.setText(msg);    singleToaster.animate();}
showToaster
public void zookeeper_f257_0(String msg)
{    showToaster(null, msg);}
getToasterMessageFont
public Font zookeeper_f258_0()
{        return font;}
setToasterMessageFont
public void zookeeper_f259_0(Font f)
{    font = f;}
getBorderColor
public Color zookeeper_f260_0()
{    return borderColor;}
setBorderColor
public void zookeeper_f261_0(Color borderColor)
{    this.borderColor = borderColor;}
getDisplayTime
public int zookeeper_f262_0()
{    return displayTime;}
setDisplayTime
public void zookeeper_f263_0(int displayTime)
{    this.displayTime = displayTime;}
getMargin
public int zookeeper_f264_0()
{    return margin;}
setMargin
public void zookeeper_f265_0(int margin)
{    this.margin = margin;}
getMessageColor
public Color zookeeper_f266_0()
{    return messageColor;}
setMessageColor
public void zookeeper_f267_0(Color messageColor)
{    this.messageColor = messageColor;}
getStep
public int zookeeper_f268_0()
{    return step;}
setStep
public void zookeeper_f269_0(int step)
{    this.step = step;}
getStepTime
public int zookeeper_f270_0()
{    return stepTime;}
setStepTime
public void zookeeper_f271_0(int stepTime)
{    this.stepTime = stepTime;}
getToasterColor
public Color zookeeper_f272_0()
{    return toasterColor;}
setToasterColor
public void zookeeper_f273_0(Color toasterColor)
{    this.toasterColor = toasterColor;}
getToasterHeight
public int zookeeper_f274_0()
{    return toasterHeight;}
setToasterHeight
public void zookeeper_f275_0(int toasterHeight)
{    this.toasterHeight = toasterHeight;}
getToasterWidth
public int zookeeper_f276_0()
{    return toasterWidth;}
setToasterWidth
public void zookeeper_f277_0(int toasterWidth)
{    this.toasterWidth = toasterWidth;}
decryptData
public String zookeeper_f278_0(byte[] encrypted) throws Exception
{    return new String(encrypted);}
encryptData
public byte[] zookeeper_f279_0(String data) throws Exception
{    if (data == null) {        return new byte[0];    }    return data.getBytes();}
actionPerformed
public void zookeeper_f280_0(ActionEvent e)
{    final List<String> selectedNodes = treeViewer.getSelectedNodes();    if (selectedNodes.size() == 1) {        final String nodeName = JOptionPane.showInputDialog(panel, "Please Enter a name for the new node", "Create Node", JOptionPane.INFORMATION_MESSAGE);        if (nodeName != null && nodeName.length() > 0) {            SwingWorker<Boolean, Void> worker = new SwingWorker<Boolean, Void>() {                @Override                protected Boolean doInBackground() throws Exception {                    return zooInspectorManager.createNode(selectedNodes.get(0), nodeName);                }                @Override                protected void done() {                    treeViewer.refreshView();                }            };            worker.execute();        }    } else {        JOptionPane.showMessageDialog(panel, "Please select 1 parent node for the new node.");    }}
doInBackground
protected Boolean zookeeper_f281_0() throws Exception
{    return zooInspectorManager.createNode(selectedNodes.get(0), nodeName);}
done
protected void zookeeper_f282_0()
{    treeViewer.refreshView();}
actionPerformed
public void zookeeper_f283_0(ActionEvent e)
{    final List<String> selectedNodes = treeViewer.getSelectedNodes();    if (selectedNodes.size() == 0) {        JOptionPane.showMessageDialog(parentPanel, "Please select at least 1 node to be deleted");    } else {        int answer = JOptionPane.showConfirmDialog(parentPanel, "Are you sure you want to delete the selected nodes?" + "(This action cannot be reverted)", "Confirm Delete", JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE);        if (answer == JOptionPane.YES_OPTION) {            SwingWorker<Boolean, Void> worker = new SwingWorker<Boolean, Void>() {                @Override                protected Boolean doInBackground() throws Exception {                    for (String nodePath : selectedNodes) {                        zooInspectorManager.deleteNode(nodePath);                    }                    return true;                }                @Override                protected void done() {                    treeViewer.refreshView();                }            };            worker.execute();        }    }}
doInBackground
protected Boolean zookeeper_f284_0() throws Exception
{    for (String nodePath : selectedNodes) {        zooInspectorManager.deleteNode(nodePath);    }    return true;}
done
protected void zookeeper_f285_0()
{    treeViewer.refreshView();}
find
public URL zookeeper_f286_0(String name)
{    String iconPath = buildIconPath(name);    URL iconUrl = findInPaths(iconPath);    if (null != iconUrl)        return iconUrl;    iconUrl = getClass().getResource(iconPath);    if (null != iconUrl)        return iconUrl;    if (!name.equals(FALLBACK_ICON))        return find(FALLBACK_ICON);    return null;}
get
public ImageIcon zookeeper_f287_0(String name, String description)
{    URL iconUrl = find(name);    if (null == iconUrl) {        ImageIcon icon = new ImageIcon();        icon.setDescription(description);        return icon;    } else {        return new ImageIcon(iconUrl, description);    }}
findInPaths
private URL zookeeper_f288_0(String iconPath)
{    for (String dataDir : DEFAULT_XDG_DATA_DIRS) {        File file = new File(dataDir + iconPath);        if (file.exists()) {            try {                return file.toURI().toURL();            } catch (MalformedURLException e) {                LoggerFactory.getLogger().warn(e.toString());            }        }    }    return null;}
buildIconPath
private String zookeeper_f289_0(String name)
{    return "/icons/" + theme + "/" + size + "/" + name + ".png";}
getTitle
public String zookeeper_f290_0()
{    return "Node ACLs";}
nodeSelectionChanged
public void zookeeper_f291_0(List<String> selectedNodes)
{    this.aclDataPanel.removeAll();    if (selectedNodes.size() > 0) {        this.selectedNode = selectedNodes.get(0);        SwingWorker<List<Map<String, String>>, Void> worker = new SwingWorker<List<Map<String, String>>, Void>() {            @Override            protected List<Map<String, String>> doInBackground() throws Exception {                return NodeViewerACL.this.zooInspectorManager.getACLs(NodeViewerACL.this.selectedNode);            }            @Override            protected void done() {                List<Map<String, String>> acls = null;                try {                    acls = get();                } catch (InterruptedException e) {                    acls = new ArrayList<Map<String, String>>();                    LoggerFactory.getLogger().error("Error retrieving ACL Information for node: " + NodeViewerACL.this.selectedNode, e);                } catch (ExecutionException e) {                    acls = new ArrayList<Map<String, String>>();                    LoggerFactory.getLogger().error("Error retrieving ACL Information for node: " + NodeViewerACL.this.selectedNode, e);                }                aclDataPanel.setLayout(new GridBagLayout());                int j = 0;                for (Map<String, String> data : acls) {                    int rowPos = 2 * j + 1;                    JPanel aclPanel = new JPanel();                    aclPanel.setBorder(BorderFactory.createLineBorder(Color.BLACK));                    aclPanel.setBackground(Color.WHITE);                    aclPanel.setLayout(new GridBagLayout());                    int i = 0;                    for (Map.Entry<String, String> entry : data.entrySet()) {                        int rowPosACL = 2 * i + 1;                        JLabel label = new JLabel(entry.getKey());                        JTextField text = new JTextField(entry.getValue());                        text.setEditable(false);                        GridBagConstraints c1 = new GridBagConstraints();                        c1.gridx = 1;                        c1.gridy = rowPosACL;                        c1.gridwidth = 1;                        c1.gridheight = 1;                        c1.weightx = 0;                        c1.weighty = 0;                        c1.anchor = GridBagConstraints.NORTHWEST;                        c1.fill = GridBagConstraints.BOTH;                        c1.insets = new Insets(5, 5, 5, 5);                        c1.ipadx = 0;                        c1.ipady = 0;                        aclPanel.add(label, c1);                        GridBagConstraints c2 = new GridBagConstraints();                        c2.gridx = 3;                        c2.gridy = rowPosACL;                        c2.gridwidth = 1;                        c2.gridheight = 1;                        c2.weightx = 0;                        c2.weighty = 0;                        c2.anchor = GridBagConstraints.NORTHWEST;                        c2.fill = GridBagConstraints.BOTH;                        c2.insets = new Insets(5, 5, 5, 5);                        c2.ipadx = 0;                        c2.ipady = 0;                        aclPanel.add(text, c2);                        i++;                    }                    GridBagConstraints c = new GridBagConstraints();                    c.gridx = 1;                    c.gridy = rowPos;                    c.gridwidth = 1;                    c.gridheight = 1;                    c.weightx = 1;                    c.weighty = 1;                    c.anchor = GridBagConstraints.NORTHWEST;                    c.fill = GridBagConstraints.NONE;                    c.insets = new Insets(5, 5, 5, 5);                    c.ipadx = 0;                    c.ipady = 0;                    aclDataPanel.add(aclPanel, c);                }                NodeViewerACL.this.aclDataPanel.revalidate();                NodeViewerACL.this.aclDataPanel.repaint();            }        };        worker.execute();    }}
doInBackground
protected List<Map<String, String>> zookeeper_f292_0() throws Exception
{    return NodeViewerACL.this.zooInspectorManager.getACLs(NodeViewerACL.this.selectedNode);}
done
protected void zookeeper_f293_0()
{    List<Map<String, String>> acls = null;    try {        acls = get();    } catch (InterruptedException e) {        acls = new ArrayList<Map<String, String>>();        LoggerFactory.getLogger().error("Error retrieving ACL Information for node: " + NodeViewerACL.this.selectedNode, e);    } catch (ExecutionException e) {        acls = new ArrayList<Map<String, String>>();        LoggerFactory.getLogger().error("Error retrieving ACL Information for node: " + NodeViewerACL.this.selectedNode, e);    }    aclDataPanel.setLayout(new GridBagLayout());    int j = 0;    for (Map<String, String> data : acls) {        int rowPos = 2 * j + 1;        JPanel aclPanel = new JPanel();        aclPanel.setBorder(BorderFactory.createLineBorder(Color.BLACK));        aclPanel.setBackground(Color.WHITE);        aclPanel.setLayout(new GridBagLayout());        int i = 0;        for (Map.Entry<String, String> entry : data.entrySet()) {            int rowPosACL = 2 * i + 1;            JLabel label = new JLabel(entry.getKey());            JTextField text = new JTextField(entry.getValue());            text.setEditable(false);            GridBagConstraints c1 = new GridBagConstraints();            c1.gridx = 1;            c1.gridy = rowPosACL;            c1.gridwidth = 1;            c1.gridheight = 1;            c1.weightx = 0;            c1.weighty = 0;            c1.anchor = GridBagConstraints.NORTHWEST;            c1.fill = GridBagConstraints.BOTH;            c1.insets = new Insets(5, 5, 5, 5);            c1.ipadx = 0;            c1.ipady = 0;            aclPanel.add(label, c1);            GridBagConstraints c2 = new GridBagConstraints();            c2.gridx = 3;            c2.gridy = rowPosACL;            c2.gridwidth = 1;            c2.gridheight = 1;            c2.weightx = 0;            c2.weighty = 0;            c2.anchor = GridBagConstraints.NORTHWEST;            c2.fill = GridBagConstraints.BOTH;            c2.insets = new Insets(5, 5, 5, 5);            c2.ipadx = 0;            c2.ipady = 0;            aclPanel.add(text, c2);            i++;        }        GridBagConstraints c = new GridBagConstraints();        c.gridx = 1;        c.gridy = rowPos;        c.gridwidth = 1;        c.gridheight = 1;        c.weightx = 1;        c.weighty = 1;        c.anchor = GridBagConstraints.NORTHWEST;        c.fill = GridBagConstraints.NONE;        c.insets = new Insets(5, 5, 5, 5);        c.ipadx = 0;        c.ipady = 0;        aclDataPanel.add(aclPanel, c);    }    NodeViewerACL.this.aclDataPanel.revalidate();    NodeViewerACL.this.aclDataPanel.repaint();}
setZooInspectorManager
public void zookeeper_f294_0(ZooInspectorNodeManager zooInspectorManager)
{    this.zooInspectorManager = zooInspectorManager;}
actionPerformed
public void zookeeper_f295_0(ActionEvent e)
{    if (selectedNode != null) {        if (JOptionPane.showConfirmDialog(NodeViewerData.this, "Are you sure you want to save this node?" + " (this action cannot be reverted)", "Confirm Save", JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE) == JOptionPane.YES_OPTION) {            zooInspectorManager.setData(selectedNode, dataArea.getText());        }    }}
getTitle
public String zookeeper_f296_0()
{    return "Node Data";}
nodeSelectionChanged
public void zookeeper_f297_0(List<String> selectedNodes)
{    if (selectedNodes.size() > 0) {        this.selectedNode = selectedNodes.get(0);        SwingWorker<String, Void> worker = new SwingWorker<String, Void>() {            @Override            protected String doInBackground() throws Exception {                return NodeViewerData.this.zooInspectorManager.getData(NodeViewerData.this.selectedNode);            }            @Override            protected void done() {                String data = "";                try {                    data = get();                } catch (InterruptedException e) {                    LoggerFactory.getLogger().error("Error retrieving data for node: " + NodeViewerData.this.selectedNode, e);                } catch (ExecutionException e) {                    LoggerFactory.getLogger().error("Error retrieving data for node: " + NodeViewerData.this.selectedNode, e);                }                NodeViewerData.this.dataArea.setText(data);            }        };        worker.execute();    }}
doInBackground
protected String zookeeper_f298_0() throws Exception
{    return NodeViewerData.this.zooInspectorManager.getData(NodeViewerData.this.selectedNode);}
done
protected void zookeeper_f299_0()
{    String data = "";    try {        data = get();    } catch (InterruptedException e) {        LoggerFactory.getLogger().error("Error retrieving data for node: " + NodeViewerData.this.selectedNode, e);    } catch (ExecutionException e) {        LoggerFactory.getLogger().error("Error retrieving data for node: " + NodeViewerData.this.selectedNode, e);    }    NodeViewerData.this.dataArea.setText(data);}
setZooInspectorManager
public void zookeeper_f300_0(ZooInspectorNodeManager zooInspectorManager)
{    this.zooInspectorManager = zooInspectorManager;}
getTitle
public String zookeeper_f301_0()
{    return "Node Metadata";}
nodeSelectionChanged
public void zookeeper_f302_0(List<String> selectedNodes)
{    this.metaDataPanel.removeAll();    if (selectedNodes.size() > 0) {        this.selectedNode = selectedNodes.get(0);        SwingWorker<Map<String, String>, Void> worker = new SwingWorker<Map<String, String>, Void>() {            @Override            protected Map<String, String> doInBackground() throws Exception {                return NodeViewerMetaData.this.zooInspectorManager.getNodeMeta(NodeViewerMetaData.this.selectedNode);            }            @Override            protected void done() {                Map<String, String> data = null;                try {                    data = get();                } catch (InterruptedException e) {                    data = new HashMap<String, String>();                    LoggerFactory.getLogger().error("Error retrieving meta data for node: " + NodeViewerMetaData.this.selectedNode, e);                } catch (ExecutionException e) {                    data = new HashMap<String, String>();                    LoggerFactory.getLogger().error("Error retrieving meta data for node: " + NodeViewerMetaData.this.selectedNode, e);                }                NodeViewerMetaData.this.metaDataPanel.setLayout(new GridBagLayout());                JPanel infoPanel = new JPanel();                infoPanel.setBackground(Color.WHITE);                infoPanel.setLayout(new GridBagLayout());                int i = 0;                int rowPos = 0;                for (Map.Entry<String, String> entry : data.entrySet()) {                    rowPos = 2 * i + 1;                    JLabel label = new JLabel(entry.getKey());                    JTextField text = new JTextField(entry.getValue());                    text.setEditable(false);                    GridBagConstraints c1 = new GridBagConstraints();                    c1.gridx = 0;                    c1.gridy = rowPos;                    c1.gridwidth = 1;                    c1.gridheight = 1;                    c1.weightx = 0;                    c1.weighty = 0;                    c1.anchor = GridBagConstraints.WEST;                    c1.fill = GridBagConstraints.HORIZONTAL;                    c1.insets = new Insets(5, 5, 5, 5);                    c1.ipadx = 0;                    c1.ipady = 0;                    infoPanel.add(label, c1);                    GridBagConstraints c2 = new GridBagConstraints();                    c2.gridx = 2;                    c2.gridy = rowPos;                    c2.gridwidth = 1;                    c2.gridheight = 1;                    c2.weightx = 0;                    c2.weighty = 0;                    c2.anchor = GridBagConstraints.WEST;                    c2.fill = GridBagConstraints.HORIZONTAL;                    c2.insets = new Insets(5, 5, 5, 5);                    c2.ipadx = 0;                    c2.ipady = 0;                    infoPanel.add(text, c2);                    i++;                }                GridBagConstraints c = new GridBagConstraints();                c.gridx = 1;                c.gridy = rowPos;                c.gridwidth = 1;                c.gridheight = 1;                c.weightx = 1;                c.weighty = 1;                c.anchor = GridBagConstraints.NORTHWEST;                c.fill = GridBagConstraints.NONE;                c.insets = new Insets(5, 5, 5, 5);                c.ipadx = 0;                c.ipady = 0;                NodeViewerMetaData.this.metaDataPanel.add(infoPanel, c);                NodeViewerMetaData.this.metaDataPanel.revalidate();                NodeViewerMetaData.this.metaDataPanel.repaint();            }        };        worker.execute();    }}
doInBackground
protected Map<String, String> zookeeper_f303_0() throws Exception
{    return NodeViewerMetaData.this.zooInspectorManager.getNodeMeta(NodeViewerMetaData.this.selectedNode);}
done
protected void zookeeper_f304_0()
{    Map<String, String> data = null;    try {        data = get();    } catch (InterruptedException e) {        data = new HashMap<String, String>();        LoggerFactory.getLogger().error("Error retrieving meta data for node: " + NodeViewerMetaData.this.selectedNode, e);    } catch (ExecutionException e) {        data = new HashMap<String, String>();        LoggerFactory.getLogger().error("Error retrieving meta data for node: " + NodeViewerMetaData.this.selectedNode, e);    }    NodeViewerMetaData.this.metaDataPanel.setLayout(new GridBagLayout());    JPanel infoPanel = new JPanel();    infoPanel.setBackground(Color.WHITE);    infoPanel.setLayout(new GridBagLayout());    int i = 0;    int rowPos = 0;    for (Map.Entry<String, String> entry : data.entrySet()) {        rowPos = 2 * i + 1;        JLabel label = new JLabel(entry.getKey());        JTextField text = new JTextField(entry.getValue());        text.setEditable(false);        GridBagConstraints c1 = new GridBagConstraints();        c1.gridx = 0;        c1.gridy = rowPos;        c1.gridwidth = 1;        c1.gridheight = 1;        c1.weightx = 0;        c1.weighty = 0;        c1.anchor = GridBagConstraints.WEST;        c1.fill = GridBagConstraints.HORIZONTAL;        c1.insets = new Insets(5, 5, 5, 5);        c1.ipadx = 0;        c1.ipady = 0;        infoPanel.add(label, c1);        GridBagConstraints c2 = new GridBagConstraints();        c2.gridx = 2;        c2.gridy = rowPos;        c2.gridwidth = 1;        c2.gridheight = 1;        c2.weightx = 0;        c2.weighty = 0;        c2.anchor = GridBagConstraints.WEST;        c2.fill = GridBagConstraints.HORIZONTAL;        c2.insets = new Insets(5, 5, 5, 5);        c2.ipadx = 0;        c2.ipady = 0;        infoPanel.add(text, c2);        i++;    }    GridBagConstraints c = new GridBagConstraints();    c.gridx = 1;    c.gridy = rowPos;    c.gridwidth = 1;    c.gridheight = 1;    c.weightx = 1;    c.weighty = 1;    c.anchor = GridBagConstraints.NORTHWEST;    c.fill = GridBagConstraints.NONE;    c.insets = new Insets(5, 5, 5, 5);    c.ipadx = 0;    c.ipady = 0;    NodeViewerMetaData.this.metaDataPanel.add(infoPanel, c);    NodeViewerMetaData.this.metaDataPanel.revalidate();    NodeViewerMetaData.this.metaDataPanel.repaint();}
setZooInspectorManager
public void zookeeper_f305_0(ZooInspectorNodeManager zooInspectorManager)
{    this.zooInspectorManager = zooInspectorManager;}
getTransferData
public Object zookeeper_f306_0(DataFlavor flavor) throws UnsupportedFlavorException, IOException
{    if (flavor.equals(nodeViewerDataFlavor)) {        return this.getClass().getCanonicalName();    } else {        return null;    }}
getTransferDataFlavors
public DataFlavor[] zookeeper_f307_0()
{    return new DataFlavor[] { nodeViewerDataFlavor };}
isDataFlavorSupported
public boolean zookeeper_f308_0(DataFlavor flavor)
{    return flavor.equals(nodeViewerDataFlavor);}
hashCode
public int zookeeper_f309_0()
{    final int prime = 31;    int result = 1;    result = prime * result + ((getTitle() == null) ? 0 : getTitle().hashCode());    return result;}
equals
public boolean zookeeper_f310_0(Object obj)
{    if (this == obj)        return true;    if (obj == null)        return false;    if (getClass() != obj.getClass())        return false;    ZooInspectorNodeViewer other = (ZooInspectorNodeViewer) obj;    if (getClass().getCanonicalName() != other.getClass().getCanonicalName()) {        return false;    }    if (getTitle() == null) {        if (other.getTitle() != null)            return false;    } else if (!getTitle().equals(other.getTitle()))        return false;    return true;}
addActionListener
public void zookeeper_f311_0(Button button, ActionListener actionListener)
{    buttons.get(button).addActionListener(actionListener);}
getJToolBar
public JToolBar zookeeper_f312_0()
{    return toolbar;}
toggleButtons
public void zookeeper_f313_0(boolean connected)
{    for (Button button : buttonsToToggle) {        buttons.get(button).setEnabled(connected != button.enabled);    }}
init
private void zookeeper_f314_0()
{    toolbar.setFloatable(false);    for (Button button : Button.values()) {        JButton jbutton = button.createJButton(iconResource);        buttons.put(button, jbutton);        toolbar.add(jbutton);    }}
createJButton
public JButton zookeeper_f315_0(IconResource iconResource)
{    JButton jbutton = new JButton(iconResource.get(icon, toolTip));    jbutton.setEnabled(enabled);    jbutton.setToolTipText(toolTip);    return jbutton;}
actionPerformed
public void zookeeper_f316_0(ActionEvent e)
{    ZooInspectorAboutDialog.this.dispose();}
actionPerformed
public void zookeeper_f317_0(ActionEvent e)
{    int result = fileChooser.showOpenDialog(ZooInspectorConnectionPropertiesDialog.this);    if (result == JFileChooser.APPROVE_OPTION) {        File propsFilePath = fileChooser.getSelectedFile();        Properties props = new Properties();        try {            FileReader reader = new FileReader(propsFilePath);            try {                props.load(reader);                loadConnectionProps(props);            } finally {                reader.close();            }        } catch (IOException ex) {            LoggerFactory.getLogger().error("An Error occurred loading connection properties from file", ex);            JOptionPane.showMessageDialog(ZooInspectorConnectionPropertiesDialog.this, "An Error occurred loading connection properties from file", "Error", JOptionPane.ERROR_MESSAGE);        }        options.revalidate();        options.repaint();    }}
actionPerformed
public void zookeeper_f318_0(ActionEvent e)
{    Properties connectionProps = getConnectionProps();    try {        zooInspectorPanel.setdefaultConnectionProps(connectionProps);    } catch (IOException ex) {        LoggerFactory.getLogger().error("An Error occurred saving the default connection properties file", ex);        JOptionPane.showMessageDialog(ZooInspectorConnectionPropertiesDialog.this, "An Error occurred saving the default connection properties file", "Error", JOptionPane.ERROR_MESSAGE);    }}
actionPerformed
public void zookeeper_f319_0(ActionEvent e)
{    ZooInspectorConnectionPropertiesDialog.this.dispose();    Properties connectionProps = getConnectionProps();    zooInspectorPanel.connect(connectionProps);}
actionPerformed
public void zookeeper_f320_0(ActionEvent e)
{    ZooInspectorConnectionPropertiesDialog.this.dispose();}
loadConnectionProps
private void zookeeper_f321_0(Properties props)
{    if (props != null) {        for (Object key : props.keySet()) {            String propsKey = (String) key;            if (components.containsKey(propsKey)) {                JComponent component = components.get(propsKey);                String value = props.getProperty(propsKey);                if (component instanceof JTextField) {                    ((JTextField) component).setText(value);                } else if (component instanceof JComboBox) {                    ((JComboBox) component).setSelectedItem(value);                }            }        }    }}
getConnectionProps
private Properties zookeeper_f322_0()
{    Properties connectionProps = new Properties();    for (Entry<String, JComponent> entry : components.entrySet()) {        String value = null;        JComponent component = entry.getValue();        if (component instanceof JTextField) {            value = ((JTextField) component).getText();        } else if (component instanceof JComboBox) {            value = ((JComboBox) component).getSelectedItem().toString();        }        connectionProps.put(entry.getKey(), value);    }    return connectionProps;}
getListCellRendererComponent
public Component zookeeper_f323_0(JList list, Object value, int index, boolean isSelected, boolean cellHasFocus)
{    ZooInspectorNodeViewer viewer = (ZooInspectorNodeViewer) value;    JLabel label = (JLabel) super.getListCellRendererComponent(list, value, index, isSelected, cellHasFocus);    label.setText(viewer.getTitle());    return label;}
canImport
public boolean zookeeper_f324_0(TransferHandler.TransferSupport info)
{        if (!info.isDataFlavorSupported(ZooInspectorNodeViewer.nodeViewerDataFlavor)) {        return false;    }    JList.DropLocation dl = (JList.DropLocation) info.getDropLocation();    if (dl.getIndex() == -1) {        return false;    }    return true;}
importData
public boolean zookeeper_f325_0(TransferHandler.TransferSupport info)
{    JList.DropLocation dl = (JList.DropLocation) info.getDropLocation();    DefaultListModel listModel = (DefaultListModel) viewersList.getModel();    int index = dl.getIndex();    boolean insert = dl.isInsert();        Transferable t = info.getTransferable();    String data;    try {        data = (String) t.getTransferData(ZooInspectorNodeViewer.nodeViewerDataFlavor);    } catch (Exception e) {        return false;    }    try {        ZooInspectorNodeViewer viewer = (ZooInspectorNodeViewer) Class.forName(data).newInstance();        if (listModel.contains(viewer)) {            listModel.removeElement(viewer);        }        if (insert) {            listModel.add(index, viewer);        } else {            listModel.set(index, viewer);        }        return true;    } catch (Exception e) {        LoggerFactory.getLogger().error("Error instantiating class: " + data, e);        return false;    }}
getSourceActions
public int zookeeper_f326_0(JComponent c)
{    return MOVE;}
createTransferable
protected Transferable zookeeper_f327_0(JComponent c)
{    JList list = (JList) c;    ZooInspectorNodeViewer value = (ZooInspectorNodeViewer) list.getSelectedValue();    return value;}
actionPerformed
public void zookeeper_f328_0(ActionEvent e)
{    DefaultListModel listModel = (DefaultListModel) viewersList.getModel();    ZooInspectorNodeViewer viewer = (ZooInspectorNodeViewer) viewersList.getSelectedValue();    int index = viewersList.getSelectedIndex();    if (listModel.contains(viewer)) {        listModel.removeElementAt(index);        listModel.insertElementAt(viewer, index - 1);        viewersList.setSelectedValue(viewer, true);    }}
actionPerformed
public void zookeeper_f329_0(ActionEvent e)
{    DefaultListModel listModel = (DefaultListModel) viewersList.getModel();    ZooInspectorNodeViewer viewer = (ZooInspectorNodeViewer) viewersList.getSelectedValue();    int index = viewersList.getSelectedIndex();    if (listModel.contains(viewer)) {        listModel.removeElementAt(index);        listModel.insertElementAt(viewer, index + 1);        viewersList.setSelectedValue(viewer, true);    }}
actionPerformed
public void zookeeper_f330_0(ActionEvent e)
{    DefaultListModel listModel = (DefaultListModel) viewersList.getModel();    ZooInspectorNodeViewer viewer = (ZooInspectorNodeViewer) viewersList.getSelectedValue();    int index = viewersList.getSelectedIndex();    if (listModel.contains(viewer)) {        listModel.removeElement(viewer);        viewersList.setSelectedIndex(index == listModel.size() ? index - 1 : index);    }}
actionPerformed
public void zookeeper_f331_0(ActionEvent e)
{    String className = newViewerTextField.getText();    if (className == null || className.length() == 0) {        JOptionPane.showMessageDialog(ZooInspectorNodeViewersDialog.this, "Please enter the full class name for a Node Viewer and click the add button", "Input Error", JOptionPane.ERROR_MESSAGE);    } else {        try {            DefaultListModel listModel = (DefaultListModel) viewersList.getModel();            ZooInspectorNodeViewer viewer = (ZooInspectorNodeViewer) Class.forName(className).newInstance();            if (listModel.contains(viewer)) {                JOptionPane.showMessageDialog(ZooInspectorNodeViewersDialog.this, "Node viewer already exists.  Each node viewer can only be added once.", "Input Error", JOptionPane.ERROR_MESSAGE);            } else {                listModel.addElement(viewer);            }        } catch (Exception ex) {            LoggerFactory.getLogger().error("An error occurred while instaniating the node viewer. ", ex);            JOptionPane.showMessageDialog(ZooInspectorNodeViewersDialog.this, "An error occurred while instaniating the node viewer: " + ex.getMessage(), "Error", JOptionPane.ERROR_MESSAGE);        }    }}
actionPerformed
public void zookeeper_f332_0(ActionEvent e)
{    int result = fileChooser.showSaveDialog(ZooInspectorNodeViewersDialog.this);    if (result == JFileChooser.APPROVE_OPTION) {        File selectedFile = fileChooser.getSelectedFile();        int answer = JOptionPane.YES_OPTION;        if (selectedFile.exists()) {            answer = JOptionPane.showConfirmDialog(ZooInspectorNodeViewersDialog.this, "The specified file already exists.  do you want to overwrite it?", "Confirm Overwrite", JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE);        }        if (answer == JOptionPane.YES_OPTION) {            DefaultListModel listModel = (DefaultListModel) viewersList.getModel();            List<String> nodeViewersClassNames = new ArrayList<String>();            Object[] modelContents = listModel.toArray();            for (Object o : modelContents) {                nodeViewersClassNames.add(((ZooInspectorNodeViewer) o).getClass().getCanonicalName());            }            try {                manager.saveNodeViewersFile(selectedFile, nodeViewersClassNames);            } catch (IOException ex) {                LoggerFactory.getLogger().error("Error saving node viewer configuration from file.", ex);                JOptionPane.showMessageDialog(ZooInspectorNodeViewersDialog.this, "Error saving node viewer configuration from file: " + ex.getMessage(), "Error", JOptionPane.ERROR_MESSAGE);            }        }    }}
actionPerformed
public void zookeeper_f333_0(ActionEvent e)
{    int result = fileChooser.showOpenDialog(ZooInspectorNodeViewersDialog.this);    if (result == JFileChooser.APPROVE_OPTION) {        try {            List<String> nodeViewersClassNames = manager.loadNodeViewersFile(fileChooser.getSelectedFile());            List<ZooInspectorNodeViewer> nodeViewers = new ArrayList<ZooInspectorNodeViewer>();            for (String nodeViewersClassName : nodeViewersClassNames) {                ZooInspectorNodeViewer viewer = (ZooInspectorNodeViewer) Class.forName(nodeViewersClassName).newInstance();                nodeViewers.add(viewer);            }            DefaultListModel model = new DefaultListModel();            for (ZooInspectorNodeViewer viewer : nodeViewers) {                model.addElement(viewer);            }            viewersList.setModel(model);            panel.revalidate();            panel.repaint();        } catch (Exception ex) {            LoggerFactory.getLogger().error("Error loading node viewer configuration from file.", ex);            JOptionPane.showMessageDialog(ZooInspectorNodeViewersDialog.this, "Error loading node viewer configuration from file: " + ex.getMessage(), "Error", JOptionPane.ERROR_MESSAGE);        }    }}
actionPerformed
public void zookeeper_f334_0(ActionEvent e)
{    int answer = JOptionPane.showConfirmDialog(ZooInspectorNodeViewersDialog.this, "Are you sure you want to save this configuration as the default?", "Confirm Set Defaults", JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE);    if (answer == JOptionPane.YES_OPTION) {        DefaultListModel listModel = (DefaultListModel) viewersList.getModel();        List<String> nodeViewersClassNames = new ArrayList<String>();        Object[] modelContents = listModel.toArray();        for (Object o : modelContents) {            nodeViewersClassNames.add(((ZooInspectorNodeViewer) o).getClass().getCanonicalName());        }        try {            manager.setDefaultNodeViewerConfiguration(nodeViewersClassNames);        } catch (IOException ex) {            LoggerFactory.getLogger().error("Error setting default node viewer configuration.", ex);            JOptionPane.showMessageDialog(ZooInspectorNodeViewersDialog.this, "Error setting default node viewer configuration: " + ex.getMessage(), "Error", JOptionPane.ERROR_MESSAGE);        }    }}
actionPerformed
public void zookeeper_f335_0(ActionEvent e)
{    ZooInspectorNodeViewersDialog.this.dispose();    DefaultListModel listModel = (DefaultListModel) viewersList.getModel();    newViewers.clear();    Object[] modelContents = listModel.toArray();    for (Object o : modelContents) {        newViewers.add((ZooInspectorNodeViewer) o);    }    currentViewers.clear();    currentViewers.addAll(newViewers);    for (NodeViewersChangeListener listener : listeners) {        listener.nodeViewersChanged(currentViewers);    }}
actionPerformed
public void zookeeper_f336_0(ActionEvent e)
{    ZooInspectorNodeViewersDialog.this.dispose();}
valueChanged
public void zookeeper_f337_0(ListSelectionEvent e)
{    JButton removeButton = buttons.get(Button.remove);    JButton upButton = buttons.get(Button.up);    JButton downButton = buttons.get(Button.down);    int index = viewersList.getSelectedIndex();    if (index == -1) {        removeButton.setEnabled(false);        upButton.setEnabled(false);        downButton.setEnabled(false);    } else {        removeButton.setEnabled(true);        if (index == 0) {            upButton.setEnabled(false);        } else {            upButton.setEnabled(true);        }        if (index == ((DefaultListModel) viewersList.getModel()).getSize()) {            downButton.setEnabled(false);        } else {            downButton.setEnabled(true);        }    }}
createJButton
public JButton zookeeper_f338_0(IconResource iconResource)
{    ImageIcon imageIcon = iconResource.get(icon, toolTip);    JButton jbutton;    if (imageIcon == null) {        jbutton = new JButton(icon);    } else {        jbutton = new JButton(imageIcon);    }    jbutton.setEnabled(enabled);    jbutton.setToolTipText(toolTip);    return jbutton;}
setNodeViewers
public void zookeeper_f339_0(List<ZooInspectorNodeViewer> nodeViewers)
{    this.nodeVeiwers.clear();    this.nodeVeiwers.addAll(nodeViewers);    needsReload.clear();    tabbedPane.removeAll();    for (ZooInspectorNodeViewer nodeViewer : nodeVeiwers) {        nodeViewer.setZooInspectorManager(zooInspectorManager);        needsReload.add(true);        tabbedPane.add(nodeViewer.getTitle(), nodeViewer);    }    this.revalidate();    this.repaint();}
reloadSelectedViewer
private void zookeeper_f340_0()
{    int index = this.tabbedPane.getSelectedIndex();    if (index != -1 && this.needsReload.get(index)) {        ZooInspectorNodeViewer viewer = this.nodeVeiwers.get(index);        viewer.nodeSelectionChanged(selectedNodes);        this.needsReload.set(index, false);    }}
valueChanged
public void zookeeper_f341_0(TreeSelectionEvent e)
{    TreePath[] paths = e.getPaths();    selectedNodes.clear();    for (TreePath path : paths) {        boolean appended = false;        StringBuilder sb = new StringBuilder();        Object[] pathArray = path.getPath();        for (Object o : pathArray) {            if (o != null) {                String nodeName = o.toString();                if (nodeName != null) {                    if (nodeName.length() > 0) {                        appended = true;                                                sb.append("/");                        sb.append(o.toString());                    }                }            }        }        if (appended) {            selectedNodes.add(sb.toString());        }    }    for (int i = 0; i < needsReload.size(); i++) {        this.needsReload.set(i, true);    }    reloadSelectedViewer();}
stateChanged
public void zookeeper_f342_0(ChangeEvent e)
{    reloadSelectedViewer();}
actionPerformed
public void zookeeper_f343_0(ActionEvent e)
{    ZooInspectorConnectionPropertiesDialog zicpd = new ZooInspectorConnectionPropertiesDialog(zooInspectorManager.getLastConnectionProps(), zooInspectorManager.getConnectionPropertiesTemplate(), ZooInspectorPanel.this);    zicpd.setVisible(true);}
actionPerformed
public void zookeeper_f344_0(ActionEvent e)
{    disconnect();}
actionPerformed
public void zookeeper_f345_0(ActionEvent e)
{    treeViewer.refreshView();}
actionPerformed
public void zookeeper_f346_0(ActionEvent e)
{    ZooInspectorNodeViewersDialog nvd = new ZooInspectorNodeViewersDialog(JOptionPane.getRootFrame(), nodeViewers, listeners, zooInspectorManager, iconResource);    nvd.setVisible(true);}
actionPerformed
public void zookeeper_f347_0(ActionEvent e)
{    ZooInspectorAboutDialog zicpd = new ZooInspectorAboutDialog(JOptionPane.getRootFrame(), iconResource);    zicpd.setVisible(true);}
connect
public void zookeeper_f348_0(final Properties connectionProps)
{    SwingWorker<Boolean, Void> worker = new SwingWorker<Boolean, Void>() {        @Override        protected Boolean doInBackground() throws Exception {            zooInspectorManager.setLastConnectionProps(connectionProps);            return zooInspectorManager.connect(connectionProps);        }        @Override        protected void done() {            try {                if (get()) {                    treeViewer.refreshView();                    toolbar.toggleButtons(true);                } else {                    JOptionPane.showMessageDialog(ZooInspectorPanel.this, "Unable to connect to zookeeper", "Error", JOptionPane.ERROR_MESSAGE);                }            } catch (InterruptedException e) {                LoggerFactory.getLogger().error("Error occurred while connecting to ZooKeeper server", e);            } catch (ExecutionException e) {                LoggerFactory.getLogger().error("Error occurred while connecting to ZooKeeper server", e);            }        }    };    worker.execute();}
doInBackground
protected Boolean zookeeper_f349_0() throws Exception
{    zooInspectorManager.setLastConnectionProps(connectionProps);    return zooInspectorManager.connect(connectionProps);}
done
protected void zookeeper_f350_0()
{    try {        if (get()) {            treeViewer.refreshView();            toolbar.toggleButtons(true);        } else {            JOptionPane.showMessageDialog(ZooInspectorPanel.this, "Unable to connect to zookeeper", "Error", JOptionPane.ERROR_MESSAGE);        }    } catch (InterruptedException e) {        LoggerFactory.getLogger().error("Error occurred while connecting to ZooKeeper server", e);    } catch (ExecutionException e) {        LoggerFactory.getLogger().error("Error occurred while connecting to ZooKeeper server", e);    }}
disconnect
public void zookeeper_f351_0()
{    disconnect(false);}
disconnect
public void zookeeper_f352_0(boolean wait)
{    SwingWorker<Boolean, Void> worker = new SwingWorker<Boolean, Void>() {        @Override        protected Boolean doInBackground() throws Exception {            return ZooInspectorPanel.this.zooInspectorManager.disconnect();        }        @Override        protected void done() {            try {                if (get()) {                    treeViewer.clearView();                    toolbar.toggleButtons(false);                }            } catch (InterruptedException e) {                LoggerFactory.getLogger().error("Error occurred while disconnecting from ZooKeeper server", e);            } catch (ExecutionException e) {                LoggerFactory.getLogger().error("Error occurred while disconnecting from ZooKeeper server", e);            }        }    };    worker.execute();    if (wait) {        while (!worker.isDone()) {            try {                Thread.sleep(100);            } catch (InterruptedException e) {                LoggerFactory.getLogger().error("Error occurred while disconnecting from ZooKeeper server", e);            }        }    }}
doInBackground
protected Boolean zookeeper_f353_0() throws Exception
{    return ZooInspectorPanel.this.zooInspectorManager.disconnect();}
done
protected void zookeeper_f354_0()
{    try {        if (get()) {            treeViewer.clearView();            toolbar.toggleButtons(false);        }    } catch (InterruptedException e) {        LoggerFactory.getLogger().error("Error occurred while disconnecting from ZooKeeper server", e);    } catch (ExecutionException e) {        LoggerFactory.getLogger().error("Error occurred while disconnecting from ZooKeeper server", e);    }}
nodeViewersChanged
public void zookeeper_f355_0(List<ZooInspectorNodeViewer> newViewers)
{    this.nodeViewersPanel.setNodeViewers(newViewers);}
setdefaultConnectionProps
public void zookeeper_f356_0(Properties connectionProps) throws IOException
{    this.zooInspectorManager.saveDefaultConnectionFile(connectionProps);}
actionPerformed
public void zookeeper_f357_0(ActionEvent e)
{    List<String> selectedNodes = getSelectedNodes();    zooInspectorManager.addWatchers(selectedNodes, ZooInspectorTreeViewer.this);}
actionPerformed
public void zookeeper_f358_0(ActionEvent e)
{    List<String> selectedNodes = getSelectedNodes();    zooInspectorManager.removeWatchers(selectedNodes);}
mouseClicked
public void zookeeper_f359_0(MouseEvent e)
{    if (e.isPopupTrigger() || e.getButton() == MouseEvent.BUTTON3) {                                popupMenu.removeAll();        popupMenu.add(addNode);        popupMenu.add(deleteNode);        popupMenu.add(addNotify);        popupMenu.add(removeNotify);        popupMenu.show(ZooInspectorTreeViewer.this, e.getX(), e.getY());    }}
refreshView
public void zookeeper_f360_0()
{    final Set<TreePath> expandedNodes = new LinkedHashSet<TreePath>();    int rowCount = tree.getRowCount();    for (int i = 0; i < rowCount; i++) {        TreePath path = tree.getPathForRow(i);        if (tree.isExpanded(path)) {            expandedNodes.add(path);        }    }    final TreePath[] selectedNodes = tree.getSelectionPaths();    SwingWorker<Boolean, Void> worker = new SwingWorker<Boolean, Void>() {        @Override        protected Boolean doInBackground() throws Exception {            tree.setModel(new DefaultTreeModel(new ZooInspectorTreeNode("/", null)));            return true;        }        @Override        protected void done() {            for (TreePath path : expandedNodes) {                tree.expandPath(path);            }            tree.getSelectionModel().setSelectionPaths(selectedNodes);        }    };    worker.execute();}
doInBackground
protected Boolean zookeeper_f361_0() throws Exception
{    tree.setModel(new DefaultTreeModel(new ZooInspectorTreeNode("/", null)));    return true;}
done
protected void zookeeper_f362_0()
{    for (TreePath path : expandedNodes) {        tree.expandPath(path);    }    tree.getSelectionModel().setSelectionPaths(selectedNodes);}
clearView
public void zookeeper_f363_0()
{    tree.setModel(new DefaultTreeModel(new DefaultMutableTreeNode()));}
children
public Enumeration<TreeNode> zookeeper_f364_0()
{    List<String> children = zooInspectorManager.getChildren(this.nodePath);    Collections.sort(children);    List<TreeNode> returnChildren = new ArrayList<TreeNode>();    for (String child : children) {        returnChildren.add(new ZooInspectorTreeNode((this.nodePath.equals("/") ? "" : this.nodePath) + "/" + child, this));    }    return Collections.enumeration(returnChildren);}
getAllowsChildren
public boolean zookeeper_f365_0()
{    return zooInspectorManager.isAllowsChildren(this.nodePath);}
getChildAt
public TreeNode zookeeper_f366_0(int childIndex)
{    String child = zooInspectorManager.getNodeChild(this.nodePath, childIndex);    if (child != null) {        return new ZooInspectorTreeNode((this.nodePath.equals("/") ? "" : this.nodePath) + "/" + child, this);    }    return null;}
getChildCount
public int zookeeper_f367_0()
{    return zooInspectorManager.getNumChildren(this.nodePath);}
getIndex
public int zookeeper_f368_0(TreeNode node)
{    return zooInspectorManager.getNodeIndex(this.nodePath);}
getParent
public TreeNode zookeeper_f369_0()
{    return this.parent;}
isLeaf
public boolean zookeeper_f370_0()
{    return !zooInspectorManager.hasChildren(this.nodePath);}
toString
public String zookeeper_f371_0()
{    return this.nodeName;}
hashCode
public int zookeeper_f372_0()
{    final int prime = 31;    int result = 1;    result = prime * result + getOuterType().hashCode();    result = prime * result + ((nodePath == null) ? 0 : nodePath.hashCode());    result = prime * result + ((parent == null) ? 0 : parent.hashCode());    return result;}
equals
public boolean zookeeper_f373_0(Object obj)
{    if (this == obj)        return true;    if (obj == null)        return false;    if (getClass() != obj.getClass())        return false;    ZooInspectorTreeNode other = (ZooInspectorTreeNode) obj;    if (!getOuterType().equals(other.getOuterType()))        return false;    if (nodePath == null) {        if (other.nodePath != null)            return false;    } else if (!nodePath.equals(other.nodePath))        return false;    if (parent == null) {        if (other.parent != null)            return false;    } else if (!parent.equals(other.parent))        return false;    return true;}
getOuterType
private ZooInspectorTreeViewer zookeeper_f374_0()
{    return ZooInspectorTreeViewer.this;}
getSelectedNodes
public List<String> zookeeper_f375_0()
{    TreePath[] paths = tree.getSelectionPaths();    List<String> selectedNodes = new ArrayList<String>();    if (paths != null) {        for (TreePath path : paths) {            StringBuilder sb = new StringBuilder();            Object[] pathArray = path.getPath();            for (Object o : pathArray) {                String nodeName = o.toString();                if (nodeName.length() > 0) {                    sb.append("/");                    sb.append(o.toString());                }            }            selectedNodes.add(sb.toString());        }    }    return selectedNodes;}
processEvent
public void zookeeper_f376_0(String nodePath, String eventType, Map<String, String> eventInfo)
{    StringBuilder sb = new StringBuilder();    sb.append("Node: ");    sb.append(nodePath);    sb.append("\nEvent: ");    sb.append(eventType);    if (eventInfo != null) {        for (Map.Entry<String, String> entry : eventInfo.entrySet()) {            sb.append("\n");            sb.append(entry.getKey());            sb.append(": ");            sb.append(entry.getValue());        }    }    this.toasterManager.showToaster(toasterIcon, sb.toString());}
getLogger
public static org.slf4j.Logger zookeeper_f377_0()
{    return logger;}
load
public List<String> zookeeper_f378_0(String nodePath) throws Exception
{    return getChildren(nodePath);}
getChildren
public List<String> zookeeper_f379_0(String nodePath)
{    try {        Stat s = zooKeeper.exists(nodePath, false);        if (s != null) {            List<String> children = this.zooKeeper.getChildren(nodePath, false);            Collections.sort(children);            return children;        }    } catch (Exception e) {        LoggerFactory.getLogger().error("Error occurred retrieving child of node: " + nodePath, e);    }    return null;}
getNodeChild
public String zookeeper_f380_0(String nodePath, int index)
{    List<String> childNodes = null;    try {        childNodes = nodes.get(nodePath);        return childNodes.get(index);    } catch (ExecutionException e) {        LoggerFactory.getLogger().error("Error occurred retrieving child " + index + "of node: " + nodePath, e);    }    return null;}
getKey
public K zookeeper_f381_0()
{    return key;}
setKey
public void zookeeper_f382_0(K key)
{    this.key = key;}
getValue
public V zookeeper_f383_0()
{    return value;}
setValue
public void zookeeper_f384_0(V value)
{    this.value = value;}
toString
public String zookeeper_f385_0()
{    return "Pair [" + key + ", " + value + "]";}
hashCode
public int zookeeper_f386_0()
{    final int prime = 31;    int result = 1;    result = prime * result + ((key == null) ? 0 : key.hashCode());    result = prime * result + ((value == null) ? 0 : value.hashCode());    return result;}
equals
public boolean zookeeper_f387_0(Object obj)
{    if (this == obj)        return true;    if (obj == null)        return false;    if (getClass() != obj.getClass())        return false;    Pair<?, ?> other = (Pair<?, ?>) obj;    if (key == null) {        if (other.key != null)            return false;    } else if (!key.equals(other.key))        return false;    if (value == null) {        if (other.value != null)            return false;    } else if (!value.equals(other.value))        return false;    return true;}
connect
public boolean zookeeper_f388_0(Properties connectionProps)
{    try {        if (this.zooKeeper == null) {            String connectString = connectionProps.getProperty(CONNECT_STRING);            String sessionTimeout = connectionProps.getProperty(SESSION_TIMEOUT);            String encryptionManager = connectionProps.getProperty(DATA_ENCRYPTION_MANAGER);            String authScheme = connectionProps.getProperty(AUTH_SCHEME_KEY);            String authData = connectionProps.getProperty(AUTH_DATA_KEY);            if (connectString == null || sessionTimeout == null) {                throw new IllegalArgumentException("Both connect string and session timeout are required.");            }            if (encryptionManager == null) {                this.encryptionManager = new BasicDataEncryptionManager();            } else {                Class<?> clazz = Class.forName(encryptionManager);                if (Arrays.asList(clazz.getInterfaces()).contains(DataEncryptionManager.class)) {                    this.encryptionManager = (DataEncryptionManager) Class.forName(encryptionManager).newInstance();                } else {                    throw new IllegalArgumentException("Data encryption manager must implement DataEncryptionManager interface");                }            }            this.connectString = connectString;            this.sessionTimeout = Integer.valueOf(sessionTimeout);            this.zooKeeper = new ZooKeeperRetry(connectString, Integer.valueOf(sessionTimeout), new Watcher() {                public void process(WatchedEvent event) {                    if (event.getState() == KeeperState.Expired) {                        connected = false;                    }                }            });            if (authData != null && authData.length() > 0) {                this.zooKeeper.addAuthInfo(authScheme, authData.getBytes());            }            ((ZooKeeperRetry) this.zooKeeper).setRetryLimit(10);            connected = ((ZooKeeperRetry) this.zooKeeper).testConnection();        }    } catch (Exception e) {        connected = false;        e.printStackTrace();    }    if (!connected) {        disconnect();    } else {        this.nodesCache = new NodesCache(zooKeeper);    }    return connected;}
process
public void zookeeper_f389_0(WatchedEvent event)
{    if (event.getState() == KeeperState.Expired) {        connected = false;    }}
disconnect
public boolean zookeeper_f390_0()
{    try {        if (this.zooKeeper != null) {            this.zooKeeper.close();            this.zooKeeper = null;            connected = false;            removeWatchers(this.watchers.keySet());            return true;        }    } catch (Exception e) {        LoggerFactory.getLogger().error("Error occurred while disconnecting from ZooKeeper server", e);    }    return false;}
getChildren
public List<String> zookeeper_f391_0(String nodePath)
{    if (connected) {        return nodesCache.getChildren(nodePath);    }    return null;}
getData
public String zookeeper_f392_0(String nodePath)
{    if (connected) {        try {            if (nodePath.length() == 0) {                nodePath = "/";            }            Stat s = zooKeeper.exists(nodePath, false);            if (s != null) {                return this.encryptionManager.decryptData(zooKeeper.getData(nodePath, false, s));            }        } catch (Exception e) {            LoggerFactory.getLogger().error("Error occurred getting data for node: " + nodePath, e);        }    }    return null;}
getNodeChild
public String zookeeper_f393_0(String nodePath, int childIndex)
{    if (connected) {        return this.nodesCache.getNodeChild(nodePath, childIndex);    }    return null;}
getNodeIndex
public int zookeeper_f394_0(String nodePath)
{    if (connected) {        int index = nodePath.lastIndexOf("/");        if (index == -1 || (!nodePath.equals("/") && nodePath.charAt(nodePath.length() - 1) == '/')) {            throw new IllegalArgumentException("Invalid node path: " + nodePath);        }        String parentPath = nodePath.substring(0, index);        String child = nodePath.substring(index + 1);        if (parentPath != null && parentPath.length() > 0) {            List<String> children = this.nodesCache.getChildren(parentPath);            if (children != null) {                return children.indexOf(child);            }        }    }    return -1;}
getACLs
public List<Map<String, String>> zookeeper_f395_0(String nodePath)
{    List<Map<String, String>> returnACLs = new ArrayList<Map<String, String>>();    if (connected) {        try {            if (nodePath.length() == 0) {                nodePath = "/";            }            Stat s = zooKeeper.exists(nodePath, false);            if (s != null) {                List<ACL> acls = zooKeeper.getACL(nodePath, s);                for (ACL acl : acls) {                    Map<String, String> aclMap = new LinkedHashMap<String, String>();                    aclMap.put(ACL_SCHEME, acl.getId().getScheme());                    aclMap.put(ACL_ID, acl.getId().getId());                    StringBuilder sb = new StringBuilder();                    int perms = acl.getPerms();                    boolean addedPerm = false;                    if ((perms & Perms.READ) == Perms.READ) {                        sb.append("Read");                        addedPerm = true;                    }                    if (addedPerm) {                        sb.append(", ");                    }                    if ((perms & Perms.WRITE) == Perms.WRITE) {                        sb.append("Write");                        addedPerm = true;                    }                    if (addedPerm) {                        sb.append(", ");                    }                    if ((perms & Perms.CREATE) == Perms.CREATE) {                        sb.append("Create");                        addedPerm = true;                    }                    if (addedPerm) {                        sb.append(", ");                    }                    if ((perms & Perms.DELETE) == Perms.DELETE) {                        sb.append("Delete");                        addedPerm = true;                    }                    if (addedPerm) {                        sb.append(", ");                    }                    if ((perms & Perms.ADMIN) == Perms.ADMIN) {                        sb.append("Admin");                        addedPerm = true;                    }                    aclMap.put(ACL_PERMS, sb.toString());                    returnACLs.add(aclMap);                }            }        } catch (InterruptedException e) {            LoggerFactory.getLogger().error("Error occurred retrieving ACLs of node: " + nodePath, e);        } catch (KeeperException e) {            LoggerFactory.getLogger().error("Error occurred retrieving ACLs of node: " + nodePath, e);        }    }    return returnACLs;}
getNodeMeta
public Map<String, String> zookeeper_f396_0(String nodePath)
{    Map<String, String> nodeMeta = new LinkedHashMap<String, String>();    if (connected) {        try {            if (nodePath.length() == 0) {                nodePath = "/";            }            Stat s = zooKeeper.exists(nodePath, false);            if (s != null) {                nodeMeta.put(A_VERSION, String.valueOf(s.getAversion()));                nodeMeta.put(C_TIME, String.valueOf(s.getCtime()));                nodeMeta.put(C_VERSION, String.valueOf(s.getCversion()));                nodeMeta.put(CZXID, String.valueOf(s.getCzxid()));                nodeMeta.put(DATA_LENGTH, String.valueOf(s.getDataLength()));                nodeMeta.put(EPHEMERAL_OWNER, String.valueOf(s.getEphemeralOwner()));                nodeMeta.put(M_TIME, String.valueOf(s.getMtime()));                nodeMeta.put(MZXID, String.valueOf(s.getMzxid()));                nodeMeta.put(NUM_CHILDREN, String.valueOf(s.getNumChildren()));                nodeMeta.put(PZXID, String.valueOf(s.getPzxid()));                nodeMeta.put(VERSION, String.valueOf(s.getVersion()));            }        } catch (Exception e) {            LoggerFactory.getLogger().error("Error occurred retrieving meta data for node: " + nodePath, e);        }    }    return nodeMeta;}
getNumChildren
public int zookeeper_f397_0(String nodePath)
{    if (connected) {        try {            Stat s = zooKeeper.exists(nodePath, false);            if (s != null) {                return s.getNumChildren();            }        } catch (Exception e) {            LoggerFactory.getLogger().error("Error occurred getting the number of children of node: " + nodePath, e);        }    }    return -1;}
hasChildren
public boolean zookeeper_f398_0(String nodePath)
{    return getNumChildren(nodePath) > 0;}
isAllowsChildren
public boolean zookeeper_f399_0(String nodePath)
{    if (connected) {        try {            Stat s = zooKeeper.exists(nodePath, false);            if (s != null) {                return s.getEphemeralOwner() == 0;            }        } catch (Exception e) {            LoggerFactory.getLogger().error("Error occurred determining whether node is allowed children: " + nodePath, e);        }    }    return false;}
getSessionMeta
public Map<String, String> zookeeper_f400_0()
{    Map<String, String> sessionMeta = new LinkedHashMap<String, String>();    try {        if (zooKeeper != null) {            sessionMeta.put(SESSION_ID, String.valueOf(zooKeeper.getSessionId()));            sessionMeta.put(SESSION_STATE, String.valueOf(zooKeeper.getState().toString()));            sessionMeta.put(CONNECT_STRING, this.connectString);            sessionMeta.put(SESSION_TIMEOUT, String.valueOf(this.sessionTimeout));        }    } catch (Exception e) {        LoggerFactory.getLogger().error("Error occurred retrieving session meta data.", e);    }    return sessionMeta;}
createNode
public boolean zookeeper_f401_0(String parent, String nodeName)
{    if (connected) {        try {            String[] nodeElements = nodeName.split("/");            for (String nodeElement : nodeElements) {                String node = parent + "/" + nodeElement;                Stat s = zooKeeper.exists(node, false);                if (s == null) {                    zooKeeper.create(node, this.encryptionManager.encryptData(null), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);                    parent = node;                }            }            return true;        } catch (Exception e) {            LoggerFactory.getLogger().error("Error occurred creating node: " + parent + "/" + nodeName, e);        }    }    return false;}
deleteNode
public boolean zookeeper_f402_0(String nodePath)
{    if (connected) {        try {            Stat s = zooKeeper.exists(nodePath, false);            if (s != null) {                List<String> children = zooKeeper.getChildren(nodePath, false);                for (String child : children) {                    String node = nodePath + "/" + child;                    deleteNode(node);                }                zooKeeper.delete(nodePath, -1);            }            return true;        } catch (Exception e) {            LoggerFactory.getLogger().error("Error occurred deleting node: " + nodePath, e);        }    }    return false;}
setData
public boolean zookeeper_f403_0(String nodePath, String data)
{    if (connected) {        try {            zooKeeper.setData(nodePath, this.encryptionManager.encryptData(data), -1);            return true;        } catch (Exception e) {            LoggerFactory.getLogger().error("Error occurred setting data for node: " + nodePath, e);        }    }    return false;}
getConnectionPropertiesTemplate
public Pair<Map<String, List<String>>, Map<String, String>> zookeeper_f404_0()
{    Map<String, List<String>> template = new LinkedHashMap<String, List<String>>();    template.put(CONNECT_STRING, Arrays.asList(new String[] { defaultHosts }));    template.put(SESSION_TIMEOUT, Arrays.asList(new String[] { defaultTimeout }));    template.put(DATA_ENCRYPTION_MANAGER, Arrays.asList(new String[] { defaultEncryptionManager }));    template.put(AUTH_SCHEME_KEY, Arrays.asList(new String[] { defaultAuthScheme }));    template.put(AUTH_DATA_KEY, Arrays.asList(new String[] { defaultAuthValue }));    Map<String, String> labels = new LinkedHashMap<String, String>();    labels.put(CONNECT_STRING, "Connect String");    labels.put(SESSION_TIMEOUT, "Session Timeout");    labels.put(DATA_ENCRYPTION_MANAGER, "Data Encryption Manager");    labels.put(AUTH_SCHEME_KEY, "Authentication Scheme");    labels.put(AUTH_DATA_KEY, "Authentication Data");    return new Pair<Map<String, List<String>>, Map<String, String>>(template, labels);}
addWatchers
public void zookeeper_f405_0(Collection<String> selectedNodes, NodeListener nodeListener)
{        if (connected) {        for (String node : selectedNodes) {            if (!watchers.containsKey(node)) {                try {                    watchers.put(node, new NodeWatcher(node, nodeListener, zooKeeper));                } catch (Exception e) {                    LoggerFactory.getLogger().error("Error occurred adding node watcher for node: " + node, e);                }            }        }    }}
removeWatchers
public void zookeeper_f406_0(Collection<String> selectedNodes)
{        if (connected) {        for (String node : selectedNodes) {            if (watchers.containsKey(node)) {                NodeWatcher watcher = watchers.remove(node);                if (watcher != null) {                    watcher.stop();                }            }        }    }}
process
public void zookeeper_f407_0(WatchedEvent event)
{    if (!closed) {        try {            if (event.getType() != EventType.NodeDeleted) {                Stat s = zooKeeper.exists(nodePath, this);                if (s != null) {                    zookeeper.getChildren(nodePath, this);                }            }        } catch (Exception e) {            LoggerFactory.getLogger().error("Error occurred re-adding node watcherfor node " + nodePath, e);        }        nodeListener.processEvent(event.getPath(), event.getType().name(), null);    }}
stop
public void zookeeper_f408_0()
{    this.closed = true;}
loadNodeViewersFile
public List<String> zookeeper_f409_0(File selectedFile) throws IOException
{    List<String> result = new ArrayList<String>();    if (defaultNodeViewersFile.exists()) {        FileReader reader = new FileReader(selectedFile);        try {            BufferedReader buff = new BufferedReader(reader);            try {                while (buff.ready()) {                    String line = buff.readLine();                    if (line != null && line.length() > 0 && !line.startsWith("#")) {                        result.add(line);                    }                }            } finally {                buff.close();            }        } finally {            reader.close();        }    }    return result;}
loadDefaultConnectionFile
private void zookeeper_f410_0() throws IOException
{    if (defaultConnectionFile.exists()) {        Properties props = new Properties();        FileReader reader = new FileReader(defaultConnectionFile);        try {            props.load(reader);        } finally {            reader.close();        }        defaultEncryptionManager = props.getProperty(DATA_ENCRYPTION_MANAGER) == null ? "org.apache.zookeeper.inspector.encryption.BasicDataEncryptionManager" : props.getProperty(DATA_ENCRYPTION_MANAGER);        defaultTimeout = props.getProperty(SESSION_TIMEOUT) == null ? "5000" : props.getProperty(SESSION_TIMEOUT);        defaultHosts = props.getProperty(CONNECT_STRING) == null ? "localhost:2181" : props.getProperty(CONNECT_STRING);        defaultAuthScheme = props.getProperty(AUTH_SCHEME_KEY) == null ? "" : props.getProperty(AUTH_SCHEME_KEY);        defaultAuthValue = props.getProperty(AUTH_DATA_KEY) == null ? "" : props.getProperty(AUTH_DATA_KEY);    } else {        defaultEncryptionManager = "org.apache.zookeeper.inspector.encryption.BasicDataEncryptionManager";        defaultTimeout = "5000";        defaultHosts = "localhost:2181";        defaultAuthScheme = "";        defaultAuthValue = "";    }}
saveDefaultConnectionFile
public void zookeeper_f411_0(Properties props) throws IOException
{    File defaultDir = defaultConnectionFile.getParentFile();    if (!defaultDir.exists()) {        if (!defaultDir.mkdirs()) {            throw new IOException("Failed to create configuration directory: " + defaultDir.getAbsolutePath());        }    }    if (!defaultConnectionFile.exists()) {        if (!defaultConnectionFile.createNewFile()) {            throw new IOException("Failed to create default connection file: " + defaultConnectionFile.getAbsolutePath());        }    }    FileWriter writer = new FileWriter(defaultConnectionFile);    try {        props.store(writer, "Default connection for ZooInspector");    } finally {        writer.close();    }}
saveNodeViewersFile
public void zookeeper_f412_0(File selectedFile, List<String> nodeViewersClassNames) throws IOException
{    if (!selectedFile.exists()) {        if (!selectedFile.createNewFile()) {            throw new IOException("Failed to create node viewers configuration file: " + selectedFile.getAbsolutePath());        }    }    FileWriter writer = new FileWriter(selectedFile);    try {        BufferedWriter buff = new BufferedWriter(writer);        try {            for (String nodeViewersClassName : nodeViewersClassNames) {                buff.append(nodeViewersClassName);                buff.append("\n");            }        } finally {            buff.flush();            buff.close();        }    } finally {        writer.close();    }}
setDefaultNodeViewerConfiguration
public void zookeeper_f413_0(List<String> nodeViewersClassNames) throws IOException
{    File defaultDir = defaultNodeViewersFile.getParentFile();    if (!defaultDir.exists()) {        if (!defaultDir.mkdirs()) {            throw new IOException("Failed to create configuration directory: " + defaultDir.getAbsolutePath());        }    }    saveNodeViewersFile(defaultNodeViewersFile, nodeViewersClassNames);}
getDefaultNodeViewerConfiguration
public List<String> zookeeper_f414_0() throws IOException
{    List<String> defaultNodeViewers = loadNodeViewersFile(defaultNodeViewersFile);    if (defaultNodeViewers.isEmpty()) {        LoggerFactory.getLogger().warn("List of default node viewers is empty");    }    return defaultNodeViewers;}
getLastConnectionProps
public Properties zookeeper_f415_0()
{    return this.lastConnectionProps;}
setLastConnectionProps
public void zookeeper_f416_0(Properties connectionProps)
{    this.lastConnectionProps = connectionProps;}
main
public static void zookeeper_f417_0(String[] args)
{    try {        UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());        JFrame frame = new JFrame("ZooInspector");        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);        iconResource = new IconResource();        final ZooInspectorPanel zooInspectorPanel = new ZooInspectorPanel(new ZooInspectorManagerImpl(), iconResource);        frame.addWindowListener(new WindowAdapter() {            @Override            public void windowClosed(WindowEvent e) {                super.windowClosed(e);                zooInspectorPanel.disconnect(true);            }        });        frame.setContentPane(zooInspectorPanel);        frame.setSize(1024, 768);        frame.setVisible(true);    } catch (Exception e) {        LoggerFactory.getLogger().error("Error occurred loading ZooInspector", e);        JOptionPane.showMessageDialog(null, "ZooInspector failed to start: " + e.getMessage(), "Error", JOptionPane.ERROR_MESSAGE);    }}
windowClosed
public void zookeeper_f418_0(WindowEvent e)
{    super.windowClosed(e);    zooInspectorPanel.disconnect(true);}
close
public synchronized void zookeeper_f419_0() throws InterruptedException
{    this.closed = true;    super.close();}
create
public String zookeeper_f420_0(String path, byte[] data, List<ACL> acl, CreateMode createMode) throws KeeperException, InterruptedException
{    int count = 0;    do {        try {            return super.create(path, data, acl, createMode);        } catch (KeeperException.ConnectionLossException e) {            LoggerFactory.getLogger().warn("ZooKeeper connection lost.  Trying to reconnect.");            if (exists(path, false) != null) {                return path;            }        } catch (KeeperException.NodeExistsException e) {            return path;        }    } while (!closed && (limit == -1 || count++ < limit));    return null;}
delete
public void zookeeper_f421_0(String path, int version) throws InterruptedException, KeeperException
{    int count = 0;    do {        try {            super.delete(path, version);        } catch (KeeperException.ConnectionLossException e) {            LoggerFactory.getLogger().warn("ZooKeeper connection lost.  Trying to reconnect.");            if (exists(path, false) == null) {                return;            }        } catch (KeeperException.NoNodeException e) {            break;        }    } while (!closed && (limit == -1 || count++ < limit));}
exists
public Stat zookeeper_f422_0(String path, boolean watch) throws KeeperException, InterruptedException
{    int count = 0;    do {        try {            return super.exists(path, watch ? watcher : null);        } catch (KeeperException.ConnectionLossException e) {            LoggerFactory.getLogger().warn("ZooKeeper connection lost.  Trying to reconnect.");        }    } while (!closed && (limit == -1 || count++ < limit));    return null;}
exists
public Stat zookeeper_f423_0(String path, Watcher watcher) throws KeeperException, InterruptedException
{    int count = 0;    do {        try {            return super.exists(path, watcher);        } catch (KeeperException.ConnectionLossException e) {            LoggerFactory.getLogger().warn("ZooKeeper connection lost.  Trying to reconnect.");        }    } while (!closed && (limit == -1 || count++ < limit));    return null;}
getACL
public List<ACL> zookeeper_f424_0(String path, Stat stat) throws KeeperException, InterruptedException
{    int count = 0;    do {        try {            return super.getACL(path, stat);        } catch (KeeperException.ConnectionLossException e) {            LoggerFactory.getLogger().warn("ZooKeeper connection lost.  Trying to reconnect.");        }    } while (!closed && (limit == -1 || count++ < limit));    return null;}
getChildren
public List<String> zookeeper_f425_0(String path, boolean watch) throws KeeperException, InterruptedException
{    int count = 0;    do {        try {            return super.getChildren(path, watch ? watcher : null);        } catch (KeeperException.ConnectionLossException e) {            LoggerFactory.getLogger().warn("ZooKeeper connection lost.  Trying to reconnect.");        }    } while (!closed && (limit == -1 || count++ < limit));    return new ArrayList<String>();}
getChildren
public List<String> zookeeper_f426_0(String path, Watcher watcher) throws KeeperException, InterruptedException
{    int count = 0;    do {        try {            return super.getChildren(path, watcher);        } catch (KeeperException.ConnectionLossException e) {            LoggerFactory.getLogger().warn("ZooKeeper connection lost.  Trying to reconnect.");        }    } while (!closed && (limit == -1 || count++ < limit));    return new ArrayList<String>();}
getData
public byte[] zookeeper_f427_0(String path, boolean watch, Stat stat) throws KeeperException, InterruptedException
{    int count = 0;    do {        try {            return super.getData(path, watch ? watcher : null, stat);        } catch (KeeperException.ConnectionLossException e) {            LoggerFactory.getLogger().warn("ZooKeeper connection lost.  Trying to reconnect.");        }    } while (!closed && (limit == -1 || count++ < limit));    return null;}
getData
public byte[] zookeeper_f428_0(String path, Watcher watcher, Stat stat) throws KeeperException, InterruptedException
{    int count = 0;    do {        try {            return super.getData(path, watcher, stat);        } catch (KeeperException.ConnectionLossException e) {            LoggerFactory.getLogger().warn("ZooKeeper connection lost.  Trying to reconnect.");        }    } while (!closed && (limit == -1 || count++ < limit));    return null;}
setACL
public Stat zookeeper_f429_0(String path, List<ACL> acl, int aclVersion) throws KeeperException, InterruptedException
{    int count = 0;    do {        try {            return super.setACL(path, acl, aclVersion);        } catch (KeeperException.ConnectionLossException e) {            LoggerFactory.getLogger().warn("ZooKeeper connection lost.  Trying to reconnect.");            Stat s = exists(path, false);            if (s != null) {                if (getACL(path, s).equals(acl)) {                    return s;                }            } else {                return null;            }        }    } while (!closed && (limit == -1 || count++ < limit));    return null;}
setData
public Stat zookeeper_f430_0(String path, byte[] data, int version) throws KeeperException, InterruptedException
{    int count = 0;    do {        try {            return super.setData(path, data, version);        } catch (KeeperException.ConnectionLossException e) {            LoggerFactory.getLogger().warn("ZooKeeper connection lost.  Trying to reconnect.");            Stat s = exists(path, false);            if (s != null) {                if (getData(path, false, s) == data) {                    return s;                }            } else {                return null;            }        }    } while (!closed && (limit == -1 || count++ < limit));    return null;}
setRetryLimit
public void zookeeper_f431_0(int limit)
{    this.limit = limit;}
testConnection
public boolean zookeeper_f432_0()
{    int count = 0;    do {        try {            return super.exists("/", null) != null;        } catch (Exception e) {            LoggerFactory.getLogger().warn("ZooKeeper connection lost.  Trying to reconnect.");        }    } while (count++ < 5);    return false;}
main
public static void zookeeper_f433_0(String[] args) throws Exception
{    org.openjdk.jmh.Main.main(args);}
createWatchManager
 static IWatchManager zookeeper_f434_0(String className) throws Exception
{    Class clazz = Class.forName("org.apache.zookeeper.server.watch." + className);    return (IWatchManager) clazz.newInstance();}
forceGC
 static void zookeeper_f435_0()
{    int gcTimes = 3;    for (int i = 0; i < gcTimes; i++) {        try {            System.gc();            Thread.currentThread().sleep(1000);            System.runFinalization();            Thread.currentThread().sleep(1000);        } catch (InterruptedException ex) {        /* ignore */        }    }}
getMemoryUse
 static long zookeeper_f436_0()
{    forceGC();    long totalMem = Runtime.getRuntime().totalMemory();    forceGC();    long freeMem = Runtime.getRuntime().freeMemory();    return totalMem - freeMem;}
setup
public void zookeeper_f437_0() throws Exception
{    paths = new String[pathCount];    for (int i = 0; i < paths.length; i++) {        paths[i] = pathPrefix + i;    }    watchesAdded = 0;    watchManager = createWatchManager(watchManagerClass);    memWhenSetup = getMemoryUse();}
tearDown
public void zookeeper_f438_0()
{    long memUsed = getMemoryUse() - memWhenSetup;    System.out.println("Memory used: " + watchesAdded + " " + memUsed);    double memPerMillionWatchesMB = memUsed * 1.0 / watchesAdded;    System.out.println("Memory used per million watches " + String.format("%.2f", memPerMillionWatchesMB) + "MB");}
testAddConcentrateWatch
public void zookeeper_f439_0(IterationState state) throws Exception
{    Watcher watcher = new DumbWatcher();        for (String path : state.paths) {        if (state.watchManager.addWatch(path, watcher)) {            state.watchesAdded++;        }    }}
setup
public void zookeeper_f440_0() throws Exception
{    initialize();    prepare();}
initialize
 void zookeeper_f441_0() throws Exception
{    if (paths == null || paths.length != pathCount) {        paths = new String[pathCount];        for (int i = 0; i < pathCount; i++) {            paths[i] = pathPrefix + i;        }    }    if (watchers == null || watchers.length != watcherCount) {        watchers = new Watcher[watcherCount];        for (int i = 0; i < watcherCount; i++) {            watchers[i] = new DumbWatcher();        }    }    if (watchManager == null || !watchManager.getClass().getSimpleName().contains(watchManagerClass)) {        watchManager = createWatchManager(watchManagerClass);    }}
prepare
 void zookeeper_f442_0()
{    for (String path : paths) {        for (Watcher watcher : watchers) {            watchManager.addWatch(path, watcher);        }    }}
testTriggerConcentrateWatch
public void zookeeper_f443_0(InvocationState state) throws Exception
{    for (String path : state.paths) {        state.watchManager.triggerWatch(path, event);    }}
prepare
public void zookeeper_f444_0()
{    watchesAdded = 0;    memWhenSetup = getMemoryUse();}
tearDown
public void zookeeper_f445_0()
{    long memUsed = getMemoryUse() - memWhenSetup;    System.out.println("Memory used: " + watchesAdded + " " + memUsed);    double memPerMillionWatchesMB = memUsed * 1.0 / watchesAdded;    System.out.println("Memory used per million sparse watches " + String.format("%.2f", memPerMillionWatchesMB) + "MB");        for (String path : paths) {        watchManager.triggerWatch(path, event);    }}
testAddSparseWatch
public void zookeeper_f446_0(AddSparseWatchState state) throws Exception
{        for (Watcher watcher : state.watchers) {        if (state.watchManager.addWatch(state.paths[0], watcher)) {            state.watchesAdded++;        }    }        for (String path : state.paths) {        if (state.watchManager.addWatch(path, state.watchers[0])) {            state.watchesAdded++;        }    }}
prepare
public void zookeeper_f447_0()
{        for (Watcher watcher : watchers) {        watchManager.addWatch(paths[0], watcher);    }        for (String path : paths) {        watchManager.addWatch(path, watchers[0]);    }}
testTriggerSparseWatch
public void zookeeper_f448_0(TriggerSparseWatchState state) throws Exception
{    for (String path : state.paths) {        state.watchManager.triggerWatch(path, event);    }}
setUp
public void zookeeper_f449_0() throws Exception
{    if (!fakeMachines) {        zk = new ZooKeeper(zkHostPort, 15000, new Watcher() {            public void process(WatchedEvent e) {            }        });        im = new InstanceManager(zk, prefix);    }}
process
public void zookeeper_f450_0(WatchedEvent e)
{}
tearDown
public void zookeeper_f451_0() throws Exception
{    if (null != im) {        im.close();    }}
getHostPort
public String zookeeper_f452_0()
{    return serverHostPort;}
getServerCount
public int zookeeper_f453_0()
{    return serverCount;}
getClientCount
public int zookeeper_f454_0()
{    return clientCount;}
startServers
public void zookeeper_f455_0() throws IOException
{    for (int i = 0; i < serverCount; i++) {        startServer(i);    }}
stopServers
public void zookeeper_f456_0() throws IOException
{    for (int i = 0; i < serverCount; i++) {        stopServer(i);    }}
startClients
public void zookeeper_f457_0() throws IOException
{    for (int i = 0; i < clientCount; i++) {        startClient(i);    }}
stopClients
public void zookeeper_f458_0() throws IOException
{    for (int i = 0; i < clientCount; i++) {        stopClient(i);    }}
configureServers
public void zookeeper_f459_0(int count) throws Exception
{    serverCount = count;    if (fakeMachines) {        fakeConfigureServers(count);    } else {        distributedConfigureServers(count);    }}
distributedConfigureServers
private void zookeeper_f460_0(int count) throws IOException
{    StringBuilder sbClient = new StringBuilder();    StringBuilder sbServer = new StringBuilder();    try {        for (int i = 0; i < count; i++) {            String[] r = QuorumPeerInstance.createServer(im, i);            if (i > 0) {                sbClient.append(',');                sbServer.append(',');            }                        sbClient.append(r[0]);                        sbServer.append(r[1]);                        sbServer.append(";" + (r[0].split(":"))[1]);        }        serverHostPort = sbClient.toString();        quorumHostPort = sbServer.toString();    } catch (Exception e) {        IOException ioe = new IOException(e.getMessage());        ioe.setStackTrace(e.getStackTrace());        throw ioe;    }}
fakeConfigureServers
private void zookeeper_f461_0(int count) throws IOException
{    peers = new HashMap<Long, QuorumServer>();    qps = new QuorumPeer[count];    qpsDirs = new File[count];    for (int i = 1; i <= count; i++) {        InetSocketAddress peerAddress = new InetSocketAddress("127.0.0.1", fakeBasePort + i);        InetSocketAddress electionAddr = new InetSocketAddress("127.0.0.1", serverCount + fakeBasePort + i);        peers.put(Long.valueOf(i), new QuorumServer(i, peerAddress, electionAddr));    }    StringBuilder sb = new StringBuilder();    for (int i = 0; i < count; i++) {                testData.mkdirs();        qpsDirs[i] = File.createTempFile("sysTest", ".tmp", testData);        qpsDirs[i].delete();        qpsDirs[i].mkdir();        int port = fakeBasePort + 10 + i;        if (sb.length() > 0) {            sb.append(',');        }        sb.append("localhost:");        sb.append(port);    }    serverHostPort = sb.toString();}
startServer
public void zookeeper_f462_0(int index) throws IOException
{    int port = fakeBasePort + 10 + index;    if (fakeMachines) {        qps[index] = new QuorumPeer(peers, qpsDirs[index], qpsDirs[index], port, 3, index + 1, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);        qps[index].start();    } else {        try {            QuorumPeerInstance.startInstance(im, quorumHostPort, index);        } catch (Exception e) {            IOException ioe = new IOException(e.getClass().getName() + ": " + e.getMessage());            ioe.setStackTrace(e.getStackTrace());            throw ioe;        }    }}
stopServer
public void zookeeper_f463_0(int index) throws IOException
{    if (fakeMachines) {        qps[index].shutdown();    } else {        try {            QuorumPeerInstance.stopInstance(im, index);        } catch (Exception e) {            IOException ioe = new IOException(e.getMessage());            ioe.setStackTrace(e.getStackTrace());            throw ioe;        }    }}
configureClients
public void zookeeper_f464_0(int count, Class<? extends Instance> clazz, String params) throws Exception
{    clientCount = count;    if (fakeMachines) {        fakeConfigureClients(count, clazz, params);    } else {        distributedConfigureClients(count, clazz, params);    }}
distributedConfigureClients
private void zookeeper_f465_0(int count, Class<? extends Instance> clazz, String params) throws IOException
{    this.clazz = clazz;    this.params = params;}
fakeConfigureClients
private void zookeeper_f466_0(int count, Class<? extends Instance> clazz, String params) throws IOException, ClassNotFoundException
{    fakeBaseClients = new Instance[count];    for (int i = 0; i < count; i++) {        try {            fakeBaseClients[i] = clazz.newInstance();        } catch (InstantiationException e) {            e.printStackTrace();            return;        } catch (IllegalAccessException e) {            e.printStackTrace();            return;        }        fakeBaseClients[i].configure(i + " " + params);    }}
startClient
public void zookeeper_f467_0(int index) throws IOException
{    if (fakeMachines) {        fakeStartClient(index);    } else {        distributedStartClient(index);    }}
distributedStartClient
private void zookeeper_f468_0(int index) throws IOException
{    try {        im.assignInstance("client" + index, clazz, index + " " + params, 1);    } catch (Exception e) {        throw new IOException(e.getMessage());    }}
fakeStartClient
private void zookeeper_f469_0(int index)
{    fakeBaseClients[index].start();}
stopClient
public void zookeeper_f470_0(int index) throws IOException
{    if (fakeMachines) {        fakeStopClient(index);    } else {        distributedStopClient(index);    }}
distributedStopClient
private void zookeeper_f471_0(int index) throws IOException
{    try {        im.removeInstance("client" + index);    } catch (Exception e) {        throw new IOException(e.getMessage());    }}
fakeStopClient
private void zookeeper_f472_0(int index)
{    fakeBaseClients[index].stop();}
main
public static void zookeeper_f473_0(String[] args)
{    JUnitCore.main(args);}
add
 static synchronized void zookeeper_f474_0(long time, int count, Socket s)
{    long interval = time / INTERVAL;    if (currentInterval == 0 || currentInterval > interval) {        System.out.println("Dropping " + count + " for " + new Date(time) + " " + currentInterval + ">" + interval);        return;    }        Long total = totalByTime.get(interval);    if (total == null) {        totalByTime.put(interval, (long) count);    } else {        totalByTime.put(interval, total.longValue() + count);    }    tf.println(interval + " " + count + " " + s);}
remove
 static synchronized long zookeeper_f475_0(long interval)
{    Long total = totalByTime.remove(interval);    return total == null ? -1 : total;}
run
public void zookeeper_f476_0()
{    try {        System.out.println("Connected to " + s);        BufferedReader is = new BufferedReader(new InputStreamReader(s.getInputStream()));        String result;        while ((result = is.readLine()) != null) {            String[] timePercentCount = result.split(" ");            if (timePercentCount.length != 5) {                System.err.println("Got " + result + " from " + s + " exitng.");                throw new IOException(result);            }            long time = Long.parseLong(timePercentCount[0]);                        int count = Integer.parseInt(timePercentCount[2]);            int errs = Integer.parseInt(timePercentCount[3]);            if (errs > 0) {                System.out.println(s + " Got an error! " + errs);            }            add(time, count, s);        }    } catch (Exception e) {        e.printStackTrace();    } finally {        close();    }}
send
 void zookeeper_f477_0(int percentage)
{    try {        s.getOutputStream().write((percentage + "\n").getBytes());    } catch (IOException e) {        e.printStackTrace();    }}
close
 void zookeeper_f478_0()
{    try {        System.err.println("Closing " + s);        slaves.remove(this);        s.close();    } catch (IOException e) {        e.printStackTrace();    }}
run
public void zookeeper_f479_0()
{    try {        while (true) {            Socket s = ss.accept();            System.err.println("Accepted connection from " + s);            slaves.add(new SlaveThread(s));        }    } catch (IOException e) {        e.printStackTrace();    } finally {        for (Iterator<SlaveThread> it = slaves.iterator(); it.hasNext(); ) {            SlaveThread st = it.next();            it.remove();            st.close();        }    }}
run
public void zookeeper_f480_0()
{    try {        currentInterval = Time.currentElapsedTime() / INTERVAL;                Thread.sleep(INTERVAL * 2);        long min = 99999;        long max = 0;        long total = 0;        int number = 0;        while (true) {            long now = Time.currentElapsedTime();            long lastInterval = currentInterval;            currentInterval += 1;            long count = remove(lastInterval);                        count = count * 1000 / INTERVAL;                        if (lastChange != 0 && (lastChange + INTERVAL * 3) < now) {                if (count < min) {                    min = count;                }                if (count > max) {                    max = count;                }                total += count;                number++;                Calendar calendar = Calendar.getInstance();                calendar.setTimeInMillis(lastInterval * INTERVAL);                String report = lastInterval + " " + calendar.get(Calendar.HOUR_OF_DAY) + ":" + calendar.get(Calendar.MINUTE) + ":" + calendar.get(Calendar.SECOND) + " " + percentage + "% " + count + " " + min + " " + ((double) total / (double) number) + " " + max;                System.err.println(report);                if (sf != null) {                    sf.println(report);                }            } else {                max = total = 0;                min = 999999999;                number = 0;            }            Thread.sleep(INTERVAL);        }    } catch (Exception e) {        e.printStackTrace();    }}
sendChange
 static synchronized void zookeeper_f481_0(int percentage)
{    long now = Time.currentElapsedTime();    long start = now;    ReporterThread.percentage = percentage;    for (SlaveThread st : slaves.toArray(new SlaveThread[0])) {        st.send(percentage);    }    now = Time.currentElapsedTime();    long delay = now - start;    if (delay > 1000) {        System.out.println("Delay of " + delay + " to send new percentage");    }    lastChange = now;}
incOutstanding
 synchronized void zookeeper_f482_0() throws InterruptedException
{    outstanding++;    while (outstanding > outstandingLimit) {        wait();    }}
decOutstanding
 synchronized void zookeeper_f483_0()
{    outstanding--;    notifyAll();}
run
public voidf484_1)
{    try {        zk = new ZooKeeper(host, 60000, this);        synchronized (this) {            if (!connected) {                wait(20000);            }        }        for (int i = 0; i < 300; i++) {            try {                Thread.sleep(100);                path = zk.create("/client", new byte[16], Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);                break;            } catch (KeeperException e) {                            }        }        if (path == null) {            System.err.println("Couldn't create a node in /!");            return;        }        while (alive) {            if (r.nextInt(100) < percentage) {                zk.setData(path, bytes, -1, this, System.currentTimeMillis());            } else {                zk.getData(path, false, this, System.currentTimeMillis());            }            incOutstanding();        }    } catch (Exception e) {        e.printStackTrace();    } finally {        alive = false;        try {            zk.close();        } catch (InterruptedException e) {            e.printStackTrace();        }    }}
process
public void zookeeper_f485_0(WatchedEvent event)
{    System.err.println(event);    synchronized (this) {        if (event.getType() == EventType.None) {            connected = (event.getState() == KeeperState.SyncConnected);            notifyAll();        }    }}
processResult
public void zookeeper_f486_0(int rc, String path, Object ctx, byte[] data, Stat stat)
{    decOutstanding();    synchronized (statSync) {        if (!alive) {            return;        }        if (rc != 0) {            System.err.println("Got rc = " + rc);            errors++;        } else {            finished++;            rlatency += Time.currentElapsedTime() - (Long) ctx;            reads++;        }    }}
processResult
public void zookeeper_f487_0(int rc, String path, Object ctx, Stat stat)
{    decOutstanding();    synchronized (statSync) {        if (rc != 0) {            System.err.println("Got rc = " + rc);            errors++;        } else {            finished++;            wlatency += Time.currentElapsedTime() - (Long) ctx;            writes++;        }    }}
run
public void zookeeper_f488_0()
{    try {        OutputStream os = s.getOutputStream();        finished = 0;        errors = 0;        while (alive) {            Thread.sleep(300);            if (percentage == -1 || (finished == 0 && errors == 0)) {                continue;            }            String report = Time.currentElapsedTime() + " " + percentage + " " + finished + " " + errors + " " + outstanding + "\n";            /* String subreport = reads + " "                                + (((double) rlatency) / reads) + " " + writes                                + " " + (((double) wlatency / writes)); */            synchronized (statSync) {                finished = 0;                errors = 0;                reads = 0;                writes = 0;                rlatency = 0;                wlatency = 0;            }            os.write(report.getBytes());                }    } catch (Exception e) {        e.printStackTrace();    }}
configure
public void zookeeper_f489_0(final String params)
{    System.err.println("Got " + params);    new Thread() {        public void run() {            try {                String[] parts = params.split(" ");                String[] hostPort = parts[1].split(":");                int bytesSize = 1024;                if (parts.length == 3) {                    try {                        bytesSize = Integer.parseInt(parts[2]);                    } catch (Exception e) {                        System.err.println("Not an integer: " + parts[2]);                    }                }                bytes = new byte[bytesSize];                s = new Socket(hostPort[0], Integer.parseInt(hostPort[1]));                zkThread = new ZooKeeperThread(parts[0]);                sendThread = new SenderThread(s);                BufferedReader is = new BufferedReader(new InputStreamReader(s.getInputStream()));                String line;                while ((line = is.readLine()) != null) {                    percentage = Integer.parseInt(line);                }            } catch (Exception e) {                e.printStackTrace();            }        }    }.start();}
run
public void zookeeper_f490_0()
{    try {        String[] parts = params.split(" ");        String[] hostPort = parts[1].split(":");        int bytesSize = 1024;        if (parts.length == 3) {            try {                bytesSize = Integer.parseInt(parts[2]);            } catch (Exception e) {                System.err.println("Not an integer: " + parts[2]);            }        }        bytes = new byte[bytesSize];        s = new Socket(hostPort[0], Integer.parseInt(hostPort[1]));        zkThread = new ZooKeeperThread(parts[0]);        sendThread = new SenderThread(s);        BufferedReader is = new BufferedReader(new InputStreamReader(s.getInputStream()));        String line;        while ((line = is.readLine()) != null) {            percentage = Integer.parseInt(line);        }    } catch (Exception e) {        e.printStackTrace();    }}
setReporter
public void zookeeper_f491_0(Reporter r)
{    this.r = r;}
start
public void zookeeper_f492_0()
{    try {        r.report("started");    } catch (Exception e) {        e.printStackTrace();    }}
stop
public void zookeeper_f493_0()
{    alive = false;    zkThread.interrupt();    sendThread.interrupt();    try {        zkThread.join();    } catch (InterruptedException e) {        e.printStackTrace();    }    try {        sendThread.join();    } catch (InterruptedException e) {        e.printStackTrace();    }    try {        r.report("stopped");    } catch (Exception e) {        e.printStackTrace();    }    try {        s.close();    } catch (IOException e) {        e.printStackTrace();    }}
process
public void zookeeper_f494_0(WatchedEvent event)
{    if (event.getType() == Watcher.Event.EventType.None) {        synchronized (this) {            connected = event.getState() == Watcher.Event.KeeperState.SyncConnected;            notifyAll();        }    }}
waitConnected
public synchronized boolean zookeeper_f495_0(long timeout) throws InterruptedException
{    long endTime = Time.currentElapsedTime() + timeout;    while (!connected && Time.currentElapsedTime() < endTime) {        wait(endTime - Time.currentElapsedTime());    }    return connected;}
processOptions
private static String[] zookeeper_f496_0(String[] args)
{    ArrayList<String> newArgs = new ArrayList<String>();    for (String a : args) {        if (a.equals("--leaderOnly")) {            leaderOnly = true;            leaderServes = true;        } else if (a.equals("--leaderServes")) {            leaderServes = true;        } else {            newArgs.add(a);        }    }    return newArgs.toArray(new String[0]);}
main
public static void zookeeper_f497_0(String[] args) throws InterruptedException, KeeperException, NoAvailableContainers, DuplicateNameException, NoAssignmentException
{    args = processOptions(args);    if (args.length == 5) {        try {            StatusWatcher statusWatcher = new StatusWatcher();            ZooKeeper zk = new ZooKeeper(args[0], 15000, statusWatcher);            if (!statusWatcher.waitConnected(5000)) {                System.err.println("Could not connect to " + args[0]);                return;            }            InstanceManager im = new InstanceManager(zk, args[1]);            ss = new ServerSocket(0);            int port = ss.getLocalPort();            int serverCount = Integer.parseInt(args[2]);            int clientCount = Integer.parseInt(args[3]);            StringBuilder quorumHostPort = new StringBuilder();            StringBuilder zkHostPort = new StringBuilder();            for (int i = 0; i < serverCount; i++) {                String[] r = QuorumPeerInstance.createServer(im, i, leaderServes);                if (i > 0) {                    quorumHostPort.append(',');                    zkHostPort.append(',');                }                                zkHostPort.append(r[0]);                                quorumHostPort.append(r[1]);                                quorumHostPort.append(";" + (r[0].split(":"))[1]);            }            for (int i = 0; i < serverCount; i++) {                QuorumPeerInstance.startInstance(im, quorumHostPort.toString(), i);            }            if (leaderOnly) {                int tries = 0;                outer: while (true) {                    Thread.sleep(1000);                    IOException lastException = null;                    String[] parts = zkHostPort.toString().split(",");                    for (int i = 0; i < parts.length; i++) {                        try {                            String mode = getMode(parts[i]);                            if (mode.equals("leader")) {                                zkHostPort = new StringBuilder(parts[i]);                                System.out.println("Connecting exclusively to " + zkHostPort.toString());                                break outer;                            }                        } catch (IOException e) {                            lastException = e;                        }                    }                    if (tries++ > 3) {                        throw lastException;                    }                }            }            for (int i = 0; i < clientCount; i++) {                im.assignInstance("client" + i, GeneratorInstance.class, zkHostPort.toString() + ' ' + InetAddress.getLocalHost().getCanonicalHostName() + ':' + port, 1);            }            new AcceptorThread();            new ReporterThread();            BufferedReader is = new BufferedReader(new InputStreamReader(System.in));            String line;            while ((line = is.readLine()) != null) {                try {                    String[] cmdNumber = line.split(" ");                    if (cmdNumber[0].equals("percentage") && cmdNumber.length > 1) {                        int number = Integer.parseInt(cmdNumber[1]);                        if (number < 0 || number > 100) {                            throw new NumberFormatException("must be between 0 and 100");                        }                        sendChange(number);                    } else if (cmdNumber[0].equals("sleep") && cmdNumber.length > 1) {                        int number = Integer.parseInt(cmdNumber[1]);                        Thread.sleep(number * 1000);                    } else if (cmdNumber[0].equals("save") && cmdNumber.length > 1) {                        sf = new PrintStream(cmdNumber[1]);                    } else {                        System.err.println("Commands must be:");                        System.err.println("\tpercentage new_write_percentage");                        System.err.println("\tsleep seconds_to_sleep");                        System.err.println("\tsave file_to_save_output");                    }                } catch (NumberFormatException e) {                    System.out.println("Not a valid number: " + e.getMessage());                }            }        } catch (NumberFormatException e) {            doUsage();        } catch (IOException e) {            e.printStackTrace();            System.exit(ExitCode.INVALID_INVOCATION.getValue());        }    } else {        doUsage();    }}
getMode
private static String zookeeper_f498_0(String hostPort) throws NumberFormatException, UnknownHostException, IOException
{    String[] parts = hostPort.split(":");    Socket s = new Socket(parts[0], Integer.parseInt(parts[1]));    s.getOutputStream().write("stat".getBytes());    BufferedReader br = new BufferedReader(new InputStreamReader(s.getInputStream()));    String line;    try {        while ((line = br.readLine()) != null) {            if (line.startsWith("Mode: ")) {                return line.substring(6);            }        }        return "unknown";    } finally {        s.close();    }}
doUsage
private static void zookeeper_f499_0()
{    System.err.println("USAGE: " + GenerateLoad.class.getName() + " [--leaderOnly] [--leaderServes] zookeeper_host:port containerPrefix #ofServers #ofClients requestSize");    System.exit(ExitCode.INVALID_INVOCATION.getValue());}
process
public void zookeeper_f500_0(WatchedEvent event)
{    if (event.getPath() != null && event.getPath().equals(myNode)) {        zk.getData(myNode, this, dc, this);    }}
processResult
public void zookeeper_f501_0(int rc, String path, Object ctx, byte[] data, Stat stat)
{    if (rc == KeeperException.Code.NONODE.intValue()) {                return;    }    if (rc != KeeperException.Code.OK.intValue()) {        zk.getData(myNode, (Watcher) ctx, this, ctx);    }    int currVer = stat.getVersion();    if (currVer != lastVer) {        String[] parts = new String(data).split(" ", 2);        myInstance.configure(parts[1]);        lastVer = currVer;    }}
report
public void zookeeper_f502_0(String report) throws KeeperException, InterruptedException
{    for (int j = 0; j < maxTries; j++) {        try {            try {                zk.setData(myReportNode, report.getBytes(), -1);            } catch (NoNodeException e) {                zk.create(myReportNode, report.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);            }            break;        } catch (ConnectionLossException e) {        }    }}
rmnod
private void zookeeper_f503_0(String path) throws InterruptedException, KeeperException
{    KeeperException lastException = null;    for (int i = 0; i < maxTries; i++) {        try {            zk.delete(path, -1);            lastException = null;            break;        } catch (KeeperException.NoNodeException e) {                        break;        } catch (KeeperException e) {            lastException = e;        }    }    if (lastException != null) {        throw lastException;    }}
mknod_inner
private void zookeeper_f504_0(String path, CreateMode mode) throws KeeperException, InterruptedException
{    for (int i = 0; i < maxTries; i++) {        try {            zk.create(path, null, Ids.OPEN_ACL_UNSAFE, mode);            break;        } catch (NodeExistsException e) {            if (mode != CreateMode.EPHEMERAL) {                return;            }            Stat stat = zk.exists(path, false);            if (stat == null) {                continue;            }            if (stat.getEphemeralOwner() != zk.getSessionId()) {                throw e;            }            break;        } catch (ConnectionLossException e) {            e.printStackTrace();        }    }}
mknod
private void zookeeper_f505_0(String path, CreateMode mode) throws KeeperException, InterruptedException
{    String[] subpath = path.split("/");    StringBuilder sb = new StringBuilder();        for (int i = 1; i < subpath.length; i++) {        sb.append("/");        sb.append(subpath[i]);        CreateMode m = CreateMode.PERSISTENT;        if (i == subpath.length - 1) {            m = mode;        }        mknod_inner(sb.toString(), m);    }}
run
public void zookeeper_f506_0() throws IOException, InterruptedException, KeeperException
{    zk = new ZooKeeper(zkHostPort, sessTimeout, this);    mknod(assignmentsNode, CreateMode.PERSISTENT);    mknod(statusNode, CreateMode.EPHEMERAL);    mknod(reportsNode, CreateMode.PERSISTENT);        zk.getChildren(assignmentsNode, true, this, null);}
main
public static void zookeeper_f507_0(String[] args) throws UnknownHostException, IOException, InterruptedException, KeeperException
{    if (args.length != 3) {        System.err.println("USAGE: " + InstanceContainer.class.getName() + " name zkHostPort znodePrefix");        System.exit(ExitCode.INVALID_INVOCATION.getValue());    }    new InstanceContainer(args[0], args[1], args[2]).run();    while (true) {        Thread.sleep(1000);    }}
process
public voidf508_1WatchedEvent event)
{    if (KeeperState.Expired == event.getState()) {                        System.exit(ExitCode.ERROR_STARTING_ADMIN_SERVER.getValue());    }    if (event.getPath() != null && event.getPath().equals(assignmentsNode)) {                zk.getChildren(assignmentsNode, true, this, null);    }}
processResult
public voidf509_1int rc, String path, Object ctx, List<String> children)
{    if (rc != KeeperException.Code.OK.intValue()) {                zk.getChildren(assignmentsNode, true, this, null);        return;    }    Map<String, Instance> newList = new HashMap<String, Instance>();        Stat stat = new Stat();    for (String child : children) {        Instance i = instances.remove(child);        if (i == null) {                        byte[] data = null;            String myNode = assignmentsNode + '/' + child;            while (true) {                try {                    data = zk.getData(myNode, true, stat);                    break;                } catch (NoNodeException e) {                                        break;                } catch (KeeperException e) {                    e.printStackTrace();                } catch (InterruptedException e) {                    return;                }            }            if (data != null) {                String instanceSpec = new String(data);                int spaceIndex = instanceSpec.indexOf(' ');                String clazz;                String conf;                if (spaceIndex == -1) {                    clazz = instanceSpec;                    conf = null;                } else {                    clazz = instanceSpec.substring(0, spaceIndex);                    conf = instanceSpec.substring(spaceIndex + 1);                }                try {                    Class<?> c = Class.forName(clazz);                    i = (Instance) c.newInstance();                    Reporter reporter = new MyReporter(child);                    i.setReporter(reporter);                    i.configure(conf);                    i.start();                    newList.put(child, i);                    int ver = stat.getVersion();                    Instance myInstance = i;                    DataCallback dc = new MyDataCallback(myNode, myInstance, ver);                    Watcher watcher = new MyWatcher(myNode, dc);                    zk.getData(myNode, watcher, dc, watcher);                } catch (Exception e) {                                        if (e.getCause() != null) {                                            }                }            }        } else {                        newList.put(child, i);        }    }        for (Map.Entry<String, Instance> i : instances.entrySet()) {        i.getValue().stop();        try {            rmnod(reportsNode + '/' + i.getKey());        } catch (InterruptedException e) {            Thread.currentThread().interrupt();        } catch (KeeperException e) {            e.printStackTrace();        }    }    instances = newList;}
setupNodes
private void zookeeper_f510_0(ZooKeeper zk) throws KeeperException, InterruptedException
{    try {        zk.create(prefixNode, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    } catch (NodeExistsException e) {    /* this is ok */    }    try {        zk.create(assignmentsNode, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    } catch (NodeExistsException e) {    /* this is ok */    }    try {        zk.create(statusNode, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    } catch (NodeExistsException e) {    /* this is ok */    }    try {        zk.create(reportsNode, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    } catch (NodeExistsException e) {    /* this is ok */    }    try {        zk.create(readyNode, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    } catch (NodeExistsException e) {    /* this is ok */    }}
processResult
public synchronized voidf511_1int rc, String path, Object ctx, List<String> children)
{    if (rc != KeeperException.Code.OK.intValue()) {        zk.getChildren(statusNode, this, this, null);        return;    }    if (LOG.isDebugEnabled()) {            }    Map<String, HashSet<Assigned>> newAssignments = new HashMap<String, HashSet<Assigned>>();    for (String c : children) {        HashSet<Assigned> a = assignments.remove(c);        if (a != null) {            newAssignments.put(c, a);        } else {            newAssignments.put(c, new HashSet<Assigned>());        }    }        for (String dead : assignments.keySet()) {        try {            removeInstance(dead);        } catch (KeeperException e) {            e.printStackTrace();        } catch (InterruptedException e) {            Thread.currentThread().interrupt();        }    }    assignments = newAssignments;}
process
public void zookeeper_f512_0(WatchedEvent event)
{    if (event.getPath().equals(statusNode)) {        zk.getChildren(statusNode, this, this, null);    }}
assignInstance
public synchronized String zookeeper_f513_0(String name, Class<? extends Instance> clazz, String params, int weight) throws NoAvailableContainers, DuplicateNameException, InterruptedException, KeeperException
{    if (weight < 1) {                weight = 1;    }    String instanceSpec = clazz.getName() + ' ' + params;    if (instanceToAssignment.get(name) != null) {        throw new DuplicateNameException(name + " already exists");    }        String mostIdle = null;    int mostIdleWeight = Integer.MAX_VALUE;    for (String preferred : preferredList) {        HashSet<Assigned> assignmentList = assignments.get(preferred);        int w = 0;        if (assignmentList != null) {            for (Assigned a : assignmentList) {                w += a.weight;            }            if (w < mostIdleWeight) {                mostIdleWeight = w;                mostIdle = preferred;            }        }    }    for (Entry<String, HashSet<Assigned>> e : assignments.entrySet()) {        int w = 0;        for (Assigned a : e.getValue()) {            w += a.weight;        }        if (w < mostIdleWeight) {            mostIdleWeight = w;            mostIdle = e.getKey();        }    }    if (mostIdle == null) {        throw new NoAvailableContainers("No available containers");    }    Assigned a = new Assigned(mostIdle, weight);    instanceToAssignment.put(name, a);    HashSet<Assigned> as = assignments.get(mostIdle);    if (as == null) {        as = new HashSet<Assigned>();        assignments.put(mostIdle, as);    }    as.add(a);    KeeperException lastException = null;    for (int i = 0; i < maxTries; i++) {        try {            zk.create(assignmentsNode + '/' + mostIdle + '/' + name, instanceSpec.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);            return mostIdle;        } catch (NodeExistsException e) {            return mostIdle;        } catch (KeeperException e) {            lastException = e;        }    }    throw lastException;}
reconfigureInstance
public voidf514_1String name, String params) throws NoAssignmentException, InterruptedException, KeeperException
{    if (LOG.isDebugEnabled()) {            }    Assigned assigned = instanceToAssignment.get(name);    if (assigned == null) {        throw new NoAssignmentException();    }    KeeperException lastException = null;    for (int i = 0; i < maxTries; i++) {        try {            zk.setData(assignmentsNode + '/' + assigned.container + '/' + name, ("update " + params).getBytes(), -1);            break;        } catch (ConnectionLossException e) {            lastException = e;        }    }    if (lastException != null) {        throw lastException;    }}
doDelete
private void zookeeper_f515_0(String path) throws InterruptedException, KeeperException
{    KeeperException lastException = null;    for (int i = 0; i < maxTries; i++) {        try {            zk.delete(path, -1);            return;        } catch (NoNodeException e) {            return;        } catch (KeeperException e) {            lastException = e;        }    }    throw lastException;}
removeInstance
public synchronized void zookeeper_f516_0(String name) throws InterruptedException, KeeperException
{    Assigned assigned = instanceToAssignment.remove(name);    if (assigned == null) {        return;    }    assignments.get(assigned.container).remove(name);    doDelete(assignmentsNode + '/' + assigned.container + '/' + name);    doDelete(reportsNode + '/' + name);}
isAlive
 synchronized boolean zookeeper_f517_0(String name)
{    return instanceToAssignment.get(name) != null;}
resetStatus
public void zookeeper_f518_0(String name) throws InterruptedException, KeeperException
{    KeeperException lastException = null;    for (int i = 0; i < maxTries; i++) {        try {            zk.delete(reportsNode + '/' + name, -1);            lastException = null;            break;        } catch (ConnectionLossException e) {            lastException = e;        } catch (NoNodeException e) {                }    }    if (lastException != null) {        throw lastException;    }}
getStatus
public Stringf519_1String name, long timeout) throws KeeperException, InterruptedException
{    Stat stat = new Stat();    byte[] data = null;    long endTime = Time.currentElapsedTime() + timeout;    KeeperException lastException = null;    for (int i = 0; i < maxTries && endTime > Time.currentElapsedTime(); i++) {        try {            data = zk.getData(reportsNode + '/' + name, false, stat);            if (LOG.isDebugEnabled()) {                            }            lastException = null;            break;        } catch (ConnectionLossException e) {            lastException = e;        } catch (NoNodeException e) {            final Object eventObj = new Object();            synchronized (eventObj) {                                Stat eStat = zk.exists(reportsNode + '/' + name, new Watcher() {                    public void process(WatchedEvent event) {                        synchronized (eventObj) {                            eventObj.notifyAll();                        }                    }                });                if (eStat == null) {                    eventObj.wait(endTime - Time.currentElapsedTime());                }            }            lastException = e;        }    }    if (lastException != null) {        throw lastException;    }    return new String(data);}
process
public void zookeeper_f520_0(WatchedEvent event)
{    synchronized (eventObj) {        eventObj.notifyAll();    }}
close
public synchronized void zookeeper_f521_0() throws InterruptedException
{    for (String name : instanceToAssignment.keySet().toArray(new String[0])) {        try {            removeInstance(name);        } catch (KeeperException e) {            e.printStackTrace();        }    }    try {        doDelete(readyNode);    } catch (KeeperException e) {        e.printStackTrace();    }}
setReporter
public void zookeeper_f522_0(Reporter r)
{    this.r = r;}
configure
public voidf523_1String params)
{    if (clientAddr == null) {        String[] parts = params.split(" ");                        serverId = Integer.parseInt(parts[0]);        if (LOG.isDebugEnabled()) {                    }        if (parts.length > 1 && parts[1].equals("false")) {            System.setProperty("zookeeper.leaderServes", "no");        } else {            System.setProperty("zookeeper.leaderServes", "yes");        }                try {            ServerSocket ss = new ServerSocket(0, 1, InetAddress.getLocalHost());            clientAddr = (InetSocketAddress) ss.getLocalSocketAddress();            ss.close();        } catch (IOException e) {            e.printStackTrace();        }        try {            ServerSocket ss = new ServerSocket(0, 1, InetAddress.getLocalHost());            quorumLeaderAddr = (InetSocketAddress) ss.getLocalSocketAddress();            ss.close();        } catch (IOException e) {            e.printStackTrace();        }        try {            ServerSocket ss = new ServerSocket(0, 1, InetAddress.getLocalHost());            quorumLeaderElectionAddr = (InetSocketAddress) ss.getLocalSocketAddress();            ss.close();        } catch (IOException e) {            e.printStackTrace();        }        String report = clientAddr.getHostString() + ':' + clientAddr.getPort() + ',' + quorumLeaderAddr.getHostString() + ':' + quorumLeaderAddr.getPort() + ':' + quorumLeaderElectionAddr.getPort();        try {            if (LOG.isDebugEnabled()) {                            }            r.report(report);        } catch (Exception e) {            e.printStackTrace();        }        return;    } else {        int spaceIndex = params.indexOf(' ');        if (spaceIndex == -1) {                        return;        }        String quorumSpecs = params.substring(0, spaceIndex);        String cmd = params.substring(spaceIndex + 1);        if (LOG.isDebugEnabled()) {                    }        if (!cmd.equals("start")) {            if (peer != null) {                peer.shutdown();            }            peer = null;            try {                for (int i = 0; i < 5; i++) {                    Thread.sleep(500);                    try {                                                new Socket("127.0.0.1", clientAddr.getPort()).close();                    } catch (IOException e) {                        break;                    }                }                r.report("stopped");            } catch (Exception e) {                            }            return;        }        String[] parts = quorumSpecs.split(",");        peers = new HashMap<Long, QuorumServer>();        for (int i = 0; i < parts.length; i++) {                        String[] subparts = ((parts[i].split(";"))[0]).split(":");            String clientPort = (parts[i].split(";"))[1];            peers.put(Long.valueOf(i), new QuorumServer(i, new InetSocketAddress(subparts[0], Integer.parseInt(subparts[1])), new InetSocketAddress(subparts[0], Integer.parseInt(subparts[2])), new InetSocketAddress(subparts[0], Integer.parseInt(clientPort))));        }        try {            if (LOG.isDebugEnabled()) {                            }            if (peer != null) {                                return;            }            System.err.println("SnapDir = " + snapDir + " LogDir = " + logDir);            peer = new QuorumPeer(peers, snapDir, logDir, clientAddr.getPort(), 3, serverId, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);            peer.start();            for (int i = 0; i < 5; i++) {                Thread.sleep(500);                try {                                        new Socket("127.0.0.1", clientAddr.getPort()).close();                    break;                } catch (IOException e) {                }            }            r.report("started");        } catch (Exception e) {                    }    }}
start
public void zookeeper_f524_0()
{}
stop
public voidf525_1)
{    if (LOG.isDebugEnabled()) {            }    if (peer != null) {        peer.shutdown();    }    if (logDir != null) {        TestUtils.deleteFileRecursively(logDir);    }    if (snapDir != null) {        TestUtils.deleteFileRecursively(snapDir);    }}
createServer
public static String[] zookeeper_f526_0(InstanceManager im, int i) throws NoAvailableContainers, DuplicateNameException, InterruptedException, KeeperException
{    return createServer(im, i, true);}
createServer
public static String[] zookeeper_f527_0(InstanceManager im, int i, boolean leaderServes) throws NoAvailableContainers, DuplicateNameException, InterruptedException, KeeperException
{    im.assignInstance("server" + i, QuorumPeerInstance.class, Integer.toString(i) + " " + leaderServes, 50);    return im.getStatus("server" + i, 3000).split(",");}
startInstance
public static void zookeeper_f528_0(InstanceManager im, String quorumHostPort, int index) throws InterruptedException, KeeperException, NoAssignmentException
{    im.resetStatus("server" + index);    im.reconfigureInstance("server" + index, quorumHostPort + " start");    im.getStatus("server" + index, 5000);}
stopInstance
public static void zookeeper_f529_0(InstanceManager im, int index) throws InterruptedException, KeeperException, NoAssignmentException
{    im.resetStatus("server" + index);    im.reconfigureInstance("server" + index, Integer.toString(index) + " stop");    im.getStatus("server" + index, 3000);}
configure
public void zookeeper_f530_0(String params)
{    String[] parts = params.split(" ");    hostPort = parts[1];    this.index = Integer.parseInt(parts[0]);    myPath = "/simpleCase/" + index;}
start
public void zookeeper_f531_0()
{    try {        zk = new ZooKeeper(hostPort, 15000, this);        zk.getData("/simpleCase", true, this, null);        if (null != r) {            r.report("Client " + index + " connecting to " + hostPort);        }    } catch (Exception e) {        e.printStackTrace();    }}
stop
public void zookeeper_f532_0()
{    try {        if (zk != null) {            zk.close();        }    } catch (InterruptedException e) {        e.printStackTrace();    }}
process
public void zookeeper_f533_0(WatchedEvent event)
{    if (event.getPath() != null && event.getPath().equals("/simpleCase")) {        zk.getData("/simpleCase", true, this, null);    }}
processResult
public void zookeeper_f534_0(int rc, String path, Object ctx, byte[] data, Stat stat)
{    if (rc != 0) {        zk.getData("/simpleCase", true, this, null);    } else {        this.data = data;        String content = new String(data);        if (content.equals("die")) {            this.stop();            return;        }        if (!createdEphemeral) {            zk.create(myPath, data, Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL, this, null);            createdEphemeral = true;        } else {            zk.setData(myPath, data, -1, this, null);        }    }}
processResult
public void zookeeper_f535_0(int rc, String path, Object ctx, String name)
{    if (rc != 0) {        zk.create(myPath, data, Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL, this, null);    }}
processResult
public void zookeeper_f536_0(int rc, String path, Object ctx, Stat stat)
{    if (rc != 0) {        zk.setData(myPath, data, -1, this, null);    }}
toString
public String zookeeper_f537_0()
{    return SimpleClient.class.getName() + "[" + index + "] using " + hostPort;}
setReporter
public void zookeeper_f538_0(Reporter r)
{    this.r = r;}
waitForConnect
private synchronized boolean zookeeper_f539_0(ZooKeeper zk, long timeout) throws InterruptedException
{    connected = (zk.getState() == States.CONNECTED);    long end = Time.currentElapsedTime() + timeout;    while (!connected && end > Time.currentElapsedTime()) {        wait(timeout);        connected = (zk.getState() == States.CONNECTED);    }    return connected;}
testSimpleCase
public voidf540_1) throws Exception
{    configureServers(serverCount);    configureClients(clientCount, SimpleClient.class, getHostPort());    Stat stat = new Stat();    startServers();        ZooKeeper zk = new ZooKeeper(getHostPort(), 15000, this);    waitForConnect(zk, 10000);    zk.create("/simpleCase", "orig".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    startClients();        for (int i = 0; i < getClientCount(); i++) {        for (int j = 0; j < maxTries; j++) {            try {                byte[] b = zk.getData("/simpleCase/" + i, false, stat);                Assert.assertEquals("orig", new String(b));            } catch (NoNodeException e) {                if (j + 1 == maxTries) {                    Assert.fail("Max tries exceeded on client " + i);                }                Thread.sleep(1000);            }        }    }        for (int i = 0; i < getServerCount(); i++) {        stopServer(i);        if (i + 1 > getServerCount() / 2) {            startServer(i);        } else if (i + 1 == getServerCount() / 2) {            Assert.assertTrue("Connection didn't recover", waitForConnect(zk, 10000));            try {                zk.setData("/simpleCase", "new".getBytes(), -1);            } catch (ConnectionLossException e) {                Assert.assertTrue("Connection didn't recover", waitForConnect(zk, 10000));                zk.setData("/simpleCase", "new".getBytes(), -1);            }            for (int j = 0; j < i; j++) {                                startServer(i);            }        }    }        Thread.sleep(100);    Assert.assertTrue("Servers didn't bounce", waitForConnect(zk, 15000));    try {        zk.getData("/simpleCase", false, stat);    } catch (ConnectionLossException e) {        Assert.assertTrue("Servers didn't bounce", waitForConnect(zk, 15000));    }        for (int i = 0; i < getClientCount(); i++) {        for (int j = 0; j < maxTries; j++) {            byte[] data = zk.getData("/simpleCase/" + i, false, stat);            if (new String(data).equals("new")) {                break;            }            if (j + 1 == maxTries) {                Assert.fail("max tries exceeded for " + i);            }            Thread.sleep(1000);        }    }        zk.setData("/simpleCase", "die".getBytes(), -1);        for (int i = 0; i < getClientCount(); i++) {        try {            for (int j = 0; j < maxTries; j++) {                zk.getData("/simpleCase/" + i, false, stat);                if (j + 1 == maxTries) {                    Assert.fail("max tries exceeded waiting for child " + i + " to die");                }                Thread.sleep(200);            }        } catch (NoNodeException e) {                }    }    stopClients();    stopServers();}
process
public void zookeeper_f541_0(WatchedEvent event)
{    if (event.getState() == KeeperState.SyncConnected) {        synchronized (this) {            connected = true;            notifyAll();        }    } else if (event.getState() == KeeperState.Disconnected) {        synchronized (this) {            connected = false;            notifyAll();        }    }}
getArchive
public static BinaryInputArchive zookeeper_f542_0(InputStream strm)
{    return new BinaryInputArchive(new DataInputStream(strm));}
done
public boolean zookeeper_f543_0()
{    return (nelems <= 0);}
incr
public void zookeeper_f544_0()
{    nelems--;}
readByte
public byte zookeeper_f545_0(String tag) throws IOException
{    return in.readByte();}
readBool
public boolean zookeeper_f546_0(String tag) throws IOException
{    return in.readBoolean();}
readInt
public int zookeeper_f547_0(String tag) throws IOException
{    return in.readInt();}
readLong
public long zookeeper_f548_0(String tag) throws IOException
{    return in.readLong();}
readFloat
public float zookeeper_f549_0(String tag) throws IOException
{    return in.readFloat();}
readDouble
public double zookeeper_f550_0(String tag) throws IOException
{    return in.readDouble();}
readString
public String zookeeper_f551_0(String tag) throws IOException
{    int len = in.readInt();    if (len == -1) {        return null;    }    checkLength(len);    byte[] b = new byte[len];    in.readFully(b);    return new String(b, StandardCharsets.UTF_8);}
readBuffer
public byte[] zookeeper_f552_0(String tag) throws IOException
{    int len = readInt(tag);    if (len == -1) {        return null;    }    checkLength(len);    byte[] arr = new byte[len];    in.readFully(arr);    return arr;}
readRecord
public void zookeeper_f553_0(Record r, String tag) throws IOException
{    r.deserialize(this, tag);}
startRecord
public void zookeeper_f554_0(String tag) throws IOException
{}
endRecord
public void zookeeper_f555_0(String tag) throws IOException
{}
startVector
public Index zookeeper_f556_0(String tag) throws IOException
{    int len = readInt(tag);    if (len == -1) {        return null;    }    return new BinaryIndex(len);}
endVector
public void zookeeper_f557_0(String tag) throws IOException
{}
startMap
public Index zookeeper_f558_0(String tag) throws IOException
{    return new BinaryIndex(readInt(tag));}
endMap
public void zookeeper_f559_0(String tag) throws IOException
{}
checkLength
private void zookeeper_f560_0(int len) throws IOException
{    if (len < 0 || len > maxBufferSize + extraMaxBufferSize) {        throw new IOException(UNREASONBLE_LENGTH + len);    }}
getArchive
public static BinaryOutputArchive zookeeper_f561_0(OutputStream strm)
{    return new BinaryOutputArchive(new DataOutputStream(strm));}
writeByte
public void zookeeper_f562_0(byte b, String tag) throws IOException
{    out.writeByte(b);}
writeBool
public void zookeeper_f563_0(boolean b, String tag) throws IOException
{    out.writeBoolean(b);}
writeInt
public void zookeeper_f564_0(int i, String tag) throws IOException
{    out.writeInt(i);}
writeLong
public void zookeeper_f565_0(long l, String tag) throws IOException
{    out.writeLong(l);}
writeFloat
public void zookeeper_f566_0(float f, String tag) throws IOException
{    out.writeFloat(f);}
writeDouble
public void zookeeper_f567_0(double d, String tag) throws IOException
{    out.writeDouble(d);}
stringToByteBuffer
private ByteBuffer zookeeper_f568_0(CharSequence s)
{    bb.clear();    final int len = s.length();    for (int i = 0; i < len; i++) {        if (bb.remaining() < 3) {            ByteBuffer n = ByteBuffer.allocate(bb.capacity() << 1);            bb.flip();            n.put(bb);            bb = n;        }        char c = s.charAt(i);        if (c < 0x80) {            bb.put((byte) c);        } else if (c < 0x800) {            bb.put((byte) (0xc0 | (c >> 6)));            bb.put((byte) (0x80 | (c & 0x3f)));        } else {            bb.put((byte) (0xe0 | (c >> 12)));            bb.put((byte) (0x80 | ((c >> 6) & 0x3f)));            bb.put((byte) (0x80 | (c & 0x3f)));        }    }    bb.flip();    return bb;}
writeString
public void zookeeper_f569_0(String s, String tag) throws IOException
{    if (s == null) {        writeInt(-1, "len");        return;    }    ByteBuffer bb = stringToByteBuffer(s);    writeInt(bb.remaining(), "len");    out.write(bb.array(), bb.position(), bb.limit());}
writeBuffer
public void zookeeper_f570_0(byte[] barr, String tag) throws IOException
{    if (barr == null) {        out.writeInt(-1);        return;    }    out.writeInt(barr.length);    out.write(barr);}
writeRecord
public void zookeeper_f571_0(Record r, String tag) throws IOException
{    r.serialize(this, tag);}
startRecord
public void zookeeper_f572_0(Record r, String tag) throws IOException
{}
endRecord
public void zookeeper_f573_0(Record r, String tag) throws IOException
{}
startVector
public void zookeeper_f574_0(List<?> v, String tag) throws IOException
{    if (v == null) {        writeInt(-1, tag);        return;    }    writeInt(v.size(), tag);}
endVector
public void zookeeper_f575_0(List<?> v, String tag) throws IOException
{}
startMap
public void zookeeper_f576_0(TreeMap<?, ?> v, String tag) throws IOException
{    writeInt(v.size(), tag);}
endMap
public void zookeeper_f577_0(TreeMap<?, ?> v, String tag) throws IOException
{}
genCode
 void zookeeper_f578_0() throws IOException
{    if (!outputDirectory.exists()) {        if (!outputDirectory.mkdirs()) {            throw new IOException("unable to create output directory " + outputDirectory);        }    }    try (FileWriter c = new FileWriter(new File(outputDirectory, mName + ".c"));        FileWriter h = new FileWriter(new File(outputDirectory, mName + ".h"))) {        h.write("/**\n");        h.write("* Licensed to the Apache Software Foundation (ASF) under one\n");        h.write("* or more contributor license agreements.  See the NOTICE file\n");        h.write("* distributed with this work for additional information\n");        h.write("* regarding copyright ownership.  The ASF licenses this file\n");        h.write("* to you under the Apache License, Version 2.0 (the\n");        h.write("* \"License\"); you may not use this file except in compliance\n");        h.write("* with the License.  You may obtain a copy of the License at\n");        h.write("*\n");        h.write("*     http://www.apache.org/licenses/LICENSE-2.0\n");        h.write("*\n");        h.write("* Unless required by applicable law or agreed to in writing, software\n");        h.write("* distributed under the License is distributed on an \"AS IS\" BASIS,\n");        h.write("* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n");        h.write("* See the License for the specific language governing permissions and\n");        h.write("* limitations under the License.\n");        h.write("*/\n");        h.write("\n");        c.write("/**\n");        c.write("* Licensed to the Apache Software Foundation (ASF) under one\n");        c.write("* or more contributor license agreements.  See the NOTICE file\n");        c.write("* distributed with this work for additional information\n");        c.write("* regarding copyright ownership.  The ASF licenses this file\n");        c.write("* to you under the Apache License, Version 2.0 (the\n");        c.write("* \"License\"); you may not use this file except in compliance\n");        c.write("* with the License.  You may obtain a copy of the License at\n");        c.write("*\n");        c.write("*     http://www.apache.org/licenses/LICENSE-2.0\n");        c.write("*\n");        c.write("* Unless required by applicable law or agreed to in writing, software\n");        c.write("* distributed under the License is distributed on an \"AS IS\" BASIS,\n");        c.write("* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n");        c.write("* See the License for the specific language governing permissions and\n");        c.write("* limitations under the License.\n");        c.write("*/\n");        c.write("\n");        h.write("#ifndef __" + mName.toUpperCase().replace('.', '_') + "__\n");        h.write("#define __" + mName.toUpperCase().replace('.', '_') + "__\n");        h.write("#include \"recordio.h\"\n");        for (Iterator<JFile> i = mInclFiles.iterator(); i.hasNext(); ) {            JFile f = i.next();            h.write("#include \"" + f.getName() + ".h\"\n");        }                h.write("\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n");                c.write("#include <stdlib.h>\n");        c.write("#include \"" + mName + ".h\"\n\n");        for (Iterator<JRecord> i = mRecList.iterator(); i.hasNext(); ) {            JRecord jr = i.next();            jr.genCCode(h, c);        }        h.write("\n#ifdef __cplusplus\n}\n#endif\n\n");        h.write("#endif //" + mName.toUpperCase().replace('.', '_') + "__\n");    }}
genCode
 void zookeeper_f579_0() throws IOException
{    if (!outputDirectory.exists()) {        if (!outputDirectory.mkdirs()) {            throw new IOException("unable to create output directory " + outputDirectory);        }    }    try (FileWriter cc = new FileWriter(new File(outputDirectory, mName + ".cc"));        FileWriter hh = new FileWriter(new File(outputDirectory, mName + ".hh"))) {        hh.write("/**\n");        hh.write("* Licensed to the Apache Software Foundation (ASF) under one\n");        hh.write("* or more contributor license agreements.  See the NOTICE file\n");        hh.write("* distributed with this work for additional information\n");        hh.write("* regarding copyright ownership.  The ASF licenses this file\n");        hh.write("* to you under the Apache License, Version 2.0 (the\n");        hh.write("* \"License\"); you may not use this file except in compliance\n");        hh.write("* with the License.  You may obtain a copy of the License at\n");        hh.write("*\n");        hh.write("*     http://www.apache.org/licenses/LICENSE-2.0\n");        hh.write("*\n");        hh.write("* Unless required by applicable law or agreed to in writing, software\n");        hh.write("* distributed under the License is distributed on an \"AS IS\" BASIS,\n");        hh.write("* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n");        hh.write("* See the License for the specific language governing permissions and\n");        hh.write("* limitations under the License.\n");        hh.write("*/\n");        hh.write("\n");        cc.write("/**\n");        cc.write("* Licensed to the Apache Software Foundation (ASF) under one\n");        cc.write("* or more contributor license agreements.  See the NOTICE file\n");        cc.write("* distributed with this work for additional information\n");        cc.write("* regarding copyright ownership.  The ASF licenses this file\n");        cc.write("* to you under the Apache License, Version 2.0 (the\n");        cc.write("* \"License\"); you may not use this file except in compliance\n");        cc.write("* with the License.  You may obtain a copy of the License at\n");        cc.write("*\n");        cc.write("*     http://www.apache.org/licenses/LICENSE-2.0\n");        cc.write("*\n");        cc.write("* Unless required by applicable law or agreed to in writing, software\n");        cc.write("* distributed under the License is distributed on an \"AS IS\" BASIS,\n");        cc.write("* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n");        cc.write("* See the License for the specific language governing permissions and\n");        cc.write("* limitations under the License.\n");        cc.write("*/\n");        cc.write("\n");        hh.write("#ifndef __" + mName.toUpperCase().replace('.', '_') + "__\n");        hh.write("#define __" + mName.toUpperCase().replace('.', '_') + "__\n");        hh.write("#include \"recordio.hh\"\n");        for (Iterator<JFile> i = mInclFiles.iterator(); i.hasNext(); ) {            JFile f = i.next();            hh.write("#include \"" + f.getName() + ".hh\"\n");        }        cc.write("#include \"" + mName + ".hh\"\n");        for (Iterator<JRecord> i = mRecList.iterator(); i.hasNext(); ) {            JRecord jr = i.next();            jr.genCppCode(hh, cc);        }        hh.write("#endif //" + mName.toUpperCase().replace('.', '_') + "__\n");    }}
genCode
 void zookeeper_f580_0() throws IOException
{    for (JRecord rec : mRecList) {        rec.genCsharpCode(outputDirectory);    }}
genCode
 void zookeeper_f581_0() throws IOException
{    for (Iterator<JRecord> i = mRecList.iterator(); i.hasNext(); ) {        JRecord rec = i.next();        rec.genJavaCode(outputDirectory);    }}
getSignature
public String zookeeper_f582_0()
{    return "z";}
genJavaCompareTo
public String zookeeper_f583_0(String fname)
{    return "    ret = (" + fname + " == peer." + fname + ")? 0 : (" + fname + "?1:-1);\n";}
genJavaHashCode
public String zookeeper_f584_0(String fname)
{    return "     ret = (" + fname + ")?0:1;\n";}
genCsharpHashCode
 String zookeeper_f585_0(String fname)
{    return "     ret = (" + capitalize(fname) + ")?0:1;\n";}
genCsharpCompareTo
 String zookeeper_f586_0(String name)
{    return "    ret = (" + capitalize(name) + " == peer." + capitalize(name) + ")? 0 : (" + capitalize(name) + "?1:-1);\n";}
genCppGetSet
public String zookeeper_f587_0(String fname, int fIdx)
{    String cgetFunc = "  virtual const " + getCppType() + "& get" + fname + "() const {\n";    cgetFunc += "    return m" + fname + ";\n";    cgetFunc += "  }\n";    String getFunc = "  virtual " + getCppType() + "& get" + fname + "() {\n";    getFunc += "    bs_.set(" + fIdx + ");return m" + fname + ";\n";    getFunc += "  }\n";    return cgetFunc + getFunc;}
getSignature
public String zookeeper_f588_0()
{    return "B";}
genJavaReadWrapper
public String zookeeper_f589_0(String fname, String tag, boolean decl)
{    String ret = "";    if (decl) {        ret = "    byte[] " + fname + ";\n";    }    return ret + "        " + fname + "=a_.readBuffer(\"" + tag + "\");\n";}
genJavaWriteWrapper
public String zookeeper_f590_0(String fname, String tag)
{    return "        a_.writeBuffer(" + fname + ",\"" + tag + "\");\n";}
genJavaCompareTo
public String zookeeper_f591_0(String fname, String other)
{    StringBuilder sb = new StringBuilder();    sb.append("    {\n");    sb.append("      byte[] my = " + fname + ";\n");    sb.append("      byte[] ur = " + other + ";\n");    sb.append("      ret = org.apache.jute.Utils.compareBytes(my,0,my.length,ur,0,ur.length);\n");    sb.append("    }\n");    return sb.toString();}
genJavaCompareTo
public String zookeeper_f592_0(String fname)
{    return genJavaCompareTo(fname, "peer." + fname);}
genJavaCompareToWrapper
public String zookeeper_f593_0(String fname, String other)
{    return "    " + genJavaCompareTo(fname, other);}
genJavaEquals
public String zookeeper_f594_0(String fname, String peer)
{    return "    ret = org.apache.jute.Utils.bufEquals(" + fname + "," + peer + ");\n";}
genJavaHashCode
public String zookeeper_f595_0(String fname)
{    return "    ret = java.util.Arrays.toString(" + fname + ").hashCode();\n";}
genJavaSlurpBytes
public String zookeeper_f596_0(String b, String s, String l)
{    StringBuilder sb = new StringBuilder();    sb.append("        {\n");    sb.append("           int i = org.apache.jute.Utils.readVInt(" + b + ", " + s + ");\n");    sb.append("           int z = WritableUtils.getVIntSize(i);\n");    sb.append("           " + s + " += z+i; " + l + " -= (z+i);\n");    sb.append("        }\n");    return sb.toString();}
genJavaCompareBytes
public String zookeeper_f597_0()
{    StringBuilder sb = new StringBuilder();    sb.append("        {\n");    sb.append("           int i1 = org.apache.jute.Utils.readVInt(b1, s1);\n");    sb.append("           int i2 = org.apache.jute.Utils.readVInt(b2, s2);\n");    sb.append("           int z1 = WritableUtils.getVIntSize(i1);\n");    sb.append("           int z2 = WritableUtils.getVIntSize(i2);\n");    sb.append("           s1+=z1; s2+=z2; l1-=z1; l2-=z2;\n");    sb.append("           int r1 = org.apache.jute.Utils.compareBytes(b1,s1,l1,b2,s2,l2);\n");    sb.append("           if (r1 != 0) { return (r1<0)?-1:0; }\n");    sb.append("           s1+=i1; s2+=i2; l1-=i1; l1-=i2;\n");    sb.append("        }\n");    return sb.toString();}
getSignature
public String zookeeper_f598_0()
{    return "b";}
genCppGetSet
 String zookeeper_f599_0(String fname, int fIdx)
{    String cgetFunc = "  virtual const " + getCppType() + "& get" + fname + "() const {\n";    cgetFunc += "    return m" + fname + ";\n";    cgetFunc += "  }\n";    String getFunc = "  virtual " + getCppType() + "& get" + fname + "() {\n";    getFunc += "    bs_.set(" + fIdx + ");return m" + fname + ";\n";    getFunc += "  }\n";    return cgetFunc + getFunc;}
genJavaCompareTo
 String zookeeper_f600_0(String fname)
{    return "    ret = " + fname + ".compareTo(peer." + fname + ");\n";}
genJavaEquals
 String zookeeper_f601_0(String fname, String peer)
{    return "    ret = " + fname + ".equals(" + peer + ");\n";}
genJavaHashCode
 String zookeeper_f602_0(String fname)
{    return "    ret = " + fname + ".hashCode();\n";}
genCsharpHashCode
 String zookeeper_f603_0(String fname)
{    return "    ret = " + capitalize(fname) + ".GetHashCode();\n";}
genCsharpEquals
 String zookeeper_f604_0(String name, String peer)
{    String[] peerSplit = peer.split("\\.");    return "    ret = " + capitalize(name) + ".Equals(" + peerSplit[0] + "." + capitalize(peerSplit[1]) + ");\n";}
genCsharpCompareTo
 String zookeeper_f605_0(String name)
{    return "    ret = " + capitalize(name) + ".CompareTo(peer." + capitalize(name) + ");\n";}
getSignature
public String zookeeper_f606_0()
{    return "d";}
genJavaHashCode
public String zookeeper_f607_0(String fname)
{    String tmp = "Double.doubleToLongBits(" + fname + ")";    return "    ret = (int)(" + tmp + "^(" + tmp + ">>>32));\n";}
getSignature
public String zookeeper_f608_0()
{    return mType.getSignature();}
genCppDecl
public String zookeeper_f609_0()
{    return mType.genCppDecl(mName);}
genCDecl
public String zookeeper_f610_0()
{    return mType.genCDecl(mName);}
genCsharpDecl
public String zookeeper_f611_0()
{    return mType.genCsharpDecl(mName);}
genCsharpConstructorParam
public String zookeeper_f612_0(String fname)
{    return mType.genCsharpConstructorParam(fname);}
genJavaDecl
public String zookeeper_f613_0()
{    return mType.genJavaDecl(mName);}
genJavaConstructorParam
public String zookeeper_f614_0(String fname)
{    return mType.genJavaConstructorParam(fname);}
getName
public String zookeeper_f615_0()
{    return mName;}
getCsharpName
public String zookeeper_f616_0()
{    return "Id".equals(mName) ? "ZKId" : mName;}
getTag
public String zookeeper_f617_0()
{    return mName;}
getType
public JType zookeeper_f618_0()
{    return mType;}
genCppGetSet
public String zookeeper_f619_0(int fIdx)
{    return mType.genCppGetSet(mName, fIdx);}
genCsharpConstructorSet
public String zookeeper_f620_0(String fname)
{    return mType.genCsharpConstructorSet(mName, fname);}
genCsharpGetSet
public String zookeeper_f621_0(int fIdx)
{    return mType.genCsharpGetSet(getCsharpName(), fIdx);}
genCsharpWriteMethodName
public String zookeeper_f622_0()
{    return mType.genCsharpWriteMethod(getCsharpName(), getTag());}
genCsharpReadMethodName
public String zookeeper_f623_0()
{    return mType.genCsharpReadMethod(getCsharpName(), getTag());}
genCsharpCompareTo
public String zookeeper_f624_0()
{    return mType.genCsharpCompareTo(getCsharpName());}
genCsharpEquals
public String zookeeper_f625_0()
{    return mType.genCsharpEquals(getCsharpName(), "peer." + getCsharpName());}
genCsharpHashCode
public String zookeeper_f626_0()
{    return mType.genCsharpHashCode(getCsharpName());}
genJavaGetSet
public String zookeeper_f627_0(int fIdx)
{    return mType.genJavaGetSet(mName, fIdx);}
genJavaWriteMethodName
public String zookeeper_f628_0()
{    return mType.genJavaWriteMethod(getName(), getTag());}
genJavaReadMethodName
public String zookeeper_f629_0()
{    return mType.genJavaReadMethod(getName(), getTag());}
genJavaCompareTo
public String zookeeper_f630_0()
{    return mType.genJavaCompareTo(getName());}
genJavaEquals
public String zookeeper_f631_0()
{    return mType.genJavaEquals(getName(), "peer." + getName());}
genJavaHashCode
public String zookeeper_f632_0()
{    return mType.genJavaHashCode(getName());}
genJavaConstructorSet
public String zookeeper_f633_0(String fname)
{    return mType.genJavaConstructorSet(mName, fname);}
getName
 String zookeeper_f634_0()
{    int idx = mName.lastIndexOf('/');    return (idx > 0) ? mName.substring(idx) : mName;}
genCode
public void zookeeper_f635_0(String language, File outputDirectory) throws IOException
{    if ("c++".equals(language)) {        CppGenerator gen = new CppGenerator(mName, mInclFiles, mRecords, outputDirectory);        gen.genCode();    } else if ("java".equals(language)) {        JavaGenerator gen = new JavaGenerator(mName, mInclFiles, mRecords, outputDirectory);        gen.genCode();    } else if ("c".equals(language)) {        CGenerator gen = new CGenerator(mName, mInclFiles, mRecords, outputDirectory);        gen.genCode();    } else if ("csharp".equals(language)) {        CSharpGenerator gen = new CSharpGenerator(mName, mInclFiles, mRecords, outputDirectory);        gen.genCode();    } else {        throw new IOException("Cannnot recognize language:" + language);    }}
getSignature
public String zookeeper_f636_0()
{    return "f";}
genJavaHashCode
public String zookeeper_f637_0(String fname)
{    return "    ret = Float.floatToIntBits(" + fname + ");\n";}
getSignature
public String zookeeper_f638_0()
{    return "i";}
getSignature
public String zookeeper_f639_0()
{    return "l";}
genJavaHashCode
public String zookeeper_f640_0(String fname)
{    return "    ret = (int) (" + fname + "^(" + fname + ">>>32));\n";}
getLevel
private static String zookeeper_f641_0()
{    return Integer.toString(level);}
incrLevel
private static void zookeeper_f642_0()
{    level++;}
decrLevel
private static void zookeeper_f643_0()
{    level--;}
getId
private static String zookeeper_f644_0(String id)
{    return id + getLevel();}
getSignature
public String zookeeper_f645_0()
{    return "{" + mKey.getSignature() + mValue.getSignature() + "}";}
genJavaCompareTo
public String zookeeper_f646_0(String fname)
{    return "    throw new UnsupportedOperationException(\"comparing " + fname + " is unimplemented\");\n";}
genJavaReadWrapper
public String zookeeper_f647_0(String fname, String tag, boolean decl)
{    StringBuilder ret = new StringBuilder("");    if (decl) {        ret.append("    java.util.TreeMap " + fname + ";\n");    }    ret.append("    {\n");    incrLevel();    ret.append("      org.apache.jute.Index " + getId("midx") + " = a_.startMap(\"" + tag + "\");\n");    ret.append("      " + fname + "=new java.util.TreeMap();\n");    ret.append("      for (; !" + getId("midx") + ".done(); " + getId("midx") + ".incr()) {\n");    ret.append(mKey.genJavaReadWrapper(getId("k"), getId("k"), true));    ret.append(mValue.genJavaReadWrapper(getId("v"), getId("v"), true));    ret.append("        " + fname + ".put(" + getId("k") + "," + getId("v") + ");\n");    ret.append("      }\n");    ret.append("    a_.endMap(\"" + tag + "\");\n");    decrLevel();    ret.append("    }\n");    return ret.toString();}
genJavaReadMethod
public String zookeeper_f648_0(String fname, String tag)
{    return genJavaReadWrapper(fname, tag, false);}
genJavaWriteWrapper
public String zookeeper_f649_0(String fname, String tag)
{    StringBuilder ret = new StringBuilder("    {\n");    incrLevel();    ret.append("      a_.startMap(" + fname + ",\"" + tag + "\");\n");    ret.append("      java.util.Set " + getId("es") + " = " + fname + ".entrySet();\n");    ret.append("      for(java.util.Iterator " + getId("midx") + " = " + getId("es") + ".iterator(); " + getId("midx") + ".hasNext(); ) {\n");    ret.append("        java.util.Map.Entry " + getId("me") + " = (java.util.Map.Entry) " + getId("midx") + ".next();\n");    ret.append("        " + mKey.getJavaWrapperType() + " " + getId("k") + " = (" + mKey.getJavaWrapperType() + ") " + getId("me") + ".getKey();\n");    ret.append("        " + mValue.getJavaWrapperType() + " " + getId("v") + " = (" + mValue.getJavaWrapperType() + ") " + getId("me") + ".getValue();\n");    ret.append(mKey.genJavaWriteWrapper(getId("k"), getId("k")));    ret.append(mValue.genJavaWriteWrapper(getId("v"), getId("v")));    ret.append("      }\n");    ret.append("      a_.endMap(" + fname + ",\"" + tag + "\");\n");    ret.append("    }\n");    decrLevel();    return ret.toString();}
genJavaWriteMethod
public String zookeeper_f650_0(String fname, String tag)
{    return genJavaWriteWrapper(fname, tag);}
genCsharpWriteWrapper
public String zookeeper_f651_0(String fname, int tag)
{    StringBuilder ret = new StringBuilder("    {\n");    incrLevel();    ret.append("      a_.StartMap(" + fname + ",\"" + tag + "\");\n");    ret.append("      java.util.Set " + getId("es") + " = " + fname + ".entrySet();\n");    ret.append("      for(java.util.Iterator " + getId("midx") + " = " + getId("es") + ".iterator(); " + getId("midx") + ".hasNext(); ) {\n");    ret.append("        java.util.Map.Entry " + getId("me") + " = (java.util.Map.Entry) " + getId("midx") + ".next();\n");    ret.append("        " + mKey.getCsharpWrapperType() + " " + getId("k") + " = (" + mKey.getCsharpWrapperType() + ") " + getId("me") + ".getKey();\n");    ret.append("        " + mValue.getCsharpWrapperType() + " " + getId("v") + " = (" + mValue.getCsharpWrapperType() + ") " + getId("me") + ".getValue();\n");    ret.append(mKey.genCsharpWriteWrapper(getId("k"), getId("k")));    ret.append(mValue.genCsharpWriteWrapper(getId("v"), getId("v")));    ret.append("      }\n");    ret.append("      a_.EndMap(" + fname + ",\"" + tag + "\");\n");    ret.append("    }\n");    decrLevel();    return ret.toString();}
genCsharpWriteMethod
 String zookeeper_f652_0(String fname, int tag)
{    return genCsharpWriteWrapper(fname, tag);}
genCsharpReadWrapper
public String zookeeper_f653_0(String fname, int tag, boolean decl)
{    StringBuilder ret = new StringBuilder("");    if (decl) {        ret.append("    System.Collections.SortedDictionary<string,string> " + capitalize(fname) + ";\n");    }    ret.append("    {\n");    incrLevel();    ret.append("      Org.Apache.Jute.IIndex " + getId("midx") + " = a_.StartMap(\"" + tag + "\");\n");    ret.append("      " + fname + "= new System.Collections.SortedDictionary<string,string>();\n");    ret.append("      for (; !" + getId("midx") + ".done(); " + getId("midx") + ".incr()) {\n");    ret.append(mKey.genCsharpReadWrapper(getId("k"), getId("k"), true));    ret.append(mValue.genCsharpReadWrapper(getId("v"), getId("v"), true));    ret.append("        " + fname + ".Add(" + getId("k") + "," + getId("v") + ");\n");    ret.append("      }\n");    ret.append("    a_.EndMap(\"" + tag + "\");\n");    decrLevel();    ret.append("    }\n");    return ret.toString();}
genCsharpReadMethod
 String zookeeper_f654_0(String fname, int tag)
{    return genCsharpReadWrapper(fname, tag, false);}
getName
public String zookeeper_f655_0()
{    return mName;}
getCsharpName
public String zookeeper_f656_0()
{    return "Id".equals(mName) ? "ZKId" : mName;}
getJavaFQName
public String zookeeper_f657_0()
{    return mFQName;}
getCppFQName
public String zookeeper_f658_0()
{    return mFQName.replaceAll("\\.", "::");}
getJavaPackage
public String zookeeper_f659_0()
{    return mModule;}
getCppNameSpace
public String zookeeper_f660_0()
{    return mModule.replaceAll("\\.", "::");}
getCsharpNameSpace
public String zookeeper_f661_0()
{    String[] parts = mModule.split("\\.");    StringBuffer namespace = new StringBuffer();    for (int i = 0; i < parts.length; i++) {        String capitalized = parts[i].substring(0, 1).toUpperCase() + parts[i].substring(1).toLowerCase();        namespace.append(capitalized);        if (i != parts.length - 1) {            namespace.append(".");        }    }    return namespace.toString();}
getFields
public List<JField> zookeeper_f662_0()
{    return mFields;}
getSignature
public String zookeeper_f663_0()
{    StringBuilder sb = new StringBuilder();    sb.append("L").append(mName).append("(");    for (Iterator<JField> i = mFields.iterator(); i.hasNext(); ) {        String s = i.next().getSignature();        sb.append(s);    }    sb.append(")");    return sb.toString();}
genCppDecl
public String zookeeper_f664_0(String fname)
{    return "  " + getCppNameSpace() + "::" + mName + " m" + fname + ";\n";}
genJavaReadMethod
public String zookeeper_f665_0(String fname, String tag)
{    return genJavaReadWrapper(fname, tag, false);}
genJavaReadWrapper
public String zookeeper_f666_0(String fname, String tag, boolean decl)
{    StringBuilder ret = new StringBuilder("");    if (decl) {        ret.append("    " + getJavaFQName() + " " + fname + ";\n");    }    ret.append("    " + fname + "= new " + getJavaFQName() + "();\n");    ret.append("    a_.readRecord(" + fname + ",\"" + tag + "\");\n");    return ret.toString();}
genJavaWriteWrapper
public String zookeeper_f667_0(String fname, String tag)
{    return "    a_.writeRecord(" + fname + ",\"" + tag + "\");\n";}
genCsharpReadMethod
 String zookeeper_f668_0(String fname, String tag)
{        return genCsharpReadWrapper(capitalize(fname), tag, false);}
genCsharpReadWrapper
public String zookeeper_f669_0(String fname, String tag, boolean decl)
{    StringBuilder ret = new StringBuilder("");    if (decl) {        ret.append("    " + getCsharpFQName(mFQName) + " " + fname + ";\n");    }    ret.append("    " + fname + "= new " + getCsharpFQName(mFQName) + "();\n");    ret.append("    a_.ReadRecord(" + fname + ",\"" + tag + "\");\n");    return ret.toString();}
genCsharpWriteWrapper
public String zookeeper_f670_0(String fname, String tag)
{    return "    a_.WriteRecord(" + fname + ",\"" + tag + "\");\n";}
genCCode
public void zookeeper_f671_0(FileWriter h, FileWriter c) throws IOException
{    for (JField f : mFields) {        if (f.getType() instanceof JVector) {            JVector jv = (JVector) f.getType();            JType jvType = jv.getElementType();            String structName = JVector.extractVectorName(jvType);            if (vectorStructs.get(structName) == null) {                vectorStructs.put(structName, structName);                h.write("struct " + structName + " {\n    int32_t count;\n" + jv.getElementType().genCDecl("*data") + "\n};\n");                h.write("int serialize_" + structName + "(struct oarchive *out, const char *tag, struct " + structName + " *v);\n");                h.write("int deserialize_" + structName + "(struct iarchive *in, const char *tag, struct " + structName + " *v);\n");                h.write("int allocate_" + structName + "(struct " + structName + " *v, int32_t len);\n");                h.write("int deallocate_" + structName + "(struct " + structName + " *v);\n");                c.write("int allocate_" + structName + "(struct " + structName + " *v, int32_t len) {\n");                c.write("    if (!len) {\n");                c.write("        v->count = 0;\n");                c.write("        v->data = 0;\n");                c.write("    } else {\n");                c.write("        v->count = len;\n");                c.write("        v->data = calloc(sizeof(*v->data), len);\n");                c.write("    }\n");                c.write("    return 0;\n");                c.write("}\n");                c.write("int deallocate_" + structName + "(struct " + structName + " *v) {\n");                c.write("    if (v->data) {\n");                c.write("        int32_t i;\n");                c.write("        for(i=0;i<v->count; i++) {\n");                c.write("            deallocate_" + JRecord.extractMethodSuffix(jvType) + "(&v->data[i]);\n");                c.write("        }\n");                c.write("        free(v->data);\n");                c.write("        v->data = 0;\n");                c.write("    }\n");                c.write("    return 0;\n");                c.write("}\n");                c.write("int serialize_" + structName + "(struct oarchive *out, const char *tag, struct " + structName + " *v)\n");                c.write("{\n");                c.write("    int32_t count = v->count;\n");                c.write("    int rc = 0;\n");                c.write("    int32_t i;\n");                c.write("    rc = out->start_vector(out, tag, &count);\n");                c.write("    for(i=0;i<v->count;i++) {\n");                genSerialize(c, jvType, "data", "data[i]");                c.write("    }\n");                c.write("    rc = rc ? rc : out->end_vector(out, tag);\n");                c.write("    return rc;\n");                c.write("}\n");                c.write("int deserialize_" + structName + "(struct iarchive *in, const char *tag, struct " + structName + " *v)\n");                c.write("{\n");                c.write("    int rc = 0;\n");                c.write("    int32_t i;\n");                c.write("    rc = in->start_vector(in, tag, &v->count);\n");                c.write("    v->data = calloc(v->count, sizeof(*v->data));\n");                c.write("    for(i=0;i<v->count;i++) {\n");                genDeserialize(c, jvType, "value", "data[i]");                c.write("    }\n");                c.write("    rc = in->end_vector(in, tag);\n");                c.write("    return rc;\n");                c.write("}\n");            }        }    }    String recName = getName();    h.write("struct " + recName + " {\n");    for (JField f : mFields) {        h.write(f.genCDecl());    }    h.write("};\n");    h.write("int serialize_" + recName + "(struct oarchive *out, const char *tag, struct " + recName + " *v);\n");    h.write("int deserialize_" + recName + "(struct iarchive *in, const char *tag, struct " + recName + "*v);\n");    h.write("void deallocate_" + recName + "(struct " + recName + "*);\n");    c.write("int serialize_" + recName + "(struct oarchive *out, const char *tag, struct " + recName + " *v)");    c.write("{\n");    c.write("    int rc;\n");    c.write("    rc = out->start_record(out, tag);\n");    for (JField f : mFields) {        genSerialize(c, f.getType(), f.getTag(), f.getName());    }    c.write("    rc = rc ? rc : out->end_record(out, tag);\n");    c.write("    return rc;\n");    c.write("}\n");    c.write("int deserialize_" + recName + "(struct iarchive *in, const char *tag, struct " + recName + "*v)");    c.write("{\n");    c.write("    int rc;\n");    c.write("    rc = in->start_record(in, tag);\n");    for (JField f : mFields) {        genDeserialize(c, f.getType(), f.getTag(), f.getName());    }    c.write("    rc = rc ? rc : in->end_record(in, tag);\n");    c.write("    return rc;\n");    c.write("}\n");    c.write("void deallocate_" + recName + "(struct " + recName + "*v)");    c.write("{\n");    for (JField f : mFields) {        if (f.getType() instanceof JRecord) {            c.write("    deallocate_" + extractStructName(f.getType()) + "(&v->" + f.getName() + ");\n");        } else if (f.getType() instanceof JVector) {            JVector vt = (JVector) f.getType();            c.write("    deallocate_" + JVector.extractVectorName(vt.getElementType()) + "(&v->" + f.getName() + ");\n");        } else if (f.getType() instanceof JCompType) {            c.write("    deallocate_" + extractMethodSuffix(f.getType()) + "(&v->" + f.getName() + ");\n");        }    }    c.write("}\n");}
genSerialize
private void zookeeper_f672_0(FileWriter c, JType type, String tag, String name) throws IOException
{    if (type instanceof JRecord) {        c.write("    rc = rc ? rc : serialize_" + extractStructName(type) + "(out, \"" + tag + "\", &v->" + name + ");\n");    } else if (type instanceof JVector) {        c.write("    rc = rc ? rc : serialize_" + JVector.extractVectorName(((JVector) type).getElementType()) + "(out, \"" + tag + "\", &v->" + name + ");\n");    } else {        c.write("    rc = rc ? rc : out->serialize_" + extractMethodSuffix(type) + "(out, \"" + tag + "\", &v->" + name + ");\n");    }}
genDeserialize
private void zookeeper_f673_0(FileWriter c, JType type, String tag, String name) throws IOException
{    if (type instanceof JRecord) {        c.write("    rc = rc ? rc : deserialize_" + extractStructName(type) + "(in, \"" + tag + "\", &v->" + name + ");\n");    } else if (type instanceof JVector) {        c.write("    rc = rc ? rc : deserialize_" + JVector.extractVectorName(((JVector) type).getElementType()) + "(in, \"" + tag + "\", &v->" + name + ");\n");    } else {        c.write("    rc = rc ? rc : in->deserialize_" + extractMethodSuffix(type) + "(in, \"" + tag + "\", &v->" + name + ");\n");    }}
extractMethodSuffix
 static String zookeeper_f674_0(JType t)
{    if (t instanceof JRecord) {        return extractStructName(t);    }    return t.getMethodSuffix();}
extractStructName
private static String zookeeper_f675_0(JType t)
{    String type = t.getCType();    if (!type.startsWith("struct ")) {        return type;    }    return type.substring("struct ".length());}
getCsharpFQName
public static String zookeeper_f676_0(String name)
{    String[] packages = name.split("\\.");    StringBuffer fQName = new StringBuffer();    for (int i = 0; i < packages.length; i++) {        String pack = packages[i];        pack = capitalize(pack);        pack = "Id".equals(pack) ? "ZKId" : pack;        fQName.append(capitalize(pack));        if (i != packages.length - 1) {            fQName.append(".");        }    }    return fQName.toString();}
getSignature
public String zookeeper_f677_0()
{    return "s";}
genJavaReadWrapper
public String zookeeper_f678_0(String fname, String tag, boolean decl)
{    String ret = "";    if (decl) {        ret = "    String " + fname + ";\n";    }    return ret + "        " + fname + "=a_.readString(\"" + tag + "\");\n";}
genJavaWriteWrapper
public String zookeeper_f679_0(String fname, String tag)
{    return "        a_.writeString(" + fname + ",\"" + tag + "\");\n";}
genCppDecl
 String zookeeper_f680_0(String fname)
{    return "  " + mCppName + " m" + fname + ";\n";}
genCDecl
 String zookeeper_f681_0(String name)
{    return "    " + mCName + " " + name + ";\n";}
genCsharpDecl
public String zookeeper_f682_0(String name)
{    return "  private " + mCsharpName + " " + name + ";\n";}
genJavaDecl
 String zookeeper_f683_0(String fname)
{    return "  private " + mJavaName + " " + fname + ";\n";}
genJavaConstructorParam
 String zookeeper_f684_0(String fname)
{    return "        " + mJavaName + " " + fname;}
genCppGetSet
 String zookeeper_f685_0(String fname, int fIdx)
{    String getFunc = "  virtual " + mCppName + " get" + fname + "() const {\n";    getFunc += "    return m" + fname + ";\n";    getFunc += "  }\n";    String setFunc = "  virtual void set" + fname + "(" + mCppName + " m_) {\n";    setFunc += "    m" + fname + "=m_; bs_.set(" + fIdx + ");\n";    setFunc += "  }\n";    return getFunc + setFunc;}
genCsharpGetSet
 String zookeeper_f686_0(String fname, int fIdx)
{    String getFunc = "  public " + getCsharpType() + " " + capitalize(fname) + " { get; set; } ";    return getFunc;}
capitalize
 static String zookeeper_f687_0(String s)
{    return s.substring(0, 1).toUpperCase() + s.substring(1);}
genJavaGetSet
 String zookeeper_f688_0(String fname, int fIdx)
{    String getFunc = "  public " + mJavaName + " get" + capitalize(fname) + "() {\n";    getFunc += "    return " + fname + ";\n";    getFunc += "  }\n";    String setFunc = "  public void set" + capitalize(fname) + "(" + mJavaName + " m_) {\n";    setFunc += "    " + fname + "=m_;\n";    setFunc += "  }\n";    return getFunc + setFunc;}
getCType
 String zookeeper_f689_0()
{    return mCName;}
getCppType
 String zookeeper_f690_0()
{    return mCppName;}
getCsharpType
 String zookeeper_f691_0()
{    return mCsharpName;}
getJavaType
 String zookeeper_f692_0()
{    return mJavaName;}
getJavaWrapperType
 String zookeeper_f693_0()
{    return mWrapper;}
getCsharpWrapperType
 String zookeeper_f694_0()
{    return mSharpWrapper;}
getMethodSuffix
 String zookeeper_f695_0()
{    return mMethodSuffix;}
genJavaWriteMethod
 String zookeeper_f696_0(String fname, String tag)
{    return "    a_.write" + mMethodSuffix + "(" + fname + ",\"" + tag + "\");\n";}
genJavaReadMethod
 String zookeeper_f697_0(String fname, String tag)
{    return "    " + fname + "=a_.read" + mMethodSuffix + "(\"" + tag + "\");\n";}
genJavaReadWrapper
 String zookeeper_f698_0(String fname, String tag, boolean decl)
{    String ret = "";    if (decl) {        ret = "    " + mWrapper + " " + fname + ";\n";    }    return ret + "    " + fname + "=new " + mWrapper + "(a_.read" + mMethodSuffix + "(\"" + tag + "\"));\n";}
genJavaWriteWrapper
 String zookeeper_f699_0(String fname, String tag)
{    return "        a_.write" + mMethodSuffix + "(" + fname + "." + mUnwrapMethod + "(),\"" + tag + "\");\n";}
genJavaCompareTo
 String zookeeper_f700_0(String fname)
{    return "    ret = (" + fname + " == peer." + fname + ")? 0 :((" + fname + "<peer." + fname + ")?-1:1);\n";}
genJavaEquals
 String zookeeper_f701_0(String fname, String peer)
{    return "    ret = (" + fname + "==" + peer + ");\n";}
genJavaHashCode
 String zookeeper_f702_0(String fname)
{    return "    ret = (int)" + fname + ";\n";}
genJavaConstructorSet
 String zookeeper_f703_0(String fname, String name)
{    return "    this." + fname + "=" + name + ";\n";}
genCsharpWriteMethod
 String zookeeper_f704_0(String fname, String tag)
{    return "    a_.Write" + mMethodSuffix + "(" + capitalize(fname) + ",\"" + tag + "\");\n";}
genCsharpReadMethod
 String zookeeper_f705_0(String fname, String tag)
{    return "    " + capitalize(fname) + "=a_.Read" + mMethodSuffix + "(\"" + tag + "\");\n";}
genCsharpReadWrapper
 String zookeeper_f706_0(String fname, String tag, boolean decl)
{    String ret = "";    if (decl) {        ret = "    " + mWrapper + " " + fname + ";\n";    }    return ret + "    " + fname + "=a_.Read" + mMethodSuffix + "(\"" + tag + "\");\n";}
genCsharpWriteWrapper
 String zookeeper_f707_0(String fname, String tag)
{    return (mUnwrapMethod == null) ? "        a_.Write" + mMethodSuffix + "(" + fname + "," + tag + ");\n" : "        a_.Write" + mMethodSuffix + "(" + fname + "." + mUnwrapMethod + "(),\"" + tag + "\");\n";}
genCsharpCompareTo
 String zookeeper_f708_0(String name)
{    return "    ret = (" + capitalize(name) + " == peer." + capitalize(name) + ")? 0 :((" + capitalize(name) + "<peer." + capitalize(name) + ")?-1:1);\n";}
genCsharpEquals
 String zookeeper_f709_0(String name, String peer)
{    String[] peerSplit = peer.split("\\.");    return "    ret = (" + capitalize(name) + "==" + peerSplit[0] + "." + capitalize(peerSplit[1]) + ");\n";}
genCsharpHashCode
 String zookeeper_f710_0(String fname)
{    return "    ret = (int)" + capitalize(fname) + ";\n";}
genCsharpConstructorSet
 String zookeeper_f711_0(String mName, String fname)
{    return capitalize(fname) + "=" + mName + ";\n";}
genCsharpConstructorParam
public String zookeeper_f712_0(String fname)
{    return "  " + mCsharpName + " " + fname + "\n";}
getId
private static String zookeeper_f713_0(String id)
{    return id + getLevel();}
getLevel
private static String zookeeper_f714_0()
{    return Integer.toString(level);}
incrLevel
private static void zookeeper_f715_0()
{    level++;}
decrLevel
private static void zookeeper_f716_0()
{    level--;}
getSignature
public String zookeeper_f717_0()
{    return "[" + mElement.getSignature() + "]";}
genJavaCompareTo
public String zookeeper_f718_0(String fname)
{    return "    throw new UnsupportedOperationException(\"comparing " + fname + " is unimplemented\");\n";}
genJavaReadWrapper
public String zookeeper_f719_0(String fname, String tag, boolean decl)
{    StringBuilder ret = new StringBuilder("");    if (decl) {        ret.append("      java.util.List " + fname + ";\n");    }    ret.append("    {\n");    incrLevel();    ret.append("      Index " + getId("vidx") + " = a_.startVector(\"" + tag + "\");\n");    ret.append("      if (" + getId("vidx") + "!= null) {");    ret.append("          " + fname + "=new java.util.ArrayList<" + mElement.getJavaType() + ">();\n");    ret.append("          for (; !" + getId("vidx") + ".done(); " + getId("vidx") + ".incr()) {\n");    ret.append(mElement.genJavaReadWrapper(getId("e"), getId("e"), true));    ret.append("            " + fname + ".add(" + getId("e") + ");\n");    ret.append("          }\n");    ret.append("      }\n");    ret.append("    a_.endVector(\"" + tag + "\");\n");    decrLevel();    ret.append("    }\n");    return ret.toString();}
genJavaReadMethod
public String zookeeper_f720_0(String fname, String tag)
{    return genJavaReadWrapper(fname, tag, false);}
genJavaWriteWrapper
public String zookeeper_f721_0(String fname, String tag)
{    StringBuilder ret = new StringBuilder("    {\n");    incrLevel();    ret.append("      a_.startVector(" + fname + ",\"" + tag + "\");\n");    ret.append("      if (" + fname + "!= null) {");    ret.append("          int " + getId("len") + " = " + fname + ".size();\n");    ret.append("          for(int " + getId("vidx") + " = 0; " + getId("vidx") + "<" + getId("len") + "; " + getId("vidx") + "++) {\n");    ret.append("            " + mElement.getJavaWrapperType() + " " + getId("e") + " = (" + mElement.getJavaWrapperType() + ") " + fname + ".get(" + getId("vidx") + ");\n");    ret.append(mElement.genJavaWriteWrapper(getId("e"), getId("e")));    ret.append("          }\n");    ret.append("      }\n");    ret.append("      a_.endVector(" + fname + ",\"" + tag + "\");\n");    ret.append("    }\n");    decrLevel();    return ret.toString();}
genJavaWriteMethod
public String zookeeper_f722_0(String fname, String tag)
{    return genJavaWriteWrapper(fname, tag);}
getElementType
public JType zookeeper_f723_0()
{    return mElement;}
genCsharpWriteWrapper
public String zookeeper_f724_0(String fname, String tag)
{    StringBuilder ret = new StringBuilder("    {\n");    incrLevel();    ret.append("      a_.StartVector(" + capitalize(fname) + ",\"" + tag + "\");\n");    ret.append("      if (" + capitalize(fname) + "!= null) {");    ret.append("          int " + getId("len") + " = " + capitalize(fname) + ".Count;\n");    ret.append("          for(int " + getId("vidx") + " = 0; " + getId("vidx") + "<" + getId("len") + "; " + getId("vidx") + "++) {\n");    ret.append("            " + mElement.getCsharpWrapperType() + " " + getId("e") + " = (" + mElement.getCsharpWrapperType() + ") " + capitalize(fname) + "[" + getId("vidx") + "];\n");    ret.append(mElement.genCsharpWriteWrapper(getId("e"), getId("e")));    ret.append("          }\n");    ret.append("      }\n");    ret.append("      a_.EndVector(" + capitalize(fname) + ",\"" + tag + "\");\n");    ret.append("    }\n");    decrLevel();    return ret.toString();}
genCsharpWriteMethod
 String zookeeper_f725_0(String fname, String tag)
{    return genCsharpWriteWrapper(fname, tag);}
genCsharpReadWrapper
public String zookeeper_f726_0(String fname, String tag, boolean decl)
{    StringBuilder ret = new StringBuilder();    if (decl) {        ret.append("      System.Collections.Generic.List<" + mElement.getCsharpType() + "> " + capitalize(fname) + ";\n");    }    ret.append("    {\n");    incrLevel();    ret.append("      IIndex " + getId("vidx") + " = a_.StartVector(\"" + tag + "\");\n");    ret.append("      if (" + getId("vidx") + "!= null) {");    ret.append("          " + capitalize(fname) + "=new System.Collections.Generic.List<" + mElement.getCsharpType() + ">();\n");    ret.append("          for (; !" + getId("vidx") + ".Done(); " + getId("vidx") + ".Incr()) {\n");    ret.append(mElement.genCsharpReadWrapper(getId("e"), getId("e"), true));    ret.append("            " + capitalize(fname) + ".Add(" + getId("e") + ");\n");    ret.append("          }\n");    ret.append("      }\n");    ret.append("    a_.EndVector(\"" + tag + "\");\n");    decrLevel();    ret.append("    }\n");    return ret.toString();}
genCsharpReadMethod
 String zookeeper_f727_0(String fname, String tag)
{    return genCsharpReadWrapper(fname, tag, false);}
extractVectorName
 static String zookeeper_f728_0(JType jvType)
{    return JRecord.extractMethodSuffix(jvType) + "_vector";}
createArchive
private static InputArchive zookeeper_f729_0(InputStream in, String format)
{    Method factory = archiveFactory.get(format);    if (factory != null) {        Object[] params = { in };        try {            return (InputArchive) factory.invoke(null, params);        } catch (IllegalArgumentException | InvocationTargetException | IllegalAccessException ex) {            ex.printStackTrace();        }    }    return null;}
read
public void zookeeper_f730_0(Record r) throws IOException
{    r.deserialize(archive, "");}
constructFactory
 static HashMap<String, Method> zookeeper_f731_0()
{    HashMap<String, Method> factory = new HashMap<String, Method>();    try {        factory.put("binary", BinaryOutputArchive.class.getDeclaredMethod("getArchive", OutputStream.class));    } catch (SecurityException | NoSuchMethodException ex) {        ex.printStackTrace();    }    return factory;}
createArchive
private static OutputArchive zookeeper_f732_0(OutputStream out, String format)
{    Method factory = archiveFactory.get(format);    if (factory != null) {        Object[] params = { out };        try {            return (OutputArchive) factory.invoke(null, params);        } catch (IllegalArgumentException | InvocationTargetException | IllegalAccessException ex) {            ex.printStackTrace();        }    }    return null;}
write
public void zookeeper_f733_0(Record r) throws IOException
{    r.serialize(archive, "");}
throwExceptionOnError
private void zookeeper_f734_0(String tag) throws IOException
{    if (stream.checkError()) {        throw new IOException("Error serializing " + tag);    }}
printCommaUnlessFirst
private void zookeeper_f735_0()
{    if (!isFirst) {        stream.print(",");    }    isFirst = false;}
writeByte
public void zookeeper_f736_0(byte b, String tag) throws IOException
{    writeLong((long) b, tag);}
writeBool
public void zookeeper_f737_0(boolean b, String tag) throws IOException
{    printCommaUnlessFirst();    String val = b ? "T" : "F";    stream.print(val);    throwExceptionOnError(tag);}
writeInt
public void zookeeper_f738_0(int i, String tag) throws IOException
{    writeLong((long) i, tag);}
writeLong
public void zookeeper_f739_0(long l, String tag) throws IOException
{    printCommaUnlessFirst();    stream.print(l);    throwExceptionOnError(tag);}
writeFloat
public void zookeeper_f740_0(float f, String tag) throws IOException
{    writeDouble((double) f, tag);}
writeDouble
public void zookeeper_f741_0(double d, String tag) throws IOException
{    printCommaUnlessFirst();    stream.print(d);    throwExceptionOnError(tag);}
writeString
public void zookeeper_f742_0(String s, String tag) throws IOException
{    printCommaUnlessFirst();    stream.print(escapeString(s));    throwExceptionOnError(tag);}
writeBuffer
public void zookeeper_f743_0(byte[] buf, String tag) throws IOException
{    printCommaUnlessFirst();    stream.print(escapeBuffer(buf));    throwExceptionOnError(tag);}
writeRecord
public void zookeeper_f744_0(Record r, String tag) throws IOException
{    if (r == null) {        return;    }    r.serialize(this, tag);}
startRecord
public void zookeeper_f745_0(Record r, String tag) throws IOException
{    if (tag != null && !"".equals(tag)) {        printCommaUnlessFirst();        stream.print("s{");        isFirst = true;    }}
endRecord
public void zookeeper_f746_0(Record r, String tag) throws IOException
{    if (tag == null || "".equals(tag)) {        stream.print("\n");        isFirst = true;    } else {        stream.print("}");        isFirst = false;    }}
startVector
public void zookeeper_f747_0(List<?> v, String tag) throws IOException
{    printCommaUnlessFirst();    stream.print("v{");    isFirst = true;}
endVector
public void zookeeper_f748_0(List<?> v, String tag) throws IOException
{    stream.print("}");    isFirst = false;}
startMap
public void zookeeper_f749_0(TreeMap<?, ?> v, String tag) throws IOException
{    printCommaUnlessFirst();    stream.print("m{");    isFirst = true;}
endMap
public void zookeeper_f750_0(TreeMap<?, ?> v, String tag) throws IOException
{    stream.print("}");    isFirst = false;}
escapeString
private static String zookeeper_f751_0(String s)
{    if (s == null) {        return "";    }    StringBuilder sb = new StringBuilder(s.length() + 1);    sb.append('\'');    int len = s.length();    for (int i = 0; i < len; i++) {        char c = s.charAt(i);        switch(c) {            case '\0':                sb.append("%00");                break;            case '\n':                sb.append("%0A");                break;            case '\r':                sb.append("%0D");                break;            case ',':                sb.append("%2C");                break;            case '}':                sb.append("%7D");                break;            case '%':                sb.append("%25");                break;            default:                sb.append(c);        }    }    return sb.toString();}
escapeBuffer
private static String zookeeper_f752_0(byte[] barr)
{    if (barr == null || barr.length == 0) {        return "";    }    StringBuilder sb = new StringBuilder(barr.length + 1);    sb.append('#');    for (byte b : barr) {        sb.append(Integer.toHexString(b));    }    return sb.toString();}
bufEquals
public static boolean zookeeper_f753_0(byte[] onearray, byte[] twoarray)
{    if (onearray == twoarray) {        return true;    }    boolean ret = (onearray.length == twoarray.length);    if (!ret) {        return ret;    }    for (int idx = 0; idx < onearray.length; idx++) {        if (onearray[idx] != twoarray[idx]) {            return false;        }    }    return true;}
compareBytes
public static int zookeeper_f754_0(byte[] b1, int off1, int len1, byte[] b2, int off2, int len2)
{    int i;    for (i = 0; i < len1 && i < len2; i++) {        if (b1[off1 + i] != b2[off2 + i]) {            return b1[off1 + i] < b2[off2 + i] ? -1 : 1;        }    }    if (len1 != len2) {        return len1 < len2 ? -1 : 1;    }    return 0;}
testReadStringCheckLength
public void zookeeper_f755_0()
{    byte[] buf = new byte[] { Byte.MAX_VALUE, Byte.MAX_VALUE, Byte.MAX_VALUE, Byte.MAX_VALUE };    ByteArrayInputStream is = new ByteArrayInputStream(buf);    BinaryInputArchive ia = BinaryInputArchive.getArchive(is);    try {        ia.readString("");        fail("Should have thrown an IOException");    } catch (IOException e) {        assertTrue("Not 'Unreasonable length' exception: " + e, e.getMessage().startsWith(BinaryInputArchive.UNREASONBLE_LENGTH));    }}
checkWriterAndReader
private void zookeeper_f756_0(TestWriter writer, TestReader reader)
{    TestCheckWriterReader.checkWriterAndReader(BinaryOutputArchive::getArchive, BinaryInputArchive::getArchive, writer, reader);}
testInt
public void zookeeper_f757_0()
{    final int expected = 4;    final String tag = "tag1";    checkWriterAndReader((oa) -> oa.writeInt(expected, tag), (ia) -> {        int actual = ia.readInt(tag);        assertEquals(expected, actual);    });}
testBool
public void zookeeper_f758_0()
{    final boolean expected = false;    final String tag = "tag1";    checkWriterAndReader((oa) -> oa.writeBool(expected, tag), (ia) -> {        boolean actual = ia.readBool(tag);        assertEquals(expected, actual);    });}
testString
public void zookeeper_f759_0()
{    final String expected = "hello";    final String tag = "tag1";    checkWriterAndReader((oa) -> oa.writeString(expected, tag), (ia) -> {        String actual = ia.readString(tag);        assertEquals(expected, actual);    });}
testFloat
public void zookeeper_f760_0()
{    final float expected = 3.14159f;    final String tag = "tag1";    final float delta = 1e-10f;    checkWriterAndReader((oa) -> oa.writeFloat(expected, tag), (ia) -> {        float actual = ia.readFloat(tag);        assertEquals(expected, actual, delta);    });}
testDouble
public void zookeeper_f761_0()
{    final double expected = 3.14159f;    final String tag = "tag1";    final float delta = 1e-20f;    checkWriterAndReader((oa) -> oa.writeDouble(expected, tag), (ia) -> {        double actual = ia.readDouble(tag);        assertEquals(expected, actual, delta);    });}
testBuffer
public void zookeeper_f762_0()
{    final byte[] expected = "hello-world".getBytes(StandardCharsets.UTF_8);    final String tag = "tag1";    checkWriterAndReader((oa) -> oa.writeBuffer(expected, tag), (ia) -> {        byte[] actual = ia.readBuffer(tag);        assertArrayEquals(expected, actual);    });}
testReadStringForRecordsHavingLengthMoreThanMaxAllowedSize
public void zookeeper_f763_0()
{    int maxBufferSize = 2000;    int extraMaxBufferSize = 1025;        int recordSize = maxBufferSize + extraMaxBufferSize + 100;    BinaryInputArchive ia = getBinaryInputArchive(recordSize, maxBufferSize, extraMaxBufferSize);    try {        ia.readString("");        fail("Should have thrown an IOException");    } catch (IOException e) {        assertTrue("Not 'Unreasonable length' exception: " + e, e.getMessage().startsWith(BinaryInputArchive.UNREASONBLE_LENGTH));    }}
testReadStringForRecordsHavingLengthLessThanMaxAllowedSize
public void zookeeper_f764_0() throws IOException
{    int maxBufferSize = 2000;    int extraMaxBufferSize = 1025;    int recordSize = maxBufferSize + extraMaxBufferSize - 100;        BinaryInputArchive ia = getBinaryInputArchive(recordSize, maxBufferSize, extraMaxBufferSize);    String s = ia.readString("");    assertNotNull(s);    assertEquals(recordSize, s.getBytes().length);}
getBinaryInputArchive
private BinaryInputArchive zookeeper_f765_0(int recordSize, int maxBufferSize, int extraMaxBufferSize)
{    byte[] data = getData(recordSize);    DataInputStream dis = new DataInputStream(new ByteArrayInputStream(data));    return new BinaryInputArchive(dis, maxBufferSize, extraMaxBufferSize);}
getData
private byte[] zookeeper_f766_0(int recordSize)
{    ByteBuffer buf = ByteBuffer.allocate(recordSize + 4);    buf.putInt(recordSize);    byte[] bytes = new byte[recordSize];    for (int i = 0; i < recordSize; i++) {        bytes[i] = (byte) 'a';    }    buf.put(bytes);    return buf.array();}
checkWriterAndReader
 static void zookeeper_f767_0(TestOutputArchive output, TestInputArchive input, TestWriter writer, TestReader reader)
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    try {        OutputArchive oa = output.getArchive(baos);        writer.write(oa);    } catch (IOException e) {        fail("Should not throw IOException while writing");    }    InputStream is = new ByteArrayInputStream(baos.toByteArray());    try {        InputArchive ia = input.getArchive(is);        reader.read(ia);    } catch (IOException e) {        fail("Should not throw IOException while reading back");    }}
configure
public voidf768_1Properties configuration) throws MetricsProviderLifeCycleException
{        this.port = Integer.parseInt(configuration.getProperty("httpPort", "7000"));    this.exportJvmInfo = Boolean.parseBoolean(configuration.getProperty("exportJvmInfo", "true"));}
start
public voidf769_1) throws MetricsProviderLifeCycleException
{    try {                if (exportJvmInfo) {            DefaultExports.initialize();        }        server = new Server(port);        ServletContextHandler context = new ServletContextHandler();        context.setContextPath("/");        server.setHandler(context);        context.addServlet(new ServletHolder(servlet), "/metrics");        server.start();    } catch (Exception err) {                if (server != null) {            try {                server.stop();            } catch (Exception suppressed) {                err.addSuppressed(suppressed);            } finally {                server = null;            }        }        throw new MetricsProviderLifeCycleException(err);    }}
getServlet
 MetricsServletImpl zookeeper_f770_0()
{    return servlet;}
getRootContext
public MetricsContext zookeeper_f771_0()
{    return rootContext;}
stop
public voidf772_1)
{    if (server != null) {        try {            server.stop();        } catch (Exception err) {                    } finally {            server = null;        }    }}
dump
public void zookeeper_f773_0(BiConsumer<String, Object> sink)
{    sampleGauges();    Enumeration<Collector.MetricFamilySamples> samplesFamilies = collectorRegistry.metricFamilySamples();    while (samplesFamilies.hasMoreElements()) {        Collector.MetricFamilySamples samples = samplesFamilies.nextElement();        samples.samples.forEach(sample -> {            String key = buildKeyForDump(sample);            sink.accept(key, sample.value);        });    }}
buildKeyForDump
private static String zookeeper_f774_0(Collector.MetricFamilySamples.Sample sample)
{    StringBuilder keyBuilder = new StringBuilder();    keyBuilder.append(sample.name);    if (sample.labelNames.size() > 0) {        keyBuilder.append('{');        for (int i = 0; i < sample.labelNames.size(); ++i) {            if (i > 0) {                keyBuilder.append(',');            }            keyBuilder.append(sample.labelNames.get(i));            keyBuilder.append("=\"");            keyBuilder.append(sample.labelValues.get(i));            keyBuilder.append('"');        }        keyBuilder.append('}');    }    return keyBuilder.toString();}
sampleGauges
private void zookeeper_f775_0()
{    rootContext.gauges.values().forEach(PrometheusGaugeWrapper::sample);}
resetAllValues
public void zookeeper_f776_0()
{}
getContext
public MetricsContext zookeeper_f777_0(String name)
{        return this;}
getCounter
public Counter zookeeper_f778_0(String name)
{    return counters.computeIfAbsent(name, PrometheusCounter::new);}
registerGauge
public void zookeeper_f779_0(String name, Gauge gauge)
{    Objects.requireNonNull(name);    gauges.compute(name, (id, prev) -> new PrometheusGaugeWrapper(id, gauge, prev != null ? prev.inner : null));}
unregisterGauge
public void zookeeper_f780_0(String name)
{    PrometheusGaugeWrapper existing = gauges.remove(name);    if (existing != null) {        existing.unregister();    }}
getSummary
public Summary zookeeper_f781_0(String name, DetailLevel detailLevel)
{    if (detailLevel == DetailLevel.BASIC) {        return basicSummaries.computeIfAbsent(name, (n) -> {            if (summaries.containsKey(n)) {                throw new IllegalArgumentException("Already registered a non basic summary as " + n);            }            return new PrometheusSummary(name, detailLevel);        });    } else {        return summaries.computeIfAbsent(name, (n) -> {            if (basicSummaries.containsKey(n)) {                throw new IllegalArgumentException("Already registered a basic summary as " + n);            }            return new PrometheusSummary(name, detailLevel);        });    }}
getSummarySet
public SummarySet zookeeper_f782_0(String name, DetailLevel detailLevel)
{    if (detailLevel == DetailLevel.BASIC) {        return basicSummarySets.computeIfAbsent(name, (n) -> {            if (summarySets.containsKey(n)) {                throw new IllegalArgumentException("Already registered a non basic summary set as " + n);            }            return new PrometheusLabelledSummary(name, detailLevel);        });    } else {        return summarySets.computeIfAbsent(name, (n) -> {            if (basicSummarySets.containsKey(n)) {                throw new IllegalArgumentException("Already registered a basic summary set as " + n);            }            return new PrometheusLabelledSummary(name, detailLevel);        });    }}
add
public voidf783_1long delta)
{    try {        inner.inc(delta);    } catch (IllegalArgumentException err) {            }}
get
public long zookeeper_f784_0()
{        return (long) inner.get();}
sample
private void zookeeper_f785_0()
{    Number value = gauge.get();    this.inner.set(value != null ? value.doubleValue() : 0);}
unregister
private void zookeeper_f786_0()
{    collectorRegistry.unregister(inner);}
add
public voidf787_1long delta)
{    try {        inner.observe(delta);    } catch (IllegalArgumentException err) {            }}
add
public voidf788_1String key, long value)
{    try {        inner.labels(key).observe(value);    } catch (IllegalArgumentException err) {            }}
doGet
protected void zookeeper_f789_0(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException
{            sampleGauges();        super.doGet(req, resp);}
exportInfo
public void zookeeper_f790_0() throws Exception
{    runTest(true);}
doNotExportInfo
public void zookeeper_f791_0() throws Exception
{    runTest(false);}
runTest
private void zookeeper_f792_0(boolean exportJvmInfo) throws Exception
{    CollectorRegistry.defaultRegistry.clear();    PrometheusMetricsProvider provider = new PrometheusMetricsProvider();    try {        Properties configuration = new Properties();                configuration.setProperty("httpPort", "0");        configuration.setProperty("exportJvmInfo", exportJvmInfo + "");        provider.configure(configuration);        provider.start();        boolean[] found = { false };        provider.dump((k, v) -> {            found[0] = found[0] || k.contains("heap");        });        assertEquals(exportJvmInfo, found[0]);    } finally {        provider.stop();    }}
setup
public void zookeeper_f793_0() throws Exception
{    CollectorRegistry.defaultRegistry.clear();    provider = new PrometheusMetricsProvider();    Properties configuration = new Properties();        configuration.setProperty("httpPort", "0");    configuration.setProperty("exportJvmInfo", "false");    provider.configure(configuration);    provider.start();}
tearDown
public void zookeeper_f794_0()
{    if (provider != null) {        provider.stop();    }    CollectorRegistry.defaultRegistry.clear();}
testCounters
public void zookeeper_f795_0() throws Exception
{    Counter counter = provider.getRootContext().getCounter("cc");    counter.add(10);    int[] count = { 0 };    provider.dump((k, v) -> {        assertEquals("cc", k);        assertEquals(10, ((Number) v).intValue());        count[0]++;    });    assertEquals(1, count[0]);    count[0] = 0;        counter.add(-1);    provider.dump((k, v) -> {        assertEquals("cc", k);        assertEquals(10, ((Number) v).intValue());        count[0]++;    });    assertEquals(1, count[0]);        assertSame(counter, provider.getRootContext().getCounter("cc"));    String res = callServlet();    assertThat(res, CoreMatchers.containsString("# TYPE cc counter"));    assertThat(res, CoreMatchers.containsString("cc 10.0"));}
testGauge
public void zookeeper_f796_0() throws Exception
{    int[] values = { 78, -89 };    int[] callCounts = { 0, 0 };    Gauge gauge0 = () -> {        callCounts[0]++;        return values[0];    };    Gauge gauge1 = () -> {        callCounts[1]++;        return values[1];    };    provider.getRootContext().registerGauge("gg", gauge0);    int[] count = { 0 };    provider.dump((k, v) -> {        assertEquals("gg", k);        assertEquals(values[0], ((Number) v).intValue());        count[0]++;    });    assertEquals(1, callCounts[0]);    assertEquals(0, callCounts[1]);    assertEquals(1, count[0]);    count[0] = 0;    String res2 = callServlet();    assertThat(res2, CoreMatchers.containsString("# TYPE gg gauge"));    assertThat(res2, CoreMatchers.containsString("gg 78.0"));    provider.getRootContext().unregisterGauge("gg");    provider.dump((k, v) -> {        count[0]++;    });    assertEquals(2, callCounts[0]);    assertEquals(0, callCounts[1]);    assertEquals(0, count[0]);    String res3 = callServlet();    assertTrue(res3.isEmpty());    provider.getRootContext().registerGauge("gg", gauge1);    provider.dump((k, v) -> {        assertEquals("gg", k);        assertEquals(values[1], ((Number) v).intValue());        count[0]++;    });    assertEquals(2, callCounts[0]);    assertEquals(1, callCounts[1]);    assertEquals(1, count[0]);    count[0] = 0;    String res4 = callServlet();    assertThat(res4, CoreMatchers.containsString("# TYPE gg gauge"));    assertThat(res4, CoreMatchers.containsString("gg -89.0"));    assertEquals(2, callCounts[0]);        assertEquals(2, callCounts[1]);        provider.getRootContext().registerGauge("gg", gauge0);    provider.dump((k, v) -> {        count[0]++;    });    assertEquals(1, count[0]);    assertEquals(3, callCounts[0]);    assertEquals(2, callCounts[1]);}
testBasicSummary
public void zookeeper_f797_0() throws Exception
{    Summary summary = provider.getRootContext().getSummary("cc", MetricsContext.DetailLevel.BASIC);    summary.add(10);    summary.add(10);    int[] count = { 0 };    provider.dump((k, v) -> {        count[0]++;        int value = ((Number) v).intValue();        switch(k) {            case "cc{quantile=\"0.5\"}":                assertEquals(10, value);                break;            case "cc_count":                assertEquals(2, value);                break;            case "cc_sum":                assertEquals(20, value);                break;            default:                fail("unespected key " + k);                break;        }    });    assertEquals(3, count[0]);    count[0] = 0;        assertSame(summary, provider.getRootContext().getSummary("cc", MetricsContext.DetailLevel.BASIC));    try {        provider.getRootContext().getSummary("cc", MetricsContext.DetailLevel.ADVANCED);        fail("Can't get the same summary with a different DetailLevel");    } catch (IllegalArgumentException err) {        assertThat(err.getMessage(), containsString("Already registered"));    }    String res = callServlet();    assertThat(res, containsString("# TYPE cc summary"));    assertThat(res, CoreMatchers.containsString("cc_sum 20.0"));    assertThat(res, CoreMatchers.containsString("cc_count 2.0"));    assertThat(res, CoreMatchers.containsString("cc{quantile=\"0.5\",} 10.0"));}
testAdvancedSummary
public void zookeeper_f798_0() throws Exception
{    Summary summary = provider.getRootContext().getSummary("cc", MetricsContext.DetailLevel.ADVANCED);    summary.add(10);    summary.add(10);    int[] count = { 0 };    provider.dump((k, v) -> {        count[0]++;        int value = ((Number) v).intValue();        switch(k) {            case "cc{quantile=\"0.5\"}":                assertEquals(10, value);                break;            case "cc{quantile=\"0.9\"}":                assertEquals(10, value);                break;            case "cc{quantile=\"0.99\"}":                assertEquals(10, value);                break;            case "cc_count":                assertEquals(2, value);                break;            case "cc_sum":                assertEquals(20, value);                break;            default:                fail("unespected key " + k);                break;        }    });    assertEquals(5, count[0]);    count[0] = 0;        assertSame(summary, provider.getRootContext().getSummary("cc", MetricsContext.DetailLevel.ADVANCED));    try {        provider.getRootContext().getSummary("cc", MetricsContext.DetailLevel.BASIC);        fail("Can't get the same summary with a different DetailLevel");    } catch (IllegalArgumentException err) {        assertThat(err.getMessage(), containsString("Already registered"));    }    String res = callServlet();    assertThat(res, containsString("# TYPE cc summary"));    assertThat(res, CoreMatchers.containsString("cc_sum 20.0"));    assertThat(res, CoreMatchers.containsString("cc_count 2.0"));    assertThat(res, CoreMatchers.containsString("cc{quantile=\"0.5\",} 10.0"));    assertThat(res, CoreMatchers.containsString("cc{quantile=\"0.9\",} 10.0"));    assertThat(res, CoreMatchers.containsString("cc{quantile=\"0.99\",} 10.0"));}
callServlet
private String zookeeper_f799_0() throws ServletException, IOException
{            StringWriter writer = new StringWriter();    HttpServletResponse response = mock(HttpServletResponse.class);    when(response.getWriter()).thenReturn(new PrintWriter(writer));    HttpServletRequest req = mock(HttpServletRequest.class);    provider.getServlet().doGet(req, response);    String res = writer.toString();    return res;}
start
public synchronized voidf800_1)
{    state = State.START;    dispatchEvent(EventType.START);        if (zooKeeper == null) {        throw new IllegalStateException("No instance of zookeeper provided. Hint: use setZooKeeper()");    }    if (hostName == null) {        throw new IllegalStateException("No hostname provided. Hint: use setHostName()");    }    try {        makeOffer();        determineElectionStatus();    } catch (KeeperException | InterruptedException e) {        becomeFailed(e);    }}
stop
public synchronized voidf801_1)
{    state = State.STOP;    dispatchEvent(EventType.STOP_START);        if (leaderOffer != null) {        try {            zooKeeper.delete(leaderOffer.getNodePath(), -1);                    } catch (InterruptedException | KeeperException e) {            becomeFailed(e);        }    }    dispatchEvent(EventType.STOP_COMPLETE);}
makeOffer
private voidf802_1) throws KeeperException, InterruptedException
{    state = State.OFFER;    dispatchEvent(EventType.OFFER_START);    LeaderOffer newLeaderOffer = new LeaderOffer();    byte[] hostnameBytes;    synchronized (this) {        newLeaderOffer.setHostName(hostName);        hostnameBytes = hostName.getBytes();        newLeaderOffer.setNodePath(zooKeeper.create(rootNodeName + "/" + "n_", hostnameBytes, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL));        leaderOffer = newLeaderOffer;    }        dispatchEvent(EventType.OFFER_COMPLETE);}
getLeaderOffer
private synchronized LeaderOffer zookeeper_f803_0()
{    return leaderOffer;}
determineElectionStatus
private voidf804_1) throws KeeperException, InterruptedException
{    state = State.DETERMINE;    dispatchEvent(EventType.DETERMINE_START);    LeaderOffer currentLeaderOffer = getLeaderOffer();    String[] components = currentLeaderOffer.getNodePath().split("/");    currentLeaderOffer.setId(Integer.valueOf(components[components.length - 1].substring("n_".length())));    List<LeaderOffer> leaderOffers = toLeaderOffers(zooKeeper.getChildren(rootNodeName, false));    /*         * For each leader offer, find out where we fit in. If we're first, we         * become the leader. If we're not elected the leader, attempt to stat the         * offer just less than us. If they exist, watch for their failure, but if         * they don't, become the leader.         */    for (int i = 0; i < leaderOffers.size(); i++) {        LeaderOffer leaderOffer = leaderOffers.get(i);        if (leaderOffer.getId().equals(currentLeaderOffer.getId())) {                        dispatchEvent(EventType.DETERMINE_COMPLETE);            if (i == 0) {                becomeLeader();            } else {                becomeReady(leaderOffers.get(i - 1));            }            /* Once we've figured out where we are, we're done. */            break;        }    }}
becomeReady
private voidf805_1LeaderOffer neighborLeaderOffer) throws KeeperException, InterruptedException
{        /*         * Make sure to pass an explicit Watcher because we could be sharing this         * zooKeeper instance with someone else.         */    Stat stat = zooKeeper.exists(neighborLeaderOffer.getNodePath(), this);    if (stat != null) {        dispatchEvent(EventType.READY_START);                state = State.READY;        dispatchEvent(EventType.READY_COMPLETE);    } else {        /*             * If the stat fails, the node has gone missing between the call to             * getChildren() and exists(). We need to try and become the leader.             */                determineElectionStatus();    }}
becomeLeader
private voidf806_1)
{    state = State.ELECTED;    dispatchEvent(EventType.ELECTED_START);        dispatchEvent(EventType.ELECTED_COMPLETE);}
becomeFailed
private voidf807_1Exception e)
{        state = State.FAILED;    dispatchEvent(EventType.FAILED);}
getLeaderHostName
public String zookeeper_f808_0() throws KeeperException, InterruptedException
{    List<LeaderOffer> leaderOffers = toLeaderOffers(zooKeeper.getChildren(rootNodeName, false));    if (leaderOffers.size() > 0) {        return leaderOffers.get(0).getHostName();    }    return null;}
toLeaderOffers
private List<LeaderOffer> zookeeper_f809_0(List<String> strings) throws KeeperException, InterruptedException
{    List<LeaderOffer> leaderOffers = new ArrayList<>(strings.size());    /*         * Turn each child of rootNodeName into a leader offer. This is a tuple of         * the sequence number and the node name.         */    for (String offer : strings) {        String hostName = new String(zooKeeper.getData(rootNodeName + "/" + offer, false, null));        leaderOffers.add(new LeaderOffer(Integer.valueOf(offer.substring("n_".length())), rootNodeName + "/" + offer, hostName));    }    /*         * We sort leader offers by sequence number (which may not be zero-based or         * contiguous) and keep their paths handy for setting watches.         */    Collections.sort(leaderOffers, new LeaderOffer.IdComparator());    return leaderOffers;}
process
public voidf810_1WatchedEvent event)
{    if (event.getType().equals(Watcher.Event.EventType.NodeDeleted)) {        if (!event.getPath().equals(getLeaderOffer().getNodePath()) && state != State.STOP) {                        try {                determineElectionStatus();            } catch (KeeperException | InterruptedException e) {                becomeFailed(e);            }        }    }}
dispatchEvent
private voidf811_1EventType eventType)
{        synchronized (listeners) {        if (listeners.size() > 0) {            for (LeaderElectionAware observer : listeners) {                observer.onElectionEvent(eventType);            }        }    }}
addListener
public void zookeeper_f812_0(LeaderElectionAware listener)
{    listeners.add(listener);}
removeListener
public void zookeeper_f813_0(LeaderElectionAware listener)
{    listeners.remove(listener);}
toString
public String zookeeper_f814_0()
{    return "{" + " state:" + state + " leaderOffer:" + getLeaderOffer() + " zooKeeper:" + zooKeeper + " hostName:" + getHostName() + " listeners:" + listeners + " }";}
getRootNodeName
public String zookeeper_f815_0()
{    return rootNodeName;}
setRootNodeName
public void zookeeper_f816_0(String rootNodeName)
{    this.rootNodeName = rootNodeName;}
getZooKeeper
public ZooKeeper zookeeper_f817_0()
{    return zooKeeper;}
setZooKeeper
public void zookeeper_f818_0(ZooKeeper zooKeeper)
{    this.zooKeeper = zooKeeper;}
getHostName
public synchronized String zookeeper_f819_0()
{    return hostName;}
setHostName
public synchronized void zookeeper_f820_0(String hostName)
{    this.hostName = hostName;}
toString
public String zookeeper_f821_0()
{    return "{" + " id:" + id + " nodePath:" + nodePath + " hostName:" + hostName + " }";}
getId
public Integer zookeeper_f822_0()
{    return id;}
setId
public void zookeeper_f823_0(Integer id)
{    this.id = id;}
getNodePath
public String zookeeper_f824_0()
{    return nodePath;}
setNodePath
public void zookeeper_f825_0(String nodePath)
{    this.nodePath = nodePath;}
getHostName
public String zookeeper_f826_0()
{    return hostName;}
setHostName
public void zookeeper_f827_0(String hostName)
{    this.hostName = hostName;}
compare
public int zookeeper_f828_0(LeaderOffer o1, LeaderOffer o2)
{    return o1.getId().compareTo(o2.getId());}
setUp
public void zookeeper_f829_0() throws Exception
{    super.setUp();    zooKeeper = createClient();    zooKeeper.create(TEST_ROOT_NODE + Thread.currentThread().getId(), new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);}
tearDown
public void zookeeper_f830_0() throws Exception
{    if (zooKeeper != null) {        zooKeeper.delete(TEST_ROOT_NODE + Thread.currentThread().getId(), -1);    }    super.tearDown();}
testNode
public void zookeeper_f831_0() throws Exception
{    LeaderElectionSupport electionSupport = createLeaderElectionSupport();    electionSupport.start();    Thread.sleep(3000);    electionSupport.stop();}
testNodes3
public voidf832_1) throws Exception
{    int testIterations = 3;    final CountDownLatch latch = new CountDownLatch(testIterations);    final AtomicInteger failureCounter = new AtomicInteger();    for (int i = 0; i < testIterations; i++) {        runElectionSupportThread(latch, failureCounter);    }    Assert.assertEquals(0, failureCounter.get());    if (!latch.await(10, TimeUnit.SECONDS)) {            }}
testNodes9
public voidf833_1) throws Exception
{    int testIterations = 9;    final CountDownLatch latch = new CountDownLatch(testIterations);    final AtomicInteger failureCounter = new AtomicInteger();    for (int i = 0; i < testIterations; i++) {        runElectionSupportThread(latch, failureCounter);    }    Assert.assertEquals(0, failureCounter.get());    if (!latch.await(10, TimeUnit.SECONDS)) {            }}
testNodes20
public voidf834_1) throws Exception
{    int testIterations = 20;    final CountDownLatch latch = new CountDownLatch(testIterations);    final AtomicInteger failureCounter = new AtomicInteger();    for (int i = 0; i < testIterations; i++) {        runElectionSupportThread(latch, failureCounter);    }    Assert.assertEquals(0, failureCounter.get());    if (!latch.await(10, TimeUnit.SECONDS)) {            }}
testNodes100
public voidf835_1) throws Exception
{    int testIterations = 100;    final CountDownLatch latch = new CountDownLatch(testIterations);    final AtomicInteger failureCounter = new AtomicInteger();    for (int i = 0; i < testIterations; i++) {        runElectionSupportThread(latch, failureCounter);    }    Assert.assertEquals(0, failureCounter.get());    if (!latch.await(20, TimeUnit.SECONDS)) {            }}
testOfferShuffle
public voidf836_1) throws InterruptedException
{    int testIterations = 10;    final CountDownLatch latch = new CountDownLatch(testIterations);    final AtomicInteger failureCounter = new AtomicInteger();    List<Thread> threads = new ArrayList<>(testIterations);    for (int i = 1; i <= testIterations; i++) {        threads.add(runElectionSupportThread(latch, failureCounter, Math.min(i * 1200, 10000)));    }    if (!latch.await(60, TimeUnit.SECONDS)) {            }}
testGetLeaderHostName
public void zookeeper_f837_0() throws Exception
{    LeaderElectionSupport electionSupport = createLeaderElectionSupport();    electionSupport.start();        Thread.sleep(3000);    String leaderHostName = electionSupport.getLeaderHostName();    Assert.assertNotNull(leaderHostName);    Assert.assertEquals("foohost", leaderHostName);    electionSupport.stop();}
testReadyOffer
public voidf838_1) throws Exception
{    final ArrayList<EventType> events = new ArrayList<>();    final CountDownLatch electedComplete = new CountDownLatch(1);    final LeaderElectionSupport electionSupport1 = createLeaderElectionSupport();    electionSupport1.start();    LeaderElectionSupport electionSupport2 = createLeaderElectionSupport();    LeaderElectionAware listener = new LeaderElectionAware() {        boolean stoppedElectedNode = false;        @Override        public void onElectionEvent(EventType eventType) {            events.add(eventType);            if (!stoppedElectedNode && eventType == EventType.DETERMINE_COMPLETE) {                stoppedElectedNode = true;                try {                                        electionSupport1.stop();                } catch (Exception e) {                                    }            }            if (eventType == EventType.ELECTED_COMPLETE) {                electedComplete.countDown();            }        }    };    electionSupport2.addListener(listener);    electionSupport2.start();        electedComplete.await(CONNECTION_TIMEOUT / 3, TimeUnit.MILLISECONDS);    final ArrayList<EventType> expectedevents = new ArrayList<>();    expectedevents.add(EventType.START);    expectedevents.add(EventType.OFFER_START);    expectedevents.add(EventType.OFFER_COMPLETE);    expectedevents.add(EventType.DETERMINE_START);    expectedevents.add(EventType.DETERMINE_COMPLETE);    expectedevents.add(EventType.DETERMINE_START);    expectedevents.add(EventType.DETERMINE_COMPLETE);    expectedevents.add(EventType.ELECTED_START);    expectedevents.add(EventType.ELECTED_COMPLETE);    Assert.assertEquals("Events has failed to executed in the order", expectedevents, events);    electionSupport2.stop();}
onElectionEvent
public voidf839_1EventType eventType)
{    events.add(eventType);    if (!stoppedElectedNode && eventType == EventType.DETERMINE_COMPLETE) {        stoppedElectedNode = true;        try {                        electionSupport1.stop();        } catch (Exception e) {                    }    }    if (eventType == EventType.ELECTED_COMPLETE) {        electedComplete.countDown();    }}
createLeaderElectionSupport
private LeaderElectionSupport zookeeper_f840_0()
{    LeaderElectionSupport electionSupport = new LeaderElectionSupport();    electionSupport.setZooKeeper(zooKeeper);    electionSupport.setRootNodeName(TEST_ROOT_NODE + Thread.currentThread().getId());    electionSupport.setHostName("foohost");    return electionSupport;}
runElectionSupportThread
private Thread zookeeper_f841_0(final CountDownLatch latch, final AtomicInteger failureCounter)
{    return runElectionSupportThread(latch, failureCounter, 3000);}
runElectionSupportThread
private Threadf842_1final CountDownLatch latch, final AtomicInteger failureCounter, final long sleepDuration)
{    final LeaderElectionSupport electionSupport = createLeaderElectionSupport();    Thread t = new Thread(() -> {        try {            electionSupport.start();            Thread.sleep(sleepDuration);            electionSupport.stop();            latch.countDown();        } catch (Exception e) {                        failureCounter.incrementAndGet();        }    });    t.start();    return t;}
close
public void zookeeper_f843_0()
{    if (closed.compareAndSet(false, true)) {        doClose();    }}
getZookeeper
public ZooKeeper zookeeper_f844_0()
{    return zookeeper;}
getAcl
public List<ACL> zookeeper_f845_0()
{    return acl;}
setAcl
public void zookeeper_f846_0(List<ACL> acl)
{    this.acl = acl;}
getRetryDelay
public long zookeeper_f847_0()
{    return retryDelay;}
setRetryDelay
public void zookeeper_f848_0(long retryDelay)
{    this.retryDelay = retryDelay;}
doClose
protected void zookeeper_f849_0()
{}
retryOperation
protected Objectf850_1ZooKeeperOperation operation) throws KeeperException, InterruptedException
{    KeeperException exception = null;    for (int i = 0; i < retryCount; i++) {        try {            return operation.execute();        } catch (KeeperException.SessionExpiredException e) {                        throw e;        } catch (KeeperException.ConnectionLossException e) {            if (exception == null) {                exception = e;            }                        retryDelay(i);        }    }    throw exception;}
ensurePathExists
protected void zookeeper_f851_0(String path)
{    ensureExists(path, null, acl, CreateMode.PERSISTENT);}
ensureExists
protected voidf852_1final String path, final byte[] data, final List<ACL> acl, final CreateMode flags)
{    try {        retryOperation(() -> {            Stat stat = zookeeper.exists(path, false);            if (stat != null) {                return true;            }            zookeeper.create(path, data, acl, flags);            return true;        });    } catch (KeeperException | InterruptedException e) {            }}
isClosed
protected boolean zookeeper_f853_0()
{    return closed.get();}
retryDelay
protected voidf854_1int attemptCount)
{    if (attemptCount > 0) {        try {            Thread.sleep(attemptCount * retryDelay);        } catch (InterruptedException e) {                    }    }}
getLockListener
public synchronized LockListener zookeeper_f855_0()
{    return this.callback;}
setLockListener
public synchronized void zookeeper_f856_0(LockListener callback)
{    this.callback = callback;}
unlock
public synchronized voidf857_1) throws RuntimeException
{    if (!isClosed() && id != null) {                try {            ZooKeeperOperation zopdel = () -> {                zookeeper.delete(id, -1);                return Boolean.TRUE;            };            zopdel.execute();        } catch (InterruptedException e) {                                    Thread.currentThread().interrupt();        } catch (KeeperException.NoNodeException e) {                } catch (KeeperException e) {                        throw new RuntimeException(e.getMessage(), e);        } finally {            LockListener lockListener = getLockListener();            if (lockListener != null) {                lockListener.lockReleased();            }            id = null;        }    }}
process
public voidf858_1WatchedEvent event)
{            try {        lock();    } catch (Exception e) {            }}
findPrefixInChildren
private voidf859_1String prefix, ZooKeeper zookeeper, String dir) throws KeeperException, InterruptedException
{    List<String> names = zookeeper.getChildren(dir, false);    for (String name : names) {        if (name.startsWith(prefix)) {            id = name;                        break;        }    }    if (id == null) {        id = zookeeper.create(dir + "/" + prefix, data, getAcl(), EPHEMERAL_SEQUENTIAL);            }}
execute
public booleanf860_1) throws KeeperException, InterruptedException
{    do {        if (id == null) {            long sessionId = zookeeper.getSessionId();            String prefix = "x-" + sessionId + "-";                                    findPrefixInChildren(prefix, zookeeper, dir);            idName = new ZNodeName(id);        }        List<String> names = zookeeper.getChildren(dir, false);        if (names.isEmpty()) {                                    id = null;        } else {                        SortedSet<ZNodeName> sortedNames = new TreeSet<>();            for (String name : names) {                sortedNames.add(new ZNodeName(dir + "/" + name));            }            ownerId = sortedNames.first().getName();            SortedSet<ZNodeName> lessThanMe = sortedNames.headSet(idName);            if (!lessThanMe.isEmpty()) {                ZNodeName lastChildName = lessThanMe.last();                lastChildId = lastChildName.getName();                                Stat stat = zookeeper.exists(lastChildId, new LockWatcher());                if (stat != null) {                    return Boolean.FALSE;                } else {                                    }            } else {                if (isOwner()) {                    LockListener lockListener = getLockListener();                    if (lockListener != null) {                        lockListener.lockAcquired();                    }                    return Boolean.TRUE;                }            }        }    } while (id == null);    return Boolean.FALSE;}
lock
public synchronized boolean zookeeper_f861_0() throws KeeperException, InterruptedException
{    if (isClosed()) {        return false;    }    ensurePathExists(dir);    return (Boolean) retryOperation(zop);}
getDir
public String zookeeper_f862_0()
{    return dir;}
isOwner
public boolean zookeeper_f863_0()
{    return id != null && id.equals(ownerId);}
getId
public String zookeeper_f864_0()
{    return this.id;}
toString
public String zookeeper_f865_0()
{    return name.toString();}
equals
public boolean zookeeper_f866_0(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    ZNodeName sequence = (ZNodeName) o;    return name.equals(sequence.name);}
hashCode
public int zookeeper_f867_0()
{    return name.hashCode() + 37;}
compareTo
public int zookeeper_f868_0(ZNodeName that)
{    int answer = this.sequence - that.sequence;    if (answer == 0) {        return this.prefix.compareTo(that.prefix);    }    return answer;}
getName
public String zookeeper_f869_0()
{    return name;}
getZNodeName
public int zookeeper_f870_0()
{    return sequence;}
getPrefix
public String zookeeper_f871_0()
{    return prefix;}
testRun
public void zookeeper_f872_0() throws Exception
{    runTest(3);}
lockAcquired
public void zookeeper_f873_0()
{    latch.countDown();}
lockReleased
public void zookeeper_f874_0()
{}
runTest
protected void zookeeper_f875_0(int count) throws Exception
{    nodes = new WriteLock[count];    for (int i = 0; i < count; i++) {        ZooKeeper keeper = createClient();        WriteLock leader = new WriteLock(keeper, dir, null);        leader.setLockListener(new LockCallback());        nodes[i] = leader;        leader.lock();    }            latch.await(30, TimeUnit.SECONDS);    WriteLock first = nodes[0];    dumpNodes(count);        Assert.assertTrue("The first znode should be the leader " + first.getId(), first.isOwner());    for (int i = 1; i < count; i++) {        WriteLock node = nodes[i];        Assert.assertFalse("Node should not be the leader " + node.getId(), node.isOwner());    }    if (count > 1) {        if (killLeader) {            System.out.println("Now killing the leader");                        latch = new CountDownLatch(1);            first.unlock();            latch.await(30, TimeUnit.SECONDS);                        WriteLock second = nodes[1];            dumpNodes(count);                        Assert.assertTrue("The second znode should be the leader " + second.getId(), second.isOwner());            for (int i = 2; i < count; i++) {                WriteLock node = nodes[i];                Assert.assertFalse("Node should not be the leader " + node.getId(), node.isOwner());            }        }        if (restartServer) {                        System.out.println("Now stopping the server");            stopServer();            Thread.sleep(10000);                        dumpNodes(count);            System.out.println("Starting the server");            startServer();            Thread.sleep(10000);            for (int i = 0; i < count - 1; i++) {                System.out.println("Calling acquire for node: " + i);                nodes[i].lock();            }            dumpNodes(count);            System.out.println("Now closing down...");        }    }}
dumpNodes
protected void zookeeper_f876_0(int count)
{    for (int i = 0; i < count; i++) {        WriteLock node = nodes[i];        System.out.println("node: " + i + " id: " + node.getId() + " is leader: " + node.isOwner());    }}
tearDown
public void zookeeper_f877_0() throws Exception
{    if (nodes != null) {        for (int i = 0; i < nodes.length; i++) {            WriteLock node = nodes[i];            if (node != null) {                System.out.println("Closing node: " + i);                node.close();                if (workAroundClosingLastZNodeFails && i == nodes.length - 1) {                    System.out.println("Not closing zookeeper: " + i + " due to bug!");                } else {                    System.out.println("Closing zookeeper: " + i);                    node.getZookeeper().close();                    System.out.println("Closed zookeeper: " + i);                }            }        }    }    System.out.println("Now lets stop the server");    super.tearDown();}
testOrderWithSamePrefix
public void zookeeper_f878_0() throws Exception
{    String[] names = { "x-3", "x-5", "x-11", "x-1" };    String[] expected = { "x-1", "x-3", "x-5", "x-11" };    assertOrderedNodeNames(names, expected);}
testOrderWithDifferentPrefixes
public void zookeeper_f879_0() throws Exception
{    String[] names = { "r-3", "r-2", "r-1", "w-2", "w-1" };    String[] expected = { "r-1", "w-1", "r-2", "w-2", "r-3" };    assertOrderedNodeNames(names, expected);}
testOrderWithDifferentPrefixIncludingSessionId
public void zookeeper_f880_0() throws Exception
{    String[] names = { "x-242681582799028564-0000000002", "x-170623981976748329-0000000003", "x-98566387950223723-0000000001" };    String[] expected = { "x-98566387950223723-0000000001", "x-242681582799028564-0000000002", "x-170623981976748329-0000000003" };    assertOrderedNodeNames(names, expected);}
testOrderWithExtraPrefixes
public void zookeeper_f881_0() throws Exception
{    String[] names = { "r-1-3-2", "r-2-2-1", "r-3-1-3" };    String[] expected = { "r-2-2-1", "r-1-3-2", "r-3-1-3" };    assertOrderedNodeNames(names, expected);}
assertOrderedNodeNames
protected void zookeeper_f882_0(String[] names, String[] expected)
{    int size = names.length;    SortedSet<ZNodeName> nodeNames = new TreeSet<>();    for (String name : names) {        nodeNames.add(new ZNodeName(name));    }    Assert.assertEquals("The SortedSet does not have the expected size!", nodeNames.size(), expected.length);    int index = 0;    for (ZNodeName nodeName : nodeNames) {        String name = nodeName.getName();        Assert.assertEquals("Node " + index, expected[index++], name);    }}
orderedChildren
private Map<Long, String>f883_1Watcher watcher) throws KeeperException, InterruptedException
{    Map<Long, String> orderedChildren = new TreeMap<>();    List<String> childNames;    childNames = zookeeper.getChildren(dir, watcher);    for (String childName : childNames) {        try {                        if (!childName.regionMatches(0, prefix, 0, prefix.length())) {                                continue;            }            String suffix = childName.substring(prefix.length());            Long childId = Long.parseLong(suffix);            orderedChildren.put(childId, childName);        } catch (NumberFormatException e) {                    }    }    return orderedChildren;}
smallestChildName
private Stringf884_1) throws KeeperException, InterruptedException
{    long minId = Long.MAX_VALUE;    String minName = "";    List<String> childNames;    try {        childNames = zookeeper.getChildren(dir, false);    } catch (KeeperException.NoNodeException e) {                return null;    }    for (String childName : childNames) {        try {                        if (!childName.regionMatches(0, prefix, 0, prefix.length())) {                                continue;            }            String suffix = childName.substring(prefix.length());            long childId = Long.parseLong(suffix);            if (childId < minId) {                minId = childId;                minName = childName;            }        } catch (NumberFormatException e) {                    }    }    if (minId < Long.MAX_VALUE) {        return minName;    } else {        return null;    }}
element
public byte[] zookeeper_f885_0() throws NoSuchElementException, KeeperException, InterruptedException
{    Map<Long, String> orderedChildren;        while (true) {        try {            orderedChildren = orderedChildren(null);        } catch (KeeperException.NoNodeException e) {            throw new NoSuchElementException();        }        if (orderedChildren.size() == 0) {            throw new NoSuchElementException();        }        for (String headNode : orderedChildren.values()) {            if (headNode != null) {                try {                    return zookeeper.getData(dir + "/" + headNode, false, null);                } catch (KeeperException.NoNodeException e) {                                }            }        }    }}
remove
public byte[] zookeeper_f886_0() throws NoSuchElementException, KeeperException, InterruptedException
{    Map<Long, String> orderedChildren;        while (true) {        try {            orderedChildren = orderedChildren(null);        } catch (KeeperException.NoNodeException e) {            throw new NoSuchElementException();        }        if (orderedChildren.size() == 0) {            throw new NoSuchElementException();        }        for (String headNode : orderedChildren.values()) {            String path = dir + "/" + headNode;            try {                byte[] data = zookeeper.getData(path, false, null);                zookeeper.delete(path, -1);                return data;            } catch (KeeperException.NoNodeException e) {                        }        }    }}
process
public voidf887_1WatchedEvent event)
{        latch.countDown();}
await
public void zookeeper_f888_0() throws InterruptedException
{    latch.await();}
take
public byte[] zookeeper_f889_0() throws KeeperException, InterruptedException
{    Map<Long, String> orderedChildren;        while (true) {        LatchChildWatcher childWatcher = new LatchChildWatcher();        try {            orderedChildren = orderedChildren(childWatcher);        } catch (KeeperException.NoNodeException e) {            zookeeper.create(dir, new byte[0], acl, CreateMode.PERSISTENT);            continue;        }        if (orderedChildren.size() == 0) {            childWatcher.await();            continue;        }        for (String headNode : orderedChildren.values()) {            String path = dir + "/" + headNode;            try {                byte[] data = zookeeper.getData(path, false, null);                zookeeper.delete(path, -1);                return data;            } catch (KeeperException.NoNodeException e) {                        }        }    }}
offer
public boolean zookeeper_f890_0(byte[] data) throws KeeperException, InterruptedException
{    for (; ; ) {        try {            zookeeper.create(dir + "/" + prefix, data, acl, CreateMode.PERSISTENT_SEQUENTIAL);            return true;        } catch (KeeperException.NoNodeException e) {            zookeeper.create(dir, new byte[0], acl, CreateMode.PERSISTENT);        }    }}
peek
public byte[] zookeeper_f891_0() throws KeeperException, InterruptedException
{    try {        return element();    } catch (NoSuchElementException e) {        return null;    }}
poll
public byte[] zookeeper_f892_0() throws KeeperException, InterruptedException
{    try {        return remove();    } catch (NoSuchElementException e) {        return null;    }}
tearDown
public voidf893_1) throws Exception
{    super.tearDown();    }
testOffer1
public void zookeeper_f894_0() throws Exception
{    String dir = "/testOffer1";    String testString = "Hello World";    final int numClients = 1;    ZooKeeper[] clients = new ZooKeeper[numClients];    DistributedQueue[] queueHandles = new DistributedQueue[numClients];    for (int i = 0; i < clients.length; i++) {        clients[i] = createClient();        queueHandles[i] = new DistributedQueue(clients[i], dir, null);    }    queueHandles[0].offer(testString.getBytes());    byte[] dequeuedBytes = queueHandles[0].remove();    Assert.assertEquals(new String(dequeuedBytes), testString);}
testOffer2
public void zookeeper_f895_0() throws Exception
{    String dir = "/testOffer2";    String testString = "Hello World";    final int numClients = 2;    ZooKeeper[] clients = new ZooKeeper[numClients];    DistributedQueue[] queueHandles = new DistributedQueue[numClients];    for (int i = 0; i < clients.length; i++) {        clients[i] = createClient();        queueHandles[i] = new DistributedQueue(clients[i], dir, null);    }    queueHandles[0].offer(testString.getBytes());    byte[] dequeuedBytes = queueHandles[1].remove();    Assert.assertEquals(new String(dequeuedBytes), testString);}
testTake1
public void zookeeper_f896_0() throws Exception
{    String dir = "/testTake1";    String testString = "Hello World";    final int numClients = 1;    ZooKeeper[] clients = new ZooKeeper[numClients];    DistributedQueue[] queueHandles = new DistributedQueue[numClients];    for (int i = 0; i < clients.length; i++) {        clients[i] = createClient();        queueHandles[i] = new DistributedQueue(clients[i], dir, null);    }    queueHandles[0].offer(testString.getBytes());    byte[] dequeuedBytes = queueHandles[0].take();    Assert.assertEquals(new String(dequeuedBytes), testString);}
testRemove1
public void zookeeper_f897_0() throws Exception
{    String dir = "/testRemove1";    final int numClients = 1;    ZooKeeper[] clients = new ZooKeeper[numClients];    DistributedQueue[] queueHandles = new DistributedQueue[numClients];    for (int i = 0; i < clients.length; i++) {        clients[i] = createClient();        queueHandles[i] = new DistributedQueue(clients[i], dir, null);    }    try {        queueHandles[0].remove();    } catch (NoSuchElementException e) {        return;    }    Assert.fail();}
createNremoveMtest
public void zookeeper_f898_0(String dir, int n, int m) throws Exception
{    String testString = "Hello World";    final int numClients = 2;    ZooKeeper[] clients = new ZooKeeper[numClients];    DistributedQueue[] queueHandles = new DistributedQueue[numClients];    for (int i = 0; i < clients.length; i++) {        clients[i] = createClient();        queueHandles[i] = new DistributedQueue(clients[i], dir, null);    }    for (int i = 0; i < n; i++) {        String offerString = testString + i;        queueHandles[0].offer(offerString.getBytes());    }    byte[] data = null;    for (int i = 0; i < m; i++) {        data = queueHandles[1].remove();    }    Assert.assertNotNull(data);    Assert.assertEquals(new String(data), testString + (m - 1));}
testRemove2
public void zookeeper_f899_0() throws Exception
{    createNremoveMtest("/testRemove2", 10, 2);}
testRemove3
public void zookeeper_f900_0() throws Exception
{    createNremoveMtest("/testRemove3", 1000, 1000);}
createNremoveMelementTest
public void zookeeper_f901_0(String dir, int n, int m) throws Exception
{    String testString = "Hello World";    final int numClients = 2;    ZooKeeper[] clients = new ZooKeeper[numClients];    DistributedQueue[] queueHandles = new DistributedQueue[numClients];    for (int i = 0; i < clients.length; i++) {        clients[i] = createClient();        queueHandles[i] = new DistributedQueue(clients[i], dir, null);    }    for (int i = 0; i < n; i++) {        String offerString = testString + i;        queueHandles[0].offer(offerString.getBytes());    }    for (int i = 0; i < m; i++) {        queueHandles[1].remove();    }    Assert.assertEquals(new String(queueHandles[1].element()), testString + m);}
testElement1
public void zookeeper_f902_0() throws Exception
{    createNremoveMelementTest("/testElement1", 1, 0);}
testElement2
public void zookeeper_f903_0() throws Exception
{    createNremoveMelementTest("/testElement2", 10, 2);}
testElement3
public void zookeeper_f904_0() throws Exception
{    createNremoveMelementTest("/testElement3", 1000, 500);}
testElement4
public void zookeeper_f905_0() throws Exception
{    createNremoveMelementTest("/testElement4", 1000, 1000 - 1);}
testTakeWait1
public void zookeeper_f906_0() throws Exception
{    String dir = "/testTakeWait1";    final String testString = "Hello World";    final int numClients = 1;    final ZooKeeper[] clients = new ZooKeeper[numClients];    final DistributedQueue[] queueHandles = new DistributedQueue[numClients];    for (int i = 0; i < clients.length; i++) {        clients[i] = createClient();        queueHandles[i] = new DistributedQueue(clients[i], dir, null);    }    final byte[][] takeResult = new byte[1][];    Thread takeThread = new Thread(() -> {        try {            takeResult[0] = queueHandles[0].take();        } catch (KeeperException | InterruptedException ignore) {                }    });    takeThread.start();    Thread.sleep(1000);    Thread offerThread = new Thread(() -> {        try {            queueHandles[0].offer(testString.getBytes());        } catch (KeeperException | InterruptedException ignore) {                }    });    offerThread.start();    offerThread.join();    takeThread.join();    Assert.assertNotNull(takeResult[0]);    Assert.assertEquals(new String(takeResult[0]), testString);}
testTakeWait2
public void zookeeper_f907_0() throws Exception
{    String dir = "/testTakeWait2";    final String testString = "Hello World";    final int numClients = 1;    final ZooKeeper[] clients = new ZooKeeper[numClients];    final DistributedQueue[] queueHandles = new DistributedQueue[numClients];    for (int i = 0; i < clients.length; i++) {        clients[i] = createClient();        queueHandles[i] = new DistributedQueue(clients[i], dir, null);    }    int numAttempts = 2;    for (int i = 0; i < numAttempts; i++) {        final byte[][] takeResult = new byte[1][];        final String threadTestString = testString + i;        Thread takeThread = new Thread(() -> {            try {                takeResult[0] = queueHandles[0].take();            } catch (KeeperException | InterruptedException ignore) {                        }        });        takeThread.start();        Thread.sleep(1000);        Thread offerThread = new Thread(() -> {            try {                queueHandles[0].offer(threadTestString.getBytes());            } catch (KeeperException | InterruptedException ignore) {                        }        });        offerThread.start();        offerThread.join();        takeThread.join();        Assert.assertNotNull(takeResult[0]);        Assert.assertEquals(new String(takeResult[0]), threadTestString);    }}
reconfigure
public byte[] zookeeper_f908_0(String joiningServers, String leavingServers, String newMembers, long fromConfig, Stat stat) throws KeeperException, InterruptedException
{    RequestHeader h = new RequestHeader();    h.setType(ZooDefs.OpCode.reconfig);    ReconfigRequest request = new ReconfigRequest(joiningServers, leavingServers, newMembers, fromConfig);    GetDataResponse response = new GetDataResponse();    ReplyHeader r = cnxn.submitRequest(h, request, response, null);    if (r.getErr() != 0) {        throw KeeperException.create(KeeperException.Code.get(r.getErr()), "");    }    if (stat != null) {        DataTree.copyStat(response.getStat(), stat);    }    return response.getData();}
reconfigure
public byte[] zookeeper_f909_0(List<String> joiningServers, List<String> leavingServers, List<String> newMembers, long fromConfig, Stat stat) throws KeeperException, InterruptedException
{    return reconfigure(StringUtils.joinStrings(joiningServers, ","), StringUtils.joinStrings(leavingServers, ","), StringUtils.joinStrings(newMembers, ","), fromConfig, stat);}
reconfigure
public void zookeeper_f910_0(String joiningServers, String leavingServers, String newMembers, long fromConfig, DataCallback cb, Object ctx)
{    RequestHeader h = new RequestHeader();    h.setType(ZooDefs.OpCode.reconfig);    ReconfigRequest request = new ReconfigRequest(joiningServers, leavingServers, newMembers, fromConfig);    GetDataResponse response = new GetDataResponse();    cnxn.queuePacket(h, new ReplyHeader(), request, response, cb, ZooDefs.CONFIG_NODE, ZooDefs.CONFIG_NODE, ctx, null);}
reconfigure
public void zookeeper_f911_0(List<String> joiningServers, List<String> leavingServers, List<String> newMembers, long fromConfig, DataCallback cb, Object ctx)
{    reconfigure(StringUtils.joinStrings(joiningServers, ","), StringUtils.joinStrings(leavingServers, ","), StringUtils.joinStrings(newMembers, ","), fromConfig, cb, ctx);}
toString
public String zookeeper_f912_0()
{    return super.toString();}
parse
public static List<ACL> zookeeper_f913_0(String aclString)
{    List<ACL> acl;    String[] acls = aclString.split(",");    acl = new ArrayList<ACL>();    for (String a : acls) {        int firstColon = a.indexOf(':');        int lastColon = a.lastIndexOf(':');        if (firstColon == -1 || lastColon == -1 || firstColon == lastColon) {            System.err.println(a + " does not have the form scheme:id:perm");            continue;        }        ACL newAcl = new ACL();        newAcl.setId(new Id(a.substring(0, firstColon), a.substring(firstColon + 1, lastColon)));        newAcl.setPerms(getPermFromString(a.substring(lastColon + 1)));        acl.add(newAcl);    }    return acl;}
getPermFromString
private static int zookeeper_f914_0(String permString)
{    int perm = 0;    for (int i = 0; i < permString.length(); i++) {        switch(permString.charAt(i)) {            case 'r':                perm |= ZooDefs.Perms.READ;                break;            case 'w':                perm |= ZooDefs.Perms.WRITE;                break;            case 'c':                perm |= ZooDefs.Perms.CREATE;                break;            case 'd':                perm |= ZooDefs.Perms.DELETE;                break;            case 'a':                perm |= ZooDefs.Perms.ADMIN;                break;            default:                System.err.println("Unknown perm type: " + permString.charAt(i));        }    }    return perm;}
parse
public CliCommand zookeeper_f915_0(String[] cmdArgs) throws CliParseException
{    Parser parser = new PosixParser();    CommandLine cl;    try {        cl = parser.parse(options, cmdArgs);    } catch (ParseException ex) {        throw new CliParseException(ex);    }    args = cl.getArgs();    if (args.length < 2) {        throw new CliParseException(getUsageStr());    }    return this;}
exec
public boolean zookeeper_f916_0() throws CliException
{    byte[] b = null;    if (args.length >= 3) {        b = args[2].getBytes();    }    zk.addAuthInfo(args[1], b);    return false;}
setOut
public void zookeeper_f917_0(PrintStream out)
{    this.out = out;}
setErr
public void zookeeper_f918_0(PrintStream err)
{    this.err = err;}
setZk
public void zookeeper_f919_0(ZooKeeper zk)
{    this.zk = zk;}
getCmdStr
public String zookeeper_f920_0()
{    return cmdStr;}
getOptionStr
public String zookeeper_f921_0()
{    return optionStr;}
getUsageStr
public String zookeeper_f922_0()
{    return cmdStr + " " + optionStr;}
addToMap
public void zookeeper_f923_0(Map<String, CliCommand> cmdMap)
{    cmdMap.put(cmdStr, this);}
getExitCode
public int zookeeper_f924_0()
{    return exitCode;}
getMessage
private static String zookeeper_f925_0(Throwable cause)
{    if (cause instanceof KeeperException) {        KeeperException keeperException = (KeeperException) cause;        if (keeperException instanceof KeeperException.NoNodeException) {            return "Node does not exist: " + keeperException.getPath();        } else if (keeperException instanceof KeeperException.NoChildrenForEphemeralsException) {            return "Ephemerals cannot have children: " + keeperException.getPath();        } else if (keeperException instanceof KeeperException.NodeExistsException) {            return "Node already exists: " + keeperException.getPath();        } else if (keeperException instanceof KeeperException.NotEmptyException) {            return "Node not empty: " + keeperException.getPath();        } else if (keeperException instanceof KeeperException.NotReadOnlyException) {            return "Not a read-only call: " + keeperException.getPath();        } else if (keeperException instanceof KeeperException.InvalidACLException) {            return "Acl is not valid : " + keeperException.getPath();        } else if (keeperException instanceof KeeperException.NoAuthException) {            return "Authentication is not valid : " + keeperException.getPath();        } else if (keeperException instanceof KeeperException.BadArgumentsException) {            return "Arguments are not valid : " + keeperException.getPath();        } else if (keeperException instanceof KeeperException.BadVersionException) {            return "version No is not valid : " + keeperException.getPath();        } else if (keeperException instanceof KeeperException.ReconfigInProgress) {            return "Another reconfiguration is in progress -- concurrent " + "reconfigs not supported (yet)";        } else if (keeperException instanceof KeeperException.NewConfigNoQuorum) {            return "No quorum of new config is connected and " + "up-to-date with the leader of last commmitted config - try invoking reconfiguration after " + "new servers are connected and synced";        }    }    return cause.getMessage();}
parse
public CliCommand zookeeper_f926_0(String[] cmdArgs) throws CliParseException
{    return this;}
exec
public boolean zookeeper_f927_0() throws CliException
{    try {        zk.close();    } catch (Exception ex) {        throw new CliWrapperException(ex);    }    return false;}
parse
public CliCommand zookeeper_f928_0(String[] cmdArgs) throws CliParseException
{    Parser parser = new PosixParser();    try {        cl = parser.parse(options, cmdArgs);    } catch (ParseException ex) {        throw new CliParseException(ex);    }    args = cl.getArgs();    if (args.length < 2) {        throw new CliParseException(getUsageStr());    }    return this;}
exec
public boolean zookeeper_f929_0() throws CliException
{    boolean hasE = cl.hasOption("e");    boolean hasS = cl.hasOption("s");    boolean hasC = cl.hasOption("c");    boolean hasT = cl.hasOption("t");    if (hasC && (hasE || hasS)) {        throw new MalformedCommandException("-c cannot be combined with -s or -e. Containers cannot be ephemeral or sequential.");    }    long ttl;    try {        ttl = hasT ? Long.parseLong(cl.getOptionValue("t")) : 0;    } catch (NumberFormatException e) {        throw new MalformedCommandException("-t argument must be a long value");    }    if (hasT && hasE) {        throw new MalformedCommandException("TTLs cannot be used with Ephemeral znodes");    }    if (hasT && hasC) {        throw new MalformedCommandException("TTLs cannot be used with Container znodes");    }    CreateMode flags;    if (hasE && hasS) {        flags = CreateMode.EPHEMERAL_SEQUENTIAL;    } else if (hasE) {        flags = CreateMode.EPHEMERAL;    } else if (hasS) {        flags = hasT ? CreateMode.PERSISTENT_SEQUENTIAL_WITH_TTL : CreateMode.PERSISTENT_SEQUENTIAL;    } else if (hasC) {        flags = CreateMode.CONTAINER;    } else {        flags = hasT ? CreateMode.PERSISTENT_WITH_TTL : CreateMode.PERSISTENT;    }    if (hasT) {        try {            EphemeralType.TTL.toEphemeralOwner(ttl);        } catch (IllegalArgumentException e) {            throw new MalformedCommandException(e.getMessage());        }    }    String path = args[1];    byte[] data = null;    if (args.length > 2) {        data = args[2].getBytes();    }    List<ACL> acl = ZooDefs.Ids.OPEN_ACL_UNSAFE;    if (args.length > 3) {        acl = AclParser.parse(args[3]);    }    try {        String newPath = hasT ? zk.create(path, data, acl, flags, new Stat(), ttl) : zk.create(path, data, acl, flags);        err.println("Created " + newPath);    } catch (IllegalArgumentException ex) {        throw new MalformedPathException(ex.getMessage());    } catch (KeeperException.EphemeralOnLocalSessionException e) {        err.println("Unable to create ephemeral node on a local session");        throw new CliWrapperException(e);    } catch (KeeperException.InvalidACLException ex) {        err.println(ex.getMessage());        throw new CliWrapperException(ex);    } catch (KeeperException | InterruptedException ex) {        throw new CliWrapperException(ex);    }    return true;}
parse
public CliCommand zookeeper_f930_0(String[] cmdArgs) throws CliParseException
{    Parser parser = new PosixParser();    try {        cl = parser.parse(options, cmdArgs);    } catch (ParseException ex) {        throw new CliParseException(ex);    }    args = cl.getArgs();    if (args.length < 2) {        throw new CliParseException(getUsageStr());    }    return this;}
exec
public boolean zookeeper_f931_0() throws CliException
{    printDeprecatedWarning();    int batchSize;    try {        batchSize = cl.hasOption("b") ? Integer.parseInt(cl.getOptionValue("b")) : 1000;    } catch (NumberFormatException e) {        throw new MalformedCommandException("-b argument must be an int value");    }    String path = args[1];    try {        boolean success = ZKUtil.deleteRecursive(zk, path, batchSize);        if (!success) {            err.println("Failed to delete some node(s) in the subtree!");        }    } catch (IllegalArgumentException ex) {        throw new MalformedPathException(ex.getMessage());    } catch (KeeperException | InterruptedException ex) {        throw new CliWrapperException(ex);    }    return false;}
printDeprecatedWarning
private void zookeeper_f932_0()
{    if ("rmr".equals(args[0])) {        err.println("The command 'rmr' has been deprecated. " + "Please use 'deleteall' instead.");    }}
parse
public CliCommand zookeeper_f933_0(String[] cmdArgs) throws CliParseException
{    Parser parser = new PosixParser();    try {        cl = parser.parse(options, cmdArgs);    } catch (ParseException ex) {        throw new CliParseException(ex);    }    args = cl.getArgs();    if (args.length < 2) {        throw new CliParseException(getUsageStr());    }    retainCompatibility(cmdArgs);    return this;}
retainCompatibility
private void zookeeper_f934_0(String[] cmdArgs) throws CliParseException
{    if (args.length > 2) {        err.println("'delete path [version]' has been deprecated. " + "Please use 'delete [-v version] path' instead.");        Parser parser = new PosixParser();        try {            cl = parser.parse(options, cmdArgs);        } catch (ParseException ex) {            throw new CliParseException(ex);        }        args = cl.getArgs();    }}
exec
public boolean zookeeper_f935_0() throws CliException
{    String path = args[1];    int version;    if (cl.hasOption("v")) {        version = Integer.parseInt(cl.getOptionValue("v"));    } else {        version = -1;    }    try {        zk.delete(path, version);    } catch (IllegalArgumentException ex) {        throw new MalformedPathException(ex.getMessage());    } catch (KeeperException | InterruptedException ex) {        throw new CliWrapperException(ex);    }    return false;}
parse
public CliCommand zookeeper_f936_0(String[] cmdArgs) throws CliParseException
{    Parser parser = new PosixParser();    try {        cl = parser.parse(options, cmdArgs);    } catch (ParseException ex) {        throw new CliParseException(ex);    }    args = cl.getArgs();    if (args.length < 2) {        throw new CliParseException(getUsageStr());    }    return this;}
exec
public boolean zookeeper_f937_0() throws CliException
{            String path = args[1];    try {        if (cl.hasOption("b")) {            delQuota(zk, path, true, false);        } else if (cl.hasOption("n")) {            delQuota(zk, path, false, true);        } else if (args.length == 2) {                                    delQuota(zk, path, true, true);        }    } catch (KeeperException | InterruptedException | IOException ex) {        throw new CliWrapperException(ex);    }    return false;}
delQuota
public static boolean zookeeper_f938_0(ZooKeeper zk, String path, boolean bytes, boolean numNodes) throws KeeperException, IOException, InterruptedException, MalformedPathException
{    String parentPath = Quotas.quotaZookeeper + path;    String quotaPath = Quotas.quotaZookeeper + path + "/" + Quotas.limitNode;    if (zk.exists(quotaPath, false) == null) {        System.out.println("Quota does not exist for " + path);        return true;    }    byte[] data = null;    try {        data = zk.getData(quotaPath, false, new Stat());    } catch (IllegalArgumentException ex) {        throw new MalformedPathException(ex.getMessage());    } catch (KeeperException.NoNodeException ne) {        System.err.println("quota does not exist for " + path);        return true;    }    StatsTrack strack = new StatsTrack(new String(data));    if (bytes && !numNodes) {        strack.setBytes(-1L);        zk.setData(quotaPath, strack.toString().getBytes(), -1);    } else if (!bytes && numNodes) {        strack.setCount(-1);        zk.setData(quotaPath, strack.toString().getBytes(), -1);    } else if (bytes && numNodes) {                        List<String> children = zk.getChildren(parentPath, false);                for (String child : children) {            zk.delete(parentPath + "/" + child, -1);        }                trimProcQuotas(zk, parentPath);    }    return true;}
trimProcQuotas
private static boolean zookeeper_f939_0(ZooKeeper zk, String path) throws KeeperException, IOException, InterruptedException
{    if (Quotas.quotaZookeeper.equals(path)) {        return true;    }    List<String> children = zk.getChildren(path, false);    if (children.size() == 0) {        zk.delete(path, -1);        String parent = path.substring(0, path.lastIndexOf('/'));        return trimProcQuotas(zk, parent);    } else {        return true;    }}
parse
public CliCommand zookeeper_f940_0(String[] cmdArgs) throws CliParseException
{    Parser parser = new PosixParser();    try {        cl = parser.parse(options, cmdArgs);    } catch (ParseException ex) {        throw new CliParseException(ex);    }    args = cl.getArgs();    if (args.length < 2) {        throw new CliParseException(getUsageStr());    }    return this;}
exec
public boolean zookeeper_f941_0() throws CliException
{    String path = args[1];    Stat stat = new Stat();    List<ACL> acl;    try {        acl = zk.getACL(path, stat);    } catch (IllegalArgumentException ex) {        throw new MalformedPathException(ex.getMessage());    } catch (KeeperException | InterruptedException ex) {        throw new CliWrapperException(ex);    }    for (ACL a : acl) {        out.println(a.getId() + ": " + getPermString(a.getPerms()));    }    if (cl.hasOption("s")) {        new StatPrinter(out).print(stat);    }    return false;}
getPermString
private static String zookeeper_f942_0(int perms)
{    StringBuilder p = new StringBuilder();    if ((perms & ZooDefs.Perms.CREATE) != 0) {        p.append('c');    }    if ((perms & ZooDefs.Perms.DELETE) != 0) {        p.append('d');    }    if ((perms & ZooDefs.Perms.READ) != 0) {        p.append('r');    }    if ((perms & ZooDefs.Perms.WRITE) != 0) {        p.append('w');    }    if ((perms & ZooDefs.Perms.ADMIN) != 0) {        p.append('a');    }    return p.toString();}
parse
public CliCommand zookeeper_f943_0(String[] cmdArgs) throws CliParseException
{    Parser parser = new PosixParser();    CommandLine cl;    try {        cl = parser.parse(options, cmdArgs);    } catch (ParseException ex) {        throw new CliParseException(ex);    }    args = cl.getArgs();    return this;}
exec
public boolean zookeeper_f944_0() throws CliException
{    if (args.length < 2) {        throw new MalformedCommandException(getUsageStr());    }    try {        String path = args[1];        int allChildrenNumber = zk.getAllChildrenNumber(path);        out.println(allChildrenNumber);    } catch (IllegalArgumentException ex) {        throw new MalformedPathException(ex.getMessage());    } catch (KeeperException | InterruptedException ex) {        throw new CliWrapperException(ex);    }    return false;}
parse
public CliCommand zookeeper_f945_0(String[] cmdArgs) throws CliParseException
{    Parser parser = new PosixParser();    try {        cl = parser.parse(options, cmdArgs);    } catch (ParseException ex) {        throw new CliParseException(ex);    }    args = cl.getArgs();    if (args.length < 2) {        throw new CliParseException(getUsageStr());    }    retainCompatibility(cmdArgs);    return this;}
retainCompatibility
private void zookeeper_f946_0(String[] cmdArgs) throws CliParseException
{        if (args.length > 2) {                cmdArgs[2] = "-w";        err.println("'get path [watch]' has been deprecated. " + "Please use 'get [-s] [-w] path' instead.");        Parser parser = new PosixParser();        try {            cl = parser.parse(options, cmdArgs);        } catch (ParseException ex) {            throw new CliParseException(ex);        }        args = cl.getArgs();    }}
exec
public boolean zookeeper_f947_0() throws CliException
{    boolean watch = cl.hasOption("w");    String path = args[1];    Stat stat = new Stat();    byte[] data;    try {        data = zk.getData(path, watch, stat);    } catch (IllegalArgumentException ex) {        throw new MalformedPathException(ex.getMessage());    } catch (KeeperException | InterruptedException ex) {        throw new CliException(ex);    }    data = (data == null) ? "null".getBytes() : data;    out.println(new String(data));    if (cl.hasOption("s")) {        new StatPrinter(out).print(stat);    }    return watch;}
parse
public CliCommand zookeeper_f948_0(String[] cmdArgs) throws CliParseException
{    Parser parser = new PosixParser();    try {        cl = parser.parse(options, cmdArgs);    } catch (ParseException ex) {        throw new CliParseException(ex);    }    args = cl.getArgs();    if (args.length < 1) {        throw new CliParseException(getUsageStr());    }    return this;}
exec
public boolean zookeeper_f949_0() throws CliException
{    boolean watch = cl.hasOption("w");    Stat stat = new Stat();    byte[] data;    try {        data = zk.getConfig(watch, stat);    } catch (KeeperException | InterruptedException ex) {        throw new CliWrapperException(ex);    }    data = (data == null) ? "null".getBytes() : data;    if (cl.hasOption("c")) {        out.println(ConfigUtils.getClientConfigStr(new String(data)));    } else {        out.println(new String(data));    }    if (cl.hasOption("s")) {        new StatPrinter(out).print(stat);    }    return watch;}
parse
public CliCommand zookeeper_f950_0(String[] cmdArgs) throws CliParseException
{    Parser parser = new PosixParser();    CommandLine cl;    try {        cl = parser.parse(options, cmdArgs);    } catch (ParseException ex) {        throw new CliParseException(ex);    }    args = cl.getArgs();    return this;}
exec
public boolean zookeeper_f951_0() throws CliException
{    String path;    List<String> ephemerals;    try {        if (args.length < 2) {                        ephemerals = zk.getEphemerals();        } else {            path = args[1];            ephemerals = zk.getEphemerals(path);        }    } catch (IllegalArgumentException ex) {        throw new MalformedPathException(ex.getMessage());    } catch (KeeperException | InterruptedException ex) {        throw new CliWrapperException(ex);    }    out.println(ephemerals);    return false;}
parse
public CliCommand zookeeper_f952_0(String[] cmdArgs) throws CliParseException
{    Parser parser = new PosixParser();    CommandLine cl;    try {        cl = parser.parse(options, cmdArgs);    } catch (ParseException ex) {        throw new CliParseException(ex);    }    args = cl.getArgs();    if (args.length < 2) {        throw new CliParseException(getUsageStr());    }    return this;}
exec
public boolean zookeeper_f953_0() throws CliException
{    String path = args[1];    String absolutePath = Quotas.quotaZookeeper + path + "/" + Quotas.limitNode;    try {        err.println("absolute path is " + absolutePath);        Stat stat = new Stat();        byte[] data = zk.getData(absolutePath, false, stat);        StatsTrack st = new StatsTrack(new String(data));        out.println("Output quota for " + path + " " + st.toString());        data = zk.getData(Quotas.quotaZookeeper + path + "/" + Quotas.statNode, false, stat);        out.println("Output stat for " + path + " " + new StatsTrack(new String(data)).toString());    } catch (IllegalArgumentException ex) {        throw new MalformedPathException(ex.getMessage());    } catch (KeeperException.NoNodeException ne) {        err.println("quota for " + path + " does not exist.");    } catch (KeeperException | InterruptedException ex) {        throw new CliWrapperException(ex);    }    return false;}
parse
public CliCommand zookeeper_f954_0(String[] cmdArgs) throws CliParseException
{    Parser parser = new PosixParser();    CommandLine cl;    try {        cl = parser.parse(options, cmdArgs);    } catch (ParseException ex) {        throw new CliParseException(ex);    }    args = cl.getArgs();    if (args.length < 2) {        throw new CliParseException(getUsageStr());    }    return this;}
exec
public boolean zookeeper_f955_0() throws CliException
{    err.println("'ls2' has been deprecated. " + "Please use 'ls [-s] path' instead.");    String path = args[1];    boolean watch = args.length > 2;    Stat stat = new Stat();    List<String> children;    try {        children = zk.getChildren(path, watch, stat);    } catch (IllegalArgumentException ex) {        throw new MalformedPathException(ex.getMessage());    } catch (KeeperException | InterruptedException ex) {        throw new CliWrapperException(ex);    }    out.println(children);    new StatPrinter(out).print(stat);    return watch;}
printHelp
private void zookeeper_f956_0()
{    HelpFormatter formatter = new HelpFormatter();    formatter.printHelp("ls [options] path", options);}
parse
public CliCommand zookeeper_f957_0(String[] cmdArgs) throws CliParseException
{    Parser parser = new PosixParser();    try {        cl = parser.parse(options, cmdArgs);    } catch (ParseException ex) {        throw new CliParseException(ex);    }    args = cl.getArgs();    if (cl.hasOption("?")) {        printHelp();    }    retainCompatibility(cmdArgs);    return this;}
retainCompatibility
private void zookeeper_f958_0(String[] cmdArgs) throws CliParseException
{        if (args.length > 2) {                cmdArgs[2] = "-w";        err.println("'ls path [watch]' has been deprecated. " + "Please use 'ls [-w] path' instead.");        Parser parser = new PosixParser();        try {            cl = parser.parse(options, cmdArgs);        } catch (ParseException ex) {            throw new CliParseException(ex);        }        args = cl.getArgs();    }}
exec
public boolean zookeeper_f959_0() throws CliException
{    if (args.length < 2) {        throw new MalformedCommandException(getUsageStr());    }    String path = args[1];    boolean watch = cl.hasOption("w");    boolean withStat = cl.hasOption("s");    boolean recursive = cl.hasOption("R");    try {        if (recursive) {            ZKUtil.visitSubTreeDFS(zk, path, watch, new StringCallback() {                @Override                public void processResult(int rc, String path, Object ctx, String name) {                    out.println(path);                }            });        } else {            Stat stat = withStat ? new Stat() : null;            List<String> children = zk.getChildren(path, watch, stat);            printChildren(children, stat);        }    } catch (IllegalArgumentException ex) {        throw new MalformedPathException(ex.getMessage());    } catch (KeeperException | InterruptedException ex) {        throw new CliWrapperException(ex);    }    return watch;}
processResult
public void zookeeper_f960_0(int rc, String path, Object ctx, String name)
{    out.println(path);}
printChildren
private void zookeeper_f961_0(List<String> children, Stat stat)
{    Collections.sort(children);    out.append("[");    boolean first = true;    for (String child : children) {        if (!first) {            out.append(", ");        } else {            first = false;        }        out.append(child);    }    out.append("]");    if (stat != null) {        new StatPrinter(out).print(stat);    }    out.append("\n");}
parse
public CliCommand zookeeper_f962_0(String[] cmdArgs) throws CliParseException
{    joining = null;    leaving = null;    members = null;    Parser parser = new PosixParser();    try {        cl = parser.parse(options, cmdArgs);    } catch (ParseException ex) {        throw new CliParseException(ex);    }    if (!(cl.hasOption("file") || cl.hasOption("members")) && !cl.hasOption("add") && !cl.hasOption("remove")) {        throw new CliParseException(getUsageStr());    }    if (cl.hasOption("v")) {        try {            version = Long.parseLong(cl.getOptionValue("v"), 16);        } catch (NumberFormatException e) {            throw new CliParseException("-v must be followed by a long (configuration version)");        }    } else {        version = -1;    }        if ((cl.hasOption("file") || cl.hasOption("members")) && (cl.hasOption("add") || cl.hasOption("remove"))) {        throw new CliParseException("Can't use -file or -members together with -add or -remove (mixing incremental" + " and non-incremental modes is not allowed)");    }    if (cl.hasOption("file") && cl.hasOption("members")) {        throw new CliParseException("Can't use -file and -members together (conflicting non-incremental modes)");    }        if (cl.hasOption("add")) {        joining = cl.getOptionValue("add").toLowerCase();    }    if (cl.hasOption("remove")) {        leaving = cl.getOptionValue("remove").toLowerCase();    }    if (cl.hasOption("members")) {        members = cl.getOptionValue("members").toLowerCase();    }    if (cl.hasOption("file")) {        try {            Properties dynamicCfg = new Properties();            try (FileInputStream inConfig = new FileInputStream(cl.getOptionValue("file"))) {                dynamicCfg.load(inConfig);            }                                                members = QuorumPeerConfig.parseDynamicConfig(dynamicCfg, 0, true, false).toString();        } catch (Exception e) {            throw new CliParseException("Error processing " + cl.getOptionValue("file") + e.getMessage());        }    }    return this;}
exec
public boolean zookeeper_f963_0() throws CliException
{    try {        Stat stat = new Stat();        if (!(zk instanceof ZooKeeperAdmin)) {                        return false;        }        byte[] curConfig = ((ZooKeeperAdmin) zk).reconfigure(joining, leaving, members, version, stat);        out.println("Committed new configuration:\n" + new String(curConfig));        if (cl.hasOption("s")) {            new StatPrinter(out).print(stat);        }    } catch (KeeperException | InterruptedException ex) {        throw new CliWrapperException(ex);    }    return false;}
parse
public CliCommand zookeeper_f964_0(String[] cmdArgs) throws CliParseException
{    Parser parser = new PosixParser();    try {        cl = parser.parse(options, cmdArgs);    } catch (ParseException ex) {        throw new CliParseException(ex);    }    args = cl.getArgs();    if (args.length < 2) {        throw new CliParseException(getUsageStr());    }    return this;}
exec
public boolean zookeeper_f965_0() throws CliWrapperException, MalformedPathException
{    String path = args[1];    WatcherType wtype = WatcherType.Any;        if (cl.hasOption("c")) {        wtype = WatcherType.Children;    } else if (cl.hasOption("d")) {        wtype = WatcherType.Data;    } else if (cl.hasOption("a")) {        wtype = WatcherType.Any;    }        boolean local = cl.hasOption("l");    try {        zk.removeAllWatches(path, wtype, local);    } catch (IllegalArgumentException ex) {        throw new MalformedPathException(ex.getMessage());    } catch (KeeperException | InterruptedException ex) {        throw new CliWrapperException(ex);    }    return true;}
parse
public CliCommand zookeeper_f966_0(String[] cmdArgs) throws CliParseException
{    Parser parser = new PosixParser();    try {        cl = parser.parse(options, cmdArgs);    } catch (ParseException ex) {        throw new CliParseException(ex);    }    args = cl.getArgs();    if (args.length < 3) {        throw new CliParseException(getUsageStr());    }    return this;}
exec
public boolean zookeeper_f967_0() throws CliException
{    String path = args[1];    String aclStr = args[2];    List<ACL> acl = AclParser.parse(aclStr);    int version;    if (cl.hasOption("v")) {        version = Integer.parseInt(cl.getOptionValue("v"));    } else {        version = -1;    }    try {        if (cl.hasOption("R")) {            ZKUtil.visitSubTreeDFS(zk, path, false, new StringCallback() {                @Override                public void processResult(int rc, String p, Object ctx, String name) {                    try {                        zk.setACL(p, acl, version);                    } catch (KeeperException | InterruptedException e) {                        out.print(e.getMessage());                    }                }            });        } else {            Stat stat = zk.setACL(path, acl, version);            if (cl.hasOption("s")) {                new StatPrinter(out).print(stat);            }        }    } catch (IllegalArgumentException ex) {        throw new MalformedPathException(ex.getMessage());    } catch (KeeperException | InterruptedException ex) {        throw new CliWrapperException(ex);    }    return false;}
processResult
public void zookeeper_f968_0(int rc, String p, Object ctx, String name)
{    try {        zk.setACL(p, acl, version);    } catch (KeeperException | InterruptedException e) {        out.print(e.getMessage());    }}
parse
public CliCommand zookeeper_f969_0(String[] cmdArgs) throws CliParseException
{    Parser parser = new PosixParser();    try {        cl = parser.parse(options, cmdArgs);    } catch (ParseException ex) {        throw new CliParseException(ex);    }    args = cl.getArgs();    if (args.length < 3) {        throw new CliParseException(getUsageStr());    }    return this;}
exec
public boolean zookeeper_f970_0() throws CliException
{    String path = args[1];    byte[] data = args[2].getBytes();    int version;    if (cl.hasOption("v")) {        version = Integer.parseInt(cl.getOptionValue("v"));    } else {        version = -1;    }    try {        Stat stat = zk.setData(path, data, version);        if (cl.hasOption("s")) {            new StatPrinter(out).print(stat);        }    } catch (IllegalArgumentException ex) {        throw new MalformedPathException(ex.getMessage());    } catch (KeeperException | InterruptedException ex) {        throw new CliWrapperException(ex);    }    return false;}
parse
public CliCommand zookeeper_f971_0(String[] cmdArgs) throws CliParseException
{    Parser parser = new PosixParser();    try {        cl = parser.parse(options, cmdArgs);    } catch (ParseException ex) {        throw new CliParseException(ex);    }    args = cl.getArgs();    if (args.length < 2) {        throw new CliParseException(getUsageStr());    }    return this;}
exec
public boolean zookeeper_f972_0() throws CliException
{        String path = args[1];    if (path.startsWith(Quotas.quotaZookeeper)) {        err.println("cannot set a quota under the path: " + Quotas.quotaZookeeper);        return false;    }    if (cl.hasOption("b")) {                long bytes = Long.parseLong(cl.getOptionValue("b"));        try {            createQuota(zk, path, bytes, -1);        } catch (KeeperException | InterruptedException | IllegalArgumentException ex) {            throw new CliWrapperException(ex);        }    } else if (cl.hasOption("n")) {                int numNodes = Integer.parseInt(cl.getOptionValue("n"));        try {            createQuota(zk, path, -1L, numNodes);        } catch (KeeperException | InterruptedException | IllegalArgumentException ex) {            throw new CliWrapperException(ex);        }    } else {        throw new MalformedCommandException(getUsageStr());    }    return false;}
createQuota
public static boolean zookeeper_f973_0(ZooKeeper zk, String path, long bytes, int numNodes) throws KeeperException, InterruptedException, IllegalArgumentException, MalformedPathException
{                Stat initStat;    try {        initStat = zk.exists(path, false);    } catch (IllegalArgumentException ex) {        throw new MalformedPathException(ex.getMessage());    }    if (initStat == null) {        throw new IllegalArgumentException(path + " does not exist.");    }            String quotaPath = Quotas.quotaZookeeper;                            checkIfChildQuota(zk, path);        checkIfParentQuota(zk, path);        if (zk.exists(quotaPath, false) == null) {        try {            zk.create(Quotas.procZookeeper, null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);            zk.create(Quotas.quotaZookeeper, null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        } catch (KeeperException.NodeExistsException ne) {                }    }            String[] splits = path.split("/");    StringBuilder sb = new StringBuilder();    sb.append(quotaPath);    for (int i = 1; i < splits.length; i++) {        sb.append("/").append(splits[i]);        quotaPath = sb.toString();        try {            zk.create(quotaPath, null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        } catch (KeeperException.NodeExistsException ne) {                }    }    String statPath = quotaPath + "/" + Quotas.statNode;    quotaPath = quotaPath + "/" + Quotas.limitNode;    StatsTrack strack = new StatsTrack(null);    strack.setBytes(bytes);    strack.setCount(numNodes);    try {        zk.create(quotaPath, strack.toString().getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        StatsTrack stats = new StatsTrack(null);        stats.setBytes(0L);        stats.setCount(0);        zk.create(statPath, stats.toString().getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    } catch (KeeperException.NodeExistsException ne) {        byte[] data = zk.getData(quotaPath, false, new Stat());        StatsTrack strackC = new StatsTrack(new String(data));        if (bytes != -1L) {            strackC.setBytes(bytes);        }        if (numNodes != -1) {            strackC.setCount(numNodes);        }        zk.setData(quotaPath, strackC.toString().getBytes(), -1);    }    return true;}
checkIfChildQuota
private static voidf974_1ZooKeeper zk, String path) throws KeeperException, InterruptedException
{    String realPath = Quotas.quotaZookeeper + path;    try {        ZKUtil.visitSubTreeDFS(zk, realPath, false, new AsyncCallback.StringCallback() {            @Override            public void processResult(int rc, String quotaPath, Object ctx, String name) {                List<String> children = new ArrayList<>();                try {                    children = zk.getChildren(quotaPath, false);                } catch (KeeperException.NoNodeException ne) {                                        return;                } catch (InterruptedException | KeeperException e) {                    e.printStackTrace();                }                if (children.size() == 0) {                    return;                }                for (String child : children) {                    if (!quotaPath.equals(Quotas.quotaZookeeper + path) && Quotas.limitNode.equals(child)) {                        throw new IllegalArgumentException(path + " has a child " + quotaPath.substring(Quotas.quotaZookeeper.length()) + " which has a quota");                    }                }            }        });    } catch (KeeperException.NoNodeException ne) {        }}
processResult
public voidf975_1int rc, String quotaPath, Object ctx, String name)
{    List<String> children = new ArrayList<>();    try {        children = zk.getChildren(quotaPath, false);    } catch (KeeperException.NoNodeException ne) {                return;    } catch (InterruptedException | KeeperException e) {        e.printStackTrace();    }    if (children.size() == 0) {        return;    }    for (String child : children) {        if (!quotaPath.equals(Quotas.quotaZookeeper + path) && Quotas.limitNode.equals(child)) {            throw new IllegalArgumentException(path + " has a child " + quotaPath.substring(Quotas.quotaZookeeper.length()) + " which has a quota");        }    }}
checkIfParentQuota
private static voidf976_1ZooKeeper zk, String path) throws InterruptedException, KeeperException
{    final String[] splits = path.split("/");    String quotaPath = Quotas.quotaZookeeper;    for (String str : splits) {        if (str.length() == 0) {                        continue;        }        quotaPath += "/" + str;        List<String> children = null;        try {            children = zk.getChildren(quotaPath, false);        } catch (KeeperException.NoNodeException ne) {                        return;        }        if (children.size() == 0) {            return;        }        for (String child : children) {            if (!quotaPath.equals(Quotas.quotaZookeeper + path) && Quotas.limitNode.equals(child)) {                throw new IllegalArgumentException(path + " has a parent " + quotaPath.substring(Quotas.quotaZookeeper.length()) + " which has a quota");            }        }    }}
parse
public CliCommand zookeeper_f977_0(String[] cmdArgs) throws CliParseException
{    Parser parser = new PosixParser();    try {        cl = parser.parse(options, cmdArgs);    } catch (ParseException ex) {        throw new CliParseException(ex);    }    args = cl.getArgs();    if (args.length < 2) {        throw new CliParseException(getUsageStr());    }    retainCompatibility(cmdArgs);    return this;}
retainCompatibility
private void zookeeper_f978_0(String[] cmdArgs) throws CliParseException
{        if (args.length > 2) {                cmdArgs[2] = "-w";        err.println("'stat path [watch]' has been deprecated. " + "Please use 'stat [-w] path' instead.");        Parser parser = new PosixParser();        try {            cl = parser.parse(options, cmdArgs);        } catch (ParseException ex) {            throw new CliParseException(ex);        }        args = cl.getArgs();    }}
exec
public boolean zookeeper_f979_0() throws CliException
{    String path = args[1];    boolean watch = cl.hasOption("w");    Stat stat;    try {        stat = zk.exists(path, watch);    } catch (IllegalArgumentException ex) {        throw new MalformedPathException(ex.getMessage());    } catch (KeeperException | InterruptedException ex) {        throw new CliWrapperException(ex);    }    if (stat == null) {        throw new CliWrapperException(new KeeperException.NoNodeException(path));    }    new StatPrinter(out).print(stat);    return watch;}
print
public void zookeeper_f980_0(Stat stat)
{    out.println("cZxid = 0x" + Long.toHexString(stat.getCzxid()));    out.println("ctime = " + new Date(stat.getCtime()).toString());    out.println("mZxid = 0x" + Long.toHexString(stat.getMzxid()));    out.println("mtime = " + new Date(stat.getMtime()).toString());    out.println("pZxid = 0x" + Long.toHexString(stat.getPzxid()));    out.println("cversion = " + stat.getCversion());    out.println("dataVersion = " + stat.getVersion());    out.println("aclVersion = " + stat.getAversion());    out.println("ephemeralOwner = 0x" + Long.toHexString(stat.getEphemeralOwner()));    out.println("dataLength = " + stat.getDataLength());    out.println("numChildren = " + stat.getNumChildren());}
parse
public CliCommand zookeeper_f981_0(String[] cmdArgs) throws CliParseException
{    Parser parser = new PosixParser();    CommandLine cl;    try {        cl = parser.parse(options, cmdArgs);    } catch (ParseException ex) {        throw new CliParseException(ex);    }    args = cl.getArgs();    if (args.length < 2) {        throw new CliParseException(getUsageStr());    }    return this;}
exec
public boolean zookeeper_f982_0() throws CliException
{    String path = args[1];    CompletableFuture<Integer> cf = new CompletableFuture<>();    try {        zk.sync(path, new AsyncCallback.VoidCallback() {            public void processResult(int rc, String path, Object ctx) {                cf.complete(rc);            }        }, null);        int resultCode = cf.get(SYNC_TIMEOUT, TimeUnit.MILLISECONDS);        if (resultCode == 0) {            out.println("Sync is OK");        } else {            out.println("Sync has failed. rc=" + resultCode);        }    } catch (IllegalArgumentException ex) {        throw new MalformedPathException(ex.getMessage());    } catch (InterruptedException ie) {        Thread.currentThread().interrupt();        throw new CliWrapperException(ie);    } catch (TimeoutException | ExecutionException ex) {        throw new CliWrapperException(ex);    }    return false;}
processResult
public void zookeeper_f983_0(int rc, String path, Object ctx)
{    cf.complete(rc);}
parse
public CliCommand zookeeper_f984_0(String[] cmdArgs) throws CliParseException
{    Parser parser = new PosixParser();    CommandLine cl;    try {        cl = parser.parse(options, cmdArgs);    } catch (ParseException ex) {        throw new CliParseException(ex);    }    args = cl.getArgs();    if (args.length > 1) {        throw new CliParseException(getUsageStr());    }    return this;}
exec
public boolean zookeeper_f985_0() throws CliException
{    out.println("ZooKeeper CLI version: " + Version.getFullVersion());    return false;}
getChrootPath
public String zookeeper_f986_0()
{    return chrootPath;}
getServerAddresses
public ArrayList<InetSocketAddress> zookeeper_f987_0()
{    return serverAddresses;}
send4LetterWord
public static String zookeeper_f988_0(String host, int port, String cmd) throws IOException, SSLContextException
{    return send4LetterWord(host, port, cmd, false, DEFAULT_SOCKET_TIMEOUT);}
send4LetterWord
public static String zookeeper_f989_0(String host, int port, String cmd, boolean secure) throws IOException, SSLContextException
{    return send4LetterWord(host, port, cmd, secure, DEFAULT_SOCKET_TIMEOUT);}
send4LetterWord
public static Stringf990_1String host, int port, String cmd, boolean secure, int timeout) throws IOException, SSLContextException
{        Socket sock;    InetSocketAddress hostaddress = host != null ? new InetSocketAddress(host, port) : new InetSocketAddress(InetAddress.getByName(null), port);    if (secure) {                try (X509Util x509Util = new ClientX509Util()) {            SSLContext sslContext = x509Util.getDefaultSSLContext();            SSLSocketFactory socketFactory = sslContext.getSocketFactory();            SSLSocket sslSock = (SSLSocket) socketFactory.createSocket();            sslSock.connect(hostaddress, timeout);            sslSock.startHandshake();            sock = sslSock;        }    } else {        sock = new Socket();        sock.connect(hostaddress, timeout);    }    sock.setSoTimeout(timeout);    BufferedReader reader = null;    try {        OutputStream outstream = sock.getOutputStream();        outstream.write(cmd.getBytes());        outstream.flush();                if (!secure) {                        sock.shutdownOutput();        }        reader = new BufferedReader(new InputStreamReader(sock.getInputStream()));        StringBuilder sb = new StringBuilder();        String line;        while ((line = reader.readLine()) != null) {            sb.append(line).append("\n");        }        return sb.toString();    } catch (SocketTimeoutException e) {        throw new IOException("Exception while executing four letter word: " + cmd, e);    } finally {        sock.close();        if (reader != null) {            reader.close();        }    }}
main
public static void zookeeper_f991_0(String[] args) throws IOException, SSLContextException
{    if (args.length == 3) {        System.out.println(send4LetterWord(args[0], Integer.parseInt(args[1]), args[2]));    } else if (args.length == 4) {        System.out.println(send4LetterWord(args[0], Integer.parseInt(args[1]), args[2], Boolean.parseBoolean(args[3])));    } else {        System.out.println("Usage: FourLetterWordMain <host> <port> <cmd> <secure(optional)>");    }}
getAllByName
public InetAddress[] zookeeper_f992_0(String name) throws UnknownHostException
{    return InetAddress.getAllByName(name);}
getAllByName
public InetAddress[] zookeeper_f993_0(String name) throws UnknownHostException
{    return InetAddress.getAllByName(name);}
init
private void zookeeper_f994_0(Collection<InetSocketAddress> serverAddresses, long randomnessSeed, Resolver resolver)
{    this.sourceOfRandomness = new Random(randomnessSeed);    this.resolver = resolver;    if (serverAddresses.isEmpty()) {        throw new IllegalArgumentException("A HostProvider may not be empty!");    }    this.serverAddresses = shuffle(serverAddresses);    currentIndex = -1;    lastIndex = -1;}
resolve
private InetSocketAddressf995_1InetSocketAddress address)
{    try {        String curHostString = address.getHostString();        List<InetAddress> resolvedAddresses = new ArrayList<>(Arrays.asList(this.resolver.getAllByName(curHostString)));        if (resolvedAddresses.isEmpty()) {            return address;        }        Collections.shuffle(resolvedAddresses);        return new InetSocketAddress(resolvedAddresses.get(0), address.getPort());    } catch (UnknownHostException e) {                return address;    }}
shuffle
private List<InetSocketAddress> zookeeper_f996_0(Collection<InetSocketAddress> serverAddresses)
{    List<InetSocketAddress> tmpList = new ArrayList<>(serverAddresses.size());    tmpList.addAll(serverAddresses);    Collections.shuffle(tmpList, sourceOfRandomness);    return tmpList;}
updateServerList
public synchronized boolean zookeeper_f997_0(Collection<InetSocketAddress> serverAddresses, InetSocketAddress currentHost)
{    List<InetSocketAddress> shuffledList = shuffle(serverAddresses);    if (shuffledList.isEmpty()) {        throw new IllegalArgumentException("A HostProvider may not be empty!");    }        boolean myServerInNewConfig = false;    InetSocketAddress myServer = currentHost;        if (reconfigMode) {        myServer = next(0);    }        if (myServer == null) {                if (lastIndex >= 0) {                        myServer = this.serverAddresses.get(lastIndex);        } else {                        myServer = this.serverAddresses.get(0);        }    }    for (InetSocketAddress addr : shuffledList) {        if (addr.getPort() == myServer.getPort() && ((addr.getAddress() != null && myServer.getAddress() != null && addr.getAddress().equals(myServer.getAddress())) || addr.getHostString().equals(myServer.getHostString()))) {            myServerInNewConfig = true;            break;        }    }    reconfigMode = true;    newServers.clear();    oldServers.clear();        for (InetSocketAddress address : shuffledList) {        if (this.serverAddresses.contains(address)) {            oldServers.add(address);        } else {            newServers.add(address);        }    }    int numOld = oldServers.size();    int numNew = newServers.size();        if (numOld + numNew > this.serverAddresses.size()) {        if (myServerInNewConfig) {                        if (sourceOfRandomness.nextFloat() <= (1 - ((float) this.serverAddresses.size()) / (numOld + numNew))) {                pNew = 1;                pOld = 0;            } else {                                reconfigMode = false;            }        } else {                                                pNew = 1;            pOld = 0;        }    } else {                if (myServerInNewConfig) {                                    reconfigMode = false;        } else {            pOld = ((float) (numOld * (this.serverAddresses.size() - (numOld + numNew)))) / ((numOld + numNew) * (this.serverAddresses.size() - numOld));            pNew = 1 - pOld;        }    }    if (!reconfigMode) {        currentIndex = shuffledList.indexOf(getServerAtCurrentIndex());    } else {        currentIndex = -1;    }    this.serverAddresses = shuffledList;    currentIndexOld = -1;    currentIndexNew = -1;    lastIndex = currentIndex;    return reconfigMode;}
getServerAtIndex
public synchronized InetSocketAddress zookeeper_f998_0(int i)
{    if (i < 0 || i >= serverAddresses.size()) {        return null;    }    return serverAddresses.get(i);}
getServerAtCurrentIndex
public synchronized InetSocketAddress zookeeper_f999_0()
{    return getServerAtIndex(currentIndex);}
size
public synchronized int zookeeper_f1000_0()
{    return serverAddresses.size();}
nextHostInReconfigMode
private InetSocketAddress zookeeper_f1001_0()
{    boolean takeNew = (sourceOfRandomness.nextFloat() <= pNew);        if (((currentIndexNew + 1) < newServers.size()) && (takeNew || (currentIndexOld + 1) >= oldServers.size())) {        ++currentIndexNew;        return newServers.get(currentIndexNew);    }        if ((currentIndexOld + 1) < oldServers.size()) {        ++currentIndexOld;        return oldServers.get(currentIndexOld);    }    return null;}
next
public InetSocketAddressf1002_1long spinDelay)
{    boolean needToSleep = false;    InetSocketAddress addr;    synchronized (this) {        if (reconfigMode) {            addr = nextHostInReconfigMode();            if (addr != null) {                currentIndex = serverAddresses.indexOf(addr);                return resolve(addr);            }                        reconfigMode = false;            needToSleep = (spinDelay > 0);        }        ++currentIndex;        if (currentIndex == serverAddresses.size()) {            currentIndex = 0;        }        addr = serverAddresses.get(currentIndex);        needToSleep = needToSleep || (currentIndex == lastIndex && spinDelay > 0);        if (lastIndex == -1) {                        lastIndex = 0;        }    }    if (needToSleep) {        try {            Thread.sleep(spinDelay);        } catch (InterruptedException e) {                    }    }    return resolve(addr);}
onConnected
public synchronized void zookeeper_f1003_0()
{    lastIndex = currentIndex;    reconfigMode = false;}
initFromJavaSystemProperties
private void zookeeper_f1004_0()
{    setProperty(ZOOKEEPER_REQUEST_TIMEOUT, System.getProperty(ZOOKEEPER_REQUEST_TIMEOUT));}
handleBackwardCompatibility
protected void zookeeper_f1005_0()
{    /**     * backward compatibility for properties which are common to both client     * and server     */    super.handleBackwardCompatibility();    /**     * backward compatibility for client specific properties     */    setProperty(ZK_SASL_CLIENT_USERNAME, System.getProperty(ZK_SASL_CLIENT_USERNAME));    setProperty(LOGIN_CONTEXT_NAME_KEY, System.getProperty(LOGIN_CONTEXT_NAME_KEY));    setProperty(ENABLE_CLIENT_SASL_KEY, System.getProperty(ENABLE_CLIENT_SASL_KEY));    setProperty(ZOOKEEPER_SERVER_REALM, System.getProperty(ZOOKEEPER_SERVER_REALM));    setProperty(DISABLE_AUTO_WATCH_RESET, System.getProperty(DISABLE_AUTO_WATCH_RESET));    setProperty(ZOOKEEPER_CLIENT_CNXN_SOCKET, System.getProperty(ZOOKEEPER_CLIENT_CNXN_SOCKET));    setProperty(SECURE_CLIENT, System.getProperty(SECURE_CLIENT));}
isSaslClientEnabled
public boolean zookeeper_f1006_0()
{    return Boolean.valueOf(getProperty(ENABLE_CLIENT_SASL_KEY, ENABLE_CLIENT_SASL_DEFAULT));}
getLong
public long zookeeper_f1007_0(String key, long defaultValue)
{    String value = getProperty(key);    if (value != null) {        return Long.parseLong(value.trim());    }    return defaultValue;}
isEnabled
public static boolean zookeeper_f1008_0()
{    return Boolean.parseBoolean(System.getProperty(ZKClientConfig.ENABLE_CLIENT_SASL_KEY, ZKClientConfig.ENABLE_CLIENT_SASL_DEFAULT));}
getSaslState
public SaslState zookeeper_f1009_0()
{    return saslState;}
getLoginContext
public String zookeeper_f1010_0()
{    if (login != null) {        return login.getLoginContextName();    }    return null;}
getConfigStatus
public String zookeeper_f1011_0()
{    return configStatus;}
isComplete
public boolean zookeeper_f1012_0()
{    return (saslState == SaslState.COMPLETE);}
isFailed
public boolean zookeeper_f1013_0()
{    return (saslState == SaslState.FAILED);}
processResult
public voidf1014_1int rc, String path, Object ctx, byte[] data, Stat stat)
{                    ZooKeeperSaslClient client = ((ClientCnxn) ctx).zooKeeperSaslClient;    if (client == null) {                return;    }    byte[] usedata = data;    if (data != null) {            } else {        usedata = new byte[0];            }    client.respondToServer(usedata, (ClientCnxn) ctx);}
createSaslClient
private SaslClientf1015_1final String servicePrincipal, final String loginContext) throws LoginException
{    try {        if (!initializedLogin) {            synchronized (this) {                if (login == null) {                                                                                login = new Login(loginContext, new SaslClientCallbackHandler(null, "Client"), clientConfig);                    login.startThreadIfNeeded();                    initializedLogin = true;                }            }        }        return SecurityUtils.createSaslClient(login.getSubject(), servicePrincipal, "zookeeper", "zk-sasl-md5", LOG, "Client");    } catch (LoginException e) {                throw e;    } catch (Exception e) {                        return null;    }}
createSaslToken
private byte[] zookeeper_f1017_0() throws SaslException
{    saslState = SaslState.INTERMEDIATE;    return createSaslToken(saslToken);}
createSaslToken
private byte[]f1018_1final byte[] saslToken) throws SaslException
{    if (saslToken == null) {                saslState = SaslState.FAILED;        throw new SaslException("Error in authenticating with a Zookeeper Quorum member: the quorum member's saslToken is null.");    }    Subject subject = login.getSubject();    if (subject != null) {        synchronized (login) {            try {                final byte[] retval = Subject.doAs(subject, new PrivilegedExceptionAction<byte[]>() {                    public byte[] run() throws SaslException {                                                return saslClient.evaluateChallenge(saslToken);                    }                });                return retval;            } catch (PrivilegedActionException e) {                String error = "An error: (" + e + ") occurred when evaluating Zookeeper Quorum Member's " + " received SASL token.";                                                final String UNKNOWN_SERVER_ERROR_TEXT = "(Mechanism level: Server not found in Kerberos database (7) - UNKNOWN_SERVER)";                if (e.toString().contains(UNKNOWN_SERVER_ERROR_TEXT)) {                    error += " This may be caused by Java's being unable to resolve the Zookeeper Quorum Member's" + " hostname correctly. You may want to try to adding" + " '-Dsun.net.spi.nameservice.provider.1=dns,sun' to your client's JVMFLAGS environment.";                }                error += " Zookeeper Client will go to AUTH_FAILED state.";                                saslState = SaslState.FAILED;                throw new SaslException(error);            }        }    } else {        throw new SaslException("Cannot make SASL token without subject defined. " + "For diagnosis, please look for WARNs and ERRORs in your log related to the Login class.");    }}
run
public byte[]f1019_1) throws SaslException
{        return saslClient.evaluateChallenge(saslToken);}
sendSaslPacket
private voidf1020_1byte[] saslToken, ClientCnxn cnxn) throws SaslException
{        GetSASLRequest request = new GetSASLRequest();    request.setToken(saslToken);    SetSASLResponse response = new SetSASLResponse();    ServerSaslResponseCallback cb = new ServerSaslResponseCallback();    try {        cnxn.sendPacket(request, response, cb, ZooDefs.OpCode.sasl);    } catch (IOException e) {        throw new SaslException("Failed to send SASL packet to server.", e);    }}
sendSaslPacket
private voidf1021_1ClientCnxn cnxn) throws SaslException
{        GetSASLRequest request = new GetSASLRequest();    request.setToken(createSaslToken());    SetSASLResponse response = new SetSASLResponse();    ServerSaslResponseCallback cb = new ServerSaslResponseCallback();    try {        cnxn.sendPacket(request, response, cb, ZooDefs.OpCode.sasl);    } catch (IOException e) {        throw new SaslException("Failed to send SASL packet to server due " + "to IOException:", e);    }}
getKeeperState
public KeeperState zookeeper_f1022_0()
{    if (saslClient != null) {        if (saslState == SaslState.FAILED) {            return KeeperState.AuthFailed;        }        if (saslClient.isComplete()) {            if (saslState == SaslState.INTERMEDIATE) {                saslState = SaslState.COMPLETE;                return KeeperState.SaslAuthenticated;            }        }    }        return null;}
initialize
public void zookeeper_f1023_0(ClientCnxn cnxn) throws SaslException
{    if (saslClient == null) {        saslState = SaslState.FAILED;        throw new SaslException("saslClient failed to initialize properly: it's null.");    }    if (saslState == SaslState.INITIAL) {        if (saslClient.hasInitialResponse()) {            sendSaslPacket(cnxn);        } else {            byte[] emptyToken = new byte[0];            sendSaslPacket(emptyToken, cnxn);        }        saslState = SaslState.INTERMEDIATE;    }}
clientTunneledAuthenticationInProgress
public booleanf1024_1)
{    if (!isSASLConfigured) {        return false;    }        try {        if ((clientConfig.getJaasConfKey() != null) || ((Configuration.getConfiguration() != null) && (Configuration.getConfiguration().getAppConfigurationEntry(clientConfig.getProperty(ZKClientConfig.LOGIN_CONTEXT_NAME_KEY, ZKClientConfig.LOGIN_CONTEXT_NAME_KEY_DEFAULT)) != null))) {                        if (!isComplete() && !isFailed()) {                return true;            }                        if (!gotLastPacket) {                                return true;            }        }                return false;    } catch (SecurityException e) {                                return false;    }}
shutdown
public void zookeeper_f1025_0()
{    if (null != login) {        login.shutdown();    }}
getSessionId
public long zookeeper_f1026_0()
{    return sessionId;}
getSessionPasswd
public byte[] zookeeper_f1027_0()
{    return sessionPasswd;}
getSessionTimeout
public int zookeeper_f1028_0()
{    return negotiatedSessionTimeout;}
toString
public String zookeeper_f1029_0()
{    StringBuilder sb = new StringBuilder();    SocketAddress local = sendThread.getClientCnxnSocket().getLocalSocketAddress();    SocketAddress remote = sendThread.getClientCnxnSocket().getRemoteSocketAddress();    sb.append("sessionid:0x").append(Long.toHexString(getSessionId())).append(" local:").append(local).append(" remoteserver:").append(remote).append(" lastZxid:").append(lastZxid).append(" xid:").append(xid).append(" sent:").append(sendThread.getClientCnxnSocket().getSentCount()).append(" recv:").append(sendThread.getClientCnxnSocket().getRecvCount()).append(" queuedpkts:").append(outgoingQueue.size()).append(" pendingresp:").append(pendingQueue.size()).append(" queuedevents:").append(eventThread.waitingEvents.size());    return sb.toString();}
createBB
public voidf1030_1)
{    try {        ByteArrayOutputStream baos = new ByteArrayOutputStream();        BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos);                boa.writeInt(-1, "len");        if (requestHeader != null) {            requestHeader.serialize(boa, "header");        }        if (request instanceof ConnectRequest) {            request.serialize(boa, "connect");                        boa.writeBool(readOnly, "readOnly");        } else if (request != null) {            request.serialize(boa, "request");        }        baos.close();        this.bb = ByteBuffer.wrap(baos.toByteArray());        this.bb.putInt(this.bb.capacity() - 4);        this.bb.rewind();    } catch (IOException e) {            }}
toString
public String zookeeper_f1031_0()
{    StringBuilder sb = new StringBuilder();    sb.append("clientPath:" + clientPath);    sb.append(" serverPath:" + serverPath);    sb.append(" finished:" + finished);    sb.append(" header:: " + requestHeader);    sb.append(" replyHeader:: " + replyHeader);    sb.append(" request:: " + request);    sb.append(" response:: " + response);        return sb.toString().replaceAll("\r*\n+", " ");}
start
public void zookeeper_f1032_0()
{    sendThread.start();    eventThread.start();}
makeThreadName
private static String zookeeper_f1033_0(String suffix)
{    String name = Thread.currentThread().getName().replaceAll("-EventThread", "");    return name + suffix;}
queueEvent
public void zookeeper_f1034_0(WatchedEvent event)
{    queueEvent(event, null);}
queueEvent
private void zookeeper_f1035_0(WatchedEvent event, Set<Watcher> materializedWatchers)
{    if (event.getType() == EventType.None && sessionState == event.getState()) {        return;    }    sessionState = event.getState();    final Set<Watcher> watchers;    if (materializedWatchers == null) {                watchers = watcher.materialize(event.getState(), event.getType(), event.getPath());    } else {        watchers = new HashSet<Watcher>();        watchers.addAll(materializedWatchers);    }    WatcherSetEventPair pair = new WatcherSetEventPair(watchers, event);        waitingEvents.add(pair);}
queueCallback
public void zookeeper_f1036_0(AsyncCallback cb, int rc, String path, Object ctx)
{    waitingEvents.add(new LocalCallback(cb, rc, path, ctx));}
queuePacket
public void zookeeper_f1037_0(Packet packet)
{    if (wasKilled) {        synchronized (waitingEvents) {            if (isRunning) {                waitingEvents.add(packet);            } else {                processEvent(packet);            }        }    } else {        waitingEvents.add(packet);    }}
queueEventOfDeath
public void zookeeper_f1038_0()
{    waitingEvents.add(eventOfDeath);}
run
public voidf1039_1)
{    try {        isRunning = true;        while (true) {            Object event = waitingEvents.take();            if (event == eventOfDeath) {                wasKilled = true;            } else {                processEvent(event);            }            if (wasKilled) {                synchronized (waitingEvents) {                    if (waitingEvents.isEmpty()) {                        isRunning = false;                        break;                    }                }            }        }    } catch (InterruptedException e) {            }    }
processEvent
private voidf1040_1Object event)
{    try {        if (event instanceof WatcherSetEventPair) {                        WatcherSetEventPair pair = (WatcherSetEventPair) event;            for (Watcher watcher : pair.watchers) {                try {                    watcher.process(pair.event);                } catch (Throwable t) {                                    }            }        } else if (event instanceof LocalCallback) {            LocalCallback lcb = (LocalCallback) event;            if (lcb.cb instanceof StatCallback) {                ((StatCallback) lcb.cb).processResult(lcb.rc, lcb.path, lcb.ctx, null);            } else if (lcb.cb instanceof DataCallback) {                ((DataCallback) lcb.cb).processResult(lcb.rc, lcb.path, lcb.ctx, null, null);            } else if (lcb.cb instanceof ACLCallback) {                ((ACLCallback) lcb.cb).processResult(lcb.rc, lcb.path, lcb.ctx, null, null);            } else if (lcb.cb instanceof ChildrenCallback) {                ((ChildrenCallback) lcb.cb).processResult(lcb.rc, lcb.path, lcb.ctx, null);            } else if (lcb.cb instanceof Children2Callback) {                ((Children2Callback) lcb.cb).processResult(lcb.rc, lcb.path, lcb.ctx, null, null);            } else if (lcb.cb instanceof StringCallback) {                ((StringCallback) lcb.cb).processResult(lcb.rc, lcb.path, lcb.ctx, null);            } else if (lcb.cb instanceof AsyncCallback.EphemeralsCallback) {                ((AsyncCallback.EphemeralsCallback) lcb.cb).processResult(lcb.rc, lcb.ctx, null);            } else if (lcb.cb instanceof AsyncCallback.AllChildrenNumberCallback) {                ((AsyncCallback.AllChildrenNumberCallback) lcb.cb).processResult(lcb.rc, lcb.path, lcb.ctx, -1);            } else {                ((VoidCallback) lcb.cb).processResult(lcb.rc, lcb.path, lcb.ctx);            }        } else {            Packet p = (Packet) event;            int rc = 0;            String clientPath = p.clientPath;            if (p.replyHeader.getErr() != 0) {                rc = p.replyHeader.getErr();            }            if (p.cb == null) {                            } else if (p.response instanceof ExistsResponse || p.response instanceof SetDataResponse || p.response instanceof SetACLResponse) {                StatCallback cb = (StatCallback) p.cb;                if (rc == 0) {                    if (p.response instanceof ExistsResponse) {                        cb.processResult(rc, clientPath, p.ctx, ((ExistsResponse) p.response).getStat());                    } else if (p.response instanceof SetDataResponse) {                        cb.processResult(rc, clientPath, p.ctx, ((SetDataResponse) p.response).getStat());                    } else if (p.response instanceof SetACLResponse) {                        cb.processResult(rc, clientPath, p.ctx, ((SetACLResponse) p.response).getStat());                    }                } else {                    cb.processResult(rc, clientPath, p.ctx, null);                }            } else if (p.response instanceof GetDataResponse) {                DataCallback cb = (DataCallback) p.cb;                GetDataResponse rsp = (GetDataResponse) p.response;                if (rc == 0) {                    cb.processResult(rc, clientPath, p.ctx, rsp.getData(), rsp.getStat());                } else {                    cb.processResult(rc, clientPath, p.ctx, null, null);                }            } else if (p.response instanceof GetACLResponse) {                ACLCallback cb = (ACLCallback) p.cb;                GetACLResponse rsp = (GetACLResponse) p.response;                if (rc == 0) {                    cb.processResult(rc, clientPath, p.ctx, rsp.getAcl(), rsp.getStat());                } else {                    cb.processResult(rc, clientPath, p.ctx, null, null);                }            } else if (p.response instanceof GetChildrenResponse) {                ChildrenCallback cb = (ChildrenCallback) p.cb;                GetChildrenResponse rsp = (GetChildrenResponse) p.response;                if (rc == 0) {                    cb.processResult(rc, clientPath, p.ctx, rsp.getChildren());                } else {                    cb.processResult(rc, clientPath, p.ctx, null);                }            } else if (p.response instanceof GetAllChildrenNumberResponse) {                AllChildrenNumberCallback cb = (AllChildrenNumberCallback) p.cb;                GetAllChildrenNumberResponse rsp = (GetAllChildrenNumberResponse) p.response;                if (rc == 0) {                    cb.processResult(rc, clientPath, p.ctx, rsp.getTotalNumber());                } else {                    cb.processResult(rc, clientPath, p.ctx, -1);                }            } else if (p.response instanceof GetChildren2Response) {                Children2Callback cb = (Children2Callback) p.cb;                GetChildren2Response rsp = (GetChildren2Response) p.response;                if (rc == 0) {                    cb.processResult(rc, clientPath, p.ctx, rsp.getChildren(), rsp.getStat());                } else {                    cb.processResult(rc, clientPath, p.ctx, null, null);                }            } else if (p.response instanceof CreateResponse) {                StringCallback cb = (StringCallback) p.cb;                CreateResponse rsp = (CreateResponse) p.response;                if (rc == 0) {                    cb.processResult(rc, clientPath, p.ctx, (chrootPath == null ? rsp.getPath() : rsp.getPath().substring(chrootPath.length())));                } else {                    cb.processResult(rc, clientPath, p.ctx, null);                }            } else if (p.response instanceof Create2Response) {                Create2Callback cb = (Create2Callback) p.cb;                Create2Response rsp = (Create2Response) p.response;                if (rc == 0) {                    cb.processResult(rc, clientPath, p.ctx, (chrootPath == null ? rsp.getPath() : rsp.getPath().substring(chrootPath.length())), rsp.getStat());                } else {                    cb.processResult(rc, clientPath, p.ctx, null, null);                }            } else if (p.response instanceof MultiResponse) {                MultiCallback cb = (MultiCallback) p.cb;                MultiResponse rsp = (MultiResponse) p.response;                if (rc == 0) {                    List<OpResult> results = rsp.getResultList();                    int newRc = rc;                    for (OpResult result : results) {                        if (result instanceof ErrorResult && KeeperException.Code.OK.intValue() != (newRc = ((ErrorResult) result).getErr())) {                            break;                        }                    }                    cb.processResult(newRc, clientPath, p.ctx, results);                } else {                    cb.processResult(rc, clientPath, p.ctx, null);                }            } else if (p.response instanceof GetEphemeralsResponse) {                EphemeralsCallback cb = (EphemeralsCallback) p.cb;                GetEphemeralsResponse rsp = (GetEphemeralsResponse) p.response;                if (rc == 0) {                    cb.processResult(rc, p.ctx, rsp.getEphemerals());                } else {                    cb.processResult(rc, p.ctx, null);                }            } else if (p.cb instanceof VoidCallback) {                VoidCallback cb = (VoidCallback) p.cb;                cb.processResult(rc, clientPath, p.ctx);            }        }    } catch (Throwable t) {            }}
finishPacket
protected void zookeeper_f1041_0(Packet p)
{    int err = p.replyHeader.getErr();    if (p.watchRegistration != null) {        p.watchRegistration.register(err);    }        if (p.watchDeregistration != null) {        Map<EventType, Set<Watcher>> materializedWatchers = null;        try {            materializedWatchers = p.watchDeregistration.unregister(err);            for (Entry<EventType, Set<Watcher>> entry : materializedWatchers.entrySet()) {                Set<Watcher> watchers = entry.getValue();                if (watchers.size() > 0) {                    queueEvent(p.watchDeregistration.getClientPath(), err, watchers, entry.getKey());                                                            p.replyHeader.setErr(Code.OK.intValue());                }            }        } catch (KeeperException.NoWatcherException nwe) {            p.replyHeader.setErr(nwe.code().intValue());        } catch (KeeperException ke) {            p.replyHeader.setErr(ke.code().intValue());        }    }    if (p.cb == null) {        synchronized (p) {            p.finished = true;            p.notifyAll();        }    } else {        p.finished = true;        eventThread.queuePacket(p);    }}
queueEvent
 void zookeeper_f1042_0(String clientPath, int err, Set<Watcher> materializedWatchers, EventType eventType)
{    KeeperState sessionState = KeeperState.SyncConnected;    if (KeeperException.Code.SESSIONEXPIRED.intValue() == err || KeeperException.Code.CONNECTIONLOSS.intValue() == err) {        sessionState = Event.KeeperState.Disconnected;    }    WatchedEvent event = new WatchedEvent(eventType, sessionState, clientPath);    eventThread.queueEvent(event, materializedWatchers);}
queueCallback
 void zookeeper_f1043_0(AsyncCallback cb, int rc, String path, Object ctx)
{    eventThread.queueCallback(cb, rc, path, ctx);}
conLossPacket
private void zookeeper_f1044_0(Packet p)
{    if (p.replyHeader == null) {        return;    }    switch(state) {        case AUTH_FAILED:            p.replyHeader.setErr(KeeperException.Code.AUTHFAILED.intValue());            break;        case CLOSED:            p.replyHeader.setErr(KeeperException.Code.SESSIONEXPIRED.intValue());            break;        default:            p.replyHeader.setErr(KeeperException.Code.CONNECTIONLOSS.intValue());    }    finishPacket(p);}
getLastZxid
public long zookeeper_f1045_0()
{    return lastZxid;}
toString
public String zookeeper_f1046_0()
{    return "EndOfStreamException: " + getMessage();}
readResponse
 voidf1047_1ByteBuffer incomingBuffer) throws IOException
{    ByteBufferInputStream bbis = new ByteBufferInputStream(incomingBuffer);    BinaryInputArchive bbia = BinaryInputArchive.getArchive(bbis);    ReplyHeader replyHdr = new ReplyHeader();    replyHdr.deserialize(bbia, "header");    if (replyHdr.getXid() == -2) {                if (LOG.isDebugEnabled()) {                    }        return;    }    if (replyHdr.getXid() == -4) {                if (replyHdr.getErr() == KeeperException.Code.AUTHFAILED.intValue()) {            state = States.AUTH_FAILED;            eventThread.queueEvent(new WatchedEvent(Watcher.Event.EventType.None, Watcher.Event.KeeperState.AuthFailed, null));            eventThread.queueEventOfDeath();        }        if (LOG.isDebugEnabled()) {                    }        return;    }    if (replyHdr.getXid() == -1) {                if (LOG.isDebugEnabled()) {                    }        WatcherEvent event = new WatcherEvent();        event.deserialize(bbia, "response");                if (chrootPath != null) {            String serverPath = event.getPath();            if (serverPath.compareTo(chrootPath) == 0) {                event.setPath("/");            } else if (serverPath.length() > chrootPath.length()) {                event.setPath(serverPath.substring(chrootPath.length()));            } else {                            }        }        WatchedEvent we = new WatchedEvent(event);        if (LOG.isDebugEnabled()) {                    }        eventThread.queueEvent(we);        return;    }        if (tunnelAuthInProgress()) {        GetSASLRequest request = new GetSASLRequest();        request.deserialize(bbia, "token");        zooKeeperSaslClient.respondToServer(request.getToken(), ClientCnxn.this);        return;    }    Packet packet;    synchronized (pendingQueue) {        if (pendingQueue.size() == 0) {            throw new IOException("Nothing in the queue, but got " + replyHdr.getXid());        }        packet = pendingQueue.remove();    }    /*             * Since requests are processed in order, we better get a response             * to the first request!             */    try {        if (packet.requestHeader.getXid() != replyHdr.getXid()) {            packet.replyHeader.setErr(KeeperException.Code.CONNECTIONLOSS.intValue());            throw new IOException("Xid out of order. Got Xid " + replyHdr.getXid() + " with err " + replyHdr.getErr() + " expected Xid " + packet.requestHeader.getXid() + " for a packet with details: " + packet);        }        packet.replyHeader.setXid(replyHdr.getXid());        packet.replyHeader.setErr(replyHdr.getErr());        packet.replyHeader.setZxid(replyHdr.getZxid());        if (replyHdr.getZxid() > 0) {            lastZxid = replyHdr.getZxid();        }        if (packet.response != null && replyHdr.getErr() == 0) {            packet.response.deserialize(bbia, "response");        }        if (LOG.isDebugEnabled()) {                    }    } finally {        finishPacket(packet);    }}
getZkState
 ZooKeeper.States zookeeper_f1048_0()
{    return state;}
getClientCnxnSocket
 ClientCnxnSocket zookeeper_f1049_0()
{    return clientCnxnSocket;}
primeConnection
 voidf1050_1) throws IOException
{        isFirstConnect = false;    long sessId = (seenRwServerBefore) ? sessionId : 0;    ConnectRequest conReq = new ConnectRequest(0, lastZxid, sessionTimeout, sessId, sessionPasswd);        if (!clientConfig.getBoolean(ZKClientConfig.DISABLE_AUTO_WATCH_RESET)) {        List<String> dataWatches = zooKeeper.getDataWatches();        List<String> existWatches = zooKeeper.getExistWatches();        List<String> childWatches = zooKeeper.getChildWatches();        if (!dataWatches.isEmpty() || !existWatches.isEmpty() || !childWatches.isEmpty()) {            Iterator<String> dataWatchesIter = prependChroot(dataWatches).iterator();            Iterator<String> existWatchesIter = prependChroot(existWatches).iterator();            Iterator<String> childWatchesIter = prependChroot(childWatches).iterator();            long setWatchesLastZxid = lastZxid;            while (dataWatchesIter.hasNext() || existWatchesIter.hasNext() || childWatchesIter.hasNext()) {                List<String> dataWatchesBatch = new ArrayList<String>();                List<String> existWatchesBatch = new ArrayList<String>();                List<String> childWatchesBatch = new ArrayList<String>();                int batchLength = 0;                                while (batchLength < SET_WATCHES_MAX_LENGTH) {                    final String watch;                    if (dataWatchesIter.hasNext()) {                        watch = dataWatchesIter.next();                        dataWatchesBatch.add(watch);                    } else if (existWatchesIter.hasNext()) {                        watch = existWatchesIter.next();                        existWatchesBatch.add(watch);                    } else if (childWatchesIter.hasNext()) {                        watch = childWatchesIter.next();                        childWatchesBatch.add(watch);                    } else {                        break;                    }                    batchLength += watch.length();                }                SetWatches sw = new SetWatches(setWatchesLastZxid, dataWatchesBatch, existWatchesBatch, childWatchesBatch);                RequestHeader header = new RequestHeader(-8, OpCode.setWatches);                Packet packet = new Packet(header, new ReplyHeader(), sw, null, null);                outgoingQueue.addFirst(packet);            }        }    }    for (AuthData id : authInfo) {        outgoingQueue.addFirst(new Packet(new RequestHeader(-4, OpCode.auth), null, new AuthPacket(0, id.scheme, id.data), null, null));    }    outgoingQueue.addFirst(new Packet(null, null, conReq, null, null, readOnly));    clientCnxnSocket.connectionPrimed();    }
prependChroot
private List<String> zookeeper_f1051_0(List<String> paths)
{    if (chrootPath != null && !paths.isEmpty()) {        for (int i = 0; i < paths.size(); ++i) {            String clientPath = paths.get(i);            String serverPath;                        if (clientPath.length() == 1) {                serverPath = chrootPath;            } else {                serverPath = chrootPath + clientPath;            }            paths.set(i, serverPath);        }    }    return paths;}
sendPing
private void zookeeper_f1052_0()
{    lastPingSentNs = System.nanoTime();    RequestHeader h = new RequestHeader(-2, OpCode.ping);    queuePacket(h, null, null, null, null, null, null, null, null);}
startConnect
private voidf1053_1InetSocketAddress addr) throws IOException
{        saslLoginFailed = false;    if (!isFirstConnect) {        try {            Thread.sleep(r.nextInt(1000));        } catch (InterruptedException e) {                    }    }    state = States.CONNECTING;    String hostPort = addr.getHostString() + ":" + addr.getPort();    MDC.put("myid", hostPort);    setName(getName().replaceAll("\\(.*\\)", "(" + hostPort + ")"));    if (clientConfig.isSaslClientEnabled()) {        try {            if (zooKeeperSaslClient != null) {                zooKeeperSaslClient.shutdown();            }            zooKeeperSaslClient = new ZooKeeperSaslClient(SaslServerPrincipal.getServerPrincipal(addr, clientConfig), clientConfig);        } catch (LoginException e) {                                                                        eventThread.queueEvent(new WatchedEvent(Watcher.Event.EventType.None, Watcher.Event.KeeperState.AuthFailed, null));            saslLoginFailed = true;        }    }    logStartConnect(addr);    clientCnxnSocket.connect(addr);}
logStartConnect
private voidf1054_1InetSocketAddress addr)
{    String msg = "Opening socket connection to server " + addr;    if (zooKeeperSaslClient != null) {        msg += ". " + zooKeeperSaslClient.getConfigStatus();    }    }
run
public voidf1055_1)
{    clientCnxnSocket.introduce(this, sessionId, outgoingQueue);    clientCnxnSocket.updateNow();    clientCnxnSocket.updateLastSendAndHeard();    int to;    long lastPingRwServer = Time.currentElapsedTime();        final int MAX_SEND_PING_INTERVAL = 10000;    InetSocketAddress serverAddress = null;    while (state.isAlive()) {        try {            if (!clientCnxnSocket.isConnected()) {                                if (closing) {                    break;                }                if (rwServerAddress != null) {                    serverAddress = rwServerAddress;                    rwServerAddress = null;                } else {                    serverAddress = hostProvider.next(1000);                }                startConnect(serverAddress);                clientCnxnSocket.updateLastSendAndHeard();            }            if (state.isConnected()) {                                if (zooKeeperSaslClient != null) {                    boolean sendAuthEvent = false;                    if (zooKeeperSaslClient.getSaslState() == ZooKeeperSaslClient.SaslState.INITIAL) {                        try {                            zooKeeperSaslClient.initialize(ClientCnxn.this);                        } catch (SaslException e) {                                                        state = States.AUTH_FAILED;                            sendAuthEvent = true;                        }                    }                    KeeperState authState = zooKeeperSaslClient.getKeeperState();                    if (authState != null) {                        if (authState == KeeperState.AuthFailed) {                                                        state = States.AUTH_FAILED;                            sendAuthEvent = true;                        } else {                            if (authState == KeeperState.SaslAuthenticated) {                                sendAuthEvent = true;                            }                        }                    }                    if (sendAuthEvent) {                        eventThread.queueEvent(new WatchedEvent(Watcher.Event.EventType.None, authState, null));                        if (state == States.AUTH_FAILED) {                            eventThread.queueEventOfDeath();                        }                    }                }                to = readTimeout - clientCnxnSocket.getIdleRecv();            } else {                to = connectTimeout - clientCnxnSocket.getIdleRecv();            }            if (to <= 0) {                String warnInfo;                warnInfo = "Client session timed out, have not heard from server in " + clientCnxnSocket.getIdleRecv() + "ms" + " for sessionid 0x" + Long.toHexString(sessionId);                                throw new SessionTimeoutException(warnInfo);            }            if (state.isConnected()) {                                                int timeToNextPing = readTimeout / 2 - clientCnxnSocket.getIdleSend() - ((clientCnxnSocket.getIdleSend() > 1000) ? 1000 : 0);                                if (timeToNextPing <= 0 || clientCnxnSocket.getIdleSend() > MAX_SEND_PING_INTERVAL) {                    sendPing();                    clientCnxnSocket.updateLastSend();                } else {                    if (timeToNextPing < to) {                        to = timeToNextPing;                    }                }            }                        if (state == States.CONNECTEDREADONLY) {                long now = Time.currentElapsedTime();                int idlePingRwServer = (int) (now - lastPingRwServer);                if (idlePingRwServer >= pingRwTimeout) {                    lastPingRwServer = now;                    idlePingRwServer = 0;                    pingRwTimeout = Math.min(2 * pingRwTimeout, maxPingRwTimeout);                    pingRwServer();                }                to = Math.min(to, pingRwTimeout - idlePingRwServer);            }            clientCnxnSocket.doTransport(to, pendingQueue, ClientCnxn.this);        } catch (Throwable e) {            if (closing) {                if (LOG.isDebugEnabled()) {                                                        }                break;            } else {                                if (e instanceof SessionExpiredException) {                                    } else if (e instanceof SessionTimeoutException) {                                    } else if (e instanceof EndOfStreamException) {                                    } else if (e instanceof RWServerFoundException) {                                    } else if (e instanceof SocketException) {                                    } else {                                    }                                                cleanAndNotifyState();            }        }    }    synchronized (state) {                        cleanup();    }    clientCnxnSocket.close();    if (state.isAlive()) {        eventThread.queueEvent(new WatchedEvent(Event.EventType.None, Event.KeeperState.Disconnected, null));    }    eventThread.queueEvent(new WatchedEvent(Event.EventType.None, Event.KeeperState.Closed, null));    ZooTrace.logTraceMessage(LOG, ZooTrace.getTextTraceLevel(), "SendThread exited loop for session: 0x" + Long.toHexString(getSessionId()));}
cleanAndNotifyState
private void zookeeper_f1056_0()
{    cleanup();    if (state.isAlive()) {        eventThread.queueEvent(new WatchedEvent(Event.EventType.None, Event.KeeperState.Disconnected, null));    }    clientCnxnSocket.updateNow();    clientCnxnSocket.updateLastSendAndHeard();}
pingRwServer
private voidf1057_1) throws RWServerFoundException
{    String result = null;    InetSocketAddress addr = hostProvider.next(0);        Socket sock = null;    BufferedReader br = null;    try {        sock = new Socket(addr.getHostString(), addr.getPort());        sock.setSoLinger(false, -1);        sock.setSoTimeout(1000);        sock.setTcpNoDelay(true);        sock.getOutputStream().write("isro".getBytes());        sock.getOutputStream().flush();        sock.shutdownOutput();        br = new BufferedReader(new InputStreamReader(sock.getInputStream()));        result = br.readLine();    } catch (ConnectException e) {        } catch (IOException e) {                    } finally {        if (sock != null) {            try {                sock.close();            } catch (IOException e) {                            }        }        if (br != null) {            try {                br.close();            } catch (IOException e) {                            }        }    }    if ("rw".equals(result)) {        pingRwTimeout = minPingRwTimeout;                        rwServerAddress = addr;        throw new RWServerFoundException("Majority server found at " + addr.getHostString() + ":" + addr.getPort());    }}
cleanup
private void zookeeper_f1058_0()
{    clientCnxnSocket.cleanup();    synchronized (pendingQueue) {        for (Packet p : pendingQueue) {            conLossPacket(p);        }        pendingQueue.clear();    }                Iterator<Packet> iter = outgoingQueue.iterator();    while (iter.hasNext()) {        Packet p = iter.next();        conLossPacket(p);        iter.remove();    }}
onConnected
 voidf1059_1int _negotiatedSessionTimeout, long _sessionId, byte[] _sessionPasswd, boolean isRO) throws IOException
{    negotiatedSessionTimeout = _negotiatedSessionTimeout;    if (negotiatedSessionTimeout <= 0) {        state = States.CLOSED;        eventThread.queueEvent(new WatchedEvent(Watcher.Event.EventType.None, Watcher.Event.KeeperState.Expired, null));        eventThread.queueEventOfDeath();        String warnInfo;        warnInfo = "Unable to reconnect to ZooKeeper service, session 0x" + Long.toHexString(sessionId) + " has expired";                throw new SessionExpiredException(warnInfo);    }    if (!readOnly && isRO) {            }    readTimeout = negotiatedSessionTimeout * 2 / 3;    connectTimeout = negotiatedSessionTimeout / hostProvider.size();    hostProvider.onConnected();    sessionId = _sessionId;    sessionPasswd = _sessionPasswd;    state = (isRO) ? States.CONNECTEDREADONLY : States.CONNECTED;    seenRwServerBefore |= !isRO;        KeeperState eventState = (isRO) ? KeeperState.ConnectedReadOnly : KeeperState.SyncConnected;    eventThread.queueEvent(new WatchedEvent(Watcher.Event.EventType.None, eventState, null));}
close
 void zookeeper_f1060_0()
{    state = States.CLOSED;    clientCnxnSocket.onClosing();}
testableCloseSocket
 void zookeeper_f1061_0() throws IOException
{    clientCnxnSocket.testableCloseSocket();}
tunnelAuthInProgress
public boolean zookeeper_f1062_0()
{        if (!clientConfig.isSaslClientEnabled()) {        return false;    }        if (saslLoginFailed) {        return false;    }        if (zooKeeperSaslClient == null) {        return true;    }        return zooKeeperSaslClient.clientTunneledAuthenticationInProgress();}
sendPacket
public void zookeeper_f1063_0(Packet p) throws IOException
{    clientCnxnSocket.sendPacket(p);}
disconnect
public voidf1064_1)
{    if (LOG.isDebugEnabled()) {            }    sendThread.close();    try {        sendThread.join();    } catch (InterruptedException ex) {            }    eventThread.queueEventOfDeath();    if (zooKeeperSaslClient != null) {        zooKeeperSaslClient.shutdown();    }}
close
public voidf1065_1) throws IOException
{    if (LOG.isDebugEnabled()) {            }    try {        RequestHeader h = new RequestHeader();        h.setType(ZooDefs.OpCode.closeSession);        submitRequest(h, null, null, null);    } catch (InterruptedException e) {        } finally {        disconnect();    }}
getXid
public synchronized int zookeeper_f1066_0()
{        if (xid == Integer.MAX_VALUE) {        xid = 1;    }    return xid++;}
submitRequest
public ReplyHeader zookeeper_f1067_0(RequestHeader h, Record request, Record response, WatchRegistration watchRegistration) throws InterruptedException
{    return submitRequest(h, request, response, watchRegistration, null);}
submitRequest
public ReplyHeader zookeeper_f1068_0(RequestHeader h, Record request, Record response, WatchRegistration watchRegistration, WatchDeregistration watchDeregistration) throws InterruptedException
{    ReplyHeader r = new ReplyHeader();    Packet packet = queuePacket(h, r, request, response, null, null, null, null, watchRegistration, watchDeregistration);    synchronized (packet) {        if (requestTimeout > 0) {                        waitForPacketFinish(r, packet);        } else {                        while (!packet.finished) {                packet.wait();            }        }    }    if (r.getErr() == Code.REQUESTTIMEOUT.intValue()) {        sendThread.cleanAndNotifyState();    }    return r;}
waitForPacketFinish
private voidf1069_1ReplyHeader r, Packet packet) throws InterruptedException
{    long waitStartTime = Time.currentElapsedTime();    while (!packet.finished) {        packet.wait(requestTimeout);        if (!packet.finished && ((Time.currentElapsedTime() - waitStartTime) >= requestTimeout)) {                        r.setErr(Code.REQUESTTIMEOUT.intValue());            break;        }    }}
saslCompleted
public void zookeeper_f1070_0()
{    sendThread.getClientCnxnSocket().saslCompleted();}
sendPacket
public void zookeeper_f1071_0(Record request, Record response, AsyncCallback cb, int opCode) throws IOException
{            int xid = getXid();    RequestHeader h = new RequestHeader();    h.setXid(xid);    h.setType(opCode);    ReplyHeader r = new ReplyHeader();    r.setXid(xid);    Packet p = new Packet(h, r, request, response, null, false);    p.cb = cb;    sendThread.sendPacket(p);}
queuePacket
public Packet zookeeper_f1072_0(RequestHeader h, ReplyHeader r, Record request, Record response, AsyncCallback cb, String clientPath, String serverPath, Object ctx, WatchRegistration watchRegistration)
{    return queuePacket(h, r, request, response, cb, clientPath, serverPath, ctx, watchRegistration, null);}
queuePacket
public Packet zookeeper_f1073_0(RequestHeader h, ReplyHeader r, Record request, Record response, AsyncCallback cb, String clientPath, String serverPath, Object ctx, WatchRegistration watchRegistration, WatchDeregistration watchDeregistration)
{    Packet packet = null;                packet = new Packet(h, r, request, response, watchRegistration);    packet.cb = cb;    packet.ctx = ctx;    packet.clientPath = clientPath;    packet.serverPath = serverPath;    packet.watchDeregistration = watchDeregistration;        synchronized (state) {        if (!state.isAlive() || closing) {            conLossPacket(packet);        } else {                        if (h.getType() == OpCode.closeSession) {                closing = true;            }            outgoingQueue.add(packet);        }    }    sendThread.getClientCnxnSocket().packetAdded();    return packet;}
addAuthInfo
public void zookeeper_f1074_0(String scheme, byte[] auth)
{    if (!state.isAlive()) {        return;    }    authInfo.add(new AuthData(scheme, auth));    queuePacket(new RequestHeader(-4, OpCode.auth), null, new AuthPacket(0, scheme, auth), null, null, null, null, null, null);}
getState
 States zookeeper_f1075_0()
{    return state;}
initRequestTimeout
private voidf1076_1)
{    try {        requestTimeout = clientConfig.getLong(ZKClientConfig.ZOOKEEPER_REQUEST_TIMEOUT, ZKClientConfig.ZOOKEEPER_REQUEST_TIMEOUT_DEFAULT);            } catch (NumberFormatException e) {                throw e;    }}
introduce
 void zookeeper_f1077_0(ClientCnxn.SendThread sendThread, long sessionId, LinkedBlockingDeque<Packet> outgoingQueue)
{    this.sendThread = sendThread;    this.sessionId = sessionId;    this.outgoingQueue = outgoingQueue;}
updateNow
 void zookeeper_f1078_0()
{    now = Time.currentElapsedTime();}
getIdleRecv
 int zookeeper_f1079_0()
{    return (int) (now - lastHeard);}
getIdleSend
 int zookeeper_f1080_0()
{    return (int) (now - lastSend);}
getSentCount
 long zookeeper_f1081_0()
{    return sentCount.get();}
getRecvCount
 long zookeeper_f1082_0()
{    return recvCount.get();}
updateLastHeard
 void zookeeper_f1083_0()
{    this.lastHeard = now;}
updateLastSend
 void zookeeper_f1084_0()
{    this.lastSend = now;}
updateLastSendAndHeard
 void zookeeper_f1085_0()
{    this.lastSend = now;    this.lastHeard = now;}
readLength
 void zookeeper_f1086_0() throws IOException
{    int len = incomingBuffer.getInt();    if (len < 0 || len >= packetLen) {        throw new IOException("Packet len " + len + " is out of range!");    }    incomingBuffer = ByteBuffer.allocate(len);}
initProperties
protected voidf1088_1) throws IOException
{    try {        packetLen = clientConfig.getInt(ZKConfig.JUTE_MAXBUFFER, ZKClientConfig.CLIENT_MAX_PACKET_LENGTH_DEFAULT);            } catch (NumberFormatException e) {        String msg = MessageFormat.format("Configured value {0} for property {1} can not be parsed to int", clientConfig.getProperty(ZKConfig.JUTE_MAXBUFFER), ZKConfig.JUTE_MAXBUFFER);                throw new IOException(msg);    }}
isConnected
 boolean zookeeper_f1089_0()
{            connectLock.lock();    try {        return channel != null || connectFuture != null;    } finally {        connectLock.unlock();    }}
configureBootstrapAllocator
private Bootstrap zookeeper_f1090_0(Bootstrap bootstrap)
{    ByteBufAllocator testAllocator = TEST_ALLOCATOR.get();    if (testAllocator != null) {        return bootstrap.option(ChannelOption.ALLOCATOR, testAllocator);    } else {        return bootstrap;    }}
connect
 voidf1091_1InetSocketAddress addr) throws IOException
{    firstConnect = new CountDownLatch(1);    Bootstrap bootstrap = new Bootstrap().group(eventLoopGroup).channel(NettyUtils.nioOrEpollSocketChannel()).option(ChannelOption.SO_LINGER, -1).option(ChannelOption.TCP_NODELAY, true).handler(new ZKClientPipelineFactory(addr.getHostString(), addr.getPort()));    bootstrap = configureBootstrapAllocator(bootstrap);    bootstrap.validate();    connectLock.lock();    try {        connectFuture = bootstrap.connect(addr);        connectFuture.addListener(new ChannelFutureListener() {            @Override            public void operationComplete(ChannelFuture channelFuture) throws Exception {                                boolean connected = false;                connectLock.lock();                try {                    if (!channelFuture.isSuccess()) {                                                return;                    } else if (connectFuture == null) {                                                                                                                        channelFuture.channel().close();                        return;                    }                                        channel = channelFuture.channel();                    disconnected.set(false);                    initialized = false;                    lenBuffer.clear();                    incomingBuffer = lenBuffer;                    sendThread.primeConnection();                    updateNow();                    updateLastSendAndHeard();                    if (sendThread.tunnelAuthInProgress()) {                        waitSasl.drainPermits();                        needSasl.set(true);                        sendPrimePacket();                    } else {                        needSasl.set(false);                    }                    connected = true;                } finally {                    connectFuture = null;                    connectLock.unlock();                    if (connected) {                                            }                                                                                wakeupCnxn();                    firstConnect.countDown();                }            }        });    } finally {        connectLock.unlock();    }}
operationComplete
public voidf1092_1ChannelFuture channelFuture) throws Exception
{        boolean connected = false;    connectLock.lock();    try {        if (!channelFuture.isSuccess()) {                        return;        } else if (connectFuture == null) {                                                            channelFuture.channel().close();            return;        }                channel = channelFuture.channel();        disconnected.set(false);        initialized = false;        lenBuffer.clear();        incomingBuffer = lenBuffer;        sendThread.primeConnection();        updateNow();        updateLastSendAndHeard();        if (sendThread.tunnelAuthInProgress()) {            waitSasl.drainPermits();            needSasl.set(true);            sendPrimePacket();        } else {            needSasl.set(false);        }        connected = true;    } finally {        connectFuture = null;        connectLock.unlock();        if (connected) {                    }                                wakeupCnxn();        firstConnect.countDown();    }}
cleanup
 void zookeeper_f1093_0()
{    connectLock.lock();    try {        if (connectFuture != null) {            connectFuture.cancel(false);            connectFuture = null;        }        if (channel != null) {            channel.close().syncUninterruptibly();            channel = null;        }    } finally {        connectLock.unlock();    }    Iterator<Packet> iter = outgoingQueue.iterator();    while (iter.hasNext()) {        Packet p = iter.next();        if (p == WakeupPacket.getInstance()) {            iter.remove();        }    }}
close
 void zookeeper_f1094_0()
{    eventLoopGroup.shutdownGracefully();}
saslCompleted
 void zookeeper_f1095_0()
{    needSasl.set(false);    waitSasl.release();}
connectionPrimed
 void zookeeper_f1096_0()
{}
packetAdded
 void zookeeper_f1097_0()
{}
onClosing
 voidf1098_1)
{    firstConnect.countDown();    wakeupCnxn();    }
wakeupCnxn
private void zookeeper_f1099_0()
{    if (needSasl.get()) {        waitSasl.release();    }    outgoingQueue.add(WakeupPacket.getInstance());}
doTransport
 void zookeeper_f1100_0(int waitTimeOut, Queue<Packet> pendingQueue, ClientCnxn cnxn) throws IOException, InterruptedException
{    try {        if (!firstConnect.await(waitTimeOut, TimeUnit.MILLISECONDS)) {            return;        }        Packet head = null;        if (needSasl.get()) {            if (!waitSasl.tryAcquire(waitTimeOut, TimeUnit.MILLISECONDS)) {                return;            }        } else {            head = outgoingQueue.poll(waitTimeOut, TimeUnit.MILLISECONDS);        }                if (!sendThread.getZkState().isAlive()) {                        addBack(head);            return;        }                if (disconnected.get()) {            addBack(head);            throw new EndOfStreamException("channel for sessionid 0x" + Long.toHexString(sessionId) + " is lost");        }        if (head != null) {            doWrite(pendingQueue, head, cnxn);        }    } finally {        updateNow();    }}
addBack
private void zookeeper_f1101_0(Packet head)
{    if (head != null && head != WakeupPacket.getInstance()) {        outgoingQueue.addFirst(head);    }}
sendPktAndFlush
private ChannelFuture zookeeper_f1102_0(Packet p)
{    return sendPkt(p, true);}
sendPktOnly
private ChannelFuture zookeeper_f1103_0(Packet p)
{    return sendPkt(p, false);}
sendPkt
private ChannelFuture zookeeper_f1104_0(Packet p, boolean doFlush)
{            p.createBB();    updateLastSend();    final ByteBuf writeBuffer = Unpooled.wrappedBuffer(p.bb);    final ChannelFuture result = doFlush ? channel.writeAndFlush(writeBuffer) : channel.write(writeBuffer);    result.addListener(onSendPktDoneListener);    return result;}
sendPrimePacket
private void zookeeper_f1105_0()
{        sendPktAndFlush(outgoingQueue.remove());}
doWrite
private void zookeeper_f1106_0(Queue<Packet> pendingQueue, Packet p, ClientCnxn cnxn)
{    updateNow();    boolean anyPacketsSent = false;    while (true) {        if (p != WakeupPacket.getInstance()) {            if ((p.requestHeader != null) && (p.requestHeader.getType() != ZooDefs.OpCode.ping) && (p.requestHeader.getType() != ZooDefs.OpCode.auth)) {                p.requestHeader.setXid(cnxn.getXid());                synchronized (pendingQueue) {                    pendingQueue.add(p);                }            }            sendPktOnly(p);            anyPacketsSent = true;        }        if (outgoingQueue.isEmpty()) {            break;        }        p = outgoingQueue.remove();    }        if (anyPacketsSent) {        channel.flush();    }}
sendPacket
 void zookeeper_f1107_0(ClientCnxn.Packet p) throws IOException
{    if (channel == null) {        throw new IOException("channel has been closed");    }    sendPktAndFlush(p);}
getRemoteSocketAddress
 SocketAddress zookeeper_f1108_0()
{    Channel copiedChanRef = channel;    return (copiedChanRef == null) ? null : copiedChanRef.remoteAddress();}
getLocalSocketAddress
 SocketAddress zookeeper_f1109_0()
{    Channel copiedChanRef = channel;    return (copiedChanRef == null) ? null : copiedChanRef.localAddress();}
testableCloseSocket
 void zookeeper_f1110_0() throws IOException
{    Channel copiedChanRef = channel;    if (copiedChanRef != null) {        copiedChanRef.disconnect().awaitUninterruptibly();    }}
getInstance
public static Packet zookeeper_f1111_0()
{    return instance;}
initChannel
protected void zookeeper_f1112_0(SocketChannel ch) throws Exception
{    ChannelPipeline pipeline = ch.pipeline();    if (clientConfig.getBoolean(ZKClientConfig.SECURE_CLIENT)) {        initSSL(pipeline);    }    pipeline.addLast("handler", new ZKClientHandler());}
initSSL
private synchronized voidf1113_1ChannelPipeline pipeline) throws SSLContextException
{    if (sslContext == null || sslEngine == null) {        try (X509Util x509Util = new ClientX509Util()) {            sslContext = x509Util.createSSLContext(clientConfig);            sslEngine = sslContext.createSSLEngine(host, port);            sslEngine.setUseClientMode(true);        }    }    pipeline.addLast("ssl", new SslHandler(sslEngine));    }
channelInactive
public voidf1114_1ChannelHandlerContext ctx) throws Exception
{        cleanup();}
cleanup
private void zookeeper_f1115_0()
{    if (!channelClosed.compareAndSet(false, true)) {        return;    }    disconnected.set(true);    onClosing();}
channelRead0
protected void zookeeper_f1116_0(ChannelHandlerContext ctx, ByteBuf buf) throws Exception
{    updateNow();    while (buf.isReadable()) {        if (incomingBuffer.remaining() > buf.readableBytes()) {            int newLimit = incomingBuffer.position() + buf.readableBytes();            incomingBuffer.limit(newLimit);        }        buf.readBytes(incomingBuffer);        incomingBuffer.limit(incomingBuffer.capacity());        if (!incomingBuffer.hasRemaining()) {            incomingBuffer.flip();            if (incomingBuffer == lenBuffer) {                recvCount.getAndIncrement();                readLength();            } else if (!initialized) {                readConnectResult();                lenBuffer.clear();                incomingBuffer = lenBuffer;                initialized = true;                updateLastHeard();            } else {                sendThread.readResponse(incomingBuffer);                lenBuffer.clear();                incomingBuffer = lenBuffer;                updateLastHeard();            }        }    }    wakeupCnxn();}
exceptionCaught
public voidf1117_1ChannelHandlerContext ctx, Throwable cause)
{        cleanup();}
setTestAllocator
 static void zookeeper_f1118_0(ByteBufAllocator allocator)
{    TEST_ALLOCATOR.set(allocator);}
clearTestAllocator
 static void zookeeper_f1119_0()
{    TEST_ALLOCATOR.set(null);}
isConnected
 boolean zookeeper_f1120_0()
{    return sockKey != null;}
doIO
 void zookeeper_f1121_0(Queue<Packet> pendingQueue, ClientCnxn cnxn) throws InterruptedException, IOException
{    SocketChannel sock = (SocketChannel) sockKey.channel();    if (sock == null) {        throw new IOException("Socket is null!");    }    if (sockKey.isReadable()) {        int rc = sock.read(incomingBuffer);        if (rc < 0) {            throw new EndOfStreamException("Unable to read additional data from server sessionid 0x" + Long.toHexString(sessionId) + ", likely server has closed socket");        }        if (!incomingBuffer.hasRemaining()) {            incomingBuffer.flip();            if (incomingBuffer == lenBuffer) {                recvCount.getAndIncrement();                readLength();            } else if (!initialized) {                readConnectResult();                enableRead();                if (findSendablePacket(outgoingQueue, sendThread.tunnelAuthInProgress()) != null) {                                                            enableWrite();                }                lenBuffer.clear();                incomingBuffer = lenBuffer;                updateLastHeard();                initialized = true;            } else {                sendThread.readResponse(incomingBuffer);                lenBuffer.clear();                incomingBuffer = lenBuffer;                updateLastHeard();            }        }    }    if (sockKey.isWritable()) {        Packet p = findSendablePacket(outgoingQueue, sendThread.tunnelAuthInProgress());        if (p != null) {            updateLastSend();                        if (p.bb == null) {                if ((p.requestHeader != null) && (p.requestHeader.getType() != OpCode.ping) && (p.requestHeader.getType() != OpCode.auth)) {                    p.requestHeader.setXid(cnxn.getXid());                }                p.createBB();            }            sock.write(p.bb);            if (!p.bb.hasRemaining()) {                sentCount.getAndIncrement();                outgoingQueue.removeFirstOccurrence(p);                if (p.requestHeader != null && p.requestHeader.getType() != OpCode.ping && p.requestHeader.getType() != OpCode.auth) {                    synchronized (pendingQueue) {                        pendingQueue.add(p);                    }                }            }        }        if (outgoingQueue.isEmpty()) {                                                                        disableWrite();        } else if (!initialized && p != null && !p.bb.hasRemaining()) {                                                                                                                        disableWrite();        } else {                        enableWrite();        }    }}
findSendablePacket
private Packetf1122_1LinkedBlockingDeque<Packet> outgoingQueue, boolean tunneledAuthInProgres)
{    if (outgoingQueue.isEmpty()) {        return null;    }        if (outgoingQueue.getFirst().bb != null || !tunneledAuthInProgres) {        return outgoingQueue.getFirst();    }                        Iterator<Packet> iter = outgoingQueue.iterator();    while (iter.hasNext()) {        Packet p = iter.next();        if (p.requestHeader == null) {                        iter.remove();            outgoingQueue.addFirst(p);            return p;        } else {                                            }    }    return null;}
cleanup
 voidf1123_1)
{    if (sockKey != null) {        SocketChannel sock = (SocketChannel) sockKey.channel();        sockKey.cancel();        try {            sock.socket().shutdownInput();        } catch (IOException e) {                    }        try {            sock.socket().shutdownOutput();        } catch (IOException e) {                    }        try {            sock.socket().close();        } catch (IOException e) {                    }        try {            sock.close();        } catch (IOException e) {                    }    }    try {        Thread.sleep(100);    } catch (InterruptedException e) {            }    sockKey = null;}
close
 voidf1124_1)
{    try {        LOG.trace("Doing client selector close");        selector.close();        LOG.trace("Closed client selector");    } catch (IOException e) {            }}
createSock
 SocketChannel zookeeper_f1125_0() throws IOException
{    SocketChannel sock;    sock = SocketChannel.open();    sock.configureBlocking(false);    sock.socket().setSoLinger(false, -1);    sock.socket().setTcpNoDelay(true);    return sock;}
registerAndConnect
 void zookeeper_f1126_0(SocketChannel sock, InetSocketAddress addr) throws IOException
{    sockKey = sock.register(selector, SelectionKey.OP_CONNECT);    boolean immediateConnect = sock.connect(addr);    if (immediateConnect) {        sendThread.primeConnection();    }}
connect
 voidf1127_1InetSocketAddress addr) throws IOException
{    SocketChannel sock = createSock();    try {        registerAndConnect(sock, addr);    } catch (IOException e) {                sock.close();        throw e;    }    initialized = false;    /*         * Reset incomingBuffer         */    lenBuffer.clear();    incomingBuffer = lenBuffer;}
getRemoteSocketAddress
 SocketAddress zookeeper_f1128_0()
{    return remoteSocketAddress;}
getLocalSocketAddress
 SocketAddress zookeeper_f1129_0()
{    return localSocketAddress;}
updateSocketAddresses
private void zookeeper_f1130_0()
{    Socket socket = ((SocketChannel) sockKey.channel()).socket();    localSocketAddress = socket.getLocalSocketAddress();    remoteSocketAddress = socket.getRemoteSocketAddress();}
packetAdded
 void zookeeper_f1131_0()
{    wakeupCnxn();}
onClosing
 void zookeeper_f1132_0()
{    wakeupCnxn();}
wakeupCnxn
private synchronized void zookeeper_f1133_0()
{    selector.wakeup();}
doTransport
 void zookeeper_f1134_0(int waitTimeOut, Queue<Packet> pendingQueue, ClientCnxn cnxn) throws IOException, InterruptedException
{    selector.select(waitTimeOut);    Set<SelectionKey> selected;    synchronized (this) {        selected = selector.selectedKeys();    }                updateNow();    for (SelectionKey k : selected) {        SocketChannel sc = ((SocketChannel) k.channel());        if ((k.readyOps() & SelectionKey.OP_CONNECT) != 0) {            if (sc.finishConnect()) {                updateLastSendAndHeard();                updateSocketAddresses();                sendThread.primeConnection();            }        } else if ((k.readyOps() & (SelectionKey.OP_READ | SelectionKey.OP_WRITE)) != 0) {            doIO(pendingQueue, cnxn);        }    }    if (sendThread.getZkState().isConnected()) {        if (findSendablePacket(outgoingQueue, sendThread.tunnelAuthInProgress()) != null) {            enableWrite();        }    }    selected.clear();}
testableCloseSocket
 voidf1135_1) throws IOException
{                SelectionKey tmp = sockKey;    if (tmp != null) {        ((SocketChannel) tmp.channel()).socket().close();    }}
saslCompleted
 void zookeeper_f1136_0()
{    enableWrite();}
enableWrite
 synchronized void zookeeper_f1137_0()
{    int i = sockKey.interestOps();    if ((i & SelectionKey.OP_WRITE) == 0) {        sockKey.interestOps(i | SelectionKey.OP_WRITE);    }}
disableWrite
private synchronized void zookeeper_f1138_0()
{    int i = sockKey.interestOps();    if ((i & SelectionKey.OP_WRITE) != 0) {        sockKey.interestOps(i & (~SelectionKey.OP_WRITE));    }}
enableRead
private synchronized void zookeeper_f1139_0()
{    int i = sockKey.interestOps();    if ((i & SelectionKey.OP_READ) == 0) {        sockKey.interestOps(i | SelectionKey.OP_READ);    }}
connectionPrimed
 void zookeeper_f1140_0()
{    sockKey.interestOps(SelectionKey.OP_READ | SelectionKey.OP_WRITE);}
getSelector
 Selector zookeeper_f1141_0()
{    return selector;}
sendPacket
 void zookeeper_f1142_0(Packet p) throws IOException
{    SocketChannel sock = (SocketChannel) sockKey.channel();    if (sock == null) {        throw new IOException("Socket is null!");    }    p.createBB();    ByteBuffer pbb = p.bb;    sock.write(pbb);}
write
public void zookeeper_f1143_0(byte[] b, int off, int len) throws IOException
{    out.write(b, off, len);}
close
public voidf1144_1) throws IOException
{    boolean triedToClose = false, success = false;    try {        flush();        ((FileOutputStream) out).getFD().sync();        triedToClose = true;        super.close();        success = true;    } finally {        if (success) {            boolean renamed = tmpFile.renameTo(origFile);            if (!renamed) {                                if (!origFile.delete() || !tmpFile.renameTo(origFile)) {                    throw new IOException("Could not rename temporary file " + tmpFile + " to " + origFile);                }            }        } else {            if (!triedToClose) {                                                IOUtils.closeStream(out);            }                        if (!tmpFile.delete()) {                            }        }    }}
abort
public voidf1145_1)
{    try {        super.close();    } catch (IOException ioe) {            }    if (!tmpFile.delete()) {            }}
getConfigPrefix
protected String zookeeper_f1146_0()
{    return "zookeeper.ssl.";}
shouldVerifyClientHostname
protected boolean zookeeper_f1147_0()
{    return false;}
getSslAuthProviderProperty
public String zookeeper_f1148_0()
{    return sslAuthProviderProperty;}
getState
public synchronized State zookeeper_f1149_0()
{    return state;}
waitForState
 synchronized void zookeeper_f1150_0(State desiredState) throws InterruptedException
{    while (this.state != desiredState) {        this.wait();    }}
setState
private synchronized void zookeeper_f1151_0(State newState)
{    state = newState;    this.notifyAll();}
compareAndSetState
private synchronized boolean zookeeper_f1152_0(State expected, State update)
{    if (state == expected) {        setState(update);        return true;    } else {        return false;    }}
compareAndSetState
private synchronized boolean zookeeper_f1153_0(State[] expectedStates, State update)
{    for (State expected : expectedStates) {        if (state == expected) {            setState(update);            return true;        }    }    return false;}
start
public void zookeeper_f1154_0()
{    if (!compareAndSetState(State.NEW, State.STARTING)) {                return;    }    this.watcherThread.start();}
stop
public void zookeeper_f1155_0()
{    if (compareAndSetState(new State[] { State.RUNNING, State.STARTING }, State.STOPPING)) {        watcherThread.interrupt();    }}
run
public voidf1156_1)
{    try {                if (!compareAndSetState(FileChangeWatcher.State.STARTING, FileChangeWatcher.State.RUNNING)) {                                    FileChangeWatcher.State state = FileChangeWatcher.this.getState();            if (state != FileChangeWatcher.State.STOPPING) {                throw new IllegalStateException("Unexpected state: " + state);            }            return;        }        runLoop();    } catch (Exception e) {                throw e;    } finally {        try {            watchService.close();        } catch (IOException e) {                    }                FileChangeWatcher.this.setState(FileChangeWatcher.State.STOPPED);    }}
runLoop
private voidf1157_1)
{    while (FileChangeWatcher.this.getState() == FileChangeWatcher.State.RUNNING) {        WatchKey key;        try {            key = watchService.take();        } catch (InterruptedException | ClosedWatchServiceException e) {                        break;        }        for (WatchEvent<?> event : key.pollEvents()) {                        try {                callback.accept(event);            } catch (Throwable e) {                            }        }        boolean isKeyValid = key.reset();        if (!isKeyValid) {                                                                        break;        }    }}
setKeyStorePath
 Builder<T> zookeeper_f1158_0(String keyStorePath)
{    this.keyStorePath = Objects.requireNonNull(keyStorePath);    return this;}
setTrustStorePath
 Builder<T> zookeeper_f1159_0(String trustStorePath)
{    this.trustStorePath = Objects.requireNonNull(trustStorePath);    return this;}
setKeyStorePassword
 Builder<T> zookeeper_f1160_0(String keyStorePassword)
{    this.keyStorePassword = Objects.requireNonNull(keyStorePassword);    return this;}
setTrustStorePassword
 Builder<T> zookeeper_f1161_0(String trustStorePassword)
{    this.trustStorePassword = Objects.requireNonNull(trustStorePassword);    return this;}
getBuilderForKeyStoreFileType
 static FileKeyStoreLoader.Builder<? extends FileKeyStoreLoader> zookeeper_f1162_0(KeyStoreFileType type)
{    switch(Objects.requireNonNull(type)) {        case JKS:            return new JKSFileLoader.Builder();        case PEM:            return new PEMFileLoader.Builder();        case PKCS12:            return new PKCS12FileLoader.Builder();        default:            throw new AssertionError("Unexpected StoreFileType: " + type.name());    }}
closeStream
public static void zookeeper_f1163_0(Closeable stream)
{    cleanup(null, stream);}
cleanup
public static voidf1164_1Logger log, Closeable... closeables)
{    for (Closeable c : closeables) {        if (c != null) {            try {                c.close();            } catch (IOException e) {                if (log != null) {                                    }            }        }    }}
copyBytes
public static void zookeeper_f1165_0(InputStream in, OutputStream out, int buffSize, boolean close) throws IOException
{    try {        copyBytes(in, out, buffSize);        if (close) {            out.close();            out = null;            in.close();            in = null;        }    } finally {        if (close) {            closeStream(out);            closeStream(in);        }    }}
copyBytes
public static void zookeeper_f1166_0(InputStream in, OutputStream out, int buffSize) throws IOException
{    PrintStream ps = out instanceof PrintStream ? (PrintStream) out : null;    byte[] buf = new byte[buffSize];    int bytesRead = in.read(buf);    while (bytesRead >= 0) {        out.write(buf, 0, bytesRead);        if ((ps != null) && ps.checkError()) {            throw new IOException("Unable to write to output stream.");        }        bytesRead = in.read(buf);    }}
keyStoreInstance
protected KeyStore zookeeper_f1167_0() throws KeyStoreException
{    return KeyStore.getInstance("JKS");}
build
 JKSFileLoader zookeeper_f1168_0()
{    return new JKSFileLoader(keyStorePath, trustStorePath, keyStorePassword, trustStorePassword);}
getPropertyValue
public String zookeeper_f1169_0()
{    return this.name();}
getDefaultFileExtension
public String zookeeper_f1170_0()
{    return defaultFileExtension;}
fromPropertyValue
public static KeyStoreFileType zookeeper_f1171_0(String propertyValue)
{    if (propertyValue == null || propertyValue.length() == 0) {        return null;    }    return KeyStoreFileType.valueOf(propertyValue.toUpperCase());}
fromFilename
public static KeyStoreFileType zookeeper_f1172_0(String filename)
{    int i = filename.lastIndexOf('.');    if (i >= 0) {        String extension = filename.substring(i);        for (KeyStoreFileType storeFileType : KeyStoreFileType.values()) {            if (storeFileType.getDefaultFileExtension().equals(extension)) {                return storeFileType;            }        }    }    throw new IllegalArgumentException("Unable to auto-detect store file type from file name: " + filename);}
fromPropertyValueOrFileName
public static KeyStoreFileType zookeeper_f1173_0(String propertyValue, String filename)
{    KeyStoreFileType result = KeyStoreFileType.fromPropertyValue(propertyValue);    if (result == null) {        result = KeyStoreFileType.fromFilename(filename);    }    return result;}
newNioOrEpollEventLoopGroup
public static EventLoopGroup zookeeper_f1174_0()
{    if (Epoll.isAvailable()) {        return new EpollEventLoopGroup();    } else {        return new NioEventLoopGroup();    }}
newNioOrEpollEventLoopGroup
public static EventLoopGroup zookeeper_f1175_0(int nThreads)
{    if (Epoll.isAvailable()) {        return new EpollEventLoopGroup(nThreads);    } else {        return new NioEventLoopGroup(nThreads);    }}
nioOrEpollSocketChannel
public static Class<? extends SocketChannel> zookeeper_f1176_0()
{    if (Epoll.isAvailable()) {        return EpollSocketChannel.class;    } else {        return NioSocketChannel.class;    }}
nioOrEpollServerSocketChannel
public static Class<? extends ServerSocketChannel> zookeeper_f1177_0()
{    if (Epoll.isAvailable()) {        return EpollServerSocketChannel.class;    } else {        return NioServerSocketChannel.class;    }}
getClientReachableLocalInetAddressCount
public static intf1178_1)
{    try {        Set<InetAddress> validInetAddresses = new HashSet<>();        Enumeration<NetworkInterface> allNetworkInterfaces = NetworkInterface.getNetworkInterfaces();        for (NetworkInterface networkInterface : Collections.list(allNetworkInterfaces)) {            for (InetAddress inetAddress : Collections.list(networkInterface.getInetAddresses())) {                if (inetAddress.isLinkLocalAddress()) {                    if (LOG.isDebugEnabled()) {                                            }                    continue;                }                if (inetAddress.isMulticastAddress()) {                    if (LOG.isDebugEnabled()) {                                            }                    continue;                }                if (inetAddress.isLoopbackAddress()) {                    if (LOG.isDebugEnabled()) {                                            }                    continue;                }                validInetAddresses.add(inetAddress);            }        }                return validInetAddresses.size() > 0 ? validInetAddresses.size() : DEFAULT_INET_ADDRESS_COUNT;    } catch (SocketException ex) {                return DEFAULT_INET_ADDRESS_COUNT;    }}
formatInetAddr
public static String zookeeper_f1179_0(InetSocketAddress addr)
{    InetAddress ia = addr.getAddress();    if (ia == null) {        return String.format("%s:%s", addr.getHostString(), addr.getPort());    }    if (ia instanceof Inet6Address) {        return String.format("[%s]:%s", ia.getHostAddress(), addr.getPort());    } else {        return String.format("%s:%s", ia.getHostAddress(), addr.getPort());    }}
getParent
 TrieNode zookeeper_f1180_0()
{    return this.parent;}
setParent
 void zookeeper_f1181_0(TrieNode parent)
{    this.parent = parent;}
setProperty
 void zookeeper_f1182_0(boolean prop)
{    this.property = prop;}
hasProperty
 boolean zookeeper_f1183_0()
{    return this.property;}
getValue
public String zookeeper_f1184_0()
{    return this.value;}
addChild
 void zookeeper_f1185_0(String childName, TrieNode node)
{    this.children.putIfAbsent(childName, node);}
deleteChild
 void zookeeper_f1186_0(String childName)
{    this.children.computeIfPresent(childName, (key, childNode) -> {                childNode.setProperty(false);                if (childNode.isLeafNode()) {            childNode.setParent(null);            return null;        }        return childNode;    });}
getChild
 TrieNode zookeeper_f1187_0(String childName)
{    return this.children.get(childName);}
getChildren
 Collection<String> zookeeper_f1188_0()
{    return children.keySet();}
isLeafNode
 boolean zookeeper_f1189_0()
{    return children.isEmpty();}
toString
public String zookeeper_f1190_0()
{    return "TrieNode [name=" + value + ", property=" + property + ", children=" + children.keySet() + "]";}
addPath
public void zookeeper_f1191_0(final String path)
{    Objects.requireNonNull(path, "Path cannot be null");    final String[] pathComponents = StringUtils.split(path, '/');    if (pathComponents.length == 0) {        throw new IllegalArgumentException("Invalid path: " + path);    }    writeLock.lock();    try {        TrieNode parent = rootNode;        for (final String part : pathComponents) {            TrieNode child = parent.getChild(part);            if (child == null) {                child = new TrieNode(parent, part);                parent.addChild(part, child);            }            parent = child;        }        parent.setProperty(true);    } finally {        writeLock.unlock();    }}
deletePath
public voidf1192_1final String path)
{    Objects.requireNonNull(path, "Path cannot be null");    final String[] pathComponents = StringUtils.split(path, '/');    if (pathComponents.length == 0) {        throw new IllegalArgumentException("Invalid path: " + path);    }    writeLock.lock();    try {        TrieNode parent = rootNode;        for (final String part : pathComponents) {            if (parent.getChild(part) == null) {                                return;            }            parent = parent.getChild(part);                    }        final TrieNode realParent = parent.getParent();        realParent.deleteChild(parent.getValue());    } finally {        writeLock.unlock();    }}
existsNode
public booleanf1193_1final String path)
{    Objects.requireNonNull(path, "Path cannot be null");    final String[] pathComponents = StringUtils.split(path, '/');    if (pathComponents.length == 0) {        throw new IllegalArgumentException("Invalid path: " + path);    }    readLock.lock();    try {        TrieNode parent = rootNode;        for (final String part : pathComponents) {            if (parent.getChild(part) == null) {                                return false;            }            parent = parent.getChild(part);                    }    } finally {        readLock.unlock();    }    return true;}
findMaxPrefix
public Stringf1194_1final String path)
{    Objects.requireNonNull(path, "Path cannot be null");    final String[] pathComponents = StringUtils.split(path, '/');    readLock.lock();    try {        TrieNode parent = rootNode;        TrieNode deepestPropertyNode = null;        for (final String element : pathComponents) {            parent = parent.getChild(element);            if (parent == null) {                                break;            }            if (parent.hasProperty()) {                deepestPropertyNode = parent;            }        }        if (deepestPropertyNode == null) {            return "/";        }        final Deque<String> treePath = new ArrayDeque<>();        TrieNode node = deepestPropertyNode;        while (node != this.rootNode) {            treePath.offerFirst(node.getValue());            node = node.parent;        }        return "/" + String.join("/", treePath);    } finally {        readLock.unlock();    }}
clear
public void zookeeper_f1195_0()
{    writeLock.lock();    try {        rootNode.getChildren().clear();    } finally {        writeLock.unlock();    }}
validatePath
public static void zookeeper_f1196_0(String path, boolean isSequential) throws IllegalArgumentException
{    validatePath(isSequential ? path + "1" : path);}
validatePath
public static void zookeeper_f1197_0(String path) throws IllegalArgumentException
{    if (path == null) {        throw new IllegalArgumentException("Path cannot be null");    }    if (path.length() == 0) {        throw new IllegalArgumentException("Path length must be > 0");    }    if (path.charAt(0) != '/') {        throw new IllegalArgumentException("Path must start with / character");    }    if (path.length() == 1) {                return;    }    if (path.charAt(path.length() - 1) == '/') {        throw new IllegalArgumentException("Path must not end with / character");    }    String reason = null;    char lastc = '/';    char[] chars = path.toCharArray();    char c;    for (int i = 1; i < chars.length; lastc = chars[i], i++) {        c = chars[i];        if (c == 0) {            reason = "null character not allowed @" + i;            break;        } else if (c == '/' && lastc == '/') {            reason = "empty node name specified @" + i;            break;        } else if (c == '.' && lastc == '.') {            if (chars[i - 2] == '/' && ((i + 1 == chars.length) || chars[i + 1] == '/')) {                reason = "relative paths not allowed @" + i;                break;            }        } else if (c == '.') {            if (chars[i - 1] == '/' && ((i + 1 == chars.length) || chars[i + 1] == '/')) {                reason = "relative paths not allowed @" + i;                break;            }        } else if (c > '\u0000' && c <= '\u001f' || c >= '\u007f' && c <= '\u009F' || c >= '\ud800' && c <= '\uf8ff' || c >= '\ufff0' && c <= '\uffff') {            reason = "invalid character @" + i;            break;        }    }    if (reason != null) {        throw new IllegalArgumentException("Invalid path string \"" + path + "\" caused by " + reason);    }}
normalizeFileSystemPath
public static String zookeeper_f1198_0(String path)
{    if (path != null) {        String osname = java.lang.System.getProperty("os.name");        if (osname.toLowerCase().contains("windows")) {            return path.replace('\\', '/');        }    }    return path;}
loadKeyStore
public KeyStore zookeeper_f1199_0() throws IOException, GeneralSecurityException
{    Optional<String> passwordOption;    if (keyStorePassword == null || keyStorePassword.length() == 0) {        passwordOption = Optional.empty();    } else {        passwordOption = Optional.of(keyStorePassword);    }    File file = new File(keyStorePath);    return PemReader.loadKeyStore(file, file, passwordOption);}
loadTrustStore
public KeyStore zookeeper_f1200_0() throws IOException, GeneralSecurityException
{    return PemReader.loadTrustStore(new File(trustStorePath));}
build
 PEMFileLoader zookeeper_f1201_0()
{    return new PEMFileLoader(keyStorePath, trustStorePath, keyStorePassword, trustStorePassword);}
keyStoreInstance
protected KeyStore zookeeper_f1202_0() throws KeyStoreException
{    return KeyStore.getInstance("PKCS12");}
build
 PKCS12FileLoader zookeeper_f1203_0()
{    return new PKCS12FileLoader(keyStorePath, trustStorePath, keyStorePassword, trustStorePassword);}
getConfigPrefix
protected String zookeeper_f1204_0()
{    return "zookeeper.ssl.quorum.";}
shouldVerifyClientHostname
protected boolean zookeeper_f1205_0()
{    return true;}
getSSLContext
public SSLContext zookeeper_f1206_0()
{    return sslContext;}
createSSLSocket
public SSLSocket zookeeper_f1207_0() throws IOException
{    return configureSSLSocket((SSLSocket) sslContext.getSocketFactory().createSocket(), true);}
createSSLSocket
public SSLSocket zookeeper_f1208_0(Socket socket, byte[] pushbackBytes) throws IOException
{    SSLSocket sslSocket;    if (pushbackBytes != null && pushbackBytes.length > 0) {        sslSocket = (SSLSocket) sslContext.getSocketFactory().createSocket(socket, new ByteArrayInputStream(pushbackBytes), true);    } else {        sslSocket = (SSLSocket) sslContext.getSocketFactory().createSocket(socket, null, socket.getPort(), true);    }    return configureSSLSocket(sslSocket, false);}
createSSLServerSocket
public SSLServerSocket zookeeper_f1209_0() throws IOException
{    SSLServerSocket sslServerSocket = (SSLServerSocket) sslContext.getServerSocketFactory().createServerSocket();    return configureSSLServerSocket(sslServerSocket);}
createSSLServerSocket
public SSLServerSocket zookeeper_f1210_0(int port) throws IOException
{    SSLServerSocket sslServerSocket = (SSLServerSocket) sslContext.getServerSocketFactory().createServerSocket(port);    return configureSSLServerSocket(sslServerSocket);}
createNettyJdkSslContext
public SslContext zookeeper_f1211_0(SSLContext sslContext, boolean isClientSocket)
{    return new JdkSslContext(sslContext, isClientSocket, cipherSuitesAsList, IdentityCipherSuiteFilter.INSTANCE, null, isClientSocket ? X509Util.ClientAuth.NONE.toNettyClientAuth() : clientAuth.toNettyClientAuth(), enabledProtocols, false);}
getHandshakeDetectionTimeoutMillis
public int zookeeper_f1212_0()
{    return handshakeDetectionTimeoutMillis;}
configureSSLSocket
private SSLSocket zookeeper_f1213_0(SSLSocket socket, boolean isClientSocket)
{    SSLParameters sslParameters = socket.getSSLParameters();    configureSslParameters(sslParameters, isClientSocket);    socket.setSSLParameters(sslParameters);    socket.setUseClientMode(isClientSocket);    return socket;}
configureSSLServerSocket
private SSLServerSocket zookeeper_f1214_0(SSLServerSocket socket)
{    SSLParameters sslParameters = socket.getSSLParameters();    configureSslParameters(sslParameters, false);    socket.setSSLParameters(sslParameters);    socket.setUseClientMode(false);    return socket;}
configureSslParameters
private voidf1215_1SSLParameters sslParameters, boolean isClientSocket)
{    if (cipherSuites != null) {        if (LOG.isDebugEnabled()) {                    }        sslParameters.setCipherSuites(cipherSuites);    }    if (enabledProtocols != null) {        if (LOG.isDebugEnabled()) {                    }        sslParameters.setProtocols(enabledProtocols);    }    if (!isClientSocket) {        switch(clientAuth) {            case NEED:                sslParameters.setNeedClientAuth(true);                break;            case WANT:                sslParameters.setWantClientAuth(true);                break;            default:                                sslParameters.setNeedClientAuth(false);                break;        }    }}
getEnabledProtocols
private String[] zookeeper_f1216_0(final ZKConfig config, final SSLContext sslContext)
{    String enabledProtocolsInput = config.getProperty(x509Util.getSslEnabledProtocolsProperty());    if (enabledProtocolsInput == null) {        return new String[] { sslContext.getProtocol() };    }    return enabledProtocolsInput.split(",");}
getCipherSuites
private String[] zookeeper_f1217_0(final ZKConfig config)
{    String cipherSuitesInput = config.getProperty(x509Util.getSslCipherSuitesProperty());    if (cipherSuitesInput == null) {        return X509Util.getDefaultCipherSuites();    } else {        return cipherSuitesInput.split(",");    }}
getClientAuth
private X509Util.ClientAuth zookeeper_f1218_0(final ZKConfig config)
{    return X509Util.ClientAuth.fromPropertyValue(config.getProperty(x509Util.getSslClientAuthProperty()));}
getHandshakeDetectionTimeoutMillis
private intf1219_1final ZKConfig config)
{    String propertyString = config.getProperty(x509Util.getSslHandshakeDetectionTimeoutMillisProperty());    int result;    if (propertyString == null) {        result = X509Util.DEFAULT_HANDSHAKE_DETECTION_TIMEOUT_MILLIS;    } else {        result = Integer.parseInt(propertyString);        if (result < 1) {                                                result = X509Util.DEFAULT_HANDSHAKE_DETECTION_TIMEOUT_MILLIS;        }    }    return result;}
loadKeyStore
public KeyStore zookeeper_f1220_0() throws IOException, GeneralSecurityException
{    try (InputStream inputStream = new FileInputStream(new File(keyStorePath))) {        KeyStore ks = keyStoreInstance();        ks.load(inputStream, passwordStringToCharArray(keyStorePassword));        return ks;    }}
loadTrustStore
public KeyStore zookeeper_f1221_0() throws IOException, GeneralSecurityException
{    try (InputStream inputStream = new FileInputStream(new File(trustStorePath))) {        KeyStore ts = keyStoreInstance();        ts.load(inputStream, passwordStringToCharArray(trustStorePassword));        return ts;    }}
passwordStringToCharArray
private static char[] zookeeper_f1222_0(String password)
{    return password == null ? EMPTY_CHAR_ARRAY : password.toCharArray();}
split
public static List<String> zookeeper_f1223_0(String value, String separator)
{    String[] splits = value.split(separator);    List<String> results = new ArrayList<String>();    for (int i = 0; i < splits.length; i++) {        splits[i] = splits[i].trim();        if (splits[i].length() > 0) {            results.add(splits[i]);        }    }    return Collections.unmodifiableList(results);}
joinStrings
public static String zookeeper_f1224_0(List<String> list, String delim)
{    if (list == null) {        return null;    }    StringBuilder builder = new StringBuilder(list.get(0));    for (String s : list.subList(1, list.size())) {        builder.append(delim).append(s);    }    return builder.toString();}
currentElapsedTime
public static long zookeeper_f1225_0()
{    return System.nanoTime() / 1000000;}
currentWallTime
public static long zookeeper_f1226_0()
{    return System.currentTimeMillis();}
elapsedTimeToDate
public static Date zookeeper_f1227_0(long elapsedTime)
{    long wallTime = currentWallTime() + elapsedTime - currentElapsedTime();    return new Date(wallTime);}
getGCMCiphers
private static String[] zookeeper_f1228_0()
{    return new String[] { "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256", "TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256", "TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384", "TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384" };}
getCBCCiphers
private static String[] zookeeper_f1229_0()
{    return new String[] { "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256", "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256", "TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA", "TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA", "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384", "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384", "TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA", "TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA" };}
concatArrays
private static String[] zookeeper_f1230_0(String[] left, String[] right)
{    String[] result = new String[left.length + right.length];    System.arraycopy(left, 0, result, 0, left.length);    System.arraycopy(right, 0, result, left.length, right.length);    return result;}
fromPropertyValue
public static ClientAuth zookeeper_f1231_0(String prop)
{    if (prop == null || prop.length() == 0) {        return NEED;    }    return ClientAuth.valueOf(prop.toUpperCase());}
toNettyClientAuth
public io.netty.handler.ssl.ClientAuth zookeeper_f1232_0()
{    return nettyAuth;}
getSslProtocolProperty
public String zookeeper_f1233_0()
{    return sslProtocolProperty;}
getSslEnabledProtocolsProperty
public String zookeeper_f1234_0()
{    return sslEnabledProtocolsProperty;}
getCipherSuitesProperty
public String zookeeper_f1235_0()
{    return cipherSuitesProperty;}
getSslKeystoreLocationProperty
public String zookeeper_f1236_0()
{    return sslKeystoreLocationProperty;}
getSslCipherSuitesProperty
public String zookeeper_f1237_0()
{    return cipherSuitesProperty;}
getSslKeystorePasswdProperty
public String zookeeper_f1238_0()
{    return sslKeystorePasswdProperty;}
getSslKeystoreTypeProperty
public String zookeeper_f1239_0()
{    return sslKeystoreTypeProperty;}
getSslTruststoreLocationProperty
public String zookeeper_f1240_0()
{    return sslTruststoreLocationProperty;}
getSslTruststorePasswdProperty
public String zookeeper_f1241_0()
{    return sslTruststorePasswdProperty;}
getSslTruststoreTypeProperty
public String zookeeper_f1242_0()
{    return sslTruststoreTypeProperty;}
getSslContextSupplierClassProperty
public String zookeeper_f1243_0()
{    return sslContextSupplierClassProperty;}
getSslHostnameVerificationEnabledProperty
public String zookeeper_f1244_0()
{    return sslHostnameVerificationEnabledProperty;}
getSslCrlEnabledProperty
public String zookeeper_f1245_0()
{    return sslCrlEnabledProperty;}
getSslOcspEnabledProperty
public String zookeeper_f1246_0()
{    return sslOcspEnabledProperty;}
getSslClientAuthProperty
public String zookeeper_f1247_0()
{    return sslClientAuthProperty;}
getSslHandshakeDetectionTimeoutMillisProperty
public String zookeeper_f1248_0()
{    return sslHandshakeDetectionTimeoutMillisProperty;}
getDefaultSSLContext
public SSLContext zookeeper_f1249_0() throws X509Exception.SSLContextException
{    return getDefaultSSLContextAndOptions().getSSLContext();}
createSSLContext
public SSLContext zookeeper_f1250_0(ZKConfig config) throws SSLContextException
{    return createSSLContextAndOptions(config).getSSLContext();}
getDefaultSSLContextAndOptions
public SSLContextAndOptions zookeeper_f1251_0() throws X509Exception.SSLContextException
{    SSLContextAndOptions result = defaultSSLContextAndOptions.get();    if (result == null) {        result = createSSLContextAndOptions();        if (!defaultSSLContextAndOptions.compareAndSet(null, result)) {                        result = defaultSSLContextAndOptions.get();        }    }    return result;}
resetDefaultSSLContextAndOptions
private void zookeeper_f1252_0() throws X509Exception.SSLContextException
{    SSLContextAndOptions newContext = createSSLContextAndOptions();    defaultSSLContextAndOptions.set(newContext);}
createSSLContextAndOptions
private SSLContextAndOptions zookeeper_f1253_0() throws SSLContextException
{    /*         * Since Configuration initializes the key store and trust store related         * configuration from system property. Reading property from         * configuration will be same reading from system property         */    return createSSLContextAndOptions(zkConfig == null ? new ZKConfig() : zkConfig);}
getSslHandshakeTimeoutMillis
public intf1254_1)
{    try {        SSLContextAndOptions ctx = getDefaultSSLContextAndOptions();        return ctx.getHandshakeDetectionTimeoutMillis();    } catch (SSLContextException e) {                return DEFAULT_HANDSHAKE_DETECTION_TIMEOUT_MILLIS;    } catch (Exception e) {                return DEFAULT_HANDSHAKE_DETECTION_TIMEOUT_MILLIS;    }}
createSSLContextAndOptions
public SSLContextAndOptionsf1255_1ZKConfig config) throws SSLContextException
{    final String supplierContextClassName = config.getProperty(sslContextSupplierClassProperty);    if (supplierContextClassName != null) {        if (LOG.isDebugEnabled()) {                    }        try {            Class<?> sslContextClass = Class.forName(supplierContextClassName);            Supplier<SSLContext> sslContextSupplier = (Supplier<SSLContext>) sslContextClass.getConstructor().newInstance();            return new SSLContextAndOptions(this, config, sslContextSupplier.get());        } catch (ClassNotFoundException | ClassCastException | NoSuchMethodException | InvocationTargetException | InstantiationException | IllegalAccessException e) {            throw new SSLContextException("Could not retrieve the SSLContext from supplier source '" + supplierContextClassName + "' provided in the property '" + sslContextSupplierClassProperty + "'", e);        }    } else {        return createSSLContextAndOptionsFromConfig(config);    }}
createSSLContextAndOptionsFromConfig
public SSLContextAndOptionsf1256_1ZKConfig config) throws SSLContextException
{    KeyManager[] keyManagers = null;    TrustManager[] trustManagers = null;    String keyStoreLocationProp = config.getProperty(sslKeystoreLocationProperty, "");    String keyStorePasswordProp = config.getProperty(sslKeystorePasswdProperty, "");    String keyStoreTypeProp = config.getProperty(sslKeystoreTypeProperty);    if (keyStoreLocationProp.isEmpty()) {            } else {        try {            keyManagers = new KeyManager[] { createKeyManager(keyStoreLocationProp, keyStorePasswordProp, keyStoreTypeProp) };        } catch (KeyManagerException keyManagerException) {            throw new SSLContextException("Failed to create KeyManager", keyManagerException);        } catch (IllegalArgumentException e) {            throw new SSLContextException("Bad value for " + sslKeystoreTypeProperty + ": " + keyStoreTypeProp, e);        }    }    String trustStoreLocationProp = config.getProperty(sslTruststoreLocationProperty, "");    String trustStorePasswordProp = config.getProperty(sslTruststorePasswdProperty, "");    String trustStoreTypeProp = config.getProperty(sslTruststoreTypeProperty);    boolean sslCrlEnabled = config.getBoolean(this.sslCrlEnabledProperty);    boolean sslOcspEnabled = config.getBoolean(this.sslOcspEnabledProperty);    boolean sslServerHostnameVerificationEnabled = config.getBoolean(this.getSslHostnameVerificationEnabledProperty(), true);    boolean sslClientHostnameVerificationEnabled = sslServerHostnameVerificationEnabled && shouldVerifyClientHostname();    if (trustStoreLocationProp.isEmpty()) {            } else {        try {            trustManagers = new TrustManager[] { createTrustManager(trustStoreLocationProp, trustStorePasswordProp, trustStoreTypeProp, sslCrlEnabled, sslOcspEnabled, sslServerHostnameVerificationEnabled, sslClientHostnameVerificationEnabled) };        } catch (TrustManagerException trustManagerException) {            throw new SSLContextException("Failed to create TrustManager", trustManagerException);        } catch (IllegalArgumentException e) {            throw new SSLContextException("Bad value for " + sslTruststoreTypeProperty + ": " + trustStoreTypeProp, e);        }    }    String protocol = config.getProperty(sslProtocolProperty, DEFAULT_PROTOCOL);    try {        SSLContext sslContext = SSLContext.getInstance(protocol);        sslContext.init(keyManagers, trustManagers, null);        return new SSLContextAndOptions(this, config, sslContext);    } catch (NoSuchAlgorithmException | KeyManagementException sslContextInitException) {        throw new SSLContextException(sslContextInitException);    }}
loadKeyStore
public static KeyStore zookeeper_f1257_0(String keyStoreLocation, String keyStorePassword, String keyStoreTypeProp) throws IOException, GeneralSecurityException
{    KeyStoreFileType storeFileType = KeyStoreFileType.fromPropertyValueOrFileName(keyStoreTypeProp, keyStoreLocation);    return FileKeyStoreLoaderBuilderProvider.getBuilderForKeyStoreFileType(storeFileType).setKeyStorePath(keyStoreLocation).setKeyStorePassword(keyStorePassword).build().loadKeyStore();}
loadTrustStore
public static KeyStore zookeeper_f1258_0(String trustStoreLocation, String trustStorePassword, String trustStoreTypeProp) throws IOException, GeneralSecurityException
{    KeyStoreFileType storeFileType = KeyStoreFileType.fromPropertyValueOrFileName(trustStoreTypeProp, trustStoreLocation);    return FileKeyStoreLoaderBuilderProvider.getBuilderForKeyStoreFileType(storeFileType).setTrustStorePath(trustStoreLocation).setTrustStorePassword(trustStorePassword).build().loadTrustStore();}
createKeyManager
public static X509KeyManager zookeeper_f1259_0(String keyStoreLocation, String keyStorePassword, String keyStoreTypeProp) throws KeyManagerException
{    if (keyStorePassword == null) {        keyStorePassword = "";    }    try {        KeyStore ks = loadKeyStore(keyStoreLocation, keyStorePassword, keyStoreTypeProp);        KeyManagerFactory kmf = KeyManagerFactory.getInstance("PKIX");        kmf.init(ks, keyStorePassword.toCharArray());        for (KeyManager km : kmf.getKeyManagers()) {            if (km instanceof X509KeyManager) {                return (X509KeyManager) km;            }        }        throw new KeyManagerException("Couldn't find X509KeyManager");    } catch (IOException | GeneralSecurityException | IllegalArgumentException e) {        throw new KeyManagerException(e);    }}
createTrustManager
public static X509TrustManager zookeeper_f1260_0(String trustStoreLocation, String trustStorePassword, String trustStoreTypeProp, boolean crlEnabled, boolean ocspEnabled, final boolean serverHostnameVerificationEnabled, final boolean clientHostnameVerificationEnabled) throws TrustManagerException
{    if (trustStorePassword == null) {        trustStorePassword = "";    }    try {        KeyStore ts = loadTrustStore(trustStoreLocation, trustStorePassword, trustStoreTypeProp);        PKIXBuilderParameters pbParams = new PKIXBuilderParameters(ts, new X509CertSelector());        if (crlEnabled || ocspEnabled) {            pbParams.setRevocationEnabled(true);            System.setProperty("com.sun.net.ssl.checkRevocation", "true");            System.setProperty("com.sun.security.enableCRLDP", "true");            if (ocspEnabled) {                Security.setProperty("ocsp.enable", "true");            }        } else {            pbParams.setRevocationEnabled(false);        }                TrustManagerFactory tmf = TrustManagerFactory.getInstance("PKIX");        tmf.init(new CertPathTrustManagerParameters(pbParams));        for (final TrustManager tm : tmf.getTrustManagers()) {            if (tm instanceof X509ExtendedTrustManager) {                return new ZKTrustManager((X509ExtendedTrustManager) tm, serverHostnameVerificationEnabled, clientHostnameVerificationEnabled);            }        }        throw new TrustManagerException("Couldn't find X509TrustManager");    } catch (IOException | GeneralSecurityException | IllegalArgumentException e) {        throw new TrustManagerException(e);    }}
createSSLSocket
public SSLSocket zookeeper_f1261_0() throws X509Exception, IOException
{    return getDefaultSSLContextAndOptions().createSSLSocket();}
createSSLSocket
public SSLSocket zookeeper_f1262_0(Socket socket, byte[] pushbackBytes) throws X509Exception, IOException
{    return getDefaultSSLContextAndOptions().createSSLSocket(socket, pushbackBytes);}
createSSLServerSocket
public SSLServerSocket zookeeper_f1263_0() throws X509Exception, IOException
{    return getDefaultSSLContextAndOptions().createSSLServerSocket();}
createSSLServerSocket
public SSLServerSocket zookeeper_f1264_0(int port) throws X509Exception, IOException
{    return getDefaultSSLContextAndOptions().createSSLServerSocket(port);}
getDefaultCipherSuites
 static String[] zookeeper_f1265_0()
{    return getDefaultCipherSuitesForJavaVersion(System.getProperty("java.specification.version"));}
getDefaultCipherSuitesForJavaVersion
 static String[]f1266_1String javaVersion)
{    Objects.requireNonNull(javaVersion);    if (javaVersion.matches("\\d+")) {                        return DEFAULT_CIPHERS_JAVA9;    } else if (javaVersion.startsWith("1.")) {                        return DEFAULT_CIPHERS_JAVA8;    } else {                return DEFAULT_CIPHERS_JAVA8;    }}
newFileChangeWatcher
private FileChangeWatcher zookeeper_f1267_0(String fileLocation) throws IOException
{    if (fileLocation == null || fileLocation.isEmpty()) {        return null;    }    final Path filePath = Paths.get(fileLocation).toAbsolutePath();    Path parentPath = filePath.getParent();    if (parentPath == null) {        throw new IOException("Key/trust store path does not have a parent: " + filePath);    }    return new FileChangeWatcher(parentPath, watchEvent -> {        handleWatchEvent(filePath, watchEvent);    });}
enableCertFileReloading
public voidf1268_1) throws IOException
{        ZKConfig config = zkConfig == null ? new ZKConfig() : zkConfig;    FileChangeWatcher newKeyStoreFileWatcher = newFileChangeWatcher(config.getProperty(sslKeystoreLocationProperty));    if (newKeyStoreFileWatcher != null) {                if (keyStoreFileWatcher != null) {            keyStoreFileWatcher.stop();        }        keyStoreFileWatcher = newKeyStoreFileWatcher;        keyStoreFileWatcher.start();    }    FileChangeWatcher newTrustStoreFileWatcher = newFileChangeWatcher(config.getProperty(sslTruststoreLocationProperty));    if (newTrustStoreFileWatcher != null) {                if (trustStoreFileWatcher != null) {            trustStoreFileWatcher.stop();        }        trustStoreFileWatcher = newTrustStoreFileWatcher;        trustStoreFileWatcher.start();    }}
close
public void zookeeper_f1269_0()
{    if (keyStoreFileWatcher != null) {        keyStoreFileWatcher.stop();        keyStoreFileWatcher = null;    }    if (trustStoreFileWatcher != null) {        trustStoreFileWatcher.stop();        trustStoreFileWatcher = null;    }}
handleWatchEvent
private voidf1270_1Path filePath, WatchEvent<?> event)
{    boolean shouldResetContext = false;    Path dirPath = filePath.getParent();    if (event.kind().equals(StandardWatchEventKinds.OVERFLOW)) {                shouldResetContext = true;    } else if (event.kind().equals(StandardWatchEventKinds.ENTRY_MODIFY) || event.kind().equals(StandardWatchEventKinds.ENTRY_CREATE)) {        Path eventFilePath = dirPath.resolve((Path) event.context());        if (filePath.equals(eventFilePath)) {            shouldResetContext = true;        }    }        if (shouldResetContext) {        if (LOG.isDebugEnabled()) {                    }        try {            this.resetDefaultSSLContextAndOptions();        } catch (SSLContextException e) {            throw new RuntimeException(e);        }    } else {        if (LOG.isDebugEnabled()) {                    }    }}
init
private void zookeeper_f1271_0()
{    /**     * backward compatibility for all currently available client properties     */    handleBackwardCompatibility();}
handleBackwardCompatibility
protected void zookeeper_f1272_0()
{    properties.put(JUTE_MAXBUFFER, System.getProperty(JUTE_MAXBUFFER));    properties.put(KINIT_COMMAND, System.getProperty(KINIT_COMMAND));    properties.put(JGSS_NATIVE, System.getProperty(JGSS_NATIVE));    try (ClientX509Util clientX509Util = new ClientX509Util()) {        putSSLProperties(clientX509Util);        properties.put(clientX509Util.getSslAuthProviderProperty(), System.getProperty(clientX509Util.getSslAuthProviderProperty()));    }    try (X509Util x509Util = new QuorumX509Util()) {        putSSLProperties(x509Util);    }}
putSSLProperties
private void zookeeper_f1273_0(X509Util x509Util)
{    properties.put(x509Util.getSslProtocolProperty(), System.getProperty(x509Util.getSslProtocolProperty()));    properties.put(x509Util.getSslEnabledProtocolsProperty(), System.getProperty(x509Util.getSslEnabledProtocolsProperty()));    properties.put(x509Util.getSslCipherSuitesProperty(), System.getProperty(x509Util.getSslCipherSuitesProperty()));    properties.put(x509Util.getSslKeystoreLocationProperty(), System.getProperty(x509Util.getSslKeystoreLocationProperty()));    properties.put(x509Util.getSslKeystorePasswdProperty(), System.getProperty(x509Util.getSslKeystorePasswdProperty()));    properties.put(x509Util.getSslKeystoreTypeProperty(), System.getProperty(x509Util.getSslKeystoreTypeProperty()));    properties.put(x509Util.getSslTruststoreLocationProperty(), System.getProperty(x509Util.getSslTruststoreLocationProperty()));    properties.put(x509Util.getSslTruststorePasswdProperty(), System.getProperty(x509Util.getSslTruststorePasswdProperty()));    properties.put(x509Util.getSslTruststoreTypeProperty(), System.getProperty(x509Util.getSslTruststoreTypeProperty()));    properties.put(x509Util.getSslContextSupplierClassProperty(), System.getProperty(x509Util.getSslContextSupplierClassProperty()));    properties.put(x509Util.getSslHostnameVerificationEnabledProperty(), System.getProperty(x509Util.getSslHostnameVerificationEnabledProperty()));    properties.put(x509Util.getSslCrlEnabledProperty(), System.getProperty(x509Util.getSslCrlEnabledProperty()));    properties.put(x509Util.getSslOcspEnabledProperty(), System.getProperty(x509Util.getSslOcspEnabledProperty()));    properties.put(x509Util.getSslClientAuthProperty(), System.getProperty(x509Util.getSslClientAuthProperty()));    properties.put(x509Util.getSslHandshakeDetectionTimeoutMillisProperty(), System.getProperty(x509Util.getSslHandshakeDetectionTimeoutMillisProperty()));}
getProperty
public String zookeeper_f1274_0(String key)
{    return properties.get(key);}
getProperty
public String zookeeper_f1275_0(String key, String defaultValue)
{    String value = properties.get(key);    return (value == null) ? defaultValue : value;}
getJaasConfKey
public String zookeeper_f1276_0()
{    return System.getProperty(Environment.JAAS_CONF_KEY);}
setProperty
public voidf1277_1String key, String value)
{    if (null == key) {        throw new IllegalArgumentException("property key is null.");    }    String oldValue = properties.put(key, value);    if (LOG.isDebugEnabled()) {        if (null != oldValue && !oldValue.equals(value)) {                    }    }}
addConfiguration
public voidf1278_1File configFile) throws ConfigException
{        try {        configFile = (new VerifyingFileFactory.Builder(LOG).warnForRelativePath().failForNonExistingPath().build()).validate(configFile);        Properties cfg = new Properties();        FileInputStream in = new FileInputStream(configFile);        try {            cfg.load(in);        } finally {            in.close();        }        parseProperties(cfg);    } catch (IOException | IllegalArgumentException e) {                throw new ConfigException("Error while processing " + configFile.getAbsolutePath(), e);    }}
addConfiguration
public void zookeeper_f1279_0(String configPath) throws ConfigException
{    addConfiguration(new File(configPath));}
parseProperties
private void zookeeper_f1280_0(Properties cfg)
{    for (Entry<Object, Object> entry : cfg.entrySet()) {        String key = entry.getKey().toString().trim();        String value = entry.getValue().toString().trim();        setProperty(key, value);    }}
getBoolean
public boolean zookeeper_f1281_0(String key)
{    return getBoolean(key, false);}
getBoolean
public boolean zookeeper_f1282_0(String key, boolean defaultValue)
{    String propertyValue = getProperty(key);    if (propertyValue == null) {        return defaultValue;    } else {        return Boolean.parseBoolean(propertyValue);    }}
getInt
public int zookeeper_f1283_0(String key, int defaultValue)
{    String value = getProperty(key);    if (value != null) {        return Integer.parseInt(value.trim());    }    return defaultValue;}
IP
 static SubjectName zookeeper_f1284_0(final String value)
{    return new SubjectName(value, IP);}
DNS
 static SubjectName zookeeper_f1285_0(final String value)
{    return new SubjectName(value, DNS);}
getType
public int zookeeper_f1286_0()
{    return type;}
getValue
public String zookeeper_f1287_0()
{    return value;}
toString
public String zookeeper_f1288_0()
{    return value;}
isIPv4Address
 static boolean zookeeper_f1289_0(final String input)
{    return IPV4_PATTERN.matcher(input).matches();}
isIPv6StdAddress
 static boolean zookeeper_f1290_0(final String input)
{    return IPV6_STD_PATTERN.matcher(input).matches();}
isIPv6HexCompressedAddress
 static boolean zookeeper_f1291_0(final String input)
{    return IPV6_HEX_COMPRESSED_PATTERN.matcher(input).matches();}
isIPv6Address
 static boolean zookeeper_f1292_0(final String input)
{    return isIPv6StdAddress(input) || isIPv6HexCompressedAddress(input);}
verify
public booleanf1293_1final String host, final SSLSession session)
{    try {        final Certificate[] certs = session.getPeerCertificates();        final X509Certificate x509 = (X509Certificate) certs[0];        verify(host, x509);        return true;    } catch (final SSLException ex) {        if (log.isDebugEnabled()) {                    }        return false;    }}
verify
 void zookeeper_f1294_0(final String host, final X509Certificate cert) throws SSLException
{    final HostNameType hostType = determineHostFormat(host);    final List<SubjectName> subjectAlts = getSubjectAltNames(cert);    if (subjectAlts != null && !subjectAlts.isEmpty()) {        switch(hostType) {            case IPv4:                matchIPAddress(host, subjectAlts);                break;            case IPv6:                matchIPv6Address(host, subjectAlts);                break;            default:                matchDNSName(host, subjectAlts);        }    } else {                        final X500Principal subjectPrincipal = cert.getSubjectX500Principal();        final String cn = extractCN(subjectPrincipal.getName(X500Principal.RFC2253));        if (cn == null) {            throw new SSLException("Certificate subject for <" + host + "> doesn't contain " + "a common name and does not have alternative names");        }        matchCN(host, cn);    }}
matchIPAddress
private static void zookeeper_f1295_0(final String host, final List<SubjectName> subjectAlts) throws SSLException
{    for (int i = 0; i < subjectAlts.size(); i++) {        final SubjectName subjectAlt = subjectAlts.get(i);        if (subjectAlt.getType() == SubjectName.IP) {            if (host.equals(subjectAlt.getValue())) {                return;            }        }    }    throw new SSLPeerUnverifiedException("Certificate for <" + host + "> doesn't match any " + "of the subject alternative names: " + subjectAlts);}
matchIPv6Address
private static void zookeeper_f1296_0(final String host, final List<SubjectName> subjectAlts) throws SSLException
{    final String normalisedHost = normaliseAddress(host);    for (int i = 0; i < subjectAlts.size(); i++) {        final SubjectName subjectAlt = subjectAlts.get(i);        if (subjectAlt.getType() == SubjectName.IP) {            final String normalizedSubjectAlt = normaliseAddress(subjectAlt.getValue());            if (normalisedHost.equals(normalizedSubjectAlt)) {                return;            }        }    }    throw new SSLPeerUnverifiedException("Certificate for <" + host + "> doesn't match any " + "of the subject alternative names: " + subjectAlts);}
matchDNSName
private static void zookeeper_f1297_0(final String host, final List<SubjectName> subjectAlts) throws SSLException
{    final String normalizedHost = host.toLowerCase(Locale.ROOT);    for (int i = 0; i < subjectAlts.size(); i++) {        final SubjectName subjectAlt = subjectAlts.get(i);        if (subjectAlt.getType() == SubjectName.DNS) {            final String normalizedSubjectAlt = subjectAlt.getValue().toLowerCase(Locale.ROOT);            if (matchIdentityStrict(normalizedHost, normalizedSubjectAlt)) {                return;            }        }    }    throw new SSLPeerUnverifiedException("Certificate for <" + host + "> doesn't match any " + "of the subject alternative names: " + subjectAlts);}
matchCN
private static void zookeeper_f1298_0(final String host, final String cn) throws SSLException
{    final String normalizedHost = host.toLowerCase(Locale.ROOT);    final String normalizedCn = cn.toLowerCase(Locale.ROOT);    if (!matchIdentityStrict(normalizedHost, normalizedCn)) {        throw new SSLPeerUnverifiedException("Certificate for <" + host + "> doesn't match " + "common name of the certificate subject: " + cn);    }}
matchIdentity
private static boolean zookeeper_f1299_0(final String host, final String identity, final boolean strict)
{                        final int asteriskIdx = identity.indexOf('*');    if (asteriskIdx != -1) {        final String prefix = identity.substring(0, asteriskIdx);        final String suffix = identity.substring(asteriskIdx + 1);        if (!prefix.isEmpty() && !host.startsWith(prefix)) {            return false;        }        if (!suffix.isEmpty() && !host.endsWith(suffix)) {            return false;        }                if (strict) {            final String remainder = host.substring(prefix.length(), host.length() - suffix.length());            return !remainder.contains(".");        }        return true;    }    return host.equalsIgnoreCase(identity);}
matchIdentityStrict
private static boolean zookeeper_f1300_0(final String host, final String identity)
{    return matchIdentity(host, identity, true);}
extractCN
private static String zookeeper_f1301_0(final String subjectPrincipal) throws SSLException
{    if (subjectPrincipal == null) {        return null;    }    try {        final LdapName subjectDN = new LdapName(subjectPrincipal);        final List<Rdn> rdns = subjectDN.getRdns();        for (int i = rdns.size() - 1; i >= 0; i--) {            final Rdn rds = rdns.get(i);            final Attributes attributes = rds.toAttributes();            final Attribute cn = attributes.get("cn");            if (cn != null) {                try {                    final Object value = cn.get();                    if (value != null) {                        return value.toString();                    }                } catch (final NoSuchElementException ignore) {                                } catch (final NamingException ignore) {                                }            }        }        return null;    } catch (final InvalidNameException e) {        throw new SSLException(subjectPrincipal + " is not a valid X500 distinguished name");    }}
determineHostFormat
private static HostNameType zookeeper_f1302_0(final String host)
{    if (InetAddressUtils.isIPv4Address(host)) {        return HostNameType.IPv4;    }    String s = host;    if (s.startsWith("[") && s.endsWith("]")) {        s = host.substring(1, host.length() - 1);    }    if (InetAddressUtils.isIPv6Address(s)) {        return HostNameType.IPv6;    }    return HostNameType.DNS;}
getSubjectAltNames
private static List<SubjectName> zookeeper_f1303_0(final X509Certificate cert)
{    try {        final Collection<List<?>> entries = cert.getSubjectAlternativeNames();        if (entries == null) {            return Collections.emptyList();        }        final List<SubjectName> result = new ArrayList<SubjectName>();        for (List<?> entry : entries) {            final Integer type = entry.size() >= 2 ? (Integer) entry.get(0) : null;            if (type != null) {                final String s = (String) entry.get(1);                result.add(new SubjectName(s, type));            }        }        return result;    } catch (final CertificateParsingException ignore) {        return Collections.emptyList();    }}
normaliseAddress
private static String zookeeper_f1304_0(final String hostname)
{    if (hostname == null) {        return hostname;    }    try {        final InetAddress inetAddress = InetAddress.getByName(hostname);        return inetAddress.getHostAddress();    } catch (final UnknownHostException unexpected) {                return hostname;    }}
getAcceptedIssuers
public X509Certificate[] zookeeper_f1305_0()
{    return x509ExtendedTrustManager.getAcceptedIssuers();}
checkClientTrusted
public void zookeeper_f1306_0(X509Certificate[] chain, String authType, Socket socket) throws CertificateException
{    x509ExtendedTrustManager.checkClientTrusted(chain, authType, socket);    if (clientHostnameVerificationEnabled) {        performHostVerification(socket.getInetAddress(), chain[0]);    }}
checkServerTrusted
public void zookeeper_f1307_0(X509Certificate[] chain, String authType, Socket socket) throws CertificateException
{    x509ExtendedTrustManager.checkServerTrusted(chain, authType, socket);    if (serverHostnameVerificationEnabled) {        performHostVerification(socket.getInetAddress(), chain[0]);    }}
checkClientTrusted
public void zookeeper_f1308_0(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException
{    x509ExtendedTrustManager.checkClientTrusted(chain, authType, engine);    if (clientHostnameVerificationEnabled) {        try {            performHostVerification(InetAddress.getByName(engine.getPeerHost()), chain[0]);        } catch (UnknownHostException e) {            throw new CertificateException("Failed to verify host", e);        }    }}
checkServerTrusted
public void zookeeper_f1309_0(X509Certificate[] chain, String authType, SSLEngine engine) throws CertificateException
{    x509ExtendedTrustManager.checkServerTrusted(chain, authType, engine);    if (serverHostnameVerificationEnabled) {        try {            performHostVerification(InetAddress.getByName(engine.getPeerHost()), chain[0]);        } catch (UnknownHostException e) {            throw new CertificateException("Failed to verify host", e);        }    }}
checkClientTrusted
public void zookeeper_f1310_0(X509Certificate[] chain, String authType) throws CertificateException
{    x509ExtendedTrustManager.checkClientTrusted(chain, authType);}
checkServerTrusted
public void zookeeper_f1311_0(X509Certificate[] chain, String authType) throws CertificateException
{    x509ExtendedTrustManager.checkServerTrusted(chain, authType);}
performHostVerification
private voidf1312_1InetAddress inetAddress, X509Certificate certificate) throws CertificateException
{    String hostAddress = "";    String hostName = "";    try {        hostAddress = inetAddress.getHostAddress();        hostnameVerifier.verify(hostAddress, certificate);    } catch (SSLException addressVerificationException) {        try {                        hostName = inetAddress.getHostName();            hostnameVerifier.verify(hostName, certificate);        } catch (SSLException hostnameVerificationException) {                                    throw new CertificateException("Failed to verify both host address and host name", hostnameVerificationException);        }    }}
isEphemeral
public boolean zookeeper_f1313_0()
{    return ephemeral;}
isSequential
public boolean zookeeper_f1314_0()
{    return sequential;}
isContainer
public boolean zookeeper_f1315_0()
{    return isContainer;}
isTTL
public boolean zookeeper_f1316_0()
{    return isTTL;}
toFlag
public int zookeeper_f1317_0()
{    return flag;}
fromFlag
public static CreateModef1318_1int flag) throws KeeperException
{    switch(flag) {        case 0:            return CreateMode.PERSISTENT;        case 1:            return CreateMode.EPHEMERAL;        case 2:            return CreateMode.PERSISTENT_SEQUENTIAL;        case 3:            return CreateMode.EPHEMERAL_SEQUENTIAL;        case 4:            return CreateMode.CONTAINER;        case 5:            return CreateMode.PERSISTENT_WITH_TTL;        case 6:            return CreateMode.PERSISTENT_SEQUENTIAL_WITH_TTL;        default:            String errMsg = "Received an invalid flag value: " + flag + " to convert to a CreateMode";                        throw new KeeperException.BadArgumentsException(errMsg);    }}
fromFlag
public static CreateMode zookeeper_f1319_0(int flag, CreateMode defaultMode)
{    switch(flag) {        case 0:            return CreateMode.PERSISTENT;        case 1:            return CreateMode.EPHEMERAL;        case 2:            return CreateMode.PERSISTENT_SEQUENTIAL;        case 3:            return CreateMode.EPHEMERAL_SEQUENTIAL;        case 4:            return CreateMode.CONTAINER;        case 5:            return CreateMode.PERSISTENT_WITH_TTL;        case 6:            return CreateMode.PERSISTENT_SEQUENTIAL_WITH_TTL;        default:            return defaultMode;    }}
getKey
public String zookeeper_f1320_0()
{    return k;}
getValue
public String zookeeper_f1321_0()
{    return v;}
toString
public String zookeeper_f1322_0()
{    return k + "=" + v;}
put
private static void zookeeper_f1323_0(List<Entry> l, String k, String v)
{    l.add(new Entry(k, v));}
list
public static List<Entry> zookeeper_f1324_0()
{    List<Entry> l = new ArrayList<Entry>();    put(l, "zookeeper.version", Version.getFullVersion());    try {        put(l, "host.name", InetAddress.getLocalHost().getCanonicalHostName());    } catch (UnknownHostException e) {        put(l, "host.name", "<NA>");    }    put(l, "java.version", System.getProperty("java.version", "<NA>"));    put(l, "java.vendor", System.getProperty("java.vendor", "<NA>"));    put(l, "java.home", System.getProperty("java.home", "<NA>"));    put(l, "java.class.path", System.getProperty("java.class.path", "<NA>"));    put(l, "java.library.path", System.getProperty("java.library.path", "<NA>"));    put(l, "java.io.tmpdir", System.getProperty("java.io.tmpdir", "<NA>"));    put(l, "java.compiler", System.getProperty("java.compiler", "<NA>"));    put(l, "os.name", System.getProperty("os.name", "<NA>"));    put(l, "os.arch", System.getProperty("os.arch", "<NA>"));    put(l, "os.version", System.getProperty("os.version", "<NA>"));    put(l, "user.name", System.getProperty("user.name", "<NA>"));    put(l, "user.home", System.getProperty("user.home", "<NA>"));    put(l, "user.dir", System.getProperty("user.dir", "<NA>"));        Runtime runtime = Runtime.getRuntime();    int mb = 1024 * 1024;    put(l, "os.memory.free", runtime.freeMemory() / mb + "MB");    put(l, "os.memory.max", runtime.maxMemory() / mb + "MB");    put(l, "os.memory.total", runtime.totalMemory() / mb + "MB");    return l;}
logEnv
public static voidf1325_1String msg, Logger log)
{    List<Entry> env = Environment.list();    for (Entry e : env) {            }}
complete
public int zookeeper_f1326_0(String buffer, int cursor, List candidates)
{        buffer = buffer.substring(0, cursor);    String token = "";    if (!buffer.endsWith(" ")) {        String[] tokens = buffer.split(" ");        if (tokens.length != 0) {            token = tokens[tokens.length - 1];        }    }    if (token.startsWith("/")) {        return completeZNode(buffer, token, candidates);    }    return completeCommand(buffer, token, candidates);}
completeCommand
private int zookeeper_f1327_0(String buffer, String token, List<String> candidates)
{    for (String cmd : ZooKeeperMain.getCommands()) {        if (cmd.startsWith(token)) {            candidates.add(cmd);        }    }    return buffer.lastIndexOf(" ") + 1;}
completeZNode
private int zookeeper_f1328_0(String buffer, String token, List<String> candidates)
{    String path = token;    int idx = path.lastIndexOf("/") + 1;    String prefix = path.substring(idx);    try {                String dir = idx == 1 ? "/" : path.substring(0, idx - 1);        List<String> children = zk.getChildren(dir, false);        for (String child : children) {            if (child.startsWith(prefix)) {                candidates.add(child);            }        }    } catch (InterruptedException e) {        return 0;    } catch (KeeperException e) {        return 0;    }    Collections.sort(candidates);    return candidates.size() == 0 ? buffer.length() : buffer.lastIndexOf("/") + 1;}
isLog4jJmxEnabled
private static booleanf1329_1)
{    boolean enabled = false;    try {        Class.forName("org.apache.log4j.spi.LoggerRepository");        if (Boolean.getBoolean("zookeeper.jmx.log4j.disable")) {                    } else {            enabled = true;                    }    } catch (ClassNotFoundException e) {            }    return enabled;}
registerLog4jMBeans
public static voidf1330_1) throws JMException
{    if (isLog4jJmxEnabled()) {                MBeanServer mbs = MBeanRegistry.getInstance().getPlatformMBeanServer();        try {                                    Object hdm = Class.forName("org.apache.log4j.jmx.HierarchyDynamicMBean").getConstructor().newInstance();            String mbean = System.getProperty("zookeeper.jmx.log4j.mbean", "log4j:hierarchy=default");            ObjectName mbo = new ObjectName(mbean);            mbs.registerMBean(hdm, mbo);                                                Object rootLogger = Class.forName("org.apache.log4j.Logger").getMethod("getRootLogger", (Class<?>[]) null).invoke(null, (Object[]) null);                        Object rootLoggerName = rootLogger.getClass().getMethod("getName", (Class<?>[]) null).invoke(rootLogger, (Object[]) null);            hdm.getClass().getMethod("addLoggerMBean", String.class).invoke(hdm, rootLoggerName);                                                            Object r = Class.forName("org.apache.log4j.LogManager").getMethod("getLoggerRepository", (Class<?>[]) null).invoke(null, (Object[]) null);                        Enumeration enumer = (Enumeration) r.getClass().getMethod("getCurrentLoggers", (Class<?>[]) null).invoke(r, (Object[]) null);            while (enumer.hasMoreElements()) {                Object logger = enumer.nextElement();                                Object loggerName = logger.getClass().getMethod("getName", (Class<?>[]) null).invoke(logger, (Object[]) null);                hdm.getClass().getMethod("addLoggerMBean", String.class).invoke(hdm, loggerName);            }        } catch (Exception e) {                        throw new JMException(e.toString());        }    }}
setInstance
public static void zookeeper_f1331_0(MBeanRegistry instance)
{    MBeanRegistry.instance = instance;}
getInstance
public static MBeanRegistry zookeeper_f1332_0()
{    return instance;}
getPlatformMBeanServer
public MBeanServer zookeeper_f1333_0()
{    return mBeanServer;}
register
public voidf1334_1ZKMBeanInfo bean, ZKMBeanInfo parent) throws JMException
{    assert bean != null;    String path = null;    if (parent != null) {        path = mapBean2Path.get(parent);        assert path != null;    }    path = makeFullPath(path, parent);    if (bean.isHidden()) {        return;    }    ObjectName oname = makeObjectName(path, bean);    try {        synchronized (LOCK) {            mBeanServer.registerMBean(bean, oname);            mapBean2Path.put(bean, path);        }    } catch (JMException e) {                throw e;    }}
unregister
private voidf1335_1String path, ZKMBeanInfo bean) throws JMException
{    if (path == null) {        return;    }    if (!bean.isHidden()) {        final ObjectName objName = makeObjectName(path, bean);                synchronized (LOCK) {            mBeanServer.unregisterMBean(objName);        }    }}
getRegisteredBeans
public Set<ZKMBeanInfo> zookeeper_f1336_0()
{    return new HashSet<ZKMBeanInfo>(mapBean2Path.keySet());}
unregister
public voidf1337_1ZKMBeanInfo bean)
{    if (bean == null) {        return;    }    String path = mapBean2Path.remove(bean);    try {        unregister(path, bean);    } catch (JMException e) {            } catch (Throwable t) {            }}
makeFullPath
public String zookeeper_f1338_0(String prefix, String... name)
{    StringBuilder sb = new StringBuilder(prefix == null ? "/" : (prefix.equals("/") ? prefix : prefix + "/"));    boolean first = true;    for (String s : name) {        if (s == null) {            continue;        }        if (!first) {            sb.append("/");        } else {            first = false;        }        sb.append(s);    }    return sb.toString();}
makeFullPath
protected String zookeeper_f1339_0(String prefix, ZKMBeanInfo bean)
{    return makeFullPath(prefix, bean == null ? null : bean.getName());}
tokenize
private int zookeeper_f1340_0(StringBuilder sb, String path, int index)
{    String[] tokens = path.split("/");    for (String s : tokens) {        if (s.length() == 0) {            continue;        }        sb.append("name").append(index++).append("=").append(s).append(",");    }    return index;}
makeObjectName
protected ObjectNamef1341_1String path, ZKMBeanInfo bean) throws MalformedObjectNameException
{    if (path == null) {        return null;    }    StringBuilder beanName = new StringBuilder(DOMAIN + ":");    int counter = 0;    counter = tokenize(beanName, path, counter);    tokenize(beanName, bean.getName(), counter);    beanName.deleteCharAt(beanName.length() - 1);    try {        return new ObjectName(beanName.toString());    } catch (MalformedObjectNameException e) {                throw e;    }}
create
public static KeeperException zookeeper_f1342_0(Code code, String path)
{    KeeperException r = create(code);    r.path = path;    return r;}
create
public static KeeperException zookeeper_f1343_0(int code, String path)
{    KeeperException r = create(Code.get(code));    r.path = path;    return r;}
create
public static KeeperException zookeeper_f1344_0(int code)
{    return create(Code.get(code));}
create
public static KeeperException zookeeper_f1345_0(Code code)
{    switch(code) {        case SYSTEMERROR:            return new SystemErrorException();        case RUNTIMEINCONSISTENCY:            return new RuntimeInconsistencyException();        case DATAINCONSISTENCY:            return new DataInconsistencyException();        case CONNECTIONLOSS:            return new ConnectionLossException();        case MARSHALLINGERROR:            return new MarshallingErrorException();        case UNIMPLEMENTED:            return new UnimplementedException();        case OPERATIONTIMEOUT:            return new OperationTimeoutException();        case NEWCONFIGNOQUORUM:            return new NewConfigNoQuorum();        case RECONFIGINPROGRESS:            return new ReconfigInProgress();        case BADARGUMENTS:            return new BadArgumentsException();        case APIERROR:            return new APIErrorException();        case NONODE:            return new NoNodeException();        case NOAUTH:            return new NoAuthException();        case BADVERSION:            return new BadVersionException();        case NOCHILDRENFOREPHEMERALS:            return new NoChildrenForEphemeralsException();        case NODEEXISTS:            return new NodeExistsException();        case INVALIDACL:            return new InvalidACLException();        case AUTHFAILED:            return new AuthFailedException();        case NOTEMPTY:            return new NotEmptyException();        case SESSIONEXPIRED:            return new SessionExpiredException();        case INVALIDCALLBACK:            return new InvalidCallbackException();        case SESSIONMOVED:            return new SessionMovedException();        case NOTREADONLY:            return new NotReadOnlyException();        case EPHEMERALONLOCALSESSION:            return new EphemeralOnLocalSessionException();        case NOWATCHER:            return new NoWatcherException();        case RECONFIGDISABLED:            return new ReconfigDisabledException();        case SESSIONCLOSEDREQUIRESASLAUTH:            return new SessionClosedRequireAuthException();        case REQUESTTIMEOUT:            return new RequestTimeoutException();        case OK:        default:            throw new IllegalArgumentException("Invalid exception code");    }}
setCode
public void zookeeper_f1346_0(int code)
{    this.code = Code.get(code);}
intValue
public int zookeeper_f1347_0()
{    return code;}
get
public static Code zookeeper_f1348_0(int code)
{    return lookup.get(code);}
getCodeMessage
 static String zookeeper_f1349_0(Code code)
{    switch(code) {        case OK:            return "ok";        case SYSTEMERROR:            return "SystemError";        case RUNTIMEINCONSISTENCY:            return "RuntimeInconsistency";        case DATAINCONSISTENCY:            return "DataInconsistency";        case CONNECTIONLOSS:            return "ConnectionLoss";        case MARSHALLINGERROR:            return "MarshallingError";        case NEWCONFIGNOQUORUM:            return "NewConfigNoQuorum";        case RECONFIGINPROGRESS:            return "ReconfigInProgress";        case UNIMPLEMENTED:            return "Unimplemented";        case OPERATIONTIMEOUT:            return "OperationTimeout";        case BADARGUMENTS:            return "BadArguments";        case APIERROR:            return "APIError";        case NONODE:            return "NoNode";        case NOAUTH:            return "NoAuth";        case BADVERSION:            return "BadVersion";        case NOCHILDRENFOREPHEMERALS:            return "NoChildrenForEphemerals";        case NODEEXISTS:            return "NodeExists";        case INVALIDACL:            return "InvalidACL";        case AUTHFAILED:            return "AuthFailed";        case NOTEMPTY:            return "Directory not empty";        case SESSIONEXPIRED:            return "Session expired";        case INVALIDCALLBACK:            return "Invalid callback";        case SESSIONMOVED:            return "Session moved";        case NOTREADONLY:            return "Not a read-only call";        case EPHEMERALONLOCALSESSION:            return "Ephemeral node on local session";        case NOWATCHER:            return "No such watcher";        case RECONFIGDISABLED:            return "Reconfig is disabled";        case SESSIONCLOSEDREQUIRESASLAUTH:            return "Session closed because client failed to authenticate";        default:            return "Unknown error " + code;    }}
getCode
public int zookeeper_f1350_0()
{    return code.code;}
code
public Code zookeeper_f1351_0()
{    return code;}
getPath
public String zookeeper_f1352_0()
{    return path;}
getMessage
public String zookeeper_f1353_0()
{    if (path == null || path.isEmpty()) {        return "KeeperErrorCode = " + getCodeMessage(code);    }    return "KeeperErrorCode = " + getCodeMessage(code) + " for " + path;}
setMultiResults
 void zookeeper_f1354_0(List<OpResult> results)
{    this.results = results;}
getResults
public List<OpResult> zookeeper_f1355_0()
{    return results != null ? new ArrayList<OpResult>(results) : null;}
startThreadIfNeeded
public void zookeeper_f1357_0()
{        if (t != null) {        t.start();    }}
shutdown
public voidf1358_1)
{    if ((t != null) && (t.isAlive())) {        t.interrupt();        try {            t.join();        } catch (InterruptedException e) {                    }    }}
getSubject
public Subject zookeeper_f1359_0()
{    return subject;}
getLoginContextName
public String zookeeper_f1360_0()
{    return loginContextName;}
login
private synchronized LoginContextf1361_1final String loginContextName) throws LoginException
{    if (loginContextName == null) {        throw new LoginException("loginContext name (JAAS file section header) was null. " + "Please check your java.security.login.auth.config (=" + System.getProperty("java.security.login.auth.config") + ") and your " + getLoginContextMessage());    }    LoginContext loginContext = new LoginContext(loginContextName, callbackHandler);    loginContext.login();        return loginContext;}
getLoginContextMessage
private String zookeeper_f1362_0()
{    if (zkConfig instanceof ZKClientConfig) {        return ZKClientConfig.LOGIN_CONTEXT_NAME_KEY + "(=" + zkConfig.getProperty(ZKClientConfig.LOGIN_CONTEXT_NAME_KEY, ZKClientConfig.LOGIN_CONTEXT_NAME_KEY_DEFAULT) + ")";    } else {        return ZooKeeperSaslServer.LOGIN_CONTEXT_NAME_KEY + "(=" + System.getProperty(ZooKeeperSaslServer.LOGIN_CONTEXT_NAME_KEY, ZooKeeperSaslServer.DEFAULT_LOGIN_CONTEXT_NAME) + ")";    }}
getRefreshTime
private longf1363_1KerberosTicket tgt)
{    long start = tgt.getStartTime().getTime();    long expires = tgt.getEndTime().getTime();            long proposedRefresh = start + (long) ((expires - start) * (TICKET_RENEW_WINDOW + (TICKET_RENEW_JITTER * rng.nextDouble())));    if (proposedRefresh > expires) {                return Time.currentWallTime();    } else {        return proposedRefresh;    }}
getTGT
private synchronized KerberosTicketf1364_1)
{    Set<KerberosTicket> tickets = subject.getPrivateCredentials(KerberosTicket.class);    for (KerberosTicket ticket : tickets) {        KerberosPrincipal server = ticket.getServer();        if (server.getName().equals("krbtgt/" + server.getRealm() + "@" + server.getRealm())) {                                    return ticket;        }    }    return null;}
hasSufficientTimeElapsed
private booleanf1365_1)
{    long now = Time.currentElapsedTime();    if (now - getLastLogin() < MIN_TIME_BEFORE_RELOGIN) {                return false;    }        setLastLogin(now);    return true;}
getLogin
private LoginContext zookeeper_f1366_0()
{    return login;}
setLogin
private void zookeeper_f1367_0(LoginContext login)
{    this.login = login;}
setLastLogin
private void zookeeper_f1368_0(long time)
{    lastLogin = time;}
getLastLogin
private long zookeeper_f1369_0()
{    return lastLogin;}
reLogin
private synchronized voidf1370_1) throws LoginException
{    if (!isKrbTicket) {        return;    }    LoginContext login = getLogin();    if (login == null) {        throw new LoginException("login must be done first");    }    if (!hasSufficientTimeElapsed()) {        return;    }        synchronized (Login.class) {                                login.logout();                        login = new LoginContext(loginContextName, getSubject());                login.login();        setLogin(login);    }}
inc
 void zookeeper_f1371_0()
{    add(1);}
configure
public void zookeeper_f1372_0(Properties configuration) throws MetricsProviderLifeCycleException
{}
start
public void zookeeper_f1373_0() throws MetricsProviderLifeCycleException
{}
getRootContext
public MetricsContext zookeeper_f1374_0()
{    return rootMetricsContext;}
stop
public void zookeeper_f1375_0()
{        rootMetricsContext.gauges.clear();}
dump
public void zookeeper_f1376_0(BiConsumer<String, Object> sink)
{    rootMetricsContext.dump(sink);}
resetAllValues
public void zookeeper_f1377_0()
{    rootMetricsContext.reset();}
getContext
public MetricsContext zookeeper_f1378_0(String name)
{        return this;}
getCounter
public Counter zookeeper_f1379_0(String name)
{    return counters.computeIfAbsent(name, (n) -> {        return new SimpleCounter(n);    });}
registerGauge
public void zookeeper_f1380_0(String name, Gauge gauge)
{    Objects.requireNonNull(gauge, "Cannot register a null Gauge for " + name);    gauges.put(name, gauge);}
unregisterGauge
public void zookeeper_f1381_0(String name)
{    gauges.remove(name);}
getSummary
public Summary zookeeper_f1382_0(String name, DetailLevel detailLevel)
{    if (detailLevel == DetailLevel.BASIC) {        return basicSummaries.computeIfAbsent(name, (n) -> {            if (summaries.containsKey(n)) {                throw new IllegalArgumentException("Already registered a non basic summary as " + n);            }            return new AvgMinMaxCounter(name);        });    } else {        return summaries.computeIfAbsent(name, (n) -> {            if (basicSummaries.containsKey(n)) {                throw new IllegalArgumentException("Already registered a basic summary as " + n);            }            return new AvgMinMaxPercentileCounter(name);        });    }}
getSummarySet
public SummarySet zookeeper_f1383_0(String name, DetailLevel detailLevel)
{    if (detailLevel == DetailLevel.BASIC) {        return basicSummarySets.computeIfAbsent(name, (n) -> {            if (summarySets.containsKey(n)) {                throw new IllegalArgumentException("Already registered a non basic summary set as " + n);            }            return new AvgMinMaxCounterSet(name);        });    } else {        return summarySets.computeIfAbsent(name, (n) -> {            if (basicSummarySets.containsKey(n)) {                throw new IllegalArgumentException("Already registered a basic summary set as " + n);            }            return new AvgMinMaxPercentileCounterSet(name);        });    }}
dump
 void zookeeper_f1384_0(BiConsumer<String, Object> sink)
{    gauges.forEach((name, metric) -> {        Number value = metric.get();        if (value != null) {            sink.accept(name, value);        }    });    counters.values().forEach(metric -> {        metric.values().forEach(sink);    });    basicSummaries.values().forEach(metric -> {        metric.values().forEach(sink);    });    summaries.values().forEach(metric -> {        metric.values().forEach(sink);    });    basicSummarySets.values().forEach(metric -> {        metric.values().forEach(sink);    });    summarySets.values().forEach(metric -> {        metric.values().forEach(sink);    });}
reset
 void zookeeper_f1385_0()
{    counters.values().forEach(metric -> {        metric.reset();    });    basicSummaries.values().forEach(metric -> {        metric.reset();    });    summaries.values().forEach(metric -> {        metric.reset();    });    basicSummarySets.values().forEach(metric -> {        metric.reset();    });    summarySets.values().forEach(metric -> {        metric.reset();    });}
startMetricsProvider
public static MetricsProviderf1386_1String metricsProviderClassName, Properties configuration) throws MetricsProviderLifeCycleException
{    try {        Class<?> clazz = Class.forName(metricsProviderClassName, true, Thread.currentThread().getContextClassLoader());        MetricsProvider metricsProvider = (MetricsProvider) clazz.getConstructor().newInstance();        metricsProvider.configure(configuration);        metricsProvider.start();        return metricsProvider;    } catch (ClassNotFoundException | IllegalAccessException | InvocationTargetException | NoSuchMethodException | InstantiationException error) {                throw new MetricsProviderLifeCycleException("Cannot boot MetricsProvider " + metricsProviderClassName, error);    } catch (MetricsProviderLifeCycleException error) {                throw error;    }}
configure
public void zookeeper_f1387_0(Properties configuration) throws MetricsProviderLifeCycleException
{}
start
public void zookeeper_f1388_0() throws MetricsProviderLifeCycleException
{}
getRootContext
public MetricsContext zookeeper_f1389_0()
{    return NullMetricsContext.INSTANCE;}
dump
public void zookeeper_f1390_0(BiConsumer<String, Object> sink)
{}
resetAllValues
public void zookeeper_f1391_0()
{}
stop
public void zookeeper_f1392_0()
{}
getContext
public MetricsContext zookeeper_f1393_0(String name)
{    return INSTANCE;}
getCounter
public Counter zookeeper_f1394_0(String name)
{    return NullCounter.INSTANCE;}
registerGauge
public void zookeeper_f1395_0(String name, Gauge gauge)
{}
unregisterGauge
public void zookeeper_f1396_0(String name)
{}
getSummary
public Summary zookeeper_f1397_0(String name, DetailLevel detailLevel)
{    return NullSummary.INSTANCE;}
getSummarySet
public SummarySet zookeeper_f1398_0(String name, DetailLevel detailLevel)
{    return NullSummarySet.INSTANCE;}
add
public void zookeeper_f1399_0(long delta)
{}
get
public long zookeeper_f1400_0()
{    return 0;}
add
public void zookeeper_f1401_0(long value)
{}
add
public void zookeeper_f1402_0(String key, long value)
{}
iterator
public Iterator<Op> zookeeper_f1403_0()
{    return ops.iterator();}
add
public void zookeeper_f1404_0(Op op) throws IllegalArgumentException
{    setOrCheckOpKind(op.getKind());    ops.add(op);}
size
public int zookeeper_f1405_0()
{    return ops.size();}
getOpKind
public Op.OpKind zookeeper_f1406_0()
{    return opKind;}
setOrCheckOpKind
private void zookeeper_f1407_0(Op.OpKind ok) throws IllegalArgumentException
{    if (opKind == null) {        opKind = ok;    } else if (ok != opKind) {        throw new IllegalArgumentException("Mixing read and write operations (transactions)" + " is not allowed in a multi request.");    }}
serialize
public void zookeeper_f1408_0(OutputArchive archive, String tag) throws IOException
{    archive.startRecord(this, tag);    for (Op op : ops) {        MultiHeader h = new MultiHeader(op.getType(), false, -1);        h.serialize(archive, tag);        switch(op.getType()) {            case ZooDefs.OpCode.create:            case ZooDefs.OpCode.create2:            case ZooDefs.OpCode.createTTL:            case ZooDefs.OpCode.createContainer:            case ZooDefs.OpCode.delete:            case ZooDefs.OpCode.setData:            case ZooDefs.OpCode.check:            case ZooDefs.OpCode.getChildren:            case ZooDefs.OpCode.getData:                op.toRequestRecord().serialize(archive, tag);                break;            default:                throw new IOException("Invalid type of op");        }    }    new MultiHeader(-1, true, -1).serialize(archive, tag);    archive.endRecord(this, tag);}
deserialize
public void zookeeper_f1409_0(InputArchive archive, String tag) throws IOException
{    archive.startRecord(tag);    MultiHeader h = new MultiHeader();    h.deserialize(archive, tag);    try {        while (!h.getDone()) {            switch(h.getType()) {                case ZooDefs.OpCode.create:                case ZooDefs.OpCode.create2:                case ZooDefs.OpCode.createContainer:                    CreateRequest cr = new CreateRequest();                    cr.deserialize(archive, tag);                    add(Op.create(cr.getPath(), cr.getData(), cr.getAcl(), cr.getFlags()));                    break;                case ZooDefs.OpCode.createTTL:                    CreateTTLRequest crTtl = new CreateTTLRequest();                    crTtl.deserialize(archive, tag);                    add(Op.create(crTtl.getPath(), crTtl.getData(), crTtl.getAcl(), crTtl.getFlags(), crTtl.getTtl()));                    break;                case ZooDefs.OpCode.delete:                    DeleteRequest dr = new DeleteRequest();                    dr.deserialize(archive, tag);                    add(Op.delete(dr.getPath(), dr.getVersion()));                    break;                case ZooDefs.OpCode.setData:                    SetDataRequest sdr = new SetDataRequest();                    sdr.deserialize(archive, tag);                    add(Op.setData(sdr.getPath(), sdr.getData(), sdr.getVersion()));                    break;                case ZooDefs.OpCode.check:                    CheckVersionRequest cvr = new CheckVersionRequest();                    cvr.deserialize(archive, tag);                    add(Op.check(cvr.getPath(), cvr.getVersion()));                    break;                case ZooDefs.OpCode.getChildren:                    GetChildrenRequest gcr = new GetChildrenRequest();                    gcr.deserialize(archive, tag);                    add(Op.getChildren(gcr.getPath()));                    break;                case ZooDefs.OpCode.getData:                    GetDataRequest gdr = new GetDataRequest();                    gdr.deserialize(archive, tag);                    add(Op.getData(gdr.getPath()));                    break;                default:                    throw new IOException("Invalid type of op");            }            h.deserialize(archive, tag);        }    } catch (IllegalArgumentException e) {        throw new IOException("Mixing different kind of ops");    }    archive.endRecord(tag);}
equals
public boolean zookeeper_f1410_0(Object o)
{    if (this == o) {        return true;    }    if (!(o instanceof MultiOperationRecord)) {        return false;    }    MultiOperationRecord that = (MultiOperationRecord) o;    if (ops != null) {        Iterator<Op> other = that.ops.iterator();        for (Op op : ops) {            boolean hasMoreData = other.hasNext();            if (!hasMoreData) {                return false;            }            Op otherOp = other.next();            if (!op.equals(otherOp)) {                return false;            }        }        return !other.hasNext();    } else {        return that.ops == null;    }}
hashCode
public int zookeeper_f1411_0()
{    int h = 1023;    for (Op op : ops) {        h = h * 25 + op.hashCode();    }    return h;}
add
public void zookeeper_f1412_0(OpResult x)
{    results.add(x);}
iterator
public Iterator<OpResult> zookeeper_f1413_0()
{    return results.iterator();}
size
public int zookeeper_f1414_0()
{    return results.size();}
serialize
public void zookeeper_f1415_0(OutputArchive archive, String tag) throws IOException
{    archive.startRecord(this, tag);    for (OpResult result : results) {        int err = result.getType() == ZooDefs.OpCode.error ? ((OpResult.ErrorResult) result).getErr() : 0;        new MultiHeader(result.getType(), false, err).serialize(archive, tag);        switch(result.getType()) {            case ZooDefs.OpCode.create:                new CreateResponse(((OpResult.CreateResult) result).getPath()).serialize(archive, tag);                break;            case ZooDefs.OpCode.create2:                OpResult.CreateResult createResult = (OpResult.CreateResult) result;                new Create2Response(createResult.getPath(), createResult.getStat()).serialize(archive, tag);                break;            case ZooDefs.OpCode.delete:            case ZooDefs.OpCode.check:                break;            case ZooDefs.OpCode.setData:                new SetDataResponse(((OpResult.SetDataResult) result).getStat()).serialize(archive, tag);                break;            case ZooDefs.OpCode.getChildren:                new GetChildrenResponse(((OpResult.GetChildrenResult) result).getChildren()).serialize(archive, tag);                break;            case ZooDefs.OpCode.getData:                new GetDataResponse(((OpResult.GetDataResult) result).getData(), ((OpResult.GetDataResult) result).getStat()).serialize(archive, tag);                break;            case ZooDefs.OpCode.error:                new ErrorResponse(((OpResult.ErrorResult) result).getErr()).serialize(archive, tag);                break;            default:                throw new IOException("Invalid type " + result.getType() + " in MultiResponse");        }    }    new MultiHeader(-1, true, -1).serialize(archive, tag);    archive.endRecord(this, tag);}
deserialize
public void zookeeper_f1416_0(InputArchive archive, String tag) throws IOException
{    results = new ArrayList<OpResult>();    archive.startRecord(tag);    MultiHeader h = new MultiHeader();    h.deserialize(archive, tag);    while (!h.getDone()) {        switch(h.getType()) {            case ZooDefs.OpCode.create:                CreateResponse cr = new CreateResponse();                cr.deserialize(archive, tag);                results.add(new OpResult.CreateResult(cr.getPath()));                break;            case ZooDefs.OpCode.create2:                Create2Response cr2 = new Create2Response();                cr2.deserialize(archive, tag);                results.add(new OpResult.CreateResult(cr2.getPath(), cr2.getStat()));                break;            case ZooDefs.OpCode.delete:                results.add(new OpResult.DeleteResult());                break;            case ZooDefs.OpCode.setData:                SetDataResponse sdr = new SetDataResponse();                sdr.deserialize(archive, tag);                results.add(new OpResult.SetDataResult(sdr.getStat()));                break;            case ZooDefs.OpCode.check:                results.add(new OpResult.CheckResult());                break;            case ZooDefs.OpCode.getChildren:                GetChildrenResponse gcr = new GetChildrenResponse();                gcr.deserialize(archive, tag);                results.add(new OpResult.GetChildrenResult(gcr.getChildren()));                break;            case ZooDefs.OpCode.getData:                GetDataResponse gdr = new GetDataResponse();                gdr.deserialize(archive, tag);                results.add(new OpResult.GetDataResult(gdr.getData(), gdr.getStat()));                break;            case ZooDefs.OpCode.error:                                ErrorResponse er = new ErrorResponse();                er.deserialize(archive, tag);                results.add(new OpResult.ErrorResult(er.getErr()));                break;            default:                throw new IOException("Invalid type " + h.getType() + " in MultiResponse");        }        h.deserialize(archive, tag);    }    archive.endRecord(tag);}
getResultList
public List<OpResult> zookeeper_f1417_0()
{    return results;}
equals
public boolean zookeeper_f1418_0(Object o)
{    if (this == o) {        return true;    }    if (!(o instanceof MultiResponse)) {        return false;    }    MultiResponse other = (MultiResponse) o;    if (results != null) {        Iterator<OpResult> i = other.results.iterator();        for (OpResult result : results) {            if (i.hasNext()) {                if (!result.equals(i.next())) {                    return false;                }            } else {                return false;            }        }        return !i.hasNext();    } else {        return other.results == null;    }}
hashCode
public int zookeeper_f1419_0()
{    int hash = results.size();    for (OpResult result : results) {        hash = (hash * 35) + result.hashCode();    }    return hash;}
create
public static Op zookeeper_f1420_0(String path, byte[] data, List<ACL> acl, int flags)
{    return new Create(path, data, acl, flags);}
create
public static Op zookeeper_f1421_0(String path, byte[] data, List<ACL> acl, int flags, long ttl)
{    CreateMode createMode = CreateMode.fromFlag(flags, CreateMode.PERSISTENT);    if (createMode.isTTL()) {        return new CreateTTL(path, data, acl, createMode, ttl);    }    return new Create(path, data, acl, flags);}
create
public static Op zookeeper_f1422_0(String path, byte[] data, List<ACL> acl, CreateMode createMode)
{    return new Create(path, data, acl, createMode);}
create
public static Op zookeeper_f1423_0(String path, byte[] data, List<ACL> acl, CreateMode createMode, long ttl)
{    if (createMode.isTTL()) {        return new CreateTTL(path, data, acl, createMode, ttl);    }    return new Create(path, data, acl, createMode);}
delete
public static Op zookeeper_f1424_0(String path, int version)
{    return new Delete(path, version);}
setData
public static Op zookeeper_f1425_0(String path, byte[] data, int version)
{    return new SetData(path, data, version);}
check
public static Op zookeeper_f1426_0(String path, int version)
{    return new Check(path, version);}
getChildren
public static Op zookeeper_f1427_0(String path)
{    return new GetChildren(path);}
getData
public static Op zookeeper_f1428_0(String path)
{    return new GetData(path);}
getType
public int zookeeper_f1429_0()
{    return type;}
getPath
public String zookeeper_f1430_0()
{    return path;}
getKind
public OpKind zookeeper_f1431_0()
{    return opKind;}
validate
 void zookeeper_f1432_0() throws KeeperException
{    PathUtils.validatePath(path);}
getOpcode
private static int zookeeper_f1433_0(CreateMode createMode)
{    if (createMode.isTTL()) {        return ZooDefs.OpCode.createTTL;    }    return createMode.isContainer() ? ZooDefs.OpCode.createContainer : ZooDefs.OpCode.create;}
equals
public boolean zookeeper_f1434_0(Object o)
{    if (this == o) {        return true;    }    if (!(o instanceof Create)) {        return false;    }    Create op = (Create) o;    boolean aclEquals = true;    Iterator<ACL> i = op.acl.iterator();    for (ACL acl : op.acl) {        boolean hasMoreData = i.hasNext();        if (!hasMoreData) {            aclEquals = false;            break;        }        ACL otherAcl = i.next();        if (!acl.equals(otherAcl)) {            aclEquals = false;            break;        }    }    return !i.hasNext() && getType() == op.getType() && Arrays.equals(data, op.data) && flags == op.flags && aclEquals;}
hashCode
public int zookeeper_f1435_0()
{    return getType() + getPath().hashCode() + Arrays.hashCode(data);}
toRequestRecord
public Record zookeeper_f1436_0()
{    return new CreateRequest(getPath(), data, acl, flags);}
withChroot
 Op zookeeper_f1437_0(String path)
{    return new Create(path, data, acl, flags);}
validate
 void zookeeper_f1438_0() throws KeeperException
{    CreateMode createMode = CreateMode.fromFlag(flags);    PathUtils.validatePath(getPath(), createMode.isSequential());    EphemeralType.validateTTL(createMode, -1);}
equals
public boolean zookeeper_f1439_0(Object o)
{    return super.equals(o) && (o instanceof CreateTTL) && (ttl == ((CreateTTL) o).ttl);}
hashCode
public int zookeeper_f1440_0()
{    return super.hashCode() + (int) (ttl ^ (ttl >>> 32));}
toRequestRecord
public Record zookeeper_f1441_0()
{    return new CreateTTLRequest(getPath(), data, acl, flags, ttl);}
withChroot
 Op zookeeper_f1442_0(String path)
{    return new CreateTTL(path, data, acl, flags, ttl);}
validate
 void zookeeper_f1443_0() throws KeeperException
{    CreateMode createMode = CreateMode.fromFlag(flags);    PathUtils.validatePath(getPath(), createMode.isSequential());    EphemeralType.validateTTL(createMode, ttl);}
equals
public boolean zookeeper_f1444_0(Object o)
{    if (this == o) {        return true;    }    if (!(o instanceof Delete)) {        return false;    }    Delete op = (Delete) o;    return getType() == op.getType() && version == op.version && getPath().equals(op.getPath());}
hashCode
public int zookeeper_f1445_0()
{    return getType() + getPath().hashCode() + version;}
toRequestRecord
public Record zookeeper_f1446_0()
{    return new DeleteRequest(getPath(), version);}
withChroot
 Op zookeeper_f1447_0(String path)
{    return new Delete(path, version);}
equals
public boolean zookeeper_f1448_0(Object o)
{    if (this == o) {        return true;    }    if (!(o instanceof SetData)) {        return false;    }    SetData op = (SetData) o;    return getType() == op.getType() && version == op.version && getPath().equals(op.getPath()) && Arrays.equals(data, op.data);}
hashCode
public int zookeeper_f1449_0()
{    return getType() + getPath().hashCode() + Arrays.hashCode(data) + version;}
toRequestRecord
public Record zookeeper_f1450_0()
{    return new SetDataRequest(getPath(), data, version);}
withChroot
 Op zookeeper_f1451_0(String path)
{    return new SetData(path, data, version);}
equals
public boolean zookeeper_f1452_0(Object o)
{    if (this == o) {        return true;    }    if (!(o instanceof Check)) {        return false;    }    Check op = (Check) o;    return getType() == op.getType() && getPath().equals(op.getPath()) && version == op.version;}
hashCode
public int zookeeper_f1453_0()
{    return getType() + getPath().hashCode() + version;}
toRequestRecord
public Record zookeeper_f1454_0()
{    return new CheckVersionRequest(getPath(), version);}
withChroot
 Op zookeeper_f1455_0(String path)
{    return new Check(path, version);}
equals
public boolean zookeeper_f1456_0(Object o)
{    if (this == o) {        return true;    }    if (!(o instanceof GetChildren)) {        return false;    }    GetChildren op = (GetChildren) o;    return getType() == op.getType() && getPath().equals(op.getPath());}
hashCode
public int zookeeper_f1457_0()
{    return getType() + getPath().hashCode();}
toRequestRecord
public Record zookeeper_f1458_0()
{    return new GetChildrenRequest(getPath(), false);}
withChroot
 Op zookeeper_f1459_0(String path)
{    return new GetChildren(path);}
equals
public boolean zookeeper_f1460_0(Object o)
{    if (this == o) {        return true;    }    if (!(o instanceof GetData)) {        return false;    }    GetData op = (GetData) o;    return getType() == op.getType() && getPath().equals(op.getPath());}
hashCode
public int zookeeper_f1461_0()
{    return getType() + getPath().hashCode();}
toRequestRecord
public Record zookeeper_f1462_0()
{    return new GetDataRequest(getPath(), false);}
withChroot
 Op zookeeper_f1463_0(String path)
{    return new GetData(path);}
getType
public int zookeeper_f1464_0()
{    return type;}
getPath
public String zookeeper_f1465_0()
{    return path;}
getStat
public Stat zookeeper_f1466_0()
{    return stat;}
equals
public boolean zookeeper_f1467_0(Object o)
{    if (this == o) {        return true;    }    if (!(o instanceof CreateResult)) {        return false;    }    CreateResult other = (CreateResult) o;    boolean statsAreEqual = stat == null && other.stat == null || (stat != null && other.stat != null && stat.getMzxid() == other.stat.getMzxid());    return getType() == other.getType() && path.equals(other.getPath()) && statsAreEqual;}
hashCode
public int zookeeper_f1468_0()
{    return (int) (getType() * 35 + path.hashCode() + (stat == null ? 0 : stat.getMzxid()));}
equals
public boolean zookeeper_f1469_0(Object o)
{    if (this == o) {        return true;    }    if (!(o instanceof DeleteResult)) {        return false;    }    DeleteResult opResult = (DeleteResult) o;    return getType() == opResult.getType();}
hashCode
public int zookeeper_f1470_0()
{    return getType();}
getStat
public Stat zookeeper_f1471_0()
{    return stat;}
equals
public boolean zookeeper_f1472_0(Object o)
{    if (this == o) {        return true;    }    if (!(o instanceof SetDataResult)) {        return false;    }    SetDataResult other = (SetDataResult) o;    return getType() == other.getType() && stat.getMzxid() == other.stat.getMzxid();}
hashCode
public int zookeeper_f1473_0()
{    return (int) (getType() * 35 + stat.getMzxid());}
equals
public boolean zookeeper_f1474_0(Object o)
{    if (this == o) {        return true;    }    if (!(o instanceof CheckResult)) {        return false;    }    CheckResult other = (CheckResult) o;    return getType() == other.getType();}
hashCode
public int zookeeper_f1475_0()
{    return getType();}
getChildren
public List<String> zookeeper_f1476_0()
{    return children;}
equals
public boolean zookeeper_f1477_0(Object o)
{    if (this == o) {        return true;    }    if (!(o instanceof GetChildrenResult)) {        return false;    }    GetChildrenResult other = (GetChildrenResult) o;    return getType() == other.getType() && children.equals(other.children);}
hashCode
public int zookeeper_f1478_0()
{    return getType() * 35 + children.hashCode();}
getData
public byte[] zookeeper_f1479_0()
{    return data == null ? null : Arrays.copyOf(data, data.length);}
getStat
public Stat zookeeper_f1480_0()
{    return stat;}
equals
public boolean zookeeper_f1481_0(Object o)
{    if (this == o) {        return true;    }    if (!(o instanceof GetDataResult)) {        return false;    }    GetDataResult other = (GetDataResult) o;    return getType() == other.getType() && stat.equals(other.stat) && Arrays.equals(data, other.data);}
hashCode
public int zookeeper_f1482_0()
{    return (int) (getType() * 35 + stat.getMzxid() + Arrays.hashCode(data));}
getErr
public int zookeeper_f1483_0()
{    return err;}
equals
public boolean zookeeper_f1484_0(Object o)
{    if (this == o) {        return true;    }    if (!(o instanceof ErrorResult)) {        return false;    }    ErrorResult other = (ErrorResult) o;    return getType() == other.getType() && err == other.getErr();}
hashCode
public int zookeeper_f1485_0()
{    return getType() * 35 + err;}
quotaPath
public static String zookeeper_f1486_0(String path)
{    return quotaZookeeper + path + "/" + limitNode;}
statPath
public static String zookeeper_f1487_0(String path)
{    return quotaZookeeper + path + "/" + statNode;}
handle
public voidf1488_1Callback[] callbacks) throws UnsupportedCallbackException
{    for (Callback callback : callbacks) {        if (callback instanceof NameCallback) {            NameCallback nc = (NameCallback) callback;            nc.setName(nc.getDefaultName());        } else {            if (callback instanceof PasswordCallback) {                PasswordCallback pc = (PasswordCallback) callback;                if (password != null) {                    pc.setPassword(this.password.toCharArray());                } else {                                    }            } else {                if (callback instanceof RealmCallback) {                    RealmCallback rc = (RealmCallback) callback;                    rc.setText(rc.getDefaultText());                } else {                    if (callback instanceof AuthorizeCallback) {                        AuthorizeCallback ac = (AuthorizeCallback) callback;                        String authid = ac.getAuthenticationID();                        String authzid = ac.getAuthorizationID();                        if (authid.equals(authzid)) {                            ac.setAuthorized(true);                        } else {                            ac.setAuthorized(false);                        }                        if (ac.isAuthorized()) {                            ac.setAuthorizedID(authzid);                        }                    } else {                        throw new UnsupportedCallbackException(callback, "Unrecognized SASL " + entity + "Callback");                    }                }            }        }    }}
getServerPrincipal
 static String zookeeper_f1489_0(InetSocketAddress addr, ZKClientConfig clientConfig)
{    return getServerPrincipal(new WrapperInetSocketAddress(addr), clientConfig);}
getServerPrincipal
 static Stringf1490_1WrapperInetSocketAddress addr, ZKClientConfig clientConfig)
{    String principalUserName = clientConfig.getProperty(ZKClientConfig.ZK_SASL_CLIENT_USERNAME, ZKClientConfig.ZK_SASL_CLIENT_USERNAME_DEFAULT);    String hostName = addr.getHostName();    boolean canonicalize = true;    String canonicalizeText = clientConfig.getProperty(ZKClientConfig.ZK_SASL_CLIENT_CANONICALIZE_HOSTNAME, ZKClientConfig.ZK_SASL_CLIENT_CANONICALIZE_HOSTNAME_DEFAULT);    try {        canonicalize = Boolean.parseBoolean(canonicalizeText);    } catch (IllegalArgumentException ea) {            }    if (canonicalize) {        WrapperInetAddress ia = addr.getAddress();        if (ia == null) {            throw new IllegalArgumentException("Unable to canonicalize address " + addr + " because it's not resolvable");        }        String canonicalHostName = ia.getCanonicalHostName();                if (!canonicalHostName.equals(ia.getHostAddress())) {            hostName = canonicalHostName;        }            }    String serverPrincipal = principalUserName + "/" + hostName;    return serverPrincipal;}
getHostName
public String zookeeper_f1491_0()
{    return addr.getHostName();}
getAddress
public WrapperInetAddress zookeeper_f1492_0()
{    InetAddress ia = addr.getAddress();    return ia == null ? null : new WrapperInetAddress(ia);}
toString
public String zookeeper_f1493_0()
{    return addr.toString();}
getCanonicalHostName
public String zookeeper_f1494_0()
{    return ia.getCanonicalHostName();}
getHostAddress
public String zookeeper_f1495_0()
{    return ia.getHostAddress();}
toString
public String zookeeper_f1496_0()
{    return ia.toString();}
createAdminServer
public static AdminServerf1497_1)
{    if (!"false".equals(System.getProperty("zookeeper.admin.enableServer"))) {        try {            Class<?> jettyAdminServerC = Class.forName("org.apache.zookeeper.server.admin.JettyAdminServer");            Object adminServer = jettyAdminServerC.getConstructor().newInstance();            return (AdminServer) adminServer;        } catch (ClassNotFoundException e) {                    } catch (InstantiationException e) {                    } catch (IllegalAccessException e) {                    } catch (InvocationTargetException e) {                    } catch (NoSuchMethodException e) {                    } catch (NoClassDefFoundError e) {                    }    }    return new DummyAdminServer();}
getPrimaryName
public String zookeeper_f1498_0()
{    return primaryName;}
getNames
public Set<String> zookeeper_f1499_0()
{    return names;}
getDoc
public String zookeeper_f1500_0()
{    return doc;}
isServerRequired
public boolean zookeeper_f1501_0()
{    return serverRequired;}
initializeResponse
protected CommandResponse zookeeper_f1502_0()
{    return new CommandResponse(primaryName);}
getCommand
public String zookeeper_f1503_0()
{    return command;}
getError
public String zookeeper_f1504_0()
{    return error;}
put
public Object zookeeper_f1505_0(String key, Object value)
{    return data.put(key, value);}
putAll
public void zookeeper_f1506_0(Map<? extends String, ?> m)
{    data.putAll(m);}
toMap
public Map<String, Object> zookeeper_f1507_0()
{    Map<String, Object> m = new LinkedHashMap<String, Object>(data);    m.put(KEY_COMMAND, command);    m.put(KEY_ERROR, error);    m.putAll(data);    return m;}
registerCommand
public static voidf1508_1Command command)
{    for (String name : command.getNames()) {        Command prev = commands.put(name, command);        if (prev != null) {                    }    }    primaryNames.add(command.getPrimaryName());}
runCommand
public static CommandResponse zookeeper_f1509_0(String cmdName, ZooKeeperServer zkServer, Map<String, String> kwargs)
{    Command command = getCommand(cmdName);    if (command == null) {        return new CommandResponse(cmdName, "Unknown command: " + cmdName);    }    if (command.isServerRequired() && (zkServer == null || !zkServer.isRunning())) {        return new CommandResponse(cmdName, "This ZooKeeper instance is not currently serving requests");    }    return command.run(zkServer, kwargs);}
getPrimaryNames
public static Set<String> zookeeper_f1510_0()
{    return primaryNames;}
getCommand
public static Command zookeeper_f1511_0(String cmdName)
{    return commands.get(cmdName);}
run
public CommandResponse zookeeper_f1512_0(ZooKeeperServer zkServer, Map<String, String> kwargs)
{    CommandResponse response = initializeResponse();    zkServer.getServerCnxnFactory().resetAllConnectionStats();    return response;}
run
public CommandResponse zookeeper_f1513_0(ZooKeeperServer zkServer, Map<String, String> kwargs)
{    CommandResponse response = initializeResponse();    response.putAll(zkServer.getConf().toMap());    return response;}
run
public CommandResponse zookeeper_f1514_0(ZooKeeperServer zkServer, Map<String, String> kwargs)
{    CommandResponse response = initializeResponse();    ServerCnxnFactory serverCnxnFactory = zkServer.getServerCnxnFactory();    if (serverCnxnFactory != null) {        response.put("connections", serverCnxnFactory.getAllConnectionInfo(false));    } else {        response.put("connections", Collections.emptyList());    }    ServerCnxnFactory secureServerCnxnFactory = zkServer.getSecureServerCnxnFactory();    if (secureServerCnxnFactory != null) {        response.put("secure_connections", secureServerCnxnFactory.getAllConnectionInfo(false));    } else {        response.put("secure_connections", Collections.emptyList());    }    return response;}
run
public CommandResponse zookeeper_f1515_0(ZooKeeperServer zkServer, Map<String, String> kwargs)
{    CommandResponse response = initializeResponse();    response.put("datadir_size", zkServer.getDataDirSize());    response.put("logdir_size", zkServer.getLogDirSize());    return response;}
run
public CommandResponse zookeeper_f1516_0(ZooKeeperServer zkServer, Map<String, String> kwargs)
{    CommandResponse response = initializeResponse();    response.put("expiry_time_to_session_ids", zkServer.getSessionExpiryMap());    response.put("session_id_to_ephemeral_paths", zkServer.getEphemerals());    return response;}
run
public CommandResponse zookeeper_f1517_0(ZooKeeperServer zkServer, Map<String, String> kwargs)
{    CommandResponse response = initializeResponse();    for (Entry e : Environment.list()) {        response.put(e.getKey(), e.getValue());    }    return response;}
run
public CommandResponse zookeeper_f1518_0(ZooKeeperServer zkServer, Map<String, String> kwargs)
{    CommandResponse response = initializeResponse();    response.put("digests", zkServer.getZKDatabase().getDataTree().getDigestLog());    return response;}
run
public CommandResponse zookeeper_f1519_0(ZooKeeperServer zkServer, Map<String, String> kwargs)
{    CommandResponse response = initializeResponse();    response.put("tracemask", ZooTrace.getTextTraceLevel());    return response;}
run
public CommandResponse zookeeper_f1520_0(ZooKeeperServer zkServer, Map<String, String> kwargs)
{    CommandResponse response = initializeResponse();    response.put("initial_configuration", zkServer.getInitialConfig());    return response;}
run
public CommandResponse zookeeper_f1521_0(ZooKeeperServer zkServer, Map<String, String> kwargs)
{    CommandResponse response = initializeResponse();    response.put("read_only", zkServer instanceof ReadOnlyZooKeeperServer);    return response;}
run
public CommandResponse zookeeper_f1522_0(ZooKeeperServer zkServer, Map<String, String> kwargs)
{    CommandResponse response = initializeResponse();    SnapshotInfo info = zkServer.getTxnLogFactory().getLastSnapshotInfo();    response.put("zxid", Long.toHexString(info == null ? -1L : info.zxid));    response.put("timestamp", info == null ? -1L : info.timestamp);    return response;}
run
public CommandResponse zookeeper_f1523_0(ZooKeeperServer zkServer, Map<String, String> kwargs)
{    CommandResponse response = initializeResponse();    if (zkServer instanceof QuorumZooKeeperServer) {        response.put("is_leader", zkServer instanceof LeaderZooKeeperServer);        QuorumPeer peer = ((QuorumZooKeeperServer) zkServer).self;        response.put("leader_id", peer.getLeaderId());        String leaderAddress = peer.getLeaderAddress();        response.put("leader_ip", leaderAddress != null ? leaderAddress : "");    } else {        response.put("error", "server is not initialized");    }    return response;}
run
public CommandResponse zookeeper_f1524_0(ZooKeeperServer zkServer, Map<String, String> kwargs)
{    CommandResponse response = initializeResponse();    zkServer.dumpMonitorValues(response::put);    ServerMetrics.getMetrics().getMetricsProvider().dump(response::put);    return response;}
run
public CommandResponse zookeeper_f1525_0(ZooKeeperServer zkServer, Map<String, String> kwargs)
{    CommandResponse response = initializeResponse();    if (zkServer instanceof LeaderZooKeeperServer) {        Leader leader = ((LeaderZooKeeperServer) zkServer).getLeader();        leader.resetObserverConnectionStats();    } else if (zkServer instanceof FollowerZooKeeperServer) {        Follower follower = ((FollowerZooKeeperServer) zkServer).getFollower();        follower.resetObserverConnectionStats();    }    return response;}
run
public CommandResponse zookeeper_f1526_0(ZooKeeperServer zkServer, Map<String, String> kwargs)
{    return initializeResponse();}
run
public CommandResponse zookeeper_f1527_0(ZooKeeperServer zkServer, Map<String, String> kwargs)
{    CommandResponse response = initializeResponse();    long traceMask;    if (!kwargs.containsKey("traceMask")) {        response.put("error", "setTraceMask requires long traceMask argument");        return response;    }    try {        traceMask = Long.parseLong(kwargs.get("traceMask"));    } catch (NumberFormatException e) {        response.put("error", "setTraceMask requires long traceMask argument, got " + kwargs.get("traceMask"));        return response;    }    ZooTrace.setTextTraceLevel(traceMask);    response.put("tracemask", traceMask);    return response;}
run
public CommandResponsef1528_1ZooKeeperServer zkServer, Map<String, String> kwargs)
{    CommandResponse response = initializeResponse();        response.put("version", Version.getFullVersion());    response.put("read_only", zkServer instanceof ReadOnlyZooKeeperServer);    response.put("server_stats", zkServer.serverStats());    response.put("client_response", zkServer.serverStats().getClientResponseStats());    if (zkServer instanceof LeaderZooKeeperServer) {        Leader leader = ((LeaderZooKeeperServer) zkServer).getLeader();        response.put("proposal_stats", leader.getProposalStats());    }    response.put("node_count", zkServer.getZKDatabase().getNodeCount());    return response;}
run
public CommandResponse zookeeper_f1529_0(ZooKeeperServer zkServer, Map<String, String> kwargs)
{    CommandResponse response = super.run(zkServer, kwargs);    response.put("connections", zkServer.getServerCnxnFactory().getAllConnectionInfo(true));    return response;}
run
public CommandResponse zookeeper_f1530_0(ZooKeeperServer zkServer, Map<String, String> kwargs)
{    CommandResponse response = initializeResponse();    zkServer.serverStats().reset();    return response;}
run
public CommandResponse zookeeper_f1531_0(ZooKeeperServer zkServer, Map<String, String> kwargs)
{    CommandResponse response = initializeResponse();    if (zkServer instanceof LeaderZooKeeperServer) {        Leader leader = ((LeaderZooKeeperServer) zkServer).getLeader();        response.put("synced_observers", leader.getObservingLearners().size());        response.put("observers", leader.getObservingLearnersInfo());        return response;    } else if (zkServer instanceof FollowerZooKeeperServer) {        Follower follower = ((FollowerZooKeeperServer) zkServer).getFollower();        Integer syncedObservers = follower.getSyncedObserverSize();        if (syncedObservers != null) {            response.put("synced_observers", syncedObservers);            response.put("observers", follower.getSyncedObserversInfo());            return response;        }    }    response.put("synced_observers", 0);    response.put("observers", Collections.emptySet());    return response;}
run
public CommandResponse zookeeper_f1532_0(ZooKeeperServer zkServer, Map<String, String> kwargs)
{    CommandResponse response = initializeResponse();    Properties systemProperties = System.getProperties();    SortedMap<String, String> sortedSystemProperties = new TreeMap<>();    systemProperties.forEach((k, v) -> sortedSystemProperties.put(k.toString(), v.toString()));    response.putAll(sortedSystemProperties);    return response;}
run
public CommandResponse zookeeper_f1533_0(ZooKeeperServer zkServer, Map<String, String> kwargs)
{    CommandResponse response = initializeResponse();    if (zkServer instanceof QuorumZooKeeperServer) {        QuorumPeer peer = ((QuorumZooKeeperServer) zkServer).self;        VotingView votingView = new VotingView(peer.getVotingView());        response.put("current_config", votingView);    } else {        response.put("current_config", Collections.emptyMap());    }    return response;}
getView
public Map<Long, String> zookeeper_f1534_0()
{    return view;}
run
public CommandResponse zookeeper_f1535_0(ZooKeeperServer zkServer, Map<String, String> kwargs)
{    DataTree dt = zkServer.getZKDatabase().getDataTree();    CommandResponse response = initializeResponse();    response.put("session_id_to_watched_paths", dt.getWatches().toMap());    return response;}
run
public CommandResponse zookeeper_f1536_0(ZooKeeperServer zkServer, Map<String, String> kwargs)
{    DataTree dt = zkServer.getZKDatabase().getDataTree();    CommandResponse response = initializeResponse();    response.put("path_to_session_ids", dt.getWatchesByPath().toMap());    return response;}
run
public CommandResponse zookeeper_f1537_0(ZooKeeperServer zkServer, Map<String, String> kwargs)
{    DataTree dt = zkServer.getZKDatabase().getDataTree();    CommandResponse response = initializeResponse();    response.putAll(dt.getWatchesSummary().toMap());    return response;}
run
public CommandResponse zookeeper_f1538_0(ZooKeeperServer zkServer, Map<String, String> kwargs)
{    CommandResponse response = initializeResponse();    if (zkServer instanceof QuorumZooKeeperServer) {        QuorumPeer peer = ((QuorumZooKeeperServer) zkServer).self;        QuorumPeer.ZabState zabState = peer.getZabState();        QuorumVerifier qv = peer.getQuorumVerifier();        QuorumPeer.QuorumServer voter = qv.getVotingMembers().get(peer.getId());        boolean voting = (voter != null && voter.addr.equals(peer.getQuorumAddress()) && voter.electionAddr.equals(peer.getElectionAddress()));        response.put("voting", voting);        response.put("zabstate", zabState.name().toLowerCase());    } else {        response.put("voting", false);        response.put("zabstate", "");    }    return response;}
start
public void zookeeper_f1539_0() throws AdminServerException
{}
shutdown
public void zookeeper_f1540_0() throws AdminServerException
{}
setZooKeeperServer
public void zookeeper_f1541_0(ZooKeeperServer zkServer)
{}
start
public voidf1542_1) throws AdminServerException
{    try {        server.start();    } catch (Exception e) {                        String message = String.format("Problem starting AdminServer on address %s, port %d and command URL %s", address, port, commandUrl);        throw new AdminServerException(message, e);    }    }
shutdown
public void zookeeper_f1543_0() throws AdminServerException
{    try {        server.stop();    } catch (Exception e) {        String message = String.format("Problem stopping AdminServer on address %s, port %d and command URL %s", address, port, commandUrl);        throw new AdminServerException(message, e);    }}
setZooKeeperServer
public void zookeeper_f1544_0(ZooKeeperServer zkServer)
{    this.zkServer = zkServer;}
doGet
protected void zookeeper_f1545_0(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException
{        String cmd = request.getPathInfo();    if (cmd == null || cmd.equals("/")) {                for (String link : commandLinks()) {            response.getWriter().println(link);            response.getWriter().println("<br/>");        }        return;    }        cmd = cmd.substring(1);        @SuppressWarnings("unchecked")    Map<String, String[]> parameterMap = request.getParameterMap();    Map<String, String> kwargs = new HashMap<String, String>();    for (Map.Entry<String, String[]> entry : parameterMap.entrySet()) {        kwargs.put(entry.getKey(), entry.getValue()[0]);    }        CommandResponse cmdResponse = Commands.runCommand(cmd, zkServer, kwargs);        CommandOutputter outputter = new JsonOutputter();    response.setStatus(HttpServletResponse.SC_OK);    response.setContentType(outputter.getContentType());    outputter.output(cmdResponse, response.getWriter());}
commandLinks
private List<String> zookeeper_f1546_0()
{    List<String> links = new ArrayList<String>();    List<String> commands = new ArrayList<String>(Commands.getPrimaryNames());    Collections.sort(commands);    for (String command : commands) {        String url = commandUrl + "/" + command;        links.add(String.format("<a href=\"%s\">%s</a>", url, command));    }    return links;}
getContentType
public String zookeeper_f1547_0()
{    return "application/json";}
output
public voidf1548_1CommandResponse response, PrintWriter pw)
{    try {        mapper.writeValue(pw, response.toMap());    } catch (JsonGenerationException e) {                pw.write(ERROR_RESPONSE);    } catch (JsonMappingException e) {                pw.write(ERROR_RESPONSE);    } catch (IOException e) {                pw.write(ERROR_RESPONSE);    }}
getLocalAddress
public InetSocketAddress zookeeper_f1549_0()
{    return endPoint.getLocalAddress();}
getRemoteAddress
public InetSocketAddress zookeeper_f1550_0()
{    return endPoint.getRemoteAddress();}
isOpen
public boolean zookeeper_f1551_0()
{    return endPoint.isOpen();}
getCreatedTimeStamp
public long zookeeper_f1552_0()
{    return endPoint.getCreatedTimeStamp();}
isOutputShutdown
public boolean zookeeper_f1553_0()
{    return endPoint.isOutputShutdown();}
isInputShutdown
public boolean zookeeper_f1554_0()
{    return endPoint.isInputShutdown();}
shutdownOutput
public void zookeeper_f1555_0()
{    endPoint.shutdownOutput();}
close
public void zookeeper_f1556_0()
{    endPoint.close();}
getTransport
public Object zookeeper_f1557_0()
{    return endPoint.getTransport();}
getIdleTimeout
public long zookeeper_f1558_0()
{    return endPoint.getIdleTimeout();}
getConnection
public Connection zookeeper_f1559_0()
{    return endPoint.getConnection();}
onOpen
public void zookeeper_f1560_0()
{    endPoint.onOpen();}
onClose
public void zookeeper_f1561_0()
{    endPoint.onClose();}
isOptimizedForDirectBuffers
public boolean zookeeper_f1562_0()
{    return endPoint.isOptimizedForDirectBuffers();}
isFillInterested
public boolean zookeeper_f1563_0()
{    return endPoint.isFillInterested();}
tryFillInterested
public boolean zookeeper_f1564_0(Callback v)
{    return endPoint.tryFillInterested(v);}
flush
public boolean zookeeper_f1565_0(ByteBuffer... v) throws IOException
{    return endPoint.flush(v);}
setIdleTimeout
public void zookeeper_f1566_0(long v)
{    endPoint.setIdleTimeout(v);}
write
public void zookeeper_f1567_0(Callback v, ByteBuffer... b) throws WritePendingException
{    endPoint.write(v, b);}
setConnection
public void zookeeper_f1568_0(Connection v)
{    endPoint.setConnection(v);}
upgrade
public void zookeeper_f1569_0(Connection v)
{    endPoint.upgrade(v);}
fillInterested
public void zookeeper_f1570_0(Callback v) throws ReadPendingException
{    endPoint.fillInterested(v);}
readAhead
private synchronized void zookeeper_f1571_0() throws IOException
{    if (leftToRead > 0) {        int n = 0;        do {            n = endPoint.fill(start);        } while (n == 0 && endPoint.isOpen() && !endPoint.isInputShutdown());        if (n == -1) {            leftToRead = -1;        } else {            leftToRead -= n;        }        if (leftToRead <= 0) {            start.rewind();        }    }}
readFromStart
private int zookeeper_f1572_0(final ByteBuffer dst) throws IOException
{    final int n = Math.min(dst.remaining(), start.remaining());    if (n > 0) {        dst.put(bytes, start.position(), n);        start.position(start.position() + n);        dst.flip();    }    return n;}
fill
public synchronized int zookeeper_f1573_0(final ByteBuffer dst) throws IOException
{    throwPendingException();    if (leftToRead > 0) {        readAhead();    }    if (leftToRead > 0) {        return 0;    }    final int sr = start.remaining();    if (sr > 0) {        dst.compact();        final int n = readFromStart(dst);        if (n < sr) {            return n;        }    }    return sr + endPoint.fill(dst);}
getBytes
public byte[] zookeeper_f1574_0()
{    if (pendingException == null) {        try {            readAhead();        } catch (IOException e) {            pendingException = e;        }    }    byte[] ret = new byte[bytes.length];    System.arraycopy(bytes, 0, ret, 0, ret.length);    return ret;}
throwPendingException
private void zookeeper_f1575_0() throws IOException
{    if (pendingException != null) {        IOException e = pendingException;        pendingException = null;        throw e;    }}
doStart
protected void zookeeper_f1576_0() throws Exception
{    super.doStart();    SSLEngine engine = this.sslContextFactory.newSSLEngine();    SSLSession session = engine.getSession();    engine.setUseClientMode(false);    if (session.getPacketBufferSize() > this.getInputBufferSize()) {        this.setInputBufferSize(session.getPacketBufferSize());    }}
newConnection
public Connectionf1577_1Connector connector, EndPoint realEndPoint)
{    ReadAheadEndpoint aheadEndpoint = new ReadAheadEndpoint(realEndPoint, 1);    byte[] bytes = aheadEndpoint.getBytes();    boolean isSSL;    if (bytes == null || bytes.length == 0) {        isSSL = false;            } else {                byte b = bytes[0];                isSSL = b == 0x16;    }        EndPoint plainEndpoint;    SslConnection sslConnection;    if (isSSL) {        SSLEngine engine = this.sslContextFactory.newSSLEngine(aheadEndpoint.getRemoteAddress());        engine.setUseClientMode(false);        sslConnection = this.newSslConnection(connector, aheadEndpoint, engine);        sslConnection.setRenegotiationAllowed(this.sslContextFactory.isRenegotiationAllowed());        this.configure(sslConnection, connector, aheadEndpoint);        plainEndpoint = sslConnection.getDecryptedEndPoint();    } else {        sslConnection = null;        plainEndpoint = aheadEndpoint;    }    ConnectionFactory next = connector.getConnectionFactory(nextProtocol);    Connection connection = next.newConnection(connector, plainEndpoint);    plainEndpoint.setConnection(connection);    return (sslConnection == null) ? connection : sslConnection;}
newSslConnection
protected SslConnection zookeeper_f1578_0(final Connector connector, final EndPoint endPoint, final SSLEngine engine)
{    return new SslConnection(connector.getByteBufferPool(), connector.getExecutor(), endPoint, engine);}
toString
public String zookeeper_f1579_0()
{    return String.format("%s@%x{%s->%s}", this.getClass().getSimpleName(), this.hashCode(), this.getProtocol(), this.nextProtocol);}
getScheme
public String zookeeper_f1580_0()
{    return "digest";}
base64Encode
private static String zookeeper_f1581_0(byte[] b)
{    StringBuilder sb = new StringBuilder();    for (int i = 0; i < b.length; ) {        int pad = 0;        int v = (b[i++] & 0xff) << 16;        if (i < b.length) {            v |= (b[i++] & 0xff) << 8;        } else {            pad++;        }        if (i < b.length) {            v |= (b[i++] & 0xff);        } else {            pad++;        }        sb.append(encode(v >> 18));        sb.append(encode(v >> 12));        if (pad < 2) {            sb.append(encode(v >> 6));        } else {            sb.append('=');        }        if (pad < 1) {            sb.append(encode(v));        } else {            sb.append('=');        }    }    return sb.toString();}
encode
private static char zookeeper_f1582_0(int i)
{    i &= 0x3f;    if (i < 26) {        return (char) ('A' + i);    }    if (i < 52) {        return (char) ('a' + i - 26);    }    if (i < 62) {        return (char) ('0' + i - 52);    }    return i == 62 ? '+' : '/';}
generateDigest
public static String zookeeper_f1583_0(String idPassword) throws NoSuchAlgorithmException
{    String[] parts = idPassword.split(":", 2);    byte[] digest = MessageDigest.getInstance("SHA1").digest(idPassword.getBytes());    return parts[0] + ":" + base64Encode(digest);}
handleAuthentication
public KeeperException.Codef1584_1ServerCnxn cnxn, byte[] authData)
{    String id = new String(authData);    try {        String digest = generateDigest(id);        if (digest.equals(superDigest)) {            cnxn.addAuthInfo(new Id("super", ""));        }        cnxn.addAuthInfo(new Id(getScheme(), digest));        return KeeperException.Code.OK;    } catch (NoSuchAlgorithmException e) {            }    return KeeperException.Code.AUTHFAILED;}
isAuthenticated
public boolean zookeeper_f1585_0()
{    return true;}
isValid
public boolean zookeeper_f1586_0(String id)
{    String[] parts = id.split(":");    return parts.length == 2;}
matches
public boolean zookeeper_f1587_0(String id, String aclExpr)
{    return id.equals(aclExpr);}
main
public static void zookeeper_f1588_0(String[] args) throws NoSuchAlgorithmException
{    for (int i = 0; i < args.length; i++) {        System.out.println(args[i] + "->" + generateDigest(args[i]));    }}
abort
public boolean zookeeper_f1589_0()
{    return false;}
commit
public boolean zookeeper_f1590_0()
{    return true;}
initialize
public void zookeeper_f1591_0(Subject subject, CallbackHandler callbackHandler, Map<String, ?> sharedState, Map<String, ?> options)
{    if (options.containsKey("username")) {                this.subject = subject;        String username = (String) options.get("username");        this.subject.getPublicCredentials().add(username);        String password = (String) options.get("password");        this.subject.getPrivateCredentials().add(password);    }    return;}
logout
public boolean zookeeper_f1592_0()
{    return true;}
login
public boolean zookeeper_f1593_0()
{        return true;}
setEnsembleNames
public void zookeeper_f1594_0(String namesCSV)
{    ensembleNames = new HashSet<String>();    for (String name : namesCSV.split(",")) {        ensembleNames.add(name.trim());    }}
getScheme
public String zookeeper_f1595_0()
{    return "ensemble";}
handleAuthentication
public KeeperException.Codef1596_1ServerCnxn cnxn, byte[] authData)
{    if (authData == null || authData.length == 0) {        ServerMetrics.getMetrics().ENSEMBLE_AUTH_SKIP.add(1);        return KeeperException.Code.OK;    }    String receivedEnsembleName = new String(authData);    if (ensembleNames == null) {        ServerMetrics.getMetrics().ENSEMBLE_AUTH_SKIP.add(1);        return KeeperException.Code.OK;    }    if (ensembleNames.contains(receivedEnsembleName)) {        ServerMetrics.getMetrics().ENSEMBLE_AUTH_SUCCESS.add(1);        return KeeperException.Code.OK;    }    long currentTime = System.currentTimeMillis();    if (lastFailureLogged + MIN_LOGGING_INTERVAL_MS < currentTime) {        String id = cnxn.getRemoteSocketAddress().getAddress().getHostAddress();                lastFailureLogged = currentTime;    }    /*         * we are doing a close here rather than returning some other error         * since we want the client to choose another server to connect to. if         * we return an error, the client will get a fatal auth error and         * shutdown.         */    ServerMetrics.getMetrics().ENSEMBLE_AUTH_FAIL.add(1);    cnxn.close(ServerCnxn.DisconnectReason.FAILED_HANDSHAKE);    return KeeperException.Code.BADARGUMENTS;}
matches
public boolean zookeeper_f1597_0(String id, String aclExpr)
{    return false;}
isAuthenticated
public boolean zookeeper_f1598_0()
{    return false;}
isValid
public boolean zookeeper_f1599_0(String id)
{    return false;}
getScheme
public String zookeeper_f1600_0()
{    return "ip";}
handleAuthentication
public KeeperException.Code zookeeper_f1601_0(ServerCnxn cnxn, byte[] authData)
{    String id = cnxn.getRemoteSocketAddress().getAddress().getHostAddress();    cnxn.addAuthInfo(new Id(getScheme(), id));    return KeeperException.Code.OK;}
addr2Bytes
private byte[] zookeeper_f1602_0(String addr)
{    byte[] b = v4addr2Bytes(addr);        return b;}
v4addr2Bytes
private byte[] zookeeper_f1603_0(String addr)
{    String[] parts = addr.split("\\.", -1);    if (parts.length != 4) {        return null;    }    byte[] b = new byte[4];    for (int i = 0; i < 4; i++) {        try {            int v = Integer.parseInt(parts[i]);            if (v >= 0 && v <= 255) {                b[i] = (byte) v;            } else {                return null;            }        } catch (NumberFormatException e) {            return null;        }    }    return b;}
mask
private void zookeeper_f1604_0(byte[] b, int bits)
{    int start = bits / 8;    int startMask = (1 << (8 - (bits % 8))) - 1;    startMask = ~startMask;    while (start < b.length) {        b[start] &= startMask;        startMask = 0;        start++;    }}
matches
public boolean zookeeper_f1605_0(String id, String aclExpr)
{    String[] parts = aclExpr.split("/", 2);    byte[] aclAddr = addr2Bytes(parts[0]);    if (aclAddr == null) {        return false;    }    int bits = aclAddr.length * 8;    if (parts.length == 2) {        try {            bits = Integer.parseInt(parts[1]);            if (bits < 0 || bits > aclAddr.length * 8) {                return false;            }        } catch (NumberFormatException e) {            return false;        }    }    mask(aclAddr, bits);    byte[] remoteAddr = addr2Bytes(id);    if (remoteAddr == null) {        return false;    }    mask(remoteAddr, bits);    for (int i = 0; i < remoteAddr.length; i++) {        if (remoteAddr[i] != aclAddr[i]) {            return false;        }    }    return true;}
isAuthenticated
public boolean zookeeper_f1606_0()
{    return false;}
isValid
public boolean zookeeper_f1607_0(String id)
{    String[] parts = id.split("/", 2);    byte[] aclAddr = addr2Bytes(parts[0]);    if (aclAddr == null) {        return false;    }    if (parts.length == 2) {        try {            int bits = Integer.parseInt(parts[1]);            if (bits < 0 || bits > aclAddr.length * 8) {                return false;            }        } catch (NumberFormatException e) {            return false;        }    }    return true;}
getDefaultRealm
public String zookeeper_f1608_0()
{    return defaultRealm;}
toString
public String zookeeper_f1609_0()
{    StringBuilder result = new StringBuilder();    result.append(serviceName);    if (hostName != null) {        result.append('/');        result.append(hostName);    }    if (realm != null) {        result.append('@');        result.append(realm);    }    return result.toString();}
getServiceName
public String zookeeper_f1610_0()
{    return serviceName;}
getHostName
public String zookeeper_f1611_0()
{    return hostName;}
getRealm
public String zookeeper_f1612_0()
{    return realm;}
toString
public String zookeeper_f1613_0()
{    StringBuilder buf = new StringBuilder();    if (isDefault) {        buf.append("DEFAULT");    } else {        buf.append("RULE:[");        buf.append(numOfComponents);        buf.append(':');        buf.append(format);        buf.append(']');        if (match != null) {            buf.append('(');            buf.append(match);            buf.append(')');        }        if (fromPattern != null) {            buf.append("s/");            buf.append(fromPattern);            buf.append('/');            buf.append(toPattern);            buf.append('/');            if (repeat) {                buf.append('g');            }        }    }    return buf.toString();}
replaceParameters
 static String zookeeper_f1614_0(String format, String[] params) throws BadFormatString
{    Matcher match = parameterPattern.matcher(format);    int start = 0;    StringBuilder result = new StringBuilder();    while (start < format.length() && match.find(start)) {        result.append(match.group(1));        String paramNum = match.group(3);        if (paramNum != null) {            try {                int num = Integer.parseInt(paramNum);                if (num < 0 || num > params.length) {                    throw new BadFormatString(String.format("index %d from %s is outside of the valid range 0 to %d", num, format, (params.length - 1)));                }                result.append(params[num]);            } catch (NumberFormatException nfe) {                throw new BadFormatString("bad format in username mapping in " + paramNum, nfe);            }        }        start = match.end();    }    return result.toString();}
replaceSubstitution
 static String zookeeper_f1615_0(String base, Pattern from, String to, boolean repeat)
{    Matcher match = from.matcher(base);    if (repeat) {        return match.replaceAll(to);    } else {        return match.replaceFirst(to);    }}
apply
 String zookeeper_f1616_0(String[] params) throws IOException
{    String result = null;    if (isDefault) {        if (defaultRealm.equals(params[0])) {            result = params[1];        }    } else if (params.length - 1 == numOfComponents) {        String base = replaceParameters(format, params);        if (match == null || match.matcher(base).matches()) {            if (fromPattern == null) {                result = base;            } else {                result = replaceSubstitution(base, fromPattern, toPattern, repeat);            }        }    }    if (result != null && nonSimplePattern.matcher(result).find()) {        throw new NoMatchingRule("Non-simple name " + result + " after auth_to_local rule " + this);    }    return result;}
parseRules
 static List<Rule> zookeeper_f1617_0(String rules)
{    List<Rule> result = new ArrayList<Rule>();    String remaining = rules.trim();    while (remaining.length() > 0) {        Matcher matcher = ruleParser.matcher(remaining);        if (!matcher.lookingAt()) {            throw new IllegalArgumentException("Invalid rule: " + remaining);        }        if (matcher.group(2) != null) {            result.add(new Rule());        } else {            result.add(new Rule(Integer.parseInt(matcher.group(4)), matcher.group(5), matcher.group(7), matcher.group(9), matcher.group(10), "g".equals(matcher.group(11))));        }        remaining = remaining.substring(matcher.end());    }    return result;}
setConfiguration
public static void zookeeper_f1618_0() throws IOException
{    String ruleString = System.getProperty("zookeeper.security.auth_to_local", "DEFAULT");    rules = parseRules(ruleString);}
getShortName
public String zookeeper_f1619_0() throws IOException
{    String[] params;    if (hostName == null) {                if (realm == null) {            return serviceName;        }        params = new String[] { realm, serviceName };    } else {        params = new String[] { realm, serviceName, hostName };    }    for (Rule r : rules) {        String result = r.apply(params);        if (result != null) {            return result;        }    }    throw new NoMatchingRule("No rules applied to " + toString());}
printRules
 static void zookeeper_f1620_0() throws IOException
{    int i = 0;    for (Rule r : rules) {        System.out.println(++i + " " + r);    }}
main
public static void zookeeper_f1621_0(String[] args) throws Exception
{    for (String arg : args) {        KerberosName name = new KerberosName(arg);        System.out.println("Name: " + name + " to " + name.getShortName());    }}
getScheme
public String zookeeper_f1622_0()
{    return "key";}
getKey
private byte[]f1623_1ZooKeeperServer zks)
{    ZKDatabase db = zks.getZKDatabase();    if (db != null) {        try {            Stat stat = new Stat();            return db.getData("/key", stat, null);        } catch (NoNodeException e) {                    }    }    return null;}
validate
private booleanf1624_1byte[] key, byte[] auth)
{        try {        String keyStr = new String(key, StandardCharsets.UTF_8);        String authStr = new String(auth, StandardCharsets.UTF_8);        int keyVal = Integer.parseInt(keyStr);        int authVal = Integer.parseInt(authStr);        if (keyVal != 0 && ((authVal % keyVal) != 0)) {            return false;        }    } catch (NumberFormatException nfe) {                return false;    }    return true;}
handleAuthentication
public KeeperException.Codef1625_1ServerObjs serverObjs, byte[] authData)
{    byte[] key = getKey(serverObjs.getZks());    String authStr = "";    String keyStr = "";    try {        authStr = new String(authData, StandardCharsets.UTF_8);    } catch (Exception e) {            }    if (key != null) {        if (!validate(key, authData)) {            try {                keyStr = new String(key, StandardCharsets.UTF_8);            } catch (Exception e) {                                                keyStr = authStr;            }                        return KeeperException.Code.AUTHFAILED;        }    }                                serverObjs.getCnxn().addAuthInfo(new Id(getScheme(), keyStr));    return KeeperException.Code.OK;}
matches
public boolean zookeeper_f1626_0(ServerObjs serverObjs, MatchValues matchValues)
{    return matchValues.getId().equals(matchValues.getAclExpr());}
isAuthenticated
public boolean zookeeper_f1627_0()
{    return true;}
isValid
public boolean zookeeper_f1628_0(String id)
{    return true;}
reset
public static void zookeeper_f1629_0()
{    synchronized (ProviderRegistry.class) {        initialized = false;        authenticationProviders.clear();    }}
initialize
public static voidf1630_1)
{    synchronized (ProviderRegistry.class) {        IPAuthenticationProvider ipp = new IPAuthenticationProvider();        DigestAuthenticationProvider digp = new DigestAuthenticationProvider();        authenticationProviders.put(ipp.getScheme(), ipp);        authenticationProviders.put(digp.getScheme(), digp);        Enumeration<Object> en = System.getProperties().keys();        while (en.hasMoreElements()) {            String k = (String) en.nextElement();            if (k.startsWith("zookeeper.authProvider.")) {                String className = System.getProperty(k);                try {                    Class<?> c = ZooKeeperServer.class.getClassLoader().loadClass(className);                    AuthenticationProvider ap = (AuthenticationProvider) c.getDeclaredConstructor().newInstance();                    authenticationProviders.put(ap.getScheme(), ap);                } catch (Exception e) {                                    }            }        }        initialized = true;    }}
getServerProvider
public static ServerAuthenticationProvider zookeeper_f1631_0(String scheme)
{    return WrappedAuthenticationProvider.wrap(getProvider(scheme));}
getProvider
public static AuthenticationProvider zookeeper_f1632_0(String scheme)
{    if (!initialized) {        initialize();    }    return authenticationProviders.get(scheme);}
removeProvider
public static void zookeeper_f1633_0(String scheme)
{    authenticationProviders.remove(scheme);}
listProviders
public static String zookeeper_f1634_0()
{    StringBuilder sb = new StringBuilder();    for (String s : authenticationProviders.keySet()) {        sb.append(s).append(" ");    }    return sb.toString();}
getScheme
public String zookeeper_f1635_0()
{    return "sasl";}
handleAuthentication
public KeeperException.Code zookeeper_f1636_0(ServerCnxn cnxn, byte[] authData)
{        return KeeperException.Code.AUTHFAILED;}
matches
public boolean zookeeper_f1637_0(String id, String aclExpr)
{    if ((id.equals("super") || id.equals(aclExpr))) {        return true;    }    String readAccessUser = System.getProperty("zookeeper.letAnySaslUserDoX");    return readAccessUser != null && aclExpr.equals(readAccessUser);}
isAuthenticated
public boolean zookeeper_f1638_0()
{    return true;}
isValid
public boolean zookeeper_f1639_0(String id)
{        try {        new KerberosName(id);        return true;    } catch (IllegalArgumentException e) {        return false;    }}
handle
public void zookeeper_f1640_0(Callback[] callbacks) throws UnsupportedCallbackException
{    for (Callback callback : callbacks) {        if (callback instanceof NameCallback) {            handleNameCallback((NameCallback) callback);        } else if (callback instanceof PasswordCallback) {            handlePasswordCallback((PasswordCallback) callback);        } else if (callback instanceof RealmCallback) {            handleRealmCallback((RealmCallback) callback);        } else if (callback instanceof AuthorizeCallback) {            handleAuthorizeCallback((AuthorizeCallback) callback);        }    }}
handleNameCallback
private voidf1641_1NameCallback nc)
{        if (credentials.get(nc.getDefaultName()) == null) {                return;    }    nc.setName(nc.getDefaultName());    userName = nc.getDefaultName();}
handlePasswordCallback
private voidf1642_1PasswordCallback pc)
{    if ("super".equals(this.userName) && System.getProperty(SYSPROP_SUPER_PASSWORD) != null) {                pc.setPassword(System.getProperty(SYSPROP_SUPER_PASSWORD).toCharArray());    } else if (credentials.containsKey(userName)) {        pc.setPassword(credentials.get(userName).toCharArray());    } else {            }}
handleRealmCallback
private voidf1643_1RealmCallback rc)
{        rc.setText(rc.getDefaultText());}
shouldAppendRealm
private boolean zookeeper_f1645_0(KerberosName kerberosName)
{    return !isSystemPropertyTrue(SYSPROP_REMOVE_REALM) && kerberosName.getRealm() != null;}
shouldAppendHost
private boolean zookeeper_f1646_0(KerberosName kerberosName)
{    return !isSystemPropertyTrue(SYSPROP_REMOVE_HOST) && kerberosName.getHostName() != null;}
isSystemPropertyTrue
private boolean zookeeper_f1647_0(String propertyName)
{    return "true".equals(System.getProperty(propertyName));}
getZks
public ZooKeeperServer zookeeper_f1648_0()
{    return zks;}
getCnxn
public ServerCnxn zookeeper_f1649_0()
{    return cnxn;}
getPath
public String zookeeper_f1650_0()
{    return path;}
getId
public String zookeeper_f1651_0()
{    return id;}
getAclExpr
public String zookeeper_f1652_0()
{    return aclExpr;}
getPerm
public int zookeeper_f1653_0()
{    return perm;}
getSetAcls
public List<ACL> zookeeper_f1654_0()
{    return setAcls;}
handleAuthentication
public final KeeperException.Code zookeeper_f1655_0(ServerCnxn cnxn, byte[] authData)
{    throw new UnsupportedOperationException();}
matches
public final boolean zookeeper_f1656_0(String id, String aclExpr)
{    throw new UnsupportedOperationException();}
wrap
 static ServerAuthenticationProvider zookeeper_f1657_0(AuthenticationProvider provider)
{    if (provider == null) {        return null;    }    return (provider instanceof ServerAuthenticationProvider) ? (ServerAuthenticationProvider) provider : new WrappedAuthenticationProvider(provider);}
handleAuthentication
public KeeperException.Code zookeeper_f1658_0(ServerObjs serverObjs, byte[] authData)
{    return implementation.handleAuthentication(serverObjs.getCnxn(), authData);}
matches
public boolean zookeeper_f1659_0(ServerObjs serverObjs, MatchValues matchValues)
{    return implementation.matches(matchValues.getId(), matchValues.getAclExpr());}
getScheme
public String zookeeper_f1660_0()
{    return implementation.getScheme();}
isAuthenticated
public boolean zookeeper_f1661_0()
{    return implementation.isAuthenticated();}
isValid
public boolean zookeeper_f1662_0(String id)
{    return implementation.isValid(id);}
getScheme
public String zookeeper_f1663_0()
{    return "x509";}
handleAuthentication
public KeeperException.Codef1664_1ServerCnxn cnxn, byte[] authData)
{    X509Certificate[] certChain = (X509Certificate[]) cnxn.getClientCertificateChain();    if (certChain == null || certChain.length == 0) {        return KeeperException.Code.AUTHFAILED;    }    if (trustManager == null) {                return KeeperException.Code.AUTHFAILED;    }    X509Certificate clientCert = certChain[0];    try {                trustManager.checkClientTrusted(certChain, clientCert.getPublicKey().getAlgorithm());    } catch (CertificateException ce) {                return KeeperException.Code.AUTHFAILED;    }    String clientId = getClientId(clientCert);    if (clientId.equals(System.getProperty(ZOOKEEPER_X509AUTHENTICATIONPROVIDER_SUPERUSER))) {        cnxn.addAuthInfo(new Id("super", clientId));            }    Id authInfo = new Id(getScheme(), clientId);    cnxn.addAuthInfo(authInfo);        return KeeperException.Code.OK;}
getClientId
protected String zookeeper_f1665_0(X509Certificate clientCert)
{    return clientCert.getSubjectX500Principal().getName();}
matches
public boolean zookeeper_f1666_0(String id, String aclExpr)
{    if (System.getProperty(ZOOKEEPER_X509AUTHENTICATIONPROVIDER_SUPERUSER) != null) {        return id.equals(System.getProperty(ZOOKEEPER_X509AUTHENTICATIONPROVIDER_SUPERUSER)) || id.equals(aclExpr);    }    return id.equals(aclExpr);}
isAuthenticated
public boolean zookeeper_f1667_0()
{    return true;}
isValid
public boolean zookeeper_f1668_0(String id)
{    try {        new X500Principal(id);        return true;    } catch (IllegalArgumentException e) {        return false;    }}
getTrustManager
public X509TrustManager zookeeper_f1669_0() throws TrustManagerException
{    if (trustManager == null) {        throw new TrustManagerException("No trust manager available");    }    return trustManager;}
getKeyManager
public X509KeyManager zookeeper_f1670_0() throws KeyManagerException
{    if (keyManager == null) {        throw new KeyManagerException("No key manager available");    }    return keyManager;}
setConnectionWeightEnabled
protected static void zookeeper_f1671_0(boolean enabled)
{    connectionWeightEnabled = enabled;    logWeighedThrottlingSetting();}
logWeighedThrottlingSetting
private static voidf1672_1)
{    if (connectionWeightEnabled) {                    } else {            }}
getDoubleProp
private static double zookeeper_f1673_0(String name, double def)
{    String val = System.getProperty(name);    if (val != null) {        return Double.parseDouble(val);    } else {        return def;    }}
setMaxTokens
public synchronized void zookeeper_f1674_0(int max)
{    int deficit = maxTokens - tokens;    maxTokens = max;    tokens = max - deficit;}
setFillTime
public synchronized void zookeeper_f1675_0(int time)
{    fillTime = time;}
setFillCount
public synchronized void zookeeper_f1676_0(int count)
{    fillCount = count;}
setFreezeTime
public synchronized void zookeeper_f1677_0(int time)
{    freezeTime = time;}
setDropIncrease
public synchronized void zookeeper_f1678_0(double increase)
{    dropIncrease = increase;}
setDropDecrease
public synchronized void zookeeper_f1679_0(double decrease)
{    dropDecrease = decrease;}
setDecreasePoint
public synchronized void zookeeper_f1680_0(double ratio)
{    decreasePoint = ratio;}
getMaxTokens
public synchronized int zookeeper_f1681_0()
{    return maxTokens;}
getFillTime
public synchronized int zookeeper_f1682_0()
{    return fillTime;}
getFillCount
public synchronized int zookeeper_f1683_0()
{    return fillCount;}
getFreezeTime
public synchronized int zookeeper_f1684_0()
{    return freezeTime;}
getDropIncrease
public synchronized double zookeeper_f1685_0()
{    return dropIncrease;}
getDropDecrease
public synchronized double zookeeper_f1686_0()
{    return dropDecrease;}
getDecreasePoint
public synchronized double zookeeper_f1687_0()
{    return decreasePoint;}
getDropChance
public synchronized double zookeeper_f1688_0()
{    return drop;}
getDeficit
public synchronized int zookeeper_f1689_0()
{    return maxTokens - tokens;}
getRequiredTokensForGlobal
public int zookeeper_f1690_0()
{    return BlueThrottle.DEFAULT_GLOBAL_SESSION_WEIGHT;}
getRequiredTokensForLocal
public int zookeeper_f1691_0()
{    return BlueThrottle.DEFAULT_LOCAL_SESSION_WEIGHT;}
getRequiredTokensForRenew
public int zookeeper_f1692_0()
{    return BlueThrottle.DEFAULT_RENEW_SESSION_WEIGHT;}
isConnectionWeightEnabled
public boolean zookeeper_f1693_0()
{    return BlueThrottle.connectionWeightEnabled;}
checkLimit
public synchronized boolean zookeeper_f1694_0(int need)
{        if (maxTokens == 0) {        return true;    }    long now = Time.currentElapsedTime();    long diff = now - lastTime;    if (diff > fillTime) {        int refill = (int) (diff * fillCount / fillTime);        tokens = Math.min(tokens + refill, maxTokens);        lastTime = now;    }        if (freezeTime != -1) {        if (!checkBlue(now)) {            return false;        }    }    if (tokens < need) {        return false;    }    tokens -= need;    return true;}
checkBlue
public synchronized boolean zookeeper_f1695_0(long now)
{    int length = maxTokens - tokens;    int limit = maxTokens;    long diff = now - lastFreeze;    long threshold = Math.round(maxTokens * decreasePoint);    if (diff > freezeTime) {        if ((length == limit) && (drop < 1)) {            drop = Math.min(drop + dropIncrease, 1);        } else if ((length <= threshold) && (drop > 0)) {            drop = Math.max(drop - dropDecrease, 0);        }        lastFreeze = now;    }    return !(rng.nextDouble() < drop);}
read
public int zookeeper_f1696_0() throws IOException
{    if (bb.remaining() == 0) {        return -1;    }    return bb.get() & 0xff;}
available
public int zookeeper_f1697_0() throws IOException
{    return bb.remaining();}
read
public int zookeeper_f1698_0(byte[] b, int off, int len) throws IOException
{    if (bb.remaining() == 0) {        return -1;    }    if (len > bb.remaining()) {        len = bb.remaining();    }    bb.get(b, off, len);    return len;}
read
public int zookeeper_f1699_0(byte[] b) throws IOException
{    return read(b, 0, b.length);}
skip
public long zookeeper_f1700_0(long n) throws IOException
{    if (n < 0L) {        return 0;    }    n = Math.min(n, bb.remaining());    bb.position(bb.position() + (int) n);    return n;}
byteBuffer2Record
public static void zookeeper_f1701_0(ByteBuffer bb, Record record) throws IOException
{    BinaryInputArchive ia;    ia = BinaryInputArchive.getArchive(new ByteBufferInputStream(bb));    record.deserialize(ia, "request");}
write
public void zookeeper_f1702_0(int b) throws IOException
{    bb.put((byte) b);}
write
public void zookeeper_f1703_0(byte[] b) throws IOException
{    bb.put(b);}
write
public void zookeeper_f1704_0(byte[] b, int off, int len) throws IOException
{    bb.put(b, off, len);}
record2ByteBuffer
public static void zookeeper_f1705_0(Record record, ByteBuffer bb) throws IOException
{    BinaryOutputArchive oa;    oa = BinaryOutputArchive.getArchive(new ByteBufferOutputStream(bb));    record.serialize(oa, "request");}
start
public void zookeeper_f1706_0()
{    run();}
run
public voidf1707_1)
{    try {        commandRun();    } catch (IOException ie) {            } finally {        serverCnxn.cleanupWriterSocket(pw);    }}
setZkServer
public void zookeeper_f1708_0(ZooKeeperServer zkServer)
{    this.zkServer = zkServer;}
isZKServerRunning
 boolean zookeeper_f1709_0()
{    return zkServer != null && zkServer.isRunning();}
setFactory
public void zookeeper_f1710_0(ServerCnxnFactory factory)
{    this.factory = factory;}
commandRun
public void zookeeper_f1711_0()
{    if (!isZKServerRunning()) {        pw.println(ZK_NOT_SERVING);    } else {        factory.resetAllConnectionStats();        pw.println("Connection stats reset.");    }}
execute
public boolean zookeeper_f1712_0(ServerCnxn serverCnxn, PrintWriter pwriter, final int commandCode, ZooKeeperServer zkServer, ServerCnxnFactory factory)
{    AbstractFourLetterCommand command = getCommand(serverCnxn, pwriter, commandCode);    if (command == null) {        return false;    }    command.setZkServer(zkServer);    command.setFactory(factory);    command.start();    return true;}
getCommand
private AbstractFourLetterCommand zookeeper_f1713_0(ServerCnxn serverCnxn, PrintWriter pwriter, final int commandCode)
{    AbstractFourLetterCommand command = null;    if (commandCode == FourLetterCommands.ruokCmd) {        command = new RuokCommand(pwriter, serverCnxn);    } else if (commandCode == FourLetterCommands.getTraceMaskCmd) {        command = new TraceMaskCommand(pwriter, serverCnxn);    } else if (commandCode == FourLetterCommands.enviCmd) {        command = new EnvCommand(pwriter, serverCnxn);    } else if (commandCode == FourLetterCommands.confCmd) {        command = new ConfCommand(pwriter, serverCnxn);    } else if (commandCode == FourLetterCommands.srstCmd) {        command = new StatResetCommand(pwriter, serverCnxn);    } else if (commandCode == FourLetterCommands.crstCmd) {        command = new CnxnStatResetCommand(pwriter, serverCnxn);    } else if (commandCode == FourLetterCommands.dirsCmd) {        command = new DirsCommand(pwriter, serverCnxn);    } else if (commandCode == FourLetterCommands.dumpCmd) {        command = new DumpCommand(pwriter, serverCnxn);    } else if (commandCode == FourLetterCommands.statCmd || commandCode == FourLetterCommands.srvrCmd) {        command = new StatCommand(pwriter, serverCnxn, commandCode);    } else if (commandCode == FourLetterCommands.consCmd) {        command = new ConsCommand(pwriter, serverCnxn);    } else if (commandCode == FourLetterCommands.wchpCmd || commandCode == FourLetterCommands.wchcCmd || commandCode == FourLetterCommands.wchsCmd) {        command = new WatchCommand(pwriter, serverCnxn, commandCode);    } else if (commandCode == FourLetterCommands.mntrCmd) {        command = new MonitorCommand(pwriter, serverCnxn);    } else if (commandCode == FourLetterCommands.isroCmd) {        command = new IsroCommand(pwriter, serverCnxn);    } else if (commandCode == FourLetterCommands.hashCmd) {        command = new DigestCommand(pwriter, serverCnxn);    }    return command;}
commandRun
public void zookeeper_f1714_0()
{    if (!isZKServerRunning()) {        pw.println(ZK_NOT_SERVING);    } else {        zkServer.dumpConf(pw);    }}
commandRun
public void zookeeper_f1715_0()
{    if (!isZKServerRunning()) {        pw.println(ZK_NOT_SERVING);    } else {        for (ServerCnxn c : factory.getConnections()) {            c.dumpConnectionInfo(pw, false);            pw.println();        }        pw.println();    }}
commandRun
public void zookeeper_f1716_0()
{    if (!isZKServerRunning()) {        pw.print(ZK_NOT_SERVING);    } else {        List<ZxidDigest> digestLog = zkServer.getZKDatabase().getDataTree().getDigestLog();        for (ZxidDigest zd : digestLog) {            pw.println(Long.toHexString(zd.getZxid()) + ": " + zd.getDigest());        }    }}
commandRun
public void zookeeper_f1717_0() throws IOException
{    if (!isZKServerRunning()) {        pw.println(ZK_NOT_SERVING);        return;    }    pw.println("datadir_size: " + zkServer.getDataDirSize());    pw.println("logdir_size: " + zkServer.getLogDirSize());}
commandRun
public void zookeeper_f1718_0()
{    if (!isZKServerRunning()) {        pw.println(ZK_NOT_SERVING);    } else {        pw.println("SessionTracker dump:");        zkServer.getSessionTracker().dumpSessions(pw);        pw.println("ephemeral nodes dump:");        zkServer.dumpEphemerals(pw);        pw.println("Connections dump:");                if (factory instanceof NIOServerCnxnFactory) {            ((NIOServerCnxnFactory) factory).dumpConnections(pw);        }    }}
commandRun
public void zookeeper_f1719_0()
{    List<Environment.Entry> env = Environment.list();    pw.println("Environment:");    for (Environment.Entry e : env) {        pw.print(e.getKey());        pw.print("=");        pw.println(e.getValue());    }}
resetWhiteList
public static synchronized void zookeeper_f1720_0()
{    whiteListInitialized = false;    whiteListedCommands.clear();}
getCommandString
public static String zookeeper_f1721_0(int command)
{    return cmd2String.get(command);}
isKnown
public static boolean zookeeper_f1722_0(int command)
{    return cmd2String.containsKey(command);}
isEnabled
public static synchronized booleanf1723_1String command)
{    if (whiteListInitialized) {        return whiteListedCommands.contains(command);    }    String commands = System.getProperty(ZOOKEEPER_4LW_COMMANDS_WHITELIST);    if (commands != null) {        String[] list = commands.split(",");        for (String cmd : list) {            if (cmd.trim().equals("*")) {                for (Map.Entry<Integer, String> entry : cmd2String.entrySet()) {                    whiteListedCommands.add(entry.getValue());                }                break;            }            if (!cmd.trim().isEmpty()) {                whiteListedCommands.add(cmd.trim());            }        }    }        if (System.getProperty("readonlymode.enabled", "false").equals("true")) {        whiteListedCommands.add("isro");    }        whiteListedCommands.add("srvr");    whiteListInitialized = true;            return whiteListedCommands.contains(command);}
commandRun
public void zookeeper_f1724_0()
{    if (!isZKServerRunning()) {        pw.print("null");    } else if (zkServer instanceof ReadOnlyZooKeeperServer) {        pw.print("ro");    } else {        pw.print("rw");    }}
commandRun
public void zookeeper_f1725_0()
{    if (!isZKServerRunning()) {        pw.println(ZK_NOT_SERVING);        return;    }        zkServer.dumpMonitorValues(this::print);    ServerMetrics.getMetrics().getMetricsProvider().dump(this::print);}
print
private void zookeeper_f1726_0(String key, Object value)
{    if (value == null) {        output(key, null);    } else if (value instanceof Long || value instanceof Integer) {                output(key, value + "");    } else if (value instanceof Number) {                output(key, ((Number) value).doubleValue() + "");    } else {        output(key, value.toString());    }}
output
private void zookeeper_f1727_0(String key, String value)
{    pw.print("zk_");    pw.print(key);    pw.print("\t");    pw.println(value);}
commandRun
public void zookeeper_f1728_0()
{    pw.println(msg);}
commandRun
public void zookeeper_f1729_0()
{    pw.print("imok");}
commandRun
public void zookeeper_f1730_0()
{    pw.print(trace);}
commandRun
public voidf1731_1)
{    if (!isZKServerRunning()) {        pw.println(ZK_NOT_SERVING);    } else {        pw.print("Zookeeper version: ");        pw.println(Version.getFullVersion());        if (zkServer instanceof ReadOnlyZooKeeperServer) {            pw.println("READ-ONLY mode; serving only read-only clients");        }        if (len == FourLetterCommands.statCmd) {                        pw.println("Clients:");            for (ServerCnxn c : factory.getConnections()) {                c.dumpConnectionInfo(pw, true);                pw.println();            }            pw.println();        }        ServerStats serverStats = zkServer.serverStats();        pw.print(serverStats.toString());        pw.print("Node count: ");        pw.println(zkServer.getZKDatabase().getNodeCount());        if (serverStats.getServerState().equals("leader")) {            Leader leader = ((LeaderZooKeeperServer) zkServer).getLeader();            BufferStats proposalStats = leader.getProposalStats();            pw.printf("Proposal sizes last/min/max: %s%n", proposalStats.toString());        }    }}
commandRun
public void zookeeper_f1732_0()
{    if (!isZKServerRunning()) {        pw.println(ZK_NOT_SERVING);    } else {        ServerStats serverStats = zkServer.serverStats();        serverStats.reset();        if (serverStats.getServerState().equals("leader")) {            ((LeaderZooKeeperServer) zkServer).getLeader().getProposalStats().reset();        }        pw.println("Server stats reset.");    }}
commandRun
public void zookeeper_f1733_0()
{    long traceMask = ZooTrace.getTextTraceLevel();    pw.print(traceMask);}
commandRun
public void zookeeper_f1734_0()
{    if (!isZKServerRunning()) {        pw.println(ZK_NOT_SERVING);    } else {        DataTree dt = zkServer.getZKDatabase().getDataTree();        if (len == FourLetterCommands.wchsCmd) {            dt.dumpWatchesSummary(pw);        } else if (len == FourLetterCommands.wchpCmd) {            dt.dumpWatches(pw, true);        } else {            dt.dumpWatches(pw, false);        }        pw.println();    }}
getSessionId
public String zookeeper_f1735_0()
{    return "0x" + Long.toHexString(sessionId);}
getSourceIP
public String zookeeper_f1736_0()
{    InetSocketAddress sockAddr = connection.getRemoteSocketAddress();    if (sockAddr == null) {        return null;    }    return sockAddr.getAddress().getHostAddress() + ":" + sockAddr.getPort();}
getName
public String zookeeper_f1737_0()
{    return MBeanRegistry.getInstance().makeFullPath("Connections", remoteIP, getSessionId());}
isHidden
public boolean zookeeper_f1738_0()
{    return false;}
getEphemeralNodes
public String[] zookeeper_f1739_0()
{    if (zk.getZKDatabase() != null) {        String[] res = zk.getZKDatabase().getEphemerals(sessionId).toArray(new String[0]);        Arrays.sort(res);        return res;    }    return null;}
getStartedTime
public String zookeeper_f1740_0()
{    return stats.getEstablished().toString();}
terminateSession
public voidf1741_1)
{    try {        zk.closeSession(sessionId);    } catch (Exception e) {            }}
terminateConnection
public void zookeeper_f1742_0()
{    connection.sendCloseSession();}
resetCounters
public void zookeeper_f1743_0()
{    stats.resetStats();}
toString
public String zookeeper_f1744_0()
{    return "ConnectionBean{ClientIP=" + ObjectName.quote(getSourceIP()) + ",SessionId=0x" + getSessionId() + "}";}
getOutstandingRequests
public long zookeeper_f1745_0()
{    return stats.getOutstandingRequests();}
getPacketsReceived
public long zookeeper_f1746_0()
{    return stats.getPacketsReceived();}
getPacketsSent
public long zookeeper_f1747_0()
{    return stats.getPacketsSent();}
getSessionTimeout
public int zookeeper_f1748_0()
{    return connection.getSessionTimeout();}
getMinLatency
public long zookeeper_f1749_0()
{    return stats.getMinLatency();}
getAvgLatency
public long zookeeper_f1750_0()
{    return stats.getAvgLatency();}
getMaxLatency
public long zookeeper_f1751_0()
{    return stats.getMaxLatency();}
getLastOperation
public String zookeeper_f1752_0()
{    return stats.getLastOperation();}
getLastCxid
public String zookeeper_f1753_0()
{    return "0x" + Long.toHexString(stats.getLastCxid());}
getLastZxid
public String zookeeper_f1754_0()
{    return "0x" + Long.toHexString(stats.getLastZxid());}
getLastResponseTime
public String zookeeper_f1755_0()
{    return Time.elapsedTimeToDate(stats.getLastResponseTime()).toString();}
getLastLatency
public long zookeeper_f1756_0()
{    return stats.getLastLatency();}
start
public voidf1757_1)
{    if (task.get() == null) {        TimerTask timerTask = new TimerTask() {            @Override            public void run() {                try {                    checkContainers();                } catch (InterruptedException e) {                    Thread.currentThread().interrupt();                                        cancel();                } catch (Throwable e) {                                    }            }        };        if (task.compareAndSet(null, timerTask)) {            timer.scheduleAtFixedRate(timerTask, checkIntervalMs, checkIntervalMs);        }    }}
run
public voidf1758_1)
{    try {        checkContainers();    } catch (InterruptedException e) {        Thread.currentThread().interrupt();                cancel();    } catch (Throwable e) {            }}
stop
public void zookeeper_f1759_0()
{    TimerTask timerTask = task.getAndSet(null);    if (timerTask != null) {        timerTask.cancel();    }    timer.cancel();}
checkContainers
public voidf1760_1) throws InterruptedException
{    long minIntervalMs = getMinIntervalMs();    for (String containerPath : getCandidates()) {        long startMs = Time.currentElapsedTime();        ByteBuffer path = ByteBuffer.wrap(containerPath.getBytes());        Request request = new Request(null, 0, 0, ZooDefs.OpCode.deleteContainer, path, null);        try {                        requestProcessor.processRequest(request);        } catch (Exception e) {                    }        long elapsedMs = Time.currentElapsedTime() - startMs;        long waitMs = minIntervalMs - elapsedMs;        if (waitMs > 0) {            Thread.sleep(waitMs);        }    }}
getMinIntervalMs
protected long zookeeper_f1761_0()
{    return TimeUnit.MINUTES.toMillis(1) / maxPerMinute;}
getCandidates
protected Collection<String> zookeeper_f1762_0()
{    Set<String> candidates = new HashSet<String>();    for (String containerPath : zkDb.getDataTree().getContainers()) {        DataNode node = zkDb.getDataTree().getNode(containerPath);        /*                cversion > 0: keep newly created containers from being deleted                before any children have been added. If you were to create the                container just before a container cleaning period the container                would be immediately be deleted.             */        if ((node != null) && (node.stat.getCversion() > 0) && (node.getChildren().isEmpty())) {            candidates.add(containerPath);        }    }    for (String ttlPath : zkDb.getDataTree().getTtls()) {        DataNode node = zkDb.getDataTree().getNode(ttlPath);        if (node != null) {            Set<String> children = node.getChildren();            if (children.isEmpty()) {                if (EphemeralType.get(node.stat.getEphemeralOwner()) == EphemeralType.TTL) {                    long elapsed = getElapsed(node);                    long ttl = EphemeralType.TTL.getValue(node.stat.getEphemeralOwner());                    if ((ttl != 0) && (getElapsed(node) > ttl)) {                        candidates.add(ttlPath);                    }                }            }        }    }    return candidates;}
getElapsed
protected long zookeeper_f1763_0(DataNode node)
{    return Time.currentWallTime() - node.stat.getMtime();}
start
public voidf1764_1)
{    if (PurgeTaskStatus.STARTED == purgeTaskStatus) {                return;    }        if (purgeInterval <= 0) {                return;    }    timer = new Timer("PurgeTask", true);    TimerTask task = new PurgeTask(dataLogDir, snapDir, snapRetainCount);    timer.scheduleAtFixedRate(task, 0, TimeUnit.HOURS.toMillis(purgeInterval));    purgeTaskStatus = PurgeTaskStatus.STARTED;}
shutdown
public voidf1765_1)
{    if (PurgeTaskStatus.STARTED == purgeTaskStatus) {                timer.cancel();        purgeTaskStatus = PurgeTaskStatus.COMPLETED;    } else {            }}
run
public voidf1766_1)
{        try {        PurgeTxnLog.purge(logsDir, snapsDir, snapRetainCount);    } catch (Exception e) {            }    }
getPurgeTaskStatus
public PurgeTaskStatus zookeeper_f1767_0()
{    return purgeTaskStatus;}
getSnapDir
public File zookeeper_f1768_0()
{    return snapDir;}
getDataLogDir
public File zookeeper_f1769_0()
{    return dataLogDir;}
getPurgeInterval
public int zookeeper_f1770_0()
{    return purgeInterval;}
getSnapRetainCount
public int zookeeper_f1771_0()
{    return snapRetainCount;}
addChild
public synchronized boolean zookeeper_f1772_0(String child)
{    if (children == null) {                children = new HashSet<String>(8);    }    return children.add(child);}
removeChild
public synchronized boolean zookeeper_f1773_0(String child)
{    if (children == null) {        return false;    }    return children.remove(child);}
setChildren
public synchronized void zookeeper_f1774_0(HashSet<String> children)
{    this.children = children;}
getChildren
public synchronized Set<String> zookeeper_f1775_0()
{    if (children == null) {        return EMPTY_SET;    }    return Collections.unmodifiableSet(children);}
copyStat
public synchronized void zookeeper_f1776_0(Stat to)
{    to.setAversion(stat.getAversion());    to.setCtime(stat.getCtime());    to.setCzxid(stat.getCzxid());    to.setMtime(stat.getMtime());    to.setMzxid(stat.getMzxid());    to.setPzxid(stat.getPzxid());    to.setVersion(stat.getVersion());    to.setEphemeralOwner(getClientEphemeralOwner(stat));    to.setDataLength(data == null ? 0 : data.length);    int numChildren = 0;    if (this.children != null) {        numChildren = children.size();    }                to.setCversion(stat.getCversion() * 2 - numChildren);    to.setNumChildren(numChildren);}
getClientEphemeralOwner
private static long zookeeper_f1777_0(StatPersisted stat)
{    EphemeralType ephemeralType = EphemeralType.get(stat.getEphemeralOwner());    if (ephemeralType != EphemeralType.NORMAL) {        return 0;    }    return stat.getEphemeralOwner();}
deserialize
public synchronized void zookeeper_f1778_0(InputArchive archive, String tag) throws IOException
{    archive.startRecord("node");    data = archive.readBuffer("data");    acl = archive.readLong("acl");    stat = new StatPersisted();    stat.deserialize(archive, "statpersisted");    archive.endRecord("node");}
serialize
public synchronized void zookeeper_f1779_0(OutputArchive archive, String tag) throws IOException
{    archive.startRecord(this, "node");    archive.writeBuffer(data, "data");    archive.writeLong(acl, "acl");    stat.serialize(archive, "statpersisted");    archive.endRecord(this, "node");}
isDigestCached
public boolean zookeeper_f1780_0()
{    return digestCached;}
setDigestCached
public void zookeeper_f1781_0(boolean digestCached)
{    this.digestCached = digestCached;}
getDigest
public long zookeeper_f1782_0()
{    return digest;}
setDigest
public void zookeeper_f1783_0(long digest)
{    this.digest = digest;}
getData
public byte[] zookeeper_f1784_0()
{    return data;}
getEphemerals
public Set<String> zookeeper_f1785_0(long sessionId)
{    HashSet<String> retv = ephemerals.get(sessionId);    if (retv == null) {        return new HashSet<String>();    }    Set<String> cloned = null;    synchronized (retv) {        cloned = (HashSet<String>) retv.clone();    }    return cloned;}
getContainers
public Set<String> zookeeper_f1786_0()
{    return new HashSet<String>(containers);}
getTtls
public Set<String> zookeeper_f1787_0()
{    return new HashSet<String>(ttls);}
getSessions
public Collection<Long> zookeeper_f1788_0()
{    return ephemerals.keySet();}
getNode
public DataNode zookeeper_f1789_0(String path)
{    return nodes.get(path);}
getNodeCount
public int zookeeper_f1790_0()
{    return nodes.size();}
getWatchCount
public int zookeeper_f1791_0()
{    return dataWatches.size() + childWatches.size();}
getEphemeralsCount
public int zookeeper_f1792_0()
{    int result = 0;    for (HashSet<String> set : ephemerals.values()) {        result += set.size();    }    return result;}
approximateDataSize
public long zookeeper_f1793_0()
{    long result = 0;    for (Map.Entry<String, DataNode> entry : nodes.entrySet()) {        DataNode value = entry.getValue();        synchronized (value) {            result += getNodeSize(entry.getKey(), value.data);        }    }    return result;}
getNodeSize
private static long zookeeper_f1794_0(String path, byte[] data)
{    return (path == null ? 0 : path.length()) + (data == null ? 0 : data.length);}
cachedApproximateDataSize
public long zookeeper_f1795_0()
{    return nodeDataSize.get();}
addConfigNode
public void zookeeper_f1796_0()
{    DataNode zookeeperZnode = nodes.get(procZookeeper);    if (zookeeperZnode != null) {                zookeeperZnode.addChild(configChildZookeeper);    } else {        assert false : "There's no /zookeeper znode - this should never happen.";    }    nodes.put(configZookeeper, new DataNode(new byte[0], -1L, new StatPersisted()));    try {                setACL(configZookeeper, ZooDefs.Ids.READ_ACL_UNSAFE, -1);    } catch (KeeperException.NoNodeException e) {        assert false : "There's no " + configZookeeper + " znode - this should never happen.";    }}
isSpecialPath
 boolean zookeeper_f1797_0(String path)
{    return rootZookeeper.equals(path) || procZookeeper.equals(path) || quotaZookeeper.equals(path) || configZookeeper.equals(path);}
copyStatPersisted
public static void zookeeper_f1798_0(StatPersisted from, StatPersisted to)
{    to.setAversion(from.getAversion());    to.setCtime(from.getCtime());    to.setCversion(from.getCversion());    to.setCzxid(from.getCzxid());    to.setMtime(from.getMtime());    to.setMzxid(from.getMzxid());    to.setPzxid(from.getPzxid());    to.setVersion(from.getVersion());    to.setEphemeralOwner(from.getEphemeralOwner());}
copyStat
public static void zookeeper_f1799_0(Stat from, Stat to)
{    to.setAversion(from.getAversion());    to.setCtime(from.getCtime());    to.setCversion(from.getCversion());    to.setCzxid(from.getCzxid());    to.setMtime(from.getMtime());    to.setMzxid(from.getMzxid());    to.setPzxid(from.getPzxid());    to.setVersion(from.getVersion());    to.setEphemeralOwner(from.getEphemeralOwner());    to.setDataLength(from.getDataLength());    to.setNumChildren(from.getNumChildren());}
updateCountBytes
public voidf1800_1String lastPrefix, long bytesDiff, int countDiff)
{    String statNode = Quotas.statPath(lastPrefix);    DataNode node = nodes.get(statNode);    StatsTrack updatedStat = null;    if (node == null) {                        return;    }    synchronized (node) {        updatedStat = new StatsTrack(new String(node.data));        updatedStat.setCount(updatedStat.getCount() + countDiff);        updatedStat.setBytes(updatedStat.getBytes() + bytesDiff);        node.data = updatedStat.toString().getBytes();    }        String quotaNode = Quotas.quotaPath(lastPrefix);    node = nodes.get(quotaNode);    StatsTrack thisStats = null;    if (node == null) {                        return;    }    synchronized (node) {        thisStats = new StatsTrack(new String(node.data));    }    if (thisStats.getCount() > -1 && (thisStats.getCount() < updatedStat.getCount())) {            }    if (thisStats.getBytes() > -1 && (thisStats.getBytes() < updatedStat.getBytes())) {            }}
createNode
public void zookeeper_f1801_0(final String path, byte[] data, List<ACL> acl, long ephemeralOwner, int parentCVersion, long zxid, long time) throws NoNodeException, NodeExistsException
{    createNode(path, data, acl, ephemeralOwner, parentCVersion, zxid, time, null);}
createNode
public void zookeeper_f1802_0(final String path, byte[] data, List<ACL> acl, long ephemeralOwner, int parentCVersion, long zxid, long time, Stat outputStat) throws KeeperException.NoNodeException, KeeperException.NodeExistsException
{    int lastSlash = path.lastIndexOf('/');    String parentName = path.substring(0, lastSlash);    String childName = path.substring(lastSlash + 1);    StatPersisted stat = new StatPersisted();    stat.setCtime(time);    stat.setMtime(time);    stat.setCzxid(zxid);    stat.setMzxid(zxid);    stat.setPzxid(zxid);    stat.setVersion(0);    stat.setAversion(0);    stat.setEphemeralOwner(ephemeralOwner);    DataNode parent = nodes.get(parentName);    if (parent == null) {        throw new KeeperException.NoNodeException();    }    synchronized (parent) {                                                                                                Long longval = aclCache.convertAcls(acl);        Set<String> children = parent.getChildren();        if (children.contains(childName)) {            throw new KeeperException.NodeExistsException();        }        nodes.preChange(parentName, parent);        if (parentCVersion == -1) {            parentCVersion = parent.stat.getCversion();            parentCVersion++;        }                if (parentCVersion > parent.stat.getCversion()) {            parent.stat.setCversion(parentCVersion);            parent.stat.setPzxid(zxid);        }        DataNode child = new DataNode(data, longval, stat);        parent.addChild(childName);        nodes.postChange(parentName, parent);        nodeDataSize.addAndGet(getNodeSize(path, child.data));        nodes.put(path, child);        EphemeralType ephemeralType = EphemeralType.get(ephemeralOwner);        if (ephemeralType == EphemeralType.CONTAINER) {            containers.add(path);        } else if (ephemeralType == EphemeralType.TTL) {            ttls.add(path);        } else if (ephemeralOwner != 0) {            HashSet<String> list = ephemerals.get(ephemeralOwner);            if (list == null) {                list = new HashSet<String>();                ephemerals.put(ephemeralOwner, list);            }            synchronized (list) {                list.add(path);            }        }        if (outputStat != null) {            child.copyStat(outputStat);        }    }        if (parentName.startsWith(quotaZookeeper)) {                if (Quotas.limitNode.equals(childName)) {                                    pTrie.addPath(parentName.substring(quotaZookeeper.length()));        }        if (Quotas.statNode.equals(childName)) {            updateQuotaForPath(parentName.substring(quotaZookeeper.length()));        }    }        String lastPrefix = getMaxPrefixWithQuota(path);    long bytes = data == null ? 0 : data.length;    if (lastPrefix != null) {                updateCountBytes(lastPrefix, bytes, 1);    }    updateWriteStat(path, bytes);    dataWatches.triggerWatch(path, Event.EventType.NodeCreated);    childWatches.triggerWatch(parentName.equals("") ? "/" : parentName, Event.EventType.NodeChildrenChanged);}
deleteNode
public void zookeeper_f1803_0(String path, long zxid) throws KeeperException.NoNodeException
{    int lastSlash = path.lastIndexOf('/');    String parentName = path.substring(0, lastSlash);    String childName = path.substring(lastSlash + 1);                DataNode parent = nodes.get(parentName);    if (parent == null) {        throw new KeeperException.NoNodeException();    }    synchronized (parent) {        nodes.preChange(parentName, parent);        parent.removeChild(childName);                if (zxid > parent.stat.getPzxid()) {            parent.stat.setPzxid(zxid);        }        nodes.postChange(parentName, parent);    }    DataNode node = nodes.get(path);    if (node == null) {        throw new KeeperException.NoNodeException();    }    nodes.remove(path);    synchronized (node) {        aclCache.removeUsage(node.acl);        nodeDataSize.addAndGet(-getNodeSize(path, node.data));    }        synchronized (parent) {        long eowner = node.stat.getEphemeralOwner();        EphemeralType ephemeralType = EphemeralType.get(eowner);        if (ephemeralType == EphemeralType.CONTAINER) {            containers.remove(path);        } else if (ephemeralType == EphemeralType.TTL) {            ttls.remove(path);        } else if (eowner != 0) {            Set<String> nodes = ephemerals.get(eowner);            if (nodes != null) {                synchronized (nodes) {                    nodes.remove(path);                }            }        }    }    if (parentName.startsWith(procZookeeper) && Quotas.limitNode.equals(childName)) {                        pTrie.deletePath(parentName.substring(quotaZookeeper.length()));    }        String lastPrefix = getMaxPrefixWithQuota(path);    if (lastPrefix != null) {                int bytes = 0;        synchronized (node) {            bytes = (node.data == null ? 0 : -(node.data.length));        }        updateCountBytes(lastPrefix, bytes, -1);    }    updateWriteStat(path, 0L);    if (LOG.isTraceEnabled()) {        ZooTrace.logTraceMessage(LOG, ZooTrace.EVENT_DELIVERY_TRACE_MASK, "dataWatches.triggerWatch " + path);        ZooTrace.logTraceMessage(LOG, ZooTrace.EVENT_DELIVERY_TRACE_MASK, "childWatches.triggerWatch " + parentName);    }    WatcherOrBitSet processed = dataWatches.triggerWatch(path, EventType.NodeDeleted);    childWatches.triggerWatch(path, EventType.NodeDeleted, processed);    childWatches.triggerWatch("".equals(parentName) ? "/" : parentName, EventType.NodeChildrenChanged);}
setData
public Stat zookeeper_f1804_0(String path, byte[] data, int version, long zxid, long time) throws KeeperException.NoNodeException
{    Stat s = new Stat();    DataNode n = nodes.get(path);    if (n == null) {        throw new KeeperException.NoNodeException();    }    byte[] lastdata = null;    synchronized (n) {        lastdata = n.data;        nodes.preChange(path, n);        n.data = data;        n.stat.setMtime(time);        n.stat.setMzxid(zxid);        n.stat.setVersion(version);        n.copyStat(s);        nodes.postChange(path, n);    }        String lastPrefix = getMaxPrefixWithQuota(path);    long dataBytes = data == null ? 0 : data.length;    if (lastPrefix != null) {        this.updateCountBytes(lastPrefix, dataBytes - (lastdata == null ? 0 : lastdata.length), 0);    }    nodeDataSize.addAndGet(getNodeSize(path, data) - getNodeSize(path, lastdata));    updateWriteStat(path, dataBytes);    dataWatches.triggerWatch(path, EventType.NodeDataChanged);    return s;}
getMaxPrefixWithQuota
public String zookeeper_f1805_0(String path)
{                String lastPrefix = pTrie.findMaxPrefix(path);    if (rootZookeeper.equals(lastPrefix) || lastPrefix.isEmpty()) {        return null;    } else {        return lastPrefix;    }}
getData
public byte[] zookeeper_f1806_0(String path, Stat stat, Watcher watcher) throws KeeperException.NoNodeException
{    DataNode n = nodes.get(path);    byte[] data = null;    if (n == null) {        throw new KeeperException.NoNodeException();    }    synchronized (n) {        n.copyStat(stat);        if (watcher != null) {            dataWatches.addWatch(path, watcher);        }        data = n.data;    }    updateReadStat(path, data == null ? 0 : data.length);    return data;}
statNode
public Stat zookeeper_f1807_0(String path, Watcher watcher) throws KeeperException.NoNodeException
{    Stat stat = new Stat();    DataNode n = nodes.get(path);    if (watcher != null) {        dataWatches.addWatch(path, watcher);    }    if (n == null) {        throw new KeeperException.NoNodeException();    }    synchronized (n) {        n.copyStat(stat);    }    updateReadStat(path, 0L);    return stat;}
getChildren
public List<String> zookeeper_f1808_0(String path, Stat stat, Watcher watcher) throws KeeperException.NoNodeException
{    DataNode n = nodes.get(path);    if (n == null) {        throw new KeeperException.NoNodeException();    }    List<String> children;    synchronized (n) {        if (stat != null) {            n.copyStat(stat);        }        children = new ArrayList<String>(n.getChildren());        if (watcher != null) {            childWatches.addWatch(path, watcher);        }    }    int bytes = 0;    for (String child : children) {        bytes += child.length();    }    updateReadStat(path, bytes);    return children;}
getAllChildrenNumber
public int zookeeper_f1809_0(String path)
{        if ("/".equals(path)) {        return nodes.size() - 2;    }    return (int) nodes.keySet().parallelStream().filter(key -> key.startsWith(path + "/")).count();}
setACL
public Stat zookeeper_f1810_0(String path, List<ACL> acl, int version) throws KeeperException.NoNodeException
{    Stat stat = new Stat();    DataNode n = nodes.get(path);    if (n == null) {        throw new KeeperException.NoNodeException();    }    synchronized (n) {        aclCache.removeUsage(n.acl);        nodes.preChange(path, n);        n.stat.setAversion(version);        n.acl = aclCache.convertAcls(acl);        n.copyStat(stat);        nodes.postChange(path, n);        return stat;    }}
getACL
public List<ACL> zookeeper_f1811_0(String path, Stat stat) throws KeeperException.NoNodeException
{    DataNode n = nodes.get(path);    if (n == null) {        throw new KeeperException.NoNodeException();    }    synchronized (n) {        if (stat != null) {            n.copyStat(stat);        }        return new ArrayList<ACL>(aclCache.convertLong(n.acl));    }}
getACL
public List<ACL> zookeeper_f1812_0(DataNode node)
{    synchronized (node) {        return aclCache.convertLong(node.acl);    }}
aclCacheSize
public int zookeeper_f1813_0()
{    return aclCache.size();}
equals
public boolean zookeeper_f1814_0(Object o)
{    if (o instanceof ProcessTxnResult) {        ProcessTxnResult other = (ProcessTxnResult) o;        return other.clientId == clientId && other.cxid == cxid;    }    return false;}
hashCode
public int zookeeper_f1815_0()
{    return (int) ((clientId ^ cxid) % Integer.MAX_VALUE);}
processTxn
public ProcessTxnResult zookeeper_f1816_0(TxnHeader header, Record txn)
{    return this.processTxn(header, txn, false);}
processTxn
public ProcessTxnResultf1817_1TxnHeader header, Record txn, boolean isSubTxn)
{    ProcessTxnResult rc = new ProcessTxnResult();    try {        rc.clientId = header.getClientId();        rc.cxid = header.getCxid();        rc.zxid = header.getZxid();        rc.type = header.getType();        rc.err = 0;        rc.multiResult = null;        switch(header.getType()) {            case OpCode.create:                CreateTxn createTxn = (CreateTxn) txn;                rc.path = createTxn.getPath();                createNode(createTxn.getPath(), createTxn.getData(), createTxn.getAcl(), createTxn.getEphemeral() ? header.getClientId() : 0, createTxn.getParentCVersion(), header.getZxid(), header.getTime(), null);                break;            case OpCode.create2:                CreateTxn create2Txn = (CreateTxn) txn;                rc.path = create2Txn.getPath();                Stat stat = new Stat();                createNode(create2Txn.getPath(), create2Txn.getData(), create2Txn.getAcl(), create2Txn.getEphemeral() ? header.getClientId() : 0, create2Txn.getParentCVersion(), header.getZxid(), header.getTime(), stat);                rc.stat = stat;                break;            case OpCode.createTTL:                CreateTTLTxn createTtlTxn = (CreateTTLTxn) txn;                rc.path = createTtlTxn.getPath();                stat = new Stat();                createNode(createTtlTxn.getPath(), createTtlTxn.getData(), createTtlTxn.getAcl(), EphemeralType.TTL.toEphemeralOwner(createTtlTxn.getTtl()), createTtlTxn.getParentCVersion(), header.getZxid(), header.getTime(), stat);                rc.stat = stat;                break;            case OpCode.createContainer:                CreateContainerTxn createContainerTxn = (CreateContainerTxn) txn;                rc.path = createContainerTxn.getPath();                stat = new Stat();                createNode(createContainerTxn.getPath(), createContainerTxn.getData(), createContainerTxn.getAcl(), EphemeralType.CONTAINER_EPHEMERAL_OWNER, createContainerTxn.getParentCVersion(), header.getZxid(), header.getTime(), stat);                rc.stat = stat;                break;            case OpCode.delete:            case OpCode.deleteContainer:                DeleteTxn deleteTxn = (DeleteTxn) txn;                rc.path = deleteTxn.getPath();                deleteNode(deleteTxn.getPath(), header.getZxid());                break;            case OpCode.reconfig:            case OpCode.setData:                SetDataTxn setDataTxn = (SetDataTxn) txn;                rc.path = setDataTxn.getPath();                rc.stat = setData(setDataTxn.getPath(), setDataTxn.getData(), setDataTxn.getVersion(), header.getZxid(), header.getTime());                break;            case OpCode.setACL:                SetACLTxn setACLTxn = (SetACLTxn) txn;                rc.path = setACLTxn.getPath();                rc.stat = setACL(setACLTxn.getPath(), setACLTxn.getAcl(), setACLTxn.getVersion());                break;            case OpCode.closeSession:                long sessionId = header.getClientId();                if (txn != null) {                    killSession(sessionId, header.getZxid(), ephemerals.remove(sessionId), ((CloseSessionTxn) txn).getPaths2Delete());                } else {                    killSession(sessionId, header.getZxid());                }                break;            case OpCode.error:                ErrorTxn errTxn = (ErrorTxn) txn;                rc.err = errTxn.getErr();                break;            case OpCode.check:                CheckVersionTxn checkTxn = (CheckVersionTxn) txn;                rc.path = checkTxn.getPath();                break;            case OpCode.multi:                MultiTxn multiTxn = (MultiTxn) txn;                List<Txn> txns = multiTxn.getTxns();                rc.multiResult = new ArrayList<ProcessTxnResult>();                boolean failed = false;                for (Txn subtxn : txns) {                    if (subtxn.getType() == OpCode.error) {                        failed = true;                        break;                    }                }                boolean post_failed = false;                for (Txn subtxn : txns) {                    ByteBuffer bb = ByteBuffer.wrap(subtxn.getData());                    Record record = null;                    switch(subtxn.getType()) {                        case OpCode.create:                            record = new CreateTxn();                            break;                        case OpCode.createTTL:                            record = new CreateTTLTxn();                            break;                        case OpCode.createContainer:                            record = new CreateContainerTxn();                            break;                        case OpCode.delete:                        case OpCode.deleteContainer:                            record = new DeleteTxn();                            break;                        case OpCode.setData:                            record = new SetDataTxn();                            break;                        case OpCode.error:                            record = new ErrorTxn();                            post_failed = true;                            break;                        case OpCode.check:                            record = new CheckVersionTxn();                            break;                        default:                            throw new IOException("Invalid type of op: " + subtxn.getType());                    }                    assert (record != null);                    ByteBufferInputStream.byteBuffer2Record(bb, record);                    if (failed && subtxn.getType() != OpCode.error) {                        int ec = post_failed ? Code.RUNTIMEINCONSISTENCY.intValue() : Code.OK.intValue();                        subtxn.setType(OpCode.error);                        record = new ErrorTxn(ec);                    }                    assert !failed || (subtxn.getType() == OpCode.error);                    TxnHeader subHdr = new TxnHeader(header.getClientId(), header.getCxid(), header.getZxid(), header.getTime(), subtxn.getType());                    ProcessTxnResult subRc = processTxn(subHdr, record, true);                    rc.multiResult.add(subRc);                    if (subRc.err != 0 && rc.err == 0) {                        rc.err = subRc.err;                    }                }                break;        }    } catch (KeeperException e) {                rc.err = e.code().intValue();    } catch (IOException e) {            }    /*         * Snapshots are taken lazily. When serializing a node, it's data         * and children copied in a synchronization block on that node,         * which means newly created node won't be in the snapshot, so         * we won't have mismatched cversion and pzxid when replaying the         * createNode txn.         *         * But there is a tricky scenario that if the child is deleted due         * to session close and re-created in a different global session         * after that the parent is serialized, then when replay the txn         * because the node is belonging to a different session, replay the         * closeSession txn won't delete it anymore, and we'll get NODEEXISTS         * error when replay the createNode txn. In this case, we need to         * update the cversion and pzxid to the new value.         *         * Note, such failures on DT should be seen only during         * restore.         */    if (header.getType() == OpCode.create && rc.err == Code.NODEEXISTS.intValue()) {                int lastSlash = rc.path.lastIndexOf('/');        String parentName = rc.path.substring(0, lastSlash);        CreateTxn cTxn = (CreateTxn) txn;        try {            setCversionPzxid(parentName, cTxn.getParentCVersion(), header.getZxid());        } catch (KeeperException.NoNodeException e) {                        rc.err = e.code().intValue();        }    } else if (rc.err != Code.OK.intValue()) {            }    /*         * Things we can only update after the whole txn is applied to data         * tree.         *         * If we update the lastProcessedZxid with the first sub txn in multi         * and there is a snapshot in progress, it's possible that the zxid         * associated with the snapshot only include partial of the multi op.         *         * When loading snapshot, it will only load the txns after the zxid         * associated with snapshot file, which could cause data inconsistency         * due to missing sub txns.         *         * To avoid this, we only update the lastProcessedZxid when the whole         * multi-op txn is applied to DataTree.         */    if (!isSubTxn) {        /*             * A snapshot might be in progress while we are modifying the data             * tree. If we set lastProcessedZxid prior to making corresponding             * change to the tree, then the zxid associated with the snapshot             * file will be ahead of its contents. Thus, while restoring from             * the snapshot, the restore method will not apply the transaction             * for zxid associated with the snapshot file, since the restore             * method assumes that transaction to be present in the snapshot.             *             * To avoid this, we first apply the transaction and then modify             * lastProcessedZxid.  During restore, we correctly handle the             * case where the snapshot contains data ahead of the zxid associated             * with the file.             */        if (rc.zxid > lastProcessedZxid) {            lastProcessedZxid = rc.zxid;        }        if (digestFromLoadedSnapshot != null) {            compareSnapshotDigests(rc.zxid);        } else {                        logZxidDigest(rc.zxid, getTreeDigest());        }    }    return rc;}
killSession
 void zookeeper_f1818_0(long session, long zxid)
{                            killSession(session, zxid, ephemerals.remove(session), null);}
killSession
 voidf1819_1long session, long zxid, Set<String> paths2DeleteLocal, List<String> paths2DeleteInTxn)
{    if (paths2DeleteInTxn != null) {        deleteNodes(session, zxid, paths2DeleteInTxn);    }    if (paths2DeleteLocal == null) {        return;    }    if (paths2DeleteInTxn != null) {                for (String path : paths2DeleteInTxn) {            paths2DeleteLocal.remove(path);        }        if (!paths2DeleteLocal.isEmpty()) {                    }    }    deleteNodes(session, zxid, paths2DeleteLocal);}
deleteNodes
 voidf1820_1long session, long zxid, Iterable<String> paths2Delete)
{    for (String path : paths2Delete) {        try {            deleteNode(path, zxid);            if (LOG.isDebugEnabled()) {                            }        } catch (NoNodeException e) {                    }    }}
getCounts
private void zookeeper_f1821_0(String path, Counts counts)
{    DataNode node = getNode(path);    if (node == null) {        return;    }    String[] children = null;    int len = 0;    synchronized (node) {        Set<String> childs = node.getChildren();        children = childs.toArray(new String[childs.size()]);        len = (node.data == null ? 0 : node.data.length);    }        counts.count += 1;    counts.bytes += len;    for (String child : children) {        getCounts(path + "/" + child, counts);    }}
updateQuotaForPath
private voidf1822_1String path)
{    Counts c = new Counts();    getCounts(path, c);    StatsTrack strack = new StatsTrack();    strack.setBytes(c.bytes);    strack.setCount(c.count);    String statPath = Quotas.quotaZookeeper + path + "/" + Quotas.statNode;    DataNode node = getNode(statPath);        if (node == null) {                return;    }    synchronized (node) {        nodes.preChange(statPath, node);        node.data = strack.toString().getBytes();        nodes.postChange(statPath, node);    }}
traverseNode
private void zookeeper_f1823_0(String path)
{    DataNode node = getNode(path);    String[] children = null;    synchronized (node) {        Set<String> childs = node.getChildren();        children = childs.toArray(new String[childs.size()]);    }    if (children.length == 0) {                                String endString = "/" + Quotas.limitNode;        if (path.endsWith(endString)) {                                                String realPath = path.substring(Quotas.quotaZookeeper.length(), path.indexOf(endString));            updateQuotaForPath(realPath);            this.pTrie.addPath(realPath);        }        return;    }    for (String child : children) {        traverseNode(path + "/" + child);    }}
setupQuota
private void zookeeper_f1824_0()
{    String quotaPath = Quotas.quotaZookeeper;    DataNode node = getNode(quotaPath);    if (node == null) {        return;    }    traverseNode(quotaPath);}
serializeNode
 void zookeeper_f1825_0(OutputArchive oa, StringBuilder path) throws IOException
{    String pathString = path.toString();    DataNode node = getNode(pathString);    if (node == null) {        return;    }    String[] children = null;    DataNode nodeCopy;    synchronized (node) {        StatPersisted statCopy = new StatPersisted();        copyStatPersisted(node.stat, statCopy);                        nodeCopy = new DataNode(node.data, node.acl, statCopy);        Set<String> childs = node.getChildren();        children = childs.toArray(new String[childs.size()]);    }    serializeNodeData(oa, pathString, nodeCopy);    path.append('/');    int off = path.length();    for (String child : children) {                                path.delete(off, Integer.MAX_VALUE);        path.append(child);        serializeNode(oa, path);    }}
serializeNodeData
public void zookeeper_f1826_0(OutputArchive oa, String path, DataNode node) throws IOException
{    oa.writeString(path, "path");    oa.writeRecord(node, "node");}
serializeAcls
public void zookeeper_f1827_0(OutputArchive oa) throws IOException
{    aclCache.serialize(oa);}
serializeNodes
public void zookeeper_f1828_0(OutputArchive oa) throws IOException
{    serializeNode(oa, new StringBuilder());        if (root != null) {        oa.writeString("/", "path");    }}
serialize
public void zookeeper_f1829_0(OutputArchive oa, String tag) throws IOException
{    serializeAcls(oa);    serializeNodes(oa);}
deserialize
public void zookeeper_f1830_0(InputArchive ia, String tag) throws IOException
{    aclCache.deserialize(ia);    nodes.clear();    pTrie.clear();    nodeDataSize.set(0);    String path = ia.readString("path");    while (!"/".equals(path)) {        DataNode node = new DataNode();        ia.readRecord(node, "node");        nodes.put(path, node);        synchronized (node) {            aclCache.addUsage(node.acl);        }        int lastSlash = path.lastIndexOf('/');        if (lastSlash == -1) {            root = node;        } else {            String parentPath = path.substring(0, lastSlash);            DataNode parent = nodes.get(parentPath);            if (parent == null) {                throw new IOException("Invalid Datatree, unable to find " + "parent " + parentPath + " of path " + path);            }            parent.addChild(path.substring(lastSlash + 1));            long eowner = node.stat.getEphemeralOwner();            EphemeralType ephemeralType = EphemeralType.get(eowner);            if (ephemeralType == EphemeralType.CONTAINER) {                containers.add(path);            } else if (ephemeralType == EphemeralType.TTL) {                ttls.add(path);            } else if (eowner != 0) {                HashSet<String> list = ephemerals.get(eowner);                if (list == null) {                    list = new HashSet<String>();                    ephemerals.put(eowner, list);                }                list.add(path);            }        }        path = ia.readString("path");    }            nodes.putWithoutDigest("/", root);    nodeDataSize.set(approximateDataSize());                    setupQuota();    aclCache.purgeUnused();}
dumpWatchesSummary
public synchronized void zookeeper_f1831_0(PrintWriter pwriter)
{    pwriter.print(dataWatches.toString());}
dumpWatches
public synchronized void zookeeper_f1832_0(PrintWriter pwriter, boolean byPath)
{    dataWatches.dumpWatches(pwriter, byPath);}
getWatches
public synchronized WatchesReport zookeeper_f1833_0()
{    return dataWatches.getWatches();}
getWatchesByPath
public synchronized WatchesPathReport zookeeper_f1834_0()
{    return dataWatches.getWatchesByPath();}
getWatchesSummary
public synchronized WatchesSummary zookeeper_f1835_0()
{    return dataWatches.getWatchesSummary();}
dumpEphemerals
public void zookeeper_f1836_0(PrintWriter pwriter)
{    pwriter.println("Sessions with Ephemerals (" + ephemerals.keySet().size() + "):");    for (Entry<Long, HashSet<String>> entry : ephemerals.entrySet()) {        pwriter.print("0x" + Long.toHexString(entry.getKey()));        pwriter.println(":");        Set<String> tmp = entry.getValue();        if (tmp != null) {            synchronized (tmp) {                for (String path : tmp) {                    pwriter.println("\t" + path);                }            }        }    }}
shutdownWatcher
public void zookeeper_f1837_0()
{    dataWatches.shutdown();    childWatches.shutdown();}
getEphemerals
public Map<Long, Set<String>> zookeeper_f1838_0()
{    Map<Long, Set<String>> ephemeralsCopy = new HashMap<Long, Set<String>>();    for (Entry<Long, HashSet<String>> e : ephemerals.entrySet()) {        synchronized (e.getValue()) {            ephemeralsCopy.put(e.getKey(), new HashSet<String>(e.getValue()));        }    }    return ephemeralsCopy;}
removeCnxn
public void zookeeper_f1839_0(Watcher watcher)
{    dataWatches.removeWatcher(watcher);    childWatches.removeWatcher(watcher);}
setWatches
public void zookeeper_f1840_0(long relativeZxid, List<String> dataWatches, List<String> existWatches, List<String> childWatches, Watcher watcher)
{    for (String path : dataWatches) {        DataNode node = getNode(path);        WatchedEvent e = null;        if (node == null) {            watcher.process(new WatchedEvent(EventType.NodeDeleted, KeeperState.SyncConnected, path));        } else if (node.stat.getMzxid() > relativeZxid) {            watcher.process(new WatchedEvent(EventType.NodeDataChanged, KeeperState.SyncConnected, path));        } else {            this.dataWatches.addWatch(path, watcher);        }    }    for (String path : existWatches) {        DataNode node = getNode(path);        if (node != null) {            watcher.process(new WatchedEvent(EventType.NodeCreated, KeeperState.SyncConnected, path));        } else {            this.dataWatches.addWatch(path, watcher);        }    }    for (String path : childWatches) {        DataNode node = getNode(path);        if (node == null) {            watcher.process(new WatchedEvent(EventType.NodeDeleted, KeeperState.SyncConnected, path));        } else if (node.stat.getPzxid() > relativeZxid) {            watcher.process(new WatchedEvent(EventType.NodeChildrenChanged, KeeperState.SyncConnected, path));        } else {            this.childWatches.addWatch(path, watcher);        }    }}
setCversionPzxid
public void zookeeper_f1841_0(String path, int newCversion, long zxid) throws KeeperException.NoNodeException
{    if (path.endsWith("/")) {        path = path.substring(0, path.length() - 1);    }    DataNode node = nodes.get(path);    if (node == null) {        throw new KeeperException.NoNodeException(path);    }    synchronized (node) {        if (newCversion == -1) {            newCversion = node.stat.getCversion() + 1;        }        if (newCversion > node.stat.getCversion()) {            nodes.preChange(path, node);            node.stat.setCversion(newCversion);            node.stat.setPzxid(zxid);            nodes.postChange(path, node);        }    }}
containsWatcher
public boolean zookeeper_f1842_0(String path, WatcherType type, Watcher watcher)
{    boolean containsWatcher = false;    switch(type) {        case Children:            containsWatcher = this.childWatches.containsWatcher(path, watcher);            break;        case Data:            containsWatcher = this.dataWatches.containsWatcher(path, watcher);            break;        case Any:            if (this.childWatches.containsWatcher(path, watcher)) {                containsWatcher = true;            }            if (this.dataWatches.containsWatcher(path, watcher)) {                containsWatcher = true;            }            break;    }    return containsWatcher;}
removeWatch
public boolean zookeeper_f1843_0(String path, WatcherType type, Watcher watcher)
{    boolean removed = false;    switch(type) {        case Children:            removed = this.childWatches.removeWatcher(path, watcher);            break;        case Data:            removed = this.dataWatches.removeWatcher(path, watcher);            break;        case Any:            if (this.childWatches.removeWatcher(path, watcher)) {                removed = true;            }            if (this.dataWatches.removeWatcher(path, watcher)) {                removed = true;            }            break;    }    return removed;}
getReferenceCountedAclCache
public ReferenceCountedACLCache zookeeper_f1844_0()
{    return aclCache;}
getTopNamespace
private String zookeeper_f1845_0(String path)
{    String[] parts = path.split("/");    return parts.length > 1 ? parts[1] : null;}
updateReadStat
private void zookeeper_f1846_0(String path, long bytes)
{    String namespace = getTopNamespace(path);    if (namespace == null) {        return;    }    long totalBytes = path.length() + bytes + STAT_OVERHEAD_BYTES;    ServerMetrics.getMetrics().READ_PER_NAMESPACE.add(namespace, totalBytes);}
updateWriteStat
private void zookeeper_f1847_0(String path, long bytes)
{    String namespace = getTopNamespace(path);    if (namespace == null) {        return;    }    ServerMetrics.getMetrics().WRITE_PER_NAMESPACE.add(namespace, path.length() + bytes);}
logZxidDigest
private void zookeeper_f1848_0(long zxid, long digest)
{    ZxidDigest zxidDigest = new ZxidDigest(zxid, digestCalculator.getDigestVersion(), digest);    lastProcessedZxidDigest = zxidDigest;    if (zxidDigest.zxid % DIGEST_LOG_INTERVAL == 0) {        synchronized (digestLog) {            digestLog.add(zxidDigest);            if (digestLog.size() > DIGEST_LOG_LIMIT) {                digestLog.poll();            }        }    }}
serializeZxidDigest
public boolean zookeeper_f1849_0(OutputArchive oa) throws IOException
{    if (!ZooKeeperServer.isDigestEnabled()) {        return false;    }    ZxidDigest zxidDigest = lastProcessedZxidDigest;    if (zxidDigest == null) {                zxidDigest = new ZxidDigest();    }    zxidDigest.serialize(oa);    return true;}
deserializeZxidDigest
public booleanf1850_1InputArchive ia) throws IOException
{    if (!ZooKeeperServer.isDigestEnabled()) {        return false;    }    try {        ZxidDigest zxidDigest = new ZxidDigest();        zxidDigest.deserialize(ia);        if (zxidDigest.zxid > 0) {            digestFromLoadedSnapshot = zxidDigest;        }        return true;    } catch (EOFException e) {                return false;    }}
compareSnapshotDigests
public voidf1851_1long zxid)
{    if (zxid == digestFromLoadedSnapshot.zxid) {        if (digestCalculator.getDigestVersion() != digestFromLoadedSnapshot.digestVersion) {                        digestFromLoadedSnapshot = null;            return;        }        if (getTreeDigest() != digestFromLoadedSnapshot.getDigest()) {            reportDigestMismatch(zxid);        }        digestFromLoadedSnapshot = null;    } else if (digestFromLoadedSnapshot.zxid != 0 && zxid > digestFromLoadedSnapshot.zxid) {            }}
reportDigestMismatch
public void zookeeper_f1852_0(long zxid)
{    ServerMetrics.getMetrics().DIGEST_MISMATCHES_COUNT.add(1);    RATE_LOGGER.rateLimitLog("Digests are not matching. Value is Zxid.", String.valueOf(zxid));    for (DigestWatcher watcher : digestWatchers) {        watcher.process(zxid);    }}
getTreeDigest
public long zookeeper_f1853_0()
{    return nodes.getDigest();}
getLastProcessedZxidDigest
public ZxidDigest zookeeper_f1854_0()
{    return lastProcessedZxidDigest;}
getDigestFromLoadedSnapshot
public ZxidDigest zookeeper_f1855_0()
{    return digestFromLoadedSnapshot;}
addDigestWatcher
public void zookeeper_f1856_0(DigestWatcher digestWatcher)
{    digestWatchers.add(digestWatcher);}
getDigestLog
public List<ZxidDigest> zookeeper_f1857_0()
{    synchronized (digestLog) {                return new LinkedList<ZxidDigest>(digestLog);    }}
serialize
public void zookeeper_f1858_0(OutputArchive oa) throws IOException
{    oa.writeLong(zxid, "zxid");    oa.writeInt(digestVersion, "digestVersion");    oa.writeLong(digest, "digest");}
deserialize
public void zookeeper_f1859_0(InputArchive ia) throws IOException
{    zxid = ia.readLong("zxid");    digestVersion = ia.readInt("digestVersion");        if (digestVersion < 2) {        String d = ia.readString("digest");        if (d != null) {            digest = Long.parseLong(d);        }    } else {        digest = ia.readLong("digest");    }}
getZxid
public long zookeeper_f1860_0()
{    return zxid;}
getDigestVersion
public int zookeeper_f1861_0()
{    return digestVersion;}
getDigest
public Long zookeeper_f1862_0()
{    return digest;}
getNodeCount
public int zookeeper_f1863_0()
{    return dataTree.getNodeCount();}
approximateDataSize
public long zookeeper_f1864_0()
{    return dataTree.cachedApproximateDataSize();}
countEphemerals
public int zookeeper_f1865_0()
{    return dataTree.getEphemeralsCount();}
getWatchCount
public int zookeeper_f1866_0()
{    return dataTree.getWatchCount();}
getName
public String zookeeper_f1867_0()
{    return "InMemoryDataTree";}
isHidden
public boolean zookeeper_f1868_0()
{    return false;}
getLastZxid
public String zookeeper_f1869_0()
{    return "0x" + Long.toHexString(dataTree.lastProcessedZxid);}
calculateDigest
 long zookeeper_f1870_0(String path, byte[] data, StatPersisted stat)
{    if (!ZooKeeperServer.isDigestEnabled()) {        return 0;    }        if (path.startsWith(ZooDefs.ZOOKEEPER_NODE_SUBTREE)) {        return 0;    }        if (path.equals("/")) {        path = "";    }        byte[] b = new byte[60];    ByteBuffer bb = ByteBuffer.wrap(b);    bb.putLong(stat.getCzxid());    bb.putLong(stat.getMzxid());    bb.putLong(stat.getPzxid());    bb.putLong(stat.getCtime());    bb.putLong(stat.getMtime());    bb.putInt(stat.getVersion());    bb.putInt(stat.getCversion());    bb.putInt(stat.getAversion());    bb.putLong(stat.getEphemeralOwner());    CRC32 crc = new CRC32();    crc.update(path.getBytes());    if (data != null) {        crc.update(data);    }    crc.update(b);    return crc.getValue();}
calculateDigest
 long zookeeper_f1871_0(String path, DataNode node)
{    if (!node.isDigestCached()) {        node.setDigest(calculateDigest(path, node.getData(), node.stat));        node.setDigestCached(true);    }    return node.getDigest();}
getDigestVersion
 int zookeeper_f1872_0()
{    return DIGEST_VERSION;}
setSessionTimeout
 void zookeeper_f1873_0(int sessionTimeout)
{}
process
public void zookeeper_f1874_0(WatchedEvent event)
{}
getSessionTimeout
 int zookeeper_f1875_0()
{    return 0;}
close
public void zookeeper_f1876_0(DisconnectReason reason)
{}
sendResponse
public void zookeeper_f1877_0(ReplyHeader h, Record r, String tag, String cacheKey, Stat stat) throws IOException
{}
sendCloseSession
public void zookeeper_f1878_0()
{}
getSessionId
public long zookeeper_f1879_0()
{    return sessionId;}
setSessionId
 void zookeeper_f1880_0(long sessionId)
{}
sendBuffer
 void zookeeper_f1881_0(ByteBuffer... closeConn)
{}
enableRecv
 void zookeeper_f1882_0()
{}
disableRecv
 void zookeeper_f1883_0(boolean waitDisableRecv)
{}
serverStats
protected ServerStats zookeeper_f1884_0()
{    return null;}
getOutstandingRequests
public long zookeeper_f1885_0()
{    return 0;}
getRemoteSocketAddress
public InetSocketAddress zookeeper_f1886_0()
{    return null;}
getInterestOps
public int zookeeper_f1887_0()
{    return 0;}
isSecure
public boolean zookeeper_f1888_0()
{    return false;}
getClientCertificateChain
public Certificate[] zookeeper_f1889_0()
{    return null;}
setClientCertificateChain
public void zookeeper_f1890_0(Certificate[] chain)
{}
maxValue
public long zookeeper_f1891_0()
{    return 0;}
toEphemeralOwner
public long zookeeper_f1892_0(long value)
{    return 0;}
getValue
public long zookeeper_f1893_0(long ephemeralOwner)
{    return 0;}
extendedEphemeralTypesEnabled
public static boolean zookeeper_f1894_0()
{    return Boolean.getBoolean(EXTENDED_TYPES_ENABLED_PROPERTY);}
get
public static EphemeralType zookeeper_f1895_0(long ephemeralOwner)
{    if (extendedEphemeralTypesEnabled()) {        if (Boolean.getBoolean(TTL_3_5_3_EMULATION_PROPERTY)) {            if (EphemeralTypeEmulate353.get(ephemeralOwner) == EphemeralTypeEmulate353.TTL) {                return TTL;            }        }        if ((ephemeralOwner & EXTENDED_MASK) == EXTENDED_MASK) {            long extendedFeatureBit = getExtendedFeatureBit(ephemeralOwner);            EphemeralType ephemeralType = extendedFeatureMap.get(extendedFeatureBit);            if (ephemeralType == null) {                throw new IllegalArgumentException(String.format("Invalid ephemeralOwner. [%s]", Long.toHexString(ephemeralOwner)));            }            return ephemeralType;        }    }    if (ephemeralOwner == CONTAINER_EPHEMERAL_OWNER) {        return CONTAINER;    }    return (ephemeralOwner == 0) ? VOID : NORMAL;}
validateServerId
public static void zookeeper_f1896_0(long serverId)
{    if (extendedEphemeralTypesEnabled()) {        if (serverId > EphemeralType.MAX_EXTENDED_SERVER_ID) {            throw new RuntimeException("extendedTypesEnabled is true but Server ID is too large. Cannot be larger than " + EphemeralType.MAX_EXTENDED_SERVER_ID);        }    }}
validateTTL
public static void zookeeper_f1897_0(CreateMode mode, long ttl)
{    if (mode.isTTL()) {        TTL.toEphemeralOwner(ttl);    } else if (ttl >= 0) {        throw new IllegalArgumentException("ttl not valid for mode: " + mode);    }}
getExtendedFeatureBit
private static long zookeeper_f1898_0(long ephemeralOwner)
{    return (ephemeralOwner & RESERVED_BITS_MASK) >> RESERVED_BITS_SHIFT;}
getExtendedFeatureValue
private static long zookeeper_f1899_0(long ephemeralOwner)
{    return ephemeralOwner & EXTENDED_FEATURE_VALUE_MASK;}
maxValue
public long zookeeper_f1900_0()
{        return EXTENDED_FEATURE_VALUE_MASK;}
toEphemeralOwner
public long zookeeper_f1901_0(long ttl)
{    if ((ttl > TTL.maxValue()) || (ttl <= 0)) {        throw new IllegalArgumentException("ttl must be positive and cannot be larger than: " + TTL.maxValue());    }        return EXTENDED_MASK | EXTENDED_BIT_TTL |     ttl;}
getValue
public long zookeeper_f1902_0(long ephemeralOwner)
{    return getExtendedFeatureValue(ephemeralOwner);}
get
public static EphemeralTypeEmulate353 zookeeper_f1903_0(long ephemeralOwner)
{    if (ephemeralOwner == CONTAINER_EPHEMERAL_OWNER) {        return CONTAINER;    }    if (ephemeralOwner < 0) {        return TTL;    }    return (ephemeralOwner == 0) ? VOID : NORMAL;}
ttlToEphemeralOwner
public static long zookeeper_f1904_0(long ttl)
{    if ((ttl > MAX_TTL) || (ttl <= 0)) {        throw new IllegalArgumentException("ttl must be positive and cannot be larger than: " + MAX_TTL);    }    return TTL_MASK | ttl;}
getValue
public int zookeeper_f1905_0()
{    return value;}
roundToNextInterval
private long zookeeper_f1906_0(long time)
{    return (time / expirationInterval + 1) * expirationInterval;}
remove
public Long zookeeper_f1907_0(E elem)
{    Long expiryTime = elemMap.remove(elem);    if (expiryTime != null) {        Set<E> set = expiryMap.get(expiryTime);        if (set != null) {            set.remove(elem);                        }    }    return expiryTime;}
update
public Long zookeeper_f1908_0(E elem, int timeout)
{    Long prevExpiryTime = elemMap.get(elem);    long now = Time.currentElapsedTime();    Long newExpiryTime = roundToNextInterval(now + timeout);    if (newExpiryTime.equals(prevExpiryTime)) {                return null;    }        Set<E> set = expiryMap.get(newExpiryTime);    if (set == null) {                set = Collections.newSetFromMap(new ConcurrentHashMap<E, Boolean>());                        Set<E> existingSet = expiryMap.putIfAbsent(newExpiryTime, set);        if (existingSet != null) {            set = existingSet;        }    }    set.add(elem);            prevExpiryTime = elemMap.put(elem, newExpiryTime);    if (prevExpiryTime != null && !newExpiryTime.equals(prevExpiryTime)) {        Set<E> prevSet = expiryMap.get(prevExpiryTime);        if (prevSet != null) {            prevSet.remove(elem);        }    }    return newExpiryTime;}
getWaitTime
public long zookeeper_f1909_0()
{    long now = Time.currentElapsedTime();    long expirationTime = nextExpirationTime.get();    return now < expirationTime ? (expirationTime - now) : 0L;}
poll
public Set<E> zookeeper_f1910_0()
{    long now = Time.currentElapsedTime();    long expirationTime = nextExpirationTime.get();    if (now < expirationTime) {        return Collections.emptySet();    }    Set<E> set = null;    long newExpirationTime = expirationTime + expirationInterval;    if (nextExpirationTime.compareAndSet(expirationTime, newExpirationTime)) {        set = expiryMap.remove(expirationTime);    }    if (set == null) {        return Collections.emptySet();    }    return set;}
dump
public void zookeeper_f1911_0(PrintWriter pwriter)
{    pwriter.print("Sets (");    pwriter.print(expiryMap.size());    pwriter.print(")/(");    pwriter.print(elemMap.size());    pwriter.println("):");    ArrayList<Long> keys = new ArrayList<Long>(expiryMap.keySet());    Collections.sort(keys);    for (long time : keys) {        Set<E> set = expiryMap.get(time);        if (set != null) {            pwriter.print(set.size());            pwriter.print(" expire at ");            pwriter.print(Time.elapsedTimeToDate(time));            pwriter.println(":");            for (E elem : set) {                pwriter.print("\t");                pwriter.println(elem.toString());            }        }    }}
getExpiryMap
public Map<Long, Set<E>> zookeeper_f1912_0()
{    return Collections.unmodifiableMap(expiryMap);}
processRequest
public voidf1913_1Request request)
{            long traceMask = ZooTrace.CLIENT_REQUEST_TRACE_MASK;    if (request.type == OpCode.ping) {        traceMask = ZooTrace.SERVER_PING_TRACE_MASK;    }    if (LOG.isTraceEnabled()) {        ZooTrace.logRequest(LOG, traceMask, 'E', request, "");    }    ProcessTxnResult rc = zks.processTxn(request);        if (request.type == OpCode.closeSession && connClosedByClient(request)) {                if (closeSession(zks.serverCnxnFactory, request.sessionId) || closeSession(zks.secureServerCnxnFactory, request.sessionId)) {            return;        }    }    if (request.getHdr() != null) {        /*             * Request header is created only by the leader, so this must be             * a quorum request. Since we're comparing timestamps across hosts,             * this metric may be incorrect. However, it's still a very useful             * metric to track in the happy case. If there is clock drift,             * the latency can go negative. Note: headers use wall time, not             * CLOCK_MONOTONIC.             */        long propagationLatency = Time.currentWallTime() - request.getHdr().getTime();        if (propagationLatency >= 0) {            ServerMetrics.getMetrics().PROPAGATION_LATENCY.add(propagationLatency);        }    }    if (request.cnxn == null) {        return;    }    ServerCnxn cnxn = request.cnxn;    long lastZxid = zks.getZKDatabase().getDataTreeLastProcessedZxid();    String lastOp = "NA";            zks.decInProcess();    zks.requestFinished(request);    Code err = Code.OK;    Record rsp = null;    String path = null;    try {        if (request.getHdr() != null && request.getHdr().getType() == OpCode.error) {            /*                 * When local session upgrading is disabled, leader will                 * reject the ephemeral node creation due to session expire.                 * However, if this is the follower that issue the request,                 * it will have the correct error code, so we should use that                 * and report to user                 */            if (request.getException() != null) {                throw request.getException();            } else {                throw KeeperException.create(KeeperException.Code.get(((ErrorTxn) request.getTxn()).getErr()));            }        }        KeeperException ke = request.getException();        if (ke instanceof SessionMovedException) {            throw ke;        }        if (ke != null && request.type != OpCode.multi) {            throw ke;        }                if (request.isStale()) {            ServerMetrics.getMetrics().STALE_REPLIES.add(1);        }        switch(request.type) {            case OpCode.ping:                {                    lastOp = "PING";                    updateStats(request, lastOp, lastZxid);                    cnxn.sendResponse(new ReplyHeader(-2, lastZxid, 0), null, "response");                    return;                }            case OpCode.createSession:                {                    lastOp = "SESS";                    updateStats(request, lastOp, lastZxid);                    zks.finishSessionInit(request.cnxn, true);                    return;                }            case OpCode.multi:                {                    lastOp = "MULT";                    rsp = new MultiResponse();                    for (ProcessTxnResult subTxnResult : rc.multiResult) {                        OpResult subResult;                        switch(subTxnResult.type) {                            case OpCode.check:                                subResult = new CheckResult();                                break;                            case OpCode.create:                                subResult = new CreateResult(subTxnResult.path);                                break;                            case OpCode.create2:                            case OpCode.createTTL:                            case OpCode.createContainer:                                subResult = new CreateResult(subTxnResult.path, subTxnResult.stat);                                break;                            case OpCode.delete:                            case OpCode.deleteContainer:                                subResult = new DeleteResult();                                break;                            case OpCode.setData:                                subResult = new SetDataResult(subTxnResult.stat);                                break;                            case OpCode.error:                                subResult = new ErrorResult(subTxnResult.err);                                if (subTxnResult.err == Code.SESSIONMOVED.intValue()) {                                    throw new SessionMovedException();                                }                                break;                            default:                                throw new IOException("Invalid type of op");                        }                        ((MultiResponse) rsp).add(subResult);                    }                    break;                }            case OpCode.multiRead:                {                    lastOp = "MLTR";                    MultiOperationRecord multiReadRecord = new MultiOperationRecord();                    ByteBufferInputStream.byteBuffer2Record(request.request, multiReadRecord);                    rsp = new MultiResponse();                    OpResult subResult;                    for (Op readOp : multiReadRecord) {                        try {                            Record rec;                            switch(readOp.getType()) {                                case OpCode.getChildren:                                    rec = handleGetChildrenRequest(readOp.toRequestRecord(), cnxn, request.authInfo);                                    subResult = new GetChildrenResult(((GetChildrenResponse) rec).getChildren());                                    break;                                case OpCode.getData:                                    rec = handleGetDataRequest(readOp.toRequestRecord(), cnxn, request.authInfo);                                    GetDataResponse gdr = (GetDataResponse) rec;                                    subResult = new GetDataResult(gdr.getData(), gdr.getStat());                                    break;                                default:                                    throw new IOException("Invalid type of readOp");                            }                        } catch (KeeperException e) {                            subResult = new ErrorResult(e.code().intValue());                        }                        ((MultiResponse) rsp).add(subResult);                    }                    break;                }            case OpCode.create:                {                    lastOp = "CREA";                    rsp = new CreateResponse(rc.path);                    err = Code.get(rc.err);                    requestPathMetricsCollector.registerRequest(request.type, rc.path);                    break;                }            case OpCode.create2:            case OpCode.createTTL:            case OpCode.createContainer:                {                    lastOp = "CREA";                    rsp = new Create2Response(rc.path, rc.stat);                    err = Code.get(rc.err);                    requestPathMetricsCollector.registerRequest(request.type, rc.path);                    break;                }            case OpCode.delete:            case OpCode.deleteContainer:                {                    lastOp = "DELE";                    err = Code.get(rc.err);                    requestPathMetricsCollector.registerRequest(request.type, rc.path);                    break;                }            case OpCode.setData:                {                    lastOp = "SETD";                    rsp = new SetDataResponse(rc.stat);                    err = Code.get(rc.err);                    requestPathMetricsCollector.registerRequest(request.type, rc.path);                    break;                }            case OpCode.reconfig:                {                    lastOp = "RECO";                    rsp = new GetDataResponse(((QuorumZooKeeperServer) zks).self.getQuorumVerifier().toString().getBytes(), rc.stat);                    err = Code.get(rc.err);                    break;                }            case OpCode.setACL:                {                    lastOp = "SETA";                    rsp = new SetACLResponse(rc.stat);                    err = Code.get(rc.err);                    requestPathMetricsCollector.registerRequest(request.type, rc.path);                    break;                }            case OpCode.closeSession:                {                    lastOp = "CLOS";                    err = Code.get(rc.err);                    break;                }            case OpCode.sync:                {                    lastOp = "SYNC";                    SyncRequest syncRequest = new SyncRequest();                    ByteBufferInputStream.byteBuffer2Record(request.request, syncRequest);                    rsp = new SyncResponse(syncRequest.getPath());                    requestPathMetricsCollector.registerRequest(request.type, syncRequest.getPath());                    break;                }            case OpCode.check:                {                    lastOp = "CHEC";                    rsp = new SetDataResponse(rc.stat);                    err = Code.get(rc.err);                    break;                }            case OpCode.exists:                {                    lastOp = "EXIS";                                        ExistsRequest existsRequest = new ExistsRequest();                    ByteBufferInputStream.byteBuffer2Record(request.request, existsRequest);                    path = existsRequest.getPath();                    if (path.indexOf('\0') != -1) {                        throw new KeeperException.BadArgumentsException();                    }                    Stat stat = zks.getZKDatabase().statNode(path, existsRequest.getWatch() ? cnxn : null);                    rsp = new ExistsResponse(stat);                    requestPathMetricsCollector.registerRequest(request.type, path);                    break;                }            case OpCode.getData:                {                    lastOp = "GETD";                    GetDataRequest getDataRequest = new GetDataRequest();                    ByteBufferInputStream.byteBuffer2Record(request.request, getDataRequest);                    path = getDataRequest.getPath();                    rsp = handleGetDataRequest(getDataRequest, cnxn, request.authInfo);                    requestPathMetricsCollector.registerRequest(request.type, path);                    break;                }            case OpCode.setWatches:                {                    lastOp = "SETW";                    SetWatches setWatches = new SetWatches();                                        request.request.rewind();                    ByteBufferInputStream.byteBuffer2Record(request.request, setWatches);                    long relativeZxid = setWatches.getRelativeZxid();                    zks.getZKDatabase().setWatches(relativeZxid, setWatches.getDataWatches(), setWatches.getExistWatches(), setWatches.getChildWatches(), cnxn);                    break;                }            case OpCode.getACL:                {                    lastOp = "GETA";                    GetACLRequest getACLRequest = new GetACLRequest();                    ByteBufferInputStream.byteBuffer2Record(request.request, getACLRequest);                    path = getACLRequest.getPath();                    DataNode n = zks.getZKDatabase().getNode(path);                    if (n == null) {                        throw new KeeperException.NoNodeException();                    }                    zks.checkACL(request.cnxn, zks.getZKDatabase().aclForNode(n), ZooDefs.Perms.READ | ZooDefs.Perms.ADMIN, request.authInfo, path, null);                    Stat stat = new Stat();                    List<ACL> acl = zks.getZKDatabase().getACL(path, stat);                    requestPathMetricsCollector.registerRequest(request.type, getACLRequest.getPath());                    try {                        zks.checkACL(request.cnxn, zks.getZKDatabase().aclForNode(n), ZooDefs.Perms.ADMIN, request.authInfo, path, null);                        rsp = new GetACLResponse(acl, stat);                    } catch (KeeperException.NoAuthException e) {                        List<ACL> acl1 = new ArrayList<ACL>(acl.size());                        for (ACL a : acl) {                            if ("digest".equals(a.getId().getScheme())) {                                Id id = a.getId();                                Id id1 = new Id(id.getScheme(), id.getId().replaceAll(":.*", ":x"));                                acl1.add(new ACL(a.getPerms(), id1));                            } else {                                acl1.add(a);                            }                        }                        rsp = new GetACLResponse(acl1, stat);                    }                    break;                }            case OpCode.getChildren:                {                    lastOp = "GETC";                    GetChildrenRequest getChildrenRequest = new GetChildrenRequest();                    ByteBufferInputStream.byteBuffer2Record(request.request, getChildrenRequest);                    path = getChildrenRequest.getPath();                    rsp = handleGetChildrenRequest(getChildrenRequest, cnxn, request.authInfo);                    requestPathMetricsCollector.registerRequest(request.type, path);                    break;                }            case OpCode.getAllChildrenNumber:                {                    lastOp = "GETACN";                    GetAllChildrenNumberRequest getAllChildrenNumberRequest = new GetAllChildrenNumberRequest();                    ByteBufferInputStream.byteBuffer2Record(request.request, getAllChildrenNumberRequest);                    path = getAllChildrenNumberRequest.getPath();                    DataNode n = zks.getZKDatabase().getNode(path);                    if (n == null) {                        throw new KeeperException.NoNodeException();                    }                    zks.checkACL(request.cnxn, zks.getZKDatabase().aclForNode(n), ZooDefs.Perms.READ, request.authInfo, path, null);                    int number = zks.getZKDatabase().getAllChildrenNumber(path);                    rsp = new GetAllChildrenNumberResponse(number);                    break;                }            case OpCode.getChildren2:                {                    lastOp = "GETC";                    GetChildren2Request getChildren2Request = new GetChildren2Request();                    ByteBufferInputStream.byteBuffer2Record(request.request, getChildren2Request);                    Stat stat = new Stat();                    path = getChildren2Request.getPath();                    DataNode n = zks.getZKDatabase().getNode(path);                    if (n == null) {                        throw new KeeperException.NoNodeException();                    }                    zks.checkACL(request.cnxn, zks.getZKDatabase().aclForNode(n), ZooDefs.Perms.READ, request.authInfo, path, null);                    List<String> children = zks.getZKDatabase().getChildren(path, stat, getChildren2Request.getWatch() ? cnxn : null);                    rsp = new GetChildren2Response(children, stat);                    requestPathMetricsCollector.registerRequest(request.type, path);                    break;                }            case OpCode.checkWatches:                {                    lastOp = "CHKW";                    CheckWatchesRequest checkWatches = new CheckWatchesRequest();                    ByteBufferInputStream.byteBuffer2Record(request.request, checkWatches);                    WatcherType type = WatcherType.fromInt(checkWatches.getType());                    path = checkWatches.getPath();                    boolean containsWatcher = zks.getZKDatabase().containsWatcher(path, type, cnxn);                    if (!containsWatcher) {                        String msg = String.format(Locale.ENGLISH, "%s (type: %s)", path, type);                        throw new KeeperException.NoWatcherException(msg);                    }                    requestPathMetricsCollector.registerRequest(request.type, checkWatches.getPath());                    break;                }            case OpCode.removeWatches:                {                    lastOp = "REMW";                    RemoveWatchesRequest removeWatches = new RemoveWatchesRequest();                    ByteBufferInputStream.byteBuffer2Record(request.request, removeWatches);                    WatcherType type = WatcherType.fromInt(removeWatches.getType());                    path = removeWatches.getPath();                    boolean removed = zks.getZKDatabase().removeWatch(path, type, cnxn);                    if (!removed) {                        String msg = String.format(Locale.ENGLISH, "%s (type: %s)", path, type);                        throw new KeeperException.NoWatcherException(msg);                    }                    requestPathMetricsCollector.registerRequest(request.type, removeWatches.getPath());                    break;                }            case OpCode.getEphemerals:                {                    lastOp = "GETE";                    GetEphemeralsRequest getEphemerals = new GetEphemeralsRequest();                    ByteBufferInputStream.byteBuffer2Record(request.request, getEphemerals);                    String prefixPath = getEphemerals.getPrefixPath();                    Set<String> allEphems = zks.getZKDatabase().getDataTree().getEphemerals(request.sessionId);                    List<String> ephemerals = new ArrayList<>();                    if (StringUtils.isBlank(prefixPath) || "/".equals(prefixPath.trim())) {                        ephemerals.addAll(allEphems);                    } else {                        for (String p : allEphems) {                            if (p.startsWith(prefixPath)) {                                ephemerals.add(p);                            }                        }                    }                    rsp = new GetEphemeralsResponse(ephemerals);                    break;                }        }    } catch (SessionMovedException e) {                                                                        cnxn.sendCloseSession();        return;    } catch (KeeperException e) {        err = e.code();    } catch (Exception e) {                                StringBuilder sb = new StringBuilder();        ByteBuffer bb = request.request;        bb.rewind();        while (bb.hasRemaining()) {            sb.append(Integer.toHexString(bb.get() & 0xff));        }                err = Code.MARSHALLINGERROR;    }    ReplyHeader hdr = new ReplyHeader(request.cxid, lastZxid, err.intValue());    updateStats(request, lastOp, lastZxid);    try {        if (request.type == OpCode.getData && path != null && rsp != null) {                                                GetDataResponse getDataResponse = (GetDataResponse) rsp;            Stat stat = null;            if (getDataResponse.getStat() != null) {                stat = getDataResponse.getStat();            }            cnxn.sendResponse(hdr, rsp, "response", path, stat);        } else {            cnxn.sendResponse(hdr, rsp, "response");        }        if (request.type == OpCode.closeSession) {            cnxn.sendCloseSession();        }    } catch (IOException e) {            }}
handleGetChildrenRequest
private Record zookeeper_f1914_0(Record request, ServerCnxn cnxn, List<Id> authInfo) throws KeeperException, IOException
{    GetChildrenRequest getChildrenRequest = (GetChildrenRequest) request;    String path = getChildrenRequest.getPath();    DataNode n = zks.getZKDatabase().getNode(path);    if (n == null) {        throw new KeeperException.NoNodeException();    }    zks.checkACL(cnxn, zks.getZKDatabase().aclForNode(n), ZooDefs.Perms.READ, authInfo, path, null);    List<String> children = zks.getZKDatabase().getChildren(path, null, getChildrenRequest.getWatch() ? cnxn : null);    return new GetChildrenResponse(children);}
handleGetDataRequest
private Record zookeeper_f1915_0(Record request, ServerCnxn cnxn, List<Id> authInfo) throws KeeperException, IOException
{    GetDataRequest getDataRequest = (GetDataRequest) request;    String path = getDataRequest.getPath();    DataNode n = zks.getZKDatabase().getNode(path);    if (n == null) {        throw new KeeperException.NoNodeException();    }    zks.checkACL(cnxn, zks.getZKDatabase().aclForNode(n), ZooDefs.Perms.READ, authInfo, path, null);    Stat stat = new Stat();    byte[] b = zks.getZKDatabase().getData(path, stat, getDataRequest.getWatch() ? cnxn : null);    return new GetDataResponse(b, stat);}
closeSession
private boolean zookeeper_f1916_0(ServerCnxnFactory serverCnxnFactory, long sessionId)
{    if (serverCnxnFactory == null) {        return false;    }    return serverCnxnFactory.closeSession(sessionId, ServerCnxn.DisconnectReason.CLIENT_CLOSED_SESSION);}
connClosedByClient
private boolean zookeeper_f1917_0(Request request)
{    return request.cnxn == null;}
shutdown
public voidf1918_1)
{        }
updateStats
private void zookeeper_f1919_0(Request request, String lastOp, long lastZxid)
{    if (request.cnxn == null) {        return;    }    long currentTime = Time.currentElapsedTime();    zks.serverStats().updateLatency(request, currentTime);    request.cnxn.updateStatsForResponse(request.cxid, lastZxid, lastOp, request.createTime, currentTime);}
main
public static voidf1920_1String[] args) throws Exception
{    if (args.length != 1) {        System.err.println("USAGE: LogFormatter log_file");        System.exit(ExitCode.INVALID_INVOCATION.getValue());    }    String error = ZKUtil.validateFileInput(args[0]);    if (null != error) {        System.err.println(error);        System.exit(ExitCode.INVALID_INVOCATION.getValue());    }    FileInputStream fis = new FileInputStream(args[0]);    BinaryInputArchive logStream = BinaryInputArchive.getArchive(fis);    FileHeader fhdr = new FileHeader();    fhdr.deserialize(logStream, "fileheader");    if (fhdr.getMagic() != FileTxnLog.TXNLOG_MAGIC) {        System.err.println("Invalid magic number for " + args[0]);        System.exit(ExitCode.INVALID_INVOCATION.getValue());    }    System.out.println("ZooKeeper Transactional Log File with dbid " + fhdr.getDbid() + " txnlog format version " + fhdr.getVersion());    int count = 0;    while (true) {        long crcValue;        byte[] bytes;        try {            crcValue = logStream.readLong("crcvalue");            bytes = logStream.readBuffer("txnEntry");        } catch (EOFException e) {            System.out.println("EOF reached after " + count + " txns.");            return;        }        if (bytes.length == 0) {                                    System.out.println("EOF reached after " + count + " txns.");            return;        }        Checksum crc = new Adler32();        crc.update(bytes, 0, bytes.length);        if (crcValue != crc.getValue()) {            throw new IOException("CRC doesn't match " + crcValue + " vs " + crc.getValue());        }        TxnHeader hdr = new TxnHeader();        Record txn = SerializeUtils.deserializeTxn(bytes, hdr);        System.out.println(DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.LONG).format(new Date(hdr.getTime())) + " session 0x" + Long.toHexString(hdr.getClientId()) + " cxid 0x" + Long.toHexString(hdr.getCxid()) + " zxid 0x" + Long.toHexString(hdr.getZxid()) + " " + Request.op2String(hdr.getType()) + " " + txn);        if (logStream.readByte("EOR") != 'B') {                        throw new EOFException("Last transaction was partial.");        }        count++;    }}
addDataPoint
public void zookeeper_f1921_0(long value)
{    total.addAndGet(value);    count.incrementAndGet();    setMin(value);    setMax(value);}
setMax
private void zookeeper_f1922_0(long value)
{    long current;    while (value > (current = max.get()) && !max.compareAndSet(current, value)) {        }}
setMin
private void zookeeper_f1923_0(long value)
{    long current;    while (value < (current = min.get()) && !min.compareAndSet(current, value)) {        }}
getAvg
public double zookeeper_f1924_0()
{            long currentCount = count.get();    long currentTotal = total.get();    if (currentCount > 0) {        double avgLatency = currentTotal / (double) currentCount;        BigDecimal bg = new BigDecimal(avgLatency);        return bg.setScale(4, RoundingMode.HALF_UP).doubleValue();    }    return 0;}
getCount
public long zookeeper_f1925_0()
{    return count.get();}
getMax
public long zookeeper_f1926_0()
{    long current = max.get();    return (current == Long.MIN_VALUE) ? 0 : current;}
getMin
public long zookeeper_f1927_0()
{    long current = min.get();    return (current == Long.MAX_VALUE) ? 0 : current;}
getTotal
public long zookeeper_f1928_0()
{    return total.get();}
resetMax
public void zookeeper_f1929_0()
{    max.set(getMin());}
reset
public void zookeeper_f1930_0()
{    count.set(0);    total.set(0);    min.set(Long.MAX_VALUE);    max.set(Long.MIN_VALUE);}
add
public void zookeeper_f1931_0(long value)
{    addDataPoint(value);}
values
public Map<String, Object> zookeeper_f1932_0()
{    Map<String, Object> m = new LinkedHashMap<String, Object>();    m.put("avg_" + name, this.getAvg());    m.put("min_" + name, this.getMin());    m.put("max_" + name, this.getMax());    m.put("cnt_" + name, this.getCount());    m.put("sum_" + name, this.getTotal());    return m;}
getCounterForKey
private AvgMinMaxCounter zookeeper_f1933_0(String key)
{    AvgMinMaxCounter counter = counters.get(key);    if (counter == null) {        counters.putIfAbsent(key, new AvgMinMaxCounter(key + "_" + name));        counter = counters.get(key);    }    return counter;}
addDataPoint
public void zookeeper_f1934_0(String key, long value)
{    getCounterForKey(key).addDataPoint(value);}
resetMax
public void zookeeper_f1935_0()
{    for (Map.Entry<String, AvgMinMaxCounter> entry : counters.entrySet()) {        entry.getValue().resetMax();    }}
reset
public void zookeeper_f1936_0()
{    for (Map.Entry<String, AvgMinMaxCounter> entry : counters.entrySet()) {        entry.getValue().reset();    }}
add
public void zookeeper_f1937_0(String key, long value)
{    addDataPoint(key, value);}
values
public Map<String, Object> zookeeper_f1938_0()
{    Map<String, Object> m = new LinkedHashMap<>();    for (Map.Entry<String, AvgMinMaxCounter> entry : counters.entrySet()) {        m.putAll(entry.getValue().values());    }    return m;}
size
public int zookeeper_f1939_0()
{    final long c = count.get();    if (c > values.length()) {        return values.length();    }    return (int) c;}
update
public void zookeeper_f1940_0(long value)
{    final long c = count.incrementAndGet();    if (c <= values.length()) {        values.set((int) c - 1, value);    } else {        final long r = nextLong(c);        if (r < values.length()) {            values.set((int) r, value);        }    }}
nextLong
private static long zookeeper_f1941_0(long n)
{    long bits, val;    do {        bits = ThreadLocalRandom.current().nextLong() & (~(1L << BITS_PER_LONG));        val = bits % n;    } while (bits - val + (n - 1) < 0L);    return val;}
getSnapshot
public Snapshot zookeeper_f1942_0()
{    final int s = size();    final List<Long> copy = new ArrayList<Long>(s);    for (int i = 0; i < s; i++) {        copy.add(values.get(i));    }    return new UniformSnapshot(copy);}
reset
public void zookeeper_f1943_0()
{    count.set(0);    values = new AtomicLongArray(DEFAULT_SIZE);}
addDataPoint
public void zookeeper_f1944_0(long value)
{    counter.add(value);    histogram.update(value);}
resetMax
public void zookeeper_f1945_0()
{        counter.resetMax();}
reset
public void zookeeper_f1946_0()
{    counter.reset();    reservoir.reset();}
add
public void zookeeper_f1947_0(long value)
{    addDataPoint(value);}
values
public Map<String, Object> zookeeper_f1948_0()
{    Map<String, Object> m = new LinkedHashMap<>();    m.putAll(counter.values());    m.put("p50_" + name, Math.round(this.histogram.getSnapshot().getMedian()));    m.put("p95_" + name, Math.round(this.histogram.getSnapshot().get95thPercentile()));    m.put("p99_" + name, Math.round(this.histogram.getSnapshot().get99thPercentile()));    m.put("p999_" + name, Math.round(this.histogram.getSnapshot().get999thPercentile()));    return m;}
getCounterForKey
private AvgMinMaxPercentileCounter zookeeper_f1949_0(String key)
{    AvgMinMaxPercentileCounter counter = counters.get(key);    if (counter == null) {        counters.putIfAbsent(key, new AvgMinMaxPercentileCounter(key + "_" + name));        counter = counters.get(key);    }    return counter;}
addDataPoint
public void zookeeper_f1950_0(String key, long value)
{    getCounterForKey(key).addDataPoint(value);}
resetMax
public void zookeeper_f1951_0()
{    for (Map.Entry<String, AvgMinMaxPercentileCounter> entry : counters.entrySet()) {        entry.getValue().resetMax();    }}
reset
public void zookeeper_f1952_0()
{    for (Map.Entry<String, AvgMinMaxPercentileCounter> entry : counters.entrySet()) {        entry.getValue().reset();    }}
add
public void zookeeper_f1953_0(String key, long value)
{    addDataPoint(key, value);}
values
public Map<String, Object> zookeeper_f1954_0()
{    Map<String, Object> m = new LinkedHashMap<>();    for (Map.Entry<String, AvgMinMaxPercentileCounter> entry : counters.entrySet()) {        m.putAll(entry.getValue().values());    }    return m;}
add
public void zookeeper_f1955_0(long value)
{}
add
public void zookeeper_f1956_0(int key, long value)
{}
add
public void zookeeper_f1957_0(String key, long value)
{}
reset
public void zookeeper_f1958_0()
{}
add
public void zookeeper_f1959_0(long value)
{    counter.addAndGet(value);}
reset
public void zookeeper_f1960_0()
{    counter.set(0);}
get
public long zookeeper_f1961_0()
{    return counter.get();}
values
public Map<String, Object> zookeeper_f1962_0()
{    Map<String, Object> m = new LinkedHashMap<String, Object>();    m.put(name, this.get());    return m;}
close
public void zookeeper_f1963_0(DisconnectReason reason)
{    disconnectReason = reason;    close();}
close
public voidf1964_1)
{    closingChannel = true;    if (LOG.isDebugEnabled()) {            }    setStale();                factory.unregisterConnection(this);        if (!factory.cnxns.remove(this)) {        if (LOG.isDebugEnabled()) {                    }        return;    }    if (LOG.isDebugEnabled()) {            }    factory.removeCnxnFromSessionMap(this);    factory.removeCnxnFromIpMap(this, ((InetSocketAddress) channel.remoteAddress()).getAddress());    if (zkServer != null) {        zkServer.removeCnxn(this);    }    if (channel.isOpen()) {                                channel.writeAndFlush(Unpooled.EMPTY_BUFFER).addListener(new ChannelFutureListener() {            @Override            public void operationComplete(ChannelFuture future) {                future.channel().close().addListener(f -> releaseQueuedBuffer());            }        });    } else {        ServerMetrics.getMetrics().CONNECTION_DROP_COUNT.add(1);        channel.eventLoop().execute(this::releaseQueuedBuffer);    }}
operationComplete
public void zookeeper_f1965_0(ChannelFuture future)
{    future.channel().close().addListener(f -> releaseQueuedBuffer());}
getSessionId
public long zookeeper_f1966_0()
{    return sessionId;}
getSessionTimeout
public int zookeeper_f1967_0()
{    return sessionTimeout;}
process
public voidf1968_1WatchedEvent event)
{    ReplyHeader h = new ReplyHeader(-1, -1L, 0);    if (LOG.isTraceEnabled()) {        ZooTrace.logTraceMessage(LOG, ZooTrace.EVENT_DELIVERY_TRACE_MASK, "Deliver event " + event + " to 0x" + Long.toHexString(this.sessionId) + " through " + this);    }        WatcherEvent e = event.getWrapper();    try {        sendResponse(h, e, "notification");    } catch (IOException e1) {        if (LOG.isDebugEnabled()) {                    }        close();    }}
sendResponse
public void zookeeper_f1969_0(ReplyHeader h, Record r, String tag, String cacheKey, Stat stat) throws IOException
{        if (closingChannel || !channel.isOpen()) {        return;    }    sendBuffer(serialize(h, r, tag, cacheKey, stat));    decrOutstandingAndCheckThrottle(h);}
setSessionId
public void zookeeper_f1970_0(long sessionId)
{    this.sessionId = sessionId;    factory.addSession(sessionId, this);}
sendBuffer
public void zookeeper_f1971_0(ByteBuffer... buffers)
{    if (buffers.length == 1 && buffers[0] == ServerCnxnFactory.closeConn) {        close(DisconnectReason.CLIENT_CLOSED_CONNECTION);        return;    }    channel.writeAndFlush(Unpooled.wrappedBuffer(buffers)).addListener(onSendBufferDoneListener);}
checkFlush
private void zookeeper_f1972_0(boolean force)
{    if ((force && sb.length() > 0) || sb.length() > 2048) {        sendBuffer(ByteBuffer.wrap(sb.toString().getBytes()));                sb.setLength(0);    }}
close
public void zookeeper_f1973_0() throws IOException
{    if (sb == null) {        return;    }    checkFlush(true);        sb = null;}
flush
public void zookeeper_f1974_0() throws IOException
{    checkFlush(true);}
write
public void zookeeper_f1975_0(char[] cbuf, int off, int len) throws IOException
{    sb.append(cbuf, off, len);    checkFlush(false);}
checkFourLetterWord
private booleanf1976_1final Channel channel, ByteBuf message, final int len)
{        if (!FourLetterCommands.isKnown(len)) {        return false;    }    String cmd = FourLetterCommands.getCommandString(len);                channel.config().setAutoRead(false);    packetReceived(4);    final PrintWriter pwriter = new PrintWriter(new BufferedWriter(new SendBufferWriter()));        if (!FourLetterCommands.isEnabled(cmd)) {                NopCommand nopCmd = new NopCommand(pwriter, this, cmd + " is not executed because it is not in the whitelist.");        nopCmd.start();        return true;    }        if (len == FourLetterCommands.setTraceMaskCmd) {        ByteBuffer mask = ByteBuffer.allocate(8);        message.readBytes(mask);        mask.flip();        long traceMask = mask.getLong();        ZooTrace.setTextTraceLevel(traceMask);        SetTraceMaskCommand setMask = new SetTraceMaskCommand(pwriter, this, traceMask);        setMask.start();        return true;    } else {        CommandExecutor commandExecutor = new CommandExecutor();        return commandExecutor.execute(this, pwriter, len, zkServer, factory);    }}
checkIsInEventLoop
private void zookeeper_f1977_0(String callerMethodName)
{    if (!channel.eventLoop().inEventLoop()) {        throw new IllegalStateException(callerMethodName + "() called from non-EventLoop thread");    }}
appendToQueuedBuffer
private void zookeeper_f1978_0(ByteBuf buf)
{    checkIsInEventLoop("appendToQueuedBuffer");    if (queuedBuffer.numComponents() == queuedBuffer.maxNumComponents()) {                queuedBuffer.consolidate();    }    queuedBuffer.addComponent(true, buf);    ServerMetrics.getMetrics().NETTY_QUEUED_BUFFER.add(queuedBuffer.capacity());}
processMessage
 voidf1979_1ByteBuf buf)
{    checkIsInEventLoop("processMessage");    if (LOG.isDebugEnabled()) {            }    if (LOG.isTraceEnabled()) {        LOG.trace("0x{} buf {}", Long.toHexString(sessionId), ByteBufUtil.hexDump(buf));    }    if (throttled.get()) {                        if (queuedBuffer == null) {                        queuedBuffer = channel.alloc().compositeBuffer();        }        appendToQueuedBuffer(buf.retainedDuplicate());        if (LOG.isTraceEnabled()) {            LOG.trace("0x{} queuedBuffer {}", Long.toHexString(sessionId), ByteBufUtil.hexDump(queuedBuffer));        }    } else {                if (queuedBuffer != null) {            appendToQueuedBuffer(buf.retainedDuplicate());            processQueuedBuffer();        } else {            receiveMessage(buf);                        if (!closingChannel && buf.isReadable()) {                LOG.trace("Before copy {}", buf);                if (queuedBuffer == null) {                    queuedBuffer = channel.alloc().compositeBuffer();                }                appendToQueuedBuffer(buf.retainedSlice(buf.readerIndex(), buf.readableBytes()));                if (LOG.isTraceEnabled()) {                    LOG.trace("Copy is {}", queuedBuffer);                    LOG.trace("0x{} queuedBuffer {}", Long.toHexString(sessionId), ByteBufUtil.hexDump(queuedBuffer));                }            }        }    }}
processQueuedBuffer
 voidf1980_1)
{    checkIsInEventLoop("processQueuedBuffer");    if (queuedBuffer != null) {        if (LOG.isTraceEnabled()) {            LOG.trace("processing queue 0x{} queuedBuffer {}", Long.toHexString(sessionId), ByteBufUtil.hexDump(queuedBuffer));        }        receiveMessage(queuedBuffer);        if (closingChannel) {                                } else if (!queuedBuffer.isReadable()) {                        releaseQueuedBuffer();        } else {                                                queuedBuffer.discardReadComponents();        }    } else {            }}
releaseQueuedBuffer
private void zookeeper_f1981_0()
{    checkIsInEventLoop("releaseQueuedBuffer");    if (queuedBuffer != null) {        queuedBuffer.release();        queuedBuffer = null;    }}
receiveMessage
private voidf1982_1ByteBuf message)
{    checkIsInEventLoop("receiveMessage");    try {        while (message.isReadable() && !throttled.get()) {            if (bb != null) {                if (LOG.isTraceEnabled()) {                    LOG.trace("message readable {} bb len {} {}", message.readableBytes(), bb.remaining(), bb);                    ByteBuffer dat = bb.duplicate();                    dat.flip();                    LOG.trace("0x{} bb {}", Long.toHexString(sessionId), ByteBufUtil.hexDump(Unpooled.wrappedBuffer(dat)));                }                if (bb.remaining() > message.readableBytes()) {                    int newLimit = bb.position() + message.readableBytes();                    bb.limit(newLimit);                }                message.readBytes(bb);                bb.limit(bb.capacity());                if (LOG.isTraceEnabled()) {                    LOG.trace("after readBytes message readable {} bb len {} {}", message.readableBytes(), bb.remaining(), bb);                    ByteBuffer dat = bb.duplicate();                    dat.flip();                    LOG.trace("after readbytes 0x{} bb {}", Long.toHexString(sessionId), ByteBufUtil.hexDump(Unpooled.wrappedBuffer(dat)));                }                if (bb.remaining() == 0) {                    bb.flip();                    packetReceived(4 + bb.remaining());                    ZooKeeperServer zks = this.zkServer;                    if (zks == null || !zks.isRunning()) {                        throw new IOException("ZK down");                    }                    if (initialized) {                                                                        zks.processPacket(this, bb);                    } else {                                                zks.processConnectRequest(this, bb);                        initialized = true;                    }                    bb = null;                }            } else {                if (LOG.isTraceEnabled()) {                    LOG.trace("message readable {} bblenrem {}", message.readableBytes(), bbLen.remaining());                    ByteBuffer dat = bbLen.duplicate();                    dat.flip();                    LOG.trace("0x{} bbLen {}", Long.toHexString(sessionId), ByteBufUtil.hexDump(Unpooled.wrappedBuffer(dat)));                }                if (message.readableBytes() < bbLen.remaining()) {                    bbLen.limit(bbLen.position() + message.readableBytes());                }                message.readBytes(bbLen);                bbLen.limit(bbLen.capacity());                if (bbLen.remaining() == 0) {                    bbLen.flip();                    if (LOG.isTraceEnabled()) {                        LOG.trace("0x{} bbLen {}", Long.toHexString(sessionId), ByteBufUtil.hexDump(Unpooled.wrappedBuffer(bbLen)));                    }                    int len = bbLen.getInt();                    if (LOG.isTraceEnabled()) {                        LOG.trace("0x{} bbLen len is {}", Long.toHexString(sessionId), len);                    }                    bbLen.clear();                    if (!initialized) {                        if (checkFourLetterWord(channel, message, len)) {                            return;                        }                    }                    if (len < 0 || len > BinaryInputArchive.maxBuffer) {                        throw new IOException("Len error " + len);                    }                                        zkServer.checkRequestSizeWhenReceivingMessage(len);                    bb = ByteBuffer.allocate(len);                }            }        }    } catch (IOException e) {                close(DisconnectReason.IO_EXCEPTION);    } catch (ClientCnxnLimitException e) {                ServerMetrics.getMetrics().CONNECTION_REJECTED.add(1);                close(DisconnectReason.CLIENT_RATE_LIMIT);    }}
disableRecv
public voidf1983_1boolean waitDisableRecv)
{    if (throttled.compareAndSet(false, true)) {                channel.pipeline().fireUserEventTriggered(ReadEvent.DISABLE);    }}
enableRecv
public voidf1984_1)
{    if (throttled.compareAndSet(true, false)) {                channel.pipeline().fireUserEventTriggered(ReadEvent.ENABLE);    }}
setSessionTimeout
public void zookeeper_f1985_0(int sessionTimeout)
{    this.sessionTimeout = sessionTimeout;}
getInterestOps
public int zookeeper_f1986_0()
{        if (channel == null || !channel.isOpen()) {        return 0;    }    int interestOps = 0;    if (!throttled.get()) {        interestOps |= SelectionKey.OP_READ;    }    if (!channel.isWritable()) {                        interestOps |= SelectionKey.OP_WRITE;    }    return interestOps;}
getRemoteSocketAddress
public InetSocketAddress zookeeper_f1987_0()
{    return (InetSocketAddress) channel.remoteAddress();}
sendCloseSession
public void zookeeper_f1988_0()
{    sendBuffer(ServerCnxnFactory.closeConn);}
serverStats
protected ServerStats zookeeper_f1989_0()
{    if (zkServer == null) {        return null;    }    return zkServer.serverStats();}
isSecure
public boolean zookeeper_f1990_0()
{    return factory.secure;}
getClientCertificateChain
public Certificate[] zookeeper_f1991_0()
{    if (clientChain == null) {        return null;    }    return Arrays.copyOf(clientChain, clientChain.length);}
setClientCertificateChain
public void zookeeper_f1992_0(Certificate[] chain)
{    if (chain == null) {        clientChain = null;    } else {        clientChain = Arrays.copyOf(chain, chain.length);    }}
getChannel
 Channel zookeeper_f1993_0()
{    return channel;}
getQueuedReadableBytes
public int zookeeper_f1994_0()
{    checkIsInEventLoop("getQueuedReadableBytes");    if (queuedBuffer != null) {        return queuedBuffer.readableBytes();    }    return 0;}
decode
protected voidf1995_1ChannelHandlerContext context, ByteBuf in, List<Object> out) throws Exception
{    if (in.readableBytes() >= 5) {        super.decode(context, in, out);    } else if (in.readableBytes() > 0) {                if (TLS_HANDSHAKE_RECORD_TYPE != in.getByte(0)) {                        handleNonSsl(context);        }    }}
handleNonSsl
private void zookeeper_f1996_0(ChannelHandlerContext context)
{    ChannelHandler handler = this.newNonSslHandler(context);    if (handler != null) {        context.pipeline().replace(this, this.newNonSslHandlerName(), handler);    } else {        context.pipeline().remove(this);    }}
newSslHandler
protected SslHandlerf1997_1ChannelHandlerContext context, SslContext sslContext)
{    NettyServerCnxn cnxn = Objects.requireNonNull(context.channel().attr(CONNECTION_ATTRIBUTE).get());        SslHandler handler = super.newSslHandler(context, sslContext);    Future<Channel> handshakeFuture = handler.handshakeFuture();    handshakeFuture.addListener(new CertificateVerifier(handler, cnxn));    return handler;}
newNonSslHandler
protected ChannelHandlerf1998_1ChannelHandlerContext context)
{    NettyServerCnxn cnxn = Objects.requireNonNull(context.channel().attr(CONNECTION_ATTRIBUTE).get());        allChannels.add(context.channel());    addCnxn(cnxn);    return super.newNonSslHandler(context);}
channelActive
public voidf1999_1ChannelHandlerContext ctx) throws Exception
{    if (LOG.isTraceEnabled()) {        LOG.trace("Channel active {}", ctx.channel());    }    final Channel channel = ctx.channel();    InetAddress addr = ((InetSocketAddress) channel.remoteAddress()).getAddress();    if (maxClientCnxns > 0 && getClientCnxnCount(addr) >= maxClientCnxns) {        ServerMetrics.getMetrics().CONNECTION_REJECTED.add(1);                channel.close();        return;    }    NettyServerCnxn cnxn = new NettyServerCnxn(channel, zkServer, NettyServerCnxnFactory.this);    ctx.channel().attr(CONNECTION_ATTRIBUTE).set(cnxn);    if (secure) {        SslHandler sslHandler = ctx.pipeline().get(SslHandler.class);        Future<Channel> handshakeFuture = sslHandler.handshakeFuture();        handshakeFuture.addListener(new CertificateVerifier(sslHandler, cnxn));    } else if (!shouldUsePortUnification) {        allChannels.add(ctx.channel());        addCnxn(cnxn);    }}
channelInactive
public void zookeeper_f2000_0(ChannelHandlerContext ctx) throws Exception
{    if (LOG.isTraceEnabled()) {        LOG.trace("Channel inactive {}", ctx.channel());    }    allChannels.remove(ctx.channel());    NettyServerCnxn cnxn = ctx.channel().attr(CONNECTION_ATTRIBUTE).getAndSet(null);    if (cnxn != null) {        if (LOG.isTraceEnabled()) {            LOG.trace("Channel inactive caused close {}", cnxn);        }        cnxn.close(ServerCnxn.DisconnectReason.CHANNEL_DISCONNECTED);    }}
exceptionCaught
public voidf2001_1ChannelHandlerContext ctx, Throwable cause) throws Exception
{        NettyServerCnxn cnxn = ctx.channel().attr(CONNECTION_ATTRIBUTE).getAndSet(null);    if (cnxn != null) {                cnxn.close(ServerCnxn.DisconnectReason.CHANNEL_CLOSED_EXCEPTION);    }}
userEventTriggered
public voidf2002_1ChannelHandlerContext ctx, Object evt) throws Exception
{    try {        if (evt == NettyServerCnxn.ReadEvent.ENABLE) {                        NettyServerCnxn cnxn = ctx.channel().attr(CONNECTION_ATTRIBUTE).get();                        if (cnxn != null) {                if (cnxn.getQueuedReadableBytes() > 0) {                    cnxn.processQueuedBuffer();                    if (advancedFlowControlEnabled && cnxn.getQueuedReadableBytes() == 0) {                                                                        ctx.read();                                            }                }            }            if (!advancedFlowControlEnabled) {                ctx.channel().config().setAutoRead(true);            }        } else if (evt == NettyServerCnxn.ReadEvent.DISABLE) {                        ctx.channel().config().setAutoRead(false);        }    } finally {        ReferenceCountUtil.release(evt);    }}
channelRead
public voidf2003_1ChannelHandlerContext ctx, Object msg) throws Exception
{    try {        LOG.trace("message received called {}", msg);        try {                        NettyServerCnxn cnxn = ctx.channel().attr(CONNECTION_ATTRIBUTE).get();            if (cnxn == null) {                            } else {                cnxn.processMessage((ByteBuf) msg);            }        } catch (Exception ex) {                        throw ex;        }    } finally {        ReferenceCountUtil.release(msg);    }}
channelReadComplete
public voidf2004_1ChannelHandlerContext ctx) throws Exception
{    if (advancedFlowControlEnabled) {        NettyServerCnxn cnxn = ctx.channel().attr(CONNECTION_ATTRIBUTE).get();        if (cnxn != null && cnxn.getQueuedReadableBytes() == 0 && cnxn.readIssuedAfterReadComplete == 0) {            ctx.read();                    }    }    ctx.fireChannelReadComplete();}
write
public void zookeeper_f2005_0(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception
{    if (LOG.isTraceEnabled()) {        promise.addListener(onWriteCompletedTracer);    }    super.write(ctx, msg, promise);}
operationComplete
public voidf2006_1Future<Channel> future)
{    if (future.isSuccess()) {        if (LOG.isDebugEnabled()) {                    }        SSLEngine eng = sslHandler.engine();                if (eng.getNeedClientAuth() || eng.getWantClientAuth()) {            SSLSession session = eng.getSession();            try {                cnxn.setClientCertificateChain(session.getPeerCertificates());            } catch (SSLPeerUnverifiedException e) {                if (eng.getNeedClientAuth()) {                                                            cnxn.close();                    return;                } else {                                                            final Channel futureChannel = future.getNow();                    allChannels.add(Objects.requireNonNull(futureChannel));                    addCnxn(cnxn);                    return;                }            } catch (Exception e) {                                cnxn.close();                return;            }            String authProviderProp = System.getProperty(x509Util.getSslAuthProviderProperty(), "x509");            X509AuthenticationProvider authProvider = (X509AuthenticationProvider) ProviderRegistry.getProvider(authProviderProp);            if (authProvider == null) {                                cnxn.close(ServerCnxn.DisconnectReason.AUTH_PROVIDER_NOT_FOUND);                return;            }            if (KeeperException.Code.OK != authProvider.handleAuthentication(cnxn, null)) {                                cnxn.close(ServerCnxn.DisconnectReason.SASL_AUTH_FAILURE);                return;            }        }        final Channel futureChannel = future.getNow();        allChannels.add(Objects.requireNonNull(futureChannel));        addCnxn(cnxn);    } else {                cnxn.close(ServerCnxn.DisconnectReason.FAILED_HANDSHAKE);    }}
read
public void zookeeper_f2007_0(ChannelHandlerContext ctx) throws Exception
{    NettyServerCnxn cnxn = ctx.channel().attr(CONNECTION_ATTRIBUTE).get();    if (cnxn != null) {        cnxn.readIssuedAfterReadComplete++;    }    ctx.read();}
channelReadComplete
public void zookeeper_f2008_0(ChannelHandlerContext ctx) throws Exception
{    NettyServerCnxn cnxn = ctx.channel().attr(CONNECTION_ATTRIBUTE).get();    if (cnxn != null) {        cnxn.readIssuedAfterReadComplete = 0;    }    ctx.fireChannelReadComplete();}
configureBootstrapAllocator
private ServerBootstrap zookeeper_f2009_0(ServerBootstrap bootstrap)
{    ByteBufAllocator testAllocator = TEST_ALLOCATOR.get();    if (testAllocator != null) {        return bootstrap.option(ChannelOption.ALLOCATOR, testAllocator).childOption(ChannelOption.ALLOCATOR, testAllocator);    } else {        return bootstrap;    }}
initChannel
protected void zookeeper_f2010_0(SocketChannel ch) throws Exception
{    ChannelPipeline pipeline = ch.pipeline();    if (advancedFlowControlEnabled) {        pipeline.addLast(readIssuedTrackingHandler);    }    if (secure) {        initSSL(pipeline, false);    } else if (shouldUsePortUnification) {        initSSL(pipeline, true);    }    pipeline.addLast("servercnxnfactory", channelHandler);}
initSSL
private synchronized voidf2011_1ChannelPipeline p, boolean supportPlaintext) throws X509Exception, KeyManagementException, NoSuchAlgorithmException
{    String authProviderProp = System.getProperty(x509Util.getSslAuthProviderProperty());    SslContext nettySslContext;    if (authProviderProp == null) {        SSLContextAndOptions sslContextAndOptions = x509Util.getDefaultSSLContextAndOptions();        nettySslContext = sslContextAndOptions.createNettyJdkSslContext(sslContextAndOptions.getSSLContext(), false);    } else {        SSLContext sslContext = SSLContext.getInstance(ClientX509Util.DEFAULT_PROTOCOL);        X509AuthenticationProvider authProvider = (X509AuthenticationProvider) ProviderRegistry.getProvider(System.getProperty(x509Util.getSslAuthProviderProperty(), "x509"));        if (authProvider == null) {                        throw new SSLContextException("Could not create SSLContext with specified auth provider: " + authProviderProp);        }        sslContext.init(new X509KeyManager[] { authProvider.getKeyManager() }, new X509TrustManager[] { authProvider.getTrustManager() }, null);        nettySslContext = x509Util.getDefaultSSLContextAndOptions().createNettyJdkSslContext(sslContext, false);    }    if (supportPlaintext) {        p.addLast("ssl", new DualModeSslHandler(nettySslContext));            } else {        p.addLast("ssl", nettySslContext.newHandler(p.channel().alloc()));            }}
closeAll
public voidf2012_1ServerCnxn.DisconnectReason reason)
{            int length = cnxns.size();    for (ServerCnxn cnxn : cnxns) {        try {                        cnxn.close(reason);        } catch (Exception e) {                    }    }    }
configure
public void zookeeper_f2013_0(InetSocketAddress addr, int maxClientCnxns, int backlog, boolean secure) throws IOException
{    configureSaslLogin();    localAddress = addr;    this.maxClientCnxns = maxClientCnxns;    this.secure = secure;    this.listenBacklog = backlog;}
getMaxClientCnxnsPerHost
public int zookeeper_f2014_0()
{    return maxClientCnxns;}
setMaxClientCnxnsPerHost
public void zookeeper_f2015_0(int max)
{    maxClientCnxns = max;}
getSocketListenBacklog
public int zookeeper_f2016_0()
{    return listenBacklog;}
getLocalPort
public int zookeeper_f2017_0()
{    return localAddress.getPort();}
join
public void zookeeper_f2018_0() throws InterruptedException
{    synchronized (this) {        while (!killed) {            wait();        }    }}
shutdown
public voidf2019_1)
{    synchronized (this) {        if (killed) {                        return;        }    }        x509Util.close();    if (login != null) {        login.shutdown();    }    final EventLoopGroup bossGroup = bootstrap.config().group();    final EventLoopGroup workerGroup = bootstrap.config().childGroup();        if (parentChannel != null) {        ChannelFuture parentCloseFuture = parentChannel.close();        if (bossGroup != null) {            parentCloseFuture.addListener(future -> {                bossGroup.shutdownGracefully();            });        }        closeAll(ServerCnxn.DisconnectReason.SERVER_SHUTDOWN);        ChannelGroupFuture allChannelsCloseFuture = allChannels.close();        if (workerGroup != null) {            allChannelsCloseFuture.addListener(future -> {                workerGroup.shutdownGracefully();            });        }    } else {        if (bossGroup != null) {            bossGroup.shutdownGracefully();        }        if (workerGroup != null) {            workerGroup.shutdownGracefully();        }    }    if (zkServer != null) {        zkServer.shutdown();    }    synchronized (this) {        killed = true;        notifyAll();    }}
start
public voidf2020_1)
{    if (listenBacklog != -1) {        bootstrap.option(ChannelOption.SO_BACKLOG, listenBacklog);    }        parentChannel = bootstrap.bind(localAddress).syncUninterruptibly().channel();            localAddress = (InetSocketAddress) parentChannel.localAddress();    }
reconfigure
public voidf2021_1InetSocketAddress addr)
{        if (addr != null && localAddress != null) {        if (addr.equals(localAddress) || (addr.getAddress().isAnyLocalAddress() && localAddress.getAddress().isAnyLocalAddress() && addr.getPort() == localAddress.getPort())) {                        return;        }    }    Channel oldChannel = parentChannel;    try {        parentChannel = bootstrap.bind(addr).syncUninterruptibly().channel();                        localAddress = (InetSocketAddress) parentChannel.localAddress();            } catch (Exception e) {            } finally {        oldChannel.close();    }}
startup
public void zookeeper_f2022_0(ZooKeeperServer zks, boolean startServer) throws IOException, InterruptedException
{    start();    setZooKeeperServer(zks);    if (startServer) {        zks.startdata();        zks.startup();    }}
getConnections
public Iterable<ServerCnxn> zookeeper_f2023_0()
{    return cnxns;}
getLocalAddress
public InetSocketAddress zookeeper_f2024_0()
{    return localAddress;}
addCnxn
private void zookeeper_f2025_0(final NettyServerCnxn cnxn)
{    cnxns.add(cnxn);    InetAddress addr = ((InetSocketAddress) cnxn.getChannel().remoteAddress()).getAddress();    ipMap.compute(addr, (a, cnxnCount) -> {        if (cnxnCount == null) {            cnxnCount = new AtomicInteger();        }        cnxnCount.incrementAndGet();        return cnxnCount;    });}
removeCnxnFromIpMap
 voidf2026_1NettyServerCnxn cnxn, InetAddress remoteAddress)
{    ipMap.compute(remoteAddress, (addr, cnxnCount) -> {        if (cnxnCount == null) {                        return null;        }        final int newValue = cnxnCount.decrementAndGet();        return newValue == 0 ? null : cnxnCount;    });}
getClientCnxnCount
private int zookeeper_f2027_0(final InetAddress addr)
{    final AtomicInteger count = ipMap.get(addr);    return count == null ? 0 : count.get();}
resetAllConnectionStats
public void zookeeper_f2028_0()
{        for (ServerCnxn c : cnxns) {        c.resetStats();    }}
getAllConnectionInfo
public Iterable<Map<String, Object>> zookeeper_f2029_0(boolean brief)
{    Set<Map<String, Object>> info = new HashSet<Map<String, Object>>();        for (ServerCnxn c : cnxns) {        info.add(c.getConnectionInfo(brief));    }    return info;}
setTestAllocator
 static void zookeeper_f2030_0(ByteBufAllocator allocator)
{    TEST_ALLOCATOR.set(allocator);}
clearTestAllocator
 static void zookeeper_f2031_0()
{    TEST_ALLOCATOR.set(null);}
setAdvancedFlowControlEnabled
public void zookeeper_f2032_0(boolean advancedFlowControlEnabled)
{    this.advancedFlowControlEnabled = advancedFlowControlEnabled;}
setSecure
public void zookeeper_f2033_0(boolean secure)
{    this.secure = secure;}
getParentChannel
public Channel zookeeper_f2034_0()
{    return parentChannel;}
sendCloseSession
public void zookeeper_f2035_0()
{    sendBuffer(ServerCnxnFactory.closeConn);}
sendBufferSync
 voidf2036_1ByteBuffer bb)
{    try {        /* configure socket to be blocking             * so that we dont have to do write in             * a tight while loop             */        if (bb != ServerCnxnFactory.closeConn) {            if (sock.isOpen()) {                sock.configureBlocking(true);                sock.write(bb);            }            packetSent();        }    } catch (IOException ie) {            }}
sendBuffer
public void zookeeper_f2037_0(ByteBuffer... buffers)
{    LOG.trace("Add a buffer to outgoingBuffers, sk {} is valid: {}", sk, sk.isValid());    synchronized (outgoingBuffers) {        for (ByteBuffer buffer : buffers) {            outgoingBuffers.add(buffer);        }        outgoingBuffers.add(packetSentinel);    }    requestInterestOpsUpdate();}
handleFailedRead
private void zookeeper_f2038_0() throws EndOfStreamException
{    setStale();    ServerMetrics.getMetrics().CONNECTION_DROP_COUNT.add(1);    throw new EndOfStreamException("Unable to read additional data from client," + " it probably closed the socket:" + " address = " + sock.socket().getRemoteSocketAddress() + "," + " session = 0x" + Long.toHexString(sessionId), DisconnectReason.UNABLE_TO_READ_FROM_CLIENT);}
readPayload
private void zookeeper_f2039_0() throws IOException, InterruptedException, ClientCnxnLimitException
{    if (incomingBuffer.remaining() != 0) {                        int rc = sock.read(incomingBuffer);        if (rc < 0) {            handleFailedRead();        }    }    if (incomingBuffer.remaining() == 0) {                incomingBuffer.flip();        packetReceived(4 + incomingBuffer.remaining());        if (!initialized) {            readConnectRequest();        } else {            readRequest();        }        lenBuffer.clear();        incomingBuffer = lenBuffer;    }}
isSelectable
public boolean zookeeper_f2040_0()
{    return sk.isValid() && selectable.get();}
disableSelectable
public void zookeeper_f2041_0()
{    selectable.set(false);}
enableSelectable
public void zookeeper_f2042_0()
{    selectable.set(true);}
requestInterestOpsUpdate
private void zookeeper_f2043_0()
{    if (isSelectable()) {        selectorThread.addInterestOpsUpdateRequest(sk);    }}
handleWrite
 void zookeeper_f2044_0(SelectionKey k) throws IOException
{    if (outgoingBuffers.isEmpty()) {        return;    }    /*         * This is going to reset the buffer position to 0 and the         * limit to the size of the buffer, so that we can fill it         * with data from the non-direct buffers that we need to         * send.         */    ByteBuffer directBuffer = NIOServerCnxnFactory.getDirectBuffer();    if (directBuffer == null) {        ByteBuffer[] bufferList = new ByteBuffer[outgoingBuffers.size()];                        sock.write(outgoingBuffers.toArray(bufferList));                ByteBuffer bb;        while ((bb = outgoingBuffers.peek()) != null) {            if (bb == ServerCnxnFactory.closeConn) {                throw new CloseRequestException("close requested", DisconnectReason.CLIENT_CLOSED_CONNECTION);            }            if (bb == packetSentinel) {                packetSent();            }            if (bb.remaining() > 0) {                break;            }            outgoingBuffers.remove();        }    } else {        directBuffer.clear();        for (ByteBuffer b : outgoingBuffers) {            if (directBuffer.remaining() < b.remaining()) {                /*                     * When we call put later, if the directBuffer is to                     * small to hold everything, nothing will be copied,                     * so we've got to slice the buffer if it's too big.                     */                b = (ByteBuffer) b.slice().limit(directBuffer.remaining());            }            /*                 * put() is going to modify the positions of both                 * buffers, put we don't want to change the position of                 * the source buffers (we'll do that after the send, if                 * needed), so we save and reset the position after the                 * copy                 */            int p = b.position();            directBuffer.put(b);            b.position(p);            if (directBuffer.remaining() == 0) {                break;            }        }        /*             * Do the flip: limit becomes position, position gets set to             * 0. This sets us up for the write.             */        directBuffer.flip();        int sent = sock.write(directBuffer);        ByteBuffer bb;                while ((bb = outgoingBuffers.peek()) != null) {            if (bb == ServerCnxnFactory.closeConn) {                throw new CloseRequestException("close requested", DisconnectReason.CLIENT_CLOSED_CONNECTION);            }            if (bb == packetSentinel) {                packetSent();            }            if (sent < bb.remaining()) {                /*                     * We only partially sent this buffer, so we update                     * the position and exit the loop.                     */                bb.position(bb.position() + sent);                break;            }            /* We've sent the whole buffer, so drop the buffer */            sent -= bb.remaining();            outgoingBuffers.remove();        }    }}
isSocketOpen
protected boolean zookeeper_f2045_0()
{    return sock.isOpen();}
doIO
 voidf2046_1SelectionKey k) throws InterruptedException
{    try {        if (!isSocketOpen()) {                        return;        }        if (k.isReadable()) {            int rc = sock.read(incomingBuffer);            if (rc < 0) {                handleFailedRead();            }            if (incomingBuffer.remaining() == 0) {                boolean isPayload;                if (incomingBuffer == lenBuffer) {                                        incomingBuffer.flip();                    isPayload = readLength(k);                    incomingBuffer.clear();                } else {                                        isPayload = true;                }                if (isPayload) {                                        readPayload();                } else {                                        return;                }            }        }        if (k.isWritable()) {            handleWrite(k);            if (!initialized && !getReadInterest() && !getWriteInterest()) {                throw new CloseRequestException("responded to info probe", DisconnectReason.INFO_PROBE);            }        }    } catch (CancelledKeyException e) {                        close(DisconnectReason.CANCELLED_KEY_EXCEPTION);    } catch (CloseRequestException e) {                close();    } catch (EndOfStreamException e) {                        close(e.getReason());    } catch (ClientCnxnLimitException e) {                ServerMetrics.getMetrics().CONNECTION_REJECTED.add(1);        if (LOG.isDebugEnabled()) {                    }        close(DisconnectReason.CLIENT_CNX_LIMIT);    } catch (IOException e) {                        close(DisconnectReason.IO_EXCEPTION);    }}
readRequest
private void zookeeper_f2047_0() throws IOException
{    zkServer.processPacket(this, incomingBuffer);}
getWriteInterest
private boolean zookeeper_f2048_0()
{    return !outgoingBuffers.isEmpty();}
getReadInterest
private boolean zookeeper_f2049_0()
{    return !throttled.get();}
disableRecv
public void zookeeper_f2050_0(boolean waitDisableRecv)
{    if (throttled.compareAndSet(false, true)) {        requestInterestOpsUpdate();    }}
enableRecv
public void zookeeper_f2051_0()
{    if (throttled.compareAndSet(true, false)) {        requestInterestOpsUpdate();    }}
readConnectRequest
private void zookeeper_f2052_0() throws IOException, InterruptedException, ClientCnxnLimitException
{    if (!isZKServerRunning()) {        throw new IOException("ZooKeeperServer not running");    }    zkServer.processConnectRequest(this, incomingBuffer);    initialized = true;}
checkFlush
private void zookeeper_f2053_0(boolean force)
{    if ((force && sb.length() > 0) || sb.length() > 2048) {        sendBufferSync(ByteBuffer.wrap(sb.toString().getBytes()));                sb.setLength(0);    }}
close
public void zookeeper_f2054_0() throws IOException
{    if (sb == null) {        return;    }    checkFlush(true);        sb = null;}
flush
public void zookeeper_f2055_0() throws IOException
{    checkFlush(true);}
write
public void zookeeper_f2056_0(char[] cbuf, int off, int len) throws IOException
{    sb.append(cbuf, off, len);    checkFlush(false);}
checkFourLetterWord
private booleanf2057_1final SelectionKey k, final int len) throws IOException
{        if (!FourLetterCommands.isKnown(len)) {        return false;    }    String cmd = FourLetterCommands.getCommandString(len);    packetReceived(4);    /**     * cancel the selection key to remove the socket handling     * from selector. This is to prevent netcat problem wherein     * netcat immediately closes the sending side after sending the     * commands and still keeps the receiving channel open.     * The idea is to remove the selectionkey from the selector     * so that the selector does not notice the closed read on the     * socket channel and keep the socket alive to write the data to     * and makes sure to close the socket after its done writing the data     */    if (k != null) {        try {            k.cancel();        } catch (Exception e) {                    }    }    final PrintWriter pwriter = new PrintWriter(new BufferedWriter(new SendBufferWriter()));        if (!FourLetterCommands.isEnabled(cmd)) {                NopCommand nopCmd = new NopCommand(pwriter, this, cmd + " is not executed because it is not in the whitelist.");        nopCmd.start();        return true;    }        if (len == FourLetterCommands.setTraceMaskCmd) {        incomingBuffer = ByteBuffer.allocate(8);        int rc = sock.read(incomingBuffer);        if (rc < 0) {            throw new IOException("Read error");        }        incomingBuffer.flip();        long traceMask = incomingBuffer.getLong();        ZooTrace.setTextTraceLevel(traceMask);        SetTraceMaskCommand setMask = new SetTraceMaskCommand(pwriter, this, traceMask);        setMask.start();        return true;    } else {        CommandExecutor commandExecutor = new CommandExecutor();        return commandExecutor.execute(this, pwriter, len, zkServer, factory);    }}
readLength
private boolean zookeeper_f2058_0(SelectionKey k) throws IOException
{        int len = lenBuffer.getInt();    if (!initialized && checkFourLetterWord(sk, len)) {        return false;    }    if (len < 0 || len > BinaryInputArchive.maxBuffer) {        throw new IOException("Len error " + len);    }    if (!isZKServerRunning()) {        throw new IOException("ZooKeeperServer not running");    }        zkServer.checkRequestSizeWhenReceivingMessage(len);    incomingBuffer = ByteBuffer.allocate(len);    return true;}
isZKServerRunning
 boolean zookeeper_f2059_0()
{    return zkServer != null && zkServer.isRunning();}
getSessionTimeout
public int zookeeper_f2060_0()
{    return sessionTimeout;}
toString
public String zookeeper_f2061_0()
{    return "ip: " + sock.socket().getRemoteSocketAddress() + " sessionId: 0x" + Long.toHexString(sessionId);}
close
public void zookeeper_f2062_0(DisconnectReason reason)
{    disconnectReason = reason;    close();}
close
private voidf2063_1)
{    setStale();    if (!factory.removeCnxn(this)) {        return;    }    if (zkServer != null) {        zkServer.removeCnxn(this);    }    if (sk != null) {        try {                        sk.cancel();        } catch (Exception e) {                    }    }    closeSock();}
closeSock
private voidf2064_1)
{    if (!sock.isOpen()) {        return;    }    if (LOG.isDebugEnabled()) {            }    closeSock(sock);}
closeSock
public static voidf2065_1SocketChannel sock)
{    if (!sock.isOpen()) {        return;    }    try {        /*             * The following sequence of code is stupid! You would think that             * only sock.close() is needed, but alas, it doesn't work that way.             * If you just do sock.close() there are cases where the socket             * doesn't actually close...             */        sock.socket().shutdownOutput();    } catch (IOException e) {                    }    try {        sock.socket().shutdownInput();    } catch (IOException e) {                    }    try {        sock.socket().close();    } catch (IOException e) {            }    try {        sock.close();    } catch (IOException e) {            }}
sendResponse
public voidf2066_1ReplyHeader h, Record r, String tag, String cacheKey, Stat stat)
{    try {        sendBuffer(serialize(h, r, tag, cacheKey, stat));        decrOutstandingAndCheckThrottle(h);    } catch (Exception e) {            }}
process
public void zookeeper_f2067_0(WatchedEvent event)
{    ReplyHeader h = new ReplyHeader(-1, -1L, 0);    if (LOG.isTraceEnabled()) {        ZooTrace.logTraceMessage(LOG, ZooTrace.EVENT_DELIVERY_TRACE_MASK, "Deliver event " + event + " to 0x" + Long.toHexString(this.sessionId) + " through " + this);    }        WatcherEvent e = event.getWrapper();    sendResponse(h, e, "notification", null, null);}
getSessionId
public long zookeeper_f2068_0()
{    return sessionId;}
setSessionId
public void zookeeper_f2069_0(long sessionId)
{    this.sessionId = sessionId;    factory.addSession(sessionId, this);}
setSessionTimeout
public void zookeeper_f2070_0(int sessionTimeout)
{    this.sessionTimeout = sessionTimeout;    factory.touchCnxn(this);}
getInterestOps
public int zookeeper_f2071_0()
{    if (!isSelectable()) {        return 0;    }    int interestOps = 0;    if (getReadInterest()) {        interestOps |= SelectionKey.OP_READ;    }    if (getWriteInterest()) {        interestOps |= SelectionKey.OP_WRITE;    }    return interestOps;}
getRemoteSocketAddress
public InetSocketAddress zookeeper_f2072_0()
{    if (!sock.isOpen()) {        return null;    }    return (InetSocketAddress) sock.socket().getRemoteSocketAddress();}
getSocketAddress
public InetAddress zookeeper_f2073_0()
{    if (!sock.isOpen()) {        return null;    }    return sock.socket().getInetAddress();}
serverStats
protected ServerStats zookeeper_f2074_0()
{    if (zkServer == null) {        return null;    }    return zkServer.serverStats();}
isSecure
public boolean zookeeper_f2075_0()
{    return false;}
getClientCertificateChain
public Certificate[] zookeeper_f2076_0()
{    throw new UnsupportedOperationException("SSL is unsupported in NIOServerCnxn");}
setClientCertificateChain
public void zookeeper_f2077_0(Certificate[] chain)
{    throw new UnsupportedOperationException("SSL is unsupported in NIOServerCnxn");}
uncaughtException
public voidf2078_1Thread t, Throwable e)
{    }
wakeupSelector
public void zookeeper_f2079_0()
{    selector.wakeup();}
closeSelector
protected voidf2080_1)
{    try {        selector.close();    } catch (IOException e) {            }}
cleanupSelectionKey
protected voidf2081_1SelectionKey key)
{    if (key != null) {        try {            key.cancel();        } catch (Exception ex) {                    }    }}
fastCloseSock
protected voidf2082_1SocketChannel sc)
{    if (sc != null) {        try {                        sc.socket().setSoLinger(true, 0);        } catch (SocketException e) {                    }        NIOServerCnxn.closeSock(sc);    }}
run
public voidf2083_1)
{    try {        while (!stopped && !acceptSocket.socket().isClosed()) {            try {                select();            } catch (RuntimeException e) {                            } catch (Exception e) {                            }        }    } finally {        closeSelector();                if (!reconfiguring) {            NIOServerCnxnFactory.this.stop();        }            }}
setReconfiguring
public void zookeeper_f2084_0()
{    reconfiguring = true;}
select
private voidf2085_1)
{    try {        selector.select();        Iterator<SelectionKey> selectedKeys = selector.selectedKeys().iterator();        while (!stopped && selectedKeys.hasNext()) {            SelectionKey key = selectedKeys.next();            selectedKeys.remove();            if (!key.isValid()) {                continue;            }            if (key.isAcceptable()) {                if (!doAccept()) {                                                                                                    pauseAccept(10);                }            } else {                            }        }    } catch (IOException e) {            }}
pauseAccept
private void zookeeper_f2086_0(long millisecs)
{    acceptKey.interestOps(0);    try {        selector.select(millisecs);    } catch (IOException e) {        } finally {        acceptKey.interestOps(SelectionKey.OP_ACCEPT);    }}
doAccept
private booleanf2087_1)
{    boolean accepted = false;    SocketChannel sc = null;    try {        sc = acceptSocket.accept();        accepted = true;        InetAddress ia = sc.socket().getInetAddress();        int cnxncount = getClientCnxnCount(ia);        if (maxClientCnxns > 0 && cnxncount >= maxClientCnxns) {            throw new IOException("Too many connections from " + ia + " - max is " + maxClientCnxns);        }                sc.configureBlocking(false);                if (!selectorIterator.hasNext()) {            selectorIterator = selectorThreads.iterator();        }        SelectorThread selectorThread = selectorIterator.next();        if (!selectorThread.addAcceptedConnection(sc)) {            throw new IOException("Unable to add connection to selector queue" + (stopped ? " (shutdown in progress)" : ""));        }        acceptErrorLogger.flush();    } catch (IOException e) {                ServerMetrics.getMetrics().CONNECTION_REJECTED.add(1);        acceptErrorLogger.rateLimitLog("Error accepting new connection: " + e.getMessage());        fastCloseSock(sc);    }    return accepted;}
addAcceptedConnection
public boolean zookeeper_f2088_0(SocketChannel accepted)
{    if (stopped || !acceptedQueue.offer(accepted)) {        return false;    }    wakeupSelector();    return true;}
addInterestOpsUpdateRequest
public boolean zookeeper_f2089_0(SelectionKey sk)
{    if (stopped || !updateQueue.offer(sk)) {        return false;    }    wakeupSelector();    return true;}
run
public voidf2090_1)
{    try {        while (!stopped) {            try {                select();                processAcceptedConnections();                processInterestOpsUpdateRequests();            } catch (RuntimeException e) {                            } catch (Exception e) {                            }        }                for (SelectionKey key : selector.keys()) {            NIOServerCnxn cnxn = (NIOServerCnxn) key.attachment();            if (cnxn.isSelectable()) {                cnxn.close(ServerCnxn.DisconnectReason.SERVER_SHUTDOWN);            }            cleanupSelectionKey(key);        }        SocketChannel accepted;        while ((accepted = acceptedQueue.poll()) != null) {            fastCloseSock(accepted);        }        updateQueue.clear();    } finally {        closeSelector();                        NIOServerCnxnFactory.this.stop();            }}
select
private voidf2091_1)
{    try {        selector.select();        Set<SelectionKey> selected = selector.selectedKeys();        ArrayList<SelectionKey> selectedList = new ArrayList<SelectionKey>(selected);        Collections.shuffle(selectedList);        Iterator<SelectionKey> selectedKeys = selectedList.iterator();        while (!stopped && selectedKeys.hasNext()) {            SelectionKey key = selectedKeys.next();            selected.remove(key);            if (!key.isValid()) {                cleanupSelectionKey(key);                continue;            }            if (key.isReadable() || key.isWritable()) {                handleIO(key);            } else {                            }        }    } catch (IOException e) {            }}
handleIO
private void zookeeper_f2092_0(SelectionKey key)
{    IOWorkRequest workRequest = new IOWorkRequest(this, key);    NIOServerCnxn cnxn = (NIOServerCnxn) key.attachment();            cnxn.disableSelectable();    key.interestOps(0);    touchCnxn(cnxn);    workerPool.schedule(workRequest);}
processAcceptedConnections
private void zookeeper_f2093_0()
{    SocketChannel accepted;    while (!stopped && (accepted = acceptedQueue.poll()) != null) {        SelectionKey key = null;        try {            key = accepted.register(selector, SelectionKey.OP_READ);            NIOServerCnxn cnxn = createConnection(accepted, key, this);            key.attach(cnxn);            addCnxn(cnxn);        } catch (IOException e) {                        cleanupSelectionKey(key);            fastCloseSock(accepted);        }    }}
processInterestOpsUpdateRequests
private void zookeeper_f2094_0()
{    SelectionKey key;    while (!stopped && (key = updateQueue.poll()) != null) {        if (!key.isValid()) {            cleanupSelectionKey(key);        }        NIOServerCnxn cnxn = (NIOServerCnxn) key.attachment();        if (cnxn.isSelectable()) {            key.interestOps(cnxn.getInterestOps());        }    }}
doWork
public void zookeeper_f2095_0() throws InterruptedException
{    if (!key.isValid()) {        selectorThread.cleanupSelectionKey(key);        return;    }    if (key.isReadable() || key.isWritable()) {        cnxn.doIO(key);                if (stopped) {            cnxn.close(ServerCnxn.DisconnectReason.SERVER_SHUTDOWN);            return;        }        if (!key.isValid()) {            selectorThread.cleanupSelectionKey(key);            return;        }        touchCnxn(cnxn);    }        cnxn.enableSelectable();        if (!selectorThread.addInterestOpsUpdateRequest(key)) {        cnxn.close(ServerCnxn.DisconnectReason.CONNECTION_MODE_CHANGED);    }}
cleanup
public void zookeeper_f2096_0()
{    cnxn.close(ServerCnxn.DisconnectReason.CLEAN_UP);}
run
public voidf2097_1)
{    try {        while (!stopped) {            long waitTime = cnxnExpiryQueue.getWaitTime();            if (waitTime > 0) {                Thread.sleep(waitTime);                continue;            }            for (NIOServerCnxn conn : cnxnExpiryQueue.poll()) {                ServerMetrics.getMetrics().SESSIONLESS_CONNECTIONS_EXPIRED.add(1);                conn.close(ServerCnxn.DisconnectReason.CONNECTION_EXPIRED);            }        }    } catch (InterruptedException e) {            }}
initialValue
protected ByteBuffer zookeeper_f2098_0()
{    return ByteBuffer.allocateDirect(directBufferBytes);}
getDirectBuffer
public static ByteBuffer zookeeper_f2099_0()
{    return directBufferBytes > 0 ? directBuffer.get() : null;}
configure
public voidf2100_1InetSocketAddress addr, int maxcc, int backlog, boolean secure) throws IOException
{    if (secure) {        throw new UnsupportedOperationException("SSL isn't supported in NIOServerCnxn");    }    configureSaslLogin();    maxClientCnxns = maxcc;    sessionlessCnxnTimeout = Integer.getInteger(ZOOKEEPER_NIO_SESSIONLESS_CNXN_TIMEOUT, 10000);                    cnxnExpiryQueue = new ExpiryQueue<NIOServerCnxn>(sessionlessCnxnTimeout);    expirerThread = new ConnectionExpirerThread();    int numCores = Runtime.getRuntime().availableProcessors();        numSelectorThreads = Integer.getInteger(ZOOKEEPER_NIO_NUM_SELECTOR_THREADS, Math.max((int) Math.sqrt((float) numCores / 2), 1));    if (numSelectorThreads < 1) {        throw new IOException("numSelectorThreads must be at least 1");    }    numWorkerThreads = Integer.getInteger(ZOOKEEPER_NIO_NUM_WORKER_THREADS, 2 * numCores);    workerShutdownTimeoutMS = Long.getLong(ZOOKEEPER_NIO_SHUTDOWN_TIMEOUT, 5000);        for (int i = 0; i < numSelectorThreads; ++i) {        selectorThreads.add(new SelectorThread(i));    }    listenBacklog = backlog;    this.ss = ServerSocketChannel.open();    ss.socket().setReuseAddress(true);        if (listenBacklog == -1) {        ss.socket().bind(addr);    } else {        ss.socket().bind(addr, listenBacklog);    }    ss.configureBlocking(false);    acceptThread = new AcceptThread(ss, addr, selectorThreads);}
tryClose
private voidf2101_1ServerSocketChannel s)
{    try {        s.close();    } catch (IOException sse) {            }}
reconfigure
public voidf2102_1InetSocketAddress addr)
{    ServerSocketChannel oldSS = ss;    try {        acceptThread.setReconfiguring();        tryClose(oldSS);        acceptThread.wakeupSelector();        try {            acceptThread.join();        } catch (InterruptedException e) {                        Thread.currentThread().interrupt();        }        this.ss = ServerSocketChannel.open();        ss.socket().setReuseAddress(true);                ss.socket().bind(addr);        ss.configureBlocking(false);        acceptThread = new AcceptThread(ss, addr, selectorThreads);        acceptThread.start();    } catch (IOException e) {                tryClose(oldSS);    }}
getMaxClientCnxnsPerHost
public int zookeeper_f2103_0()
{    return maxClientCnxns;}
setMaxClientCnxnsPerHost
public void zookeeper_f2104_0(int max)
{    maxClientCnxns = max;}
getSocketListenBacklog
public int zookeeper_f2105_0()
{    return listenBacklog;}
start
public void zookeeper_f2106_0()
{    stopped = false;    if (workerPool == null) {        workerPool = new WorkerService("NIOWorker", numWorkerThreads, false);    }    for (SelectorThread thread : selectorThreads) {        if (thread.getState() == Thread.State.NEW) {            thread.start();        }    }        if (acceptThread.getState() == Thread.State.NEW) {        acceptThread.start();    }    if (expirerThread.getState() == Thread.State.NEW) {        expirerThread.start();    }}
startup
public void zookeeper_f2107_0(ZooKeeperServer zks, boolean startServer) throws IOException, InterruptedException
{    start();    setZooKeeperServer(zks);    if (startServer) {        zks.startdata();        zks.startup();    }}
getLocalAddress
public InetSocketAddress zookeeper_f2108_0()
{    return (InetSocketAddress) ss.socket().getLocalSocketAddress();}
getLocalPort
public int zookeeper_f2109_0()
{    return ss.socket().getLocalPort();}
removeCnxn
public boolean zookeeper_f2110_0(NIOServerCnxn cnxn)
{        if (!cnxns.remove(cnxn)) {        return false;    }    cnxnExpiryQueue.remove(cnxn);    removeCnxnFromSessionMap(cnxn);    InetAddress addr = cnxn.getSocketAddress();    if (addr != null) {        Set<NIOServerCnxn> set = ipMap.get(addr);        if (set != null) {            set.remove(cnxn);                        }    }        unregisterConnection(cnxn);    return true;}
touchCnxn
public void zookeeper_f2111_0(NIOServerCnxn cnxn)
{    cnxnExpiryQueue.update(cnxn, cnxn.getSessionTimeout());}
addCnxn
private void zookeeper_f2112_0(NIOServerCnxn cnxn) throws IOException
{    InetAddress addr = cnxn.getSocketAddress();    if (addr == null) {        throw new IOException("Socket of " + cnxn + " has been closed");    }    Set<NIOServerCnxn> set = ipMap.get(addr);    if (set == null) {                                                        set = Collections.newSetFromMap(new ConcurrentHashMap<NIOServerCnxn, Boolean>(2));                        Set<NIOServerCnxn> existingSet = ipMap.putIfAbsent(addr, set);        if (existingSet != null) {            set = existingSet;        }    }    set.add(cnxn);    cnxns.add(cnxn);    touchCnxn(cnxn);}
createConnection
protected NIOServerCnxn zookeeper_f2113_0(SocketChannel sock, SelectionKey sk, SelectorThread selectorThread) throws IOException
{    return new NIOServerCnxn(zkServer, sock, sk, this, selectorThread);}
getClientCnxnCount
private int zookeeper_f2114_0(InetAddress cl)
{    Set<NIOServerCnxn> s = ipMap.get(cl);    if (s == null) {        return 0;    }    return s.size();}
closeAll
public voidf2115_1ServerCnxn.DisconnectReason reason)
{        for (ServerCnxn cnxn : cnxns) {        try {                        cnxn.close(reason);        } catch (Exception e) {                    }    }}
stop
public voidf2116_1)
{    stopped = true;        try {        ss.close();    } catch (IOException e) {            }    if (acceptThread != null) {        if (acceptThread.isAlive()) {            acceptThread.wakeupSelector();        } else {            acceptThread.closeSelector();        }    }    if (expirerThread != null) {        expirerThread.interrupt();    }    for (SelectorThread thread : selectorThreads) {        if (thread.isAlive()) {            thread.wakeupSelector();        } else {            thread.closeSelector();        }    }    if (workerPool != null) {        workerPool.stop();    }}
shutdown
public voidf2117_1)
{    try {                stop();                join();                closeAll(ServerCnxn.DisconnectReason.SERVER_SHUTDOWN);        if (login != null) {            login.shutdown();        }    } catch (InterruptedException e) {            } catch (Exception e) {            }    if (zkServer != null) {        zkServer.shutdown();    }}
join
public void zookeeper_f2118_0() throws InterruptedException
{    if (acceptThread != null) {        acceptThread.join();    }    for (SelectorThread thread : selectorThreads) {        thread.join();    }    if (workerPool != null) {        workerPool.join(workerShutdownTimeoutMS);    }}
getConnections
public Iterable<ServerCnxn> zookeeper_f2119_0()
{    return cnxns;}
dumpConnections
public void zookeeper_f2120_0(PrintWriter pwriter)
{    pwriter.print("Connections ");    cnxnExpiryQueue.dump(pwriter);}
resetAllConnectionStats
public void zookeeper_f2121_0()
{        for (ServerCnxn c : cnxns) {        c.resetStats();    }}
getAllConnectionInfo
public Iterable<Map<String, Object>> zookeeper_f2122_0(boolean brief)
{    HashSet<Map<String, Object>> info = new HashSet<Map<String, Object>>();        for (ServerCnxn c : cnxns) {        info.add(c.getConnectionInfo(brief));    }    return info;}
put
public DataNode zookeeper_f2123_0(String path, DataNode node)
{    DataNode oldNode = nodes.put(path, node);    addDigest(path, node);    if (oldNode != null) {        removeDigest(path, oldNode);    }    return oldNode;}
putWithoutDigest
public DataNode zookeeper_f2124_0(String path, DataNode node)
{    return nodes.put(path, node);}
get
public DataNode zookeeper_f2125_0(String path)
{    return nodes.get(path);}
remove
public DataNode zookeeper_f2126_0(String path)
{    DataNode oldNode = nodes.remove(path);    if (oldNode != null) {        removeDigest(path, oldNode);    }    return oldNode;}
keySet
public ConcurrentHashMap.KeySetView<String, DataNode> zookeeper_f2127_0()
{    return nodes.keySet();}
entrySet
public Set<Map.Entry<String, DataNode>> zookeeper_f2128_0()
{    return nodes.entrySet();}
clear
public void zookeeper_f2129_0()
{    nodes.clear();    hash = new AdHash();}
size
public int zookeeper_f2130_0()
{    return nodes.size();}
preChange
public void zookeeper_f2131_0(String path, DataNode node)
{    removeDigest(path, node);}
postChange
public void zookeeper_f2132_0(String path, DataNode node)
{            node.digestCached = false;    addDigest(path, node);}
addDigest
private void zookeeper_f2133_0(String path, DataNode node)
{    if (ZooKeeperServer.isDigestEnabled()) {        hash.addDigest(digestCalculator.calculateDigest(path, node));    }}
removeDigest
private void zookeeper_f2134_0(String path, DataNode node)
{    if (ZooKeeperServer.isDigestEnabled()) {        hash.removeDigest(digestCalculator.calculateDigest(path, node));    }}
getDigest
public long zookeeper_f2135_0()
{    return hash.getHash();}
getName
public String zookeeper_f2136_0()
{    return "Observer";}
getPendingRevalidationCount
public int zookeeper_f2137_0()
{    return this.observer.getPendingRevalidationsCount();}
getQuorumAddress
public String zookeeper_f2138_0()
{    return observer.getSocket().toString();}
getLearnerMaster
public String zookeeper_f2139_0()
{    QuorumPeer.QuorumServer learnerMaster = observer.getCurrentLearnerMaster();    if (learnerMaster == null || learnerMaster.addr == null) {        return "Unknown";    }    return learnerMaster.addr.getAddress().getHostAddress() + ":" + learnerMaster.addr.getPort();}
setLearnerMaster
public void zookeeper_f2140_0(String learnerMaster)
{    if (!observer.setLearnerMaster(learnerMaster)) {        throw new IllegalArgumentException("Not a valid learner master");    }}
getPreAllocSize
public static long zookeeper_f2141_0()
{    return preAllocSize;}
setPreallocSize
public static void zookeeper_f2142_0(long size)
{    preAllocSize = size;}
setCurrentSize
public void zookeeper_f2143_0(long currentSize)
{    this.currentSize = currentSize;}
padFile
 long zookeeper_f2144_0(FileChannel fileChannel) throws IOException
{    long newFileSize = calculateFileSizeWithPadding(fileChannel.position(), currentSize, preAllocSize);    if (currentSize != newFileSize) {        fileChannel.write((ByteBuffer) fill.position(0), newFileSize - fill.remaining());        currentSize = newFileSize;    }    return currentSize;}
calculateFileSizeWithPadding
public static long zookeeper_f2145_0(long position, long fileSize, long preAllocSize)
{        if (preAllocSize > 0 && position + 4096 >= fileSize) {                if (position > fileSize) {            fileSize = position + preAllocSize;            fileSize -= fileSize % preAllocSize;        } else {            fileSize += preAllocSize;        }    }    return fileSize;}
getLastSnapshotInfo
public SnapshotInfo zookeeper_f2146_0()
{    return this.lastSnapshotInfo;}
deserialize
public longf2147_1DataTree dt, Map<Long, Integer> sessions) throws IOException
{                List<File> snapList = findNValidSnapshots(100);    if (snapList.size() == 0) {        return -1L;    }    File snap = null;    boolean foundValid = false;    for (int i = 0, snapListSize = snapList.size(); i < snapListSize; i++) {        snap = snapList.get(i);                try (CheckedInputStream snapIS = SnapStream.getInputStream(snap)) {            InputArchive ia = BinaryInputArchive.getArchive(snapIS);            deserialize(dt, sessions, ia);            SnapStream.checkSealIntegrity(snapIS, ia);            if (dt.deserializeZxidDigest(ia)) {                SnapStream.checkSealIntegrity(snapIS, ia);            }            foundValid = true;            break;        } catch (IOException e) {                    }    }    if (!foundValid) {        throw new IOException("Not able to find valid snapshots in " + snapDir);    }    dt.lastProcessedZxid = Util.getZxidFromName(snap.getName(), SNAPSHOT_FILE_PREFIX);    lastSnapshotInfo = new SnapshotInfo(dt.lastProcessedZxid, snap.lastModified() / 1000);        if (dt.getDigestFromLoadedSnapshot() != null) {        dt.compareSnapshotDigests(dt.lastProcessedZxid);    }    return dt.lastProcessedZxid;}
deserialize
public void zookeeper_f2148_0(DataTree dt, Map<Long, Integer> sessions, InputArchive ia) throws IOException
{    FileHeader header = new FileHeader();    header.deserialize(ia, "fileheader");    if (header.getMagic() != SNAP_MAGIC) {        throw new IOException("mismatching magic headers " + header.getMagic() + " !=  " + FileSnap.SNAP_MAGIC);    }    SerializeUtils.deserializeSnapshot(dt, ia, sessions);}
findMostRecentSnapshot
public File zookeeper_f2149_0() throws IOException
{    List<File> files = findNValidSnapshots(1);    if (files.size() == 0) {        return null;    }    return files.get(0);}
findNValidSnapshots
private List<File>f2150_1int n) throws IOException
{    List<File> files = Util.sortDataDir(snapDir.listFiles(), SNAPSHOT_FILE_PREFIX, false);    int count = 0;    List<File> list = new ArrayList<File>();    for (File f : files) {                try {            if (SnapStream.isValidSnapshot(f)) {                list.add(f);                count++;                if (count == n) {                    break;                }            }        } catch (IOException e) {                    }    }    return list;}
findNRecentSnapshots
public List<File> zookeeper_f2151_0(int n) throws IOException
{    List<File> files = Util.sortDataDir(snapDir.listFiles(), SNAPSHOT_FILE_PREFIX, false);    int count = 0;    List<File> list = new ArrayList<File>();    for (File f : files) {        if (count == n) {            break;        }        if (Util.getZxidFromName(f.getName(), SNAPSHOT_FILE_PREFIX) != -1) {            count++;            list.add(f);        }    }    return list;}
serialize
protected void zookeeper_f2152_0(DataTree dt, Map<Long, Integer> sessions, OutputArchive oa, FileHeader header) throws IOException
{        if (header == null) {        throw new IllegalStateException("Snapshot's not open for writing: uninitialized header");    }    header.serialize(oa, "fileheader");    SerializeUtils.serializeSnapshot(dt, oa, sessions);}
serialize
public synchronized void zookeeper_f2153_0(DataTree dt, Map<Long, Integer> sessions, File snapShot, boolean fsync) throws IOException
{    if (!close) {        try (CheckedOutputStream snapOS = SnapStream.getOutputStream(snapShot)) {            OutputArchive oa = BinaryOutputArchive.getArchive(snapOS);            FileHeader header = new FileHeader(SNAP_MAGIC, VERSION, dbId);            serialize(dt, sessions, oa, header);            SnapStream.sealStream(snapOS, oa);                        if (dt.serializeZxidDigest(oa)) {                SnapStream.sealStream(snapOS, oa);            }            lastSnapshotInfo = new SnapshotInfo(Util.getZxidFromName(snapShot.getName(), SNAPSHOT_FILE_PREFIX), snapShot.lastModified() / 1000);        }    }}
writeChecksum
private void zookeeper_f2154_0(CheckedOutputStream crcOut, OutputArchive oa) throws IOException
{    long val = crcOut.getChecksum().getValue();    oa.writeLong(val, "val");    oa.writeString("/", "path");}
checkChecksum
private void zookeeper_f2155_0(CheckedInputStream crcIn, InputArchive ia) throws IOException
{    long checkSum = crcIn.getChecksum().getValue();    long val = ia.readLong("val");        ia.readString("path");    if (val != checkSum) {        throw new IOException("CRC corruption");    }}
close
public synchronized void zookeeper_f2156_0() throws IOException
{    close = true;}
setPreallocSize
public static void zookeeper_f2157_0(long size)
{    FilePadding.setPreallocSize(size);}
setServerStats
public synchronized void zookeeper_f2158_0(ServerStats serverStats)
{    this.serverStats = serverStats;}
setTxnLogSizeLimit
public static void zookeeper_f2159_0(long size)
{    txnLogSizeLimit = size;}
getCurrentLogSize
public synchronized long zookeeper_f2160_0()
{    if (logFileWrite != null) {        return logFileWrite.length();    }    return 0;}
setTotalLogSize
public synchronized void zookeeper_f2161_0(long size)
{    prevLogsRunningTotal = size;}
getTotalLogSize
public synchronized long zookeeper_f2162_0()
{    return prevLogsRunningTotal + getCurrentLogSize();}
makeChecksumAlgorithm
protected Checksum zookeeper_f2163_0()
{    return new Adler32();}
rollLog
public synchronized void zookeeper_f2164_0() throws IOException
{    if (logStream != null) {        this.logStream.flush();        prevLogsRunningTotal += getCurrentLogSize();        this.logStream = null;        oa = null;        }}
close
public synchronized void zookeeper_f2165_0() throws IOException
{    if (logStream != null) {        logStream.close();    }    for (FileOutputStream log : streamsToFlush) {        log.close();    }}
append
public synchronized booleanf2166_1TxnHeader hdr, Record txn) throws IOException
{    if (hdr == null) {        return false;    }    if (hdr.getZxid() <= lastZxidSeen) {            } else {        lastZxidSeen = hdr.getZxid();    }    if (logStream == null) {        if (LOG.isInfoEnabled()) {                    }        logFileWrite = new File(logDir, Util.makeLogName(hdr.getZxid()));        fos = new FileOutputStream(logFileWrite);        logStream = new BufferedOutputStream(fos);        oa = BinaryOutputArchive.getArchive(logStream);        FileHeader fhdr = new FileHeader(TXNLOG_MAGIC, VERSION, dbId);        fhdr.serialize(oa, "fileheader");                logStream.flush();        filePadding.setCurrentSize(fos.getChannel().position());        streamsToFlush.add(fos);    }    filePadding.padFile(fos.getChannel());    byte[] buf = Util.marshallTxnEntry(hdr, txn);    if (buf == null || buf.length == 0) {        throw new IOException("Faulty serialization for header " + "and txn");    }    Checksum crc = makeChecksumAlgorithm();    crc.update(buf, 0, buf.length);    oa.writeLong(crc.getValue(), "txnEntryCRC");    Util.writeTxnBytes(oa, buf);    return true;}
getLogFiles
public static File[] zookeeper_f2167_0(File[] logDirList, long snapshotZxid)
{    List<File> files = Util.sortDataDir(logDirList, LOG_FILE_PREFIX, true);    long logZxid = 0;        for (File f : files) {        long fzxid = Util.getZxidFromName(f.getName(), LOG_FILE_PREFIX);        if (fzxid > snapshotZxid) {            break;        }                if (fzxid > logZxid) {            logZxid = fzxid;        }    }    List<File> v = new ArrayList<File>(5);    for (File f : files) {        long fzxid = Util.getZxidFromName(f.getName(), LOG_FILE_PREFIX);        if (fzxid < logZxid) {            continue;        }        v.add(f);    }    return v.toArray(new File[0]);}
getLastLoggedZxid
public longf2168_1)
{    File[] files = getLogFiles(logDir.listFiles(), 0);    long maxLog = files.length > 0 ? Util.getZxidFromName(files[files.length - 1].getName(), LOG_FILE_PREFIX) : -1;            long zxid = maxLog;    TxnIterator itr = null;    try {        FileTxnLog txn = new FileTxnLog(logDir);        itr = txn.read(maxLog);        while (true) {            if (!itr.next()) {                break;            }            TxnHeader hdr = itr.getHeader();            zxid = hdr.getZxid();        }    } catch (IOException e) {            } finally {        close(itr);    }    return zxid;}
close
private voidf2169_1TxnIterator itr)
{    if (itr != null) {        try {            itr.close();        } catch (IOException ioe) {                    }    }}
commit
public synchronized voidf2170_1) throws IOException
{    if (logStream != null) {        logStream.flush();    }    for (FileOutputStream log : streamsToFlush) {        log.flush();        if (forceSync) {            long startSyncNS = System.nanoTime();            FileChannel channel = log.getChannel();            channel.force(false);            syncElapsedMS = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startSyncNS);            if (syncElapsedMS > fsyncWarningThresholdMS) {                if (serverStats != null) {                    serverStats.incrementFsyncThresholdExceedCount();                }                            }            ServerMetrics.getMetrics().FSYNC_TIME.add(syncElapsedMS);        }    }    while (streamsToFlush.size() > 1) {        streamsToFlush.poll().close();    }        if (txnLogSizeLimit > 0) {        long logSize = getCurrentLogSize();        if (logSize > txnLogSizeLimit) {                        rollLog();        }    }}
getTxnLogSyncElapsedTime
public long zookeeper_f2171_0()
{    return syncElapsedMS;}
read
public TxnIterator zookeeper_f2172_0(long zxid) throws IOException
{    return read(zxid, true);}
read
public TxnIterator zookeeper_f2173_0(long zxid, boolean fastForward) throws IOException
{    return new FileTxnIterator(logDir, zxid, fastForward);}
truncate
public booleanf2174_1long zxid) throws IOException
{    FileTxnIterator itr = null;    try {        itr = new FileTxnIterator(this.logDir, zxid);        PositionInputStream input = itr.inputStream;        if (input == null) {            throw new IOException("No log files found to truncate! This could " + "happen if you still have snapshots from an old setup or " + "log files were deleted accidentally or dataLogDir was changed in zoo.cfg.");        }        long pos = input.getPosition();                RandomAccessFile raf = new RandomAccessFile(itr.logFile, "rw");        raf.setLength(pos);        raf.close();        while (itr.goToNextLog()) {            if (!itr.logFile.delete()) {                            }        }    } finally {        close(itr);    }    return true;}
readHeader
private static FileHeaderf2175_1File file) throws IOException
{    InputStream is = null;    try {        is = new BufferedInputStream(new FileInputStream(file));        InputArchive ia = BinaryInputArchive.getArchive(is);        FileHeader hdr = new FileHeader();        hdr.deserialize(ia, "fileheader");        return hdr;    } finally {        try {            if (is != null) {                is.close();            }        } catch (IOException e) {                    }    }}
getDbId
public long zookeeper_f2176_0() throws IOException
{    FileTxnIterator itr = new FileTxnIterator(logDir, 0);    FileHeader fh = readHeader(itr.logFile);    itr.close();    if (fh == null) {        throw new IOException("Unsupported Format.");    }    return fh.getDbid();}
isForceSync
public boolean zookeeper_f2177_0()
{    return forceSync;}
read
public int zookeeper_f2178_0() throws IOException
{    int rc = super.read();    if (rc > -1) {        position++;    }    return rc;}
read
public int zookeeper_f2179_0(byte[] b) throws IOException
{    int rc = super.read(b);    if (rc > 0) {        position += rc;    }    return rc;}
read
public int zookeeper_f2180_0(byte[] b, int off, int len) throws IOException
{    int rc = super.read(b, off, len);    if (rc > 0) {        position += rc;    }    return rc;}
skip
public long zookeeper_f2181_0(long n) throws IOException
{    long rc = super.skip(n);    if (rc > 0) {        position += rc;    }    return rc;}
getPosition
public long zookeeper_f2182_0()
{    return position;}
markSupported
public boolean zookeeper_f2183_0()
{    return false;}
mark
public void zookeeper_f2184_0(int readLimit)
{    throw new UnsupportedOperationException("mark");}
reset
public void zookeeper_f2185_0()
{    throw new UnsupportedOperationException("reset");}
init
 void zookeeper_f2186_0() throws IOException
{    storedFiles = new ArrayList<>();    List<File> files = Util.sortDataDir(FileTxnLog.getLogFiles(logDir.listFiles(), 0), LOG_FILE_PREFIX, false);    for (File f : files) {        if (Util.getZxidFromName(f.getName(), LOG_FILE_PREFIX) >= zxid) {            storedFiles.add(f);        } else if (Util.getZxidFromName(f.getName(), LOG_FILE_PREFIX) < zxid) {                        storedFiles.add(f);            break;        }    }    goToNextLog();    next();}
getStorageSize
public long zookeeper_f2187_0()
{    long sum = 0;    for (File f : storedFiles) {        sum += f.length();    }    return sum;}
goToNextLog
private boolean zookeeper_f2188_0() throws IOException
{    if (storedFiles.size() > 0) {        this.logFile = storedFiles.remove(storedFiles.size() - 1);        ia = createInputArchive(this.logFile);        return true;    }    return false;}
inStreamCreated
protected void zookeeper_f2189_0(InputArchive ia, InputStream is) throws IOException
{    FileHeader header = new FileHeader();    header.deserialize(ia, "fileheader");    if (header.getMagic() != FileTxnLog.TXNLOG_MAGIC) {        throw new IOException("Transaction log: " + this.logFile + " has invalid magic number " + header.getMagic() + " != " + FileTxnLog.TXNLOG_MAGIC);    }}
createInputArchive
protected InputArchivef2190_1File logFile) throws IOException
{    if (inputStream == null) {        inputStream = new PositionInputStream(new BufferedInputStream(new FileInputStream(logFile)));                ia = BinaryInputArchive.getArchive(inputStream);        inStreamCreated(ia, inputStream);            }    return ia;}
makeChecksumAlgorithm
protected Checksum zookeeper_f2191_0()
{    return new Adler32();}
next
public booleanf2192_1) throws IOException
{    if (ia == null) {        return false;    }    try {        long crcValue = ia.readLong("crcvalue");        byte[] bytes = Util.readTxnBytes(ia);                if (bytes == null || bytes.length == 0) {            throw new EOFException("Failed to read " + logFile);        }                        Checksum crc = makeChecksumAlgorithm();        crc.update(bytes, 0, bytes.length);        if (crcValue != crc.getValue()) {            throw new IOException(CRC_ERROR);        }        hdr = new TxnHeader();        record = SerializeUtils.deserializeTxn(bytes, hdr);    } catch (EOFException e) {                inputStream.close();        inputStream = null;        ia = null;        hdr = null;                if (!goToNextLog()) {            return false;        }                return next();    } catch (IOException e) {        inputStream.close();        throw e;    }    return true;}
getHeader
public TxnHeader zookeeper_f2193_0()
{    return hdr;}
getTxn
public Record zookeeper_f2194_0()
{    return record;}
close
public void zookeeper_f2195_0() throws IOException
{    if (inputStream != null) {        inputStream.close();    }}
setServerStats
public void zookeeper_f2196_0(ServerStats serverStats)
{    txnLog.setServerStats(serverStats);}
checkLogDir
private void zookeeper_f2197_0() throws LogDirContentCheckException
{    File[] files = this.dataDir.listFiles(new FilenameFilter() {        @Override        public boolean accept(File dir, String name) {            return Util.isSnapshotFileName(name);        }    });    if (files != null && files.length > 0) {        throw new LogDirContentCheckException("Log directory has snapshot files. Check if dataLogDir and dataDir configuration is correct.");    }}
accept
public boolean zookeeper_f2198_0(File dir, String name)
{    return Util.isSnapshotFileName(name);}
checkSnapDir
private void zookeeper_f2199_0() throws SnapDirContentCheckException
{    File[] files = this.snapDir.listFiles(new FilenameFilter() {        @Override        public boolean accept(File dir, String name) {            return Util.isLogFileName(name);        }    });    if (files != null && files.length > 0) {        throw new SnapDirContentCheckException("Snapshot directory has log files. Check if dataLogDir and dataDir configuration is correct.");    }}
accept
public boolean zookeeper_f2200_0(File dir, String name)
{    return Util.isLogFileName(name);}
getDataDir
public File zookeeper_f2201_0()
{    return this.dataDir;}
getSnapDir
public File zookeeper_f2202_0()
{    return this.snapDir;}
getLastSnapshotInfo
public SnapshotInfo zookeeper_f2203_0()
{    return this.snapLog.getLastSnapshotInfo();}
restore
public longf2204_1DataTree dt, Map<Long, Integer> sessions, PlayBackListener listener) throws IOException
{    long snapLoadingStartTime = Time.currentElapsedTime();    long deserializeResult = snapLog.deserialize(dt, sessions);    ServerMetrics.getMetrics().STARTUP_SNAP_LOAD_TIME.add(Time.currentElapsedTime() - snapLoadingStartTime);    FileTxnLog txnLog = new FileTxnLog(dataDir);    boolean trustEmptyDB;    File initFile = new File(dataDir.getParent(), "initialize");    if (Files.deleteIfExists(initFile.toPath())) {                trustEmptyDB = true;    } else {        trustEmptyDB = autoCreateDB;    }    if (-1L == deserializeResult) {        /* this means that we couldn't find any snapshot, so we need to             * initialize an empty database (reported in ZOOKEEPER-2325) */        if (txnLog.getLastLoggedZxid() != -1) {                        if (!trustEmptySnapshot) {                throw new IOException(EMPTY_SNAPSHOT_WARNING + "Something is broken!");            } else {                            }        }        if (trustEmptyDB) {            /* TODO: (br33d) we should either put a ConcurrentHashMap on restore()                 *       or use Map on save() */            save(dt, (ConcurrentHashMap<Long, Integer>) sessions, false);            /* return a zxid of 0, since we know the database is empty */            return 0L;        } else {            /* return a zxid of -1, since we are possibly missing data */                        dt.lastProcessedZxid = -1L;            return -1L;        }    }    long highestZxid = fastForwardFromEdits(dt, sessions, listener);                    DataTree.ZxidDigest snapshotZxidDigest = dt.getDigestFromLoadedSnapshot();    if (snapshotZxidDigest != null) {            }    return highestZxid;}
fastForwardFromEdits
public longf2205_1DataTree dt, Map<Long, Integer> sessions, PlayBackListener listener) throws IOException
{    TxnIterator itr = txnLog.read(dt.lastProcessedZxid + 1);    long highestZxid = dt.lastProcessedZxid;    TxnHeader hdr;    int txnLoaded = 0;    long startTime = Time.currentElapsedTime();    try {        while (true) {                                    hdr = itr.getHeader();            if (hdr == null) {                                return dt.lastProcessedZxid;            }            if (hdr.getZxid() < highestZxid && highestZxid != 0) {                            } else {                highestZxid = hdr.getZxid();            }            try {                processTransaction(hdr, dt, sessions, itr.getTxn());                txnLoaded++;            } catch (KeeperException.NoNodeException e) {                throw new IOException("Failed to process transaction type: " + hdr.getType() + " error: " + e.getMessage(), e);            }            listener.onTxnLoaded(hdr, itr.getTxn());            if (!itr.next()) {                break;            }        }    } finally {        if (itr != null) {            itr.close();        }    }    long loadTime = Time.currentElapsedTime() - startTime;        ServerMetrics.getMetrics().STARTUP_TXNS_LOADED.add(txnLoaded);    ServerMetrics.getMetrics().STARTUP_TXNS_LOAD_TIME.add(loadTime);    return highestZxid;}
readTxnLog
public TxnIterator zookeeper_f2206_0(long zxid) throws IOException
{    return readTxnLog(zxid, true);}
readTxnLog
public TxnIterator zookeeper_f2207_0(long zxid, boolean fastForward) throws IOException
{    FileTxnLog txnLog = new FileTxnLog(dataDir);    return txnLog.read(zxid, fastForward);}
processTransaction
public voidf2208_1TxnHeader hdr, DataTree dt, Map<Long, Integer> sessions, Record txn) throws KeeperException.NoNodeException
{    ProcessTxnResult rc;    switch(hdr.getType()) {        case OpCode.createSession:            sessions.put(hdr.getClientId(), ((CreateSessionTxn) txn).getTimeOut());            if (LOG.isTraceEnabled()) {                ZooTrace.logTraceMessage(LOG, ZooTrace.SESSION_TRACE_MASK, "playLog --- create session in log: 0x" + Long.toHexString(hdr.getClientId()) + " with timeout: " + ((CreateSessionTxn) txn).getTimeOut());            }                        rc = dt.processTxn(hdr, txn);            break;        case OpCode.closeSession:            sessions.remove(hdr.getClientId());            if (LOG.isTraceEnabled()) {                ZooTrace.logTraceMessage(LOG, ZooTrace.SESSION_TRACE_MASK, "playLog --- close session in log: 0x" + Long.toHexString(hdr.getClientId()));            }            rc = dt.processTxn(hdr, txn);            break;        default:            rc = dt.processTxn(hdr, txn);    }    /*         * Snapshots are lazily created. So when a snapshot is in progress,         * there is a chance for later transactions to make into the         * snapshot. Then when the snapshot is restored, NONODE/NODEEXISTS         * errors could occur. It should be safe to ignore these.         */    if (rc.err != Code.OK.intValue()) {            }}
getLastLoggedZxid
public long zookeeper_f2209_0()
{    FileTxnLog txnLog = new FileTxnLog(dataDir);    return txnLog.getLastLoggedZxid();}
save
public voidf2210_1DataTree dataTree, ConcurrentHashMap<Long, Integer> sessionsWithTimeouts, boolean syncSnap) throws IOException
{    long lastZxid = dataTree.lastProcessedZxid;    File snapshotFile = new File(snapDir, Util.makeSnapshotName(lastZxid));        try {        snapLog.serialize(dataTree, sessionsWithTimeouts, snapshotFile, syncSnap);    } catch (IOException e) {        if (snapshotFile.length() == 0) {            /* This may be caused by a full disk. In such a case, the server                 * will get stuck in a loop where it tries to write a snapshot                 * out to disk, and ends up creating an empty file instead.                 * Doing so will eventually result in valid snapshots being                 * removed during cleanup. */            if (snapshotFile.delete()) {                            } else {                            }        } else {        /* Something else went wrong when writing the snapshot out to                 * disk. If this snapshot file is invalid, when restarting,                 * ZooKeeper will skip it, and find the last known good snapshot                 * instead. */        }        throw e;    }}
truncateLog
public boolean zookeeper_f2211_0(long zxid) throws IOException
{        close();        FileTxnLog truncLog = new FileTxnLog(dataDir);    boolean truncated = truncLog.truncate(zxid);    truncLog.close();                    txnLog = new FileTxnLog(dataDir);    snapLog = new FileSnap(snapDir);    return truncated;}
findMostRecentSnapshot
public File zookeeper_f2212_0() throws IOException
{    FileSnap snaplog = new FileSnap(snapDir);    return snaplog.findMostRecentSnapshot();}
findNRecentSnapshots
public List<File> zookeeper_f2213_0(int n) throws IOException
{    FileSnap snaplog = new FileSnap(snapDir);    return snaplog.findNRecentSnapshots(n);}
getSnapshotLogs
public File[] zookeeper_f2214_0(long zxid)
{    return FileTxnLog.getLogFiles(dataDir.listFiles(), zxid);}
append
public boolean zookeeper_f2215_0(Request si) throws IOException
{    return txnLog.append(si.getHdr(), si.getTxn());}
commit
public void zookeeper_f2216_0() throws IOException
{    txnLog.commit();}
getTxnLogElapsedSyncTime
public long zookeeper_f2217_0()
{    return txnLog.getTxnLogSyncElapsedTime();}
rollLog
public void zookeeper_f2218_0() throws IOException
{    txnLog.rollLog();}
close
public void zookeeper_f2219_0() throws IOException
{    txnLog.close();    snapLog.close();}
setTotalLogSize
public void zookeeper_f2220_0(long size)
{    txnLog.setTotalLogSize(size);}
getTotalLogSize
public long zookeeper_f2221_0()
{    return txnLog.getTotalLogSize();}
getName
public String zookeeper_f2222_0()
{    return name;}
getFileExtension
public String zookeeper_f2223_0()
{    return name.isEmpty() ? "" : "." + name;}
fromString
public static StreamMode zookeeper_f2224_0(String name)
{    for (StreamMode c : values()) {        if (c.getName().compareToIgnoreCase(name) == 0) {            return c;        }    }    return DEFAULT_MODE;}
getInputStream
public static CheckedInputStream zookeeper_f2225_0(File file) throws IOException
{    FileInputStream fis = new FileInputStream(file);    InputStream is;    switch(getStreamMode(file.getName())) {        case GZIP:            is = new GZIPInputStream(fis);            break;        case SNAPPY:            is = new SnappyInputStream(fis);            break;        case CHECKED:        default:            is = new BufferedInputStream(fis);    }    return new CheckedInputStream(is, new Adler32());}
getOutputStream
public static CheckedOutputStream zookeeper_f2226_0(File file) throws IOException
{    FileOutputStream fos = new FileOutputStream(file);    OutputStream os;    switch(streamMode) {        case GZIP:            os = new GZIPOutputStream(fos);            break;        case SNAPPY:            os = new SnappyOutputStream(fos);            break;        case CHECKED:        default:            os = new BufferedOutputStream(fos);    }    return new CheckedOutputStream(os, new Adler32());}
sealStream
public static void zookeeper_f2227_0(CheckedOutputStream os, OutputArchive oa) throws IOException
{    long val = os.getChecksum().getValue();    oa.writeLong(val, "val");    oa.writeString("/", "path");}
checkSealIntegrity
 static void zookeeper_f2228_0(CheckedInputStream is, InputArchive ia) throws IOException
{    long checkSum = is.getChecksum().getValue();    long val = ia.readLong("val");        ia.readString("path");    if (val != checkSum) {        throw new IOException("CRC corruption");    }}
isValidSnapshot
public static boolean zookeeper_f2229_0(File file) throws IOException
{    if (file == null || Util.getZxidFromName(file.getName(), FileSnap.SNAPSHOT_FILE_PREFIX) == -1) {        return false;    }    boolean isValid = false;    switch(getStreamMode(file.getName())) {        case GZIP:            isValid = isValidGZipStream(file);            break;        case SNAPPY:            isValid = isValidSnappyStream(file);            break;        case CHECKED:        default:            isValid = isValidCheckedStream(file);    }    return isValid;}
setStreamMode
public static void zookeeper_f2230_0(StreamMode mode)
{    streamMode = mode;}
getStreamMode
public static StreamMode zookeeper_f2231_0()
{    return streamMode;}
getStreamMode
public static StreamMode zookeeper_f2232_0(String fileName)
{    String[] splitSnapName = fileName.split("\\.");        if (splitSnapName.length > 1) {        String mode = splitSnapName[splitSnapName.length - 1];        return StreamMode.fromString(mode);    }    return StreamMode.CHECKED;}
isValidGZipStream
private static booleanf2233_1File f) throws IOException
{    byte[] byteArray = new byte[2];    try (FileInputStream fis = new FileInputStream(f)) {        if (2 != fis.read(byteArray, 0, 2)) {                        return false;        }        ByteBuffer bb = ByteBuffer.wrap(byteArray);        byte[] magicHeader = new byte[2];        bb.get(magicHeader, 0, 2);        int magic = magicHeader[0] & 0xff | ((magicHeader[1] << 8) & 0xff00);        return magic == GZIPInputStream.GZIP_MAGIC;    } catch (FileNotFoundException e) {                return false;    }}
isValidSnappyStream
private static booleanf2234_1File f) throws IOException
{    byte[] byteArray = new byte[SnappyCodec.MAGIC_LEN];    try (FileInputStream fis = new FileInputStream(f)) {        if (SnappyCodec.MAGIC_LEN != fis.read(byteArray, 0, SnappyCodec.MAGIC_LEN)) {                        return false;        }        ByteBuffer bb = ByteBuffer.wrap(byteArray);        byte[] magicHeader = new byte[SnappyCodec.MAGIC_LEN];        bb.get(magicHeader, 0, SnappyCodec.MAGIC_LEN);        return Arrays.equals(magicHeader, SnappyCodec.getMagicHeader());    } catch (FileNotFoundException e) {                return false;    }}
isValidCheckedStream
private static booleanf2235_1File f) throws IOException
{    try (RandomAccessFile raf = new RandomAccessFile(f, "r")) {                if (raf.length() < 10) {            return false;        }        raf.seek(raf.length() - 5);        byte[] bytes = new byte[5];        int readlen = 0;        int l;        while (readlen < 5 && (l = raf.read(bytes, readlen, bytes.length - readlen)) >= 0) {            readlen += l;        }        if (readlen != bytes.length) {                        return false;        }        ByteBuffer bb = ByteBuffer.wrap(bytes);        int len = bb.getInt();        byte b = bb.get();        if (len != 1 || b != '/') {                        return false;        }    }    return true;}
getExitCode
 int zookeeper_f2236_0()
{    return exitCode;}
getOptions
 Options zookeeper_f2237_0()
{    return options;}
main
public static void zookeeper_f2238_0(String[] args) throws Exception
{    try (final TxnLogToolkit lt = parseCommandLine(args)) {        if (lt.isDumpMode()) {            lt.dump(new Scanner(System.in));            lt.printStat();        } else {            lt.chop();        }    } catch (TxnLogToolkitParseException e) {        System.err.println(e.getMessage() + "\n");        printHelpAndExit(e.getExitCode(), e.getOptions());    } catch (TxnLogToolkitException e) {        System.err.println(e.getMessage());        System.exit(e.getExitCode());    }}
loadTxnFile
private File zookeeper_f2239_0(String txnLogFileName) throws TxnLogToolkitException
{    File logFile = new File(txnLogFileName);    if (!logFile.exists() || !logFile.canRead()) {        throw new TxnLogToolkitException(ExitCode.UNEXPECTED_ERROR.getValue(), "File doesn't exist or not readable: %s", logFile);    }    return logFile;}
dump
public void zookeeper_f2240_0(Scanner scanner) throws Exception
{    crcFixed = 0;    FileHeader fhdr = new FileHeader();    fhdr.deserialize(logStream, "fileheader");    if (fhdr.getMagic() != TXNLOG_MAGIC) {        throw new TxnLogToolkitException(ExitCode.INVALID_INVOCATION.getValue(), "Invalid magic number for %s", txnLogFile.getName());    }    System.out.println("ZooKeeper Transactional Log File with dbid " + fhdr.getDbid() + " txnlog format version " + fhdr.getVersion());    if (recoveryMode) {        fhdr.serialize(recoveryOa, "fileheader");        recoveryFos.flush();        filePadding.setCurrentSize(recoveryFos.getChannel().position());    }    int count = 0;    while (true) {        long crcValue;        byte[] bytes;        try {            crcValue = logStream.readLong("crcvalue");            bytes = logStream.readBuffer("txnEntry");        } catch (EOFException e) {            System.out.println("EOF reached after " + count + " txns.");            return;        }        if (bytes.length == 0) {                                    System.out.println("EOF reached after " + count + " txns.");            return;        }        Checksum crc = new Adler32();        crc.update(bytes, 0, bytes.length);        if (crcValue != crc.getValue()) {            if (recoveryMode) {                if (!force) {                    printTxn(bytes, "CRC ERROR");                    if (askForFix(scanner)) {                        crcValue = crc.getValue();                        ++crcFixed;                    }                } else {                    crcValue = crc.getValue();                    printTxn(bytes, "CRC FIXED");                    ++crcFixed;                }            } else {                printTxn(bytes, "CRC ERROR");            }        }        if (!recoveryMode || verbose) {            printTxn(bytes);        }        if (logStream.readByte("EOR") != 'B') {            throw new TxnLogToolkitException(ExitCode.UNEXPECTED_ERROR.getValue(), "Last transaction was partial.");        }        if (recoveryMode) {            filePadding.padFile(recoveryFos.getChannel());            recoveryOa.writeLong(crcValue, "crcvalue");            recoveryOa.writeBuffer(bytes, "txnEntry");            recoveryOa.writeByte((byte) 'B', "EOR");        }        count++;    }}
chop
public void zookeeper_f2241_0()
{    File targetFile = new File(txnLogFile.getParentFile(), txnLogFile.getName() + ".chopped" + zxid);    try (InputStream is = new BufferedInputStream(new FileInputStream(txnLogFile));        OutputStream os = new BufferedOutputStream(new FileOutputStream(targetFile))) {        if (!LogChopper.chop(is, os, zxid)) {            throw new TxnLogToolkitException(ExitCode.INVALID_INVOCATION.getValue(), "Failed to chop %s", txnLogFile.getName());        }    } catch (Exception e) {        System.out.println("Got exception: " + e.getMessage());    }}
isDumpMode
public boolean zookeeper_f2242_0()
{    return zxid < 0;}
askForFix
private boolean zookeeper_f2243_0(Scanner scanner) throws TxnLogToolkitException
{    while (true) {        System.out.print("Would you like to fix it (Yes/No/Abort) ? ");        char answer = Character.toUpperCase(scanner.next().charAt(0));        switch(answer) {            case 'Y':                return true;            case 'N':                return false;            case 'A':                throw new TxnLogToolkitException(ExitCode.EXECUTION_FINISHED.getValue(), "Recovery aborted.");        }    }}
printTxn
private void zookeeper_f2244_0(byte[] bytes) throws IOException
{    printTxn(bytes, "");}
printTxn
private void zookeeper_f2245_0(byte[] bytes, String prefix) throws IOException
{    TxnHeader hdr = new TxnHeader();    Record txn = SerializeUtils.deserializeTxn(bytes, hdr);    String txnStr = getFormattedTxnStr(txn);    String txns = String.format("%s session 0x%s cxid 0x%s zxid 0x%s %s %s", DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.LONG).format(new Date(hdr.getTime())), Long.toHexString(hdr.getClientId()), Long.toHexString(hdr.getCxid()), Long.toHexString(hdr.getZxid()), Request.op2String(hdr.getType()), txnStr);    if (prefix != null && !"".equals(prefix.trim())) {        System.out.print(prefix + " - ");    }    if (txns.endsWith("\n")) {        System.out.print(txns);    } else {        System.out.println(txns);    }}
getFormattedTxnStr
private static String zookeeper_f2246_0(Record txn) throws IOException
{    StringBuilder txnData = new StringBuilder();    if (txn == null) {        return txnData.toString();    }    if (txn instanceof CreateTxn) {        CreateTxn createTxn = ((CreateTxn) txn);        txnData.append(createTxn.getPath() + "," + checkNullToEmpty(createTxn.getData())).append("," + createTxn.getAcl() + "," + createTxn.getEphemeral()).append("," + createTxn.getParentCVersion());    } else if (txn instanceof SetDataTxn) {        SetDataTxn setDataTxn = ((SetDataTxn) txn);        txnData.append(setDataTxn.getPath() + "," + checkNullToEmpty(setDataTxn.getData())).append("," + setDataTxn.getVersion());    } else if (txn instanceof CreateContainerTxn) {        CreateContainerTxn createContainerTxn = ((CreateContainerTxn) txn);        txnData.append(createContainerTxn.getPath() + "," + checkNullToEmpty(createContainerTxn.getData())).append("," + createContainerTxn.getAcl() + "," + createContainerTxn.getParentCVersion());    } else if (txn instanceof CreateTTLTxn) {        CreateTTLTxn createTTLTxn = ((CreateTTLTxn) txn);        txnData.append(createTTLTxn.getPath() + "," + checkNullToEmpty(createTTLTxn.getData())).append("," + createTTLTxn.getAcl() + "," + createTTLTxn.getParentCVersion()).append("," + createTTLTxn.getTtl());    } else if (txn instanceof MultiTxn) {        MultiTxn multiTxn = ((MultiTxn) txn);        List<Txn> txnList = multiTxn.getTxns();        for (int i = 0; i < txnList.size(); i++) {            Txn t = txnList.get(i);            if (i == 0) {                txnData.append(Request.op2String(t.getType()) + ":" + checkNullToEmpty(t.getData()));            } else {                txnData.append(";" + Request.op2String(t.getType()) + ":" + checkNullToEmpty(t.getData()));            }        }    } else {        txnData.append(txn.toString());    }    return txnData.toString();}
checkNullToEmpty
private static String zookeeper_f2247_0(byte[] data) throws IOException
{    if (data == null || data.length == 0) {        return "";    }    return new String(data, StandardCharsets.UTF_8);}
openTxnLogFile
private void zookeeper_f2248_0() throws FileNotFoundException
{    txnFis = new FileInputStream(txnLogFile);    logStream = BinaryInputArchive.getArchive(txnFis);}
closeTxnLogFile
private void zookeeper_f2249_0() throws IOException
{    if (txnFis != null) {        txnFis.close();    }}
openRecoveryFile
private void zookeeper_f2250_0() throws FileNotFoundException
{    recoveryFos = new FileOutputStream(recoveryLogFile);    recoveryOa = BinaryOutputArchive.getArchive(recoveryFos);}
closeRecoveryFile
private void zookeeper_f2251_0() throws IOException
{    if (recoveryFos != null) {        recoveryFos.close();    }}
parseCommandLine
private static TxnLogToolkit zookeeper_f2252_0(String[] args) throws TxnLogToolkitException, FileNotFoundException
{    CommandLineParser parser = new PosixParser();    Options options = new Options();    Option helpOpt = new Option("h", "help", false, "Print help message");    options.addOption(helpOpt);    Option recoverOpt = new Option("r", "recover", false, "Recovery mode. Re-calculate CRC for broken entries.");    options.addOption(recoverOpt);    Option quietOpt = new Option("v", "verbose", false, "Be verbose in recovery mode: print all entries, not just fixed ones.");    options.addOption(quietOpt);    Option dumpOpt = new Option("d", "dump", false, "Dump mode. Dump all entries of the log file with printing the content of a nodepath (default)");    options.addOption(dumpOpt);    Option forceOpt = new Option("y", "yes", false, "Non-interactive mode: repair all CRC errors without asking");    options.addOption(forceOpt);        Option chopOpt = new Option("c", "chop", false, "Chop mode. Chop txn file to a zxid.");    Option zxidOpt = new Option("z", "zxid", true, "Used with chop. Zxid to which to chop.");    options.addOption(chopOpt);    options.addOption(zxidOpt);    try {        CommandLine cli = parser.parse(options, args);        if (cli.hasOption("help")) {            printHelpAndExit(0, options);        }        if (cli.getArgs().length < 1) {            printHelpAndExit(1, options);        }        if (cli.hasOption("chop") && cli.hasOption("zxid")) {            return new TxnLogToolkit(cli.getArgs()[0], cli.getOptionValue("zxid"));        }        return new TxnLogToolkit(cli.hasOption("recover"), cli.hasOption("verbose"), cli.getArgs()[0], cli.hasOption("yes"));    } catch (ParseException e) {        throw new TxnLogToolkitParseException(options, ExitCode.UNEXPECTED_ERROR.getValue(), e.getMessage());    }}
printHelpAndExit
private static void zookeeper_f2253_0(int exitCode, Options options)
{    HelpFormatter help = new HelpFormatter();    help.printHelp(120, "TxnLogToolkit [-dhrvc] <txn_log_file_name> (-z <zxid>)", "", options, "");    System.exit(exitCode);}
printStat
private void zookeeper_f2254_0()
{    if (recoveryMode) {        System.out.printf("Recovery file %s has been written with %d fixed CRC error(s)%n", recoveryLogFile, crcFixed);    }}
close
public void zookeeper_f2255_0() throws IOException
{    if (recoveryMode) {        closeRecoveryFile();    }    closeTxnLogFile();}
makeURIString
public static String zookeeper_f2256_0(String dataDir, String dataLogDir, String convPolicy)
{    String uri = "file:" + SNAP_DIR + "=" + dataDir + ";" + LOG_DIR + "=" + dataLogDir;    if (convPolicy != null) {        uri += ";" + DB_FORMAT_CONV + "=" + convPolicy;    }    return uri.replace('\\', '/');}
makeFileLoggerURL
public static URI zookeeper_f2257_0(File dataDir, File dataLogDir)
{    return URI.create(makeURIString(dataDir.getPath(), dataLogDir.getPath(), null));}
makeFileLoggerURL
public static URI zookeeper_f2258_0(File dataDir, File dataLogDir, String convPolicy)
{    return URI.create(makeURIString(dataDir.getPath(), dataLogDir.getPath(), convPolicy));}
makeLogName
public static String zookeeper_f2259_0(long zxid)
{    return FileTxnLog.LOG_FILE_PREFIX + "." + Long.toHexString(zxid);}
makeSnapshotName
public static String zookeeper_f2260_0(long zxid)
{    return FileSnap.SNAPSHOT_FILE_PREFIX + "." + Long.toHexString(zxid) + SnapStream.getStreamMode().getFileExtension();}
getSnapDir
public static File zookeeper_f2261_0(Properties props)
{    return new File(props.getProperty(SNAP_DIR));}
getLogDir
public static File zookeeper_f2262_0(Properties props)
{    return new File(props.getProperty(LOG_DIR));}
getFormatConversionPolicy
public static String zookeeper_f2263_0(Properties props)
{    return props.getProperty(DB_FORMAT_CONV);}
getZxidFromName
public static long zookeeper_f2264_0(String name, String prefix)
{    long zxid = -1;    String[] nameParts = name.split("\\.");    if (nameParts.length >= 2 && nameParts[0].equals(prefix)) {        try {            zxid = Long.parseLong(nameParts[1], 16);        } catch (NumberFormatException e) {        }    }    return zxid;}
readTxnBytes
public static byte[]f2265_1InputArchive ia) throws IOException
{    try {        byte[] bytes = ia.readBuffer("txtEntry");                if (bytes.length == 0) {            return bytes;        }        if (ia.readByte("EOF") != 'B') {                        return null;        }        return bytes;    } catch (EOFException e) {    }    return null;}
marshallTxnEntry
public static byte[] zookeeper_f2266_0(TxnHeader hdr, Record txn) throws IOException
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    OutputArchive boa = BinaryOutputArchive.getArchive(baos);    hdr.serialize(boa, "hdr");    if (txn != null) {        txn.serialize(boa, "txn");    }    return baos.toByteArray();}
writeTxnBytes
public static void zookeeper_f2267_0(OutputArchive oa, byte[] bytes) throws IOException
{    oa.writeBuffer(bytes, "txnEntry");        oa.writeByte((byte) 0x42, "EOR");}
compare
public int zookeeper_f2268_0(File o1, File o2)
{    long z1 = Util.getZxidFromName(o1.getName(), prefix);    long z2 = Util.getZxidFromName(o2.getName(), prefix);    int result = z1 < z2 ? -1 : (z1 > z2 ? 1 : 0);    return ascending ? result : -result;}
sortDataDir
public static List<File> zookeeper_f2269_0(File[] files, String prefix, boolean ascending)
{    if (files == null) {        return new ArrayList<File>(0);    }    List<File> filelist = Arrays.asList(files);    Collections.sort(filelist, new DataDirFileComparator(prefix, ascending));    return filelist;}
isLogFileName
public static boolean zookeeper_f2270_0(String fileName)
{    return fileName.startsWith(FileTxnLog.LOG_FILE_PREFIX + ".");}
isSnapshotFileName
public static boolean zookeeper_f2271_0(String fileName)
{    return fileName.startsWith(FileSnap.SNAPSHOT_FILE_PREFIX + ".");}
setFailCreate
public static void zookeeper_f2272_0(boolean b)
{    failCreate = b;}
run
public voidf2273_1)
{    try {        while (true) {            ServerMetrics.getMetrics().PREP_PROCESSOR_QUEUE_SIZE.add(submittedRequests.size());            Request request = submittedRequests.take();            ServerMetrics.getMetrics().PREP_PROCESSOR_QUEUE_TIME.add(Time.currentElapsedTime() - request.prepQueueStartTime);            long traceMask = ZooTrace.CLIENT_REQUEST_TRACE_MASK;            if (request.type == OpCode.ping) {                traceMask = ZooTrace.CLIENT_PING_TRACE_MASK;            }            if (LOG.isTraceEnabled()) {                ZooTrace.logRequest(LOG, traceMask, 'P', request, "");            }            if (Request.requestOfDeath == request) {                break;            }            request.prepStartTime = Time.currentElapsedTime();            pRequest(request);        }    } catch (RequestProcessorException e) {        if (e.getCause() instanceof XidRolloverException) {                    }        handleException(this.getName(), e);    } catch (Exception e) {        handleException(this.getName(), e);    }    }
getRecordForPath
private ChangeRecord zookeeper_f2274_0(String path) throws KeeperException.NoNodeException
{    ChangeRecord lastChange = null;    synchronized (zks.outstandingChanges) {        lastChange = zks.outstandingChangesForPath.get(path);        if (lastChange == null) {            DataNode n = zks.getZKDatabase().getNode(path);            if (n != null) {                Set<String> children;                synchronized (n) {                    children = n.getChildren();                }                lastChange = new ChangeRecord(-1, path, n.stat, children.size(), zks.getZKDatabase().aclForNode(n));            }        }    }    if (lastChange == null || lastChange.stat == null) {        throw new KeeperException.NoNodeException(path);    }    return lastChange;}
getOutstandingChange
private ChangeRecord zookeeper_f2275_0(String path)
{    synchronized (zks.outstandingChanges) {        return zks.outstandingChangesForPath.get(path);    }}
addChangeRecord
protected void zookeeper_f2276_0(ChangeRecord c)
{    synchronized (zks.outstandingChanges) {        zks.outstandingChanges.add(c);        zks.outstandingChangesForPath.put(c.path, c);        ServerMetrics.getMetrics().OUTSTANDING_CHANGES_QUEUED.add(1);    }}
getPendingChanges
private Map<String, ChangeRecord> zookeeper_f2277_0(MultiOperationRecord multiRequest)
{    Map<String, ChangeRecord> pendingChangeRecords = new HashMap<String, ChangeRecord>();    for (Op op : multiRequest) {        String path = op.getPath();        ChangeRecord cr = getOutstandingChange(path);                if (cr != null) {            pendingChangeRecords.put(path, cr);        }        /*             * ZOOKEEPER-1624 - We need to store for parent's ChangeRecord             * of the parent node of a request. So that if this is a             * sequential node creation request, rollbackPendingChanges()             * can restore previous parent's ChangeRecord correctly.             *             * Otherwise, sequential node name generation will be incorrect             * for a subsequent request.             */        int lastSlash = path.lastIndexOf('/');        if (lastSlash == -1 || path.indexOf('\0') != -1) {            continue;        }        String parentPath = path.substring(0, lastSlash);        ChangeRecord parentCr = getOutstandingChange(parentPath);        if (parentCr != null) {            pendingChangeRecords.put(parentPath, parentCr);        }    }    return pendingChangeRecords;}
rollbackPendingChanges
 void zookeeper_f2278_0(long zxid, Map<String, ChangeRecord> pendingChangeRecords)
{    synchronized (zks.outstandingChanges) {                Iterator<ChangeRecord> iter = zks.outstandingChanges.descendingIterator();        while (iter.hasNext()) {            ChangeRecord c = iter.next();            if (c.zxid == zxid) {                iter.remove();                                                zks.outstandingChangesForPath.remove(c.path);            } else {                break;            }        }                if (zks.outstandingChanges.isEmpty()) {            return;        }        long firstZxid = zks.outstandingChanges.peek().zxid;        for (ChangeRecord c : pendingChangeRecords.values()) {                        if (c.zxid < firstZxid) {                continue;            }                        zks.outstandingChangesForPath.put(c.path, c);        }    }}
validatePathForCreate
private Stringf2279_1String path, long sessionId) throws BadArgumentsException
{    int lastSlash = path.lastIndexOf('/');    if (lastSlash == -1 || path.indexOf('\0') != -1 || failCreate) {                throw new KeeperException.BadArgumentsException(path);    }    return path.substring(0, lastSlash);}
pRequest2Txn
protected voidf2280_1int type, long zxid, Request request, Record record, boolean deserialize) throws KeeperException, IOException, RequestProcessorException
{    request.setHdr(new TxnHeader(request.sessionId, request.cxid, zxid, Time.currentWallTime(), type));    switch(type) {        case OpCode.create:        case OpCode.create2:        case OpCode.createTTL:        case OpCode.createContainer:            {                pRequest2TxnCreate(type, request, record, deserialize);                break;            }        case OpCode.deleteContainer:            {                String path = new String(request.request.array());                String parentPath = getParentPathAndValidate(path);                ChangeRecord nodeRecord = getRecordForPath(path);                if (nodeRecord.childCount > 0) {                    throw new KeeperException.NotEmptyException(path);                }                if (EphemeralType.get(nodeRecord.stat.getEphemeralOwner()) == EphemeralType.NORMAL) {                    throw new KeeperException.BadVersionException(path);                }                ChangeRecord parentRecord = getRecordForPath(parentPath);                request.setTxn(new DeleteTxn(path));                parentRecord = parentRecord.duplicate(request.getHdr().getZxid());                parentRecord.childCount--;                addChangeRecord(parentRecord);                addChangeRecord(new ChangeRecord(request.getHdr().getZxid(), path, null, -1, null));                break;            }        case OpCode.delete:            zks.sessionTracker.checkSession(request.sessionId, request.getOwner());            DeleteRequest deleteRequest = (DeleteRequest) record;            if (deserialize) {                ByteBufferInputStream.byteBuffer2Record(request.request, deleteRequest);            }            String path = deleteRequest.getPath();            String parentPath = getParentPathAndValidate(path);            ChangeRecord parentRecord = getRecordForPath(parentPath);            zks.checkACL(request.cnxn, parentRecord.acl, ZooDefs.Perms.DELETE, request.authInfo, path, null);            ChangeRecord nodeRecord = getRecordForPath(path);            checkAndIncVersion(nodeRecord.stat.getVersion(), deleteRequest.getVersion(), path);            if (nodeRecord.childCount > 0) {                throw new KeeperException.NotEmptyException(path);            }            request.setTxn(new DeleteTxn(path));            parentRecord = parentRecord.duplicate(request.getHdr().getZxid());            parentRecord.childCount--;            addChangeRecord(parentRecord);            addChangeRecord(new ChangeRecord(request.getHdr().getZxid(), path, null, -1, null));            break;        case OpCode.setData:            zks.sessionTracker.checkSession(request.sessionId, request.getOwner());            SetDataRequest setDataRequest = (SetDataRequest) record;            if (deserialize) {                ByteBufferInputStream.byteBuffer2Record(request.request, setDataRequest);            }            path = setDataRequest.getPath();            validatePath(path, request.sessionId);            nodeRecord = getRecordForPath(path);            zks.checkACL(request.cnxn, nodeRecord.acl, ZooDefs.Perms.WRITE, request.authInfo, path, null);            int newVersion = checkAndIncVersion(nodeRecord.stat.getVersion(), setDataRequest.getVersion(), path);            request.setTxn(new SetDataTxn(path, setDataRequest.getData(), newVersion));            nodeRecord = nodeRecord.duplicate(request.getHdr().getZxid());            nodeRecord.stat.setVersion(newVersion);            addChangeRecord(nodeRecord);            break;        case OpCode.reconfig:            if (!QuorumPeerConfig.isReconfigEnabled()) {                                throw new KeeperException.ReconfigDisabledException();            }            if (ZooKeeperServer.skipACL) {                            }            zks.sessionTracker.checkSession(request.sessionId, request.getOwner());            LeaderZooKeeperServer lzks;            try {                lzks = (LeaderZooKeeperServer) zks;            } catch (ClassCastException e) {                                throw new KeeperException.UnimplementedException();            }            QuorumVerifier lastSeenQV = lzks.self.getLastSeenQuorumVerifier();                        if (lastSeenQV.getVersion() != lzks.self.getQuorumVerifier().getVersion()) {                throw new KeeperException.ReconfigInProgress();            }            ReconfigRequest reconfigRequest = (ReconfigRequest) record;            long configId = reconfigRequest.getCurConfigId();            if (configId != -1 && configId != lzks.self.getLastSeenQuorumVerifier().getVersion()) {                String msg = "Reconfiguration from version " + configId + " failed -- last seen version is " + lzks.self.getLastSeenQuorumVerifier().getVersion();                throw new KeeperException.BadVersionException(msg);            }            String newMembers = reconfigRequest.getNewMembers();            if (newMembers != null) {                                                                newMembers = newMembers.replaceAll(",", "\n");                try {                    Properties props = new Properties();                    props.load(new StringReader(newMembers));                    request.qv = QuorumPeerConfig.parseDynamicConfig(props, lzks.self.getElectionType(), true, false);                    request.qv.setVersion(request.getHdr().getZxid());                } catch (IOException | ConfigException e) {                    throw new KeeperException.BadArgumentsException(e.getMessage());                }            } else {                                                List<String> joiningServers = null;                String joiningServersString = reconfigRequest.getJoiningServers();                if (joiningServersString != null) {                    joiningServers = StringUtils.split(joiningServersString, ",");                }                List<String> leavingServers = null;                String leavingServersString = reconfigRequest.getLeavingServers();                if (leavingServersString != null) {                    leavingServers = StringUtils.split(leavingServersString, ",");                }                if (!(lastSeenQV instanceof QuorumMaj)) {                    String msg = "Incremental reconfiguration requested but last configuration seen has a non-majority quorum system";                                        throw new KeeperException.BadArgumentsException(msg);                }                Map<Long, QuorumServer> nextServers = new HashMap<Long, QuorumServer>(lastSeenQV.getAllMembers());                try {                    if (leavingServers != null) {                        for (String leaving : leavingServers) {                            long sid = Long.parseLong(leaving);                            nextServers.remove(sid);                        }                    }                    if (joiningServers != null) {                        for (String joiner : joiningServers) {                                                        String[] parts = StringUtils.split(joiner, "=").toArray(new String[0]);                            if (parts.length != 2) {                                throw new KeeperException.BadArgumentsException("Wrong format of server string");                            }                                                        Long sid = Long.parseLong(parts[0].substring(parts[0].lastIndexOf('.') + 1));                            QuorumServer qs = new QuorumServer(sid, parts[1]);                            if (qs.clientAddr == null || qs.electionAddr == null || qs.addr == null) {                                throw new KeeperException.BadArgumentsException("Wrong format of server string - each server should have 3 ports specified");                            }                                                        for (QuorumServer nqs : nextServers.values()) {                                if (qs.id == nqs.id) {                                    continue;                                }                                qs.checkAddressDuplicate(nqs);                            }                            nextServers.remove(qs.id);                            nextServers.put(qs.id, qs);                        }                    }                } catch (ConfigException e) {                    throw new KeeperException.BadArgumentsException("Reconfiguration failed");                }                request.qv = new QuorumMaj(nextServers);                request.qv.setVersion(request.getHdr().getZxid());            }            if (QuorumPeerConfig.isStandaloneEnabled() && request.qv.getVotingMembers().size() < 2) {                String msg = "Reconfig failed - new configuration must include at least 2 followers";                                throw new KeeperException.BadArgumentsException(msg);            } else if (request.qv.getVotingMembers().size() < 1) {                String msg = "Reconfig failed - new configuration must include at least 1 follower";                                throw new KeeperException.BadArgumentsException(msg);            }            if (!lzks.getLeader().isQuorumSynced(request.qv)) {                String msg2 = "Reconfig failed - there must be a connected and synced quorum in new configuration";                                throw new KeeperException.NewConfigNoQuorum();            }            nodeRecord = getRecordForPath(ZooDefs.CONFIG_NODE);            zks.checkACL(request.cnxn, nodeRecord.acl, ZooDefs.Perms.WRITE, request.authInfo, null, null);            request.setTxn(new SetDataTxn(ZooDefs.CONFIG_NODE, request.qv.toString().getBytes(), -1));            nodeRecord = nodeRecord.duplicate(request.getHdr().getZxid());            nodeRecord.stat.setVersion(-1);            addChangeRecord(nodeRecord);            break;        case OpCode.setACL:            zks.sessionTracker.checkSession(request.sessionId, request.getOwner());            SetACLRequest setAclRequest = (SetACLRequest) record;            if (deserialize) {                ByteBufferInputStream.byteBuffer2Record(request.request, setAclRequest);            }            path = setAclRequest.getPath();            validatePath(path, request.sessionId);            List<ACL> listACL = fixupACL(path, request.authInfo, setAclRequest.getAcl());            nodeRecord = getRecordForPath(path);            zks.checkACL(request.cnxn, nodeRecord.acl, ZooDefs.Perms.ADMIN, request.authInfo, path, listACL);            newVersion = checkAndIncVersion(nodeRecord.stat.getAversion(), setAclRequest.getVersion(), path);            request.setTxn(new SetACLTxn(path, listACL, newVersion));            nodeRecord = nodeRecord.duplicate(request.getHdr().getZxid());            nodeRecord.stat.setAversion(newVersion);            addChangeRecord(nodeRecord);            break;        case OpCode.createSession:            request.request.rewind();            int to = request.request.getInt();            request.setTxn(new CreateSessionTxn(to));            request.request.rewind();                        zks.sessionTracker.trackSession(request.sessionId, to);            zks.setOwner(request.sessionId, request.getOwner());            break;        case OpCode.closeSession:                                                            long startTime = Time.currentElapsedTime();            synchronized (zks.outstandingChanges) {                                                                                Set<String> es = zks.getZKDatabase().getEphemerals(request.sessionId);                for (ChangeRecord c : zks.outstandingChanges) {                    if (c.stat == null) {                                                es.remove(c.path);                    } else if (c.stat.getEphemeralOwner() == request.sessionId) {                        es.add(c.path);                    }                }                for (String path2Delete : es) {                    addChangeRecord(new ChangeRecord(request.getHdr().getZxid(), path2Delete, null, 0, null));                }                if (ZooKeeperServer.isCloseSessionTxnEnabled()) {                    request.setTxn(new CloseSessionTxn(new ArrayList<String>(es)));                }                zks.sessionTracker.setSessionClosing(request.sessionId);            }            ServerMetrics.getMetrics().CLOSE_SESSION_PREP_TIME.add(Time.currentElapsedTime() - startTime);            break;        case OpCode.check:            zks.sessionTracker.checkSession(request.sessionId, request.getOwner());            CheckVersionRequest checkVersionRequest = (CheckVersionRequest) record;            if (deserialize) {                ByteBufferInputStream.byteBuffer2Record(request.request, checkVersionRequest);            }            path = checkVersionRequest.getPath();            validatePath(path, request.sessionId);            nodeRecord = getRecordForPath(path);            zks.checkACL(request.cnxn, nodeRecord.acl, ZooDefs.Perms.READ, request.authInfo, path, null);            request.setTxn(new CheckVersionTxn(path, checkAndIncVersion(nodeRecord.stat.getVersion(), checkVersionRequest.getVersion(), path)));            break;        default:                        break;    }}
pRequest2TxnCreate
private void zookeeper_f2281_0(int type, Request request, Record record, boolean deserialize) throws IOException, KeeperException
{    if (deserialize) {        ByteBufferInputStream.byteBuffer2Record(request.request, record);    }    int flags;    String path;    List<ACL> acl;    byte[] data;    long ttl;    if (type == OpCode.createTTL) {        CreateTTLRequest createTtlRequest = (CreateTTLRequest) record;        flags = createTtlRequest.getFlags();        path = createTtlRequest.getPath();        acl = createTtlRequest.getAcl();        data = createTtlRequest.getData();        ttl = createTtlRequest.getTtl();    } else {        CreateRequest createRequest = (CreateRequest) record;        flags = createRequest.getFlags();        path = createRequest.getPath();        acl = createRequest.getAcl();        data = createRequest.getData();        ttl = -1;    }    CreateMode createMode = CreateMode.fromFlag(flags);    validateCreateRequest(path, createMode, request, ttl);    String parentPath = validatePathForCreate(path, request.sessionId);    List<ACL> listACL = fixupACL(path, request.authInfo, acl);    ChangeRecord parentRecord = getRecordForPath(parentPath);    zks.checkACL(request.cnxn, parentRecord.acl, ZooDefs.Perms.CREATE, request.authInfo, path, listACL);    int parentCVersion = parentRecord.stat.getCversion();    if (createMode.isSequential()) {        path = path + String.format(Locale.ENGLISH, "%010d", parentCVersion);    }    validatePath(path, request.sessionId);    try {        if (getRecordForPath(path) != null) {            throw new KeeperException.NodeExistsException(path);        }    } catch (KeeperException.NoNodeException e) {        }    boolean ephemeralParent = EphemeralType.get(parentRecord.stat.getEphemeralOwner()) == EphemeralType.NORMAL;    if (ephemeralParent) {        throw new KeeperException.NoChildrenForEphemeralsException(path);    }    int newCversion = parentRecord.stat.getCversion() + 1;    if (type == OpCode.createContainer) {        request.setTxn(new CreateContainerTxn(path, data, listACL, newCversion));    } else if (type == OpCode.createTTL) {        request.setTxn(new CreateTTLTxn(path, data, listACL, newCversion, ttl));    } else {        request.setTxn(new CreateTxn(path, data, listACL, createMode.isEphemeral(), newCversion));    }    StatPersisted s = new StatPersisted();    if (createMode.isEphemeral()) {        s.setEphemeralOwner(request.sessionId);    }    parentRecord = parentRecord.duplicate(request.getHdr().getZxid());    parentRecord.childCount++;    parentRecord.stat.setCversion(newCversion);    addChangeRecord(parentRecord);    addChangeRecord(new ChangeRecord(request.getHdr().getZxid(), path, s, 0, listACL));}
validatePath
private voidf2282_1String path, long sessionId) throws BadArgumentsException
{    try {        PathUtils.validatePath(path);    } catch (IllegalArgumentException ie) {                throw new BadArgumentsException(path);    }}
getParentPathAndValidate
private String zookeeper_f2283_0(String path) throws BadArgumentsException
{    int lastSlash = path.lastIndexOf('/');    if (lastSlash == -1 || path.indexOf('\0') != -1 || zks.getZKDatabase().isSpecialPath(path)) {        throw new BadArgumentsException(path);    }    return path.substring(0, lastSlash);}
checkAndIncVersion
private static int zookeeper_f2284_0(int currentVersion, int expectedVersion, String path) throws KeeperException.BadVersionException
{    if (expectedVersion != -1 && expectedVersion != currentVersion) {        throw new KeeperException.BadVersionException(path);    }    return currentVersion + 1;}
pRequest
protected voidf2285_1Request request) throws RequestProcessorException
{            request.setHdr(null);    request.setTxn(null);    try {        switch(request.type) {            case OpCode.createContainer:            case OpCode.create:            case OpCode.create2:                CreateRequest create2Request = new CreateRequest();                pRequest2Txn(request.type, zks.getNextZxid(), request, create2Request, true);                break;            case OpCode.createTTL:                CreateTTLRequest createTtlRequest = new CreateTTLRequest();                pRequest2Txn(request.type, zks.getNextZxid(), request, createTtlRequest, true);                break;            case OpCode.deleteContainer:            case OpCode.delete:                DeleteRequest deleteRequest = new DeleteRequest();                pRequest2Txn(request.type, zks.getNextZxid(), request, deleteRequest, true);                break;            case OpCode.setData:                SetDataRequest setDataRequest = new SetDataRequest();                pRequest2Txn(request.type, zks.getNextZxid(), request, setDataRequest, true);                break;            case OpCode.reconfig:                ReconfigRequest reconfigRequest = new ReconfigRequest();                ByteBufferInputStream.byteBuffer2Record(request.request, reconfigRequest);                pRequest2Txn(request.type, zks.getNextZxid(), request, reconfigRequest, true);                break;            case OpCode.setACL:                SetACLRequest setAclRequest = new SetACLRequest();                pRequest2Txn(request.type, zks.getNextZxid(), request, setAclRequest, true);                break;            case OpCode.check:                CheckVersionRequest checkRequest = new CheckVersionRequest();                pRequest2Txn(request.type, zks.getNextZxid(), request, checkRequest, true);                break;            case OpCode.multi:                MultiOperationRecord multiRequest = new MultiOperationRecord();                try {                    ByteBufferInputStream.byteBuffer2Record(request.request, multiRequest);                } catch (IOException e) {                    request.setHdr(new TxnHeader(request.sessionId, request.cxid, zks.getNextZxid(), Time.currentWallTime(), OpCode.multi));                    throw e;                }                List<Txn> txns = new ArrayList<Txn>();                                long zxid = zks.getNextZxid();                KeeperException ke = null;                                Map<String, ChangeRecord> pendingChanges = getPendingChanges(multiRequest);                for (Op op : multiRequest) {                    Record subrequest = op.toRequestRecord();                    int type;                    Record txn;                    /* If we've already failed one of the ops, don't bother                     * trying the rest as we know it's going to fail and it                     * would be confusing in the logfiles.                     */                    if (ke != null) {                        type = OpCode.error;                        txn = new ErrorTxn(Code.RUNTIMEINCONSISTENCY.intValue());                    } else {                        /* Prep the request and convert to a Txn */                        try {                            pRequest2Txn(op.getType(), zxid, request, subrequest, false);                            type = request.getHdr().getType();                            txn = request.getTxn();                        } catch (KeeperException e) {                            ke = e;                            type = OpCode.error;                            txn = new ErrorTxn(e.code().intValue());                            if (e.code().intValue() > Code.APIERROR.intValue()) {                                                            }                            request.setException(e);                            /* Rollback change records from failed multi-op */                            rollbackPendingChanges(zxid, pendingChanges);                        }                    }                                        try (ByteArrayOutputStream baos = new ByteArrayOutputStream()) {                        BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos);                        txn.serialize(boa, "request");                        ByteBuffer bb = ByteBuffer.wrap(baos.toByteArray());                        txns.add(new Txn(type, bb.array()));                    }                }                request.setHdr(new TxnHeader(request.sessionId, request.cxid, zxid, Time.currentWallTime(), request.type));                request.setTxn(new MultiTxn(txns));                break;                        case OpCode.createSession:            case OpCode.closeSession:                if (!request.isLocalSession()) {                    pRequest2Txn(request.type, zks.getNextZxid(), request, null, true);                }                break;                        case OpCode.sync:            case OpCode.exists:            case OpCode.getData:            case OpCode.getACL:            case OpCode.getChildren:            case OpCode.getAllChildrenNumber:            case OpCode.getChildren2:            case OpCode.ping:            case OpCode.setWatches:            case OpCode.checkWatches:            case OpCode.removeWatches:            case OpCode.getEphemerals:            case OpCode.multiRead:                zks.sessionTracker.checkSession(request.sessionId, request.getOwner());                break;            default:                                break;        }    } catch (KeeperException e) {        if (request.getHdr() != null) {            request.getHdr().setType(OpCode.error);            request.setTxn(new ErrorTxn(e.code().intValue()));        }        if (e.code().intValue() > Code.APIERROR.intValue()) {                    }        request.setException(e);    } catch (Exception e) {                                StringBuilder sb = new StringBuilder();        ByteBuffer bb = request.request;        if (bb != null) {            bb.rewind();            while (bb.hasRemaining()) {                sb.append(Integer.toHexString(bb.get() & 0xff));            }        } else {            sb.append("request buffer is null");        }                if (request.getHdr() != null) {            request.getHdr().setType(OpCode.error);            request.setTxn(new ErrorTxn(Code.MARSHALLINGERROR.intValue()));        }    }    request.zxid = zks.getZxid();    ServerMetrics.getMetrics().PREP_PROCESS_TIME.add(Time.currentElapsedTime() - request.prepStartTime);    nextProcessor.processRequest(request);}
removeDuplicates
private static List<ACL> zookeeper_f2286_0(final List<ACL> acls)
{    if (acls == null || acls.isEmpty()) {        return Collections.emptyList();    }            final ArrayList<ACL> retval = new ArrayList<>(acls.size());    for (final ACL acl : acls) {        if (!retval.contains(acl)) {            retval.add(acl);        }    }    return retval;}
validateCreateRequest
private void zookeeper_f2287_0(String path, CreateMode createMode, Request request, long ttl) throws KeeperException
{    if (createMode.isTTL() && !EphemeralType.extendedEphemeralTypesEnabled()) {        throw new KeeperException.UnimplementedException();    }    try {        EphemeralType.validateTTL(createMode, ttl);    } catch (IllegalArgumentException e) {        throw new BadArgumentsException(path);    }    if (createMode.isEphemeral()) {                if (request.getException() != null) {            throw request.getException();        }        zks.sessionTracker.checkGlobalSession(request.sessionId, request.getOwner());    } else {        zks.sessionTracker.checkSession(request.sessionId, request.getOwner());    }}
fixupACL
public static List<ACL>f2288_1String path, List<Id> authInfo, List<ACL> acls) throws KeeperException.InvalidACLException
{            List<ACL> uniqacls = removeDuplicates(acls);    if (uniqacls == null || uniqacls.size() == 0) {        throw new KeeperException.InvalidACLException(path);    }    List<ACL> rv = new ArrayList<>();    for (ACL a : uniqacls) {                if (a == null) {            throw new KeeperException.InvalidACLException(path);        }        Id id = a.getId();        if (id == null || id.getScheme() == null) {            throw new KeeperException.InvalidACLException(path);        }        if (id.getScheme().equals("world") && id.getId().equals("anyone")) {            rv.add(a);        } else if (id.getScheme().equals("auth")) {                                    boolean authIdValid = false;            for (Id cid : authInfo) {                ServerAuthenticationProvider ap = ProviderRegistry.getServerProvider(cid.getScheme());                if (ap == null) {                                    } else if (ap.isAuthenticated()) {                    authIdValid = true;                    rv.add(new ACL(a.getPerms(), cid));                }            }            if (!authIdValid) {                throw new KeeperException.InvalidACLException(path);            }        } else {            ServerAuthenticationProvider ap = ProviderRegistry.getServerProvider(id.getScheme());            if (ap == null || !ap.isValid(id.getId())) {                throw new KeeperException.InvalidACLException(path);            }            rv.add(a);        }    }    return rv;}
processRequest
public void zookeeper_f2289_0(Request request)
{    request.prepQueueStartTime = Time.currentElapsedTime();    submittedRequests.add(request);    ServerMetrics.getMetrics().PREP_PROCESSOR_QUEUED.add(1);}
shutdown
public voidf2290_1)
{        submittedRequests.clear();    submittedRequests.add(Request.requestOfDeath);    nextProcessor.shutdown();}
printUsage
 static void zookeeper_f2291_0()
{    System.out.println("Usage:");    System.out.println("PurgeTxnLog dataLogDir [snapDir] -n count");    System.out.println("\tdataLogDir -- path to the txn log directory");    System.out.println("\tsnapDir -- path to the snapshot directory");    System.out.println("\tcount -- the number of old snaps/logs you want " + "to keep, value should be greater than or equal to 3");}
purge
public static void zookeeper_f2292_0(File dataDir, File snapDir, int num) throws IOException
{    if (num < 3) {        throw new IllegalArgumentException(COUNT_ERR_MSG);    }    FileTxnSnapLog txnLog = new FileTxnSnapLog(dataDir, snapDir);    List<File> snaps = txnLog.findNRecentSnapshots(num);    int numSnaps = snaps.size();    if (numSnaps > 0) {        purgeOlderSnapshots(txnLog, snaps.get(numSnaps - 1));    }}
purgeOlderSnapshots
 static voidf2293_1FileTxnSnapLog txnLog, File snapShot)
{    final long leastZxidToBeRetain = Util.getZxidFromName(snapShot.getName(), PREFIX_SNAPSHOT);    /**     * We delete all files with a zxid in their name that is less than leastZxidToBeRetain.     * This rule applies to both snapshot files as well as log files, with the following     * exception for log files.     *     * A log file with zxid less than X may contain transactions with zxid larger than X.  More     * precisely, a log file named log.(X-a) may contain transactions newer than snapshot.X if     * there are no other log files with starting zxid in the interval (X-a, X].  Assuming the     * latter condition is true, log.(X-a) must be retained to ensure that snapshot.X is     * recoverable.  In fact, this log file may very well extend beyond snapshot.X to newer     * snapshot files if these newer snapshots were not accompanied by log rollover (possible in     * the learner state machine at the time of this writing).  We can make more precise     * determination of whether log.(leastZxidToBeRetain-a) for the smallest 'a' is actually     * needed or not (e.g. not needed if there's a log file named log.(leastZxidToBeRetain+1)),     * but the complexity quickly adds up with gains only in uncommon scenarios.  It's safe and     * simple to just preserve log.(leastZxidToBeRetain-a) for the smallest 'a' to ensure     * recoverability of all snapshots being retained.  We determine that log file here by     * calling txnLog.getSnapshotLogs().     */    final Set<File> retainedTxnLogs = new HashSet<File>();    retainedTxnLogs.addAll(Arrays.asList(txnLog.getSnapshotLogs(leastZxidToBeRetain)));    /**     * Finds all candidates for deletion, which are files with a zxid in their name that is less     * than leastZxidToBeRetain.  There's an exception to this rule, as noted above.     */    class MyFileFilter implements FileFilter {        private final String prefix;        MyFileFilter(String prefix) {            this.prefix = prefix;        }        public boolean accept(File f) {            if (!f.getName().startsWith(prefix + ".")) {                return false;            }            if (retainedTxnLogs.contains(f)) {                return false;            }            long fZxid = Util.getZxidFromName(f.getName(), prefix);            return fZxid < leastZxidToBeRetain;        }    }        File[] logs = txnLog.getDataDir().listFiles(new MyFileFilter(PREFIX_LOG));    List<File> files = new ArrayList<>();    if (logs != null) {        files.addAll(Arrays.asList(logs));    }        File[] snapshots = txnLog.getSnapDir().listFiles(new MyFileFilter(PREFIX_SNAPSHOT));    if (snapshots != null) {        files.addAll(Arrays.asList(snapshots));    }        for (File f : files) {        final String msg = "Removing file: " + DateFormat.getDateTimeInstance().format(f.lastModified()) + "\t" + f.getPath();                System.out.println(msg);        if (!f.delete()) {            System.err.println("Failed to remove " + f.getPath());        }    }}
accept
public boolean zookeeper_f2294_0(File f)
{    if (!f.getName().startsWith(prefix + ".")) {        return false;    }    if (retainedTxnLogs.contains(f)) {        return false;    }    long fZxid = Util.getZxidFromName(f.getName(), prefix);    return fZxid < leastZxidToBeRetain;}
main
public static void zookeeper_f2295_0(String[] args) throws IOException
{    if (args.length < 3 || args.length > 4) {        printUsageThenExit();    }    File dataDir = validateAndGetFile(args[0]);    File snapDir = dataDir;    int num = -1;    String countOption = "";    if (args.length == 3) {        countOption = args[1];        num = validateAndGetCount(args[2]);    } else {        snapDir = validateAndGetFile(args[1]);        countOption = args[2];        num = validateAndGetCount(args[3]);    }    if (!"-n".equals(countOption)) {        printUsageThenExit();    }    purge(dataDir, snapDir, num);}
validateAndGetFile
private static File zookeeper_f2296_0(String path)
{    File file = new File(path);    if (!file.exists()) {        System.err.println("Path '" + file.getAbsolutePath() + "' does not exist. ");        printUsageThenExit();    }    return file;}
validateAndGetCount
private static int zookeeper_f2297_0(String number)
{    int result = 0;    try {        result = Integer.parseInt(number);        if (result < 3) {            System.err.println(COUNT_ERR_MSG);            printUsageThenExit();        }    } catch (NumberFormatException e) {        System.err.println("'" + number + "' can not be parsed to integer.");        printUsageThenExit();    }    return result;}
printUsageThenExit
private static void zookeeper_f2298_0()
{    printUsage();    System.exit(ExitCode.UNEXPECTED_ERROR.getValue());}
processRequest
public voidf2299_1Request request)
{    QuorumPeer self = leader.self;    if (self != null) {        request.logLatency(ServerMetrics.getMetrics().PROPOSAL_ACK_CREATION_LATENCY);        leader.processAck(self.getId(), request.zxid, null);    } else {            }}
shutdown
public void zookeeper_f2300_0()
{}
authenticate
public void zookeeper_f2301_0(Socket sock, String hostname)
{        return;}
authenticate
public void zookeeper_f2302_0(final Socket sock, final DataInputStream din)
{}
getStatus
 static Statusf2303_1int status)
{    switch(status) {        case 0:            return IN_PROGRESS;        case 1:            return SUCCESS;        case -1:            return ERROR;        default:                        assert false : "Unknown status!";            return ERROR;    }}
status
 int zookeeper_f2304_0()
{    return status;}
createPacket
public static QuorumAuthPacket zookeeper_f2305_0(Status status, byte[] response)
{    return new QuorumAuthPacket(QUORUM_AUTH_MAGIC_NUMBER, status.status(), response);}
nextPacketIsAuth
public static boolean zookeeper_f2306_0(DataInputStream din) throws IOException
{    din.mark(32);    BinaryInputArchive bia = new BinaryInputArchive(din);    boolean firstIsAuth = (bia.readLong("NO_TAG") == QuorumAuth.QUORUM_AUTH_MAGIC_NUMBER);    din.reset();    return firstIsAuth;}
authenticate
public voidf2307_1Socket sock, String hostName) throws IOException
{    if (!quorumRequireSasl) {                        return;    }    SaslClient sc = null;    String principalConfig = SecurityUtils.getServerPrincipal(quorumServicePrincipal, hostName);    try {        DataOutputStream dout = new DataOutputStream(sock.getOutputStream());        DataInputStream din = new DataInputStream(sock.getInputStream());        byte[] responseToken = new byte[0];        sc = SecurityUtils.createSaslClient(learnerLogin.getSubject(), principalConfig, QuorumAuth.QUORUM_SERVER_PROTOCOL_NAME, QuorumAuth.QUORUM_SERVER_SASL_DIGEST, LOG, "QuorumLearner");        if (sc.hasInitialResponse()) {            responseToken = createSaslToken(new byte[0], sc, learnerLogin);        }        send(dout, responseToken);        QuorumAuthPacket authPacket = receive(din);        QuorumAuth.Status qpStatus = QuorumAuth.Status.getStatus(authPacket.getStatus());        while (!sc.isComplete()) {            switch(qpStatus) {                case SUCCESS:                    responseToken = createSaslToken(authPacket.getToken(), sc, learnerLogin);                                        if (responseToken != null) {                        throw new SaslException("Protocol error: attempting to send response after completion");                    }                    break;                case IN_PROGRESS:                    responseToken = createSaslToken(authPacket.getToken(), sc, learnerLogin);                    send(dout, responseToken);                    authPacket = receive(din);                    qpStatus = QuorumAuth.Status.getStatus(authPacket.getStatus());                    break;                case ERROR:                    throw new SaslException("Authentication failed against server addr: " + sock.getRemoteSocketAddress());                default:                                        throw new SaslException("Authentication failed against server addr: " + sock.getRemoteSocketAddress());            }        }                checkAuthStatus(sock, qpStatus);    } finally {        if (sc != null) {            try {                sc.dispose();            } catch (SaslException e) {                            }        }    }}
checkAuthStatus
private voidf2308_1Socket sock, QuorumAuth.Status qpStatus) throws SaslException
{    if (qpStatus == QuorumAuth.Status.SUCCESS) {            } else {        throw new SaslException("Authentication failed against server addr: " + sock.getRemoteSocketAddress() + ", qpStatus: " + qpStatus);    }}
receive
private QuorumAuthPacket zookeeper_f2309_0(DataInputStream din) throws IOException
{    QuorumAuthPacket authPacket = new QuorumAuthPacket();    BinaryInputArchive bia = BinaryInputArchive.getArchive(din);    authPacket.deserialize(bia, QuorumAuth.QUORUM_AUTH_MESSAGE_TAG);    return authPacket;}
send
private void zookeeper_f2310_0(DataOutputStream dout, byte[] response) throws IOException
{    QuorumAuthPacket authPacket;    BufferedOutputStream bufferedOutput = new BufferedOutputStream(dout);    BinaryOutputArchive boa = BinaryOutputArchive.getArchive(bufferedOutput);    authPacket = QuorumAuth.createPacket(QuorumAuth.Status.IN_PROGRESS, response);    boa.writeRecord(authPacket, QuorumAuth.QUORUM_AUTH_MESSAGE_TAG);    bufferedOutput.flush();}
createSaslToken
private byte[]f2311_1final byte[] saslToken, final SaslClient saslClient, final Login login) throws SaslException
{    if (saslToken == null) {        throw new SaslException("Error in authenticating with a Zookeeper Quorum member: the quorum member's saslToken is null.");    }    if (login.getSubject() != null) {        synchronized (login) {            try {                final byte[] retval = Subject.doAs(login.getSubject(), new PrivilegedExceptionAction<byte[]>() {                    public byte[] run() throws SaslException {                                                return saslClient.evaluateChallenge(saslToken);                    }                });                return retval;            } catch (PrivilegedActionException e) {                String error = "An error: (" + e + ") occurred when evaluating Zookeeper Quorum Member's received SASL token.";                                                                final String UNKNOWN_SERVER_ERROR_TEXT = "(Mechanism level: Server not found in Kerberos database (7) - UNKNOWN_SERVER)";                if (e.toString().indexOf(UNKNOWN_SERVER_ERROR_TEXT) > -1) {                    error += " This may be caused by Java's being unable to resolve the Zookeeper Quorum Member's" + " hostname correctly. You may want to try to adding" + " '-Dsun.net.spi.nameservice.provider.1=dns,sun' to your server's JVMFLAGS environment.";                }                                throw new SaslException(error);            }        }    } else {        throw new SaslException("Cannot make SASL token without subject defined. " + "For diagnosis, please look for WARNs and ERRORs in your log related to the Login class.");    }}
run
public byte[]f2312_1) throws SaslException
{        return saslClient.evaluateChallenge(saslToken);}
authenticate
public voidf2313_1Socket sock, DataInputStream din) throws SaslException
{    DataOutputStream dout = null;    SaslServer ss = null;    try {        if (!QuorumAuth.nextPacketIsAuth(din)) {            if (quorumRequireSasl) {                throw new SaslException("Learner not trying to authenticate" + " and authentication is required");            } else {                                return;            }        }        byte[] token = receive(din);        int tries = 0;        dout = new DataOutputStream(sock.getOutputStream());        byte[] challenge = null;        ss = SecurityUtils.createSaslServer(serverLogin.getSubject(), QuorumAuth.QUORUM_SERVER_PROTOCOL_NAME, QuorumAuth.QUORUM_SERVER_SASL_DIGEST, serverLogin.callbackHandler, LOG);        while (!ss.isComplete()) {            challenge = ss.evaluateResponse(token);            if (!ss.isComplete()) {                                if (++tries > MAX_RETRIES) {                    send(dout, challenge, QuorumAuth.Status.ERROR);                                        break;                }                send(dout, challenge, QuorumAuth.Status.IN_PROGRESS);                token = receive(din);            }        }                if (ss.isComplete()) {            send(dout, challenge, QuorumAuth.Status.SUCCESS);                    }    } catch (Exception e) {        try {            if (dout != null) {                                send(dout, new byte[0], QuorumAuth.Status.ERROR);            }        } catch (IOException ioe) {                    }                if (quorumRequireSasl) {                        throw new SaslException("Failed to authenticate using SASL: " + e.getMessage());        } else {                                        }    } finally {        if (ss != null) {            try {                ss.dispose();            } catch (SaslException e) {                            }        }    }}
receive
private byte[] zookeeper_f2314_0(DataInputStream din) throws IOException
{    QuorumAuthPacket authPacket = new QuorumAuthPacket();    BinaryInputArchive bia = BinaryInputArchive.getArchive(din);    authPacket.deserialize(bia, QuorumAuth.QUORUM_AUTH_MESSAGE_TAG);    return authPacket.getToken();}
send
private void zookeeper_f2315_0(DataOutputStream dout, byte[] challenge, QuorumAuth.Status s) throws IOException
{    BufferedOutputStream bufferedOutput = new BufferedOutputStream(dout);    BinaryOutputArchive boa = BinaryOutputArchive.getArchive(bufferedOutput);    QuorumAuthPacket authPacket;    if (challenge == null && s != QuorumAuth.Status.SUCCESS) {        authPacket = QuorumAuth.createPacket(QuorumAuth.Status.IN_PROGRESS, null);    } else {        authPacket = QuorumAuth.createPacket(s, challenge);    }    boa.writeRecord(authPacket, QuorumAuth.QUORUM_AUTH_MESSAGE_TAG);    bufferedOutput.flush();}
handle
public void zookeeper_f2316_0(Callback[] callbacks) throws UnsupportedCallbackException
{    for (Callback callback : callbacks) {        if (callback instanceof NameCallback) {            handleNameCallback((NameCallback) callback);        } else if (callback instanceof PasswordCallback) {            handlePasswordCallback((PasswordCallback) callback);        } else if (callback instanceof RealmCallback) {            handleRealmCallback((RealmCallback) callback);        } else if (callback instanceof AuthorizeCallback) {            handleAuthorizeCallback((AuthorizeCallback) callback);        }    }}
handleNameCallback
private voidf2317_1NameCallback nc)
{        if (credentials.get(nc.getDefaultName()) == null) {                return;    }    nc.setName(nc.getDefaultName());    userName = nc.getDefaultName();}
handlePasswordCallback
private voidf2318_1PasswordCallback pc)
{    if (credentials.containsKey(userName)) {        pc.setPassword(credentials.get(userName).toCharArray());    } else {            }}
handleRealmCallback
private voidf2319_1RealmCallback rc)
{        rc.setText(rc.getDefaultText());}
saveChallenge
 booleanf2321_1long tag, long challenge)
{    Semaphore s = challengeMutex.get(tag);    if (s != null) {        synchronized (Messenger.this) {            challengeMap.put(tag, challenge);            challengeMutex.remove(tag);        }        s.release();    } else {            }    return true;}
run
public voidf2322_1)
{    byte[] responseBytes = new byte[48];    ByteBuffer responseBuffer = ByteBuffer.wrap(responseBytes);    DatagramPacket responsePacket = new DatagramPacket(responseBytes, responseBytes.length);    while (true) {                try {            responseBuffer.clear();            mySocket.receive(responsePacket);        } catch (IOException e) {                    }                if (responsePacket.getLength() != responseBytes.length) {                        continue;        }        responseBuffer.clear();        int type = responseBuffer.getInt();        if ((type > 3) || (type < 0)) {                        continue;        }        long tag = responseBuffer.getLong();        QuorumPeer.ServerState ackstate = QuorumPeer.ServerState.LOOKING;        switch(responseBuffer.getInt()) {            case 0:                ackstate = QuorumPeer.ServerState.LOOKING;                break;            case 1:                ackstate = QuorumPeer.ServerState.LEADING;                break;            case 2:                ackstate = QuorumPeer.ServerState.FOLLOWING;                break;            default:                                break;        }        Vote current = self.getCurrentVote();        switch(type) {            case 0:                                ToSend c = new ToSend(ToSend.mType.challenge, tag, current.getId(), current.getZxid(), logicalclock.get(), self.getPeerState(), (InetSocketAddress) responsePacket.getSocketAddress());                sendqueue.offer(c);                break;            case 1:                                long challenge = responseBuffer.getLong();                saveChallenge(tag, challenge);                break;            case 2:                Notification n = new Notification();                n.leader = responseBuffer.getLong();                n.zxid = responseBuffer.getLong();                n.epoch = responseBuffer.getLong();                n.state = ackstate;                n.addr = (InetSocketAddress) responsePacket.getSocketAddress();                if ((myMsg.lastEpoch <= n.epoch) && ((n.zxid > myMsg.lastProposedZxid) || ((n.zxid == myMsg.lastProposedZxid) && (n.leader > myMsg.lastProposedLeader)))) {                    myMsg.lastProposedZxid = n.zxid;                    myMsg.lastProposedLeader = n.leader;                    myMsg.lastEpoch = n.epoch;                }                long recChallenge;                InetSocketAddress addr = (InetSocketAddress) responsePacket.getSocketAddress();                if (authEnabled) {                    ConcurrentHashMap<Long, Long> tmpMap = addrChallengeMap.get(addr);                    if (tmpMap != null) {                        if (tmpMap.get(tag) != null) {                            recChallenge = responseBuffer.getLong();                            if (tmpMap.get(tag) == recChallenge) {                                recvqueue.offer(n);                                ToSend a = new ToSend(ToSend.mType.ack, tag, current.getId(), current.getZxid(), logicalclock.get(), self.getPeerState(), addr);                                sendqueue.offer(a);                            } else {                                                            }                        } else {                                                    }                    }                } else {                    recvqueue.offer(n);                    ToSend a = new ToSend(ToSend.mType.ack, tag, current.getId(), current.getZxid(), logicalclock.get(), self.getPeerState(), (InetSocketAddress) responsePacket.getSocketAddress());                    sendqueue.offer(a);                }                break;                        case 3:                Semaphore s = ackMutex.get(tag);                if (s != null) {                    s.release();                } else {                                    }                ackset.add(tag);                if (authEnabled) {                    ConcurrentHashMap<Long, Long> tmpMap = addrChallengeMap.get(responsePacket.getSocketAddress());                    if (tmpMap != null) {                        tmpMap.remove(tag);                    } else {                                            }                }                if (ackstate != QuorumPeer.ServerState.LOOKING) {                    Notification outofsync = new Notification();                    outofsync.leader = responseBuffer.getLong();                    outofsync.zxid = responseBuffer.getLong();                    outofsync.epoch = responseBuffer.getLong();                    outofsync.state = ackstate;                    outofsync.addr = (InetSocketAddress) responsePacket.getSocketAddress();                    recvqueue.offer(outofsync);                }                break;                        default:                                break;        }    }}
genChallenge
 long zookeeper_f2323_0()
{    byte[] buf = new byte[8];    buf[0] = (byte) ((challengeCounter & 0xff000000) >>> 24);    buf[1] = (byte) ((challengeCounter & 0x00ff0000) >>> 16);    buf[2] = (byte) ((challengeCounter & 0x0000ff00) >>> 8);    buf[3] = (byte) ((challengeCounter & 0x000000ff));    challengeCounter++;    int secret = rand.nextInt(java.lang.Integer.MAX_VALUE);    buf[4] = (byte) ((secret & 0xff000000) >>> 24);    buf[5] = (byte) ((secret & 0x00ff0000) >>> 16);    buf[6] = (byte) ((secret & 0x0000ff00) >>> 8);    buf[7] = (byte) ((secret & 0x000000ff));    return (((long) (buf[0] & 0xFF)) << 56) + (((long) (buf[1] & 0xFF)) << 48) + (((long) (buf[2] & 0xFF)) << 40) + (((long) (buf[3] & 0xFF)) << 32) + (((long) (buf[4] & 0xFF)) << 24) + (((long) (buf[5] & 0xFF)) << 16) + (((long) (buf[6] & 0xFF)) << 8) + ((long) (buf[7] & 0xFF));}
run
public void zookeeper_f2324_0()
{    while (true) {        try {            ToSend m = sendqueue.take();            process(m);        } catch (InterruptedException e) {            break;        }    }}
process
private voidf2325_1ToSend m)
{    int attempts = 0;    byte[] zeroes;    byte[] requestBytes = new byte[48];    DatagramPacket requestPacket = new DatagramPacket(requestBytes, requestBytes.length);    ByteBuffer requestBuffer = ByteBuffer.wrap(requestBytes);    switch(m.type) {        case 0:            /*                     * Building challenge request packet to send                     */            requestBuffer.clear();            requestBuffer.putInt(ToSend.mType.crequest.ordinal());            requestBuffer.putLong(m.tag);            requestBuffer.putInt(m.state.ordinal());            zeroes = new byte[32];            requestBuffer.put(zeroes);            requestPacket.setLength(48);            try {                requestPacket.setSocketAddress(m.addr);            } catch (IllegalArgumentException e) {                                throw new IllegalArgumentException("Unable to set socket address on packet, msg:" + e.getMessage() + " with addr:" + m.addr, e);            }            try {                if (challengeMap.get(m.tag) == null) {                    mySocket.send(requestPacket);                }            } catch (IOException e) {                            }            break;        case 1:            /*                     * Building challenge packet to send                     */            long newChallenge;            ConcurrentHashMap<Long, Long> tmpMap = addrChallengeMap.get(m.addr);            if (tmpMap != null) {                Long tmpLong = tmpMap.get(m.tag);                if (tmpLong != null) {                    newChallenge = tmpLong;                } else {                    newChallenge = genChallenge();                }                tmpMap.put(m.tag, newChallenge);                requestBuffer.clear();                requestBuffer.putInt(ToSend.mType.challenge.ordinal());                requestBuffer.putLong(m.tag);                requestBuffer.putInt(m.state.ordinal());                requestBuffer.putLong(newChallenge);                zeroes = new byte[24];                requestBuffer.put(zeroes);                requestPacket.setLength(48);                try {                    requestPacket.setSocketAddress(m.addr);                } catch (IllegalArgumentException e) {                                        throw new IllegalArgumentException("Unable to set socket address on packet, msg:" + e.getMessage() + " with addr:" + m.addr, e);                }                try {                    mySocket.send(requestPacket);                } catch (IOException e) {                                    }            } else {                            }            break;        case 2:            /*                     * Building notification packet to send                     */            requestBuffer.clear();            requestBuffer.putInt(m.type);            requestBuffer.putLong(m.tag);            requestBuffer.putInt(m.state.ordinal());            requestBuffer.putLong(m.leader);            requestBuffer.putLong(m.zxid);            requestBuffer.putLong(m.epoch);            zeroes = new byte[8];            requestBuffer.put(zeroes);            requestPacket.setLength(48);            try {                requestPacket.setSocketAddress(m.addr);            } catch (IllegalArgumentException e) {                                throw new IllegalArgumentException("Unable to set socket address on packet, msg:" + e.getMessage() + " with addr:" + m.addr, e);            }            boolean myChallenge = false;            boolean myAck = false;            while (attempts < maxAttempts) {                try {                    if (!myChallenge && authEnabled) {                        ToSend crequest = new ToSend(ToSend.mType.crequest, m.tag, m.leader, m.zxid, m.epoch, QuorumPeer.ServerState.LOOKING, m.addr);                        sendqueue.offer(crequest);                        try {                            double timeout = ackWait * java.lang.Math.pow(2, attempts);                            Semaphore s = new Semaphore(0);                            synchronized (Messenger.this) {                                challengeMutex.put(m.tag, s);                                s.tryAcquire((long) timeout, TimeUnit.MILLISECONDS);                                myChallenge = challengeMap.containsKey(m.tag);                            }                        } catch (InterruptedException e) {                                                    }                    }                    if (authEnabled && !myChallenge) {                        attempts++;                        continue;                    }                    if (authEnabled) {                        requestBuffer.position(40);                        Long tmpLong = challengeMap.get(m.tag);                        if (tmpLong != null) {                            requestBuffer.putLong(tmpLong);                        } else {                                                    }                    }                    mySocket.send(requestPacket);                    try {                        Semaphore s = new Semaphore(0);                        double timeout = ackWait * java.lang.Math.pow(10, attempts);                        ackMutex.put(m.tag, s);                        s.tryAcquire((int) timeout, TimeUnit.MILLISECONDS);                    } catch (InterruptedException e) {                                            }                    if (ackset.remove(m.tag)) {                        myAck = true;                    }                } catch (IOException e) {                                    /*                             * Do nothing, just try again                             */                }                if (myAck) {                    /*                             * Received ack successfully, so return                             */                    challengeMap.remove(m.tag);                    return;                } else {                    attempts++;                }            }            /*                     * Return message to queue for another attempt later if                     * epoch hasn't changed.                     */            if (m.epoch == logicalclock.get()) {                challengeMap.remove(m.tag);                sendqueue.offer(m);            }            break;        case 3:            requestBuffer.clear();            requestBuffer.putInt(m.type);            requestBuffer.putLong(m.tag);            requestBuffer.putInt(m.state.ordinal());            requestBuffer.putLong(m.leader);            requestBuffer.putLong(m.zxid);            requestBuffer.putLong(m.epoch);            requestPacket.setLength(48);            try {                requestPacket.setSocketAddress(m.addr);            } catch (IllegalArgumentException e) {                                throw new IllegalArgumentException("Unable to set socket address on packet, msg:" + e.getMessage() + " with addr:" + m.addr, e);            }            try {                mySocket.send(requestPacket);            } catch (IOException e) {                            }            break;        default:                        break;    }}
starter
private void zookeeper_f2326_0(QuorumPeer self)
{    this.self = self;    port = self.getVotingView().get(self.getId()).electionAddr.getPort();    proposedLeader = -1;    proposedZxid = -1;    try {        mySocket = new DatagramSocket(port);        } catch (SocketException e1) {        e1.printStackTrace();        throw new RuntimeException();    }    sendqueue = new LinkedBlockingQueue<ToSend>(2 * self.getVotingView().size());    recvqueue = new LinkedBlockingQueue<Notification>(2 * self.getVotingView().size());    new Messenger(self.getVotingView().size() * 2, mySocket);}
leaveInstance
private void zookeeper_f2327_0()
{    logicalclock.incrementAndGet();}
sendNotifications
private void zookeeper_f2328_0()
{    for (QuorumServer server : self.getView().values()) {        ToSend notmsg = new ToSend(ToSend.mType.notification, AuthFastLeaderElection.sequencer++, proposedLeader, proposedZxid, logicalclock.get(), QuorumPeer.ServerState.LOOKING, self.getView().get(server.id).electionAddr);        sendqueue.offer(notmsg);    }}
totalOrderPredicate
private boolean zookeeper_f2329_0(long id, long zxid)
{    return (zxid > proposedZxid) || ((zxid == proposedZxid) && (id > proposedLeader));}
termPredicate
private boolean zookeeper_f2330_0(Map<InetSocketAddress, Vote> votes, long l, long zxid)
{    Collection<Vote> votesCast = votes.values();    int count = 0;    /*         * First make the views consistent. Sometimes peers will have different         * zxids for a server depending on timing.         */    for (Vote v : votesCast) {        if ((v.getId() == l) && (v.getZxid() == zxid)) {            count++;        }    }    return count > (self.getVotingView().size() / 2);}
shutdown
public void zookeeper_f2331_0()
{}
lookForLeader
public Votef2332_1) throws InterruptedException
{    try {        self.jmxLeaderElectionBean = new LeaderElectionBean();        MBeanRegistry.getInstance().register(self.jmxLeaderElectionBean, self.jmxLocalPeerBean);    } catch (Exception e) {                self.jmxLeaderElectionBean = null;    }    try {        HashMap<InetSocketAddress, Vote> recvset = new HashMap<InetSocketAddress, Vote>();        HashMap<InetSocketAddress, Vote> outofelection = new HashMap<InetSocketAddress, Vote>();        logicalclock.incrementAndGet();        proposedLeader = self.getId();        proposedZxid = self.getLastLoggedZxid();                sendNotifications();        while (self.getPeerState() == ServerState.LOOKING) {            /*                 * Remove next notification from queue, times out after 2 times                 * the termination time                 */            Notification n = recvqueue.poll(2 * finalizeWait, TimeUnit.MILLISECONDS);            /*                 * Sends more notifications if haven't received enough.                 * Otherwise processes new notification.                 */            if (n == null) {                if (((!outofelection.isEmpty()) || (recvset.size() > 1))) {                    sendNotifications();                }            } else {                switch(n.state) {                    case LOOKING:                        if (n.epoch > logicalclock.get()) {                            logicalclock.set(n.epoch);                            recvset.clear();                            if (totalOrderPredicate(n.leader, n.zxid)) {                                proposedLeader = n.leader;                                proposedZxid = n.zxid;                            }                            sendNotifications();                        } else if (n.epoch < logicalclock.get()) {                            break;                        } else if (totalOrderPredicate(n.leader, n.zxid)) {                            proposedLeader = n.leader;                            proposedZxid = n.zxid;                            sendNotifications();                        }                        recvset.put(n.addr, new Vote(n.leader, n.zxid));                                                if (self.getVotingView().size() == recvset.size()) {                            self.setPeerState((proposedLeader == self.getId()) ? ServerState.LEADING : ServerState.FOLLOWING);                                                                                                                leaveInstance();                            return new Vote(proposedLeader, proposedZxid);                        } else if (termPredicate(recvset, proposedLeader, proposedZxid)) {                                                                                    Thread.sleep(finalizeWait);                                                        while ((!recvqueue.isEmpty()) && !totalOrderPredicate(recvqueue.peek().leader, recvqueue.peek().zxid)) {                                recvqueue.poll();                            }                            if (recvqueue.isEmpty()) {                                                                                                self.setPeerState((proposedLeader == self.getId()) ? ServerState.LEADING : ServerState.FOLLOWING);                                leaveInstance();                                return new Vote(proposedLeader, proposedZxid);                            }                        }                        break;                    case LEADING:                        outofelection.put(n.addr, new Vote(n.leader, n.zxid));                        if (termPredicate(outofelection, n.leader, n.zxid)) {                            self.setPeerState((n.leader == self.getId()) ? ServerState.LEADING : ServerState.FOLLOWING);                            leaveInstance();                            return new Vote(n.leader, n.zxid);                        }                        break;                    case FOLLOWING:                        outofelection.put(n.addr, new Vote(n.leader, n.zxid));                        if (termPredicate(outofelection, n.leader, n.zxid)) {                            self.setPeerState((n.leader == self.getId()) ? ServerState.LEADING : ServerState.FOLLOWING);                            leaveInstance();                            return new Vote(n.leader, n.zxid);                        }                        break;                    default:                        break;                }            }        }        return null;    } finally {        try {            if (self.jmxLeaderElectionBean != null) {                MBeanRegistry.getInstance().unregister(self.jmxLeaderElectionBean);            }        } catch (Exception e) {                    }        self.jmxLeaderElectionBean = null;    }}
getLastBufferSize
public synchronized int zookeeper_f2333_0()
{    return lastBufferSize;}
setLastBufferSize
public synchronized void zookeeper_f2334_0(int value)
{    lastBufferSize = value;    if (minBufferSize == INIT_VALUE || value < minBufferSize) {        minBufferSize = value;    }    if (value > maxBufferSize) {        maxBufferSize = value;    }}
getMinBufferSize
public synchronized int zookeeper_f2335_0()
{    return minBufferSize;}
getMaxBufferSize
public synchronized int zookeeper_f2336_0()
{    return maxBufferSize;}
reset
public synchronized void zookeeper_f2337_0()
{    lastBufferSize = INIT_VALUE;    minBufferSize = INIT_VALUE;    maxBufferSize = INIT_VALUE;}
toString
public synchronized String zookeeper_f2338_0()
{    return String.format("%d/%d/%d", lastBufferSize, minBufferSize, maxBufferSize);}
isProcessingRequest
private boolean zookeeper_f2339_0()
{    return numRequestsProcessing.get() != 0;}
needCommit
protected boolean zookeeper_f2340_0(Request request)
{    switch(request.type) {        case OpCode.create:        case OpCode.create2:        case OpCode.createTTL:        case OpCode.createContainer:        case OpCode.delete:        case OpCode.deleteContainer:        case OpCode.setData:        case OpCode.reconfig:        case OpCode.multi:        case OpCode.setACL:        case OpCode.check:            return true;        case OpCode.sync:            return matchSyncs;        case OpCode.createSession:        case OpCode.closeSession:            return !request.isLocalSession();        default:            return false;    }}
run
public voidf2341_1)
{    try {        /*             * In each iteration of the following loop we process at most             * requestsToProcess requests of queuedRequests. We have to limit             * the number of request we poll from queuedRequests, since it is             * possible to endlessly poll read requests from queuedRequests, and             * that will lead to a starvation of non-local committed requests.             */        int requestsToProcess = 0;        boolean commitIsWaiting = false;        do {            /*                 * Since requests are placed in the queue before being sent to                 * the leader, if commitIsWaiting = true, the commit belongs to                 * the first update operation in the queuedRequests or to a                 * request from a client on another server (i.e., the order of                 * the following two lines is important!).                 */            commitIsWaiting = !committedRequests.isEmpty();            requestsToProcess = queuedRequests.size();                        if (requestsToProcess == 0 && !commitIsWaiting) {                                synchronized (this) {                    while (!stopped && requestsToProcess == 0 && !commitIsWaiting) {                        wait();                        commitIsWaiting = !committedRequests.isEmpty();                        requestsToProcess = queuedRequests.size();                    }                }            }            ServerMetrics.getMetrics().READS_QUEUED_IN_COMMIT_PROCESSOR.add(numReadQueuedRequests.get());            ServerMetrics.getMetrics().WRITES_QUEUED_IN_COMMIT_PROCESSOR.add(numWriteQueuedRequests.get());            ServerMetrics.getMetrics().COMMITS_QUEUED_IN_COMMIT_PROCESSOR.add(committedRequests.size());            long time = Time.currentElapsedTime();            /*                 * Processing up to requestsToProcess requests from the incoming                 * queue (queuedRequests). If maxReadBatchSize is set then no                 * commits will be processed until maxReadBatchSize number of                 * reads are processed (or no more reads remain in the queue).                 * After the loop a single committed request is processed if                 * one is waiting (or a batch of commits if maxCommitBatchSize                 * is set).                 */            Request request;            int readsProcessed = 0;            while (!stopped && requestsToProcess > 0 && (maxReadBatchSize < 0 || readsProcessed <= maxReadBatchSize) && (request = queuedRequests.poll()) != null) {                requestsToProcess--;                if (needCommit(request) || pendingRequests.containsKey(request.sessionId)) {                                        Deque<Request> requests = pendingRequests.computeIfAbsent(request.sessionId, sid -> new ArrayDeque<>());                    requests.addLast(request);                    ServerMetrics.getMetrics().REQUESTS_IN_SESSION_QUEUE.add(requests.size());                } else {                    readsProcessed++;                    numReadQueuedRequests.decrementAndGet();                    sendToNextProcessor(request);                }                /*                     * Stop feeding the pool if there is a local pending update                     * and a committed request that is ready. Once we have a                     * pending request with a waiting committed request, we know                     * we can process the committed one. This is because commits                     * for local requests arrive in the order they appeared in                     * the queue, so if we have a pending request and a                     * committed request, the committed request must be for that                     * pending write or for a write originating at a different                     * server. We skip this if maxReadBatchSize is set.                     */                if (maxReadBatchSize < 0 && !pendingRequests.isEmpty() && !committedRequests.isEmpty()) {                    /*                         * We set commitIsWaiting so that we won't check                         * committedRequests again.                         */                    commitIsWaiting = true;                    break;                }            }            ServerMetrics.getMetrics().READS_ISSUED_IN_COMMIT_PROC.add(readsProcessed);            if (!commitIsWaiting) {                commitIsWaiting = !committedRequests.isEmpty();            }            /*                 * Handle commits, if any.                 */            if (commitIsWaiting && !stopped) {                /*                     * Drain outstanding reads                     */                waitForEmptyPool();                if (stopped) {                    return;                }                int commitsToProcess = maxCommitBatchSize;                /*                     * Loop through all the commits, and try to drain them.                     */                Set<Long> queuesToDrain = new HashSet<>();                long startWriteTime = Time.currentElapsedTime();                int commitsProcessed = 0;                while (commitIsWaiting && !stopped && commitsToProcess > 0) {                                        request = committedRequests.peek();                    /*                         * Check if this is a local write request is pending,                         * if so, update it with the committed info. If the commit matches                         * the first write queued in the blockedRequestQueue, we know this is                         * a commit for a local write, as commits are received in order. Else                         * it must be a commit for a remote write.                         */                    if (!queuedWriteRequests.isEmpty() && queuedWriteRequests.peek().sessionId == request.sessionId && queuedWriteRequests.peek().cxid == request.cxid) {                        /*                             * Commit matches the earliest write in our write queue.                             */                        Deque<Request> sessionQueue = pendingRequests.get(request.sessionId);                        ServerMetrics.getMetrics().PENDING_SESSION_QUEUE_SIZE.add(pendingRequests.size());                        if (sessionQueue == null || sessionQueue.isEmpty() || !needCommit(sessionQueue.peek())) {                            /*                                 * Can't process this write yet.                                 * Either there are reads pending in this session, or we                                 * haven't gotten to this write yet.                                 */                            break;                        } else {                            ServerMetrics.getMetrics().REQUESTS_IN_SESSION_QUEUE.add(sessionQueue.size());                                                        Request topPending = sessionQueue.poll();                            /*                                 * Generally, we want to send to the next processor our version of the request,                                 * since it contains the session information that is needed for post update processing.                                 * In more details, when a request is in the local queue, there is (or could be) a client                                 * attached to this server waiting for a response, and there is other bookkeeping of                                 * requests that are outstanding and have originated from this server                                 * (e.g., for setting the max outstanding requests) - we need to update this info when an                                 * outstanding request completes. Note that in the other case, the operation                                 * originated from a different server and there is no local bookkeeping or a local client                                 * session that needs to be notified.                                 */                            topPending.setHdr(request.getHdr());                            topPending.setTxn(request.getTxn());                            topPending.zxid = request.zxid;                            topPending.commitRecvTime = request.commitRecvTime;                            request = topPending;                                                        numWriteQueuedRequests.decrementAndGet();                            queuedWriteRequests.poll();                            queuesToDrain.add(request.sessionId);                        }                    }                    /*                         * Pull the request off the commit queue, now that we are going                         * to process it.                         */                    committedRequests.remove();                    commitsToProcess--;                    commitsProcessed++;                                        processWrite(request);                    commitIsWaiting = !committedRequests.isEmpty();                }                ServerMetrics.getMetrics().WRITE_BATCH_TIME_IN_COMMIT_PROCESSOR.add(Time.currentElapsedTime() - startWriteTime);                ServerMetrics.getMetrics().WRITES_ISSUED_IN_COMMIT_PROC.add(commitsProcessed);                /*                     * Process following reads if any, remove session queue(s) if                     * empty.                     */                readsProcessed = 0;                for (Long sessionId : queuesToDrain) {                    Deque<Request> sessionQueue = pendingRequests.get(sessionId);                    int readsAfterWrite = 0;                    while (!stopped && !sessionQueue.isEmpty() && !needCommit(sessionQueue.peek())) {                        numReadQueuedRequests.decrementAndGet();                        sendToNextProcessor(sessionQueue.poll());                        readsAfterWrite++;                    }                    ServerMetrics.getMetrics().READS_AFTER_WRITE_IN_SESSION_QUEUE.add(readsAfterWrite);                    readsProcessed += readsAfterWrite;                                        if (sessionQueue.isEmpty()) {                        pendingRequests.remove(sessionId);                    }                }                ServerMetrics.getMetrics().SESSION_QUEUES_DRAINED.add(queuesToDrain.size());                ServerMetrics.getMetrics().READ_ISSUED_FROM_SESSION_QUEUE.add(readsProcessed);            }            ServerMetrics.getMetrics().COMMIT_PROCESS_TIME.add(Time.currentElapsedTime() - time);            endOfIteration();        } while (!stoppedMainLoop);    } catch (Throwable e) {        handleException(this.getName(), e);    }    }
endOfIteration
protected void zookeeper_f2342_0()
{}
waitForEmptyPool
protected void zookeeper_f2343_0() throws InterruptedException
{    int numRequestsInProcess = numRequestsProcessing.get();    if (numRequestsInProcess != 0) {        ServerMetrics.getMetrics().CONCURRENT_REQUEST_PROCESSING_IN_COMMIT_PROCESSOR.add(numRequestsInProcess);    }    long startWaitTime = Time.currentElapsedTime();    synchronized (emptyPoolSync) {        while ((!stopped) && isProcessingRequest()) {            emptyPoolSync.wait();        }    }    ServerMetrics.getMetrics().TIME_WAITING_EMPTY_POOL_IN_COMMIT_PROCESSOR_READ.add(Time.currentElapsedTime() - startWaitTime);}
start
public voidf2344_1)
{    int numCores = Runtime.getRuntime().availableProcessors();    int numWorkerThreads = Integer.getInteger(ZOOKEEPER_COMMIT_PROC_NUM_WORKER_THREADS, numCores);    workerShutdownTimeoutMS = Long.getLong(ZOOKEEPER_COMMIT_PROC_SHUTDOWN_TIMEOUT, 5000);    initBatchSizes();        if (workerPool == null) {        workerPool = new WorkerService("CommitProcWork", numWorkerThreads, true);    }    stopped = false;    stoppedMainLoop = false;    super.start();}
sendToNextProcessor
private void zookeeper_f2345_0(Request request)
{    numRequestsProcessing.incrementAndGet();    workerPool.schedule(new CommitWorkRequest(request), request.sessionId);}
processWrite
private void zookeeper_f2346_0(Request request) throws RequestProcessorException
{    processCommitMetrics(request, true);    long timeBeforeFinalProc = Time.currentElapsedTime();    nextProcessor.processRequest(request);    ServerMetrics.getMetrics().WRITE_FINAL_PROC_TIME.add(Time.currentElapsedTime() - timeBeforeFinalProc);}
initBatchSizes
private static voidf2347_1)
{    maxReadBatchSize = Integer.getInteger(ZOOKEEPER_COMMIT_PROC_MAX_READ_BATCH_SIZE, -1);    maxCommitBatchSize = Integer.getInteger(ZOOKEEPER_COMMIT_PROC_MAX_COMMIT_BATCH_SIZE, 1);    if (maxCommitBatchSize <= 0) {        String errorMsg = "maxCommitBatchSize must be positive, was " + maxCommitBatchSize;        throw new IllegalArgumentException(errorMsg);    }    }
processCommitMetrics
private static void zookeeper_f2348_0(Request request, boolean isWrite)
{    if (isWrite) {        if (request.commitProcQueueStartTime != -1 && request.commitRecvTime != -1) {                        long currentTime = Time.currentElapsedTime();            ServerMetrics.getMetrics().WRITE_COMMITPROC_TIME.add(currentTime - request.commitProcQueueStartTime);            ServerMetrics.getMetrics().LOCAL_WRITE_COMMITTED_TIME.add(currentTime - request.commitRecvTime);        } else if (request.commitRecvTime != -1) {                        ServerMetrics.getMetrics().SERVER_WRITE_COMMITTED_TIME.add(Time.currentElapsedTime() - request.commitRecvTime);        }    } else {        if (request.commitProcQueueStartTime != -1) {            ServerMetrics.getMetrics().READ_COMMITPROC_TIME.add(Time.currentElapsedTime() - request.commitProcQueueStartTime);        }    }}
getMaxReadBatchSize
public static int zookeeper_f2349_0()
{    return maxReadBatchSize;}
getMaxCommitBatchSize
public static int zookeeper_f2350_0()
{    return maxCommitBatchSize;}
setMaxReadBatchSize
public static voidf2351_1int size)
{    maxReadBatchSize = size;    }
setMaxCommitBatchSize
public static voidf2352_1int size)
{    if (size > 0) {        maxCommitBatchSize = size;            }}
cleanup
public voidf2353_1)
{    if (!stopped) {                CommitProcessor.this.halt();    }}
doWork
public void zookeeper_f2354_0() throws RequestProcessorException
{    try {        processCommitMetrics(request, needCommit(request));        long timeBeforeFinalProc = Time.currentElapsedTime();        nextProcessor.processRequest(request);        if (needCommit(request)) {            ServerMetrics.getMetrics().WRITE_FINAL_PROC_TIME.add(Time.currentElapsedTime() - timeBeforeFinalProc);        } else {            ServerMetrics.getMetrics().READ_FINAL_PROC_TIME.add(Time.currentElapsedTime() - timeBeforeFinalProc);        }    } finally {        if (numRequestsProcessing.decrementAndGet() == 0) {            wakeupOnEmpty();        }    }}
wakeup
private synchronized void zookeeper_f2355_0()
{    notifyAll();}
wakeupOnEmpty
private void zookeeper_f2356_0()
{    synchronized (emptyPoolSync) {        emptyPoolSync.notifyAll();    }}
commit
public voidf2357_1Request request)
{    if (stopped || request == null) {        return;    }        request.commitRecvTime = Time.currentElapsedTime();    ServerMetrics.getMetrics().COMMITS_QUEUED.add(1);    committedRequests.add(request);    wakeup();}
processRequest
public voidf2358_1Request request)
{    if (stopped) {        return;    }        request.commitProcQueueStartTime = Time.currentElapsedTime();    queuedRequests.add(request);        if (needCommit(request)) {        queuedWriteRequests.add(request);        numWriteQueuedRequests.incrementAndGet();    } else {        numReadQueuedRequests.incrementAndGet();    }    wakeup();}
halt
private void zookeeper_f2359_0()
{    stoppedMainLoop = true;    stopped = true;    wakeupOnEmpty();    wakeup();    queuedRequests.clear();    if (workerPool != null) {        workerPool.stop();    }}
shutdown
public voidf2360_1)
{        halt();    if (workerPool != null) {        workerPool.join(workerShutdownTimeoutMS);    }    if (nextProcessor != null) {        nextProcessor.shutdown();    }}
run
public voidf2361_1)
{    Message response;    while (!stop) {                try {            response = manager.pollRecvQueue(3000, TimeUnit.MILLISECONDS);            if (response == null) {                continue;            }                        if (response.buffer.capacity() < 28) {                                continue;            }                                                boolean backCompatibility28 = (response.buffer.capacity() == 28);                        boolean backCompatibility40 = (response.buffer.capacity() == 40);            response.buffer.clear();                        Notification n = new Notification();            int rstate = response.buffer.getInt();            long rleader = response.buffer.getLong();            long rzxid = response.buffer.getLong();            long relectionEpoch = response.buffer.getLong();            long rpeerepoch;            int version = 0x0;            if (!backCompatibility28) {                rpeerepoch = response.buffer.getLong();                if (!backCompatibility40) {                    /*                                 * Version added in 3.4.6                                 */                    version = response.buffer.getInt();                } else {                                    }            } else {                                rpeerepoch = ZxidUtils.getEpochFromZxid(rzxid);            }            QuorumVerifier rqv = null;                        if (version > 0x1) {                int configLength = response.buffer.getInt();                byte[] b = new byte[configLength];                response.buffer.get(b);                synchronized (self) {                    try {                        rqv = self.configFromString(new String(b));                        QuorumVerifier curQV = self.getQuorumVerifier();                        if (rqv.getVersion() > curQV.getVersion()) {                                                        if (self.getPeerState() == ServerState.LOOKING) {                                                                self.processReconfig(rqv, null, null, false);                                if (!rqv.equals(curQV)) {                                                                        self.shuttingDownLE = true;                                    self.getElectionAlg().shutdown();                                    break;                                }                            } else {                                                            }                        }                    } catch (IOException e) {                                            } catch (ConfigException e) {                                            }                }            } else {                            }            /*                         * If it is from a non-voting server (such as an observer or                         * a non-voting follower), respond right away.                         */            if (!validVoter(response.sid)) {                Vote current = self.getCurrentVote();                QuorumVerifier qv = self.getQuorumVerifier();                ToSend notmsg = new ToSend(ToSend.mType.notification, current.getId(), current.getZxid(), logicalclock.get(), self.getPeerState(), response.sid, current.getPeerEpoch(), qv.toString().getBytes());                sendqueue.offer(notmsg);            } else {                                                                QuorumPeer.ServerState ackstate = QuorumPeer.ServerState.LOOKING;                switch(rstate) {                    case 0:                        ackstate = QuorumPeer.ServerState.LOOKING;                        break;                    case 1:                        ackstate = QuorumPeer.ServerState.FOLLOWING;                        break;                    case 2:                        ackstate = QuorumPeer.ServerState.LEADING;                        break;                    case 3:                        ackstate = QuorumPeer.ServerState.OBSERVING;                        break;                    default:                        continue;                }                n.leader = rleader;                n.zxid = rzxid;                n.electionEpoch = relectionEpoch;                n.state = ackstate;                n.sid = response.sid;                n.peerEpoch = rpeerepoch;                n.version = version;                n.qv = rqv;                /*                             * Print notification info                             */                if (LOG.isInfoEnabled()) {                    printNotification(n);                }                if (self.getPeerState() == QuorumPeer.ServerState.LOOKING) {                    recvqueue.offer(n);                    /*                                 * Send a notification back if the peer that sent this                                 * message is also looking and its logical clock is                                 * lagging behind.                                 */                    if ((ackstate == QuorumPeer.ServerState.LOOKING) && (n.electionEpoch < logicalclock.get())) {                        Vote v = getVote();                        QuorumVerifier qv = self.getQuorumVerifier();                        ToSend notmsg = new ToSend(ToSend.mType.notification, v.getId(), v.getZxid(), logicalclock.get(), self.getPeerState(), response.sid, v.getPeerEpoch(), qv.toString().getBytes());                        sendqueue.offer(notmsg);                    }                } else {                    /*                                 * If this server is not looking, but the one that sent the ack                                 * is looking, then send back what it believes to be the leader.                                 */                    Vote current = self.getCurrentVote();                    if (ackstate == QuorumPeer.ServerState.LOOKING) {                        if (self.leader != null) {                            if (leadingVoteSet != null) {                                self.leader.setLeadingVoteSet(leadingVoteSet);                                leadingVoteSet = null;                            }                            self.leader.reportLookingSid(response.sid);                        }                        if (LOG.isDebugEnabled()) {                                                    }                        QuorumVerifier qv = self.getQuorumVerifier();                        ToSend notmsg = new ToSend(ToSend.mType.notification, current.getId(), current.getZxid(), current.getElectionEpoch(), self.getPeerState(), response.sid, current.getPeerEpoch(), qv.toString().getBytes());                        sendqueue.offer(notmsg);                    }                }            }        } catch (InterruptedException e) {                    }    }    }
run
public voidf2362_1)
{    while (!stop) {        try {            ToSend m = sendqueue.poll(3000, TimeUnit.MILLISECONDS);            if (m == null) {                continue;            }            process(m);        } catch (InterruptedException e) {            break;        }    }    }
process
 void zookeeper_f2363_0(ToSend m)
{    ByteBuffer requestBuffer = buildMsg(m.state.ordinal(), m.leader, m.zxid, m.electionEpoch, m.peerEpoch, m.configData);    manager.toSend(m.sid, requestBuffer);}
start
 void zookeeper_f2364_0()
{    this.wsThread.start();    this.wrThread.start();}
halt
 void zookeeper_f2365_0()
{    this.ws.stop = true;    this.wr.stop = true;}
getLogicalClock
public long zookeeper_f2366_0()
{    return logicalclock.get();}
buildMsg
 static ByteBuffer zookeeper_f2367_0(int state, long leader, long zxid, long electionEpoch, long epoch)
{    byte[] requestBytes = new byte[40];    ByteBuffer requestBuffer = ByteBuffer.wrap(requestBytes);    /*         * Building notification packet to send, this is called directly only in tests         */    requestBuffer.clear();    requestBuffer.putInt(state);    requestBuffer.putLong(leader);    requestBuffer.putLong(zxid);    requestBuffer.putLong(electionEpoch);    requestBuffer.putLong(epoch);    requestBuffer.putInt(0x1);    return requestBuffer;}
buildMsg
 static ByteBuffer zookeeper_f2368_0(int state, long leader, long zxid, long electionEpoch, long epoch, byte[] configData)
{    byte[] requestBytes = new byte[44 + configData.length];    ByteBuffer requestBuffer = ByteBuffer.wrap(requestBytes);    /*         * Building notification packet to send         */    requestBuffer.clear();    requestBuffer.putInt(state);    requestBuffer.putLong(leader);    requestBuffer.putLong(zxid);    requestBuffer.putLong(electionEpoch);    requestBuffer.putLong(epoch);    requestBuffer.putInt(Notification.CURRENTVERSION);    requestBuffer.putInt(configData.length);    requestBuffer.put(configData);    return requestBuffer;}
starter
private void zookeeper_f2369_0(QuorumPeer self, QuorumCnxManager manager)
{    this.self = self;    proposedLeader = -1;    proposedZxid = -1;    sendqueue = new LinkedBlockingQueue<ToSend>();    recvqueue = new LinkedBlockingQueue<Notification>();    this.messenger = new Messenger(manager);}
start
public void zookeeper_f2370_0()
{    this.messenger.start();}
leaveInstance
private voidf2371_1Vote v)
{    if (LOG.isDebugEnabled()) {            }    recvqueue.clear();}
getCnxManager
public QuorumCnxManager zookeeper_f2372_0()
{    return manager;}
shutdown
public voidf2373_1)
{    stop = true;    proposedLeader = -1;    proposedZxid = -1;    leadingVoteSet = null;        manager.halt();        messenger.halt();    }
sendNotifications
private voidf2374_1)
{    for (long sid : self.getCurrentAndNextConfigVoters()) {        QuorumVerifier qv = self.getQuorumVerifier();        ToSend notmsg = new ToSend(ToSend.mType.notification, proposedLeader, proposedZxid, logicalclock.get(), QuorumPeer.ServerState.LOOKING, sid, proposedEpoch, qv.toString().getBytes());        if (LOG.isDebugEnabled()) {                    }        sendqueue.offer(notmsg);    }}
totalOrderPredicate
protected booleanf2376_1long newId, long newZxid, long newEpoch, long curId, long curZxid, long curEpoch)
{    if (LOG.isDebugEnabled()) {            }    if (self.getQuorumVerifier().getWeight(newId) == 0) {        return false;    }    return ((newEpoch > curEpoch) || ((newEpoch == curEpoch) && ((newZxid > curZxid) || ((newZxid == curZxid) && (newId > curId)))));}
getVoteTracker
protected SyncedLearnerTracker zookeeper_f2377_0(Map<Long, Vote> votes, Vote vote)
{    SyncedLearnerTracker voteSet = new SyncedLearnerTracker();    voteSet.addQuorumVerifier(self.getQuorumVerifier());    if (self.getLastSeenQuorumVerifier() != null && self.getLastSeenQuorumVerifier().getVersion() > self.getQuorumVerifier().getVersion()) {        voteSet.addQuorumVerifier(self.getLastSeenQuorumVerifier());    }    /*         * First make the views consistent. Sometimes peers will have different         * zxids for a server depending on timing.         */    for (Map.Entry<Long, Vote> entry : votes.entrySet()) {        if (vote.equals(entry.getValue())) {            voteSet.addAck(entry.getKey());        }    }    return voteSet;}
checkLeader
protected boolean zookeeper_f2378_0(Map<Long, Vote> votes, long leader, long electionEpoch)
{    boolean predicate = true;    if (leader != self.getId()) {        if (votes.get(leader) == null) {            predicate = false;        } else if (votes.get(leader).getState() != ServerState.LEADING) {            predicate = false;        }    } else if (logicalclock.get() != electionEpoch) {        predicate = false;    }    return predicate;}
updateProposal
 synchronized voidf2379_1long leader, long zxid, long epoch)
{    if (LOG.isDebugEnabled()) {            }    proposedLeader = leader;    proposedZxid = zxid;    proposedEpoch = epoch;}
getVote
public synchronized Vote zookeeper_f2380_0()
{    return new Vote(proposedLeader, proposedZxid, proposedEpoch);}
learningState
private ServerStatef2381_1)
{    if (self.getLearnerType() == LearnerType.PARTICIPANT) {                return ServerState.FOLLOWING;    } else {                return ServerState.OBSERVING;    }}
getInitId
private long zookeeper_f2382_0()
{    if (self.getQuorumVerifier().getVotingMembers().containsKey(self.getId())) {        return self.getId();    } else {        return Long.MIN_VALUE;    }}
getInitLastLoggedZxid
private long zookeeper_f2383_0()
{    if (self.getLearnerType() == LearnerType.PARTICIPANT) {        return self.getLastLoggedZxid();    } else {        return Long.MIN_VALUE;    }}
getPeerEpoch
private long zookeeper_f2384_0()
{    if (self.getLearnerType() == LearnerType.PARTICIPANT) {        try {            return self.getCurrentEpoch();        } catch (IOException e) {            RuntimeException re = new RuntimeException(e.getMessage());            re.setStackTrace(e.getStackTrace());            throw re;        }    } else {        return Long.MIN_VALUE;    }}
setPeerState
private void zookeeper_f2385_0(long proposedLeader, SyncedLearnerTracker voteSet)
{    ServerState ss = (proposedLeader == self.getId()) ? ServerState.LEADING : learningState();    self.setPeerState(ss);    if (ss == ServerState.LEADING) {        leadingVoteSet = voteSet;    }}
lookForLeader
public Votef2386_1) throws InterruptedException
{    try {        self.jmxLeaderElectionBean = new LeaderElectionBean();        MBeanRegistry.getInstance().register(self.jmxLeaderElectionBean, self.jmxLocalPeerBean);    } catch (Exception e) {                self.jmxLeaderElectionBean = null;    }    self.start_fle = Time.currentElapsedTime();    try {        Map<Long, Vote> recvset = new HashMap<Long, Vote>();        Map<Long, Vote> outofelection = new HashMap<Long, Vote>();        int notTimeout = minNotificationInterval;        synchronized (this) {            logicalclock.incrementAndGet();            updateProposal(getInitId(), getInitLastLoggedZxid(), getPeerEpoch());        }                sendNotifications();        SyncedLearnerTracker voteSet;        while ((self.getPeerState() == ServerState.LOOKING) && (!stop)) {            /*                 * Remove next notification from queue, times out after 2 times                 * the termination time                 */            Notification n = recvqueue.poll(notTimeout, TimeUnit.MILLISECONDS);            /*                 * Sends more notifications if haven't received enough.                 * Otherwise processes new notification.                 */            if (n == null) {                if (manager.haveDelivered()) {                    sendNotifications();                } else {                    manager.connectAll();                }                /*                     * Exponential backoff                     */                int tmpTimeOut = notTimeout * 2;                notTimeout = (tmpTimeOut < maxNotificationInterval ? tmpTimeOut : maxNotificationInterval);                            } else if (validVoter(n.sid) && validVoter(n.leader)) {                /*                     * Only proceed if the vote comes from a replica in the current or next                     * voting view for a replica in the current or next voting view.                     */                switch(n.state) {                    case LOOKING:                        if (getInitLastLoggedZxid() == -1) {                                                        break;                        }                        if (n.zxid == -1) {                                                        break;                        }                                                if (n.electionEpoch > logicalclock.get()) {                            logicalclock.set(n.electionEpoch);                            recvset.clear();                            if (totalOrderPredicate(n.leader, n.zxid, n.peerEpoch, getInitId(), getInitLastLoggedZxid(), getPeerEpoch())) {                                updateProposal(n.leader, n.zxid, n.peerEpoch);                            } else {                                updateProposal(getInitId(), getInitLastLoggedZxid(), getPeerEpoch());                            }                            sendNotifications();                        } else if (n.electionEpoch < logicalclock.get()) {                            if (LOG.isDebugEnabled()) {                                                            }                            break;                        } else if (totalOrderPredicate(n.leader, n.zxid, n.peerEpoch, proposedLeader, proposedZxid, proposedEpoch)) {                            updateProposal(n.leader, n.zxid, n.peerEpoch);                            sendNotifications();                        }                        if (LOG.isDebugEnabled()) {                                                    }                                                recvset.put(n.sid, new Vote(n.leader, n.zxid, n.electionEpoch, n.peerEpoch));                        voteSet = getVoteTracker(recvset, new Vote(proposedLeader, proposedZxid, logicalclock.get(), proposedEpoch));                        if (voteSet.hasAllQuorums()) {                                                        while ((n = recvqueue.poll(finalizeWait, TimeUnit.MILLISECONDS)) != null) {                                if (totalOrderPredicate(n.leader, n.zxid, n.peerEpoch, proposedLeader, proposedZxid, proposedEpoch)) {                                    recvqueue.put(n);                                    break;                                }                            }                            /*                             * This predicate is true once we don't read any new                             * relevant message from the reception queue                             */                            if (n == null) {                                setPeerState(proposedLeader, voteSet);                                Vote endVote = new Vote(proposedLeader, proposedZxid, logicalclock.get(), proposedEpoch);                                leaveInstance(endVote);                                return endVote;                            }                        }                        break;                    case OBSERVING:                                                break;                    case FOLLOWING:                    case LEADING:                        /*                         * Consider all notifications from the same epoch                         * together.                         */                        if (n.electionEpoch == logicalclock.get()) {                            recvset.put(n.sid, new Vote(n.leader, n.zxid, n.electionEpoch, n.peerEpoch));                            voteSet = getVoteTracker(recvset, new Vote(n.version, n.leader, n.zxid, n.electionEpoch, n.peerEpoch, n.state));                            if (voteSet.hasAllQuorums() && checkLeader(outofelection, n.leader, n.electionEpoch)) {                                setPeerState(n.leader, voteSet);                                Vote endVote = new Vote(n.leader, n.zxid, n.electionEpoch, n.peerEpoch);                                leaveInstance(endVote);                                return endVote;                            }                        }                        /*                         * Before joining an established ensemble, verify that                         * a majority are following the same leader.                         */                        outofelection.put(n.sid, new Vote(n.version, n.leader, n.zxid, n.electionEpoch, n.peerEpoch, n.state));                        voteSet = getVoteTracker(outofelection, new Vote(n.version, n.leader, n.zxid, n.electionEpoch, n.peerEpoch, n.state));                        if (voteSet.hasAllQuorums() && checkLeader(outofelection, n.leader, n.electionEpoch)) {                            synchronized (this) {                                logicalclock.set(n.electionEpoch);                                setPeerState(n.leader, voteSet);                            }                            Vote endVote = new Vote(n.leader, n.zxid, n.electionEpoch, n.peerEpoch);                            leaveInstance(endVote);                            return endVote;                        }                        break;                    default:                                                break;                }            } else {                if (!validVoter(n.leader)) {                                    }                if (!validVoter(n.sid)) {                                    }            }        }        return null;    } finally {        try {            if (self.jmxLeaderElectionBean != null) {                MBeanRegistry.getInstance().unregister(self.jmxLeaderElectionBean);            }        } catch (Exception e) {                    }        self.jmxLeaderElectionBean = null;            }}
validVoter
private boolean zookeeper_f2387_0(long sid)
{    return self.getCurrentAndNextConfigVoters().contains(sid);}
hashCode
public int zookeeper_f2388_0()
{    assert false : "hashCode not designed";        return 42;}
equals
public boolean zookeeper_f2389_0(Object o)
{    if (!(o instanceof QuorumHierarchical)) {        return false;    }    QuorumHierarchical qm = (QuorumHierarchical) o;    if (qm.getVersion() == version) {        return true;    }    if ((allMembers.size() != qm.getAllMembers().size()) || (serverWeight.size() != qm.serverWeight.size()) || (groupWeight.size() != qm.groupWeight.size()) || (serverGroup.size() != qm.serverGroup.size())) {        return false;    }    for (QuorumServer qs : allMembers.values()) {        QuorumServer qso = qm.getAllMembers().get(qs.id);        if (qso == null || !qs.equals(qso)) {            return false;        }    }    for (Entry<Long, Long> entry : serverWeight.entrySet()) {        if (!entry.getValue().equals(qm.serverWeight.get(entry.getKey()))) {            return false;        }    }    for (Entry<Long, Long> entry : groupWeight.entrySet()) {        if (!entry.getValue().equals(qm.groupWeight.get(entry.getKey()))) {            return false;        }    }    for (Entry<Long, Long> entry : serverGroup.entrySet()) {        if (!entry.getValue().equals(qm.serverGroup.get(entry.getKey()))) {            return false;        }    }    return true;}
getWeight
public long zookeeper_f2390_0(long id)
{    return serverWeight.get(id);}
readConfigFile
private voidf2391_1String filename) throws ConfigException
{    File configFile = new File(filename);        try {        if (!configFile.exists()) {            throw new IllegalArgumentException(configFile.toString() + " file is missing");        }        Properties cfg = new Properties();        FileInputStream in = new FileInputStream(configFile);        try {            cfg.load(in);        } finally {            in.close();        }        parse(cfg);    } catch (IOException e) {        throw new ConfigException("Error processing " + filename, e);    } catch (IllegalArgumentException e) {        throw new ConfigException("Error processing " + filename, e);    }}
parse
private void zookeeper_f2392_0(Properties quorumProp) throws ConfigException
{    for (Entry<Object, Object> entry : quorumProp.entrySet()) {        String key = entry.getKey().toString();        String value = entry.getValue().toString();        if (key.startsWith("server.")) {            int dot = key.indexOf('.');            long sid = Long.parseLong(key.substring(dot + 1));            QuorumServer qs = new QuorumServer(sid, value);            allMembers.put(Long.valueOf(sid), qs);            if (qs.type == LearnerType.PARTICIPANT) {                participatingMembers.put(Long.valueOf(sid), qs);            } else {                observingMembers.put(Long.valueOf(sid), qs);            }        } else if (key.startsWith("group")) {            int dot = key.indexOf('.');            long gid = Long.parseLong(key.substring(dot + 1));            numGroups++;            String[] parts = value.split(":");            for (String s : parts) {                long sid = Long.parseLong(s);                if (serverGroup.containsKey(sid)) {                    throw new ConfigException("Server " + sid + "is in multiple groups");                } else {                    serverGroup.put(sid, gid);                }            }        } else if (key.startsWith("weight")) {            int dot = key.indexOf('.');            long sid = Long.parseLong(key.substring(dot + 1));            serverWeight.put(sid, Long.parseLong(value));        } else if (key.equals("version")) {            version = Long.parseLong(value, 16);        }    }    for (QuorumServer qs : allMembers.values()) {        Long id = qs.id;        if (qs.type == LearnerType.PARTICIPANT) {            if (!serverGroup.containsKey(id)) {                throw new ConfigException("Server " + id + "is not in a group");            }            if (!serverWeight.containsKey(id)) {                serverWeight.put(id, (long) 1);            }        }    }    computeGroupWeight();}
getAllMembers
public Map<Long, QuorumServer> zookeeper_f2393_0()
{    return allMembers;}
toString
public String zookeeper_f2394_0()
{    StringWriter sw = new StringWriter();    for (QuorumServer member : getAllMembers().values()) {        String key = "server." + member.id;        String value = member.toString();        sw.append(key);        sw.append('=');        sw.append(value);        sw.append('\n');    }    Map<Long, String> groups = new HashMap<Long, String>();    for (Entry<Long, Long> pair : serverGroup.entrySet()) {        Long sid = pair.getKey();        Long gid = pair.getValue();        String str = groups.get(gid);        if (str == null) {            str = sid.toString();        } else {            str = str.concat(":").concat(sid.toString());        }        groups.put(gid, str);    }    for (Entry<Long, String> pair : groups.entrySet()) {        Long gid = pair.getKey();        String key = "group." + gid.toString();        String value = pair.getValue();        sw.append(key);        sw.append('=');        sw.append(value);        sw.append('\n');    }    for (Entry<Long, Long> pair : serverWeight.entrySet()) {        Long sid = pair.getKey();        String key = "weight." + sid.toString();        String value = pair.getValue().toString();        sw.append(key);        sw.append('=');        sw.append(value);        sw.append('\n');    }    sw.append("version=" + Long.toHexString(version));    return sw.toString();}
computeGroupWeight
private voidf2395_1)
{    for (Entry<Long, Long> entry : serverGroup.entrySet()) {        Long sid = entry.getKey();        Long gid = entry.getValue();        if (!groupWeight.containsKey(gid)) {            groupWeight.put(gid, serverWeight.get(sid));        } else {            long totalWeight = serverWeight.get(sid) + groupWeight.get(gid);            groupWeight.put(gid, totalWeight);        }    }    /*         * Do not consider groups with weight zero         */    for (long weight : groupWeight.values()) {                if (weight == ((long) 0)) {            numGroups--;                    }    }}
containsQuorum
public booleanf2396_1Set<Long> set)
{    HashMap<Long, Long> expansion = new HashMap<Long, Long>();    /*         * Adds up weights per group         */        if (set.size() == 0) {        return false;    }    for (long sid : set) {        Long gid = serverGroup.get(sid);        if (gid == null) {            continue;        }        if (!expansion.containsKey(gid)) {            expansion.put(gid, serverWeight.get(sid));        } else {            long totalWeight = serverWeight.get(sid) + expansion.get(gid);            expansion.put(gid, totalWeight);        }    }    /*         * Check if all groups have majority         */    int majGroupCounter = 0;    for (Entry<Long, Long> entry : expansion.entrySet()) {        Long gid = entry.getKey();                if (entry.getValue() > (groupWeight.get(gid) / 2)) {            majGroupCounter++;        }    }        if ((majGroupCounter > (numGroups / 2))) {                return true;    } else {                return false;    }}
getVotingMembers
public Map<Long, QuorumServer> zookeeper_f2397_0()
{    return participatingMembers;}
getObservingMembers
public Map<Long, QuorumServer> zookeeper_f2398_0()
{    return observingMembers;}
getVersion
public long zookeeper_f2399_0()
{    return version;}
setVersion
public void zookeeper_f2400_0(long ver)
{    version = ver;}
hashCode
public int zookeeper_f2401_0()
{    assert false : "hashCode not designed";        return 42;}
equals
public boolean zookeeper_f2402_0(Object o)
{    if (!(o instanceof QuorumMaj)) {        return false;    }    QuorumMaj qm = (QuorumMaj) o;    if (qm.getVersion() == version) {        return true;    }    if (allMembers.size() != qm.getAllMembers().size()) {        return false;    }    for (QuorumServer qs : allMembers.values()) {        QuorumServer qso = qm.getAllMembers().get(qs.id);        if (qso == null || !qs.equals(qso)) {            return false;        }    }    return true;}
getWeight
public long zookeeper_f2403_0(long id)
{    return 1;}
toString
public String zookeeper_f2404_0()
{    StringBuilder sw = new StringBuilder();    for (QuorumServer member : getAllMembers().values()) {        String key = "server." + member.id;        String value = member.toString();        sw.append(key);        sw.append('=');        sw.append(value);        sw.append('\n');    }    String hexVersion = Long.toHexString(version);    sw.append("version=");    sw.append(hexVersion);    return sw.toString();}
containsQuorum
public boolean zookeeper_f2405_0(Set<Long> ackSet)
{    return (ackSet.size() > half);}
getAllMembers
public Map<Long, QuorumServer> zookeeper_f2406_0()
{    return allMembers;}
getVotingMembers
public Map<Long, QuorumServer> zookeeper_f2407_0()
{    return votingMembers;}
getObservingMembers
public Map<Long, QuorumServer> zookeeper_f2408_0()
{    return observingMembers;}
getVersion
public long zookeeper_f2409_0()
{    return version;}
setVersion
public void zookeeper_f2410_0(long ver)
{    version = ver;}
toString
public String zookeeper_f2411_0()
{    StringBuilder sb = new StringBuilder();    sb.append("Follower ").append(sock);    sb.append(" lastQueuedZxid:").append(lastQueued);    sb.append(" pendingRevalidationCount:").append(pendingRevalidations.size());    return sb.toString();}
followLeader
 voidf2412_1) throws InterruptedException
{    self.end_fle = Time.currentElapsedTime();    long electionTimeTaken = self.end_fle - self.start_fle;    self.setElectionTimeTaken(electionTimeTaken);    ServerMetrics.getMetrics().ELECTION_TIME.add(electionTimeTaken);        self.start_fle = 0;    self.end_fle = 0;    fzk.registerJMX(new FollowerBean(this, zk), self.jmxLocalPeerBean);    long connectionTime = 0;    boolean completedSync = false;    try {        self.setZabState(QuorumPeer.ZabState.DISCOVERY);        QuorumServer leaderServer = findLeader();        try {            connectToLeader(leaderServer.addr, leaderServer.hostname);            connectionTime = System.currentTimeMillis();            long newEpochZxid = registerWithLeader(Leader.FOLLOWERINFO);            if (self.isReconfigStateChange()) {                throw new Exception("learned about role change");            }                                    long newEpoch = ZxidUtils.getEpochFromZxid(newEpochZxid);            if (newEpoch < self.getAcceptedEpoch()) {                                throw new IOException("Error: Epoch of leader is lower");            }            long startTime = Time.currentElapsedTime();            try {                self.setLeaderAddressAndId(leaderServer.addr, leaderServer.getId());                self.setZabState(QuorumPeer.ZabState.SYNCHRONIZATION);                syncWithLeader(newEpochZxid);                self.setZabState(QuorumPeer.ZabState.BROADCAST);                completedSync = true;            } finally {                long syncTime = Time.currentElapsedTime() - startTime;                ServerMetrics.getMetrics().FOLLOWER_SYNC_TIME.add(syncTime);            }            if (self.getObserverMasterPort() > 0) {                                om = new ObserverMaster(self, fzk, self.getObserverMasterPort());                om.start();            } else {                om = null;            }                        QuorumPacket qp = new QuorumPacket();            while (this.isRunning()) {                readPacket(qp);                processPacket(qp);            }        } catch (Exception e) {                        closeSocket();                        pendingRevalidations.clear();        }    } finally {        if (om != null) {            om.stop();        }        zk.unregisterJMX(this);        if (connectionTime != 0) {            long connectionDuration = System.currentTimeMillis() - connectionTime;                        messageTracker.dumpToLog(leaderAddr.toString());        }    }}
processPacket
protected voidf2413_1QuorumPacket qp) throws Exception
{    switch(qp.getType()) {        case Leader.PING:            ping(qp);            break;        case Leader.PROPOSAL:            ServerMetrics.getMetrics().LEARNER_PROPOSAL_RECEIVED_COUNT.add(1);            TxnHeader hdr = new TxnHeader();            Record txn = SerializeUtils.deserializeTxn(qp.getData(), hdr);            if (hdr.getZxid() != lastQueued + 1) {                            }            lastQueued = hdr.getZxid();            if (hdr.getType() == OpCode.reconfig) {                SetDataTxn setDataTxn = (SetDataTxn) txn;                QuorumVerifier qv = self.configFromString(new String(setDataTxn.getData()));                self.setLastSeenQuorumVerifier(qv, true);            }            fzk.logRequest(hdr, txn);            if (hdr != null) {                /*                 * Request header is created only by the leader, so this is only set                 * for quorum packets. If there is a clock drift, the latency may be                 * negative. Headers use wall time, not CLOCK_MONOTONIC.                 */                long now = Time.currentWallTime();                long latency = now - hdr.getTime();                if (latency >= 0) {                    ServerMetrics.getMetrics().PROPOSAL_LATENCY.add(latency);                }            }            if (om != null) {                final long startTime = Time.currentElapsedTime();                om.proposalReceived(qp);                ServerMetrics.getMetrics().OM_PROPOSAL_PROCESS_TIME.add(Time.currentElapsedTime() - startTime);            }            break;        case Leader.COMMIT:            ServerMetrics.getMetrics().LEARNER_COMMIT_RECEIVED_COUNT.add(1);            fzk.commit(qp.getZxid());            if (om != null) {                final long startTime = Time.currentElapsedTime();                om.proposalCommitted(qp.getZxid());                ServerMetrics.getMetrics().OM_COMMIT_PROCESS_TIME.add(Time.currentElapsedTime() - startTime);            }            break;        case Leader.COMMITANDACTIVATE:                        Request request = fzk.pendingTxns.element();            SetDataTxn setDataTxn = (SetDataTxn) request.getTxn();            QuorumVerifier qv = self.configFromString(new String(setDataTxn.getData()));                        ByteBuffer buffer = ByteBuffer.wrap(qp.getData());            long suggestedLeaderId = buffer.getLong();            final long zxid = qp.getZxid();            boolean majorChange = self.processReconfig(qv, suggestedLeaderId, zxid, true);                        fzk.commit(zxid);            if (om != null) {                om.informAndActivate(zxid, suggestedLeaderId);            }            if (majorChange) {                throw new Exception("changes proposed in reconfig");            }            break;        case Leader.UPTODATE:                        break;        case Leader.REVALIDATE:            if (om == null || !om.revalidateLearnerSession(qp)) {                revalidate(qp);            }            break;        case Leader.SYNC:            fzk.sync();            break;        default:                        break;    }}
getZxid
public longf2414_1)
{    try {        synchronized (fzk) {            return fzk.getZxid();        }    } catch (NullPointerException e) {            }    return -1;}
getLastQueued
protected long zookeeper_f2415_0()
{    return lastQueued;}
getSyncedObserverSize
public Integer zookeeper_f2416_0()
{    return om == null ? null : om.getNumActiveObservers();}
getSyncedObserversInfo
public Iterable<Map<String, Object>> zookeeper_f2417_0()
{    if (om != null && om.getNumActiveObservers() > 0) {        return om.getActiveObservers();    }    return Collections.emptySet();}
resetObserverConnectionStats
public void zookeeper_f2418_0()
{    if (om != null && om.getNumActiveObservers() > 0) {        om.resetObserverConnectionStats();    }}
shutdown
public voidf2419_1)
{        super.shutdown();}
getName
public String zookeeper_f2420_0()
{    return "Follower";}
getQuorumAddress
public String zookeeper_f2421_0()
{    return follower.sock.toString();}
getLastQueuedZxid
public String zookeeper_f2422_0()
{    return "0x" + Long.toHexString(follower.getLastQueued());}
getPendingRevalidationCount
public int zookeeper_f2423_0()
{    return follower.getPendingRevalidationsCount();}
getElectionTimeTaken
public long zookeeper_f2424_0()
{    return follower.self.getElectionTimeTaken();}
getObserverMasterPacketSizeLimit
public int zookeeper_f2425_0()
{    return follower.om == null ? -1 : follower.om.getPktsSizeLimit();}
setObserverMasterPacketSizeLimit
public void zookeeper_f2426_0(int sizeLimit)
{    ObserverMaster.setPktsSizeLimit(sizeLimit);}
getMaxConcurrentSnapSyncs
public int zookeeper_f2427_0()
{    final ObserverMaster om = follower.om;    return om == null ? -1 : om.getMaxConcurrentSnapSyncs();}
setMaxConcurrentSnapSyncs
public void zookeeper_f2428_0(int maxConcurrentSnapshots)
{    final ObserverMaster om = follower.om;    if (om != null) {        om.setMaxConcurrentSnapSyncs(maxConcurrentSnapshots);    }}
getMaxConcurrentDiffSyncs
public int zookeeper_f2429_0()
{    final ObserverMaster om = follower.om;    return om == null ? -1 : om.getMaxConcurrentDiffSyncs();}
setMaxConcurrentDiffSyncs
public void zookeeper_f2430_0(int maxConcurrentDiffSyncs)
{    final ObserverMaster om = follower.om;    if (om != null) {        om.setMaxConcurrentDiffSyncs(maxConcurrentDiffSyncs);    }}
run
public voidf2431_1)
{    try {        while (!finished) {            Request request = queuedRequests.take();            if (LOG.isTraceEnabled()) {                ZooTrace.logRequest(LOG, ZooTrace.CLIENT_REQUEST_TRACE_MASK, 'F', request, "");            }            if (request == Request.requestOfDeath) {                break;            }                        if (!zks.authWriteRequest(request)) {                continue;            }                                                nextProcessor.processRequest(request);                        switch(request.type) {                case OpCode.sync:                    zks.pendingSyncs.add(request);                    zks.getFollower().request(request);                    break;                case OpCode.create:                case OpCode.create2:                case OpCode.createTTL:                case OpCode.createContainer:                case OpCode.delete:                case OpCode.deleteContainer:                case OpCode.setData:                case OpCode.reconfig:                case OpCode.setACL:                case OpCode.multi:                case OpCode.check:                    zks.getFollower().request(request);                    break;                case OpCode.createSession:                case OpCode.closeSession:                                        if (!request.isLocalSession()) {                        zks.getFollower().request(request);                    }                    break;            }        }    } catch (Exception e) {        handleException(this.getName(), e);    }    }
processRequest
public void zookeeper_f2432_0(Request request)
{    processRequest(request, true);}
processRequest
 voidf2433_1Request request, boolean checkForUpgrade)
{    if (!finished) {        if (checkForUpgrade) {                                                Request upgradeRequest = null;            try {                upgradeRequest = zks.checkUpgradeSession(request);            } catch (KeeperException ke) {                if (request.getHdr() != null) {                    request.getHdr().setType(OpCode.error);                    request.setTxn(new ErrorTxn(ke.code().intValue()));                }                request.setException(ke);                            } catch (IOException ie) {                            }            if (upgradeRequest != null) {                queuedRequests.add(upgradeRequest);            }        }        queuedRequests.add(request);    }}
shutdown
public voidf2434_1)
{        finished = true;    queuedRequests.clear();    queuedRequests.add(Request.requestOfDeath);    nextProcessor.shutdown();}
getFollower
public Follower zookeeper_f2435_0()
{    return self.follower;}
setupRequestProcessors
protected void zookeeper_f2436_0()
{    RequestProcessor finalProcessor = new FinalRequestProcessor(this);    commitProcessor = new CommitProcessor(finalProcessor, Long.toString(getServerId()), true, getZooKeeperServerListener());    commitProcessor.start();    firstProcessor = new FollowerRequestProcessor(this, commitProcessor);    ((FollowerRequestProcessor) firstProcessor).start();    syncProcessor = new SyncRequestProcessor(this, new SendAckRequestProcessor(getFollower()));    syncProcessor.start();}
logRequest
public void zookeeper_f2437_0(TxnHeader hdr, Record txn)
{    Request request = new Request(hdr.getClientId(), hdr.getCxid(), hdr.getType(), hdr, txn, hdr.getZxid());    if ((request.zxid & 0xffffffffL) != 0) {        pendingTxns.add(request);    }    syncProcessor.processRequest(request);}
commit
public voidf2438_1long zxid)
{    if (pendingTxns.size() == 0) {                return;    }    long firstElementZxid = pendingTxns.element().zxid;    if (firstElementZxid != zxid) {                System.exit(ExitCode.UNMATCHED_TXN_COMMIT.getValue());    }    Request request = pendingTxns.remove();    request.logLatency(ServerMetrics.getMetrics().COMMIT_PROPAGATION_LATENCY);    commitProcessor.commit(request);}
sync
public synchronized voidf2439_1)
{    if (pendingSyncs.size() == 0) {                return;    }    Request r = pendingSyncs.remove();    if (r instanceof LearnerSyncRequest) {        LearnerSyncRequest lsr = (LearnerSyncRequest) r;        lsr.fh.queuePacket(new QuorumPacket(Leader.SYNC, 0, null, null));    }    commitProcessor.commit(r);}
getGlobalOutstandingLimit
public int zookeeper_f2440_0()
{    int divisor = self.getQuorumSize() > 2 ? self.getQuorumSize() - 1 : 1;    int globalOutstandingLimit = super.getGlobalOutstandingLimit() / divisor;    return globalOutstandingLimit;}
getState
public String zookeeper_f2441_0()
{    return "follower";}
getLearner
public Learner zookeeper_f2442_0()
{    return getFollower();}
processObserverRequest
 void zookeeper_f2443_0(Request request)
{    ((FollowerRequestProcessor) firstProcessor).processRequest(request, false);}
registerJMX
 booleanf2444_1LearnerHandlerBean handlerBean)
{    try {        MBeanRegistry.getInstance().register(handlerBean, jmxServerBean);        return true;    } catch (JMException e) {            }    return false;}
registerMetrics
protected void zookeeper_f2445_0()
{    super.registerMetrics();    MetricsContext rootContext = ServerMetrics.getMetrics().getMetricsProvider().getRootContext();    rootContext.registerGauge("synced_observers", self::getSynced_observers_metric);}
unregisterMetrics
protected void zookeeper_f2446_0()
{    super.unregisterMetrics();    MetricsContext rootContext = ServerMetrics.getMetrics().getMetricsProvider().getRootContext();    rootContext.unregisterGauge("synced_observers");}
toString
public String zookeeper_f2447_0()
{    return packet.getType() + ", " + packet.getZxid() + ", " + request;}
setAckLoggingFrequency
public static void zookeeper_f2448_0(int frequency)
{    ackLoggingFrequency = frequency;}
getAckLoggingFrequency
public static int zookeeper_f2449_0()
{    return ackLoggingFrequency;}
getProposalStats
public BufferStats zookeeper_f2450_0()
{    return proposalStats;}
getLearners
public List<LearnerHandler> zookeeper_f2451_0()
{    synchronized (learners) {        return new ArrayList<LearnerHandler>(learners);    }}
getForwardingFollowers
public List<LearnerHandler> zookeeper_f2452_0()
{    synchronized (forwardingFollowers) {        return new ArrayList<LearnerHandler>(forwardingFollowers);    }}
getNonVotingFollowers
public List<LearnerHandler> zookeeper_f2453_0()
{    List<LearnerHandler> nonVotingFollowers = new ArrayList<LearnerHandler>();    synchronized (forwardingFollowers) {        for (LearnerHandler lh : forwardingFollowers) {            if (!isParticipant(lh.getSid())) {                nonVotingFollowers.add(lh);            }        }    }    return nonVotingFollowers;}
addForwardingFollower
 void zookeeper_f2454_0(LearnerHandler lh)
{    synchronized (forwardingFollowers) {        forwardingFollowers.add(lh);    }}
getObservingLearners
public List<LearnerHandler> zookeeper_f2455_0()
{    synchronized (observingLearners) {        return new ArrayList<LearnerHandler>(observingLearners);    }}
addObserverLearnerHandler
private void zookeeper_f2456_0(LearnerHandler lh)
{    synchronized (observingLearners) {        observingLearners.add(lh);    }}
getObservingLearnersInfo
public Iterable<Map<String, Object>> zookeeper_f2457_0()
{    Set<Map<String, Object>> info = new HashSet<>();    synchronized (observingLearners) {        for (LearnerHandler lh : observingLearners) {            info.add(lh.getLearnerHandlerInfo());        }    }    return info;}
resetObserverConnectionStats
public void zookeeper_f2458_0()
{    synchronized (observingLearners) {        for (LearnerHandler lh : observingLearners) {            lh.resetObserverConnectionStats();        }    }}
getNumPendingSyncs
public synchronized int zookeeper_f2459_0()
{    return pendingSyncs.size();}
addLearnerHandler
public void zookeeper_f2460_0(LearnerHandler learner)
{    synchronized (learners) {        learners.add(learner);    }}
removeLearnerHandler
public void zookeeper_f2461_0(LearnerHandler peer)
{    synchronized (forwardingFollowers) {        forwardingFollowers.remove(peer);    }    synchronized (learners) {        learners.remove(peer);    }    synchronized (observingLearners) {        observingLearners.remove(peer);    }}
isLearnerSynced
 boolean zookeeper_f2462_0(LearnerHandler peer)
{    synchronized (forwardingFollowers) {        return forwardingFollowers.contains(peer);    }}
isQuorumSynced
public boolean zookeeper_f2463_0(QuorumVerifier qv)
{    HashSet<Long> ids = new HashSet<Long>();    if (qv.getVotingMembers().containsKey(self.getId())) {        ids.add(self.getId());    }    synchronized (forwardingFollowers) {        for (LearnerHandler learnerHandler : forwardingFollowers) {            if (learnerHandler.synced() && qv.getVotingMembers().containsKey(learnerHandler.getSid())) {                ids.add(learnerHandler.getSid());            }        }    }    return qv.containsQuorum(ids);}
run
public voidf2464_1)
{    try {        while (!stop) {            Socket s = null;            boolean error = false;            try {                s = ss.accept();                                                s.setSoTimeout(self.tickTime * self.initLimit);                s.setTcpNoDelay(nodelay);                BufferedInputStream is = new BufferedInputStream(s.getInputStream());                LearnerHandler fh = new LearnerHandler(s, is, Leader.this);                fh.start();            } catch (SocketException e) {                error = true;                if (stop) {                                                                                                    stop = true;                } else {                    throw e;                }            } catch (SaslException e) {                                error = true;            } catch (Exception e) {                error = true;                throw e;            } finally {                                if (error && s != null && !s.isClosed()) {                    try {                        s.close();                    } catch (IOException e) {                                            }                }            }        }    } catch (Exception e) {                handleException(this.getName(), e);    }}
halt
public void zookeeper_f2465_0()
{    stop = true;}
getUptime
public long zookeeper_f2466_0()
{    if (leaderStartTime > 0) {        return Time.currentElapsedTime() - leaderStartTime;    }    return 0;}
lead
 voidf2467_1) throws IOException, InterruptedException
{    self.end_fle = Time.currentElapsedTime();    long electionTimeTaken = self.end_fle - self.start_fle;    self.setElectionTimeTaken(electionTimeTaken);    ServerMetrics.getMetrics().ELECTION_TIME.add(electionTimeTaken);        self.start_fle = 0;    self.end_fle = 0;    zk.registerJMX(new LeaderBean(this, zk), self.jmxLocalPeerBean);    try {        self.setZabState(QuorumPeer.ZabState.DISCOVERY);        self.tick.set(0);        zk.loadData();        leaderStateSummary = new StateSummary(self.getCurrentEpoch(), zk.getLastProcessedZxid());                        cnxAcceptor = new LearnerCnxAcceptor();        cnxAcceptor.start();        long epoch = getEpochToPropose(self.getId(), self.getAcceptedEpoch());        zk.setZxid(ZxidUtils.makeZxid(epoch, 0));        synchronized (this) {            lastProposed = zk.getZxid();        }        newLeaderProposal.packet = new QuorumPacket(NEWLEADER, zk.getZxid(), null, null);        if ((newLeaderProposal.packet.getZxid() & 0xffffffffL) != 0) {                    }        QuorumVerifier lastSeenQV = self.getLastSeenQuorumVerifier();        QuorumVerifier curQV = self.getQuorumVerifier();        if (curQV.getVersion() == 0 && curQV.getVersion() == lastSeenQV.getVersion()) {                        try {                QuorumVerifier newQV = self.configFromString(curQV.toString());                newQV.setVersion(zk.getZxid());                self.setLastSeenQuorumVerifier(newQV, true);            } catch (Exception e) {                throw new IOException(e);            }        }        newLeaderProposal.addQuorumVerifier(self.getQuorumVerifier());        if (self.getLastSeenQuorumVerifier().getVersion() > self.getQuorumVerifier().getVersion()) {            newLeaderProposal.addQuorumVerifier(self.getLastSeenQuorumVerifier());        }                                waitForEpochAck(self.getId(), leaderStateSummary);        self.setCurrentEpoch(epoch);        self.setLeaderAddressAndId(self.getQuorumAddress(), self.getId());        self.setZabState(QuorumPeer.ZabState.SYNCHRONIZATION);        try {            waitForNewLeaderAck(self.getId(), zk.getZxid());        } catch (InterruptedException e) {            shutdown("Waiting for a quorum of followers, only synced with sids: [ " + newLeaderProposal.ackSetsToString() + " ]");            HashSet<Long> followerSet = new HashSet<Long>();            for (LearnerHandler f : getLearners()) {                if (self.getQuorumVerifier().getVotingMembers().containsKey(f.getSid())) {                    followerSet.add(f.getSid());                }            }            boolean initTicksShouldBeIncreased = true;            for (Proposal.QuorumVerifierAcksetPair qvAckset : newLeaderProposal.qvAcksetPairs) {                if (!qvAckset.getQuorumVerifier().containsQuorum(followerSet)) {                    initTicksShouldBeIncreased = false;                    break;                }            }            if (initTicksShouldBeIncreased) {                            }            return;        }        startZkServer();        /**         * WARNING: do not use this for anything other than QA testing         * on a real cluster. Specifically to enable verification that quorum         * can handle the lower 32bit roll-over issue identified in         * ZOOKEEPER-1277. Without this option it would take a very long         * time (on order of a month say) to see the 4 billion writes         * necessary to cause the roll-over to occur.         *         * This field allows you to override the zxid of the server. Typically         * you'll want to set it to something like 0xfffffff0 and then         * start the quorum, run some operations and see the re-election.         */        String initialZxid = System.getProperty("zookeeper.testingonly.initialZxid");        if (initialZxid != null) {            long zxid = Long.parseLong(initialZxid);            zk.setZxid((zk.getZxid() & 0xffffffff00000000L) | zxid);        }        if (!System.getProperty("zookeeper.leaderServes", "yes").equals("no")) {            self.setZooKeeperServer(zk);        }        self.setZabState(QuorumPeer.ZabState.BROADCAST);        self.adminServer.setZooKeeperServer(zk);                                                                                boolean tickSkip = true;                String shutdownMessage = null;        while (true) {            synchronized (this) {                long start = Time.currentElapsedTime();                long cur = start;                long end = start + self.tickTime / 2;                while (cur < end) {                    wait(end - cur);                    cur = Time.currentElapsedTime();                }                if (!tickSkip) {                    self.tick.incrementAndGet();                }                                                                SyncedLearnerTracker syncedAckSet = new SyncedLearnerTracker();                syncedAckSet.addQuorumVerifier(self.getQuorumVerifier());                if (self.getLastSeenQuorumVerifier() != null && self.getLastSeenQuorumVerifier().getVersion() > self.getQuorumVerifier().getVersion()) {                    syncedAckSet.addQuorumVerifier(self.getLastSeenQuorumVerifier());                }                syncedAckSet.addAck(self.getId());                for (LearnerHandler f : getLearners()) {                    if (f.synced()) {                        syncedAckSet.addAck(f.getSid());                    }                }                                if (!this.isRunning()) {                                        shutdownMessage = "Unexpected internal error";                    break;                }                if (!tickSkip && !syncedAckSet.hasAllQuorums()) {                                                            shutdownMessage = "Not sufficient followers synced, only synced with sids: [ " + syncedAckSet.ackSetsToString() + " ]";                    break;                }                tickSkip = !tickSkip;            }            for (LearnerHandler f : getLearners()) {                f.ping();            }        }        if (shutdownMessage != null) {            shutdown(shutdownMessage);                }    } finally {        zk.unregisterJMX(this);    }}
shutdown
 voidf2468_1String reason)
{        if (isShutdown) {        return;    }        if (cnxAcceptor != null) {        cnxAcceptor.halt();    }        self.setZooKeeperServer(null);    self.adminServer.setZooKeeperServer(null);    try {        ss.close();    } catch (IOException e) {            }    self.closeAllConnections();        if (zk != null) {        zk.shutdown();    }    synchronized (learners) {        for (Iterator<LearnerHandler> it = learners.iterator(); it.hasNext(); ) {            LearnerHandler f = it.next();            it.remove();            f.shutdown();        }    }    isShutdown = true;}
getDesignatedLeader
private long zookeeper_f2469_0(Proposal reconfigProposal, long zxid)
{        Proposal.QuorumVerifierAcksetPair newQVAcksetPair = reconfigProposal.qvAcksetPairs.get(reconfigProposal.qvAcksetPairs.size() - 1);        if (newQVAcksetPair.getQuorumVerifier().getVotingMembers().containsKey(self.getId()) && newQVAcksetPair.getQuorumVerifier().getVotingMembers().get(self.getId()).addr.equals(self.getQuorumAddress())) {        return self.getId();    }                HashSet<Long> candidates = new HashSet<Long>(newQVAcksetPair.getAckset());        candidates.remove(self.getId());    long curCandidate = candidates.iterator().next();            long curZxid = zxid + 1;    Proposal p = outstandingProposals.get(curZxid);    while (p != null && !candidates.isEmpty()) {        for (Proposal.QuorumVerifierAcksetPair qvAckset : p.qvAcksetPairs) {                        candidates.retainAll(qvAckset.getAckset());                        if (candidates.isEmpty()) {                return curCandidate;            }                        curCandidate = candidates.iterator().next();            if (candidates.size() == 1) {                return curCandidate;            }        }        curZxid++;        p = outstandingProposals.get(curZxid);    }    return curCandidate;}
tryToCommit
public synchronized booleanf2470_1Proposal p, long zxid, SocketAddress followerAddr)
{        if (outstandingProposals.containsKey(zxid - 1)) {        return false;    }        if (!p.hasAllQuorums()) {        return false;    }        if (zxid != lastCommitted + 1) {                    }    outstandingProposals.remove(zxid);    if (p.request != null) {        toBeApplied.add(p);    }    if (p.request == null) {            } else if (p.request.getHdr().getType() == OpCode.reconfig) {                                                Long designatedLeader = getDesignatedLeader(p, zxid);                QuorumVerifier newQV = p.qvAcksetPairs.get(p.qvAcksetPairs.size() - 1).getQuorumVerifier();        self.processReconfig(newQV, designatedLeader, zk.getZxid(), true);        if (designatedLeader != self.getId()) {            allowedToCommit = false;        }                                commitAndActivate(zxid, designatedLeader);        informAndActivate(p, designatedLeader);        } else {        p.request.logLatency(ServerMetrics.getMetrics().QUORUM_ACK_LATENCY);        commit(zxid);        inform(p);    }    zk.commitProcessor.commit(p.request);    if (pendingSyncs.containsKey(zxid)) {        for (LearnerSyncRequest r : pendingSyncs.remove(zxid)) {            sendSync(r);        }    }    return true;}
processAck
public synchronized voidf2471_1long sid, long zxid, SocketAddress followerAddr)
{    if (!allowedToCommit) {                return;    }        if (LOG.isTraceEnabled()) {        LOG.trace("Ack zxid: 0x{}", Long.toHexString(zxid));        for (Proposal p : outstandingProposals.values()) {            long packetZxid = p.packet.getZxid();            LOG.trace("outstanding proposal: 0x{}", Long.toHexString(packetZxid));        }        LOG.trace("outstanding proposals all");    }    if ((zxid & 0xffffffffL) == 0) {        /*             * We no longer process NEWLEADER ack with this method. However,             * the learner sends an ack back to the leader after it gets             * UPTODATE, so we just ignore the message.             */        return;    }    if (outstandingProposals.size() == 0) {                return;    }    if (lastCommitted >= zxid) {        if (LOG.isDebugEnabled()) {                    }                return;    }    Proposal p = outstandingProposals.get(zxid);    if (p == null) {                return;    }    if (ackLoggingFrequency > 0 && (zxid % ackLoggingFrequency == 0)) {        p.request.logLatency(ServerMetrics.getMetrics().ACK_LATENCY, Long.toString(sid));    }    p.addAck(sid);    boolean hasCommitted = tryToCommit(p, zxid, followerAddr);    if (hasCommitted && p.request != null && p.request.getHdr().getType() == OpCode.reconfig) {        long curZxid = zxid;        while (allowedToCommit && hasCommitted && p != null) {            curZxid++;            p = outstandingProposals.get(curZxid);            if (p != null) {                hasCommitted = tryToCommit(p, curZxid, null);            }        }    }}
processRequest
public voidf2472_1Request request) throws RequestProcessorException
{    next.processRequest(request);        if (request.getHdr() != null) {        long zxid = request.getHdr().getZxid();        Iterator<Proposal> iter = leader.toBeApplied.iterator();        if (iter.hasNext()) {            Proposal p = iter.next();            if (p.request != null && p.request.zxid == zxid) {                iter.remove();                return;            }        }            }}
shutdown
public voidf2473_1)
{        next.shutdown();}
sendPacket
 void zookeeper_f2474_0(QuorumPacket qp)
{    synchronized (forwardingFollowers) {        for (LearnerHandler f : forwardingFollowers) {            f.queuePacket(qp);        }    }}
sendObserverPacket
 void zookeeper_f2475_0(QuorumPacket qp)
{    for (LearnerHandler f : getObservingLearners()) {        f.queuePacket(qp);    }}
commit
public void zookeeper_f2476_0(long zxid)
{    synchronized (this) {        lastCommitted = zxid;    }    QuorumPacket qp = new QuorumPacket(Leader.COMMIT, zxid, null, null);    sendPacket(qp);    ServerMetrics.getMetrics().COMMIT_COUNT.add(1);}
commitAndActivate
public void zookeeper_f2477_0(long zxid, long designatedLeader)
{    synchronized (this) {        lastCommitted = zxid;    }    byte[] data = new byte[8];    ByteBuffer buffer = ByteBuffer.wrap(data);    buffer.putLong(designatedLeader);    QuorumPacket qp = new QuorumPacket(Leader.COMMITANDACTIVATE, zxid, data, null);    sendPacket(qp);}
inform
public void zookeeper_f2478_0(Proposal proposal)
{    QuorumPacket qp = new QuorumPacket(Leader.INFORM, proposal.request.zxid, proposal.packet.getData(), null);    sendObserverPacket(qp);}
buildInformAndActivePacket
public static QuorumPacket zookeeper_f2479_0(long zxid, long designatedLeader, byte[] proposalData)
{    byte[] data = new byte[proposalData.length + 8];    ByteBuffer buffer = ByteBuffer.wrap(data);    buffer.putLong(designatedLeader);    buffer.put(proposalData);    return new QuorumPacket(Leader.INFORMANDACTIVATE, zxid, data, null);}
informAndActivate
public void zookeeper_f2480_0(Proposal proposal, long designatedLeader)
{    sendObserverPacket(buildInformAndActivePacket(proposal.request.zxid, designatedLeader, proposal.packet.getData()));}
getLastProposed
public synchronized long zookeeper_f2481_0()
{    return lastProposed;}
getEpoch
public long zookeeper_f2482_0()
{    return ZxidUtils.getEpochFromZxid(lastProposed);}
propose
public Proposalf2483_1Request request) throws XidRolloverException
{    /**     * Address the rollover issue. All lower 32bits set indicate a new leader     * election. Force a re-election instead. See ZOOKEEPER-1277     */    if ((request.zxid & 0xffffffffL) == 0xffffffffL) {        String msg = "zxid lower 32 bits have rolled over, forcing re-election, and therefore new epoch start";        shutdown(msg);        throw new XidRolloverException(msg);    }    byte[] data = SerializeUtils.serializeRequest(request);    proposalStats.setLastBufferSize(data.length);    QuorumPacket pp = new QuorumPacket(Leader.PROPOSAL, request.zxid, data, null);    Proposal p = new Proposal();    p.packet = pp;    p.request = request;    synchronized (this) {        p.addQuorumVerifier(self.getQuorumVerifier());        if (request.getHdr().getType() == OpCode.reconfig) {            self.setLastSeenQuorumVerifier(request.qv, true);        }        if (self.getQuorumVerifier().getVersion() < self.getLastSeenQuorumVerifier().getVersion()) {            p.addQuorumVerifier(self.getLastSeenQuorumVerifier());        }                lastProposed = p.packet.getZxid();        outstandingProposals.put(lastProposed, p);        sendPacket(pp);    }    ServerMetrics.getMetrics().PROPOSAL_COUNT.add(1);    return p;}
processSync
public synchronized void zookeeper_f2484_0(LearnerSyncRequest r)
{    if (outstandingProposals.isEmpty()) {        sendSync(r);    } else {        List<LearnerSyncRequest> l = pendingSyncs.get(lastProposed);        if (l == null) {            l = new ArrayList<LearnerSyncRequest>();        }        l.add(r);        pendingSyncs.put(lastProposed, l);    }}
sendSync
public void zookeeper_f2485_0(LearnerSyncRequest r)
{    QuorumPacket qp = new QuorumPacket(Leader.SYNC, 0, null, null);    r.fh.queuePacket(qp);}
startForwarding
public synchronized long zookeeper_f2486_0(LearnerHandler handler, long lastSeenZxid)
{        if (lastProposed > lastSeenZxid) {        for (Proposal p : toBeApplied) {            if (p.packet.getZxid() <= lastSeenZxid) {                continue;            }            handler.queuePacket(p.packet);                                    QuorumPacket qp = new QuorumPacket(Leader.COMMIT, p.packet.getZxid(), null, null);            handler.queuePacket(qp);        }                if (handler.getLearnerType() == LearnerType.PARTICIPANT) {            List<Long> zxids = new ArrayList<Long>(outstandingProposals.keySet());            Collections.sort(zxids);            for (Long zxid : zxids) {                if (zxid <= lastSeenZxid) {                    continue;                }                handler.queuePacket(outstandingProposals.get(zxid).packet);            }        }    }    if (handler.getLearnerType() == LearnerType.PARTICIPANT) {        addForwardingFollower(handler);    } else {        addObserverLearnerHandler(handler);    }    return lastProposed;}
waitForStartup
public void zookeeper_f2487_0() throws InterruptedException
{    synchronized (zk) {        while (!zk.isRunning() && !Thread.currentThread().isInterrupted()) {            zk.wait(20);        }    }}
setMaxTimeToWaitForEpoch
public static voidf2488_1int maxTimeToWaitForEpoch)
{    Leader.maxTimeToWaitForEpoch = maxTimeToWaitForEpoch;    }
quitLeading
private voidf2489_1)
{    synchronized (connectingFollowers) {        quitWaitForEpoch = true;        connectingFollowers.notifyAll();    }    ServerMetrics.getMetrics().QUIT_LEADING_DUE_TO_DISLOYAL_VOTER.add(1);    }
setLeadingVoteSet
public void zookeeper_f2490_0(SyncedLearnerTracker voteSet)
{    this.voteSet = voteSet;}
reportLookingSid
public void zookeeper_f2491_0(long sid)
{    if (maxTimeToWaitForEpoch < 0 || timeStartWaitForEpoch < 0 || !waitingForNewEpoch) {        return;    }    if (voteSet == null || !voteSet.hasSid(sid)) {        return;    }    if (Time.currentElapsedTime() - timeStartWaitForEpoch > maxTimeToWaitForEpoch) {        quitLeading();    }}
getEpochToPropose
public long zookeeper_f2492_0(long sid, long lastAcceptedEpoch) throws InterruptedException, IOException
{    synchronized (connectingFollowers) {        if (!waitingForNewEpoch) {            return epoch;        }        if (lastAcceptedEpoch >= epoch) {            epoch = lastAcceptedEpoch + 1;        }        if (isParticipant(sid)) {            connectingFollowers.add(sid);        }        QuorumVerifier verifier = self.getQuorumVerifier();        if (connectingFollowers.contains(self.getId()) && verifier.containsQuorum(connectingFollowers)) {            waitingForNewEpoch = false;            self.setAcceptedEpoch(epoch);            connectingFollowers.notifyAll();        } else {            long start = Time.currentElapsedTime();            if (sid == self.getId()) {                timeStartWaitForEpoch = start;            }            long cur = start;            long end = start + self.getInitLimit() * self.getTickTime();            while (waitingForNewEpoch && cur < end && !quitWaitForEpoch) {                connectingFollowers.wait(end - cur);                cur = Time.currentElapsedTime();            }            if (waitingForNewEpoch) {                throw new InterruptedException("Timeout while waiting for epoch from quorum");            }        }        return epoch;    }}
getZKDatabase
public ZKDatabase zookeeper_f2493_0()
{    return zk.getZKDatabase();}
waitForEpochAck
public void zookeeper_f2494_0(long id, StateSummary ss) throws IOException, InterruptedException
{    synchronized (electingFollowers) {        if (electionFinished) {            return;        }        if (ss.getCurrentEpoch() != -1) {            if (ss.isMoreRecentThan(leaderStateSummary)) {                throw new IOException("Follower is ahead of the leader, leader summary: " + leaderStateSummary.getCurrentEpoch() + " (current epoch), " + leaderStateSummary.getLastZxid() + " (last zxid)");            }            if (ss.getLastZxid() != -1 && isParticipant(id)) {                electingFollowers.add(id);            }        }        QuorumVerifier verifier = self.getQuorumVerifier();        if (electingFollowers.contains(self.getId()) && verifier.containsQuorum(electingFollowers)) {            electionFinished = true;            electingFollowers.notifyAll();        } else {            long start = Time.currentElapsedTime();            long cur = start;            long end = start + self.getInitLimit() * self.getTickTime();            while (!electionFinished && cur < end) {                electingFollowers.wait(end - cur);                cur = Time.currentElapsedTime();            }            if (!electionFinished) {                throw new InterruptedException("Timeout while waiting for epoch to be acked by quorum");            }        }    }}
getSidSetString
private String zookeeper_f2495_0(Set<Long> sidSet)
{    StringBuilder sids = new StringBuilder();    Iterator<Long> iter = sidSet.iterator();    while (iter.hasNext()) {        sids.append(iter.next());        if (!iter.hasNext()) {            break;        }        sids.append(",");    }    return sids.toString();}
waitForNewLeaderAck
public voidf2497_1long sid, long zxid) throws InterruptedException
{    synchronized (newLeaderProposal.qvAcksetPairs) {        if (quorumFormed) {            return;        }        long currentZxid = newLeaderProposal.packet.getZxid();        if (zxid != currentZxid) {                        return;        }        /*             * Note that addAck already checks that the learner             * is a PARTICIPANT.             */        newLeaderProposal.addAck(sid);        if (newLeaderProposal.hasAllQuorums()) {            quorumFormed = true;            newLeaderProposal.qvAcksetPairs.notifyAll();        } else {            long start = Time.currentElapsedTime();            long cur = start;            long end = start + self.getInitLimit() * self.getTickTime();            while (!quorumFormed && cur < end) {                newLeaderProposal.qvAcksetPairs.wait(end - cur);                cur = Time.currentElapsedTime();            }            if (!quorumFormed) {                throw new InterruptedException("Timeout while waiting for NEWLEADER to be acked by quorum");            }        }    }}
getPacketType
public static String zookeeper_f2498_0(int packetType)
{    switch(packetType) {        case DIFF:            return "DIFF";        case TRUNC:            return "TRUNC";        case SNAP:            return "SNAP";        case OBSERVERINFO:            return "OBSERVERINFO";        case NEWLEADER:            return "NEWLEADER";        case FOLLOWERINFO:            return "FOLLOWERINFO";        case UPTODATE:            return "UPTODATE";        case LEADERINFO:            return "LEADERINFO";        case ACKEPOCH:            return "ACKEPOCH";        case REQUEST:            return "REQUEST";        case PROPOSAL:            return "PROPOSAL";        case ACK:            return "ACK";        case COMMIT:            return "COMMIT";        case COMMITANDACTIVATE:            return "COMMITANDACTIVATE";        case PING:            return "PING";        case REVALIDATE:            return "REVALIDATE";        case SYNC:            return "SYNC";        case INFORM:            return "INFORM";        case INFORMANDACTIVATE:            return "INFORMANDACTIVATE";        default:            return "UNKNOWN";    }}
isRunning
private boolean zookeeper_f2499_0()
{    return self.isRunning() && zk.isRunning();}
isParticipant
private boolean zookeeper_f2500_0(long sid)
{    return self.getQuorumVerifier().getVotingMembers().containsKey(sid);}
getCurrentTick
public int zookeeper_f2501_0()
{    return self.tick.get();}
syncTimeout
public int zookeeper_f2502_0()
{    return self.tickTime * self.syncLimit;}
getTickOfNextAckDeadline
public int zookeeper_f2503_0()
{    return self.tick.get() + self.syncLimit;}
getTickOfInitialAckDeadline
public int zookeeper_f2504_0()
{    return self.tick.get() + self.initLimit + self.syncLimit;}
getAndDecrementFollowerCounter
public long zookeeper_f2505_0()
{    return followerCounter.getAndDecrement();}
touch
public void zookeeper_f2506_0(long sess, int to)
{    zk.touch(sess, to);}
submitLearnerRequest
public void zookeeper_f2507_0(Request si)
{    zk.submitLearnerRequest(si);}
getQuorumVerifierVersion
public long zookeeper_f2508_0()
{    return self.getQuorumVerifier().getVersion();}
getPeerInfo
public String zookeeper_f2509_0(long sid)
{    QuorumPeer.QuorumServer server = self.getView().get(sid);    return server == null ? "" : server.toString();}
getQuorumVerifierBytes
public byte[] zookeeper_f2510_0()
{    return self.getLastSeenQuorumVerifier().toString().getBytes();}
getQuorumAuthServer
public QuorumAuthServer zookeeper_f2511_0()
{    return (self == null) ? null : self.authServer;}
revalidateSession
public voidf2512_1QuorumPacket qp, LearnerHandler learnerHandler) throws IOException
{    ByteArrayInputStream bis = new ByteArrayInputStream(qp.getData());    DataInputStream dis = new DataInputStream(bis);    long id = dis.readLong();    int to = dis.readInt();    ByteArrayOutputStream bos = new ByteArrayOutputStream();    DataOutputStream dos = new DataOutputStream(bos);    dos.writeLong(id);    boolean valid = zk.checkIfValidGlobalSession(id, to);    if (valid) {        try {                        zk.setOwner(id, learnerHandler);        } catch (KeeperException.SessionExpiredException e) {                    }    }    if (LOG.isTraceEnabled()) {        ZooTrace.logTraceMessage(LOG, ZooTrace.SESSION_TRACE_MASK, "Session 0x" + Long.toHexString(id) + " is valid: " + valid);    }    dos.writeBoolean(valid);    qp.setData(bos.toByteArray());    learnerHandler.queuePacket(qp);}
registerLearnerHandlerBean
public void zookeeper_f2513_0(final LearnerHandler learnerHandler, Socket socket)
{    LearnerHandlerBean bean = new LearnerHandlerBean(learnerHandler, socket);    if (zk.registerJMX(bean)) {        connectionBeans.put(learnerHandler, bean);    }}
unregisterLearnerHandlerBean
public void zookeeper_f2514_0(final LearnerHandler learnerHandler)
{    LearnerHandlerBean bean = connectionBeans.remove(learnerHandler);    if (bean != null) {        MBeanRegistry.getInstance().unregister(bean);    }}
getName
public String zookeeper_f2515_0()
{    return "Leader";}
getCurrentZxid
public String zookeeper_f2516_0()
{    return "0x" + Long.toHexString(zks.getZxid());}
followerInfo
public String zookeeper_f2517_0()
{    StringBuilder sb = new StringBuilder();    for (LearnerHandler handler : leader.getLearners()) {        if (handler.getLearnerType() == LearnerType.PARTICIPANT) {            sb.append(handler.toString()).append("\n");        }    }    return sb.toString();}
nonVotingFollowerInfo
public String zookeeper_f2518_0()
{    StringBuilder sb = new StringBuilder();    for (LearnerHandler handler : leader.getNonVotingFollowers()) {        sb.append(handler.toString()).append("\n");    }    return sb.toString();}
getElectionTimeTaken
public long zookeeper_f2519_0()
{    return leader.self.getElectionTimeTaken();}
getLastProposalSize
public int zookeeper_f2520_0()
{    return leader.getProposalStats().getLastBufferSize();}
getMinProposalSize
public int zookeeper_f2521_0()
{    return leader.getProposalStats().getMinBufferSize();}
getMaxProposalSize
public int zookeeper_f2522_0()
{    return leader.getProposalStats().getMaxBufferSize();}
resetProposalStatistics
public void zookeeper_f2523_0()
{    leader.getProposalStats().reset();}
getMaxConcurrentSnapSyncs
public int zookeeper_f2524_0()
{    return leader.getMaxConcurrentSnapSyncs();}
setMaxConcurrentSnapSyncs
public void zookeeper_f2525_0(int maxConcurrentSnapshots)
{    leader.setMaxConcurrentSnapSyncs(maxConcurrentSnapshots);}
getMaxConcurrentDiffSyncs
public int zookeeper_f2526_0()
{    return leader.getMaxConcurrentDiffSyncs();}
setMaxConcurrentDiffSyncs
public void zookeeper_f2527_0(int maxConcurrentDiffSyncs)
{    leader.setMaxConcurrentDiffSyncs(maxConcurrentDiffSyncs);}
getName
public String zookeeper_f2528_0()
{    return "LeaderElection";}
isHidden
public boolean zookeeper_f2529_0()
{    return false;}
getStartTime
public String zookeeper_f2530_0()
{    return startTime.toString();}
processRequest
public voidf2531_1Request request) throws RequestProcessorException
{        if (!lzks.authWriteRequest(request)) {        return;    }            Request upgradeRequest = null;    try {        upgradeRequest = lzks.checkUpgradeSession(request);    } catch (KeeperException ke) {        if (request.getHdr() != null) {                        request.getHdr().setType(OpCode.error);            request.setTxn(new ErrorTxn(ke.code().intValue()));        }        request.setException(ke);            } catch (IOException ie) {            }    if (upgradeRequest != null) {        nextProcessor.processRequest(upgradeRequest);    }    nextProcessor.processRequest(request);}
shutdown
public voidf2532_1)
{        nextProcessor.shutdown();}
removeSession
public void zookeeper_f2533_0(long sessionId)
{    if (localSessionTracker != null) {        localSessionTracker.removeSession(sessionId);    }    globalSessionTracker.removeSession(sessionId);}
start
public void zookeeper_f2534_0()
{    globalSessionTracker.start();    if (localSessionTracker != null) {        localSessionTracker.start();    }}
shutdown
public void zookeeper_f2535_0()
{    if (localSessionTracker != null) {        localSessionTracker.shutdown();    }    globalSessionTracker.shutdown();}
isGlobalSession
public boolean zookeeper_f2536_0(long sessionId)
{    return globalSessionTracker.isTrackingSession(sessionId);}
trackSession
public booleanf2537_1long sessionId, int sessionTimeout)
{    boolean tracked = globalSessionTracker.trackSession(sessionId, sessionTimeout);    if (localSessionsEnabled && tracked) {                            }    return tracked;}
commitSession
public synchronized booleanf2538_1long sessionId, int sessionTimeout)
{    boolean added = globalSessionTracker.commitSession(sessionId, sessionTimeout);    if (added) {            }        if (localSessionsEnabled) {        removeLocalSession(sessionId);        finishedUpgrading(sessionId);    }    return added;}
touchSession
public boolean zookeeper_f2539_0(long sessionId, int sessionTimeout)
{    if (localSessionTracker != null && localSessionTracker.touchSession(sessionId, sessionTimeout)) {        return true;    }    return globalSessionTracker.touchSession(sessionId, sessionTimeout);}
createSession
public long zookeeper_f2540_0(int sessionTimeout)
{    if (localSessionsEnabled) {        return localSessionTracker.createSession(sessionTimeout);    }    return globalSessionTracker.createSession(sessionTimeout);}
getServerIdFromSessionId
public static long zookeeper_f2541_0(long sessionId)
{    return sessionId >> 56;}
checkSession
public void zookeeper_f2542_0(long sessionId, Object owner) throws SessionExpiredException, SessionMovedException, UnknownSessionException
{    if (localSessionTracker != null) {        try {            localSessionTracker.checkSession(sessionId, owner);                        if (!isGlobalSession(sessionId)) {                return;            }        } catch (UnknownSessionException e) {                }    }    try {        globalSessionTracker.checkSession(sessionId, owner);                return;    } catch (UnknownSessionException e) {        }    /*         * if local session is not enabled or it used to be our local session         * throw sessions expires         */    if (!localSessionsEnabled || (getServerIdFromSessionId(sessionId) == serverId)) {        throw new SessionExpiredException();    }}
checkGlobalSession
public void zookeeper_f2543_0(long sessionId, Object owner) throws SessionExpiredException, SessionMovedException
{    try {        globalSessionTracker.checkSession(sessionId, owner);    } catch (UnknownSessionException e) {                throw new SessionExpiredException();    }}
setOwner
public void zookeeper_f2544_0(long sessionId, Object owner) throws SessionExpiredException
{    if (localSessionTracker != null) {        try {            localSessionTracker.setOwner(sessionId, owner);            return;        } catch (SessionExpiredException e) {                }    }    globalSessionTracker.setOwner(sessionId, owner);}
dumpSessions
public void zookeeper_f2545_0(PrintWriter pwriter)
{    if (localSessionTracker != null) {        pwriter.print("Local ");        localSessionTracker.dumpSessions(pwriter);        pwriter.print("Global ");    }    globalSessionTracker.dumpSessions(pwriter);}
setSessionClosing
public void zookeeper_f2546_0(long sessionId)
{        if (localSessionTracker != null) {        localSessionTracker.setSessionClosing(sessionId);    }    globalSessionTracker.setSessionClosing(sessionId);}
getSessionExpiryMap
public Map<Long, Set<Long>> zookeeper_f2547_0()
{    Map<Long, Set<Long>> sessionExpiryMap;        if (localSessionTracker != null) {        sessionExpiryMap = localSessionTracker.getSessionExpiryMap();    } else {        sessionExpiryMap = new TreeMap<Long, Set<Long>>();    }    sessionExpiryMap.putAll(globalSessionTracker.getSessionExpiryMap());    return sessionExpiryMap;}
getLeader
public Leader zookeeper_f2548_0()
{    return self.leader;}
setupRequestProcessors
protected void zookeeper_f2549_0()
{    RequestProcessor finalProcessor = new FinalRequestProcessor(this);    RequestProcessor toBeAppliedProcessor = new Leader.ToBeAppliedRequestProcessor(finalProcessor, getLeader());    commitProcessor = new CommitProcessor(toBeAppliedProcessor, Long.toString(getServerId()), false, getZooKeeperServerListener());    commitProcessor.start();    ProposalRequestProcessor proposalProcessor = new ProposalRequestProcessor(this, commitProcessor);    proposalProcessor.initialize();    prepRequestProcessor = new PrepRequestProcessor(this, proposalProcessor);    prepRequestProcessor.start();    firstProcessor = new LeaderRequestProcessor(this, prepRequestProcessor);    setupContainerManager();}
setupContainerManager
private synchronized void zookeeper_f2550_0()
{    containerManager = new ContainerManager(getZKDatabase(), prepRequestProcessor, Integer.getInteger("znode.container.checkIntervalMs", (int) TimeUnit.MINUTES.toMillis(1)), Integer.getInteger("znode.container.maxPerMinute", 10000));}
startup
public synchronized void zookeeper_f2551_0()
{    super.startup();    if (containerManager != null) {        containerManager.start();    }}
registerMetrics
protected void zookeeper_f2552_0()
{    super.registerMetrics();    MetricsContext rootContext = ServerMetrics.getMetrics().getMetricsProvider().getRootContext();    rootContext.registerGauge("learners", () -> {        return getLeader().getLearners().size();    });    rootContext.registerGauge("synced_followers", () -> {        return getLeader().getForwardingFollowers().size();    });    rootContext.registerGauge("synced_non_voting_followers", () -> {        return getLeader().getNonVotingFollowers().size();    });    rootContext.registerGauge("synced_observers", self::getSynced_observers_metric);    rootContext.registerGauge("pending_syncs", () -> {        return getLeader().getNumPendingSyncs();    });    rootContext.registerGauge("leader_uptime", () -> {        return getLeader().getUptime();    });    rootContext.registerGauge("last_proposal_size", () -> {        return getLeader().getProposalStats().getLastBufferSize();    });    rootContext.registerGauge("max_proposal_size", () -> {        return getLeader().getProposalStats().getMaxBufferSize();    });    rootContext.registerGauge("min_proposal_size", () -> {        return getLeader().getProposalStats().getMinBufferSize();    });}
unregisterMetrics
protected void zookeeper_f2553_0()
{    super.unregisterMetrics();    MetricsContext rootContext = ServerMetrics.getMetrics().getMetricsProvider().getRootContext();    rootContext.unregisterGauge("learners");    rootContext.unregisterGauge("synced_followers");    rootContext.unregisterGauge("synced_non_voting_followers");    rootContext.unregisterGauge("synced_observers");    rootContext.unregisterGauge("pending_syncs");    rootContext.unregisterGauge("leader_uptime");    rootContext.unregisterGauge("last_proposal_size");    rootContext.unregisterGauge("max_proposal_size");    rootContext.unregisterGauge("min_proposal_size");}
shutdown
public synchronized void zookeeper_f2554_0()
{    if (containerManager != null) {        containerManager.stop();    }    super.shutdown();}
getGlobalOutstandingLimit
public int zookeeper_f2555_0()
{    int divisor = self.getQuorumSize() > 2 ? self.getQuorumSize() - 1 : 1;    int globalOutstandingLimit = super.getGlobalOutstandingLimit() / divisor;    return globalOutstandingLimit;}
createSessionTracker
public void zookeeper_f2556_0()
{    sessionTracker = new LeaderSessionTracker(this, getZKDatabase().getSessionWithTimeOuts(), tickTime, self.getId(), self.areLocalSessionsEnabled(), getZooKeeperServerListener());}
touch
public boolean zookeeper_f2557_0(long sess, int to)
{    return sessionTracker.touchSession(sess, to);}
checkIfValidGlobalSession
public boolean zookeeper_f2558_0(long sess, int to)
{    if (self.areLocalSessionsEnabled() && !upgradeableSessionTracker.isGlobalSession(sess)) {        return false;    }    return sessionTracker.touchSession(sess, to);}
submitLearnerRequest
public void zookeeper_f2559_0(Request request)
{    /*         * Requests coming from the learner should have gone through         * submitRequest() on each server which already perform some request         * validation, so we don't need to do it again.         *         * Additionally, LearnerHandler should start submitting requests into         * the leader's pipeline only when the leader's server is started, so we         * can submit the request directly into PrepRequestProcessor.         *         * This is done so that requests from learners won't go through         * LeaderRequestProcessor which perform local session upgrade.         */    prepRequestProcessor.processRequest(request);}
registerJMX
protected voidf2560_1)
{        try {        jmxDataTreeBean = new DataTreeBean(getZKDatabase().getDataTree());        MBeanRegistry.getInstance().register(jmxDataTreeBean, jmxServerBean);    } catch (Exception e) {                jmxDataTreeBean = null;    }}
registerJMX
public voidf2561_1LeaderBean leaderBean, LocalPeerBean localPeerBean)
{        if (self.jmxLeaderElectionBean != null) {        try {            MBeanRegistry.getInstance().unregister(self.jmxLeaderElectionBean);        } catch (Exception e) {                    }        self.jmxLeaderElectionBean = null;    }    try {        jmxServerBean = leaderBean;        MBeanRegistry.getInstance().register(leaderBean, localPeerBean);    } catch (Exception e) {                jmxServerBean = null;    }}
registerJMX
 booleanf2562_1LearnerHandlerBean handlerBean)
{    try {        MBeanRegistry.getInstance().register(handlerBean, jmxServerBean);        return true;    } catch (JMException e) {            }    return false;}
unregisterJMX
protected voidf2563_1)
{        try {        if (jmxDataTreeBean != null) {            MBeanRegistry.getInstance().unregister(jmxDataTreeBean);        }    } catch (Exception e) {            }    jmxDataTreeBean = null;}
unregisterJMX
protected voidf2564_1Leader leader)
{        try {        if (jmxServerBean != null) {            MBeanRegistry.getInstance().unregister(jmxServerBean);        }    } catch (Exception e) {            }    jmxServerBean = null;}
getState
public String zookeeper_f2565_0()
{    return "leader";}
getServerId
public long zookeeper_f2566_0()
{    return self.getId();}
revalidateSession
protected void zookeeper_f2567_0(ServerCnxn cnxn, long sessionId, int sessionTimeout) throws IOException
{    super.revalidateSession(cnxn, sessionId, sessionTimeout);    try {                        setOwner(sessionId, ServerCnxn.me);    } catch (SessionExpiredException e) {        }}
getSocket
public Socket zookeeper_f2568_0()
{    return sock;}
getPendingRevalidationsCount
public int zookeeper_f2569_0()
{    return pendingRevalidations.size();}
validateSession
 voidf2570_1ServerCnxn cnxn, long clientId, int timeout) throws IOException
{        ByteArrayOutputStream baos = new ByteArrayOutputStream();    DataOutputStream dos = new DataOutputStream(baos);    dos.writeLong(clientId);    dos.writeInt(timeout);    dos.close();    QuorumPacket qp = new QuorumPacket(Leader.REVALIDATE, -1, baos.toByteArray(), null);    pendingRevalidations.put(clientId, cnxn);    if (LOG.isTraceEnabled()) {        ZooTrace.logTraceMessage(LOG, ZooTrace.SESSION_TRACE_MASK, "To validate session 0x" + Long.toHexString(clientId));    }    writePacket(qp, true);}
writePacket
 void zookeeper_f2571_0(QuorumPacket pp, boolean flush) throws IOException
{    synchronized (leaderOs) {        if (pp != null) {            messageTracker.trackSent(pp.getType());            leaderOs.writeRecord(pp, "packet");        }        if (flush) {            bufferedOutput.flush();        }    }}
readPacket
 void zookeeper_f2572_0(QuorumPacket pp) throws IOException
{    synchronized (leaderIs) {        leaderIs.readRecord(pp, "packet");        messageTracker.trackReceived(pp.getType());    }    long traceMask = ZooTrace.SERVER_PACKET_TRACE_MASK;    if (pp.getType() == Leader.PING) {        traceMask = ZooTrace.SERVER_PING_TRACE_MASK;    }    if (LOG.isTraceEnabled()) {        ZooTrace.logQuorumPacket(LOG, traceMask, 'i', pp);    }}
request
 void zookeeper_f2573_0(Request request) throws IOException
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    DataOutputStream oa = new DataOutputStream(baos);    oa.writeLong(request.sessionId);    oa.writeInt(request.cxid);    oa.writeInt(request.type);    if (request.request != null) {        request.request.rewind();        int len = request.request.remaining();        byte[] b = new byte[len];        request.request.get(b);        request.request.rewind();        oa.write(b);    }    oa.close();    QuorumPacket qp = new QuorumPacket(Leader.REQUEST, -1, baos.toByteArray(), request.authInfo);    writePacket(qp, true);}
findLeader
protected QuorumServerf2574_1)
{    QuorumServer leaderServer = null;        Vote current = self.getCurrentVote();    for (QuorumServer s : self.getView().values()) {        if (s.id == current.getId()) {                                    s.recreateSocketAddresses();            leaderServer = s;            break;        }    }    if (leaderServer == null) {            }    return leaderServer;}
nanoTime
protected long zookeeper_f2575_0()
{    return System.nanoTime();}
sockConnect
protected void zookeeper_f2576_0(Socket sock, InetSocketAddress addr, int timeout) throws IOException
{    sock.connect(addr, timeout);}
connectToLeader
protected voidf2577_1InetSocketAddress addr, String hostname) throws IOException, InterruptedException, X509Exception
{    this.sock = createSocket();    this.leaderAddr = addr;        int connectTimeout = self.tickTime * self.initLimit;        if (self.connectToLearnerMasterLimit > 0) {        connectTimeout = self.tickTime * self.connectToLearnerMasterLimit;    }    int remainingTimeout;    long startNanoTime = nanoTime();    for (int tries = 0; tries < 5; tries++) {        try {                        remainingTimeout = connectTimeout - (int) ((nanoTime() - startNanoTime) / 1000000);            if (remainingTimeout <= 0) {                                throw new IOException("connectToLeader exceeded on retries.");            }            sockConnect(sock, addr, Math.min(connectTimeout, remainingTimeout));            if (self.isSslQuorum()) {                ((SSLSocket) sock).startHandshake();            }            sock.setTcpNoDelay(nodelay);            break;        } catch (IOException e) {            remainingTimeout = connectTimeout - (int) ((nanoTime() - startNanoTime) / 1000000);            if (remainingTimeout <= 1000) {                                throw e;            } else if (tries >= 4) {                                throw e;            } else {                                this.sock = createSocket();            }        }        Thread.sleep(leaderConnectDelayDuringRetryMs);    }    self.authLearner.authenticate(sock, hostname);    leaderIs = BinaryInputArchive.getArchive(new BufferedInputStream(sock.getInputStream()));    bufferedOutput = new BufferedOutputStream(sock.getOutputStream());    leaderOs = BinaryOutputArchive.getArchive(bufferedOutput);}
createSocket
private Socket zookeeper_f2578_0() throws X509Exception, IOException
{    Socket sock;    if (self.isSslQuorum()) {        sock = self.getX509Util().createSSLSocket();    } else {        sock = new Socket();    }    sock.setSoTimeout(self.tickTime * self.initLimit);    return sock;}
registerWithLeader
protected longf2579_1int pktType) throws IOException
{    /*         * Send follower info, including last zxid and sid         */    long lastLoggedZxid = self.getLastLoggedZxid();    QuorumPacket qp = new QuorumPacket();    qp.setType(pktType);    qp.setZxid(ZxidUtils.makeZxid(self.getAcceptedEpoch(), 0));    /*         * Add sid to payload         */    LearnerInfo li = new LearnerInfo(self.getId(), 0x10000, self.getQuorumVerifier().getVersion());    ByteArrayOutputStream bsid = new ByteArrayOutputStream();    BinaryOutputArchive boa = BinaryOutputArchive.getArchive(bsid);    boa.writeRecord(li, "LearnerInfo");    qp.setData(bsid.toByteArray());    writePacket(qp, true);    readPacket(qp);    final long newEpoch = ZxidUtils.getEpochFromZxid(qp.getZxid());    if (qp.getType() == Leader.LEADERINFO) {                leaderProtocolVersion = ByteBuffer.wrap(qp.getData()).getInt();        byte[] epochBytes = new byte[4];        final ByteBuffer wrappedEpochBytes = ByteBuffer.wrap(epochBytes);        if (newEpoch > self.getAcceptedEpoch()) {            wrappedEpochBytes.putInt((int) self.getCurrentEpoch());            self.setAcceptedEpoch(newEpoch);        } else if (newEpoch == self.getAcceptedEpoch()) {                                                            wrappedEpochBytes.putInt(-1);        } else {            throw new IOException("Leaders epoch, " + newEpoch + " is less than accepted epoch, " + self.getAcceptedEpoch());        }        QuorumPacket ackNewEpoch = new QuorumPacket(Leader.ACKEPOCH, lastLoggedZxid, epochBytes, null);        writePacket(ackNewEpoch, true);        return ZxidUtils.makeZxid(newEpoch, 0);    } else {        if (newEpoch > self.getAcceptedEpoch()) {            self.setAcceptedEpoch(newEpoch);        }        if (qp.getType() != Leader.NEWLEADER) {                        throw new IOException("First packet should have been NEWLEADER");        }        return qp.getZxid();    }}
syncWithLeader
protected voidf2580_1long newLeaderZxid) throws Exception
{    QuorumPacket ack = new QuorumPacket(Leader.ACK, 0, null, null);    QuorumPacket qp = new QuorumPacket();    long newEpoch = ZxidUtils.getEpochFromZxid(newLeaderZxid);    QuorumVerifier newLeaderQV = null;            boolean snapshotNeeded = true;    boolean syncSnapshot = false;    readPacket(qp);    Deque<Long> packetsCommitted = new ArrayDeque<>();    Deque<PacketInFlight> packetsNotCommitted = new ArrayDeque<>();    synchronized (zk) {        if (qp.getType() == Leader.DIFF) {                        self.setSyncMode(QuorumPeer.SyncMode.DIFF);            snapshotNeeded = false;        } else if (qp.getType() == Leader.SNAP) {            self.setSyncMode(QuorumPeer.SyncMode.SNAP);                                                zk.getZKDatabase().deserializeSnapshot(leaderIs);                        if (!QuorumPeerConfig.isReconfigEnabled()) {                                zk.getZKDatabase().initConfigInZKDatabase(self.getQuorumVerifier());            }            String signature = leaderIs.readString("signature");            if (!signature.equals("BenWasHere")) {                                throw new IOException("Missing signature");            }            zk.getZKDatabase().setlastProcessedZxid(qp.getZxid());                        syncSnapshot = true;        } else if (qp.getType() == Leader.TRUNC) {                        self.setSyncMode(QuorumPeer.SyncMode.TRUNC);                        boolean truncated = zk.getZKDatabase().truncateLog(qp.getZxid());            if (!truncated) {                                                System.exit(ExitCode.QUORUM_PACKET_ERROR.getValue());            }            zk.getZKDatabase().setlastProcessedZxid(qp.getZxid());        } else {                        System.exit(ExitCode.QUORUM_PACKET_ERROR.getValue());        }        zk.getZKDatabase().initConfigInZKDatabase(self.getQuorumVerifier());        zk.createSessionTracker();        long lastQueued = 0;                                boolean isPreZAB1_0 = true;                        boolean writeToTxnLog = !snapshotNeeded;                outerLoop: while (self.isRunning()) {            readPacket(qp);            switch(qp.getType()) {                case Leader.PROPOSAL:                    PacketInFlight pif = new PacketInFlight();                    pif.hdr = new TxnHeader();                    pif.rec = SerializeUtils.deserializeTxn(qp.getData(), pif.hdr);                    if (pif.hdr.getZxid() != lastQueued + 1) {                                            }                    lastQueued = pif.hdr.getZxid();                    if (pif.hdr.getType() == OpCode.reconfig) {                        SetDataTxn setDataTxn = (SetDataTxn) pif.rec;                        QuorumVerifier qv = self.configFromString(new String(setDataTxn.getData()));                        self.setLastSeenQuorumVerifier(qv, true);                    }                    packetsNotCommitted.add(pif);                    break;                case Leader.COMMIT:                case Leader.COMMITANDACTIVATE:                    pif = packetsNotCommitted.peekFirst();                    if (pif.hdr.getZxid() == qp.getZxid() && qp.getType() == Leader.COMMITANDACTIVATE) {                        QuorumVerifier qv = self.configFromString(new String(((SetDataTxn) pif.rec).getData()));                        boolean majorChange = self.processReconfig(qv, ByteBuffer.wrap(qp.getData()).getLong(), qp.getZxid(), true);                        if (majorChange) {                            throw new Exception("changes proposed in reconfig");                        }                    }                    if (!writeToTxnLog) {                        if (pif.hdr.getZxid() != qp.getZxid()) {                                                    } else {                            zk.processTxn(pif.hdr, pif.rec);                            packetsNotCommitted.remove();                        }                    } else {                        packetsCommitted.add(qp.getZxid());                    }                    break;                case Leader.INFORM:                case Leader.INFORMANDACTIVATE:                    PacketInFlight packet = new PacketInFlight();                    packet.hdr = new TxnHeader();                    if (qp.getType() == Leader.INFORMANDACTIVATE) {                        ByteBuffer buffer = ByteBuffer.wrap(qp.getData());                        long suggestedLeaderId = buffer.getLong();                        byte[] remainingdata = new byte[buffer.remaining()];                        buffer.get(remainingdata);                        packet.rec = SerializeUtils.deserializeTxn(remainingdata, packet.hdr);                        QuorumVerifier qv = self.configFromString(new String(((SetDataTxn) packet.rec).getData()));                        boolean majorChange = self.processReconfig(qv, suggestedLeaderId, qp.getZxid(), true);                        if (majorChange) {                            throw new Exception("changes proposed in reconfig");                        }                    } else {                        packet.rec = SerializeUtils.deserializeTxn(qp.getData(), packet.hdr);                                                if (packet.hdr.getZxid() != lastQueued + 1) {                                                    }                        lastQueued = packet.hdr.getZxid();                    }                    if (!writeToTxnLog) {                                                zk.processTxn(packet.hdr, packet.rec);                    } else {                        packetsNotCommitted.add(packet);                        packetsCommitted.add(qp.getZxid());                    }                    break;                case Leader.UPTODATE:                                        if (newLeaderQV != null) {                        boolean majorChange = self.processReconfig(newLeaderQV, null, null, true);                        if (majorChange) {                            throw new Exception("changes proposed in reconfig");                        }                    }                    if (isPreZAB1_0) {                        zk.takeSnapshot(syncSnapshot);                        self.setCurrentEpoch(newEpoch);                    }                    self.setZooKeeperServer(zk);                    self.adminServer.setZooKeeperServer(zk);                    break outerLoop;                case                 Leader.NEWLEADER:                                                            if (qp.getData() != null && qp.getData().length > 1) {                        try {                            QuorumVerifier qv = self.configFromString(new String(qp.getData()));                            self.setLastSeenQuorumVerifier(qv, true);                            newLeaderQV = qv;                        } catch (Exception e) {                            e.printStackTrace();                        }                    }                    if (snapshotNeeded) {                        zk.takeSnapshot(syncSnapshot);                    }                    self.setCurrentEpoch(newEpoch);                                        writeToTxnLog = true;                    isPreZAB1_0 = false;                    writePacket(new QuorumPacket(Leader.ACK, newLeaderZxid, null, null), true);                    break;            }        }    }    ack.setZxid(ZxidUtils.makeZxid(newEpoch, 0));    writePacket(ack, true);    sock.setSoTimeout(self.tickTime * self.syncLimit);    self.setSyncMode(QuorumPeer.SyncMode.NONE);    zk.startup();    /*         * Update the election vote here to ensure that all members of the         * ensemble report the same vote to new servers that start up and         * send leader election notifications to the ensemble.         *         * @see https://issues.apache.org/jira/browse/ZOOKEEPER-1732         */    self.updateElectionVote(newEpoch);        if (zk instanceof FollowerZooKeeperServer) {        FollowerZooKeeperServer fzk = (FollowerZooKeeperServer) zk;        for (PacketInFlight p : packetsNotCommitted) {            fzk.logRequest(p.hdr, p.rec);        }        for (Long zxid : packetsCommitted) {            fzk.commit(zxid);        }    } else if (zk instanceof ObserverZooKeeperServer) {                        ObserverZooKeeperServer ozk = (ObserverZooKeeperServer) zk;        for (PacketInFlight p : packetsNotCommitted) {            Long zxid = packetsCommitted.peekFirst();            if (p.hdr.getZxid() != zxid) {                                                                continue;            }            packetsCommitted.remove();            Request request = new Request(null, p.hdr.getClientId(), p.hdr.getCxid(), p.hdr.getType(), null, null);            request.setTxn(p.rec);            request.setHdr(p.hdr);            ozk.commitRequest(request);        }    } else {                throw new UnsupportedOperationException("Unknown server type");    }}
revalidate
protected voidf2581_1QuorumPacket qp) throws IOException
{    ByteArrayInputStream bis = new ByteArrayInputStream(qp.getData());    DataInputStream dis = new DataInputStream(bis);    long sessionId = dis.readLong();    boolean valid = dis.readBoolean();    ServerCnxn cnxn = pendingRevalidations.remove(sessionId);    if (cnxn == null) {            } else {        zk.finishSessionInit(cnxn, valid);    }    if (LOG.isTraceEnabled()) {        ZooTrace.logTraceMessage(LOG, ZooTrace.SESSION_TRACE_MASK, "Session 0x" + Long.toHexString(sessionId) + " is valid: " + valid);    }}
ping
protected void zookeeper_f2582_0(QuorumPacket qp) throws IOException
{        ByteArrayOutputStream bos = new ByteArrayOutputStream();    DataOutputStream dos = new DataOutputStream(bos);    Map<Long, Integer> touchTable = zk.getTouchSnapshot();    for (Entry<Long, Integer> entry : touchTable.entrySet()) {        dos.writeLong(entry.getKey());        dos.writeInt(entry.getValue());    }    qp.setData(bos.toByteArray());    writePacket(qp, true);}
shutdown
public void zookeeper_f2583_0()
{    self.setZooKeeperServer(null);    self.closeAllConnections();    self.adminServer.setZooKeeperServer(null);    closeSocket();        if (zk != null) {        zk.shutdown();    }}
isRunning
 boolean zookeeper_f2584_0()
{    return self.isRunning() && zk.isRunning();}
closeSocket
 voidf2585_1)
{    try {        if (sock != null) {            sock.close();        }    } catch (IOException e) {            }}
getSocket
public Socket zookeeper_f2586_0()
{    return sock;}
getSid
 long zookeeper_f2587_0()
{    return sid;}
getRemoteAddress
 String zookeeper_f2588_0()
{    return sock == null ? "<null>" : sock.getRemoteSocketAddress().toString();}
getVersion
 int zookeeper_f2589_0()
{    return version;}
getLastZxid
public synchronized long zookeeper_f2590_0()
{    return lastZxid;}
getEstablished
public Date zookeeper_f2591_0()
{    return (Date) established.clone();}
start
public synchronized void zookeeper_f2592_0()
{    started = true;}
updateProposal
public synchronized void zookeeper_f2593_0(long zxid, long time)
{    if (!started) {        return;    }    if (currentTime == 0) {        currentTime = time;        currentZxid = zxid;    } else {        nextTime = time;        nextZxid = zxid;    }}
updateAck
public synchronized voidf2594_1long zxid)
{    if (currentZxid == zxid) {        currentTime = nextTime;        currentZxid = nextZxid;        nextTime = 0;        nextZxid = 0;    } else if (nextZxid == zxid) {                nextTime = 0;        nextZxid = 0;    }}
check
public synchronized boolean zookeeper_f2595_0(long time)
{    if (currentTime == 0) {        return true;    } else {        long msDelay = (time - currentTime) / 1000000;        return (msDelay < learnerMaster.syncTimeout());    }}
hashCode
public int zookeeper_f2596_0()
{    return Objects.hash(time);}
equals
public boolean zookeeper_f2597_0(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    MarkerQuorumPacket that = (MarkerQuorumPacket) o;    return time == that.time;}
setOutputArchive
protected void zookeeper_f2598_0(BinaryOutputArchive oa)
{    this.oa = oa;}
setBufferedOutput
protected void zookeeper_f2599_0(BufferedOutputStream bufferedOutput)
{    this.bufferedOutput = bufferedOutput;}
toString
public String zookeeper_f2600_0()
{    StringBuilder sb = new StringBuilder();    sb.append("LearnerHandler ").append(sock);    sb.append(" tickOfNextAckDeadline:").append(tickOfNextAckDeadline());    sb.append(" synced?:").append(synced());    sb.append(" queuedPacketLength:").append(queuedPackets.size());    return sb.toString();}
getLearnerType
public LearnerType zookeeper_f2601_0()
{    return learnerType;}
sendPackets
private voidf2602_1) throws InterruptedException
{    long traceMask = ZooTrace.SERVER_PACKET_TRACE_MASK;    while (true) {        try {            QuorumPacket p;            p = queuedPackets.poll();            if (p == null) {                bufferedOutput.flush();                p = queuedPackets.take();            }            ServerMetrics.getMetrics().LEARNER_HANDLER_QP_SIZE.add(Long.toString(this.sid), queuedPackets.size());            if (p instanceof MarkerQuorumPacket) {                MarkerQuorumPacket m = (MarkerQuorumPacket) p;                ServerMetrics.getMetrics().LEARNER_HANDLER_QP_TIME.add(Long.toString(this.sid), (System.nanoTime() - m.time) / 1000000L);                continue;            }            queuedPacketsSize.addAndGet(-packetSize(p));            if (p == proposalOfDeath) {                                break;            }            if (p.getType() == Leader.PING) {                traceMask = ZooTrace.SERVER_PING_TRACE_MASK;            }            if (p.getType() == Leader.PROPOSAL) {                syncLimitCheck.updateProposal(p.getZxid(), System.nanoTime());            }            if (LOG.isTraceEnabled()) {                ZooTrace.logQuorumPacket(LOG, traceMask, 'o', p);            }                        if (p.getZxid() > 0) {                lastZxid = p.getZxid();            }            oa.writeRecord(p, "packet");            packetsSent.incrementAndGet();            messageTracker.trackSent(p.getType());        } catch (IOException e) {            if (!sock.isClosed()) {                                try {                                                                                sock.close();                } catch (IOException ie) {                                    }            }            break;        }    }}
packetToString
public static Stringf2603_1QuorumPacket p)
{    String type;    String mess = null;    switch(p.getType()) {        case Leader.ACK:            type = "ACK";            break;        case Leader.COMMIT:            type = "COMMIT";            break;        case Leader.FOLLOWERINFO:            type = "FOLLOWERINFO";            break;        case Leader.NEWLEADER:            type = "NEWLEADER";            break;        case Leader.PING:            type = "PING";            break;        case Leader.PROPOSAL:            type = "PROPOSAL";            TxnHeader hdr = new TxnHeader();            try {                SerializeUtils.deserializeTxn(p.getData(), hdr);                        } catch (IOException e) {                            }            break;        case Leader.REQUEST:            type = "REQUEST";            break;        case Leader.REVALIDATE:            type = "REVALIDATE";            ByteArrayInputStream bis = new ByteArrayInputStream(p.getData());            DataInputStream dis = new DataInputStream(bis);            try {                long id = dis.readLong();                mess = " sessionid = " + id;            } catch (IOException e) {                            }            break;        case Leader.UPTODATE:            type = "UPTODATE";            break;        case Leader.DIFF:            type = "DIFF";            break;        case Leader.TRUNC:            type = "TRUNC";            break;        case Leader.SNAP:            type = "SNAP";            break;        case Leader.ACKEPOCH:            type = "ACKEPOCH";            break;        case Leader.SYNC:            type = "SYNC";            break;        case Leader.INFORM:            type = "INFORM";            break;        case Leader.COMMITANDACTIVATE:            type = "COMMITANDACTIVATE";            break;        case Leader.INFORMANDACTIVATE:            type = "INFORMANDACTIVATE";            break;        default:            type = "UNKNOWN" + p.getType();    }    String entry = null;    if (type != null) {        entry = type + " " + Long.toHexString(p.getZxid()) + " " + mess;    }    return entry;}
run
public voidf2604_1)
{    try {        learnerMaster.addLearnerHandler(this);        tickOfNextAckDeadline = learnerMaster.getTickOfInitialAckDeadline();        ia = BinaryInputArchive.getArchive(bufferedInput);        bufferedOutput = new BufferedOutputStream(sock.getOutputStream());        oa = BinaryOutputArchive.getArchive(bufferedOutput);        QuorumPacket qp = new QuorumPacket();        ia.readRecord(qp, "packet");        messageTracker.trackReceived(qp.getType());        if (qp.getType() != Leader.FOLLOWERINFO && qp.getType() != Leader.OBSERVERINFO) {                        return;        }        if (learnerMaster instanceof ObserverMaster && qp.getType() != Leader.OBSERVERINFO) {            throw new IOException("Non observer attempting to connect to ObserverMaster. type = " + qp.getType());        }        byte[] learnerInfoData = qp.getData();        if (learnerInfoData != null) {            ByteBuffer bbsid = ByteBuffer.wrap(learnerInfoData);            if (learnerInfoData.length >= 8) {                this.sid = bbsid.getLong();            }            if (learnerInfoData.length >= 12) {                                this.version = bbsid.getInt();            }            if (learnerInfoData.length >= 20) {                long configVersion = bbsid.getLong();                if (configVersion > learnerMaster.getQuorumVerifierVersion()) {                    throw new IOException("Follower is ahead of the leader (has a later activated configuration)");                }            }        } else {            this.sid = learnerMaster.getAndDecrementFollowerCounter();        }        String followerInfo = learnerMaster.getPeerInfo(this.sid);        if (followerInfo.isEmpty()) {                    } else {                    }        if (qp.getType() == Leader.OBSERVERINFO) {            learnerType = LearnerType.OBSERVER;        }        learnerMaster.registerLearnerHandlerBean(this, sock);        long lastAcceptedEpoch = ZxidUtils.getEpochFromZxid(qp.getZxid());        long peerLastZxid;        StateSummary ss = null;        long zxid = qp.getZxid();        long newEpoch = learnerMaster.getEpochToPropose(this.getSid(), lastAcceptedEpoch);        long newLeaderZxid = ZxidUtils.makeZxid(newEpoch, 0);        if (this.getVersion() < 0x10000) {                        long epoch = ZxidUtils.getEpochFromZxid(zxid);            ss = new StateSummary(epoch, zxid);                        learnerMaster.waitForEpochAck(this.getSid(), ss);        } else {            byte[] ver = new byte[4];            ByteBuffer.wrap(ver).putInt(0x10000);            QuorumPacket newEpochPacket = new QuorumPacket(Leader.LEADERINFO, newLeaderZxid, ver, null);            oa.writeRecord(newEpochPacket, "packet");            messageTracker.trackSent(Leader.LEADERINFO);            bufferedOutput.flush();            QuorumPacket ackEpochPacket = new QuorumPacket();            ia.readRecord(ackEpochPacket, "packet");            messageTracker.trackReceived(ackEpochPacket.getType());            if (ackEpochPacket.getType() != Leader.ACKEPOCH) {                                return;            }            ByteBuffer bbepoch = ByteBuffer.wrap(ackEpochPacket.getData());            ss = new StateSummary(bbepoch.getInt(), ackEpochPacket.getZxid());            learnerMaster.waitForEpochAck(this.getSid(), ss);        }        peerLastZxid = ss.getLastZxid();                        boolean needSnap = syncFollower(peerLastZxid, learnerMaster);                                boolean exemptFromThrottle = getLearnerType() != LearnerType.OBSERVER;        /* if we are not truncating or sending a diff just send a snapshot */        if (needSnap) {            syncThrottler = learnerMaster.getLearnerSnapSyncThrottler();            syncThrottler.beginSync(exemptFromThrottle);            try {                long zxidToSend = learnerMaster.getZKDatabase().getDataTreeLastProcessedZxid();                oa.writeRecord(new QuorumPacket(Leader.SNAP, zxidToSend, null, null), "packet");                messageTracker.trackSent(Leader.SNAP);                bufferedOutput.flush();                                                learnerMaster.getZKDatabase().serializeSnapshot(oa);                oa.writeString("BenWasHere", "signature");                bufferedOutput.flush();            } finally {                ServerMetrics.getMetrics().SNAP_COUNT.add(1);            }        } else {            syncThrottler = learnerMaster.getLearnerDiffSyncThrottler();            syncThrottler.beginSync(exemptFromThrottle);            ServerMetrics.getMetrics().DIFF_COUNT.add(1);        }                        if (getVersion() < 0x10000) {            QuorumPacket newLeaderQP = new QuorumPacket(Leader.NEWLEADER, newLeaderZxid, null, null);            oa.writeRecord(newLeaderQP, "packet");        } else {            QuorumPacket newLeaderQP = new QuorumPacket(Leader.NEWLEADER, newLeaderZxid, learnerMaster.getQuorumVerifierBytes(), null);            queuedPackets.add(newLeaderQP);        }        bufferedOutput.flush();                startSendingPackets();        /*             * Have to wait for the first ACK, wait until             * the learnerMaster is ready, and only then we can             * start processing messages.             */        qp = new QuorumPacket();        ia.readRecord(qp, "packet");        messageTracker.trackReceived(qp.getType());        if (qp.getType() != Leader.ACK) {                        return;        }                learnerMaster.waitForNewLeaderAck(getSid(), qp.getZxid());        syncLimitCheck.start();                syncThrottler.endSync();        syncThrottler = null;                sock.setSoTimeout(learnerMaster.syncTimeout());        /*             * Wait until learnerMaster starts up             */        learnerMaster.waitForStartup();                                                queuedPackets.add(new QuorumPacket(Leader.UPTODATE, -1, null, null));        while (true) {            qp = new QuorumPacket();            ia.readRecord(qp, "packet");            messageTracker.trackReceived(qp.getType());            long traceMask = ZooTrace.SERVER_PACKET_TRACE_MASK;            if (qp.getType() == Leader.PING) {                traceMask = ZooTrace.SERVER_PING_TRACE_MASK;            }            if (LOG.isTraceEnabled()) {                ZooTrace.logQuorumPacket(LOG, traceMask, 'i', qp);            }            tickOfNextAckDeadline = learnerMaster.getTickOfNextAckDeadline();            packetsReceived.incrementAndGet();            ByteBuffer bb;            long sessionId;            int cxid;            int type;            switch(qp.getType()) {                case Leader.ACK:                    if (this.learnerType == LearnerType.OBSERVER) {                                            }                    syncLimitCheck.updateAck(qp.getZxid());                    learnerMaster.processAck(this.sid, qp.getZxid(), sock.getLocalSocketAddress());                    break;                case Leader.PING:                                        ByteArrayInputStream bis = new ByteArrayInputStream(qp.getData());                    DataInputStream dis = new DataInputStream(bis);                    while (dis.available() > 0) {                        long sess = dis.readLong();                        int to = dis.readInt();                        learnerMaster.touch(sess, to);                    }                    break;                case Leader.REVALIDATE:                    ServerMetrics.getMetrics().REVALIDATE_COUNT.add(1);                    learnerMaster.revalidateSession(qp, this);                    break;                case Leader.REQUEST:                    bb = ByteBuffer.wrap(qp.getData());                    sessionId = bb.getLong();                    cxid = bb.getInt();                    type = bb.getInt();                    bb = bb.slice();                    Request si;                    if (type == OpCode.sync) {                        si = new LearnerSyncRequest(this, sessionId, cxid, type, bb, qp.getAuthinfo());                    } else {                        si = new Request(null, sessionId, cxid, type, bb, qp.getAuthinfo());                    }                    si.setOwner(this);                    learnerMaster.submitLearnerRequest(si);                    requestsReceived.incrementAndGet();                    break;                default:                                        break;            }        }    } catch (IOException e) {        if (sock != null && !sock.isClosed()) {                                    try {                sock.close();            } catch (IOException ie) {                        }        }    } catch (InterruptedException e) {            } catch (SyncThrottleException e) {                syncThrottler = null;    } catch (Exception e) {                throw e;    } finally {        if (syncThrottler != null) {            syncThrottler.endSync();            syncThrottler = null;        }        String remoteAddr = getRemoteAddress();                messageTracker.dumpToLog(remoteAddr);        shutdown();    }}
startSendingPackets
protected voidf2605_1)
{    if (!sendingThreadStarted) {                new Thread() {            public void run() {                Thread.currentThread().setName("Sender-" + sock.getRemoteSocketAddress());                try {                    sendPackets();                } catch (InterruptedException e) {                                    }            }        }.start();        sendingThreadStarted = true;    } else {            }}
run
public voidf2606_1)
{    Thread.currentThread().setName("Sender-" + sock.getRemoteSocketAddress());    try {        sendPackets();    } catch (InterruptedException e) {            }}
shouldSendMarkerPacketForLogging
protected boolean zookeeper_f2607_0()
{    return true;}
syncFollower
 booleanf2608_1long peerLastZxid, LearnerMaster learnerMaster)
{    /*         * When leader election is completed, the leader will set its         * lastProcessedZxid to be (epoch < 32). There will be no txn associated         * with this zxid.         *         * The learner will set its lastProcessedZxid to the same value if         * it get DIFF or SNAP from the learnerMaster. If the same learner come         * back to sync with learnerMaster using this zxid, we will never find this         * zxid in our history. In this case, we will ignore TRUNC logic and         * always send DIFF if we have old enough history         */    boolean isPeerNewEpochZxid = (peerLastZxid & 0xffffffffL) == 0;        long currentZxid = peerLastZxid;    boolean needSnap = true;    ZKDatabase db = learnerMaster.getZKDatabase();    boolean txnLogSyncEnabled = db.isTxnLogSyncEnabled();    ReentrantReadWriteLock lock = db.getLogLock();    ReadLock rl = lock.readLock();    try {        rl.lock();        long maxCommittedLog = db.getmaxCommittedLog();        long minCommittedLog = db.getminCommittedLog();        long lastProcessedZxid = db.getDataTreeLastProcessedZxid();                if (db.getCommittedLog().isEmpty()) {            /*                 * It is possible that committedLog is empty. In that case                 * setting these value to the latest txn in learnerMaster db                 * will reduce the case that we need to handle                 *                 * Here is how each case handle by the if block below                 * 1. lastProcessZxid == peerZxid -> Handle by (2)                 * 2. lastProcessZxid < peerZxid -> Handle by (3)                 * 3. lastProcessZxid > peerZxid -> Handle by (5)                 */            minCommittedLog = lastProcessedZxid;            maxCommittedLog = lastProcessedZxid;        }        if (forceSnapSync) {                                } else if (lastProcessedZxid == peerLastZxid) {                                    queueOpPacket(Leader.DIFF, peerLastZxid);            needOpPacket = false;            needSnap = false;        } else if (peerLastZxid > maxCommittedLog && !isPeerNewEpochZxid) {                        if (LOG.isDebugEnabled()) {                            }            queueOpPacket(Leader.TRUNC, maxCommittedLog);            currentZxid = maxCommittedLog;            needOpPacket = false;            needSnap = false;        } else if ((maxCommittedLog >= peerLastZxid) && (minCommittedLog <= peerLastZxid)) {                                    Iterator<Proposal> itr = db.getCommittedLog().iterator();            currentZxid = queueCommittedProposals(itr, peerLastZxid, null, maxCommittedLog);            needSnap = false;        } else if (peerLastZxid < minCommittedLog && txnLogSyncEnabled) {                                    long sizeLimit = db.calculateTxnLogSizeLimit();                                    Iterator<Proposal> txnLogItr = db.getProposalsFromTxnLog(peerLastZxid, sizeLimit);            if (txnLogItr.hasNext()) {                                currentZxid = queueCommittedProposals(txnLogItr, peerLastZxid, minCommittedLog, maxCommittedLog);                if (currentZxid < minCommittedLog) {                                        currentZxid = peerLastZxid;                                                            queuedPackets.clear();                    needOpPacket = true;                } else {                    if (LOG.isDebugEnabled()) {                                            }                    Iterator<Proposal> committedLogItr = db.getCommittedLog().iterator();                    currentZxid = queueCommittedProposals(committedLogItr, currentZxid, null, maxCommittedLog);                    needSnap = false;                }            }                        if (txnLogItr instanceof TxnLogProposalIterator) {                TxnLogProposalIterator txnProposalItr = (TxnLogProposalIterator) txnLogItr;                txnProposalItr.close();            }        } else {                    }        if (needSnap) {            currentZxid = db.getDataTreeLastProcessedZxid();        }        if (LOG.isDebugEnabled()) {                    }        leaderLastZxid = learnerMaster.startForwarding(this, currentZxid);    } finally {        rl.unlock();    }    if (needOpPacket && !needSnap) {                                needSnap = true;    }    return needSnap;}
queueCommittedProposals
protected longf2609_1Iterator<Proposal> itr, long peerLastZxid, Long maxZxid, Long lastCommittedZxid)
{    boolean isPeerNewEpochZxid = (peerLastZxid & 0xffffffffL) == 0;    long queuedZxid = peerLastZxid;            long prevProposalZxid = -1;    while (itr.hasNext()) {        Proposal propose = itr.next();        long packetZxid = propose.packet.getZxid();                if ((maxZxid != null) && (packetZxid > maxZxid)) {            break;        }                if (packetZxid < peerLastZxid) {            prevProposalZxid = packetZxid;            continue;        }                if (needOpPacket) {                        if (packetZxid == peerLastZxid) {                                queueOpPacket(Leader.DIFF, lastCommittedZxid);                needOpPacket = false;                continue;            }            if (isPeerNewEpochZxid) {                                                queueOpPacket(Leader.DIFF, lastCommittedZxid);                needOpPacket = false;            } else if (packetZxid > peerLastZxid) {                                if (ZxidUtils.getEpochFromZxid(packetZxid) != ZxidUtils.getEpochFromZxid(peerLastZxid)) {                                                                                                    return queuedZxid;                }                                queueOpPacket(Leader.TRUNC, prevProposalZxid);                needOpPacket = false;            }        }        if (packetZxid <= queuedZxid) {                        continue;        }                        queuePacket(propose.packet);        queueOpPacket(Leader.COMMIT, packetZxid);        queuedZxid = packetZxid;    }    if (needOpPacket && isPeerNewEpochZxid) {                                        queueOpPacket(Leader.DIFF, lastCommittedZxid);        needOpPacket = false;    }    return queuedZxid;}
shutdown
public voidf2610_1)
{        try {        queuedPackets.clear();        queuedPackets.put(proposalOfDeath);    } catch (InterruptedException e) {            }    try {        if (sock != null && !sock.isClosed()) {            sock.close();        }    } catch (IOException e) {            }    this.interrupt();    learnerMaster.removeLearnerHandler(this);    learnerMaster.unregisterLearnerHandlerBean(this);}
tickOfNextAckDeadline
public long zookeeper_f2611_0()
{    return tickOfNextAckDeadline;}
ping
public voidf2612_1)
{        if (!sendingThreadStarted) {        return;    }    long id;    if (syncLimitCheck.check(System.nanoTime())) {        id = learnerMaster.getLastProposed();        QuorumPacket ping = new QuorumPacket(Leader.PING, id, null, null);        queuePacket(ping);    } else {                shutdown();    }}
queueOpPacket
private void zookeeper_f2613_0(int type, long zxid)
{    QuorumPacket packet = new QuorumPacket(type, zxid, null, null);    queuePacket(packet);}
queuePacket
 void zookeeper_f2614_0(QuorumPacket p)
{    queuedPackets.add(p);        if (shouldSendMarkerPacketForLogging() && packetCounter.getAndIncrement() % markerPacketInterval == 0) {        queuedPackets.add(new MarkerQuorumPacket(System.nanoTime()));    }    queuedPacketsSize.addAndGet(packetSize(p));}
packetSize
 static long zookeeper_f2615_0(QuorumPacket p)
{    /* Approximate base size of QuorumPacket: int + long + byte[] + List */    long size = 4 + 8 + 8 + 8;    byte[] data = p.getData();    if (data != null) {        size += data.length;    }    return size;}
synced
public boolean zookeeper_f2616_0()
{    return isAlive() && learnerMaster.getCurrentTick() <= tickOfNextAckDeadline;}
getLearnerHandlerInfo
public synchronized Map<String, Object> zookeeper_f2617_0()
{    Map<String, Object> info = new LinkedHashMap<>(9);    info.put("remote_socket_address", getRemoteAddress());    info.put("sid", getSid());    info.put("established", getEstablished());    info.put("queued_packets", queuedPackets.size());    info.put("queued_packets_size", queuedPacketsSize.get());    info.put("packets_received", packetsReceived.longValue());    info.put("packets_sent", packetsSent.longValue());    info.put("requests", requestsReceived.longValue());    info.put("last_zxid", getLastZxid());    return info;}
resetObserverConnectionStats
public synchronized void zookeeper_f2618_0()
{    packetsReceived.set(0);    packetsSent.set(0);    requestsReceived.set(0);    lastZxid = -1;}
getQueuedPackets
public Queue<QuorumPacket> zookeeper_f2619_0()
{    return queuedPackets;}
setFirstPacket
public void zookeeper_f2620_0(boolean value)
{    needOpPacket = value;}
getName
public String zookeeper_f2621_0()
{    return MBeanRegistry.getInstance().makeFullPath("Learner_Connections", ObjectName.quote(remoteAddr), String.format("\"id:%d\"", learnerHandler.getSid()));}
isHidden
public boolean zookeeper_f2622_0()
{    return false;}
terminateConnection
public voidf2623_1)
{        learnerHandler.shutdown();}
toString
public String zookeeper_f2624_0()
{    return "LearnerHandlerBean{remoteIP=" + remoteAddr + ",ServerId=" + learnerHandler.getSid() + "}";}
getMaxConcurrentSnapSyncs
public int zookeeper_f2625_0()
{    return maxConcurrentSnapSyncs;}
setMaxConcurrentSnapSyncs
public voidf2626_1int maxConcurrentSnapSyncs)
{        this.maxConcurrentSnapSyncs = maxConcurrentSnapSyncs;    learnerSnapSyncThrottler.setMaxConcurrentSyncs(maxConcurrentSnapSyncs);}
getMaxConcurrentDiffSyncs
public int zookeeper_f2627_0()
{    return maxConcurrentDiffSyncs;}
setMaxConcurrentDiffSyncs
public voidf2628_1int maxConcurrentDiffSyncs)
{        this.maxConcurrentDiffSyncs = maxConcurrentDiffSyncs;    learnerDiffSyncThrottler.setMaxConcurrentSyncs(maxConcurrentDiffSyncs);}
getLearnerSnapSyncThrottler
public LearnerSyncThrottler zookeeper_f2629_0()
{    return learnerSnapSyncThrottler;}
getLearnerDiffSyncThrottler
public LearnerSyncThrottler zookeeper_f2630_0()
{    return learnerDiffSyncThrottler;}
removeSession
public void zookeeper_f2631_0(long sessionId)
{    if (localSessionTracker != null) {        localSessionTracker.removeSession(sessionId);    }    globalSessionsWithTimeouts.remove(sessionId);    touchTable.get().remove(sessionId);}
start
public void zookeeper_f2632_0()
{    if (localSessionTracker != null) {        localSessionTracker.start();    }}
shutdown
public void zookeeper_f2633_0()
{    if (localSessionTracker != null) {        localSessionTracker.shutdown();    }}
isGlobalSession
public boolean zookeeper_f2634_0(long sessionId)
{    return globalSessionsWithTimeouts.containsKey(sessionId);}
trackSession
public boolean zookeeper_f2635_0(long sessionId, int sessionTimeout)
{        return false;}
commitSession
public synchronized booleanf2636_1long sessionId, int sessionTimeout)
{    boolean added = globalSessionsWithTimeouts.put(sessionId, sessionTimeout) == null;    if (added) {                            }        if (localSessionsEnabled) {        removeLocalSession(sessionId);        finishedUpgrading(sessionId);    }    touchTable.get().put(sessionId, sessionTimeout);    return added;}
touchSession
public boolean zookeeper_f2637_0(long sessionId, int sessionTimeout)
{    if (localSessionsEnabled) {        if (localSessionTracker.touchSession(sessionId, sessionTimeout)) {            return true;        }        if (!isGlobalSession(sessionId) && !isUpgradingSession(sessionId)) {            return false;        }    }    touchTable.get().put(sessionId, sessionTimeout);    return true;}
snapshot
public Map<Long, Integer> zookeeper_f2638_0()
{    return touchTable.getAndSet(new ConcurrentHashMap<Long, Integer>());}
createSession
public long zookeeper_f2639_0(int sessionTimeout)
{    if (localSessionsEnabled) {        return localSessionTracker.createSession(sessionTimeout);    }    return nextSessionId.getAndIncrement();}
checkSession
public void zookeeper_f2640_0(long sessionId, Object owner) throws SessionExpiredException, SessionMovedException
{    if (localSessionTracker != null) {        try {            localSessionTracker.checkSession(sessionId, owner);            return;        } catch (UnknownSessionException e) {                        if (!isGlobalSession(sessionId)) {                throw new SessionExpiredException();            }        }    }}
setOwner
public void zookeeper_f2641_0(long sessionId, Object owner) throws SessionExpiredException
{    if (localSessionTracker != null) {        try {            localSessionTracker.setOwner(sessionId, owner);            return;        } catch (SessionExpiredException e) {                        if (!isGlobalSession(sessionId)) {                throw e;            }        }    }}
dumpSessions
public void zookeeper_f2642_0(PrintWriter pwriter)
{    if (localSessionTracker != null) {        pwriter.print("Local ");        localSessionTracker.dumpSessions(pwriter);    }    pwriter.print("Global Sessions(");    pwriter.print(globalSessionsWithTimeouts.size());    pwriter.println("):");    SortedSet<Long> sessionIds = new TreeSet<Long>(globalSessionsWithTimeouts.keySet());    for (long sessionId : sessionIds) {        pwriter.print("0x");        pwriter.print(Long.toHexString(sessionId));        pwriter.print("\t");        pwriter.print(globalSessionsWithTimeouts.get(sessionId));        pwriter.println("ms");    }}
setSessionClosing
public void zookeeper_f2643_0(long sessionId)
{        if (localSessionTracker != null) {        localSessionTracker.setSessionClosing(sessionId);    }}
getSessionExpiryMap
public Map<Long, Set<Long>> zookeeper_f2644_0()
{    return new HashMap<Long, Set<Long>>();}
beginSync
protected void zookeeper_f2645_0(boolean essential) throws SyncThrottleException, InterruptedException
{    synchronized (countSyncObject) {        if (essential || syncInProgress < maxConcurrentSyncs) {            syncInProgress++;        } else {            throw new SyncThrottleException(syncInProgress + 1, maxConcurrentSyncs, syncType);        }    }}
endSync
public voidf2646_1)
{    int newCount;    synchronized (countSyncObject) {        syncInProgress--;        newCount = syncInProgress;        countSyncObject.notify();    }    if (newCount < 0) {        String errorMsg = "endSync() called incorrectly; current sync count is " + newCount;            }}
setMaxConcurrentSyncs
public void zookeeper_f2647_0(int maxConcurrentSyncs)
{    this.maxConcurrentSyncs = maxConcurrentSyncs;}
getSyncInProgress
public int zookeeper_f2648_0()
{    return syncInProgress;}
getTouchSnapshot
protected Map<Long, Integer> zookeeper_f2649_0()
{    if (sessionTracker != null) {        return ((LearnerSessionTracker) sessionTracker).snapshot();    }    Map<Long, Integer> map = Collections.emptyMap();    return map;}
getServerId
public long zookeeper_f2650_0()
{    return self.getId();}
createSessionTracker
public void zookeeper_f2651_0()
{    sessionTracker = new LearnerSessionTracker(this, getZKDatabase().getSessionWithTimeOuts(), this.tickTime, self.getId(), self.areLocalSessionsEnabled(), getZooKeeperServerListener());}
revalidateSession
protected void zookeeper_f2652_0(ServerCnxn cnxn, long sessionId, int sessionTimeout) throws IOException
{    if (upgradeableSessionTracker.isLocalSession(sessionId)) {        super.revalidateSession(cnxn, sessionId, sessionTimeout);    } else {        getLearner().validateSession(cnxn, sessionId, sessionTimeout);    }}
registerJMX
protected voidf2653_1)
{        try {        jmxDataTreeBean = new DataTreeBean(getZKDatabase().getDataTree());        MBeanRegistry.getInstance().register(jmxDataTreeBean, jmxServerBean);    } catch (Exception e) {                jmxDataTreeBean = null;    }}
registerJMX
public voidf2654_1ZooKeeperServerBean serverBean, LocalPeerBean localPeerBean)
{        if (self.jmxLeaderElectionBean != null) {        try {            MBeanRegistry.getInstance().unregister(self.jmxLeaderElectionBean);        } catch (Exception e) {                    }        self.jmxLeaderElectionBean = null;    }    try {        jmxServerBean = serverBean;        MBeanRegistry.getInstance().register(serverBean, localPeerBean);    } catch (Exception e) {                jmxServerBean = null;    }}
unregisterJMX
protected voidf2655_1)
{        try {        if (jmxDataTreeBean != null) {            MBeanRegistry.getInstance().unregister(jmxDataTreeBean);        }    } catch (Exception e) {            }    jmxDataTreeBean = null;}
unregisterJMX
protected voidf2656_1Learner peer)
{        try {        if (jmxServerBean != null) {            MBeanRegistry.getInstance().unregister(jmxServerBean);        }    } catch (Exception e) {            }    jmxServerBean = null;}
shutdown
public synchronized voidf2657_1)
{    if (!canShutdown()) {                return;    }        try {        super.shutdown();    } catch (Exception e) {            }    try {        if (syncProcessor != null) {            syncProcessor.shutdown();        }    } catch (Exception e) {            }}
getName
public String zookeeper_f2658_0()
{    return "replica." + peer.getId();}
isHidden
public boolean zookeeper_f2659_0()
{    return false;}
getTickTime
public int zookeeper_f2660_0()
{    return peer.getTickTime();}
getMaxClientCnxnsPerHost
public int zookeeper_f2661_0()
{    return peer.getMaxClientCnxnsPerHost();}
getMinSessionTimeout
public int zookeeper_f2662_0()
{    return peer.getMinSessionTimeout();}
getMaxSessionTimeout
public int zookeeper_f2663_0()
{    return peer.getMaxSessionTimeout();}
getInitLimit
public int zookeeper_f2664_0()
{    return peer.getInitLimit();}
getSyncLimit
public int zookeeper_f2665_0()
{    return peer.getSyncLimit();}
setInitLimit
public void zookeeper_f2666_0(int initLimit)
{    peer.setInitLimit(initLimit);}
setSyncLimit
public void zookeeper_f2667_0(int syncLimit)
{    peer.setSyncLimit(syncLimit);}
getTick
public int zookeeper_f2668_0()
{    return peer.getTick();}
getState
public String zookeeper_f2669_0()
{    return peer.getServerState();}
getQuorumAddress
public String zookeeper_f2670_0()
{    return formatInetAddr(peer.getQuorumAddress());}
getElectionType
public int zookeeper_f2671_0()
{    return peer.getElectionType();}
getElectionAddress
public String zookeeper_f2672_0()
{    return formatInetAddr(peer.getElectionAddress());}
getClientAddress
public String zookeeper_f2673_0()
{    if (null != peer.cnxnFactory) {        return formatInetAddr(peer.cnxnFactory.getLocalAddress());    } else {        return "";    }}
getLearnerType
public String zookeeper_f2674_0()
{    return peer.getLearnerType().toString();}
getConfigVersion
public long zookeeper_f2675_0()
{    return peer.getQuorumVerifier().getVersion();}
getQuorumSystemInfo
public String zookeeper_f2676_0()
{    return peer.getQuorumVerifier().toString();}
isPartOfEnsemble
public boolean zookeeper_f2677_0()
{    return peer.getView().containsKey(peer.getId());}
isLeader
public boolean zookeeper_f2678_0()
{    return peer.isLeader(peer.getId());}
isLocalSession
public boolean zookeeper_f2679_0(long sessionId)
{    return isTrackingSession(sessionId);}
isGlobalSession
public boolean zookeeper_f2680_0(long sessionId)
{    return false;}
createSession
public long zookeeper_f2681_0(int sessionTimeout)
{    long sessionId = super.createSession(sessionTimeout);    commitSession(sessionId, sessionTimeout);    return sessionId;}
toString
public String zookeeper_f2682_0()
{    StringBuilder sb = new StringBuilder();    sb.append("Observer ").append(sock);    sb.append(" pendingRevalidationCount:").append(pendingRevalidations.size());    return sb.toString();}
observeLeader
 voidf2683_1) throws Exception
{    zk.registerJMX(new ObserverBean(this, zk), self.jmxLocalPeerBean);    long connectTime = 0;    boolean completedSync = false;    try {        self.setZabState(QuorumPeer.ZabState.DISCOVERY);        QuorumServer master = findLearnerMaster();        try {            connectToLeader(master.addr, master.hostname);            connectTime = System.currentTimeMillis();            long newLeaderZxid = registerWithLeader(Leader.OBSERVERINFO);            if (self.isReconfigStateChange()) {                throw new Exception("learned about role change");            }            self.setLeaderAddressAndId(master.addr, master.getId());            self.setZabState(QuorumPeer.ZabState.SYNCHRONIZATION);            syncWithLeader(newLeaderZxid);            self.setZabState(QuorumPeer.ZabState.BROADCAST);            completedSync = true;            QuorumPacket qp = new QuorumPacket();            while (this.isRunning() && nextLearnerMaster.get() == null) {                readPacket(qp);                processPacket(qp);            }        } catch (Exception e) {                        closeSocket();                        pendingRevalidations.clear();        }    } finally {        currentLearnerMaster = null;        zk.unregisterJMX(this);        if (connectTime != 0) {            long connectionDuration = System.currentTimeMillis() - connectTime;                        messageTracker.dumpToLog(leaderAddr.toString());        }    }}
findLearnerMaster
private QuorumServerf2684_1)
{    QuorumPeer.QuorumServer prescribedLearnerMaster = nextLearnerMaster.getAndSet(null);    if (prescribedLearnerMaster != null && self.validateLearnerMaster(Long.toString(prescribedLearnerMaster.id)) == null) {                prescribedLearnerMaster = null;    }    final QuorumPeer.QuorumServer master = (prescribedLearnerMaster == null) ? self.findLearnerMaster(findLeader()) : prescribedLearnerMaster;    currentLearnerMaster = master;    if (master == null) {            } else {            }    return master;}
processPacket
protected voidf2685_1QuorumPacket qp) throws Exception
{    switch(qp.getType()) {        case Leader.PING:            ping(qp);            break;        case Leader.PROPOSAL:                        break;        case Leader.COMMIT:                        break;        case Leader.UPTODATE:                        break;        case Leader.REVALIDATE:            revalidate(qp);            break;        case Leader.SYNC:            ((ObserverZooKeeperServer) zk).sync();            break;        case Leader.INFORM:            ServerMetrics.getMetrics().LEARNER_COMMIT_RECEIVED_COUNT.add(1);            TxnHeader hdr = new TxnHeader();            Record txn = SerializeUtils.deserializeTxn(qp.getData(), hdr);            Request request = new Request(hdr.getClientId(), hdr.getCxid(), hdr.getType(), hdr, txn, 0);            request.logLatency(ServerMetrics.getMetrics().COMMIT_PROPAGATION_LATENCY);            ObserverZooKeeperServer obs = (ObserverZooKeeperServer) zk;            obs.commitRequest(request);            break;        case Leader.INFORMANDACTIVATE:            hdr = new TxnHeader();                        ByteBuffer buffer = ByteBuffer.wrap(qp.getData());            long suggestedLeaderId = buffer.getLong();            byte[] remainingdata = new byte[buffer.remaining()];            buffer.get(remainingdata);            txn = SerializeUtils.deserializeTxn(remainingdata, hdr);            QuorumVerifier qv = self.configFromString(new String(((SetDataTxn) txn).getData()));            request = new Request(hdr.getClientId(), hdr.getCxid(), hdr.getType(), hdr, txn, 0);            obs = (ObserverZooKeeperServer) zk;            boolean majorChange = self.processReconfig(qv, suggestedLeaderId, qp.getZxid(), true);            obs.commitRequest(request);            if (majorChange) {                throw new Exception("changes proposed in reconfig");            }            break;        default:                        break;    }}
shutdown
public voidf2686_1)
{        super.shutdown();}
waitForReconnectDelay
 static void zookeeper_f2687_0()
{    waitForReconnectDelayHelper(reconnectDelayMs);}
waitForObserverElectionDelay
 static void zookeeper_f2688_0()
{    waitForReconnectDelayHelper(observerElectionDelayMs);}
waitForReconnectDelayHelper
private static voidf2689_1long delayValueMs)
{    if (delayValueMs > 0) {        long randomDelay = (long) (delayValueMs * Math.random());                try {            Thread.sleep(randomDelay);        } catch (InterruptedException e) {                    }    }}
getLearnerMasterId
public long zookeeper_f2690_0()
{    QuorumPeer.QuorumServer current = currentLearnerMaster;    return current == null ? -1 : current.id;}
setLearnerMaster
public booleanf2691_1String learnerMaster)
{    final QuorumPeer.QuorumServer server = self.validateLearnerMaster(learnerMaster);    if (server == null) {        return false;    } else if (server.equals(currentLearnerMaster)) {                return true;    } else {                nextLearnerMaster.set(server);        return true;    }}
getCurrentLearnerMaster
public QuorumPeer.QuorumServer zookeeper_f2692_0()
{    return currentLearnerMaster;}
getObserverElectionDelayMs
public static long zookeeper_f2693_0()
{    return observerElectionDelayMs;}
setObserverElectionDelayMs
public static voidf2694_1long electionDelayMs)
{    observerElectionDelayMs = electionDelayMs;    }
equals
public boolean zookeeper_f2695_0(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    final Revalidation that = (Revalidation) o;    return sessionId == that.sessionId && timeout == that.timeout && handler.equals(that.handler);}
hashCode
public int zookeeper_f2696_0()
{    int result = (int) (sessionId ^ (sessionId >>> 32));    result = 31 * result + timeout;    result = 31 * result + handler.hashCode();    return result;}
run
public void zookeeper_f2697_0()
{    for (LearnerHandler lh : activeObservers) {        lh.ping();    }}
addLearnerHandler
public void zookeeper_f2698_0(LearnerHandler learnerHandler)
{    if (!listenerRunning) {        throw new RuntimeException(("ObserverMaster is not running"));    }}
removeLearnerHandler
public void zookeeper_f2699_0(LearnerHandler learnerHandler)
{    activeObservers.remove(learnerHandler);}
syncTimeout
public int zookeeper_f2700_0()
{    return self.getSyncLimit() * self.getTickTime();}
getTickOfNextAckDeadline
public int zookeeper_f2701_0()
{    return self.tick.get() + self.syncLimit;}
getTickOfInitialAckDeadline
public int zookeeper_f2702_0()
{    return self.tick.get() + self.initLimit + self.syncLimit;}
getAndDecrementFollowerCounter
public long zookeeper_f2703_0()
{    return followerCounter.getAndDecrement();}
waitForEpochAck
public void zookeeper_f2704_0(long sid, StateSummary ss) throws IOException, InterruptedException
{}
waitForStartup
public void zookeeper_f2705_0() throws InterruptedException
{}
getLastProposed
public synchronized long zookeeper_f2706_0()
{    return lastProposedZxid;}
getEpochToPropose
public long zookeeper_f2707_0(long sid, long lastAcceptedEpoch) throws InterruptedException, IOException
{    return self.getCurrentEpoch();}
getZKDatabase
public ZKDatabase zookeeper_f2708_0()
{    return zks.getZKDatabase();}
waitForNewLeaderAck
public void zookeeper_f2709_0(long sid, long zxid) throws InterruptedException
{}
getCurrentTick
public int zookeeper_f2710_0()
{    return self.tick.get();}
processAck
public void zookeeper_f2711_0(long sid, long zxid, SocketAddress localSocketAddress)
{    if ((zxid & 0xffffffffL) == 0) {        /*             * We no longer process NEWLEADER ack by this method. However,             * the learner sends ack back to the leader after it gets UPTODATE             * so we just ignore the message.             */        return;    }    throw new RuntimeException("Observers shouldn't send ACKS ack = " + Long.toHexString(zxid));}
touch
public void zookeeper_f2712_0(long sess, int to)
{    zks.getSessionTracker().touchSession(sess, to);}
revalidateLearnerSession
 boolean zookeeper_f2713_0(QuorumPacket qp) throws IOException
{    ByteArrayInputStream bis = new ByteArrayInputStream(qp.getData());    DataInputStream dis = new DataInputStream(bis);    long id = dis.readLong();    boolean valid = dis.readBoolean();    Iterator<Revalidation> itr = pendingRevalidations.iterator();    if (!itr.hasNext()) {                return false;    }    Revalidation revalidation = itr.next();    if (revalidation.sessionId != id) {                return false;    }    itr.remove();    LearnerHandler learnerHandler = revalidation.handler;        QuorumPacket deepCopy = new QuorumPacket(qp.getType(), qp.getZxid(), Arrays.copyOf(qp.getData(), qp.getData().length), qp.getAuthinfo() == null ? null : new ArrayList<>(qp.getAuthinfo()));    learnerHandler.queuePacket(deepCopy);        if (valid) {        touch(revalidation.sessionId, revalidation.timeout);    }    return true;}
revalidateSession
public void zookeeper_f2714_0(QuorumPacket qp, LearnerHandler learnerHandler) throws IOException
{    ByteArrayInputStream bis = new ByteArrayInputStream(qp.getData());    DataInputStream dis = new DataInputStream(bis);    long id = dis.readLong();    int to = dis.readInt();    synchronized (revalidateSessionLock) {        pendingRevalidations.add(new Revalidation(id, to, learnerHandler));        Learner learner = zks.getLearner();        if (learner != null) {            learner.writePacket(qp, true);        }    }}
submitLearnerRequest
public void zookeeper_f2715_0(Request si)
{    zks.processObserverRequest(si);}
startForwarding
public synchronized longf2716_1LearnerHandler learnerHandler, long lastSeenZxid)
{    Iterator<QuorumPacket> itr = committedPkts.iterator();    if (itr.hasNext()) {        QuorumPacket packet = itr.next();        if (packet.getZxid() > lastSeenZxid + 1) {                        learnerHandler.shutdown();            return -1;        } else if (packet.getZxid() == lastSeenZxid + 1) {            learnerHandler.queuePacket(packet);        }        long queueHeadZxid = packet.getZxid();        long queueBytesUsed = LearnerHandler.packetSize(packet);        while (itr.hasNext()) {            packet = itr.next();            if (packet.getZxid() <= lastSeenZxid) {                continue;            }            learnerHandler.queuePacket(packet);            queueBytesUsed += LearnerHandler.packetSize(packet);        }            }    activeObservers.add(learnerHandler);    return lastProposedZxid;}
getQuorumVerifierVersion
public long zookeeper_f2717_0()
{    return self.getQuorumVerifier().getVersion();}
getPeerInfo
public String zookeeper_f2718_0(long sid)
{    QuorumPeer.QuorumServer server = self.getView().get(sid);    return server == null ? "" : server.toString();}
getQuorumVerifierBytes
public byte[] zookeeper_f2719_0()
{    return self.getLastSeenQuorumVerifier().toString().getBytes();}
getQuorumAuthServer
public QuorumAuthServer zookeeper_f2720_0()
{    return (self == null) ? null : self.authServer;}
proposalReceived
 void zookeeper_f2721_0(QuorumPacket qp)
{    proposedPkts.add(new QuorumPacket(Leader.INFORM, qp.getZxid(), qp.getData(), null));}
removeProposedPacket
private synchronized QuorumPacketf2722_1long zxid)
{    QuorumPacket pkt = proposedPkts.peek();    if (pkt == null || pkt.getZxid() > zxid) {                return null;    }    if (pkt.getZxid() != zxid) {        final String m = String.format("Unexpected proposal packet on commit ack, expected zxid 0x%d got zxid 0x%d", zxid, pkt.getZxid());                throw new RuntimeException(m);    }    proposedPkts.remove();    return pkt;}
cacheCommittedPacket
private synchronized void zookeeper_f2723_0(final QuorumPacket pkt)
{    committedPkts.add(pkt);    pktsSize += LearnerHandler.packetSize(pkt);        for (int i = 0; pktsSize > pktsSizeLimit * 0.8 && i < 5; i++) {        QuorumPacket oldPkt = committedPkts.poll();        if (oldPkt == null) {            pktsSize = 0;            break;        }        pktsSize -= LearnerHandler.packetSize(oldPkt);    }        while (pktsSize > pktsSizeLimit) {        QuorumPacket oldPkt = committedPkts.poll();        if (oldPkt == null) {            pktsSize = 0;            break;        }        pktsSize -= LearnerHandler.packetSize(oldPkt);    }}
sendPacket
private synchronized void zookeeper_f2724_0(final QuorumPacket pkt)
{    for (LearnerHandler lh : activeObservers) {        lh.queuePacket(pkt);    }    lastProposedZxid = pkt.getZxid();}
proposalCommitted
 synchronized void zookeeper_f2725_0(long zxid)
{    QuorumPacket pkt = removeProposedPacket(zxid);    if (pkt == null) {        return;    }    cacheCommittedPacket(pkt);    sendPacket(pkt);}
informAndActivate
 synchronized void zookeeper_f2726_0(long zxid, long suggestedLeaderId)
{    QuorumPacket pkt = removeProposedPacket(zxid);    if (pkt == null) {        return;    }        QuorumPacket informAndActivateQP = Leader.buildInformAndActivePacket(zxid, suggestedLeaderId, pkt.getData());    cacheCommittedPacket(informAndActivateQP);    sendPacket(informAndActivateQP);}
start
public synchronized void zookeeper_f2727_0() throws IOException
{    if (thread != null && thread.isAlive()) {        return;    }    listenerRunning = true;        int backlog = 10;    if (self.shouldUsePortUnification() || self.isSslQuorum()) {        boolean allowInsecureConnection = self.shouldUsePortUnification();        if (self.getQuorumListenOnAllIPs()) {            ss = new UnifiedServerSocket(self.getX509Util(), allowInsecureConnection, port, backlog);        } else {            ss = new UnifiedServerSocket(self.getX509Util(), allowInsecureConnection, port, backlog, self.getQuorumAddress().getAddress());        }    } else {        if (self.getQuorumListenOnAllIPs()) {            ss = new ServerSocket(port, backlog);        } else {            ss = new ServerSocket(port, backlog, self.getQuorumAddress().getAddress());        }    }    thread = new Thread(this, "ObserverMaster");    thread.start();    pinger = Executors.newSingleThreadScheduledExecutor();    pinger.scheduleAtFixedRate(ping, self.tickTime / 2, self.tickTime / 2, TimeUnit.MILLISECONDS);}
run
public voidf2728_1)
{    ServerSocket ss;    synchronized (this) {        ss = this.ss;    }    while (listenerRunning) {        try {            Socket s = ss.accept();                                    s.setSoTimeout(self.tickTime * self.initLimit);            BufferedInputStream is = new BufferedInputStream(s.getInputStream());            LearnerHandler lh = new LearnerHandler(s, is, this);            lh.start();        } catch (Exception e) {            if (listenerRunning) {                            } else {                            }        }    }/*         * we don't need to close ss because we only got here because listenerRunning is         * false and that is set and then ss is closed() in stop()         */}
stop
public synchronized void zookeeper_f2729_0()
{    listenerRunning = false;    if (pinger != null) {        pinger.shutdownNow();    }    if (ss != null) {        try {            ss.close();        } catch (IOException e) {            e.printStackTrace();        }    }    for (LearnerHandler lh : activeObservers) {        lh.shutdown();    }}
getNumActiveObservers
 int zookeeper_f2730_0()
{    return activeObservers.size();}
getActiveObservers
public Iterable<Map<String, Object>> zookeeper_f2731_0()
{    Set<Map<String, Object>> info = new HashSet<>();    for (LearnerHandler lh : activeObservers) {        info.add(lh.getLearnerHandlerInfo());    }    return info;}
resetObserverConnectionStats
public void zookeeper_f2732_0()
{    for (LearnerHandler lh : activeObservers) {        lh.resetObserverConnectionStats();    }}
getPktsSizeLimit
 int zookeeper_f2733_0()
{    return pktsSizeLimit;}
setPktsSizeLimit
 static void zookeeper_f2734_0(final int sizeLimit)
{    pktsSizeLimit = sizeLimit;}
registerLearnerHandlerBean
public void zookeeper_f2735_0(final LearnerHandler learnerHandler, Socket socket)
{    LearnerHandlerBean bean = new LearnerHandlerBean(learnerHandler, socket);    if (zks.registerJMX(bean)) {        connectionBeans.put(learnerHandler, bean);    }}
unregisterLearnerHandlerBean
public void zookeeper_f2736_0(final LearnerHandler learnerHandler)
{    LearnerHandlerBean bean = connectionBeans.remove(learnerHandler);    if (bean != null) {        MBeanRegistry.getInstance().unregister(bean);    }}
run
public voidf2737_1)
{    try {        while (!finished) {            Request request = queuedRequests.take();            if (LOG.isTraceEnabled()) {                ZooTrace.logRequest(LOG, ZooTrace.CLIENT_REQUEST_TRACE_MASK, 'F', request, "");            }            if (request == Request.requestOfDeath) {                break;            }                        if (!zks.authWriteRequest(request)) {                continue;            }                                                nextProcessor.processRequest(request);                        switch(request.type) {                case OpCode.sync:                    zks.pendingSyncs.add(request);                    zks.getObserver().request(request);                    break;                case OpCode.create:                case OpCode.create2:                case OpCode.createTTL:                case OpCode.createContainer:                case OpCode.delete:                case OpCode.deleteContainer:                case OpCode.setData:                case OpCode.reconfig:                case OpCode.setACL:                case OpCode.multi:                case OpCode.check:                    zks.getObserver().request(request);                    break;                case OpCode.createSession:                case OpCode.closeSession:                                        if (!request.isLocalSession()) {                        zks.getObserver().request(request);                    }                    break;            }        }    } catch (Exception e) {        handleException(this.getName(), e);    }    }
processRequest
public voidf2738_1Request request)
{    if (!finished) {        Request upgradeRequest = null;        try {            upgradeRequest = zks.checkUpgradeSession(request);        } catch (KeeperException ke) {            if (request.getHdr() != null) {                request.getHdr().setType(OpCode.error);                request.setTxn(new ErrorTxn(ke.code().intValue()));            }            request.setException(ke);                    } catch (IOException ie) {                    }        if (upgradeRequest != null) {            queuedRequests.add(upgradeRequest);        }        queuedRequests.add(request);    }}
shutdown
public voidf2739_1)
{        finished = true;    queuedRequests.clear();    queuedRequests.add(Request.requestOfDeath);    nextProcessor.shutdown();}
getObserver
public Observer zookeeper_f2740_0()
{    return self.observer;}
getLearner
public Learner zookeeper_f2741_0()
{    return self.observer;}
commitRequest
public void zookeeper_f2742_0(Request request)
{    if (syncRequestProcessorEnabled) {                syncProcessor.processRequest(request);    }    commitProcessor.commit(request);}
setupRequestProcessors
protected void zookeeper_f2743_0()
{                RequestProcessor finalProcessor = new FinalRequestProcessor(this);    commitProcessor = new CommitProcessor(finalProcessor, Long.toString(getServerId()), true, getZooKeeperServerListener());    commitProcessor.start();    firstProcessor = new ObserverRequestProcessor(this, commitProcessor);    ((ObserverRequestProcessor) firstProcessor).start();    /*         * Observer should write to disk, so that the it won't request         * too old txn from the leader which may lead to getting an entire         * snapshot.         *         * However, this may degrade performance as it has to write to disk         * and do periodic snapshot which may double the memory requirements         */    if (syncRequestProcessorEnabled) {        syncProcessor = new SyncRequestProcessor(this, null);        syncProcessor.start();    }}
sync
public synchronized voidf2744_1)
{    if (pendingSyncs.size() == 0) {                return;    }    Request r = pendingSyncs.remove();    commitProcessor.commit(r);}
getState
public String zookeeper_f2745_0()
{    return "observer";}
shutdown
public synchronized voidf2746_1)
{    if (!canShutdown()) {                return;    }    super.shutdown();    if (syncRequestProcessorEnabled && syncProcessor != null) {        syncProcessor.shutdown();    }}
dumpMonitorValues
public void zookeeper_f2747_0(BiConsumer<String, Object> response)
{    super.dumpMonitorValues(response);    response.accept("observer_master_id", getObserver().getLearnerMasterId());}
getInputStream
public InputStream zookeeper_f2748_0() throws IOException
{    if (pushbackInputStream == null) {        return super.getInputStream();    }    return pushbackInputStream;}
prependToInputStream
public void zookeeper_f2749_0(byte[] bytes, int offset, int length) throws IOException
{    if (length == 0) {                return;    }    if (pushbackInputStream != null) {        throw new IOException("prependToInputStream() called more than once");    }    PushbackInputStream pushbackInputStream = new PushbackInputStream(getInputStream(), length);    pushbackInputStream.unread(bytes, offset, length);    this.pushbackInputStream = pushbackInputStream;}
initialize
public void zookeeper_f2750_0()
{    syncProcessor.start();}
processRequest
public void zookeeper_f2751_0(Request request) throws RequestProcessorException
{    if (request instanceof LearnerSyncRequest) {        zks.getLeader().processSync((LearnerSyncRequest) request);    } else {        nextProcessor.processRequest(request);        if (request.getHdr() != null) {                        try {                zks.getLeader().propose(request);            } catch (XidRolloverException e) {                throw new RequestProcessorException(e.getMessage(), e);            }            syncProcessor.processRequest(request);        }    }}
shutdown
public voidf2752_1)
{        nextProcessor.shutdown();    syncProcessor.shutdown();}
getName
public String zookeeper_f2753_0()
{    return name;}
isHidden
public boolean zookeeper_f2754_0()
{    return false;}
getQuorumSize
public int zookeeper_f2755_0()
{    return peer.getQuorumSize();}
getSyncLimit
public int zookeeper_f2756_0()
{    return peer.getSyncLimit();}
getInitLimit
public int zookeeper_f2757_0()
{    return peer.getInitLimit();}
setInitLimit
public void zookeeper_f2758_0(int initLimit)
{    peer.setInitLimit(initLimit);}
setSyncLimit
public void zookeeper_f2759_0(int syncLimit)
{    peer.setSyncLimit(syncLimit);}
isSslQuorum
public boolean zookeeper_f2760_0()
{    return peer.isSslQuorum();}
isPortUnification
public boolean zookeeper_f2761_0()
{    return peer.shouldUsePortUnification();}
getObserverElectionDelayMS
public long zookeeper_f2762_0()
{    return Observer.getObserverElectionDelayMs();}
setObserverElectionDelayMS
public void zookeeper_f2763_0(long delayMS)
{    Observer.setObserverElectionDelayMs(delayMS);}
parse
public static InitialMessage zookeeper_f2764_0(Long protocolVersion, DataInputStream din) throws InitialMessageException, IOException
{    Long sid;    if (protocolVersion != PROTOCOL_VERSION) {        throw new InitialMessageException("Got unrecognized protocol version %s", protocolVersion);    }    sid = din.readLong();    int remaining = din.readInt();    if (remaining <= 0 || remaining > maxBuffer) {        throw new InitialMessageException("Unreasonable buffer length: %s", remaining);    }    byte[] b = new byte[remaining];    int num_read = din.read(b);    if (num_read != remaining) {        throw new InitialMessageException("Read only %s bytes out of %s sent by server %s", num_read, remaining, sid);    }    String addr = new String(b);    String[] host_port;    try {        host_port = ConfigUtils.getHostAndPort(addr);    } catch (ConfigException e) {        throw new InitialMessageException("Badly formed address: %s", addr);    }    if (host_port.length != 2) {        throw new InitialMessageException("Badly formed address: %s", addr);    }    int port;    try {        port = Integer.parseInt(host_port[1]);    } catch (NumberFormatException e) {        throw new InitialMessageException("Bad port number: %s", host_port[1]);    } catch (ArrayIndexOutOfBoundsException e) {        throw new InitialMessageException("No port number in: %s", addr);    }    return new InitialMessage(sid, new InetSocketAddress(host_port[0], port));}
initializeAuth
private voidf2765_1final long mySid, final QuorumAuthServer authServer, final QuorumAuthLearner authLearner, final int quorumCnxnThreadsSize, final boolean quorumSaslAuthEnabled)
{    this.authServer = authServer;    this.authLearner = authLearner;    this.quorumSaslAuthEnabled = quorumSaslAuthEnabled;    if (!this.quorumSaslAuthEnabled) {                return;    }        final AtomicInteger threadIndex = new AtomicInteger(1);    SecurityManager s = System.getSecurityManager();    final ThreadGroup group = (s != null) ? s.getThreadGroup() : Thread.currentThread().getThreadGroup();    ThreadFactory daemonThFactory = new ThreadFactory() {        @Override        public Thread newThread(Runnable r) {            Thread t = new Thread(group, r, "QuorumConnectionThread-[myid=" + mySid + "]-" + threadIndex.getAndIncrement());            return t;        }    };    this.connectionExecutor = new ThreadPoolExecutor(3, quorumCnxnThreadsSize, 60, TimeUnit.SECONDS, new SynchronousQueue<Runnable>(), daemonThFactory);    this.connectionExecutor.allowCoreThreadTimeOut(true);}
newThread
public Thread zookeeper_f2766_0(Runnable r)
{    Thread t = new Thread(group, r, "QuorumConnectionThread-[myid=" + mySid + "]-" + threadIndex.getAndIncrement());    return t;}
testInitiateConnection
public voidf2767_1long sid) throws Exception
{        Socket sock = new Socket();    setSockOpts(sock);    sock.connect(self.getVotingView().get(sid).electionAddr, cnxTO);    initiateConnection(sock, sid);}
initiateConnection
public voidf2768_1final Socket sock, final Long sid)
{    try {        startConnection(sock, sid);    } catch (IOException e) {                closeSocket(sock);        return;    }}
initiateConnectionAsync
public voidf2769_1final Socket sock, final Long sid)
{    if (!inprogressConnections.add(sid)) {                                closeSocket(sock);        return;    }    try {        connectionExecutor.execute(new QuorumConnectionReqThread(sock, sid));        connectionThreadCnt.incrementAndGet();    } catch (Throwable e) {                                inprogressConnections.remove(sid);                closeSocket(sock);    }}
run
public void zookeeper_f2770_0()
{    try {        initiateConnection(sock, sid);    } finally {        inprogressConnections.remove(sid);    }}
startConnection
private booleanf2771_1Socket sock, Long sid) throws IOException
{    DataOutputStream dout = null;    DataInputStream din = null;    try {                        BufferedOutputStream buf = new BufferedOutputStream(sock.getOutputStream());        dout = new DataOutputStream(buf);                        dout.writeLong(PROTOCOL_VERSION);        dout.writeLong(self.getId());        String addr = formatInetAddr(self.getElectionAddress());        byte[] addr_bytes = addr.getBytes();        dout.writeInt(addr_bytes.length);        dout.write(addr_bytes);        dout.flush();        din = new DataInputStream(new BufferedInputStream(sock.getInputStream()));    } catch (IOException e) {                closeSocket(sock);        return false;    }        QuorumPeer.QuorumServer qps = self.getVotingView().get(sid);    if (qps != null) {                authLearner.authenticate(sock, qps.hostname);    }        if (sid > self.getId()) {                closeSocket(sock);        } else {        SendWorker sw = new SendWorker(sock, sid);        RecvWorker rw = new RecvWorker(sock, din, sid, sw);        sw.setRecv(rw);        SendWorker vsw = senderWorkerMap.get(sid);        if (vsw != null) {            vsw.finish();        }        senderWorkerMap.put(sid, sw);        queueSendMap.putIfAbsent(sid, new ArrayBlockingQueue<ByteBuffer>(SEND_CAPACITY));        sw.start();        rw.start();        return true;    }    return false;}
receiveConnection
public voidf2772_1final Socket sock)
{    DataInputStream din = null;    try {        din = new DataInputStream(new BufferedInputStream(sock.getInputStream()));        handleConnection(sock, din);    } catch (IOException e) {                closeSocket(sock);    }}
receiveConnectionAsync
public voidf2773_1final Socket sock)
{    try {        connectionExecutor.execute(new QuorumConnectionReceiverThread(sock));        connectionThreadCnt.incrementAndGet();    } catch (Throwable e) {                closeSocket(sock);    }}
run
public void zookeeper_f2774_0()
{    receiveConnection(sock);}
handleConnection
private voidf2775_1Socket sock, DataInputStream din) throws IOException
{    Long sid = null, protocolVersion = null;    InetSocketAddress electionAddr = null;    try {        protocolVersion = din.readLong();        if (protocolVersion >= 0) {                        sid = protocolVersion;        } else {            try {                InitialMessage init = InitialMessage.parse(protocolVersion, din);                sid = init.sid;                electionAddr = init.electionAddr;            } catch (InitialMessage.InitialMessageException ex) {                                closeSocket(sock);                return;            }        }        if (sid == QuorumPeer.OBSERVER_ID) {            /*                 * Choose identifier at random. We need a value to identify                 * the connection.                 */            sid = observerCounter.getAndDecrement();                    }    } catch (IOException e) {                closeSocket(sock);        return;    }        authServer.authenticate(sock, din);        if (sid < self.getId()) {        /*             * This replica might still believe that the connection to sid is             * up, so we have to shut down the workers before trying to open a             * new connection.             */        SendWorker sw = senderWorkerMap.get(sid);        if (sw != null) {            sw.finish();        }        /*             * Now we start a new connection             */                closeSocket(sock);        if (electionAddr != null) {            connectOne(sid, electionAddr);        } else {            connectOne(sid);        }    } else {                SendWorker sw = new SendWorker(sock, sid);        RecvWorker rw = new RecvWorker(sock, din, sid, sw);        sw.setRecv(rw);        SendWorker vsw = senderWorkerMap.get(sid);        if (vsw != null) {            vsw.finish();        }        senderWorkerMap.put(sid, sw);        queueSendMap.putIfAbsent(sid, new ArrayBlockingQueue<ByteBuffer>(SEND_CAPACITY));        sw.start();        rw.start();    }}
toSend
public void zookeeper_f2776_0(Long sid, ByteBuffer b)
{    /*         * If sending message to myself, then simply enqueue it (loopback).         */    if (this.mySid == sid) {        b.position(0);        addToRecvQueue(new Message(b.duplicate(), sid));    /*             * Otherwise send to the corresponding thread to send.             */    } else {        /*             * Start a new connection if doesn't have one already.             */        ArrayBlockingQueue<ByteBuffer> bq = queueSendMap.computeIfAbsent(sid, serverId -> new ArrayBlockingQueue<>(SEND_CAPACITY));        addToSendQueue(bq, b);        connectOne(sid);    }}
connectOne
 synchronized booleanf2777_1long sid, InetSocketAddress electionAddr)
{    if (senderWorkerMap.get(sid) != null) {                return true;    }    Socket sock = null;    try {                if (self.isSslQuorum()) {            sock = self.getX509Util().createSSLSocket();        } else {            sock = new Socket();        }        setSockOpts(sock);        sock.connect(electionAddr, cnxTO);        if (sock instanceof SSLSocket) {            SSLSocket sslSock = (SSLSocket) sock;            sslSock.startHandshake();                    }                        if (quorumSaslAuthEnabled) {            initiateConnectionAsync(sock, sid);        } else {            initiateConnection(sock, sid);        }        return true;    } catch (UnresolvedAddressException e) {                                                closeSocket(sock);        throw e;    } catch (X509Exception e) {                closeSocket(sock);        return false;    } catch (IOException e) {                closeSocket(sock);        return false;    }}
connectOne
 synchronized voidf2778_1long sid)
{    if (senderWorkerMap.get(sid) != null) {                return;    }    synchronized (self.QV_LOCK) {        boolean knownId = false;                        self.recreateSocketAddresses(sid);        Map<Long, QuorumPeer.QuorumServer> lastCommittedView = self.getView();        QuorumVerifier lastSeenQV = self.getLastSeenQuorumVerifier();        Map<Long, QuorumPeer.QuorumServer> lastProposedView = lastSeenQV.getAllMembers();        if (lastCommittedView.containsKey(sid)) {            knownId = true;            if (connectOne(sid, lastCommittedView.get(sid).electionAddr)) {                return;            }        }        if (lastSeenQV != null && lastProposedView.containsKey(sid) && (!knownId || (lastProposedView.get(sid).electionAddr != lastCommittedView.get(sid).electionAddr))) {            knownId = true;            if (connectOne(sid, lastProposedView.get(sid).electionAddr)) {                return;            }        }        if (!knownId) {                    }    }}
connectAll
public void zookeeper_f2779_0()
{    long sid;    for (Enumeration<Long> en = queueSendMap.keys(); en.hasMoreElements(); ) {        sid = en.nextElement();        connectOne(sid);    }}
haveDelivered
 booleanf2780_1)
{    for (ArrayBlockingQueue<ByteBuffer> queue : queueSendMap.values()) {                if (queue.size() == 0) {            return true;        }    }    return false;}
halt
public voidf2781_1)
{    shutdown = true;        listener.halt();        try {        listener.join();    } catch (InterruptedException ex) {            }    softHalt();        if (connectionExecutor != null) {        connectionExecutor.shutdown();    }    inprogressConnections.clear();    resetConnectionThreadCount();}
softHalt
public voidf2782_1)
{    for (SendWorker sw : senderWorkerMap.values()) {                sw.finish();    }}
setSockOpts
private void zookeeper_f2783_0(Socket sock) throws SocketException
{    sock.setTcpNoDelay(true);    sock.setKeepAlive(tcpKeepAlive);    sock.setSoTimeout(this.socketTimeout);}
closeSocket
private voidf2784_1Socket sock)
{    if (sock == null) {        return;    }    try {        sock.close();    } catch (IOException ie) {            }}
getThreadCount
public long zookeeper_f2785_0()
{    return threadCnt.get();}
getConnectionThreadCount
public long zookeeper_f2786_0()
{    return connectionThreadCnt.get();}
resetConnectionThreadCount
private void zookeeper_f2787_0()
{    connectionThreadCnt.set(0);}
setSocketBindErrorHandler
 void zookeeper_f2788_0(Runnable errorHandler)
{    this.socketBindErrorHandler = errorHandler;}
run
public voidf2789_1)
{    int numRetries = 0;    InetSocketAddress addr;    Socket client = null;    Exception exitException = null;    while ((!shutdown) && (portBindMaxRetry == 0 || numRetries < portBindMaxRetry)) {        try {            if (self.shouldUsePortUnification()) {                                ss = new UnifiedServerSocket(self.getX509Util(), true);            } else if (self.isSslQuorum()) {                                ss = new UnifiedServerSocket(self.getX509Util(), false);            } else {                ss = new ServerSocket();            }            ss.setReuseAddress(true);            if (self.getQuorumListenOnAllIPs()) {                int port = self.getElectionAddress().getPort();                addr = new InetSocketAddress(port);            } else {                                                self.recreateSocketAddresses(self.getId());                addr = self.getElectionAddress();            }                        setName(addr.toString());            ss.bind(addr);            while (!shutdown) {                try {                    client = ss.accept();                    setSockOpts(client);                                                            if (quorumSaslAuthEnabled) {                        receiveConnectionAsync(client);                    } else {                        receiveConnection(client);                    }                    numRetries = 0;                } catch (SocketTimeoutException e) {                                    }            }        } catch (IOException e) {            if (shutdown) {                break;            }                        exitException = e;            numRetries++;            try {                ss.close();                Thread.sleep(1000);            } catch (IOException ie) {                            } catch (InterruptedException ie) {                            }            closeSocket(client);        }    }        if (!shutdown) {                if (exitException instanceof SocketException) {                                                socketBindErrorHandler.run();        }    } else if (ss != null) {                try {            ss.close();        } catch (IOException ie) {                                }    }}
halt
 voidf2790_1)
{    try {                if (ss != null) {                        ss.close();        }    } catch (IOException e) {            }}
setRecv
 synchronized void zookeeper_f2791_0(RecvWorker recvWorker)
{    this.recvWorker = recvWorker;}
getRecvWorker
 synchronized RecvWorker zookeeper_f2792_0()
{    return recvWorker;}
finish
 synchronized booleanf2793_1)
{        if (!running) {        /*                 * Avoids running finish() twice.                 */        return running;    }    running = false;    closeSocket(sock);    this.interrupt();    if (recvWorker != null) {        recvWorker.finish();    }        senderWorkerMap.remove(sid, this);    threadCnt.decrementAndGet();    return running;}
send
 synchronized voidf2794_1ByteBuffer b) throws IOException
{    byte[] msgBytes = new byte[b.capacity()];    try {        b.position(0);        b.get(msgBytes);    } catch (BufferUnderflowException be) {                return;    }    dout.writeInt(b.capacity());    dout.write(b.array());    dout.flush();}
run
public voidf2795_1)
{    threadCnt.incrementAndGet();    try {        /**         * If there is nothing in the queue to send, then we         * send the lastMessage to ensure that the last message         * was received by the peer. The message could be dropped         * in case self or the peer shutdown their connection         * (and exit the thread) prior to reading/processing         * the last message. Duplicate messages are handled correctly         * by the peer.         *         * If the send queue is non-empty, then we have a recent         * message than that stored in lastMessage. To avoid sending         * stale message, we should send the message in the send queue.         */        ArrayBlockingQueue<ByteBuffer> bq = queueSendMap.get(sid);        if (bq == null || isSendQueueEmpty(bq)) {            ByteBuffer b = lastMessageSent.get(sid);            if (b != null) {                                send(b);            }        }    } catch (IOException e) {                this.finish();    }    try {        while (running && !shutdown && sock != null) {            ByteBuffer b = null;            try {                ArrayBlockingQueue<ByteBuffer> bq = queueSendMap.get(sid);                if (bq != null) {                    b = pollSendQueue(bq, 1000, TimeUnit.MILLISECONDS);                } else {                                        break;                }                if (b != null) {                    lastMessageSent.put(sid, b);                    send(b);                }            } catch (InterruptedException e) {                            }        }    } catch (Exception e) {            }    this.finish();    }
finish
 synchronized boolean zookeeper_f2796_0()
{    if (!running) {        /*                 * Avoids running finish() twice.                 */        return running;    }    running = false;    this.interrupt();    threadCnt.decrementAndGet();    return running;}
run
public voidf2797_1)
{    threadCnt.incrementAndGet();    try {        while (running && !shutdown && sock != null) {            /**             * Reads the first int to determine the length of the             * message             */            int length = din.readInt();            if (length <= 0 || length > PACKETMAXSIZE) {                throw new IOException("Received packet with invalid packet: " + length);            }            /**             * Allocates a new ByteBuffer to receive the message             */            final byte[] msgArray = new byte[length];            din.readFully(msgArray, 0, length);            addToRecvQueue(new Message(ByteBuffer.wrap(msgArray), sid));        }    } catch (Exception e) {            } finally {                sw.finish();        closeSocket(sock);    }}
addToSendQueue
private voidf2798_1ArrayBlockingQueue<ByteBuffer> queue, ByteBuffer buffer)
{    if (queue.remainingCapacity() == 0) {        try {            queue.remove();        } catch (NoSuchElementException ne) {                                }    }    try {        queue.add(buffer);    } catch (IllegalStateException ie) {                    }}
isSendQueueEmpty
private boolean zookeeper_f2799_0(ArrayBlockingQueue<ByteBuffer> queue)
{    return queue.isEmpty();}
pollSendQueue
private ByteBuffer zookeeper_f2800_0(ArrayBlockingQueue<ByteBuffer> queue, long timeout, TimeUnit unit) throws InterruptedException
{    return queue.poll(timeout, unit);}
addToRecvQueue
public voidf2801_1Message msg)
{    synchronized (recvQLock) {        if (recvQueue.remainingCapacity() == 0) {            try {                recvQueue.remove();            } catch (NoSuchElementException ne) {                                            }        }        try {            recvQueue.add(msg);        } catch (IllegalStateException ie) {                                }    }}
pollRecvQueue
public Message zookeeper_f2802_0(long timeout, TimeUnit unit) throws InterruptedException
{    return recvQueue.poll(timeout, unit);}
connectedToPeer
public boolean zookeeper_f2803_0(long peerSid)
{    return senderWorkerMap.get(peerSid) != null;}
getObserverMasterPort
public int zookeeper_f2804_0()
{    return observerMasterPort;}
setObserverMasterPort
public void zookeeper_f2805_0(int observerMasterPort)
{    this.observerMasterPort = observerMasterPort;}
getId
public long zookeeper_f2806_0()
{    return id;}
recreateSocketAddresses
public voidf2807_1)
{    if (this.addr == null) {                return;    }    if (this.electionAddr == null) {                return;    }    String host = this.addr.getHostString();    InetAddress address = null;    try {        address = InetAddress.getByName(host);    } catch (UnknownHostException ex) {                return;    }        int port = this.addr.getPort();    this.addr = new InetSocketAddress(address, port);    port = this.electionAddr.getPort();    this.electionAddr = new InetSocketAddress(address, port);}
setType
private void zookeeper_f2808_0(String s) throws ConfigException
{    if (s.toLowerCase().equals("observer")) {        type = LearnerType.OBSERVER;    } else if (s.toLowerCase().equals("participant")) {        type = LearnerType.PARTICIPANT;    } else {        throw new ConfigException("Unrecognised peertype: " + s);    }}
setMyAddrs
private void zookeeper_f2809_0()
{    this.myAddrs = new ArrayList<InetSocketAddress>();    this.myAddrs.add(this.addr);    this.myAddrs.add(this.clientAddr);    this.myAddrs.add(this.electionAddr);    this.myAddrs = excludedSpecialAddresses(this.myAddrs);}
delimitedHostString
public static String zookeeper_f2810_0(InetSocketAddress addr)
{    String host = addr.getHostString();    if (host.contains(":")) {        return "[" + host + "]";    } else {        return host;    }}
toString
public String zookeeper_f2811_0()
{    StringWriter sw = new StringWriter();        if (addr != null) {        sw.append(delimitedHostString(addr));        sw.append(":");        sw.append(String.valueOf(addr.getPort()));    }    if (electionAddr != null) {        sw.append(":");        sw.append(String.valueOf(electionAddr.getPort()));    }    if (type == LearnerType.OBSERVER) {        sw.append(":observer");    } else if (type == LearnerType.PARTICIPANT) {        sw.append(":participant");    }    if (clientAddr != null && !isClientAddrFromStatic) {        sw.append(";");        sw.append(delimitedHostString(clientAddr));        sw.append(":");        sw.append(String.valueOf(clientAddr.getPort()));    }    return sw.toString();}
hashCode
public int zookeeper_f2812_0()
{    assert false : "hashCode not designed";        return 42;}
checkAddressesEqual
private boolean zookeeper_f2813_0(InetSocketAddress addr1, InetSocketAddress addr2)
{    return (addr1 != null || addr2 == null) && (addr1 == null || addr2 != null) && (addr1 == null || addr2 == null || addr1.equals(addr2));}
equals
public boolean zookeeper_f2814_0(Object o)
{    if (!(o instanceof QuorumServer)) {        return false;    }    QuorumServer qs = (QuorumServer) o;    if ((qs.id != id) || (qs.type != type)) {        return false;    }    if (!checkAddressesEqual(addr, qs.addr)) {        return false;    }    if (!checkAddressesEqual(electionAddr, qs.electionAddr)) {        return false;    }    return checkAddressesEqual(clientAddr, qs.clientAddr);}
checkAddressDuplicate
public void zookeeper_f2815_0(QuorumServer s) throws BadArgumentsException
{    List<InetSocketAddress> otherAddrs = new ArrayList<InetSocketAddress>();    otherAddrs.add(s.addr);    otherAddrs.add(s.clientAddr);    otherAddrs.add(s.electionAddr);    otherAddrs = excludedSpecialAddresses(otherAddrs);    for (InetSocketAddress my : this.myAddrs) {        for (InetSocketAddress other : otherAddrs) {            if (my.equals(other)) {                String error = String.format("%s of server.%d conflicts %s of server.%d", my, this.id, other, s.id);                throw new BadArgumentsException(error);            }        }    }}
excludedSpecialAddresses
private List<InetSocketAddress> zookeeper_f2816_0(List<InetSocketAddress> addrs)
{    List<InetSocketAddress> included = new ArrayList<>();    for (InetSocketAddress addr : addrs) {        if (addr == null) {            continue;        }        InetAddress inetaddr = addr.getAddress();        if (        inetaddr == null || inetaddr.isAnyLocalAddress() || inetaddr.isLoopbackAddress()) {                        continue;        }        included.add(addr);    }    return included;}
getLearnerType
public LearnerType zookeeper_f2817_0()
{    return learnerType;}
setLearnerType
public void zookeeper_f2818_0(LearnerType p)
{    learnerType = p;}
setConfigFileName
protected synchronized void zookeeper_f2819_0(String s)
{    configFilename = s;}
getQuorumSize
public int zookeeper_f2820_0()
{    return getVotingView().size();}
setJvmPauseMonitor
public void zookeeper_f2821_0(JvmPauseMonitor jvmPauseMonitor)
{    this.jvmPauseMonitor = jvmPauseMonitor;}
getId
public long zookeeper_f2822_0()
{    return myid;}
setId
 void zookeeper_f2823_0(long id)
{    this.myid = id;}
isSslQuorum
public boolean zookeeper_f2824_0()
{    return sslQuorum;}
shouldUsePortUnification
public boolean zookeeper_f2825_0()
{    return shouldUsePortUnification;}
getX509Util
 QuorumX509Util zookeeper_f2826_0()
{    return x509Util;}
getCurrentVote
public synchronized Vote zookeeper_f2827_0()
{    return currentVote;}
setCurrentVote
public synchronized void zookeeper_f2828_0(Vote v)
{    currentVote = v;}
run
public voidf2829_1)
{    try {        byte[] b = new byte[36];        ByteBuffer responseBuffer = ByteBuffer.wrap(b);        DatagramPacket packet = new DatagramPacket(b, b.length);        while (running) {            udpSocket.receive(packet);            if (packet.getLength() != 4) {                            } else {                responseBuffer.clear();                                responseBuffer.getInt();                responseBuffer.putLong(myid);                Vote current = getCurrentVote();                switch(getPeerState()) {                    case LOOKING:                        responseBuffer.putLong(current.getId());                        responseBuffer.putLong(current.getZxid());                        break;                    case LEADING:                        responseBuffer.putLong(myid);                        try {                            long proposed;                            synchronized (leader) {                                proposed = leader.lastProposed;                            }                            responseBuffer.putLong(proposed);                        } catch (NullPointerException npe) {                                                                        }                        break;                    case FOLLOWING:                        responseBuffer.putLong(current.getId());                        try {                            responseBuffer.putLong(follower.getZxid());                        } catch (NullPointerException npe) {                                                                        }                        break;                    case OBSERVING:                                                break;                }                packet.setData(b);                udpSocket.send(packet);            }            packet.setLength(b.length);        }    } catch (RuntimeException e) {            } catch (IOException e) {            } finally {            }}
setPeerState
public synchronized voidf2830_1ServerState newState)
{    state = newState;    if (newState == ServerState.LOOKING) {        setLeaderAddressAndId(null, -1);        setZabState(ZabState.ELECTION);    } else {            }}
setZabState
public voidf2831_1ZabState zabState)
{    this.zabState.set(zabState);    }
setSyncMode
public voidf2832_1SyncMode syncMode)
{    this.syncMode.set(syncMode);    }
getZabState
public ZabState zookeeper_f2833_0()
{    return zabState.get();}
getSyncMode
public SyncMode zookeeper_f2834_0()
{    return syncMode.get();}
setLeaderAddressAndId
public void zookeeper_f2835_0(InetSocketAddress addr, long newId)
{    if (addr != null) {        leaderAddress.set(addr.getHostString());    } else {        leaderAddress.set(null);    }    leaderId.set(newId);}
getLeaderAddress
public String zookeeper_f2836_0()
{    return leaderAddress.get();}
getLeaderId
public long zookeeper_f2837_0()
{    return leaderId.get();}
getDetailedPeerState
public String zookeeper_f2838_0()
{    final StringBuilder sb = new StringBuilder(getPeerState().toString().toLowerCase());    final ZabState zabState = getZabState();    if (!ZabState.ELECTION.equals(zabState)) {        sb.append(" - ").append(zabState.toString().toLowerCase());    }    final SyncMode syncMode = getSyncMode();    if (!SyncMode.NONE.equals(syncMode)) {        sb.append(" - ").append(syncMode.toString().toLowerCase());    }    return sb.toString();}
reconfigFlagSet
public synchronized void zookeeper_f2839_0()
{    reconfigFlag = true;}
reconfigFlagClear
public synchronized void zookeeper_f2840_0()
{    reconfigFlag = false;}
isReconfigStateChange
public synchronized boolean zookeeper_f2841_0()
{    return reconfigFlag;}
getPeerState
public synchronized ServerState zookeeper_f2842_0()
{    return state;}
recreateSocketAddresses
public void zookeeper_f2843_0(long id)
{    QuorumVerifier qv = getQuorumVerifier();    if (qv != null) {        QuorumServer qs = qv.getAllMembers().get(id);        if (qs != null) {            qs.recreateSocketAddresses();            if (id == getId()) {                setAddrs(qs.addr, qs.electionAddr, qs.clientAddr);            }        }    }    qv = getLastSeenQuorumVerifier();    if (qv != null) {        QuorumServer qs = qv.getAllMembers().get(id);        if (qs != null) {            qs.recreateSocketAddresses();        }    }}
getAddrs
private AddressTuple zookeeper_f2844_0()
{    AddressTuple addrs = myAddrs.get();    if (addrs != null) {        return addrs;    }    try {        synchronized (QV_LOCK) {            addrs = myAddrs.get();            while (addrs == null) {                QV_LOCK.wait();                addrs = myAddrs.get();            }            return addrs;        }    } catch (InterruptedException e) {        Thread.currentThread().interrupt();        throw new RuntimeException(e);    }}
getQuorumAddress
public InetSocketAddress zookeeper_f2845_0()
{    return getAddrs().quorumAddr;}
getElectionAddress
public InetSocketAddress zookeeper_f2846_0()
{    return getAddrs().electionAddr;}
getClientAddress
public InetSocketAddress zookeeper_f2847_0()
{    final AddressTuple addrs = myAddrs.get();    return (addrs == null) ? null : addrs.clientAddr;}
setAddrs
private void zookeeper_f2848_0(InetSocketAddress quorumAddr, InetSocketAddress electionAddr, InetSocketAddress clientAddr)
{    synchronized (QV_LOCK) {        myAddrs.set(new AddressTuple(quorumAddr, electionAddr, clientAddr));        QV_LOCK.notifyAll();    }}
testingQuorumPeer
public static QuorumPeer zookeeper_f2849_0() throws SaslException
{    return new QuorumPeer();}
createX509Util
 QuorumX509Util zookeeper_f2850_0()
{    return new QuorumX509Util();}
initialize
public void zookeeper_f2851_0() throws SaslException
{        if (isQuorumSaslAuthEnabled()) {        Set<String> authzHosts = new HashSet<String>();        for (QuorumServer qs : getView().values()) {            authzHosts.add(qs.hostname);        }        authServer = new SaslQuorumAuthServer(isQuorumServerSaslAuthRequired(), quorumServerLoginContext, authzHosts);        authLearner = new SaslQuorumAuthLearner(isQuorumLearnerSaslAuthRequired(), quorumServicePrincipal, quorumLearnerLoginContext);    } else {        authServer = new NullQuorumAuthServer();        authLearner = new NullQuorumAuthLearner();    }}
quorumStats
 QuorumStats zookeeper_f2852_0()
{    return quorumStats;}
start
public synchronized voidf2853_1)
{    if (!getView().containsKey(myid)) {        throw new RuntimeException("My id " + myid + " not in the peer list");    }    loadDataBase();    startServerCnxnFactory();    try {        adminServer.start();    } catch (AdminServerException e) {                System.out.println(e);    }    startLeaderElection();    startJvmPauseMonitor();    super.start();}
loadDataBase
private voidf2854_1)
{    try {        zkDb.loadDataBase();                long lastProcessedZxid = zkDb.getDataTree().lastProcessedZxid;        long epochOfZxid = ZxidUtils.getEpochFromZxid(lastProcessedZxid);        try {            currentEpoch = readLongFromFile(CURRENT_EPOCH_FILENAME);        } catch (FileNotFoundException e) {                                                currentEpoch = epochOfZxid;                        writeLongToFile(CURRENT_EPOCH_FILENAME, currentEpoch);        }        if (epochOfZxid > currentEpoch) {            throw new IOException("The current epoch, " + ZxidUtils.zxidToString(currentEpoch) + ", is older than the last zxid, " + lastProcessedZxid);        }        try {            acceptedEpoch = readLongFromFile(ACCEPTED_EPOCH_FILENAME);        } catch (FileNotFoundException e) {                                                acceptedEpoch = epochOfZxid;                        writeLongToFile(ACCEPTED_EPOCH_FILENAME, acceptedEpoch);        }        if (acceptedEpoch < currentEpoch) {            throw new IOException("The accepted epoch, " + ZxidUtils.zxidToString(acceptedEpoch) + " is less than the current epoch, " + ZxidUtils.zxidToString(currentEpoch));        }    } catch (IOException ie) {                throw new RuntimeException("Unable to run quorum server ", ie);    }}
stopLeaderElection
public synchronized void zookeeper_f2855_0()
{    responder.running = false;    responder.interrupt();}
startLeaderElection
public synchronized void zookeeper_f2856_0()
{    try {        if (getPeerState() == ServerState.LOOKING) {            currentVote = new Vote(myid, getLastLoggedZxid(), getCurrentEpoch());        }    } catch (IOException e) {        RuntimeException re = new RuntimeException(e.getMessage());        re.setStackTrace(e.getStackTrace());        throw re;    }    this.electionAlg = createElectionAlgorithm(electionType);}
startJvmPauseMonitor
private void zookeeper_f2857_0()
{    if (this.jvmPauseMonitor != null) {        this.jvmPauseMonitor.serviceStart();    }}
countParticipants
protected static int zookeeper_f2858_0(Map<Long, QuorumServer> peers)
{    int count = 0;    for (QuorumServer q : peers.values()) {        if (q.type == LearnerType.PARTICIPANT) {            count++;        }    }    return count;}
getClientAddress
private static InetSocketAddress zookeeper_f2859_0(Map<Long, QuorumServer> quorumPeers, long myid, int clientPort) throws IOException
{    QuorumServer quorumServer = quorumPeers.get(myid);    if (null == quorumServer) {        throw new IOException("No QuorumServer correspoding to myid " + myid);    }    if (null == quorumServer.clientAddr) {        return new InetSocketAddress(clientPort);    }    if (quorumServer.clientAddr.getPort() != clientPort) {        throw new IOException("QuorumServer port " + quorumServer.clientAddr.getPort() + " does not match with given port " + clientPort);    }    return quorumServer.clientAddr;}
getLastLoggedZxid
public long zookeeper_f2860_0()
{    if (!zkDb.isInitialized()) {        loadDataBase();    }    return zkDb.getDataTreeLastProcessedZxid();}
makeFollower
protected Follower zookeeper_f2861_0(FileTxnSnapLog logFactory) throws IOException
{    return new Follower(this, new FollowerZooKeeperServer(logFactory, this, this.zkDb));}
makeLeader
protected Leader zookeeper_f2862_0(FileTxnSnapLog logFactory) throws IOException, X509Exception
{    return new Leader(this, new LeaderZooKeeperServer(logFactory, this, this.zkDb));}
makeObserver
protected Observer zookeeper_f2863_0(FileTxnSnapLog logFactory) throws IOException
{    return new Observer(this, new ObserverZooKeeperServer(logFactory, this, this.zkDb));}
createElectionAlgorithm
protected Electionf2864_1int electionAlgorithm)
{    Election le = null;        switch(electionAlgorithm) {        case 1:            le = new AuthFastLeaderElection(this);            break;        case 2:            le = new AuthFastLeaderElection(this, true);            break;        case 3:            QuorumCnxManager qcm = createCnxnManager();            QuorumCnxManager oldQcm = qcmRef.getAndSet(qcm);            if (oldQcm != null) {                                oldQcm.halt();            }            QuorumCnxManager.Listener listener = qcm.listener;            if (listener != null) {                listener.start();                FastLeaderElection fle = new FastLeaderElection(this, qcm);                fle.start();                le = fle;            } else {                            }            break;        default:            assert false;    }    return le;}
makeLEStrategy
protected Electionf2865_1)
{        return electionAlg;}
setLeader
protected synchronized void zookeeper_f2866_0(Leader newLeader)
{    leader = newLeader;}
setFollower
protected synchronized void zookeeper_f2867_0(Follower newFollower)
{    follower = newFollower;}
setObserver
protected synchronized void zookeeper_f2868_0(Observer newObserver)
{    observer = newObserver;}
getActiveServer
public synchronized ZooKeeperServer zookeeper_f2869_0()
{    if (leader != null) {        return leader.zk;    } else if (follower != null) {        return follower.zk;    } else if (observer != null) {        return observer.zk;    }    return null;}
run
public voidf2870_1)
{    updateThreadName();        try {        jmxQuorumBean = new QuorumBean(this);        MBeanRegistry.getInstance().register(jmxQuorumBean, null);        for (QuorumServer s : getView().values()) {            ZKMBeanInfo p;            if (getId() == s.id) {                p = jmxLocalPeerBean = new LocalPeerBean(this);                try {                    MBeanRegistry.getInstance().register(p, jmxQuorumBean);                } catch (Exception e) {                                        jmxLocalPeerBean = null;                }            } else {                RemotePeerBean rBean = new RemotePeerBean(this, s);                try {                    MBeanRegistry.getInstance().register(rBean, jmxQuorumBean);                    jmxRemotePeerBean.put(s.id, rBean);                } catch (Exception e) {                                    }            }        }    } catch (Exception e) {                jmxQuorumBean = null;    }    try {        /*             * Main loop             */        while (running) {            switch(getPeerState()) {                case LOOKING:                                        ServerMetrics.getMetrics().LOOKING_COUNT.add(1);                    if (Boolean.getBoolean("readonlymode.enabled")) {                                                                        final ReadOnlyZooKeeperServer roZk = new ReadOnlyZooKeeperServer(logFactory, this, this.zkDb);                                                                                                                                                                        Thread roZkMgr = new Thread() {                            public void run() {                                try {                                                                        sleep(Math.max(2000, tickTime));                                    if (ServerState.LOOKING.equals(getPeerState())) {                                        roZk.startup();                                    }                                } catch (InterruptedException e) {                                                                    } catch (Exception e) {                                                                    }                            }                        };                        try {                            roZkMgr.start();                            reconfigFlagClear();                            if (shuttingDownLE) {                                shuttingDownLE = false;                                startLeaderElection();                            }                            setCurrentVote(makeLEStrategy().lookForLeader());                        } catch (Exception e) {                                                        setPeerState(ServerState.LOOKING);                        } finally {                                                                                    roZkMgr.interrupt();                            roZk.shutdown();                        }                    } else {                        try {                            reconfigFlagClear();                            if (shuttingDownLE) {                                shuttingDownLE = false;                                startLeaderElection();                            }                            setCurrentVote(makeLEStrategy().lookForLeader());                        } catch (Exception e) {                                                        setPeerState(ServerState.LOOKING);                        }                    }                    break;                case OBSERVING:                    try {                                                setObserver(makeObserver(logFactory));                        observer.observeLeader();                    } catch (Exception e) {                                            } finally {                        observer.shutdown();                        setObserver(null);                        updateServerState();                                                if (isRunning()) {                            Observer.waitForObserverElectionDelay();                        }                    }                    break;                case FOLLOWING:                    try {                                                setFollower(makeFollower(logFactory));                        follower.followLeader();                    } catch (Exception e) {                                            } finally {                        follower.shutdown();                        setFollower(null);                        updateServerState();                    }                    break;                case LEADING:                                        try {                        setLeader(makeLeader(logFactory));                        leader.lead();                        setLeader(null);                    } catch (Exception e) {                                            } finally {                        if (leader != null) {                            leader.shutdown("Forcing shutdown");                            setLeader(null);                        }                        updateServerState();                    }                    break;            }        }    } finally {                MBeanRegistry instance = MBeanRegistry.getInstance();        instance.unregister(jmxQuorumBean);        instance.unregister(jmxLocalPeerBean);        for (RemotePeerBean remotePeerBean : jmxRemotePeerBean.values()) {            instance.unregister(remotePeerBean);        }        jmxQuorumBean = null;        jmxLocalPeerBean = null;        jmxRemotePeerBean = null;    }}
run
public voidf2871_1)
{    try {                sleep(Math.max(2000, tickTime));        if (ServerState.LOOKING.equals(getPeerState())) {            roZk.startup();        }    } catch (InterruptedException e) {            } catch (Exception e) {            }}
updateServerState
private synchronized voidf2872_1)
{    if (!reconfigFlag) {        setPeerState(ServerState.LOOKING);                return;    }    if (getId() == getCurrentVote().getId()) {        setPeerState(ServerState.LEADING);            } else if (getLearnerType() == LearnerType.PARTICIPANT) {        setPeerState(ServerState.FOLLOWING);            } else if (getLearnerType() == LearnerType.OBSERVER) {        setPeerState(ServerState.OBSERVING);            } else {                setPeerState(ServerState.LOOKING);            }    reconfigFlag = false;}
shutdown
public voidf2873_1)
{    running = false;    x509Util.close();    if (leader != null) {        leader.shutdown("quorum Peer shutdown");    }    if (follower != null) {        follower.shutdown();    }    shutdownServerCnxnFactory();    if (udpSocket != null) {        udpSocket.close();    }    if (jvmPauseMonitor != null) {        jvmPauseMonitor.serviceStop();    }    try {        adminServer.shutdown();    } catch (AdminServerException e) {            }    if (getElectionAlg() != null) {        this.interrupt();        getElectionAlg().shutdown();    }    try {        zkDb.close();    } catch (IOException ie) {            }}
getView
public Map<Long, QuorumPeer.QuorumServer> zookeeper_f2874_0()
{    return Collections.unmodifiableMap(getQuorumVerifier().getAllMembers());}
getVotingView
public Map<Long, QuorumPeer.QuorumServer> zookeeper_f2875_0()
{    return getQuorumVerifier().getVotingMembers();}
getObservingView
public Map<Long, QuorumPeer.QuorumServer> zookeeper_f2876_0()
{    return getQuorumVerifier().getObservingMembers();}
getCurrentAndNextConfigVoters
public synchronized Set<Long> zookeeper_f2877_0()
{    Set<Long> voterIds = new HashSet<Long>(getQuorumVerifier().getVotingMembers().keySet());    if (getLastSeenQuorumVerifier() != null) {        voterIds.addAll(getLastSeenQuorumVerifier().getVotingMembers().keySet());    }    return voterIds;}
viewContains
public boolean zookeeper_f2878_0(Long sid)
{    return this.getView().containsKey(sid);}
getQuorumPeers
public String[] zookeeper_f2879_0()
{    List<String> l = new ArrayList<String>();    synchronized (this) {        if (leader != null) {            for (LearnerHandler fh : leader.getLearners()) {                if (fh.getSocket() != null) {                    String s = formatInetAddr((InetSocketAddress) fh.getSocket().getRemoteSocketAddress());                    if (leader.isLearnerSynced(fh)) {                        s += "*";                    }                    l.add(s);                }            }        } else if (follower != null) {            l.add(formatInetAddr((InetSocketAddress) follower.sock.getRemoteSocketAddress()));        }    }    return l.toArray(new String[0]);}
getServerState
public String zookeeper_f2880_0()
{    switch(getPeerState()) {        case LOOKING:            return QuorumStats.Provider.LOOKING_STATE;        case LEADING:            return QuorumStats.Provider.LEADING_STATE;        case FOLLOWING:            return QuorumStats.Provider.FOLLOWING_STATE;        case OBSERVING:            return QuorumStats.Provider.OBSERVING_STATE;    }    return QuorumStats.Provider.UNKNOWN_STATE;}
setMyid
public void zookeeper_f2881_0(long myid)
{    this.myid = myid;}
setInitialConfig
public void zookeeper_f2882_0(String initialConfig)
{    this.initialConfig = initialConfig;}
getInitialConfig
public String zookeeper_f2883_0()
{    return initialConfig;}
getTickTime
public int zookeeper_f2884_0()
{    return tickTime;}
setTickTime
public voidf2885_1int tickTime)
{        this.tickTime = tickTime;}
getMaxClientCnxnsPerHost
public int zookeeper_f2886_0()
{    if (cnxnFactory != null) {        return cnxnFactory.getMaxClientCnxnsPerHost();    }    if (secureCnxnFactory != null) {        return secureCnxnFactory.getMaxClientCnxnsPerHost();    }    return -1;}
areLocalSessionsEnabled
public boolean zookeeper_f2887_0()
{    return localSessionsEnabled;}
enableLocalSessions
public voidf2888_1boolean flag)
{        localSessionsEnabled = flag;}
isLocalSessionsUpgradingEnabled
public boolean zookeeper_f2889_0()
{    return localSessionsUpgradingEnabled;}
enableLocalSessionsUpgrading
public voidf2890_1boolean flag)
{        localSessionsUpgradingEnabled = flag;}
getMinSessionTimeout
public int zookeeper_f2891_0()
{    return minSessionTimeout;}
setMinSessionTimeout
public voidf2892_1int min)
{        this.minSessionTimeout = min;}
getMaxSessionTimeout
public int zookeeper_f2893_0()
{    return maxSessionTimeout;}
setMaxSessionTimeout
public voidf2894_1int max)
{        this.maxSessionTimeout = max;}
getClientPortListenBacklog
public int zookeeper_f2895_0()
{    return this.clientPortListenBacklog;}
setClientPortListenBacklog
public void zookeeper_f2896_0(int backlog)
{    this.clientPortListenBacklog = backlog;}
getInitLimit
public int zookeeper_f2897_0()
{    return initLimit;}
setInitLimit
public voidf2898_1int initLimit)
{        this.initLimit = initLimit;}
getTick
public int zookeeper_f2899_0()
{    return tick.get();}
configFromString
public QuorumVerifier zookeeper_f2900_0(String s) throws IOException, ConfigException
{    Properties props = new Properties();    props.load(new StringReader(s));    return QuorumPeerConfig.parseDynamicConfig(props, electionType, false, false);}
getQuorumVerifier
public QuorumVerifier zookeeper_f2901_0()
{    synchronized (QV_LOCK) {        return quorumVerifier;    }}
getLastSeenQuorumVerifier
public QuorumVerifier zookeeper_f2902_0()
{    synchronized (QV_LOCK) {        return lastSeenQuorumVerifier;    }}
restartLeaderElection
public synchronized voidf2903_1QuorumVerifier qvOLD, QuorumVerifier qvNEW)
{    if (qvOLD == null || !qvOLD.equals(qvNEW)) {                getElectionAlg().shutdown();        shuttingDownLE = false;        startLeaderElection();    }}
getNextDynamicConfigFilename
public Stringf2904_1)
{    if (configFilename == null) {                return null;    }    return configFilename + QuorumPeerConfig.nextDynamicConfigFileSuffix;}
connectNewPeers
private void zookeeper_f2905_0(QuorumCnxManager qcm)
{    if (quorumVerifier != null && lastSeenQuorumVerifier != null) {        Map<Long, QuorumServer> committedView = quorumVerifier.getAllMembers();        for (Entry<Long, QuorumServer> e : lastSeenQuorumVerifier.getAllMembers().entrySet()) {            if (e.getKey() != getId() && !committedView.containsKey(e.getKey())) {                qcm.connectOne(e.getKey());            }        }    }}
setLastSeenQuorumVerifier
public voidf2906_1QuorumVerifier qv, boolean writeToDisk)
{                                QuorumCnxManager qcm = qcmRef.get();    Object outerLockObject = (qcm != null) ? qcm : QV_LOCK;    synchronized (outerLockObject) {        synchronized (QV_LOCK) {            if (lastSeenQuorumVerifier != null && lastSeenQuorumVerifier.getVersion() > qv.getVersion()) {                            }                        if (lastSeenQuorumVerifier != null && lastSeenQuorumVerifier.getVersion() == qv.getVersion()) {                return;            }            lastSeenQuorumVerifier = qv;            if (qcm != null) {                connectNewPeers(qcm);            }            if (writeToDisk) {                try {                    String fileName = getNextDynamicConfigFilename();                    if (fileName != null) {                        QuorumPeerConfig.writeDynamicConfig(fileName, qv, true);                    }                } catch (IOException e) {                                    }            }        }    }}
setQuorumVerifier
public QuorumVerifierf2907_1QuorumVerifier qv, boolean writeToDisk)
{    synchronized (QV_LOCK) {        if ((quorumVerifier != null) && (quorumVerifier.getVersion() >= qv.getVersion())) {                                                return quorumVerifier;        }        QuorumVerifier prevQV = quorumVerifier;        quorumVerifier = qv;        if (lastSeenQuorumVerifier == null || (qv.getVersion() > lastSeenQuorumVerifier.getVersion())) {            lastSeenQuorumVerifier = qv;        }        if (writeToDisk) {                        if (configFilename != null) {                try {                    String dynamicConfigFilename = makeDynamicConfigFilename(qv.getVersion());                    QuorumPeerConfig.writeDynamicConfig(dynamicConfigFilename, qv, false);                    QuorumPeerConfig.editStaticConfig(configFilename, dynamicConfigFilename, needEraseClientInfoFromStaticConfig());                } catch (IOException e) {                                    }            } else {                            }        }        if (qv.getVersion() == lastSeenQuorumVerifier.getVersion()) {            QuorumPeerConfig.deleteFile(getNextDynamicConfigFilename());        }        QuorumServer qs = qv.getAllMembers().get(getId());        if (qs != null) {            setAddrs(qs.addr, qs.electionAddr, qs.clientAddr);        }        updateObserverMasterList();        return prevQV;    }}
makeDynamicConfigFilename
private String zookeeper_f2908_0(long version)
{    return configFilename + ".dynamic." + Long.toHexString(version);}
needEraseClientInfoFromStaticConfig
private boolean zookeeper_f2909_0()
{    QuorumServer server = quorumVerifier.getAllMembers().get(getId());    return (server != null && server.clientAddr != null && !server.isClientAddrFromStatic);}
getElectionAlg
public Election zookeeper_f2910_0()
{    return electionAlg;}
getSyncLimit
public int zookeeper_f2911_0()
{    return syncLimit;}
setSyncLimit
public voidf2912_1int syncLimit)
{        this.syncLimit = syncLimit;}
getConnectToLearnerMasterLimit
public int zookeeper_f2913_0()
{    return connectToLearnerMasterLimit;}
setConnectToLearnerMasterLimit
public voidf2914_1int connectToLearnerMasterLimit)
{        this.connectToLearnerMasterLimit = connectToLearnerMasterLimit;}
getSyncEnabled
public booleanf2915_1)
{    if (System.getProperty(SYNC_ENABLED) != null) {                return Boolean.getBoolean(SYNC_ENABLED);    } else {        return syncEnabled;    }}
setSyncEnabled
public void zookeeper_f2916_0(boolean syncEnabled)
{    this.syncEnabled = syncEnabled;}
getElectionType
public int zookeeper_f2917_0()
{    return electionType;}
setElectionType
public void zookeeper_f2918_0(int electionType)
{    this.electionType = electionType;}
getQuorumListenOnAllIPs
public boolean zookeeper_f2919_0()
{    return quorumListenOnAllIPs;}
setQuorumListenOnAllIPs
public void zookeeper_f2920_0(boolean quorumListenOnAllIPs)
{    this.quorumListenOnAllIPs = quorumListenOnAllIPs;}
setCnxnFactory
public void zookeeper_f2921_0(ServerCnxnFactory cnxnFactory)
{    this.cnxnFactory = cnxnFactory;}
setSecureCnxnFactory
public void zookeeper_f2922_0(ServerCnxnFactory secureCnxnFactory)
{    this.secureCnxnFactory = secureCnxnFactory;}
setSslQuorum
public voidf2923_1boolean sslQuorum)
{    if (sslQuorum) {            } else {            }    this.sslQuorum = sslQuorum;}
setUsePortUnification
public voidf2924_1boolean shouldUsePortUnification)
{        this.shouldUsePortUnification = shouldUsePortUnification;}
startServerCnxnFactory
private void zookeeper_f2925_0()
{    if (cnxnFactory != null) {        cnxnFactory.start();    }    if (secureCnxnFactory != null) {        secureCnxnFactory.start();    }}
shutdownServerCnxnFactory
private void zookeeper_f2926_0()
{    if (cnxnFactory != null) {        cnxnFactory.shutdown();    }    if (secureCnxnFactory != null) {        secureCnxnFactory.shutdown();    }}
setZooKeeperServer
public void zookeeper_f2927_0(ZooKeeperServer zks)
{    if (cnxnFactory != null) {        cnxnFactory.setZooKeeperServer(zks);    }    if (secureCnxnFactory != null) {        secureCnxnFactory.setZooKeeperServer(zks);    }}
closeAllConnections
public void zookeeper_f2928_0()
{    if (cnxnFactory != null) {        cnxnFactory.closeAll(ServerCnxn.DisconnectReason.SERVER_SHUTDOWN);    }    if (secureCnxnFactory != null) {        secureCnxnFactory.closeAll(ServerCnxn.DisconnectReason.SERVER_SHUTDOWN);    }}
getClientPort
public int zookeeper_f2929_0()
{    if (cnxnFactory != null) {        return cnxnFactory.getLocalPort();    }    return -1;}
setTxnFactory
public void zookeeper_f2930_0(FileTxnSnapLog factory)
{    this.logFactory = factory;}
getTxnFactory
public FileTxnSnapLog zookeeper_f2931_0()
{    return this.logFactory;}
setZKDatabase
public void zookeeper_f2932_0(ZKDatabase database)
{    this.zkDb = database;}
getZkDb
protected ZKDatabase zookeeper_f2933_0()
{    return zkDb;}
initConfigInZKDatabase
public synchronized void zookeeper_f2934_0()
{    if (zkDb != null) {        zkDb.initConfigInZKDatabase(getQuorumVerifier());    }}
isRunning
public boolean zookeeper_f2935_0()
{    return running;}
getQuorumCnxManager
public QuorumCnxManager zookeeper_f2936_0()
{    return qcmRef.get();}
readLongFromFile
private long zookeeper_f2937_0(String name) throws IOException
{    File file = new File(logFactory.getSnapDir(), name);    BufferedReader br = new BufferedReader(new FileReader(file));    String line = "";    try {        line = br.readLine();        return Long.parseLong(line);    } catch (NumberFormatException e) {        throw new IOException("Found " + line + " in " + file);    } finally {        br.close();    }}
writeLongToFile
private void zookeeper_f2938_0(String name, final long value) throws IOException
{    File file = new File(logFactory.getSnapDir(), name);    new AtomicFileWritingIdiom(file, new WriterStatement() {        @Override        public void write(Writer bw) throws IOException {            bw.write(Long.toString(value));        }    });}
write
public void zookeeper_f2939_0(Writer bw) throws IOException
{    bw.write(Long.toString(value));}
getCurrentEpoch
public long zookeeper_f2940_0() throws IOException
{    if (currentEpoch == -1) {        currentEpoch = readLongFromFile(CURRENT_EPOCH_FILENAME);    }    return currentEpoch;}
getAcceptedEpoch
public long zookeeper_f2941_0() throws IOException
{    if (acceptedEpoch == -1) {        acceptedEpoch = readLongFromFile(ACCEPTED_EPOCH_FILENAME);    }    return acceptedEpoch;}
setCurrentEpoch
public void zookeeper_f2942_0(long e) throws IOException
{    currentEpoch = e;    writeLongToFile(CURRENT_EPOCH_FILENAME, e);}
setAcceptedEpoch
public void zookeeper_f2943_0(long e) throws IOException
{    acceptedEpoch = e;    writeLongToFile(ACCEPTED_EPOCH_FILENAME, e);}
processReconfig
public booleanf2944_1QuorumVerifier qv, Long suggestedLeaderId, Long zxid, boolean restartLE)
{    if (!QuorumPeerConfig.isReconfigEnabled()) {                return false;    }    InetSocketAddress oldClientAddr = getClientAddress();            QuorumVerifier prevQV = setQuorumVerifier(qv, true);                                    initConfigInZKDatabase();    if (prevQV.getVersion() < qv.getVersion() && !prevQV.equals(qv)) {        Map<Long, QuorumServer> newMembers = qv.getAllMembers();        updateRemotePeerMXBeans(newMembers);        if (restartLE) {            restartLeaderElection(prevQV, qv);        }        QuorumServer myNewQS = newMembers.get(getId());        if (myNewQS != null && myNewQS.clientAddr != null && !myNewQS.clientAddr.equals(oldClientAddr)) {            cnxnFactory.reconfigure(myNewQS.clientAddr);            updateThreadName();        }        boolean roleChange = updateLearnerType(qv);        boolean leaderChange = false;        if (suggestedLeaderId != null) {                        leaderChange = updateVote(suggestedLeaderId, zxid);        } else {            long currentLeaderId = getCurrentVote().getId();            QuorumServer myleaderInCurQV = prevQV.getVotingMembers().get(currentLeaderId);            QuorumServer myleaderInNewQV = qv.getVotingMembers().get(currentLeaderId);            leaderChange = (myleaderInCurQV == null || myleaderInCurQV.addr == null || myleaderInNewQV == null || !myleaderInCurQV.addr.equals(myleaderInNewQV.addr));                                    reconfigFlagClear();        }        return roleChange || leaderChange;    }    return false;}
updateRemotePeerMXBeans
private voidf2945_1Map<Long, QuorumServer> newMembers)
{    Set<Long> existingMembers = new HashSet<Long>(newMembers.keySet());    existingMembers.retainAll(jmxRemotePeerBean.keySet());    for (Long id : existingMembers) {        RemotePeerBean rBean = jmxRemotePeerBean.get(id);        rBean.setQuorumServer(newMembers.get(id));    }    Set<Long> joiningMembers = new HashSet<Long>(newMembers.keySet());    joiningMembers.removeAll(jmxRemotePeerBean.keySet());        joiningMembers.remove(getId());    for (Long id : joiningMembers) {        QuorumServer qs = newMembers.get(id);        RemotePeerBean rBean = new RemotePeerBean(this, qs);        try {            MBeanRegistry.getInstance().register(rBean, jmxQuorumBean);            jmxRemotePeerBean.put(qs.id, rBean);        } catch (Exception e) {                    }    }    Set<Long> leavingMembers = new HashSet<Long>(jmxRemotePeerBean.keySet());    leavingMembers.removeAll(newMembers.keySet());    for (Long id : leavingMembers) {        RemotePeerBean rBean = jmxRemotePeerBean.remove(id);        try {            MBeanRegistry.getInstance().unregister(rBean);        } catch (Exception e) {                    }    }}
updateObserverMasterList
private voidf2946_1)
{    if (observerMasterPort <= 0) {                return;    }    observerMasters.clear();    StringBuilder sb = new StringBuilder();    for (QuorumServer server : quorumVerifier.getVotingMembers().values()) {        InetSocketAddress addr = new InetSocketAddress(server.addr.getAddress(), observerMasterPort);        observerMasters.add(new QuorumServer(server.id, addr));        sb.append(addr).append(",");    }        Collections.shuffle(observerMasters);            nextObserverMaster = 0;}
useObserverMasters
private boolean zookeeper_f2947_0()
{    return getLearnerType() == LearnerType.OBSERVER && observerMasters.size() > 0;}
nextObserverMaster
private QuorumServer zookeeper_f2948_0()
{    if (nextObserverMaster >= observerMasters.size()) {        nextObserverMaster = 0;                if (isRunning()) {            Observer.waitForReconnectDelay();        }    }    return observerMasters.get(nextObserverMaster++);}
findLearnerMaster
 QuorumServer zookeeper_f2949_0(QuorumServer leader)
{    if (useObserverMasters()) {        return nextObserverMaster();    } else {                if (isRunning()) {            Observer.waitForReconnectDelay();        }        return leader;    }}
validateLearnerMaster
 QuorumServerf2950_1String desiredMaster)
{    if (useObserverMasters()) {        Long sid;        try {            sid = Long.parseLong(desiredMaster);        } catch (NumberFormatException e) {            sid = null;        }        for (QuorumServer server : observerMasters) {            if (sid == null) {                String serverAddr = server.addr.getAddress().getHostAddress() + ':' + server.addr.getPort();                if (serverAddr.startsWith(desiredMaster)) {                    return server;                }            } else {                if (sid.equals(server.id)) {                    return server;                }            }        }        if (sid == null) {                    } else {                    }    } else {            }    return null;}
updateLearnerType
private booleanf2951_1QuorumVerifier newQV)
{        if (newQV.getObservingMembers().containsKey(getId())) {        if (getLearnerType() != LearnerType.OBSERVER) {            setLearnerType(LearnerType.OBSERVER);                        reconfigFlagSet();            return true;        } else {            return false;        }    } else if (newQV.getVotingMembers().containsKey(getId())) {        if (getLearnerType() != LearnerType.PARTICIPANT) {            setLearnerType(LearnerType.PARTICIPANT);                        reconfigFlagSet();            return true;        } else {            return false;        }    }        if (getLearnerType() != LearnerType.PARTICIPANT) {        setLearnerType(LearnerType.PARTICIPANT);                reconfigFlagSet();        return true;    }    return false;}
updateVote
private booleanf2952_1long designatedLeader, long zxid)
{    Vote currentVote = getCurrentVote();    if (currentVote != null && designatedLeader != currentVote.getId()) {        setCurrentVote(new Vote(designatedLeader, zxid));        reconfigFlagSet();                return true;    }    return false;}
updateElectionVote
protected void zookeeper_f2953_0(long newEpoch)
{    Vote currentVote = getCurrentVote();    if (currentVote != null) {        setCurrentVote(new Vote(currentVote.getId(), currentVote.getZxid(), currentVote.getElectionEpoch(), newEpoch, currentVote.getState()));    }}
updateThreadName
private void zookeeper_f2954_0()
{    String plain = cnxnFactory != null ? cnxnFactory.getLocalAddress() != null ? formatInetAddr(cnxnFactory.getLocalAddress()) : "disabled" : "disabled";    String secure = secureCnxnFactory != null ? formatInetAddr(secureCnxnFactory.getLocalAddress()) : "disabled";    setName(String.format("QuorumPeer[myid=%d](plain=%s)(secure=%s)", getId(), plain, secure));}
setElectionTimeTaken
 void zookeeper_f2955_0(long electionTimeTaken)
{    this.electionTimeTaken = electionTimeTaken;}
getElectionTimeTaken
 long zookeeper_f2956_0()
{    return electionTimeTaken;}
setQuorumServerSaslRequired
 voidf2957_1boolean serverSaslRequired)
{    quorumServerSaslAuthRequired = serverSaslRequired;    }
setQuorumLearnerSaslRequired
 voidf2958_1boolean learnerSaslRequired)
{    quorumLearnerSaslAuthRequired = learnerSaslRequired;    }
setQuorumSaslEnabled
 voidf2959_1boolean enableAuth)
{    quorumSaslEnableAuth = enableAuth;    if (!quorumSaslEnableAuth) {            } else {            }}
setQuorumServicePrincipal
 voidf2960_1String servicePrincipal)
{    quorumServicePrincipal = servicePrincipal;    }
setQuorumLearnerLoginContext
 voidf2961_1String learnerContext)
{    quorumLearnerLoginContext = learnerContext;    }
setQuorumServerLoginContext
 voidf2962_1String serverContext)
{    quorumServerLoginContext = serverContext;    }
setQuorumCnxnThreadsSize
 voidf2963_1int qCnxnThreadsSize)
{    if (qCnxnThreadsSize > QUORUM_CNXN_THREADS_SIZE_DEFAULT_VALUE) {        quorumCnxnThreadsSize = qCnxnThreadsSize;    }    }
isQuorumSaslAuthEnabled
 boolean zookeeper_f2964_0()
{    return quorumSaslEnableAuth;}
isQuorumServerSaslAuthRequired
private boolean zookeeper_f2965_0()
{    return quorumServerSaslAuthRequired;}
isQuorumLearnerSaslAuthRequired
private boolean zookeeper_f2966_0()
{    return quorumLearnerSaslAuthRequired;}
createCnxnManager
public QuorumCnxManagerf2967_1)
{    int timeout = quorumCnxnTimeoutMs > 0 ? quorumCnxnTimeoutMs : this.tickTime * this.syncLimit;        return new QuorumCnxManager(this, this.getId(), this.getView(), this.authServer, this.authLearner, timeout, this.getQuorumListenOnAllIPs(), this.quorumCnxnThreadsSize, this.isQuorumSaslAuthEnabled());}
isLeader
 boolean zookeeper_f2968_0(long id)
{    Vote vote = getCurrentVote();    return vote != null && id == vote.getId();}
getSynced_observers_metric
public Integer zookeeper_f2969_0()
{    if (leader != null) {        return leader.getObservingLearners().size();    } else if (follower != null) {        return follower.getSyncedObserverSize();    } else {        return null;    }}
parse
public voidf2970_1String path) throws ConfigException
{        try {        File configFile = (new VerifyingFileFactory.Builder(LOG).warnForRelativePath().failForNonExistingPath().build()).create(path);        Properties cfg = new Properties();        FileInputStream in = new FileInputStream(configFile);        try {            cfg.load(in);            configFileStr = path;        } finally {            in.close();        }        /* Read entire config file as initial configuration */        initialConfig = new String(Files.readAllBytes(configFile.toPath()));        parseProperties(cfg);    } catch (IOException e) {        throw new ConfigException("Error processing " + path, e);    } catch (IllegalArgumentException e) {        throw new ConfigException("Error processing " + path, e);    }    if (dynamicConfigFileStr != null) {        try {            Properties dynamicCfg = new Properties();            FileInputStream inConfig = new FileInputStream(dynamicConfigFileStr);            try {                dynamicCfg.load(inConfig);                if (dynamicCfg.getProperty("version") != null) {                    throw new ConfigException("dynamic file shouldn't have version inside");                }                String version = getVersionFromFilename(dynamicConfigFileStr);                                if (version != null) {                    dynamicCfg.setProperty("version", version);                }            } finally {                inConfig.close();            }            setupQuorumPeerConfig(dynamicCfg, false);        } catch (IOException e) {            throw new ConfigException("Error processing " + dynamicConfigFileStr, e);        } catch (IllegalArgumentException e) {            throw new ConfigException("Error processing " + dynamicConfigFileStr, e);        }        File nextDynamicConfigFile = new File(configFileStr + nextDynamicConfigFileSuffix);        if (nextDynamicConfigFile.exists()) {            try {                Properties dynamicConfigNextCfg = new Properties();                FileInputStream inConfigNext = new FileInputStream(nextDynamicConfigFile);                try {                    dynamicConfigNextCfg.load(inConfigNext);                } finally {                    inConfigNext.close();                }                boolean isHierarchical = false;                for (Entry<Object, Object> entry : dynamicConfigNextCfg.entrySet()) {                    String key = entry.getKey().toString().trim();                    if (key.startsWith("group") || key.startsWith("weight")) {                        isHierarchical = true;                        break;                    }                }                lastSeenQuorumVerifier = createQuorumVerifier(dynamicConfigNextCfg, isHierarchical);            } catch (IOException e) {                            }        }    }}
getVersionFromFilename
public static String zookeeper_f2971_0(String filename)
{    int i = filename.lastIndexOf('.');    if (i < 0 || i >= filename.length()) {        return null;    }    String hexVersion = filename.substring(i + 1);    try {        long version = Long.parseLong(hexVersion, 16);        return Long.toHexString(version);    } catch (NumberFormatException e) {        return null;    }}
parseProperties
public voidf2972_1Properties zkProp) throws IOException, ConfigException
{    int clientPort = 0;    int secureClientPort = 0;    int observerMasterPort = 0;    String clientPortAddress = null;    String secureClientPortAddress = null;    VerifyingFileFactory vff = new VerifyingFileFactory.Builder(LOG).warnForRelativePath().build();    for (Entry<Object, Object> entry : zkProp.entrySet()) {        String key = entry.getKey().toString().trim();        String value = entry.getValue().toString().trim();        if (key.equals("dataDir")) {            dataDir = vff.create(value);        } else if (key.equals("dataLogDir")) {            dataLogDir = vff.create(value);        } else if (key.equals("clientPort")) {            clientPort = Integer.parseInt(value);        } else if (key.equals("localSessionsEnabled")) {            localSessionsEnabled = Boolean.parseBoolean(value);        } else if (key.equals("localSessionsUpgradingEnabled")) {            localSessionsUpgradingEnabled = Boolean.parseBoolean(value);        } else if (key.equals("clientPortAddress")) {            clientPortAddress = value.trim();        } else if (key.equals("secureClientPort")) {            secureClientPort = Integer.parseInt(value);        } else if (key.equals("secureClientPortAddress")) {            secureClientPortAddress = value.trim();        } else if (key.equals("observerMasterPort")) {            observerMasterPort = Integer.parseInt(value);        } else if (key.equals("clientPortListenBacklog")) {            clientPortListenBacklog = Integer.parseInt(value);        } else if (key.equals("tickTime")) {            tickTime = Integer.parseInt(value);        } else if (key.equals("maxClientCnxns")) {            maxClientCnxns = Integer.parseInt(value);        } else if (key.equals("minSessionTimeout")) {            minSessionTimeout = Integer.parseInt(value);        } else if (key.equals("maxSessionTimeout")) {            maxSessionTimeout = Integer.parseInt(value);        } else if (key.equals("initLimit")) {            initLimit = Integer.parseInt(value);        } else if (key.equals("syncLimit")) {            syncLimit = Integer.parseInt(value);        } else if (key.equals("connectToLearnerMasterLimit")) {            connectToLearnerMasterLimit = Integer.parseInt(value);        } else if (key.equals("electionAlg")) {            electionAlg = Integer.parseInt(value);            if (electionAlg != 1 && electionAlg != 2 && electionAlg != 3) {                throw new ConfigException("Invalid electionAlg value. Only 1, 2, 3 are supported.");            }        } else if (key.equals("quorumListenOnAllIPs")) {            quorumListenOnAllIPs = Boolean.parseBoolean(value);        } else if (key.equals("peerType")) {            if (value.toLowerCase().equals("observer")) {                peerType = LearnerType.OBSERVER;            } else if (value.toLowerCase().equals("participant")) {                peerType = LearnerType.PARTICIPANT;            } else {                throw new ConfigException("Unrecognised peertype: " + value);            }        } else if (key.equals("syncEnabled")) {            syncEnabled = Boolean.parseBoolean(value);        } else if (key.equals("dynamicConfigFile")) {            dynamicConfigFileStr = value;        } else if (key.equals("autopurge.snapRetainCount")) {            snapRetainCount = Integer.parseInt(value);        } else if (key.equals("autopurge.purgeInterval")) {            purgeInterval = Integer.parseInt(value);        } else if (key.equals("standaloneEnabled")) {            if (value.toLowerCase().equals("true")) {                setStandaloneEnabled(true);            } else if (value.toLowerCase().equals("false")) {                setStandaloneEnabled(false);            } else {                throw new ConfigException("Invalid option " + value + " for standalone mode. Choose 'true' or 'false.'");            }        } else if (key.equals("reconfigEnabled")) {            if (value.toLowerCase().equals("true")) {                setReconfigEnabled(true);            } else if (value.toLowerCase().equals("false")) {                setReconfigEnabled(false);            } else {                throw new ConfigException("Invalid option " + value + " for reconfigEnabled flag. Choose 'true' or 'false.'");            }        } else if (key.equals("sslQuorum")) {            sslQuorum = Boolean.parseBoolean(value);        } else if (key.equals("portUnification")) {            shouldUsePortUnification = Boolean.parseBoolean(value);        } else if (key.equals("sslQuorumReloadCertFiles")) {            sslQuorumReloadCertFiles = Boolean.parseBoolean(value);        } else if ((key.startsWith("server.") || key.startsWith("group") || key.startsWith("weight")) && zkProp.containsKey("dynamicConfigFile")) {            throw new ConfigException("parameter: " + key + " must be in a separate dynamic config file");        } else if (key.equals(QuorumAuth.QUORUM_SASL_AUTH_ENABLED)) {            quorumEnableSasl = Boolean.parseBoolean(value);        } else if (key.equals(QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED)) {            quorumServerRequireSasl = Boolean.parseBoolean(value);        } else if (key.equals(QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED)) {            quorumLearnerRequireSasl = Boolean.parseBoolean(value);        } else if (key.equals(QuorumAuth.QUORUM_LEARNER_SASL_LOGIN_CONTEXT)) {            quorumLearnerLoginContext = value;        } else if (key.equals(QuorumAuth.QUORUM_SERVER_SASL_LOGIN_CONTEXT)) {            quorumServerLoginContext = value;        } else if (key.equals(QuorumAuth.QUORUM_KERBEROS_SERVICE_PRINCIPAL)) {            quorumServicePrincipal = value;        } else if (key.equals("quorum.cnxn.threads.size")) {            quorumCnxnThreadsSize = Integer.parseInt(value);        } else if (key.equals(JvmPauseMonitor.INFO_THRESHOLD_KEY)) {            jvmPauseInfoThresholdMs = Long.parseLong(value);        } else if (key.equals(JvmPauseMonitor.WARN_THRESHOLD_KEY)) {            jvmPauseWarnThresholdMs = Long.parseLong(value);        } else if (key.equals(JvmPauseMonitor.SLEEP_TIME_MS_KEY)) {            jvmPauseSleepTimeMs = Long.parseLong(value);        } else if (key.equals(JvmPauseMonitor.JVM_PAUSE_MONITOR_FEATURE_SWITCH_KEY)) {            jvmPauseMonitorToRun = Boolean.parseBoolean(value);        } else if (key.equals("metricsProvider.className")) {            metricsProviderClassName = value;        } else if (key.startsWith("metricsProvider.")) {            String keyForMetricsProvider = key.substring(16);            metricsProviderConfiguration.put(keyForMetricsProvider, value);        } else {            System.setProperty("zookeeper." + key, value);        }    }    if (!quorumEnableSasl && quorumServerRequireSasl) {        throw new IllegalArgumentException(QuorumAuth.QUORUM_SASL_AUTH_ENABLED + " is disabled, so cannot enable " + QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED);    }    if (!quorumEnableSasl && quorumLearnerRequireSasl) {        throw new IllegalArgumentException(QuorumAuth.QUORUM_SASL_AUTH_ENABLED + " is disabled, so cannot enable " + QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED);    }        if (!quorumLearnerRequireSasl && quorumServerRequireSasl) {        throw new IllegalArgumentException(QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED + " is disabled, so cannot enable " + QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED);    }        if (snapRetainCount < MIN_SNAP_RETAIN_COUNT) {                snapRetainCount = MIN_SNAP_RETAIN_COUNT;    }    if (dataDir == null) {        throw new IllegalArgumentException("dataDir is not set");    }    if (dataLogDir == null) {        dataLogDir = dataDir;    }    if (clientPort == 0) {                if (clientPortAddress != null) {            throw new IllegalArgumentException("clientPortAddress is set but clientPort is not set");        }    } else if (clientPortAddress != null) {        this.clientPortAddress = new InetSocketAddress(InetAddress.getByName(clientPortAddress), clientPort);            } else {        this.clientPortAddress = new InetSocketAddress(clientPort);            }    if (secureClientPort == 0) {                if (secureClientPortAddress != null) {            throw new IllegalArgumentException("secureClientPortAddress is set but secureClientPort is not set");        }    } else if (secureClientPortAddress != null) {        this.secureClientPortAddress = new InetSocketAddress(InetAddress.getByName(secureClientPortAddress), secureClientPort);            } else {        this.secureClientPortAddress = new InetSocketAddress(secureClientPort);            }    if (this.secureClientPortAddress != null) {        configureSSLAuth();    }    if (observerMasterPort <= 0) {            } else {        this.observerMasterPort = observerMasterPort;            }    if (tickTime == 0) {        throw new IllegalArgumentException("tickTime is not set");    }    minSessionTimeout = minSessionTimeout == -1 ? tickTime * 2 : minSessionTimeout;    maxSessionTimeout = maxSessionTimeout == -1 ? tickTime * 20 : maxSessionTimeout;    if (minSessionTimeout > maxSessionTimeout) {        throw new IllegalArgumentException("minSessionTimeout must not be larger than maxSessionTimeout");    }        try {        Class.forName(metricsProviderClassName, false, Thread.currentThread().getContextClassLoader());    } catch (ClassNotFoundException error) {        throw new IllegalArgumentException("metrics provider class was not found", error);    }        if (dynamicConfigFileStr == null) {        setupQuorumPeerConfig(zkProp, true);        if (isDistributed() && isReconfigEnabled()) {                                    backupOldConfig();        }    }}
configureSSLAuth
public static void zookeeper_f2973_0() throws ConfigException
{    try (ClientX509Util clientX509Util = new ClientX509Util()) {        String sslAuthProp = "zookeeper.authProvider." + System.getProperty(clientX509Util.getSslAuthProviderProperty(), "x509");        if (System.getProperty(sslAuthProp) == null) {            if ("zookeeper.authProvider.x509".equals(sslAuthProp)) {                System.setProperty("zookeeper.authProvider.x509", "org.apache.zookeeper.server.auth.X509AuthenticationProvider");            } else {                throw new ConfigException("No auth provider configured for the SSL authentication scheme '" + System.getProperty(clientX509Util.getSslAuthProviderProperty()) + "'.");            }        }    }}
backupOldConfig
private void zookeeper_f2974_0() throws IOException
{    new AtomicFileWritingIdiom(new File(configFileStr + ".bak"), new OutputStreamStatement() {        @Override        public void write(OutputStream output) throws IOException {            InputStream input = null;            try {                input = new FileInputStream(new File(configFileStr));                byte[] buf = new byte[1024];                int bytesRead;                while ((bytesRead = input.read(buf)) > 0) {                    output.write(buf, 0, bytesRead);                }            } finally {                if (input != null) {                    input.close();                }            }        }    });}
write
public void zookeeper_f2975_0(OutputStream output) throws IOException
{    InputStream input = null;    try {        input = new FileInputStream(new File(configFileStr));        byte[] buf = new byte[1024];        int bytesRead;        while ((bytesRead = input.read(buf)) > 0) {            output.write(buf, 0, bytesRead);        }    } finally {        if (input != null) {            input.close();        }    }}
writeDynamicConfig
public static void zookeeper_f2976_0(final String dynamicConfigFilename, final QuorumVerifier qv, final boolean needKeepVersion) throws IOException
{    new AtomicFileWritingIdiom(new File(dynamicConfigFilename), new WriterStatement() {        @Override        public void write(Writer out) throws IOException {            Properties cfg = new Properties();            cfg.load(new StringReader(qv.toString()));            List<String> servers = new ArrayList<String>();            for (Entry<Object, Object> entry : cfg.entrySet()) {                String key = entry.getKey().toString().trim();                if (!needKeepVersion && key.startsWith("version")) {                    continue;                }                String value = entry.getValue().toString().trim();                servers.add(key.concat("=").concat(value));            }            Collections.sort(servers);            out.write(StringUtils.joinStrings(servers, "\n"));        }    });}
write
public void zookeeper_f2977_0(Writer out) throws IOException
{    Properties cfg = new Properties();    cfg.load(new StringReader(qv.toString()));    List<String> servers = new ArrayList<String>();    for (Entry<Object, Object> entry : cfg.entrySet()) {        String key = entry.getKey().toString().trim();        if (!needKeepVersion && key.startsWith("version")) {            continue;        }        String value = entry.getValue().toString().trim();        servers.add(key.concat("=").concat(value));    }    Collections.sort(servers);    out.write(StringUtils.joinStrings(servers, "\n"));}
editStaticConfig
public static void zookeeper_f2978_0(final String configFileStr, final String dynamicFileStr, final boolean eraseClientPortAddress) throws IOException
{        if (configFileStr == null) {        return;    }    File configFile = (new VerifyingFileFactory.Builder(LOG).warnForRelativePath().failForNonExistingPath().build()).create(configFileStr);    final File dynamicFile = (new VerifyingFileFactory.Builder(LOG).warnForRelativePath().failForNonExistingPath().build()).create(dynamicFileStr);    final Properties cfg = new Properties();    FileInputStream in = new FileInputStream(configFile);    try {        cfg.load(in);    } finally {        in.close();    }    new AtomicFileWritingIdiom(new File(configFileStr), new WriterStatement() {        @Override        public void write(Writer out) throws IOException {            for (Entry<Object, Object> entry : cfg.entrySet()) {                String key = entry.getKey().toString().trim();                if (key.startsWith("server.") || key.startsWith("group") || key.startsWith("weight") || key.startsWith("dynamicConfigFile") || key.startsWith("peerType") || (eraseClientPortAddress && (key.startsWith("clientPort") || key.startsWith("clientPortAddress")))) {                                        continue;                }                String value = entry.getValue().toString().trim();                out.write(key.concat("=").concat(value).concat("\n"));            }                        String dynamicConfigFilePath = PathUtils.normalizeFileSystemPath(dynamicFile.getCanonicalPath());            out.write("dynamicConfigFile=".concat(dynamicConfigFilePath).concat("\n"));        }    });}
write
public void zookeeper_f2979_0(Writer out) throws IOException
{    for (Entry<Object, Object> entry : cfg.entrySet()) {        String key = entry.getKey().toString().trim();        if (key.startsWith("server.") || key.startsWith("group") || key.startsWith("weight") || key.startsWith("dynamicConfigFile") || key.startsWith("peerType") || (eraseClientPortAddress && (key.startsWith("clientPort") || key.startsWith("clientPortAddress")))) {                        continue;        }        String value = entry.getValue().toString().trim();        out.write(key.concat("=").concat(value).concat("\n"));    }        String dynamicConfigFilePath = PathUtils.normalizeFileSystemPath(dynamicFile.getCanonicalPath());    out.write("dynamicConfigFile=".concat(dynamicConfigFilePath).concat("\n"));}
deleteFile
public static voidf2980_1String filename)
{    if (filename == null) {        return;    }    File f = new File(filename);    if (f.exists()) {        try {            f.delete();        } catch (Exception e) {                    }    }}
createQuorumVerifier
private static QuorumVerifier zookeeper_f2981_0(Properties dynamicConfigProp, boolean isHierarchical) throws ConfigException
{    if (isHierarchical) {        return new QuorumHierarchical(dynamicConfigProp);    } else {                return new QuorumMaj(dynamicConfigProp);    }}
setupQuorumPeerConfig
 void zookeeper_f2982_0(Properties prop, boolean configBackwardCompatibilityMode) throws IOException, ConfigException
{    quorumVerifier = parseDynamicConfig(prop, electionAlg, true, configBackwardCompatibilityMode);    setupMyId();    setupClientPort();    setupPeerType();    checkValidity();}
parseDynamicConfig
public static QuorumVerifierf2983_1Properties dynamicConfigProp, int eAlg, boolean warnings, boolean configBackwardCompatibilityMode) throws IOException, ConfigException
{    boolean isHierarchical = false;    for (Entry<Object, Object> entry : dynamicConfigProp.entrySet()) {        String key = entry.getKey().toString().trim();        if (key.startsWith("group") || key.startsWith("weight")) {            isHierarchical = true;        } else if (!configBackwardCompatibilityMode && !key.startsWith("server.") && !key.equals("version")) {                        throw new ConfigException("Unrecognised parameter: " + key);        }    }    QuorumVerifier qv = createQuorumVerifier(dynamicConfigProp, isHierarchical);    int numParticipators = qv.getVotingMembers().size();    int numObservers = qv.getObservingMembers().size();    if (numParticipators == 0) {        if (!standaloneEnabled) {            throw new IllegalArgumentException("standaloneEnabled = false then " + "number of participants should be >0");        }        if (numObservers > 0) {            throw new IllegalArgumentException("Observers w/o participants is an invalid configuration");        }    } else if (numParticipators == 1 && standaloneEnabled) {                                                if (numObservers > 0) {            throw new IllegalArgumentException("Observers w/o quorum is an invalid configuration");        }    } else {        if (warnings) {            if (numParticipators <= 2) {                            } else if (numParticipators % 2 == 0) {                            }        }        for (QuorumServer s : qv.getVotingMembers().values()) {            if (s.electionAddr == null) {                throw new IllegalArgumentException("Missing election port for server: " + s.id);            }        }    }    return qv;}
setupMyId
private void zookeeper_f2984_0() throws IOException
{    File myIdFile = new File(dataDir, "myid");        if (!myIdFile.isFile()) {        return;    }    BufferedReader br = new BufferedReader(new FileReader(myIdFile));    String myIdString;    try {        myIdString = br.readLine();    } finally {        br.close();    }    try {        serverId = Long.parseLong(myIdString);        MDC.put("myid", myIdString);    } catch (NumberFormatException e) {        throw new IllegalArgumentException("serverid " + myIdString + " is not a number");    }}
setupClientPort
private void zookeeper_f2985_0() throws ConfigException
{    if (serverId == UNSET_SERVERID) {        return;    }    QuorumServer qs = quorumVerifier.getAllMembers().get(serverId);    if (clientPortAddress != null && qs != null && qs.clientAddr != null) {        if ((!clientPortAddress.getAddress().isAnyLocalAddress() && !clientPortAddress.equals(qs.clientAddr)) || (clientPortAddress.getAddress().isAnyLocalAddress() && clientPortAddress.getPort() != qs.clientAddr.getPort())) {            throw new ConfigException("client address for this server (id = " + serverId + ") in static config file is " + clientPortAddress + " is different from client address found in dynamic file: " + qs.clientAddr);        }    }    if (qs != null && qs.clientAddr != null) {        clientPortAddress = qs.clientAddr;    }    if (qs != null && qs.clientAddr == null) {        qs.clientAddr = clientPortAddress;        qs.isClientAddrFromStatic = true;    }}
setupPeerType
private voidf2986_1)
{        LearnerType roleByServersList = quorumVerifier.getObservingMembers().containsKey(serverId) ? LearnerType.OBSERVER : LearnerType.PARTICIPANT;    if (roleByServersList != peerType) {                peerType = roleByServersList;    }}
checkValidity
public void zookeeper_f2987_0() throws IOException, ConfigException
{    if (isDistributed()) {        if (initLimit == 0) {            throw new IllegalArgumentException("initLimit is not set");        }        if (syncLimit == 0) {            throw new IllegalArgumentException("syncLimit is not set");        }        if (serverId == UNSET_SERVERID) {            throw new IllegalArgumentException("myid file is missing");        }    }}
getClientPortAddress
public InetSocketAddress zookeeper_f2988_0()
{    return clientPortAddress;}
getSecureClientPortAddress
public InetSocketAddress zookeeper_f2989_0()
{    return secureClientPortAddress;}
getObserverMasterPort
public int zookeeper_f2990_0()
{    return observerMasterPort;}
getDataDir
public File zookeeper_f2991_0()
{    return dataDir;}
getDataLogDir
public File zookeeper_f2992_0()
{    return dataLogDir;}
getInitialConfig
public String zookeeper_f2993_0()
{    return initialConfig;}
getTickTime
public int zookeeper_f2994_0()
{    return tickTime;}
getMaxClientCnxns
public int zookeeper_f2995_0()
{    return maxClientCnxns;}
getMinSessionTimeout
public int zookeeper_f2996_0()
{    return minSessionTimeout;}
getMaxSessionTimeout
public int zookeeper_f2997_0()
{    return maxSessionTimeout;}
getMetricsProviderClassName
public String zookeeper_f2998_0()
{    return metricsProviderClassName;}
getMetricsProviderConfiguration
public Properties zookeeper_f2999_0()
{    return metricsProviderConfiguration;}
areLocalSessionsEnabled
public boolean zookeeper_f3000_0()
{    return localSessionsEnabled;}
isLocalSessionsUpgradingEnabled
public boolean zookeeper_f3001_0()
{    return localSessionsUpgradingEnabled;}
isSslQuorum
public boolean zookeeper_f3002_0()
{    return sslQuorum;}
shouldUsePortUnification
public boolean zookeeper_f3003_0()
{    return shouldUsePortUnification;}
getClientPortListenBacklog
public int zookeeper_f3004_0()
{    return clientPortListenBacklog;}
getInitLimit
public int zookeeper_f3005_0()
{    return initLimit;}
getSyncLimit
public int zookeeper_f3006_0()
{    return syncLimit;}
getConnectToLearnerMasterLimit
public int zookeeper_f3007_0()
{    return connectToLearnerMasterLimit;}
getElectionAlg
public int zookeeper_f3008_0()
{    return electionAlg;}
getElectionPort
public int zookeeper_f3009_0()
{    return electionPort;}
getSnapRetainCount
public int zookeeper_f3010_0()
{    return snapRetainCount;}
getPurgeInterval
public int zookeeper_f3011_0()
{    return purgeInterval;}
getSyncEnabled
public boolean zookeeper_f3012_0()
{    return syncEnabled;}
getQuorumVerifier
public QuorumVerifier zookeeper_f3013_0()
{    return quorumVerifier;}
getLastSeenQuorumVerifier
public QuorumVerifier zookeeper_f3014_0()
{    return lastSeenQuorumVerifier;}
getServers
public Map<Long, QuorumServer> zookeeper_f3015_0()
{        return Collections.unmodifiableMap(quorumVerifier.getAllMembers());}
getJvmPauseInfoThresholdMs
public long zookeeper_f3016_0()
{    return jvmPauseInfoThresholdMs;}
getJvmPauseWarnThresholdMs
public long zookeeper_f3017_0()
{    return jvmPauseWarnThresholdMs;}
getJvmPauseSleepTimeMs
public long zookeeper_f3018_0()
{    return jvmPauseSleepTimeMs;}
isJvmPauseMonitorToRun
public boolean zookeeper_f3019_0()
{    return jvmPauseMonitorToRun;}
getServerId
public long zookeeper_f3020_0()
{    return serverId;}
isDistributed
public boolean zookeeper_f3021_0()
{    return quorumVerifier != null && (!standaloneEnabled || quorumVerifier.getVotingMembers().size() > 1);}
getPeerType
public LearnerType zookeeper_f3022_0()
{    return peerType;}
getConfigFilename
public String zookeeper_f3023_0()
{    return configFileStr;}
getQuorumListenOnAllIPs
public Boolean zookeeper_f3024_0()
{    return quorumListenOnAllIPs;}
isStandaloneEnabled
public static boolean zookeeper_f3025_0()
{    return standaloneEnabled;}
setStandaloneEnabled
public static void zookeeper_f3026_0(boolean enabled)
{    standaloneEnabled = enabled;}
isReconfigEnabled
public static boolean zookeeper_f3027_0()
{    return reconfigEnabled;}
setReconfigEnabled
public static void zookeeper_f3028_0(boolean enabled)
{    reconfigEnabled = enabled;}
main
public static voidf3029_1String[] args)
{    QuorumPeerMain main = new QuorumPeerMain();    try {        main.initializeAndRun(args);    } catch (IllegalArgumentException e) {                        System.err.println(USAGE);        System.exit(ExitCode.INVALID_INVOCATION.getValue());    } catch (ConfigException e) {                System.err.println("Invalid config, exiting abnormally");        System.exit(ExitCode.INVALID_INVOCATION.getValue());    } catch (DatadirException e) {                System.err.println("Unable to access datadir, exiting abnormally");        System.exit(ExitCode.UNABLE_TO_ACCESS_DATADIR.getValue());    } catch (AdminServerException e) {                System.err.println("Unable to start AdminServer, exiting abnormally");        System.exit(ExitCode.ERROR_STARTING_ADMIN_SERVER.getValue());    } catch (Exception e) {                System.exit(ExitCode.UNEXPECTED_ERROR.getValue());    }        System.exit(ExitCode.EXECUTION_FINISHED.getValue());}
initializeAndRun
protected voidf3030_1String[] args) throws ConfigException, IOException, AdminServerException
{    QuorumPeerConfig config = new QuorumPeerConfig();    if (args.length == 1) {        config.parse(args[0]);    }        DatadirCleanupManager purgeMgr = new DatadirCleanupManager(config.getDataDir(), config.getDataLogDir(), config.getSnapRetainCount(), config.getPurgeInterval());    purgeMgr.start();    if (args.length == 1 && config.isDistributed()) {        runFromConfig(config);    } else {                        ZooKeeperServerMain.main(args);    }}
runFromConfig
public voidf3031_1QuorumPeerConfig config) throws IOException, AdminServerException
{    try {        ManagedUtil.registerLog4jMBeans();    } catch (JMException e) {            }        MetricsProvider metricsProvider;    try {        metricsProvider = MetricsProviderBootstrap.startMetricsProvider(config.getMetricsProviderClassName(), config.getMetricsProviderConfiguration());    } catch (MetricsProviderLifeCycleException error) {        throw new IOException("Cannot boot MetricsProvider " + config.getMetricsProviderClassName(), error);    }    try {        ServerMetrics.metricsProviderInitialized(metricsProvider);        ServerCnxnFactory cnxnFactory = null;        ServerCnxnFactory secureCnxnFactory = null;        if (config.getClientPortAddress() != null) {            cnxnFactory = ServerCnxnFactory.createFactory();            cnxnFactory.configure(config.getClientPortAddress(), config.getMaxClientCnxns(), config.getClientPortListenBacklog(), false);        }        if (config.getSecureClientPortAddress() != null) {            secureCnxnFactory = ServerCnxnFactory.createFactory();            secureCnxnFactory.configure(config.getSecureClientPortAddress(), config.getMaxClientCnxns(), config.getClientPortListenBacklog(), true);        }        quorumPeer = getQuorumPeer();        quorumPeer.setTxnFactory(new FileTxnSnapLog(config.getDataLogDir(), config.getDataDir()));        quorumPeer.enableLocalSessions(config.areLocalSessionsEnabled());        quorumPeer.enableLocalSessionsUpgrading(config.isLocalSessionsUpgradingEnabled());                quorumPeer.setElectionType(config.getElectionAlg());        quorumPeer.setMyid(config.getServerId());        quorumPeer.setTickTime(config.getTickTime());        quorumPeer.setMinSessionTimeout(config.getMinSessionTimeout());        quorumPeer.setMaxSessionTimeout(config.getMaxSessionTimeout());        quorumPeer.setInitLimit(config.getInitLimit());        quorumPeer.setSyncLimit(config.getSyncLimit());        quorumPeer.setConnectToLearnerMasterLimit(config.getConnectToLearnerMasterLimit());        quorumPeer.setObserverMasterPort(config.getObserverMasterPort());        quorumPeer.setConfigFileName(config.getConfigFilename());        quorumPeer.setClientPortListenBacklog(config.getClientPortListenBacklog());        quorumPeer.setZKDatabase(new ZKDatabase(quorumPeer.getTxnFactory()));        quorumPeer.setQuorumVerifier(config.getQuorumVerifier(), false);        if (config.getLastSeenQuorumVerifier() != null) {            quorumPeer.setLastSeenQuorumVerifier(config.getLastSeenQuorumVerifier(), false);        }        quorumPeer.initConfigInZKDatabase();        quorumPeer.setCnxnFactory(cnxnFactory);        quorumPeer.setSecureCnxnFactory(secureCnxnFactory);        quorumPeer.setSslQuorum(config.isSslQuorum());        quorumPeer.setUsePortUnification(config.shouldUsePortUnification());        quorumPeer.setLearnerType(config.getPeerType());        quorumPeer.setSyncEnabled(config.getSyncEnabled());        quorumPeer.setQuorumListenOnAllIPs(config.getQuorumListenOnAllIPs());        if (config.sslQuorumReloadCertFiles) {            quorumPeer.getX509Util().enableCertFileReloading();        }                quorumPeer.setQuorumSaslEnabled(config.quorumEnableSasl);        if (quorumPeer.isQuorumSaslAuthEnabled()) {            quorumPeer.setQuorumServerSaslRequired(config.quorumServerRequireSasl);            quorumPeer.setQuorumLearnerSaslRequired(config.quorumLearnerRequireSasl);            quorumPeer.setQuorumServicePrincipal(config.quorumServicePrincipal);            quorumPeer.setQuorumServerLoginContext(config.quorumServerLoginContext);            quorumPeer.setQuorumLearnerLoginContext(config.quorumLearnerLoginContext);        }        quorumPeer.setQuorumCnxnThreadsSize(config.quorumCnxnThreadsSize);        quorumPeer.initialize();        if (config.jvmPauseMonitorToRun) {            quorumPeer.setJvmPauseMonitor(new JvmPauseMonitor(config));        }        quorumPeer.start();        quorumPeer.join();    } catch (InterruptedException e) {                    } finally {        if (metricsProvider != null) {            try {                metricsProvider.stop();            } catch (Throwable error) {                            }        }    }}
getQuorumPeer
protected QuorumPeer zookeeper_f3032_0() throws SaslException
{    return new QuorumPeer();}
getServerState
public String zookeeper_f3033_0()
{    return provider.getServerState();}
getQuorumPeers
public String[] zookeeper_f3034_0()
{    return provider.getQuorumPeers();}
toString
public String zookeeper_f3035_0()
{    StringBuilder sb = new StringBuilder(super.toString());    String state = getServerState();    if (state.equals(Provider.LEADING_STATE)) {        sb.append("Followers:");        for (String f : getQuorumPeers()) {            sb.append(" ").append(f);        }        sb.append("\n");    } else if (state.equals(Provider.FOLLOWING_STATE) || state.equals(Provider.OBSERVING_STATE)) {        sb.append("Leader: ");        String[] ldr = getQuorumPeers();        if (ldr.length > 0) {            sb.append(ldr[0]);        } else {            sb.append("not connected");        }        sb.append("\n");    }    return sb.toString();}
startSessionTracker
protected void zookeeper_f3036_0()
{    upgradeableSessionTracker = (UpgradeableSessionTracker) sessionTracker;    upgradeableSessionTracker.start();}
checkUpgradeSession
public Request zookeeper_f3037_0(Request request) throws IOException, KeeperException
{        if ((request.type != OpCode.create && request.type != OpCode.create2 && request.type != OpCode.multi) || !upgradeableSessionTracker.isLocalSession(request.sessionId)) {        return null;    }    if (OpCode.multi == request.type) {        MultiOperationRecord multiTransactionRecord = new MultiOperationRecord();        request.request.rewind();        ByteBufferInputStream.byteBuffer2Record(request.request, multiTransactionRecord);        request.request.rewind();        boolean containsEphemeralCreate = false;        for (Op op : multiTransactionRecord) {            if (op.getType() == OpCode.create || op.getType() == OpCode.create2) {                CreateRequest createRequest = (CreateRequest) op.toRequestRecord();                CreateMode createMode = CreateMode.fromFlag(createRequest.getFlags());                if (createMode.isEphemeral()) {                    containsEphemeralCreate = true;                    break;                }            }        }        if (!containsEphemeralCreate) {            return null;        }    } else {        CreateRequest createRequest = new CreateRequest();        request.request.rewind();        ByteBufferInputStream.byteBuffer2Record(request.request, createRequest);        request.request.rewind();        CreateMode createMode = CreateMode.fromFlag(createRequest.getFlags());        if (!createMode.isEphemeral()) {            return null;        }    }        if (!self.isLocalSessionsUpgradingEnabled()) {        throw new KeeperException.EphemeralOnLocalSessionException();    }    return makeUpgradeRequest(request.sessionId);}
makeUpgradeRequest
private Request zookeeper_f3038_0(long sessionId)
{        synchronized (upgradeableSessionTracker) {        if (upgradeableSessionTracker.isLocalSession(sessionId)) {            int timeout = upgradeableSessionTracker.upgradeSession(sessionId);            ByteBuffer to = ByteBuffer.allocate(4);            to.putInt(timeout);            return new Request(null, sessionId, 0, OpCode.createSession, to, null);        }    }    return null;}
upgrade
public voidf3039_1long sessionId)
{    Request request = makeUpgradeRequest(sessionId);    if (request != null) {                        submitRequest(request);    }}
setLocalSessionFlag
protected voidf3040_1Request si)
{        switch(si.type) {        case OpCode.createSession:            if (self.areLocalSessionsEnabled()) {                                si.setLocalSession(true);            }            break;        case OpCode.closeSession:            String reqType = "global";            if (upgradeableSessionTracker.isLocalSession(si.sessionId)) {                si.setLocalSession(true);                reqType = "local";            }                        break;        default:            break;    }}
dumpConf
public void zookeeper_f3041_0(PrintWriter pwriter)
{    super.dumpConf(pwriter);    pwriter.print("initLimit=");    pwriter.println(self.getInitLimit());    pwriter.print("syncLimit=");    pwriter.println(self.getSyncLimit());    pwriter.print("electionAlg=");    pwriter.println(self.getElectionType());    pwriter.print("electionPort=");    pwriter.println(self.getElectionAddress().getPort());    pwriter.print("quorumPort=");    pwriter.println(self.getQuorumAddress().getPort());    pwriter.print("peerType=");    pwriter.println(self.getLearnerType().ordinal());    pwriter.println("membership: ");    pwriter.print(new String(self.getQuorumVerifier().toString().getBytes()));}
setState
protected void zookeeper_f3042_0(State state)
{    this.state = state;}
registerMetrics
protected void zookeeper_f3043_0()
{    super.registerMetrics();    MetricsContext rootContext = ServerMetrics.getMetrics().getMetricsProvider().getRootContext();    rootContext.registerGauge("quorum_size", () -> {        return self.getQuorumSize();    });}
unregisterMetrics
protected void zookeeper_f3044_0()
{    super.unregisterMetrics();    MetricsContext rootContext = ServerMetrics.getMetrics().getMetricsProvider().getRootContext();    rootContext.unregisterGauge("quorum_size");}
dumpMonitorValues
public void zookeeper_f3045_0(BiConsumer<String, Object> response)
{    super.dumpMonitorValues(response);    response.accept("peer_state", self.getDetailedPeerState());}
getName
public String zookeeper_f3046_0()
{    return "ReadOnlyServer";}
run
public voidf3047_1)
{    try {        while (!finished) {            Request request = queuedRequests.take();                        long traceMask = ZooTrace.CLIENT_REQUEST_TRACE_MASK;            if (request.type == OpCode.ping) {                traceMask = ZooTrace.CLIENT_PING_TRACE_MASK;            }            if (LOG.isTraceEnabled()) {                ZooTrace.logRequest(LOG, traceMask, 'R', request, "");            }            if (Request.requestOfDeath == request) {                break;            }                        switch(request.type) {                case OpCode.sync:                case OpCode.create:                case OpCode.create2:                case OpCode.createTTL:                case OpCode.createContainer:                case OpCode.delete:                case OpCode.deleteContainer:                case OpCode.setData:                case OpCode.reconfig:                case OpCode.setACL:                case OpCode.multi:                case OpCode.check:                    ReplyHeader hdr = new ReplyHeader(request.cxid, zks.getZKDatabase().getDataTreeLastProcessedZxid(), Code.NOTREADONLY.intValue());                    try {                        request.cnxn.sendResponse(hdr, null, null);                    } catch (IOException e) {                                            }                    continue;            }                        if (nextProcessor != null) {                nextProcessor.processRequest(request);            }        }    } catch (RequestProcessorException e) {        if (e.getCause() instanceof XidRolloverException) {                    }        handleException(this.getName(), e);    } catch (Exception e) {        handleException(this.getName(), e);    }    }
processRequest
public void zookeeper_f3048_0(Request request)
{    if (!finished) {        queuedRequests.add(request);    }}
shutdown
public void zookeeper_f3049_0()
{    finished = true;    queuedRequests.clear();    queuedRequests.add(Request.requestOfDeath);    nextProcessor.shutdown();}
setupRequestProcessors
protected void zookeeper_f3050_0()
{    RequestProcessor finalProcessor = new FinalRequestProcessor(this);    RequestProcessor prepProcessor = new PrepRequestProcessor(this, finalProcessor);    ((PrepRequestProcessor) prepProcessor).start();    firstProcessor = new ReadOnlyRequestProcessor(this, prepProcessor);    ((ReadOnlyRequestProcessor) firstProcessor).start();}
startup
public synchronized voidf3051_1)
{        if (shutdown) {                return;    }    registerJMX(new ReadOnlyBean(this), self.jmxLocalPeerBean);    super.startup();    self.setZooKeeperServer(this);    self.adminServer.setZooKeeperServer(this);    }
registerJMX
protected voidf3052_1)
{        try {        jmxDataTreeBean = new DataTreeBean(getZKDatabase().getDataTree());        MBeanRegistry.getInstance().register(jmxDataTreeBean, jmxServerBean);    } catch (Exception e) {                jmxDataTreeBean = null;    }}
registerJMX
public voidf3053_1ZooKeeperServerBean serverBean, LocalPeerBean localPeerBean)
{        try {        jmxServerBean = serverBean;        MBeanRegistry.getInstance().register(serverBean, localPeerBean);    } catch (Exception e) {                jmxServerBean = null;    }}
unregisterJMX
protected voidf3054_1)
{        try {        if (jmxDataTreeBean != null) {            MBeanRegistry.getInstance().unregister(jmxDataTreeBean);        }    } catch (Exception e) {            }    jmxDataTreeBean = null;}
unregisterJMX
protected voidf3055_1ZooKeeperServer zks)
{        try {        if (jmxServerBean != null) {            MBeanRegistry.getInstance().unregister(jmxServerBean);        }    } catch (Exception e) {            }    jmxServerBean = null;}
getState
public String zookeeper_f3056_0()
{    return "read-only";}
getServerId
public long zookeeper_f3057_0()
{    return self.getId();}
shutdown
public synchronized voidf3058_1)
{    if (!canShutdown()) {                return;    }    shutdown = true;    unregisterJMX(this);        self.setZooKeeperServer(null);        self.closeAllConnections();    self.adminServer.setZooKeeperServer(null);        super.shutdown();}
dumpConf
public void zookeeper_f3059_0(PrintWriter pwriter)
{    super.dumpConf(pwriter);    pwriter.print("initLimit=");    pwriter.println(self.getInitLimit());    pwriter.print("syncLimit=");    pwriter.println(self.getSyncLimit());    pwriter.print("electionAlg=");    pwriter.println(self.getElectionType());    pwriter.print("electionPort=");    pwriter.println(self.getElectionAddress().getPort());    pwriter.print("quorumPort=");    pwriter.println(self.getQuorumAddress().getPort());    pwriter.print("peerType=");    pwriter.println(self.getLearnerType().ordinal());}
setState
protected void zookeeper_f3060_0(State state)
{    this.state = state;}
setQuorumServer
public void zookeeper_f3061_0(QuorumPeer.QuorumServer peer)
{    this.peer = peer;}
getName
public String zookeeper_f3062_0()
{    return "replica." + peer.id;}
isHidden
public boolean zookeeper_f3063_0()
{    return false;}
getQuorumAddress
public String zookeeper_f3064_0()
{    return peer.addr.getHostString() + ":" + peer.addr.getPort();}
getElectionAddress
public String zookeeper_f3065_0()
{    return peer.electionAddr.getHostString() + ":" + peer.electionAddr.getPort();}
getClientAddress
public String zookeeper_f3066_0()
{    if (null == peer.clientAddr) {        return "";    }    return peer.clientAddr.getHostString() + ":" + peer.clientAddr.getPort();}
getLearnerType
public String zookeeper_f3067_0()
{    return peer.type.toString();}
isLeader
public boolean zookeeper_f3068_0()
{    return localPeer.isLeader(peer.getId());}
processRequest
public voidf3069_1Request si)
{    if (si.type != OpCode.sync) {        QuorumPacket qp = new QuorumPacket(Leader.ACK, si.getHdr().getZxid(), null, null);        try {            si.logLatency(ServerMetrics.getMetrics().PROPOSAL_ACK_CREATION_LATENCY);            learner.writePacket(qp, false);        } catch (IOException e) {                        try {                if (!learner.sock.isClosed()) {                    learner.sock.close();                }            } catch (IOException e1) {                                            }        }    }}
flush
public voidf3070_1) throws IOException
{    try {        learner.writePacket(null, true);    } catch (IOException e) {                try {            if (!learner.sock.isClosed()) {                learner.sock.close();            }        } catch (IOException e1) {                                }    }}
shutdown
public void zookeeper_f3071_0()
{}
isHidden
public boolean zookeeper_f3072_0()
{    return false;}
getStartTime
public String zookeeper_f3073_0()
{    return startTime.toString();}
getCurrentEpoch
public long zookeeper_f3074_0()
{    return currentEpoch;}
getLastZxid
public long zookeeper_f3075_0()
{    return lastZxid;}
isMoreRecentThan
public boolean zookeeper_f3076_0(StateSummary ss)
{    return (currentEpoch > ss.currentEpoch) || (currentEpoch == ss.currentEpoch && lastZxid > ss.lastZxid);}
equals
public boolean zookeeper_f3077_0(Object obj)
{    if (!(obj instanceof StateSummary)) {        return false;    }    StateSummary ss = (StateSummary) obj;    return currentEpoch == ss.currentEpoch && lastZxid == ss.lastZxid;}
hashCode
public int zookeeper_f3078_0()
{    return (int) (currentEpoch ^ lastZxid);}
addQuorumVerifier
public void zookeeper_f3079_0(QuorumVerifier qv)
{    qvAcksetPairs.add(new QuorumVerifierAcksetPair(qv, new HashSet<Long>(qv.getVotingMembers().size())));}
addAck
public boolean zookeeper_f3080_0(Long sid)
{    boolean change = false;    for (QuorumVerifierAcksetPair qvAckset : qvAcksetPairs) {        if (qvAckset.getQuorumVerifier().getVotingMembers().containsKey(sid)) {            qvAckset.getAckset().add(sid);            change = true;        }    }    return change;}
hasSid
public boolean zookeeper_f3081_0(long sid)
{    for (QuorumVerifierAcksetPair qvAckset : qvAcksetPairs) {        if (!qvAckset.getQuorumVerifier().getVotingMembers().containsKey(sid)) {            return false;        }    }    return true;}
hasAllQuorums
public boolean zookeeper_f3082_0()
{    for (QuorumVerifierAcksetPair qvAckset : qvAcksetPairs) {        if (!qvAckset.getQuorumVerifier().containsQuorum(qvAckset.getAckset())) {            return false;        }    }    return true;}
ackSetsToString
public String zookeeper_f3083_0()
{    StringBuilder sb = new StringBuilder();    for (QuorumVerifierAcksetPair qvAckset : qvAcksetPairs) {        sb.append(qvAckset.getAckset().toString()).append(",");    }    return sb.substring(0, sb.length() - 1);}
getQuorumVerifier
public QuorumVerifier zookeeper_f3084_0()
{    return this.qv;}
getAckset
public HashSet<Long> zookeeper_f3085_0()
{    return this.ackset;}
getMessage
private static String zookeeper_f3086_0(int concurrentSyncNumber, int throttleThreshold, LearnerSyncThrottler.SyncType syncType)
{    return String.format("new %s sync would make %d concurrently in progress; maximum is %d", syncType.toString().toLowerCase(), concurrentSyncNumber, throttleThreshold);}
accept
public Socket zookeeper_f3087_0() throws IOException
{    if (isClosed()) {        throw new SocketException("Socket is closed");    }    if (!isBound()) {        throw new SocketException("Socket is not bound yet");    }    final PrependableSocket prependableSocket = new PrependableSocket(null);    implAccept(prependableSocket);    return new UnifiedSocket(x509Util, allowInsecureConnection, prependableSocket);}
isSecureSocket
public boolean zookeeper_f3088_0()
{    return mode == Mode.TLS;}
isPlaintextSocket
public boolean zookeeper_f3089_0()
{    return mode == Mode.PLAINTEXT;}
isModeKnown
public boolean zookeeper_f3090_0()
{    return mode != Mode.UNKNOWN;}
detectMode
private voidf3091_1) throws IOException
{    byte[] litmus = new byte[5];    int oldTimeout = -1;    int bytesRead = 0;    int newTimeout = x509Util.getSslHandshakeTimeoutMillis();    try {        oldTimeout = prependableSocket.getSoTimeout();        prependableSocket.setSoTimeout(newTimeout);        bytesRead = prependableSocket.getInputStream().read(litmus, 0, litmus.length);    } catch (SocketTimeoutException e) {                    } finally {                try {            if (oldTimeout != -1) {                prependableSocket.setSoTimeout(oldTimeout);            }        } catch (Exception e) {                    }    }    if (bytesRead < 0) {                bytesRead = 0;    }    if (bytesRead == litmus.length && SslHandler.isEncrypted(Unpooled.wrappedBuffer(litmus))) {        try {            sslSocket = x509Util.createSSLSocket(prependableSocket, litmus);        } catch (X509Exception e) {            throw new IOException("failed to create SSL context", e);        }        prependableSocket = null;        mode = Mode.TLS;            } else if (allowInsecureConnection) {        prependableSocket.prependToInputStream(litmus, 0, bytesRead);        mode = Mode.PLAINTEXT;            } else {        prependableSocket.close();        mode = Mode.PLAINTEXT;        throw new IOException("Blocked insecure connection attempt");    }}
getSocketAllowUnknownMode
private Socket zookeeper_f3092_0()
{    if (isSecureSocket()) {        return sslSocket;    } else {                return prependableSocket;    }}
getSocket
private Socket zookeeper_f3093_0() throws IOException
{    if (!isModeKnown()) {        detectMode();    }    if (mode == Mode.TLS) {        return sslSocket;    } else {        return prependableSocket;    }}
getSslSocket
public SSLSocket zookeeper_f3094_0() throws IOException
{    if (!isModeKnown()) {        detectMode();    }    if (!isSecureSocket()) {        throw new SocketException("Socket mode is not TLS");    }    return sslSocket;}
connect
public void zookeeper_f3095_0(SocketAddress endpoint) throws IOException
{    getSocketAllowUnknownMode().connect(endpoint);}
connect
public void zookeeper_f3096_0(SocketAddress endpoint, int timeout) throws IOException
{    getSocketAllowUnknownMode().connect(endpoint, timeout);}
bind
public void zookeeper_f3097_0(SocketAddress bindpoint) throws IOException
{    getSocketAllowUnknownMode().bind(bindpoint);}
getInetAddress
public InetAddress zookeeper_f3098_0()
{    return getSocketAllowUnknownMode().getInetAddress();}
getLocalAddress
public InetAddress zookeeper_f3099_0()
{    return getSocketAllowUnknownMode().getLocalAddress();}
getPort
public int zookeeper_f3100_0()
{    return getSocketAllowUnknownMode().getPort();}
getLocalPort
public int zookeeper_f3101_0()
{    return getSocketAllowUnknownMode().getLocalPort();}
getRemoteSocketAddress
public SocketAddress zookeeper_f3102_0()
{    return getSocketAllowUnknownMode().getRemoteSocketAddress();}
getLocalSocketAddress
public SocketAddress zookeeper_f3103_0()
{    return getSocketAllowUnknownMode().getLocalSocketAddress();}
getChannel
public SocketChannel zookeeper_f3104_0()
{    return getSocketAllowUnknownMode().getChannel();}
getInputStream
public InputStream zookeeper_f3105_0() throws IOException
{    return new UnifiedInputStream(this);}
getOutputStream
public OutputStream zookeeper_f3106_0() throws IOException
{    return new UnifiedOutputStream(this);}
setTcpNoDelay
public void zookeeper_f3107_0(boolean on) throws SocketException
{    getSocketAllowUnknownMode().setTcpNoDelay(on);}
getTcpNoDelay
public boolean zookeeper_f3108_0() throws SocketException
{    return getSocketAllowUnknownMode().getTcpNoDelay();}
setSoLinger
public void zookeeper_f3109_0(boolean on, int linger) throws SocketException
{    getSocketAllowUnknownMode().setSoLinger(on, linger);}
getSoLinger
public int zookeeper_f3110_0() throws SocketException
{    return getSocketAllowUnknownMode().getSoLinger();}
sendUrgentData
public void zookeeper_f3111_0(int data) throws IOException
{    getSocket().sendUrgentData(data);}
setOOBInline
public void zookeeper_f3112_0(boolean on) throws SocketException
{    getSocketAllowUnknownMode().setOOBInline(on);}
getOOBInline
public boolean zookeeper_f3113_0() throws SocketException
{    return getSocketAllowUnknownMode().getOOBInline();}
setSoTimeout
public synchronized void zookeeper_f3114_0(int timeout) throws SocketException
{    getSocketAllowUnknownMode().setSoTimeout(timeout);}
getSoTimeout
public synchronized int zookeeper_f3115_0() throws SocketException
{    return getSocketAllowUnknownMode().getSoTimeout();}
setSendBufferSize
public synchronized void zookeeper_f3116_0(int size) throws SocketException
{    getSocketAllowUnknownMode().setSendBufferSize(size);}
getSendBufferSize
public synchronized int zookeeper_f3117_0() throws SocketException
{    return getSocketAllowUnknownMode().getSendBufferSize();}
setReceiveBufferSize
public synchronized void zookeeper_f3118_0(int size) throws SocketException
{    getSocketAllowUnknownMode().setReceiveBufferSize(size);}
getReceiveBufferSize
public synchronized int zookeeper_f3119_0() throws SocketException
{    return getSocketAllowUnknownMode().getReceiveBufferSize();}
setKeepAlive
public void zookeeper_f3120_0(boolean on) throws SocketException
{    getSocketAllowUnknownMode().setKeepAlive(on);}
getKeepAlive
public boolean zookeeper_f3121_0() throws SocketException
{    return getSocketAllowUnknownMode().getKeepAlive();}
setTrafficClass
public void zookeeper_f3122_0(int tc) throws SocketException
{    getSocketAllowUnknownMode().setTrafficClass(tc);}
getTrafficClass
public int zookeeper_f3123_0() throws SocketException
{    return getSocketAllowUnknownMode().getTrafficClass();}
setReuseAddress
public void zookeeper_f3124_0(boolean on) throws SocketException
{    getSocketAllowUnknownMode().setReuseAddress(on);}
getReuseAddress
public boolean zookeeper_f3125_0() throws SocketException
{    return getSocketAllowUnknownMode().getReuseAddress();}
close
public synchronized void zookeeper_f3126_0() throws IOException
{    getSocketAllowUnknownMode().close();}
shutdownInput
public void zookeeper_f3127_0() throws IOException
{    getSocketAllowUnknownMode().shutdownInput();}
shutdownOutput
public void zookeeper_f3128_0() throws IOException
{    getSocketAllowUnknownMode().shutdownOutput();}
toString
public String zookeeper_f3129_0()
{    return "UnifiedSocket[mode=" + mode.toString() + "socket=" + getSocketAllowUnknownMode().toString() + "]";}
isConnected
public boolean zookeeper_f3130_0()
{    return getSocketAllowUnknownMode().isConnected();}
isBound
public boolean zookeeper_f3131_0()
{    return getSocketAllowUnknownMode().isBound();}
isClosed
public boolean zookeeper_f3132_0()
{    return getSocketAllowUnknownMode().isClosed();}
isInputShutdown
public boolean zookeeper_f3133_0()
{    return getSocketAllowUnknownMode().isInputShutdown();}
isOutputShutdown
public boolean zookeeper_f3134_0()
{    return getSocketAllowUnknownMode().isOutputShutdown();}
setPerformancePreferences
public void zookeeper_f3135_0(int connectionTime, int latency, int bandwidth)
{    getSocketAllowUnknownMode().setPerformancePreferences(connectionTime, latency, bandwidth);}
read
public int zookeeper_f3136_0() throws IOException
{    return getRealInputStream().read();}
read
public int zookeeper_f3137_0(byte[] b) throws IOException
{    return getRealInputStream().read(b);}
read
public int zookeeper_f3138_0(byte[] b, int off, int len) throws IOException
{    return getRealInputStream().read(b, off, len);}
getRealInputStream
private InputStream zookeeper_f3139_0() throws IOException
{    if (realInputStream == null) {                realInputStream = unifiedSocket.getSocket().getInputStream();    }    return realInputStream;}
skip
public long zookeeper_f3140_0(long n) throws IOException
{    return getRealInputStream().skip(n);}
available
public int zookeeper_f3141_0() throws IOException
{    return getRealInputStream().available();}
close
public void zookeeper_f3142_0() throws IOException
{    getRealInputStream().close();}
mark
public synchronized void zookeeper_f3143_0(int readlimit)
{    try {        getRealInputStream().mark(readlimit);    } catch (IOException e) {        throw new RuntimeException(e);    }}
reset
public synchronized void zookeeper_f3144_0() throws IOException
{    getRealInputStream().reset();}
markSupported
public boolean zookeeper_f3145_0()
{    try {        return getRealInputStream().markSupported();    } catch (IOException e) {        throw new RuntimeException(e);    }}
write
public void zookeeper_f3146_0(int b) throws IOException
{    getRealOutputStream().write(b);}
write
public void zookeeper_f3147_0(byte[] b) throws IOException
{    getRealOutputStream().write(b);}
write
public void zookeeper_f3148_0(byte[] b, int off, int len) throws IOException
{    getRealOutputStream().write(b, off, len);}
flush
public void zookeeper_f3149_0() throws IOException
{    getRealOutputStream().flush();}
close
public void zookeeper_f3150_0() throws IOException
{    getRealOutputStream().close();}
getRealOutputStream
private OutputStream zookeeper_f3151_0() throws IOException
{    if (realOutputStream == null) {                realOutputStream = unifiedSocket.getSocket().getOutputStream();    }    return realOutputStream;}
start
public void zookeeper_f3152_0()
{}
createLocalSessionTracker
public void zookeeper_f3153_0(SessionExpirer expirer, int tickTime, long id, ZooKeeperServerListener listener)
{    this.localSessionsWithTimeouts = new ConcurrentHashMap<Long, Integer>();    this.localSessionTracker = new LocalSessionTracker(expirer, this.localSessionsWithTimeouts, tickTime, id, listener);    this.upgradingSessions = new ConcurrentHashMap<Long, Integer>();}
isTrackingSession
public boolean zookeeper_f3154_0(long sessionId)
{    return isLocalSession(sessionId) || isGlobalSession(sessionId);}
isLocalSession
public boolean zookeeper_f3155_0(long sessionId)
{    return localSessionTracker != null && localSessionTracker.isTrackingSession(sessionId);}
isLocalSessionsEnabled
public boolean zookeeper_f3156_0()
{    return localSessionsEnabled;}
isUpgradingSession
public boolean zookeeper_f3157_0(long sessionId)
{    return upgradingSessions != null && upgradingSessions.containsKey(sessionId);}
finishedUpgrading
public void zookeeper_f3158_0(long sessionId)
{    if (upgradingSessions != null) {        upgradingSessions.remove(sessionId);    }}
upgradeSession
public intf3159_1long sessionId)
{    if (localSessionsWithTimeouts == null) {        return -1;    }            Integer timeout = localSessionsWithTimeouts.remove(sessionId);    if (timeout != null) {                                                trackSession(sessionId, timeout);                        upgradingSessions.put(sessionId, timeout);        localSessionTracker.removeSession(sessionId);        return timeout;    }    return -1;}
removeLocalSession
protected void zookeeper_f3160_0(long sessionId)
{    if (localSessionTracker == null) {        return;    }    localSessionTracker.removeSession(sessionId);}
checkGlobalSession
public void zookeeper_f3161_0(long sessionId, Object owner) throws KeeperException.SessionExpiredException, KeeperException.SessionMovedException
{    throw new UnsupportedOperationException();}
getLocalSessionCount
public long zookeeper_f3162_0()
{    if (localSessionsWithTimeouts == null) {        return 0;    }    return localSessionsWithTimeouts.size();}
getVersion
public int zookeeper_f3163_0()
{    return version;}
getId
public long zookeeper_f3164_0()
{    return id;}
getZxid
public long zookeeper_f3165_0()
{    return zxid;}
getElectionEpoch
public long zookeeper_f3166_0()
{    return electionEpoch;}
getPeerEpoch
public long zookeeper_f3167_0()
{    return peerEpoch;}
getState
public ServerState zookeeper_f3168_0()
{    return state;}
equals
public boolean zookeeper_f3169_0(Object o)
{    if (!(o instanceof Vote)) {        return false;    }    Vote other = (Vote) o;    if ((state == ServerState.LOOKING) || (other.state == ServerState.LOOKING)) {        return id == other.id && zxid == other.zxid && electionEpoch == other.electionEpoch && peerEpoch == other.peerEpoch;    } else {        /*             * There are two things going on in the logic below:             *             * 1. skip comparing the zxid and electionEpoch for votes for servers             *    out of election.             *             *    Need to skip those because they can be inconsistent due to             *    scenarios described in QuorumPeer.updateElectionVote.             *             *    And given that only one ensemble can be running at a single point             *    in time and that each epoch is used only once, using only id and             *    epoch to compare the votes is sufficient.             *             *    {@see https://issues.apache.org/jira/browse/ZOOKEEPER-1805}             *             * 2. skip comparing peerEpoch if if we're running with mixed ensemble             *    with (version > 0x0) and without the change (version = 0x0)             *    introduced in ZOOKEEPER-1732.             *             *    {@see https://issues.apache.org/jira/browse/ZOOKEEPER-1732}             *             *    The server running with and without ZOOKEEPER-1732 will return             *    different peerEpoch. During rolling upgrades, it's possible             *    that 2/5 servers are returning epoch 1, while the other 2/5             *    are returning epoch 2, the other server need to ignore the             *    peerEpoch to be able to join it.             */        if ((version > 0x0) ^ (other.version > 0x0)) {            return id == other.id;        } else {            return (id == other.id && peerEpoch == other.peerEpoch);        }    }}
hashCode
public int zookeeper_f3170_0()
{    return (int) (id & zxid);}
toString
public String zookeeper_f3171_0()
{    return "(" + id + ", " + Long.toHexString(zxid) + ", " + Long.toHexString(peerEpoch) + ")";}
flush
public voidf3172_1)
{    if (msg != null && count > 0) {        String log = "";        if (count > 1) {            log = "[" + count + " times] ";        }        log += "Message: " + msg;        if (value != null) {            log += " Last value:" + value;        }            }    msg = null;    value = null;    count = 0;}
rateLimitLog
public void zookeeper_f3173_0(String newMsg)
{    rateLimitLog(newMsg, null);}
rateLimitLog
public voidf3174_1String newMsg, String value)
{    long now = Time.currentElapsedTime();    if (newMsg.equals(msg)) {        ++count;        this.value = value;        if (now - timestamp >= LOG_INTERVAL) {            flush();            msg = newMsg;            timestamp = now;            this.value = value;        }    } else {        flush();        msg = newMsg;        this.value = value;        timestamp = now;            }}
convertAcls
public synchronized Long zookeeper_f3175_0(List<ACL> acls)
{    if (acls == null) {        return OPEN_UNSAFE_ACL_ID;    }        Long ret = aclKeyMap.get(acls);    if (ret == null) {        ret = incrementIndex();        longKeyMap.put(ret, acls);        aclKeyMap.put(acls, ret);    }    addUsage(ret);    return ret;}
convertLong
public synchronized List<ACL>f3176_1Long longVal)
{    if (longVal == null) {        return null;    }    if (longVal == OPEN_UNSAFE_ACL_ID) {        return ZooDefs.Ids.OPEN_ACL_UNSAFE;    }    List<ACL> acls = longKeyMap.get(longVal);    if (acls == null) {                throw new RuntimeException("Failed to fetch acls for " + longVal);    }    return acls;}
incrementIndex
private long zookeeper_f3177_0()
{    return ++aclIndex;}
deserialize
public synchronized void zookeeper_f3178_0(InputArchive ia) throws IOException
{    clear();    int i = ia.readInt("map");    while (i > 0) {        Long val = ia.readLong("long");        if (aclIndex < val) {            aclIndex = val;        }        List<ACL> aclList = new ArrayList<ACL>();        Index j = ia.startVector("acls");        if (j == null) {            throw new RuntimeException("Incorrent format of InputArchive when deserialize DataTree - missing acls");        }        while (!j.done()) {            ACL acl = new ACL();            acl.deserialize(ia, "acl");            aclList.add(acl);            j.incr();        }        longKeyMap.put(val, aclList);        aclKeyMap.put(aclList, val);        referenceCounter.put(val, new AtomicLongWithEquals(0));        i--;    }}
serialize
public synchronized void zookeeper_f3179_0(OutputArchive oa) throws IOException
{    oa.writeInt(longKeyMap.size(), "map");    Set<Map.Entry<Long, List<ACL>>> set = longKeyMap.entrySet();    for (Map.Entry<Long, List<ACL>> val : set) {        oa.writeLong(val.getKey(), "long");        List<ACL> aclList = val.getValue();        oa.startVector(aclList, "acls");        for (ACL acl : aclList) {            acl.serialize(oa, "acl");        }        oa.endVector(aclList, "acls");    }}
size
public int zookeeper_f3180_0()
{    return aclKeyMap.size();}
clear
private void zookeeper_f3181_0()
{    aclKeyMap.clear();    longKeyMap.clear();    referenceCounter.clear();}
addUsage
public synchronized voidf3182_1Long acl)
{    if (acl == OPEN_UNSAFE_ACL_ID) {        return;    }    if (!longKeyMap.containsKey(acl)) {                return;    }    AtomicLong count = referenceCounter.get(acl);    if (count == null) {        referenceCounter.put(acl, new AtomicLongWithEquals(1));    } else {        count.incrementAndGet();    }}
removeUsage
public synchronized voidf3183_1Long acl)
{    if (acl == OPEN_UNSAFE_ACL_ID) {        return;    }    if (!longKeyMap.containsKey(acl)) {                return;    }    long newCount = referenceCounter.get(acl).decrementAndGet();    if (newCount <= 0) {        referenceCounter.remove(acl);        aclKeyMap.remove(longKeyMap.get(acl));        longKeyMap.remove(acl);    }}
purgeUnused
public synchronized void zookeeper_f3184_0()
{    Iterator<Map.Entry<Long, AtomicLongWithEquals>> refCountIter = referenceCounter.entrySet().iterator();    while (refCountIter.hasNext()) {        Map.Entry<Long, AtomicLongWithEquals> entry = refCountIter.next();        if (entry.getValue().get() <= 0) {            Long acl = entry.getKey();            aclKeyMap.remove(longKeyMap.get(acl));            longKeyMap.remove(acl);            refCountIter.remove();        }    }}
equals
public boolean zookeeper_f3185_0(Object o)
{    if (this == o) {        return true;    }    if (o == null || getClass() != o.getClass()) {        return false;    }    return equals((AtomicLongWithEquals) o);}
equals
public boolean zookeeper_f3186_0(AtomicLongWithEquals that)
{    return get() == that.get();}
hashCode
public int zookeeper_f3187_0()
{    return 31 * Long.valueOf(get()).hashCode();}
isLocalSession
public boolean zookeeper_f3188_0()
{    return isLocalSession;}
setLocalSession
public void zookeeper_f3189_0(boolean isLocalSession)
{    this.isLocalSession = isLocalSession;}
setLargeRequestSize
public void zookeeper_f3190_0(int size)
{    largeRequestSize = size;}
getLargeRequestSize
public int zookeeper_f3191_0()
{    return largeRequestSize;}
getOwner
public Object zookeeper_f3192_0()
{    return owner;}
setOwner
public void zookeeper_f3193_0(Object owner)
{    this.owner = owner;}
getHdr
public TxnHeader zookeeper_f3194_0()
{    return hdr;}
setHdr
public void zookeeper_f3195_0(TxnHeader hdr)
{    this.hdr = hdr;}
getTxn
public Record zookeeper_f3196_0()
{    return txn;}
setTxn
public void zookeeper_f3197_0(Record txn)
{    this.txn = txn;}
getConnection
public ServerCnxn zookeeper_f3198_0()
{    return cnxn;}
getStaleLatencyCheck
public static boolean zookeeper_f3199_0()
{    return staleLatencyCheck;}
setStaleLatencyCheck
public static void zookeeper_f3200_0(boolean check)
{    staleLatencyCheck = check;}
getStaleConnectionCheck
public static boolean zookeeper_f3201_0()
{    return staleConnectionCheck;}
setStaleConnectionCheck
public static void zookeeper_f3202_0(boolean check)
{    staleConnectionCheck = check;}
isStale
public boolean zookeeper_f3203_0()
{    if (cnxn == null) {        return false;    }        if (type == OpCode.closeSession) {        return false;    }    if (staleConnectionCheck) {                if (cnxn.isStale() || cnxn.isInvalid()) {            return true;        }    }    if (staleLatencyCheck) {                        long currentTime = Time.currentElapsedTime();        return (currentTime - createTime) > cnxn.getSessionTimeout();    }    return false;}
mustDrop
public boolean zookeeper_f3204_0()
{    return ((cnxn != null) && cnxn.isInvalid());}
isValid
 static boolean zookeeper_f3205_0(int type)
{        switch(type) {        case OpCode.notification:            return false;        case OpCode.check:        case OpCode.closeSession:        case OpCode.create:        case OpCode.create2:        case OpCode.createTTL:        case OpCode.createContainer:        case OpCode.createSession:        case OpCode.delete:        case OpCode.deleteContainer:        case OpCode.exists:        case OpCode.getACL:        case OpCode.getChildren:        case OpCode.getAllChildrenNumber:        case OpCode.getChildren2:        case OpCode.getData:        case OpCode.getEphemerals:        case OpCode.multi:        case OpCode.multiRead:        case OpCode.ping:        case OpCode.reconfig:        case OpCode.setACL:        case OpCode.setData:        case OpCode.setWatches:        case OpCode.sync:        case OpCode.checkWatches:        case OpCode.removeWatches:            return true;        default:            return false;    }}
isQuorum
public boolean zookeeper_f3206_0()
{    switch(this.type) {        case OpCode.exists:        case OpCode.getACL:        case OpCode.getChildren:        case OpCode.getAllChildrenNumber:        case OpCode.getChildren2:        case OpCode.getData:        case OpCode.getEphemerals:        case OpCode.multiRead:            return false;        case OpCode.create:        case OpCode.create2:        case OpCode.createTTL:        case OpCode.createContainer:        case OpCode.error:        case OpCode.delete:        case OpCode.deleteContainer:        case OpCode.setACL:        case OpCode.setData:        case OpCode.check:        case OpCode.multi:        case OpCode.reconfig:            return true;        case OpCode.closeSession:        case OpCode.createSession:            return !this.isLocalSession;        default:            return false;    }}
op2String
public static String zookeeper_f3207_0(int op)
{    switch(op) {        case OpCode.notification:            return "notification";        case OpCode.create:            return "create";        case OpCode.delete:            return "delete";        case OpCode.exists:            return "exists";        case OpCode.getData:            return "getData";        case OpCode.setData:            return "setData";        case OpCode.getACL:            return "getACL";        case OpCode.setACL:            return "setACL";        case OpCode.getChildren:            return "getChildren";        case OpCode.sync:            return "sync";        case OpCode.ping:            return "ping";        case OpCode.getChildren2:            return "getChildren2";        case OpCode.check:            return "check";        case OpCode.multi:            return "multi";        case OpCode.create2:            return "create2";        case OpCode.reconfig:            return "reconfig";        case OpCode.checkWatches:            return "checkWatches";        case OpCode.removeWatches:            return "removeWatches";        case OpCode.createContainer:            return "createContainer";        case OpCode.deleteContainer:            return "deleteContainer";        case OpCode.createTTL:            return "createTtl";        case OpCode.multiRead:            return "multiRead";        case OpCode.auth:            return "auth";        case OpCode.setWatches:            return "setWatches";        case OpCode.sasl:            return "sasl";        case OpCode.getEphemerals:            return "getEphemerals";        case OpCode.getAllChildrenNumber:            return "getAllChildrenNumber";        case OpCode.createSession:            return "createSession";        case OpCode.closeSession:            return "closeSession";        case OpCode.error:            return "error";        default:            return "unknown " + op;    }}
toString
public String zookeeper_f3208_0()
{    StringBuilder sb = new StringBuilder();    sb.append("sessionid:0x").append(Long.toHexString(sessionId)).append(" type:").append(op2String(type)).append(" cxid:0x").append(Long.toHexString(cxid)).append(" zxid:0x").append(Long.toHexString(hdr == null ? -2 : hdr.getZxid())).append(" txntype:").append(hdr == null ? "unknown" : "" + hdr.getType());        String path = "n/a";    if (type != OpCode.createSession && type != OpCode.setWatches && type != OpCode.closeSession && request != null && request.remaining() >= 4) {        try {                        ByteBuffer rbuf = request.asReadOnlyBuffer();            rbuf.clear();            int pathLen = rbuf.getInt();                        if (pathLen >= 0 && pathLen < 4096 && rbuf.remaining() >= pathLen) {                byte[] b = new byte[pathLen];                rbuf.get(b);                path = new String(b);            }        } catch (Exception e) {                }    }    sb.append(" reqpath:").append(path);    return sb.toString();}
setException
public void zookeeper_f3209_0(KeeperException e)
{    this.e = e;}
getException
public KeeperException zookeeper_f3210_0()
{    return e;}
logLatency
public void zookeeper_f3211_0(Summary metric)
{    logLatency(metric, Time.currentWallTime());}
logLatency
public void zookeeper_f3212_0(Summary metric, long currentTime)
{    if (hdr != null) {        /* Request header is created by leader. If there is clock drift             * latency might be negative. Headers use wall time, not             * CLOCK_MONOTONIC.             */        long latency = currentTime - hdr.getTime();        if (latency >= 0) {            metric.add(latency);        }    }}
logLatency
public void zookeeper_f3213_0(SummarySet metric, String key, long currentTime)
{    if (hdr != null) {        /* Request header is created by leader. If there is clock drift             * latency might be negative. Headers use wall time, not             * CLOCK_MONOTONIC.             */        long latency = currentTime - hdr.getTime();        if (latency >= 0) {            metric.add(key, latency);        }    }}
logLatency
public void zookeeper_f3214_0(SummarySet metric, String key)
{    logLatency(metric, key, Time.currentWallTime());}
getMaxRequests
public static int zookeeper_f3215_0()
{    return maxRequests;}
setMaxRequests
public static void zookeeper_f3216_0(int requests)
{    maxRequests = requests;}
getStallTime
public static int zookeeper_f3217_0()
{    return stallTime;}
setStallTime
public static void zookeeper_f3218_0(int time)
{    stallTime = time;}
getDropStaleRequests
public static boolean zookeeper_f3219_0()
{    return dropStaleRequests;}
setDropStaleRequests
public static void zookeeper_f3220_0(boolean drop)
{    dropStaleRequests = drop;}
run
public voidf3221_1)
{    try {        while (true) {            if (killed) {                break;            }            Request request = submittedRequests.take();            if (Request.requestOfDeath == request) {                break;            }            if (request.mustDrop()) {                continue;            }                        if (maxRequests > 0) {                while (!killed) {                    if (dropStaleRequests && request.isStale()) {                                                dropRequest(request);                        ServerMetrics.getMetrics().STALE_REQUESTS_DROPPED.add(1);                        request = null;                        break;                    }                    if (zks.getInProcess() < maxRequests) {                        break;                    }                    throttleSleep(stallTime);                }            }            if (killed) {                break;            }                        if (request != null) {                if (request.isStale()) {                    ServerMetrics.getMetrics().STALE_REQUESTS.add(1);                }                zks.submitRequestNow(request);            }        }    } catch (InterruptedException e) {            }    int dropped = drainQueue();    }
throttleSleep
private synchronized void zookeeper_f3222_0(int stallTime)
{    try {        ServerMetrics.getMetrics().REQUEST_THROTTLE_WAIT_COUNT.add(1);        this.wait(stallTime);    } catch (InterruptedException ie) {        return;    }}
throttleWake
public synchronized void zookeeper_f3223_0()
{    this.notify();}
drainQueue
private intf3224_1)
{                    int dropped = 0;    Request request;        while ((request = submittedRequests.poll()) != null) {        dropped += 1;        dropRequest(request);    }    return dropped;}
dropRequest
private void zookeeper_f3225_0(Request request)
{                    ServerCnxn conn = request.getConnection();    if (conn != null) {                conn.setInvalid();    }            zks.requestFinished(request);}
submitRequest
public voidf3226_1Request request)
{    if (stopping) {                dropRequest(request);    } else {        submittedRequests.add(request);    }}
getInflight
public int zookeeper_f3227_0()
{    return submittedRequests.size();}
shutdown
public voidf3228_1)
{            stopping = true;    submittedRequests.add(Request.requestOfDeath);    try {        this.join(shutdownTimeout);    } catch (InterruptedException e) {            }            killed = true;    try {        this.join();    } catch (InterruptedException e) {                        System.exit(ExitCode.UNEXPECTED_ERROR.getValue());    }}
put
public void zookeeper_f3229_0(String path, byte[] data, Stat stat)
{    Entry entry = new Entry();    entry.data = data;    entry.stat = stat;    cache.put(path, entry);}
get
public byte[] zookeeper_f3230_0(String key, Stat stat)
{    Entry entry = cache.get(key);    if (entry == null) {        return null;    }    if (!stat.equals(entry.stat)) {                cache.remove(key);        return null;    } else {        return entry.data;    }}
getResponseCacheSize
private static int zookeeper_f3231_0()
{    return Integer.getInteger("zookeeper.maxResponseCacheSize", DEFAULT_RESPONSE_CACHE_SIZE);}
isEnabled
public static boolean zookeeper_f3232_0()
{    return getResponseCacheSize() > 0;}
removeEldestEntry
protected boolean zookeeper_f3233_0(Map.Entry<K, V> eldest)
{    return size() >= cacheSize;}
toDisconnectReasonString
public String zookeeper_f3234_0()
{    return disconnectReason;}
incrOutstandingAndCheckThrottle
public void zookeeper_f3235_0(RequestHeader h)
{    if (h.getXid() <= 0) {        return;    }    if (zkServer.shouldThrottle(outstandingCount.incrementAndGet())) {        disableRecv(false);    }}
decrOutstandingAndCheckThrottle
public void zookeeper_f3236_0(ReplyHeader h)
{    if (h.getXid() <= 0) {        return;    }    if (!zkServer.shouldThrottle(outstandingCount.decrementAndGet())) {        enableRecv();    }}
sendResponse
public void zookeeper_f3237_0(ReplyHeader h, Record r, String tag) throws IOException
{    sendResponse(h, r, tag, null, null);}
serializeRecord
protected byte[] zookeeper_f3238_0(Record record) throws IOException
{    ByteArrayOutputStream baos = new ByteArrayOutputStream(ZooKeeperServer.intBufferStartingSizeBytes);    BinaryOutputArchive bos = BinaryOutputArchive.getArchive(baos);    bos.writeRecord(record, null);    return baos.toByteArray();}
serialize
protected ByteBuffer[] zookeeper_f3239_0(ReplyHeader h, Record r, String tag, String cacheKey, Stat stat) throws IOException
{    byte[] header = serializeRecord(h);    byte[] data = null;    if (r != null) {        ResponseCache cache = zkServer.getReadResponseCache();        if (cache != null && stat != null && cacheKey != null && !cacheKey.endsWith(Quotas.statNode)) {                                                            data = cache.get(cacheKey, stat);            if (data == null) {                                data = serializeRecord(r);                cache.put(cacheKey, data, stat);                ServerMetrics.getMetrics().RESPONSE_PACKET_CACHE_MISSING.add(1);            } else {                ServerMetrics.getMetrics().RESPONSE_PACKET_CACHE_HITS.add(1);            }        } else {            data = serializeRecord(r);        }    }    int dataLength = data == null ? 0 : data.length;    int packetLength = header.length + dataLength;    ServerStats serverStats = serverStats();    if (serverStats != null) {        serverStats.updateClientResponseSize(packetLength);    }    ByteBuffer lengthBuffer = ByteBuffer.allocate(4).putInt(packetLength);    lengthBuffer.rewind();    int bufferLen = data != null ? 3 : 2;    ByteBuffer[] buffers = new ByteBuffer[bufferLen];    buffers[0] = lengthBuffer;    buffers[1] = ByteBuffer.wrap(header);    if (data != null) {        buffers[2] = ByteBuffer.wrap(data);    }    return buffers;}
getAuthInfo
public List<Id> zookeeper_f3240_0()
{    return Collections.unmodifiableList(new ArrayList<>(authInfo));}
addAuthInfo
public void zookeeper_f3241_0(Id id)
{    authInfo.add(id);}
removeAuthInfo
public boolean zookeeper_f3242_0(Id id)
{    return authInfo.remove(id);}
disableRecv
 void zookeeper_f3243_0()
{    disableRecv(true);}
getReason
public DisconnectReason zookeeper_f3244_0()
{    return reason;}
toString
public String zookeeper_f3245_0()
{    return "EndOfStreamException: " + getMessage();}
getReason
public DisconnectReason zookeeper_f3246_0()
{    return reason;}
isStale
public boolean zookeeper_f3247_0()
{    return stale;}
setStale
public void zookeeper_f3248_0()
{    stale = true;}
isInvalid
public boolean zookeeper_f3249_0()
{    return invalid;}
setInvalid
public void zookeeper_f3250_0()
{    if (!invalid) {        if (!stale) {            sendCloseSession();        }        invalid = true;    }}
packetReceived
protected void zookeeper_f3251_0(long bytes)
{    incrPacketsReceived();    ServerStats serverStats = serverStats();    if (serverStats != null) {        serverStats().incrementPacketsReceived();    }    ServerMetrics.getMetrics().BYTES_RECEIVED_COUNT.add(bytes);}
packetSent
protected void zookeeper_f3252_0()
{    incrPacketsSent();    ServerStats serverStats = serverStats();    if (serverStats != null) {        serverStats.incrementPacketsSent();    }}
resetStats
public synchronized void zookeeper_f3253_0()
{    disconnectReason = DisconnectReason.RESET_COMMAND;    packetsReceived.set(0);    packetsSent.set(0);    minLatency = Long.MAX_VALUE;    maxLatency = 0;    lastOp = "NA";    lastCxid = -1;    lastZxid = -1;    lastResponseTime = 0;    lastLatency = 0;    count = 0;    totalLatency = 0;}
incrPacketsReceived
protected long zookeeper_f3254_0()
{    return packetsReceived.incrementAndGet();}
incrPacketsSent
protected long zookeeper_f3255_0()
{    return packetsSent.incrementAndGet();}
updateStatsForResponse
protected synchronized void zookeeper_f3256_0(long cxid, long zxid, String op, long start, long end)
{        if (cxid >= 0) {        lastCxid = cxid;    }    lastZxid = zxid;    lastOp = op;    lastResponseTime = end;    long elapsed = end - start;    lastLatency = elapsed;    if (elapsed < minLatency) {        minLatency = elapsed;    }    if (elapsed > maxLatency) {        maxLatency = elapsed;    }    count++;    totalLatency += elapsed;}
getEstablished
public Date zookeeper_f3257_0()
{    return (Date) established.clone();}
getOutstandingRequests
public long zookeeper_f3258_0()
{    return outstandingCount.longValue();}
getPacketsReceived
public long zookeeper_f3259_0()
{    return packetsReceived.longValue();}
getPacketsSent
public long zookeeper_f3260_0()
{    return packetsSent.longValue();}
getMinLatency
public synchronized long zookeeper_f3261_0()
{    return minLatency == Long.MAX_VALUE ? 0 : minLatency;}
getAvgLatency
public synchronized long zookeeper_f3262_0()
{    return count == 0 ? 0 : totalLatency / count;}
getMaxLatency
public synchronized long zookeeper_f3263_0()
{    return maxLatency;}
getLastOperation
public synchronized String zookeeper_f3264_0()
{    return lastOp;}
getLastCxid
public synchronized long zookeeper_f3265_0()
{    return lastCxid;}
getLastZxid
public synchronized long zookeeper_f3266_0()
{    return lastZxid;}
getLastResponseTime
public synchronized long zookeeper_f3267_0()
{    return lastResponseTime;}
getLastLatency
public synchronized long zookeeper_f3268_0()
{    return lastLatency;}
toString
public String zookeeper_f3269_0()
{    StringWriter sw = new StringWriter();    PrintWriter pwriter = new PrintWriter(sw);    dumpConnectionInfo(pwriter, false);    pwriter.flush();    pwriter.close();    return sw.toString();}
dumpConnectionInfo
public synchronized void zookeeper_f3270_0(PrintWriter pwriter, boolean brief)
{    pwriter.print(" ");    pwriter.print(getRemoteSocketAddress());    pwriter.print("[");    int interestOps = getInterestOps();    pwriter.print(interestOps == 0 ? "0" : Integer.toHexString(interestOps));    pwriter.print("](queued=");    pwriter.print(getOutstandingRequests());    pwriter.print(",recved=");    pwriter.print(getPacketsReceived());    pwriter.print(",sent=");    pwriter.print(getPacketsSent());    if (!brief) {        long sessionId = getSessionId();        if (sessionId != 0) {            pwriter.print(",sid=0x");            pwriter.print(Long.toHexString(sessionId));            pwriter.print(",lop=");            pwriter.print(getLastOperation());            pwriter.print(",est=");            pwriter.print(getEstablished().getTime());            pwriter.print(",to=");            pwriter.print(getSessionTimeout());            long lastCxid = getLastCxid();            if (lastCxid >= 0) {                pwriter.print(",lcxid=0x");                pwriter.print(Long.toHexString(lastCxid));            }            pwriter.print(",lzxid=0x");            pwriter.print(Long.toHexString(getLastZxid()));            pwriter.print(",lresp=");            pwriter.print(getLastResponseTime());            pwriter.print(",llat=");            pwriter.print(getLastLatency());            pwriter.print(",minlat=");            pwriter.print(getMinLatency());            pwriter.print(",avglat=");            pwriter.print(getAvgLatency());            pwriter.print(",maxlat=");            pwriter.print(getMaxLatency());        }    }    pwriter.print(")");}
getConnectionInfo
public synchronized Map<String, Object> zookeeper_f3271_0(boolean brief)
{    Map<String, Object> info = new LinkedHashMap<String, Object>();    info.put("remote_socket_address", getRemoteSocketAddress());    info.put("interest_ops", getInterestOps());    info.put("outstanding_requests", getOutstandingRequests());    info.put("packets_received", getPacketsReceived());    info.put("packets_sent", getPacketsSent());    if (!brief) {        info.put("session_id", getSessionId());        info.put("last_operation", getLastOperation());        info.put("established", getEstablished());        info.put("session_timeout", getSessionTimeout());        info.put("last_cxid", getLastCxid());        info.put("last_zxid", getLastZxid());        info.put("last_response_time", getLastResponseTime());        info.put("last_latency", getLastLatency());        info.put("min_latency", getMinLatency());        info.put("avg_latency", getAvgLatency());        info.put("max_latency", getMaxLatency());    }    return info;}
cleanupWriterSocket
public voidf3272_1PrintWriter pwriter)
{    try {        if (pwriter != null) {            pwriter.flush();            pwriter.close();        }    } catch (Exception e) {            } finally {        try {            close(DisconnectReason.CLOSE_CONNECTION_COMMAND);        } catch (Exception e) {                    }    }}
addSession
public void zookeeper_f3273_0(long sessionId, ServerCnxn cnxn)
{    sessionMap.put(sessionId, cnxn);}
removeCnxnFromSessionMap
public void zookeeper_f3274_0(ServerCnxn cnxn)
{    long sessionId = cnxn.getSessionId();    if (sessionId != 0) {        sessionMap.remove(sessionId);    }}
closeSession
public booleanf3275_1long sessionId, ServerCnxn.DisconnectReason reason)
{    ServerCnxn cnxn = sessionMap.remove(sessionId);    if (cnxn != null) {        try {            cnxn.close(reason);        } catch (Exception e) {                    }        return true;    }    return false;}
getNumAliveConnections
public int zookeeper_f3276_0()
{    return cnxns.size();}
getZooKeeperServer
public final ZooKeeperServer zookeeper_f3277_0()
{    return zkServer;}
configure
public void zookeeper_f3278_0(InetSocketAddress addr, int maxcc) throws IOException
{    configure(addr, maxcc, -1);}
configure
public void zookeeper_f3279_0(InetSocketAddress addr, int maxcc, int backlog) throws IOException
{    configure(addr, maxcc, backlog, false);}
isSecure
public boolean zookeeper_f3280_0()
{    return secure;}
startup
public void zookeeper_f3281_0(ZooKeeperServer zkServer) throws IOException, InterruptedException
{    startup(zkServer, true);}
setZooKeeperServer
public final void zookeeper_f3282_0(ZooKeeperServer zks)
{    this.zkServer = zks;    if (zks != null) {        if (secure) {            zks.setSecureServerCnxnFactory(this);        } else {            zks.setServerCnxnFactory(this);        }    }}
createFactory
public static ServerCnxnFactoryf3283_1) throws IOException
{    String serverCnxnFactoryName = System.getProperty(ZOOKEEPER_SERVER_CNXN_FACTORY);    if (serverCnxnFactoryName == null) {        serverCnxnFactoryName = NIOServerCnxnFactory.class.getName();    }    try {        ServerCnxnFactory serverCnxnFactory = (ServerCnxnFactory) Class.forName(serverCnxnFactoryName).getDeclaredConstructor().newInstance();                return serverCnxnFactory;    } catch (Exception e) {        IOException ioe = new IOException("Couldn't instantiate " + serverCnxnFactoryName, e);        throw ioe;    }}
createFactory
public static ServerCnxnFactory zookeeper_f3284_0(int clientPort, int maxClientCnxns) throws IOException
{    return createFactory(new InetSocketAddress(clientPort), maxClientCnxns, -1);}
createFactory
public static ServerCnxnFactory zookeeper_f3285_0(int clientPort, int maxClientCnxns, int backlog) throws IOException
{    return createFactory(new InetSocketAddress(clientPort), maxClientCnxns, backlog);}
createFactory
public static ServerCnxnFactory zookeeper_f3286_0(InetSocketAddress addr, int maxClientCnxns) throws IOException
{    return createFactory(addr, maxClientCnxns, -1);}
createFactory
public static ServerCnxnFactory zookeeper_f3287_0(InetSocketAddress addr, int maxClientCnxns, int backlog) throws IOException
{    ServerCnxnFactory factory = createFactory();    factory.configure(addr, maxClientCnxns, backlog);    return factory;}
unregisterConnection
public void zookeeper_f3288_0(ServerCnxn serverCnxn)
{    ConnectionBean jmxConnectionBean = connectionBeans.remove(serverCnxn);    if (jmxConnectionBean != null) {        MBeanRegistry.getInstance().unregister(jmxConnectionBean);    }}
registerConnection
public voidf3289_1ServerCnxn serverCnxn)
{    if (zkServer != null) {        ConnectionBean jmxConnectionBean = new ConnectionBean(serverCnxn, zkServer);        try {            MBeanRegistry.getInstance().register(jmxConnectionBean, zkServer.jmxServerBean);            connectionBeans.put(serverCnxn, jmxConnectionBean);        } catch (JMException e) {                    }    }}
configureSaslLogin
protected voidf3290_1) throws IOException
{    String serverSection = System.getProperty(ZooKeeperSaslServer.LOGIN_CONTEXT_NAME_KEY, ZooKeeperSaslServer.DEFAULT_LOGIN_CONTEXT_NAME);        AppConfigurationEntry[] entries = null;    SecurityException securityException = null;    try {        entries = Configuration.getConfiguration().getAppConfigurationEntry(serverSection);    } catch (SecurityException e) {                securityException = e;    }        if (entries == null) {        String jaasFile = System.getProperty(Environment.JAAS_CONF_KEY);        String loginContextName = System.getProperty(ZooKeeperSaslServer.LOGIN_CONTEXT_NAME_KEY);        if (securityException != null && (loginContextName != null || jaasFile != null)) {            String errorMessage = "No JAAS configuration section named '" + serverSection + "' was found";            if (jaasFile != null) {                errorMessage += " in '" + jaasFile + "'.";            }            if (loginContextName != null) {                errorMessage += " But " + ZooKeeperSaslServer.LOGIN_CONTEXT_NAME_KEY + " was set.";            }                        throw new IOException(errorMessage);        }        return;    }        try {        saslServerCallbackHandler = new SaslServerCallbackHandler(Configuration.getConfiguration());        login = new Login(serverSection, saslServerCallbackHandler, new ZKConfig());        login.startThreadIfNeeded();    } catch (LoginException e) {        throw new IOException("Could not configure server because SASL configuration did not allow the " + " ZooKeeper server to authenticate itself properly: " + e);    }}
parse
public void zookeeper_f3291_0(String[] args)
{    if (args.length < 2 || args.length > 4) {        throw new IllegalArgumentException("Invalid number of arguments:" + Arrays.toString(args));    }    clientPortAddress = new InetSocketAddress(Integer.parseInt(args[0]));    dataDir = new File(args[1]);    dataLogDir = dataDir;    if (args.length >= 3) {        tickTime = Integer.parseInt(args[2]);    }    if (args.length == 4) {        maxClientCnxns = Integer.parseInt(args[3]);    }}
parse
public void zookeeper_f3292_0(String path) throws ConfigException
{    QuorumPeerConfig config = new QuorumPeerConfig();    config.parse(path);            readFrom(config);}
readFrom
public void zookeeper_f3293_0(QuorumPeerConfig config)
{    clientPortAddress = config.getClientPortAddress();    secureClientPortAddress = config.getSecureClientPortAddress();    dataDir = config.getDataDir();    dataLogDir = config.getDataLogDir();    tickTime = config.getTickTime();    maxClientCnxns = config.getMaxClientCnxns();    minSessionTimeout = config.getMinSessionTimeout();    maxSessionTimeout = config.getMaxSessionTimeout();    jvmPauseMonitorToRun = config.isJvmPauseMonitorToRun();    jvmPauseInfoThresholdMs = config.getJvmPauseInfoThresholdMs();    jvmPauseWarnThresholdMs = config.getJvmPauseWarnThresholdMs();    jvmPauseSleepTimeMs = config.getJvmPauseSleepTimeMs();    metricsProviderClassName = config.getMetricsProviderClassName();    metricsProviderConfiguration = config.getMetricsProviderConfiguration();    listenBacklog = config.getClientPortListenBacklog();    initialConfig = config.getInitialConfig();}
getClientPortAddress
public InetSocketAddress zookeeper_f3294_0()
{    return clientPortAddress;}
getSecureClientPortAddress
public InetSocketAddress zookeeper_f3295_0()
{    return secureClientPortAddress;}
getDataDir
public File zookeeper_f3296_0()
{    return dataDir;}
getDataLogDir
public File zookeeper_f3297_0()
{    return dataLogDir;}
getTickTime
public int zookeeper_f3298_0()
{    return tickTime;}
getMaxClientCnxns
public int zookeeper_f3299_0()
{    return maxClientCnxns;}
getMinSessionTimeout
public int zookeeper_f3300_0()
{    return minSessionTimeout;}
getMaxSessionTimeout
public int zookeeper_f3301_0()
{    return maxSessionTimeout;}
getJvmPauseInfoThresholdMs
public long zookeeper_f3302_0()
{    return jvmPauseInfoThresholdMs;}
getJvmPauseWarnThresholdMs
public long zookeeper_f3303_0()
{    return jvmPauseWarnThresholdMs;}
getJvmPauseSleepTimeMs
public long zookeeper_f3304_0()
{    return jvmPauseSleepTimeMs;}
isJvmPauseMonitorToRun
public boolean zookeeper_f3305_0()
{    return jvmPauseMonitorToRun;}
getMetricsProviderClassName
public String zookeeper_f3306_0()
{    return metricsProviderClassName;}
getMetricsProviderConfiguration
public Properties zookeeper_f3307_0()
{    return metricsProviderConfiguration;}
getClientPortListenBacklog
public int zookeeper_f3308_0()
{    return listenBacklog;}
getMetrics
public static ServerMetrics zookeeper_f3309_0()
{    return CURRENT;}
metricsProviderInitialized
public static voidf3310_1MetricsProvider metricsProvider)
{        CURRENT = new ServerMetrics(metricsProvider);}
resetAll
public void zookeeper_f3311_0()
{    metricsProvider.resetAllValues();}
getMetricsProvider
public MetricsProvider zookeeper_f3312_0()
{    return metricsProvider;}
getMinLatency
public long zookeeper_f3313_0()
{    return requestLatency.getMin();}
getAvgLatency
public double zookeeper_f3314_0()
{    return requestLatency.getAvg();}
getMaxLatency
public long zookeeper_f3315_0()
{    return requestLatency.getMax();}
getOutstandingRequests
public long zookeeper_f3316_0()
{    return provider.getOutstandingRequests();}
getLastProcessedZxid
public long zookeeper_f3317_0()
{    return provider.getLastProcessedZxid();}
getDataDirSize
public long zookeeper_f3318_0()
{    return provider.getDataDirSize();}
getLogDirSize
public long zookeeper_f3319_0()
{    return provider.getLogDirSize();}
getPacketsReceived
public long zookeeper_f3320_0()
{    return packetsReceived.get();}
getPacketsSent
public long zookeeper_f3321_0()
{    return packetsSent.get();}
getServerState
public String zookeeper_f3322_0()
{    return provider.getState();}
getNumAliveClientConnections
public int zookeeper_f3323_0()
{    return provider.getNumAliveConnections();}
getUptime
public long zookeeper_f3324_0()
{    return Time.currentElapsedTime() - startTime;}
isProviderNull
public boolean zookeeper_f3325_0()
{    return provider == null;}
toString
public String zookeeper_f3326_0()
{    StringBuilder sb = new StringBuilder();    sb.append("Latency min/avg/max: " + getMinLatency() + "/" + getAvgLatency() + "/" + getMaxLatency() + "\n");    sb.append("Received: " + getPacketsReceived() + "\n");    sb.append("Sent: " + getPacketsSent() + "\n");    sb.append("Connections: " + getNumAliveClientConnections() + "\n");    if (provider != null) {        sb.append("Outstanding: " + getOutstandingRequests() + "\n");        sb.append("Zxid: 0x" + Long.toHexString(getLastProcessedZxid()) + "\n");    }    sb.append("Mode: " + getServerState() + "\n");    return sb.toString();}
updateLatency
public void zookeeper_f3327_0(Request request, long currentTime)
{    long latency = currentTime - request.createTime;    if (latency < 0) {        return;    }    requestLatency.addDataPoint(latency);    if (request.getHdr() != null) {                ServerMetrics.getMetrics().UPDATE_LATENCY.add(latency);    } else {                ServerMetrics.getMetrics().READ_LATENCY.add(latency);    }}
resetLatency
public void zookeeper_f3328_0()
{    requestLatency.reset();}
resetMaxLatency
public void zookeeper_f3329_0()
{    requestLatency.resetMax();}
incrementPacketsReceived
public void zookeeper_f3330_0()
{    packetsReceived.incrementAndGet();}
incrementPacketsSent
public void zookeeper_f3331_0()
{    packetsSent.incrementAndGet();}
resetRequestCounters
public void zookeeper_f3332_0()
{    packetsReceived.set(0);    packetsSent.set(0);}
getFsyncThresholdExceedCount
public long zookeeper_f3333_0()
{    return fsyncThresholdExceedCount.get();}
incrementFsyncThresholdExceedCount
public void zookeeper_f3334_0()
{    fsyncThresholdExceedCount.incrementAndGet();}
resetFsyncThresholdExceedCount
public void zookeeper_f3335_0()
{    fsyncThresholdExceedCount.set(0);}
reset
public void zookeeper_f3336_0()
{    resetLatency();    resetRequestCounters();    clientResponseStats.reset();    ServerMetrics.getMetrics().resetAll();}
updateClientResponseSize
public void zookeeper_f3337_0(int size)
{    clientResponseStats.setLastBufferSize(size);}
getClientResponseStats
public BufferStats zookeeper_f3338_0()
{    return clientResponseStats;}
getSessionId
public long zookeeper_f3339_0()
{    return sessionId;}
getTimeout
public int zookeeper_f3340_0()
{    return timeout;}
isClosing
public boolean zookeeper_f3341_0()
{    return isClosing;}
toString
public String zookeeper_f3342_0()
{    return "0x" + Long.toHexString(sessionId);}
initializeNextSessionId
public static long zookeeper_f3343_0(long id)
{    long nextSid;    nextSid = (Time.currentElapsedTime() << 24) >>> 8;    nextSid = nextSid | (id << 56);    if (nextSid == EphemeralType.CONTAINER_EPHEMERAL_OWNER) {                ++nextSid;    }    return nextSid;}
dumpSessions
public void zookeeper_f3344_0(PrintWriter pwriter)
{    pwriter.print("Session ");    sessionExpiryQueue.dump(pwriter);}
getSessionExpiryMap
public synchronized Map<Long, Set<Long>> zookeeper_f3345_0()
{        Map<Long, Set<SessionImpl>> expiryMap = sessionExpiryQueue.getExpiryMap();    Map<Long, Set<Long>> sessionExpiryMap = new TreeMap<Long, Set<Long>>();    for (Entry<Long, Set<SessionImpl>> e : expiryMap.entrySet()) {        Set<Long> ids = new HashSet<Long>();        sessionExpiryMap.put(e.getKey(), ids);        for (SessionImpl s : e.getValue()) {            ids.add(s.sessionId);        }    }    return sessionExpiryMap;}
toString
public String zookeeper_f3346_0()
{    StringWriter sw = new StringWriter();    PrintWriter pwriter = new PrintWriter(sw);    dumpSessions(pwriter);    pwriter.flush();    pwriter.close();    return sw.toString();}
run
public voidf3347_1)
{    try {        while (running) {            long waitTime = sessionExpiryQueue.getWaitTime();            if (waitTime > 0) {                Thread.sleep(waitTime);                continue;            }            for (SessionImpl s : sessionExpiryQueue.poll()) {                ServerMetrics.getMetrics().STALE_SESSIONS_EXPIRED.add(1);                setSessionClosing(s.sessionId);                expirer.expire(s);            }        }    } catch (InterruptedException e) {        handleException(this.getName(), e);    }    }
touchSession
public synchronized boolean zookeeper_f3348_0(long sessionId, int timeout)
{    SessionImpl s = sessionsById.get(sessionId);    if (s == null) {        logTraceTouchInvalidSession(sessionId, timeout);        return false;    }    if (s.isClosing()) {        logTraceTouchClosingSession(sessionId, timeout);        return false;    }    updateSessionExpiry(s, timeout);    return true;}
updateSessionExpiry
private void zookeeper_f3349_0(SessionImpl s, int timeout)
{    logTraceTouchSession(s.sessionId, timeout, "");    sessionExpiryQueue.update(s, timeout);}
logTraceTouchSession
private void zookeeper_f3350_0(long sessionId, int timeout, String sessionStatus)
{    if (!LOG.isTraceEnabled()) {        return;    }    String msg = MessageFormat.format("SessionTrackerImpl --- Touch {0}session: 0x{1} with timeout {2}", sessionStatus, Long.toHexString(sessionId), Integer.toString(timeout));    ZooTrace.logTraceMessage(LOG, ZooTrace.CLIENT_PING_TRACE_MASK, msg);}
logTraceTouchInvalidSession
private void zookeeper_f3351_0(long sessionId, int timeout)
{    logTraceTouchSession(sessionId, timeout, "invalid ");}
logTraceTouchClosingSession
private void zookeeper_f3352_0(long sessionId, int timeout)
{    logTraceTouchSession(sessionId, timeout, "closing ");}
getSessionTimeout
public int zookeeper_f3353_0(long sessionId)
{    return sessionsWithTimeout.get(sessionId);}
setSessionClosing
public synchronized void zookeeper_f3354_0(long sessionId)
{    if (LOG.isTraceEnabled()) {        LOG.trace("Session closing: 0x" + Long.toHexString(sessionId));    }    SessionImpl s = sessionsById.get(sessionId);    if (s == null) {        return;    }    s.isClosing = true;}
removeSession
public synchronized voidf3355_1long sessionId)
{    if (LOG.isDebugEnabled()) {            }    SessionImpl s = sessionsById.remove(sessionId);    sessionsWithTimeout.remove(sessionId);    if (LOG.isTraceEnabled()) {        ZooTrace.logTraceMessage(LOG, ZooTrace.SESSION_TRACE_MASK, "SessionTrackerImpl --- Removing session 0x" + Long.toHexString(sessionId));    }    if (s != null) {        sessionExpiryQueue.remove(s);    }}
shutdown
public voidf3356_1)
{        running = false;    if (LOG.isTraceEnabled()) {        ZooTrace.logTraceMessage(LOG, ZooTrace.getTextTraceLevel(), "Shutdown SessionTrackerImpl!");    }}
createSession
public long zookeeper_f3357_0(int sessionTimeout)
{    long sessionId = nextSessionId.getAndIncrement();    trackSession(sessionId, sessionTimeout);    return sessionId;}
trackSession
public synchronized booleanf3358_1long id, int sessionTimeout)
{    boolean added = false;    SessionImpl session = sessionsById.get(id);    if (session == null) {        session = new SessionImpl(id, sessionTimeout);    }            SessionImpl existedSession = sessionsById.putIfAbsent(id, session);    if (existedSession != null) {        session = existedSession;    } else {        added = true;        if (LOG.isDebugEnabled()) {                    }    }    if (LOG.isTraceEnabled()) {        String actionStr = added ? "Adding" : "Existing";        ZooTrace.logTraceMessage(LOG, ZooTrace.SESSION_TRACE_MASK, "SessionTrackerImpl --- " + actionStr + " session 0x" + Long.toHexString(id) + " " + sessionTimeout);    }    updateSessionExpiry(session, sessionTimeout);    return added;}
commitSession
public synchronized boolean zookeeper_f3359_0(long id, int sessionTimeout)
{    return sessionsWithTimeout.put(id, sessionTimeout) == null;}
isTrackingSession
public boolean zookeeper_f3360_0(long sessionId)
{    return sessionsById.containsKey(sessionId);}
checkSession
public synchronized voidf3361_1long sessionId, Object owner) throws KeeperException.SessionExpiredException, KeeperException.SessionMovedException, KeeperException.UnknownSessionException
{    if (LOG.isDebugEnabled()) {            }    SessionImpl session = sessionsById.get(sessionId);    if (session == null) {        throw new KeeperException.UnknownSessionException();    }    if (session.isClosing()) {        throw new KeeperException.SessionExpiredException();    }    if (session.owner == null) {        session.owner = owner;    } else if (session.owner != owner) {        throw new KeeperException.SessionMovedException();    }}
setOwner
public synchronized void zookeeper_f3362_0(long id, Object owner) throws SessionExpiredException
{    SessionImpl session = sessionsById.get(id);    if (session == null || session.isClosing()) {        throw new KeeperException.SessionExpiredException();    }    session.owner = owner;}
checkGlobalSession
public void zookeeper_f3363_0(long sessionId, Object owner) throws KeeperException.SessionExpiredException, KeeperException.SessionMovedException
{    try {        checkSession(sessionId, owner);    } catch (KeeperException.UnknownSessionException e) {        throw new KeeperException.SessionExpiredException();    }}
getLocalSessionCount
public long zookeeper_f3364_0()
{    return 0;}
isLocalSessionsEnabled
public boolean zookeeper_f3365_0()
{    return false;}
main
public static void zookeeper_f3366_0(String[] args) throws Exception
{    String snapshotFile = null;    boolean dumpData = false;    boolean dumpJson = false;    int i;    for (i = 0; i < args.length; i++) {        if (args[i].equals("-d")) {            dumpData = true;        } else if (args[i].equals("-json")) {            dumpJson = true;        } else {            snapshotFile = args[i];            i++;            break;        }    }    if (args.length != i || snapshotFile == null) {        System.err.println("USAGE: SnapshotFormatter [-d|-json] snapshot_file");        System.err.println("       -d dump the data for each znode");        System.err.println("       -json dump znode info in json format");        System.exit(ExitCode.INVALID_INVOCATION.getValue());    }    String error = ZKUtil.validateFileInput(snapshotFile);    if (null != error) {        System.err.println(error);        System.exit(ExitCode.INVALID_INVOCATION.getValue());    }    if (dumpData && dumpJson) {        System.err.println("Cannot specify both data dump (-d) and json mode (-json) in same call");        System.exit(ExitCode.INVALID_INVOCATION.getValue());    }    new SnapshotFormatter().run(snapshotFile, dumpData, dumpJson);}
run
public void zookeeper_f3367_0(String snapshotFileName, boolean dumpData, boolean dumpJson) throws IOException
{    File snapshotFile = new File(snapshotFileName);    try (InputStream is = SnapStream.getInputStream(snapshotFile)) {        InputArchive ia = BinaryInputArchive.getArchive(is);        FileSnap fileSnap = new FileSnap(null);        DataTree dataTree = new DataTree();        Map<Long, Integer> sessions = new HashMap<Long, Integer>();        fileSnap.deserialize(dataTree, sessions, ia);        long fileNameZxid = Util.getZxidFromName(snapshotFile.getName(), SNAPSHOT_FILE_PREFIX);        if (dumpJson) {            printSnapshotJson(dataTree);        } else {            printDetails(dataTree, sessions, dumpData, fileNameZxid);        }    }}
printDetails
private void zookeeper_f3368_0(DataTree dataTree, Map<Long, Integer> sessions, boolean dumpData, long fileNameZxid)
{    long dtZxid = printZnodeDetails(dataTree, dumpData);    printSessionDetails(dataTree, sessions);    System.out.println(String.format("----%nLast zxid: 0x%s", Long.toHexString(Math.max(fileNameZxid, dtZxid))));}
printZnodeDetails
private long zookeeper_f3369_0(DataTree dataTree, boolean dumpData)
{    System.out.println(String.format("ZNode Details (count=%d):", dataTree.getNodeCount()));    final long zxid = printZnode(dataTree, "/", dumpData);    System.out.println("----");    return zxid;}
printZnode
private long zookeeper_f3370_0(DataTree dataTree, String name, boolean dumpData)
{    System.out.println("----");    DataNode n = dataTree.getNode(name);    Set<String> children;    long zxid;    synchronized (n) {                System.out.println(name);        printStat(n.stat);        zxid = Math.max(n.stat.getMzxid(), n.stat.getPzxid());        if (dumpData) {            System.out.println("  data = " + (n.data == null ? "" : Base64.getEncoder().encodeToString(n.data)));        } else {            System.out.println("  dataLength = " + (n.data == null ? 0 : n.data.length));        }        children = n.getChildren();    }    if (children != null) {        for (String child : children) {            long cxid = printZnode(dataTree, name + (name.equals("/") ? "" : "/") + child, dumpData);            zxid = Math.max(zxid, cxid);        }    }    return zxid;}
printSessionDetails
private void zookeeper_f3371_0(DataTree dataTree, Map<Long, Integer> sessions)
{    System.out.println("Session Details (sid, timeout, ephemeralCount):");    for (Map.Entry<Long, Integer> e : sessions.entrySet()) {        long sid = e.getKey();        System.out.println(String.format("%#016x, %d, %d", sid, e.getValue(), dataTree.getEphemerals(sid).size()));    }}
printStat
private void zookeeper_f3372_0(StatPersisted stat)
{    printHex("cZxid", stat.getCzxid());    System.out.println("  ctime = " + new Date(stat.getCtime()).toString());    printHex("mZxid", stat.getMzxid());    System.out.println("  mtime = " + new Date(stat.getMtime()).toString());    printHex("pZxid", stat.getPzxid());    System.out.println("  cversion = " + stat.getCversion());    System.out.println("  dataVersion = " + stat.getVersion());    System.out.println("  aclVersion = " + stat.getAversion());    printHex("ephemeralOwner", stat.getEphemeralOwner());}
printHex
private void zookeeper_f3373_0(String prefix, long value)
{    System.out.println(String.format("  %s = %#016x", prefix, value));}
printSnapshotJson
private void zookeeper_f3374_0(final DataTree dataTree)
{    System.out.printf("[1,0,{\"progname\":\"SnapshotFormatter.java\",\"progver\":\"0.01\",\"timestamp\":%d}", System.currentTimeMillis());    printZnodeJson(dataTree, "/");    System.out.print("]");}
printZnodeJson
private void zookeeper_f3375_0(final DataTree dataTree, final String fullPath)
{    final DataNode n = dataTree.getNode(fullPath);    if (null == n) {        System.err.println("DataTree Node for " + fullPath + " doesn't exist");        return;    }    final String name = fullPath.equals("/") ? fullPath : fullPath.substring(fullPath.lastIndexOf("/") + 1);    System.out.print(",");    int dataLen;    synchronized (n) {                dataLen = (n.data == null) ? 0 : n.data.length;    }    StringBuilder nodeSB = new StringBuilder();    nodeSB.append("{");    nodeSB.append("\"name\":\"").append(JSONValue.escape(name)).append("\"").append(",");    nodeSB.append("\"asize\":").append(dataLen).append(",");    nodeSB.append("\"dsize\":").append(dataLen).append(",");    nodeSB.append("\"dev\":").append(0).append(",");    nodeSB.append("\"ino\":").append(++INODE_IDX);    nodeSB.append("}");    Set<String> children;    synchronized (n) {                children = n.getChildren();    }    if (children != null && children.size() > 0) {        System.out.print("[" + nodeSB);        for (String child : children) {            printZnodeJson(dataTree, fullPath + (fullPath.equals("/") ? "" : "/") + child);        }        System.out.print("]");    } else {        System.out.print(nodeSB);    }}
setSnapCount
public static void zookeeper_f3376_0(int count)
{    snapCount = count;}
getSnapCount
public static int zookeeper_f3377_0()
{    return snapCount;}
getRemainingDelay
private long zookeeper_f3378_0()
{    long flushDelay = zks.getFlushDelay();    long duration = Time.currentElapsedTime() - lastFlushTime;    if (duration < flushDelay) {        return flushDelay - duration;    }    return 0;}
shouldFlush
private boolean zookeeper_f3379_0()
{    long flushDelay = zks.getFlushDelay();    long maxBatchSize = zks.getMaxBatchSize();    if ((flushDelay > 0) && (getRemainingDelay() == 0)) {        return true;    }    return (maxBatchSize > 0) && (toFlush.size() >= maxBatchSize);}
setSnapSizeInBytes
public static void zookeeper_f3380_0(long size)
{    snapSizeInBytes = size;}
shouldSnapshot
private boolean zookeeper_f3381_0()
{    int logCount = zks.getZKDatabase().getTxnCount();    long logSize = zks.getZKDatabase().getTxnSize();    return (logCount > (snapCount / 2 + randRoll)) || (snapSizeInBytes > 0 && logSize > (snapSizeInBytes / 2 + randSize));}
resetSnapshotStats
private void zookeeper_f3382_0()
{    randRoll = ThreadLocalRandom.current().nextInt(snapCount / 2);    randSize = Math.abs(ThreadLocalRandom.current().nextLong() % (snapSizeInBytes / 2));}
run
public voidf3383_1)
{    try {                        resetSnapshotStats();        lastFlushTime = Time.currentElapsedTime();        while (true) {            ServerMetrics.getMetrics().SYNC_PROCESSOR_QUEUE_SIZE.add(queuedRequests.size());            long pollTime = Math.min(zks.getMaxWriteQueuePollTime(), getRemainingDelay());            Request si = queuedRequests.poll(pollTime, TimeUnit.MILLISECONDS);            if (si == null) {                /* We timed out looking for more writes to batch, go ahead and flush immediately */                flush();                si = queuedRequests.take();            }            if (si == REQUEST_OF_DEATH) {                break;            }            long startProcessTime = Time.currentElapsedTime();            ServerMetrics.getMetrics().SYNC_PROCESSOR_QUEUE_TIME.add(startProcessTime - si.syncQueueStartTime);                        if (zks.getZKDatabase().append(si)) {                if (shouldSnapshot()) {                    resetSnapshotStats();                                        zks.getZKDatabase().rollLog();                                        if (!snapThreadMutex.tryAcquire()) {                                            } else {                        new ZooKeeperThread("Snapshot Thread") {                            public void run() {                                try {                                    zks.takeSnapshot();                                } catch (Exception e) {                                                                    } finally {                                    snapThreadMutex.release();                                }                            }                        }.start();                    }                }            } else if (toFlush.isEmpty()) {                                if (nextProcessor != null) {                    nextProcessor.processRequest(si);                    if (nextProcessor instanceof Flushable) {                        ((Flushable) nextProcessor).flush();                    }                }                continue;            }            toFlush.add(si);            if (shouldFlush()) {                flush();            }            ServerMetrics.getMetrics().SYNC_PROCESS_TIME.add(Time.currentElapsedTime() - startProcessTime);        }    } catch (Throwable t) {        handleException(this.getName(), t);    }    }
run
public voidf3384_1)
{    try {        zks.takeSnapshot();    } catch (Exception e) {            } finally {        snapThreadMutex.release();    }}
flush
private void zookeeper_f3385_0() throws IOException, RequestProcessorException
{    if (this.toFlush.isEmpty()) {        return;    }    ServerMetrics.getMetrics().BATCH_SIZE.add(toFlush.size());    long flushStartTime = Time.currentElapsedTime();    zks.getZKDatabase().commit();    ServerMetrics.getMetrics().SYNC_PROCESSOR_FLUSH_TIME.add(Time.currentElapsedTime() - flushStartTime);    if (this.nextProcessor == null) {        this.toFlush.clear();    } else {        while (!this.toFlush.isEmpty()) {            final Request i = this.toFlush.remove();            long latency = Time.currentElapsedTime() - i.syncQueueStartTime;            ServerMetrics.getMetrics().SYNC_PROCESSOR_QUEUE_AND_FLUSH_TIME.add(latency);            this.nextProcessor.processRequest(i);        }        if (this.nextProcessor instanceof Flushable) {            ((Flushable) this.nextProcessor).flush();        }        lastFlushTime = Time.currentElapsedTime();    }}
shutdown
public voidf3386_1)
{        queuedRequests.add(REQUEST_OF_DEATH);    try {        this.join();        this.flush();    } catch (InterruptedException e) {                Thread.currentThread().interrupt();    } catch (IOException e) {            } catch (RequestProcessorException e) {            }    if (nextProcessor != null) {        nextProcessor.shutdown();    }}
processRequest
public void zookeeper_f3387_0(final Request request)
{    Objects.requireNonNull(request, "Request cannot be null");    request.syncQueueStartTime = Time.currentElapsedTime();    queuedRequests.add(request);    ServerMetrics.getMetrics().SYNC_PROCESSOR_QUEUED.add(1);}
main
public static void zookeeper_f3388_0(String[] args) throws IOException
{    if (args.length != 1) {        System.err.println("USAGE: TraceFormatter trace_file");        System.exit(ExitCode.INVALID_INVOCATION.getValue());    }    FileChannel fc = new FileInputStream(args[0]).getChannel();    while (true) {        ByteBuffer bb = ByteBuffer.allocate(41);        fc.read(bb);        bb.flip();        byte app = bb.get();        long time = bb.getLong();        long id = bb.getLong();        int cxid = bb.getInt();        long zxid = bb.getLong();        int txnType = bb.getInt();        int type = bb.getInt();        int len = bb.getInt();        bb = ByteBuffer.allocate(len);        fc.read(bb);        bb.flip();        String path = "n/a";        if (bb.remaining() > 0) {            if (type != OpCode.createSession) {                int pathLen = bb.getInt();                byte[] b = new byte[pathLen];                bb.get(b);                path = new String(b);            }        }        System.out.println(DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.LONG).format(new Date(time)) + ": " + (char) app + " id=0x" + Long.toHexString(id) + " cxid=" + cxid + " op=" + Request.op2String(type) + " zxid=0x" + Long.toHexString(zxid) + " txnType=" + txnType + " len=" + len + " path=" + path);    }}
hasNext
public boolean zookeeper_f3389_0()
{    return hasNext;}
next
public Proposalf3390_1)
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos);    Proposal p = new Proposal();    try {        TxnHeader hdr = itr.getHeader();        Record txn = itr.getTxn();        hdr.serialize(boa, "hdr");        if (txn != null) {            txn.serialize(boa, "txn");        }        baos.close();        QuorumPacket pp = new QuorumPacket(Leader.PROPOSAL, itr.getHeader().getZxid(), baos.toByteArray(), null);        p.packet = pp;        p.request = null;                hasNext = itr.next();    } catch (IOException e) {                hasNext = false;    }    return p;}
remove
public void zookeeper_f3391_0()
{    throw new UnsupportedOperationException();}
close
public voidf3392_1)
{    if (itr != null) {        try {            itr.close();        } catch (IOException ioe) {                    }    }}
processRequest
public void zookeeper_f3393_0(Request request) throws RequestProcessorException
{    KeeperException ke = new KeeperException.UnimplementedException();    request.setException(ke);    ReplyHeader rh = new ReplyHeader(request.cxid, request.zxid, ke.code().intValue());    try {        request.cnxn.sendResponse(rh, null, "response");    } catch (IOException e) {        throw new RequestProcessorException("Can't send the response", e);    }    request.cnxn.sendCloseSession();}
shutdown
public void zookeeper_f3394_0()
{}
addDigest
public AdHash zookeeper_f3395_0(long digest)
{    hash += digest;    return this;}
removeDigest
public AdHash zookeeper_f3396_0(long digest)
{    hash -= digest;    return this;}
toHexString
public String zookeeper_f3397_0()
{    return Long.toHexString(hash);}
getHash
public long zookeeper_f3398_0()
{    return hash;}
equals
public boolean zookeeper_f3399_0(Object other)
{    return other instanceof AdHash && ((AdHash) other).hash == this.hash;}
hashCode
public int zookeeper_f3400_0()
{    return Long.hashCode(hash);}
toString
public String zookeeper_f3401_0()
{    return toHexString();}
add
public synchronized boolean zookeeper_f3402_0(Integer elementBit)
{    if (elementBit == null || elementBits.get(elementBit)) {        return false;    }    if (cache.size() < cacheSize) {        cache.add(elementBit);    }    elementBits.set(elementBit);    elementCount++;    return true;}
remove
public synchronized int zookeeper_f3403_0(Set<Integer> bitSet, BitSet bits)
{    cache.removeAll(bitSet);    elementBits.andNot(bits);    int elementCountBefore = elementCount;    elementCount = elementBits.cardinality();    return elementCountBefore - elementCount;}
remove
public synchronized boolean zookeeper_f3404_0(Integer elementBit)
{    if (elementBit == null || !elementBits.get(elementBit)) {        return false;    }    cache.remove(elementBit);    elementBits.clear(elementBit);    elementCount--;    return true;}
contains
public synchronized boolean zookeeper_f3405_0(Integer elementBit)
{    if (elementBit == null) {        return false;    }    return elementBits.get(elementBit);}
size
public synchronized int zookeeper_f3406_0()
{    return elementCount;}
iterator
public Iterator<Integer> zookeeper_f3407_0()
{        int currentSize = size();    if (cache.size() == currentSize) {        return cache.iterator();    }    return new Iterator<Integer>() {        int returnedCount = 0;        int bitIndex = 0;        @Override        public boolean hasNext() {            return returnedCount < currentSize;        }        @Override        public Integer next() {            int bit = elementBits.nextSetBit(bitIndex);            bitIndex = bit + 1;            returnedCount++;            return bit;        }        @Override        public void remove() {            throw new UnsupportedOperationException();        }    };}
hasNext
public boolean zookeeper_f3408_0()
{    return returnedCount < currentSize;}
next
public Integer zookeeper_f3409_0()
{    int bit = elementBits.nextSetBit(bitIndex);    bitIndex = bit + 1;    returnedCount++;    return bit;}
remove
public void zookeeper_f3410_0()
{    throw new UnsupportedOperationException();}
cachedSize
public synchronized int zookeeper_f3411_0()
{    return cache.size();}
isEmpty
public synchronized boolean zookeeper_f3412_0()
{    return elementCount == 0;}
add
public Integer zookeeper_f3413_0(T value)
{    /*         * Optimized for code which will add the same value again and again,         * more specifically this is used to add new bit for watcher, and         * the same watcher may watching thousands or even millions of nodes,         * which will call add the same value of this function, check exist         * using read lock will optimize the performance here.         */    Integer bit = getBit(value);    if (bit != null) {        return bit;    }    rwLock.writeLock().lock();    try {        bit = value2Bit.get(value);        if (bit != null) {            return bit;        }        bit = freedBitSet.nextSetBit(0);        if (bit > -1) {            freedBitSet.clear(bit);        } else {            bit = nextBit++;        }        value2Bit.put(value, bit);        bit2Value.put(bit, value);        return bit;    } finally {        rwLock.writeLock().unlock();    }}
get
public T zookeeper_f3414_0(int bit)
{    rwLock.readLock().lock();    try {        return bit2Value.get(bit);    } finally {        rwLock.readLock().unlock();    }}
getBit
public Integer zookeeper_f3415_0(T value)
{    rwLock.readLock().lock();    try {        return value2Bit.get(value);    } finally {        rwLock.readLock().unlock();    }}
remove
public int zookeeper_f3416_0(T value)
{    /*         * remove only called once when the session is closed, so use write         * lock directly without checking read lock.         */    rwLock.writeLock().lock();    try {        Integer bit = value2Bit.get(value);        if (bit == null) {            return -1;        }        value2Bit.remove(value);        bit2Value.remove(bit);        freedBitSet.set(bit);        return bit;    } finally {        rwLock.writeLock().unlock();    }}
remove
public T zookeeper_f3417_0(int bit)
{    rwLock.writeLock().lock();    try {        T value = bit2Value.get(bit);        if (value == null) {            return null;        }        value2Bit.remove(value);        bit2Value.remove(bit);        freedBitSet.set(bit);        return value;    } finally {        rwLock.writeLock().unlock();    }}
size
public int zookeeper_f3418_0()
{    rwLock.readLock().lock();    try {        return value2Bit.size();    } finally {        rwLock.readLock().unlock();    }}
write
public synchronized void zookeeper_f3419_0(T element)
{    int newSize = numberOfElements.incrementAndGet();    if (newSize > capacity) {        buffer[oldest] = element;        oldest = ++oldest % capacity;        numberOfElements.decrementAndGet();    } else {        int index = (oldest + numberOfElements.get() - 1) % capacity;        buffer[index] = element;    }}
take
public synchronized T zookeeper_f3420_0()
{    int newSize = numberOfElements.decrementAndGet();    if (newSize < 0) {        numberOfElements.incrementAndGet();        return null;    }    T polled = buffer[oldest];    oldest = ++oldest % capacity;    return polled;}
peek
public synchronized T zookeeper_f3421_0()
{    if (numberOfElements.get() <= 0) {        return null;    }    return buffer[oldest];}
size
public int zookeeper_f3422_0()
{    return numberOfElements.get();}
isEmpty
public boolean zookeeper_f3423_0()
{    return numberOfElements.get() <= 0;}
isFull
public boolean zookeeper_f3424_0()
{    return numberOfElements.get() >= capacity;}
reset
public synchronized void zookeeper_f3425_0()
{    numberOfElements.set(0);}
getClientConfigStr
public static String zookeeper_f3426_0(String configData)
{    Properties props = new Properties();    try {        props.load(new StringReader(configData));    } catch (IOException e) {        e.printStackTrace();        return "";    }    StringBuffer sb = new StringBuffer();    boolean first = true;    String version = "";    for (Entry<Object, Object> entry : props.entrySet()) {        String key = entry.getKey().toString().trim();        String value = entry.getValue().toString().trim();        if (key.equals("version")) {            version = value;        }        if (!key.startsWith("server.")) {            continue;        }        QuorumPeer.QuorumServer qs;        try {            qs = new QuorumPeer.QuorumServer(-1, value);        } catch (ConfigException e) {            e.printStackTrace();            continue;        }        if (!first) {            sb.append(",");        } else {            first = false;        }        if (null != qs.clientAddr) {            sb.append(qs.clientAddr.getHostString() + ":" + qs.clientAddr.getPort());        }    }    return version + " " + sb.toString();}
getHostAndPort
public static String[] zookeeper_f3427_0(String s) throws ConfigException
{    if (s.startsWith("[")) {        int i = s.indexOf("]");        if (i < 0) {            throw new ConfigException(s + " starts with '[' but has no matching ']:'");        }        if (i + 2 == s.length()) {            throw new ConfigException(s + " doesn't have a port after colon");        }        if (i + 2 < s.length()) {            String[] sa = s.substring(i + 2).split(":");            String[] nsa = new String[sa.length + 1];            nsa[0] = s.substring(1, i);            System.arraycopy(sa, 0, nsa, 1, sa.length);            return nsa;        }        return new String[] { s.replaceAll("\\[|\\]", "") };    } else {        return s.split(":");    }}
serviceStart
public void zookeeper_f3428_0()
{    monitorThread = new Thread(new JVMMonitor());    monitorThread.setDaemon(true);    monitorThread.start();}
serviceStop
public void zookeeper_f3429_0()
{    shouldRun = false;    if (monitorThread != null) {        monitorThread.interrupt();        try {            monitorThread.join();        } catch (InterruptedException e) {            Thread.currentThread().interrupt();        }    }}
isStarted
public boolean zookeeper_f3430_0()
{    return monitorThread != null;}
getNumGcWarnThresholdExceeded
public long zookeeper_f3431_0()
{    return numGcWarnThresholdExceeded;}
getNumGcInfoThresholdExceeded
public long zookeeper_f3432_0()
{    return numGcInfoThresholdExceeded;}
getTotalGcExtraSleepTime
public long zookeeper_f3433_0()
{    return totalGcExtraSleepTime;}
formatMessage
private String zookeeper_f3434_0(long extraSleepTime, Map<String, GcTimes> gcTimesAfterSleep, Map<String, GcTimes> gcTimesBeforeSleep)
{    Set<String> gcBeanNames = new HashSet<>(gcTimesAfterSleep.keySet());    gcBeanNames.retainAll(gcTimesBeforeSleep.keySet());    List<String> gcDiffs = new ArrayList<>();    for (String name : gcBeanNames) {        GcTimes diff = gcTimesAfterSleep.get(name).subtract(gcTimesBeforeSleep.get(name));        if (diff.gcCount != 0) {            gcDiffs.add("GC pool '" + name + "' had collection(s): " + diff.toString());        }    }    String ret = String.format("Detected pause in JVM or host machine (eg GC): pause of approximately %d ms, " + "total pause: info level: %d, warn level: %d %n", extraSleepTime, numGcInfoThresholdExceeded, numGcWarnThresholdExceeded);    if (gcDiffs.isEmpty()) {        ret += ("No GCs detected");    } else {        ret += String.join("\n", gcDiffs);    }    return ret;}
getGcTimes
private Map<String, GcTimes> zookeeper_f3435_0()
{    Map<String, GcTimes> map = new HashMap<>();    List<GarbageCollectorMXBean> gcBeans = ManagementFactory.getGarbageCollectorMXBeans();    for (GarbageCollectorMXBean gcBean : gcBeans) {        map.put(gcBean.getName(), new GcTimes(gcBean));    }    return map;}
subtract
private GcTimes zookeeper_f3436_0(GcTimes other)
{    return new GcTimes(this.gcCount - other.gcCount, this.gcTimeMillis - other.gcTimeMillis);}
toString
public String zookeeper_f3437_0()
{    return "count=" + gcCount + " time=" + gcTimeMillis + "ms";}
run
public voidf3438_1)
{    Map<String, GcTimes> gcTimesBeforeSleep = getGcTimes();        while (shouldRun) {        long startTime = Instant.now().toEpochMilli();        try {            Thread.sleep(sleepTimeMs);        } catch (InterruptedException ie) {            return;        }        long endTime = Instant.now().toEpochMilli();        long extraSleepTime = (endTime - startTime) - sleepTimeMs;        Map<String, GcTimes> gcTimesAfterSleep = getGcTimes();        if (extraSleepTime > warnThresholdMs) {            ++numGcWarnThresholdExceeded;                    } else if (extraSleepTime > infoThresholdMs) {            ++numGcInfoThresholdExceeded;                    }        totalGcExtraSleepTime += extraSleepTime;        gcTimesBeforeSleep = gcTimesAfterSleep;    }}
getDefaultRealm
public static String zookeeper_f3439_0() throws IllegalArgumentException
{    return new KerberosPrincipal("tmp", 1).getRealm();}
main
public static void zookeeper_f3440_0(String[] args)
{    ExitCode rc = ExitCode.INVALID_INVOCATION;    if (args.length != 3) {        System.out.println("Usage: LogChopper zxid_to_chop_to txn_log_to_chop chopped_filename");        System.out.println("    this program will read the txn_log_to_chop file and copy all the transactions");        System.out.println("    from it up to (and including) the given zxid into chopped_filename.");        System.exit(rc.getValue());    }    String txnLog = args[1];    String choppedLog = args[2];    try (InputStream is = new BufferedInputStream(new FileInputStream(txnLog));        OutputStream os = new BufferedOutputStream(new FileOutputStream(choppedLog))) {        long zxid = Long.decode(args[0]);        if (chop(is, os, zxid)) {            rc = ExitCode.EXECUTION_FINISHED;        }    } catch (Exception e) {        System.out.println("Got exception: " + e.getMessage());    }    System.exit(rc.getValue());}
chop
public static boolean zookeeper_f3441_0(InputStream is, OutputStream os, long zxid) throws IOException
{    BinaryInputArchive logStream = BinaryInputArchive.getArchive(is);    BinaryOutputArchive choppedStream = BinaryOutputArchive.getArchive(os);    FileHeader fhdr = new FileHeader();    fhdr.deserialize(logStream, "fileheader");    if (fhdr.getMagic() != FileTxnLog.TXNLOG_MAGIC) {        System.err.println("Invalid magic number in txn log file");        return false;    }    System.out.println("ZooKeeper Transactional Log File with dbid " + fhdr.getDbid() + " txnlog format version " + fhdr.getVersion());    fhdr.serialize(choppedStream, "fileheader");    int count = 0;    boolean hasZxid = false;    long previousZxid = -1;    while (true) {        long crcValue;        byte[] bytes;        try {            crcValue = logStream.readLong("crcvalue");            bytes = logStream.readBuffer("txnEntry");        } catch (EOFException e) {            System.out.println("EOF reached after " + count + " txns.");                        return false;        }        if (bytes.length == 0) {                                    System.out.println("EOF reached after " + count + " txns.");                        return false;        }        Checksum crc = new Adler32();        crc.update(bytes, 0, bytes.length);        if (crcValue != crc.getValue()) {            throw new IOException("CRC doesn't match " + crcValue + " vs " + crc.getValue());        }        TxnHeader hdr = new TxnHeader();        Record txn = SerializeUtils.deserializeTxn(bytes, hdr);        if (logStream.readByte("EOR") != 'B') {            System.out.println("Last transaction was partial.");            throw new EOFException("Last transaction was partial.");        }        final long txnZxid = hdr.getZxid();        if (txnZxid == zxid) {            hasZxid = true;        }                if (previousZxid != -1 && txnZxid != previousZxid + 1) {            long txnEpoch = ZxidUtils.getEpochFromZxid(txnZxid);            long txnCounter = ZxidUtils.getCounterFromZxid(txnZxid);            long previousEpoch = ZxidUtils.getEpochFromZxid(previousZxid);            if (txnEpoch == previousEpoch) {                System.out.println(String.format("There is intra-epoch gap between %x and %x", previousZxid, txnZxid));            } else if (txnCounter != 1) {                System.out.println(String.format("There is inter-epoch gap between %x and %x", previousZxid, txnZxid));            }        }        previousZxid = txnZxid;        if (txnZxid > zxid) {            if (count == 0 || !hasZxid) {                System.out.println(String.format("This log does not contain zxid %x", zxid));                return false;            }            System.out.println(String.format("Chopping at %x new log has %d records", zxid, count));            return true;        }        choppedStream.writeLong(crcValue, "crcvalue");        choppedStream.writeBuffer(bytes, "txnEntry");        choppedStream.writeByte((byte) 'B', "EOR");        count++;    }}
trackSent
public void zookeeper_f3442_0(long timestamp)
{    if (enabled) {        sentBuffer.write(new BufferedMessage(timestamp));    }}
trackSent
public void zookeeper_f3443_0(int packetType)
{    if (enabled) {        sentBuffer.write(new BufferedMessage(packetType));    }}
trackReceived
public void zookeeper_f3444_0(long timestamp)
{    if (enabled) {        receivedBuffer.write(new BufferedMessage(timestamp));    }}
trackReceived
public void zookeeper_f3445_0(int packetType)
{    if (enabled) {        receivedBuffer.write(new BufferedMessage(packetType));    }}
peekSent
public final BufferedMessage zookeeper_f3446_0()
{    return sentBuffer.peek();}
peekReceived
public final BufferedMessage zookeeper_f3447_0()
{    return receivedBuffer.peek();}
peekSentTimestamp
public final long zookeeper_f3448_0()
{    return enabled ? sentBuffer.peek().getTimestamp() : 0;}
peekReceivedTimestamp
public final long zookeeper_f3449_0()
{    return enabled ? receivedBuffer.peek().getTimestamp() : 0;}
dumpToLog
public void zookeeper_f3450_0(String serverAddress)
{    if (!enabled) {        return;    }    logMessages(serverAddress, receivedBuffer, Direction.RECEIVED);    logMessages(serverAddress, sentBuffer, Direction.SENT);}
logMessages
private static voidf3451_1String serverAddr, CircularBuffer<BufferedMessage> messages, Direction direction)
{    String sentOrReceivedText = direction == Direction.SENT ? "sentBuffer to" : "receivedBuffer from";    if (messages.isEmpty()) {            } else {                while (!messages.isEmpty()) {                    }    }}
getTimestamp
private long zookeeper_f3452_0()
{    return timestamp;}
toString
public String zookeeper_f3453_0()
{    if (messageType == -1) {        return "TimeStamp: " + new SimpleDateFormat("yyyy-MM-dd HH:mm:ss,SSS").format(new Date(timestamp));    } else {        return "TimeStamp: " + new SimpleDateFormat("yyyy-MM-dd HH:mm:ss,SSS").format(new Date(timestamp)) + " Type: " + Leader.getPacketType(messageType);    }}
getUnix
public boolean zookeeper_f3454_0()
{    if (windows) {        return false;    }    return (!ibmvendor || linux);}
getOSUnixMXBeanMethod
private Longf3455_1String mBeanMethodName)
{    Object unixos;    Class<?> classRef;    Method mBeanMethod;    try {        classRef = Class.forName("com.sun.management.UnixOperatingSystemMXBean");        if (classRef.isInstance(osMbean)) {            mBeanMethod = classRef.getDeclaredMethod(mBeanMethodName);            unixos = classRef.cast(osMbean);            return (Long) mBeanMethod.invoke(unixos);        }    } catch (Exception e) {            }    return null;}
getOpenFileDescriptorCount
public longf3456_1)
{    Long ofdc;    if (!ibmvendor) {        ofdc = getOSUnixMXBeanMethod("getOpenFileDescriptorCount");        return (ofdc != null ? ofdc.longValue() : -1);    }    try {                RuntimeMXBean rtmbean = ManagementFactory.getRuntimeMXBean();        String rtname = rtmbean.getName();        String[] pidhost = rtname.split("@");                Process p = Runtime.getRuntime().exec(new String[] { "bash", "-c", "ls /proc/" + pidhost[0] + "/fdinfo | wc -l" });        InputStream in = p.getInputStream();        BufferedReader output = new BufferedReader(new InputStreamReader(in));        try {            String openFileDesCount;            if ((openFileDesCount = output.readLine()) != null) {                return Long.parseLong(openFileDesCount);            }        } finally {            if (output != null) {                output.close();            }        }    } catch (IOException ie) {            }    return -1;}
getMaxFileDescriptorCount
public longf3457_1)
{    Long mfdc;    if (!ibmvendor) {        mfdc = getOSUnixMXBeanMethod("getMaxFileDescriptorCount");        return (mfdc != null ? mfdc.longValue() : -1);    }    try {                Process p = Runtime.getRuntime().exec(new String[] { "bash", "-c", "ulimit -n" });        InputStream in = p.getInputStream();        BufferedReader output = new BufferedReader(new InputStreamReader(in));        try {            String maxFileDesCount;            if ((maxFileDesCount = output.readLine()) != null) {                return Long.parseLong(maxFileDesCount);            }        } finally {            if (output != null) {                output.close();            }        }    } catch (IOException ie) {            }    return -1;}
isWriteOp
 static boolean zookeeper_f3458_0(int requestType)
{    switch(requestType) {        case ZooDefs.OpCode.sync:        case ZooDefs.OpCode.create:        case ZooDefs.OpCode.create2:        case ZooDefs.OpCode.createContainer:        case ZooDefs.OpCode.delete:        case ZooDefs.OpCode.deleteContainer:        case ZooDefs.OpCode.setData:        case ZooDefs.OpCode.reconfig:        case ZooDefs.OpCode.setACL:        case ZooDefs.OpCode.multi:        case ZooDefs.OpCode.check:            return true;    }    return false;}
trimPathDepth
 static String zookeeper_f3459_0(String path, int maxDepth)
{    int count = 0;    StringBuilder sb = new StringBuilder();    StringTokenizer pathTokenizer = new StringTokenizer(path, PATH_SEPERATOR);    while (pathTokenizer.hasMoreElements() && count++ < maxDepth) {        sb.append(PATH_SEPERATOR);        sb.append(pathTokenizer.nextToken());    }    path = sb.toString();    return path;}
shutdown
public voidf3460_1)
{    if (!enabled) {        return;    }        scheduledExecutor.shutdownNow();}
registerRequest
public voidf3462_1int type, String path)
{    if (!enabled) {        return;    }    if (sampler.nextFloat() <= REQUEST_PREPROCESS_SAMPLE_RATE) {        PathStatsQueue pathStatsQueue = immutableRequestsMap.get(Request.op2String(type));        if (pathStatsQueue != null) {            pathStatsQueue.registerRequest(path);        } else {                    }    }}
dumpTopRequestPath
public void zookeeper_f3463_0(PrintWriter pwriter, String requestTypeName, int queryMaxDepth)
{    if (queryMaxDepth < 1) {        return;    }    PathStatsQueue pathStatsQueue = immutableRequestsMap.get(requestTypeName);    if (pathStatsQueue == null) {        pwriter.println("Can not find path stats for type: " + requestTypeName);        return;    } else {        pwriter.println("The top requests of type: " + requestTypeName);    }    Map<String, Integer> combinedMap;    final int maxDepth = Math.min(queryMaxDepth, REQUEST_PREPROCESS_PATH_DEPTH);    combinedMap = pathStatsQueue.collectStats(maxDepth);    logTopPaths(combinedMap, entry -> pwriter.println(entry.getKey() + " : " + entry.getValue()));}
dumpTopReadPaths
public void zookeeper_f3464_0(PrintWriter pwriter, int queryMaxDepth)
{    pwriter.println("The top read requests are");    dumpTopAggregatedPaths(pwriter, queryMaxDepth, queue -> !queue.isWriteOperation);}
dumpTopWritePaths
public void zookeeper_f3465_0(PrintWriter pwriter, int queryMaxDepth)
{    pwriter.println("The top write requests are");    dumpTopAggregatedPaths(pwriter, queryMaxDepth, queue -> queue.isWriteOperation);}
dumpTopPaths
public void zookeeper_f3466_0(PrintWriter pwriter, int queryMaxDepth)
{    pwriter.println("The top requests are");    dumpTopAggregatedPaths(pwriter, queryMaxDepth, queue -> true);}
dumpTopAggregatedPaths
private void zookeeper_f3467_0(PrintWriter pwriter, int queryMaxDepth, final Predicate<PathStatsQueue> predicate)
{    if (!enabled) {        return;    }    final Map<String, Integer> combinedMap = aggregatePaths(queryMaxDepth, predicate);    logTopPaths(combinedMap, entry -> pwriter.println(entry.getKey() + " : " + entry.getValue()));}
aggregatePaths
 Map<String, Integer> zookeeper_f3468_0(int queryMaxDepth, Predicate<PathStatsQueue> predicate)
{    final Map<String, Integer> combinedMap = new HashMap<>(REQUEST_PREPROCESS_TOPPATH_MAX);    final int maxDepth = Math.min(queryMaxDepth, REQUEST_PREPROCESS_PATH_DEPTH);    immutableRequestsMap.values().stream().filter(predicate).forEach(pathStatsQueue -> pathStatsQueue.collectStats(maxDepth).forEach((path, count) -> combinedMap.put(path, combinedMap.getOrDefault(path, 0) + count)));    return combinedMap;}
logTopPaths
 void zookeeper_f3469_0(Map<String, Integer> combinedMap, final Consumer<Map.Entry<String, Integer>> output)
{    combinedMap.entrySet().stream().sorted(Comparator.comparing(Map.Entry<String, Integer>::getValue).reversed()).limit(REQUEST_PREPROCESS_TOPPATH_MAX).forEach(output);}
registerRequest
public void zookeeper_f3470_0(String path)
{    if (!enabled) {        return;    }    currentSlot.get().offer(path);}
getCurrentSlot
 ConcurrentLinkedQueue<String> zookeeper_f3471_0()
{    return currentSlot.get();}
mapReducePaths
 Map<String, Integer> zookeeper_f3472_0(int maxDepth, Collection<String> tobeProcessedSlot)
{    Map<String, Integer> newSlot = new ConcurrentHashMap<>();    tobeProcessedSlot.stream().filter(path -> path != null).forEach((path) -> {        path = trimPathDepth(path, maxDepth);        newSlot.put(path, newSlot.getOrDefault(path, 0) + 1);    });    return newSlot;}
collectStats
public Map<String, Integer> zookeeper_f3473_0(int maxDepth)
{    Map<String, Integer> combinedMap;            Map<String, Integer> snapShot = mapReducePaths(maxDepth, Arrays.asList(currentSlot.get().toArray(new String[0])));        synchronized (accurateMode ? requestPathStats : new Object()) {        combinedMap = requestPathStats.stream().reduce(snapShot, (firstMap, secondMap) -> {            secondMap.forEach((key, value) -> {                String trimmedPath = trimPathDepth(key, maxDepth);                firstMap.put(trimmedPath, firstMap.getOrDefault(trimmedPath, 0) + value);            });            return firstMap;        });    }    return combinedMap;}
start
public voidf3474_1)
{    if (!enabled) {        return;    }        int delay = sampler.nextInt(REQUEST_STATS_SLOT_DURATION);            scheduledExecutor.scheduleWithFixedDelay(() -> {                ConcurrentLinkedQueue<String> tobeProcessedSlot = currentSlot.getAndSet(new ConcurrentLinkedQueue<>());        try {                                    Map<String, Integer> latestSlot = mapReducePaths(REQUEST_PREPROCESS_PATH_DEPTH, tobeProcessedSlot);            synchronized (accurateMode ? requestPathStats : new Object()) {                if (requestPathStats.remainingCapacity() <= 0) {                    requestPathStats.poll();                }                if (!requestPathStats.offer(latestSlot)) {                                    }            }        } catch (Exception e) {                    }    }, delay, REQUEST_STATS_SLOT_DURATION, TimeUnit.SECONDS);}
isWriteOperation
 boolean zookeeper_f3475_0()
{    return isWriteOperation;}
deserializeTxn
public static Record zookeeper_f3476_0(byte[] txnBytes, TxnHeader hdr) throws IOException
{    final ByteArrayInputStream bais = new ByteArrayInputStream(txnBytes);    InputArchive ia = BinaryInputArchive.getArchive(bais);    hdr.deserialize(ia, "hdr");    bais.mark(bais.available());    Record txn = null;    switch(hdr.getType()) {        case OpCode.createSession:                                    txn = new CreateSessionTxn();            break;        case OpCode.closeSession:            txn = ZooKeeperServer.isCloseSessionTxnEnabled() ? new CloseSessionTxn() : null;            break;        case OpCode.create:        case OpCode.create2:            txn = new CreateTxn();            break;        case OpCode.createTTL:            txn = new CreateTTLTxn();            break;        case OpCode.createContainer:            txn = new CreateContainerTxn();            break;        case OpCode.delete:        case OpCode.deleteContainer:            txn = new DeleteTxn();            break;        case OpCode.reconfig:        case OpCode.setData:            txn = new SetDataTxn();            break;        case OpCode.setACL:            txn = new SetACLTxn();            break;        case OpCode.error:            txn = new ErrorTxn();            break;        case OpCode.multi:            txn = new MultiTxn();            break;        default:            throw new IOException("Unsupported Txn with type=%d" + hdr.getType());    }    if (txn != null) {        try {            txn.deserialize(ia, "txn");        } catch (EOFException e) {                        if (hdr.getType() == OpCode.create) {                CreateTxn create = (CreateTxn) txn;                bais.reset();                CreateTxnV0 createv0 = new CreateTxnV0();                createv0.deserialize(ia, "txn");                                                create.setPath(createv0.getPath());                create.setData(createv0.getData());                create.setAcl(createv0.getAcl());                create.setEphemeral(createv0.getEphemeral());                create.setParentCVersion(-1);            } else if (hdr.getType() == OpCode.closeSession) {                                                txn = null;            } else {                throw e;            }        }    }    return txn;}
deserializeSnapshot
public static void zookeeper_f3477_0(DataTree dt, InputArchive ia, Map<Long, Integer> sessions) throws IOException
{    int count = ia.readInt("count");    while (count > 0) {        long id = ia.readLong("id");        int to = ia.readInt("timeout");        sessions.put(id, to);        if (LOG.isTraceEnabled()) {            ZooTrace.logTraceMessage(LOG, ZooTrace.SESSION_TRACE_MASK, "loadData --- session in archive: " + id + " with timeout: " + to);        }        count--;    }    dt.deserialize(ia, "tree");}
serializeSnapshot
public static void zookeeper_f3478_0(DataTree dt, OutputArchive oa, Map<Long, Integer> sessions) throws IOException
{    HashMap<Long, Integer> sessSnap = new HashMap<Long, Integer>(sessions);    oa.writeInt(sessSnap.size(), "count");    for (Entry<Long, Integer> entry : sessSnap.entrySet()) {        oa.writeLong(entry.getKey().longValue(), "id");        oa.writeInt(entry.getValue().intValue(), "timeout");    }    dt.serialize(oa, "tree");}
serializeRequest
public static byte[]f3479_1Request request)
{    if (request == null || request.getHdr() == null) {        return null;    }    ByteArrayOutputStream baos = new ByteArrayOutputStream();    BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos);    try {        request.getHdr().serialize(boa, "hdr");        if (request.getTxn() != null) {            request.getTxn().serialize(boa, "txn");        }    } catch (IOException e) {            } finally {        IOUtils.cleanup(LOG, baos);    }    return baos.toByteArray();}
create
public File zookeeper_f3480_0(String path)
{    File file = new File(path);    return validate(file);}
validate
public File zookeeper_f3481_0(File file)
{    if (warnForRelativePath) {        doWarnForRelativePath(file);    }    if (failForNonExistingPath) {        doFailForNonExistingPath(file);    }    return file;}
doFailForNonExistingPath
private void zookeeper_f3482_0(File file)
{    if (!file.exists()) {        throw new IllegalArgumentException(file.toString() + " file is missing");    }}
doWarnForRelativePath
private voidf3483_1File file)
{    if (file.isAbsolute()) {        return;    }    if (file.getPath().substring(0, 2).equals("." + File.separator)) {        return;    }    }
warnForRelativePath
public Builder zookeeper_f3484_0()
{    warnForRelativePathOption = true;    return this;}
failForNonExistingPath
public Builder zookeeper_f3485_0()
{    failForNonExistingPathOption = true;    return this;}
build
public VerifyingFileFactory zookeeper_f3486_0()
{    return new VerifyingFileFactory(this);}
getEpochFromZxid
public static long zookeeper_f3487_0(long zxid)
{    return zxid >> 32L;}
getCounterFromZxid
public static long zookeeper_f3488_0(long zxid)
{    return zxid & 0xffffffffL;}
makeZxid
public static long zookeeper_f3489_0(long epoch, long counter)
{    return (epoch << 32L) | (counter & 0xffffffffL);}
zxidToString
public static String zookeeper_f3490_0(long zxid)
{    return Long.toHexString(zxid);}
addDeadWatcher
public voidf3491_1int watcherBit)
{        while (maxInProcessingDeadWatchers > 0 && !stopped && totalDeadWatchers.get() >= maxInProcessingDeadWatchers) {        try {            RATE_LOGGER.rateLimitLog("Waiting for dead watchers cleaning");            long startTime = Time.currentElapsedTime();            synchronized (processingCompletedEvent) {                processingCompletedEvent.wait(100);            }            long latency = Time.currentElapsedTime() - startTime;            ServerMetrics.getMetrics().ADD_DEAD_WATCHER_STALL_TIME.add(latency);        } catch (InterruptedException e) {                        break;        }    }    synchronized (this) {        if (deadWatchers.add(watcherBit)) {            totalDeadWatchers.incrementAndGet();            ServerMetrics.getMetrics().DEAD_WATCHERS_QUEUED.add(1);            if (deadWatchers.size() >= watcherCleanThreshold) {                synchronized (cleanEvent) {                    cleanEvent.notifyAll();                }            }        }    }}
run
public voidf3492_1)
{    while (!stopped) {        synchronized (cleanEvent) {            try {                                if (!stopped && deadWatchers.size() < watcherCleanThreshold) {                    int maxWaitMs = (watcherCleanIntervalInSeconds + r.nextInt(watcherCleanIntervalInSeconds / 2 + 1)) * 1000;                    cleanEvent.wait(maxWaitMs);                }            } catch (InterruptedException e) {                                break;            }        }        if (deadWatchers.isEmpty()) {            continue;        }        synchronized (this) {                                                                        final Set<Integer> snapshot = new HashSet<Integer>(deadWatchers);            deadWatchers.clear();            int total = snapshot.size();                        cleaners.schedule(new WorkRequest() {                @Override                public void doWork() throws Exception {                    long startTime = Time.currentElapsedTime();                    listener.processDeadWatchers(snapshot);                    long latency = Time.currentElapsedTime() - startTime;                                        ServerMetrics.getMetrics().DEAD_WATCHERS_CLEANER_LATENCY.add(latency);                    ServerMetrics.getMetrics().DEAD_WATCHERS_CLEARED.add(total);                    totalDeadWatchers.addAndGet(-total);                    synchronized (processingCompletedEvent) {                        processingCompletedEvent.notifyAll();                    }                }            });        }    }    }
doWork
public voidf3493_1) throws Exception
{    long startTime = Time.currentElapsedTime();    listener.processDeadWatchers(snapshot);    long latency = Time.currentElapsedTime() - startTime;        ServerMetrics.getMetrics().DEAD_WATCHERS_CLEANER_LATENCY.add(latency);    ServerMetrics.getMetrics().DEAD_WATCHERS_CLEARED.add(total);    totalDeadWatchers.addAndGet(-total);    synchronized (processingCompletedEvent) {        processingCompletedEvent.notifyAll();    }}
shutdown
public voidf3494_1)
{    stopped = true;    deadWatchers.clear();    cleaners.stop();    this.interrupt();    if (LOG.isInfoEnabled()) {            }}
contains
public boolean zookeeper_f3495_0(Watcher watcher)
{    if (watchers == null) {        return false;    }    return watchers.contains(watcher);}
contains
public boolean zookeeper_f3496_0(int watcherBit)
{    if (watcherBits == null) {        return false;    }    return watcherBits.contains(watcherBit);}
size
public int zookeeper_f3497_0()
{    if (watchers != null) {        return watchers.size();    }    if (watcherBits != null) {        return watcherBits.size();    }    return 0;}
deepCopy
private static Map<String, Set<Long>> zookeeper_f3498_0(Map<String, Set<Long>> m)
{    Map<String, Set<Long>> m2 = new HashMap<String, Set<Long>>();    for (Map.Entry<String, Set<Long>> e : m.entrySet()) {        m2.put(e.getKey(), new HashSet<Long>(e.getValue()));    }    return m2;}
hasSessions
public boolean zookeeper_f3499_0(String path)
{    return path2Ids.containsKey(path);}
getSessions
public Set<Long> zookeeper_f3500_0(String path)
{    Set<Long> s = path2Ids.get(path);    return s != null ? Collections.unmodifiableSet(s) : null;}
toMap
public Map<String, Set<Long>> zookeeper_f3501_0()
{    return deepCopy(path2Ids);}
deepCopy
private static Map<Long, Set<String>> zookeeper_f3502_0(Map<Long, Set<String>> m)
{    Map<Long, Set<String>> m2 = new HashMap<Long, Set<String>>();    for (Map.Entry<Long, Set<String>> e : m.entrySet()) {        m2.put(e.getKey(), new HashSet<String>(e.getValue()));    }    return m2;}
hasPaths
public boolean zookeeper_f3503_0(long sessionId)
{    return id2paths.containsKey(sessionId);}
getPaths
public Set<String> zookeeper_f3504_0(long sessionId)
{    Set<String> s = id2paths.get(sessionId);    return s != null ? Collections.unmodifiableSet(s) : null;}
toMap
public Map<Long, Set<String>> zookeeper_f3505_0()
{    return deepCopy(id2paths);}
getNumConnections
public int zookeeper_f3506_0()
{    return numConnections;}
getNumPaths
public int zookeeper_f3507_0()
{    return numPaths;}
getTotalWatches
public int zookeeper_f3508_0()
{    return totalWatches;}
toMap
public Map<String, Object> zookeeper_f3509_0()
{    Map<String, Object> summary = new LinkedHashMap<String, Object>();    summary.put(KEY_NUM_CONNECTIONS, numConnections);    summary.put(KEY_NUM_PATHS, numPaths);    summary.put(KEY_NUM_TOTAL_WATCHES, totalWatches);    return summary;}
size
public synchronized int zookeeper_f3510_0()
{    int result = 0;    for (Set<Watcher> watches : watchTable.values()) {        result += watches.size();    }    return result;}
isDeadWatcher
 boolean zookeeper_f3511_0(Watcher watcher)
{    return watcher instanceof ServerCnxn && ((ServerCnxn) watcher).isStale();}
addWatch
public synchronized booleanf3512_1String path, Watcher watcher)
{    if (isDeadWatcher(watcher)) {                return false;    }    Set<Watcher> list = watchTable.get(path);    if (list == null) {                                list = new HashSet<Watcher>(4);        watchTable.put(path, list);    }    list.add(watcher);    Set<String> paths = watch2Paths.get(watcher);    if (paths == null) {                paths = new HashSet<String>();        watch2Paths.put(watcher, paths);    }    return paths.add(path);}
removeWatcher
public synchronized void zookeeper_f3513_0(Watcher watcher)
{    Set<String> paths = watch2Paths.remove(watcher);    if (paths == null) {        return;    }    for (String p : paths) {        Set<Watcher> list = watchTable.get(p);        if (list != null) {            list.remove(watcher);            if (list.isEmpty()) {                watchTable.remove(p);            }        }    }}
triggerWatch
public WatcherOrBitSet zookeeper_f3514_0(String path, EventType type)
{    return triggerWatch(path, type, null);}
triggerWatch
public WatcherOrBitSet zookeeper_f3515_0(String path, EventType type, WatcherOrBitSet supress)
{    WatchedEvent e = new WatchedEvent(type, KeeperState.SyncConnected, path);    Set<Watcher> watchers;    synchronized (this) {        watchers = watchTable.remove(path);        if (watchers == null || watchers.isEmpty()) {            if (LOG.isTraceEnabled()) {                ZooTrace.logTraceMessage(LOG, ZooTrace.EVENT_DELIVERY_TRACE_MASK, "No watchers for " + path);            }            return null;        }        for (Watcher w : watchers) {            Set<String> paths = watch2Paths.get(w);            if (paths != null) {                paths.remove(path);            }        }    }    for (Watcher w : watchers) {        if (supress != null && supress.contains(w)) {            continue;        }        w.process(e);    }    switch(type) {        case NodeCreated:            ServerMetrics.getMetrics().NODE_CREATED_WATCHER.add(watchers.size());            break;        case NodeDeleted:            ServerMetrics.getMetrics().NODE_DELETED_WATCHER.add(watchers.size());            break;        case NodeDataChanged:            ServerMetrics.getMetrics().NODE_CHANGED_WATCHER.add(watchers.size());            break;        case NodeChildrenChanged:            ServerMetrics.getMetrics().NODE_CHILDREN_WATCHER.add(watchers.size());            break;        default:                        break;    }    return new WatcherOrBitSet(watchers);}
toString
public synchronized String zookeeper_f3516_0()
{    StringBuilder sb = new StringBuilder();    sb.append(watch2Paths.size()).append(" connections watching ").append(watchTable.size()).append(" paths\n");    int total = 0;    for (Set<String> paths : watch2Paths.values()) {        total += paths.size();    }    sb.append("Total watches:").append(total);    return sb.toString();}
dumpWatches
public synchronized void zookeeper_f3517_0(PrintWriter pwriter, boolean byPath)
{    if (byPath) {        for (Entry<String, Set<Watcher>> e : watchTable.entrySet()) {            pwriter.println(e.getKey());            for (Watcher w : e.getValue()) {                pwriter.print("\t0x");                pwriter.print(Long.toHexString(((ServerCnxn) w).getSessionId()));                pwriter.print("\n");            }        }    } else {        for (Entry<Watcher, Set<String>> e : watch2Paths.entrySet()) {            pwriter.print("0x");            pwriter.println(Long.toHexString(((ServerCnxn) e.getKey()).getSessionId()));            for (String path : e.getValue()) {                pwriter.print("\t");                pwriter.println(path);            }        }    }}
containsWatcher
public synchronized boolean zookeeper_f3518_0(String path, Watcher watcher)
{    Set<String> paths = watch2Paths.get(watcher);    return paths != null && paths.contains(path);}
removeWatcher
public synchronized boolean zookeeper_f3519_0(String path, Watcher watcher)
{    Set<String> paths = watch2Paths.get(watcher);    if (paths == null || !paths.remove(path)) {        return false;    }    Set<Watcher> list = watchTable.get(path);    if (list == null || !list.remove(watcher)) {        return false;    }    if (list.isEmpty()) {        watchTable.remove(path);    }    return true;}
getWatches
public synchronized WatchesReport zookeeper_f3520_0()
{    Map<Long, Set<String>> id2paths = new HashMap<Long, Set<String>>();    for (Entry<Watcher, Set<String>> e : watch2Paths.entrySet()) {        Long id = ((ServerCnxn) e.getKey()).getSessionId();        Set<String> paths = new HashSet<String>(e.getValue());        id2paths.put(id, paths);    }    return new WatchesReport(id2paths);}
getWatchesByPath
public synchronized WatchesPathReport zookeeper_f3521_0()
{    Map<String, Set<Long>> path2ids = new HashMap<String, Set<Long>>();    for (Entry<String, Set<Watcher>> e : watchTable.entrySet()) {        Set<Long> ids = new HashSet<Long>(e.getValue().size());        path2ids.put(e.getKey(), ids);        for (Watcher watcher : e.getValue()) {            ids.add(((ServerCnxn) watcher).getSessionId());        }    }    return new WatchesPathReport(path2ids);}
getWatchesSummary
public synchronized WatchesSummary zookeeper_f3522_0()
{    int totalWatches = 0;    for (Set<String> paths : watch2Paths.values()) {        totalWatches += paths.size();    }    return new WatchesSummary(watch2Paths.size(), watchTable.size(), totalWatches);}
shutdown
public void zookeeper_f3523_0()
{/* do nothing */}
createWatchManager
public static IWatchManagerf3524_1) throws IOException
{    String watchManagerName = System.getProperty(ZOOKEEPER_WATCH_MANAGER_NAME);    if (watchManagerName == null) {        watchManagerName = WatchManager.class.getName();    }    try {        IWatchManager watchManager = (IWatchManager) Class.forName(watchManagerName).getConstructor().newInstance();                return watchManager;    } catch (Exception e) {        IOException ioe = new IOException("Couldn't instantiate " + watchManagerName, e);        throw ioe;    }}
addWatch
public booleanf3525_1String path, Watcher watcher)
{    boolean result = false;                        addRemovePathRWLock.readLock().lock();    try {                if (isDeadWatcher(watcher)) {                    } else {            Integer bit = watcherBitIdMap.add(watcher);            BitHashSet watchers = pathWatches.get(path);            if (watchers == null) {                watchers = new BitHashSet();                BitHashSet existingWatchers = pathWatches.putIfAbsent(path, watchers);                                if (existingWatchers != null) {                    watchers = existingWatchers;                }            }            result = watchers.add(bit);        }    } finally {        addRemovePathRWLock.readLock().unlock();    }    return result;}
containsWatcher
public boolean zookeeper_f3526_0(String path, Watcher watcher)
{    BitHashSet watchers = pathWatches.get(path);    return watchers != null && watchers.contains(watcherBitIdMap.getBit(watcher));}
removeWatcher
public boolean zookeeper_f3527_0(String path, Watcher watcher)
{                        addRemovePathRWLock.writeLock().lock();    try {        BitHashSet list = pathWatches.get(path);        if (list == null || !list.remove(watcherBitIdMap.getBit(watcher))) {            return false;        }        if (list.isEmpty()) {            pathWatches.remove(path);        }        return true;    } finally {        addRemovePathRWLock.writeLock().unlock();    }}
removeWatcher
public void zookeeper_f3528_0(Watcher watcher)
{    Integer watcherBit;            addRemovePathRWLock.writeLock().lock();    try {                watcherBit = watcherBitIdMap.getBit(watcher);        if (watcherBit == null) {            return;        }    } finally {        addRemovePathRWLock.writeLock().unlock();    }                                            watcherCleaner.addDeadWatcher(watcherBit);}
processDeadWatchers
public void zookeeper_f3529_0(Set<Integer> deadWatchers)
{                BitSet bits = new BitSet();    for (int dw : deadWatchers) {        bits.set(dw);    }        for (BitHashSet watchers : pathWatches.values()) {        watchers.remove(deadWatchers, bits);    }        for (Integer wbit : deadWatchers) {        watcherBitIdMap.remove(wbit);    }}
triggerWatch
public WatcherOrBitSet zookeeper_f3530_0(String path, EventType type)
{    return triggerWatch(path, type, null);}
triggerWatch
public WatcherOrBitSet zookeeper_f3531_0(String path, EventType type, WatcherOrBitSet suppress)
{    WatchedEvent e = new WatchedEvent(type, KeeperState.SyncConnected, path);    BitHashSet watchers = remove(path);    if (watchers == null) {        return null;    }    int triggeredWatches = 0;        synchronized (watchers) {        for (Integer wBit : watchers) {            if (suppress != null && suppress.contains(wBit)) {                continue;            }            Watcher w = watcherBitIdMap.get(wBit);                        if (w == null || isDeadWatcher(w)) {                continue;            }            w.process(e);            triggeredWatches++;        }    }    updateMetrics(type, triggeredWatches);    return new WatcherOrBitSet(watchers);}
size
public int zookeeper_f3532_0()
{    int size = 0;    for (BitHashSet watches : pathWatches.values()) {        size += watches.size();    }    return size;}
shutdown
public void zookeeper_f3533_0()
{    if (watcherCleaner != null) {        watcherCleaner.shutdown();    }}
remove
private BitHashSet zookeeper_f3534_0(String path)
{    addRemovePathRWLock.writeLock().lock();    try {        return pathWatches.remove(path);    } finally {        addRemovePathRWLock.writeLock().unlock();    }}
updateMetrics
 void zookeeper_f3535_0(final EventType type, int size)
{    switch(type) {        case NodeCreated:            ServerMetrics.getMetrics().NODE_CREATED_WATCHER.add(size);            break;        case NodeDeleted:            ServerMetrics.getMetrics().NODE_DELETED_WATCHER.add(size);            break;        case NodeDataChanged:            ServerMetrics.getMetrics().NODE_CHANGED_WATCHER.add(size);            break;        case NodeChildrenChanged:            ServerMetrics.getMetrics().NODE_CHILDREN_WATCHER.add(size);            break;        default:                        break;    }}
isDeadWatcher
 boolean zookeeper_f3536_0(Watcher watcher)
{    return watcher instanceof ServerCnxn && ((ServerCnxn) watcher).isStale();}
pathSize
 int zookeeper_f3537_0()
{    return pathWatches.size();}
getWatchesSummary
public WatchesSummary zookeeper_f3538_0()
{    return new WatchesSummary(watcherBitIdMap.size(), pathSize(), size());}
getWatches
public WatchesReport zookeeper_f3539_0()
{    Map<Long, Set<String>> id2paths = new HashMap<Long, Set<String>>();    for (Entry<Watcher, Set<String>> e : getWatcher2PathesMap().entrySet()) {        Long id = ((ServerCnxn) e.getKey()).getSessionId();        Set<String> paths = new HashSet<String>(e.getValue());        id2paths.put(id, paths);    }    return new WatchesReport(id2paths);}
getWatchesByPath
public WatchesPathReport zookeeper_f3540_0()
{    Map<String, Set<Long>> path2ids = new HashMap<String, Set<Long>>();    for (Entry<String, BitHashSet> e : pathWatches.entrySet()) {        BitHashSet watchers = e.getValue();        synchronized (watchers) {            Set<Long> ids = new HashSet<Long>(watchers.size());            path2ids.put(e.getKey(), ids);            for (Integer wbit : watchers) {                Watcher watcher = watcherBitIdMap.get(wbit);                if (watcher instanceof ServerCnxn) {                    ids.add(((ServerCnxn) watcher).getSessionId());                }            }        }    }    return new WatchesPathReport(path2ids);}
getWatcher2PathesMap
public Map<Watcher, Set<String>> zookeeper_f3541_0()
{    Map<Watcher, Set<String>> watcher2paths = new HashMap<Watcher, Set<String>>();    for (Entry<String, BitHashSet> e : pathWatches.entrySet()) {        String path = e.getKey();        BitHashSet watchers = e.getValue();                synchronized (watchers) {            for (Integer wbit : watchers) {                Watcher w = watcherBitIdMap.get(wbit);                if (w == null) {                    continue;                }                if (!watcher2paths.containsKey(w)) {                    watcher2paths.put(w, new HashSet<String>());                }                watcher2paths.get(w).add(path);            }        }    }    return watcher2paths;}
dumpWatches
public void zookeeper_f3542_0(PrintWriter pwriter, boolean byPath)
{    if (byPath) {        for (Entry<String, BitHashSet> e : pathWatches.entrySet()) {            pwriter.println(e.getKey());            BitHashSet watchers = e.getValue();            synchronized (watchers) {                for (Integer wbit : watchers) {                    Watcher w = watcherBitIdMap.get(wbit);                    if (!(w instanceof ServerCnxn)) {                        continue;                    }                    pwriter.print("\t0x");                    pwriter.print(Long.toHexString(((ServerCnxn) w).getSessionId()));                    pwriter.print("\n");                }            }        }    } else {        for (Entry<Watcher, Set<String>> e : getWatcher2PathesMap().entrySet()) {            pwriter.print("0x");            pwriter.println(Long.toHexString(((ServerCnxn) e.getKey()).getSessionId()));            for (String path : e.getValue()) {                pwriter.print("\t");                pwriter.println(path);            }        }    }}
toString
public String zookeeper_f3543_0()
{    StringBuilder sb = new StringBuilder();    sb.append(watcherBitIdMap.size()).append(" connections watching ").append(pathSize()).append(" paths\n");    sb.append("Total watches:").append(size());    return sb.toString();}
cleanup
public void zookeeper_f3544_0()
{}
schedule
public void zookeeper_f3545_0(WorkRequest workRequest)
{    schedule(workRequest, 0);}
schedule
public voidf3546_1WorkRequest workRequest, long id)
{    if (stopped) {        workRequest.cleanup();        return;    }    ScheduledWorkRequest scheduledWorkRequest = new ScheduledWorkRequest(workRequest);            int size = workers.size();    if (size > 0) {        try {                        int workerNum = ((int) (id % size) + size) % size;            ExecutorService worker = workers.get(workerNum);            worker.execute(scheduledWorkRequest);        } catch (RejectedExecutionException e) {                        workRequest.cleanup();        }    } else {                        scheduledWorkRequest.run();    }}
run
public voidf3547_1)
{    try {                if (stopped) {            workRequest.cleanup();            return;        }        workRequest.doWork();    } catch (Exception e) {                workRequest.cleanup();    }}
newThread
public Thread zookeeper_f3548_0(Runnable r)
{    Thread t = new Thread(group, r, namePrefix + threadNumber.getAndIncrement(), 0);    if (!t.isDaemon()) {        t.setDaemon(true);    }    if (t.getPriority() != Thread.NORM_PRIORITY) {        t.setPriority(Thread.NORM_PRIORITY);    }    return t;}
start
public void zookeeper_f3549_0()
{    if (numWorkerThreads > 0) {        if (threadsAreAssignable) {            for (int i = 1; i <= numWorkerThreads; ++i) {                workers.add(Executors.newFixedThreadPool(1, new DaemonThreadFactory(threadNamePrefix, i)));            }        } else {            workers.add(Executors.newFixedThreadPool(numWorkerThreads, new DaemonThreadFactory(threadNamePrefix)));        }    }    stopped = false;}
stop
public void zookeeper_f3550_0()
{    stopped = true;        for (ExecutorService worker : workers) {        worker.shutdown();    }}
join
public void zookeeper_f3551_0(long shutdownTimeoutMS)
{        long now = Time.currentElapsedTime();    long endTime = now + shutdownTimeoutMS;    for (ExecutorService worker : workers) {        boolean terminated = false;        while ((now = Time.currentElapsedTime()) <= endTime) {            try {                terminated = worker.awaitTermination(endTime - now, TimeUnit.MILLISECONDS);                break;            } catch (InterruptedException e) {                        }        }        if (!terminated) {                        worker.shutdownNow();        }    }}
isInitialized
public boolean zookeeper_f3552_0()
{    return initialized;}
clear
public void zookeeper_f3553_0()
{    minCommittedLog = 0;    maxCommittedLog = 0;    /* to be safe we just create a new         * datatree.         */    dataTree.shutdownWatcher();    dataTree = createDataTree();    sessionsWithTimeouts.clear();    WriteLock lock = logLock.writeLock();    try {        lock.lock();        committedLog.clear();    } finally {        lock.unlock();    }    initialized = false;}
getDataTree
public DataTree zookeeper_f3554_0()
{    return this.dataTree;}
getmaxCommittedLog
public long zookeeper_f3555_0()
{    return maxCommittedLog;}
getminCommittedLog
public long zookeeper_f3556_0()
{    return minCommittedLog;}
getLogLock
public ReentrantReadWriteLock zookeeper_f3557_0()
{    return logLock;}
getCommittedLog
public synchronized Collection<Proposal> zookeeper_f3558_0()
{    final Collection<Proposal> result;    ReadLock rl = logLock.readLock();        if (logLock.getReadHoldCount() > 0) {        result = this.committedLog;    } else {        rl.lock();        try {            result = new ArrayList<>(this.committedLog);        } finally {            rl.unlock();        }    }    return Collections.unmodifiableCollection(result);}
getDataTreeLastProcessedZxid
public long zookeeper_f3559_0()
{    return dataTree.lastProcessedZxid;}
getSessions
public Collection<Long> zookeeper_f3560_0()
{    return dataTree.getSessions();}
getSessionCount
public long zookeeper_f3561_0()
{    return sessionsWithTimeouts.size();}
getSessionWithTimeOuts
public ConcurrentHashMap<Long, Integer> zookeeper_f3562_0()
{    return sessionsWithTimeouts;}
onTxnLoaded
public void zookeeper_f3563_0(TxnHeader hdr, Record txn)
{    addCommittedProposal(hdr, txn);}
loadDataBase
public longf3564_1) throws IOException
{    long startTime = Time.currentElapsedTime();    long zxid = snapLog.restore(dataTree, sessionsWithTimeouts, commitProposalPlaybackListener);    initialized = true;    long loadTime = Time.currentElapsedTime() - startTime;    ServerMetrics.getMetrics().DB_INIT_TIME.add(loadTime);        return zxid;}
fastForwardDataBase
public long zookeeper_f3565_0() throws IOException
{    long zxid = snapLog.fastForwardFromEdits(dataTree, sessionsWithTimeouts, commitProposalPlaybackListener);    initialized = true;    return zxid;}
addCommittedProposal
private void zookeeper_f3566_0(TxnHeader hdr, Record txn)
{    Request r = new Request(0, hdr.getCxid(), hdr.getType(), hdr, txn, hdr.getZxid());    addCommittedProposal(r);}
addCommittedProposal
public void zookeeper_f3567_0(Request request)
{    WriteLock wl = logLock.writeLock();    try {        wl.lock();        if (committedLog.size() > commitLogCount) {            committedLog.remove();            minCommittedLog = committedLog.peek().packet.getZxid();        }        if (committedLog.isEmpty()) {            minCommittedLog = request.zxid;            maxCommittedLog = request.zxid;        }        byte[] data = SerializeUtils.serializeRequest(request);        QuorumPacket pp = new QuorumPacket(Leader.PROPOSAL, request.zxid, data, null);        Proposal p = new Proposal();        p.packet = pp;        p.request = request;        committedLog.add(p);        maxCommittedLog = p.packet.getZxid();    } finally {        wl.unlock();    }}
isTxnLogSyncEnabled
public booleanf3568_1)
{    boolean enabled = snapshotSizeFactor >= 0;    if (enabled) {            } else {            }    return enabled;}
calculateTxnLogSizeLimit
public longf3569_1)
{    long snapSize = 0;    try {        File snapFile = snapLog.findMostRecentSnapshot();        if (snapFile != null) {            snapSize = snapFile.length();        }    } catch (IOException e) {            }    return (long) (snapSize * snapshotSizeFactor);}
getProposalsFromTxnLog
public Iterator<Proposal>f3570_1long startZxid, long sizeLimit)
{    if (sizeLimit < 0) {                return TxnLogProposalIterator.EMPTY_ITERATOR;    }    TxnIterator itr = null;    try {        itr = snapLog.readTxnLog(startZxid, false);                if ((itr.getHeader() != null) && (itr.getHeader().getZxid() > startZxid)) {                        itr.close();            return TxnLogProposalIterator.EMPTY_ITERATOR;        }        if (sizeLimit > 0) {            long txnSize = itr.getStorageSize();            if (txnSize > sizeLimit) {                                itr.close();                return TxnLogProposalIterator.EMPTY_ITERATOR;            }        }    } catch (IOException e) {                try {            if (itr != null) {                itr.close();            }        } catch (IOException ioe) {                    }        return TxnLogProposalIterator.EMPTY_ITERATOR;    }    return new TxnLogProposalIterator(itr);}
aclForNode
public List<ACL> zookeeper_f3571_0(DataNode n)
{    return dataTree.getACL(n);}
removeCnxn
public void zookeeper_f3572_0(ServerCnxn cnxn)
{    dataTree.removeCnxn(cnxn);}
killSession
public void zookeeper_f3573_0(long sessionId, long zxid)
{    dataTree.killSession(sessionId, zxid);}
dumpEphemerals
public void zookeeper_f3574_0(PrintWriter pwriter)
{    dataTree.dumpEphemerals(pwriter);}
getEphemerals
public Map<Long, Set<String>> zookeeper_f3575_0()
{    return dataTree.getEphemerals();}
getNodeCount
public int zookeeper_f3576_0()
{    return dataTree.getNodeCount();}
getEphemerals
public Set<String> zookeeper_f3577_0(long sessionId)
{    return dataTree.getEphemerals(sessionId);}
setlastProcessedZxid
public void zookeeper_f3578_0(long zxid)
{    dataTree.lastProcessedZxid = zxid;}
processTxn
public ProcessTxnResult zookeeper_f3579_0(TxnHeader hdr, Record txn)
{    return dataTree.processTxn(hdr, txn);}
statNode
public Stat zookeeper_f3580_0(String path, ServerCnxn serverCnxn) throws KeeperException.NoNodeException
{    return dataTree.statNode(path, serverCnxn);}
getNode
public DataNode zookeeper_f3581_0(String path)
{    return dataTree.getNode(path);}
getData
public byte[] zookeeper_f3582_0(String path, Stat stat, Watcher watcher) throws KeeperException.NoNodeException
{    return dataTree.getData(path, stat, watcher);}
setWatches
public void zookeeper_f3583_0(long relativeZxid, List<String> dataWatches, List<String> existWatches, List<String> childWatches, Watcher watcher)
{    dataTree.setWatches(relativeZxid, dataWatches, existWatches, childWatches, watcher);}
getACL
public List<ACL> zookeeper_f3584_0(String path, Stat stat) throws NoNodeException
{    return dataTree.getACL(path, stat);}
getChildren
public List<String> zookeeper_f3585_0(String path, Stat stat, Watcher watcher) throws KeeperException.NoNodeException
{    return dataTree.getChildren(path, stat, watcher);}
getAllChildrenNumber
public int zookeeper_f3586_0(String path) throws KeeperException.NoNodeException
{    return dataTree.getAllChildrenNumber(path);}
isSpecialPath
public boolean zookeeper_f3587_0(String path)
{    return dataTree.isSpecialPath(path);}
getAclSize
public int zookeeper_f3588_0()
{    return dataTree.aclCacheSize();}
truncateLog
public boolean zookeeper_f3589_0(long zxid) throws IOException
{    clear();        boolean truncated = snapLog.truncateLog(zxid);    if (!truncated) {        return false;    }    loadDataBase();    return true;}
deserializeSnapshot
public void zookeeper_f3590_0(InputArchive ia) throws IOException
{    clear();    SerializeUtils.deserializeSnapshot(getDataTree(), ia, getSessionWithTimeOuts());    initialized = true;}
serializeSnapshot
public void zookeeper_f3591_0(OutputArchive oa) throws IOException, InterruptedException
{    SerializeUtils.serializeSnapshot(getDataTree(), oa, getSessionWithTimeOuts());}
append
public boolean zookeeper_f3592_0(Request si) throws IOException
{    txnCount.incrementAndGet();    return this.snapLog.append(si);}
rollLog
public void zookeeper_f3593_0() throws IOException
{    this.snapLog.rollLog();    resetTxnCount();}
commit
public void zookeeper_f3594_0() throws IOException
{    this.snapLog.commit();}
close
public void zookeeper_f3595_0() throws IOException
{    this.snapLog.close();}
initConfigInZKDatabase
public synchronized voidf3596_1QuorumVerifier qv)
{    if (qv == null) {                return;    }    try {        if (this.dataTree.getNode(ZooDefs.CONFIG_NODE) == null) {                                    this.dataTree.addConfigNode();        }        this.dataTree.setData(ZooDefs.CONFIG_NODE, qv.toString().getBytes(), -1, qv.getVersion(), Time.currentWallTime());    } catch (NoNodeException e) {        System.out.println("configuration node missing - should not happen");    }}
setSnapshotSizeFactor
public void zookeeper_f3597_0(double snapshotSizeFactor)
{    this.snapshotSizeFactor = snapshotSizeFactor;}
containsWatcher
public boolean zookeeper_f3598_0(String path, WatcherType type, Watcher watcher)
{    return dataTree.containsWatcher(path, type, watcher);}
removeWatch
public boolean zookeeper_f3599_0(String path, WatcherType type, Watcher watcher)
{    return dataTree.removeWatch(path, type, watcher);}
createDataTree
public DataTree zookeeper_f3600_0()
{    return new DataTree();}
resetTxnCount
public void zookeeper_f3601_0()
{    txnCount.set(0);    snapLog.setTotalLogSize(0);}
getTxnCount
public int zookeeper_f3602_0()
{    return txnCount.get();}
getTxnSize
public long zookeeper_f3603_0()
{    return snapLog.getTotalLogSize();}
handleException
protected voidf3604_1String threadName, Throwable e)
{        listener.notifyStopping(threadName, ExitCode.UNEXPECTED_ERROR.getValue());    ServerMetrics.getMetrics().UNRECOVERABLE_ERROR_COUNT.add(1);}
createSaslServer
private SaslServer zookeeper_f3605_0(final Login login)
{    synchronized (login) {        Subject subject = login.getSubject();        return SecurityUtils.createSaslServer(subject, "zookeeper", "zk-sasl-md5", login.callbackHandler, LOG);    }}
evaluateResponse
public byte[] zookeeper_f3606_0(byte[] response) throws SaslException
{    return saslServer.evaluateResponse(response);}
isComplete
public boolean zookeeper_f3607_0()
{    return saslServer.isComplete();}
getAuthorizationID
public String zookeeper_f3608_0()
{    return saslServer.getAuthorizationID();}
isCloseSessionTxnEnabled
public static boolean zookeeper_f3609_0()
{    return closeSessionTxnEnabled;}
setCloseSessionTxnEnabled
public static voidf3610_1boolean enabled)
{    ZooKeeperServer.closeSessionTxnEnabled = enabled;    }
removeCnxn
 void zookeeper_f3611_0(ServerCnxn cnxn)
{    zkDb.removeCnxn(cnxn);}
getInitialConfig
public String zookeeper_f3612_0()
{    return initialConfig;}
serverStats
public ServerStats zookeeper_f3613_0()
{    return serverStats;}
getRequestPathMetricsCollector
public RequestPathMetricsCollector zookeeper_f3614_0()
{    return requestPathMetricsCollector;}
connThrottle
public BlueThrottle zookeeper_f3615_0()
{    return connThrottle;}
dumpConf
public void zookeeper_f3616_0(PrintWriter pwriter)
{    pwriter.print("clientPort=");    pwriter.println(getClientPort());    pwriter.print("secureClientPort=");    pwriter.println(getSecureClientPort());    pwriter.print("dataDir=");    pwriter.println(zkDb.snapLog.getSnapDir().getAbsolutePath());    pwriter.print("dataDirSize=");    pwriter.println(getDataDirSize());    pwriter.print("dataLogDir=");    pwriter.println(zkDb.snapLog.getDataDir().getAbsolutePath());    pwriter.print("dataLogSize=");    pwriter.println(getLogDirSize());    pwriter.print("tickTime=");    pwriter.println(getTickTime());    pwriter.print("maxClientCnxns=");    pwriter.println(getMaxClientCnxnsPerHost());    pwriter.print("minSessionTimeout=");    pwriter.println(getMinSessionTimeout());    pwriter.print("maxSessionTimeout=");    pwriter.println(getMaxSessionTimeout());    pwriter.print("clientPortListenBacklog=");    pwriter.println(getClientPortListenBacklog());    pwriter.print("serverId=");    pwriter.println(getServerId());}
getConf
public ZooKeeperServerConf zookeeper_f3617_0()
{    return new ZooKeeperServerConf(getClientPort(), zkDb.snapLog.getSnapDir().getAbsolutePath(), zkDb.snapLog.getDataDir().getAbsolutePath(), getTickTime(), serverCnxnFactory.getMaxClientCnxnsPerHost(), getMinSessionTimeout(), getMaxSessionTimeout(), getServerId(), getClientPortListenBacklog());}
getZKDatabase
public ZKDatabase zookeeper_f3618_0()
{    return this.zkDb;}
setZKDatabase
public void zookeeper_f3619_0(ZKDatabase zkDb)
{    this.zkDb = zkDb;}
loadData
public void zookeeper_f3620_0() throws IOException, InterruptedException
{    /*         * When a new leader starts executing Leader#lead, it         * invokes this method. The database, however, has been         * initialized before running leader election so that         * the server could pick its zxid for its initial vote.         * It does it by invoking QuorumPeer#getLastLoggedZxid.         * Consequently, we don't need to initialize it once more         * and avoid the penalty of loading it a second time. Not         * reloading it is particularly important for applications         * that host a large database.         *         * The following if block checks whether the database has         * been initialized or not. Note that this method is         * invoked by at least one other method:         * ZooKeeperServer#startdata.         *         * See ZOOKEEPER-1642 for more detail.         */    if (zkDb.isInitialized()) {        setZxid(zkDb.getDataTreeLastProcessedZxid());    } else {        setZxid(zkDb.loadDataBase());    }        List<Long> deadSessions = new ArrayList<>();    for (Long session : zkDb.getSessions()) {        if (zkDb.getSessionWithTimeOuts().get(session) == null) {            deadSessions.add(session);        }    }    for (long session : deadSessions) {                killSession(session, zkDb.getDataTreeLastProcessedZxid());    }        takeSnapshot();}
takeSnapshot
public void zookeeper_f3621_0()
{    takeSnapshot(false);}
takeSnapshot
public voidf3622_1boolean syncSnap)
{    long start = Time.currentElapsedTime();    try {        txnLogFactory.save(zkDb.getDataTree(), zkDb.getSessionWithTimeOuts(), syncSnap);    } catch (IOException e) {                                System.exit(ExitCode.TXNLOG_ERROR_TAKING_SNAPSHOT.getValue());    }    long elapsed = Time.currentElapsedTime() - start;        ServerMetrics.getMetrics().SNAPSHOT_TIME.add(elapsed);}
getDataDirSize
public long zookeeper_f3623_0()
{    if (zkDb == null) {        return 0L;    }    File path = zkDb.snapLog.getDataDir();    return getDirSize(path);}
getLogDirSize
public long zookeeper_f3624_0()
{    if (zkDb == null) {        return 0L;    }    File path = zkDb.snapLog.getSnapDir();    return getDirSize(path);}
getDirSize
private long zookeeper_f3625_0(File file)
{    long size = 0L;    if (file.isDirectory()) {        File[] files = file.listFiles();        if (files != null) {            for (File f : files) {                size += getDirSize(f);            }        }    } else {        size = file.length();    }    return size;}
getZxid
public long zookeeper_f3626_0()
{    return hzxid.get();}
getSessionTracker
public SessionTracker zookeeper_f3627_0()
{    return sessionTracker;}
getNextZxid
 long zookeeper_f3628_0()
{    return hzxid.incrementAndGet();}
setZxid
public void zookeeper_f3629_0(long zxid)
{    hzxid.set(zxid);}
close
private void zookeeper_f3630_0(long sessionId)
{    Request si = new Request(null, sessionId, 0, OpCode.closeSession, null, null);    setLocalSessionFlag(si);    submitRequest(si);}
closeSession
public voidf3631_1long sessionId)
{                close(sessionId);}
killSession
protected void zookeeper_f3632_0(long sessionId, long zxid)
{    zkDb.killSession(sessionId, zxid);    if (LOG.isTraceEnabled()) {        ZooTrace.logTraceMessage(LOG, ZooTrace.SESSION_TRACE_MASK, "ZooKeeperServer --- killSession: 0x" + Long.toHexString(sessionId));    }    if (sessionTracker != null) {        sessionTracker.removeSession(sessionId);    }}
expire
public voidf3633_1Session session)
{    long sessionId = session.getSessionId();        close(sessionId);}
touch
 void zookeeper_f3634_0(ServerCnxn cnxn) throws MissingSessionException
{    if (cnxn == null) {        return;    }    long id = cnxn.getSessionId();    int to = cnxn.getSessionTimeout();    if (!sessionTracker.touchSession(id, to)) {        throw new MissingSessionException("No session with sessionid 0x" + Long.toHexString(id) + " exists, probably expired and removed");    }}
registerJMX
protected voidf3635_1)
{        try {        jmxServerBean = new ZooKeeperServerBean(this);        MBeanRegistry.getInstance().register(jmxServerBean, null);        try {            jmxDataTreeBean = new DataTreeBean(zkDb.getDataTree());            MBeanRegistry.getInstance().register(jmxDataTreeBean, jmxServerBean);        } catch (Exception e) {                        jmxDataTreeBean = null;        }    } catch (Exception e) {                jmxServerBean = null;    }}
startdata
public void zookeeper_f3636_0() throws IOException, InterruptedException
{        if (zkDb == null) {        zkDb = new ZKDatabase(this.txnLogFactory);    }    if (!zkDb.isInitialized()) {        loadData();    }}
startup
public synchronized void zookeeper_f3637_0()
{    if (sessionTracker == null) {        createSessionTracker();    }    startSessionTracker();    setupRequestProcessors();    startRequestThrottler();    registerJMX();    startJvmPauseMonitor();    registerMetrics();    setState(State.RUNNING);    requestPathMetricsCollector.start();    localSessionEnabled = sessionTracker.isLocalSessionsEnabled();    notifyAll();}
startJvmPauseMonitor
protected void zookeeper_f3638_0()
{    if (this.jvmPauseMonitor != null) {        this.jvmPauseMonitor.serviceStart();    }}
startRequestThrottler
protected void zookeeper_f3639_0()
{    requestThrottler = new RequestThrottler(this);    requestThrottler.start();}
setupRequestProcessors
protected void zookeeper_f3640_0()
{    RequestProcessor finalProcessor = new FinalRequestProcessor(this);    RequestProcessor syncProcessor = new SyncRequestProcessor(this, finalProcessor);    ((SyncRequestProcessor) syncProcessor).start();    firstProcessor = new PrepRequestProcessor(this, syncProcessor);    ((PrepRequestProcessor) firstProcessor).start();}
getZooKeeperServerListener
public ZooKeeperServerListener zookeeper_f3641_0()
{    return listener;}
setCreateSessionTrackerServerId
public void zookeeper_f3642_0(int newId)
{    createSessionTrackerServerId = newId;}
createSessionTracker
protected void zookeeper_f3643_0()
{    sessionTracker = new SessionTrackerImpl(this, zkDb.getSessionWithTimeOuts(), tickTime, createSessionTrackerServerId, getZooKeeperServerListener());}
startSessionTracker
protected void zookeeper_f3644_0()
{    ((SessionTrackerImpl) sessionTracker).start();}
setState
protected voidf3645_1State state)
{    this.state = state;        if (zkShutdownHandler != null) {        zkShutdownHandler.handle(state);    } else {            }}
canShutdown
protected boolean zookeeper_f3646_0()
{    return state == State.RUNNING || state == State.ERROR;}
isRunning
public boolean zookeeper_f3647_0()
{    return state == State.RUNNING;}
shutdown
public void zookeeper_f3648_0()
{    shutdown(false);}
shutdown
public synchronized voidf3649_1boolean fullyShutDown)
{    if (!canShutdown()) {                return;    }            setState(State.SHUTDOWN);            unregisterMetrics();    if (requestThrottler != null) {        requestThrottler.shutdown();    }        if (sessionTracker != null) {        sessionTracker.shutdown();    }    if (firstProcessor != null) {        firstProcessor.shutdown();    }    if (jvmPauseMonitor != null) {        jvmPauseMonitor.serviceStop();    }    if (zkDb != null) {        if (fullyShutDown) {            zkDb.clear();        } else {                        try {                                zkDb.fastForwardDataBase();            } catch (IOException e) {                                zkDb.clear();            }        }    }    requestPathMetricsCollector.shutdown();    unregisterJMX();}
unregisterJMX
protected voidf3650_1)
{        try {        if (jmxDataTreeBean != null) {            MBeanRegistry.getInstance().unregister(jmxDataTreeBean);        }    } catch (Exception e) {            }    try {        if (jmxServerBean != null) {            MBeanRegistry.getInstance().unregister(jmxServerBean);        }    } catch (Exception e) {            }    jmxServerBean = null;    jmxDataTreeBean = null;}
incInProcess
public void zookeeper_f3651_0()
{    requestsInProcess.incrementAndGet();}
decInProcess
public void zookeeper_f3652_0()
{    requestsInProcess.decrementAndGet();    if (requestThrottler != null) {        requestThrottler.throttleWake();    }}
getInProcess
public int zookeeper_f3653_0()
{    return requestsInProcess.get();}
getInflight
public int zookeeper_f3654_0()
{    return requestThrottleInflight();}
requestThrottleInflight
private int zookeeper_f3655_0()
{    if (requestThrottler != null) {        return requestThrottler.getInflight();    }    return 0;}
duplicate
 ChangeRecord zookeeper_f3656_0(long zxid)
{    StatPersisted stat = new StatPersisted();    if (this.stat != null) {        DataTree.copyStatPersisted(this.stat, stat);    }    return new ChangeRecord(zxid, path, stat, childCount, acl == null ? new ArrayList<>() : new ArrayList<>(acl));}
generatePasswd
 byte[] zookeeper_f3657_0(long id)
{    Random r = new Random(id ^ superSecret);    byte[] p = new byte[16];    r.nextBytes(p);    return p;}
checkPasswd
protected boolean zookeeper_f3658_0(long sessionId, byte[] passwd)
{    return sessionId != 0 && Arrays.equals(passwd, generatePasswd(sessionId));}
createSession
 long zookeeper_f3659_0(ServerCnxn cnxn, byte[] passwd, int timeout)
{    if (passwd == null) {                passwd = new byte[0];    }    long sessionId = sessionTracker.createSession(timeout);    Random r = new Random(sessionId ^ superSecret);    r.nextBytes(passwd);    ByteBuffer to = ByteBuffer.allocate(4);    to.putInt(timeout);    cnxn.setSessionId(sessionId);    Request si = new Request(cnxn, sessionId, 0, OpCode.createSession, to, null);    setLocalSessionFlag(si);    submitRequest(si);    return sessionId;}
setOwner
public void zookeeper_f3660_0(long id, Object owner) throws SessionExpiredException
{    sessionTracker.setOwner(id, owner);}
revalidateSession
protected void zookeeper_f3661_0(ServerCnxn cnxn, long sessionId, int sessionTimeout) throws IOException
{    boolean rc = sessionTracker.touchSession(sessionId, sessionTimeout);    if (LOG.isTraceEnabled()) {        ZooTrace.logTraceMessage(LOG, ZooTrace.SESSION_TRACE_MASK, "Session 0x" + Long.toHexString(sessionId) + " is valid: " + rc);    }    finishSessionInit(cnxn, rc);}
reopenSession
public voidf3662_1ServerCnxn cnxn, long sessionId, byte[] passwd, int sessionTimeout) throws IOException
{    if (checkPasswd(sessionId, passwd)) {        revalidateSession(cnxn, sessionId, sessionTimeout);    } else {                finishSessionInit(cnxn, false);    }}
finishSessionInit
public voidf3663_1ServerCnxn cnxn, boolean valid)
{        try {        if (valid) {            if (serverCnxnFactory != null && serverCnxnFactory.cnxns.contains(cnxn)) {                serverCnxnFactory.registerConnection(cnxn);            } else if (secureServerCnxnFactory != null && secureServerCnxnFactory.cnxns.contains(cnxn)) {                secureServerCnxnFactory.registerConnection(cnxn);            }        }    } catch (Exception e) {            }    try {        ConnectResponse rsp = new ConnectResponse(0, valid ? cnxn.getSessionTimeout() : 0,         valid ? cnxn.getSessionId() : 0,         valid ? generatePasswd(cnxn.getSessionId()) : new byte[16]);        ByteArrayOutputStream baos = new ByteArrayOutputStream();        BinaryOutputArchive bos = BinaryOutputArchive.getArchive(baos);        bos.writeInt(-1, "len");        rsp.serialize(bos, "connect");        if (!cnxn.isOldClient) {            bos.writeBool(this instanceof ReadOnlyZooKeeperServer, "readOnly");        }        baos.close();        ByteBuffer bb = ByteBuffer.wrap(baos.toByteArray());        bb.putInt(bb.remaining() - 4).rewind();        cnxn.sendBuffer(bb);        if (valid) {            if (LOG.isDebugEnabled()) {                            }            cnxn.enableRecv();        } else {                        cnxn.sendBuffer(ServerCnxnFactory.closeConn);        }    } catch (Exception e) {                cnxn.close(ServerCnxn.DisconnectReason.IO_EXCEPTION_IN_SESSION_INIT);    }}
closeSession
public void zookeeper_f3664_0(ServerCnxn cnxn, RequestHeader requestHeader)
{    closeSession(cnxn.getSessionId());}
getServerId
public long zookeeper_f3665_0()
{    return 0;}
setLocalSessionFlag
protected void zookeeper_f3666_0(Request si)
{}
submitRequest
public void zookeeper_f3667_0(Request si)
{    enqueueRequest(si);}
enqueueRequest
public voidf3668_1Request si)
{    if (requestThrottler == null) {        synchronized (this) {            try {                                while (state == State.INITIAL) {                    wait(1000);                }            } catch (InterruptedException e) {                            }            if (requestThrottler == null) {                throw new RuntimeException("Not started");            }        }    }    requestThrottler.submitRequest(si);}
submitRequestNow
public voidf3669_1Request si)
{    if (firstProcessor == null) {        synchronized (this) {            try {                                while (state == State.INITIAL) {                    wait(1000);                }            } catch (InterruptedException e) {                            }            if (firstProcessor == null || state != State.RUNNING) {                throw new RuntimeException("Not started");            }        }    }    try {        touch(si.cnxn);        boolean validpacket = Request.isValid(si.type);        if (validpacket) {            firstProcessor.processRequest(si);            if (si.cnxn != null) {                incInProcess();            }        } else {                                    requestFinished(si);            new UnimplementedRequestProcessor().processRequest(si);        }    } catch (MissingSessionException e) {        if (LOG.isDebugEnabled()) {                    }                requestFinished(si);    } catch (RequestProcessorException e) {                        requestFinished(si);    }}
getSnapCount
public static intf3670_1)
{    String sc = System.getProperty(SNAP_COUNT);    try {        int snapCount = Integer.parseInt(sc);                if (snapCount < 2) {                        snapCount = 2;        }        return snapCount;    } catch (Exception e) {        return 100000;    }}
getGlobalOutstandingLimit
public int zookeeper_f3671_0()
{    String sc = System.getProperty(GLOBAL_OUTSTANDING_LIMIT);    int limit;    try {        limit = Integer.parseInt(sc);    } catch (Exception e) {        limit = 1000;    }    return limit;}
setServerCnxnFactory
public void zookeeper_f3673_0(ServerCnxnFactory factory)
{    serverCnxnFactory = factory;}
getServerCnxnFactory
public ServerCnxnFactory zookeeper_f3674_0()
{    return serverCnxnFactory;}
getSecureServerCnxnFactory
public ServerCnxnFactory zookeeper_f3675_0()
{    return secureServerCnxnFactory;}
setSecureServerCnxnFactory
public void zookeeper_f3676_0(ServerCnxnFactory factory)
{    secureServerCnxnFactory = factory;}
getLastProcessedZxid
public long zookeeper_f3677_0()
{    return zkDb.getDataTreeLastProcessedZxid();}
getOutstandingRequests
public long zookeeper_f3678_0()
{    return getInProcess();}
getNumAliveConnections
public int zookeeper_f3679_0()
{    int numAliveConnections = 0;    if (serverCnxnFactory != null) {        numAliveConnections += serverCnxnFactory.getNumAliveConnections();    }    if (secureServerCnxnFactory != null) {        numAliveConnections += secureServerCnxnFactory.getNumAliveConnections();    }    return numAliveConnections;}
truncateLog
public void zookeeper_f3680_0(long zxid) throws IOException
{    this.zkDb.truncateLog(zxid);}
getTickTime
public int zookeeper_f3681_0()
{    return tickTime;}
setTickTime
public voidf3682_1int tickTime)
{        this.tickTime = tickTime;}
getMinSessionTimeout
public int zookeeper_f3683_0()
{    return minSessionTimeout;}
setMinSessionTimeout
public voidf3684_1int min)
{    this.minSessionTimeout = min == -1 ? tickTime * 2 : min;    }
getMaxSessionTimeout
public int zookeeper_f3685_0()
{    return maxSessionTimeout;}
setMaxSessionTimeout
public voidf3686_1int max)
{    this.maxSessionTimeout = max == -1 ? tickTime * 20 : max;    }
getClientPortListenBacklog
public int zookeeper_f3687_0()
{    return listenBacklog;}
setClientPortListenBacklog
public voidf3688_1int backlog)
{    this.listenBacklog = backlog;    }
getClientPort
public int zookeeper_f3689_0()
{    return serverCnxnFactory != null ? serverCnxnFactory.getLocalPort() : -1;}
getSecureClientPort
public int zookeeper_f3690_0()
{    return secureServerCnxnFactory != null ? secureServerCnxnFactory.getLocalPort() : -1;}
getMaxClientCnxnsPerHost
public int zookeeper_f3691_0()
{    if (serverCnxnFactory != null) {        return serverCnxnFactory.getMaxClientCnxnsPerHost();    }    if (secureServerCnxnFactory != null) {        return secureServerCnxnFactory.getMaxClientCnxnsPerHost();    }    return -1;}
setTxnLogFactory
public void zookeeper_f3692_0(FileTxnSnapLog txnLog)
{    this.txnLogFactory = txnLog;}
getTxnLogFactory
public FileTxnSnapLog zookeeper_f3693_0()
{    return this.txnLogFactory;}
getTxnLogElapsedSyncTime
public long zookeeper_f3694_0()
{    return txnLogFactory.getTxnLogElapsedSyncTime();}
getState
public String zookeeper_f3695_0()
{    return "standalone";}
dumpEphemerals
public void zookeeper_f3696_0(PrintWriter pwriter)
{    zkDb.dumpEphemerals(pwriter);}
getEphemerals
public Map<Long, Set<String>> zookeeper_f3697_0()
{    return zkDb.getEphemerals();}
getConnectionDropChance
public double zookeeper_f3698_0()
{    return connThrottle.getDropChance();}
shouldThrottle
public boolean zookeeper_f3700_0(long outStandingCount)
{    if (getGlobalOutstandingLimit() < getInflight()) {        return outStandingCount > 0;    }    return false;}
getFlushDelay
 long zookeeper_f3701_0()
{    return flushDelay;}
setFlushDelay
 static voidf3702_1long delay)
{        flushDelay = delay;}
getMaxWriteQueuePollTime
 long zookeeper_f3703_0()
{    return maxWriteQueuePollTime;}
setMaxWriteQueuePollTime
 static voidf3704_1long maxTime)
{        maxWriteQueuePollTime = maxTime;}
getMaxBatchSize
 int zookeeper_f3705_0()
{    return maxBatchSize;}
setMaxBatchSize
 static voidf3706_1int size)
{        maxBatchSize = size;}
initLargeRequestThrottlingSettings
private void zookeeper_f3707_0()
{    setLargeRequestMaxBytes(Integer.getInteger("zookeeper.largeRequestMaxBytes", largeRequestMaxBytes));    setLargeRequestThreshold(Integer.getInteger("zookeeper.largeRequestThreshold", -1));}
getLargeRequestMaxBytes
public int zookeeper_f3708_0()
{    return largeRequestMaxBytes;}
setLargeRequestMaxBytes
public voidf3709_1int bytes)
{    if (bytes <= 0) {                    } else {        largeRequestMaxBytes = bytes;            }}
getLargeRequestThreshold
public int zookeeper_f3710_0()
{    return largeRequestThreshold;}
setLargeRequestThreshold
public voidf3711_1int threshold)
{    if (threshold == 0 || threshold < -1) {                largeRequestThreshold = -1;    } else {        largeRequestThreshold = threshold;            }}
getLargeRequestBytes
public int zookeeper_f3712_0()
{    return currentLargeRequestBytes.get();}
isLargeRequest
private boolean zookeeper_f3713_0(int length)
{        if (largeRequestThreshold == -1) {        return false;    }    return length > largeRequestThreshold;}
checkRequestSizeWhenReceivingMessage
public boolean zookeeper_f3714_0(int length) throws IOException
{    if (!isLargeRequest(length)) {        return true;    }    if (currentLargeRequestBytes.get() + length <= largeRequestMaxBytes) {        return true;    } else {        ServerMetrics.getMetrics().LARGE_REQUESTS_REJECTED.add(1);        throw new IOException("Rejecting large request");    }}
checkRequestSizeWhenMessageReceived
private boolean zookeeper_f3715_0(int length) throws IOException
{    if (!isLargeRequest(length)) {        return true;    }    int bytes = currentLargeRequestBytes.addAndGet(length);    if (bytes > largeRequestMaxBytes) {        currentLargeRequestBytes.addAndGet(-length);        ServerMetrics.getMetrics().LARGE_REQUESTS_REJECTED.add(1);        throw new IOException("Rejecting large request");    }    return true;}
requestFinished
public void zookeeper_f3716_0(Request request)
{    int largeRequestLength = request.getLargeRequestSize();    if (largeRequestLength != -1) {        currentLargeRequestBytes.addAndGet(-largeRequestLength);    }}
processPacket
public voidf3717_1ServerCnxn cnxn, ByteBuffer incomingBuffer) throws IOException
{        InputStream bais = new ByteBufferInputStream(incomingBuffer);    BinaryInputArchive bia = BinaryInputArchive.getArchive(bais);    RequestHeader h = new RequestHeader();    h.deserialize(bia, "header");                                        cnxn.incrOutstandingAndCheckThrottle(h);                incomingBuffer = incomingBuffer.slice();    if (h.getType() == OpCode.auth) {                AuthPacket authPacket = new AuthPacket();        ByteBufferInputStream.byteBuffer2Record(incomingBuffer, authPacket);        String scheme = authPacket.getScheme();        ServerAuthenticationProvider ap = ProviderRegistry.getServerProvider(scheme);        Code authReturn = KeeperException.Code.AUTHFAILED;        if (ap != null) {            try {                                                authReturn = ap.handleAuthentication(new ServerAuthenticationProvider.ServerObjs(this, cnxn), authPacket.getAuth());            } catch (RuntimeException e) {                                authReturn = KeeperException.Code.AUTHFAILED;            }        }        if (authReturn == KeeperException.Code.OK) {                                    ReplyHeader rh = new ReplyHeader(h.getXid(), 0, KeeperException.Code.OK.intValue());            cnxn.sendResponse(rh, null, null);        } else {            if (ap == null) {                            } else {                            }                        ReplyHeader rh = new ReplyHeader(h.getXid(), 0, KeeperException.Code.AUTHFAILED.intValue());            cnxn.sendResponse(rh, null, null);                        cnxn.sendBuffer(ServerCnxnFactory.closeConn);            cnxn.disableRecv();        }        return;    } else if (h.getType() == OpCode.sasl) {        processSasl(incomingBuffer, cnxn, h);    } else {        if (shouldRequireClientSaslAuth() && !hasCnxSASLAuthenticated(cnxn)) {            ReplyHeader replyHeader = new ReplyHeader(h.getXid(), 0, Code.SESSIONCLOSEDREQUIRESASLAUTH.intValue());            cnxn.sendResponse(replyHeader, null, "response");            cnxn.sendCloseSession();            cnxn.disableRecv();        } else {            Request si = new Request(cnxn, cnxn.getSessionId(), h.getXid(), h.getType(), incomingBuffer, cnxn.getAuthInfo());            int length = incomingBuffer.limit();            if (isLargeRequest(length)) {                                checkRequestSizeWhenMessageReceived(length);                si.setLargeRequestSize(length);            }            si.setOwner(ServerCnxn.me);                                    setLocalSessionFlag(si);            submitRequest(si);        }    }}
shouldAllowSaslFailedClientsConnect
private static boolean zookeeper_f3718_0()
{    return Boolean.getBoolean(ALLOW_SASL_FAILED_CLIENTS);}
shouldRequireClientSaslAuth
private static boolean zookeeper_f3719_0()
{    return Boolean.getBoolean(SESSION_REQUIRE_CLIENT_SASL_AUTH);}
hasCnxSASLAuthenticated
private boolean zookeeper_f3720_0(ServerCnxn cnxn)
{    for (Id id : cnxn.getAuthInfo()) {        if (id.getScheme().equals(SASL_AUTH_SCHEME)) {            return true;        }    }    return false;}
processSasl
private voidf3721_1ByteBuffer incomingBuffer, ServerCnxn cnxn, RequestHeader requestHeader) throws IOException
{        GetSASLRequest clientTokenRecord = new GetSASLRequest();    ByteBufferInputStream.byteBuffer2Record(incomingBuffer, clientTokenRecord);    byte[] clientToken = clientTokenRecord.getToken();        byte[] responseToken = null;    try {        ZooKeeperSaslServer saslServer = cnxn.zooKeeperSaslServer;        try {                                                responseToken = saslServer.evaluateResponse(clientToken);            if (saslServer.isComplete()) {                String authorizationID = saslServer.getAuthorizationID();                                cnxn.addAuthInfo(new Id("sasl", authorizationID));                if (System.getProperty("zookeeper.superUser") != null && authorizationID.equals(System.getProperty("zookeeper.superUser"))) {                    cnxn.addAuthInfo(new Id("super", ""));                }            }        } catch (SaslException e) {                        if (shouldAllowSaslFailedClientsConnect() && !shouldRequireClientSaslAuth()) {                            } else {                int error;                if (shouldRequireClientSaslAuth()) {                                        error = Code.SESSIONCLOSEDREQUIRESASLAUTH.intValue();                } else {                                        error = Code.AUTHFAILED.intValue();                }                ReplyHeader replyHeader = new ReplyHeader(requestHeader.getXid(), 0, error);                cnxn.sendResponse(replyHeader, new SetSASLResponse(null), "response");                cnxn.sendCloseSession();                cnxn.disableRecv();                return;            }        }    } catch (NullPointerException e) {            }    if (responseToken != null) {            }    ReplyHeader replyHeader = new ReplyHeader(requestHeader.getXid(), 0, Code.OK.intValue());    Record record = new SetSASLResponse(responseToken);    cnxn.sendResponse(replyHeader, record, "response");}
processTxn
public ProcessTxnResult zookeeper_f3722_0(TxnHeader hdr, Record txn)
{    processTxnForSessionEvents(null, hdr, txn);    return processTxnInDB(hdr, txn);}
processTxn
public ProcessTxnResultf3723_1Request request)
{    TxnHeader hdr = request.getHdr();    processTxnForSessionEvents(request, hdr, request.getTxn());    final boolean writeRequest = (hdr != null);    final boolean quorumRequest = request.isQuorum();        if (!writeRequest && !quorumRequest) {        return new ProcessTxnResult();    }    synchronized (outstandingChanges) {        ProcessTxnResult rc = processTxnInDB(hdr, request.getTxn());                if (writeRequest) {            long zxid = hdr.getZxid();            while (!outstandingChanges.isEmpty() && outstandingChanges.peek().zxid <= zxid) {                ChangeRecord cr = outstandingChanges.remove();                ServerMetrics.getMetrics().OUTSTANDING_CHANGES_REMOVED.add(1);                if (cr.zxid < zxid) {                                    }                if (outstandingChangesForPath.get(cr.path) == cr) {                    outstandingChangesForPath.remove(cr.path);                }            }        }                if (quorumRequest) {            getZKDatabase().addCommittedProposal(request);        }        return rc;    }}
processTxnForSessionEvents
private voidf3724_1Request request, TxnHeader hdr, Record txn)
{    int opCode = (request == null) ? hdr.getType() : request.type;    long sessionId = (request == null) ? hdr.getClientId() : request.sessionId;    if (opCode == OpCode.createSession) {        if (hdr != null && txn instanceof CreateSessionTxn) {            CreateSessionTxn cst = (CreateSessionTxn) txn;            sessionTracker.commitSession(sessionId, cst.getTimeOut());        } else if (request == null || !request.isLocalSession()) {                    }    } else if (opCode == OpCode.closeSession) {        sessionTracker.removeSession(sessionId);    }}
processTxnInDB
private ProcessTxnResult zookeeper_f3725_0(TxnHeader hdr, Record txn)
{    if (hdr == null) {        return new ProcessTxnResult();    } else {        return getZKDatabase().processTxn(hdr, txn);    }}
getSessionExpiryMap
public Map<Long, Set<Long>> zookeeper_f3726_0()
{    return sessionTracker.getSessionExpiryMap();}
registerServerShutdownHandler
 void zookeeper_f3727_0(ZooKeeperServerShutdownHandler zkShutdownHandler)
{    this.zkShutdownHandler = zkShutdownHandler;}
isResponseCachingEnabled
public boolean zookeeper_f3728_0()
{    return isResponseCachingEnabled;}
setResponseCachingEnabled
public void zookeeper_f3729_0(boolean isEnabled)
{    isResponseCachingEnabled = isEnabled;}
getReadResponseCache
public ResponseCache zookeeper_f3730_0()
{    return isResponseCachingEnabled ? readResponseCache : null;}
registerMetrics
protected void zookeeper_f3731_0()
{    MetricsContext rootContext = ServerMetrics.getMetrics().getMetricsProvider().getRootContext();    final ZKDatabase zkdb = this.getZKDatabase();    final ServerStats stats = this.serverStats();    rootContext.registerGauge("avg_latency", stats::getAvgLatency);    rootContext.registerGauge("max_latency", stats::getMaxLatency);    rootContext.registerGauge("min_latency", stats::getMinLatency);    rootContext.registerGauge("packets_received", stats::getPacketsReceived);    rootContext.registerGauge("packets_sent", stats::getPacketsSent);    rootContext.registerGauge("num_alive_connections", stats::getNumAliveClientConnections);    rootContext.registerGauge("outstanding_requests", stats::getOutstandingRequests);    rootContext.registerGauge("uptime", stats::getUptime);    rootContext.registerGauge("znode_count", zkdb::getNodeCount);    rootContext.registerGauge("watch_count", zkdb.getDataTree()::getWatchCount);    rootContext.registerGauge("ephemerals_count", zkdb.getDataTree()::getEphemeralsCount);    rootContext.registerGauge("approximate_data_size", zkdb.getDataTree()::cachedApproximateDataSize);    rootContext.registerGauge("global_sessions", zkdb::getSessionCount);    rootContext.registerGauge("local_sessions", this.getSessionTracker()::getLocalSessionCount);    OSMXBean osMbean = new OSMXBean();    rootContext.registerGauge("open_file_descriptor_count", osMbean::getOpenFileDescriptorCount);    rootContext.registerGauge("max_file_descriptor_count", osMbean::getMaxFileDescriptorCount);    rootContext.registerGauge("connection_drop_probability", this::getConnectionDropChance);    rootContext.registerGauge("last_client_response_size", stats.getClientResponseStats()::getLastBufferSize);    rootContext.registerGauge("max_client_response_size", stats.getClientResponseStats()::getMaxBufferSize);    rootContext.registerGauge("min_client_response_size", stats.getClientResponseStats()::getMinBufferSize);}
unregisterMetrics
protected void zookeeper_f3732_0()
{    MetricsContext rootContext = ServerMetrics.getMetrics().getMetricsProvider().getRootContext();    rootContext.unregisterGauge("avg_latency");    rootContext.unregisterGauge("max_latency");    rootContext.unregisterGauge("min_latency");    rootContext.unregisterGauge("packets_received");    rootContext.unregisterGauge("packets_sent");    rootContext.unregisterGauge("num_alive_connections");    rootContext.unregisterGauge("outstanding_requests");    rootContext.unregisterGauge("uptime");    rootContext.unregisterGauge("znode_count");    rootContext.unregisterGauge("watch_count");    rootContext.unregisterGauge("ephemerals_count");    rootContext.unregisterGauge("approximate_data_size");    rootContext.unregisterGauge("global_sessions");    rootContext.unregisterGauge("local_sessions");    rootContext.unregisterGauge("open_file_descriptor_count");    rootContext.unregisterGauge("max_file_descriptor_count");    rootContext.unregisterGauge("connection_drop_probability");    rootContext.unregisterGauge("last_client_response_size");    rootContext.unregisterGauge("max_client_response_size");    rootContext.unregisterGauge("min_client_response_size");}
dumpMonitorValues
public void zookeeper_f3733_0(BiConsumer<String, Object> response)
{    ServerStats stats = serverStats();    response.accept("version", Version.getFullVersion());    response.accept("server_state", stats.getServerState());}
checkACL
public voidf3734_1ServerCnxn cnxn, List<ACL> acl, int perm, List<Id> ids, String path, List<ACL> setAcls) throws KeeperException.NoAuthException
{    if (skipACL) {        return;    }                if (acl == null || acl.size() == 0) {        return;    }    for (Id authId : ids) {        if (authId.getScheme().equals("super")) {            return;        }    }    for (ACL a : acl) {        Id id = a.getId();        if ((a.getPerms() & perm) != 0) {            if (id.getScheme().equals("world") && id.getId().equals("anyone")) {                return;            }            ServerAuthenticationProvider ap = ProviderRegistry.getServerProvider(id.getScheme());            if (ap != null) {                for (Id authId : ids) {                    if (authId.getScheme().equals(id.getScheme()) && ap.matches(new ServerAuthenticationProvider.ServerObjs(this, cnxn), new ServerAuthenticationProvider.MatchValues(path, authId.getId(), id.getId(), perm, setAcls))) {                        return;                    }                }            }        }    }    throw new KeeperException.NoAuthException();}
isDigestEnabled
public static boolean zookeeper_f3735_0()
{    return digestEnabled;}
setDigestEnabled
public static voidf3736_1boolean digestEnabled)
{        ZooKeeperServer.digestEnabled = digestEnabled;}
parentPath
private String zookeeper_f3737_0(String path) throws KeeperException.BadArgumentsException
{    int lastSlash = path.lastIndexOf('/');    if (lastSlash == -1 || path.indexOf('\0') != -1 || getZKDatabase().isSpecialPath(path)) {        throw new KeeperException.BadArgumentsException(path);    }    return lastSlash == 0 ? "/" : path.substring(0, lastSlash);}
effectiveACLPath
private String zookeeper_f3738_0(Request request) throws KeeperException.BadArgumentsException, KeeperException.InvalidACLException
{    boolean mustCheckACL = false;    String path = null;    List<ACL> acl = null;    switch(request.type) {        case OpCode.create:        case OpCode.create2:            {                CreateRequest req = new CreateRequest();                if (buffer2Record(request.request, req)) {                    mustCheckACL = true;                    acl = req.getAcl();                    path = parentPath(req.getPath());                }                break;            }        case OpCode.delete:            {                DeleteRequest req = new DeleteRequest();                if (buffer2Record(request.request, req)) {                    path = parentPath(req.getPath());                }                break;            }        case OpCode.setData:            {                SetDataRequest req = new SetDataRequest();                if (buffer2Record(request.request, req)) {                    path = req.getPath();                }                break;            }        case OpCode.setACL:            {                SetACLRequest req = new SetACLRequest();                if (buffer2Record(request.request, req)) {                    mustCheckACL = true;                    acl = req.getAcl();                    path = req.getPath();                }                break;            }    }    if (mustCheckACL) {        /* we ignore the extrapolated ACL returned by fixupACL because             * we only care about it being well-formed (and if it isn't, an             * exception will be raised).             */        PrepRequestProcessor.fixupACL(path, request.authInfo, acl);    }    return path;}
effectiveACLPerms
private int zookeeper_f3739_0(Request request)
{    switch(request.type) {        case OpCode.create:        case OpCode.create2:            return ZooDefs.Perms.CREATE;        case OpCode.delete:            return ZooDefs.Perms.DELETE;        case OpCode.setData:            return ZooDefs.Perms.WRITE;        case OpCode.setACL:            return ZooDefs.Perms.ADMIN;        default:            return ZooDefs.Perms.ALL;    }}
authWriteRequest
public booleanf3740_1Request request)
{    int err;    String pathToCheck;    if (!enableEagerACLCheck) {        return true;    }    err = KeeperException.Code.OK.intValue();    try {        pathToCheck = effectiveACLPath(request);        if (pathToCheck != null) {            checkACL(request.cnxn, zkDb.getACL(pathToCheck, null), effectiveACLPerms(request), request.authInfo, pathToCheck, null);        }    } catch (KeeperException.NoAuthException e) {                err = e.code().intValue();    } catch (KeeperException.InvalidACLException e) {                err = e.code().intValue();    } catch (KeeperException.NoNodeException e) {            } catch (KeeperException.BadArgumentsException e) {            } catch (Throwable t) {                throw t;    } finally {        if (err != KeeperException.Code.OK.intValue()) {            /*  This request has a bad ACL, so we are dismissing it early. */            decInProcess();            ReplyHeader rh = new ReplyHeader(request.cxid, 0, err);            try {                request.cnxn.sendResponse(rh, null, null);            } catch (IOException e) {                            }        }    }    return err == KeeperException.Code.OK.intValue();}
buffer2Record
private boolean zookeeper_f3741_0(ByteBuffer request, Record record)
{    boolean rv = false;    try {        ByteBufferInputStream.byteBuffer2Record(request, record);        request.rewind();        rv = true;    } catch (IOException ex) {    }    return rv;}
getClientPort
public String zookeeper_f3742_0()
{    return Integer.toString(zks.getClientPort());}
getName
public String zookeeper_f3743_0()
{    return name;}
isHidden
public boolean zookeeper_f3744_0()
{    return false;}
getStartTime
public String zookeeper_f3745_0()
{    return startTime.toString();}
getVersion
public String zookeeper_f3746_0()
{    return Version.getFullVersion();}
getAvgRequestLatency
public double zookeeper_f3747_0()
{    return zks.serverStats().getAvgLatency();}
getMaxRequestLatency
public long zookeeper_f3748_0()
{    return zks.serverStats().getMaxLatency();}
getMinRequestLatency
public long zookeeper_f3749_0()
{    return zks.serverStats().getMinLatency();}
getOutstandingRequests
public long zookeeper_f3750_0()
{    return zks.serverStats().getOutstandingRequests();}
getTickTime
public int zookeeper_f3751_0()
{    return zks.getTickTime();}
setTickTime
public void zookeeper_f3752_0(int tickTime)
{    zks.setTickTime(tickTime);}
getMaxClientCnxnsPerHost
public int zookeeper_f3753_0()
{    return zks.getMaxClientCnxnsPerHost();}
setMaxClientCnxnsPerHost
public void zookeeper_f3754_0(int max)
{    if (zks.serverCnxnFactory != null) {        zks.serverCnxnFactory.setMaxClientCnxnsPerHost(max);    }    if (zks.secureServerCnxnFactory != null) {        zks.secureServerCnxnFactory.setMaxClientCnxnsPerHost(max);    }}
getMinSessionTimeout
public int zookeeper_f3755_0()
{    return zks.getMinSessionTimeout();}
setMinSessionTimeout
public void zookeeper_f3756_0(int min)
{    zks.setMinSessionTimeout(min);}
getMaxSessionTimeout
public int zookeeper_f3757_0()
{    return zks.getMaxSessionTimeout();}
setMaxSessionTimeout
public void zookeeper_f3758_0(int max)
{    zks.setMaxSessionTimeout(max);}
getDataDirSize
public long zookeeper_f3759_0()
{    return zks.getDataDirSize();}
getLogDirSize
public long zookeeper_f3760_0()
{    return zks.getLogDirSize();}
getPacketsReceived
public long zookeeper_f3761_0()
{    return zks.serverStats().getPacketsReceived();}
getPacketsSent
public long zookeeper_f3762_0()
{    return zks.serverStats().getPacketsSent();}
getFsyncThresholdExceedCount
public long zookeeper_f3763_0()
{    return zks.serverStats().getFsyncThresholdExceedCount();}
resetLatency
public void zookeeper_f3764_0()
{    zks.serverStats().resetLatency();}
resetMaxLatency
public void zookeeper_f3765_0()
{    zks.serverStats().resetMaxLatency();}
resetFsyncThresholdExceedCount
public void zookeeper_f3766_0()
{    zks.serverStats().resetFsyncThresholdExceedCount();}
resetStatistics
public void zookeeper_f3767_0()
{    ServerStats serverStats = zks.serverStats();    serverStats.resetRequestCounters();    serverStats.resetLatency();    serverStats.resetFsyncThresholdExceedCount();}
getNumAliveConnections
public long zookeeper_f3768_0()
{    return zks.getNumAliveConnections();}
getSecureClientPort
public String zookeeper_f3769_0()
{    if (zks.secureServerCnxnFactory != null) {        return Integer.toString(zks.secureServerCnxnFactory.getLocalPort());    }    return "";}
getSecureClientAddress
public String zookeeper_f3770_0()
{    if (zks.secureServerCnxnFactory != null) {        return String.format("%s:%d", zks.secureServerCnxnFactory.getLocalAddress().getHostString(), zks.secureServerCnxnFactory.getLocalPort());    }    return "";}
getTxnLogElapsedSyncTime
public long zookeeper_f3771_0()
{    return zks.getTxnLogElapsedSyncTime();}
getJuteMaxBufferSize
public int zookeeper_f3772_0()
{    return BinaryInputArchive.maxBuffer;}
getLastClientResponseSize
public int zookeeper_f3773_0()
{    return zks.serverStats().getClientResponseStats().getLastBufferSize();}
getMinClientResponseSize
public int zookeeper_f3774_0()
{    return zks.serverStats().getClientResponseStats().getMinBufferSize();}
getMaxClientResponseSize
public int zookeeper_f3775_0()
{    return zks.serverStats().getClientResponseStats().getMaxBufferSize();}
getResponseCachingEnabled
public boolean zookeeper_f3776_0()
{    return zks.isResponseCachingEnabled();}
setResponseCachingEnabled
public void zookeeper_f3777_0(boolean isEnabled)
{    zks.setResponseCachingEnabled(isEnabled);}
getConnectionMaxTokens
public int zookeeper_f3778_0()
{    return zks.connThrottle().getMaxTokens();}
setConnectionMaxTokens
public void zookeeper_f3779_0(int val)
{    zks.connThrottle().setMaxTokens(val);}
getConnectionTokenFillTime
public int zookeeper_f3780_0()
{    return zks.connThrottle().getFillTime();}
setConnectionTokenFillTime
public void zookeeper_f3781_0(int val)
{    zks.connThrottle().setFillTime(val);}
getConnectionTokenFillCount
public int zookeeper_f3782_0()
{    return zks.connThrottle().getFillCount();}
setConnectionTokenFillCount
public void zookeeper_f3783_0(int val)
{    zks.connThrottle().setFillCount(val);}
getConnectionFreezeTime
public int zookeeper_f3784_0()
{    return zks.connThrottle().getFreezeTime();}
setConnectionFreezeTime
public void zookeeper_f3785_0(int val)
{    zks.connThrottle().setFreezeTime(val);}
getConnectionDropIncrease
public double zookeeper_f3786_0()
{    return zks.connThrottle().getDropIncrease();}
setConnectionDropIncrease
public void zookeeper_f3787_0(double val)
{    zks.connThrottle().setDropIncrease(val);}
getConnectionDropDecrease
public double zookeeper_f3788_0()
{    return zks.connThrottle().getDropDecrease();}
setConnectionDropDecrease
public void zookeeper_f3789_0(double val)
{    zks.connThrottle().setDropDecrease(val);}
getConnectionDecreaseRatio
public double zookeeper_f3790_0()
{    return zks.connThrottle().getDecreasePoint();}
setConnectionDecreaseRatio
public void zookeeper_f3791_0(double val)
{    zks.connThrottle().setDecreasePoint(val);}
getCommitProcMaxReadBatchSize
public int zookeeper_f3792_0()
{    return CommitProcessor.getMaxReadBatchSize();}
setCommitProcMaxReadBatchSize
public void zookeeper_f3793_0(int size)
{    CommitProcessor.setMaxReadBatchSize(size);}
getCommitProcMaxCommitBatchSize
public int zookeeper_f3794_0()
{    return CommitProcessor.getMaxCommitBatchSize();}
setCommitProcMaxCommitBatchSize
public void zookeeper_f3795_0(int size)
{    CommitProcessor.setMaxCommitBatchSize(size);}
getFlushDelay
public long zookeeper_f3796_0()
{    return zks.getFlushDelay();}
setFlushDelay
public void zookeeper_f3797_0(long delay)
{    ZooKeeperServer.setFlushDelay(delay);}
getRequestThrottleLimit
public int zookeeper_f3798_0()
{    return RequestThrottler.getMaxRequests();}
setRequestThrottleLimit
public void zookeeper_f3799_0(int requests)
{    RequestThrottler.setMaxRequests(requests);}
getRequestThrottleStallTime
public int zookeeper_f3800_0()
{    return RequestThrottler.getStallTime();}
setRequestThrottleStallTime
public void zookeeper_f3801_0(int time)
{    RequestThrottler.setStallTime(time);}
getRequestThrottleDropStale
public boolean zookeeper_f3802_0()
{    return RequestThrottler.getDropStaleRequests();}
setRequestThrottleDropStale
public void zookeeper_f3803_0(boolean drop)
{    RequestThrottler.setDropStaleRequests(drop);}
getMaxWriteQueuePollTime
public long zookeeper_f3804_0()
{    return zks.getMaxWriteQueuePollTime();}
setMaxWriteQueuePollTime
public void zookeeper_f3805_0(long delay)
{    ZooKeeperServer.setMaxWriteQueuePollTime(delay);}
getRequestStaleLatencyCheck
public boolean zookeeper_f3806_0()
{    return Request.getStaleLatencyCheck();}
setRequestStaleLatencyCheck
public void zookeeper_f3807_0(boolean check)
{    Request.setStaleLatencyCheck(check);}
getMaxBatchSize
public int zookeeper_f3808_0()
{    return zks.getMaxBatchSize();}
setMaxBatchSize
public void zookeeper_f3809_0(int size)
{    ZooKeeperServer.setMaxBatchSize(size);}
getRequestStaleConnectionCheck
public boolean zookeeper_f3810_0()
{    return Request.getStaleConnectionCheck();}
setRequestStaleConnectionCheck
public void zookeeper_f3811_0(boolean check)
{    Request.setStaleConnectionCheck(check);}
getLargeRequestMaxBytes
public int zookeeper_f3812_0()
{    return zks.getLargeRequestMaxBytes();}
setLargeRequestMaxBytes
public void zookeeper_f3813_0(int bytes)
{    zks.setLargeRequestMaxBytes(bytes);}
getLargeRequestThreshold
public int zookeeper_f3814_0()
{    return zks.getLargeRequestThreshold();}
setLargeRequestThreshold
public void zookeeper_f3815_0(int threshold)
{    zks.setLargeRequestThreshold(threshold);}
getClientPort
public int zookeeper_f3816_0()
{    return clientPort;}
getDataDir
public String zookeeper_f3817_0()
{    return dataDir;}
getDataLogDir
public String zookeeper_f3818_0()
{    return dataLogDir;}
getTickTime
public int zookeeper_f3819_0()
{    return tickTime;}
getMaxClientCnxnsPerHost
public int zookeeper_f3820_0()
{    return maxClientCnxnsPerHost;}
getMinSessionTimeout
public int zookeeper_f3821_0()
{    return minSessionTimeout;}
getMaxSessionTimeout
public int zookeeper_f3822_0()
{    return maxSessionTimeout;}
getServerId
public long zookeeper_f3823_0()
{    return serverId;}
getClientPortListenBacklog
public int zookeeper_f3824_0()
{    return clientPortListenBacklog;}
toMap
public Map<String, Object> zookeeper_f3825_0()
{    Map<String, Object> conf = new LinkedHashMap<String, Object>();    conf.put(KEY_CLIENT_PORT, clientPort);    conf.put(KEY_DATA_DIR, dataDir);    conf.put(KEY_DATA_LOG_DIR, dataLogDir);    conf.put(KEY_TICK_TIME, tickTime);    conf.put(KEY_MAX_CLIENT_CNXNS, maxClientCnxnsPerHost);    conf.put(KEY_MIN_SESSION_TIMEOUT, minSessionTimeout);    conf.put(KEY_MAX_SESSION_TIMEOUT, maxSessionTimeout);    conf.put(KEY_SERVER_ID, serverId);    conf.put(KEY_CLIENT_PORT_LISTEN_BACKLOG, clientPortListenBacklog);    return conf;}
notifyStopping
public voidf3826_1String threadName, int exitCode)
{        zkServer.setState(State.ERROR);}
main
public static voidf3827_1String[] args)
{    ZooKeeperServerMain main = new ZooKeeperServerMain();    try {        main.initializeAndRun(args);    } catch (IllegalArgumentException e) {                        System.err.println(USAGE);        System.exit(ExitCode.INVALID_INVOCATION.getValue());    } catch (ConfigException e) {                System.err.println("Invalid config, exiting abnormally");        System.exit(ExitCode.INVALID_INVOCATION.getValue());    } catch (DatadirException e) {                System.err.println("Unable to access datadir, exiting abnormally");        System.exit(ExitCode.UNABLE_TO_ACCESS_DATADIR.getValue());    } catch (AdminServerException e) {                System.err.println("Unable to start AdminServer, exiting abnormally");        System.exit(ExitCode.ERROR_STARTING_ADMIN_SERVER.getValue());    } catch (Exception e) {                System.exit(ExitCode.UNEXPECTED_ERROR.getValue());    }        System.exit(ExitCode.EXECUTION_FINISHED.getValue());}
initializeAndRun
protected voidf3828_1String[] args) throws ConfigException, IOException, AdminServerException
{    try {        ManagedUtil.registerLog4jMBeans();    } catch (JMException e) {            }    ServerConfig config = new ServerConfig();    if (args.length == 1) {        config.parse(args[0]);    } else {        config.parse(args);    }    runFromConfig(config);}
runFromConfig
public voidf3829_1ServerConfig config) throws IOException, AdminServerException
{        FileTxnSnapLog txnLog = null;    try {        try {            metricsProvider = MetricsProviderBootstrap.startMetricsProvider(config.getMetricsProviderClassName(), config.getMetricsProviderConfiguration());        } catch (MetricsProviderLifeCycleException error) {            throw new IOException("Cannot boot MetricsProvider " + config.getMetricsProviderClassName(), error);        }        ServerMetrics.metricsProviderInitialized(metricsProvider);                                        txnLog = new FileTxnSnapLog(config.dataLogDir, config.dataDir);        JvmPauseMonitor jvmPauseMonitor = null;        if (config.jvmPauseMonitorToRun) {            jvmPauseMonitor = new JvmPauseMonitor(config);        }        final ZooKeeperServer zkServer = new ZooKeeperServer(jvmPauseMonitor, txnLog, config.tickTime, config.minSessionTimeout, config.maxSessionTimeout, config.listenBacklog, null, config.initialConfig);        txnLog.setServerStats(zkServer.serverStats());                        final CountDownLatch shutdownLatch = new CountDownLatch(1);        zkServer.registerServerShutdownHandler(new ZooKeeperServerShutdownHandler(shutdownLatch));                adminServer = AdminServerFactory.createAdminServer();        adminServer.setZooKeeperServer(zkServer);        adminServer.start();        boolean needStartZKServer = true;        if (config.getClientPortAddress() != null) {            cnxnFactory = ServerCnxnFactory.createFactory();            cnxnFactory.configure(config.getClientPortAddress(), config.getMaxClientCnxns(), config.getClientPortListenBacklog(), false);            cnxnFactory.startup(zkServer);                        needStartZKServer = false;        }        if (config.getSecureClientPortAddress() != null) {            secureCnxnFactory = ServerCnxnFactory.createFactory();            secureCnxnFactory.configure(config.getSecureClientPortAddress(), config.getMaxClientCnxns(), config.getClientPortListenBacklog(), true);            secureCnxnFactory.startup(zkServer, needStartZKServer);        }        containerManager = new ContainerManager(zkServer.getZKDatabase(), zkServer.firstProcessor, Integer.getInteger("znode.container.checkIntervalMs", (int) TimeUnit.MINUTES.toMillis(1)), Integer.getInteger("znode.container.maxPerMinute", 10000));        containerManager.start();                        shutdownLatch.await();        shutdown();        if (cnxnFactory != null) {            cnxnFactory.join();        }        if (secureCnxnFactory != null) {            secureCnxnFactory.join();        }        if (zkServer.canShutdown()) {            zkServer.shutdown(true);        }    } catch (InterruptedException e) {                    } finally {        if (txnLog != null) {            txnLog.close();        }        if (metricsProvider != null) {            try {                metricsProvider.stop();            } catch (Throwable error) {                            }        }    }}
shutdown
protected voidf3830_1)
{    if (containerManager != null) {        containerManager.stop();    }    if (cnxnFactory != null) {        cnxnFactory.shutdown();    }    if (secureCnxnFactory != null) {        secureCnxnFactory.shutdown();    }    try {        if (adminServer != null) {            adminServer.shutdown();        }    } catch (AdminServerException e) {            }}
getCnxnFactory
 ServerCnxnFactory zookeeper_f3831_0()
{    return cnxnFactory;}
handle
 void zookeeper_f3832_0(State state)
{    if (state == State.ERROR || state == State.SHUTDOWN) {        shutdownLatch.countDown();    }}
uncaughtException
public void zookeeper_f3833_0(Thread t, Throwable e)
{    handleException(t.getName(), e);}
handleException
protected voidf3834_1String thName, Throwable e)
{    }
getTextTraceLevel
public static synchronized long zookeeper_f3835_0()
{    return traceMask;}
setTextTraceLevel
public static synchronized voidf3836_1long mask)
{    traceMask = mask;    final Logger LOG = LoggerFactory.getLogger(ZooTrace.class);    }
isTraceEnabled
public static synchronized boolean zookeeper_f3837_0(Logger log, long mask)
{    return log.isTraceEnabled() && (mask & traceMask) != 0;}
logTraceMessage
public static void zookeeper_f3838_0(Logger log, long mask, String msg)
{    if (isTraceEnabled(log, mask)) {        log.trace(msg);    }}
logQuorumPacket
public static void zookeeper_f3839_0(Logger log, long mask, char direction, QuorumPacket qp)
{    if (isTraceEnabled(log, mask)) {        logTraceMessage(log, mask, direction + " " + LearnerHandler.packetToString(qp));    }}
logRequest
public static void zookeeper_f3840_0(Logger log, long mask, char rp, Request request, String header)
{    if (isTraceEnabled(log, mask)) {        log.trace(header + ":" + rp + request.toString());    }}
ruok
public static voidf3841_1String host, int port)
{    Socket s = null;    try {        byte[] reqBytes = new byte[4];        ByteBuffer req = ByteBuffer.wrap(reqBytes);        req.putInt(ByteBuffer.wrap("ruok".getBytes()).getInt());        s = new Socket();        s.setSoLinger(false, 10);        s.setSoTimeout(20000);        s.connect(new InetSocketAddress(host, port));        InputStream is = s.getInputStream();        OutputStream os = s.getOutputStream();        os.write(reqBytes);        byte[] resBytes = new byte[4];        int rc = is.read(resBytes);        String retv = new String(resBytes);        System.out.println("rc=" + rc + " retv=" + retv);    } catch (IOException e) {            } finally {        if (s != null) {            try {                s.close();            } catch (IOException e) {                            }        }    }}
dump
public static voidf3842_1String host, int port)
{    Socket s = null;    try {        byte[] reqBytes = new byte[4];        ByteBuffer req = ByteBuffer.wrap(reqBytes);        req.putInt(ByteBuffer.wrap("dump".getBytes()).getInt());        s = new Socket();        s.setSoLinger(false, 10);        s.setSoTimeout(20000);        s.connect(new InetSocketAddress(host, port));        InputStream is = s.getInputStream();        OutputStream os = s.getOutputStream();        os.write(reqBytes);        byte[] resBytes = new byte[1024];        int rc = is.read(resBytes);        String retv = new String(resBytes);        System.out.println("rc=" + rc + " retv=" + retv);    } catch (IOException e) {            } finally {        if (s != null) {            try {                s.close();            } catch (IOException e) {                            }        }    }}
stat
public static voidf3843_1String host, int port)
{    Socket s = null;    try {        byte[] reqBytes = new byte[4];        ByteBuffer req = ByteBuffer.wrap(reqBytes);        req.putInt(ByteBuffer.wrap("stat".getBytes()).getInt());        s = new Socket();        s.setSoLinger(false, 10);        s.setSoTimeout(20000);        s.connect(new InetSocketAddress(host, port));        InputStream is = s.getInputStream();        OutputStream os = s.getOutputStream();        os.write(reqBytes);        byte[] resBytes = new byte[1024];        int rc = is.read(resBytes);        String retv = new String(resBytes);        System.out.println("rc=" + rc + " retv=" + retv);    } catch (IOException e) {            } finally {        if (s != null) {            try {                s.close();            } catch (IOException e) {                            }        }    }}
kill
public static voidf3844_1String host, int port)
{    Socket s = null;    try {        byte[] reqBytes = new byte[4];        ByteBuffer req = ByteBuffer.wrap(reqBytes);        req.putInt(ByteBuffer.wrap("kill".getBytes()).getInt());        s = new Socket();        s.setSoLinger(false, 10);        s.setSoTimeout(20000);        s.connect(new InetSocketAddress(host, port));        InputStream is = s.getInputStream();        OutputStream os = s.getOutputStream();        os.write(reqBytes);        byte[] resBytes = new byte[4];        int rc = is.read(resBytes);        String retv = new String(resBytes);        System.out.println("rc=" + rc + " retv=" + retv);    } catch (IOException e) {            } finally {        if (s != null) {            try {                s.close();            } catch (IOException e) {                            }        }    }}
setTraceMask
public static voidf3845_1String host, int port, String traceMaskStr)
{    Socket s = null;    try {        byte[] reqBytes = new byte[12];        ByteBuffer req = ByteBuffer.wrap(reqBytes);        long traceMask = Long.parseLong(traceMaskStr, 8);        req.putInt(ByteBuffer.wrap("stmk".getBytes()).getInt());        req.putLong(traceMask);        s = new Socket();        s.setSoLinger(false, 10);        s.setSoTimeout(20000);        s.connect(new InetSocketAddress(host, port));        InputStream is = s.getInputStream();        OutputStream os = s.getOutputStream();        os.write(reqBytes);        byte[] resBytes = new byte[8];        int rc = is.read(resBytes);        ByteBuffer res = ByteBuffer.wrap(resBytes);        long retv = res.getLong();        System.out.println("rc=" + rc + " retv=0" + Long.toOctalString(retv) + " masks=0" + Long.toOctalString(traceMask));        assert (retv == traceMask);    } catch (IOException e) {            } finally {        if (s != null) {            try {                s.close();            } catch (IOException e) {                            }        }    }}
getTraceMask
public static voidf3846_1String host, int port)
{    Socket s = null;    try {        byte[] reqBytes = new byte[12];        ByteBuffer req = ByteBuffer.wrap(reqBytes);        req.putInt(ByteBuffer.wrap("gtmk".getBytes()).getInt());        s = new Socket();        s.setSoLinger(false, 10);        s.setSoTimeout(20000);        s.connect(new InetSocketAddress(host, port));        InputStream is = s.getInputStream();        OutputStream os = s.getOutputStream();        os.write(reqBytes);        byte[] resBytes = new byte[8];        int rc = is.read(resBytes);        ByteBuffer res = ByteBuffer.wrap(resBytes);        long retv = res.getLong();        System.out.println("rc=" + rc + " retv=0" + Long.toOctalString(retv));    } catch (IOException e) {            } finally {        if (s != null) {            try {                s.close();            } catch (IOException e) {                            }        }    }}
usage
private static void zookeeper_f3847_0()
{    System.out.println("usage: java [-cp CLASSPATH] org.apache.zookeeper.ServerAdminClient " + "host port op (ruok|stat|dump|kill|gettracemask|settracemask) [arguments]");}
main
public static void zookeeper_f3848_0(String[] args)
{    if (args.length < 3) {        usage();        return;    }    String host = args[0];    int port = Integer.parseInt(args[1]);    String op = args[2];    if (op.equalsIgnoreCase("gettracemask")) {        getTraceMask(host, port);    } else if (op.equalsIgnoreCase("settracemask")) {        setTraceMask(host, port, args[3]);    } else if (op.equalsIgnoreCase("ruok")) {        ruok(host, port);    } else if (op.equalsIgnoreCase("kill")) {        kill(host, port);    } else if (op.equalsIgnoreCase("stat")) {        stat(host, port);    } else if (op.equalsIgnoreCase("dump")) {        dump(host, port);    } else {        System.out.println("Unrecognized op: " + op);    }}
getGroupsCommand
public static String[] zookeeper_f3849_0()
{    return new String[] { "bash", "-c", "groups" };}
getGroupsForUserCommand
public static String[] zookeeper_f3850_0(final String user)
{        return new String[] { "bash", "-c", "id -Gn " + user };}
getGET_PERMISSION_COMMAND
public static String[] zookeeper_f3851_0()
{        return new String[] { (WINDOWS ? "ls" : "/bin/ls"), "-ld" };}
getUlimitMemoryCommand
public static String[] zookeeper_f3852_0(int memoryLimit)
{        if (WINDOWS) {        return null;    }    return new String[] { ULIMIT_COMMAND, "-v", String.valueOf(memoryLimit) };}
setEnvironment
protected void zookeeper_f3853_0(Map<String, String> env)
{    this.environment = env;}
setWorkingDirectory
protected void zookeeper_f3854_0(File dir)
{    this.dir = dir;}
run
protected void zookeeper_f3855_0() throws IOException
{    if (lastTime + interval > Time.currentElapsedTime()) {        return;    }        exitCode = ExitCode.EXECUTION_FINISHED.getValue();    runCommand();}
runCommand
private voidf3856_1) throws IOException
{    ProcessBuilder builder = new ProcessBuilder(getExecString());    Timer timeOutTimer = null;    ShellTimeoutTimerTask timeoutTimerTask = null;    timedOut = new AtomicBoolean(false);    completed = new AtomicBoolean(false);    if (environment != null) {        builder.environment().putAll(this.environment);    }    if (dir != null) {        builder.directory(this.dir);    }    process = builder.start();    if (timeOutInterval > 0) {        timeOutTimer = new Timer();        timeoutTimerTask = new ShellTimeoutTimerTask(this);                timeOutTimer.schedule(timeoutTimerTask, timeOutInterval);    }    final BufferedReader errReader = new BufferedReader(new InputStreamReader(process.getErrorStream()));    BufferedReader inReader = new BufferedReader(new InputStreamReader(process.getInputStream()));    final StringBuffer errMsg = new StringBuffer();            Thread errThread = new Thread() {        @Override        public void run() {            try {                String line = errReader.readLine();                while ((line != null) && !isInterrupted()) {                    errMsg.append(line);                    errMsg.append(System.getProperty("line.separator"));                    line = errReader.readLine();                }            } catch (IOException ioe) {                            }        }    };    try {        errThread.start();    } catch (IllegalStateException ise) {    }    try {                parseExecResult(inReader);                String line = inReader.readLine();        while (line != null) {            line = inReader.readLine();        }                exitCode = process.waitFor();        try {                        errThread.join();        } catch (InterruptedException ie) {                    }        completed.set(true);                if (exitCode != ExitCode.EXECUTION_FINISHED.getValue()) {            throw new ExitCodeException(exitCode, errMsg.toString());        }    } catch (InterruptedException ie) {        throw new IOException(ie.toString());    } finally {        if ((timeOutTimer != null) && !timedOut.get()) {            timeOutTimer.cancel();        }                try {            inReader.close();        } catch (IOException ioe) {                    }        if (!completed.get()) {            errThread.interrupt();        }        try {            errReader.close();        } catch (IOException ioe) {                    }        process.destroy();        lastTime = Time.currentElapsedTime();    }}
run
public voidf3857_1)
{    try {        String line = errReader.readLine();        while ((line != null) && !isInterrupted()) {            errMsg.append(line);            errMsg.append(System.getProperty("line.separator"));            line = errReader.readLine();        }    } catch (IOException ioe) {            }}
getProcess
public Process zookeeper_f3858_0()
{    return process;}
getExitCode
public int zookeeper_f3859_0()
{    return exitCode;}
getExitCode
public int zookeeper_f3860_0()
{    return exitCode;}
execute
public void zookeeper_f3861_0() throws IOException
{    this.run();}
getExecString
protected String[] zookeeper_f3862_0()
{    return command;}
parseExecResult
protected void zookeeper_f3863_0(BufferedReader lines) throws IOException
{    output = new StringBuffer();    char[] buf = new char[512];    int nRead;    while ((nRead = lines.read(buf, 0, buf.length)) > 0) {        output.append(buf, 0, nRead);    }}
getOutput
public String zookeeper_f3864_0()
{    return (output == null) ? "" : output.toString();}
toString
public String zookeeper_f3865_0()
{    StringBuilder builder = new StringBuilder();    String[] args = getExecString();    for (String s : args) {        if (s.indexOf(' ') >= 0) {            builder.append('"').append(s).append('"');        } else {            builder.append(s);        }        builder.append(' ');    }    return builder.toString();}
isTimedOut
public boolean zookeeper_f3866_0()
{    return timedOut.get();}
setTimedOut
private void zookeeper_f3867_0()
{    this.timedOut.set(true);}
execCommand
public static String zookeeper_f3868_0(String... cmd) throws IOException
{    return execCommand(null, cmd, 0L);}
execCommand
public static String zookeeper_f3869_0(Map<String, String> env, String[] cmd, long timeout) throws IOException
{    ShellCommandExecutor exec = new ShellCommandExecutor(cmd, null, env, timeout);    exec.execute();    return exec.getOutput();}
execCommand
public static String zookeeper_f3870_0(Map<String, String> env, String... cmd) throws IOException
{    return execCommand(env, cmd, 0L);}
run
public void zookeeper_f3871_0()
{    Process p = shell.getProcess();    try {        p.exitValue();    } catch (Exception e) {                if (p != null && !shell.completed.get()) {            shell.setTimedOut();            p.destroy();        }    }}
getCount
public int zookeeper_f3872_0()
{    return this.count;}
setCount
public void zookeeper_f3873_0(int count)
{    this.count = count;}
getBytes
public long zookeeper_f3874_0()
{    return this.bytes;}
setBytes
public void zookeeper_f3875_0(long bytes)
{    this.bytes = bytes;}
toString
public String zookeeper_f3876_0()
{    return countStr + "=" + count + "," + byteStr + "=" + bytes;}
create
public Transaction zookeeper_f3877_0(final String path, byte[] data, List<ACL> acl, CreateMode createMode)
{    ops.add(Op.create(path, data, acl, createMode.toFlag()));    return this;}
delete
public Transaction zookeeper_f3878_0(final String path, int version)
{    ops.add(Op.delete(path, version));    return this;}
check
public Transaction zookeeper_f3879_0(String path, int version)
{    ops.add(Op.check(path, version));    return this;}
setData
public Transaction zookeeper_f3880_0(final String path, byte[] data, int version)
{    ops.add(Op.setData(path, data, version));    return this;}
commit
public List<OpResult> zookeeper_f3881_0() throws InterruptedException, KeeperException
{    return zk.multi(ops);}
commit
public void zookeeper_f3882_0(MultiCallback cb, Object ctx)
{    zk.multi(ops, cb, ctx);}
loadTrustStore
public static KeyStore zookeeper_f3883_0(File certificateChainFile) throws IOException, GeneralSecurityException
{    KeyStore keyStore = KeyStore.getInstance("JKS");    keyStore.load(null, null);    List<X509Certificate> certificateChain = readCertificateChain(certificateChainFile);    for (X509Certificate certificate : certificateChain) {        X500Principal principal = certificate.getSubjectX500Principal();        keyStore.setCertificateEntry(principal.getName("RFC2253"), certificate);    }    return keyStore;}
loadKeyStore
public static KeyStore zookeeper_f3884_0(File certificateChainFile, File privateKeyFile, Optional<String> keyPassword) throws IOException, GeneralSecurityException
{    PrivateKey key = loadPrivateKey(privateKeyFile, keyPassword);    List<X509Certificate> certificateChain = readCertificateChain(certificateChainFile);    if (certificateChain.isEmpty()) {        throw new CertificateException("Certificate file does not contain any certificates: " + certificateChainFile);    }    KeyStore keyStore = KeyStore.getInstance("JKS");    keyStore.load(null, null);    keyStore.setKeyEntry("key", key, keyPassword.orElse("").toCharArray(), certificateChain.toArray(new Certificate[0]));    return keyStore;}
readCertificateChain
public static List<X509Certificate> zookeeper_f3885_0(File certificateChainFile) throws IOException, GeneralSecurityException
{    String contents = new String(Files.readAllBytes(certificateChainFile.toPath()), US_ASCII);    return readCertificateChain(contents);}
readCertificateChain
public static List<X509Certificate> zookeeper_f3886_0(String certificateChain) throws CertificateException
{    Matcher matcher = CERT_PATTERN.matcher(certificateChain);    CertificateFactory certificateFactory = CertificateFactory.getInstance("X.509");    List<X509Certificate> certificates = new ArrayList<>();    int start = 0;    while (matcher.find(start)) {        byte[] buffer = base64Decode(matcher.group(1));        certificates.add((X509Certificate) certificateFactory.generateCertificate(new ByteArrayInputStream(buffer)));        start = matcher.end();    }    return certificates;}
loadPrivateKey
public static PrivateKey zookeeper_f3887_0(File privateKeyFile, Optional<String> keyPassword) throws IOException, GeneralSecurityException
{    String privateKey = new String(Files.readAllBytes(privateKeyFile.toPath()), US_ASCII);    return loadPrivateKey(privateKey, keyPassword);}
loadPrivateKey
public static PrivateKey zookeeper_f3888_0(String privateKey, Optional<String> keyPassword) throws IOException, GeneralSecurityException
{    Matcher matcher = PRIVATE_KEY_PATTERN.matcher(privateKey);    if (!matcher.find()) {        throw new KeyStoreException("did not find a private key");    }    byte[] encodedKey = base64Decode(matcher.group(1));    PKCS8EncodedKeySpec encodedKeySpec;    if (keyPassword.isPresent()) {        EncryptedPrivateKeyInfo encryptedPrivateKeyInfo = new EncryptedPrivateKeyInfo(encodedKey);        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(encryptedPrivateKeyInfo.getAlgName());        SecretKey secretKey = keyFactory.generateSecret(new PBEKeySpec(keyPassword.get().toCharArray()));        Cipher cipher = Cipher.getInstance(encryptedPrivateKeyInfo.getAlgName());        cipher.init(DECRYPT_MODE, secretKey, encryptedPrivateKeyInfo.getAlgParameters());        encodedKeySpec = encryptedPrivateKeyInfo.getKeySpec(cipher);    } else {        encodedKeySpec = new PKCS8EncodedKeySpec(encodedKey);    }        try {        KeyFactory keyFactory = KeyFactory.getInstance("RSA");        return keyFactory.generatePrivate(encodedKeySpec);    } catch (InvalidKeySpecException ignore) {    }    try {        KeyFactory keyFactory = KeyFactory.getInstance("EC");        return keyFactory.generatePrivate(encodedKeySpec);    } catch (InvalidKeySpecException ignore) {    }    KeyFactory keyFactory = KeyFactory.getInstance("DSA");    return keyFactory.generatePrivate(encodedKeySpec);}
loadPublicKey
public static PublicKey zookeeper_f3889_0(File publicKeyFile) throws IOException, GeneralSecurityException
{    String publicKey = new String(Files.readAllBytes(publicKeyFile.toPath()), US_ASCII);    return loadPublicKey(publicKey);}
loadPublicKey
public static PublicKey zookeeper_f3890_0(String publicKey) throws GeneralSecurityException
{    Matcher matcher = PUBLIC_KEY_PATTERN.matcher(publicKey);    if (!matcher.find()) {        throw new KeyStoreException("did not find a public key");    }    String data = matcher.group(1);    byte[] encodedKey = base64Decode(data);    X509EncodedKeySpec encodedKeySpec = new X509EncodedKeySpec(encodedKey);    try {        KeyFactory keyFactory = KeyFactory.getInstance("RSA");        return keyFactory.generatePublic(encodedKeySpec);    } catch (InvalidKeySpecException ignore) {    }    try {        KeyFactory keyFactory = KeyFactory.getInstance("EC");        return keyFactory.generatePublic(encodedKeySpec);    } catch (InvalidKeySpecException ignore) {    }    KeyFactory keyFactory = KeyFactory.getInstance("DSA");    return keyFactory.generatePublic(encodedKeySpec);}
base64Decode
private static byte[] zookeeper_f3891_0(String base64)
{    return getMimeDecoder().decode(base64.getBytes(US_ASCII));}
run
public SaslServerf3895_1)
{    try {        SaslServer saslServer;        saslServer = Sasl.createSaslServer(mech, servicePrincipalName, serviceHostname, null, callbackHandler);        return saslServer;    } catch (SaslException e) {                return null;    }}
getServerPrincipal
public static String zookeeper_f3896_0(String principalConfig, String hostname)
{    String[] components = getComponents(principalConfig);    if (components == null || components.length != 2 || !components[1].equals(QUORUM_HOSTNAME_PATTERN)) {        return principalConfig;    } else {        return replacePattern(components, hostname);    }}
getComponents
private static String[] zookeeper_f3897_0(String principalConfig)
{    if (principalConfig == null) {        return null;    }    return principalConfig.split("[/]");}
replacePattern
private static String zookeeper_f3898_0(String[] components, String hostname)
{    return components[0] + "/" + hostname.toLowerCase();}
printUsage
 static void zookeeper_f3899_0()
{    System.out.print("Usage:\tjava  -cp <classpath> org.apache.zookeeper." + "version.util.VerGen maj.min.micro[-qualifier] rev buildDate outputDirectory");    System.exit(ExitCode.UNEXPECTED_ERROR.getValue());}
parseVersionString
public static Version zookeeper_f3900_0(String input)
{    Version result = new Version();    Pattern p = Pattern.compile("^(\\d+)\\.(\\d+)\\.(\\d+)((\\.\\d+)*)(-(.+))?$");    Matcher m = p.matcher(input);    if (!m.matches()) {        return null;    }    result.maj = Integer.parseInt(m.group(1));    result.min = Integer.parseInt(m.group(2));    result.micro = Integer.parseInt(m.group(3));    if (m.groupCount() == 7) {        result.qualifier = m.group(7);    } else {        result.qualifier = null;    }    return result;}
main
public static void zookeeper_f3901_0(String[] args)
{    if (args.length != 4) {        printUsage();    }    try {        Version version = parseVersionString(args[0]);        if (version == null) {            System.err.println("Invalid version number format, must be \"x.y.z(-.*)?\"");            System.exit(ExitCode.UNEXPECTED_ERROR.getValue());        }        String rev = args[1];        if (rev == null || rev.trim().isEmpty()) {            rev = "-1";        } else {            rev = rev.trim();        }        generateFile(new File(args[3]), version, rev, args[2]);    } catch (NumberFormatException e) {        System.err.println("All version-related parameters must be valid integers!");        throw e;    }}
getRevisionHash
public static String zookeeper_f3902_0()
{    return REVISION_HASH;}
getBuildDate
public static String zookeeper_f3903_0()
{    return BUILD_DATE;}
getVersion
public static String zookeeper_f3904_0()
{    return MAJOR + "." + MINOR + "." + MICRO + (QUALIFIER == null ? "" : "-" + QUALIFIER);}
getVersionRevision
public static String zookeeper_f3905_0()
{    return getVersion() + "-" + getRevisionHash();}
getFullVersion
public static String zookeeper_f3906_0()
{    return getVersionRevision() + ", built on " + getBuildDate();}
printUsage
public static void zookeeper_f3907_0()
{    System.out.print("Usage:\tjava -cp ... org.apache.zookeeper.Version " + "[--full | --short | --revision],\n\tPrints --full version " + "info if no arg specified.");    System.exit(ExitCode.UNEXPECTED_ERROR.getValue());}
main
public static void zookeeper_f3908_0(String[] args)
{    if (args.length > 1) {        printUsage();    }    if (args.length == 0 || (args.length == 1 && args[0].equals("--full"))) {        System.out.println(getFullVersion());        System.exit(ExitCode.EXECUTION_FINISHED.getValue());    }    if (args[0].equals("--short")) {        System.out.println(getVersion());    } else if (args[0].equals("--revision")) {        System.out.println(getVersionRevision());    } else {        printUsage();    }    System.exit(ExitCode.EXECUTION_FINISHED.getValue());}
unregister
public Map<EventType, Set<Watcher>> zookeeper_f3909_0(int rc) throws KeeperException
{    return zkManager.removeWatcher(clientPath, watcher, watcherType, local, rc);}
getClientPath
public String zookeeper_f3910_0()
{    return clientPath;}
getState
public KeeperState zookeeper_f3911_0()
{    return keeperState;}
getType
public EventType zookeeper_f3912_0()
{    return eventType;}
getPath
public String zookeeper_f3913_0()
{    return path;}
toString
public String zookeeper_f3914_0()
{    return "WatchedEvent state:" + keeperState + " type:" + eventType + " path:" + path;}
getWrapper
public WatcherEvent zookeeper_f3915_0()
{    return new WatcherEvent(eventType.getIntValue(), keeperState.getIntValue(), path);}
getIntValue
public int zookeeper_f3916_0()
{    return intValue;}
fromInt
public static KeeperState zookeeper_f3917_0(int intValue)
{    switch(intValue) {        case -1:            return KeeperState.Unknown;        case 0:            return KeeperState.Disconnected;        case 1:            return KeeperState.NoSyncConnected;        case 3:            return KeeperState.SyncConnected;        case 4:            return KeeperState.AuthFailed;        case 5:            return KeeperState.ConnectedReadOnly;        case 6:            return KeeperState.SaslAuthenticated;        case -112:            return KeeperState.Expired;        case 7:            return KeeperState.Closed;        default:            throw new RuntimeException("Invalid integer value for conversion to KeeperState");    }}
getIntValue
public int zookeeper_f3918_0()
{    return intValue;}
fromInt
public static EventType zookeeper_f3919_0(int intValue)
{    switch(intValue) {        case -1:            return EventType.None;        case 1:            return EventType.NodeCreated;        case 2:            return EventType.NodeDeleted;        case 3:            return EventType.NodeDataChanged;        case 4:            return EventType.NodeChildrenChanged;        case 5:            return EventType.DataWatchRemoved;        case 6:            return EventType.ChildWatchRemoved;        default:            throw new RuntimeException("Invalid integer value for conversion to EventType");    }}
getIntValue
public int zookeeper_f3920_0()
{    return intValue;}
fromInt
public static WatcherType zookeeper_f3921_0(int intValue)
{    switch(intValue) {        case 1:            return WatcherType.Children;        case 2:            return WatcherType.Data;        case 3:            return WatcherType.Any;        default:            throw new RuntimeException("Invalid integer value for conversion to WatcherType");    }}
deleteRecursive
public static booleanf3922_1ZooKeeper zk, final String pathRoot, final int batchSize) throws InterruptedException, KeeperException
{    PathUtils.validatePath(pathRoot);    List<String> tree = listSubTreeBFS(zk, pathRoot);        return deleteInBatch(zk, tree, batchSize);}
deleteInBatch
private static boolean zookeeper_f3923_0(ZooKeeper zk, List<String> tree, int batchSize) throws InterruptedException
{    int rateLimit = 10;    List<Op> ops = new ArrayList<>();    BatchedDeleteCbContext context = new BatchedDeleteCbContext(rateLimit);    MultiCallback cb = (rc, path, ctx, opResults) -> {        ((BatchedDeleteCbContext) ctx).sem.release();        if (rc != Code.OK.intValue()) {            ((BatchedDeleteCbContext) ctx).success.set(false);        }    };        for (int i = tree.size() - 1; i >= 0; --i) {                ops.add(Op.delete(tree.get(i), -1));        if (ops.size() == batchSize || i == 0) {            if (!context.success.get()) {                                break;            }            context.sem.acquire();            zk.multi(ops, cb, context);            ops = new ArrayList<>();        }    }        context.sem.acquire(rateLimit);    return context.success.get();}
deleteRecursive
public static voidf3924_1ZooKeeper zk, final String pathRoot, VoidCallback cb, Object ctx) throws InterruptedException, KeeperException
{    PathUtils.validatePath(pathRoot);    List<String> tree = listSubTreeBFS(zk, pathRoot);        for (int i = tree.size() - 1; i >= 0; --i) {                        zk.delete(tree.get(i), -1, cb, ctx);    }}
validateFileInput
public static String zookeeper_f3925_0(String filePath)
{    File file = new File(filePath);    if (!file.exists()) {        return "File '" + file.getAbsolutePath() + "' does not exist.";    }    if (!file.canRead()) {        return "Read permission is denied on the file '" + file.getAbsolutePath() + "'";    }    if (file.isDirectory()) {        return "'" + file.getAbsolutePath() + "' is a direcory. it must be a file.";    }    return null;}
listSubTreeBFS
public static List<String> zookeeper_f3926_0(ZooKeeper zk, final String pathRoot) throws KeeperException, InterruptedException
{    Queue<String> queue = new ArrayDeque<>();    List<String> tree = new ArrayList<String>();    queue.add(pathRoot);    tree.add(pathRoot);    while (!queue.isEmpty()) {        String node = queue.poll();        List<String> children = zk.getChildren(node, false);        for (final String child : children) {            final String childPath = node + "/" + child;            queue.add(childPath);            tree.add(childPath);        }    }    return tree;}
visitSubTreeDFS
public static void zookeeper_f3927_0(ZooKeeper zk, final String path, boolean watch, StringCallback cb) throws KeeperException, InterruptedException
{    PathUtils.validatePath(path);    zk.getData(path, watch, null);    cb.processResult(Code.OK.intValue(), path, null, path);    visitSubTreeDFSHelper(zk, path, watch, cb);}
visitSubTreeDFSHelper
private static void zookeeper_f3928_0(ZooKeeper zk, final String path, boolean watch, StringCallback cb) throws KeeperException, InterruptedException
{        final boolean isRoot = path.length() == 1;    try {        List<String> children = zk.getChildren(path, watch, null);        Collections.sort(children);        for (String child : children) {            String childPath = (isRoot ? path : path + "/") + child;            cb.processResult(Code.OK.intValue(), childPath, null, child);        }        for (String child : children) {            String childPath = (isRoot ? path : path + "/") + child;            visitSubTreeDFSHelper(zk, childPath, watch, cb);        }    } catch (KeeperException.NoNodeException e) {                return;    }}
updateServerList
public void zookeeper_f3929_0(String connectString) throws IOException
{    ConnectStringParser connectStringParser = new ConnectStringParser(connectString);    Collection<InetSocketAddress> serverAddresses = connectStringParser.getServerAddresses();    ClientCnxnSocket clientCnxnSocket = cnxn.sendThread.getClientCnxnSocket();    InetSocketAddress currentHost = (InetSocketAddress) clientCnxnSocket.getRemoteSocketAddress();    boolean reconfigMode = hostProvider.updateServerList(serverAddresses, currentHost);        if (reconfigMode) {        clientCnxnSocket.testableCloseSocket();    }}
getSaslClient
public ZooKeeperSaslClient zookeeper_f3930_0()
{    return cnxn.zooKeeperSaslClient;}
getClientConfig
public ZKClientConfig zookeeper_f3931_0()
{    return clientConfig;}
getDataWatches
protected List<String> zookeeper_f3932_0()
{    synchronized (watchManager.dataWatches) {        List<String> rc = new ArrayList<String>(watchManager.dataWatches.keySet());        return rc;    }}
getExistWatches
protected List<String> zookeeper_f3933_0()
{    synchronized (watchManager.existWatches) {        List<String> rc = new ArrayList<String>(watchManager.existWatches.keySet());        return rc;    }}
getChildWatches
protected List<String> zookeeper_f3934_0()
{    synchronized (watchManager.childWatches) {        List<String> rc = new ArrayList<String>(watchManager.childWatches.keySet());        return rc;    }}
addTo
private void zookeeper_f3935_0(Set<Watcher> from, Set<Watcher> to)
{    if (from != null) {        to.addAll(from);    }}
removeWatcher
public Map<EventType, Set<Watcher>> zookeeper_f3936_0(String clientPath, Watcher watcher, WatcherType watcherType, boolean local, int rc) throws KeeperException
{            containsWatcher(clientPath, watcher, watcherType);    Map<EventType, Set<Watcher>> removedWatchers = new HashMap<>();    HashSet<Watcher> childWatchersToRem = new HashSet<>();    removedWatchers.put(EventType.ChildWatchRemoved, childWatchersToRem);    HashSet<Watcher> dataWatchersToRem = new HashSet<>();    removedWatchers.put(EventType.DataWatchRemoved, dataWatchersToRem);    boolean removedWatcher = false;    switch(watcherType) {        case Children:            {                synchronized (childWatches) {                    removedWatcher = removeWatches(childWatches, watcher, clientPath, local, rc, childWatchersToRem);                }                break;            }        case Data:            {                synchronized (dataWatches) {                    removedWatcher = removeWatches(dataWatches, watcher, clientPath, local, rc, dataWatchersToRem);                }                synchronized (existWatches) {                    boolean removedDataWatcher = removeWatches(existWatches, watcher, clientPath, local, rc, dataWatchersToRem);                    removedWatcher |= removedDataWatcher;                }                break;            }        case Any:            {                synchronized (childWatches) {                    removedWatcher = removeWatches(childWatches, watcher, clientPath, local, rc, childWatchersToRem);                }                synchronized (dataWatches) {                    boolean removedDataWatcher = removeWatches(dataWatches, watcher, clientPath, local, rc, dataWatchersToRem);                    removedWatcher |= removedDataWatcher;                }                synchronized (existWatches) {                    boolean removedDataWatcher = removeWatches(existWatches, watcher, clientPath, local, rc, dataWatchersToRem);                    removedWatcher |= removedDataWatcher;                }            }    }        if (!removedWatcher) {        throw new KeeperException.NoWatcherException(clientPath);    }    return removedWatchers;}
contains
private boolean zookeeper_f3937_0(String path, Watcher watcherObj, Map<String, Set<Watcher>> pathVsWatchers)
{    boolean watcherExists = true;    if (pathVsWatchers == null || pathVsWatchers.size() == 0) {        watcherExists = false;    } else {        Set<Watcher> watchers = pathVsWatchers.get(path);        if (watchers == null) {            watcherExists = false;        } else if (watcherObj == null) {            watcherExists = watchers.size() > 0;        } else {            watcherExists = watchers.contains(watcherObj);        }    }    return watcherExists;}
containsWatcher
 void zookeeper_f3938_0(String path, Watcher watcher, WatcherType watcherType) throws NoWatcherException
{    boolean containsWatcher = false;    switch(watcherType) {        case Children:            {                synchronized (childWatches) {                    containsWatcher = contains(path, watcher, childWatches);                }                break;            }        case Data:            {                synchronized (dataWatches) {                    containsWatcher = contains(path, watcher, dataWatches);                }                synchronized (existWatches) {                    boolean contains_temp = contains(path, watcher, existWatches);                    containsWatcher |= contains_temp;                }                break;            }        case Any:            {                synchronized (childWatches) {                    containsWatcher = contains(path, watcher, childWatches);                }                synchronized (dataWatches) {                    boolean contains_temp = contains(path, watcher, dataWatches);                    containsWatcher |= contains_temp;                }                synchronized (existWatches) {                    boolean contains_temp = contains(path, watcher, existWatches);                    containsWatcher |= contains_temp;                }            }    }        if (!containsWatcher) {        throw new KeeperException.NoWatcherException(path);    }}
removeWatches
protected boolean zookeeper_f3939_0(Map<String, Set<Watcher>> pathVsWatcher, Watcher watcher, String path, boolean local, int rc, Set<Watcher> removedWatchers) throws KeeperException
{    if (!local && rc != Code.OK.intValue()) {        throw KeeperException.create(KeeperException.Code.get(rc), path);    }    boolean success = false;        if (rc == Code.OK.intValue() || (local && rc != Code.OK.intValue())) {                if (watcher == null) {            Set<Watcher> pathWatchers = pathVsWatcher.remove(path);            if (pathWatchers != null) {                                removedWatchers.addAll(pathWatchers);                success = true;            }        } else {            Set<Watcher> watchers = pathVsWatcher.get(path);            if (watchers != null) {                if (watchers.remove(watcher)) {                                        removedWatchers.add(watcher);                                        if (watchers.size() <= 0) {                        pathVsWatcher.remove(path);                    }                    success = true;                }            }        }    }    return success;}
materialize
public Set<Watcher>f3940_1Watcher.Event.KeeperState state, Watcher.Event.EventType type, String clientPath)
{    Set<Watcher> result = new HashSet<Watcher>();    switch(type) {        case None:            result.add(defaultWatcher);            boolean clear = disableAutoWatchReset && state != Watcher.Event.KeeperState.SyncConnected;            synchronized (dataWatches) {                for (Set<Watcher> ws : dataWatches.values()) {                    result.addAll(ws);                }                if (clear) {                    dataWatches.clear();                }            }            synchronized (existWatches) {                for (Set<Watcher> ws : existWatches.values()) {                    result.addAll(ws);                }                if (clear) {                    existWatches.clear();                }            }            synchronized (childWatches) {                for (Set<Watcher> ws : childWatches.values()) {                    result.addAll(ws);                }                if (clear) {                    childWatches.clear();                }            }            return result;        case NodeDataChanged:        case NodeCreated:            synchronized (dataWatches) {                addTo(dataWatches.remove(clientPath), result);            }            synchronized (existWatches) {                addTo(existWatches.remove(clientPath), result);            }            break;        case NodeChildrenChanged:            synchronized (childWatches) {                addTo(childWatches.remove(clientPath), result);            }            break;        case NodeDeleted:            synchronized (dataWatches) {                addTo(dataWatches.remove(clientPath), result);            }                        synchronized (existWatches) {                Set<Watcher> list = existWatches.remove(clientPath);                if (list != null) {                    addTo(list, result);                                    }            }            synchronized (childWatches) {                addTo(childWatches.remove(clientPath), result);            }            break;        default:            String msg = "Unhandled watch event type " + type + " with state " + state + " on path " + clientPath;                        throw new RuntimeException(msg);    }    return result;}
register
public void zookeeper_f3941_0(int rc)
{    if (shouldAddWatch(rc)) {        Map<String, Set<Watcher>> watches = getWatches(rc);        synchronized (watches) {            Set<Watcher> watchers = watches.get(clientPath);            if (watchers == null) {                watchers = new HashSet<Watcher>();                watches.put(clientPath, watchers);            }            watchers.add(watcher);        }    }}
shouldAddWatch
protected boolean zookeeper_f3942_0(int rc)
{    return rc == 0;}
getWatches
protected Map<String, Set<Watcher>> zookeeper_f3943_0(int rc)
{    return rc == 0 ? watchManager.dataWatches : watchManager.existWatches;}
shouldAddWatch
protected boolean zookeeper_f3944_0(int rc)
{    return rc == 0 || rc == KeeperException.Code.NONODE.intValue();}
getWatches
protected Map<String, Set<Watcher>> zookeeper_f3945_0(int rc)
{    return watchManager.dataWatches;}
getWatches
protected Map<String, Set<Watcher>> zookeeper_f3946_0(int rc)
{    return watchManager.childWatches;}
isAlive
public boolean zookeeper_f3947_0()
{    return this != CLOSED && this != AUTH_FAILED;}
isConnected
public boolean zookeeper_f3948_0()
{    return this == CONNECTED || this == CONNECTEDREADONLY;}
createConnection
protected ClientCnxn zookeeper_f3949_0(String chrootPath, HostProvider hostProvider, int sessionTimeout, ZooKeeper zooKeeper, ClientWatchManager watcher, ClientCnxnSocket clientCnxnSocket, boolean canBeReadOnly) throws IOException
{    return new ClientCnxn(chrootPath, hostProvider, sessionTimeout, this, watchManager, clientCnxnSocket, canBeReadOnly);}
createDefaultHostProvider
private static HostProvider zookeeper_f3950_0(String connectString)
{    return new StaticHostProvider(new ConnectStringParser(connectString).getServerAddresses());}
getTestable
public Testable zookeeper_f3951_0()
{    return new ZooKeeperTestable(cnxn);}
defaultWatchManager
protected ZKWatchManager zookeeper_f3952_0()
{    return new ZKWatchManager(getClientConfig().getBoolean(ZKClientConfig.DISABLE_AUTO_WATCH_RESET));}
getSessionId
public long zookeeper_f3953_0()
{    return cnxn.getSessionId();}
getSessionPasswd
public byte[] zookeeper_f3954_0()
{    return cnxn.getSessionPasswd();}
getSessionTimeout
public int zookeeper_f3955_0()
{    return cnxn.getSessionTimeout();}
addAuthInfo
public void zookeeper_f3956_0(String scheme, byte[] auth)
{    cnxn.addAuthInfo(scheme, auth);}
register
public synchronized void zookeeper_f3957_0(Watcher watcher)
{    watchManager.defaultWatcher = watcher;}
close
public synchronized voidf3958_1) throws InterruptedException
{    if (!cnxn.getState().isAlive()) {                return;    }    if (LOG.isDebugEnabled()) {            }    try {        cnxn.close();    } catch (IOException e) {            }    }
close
public boolean zookeeper_f3959_0(int waitForShutdownTimeoutMs) throws InterruptedException
{    close();    return testableWaitForShutdown(waitForShutdownTimeoutMs);}
prependChroot
private String zookeeper_f3960_0(String clientPath)
{    if (cnxn.chrootPath != null) {                if (clientPath.length() == 1) {            return cnxn.chrootPath;        }        return cnxn.chrootPath + clientPath;    } else {        return clientPath;    }}
create
public String zookeeper_f3961_0(final String path, byte[] data, List<ACL> acl, CreateMode createMode) throws KeeperException, InterruptedException
{    final String clientPath = path;    PathUtils.validatePath(clientPath, createMode.isSequential());    EphemeralType.validateTTL(createMode, -1);    validateACL(acl);    final String serverPath = prependChroot(clientPath);    RequestHeader h = new RequestHeader();    h.setType(createMode.isContainer() ? ZooDefs.OpCode.createContainer : ZooDefs.OpCode.create);    CreateRequest request = new CreateRequest();    CreateResponse response = new CreateResponse();    request.setData(data);    request.setFlags(createMode.toFlag());    request.setPath(serverPath);    request.setAcl(acl);    ReplyHeader r = cnxn.submitRequest(h, request, response, null);    if (r.getErr() != 0) {        throw KeeperException.create(KeeperException.Code.get(r.getErr()), clientPath);    }    if (cnxn.chrootPath == null) {        return response.getPath();    } else {        return response.getPath().substring(cnxn.chrootPath.length());    }}
create
public String zookeeper_f3962_0(final String path, byte[] data, List<ACL> acl, CreateMode createMode, Stat stat) throws KeeperException, InterruptedException
{    return create(path, data, acl, createMode, stat, -1);}
create
public String zookeeper_f3963_0(final String path, byte[] data, List<ACL> acl, CreateMode createMode, Stat stat, long ttl) throws KeeperException, InterruptedException
{    final String clientPath = path;    PathUtils.validatePath(clientPath, createMode.isSequential());    EphemeralType.validateTTL(createMode, ttl);    validateACL(acl);    final String serverPath = prependChroot(clientPath);    RequestHeader h = new RequestHeader();    setCreateHeader(createMode, h);    Create2Response response = new Create2Response();    Record record = makeCreateRecord(createMode, serverPath, data, acl, ttl);    ReplyHeader r = cnxn.submitRequest(h, record, response, null);    if (r.getErr() != 0) {        throw KeeperException.create(KeeperException.Code.get(r.getErr()), clientPath);    }    if (stat != null) {        DataTree.copyStat(response.getStat(), stat);    }    if (cnxn.chrootPath == null) {        return response.getPath();    } else {        return response.getPath().substring(cnxn.chrootPath.length());    }}
setCreateHeader
private void zookeeper_f3964_0(CreateMode createMode, RequestHeader h)
{    if (createMode.isTTL()) {        h.setType(ZooDefs.OpCode.createTTL);    } else {        h.setType(createMode.isContainer() ? ZooDefs.OpCode.createContainer : ZooDefs.OpCode.create2);    }}
makeCreateRecord
private Record zookeeper_f3965_0(CreateMode createMode, String serverPath, byte[] data, List<ACL> acl, long ttl)
{    Record record;    if (createMode.isTTL()) {        CreateTTLRequest request = new CreateTTLRequest();        request.setData(data);        request.setFlags(createMode.toFlag());        request.setPath(serverPath);        request.setAcl(acl);        request.setTtl(ttl);        record = request;    } else {        CreateRequest request = new CreateRequest();        request.setData(data);        request.setFlags(createMode.toFlag());        request.setPath(serverPath);        request.setAcl(acl);        record = request;    }    return record;}
create
public void zookeeper_f3966_0(final String path, byte[] data, List<ACL> acl, CreateMode createMode, StringCallback cb, Object ctx)
{    final String clientPath = path;    PathUtils.validatePath(clientPath, createMode.isSequential());    EphemeralType.validateTTL(createMode, -1);    final String serverPath = prependChroot(clientPath);    RequestHeader h = new RequestHeader();    h.setType(createMode.isContainer() ? ZooDefs.OpCode.createContainer : ZooDefs.OpCode.create);    CreateRequest request = new CreateRequest();    CreateResponse response = new CreateResponse();    ReplyHeader r = new ReplyHeader();    request.setData(data);    request.setFlags(createMode.toFlag());    request.setPath(serverPath);    request.setAcl(acl);    cnxn.queuePacket(h, r, request, response, cb, clientPath, serverPath, ctx, null);}
create
public void zookeeper_f3967_0(final String path, byte[] data, List<ACL> acl, CreateMode createMode, Create2Callback cb, Object ctx)
{    create(path, data, acl, createMode, cb, ctx, -1);}
create
public void zookeeper_f3968_0(final String path, byte[] data, List<ACL> acl, CreateMode createMode, Create2Callback cb, Object ctx, long ttl)
{    final String clientPath = path;    PathUtils.validatePath(clientPath, createMode.isSequential());    EphemeralType.validateTTL(createMode, ttl);    final String serverPath = prependChroot(clientPath);    RequestHeader h = new RequestHeader();    setCreateHeader(createMode, h);    ReplyHeader r = new ReplyHeader();    Create2Response response = new Create2Response();    Record record = makeCreateRecord(createMode, serverPath, data, acl, ttl);    cnxn.queuePacket(h, r, record, response, cb, clientPath, serverPath, ctx, null);}
delete
public void zookeeper_f3969_0(final String path, int version) throws InterruptedException, KeeperException
{    final String clientPath = path;    PathUtils.validatePath(clientPath);    final String serverPath;        if (clientPath.equals("/")) {                        serverPath = clientPath;    } else {        serverPath = prependChroot(clientPath);    }    RequestHeader h = new RequestHeader();    h.setType(ZooDefs.OpCode.delete);    DeleteRequest request = new DeleteRequest();    request.setPath(serverPath);    request.setVersion(version);    ReplyHeader r = cnxn.submitRequest(h, request, null, null);    if (r.getErr() != 0) {        throw KeeperException.create(KeeperException.Code.get(r.getErr()), clientPath);    }}
multi
public List<OpResult> zookeeper_f3970_0(Iterable<Op> ops) throws InterruptedException, KeeperException
{    for (Op op : ops) {        op.validate();    }    return multiInternal(generateMultiTransaction(ops));}
multi
public void zookeeper_f3971_0(Iterable<Op> ops, MultiCallback cb, Object ctx)
{    List<OpResult> results = validatePath(ops);    if (results.size() > 0) {        cb.processResult(KeeperException.Code.BADARGUMENTS.intValue(), null, ctx, results);        return;    }    multiInternal(generateMultiTransaction(ops), cb, ctx);}
validatePath
private List<OpResult>f3972_1Iterable<Op> ops)
{    List<OpResult> results = new ArrayList<OpResult>();    boolean error = false;    for (Op op : ops) {        try {            op.validate();        } catch (IllegalArgumentException iae) {                        ErrorResult err = new ErrorResult(KeeperException.Code.BADARGUMENTS.intValue());            results.add(err);            error = true;            continue;        } catch (KeeperException ke) {                        ErrorResult err = new ErrorResult(ke.code().intValue());            results.add(err);            error = true;            continue;        }        ErrorResult err = new ErrorResult(KeeperException.Code.RUNTIMEINCONSISTENCY.intValue());        results.add(err);    }    if (!error) {        results.clear();    }    return results;}
generateMultiTransaction
private MultiOperationRecord zookeeper_f3973_0(Iterable<Op> ops)
{        List<Op> transaction = new ArrayList<Op>();    for (Op op : ops) {        transaction.add(withRootPrefix(op));    }    return new MultiOperationRecord(transaction);}
withRootPrefix
private Op zookeeper_f3974_0(Op op)
{    if (null != op.getPath()) {        final String serverPath = prependChroot(op.getPath());        if (!op.getPath().equals(serverPath)) {            return op.withChroot(serverPath);        }    }    return op;}
multiInternal
protected void zookeeper_f3975_0(MultiOperationRecord request, MultiCallback cb, Object ctx) throws IllegalArgumentException
{    RequestHeader h = new RequestHeader();    switch(request.getOpKind()) {        case TRANSACTION:            h.setType(ZooDefs.OpCode.multi);            break;        case READ:            h.setType(ZooDefs.OpCode.multiRead);            break;        default:            throw new IllegalArgumentException("Unsupported OpKind: " + request.getOpKind());    }    MultiResponse response = new MultiResponse();    cnxn.queuePacket(h, new ReplyHeader(), request, response, cb, null, null, ctx, null);}
multiInternal
protected List<OpResult> zookeeper_f3976_0(MultiOperationRecord request) throws InterruptedException, KeeperException, IllegalArgumentException
{    RequestHeader h = new RequestHeader();    switch(request.getOpKind()) {        case TRANSACTION:            h.setType(ZooDefs.OpCode.multi);            break;        case READ:            h.setType(ZooDefs.OpCode.multiRead);            break;        default:            throw new IllegalArgumentException("Unsupported OpKind: " + request.getOpKind());    }    MultiResponse response = new MultiResponse();    ReplyHeader r = cnxn.submitRequest(h, request, response, null);    if (r.getErr() != 0) {        throw KeeperException.create(KeeperException.Code.get(r.getErr()));    }    List<OpResult> results = response.getResultList();        if (request.getOpKind() == Op.OpKind.READ) {        return results;    }    ErrorResult fatalError = null;    for (OpResult result : results) {        if (result instanceof ErrorResult && ((ErrorResult) result).getErr() != KeeperException.Code.OK.intValue()) {            fatalError = (ErrorResult) result;            break;        }    }    if (fatalError != null) {        KeeperException ex = KeeperException.create(KeeperException.Code.get(fatalError.getErr()));        ex.setMultiResults(results);        throw ex;    }    return results;}
transaction
public Transaction zookeeper_f3977_0()
{    return new Transaction(this);}
delete
public void zookeeper_f3978_0(final String path, int version, VoidCallback cb, Object ctx)
{    final String clientPath = path;    PathUtils.validatePath(clientPath);    final String serverPath;        if (clientPath.equals("/")) {                        serverPath = clientPath;    } else {        serverPath = prependChroot(clientPath);    }    RequestHeader h = new RequestHeader();    h.setType(ZooDefs.OpCode.delete);    DeleteRequest request = new DeleteRequest();    request.setPath(serverPath);    request.setVersion(version);    cnxn.queuePacket(h, new ReplyHeader(), request, null, cb, clientPath, serverPath, ctx, null);}
exists
public Stat zookeeper_f3979_0(final String path, Watcher watcher) throws KeeperException, InterruptedException
{    final String clientPath = path;    PathUtils.validatePath(clientPath);        WatchRegistration wcb = null;    if (watcher != null) {        wcb = new ExistsWatchRegistration(watcher, clientPath);    }    final String serverPath = prependChroot(clientPath);    RequestHeader h = new RequestHeader();    h.setType(ZooDefs.OpCode.exists);    ExistsRequest request = new ExistsRequest();    request.setPath(serverPath);    request.setWatch(watcher != null);    SetDataResponse response = new SetDataResponse();    ReplyHeader r = cnxn.submitRequest(h, request, response, wcb);    if (r.getErr() != 0) {        if (r.getErr() == KeeperException.Code.NONODE.intValue()) {            return null;        }        throw KeeperException.create(KeeperException.Code.get(r.getErr()), clientPath);    }    return response.getStat().getCzxid() == -1 ? null : response.getStat();}
exists
public Stat zookeeper_f3980_0(String path, boolean watch) throws KeeperException, InterruptedException
{    return exists(path, watch ? watchManager.defaultWatcher : null);}
exists
public void zookeeper_f3981_0(final String path, Watcher watcher, StatCallback cb, Object ctx)
{    final String clientPath = path;    PathUtils.validatePath(clientPath);        WatchRegistration wcb = null;    if (watcher != null) {        wcb = new ExistsWatchRegistration(watcher, clientPath);    }    final String serverPath = prependChroot(clientPath);    RequestHeader h = new RequestHeader();    h.setType(ZooDefs.OpCode.exists);    ExistsRequest request = new ExistsRequest();    request.setPath(serverPath);    request.setWatch(watcher != null);    SetDataResponse response = new SetDataResponse();    cnxn.queuePacket(h, new ReplyHeader(), request, response, cb, clientPath, serverPath, ctx, wcb);}
exists
public void zookeeper_f3982_0(String path, boolean watch, StatCallback cb, Object ctx)
{    exists(path, watch ? watchManager.defaultWatcher : null, cb, ctx);}
getData
public byte[] zookeeper_f3983_0(final String path, Watcher watcher, Stat stat) throws KeeperException, InterruptedException
{    final String clientPath = path;    PathUtils.validatePath(clientPath);        WatchRegistration wcb = null;    if (watcher != null) {        wcb = new DataWatchRegistration(watcher, clientPath);    }    final String serverPath = prependChroot(clientPath);    RequestHeader h = new RequestHeader();    h.setType(ZooDefs.OpCode.getData);    GetDataRequest request = new GetDataRequest();    request.setPath(serverPath);    request.setWatch(watcher != null);    GetDataResponse response = new GetDataResponse();    ReplyHeader r = cnxn.submitRequest(h, request, response, wcb);    if (r.getErr() != 0) {        throw KeeperException.create(KeeperException.Code.get(r.getErr()), clientPath);    }    if (stat != null) {        DataTree.copyStat(response.getStat(), stat);    }    return response.getData();}
getData
public byte[] zookeeper_f3984_0(String path, boolean watch, Stat stat) throws KeeperException, InterruptedException
{    return getData(path, watch ? watchManager.defaultWatcher : null, stat);}
getData
public void zookeeper_f3985_0(final String path, Watcher watcher, DataCallback cb, Object ctx)
{    final String clientPath = path;    PathUtils.validatePath(clientPath);        WatchRegistration wcb = null;    if (watcher != null) {        wcb = new DataWatchRegistration(watcher, clientPath);    }    final String serverPath = prependChroot(clientPath);    RequestHeader h = new RequestHeader();    h.setType(ZooDefs.OpCode.getData);    GetDataRequest request = new GetDataRequest();    request.setPath(serverPath);    request.setWatch(watcher != null);    GetDataResponse response = new GetDataResponse();    cnxn.queuePacket(h, new ReplyHeader(), request, response, cb, clientPath, serverPath, ctx, wcb);}
getData
public void zookeeper_f3986_0(String path, boolean watch, DataCallback cb, Object ctx)
{    getData(path, watch ? watchManager.defaultWatcher : null, cb, ctx);}
getConfig
public byte[] zookeeper_f3987_0(Watcher watcher, Stat stat) throws KeeperException, InterruptedException
{    final String configZnode = ZooDefs.CONFIG_NODE;        WatchRegistration wcb = null;    if (watcher != null) {        wcb = new DataWatchRegistration(watcher, configZnode);    }    RequestHeader h = new RequestHeader();    h.setType(ZooDefs.OpCode.getData);    GetDataRequest request = new GetDataRequest();    request.setPath(configZnode);    request.setWatch(watcher != null);    GetDataResponse response = new GetDataResponse();    ReplyHeader r = cnxn.submitRequest(h, request, response, wcb);    if (r.getErr() != 0) {        throw KeeperException.create(KeeperException.Code.get(r.getErr()), configZnode);    }    if (stat != null) {        DataTree.copyStat(response.getStat(), stat);    }    return response.getData();}
getConfig
public void zookeeper_f3988_0(Watcher watcher, DataCallback cb, Object ctx)
{    final String configZnode = ZooDefs.CONFIG_NODE;        WatchRegistration wcb = null;    if (watcher != null) {        wcb = new DataWatchRegistration(watcher, configZnode);    }    RequestHeader h = new RequestHeader();    h.setType(ZooDefs.OpCode.getData);    GetDataRequest request = new GetDataRequest();    request.setPath(configZnode);    request.setWatch(watcher != null);    GetDataResponse response = new GetDataResponse();    cnxn.queuePacket(h, new ReplyHeader(), request, response, cb, configZnode, configZnode, ctx, wcb);}
getConfig
public byte[] zookeeper_f3989_0(boolean watch, Stat stat) throws KeeperException, InterruptedException
{    return getConfig(watch ? watchManager.defaultWatcher : null, stat);}
getConfig
public void zookeeper_f3990_0(boolean watch, DataCallback cb, Object ctx)
{    getConfig(watch ? watchManager.defaultWatcher : null, cb, ctx);}
setData
public Stat zookeeper_f3991_0(final String path, byte[] data, int version) throws KeeperException, InterruptedException
{    final String clientPath = path;    PathUtils.validatePath(clientPath);    final String serverPath = prependChroot(clientPath);    RequestHeader h = new RequestHeader();    h.setType(ZooDefs.OpCode.setData);    SetDataRequest request = new SetDataRequest();    request.setPath(serverPath);    request.setData(data);    request.setVersion(version);    SetDataResponse response = new SetDataResponse();    ReplyHeader r = cnxn.submitRequest(h, request, response, null);    if (r.getErr() != 0) {        throw KeeperException.create(KeeperException.Code.get(r.getErr()), clientPath);    }    return response.getStat();}
setData
public void zookeeper_f3992_0(final String path, byte[] data, int version, StatCallback cb, Object ctx)
{    final String clientPath = path;    PathUtils.validatePath(clientPath);    final String serverPath = prependChroot(clientPath);    RequestHeader h = new RequestHeader();    h.setType(ZooDefs.OpCode.setData);    SetDataRequest request = new SetDataRequest();    request.setPath(serverPath);    request.setData(data);    request.setVersion(version);    SetDataResponse response = new SetDataResponse();    cnxn.queuePacket(h, new ReplyHeader(), request, response, cb, clientPath, serverPath, ctx, null);}
getACL
public List<ACL> zookeeper_f3993_0(final String path, Stat stat) throws KeeperException, InterruptedException
{    final String clientPath = path;    PathUtils.validatePath(clientPath);    final String serverPath = prependChroot(clientPath);    RequestHeader h = new RequestHeader();    h.setType(ZooDefs.OpCode.getACL);    GetACLRequest request = new GetACLRequest();    request.setPath(serverPath);    GetACLResponse response = new GetACLResponse();    ReplyHeader r = cnxn.submitRequest(h, request, response, null);    if (r.getErr() != 0) {        throw KeeperException.create(KeeperException.Code.get(r.getErr()), clientPath);    }    if (stat != null) {        DataTree.copyStat(response.getStat(), stat);    }    return response.getAcl();}
getACL
public void zookeeper_f3994_0(final String path, Stat stat, ACLCallback cb, Object ctx)
{    final String clientPath = path;    PathUtils.validatePath(clientPath);    final String serverPath = prependChroot(clientPath);    RequestHeader h = new RequestHeader();    h.setType(ZooDefs.OpCode.getACL);    GetACLRequest request = new GetACLRequest();    request.setPath(serverPath);    GetACLResponse response = new GetACLResponse();    cnxn.queuePacket(h, new ReplyHeader(), request, response, cb, clientPath, serverPath, ctx, null);}
setACL
public Stat zookeeper_f3995_0(final String path, List<ACL> acl, int aclVersion) throws KeeperException, InterruptedException
{    final String clientPath = path;    PathUtils.validatePath(clientPath);    validateACL(acl);    final String serverPath = prependChroot(clientPath);    RequestHeader h = new RequestHeader();    h.setType(ZooDefs.OpCode.setACL);    SetACLRequest request = new SetACLRequest();    request.setPath(serverPath);    request.setAcl(acl);    request.setVersion(aclVersion);    SetACLResponse response = new SetACLResponse();    ReplyHeader r = cnxn.submitRequest(h, request, response, null);    if (r.getErr() != 0) {        throw KeeperException.create(KeeperException.Code.get(r.getErr()), clientPath);    }    return response.getStat();}
setACL
public void zookeeper_f3996_0(final String path, List<ACL> acl, int version, StatCallback cb, Object ctx)
{    final String clientPath = path;    PathUtils.validatePath(clientPath);    final String serverPath = prependChroot(clientPath);    RequestHeader h = new RequestHeader();    h.setType(ZooDefs.OpCode.setACL);    SetACLRequest request = new SetACLRequest();    request.setPath(serverPath);    request.setAcl(acl);    request.setVersion(version);    SetACLResponse response = new SetACLResponse();    cnxn.queuePacket(h, new ReplyHeader(), request, response, cb, clientPath, serverPath, ctx, null);}
getChildren
public List<String> zookeeper_f3997_0(final String path, Watcher watcher) throws KeeperException, InterruptedException
{    final String clientPath = path;    PathUtils.validatePath(clientPath);        WatchRegistration wcb = null;    if (watcher != null) {        wcb = new ChildWatchRegistration(watcher, clientPath);    }    final String serverPath = prependChroot(clientPath);    RequestHeader h = new RequestHeader();    h.setType(ZooDefs.OpCode.getChildren);    GetChildrenRequest request = new GetChildrenRequest();    request.setPath(serverPath);    request.setWatch(watcher != null);    GetChildrenResponse response = new GetChildrenResponse();    ReplyHeader r = cnxn.submitRequest(h, request, response, wcb);    if (r.getErr() != 0) {        throw KeeperException.create(KeeperException.Code.get(r.getErr()), clientPath);    }    return response.getChildren();}
getChildren
public List<String> zookeeper_f3998_0(String path, boolean watch) throws KeeperException, InterruptedException
{    return getChildren(path, watch ? watchManager.defaultWatcher : null);}
getChildren
public void zookeeper_f3999_0(final String path, Watcher watcher, ChildrenCallback cb, Object ctx)
{    final String clientPath = path;    PathUtils.validatePath(clientPath);        WatchRegistration wcb = null;    if (watcher != null) {        wcb = new ChildWatchRegistration(watcher, clientPath);    }    final String serverPath = prependChroot(clientPath);    RequestHeader h = new RequestHeader();    h.setType(ZooDefs.OpCode.getChildren);    GetChildrenRequest request = new GetChildrenRequest();    request.setPath(serverPath);    request.setWatch(watcher != null);    GetChildrenResponse response = new GetChildrenResponse();    cnxn.queuePacket(h, new ReplyHeader(), request, response, cb, clientPath, serverPath, ctx, wcb);}
getChildren
public void zookeeper_f4000_0(String path, boolean watch, ChildrenCallback cb, Object ctx)
{    getChildren(path, watch ? watchManager.defaultWatcher : null, cb, ctx);}
getChildren
public List<String> zookeeper_f4001_0(final String path, Watcher watcher, Stat stat) throws KeeperException, InterruptedException
{    final String clientPath = path;    PathUtils.validatePath(clientPath);        WatchRegistration wcb = null;    if (watcher != null) {        wcb = new ChildWatchRegistration(watcher, clientPath);    }    final String serverPath = prependChroot(clientPath);    RequestHeader h = new RequestHeader();    h.setType(ZooDefs.OpCode.getChildren2);    GetChildren2Request request = new GetChildren2Request();    request.setPath(serverPath);    request.setWatch(watcher != null);    GetChildren2Response response = new GetChildren2Response();    ReplyHeader r = cnxn.submitRequest(h, request, response, wcb);    if (r.getErr() != 0) {        throw KeeperException.create(KeeperException.Code.get(r.getErr()), clientPath);    }    if (stat != null) {        DataTree.copyStat(response.getStat(), stat);    }    return response.getChildren();}
getChildren
public List<String> zookeeper_f4002_0(String path, boolean watch, Stat stat) throws KeeperException, InterruptedException
{    return getChildren(path, watch ? watchManager.defaultWatcher : null, stat);}
getChildren
public void zookeeper_f4003_0(final String path, Watcher watcher, Children2Callback cb, Object ctx)
{    final String clientPath = path;    PathUtils.validatePath(clientPath);        WatchRegistration wcb = null;    if (watcher != null) {        wcb = new ChildWatchRegistration(watcher, clientPath);    }    final String serverPath = prependChroot(clientPath);    RequestHeader h = new RequestHeader();    h.setType(ZooDefs.OpCode.getChildren2);    GetChildren2Request request = new GetChildren2Request();    request.setPath(serverPath);    request.setWatch(watcher != null);    GetChildren2Response response = new GetChildren2Response();    cnxn.queuePacket(h, new ReplyHeader(), request, response, cb, clientPath, serverPath, ctx, wcb);}
getChildren
public void zookeeper_f4004_0(String path, boolean watch, Children2Callback cb, Object ctx)
{    getChildren(path, watch ? watchManager.defaultWatcher : null, cb, ctx);}
getAllChildrenNumber
public int zookeeper_f4005_0(final String path) throws KeeperException, InterruptedException
{    final String clientPath = path;    PathUtils.validatePath(clientPath);    final String serverPath = prependChroot(clientPath);    RequestHeader h = new RequestHeader();    h.setType(ZooDefs.OpCode.getAllChildrenNumber);    GetAllChildrenNumberRequest request = new GetAllChildrenNumberRequest(serverPath);    GetAllChildrenNumberResponse response = new GetAllChildrenNumberResponse();    ReplyHeader r = cnxn.submitRequest(h, request, response, null);    if (r.getErr() != 0) {        throw KeeperException.create(KeeperException.Code.get(r.getErr()), clientPath);    }    return response.getTotalNumber();}
getAllChildrenNumber
public void zookeeper_f4006_0(final String path, AsyncCallback.AllChildrenNumberCallback cb, Object ctx)
{    final String clientPath = path;    PathUtils.validatePath(clientPath);    final String serverPath = prependChroot(clientPath);    RequestHeader h = new RequestHeader();    h.setType(ZooDefs.OpCode.getAllChildrenNumber);    GetAllChildrenNumberRequest request = new GetAllChildrenNumberRequest(serverPath);    GetAllChildrenNumberResponse response = new GetAllChildrenNumberResponse();    cnxn.queuePacket(h, new ReplyHeader(), request, response, cb, clientPath, serverPath, ctx, null);}
getEphemerals
public List<String> zookeeper_f4007_0() throws KeeperException, InterruptedException
{    return getEphemerals("/");}
getEphemerals
public List<String> zookeeper_f4008_0(String prefixPath) throws KeeperException, InterruptedException
{    PathUtils.validatePath(prefixPath);    RequestHeader h = new RequestHeader();    h.setType(ZooDefs.OpCode.getEphemerals);    GetEphemeralsRequest request = new GetEphemeralsRequest(prefixPath);    GetEphemeralsResponse response = new GetEphemeralsResponse();    ReplyHeader r = cnxn.submitRequest(h, request, response, null);    if (r.getErr() != 0) {        throw KeeperException.create(KeeperException.Code.get(r.getErr()));    }    return response.getEphemerals();}
getEphemerals
public void zookeeper_f4009_0(String prefixPath, AsyncCallback.EphemeralsCallback cb, Object ctx)
{    PathUtils.validatePath(prefixPath);    RequestHeader h = new RequestHeader();    h.setType(ZooDefs.OpCode.getEphemerals);    GetEphemeralsRequest request = new GetEphemeralsRequest(prefixPath);    GetEphemeralsResponse response = new GetEphemeralsResponse();    cnxn.queuePacket(h, new ReplyHeader(), request, response, cb, null, null, ctx, null);}
getEphemerals
public void zookeeper_f4010_0(AsyncCallback.EphemeralsCallback cb, Object ctx)
{    getEphemerals("/", cb, ctx);}
sync
public void zookeeper_f4011_0(final String path, VoidCallback cb, Object ctx)
{    final String clientPath = path;    PathUtils.validatePath(clientPath);    final String serverPath = prependChroot(clientPath);    RequestHeader h = new RequestHeader();    h.setType(ZooDefs.OpCode.sync);    SyncRequest request = new SyncRequest();    SyncResponse response = new SyncResponse();    request.setPath(serverPath);    cnxn.queuePacket(h, new ReplyHeader(), request, response, cb, clientPath, serverPath, ctx, null);}
removeWatches
public void zookeeper_f4012_0(String path, Watcher watcher, WatcherType watcherType, boolean local) throws InterruptedException, KeeperException
{    validateWatcher(watcher);    removeWatches(ZooDefs.OpCode.checkWatches, path, watcher, watcherType, local);}
removeWatches
public void zookeeper_f4013_0(String path, Watcher watcher, WatcherType watcherType, boolean local, VoidCallback cb, Object ctx)
{    validateWatcher(watcher);    removeWatches(ZooDefs.OpCode.checkWatches, path, watcher, watcherType, local, cb, ctx);}
removeAllWatches
public void zookeeper_f4014_0(String path, WatcherType watcherType, boolean local) throws InterruptedException, KeeperException
{    removeWatches(ZooDefs.OpCode.removeWatches, path, null, watcherType, local);}
removeAllWatches
public void zookeeper_f4015_0(String path, WatcherType watcherType, boolean local, VoidCallback cb, Object ctx)
{    removeWatches(ZooDefs.OpCode.removeWatches, path, null, watcherType, local, cb, ctx);}
validateWatcher
private void zookeeper_f4016_0(Watcher watcher)
{    if (watcher == null) {        throw new IllegalArgumentException("Invalid Watcher, shouldn't be null!");    }}
removeWatches
private void zookeeper_f4017_0(int opCode, String path, Watcher watcher, WatcherType watcherType, boolean local) throws InterruptedException, KeeperException
{    PathUtils.validatePath(path);    final String clientPath = path;    final String serverPath = prependChroot(clientPath);    WatchDeregistration wcb = new WatchDeregistration(clientPath, watcher, watcherType, local, watchManager);    RequestHeader h = new RequestHeader();    h.setType(opCode);    Record request = getRemoveWatchesRequest(opCode, watcherType, serverPath);    ReplyHeader r = cnxn.submitRequest(h, request, null, null, wcb);    if (r.getErr() != 0) {        throw KeeperException.create(KeeperException.Code.get(r.getErr()), clientPath);    }}
removeWatches
private void zookeeper_f4018_0(int opCode, String path, Watcher watcher, WatcherType watcherType, boolean local, VoidCallback cb, Object ctx)
{    PathUtils.validatePath(path);    final String clientPath = path;    final String serverPath = prependChroot(clientPath);    WatchDeregistration wcb = new WatchDeregistration(clientPath, watcher, watcherType, local, watchManager);    RequestHeader h = new RequestHeader();    h.setType(opCode);    Record request = getRemoveWatchesRequest(opCode, watcherType, serverPath);    cnxn.queuePacket(h, new ReplyHeader(), request, null, cb, clientPath, serverPath, ctx, null, wcb);}
getRemoveWatchesRequest
private Recordf4019_1int opCode, WatcherType watcherType, final String serverPath)
{    Record request = null;    switch(opCode) {        case ZooDefs.OpCode.checkWatches:            CheckWatchesRequest chkReq = new CheckWatchesRequest();            chkReq.setPath(serverPath);            chkReq.setType(watcherType.getIntValue());            request = chkReq;            break;        case ZooDefs.OpCode.removeWatches:            RemoveWatchesRequest rmReq = new RemoveWatchesRequest();            rmReq.setPath(serverPath);            rmReq.setType(watcherType.getIntValue());            request = rmReq;            break;        default:                        break;    }    return request;}
getState
public States zookeeper_f4020_0()
{    return cnxn.getState();}
toString
public String zookeeper_f4021_0()
{    States state = getState();    return ("State:" + state.toString() + (state.isConnected() ? " Timeout:" + getSessionTimeout() + " " : " ") + cnxn);}
testableWaitForShutdown
protected boolean zookeeper_f4022_0(int wait) throws InterruptedException
{    cnxn.sendThread.join(wait);    if (cnxn.sendThread.isAlive()) {        return false;    }    cnxn.eventThread.join(wait);    return !cnxn.eventThread.isAlive();}
testableRemoteSocketAddress
protected SocketAddress zookeeper_f4023_0()
{    return cnxn.sendThread.getClientCnxnSocket().getRemoteSocketAddress();}
testableLocalSocketAddress
protected SocketAddress zookeeper_f4024_0()
{    return cnxn.sendThread.getClientCnxnSocket().getLocalSocketAddress();}
getClientCnxnSocket
private ClientCnxnSocket zookeeper_f4025_0() throws IOException
{    String clientCnxnSocketName = getClientConfig().getProperty(ZKClientConfig.ZOOKEEPER_CLIENT_CNXN_SOCKET);    if (clientCnxnSocketName == null) {        clientCnxnSocketName = ClientCnxnSocketNIO.class.getName();    }    try {        Constructor<?> clientCxnConstructor = Class.forName(clientCnxnSocketName).getDeclaredConstructor(ZKClientConfig.class);        ClientCnxnSocket clientCxnSocket = (ClientCnxnSocket) clientCxnConstructor.newInstance(getClientConfig());        return clientCxnSocket;    } catch (Exception e) {        throw new IOException("Couldn't instantiate " + clientCnxnSocketName, e);    }}
validateACL
private void zookeeper_f4026_0(List<ACL> acl) throws KeeperException.InvalidACLException
{    if (acl == null || acl.isEmpty() || acl.contains(null)) {        throw new KeeperException.InvalidACLException();    }}
printBanner
public static voidf4027_1Logger log)
{    for (String line : BANNER) {            }}
getPrintWatches
public boolean zookeeper_f4028_0()
{    return printWatches;}
usage
 static void zookeeper_f4029_0()
{    System.err.println("ZooKeeper -server host:port cmd args");    List<String> cmdList = new ArrayList<String>(commandMap.keySet());    Collections.sort(cmdList);    for (String cmd : cmdList) {        System.err.println("\t" + cmd + " " + commandMap.get(cmd));    }}
process
public void zookeeper_f4030_0(WatchedEvent event)
{    if (getPrintWatches()) {        ZooKeeperMain.printMessage("WATCHER::");        ZooKeeperMain.printMessage(event.toString());    }}
getOption
public String zookeeper_f4031_0(String opt)
{    return options.get(opt);}
getCommand
public String zookeeper_f4032_0()
{    return command;}
getCmdArgument
public String zookeeper_f4033_0(int index)
{    return cmdArgs.get(index);}
getNumArguments
public int zookeeper_f4034_0()
{    return cmdArgs.size();}
getArgArray
public String[] zookeeper_f4035_0()
{    return cmdArgs.toArray(new String[0]);}
parseOptions
public boolean zookeeper_f4036_0(String[] args)
{    List<String> argList = Arrays.asList(args);    Iterator<String> it = argList.iterator();    while (it.hasNext()) {        String opt = it.next();        try {            if (opt.equals("-server")) {                options.put("server", it.next());            } else if (opt.equals("-timeout")) {                options.put("timeout", it.next());            } else if (opt.equals("-r")) {                options.put("readonly", "true");            }        } catch (NoSuchElementException e) {            System.err.println("Error: no argument found for option " + opt);            return false;        }        if (!opt.startsWith("-")) {            command = opt;            cmdArgs = new ArrayList<String>();            cmdArgs.add(command);            while (it.hasNext()) {                cmdArgs.add(it.next());            }            return true;        }    }    return true;}
parseCommand
public boolean zookeeper_f4037_0(String cmdstring)
{    Matcher matcher = ARGS_PATTERN.matcher(cmdstring);    List<String> args = new LinkedList<String>();    while (matcher.find()) {        String value = matcher.group(1);        if (QUOTED_PATTERN.matcher(value).matches()) {                        value = value.substring(1, value.length() - 1);        }        args.add(value);    }    if (args.isEmpty()) {        return false;    }    command = args.get(0);    cmdArgs = args;    return true;}
addToHistory
protected void zookeeper_f4038_0(int i, String cmd)
{    history.put(i, cmd);}
getCommands
public static List<String> zookeeper_f4039_0()
{    List<String> cmdList = new ArrayList<String>(commandMap.keySet());    Collections.sort(cmdList);    return cmdList;}
getPrompt
protected String zookeeper_f4040_0()
{    return "[zk: " + host + "(" + zk.getState() + ")" + " " + commandCount + "] ";}
printMessage
public static void zookeeper_f4041_0(String msg)
{    System.out.println("\n" + msg);}
connectToZK
protected void zookeeper_f4042_0(String newHost) throws InterruptedException, IOException
{    if (zk != null && zk.getState().isAlive()) {        zk.close();    }    host = newHost;    boolean readOnly = cl.getOption("readonly") != null;    if (cl.getOption("secure") != null) {        System.setProperty(ZKClientConfig.SECURE_CLIENT, "true");        System.out.println("Secure connection is enabled");    }    zk = new ZooKeeperAdmin(host, Integer.parseInt(cl.getOption("timeout")), new MyWatcher(), readOnly);}
main
public static void zookeeper_f4043_0(String[] args) throws CliException, IOException, InterruptedException
{    ZooKeeperMain main = new ZooKeeperMain(args);    main.run();}
run
 voidf4044_1) throws CliException, IOException, InterruptedException
{    if (cl.getCommand() == null) {        System.out.println("Welcome to ZooKeeper!");        boolean jlinemissing = false;                try {            Class<?> consoleC = Class.forName("jline.console.ConsoleReader");            Class<?> completorC = Class.forName("org.apache.zookeeper.JLineZNodeCompleter");            System.out.println("JLine support is enabled");            Object console = consoleC.getConstructor().newInstance();            Object completor = completorC.getConstructor(ZooKeeper.class).newInstance(zk);            Method addCompletor = consoleC.getMethod("addCompleter", Class.forName("jline.console.completer.Completer"));            addCompletor.invoke(console, completor);            String line;            Method readLine = consoleC.getMethod("readLine", String.class);            while ((line = (String) readLine.invoke(console, getPrompt())) != null) {                executeLine(line);            }        } catch (ClassNotFoundException e) {                        jlinemissing = true;        } catch (NoSuchMethodException e) {                        jlinemissing = true;        } catch (InvocationTargetException e) {                        jlinemissing = true;        } catch (IllegalAccessException e) {                        jlinemissing = true;        } catch (InstantiationException e) {                        jlinemissing = true;        }        if (jlinemissing) {            System.out.println("JLine support is disabled");            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));            String line;            while ((line = br.readLine()) != null) {                executeLine(line);            }        }    } else {                processCmd(cl);    }    System.exit(exitCode);}
executeLine
public void zookeeper_f4045_0(String line) throws CliException, InterruptedException, IOException
{    if (!line.equals("")) {        cl.parseCommand(line);        addToHistory(commandCount, line);        processCmd(cl);        commandCount++;    }}
processCmd
protected boolean zookeeper_f4046_0(MyCommandOptions co) throws CliException, IOException, InterruptedException
{    boolean watch = false;    try {        watch = processZKCmd(co);        exitCode = ExitCode.EXECUTION_FINISHED.getValue();    } catch (CliException ex) {        exitCode = ex.getExitCode();        System.err.println(ex.getMessage());    }    return watch;}
processZKCmd
protected booleanf4047_1MyCommandOptions co) throws CliException, IOException, InterruptedException
{    String[] args = co.getArgArray();    String cmd = co.getCommand();    if (args.length < 1) {        usage();        throw new MalformedCommandException("No command entered");    }    if (!commandMap.containsKey(cmd)) {        usage();        throw new CommandNotFoundException("Command not found " + cmd);    }    boolean watch = false;        if (cmd.equals("quit")) {        zk.close();        System.exit(exitCode);    } else if (cmd.equals("redo") && args.length >= 2) {        Integer i = Integer.decode(args[1]);        if (commandCount <= i || i < 0) {                        throw new MalformedCommandException("Command index out of range");        }        cl.parseCommand(history.get(i));        if (cl.getCommand().equals("redo")) {            throw new MalformedCommandException("No redoing redos");        }        history.put(commandCount, history.get(i));        processCmd(cl);    } else if (cmd.equals("history")) {        for (int i = commandCount - 10; i <= commandCount; ++i) {            if (i < 0) {                continue;            }            System.out.println(i + " - " + history.get(i));        }    } else if (cmd.equals("printwatches")) {        if (args.length == 1) {            System.out.println("printwatches is " + (printWatches ? "on" : "off"));        } else {            printWatches = args[1].equals("on");        }    } else if (cmd.equals("connect")) {        if (args.length >= 2) {            connectToZK(args[1]);        } else {            connectToZK(host);        }    }        if (zk == null || !zk.getState().isAlive()) {        System.out.println("Not connected");        return false;    }        CliCommand cliCmd = commandMapCli.get(cmd);    if (cliCmd != null) {        cliCmd.setZk(zk);        watch = cliCmd.parse(args).exec();    } else if (!commandMap.containsKey(cmd)) {        usage();    }    return watch;}
injectSessionExpiration
public voidf4048_1)
{        clientCnxn.eventThread.queueEvent(new WatchedEvent(Watcher.Event.EventType.None, Watcher.Event.KeeperState.Expired, null));    clientCnxn.eventThread.queueEventOfDeath();    clientCnxn.state = ZooKeeper.States.CLOSED;    clientCnxn.sendThread.getClientCnxnSocket().onClosing();}
queueEvent
public voidf4049_1WatchedEvent event)
{        clientCnxn.eventThread.queueEvent(event);}
init
public static void zookeeper_f4050_0()
{    if (!testData.exists()) {        testData.mkdirs();    }}
testDefaultConfiguration
public void zookeeper_f4051_0()
{    Map<String, String> properties = new HashMap<>();    properties.put(ZK_SASL_CLIENT_USERNAME, "zookeeper1");    properties.put(LOGIN_CONTEXT_NAME_KEY, "Client1");    properties.put(ENABLE_CLIENT_SASL_KEY, "true");    properties.put(ZOOKEEPER_SERVER_REALM, "zookeeper/hadoop.hadoop.com");    properties.put(DISABLE_AUTO_WATCH_RESET, "true");    properties.put(ZOOKEEPER_CLIENT_CNXN_SOCKET, "ClientCnxnSocketNetty");    properties.put(SECURE_CLIENT, "true");    for (Map.Entry<String, String> e : properties.entrySet()) {        System.setProperty(e.getKey(), e.getValue());    }    /**     * ZKClientConfig should get initialized with system properties     */    ZKClientConfig conf = new ZKClientConfig();    for (Map.Entry<String, String> e : properties.entrySet()) {        assertEquals(e.getValue(), conf.getProperty(e.getKey()));    }    /**     * clear properties     */    for (Map.Entry<String, String> e : properties.entrySet()) {        System.clearProperty(e.getKey());    }    conf = new ZKClientConfig();    /**     * test that all the properties are null     */    for (Map.Entry<String, String> e : properties.entrySet()) {        String result = conf.getProperty(e.getKey());        assertNull(result);    }}
testSystemPropertyValue
public void zookeeper_f4052_0()
{    String clientName = "zookeeper1";    System.setProperty(ZK_SASL_CLIENT_USERNAME, clientName);    ZKClientConfig conf = new ZKClientConfig();    assertEquals(conf.getProperty(ZK_SASL_CLIENT_USERNAME), clientName);    String newClientName = "zookeeper2";    conf.setProperty(ZK_SASL_CLIENT_USERNAME, newClientName);    assertEquals(conf.getProperty(ZK_SASL_CLIENT_USERNAME), newClientName);}
testReadConfigurationFile
public void zookeeper_f4053_0() throws IOException, ConfigException
{    File file = File.createTempFile("clientConfig", ".conf", testData);    file.deleteOnExit();    Properties clientConfProp = new Properties();    clientConfProp.setProperty(ENABLE_CLIENT_SASL_KEY, "true");    clientConfProp.setProperty(ZK_SASL_CLIENT_USERNAME, "ZK");    clientConfProp.setProperty(LOGIN_CONTEXT_NAME_KEY, "MyClient");    clientConfProp.setProperty(ZOOKEEPER_SERVER_REALM, "HADOOP.COM");    clientConfProp.setProperty("dummyProperty", "dummyValue");    OutputStream io = new FileOutputStream(file);    try {        clientConfProp.store(io, "Client Configurations");    } finally {        io.close();    }    ZKClientConfig conf = new ZKClientConfig();    conf.addConfiguration(file.getAbsolutePath());    assertEquals(conf.getProperty(ENABLE_CLIENT_SASL_KEY), "true");    assertEquals(conf.getProperty(ZK_SASL_CLIENT_USERNAME), "ZK");    assertEquals(conf.getProperty(LOGIN_CONTEXT_NAME_KEY), "MyClient");    assertEquals(conf.getProperty(ZOOKEEPER_SERVER_REALM), "HADOOP.COM");    assertEquals(conf.getProperty("dummyProperty"), "dummyValue");            file.delete();}
testSetConfiguration
public void zookeeper_f4054_0()
{    ZKClientConfig conf = new ZKClientConfig();    String defaultValue = conf.getProperty(ZKClientConfig.ENABLE_CLIENT_SASL_KEY, ZKClientConfig.ENABLE_CLIENT_SASL_DEFAULT);    if (defaultValue.equals("true")) {        conf.setProperty(ENABLE_CLIENT_SASL_KEY, "false");    } else {        conf.setProperty(ENABLE_CLIENT_SASL_KEY, "true");    }    assertTrue(conf.getProperty(ENABLE_CLIENT_SASL_KEY) != defaultValue);}
testIntegerRetrievalFromProperty
public void zookeeper_f4055_0()
{    ZKClientConfig conf = new ZKClientConfig();    String prop = "UnSetProperty" + System.currentTimeMillis();    int defaultValue = 100;        int result = conf.getInt(prop, defaultValue);    assertEquals(defaultValue, result);            conf.setProperty(ZKConfig.JUTE_MAXBUFFER, "InvlaidIntValue123");    try {        result = conf.getInt(ZKConfig.JUTE_MAXBUFFER, defaultValue);        fail("NumberFormatException is expected");    } catch (NumberFormatException exception) {        }    assertEquals(defaultValue, result);        int value = ZKClientConfig.CLIENT_MAX_PACKET_LENGTH_DEFAULT;    conf.setProperty(ZKConfig.JUTE_MAXBUFFER, Integer.toString(value));    result = conf.getInt(ZKConfig.JUTE_MAXBUFFER, defaultValue);    assertEquals(value, result);        value = 12345;    conf.setProperty(ZKConfig.JUTE_MAXBUFFER, " " + value + " ");    result = conf.getInt(ZKConfig.JUTE_MAXBUFFER, defaultValue);    assertEquals(value, result);}
testClientCanonicalization
public void zookeeper_f4056_0() throws IOException, InterruptedException
{    SaslServerPrincipal.WrapperInetSocketAddress addr = mock(SaslServerPrincipal.WrapperInetSocketAddress.class);    SaslServerPrincipal.WrapperInetAddress ia = mock(SaslServerPrincipal.WrapperInetAddress.class);    when(addr.getHostName()).thenReturn("zookeeper.apache.org");    when(addr.getAddress()).thenReturn(ia);    when(ia.getCanonicalHostName()).thenReturn("zk1.apache.org");    when(ia.getHostAddress()).thenReturn("127.0.0.1");    ZKClientConfig conf = new ZKClientConfig();    String principal = SaslServerPrincipal.getServerPrincipal(addr, conf);    assertEquals("The computed principal does not appear to have been canonicalized", "zookeeper/zk1.apache.org", principal);}
testClientNoCanonicalization
public void zookeeper_f4057_0() throws IOException, InterruptedException
{    SaslServerPrincipal.WrapperInetSocketAddress addr = mock(SaslServerPrincipal.WrapperInetSocketAddress.class);    SaslServerPrincipal.WrapperInetAddress ia = mock(SaslServerPrincipal.WrapperInetAddress.class);    when(addr.getHostName()).thenReturn("zookeeper.apache.org");    when(addr.getAddress()).thenReturn(ia);    when(ia.getCanonicalHostName()).thenReturn("zk1.apache.org");    when(ia.getHostAddress()).thenReturn("127.0.0.1");    ZKClientConfig conf = new ZKClientConfig();    conf.setProperty(ZKClientConfig.ZK_SASL_CLIENT_CANONICALIZE_HOSTNAME, "false");    String principal = SaslServerPrincipal.getServerPrincipal(addr, conf);    assertEquals("The computed principal does appears to have been canonicalized incorrectly", "zookeeper/zookeeper.apache.org", principal);}
testClientCanonicalizationToIp
public void zookeeper_f4058_0() throws IOException, InterruptedException
{    SaslServerPrincipal.WrapperInetSocketAddress addr = mock(SaslServerPrincipal.WrapperInetSocketAddress.class);    SaslServerPrincipal.WrapperInetAddress ia = mock(SaslServerPrincipal.WrapperInetAddress.class);    when(addr.getHostName()).thenReturn("zookeeper.apache.org");    when(addr.getAddress()).thenReturn(ia);    when(ia.getCanonicalHostName()).thenReturn("127.0.0.1");    when(ia.getHostAddress()).thenReturn("127.0.0.1");    ZKClientConfig conf = new ZKClientConfig();    String principal = SaslServerPrincipal.getServerPrincipal(addr, conf);    assertEquals("The computed principal does appear to have falled back to the original host name", "zookeeper/zookeeper.apache.org", principal);}
setUp
public void zookeeper_f4059_0()
{    ClientCnxnSocketNetty.setTestAllocator(TestByteBufAllocator.getInstance());}
tearDown
public void zookeeper_f4060_0()
{    ClientCnxnSocketNetty.clearTestAllocator();    TestByteBufAllocator.checkForLeaks();}
testWhenInvalidJuteMaxBufferIsConfiguredIOExceptionIsThrown
public void zookeeper_f4061_0()
{    ZKClientConfig clientConfig = new ZKClientConfig();    String value = "SomeInvalidInt";    clientConfig.setProperty(ZKConfig.JUTE_MAXBUFFER, value);        try {        new ClientCnxnSocketNIO(clientConfig);        fail("IOException is expected.");    } catch (IOException e) {        assertTrue(e.getMessage().contains(value));    }        try {        new ClientCnxnSocketNetty(clientConfig);        fail("IOException is expected.");    } catch (IOException e) {        assertTrue(e.getMessage().contains(value));    }}
registerAndConnect
 void zookeeper_f4062_0(SocketChannel sock, InetSocketAddress addr) throws IOException
{    countDownLatch.countDown();    throw new IOException("failed to register");}
createSock
 SocketChannel zookeeper_f4063_0()
{    return sc;}
testClientReconnect
public void zookeeper_f4064_0() throws IOException, InterruptedException
{    HostProvider hostProvider = mock(HostProvider.class);    when(hostProvider.size()).thenReturn(1);    InetSocketAddress inaddr = new InetSocketAddress("127.0.0.1", 1111);    when(hostProvider.next(anyLong())).thenReturn(inaddr);    ZooKeeper zk = mock(ZooKeeper.class);    when(zk.getClientConfig()).thenReturn(new ZKClientConfig());    sc = SocketChannel.open();    ClientCnxnSocketNIO nioCnxn = new MockCnxn();    ClientWatchManager watcher = mock(ClientWatchManager.class);    ClientCnxn clientCnxn = new ClientCnxn("tmp", hostProvider, 5000, zk, watcher, nioCnxn, false);    clientCnxn.start();    countDownLatch.await(5000, TimeUnit.MILLISECONDS);    assertTrue(countDownLatch.getCount() == 0);    clientCnxn.close();}
testClientRequestTimeout
public void zookeeper_f4065_0() throws Exception
{    int requestTimeOut = 15000;    System.setProperty("zookeeper.request.timeout", Integer.toString(requestTimeOut));    final int[] clientPorts = new int[SERVER_COUNT];    StringBuilder sb = new StringBuilder();    String server;    for (int i = 0; i < SERVER_COUNT; i++) {        clientPorts[i] = PortAssignment.unique();        server = "server." + i + "=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ":participant;127.0.0.1:" + clientPorts[i];        sb.append(server + "\n");    }    String currentQuorumCfgSection = sb.toString();    MainThread[] mt = new MainThread[SERVER_COUNT];    for (int i = 0; i < SERVER_COUNT; i++) {        mt[i] = new MainThread(i, clientPorts[i], currentQuorumCfgSection, false);        mt[i].start();    }        for (int i = 0; i < SERVER_COUNT; i++) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts[i], CONNECTION_TIMEOUT));    }    CountdownWatcher watch1 = new CountdownWatcher();    CustomZooKeeper zk = new CustomZooKeeper(getCxnString(clientPorts), ClientBase.CONNECTION_TIMEOUT, watch1);    watch1.waitForConnected(ClientBase.CONNECTION_TIMEOUT);    String data = "originalData";        zk.create("/clientHang1", data.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);        dropPacket = true;    dropPacketType = ZooDefs.OpCode.create;        try {        zk.create("/clientHang2", data.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        fail("KeeperException is expected.");    } catch (KeeperException exception) {        assertEquals(KeeperException.Code.REQUESTTIMEOUT.intValue(), exception.code().intValue());    }        zk.close();    for (int i = 0; i < SERVER_COUNT; i++) {        mt[i].shutdown();    }}
getCxnString
private String zookeeper_f4066_0(int[] clientPorts)
{    StringBuffer hostPortBuffer = new StringBuffer();    for (int i = 0; i < clientPorts.length; i++) {        hostPortBuffer.append("127.0.0.1:");        hostPortBuffer.append(clientPorts[i]);        if (i != (clientPorts.length - 1)) {            hostPortBuffer.append(',');        }    }    return hostPortBuffer.toString();}
finishPacket
public void zookeeper_f4067_0(Packet p)
{    if (dropPacket && p.requestHeader.getType() == dropPacketType) {                return;    }    super.finishPacket(p);}
createConnection
protected ClientCnxn zookeeper_f4068_0(String chrootPath, HostProvider hostProvider, int sessionTimeout, ZooKeeper zooKeeper, ClientWatchManager watcher, ClientCnxnSocket clientCnxnSocket, boolean canBeReadOnly) throws IOException
{    return new CustomClientCnxn(chrootPath, hostProvider, sessionTimeout, zooKeeper, watcher, clientCnxnSocket, canBeReadOnly);}
createTmpDir
public static void zookeeper_f4069_0()
{    tmpdir = new File("build/test/tmp");    tmpdir.mkdirs();}
testOutputStreamSuccess
public void zookeeper_f4070_0() throws IOException
{    File target = new File(tmpdir, "target.txt");    final File tmp = new File(tmpdir, "target.txt.tmp");    createFile(target, "before");    assertEquals("before", getContent(target));    new AtomicFileWritingIdiom(target, new OutputStreamStatement() {        @Override        public void write(OutputStream os) throws IOException {            os.write("after".getBytes(StandardCharsets.US_ASCII));            assertTrue("implementation of AtomicFileOutputStream has changed, update the test", tmp.exists());        }    });    assertFalse("tmp file should have been deleted", tmp.exists());        assertEquals("after", getContent(target));    target.delete();}
write
public void zookeeper_f4071_0(OutputStream os) throws IOException
{    os.write("after".getBytes(StandardCharsets.US_ASCII));    assertTrue("implementation of AtomicFileOutputStream has changed, update the test", tmp.exists());}
testWriterSuccess
public void zookeeper_f4072_0() throws IOException
{    File target = new File(tmpdir, "target.txt");    final File tmp = new File(tmpdir, "target.txt.tmp");    createFile(target, "before");    assertEquals("before", getContent(target));    new AtomicFileWritingIdiom(target, new WriterStatement() {        @Override        public void write(Writer os) throws IOException {            os.write("after");            assertTrue("implementation of AtomicFileOutputStream has changed, update the test", tmp.exists());        }    });    assertFalse("tmp file should have been deleted", tmp.exists());        assertEquals("after", getContent(target));    target.delete();}
write
public void zookeeper_f4073_0(Writer os) throws IOException
{    os.write("after");    assertTrue("implementation of AtomicFileOutputStream has changed, update the test", tmp.exists());}
testOutputStreamFailure
public void zookeeper_f4074_0() throws IOException
{    File target = new File(tmpdir, "target.txt");    final File tmp = new File(tmpdir, "target.txt.tmp");    createFile(target, "before");    assertEquals("before", getContent(target));    boolean exception = false;    try {        new AtomicFileWritingIdiom(target, new OutputStreamStatement() {            @Override            public void write(OutputStream os) throws IOException {                os.write("after".getBytes(StandardCharsets.US_ASCII));                os.flush();                assertTrue("implementation of AtomicFileOutputStream has changed, update the test", tmp.exists());                throw new RuntimeException();            }        });    } catch (RuntimeException ex) {        exception = true;    }    assertFalse("tmp file should have been deleted", tmp.exists());    assertTrue("should have raised an exception", exception);        assertEquals("before", getContent(target));    target.delete();}
write
public void zookeeper_f4075_0(OutputStream os) throws IOException
{    os.write("after".getBytes(StandardCharsets.US_ASCII));    os.flush();    assertTrue("implementation of AtomicFileOutputStream has changed, update the test", tmp.exists());    throw new RuntimeException();}
testWriterFailure
public void zookeeper_f4076_0() throws IOException
{    File target = new File(tmpdir, "target.txt");    final File tmp = new File(tmpdir, "target.txt.tmp");    createFile(target, "before");    assertEquals("before", getContent(target));    boolean exception = false;    try {        new AtomicFileWritingIdiom(target, new WriterStatement() {            @Override            public void write(Writer os) throws IOException {                os.write("after");                os.flush();                assertTrue("implementation of AtomicFileOutputStream has changed, update the test", tmp.exists());                throw new RuntimeException();            }        });    } catch (RuntimeException ex) {        exception = true;    }    assertFalse("tmp file should have been deleted", tmp.exists());    assertTrue("should have raised an exception", exception);        assertEquals("before", getContent(target));    target.delete();}
write
public void zookeeper_f4077_0(Writer os) throws IOException
{    os.write("after");    os.flush();    assertTrue("implementation of AtomicFileOutputStream has changed, update the test", tmp.exists());    throw new RuntimeException();}
testOutputStreamFailureIOException
public void zookeeper_f4078_0() throws IOException
{    File target = new File(tmpdir, "target.txt");    final File tmp = new File(tmpdir, "target.txt.tmp");    createFile(target, "before");    assertEquals("before", getContent(target));    boolean exception = false;    try {        new AtomicFileWritingIdiom(target, new OutputStreamStatement() {            @Override            public void write(OutputStream os) throws IOException {                os.write("after".getBytes(StandardCharsets.US_ASCII));                os.flush();                assertTrue("implementation of AtomicFileOutputStream has changed, update the test", tmp.exists());                throw new IOException();            }        });    } catch (IOException ex) {        exception = true;    }    assertFalse("tmp file should have been deleted", tmp.exists());    assertTrue("should have raised an exception", exception);        assertEquals("before", getContent(target));    target.delete();}
write
public void zookeeper_f4079_0(OutputStream os) throws IOException
{    os.write("after".getBytes(StandardCharsets.US_ASCII));    os.flush();    assertTrue("implementation of AtomicFileOutputStream has changed, update the test", tmp.exists());    throw new IOException();}
testWriterFailureIOException
public void zookeeper_f4080_0() throws IOException
{    File target = new File(tmpdir, "target.txt");    final File tmp = new File(tmpdir, "target.txt.tmp");    createFile(target, "before");    assertEquals("before", getContent(target));    boolean exception = false;    try {        new AtomicFileWritingIdiom(target, new WriterStatement() {            @Override            public void write(Writer os) throws IOException {                os.write("after");                os.flush();                assertTrue("implementation of AtomicFileOutputStream has changed, update the test", tmp.exists());                throw new IOException();            }        });    } catch (IOException ex) {        exception = true;    }    assertFalse("tmp file should have been deleted", tmp.exists());    assertTrue("should have raised an exception", exception);        assertEquals("before", getContent(target));    target.delete();}
write
public void zookeeper_f4081_0(Writer os) throws IOException
{    os.write("after");    os.flush();    assertTrue("implementation of AtomicFileOutputStream has changed, update the test", tmp.exists());    throw new IOException();}
testOutputStreamFailureError
public void zookeeper_f4082_0() throws IOException
{    File target = new File(tmpdir, "target.txt");    final File tmp = new File(tmpdir, "target.txt.tmp");    createFile(target, "before");    assertEquals("before", getContent(target));    boolean exception = false;    try {        new AtomicFileWritingIdiom(target, new OutputStreamStatement() {            @Override            public void write(OutputStream os) throws IOException {                os.write("after".getBytes(StandardCharsets.US_ASCII));                os.flush();                assertTrue("implementation of AtomicFileOutputStream has changed, update the test", tmp.exists());                throw new Error();            }        });    } catch (Error ex) {        exception = true;    }    assertFalse("tmp file should have been deleted", tmp.exists());    assertTrue("should have raised an exception", exception);        assertEquals("before", getContent(target));    target.delete();}
write
public void zookeeper_f4083_0(OutputStream os) throws IOException
{    os.write("after".getBytes(StandardCharsets.US_ASCII));    os.flush();    assertTrue("implementation of AtomicFileOutputStream has changed, update the test", tmp.exists());    throw new Error();}
testWriterFailureError
public void zookeeper_f4084_0() throws IOException
{    File target = new File(tmpdir, "target.txt");    final File tmp = new File(tmpdir, "target.txt.tmp");    createFile(target, "before");    assertEquals("before", getContent(target));    boolean exception = false;    try {        new AtomicFileWritingIdiom(target, new WriterStatement() {            @Override            public void write(Writer os) throws IOException {                os.write("after");                os.flush();                assertTrue("implementation of AtomicFileOutputStream has changed, update the test", tmp.exists());                throw new Error();            }        });    } catch (Error ex) {        exception = true;    }    assertFalse("tmp file should have been deleted", tmp.exists());    assertTrue("should have raised an exception", exception);        assertEquals("before", getContent(target));    target.delete();}
write
public void zookeeper_f4085_0(Writer os) throws IOException
{    os.write("after");    os.flush();    assertTrue("implementation of AtomicFileOutputStream has changed, update the test", tmp.exists());    throw new Error();}
testOutputStreamSuccessNE
public void zookeeper_f4086_0() throws IOException
{    File target = new File(tmpdir, "target.txt");    final File tmp = new File(tmpdir, "target.txt.tmp");    target.delete();    assertFalse("file should not exist", target.exists());    new AtomicFileWritingIdiom(target, new OutputStreamStatement() {        @Override        public void write(OutputStream os) throws IOException {            os.write("after".getBytes(StandardCharsets.US_ASCII));            assertTrue("implementation of AtomicFileOutputStream has changed, update the test", tmp.exists());        }    });        assertEquals("after", getContent(target));    target.delete();}
write
public void zookeeper_f4087_0(OutputStream os) throws IOException
{    os.write("after".getBytes(StandardCharsets.US_ASCII));    assertTrue("implementation of AtomicFileOutputStream has changed, update the test", tmp.exists());}
testWriterSuccessNE
public void zookeeper_f4088_0() throws IOException
{    File target = new File(tmpdir, "target.txt");    final File tmp = new File(tmpdir, "target.txt.tmp");    target.delete();    assertFalse("file should not exist", target.exists());    new AtomicFileWritingIdiom(target, new WriterStatement() {        @Override        public void write(Writer os) throws IOException {            os.write("after");            assertTrue("implementation of AtomicFileOutputStream has changed, update the test", tmp.exists());        }    });    assertFalse("tmp file should have been deleted", tmp.exists());        assertEquals("after", getContent(target));    target.delete();}
write
public void zookeeper_f4089_0(Writer os) throws IOException
{    os.write("after");    assertTrue("implementation of AtomicFileOutputStream has changed, update the test", tmp.exists());}
testOutputStreamFailureNE
public void zookeeper_f4090_0() throws IOException
{    File target = new File(tmpdir, "target.txt");    final File tmp = new File(tmpdir, "target.txt.tmp");    target.delete();    assertFalse("file should not exist", target.exists());    boolean exception = false;    try {        new AtomicFileWritingIdiom(target, new OutputStreamStatement() {            @Override            public void write(OutputStream os) throws IOException {                os.write("after".getBytes(StandardCharsets.US_ASCII));                os.flush();                assertTrue("implementation of AtomicFileOutputStream has changed, update the test", tmp.exists());                throw new RuntimeException();            }        });    } catch (RuntimeException ex) {        exception = true;    }    assertFalse("tmp file should have been deleted", tmp.exists());    assertTrue("should have raised an exception", exception);        assertFalse("file should not exist", target.exists());}
write
public void zookeeper_f4091_0(OutputStream os) throws IOException
{    os.write("after".getBytes(StandardCharsets.US_ASCII));    os.flush();    assertTrue("implementation of AtomicFileOutputStream has changed, update the test", tmp.exists());    throw new RuntimeException();}
testWriterFailureNE
public void zookeeper_f4092_0() throws IOException
{    File target = new File(tmpdir, "target.txt");    final File tmp = new File(tmpdir, "target.txt.tmp");    target.delete();    assertFalse("file should not exist", target.exists());    boolean exception = false;    try {        new AtomicFileWritingIdiom(target, new WriterStatement() {            @Override            public void write(Writer os) throws IOException {                os.write("after");                os.flush();                assertTrue("implementation of AtomicFileOutputStream has changed, update the test", tmp.exists());                throw new RuntimeException();            }        });    } catch (RuntimeException ex) {        exception = true;    }    assertFalse("tmp file should have been deleted", tmp.exists());    assertTrue("should have raised an exception", exception);        assertFalse("file should not exist", target.exists());}
write
public void zookeeper_f4093_0(Writer os) throws IOException
{    os.write("after");    os.flush();    assertTrue("implementation of AtomicFileOutputStream has changed, update the test", tmp.exists());    throw new RuntimeException();}
getContent
private String zookeeper_f4094_0(File file, String encoding) throws IOException
{    StringBuilder result = new StringBuilder();    FileInputStream fis = new FileInputStream(file);    byte[] b = new byte[20];    int nb;    while ((nb = fis.read(b)) != -1) {        result.append(new String(b, 0, nb, encoding));    }    fis.close();    return result.toString();}
getContent
private String zookeeper_f4095_0(File file) throws IOException
{    return getContent(file, "ASCII");}
createFile
private void zookeeper_f4096_0(File file, String content) throws IOException
{    FileOutputStream fos = new FileOutputStream(file);    fos.write(content.getBytes(StandardCharsets.US_ASCII));    fos.close();}
defaultParams
public static Collection<Object[]> zookeeper_f4097_0()
{    ArrayList<Object[]> result = new ArrayList<>();    int paramIndex = 0;    for (X509KeyType caKeyType : X509KeyType.values()) {        for (X509KeyType certKeyType : X509KeyType.values()) {            for (String keyPassword : new String[] { "", "pa$$w0rd" }) {                result.add(new Object[] { caKeyType, certKeyType, keyPassword, paramIndex++ });            }        }    }    return result;}
setUpBaseClass
public static void zookeeper_f4098_0() throws Exception
{    Security.addProvider(new BouncyCastleProvider());    cachedTestContexts = new HashMap<>();    tempDir = ClientBase.createEmptyTestDir();}
cleanUpBaseClass
public static void zookeeper_f4099_0()
{    Security.removeProvider("BC");    cachedTestContexts.clear();    cachedTestContexts = null;    try {        FileUtils.deleteDirectory(tempDir);    } catch (IOException e) {        }}
createTempFile
public static void zookeeper_f4100_0() throws IOException
{    tempDir = ClientBase.createEmptyTestDir();    tempFile = File.createTempFile("zk_test_", "", tempDir);    tempFile.deleteOnExit();}
cleanupTempDir
public static void zookeeper_f4101_0()
{    try {        FileUtils.deleteDirectory(tempDir);    } catch (IOException e) {        }}
testCallbackWorksOnFileChanges
public voidf4102_1) throws IOException, InterruptedException
{    FileChangeWatcher watcher = null;    try {        final List<WatchEvent<?>> events = new ArrayList<>();        watcher = new FileChangeWatcher(tempDir.toPath(), event -> {                                    if (StandardWatchEventKinds.ENTRY_CREATE.equals(event.kind())) {                return;            }            synchronized (events) {                events.add(event);                events.notifyAll();            }        });        watcher.start();        watcher.waitForState(FileChangeWatcher.State.RUNNING);                Thread.sleep(1000L);        for (int i = 0; i < 3; i++) {                        FileUtils.writeStringToFile(tempFile, "Hello world " + i + "\n", StandardCharsets.UTF_8, true);            synchronized (events) {                if (events.size() < i + 1) {                    events.wait(3000L);                }                assertEquals("Wrong number of events", i + 1, events.size());                WatchEvent<?> event = events.get(i);                assertEquals(StandardWatchEventKinds.ENTRY_MODIFY, event.kind());                assertEquals(tempFile.getName(), event.context().toString());            }        }    } finally {        if (watcher != null) {            watcher.stop();            watcher.waitForState(FileChangeWatcher.State.STOPPED);        }    }}
testCallbackWorksOnFileTouched
public voidf4103_1) throws IOException, InterruptedException
{    FileChangeWatcher watcher = null;    try {        final List<WatchEvent<?>> events = new ArrayList<>();        watcher = new FileChangeWatcher(tempDir.toPath(), event -> {                                    if (StandardWatchEventKinds.ENTRY_CREATE.equals(event.kind())) {                return;            }            synchronized (events) {                events.add(event);                events.notifyAll();            }        });        watcher.start();        watcher.waitForState(FileChangeWatcher.State.RUNNING);                Thread.sleep(1000L);                FileUtils.touch(tempFile);        synchronized (events) {            if (events.isEmpty()) {                events.wait(3000L);            }            assertFalse(events.isEmpty());            WatchEvent<?> event = events.get(0);            assertEquals(StandardWatchEventKinds.ENTRY_MODIFY, event.kind());            assertEquals(tempFile.getName(), event.context().toString());        }    } finally {        if (watcher != null) {            watcher.stop();            watcher.waitForState(FileChangeWatcher.State.STOPPED);        }    }}
testCallbackWorksOnFileAdded
public voidf4104_1) throws IOException, InterruptedException
{    FileChangeWatcher watcher = null;    try {        final List<WatchEvent<?>> events = new ArrayList<>();        watcher = new FileChangeWatcher(tempDir.toPath(), event -> {                        synchronized (events) {                events.add(event);                events.notifyAll();            }        });        watcher.start();        watcher.waitForState(FileChangeWatcher.State.RUNNING);                Thread.sleep(1000L);        File tempFile2 = File.createTempFile("zk_test_", "", tempDir);        tempFile2.deleteOnExit();        synchronized (events) {            if (events.isEmpty()) {                events.wait(3000L);            }            assertFalse(events.isEmpty());            WatchEvent<?> event = events.get(0);            assertEquals(StandardWatchEventKinds.ENTRY_CREATE, event.kind());            assertEquals(tempFile2.getName(), event.context().toString());        }    } finally {        if (watcher != null) {            watcher.stop();            watcher.waitForState(FileChangeWatcher.State.STOPPED);        }    }}
testCallbackWorksOnFileDeleted
public voidf4105_1) throws IOException, InterruptedException
{    FileChangeWatcher watcher = null;    try {        final List<WatchEvent<?>> events = new ArrayList<>();        watcher = new FileChangeWatcher(tempDir.toPath(), event -> {                                    if (StandardWatchEventKinds.ENTRY_CREATE.equals(event.kind())) {                return;            }            synchronized (events) {                events.add(event);                events.notifyAll();            }        });        watcher.start();        watcher.waitForState(FileChangeWatcher.State.RUNNING);                Thread.sleep(1000L);        tempFile.delete();        synchronized (events) {            if (events.isEmpty()) {                events.wait(3000L);            }            assertFalse(events.isEmpty());            WatchEvent<?> event = events.get(0);            assertEquals(StandardWatchEventKinds.ENTRY_DELETE, event.kind());            assertEquals(tempFile.getName(), event.context().toString());        }    } finally {        if (watcher != null) {            watcher.stop();            watcher.waitForState(FileChangeWatcher.State.STOPPED);        }    }}
testCallbackErrorDoesNotCrashWatcherThread
public voidf4106_1) throws IOException, InterruptedException
{    FileChangeWatcher watcher = null;    try {        final AtomicInteger callCount = new AtomicInteger(0);        watcher = new FileChangeWatcher(tempDir.toPath(), event -> {                        int oldValue;            synchronized (callCount) {                oldValue = callCount.getAndIncrement();                callCount.notifyAll();            }            if (oldValue == 0) {                throw new RuntimeException("This error should not crash the watcher thread");            }        });        watcher.start();        watcher.waitForState(FileChangeWatcher.State.RUNNING);                Thread.sleep(1000L);                FileUtils.writeStringToFile(tempFile, "Hello world\n", StandardCharsets.UTF_8, true);        synchronized (callCount) {            while (callCount.get() == 0) {                callCount.wait(3000L);            }        }                FileUtils.writeStringToFile(tempFile, "Hello world again\n", StandardCharsets.UTF_8, true);        synchronized (callCount) {            if (callCount.get() == 1) {                callCount.wait(3000L);            }        }                        assertTrue(callCount.get() > 1);    } finally {        if (watcher != null) {            watcher.stop();            watcher.waitForState(FileChangeWatcher.State.STOPPED);        }    }}
testGetBuilderForJKSFileType
public void zookeeper_f4107_0()
{    FileKeyStoreLoader.Builder<?> builder = FileKeyStoreLoaderBuilderProvider.getBuilderForKeyStoreFileType(KeyStoreFileType.JKS);    assertTrue(builder instanceof JKSFileLoader.Builder);}
testGetBuilderForPEMFileType
public void zookeeper_f4108_0()
{    FileKeyStoreLoader.Builder<?> builder = FileKeyStoreLoaderBuilderProvider.getBuilderForKeyStoreFileType(KeyStoreFileType.PEM);    assertTrue(builder instanceof PEMFileLoader.Builder);}
testGetBuilderForPKCS12FileType
public void zookeeper_f4109_0()
{    FileKeyStoreLoader.Builder<?> builder = FileKeyStoreLoaderBuilderProvider.getBuilderForKeyStoreFileType(KeyStoreFileType.PKCS12);    assertTrue(builder instanceof PKCS12FileLoader.Builder);}
testGetBuilderForNullFileType
public void zookeeper_f4110_0()
{    FileKeyStoreLoaderBuilderProvider.getBuilderForKeyStoreFileType(null);}
params
public static Collection<Object[]> zookeeper_f4111_0()
{    return BaseX509ParameterizedTestCase.defaultParams();}
testLoadKeyStore
public void zookeeper_f4112_0() throws Exception
{    String path = x509TestContext.getKeyStoreFile(KeyStoreFileType.JKS).getAbsolutePath();    KeyStore ks = new JKSFileLoader.Builder().setKeyStorePath(path).setKeyStorePassword(x509TestContext.getKeyStorePassword()).build().loadKeyStore();    assertEquals(1, ks.size());}
testLoadKeyStoreWithWrongPassword
public void zookeeper_f4113_0() throws Exception
{    String path = x509TestContext.getKeyStoreFile(KeyStoreFileType.JKS).getAbsolutePath();    new JKSFileLoader.Builder().setKeyStorePath(path).setKeyStorePassword("wrong password").build().loadKeyStore();}
testLoadKeyStoreWithWrongFilePath
public void zookeeper_f4114_0() throws Exception
{    String path = x509TestContext.getKeyStoreFile(KeyStoreFileType.JKS).getAbsolutePath();    new JKSFileLoader.Builder().setKeyStorePath(path + ".does_not_exist").setKeyStorePassword(x509TestContext.getKeyStorePassword()).build().loadKeyStore();}
testLoadKeyStoreWithNullFilePath
public void zookeeper_f4115_0() throws Exception
{    new JKSFileLoader.Builder().setKeyStorePassword(x509TestContext.getKeyStorePassword()).build().loadKeyStore();}
testLoadKeyStoreWithWrongFileType
public void zookeeper_f4116_0() throws Exception
{        String path = x509TestContext.getKeyStoreFile(KeyStoreFileType.PEM).getAbsolutePath();    new JKSFileLoader.Builder().setKeyStorePath(path).setKeyStorePassword(x509TestContext.getKeyStorePassword()).build().loadKeyStore();}
testLoadTrustStore
public void zookeeper_f4117_0() throws Exception
{    String path = x509TestContext.getTrustStoreFile(KeyStoreFileType.JKS).getAbsolutePath();    KeyStore ts = new JKSFileLoader.Builder().setTrustStorePath(path).setTrustStorePassword(x509TestContext.getTrustStorePassword()).build().loadTrustStore();    assertEquals(1, ts.size());}
testLoadTrustStoreWithWrongPassword
public void zookeeper_f4118_0() throws Exception
{    String path = x509TestContext.getTrustStoreFile(KeyStoreFileType.JKS).getAbsolutePath();    new JKSFileLoader.Builder().setTrustStorePath(path).setTrustStorePassword("wrong password").build().loadTrustStore();}
testLoadTrustStoreWithWrongFilePath
public void zookeeper_f4119_0() throws Exception
{    String path = x509TestContext.getTrustStoreFile(KeyStoreFileType.JKS).getAbsolutePath();    new JKSFileLoader.Builder().setTrustStorePath(path + ".does_not_exist").setTrustStorePassword(x509TestContext.getTrustStorePassword()).build().loadTrustStore();}
testLoadTrustStoreWithNullFilePath
public void zookeeper_f4120_0() throws Exception
{    new JKSFileLoader.Builder().setTrustStorePassword(x509TestContext.getTrustStorePassword()).build().loadTrustStore();}
testLoadTrustStoreWithWrongFileType
public void zookeeper_f4121_0() throws Exception
{        String path = x509TestContext.getTrustStoreFile(KeyStoreFileType.PEM).getAbsolutePath();    new JKSFileLoader.Builder().setTrustStorePath(path).setTrustStorePassword(x509TestContext.getTrustStorePassword()).build().loadTrustStore();}
testGetPropertyValue
public void zookeeper_f4122_0()
{    assertEquals("PEM", KeyStoreFileType.PEM.getPropertyValue());    assertEquals("JKS", KeyStoreFileType.JKS.getPropertyValue());    assertEquals("PKCS12", KeyStoreFileType.PKCS12.getPropertyValue());}
testFromPropertyValue
public void zookeeper_f4123_0()
{    assertEquals(KeyStoreFileType.PEM, KeyStoreFileType.fromPropertyValue("PEM"));    assertEquals(KeyStoreFileType.JKS, KeyStoreFileType.fromPropertyValue("JKS"));    assertEquals(KeyStoreFileType.PKCS12, KeyStoreFileType.fromPropertyValue("PKCS12"));    assertNull(KeyStoreFileType.fromPropertyValue(""));    assertNull(KeyStoreFileType.fromPropertyValue(null));}
testFromPropertyValueIgnoresCase
public void zookeeper_f4124_0()
{    assertEquals(KeyStoreFileType.PEM, KeyStoreFileType.fromPropertyValue("pem"));    assertEquals(KeyStoreFileType.JKS, KeyStoreFileType.fromPropertyValue("jks"));    assertEquals(KeyStoreFileType.PKCS12, KeyStoreFileType.fromPropertyValue("pkcs12"));    assertNull(KeyStoreFileType.fromPropertyValue(""));    assertNull(KeyStoreFileType.fromPropertyValue(null));}
testFromPropertyValueThrowsOnBadPropertyValue
public void zookeeper_f4125_0()
{    KeyStoreFileType.fromPropertyValue("foobar");}
testFromFilename
public void zookeeper_f4126_0()
{    assertEquals(KeyStoreFileType.JKS, KeyStoreFileType.fromFilename("mykey.jks"));    assertEquals(KeyStoreFileType.JKS, KeyStoreFileType.fromFilename("/path/to/key/dir/mykey.jks"));    assertEquals(KeyStoreFileType.PEM, KeyStoreFileType.fromFilename("mykey.pem"));    assertEquals(KeyStoreFileType.PEM, KeyStoreFileType.fromFilename("/path/to/key/dir/mykey.pem"));    assertEquals(KeyStoreFileType.PKCS12, KeyStoreFileType.fromFilename("mykey.p12"));    assertEquals(KeyStoreFileType.PKCS12, KeyStoreFileType.fromFilename("/path/to/key/dir/mykey.p12"));}
testFromFilenameThrowsOnBadFileExtension
public void zookeeper_f4127_0()
{    KeyStoreFileType.fromFilename("prod.key");}
testFromPropertyValueOrFileName
public void zookeeper_f4128_0()
{        assertEquals(KeyStoreFileType.JKS, KeyStoreFileType.fromPropertyValueOrFileName("JKS", "prod.key"));    assertEquals(KeyStoreFileType.PEM, KeyStoreFileType.fromPropertyValueOrFileName("PEM", "prod.key"));    assertEquals(KeyStoreFileType.PKCS12, KeyStoreFileType.fromPropertyValueOrFileName("PKCS12", "prod.key"));        assertEquals(KeyStoreFileType.JKS, KeyStoreFileType.fromPropertyValueOrFileName("", "prod.jks"));}
testFromPropertyValueOrFileNameThrowsOnBadPropertyValue
public void zookeeper_f4129_0()
{    KeyStoreFileType.fromPropertyValueOrFileName("foobar", "prod.jks");}
testFromPropertyValueOrFileNameThrowsOnBadFileExtension
public void zookeeper_f4130_0()
{    KeyStoreFileType.fromPropertyValueOrFileName("", "prod.key");}
testFormatInetAddrGoodIpv4
public void zookeeper_f4131_0()
{    InetSocketAddress isa = new InetSocketAddress(v4addr, port);    assertEquals("127.0.0.1:1234", NetUtils.formatInetAddr(isa));}
testFormatInetAddrGoodIpv6Local
public void zookeeper_f4132_0()
{        InetSocketAddress isa = new InetSocketAddress("::1", port);    assertEquals(v6local, NetUtils.formatInetAddr(isa));}
testFormatInetAddrGoodIpv6Ext
public void zookeeper_f4133_0()
{        InetSocketAddress isa = new InetSocketAddress("2600::", port);    assertEquals(v6ext, NetUtils.formatInetAddr(isa));}
testFormatInetAddrGoodHostname
public void zookeeper_f4134_0()
{    InetSocketAddress isa = new InetSocketAddress("localhost", 1234);    assertThat(NetUtils.formatInetAddr(isa), anyOf(equalTo(v4local), equalTo(v6local)));}
testFormatAddrUnresolved
public void zookeeper_f4135_0()
{    InetSocketAddress isa = InetSocketAddress.createUnresolved("doesnt.exist.com", 1234);    assertEquals("doesnt.exist.com:1234", NetUtils.formatInetAddr(isa));}
before
public void zookeeper_f4136_0()
{    this.pathTrie = new PathTrie();}
addNullPath
public void zookeeper_f4137_0()
{    this.pathTrie.addPath(null);}
addIllegalPath
public void zookeeper_f4138_0()
{    this.pathTrie.addPath("");}
addPathToRoot
public void zookeeper_f4139_0()
{    this.pathTrie.addPath("node1");    assertTrue(this.pathTrie.existsNode("/node1"));}
addPathToRootLeaves
public void zookeeper_f4140_0()
{    this.pathTrie.addPath("node1");    this.pathTrie.addPath("node1/node2");    this.pathTrie.addPath("node1/node3");    assertTrue(this.pathTrie.existsNode("/node1"));    assertTrue(this.pathTrie.existsNode("/node1/node2"));    assertTrue(this.pathTrie.existsNode("/node1/node3"));}
deleteNullPath
public void zookeeper_f4141_0()
{    this.pathTrie.deletePath(null);}
deleteIllegalPath
public void zookeeper_f4142_0()
{    this.pathTrie.deletePath("");}
deletePathFromRoot
public void zookeeper_f4143_0()
{    this.pathTrie.addPath("node1");    this.pathTrie.deletePath("node1");    assertFalse(this.pathTrie.existsNode("/node1"));}
deletePathFromRootLeaves
public void zookeeper_f4144_0()
{    this.pathTrie.addPath("node1");    this.pathTrie.addPath("node1/node2");    this.pathTrie.addPath("node1/node3");    this.pathTrie.deletePath("node1/node3");    assertTrue(this.pathTrie.existsNode("/node1"));    assertTrue(this.pathTrie.existsNode("/node1/node2"));    assertFalse(this.pathTrie.existsNode("/node1/node3"));    this.pathTrie.deletePath("node1/node2");    assertTrue(this.pathTrie.existsNode("/node1"));    assertFalse(this.pathTrie.existsNode("/node1/node2"));    this.pathTrie.deletePath("node1");    assertFalse(this.pathTrie.existsNode("/node1"));}
deletePathDoesNotExist
public void zookeeper_f4145_0()
{    this.pathTrie.addPath("node1");    this.pathTrie.addPath("node1/node2");    this.pathTrie.deletePath("node1/node3");    assertTrue(this.pathTrie.existsNode("/node1"));    assertTrue(this.pathTrie.existsNode("/node1/node2"));}
deleteRootPath
public void zookeeper_f4146_0()
{    this.pathTrie.addPath("node1");    this.pathTrie.addPath("node1/node2");    this.pathTrie.addPath("node1/node3");        this.pathTrie.deletePath("node1");    assertTrue(this.pathTrie.existsNode("/node1"));    assertTrue(this.pathTrie.existsNode("/node1/node2"));    assertTrue(this.pathTrie.existsNode("/node1/node3"));}
findMaxPrefixNullPath
public void zookeeper_f4147_0()
{    this.pathTrie.findMaxPrefix(null);}
findMaxPrefixRootPath
public void zookeeper_f4148_0()
{    assertEquals("/", this.pathTrie.findMaxPrefix("/"));}
findMaxPrefixChildren
public void zookeeper_f4149_0()
{    this.pathTrie.addPath("node1");    this.pathTrie.addPath("node1/node2");    this.pathTrie.addPath("node1/node3");    assertEquals("/node1", this.pathTrie.findMaxPrefix("/node1"));    assertEquals("/node1/node2", this.pathTrie.findMaxPrefix("/node1/node2"));    assertEquals("/node1/node3", this.pathTrie.findMaxPrefix("/node1/node3"));}
findMaxPrefixChildrenPrefix
public void zookeeper_f4150_0()
{    this.pathTrie.addPath("node1");    assertEquals("/node1", this.pathTrie.findMaxPrefix("/node1/node2"));    assertEquals("/node1", this.pathTrie.findMaxPrefix("/node1/node3"));}
testValidatePath_ValidPath
public void zookeeper_f4151_0()
{    PathUtils.validatePath("/this is / a valid/path");}
testValidatePath_Null
public void zookeeper_f4152_0()
{    PathUtils.validatePath(null);}
testValidatePath_EmptyString
public void zookeeper_f4153_0()
{    PathUtils.validatePath("");}
testValidatePath_NotAbsolutePath
public void zookeeper_f4154_0()
{    PathUtils.validatePath("not/valid");}
testValidatePath_EndsWithSlash
public void zookeeper_f4155_0()
{    PathUtils.validatePath("/ends/with/slash/");}
testValidatePath_ContainsNullCharacter
public void zookeeper_f4156_0()
{    PathUtils.validatePath("/test\u0000");}
testValidatePath_DoubleSlash
public void zookeeper_f4157_0()
{    PathUtils.validatePath("/double//slash");}
testValidatePath_SinglePeriod
public void zookeeper_f4158_0()
{    PathUtils.validatePath("/single/./period");}
testValidatePath_DoublePeriod
public void zookeeper_f4159_0()
{    PathUtils.validatePath("/double/../period");}
testValidatePath_NameContainingPeriod
public void zookeeper_f4160_0()
{        PathUtils.validatePath("/name/with.period.");}
testValidatePath_0x01
public void zookeeper_f4161_0()
{    PathUtils.validatePath("/test\u0001");}
testValidatePath_0x1F
public void zookeeper_f4162_0()
{    PathUtils.validatePath("/test\u001F");}
testValidatePath_0x20
public void zookeeper_f4163_0()
{    PathUtils.validatePath("/test\u0020");}
testValidatePath_0x7e
public void zookeeper_f4164_0()
{        PathUtils.validatePath("/test\u007e");}
testValidatePath_0x7f
public void zookeeper_f4165_0()
{    PathUtils.validatePath("/test\u007f");}
testValidatePath_0x9f
public void zookeeper_f4166_0()
{    PathUtils.validatePath("/test\u009f");}
testValidatePath_ud800
public void zookeeper_f4167_0()
{    PathUtils.validatePath("/test\ud800");}
testValidatePath_uf8ff
public void zookeeper_f4168_0()
{    PathUtils.validatePath("/test\uf8ff");}
testValidatePath_HighestAllowableChar
public void zookeeper_f4169_0()
{    PathUtils.validatePath("/test\uffef");}
testValidatePath_SupplementaryChar
public void zookeeper_f4170_0()
{    PathUtils.validatePath("/test\ufff0");}
params
public static Collection<Object[]> zookeeper_f4171_0()
{    return BaseX509ParameterizedTestCase.defaultParams();}
testLoadKeyStore
public void zookeeper_f4172_0() throws Exception
{    String path = x509TestContext.getKeyStoreFile(KeyStoreFileType.PEM).getAbsolutePath();    KeyStore ks = new PEMFileLoader.Builder().setKeyStorePath(path).setKeyStorePassword(x509TestContext.getKeyStorePassword()).build().loadKeyStore();    assertEquals(1, ks.size());}
testLoadKeyStoreWithWrongPassword
public void zookeeper_f4173_0() throws Exception
{    String path = x509TestContext.getKeyStoreFile(KeyStoreFileType.PEM).getAbsolutePath();    new PEMFileLoader.Builder().setKeyStorePath(path).setKeyStorePassword("wrong password").build().loadKeyStore();}
testLoadKeyStoreWithWrongFilePath
public void zookeeper_f4174_0() throws Exception
{    String path = x509TestContext.getKeyStoreFile(KeyStoreFileType.PEM).getAbsolutePath();    new PEMFileLoader.Builder().setKeyStorePath(path + ".does_not_exist").setKeyStorePassword(x509TestContext.getKeyStorePassword()).build().loadKeyStore();}
testLoadKeyStoreWithNullFilePath
public void zookeeper_f4175_0() throws Exception
{    new PEMFileLoader.Builder().setKeyStorePassword(x509TestContext.getKeyStorePassword()).build().loadKeyStore();}
testLoadKeyStoreWithWrongFileType
public void zookeeper_f4176_0() throws Exception
{        String path = x509TestContext.getKeyStoreFile(KeyStoreFileType.JKS).getAbsolutePath();    new PEMFileLoader.Builder().setKeyStorePath(path).setKeyStorePassword(x509TestContext.getKeyStorePassword()).build().loadKeyStore();}
testLoadTrustStore
public void zookeeper_f4177_0() throws Exception
{    String path = x509TestContext.getTrustStoreFile(KeyStoreFileType.PEM).getAbsolutePath();    KeyStore ts = new PEMFileLoader.Builder().setTrustStorePath(path).setTrustStorePassword(x509TestContext.getTrustStorePassword()).build().loadTrustStore();    assertEquals(1, ts.size());}
testLoadTrustStoreWithWrongFilePath
public void zookeeper_f4178_0() throws Exception
{    String path = x509TestContext.getTrustStoreFile(KeyStoreFileType.PEM).getAbsolutePath();    new PEMFileLoader.Builder().setTrustStorePath(path + ".does_not_exist").setTrustStorePassword(x509TestContext.getTrustStorePassword()).build().loadTrustStore();}
testLoadTrustStoreWithNullFilePath
public void zookeeper_f4179_0() throws Exception
{    new PEMFileLoader.Builder().setTrustStorePassword(x509TestContext.getTrustStorePassword()).build().loadTrustStore();}
testLoadTrustStoreWithWrongFileType
public void zookeeper_f4180_0() throws Exception
{        String path = x509TestContext.getTrustStoreFile(KeyStoreFileType.JKS).getAbsolutePath();    KeyStore ts = new PEMFileLoader.Builder().setTrustStorePath(path).setTrustStorePassword(x509TestContext.getTrustStorePassword()).build().loadTrustStore();    assertEquals(0, ts.size());}
params
public static Collection<Object[]> zookeeper_f4181_0()
{    return BaseX509ParameterizedTestCase.defaultParams();}
testLoadKeyStore
public void zookeeper_f4182_0() throws Exception
{    String path = x509TestContext.getKeyStoreFile(KeyStoreFileType.PKCS12).getAbsolutePath();    KeyStore ks = new PKCS12FileLoader.Builder().setKeyStorePath(path).setKeyStorePassword(x509TestContext.getKeyStorePassword()).build().loadKeyStore();    assertEquals(1, ks.size());}
testLoadKeyStoreWithWrongPassword
public void zookeeper_f4183_0() throws Exception
{    String path = x509TestContext.getKeyStoreFile(KeyStoreFileType.PKCS12).getAbsolutePath();    new PKCS12FileLoader.Builder().setKeyStorePath(path).setKeyStorePassword("wrong password").build().loadKeyStore();}
testLoadKeyStoreWithWrongFilePath
public void zookeeper_f4184_0() throws Exception
{    String path = x509TestContext.getKeyStoreFile(KeyStoreFileType.PKCS12).getAbsolutePath();    new PKCS12FileLoader.Builder().setKeyStorePath(path + ".does_not_exist").setKeyStorePassword(x509TestContext.getKeyStorePassword()).build().loadKeyStore();}
testLoadKeyStoreWithNullFilePath
public void zookeeper_f4185_0() throws Exception
{    new PKCS12FileLoader.Builder().setKeyStorePassword(x509TestContext.getKeyStorePassword()).build().loadKeyStore();}
testLoadKeyStoreWithWrongFileType
public void zookeeper_f4186_0() throws Exception
{        String path = x509TestContext.getKeyStoreFile(KeyStoreFileType.PEM).getAbsolutePath();    new PKCS12FileLoader.Builder().setKeyStorePath(path).setKeyStorePassword(x509TestContext.getKeyStorePassword()).build().loadKeyStore();}
testLoadTrustStore
public void zookeeper_f4187_0() throws Exception
{    String path = x509TestContext.getTrustStoreFile(KeyStoreFileType.PKCS12).getAbsolutePath();    KeyStore ts = new PKCS12FileLoader.Builder().setTrustStorePath(path).setTrustStorePassword(x509TestContext.getTrustStorePassword()).build().loadTrustStore();    assertEquals(1, ts.size());}
testLoadTrustStoreWithWrongPassword
public void zookeeper_f4188_0() throws Exception
{    String path = x509TestContext.getTrustStoreFile(KeyStoreFileType.PKCS12).getAbsolutePath();    new PKCS12FileLoader.Builder().setTrustStorePath(path).setTrustStorePassword("wrong password").build().loadTrustStore();}
testLoadTrustStoreWithWrongFilePath
public void zookeeper_f4189_0() throws Exception
{    String path = x509TestContext.getTrustStoreFile(KeyStoreFileType.PKCS12).getAbsolutePath();    new PKCS12FileLoader.Builder().setTrustStorePath(path + ".does_not_exist").setTrustStorePassword(x509TestContext.getTrustStorePassword()).build().loadTrustStore();}
testLoadTrustStoreWithNullFilePath
public void zookeeper_f4190_0() throws Exception
{    new PKCS12FileLoader.Builder().setTrustStorePassword(x509TestContext.getTrustStorePassword()).build().loadTrustStore();}
testLoadTrustStoreWithWrongFileType
public void zookeeper_f4191_0() throws Exception
{        String path = x509TestContext.getTrustStoreFile(KeyStoreFileType.PEM).getAbsolutePath();    new PKCS12FileLoader.Builder().setTrustStorePath(path).setTrustStorePassword(x509TestContext.getTrustStorePassword()).build().loadTrustStore();}
main
public static void zookeeper_f4192_0(String[] args) throws Exception
{    System.out.print("Starting\n");    final TimeTest test = new TimeTest();    System.out.print("After construct\n");    test.setUp();    ZooKeeper zk = test.createClient();    zk.create("/ephemeral", new byte[] { 1, 2, 3 }, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);    while (Time.currentElapsedTime() - nt0 < 100000) {        System.out.printf("%d\t%s\n", discrepancy(), zk.exists("/ephemeral", watchCount.get() == 0 ? createWatcher() : null) != null);        waitByYielding(500);    }}
createWatcher
private static Watcher zookeeper_f4193_0()
{    watchCount.incrementAndGet();    return event -> {        watchCount.decrementAndGet();        System.out.printf("%d event = %s\n", discrepancy(), event);    };}
waitByYielding
private static void zookeeper_f4194_0(long delay)
{    long t0 = Time.currentElapsedTime();    while (Time.currentElapsedTime() < t0 + delay) {        Thread.yield();    }}
discrepancy
private static long zookeeper_f4195_0()
{    return (System.currentTimeMillis() - mt0) - (Time.currentElapsedTime() - nt0);}
testElapsedTimeToDate
public void zookeeper_f4196_0() throws Exception
{    long walltime = Time.currentWallTime();    long elapsedTime = Time.currentElapsedTime();    Thread.sleep(200);    Calendar cal = Calendar.getInstance();    cal.setTime(Time.elapsedTimeToDate(elapsedTime));    int calculatedDate = cal.get(Calendar.HOUR_OF_DAY);    cal.setTime(new Date(walltime));    int realDate = cal.get(Calendar.HOUR_OF_DAY);    assertEquals(calculatedDate, realDate);}
keyPairToType
private X509KeyType zookeeper_f4197_0(KeyPair keyPair)
{    if (keyPair.getPrivate().getAlgorithm().contains("RSA")) {        return X509KeyType.RSA;    } else {        return X509KeyType.EC;    }}
getTempDir
public File zookeeper_f4198_0()
{    return tempDir;}
getTrustStoreKeyType
public X509KeyType zookeeper_f4199_0()
{    return trustStoreKeyType;}
getTrustStoreKeyPair
public KeyPair zookeeper_f4200_0()
{    return trustStoreKeyPair;}
getTrustStoreCertExpirationMillis
public long zookeeper_f4201_0()
{    return trustStoreCertExpirationMillis;}
getTrustStoreCertificate
public X509Certificate zookeeper_f4202_0()
{    return trustStoreCertificate;}
getTrustStorePassword
public String zookeeper_f4203_0()
{    return trustStorePassword;}
getTrustStoreFile
public File zookeeper_f4204_0(KeyStoreFileType storeFileType) throws IOException
{    switch(storeFileType) {        case JKS:            return getTrustStoreJksFile();        case PEM:            return getTrustStorePemFile();        case PKCS12:            return getTrustStorePkcs12File();        default:            throw new IllegalArgumentException("Invalid trust store type: " + storeFileType + ", must be one of: " + Arrays.toString(KeyStoreFileType.values()));    }}
getTrustStoreJksFile
private File zookeeper_f4205_0() throws IOException
{    if (trustStoreJksFile == null) {        File trustStoreJksFile = File.createTempFile(TRUST_STORE_PREFIX, KeyStoreFileType.JKS.getDefaultFileExtension(), tempDir);        trustStoreJksFile.deleteOnExit();        try (final FileOutputStream trustStoreOutputStream = new FileOutputStream(trustStoreJksFile)) {            byte[] bytes = X509TestHelpers.certToJavaTrustStoreBytes(trustStoreCertificate, trustStorePassword);            trustStoreOutputStream.write(bytes);            trustStoreOutputStream.flush();        } catch (GeneralSecurityException e) {            throw new IOException(e);        }        this.trustStoreJksFile = trustStoreJksFile;    }    return trustStoreJksFile;}
getTrustStorePemFile
private File zookeeper_f4206_0() throws IOException
{    if (trustStorePemFile == null) {        File trustStorePemFile = File.createTempFile(TRUST_STORE_PREFIX, KeyStoreFileType.PEM.getDefaultFileExtension(), tempDir);        trustStorePemFile.deleteOnExit();        FileUtils.writeStringToFile(trustStorePemFile, X509TestHelpers.pemEncodeX509Certificate(trustStoreCertificate), StandardCharsets.US_ASCII, false);        this.trustStorePemFile = trustStorePemFile;    }    return trustStorePemFile;}
getTrustStorePkcs12File
private File zookeeper_f4207_0() throws IOException
{    if (trustStorePkcs12File == null) {        File trustStorePkcs12File = File.createTempFile(TRUST_STORE_PREFIX, KeyStoreFileType.PKCS12.getDefaultFileExtension(), tempDir);        trustStorePkcs12File.deleteOnExit();        try (final FileOutputStream trustStoreOutputStream = new FileOutputStream(trustStorePkcs12File)) {            byte[] bytes = X509TestHelpers.certToPKCS12TrustStoreBytes(trustStoreCertificate, trustStorePassword);            trustStoreOutputStream.write(bytes);            trustStoreOutputStream.flush();        } catch (GeneralSecurityException e) {            throw new IOException(e);        }        this.trustStorePkcs12File = trustStorePkcs12File;    }    return trustStorePkcs12File;}
getKeyStoreKeyType
public X509KeyType zookeeper_f4208_0()
{    return keyStoreKeyType;}
getKeyStoreKeyPair
public KeyPair zookeeper_f4209_0()
{    return keyStoreKeyPair;}
getKeyStoreCertExpirationMillis
public long zookeeper_f4210_0()
{    return keyStoreCertExpirationMillis;}
getKeyStoreCertificate
public X509Certificate zookeeper_f4211_0()
{    return keyStoreCertificate;}
getKeyStorePassword
public String zookeeper_f4212_0()
{    return keyStorePassword;}
isKeyStoreEncrypted
public boolean zookeeper_f4213_0()
{    return keyStorePassword.length() > 0;}
getKeyStoreFile
public File zookeeper_f4214_0(KeyStoreFileType storeFileType) throws IOException
{    switch(storeFileType) {        case JKS:            return getKeyStoreJksFile();        case PEM:            return getKeyStorePemFile();        case PKCS12:            return getKeyStorePkcs12File();        default:            throw new IllegalArgumentException("Invalid key store type: " + storeFileType + ", must be one of: " + Arrays.toString(KeyStoreFileType.values()));    }}
getKeyStoreJksFile
private File zookeeper_f4215_0() throws IOException
{    if (keyStoreJksFile == null) {        File keyStoreJksFile = File.createTempFile(KEY_STORE_PREFIX, KeyStoreFileType.JKS.getDefaultFileExtension(), tempDir);        keyStoreJksFile.deleteOnExit();        try (final FileOutputStream keyStoreOutputStream = new FileOutputStream(keyStoreJksFile)) {            byte[] bytes = X509TestHelpers.certAndPrivateKeyToJavaKeyStoreBytes(keyStoreCertificate, keyStoreKeyPair.getPrivate(), keyStorePassword);            keyStoreOutputStream.write(bytes);            keyStoreOutputStream.flush();        } catch (GeneralSecurityException e) {            throw new IOException(e);        }        this.keyStoreJksFile = keyStoreJksFile;    }    return keyStoreJksFile;}
getKeyStorePemFile
private File zookeeper_f4216_0() throws IOException
{    if (keyStorePemFile == null) {        try {            File keyStorePemFile = File.createTempFile(KEY_STORE_PREFIX, KeyStoreFileType.PEM.getDefaultFileExtension(), tempDir);            keyStorePemFile.deleteOnExit();            FileUtils.writeStringToFile(keyStorePemFile, X509TestHelpers.pemEncodeCertAndPrivateKey(keyStoreCertificate, keyStoreKeyPair.getPrivate(), keyStorePassword), StandardCharsets.US_ASCII, false);            this.keyStorePemFile = keyStorePemFile;        } catch (OperatorCreationException e) {            throw new IOException(e);        }    }    return keyStorePemFile;}
getKeyStorePkcs12File
private File zookeeper_f4217_0() throws IOException
{    if (keyStorePkcs12File == null) {        File keyStorePkcs12File = File.createTempFile(KEY_STORE_PREFIX, KeyStoreFileType.PKCS12.getDefaultFileExtension(), tempDir);        keyStorePkcs12File.deleteOnExit();        try (final FileOutputStream keyStoreOutputStream = new FileOutputStream(keyStorePkcs12File)) {            byte[] bytes = X509TestHelpers.certAndPrivateKeyToPKCS12Bytes(keyStoreCertificate, keyStoreKeyPair.getPrivate(), keyStorePassword);            keyStoreOutputStream.write(bytes);            keyStoreOutputStream.flush();        } catch (GeneralSecurityException e) {            throw new IOException(e);        }        this.keyStorePkcs12File = keyStorePkcs12File;    }    return keyStorePkcs12File;}
setSystemProperties
public void zookeeper_f4218_0(X509Util x509Util, KeyStoreFileType keyStoreFileType, KeyStoreFileType trustStoreFileType) throws IOException
{    System.setProperty(x509Util.getSslKeystoreLocationProperty(), this.getKeyStoreFile(keyStoreFileType).getAbsolutePath());    System.setProperty(x509Util.getSslKeystorePasswdProperty(), this.getKeyStorePassword());    System.setProperty(x509Util.getSslKeystoreTypeProperty(), keyStoreFileType.getPropertyValue());    System.setProperty(x509Util.getSslTruststoreLocationProperty(), this.getTrustStoreFile(trustStoreFileType).getAbsolutePath());    System.setProperty(x509Util.getSslTruststorePasswdProperty(), this.getTrustStorePassword());    System.setProperty(x509Util.getSslTruststoreTypeProperty(), trustStoreFileType.getPropertyValue());    if (hostnameVerification != null) {        System.setProperty(x509Util.getSslHostnameVerificationEnabledProperty(), hostnameVerification.toString());    } else {        System.clearProperty(x509Util.getSslHostnameVerificationEnabledProperty());    }}
clearSystemProperties
public void zookeeper_f4219_0(X509Util x509Util)
{    System.clearProperty(x509Util.getSslKeystoreLocationProperty());    System.clearProperty(x509Util.getSslKeystorePasswdProperty());    System.clearProperty(x509Util.getSslKeystoreTypeProperty());    System.clearProperty(x509Util.getSslTruststoreLocationProperty());    System.clearProperty(x509Util.getSslTruststorePasswdProperty());    System.clearProperty(x509Util.getSslTruststoreTypeProperty());    System.clearProperty(x509Util.getSslHostnameVerificationEnabledProperty());}
build
public X509TestContext zookeeper_f4220_0() throws IOException, GeneralSecurityException, OperatorCreationException
{    KeyPair trustStoreKeyPair = X509TestHelpers.generateKeyPair(trustStoreKeyType);    KeyPair keyStoreKeyPair = X509TestHelpers.generateKeyPair(keyStoreKeyType);    return new X509TestContext(tempDir, trustStoreKeyPair, trustStoreCertExpirationMillis, trustStorePassword, keyStoreKeyPair, keyStoreCertExpirationMillis, keyStorePassword, hostnameVerification);}
setTempDir
public Builder zookeeper_f4221_0(File tempDir)
{    this.tempDir = tempDir;    return this;}
setTrustStoreKeyType
public Builder zookeeper_f4222_0(X509KeyType keyType)
{    trustStoreKeyType = keyType;    return this;}
setTrustStorePassword
public Builder zookeeper_f4223_0(String password)
{    trustStorePassword = password;    return this;}
setTrustStoreCertExpirationMillis
public Builder zookeeper_f4224_0(long expirationMillis)
{    trustStoreCertExpirationMillis = expirationMillis;    return this;}
setKeyStoreKeyType
public Builder zookeeper_f4225_0(X509KeyType keyType)
{    keyStoreKeyType = keyType;    return this;}
setKeyStorePassword
public Builder zookeeper_f4226_0(String password)
{    keyStorePassword = password;    return this;}
setKeyStoreCertExpirationMillis
public Builder zookeeper_f4227_0(long expirationMillis)
{    keyStoreCertExpirationMillis = expirationMillis;    return this;}
setHostnameVerification
public Builder zookeeper_f4228_0(Boolean hostnameVerification)
{    this.hostnameVerification = hostnameVerification;    return this;}
newBuilder
public static Builder zookeeper_f4229_0()
{    return new Builder();}
newSelfSignedCACert
public static X509Certificate zookeeper_f4230_0(X500Name subject, KeyPair keyPair, long expirationMillis) throws IOException, OperatorCreationException, GeneralSecurityException
{    Date now = new Date();    X509v3CertificateBuilder builder = initCertBuilder(    subject, now, new Date(now.getTime() + expirationMillis), subject, keyPair.getPublic());        builder.addExtension(Extension.basicConstraints, true, new BasicConstraints(true));    builder.addExtension(Extension.keyUsage, true, new KeyUsage(KeyUsage.digitalSignature | KeyUsage.keyCertSign | KeyUsage.cRLSign));    return buildAndSignCertificate(keyPair.getPrivate(), builder);}
newCert
public static X509Certificate zookeeper_f4231_0(X509Certificate caCert, KeyPair caKeyPair, X500Name certSubject, PublicKey certPublicKey, long expirationMillis) throws IOException, OperatorCreationException, GeneralSecurityException
{    if (!caKeyPair.getPublic().equals(caCert.getPublicKey())) {        throw new IllegalArgumentException("CA private key does not match the public key in the CA cert");    }    Date now = new Date();    X509v3CertificateBuilder builder = initCertBuilder(new X500Name(caCert.getIssuerDN().getName()), now, new Date(now.getTime() + expirationMillis), certSubject, certPublicKey);        builder.addExtension(Extension.basicConstraints, true, new BasicConstraints(false));    builder.addExtension(Extension.keyUsage, true, new KeyUsage(KeyUsage.digitalSignature | KeyUsage.keyEncipherment));    builder.addExtension(Extension.extendedKeyUsage, true, new ExtendedKeyUsage(new KeyPurposeId[] { KeyPurposeId.id_kp_serverAuth, KeyPurposeId.id_kp_clientAuth }));    builder.addExtension(Extension.subjectAlternativeName, false, getLocalhostSubjectAltNames());    return buildAndSignCertificate(caKeyPair.getPrivate(), builder);}
getLocalhostSubjectAltNames
private static GeneralNames zookeeper_f4232_0() throws UnknownHostException
{    InetAddress[] localAddresses = InetAddress.getAllByName("localhost");    GeneralName[] generalNames = new GeneralName[localAddresses.length + 1];    for (int i = 0; i < localAddresses.length; i++) {        generalNames[i] = new GeneralName(GeneralName.iPAddress, new DEROctetString(localAddresses[i].getAddress()));    }    generalNames[generalNames.length - 1] = new GeneralName(GeneralName.dNSName, new DERIA5String("localhost"));    return new GeneralNames(generalNames);}
initCertBuilder
private static X509v3CertificateBuilder zookeeper_f4233_0(X500Name issuer, Date notBefore, Date notAfter, X500Name subject, PublicKey subjectPublicKey)
{    return new X509v3CertificateBuilder(issuer, new BigInteger(SERIAL_NUMBER_MAX_BITS, PRNG), notBefore, notAfter, subject, SubjectPublicKeyInfo.getInstance(subjectPublicKey.getEncoded()));}
buildAndSignCertificate
private static X509Certificate zookeeper_f4234_0(PrivateKey privateKey, X509v3CertificateBuilder builder) throws IOException, OperatorCreationException, CertificateException
{    BcContentSignerBuilder signerBuilder;    if (privateKey.getAlgorithm().contains("RSA")) {                AlgorithmIdentifier signatureAlgorithm = new DefaultSignatureAlgorithmIdentifierFinder().find("SHA256WithRSAEncryption");        AlgorithmIdentifier digestAlgorithm = new DefaultDigestAlgorithmIdentifierFinder().find(signatureAlgorithm);        signerBuilder = new BcRSAContentSignerBuilder(signatureAlgorithm, digestAlgorithm);    } else {                AlgorithmIdentifier signatureAlgorithm = new DefaultSignatureAlgorithmIdentifierFinder().find("SHA256withECDSA");        AlgorithmIdentifier digestAlgorithm = new DefaultDigestAlgorithmIdentifierFinder().find(signatureAlgorithm);        signerBuilder = new BcECContentSignerBuilder(signatureAlgorithm, digestAlgorithm);    }    AsymmetricKeyParameter privateKeyParam = PrivateKeyFactory.createKey(privateKey.getEncoded());    ContentSigner signer = signerBuilder.build(privateKeyParam);    return toX509Cert(builder.build(signer));}
generateKeyPair
public static KeyPair zookeeper_f4235_0(X509KeyType keyType) throws GeneralSecurityException
{    switch(keyType) {        case RSA:            return generateRSAKeyPair();        case EC:            return generateECKeyPair();        default:            throw new IllegalArgumentException("Invalid X509KeyType");    }}
generateRSAKeyPair
public static KeyPair zookeeper_f4236_0() throws GeneralSecurityException
{    KeyPairGenerator keyGen = KeyPairGenerator.getInstance("RSA");    RSAKeyGenParameterSpec keyGenSpec = new RSAKeyGenParameterSpec(DEFAULT_RSA_KEY_SIZE_BITS, DEFAULT_RSA_PUB_EXPONENT);    keyGen.initialize(keyGenSpec, PRNG);    return keyGen.generateKeyPair();}
generateECKeyPair
public static KeyPair zookeeper_f4237_0() throws GeneralSecurityException
{    KeyPairGenerator keyGen = KeyPairGenerator.getInstance("EC");    keyGen.initialize(new ECGenParameterSpec(DEFAULT_ELLIPTIC_CURVE_NAME), PRNG);    return keyGen.generateKeyPair();}
pemEncodeCertAndPrivateKey
public static String zookeeper_f4238_0(X509Certificate cert, PrivateKey privateKey, String keyPassword) throws IOException, OperatorCreationException
{    return pemEncodeX509Certificate(cert) + "\n" + pemEncodePrivateKey(privateKey, keyPassword);}
pemEncodePrivateKey
public static String zookeeper_f4239_0(PrivateKey key, String password) throws IOException, OperatorCreationException
{    StringWriter stringWriter = new StringWriter();    JcaPEMWriter pemWriter = new JcaPEMWriter(stringWriter);    OutputEncryptor encryptor = null;    if (password != null && password.length() > 0) {        encryptor = new JceOpenSSLPKCS8EncryptorBuilder(PKCSObjectIdentifiers.pbeWithSHAAnd3_KeyTripleDES_CBC).setProvider(BouncyCastleProvider.PROVIDER_NAME).setRandom(PRNG).setPasssword(password.toCharArray()).build();    }    pemWriter.writeObject(new JcaPKCS8Generator(key, encryptor));    pemWriter.close();    return stringWriter.toString();}
pemEncodeX509Certificate
public static String zookeeper_f4240_0(X509Certificate cert) throws IOException
{    StringWriter stringWriter = new StringWriter();    JcaPEMWriter pemWriter = new JcaPEMWriter(stringWriter);    pemWriter.writeObject(cert);    pemWriter.close();    return stringWriter.toString();}
certToJavaTrustStoreBytes
public static byte[] zookeeper_f4241_0(X509Certificate cert, String keyPassword) throws IOException, GeneralSecurityException
{    KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());    return certToTrustStoreBytes(cert, keyPassword, trustStore);}
certToPKCS12TrustStoreBytes
public static byte[] zookeeper_f4242_0(X509Certificate cert, String keyPassword) throws IOException, GeneralSecurityException
{    KeyStore trustStore = KeyStore.getInstance("PKCS12");    return certToTrustStoreBytes(cert, keyPassword, trustStore);}
certToTrustStoreBytes
private static byte[] zookeeper_f4243_0(X509Certificate cert, String keyPassword, KeyStore trustStore) throws IOException, GeneralSecurityException
{    char[] keyPasswordChars = keyPassword == null ? new char[0] : keyPassword.toCharArray();    trustStore.load(null, keyPasswordChars);    trustStore.setCertificateEntry(cert.getSubjectDN().toString(), cert);    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();    trustStore.store(outputStream, keyPasswordChars);    outputStream.flush();    byte[] result = outputStream.toByteArray();    outputStream.close();    return result;}
certAndPrivateKeyToJavaKeyStoreBytes
public static byte[] zookeeper_f4244_0(X509Certificate cert, PrivateKey privateKey, String keyPassword) throws IOException, GeneralSecurityException
{    KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());    return certAndPrivateKeyToPKCS12Bytes(cert, privateKey, keyPassword, keyStore);}
certAndPrivateKeyToPKCS12Bytes
public static byte[] zookeeper_f4245_0(X509Certificate cert, PrivateKey privateKey, String keyPassword) throws IOException, GeneralSecurityException
{    KeyStore keyStore = KeyStore.getInstance("PKCS12");    return certAndPrivateKeyToPKCS12Bytes(cert, privateKey, keyPassword, keyStore);}
certAndPrivateKeyToPKCS12Bytes
private static byte[] zookeeper_f4246_0(X509Certificate cert, PrivateKey privateKey, String keyPassword, KeyStore keyStore) throws IOException, GeneralSecurityException
{    char[] keyPasswordChars = keyPassword == null ? new char[0] : keyPassword.toCharArray();    keyStore.load(null, keyPasswordChars);    keyStore.setKeyEntry("key", privateKey, keyPasswordChars, new Certificate[] { cert });    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();    keyStore.store(outputStream, keyPasswordChars);    outputStream.flush();    byte[] result = outputStream.toByteArray();    outputStream.close();    return result;}
toX509Cert
public static X509Certificate zookeeper_f4247_0(X509CertificateHolder certHolder) throws CertificateException
{    return new JcaX509CertificateConverter().setProvider(BouncyCastleProvider.PROVIDER_NAME).getCertificate(certHolder);}
params
public static Collection<Object[]> zookeeper_f4248_0()
{    return BaseX509ParameterizedTestCase.defaultParams();}
setUp
public void zookeeper_f4249_0() throws Exception
{    try (X509Util x509util = new ClientX509Util()) {        x509TestContext.setSystemProperties(x509util, KeyStoreFileType.JKS, KeyStoreFileType.JKS);    }    System.setProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY, "org.apache.zookeeper.server.NettyServerCnxnFactory");    System.setProperty(ZKClientConfig.ZOOKEEPER_CLIENT_CNXN_SOCKET, "org.apache.zookeeper.ClientCnxnSocketNetty");    x509Util = new ClientX509Util();}
cleanUp
public void zookeeper_f4250_0()
{    x509TestContext.clearSystemProperties(x509Util);    System.clearProperty(x509Util.getSslOcspEnabledProperty());    System.clearProperty(x509Util.getSslCrlEnabledProperty());    System.clearProperty(x509Util.getCipherSuitesProperty());    System.clearProperty(x509Util.getSslProtocolProperty());    System.clearProperty(x509Util.getSslHandshakeDetectionTimeoutMillisProperty());    System.clearProperty("com.sun.net.ssl.checkRevocation");    System.clearProperty("com.sun.security.enableCRLDP");    Security.setProperty("ocsp.enable", Boolean.FALSE.toString());    Security.setProperty("com.sun.security.enableCRLDP", Boolean.FALSE.toString());    System.clearProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY);    System.clearProperty(ZKClientConfig.ZOOKEEPER_CLIENT_CNXN_SOCKET);    x509Util.close();}
testCreateSSLContextWithoutCustomProtocol
public void zookeeper_f4251_0() throws Exception
{    SSLContext sslContext = x509Util.getDefaultSSLContext();    assertEquals(X509Util.DEFAULT_PROTOCOL, sslContext.getProtocol());}
testCreateSSLContextWithCustomProtocol
public void zookeeper_f4252_0() throws Exception
{    final String protocol = "TLSv1.1";    System.setProperty(x509Util.getSslProtocolProperty(), protocol);    SSLContext sslContext = x509Util.getDefaultSSLContext();    assertEquals(protocol, sslContext.getProtocol());}
testCreateSSLContextWithoutKeyStoreLocation
public void zookeeper_f4253_0() throws Exception
{    System.clearProperty(x509Util.getSslKeystoreLocationProperty());    x509Util.getDefaultSSLContext();}
testCreateSSLContextWithoutKeyStorePassword
public void zookeeper_f4254_0() throws Exception
{    if (!x509TestContext.isKeyStoreEncrypted()) {        throw new X509Exception.SSLContextException("");    }    System.clearProperty(x509Util.getSslKeystorePasswdProperty());    x509Util.getDefaultSSLContext();}
testCreateSSLContextWithCustomCipherSuites
public void zookeeper_f4255_0() throws Exception
{    setCustomCipherSuites();    SSLSocket sslSocket = x509Util.createSSLSocket();    assertArrayEquals(customCipherSuites, sslSocket.getEnabledCipherSuites());}
testCRLEnabled
public void zookeeper_f4256_0() throws Exception
{    System.setProperty(x509Util.getSslCrlEnabledProperty(), "true");    x509Util.getDefaultSSLContext();    assertTrue(Boolean.valueOf(System.getProperty("com.sun.net.ssl.checkRevocation")));    assertTrue(Boolean.valueOf(System.getProperty("com.sun.security.enableCRLDP")));    assertFalse(Boolean.valueOf(Security.getProperty("ocsp.enable")));}
testCRLDisabled
public void zookeeper_f4257_0() throws Exception
{    x509Util.getDefaultSSLContext();    assertFalse(Boolean.valueOf(System.getProperty("com.sun.net.ssl.checkRevocation")));    assertFalse(Boolean.valueOf(System.getProperty("com.sun.security.enableCRLDP")));    assertFalse(Boolean.valueOf(Security.getProperty("ocsp.enable")));}
testOCSPEnabled
public void zookeeper_f4258_0() throws Exception
{    System.setProperty(x509Util.getSslOcspEnabledProperty(), "true");    x509Util.getDefaultSSLContext();    assertTrue(Boolean.valueOf(System.getProperty("com.sun.net.ssl.checkRevocation")));    assertTrue(Boolean.valueOf(System.getProperty("com.sun.security.enableCRLDP")));    assertTrue(Boolean.valueOf(Security.getProperty("ocsp.enable")));}
testCreateSSLSocket
public void zookeeper_f4259_0() throws Exception
{    setCustomCipherSuites();    SSLSocket sslSocket = x509Util.createSSLSocket();    assertArrayEquals(customCipherSuites, sslSocket.getEnabledCipherSuites());}
testCreateSSLServerSocketWithoutPort
public void zookeeper_f4260_0() throws Exception
{    setCustomCipherSuites();    SSLServerSocket sslServerSocket = x509Util.createSSLServerSocket();    assertArrayEquals(customCipherSuites, sslServerSocket.getEnabledCipherSuites());    assertTrue(sslServerSocket.getNeedClientAuth());}
testCreateSSLServerSocketWithPort
public void zookeeper_f4261_0() throws Exception
{    setCustomCipherSuites();    int port = PortAssignment.unique();    SSLServerSocket sslServerSocket = x509Util.createSSLServerSocket(port);    assertEquals(sslServerSocket.getLocalPort(), port);    assertArrayEquals(customCipherSuites, sslServerSocket.getEnabledCipherSuites());    assertTrue(sslServerSocket.getNeedClientAuth());}
testLoadPEMKeyStore
public void zookeeper_f4262_0() throws Exception
{        X509KeyManager km = X509Util.createKeyManager(x509TestContext.getKeyStoreFile(KeyStoreFileType.PEM).getAbsolutePath(), x509TestContext.getKeyStorePassword(), KeyStoreFileType.PEM.getPropertyValue());}
testLoadPEMKeyStoreNullPassword
public void zookeeper_f4263_0() throws Exception
{    if (!x509TestContext.getKeyStorePassword().isEmpty()) {        return;    }        X509KeyManager km = X509Util.createKeyManager(x509TestContext.getKeyStoreFile(KeyStoreFileType.PEM).getAbsolutePath(), null, KeyStoreFileType.PEM.getPropertyValue());}
testLoadPEMKeyStoreAutodetectStoreFileType
public void zookeeper_f4264_0() throws Exception
{        X509KeyManager km = X509Util.createKeyManager(x509TestContext.getKeyStoreFile(KeyStoreFileType.PEM).getAbsolutePath(), x509TestContext.getKeyStorePassword(), null);}
testLoadPEMKeyStoreWithWrongPassword
public void zookeeper_f4265_0() throws Exception
{        X509KeyManager km = X509Util.createKeyManager(x509TestContext.getKeyStoreFile(KeyStoreFileType.PEM).getAbsolutePath(),     "wrong password", KeyStoreFileType.PEM.getPropertyValue());}
testLoadPEMTrustStore
public void zookeeper_f4266_0() throws Exception
{        X509TrustManager tm = X509Util.createTrustManager(x509TestContext.getTrustStoreFile(KeyStoreFileType.PEM).getAbsolutePath(), x509TestContext.getTrustStorePassword(), KeyStoreFileType.PEM.getPropertyValue(), false, false, true, true);}
testLoadPEMTrustStoreNullPassword
public void zookeeper_f4267_0() throws Exception
{    if (!x509TestContext.getTrustStorePassword().isEmpty()) {        return;    }        X509TrustManager tm = X509Util.createTrustManager(x509TestContext.getTrustStoreFile(KeyStoreFileType.PEM).getAbsolutePath(), null, KeyStoreFileType.PEM.getPropertyValue(), false, false, true, true);}
testLoadPEMTrustStoreAutodetectStoreFileType
public void zookeeper_f4268_0() throws Exception
{        X509TrustManager tm = X509Util.createTrustManager(x509TestContext.getTrustStoreFile(KeyStoreFileType.PEM).getAbsolutePath(), x509TestContext.getTrustStorePassword(),     null, false, false, true, true);}
testLoadJKSKeyStore
public void zookeeper_f4269_0() throws Exception
{        X509KeyManager km = X509Util.createKeyManager(x509TestContext.getKeyStoreFile(KeyStoreFileType.JKS).getAbsolutePath(), x509TestContext.getKeyStorePassword(), KeyStoreFileType.JKS.getPropertyValue());}
testLoadJKSKeyStoreNullPassword
public void zookeeper_f4270_0() throws Exception
{    if (!x509TestContext.getKeyStorePassword().isEmpty()) {        return;    }        X509KeyManager km = X509Util.createKeyManager(x509TestContext.getKeyStoreFile(KeyStoreFileType.JKS).getAbsolutePath(), null, KeyStoreFileType.JKS.getPropertyValue());}
testLoadJKSKeyStoreAutodetectStoreFileType
public void zookeeper_f4271_0() throws Exception
{        X509KeyManager km = X509Util.createKeyManager(x509TestContext.getKeyStoreFile(KeyStoreFileType.JKS).getAbsolutePath(), x509TestContext.getKeyStorePassword(), null);}
testLoadJKSKeyStoreWithWrongPassword
public void zookeeper_f4272_0() throws Exception
{        X509KeyManager km = X509Util.createKeyManager(x509TestContext.getKeyStoreFile(KeyStoreFileType.JKS).getAbsolutePath(), "wrong password", KeyStoreFileType.JKS.getPropertyValue());}
testLoadJKSTrustStore
public void zookeeper_f4273_0() throws Exception
{        X509TrustManager tm = X509Util.createTrustManager(x509TestContext.getTrustStoreFile(KeyStoreFileType.JKS).getAbsolutePath(), x509TestContext.getTrustStorePassword(), KeyStoreFileType.JKS.getPropertyValue(), true, true, true, true);}
testLoadJKSTrustStoreNullPassword
public void zookeeper_f4274_0() throws Exception
{    if (!x509TestContext.getTrustStorePassword().isEmpty()) {        return;    }        X509TrustManager tm = X509Util.createTrustManager(x509TestContext.getTrustStoreFile(KeyStoreFileType.JKS).getAbsolutePath(), null, KeyStoreFileType.JKS.getPropertyValue(), false, false, true, true);}
testLoadJKSTrustStoreAutodetectStoreFileType
public void zookeeper_f4275_0() throws Exception
{        X509TrustManager tm = X509Util.createTrustManager(x509TestContext.getTrustStoreFile(KeyStoreFileType.JKS).getAbsolutePath(), x509TestContext.getTrustStorePassword(),     null, true, true, true, true);}
testLoadJKSTrustStoreWithWrongPassword
public void zookeeper_f4276_0() throws Exception
{        X509TrustManager tm = X509Util.createTrustManager(x509TestContext.getTrustStoreFile(KeyStoreFileType.JKS).getAbsolutePath(), "wrong password", KeyStoreFileType.JKS.getPropertyValue(), true, true, true, true);}
testLoadPKCS12KeyStore
public void zookeeper_f4277_0() throws Exception
{        X509KeyManager km = X509Util.createKeyManager(x509TestContext.getKeyStoreFile(KeyStoreFileType.PKCS12).getAbsolutePath(), x509TestContext.getKeyStorePassword(), KeyStoreFileType.PKCS12.getPropertyValue());}
testLoadPKCS12KeyStoreNullPassword
public void zookeeper_f4278_0() throws Exception
{    if (!x509TestContext.getKeyStorePassword().isEmpty()) {        return;    }        X509KeyManager km = X509Util.createKeyManager(x509TestContext.getKeyStoreFile(KeyStoreFileType.PKCS12).getAbsolutePath(), null, KeyStoreFileType.PKCS12.getPropertyValue());}
testLoadPKCS12KeyStoreAutodetectStoreFileType
public void zookeeper_f4279_0() throws Exception
{        X509KeyManager km = X509Util.createKeyManager(x509TestContext.getKeyStoreFile(KeyStoreFileType.PKCS12).getAbsolutePath(), x509TestContext.getKeyStorePassword(), null);}
testLoadPKCS12KeyStoreWithWrongPassword
public void zookeeper_f4280_0() throws Exception
{        X509KeyManager km = X509Util.createKeyManager(x509TestContext.getKeyStoreFile(KeyStoreFileType.PKCS12).getAbsolutePath(), "wrong password", KeyStoreFileType.PKCS12.getPropertyValue());}
testLoadPKCS12TrustStore
public void zookeeper_f4281_0() throws Exception
{        X509TrustManager tm = X509Util.createTrustManager(x509TestContext.getTrustStoreFile(KeyStoreFileType.PKCS12).getAbsolutePath(), x509TestContext.getTrustStorePassword(), KeyStoreFileType.PKCS12.getPropertyValue(), true, true, true, true);}
testLoadPKCS12TrustStoreNullPassword
public void zookeeper_f4282_0() throws Exception
{    if (!x509TestContext.getTrustStorePassword().isEmpty()) {        return;    }        X509TrustManager tm = X509Util.createTrustManager(x509TestContext.getTrustStoreFile(KeyStoreFileType.PKCS12).getAbsolutePath(), null, KeyStoreFileType.PKCS12.getPropertyValue(), false, false, true, true);}
testLoadPKCS12TrustStoreAutodetectStoreFileType
public void zookeeper_f4283_0() throws Exception
{        X509TrustManager tm = X509Util.createTrustManager(x509TestContext.getTrustStoreFile(KeyStoreFileType.PKCS12).getAbsolutePath(), x509TestContext.getTrustStorePassword(),     null, true, true, true, true);}
testLoadPKCS12TrustStoreWithWrongPassword
public void zookeeper_f4284_0() throws Exception
{        X509TrustManager tm = X509Util.createTrustManager(x509TestContext.getTrustStoreFile(KeyStoreFileType.PKCS12).getAbsolutePath(), "wrong password", KeyStoreFileType.PKCS12.getPropertyValue(), true, true, true, true);}
testGetSslHandshakeDetectionTimeoutMillisProperty
public void zookeeper_f4285_0()
{    assertEquals(X509Util.DEFAULT_HANDSHAKE_DETECTION_TIMEOUT_MILLIS, x509Util.getSslHandshakeTimeoutMillis());        String newPropertyString = Integer.toString(X509Util.DEFAULT_HANDSHAKE_DETECTION_TIMEOUT_MILLIS + 1);    System.setProperty(x509Util.getSslHandshakeDetectionTimeoutMillisProperty(), newPropertyString);    try (X509Util tempX509Util = new ClientX509Util()) {        assertEquals(X509Util.DEFAULT_HANDSHAKE_DETECTION_TIMEOUT_MILLIS + 1, tempX509Util.getSslHandshakeTimeoutMillis());    }        System.setProperty(x509Util.getSslHandshakeDetectionTimeoutMillisProperty(), "0");    try (X509Util tempX509Util = new ClientX509Util()) {        assertEquals(X509Util.DEFAULT_HANDSHAKE_DETECTION_TIMEOUT_MILLIS, tempX509Util.getSslHandshakeTimeoutMillis());    }        System.setProperty(x509Util.getSslHandshakeDetectionTimeoutMillisProperty(), "-1");    try (X509Util tempX509Util = new ClientX509Util()) {        assertEquals(X509Util.DEFAULT_HANDSHAKE_DETECTION_TIMEOUT_MILLIS, tempX509Util.getSslHandshakeTimeoutMillis());    }}
testCreateSSLContext_invalidCustomSSLContextClass
public void zookeeper_f4286_0() throws Exception
{    ZKConfig zkConfig = new ZKConfig();    ClientX509Util clientX509Util = new ClientX509Util();    zkConfig.setProperty(clientX509Util.getSslContextSupplierClassProperty(), String.class.getCanonicalName());    clientX509Util.createSSLContext(zkConfig);}
testCreateSSLContext_validCustomSSLContextClass
public void zookeeper_f4287_0() throws Exception
{    ZKConfig zkConfig = new ZKConfig();    ClientX509Util clientX509Util = new ClientX509Util();    zkConfig.setProperty(clientX509Util.getSslContextSupplierClassProperty(), SslContextSupplier.class.getName());    final SSLContext sslContext = clientX509Util.createSSLContext(zkConfig);    assertEquals(SSLContext.getDefault(), sslContext);}
forceClose
private static void zookeeper_f4288_0(Socket s)
{    if (s == null || s.isClosed()) {        return;    }    try {        s.close();    } catch (IOException e) {    }}
forceClose
private static void zookeeper_f4289_0(ServerSocket s)
{    if (s == null || s.isClosed()) {        return;    }    try {        s.close();    } catch (IOException e) {    }}
testClientRenegotiationFails
public void zookeeper_f4290_0() throws Throwable
{    int port = PortAssignment.unique();    ExecutorService workerPool = Executors.newCachedThreadPool();    final SSLServerSocket listeningSocket = x509Util.createSSLServerSocket();    SSLSocket clientSocket = null;    SSLSocket serverSocket = null;    final AtomicInteger handshakesCompleted = new AtomicInteger(0);    final CountDownLatch handshakeCompleted = new CountDownLatch(1);    try {        InetSocketAddress localServerAddress = new InetSocketAddress(InetAddress.getLoopbackAddress(), port);        listeningSocket.bind(localServerAddress);        Future<SSLSocket> acceptFuture;        acceptFuture = workerPool.submit(new Callable<SSLSocket>() {            @Override            public SSLSocket call() throws Exception {                SSLSocket sslSocket = (SSLSocket) listeningSocket.accept();                sslSocket.addHandshakeCompletedListener(new HandshakeCompletedListener() {                    @Override                    public void handshakeCompleted(HandshakeCompletedEvent handshakeCompletedEvent) {                        handshakesCompleted.getAndIncrement();                        handshakeCompleted.countDown();                    }                });                assertEquals(1, sslSocket.getInputStream().read());                try {                                        sslSocket.getInputStream().read();                    return sslSocket;                } catch (Exception e) {                    forceClose(sslSocket);                    throw e;                }            }        });        clientSocket = x509Util.createSSLSocket();        clientSocket.connect(localServerAddress);        clientSocket.getOutputStream().write(1);                clientSocket.startHandshake();        clientSocket.getOutputStream().write(1);                try {            serverSocket = acceptFuture.get();        } catch (ExecutionException e) {            throw e.getCause();        }    } finally {        forceClose(serverSocket);        forceClose(clientSocket);        forceClose(listeningSocket);        workerPool.shutdown();                        handshakeCompleted.await(5, TimeUnit.SECONDS);        assertEquals(1, handshakesCompleted.get());    }}
call
public SSLSocket zookeeper_f4291_0() throws Exception
{    SSLSocket sslSocket = (SSLSocket) listeningSocket.accept();    sslSocket.addHandshakeCompletedListener(new HandshakeCompletedListener() {        @Override        public void handshakeCompleted(HandshakeCompletedEvent handshakeCompletedEvent) {            handshakesCompleted.getAndIncrement();            handshakeCompleted.countDown();        }    });    assertEquals(1, sslSocket.getInputStream().read());    try {                sslSocket.getInputStream().read();        return sslSocket;    } catch (Exception e) {        forceClose(sslSocket);        throw e;    }}
handshakeCompleted
public void zookeeper_f4292_0(HandshakeCompletedEvent handshakeCompletedEvent)
{    handshakesCompleted.getAndIncrement();    handshakeCompleted.countDown();}
testGetDefaultCipherSuitesJava8
public void zookeeper_f4293_0()
{    String[] cipherSuites = X509Util.getDefaultCipherSuitesForJavaVersion("1.8");        assertTrue(cipherSuites[0].contains("CBC"));}
testGetDefaultCipherSuitesJava9
public void zookeeper_f4294_0()
{    String[] cipherSuites = X509Util.getDefaultCipherSuitesForJavaVersion("9");        assertTrue(cipherSuites[0].contains("GCM"));}
testGetDefaultCipherSuitesJava10
public void zookeeper_f4295_0()
{    String[] cipherSuites = X509Util.getDefaultCipherSuitesForJavaVersion("10");        assertTrue(cipherSuites[0].contains("GCM"));}
testGetDefaultCipherSuitesJava11
public void zookeeper_f4296_0()
{    String[] cipherSuites = X509Util.getDefaultCipherSuitesForJavaVersion("11");        assertTrue(cipherSuites[0].contains("GCM"));}
testGetDefaultCipherSuitesUnknownVersion
public void zookeeper_f4297_0()
{    String[] cipherSuites = X509Util.getDefaultCipherSuitesForJavaVersion("notaversion");        assertTrue(cipherSuites[0].contains("CBC"));}
testGetDefaultCipherSuitesNullVersion
public void zookeeper_f4298_0()
{    X509Util.getDefaultCipherSuitesForJavaVersion(null);}
setCustomCipherSuites
private void zookeeper_f4299_0()
{    System.setProperty(x509Util.getCipherSuitesProperty(), customCipherSuites[0] + "," + customCipherSuites[1]);        x509Util.close();    x509Util = new ClientX509Util();}
get
public SSLContext zookeeper_f4300_0()
{    try {        return SSLContext.getDefault();    } catch (NoSuchAlgorithmException e) {        throw new RuntimeException(e);    }}
createKeyPair
public static void zookeeper_f4301_0() throws Exception
{    Security.addProvider(new BouncyCastleProvider());    KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("RSA", BouncyCastleProvider.PROVIDER_NAME);    keyPairGenerator.initialize(4096);    keyPair = keyPairGenerator.genKeyPair();}
removeBouncyCastleProvider
public static void zookeeper_f4302_0() throws Exception
{    Security.removeProvider("BC");}
setup
public void zookeeper_f4303_0() throws Exception
{    mockX509ExtendedTrustManager = mock(X509ExtendedTrustManager.class);    mockInetAddress = mock(InetAddress.class);    when(mockInetAddress.getHostAddress()).thenAnswer(new Answer() {        @Override        public Object answer(InvocationOnMock invocationOnMock) throws Throwable {            return IP_ADDRESS;        }    });    when(mockInetAddress.getHostName()).thenAnswer(new Answer() {        @Override        public Object answer(InvocationOnMock invocationOnMock) throws Throwable {            return HOSTNAME;        }    });    mockSocket = mock(Socket.class);    when(mockSocket.getInetAddress()).thenAnswer(new Answer() {        @Override        public Object answer(InvocationOnMock invocationOnMock) throws Throwable {            return mockInetAddress;        }    });}
answer
public Object zookeeper_f4304_0(InvocationOnMock invocationOnMock) throws Throwable
{    return IP_ADDRESS;}
answer
public Object zookeeper_f4305_0(InvocationOnMock invocationOnMock) throws Throwable
{    return HOSTNAME;}
answer
public Object zookeeper_f4306_0(InvocationOnMock invocationOnMock) throws Throwable
{    return mockInetAddress;}
createSelfSignedCertifcateChain
private X509Certificate[] zookeeper_f4307_0(String ipAddress, String hostname) throws Exception
{    X500NameBuilder nameBuilder = new X500NameBuilder(BCStyle.INSTANCE);    nameBuilder.addRDN(BCStyle.CN, "NOT_LOCALHOST");    Date notBefore = new Date();    Calendar cal = Calendar.getInstance();    cal.setTime(notBefore);    cal.add(Calendar.YEAR, 1);    Date notAfter = cal.getTime();    BigInteger serialNumber = new BigInteger(128, new Random());    X509v3CertificateBuilder certificateBuilder = new JcaX509v3CertificateBuilder(nameBuilder.build(), serialNumber, notBefore, notAfter, nameBuilder.build(), keyPair.getPublic()).addExtension(Extension.basicConstraints, true, new BasicConstraints(0)).addExtension(Extension.keyUsage, true, new KeyUsage(KeyUsage.digitalSignature | KeyUsage.keyCertSign | KeyUsage.cRLSign));    List<GeneralName> generalNames = new ArrayList<>();    if (ipAddress != null) {        generalNames.add(new GeneralName(GeneralName.iPAddress, ipAddress));    }    if (hostname != null) {        generalNames.add(new GeneralName(GeneralName.dNSName, hostname));    }    if (!generalNames.isEmpty()) {        certificateBuilder.addExtension(Extension.subjectAlternativeName, true, new GeneralNames(generalNames.toArray(new GeneralName[] {})));    }    ContentSigner contentSigner = new JcaContentSignerBuilder("SHA256WithRSAEncryption").build(keyPair.getPrivate());    return new X509Certificate[] { new JcaX509CertificateConverter().getCertificate(certificateBuilder.build(contentSigner)) };}
testServerHostnameVerificationWithHostnameVerificationDisabled
public void zookeeper_f4308_0() throws Exception
{    ZKTrustManager zkTrustManager = new ZKTrustManager(mockX509ExtendedTrustManager, false, false);    X509Certificate[] certificateChain = createSelfSignedCertifcateChain(IP_ADDRESS, HOSTNAME);    zkTrustManager.checkServerTrusted(certificateChain, null, mockSocket);    verify(mockInetAddress, times(0)).getHostAddress();    verify(mockInetAddress, times(0)).getHostName();    verify(mockX509ExtendedTrustManager, times(1)).checkServerTrusted(certificateChain, null, mockSocket);}
testServerHostnameVerificationWithHostnameVerificationDisabledAndClientHostnameVerificationEnabled
public void zookeeper_f4309_0() throws Exception
{    ZKTrustManager zkTrustManager = new ZKTrustManager(mockX509ExtendedTrustManager, false, true);    X509Certificate[] certificateChain = createSelfSignedCertifcateChain(IP_ADDRESS, HOSTNAME);    zkTrustManager.checkServerTrusted(certificateChain, null, mockSocket);    verify(mockInetAddress, times(0)).getHostAddress();    verify(mockInetAddress, times(0)).getHostName();    verify(mockX509ExtendedTrustManager, times(1)).checkServerTrusted(certificateChain, null, mockSocket);}
testServerHostnameVerificationWithIPAddress
public void zookeeper_f4310_0() throws Exception
{    ZKTrustManager zkTrustManager = new ZKTrustManager(mockX509ExtendedTrustManager, true, false);    X509Certificate[] certificateChain = createSelfSignedCertifcateChain(IP_ADDRESS, null);    zkTrustManager.checkServerTrusted(certificateChain, null, mockSocket);    verify(mockInetAddress, times(1)).getHostAddress();    verify(mockInetAddress, times(0)).getHostName();    verify(mockX509ExtendedTrustManager, times(1)).checkServerTrusted(certificateChain, null, mockSocket);}
testServerHostnameVerificationWithHostname
public void zookeeper_f4311_0() throws Exception
{    ZKTrustManager zkTrustManager = new ZKTrustManager(mockX509ExtendedTrustManager, true, false);    X509Certificate[] certificateChain = createSelfSignedCertifcateChain(null, HOSTNAME);    zkTrustManager.checkServerTrusted(certificateChain, null, mockSocket);    verify(mockInetAddress, times(1)).getHostAddress();    verify(mockInetAddress, times(1)).getHostName();    verify(mockX509ExtendedTrustManager, times(1)).checkServerTrusted(certificateChain, null, mockSocket);}
testClientHostnameVerificationWithHostnameVerificationDisabled
public void zookeeper_f4312_0() throws Exception
{    ZKTrustManager zkTrustManager = new ZKTrustManager(mockX509ExtendedTrustManager, false, true);    X509Certificate[] certificateChain = createSelfSignedCertifcateChain(null, HOSTNAME);    zkTrustManager.checkClientTrusted(certificateChain, null, mockSocket);    verify(mockInetAddress, times(1)).getHostAddress();    verify(mockInetAddress, times(1)).getHostName();    verify(mockX509ExtendedTrustManager, times(1)).checkClientTrusted(certificateChain, null, mockSocket);}
testClientHostnameVerificationWithClientHostnameVerificationDisabled
public void zookeeper_f4313_0() throws Exception
{    ZKTrustManager zkTrustManager = new ZKTrustManager(mockX509ExtendedTrustManager, true, false);    X509Certificate[] certificateChain = createSelfSignedCertifcateChain(null, HOSTNAME);    zkTrustManager.checkClientTrusted(certificateChain, null, mockSocket);    verify(mockInetAddress, times(0)).getHostAddress();    verify(mockInetAddress, times(0)).getHostName();    verify(mockX509ExtendedTrustManager, times(1)).checkClientTrusted(certificateChain, null, mockSocket);}
testClientHostnameVerificationWithIPAddress
public void zookeeper_f4314_0() throws Exception
{    ZKTrustManager zkTrustManager = new ZKTrustManager(mockX509ExtendedTrustManager, true, true);    X509Certificate[] certificateChain = createSelfSignedCertifcateChain(IP_ADDRESS, null);    zkTrustManager.checkClientTrusted(certificateChain, null, mockSocket);    verify(mockInetAddress, times(1)).getHostAddress();    verify(mockInetAddress, times(0)).getHostName();    verify(mockX509ExtendedTrustManager, times(1)).checkClientTrusted(certificateChain, null, mockSocket);}
testClientHostnameVerificationWithHostname
public void zookeeper_f4315_0() throws Exception
{    ZKTrustManager zkTrustManager = new ZKTrustManager(mockX509ExtendedTrustManager, true, true);    X509Certificate[] certificateChain = createSelfSignedCertifcateChain(null, HOSTNAME);    zkTrustManager.checkClientTrusted(certificateChain, null, mockSocket);    verify(mockInetAddress, times(1)).getHostAddress();    verify(mockInetAddress, times(1)).getHostName();    verify(mockX509ExtendedTrustManager, times(1)).checkClientTrusted(certificateChain, null, mockSocket);}
size
public int zookeeper_f4316_0()
{    return 1;}
next
public InetSocketAddress zookeeper_f4317_0(long spinDelay)
{    return new InetSocketAddress("127.0.0.1", 2181);}
onConnected
public void zookeeper_f4318_0()
{}
updateServerList
public boolean zookeeper_f4319_0(Collection<InetSocketAddress> serverAddresses, InetSocketAddress currentHost)
{    counter.decrementAndGet();    return false;}
testZooKeeperWithCustomHostProvider
public void zookeeper_f4320_0() throws IOException, InterruptedException
{    final int CLIENT_PORT = PortAssignment.unique();    final HostProvider specialHostProvider = new SpecialHostProvider();    int expectedCounter = 3;    counter.set(expectedCounter);    ZooKeeper zkDefaults = new ZooKeeper("127.0.0.1:" + CLIENT_PORT, ClientBase.CONNECTION_TIMEOUT, DummyWatcher.INSTANCE, false);    ZooKeeper zkSpecial = new ZooKeeper("127.0.0.1:" + CLIENT_PORT, ClientBase.CONNECTION_TIMEOUT, DummyWatcher.INSTANCE, false, specialHostProvider);    assertTrue(counter.get() == expectedCounter);    zkDefaults.updateServerList("127.0.0.1:" + PortAssignment.unique());    assertTrue(counter.get() == expectedCounter);    zkSpecial.updateServerList("127.0.0.1:" + PortAssignment.unique());    expectedCounter--;    assertTrue(counter.get() == expectedCounter);}
process
public void zookeeper_f4321_0(WatchedEvent event)
{}
setUp
public void zookeeper_f4322_0() throws Exception
{    super.setUp();    zk = createClient();    generatePaths(PERSISTENT_CNT, EPHEMERAL_CNT);}
tearDown
public void zookeeper_f4323_0() throws Exception
{    super.tearDown();    zk.close();}
testGetAllChildrenNumberSync
public void zookeeper_f4324_0() throws KeeperException, InterruptedException
{        try {        zk.getAllChildrenNumber(null);        fail("the path for getAllChildrenNumber must not be null.");    } catch (IllegalArgumentException e) {        }    assertEquals(EPHEMERAL_CNT, zk.getAllChildrenNumber(BASE + "/0"));    assertEquals(0, zk.getAllChildrenNumber(BASE + "/0/ephem0"));    assertEquals(0, zk.getAllChildrenNumber(BASE_EXT));    assertEquals(PERSISTENT_CNT + PERSISTENT_CNT * EPHEMERAL_CNT, zk.getAllChildrenNumber(BASE));        assertEquals(13, zk.getAllChildrenNumber("/"));}
testGetAllChildrenNumberAsync
public void zookeeper_f4325_0() throws IOException, KeeperException, InterruptedException
{    final CountDownLatch doneProcessing = new CountDownLatch(1);    zk.getAllChildrenNumber("/", new AsyncCallback.AllChildrenNumberCallback() {        @Override        public void processResult(int rc, String path, Object ctx, int number) {            if (path == null) {                fail((String.format("the path of getAllChildrenNumber was null.")));            }            assertEquals(13, number);            doneProcessing.countDown();        }    }, null);    long waitForCallbackSecs = 2L;    if (!doneProcessing.await(waitForCallbackSecs, TimeUnit.SECONDS)) {        fail(String.format("getAllChildrenNumber didn't callback within %d seconds", waitForCallbackSecs));    }}
processResult
public void zookeeper_f4326_0(int rc, String path, Object ctx, int number)
{    if (path == null) {        fail((String.format("the path of getAllChildrenNumber was null.")));    }    assertEquals(13, number);    doneProcessing.countDown();}
generatePaths
private void zookeeper_f4327_0(int persistantCnt, int ephemeralCnt) throws KeeperException, InterruptedException
{    zk.create(BASE, BASE.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create(BASE_EXT, BASE_EXT.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    for (int p = 0; p < persistantCnt; p++) {        String base = BASE + "/" + p;        zk.create(base, base.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        for (int e = 0; e < ephemeralCnt; e++) {            String ephem = base + "/ephem" + e;            zk.create(ephem, ephem.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);        }    }}
setUp
public void zookeeper_f4328_0() throws Exception
{    super.setUp();    zk = createClient();    expected = generatePaths(PERSISTENT_CNT, EPHEMERAL_CNT);}
tearDown
public void zookeeper_f4329_0() throws Exception
{    super.tearDown();    zk.close();}
testGetEphemeralsSync
public void zookeeper_f4330_0() throws KeeperException, InterruptedException
{    List<String> actual = zk.getEphemerals();    assertEquals("Expected ephemeral count for allPaths", actual.size(), expected.length);    for (int i = 0; i < expected.length; i++) {        String path = expected[i];        assertTrue(String.format("Path=%s exists in get All Ephemerals list ", path), actual.contains(path));    }}
testGetEphemeralsSyncByPath
public void zookeeper_f4331_0() throws KeeperException, InterruptedException
{    final String prefixPath = BASE + 0;    List<String> actual = zk.getEphemerals(prefixPath);    assertEquals("Expected ephemeral count for allPaths", actual.size(), EPHEMERAL_CNT);    for (int i = 0; i < EPHEMERAL_CNT; i++) {        String path = expected[i];        assertTrue(String.format("Path=%s exists in getEphemerals(%s) list ", path, prefixPath), actual.contains(path));    }}
testGetEphemerals
public void zookeeper_f4332_0() throws IOException, KeeperException, InterruptedException
{    final CountDownLatch doneProcessing = new CountDownLatch(1);    final List<String> unexpectedBehavior = new ArrayList<String>();    zk.getEphemerals(new AsyncCallback.EphemeralsCallback() {        @Override        public void processResult(int rc, Object ctx, List<String> paths) {            if (paths == null) {                unexpectedBehavior.add(String.format("Expected ephemeral count for" + " allPaths to be %d but was null", expected.length));            } else if (paths.size() != expected.length) {                unexpectedBehavior.add(String.format("Expected ephemeral count for allPaths to be %d but was %d", expected.length, paths.size()));            }            for (int i = 0; i < expected.length; i++) {                String path = expected[i];                if (!paths.contains(path)) {                    unexpectedBehavior.add(String.format("Path=%s exists in getEphemerals list ", path));                }            }            doneProcessing.countDown();        }    }, null);    long waitForCallbackSecs = 2L;    if (!doneProcessing.await(waitForCallbackSecs, TimeUnit.SECONDS)) {        fail(String.format("getEphemerals didn't callback within %d seconds", waitForCallbackSecs));    }    checkForUnexpectedBehavior(unexpectedBehavior);}
processResult
public void zookeeper_f4333_0(int rc, Object ctx, List<String> paths)
{    if (paths == null) {        unexpectedBehavior.add(String.format("Expected ephemeral count for" + " allPaths to be %d but was null", expected.length));    } else if (paths.size() != expected.length) {        unexpectedBehavior.add(String.format("Expected ephemeral count for allPaths to be %d but was %d", expected.length, paths.size()));    }    for (int i = 0; i < expected.length; i++) {        String path = expected[i];        if (!paths.contains(path)) {            unexpectedBehavior.add(String.format("Path=%s exists in getEphemerals list ", path));        }    }    doneProcessing.countDown();}
testGetEphemeralsByPath
public void zookeeper_f4334_0() throws IOException, KeeperException, InterruptedException
{    final CountDownLatch doneProcessing = new CountDownLatch(1);    final String checkPath = BASE + "0";    final List<String> unexpectedBehavior = new ArrayList<String>();    zk.getEphemerals(checkPath, new AsyncCallback.EphemeralsCallback() {        @Override        public void processResult(int rc, Object ctx, List<String> paths) {            if (paths == null) {                unexpectedBehavior.add(String.format("Expected ephemeral count for %s to be %d but was null", checkPath, expected.length));            } else if (paths.size() != EPHEMERAL_CNT) {                unexpectedBehavior.add(String.format("Expected ephemeral count for %s to be %d but was %d", checkPath, EPHEMERAL_CNT, paths.size()));            }            for (int i = 0; i < EPHEMERAL_CNT; i++) {                String path = expected[i];                if (!paths.contains(path)) {                    unexpectedBehavior.add(String.format("Expected path=%s didn't exist " + "in getEphemerals list.", path));                }            }            doneProcessing.countDown();        }    }, null);    long waitForCallbackSecs = 2L;    if (!doneProcessing.await(waitForCallbackSecs, TimeUnit.SECONDS)) {        fail(String.format("getEphemerals(%s) didn't callback within %d seconds", checkPath, waitForCallbackSecs));    }    checkForUnexpectedBehavior(unexpectedBehavior);}
processResult
public void zookeeper_f4335_0(int rc, Object ctx, List<String> paths)
{    if (paths == null) {        unexpectedBehavior.add(String.format("Expected ephemeral count for %s to be %d but was null", checkPath, expected.length));    } else if (paths.size() != EPHEMERAL_CNT) {        unexpectedBehavior.add(String.format("Expected ephemeral count for %s to be %d but was %d", checkPath, EPHEMERAL_CNT, paths.size()));    }    for (int i = 0; i < EPHEMERAL_CNT; i++) {        String path = expected[i];        if (!paths.contains(path)) {            unexpectedBehavior.add(String.format("Expected path=%s didn't exist " + "in getEphemerals list.", path));        }    }    doneProcessing.countDown();}
testGetEphemeralsEmpty
public void zookeeper_f4336_0() throws IOException, KeeperException, InterruptedException
{    final CountDownLatch doneProcessing = new CountDownLatch(1);    final String checkPath = "/unknownPath";    final int expectedSize = 0;    final List<String> unexpectedBehavior = new ArrayList<String>();    zk.getEphemerals(checkPath, new AsyncCallback.EphemeralsCallback() {        @Override        public void processResult(int rc, Object ctx, List<String> paths) {            if (paths == null) {                unexpectedBehavior.add(String.format("Expected ephemeral count for %s to be %d but was null", checkPath, expectedSize));            } else if (paths.size() != expectedSize) {                unexpectedBehavior.add(String.format("Expected ephemeral count for %s to be %d but was %d", checkPath, expectedSize, paths.size()));            }            doneProcessing.countDown();        }    }, null);    long waitForCallbackSecs = 2L;    if (!doneProcessing.await(waitForCallbackSecs, TimeUnit.SECONDS)) {        fail(String.format("getEphemerals(%s) didn't callback within %d seconds", checkPath, waitForCallbackSecs));    }    checkForUnexpectedBehavior(unexpectedBehavior);}
processResult
public void zookeeper_f4337_0(int rc, Object ctx, List<String> paths)
{    if (paths == null) {        unexpectedBehavior.add(String.format("Expected ephemeral count for %s to be %d but was null", checkPath, expectedSize));    } else if (paths.size() != expectedSize) {        unexpectedBehavior.add(String.format("Expected ephemeral count for %s to be %d but was %d", checkPath, expectedSize, paths.size()));    }    doneProcessing.countDown();}
testGetEphemeralsErrors
public void zookeeper_f4338_0() throws KeeperException
{    try {        zk.getEphemerals(null, null, null);        fail("Should have thrown a IllegalArgumentException for a null prefixPath");    } catch (IllegalArgumentException e) {        }    try {        zk.getEphemerals("no leading slash", null, null);        fail("Should have thrown a IllegalArgumentException " + "for a prefix with no leading slash");    } catch (IllegalArgumentException e) {        }}
generatePaths
private String[] zookeeper_f4339_0(int persistantCnt, int ephemeralCnt) throws KeeperException, InterruptedException
{    final String[] expected = new String[persistantCnt * ephemeralCnt];    for (int p = 0; p < persistantCnt; p++) {        String base = BASE + p;        zk.create(base, base.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        for (int e = 0; e < ephemeralCnt; e++) {            String ephem = base + "/ephem" + e;            zk.create(ephem, ephem.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);            expected[p * ephemeralCnt + e] = ephem;        }    }    return expected;}
checkForUnexpectedBehavior
private void zookeeper_f4340_0(List<String> unexpectedBehavior)
{    if (unexpectedBehavior.size() > 0) {        StringBuilder b = new StringBuilder("The test failed for the following reasons:");        b.append(NEWLINE);        for (String error : unexpectedBehavior) {            b.append("ERROR: ").append(error).append(NEWLINE);        }        fail(b.toString());    }}
addSection
public void zookeeper_f4341_0(String name, String loginModuleName, String... args)
{    Map<String, String> conf = new HashMap<String, String>();        for (int i = 0; i < args.length - 1; i += 2) {        conf.put(args[i], args[i + 1]);    }    addSection(name, loginModuleName, conf);}
addSection
public void zookeeper_f4342_0(String name, String loginModuleName, final Map<String, String> conf)
{    AppConfigurationEntry[] entries = new AppConfigurationEntry[1];    entries[0] = new AppConfigurationEntry(loginModuleName, LoginModuleControlFlag.REQUIRED, conf);    this.sections.put(name, entries);}
getAppConfigurationEntry
public AppConfigurationEntry[] zookeeper_f4343_0(String appName)
{    return sections.get(appName);}
computeTestMethodsForClass
public static List<FrameworkMethod>f4344_1final Class klass, final List<FrameworkMethod> defaultMethods)
{    List<FrameworkMethod> list = defaultMethods;    String methodName = System.getProperty("test.method");    if (methodName == null) {            } else {                try {            list = Arrays.asList(new FrameworkMethod(klass.getMethod(methodName)));        } catch (NoSuchMethodException nsme) {                    }    }    return list;}
computeTestMethods
protected List<FrameworkMethod> zookeeper_f4345_0()
{    return computeTestMethodsForClass(getTestClass().getJavaClass(), super.computeTestMethods());}
evaluate
public voidf4346_1) throws Throwable
{        try {        super.evaluate();        Runtime rt = Runtime.getRuntime();        long usedKB = (rt.totalMemory() - rt.freeMemory()) / 1024;                ThreadGroup tg = Thread.currentThread().getThreadGroup();        while (tg.getParent() != null) {            tg = tg.getParent();        }            } catch (Throwable t) {                                Test annotation = this.method.getAnnotation(Test.class);        if (annotation != null && annotation.expected() != null && annotation.expected().isAssignableFrom(t.getClass())) {                    } else {                    }        throw t;    }    }
methodInvoker
protected Statement zookeeper_f4347_0(FrameworkMethod method, Object test)
{    return new LoggedInvokeMethod(method, test);}
configure
public void zookeeper_f4348_0(Properties prprts) throws MetricsProviderLifeCycleException
{}
start
public void zookeeper_f4349_0() throws MetricsProviderLifeCycleException
{}
getRootContext
public MetricsContext zookeeper_f4350_0()
{    return NullMetricsProvider.NullMetricsContext.INSTANCE;}
stop
public void zookeeper_f4351_0()
{}
dump
public void zookeeper_f4352_0(BiConsumer<String, Object> sink)
{}
resetAllValues
public void zookeeper_f4353_0()
{}
reset
public static void zookeeper_f4354_0()
{    configureCalled.set(false);    startCalled.set(false);    stopCalled.set(false);    getRootContextCalled.set(false);}
configure
public void zookeeper_f4355_0(Properties prprts) throws MetricsProviderLifeCycleException
{    if (!configureCalled.compareAndSet(false, true)) {                throw new IllegalStateException();    }}
start
public void zookeeper_f4356_0() throws MetricsProviderLifeCycleException
{    if (!startCalled.compareAndSet(false, true)) {                throw new IllegalStateException();    }}
getRootContext
public MetricsContext zookeeper_f4357_0()
{    getRootContextCalled.set(true);    return NullMetricsProvider.NullMetricsContext.INSTANCE;}
stop
public void zookeeper_f4358_0()
{    if (!stopCalled.compareAndSet(false, true)) {                throw new IllegalStateException();    }}
start
public void zookeeper_f4359_0() throws MetricsProviderLifeCycleException
{    throw new MetricsProviderLifeCycleException();}
configure
public void zookeeper_f4360_0(Properties prprts) throws MetricsProviderLifeCycleException
{    throw new MetricsProviderLifeCycleException();}
configure
public void zookeeper_f4361_0(Properties prprts) throws MetricsProviderLifeCycleException
{    httpPort.set(Integer.parseInt(prprts.getProperty("httpPort")));}
stop
public void zookeeper_f4362_0()
{    stopCalled.set(true);    throw new RuntimeException();}
collect
public static Map<String, Object> zookeeper_f4363_0(MetricsProvider metricsProvider)
{    Map<String, Object> res = new HashMap<>();    metricsProvider.dump(res::put);    return res;}
currentServerMetrics
public static Map<String, Object> zookeeper_f4364_0()
{    return collect(ServerMetrics.getMetrics().getMetricsProvider());}
createAndReturnBB
public ByteBuffer zookeeper_f4365_0()
{    createBB();    return this.bb;}
testRoundTrip
public void zookeeper_f4366_0() throws IOException
{    MultiOperationRecord request = new MultiOperationRecord();    request.add(Op.check("check", 1));    request.add(Op.create("create", "create data".getBytes(), ZooDefs.Ids.CREATOR_ALL_ACL, ZooDefs.Perms.ALL));    request.add(Op.delete("delete", 17));    request.add(Op.setData("setData", "set data".getBytes(), 19));    MultiOperationRecord decodedRequest = codeDecode(request);    assertEquals(request, decodedRequest);    assertEquals(request.hashCode(), decodedRequest.hashCode());}
testEmptyRoundTrip
public void zookeeper_f4367_0() throws IOException
{    MultiOperationRecord request = new MultiOperationRecord();    MultiOperationRecord decodedRequest = codeDecode(request);    assertEquals(request, decodedRequest);    assertEquals(request.hashCode(), decodedRequest.hashCode());}
codeDecode
private MultiOperationRecord zookeeper_f4368_0(MultiOperationRecord request) throws IOException
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos);    request.serialize(boa, "request");    baos.close();    ByteBuffer bb = ByteBuffer.wrap(baos.toByteArray());    bb.rewind();    BinaryInputArchive bia = BinaryInputArchive.getArchive(new ByteBufferInputStream(bb));    MultiOperationRecord decodedRequest = new MultiOperationRecord();    decodedRequest.deserialize(bia, "request");    return decodedRequest;}
testRoundTrip
public void zookeeper_f4369_0() throws IOException
{    MultiResponse response = new MultiResponse();    response.add(new OpResult.CheckResult());    response.add(new OpResult.CreateResult("foo-bar"));    response.add(new OpResult.DeleteResult());    Stat s = new Stat();    s.setCzxid(546);    response.add(new OpResult.SetDataResult(s));    MultiResponse decodedResponse = codeDecode(response);    assertEquals(response, decodedResponse);    assertEquals(response.hashCode(), decodedResponse.hashCode());}
testEmptyRoundTrip
public void zookeeper_f4370_0() throws IOException
{    MultiResponse result = new MultiResponse();    MultiResponse decodedResult = codeDecode(result);    assertEquals(result, decodedResult);    assertEquals(result.hashCode(), decodedResult.hashCode());}
codeDecode
private MultiResponse zookeeper_f4371_0(MultiResponse request) throws IOException
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos);    request.serialize(boa, "result");    baos.close();    ByteBuffer bb = ByteBuffer.wrap(baos.toByteArray());    bb.rewind();    BinaryInputArchive bia = BinaryInputArchive.getArchive(new ByteBufferInputStream(bb));    MultiResponse decodedRequest = new MultiResponse();    decodedRequest.deserialize(bia, "result");    return decodedRequest;}
unique
public static synchronized intf4372_1)
{    if (portRange == null) {        Integer threadId = Integer.getInteger("zookeeper.junit.threadid");        portRange = setupPortRange(System.getProperty("test.junit.threads"), threadId != null ? "threadid=" + threadId : System.getProperty("sun.java.command"));        nextPort = portRange.getMinimum();    }    int candidatePort = nextPort;    for (; ; ) {        ++candidatePort;        if (candidatePort > portRange.getMaximum()) {            candidatePort = portRange.getMinimum();        }        if (candidatePort == nextPort) {            throw new IllegalStateException(String.format("Could not assign port from range %s.  The entire range has been exhausted.", portRange));        }        try {            ServerSocket s = new ServerSocket(candidatePort);            s.close();            nextPort = candidatePort;                        return nextPort;        } catch (IOException e) {                    }    }}
setupPortRange
 static PortRangef4373_1String strProcessCount, String cmdLine)
{    Integer processCount = null;    if (strProcessCount != null && !strProcessCount.isEmpty()) {        try {            processCount = Integer.valueOf(strProcessCount);        } catch (NumberFormatException e) {                    }    }    Integer threadId = null;    if (processCount != null) {        if (cmdLine != null && !cmdLine.isEmpty()) {            Matcher m = Pattern.compile("threadid=(\\d+)").matcher(cmdLine);            if (m.find()) {                try {                    threadId = Integer.valueOf(m.group(1));                } catch (NumberFormatException e) {                                    }            }        }    }    final PortRange newPortRange;    if (processCount != null && processCount > 1 && threadId != null) {                                        int portRangeSize = (GLOBAL_MAX_PORT - GLOBAL_BASE_PORT) / processCount;        int minPort = GLOBAL_BASE_PORT + ((threadId - 1) * portRangeSize);        int maxPort = minPort + portRangeSize - 1;        newPortRange = new PortRange(minPort, maxPort);            } else {                        newPortRange = new PortRange(GLOBAL_BASE_PORT, GLOBAL_MAX_PORT);            }    return newPortRange;}
getMaximum
 int zookeeper_f4374_0()
{    return maximum;}
getMinimum
 int zookeeper_f4375_0()
{    return minimum;}
toString
public String zookeeper_f4376_0()
{    return String.format("%d - %d", minimum, maximum);}
data
public static Collection<Object[]> zookeeper_f4377_0()
{    return Arrays.asList(new Object[] { "8", "threadid=1", 11221, 13913 }, new Object[] { "8", "threadid=2", 13914, 16606 }, new Object[] { "8", "threadid=3", 16607, 19299 }, new Object[] { "8", "threadid=4", 19300, 21992 }, new Object[] { "8", "threadid=5", 21993, 24685 }, new Object[] { "8", "threadid=6", 24686, 27378 }, new Object[] { "8", "threadid=7", 27379, 30071 }, new Object[] { "8", "threadid=8", 30072, 32764 }, new Object[] { "1", "threadid=1", 11221, 32767 }, new Object[] { "2", "threadid=1", 11221, 21993 }, new Object[] { "2", "threadid=2", 21994, 32766 }, new Object[] { null, null, 11221, 32767 }, new Object[] { "", "", 11221, 32767 });}
testSetupPortRange
public void zookeeper_f4378_0()
{    PortAssignment.PortRange portRange = PortAssignment.setupPortRange(strProcessCount, cmdLine);    assertEquals(buildAssertionMessage("minimum"), expectedMinimumPort, portRange.getMinimum());    assertEquals(buildAssertionMessage("maximum"), expectedMaximumPort, portRange.getMaximum());}
buildAssertionMessage
private String zookeeper_f4379_0(String checkType)
{    return String.format("strProcessCount = %s, cmdLine = %s, checking %s", strProcessCount, cmdLine, checkType);}
setUp
public void zookeeper_f4380_0() throws Exception
{    super.setUp();    zk = createClient();    zkMain = new ZooKeeperMain(zk);}
tearDown
public void zookeeper_f4381_0() throws Exception
{    if (zk != null) {        zk.close();    }    super.tearDown();}
testRemoveWatchesWithNoPassedOptions
public voidf4382_1) throws Exception
{    List<EventType> expectedEvents = new ArrayList<>();    expectedEvents.add(EventType.ChildWatchRemoved);    expectedEvents.add(EventType.DataWatchRemoved);    MyWatcher myWatcher = new MyWatcher("/testnode1", expectedEvents, 2);    zk.create("/testnode1", "data".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/testnode2", "data".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        zk.getChildren("/testnode1", myWatcher);    zk.getChildren("/testnode2", myWatcher);        zk.getData("/testnode1", myWatcher, null);    zk.getData("/testnode2", myWatcher, null);    String cmdstring = "removewatches /testnode1";        zkMain.cl.parseCommand(cmdstring);    assertTrue("Removewatches cmd fails to remove child watches", zkMain.processZKCmd(zkMain.cl));        myWatcher.matches();        assertTrue("Failed to find child watches for the path testnode2", zk.getChildWatches().contains("/testnode2"));    assertTrue("Failed to find data watches for the path testnode2", zk.getDataWatches().contains("/testnode2"));}
testRemoveNodeDataChangedWatches
public voidf4383_1) throws Exception
{        List<EventType> expectedEvents = new ArrayList<>();    expectedEvents.add(EventType.DataWatchRemoved);    MyWatcher myWatcher = new MyWatcher("/testnode1", expectedEvents, 1);    zk.create("/testnode1", "data".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.getData("/testnode1", myWatcher, null);    String cmdstring = "removewatches /testnode1 -d";        zkMain.cl.parseCommand(cmdstring);    assertTrue("Removewatches cmd fails to remove data watches", zkMain.processZKCmd(zkMain.cl));        myWatcher.matches();        assertEquals("Data watches are not removed : " + zk.getDataWatches(), 0, zk.getDataWatches().size());}
testRemoveNodeCreatedWatches
public voidf4384_1) throws Exception
{    List<EventType> expectedEvents = new ArrayList<>();    expectedEvents.add(EventType.DataWatchRemoved);    MyWatcher myWatcher1 = new MyWatcher("/testnode1", expectedEvents, 1);    MyWatcher myWatcher2 = new MyWatcher("/testnode1/testnode2", expectedEvents, 1);            zk.exists("/testnode1", myWatcher1);    zk.exists("/testnode1/testnode2", myWatcher2);    String cmdstring1 = "removewatches /testnode1 -d";        zkMain.cl.parseCommand(cmdstring1);    assertTrue("Removewatches cmd fails to remove pre-create watches", zkMain.processZKCmd(zkMain.cl));    myWatcher1.matches();    assertEquals("Failed to remove pre-create watches :" + zk.getExistWatches(), 1, zk.getExistWatches().size());    assertTrue("Failed to remove pre-create watches :" + zk.getExistWatches(), zk.getExistWatches().contains("/testnode1/testnode2"));    String cmdstring2 = "removewatches /testnode1/testnode2 -d";        zkMain.cl.parseCommand(cmdstring2);    assertTrue("Removewatches cmd fails to remove data watches", zkMain.processZKCmd(zkMain.cl));    myWatcher2.matches();    assertEquals("Failed to remove pre-create watches : " + zk.getExistWatches(), 0, zk.getExistWatches().size());}
testRemoveNodeChildrenChangedWatches
public voidf4385_1) throws Exception
{    List<EventType> expectedEvents = new ArrayList<>();    expectedEvents.add(EventType.ChildWatchRemoved);    MyWatcher myWatcher = new MyWatcher("/testnode1", expectedEvents, 1);    zk.create("/testnode1", "data".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        zk.getChildren("/testnode1", myWatcher);    String cmdstring = "removewatches /testnode1 -c";        zkMain.cl.parseCommand(cmdstring);    assertTrue("Removewatches cmd fails to remove child watches", zkMain.processZKCmd(zkMain.cl));    myWatcher.matches();    assertEquals("Failed to remove child watches : " + zk.getChildWatches(), 0, zk.getChildWatches().size());}
testRemoveNodeDeletedWatches
public voidf4386_1) throws Exception
{        List<EventType> expectedEvents = new ArrayList<>();    expectedEvents.add(EventType.ChildWatchRemoved);    expectedEvents.add(EventType.NodeDeleted);    MyWatcher myWatcher = new MyWatcher("/testnode1", expectedEvents, 1);    zk.create("/testnode1", "data".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/testnode1/testnode2", "data".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.getChildren("/testnode1/testnode2", myWatcher);    zk.getChildren("/testnode1", myWatcher);    String cmdstring = "removewatches /testnode1 -c";        zkMain.cl.parseCommand(cmdstring);    assertTrue("Removewatches cmd fails to remove child watches", zkMain.processZKCmd(zkMain.cl));        myWatcher.matches();    assertEquals("Failed to remove child watches : " + zk.getChildWatches(), 1, zk.getChildWatches().size());    assertTrue("Failed to remove child watches :" + zk.getChildWatches(), zk.getChildWatches().contains("/testnode1/testnode2"));        zk.delete("/testnode1/testnode2", -1);    myWatcher.matches();}
testRemoveAnyWatches
public void zookeeper_f4387_0() throws Exception
{    verifyRemoveAnyWatches(false);}
testRemoveWatchesLocallyWhenNoServerConnection
public void zookeeper_f4388_0() throws Exception
{    verifyRemoveAnyWatches(true);}
verifyRemoveAnyWatches
private voidf4389_1boolean local) throws Exception
{    final Map<String, List<EventType>> pathVsEvent = new HashMap<>();        final CountDownLatch watcherLatch = new CountDownLatch(2);    Watcher watcher = new Watcher() {        @Override        public void process(WatchedEvent event) {            switch(event.getType()) {                case ChildWatchRemoved:                case DataWatchRemoved:                    addWatchNotifications(pathVsEvent, event);                    watcherLatch.countDown();                    break;                case NodeChildrenChanged:                case NodeDataChanged:                    addWatchNotifications(pathVsEvent, event);                    break;            }        }        private void addWatchNotifications(Map<String, List<EventType>> pathVsEvent, WatchedEvent event) {            pathVsEvent.computeIfAbsent(event.getPath(), k -> new ArrayList<>()).add(event.getType());        }    };    zk.create("/testnode1", "data".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.getChildren("/testnode1", watcher);    zk.getData("/testnode1", watcher, null);    String cmdstring = "removewatches /testnode1 -a";    if (local) {                stopServer();        cmdstring = "removewatches /testnode1 -a -l";    }        zkMain.cl.parseCommand(cmdstring);    assertTrue("Removewatches cmd fails to remove child/data watches", zkMain.processZKCmd(zkMain.cl));        watcherLatch.await(10, TimeUnit.SECONDS);    assertEquals("Didn't receives WatchRemoved events!", 1, pathVsEvent.size());    assertTrue("Didn't receives DataWatchRemoved!", pathVsEvent.get("/testnode1").contains(EventType.DataWatchRemoved));    assertTrue("Didn't receives ChildWatchRemoved!", pathVsEvent.get("/testnode1").contains(EventType.ChildWatchRemoved));}
process
public void zookeeper_f4390_0(WatchedEvent event)
{    switch(event.getType()) {        case ChildWatchRemoved:        case DataWatchRemoved:            addWatchNotifications(pathVsEvent, event);            watcherLatch.countDown();            break;        case NodeChildrenChanged:        case NodeDataChanged:            addWatchNotifications(pathVsEvent, event);            break;    }}
addWatchNotifications
private void zookeeper_f4391_0(Map<String, List<EventType>> pathVsEvent, WatchedEvent event)
{    pathVsEvent.computeIfAbsent(event.getPath(), k -> new ArrayList<>()).add(event.getType());}
process
public voidf4392_1WatchedEvent event)
{        this.eventPath = event.getPath();    if (expectedEvents.contains(event.getType())) {        latch.countDown();    }}
matches
public booleanf4393_1) throws InterruptedException
{    if (!latch.await(CONNECTION_TIMEOUT / 3, TimeUnit.MILLISECONDS)) {                return false;    }        return path.equals(eventPath);}
setUp
public void zookeeper_f4394_0() throws Exception
{    super.setUp();    zk1 = createClient();    zk2 = createClient();}
tearDown
public void zookeeper_f4395_0() throws Exception
{    if (zk1 != null) {        zk1.close();    }    if (zk2 != null) {        zk2.close();    }    super.tearDown();}
configs
public static Collection<Object[]> zookeeper_f4396_0()
{    return Arrays.asList(new Object[][] { { false }, { true } });}
removeWatches
private voidf4397_1ZooKeeper zk, String path, Watcher watcher, WatcherType watcherType, boolean local, KeeperException.Code rc) throws InterruptedException, KeeperException
{        if (useAsync) {        MyCallback c1 = new MyCallback(rc.intValue(), path);        zk.removeWatches(path, watcher, watcherType, local, c1, null);        assertTrue("Didn't succeeds removeWatch operation", c1.matches());        if (KeeperException.Code.OK.intValue() != c1.rc) {            KeeperException ke = KeeperException.create(KeeperException.Code.get(c1.rc));            throw ke;        }    } else {        zk.removeWatches(path, watcher, watcherType, local);    }}
removeAllWatches
private voidf4398_1ZooKeeper zk, String path, WatcherType watcherType, boolean local, KeeperException.Code rc) throws InterruptedException, KeeperException
{        if (useAsync) {        MyCallback c1 = new MyCallback(rc.intValue(), path);        zk.removeAllWatches(path, watcherType, local, c1, null);        assertTrue("Didn't succeeds removeWatch operation", c1.matches());        if (KeeperException.Code.OK.intValue() != c1.rc) {            KeeperException ke = KeeperException.create(KeeperException.Code.get(c1.rc));            throw ke;        }    } else {        zk.removeAllWatches(path, watcherType, local);    }}
testRemoveSingleWatcher
public voidf4399_1) throws Exception
{    zk1.create("/node1", null, Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);    zk1.create("/node2", null, Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);    MyWatcher w1 = new MyWatcher("/node1", 1);        assertNotNull("Didn't set data watches", zk2.exists("/node1", w1));    MyWatcher w2 = new MyWatcher("/node2", 1);        assertNotNull("Didn't set data watches", zk2.exists("/node2", w2));    removeWatches(zk2, "/node1", w1, WatcherType.Data, false, Code.OK);    assertEquals("Didn't find data watcher", 1, zk2.getDataWatches().size());    assertEquals("Didn't find data watcher", "/node2", zk2.getDataWatches().get(0));    removeWatches(zk2, "/node2", w2, WatcherType.Any, false, Code.OK);    assertTrue("Didn't remove data watcher", w2.matches());        if (zk1 != null) {        zk1.close();        zk1 = null;    }    List<EventType> events = w1.getEventsAfterWatchRemoval();    assertFalse("Shouldn't get NodeDeletedEvent after watch removal", events.contains(EventType.NodeDeleted));    assertEquals("Shouldn't get NodeDeletedEvent after watch removal", 0, events.size());}
testMultipleDataWatchers
public voidf4400_1) throws IOException, InterruptedException, KeeperException
{    zk1.create("/node1", null, Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);    MyWatcher w1 = new MyWatcher("/node1", 1);        assertNotNull("Didn't set data watches", zk2.exists("/node1", w1));    MyWatcher w2 = new MyWatcher("/node1", 1);        assertNotNull("Didn't set data watches", zk2.exists("/node1", w2));    removeWatches(zk2, "/node1", w2, WatcherType.Data, false, Code.OK);    assertEquals("Didn't find data watcher", 1, zk2.getDataWatches().size());    assertEquals("Didn't find data watcher", "/node1", zk2.getDataWatches().get(0));    removeWatches(zk2, "/node1", w1, WatcherType.Any, false, Code.OK);    assertTrue("Didn't remove data watcher", w2.matches());        if (zk1 != null) {        zk1.close();        zk1 = null;    }    List<EventType> events = w2.getEventsAfterWatchRemoval();    assertEquals("Shouldn't get NodeDeletedEvent after watch removal", 0, events.size());}
testMultipleChildWatchers
public voidf4401_1) throws IOException, InterruptedException, KeeperException
{    zk1.create("/node1", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    MyWatcher w1 = new MyWatcher("/node1", 1);        zk2.getChildren("/node1", w1);    MyWatcher w2 = new MyWatcher("/node1", 1);        zk2.getChildren("/node1", w2);    removeWatches(zk2, "/node1", w2, WatcherType.Children, false, Code.OK);    assertTrue("Didn't remove child watcher", w2.matches());    assertEquals("Didn't find child watcher", 1, zk2.getChildWatches().size());    removeWatches(zk2, "/node1", w1, WatcherType.Any, false, Code.OK);    assertTrue("Didn't remove child watcher", w1.matches());        zk1.create("/node1/node2", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        int count = 30;    while (count > 0) {        if (w1.getEventsAfterWatchRemoval().size() > 0) {            break;        }        count--;        Thread.sleep(100);    }        List<EventType> events = w2.getEventsAfterWatchRemoval();    assertEquals("Shouldn't get NodeChildrenChanged event", 0, events.size());}
testRemoveAllWatchers
public voidf4402_1) throws IOException, InterruptedException, KeeperException
{    zk1.create("/node1", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    MyWatcher w1 = new MyWatcher("/node1", 2);    MyWatcher w2 = new MyWatcher("/node1", 2);        assertNotNull("Didn't set data watches", zk2.exists("/node1", w1));        assertNotNull("Didn't set data watches", zk2.exists("/node1", w2));        zk2.getChildren("/node1", w1);        zk2.getChildren("/node1", w2);    removeWatches(zk2, "/node1", w1, WatcherType.Any, false, Code.OK);    removeWatches(zk2, "/node1", w2, WatcherType.Any, false, Code.OK);    zk1.create("/node1/child", null, Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);    assertTrue("Didn't remove data watcher", w1.matches());    assertTrue("Didn't remove child watcher", w2.matches());}
testRemoveAllDataWatchers
public voidf4403_1) throws IOException, InterruptedException, KeeperException
{    zk1.create("/node1", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    MyWatcher w1 = new MyWatcher("/node1", 1);    MyWatcher w2 = new MyWatcher("/node1", 1);        assertNotNull("Didn't set data watches", zk2.exists("/node1", w1));        assertNotNull("Didn't set data watches", zk2.exists("/node1", w2));        zk2.getChildren("/node1", w1);        zk2.getChildren("/node1", w2);    removeWatches(zk2, "/node1", w1, WatcherType.Data, false, Code.OK);    removeWatches(zk2, "/node1", w2, WatcherType.Data, false, Code.OK);    zk1.create("/node1/child", null, Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);    assertTrue("Didn't remove data watcher", w1.matches());    assertTrue("Didn't remove data watcher", w2.matches());        int count = 10;    while (count > 0) {        if (w1.getEventsAfterWatchRemoval().size() > 0 && w2.getEventsAfterWatchRemoval().size() > 0) {            break;        }        count--;        Thread.sleep(1000);    }        List<EventType> events = w1.getEventsAfterWatchRemoval();    assertEquals("Didn't get NodeChildrenChanged event", 1, events.size());    assertTrue("Didn't get NodeChildrenChanged event", events.contains(EventType.NodeChildrenChanged));        events = w2.getEventsAfterWatchRemoval();    assertEquals("Didn't get NodeChildrenChanged event", 1, events.size());    assertTrue("Didn't get NodeChildrenChanged event", events.contains(EventType.NodeChildrenChanged));}
testRemoveAllChildWatchers
public voidf4404_1) throws IOException, InterruptedException, KeeperException
{    zk1.create("/node1", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    MyWatcher w1 = new MyWatcher("/node1", 1);    MyWatcher w2 = new MyWatcher("/node1", 1);        assertNotNull("Didn't set data watches", zk2.exists("/node1", w1));        assertNotNull("Didn't set data watches", zk2.exists("/node1", w2));        zk2.getChildren("/node1", w1);        zk2.getChildren("/node1", w2);    removeWatches(zk2, "/node1", w1, WatcherType.Children, false, Code.OK);    removeWatches(zk2, "/node1", w2, WatcherType.Children, false, Code.OK);    zk1.setData("/node1", "test".getBytes(), -1);    assertTrue("Didn't remove child watcher", w1.matches());    assertTrue("Didn't remove child watcher", w2.matches());        int count = 10;    while (count > 0) {        if (w1.getEventsAfterWatchRemoval().size() > 0 && w2.getEventsAfterWatchRemoval().size() > 0) {            break;        }        count--;        Thread.sleep(1000);    }        List<EventType> events = w1.getEventsAfterWatchRemoval();    assertEquals("Didn't get NodeDataChanged event", 1, events.size());    assertTrue("Didn't get NodeDataChanged event", events.contains(EventType.NodeDataChanged));        events = w2.getEventsAfterWatchRemoval();    assertEquals("Didn't get NodeDataChanged event", 1, events.size());    assertTrue("Didn't get NodeDataChanged event", events.contains(EventType.NodeDataChanged));}
testNoWatcherException
public voidf4405_1) throws IOException, InterruptedException, KeeperException
{    zk1.create("/node1", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    MyWatcher w1 = new MyWatcher("/node1", 2);    MyWatcher w2 = new MyWatcher("/node1", 2);        assertNotNull("Didn't set data watches", zk2.exists("/node1", w1));        assertNull("Didn't set data watches", zk2.exists("/node2", w2));        zk2.getChildren("/node1", w1);        zk2.getChildren("/node1", w2);        MyWatcher w3 = new MyWatcher("/node1", 2);    try {        removeWatches(zk2, "/node1", w3, WatcherType.Any, false, Code.NOWATCHER);        fail("Should throw exception as given watcher doesn't exists");    } catch (KeeperException.NoWatcherException nwe) {        }    try {        removeWatches(zk2, "/node1", w3, WatcherType.Children, false, Code.NOWATCHER);        fail("Should throw exception as given watcher doesn't exists");    } catch (KeeperException.NoWatcherException nwe) {        }    try {        removeWatches(zk2, "/node1", w3, WatcherType.Data, false, Code.NOWATCHER);        fail("Should throw exception as given watcher doesn't exists");    } catch (KeeperException.NoWatcherException nwe) {        }    try {        removeWatches(zk2, "/nonexists", w3, WatcherType.Data, false, Code.NOWATCHER);        fail("Should throw exception as given watcher doesn't exists");    } catch (KeeperException.NoWatcherException nwe) {        }}
testRemoveAnyDataWatcher
public voidf4406_1) throws Exception
{    zk1.create("/node1", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    MyWatcher w1 = new MyWatcher("/node1", 1);    MyWatcher w2 = new MyWatcher("/node1", 2);            assertNotNull("Didn't set data watches", zk2.exists("/node1", w1));        assertNotNull("Didn't set data watches", zk2.exists("/node1", w2));            zk2.getChildren("/node1", w2);    removeWatches(zk2, "/node1", w1, WatcherType.Any, false, Code.OK);    assertTrue("Didn't remove data watcher", w1.matches());    assertEquals("Didn't find child watcher", 1, zk2.getChildWatches().size());    assertEquals("Didn't find data watcher", 1, zk2.getDataWatches().size());    removeWatches(zk2, "/node1", w2, WatcherType.Any, false, Code.OK);    assertTrue("Didn't remove child watcher", w2.matches());}
testRemoveAnyChildWatcher
public voidf4407_1) throws Exception
{    zk1.create("/node1", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    MyWatcher w1 = new MyWatcher("/node1", 2);    MyWatcher w2 = new MyWatcher("/node1", 1);        assertNotNull("Didn't set data watches", zk2.exists("/node1", w1));            zk2.getChildren("/node1", w2);        zk2.getChildren("/node1", w1);    removeWatches(zk2, "/node1", w2, WatcherType.Any, false, Code.OK);    assertTrue("Didn't remove child watcher", w2.matches());    assertEquals("Didn't find child watcher", 1, zk2.getChildWatches().size());    assertEquals("Didn't find data watcher", 1, zk2.getDataWatches().size());    removeWatches(zk2, "/node1", w1, WatcherType.Any, false, Code.OK);    assertTrue("Didn't remove watchers", w1.matches());}
testRemoveWatcherWhenNoConnection
public voidf4408_1) throws Exception
{    zk1.create("/node1", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    MyWatcher w1 = new MyWatcher("/node1", 2);    MyWatcher w2 = new MyWatcher("/node1", 1);        assertNotNull("Didn't set data watches", zk2.exists("/node1", w1));            zk2.getChildren("/node1", w1);        zk2.getChildren("/node1", w2);    stopServer();    removeWatches(zk2, "/node1", w2, WatcherType.Any, true, Code.OK);    assertTrue("Didn't remove child watcher", w2.matches());    assertFalse("Shouldn't remove data watcher", w1.matches());    try {        removeWatches(zk2, "/node1", w1, WatcherType.Any, false, Code.CONNECTIONLOSS);        fail("Should throw exception as last watch removal requires server connection");    } catch (KeeperException.ConnectionLossException nwe) {        }    assertFalse("Shouldn't remove data watcher", w1.matches());            removeWatches(zk2, "/node1", w1, WatcherType.Any, true, Code.OK);    assertTrue("Didn't remove data watcher", w1.matches());}
testManyPreNodeWatchers
public voidf4409_1) throws Exception
{    int count = 50;    List<MyWatcher> wList = new ArrayList<MyWatcher>(count);    MyWatcher w;    String path = "/node";        for (int i = 0; i < count; i++) {        final String nodePath = path + i;        w = new MyWatcher(nodePath, 1);        wList.add(w);                zk1.exists(nodePath, w);    }    assertEquals("Failed to add watchers!", count, zk1.getExistWatches().size());    for (int i = 0; i < count; i++) {        final MyWatcher watcher = wList.get(i);        removeWatches(zk1, path + i, watcher, WatcherType.Data, false, Code.OK);        assertTrue("Didn't remove data watcher", watcher.matches());    }    assertEquals("Didn't remove watch references!", 0, zk1.getExistWatches().size());}
testManyChildWatchers
public voidf4410_1) throws Exception
{    int count = 50;    List<MyWatcher> wList = new ArrayList<MyWatcher>(count);    MyWatcher w;    String path = "/node";        for (int i = 0; i < count; i++) {        String nodePath = path + i;        zk1.create(nodePath, null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        nodePath += "/";    }    for (int i = 0; i < count; i++) {        String nodePath = path + i;        w = new MyWatcher(path + i, 1);        wList.add(w);                zk1.getChildren(nodePath, w);        nodePath += "/";    }    assertEquals("Failed to add watchers!", count, zk1.getChildWatches().size());    for (int i = 0; i < count; i++) {        final MyWatcher watcher = wList.get(i);        removeWatches(zk1, path + i, watcher, WatcherType.Children, false, Code.OK);        assertTrue("Didn't remove child watcher", watcher.matches());    }    assertEquals("Didn't remove watch references!", 0, zk1.getChildWatches().size());}
testManyDataWatchers
public voidf4411_1) throws Exception
{    int count = 50;    List<MyWatcher> wList = new ArrayList<MyWatcher>(count);    MyWatcher w;    String path = "/node";        for (int i = 0; i < count; i++) {        String nodePath = path + i;        w = new MyWatcher(path + i, 1);        wList.add(w);        zk1.create(nodePath, null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);                zk1.getData(nodePath, w, null);        nodePath += "/";    }    assertEquals("Failed to add watchers!", count, zk1.getDataWatches().size());    for (int i = 0; i < count; i++) {        final MyWatcher watcher = wList.get(i);        removeWatches(zk1, path + i, watcher, WatcherType.Data, false, Code.OK);        assertTrue("Didn't remove data watcher", watcher.matches());    }    assertEquals("Didn't remove watch references!", 0, zk1.getDataWatches().size());}
testManyWatchersWhenNoConnection
public voidf4412_1) throws Exception
{    int count = 3;    List<MyWatcher> wList = new ArrayList<MyWatcher>(count);    MyWatcher w;    String path = "/node";        for (int i = 0; i < count; i++) {        String nodePath = path + i;        zk1.create(nodePath, null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        nodePath += "/";    }    for (int i = 0; i < count; i++) {        String nodePath = path + i;        w = new MyWatcher(path + i, 2);        wList.add(w);                zk1.getChildren(nodePath, w);        nodePath += "/";    }    assertEquals("Failed to add watchers!", count, zk1.getChildWatches().size());        for (int i = 0; i < count; i++) {        String nodePath = path + i;        w = wList.get(i);                zk1.getData(nodePath, w, null);        nodePath += "/";    }    assertEquals("Failed to add watchers!", count, zk1.getDataWatches().size());    stopServer();    for (int i = 0; i < count; i++) {        final MyWatcher watcher = wList.get(i);        removeWatches(zk1, path + i, watcher, WatcherType.Any, true, Code.OK);        assertTrue("Didn't remove watcher", watcher.matches());    }    assertEquals("Didn't remove watch references!", 0, zk1.getChildWatches().size());    assertEquals("Didn't remove watch references!", 0, zk1.getDataWatches().size());}
testChRootRemoveWatcher
public voidf4413_1) throws Exception
{        String chRoot = "/appsX";    zk1.create("/appsX", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    if (zk1 != null) {        zk1.close();    }    if (zk2 != null) {        zk2.close();    }        zk1 = createClient(this.hostPort + chRoot);    zk2 = createClient(this.hostPort + chRoot);        zk1.create("/node1", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    MyWatcher w1 = new MyWatcher("/node1", 2);    MyWatcher w2 = new MyWatcher("/node1", 1);        assertNotNull("Didn't set data watches", zk2.exists("/node1", w1));            zk2.getChildren("/node1", w2);        zk2.getChildren("/node1", w1);    removeWatches(zk2, "/node1", w1, WatcherType.Any, false, Code.OK);    assertTrue("Didn't remove child watcher", w1.matches());    assertEquals("Didn't find child watcher", 1, zk2.getChildWatches().size());    removeWatches(zk2, "/node1", w2, WatcherType.Any, false, Code.OK);    assertTrue("Didn't remove child watcher", w2.matches());}
testNoWatcherServerException
public void zookeeper_f4414_0() throws InterruptedException, IOException, TimeoutException
{    CountdownWatcher watcher = new CountdownWatcher();    MyZooKeeper zk = new MyZooKeeper(hostPort, CONNECTION_TIMEOUT, watcher);    boolean nw = false;    watcher.waitForConnected(CONNECTION_TIMEOUT);    try {        zk.removeWatches("/nowatchhere", watcher, WatcherType.Data, false);    } catch (KeeperException nwe) {        if (nwe.code().intValue() == Code.NOWATCHER.intValue()) {            nw = true;        }    }    assertTrue("Server didn't return NOWATCHER", zk.getRemoveWatchesRC() == Code.NOWATCHER.intValue());    assertTrue("NoWatcherException didn't happen", nw);}
testRemoveAllNoWatcherException
public void zookeeper_f4415_0() throws IOException, InterruptedException, KeeperException
{    zk1.create("/node1", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    try {        removeAllWatches(zk2, "/node1", WatcherType.Any, false, Code.NOWATCHER);        fail("Should throw exception as given watcher doesn't exists");    } catch (KeeperException.NoWatcherException nwe) {        }}
testNullWatcherReference
public void zookeeper_f4416_0() throws Exception
{    zk1.create("/node1", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    try {        if (useAsync) {            zk1.removeWatches("/node1", null, WatcherType.Data, false, null, null);        } else {            zk1.removeWatches("/node1", null, WatcherType.Data, false);        }        fail("Must throw IllegalArgumentException as watcher is null!");    } catch (IllegalArgumentException iae) {        }}
testRemoveWhenMultipleDataWatchesOnAPath
public voidf4417_1) throws Exception
{    zk1.create("/node1", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    final CountDownLatch dataWatchCount = new CountDownLatch(1);    final CountDownLatch rmWatchCount = new CountDownLatch(1);    Watcher w1 = event -> {        if (event.getType() == EventType.DataWatchRemoved) {            rmWatchCount.countDown();        }    };    Watcher w2 = event -> {        if (event.getType() == EventType.NodeDataChanged) {            dataWatchCount.countDown();        }    };            assertNotNull("Didn't set data watches", zk2.exists("/node1", w1));        assertNotNull("Didn't set data watches", zk2.exists("/node1", w2));    removeWatches(zk2, "/node1", w1, WatcherType.Data, false, Code.OK);    assertTrue("Didn't remove data watcher", rmWatchCount.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS));    zk1.setData("/node1", "test".getBytes(), -1);        assertTrue("Didn't get data watch notification!", dataWatchCount.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS));}
testRemoveWhenMultipleChildWatchesOnAPath
public voidf4418_1) throws Exception
{    zk1.create("/node1", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    final CountDownLatch childWatchCount = new CountDownLatch(1);    final CountDownLatch rmWatchCount = new CountDownLatch(1);    Watcher w1 = event -> {        if (event.getType() == EventType.ChildWatchRemoved) {            rmWatchCount.countDown();        }    };    Watcher w2 = event -> {        if (event.getType() == EventType.NodeChildrenChanged) {            childWatchCount.countDown();        }    };            assertEquals("Didn't set child watches", 0, zk2.getChildren("/node1", w1).size());        assertEquals("Didn't set child watches", 0, zk2.getChildren("/node1", w2).size());    removeWatches(zk2, "/node1", w1, WatcherType.Children, false, Code.OK);    assertTrue("Didn't remove child watcher", rmWatchCount.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS));    zk1.create("/node1/node2", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        assertTrue("Didn't get child watch notification!", childWatchCount.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS));}
testRemoveAllDataWatchesOnAPath
public voidf4419_1) throws Exception
{    zk1.create("/node1", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    final CountDownLatch dWatchCount = new CountDownLatch(2);    final CountDownLatch rmWatchCount = new CountDownLatch(2);    Watcher w1 = event -> {        switch(event.getType()) {            case DataWatchRemoved:                rmWatchCount.countDown();                break;            case NodeDataChanged:                dWatchCount.countDown();                break;            default:                break;        }    };    Watcher w2 = event -> {        switch(event.getType()) {            case DataWatchRemoved:                rmWatchCount.countDown();                break;            case NodeDataChanged:                dWatchCount.countDown();                break;            default:                break;        }    };            assertNotNull("Didn't set data watches", zk2.exists("/node1", w1));        assertNotNull("Didn't set data watches", zk2.exists("/node1", w2));    assertTrue("Server session is not a watcher", isServerSessionWatcher(zk2.getSessionId(), "/node1", WatcherType.Data));    removeAllWatches(zk2, "/node1", WatcherType.Data, false, Code.OK);    assertTrue("Didn't remove data watcher", rmWatchCount.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS));    assertFalse("Server session is still a watcher after removal", isServerSessionWatcher(zk2.getSessionId(), "/node1", WatcherType.Data));}
testRemoveAllChildWatchesOnAPath
public voidf4420_1) throws Exception
{    zk1.create("/node1", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    final CountDownLatch cWatchCount = new CountDownLatch(2);    final CountDownLatch rmWatchCount = new CountDownLatch(2);    Watcher w1 = event -> {        switch(event.getType()) {            case ChildWatchRemoved:                rmWatchCount.countDown();                break;            case NodeChildrenChanged:                cWatchCount.countDown();                break;            default:                break;        }    };    Watcher w2 = event -> {        switch(event.getType()) {            case ChildWatchRemoved:                rmWatchCount.countDown();                break;            case NodeChildrenChanged:                cWatchCount.countDown();                break;            default:                break;        }    };            assertEquals("Didn't set child watches", 0, zk2.getChildren("/node1", w1).size());        assertEquals("Didn't set child watches", 0, zk2.getChildren("/node1", w2).size());    assertTrue("Server session is not a watcher", isServerSessionWatcher(zk2.getSessionId(), "/node1", WatcherType.Children));    removeAllWatches(zk2, "/node1", WatcherType.Children, false, Code.OK);    assertTrue("Didn't remove child watcher", rmWatchCount.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS));    assertFalse("Server session is still a watcher after removal", isServerSessionWatcher(zk2.getSessionId(), "/node1", WatcherType.Children));}
testRemoveAllWatchesOnAPath
public voidf4421_1) throws Exception
{    zk1.create("/node1", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    final CountDownLatch watchCount = new CountDownLatch(2);    final CountDownLatch rmWatchCount = new CountDownLatch(4);    Watcher w1 = event -> {        switch(event.getType()) {            case ChildWatchRemoved:            case DataWatchRemoved:                rmWatchCount.countDown();                break;            case NodeChildrenChanged:            case NodeDataChanged:                watchCount.countDown();                break;            default:                break;        }    };    Watcher w2 = event -> {        switch(event.getType()) {            case ChildWatchRemoved:            case DataWatchRemoved:                rmWatchCount.countDown();                break;            case NodeChildrenChanged:            case NodeDataChanged:                watchCount.countDown();                break;            default:                break;        }    };            assertEquals("Didn't set child watches", 0, zk2.getChildren("/node1", w1).size());        assertEquals("Didn't set child watches", 0, zk2.getChildren("/node1", w2).size());            assertNotNull("Didn't set data watches", zk2.exists("/node1", w1));        assertNotNull("Didn't set data watches", zk2.exists("/node1", w2));    assertTrue("Server session is not a watcher", isServerSessionWatcher(zk2.getSessionId(), "/node1", WatcherType.Data));    removeAllWatches(zk2, "/node1", WatcherType.Any, false, Code.OK);    assertTrue("Didn't remove data watcher", rmWatchCount.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS));    assertFalse("Server session is still a watcher after removal", isServerSessionWatcher(zk2.getSessionId(), "/node1", WatcherType.Data));    assertEquals("Received watch notification after removal!", 2, watchCount.getCount());}
containsWatcher
 void zookeeper_f4422_0(String path, Watcher watcher, WatcherType watcherType) throws NoWatcherException
{}
removeWatches
protected boolean zookeeper_f4423_0(Map<String, Set<Watcher>> pathVsWatcher, Watcher watcher, String path, boolean local, int rc, Set<Watcher> removedWatchers) throws KeeperException
{    lastrc = rc;    return false;}
defaultWatchManager
protected ZKWatchManager zookeeper_f4424_0()
{    myWatchManager = new MyWatchManager(getClientConfig().getBoolean(ZKClientConfig.DISABLE_AUTO_WATCH_RESET));    return myWatchManager;}
getRemoveWatchesRC
public int zookeeper_f4425_0()
{    return myWatchManager.lastrc;}
process
public voidf4426_1WatchedEvent event)
{        this.eventPath = event.getPath();        if (latch.getCount() == 0) {        if (event.getType() != EventType.None) {            eventsAfterWatchRemoval.add(event.getType());        }    }    if (event.getType() == EventType.ChildWatchRemoved || event.getType() == EventType.DataWatchRemoved) {        latch.countDown();    }}
matches
public booleanf4427_1) throws InterruptedException
{    if (!latch.await(CONNECTION_TIMEOUT / 5, TimeUnit.MILLISECONDS)) {                return false;    }        return path.equals(eventPath);}
getEventsAfterWatchRemoval
public List<EventType> zookeeper_f4428_0()
{    return eventsAfterWatchRemoval;}
processResult
public void zookeeper_f4429_0(int rc, String eventPath, Object ctx)
{    System.out.println("latch:" + path + " " + eventPath);    this.eventPath = eventPath;    this.eventRc = rc;    this.latch.countDown();}
matches
public boolean zookeeper_f4430_0() throws InterruptedException
{    if (!latch.await(CONNECTION_TIMEOUT / 5, TimeUnit.MILLISECONDS)) {        return false;    }    return path.equals(eventPath) && rc == eventRc;}
isServerSessionWatcher
private boolean zookeeper_f4431_0(long sessionId, String path, WatcherType type)
{    Set<ServerCnxn> cnxns = new HashSet<>();    CollectionUtils.addAll(cnxns, serverFactory.getConnections().iterator());    for (ServerCnxn cnxn : cnxns) {        if (cnxn.getSessionId() == sessionId) {            return serverFactory.getZooKeeperServer().getZKDatabase().getDataTree().containsWatcher(path, type, cnxn);        }    }    return false;}
init
public static void zookeeper_f4432_0()
{    System.setProperty("zookeeper.authProvider.1", "org.apache.zookeeper.server.auth.SASLAuthenticationProvider");    try {        File tmpDir = createTmpDir();        File saslConfFile = new File(tmpDir, "jaas.conf");        String jaasContent = getJaasFileContent();        FileWriter fwriter = new FileWriter(saslConfFile);        fwriter.write(jaasContent);        fwriter.close();        System.setProperty("java.security.auth.login.config", saslConfFile.getAbsolutePath());    } catch (IOException e) {            }}
getJaasFileContent
private static String zookeeper_f4433_0()
{    StringBuilder jaasContent = new StringBuilder();    String newLine = System.getProperty("line.separator");    jaasContent.append("Server {");    jaasContent.append(newLine);    jaasContent.append("org.apache.zookeeper.server.auth.DigestLoginModule required");    jaasContent.append(newLine);    jaasContent.append("user_super=\"test\";");    jaasContent.append(newLine);    jaasContent.append("};");    jaasContent.append(newLine);    jaasContent.append("Client {");    jaasContent.append(newLine);    jaasContent.append("org.apache.zookeeper.server.auth.DigestLoginModule required");    jaasContent.append(newLine);    jaasContent.append("username=\"super\"");    jaasContent.append(newLine);    jaasContent.append("password=\"test\";");    jaasContent.append(newLine);    jaasContent.append("};");    jaasContent.append(newLine);    return jaasContent.toString();}
clean
public static void zookeeper_f4434_0()
{    System.clearProperty("zookeeper.authProvider.1");    System.clearProperty("java.security.auth.login.config");}
createClient
protected TestableZooKeeper zookeeper_f4435_0(String hp) throws IOException, InterruptedException
{    MyWatcher watcher = new MyWatcher();    return createClient(watcher, hp);}
process
public synchronized void zookeeper_f4436_0(WatchedEvent event)
{    if (event.getState() == KeeperState.AuthFailed) {        authFailed.countDown();    } else {        super.process(event);    }}
testAuth
public void zookeeper_f4437_0() throws Exception
{    ZooKeeper zk = createClient();    try {        zk.create("/path1", null, Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT);        Thread.sleep(1000);    } finally {        zk.close();    }}
testValidSaslIds
public void zookeeper_f4438_0() throws Exception
{    ZooKeeper zk = createClient();    List<String> validIds = new ArrayList<String>();    validIds.add("user");    validIds.add("service/host.name.com");    validIds.add("user@KERB.REALM");    validIds.add("service/host.name.com@KERB.REALM");    int i = 0;    for (String validId : validIds) {        List<ACL> aclList = new ArrayList<ACL>();        ACL acl = new ACL(0, new Id("sasl", validId));        aclList.add(acl);        zk.create("/valid" + i, null, aclList, CreateMode.PERSISTENT);        i++;    }}
testInvalidSaslIds
public void zookeeper_f4439_0() throws Exception
{    ZooKeeper zk = createClient();    List<String> invalidIds = new ArrayList<String>();    invalidIds.add("user@KERB.REALM/server.com");    invalidIds.add("user@KERB.REALM1@KERB.REALM2");    int i = 0;    for (String invalidId : invalidIds) {        List<ACL> aclList = new ArrayList<ACL>();        try {            ACL acl = new ACL(0, new Id("sasl", invalidId));            aclList.add(acl);            zk.create("/invalid" + i, null, aclList, CreateMode.PERSISTENT);            fail("SASLAuthenticationProvider.isValid() failed to catch invalid Id.");        } catch (KeeperException.InvalidACLException e) {                } finally {            i++;        }    }}
testZKOperationsAfterClientSaslAuthFailure
public void zookeeper_f4440_0() throws Exception
{    CountdownWatcher watcher = new CountdownWatcher();    ZooKeeper zk = new ZooKeeper(hostPort, CONNECTION_TIMEOUT, watcher);    watcher.waitForConnected(CONNECTION_TIMEOUT);    try {        setSaslFailureFlag(zk);                int totalTry = 10;        int tryCount = 0;        boolean success = false;        while (!success && tryCount++ <= totalTry) {            try {                zk.create("/saslAuthFail", "data".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);                success = true;            } catch (KeeperException.ConnectionLossException e) {                Thread.sleep(1000);                        }        }        assertTrue("ZNode creation is failing continuously after Sasl auth failure.", success);    } finally {        zk.close();    }}
setSaslFailureFlag
private void zookeeper_f4441_0(ZooKeeper zk) throws Exception
{    Field cnxnField = zk.getClass().getDeclaredField("cnxn");    cnxnField.setAccessible(true);    ClientCnxn clientCnxn = (ClientCnxn) cnxnField.get(zk);    Field sendThreadField = clientCnxn.getClass().getDeclaredField("sendThread");    sendThreadField.setAccessible(true);    SendThread sendThread = (SendThread) sendThreadField.get(clientCnxn);    Field saslLoginFailedField = sendThread.getClass().getDeclaredField("saslLoginFailed");    saslLoginFailedField.setAccessible(true);    saslLoginFailedField.setBoolean(sendThread, true);}
testThreadsShutdownOnAuthFailed
public void zookeeper_f4442_0() throws Exception
{    MyWatcher watcher = new MyWatcher();    ZooKeeper zk = null;    try {        zk = new ZooKeeper(hostPort, CONNECTION_TIMEOUT, watcher);        watcher.waitForConnected(CONNECTION_TIMEOUT);        try {            zk.addAuthInfo("FOO", "BAR".getBytes());            zk.getData("/path1", false, null);            fail("Should get auth state error");        } catch (KeeperException.AuthFailedException e) {            if (!authFailed.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS)) {                fail("Should have called my watcher");            }        }        Field cnxnField = zk.getClass().getDeclaredField("cnxn");        cnxnField.setAccessible(true);        ClientCnxn clientCnxn = (ClientCnxn) cnxnField.get(zk);        Field sendThreadField = clientCnxn.getClass().getDeclaredField("sendThread");        sendThreadField.setAccessible(true);        SendThread sendThread = (SendThread) sendThreadField.get(clientCnxn);        Field eventThreadField = clientCnxn.getClass().getDeclaredField("eventThread");        eventThreadField.setAccessible(true);        EventThread eventThread = (EventThread) eventThreadField.get(clientCnxn);        sendThread.join(CONNECTION_TIMEOUT);        eventThread.join(CONNECTION_TIMEOUT);        assertFalse("SendThread did not shutdown after authFail", sendThread.isAlive());        assertFalse("EventThread did not shutdown after authFail", eventThread.isAlive());    } finally {        if (zk != null) {            zk.close();        }    }}
setUp
public void zookeeper_f4443_0() throws Exception
{    r = new CommandResponse("makemeasandwich", "makeityourself");}
testGetters
public void zookeeper_f4444_0()
{    assertEquals("makemeasandwich", r.getCommand());    assertEquals("makeityourself", r.getError());}
testMap
public void zookeeper_f4445_0()
{    r.put("missing", "sudo");    Map<String, Object> m = new HashMap<String, Object>();    m.put("origin", "xkcd");    m.put("url", "http://xkcd.com/149/");    r.putAll(m);    Map<String, Object> rmap = r.toMap();    assertEquals(5, rmap.size());    assertEquals("makemeasandwich", rmap.get(CommandResponse.KEY_COMMAND));    assertEquals("makeityourself", rmap.get(CommandResponse.KEY_ERROR));    assertEquals("sudo", rmap.get("missing"));    assertEquals("xkcd", rmap.get("origin"));    assertEquals("http://xkcd.com/149/", rmap.get("url"));}
testCommand
public void zookeeper_f4446_0(String cmdName, Map<String, String> kwargs, Field... fields) throws IOException, InterruptedException
{    ZooKeeperServer zks = serverFactory.getZooKeeperServer();    Map<String, Object> result = Commands.runCommand(cmdName, zks, kwargs).toMap();    assertTrue(result.containsKey("command"));        assertEquals(cmdName, result.remove("command"));    assertTrue(result.containsKey("error"));    assertNull("error: " + result.get("error"), result.remove("error"));    for (Field field : fields) {        String k = field.key;        assertTrue("Result from command " + cmdName + " missing field \"" + k + "\"" + "\n" + result, result.containsKey(k));        Class<?> t = field.type;        Object v = result.remove(k);        assertTrue("\"" + k + "\" field from command " + cmdName + " should be of type " + t + ", is actually of type " + v.getClass(), t.isAssignableFrom(v.getClass()));    }    assertTrue("Result from command " + cmdName + " contains extra fields: " + result, result.isEmpty());}
testCommand
public void zookeeper_f4447_0(String cmdName, Field... fields) throws IOException, InterruptedException
{    testCommand(cmdName, new HashMap<String, String>(), fields);}
testConfiguration
public void zookeeper_f4448_0() throws IOException, InterruptedException
{    testCommand("configuration", new Field("client_port", Integer.class), new Field("data_dir", String.class), new Field("data_log_dir", String.class), new Field("tick_time", Integer.class), new Field("max_client_cnxns", Integer.class), new Field("min_session_timeout", Integer.class), new Field("max_session_timeout", Integer.class), new Field("server_id", Long.class), new Field("client_port_listen_backlog", Integer.class));}
testConnections
public void zookeeper_f4449_0() throws IOException, InterruptedException
{    testCommand("connections", new Field("connections", Iterable.class), new Field("secure_connections", Iterable.class));}
testObservers
public void zookeeper_f4450_0() throws IOException, InterruptedException
{    testCommand("observers", new Field("synced_observers", Integer.class), new Field("observers", Iterable.class));}
testObserverConnectionStatReset
public void zookeeper_f4451_0() throws IOException, InterruptedException
{    testCommand("observer_connection_stat_reset");}
testConnectionStatReset
public void zookeeper_f4452_0() throws IOException, InterruptedException
{    testCommand("connection_stat_reset");}
testDump
public void zookeeper_f4453_0() throws IOException, InterruptedException
{    testCommand("dump", new Field("expiry_time_to_session_ids", Map.class), new Field("session_id_to_ephemeral_paths", Map.class));}
testEnvironment
public void zookeeper_f4454_0() throws IOException, InterruptedException
{    testCommand("environment", new Field("zookeeper.version", String.class), new Field("host.name", String.class), new Field("java.version", String.class), new Field("java.vendor", String.class), new Field("java.home", String.class), new Field("java.class.path", String.class), new Field("java.library.path", String.class), new Field("java.io.tmpdir", String.class), new Field("java.compiler", String.class), new Field("os.name", String.class), new Field("os.arch", String.class), new Field("os.version", String.class), new Field("user.name", String.class), new Field("user.home", String.class), new Field("user.dir", String.class), new Field("os.memory.free", String.class), new Field("os.memory.max", String.class), new Field("os.memory.total", String.class));}
testGetTraceMask
public void zookeeper_f4455_0() throws IOException, InterruptedException
{    testCommand("get_trace_mask", new Field("tracemask", Long.class));}
testIsReadOnly
public void zookeeper_f4456_0() throws IOException, InterruptedException
{    testCommand("is_read_only", new Field("read_only", Boolean.class));}
testLastSnapshot
public void zookeeper_f4457_0() throws IOException, InterruptedException
{    testCommand("last_snapshot", new Field("zxid", String.class), new Field("timestamp", Long.class));}
testMonitor
public void zookeeper_f4458_0() throws IOException, InterruptedException
{    ArrayList<Field> fields = new ArrayList<>(Arrays.asList(new Field("version", String.class), new Field("avg_latency", Double.class), new Field("max_latency", Long.class), new Field("min_latency", Long.class), new Field("packets_received", Long.class), new Field("packets_sent", Long.class), new Field("num_alive_connections", Integer.class), new Field("outstanding_requests", Long.class), new Field("server_state", String.class), new Field("znode_count", Integer.class), new Field("watch_count", Integer.class), new Field("ephemerals_count", Integer.class), new Field("approximate_data_size", Long.class), new Field("open_file_descriptor_count", Long.class), new Field("max_file_descriptor_count", Long.class), new Field("last_client_response_size", Integer.class), new Field("max_client_response_size", Integer.class), new Field("min_client_response_size", Integer.class), new Field("uptime", Long.class), new Field("global_sessions", Long.class), new Field("local_sessions", Long.class), new Field("connection_drop_probability", Double.class)));    Map<String, Object> metrics = MetricsUtils.currentServerMetrics();    for (String metric : metrics.keySet()) {        boolean alreadyDefined = fields.stream().anyMatch(f -> {            return f.key.equals(metric);        });        if (alreadyDefined) {                        continue;        }        if (metric.startsWith("avg_")) {            fields.add(new Field(metric, Double.class));        } else {            fields.add(new Field(metric, Long.class));        }    }    Field[] fieldsArray = fields.toArray(new Field[0]);    testCommand("monitor", fieldsArray);}
testRuok
public void zookeeper_f4459_0() throws IOException, InterruptedException
{    testCommand("ruok");}
testServerStats
public void zookeeper_f4460_0() throws IOException, InterruptedException
{    testCommand("server_stats", new Field("version", String.class), new Field("read_only", Boolean.class), new Field("server_stats", ServerStats.class), new Field("node_count", Integer.class), new Field("client_response", BufferStats.class));}
testSetTraceMask
public void zookeeper_f4461_0() throws IOException, InterruptedException
{    Map<String, String> kwargs = new HashMap<String, String>();    kwargs.put("traceMask", "1");    testCommand("set_trace_mask", kwargs, new Field("tracemask", Long.class));}
testStat
public void zookeeper_f4462_0() throws IOException, InterruptedException
{    testCommand("stats", new Field("version", String.class), new Field("read_only", Boolean.class), new Field("server_stats", ServerStats.class), new Field("node_count", Integer.class), new Field("connections", Iterable.class), new Field("client_response", BufferStats.class));}
testStatReset
public void zookeeper_f4463_0() throws IOException, InterruptedException
{    testCommand("stat_reset");}
testWatches
public void zookeeper_f4464_0() throws IOException, InterruptedException
{    testCommand("watches", new Field("session_id_to_watched_paths", Map.class));}
testWatchesByPath
public void zookeeper_f4465_0() throws IOException, InterruptedException
{    testCommand("watches_by_path", new Field("path_to_session_ids", Map.class));}
testWatchSummary
public void zookeeper_f4466_0() throws IOException, InterruptedException
{    testCommand("watch_summary", new Field("num_connections", Integer.class), new Field("num_paths", Integer.class), new Field("num_total_watches", Integer.class));}
testConsCommandSecureOnly
public void zookeeper_f4467_0()
{        Commands.ConsCommand cmd = new Commands.ConsCommand();    ZooKeeperServer zkServer = mock(ZooKeeperServer.class);    ServerCnxnFactory cnxnFactory = mock(ServerCnxnFactory.class);    when(zkServer.getSecureServerCnxnFactory()).thenReturn(cnxnFactory);        CommandResponse response = cmd.run(zkServer, null);        assertThat(response.toMap().containsKey("connections"), is(true));    assertThat(response.toMap().containsKey("secure_connections"), is(true));}
enableServer
public void zookeeper_f4468_0()
{        System.setProperty("zookeeper.admin.enableServer", "true");    System.setProperty("zookeeper.admin.serverPort", "" + jettyAdminPort);}
setupEncryption
public voidf4469_1)
{    Security.addProvider(new BouncyCastleProvider());    File tmpDir = null;    X509TestContext x509TestContext = null;    try {        tmpDir = ClientBase.createEmptyTestDir();        x509TestContext = X509TestContext.newBuilder().setTempDir(tmpDir).setKeyStorePassword("").setKeyStoreKeyType(X509KeyType.EC).setTrustStorePassword("").setTrustStoreKeyType(X509KeyType.EC).build();        System.setProperty("zookeeper.ssl.quorum.keyStore.location", x509TestContext.getKeyStoreFile(KeyStoreFileType.PEM).getAbsolutePath());        System.setProperty("zookeeper.ssl.quorum.trustStore.location", x509TestContext.getTrustStoreFile(KeyStoreFileType.PEM).getAbsolutePath());    } catch (Exception e) {            }    System.setProperty("zookeeper.ssl.quorum.keyStore.password", "");    System.setProperty("zookeeper.ssl.quorum.keyStore.type", "PEM");    System.setProperty("zookeeper.ssl.quorum.trustStore.password", "");    System.setProperty("zookeeper.ssl.quorum.trustStore.type", "PEM");    System.setProperty("zookeeper.admin.portUnification", "true");        TrustManager[] trustAllCerts = new TrustManager[] { new X509TrustManager() {        public java.security.cert.X509Certificate[] getAcceptedIssuers() {            return null;        }        public void checkClientTrusted(X509Certificate[] certs, String authType) {        }        public void checkServerTrusted(X509Certificate[] certs, String authType) {        }    } };        SSLContext sc = null;    try {        sc = SSLContext.getInstance("SSL");        sc.init(null, trustAllCerts, new java.security.SecureRandom());    } catch (Exception e) {            }        HostnameVerifier allValid = new HostnameVerifier() {        public boolean verify(String hostname, SSLSession session) {            return true;        }    };            HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());    HttpsURLConnection.setDefaultHostnameVerifier(allValid);}
getAcceptedIssuers
public java.security.cert.X509Certificate[] zookeeper_f4470_0()
{    return null;}
checkClientTrusted
public void zookeeper_f4471_0(X509Certificate[] certs, String authType)
{}
checkServerTrusted
public void zookeeper_f4472_0(X509Certificate[] certs, String authType)
{}
verify
public boolean zookeeper_f4473_0(String hostname, SSLSession session)
{    return true;}
cleanUp
public void zookeeper_f4474_0()
{    Security.removeProvider("BC");    System.clearProperty("zookeeper.admin.enableServer");    System.clearProperty("zookeeper.admin.serverPort");    System.clearProperty("zookeeper.ssl.quorum.keyStore.location");    System.clearProperty("zookeeper.ssl.quorum.keyStore.password");    System.clearProperty("zookeeper.ssl.quorum.keyStore.type");    System.clearProperty("zookeeper.ssl.quorum.trustStore.location");    System.clearProperty("zookeeper.ssl.quorum.trustStore.password");    System.clearProperty("zookeeper.ssl.quorum.trustStore.type");    System.clearProperty("zookeeper.admin.portUnification");}
testJettyAdminServer
public void zookeeper_f4475_0() throws AdminServerException, IOException, SSLContextException, GeneralSecurityException
{    JettyAdminServer server = new JettyAdminServer();    try {        server.start();        queryAdminServer(jettyAdminPort);    } finally {        server.shutdown();    }}
testStandalone
public void zookeeper_f4476_0() throws Exception
{    ClientBase.setupTestEnv();    final int CLIENT_PORT = PortAssignment.unique();    ZooKeeperServerMainTest.MainThread main = new ZooKeeperServerMainTest.MainThread(CLIENT_PORT, false, null);    main.start();    assertTrue("waiting for server being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT, ClientBase.CONNECTION_TIMEOUT));    queryAdminServer(jettyAdminPort);    main.shutdown();    assertTrue("waiting for server down", ClientBase.waitForServerDown("127.0.0.1:" + CLIENT_PORT, ClientBase.CONNECTION_TIMEOUT));}
testQuorum
public void zookeeper_f4477_0() throws Exception
{    ClientBase.setupTestEnv();    final int CLIENT_PORT_QP1 = PortAssignment.unique();    final int CLIENT_PORT_QP2 = PortAssignment.unique();    final int ADMIN_SERVER_PORT1 = PortAssignment.unique();    final int ADMIN_SERVER_PORT2 = PortAssignment.unique();    String quorumCfgSection = String.format("server.1=127.0.0.1:%d:%d;%d\nserver.2=127.0.0.1:%d:%d;%d", PortAssignment.unique(), PortAssignment.unique(), CLIENT_PORT_QP1, PortAssignment.unique(), PortAssignment.unique(), CLIENT_PORT_QP2);    QuorumPeerTestBase.MainThread q1 = new QuorumPeerTestBase.MainThread(1, CLIENT_PORT_QP1, ADMIN_SERVER_PORT1, quorumCfgSection, null);    q1.start();                Thread.sleep(500);    QuorumPeerTestBase.MainThread q2 = new QuorumPeerTestBase.MainThread(2, CLIENT_PORT_QP2, ADMIN_SERVER_PORT2, quorumCfgSection, null);    q2.start();    Thread.sleep(500);    assertTrue("waiting for server 1 being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_QP1, ClientBase.CONNECTION_TIMEOUT));    assertTrue("waiting for server 2 being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_QP2, ClientBase.CONNECTION_TIMEOUT));    queryAdminServer(ADMIN_SERVER_PORT1);    queryAdminServer(ADMIN_SERVER_PORT2);    q1.shutdown();    q2.shutdown();    assertTrue("waiting for server 1 down", ClientBase.waitForServerDown("127.0.0.1:" + CLIENT_PORT_QP1, ClientBase.CONNECTION_TIMEOUT));    assertTrue("waiting for server 2 down", ClientBase.waitForServerDown("127.0.0.1:" + CLIENT_PORT_QP2, ClientBase.CONNECTION_TIMEOUT));}
queryAdminServer
private void zookeeper_f4478_0(int port) throws IOException, SSLContextException
{    queryAdminServer(String.format(URL_FORMAT, port), false);    queryAdminServer(String.format(HTTPS_URL_FORMAT, port), true);}
queryAdminServer
private void zookeeper_f4479_0(String urlStr, boolean encrypted) throws IOException, SSLContextException
{    URL url = new URL(urlStr);    BufferedReader dis;    if (!encrypted) {        dis = new BufferedReader(new InputStreamReader((url.openStream())));    } else {        HttpsURLConnection conn = (HttpsURLConnection) url.openConnection();        dis = new BufferedReader(new InputStreamReader(conn.getInputStream()));    }    String line = dis.readLine();    assertTrue(line.length() > 0);}
nextDouble
public double zookeeper_f4480_0()
{    if (throttle.getDropChance() > 0) {        flag = 1 - flag;        return flag;    } else {        return 1;    }}
testThrottleDisabled
public void zookeeper_f4481_0()
{    BlueThrottle throttler = new BlueThrottle();    assertTrue("Throttle should be disabled by default", throttler.checkLimit(1));}
testThrottleWithoutRefill
public void zookeeper_f4482_0()
{    BlueThrottle throttler = new BlueThrottle();    throttler.setMaxTokens(1);    throttler.setFillTime(2000);    assertTrue("First request should be allowed", throttler.checkLimit(1));    assertFalse("Second request should be denied", throttler.checkLimit(1));}
testThrottleWithRefill
public void zookeeper_f4483_0() throws InterruptedException
{    BlueThrottle throttler = new BlueThrottle();    throttler.setMaxTokens(1);    throttler.setFillTime(500);    assertTrue("First request should be allowed", throttler.checkLimit(1));    assertFalse("Second request should be denied", throttler.checkLimit(1));        Thread.sleep(750);    assertTrue("Third request should be allowed since we've got a new token", throttler.checkLimit(1));}
testThrottleWithoutRandomDropping
public void zookeeper_f4484_0() throws InterruptedException
{    int maxTokens = 5;    BlueThrottle throttler = new BlueThrottleWithMockRandom(new MockRandom());    throttler.setMaxTokens(maxTokens);    throttler.setFillCount(maxTokens);    throttler.setFillTime(1000);    for (int i = 0; i < maxTokens; i++) {        throttler.checkLimit(1);    }    assertEquals("All tokens should be used up by now", throttler.getMaxTokens(), throttler.getDeficit());    Thread.sleep(110);    throttler.checkLimit(1);    assertFalse("Dropping probability should still be zero", throttler.getDropChance() > 0);        Thread.sleep(1500);    for (int i = 0; i < maxTokens; i++) {        assertTrue("The first " + maxTokens + " requests should be allowed", throttler.checkLimit(1));    }    for (int i = 0; i < maxTokens; i++) {        assertFalse("The latter " + maxTokens + " requests should be denied", throttler.checkLimit(1));    }}
testThrottleWithRandomDropping
public voidf4485_1) throws InterruptedException
{    int maxTokens = 5;    BlueThrottle throttler = new BlueThrottleWithMockRandom(new MockRandom());    throttler.setMaxTokens(maxTokens);    throttler.setFillCount(maxTokens);    throttler.setFillTime(1000);    throttler.setFreezeTime(100);    throttler.setDropIncrease(0.5);    for (int i = 0; i < maxTokens; i++) {        throttler.checkLimit(1);    }    assertEquals("All tokens should be used up by now", throttler.getMaxTokens(), throttler.getDeficit());    Thread.sleep(120);        throttler.checkLimit(1);    assertTrue("Dropping probability should be increased", throttler.getDropChance() > 0);            Thread.sleep(1100);        int accepted = 0;    for (int i = 0; i < maxTokens; i++) {        if (throttler.checkLimit(1)) {            accepted++;        }    }        assertTrue("The dropping should be distributed", accepted < maxTokens);    accepted = 0;    for (int i = 0; i < maxTokens; i++) {        if (throttler.checkLimit(1)) {            accepted++;        }    }        assertTrue("Later requests should have a chance", accepted > 0);}
connect
private intf4486_1int n) throws Exception
{    String connStr = quorumUtil.getConnectionStringForServer(1);    int connected = 0;    zks = new ZooKeeper[n];    watchers = new ClientBase.CountdownWatcher[n];    for (int i = 0; i < n; i++) {        watchers[i] = new ClientBase.CountdownWatcher();        zks[i] = new ZooKeeper(connStr, 3000, watchers[i]);        try {            watchers[i].waitForConnected(RAPID_TIMEOUT);            connected++;        } catch (TimeoutException e) {                        break;        }    }    return connected;}
shutdownQuorum
private void zookeeper_f4487_0() throws Exception
{    for (ZooKeeper zk : zks) {        if (zk != null) {            zk.close();        }    }    quorumUtil.shutdownAll();}
testNoThrottling
public void zookeeper_f4488_0() throws Exception
{    quorumUtil.startAll();        quorumUtil.getPeer(1).peer.getActiveServer().connThrottle().setMaxTokens(0);    int connected = connect(10);    Assert.assertEquals(10, connected);    shutdownQuorum();}
testThrottling
public void zookeeper_f4489_0() throws Exception
{    quorumUtil.enableLocalSession(true);    quorumUtil.startAll();    quorumUtil.getPeer(1).peer.getActiveServer().connThrottle().setMaxTokens(2);        quorumUtil.getPeer(1).peer.getActiveServer().connThrottle().setFillCount(0);    int connected = connect(3);    Assert.assertEquals(2, connected);    shutdownQuorum();    quorumUtil.enableLocalSession(false);    quorumUtil.startAll();    quorumUtil.getPeer(1).peer.getActiveServer().connThrottle().setMaxTokens(2);        quorumUtil.getPeer(1).peer.getActiveServer().connThrottle().setFillCount(0);    connected = connect(3);    Assert.assertEquals(2, connected);    shutdownQuorum();}
testWeighedThrottling
public voidf4490_1) throws Exception
{            BlueThrottle.setConnectionWeightEnabled(true);    quorumUtil.enableLocalSession(true);    quorumUtil.startAll();    quorumUtil.getPeer(1).peer.getActiveServer().connThrottle().setMaxTokens(10);    quorumUtil.getPeer(1).peer.getActiveServer().connThrottle().setFillCount(0);        int connected = connect(11);    Assert.assertEquals(10, connected);    shutdownQuorum();    quorumUtil.enableLocalSession(false);    quorumUtil.startAll();    quorumUtil.getPeer(1).peer.getActiveServer().connThrottle().setMaxTokens(10);    quorumUtil.getPeer(1).peer.getActiveServer().connThrottle().setFillCount(0);        connected = connect(11);    Assert.assertEquals(3, connected);    shutdownQuorum();    quorumUtil.startAll();    quorumUtil.getPeer(1).peer.getActiveServer().connThrottle().setMaxTokens(10);    quorumUtil.getPeer(1).peer.getActiveServer().connThrottle().setFillCount(0);    connected = connect(2);    Assert.assertEquals(2, connected);    quorumUtil.shutdown(1);    watchers[0].waitForDisconnected(RAPID_TIMEOUT);    watchers[1].waitForDisconnected(RAPID_TIMEOUT);    quorumUtil.restart(1);        quorumUtil.getPeer(1).peer.getActiveServer().connThrottle().setMaxTokens(3);    quorumUtil.getPeer(1).peer.getActiveServer().connThrottle().setFillCount(0);    int reconnected = 0;    for (int i = 0; i < 2; i++) {        try {            watchers[i].waitForConnected(RAPID_TIMEOUT);            reconnected++;        } catch (TimeoutException e) {                    }    }            Assert.assertEquals(1, reconnected);    shutdownQuorum();}
setUpClass
public static void zookeeper_f4491_0()
{    int len = DATA_BYTES_0.length + 2;    DATA_BYTES = new byte[len];    System.arraycopy(DATA_BYTES_0, 0, DATA_BYTES, 0, DATA_BYTES_0.length);    DATA_BYTES[len - 2] = (byte) 0x0;    DATA_BYTES[len - 1] = (byte) 0xff;}
setUp
public void zookeeper_f4492_0() throws Exception
{    bb = ByteBuffer.wrap(DATA_BYTES);    in = new ByteBufferInputStream(bb);    bs = new byte[] { (byte) 1, (byte) 2, (byte) 3, (byte) 4 };}
testRead
public void zookeeper_f4493_0() throws Exception
{    for (int i = 0; i < DATA_BYTES.length; i++) {        int b = in.read();        assertEquals(DATA_BYTES[i], (byte) b);    }    assertEquals(-1, in.read());}
testReadArrayOffsetLength
public void zookeeper_f4494_0() throws Exception
{    assertEquals(1, in.read(bs, 2, 1));    byte[] expected = new byte[] { (byte) 1, (byte) 2, DATA_BYTES[0], (byte) 4 };    assertArrayEquals(expected, bs);}
testReadArrayOffsetLength_LengthTooLarge
public void zookeeper_f4495_0() throws Exception
{    in.read(bs, 2, 3);}
testReadArrayOffsetLength_HitEndOfStream
public void zookeeper_f4496_0() throws Exception
{    for (int i = 0; i < DATA_BYTES.length - 1; i++) {        in.read();    }    assertEquals(1, in.read(bs, 2, 2));    byte[] expected = new byte[] { (byte) 1, (byte) 2, DATA_BYTES[DATA_BYTES.length - 1], (byte) 4 };    assertArrayEquals(expected, bs);}
testReadArrayOffsetLength_AtEndOfStream
public void zookeeper_f4497_0() throws Exception
{    for (int i = 0; i < DATA_BYTES.length; i++) {        in.read();    }    byte[] expected = Arrays.copyOf(bs, bs.length);    assertEquals(-1, in.read(bs, 2, 2));    assertArrayEquals(expected, bs);}
testReadArrayOffsetLength_0Length
public void zookeeper_f4498_0() throws Exception
{    byte[] expected = Arrays.copyOf(bs, bs.length);    assertEquals(0, in.read(bs, 2, 0));    assertArrayEquals(expected, bs);}
testReadArray
public void zookeeper_f4499_0() throws Exception
{    byte[] expected = Arrays.copyOf(DATA_BYTES, 4);    assertEquals(4, in.read(bs));    assertArrayEquals(expected, bs);}
testSkip
public void zookeeper_f4500_0() throws Exception
{    in.read();    assertEquals(2L, in.skip(2L));    assertEquals(DATA_BYTES[3], in.read());    assertEquals(DATA_BYTES[4], in.read());}
testSkip2
public void zookeeper_f4501_0() throws Exception
{    for (int i = 0; i < DATA_BYTES.length / 2; i++) {        in.read();    }    long skipAmount = DATA_BYTES.length / 4;    assertEquals(skipAmount, in.skip(skipAmount));    int idx = DATA_BYTES.length / 2 + (int) skipAmount;    assertEquals(DATA_BYTES[idx++], in.read());    assertEquals(DATA_BYTES[idx++], in.read());}
testNegativeSkip
public void zookeeper_f4502_0() throws Exception
{    in.read();    assertEquals(0L, in.skip(-2L));    assertEquals(DATA_BYTES[1], in.read());    assertEquals(DATA_BYTES[2], in.read());}
testSkip_HitEnd
public void zookeeper_f4503_0() throws Exception
{    for (int i = 0; i < DATA_BYTES.length - 1; i++) {        in.read();    }    assertEquals(1L, in.skip(2L));    assertEquals(-1, in.read());}
testSkip_AtEnd
public void zookeeper_f4504_0() throws Exception
{    for (int i = 0; i < DATA_BYTES.length; i++) {        in.read();    }    assertEquals(0L, in.skip(2L));    assertEquals(-1, in.read());}
testAvailable
public void zookeeper_f4505_0() throws Exception
{    for (int i = DATA_BYTES.length; i > 0; i--) {        assertEquals(i, in.available());        in.read();    }    assertEquals(0, in.available());}
testRevalidateCount
public voidf4506_1) throws Exception
{    ServerMetrics.getMetrics().resetAll();        QuorumUtil util = new QuorumUtil(1);        util.enableLocalSession(false);    util.startAll();    int follower1 = (int) util.getFollowerQuorumPeers().get(0).getId();    int follower2 = (int) util.getFollowerQuorumPeers().get(1).getId();        ClientBase.CountdownWatcher watcher = new ClientBase.CountdownWatcher();        ZooKeeper zk = new ZooKeeper(util.getConnectionStringForServer(follower1), ClientBase.CONNECTION_TIMEOUT, watcher);    watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT);            zk.updateServerList(util.getConnectionStringForServer(follower2));        util.shutdown(follower1);    watcher.waitForDisconnected(ClientBase.CONNECTION_TIMEOUT);            watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT);        Map<String, Object> values = MetricsUtils.currentServerMetrics();    assertEquals(1L, values.get("connection_revalidate_count"));    assertEquals(1L, values.get("revalidate_count"));    zk.close();    util.shutdownAll();}
isSocketOpen
protected boolean zookeeper_f4507_0()
{    return true;}
channel
public SelectableChannel zookeeper_f4508_0()
{    return null;}
selector
public Selector zookeeper_f4509_0()
{    return mock(Selector.class);}
isValid
public boolean zookeeper_f4510_0()
{    return true;}
cancel
public void zookeeper_f4511_0()
{}
interestOps
public int zookeeper_f4512_0()
{    return ops;}
interestOps
public SelectionKey zookeeper_f4513_0(int ops)
{    this.ops = ops;    return this;}
readyOps
public int zookeeper_f4514_0()
{    return ops;}
createMockNIOCnxn
private NIOServerCnxn zookeeper_f4515_0() throws IOException
{    InetSocketAddress socketAddr = new InetSocketAddress(80);    Socket socket = mock(Socket.class);    when(socket.getRemoteSocketAddress()).thenReturn(socketAddr);    SocketChannel sock = mock(SocketChannel.class);    when(sock.socket()).thenReturn(socket);    when(sock.read(any(ByteBuffer.class))).thenReturn(-1);    return new MockNIOServerCnxn(mock(ZooKeeperServer.class), sock, null, mock(NIOServerCnxnFactory.class), null);}
testNIOConnectionDropCount
public void zookeeper_f4516_0() throws Exception
{    ServerMetrics.getMetrics().resetAll();    NIOServerCnxn cnxn = createMockNIOCnxn();    cnxn.doIO(new FakeSK());    Map<String, Object> values = MetricsUtils.currentServerMetrics();    assertEquals(1L, values.get("connection_drop_count"));}
testNettyConnectionDropCount
public void zookeeper_f4517_0() throws Exception
{    InetSocketAddress socketAddr = new InetSocketAddress(80);    Channel channel = mock(Channel.class);    when(channel.isOpen()).thenReturn(false);    when(channel.remoteAddress()).thenReturn(socketAddr);    EventLoop eventLoop = mock(EventLoop.class);    when(channel.eventLoop()).thenReturn(eventLoop);    ServerMetrics.getMetrics().resetAll();    NettyServerCnxnFactory factory = new NettyServerCnxnFactory();    NettyServerCnxn cnxn = new NettyServerCnxn(channel, mock(ZooKeeperServer.class), factory);        factory.cnxns.add(cnxn);    cnxn.close();    Map<String, Object> values = MetricsUtils.currentServerMetrics();    assertEquals(1L, values.get("connection_drop_count"));}
testSessionlessConnectionsExpired
public void zookeeper_f4518_0() throws Exception
{    ServerCnxnFactory factory = new NIOServerCnxnFactory();    factory.configure(new InetSocketAddress(PortAssignment.unique()), 1000);    factory.start();    int timeout = Integer.getInteger(ZOOKEEPER_NIO_SESSIONLESS_CNXN_TIMEOUT, 10000);    ServerMetrics.getMetrics().resetAll();        ((NIOServerCnxnFactory) factory).touchCnxn(createMockNIOCnxn());    ((NIOServerCnxnFactory) factory).touchCnxn(createMockNIOCnxn());    Map<String, Object> values = MetricsUtils.currentServerMetrics();    int sleptTime = 0;    while (values.get("sessionless_connections_expired") == null || sleptTime < 2 * timeout) {        Thread.sleep(100);        sleptTime += 100;        values = MetricsUtils.currentServerMetrics();    }    assertEquals(2L, values.get("sessionless_connections_expired"));    factory.shutdown();}
testStaleSessionsExpired
public void zookeeper_f4519_0() throws Exception
{    int tickTime = 1000;    SessionTrackerImpl tracker = new SessionTrackerImpl(mock(ZooKeeperServer.class), new ConcurrentHashMap<>(), tickTime, 1L, null);    tracker.sessionsById.put(1L, mock(SessionTrackerImpl.SessionImpl.class));    tracker.sessionsById.put(2L, mock(SessionTrackerImpl.SessionImpl.class));    tracker.touchSession(1L, tickTime);    tracker.touchSession(2L, tickTime);    ServerMetrics.getMetrics().resetAll();    tracker.start();    Map<String, Object> values = MetricsUtils.currentServerMetrics();    int sleptTime = 0;    while (values.get("stale_sessions_expired") == null || sleptTime < 2 * tickTime) {        Thread.sleep(100);        sleptTime += 100;        values = MetricsUtils.currentServerMetrics();    }    assertEquals(2L, values.get("stale_sessions_expired"));    tracker.shutdown();}
corruptFile
private void zookeeper_f4520_0(File file) throws IOException
{        RandomAccessFile raf = new RandomAccessFile(file, "rw");    byte[] b = "mahadev".getBytes();    long writeLen = 500L;    raf.seek(writeLen);        raf.write(b);    raf.close();}
getCheckSum
private boolean zookeeper_f4521_0(FileSnap snap, File snapFile) throws IOException
{    DataTree dt = new DataTree();    Map<Long, Integer> sessions = new ConcurrentHashMap<Long, Integer>();    InputStream snapIS = new BufferedInputStream(new FileInputStream(snapFile));    CheckedInputStream crcIn = new CheckedInputStream(snapIS, new Adler32());    InputArchive ia = BinaryInputArchive.getArchive(crcIn);    try {        snap.deserialize(dt, sessions, ia);    } catch (IOException ie) {                                        snapIS.close();        crcIn.close();        throw ie;    }    long checksum = crcIn.getChecksum().getValue();    long val = ia.readLong("val");    snapIS.close();    crcIn.close();    return (val != checksum);}
testChecksums
public voidf4522_1) throws Exception
{    File tmpDir = ClientBase.createTmpDir();    ClientBase.setupTestEnv();    ZooKeeperServer zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);    SyncRequestProcessor.setSnapCount(150);    final int PORT = Integer.parseInt(HOSTPORT.split(":")[1]);    ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);    f.startup(zks);        assertTrue("waiting for server being up", ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT));    ZooKeeper zk = ClientBase.createZKClient(HOSTPORT);    try {        for (int i = 0; i < 2000; i++) {            zk.create("/crctest- " + i, ("/crctest- " + i).getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        }    } finally {        zk.close();    }    f.shutdown();    zks.shutdown();    assertTrue("waiting for server down", ClientBase.waitForServerDown(HOSTPORT, ClientBase.CONNECTION_TIMEOUT));    File versionDir = new File(tmpDir, "version-2");    File[] list = versionDir.listFiles();            File snapFile = null;    File logFile = null;    for (File file : list) {                if (file.getName().startsWith("log")) {            logFile = file;            corruptFile(logFile);        }    }    FileTxnLog flog = new FileTxnLog(versionDir);    TxnIterator itr = flog.read(1);        try {        while (itr.next()) {        }        assertTrue(false);    } catch (IOException ie) {            }    itr.close();        FileSnap snap = new FileSnap(versionDir);    List<File> snapFiles = snap.findNRecentSnapshots(2);    snapFile = snapFiles.get(0);    corruptFile(snapFile);    boolean cfile = false;    try {        cfile = getCheckSum(snap, snapFile);    } catch (IOException ie) {                                snapFile = snapFiles.get(1);        corruptFile(snapFile);        cfile = getCheckSum(snap, snapFile);    }    assertTrue(cfile);}
setUp
public void zookeeper_f4523_0() throws Exception
{    super.setUp();    zk = createClient();}
tearDown
public void zookeeper_f4524_0() throws Exception
{    super.tearDown();    zk.close();}
testCreate
public void zookeeper_f4525_0() throws KeeperException, InterruptedException
{    createNoStatVerifyResult("/foo");    createNoStatVerifyResult("/foo/child");}
testCreateWithStat
public void zookeeper_f4526_0() throws KeeperException, InterruptedException
{    Stat stat = createWithStatVerifyResult("/foo");    Stat childStat = createWithStatVerifyResult("/foo/child");        assertFalse(stat.equals(childStat));}
testCreateWithNullStat
public void zookeeper_f4527_0() throws KeeperException, InterruptedException
{    final String name = "/foo";    assertNull(zk.exists(name, false));    Stat stat = null;            zk.create(name, name.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.CONTAINER, stat);    assertNull(stat);    assertNotNull(zk.exists(name, false));}
testSimpleDeletion
public void zookeeper_f4528_0() throws KeeperException, InterruptedException
{    zk.create("/foo", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.CONTAINER);    zk.create("/foo/bar", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        zk.delete("/foo/bar", -1);    ContainerManager containerManager = new ContainerManager(serverFactory.getZooKeeperServer().getZKDatabase(), serverFactory.getZooKeeperServer().firstProcessor, 1, 100);    containerManager.checkContainers();    Thread.sleep(1000);    assertNull("Container should have been deleted", zk.exists("/foo", false));}
testMultiWithContainerSimple
public void zookeeper_f4529_0() throws KeeperException, InterruptedException
{    Op createContainer = Op.create("/foo", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.CONTAINER);    zk.multi(Collections.singletonList(createContainer));    DataTree dataTree = serverFactory.getZooKeeperServer().getZKDatabase().getDataTree();    assertEquals(dataTree.getContainers().size(), 1);}
testMultiWithContainer
public void zookeeper_f4530_0() throws KeeperException, InterruptedException
{    Op createContainer = Op.create("/foo", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.CONTAINER);    Op createChild = Op.create("/foo/bar", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.multi(Arrays.asList(createContainer, createChild));    DataTree dataTree = serverFactory.getZooKeeperServer().getZKDatabase().getDataTree();    assertEquals(dataTree.getContainers().size(), 1);        zk.delete("/foo/bar", -1);    ContainerManager containerManager = new ContainerManager(serverFactory.getZooKeeperServer().getZKDatabase(), serverFactory.getZooKeeperServer().firstProcessor, 1, 100);    containerManager.checkContainers();    Thread.sleep(1000);    assertNull("Container should have been deleted", zk.exists("/foo", false));    createContainer = Op.create("/foo", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.CONTAINER);    createChild = Op.create("/foo/bar", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    Op deleteChild = Op.delete("/foo/bar", -1);    zk.multi(Arrays.asList(createContainer, createChild, deleteChild));    containerManager.checkContainers();    Thread.sleep(1000);    assertNull("Container should have been deleted", zk.exists("/foo", false));}
testSimpleDeletionAsync
public void zookeeper_f4531_0() throws KeeperException, InterruptedException
{    final CountDownLatch latch = new CountDownLatch(1);    AsyncCallback.Create2Callback cb = new AsyncCallback.Create2Callback() {        @Override        public void processResult(int rc, String path, Object ctx, String name, Stat stat) {            assertEquals(ctx, "context");            latch.countDown();        }    };    zk.create("/foo", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.CONTAINER, cb, "context");    assertTrue(latch.await(5, TimeUnit.SECONDS));    zk.create("/foo/bar", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        zk.delete("/foo/bar", -1);    ContainerManager containerManager = new ContainerManager(serverFactory.getZooKeeperServer().getZKDatabase(), serverFactory.getZooKeeperServer().firstProcessor, 1, 100);    containerManager.checkContainers();    Thread.sleep(1000);    assertNull("Container should have been deleted", zk.exists("/foo", false));}
processResult
public void zookeeper_f4532_0(int rc, String path, Object ctx, String name, Stat stat)
{    assertEquals(ctx, "context");    latch.countDown();}
testCascadingDeletion
public void zookeeper_f4533_0() throws KeeperException, InterruptedException
{    zk.create("/foo", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.CONTAINER);    zk.create("/foo/bar", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.CONTAINER);    zk.create("/foo/bar/one", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        zk.delete("/foo/bar/one", -1);    ContainerManager containerManager = new ContainerManager(serverFactory.getZooKeeperServer().getZKDatabase(), serverFactory.getZooKeeperServer().firstProcessor, 1, 100);    containerManager.checkContainers();    Thread.sleep(1000);    containerManager.checkContainers();    Thread.sleep(1000);    assertNull("Container should have been deleted", zk.exists("/foo/bar", false));    assertNull("Container should have been deleted", zk.exists("/foo", false));}
testFalseEmpty
public void zookeeper_f4534_0() throws KeeperException, InterruptedException
{    zk.create("/foo", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.CONTAINER);    zk.create("/foo/bar", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    ContainerManager containerManager = new ContainerManager(serverFactory.getZooKeeperServer().getZKDatabase(), serverFactory.getZooKeeperServer().firstProcessor, 1, 100) {        @Override        protected Collection<String> getCandidates() {            return Collections.singletonList("/foo");        }    };    containerManager.checkContainers();    Thread.sleep(1000);    assertNotNull("Container should have not been deleted", zk.exists("/foo", false));}
getCandidates
protected Collection<String> zookeeper_f4535_0()
{    return Collections.singletonList("/foo");}
testMaxPerMinute
public void zookeeper_f4536_0() throws InterruptedException
{    final BlockingQueue<String> queue = new LinkedBlockingQueue<String>();    RequestProcessor processor = new RequestProcessor() {        @Override        public void processRequest(Request request) {            queue.add(new String(request.request.array()));        }        @Override        public void shutdown() {        }    };    final ContainerManager containerManager = new ContainerManager(serverFactory.getZooKeeperServer().getZKDatabase(), processor, 1, 2) {        @Override        protected long getMinIntervalMs() {            return 1000;        }        @Override        protected Collection<String> getCandidates() {            return Arrays.asList("/one", "/two", "/three", "/four");        }    };    Executors.newSingleThreadExecutor().submit(new Callable<Void>() {        @Override        public Void call() throws Exception {            containerManager.checkContainers();            return null;        }    });    assertEquals(queue.poll(5, TimeUnit.SECONDS), "/one");    assertEquals(queue.poll(5, TimeUnit.SECONDS), "/two");    assertEquals(queue.size(), 0);    Thread.sleep(500);    assertEquals(queue.size(), 0);    assertEquals(queue.poll(5, TimeUnit.SECONDS), "/three");    assertEquals(queue.poll(5, TimeUnit.SECONDS), "/four");}
processRequest
public void zookeeper_f4537_0(Request request)
{    queue.add(new String(request.request.array()));}
shutdown
public void zookeeper_f4538_0()
{}
getMinIntervalMs
protected long zookeeper_f4539_0()
{    return 1000;}
getCandidates
protected Collection<String> zookeeper_f4540_0()
{    return Arrays.asList("/one", "/two", "/three", "/four");}
call
public Void zookeeper_f4541_0() throws Exception
{    containerManager.checkContainers();    return null;}
createNoStatVerifyResult
private void zookeeper_f4542_0(String newName) throws KeeperException, InterruptedException
{    assertNull("Node existed before created", zk.exists(newName, false));    zk.create(newName, newName.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.CONTAINER);    assertNotNull("Node was not created as expected", zk.exists(newName, false));}
createWithStatVerifyResult
private Stat zookeeper_f4543_0(String newName) throws KeeperException, InterruptedException
{    assertNull("Node existed before created", zk.exists(newName, false));    Stat stat = new Stat();    zk.create(newName, newName.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.CONTAINER, stat);    validateCreateStat(stat, newName);    Stat referenceStat = zk.exists(newName, false);    assertNotNull("Node was not created as expected", referenceStat);    assertEquals(referenceStat, stat);    return stat;}
validateCreateStat
private void zookeeper_f4544_0(Stat stat, String name)
{    assertEquals(stat.getCzxid(), stat.getMzxid());    assertEquals(stat.getCzxid(), stat.getPzxid());    assertEquals(stat.getCtime(), stat.getMtime());    assertEquals(0, stat.getCversion());    assertEquals(0, stat.getVersion());    assertEquals(0, stat.getAversion());    assertEquals(0, stat.getEphemeralOwner());    assertEquals(name.length(), stat.getDataLength());    assertEquals(0, stat.getNumChildren());}
setUp
public void zookeeper_f4545_0() throws Exception
{    System.setProperty(EphemeralType.EXTENDED_TYPES_ENABLED_PROPERTY, disabledTests.contains(getTestName()) ? "false" : "true");    super.setUpWithServerId(254);    zk = createClient();}
tearDown
public void zookeeper_f4546_0() throws Exception
{    System.clearProperty(EphemeralType.EXTENDED_TYPES_ENABLED_PROPERTY);    super.tearDown();    zk.close();}
testCreate
public void zookeeper_f4547_0() throws KeeperException, InterruptedException
{    Stat stat = new Stat();    zk.create("/foo", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_WITH_TTL, stat, 100);    assertEquals(0, stat.getEphemeralOwner());    final AtomicLong fakeElapsed = new AtomicLong(0);    ContainerManager containerManager = newContainerManager(fakeElapsed);    containerManager.checkContainers();    assertNotNull("Ttl node should not have been deleted yet", zk.exists("/foo", false));    fakeElapsed.set(1000);    containerManager.checkContainers();    assertNull("Ttl node should have been deleted", zk.exists("/foo", false));}
testBadTTLs
public void zookeeper_f4548_0() throws InterruptedException, KeeperException
{    RequestHeader h = new RequestHeader(1, ZooDefs.OpCode.createTTL);    String path = "/bad_ttl";    CreateTTLRequest request = new CreateTTLRequest(path, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_WITH_TTL.toFlag(), -100);    CreateResponse response = new CreateResponse();    ReplyHeader r = zk.submitRequest(h, request, response, null);    assertEquals("An invalid CreateTTLRequest should throw BadArguments", r.getErr(), Code.BADARGUMENTS.intValue());    assertNull("An invalid CreateTTLRequest should not result in znode creation", zk.exists(path, false));    request = new CreateTTLRequest(path, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_WITH_TTL.toFlag(), EphemeralType.TTL.maxValue() + 1);    response = new CreateResponse();    r = zk.submitRequest(h, request, response, null);    assertEquals("An invalid CreateTTLRequest should throw BadArguments", r.getErr(), Code.BADARGUMENTS.intValue());    assertNull("An invalid CreateTTLRequest should not result in znode creation", zk.exists(path, false));}
testMaxTTLs
public void zookeeper_f4549_0() throws InterruptedException, KeeperException
{    RequestHeader h = new RequestHeader(1, ZooDefs.OpCode.createTTL);    String path = "/bad_ttl";    CreateTTLRequest request = new CreateTTLRequest(path, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_WITH_TTL.toFlag(), EphemeralType.TTL.maxValue());    CreateResponse response = new CreateResponse();    ReplyHeader r = zk.submitRequest(h, request, response, null);    assertEquals("EphemeralType.getMaxTTL() should succeed", r.getErr(), Code.OK.intValue());    assertNotNull("Node should exist", zk.exists(path, false));}
testCreateSequential
public void zookeeper_f4550_0() throws KeeperException, InterruptedException
{    Stat stat = new Stat();    String path = zk.create("/foo", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL_WITH_TTL, stat, 100);    assertEquals(0, stat.getEphemeralOwner());    final AtomicLong fakeElapsed = new AtomicLong(0);    ContainerManager containerManager = newContainerManager(fakeElapsed);    containerManager.checkContainers();    assertNotNull("Ttl node should not have been deleted yet", zk.exists(path, false));    fakeElapsed.set(1000);    containerManager.checkContainers();    assertNull("Ttl node should have been deleted", zk.exists(path, false));}
testCreateAsync
public void zookeeper_f4551_0() throws KeeperException, InterruptedException
{    AsyncCallback.Create2Callback callback = new AsyncCallback.Create2Callback() {        @Override        public void processResult(int rc, String path, Object ctx, String name, Stat stat) {                }    };    zk.create("/foo", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_WITH_TTL, callback, null, 100);    final AtomicLong fakeElapsed = new AtomicLong(0);    ContainerManager containerManager = newContainerManager(fakeElapsed);    containerManager.checkContainers();    assertNotNull("Ttl node should not have been deleted yet", zk.exists("/foo", false));    fakeElapsed.set(1000);    containerManager.checkContainers();    assertNull("Ttl node should have been deleted", zk.exists("/foo", false));}
processResult
public void zookeeper_f4552_0(int rc, String path, Object ctx, String name, Stat stat)
{}
testModifying
public void zookeeper_f4553_0() throws KeeperException, InterruptedException
{    Stat stat = new Stat();    zk.create("/foo", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_WITH_TTL, stat, 100);    assertEquals(0, stat.getEphemeralOwner());    final AtomicLong fakeElapsed = new AtomicLong(0);    ContainerManager containerManager = newContainerManager(fakeElapsed);    containerManager.checkContainers();    assertNotNull("Ttl node should not have been deleted yet", zk.exists("/foo", false));    for (int i = 0; i < 10; ++i) {        fakeElapsed.set(50);        zk.setData("/foo", new byte[i + 1], -1);        containerManager.checkContainers();        assertNotNull("Ttl node should not have been deleted yet", zk.exists("/foo", false));    }    fakeElapsed.set(200);    containerManager.checkContainers();    assertNull("Ttl node should have been deleted", zk.exists("/foo", false));}
testMulti
public void zookeeper_f4554_0() throws KeeperException, InterruptedException
{    Op createTtl = Op.create("/a", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_WITH_TTL, 100);    Op createTtlSequential = Op.create("/b", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL_WITH_TTL, 200);    Op createNonTtl = Op.create("/c", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    List<OpResult> results = zk.multi(Arrays.asList(createTtl, createTtlSequential, createNonTtl));    String sequentialPath = ((OpResult.CreateResult) results.get(1)).getPath();    final AtomicLong fakeElapsed = new AtomicLong(0);    ContainerManager containerManager = newContainerManager(fakeElapsed);    containerManager.checkContainers();    assertNotNull("node should not have been deleted yet", zk.exists("/a", false));    assertNotNull("node should not have been deleted yet", zk.exists(sequentialPath, false));    assertNotNull("node should never be deleted", zk.exists("/c", false));    fakeElapsed.set(110);    containerManager.checkContainers();    assertNull("node should have been deleted", zk.exists("/a", false));    assertNotNull("node should not have been deleted yet", zk.exists(sequentialPath, false));    assertNotNull("node should never be deleted", zk.exists("/c", false));    fakeElapsed.set(210);    containerManager.checkContainers();    assertNull("node should have been deleted", zk.exists("/a", false));    assertNull("node should have been deleted", zk.exists(sequentialPath, false));    assertNotNull("node should never be deleted", zk.exists("/c", false));}
testBadUsage
public void zookeeper_f4555_0() throws KeeperException, InterruptedException
{    for (CreateMode createMode : CreateMode.values()) {        try {            zk.create("/foo", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, createMode, new Stat(), createMode.isTTL() ? 0 : 100);            fail("should have thrown IllegalArgumentException");        } catch (IllegalArgumentException dummy) {                }    }    for (CreateMode createMode : CreateMode.values()) {        AsyncCallback.Create2Callback callback = new AsyncCallback.Create2Callback() {            @Override            public void processResult(int rc, String path, Object ctx, String name, Stat stat) {                        }        };        try {            zk.create("/foo", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, createMode, callback, null, createMode.isTTL() ? 0 : 100);            fail("should have thrown IllegalArgumentException");        } catch (IllegalArgumentException dummy) {                }    }    try {        Op op = Op.create("/foo", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_WITH_TTL, 0);        zk.multi(Collections.singleton(op));        fail("should have thrown IllegalArgumentException");    } catch (IllegalArgumentException dummy) {        }    try {        Op op = Op.create("/foo", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL_WITH_TTL, 0);        zk.multi(Collections.singleton(op));        fail("should have thrown IllegalArgumentException");    } catch (IllegalArgumentException dummy) {        }}
processResult
public void zookeeper_f4556_0(int rc, String path, Object ctx, String name, Stat stat)
{}
testDisabled
public void zookeeper_f4557_0() throws KeeperException, InterruptedException
{        zk.create("/foo", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_WITH_TTL, new Stat(), 100);}
newContainerManager
private ContainerManager zookeeper_f4558_0(final AtomicLong fakeElapsed)
{    return new ContainerManager(serverFactory.getZooKeeperServer().getZKDatabase(), serverFactory.getZooKeeperServer().firstProcessor, 1, 100) {        @Override        protected long getElapsed(DataNode node) {            return fakeElapsed.get();        }    };}
getElapsed
protected long zookeeper_f4559_0(DataNode node)
{    return fakeElapsed.get();}
setUp
public void zookeeper_f4560_0() throws Exception
{    File dataDir = ClientBase.createTmpDir();    snapDir = dataDir;    dataLogDir = dataDir;}
testPurgeTask
public void zookeeper_f4561_0() throws Exception
{    purgeMgr = new DatadirCleanupManager(snapDir, dataLogDir, 3, 1);    purgeMgr.start();    assertEquals("Data log directory is not set as configured", dataLogDir, purgeMgr.getDataLogDir());    assertEquals("Snapshot directory is not set as configured", snapDir, purgeMgr.getSnapDir());    assertEquals("Snapshot retain count is not set as configured", 3, purgeMgr.getSnapRetainCount());    assertEquals("Purge task is not started", STARTED, purgeMgr.getPurgeTaskStatus());    purgeMgr.shutdown();    assertEquals("Purge task is still running after shutdown", COMPLETED, purgeMgr.getPurgeTaskStatus());}
testWithZeroPurgeInterval
public void zookeeper_f4562_0() throws Exception
{    purgeMgr = new DatadirCleanupManager(snapDir, dataLogDir, 3, 0);    purgeMgr.start();    assertEquals("Purge task is scheduled with zero purge interval", NOT_STARTED, purgeMgr.getPurgeTaskStatus());    purgeMgr.shutdown();    assertEquals("Purge task is scheduled with zero purge interval", NOT_STARTED, purgeMgr.getPurgeTaskStatus());}
testWithNegativePurgeInterval
public void zookeeper_f4563_0() throws Exception
{    purgeMgr = new DatadirCleanupManager(snapDir, dataLogDir, 3, -1);    purgeMgr.start();    assertEquals("Purge task is scheduled with negative purge interval", NOT_STARTED, purgeMgr.getPurgeTaskStatus());    purgeMgr.shutdown();    assertEquals("Purge task is scheduled with negative purge interval", NOT_STARTED, purgeMgr.getPurgeTaskStatus());}
tearDown
public void zookeeper_f4564_0() throws Exception
{    if (purgeMgr != null) {        purgeMgr.shutdown();    }}
testGetChildrenShouldReturnEmptySetWhenThereAreNoChidren
public void zookeeper_f4565_0()
{        DataNode dataNode = new DataNode();    Set<String> children = dataNode.getChildren();    assertNotNull(children);    assertEquals(0, children.size());        String child = "child";    dataNode.addChild(child);    dataNode.removeChild(child);    children = dataNode.getChildren();    assertNotNull(children);    assertEquals(0, children.size());        children = dataNode.getChildren();    try {        children.add("new child");        fail("UnsupportedOperationException is expected");    } catch (UnsupportedOperationException e) {        }}
testGetChildrenReturnsImmutableEmptySet
public void zookeeper_f4566_0()
{    DataNode dataNode = new DataNode();    Set<String> children = dataNode.getChildren();    try {        children.add("new child");        fail("UnsupportedOperationException is expected");    } catch (UnsupportedOperationException e) {        }}
testDumpEphemerals
public voidf4567_1) throws Exception
{    int count = 1000;    long session = 1000;    long zxid = 2000;    final DataTree dataTree = new DataTree();        createEphemeralNode(session, dataTree, count);    final AtomicBoolean exceptionDuringDumpEphemerals = new AtomicBoolean(false);    final AtomicBoolean running = new AtomicBoolean(true);    Thread thread = new Thread() {        public void run() {            PrintWriter pwriter = new PrintWriter(new StringWriter());            try {                while (running.get()) {                    dataTree.dumpEphemerals(pwriter);                }            } catch (Exception e) {                                exceptionDuringDumpEphemerals.set(true);            }        }    };    thread.start();        killZkClientSession(session, zxid, dataTree, count);    running.set(false);    thread.join();    assertFalse("Should have got exception while dumpEphemerals!", exceptionDuringDumpEphemerals.get());}
run
public voidf4568_1)
{    PrintWriter pwriter = new PrintWriter(new StringWriter());    try {        while (running.get()) {            dataTree.dumpEphemerals(pwriter);        }    } catch (Exception e) {                exceptionDuringDumpEphemerals.set(true);    }}
killZkClientSession
private void zookeeper_f4569_0(long session, long zxid, final DataTree dataTree, int count)
{    for (int i = 0; i < count; i++) {        dataTree.killSession(session + i, zxid);    }}
createEphemeralNode
private void zookeeper_f4570_0(long session, final DataTree dataTree, int count) throws NoNodeException, NodeExistsException
{    for (int i = 0; i < count; i++) {        dataTree.createNode("/test" + i, new byte[0], null, session + i, dataTree.getNode("/").stat.getCversion() + 1, 1, 1);    }}
testRootWatchTriggered
public void zookeeper_f4571_0() throws Exception
{    DataTree dt = new DataTree();    CompletableFuture<Void> fire = new CompletableFuture<>();        dt.getChildren("/", new Stat(), event -> {        if (event.getPath().equals("/")) {            fire.complete(null);        }    });        dt.createNode("/xyz", new byte[0], null, 0, dt.getNode("/").stat.getCversion() + 1, 1, 1);    assertTrue("Root node watch not triggered", fire.isDone());}
testIncrementCversion
public void zookeeper_f4572_0() throws Exception
{    try {                ZooKeeperServer.setDigestEnabled(true);        DataTree dt = new DataTree();        dt.createNode("/test", new byte[0], null, 0, dt.getNode("/").stat.getCversion() + 1, 1, 1);        DataNode zk = dt.getNode("/test");        int prevCversion = zk.stat.getCversion();        long prevPzxid = zk.stat.getPzxid();        long digestBefore = dt.getTreeDigest();        dt.setCversionPzxid("/test/", prevCversion + 1, prevPzxid + 1);        int newCversion = zk.stat.getCversion();        long newPzxid = zk.stat.getPzxid();        assertTrue("<cversion, pzxid> verification failed. Expected: <" + (prevCversion + 1) + ", " + (prevPzxid + 1) + ">, found: <" + newCversion + ", " + newPzxid + ">", (newCversion == prevCversion + 1 && newPzxid == prevPzxid + 1));        assertNotEquals(digestBefore, dt.getTreeDigest());    } finally {        ZooKeeperServer.setDigestEnabled(false);    }}
testNoCversionRevert
public void zookeeper_f4573_0() throws Exception
{    DataTree dt = new DataTree();    DataNode parent = dt.getNode("/");    dt.createNode("/test", new byte[0], null, 0, parent.stat.getCversion() + 1, 1, 1);    int currentCversion = parent.stat.getCversion();    long currentPzxid = parent.stat.getPzxid();    dt.createNode("/test1", new byte[0], null, 0, currentCversion - 1, 1, 1);    parent = dt.getNode("/");    int newCversion = parent.stat.getCversion();    long newPzxid = parent.stat.getPzxid();    assertTrue("<cversion, pzxid> verification failed. Expected: <" + currentCversion + ", " + currentPzxid + ">, found: <" + newCversion + ", " + newPzxid + ">", (newCversion >= currentCversion && newPzxid >= currentPzxid));}
testPzxidUpdatedWhenDeletingNonExistNode
public void zookeeper_f4574_0() throws Exception
{    DataTree dt = new DataTree();    DataNode root = dt.getNode("/");    long currentPzxid = root.stat.getPzxid();        long zxid = currentPzxid + 1;    try {        dt.deleteNode("/testPzxidUpdatedWhenDeletingNonExistNode", zxid);    } catch (NoNodeException e) {    /* expected */    }    root = dt.getNode("/");    currentPzxid = root.stat.getPzxid();    assertEquals(currentPzxid, zxid);        long prevPzxid = currentPzxid;    zxid = prevPzxid - 1;    try {        dt.deleteNode("/testPzxidUpdatedWhenDeletingNonExistNode", zxid);    } catch (NoNodeException e) {    /* expected */    }    root = dt.getNode("/");    currentPzxid = root.stat.getPzxid();    assertEquals(currentPzxid, prevPzxid);}
testDigestUpdatedWhenReplayCreateTxnForExistNode
public void zookeeper_f4575_0()
{    try {                ZooKeeperServer.setDigestEnabled(true);        DataTree dt = new DataTree();        dt.processTxn(new TxnHeader(13, 1000, 1, 30, ZooDefs.OpCode.create), new CreateTxn("/foo", "".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, false, 1));                                dt.processTxn(new TxnHeader(13, 1000, 1, 30, ZooDefs.OpCode.create), new CreateTxn("/foo", "".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, false, 2));                assertEquals(dt.getTreeDigest(), dt.getLastProcessedZxidDigest().digest);    } finally {        ZooKeeperServer.setDigestEnabled(false);    }}
testPathTrieClearOnDeserialize
public void zookeeper_f4576_0() throws Exception
{        DataTree dserTree = new DataTree();    dserTree.createNode("/bug", new byte[20], null, -1, 1, 1, 1);    dserTree.createNode(Quotas.quotaZookeeper + "/bug", null, null, -1, 1, 1, 1);    dserTree.createNode(Quotas.quotaPath("/bug"), new byte[20], null, -1, 1, 1, 1);    dserTree.createNode(Quotas.statPath("/bug"), new byte[20], null, -1, 1, 1, 1);        DataTree tree = new DataTree();    ByteArrayOutputStream baos = new ByteArrayOutputStream();    BinaryOutputArchive oa = BinaryOutputArchive.getArchive(baos);    tree.serialize(oa, "test");    baos.flush();    ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());    BinaryInputArchive ia = BinaryInputArchive.getArchive(bais);    dserTree.deserialize(ia, "test");    Field pfield = DataTree.class.getDeclaredField("pTrie");    pfield.setAccessible(true);    PathTrie pTrie = (PathTrie) pfield.get(dserTree);        assertEquals("/bug is still in pTrie", "/", pTrie.findMaxPrefix("/bug"));}
testSerializeDoesntLockDataNodeWhileWriting
public void zookeeper_f4577_0() throws Exception
{    DataTree tree = new DataTree();    tree.createNode("/marker", new byte[] { 42 }, null, -1, 1, 1, 1);    final DataNode markerNode = tree.getNode("/marker");    final AtomicBoolean ranTestCase = new AtomicBoolean();    DataOutputStream out = new DataOutputStream(new ByteArrayOutputStream());    BinaryOutputArchive oa = new BinaryOutputArchive(out) {        @Override        public void writeRecord(Record r, String tag) throws IOException {                        if (r instanceof DataNode) {                DataNode node = (DataNode) r;                if (node.data.length == 1 && node.data[0] == 42) {                    final Semaphore semaphore = new Semaphore(0);                    new Thread(new Runnable() {                        @Override                        public void run() {                            synchronized (markerNode) {                                                                semaphore.release();                            }                        }                    }).start();                    try {                        boolean acquired = semaphore.tryAcquire(30, TimeUnit.SECONDS);                                                                        assertTrue("Couldn't acquire a lock on the DataNode while we were calling tree.serialize", acquired);                    } catch (InterruptedException e1) {                        throw new RuntimeException(e1);                    }                    ranTestCase.set(true);                }            }            super.writeRecord(r, tag);        }    };    tree.serialize(oa, "test");        assertTrue("Didn't find the expected node", ranTestCase.get());}
writeRecord
public void zookeeper_f4578_0(Record r, String tag) throws IOException
{        if (r instanceof DataNode) {        DataNode node = (DataNode) r;        if (node.data.length == 1 && node.data[0] == 42) {            final Semaphore semaphore = new Semaphore(0);            new Thread(new Runnable() {                @Override                public void run() {                    synchronized (markerNode) {                                                semaphore.release();                    }                }            }).start();            try {                boolean acquired = semaphore.tryAcquire(30, TimeUnit.SECONDS);                                                assertTrue("Couldn't acquire a lock on the DataNode while we were calling tree.serialize", acquired);            } catch (InterruptedException e1) {                throw new RuntimeException(e1);            }            ranTestCase.set(true);        }    }    super.writeRecord(r, tag);}
run
public void zookeeper_f4579_0()
{    synchronized (markerNode) {                semaphore.release();    }}
testReconfigACLClearOnDeserialize
public void zookeeper_f4580_0() throws Exception
{    DataTree tree = new DataTree();            tree.deleteNode(ZooDefs.CONFIG_NODE, 1);    tree.getReferenceCountedAclCache().aclIndex = 0;    assertEquals("expected to have 1 acl in acl cache map", 0, tree.aclCacheSize());        tree.createNode("/bug", new byte[20], ZooDefs.Ids.OPEN_ACL_UNSAFE, -1, 1, 1, 1);    ByteArrayOutputStream baos = new ByteArrayOutputStream();    BinaryOutputArchive oa = BinaryOutputArchive.getArchive(baos);    tree.serialize(oa, "test");    baos.flush();    ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());    BinaryInputArchive ia = BinaryInputArchive.getArchive(bais);    tree.deserialize(ia, "test");    assertEquals("expected to have 1 acl in acl cache map", 1, tree.aclCacheSize());    assertEquals("expected to have the same acl", ZooDefs.Ids.OPEN_ACL_UNSAFE, tree.getACL("/bug", new Stat()));            tree.addConfigNode();    assertEquals("expected to have 2 acl in acl cache map", 2, tree.aclCacheSize());    assertEquals("expected to have the same acl", ZooDefs.Ids.OPEN_ACL_UNSAFE, tree.getACL("/bug", new Stat()));}
testCachedApproximateDataSize
public void zookeeper_f4581_0() throws Exception
{    DataTree dt = new DataTree();    long initialSize = dt.approximateDataSize();    assertEquals(dt.cachedApproximateDataSize(), dt.approximateDataSize());        dt.createNode("/testApproximateDataSize", new byte[20], null, -1, 1, 1, 1);    dt.createNode("/testApproximateDataSize1", new byte[20], null, -1, 1, 1, 1);    assertEquals(dt.cachedApproximateDataSize(), dt.approximateDataSize());        dt.setData("/testApproximateDataSize1", new byte[32], -1, 1, 1);    assertEquals(dt.cachedApproximateDataSize(), dt.approximateDataSize());        dt.deleteNode("/testApproximateDataSize", -1);    assertEquals(dt.cachedApproximateDataSize(), dt.approximateDataSize());}
testGetAllChildrenNumber
public void zookeeper_f4582_0() throws Exception
{    DataTree dt = new DataTree();        dt.createNode("/all_children_test", new byte[20], null, -1, 1, 1, 1);    dt.createNode("/all_children_test/nodes", new byte[20], null, -1, 1, 1, 1);    dt.createNode("/all_children_test/nodes/node1", new byte[20], null, -1, 1, 1, 1);    dt.createNode("/all_children_test/nodes/node2", new byte[20], null, -1, 1, 1, 1);    dt.createNode("/all_children_test/nodes/node3", new byte[20], null, -1, 1, 1, 1);    assertEquals(4, dt.getAllChildrenNumber("/all_children_test"));    assertEquals(3, dt.getAllChildrenNumber("/all_children_test/nodes"));    assertEquals(0, dt.getAllChildrenNumber("/all_children_test/nodes/node1"));        assertEquals(8, dt.getAllChildrenNumber("/"));}
testDataTreeMetrics
public void zookeeper_f4583_0() throws Exception
{    ServerMetrics.getMetrics().resetAll();    long readBytes1 = 0;    long readBytes2 = 0;    long writeBytes1 = 0;    long writeBytes2 = 0;    final String TOP1 = "top1";    final String TOP2 = "ttop2";    final String TOP1PATH = "/" + TOP1;    final String TOP2PATH = "/" + TOP2;    final String CHILD1 = "child1";    final String CHILD2 = "springishere";    final String CHILD1PATH = TOP1PATH + "/" + CHILD1;    final String CHILD2PATH = TOP1PATH + "/" + CHILD2;    final int TOP2_LEN = 50;    final int CHILD1_LEN = 100;    final int CHILD2_LEN = 250;    DataTree dt = new DataTree();    dt.createNode(TOP1PATH, null, null, -1, 1, 1, 1);    writeBytes1 += TOP1PATH.length();    dt.createNode(TOP2PATH, new byte[TOP2_LEN], null, -1, 1, 1, 1);    writeBytes2 += TOP2PATH.length() + TOP2_LEN;    dt.createNode(CHILD1PATH, null, null, -1, 1, 1, 1);    writeBytes1 += CHILD1PATH.length();    dt.setData(CHILD1PATH, new byte[CHILD1_LEN], 1, -1, 1);    writeBytes1 += CHILD1PATH.length() + CHILD1_LEN;    dt.createNode(CHILD2PATH, new byte[CHILD2_LEN], null, -1, 1, 1, 1);    writeBytes1 += CHILD2PATH.length() + CHILD2_LEN;    dt.getData(TOP1PATH, new Stat(), null);    readBytes1 += TOP1PATH.length() + DataTree.STAT_OVERHEAD_BYTES;    dt.getData(TOP2PATH, new Stat(), null);    readBytes2 += TOP2PATH.length() + TOP2_LEN + DataTree.STAT_OVERHEAD_BYTES;    dt.statNode(CHILD2PATH, null);    readBytes1 += CHILD2PATH.length() + DataTree.STAT_OVERHEAD_BYTES;    dt.getChildren(TOP1PATH, new Stat(), null);    readBytes1 += TOP1PATH.length() + CHILD1.length() + CHILD2.length() + DataTree.STAT_OVERHEAD_BYTES;    dt.deleteNode(TOP1PATH, 1);    writeBytes1 += TOP1PATH.length();    Map<String, Object> values = MetricsUtils.currentServerMetrics();    System.out.println("values:" + values);    assertEquals(writeBytes1, values.get("sum_" + TOP1 + "_write_per_namespace"));    assertEquals(5L, values.get("cnt_" + TOP1 + "_write_per_namespace"));    assertEquals(writeBytes2, values.get("sum_" + TOP2 + "_write_per_namespace"));    assertEquals(1L, values.get("cnt_" + TOP2 + "_write_per_namespace"));    assertEquals(readBytes1, values.get("sum_" + TOP1 + "_read_per_namespace"));    assertEquals(3L, values.get("cnt_" + TOP1 + "_read_per_namespace"));    assertEquals(readBytes2, values.get("sum_" + TOP2 + "_read_per_namespace"));    assertEquals(1L, values.get("cnt_" + TOP2 + "_read_per_namespace"));}
testDigest
public void zookeeper_f4584_0() throws Exception
{    try {                ZooKeeperServer.setDigestEnabled(true);        DataTree dt = new DataTree();                long previousDigest = dt.getTreeDigest();        dt.createNode("/digesttest", new byte[0], null, -1, 1, 1, 1);        assertNotEquals(dt.getTreeDigest(), previousDigest);                previousDigest = dt.getTreeDigest();        dt.createNode("/digesttest/1", "1".getBytes(), null, -1, 2, 2, 2);        assertNotEquals(dt.getTreeDigest(), previousDigest);                previousDigest = dt.getTreeDigest();        try {            dt.createNode("/digesttest/1", "1".getBytes(), null, -1, 2, 2, 2);        } catch (NodeExistsException e) {        /* ignore */        }        assertEquals(dt.getTreeDigest(), previousDigest);                previousDigest = dt.getTreeDigest();        dt.setData("/digesttest/1", "2".getBytes(), 3, 3, 3);        assertNotEquals(dt.getTreeDigest(), previousDigest);                previousDigest = dt.getTreeDigest();        dt.deleteNode("/digesttest/1", 5);        assertNotEquals(dt.getTreeDigest(), previousDigest);    } finally {        ZooKeeperServer.setDigestEnabled(false);    }}
deserializeTree
private static voidf4585_1int depth, int width, int len) throws InterruptedException, IOException, KeeperException.NodeExistsException, KeeperException.NoNodeException
{    BinaryInputArchive ia;    int count;    {        DataTree tree = new DataTree();        SerializationPerfTest.createNodes(tree, "/", depth, width, tree.getNode("/").stat.getCversion(), new byte[len]);        count = tree.getNodeCount();        ByteArrayOutputStream baos = new ByteArrayOutputStream();        BinaryOutputArchive oa = BinaryOutputArchive.getArchive(baos);        tree.serialize(oa, "test");        baos.flush();        ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());        ia = BinaryInputArchive.getArchive(bais);    }    DataTree dserTree = new DataTree();    System.gc();    long start = System.nanoTime();    dserTree.deserialize(ia, "test");    long end = System.nanoTime();    long durationms = (end - start) / 1000000L;    long pernodeus = ((end - start) / 1000L) / count;    assertEquals(count, dserTree.getNodeCount());    }
testSingleDeserialize
public void zookeeper_f4586_0() throws InterruptedException, IOException, KeeperException.NodeExistsException, KeeperException.NoNodeException
{    deserializeTree(1, 0, 20);}
testWideDeserialize
public void zookeeper_f4587_0() throws InterruptedException, IOException, KeeperException.NodeExistsException, KeeperException.NoNodeException
{    deserializeTree(2, 10000, 20);}
testDeepDeserialize
public void zookeeper_f4588_0() throws InterruptedException, IOException, KeeperException.NodeExistsException, KeeperException.NoNodeException
{    deserializeTree(400, 1, 20);}
test10Wide5DeepDeserialize
public void zookeeper_f4589_0() throws InterruptedException, IOException, KeeperException.NodeExistsException, KeeperException.NoNodeException
{    deserializeTree(5, 10, 20);}
test15Wide5DeepDeserialize
public void zookeeper_f4590_0() throws InterruptedException, IOException, KeeperException.NodeExistsException, KeeperException.NoNodeException
{    deserializeTree(5, 15, 20);}
test25Wide4DeepDeserialize
public void zookeeper_f4591_0() throws InterruptedException, IOException, KeeperException.NodeExistsException, KeeperException.NoNodeException
{    deserializeTree(4, 25, 20);}
test40Wide4DeepDeserialize
public void zookeeper_f4592_0() throws InterruptedException, IOException, KeeperException.NodeExistsException, KeeperException.NoNodeException
{    deserializeTree(4, 40, 20);}
test300Wide3DeepDeserialize
public void zookeeper_f4593_0() throws InterruptedException, IOException, KeeperException.NodeExistsException, KeeperException.NoNodeException
{    deserializeTree(3, 300, 20);}
setUp
public void zookeeper_f4594_0() throws Exception
{    System.setProperty(EphemeralType.EXTENDED_TYPES_ENABLED_PROPERTY, "true");    System.setProperty(EphemeralType.TTL_3_5_3_EMULATION_PROPERTY, "true");    super.setUp();    zk = createClient();}
tearDown
public void zookeeper_f4595_0() throws Exception
{    System.clearProperty(EphemeralType.EXTENDED_TYPES_ENABLED_PROPERTY);    System.clearProperty(EphemeralType.TTL_3_5_3_EMULATION_PROPERTY);    super.tearDown();    zk.close();}
testCreate
public void zookeeper_f4596_0() throws KeeperException, InterruptedException
{    Stat stat = new Stat();    zk.create("/foo", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_WITH_TTL, stat, 100);    assertEquals(0, stat.getEphemeralOwner());    final AtomicLong fakeElapsed = new AtomicLong(0);    ContainerManager containerManager = newContainerManager(fakeElapsed);    containerManager.checkContainers();    assertNotNull("Ttl node should not have been deleted yet", zk.exists("/foo", false));    fakeElapsed.set(1000);    containerManager.checkContainers();    assertNull("Ttl node should have been deleted", zk.exists("/foo", false));}
test353TTL
public void zookeeper_f4597_0() throws KeeperException, InterruptedException
{    DataTree dataTree = serverFactory.zkServer.getZKDatabase().dataTree;    long ephemeralOwner = EphemeralTypeEmulate353.ttlToEphemeralOwner(100);    dataTree.createNode("/foo", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, ephemeralOwner, dataTree.getNode("/").stat.getCversion() + 1, 1, 1);    final AtomicLong fakeElapsed = new AtomicLong(0);    ContainerManager containerManager = newContainerManager(fakeElapsed);    containerManager.checkContainers();    assertNotNull("Ttl node should not have been deleted yet", zk.exists("/foo", false));    fakeElapsed.set(1000);    containerManager.checkContainers();    assertNull("Ttl node should have been deleted", zk.exists("/foo", false));}
testEphemeralOwner_emulationTTL
public void zookeeper_f4598_0()
{    assertThat(EphemeralType.get(-1), equalTo(EphemeralType.TTL));}
testEphemeralOwner_emulationContainer
public void zookeeper_f4599_0()
{    assertThat(EphemeralType.get(EphemeralType.CONTAINER_EPHEMERAL_OWNER), equalTo(EphemeralType.CONTAINER));}
newContainerManager
private ContainerManager zookeeper_f4600_0(final AtomicLong fakeElapsed)
{    return new ContainerManager(serverFactory.getZooKeeperServer().getZKDatabase(), serverFactory.getZooKeeperServer().firstProcessor, 1, 100) {        @Override        protected long getElapsed(DataNode node) {            return fakeElapsed.get();        }    };}
getElapsed
protected long zookeeper_f4601_0(DataNode node)
{    return fakeElapsed.get();}
setUp
public void zookeeper_f4602_0()
{    System.setProperty(EphemeralType.EXTENDED_TYPES_ENABLED_PROPERTY, "true");}
tearDown
public void zookeeper_f4603_0()
{    System.clearProperty(EphemeralType.EXTENDED_TYPES_ENABLED_PROPERTY);}
testTtls
public void zookeeper_f4604_0()
{    long[] ttls = { 100, 1, EphemeralType.TTL.maxValue() };    for (long ttl : ttls) {        long ephemeralOwner = EphemeralType.TTL.toEphemeralOwner(ttl);        assertEquals(EphemeralType.TTL, EphemeralType.get(ephemeralOwner));        assertEquals(ttl, EphemeralType.TTL.getValue(ephemeralOwner));    }    EphemeralType.validateTTL(CreateMode.PERSISTENT_WITH_TTL, 100);    EphemeralType.validateTTL(CreateMode.PERSISTENT_SEQUENTIAL_WITH_TTL, 100);    try {        EphemeralType.validateTTL(CreateMode.EPHEMERAL, 100);        fail("Should have thrown IllegalArgumentException");    } catch (IllegalArgumentException dummy) {        }}
testContainerValue
public void zookeeper_f4605_0()
{    assertEquals(Long.MIN_VALUE, EphemeralType.CONTAINER_EPHEMERAL_OWNER);    assertEquals(EphemeralType.CONTAINER, EphemeralType.get(EphemeralType.CONTAINER_EPHEMERAL_OWNER));}
testNonSpecial
public void zookeeper_f4606_0()
{    assertEquals(EphemeralType.VOID, EphemeralType.get(0));    assertEquals(EphemeralType.NORMAL, EphemeralType.get(1));    assertEquals(EphemeralType.NORMAL, EphemeralType.get(Long.MAX_VALUE));}
testServerIds
public void zookeeper_f4607_0()
{    for (int i = 0; i <= EphemeralType.MAX_EXTENDED_SERVER_ID; ++i) {        EphemeralType.validateServerId(i);    }    try {        EphemeralType.validateServerId(EphemeralType.MAX_EXTENDED_SERVER_ID + 1);        fail("Should have thrown RuntimeException");    } catch (RuntimeException e) {        }}
testEphemeralOwner_extendedFeature_TTL
public void zookeeper_f4608_0()
{            assertThat(EphemeralType.get(0xff00000000000000L), equalTo(EphemeralType.TTL));}
testEphemeralOwner_extendedFeature_extendedTypeUnsupported
public void zookeeper_f4609_0()
{            EphemeralType.get(0xff00010000000000L);}
setUp
public void zookeeper_f4610_0() throws KeeperException.NoNodeException, IOException
{    testACLs.clear();    testACLs.addAll(Arrays.asList(new ACL(ZooDefs.Perms.ALL, new Id("digest", "user:secrethash")), new ACL(ZooDefs.Perms.ADMIN, new Id("digest", "adminuser:adminsecret")), new ACL(ZooDefs.Perms.READ, new Id("world", "anyone"))));    ZooKeeperServer zks = new ZooKeeperServer();    ZKDatabase db = mock(ZKDatabase.class);    String testPath = "/testPath";    when(db.getNode(eq(testPath))).thenReturn(new DataNode());    when(db.getACL(eq(testPath), any(Stat.class))).thenReturn(testACLs);    when(db.aclForNode(any(DataNode.class))).thenReturn(testACLs);    zks.setZKDatabase(db);    processor = new FinalRequestProcessor(zks);    cnxn = mock(ServerCnxn.class);    doAnswer(new Answer() {        @Override        public Object answer(InvocationOnMock invocationOnMock) {            replyHeaders[0] = invocationOnMock.getArgument(0);            responseRecord[0] = invocationOnMock.getArgument(1);            return null;        }    }).when(cnxn).sendResponse(any(), any(), anyString());    GetACLRequest getACLRequest = new GetACLRequest();    getACLRequest.setPath(testPath);    ByteArrayOutputStream baos = new ByteArrayOutputStream();    BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos);    getACLRequest.serialize(boa, "request");    baos.close();    bb = ByteBuffer.wrap(baos.toByteArray());}
answer
public Object zookeeper_f4611_0(InvocationOnMock invocationOnMock)
{    replyHeaders[0] = invocationOnMock.getArgument(0);    responseRecord[0] = invocationOnMock.getArgument(1);    return null;}
testACLDigestHashHiding_NoAuth_WorldCanRead
public void zookeeper_f4612_0()
{            Request r = new Request(cnxn, 0, 0, ZooDefs.OpCode.getACL, bb, new ArrayList<Id>());    processor.processRequest(r);        assertMasked(true);}
testACLDigestHashHiding_NoAuth_NoWorld
public void zookeeper_f4613_0()
{        testACLs.remove(2);        Request r = new Request(cnxn, 0, 0, ZooDefs.OpCode.getACL, bb, new ArrayList<Id>());    processor.processRequest(r);        assertThat(KeeperException.Code.get(replyHeaders[0].getErr()), equalTo(KeeperException.Code.NOAUTH));}
testACLDigestHashHiding_UserCanRead
public void zookeeper_f4614_0()
{        List<Id> authInfo = new ArrayList<Id>();    authInfo.add(new Id("digest", "otheruser:somesecrethash"));        Request r = new Request(cnxn, 0, 0, ZooDefs.OpCode.getACL, bb, authInfo);    processor.processRequest(r);        assertMasked(true);}
testACLDigestHashHiding_UserCanAll
public void zookeeper_f4615_0()
{        List<Id> authInfo = new ArrayList<Id>();    authInfo.add(new Id("digest", "user:secrethash"));        Request r = new Request(cnxn, 0, 0, ZooDefs.OpCode.getACL, bb, authInfo);    processor.processRequest(r);        assertMasked(false);}
testACLDigestHashHiding_AdminUser
public void zookeeper_f4616_0()
{        List<Id> authInfo = new ArrayList<Id>();    authInfo.add(new Id("digest", "adminuser:adminsecret"));        Request r = new Request(cnxn, 0, 0, ZooDefs.OpCode.getACL, bb, authInfo);    processor.processRequest(r);        assertMasked(false);}
testACLDigestHashHiding_OnlyAdmin
public void zookeeper_f4617_0()
{        testACLs.clear();    testACLs.addAll(Arrays.asList(new ACL(ZooDefs.Perms.READ, new Id("digest", "user:secrethash")), new ACL(ZooDefs.Perms.ADMIN, new Id("digest", "adminuser:adminsecret"))));    List<Id> authInfo = new ArrayList<Id>();    authInfo.add(new Id("digest", "adminuser:adminsecret"));        Request r = new Request(cnxn, 0, 0, ZooDefs.OpCode.getACL, bb, authInfo);    processor.processRequest(r);        assertTrue("Not a GetACL response. Auth failed?", responseRecord[0] instanceof GetACLResponse);    GetACLResponse rsp = (GetACLResponse) responseRecord[0];    assertThat("Number of ACLs in the response are different", rsp.getAcl().size(), equalTo(2));        assertThat("Password hash mismatch in the response", rsp.getAcl().get(0).getId().getId(), equalTo("user:secrethash"));    assertThat("Password hash mismatch in the response", rsp.getAcl().get(1).getId().getId(), equalTo("adminuser:adminsecret"));}
assertMasked
private void zookeeper_f4618_0(boolean masked)
{    assertTrue("Not a GetACL response. Auth failed?", responseRecord[0] instanceof GetACLResponse);    GetACLResponse rsp = (GetACLResponse) responseRecord[0];    assertThat("Number of ACLs in the response are different", rsp.getAcl().size(), equalTo(3));        assertThat("Invalid ACL list in the response", rsp.getAcl().get(0).getPerms(), equalTo(ZooDefs.Perms.ALL));    assertThat("Invalid ACL list in the response", rsp.getAcl().get(0).getId().getScheme(), equalTo("digest"));    if (masked) {        assertThat("Password hash is not masked in the response", rsp.getAcl().get(0).getId().getId(), equalTo("user:x"));    } else {        assertThat("Password hash mismatch in the response", rsp.getAcl().get(0).getId().getId(), equalTo("user:secrethash"));    }    assertThat("Invalid ACL list in the response", rsp.getAcl().get(1).getPerms(), equalTo(ZooDefs.Perms.ADMIN));    assertThat("Invalid ACL list in the response", rsp.getAcl().get(1).getId().getScheme(), equalTo("digest"));    if (masked) {        assertThat("Password hash is not masked in the response", rsp.getAcl().get(1).getId().getId(), equalTo("adminuser:x"));    } else {        assertThat("Password hash mismatch in the response", rsp.getAcl().get(1).getId().getId(), equalTo("adminuser:adminsecret"));    }    assertThat("Invalid ACL list in the response", rsp.getAcl().get(2).getPerms(), equalTo(ZooDefs.Perms.READ));    assertThat("Invalid ACL list in the response", rsp.getAcl().get(2).getId().getScheme(), equalTo("world"));    assertThat("Invalid ACL list in the response", rsp.getAcl().get(2).getId().getId(), equalTo("anyone"));        assertThat("Original ACL list has been modified", testACLs.get(0).getPerms(), equalTo(ZooDefs.Perms.ALL));    assertThat("Original ACL list has been modified", testACLs.get(0).getId().getScheme(), equalTo("digest"));    assertThat("Original ACL list has been modified", testACLs.get(0).getId().getId(), equalTo("user:secrethash"));    assertThat("Original ACL list has been modified", testACLs.get(1).getPerms(), equalTo(ZooDefs.Perms.ADMIN));    assertThat("Original ACL list has been modified", testACLs.get(1).getId().getScheme(), equalTo("digest"));    assertThat("Original ACL list has been modified", testACLs.get(1).getId().getId(), equalTo("adminuser:adminsecret"));    assertThat("Original ACL list has been modified", testACLs.get(2).getPerms(), equalTo(ZooDefs.Perms.READ));    assertThat("Original ACL list has been modified", testACLs.get(2).getId().getScheme(), equalTo("world"));    assertThat("Original ACL list has been modified", testACLs.get(2).getId().getId(), equalTo("anyone"));}
run
public voidf4619_1)
{    String[] args = new String[1];    args[0] = confFile.toString();    try {        main.initializeAndRun(args);    } catch (Exception e) {                    }}
shutdown
public void zookeeper_f4620_0()
{    main.shutdown();}
shutdown
public void zookeeper_f4621_0()
{    super.shutdown();}
testInvalidSnapCount
public void zookeeper_f4622_0() throws Exception
{    final int CLIENT_PORT = 3181;    MainThread main = new MainThread(CLIENT_PORT);    main.start();    assertTrue("waiting for server being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT, CONNECTION_TIMEOUT));    assertEquals(SyncRequestProcessor.getSnapCount(), 2);    main.shutdown();}
process
public void zookeeper_f4623_0(WatchedEvent event)
{}
testInvalidSnapshot
public voidf4624_1) throws Exception
{    ZooKeeper zk = createClient();    try {        for (int i = 0; i < 2000; i++) {            zk.create("/invalidsnap-" + i, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        }    } finally {        zk.close();    }    NIOServerCnxnFactory factory = (NIOServerCnxnFactory) serverFactory;    stopServer();        File snapFile = factory.zkServer.getTxnLogFactory().findMostRecentSnapshot();        RandomAccessFile raf = new RandomAccessFile(snapFile, "rws");    raf.setLength(3);    raf.close();        startServer();        zk = createClient();    try {        assertTrue("the node should exist", (zk.exists("/invalidsnap-1999", false) != null));    } finally {        zk.close();    }}
initCounter
public void zookeeper_f4625_0()
{    testCounterSet = new AvgMinMaxCounterSet("test");}
addDataPoints
private void zookeeper_f4626_0()
{    testCounterSet.add("key1", 0);    testCounterSet.add("key1", 1);    testCounterSet.add("key2", 2);    testCounterSet.add("key2", 3);    testCounterSet.add("key2", 4);    testCounterSet.add("key2", 5);}
testReset
public void zookeeper_f4627_0()
{    addDataPoints();    testCounterSet.reset();    Map<String, Object> values = testCounterSet.values();    assertEquals("There should be 10 values in the set", 10, values.size());    assertEquals("avg_key1_test should =0", 0D, values.get("avg_key1_test"));    assertEquals("min_key1_test should =0", 0L, values.get("min_key1_test"));    assertEquals("max_key1_test should =0", 0L, values.get("max_key1_test"));    assertEquals("cnt_key1_test should =0", 0L, values.get("cnt_key1_test"));    assertEquals("sum_key1_test should =0", 0L, values.get("sum_key1_test"));    assertEquals("avg_key2_test should =0", 0D, values.get("avg_key2_test"));    assertEquals("min_key2_test should =0", 0L, values.get("min_key2_test"));    assertEquals("max_key2_test should =0", 0L, values.get("max_key2_test"));    assertEquals("cnt_key2_test should =0", 0L, values.get("cnt_key2_test"));    assertEquals("sum_key2_test should =0", 0L, values.get("sum_key2_test"));}
testValues
public void zookeeper_f4628_0()
{    addDataPoints();    Map<String, Object> values = testCounterSet.values();    assertEquals("There should be 10 values in the set", 10, values.size());    assertEquals("avg_key1_test should =0.5", 0.5D, values.get("avg_key1_test"));    assertEquals("min_key1_test should =0", 0L, values.get("min_key1_test"));    assertEquals("max_key1_test should =1", 1L, values.get("max_key1_test"));    assertEquals("cnt_key1_test should =2", 2L, values.get("cnt_key1_test"));    assertEquals("sum_key1_test should =1", 1L, values.get("sum_key1_test"));    assertEquals("avg_key2_test should =3.5", 3.5, values.get("avg_key2_test"));    assertEquals("min_key2_test should =2", 2L, values.get("min_key2_test"));    assertEquals("max_key2_test should =5", 5L, values.get("max_key2_test"));    assertEquals("cnt_key2_test should =4", 4L, values.get("cnt_key2_test"));    assertEquals("sum_key2_test should =14", 14L, values.get("sum_key2_test"));}
initCounter
public void zookeeper_f4629_0()
{    testCounterSet = new AvgMinMaxPercentileCounterSet("test");}
addDataPoints
private void zookeeper_f4630_0()
{    for (int i = 0; i < 1000; i++) {        testCounterSet.add("key1", i);    }    for (int i = 1000; i < 2000; i++) {        testCounterSet.add("key2", i);    }}
testReset
public void zookeeper_f4631_0()
{    addDataPoints();    testCounterSet.reset();    Map<String, Object> values = testCounterSet.values();    assertEquals("avg_key1_test should =0", 0D, values.get("avg_key1_test"));    assertEquals("min_key1_test should =0", 0L, values.get("min_key1_test"));    assertEquals("max_key1_test should =0", 0L, values.get("max_key1_test"));    assertEquals("cnt_key1_test should =0", 0L, values.get("cnt_key1_test"));    assertEquals("sum_key1_test should =0", 0L, values.get("sum_key1_test"));    assertEquals("p50_key1_test should have p50=0", 0L, values.get("p50_key1_test"));    assertEquals("p95_key1_test should have p95=0", 0L, values.get("p95_key1_test"));    assertEquals("p99_key1_test should have p99=0", 0L, values.get("p99_key1_test"));    assertEquals("p999_key1_test should have p999=0", 0L, values.get("p999_key1_test"));    assertEquals("avg_key2_test should =0", 0D, values.get("avg_key2_test"));    assertEquals("min_key2_test should =0", 0L, values.get("min_key2_test"));    assertEquals("max_key2_test should =0", 0L, values.get("max_key2_test"));    assertEquals("cnt_key2_test should =0", 0L, values.get("cnt_key2_test"));    assertEquals("sum_key2_test should =0", 0L, values.get("sum_key2_test"));    assertEquals("p50_key2_test should have p50=0", 0L, values.get("p50_key2_test"));    assertEquals("p95_key2_test should have p95=0", 0L, values.get("p95_key2_test"));    assertEquals("p99_key2_test should have p99=0", 0L, values.get("p99_key2_test"));    assertEquals("p999_key2_test should have p999=0", 0L, values.get("p999_key2_test"));}
testValues
public void zookeeper_f4632_0()
{    addDataPoints();    Map<String, Object> values = testCounterSet.values();    assertEquals("There should be 18 values in the set", 18, values.size());    assertEquals("avg_key1_test should =499.5", 999D / 2, values.get("avg_key1_test"));    assertEquals("min_key1_test should =0", 0L, values.get("min_key1_test"));    assertEquals("max_key1_test should =999", 999L, values.get("max_key1_test"));    assertEquals("cnt_key1_test should =1000", 1000L, values.get("cnt_key1_test"));    assertEquals("sum_key1_test should =999*500", 999 * 500L, values.get("sum_key1_test"));    assertEquals("p50_key1_test should have p50=500", 500L, values.get("p50_key1_test"));    assertEquals("p95_key1_test should have p95=950", 950L, values.get("p95_key1_test"));    assertEquals("p99_key1_test should have p99=990", 990L, values.get("p99_key1_test"));    assertEquals("p999_key1_test should have p999=999", 999L, values.get("p999_key1_test"));    assertEquals("avg_key2_test should =3.5", 1000 + 999D / 2, values.get("avg_key2_test"));    assertEquals("min_key2_test should =2", 1000L, values.get("min_key2_test"));    assertEquals("max_key2_test should =5", 1999L, values.get("max_key2_test"));    assertEquals("cnt_key2_test should =4", 1000L, values.get("cnt_key2_test"));    assertEquals("sum_key2_test should =14", 2999 * 500L, values.get("sum_key2_test"));    assertEquals("p50_key2_test should have p50=1500", 1500L, values.get("p50_key2_test"));    assertEquals("p95_key2_test should have p95=1950", 1950L, values.get("p95_key2_test"));    assertEquals("p99_key2_test should have p99=1990", 1990L, values.get("p99_key2_test"));    assertEquals("p999_key2_test should have p999=1999", 1999L, values.get("p999_key2_test"));}
initCounter
public void zookeeper_f4633_0()
{    testCounter = new AvgMinMaxPercentileCounter("test");}
addDataPoints
private void zookeeper_f4634_0()
{    for (int i = 0; i < 1000; i++) {        testCounter.add(i);    }}
testReset
public void zookeeper_f4635_0()
{    addDataPoints();    testCounter.reset();    Map<String, Object> values = testCounter.values();    assertEquals("There should be 9 values in the set", 9, values.size());    assertEquals("should avg=0", 0D, values.get("avg_test"));    assertEquals("should have min=0", 0L, values.get("min_test"));    assertEquals("should have max=0", 0L, values.get("max_test"));    assertEquals("should have cnt=0", 0L, values.get("cnt_test"));    assertEquals("should have sum=0", 0L, values.get("sum_test"));    assertEquals("should have p50=0", 0L, values.get("p50_test"));    assertEquals("should have p95=0", 0L, values.get("p95_test"));    assertEquals("should have p99=0", 0L, values.get("p99_test"));    assertEquals("should have p999=0", 0L, values.get("p999_test"));}
testValues
public void zookeeper_f4636_0()
{    addDataPoints();    Map<String, Object> values = testCounter.values();    assertEquals("There should be 9 values in the set", 9, values.size());    assertEquals("should avg=499.5", 999D / 2, values.get("avg_test"));    assertEquals("should have min=0", 0L, values.get("min_test"));    assertEquals("should have max=999", 999L, values.get("max_test"));    assertEquals("should have cnt=1000", 1000L, values.get("cnt_test"));    assertEquals("should have sum=999*500", 999 * 500L, values.get("sum_test"));    assertEquals("should have p50=500", 500L, values.get("p50_test"));    assertEquals("should have p95=950", 950L, values.get("p95_test"));    assertEquals("should have p99=990", 990L, values.get("p99_test"));    assertEquals("should have p999=999", 999L, values.get("p999_test"));}
doIO
public void zookeeper_f4637_0(SelectionKey k) throws InterruptedException
{    super.doIO(k);}
isSocketOpen
protected boolean zookeeper_f4638_0()
{    return true;}
addInterestOpsUpdateRequest
public boolean zookeeper_f4639_0(SelectionKey sk)
{    return super.addInterestOpsUpdateRequest(sk);}
getSessionTimeout
 int zookeeper_f4640_0()
{    return 0;}
close
public void zookeeper_f4641_0(DisconnectReason reason)
{}
sendResponse
public void zookeeper_f4642_0(ReplyHeader h, Record r, String tag, String cacheKey, Stat stat) throws IOException
{}
sendCloseSession
public void zookeeper_f4643_0()
{}
process
public void zookeeper_f4644_0(WatchedEvent event)
{}
getSessionId
public long zookeeper_f4645_0()
{    return 0;}
setSessionId
 void zookeeper_f4646_0(long sessionId)
{}
isSecure
public boolean zookeeper_f4647_0()
{    return secure;}
getClientCertificateChain
public Certificate[] zookeeper_f4648_0()
{    return clientChain;}
setClientCertificateChain
public void zookeeper_f4649_0(Certificate[] chain)
{    clientChain = chain;}
sendBuffer
 void zookeeper_f4650_0(ByteBuffer... closeConn)
{}
enableRecv
 void zookeeper_f4651_0()
{}
disableRecv
 void zookeeper_f4652_0(boolean waitDisableRecv)
{}
setSessionTimeout
 void zookeeper_f4653_0(int sessionTimeout)
{}
serverStats
protected ServerStats zookeeper_f4654_0()
{    return null;}
getOutstandingRequests
public long zookeeper_f4655_0()
{    return 0;}
getRemoteSocketAddress
public InetSocketAddress zookeeper_f4656_0()
{    return null;}
getInterestOps
public int zookeeper_f4657_0()
{    return 0;}
setUp
public void zookeeper_f4658_0() throws Exception
{    localSessionsEnabled = true;    localSessionsUpgradingEnabled = true;    super.setUp();}
ephemeralCreateMultiOpTest
public void zookeeper_f4659_0() throws KeeperException, InterruptedException, IOException
{    final ZooKeeper zk = createClient();    String data = "test";    String path = "/ephemeralcreatemultiop";    zk.create(path, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    QuorumZooKeeperServer server = getConnectedServer(zk.getSessionId());    assertNotNull("unable to find server interlocutor", server);    UpgradeableSessionTracker sessionTracker = (UpgradeableSessionTracker) server.getSessionTracker();    assertFalse("session already global", sessionTracker.isGlobalSession(zk.getSessionId()));    List<OpResult> multi = null;    try {        multi = zk.multi(Arrays.asList(Op.setData(path, data.getBytes(), 0), Op.create(path + "/e", data.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL), Op.create(path + "/p", data.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT), Op.create(path + "/q", data.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL)));    } catch (KeeperException.SessionExpiredException e) {                fail("received session expired for a session promotion in a multi-op");    }    assertNotNull(multi);    assertEquals(4, multi.size());    assertEquals(data, new String(zk.getData(path + "/e", false, null)));    assertEquals(data, new String(zk.getData(path + "/p", false, null)));    assertEquals(data, new String(zk.getData(path + "/q", false, null)));    assertTrue("session not promoted", sessionTracker.isGlobalSession(zk.getSessionId()));}
directCheckUpgradeSessionTest
public void zookeeper_f4660_0() throws IOException, InterruptedException, KeeperException
{    final ZooKeeper zk = createClient();    String path = "/directcheckupgradesession";    zk.create(path, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    QuorumZooKeeperServer server = getConnectedServer(zk.getSessionId());    assertNotNull("unable to find server interlocutor", server);    Request readRequest = makeGetDataRequest(path, zk.getSessionId());    Request createRequest = makeCreateRequest(path + "/e", zk.getSessionId());    assertNull("tried to upgrade on a read", server.checkUpgradeSession(readRequest));    assertNotNull("failed to upgrade on a create", server.checkUpgradeSession(createRequest));    assertNull("tried to upgrade after successful promotion", server.checkUpgradeSession(createRequest));}
makeGetDataRequest
private Request zookeeper_f4661_0(String path, long sessionId) throws IOException
{    ByteArrayOutputStream boas = new ByteArrayOutputStream();    BinaryOutputArchive boa = BinaryOutputArchive.getArchive(boas);    GetDataRequest getDataRequest = new GetDataRequest(path, false);    getDataRequest.serialize(boa, "request");    ByteBuffer bb = ByteBuffer.wrap(boas.toByteArray());    return new Request(null, sessionId, 1, ZooDefs.OpCode.getData, bb, new ArrayList<Id>());}
makeCreateRequest
private Request zookeeper_f4662_0(String path, long sessionId) throws IOException
{    ByteArrayOutputStream boas = new ByteArrayOutputStream();    BinaryOutputArchive boa = BinaryOutputArchive.getArchive(boas);    CreateRequest createRequest = new CreateRequest(path, "data".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL.toFlag());    createRequest.serialize(boa, "request");    ByteBuffer bb = ByteBuffer.wrap(boas.toByteArray());    return new Request(null, sessionId, 1, ZooDefs.OpCode.create2, bb, new ArrayList<Id>());}
getConnectedServer
private QuorumZooKeeperServer zookeeper_f4663_0(long sessionId)
{    for (QuorumPeer peer : getPeerList()) {        if (peer.getActiveServer().getSessionTracker().isTrackingSession(sessionId)) {            return (QuorumZooKeeperServer) peer.getActiveServer();        }    }    return null;}
testRebind
public void zookeeper_f4664_0() throws Exception
{    InetSocketAddress addr = new InetSocketAddress(PortAssignment.unique());    NettyServerCnxnFactory factory = new NettyServerCnxnFactory();    factory.configure(addr, 100, -1, false);    factory.start();    Assert.assertTrue(factory.getParentChannel().isActive());    factory.reconfigure(addr);        Thread.sleep(100);    Assert.assertTrue(factory.getParentChannel().isActive());}
testRebindIPv4IPv6
public void zookeeper_f4665_0() throws Exception
{    int randomPort = PortAssignment.unique();    InetSocketAddress addr = new InetSocketAddress("0.0.0.0", randomPort);    NettyServerCnxnFactory factory = new NettyServerCnxnFactory();    factory.configure(addr, 100, -1, false);    factory.start();    Assert.assertTrue(factory.getParentChannel().isActive());    factory.reconfigure(new InetSocketAddress("[0:0:0:0:0:0:0:0]", randomPort));        Thread.sleep(100);    Assert.assertTrue(factory.getParentChannel().isActive());}
setUp
public void zookeeper_f4666_0() throws Exception
{    System.setProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY, "org.apache.zookeeper.server.NettyServerCnxnFactory");    NettyServerCnxnFactory.setTestAllocator(TestByteBufAllocator.getInstance());    super.maxCnxns = 1;    super.exceptionOnFailedConnect = true;    super.setUp();}
tearDown
public void zookeeper_f4667_0() throws Exception
{    super.tearDown();    NettyServerCnxnFactory.clearTestAllocator();    TestByteBufAllocator.checkForLeaks();}
testSendCloseSession
public voidf4668_1) throws Exception
{    assertTrue("Didn't instantiate ServerCnxnFactory with NettyServerCnxnFactory!", serverFactory instanceof NettyServerCnxnFactory);    final ZooKeeper zk = createClient();    final ZooKeeperServer zkServer = serverFactory.getZooKeeperServer();    final String path = "/a";    try {                zk.create(path, "test".getBytes(StandardCharsets.UTF_8), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);                assertNotNull("Didn't create znode:" + path, zk.exists(path, true));        assertEquals(1, zkServer.getZKDatabase().getDataTree().getWatchCount());        Iterable<ServerCnxn> connections = serverFactory.getConnections();        assertEquals("Mismatch in number of live connections!", 1, serverFactory.getNumAliveConnections());        for (ServerCnxn serverCnxn : connections) {            serverCnxn.sendCloseSession();        }                int timeout = 0;        while (serverFactory.getNumAliveConnections() != 0) {            Thread.sleep(1000);            timeout += 1000;            if (timeout > CONNECTION_TIMEOUT) {                fail("The number of live connections should be 0");            }        }                assertEquals(0, zkServer.getZKDatabase().getDataTree().getWatchCount());    } finally {        zk.close();    }}
testMaxConnectionPerIpSurpased
public void zookeeper_f4669_0() throws Exception
{    assertTrue("Did not instantiate ServerCnxnFactory with NettyServerCnxnFactory!", serverFactory instanceof NettyServerCnxnFactory);    try (final ZooKeeper zk1 = createClient();        final ZooKeeper zk2 = createClient()) {    }}
testClientResponseStatsUpdate
public void zookeeper_f4670_0() throws IOException, InterruptedException, KeeperException
{    try (ZooKeeper zk = createClient()) {        BufferStats clientResponseStats = serverFactory.getZooKeeperServer().serverStats().getClientResponseStats();        assertThat("Last client response size should be initialized with INIT_VALUE", clientResponseStats.getLastBufferSize(), equalTo(BufferStats.INIT_VALUE));        zk.create("/a", "test".getBytes(StandardCharsets.UTF_8), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        assertThat("Last client response size should be greater than 0 after client request was performed", clientResponseStats.getLastBufferSize(), greaterThan(0));        byte[] contents = zk.getData("/a", null, null);        assertArrayEquals("unexpected data", "test".getBytes(StandardCharsets.UTF_8), contents);    }}
testServerSideThrottling
public void zookeeper_f4671_0() throws IOException, InterruptedException, KeeperException
{    try (ZooKeeper zk = createClient()) {        BufferStats clientResponseStats = serverFactory.getZooKeeperServer().serverStats().getClientResponseStats();        assertThat("Last client response size should be initialized with INIT_VALUE", clientResponseStats.getLastBufferSize(), equalTo(BufferStats.INIT_VALUE));        zk.create("/a", "test".getBytes(StandardCharsets.UTF_8), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        assertThat("Last client response size should be greater than 0 after client request was performed", clientResponseStats.getLastBufferSize(), greaterThan(0));        for (final ServerCnxn cnxn : serverFactory.cnxns) {            final NettyServerCnxn nettyCnxn = ((NettyServerCnxn) cnxn);                        nettyCnxn.disableRecv();                        nettyCnxn.getChannel().eventLoop().schedule(new Runnable() {                @Override                public void run() {                    nettyCnxn.getChannel().read();                }            }, 1, TimeUnit.SECONDS);                        nettyCnxn.getChannel().eventLoop().schedule(new Runnable() {                @Override                public void run() {                    nettyCnxn.enableRecv();                }            }, 2, TimeUnit.SECONDS);        }        byte[] contents = zk.getData("/a", null, null);        assertArrayEquals("unexpected data", "test".getBytes(StandardCharsets.UTF_8), contents);                for (final ServerCnxn cnxn : serverFactory.cnxns) {            final NettyServerCnxn nettyCnxn = ((NettyServerCnxn) cnxn);                        nettyCnxn.disableRecv();                        nettyCnxn.getChannel().eventLoop().schedule(new Runnable() {                @Override                public void run() {                    nettyCnxn.enableRecv();                }            }, 2, TimeUnit.SECONDS);        }        contents = zk.getData("/a", null, null);        assertArrayEquals("unexpected data", "test".getBytes(StandardCharsets.UTF_8), contents);    }}
run
public void zookeeper_f4672_0()
{    nettyCnxn.getChannel().read();}
run
public void zookeeper_f4673_0()
{    nettyCnxn.enableRecv();}
run
public void zookeeper_f4674_0()
{    nettyCnxn.enableRecv();}
testEnableDisableThrottling_secure_random
public void zookeeper_f4675_0() throws Exception
{    runEnableDisableThrottling(true, true);}
testEnableDisableThrottling_secure_sequentially
public void zookeeper_f4676_0() throws Exception
{    runEnableDisableThrottling(true, false);}
testEnableDisableThrottling_nonSecure_random
public void zookeeper_f4677_0() throws Exception
{    runEnableDisableThrottling(false, true);}
testEnableDisableThrottling_nonSecure_sequentially
public void zookeeper_f4678_0() throws Exception
{    runEnableDisableThrottling(false, false);}
runEnableDisableThrottling
private voidf4679_1boolean secure, boolean randomDisableEnable) throws Exception
{    ClientX509Util x509Util = null;    if (secure) {        x509Util = SSLAuthTest.setUpSecure();    }    try {        NettyServerCnxnFactory factory = (NettyServerCnxnFactory) serverFactory;        factory.setAdvancedFlowControlEnabled(true);        if (secure) {            factory.setSecure(true);        }        final String path = "/testEnableDisableThrottling";        try (ZooKeeper zk = createClient()) {            zk.create(path, new byte[1], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);                        AtomicBoolean stopped = new AtomicBoolean(false);            Random random = new Random();            Thread enableDisableThread = null;            if (randomDisableEnable) {                enableDisableThread = new Thread() {                    @Override                    public void run() {                        while (!stopped.get()) {                            for (final ServerCnxn cnxn : serverFactory.cnxns) {                                boolean shouldDisableEnable = random.nextBoolean();                                if (shouldDisableEnable) {                                    cnxn.disableRecv();                                } else {                                    cnxn.enableRecv();                                }                            }                            try {                                Thread.sleep(10);                            } catch (InterruptedException e) {                            /* ignore */                            }                        }                                                for (final ServerCnxn cnxn : serverFactory.cnxns) {                            cnxn.enableRecv();                        }                    }                };            } else {                enableDisableThread = new Thread() {                    @Override                    public void run() {                        while (!stopped.get()) {                            for (final ServerCnxn cnxn : serverFactory.cnxns) {                                try {                                    cnxn.disableRecv();                                    Thread.sleep(10);                                    cnxn.enableRecv();                                    Thread.sleep(10);                                } catch (InterruptedException e) {                                /* ignore */                                }                            }                        }                    }                };            }            enableDisableThread.start();                                    int totalRequestsNum = 100000;            AtomicInteger successResponse = new AtomicInteger();            CountDownLatch responseReceivedLatch = new CountDownLatch(totalRequestsNum);            Thread clientThread = new Thread() {                @Override                public void run() {                    int requestIssued = 0;                    while (requestIssued++ < totalRequestsNum) {                        zk.getData(path, null, new DataCallback() {                            @Override                            public void processResult(int rc, String path, Object ctx, byte[] data, Stat stat) {                                if (rc == 0) {                                    successResponse.addAndGet(1);                                } else {                                                                    }                                responseReceivedLatch.countDown();                            }                        }, null);                    }                }            };            clientThread.start();                                    assertTrue(responseReceivedLatch.await(60, TimeUnit.SECONDS));                        stopped.set(true);            enableDisableThread.join();                                                Thread.sleep(1000);            assertEquals(successResponse.get(), totalRequestsNum);        }    } finally {        if (secure) {            SSLAuthTest.clearSecureSetting(x509Util);        }    }}
run
public void zookeeper_f4680_0()
{    while (!stopped.get()) {        for (final ServerCnxn cnxn : serverFactory.cnxns) {            boolean shouldDisableEnable = random.nextBoolean();            if (shouldDisableEnable) {                cnxn.disableRecv();            } else {                cnxn.enableRecv();            }        }        try {            Thread.sleep(10);        } catch (InterruptedException e) {        /* ignore */        }    }        for (final ServerCnxn cnxn : serverFactory.cnxns) {        cnxn.enableRecv();    }}
run
public void zookeeper_f4681_0()
{    while (!stopped.get()) {        for (final ServerCnxn cnxn : serverFactory.cnxns) {            try {                cnxn.disableRecv();                Thread.sleep(10);                cnxn.enableRecv();                Thread.sleep(10);            } catch (InterruptedException e) {            /* ignore */            }        }    }}
run
public voidf4682_1)
{    int requestIssued = 0;    while (requestIssued++ < totalRequestsNum) {        zk.getData(path, null, new DataCallback() {            @Override            public void processResult(int rc, String path, Object ctx, byte[] data, Stat stat) {                if (rc == 0) {                    successResponse.addAndGet(1);                } else {                                    }                responseReceivedLatch.countDown();            }        }, null);    }}
processResult
public voidf4683_1int rc, String path, Object ctx, byte[] data, Stat stat)
{    if (rc == 0) {        successResponse.addAndGet(1);    } else {            }    responseReceivedLatch.countDown();}
setUp
public void zookeeper_f4684_0() throws IOException
{    listenAddress = new InetSocketAddress(PortAssignment.unique());    factory = new NIOServerCnxnFactory();    factory.configure(listenAddress, 100);}
tearDown
public void zookeeper_f4685_0()
{    if (factory != null) {        factory.shutdown();    }}
testStartupWithoutStart_SocketAlreadyBound
public void zookeeper_f4686_0() throws IOException
{    ServerSocket ss = new ServerSocket(listenAddress.getPort());}
testStartupWithStart_SocketAlreadyBound
public void zookeeper_f4687_0() throws IOException
{    factory.start();    ServerSocket ss = new ServerSocket(listenAddress.getPort());}
testShutdownWithoutStart_SocketReleased
public void zookeeper_f4688_0() throws IOException
{    factory.shutdown();    factory = null;    ServerSocket ss = new ServerSocket(listenAddress.getPort());    ss.close();}
testOperationsAfterCnxnClose
public voidf4689_1) throws IOException, InterruptedException, KeeperException
{    final ZooKeeper zk = createClient();    final String path = "/a";    try {                zk.create(path, "test".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        assertNotNull("Didn't create znode:" + path, zk.exists(path, false));                        assertTrue("Didn't instantiate ServerCnxnFactory with NIOServerCnxnFactory!", serverFactory instanceof NIOServerCnxnFactory);        Iterable<ServerCnxn> connections = serverFactory.getConnections();        for (ServerCnxn serverCnxn : connections) {            serverCnxn.close(ServerCnxn.DisconnectReason.CHANNEL_CLOSED_EXCEPTION);            try {                serverCnxn.toString();            } catch (Exception e) {                                fail("Shouldn't throw exception while " + "getting connection details!");            }        }    } finally {        zk.close();    }}
testClientResponseStatsUpdate
public void zookeeper_f4690_0() throws IOException, InterruptedException, KeeperException
{    try (ZooKeeper zk = createClient()) {        BufferStats clientResponseStats = serverFactory.getZooKeeperServer().serverStats().getClientResponseStats();        assertThat("Last client response size should be initialized with INIT_VALUE", clientResponseStats.getLastBufferSize(), equalTo(BufferStats.INIT_VALUE));        zk.create("/a", "test".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        assertThat("Last client response size should be greater then zero after client request was performed", clientResponseStats.getLastBufferSize(), greaterThan(0));    }}
setUp
public void zookeeper_f4691_0()
{    ZooKeeperServer.setDigestEnabled(true);}
tearDown
public void zookeeper_f4692_0()
{    ZooKeeperServer.setDigestEnabled(false);}
testOperations
public void zookeeper_f4693_0()
{    NodeHashMapImpl nodes = new NodeHashMapImpl(new DigestCalculator());    assertEquals(0, nodes.size());    assertEquals(0L, nodes.getDigest());        String p1 = "p1";    DataNode n1 = new DataNode(p1.getBytes(), 0L, new StatPersisted());    nodes.put(p1, n1);    assertEquals(n1, nodes.get(p1));    assertNotEquals(0L, nodes.getDigest());    assertEquals(1, nodes.size());        String p2 = "p2";    nodes.put(p2, new DataNode(p2.getBytes(), 0L, new StatPersisted()));    Set<Map.Entry<String, DataNode>> entries = nodes.entrySet();    assertEquals(2, entries.size());        nodes.remove(p1);    assertEquals(1, nodes.size());    nodes.remove(p2);    assertEquals(0, nodes.size());    assertEquals(0L, nodes.getDigest());        String p3 = "p3";    DataNode n3 = new DataNode(p3.getBytes(), 0L, new StatPersisted());    nodes.put(p3, n3);    long preChangeDigest = nodes.getDigest();    assertNotEquals(0L, preChangeDigest);    nodes.preChange(p3, n3);    assertEquals(0L, nodes.getDigest());    n3.stat.setMzxid(1);    n3.stat.setMtime(1);    n3.stat.setVersion(1);    nodes.postChange(p3, n3);    long postChangeDigest = nodes.getDigest();    assertNotEquals(0, postChangeDigest);    assertNotEquals(preChangeDigest, postChangeDigest);}
serialize
public synchronized void zookeeper_f4694_0(DataTree dt, Map<Long, Integer> sessions, File snapShot, boolean fsync) throws IOException
{        assertTrue(snapShot.createNewFile());    throw new IOException("Created empty snapshot file from " + "MockFileSnap::serialize()");}
testNoEmptySnapshot
public void zookeeper_f4695_0() throws Exception
{    File tmpFile = File.createTempFile("empty-snapshot-test", ".junit", new File(System.getProperty("build.test.dir", "build")));    File tmpDataDir = new File(tmpFile + ".dir");    assertFalse(tmpDataDir.exists());    assertTrue(tmpDataDir.mkdirs());    FileTxnSnapLog snapLog = new FileTxnSnapLog(tmpDataDir, tmpDataDir);    snapLog.snapLog = new MockFileSnap(snapLog.dataDir);    assertEquals(0, ((FileSnap) snapLog.snapLog).findNRecentSnapshots(10).size());    DataTree tree = new DataTree();    tree.createNode("/empty-snapshot-test-1", "data".getBytes(), null, -1, -1, 1, 1);    try {        snapLog.save(tree, new ConcurrentHashMap<>(), false);        fail("Should have thrown an IOException");    } catch (IOException e) {        }    assertEquals(0, ((FileSnap) snapLog.snapLog).findNRecentSnapshots(10).size());    snapLog.snapLog = new FileSnap(snapLog.dataDir);    snapLog.save(tree, new ConcurrentHashMap<>(), false);    assertEquals(1, ((FileSnap) snapLog.snapLog).findNRecentSnapshots(10).size());}
testInvalidPreallocSize
public void zookeeper_f4696_0()
{    assertEquals("file should not be padded", 10 * KB, FilePadding.calculateFileSizeWithPadding(7 * KB, 10 * KB, 0));    assertEquals("file should not be padded", 10 * KB, FilePadding.calculateFileSizeWithPadding(7 * KB, 10 * KB, -1));}
testCalculateFileSizeWithPaddingWhenNotToCurrentSize
public void zookeeper_f4697_0()
{    assertEquals("file should not be padded", 10 * KB, FilePadding.calculateFileSizeWithPadding(5 * KB, 10 * KB, 10 * KB));}
testCalculateFileSizeWithPaddingWhenCloseToCurrentSize
public void zookeeper_f4698_0()
{    assertEquals("file should be padded an additional 10 KB", 20 * KB, FilePadding.calculateFileSizeWithPadding(7 * KB, 10 * KB, 10 * KB));}
testFileSizeGreaterThanPosition
public void zookeeper_f4699_0()
{    assertEquals("file should be padded to 40 KB", 40 * KB, FilePadding.calculateFileSizeWithPadding(31 * KB, 10 * KB, 10 * KB));}
testPreAllocSizeSmallerThanTxnData
public void zookeeper_f4700_0() throws IOException
{    File logDir = ClientBase.createTmpDir();    FileTxnLog fileTxnLog = new FileTxnLog(logDir);        final int preAllocSize = 500 * KB;    FilePadding.setPreallocSize(preAllocSize);            byte[] data = new byte[2 * preAllocSize];    Arrays.fill(data, (byte) 0xff);            fileTxnLog.append(new TxnHeader(1, 1, 1, 1, ZooDefs.OpCode.create), new CreateTxn("/testPreAllocSizeSmallerThanTxnData1", data, ZooDefs.Ids.OPEN_ACL_UNSAFE, false, 0));    fileTxnLog.commit();    fileTxnLog.append(new TxnHeader(1, 1, 2, 2, ZooDefs.OpCode.create), new CreateTxn("/testPreAllocSizeSmallerThanTxnData2", new byte[] {}, ZooDefs.Ids.OPEN_ACL_UNSAFE, false, 0));    fileTxnLog.commit();    fileTxnLog.close();        FileTxnLog.FileTxnIterator fileTxnIterator = new FileTxnLog.FileTxnIterator(logDir, 0);        CreateTxn createTxn = (CreateTxn) fileTxnIterator.getTxn();    assertTrue(Arrays.equals(createTxn.getData(), data));        fileTxnIterator.next();    createTxn = (CreateTxn) fileTxnIterator.getTxn();    assertTrue(Arrays.equals(createTxn.getData(), new byte[] {}));}
testSetPreallocSize
public void zookeeper_f4701_0()
{    long customPreallocSize = 10101;    FileTxnLog.setPreallocSize(customPreallocSize);    assertThat(FilePadding.getPreAllocSize(), is(equalTo(customPreallocSize)));}
testSyncThresholdExceedCount
public void zookeeper_f4702_0() throws IOException
{            java.lang.System.setProperty(FileTxnLog.ZOOKEEPER_FSYNC_WARNING_THRESHOLD_MS_PROPERTY, "-1");    ServerStats.Provider providerMock = mock(ServerStats.Provider.class);    ServerStats serverStats = new ServerStats(providerMock);    File logDir = ClientBase.createTmpDir();    FileTxnLog fileTxnLog = new FileTxnLog(logDir);    fileTxnLog.setServerStats(serverStats);        assertEquals(0L, serverStats.getFsyncThresholdExceedCount());        for (int i = 0; i < 50; i++) {        fileTxnLog.append(new TxnHeader(1, 1, 1, 1, ZooDefs.OpCode.create), new CreateTxn("/testFsyncThresholdCountIncreased", new byte[] {}, ZooDefs.Ids.OPEN_ACL_UNSAFE, false, 0));                fileTxnLog.commit();                assertEquals((long) i + 1, serverStats.getFsyncThresholdExceedCount());    }}
testGetCurrentLogSize
public voidf4703_1) throws Exception
{    FileTxnLog.setTxnLogSizeLimit(-1);    File tmpDir = ClientBase.createTmpDir();    FileTxnLog log = new FileTxnLog(tmpDir);    FileTxnLog.setPreallocSize(PREALLOCATE);    CreateRequest record = new CreateRequest(null, new byte[NODE_SIZE], ZooDefs.Ids.OPEN_ACL_UNSAFE, 0);    int zxid = 1;    for (int i = 0; i < 4; i++) {        log.append(new TxnHeader(0, 0, zxid++, 0, 0), record);            }    log.commit();        assertTrue(log.getCurrentLogSize() > (zxid - 1) * NODE_SIZE);    for (int i = 0; i < 4; i++) {        log.append(new TxnHeader(0, 0, zxid++, 0, 0), record);            }    log.commit();        assertTrue(log.getCurrentLogSize() > (zxid - 1) * NODE_SIZE);}
testLogSizeLimit
public voidf4704_1) throws Exception
{    File tmpDir = ClientBase.createTmpDir();    ClientBase.setupTestEnv();                FileTxnLog.setPreallocSize(PREALLOCATE);    FileTxnLog.setTxnLogSizeLimit(LOG_SIZE_LIMIT);    ZooKeeperServer zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);    final int PORT = Integer.parseInt(HOSTPORT.split(":")[1]);    ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);    f.startup(zks);    assertTrue("waiting for server being up ", ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT));    ZooKeeper zk = new ZooKeeper(HOSTPORT, CONNECTION_TIMEOUT, DummyWatcher.INSTANCE);        HashSet<Long> zxids = new HashSet<>();    byte[] bytes = new byte[NODE_SIZE];    Random random = new Random();    random.nextBytes(bytes);        long txnCount = LOG_SIZE_LIMIT / NODE_SIZE / 2 * 5;        try {        for (long i = 0; i < txnCount; i++) {            Stat stat = new Stat();            zk.create("/node-" + i, bytes, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);            zk.getData("/node-" + i, null, stat);            zxids.add(stat.getCzxid());        }    } finally {        zk.close();    }        f.shutdown();    assertTrue("waiting for server to shutdown", ClientBase.waitForServerDown(HOSTPORT, CONNECTION_TIMEOUT));    File logDir = new File(tmpDir, FileTxnSnapLog.version + FileTxnSnapLog.VERSION);    File[] txnLogs = FileTxnLog.getLogFiles(logDir.listFiles(), 0);    assertEquals("Unexpected number of logs", 3, txnLogs.length);        long threshold = LOG_SIZE_LIMIT + NODE_SIZE;        assertTrue("Exceed log size limit: " + txnLogs[0].length(), threshold > txnLogs[0].length());        assertTrue("Exceed log size limit " + txnLogs[1].length(), threshold > txnLogs[1].length());        zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);    zks.startdata();    ZKDatabase db = zks.getZKDatabase();    for (long i = 0; i < txnCount; i++) {        Stat stat = new Stat();        byte[] data = db.getData("/node-" + i, stat, null);        assertArrayEquals("Missmatch data", bytes, data);        assertTrue("Unknown zxid ", zxids.contains(stat.getMzxid()));    }}
process
public voidf4705_1WatchedEvent e)
{        allCreatedLatch.countDown();}
testFileTxnSnapLogMetrics
public voidf4706_1) throws Exception
{    SyncRequestProcessor.setSnapCount(100);    QuorumUtil util = new QuorumUtil(1);    util.startAll();    allCreatedLatch = new CountDownLatch(1);    byte[] data = new byte[500];        ZooKeeper zk = ClientBase.createZKClient(util.getConnString());    for (int i = 0; i < 150; i++) {        zk.create("/path" + i, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    }    if (null == zk.exists("/path149", new MockWatcher())) {        allCreatedLatch.await();    }    ServerMetrics.getMetrics().resetAll();    int leader = util.getLeaderServer();        util.shutdown(leader);    util.start(leader);    Map<String, Object> values = MetricsUtils.currentServerMetrics();        assertEquals(1L, values.get("cnt_startup_txns_loaded"));    assertThat((long) values.get("max_startup_txns_loaded"), greaterThan(0L));    assertEquals(1L, values.get("cnt_startup_txns_load_time"));    assertThat((long) values.get("max_startup_txns_load_time"), greaterThanOrEqualTo(0L));    assertEquals(1L, values.get("cnt_startup_snap_load_time"));    assertThat((long) values.get("max_startup_snap_load_time"), greaterThan(0L));    util.shutdownAll();}
setUp
public void zookeeper_f4707_0() throws Exception
{    tmpDir = ClientBase.createEmptyTestDir();    logDir = new File(tmpDir, "logdir");    snapDir = new File(tmpDir, "snapdir");}
tearDown
public void zookeeper_f4708_0() throws Exception
{    if (tmpDir != null) {        TestUtils.deleteFileRecursively(tmpDir);    }    this.tmpDir = null;    this.logDir = null;    this.snapDir = null;    this.logVersionDir = null;    this.snapVersionDir = null;}
createVersionDir
private File zookeeper_f4709_0(File parentDir)
{    File versionDir = new File(parentDir, FileTxnSnapLog.version + FileTxnSnapLog.VERSION);    versionDir.mkdirs();    return versionDir;}
createLogFile
private void zookeeper_f4710_0(File dir, long zxid) throws IOException
{    File file = new File(dir.getPath() + File.separator + Util.makeLogName(zxid));    file.createNewFile();}
createSnapshotFile
private void zookeeper_f4711_0(File dir, long zxid) throws IOException
{    File file = new File(dir.getPath() + File.separator + Util.makeSnapshotName(zxid));    file.createNewFile();}
twoDirSetupWithCorrectFiles
private void zookeeper_f4712_0() throws IOException
{    logVersionDir = createVersionDir(logDir);    snapVersionDir = createVersionDir(snapDir);        createLogFile(logVersionDir, 1);    createLogFile(logVersionDir, 2);        createSnapshotFile(snapVersionDir, 1);    createSnapshotFile(snapVersionDir, 2);}
singleDirSetupWithCorrectFiles
private void zookeeper_f4713_0() throws IOException
{    logVersionDir = createVersionDir(logDir);        createLogFile(logVersionDir, 1);    createLogFile(logVersionDir, 2);    createSnapshotFile(logVersionDir, 1);    createSnapshotFile(logVersionDir, 2);}
createFileTxnSnapLogWithNoAutoCreateDataDir
private FileTxnSnapLog zookeeper_f4714_0(File logDir, File snapDir) throws IOException
{    return createFileTxnSnapLogWithAutoCreateDataDir(logDir, snapDir, "false");}
createFileTxnSnapLogWithAutoCreateDataDir
private FileTxnSnapLog zookeeper_f4715_0(File logDir, File snapDir, String autoCreateValue) throws IOException
{    String priorAutocreateDirValue = System.getProperty(FileTxnSnapLog.ZOOKEEPER_DATADIR_AUTOCREATE);    System.setProperty(FileTxnSnapLog.ZOOKEEPER_DATADIR_AUTOCREATE, autoCreateValue);    FileTxnSnapLog fileTxnSnapLog;    try {        fileTxnSnapLog = new FileTxnSnapLog(logDir, snapDir);    } finally {        if (priorAutocreateDirValue == null) {            System.clearProperty(FileTxnSnapLog.ZOOKEEPER_DATADIR_AUTOCREATE);        } else {            System.setProperty(FileTxnSnapLog.ZOOKEEPER_DATADIR_AUTOCREATE, priorAutocreateDirValue);        }    }    return fileTxnSnapLog;}
createFileTxnSnapLogWithAutoCreateDB
private FileTxnSnapLog zookeeper_f4716_0(File logDir, File snapDir, String autoCreateValue) throws IOException
{    String priorAutocreateDBValue = System.getProperty(FileTxnSnapLog.ZOOKEEPER_DB_AUTOCREATE);    System.setProperty(FileTxnSnapLog.ZOOKEEPER_DB_AUTOCREATE, autoCreateValue);    FileTxnSnapLog fileTxnSnapLog;    try {        fileTxnSnapLog = new FileTxnSnapLog(logDir, snapDir);    } finally {        if (priorAutocreateDBValue == null) {            System.clearProperty(FileTxnSnapLog.ZOOKEEPER_DB_AUTOCREATE);        } else {            System.setProperty(FileTxnSnapLog.ZOOKEEPER_DB_AUTOCREATE, priorAutocreateDBValue);        }    }    return fileTxnSnapLog;}
testWithAutoCreateDataDir
public void zookeeper_f4717_0() throws IOException
{    assertFalse("log directory already exists", logDir.exists());    assertFalse("snapshot directory already exists", snapDir.exists());    FileTxnSnapLog fileTxnSnapLog = createFileTxnSnapLogWithAutoCreateDataDir(logDir, snapDir, "true");    assertTrue(logDir.exists());    assertTrue(snapDir.exists());    assertTrue(fileTxnSnapLog.getDataDir().exists());    assertTrue(fileTxnSnapLog.getSnapDir().exists());}
testWithoutAutoCreateDataDir
public void zookeeper_f4718_0() throws Exception
{    assertFalse("log directory already exists", logDir.exists());    assertFalse("snapshot directory already exists", snapDir.exists());    try {        createFileTxnSnapLogWithAutoCreateDataDir(logDir, snapDir, "false");    } catch (FileTxnSnapLog.DatadirException e) {        assertFalse(logDir.exists());        assertFalse(snapDir.exists());                throw e;    }    fail("Expected exception from FileTxnSnapLog");}
attemptAutoCreateDB
private void zookeeper_f4719_0(File dataDir, File snapDir, Map<Long, Integer> sessions, String autoCreateValue, long expectedValue) throws IOException
{    sessions.clear();    FileTxnSnapLog fileTxnSnapLog = createFileTxnSnapLogWithAutoCreateDB(dataDir, snapDir, autoCreateValue);    long zxid = fileTxnSnapLog.restore(new DataTree(), sessions, new FileTxnSnapLog.PlayBackListener() {        @Override        public void onTxnLoaded(TxnHeader hdr, Record rec) {                }    });    assertEquals("unexpected zxid", expectedValue, zxid);}
onTxnLoaded
public void zookeeper_f4720_0(TxnHeader hdr, Record rec)
{}
testAutoCreateDB
public void zookeeper_f4721_0() throws IOException
{    assertTrue("cannot create log directory", logDir.mkdir());    assertTrue("cannot create snapshot directory", snapDir.mkdir());    File initFile = new File(logDir, "initialize");    assertFalse("initialize file already exists", initFile.exists());    Map<Long, Integer> sessions = new ConcurrentHashMap<>();    attemptAutoCreateDB(logDir, snapDir, sessions, "false", -1L);    attemptAutoCreateDB(logDir, snapDir, sessions, "true", 0L);    assertTrue("cannot create initialize file", initFile.createNewFile());    attemptAutoCreateDB(logDir, snapDir, sessions, "false", 0L);}
testGetTxnLogSyncElapsedTime
public void zookeeper_f4722_0() throws IOException
{    FileTxnSnapLog fileTxnSnapLog = createFileTxnSnapLogWithAutoCreateDataDir(logDir, snapDir, "true");    TxnHeader hdr = new TxnHeader(1, 1, 1, 1, ZooDefs.OpCode.setData);    Record txn = new SetDataTxn("/foo", new byte[0], 1);    Request req = new Request(0, 0, 0, hdr, txn, 0);    try {        fileTxnSnapLog.append(req);        fileTxnSnapLog.commit();        long syncElapsedTime = fileTxnSnapLog.getTxnLogElapsedSyncTime();        assertNotEquals("Did not update syncElapsedTime!", -1L, syncElapsedTime);    } finally {        fileTxnSnapLog.close();    }}
testDirCheckWithCorrectFiles
public void zookeeper_f4723_0() throws IOException
{    twoDirSetupWithCorrectFiles();    try {        createFileTxnSnapLogWithNoAutoCreateDataDir(logDir, snapDir);    } catch (FileTxnSnapLog.LogDirContentCheckException | FileTxnSnapLog.SnapDirContentCheckException e) {        fail("Should not throw ContentCheckException.");    }}
testDirCheckWithSingleDirSetup
public void zookeeper_f4724_0() throws IOException
{    singleDirSetupWithCorrectFiles();    try {        createFileTxnSnapLogWithNoAutoCreateDataDir(logDir, logDir);    } catch (FileTxnSnapLog.LogDirContentCheckException | FileTxnSnapLog.SnapDirContentCheckException e) {        fail("Should not throw ContentCheckException.");    }}
testDirCheckWithSnapFilesInLogDir
public void zookeeper_f4725_0() throws IOException
{    twoDirSetupWithCorrectFiles();        createSnapshotFile(logVersionDir, 3);    createSnapshotFile(logVersionDir, 4);    createFileTxnSnapLogWithNoAutoCreateDataDir(logDir, snapDir);}
testDirCheckWithLogFilesInSnapDir
public void zookeeper_f4726_0() throws IOException
{    twoDirSetupWithCorrectFiles();        createLogFile(snapVersionDir, 3);    createLogFile(snapVersionDir, 4);    createFileTxnSnapLogWithNoAutoCreateDataDir(logDir, snapDir);}
testACLCreatedDuringFuzzySnapshotSync
public void zookeeper_f4727_0() throws IOException
{    DataTree leaderDataTree = new DataTree();        File file = File.createTempFile("snapshot", "zk");    FileOutputStream os = new FileOutputStream(file);    OutputArchive oa = BinaryOutputArchive.getArchive(os);    leaderDataTree.serializeAcls(oa);        TxnHeader hdr1 = new TxnHeader(1, 2, 2, 2, ZooDefs.OpCode.create);    Record txn1 = new CreateTxn("/a1", "foo".getBytes(), ZooDefs.Ids.CREATOR_ALL_ACL, false, -1);    leaderDataTree.processTxn(hdr1, txn1);        leaderDataTree.serializeNodes(oa);    os.close();        FileInputStream is = new FileInputStream(file);    InputArchive ia = BinaryInputArchive.getArchive(is);    DataTree followerDataTree = new DataTree();    followerDataTree.deserialize(ia, "tree");    followerDataTree.processTxn(hdr1, txn1);    DataNode a1 = leaderDataTree.getNode("/a1");    assertNotNull(a1);    assertEquals(ZooDefs.Ids.CREATOR_ALL_ACL, leaderDataTree.getACL(a1));    assertEquals(ZooDefs.Ids.CREATOR_ALL_ACL, followerDataTree.getACL(a1));}
tearDown
public void zookeeper_f4728_0()
{    System.clearProperty(SnapStream.ZOOKEEPER_SHAPSHOT_STREAM_MODE);    SnapStream.setStreamMode(StreamMode.DEFAULT_MODE);}
testStreamMode
public void zookeeper_f4729_0()
{    assertEquals(StreamMode.CHECKED.getName(), "");    assertEquals(StreamMode.CHECKED.getFileExtension(), "");    assertEquals(StreamMode.CHECKED, StreamMode.fromString("name"));    assertEquals(StreamMode.GZIP.getName(), "gz");    assertEquals(StreamMode.GZIP.getFileExtension(), ".gz");    assertEquals(StreamMode.GZIP, StreamMode.fromString("gz"));    assertEquals(StreamMode.SNAPPY.getName(), "snappy");    assertEquals(StreamMode.SNAPPY.getFileExtension(), ".snappy");    assertEquals(StreamMode.SNAPPY, StreamMode.fromString("snappy"));}
testGetStreamMode
public void zookeeper_f4730_0()
{    assertEquals("expected to return un-compressed stream", StreamMode.CHECKED, SnapStream.getStreamMode("snapshot.180000e3a2"));    assertEquals("expected to return snappy stream", StreamMode.SNAPPY, SnapStream.getStreamMode("snapshot.180000e3a2.snappy"));    assertEquals("expected to return gzip stream", StreamMode.GZIP, SnapStream.getStreamMode("snapshot.180000e3a2.gz"));}
testSerializeDeserializeWithChecked
public void zookeeper_f4731_0() throws IOException
{    testSerializeDeserialize(StreamMode.CHECKED, "");}
testSerializeDeserializeWithSNAPPY
public void zookeeper_f4732_0() throws IOException
{    testSerializeDeserialize(StreamMode.SNAPPY, ".snappy");}
testSerializeDeserializeWithGZIP
public void zookeeper_f4733_0() throws IOException
{    testSerializeDeserialize(StreamMode.GZIP, ".gz");}
testSerializeDeserialize
private void zookeeper_f4734_0(StreamMode mode, String fileSuffix) throws IOException
{    SnapStream.setStreamMode(mode);        File tmpDir = createTmpDir();    File file = new File(tmpDir, "snapshot.180000e3a2" + fileSuffix);    CheckedOutputStream os = SnapStream.getOutputStream(file);    OutputArchive oa = BinaryOutputArchive.getArchive(os);    FileHeader header = new FileHeader(FileSnap.SNAP_MAGIC, 2, 1);    header.serialize(oa, "fileheader");    SnapStream.sealStream(os, oa);    os.flush();    os.close();    assertTrue(SnapStream.isValidSnapshot(file));        CheckedInputStream is = SnapStream.getInputStream(file);    InputArchive ia = BinaryInputArchive.getArchive(is);    FileHeader restoredHeader = new FileHeader();    restoredHeader.deserialize(ia, "fileheader");    assertEquals("magic not the same", restoredHeader, header);    SnapStream.checkSealIntegrity(is, ia);}
checkInvalidSnapshot
private void zookeeper_f4735_0(String filename) throws IOException
{        SnapStream.setStreamMode(StreamMode.CHECKED);        File tmpDir = createTmpDir();    File file = new File(tmpDir, filename);    OutputStream os = SnapStream.getOutputStream(file);    os.write(1);    os.flush();    os.close();    assertFalse(SnapStream.isValidSnapshot(file));}
testInvalidSnapshot
public void zookeeper_f4736_0() throws IOException
{    assertFalse(SnapStream.isValidSnapshot(null));    checkInvalidSnapshot("snapshot.180000e3a2");    checkInvalidSnapshot("snapshot.180000e3a2.gz");    checkInvalidSnapshot("snapshot.180000e3a2.snappy");}
setUp
public void zookeeper_f4737_0() throws IOException
{    System.setOut(new PrintStream(outContent));    System.setErr(new PrintStream(errContent));    File snapDir = new File(testData, "invalidsnap");    mySnapDir = ClientBase.createTmpDir();    FileUtils.copyDirectory(snapDir, mySnapDir);}
tearDown
public void zookeeper_f4738_0() throws IOException
{    System.setOut(System.out);    System.setErr(System.err);    mySnapDir.setWritable(true);    FileUtils.deleteDirectory(mySnapDir);}
testDumpMode
public void zookeeper_f4739_0() throws Exception
{        File logfile = new File(new File(mySnapDir, "version-2"), "log.274");    TxnLogToolkit lt = new TxnLogToolkit(false, false, logfile.toString(), true);        lt.dump(null);}
testInitMissingFile
public void zookeeper_f4740_0() throws FileNotFoundException, TxnLogToolkit.TxnLogToolkitException
{        File logfile = new File("this_file_should_not_exists");    TxnLogToolkit lt = new TxnLogToolkit(false, false, logfile.toString(), true);}
testInitWithRecoveryFileExists
public void zookeeper_f4741_0() throws IOException, TxnLogToolkit.TxnLogToolkitException
{        File logfile = new File(new File(mySnapDir, "version-2"), "log.274");    File recoveryFile = new File(new File(mySnapDir, "version-2"), "log.274.fixed");    recoveryFile.createNewFile();    TxnLogToolkit lt = new TxnLogToolkit(true, false, logfile.toString(), true);}
testDumpWithCrcError
public void zookeeper_f4742_0() throws Exception
{        File logfile = new File(new File(mySnapDir, "version-2"), "log.42");    TxnLogToolkit lt = new TxnLogToolkit(false, false, logfile.toString(), true);        lt.dump(null);        String output = outContent.toString();    Pattern p = Pattern.compile("^CRC ERROR.*session 0x8061fac5ddeb0000 cxid 0x0 zxid 0x8800000002 createSession 30000$", Pattern.MULTILINE);    Matcher m = p.matcher(output);    assertTrue("Output doesn't indicate CRC error for the broken session id: " + output, m.find());}
testRecoveryFixBrokenFile
public void zookeeper_f4743_0() throws Exception
{        File logfile = new File(new File(mySnapDir, "version-2"), "log.42");    TxnLogToolkit lt = new TxnLogToolkit(true, false, logfile.toString(), true);        lt.dump(null);        String output = outContent.toString();    assertThat(output, containsString("CRC FIXED"));        outContent.reset();    logfile = new File(new File(mySnapDir, "version-2"), "log.42.fixed");    lt = new TxnLogToolkit(false, false, logfile.toString(), true);    lt.dump(null);    output = outContent.toString();    assertThat(output, not(containsString("CRC ERROR")));}
testRecoveryInteractiveMode
public void zookeeper_f4744_0() throws Exception
{        File logfile = new File(new File(mySnapDir, "version-2"), "log.42");    TxnLogToolkit lt = new TxnLogToolkit(true, false, logfile.toString(), false);        lt.dump(new Scanner("y\n"));        String output = outContent.toString();    assertThat(output, containsString("CRC ERROR"));        outContent.reset();    logfile = new File(new File(mySnapDir, "version-2"), "log.42.fixed");    lt = new TxnLogToolkit(false, false, logfile.toString(), true);    lt.dump(null);    output = outContent.toString();    assertThat(output, not(containsString("CRC ERROR")));}
setup
public void zookeeper_f4745_0()
{    System.setProperty(ZooKeeperServer.SKIP_ACL, "true");    zks = spy(new ZooKeeperServer());    zks.sessionTracker = mock(SessionTracker.class);    ZKDatabase db = mock(ZKDatabase.class);    when(zks.getZKDatabase()).thenReturn(db);    DataNode node = new DataNode(new byte[1], null, mock(StatPersisted.class));    when(db.getNode(anyString())).thenReturn(node);    Set<String> ephemerals = new HashSet<>();    ephemerals.add("/crystalmountain");    ephemerals.add("/stevenspass");    when(db.getEphemerals(anyLong())).thenReturn(ephemerals);    nextProcessor = mock(RequestProcessor.class);    ServerMetrics.getMetrics().resetAll();}
tearDown
public void zookeeper_f4746_0() throws Exception
{    System.clearProperty(ZooKeeperServer.SKIP_ACL);}
createRequest
private Request zookeeper_f4747_0(Record record, int opCode) throws IOException
{        ByteArrayOutputStream baos = new ByteArrayOutputStream();    BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos);    record.serialize(boa, "request");    baos.close();    return new Request(null, 1L, 0, opCode, ByteBuffer.wrap(baos.toByteArray()), null);}
createRequest
private Request zookeeper_f4748_0(String path, int opCode) throws IOException
{    Record record;    switch(opCode) {        case ZooDefs.OpCode.setData:            record = new SetDataRequest(path, new byte[0], -1);            break;        case ZooDefs.OpCode.delete:            record = new DeleteRequest(path, -1);            break;        default:            record = new DeleteRequest(path, -1);            break;    }    return createRequest(record, opCode);}
createRequest
private Request zookeeper_f4749_0(long sessionId, int opCode)
{    return new Request(null, sessionId, 0, opCode, null, null);}
testPrepRequestProcessorMetrics
public void zookeeper_f4750_0() throws Exception
{    CountDownLatch threeRequests = new CountDownLatch(3);    doAnswer(invocationOnMock -> {        threeRequests.countDown();        return null;    }).when(nextProcessor).processRequest(any(Request.class));    PrepRequestProcessor prepRequestProcessor = new PrepRequestProcessor(zks, nextProcessor);        prepRequestProcessor.processRequest(createRequest("/foo", ZooDefs.OpCode.setData));        prepRequestProcessor.processRequest(createRequest("/foo/bar", ZooDefs.OpCode.delete));        prepRequestProcessor.processRequest(createRequest(2, ZooDefs.OpCode.closeSession));    Map<String, Object> values = MetricsUtils.currentServerMetrics();    assertEquals(3L, values.get("prep_processor_request_queued"));        Thread.sleep(20);    prepRequestProcessor.start();    threeRequests.await(500, TimeUnit.MILLISECONDS);    values = MetricsUtils.currentServerMetrics();    assertEquals(3L, values.get("max_prep_processor_queue_size"));    assertThat((long) values.get("min_prep_processor_queue_time_ms"), greaterThan(20L));    assertEquals(3L, values.get("cnt_prep_processor_queue_time_ms"));    assertEquals(3L, values.get("cnt_prep_process_time"));    assertThat((long) values.get("max_prep_process_time"), greaterThan(0L));    assertEquals(1L, values.get("cnt_close_session_prep_time"));    assertThat((long) values.get("max_close_session_prep_time"), greaterThanOrEqualTo(0L));    assertEquals(5L, values.get("outstanding_changes_queued"));}
process
public void zookeeper_f4751_0(WatchedEvent e)
{    created.countDown();}
testOutstandingChangesRemoved
public void zookeeper_f4752_0() throws Exception
{        QuorumUtil util = new QuorumUtil(1);    util.startAll();    ServerMetrics.getMetrics().resetAll();    ZooKeeper zk = ClientBase.createZKClient(util.getConnString());    zk.create("/test", new byte[50], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    CountDownLatch created = new CountDownLatch(1);    zk.exists("/test", new SimpleWatcher(created));    created.await(200, TimeUnit.MILLISECONDS);    Map<String, Object> values = MetricsUtils.currentServerMetrics();    assertThat((long) values.get("outstanding_changes_removed"), greaterThan(0L));    util.shutdownAll();}
setup
public void zookeeper_f4753_0() throws Exception
{    File tmpDir = ClientBase.createTmpDir();    ClientBase.setupTestEnv();    zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);    SyncRequestProcessor.setSnapCount(100);    final int PORT = Integer.parseInt(HOSTPORT.split(":")[1]);    servcnxnf = ServerCnxnFactory.createFactory(PORT, -1);    servcnxnf.startup(zks);    assertTrue("waiting for server being up ", ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT));    zks.sessionTracker = new MySessionTracker();}
teardown
public void zookeeper_f4754_0() throws Exception
{    if (servcnxnf != null) {        servcnxnf.shutdown();    }    if (zks != null) {        zks.shutdown();    }}
testPRequest
public void zookeeper_f4755_0() throws Exception
{    pLatch = new CountDownLatch(1);    processor = new PrepRequestProcessor(zks, new MyRequestProcessor());    Request foo = new Request(null, 1L, 1, OpCode.create, ByteBuffer.allocate(3), null);    processor.pRequest(foo);    assertEquals("Request should have marshalling error", new ErrorTxn(KeeperException.Code.MARSHALLINGERROR.intValue()), outcome.getTxn());    assertTrue("request hasn't been processed in chain", pLatch.await(5, TimeUnit.SECONDS));}
createRequest
private Request zookeeper_f4756_0(Record record, int opCode) throws IOException
{    return createRequest(record, opCode, 1L);}
createRequest
private Request zookeeper_f4757_0(Record record, int opCode, long sessionId) throws IOException
{        ByteArrayOutputStream baos = new ByteArrayOutputStream();    BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos);    record.serialize(boa, "request");    baos.close();        List<Id> ids = Arrays.asList(Ids.ANYONE_ID_UNSAFE);    return new Request(null, sessionId, 0, opCode, ByteBuffer.wrap(baos.toByteArray()), ids);}
process
private void zookeeper_f4758_0(List<Op> ops) throws Exception
{    pLatch = new CountDownLatch(1);    processor = new PrepRequestProcessor(zks, new MyRequestProcessor());    Record record = new MultiOperationRecord(ops);    Request req = createRequest(record, OpCode.multi);    processor.pRequest(req);    assertTrue("request hasn't been processed in chain", pLatch.await(5, TimeUnit.SECONDS));}
testMultiOutstandingChange
public void zookeeper_f4759_0() throws Exception
{    zks.getZKDatabase().dataTree.createNode("/foo", new byte[0], Ids.OPEN_ACL_UNSAFE, 0, 0, 0, 0);    assertNull(zks.outstandingChangesForPath.get("/foo"));    process(Arrays.asList(Op.setData("/foo", new byte[0], -1)));    ChangeRecord cr = zks.outstandingChangesForPath.get("/foo");    assertNotNull("Change record wasn't set", cr);    assertEquals("Record zxid wasn't set correctly", 1, cr.zxid);    process(Arrays.asList(Op.delete("/foo", -1)));    cr = zks.outstandingChangesForPath.get("/foo");    assertEquals("Record zxid wasn't set correctly", 2, cr.zxid);        process(Arrays.asList(Op.delete("/foo", -1)));    cr = zks.outstandingChangesForPath.get("/foo");        assertEquals("Record zxid wasn't set correctly", 2, cr.zxid);}
testMultiRollbackNoLastChange
public void zookeeper_f4760_0() throws Exception
{    zks.getZKDatabase().dataTree.createNode("/foo", new byte[0], Ids.OPEN_ACL_UNSAFE, 0, 0, 0, 0);    zks.getZKDatabase().dataTree.createNode("/foo/bar", new byte[0], Ids.OPEN_ACL_UNSAFE, 0, 0, 0, 0);    assertNull(zks.outstandingChangesForPath.get("/foo"));                process(Arrays.asList(Op.setData("/foo", new byte[0], -1), Op.delete("/foo", -1)));        assertNull(zks.outstandingChangesForPath.get("/foo"));}
testCloseSessionTxn
public void zookeeper_f4761_0() throws Exception
{    boolean before = ZooKeeperServer.isCloseSessionTxnEnabled();    ZooKeeperServer.setCloseSessionTxnEnabled(true);    try {                long ephemeralOwner = 1;        DataTree dt = zks.getZKDatabase().dataTree;        dt.createNode("/foo", new byte[0], Ids.OPEN_ACL_UNSAFE, ephemeralOwner, 0, 0, 0);        dt.createNode("/bar", new byte[0], Ids.OPEN_ACL_UNSAFE, ephemeralOwner, 0, 0, 0);                RequestHeader header = new RequestHeader();        header.setType(OpCode.closeSession);        final FinalRequestProcessor frq = new FinalRequestProcessor(zks);        final CountDownLatch latch = new CountDownLatch(1);        processor = new PrepRequestProcessor(zks, new RequestProcessor() {            @Override            public void processRequest(Request request) {                frq.processRequest(request);                latch.countDown();            }            @Override            public void shutdown() {                        }        });        processor.pRequest(createRequest(header, OpCode.closeSession, ephemeralOwner));        assertTrue(latch.await(3, TimeUnit.SECONDS));                assertEquals(null, dt.getNode("/foo"));        assertEquals(null, dt.getNode("/bar"));    } finally {        ZooKeeperServer.setCloseSessionTxnEnabled(before);    }}
processRequest
public void zookeeper_f4762_0(Request request)
{    frq.processRequest(request);    latch.countDown();}
shutdown
public void zookeeper_f4763_0()
{}
testInvalidPath
public void zookeeper_f4764_0() throws Exception
{    pLatch = new CountDownLatch(1);    processor = new PrepRequestProcessor(zks, new MyRequestProcessor());    SetDataRequest record = new SetDataRequest("", new byte[0], -1);    Request req = createRequest(record, OpCode.setData);    processor.pRequest(req);    pLatch.await();    assertEquals(outcome.getHdr().getType(), OpCode.error);    assertEquals(outcome.getException().code(), KeeperException.Code.BADARGUMENTS);}
processRequest
public void zookeeper_f4765_0(Request request)
{        outcome = request;    pLatch.countDown();}
shutdown
public void zookeeper_f4766_0()
{}
trackSession
public boolean zookeeper_f4767_0(long id, int to)
{        return false;}
commitSession
public boolean zookeeper_f4768_0(long id, int to)
{        return false;}
checkSession
public void zookeeper_f4769_0(long sessionId, Object owner) throws SessionExpiredException, SessionMovedException
{}
createSession
public long zookeeper_f4770_0(int sessionTimeout)
{        return 0;}
dumpSessions
public void zookeeper_f4771_0(PrintWriter pwriter)
{}
removeSession
public void zookeeper_f4772_0(long sessionId)
{}
upgradeSession
public int zookeeper_f4773_0(long sessionId)
{        return 0;}
setOwner
public void zookeeper_f4774_0(long id, Object owner) throws SessionExpiredException
{}
shutdown
public void zookeeper_f4775_0()
{}
touchSession
public boolean zookeeper_f4776_0(long sessionId, int sessionTimeout)
{        return false;}
setSessionClosing
public void zookeeper_f4777_0(long sessionId)
{}
isTrackingSession
public boolean zookeeper_f4778_0(long sessionId)
{        return false;}
checkGlobalSession
public void zookeeper_f4779_0(long sessionId, Object owner) throws SessionExpiredException, SessionMovedException
{}
getSessionExpiryMap
public Map<Long, Set<Long>> zookeeper_f4780_0()
{    return new HashMap<Long, Set<Long>>();}
getLocalSessionCount
public long zookeeper_f4781_0()
{    return 0;}
isLocalSessionsEnabled
public boolean zookeeper_f4782_0()
{    return false;}
teardown
public void zookeeper_f4783_0()
{    if (null != tmpDir) {        ClientBase.recursiveDelete(tmpDir);    }}
testPurge
public void zookeeper_f4784_0() throws Exception
{    tmpDir = ClientBase.createTmpDir();    ClientBase.setupTestEnv();    ZooKeeperServer zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);    SyncRequestProcessor.setSnapCount(100);    final int PORT = Integer.parseInt(HOSTPORT.split(":")[1]);    ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);    f.startup(zks);    assertTrue("waiting for server being up ", ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT));    ZooKeeper zk = ClientBase.createZKClient(HOSTPORT);    try {        for (int i = 0; i < 2000; i++) {            zk.create("/invalidsnap-" + i, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        }    } finally {        zk.close();    }    f.shutdown();    zks.getTxnLogFactory().close();    assertTrue("waiting for server to shutdown", ClientBase.waitForServerDown(HOSTPORT, CONNECTION_TIMEOUT));        PurgeTxnLog.purge(tmpDir, tmpDir, 3);    FileTxnSnapLog snaplog = new FileTxnSnapLog(tmpDir, tmpDir);    List<File> listLogs = snaplog.findNRecentSnapshots(4);    int numSnaps = 0;    for (File ff : listLogs) {        if (ff.getName().startsWith("snapshot")) {            numSnaps++;        }    }    assertTrue("exactly 3 snapshots ", (numSnaps == 3));    snaplog.close();    zks.shutdown();}
testPurgeWhenLogRollingInProgress
public voidf4785_1) throws Exception
{    tmpDir = ClientBase.createTmpDir();    ClientBase.setupTestEnv();    ZooKeeperServer zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);    SyncRequestProcessor.setSnapCount(30);    final int PORT = Integer.parseInt(HOSTPORT.split(":")[1]);    ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);    f.startup(zks);    assertTrue("waiting for server being up ", ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT));    final ZooKeeper zk = ClientBase.createZKClient(HOSTPORT);    final CountDownLatch doPurge = new CountDownLatch(1);    final CountDownLatch purgeFinished = new CountDownLatch(1);    final AtomicBoolean opFailed = new AtomicBoolean(false);    new Thread() {        public void run() {            try {                doPurge.await(OP_TIMEOUT_IN_MILLIS / 2, TimeUnit.MILLISECONDS);                PurgeTxnLog.purge(tmpDir, tmpDir, 3);            } catch (IOException ioe) {                                opFailed.set(true);            } catch (InterruptedException ie) {                                opFailed.set(true);            } finally {                purgeFinished.countDown();            }        }    }.start();    final int thCount = 3;    List<String> znodes = manyClientOps(zk, doPurge, thCount, "/invalidsnap");    assertTrue("Purging is not finished!", purgeFinished.await(OP_TIMEOUT_IN_MILLIS, TimeUnit.MILLISECONDS));    assertFalse("Purging failed!", opFailed.get());    for (String znode : znodes) {        try {            zk.getData(znode, false, null);        } catch (Exception ke) {                        fail("Unexpected exception when visiting znode!");        }    }    zk.close();    f.shutdown();    zks.shutdown();    zks.getTxnLogFactory().close();}
run
public voidf4786_1)
{    try {        doPurge.await(OP_TIMEOUT_IN_MILLIS / 2, TimeUnit.MILLISECONDS);        PurgeTxnLog.purge(tmpDir, tmpDir, 3);    } catch (IOException ioe) {                opFailed.set(true);    } catch (InterruptedException ie) {                opFailed.set(true);    } finally {        purgeFinished.countDown();    }}
testFindNRecentSnapshots
public void zookeeper_f4787_0() throws Exception
{        int nRecentSnap = 4;    int nRecentCount = 30;    int offset = 0;    tmpDir = ClientBase.createTmpDir();    File version2 = new File(tmpDir.toString(), "version-2");    assertTrue("Failed to create version_2 dir:" + version2.toString(), version2.mkdir());        FileTxnSnapLog txnLog = new FileTxnSnapLog(tmpDir, tmpDir);    List<File> foundSnaps = txnLog.findNRecentSnapshots(1);    assertEquals(0, foundSnaps.size());    List<File> expectedNRecentSnapFiles = new ArrayList<File>();    int counter = offset + (2 * nRecentCount);    for (int i = 0; i < nRecentCount; i++) {                File logFile = new File(version2 + "/log." + Long.toHexString(--counter));        assertTrue("Failed to create log File:" + logFile.toString(), logFile.createNewFile());                File snapFile = new File(version2 + "/snapshot." + Long.toHexString(--counter));        assertTrue("Failed to create snap File:" + snapFile.toString(), snapFile.createNewFile());                if (i < nRecentSnap) {            expectedNRecentSnapFiles.add(snapFile);        }    }            List<File> nRecentSnapFiles = txnLog.findNRecentSnapshots(nRecentSnap);    assertEquals("exactly 4 snapshots ", 4, nRecentSnapFiles.size());    expectedNRecentSnapFiles.removeAll(nRecentSnapFiles);    assertEquals("Didn't get the recent snap files", 0, expectedNRecentSnapFiles.size());            nRecentSnapFiles = txnLog.findNRecentSnapshots(nRecentCount + 5);    assertEquals(nRecentCount, nRecentSnapFiles.size());    for (File f : nRecentSnapFiles) {        assertTrue("findNRecentSnapshots() returned a non-snapshot: " + f.getPath(), (Util.getZxidFromName(f.getName(), "snapshot") != -1));    }    txnLog.close();}
testSnapFilesGreaterThanToRetain
public void zookeeper_f4788_0() throws Exception
{    int nRecentCount = 4;    int fileAboveRecentCount = 4;    int fileToPurgeCount = 2;    AtomicInteger offset = new AtomicInteger(0);    tmpDir = ClientBase.createTmpDir();    File version2 = new File(tmpDir.toString(), "version-2");    assertTrue("Failed to create version_2 dir:" + version2.toString(), version2.mkdir());    List<File> snapsToPurge = new ArrayList<File>();    List<File> logsToPurge = new ArrayList<File>();    List<File> snaps = new ArrayList<File>();    List<File> logs = new ArrayList<File>();    List<File> snapsAboveRecentFiles = new ArrayList<File>();    List<File> logsAboveRecentFiles = new ArrayList<File>();    createDataDirFiles(offset, fileToPurgeCount, false, version2, snapsToPurge, logsToPurge);    createDataDirFiles(offset, nRecentCount, false, version2, snaps, logs);        logs.add(logsToPurge.remove(0));    createDataDirFiles(offset, fileAboveRecentCount, false, version2, snapsAboveRecentFiles, logsAboveRecentFiles);    /**     * The newest log file preceding the oldest retained snapshot is not removed as it may     * contain transactions newer than the oldest snapshot.     */    logsToPurge.remove(0);    FileTxnSnapLog txnLog = new FileTxnSnapLog(tmpDir, tmpDir);    PurgeTxnLog.purgeOlderSnapshots(txnLog, snaps.get(snaps.size() - 1));    txnLog.close();    verifyFilesAfterPurge(snapsToPurge, false);    verifyFilesAfterPurge(logsToPurge, false);    verifyFilesAfterPurge(snaps, true);    verifyFilesAfterPurge(logs, true);    verifyFilesAfterPurge(snapsAboveRecentFiles, true);    verifyFilesAfterPurge(logsAboveRecentFiles, true);}
testSnapFilesEqualsToRetain
public void zookeeper_f4789_0() throws Exception
{    internalTestSnapFilesEqualsToRetain(false);}
testSnapFilesEqualsToRetainWithPrecedingLog
public void zookeeper_f4790_0() throws Exception
{    internalTestSnapFilesEqualsToRetain(true);}
internalTestSnapFilesEqualsToRetain
public void zookeeper_f4791_0(boolean testWithPrecedingLogFile) throws Exception
{    int nRecentCount = 3;    AtomicInteger offset = new AtomicInteger(0);    tmpDir = ClientBase.createTmpDir();    File version2 = new File(tmpDir.toString(), "version-2");    assertTrue("Failed to create version_2 dir:" + version2.toString(), version2.mkdir());    List<File> snaps = new ArrayList<File>();    List<File> logs = new ArrayList<File>();    createDataDirFiles(offset, nRecentCount, testWithPrecedingLogFile, version2, snaps, logs);    FileTxnSnapLog txnLog = new FileTxnSnapLog(tmpDir, tmpDir);    PurgeTxnLog.purgeOlderSnapshots(txnLog, snaps.get(snaps.size() - 1));    txnLog.close();    verifyFilesAfterPurge(snaps, true);    verifyFilesAfterPurge(logs, true);}
testSnapFilesLessThanToRetain
public void zookeeper_f4792_0() throws Exception
{    int nRecentCount = 4;    int fileToPurgeCount = 2;    AtomicInteger offset = new AtomicInteger(0);    tmpDir = ClientBase.createTmpDir();    File version2 = new File(tmpDir.toString(), "version-2");    assertTrue("Failed to create version_2 dir:" + version2.toString(), version2.mkdir());    List<File> snapsToPurge = new ArrayList<File>();    List<File> logsToPurge = new ArrayList<File>();    List<File> snaps = new ArrayList<File>();    List<File> logs = new ArrayList<File>();    createDataDirFiles(offset, fileToPurgeCount, false, version2, snapsToPurge, logsToPurge);    createDataDirFiles(offset, nRecentCount, false, version2, snaps, logs);        logs.add(logsToPurge.remove(0));    /**     * The newest log file preceding the oldest retained snapshot is not removed as it may     * contain transactions newer than the oldest snapshot.     */    logsToPurge.remove(0);    FileTxnSnapLog txnLog = new FileTxnSnapLog(tmpDir, tmpDir);    PurgeTxnLog.purgeOlderSnapshots(txnLog, snaps.get(snaps.size() - 1));    txnLog.close();    verifyFilesAfterPurge(snapsToPurge, false);    verifyFilesAfterPurge(logsToPurge, false);    verifyFilesAfterPurge(snaps, true);    verifyFilesAfterPurge(logs, true);}
testPurgeTxnLogWithDataDir
public void zookeeper_f4793_0() throws Exception
{    tmpDir = ClientBase.createTmpDir();    File dataDir = new File(tmpDir, "dataDir");    File dataLogDir = new File(tmpDir, "dataLogDir");    File dataDirVersion2 = new File(dataDir, "version-2");    dataDirVersion2.mkdirs();    File dataLogDirVersion2 = new File(dataLogDir, "version-2");    dataLogDirVersion2.mkdirs();        int totalFiles = 20;        for (int i = 0; i < totalFiles; i++) {                File logFile = new File(dataLogDirVersion2, "log." + Long.toHexString(i));        logFile.createNewFile();                File snapFile = new File(dataDirVersion2, "snapshot." + Long.toHexString(i));        snapFile.createNewFile();    }    int numberOfSnapFilesToKeep = 10;        String[] args = new String[] { dataLogDir.getAbsolutePath(), dataDir.getAbsolutePath(), "-n", Integer.toString(numberOfSnapFilesToKeep) };    PurgeTxnLog.main(args);    assertEquals(numberOfSnapFilesToKeep, dataDirVersion2.listFiles().length);        assertEquals(numberOfSnapFilesToKeep, dataLogDirVersion2.listFiles().length);    ClientBase.recursiveDelete(tmpDir);}
testPurgeTxnLogWithoutDataDir
public void zookeeper_f4794_0() throws Exception
{    tmpDir = ClientBase.createTmpDir();    File dataDir = new File(tmpDir, "dataDir");    File dataLogDir = new File(tmpDir, "dataLogDir");    File dataDirVersion2 = new File(dataDir, "version-2");    dataDirVersion2.mkdirs();    File dataLogDirVersion2 = new File(dataLogDir, "version-2");    dataLogDirVersion2.mkdirs();        int totalFiles = 20;        for (int i = 0; i < totalFiles; i++) {                File logFile = new File(dataLogDirVersion2, "log." + Long.toHexString(i));        logFile.createNewFile();                File snapFile = new File(dataLogDirVersion2, "snapshot." + Long.toHexString(i));        snapFile.createNewFile();    }    int numberOfSnapFilesToKeep = 10;        String[] args = new String[] { dataLogDir.getAbsolutePath(), "-n", Integer.toString(numberOfSnapFilesToKeep) };    PurgeTxnLog.main(args);    assertEquals(numberOfSnapFilesToKeep *     2, dataLogDirVersion2.listFiles().length);    ClientBase.recursiveDelete(tmpDir);}
testPurgeDoesNotDeleteOverlappingLogFile
public void zookeeper_f4795_0() throws Exception
{        final int SNAP_RETAIN_COUNT = 3;        final int NUM_ZNODES_PER_SNAPSHOT = 100;    /**     * Set a sufficiently high snapCount to ensure that we don't rollover the log.  Normally,     * the default value (100K at time of this writing) would ensure this, but we make that     * dependence explicit here to make the test future-proof.  Not rolling over the log is     * important for this test since we are testing retention of the one and only log file which     * predates each retained snapshot.     */    SyncRequestProcessor.setSnapCount(SNAP_RETAIN_COUNT * NUM_ZNODES_PER_SNAPSHOT * 10);        tmpDir = ClientBase.createTmpDir();    ClientBase.setupTestEnv();    ZooKeeperServer zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);    final int PORT = Integer.parseInt(HOSTPORT.split(":")[1]);    ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);    f.startup(zks);    assertTrue("waiting for server being up ", ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT));    ZooKeeper zk = ClientBase.createZKClient(HOSTPORT);        int unique = 0;    try {        /**         * Create some znodes and take a snapshot.  Repeat this until we have SNAP_RETAIN_COUNT         * snapshots.  Do not rollover the log.         */        for (int snapshotCount = 0; snapshotCount < SNAP_RETAIN_COUNT; snapshotCount++) {            for (int i = 0; i < 100; i++, unique++) {                zk.create("/snap-" + unique, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);            }            zks.takeSnapshot();        }                for (int i = 0; i < 100; i++, unique++) {            zk.create("/snap-" + unique, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        }    } finally {        zk.close();    }        f.shutdown();    zks.getTxnLogFactory().close();    zks.shutdown();    assertTrue("waiting for server to shutdown", ClientBase.waitForServerDown(HOSTPORT, CONNECTION_TIMEOUT));        PurgeTxnLog.purge(tmpDir, tmpDir, SNAP_RETAIN_COUNT);        zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);    f = ServerCnxnFactory.createFactory(PORT, -1);    f.startup(zks);    zk = ClientBase.createZKClient(HOSTPORT);    /**     * Verify that the last znode that was created above exists.  This znode's creation was     * captured by the transaction log which was created before any of the above     * SNAP_RETAIN_COUNT snapshots were created, but it's not captured in any of these     * snapshots.  So for it it exist, the (only) existing log file should not have been purged.     */    final String lastZnode = "/snap-" + (unique - 1);    final Stat stat = zk.exists(lastZnode, false);    assertNotNull("Last znode does not exist: " + lastZnode, stat);        f.shutdown();    zks.getTxnLogFactory().close();    zks.shutdown();}
createDataDirLogFile
private File zookeeper_f4796_0(File version_2, int Zxid) throws IOException
{    File logFile = new File(version_2 + "/log." + Long.toHexString(Zxid));    assertTrue("Failed to create log File:" + logFile.toString(), logFile.createNewFile());    return logFile;}
createDataDirFiles
private void zookeeper_f4797_0(AtomicInteger offset, int limit, boolean createPrecedingLogFile, File version_2, List<File> snaps, List<File> logs) throws IOException
{    int counter = offset.get() + (2 * limit);    if (createPrecedingLogFile) {        counter++;    }    offset.set(counter);    for (int i = 0; i < limit; i++) {                logs.add(createDataDirLogFile(version_2, --counter));                File snapFile = new File(version_2 + "/snapshot." + Long.toHexString(--counter));        assertTrue("Failed to create snap File:" + snapFile.toString(), snapFile.createNewFile());        snaps.add(snapFile);    }    if (createPrecedingLogFile) {        logs.add(createDataDirLogFile(version_2, --counter));    }}
verifyFilesAfterPurge
private void zookeeper_f4798_0(List<File> logs, boolean exists)
{    for (File file : logs) {        assertEquals("After purging, file " + file, exists, file.exists());    }}
manyClientOps
private List<String>f4799_1final ZooKeeper zk, final CountDownLatch doPurge, int thCount, final String prefix)
{    Thread[] ths = new Thread[thCount];    final List<String> znodes = Collections.synchronizedList(new ArrayList<String>());    final CountDownLatch finished = new CountDownLatch(thCount);    for (int indx = 0; indx < thCount; indx++) {        final String myprefix = prefix + "-" + indx;        Thread th = new Thread() {            public void run() {                for (int i = 0; i < 1000; i++) {                    try {                        String mynode = myprefix + "-" + i;                        znodes.add(mynode);                        zk.create(mynode, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);                    } catch (Exception e) {                                            }                    if (i == 200) {                        doPurge.countDown();                    }                }                finished.countDown();            }        };        ths[indx] = th;    }    for (Thread thread : ths) {        thread.start();    }    try {        assertTrue("ZkClient ops is not finished!", finished.await(OP_TIMEOUT_IN_MILLIS, TimeUnit.MILLISECONDS));    } catch (InterruptedException ie) {                fail("Unexpected exception occurred!");    }    return znodes;}
run
public voidf4800_1)
{    for (int i = 0; i < 1000; i++) {        try {            String mynode = myprefix + "-" + i;            znodes.add(mynode);            zk.create(mynode, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        } catch (Exception e) {                    }        if (i == 200) {            doPurge.countDown();        }    }    finished.countDown();}
setUpSasl
public static void zookeeper_f4801_0() throws Exception
{    startMiniKdc();}
tearDownSasl
public static void zookeeper_f4802_0() throws Exception
{    stopMiniKdc();    FileUtils.deleteQuietly(workDir);}
startMiniKdc
public static void zookeeper_f4803_0() throws Exception
{    createTestDir();    createMiniKdcConf();    kdc = new MiniKdc(conf, workDir);    kdc.start();}
createTestDir
public static void zookeeper_f4804_0() throws IOException
{    workDir = createTmpDir(new File(System.getProperty("build.test.dir", "build")));}
createTmpDir
 static File zookeeper_f4805_0(File parentDir) throws IOException
{    File tmpFile = File.createTempFile("test", ".junit", parentDir);            File tmpDir = new File(tmpFile + ".dir");        assertFalse(tmpDir.exists());    assertTrue(tmpDir.mkdirs());    return tmpDir;}
createMiniKdcConf
public static void zookeeper_f4806_0()
{    conf = MiniKdc.createConf();}
stopMiniKdc
public static void zookeeper_f4807_0()
{    if (kdc != null) {        kdc.stop();    }}
getKdc
public static MiniKdc zookeeper_f4808_0()
{    return kdc;}
getWorkDir
public static File zookeeper_f4809_0()
{    return workDir;}
getConf
public static Properties zookeeper_f4810_0()
{    return conf;}
getRealm
public static String zookeeper_f4811_0()
{    return "EXAMPLE.COM";}
getLearnerPrincipal
public static String zookeeper_f4812_0()
{    return "learner@EXAMPLE.COM";}
getServerPrincipal
public static String zookeeper_f4813_0()
{    return "zkquorum/localhost@EXAMPLE.COM";}
getHostLearnerPrincipal
public static String zookeeper_f4814_0()
{    return "learner/_HOST@EXAMPLE.COM";}
getHostServerPrincipal
public static String zookeeper_f4815_0()
{    return "zkquorum/_HOST@EXAMPLE.COM";}
getHostNamedLearnerPrincipal
public static String zookeeper_f4816_0(String myHostname)
{    return "learner/" + myHostname + "@EXAMPLE.COM";}
getKeytabFile
public static String zookeeper_f4817_0()
{    return keytabFile;}
replaceHostPattern
public static String zookeeper_f4818_0(String principal)
{    String[] components = principal.split("[/@]");    if (components == null || components.length < 2 || !components[1].equals(SecurityUtils.QUORUM_HOSTNAME_PATTERN)) {        return principal;    } else {        return replacePattern(components, "localhost");    }}
replacePattern
public static String zookeeper_f4819_0(String[] components, String hostname)
{    if (components.length == 3) {        return components[0] + "/" + hostname.toLowerCase() + "@" + components[2];    } else {        return components[0] + "/" + hostname.toLowerCase();    }}
main
public static void zookeeper_f4820_0(String[] args) throws Exception
{    if (args.length < 4) {        System.out.println("Arguments: <WORKDIR> <MINIKDCPROPERTIES> " + "<KEYTABFILE> [<PRINCIPALS>]+");        System.exit(ExitCode.UNEXPECTED_ERROR.getValue());    }    File workDir = new File(args[0]);    if (!workDir.exists()) {        throw new RuntimeException("Specified work directory does not exists: " + workDir.getAbsolutePath());    }    Properties conf = createConf();    File file = new File(args[1]);    if (!file.exists()) {        throw new RuntimeException("Specified configuration does not exists: " + file.getAbsolutePath());    }    Properties userConf = new Properties();    InputStreamReader r = null;    try {        r = new InputStreamReader(new FileInputStream(file), StandardCharsets.UTF_8);        userConf.load(r);    } finally {        if (r != null) {            r.close();        }    }    for (Map.Entry<?, ?> entry : userConf.entrySet()) {        conf.put(entry.getKey(), entry.getValue());    }    final MiniKdc miniKdc = new MiniKdc(conf, workDir);    miniKdc.start();    File krb5conf = new File(workDir, "krb5.conf");    if (miniKdc.getKrb5conf().renameTo(krb5conf)) {        File keytabFile = new File(args[2]).getAbsoluteFile();        String[] principals = new String[args.length - 3];        System.arraycopy(args, 3, principals, 0, args.length - 3);        miniKdc.createPrincipal(keytabFile, principals);        System.out.println();        System.out.println("Standalone MiniKdc Running");        System.out.println("---------------------------------------------------");        System.out.println("  Realm           : " + miniKdc.getRealm());        System.out.println("  Running at      : " + miniKdc.getHost() + ":" + miniKdc.getHost());        System.out.println("  krb5conf        : " + krb5conf);        System.out.println();        System.out.println("  created keytab  : " + keytabFile);        System.out.println("  with principals : " + Arrays.asList(principals));        System.out.println();        System.out.println(" Do <CTRL-C> or kill <PID> to stop it");        System.out.println("---------------------------------------------------");        System.out.println();        Runtime.getRuntime().addShutdownHook(new Thread() {            @Override            public void run() {                miniKdc.stop();            }        });    } else {        throw new RuntimeException("Cannot rename KDC's krb5conf to " + krb5conf.getAbsolutePath());    }}
run
public void zookeeper_f4821_0()
{    miniKdc.stop();}
createConf
public static Properties zookeeper_f4822_0()
{    return (Properties) DEFAULT_CONFIG.clone();}
setTransport
public void zookeeper_f4823_0(String transport)
{    this.transport = transport;}
getPort
public int zookeeper_f4824_0()
{    return port;}
getHost
public String zookeeper_f4825_0()
{    return conf.getProperty(KDC_BIND_ADDRESS);}
getRealm
public String zookeeper_f4826_0()
{    return realm;}
getKrb5conf
public File zookeeper_f4827_0()
{    krb5conf = new File(System.getProperty(JAVA_SECURITY_KRB5_CONF));    return krb5conf;}
start
public synchronized voidf4828_1) throws Exception
{    if (simpleKdc != null) {        throw new RuntimeException("Already started");    }    simpleKdc = new SimpleKdcServer();    prepareKdcServer();    simpleKdc.init();    resetDefaultRealm();    simpleKdc.start();    }
resetDefaultRealm
private void zookeeper_f4829_0() throws IOException
{    InputStream templateResource = new FileInputStream(getKrb5conf().getAbsolutePath());    String content = IOUtil.readInput(templateResource);    content = content.replaceAll("default_realm = .*\n", "default_realm = " + getRealm() + "\n");    IOUtil.writeFile(content, getKrb5conf());}
prepareKdcServer
private void zookeeper_f4830_0() throws Exception
{        simpleKdc.setWorkDir(workDir);    simpleKdc.setKdcHost(getHost());    simpleKdc.setKdcRealm(realm);    if (transport == null) {        transport = conf.getProperty(TRANSPORT);    }    if (port == 0) {        port = NetworkUtil.getServerPort();    }    if (transport != null) {        if (transport.trim().equals("TCP")) {            simpleKdc.setKdcTcpPort(port);            simpleKdc.setAllowUdp(false);        } else if (transport.trim().equals("UDP")) {            simpleKdc.setKdcUdpPort(port);            simpleKdc.setAllowTcp(false);        } else {            throw new IllegalArgumentException("Invalid transport: " + transport);        }    } else {        throw new IllegalArgumentException("Need to set transport!");    }    simpleKdc.getKdcConfig().setString(KdcConfigKey.KDC_SERVICE_NAME, conf.getProperty(INSTANCE));    if (conf.getProperty(DEBUG) != null) {        krb5Debug = getAndSet(SUN_SECURITY_KRB5_DEBUG, conf.getProperty(DEBUG));    }}
stop
public synchronized voidf4831_1)
{    if (simpleKdc != null) {        try {            simpleKdc.stop();        } catch (KrbException e) {            e.printStackTrace();        } finally {            if (conf.getProperty(DEBUG) != null) {                System.setProperty(SUN_SECURITY_KRB5_DEBUG, Boolean.toString(krb5Debug));            }        }    }    delete(workDir);    try {                Thread.sleep(1000);    } catch (InterruptedException e) {        e.printStackTrace();    }    }
delete
private voidf4832_1File f)
{    if (f.isFile()) {        if (!f.delete()) {                    }    } else {        for (File c : f.listFiles()) {            delete(c);        }        if (!f.delete()) {                    }    }}
createPrincipal
public synchronized void zookeeper_f4833_0(String principal, String password) throws Exception
{    simpleKdc.createPrincipal(principal, password);}
createPrincipal
public synchronized voidf4834_1File keytabFile, String... principals) throws Exception
{    simpleKdc.createPrincipals(principals);    if (keytabFile.exists() && !keytabFile.delete()) {            }    for (String principal : principals) {        simpleKdc.getKadmin().exportKeytab(keytabFile, principal);    }}
getAndSet
private boolean zookeeper_f4835_0(String sysprop, String debug)
{    boolean old = Boolean.getBoolean(sysprop);    System.setProperty(sysprop, debug);    return old;}
testMiniKdcStart
public void zookeeper_f4836_0()
{    MiniKdc kdc = getKdc();    assertNotSame(0, kdc.getPort());}
testKeytabGen
public void zookeeper_f4837_0() throws Exception
{    MiniKdc kdc = getKdc();    File workDir = getWorkDir();    kdc.createPrincipal(new File(workDir, "keytab"), "foo/bar", "bar/foo");    List<PrincipalName> principalNameList = Keytab.loadKeytab(new File(workDir, "keytab")).getPrincipals();    Set<String> principals = new HashSet<String>();    for (PrincipalName principalName : principalNameList) {        principals.add(principalName.getName());    }    assertEquals(new HashSet<>(Arrays.asList("foo/bar@" + kdc.getRealm(), "bar/foo@" + kdc.getRealm())), principals);}
createClientConfig
public static Configuration zookeeper_f4838_0(String principal, File keytab)
{    return new KerberosConfiguration(principal, keytab, true);}
createServerConfig
public static Configuration zookeeper_f4839_0(String principal, File keytab)
{    return new KerberosConfiguration(principal, keytab, false);}
getKrb5LoginModuleName
private static String zookeeper_f4840_0()
{    return System.getProperty("java.vendor").contains("IBM") ? "com.ibm.security.auth.module.Krb5LoginModule" : "com.sun.security.auth.module.Krb5LoginModule";}
getAppConfigurationEntry
public AppConfigurationEntry[] zookeeper_f4841_0(String name)
{    Map<String, String> options = new HashMap<String, String>();    options.put("principal", principal);    options.put("refreshKrb5Config", "true");    if (IBM_JAVA) {        options.put("useKeytab", keytab);        options.put("credsType", "both");    } else {        options.put("keyTab", keytab);        options.put("useKeyTab", "true");        options.put("storeKey", "true");        options.put("doNotPrompt", "true");        options.put("useTicketCache", "true");        options.put("renewTGT", "true");        options.put("isInitiator", Boolean.toString(isInitiator));    }    String ticketCache = System.getenv("KRB5CCNAME");    if (ticketCache != null) {        options.put("ticketCache", ticketCache);    }    options.put("debug", "true");    return new AppConfigurationEntry[] { new AppConfigurationEntry(getKrb5LoginModuleName(), AppConfigurationEntry.LoginModuleControlFlag.REQUIRED, options) };}
testKerberosLogin
public void zookeeper_f4842_0() throws Exception
{    MiniKdc kdc = getKdc();    File workDir = getWorkDir();    LoginContext loginContext = null;    try {        String principal = "foo";        File keytab = new File(workDir, "foo.keytab");        kdc.createPrincipal(keytab, principal);        Set<Principal> principals = new HashSet<Principal>();        principals.add(new KerberosPrincipal(principal));                Subject subject = new Subject(false, principals, new HashSet<Object>(), new HashSet<Object>());        loginContext = new LoginContext("", subject, null, KerberosConfiguration.createClientConfig(principal, keytab));        loginContext.login();        subject = loginContext.getSubject();        assertEquals(1, subject.getPrincipals().size());        assertEquals(KerberosPrincipal.class, subject.getPrincipals().iterator().next().getClass());        assertEquals(principal + "@" + kdc.getRealm(), subject.getPrincipals().iterator().next().getName());        loginContext.logout();                subject = new Subject(false, principals, new HashSet<Object>(), new HashSet<Object>());        loginContext = new LoginContext("", subject, null, KerberosConfiguration.createServerConfig(principal, keytab));        loginContext.login();        subject = loginContext.getSubject();        assertEquals(1, subject.getPrincipals().size());        assertEquals(KerberosPrincipal.class, subject.getPrincipals().iterator().next().getClass());        assertEquals(principal + "@" + kdc.getRealm(), subject.getPrincipals().iterator().next().getName());        loginContext.logout();    } finally {        if (loginContext != null && loginContext.getSubject() != null && !loginContext.getSubject().getPrincipals().isEmpty()) {            loginContext.logout();        }    }}
setupJaasConfig
public static voidf4843_1String jaasEntries)
{    try {        jaasConfigDir = ClientBase.createTmpDir();        File saslConfFile = new File(jaasConfigDir, "jaas.conf");        FileWriter fwriter = new FileWriter(saslConfFile);        fwriter.write(jaasEntries);        fwriter.close();        System.setProperty("java.security.auth.login.config", saslConfFile.getAbsolutePath());    } catch (IOException ioe) {                    }}
cleanupJaasConfig
public static void zookeeper_f4844_0()
{    if (jaasConfigDir != null) {        FileUtils.deleteQuietly(jaasConfigDir);    }}
startQuorum
protected String zookeeper_f4845_0(final int serverCount, Map<String, String> authConfigs, int authServerCount) throws IOException
{    StringBuilder connectStr = new StringBuilder();    final int[] clientPorts = startQuorum(serverCount, connectStr, authConfigs, authServerCount);    for (int i = 0; i < serverCount; i++) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts[i], ClientBase.CONNECTION_TIMEOUT));    }    return connectStr.toString();}
startQuorum
protected int[] zookeeper_f4846_0(final int serverCount, StringBuilder connectStr, Map<String, String> authConfigs, int authServerCount) throws IOException
{    final int[] clientPorts = new int[serverCount];    StringBuilder sb = new StringBuilder();    for (int i = 0; i < serverCount; i++) {        clientPorts[i] = PortAssignment.unique();        String server = String.format("server.%d=localhost:%d:%d:participant", i, PortAssignment.unique(), PortAssignment.unique());        sb.append(server + "\n");        connectStr.append("127.0.0.1:" + clientPorts[i]);        if (i < serverCount - 1) {            connectStr.append(",");        }    }    String quorumCfg = sb.toString();        int i = 0;    for (; i < authServerCount; i++) {        startServer(authConfigs, clientPorts, quorumCfg, i);    }        for (int j = 0; j < serverCount - authServerCount; j++, i++) {        MainThread mthread = new MainThread(i, clientPorts[i], quorumCfg);        mt.add(mthread);        mthread.start();    }    return clientPorts;}
startServer
private void zookeeper_f4847_0(Map<String, String> authConfigs, final int[] clientPorts, String quorumCfg, int i) throws IOException
{    MainThread mthread = new MainThread(i, clientPorts[i], quorumCfg, authConfigs);    mt.add(mthread);    mthread.start();}
startServer
protected void zookeeper_f4848_0(MainThread restartPeer, Map<String, String> authConfigs) throws IOException
{    MainThread mthread = new MainThread(restartPeer.getMyid(), restartPeer.getClientPort(), restartPeer.getQuorumCfgSection(), authConfigs);    mt.add(mthread);    mthread.start();}
shutdownAll
 void zookeeper_f4849_0()
{    for (int i = 0; i < mt.size(); i++) {        shutdown(i);    }}
shutdown
 MainThread zookeeper_f4850_0(int index)
{    MainThread mainThread = mt.get(index);    try {        mainThread.shutdown();    } catch (InterruptedException e) {        } finally {        mt.remove(index);    }    mainThread.deleteBaseDir();    return mainThread;}
tearDown
public void zookeeper_f4851_0() throws Exception
{    shutdownAll();}
cleanup
public static void zookeeper_f4852_0()
{    cleanupJaasConfig();}
testNullAuthLearnerServer
public void zookeeper_f4853_0() throws Exception
{    Map<String, String> authConfigs = new HashMap<String, String>();    authConfigs.put(QuorumAuth.QUORUM_SASL_AUTH_ENABLED, "false");    String connectStr = startQuorum(2, authConfigs, 0);    CountdownWatcher watcher = new CountdownWatcher();    ZooKeeper zk = new ZooKeeper(connectStr, ClientBase.CONNECTION_TIMEOUT, watcher);    watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT);    zk.create("/foo", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.close();}
testAuthLearnerAgainstNullAuthServer
public void zookeeper_f4854_0() throws Exception
{    Map<String, String> authConfigs = new HashMap<String, String>();    authConfigs.put(QuorumAuth.QUORUM_SASL_AUTH_ENABLED, "true");    String connectStr = startQuorum(2, authConfigs, 1);    CountdownWatcher watcher = new CountdownWatcher();    ZooKeeper zk = new ZooKeeper(connectStr, ClientBase.CONNECTION_TIMEOUT, watcher);    watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT);    zk.create("/foo", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.close();}
testAuthLearnerAgainstNoAuthRequiredServer
public void zookeeper_f4855_0() throws Exception
{    Map<String, String> authConfigs = new HashMap<String, String>();    authConfigs.put(QuorumAuth.QUORUM_SASL_AUTH_ENABLED, "true");    String connectStr = startQuorum(2, authConfigs, 2);    CountdownWatcher watcher = new CountdownWatcher();    ZooKeeper zk = new ZooKeeper(connectStr, ClientBase.CONNECTION_TIMEOUT, watcher);    watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT);    zk.create("/foo", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.close();}
testAuthLearnerServer
public void zookeeper_f4856_0() throws Exception
{    Map<String, String> authConfigs = new HashMap<String, String>();    authConfigs.put(QuorumAuth.QUORUM_SASL_AUTH_ENABLED, "true");    authConfigs.put(QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED, "true");    authConfigs.put(QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED, "true");    String connectStr = startQuorum(2, authConfigs, 2);    CountdownWatcher watcher = new CountdownWatcher();    ZooKeeper zk = new ZooKeeper(connectStr, ClientBase.CONNECTION_TIMEOUT, watcher);    watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT);    zk.create("/foo", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.close();}
testRollingUpgrade
public void zookeeper_f4857_0() throws Exception
{                Map<String, String> authConfigs = new HashMap<String, String>();    authConfigs.put(QuorumAuth.QUORUM_SASL_AUTH_ENABLED, "false");    String connectStr = startQuorum(3, authConfigs, 0);    CountdownWatcher watcher = new CountdownWatcher();    ZooKeeper zk = new ZooKeeper(connectStr, ClientBase.CONNECTION_TIMEOUT, watcher);    watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT);    zk.create("/foo", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);            authConfigs.put(QuorumAuth.QUORUM_SASL_AUTH_ENABLED, "true");    authConfigs.put(QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED, "false");    authConfigs.put(QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED, "false");    restartServer(authConfigs, 0, zk, watcher);    restartServer(authConfigs, 1, zk, watcher);    restartServer(authConfigs, 2, zk, watcher);            authConfigs.put(QuorumAuth.QUORUM_SASL_AUTH_ENABLED, "true");    authConfigs.put(QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED, "true");    authConfigs.put(QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED, "false");    restartServer(authConfigs, 0, zk, watcher);    restartServer(authConfigs, 1, zk, watcher);    restartServer(authConfigs, 2, zk, watcher);            authConfigs.put(QuorumAuth.QUORUM_SASL_AUTH_ENABLED, "true");    authConfigs.put(QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED, "true");    authConfigs.put(QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED, "true");    restartServer(authConfigs, 0, zk, watcher);    restartServer(authConfigs, 1, zk, watcher);    restartServer(authConfigs, 2, zk, watcher);                authConfigs.put(QuorumAuth.QUORUM_SASL_AUTH_ENABLED, "false");    MainThread m = shutdown(2);    startServer(m, authConfigs);    assertFalse("waiting for server 2 being up", ClientBase.waitForServerUp("127.0.0.1:" + m.getClientPort(), 5000));}
restartServer
private voidf4858_1Map<String, String> authConfigs, int index, ZooKeeper zk, CountdownWatcher watcher) throws IOException, KeeperException, InterruptedException, TimeoutException
{        MainThread m = shutdown(index);    startServer(m, authConfigs);    assertTrue("waiting for server" + index + "being up", ClientBase.waitForServerUp("127.0.0.1:" + m.getClientPort(), ClientBase.CONNECTION_TIMEOUT));    watcher.waitForConnected(ClientTest.CONNECTION_TIMEOUT);    zk.create("/foo", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);}
tearDown
public void zookeeper_f4859_0() throws Exception
{    for (MainThread mainThread : mt) {        mainThread.shutdown();        mainThread.deleteBaseDir();    }}
cleanup
public static void zookeeper_f4860_0()
{    cleanupJaasConfig();}
testValidCredentials
public void zookeeper_f4861_0() throws Exception
{    Map<String, String> authConfigs = new HashMap<String, String>();    authConfigs.put(QuorumAuth.QUORUM_SASL_AUTH_ENABLED, "true");    authConfigs.put(QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED, "true");    authConfigs.put(QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED, "true");    String connectStr = startQuorum(3, authConfigs, 3);    CountdownWatcher watcher = new CountdownWatcher();    ZooKeeper zk = new ZooKeeper(connectStr, ClientBase.CONNECTION_TIMEOUT, watcher);    watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT);    for (int i = 0; i < 10; i++) {        zk.create("/" + i, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    }    zk.close();}
testSaslNotRequiredWithInvalidCredentials
public void zookeeper_f4862_0() throws Exception
{    Map<String, String> authConfigs = new HashMap<String, String>();    authConfigs.put(QuorumAuth.QUORUM_LEARNER_SASL_LOGIN_CONTEXT, "QuorumLearnerInvalid");    authConfigs.put(QuorumAuth.QUORUM_SASL_AUTH_ENABLED, "false");    authConfigs.put(QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED, "false");    String connectStr = startQuorum(3, authConfigs, 3);    CountdownWatcher watcher = new CountdownWatcher();    ZooKeeper zk = new ZooKeeper(connectStr, ClientBase.CONNECTION_TIMEOUT, watcher);    watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT);    for (int i = 0; i < 10; i++) {        zk.create("/" + i, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    }    zk.close();}
testSaslRequiredInvalidCredentials
public void zookeeper_f4863_0() throws Exception
{    Map<String, String> authConfigs = new HashMap<String, String>();    authConfigs.put(QuorumAuth.QUORUM_LEARNER_SASL_LOGIN_CONTEXT, "QuorumLearnerInvalid");    authConfigs.put(QuorumAuth.QUORUM_SASL_AUTH_ENABLED, "true");    authConfigs.put(QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED, "true");    authConfigs.put(QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED, "true");    int serverCount = 2;    final int[] clientPorts = startQuorum(serverCount, new StringBuilder(), authConfigs, serverCount);    for (int i = 0; i < serverCount; i++) {        boolean waitForServerUp = ClientBase.waitForServerUp("127.0.0.1:" + clientPorts[i], QuorumPeerTestBase.TIMEOUT);        assertFalse("Shouldn't start server with invalid credentials", waitForServerUp);    }}
testEnableQuorumServerRequireSaslWithoutQuorumLearnerRequireSasl
public void zookeeper_f4864_0() throws Exception
{    Map<String, String> authConfigs = new HashMap<String, String>();    authConfigs.put(QuorumAuth.QUORUM_LEARNER_SASL_LOGIN_CONTEXT, "QuorumLearner");    authConfigs.put(QuorumAuth.QUORUM_SASL_AUTH_ENABLED, "true");    authConfigs.put(QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED, "true");    authConfigs.put(QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED, "false");    MainThread mthread = new MainThread(1, PortAssignment.unique(), "", authConfigs);    String[] args = new String[1];    args[0] = mthread.getConfFile().toString();    try {        new QuorumPeerMain() {            @Override            protected void initializeAndRun(String[] args) throws ConfigException, IOException, AdminServer.AdminServerException {                super.initializeAndRun(args);            }        }.initializeAndRun(args);        fail("Must throw exception as quorumpeer learner is not enabled!");    } catch (ConfigException e) {        }}
initializeAndRun
protected void zookeeper_f4865_0(String[] args) throws ConfigException, IOException, AdminServer.AdminServerException
{    super.initializeAndRun(args);}
testEnableQuorumAuthenticationConfigurations
public void zookeeper_f4866_0() throws Exception
{    Map<String, String> authConfigs = new HashMap<String, String>();    authConfigs.put(QuorumAuth.QUORUM_LEARNER_SASL_LOGIN_CONTEXT, "QuorumLearner");    authConfigs.put(QuorumAuth.QUORUM_SASL_AUTH_ENABLED, "false");        authConfigs.put(QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED, "true");    authConfigs.put(QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED, "false");    MainThread mthread = new MainThread(1, PortAssignment.unique(), "", authConfigs);    String[] args = new String[1];    args[0] = mthread.getConfFile().toString();    try {        new QuorumPeerMain() {            @Override            protected void initializeAndRun(String[] args) throws ConfigException, IOException, AdminServer.AdminServerException {                super.initializeAndRun(args);            }        }.initializeAndRun(args);        fail("Must throw exception as quorum sasl is not enabled!");    } catch (ConfigException e) {        }        authConfigs.put(QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED, "false");    authConfigs.put(QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED, "true");    try {        new QuorumPeerMain() {            @Override            protected void initializeAndRun(String[] args) throws ConfigException, IOException, AdminServer.AdminServerException {                super.initializeAndRun(args);            }        }.initializeAndRun(args);        fail("Must throw exception as quorum sasl is not enabled!");    } catch (ConfigException e) {        }}
initializeAndRun
protected void zookeeper_f4867_0(String[] args) throws ConfigException, IOException, AdminServer.AdminServerException
{    super.initializeAndRun(args);}
initializeAndRun
protected void zookeeper_f4868_0(String[] args) throws ConfigException, IOException, AdminServer.AdminServerException
{    super.initializeAndRun(args);}
setUp
public void zookeeper_f4869_0() throws Exception
{        keytabFile = new File(KerberosTestUtils.getKeytabFile());    String learnerPrincipal = KerberosTestUtils.getLearnerPrincipal();    String serverPrincipal = KerberosTestUtils.getServerPrincipal();    learnerPrincipal = learnerPrincipal.substring(0, learnerPrincipal.lastIndexOf("@"));    serverPrincipal = serverPrincipal.substring(0, serverPrincipal.lastIndexOf("@"));    getKdc().createPrincipal(keytabFile, learnerPrincipal, serverPrincipal);}
tearDown
public void zookeeper_f4870_0() throws Exception
{    for (MainThread mainThread : mt) {        mainThread.shutdown();        mainThread.deleteBaseDir();    }}
cleanup
public static void zookeeper_f4871_0()
{    if (keytabFile != null) {        FileUtils.deleteQuietly(keytabFile);    }    cleanupJaasConfig();}
testValidCredentials
public void zookeeper_f4872_0() throws Exception
{    String serverPrincipal = KerberosTestUtils.getServerPrincipal();    serverPrincipal = serverPrincipal.substring(0, serverPrincipal.lastIndexOf("@"));    Map<String, String> authConfigs = new HashMap<String, String>();    authConfigs.put(QuorumAuth.QUORUM_SASL_AUTH_ENABLED, "true");    authConfigs.put(QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED, "true");    authConfigs.put(QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED, "true");    authConfigs.put(QuorumAuth.QUORUM_KERBEROS_SERVICE_PRINCIPAL, serverPrincipal);    String connectStr = startQuorum(3, authConfigs, 3);    CountdownWatcher watcher = new CountdownWatcher();    ZooKeeper zk = new ZooKeeper(connectStr, ClientBase.CONNECTION_TIMEOUT, watcher);    watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT);    for (int i = 0; i < 10; i++) {        zk.create("/" + i, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    }    zk.close();}
setupJaasConfigEntries
private static void zookeeper_f4873_0(String hostServerPrincipal, String hostLearnerPrincipal, String hostNamedLearnerPrincipal)
{    String keytabFilePath = FilenameUtils.normalize(KerberosTestUtils.getKeytabFile(), true);    String jaasEntries = "QuorumServer {\n" + "       com.sun.security.auth.module.Krb5LoginModule required\n" + "       useKeyTab=true\n" + "       keyTab=\"" + keytabFilePath + "\"\n" + "       storeKey=true\n" + "       useTicketCache=false\n" + "       debug=false\n" + "       principal=\"" + KerberosTestUtils.replaceHostPattern(hostServerPrincipal) + "\";\n" + "};\n" + "QuorumLearner {\n" + "       com.sun.security.auth.module.Krb5LoginModule required\n" + "       useKeyTab=true\n" + "       keyTab=\"" + keytabFilePath + "\"\n" + "       storeKey=true\n" + "       useTicketCache=false\n" + "       debug=false\n" + "       principal=\"" + KerberosTestUtils.replaceHostPattern(hostLearnerPrincipal) + "\";\n" + "};\n" + "QuorumLearnerMyHost {\n" + "       com.sun.security.auth.module.Krb5LoginModule required\n" + "       useKeyTab=true\n" + "       keyTab=\"" + keytabFilePath + "\"\n" + "       storeKey=true\n" + "       useTicketCache=false\n" + "       debug=false\n" + "       principal=\"" + hostNamedLearnerPrincipal + "\";\n" + "};\n";    setupJaasConfig(jaasEntries);}
setUp
public static void zookeeper_f4874_0() throws Exception
{        keytabFile = new File(KerberosTestUtils.getKeytabFile());        String learnerPrincipal = hostLearnerPrincipal.substring(0, hostLearnerPrincipal.lastIndexOf("@"));    learnerPrincipal = KerberosTestUtils.replaceHostPattern(learnerPrincipal);    String serverPrincipal = hostServerPrincipal.substring(0, hostServerPrincipal.lastIndexOf("@"));    serverPrincipal = KerberosTestUtils.replaceHostPattern(serverPrincipal);        String learnerPrincipal2 = hostNamedLearnerPrincipal.substring(0, hostNamedLearnerPrincipal.lastIndexOf("@"));    getKdc().createPrincipal(keytabFile, learnerPrincipal, learnerPrincipal2, serverPrincipal);}
tearDown
public void zookeeper_f4875_0() throws Exception
{    for (MainThread mainThread : mt) {        mainThread.shutdown();        mainThread.deleteBaseDir();    }}
cleanup
public static void zookeeper_f4876_0()
{    if (keytabFile != null) {        FileUtils.deleteQuietly(keytabFile);    }    cleanupJaasConfig();}
testValidCredentials
public void zookeeper_f4877_0() throws Exception
{    String serverPrincipal = hostServerPrincipal.substring(0, hostServerPrincipal.lastIndexOf("@"));    Map<String, String> authConfigs = new HashMap<String, String>();    authConfigs.put(QuorumAuth.QUORUM_SASL_AUTH_ENABLED, "true");    authConfigs.put(QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED, "true");    authConfigs.put(QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED, "true");    authConfigs.put(QuorumAuth.QUORUM_KERBEROS_SERVICE_PRINCIPAL, serverPrincipal);    String connectStr = startQuorum(3, authConfigs, 3);    CountdownWatcher watcher = new CountdownWatcher();    ZooKeeper zk = new ZooKeeper(connectStr, ClientBase.CONNECTION_TIMEOUT, watcher);    watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT);    for (int i = 0; i < 10; i++) {        zk.create("/" + i, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    }    zk.close();}
testConnectBadServer
public void zookeeper_f4878_0() throws Exception
{    String serverPrincipal = hostServerPrincipal.substring(0, hostServerPrincipal.lastIndexOf("@"));    Map<String, String> authConfigs = new HashMap<String, String>();    authConfigs.put(QuorumAuth.QUORUM_SASL_AUTH_ENABLED, "true");    authConfigs.put(QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED, "true");    authConfigs.put(QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED, "true");    authConfigs.put(QuorumAuth.QUORUM_KERBEROS_SERVICE_PRINCIPAL, serverPrincipal);    String connectStr = startQuorum(3, authConfigs, 3);    CountdownWatcher watcher = new CountdownWatcher();    ZooKeeper zk = new ZooKeeper(connectStr, ClientBase.CONNECTION_TIMEOUT, watcher);    watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT);    for (int i = 0; i < 10; i++) {        zk.create("/" + i, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    }    zk.close();    String quorumCfgSection = mt.get(0).getQuorumCfgSection();    StringBuilder sb = new StringBuilder();    sb.append(quorumCfgSection);    int myid = mt.size() + 1;    final int clientPort = PortAssignment.unique();    String server = String.format("server.%d=localhost:%d:%d:participant", myid, PortAssignment.unique(), PortAssignment.unique());    sb.append(server + "\n");    quorumCfgSection = sb.toString();    authConfigs.put(QuorumAuth.QUORUM_LEARNER_SASL_LOGIN_CONTEXT, "QuorumLearnerMyHost");    MainThread badServer = new MainThread(myid, clientPort, quorumCfgSection, authConfigs);    badServer.start();    watcher = new CountdownWatcher();    connectStr = "127.0.0.1:" + clientPort;    zk = new ZooKeeper(connectStr, ClientBase.CONNECTION_TIMEOUT, watcher);    try {        watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT / 3);        fail("Must throw exception as the myHost is not an authorized one!");    } catch (TimeoutException e) {        } finally {        zk.close();        badServer.shutdown();        badServer.deleteBaseDir();    }}
testSetProposalSizeSetMinMax
public void zookeeper_f4879_0()
{    BufferStats stats = new BufferStats();    assertEquals(-1, stats.getLastBufferSize());    assertEquals(-1, stats.getMinBufferSize());    assertEquals(-1, stats.getMaxBufferSize());    stats.setLastBufferSize(10);    assertEquals(10, stats.getLastBufferSize());    assertEquals(10, stats.getMinBufferSize());    assertEquals(10, stats.getMaxBufferSize());    stats.setLastBufferSize(20);    assertEquals(20, stats.getLastBufferSize());    assertEquals(10, stats.getMinBufferSize());    assertEquals(20, stats.getMaxBufferSize());    stats.setLastBufferSize(5);    assertEquals(5, stats.getLastBufferSize());    assertEquals(5, stats.getMinBufferSize());    assertEquals(20, stats.getMaxBufferSize());}
testReset
public void zookeeper_f4880_0()
{    BufferStats stats = new BufferStats();    stats.setLastBufferSize(10);    assertEquals(10, stats.getLastBufferSize());    assertEquals(10, stats.getMinBufferSize());    assertEquals(10, stats.getMaxBufferSize());    stats.reset();    assertEquals(-1, stats.getLastBufferSize());    assertEquals(-1, stats.getMinBufferSize());    assertEquals(-1, stats.getMaxBufferSize());}
testCloseSessionTxnCompatile
public void zookeeper_f4881_0() throws Exception
{            testCloseSessionWithDifferentConfig(false, false);        testCloseSessionWithDifferentConfig(false, true);        testCloseSessionWithDifferentConfig(true, false);        testCloseSessionWithDifferentConfig(true, true);}
testCloseSessionWithDifferentConfig
private void zookeeper_f4882_0(boolean closeSessionEnabledOnLeader, boolean closeSessionEnabledOnFollower) throws Exception
{        final int numServers = 3;    servers = LaunchServers(numServers);    int leaderId = servers.findLeader();    ZooKeeperServer.setCloseSessionTxnEnabled(closeSessionEnabledOnLeader);                        int followerA = (leaderId + 1) % numServers;    servers.mt[followerA].shutdown();    waitForOne(servers.zk[followerA], States.CONNECTING);        String path = "/testCloseSessionTxnCompatile";    servers.zk[leaderId].create(path, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);        servers.restartClient(leaderId, this);    waitForOne(servers.zk[leaderId], States.CONNECTED);            System.setProperty("zookeeper.retainZKDatabase", "true");    ZooKeeperServer.setCloseSessionTxnEnabled(closeSessionEnabledOnFollower);        servers.mt[followerA].start();    waitForOne(servers.zk[followerA], States.CONNECTED);        for (int i = 0; i < numServers; i++) {        final CountDownLatch syncedLatch = new CountDownLatch(1);        servers.zk[i].sync(path, new AsyncCallback.VoidCallback() {            @Override            public void processResult(int rc, String path, Object ctx) {                syncedLatch.countDown();            }        }, null);        Assert.assertTrue(syncedLatch.await(3, TimeUnit.SECONDS));        Assert.assertNull(servers.zk[i].exists(path, false));    }}
processResult
public void zookeeper_f4883_0(int rc, String path, Object ctx)
{    syncedLatch.countDown();}
setUp
public void zookeeper_f4884_0() throws Exception
{    this.count = 3;    this.peers = new HashMap<Long, QuorumServer>(count);    peerTmpdir = new File[count];    peerQuorumPort = new int[count];    peerClientPort = new int[count];    for (int i = 0; i < count; i++) {        peerQuorumPort[i] = PortAssignment.unique();        peerClientPort[i] = PortAssignment.unique();        peers.put((long) i, new QuorumServer(i, new InetSocketAddress("127.0.0.1", peerQuorumPort[i]), new InetSocketAddress("127.0.0.1", PortAssignment.unique()), new InetSocketAddress("127.0.0.1", peerClientPort[i])));        peerTmpdir[i] = ClientBase.createTmpDir();    }}
createMsg
 ByteBuffer zookeeper_f4885_0(int state, long leader, long zxid, long epoch)
{    byte[] requestBytes = new byte[28];    ByteBuffer requestBuffer = ByteBuffer.wrap(requestBytes);    /*         * Building notification packet to send         */    requestBuffer.clear();    requestBuffer.putInt(state);    requestBuffer.putLong(leader);    requestBuffer.putLong(zxid);    requestBuffer.putLong(epoch);    return requestBuffer;}
run
public voidf4886_1)
{    try {        QuorumPeer peer = new QuorumPeer(peers, peerTmpdir[0], peerTmpdir[0], peerClientPort[0], 3, 0, 1000, 2, 2, 2);        QuorumCnxManager cnxManager = peer.createCnxnManager();        QuorumCnxManager.Listener listener = cnxManager.listener;        if (listener != null) {            listener.start();        } else {                    }        long sid = 1;        cnxManager.toSend(sid, createMsg(ServerState.LOOKING.ordinal(), 0, -1, 1));        Message m = null;        int numRetries = 1;        while ((m == null) && (numRetries++ <= THRESHOLD)) {            m = cnxManager.pollRecvQueue(3000, TimeUnit.MILLISECONDS);            if (m == null) {                cnxManager.connectAll();            }        }        if (numRetries > THRESHOLD) {            failed = true;            return;        }        cnxManager.testInitiateConnection(sid);        m = cnxManager.pollRecvQueue(3000, TimeUnit.MILLISECONDS);        if (m == null) {            failed = true;        }    } catch (Exception e) {                fail("Unexpected exception");    }}
testCnxManager
public voidf4887_1) throws Exception
{    CnxManagerThread thread = new CnxManagerThread();    thread.start();    QuorumPeer peer = new QuorumPeer(peers, peerTmpdir[1], peerTmpdir[1], peerClientPort[1], 3, 1, 1000, 2, 2, 2);    QuorumCnxManager cnxManager = peer.createCnxnManager();    QuorumCnxManager.Listener listener = cnxManager.listener;    if (listener != null) {        listener.start();    } else {            }    cnxManager.toSend(0L, createMsg(ServerState.LOOKING.ordinal(), 1, -1, 1));    Message m = null;    int numRetries = 1;    while ((m == null) && (numRetries++ <= THRESHOLD)) {        m = cnxManager.pollRecvQueue(3000, TimeUnit.MILLISECONDS);        if (m == null) {            cnxManager.connectAll();        }    }    assertTrue("Exceeded number of retries", numRetries <= THRESHOLD);    thread.join(5000);    if (thread.isAlive()) {        fail("Thread didn't join");    } else {        if (thread.failed) {            fail("Did not receive expected message");        }    }    cnxManager.halt();    assertFalse(cnxManager.listener.isAlive());}
testCnxManagerTimeout
public voidf4888_1) throws Exception
{    Random rand = new Random();    byte b = (byte) rand.nextInt();    int deadPort = PortAssignment.unique();    String deadAddress = "10.1.1." + b;        peers.put(2L, new QuorumServer(2, new InetSocketAddress(deadAddress, deadPort), new InetSocketAddress(deadAddress, PortAssignment.unique()), new InetSocketAddress(deadAddress, PortAssignment.unique())));    peerTmpdir[2] = ClientBase.createTmpDir();    QuorumPeer peer = new QuorumPeer(peers, peerTmpdir[1], peerTmpdir[1], peerClientPort[1], 3, 1, 1000, 2, 2, 2);    QuorumCnxManager cnxManager = peer.createCnxnManager();    QuorumCnxManager.Listener listener = cnxManager.listener;    if (listener != null) {        listener.start();    } else {            }    long begin = Time.currentElapsedTime();    cnxManager.toSend(2L, createMsg(ServerState.LOOKING.ordinal(), 1, -1, 1));    long end = Time.currentElapsedTime();    if ((end - begin) > 6000) {        fail("Waited more than necessary");    }    cnxManager.halt();    assertFalse(cnxManager.listener.isAlive());}
testCnxManagerSpinLock
public voidf4889_1) throws Exception
{    QuorumPeer peer = new QuorumPeer(peers, peerTmpdir[1], peerTmpdir[1], peerClientPort[1], 3, 1, 1000, 2, 2, 2);    QuorumCnxManager cnxManager = peer.createCnxnManager();    QuorumCnxManager.Listener listener = cnxManager.listener;    if (listener != null) {        listener.start();    } else {            }    int port = peers.get(peer.getId()).electionAddr.getPort();        Thread.sleep(1000);    SocketChannel sc = SocketChannel.open();    sc.socket().connect(peers.get(1L).electionAddr, 5000);    InetSocketAddress otherAddr = peers.get(Long.valueOf(2)).electionAddr;    DataOutputStream dout = new DataOutputStream(sc.socket().getOutputStream());    dout.writeLong(QuorumCnxManager.PROTOCOL_VERSION);    dout.writeLong(2);    String addr = otherAddr.getHostString() + ":" + otherAddr.getPort();    byte[] addr_bytes = addr.getBytes();    dout.writeInt(addr_bytes.length);    dout.write(addr_bytes);    dout.flush();    ByteBuffer msgBuffer = ByteBuffer.wrap(new byte[4]);    msgBuffer.putInt(-20);    msgBuffer.position(0);    sc.write(msgBuffer);    Thread.sleep(1000);    try {        /*             * Write a number of times until it             * detects that the socket is broken.             */        for (int i = 0; i < 100; i++) {            msgBuffer.position(0);            sc.write(msgBuffer);        }        fail("Socket has not been closed");    } catch (Exception e) {            }    peer.shutdown();    cnxManager.halt();    assertFalse(cnxManager.listener.isAlive());}
testCnxManagerListenerThreadConfigurableRetry
public void zookeeper_f4890_0() throws Exception
{    final Map<Long, QuorumServer> unresolvablePeers = new HashMap<>();    final long myid = 1L;    unresolvablePeers.put(myid, new QuorumServer(myid, "unresolvable-domain.org:2182:2183;2181"));    final QuorumPeer peer = new QuorumPeer(unresolvablePeers, ClientBase.createTmpDir(), ClientBase.createTmpDir(), 2181, 3, myid, 1000, 2, 2, 2);    final QuorumCnxManager cnxManager = peer.createCnxnManager();    final QuorumCnxManager.Listener listener = cnxManager.listener;    final AtomicBoolean errorHappend = new AtomicBoolean();    listener.setSocketBindErrorHandler(() -> errorHappend.set(true));    listener.start();                listener.join(15000);    assertFalse(listener.isAlive());    assertTrue(errorHappend.get());    assertFalse(QuorumPeer.class.getSimpleName() + " not stopped after " + "listener thread death", listener.isAlive());}
testCnxManagerNPE
public voidf4891_1) throws Exception
{        peers.get(2L).type = LearnerType.OBSERVER;    QuorumPeer peer = new QuorumPeer(peers, peerTmpdir[1], peerTmpdir[1], peerClientPort[1], 3, 1, 1000, 2, 2, 2);    QuorumCnxManager cnxManager = peer.createCnxnManager();    QuorumCnxManager.Listener listener = cnxManager.listener;    if (listener != null) {        listener.start();    } else {            }    int port = peers.get(peer.getId()).electionAddr.getPort();        Thread.sleep(1000);    SocketChannel sc = SocketChannel.open();    sc.socket().connect(peers.get(1L).electionAddr, 5000);    /*         * Write id (3.4.6 protocol). This previously caused a NPE in         * QuorumCnxManager.         */    byte[] msgBytes = new byte[8];    ByteBuffer msgBuffer = ByteBuffer.wrap(msgBytes);    msgBuffer.putLong(2L);    msgBuffer.position(0);    sc.write(msgBuffer);    msgBuffer = ByteBuffer.wrap(new byte[8]);        msgBuffer.putInt(4);        msgBuffer.putInt(5);    msgBuffer.position(0);    sc.write(msgBuffer);    Message m = cnxManager.pollRecvQueue(1000, TimeUnit.MILLISECONDS);    assertNotNull(m);    peer.shutdown();    cnxManager.halt();    assertFalse(cnxManager.listener.isAlive());}
testSocketTimeout
public voidf4892_1) throws Exception
{    QuorumPeer peer = new QuorumPeer(peers, peerTmpdir[1], peerTmpdir[1], peerClientPort[1], 3, 1, 2000, 2, 2, 2);    QuorumCnxManager cnxManager = peer.createCnxnManager();    QuorumCnxManager.Listener listener = cnxManager.listener;    if (listener != null) {        listener.start();    } else {            }    int port = peers.get(peer.getId()).electionAddr.getPort();        Thread.sleep(1000);    Socket sock = new Socket();    sock.connect(peers.get(1L).electionAddr, 5000);    long begin = Time.currentElapsedTime();        cnxManager.receiveConnection(sock);    long end = Time.currentElapsedTime();    if ((end - begin) > ((peer.getSyncLimit() * peer.getTickTime()) + 500)) {        fail("Waited more than necessary");    }    cnxManager.halt();    assertFalse(cnxManager.listener.isAlive());}
testSSLSocketClosedWhenHandshakeTimeout
public void zookeeper_f4893_0() throws Exception
{    final CountDownLatch closeLatch = new CountDownLatch(1);    QuorumX509Util mockedX509Util = new QuorumX509Util() {        @Override        public SSLSocket createSSLSocket() {            return new SSLSocket() {                @Override                public void connect(SocketAddress endpoint, int timeout) {                }                @Override                public void startHandshake() throws IOException {                    throw new IOException();                }                @Override                public void close() {                    closeLatch.countDown();                }                public String[] getSupportedCipherSuites() {                    throw new UnsupportedOperationException();                }                public String[] getEnabledCipherSuites() {                    throw new UnsupportedOperationException();                }                public String[] getSupportedProtocols() {                    throw new UnsupportedOperationException();                }                public String[] getEnabledProtocols() {                    throw new UnsupportedOperationException();                }                public SSLSession getSession() {                    throw new UnsupportedOperationException();                }                public void setEnabledCipherSuites(String[] suites) {                }                public void setEnabledProtocols(String[] protocols) {                }                public void addHandshakeCompletedListener(HandshakeCompletedListener listener) {                }                public void removeHandshakeCompletedListener(HandshakeCompletedListener listener) {                }                public void setUseClientMode(boolean mode) {                }                public boolean getUseClientMode() {                    return true;                }                public void setNeedClientAuth(boolean need) {                }                public boolean getNeedClientAuth() {                    return true;                }                public void setWantClientAuth(boolean want) {                }                public boolean getWantClientAuth() {                    return true;                }                public void setEnableSessionCreation(boolean flag) {                }                public boolean getEnableSessionCreation() {                    return true;                }            };        }    };    QuorumPeer peer = new QuorumPeer(peers, peerTmpdir[0], peerTmpdir[0], peerClientPort[0], 3, 0, 2000, 2, 2, 2) {        @Override        public QuorumX509Util createX509Util() {            return mockedX509Util;        }    };    peer.setSslQuorum(true);    QuorumCnxManager cnxManager = peer.createCnxnManager();    cnxManager.connectOne(1, peers.get(1L).electionAddr);    assertTrue(closeLatch.await(1, TimeUnit.SECONDS));}
createSSLSocket
public SSLSocket zookeeper_f4894_0()
{    return new SSLSocket() {        @Override        public void connect(SocketAddress endpoint, int timeout) {        }        @Override        public void startHandshake() throws IOException {            throw new IOException();        }        @Override        public void close() {            closeLatch.countDown();        }        public String[] getSupportedCipherSuites() {            throw new UnsupportedOperationException();        }        public String[] getEnabledCipherSuites() {            throw new UnsupportedOperationException();        }        public String[] getSupportedProtocols() {            throw new UnsupportedOperationException();        }        public String[] getEnabledProtocols() {            throw new UnsupportedOperationException();        }        public SSLSession getSession() {            throw new UnsupportedOperationException();        }        public void setEnabledCipherSuites(String[] suites) {        }        public void setEnabledProtocols(String[] protocols) {        }        public void addHandshakeCompletedListener(HandshakeCompletedListener listener) {        }        public void removeHandshakeCompletedListener(HandshakeCompletedListener listener) {        }        public void setUseClientMode(boolean mode) {        }        public boolean getUseClientMode() {            return true;        }        public void setNeedClientAuth(boolean need) {        }        public boolean getNeedClientAuth() {            return true;        }        public void setWantClientAuth(boolean want) {        }        public boolean getWantClientAuth() {            return true;        }        public void setEnableSessionCreation(boolean flag) {        }        public boolean getEnableSessionCreation() {            return true;        }    };}
connect
public void zookeeper_f4895_0(SocketAddress endpoint, int timeout)
{}
startHandshake
public void zookeeper_f4896_0() throws IOException
{    throw new IOException();}
close
public void zookeeper_f4897_0()
{    closeLatch.countDown();}
getSupportedCipherSuites
public String[] zookeeper_f4898_0()
{    throw new UnsupportedOperationException();}
getEnabledCipherSuites
public String[] zookeeper_f4899_0()
{    throw new UnsupportedOperationException();}
getSupportedProtocols
public String[] zookeeper_f4900_0()
{    throw new UnsupportedOperationException();}
getEnabledProtocols
public String[] zookeeper_f4901_0()
{    throw new UnsupportedOperationException();}
getSession
public SSLSession zookeeper_f4902_0()
{    throw new UnsupportedOperationException();}
setEnabledCipherSuites
public void zookeeper_f4903_0(String[] suites)
{}
setEnabledProtocols
public void zookeeper_f4904_0(String[] protocols)
{}
addHandshakeCompletedListener
public void zookeeper_f4905_0(HandshakeCompletedListener listener)
{}
removeHandshakeCompletedListener
public void zookeeper_f4906_0(HandshakeCompletedListener listener)
{}
setUseClientMode
public void zookeeper_f4907_0(boolean mode)
{}
getUseClientMode
public boolean zookeeper_f4908_0()
{    return true;}
setNeedClientAuth
public void zookeeper_f4909_0(boolean need)
{}
getNeedClientAuth
public boolean zookeeper_f4910_0()
{    return true;}
setWantClientAuth
public void zookeeper_f4911_0(boolean want)
{}
getWantClientAuth
public boolean zookeeper_f4912_0()
{    return true;}
setEnableSessionCreation
public void zookeeper_f4913_0(boolean flag)
{}
getEnableSessionCreation
public boolean zookeeper_f4914_0()
{    return true;}
createX509Util
public QuorumX509Util zookeeper_f4915_0()
{    return mockedX509Util;}
testWorkerThreads
public voidf4916_1) throws Exception
{    ArrayList<QuorumPeer> peerList = new ArrayList<QuorumPeer>();    try {        for (int sid = 0; sid < 3; sid++) {            QuorumPeer peer = new QuorumPeer(peers, peerTmpdir[sid], peerTmpdir[sid], peerClientPort[sid], 3, sid, 1000, 2, 2, 2);                        peer.start();            peerList.add(sid, peer);        }        String failure = verifyThreadCount(peerList, 4);        assertNull(failure, failure);        for (int myid = 0; myid < 3; myid++) {            for (int i = 0; i < 5; i++) {                                QuorumPeer peer = peerList.get(myid);                                peer.shutdown();                peerList.remove(myid);                failure = verifyThreadCount(peerList, 2);                assertNull(failure, failure);                                peer = new QuorumPeer(peers, peerTmpdir[myid], peerTmpdir[myid], peerClientPort[myid], 3, myid, 1000, 2, 2, 2);                                peer.start();                peerList.add(myid, peer);                failure = verifyThreadCount(peerList, 4);                assertNull(failure, failure);            }        }    } finally {        for (QuorumPeer quorumPeer : peerList) {            quorumPeer.shutdown();        }    }}
verifyThreadCount
public String zookeeper_f4917_0(ArrayList<QuorumPeer> peerList, long ecnt) throws InterruptedException
{    String failure = null;    for (int i = 0; i < 480; i++) {        Thread.sleep(500);        failure = _verifyThreadCount(peerList, ecnt);        if (failure == null) {            return null;        }    }    return failure;}
_verifyThreadCount
public String zookeeper_f4918_0(ArrayList<QuorumPeer> peerList, long ecnt)
{    for (int myid = 0; myid < peerList.size(); myid++) {        QuorumPeer peer = peerList.get(myid);        QuorumCnxManager cnxManager = peer.getQuorumCnxManager();        long cnt = cnxManager.getThreadCount();        if (cnt != ecnt) {            return new Date() + " Incorrect number of Worker threads for sid=" + myid + " expected " + ecnt + " found " + cnt;        }    }    return null;}
testInitialMessage
public void zookeeper_f4919_0() throws Exception
{    InitialMessage msg;    ByteArrayOutputStream bos;    DataInputStream din;    DataOutputStream dout;    String hostport;        try {                hostport = "10.0.0.2:3888";        bos = new ByteArrayOutputStream();        dout = new DataOutputStream(bos);                dout.writeLong(5L);        dout.writeInt(hostport.getBytes().length);        dout.writeBytes(hostport);                din = new DataInputStream(new ByteArrayInputStream(bos.toByteArray()));        msg = InitialMessage.parse(-65530L, din);        fail("bad protocol version accepted");    } catch (InitialMessage.InitialMessageException ex) {    }        try {        hostport = createLongString(1048576);        bos = new ByteArrayOutputStream();        dout = new DataOutputStream(bos);                dout.writeLong(5L);        dout.writeInt(hostport.getBytes().length);        dout.writeBytes(hostport);        din = new DataInputStream(new ByteArrayInputStream(bos.toByteArray()));        msg = InitialMessage.parse(QuorumCnxManager.PROTOCOL_VERSION, din);        fail("long message accepted");    } catch (InitialMessage.InitialMessageException ex) {    }        try {        hostport = "what's going on here?";        bos = new ByteArrayOutputStream();        dout = new DataOutputStream(bos);                dout.writeLong(5L);        dout.writeInt(hostport.getBytes().length);        dout.writeBytes(hostport);        din = new DataInputStream(new ByteArrayInputStream(bos.toByteArray()));        msg = InitialMessage.parse(QuorumCnxManager.PROTOCOL_VERSION, din);        fail("bad hostport accepted");    } catch (InitialMessage.InitialMessageException ex) {    }        try {        hostport = "10.0.0.2:3888";        bos = new ByteArrayOutputStream();        dout = new DataOutputStream(bos);                dout.writeLong(5L);        dout.writeInt(hostport.getBytes().length);        dout.writeBytes(hostport);                din = new DataInputStream(new ByteArrayInputStream(bos.toByteArray()));        msg = InitialMessage.parse(QuorumCnxManager.PROTOCOL_VERSION, din);    } catch (InitialMessage.InitialMessageException ex) {        fail(ex.toString());    }}
createLongString
private String zookeeper_f4920_0(int size)
{    StringBuilder sb = new StringBuilder(size);    for (int i = 0; i < size; i++) {        sb.append('x');    }    return sb.toString();}
setUp
public void zookeeper_f4921_0() throws Exception
{    processedRequests = new LinkedBlockingQueue<Request>();    processor = new MockCommitProcessor();    CommitProcessor.setMaxReadBatchSize(-1);    CommitProcessor.setMaxCommitBatchSize(1);}
tearDown
public void zookeeper_f4922_0() throws Exception
{    processor.shutdown();}
poll
public Request zookeeper_f4923_0()
{    readReqId++;    try {        return newRequest(new GetDataRequest("/", false), OpCode.getData, readReqId % 50, readReqId);    } catch (IOException e) {        e.printStackTrace();    }    return null;}
size
public int zookeeper_f4924_0()
{    return 42;}
processRequest
public void zookeeper_f4925_0(Request request) throws RequestProcessorException
{    processedRequests.offer(request);}
shutdown
public void zookeeper_f4926_0()
{}
notifyStopping
public void zookeeper_f4927_0(String threadName, int errorCode)
{    fail("Commit processor crashed " + errorCode);}
initThreads
public void zookeeper_f4928_0(int poolSize)
{    this.stopped = false;    this.workerPool = new WorkerService("CommitProcWork", poolSize, true);}
newRequest
private Request zookeeper_f4929_0(Record rec, int type, int sessionId, int xid) throws IOException
{    ByteArrayOutputStream boas = new ByteArrayOutputStream();    BinaryOutputArchive boa = BinaryOutputArchive.getArchive(boas);    rec.serialize(boa, "request");    ByteBuffer bb = ByteBuffer.wrap(boas.toByteArray());    return new Request(null, sessionId, xid, type, bb, new ArrayList<Id>());}
committedAndUncommittedOfTheSameSessionRaceTest
public void zookeeper_f4930_0() throws Exception
{    final String path = "/testCvsUCRace";    Request readReq = newRequest(new GetDataRequest(path, false), OpCode.getData, 0x0, 0);    Request writeReq = newRequest(new SetDataRequest(path, new byte[16], -1), OpCode.setData, 0x0, 1);    processor.committedRequests.add(writeReq);    processor.queuedRequests.add(readReq);    processor.queuedRequests.add(writeReq);    processor.queuedWriteRequests.add(writeReq);    processor.initThreads(1);    processor.stoppedMainLoop = true;    processor.run();    assertTrue("Request was not processed " + readReq + " instead " + processedRequests.peek(), processedRequests.peek() != null && processedRequests.peek().equals(readReq));    processedRequests.poll();    assertTrue("Request was not processed " + writeReq + " instead " + processedRequests.peek(), processedRequests.peek() != null && processedRequests.peek().equals(writeReq));}
processAsMuchUncommittedRequestsAsPossibleTest
public voidf4931_1) throws Exception
{    final String path = "/testAsMuchAsPossible";    List<Request> shouldBeProcessed = new LinkedList<Request>();    Set<Request> shouldNotBeProcessed = new HashSet<Request>();    for (int sessionId = 1; sessionId <= 5; ++sessionId) {        for (int readReqId = 1; readReqId <= sessionId; ++readReqId) {            Request readReq = newRequest(new GetDataRequest(path, false), OpCode.getData, sessionId, readReqId);            shouldBeProcessed.add(readReq);            processor.queuedRequests.add(readReq);        }        Request writeReq = newRequest(new CreateRequest(path, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL.toFlag()), OpCode.create, sessionId, sessionId + 1);        Request readReq = newRequest(new GetDataRequest(path, false), OpCode.getData, sessionId, sessionId + 2);        processor.queuedRequests.add(writeReq);        processor.queuedWriteRequests.add(writeReq);        processor.queuedRequests.add(readReq);        shouldNotBeProcessed.add(writeReq);        shouldNotBeProcessed.add(readReq);    }    processor.initThreads(defaultSizeOfThreadPool);    processor.stoppedMainLoop = true;    processor.run();    Thread.sleep(1000);    shouldBeProcessed.removeAll(processedRequests);    for (Request r : shouldBeProcessed) {            }    assertTrue("Not all requests were processed", shouldBeProcessed.isEmpty());    assertFalse("Processed a wrong request", shouldNotBeProcessed.removeAll(processedRequests));}
processAllFollowingUncommittedAfterFirstCommitTest
public voidf4932_1) throws Exception
{    final String path = "/testUncommittedFollowingCommited";    Set<Request> shouldBeInPending = new HashSet<Request>();    Set<Request> shouldBeProcessedAfterPending = new HashSet<Request>();    Request writeReq = newRequest(new CreateRequest(path, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL.toFlag()), OpCode.create, 0x1, 1);    processor.queuedRequests.add(writeReq);    processor.queuedWriteRequests.add(writeReq);    shouldBeInPending.add(writeReq);    for (int readReqId = 2; readReqId <= 5; ++readReqId) {        Request readReq = newRequest(new GetDataRequest(path, false), OpCode.getData, 0x1, readReqId);        processor.queuedRequests.add(readReq);        shouldBeInPending.add(readReq);        shouldBeProcessedAfterPending.add(readReq);    }    processor.initThreads(defaultSizeOfThreadPool);    processor.stoppedMainLoop = true;    processor.run();    assertTrue("Processed without waiting for commit", processedRequests.isEmpty());    assertTrue("Did not handled all of queuedRequests' requests", processor.queuedRequests.isEmpty());    assertTrue("Removed from blockedQueuedRequests before commit", !processor.queuedWriteRequests.isEmpty());    shouldBeInPending.removeAll(processor.pendingRequests.get(writeReq.sessionId));    for (Request r : shouldBeInPending) {            }    assertTrue("Not all requests moved to pending from queuedRequests", shouldBeInPending.isEmpty());    processor.committedRequests.add(writeReq);    processor.stoppedMainLoop = true;    processor.run();    processor.initThreads(defaultSizeOfThreadPool);    Thread.sleep(500);    assertTrue("Did not process committed request", processedRequests.peek() == writeReq);    assertTrue("Did not process following read request", processedRequests.containsAll(shouldBeProcessedAfterPending));    assertTrue("Did not process committed request", processor.committedRequests.isEmpty());    assertTrue("Did not process committed request", processor.pendingRequests.isEmpty());    assertTrue("Did not remove from blockedQueuedRequests", processor.queuedWriteRequests.isEmpty());}
processAllWritesMaxBatchSize
public void zookeeper_f4933_0() throws Exception
{    final String path = "/processAllWritesMaxBatchSize";    HashSet<Request> shouldBeProcessedAfterPending = new HashSet<Request>();    Request writeReq = newRequest(new CreateRequest(path + "_1", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL.toFlag()), OpCode.create, 0x1, 1);    processor.queuedRequests.add(writeReq);    processor.queuedWriteRequests.add(writeReq);    Request writeReq2 = newRequest(new CreateRequest(path + "_2", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL.toFlag()), OpCode.create, 0x2, 1);    processor.queuedRequests.add(writeReq2);    processor.queuedWriteRequests.add(writeReq2);    for (int readReqId = 2; readReqId <= 5; ++readReqId) {        Request readReq = newRequest(new GetDataRequest(path, false), OpCode.getData, 0x1, readReqId);        Request readReq2 = newRequest(new GetDataRequest(path, false), OpCode.getData, 0x2, readReqId);        processor.queuedRequests.add(readReq);        shouldBeProcessedAfterPending.add(readReq);        processor.queuedRequests.add(readReq2);        shouldBeProcessedAfterPending.add(readReq2);    }    Request writeReq3 = newRequest(new CreateRequest(path + "_3", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL.toFlag()), OpCode.create, 0x2, 6);    processor.queuedRequests.add(writeReq3);    processor.queuedWriteRequests.add(writeReq3);    processor.initThreads(defaultSizeOfThreadPool);    processor.stoppedMainLoop = true;    CommitProcessor.setMaxCommitBatchSize(2);    processor.run();    assertTrue("Processed without waiting for commit", processedRequests.isEmpty());    assertTrue("Did not handled all of queuedRequests' requests", processor.queuedRequests.isEmpty());    assertTrue("Removed from blockedQueuedRequests before commit", !processor.queuedWriteRequests.isEmpty());    assertTrue("Missing session 1 in pending queue", processor.pendingRequests.containsKey(writeReq.sessionId));    assertTrue("Missing session 2 in pending queue", processor.pendingRequests.containsKey(writeReq2.sessionId));    processor.committedRequests.add(writeReq);    processor.committedRequests.add(writeReq2);    processor.committedRequests.add(writeReq3);    processor.stoppedMainLoop = true;    CommitProcessor.setMaxCommitBatchSize(3);    processor.run();    processor.initThreads(defaultSizeOfThreadPool);    Thread.sleep(500);    assertTrue("Did not process committed request", processedRequests.peek() == writeReq);    assertTrue("Did not process following read request", processedRequests.containsAll(shouldBeProcessedAfterPending));    assertTrue("Processed committed request", !processor.committedRequests.isEmpty());    assertTrue("Removed commit for write req 3", processor.committedRequests.peek() == writeReq3);    assertTrue("Processed committed request", !processor.pendingRequests.isEmpty());    assertTrue("Missing session 2 in pending queue", processor.pendingRequests.containsKey(writeReq3.sessionId));    assertTrue("Missing write 3 in pending queue", processor.pendingRequests.get(writeReq3.sessionId).peek() == writeReq3);    assertTrue("Removed from blockedQueuedRequests", !processor.queuedWriteRequests.isEmpty());    assertTrue("Removed write req 3 from blockedQueuedRequests", processor.queuedWriteRequests.peek() == writeReq3);    Request readReq3 = newRequest(new GetDataRequest(path, false), OpCode.getData, 0x1, 7);    processor.queuedRequests.add(readReq3);    shouldBeProcessedAfterPending.add(readReq3);    Request writeReq4 = newRequest(new CreateRequest(path + "_4", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL.toFlag()), OpCode.create, 0x2, 7);    processor.queuedRequests.add(writeReq4);    processor.queuedWriteRequests.add(writeReq4);    processor.committedRequests.add(writeReq4);    processor.stoppedMainLoop = true;    CommitProcessor.setMaxCommitBatchSize(3);    processor.run();    processor.initThreads(defaultSizeOfThreadPool);    Thread.sleep(500);    assertTrue("Did not process committed request", processedRequests.peek() == writeReq);    assertTrue("Did not process following read request", processedRequests.containsAll(shouldBeProcessedAfterPending));    assertTrue("Processed unexpected committed request", !processor.committedRequests.isEmpty());    assertTrue("Unexpected pending request", processor.pendingRequests.isEmpty());    assertTrue("Removed from blockedQueuedRequests", !processor.queuedWriteRequests.isEmpty());    assertTrue("Removed write req 4 from blockedQueuedRequests", processor.queuedWriteRequests.peek() == writeReq4);    processor.stoppedMainLoop = true;    CommitProcessor.setMaxCommitBatchSize(3);    processor.run();    processor.initThreads(defaultSizeOfThreadPool);    Thread.sleep(500);    assertTrue("Did not process committed request", processedRequests.peek() == writeReq);    assertTrue("Did not process following read request", processedRequests.containsAll(shouldBeProcessedAfterPending));    assertTrue("Did not process committed request", processor.committedRequests.isEmpty());    assertTrue("Did not process committed request", processor.pendingRequests.isEmpty());    assertTrue("Did not remove from blockedQueuedRequests", processor.queuedWriteRequests.isEmpty());}
noStarvationOfNonLocalCommittedRequestsTest
public void zookeeper_f4934_0() throws Exception
{    final String path = "/noStarvationOfCommittedRequests";    processor.queuedRequests = new MockRequestsQueue();    Set<Request> nonLocalCommits = new HashSet<Request>();    for (int i = 0; i < 10; i++) {        Request nonLocalCommitReq = newRequest(new CreateRequest(path, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL.toFlag()), OpCode.create, 51, i + 1);        processor.committedRequests.add(nonLocalCommitReq);        nonLocalCommits.add(nonLocalCommitReq);    }    for (int i = 0; i < 10; i++) {        processor.initThreads(defaultSizeOfThreadPool);        processor.stoppedMainLoop = true;        processor.run();    }    assertTrue("commit request was not processed", processedRequests.containsAll(nonLocalCommits));}
noStarvationOfReadRequestsTest
public void zookeeper_f4935_0() throws Exception
{    final String path = "/noStarvationOfReadRequests";        Request firstCommittedReq = newRequest(new CreateRequest(path, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL.toFlag()), OpCode.create, 0x3, 1);    processor.queuedRequests.add(firstCommittedReq);    processor.queuedWriteRequests.add(firstCommittedReq);    processor.committedRequests.add(firstCommittedReq);    Set<Request> allReads = new HashSet<Request>();        Request firstRead = newRequest(new GetDataRequest(path, false), OpCode.getData, 0x1, 0);    allReads.add(firstRead);    processor.queuedRequests.add(firstRead);        Request secondCommittedReq = newRequest(new CreateRequest(path, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL.toFlag()), OpCode.create, 0x99, 2);    processor.committedRequests.add(secondCommittedReq);    Set<Request> waitingCommittedRequests = new HashSet<Request>();        for (int writeReqId = 3; writeReqId < 102; ++writeReqId) {        Request writeReq = newRequest(new CreateRequest(path, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL.toFlag()), OpCode.create, 0x8, writeReqId);        processor.committedRequests.add(writeReq);        waitingCommittedRequests.add(writeReq);    }        for (int readReqId = 1; readReqId <= 50; ++readReqId) {        Request readReq = newRequest(new GetDataRequest(path, false), OpCode.getData, 0x5, readReqId);        allReads.add(readReq);        processor.queuedRequests.add(readReq);    }    processor.initThreads(defaultSizeOfThreadPool);    processor.stoppedMainLoop = true;    processor.run();    assertTrue("Did not process the first write request", processedRequests.contains(firstCommittedReq));    for (Request r : allReads) {        assertTrue("Processed read request", !processedRequests.contains(r));    }    processor.run();    assertTrue("did not processed all reads", processedRequests.containsAll(allReads));    assertTrue("Did not process the second write request", processedRequests.contains(secondCommittedReq));    for (Request r : waitingCommittedRequests) {        assertTrue("Processed additional committed request", !processedRequests.contains(r));    }}
noCrashOnCommittedRequestsOfUnseenRequestTest
public void zookeeper_f4936_0() throws Exception
{    final String path = "/noCrash/OnCommittedRequests/OfUnseenRequestTest";    final int numberofReads = 10;    final int sessionid = 0x123456;    final int firstCXid = 0x100;    int readReqId = firstCXid;    processor.stoppedMainLoop = true;    HashSet<Request> localRequests = new HashSet<Request>();        Request firstCommittedReq = newRequest(new CreateRequest(path, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL.toFlag()), OpCode.create, sessionid, readReqId++);    processor.queuedRequests.add(firstCommittedReq);    processor.queuedWriteRequests.add(firstCommittedReq);    localRequests.add(firstCommittedReq);        for (; readReqId <= numberofReads + firstCXid; ++readReqId) {        Request readReq = newRequest(new GetDataRequest(path, false), OpCode.getData, sessionid, readReqId);        processor.queuedRequests.add(readReq);        localRequests.add(readReq);    }        assertTrue(processor.queuedRequests.containsAll(localRequests));    processor.initThreads(defaultSizeOfThreadPool);    processor.run();    Thread.sleep(1000);        assertTrue(processedRequests.isEmpty());            Request preSessionCommittedReq = newRequest(new CreateRequest(path, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL.toFlag()), OpCode.create, sessionid, firstCXid - 2);    processor.committedRequests.add(preSessionCommittedReq);    processor.committedRequests.add(firstCommittedReq);    processor.run();    Thread.sleep(1000);        assertTrue(processedRequests.peek() == preSessionCommittedReq);    processor.run();    Thread.sleep(1000);        assertTrue(processedRequests.containsAll(localRequests));}
noCrashOnOutofOrderCommittedRequestTest
public void zookeeper_f4937_0() throws Exception
{    final String path = "/noCrash/OnCommittedRequests/OfUnSeenRequestTest";    final int sessionid = 0x123456;    final int lastCXid = 0x100;    final int numberofReads = 10;    int readReqId = lastCXid;    processor.stoppedMainLoop = true;    HashSet<Request> localRequests = new HashSet<Request>();        Request orphanCommittedReq = newRequest(new CreateRequest(path, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL.toFlag()), OpCode.create, sessionid, lastCXid);    processor.queuedRequests.add(orphanCommittedReq);    processor.queuedWriteRequests.add(orphanCommittedReq);    localRequests.add(orphanCommittedReq);        for (; readReqId <= numberofReads + lastCXid; ++readReqId) {        Request readReq = newRequest(new GetDataRequest(path, false), OpCode.getData, sessionid, readReqId);        processor.queuedRequests.add(readReq);        localRequests.add(readReq);    }        processor.initThreads(defaultSizeOfThreadPool);    processor.run();    Thread.sleep(1000);        assertTrue(processedRequests.isEmpty());            Request otherSessionCommittedReq = newRequest(new CreateRequest(path, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL.toFlag()), OpCode.create, sessionid, lastCXid + 10);    processor.committedRequests.add(otherSessionCommittedReq);    processor.committedRequests.add(orphanCommittedReq);    processor.run();    Thread.sleep(1000);        assertTrue(processedRequests.size() == 1);    assertTrue(processedRequests.contains(otherSessionCommittedReq));    processor.run();    Thread.sleep(1000);        assertTrue(processedRequests.containsAll(localRequests));}
setup
public voidf4938_1)
{        ServerMetrics.getMetrics().resetAll();        System.clearProperty("zookeeper.commitProcessor.maxReadBatchSize");    System.clearProperty("zookeeper.commitProcessor.maxCommitBatchSize");}
setupProcessors
public void zookeeper_f4939_0(int commitWorkers, int finalProcTime)
{    finalProcessor = new DummyFinalProcessor(finalProcTime);    commitProcessor = new TestCommitProcessor(finalProcessor, commitWorkers);    commitProcessor.start();}
tearDown
public voidf4940_1) throws Exception
{        commitProcessor.shutdown();    commitProcessor.join();}
start
public voidf4941_1)
{    super.workerPool = new TestWorkerService(numWorkerThreads);    super.start();                                                        Thread.State state = super.getState();    while (state != State.WAITING) {        try {            Thread.sleep(50);        } catch (Exception e) {        }        state = super.getState();    }    }
endOfIteration
protected void zookeeper_f4942_0()
{    if (requestProcessed != null) {        requestProcessed.countDown();    }}
waitForEmptyPool
protected void zookeeper_f4943_0() throws InterruptedException
{    if (commitSeen != null) {        commitSeen.countDown();    }    super.waitForEmptyPool();    if (poolEmpytied != null) {        poolEmpytied.countDown();    }}
schedule
public void zookeeper_f4944_0(WorkRequest workRequest, long id)
{    super.schedule(workRequest, id);    if (requestScheduled != null) {        requestScheduled.countDown();    }}
processRequest
public void zookeeper_f4945_0(Request request)
{    if (processTime > 0) {        try {            if (commitSeen != null) {                commitSeen.await(5, TimeUnit.SECONDS);            }            Thread.sleep(processTime);        } catch (Exception e) {        }    }}
shutdown
public void zookeeper_f4946_0()
{}
checkMetrics
private void zookeeper_f4947_0(String metricName, long min, long max, double avg, long cnt, long sum)
{    Map<String, Object> values = MetricsUtils.currentServerMetrics();    assertEquals("expected min is " + min, min, values.get("min_" + metricName));    assertEquals("expected max is: " + max, max, values.get("max_" + metricName));    assertEquals("expected avg is: " + avg, avg, (Double) values.get("avg_" + metricName), 0.001);    assertEquals("expected cnt is: " + cnt, cnt, values.get("cnt_" + metricName));    assertEquals("expected sum is: " + sum, sum, values.get("sum_" + metricName));}
checkTimeMetric
private void zookeeper_f4948_0(long actual, long lBoundrary, long hBoundrary)
{    assertThat(actual, greaterThanOrEqualTo(lBoundrary));    assertThat(actual, lessThanOrEqualTo(hBoundrary));}
createReadRequest
private Request zookeeper_f4949_0(long sessionId, int xid)
{    return new Request(null, sessionId, xid, ZooDefs.OpCode.getData, ByteBuffer.wrap(new byte[10]), null);}
createWriteRequest
private Request zookeeper_f4950_0(long sessionId, int xid)
{    return new Request(null, sessionId, xid, ZooDefs.OpCode.setData, ByteBuffer.wrap(new byte[10]), null);}
processRequestWithWait
private void zookeeper_f4951_0(Request request) throws Exception
{    requestProcessed = new CountDownLatch(1);    commitProcessor.processRequest(request);    requestProcessed.await(5, TimeUnit.SECONDS);}
commitWithWait
private void zookeeper_f4952_0(Request request) throws Exception
{    requestProcessed = new CountDownLatch(1);    commitProcessor.commit(request);    requestProcessed.await(5, TimeUnit.SECONDS);}
testRequestsInSessionQueue
public void zookeeper_f4953_0() throws Exception
{    setupProcessors(0, 0);    Request req1 = createWriteRequest(1L, 1);    processRequestWithWait(req1);    checkMetrics("requests_in_session_queue", 1L, 1L, 1D, 1L, 1L);        processRequestWithWait(createReadRequest(1L, 2));    processRequestWithWait(createReadRequest(1L, 3));    checkMetrics("requests_in_session_queue", 1L, 3L, 2D, 3L, 6);    commitWithWait(req1);    checkMetrics("requests_in_session_queue", 1L, 3L, 2.25D, 4L, 9);}
testWriteFinalProcTime
public void zookeeper_f4954_0() throws Exception
{    setupProcessors(0, 1000);    Request req1 = createWriteRequest(1L, 2);    processRequestWithWait(req1);        Map<String, Object> values = MetricsUtils.currentServerMetrics();    assertEquals(0L, values.get("cnt_write_final_proc_time_ms"));    commitWithWait(req1);    values = MetricsUtils.currentServerMetrics();    assertEquals(1L, values.get("cnt_write_final_proc_time_ms"));    checkTimeMetric((long) values.get("max_write_final_proc_time_ms"), 1000L, 2000L);}
testReadFinalProcTime
public void zookeeper_f4955_0() throws Exception
{    setupProcessors(0, 1000);    processRequestWithWait(createReadRequest(1L, 1));    Map<String, Object> values = MetricsUtils.currentServerMetrics();    assertEquals(1L, values.get("cnt_read_final_proc_time_ms"));    checkTimeMetric((long) values.get("max_read_final_proc_time_ms"), 1000L, 2000L);}
testCommitProcessTime
public void zookeeper_f4956_0() throws Exception
{    setupProcessors(0, 0);    processRequestWithWait(createReadRequest(1L, 1));    Map<String, Object> values = MetricsUtils.currentServerMetrics();    assertEquals(1L, values.get("cnt_commit_process_time"));    checkTimeMetric((long) values.get("max_commit_process_time"), 0L, 1000L);}
testServerWriteCommittedTime
public void zookeeper_f4957_0() throws Exception
{    setupProcessors(0, 0);        commitWithWait(createWriteRequest(1L, 1));    Map<String, Object> values = MetricsUtils.currentServerMetrics();    assertEquals(1L, values.get("cnt_server_write_committed_time_ms"));    checkTimeMetric((long) values.get("max_server_write_committed_time_ms"), 0L, 1000L);}
testLocalWriteCommittedTime
public void zookeeper_f4958_0() throws Exception
{    setupProcessors(0, 0);    Request req1 = createWriteRequest(1L, 2);    processRequestWithWait(req1);    commitWithWait(req1);    Map<String, Object> values = MetricsUtils.currentServerMetrics();    assertEquals(1L, values.get("cnt_local_write_committed_time_ms"));    checkTimeMetric((long) values.get("max_local_write_committed_time_ms"), 0L, 1000L);    Request req2 = createWriteRequest(1L, 2);    processRequestWithWait(req2);            Thread.sleep(1000);    commitWithWait(req2);    values = MetricsUtils.currentServerMetrics();    assertEquals(2L, values.get("cnt_local_write_committed_time_ms"));    checkTimeMetric((long) values.get("max_local_write_committed_time_ms"), 0L, 1000L);}
testWriteCommitProcTime
public void zookeeper_f4959_0() throws Exception
{    setupProcessors(0, 0);    Request req1 = createWriteRequest(1L, 2);    processRequestWithWait(req1);    commitWithWait(req1);    Map<String, Object> values = MetricsUtils.currentServerMetrics();    assertEquals(1L, values.get("cnt_write_commitproc_time_ms"));    checkTimeMetric((long) values.get("max_write_commitproc_time_ms"), 0L, 1000L);    Request req2 = createWriteRequest(1L, 2);    processRequestWithWait(req2);        Thread.sleep(1000);    commitWithWait(req2);    values = MetricsUtils.currentServerMetrics();    assertEquals(2L, values.get("cnt_write_commitproc_time_ms"));    checkTimeMetric((long) values.get("max_write_commitproc_time_ms"), 1000L, 2000L);}
testReadCommitProcTime
public void zookeeper_f4960_0() throws Exception
{    setupProcessors(0, 0);    processRequestWithWait(createReadRequest(1L, 1));    Map<String, Object> values = MetricsUtils.currentServerMetrics();    assertEquals(1L, values.get("cnt_read_commitproc_time_ms"));    checkTimeMetric((long) values.get("max_read_commitproc_time_ms"), 0L, 1000L);    Request req1 = createWriteRequest(1L, 2);    processRequestWithWait(req1);    processRequestWithWait(createReadRequest(1L, 3));        Thread.sleep(1000);    commitWithWait(req1);    values = MetricsUtils.currentServerMetrics();    assertEquals(2L, values.get("cnt_read_commitproc_time_ms"));    checkTimeMetric((long) values.get("max_read_commitproc_time_ms"), 1000L, 2000L);}
testTimeWaitingEmptyPoolInCommitProcessorRead
public void zookeeper_f4961_0() throws Exception
{    setupProcessors(1, 1000);        requestScheduled = new CountDownLatch(3);    commitProcessor.processRequest(createReadRequest(0L, 2));    commitProcessor.processRequest(createReadRequest(1L, 3));    commitProcessor.processRequest(createReadRequest(2L, 4));    requestScheduled.await(5, TimeUnit.SECONDS);        poolEmpytied = new CountDownLatch(1);    commitProcessor.commit(createWriteRequest(1L, 1));    poolEmpytied.await(5, TimeUnit.SECONDS);    long actual = (long) MetricsUtils.currentServerMetrics().get("max_time_waiting_empty_pool_in_commit_processor_read_ms");        checkTimeMetric(actual, 2500L, 3500L);}
testConcurrentRequestProcessingInCommitProcessor
public void zookeeper_f4962_0() throws Exception
{    setupProcessors(3, 1000);        commitSeen = new CountDownLatch(1);    requestScheduled = new CountDownLatch(3);    commitProcessor.processRequest(createReadRequest(1L, 2));    commitProcessor.processRequest(createReadRequest(1L, 3));    commitProcessor.processRequest(createReadRequest(1L, 4));    requestScheduled.await(5, TimeUnit.SECONDS);        poolEmpytied = new CountDownLatch(1);    commitProcessor.commit(createWriteRequest(1L, 1));    poolEmpytied.await(5, TimeUnit.SECONDS);        Map<String, Object> values = MetricsUtils.currentServerMetrics();    assertEquals(3L, values.get("max_concurrent_request_processing_in_commit_processor"));}
testReadsAfterWriteInSessionQueue
public void zookeeper_f4963_0() throws Exception
{    setupProcessors(0, 0);        processRequestWithWait(createReadRequest(1L, 1));        Request req1 = createWriteRequest(1L, 1);    processRequestWithWait(req1);        processRequestWithWait(createReadRequest(1L, 2));    processRequestWithWait(createReadRequest(1L, 3));    processRequestWithWait(createReadRequest(1L, 4));        commitWithWait(req1);    checkMetrics("reads_after_write_in_session_queue", 3L, 3L, 3d, 1, 3);}
testReadsQueuedInCommitProcessor
public void zookeeper_f4964_0() throws Exception
{    setupProcessors(0, 0);    processRequestWithWait(createReadRequest(1L, 1));    processRequestWithWait(createReadRequest(1L, 2));        checkMetrics("read_commit_proc_req_queued", 1L, 1L, 1d, 2, 2);}
testWritesQueuedInCommitProcessor
public void zookeeper_f4965_0() throws Exception
{    setupProcessors(0, 0);    Request req1 = createWriteRequest(1L, 1);    processRequestWithWait(req1);    Request req2 = createWriteRequest(1L, 2);    processRequestWithWait(req2);            checkMetrics("write_commit_proc_req_queued", 1L, 2L, 1.5d, 2, 3);    commitWithWait(req1);        checkMetrics("write_commit_proc_req_queued", 1L, 2L, 1.6667d, 3, 5);    commitWithWait(req2);        checkMetrics("write_commit_proc_req_queued", 1L, 2L, 1.5d, 4, 6);            processRequestWithWait(createReadRequest(1L, 1));    checkMetrics("write_commit_proc_req_queued", 0L, 2L, 1.2d, 5, 6);}
testCommitsQueuedInCommitProcessor
public void zookeeper_f4966_0() throws Exception
{    setupProcessors(0, 0);    commitWithWait(createWriteRequest(1L, 1));    commitWithWait(createWriteRequest(1L, 2));        checkMetrics("commit_commit_proc_req_queued", 1L, 1L, 1d, 2, 2);}
testCommitsQueued
public void zookeeper_f4967_0() throws Exception
{    setupProcessors(0, 0);    commitWithWait(createWriteRequest(1L, 1));    commitWithWait(createWriteRequest(1L, 2));    Map<String, Object> values = MetricsUtils.currentServerMetrics();    assertEquals(2L, (long) values.get("request_commit_queued"));}
testPendingSessionQueueSize
public void zookeeper_f4968_0() throws Exception
{    setupProcessors(0, 0);        Request req1 = createWriteRequest(1L, 1);    processRequestWithWait(req1);        Request req2 = createWriteRequest(2L, 2);    processRequestWithWait(req2);    Request req3 = createWriteRequest(2L, 3);    processRequestWithWait(req3);    commitWithWait(req1);        checkMetrics("pending_session_queue_size", 2L, 2L, 2d, 1, 2);    commitWithWait(req2);        checkMetrics("pending_session_queue_size", 1L, 2L, 1.5d, 2, 3);    commitWithWait(req3);        checkMetrics("pending_session_queue_size", 1L, 2L, 1.333d, 3, 4);}
setUp
public void zookeeper_f4969_0(int numCommitThreads, int numClientThreads, int writePercent) throws Exception
{    stopped = false;    System.setProperty(CommitProcessor.ZOOKEEPER_COMMIT_PROC_NUM_WORKER_THREADS, Integer.toString(numCommitThreads));    tmpDir = ClientBase.createTmpDir();    ClientBase.setupTestEnv();    zks = new TestZooKeeperServer(tmpDir, tmpDir, 4000);    zks.startup();    for (int i = 0; i < numClientThreads; ++i) {        TestClientThread client = new TestClientThread(writePercent);        testClients.add(client);        client.start();    }}
setUp
public void zookeeper_f4970_0(int numCommitThreads, int numReadOnlyClientThreads, int mixWorkloadClientThreads, int writePercent) throws Exception
{    stopped = false;    System.setProperty(CommitProcessor.ZOOKEEPER_COMMIT_PROC_NUM_WORKER_THREADS, Integer.toString(numCommitThreads));    tmpDir = ClientBase.createTmpDir();    ClientBase.setupTestEnv();    zks = new TestZooKeeperServer(tmpDir, tmpDir, 4000);    zks.startup();    for (int i = 0; i < mixWorkloadClientThreads; ++i) {        TestClientThread client = new TestClientThread(writePercent);        testClients.add(client);        client.start();    }    for (int i = 0; i < numReadOnlyClientThreads; ++i) {        TestClientThread client = new TestClientThread(0);        testClients.add(client);        client.start();    }}
tearDown
public voidf4971_1) throws Exception
{        stopped = true;    zks.shutdown();    for (TestClientThread client : testClients) {        client.interrupt();        client.join();    }    if (tmpDir != null) {        assertTrue("delete " + tmpDir.toString(), ClientBase.recursiveDelete(tmpDir));    }    processedReadRequests.set(0);    processedWriteRequests.set(0);    testClients.clear();    commitProcessor.join();}
sendWriteRequest
public void zookeeper_f4972_0() throws Exception
{    ByteArrayOutputStream boas = new ByteArrayOutputStream();    BinaryOutputArchive boa = BinaryOutputArchive.getArchive(boas);    CreateRequest createReq = new CreateRequest("/session" + Long.toHexString(sessionId) + "-" + (++nodeId), new byte[0], Ids.OPEN_ACL_UNSAFE, 1);    createReq.serialize(boa, "request");    ByteBuffer bb = ByteBuffer.wrap(boas.toByteArray());    Request req = new Request(null, sessionId, ++cxid, OpCode.create, bb, new ArrayList<Id>());    zks.getFirstProcessor().processRequest(req);}
sendReadRequest
public void zookeeper_f4973_0() throws Exception
{    ByteArrayOutputStream boas = new ByteArrayOutputStream();    BinaryOutputArchive boa = BinaryOutputArchive.getArchive(boas);    GetDataRequest getDataRequest = new GetDataRequest("/session" + Long.toHexString(sessionId) + "-" + nodeId, false);    getDataRequest.serialize(boa, "request");    ByteBuffer bb = ByteBuffer.wrap(boas.toByteArray());    Request req = new Request(null, sessionId, ++cxid, OpCode.getData, bb, new ArrayList<Id>());    zks.getFirstProcessor().processRequest(req);}
run
public voidf4974_1)
{    Random rand = new Random(Thread.currentThread().getId());    try {        sendWriteRequest();        while (!stopped) {            if (rand.nextInt(100) < writePercent) {                sendWriteRequest();            } else {                sendReadRequest();            }            Thread.sleep(5 + rand.nextInt(95));        }    } catch (Exception e) {            }}
testNoCommitWorkersReadOnlyWorkload
public voidf4975_1) throws Exception
{    int numClients = 10;        setUp(0, numClients, 0);    synchronized (this) {        wait(TEST_RUN_TIME_IN_MS);    }    assertFalse(fail);    assertTrue("No read requests processed", processedReadRequests.get() > 0);        assertTrue("Write requests processed", processedWriteRequests.get() == numClients);}
testNoCommitWorkersMixedWorkload
public voidf4976_1) throws Exception
{    int numClients = 10;        setUp(0, numClients, 25);    synchronized (this) {        wait(TEST_RUN_TIME_IN_MS);    }    assertFalse(fail);    checkProcessedRequest();}
testOneCommitWorkerReadOnlyWorkload
public voidf4977_1) throws Exception
{    int numClients = 10;        setUp(1, numClients, 0);    synchronized (this) {        wait(TEST_RUN_TIME_IN_MS);    }    assertFalse(fail);    assertTrue("No read requests processed", processedReadRequests.get() > 0);        assertTrue("Write requests processed", processedWriteRequests.get() == numClients);}
testOneCommitWorkerMixedWorkload
public voidf4978_1) throws Exception
{    setUp(1, 10, 25);        synchronized (this) {        wait(TEST_RUN_TIME_IN_MS);    }    assertFalse(fail);    checkProcessedRequest();}
testManyCommitWorkersReadOnly
public voidf4979_1) throws Exception
{    int numClients = 10;        setUp(10, numClients, 0);    synchronized (this) {        wait(TEST_RUN_TIME_IN_MS);    }    assertFalse(fail);    assertTrue("No read requests processed", processedReadRequests.get() > 0);        assertTrue("Write requests processed", processedWriteRequests.get() == numClients);}
testManyCommitWorkersMixedWorkload
public voidf4980_1) throws Exception
{    setUp(16, 8, 8, 25);        synchronized (this) {        wait(TEST_RUN_TIME_IN_MS);    }    assertFalse(fail);    checkProcessedRequest();}
checkProcessedRequest
private void zookeeper_f4981_0()
{    assertTrue("No read requests processed", processedReadRequests.get() > 0);    assertTrue("No write requests processed", processedWriteRequests.get() > 0);}
failTest
private synchronized void zookeeper_f4982_0(String reason)
{    fail = true;    notifyAll();    fail(reason);}
getFirstProcessor
public PrepRequestProcessor zookeeper_f4983_0()
{    return (PrepRequestProcessor) firstProcessor;}
setupRequestProcessors
protected void zookeeper_f4984_0()
{    RequestProcessor finalProcessor = new FinalRequestProcessor(zks);            ValidateProcessor validateProcessor = new ValidateProcessor(finalProcessor);    commitProcessor = new CommitProcessor(validateProcessor, "1", true, null);    validateProcessor.setCommitProcessor(commitProcessor);    commitProcessor.start();    MockProposalRequestProcessor proposalProcessor = new MockProposalRequestProcessor(commitProcessor);    proposalProcessor.start();    firstProcessor = new PrepRequestProcessor(zks, proposalProcessor);    getFirstProcessor().start();}
run
public void zookeeper_f4985_0()
{    Random rand = new Random(Thread.currentThread().getId());    try {        while (true) {                        if (!proposals.isEmpty()) {                Request request = proposals.take();                Thread.sleep(5 + rand.nextInt(95));                commitProcessor.commit(request);            }        }    } catch (InterruptedException e) {        }}
processRequest
public void zookeeper_f4986_0(Request request) throws RequestProcessorException
{    commitProcessor.processRequest(request);    if (request.getHdr() != null) {                proposals.add(request);    }}
shutdown
public voidf4987_1)
{        proposals.clear();    if (commitProcessor != null) {        commitProcessor.shutdown();    }}
setCommitProcessor
public void zookeeper_f4988_0(CommitProcessor commitProcessor)
{    this.commitProcessor = commitProcessor;}
processRequest
public voidf4989_1Request request) throws RequestProcessorException
{    if (stopped) {        return;    }    if (request.type == OpCode.closeSession) {                nextProcessor.processRequest(request);        return;    }    boolean isWriteRequest = commitProcessor.needCommit(request);    if (isWriteRequest) {        outstandingWriteRequests.incrementAndGet();        validateWriteRequestVariant(request);            } else {                outstandingReadRequests.incrementAndGet();        validateReadRequestVariant(request);    }        try {        Thread.sleep(5 + rand.nextInt(25));    } catch (InterruptedException e) {        }    nextProcessor.processRequest(request);    /*             * The commit workers will have to execute this line before they             * wake up the commit processor. So this value is up-to-date when             * variant check is performed             */    if (isWriteRequest) {        outstandingWriteRequests.decrementAndGet();                processedWriteRequests.incrementAndGet();    } else {        outstandingReadRequests.decrementAndGet();                processedReadRequests.incrementAndGet();    }    validateRequest(request);}
validateWriteRequestVariant
private void zookeeper_f4990_0(Request request)
{    if (stopped) {        return;    }    long zxid = request.getHdr().getZxid();    int readRequests = outstandingReadRequests.get();    if (readRequests != 0) {        failTest("There are " + readRequests + " outstanding" + " read requests while issuing a write request zxid=" + zxid);    }    int writeRequests = outstandingWriteRequests.get();    if (writeRequests > 1) {        failTest("There are " + writeRequests + " outstanding" + " write requests while issuing a write request zxid=" + zxid + " (expected one)");    }}
validateReadRequestVariant
private void zookeeper_f4991_0(Request request)
{    int writeRequests = outstandingWriteRequests.get();    if (writeRequests != 0) {        failTest("There are " + writeRequests + " outstanding" + " write requests while issuing a read request cxid=" + request.cxid + " for session 0x" + Long.toHexString(request.sessionId));    }}
validateRequest
private voidf4992_1Request request)
{    if (LOG.isDebugEnabled()) {            }        if (request.getHdr() != null) {        long zxid = request.getHdr().getZxid();        if (!expectedZxid.compareAndSet(zxid, zxid + 1)) {            failTest("Write request, expected_zxid=" + expectedZxid.get() + "; req_zxid=" + zxid);        }    }        AtomicInteger sessionCxid = cxidMap.get(request.sessionId);    if (sessionCxid == null) {        sessionCxid = new AtomicInteger(request.cxid + 1);        AtomicInteger existingSessionCxid = cxidMap.putIfAbsent(request.sessionId, sessionCxid);        if (existingSessionCxid != null) {            failTest("Race condition adding cxid=" + request.cxid + " for session 0x" + Long.toHexString(request.sessionId) + " with other_cxid=" + existingSessionCxid.get());        }    } else {        if (!sessionCxid.compareAndSet(request.cxid, request.cxid + 1)) {            failTest("Expected_cxid=" + sessionCxid.get() + "; req_cxid=" + request.cxid);        }    }}
shutdown
public voidf4993_1)
{        cxidMap.clear();    expectedZxid = new AtomicLong(1);    if (nextProcessor != null) {        nextProcessor.shutdown();    }}
processRequest
public void zookeeper_f4994_0(Request request) throws RequestProcessorException
{    if (blocking) {        incomingRequests.add(request);    } else {        next.processRequest(request);    }}
submitRequest
public void zookeeper_f4995_0(Request request) throws RequestProcessorException
{    next.processRequest(request);}
shutdown
public void zookeeper_f4996_0()
{}
unblockQueue
public void zookeeper_f4997_0() throws RequestProcessorException
{    if (blocking) {        for (Request request : incomingRequests) {            next.processRequest(request);        }        blocking = false;    }}
injectDelayRequestProcessor
public static DelayRequestProcessor zookeeper_f4998_0(FollowerZooKeeperServer zooKeeperServer)
{    RequestProcessor finalRequestProcessor = zooKeeperServer.commitProcessor.nextProcessor;    DelayRequestProcessor delayRequestProcessor = new DelayRequestProcessor(finalRequestProcessor);    zooKeeperServer.commitProcessor.nextProcessor = delayRequestProcessor;    return delayRequestProcessor;}
data
public static Collection<Object[]> zookeeper_f4999_0()
{    return Arrays.asList(new Object[][] { { ServerState.LEADING, true }, { ServerState.LEADING, false }, { ServerState.FOLLOWING, true }, { ServerState.FOLLOWING, false }, { ServerState.OBSERVING, true }, { ServerState.OBSERVING, false } });}
setUp
public void zookeeper_f5000_0() throws Exception
{    ensureCheck(checkEnabled);    CountdownWatcher clientWatch = new CountdownWatcher();    CountdownWatcher clientWatchB = new CountdownWatcher();    super.setUp(true);    String hostPort = getPeersMatching(serverState).split(",")[0];    int clientPort = Integer.parseInt(hostPort.split(":")[1]);    zkLeader = getPeerList().get(getLeaderIndex());    connectedServer = getPeerByClientPort(clientPort).getActiveServer();    zkClient = createClient(clientWatch, hostPort);    zkClientB = createClient(clientWatchB, hostPort);    zkClient.addAuthInfo(AUTH_PROVIDER, AUTH);    zkClientB.addAuthInfo(AUTH_PROVIDER, AUTHB);    clientWatch.waitForConnected(CONNECTION_TIMEOUT);    clientWatchB.waitForConnected(CONNECTION_TIMEOUT);}
tearDown
public void zookeeper_f5001_0() throws Exception
{    if (zkClient != null) {        zkClient.close();    }    if (zkClientB != null) {        zkClientB.close();    }    super.tearDown();}
ensureCheck
private void zookeeper_f5002_0(boolean enabled)
{    if (enabled) {        System.setProperty(ZooKeeperServer.ENABLE_EAGER_ACL_CHECK, "true");    } else {        System.clearProperty(ZooKeeperServer.ENABLE_EAGER_ACL_CHECK);    }}
assertTransactionState
private void zookeeper_f5003_0(String condition, long lastxid)
{    String assertion = String.format("Server State: %s Check Enabled: %s %s", serverState, checkEnabled, condition);    if (checkEnabled) {        assertEquals(assertion, lastxid, zkLeader.getLastLoggedZxid());    } else {        assertNotSame(assertion, lastxid, zkLeader.getLastLoggedZxid());    }}
testCreateOK
public void zookeeper_f5004_0() throws Exception
{    ensureCheck(true);    zkClient.create(PARENT_PATH, DATA, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zkClientB.create(CHILD_PATH, DATA, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    assertEquals("OutstandingRequests not decremented", 0, connectedServer.getInProcess());}
testCreate2OK
public void zookeeper_f5005_0() throws Exception
{    zkClient.create(PARENT_PATH, DATA, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, null);    zkClientB.create(CHILD_PATH, DATA, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, null);    assertEquals("OutstandingRequests not decremented", 0, connectedServer.getInProcess());}
testCreateFail
public void zookeeper_f5006_0() throws Exception
{    zkClient.create(PARENT_PATH, DATA, Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT);    long lastxid = zkLeader.getLastLoggedZxid();    try {        zkClientB.create(CHILD_PATH, DATA, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    } catch (KeeperException.NoAuthException e) {    }    assertEquals("OutstandingRequests not decremented", 0, connectedServer.getInProcess());    assertTransactionState("Transaction state on Leader after failed create", lastxid);}
testCreate2Fail
public void zookeeper_f5007_0() throws Exception
{    zkClient.create(PARENT_PATH, DATA, Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT, null);    long lastxid = zkLeader.getLastLoggedZxid();    try {        zkClientB.create(CHILD_PATH, DATA, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, null);    } catch (KeeperException.NoAuthException e) {    }    assertEquals("OutstandingRequests not decremented", 0, connectedServer.getInProcess());    assertTransactionState("Transaction state on Leader after failed create2", lastxid);}
testDeleteOK
public void zookeeper_f5008_0() throws Exception
{    zkClient.create(PARENT_PATH, DATA, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zkClientB.delete(PARENT_PATH, -1);    assertEquals("OutstandingRequests not decremented", 0, connectedServer.getInProcess());}
testDeleteFail
public void zookeeper_f5009_0() throws Exception
{    zkClient.create(PARENT_PATH, DATA, Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT, null);    zkClient.create(CHILD_PATH, DATA, Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT, null);    long lastxid = zkLeader.getLastLoggedZxid();    try {        zkClientB.delete(CHILD_PATH, -1);    } catch (KeeperException.NoAuthException e) {    }    assertEquals("OutstandingRequests not decremented", 0, connectedServer.getInProcess());    assertTransactionState("Transaction state on Leader after failed delete", lastxid);}
testSetDataOK
public void zookeeper_f5010_0() throws Exception
{    zkClient.create(PARENT_PATH, null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, null);    zkClientB.setData(PARENT_PATH, DATA, -1);}
testSetDataFail
public void zookeeper_f5011_0() throws Exception
{    zkClient.create(PARENT_PATH, null, Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT, null);    long lastxid = zkLeader.getLastLoggedZxid();    try {        zkClientB.setData(PARENT_PATH, DATA, -1);    } catch (KeeperException.NoAuthException e) {    }    assertEquals("OutstandingRequests not decremented", 0, connectedServer.getInProcess());    assertTransactionState("Transaction state on Leader after failed setData", lastxid);}
testSetACLOK
public void zookeeper_f5012_0() throws Exception
{    zkClient.create(PARENT_PATH, null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, null);    zkClientB.setACL(PARENT_PATH, Ids.READ_ACL_UNSAFE, -1);    assertEquals("OutstandingRequests not decremented", 0, connectedServer.getInProcess());}
testSetACLFail
public void zookeeper_f5013_0() throws Exception
{    zkClient.create(PARENT_PATH, null, Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT, null);    long lastxid = zkLeader.getLastLoggedZxid();    try {        zkClientB.setACL(PARENT_PATH, Ids.READ_ACL_UNSAFE, -1);    } catch (KeeperException.NoAuthException e) {    }    assertEquals("OutstandingRequests not decremented", 0, connectedServer.getInProcess());    assertTransactionState("Transaction state on Leader after failed setACL", lastxid);}
testBadACL
public void zookeeper_f5014_0() throws Exception
{    CountdownWatcher cw = new CountdownWatcher();    TestableZooKeeper zk = createClient(cw, getPeersMatching(serverState));    long lastxid;    cw.waitForConnected(CONNECTION_TIMEOUT);    lastxid = zkLeader.getLastLoggedZxid();    try {        zk.create("/acltest", new byte[0], Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT);        fail("Should have received an invalid acl error");    } catch (KeeperException.InvalidACLException e) {    }    assertEquals("OutstandingRequests not decremented", 0, connectedServer.getInProcess());    assertTransactionState("zxid after invalid ACL", lastxid);}
testEphemeralNodeDeletion
public void zookeeper_f5015_0() throws Exception
{    final int[] clientPorts = new int[SERVER_COUNT];    StringBuilder sb = new StringBuilder();    String server;    for (int i = 0; i < SERVER_COUNT; i++) {        clientPorts[i] = PortAssignment.unique();        server = "server." + i + "=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ":participant;127.0.0.1:" + clientPorts[i];        sb.append(server + "\n");    }    String currentQuorumCfgSection = sb.toString();        for (int i = 0; i < SERVER_COUNT; i++) {        mt[i] = new MainThread(i, clientPorts[i], currentQuorumCfgSection, false) {            @Override            public TestQPMain getTestQPMain() {                return new MockTestQPMain();            }        };        mt[i].start();    }        for (int i = 0; i < SERVER_COUNT; i++) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts[i], CONNECTION_TIMEOUT));    }    CountdownWatcher watch = new CountdownWatcher();    ZooKeeper zk = new ZooKeeper("127.0.0.1:" + clientPorts[1], ClientBase.CONNECTION_TIMEOUT, watch);    watch.waitForConnected(ClientBase.CONNECTION_TIMEOUT);    /**     * now the problem scenario starts     */    Stat firstEphemeralNode = new Stat();        String nodePath = "/e1";    zk.create(nodePath, "1".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL, firstEphemeralNode);    assertEquals("Current session and ephemeral owner should be same", zk.getSessionId(), firstEphemeralNode.getEphemeralOwner());        CustomQuorumPeer follower = (CustomQuorumPeer) getByServerState(mt, ServerState.FOLLOWING);    follower.setInjectError(true);        zk.close();        follower.setInjectError(false);    assertTrue("Faulted Follower should have joined quorum by now", ClientBase.waitForServerUp("127.0.0.1:" + follower.getClientPort(), CONNECTION_TIMEOUT));    QuorumPeer leader = getByServerState(mt, ServerState.LEADING);    assertNotNull("Leader should not be null", leader);    assertTrue("Leader must be running", ClientBase.waitForServerUp("127.0.0.1:" + leader.getClientPort(), CONNECTION_TIMEOUT));    watch = new CountdownWatcher();    zk = new ZooKeeper("127.0.0.1:" + leader.getClientPort(), ClientBase.CONNECTION_TIMEOUT, watch);    watch.waitForConnected(ClientBase.CONNECTION_TIMEOUT);    Stat exists = zk.exists(nodePath, false);    assertNull("Node must have been deleted from leader", exists);    CountdownWatcher followerWatch = new CountdownWatcher();    ZooKeeper followerZK = new ZooKeeper("127.0.0.1:" + follower.getClientPort(), ClientBase.CONNECTION_TIMEOUT, followerWatch);    followerWatch.waitForConnected(ClientBase.CONNECTION_TIMEOUT);    Stat nodeAtFollower = followerZK.exists(nodePath, false);        assertNull("ephemeral node must not exist", nodeAtFollower);        Stat currentEphemeralNode = new Stat();    zk.create(nodePath, "2".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL, currentEphemeralNode);        zk.close();    SyncCallback cb = new SyncCallback();    followerZK.sync(nodePath, cb, null);    cb.sync.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS);    nodeAtFollower = followerZK.exists(nodePath, false);                assertNull("After session close ephemeral node must be deleted", nodeAtFollower);    followerZK.close();}
getTestQPMain
public TestQPMain zookeeper_f5016_0()
{    return new MockTestQPMain();}
tearDown
public voidf5017_1)
{        for (int i = 0; i < mt.length; i++) {        try {            mt[i].shutdown();        } catch (InterruptedException e) {                    }    }}
getByServerState
private QuorumPeer zookeeper_f5018_0(MainThread[] mt, ServerState state)
{    for (int i = mt.length - 1; i >= 0; i--) {        QuorumPeer quorumPeer = mt[i].getQuorumPeer();        if (null != quorumPeer && state == quorumPeer.getPeerState()) {            return quorumPeer;        }    }    return null;}
makeFollower
protected Follower zookeeper_f5019_0(FileTxnSnapLog logFactory) throws IOException
{    return new Follower(this, new FollowerZooKeeperServer(logFactory, this, this.getZkDb())) {        @Override        void readPacket(QuorumPacket pp) throws IOException {            /**             * In real scenario got SocketTimeoutException while reading             * the packet from leader because of network problem, but             * here throwing SocketTimeoutException based on whether             * error is injected or not             */            super.readPacket(pp);            if (injectError && pp.getType() == Leader.PROPOSAL) {                String type = LearnerHandler.packetToString(pp);                throw new SocketTimeoutException("Socket timeout while reading the packet for operation " + type);            }        }    };}
readPacket
 void zookeeper_f5020_0(QuorumPacket pp) throws IOException
{    /**     * In real scenario got SocketTimeoutException while reading     * the packet from leader because of network problem, but     * here throwing SocketTimeoutException based on whether     * error is injected or not     */    super.readPacket(pp);    if (injectError && pp.getType() == Leader.PROPOSAL) {        String type = LearnerHandler.packetToString(pp);        throw new SocketTimeoutException("Socket timeout while reading the packet for operation " + type);    }}
setInjectError
public void zookeeper_f5021_0(boolean injectError)
{    this.injectError = injectError;}
getQuorumPeer
protected QuorumPeer zookeeper_f5022_0() throws SaslException
{    return new CustomQuorumPeer();}
processResult
public void zookeeper_f5023_0(int rc, String path, Object ctx)
{    sync.countDown();}
setUp
public void zookeeper_f5024_0() throws Exception
{    count = 3;    peers = new HashMap<Long, QuorumServer>(count);    tmpdir = new File[count];    port = new int[count];    cnxManagers = new QuorumCnxManager[count - 1];}
tearDown
public void zookeeper_f5025_0() throws Exception
{    for (int i = 0; i < (count - 1); i++) {        if (cnxManagers[i] != null) {            cnxManagers[i].halt();        }    }}
testBackwardElectionRound
public voidf5026_1) throws Exception
{        for (int i = 0; i < count; i++) {        int clientport = PortAssignment.unique();        peers.put(Long.valueOf(i), new QuorumServer(i, new InetSocketAddress(clientport), new InetSocketAddress(PortAssignment.unique())));        tmpdir[i] = ClientBase.createTmpDir();        port[i] = clientport;    }    ByteBuffer initialMsg0 = getMsg();    ByteBuffer initialMsg1 = getMsg();    /*         * Start server 0         */    QuorumPeer peer = new QuorumPeer(peers, tmpdir[0], tmpdir[0], port[0], 3, 0, 1000, 2, 2, 2);    peer.startLeaderElection();    FLETestUtils.LEThread thread = new FLETestUtils.LEThread(peer, 0);    thread.start();    /*         * Start mock server 1         */    QuorumPeer mockPeer = new QuorumPeer(peers, tmpdir[1], tmpdir[1], port[1], 3, 1, 1000, 2, 2, 2);    cnxManagers[0] = mockPeer.createCnxnManager();    cnxManagers[0].listener.start();    cnxManagers[0].toSend(0L, initialMsg0);    /*         * Start mock server 2         */    mockPeer = new QuorumPeer(peers, tmpdir[2], tmpdir[2], port[2], 3, 2, 1000, 2, 2, 2);    cnxManagers[1] = mockPeer.createCnxnManager();    cnxManagers[1].listener.start();    cnxManagers[1].toSend(0L, initialMsg1);    /*         * Run another instance of leader election.         */    thread.join(5000);    thread = new FLETestUtils.LEThread(peer, 0);    thread.start();    /*         * Send the same messages, this time should not make 0 the leader.         */    cnxManagers[0].toSend(0L, initialMsg0);    cnxManagers[1].toSend(0L, initialMsg1);    thread.join(5000);    if (!thread.isAlive()) {        fail("Should not have joined");    }}
getMsg
private ByteBuffer zookeeper_f5027_0()
{    return FLETestUtils.createMsg(ServerState.FOLLOWING.ordinal(), 0, 0, 1);}
setUp
public void zookeeper_f5028_0() throws Exception
{    count = 3;    peers = new HashMap<Long, QuorumServer>(count);    tmpdir = new File[count];    port = new int[count];}
tearDown
public void zookeeper_f5029_0() throws Exception
{    cnxManager.halt();}
testLostMessage
public voidf5030_1) throws Exception
{        for (int i = 0; i < count; i++) {        int clientport = PortAssignment.unique();        peers.put(Long.valueOf(i), new QuorumServer(i, new InetSocketAddress(clientport), new InetSocketAddress(PortAssignment.unique())));        tmpdir[i] = ClientBase.createTmpDir();        port[i] = clientport;    }    /*         * Start server 0         */    QuorumPeer peer = new QuorumPeer(peers, tmpdir[1], tmpdir[1], port[1], 3, 1, 1000, 2, 2, 2);    peer.startLeaderElection();    FLETestUtils.LEThread thread = new FLETestUtils.LEThread(peer, 1);    thread.start();    /*         * Start mock server 1         */    mockServer();    thread.join(5000);    if (thread.isAlive()) {        fail("Threads didn't join");    }}
mockServer
 void zookeeper_f5031_0() throws InterruptedException, IOException
{    QuorumPeer peer = new QuorumPeer(peers, tmpdir[0], tmpdir[0], port[0], 3, 0, 1000, 2, 2, 2);    cnxManager = peer.createCnxnManager();    cnxManager.listener.start();    cnxManager.toSend(1L, FLETestUtils.createMsg(ServerState.LOOKING.ordinal(), 0, 0, 0));    cnxManager.recvQueue.take();    cnxManager.toSend(1L, FLETestUtils.createMsg(ServerState.FOLLOWING.ordinal(), 1, 0, 0));}
setUp
public void zookeeper_f5032_0() throws Exception
{    File tmpdir = ClientBase.createTmpDir();    Map<Long, QuorumServer> peers = new HashMap<Long, QuorumServer>();    for (int i = 0; i < 5; i++) {        peers.put(Long.valueOf(i), new QuorumServer(Long.valueOf(i), new InetSocketAddress("127.0.0.1", PortAssignment.unique())));    }    QuorumPeer peer = new QuorumPeer(peers, tmpdir, tmpdir, PortAssignment.unique(), 3, 3, 1000, 2, 2, 2);    fle = new FastLeaderElection(peer, peer.createCnxnManager());}
testIgnoringZxidElectionEpoch
public void zookeeper_f5033_0()
{    Map<Long, Vote> votes = new HashMap<Long, Vote>();    votes.put(0L, new Vote(0x1, 4L, ZxidUtils.makeZxid(1, 1), 1, 2, ServerState.FOLLOWING));    votes.put(1L, new Vote(0x1, 4L, ZxidUtils.makeZxid(1, 2), 1, 2, ServerState.FOLLOWING));    votes.put(3L, new Vote(0x1, 4L, ZxidUtils.makeZxid(2, 1), 2, 2, ServerState.FOLLOWING));    votes.put(4L, new Vote(0x1, 4L, ZxidUtils.makeZxid(2, 1), 2, 2, ServerState.LEADING));    assertTrue(fle.getVoteTracker(votes, new Vote(4L, ZxidUtils.makeZxid(2, 1), 2, 2, ServerState.FOLLOWING)).hasAllQuorums());}
testElectionWIthDifferentVersion
public void zookeeper_f5034_0()
{    Map<Long, Vote> votes = new HashMap<Long, Vote>();    votes.put(0L, new Vote(0x1, 4L, ZxidUtils.makeZxid(1, 1), 1, 1, ServerState.FOLLOWING));    votes.put(1L, new Vote(0x1, 4L, ZxidUtils.makeZxid(1, 1), 1, 1, ServerState.FOLLOWING));    votes.put(3L, new Vote(4L, ZxidUtils.makeZxid(2, 1), 2, 2, ServerState.FOLLOWING));    votes.put(4L, new Vote(4L, ZxidUtils.makeZxid(2, 1), 2, 2, ServerState.LEADING));    assertTrue(fle.getVoteTracker(votes, new Vote(4L, ZxidUtils.makeZxid(2, 1), 2, 2, ServerState.FOLLOWING)).hasAllQuorums());}
testLookingNormal
public void zookeeper_f5035_0()
{    Map<Long, Vote> votes = new HashMap<Long, Vote>();    votes.put(0L, new Vote(4L, ZxidUtils.makeZxid(2, 1), 1, 1, ServerState.LOOKING));    votes.put(1L, new Vote(4L, ZxidUtils.makeZxid(2, 1), 1, 1, ServerState.LOOKING));    votes.put(3L, new Vote(4L, ZxidUtils.makeZxid(2, 1), 1, 1, ServerState.LOOKING));    votes.put(4L, new Vote(4L, ZxidUtils.makeZxid(2, 1), 1, 1, ServerState.LEADING));    assertTrue(fle.getVoteTracker(votes, new Vote(4L, ZxidUtils.makeZxid(2, 1), 1, 1, ServerState.LOOKING)).hasAllQuorums());}
testLookingDiffRounds
public void zookeeper_f5036_0()
{    HashMap<Long, Vote> votes = new HashMap<Long, Vote>();    votes.put(0L, new Vote(4L, ZxidUtils.makeZxid(1, 1), 1, 1, ServerState.LOOKING));    votes.put(1L, new Vote(4L, ZxidUtils.makeZxid(2, 1), 2, 2, ServerState.LOOKING));    votes.put(3L, new Vote(4L, ZxidUtils.makeZxid(2, 1), 3, 2, ServerState.LOOKING));    votes.put(4L, new Vote(4L, ZxidUtils.makeZxid(2, 1), 3, 2, ServerState.LEADING));    assertFalse(fle.getVoteTracker(votes, new Vote(4L, ZxidUtils.makeZxid(2, 1), 2, 2, ServerState.LOOKING)).hasAllQuorums());}
testOutofElection
public void zookeeper_f5037_0()
{    HashMap<Long, Vote> outofelection = new HashMap<Long, Vote>();    outofelection.put(1L, new Vote(0x0, 5, ZxidUtils.makeZxid(15, 0), 0xa, 0x17, ServerState.FOLLOWING));    outofelection.put(2L, new Vote(0x0, 5, ZxidUtils.makeZxid(15, 0), 0xa, 0x17, ServerState.FOLLOWING));    outofelection.put(4L, new Vote(0x1, 5, ZxidUtils.makeZxid(15, 0), 0xa, 0x18, ServerState.FOLLOWING));    Vote vote = new Vote(0x1, 5, ZxidUtils.makeZxid(15, 0), 0xa, 0x18, ServerState.LEADING);    outofelection.put(5L, vote);    Notification n = new Notification();    n.version = vote.getVersion();    n.leader = vote.getId();    n.zxid = vote.getZxid();    n.electionEpoch = vote.getElectionEpoch();    n.state = vote.getState();    n.peerEpoch = vote.getPeerEpoch();    n.sid = 5L;        fle.logicalclock.set(0x1);    assertTrue("Quorum check failed", fle.getVoteTracker(outofelection, new Vote(n.version, n.leader, n.zxid, n.electionEpoch, n.peerEpoch, n.state)).hasAllQuorums());    assertTrue("Leader check failed", fle.checkLeader(outofelection, n.leader, n.electionEpoch));}
run
public voidf5038_1)
{    try {        Vote v = null;        peer.setPeerState(ServerState.LOOKING);                v = peer.getElectionAlg().lookForLeader();        if (v == null) {            fail("Thread " + i + " got a null vote");        }        /*                 * A real zookeeper would take care of setting the current vote. Here                 * we do it manually.                 */        peer.setCurrentVote(v);                assertTrue("State is not leading.", peer.getPeerState() == ServerState.LEADING);    } catch (Exception e) {        e.printStackTrace();    }    }
createMsg
 static ByteBuffer zookeeper_f5039_0(int state, long leader, long zxid, long epoch)
{    return FastLeaderElection.buildMsg(state, leader, zxid, 1, epoch);}
setup
public voidf5040_1) throws Exception
{        final int ENSEMBLE_SERVERS = 3;    clientPorts = new int[ENSEMBLE_SERVERS];    StringBuilder sb = new StringBuilder();    String server;    for (int i = 0; i < ENSEMBLE_SERVERS; i++) {        clientPorts[i] = PortAssignment.unique();        server = "server." + i + "=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ":participant;127.0.0.1:" + clientPorts[i];        sb.append(server + "\n");    }    String currentQuorumCfgSection = sb.toString();        mt = new MainThread[ENSEMBLE_SERVERS];    zk = new ZooKeeper[ENSEMBLE_SERVERS];    for (int i = 0; i < ENSEMBLE_SERVERS; i++) {        mt[i] = new MainThread(i, clientPorts[i], currentQuorumCfgSection, false) {            @Override            public TestQPMain getTestQPMain() {                return new CustomizedQPMain();            }        };        mt[i].start();        zk[i] = new ZooKeeper("127.0.0.1:" + clientPorts[i], ClientBase.CONNECTION_TIMEOUT, this);    }    QuorumPeerMainTest.waitForAll(zk, States.CONNECTED);        leaderId = -1;    followerA = -1;    for (int i = 0; i < ENSEMBLE_SERVERS; i++) {        if (mt[i].main.quorumPeer.leader != null) {            leaderId = i;        } else if (followerA == -1) {            followerA = i;        }    }}
getTestQPMain
public TestQPMain zookeeper_f5041_0()
{    return new CustomizedQPMain();}
tearDown
public void zookeeper_f5042_0() throws Exception
{    if (mt != null) {        for (MainThread t : mt) {            t.shutdown();        }    }    if (zk != null) {        for (ZooKeeper z : zk) {            z.close();        }    }}
testMultiOpConsistency
public voidf5043_1) throws Exception
{        final String path = "/testMultiOpConsistency";    createEmptyNode(zk[followerA], path, CreateMode.PERSISTENT);        CustomDataTree dt = (CustomDataTree) mt[followerA].main.quorumPeer.getZkDb().getDataTree();    final ZooKeeperServer zkServer = mt[followerA].main.quorumPeer.getActiveServer();    String node1 = path + "/1";    String node2 = path + "/2";    dt.addNodeCreateListener(node2, new NodeCreateListener() {        @Override        public void process(String path) {                        zkServer.takeSnapshot(true);        }    });        zk[followerA].multi(Arrays.asList(Op.create(node1, node1.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT), Op.create(node2, node2.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT)));        mt[followerA].shutdown();    QuorumPeerMainTest.waitForOne(zk[followerA], States.CONNECTING);    mt[followerA].start();    QuorumPeerMainTest.waitForOne(zk[followerA], States.CONNECTED);        assertEquals(new String(zk[leaderId].getData(node2, null, null)), new String(zk[followerA].getData(node2, null, null)));}
process
public voidf5044_1String path)
{        zkServer.takeSnapshot(true);}
testPZxidUpdatedDuringSnapSyncing
public voidf5045_1) throws Exception
{        System.setProperty(LearnerHandler.FORCE_SNAP_SYNC, "true");    final String parent = "/testPZxidUpdatedWhenDeletingNonExistNode";    final String child = parent + "/child";    createEmptyNode(zk[leaderId], parent, CreateMode.PERSISTENT);    createEmptyNode(zk[leaderId], child, CreateMode.EPHEMERAL);        createEmptyNode(zk[leaderId], child + "1", CreateMode.EPHEMERAL);        mt[followerA].shutdown();    QuorumPeerMainTest.waitForOne(zk[followerA], States.CONNECTING);        addSerializeListener(leaderId, parent, child);        mt[followerA].start();    QuorumPeerMainTest.waitForOne(zk[followerA], States.CONNECTED);        compareStat(parent, leaderId, followerA);}
testPZxidUpdatedWhenLoadingSnapshot
public voidf5046_1) throws Exception
{    final String parent = "/testPZxidUpdatedDuringTakingSnapshot";    final String child = parent + "/child";    createEmptyNode(zk[followerA], parent, CreateMode.PERSISTENT);    createEmptyNode(zk[followerA], child, CreateMode.EPHEMERAL);        createEmptyNode(zk[leaderId], child + "1", CreateMode.EPHEMERAL);        addSerializeListener(followerA, parent, child);        ZooKeeperServer zkServer = mt[followerA].main.quorumPeer.getActiveServer();    zkServer.takeSnapshot(true);        mt[followerA].shutdown();    QuorumPeerMainTest.waitForOne(zk[followerA], States.CLOSED);    mt[followerA].start();        zk[followerA] = new ZooKeeper("127.0.0.1:" + clientPorts[followerA], ClientBase.CONNECTION_TIMEOUT, this);    QuorumPeerMainTest.waitForOne(zk[followerA], States.CONNECTED);        compareStat(parent, leaderId, followerA);}
addSerializeListener
private voidf5047_1int sid, String parent, String child)
{    final ZooKeeper zkClient = zk[sid];    CustomDataTree dt = (CustomDataTree) mt[sid].main.quorumPeer.getZkDb().getDataTree();    dt.addListener(parent, new NodeSerializeListener() {        @Override        public void nodeSerialized(String path) {            try {                zkClient.delete(child, -1);                zkClient.close();                            } catch (Exception e) {                            }        }    });}
nodeSerialized
public voidf5048_1String path)
{    try {        zkClient.delete(child, -1);        zkClient.close();            } catch (Exception e) {            }}
compareStat
private void zookeeper_f5049_0(String path, int sid, int compareWithSid) throws Exception
{    ZooKeeper[] compareZk = new ZooKeeper[2];    compareZk[0] = new ZooKeeper("127.0.0.1:" + clientPorts[sid], ClientBase.CONNECTION_TIMEOUT, this);    compareZk[1] = new ZooKeeper("127.0.0.1:" + clientPorts[compareWithSid], ClientBase.CONNECTION_TIMEOUT, this);    QuorumPeerMainTest.waitForAll(compareZk, States.CONNECTED);    try {        Stat stat1 = new Stat();        compareZk[0].getData(path, null, stat1);        Stat stat2 = new Stat();        compareZk[1].getData(path, null, stat2);        assertEquals(stat1, stat2);    } finally {        for (ZooKeeper z : compareZk) {            z.close();        }    }}
testGlobalSessionConsistency
public voidf5050_1) throws Exception
{        CustomizedQPMain followerAMain = (CustomizedQPMain) mt[followerA].main;    final ZooKeeperServer zkServer = followerAMain.quorumPeer.getActiveServer();        final AtomicBoolean shouldTakeSnapshot = new AtomicBoolean(true);    followerAMain.setCommitSessionListener(new CommitSessionListener() {        @Override        public void process(long sessionId) {                        if (shouldTakeSnapshot.getAndSet(false)) {                zkServer.takeSnapshot(true);            }        }    });        ZooKeeper globalClient = new ZooKeeper("127.0.0.1:" + clientPorts[followerA], ClientBase.CONNECTION_TIMEOUT, this);    QuorumPeerMainTest.waitForOne(globalClient, States.CONNECTED);        mt[followerA].shutdown();    QuorumPeerMainTest.waitForOne(zk[followerA], States.CONNECTING);    mt[followerA].start();    QuorumPeerMainTest.waitForOne(zk[followerA], States.CONNECTED);        Map<Long, Integer> globalSessionsOnLeader = mt[leaderId].main.quorumPeer.getZkDb().getSessionWithTimeOuts();    Map<Long, Integer> globalSessionsOnFollowerA = mt[followerA].main.quorumPeer.getZkDb().getSessionWithTimeOuts();        assertTrue(globalSessionsOnFollowerA.keySet().containsAll(globalSessionsOnLeader.keySet()));}
process
public voidf5051_1long sessionId)
{        if (shouldTakeSnapshot.getAndSet(false)) {        zkServer.takeSnapshot(true);    }}
createEmptyNode
private void zookeeper_f5052_0(ZooKeeper zk, String path, CreateMode mode) throws Exception
{    zk.create(path, new byte[0], Ids.OPEN_ACL_UNSAFE, mode);}
serializeNodeData
public void zookeeper_f5053_0(OutputArchive oa, String path, DataNode node) throws IOException
{    super.serializeNodeData(oa, path, node);    NodeSerializeListener listener = listeners.get(path);    if (listener != null) {        listener.nodeSerialized(path);    }}
addListener
public void zookeeper_f5054_0(String path, NodeSerializeListener listener)
{    listeners.put(path, listener);}
createNode
public void zookeeper_f5055_0(final String path, byte[] data, List<ACL> acl, long ephemeralOwner, int parentCVersion, long zxid, long time, Stat outputStat) throws NoNodeException, NodeExistsException
{    NodeCreateListener listener = nodeCreateListeners.get(path);    if (listener != null) {        listener.process(path);    }    super.createNode(path, data, acl, ephemeralOwner, parentCVersion, zxid, time, outputStat);}
addNodeCreateListener
public void zookeeper_f5056_0(String path, NodeCreateListener listener)
{    nodeCreateListeners.put(path, listener);}
setCommitSessionListener
public void zookeeper_f5057_0(CommitSessionListener listener)
{    this.commitSessionListener = listener;}
getQuorumPeer
protected QuorumPeer zookeeper_f5058_0() throws SaslException
{    return new QuorumPeer() {        @Override        public void setZKDatabase(ZKDatabase database) {            super.setZKDatabase(new ZKDatabase(this.getTxnFactory()) {                @Override                public DataTree createDataTree() {                    return new CustomDataTree();                }            });        }        @Override        protected Follower makeFollower(FileTxnSnapLog logFactory) throws IOException {            return new Follower(this, new FollowerZooKeeperServer(logFactory, this, this.getZkDb()) {                @Override                public void createSessionTracker() {                    sessionTracker = new LearnerSessionTracker(this, getZKDatabase().getSessionWithTimeOuts(), this.tickTime, self.getId(), self.areLocalSessionsEnabled(), getZooKeeperServerListener()) {                        public synchronized boolean commitSession(long sessionId, int sessionTimeout) {                            if (commitSessionListener != null) {                                commitSessionListener.process(sessionId);                            }                            return super.commitSession(sessionId, sessionTimeout);                        }                    };                }            });        }    };}
setZKDatabase
public void zookeeper_f5059_0(ZKDatabase database)
{    super.setZKDatabase(new ZKDatabase(this.getTxnFactory()) {        @Override        public DataTree createDataTree() {            return new CustomDataTree();        }    });}
createDataTree
public DataTree zookeeper_f5060_0()
{    return new CustomDataTree();}
makeFollower
protected Follower zookeeper_f5061_0(FileTxnSnapLog logFactory) throws IOException
{    return new Follower(this, new FollowerZooKeeperServer(logFactory, this, this.getZkDb()) {        @Override        public void createSessionTracker() {            sessionTracker = new LearnerSessionTracker(this, getZKDatabase().getSessionWithTimeOuts(), this.tickTime, self.getId(), self.areLocalSessionsEnabled(), getZooKeeperServerListener()) {                public synchronized boolean commitSession(long sessionId, int sessionTimeout) {                    if (commitSessionListener != null) {                        commitSessionListener.process(sessionId);                    }                    return super.commitSession(sessionId, sessionTimeout);                }            };        }    });}
createSessionTracker
public void zookeeper_f5062_0()
{    sessionTracker = new LearnerSessionTracker(this, getZKDatabase().getSessionWithTimeOuts(), this.tickTime, self.getId(), self.areLocalSessionsEnabled(), getZooKeeperServerListener()) {        public synchronized boolean commitSession(long sessionId, int sessionTimeout) {            if (commitSessionListener != null) {                commitSessionListener.process(sessionId);            }            return super.commitSession(sessionId, sessionTimeout);        }    };}
commitSession
public synchronized boolean zookeeper_f5063_0(long sessionId, int sessionTimeout)
{    if (commitSessionListener != null) {        commitSessionListener.process(sessionId);    }    return super.commitSession(sessionId, sessionTimeout);}
setUp
public void zookeeper_f5064_0() throws IOException, X509Exception
{    qp = new QuorumPeer();    long myId = qp.getId();    int clientPort = PortAssignment.unique();    Map<Long, QuorumServer> peersView = new HashMap<Long, QuorumServer>();    InetAddress clientIP = InetAddress.getLoopbackAddress();    peersView.put(Long.valueOf(myId), new QuorumServer(myId, new InetSocketAddress(clientIP, PortAssignment.unique()), new InetSocketAddress(clientIP, PortAssignment.unique()), new InetSocketAddress(clientIP, clientPort), LearnerType.PARTICIPANT));    quorumVerifierMock = mock(QuorumVerifier.class);    when(quorumVerifierMock.getAllMembers()).thenReturn(peersView);    qp.setQuorumVerifier(quorumVerifierMock, false);    File tmpDir = ClientBase.createEmptyTestDir();    fileTxnSnapLog = new FileTxnSnapLog(new File(tmpDir, "data"), new File(tmpDir, "data_txnlog"));    ZKDatabase zkDb = new ZKDatabase(fileTxnSnapLog);    zks = new LeaderZooKeeperServer(fileTxnSnapLog, qp, zkDb);    leader = new Leader(qp, zks);    leaderBean = new LeaderBean(leader, zks);}
tearDown
public void zookeeper_f5065_0() throws IOException
{    fileTxnSnapLog.close();}
testGetName
public void zookeeper_f5066_0()
{    assertEquals("Leader", leaderBean.getName());}
testGetCurrentZxid
public void zookeeper_f5067_0()
{        zks.setZxid(1);        assertEquals("0x1", leaderBean.getCurrentZxid());}
testGetElectionTimeTaken
public void zookeeper_f5068_0()
{        qp.setElectionTimeTaken(1);        assertEquals(1, leaderBean.getElectionTimeTaken());}
testGetProposalSize
public void zookeeper_f5069_0() throws IOException, Leader.XidRolloverException
{        Request req = createMockRequest();        leader.propose(req);        byte[] data = SerializeUtils.serializeRequest(req);    assertEquals(data.length, leaderBean.getLastProposalSize());    assertEquals(data.length, leaderBean.getMinProposalSize());    assertEquals(data.length, leaderBean.getMaxProposalSize());}
testResetProposalStats
public void zookeeper_f5070_0() throws IOException, Leader.XidRolloverException
{        int initialProposalSize = leaderBean.getLastProposalSize();    Request req = createMockRequest();        leader.propose(req);        assertNotEquals(initialProposalSize, leaderBean.getLastProposalSize());    leaderBean.resetProposalStatistics();    assertEquals(initialProposalSize, leaderBean.getLastProposalSize());    assertEquals(initialProposalSize, leaderBean.getMinProposalSize());    assertEquals(initialProposalSize, leaderBean.getMaxProposalSize());}
createMockRequest
private Request zookeeper_f5071_0() throws IOException
{    TxnHeader header = mock(TxnHeader.class);    doAnswer(new Answer() {        @Override        public Object answer(InvocationOnMock invocation) throws Throwable {            Object[] args = invocation.getArguments();            OutputArchive oa = (OutputArchive) args[0];            oa.writeString("header", "test");            return null;        }    }).when(header).serialize(any(OutputArchive.class), anyString());    Record txn = mock(Record.class);    doAnswer(new Answer() {        @Override        public Object answer(InvocationOnMock invocation) throws Throwable {            Object[] args = invocation.getArguments();            OutputArchive oa = (OutputArchive) args[0];            oa.writeString("record", "test");            return null;        }    }).when(txn).serialize(any(OutputArchive.class), anyString());    return new Request(1, 2, 3, header, txn, 4);}
answer
public Object zookeeper_f5072_0(InvocationOnMock invocation) throws Throwable
{    Object[] args = invocation.getArguments();    OutputArchive oa = (OutputArchive) args[0];    oa.writeString("header", "test");    return null;}
answer
public Object zookeeper_f5073_0(InvocationOnMock invocation) throws Throwable
{    Object[] args = invocation.getArguments();    OutputArchive oa = (OutputArchive) args[0];    oa.writeString("record", "test");    return null;}
testFollowerInfo
public void zookeeper_f5074_0() throws IOException
{    Map<Long, QuorumServer> votingMembers = new HashMap<Long, QuorumServer>();    votingMembers.put(1L, null);    votingMembers.put(2L, null);    votingMembers.put(3L, null);    when(quorumVerifierMock.getVotingMembers()).thenReturn(votingMembers);    LearnerHandler follower = mock(LearnerHandler.class);    when(follower.getLearnerType()).thenReturn(LearnerType.PARTICIPANT);    when(follower.toString()).thenReturn("1");    when(follower.getSid()).thenReturn(1L);    leader.addLearnerHandler(follower);    leader.addForwardingFollower(follower);    assertEquals("1\n", leaderBean.followerInfo());    assertEquals("", leaderBean.nonVotingFollowerInfo());    LearnerHandler observer = mock(LearnerHandler.class);    when(observer.getLearnerType()).thenReturn(LearnerType.OBSERVER);    when(observer.toString()).thenReturn("2");    leader.addLearnerHandler(observer);    assertEquals("1\n", leaderBean.followerInfo());    assertEquals("", leaderBean.nonVotingFollowerInfo());    LearnerHandler nonVotingFollower = mock(LearnerHandler.class);    when(nonVotingFollower.getLearnerType()).thenReturn(LearnerType.PARTICIPANT);    when(nonVotingFollower.toString()).thenReturn("5");    when(nonVotingFollower.getSid()).thenReturn(5L);    leader.addLearnerHandler(nonVotingFollower);    leader.addForwardingFollower(nonVotingFollower);    String followerInfo = leaderBean.followerInfo();    assertTrue(followerInfo.contains("1"));    assertTrue(followerInfo.contains("5"));    assertEquals("5\n", leaderBean.nonVotingFollowerInfo());}
process
public void zookeeper_f5075_0(WatchedEvent e)
{    createdLatch.countDown();}
setup
public void zookeeper_f5076_0()
{    oldLoggingFeq = Leader.getAckLoggingFrequency();}
teardown
public void zookeeper_f5077_0()
{    Leader.setAckLoggingFrequency(oldLoggingFeq);}
testLeaderMetrics
public void zookeeper_f5078_0() throws Exception
{        Leader.setAckLoggingFrequency(1);    ServerMetrics.getMetrics().resetAll();        QuorumUtil util = new QuorumUtil(1);    util.startAll();    ZooKeeper zk = ClientBase.createZKClient(util.getConnString());    createdLatch = new CountDownLatch(1);    zk.exists("/test", new MyWatcher());    zk.create("/test", new byte[2], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    createdLatch.await();    Map<String, Object> values = MetricsUtils.currentServerMetrics();    assertEquals(2L, values.get("proposal_count"));        assertEquals(2L, values.get("cnt_quorum_ack_latency"));    assertThat((long) values.get("min_quorum_ack_latency"), greaterThan(0L));    int numberOfAckServers = 0;        for (int sid = 1; sid <= 3; sid++) {        String metricName = "min_" + sid + "_ack_latency";        if (values.get(metricName) != null) {            numberOfAckServers++;            assertThat((long) values.get("min_" + sid + "_ack_latency"), greaterThanOrEqualTo(0L));        }    }        assertThat(numberOfAckServers, greaterThanOrEqualTo(2));    zk.close();    util.shutdownAll();}
setUp
public void zookeeper_f5079_0() throws Exception
{    tmpDir = ClientBase.createTmpDir();    peer = createQuorumPeer(tmpDir);    participantId = 1;    Map<Long, QuorumPeer.QuorumServer> peers = peer.getQuorumVerifier().getAllMembers();    observerId = peers.size();    leader = createLeader(tmpDir, peer);    peer.leader = leader;    peers.put(observerId, new QuorumPeer.QuorumServer(observerId, new InetSocketAddress("127.0.0.1", PortAssignment.unique()), new InetSocketAddress("127.0.0.1", PortAssignment.unique()), new InetSocketAddress("127.0.0.1", PortAssignment.unique()), QuorumPeer.LearnerType.OBSERVER));        peer.tickTime = 1;}
tearDown
public void zookeeper_f5080_0()
{    leader.shutdown("end of test");    tmpDir.delete();}
testGetEpochToPropose
public void zookeeper_f5081_0() throws Exception
{    long lastAcceptedEpoch = 5;    peer.setAcceptedEpoch(5);    assertEquals("Unexpected vote in connectingFollowers", 0, leader.connectingFollowers.size());    assertTrue(leader.waitingForNewEpoch);    try {                        leader.getEpochToPropose(peer.getId(), lastAcceptedEpoch);    } catch (InterruptedException e) {        }    assertEquals("Unexpected vote in connectingFollowers", 1, leader.connectingFollowers.size());    assertEquals("Leader shouldn't set new epoch until quorum of participants is in connectingFollowers", lastAcceptedEpoch, peer.getAcceptedEpoch());    assertTrue(leader.waitingForNewEpoch);    try {                leader.getEpochToPropose(observerId, lastAcceptedEpoch);    } catch (InterruptedException e) {        }    assertEquals("Unexpected vote in connectingFollowers", 1, leader.connectingFollowers.size());    assertEquals("Leader shouldn't set new epoch after observer asks for epoch", lastAcceptedEpoch, peer.getAcceptedEpoch());    assertTrue(leader.waitingForNewEpoch);    try {                        leader.getEpochToPropose(participantId, lastAcceptedEpoch);    } catch (Exception e) {        fail("Timed out in getEpochToPropose");    }    assertEquals("Unexpected vote in connectingFollowers", 2, leader.connectingFollowers.size());    assertEquals("Leader should record next epoch", lastAcceptedEpoch + 1, peer.getAcceptedEpoch());    assertFalse(leader.waitingForNewEpoch);}
testWaitForEpochAck
public void zookeeper_f5082_0() throws Exception
{        leader.leaderStateSummary = new StateSummary(leader.self.getCurrentEpoch(), leader.zk.getLastProcessedZxid());    assertEquals("Unexpected vote in electingFollowers", 0, leader.electingFollowers.size());    assertFalse(leader.electionFinished);    try {                leader.waitForEpochAck(peer.getId(), new StateSummary(0, 0));    } catch (InterruptedException e) {        }    assertEquals("Unexpected vote in electingFollowers", 1, leader.electingFollowers.size());    assertFalse(leader.electionFinished);    try {                leader.waitForEpochAck(observerId, new StateSummary(0, 0));    } catch (InterruptedException e) {        }    assertEquals("Unexpected vote in electingFollowers", 1, leader.electingFollowers.size());    assertFalse(leader.electionFinished);    try {                leader.waitForEpochAck(participantId, new StateSummary(0, 0));        assertEquals("Unexpected vote in electingFollowers", 2, leader.electingFollowers.size());        assertTrue(leader.electionFinished);    } catch (Exception e) {        fail("Timed out in waitForEpochAck");    }}
testWaitForNewLeaderAck
public void zookeeper_f5083_0() throws Exception
{    long zxid = leader.zk.getZxid();        leader.newLeaderProposal.packet = new QuorumPacket(0, zxid, null, null);    leader.newLeaderProposal.addQuorumVerifier(peer.getQuorumVerifier());    Set<Long> ackSet = leader.newLeaderProposal.qvAcksetPairs.get(0).getAckset();    assertEquals("Unexpected vote in ackSet", 0, ackSet.size());    assertFalse(leader.quorumFormed);    try {                leader.waitForNewLeaderAck(peer.getId(), zxid);    } catch (InterruptedException e) {        }    assertEquals("Unexpected vote in ackSet", 1, ackSet.size());    assertFalse(leader.quorumFormed);    try {                leader.waitForNewLeaderAck(observerId, zxid);    } catch (InterruptedException e) {        }    assertEquals("Unexpected vote in ackSet", 1, ackSet.size());    assertFalse(leader.quorumFormed);    try {                leader.waitForNewLeaderAck(participantId, zxid);        assertEquals("Unexpected vote in ackSet", 2, ackSet.size());        assertTrue(leader.quorumFormed);    } catch (Exception e) {        fail("Timed out in waitForEpochAck");    }}
setup
public void zookeeper_f5084_0() throws IOException
{    Leader leader = mock(Leader.class);    when(leader.getQuorumAuthServer()).thenReturn(null);    Socket socket = mock(Socket.class);    when(socket.getRemoteSocketAddress()).thenReturn(new InetSocketAddress(32));        BinaryOutputArchive oa = mock(BinaryOutputArchive.class);    doAnswer(invocationOnMock -> {        Thread.sleep(5);        return null;    }).when(oa).writeRecord(any(QuorumPacket.class), anyString());    BufferedOutputStream bos = mock(BufferedOutputStream.class);        doAnswer(invocationOnMock -> {        if (allSentLatch != null) {            allSentLatch.countDown();        }        return null;    }).when(bos).flush();    learnerHandler = new MockLearnerHandler(socket, leader);    learnerHandler.setOutputArchive(oa);    learnerHandler.setBufferedOutput(bos);    learnerHandler.sid = sid;}
testMetrics
public void zookeeper_f5085_0() throws InterruptedException
{    ServerMetrics.getMetrics().resetAll();        for (int i = 0; i < 1001; i++) {        learnerHandler.queuePacket(new QuorumPacket());    }    allSentLatch = new CountDownLatch(1);    learnerHandler.startSendingPackets();    allSentLatch.await(8, TimeUnit.SECONDS);    Map<String, Object> values = MetricsUtils.currentServerMetrics();    String sidStr = Long.toString(sid);        assertEquals(2L, values.get("cnt_" + sidStr + "_learner_handler_qp_time_ms"));            assertThat((long) values.get("max_" + sidStr + "_learner_handler_qp_time_ms"), greaterThan(5000L));        assertEquals(1003L, values.get("cnt_" + sidStr + "_learner_handler_qp_size"));        assertEquals(1002L, values.get("max_" + sidStr + "_learner_handler_qp_size"));        assertEquals(0L, values.get("min_" + sidStr + "_learner_handler_qp_size"));}
startSendingPackets
protected void zookeeper_f5086_0()
{    threadStarted = true;}
shouldSendMarkerPacketForLogging
protected boolean zookeeper_f5087_0()
{    return false;}
getDataTreeLastProcessedZxid
public long zookeeper_f5088_0()
{    return lastProcessedZxid;}
getmaxCommittedLog
public long zookeeper_f5089_0()
{    if (!committedLog.isEmpty()) {        return committedLog.getLast().packet.getZxid();    }    return 0;}
getminCommittedLog
public long zookeeper_f5090_0()
{    if (!committedLog.isEmpty()) {        return committedLog.getFirst().packet.getZxid();    }    return 0;}
getCommittedLog
public List<Proposal> zookeeper_f5091_0()
{    return committedLog;}
getLogLock
public ReentrantReadWriteLock zookeeper_f5092_0()
{    return lock;}
getProposalsFromTxnLog
public Iterator<Proposal> zookeeper_f5093_0(long peerZxid, long limit)
{    if (peerZxid >= txnLog.peekFirst().packet.getZxid()) {        return txnLog.iterator();    } else {        return Collections.emptyIterator();    }}
calculateTxnLogSizeLimit
public long zookeeper_f5094_0()
{    return 1;}
setUp
public void zookeeper_f5095_0() throws Exception
{    db = new MockZKDatabase(null);    sock = mock(Socket.class);        leader = mock(Leader.class);    when(leader.startForwarding(ArgumentMatchers.any(LearnerHandler.class), ArgumentMatchers.anyLong())).thenAnswer(new Answer<Long>() {        public Long answer(InvocationOnMock invocation) {            currentZxid = invocation.getArgument(1);            return 0L;        }    });    when(leader.getZKDatabase()).thenReturn(db);    learnerHandler = new MockLearnerHandler(sock, leader);}
answer
public Long zookeeper_f5096_0(InvocationOnMock invocation)
{    currentZxid = invocation.getArgument(1);    return 0L;}
createProposal
 Proposal zookeeper_f5097_0(long zxid)
{    Proposal p = new Proposal();    p.packet = new QuorumPacket();    p.packet.setZxid(zxid);    p.packet.setType(Leader.PROPOSAL);    return p;}
queuedPacketMatches
public void zookeeper_f5098_0(long[] zxids)
{    int index = 0;    for (QuorumPacket qp : learnerHandler.getQueuedPackets()) {        if (qp.getType() == Leader.PROPOSAL) {            assertZxidEquals(zxids[index++], qp.getZxid());        }    }}
reset
 void zookeeper_f5099_0()
{    learnerHandler.getQueuedPackets().clear();    learnerHandler.threadStarted = false;    learnerHandler.setFirstPacket(true);}
assertOpType
public void zookeeper_f5100_0(int type, long zxid, long currentZxid)
{    Queue<QuorumPacket> packets = learnerHandler.getQueuedPackets();    assertTrue(packets.size() > 0);    assertEquals(type, packets.peek().getType());    assertZxidEquals(zxid, packets.peek().getZxid());    assertZxidEquals(currentZxid, this.currentZxid);}
assertZxidEquals
 void zookeeper_f5101_0(long expected, long value)
{    assertEquals("Expected 0x" + Long.toHexString(expected) + " but was 0x" + Long.toHexString(value), expected, value);}
testEmptyCommittedLog
public void zookeeper_f5102_0() throws Exception
{    long peerZxid;        peerZxid = 3;    db.lastProcessedZxid = 1;    db.committedLog.clear();    assertFalse(learnerHandler.syncFollower(peerZxid, leader));        assertOpType(Leader.TRUNC, db.lastProcessedZxid, db.lastProcessedZxid);    reset();        peerZxid = 1;    db.lastProcessedZxid = 1;    db.committedLog.clear();    assertFalse(learnerHandler.syncFollower(peerZxid, leader));        assertOpType(Leader.DIFF, db.lastProcessedZxid, db.lastProcessedZxid);    assertEquals(1, learnerHandler.getQueuedPackets().size());    reset();            peerZxid = 0;    db.setSnapshotSizeFactor(-1);    db.lastProcessedZxid = 1;    db.committedLog.clear();        assertTrue(learnerHandler.syncFollower(peerZxid, leader));    assertEquals(0, learnerHandler.getQueuedPackets().size());    reset();}
testCommittedLog
public void zookeeper_f5103_0() throws Exception
{    long peerZxid;            db.lastProcessedZxid = 6;    db.committedLog.add(createProposal(2));    db.committedLog.add(createProposal(3));    db.committedLog.add(createProposal(5));        peerZxid = 4;    assertFalse(learnerHandler.syncFollower(peerZxid, leader));        assertOpType(Leader.TRUNC, 3, 5);        assertEquals(3, learnerHandler.getQueuedPackets().size());    queuedPacketMatches(new long[] { 5 });    reset();        peerZxid = 2;    assertFalse(learnerHandler.syncFollower(peerZxid, leader));        assertOpType(Leader.DIFF, db.getmaxCommittedLog(), db.getmaxCommittedLog());        assertEquals(5, learnerHandler.getQueuedPackets().size());    queuedPacketMatches(new long[] { 3, 5 });    reset();        peerZxid = 1;    db.setSnapshotSizeFactor(-1);        assertTrue(learnerHandler.syncFollower(peerZxid, leader));    assertEquals(0, learnerHandler.getQueuedPackets().size());    reset();}
testTxnLog
public void zookeeper_f5104_0() throws Exception
{    long peerZxid;    db.txnLog.add(createProposal(2));    db.txnLog.add(createProposal(3));    db.txnLog.add(createProposal(5));    db.txnLog.add(createProposal(6));    db.txnLog.add(createProposal(7));    db.txnLog.add(createProposal(8));    db.txnLog.add(createProposal(9));    db.lastProcessedZxid = 9;    db.committedLog.add(createProposal(6));    db.committedLog.add(createProposal(7));    db.committedLog.add(createProposal(8));        peerZxid = 4;    assertFalse(learnerHandler.syncFollower(peerZxid, leader));        assertOpType(Leader.TRUNC, 3, db.getmaxCommittedLog());        assertEquals(9, learnerHandler.getQueuedPackets().size());    queuedPacketMatches(new long[] { 5, 6, 7, 8 });    reset();        peerZxid = 3;    assertFalse(learnerHandler.syncFollower(peerZxid, leader));        assertOpType(Leader.DIFF, db.getmaxCommittedLog(), db.getmaxCommittedLog());        assertEquals(9, learnerHandler.getQueuedPackets().size());    queuedPacketMatches(new long[] { 5, 6, 7, 8 });    reset();}
testTxnLogProposalIteratorClosure
public void zookeeper_f5105_0() throws Exception
{    long peerZxid;        db = new MockZKDatabase(null) {        @Override        public Iterator<Proposal> getProposalsFromTxnLog(long peerZxid, long limit) {            return TxnLogProposalIterator.EMPTY_ITERATOR;        }    };    db.lastProcessedZxid = 7;    db.txnLog.add(createProposal(2));    db.txnLog.add(createProposal(3));    when(leader.getZKDatabase()).thenReturn(db);        peerZxid = 4;    assertTrue("Couldn't identify snapshot transfer!", learnerHandler.syncFollower(peerZxid, leader));    reset();}
getProposalsFromTxnLog
public Iterator<Proposal> zookeeper_f5106_0(long peerZxid, long limit)
{    return TxnLogProposalIterator.EMPTY_ITERATOR;}
testTxnLogOnly
public void zookeeper_f5107_0() throws Exception
{    long peerZxid;        db.lastProcessedZxid = 7;    db.txnLog.add(createProposal(2));    db.txnLog.add(createProposal(3));    db.txnLog.add(createProposal(5));    db.txnLog.add(createProposal(6));    db.txnLog.add(createProposal(7));    db.txnLog.add(createProposal(8));        peerZxid = 4;    assertFalse(learnerHandler.syncFollower(peerZxid, leader));            assertOpType(Leader.TRUNC, 3, db.lastProcessedZxid);        assertEquals(7, learnerHandler.getQueuedPackets().size());    queuedPacketMatches(new long[] { 5, 6, 7 });    reset();        peerZxid = 2;    assertFalse(learnerHandler.syncFollower(peerZxid, leader));        assertOpType(Leader.DIFF, db.lastProcessedZxid, db.lastProcessedZxid);        assertEquals(9, learnerHandler.getQueuedPackets().size());    queuedPacketMatches(new long[] { 3, 5, 6, 7 });    reset();        peerZxid = 1;    assertTrue(learnerHandler.syncFollower(peerZxid, leader));        assertEquals(0, learnerHandler.getQueuedPackets().size());    reset();}
getZxid
 long zookeeper_f5108_0(long epoch, long counter)
{    return ZxidUtils.makeZxid(epoch, counter);}
testTxnLogWithNegativeZxid
public void zookeeper_f5109_0() throws Exception
{    long peerZxid;    db.txnLog.add(createProposal(getZxid(0xf, 2)));    db.txnLog.add(createProposal(getZxid(0xf, 3)));    db.txnLog.add(createProposal(getZxid(0xf, 5)));    db.txnLog.add(createProposal(getZxid(0xf, 6)));    db.txnLog.add(createProposal(getZxid(0xf, 7)));    db.txnLog.add(createProposal(getZxid(0xf, 8)));    db.txnLog.add(createProposal(getZxid(0xf, 9)));    db.lastProcessedZxid = getZxid(0xf, 9);    db.committedLog.add(createProposal(getZxid(0xf, 6)));    db.committedLog.add(createProposal(getZxid(0xf, 7)));    db.committedLog.add(createProposal(getZxid(0xf, 8)));        peerZxid = getZxid(0xf, 4);    assertFalse(learnerHandler.syncFollower(peerZxid, leader));        assertOpType(Leader.TRUNC, getZxid(0xf, 3), db.getmaxCommittedLog());        assertEquals(9, learnerHandler.getQueuedPackets().size());    queuedPacketMatches(new long[] { getZxid(0xf, 5), getZxid(0xf, 6), getZxid(0xf, 7), getZxid(0xf, 8) });    reset();        peerZxid = getZxid(0xf, 3);    assertFalse(learnerHandler.syncFollower(peerZxid, leader));        assertOpType(Leader.DIFF, db.getmaxCommittedLog(), db.getmaxCommittedLog());        assertEquals(9, learnerHandler.getQueuedPackets().size());    queuedPacketMatches(new long[] { getZxid(0xf, 5), getZxid(0xf, 6), getZxid(0xf, 7), getZxid(0xf, 8) });    reset();}
testNewEpochZxid
public void zookeeper_f5110_0() throws Exception
{    long peerZxid;    db.txnLog.add(createProposal(getZxid(0, 1)));    db.txnLog.add(createProposal(getZxid(1, 1)));    db.txnLog.add(createProposal(getZxid(1, 2)));        db.lastProcessedZxid = getZxid(2, 0);    db.committedLog.add(createProposal(getZxid(1, 1)));    db.committedLog.add(createProposal(getZxid(1, 2)));        peerZxid = getZxid(0, 0);                assertTrue(learnerHandler.syncFollower(peerZxid, leader));    assertEquals(0, learnerHandler.getQueuedPackets().size());    reset();        peerZxid = getZxid(1, 0);    assertFalse(learnerHandler.syncFollower(peerZxid, leader));        assertOpType(Leader.DIFF, getZxid(1, 2), getZxid(1, 2));        assertEquals(5, learnerHandler.getQueuedPackets().size());    queuedPacketMatches(new long[] { getZxid(1, 1), getZxid(1, 2) });    reset();        peerZxid = getZxid(2, 0);    assertFalse(learnerHandler.syncFollower(peerZxid, leader));        assertOpType(Leader.DIFF, getZxid(2, 0), getZxid(2, 0));        assertEquals(1, learnerHandler.getQueuedPackets().size());    reset();}
testDuplicatedTxn
public void zookeeper_f5111_0() throws Exception
{    long peerZxid;    db.txnLog.add(createProposal(getZxid(0, 1)));    db.txnLog.add(createProposal(getZxid(1, 1)));    db.txnLog.add(createProposal(getZxid(1, 2)));    db.txnLog.add(createProposal(getZxid(1, 1)));    db.txnLog.add(createProposal(getZxid(1, 2)));        db.lastProcessedZxid = getZxid(2, 0);    db.committedLog.add(createProposal(getZxid(1, 1)));    db.committedLog.add(createProposal(getZxid(1, 2)));    db.committedLog.add(createProposal(getZxid(1, 1)));    db.committedLog.add(createProposal(getZxid(1, 2)));        peerZxid = getZxid(1, 0);    assertFalse(learnerHandler.syncFollower(peerZxid, leader));        assertOpType(Leader.DIFF, getZxid(1, 2), getZxid(1, 2));        assertEquals(5, learnerHandler.getQueuedPackets().size());    queuedPacketMatches(new long[] { getZxid(1, 1), getZxid(1, 2) });    reset();}
testCrossEpochTrunc
public void zookeeper_f5112_0() throws Exception
{    long peerZxid;    db.txnLog.add(createProposal(getZxid(1, 1)));    db.txnLog.add(createProposal(getZxid(2, 1)));    db.txnLog.add(createProposal(getZxid(2, 2)));    db.txnLog.add(createProposal(getZxid(4, 1)));        db.lastProcessedZxid = getZxid(6, 0);        peerZxid = getZxid(3, 1);    assertTrue(learnerHandler.syncFollower(peerZxid, leader));    assertEquals(0, learnerHandler.getQueuedPackets().size());    reset();}
testTxnLogGap
public void zookeeper_f5113_0() throws Exception
{    long peerZxid;    db.txnLog.add(createProposal(2));    db.txnLog.add(createProposal(3));    db.txnLog.add(createProposal(4));    db.lastProcessedZxid = 8;    db.committedLog.add(createProposal(7));    db.committedLog.add(createProposal(8));        peerZxid = 3;    assertTrue(learnerHandler.syncFollower(peerZxid, leader));    reset();}
testLearnerMetricsTest
public void zookeeper_f5114_0() throws Exception
{    ServerMetrics.getMetrics().resetAll();    ClientBase.setupTestEnv();    final String path = "/zk-testLeanerMetrics";    final byte[] data = new byte[512];    final int[] clientPorts = new int[SERVER_COUNT];    StringBuilder sb = new StringBuilder();    int observer = 0;    clientPorts[observer] = PortAssignment.unique();    sb.append("server." + observer + "=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ":observer\n");    for (int i = 1; i < SERVER_COUNT; i++) {        clientPorts[i] = PortAssignment.unique();        sb.append("server." + i + "=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + "\n");    }        String quorumCfgSection = sb.toString();    for (int i = 1; i < SERVER_COUNT; i++) {        mt[i] = new QuorumPeerTestBase.MainThread(i, clientPorts[i], quorumCfgSection);        mt[i].start();    }        Map<String, String> observerConfig = new HashMap<>();    observerConfig.put("peerType", "observer");    mt[observer] = new QuorumPeerTestBase.MainThread(observer, clientPorts[observer], quorumCfgSection, observerConfig);    mt[observer].start();            zk_client = new ZooKeeper("127.0.0.1:" + clientPorts[observer], ClientBase.CONNECTION_TIMEOUT, this);    waitForOne(zk_client, ZooKeeper.States.CONNECTED);        zk_client.create(path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);            waitForMetric("learner_proposal_received_count", is(4L));    waitForMetric("cnt_proposal_latency", is(4L));    waitForMetric("min_proposal_latency", greaterThanOrEqualTo(0L));        waitForMetric("cnt_proposal_ack_creation_latency", is(6L));    waitForMetric("min_proposal_ack_creation_latency", greaterThanOrEqualTo(0L));            waitForMetric("learner_commit_received_count", is(6L));    waitForMetric("cnt_commit_propagation_latency", is(6L));    waitForMetric("min_commit_propagation_latency", greaterThanOrEqualTo(0L));}
waitForMetric
private voidf5115_1final String metricKey, final Matcher<Long> matcher) throws InterruptedException
{    final String errorMessage = String.format("unable to match on metric: %s", metricKey);    waitFor(errorMessage, () -> {        long actual = (long) MetricsUtils.currentServerMetrics().get(metricKey);        if (!matcher.matches(actual)) {                        return false;        }        return true;    }, TIMEOUT_SECONDS);}
tearDown
public void zookeeper_f5116_0() throws Exception
{    zk_client.close();    for (int i = 0; i < SERVER_COUNT; i++) {        mt[i].shutdown();    }}
syncTypes
public static Collection zookeeper_f5117_0()
{    return Arrays.asList(new Object[][] { { LearnerSyncThrottler.SyncType.DIFF }, { LearnerSyncThrottler.SyncType.SNAP } });}
testTooManySyncsNonessential
public void zookeeper_f5118_0() throws Exception
{    LearnerSyncThrottler throttler = new LearnerSyncThrottler(5, syncType);    for (int i = 0; i < 6; i++) {        throttler.beginSync(false);    }}
testTooManySyncsEssential
public void zookeeper_f5119_0() throws Exception
{    LearnerSyncThrottler throttler = new LearnerSyncThrottler(5, syncType);    try {        for (int i = 0; i < 6; i++) {            throttler.beginSync(true);        }    } catch (SyncThrottleException ex) {        fail("essential syncs should not be throttled");    }    throttler.endSync();    throttler.beginSync(false);}
testNoThrottle
public void zookeeper_f5120_0() throws Exception
{    LearnerSyncThrottler throttler = new LearnerSyncThrottler(5, syncType);    try {        for (int i = 0; i < 6; i++) {            throttler.beginSync(true);        }    } catch (SyncThrottleException ex) {        fail("essential syncs should not be throttled");    }    throttler.endSync();    for (int i = 0; i < 5; i++) {        throttler.endSync();        throttler.beginSync(false);    }    assertTrue("should get here without exception", true);}
testTryWithResourceNoThrottle
public void zookeeper_f5121_0() throws Exception
{    LearnerSyncThrottler throttler = new LearnerSyncThrottler(1, syncType);    for (int i = 0; i < 3; i++) {        throttler.beginSync(false);        try {            assertEquals(1, throttler.getSyncInProgress());        } finally {            throttler.endSync();        }    }}
testTryWithResourceThrottle
public void zookeeper_f5122_0() throws Exception
{    LearnerSyncThrottler throttler = new LearnerSyncThrottler(1, syncType);    try {        throttler.beginSync(true);        try {            throttler.beginSync(false);            fail("shouldn't be able to have both syncs open");        } catch (SyncThrottleException e) {        }        throttler.endSync();    } catch (SyncThrottleException e) {        fail("First sync shouldn't be throttled");    }}
testParallelNoThrottle
public void zookeeper_f5123_0()
{    final int numThreads = 50;    final LearnerSyncThrottler throttler = new LearnerSyncThrottler(numThreads, syncType);    ExecutorService threadPool = Executors.newFixedThreadPool(numThreads);    final CountDownLatch threadStartLatch = new CountDownLatch(numThreads);    final CountDownLatch syncProgressLatch = new CountDownLatch(numThreads);    List<Future<Boolean>> results = new ArrayList<Future<Boolean>>(numThreads);    for (int i = 0; i < numThreads; i++) {        results.add(threadPool.submit(new Callable<Boolean>() {            @Override            public Boolean call() {                threadStartLatch.countDown();                try {                    threadStartLatch.await();                    throttler.beginSync(false);                    syncProgressLatch.countDown();                    syncProgressLatch.await();                    throttler.endSync();                } catch (Exception e) {                    return false;                }                return true;            }        }));    }    try {        for (Future<Boolean> result : results) {            assertTrue(result.get());        }    } catch (Exception e) {    } finally {        threadPool.shutdown();    }}
call
public Boolean zookeeper_f5124_0()
{    threadStartLatch.countDown();    try {        threadStartLatch.await();        throttler.beginSync(false);        syncProgressLatch.countDown();        syncProgressLatch.await();        throttler.endSync();    } catch (Exception e) {        return false;    }    return true;}
getLearner
public Learner zookeeper_f5125_0()
{    return learner;}
setTimeMultiplier
public void zookeeper_f5126_0(long multiplier)
{    timeMultiplier = multiplier;}
setPassConnectAttempt
public void zookeeper_f5127_0(int num)
{    passSocketConnectOnAttempt = num;}
nanoTime
protected long zookeeper_f5128_0()
{    return socketConnectAttempt * timeMultiplier;}
getSockConnectAttempt
protected int zookeeper_f5129_0()
{    return socketConnectAttempt;}
sockConnect
protected void zookeeper_f5130_0(Socket sock, InetSocketAddress addr, int timeout) throws IOException
{    if (++socketConnectAttempt < passSocketConnectOnAttempt) {        throw new IOException("Test injected Socket.connect() error.");    }}
connectionRetryTimeoutTest
public void zookeeper_f5131_0() throws Exception
{    Learner learner = new TimeoutLearner();    learner.self = new QuorumPeer();    learner.self.setTickTime(2000);    learner.self.setInitLimit(5);    learner.self.setSyncLimit(2);        InetSocketAddress addr = new InetSocketAddress(1111);        learner.connectToLeader(addr, "");}
connectionInitLimitTimeoutTest
public void zookeeper_f5132_0() throws Exception
{    TimeoutLearner learner = new TimeoutLearner();    learner.self = new QuorumPeer();    learner.self.setTickTime(2000);    learner.self.setInitLimit(5);    learner.self.setSyncLimit(2);        InetSocketAddress addr = new InetSocketAddress(1111);        learner.setTimeMultiplier((long) 4000 * 1000000);    learner.setPassConnectAttempt(5);        try {        learner.connectToLeader(addr, "");        fail("should have thrown IOException!");    } catch (IOException e) {                assertTrue(learner.nanoTime() > 2000 * 5 * 1000000);        assertEquals(3, learner.getSockConnectAttempt());    }}
connectToLearnerMasterLimitTest
public void zookeeper_f5133_0() throws Exception
{    TimeoutLearner learner = new TimeoutLearner();    learner.self = new QuorumPeer();    learner.self.setTickTime(2000);    learner.self.setInitLimit(2);    learner.self.setSyncLimit(2);    learner.self.setConnectToLearnerMasterLimit(5);    InetSocketAddress addr = new InetSocketAddress(1111);    learner.setTimeMultiplier((long) 4000 * 1000000);    learner.setPassConnectAttempt(5);    try {        learner.connectToLeader(addr, "");        fail("should have thrown IOException!");    } catch (IOException e) {        assertTrue(learner.nanoTime() > 2000 * 5 * 1000000);        assertEquals(3, learner.getSockConnectAttempt());    }}
syncTest
public void zookeeper_f5134_0() throws Exception
{    File tmpFile = File.createTempFile("test", ".dir", testData);    tmpFile.delete();    try {        FileTxnSnapLog ftsl = new FileTxnSnapLog(tmpFile, tmpFile);        SimpleLearner sl = new SimpleLearner(ftsl);        long startZxid = sl.zk.getLastProcessedZxid();                ByteArrayOutputStream baos = new ByteArrayOutputStream();        BinaryOutputArchive oa = BinaryOutputArchive.getArchive(baos);        sl.leaderOs = BinaryOutputArchive.getArchive(new ByteArrayOutputStream());                sl.bufferedOutput = new BufferedOutputStream(System.out);        sl.sock = new Socket();                QuorumPacket qp = new QuorumPacket(Leader.SNAP, 0, null, null);        oa.writeRecord(qp, null);        sl.zk.getZKDatabase().serializeSnapshot(oa);        oa.writeString("BenWasHere", "signature");        TxnHeader hdr = new TxnHeader(0, 0, 0, 0, ZooDefs.OpCode.create);        CreateTxn txn = new CreateTxn("/foo", new byte[0], new ArrayList<ACL>(), false, sl.zk.getZKDatabase().getNode("/").stat.getCversion());        ByteArrayOutputStream tbaos = new ByteArrayOutputStream();        BinaryOutputArchive boa = BinaryOutputArchive.getArchive(tbaos);        hdr.serialize(boa, "hdr");        txn.serialize(boa, "txn");        tbaos.close();        qp = new QuorumPacket(Leader.PROPOSAL, 1, tbaos.toByteArray(), null);        oa.writeRecord(qp, null);                sl.leaderIs = BinaryInputArchive.getArchive(new ByteArrayInputStream(baos.toByteArray()));        try {            sl.syncWithLeader(3);        } catch (EOFException e) {        }        sl.zk.shutdown();        sl = new SimpleLearner(ftsl);        assertEquals(startZxid, sl.zk.getLastProcessedZxid());    } finally {        TestUtils.deleteFileRecursively(tmpFile);    }}
testClientAddress
public void zookeeper_f5135_0() throws Exception
{    QuorumPeer quorumPeer = new QuorumPeer();    LocalPeerBean remotePeerBean = new LocalPeerBean(quorumPeer);    /**     * Case 1: When cnxnFactory is null     */    String result = remotePeerBean.getClientAddress();    assertNotNull(result);    assertEquals(0, result.length());    /**     * Case 2: When only client port is configured     */    ServerCnxnFactory cnxnFactory = ServerCnxnFactory.createFactory();    int clientPort = PortAssignment.unique();    InetSocketAddress address = new InetSocketAddress(clientPort);    cnxnFactory.configure(address, 5, -1, false);    quorumPeer.setCnxnFactory(cnxnFactory);    result = remotePeerBean.getClientAddress();    String ipv4 = "0.0.0.0:" + clientPort;    String ipv6 = "[0:0:0:0:0:0:0:0]:" + clientPort;    assertTrue(result.equals(ipv4) || result.equals(ipv6));        cnxnFactory.shutdown();    /**     * Case 3: When both client port and client address is configured     */    clientPort = PortAssignment.unique();    InetAddress clientIP = InetAddress.getLoopbackAddress();    address = new InetSocketAddress(clientIP, clientPort);    cnxnFactory = ServerCnxnFactory.createFactory();    cnxnFactory.configure(address, 5, -1, false);    quorumPeer.setCnxnFactory(cnxnFactory);    result = remotePeerBean.getClientAddress();    String expectedResult = clientIP.getHostAddress() + ":" + clientPort;    assertEquals(expectedResult, result);        cnxnFactory.shutdown();}
testLocalPeerIsLeader
public void zookeeper_f5136_0() throws Exception
{    long localPeerId = 7;    QuorumPeer peer = mock(QuorumPeer.class);    when(peer.getId()).thenReturn(localPeerId);    when(peer.isLeader(eq(localPeerId))).thenReturn(true);    LocalPeerBean localPeerBean = new LocalPeerBean(peer);    assertTrue(localPeerBean.isLeader());}
testLocalPeerIsNotLeader
public void zookeeper_f5137_0() throws Exception
{    long localPeerId = 7;    QuorumPeer peer = mock(QuorumPeer.class);    when(peer.getId()).thenReturn(localPeerId);    when(peer.isLeader(eq(localPeerId))).thenReturn(false);    LocalPeerBean localPeerBean = new LocalPeerBean(peer);    assertFalse(localPeerBean.isLeader());}
testGetNameProperty
public void zookeeper_f5138_0()
{    QuorumPeer qpMock = mock(QuorumPeer.class);    when(qpMock.getId()).thenReturn(1L);    QuorumBean qb = new QuorumBean(qpMock);    assertThat("getName property should return Bean name in the right format", qb.getName(), equalTo("ReplicatedServer_id1"));}
testIsHiddenProperty
public void zookeeper_f5139_0()
{    QuorumPeer qpMock = mock(QuorumPeer.class);    QuorumBean qb = new QuorumBean(qpMock);    assertThat("isHidden should return false", qb.isHidden(), equalTo(false));}
testGetQuorumSizeProperty
public void zookeeper_f5140_0()
{    QuorumPeer qpMock = mock(QuorumPeer.class);    QuorumBean qb = new QuorumBean(qpMock);    when(qpMock.getQuorumSize()).thenReturn(5);    assertThat("getQuorumSize property should return value of peet.getQuorumSize()", qb.getQuorumSize(), equalTo(5));}
testSslQuorumProperty
public void zookeeper_f5141_0()
{    QuorumPeer qpMock = mock(QuorumPeer.class);    QuorumBean qb = new QuorumBean(qpMock);    when(qpMock.isSslQuorum()).thenReturn(true);    assertThat("isSslQuorum property should return value of peer.isSslQuorum()", qb.isSslQuorum(), equalTo(true));    when(qpMock.isSslQuorum()).thenReturn(false);    assertThat("isSslQuorum property should return value of peer.isSslQuorum()", qb.isSslQuorum(), equalTo(false));}
testPortUnificationProperty
public void zookeeper_f5142_0()
{    QuorumPeer qpMock = mock(QuorumPeer.class);    QuorumBean qb = new QuorumBean(qpMock);    when(qpMock.shouldUsePortUnification()).thenReturn(true);    assertThat("isPortUnification property should return value of peer.shouldUsePortUnification()", qb.isPortUnification(), equalTo(true));    when(qpMock.shouldUsePortUnification()).thenReturn(false);    assertThat("isPortUnification property should return value of peer.shouldUsePortUnification()", qb.isPortUnification(), equalTo(false));}
testErrorMessageWhensecureClientPortNotSetButsecureClientPortAddressSet
public void zookeeper_f5143_0() throws IOException, ConfigException
{    QuorumPeerConfig quorumPeerConfig = new QuorumPeerConfig();    try {        Properties zkProp = getDefaultZKProperties();        zkProp.setProperty("secureClientPortAddress", "localhost");        quorumPeerConfig.parseProperties(zkProp);        fail("IllegalArgumentException is expected");    } catch (IllegalArgumentException e) {        String expectedMessage = "secureClientPortAddress is set but secureClientPort is not set";        assertEquals(expectedMessage, e.getMessage());    }}
testErrorMessageWhenclientPortNotSetButclientPortAddressSet
public void zookeeper_f5144_0() throws IOException, ConfigException
{    QuorumPeerConfig quorumPeerConfig = new QuorumPeerConfig();    try {        Properties zkProp = getDefaultZKProperties();        zkProp.setProperty("clientPortAddress", "localhost");        quorumPeerConfig.parseProperties(zkProp);        fail("IllegalArgumentException is expected");    } catch (IllegalArgumentException e) {        String expectedMessage = "clientPortAddress is set but clientPort is not set";        assertEquals(expectedMessage, e.getMessage());    }}
testConfigureSSLAuthGetsConfiguredIfSecurePortConfigured
public void zookeeper_f5145_0() throws IOException, ConfigException
{    String sslAuthProp = "zookeeper.authProvider.x509";    QuorumPeerConfig quorumPeerConfig = new QuorumPeerConfig();    Properties zkProp = getDefaultZKProperties();    zkProp.setProperty("secureClientPort", "12345");    quorumPeerConfig.parseProperties(zkProp);    String expected = "org.apache.zookeeper.server.auth.X509AuthenticationProvider";    String result = System.getProperty(sslAuthProp);    assertEquals(expected, result);}
testCustomSSLAuth
public void zookeeper_f5146_0() throws IOException
{    try (ClientX509Util x509Util = new ClientX509Util()) {        System.setProperty(x509Util.getSslAuthProviderProperty(), "y509");        QuorumPeerConfig quorumPeerConfig = new QuorumPeerConfig();        try {            Properties zkProp = getDefaultZKProperties();            zkProp.setProperty("secureClientPort", "12345");            quorumPeerConfig.parseProperties(zkProp);            fail("ConfigException is expected");        } catch (ConfigException e) {            assertNotNull(e.getMessage());        }    }}
testSamePortConfiguredForClientAndElection
public void zookeeper_f5147_0() throws IOException, ConfigException
{    QuorumPeerConfig quorumPeerConfig = new QuorumPeerConfig();    Properties zkProp = getDefaultZKProperties();    zkProp.setProperty("server.1", "localhost:2888:2888");    quorumPeerConfig.parseProperties(zkProp);}
testClientAddrFromClientPort
public void zookeeper_f5148_0() throws IOException, ConfigException
{    long serverId = 1;    QuorumPeerConfig quorumPeerConfig = new MockQuorumPeerConfig(serverId);    Properties zkProp = getDefaultZKProperties();    int clientPort = 12345;    zkProp.setProperty("clientPort", Integer.toString(clientPort));    zkProp.setProperty("server.1", "127.0.0.1:2889:3889:participant");    quorumPeerConfig.parseProperties(zkProp);    QuorumServer qs = quorumPeerConfig.getQuorumVerifier().getAllMembers().get(serverId);    InetSocketAddress expectedAddress = new InetSocketAddress("0.0.0.0", clientPort);    assertEquals(expectedAddress, quorumPeerConfig.getClientPortAddress());    assertEquals(quorumPeerConfig.getClientPortAddress(), qs.clientAddr);}
testJvmPauseMonitorConfigured
public void zookeeper_f5149_0() throws IOException, ConfigException
{    final Long sleepTime = 444L;    final Long warnTH = 5555L;    final Long infoTH = 555L;    QuorumPeerConfig quorumPeerConfig = new QuorumPeerConfig();    Properties zkProp = getDefaultZKProperties();    zkProp.setProperty("dataDir", new File("myDataDir").getAbsolutePath());    zkProp.setProperty("jvm.pause.monitor", "true");    zkProp.setProperty("jvm.pause.sleep.time.ms", sleepTime.toString());    zkProp.setProperty("jvm.pause.warn-threshold.ms", warnTH.toString());    zkProp.setProperty("jvm.pause.info-threshold.ms", infoTH.toString());    quorumPeerConfig.parseProperties(zkProp);    assertEquals(sleepTime, Long.valueOf(quorumPeerConfig.getJvmPauseSleepTimeMs()));    assertEquals(warnTH, Long.valueOf(quorumPeerConfig.getJvmPauseWarnThresholdMs()));    assertEquals(infoTH, Long.valueOf(quorumPeerConfig.getJvmPauseInfoThresholdMs()));    assertTrue(quorumPeerConfig.isJvmPauseMonitorToRun());}
getDefaultZKProperties
private Properties zookeeper_f5150_0()
{    Properties zkProp = new Properties();    zkProp.setProperty("dataDir", new File("myDataDir").getAbsolutePath());    return zkProp;}
testQuorumInternal
public void zookeeper_f5151_0(String addr) throws Exception
{    ClientBase.setupTestEnv();    final int CLIENT_PORT_QP1 = PortAssignment.unique();    final int CLIENT_PORT_QP2 = PortAssignment.unique();    String server1 = String.format("server.1=%1$s:%2$s:%3$s;%4$s", addr, PortAssignment.unique(), PortAssignment.unique(), CLIENT_PORT_QP1);    String server2 = String.format("server.2=%1$s:%2$s:%3$s;%4$s", addr, PortAssignment.unique(), PortAssignment.unique(), CLIENT_PORT_QP2);    String quorumCfgSection = server1 + "\n" + server2;    MainThread q1 = new MainThread(1, CLIENT_PORT_QP1, quorumCfgSection);    MainThread q2 = new MainThread(2, CLIENT_PORT_QP2, quorumCfgSection);    q1.start();    q2.start();    assertTrue("waiting for server 1 being up", ClientBase.waitForServerUp(addr + ":" + CLIENT_PORT_QP1, CONNECTION_TIMEOUT));    assertTrue("waiting for server 2 being up", ClientBase.waitForServerUp(addr + ":" + CLIENT_PORT_QP2, CONNECTION_TIMEOUT));    QuorumPeer quorumPeer = q1.main.quorumPeer;    int tickTime = quorumPeer.getTickTime();    assertEquals("Default value of minimumSessionTimeOut is not considered", tickTime * 2, quorumPeer.getMinSessionTimeout());    assertEquals("Default value of maximumSessionTimeOut is not considered", tickTime * 20, quorumPeer.getMaxSessionTimeout());    ZooKeeper zk = new ZooKeeper(addr + ":" + CLIENT_PORT_QP1, ClientBase.CONNECTION_TIMEOUT, this);    waitForOne(zk, States.CONNECTED);    zk.create("/foo_q1", "foobar1".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    assertEquals(new String(zk.getData("/foo_q1", null, null)), "foobar1");    zk.close();    zk = new ZooKeeper(addr + ":" + CLIENT_PORT_QP2, ClientBase.CONNECTION_TIMEOUT, this);    waitForOne(zk, States.CONNECTED);    zk.create("/foo_q2", "foobar2".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    assertEquals(new String(zk.getData("/foo_q2", null, null)), "foobar2");    zk.close();    q1.shutdown();    q2.shutdown();    assertTrue("waiting for server 1 down", ClientBase.waitForServerDown(addr + ":" + CLIENT_PORT_QP1, ClientBase.CONNECTION_TIMEOUT));    assertTrue("waiting for server 2 down", ClientBase.waitForServerDown(addr + ":" + CLIENT_PORT_QP2, ClientBase.CONNECTION_TIMEOUT));}
testQuorum
public void zookeeper_f5152_0() throws Exception
{    testQuorumInternal("127.0.0.1");}
testQuorumV6
public void zookeeper_f5153_0() throws Exception
{    testQuorumInternal("[::1]");}
testEarlyLeaderAbandonment
public void zookeeper_f5154_0() throws Exception
{    ClientBase.setupTestEnv();    final int SERVER_COUNT = 3;    final int[] clientPorts = new int[SERVER_COUNT];    StringBuilder sb = new StringBuilder();    for (int i = 0; i < SERVER_COUNT; i++) {        clientPorts[i] = PortAssignment.unique();        sb.append("server." + i + "=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ";" + clientPorts[i] + "\n");    }    String quorumCfgSection = sb.toString();    MainThread[] mt = new MainThread[SERVER_COUNT];    ZooKeeper[] zk = new ZooKeeper[SERVER_COUNT];    for (int i = 0; i < SERVER_COUNT; i++) {        mt[i] = new MainThread(i, clientPorts[i], quorumCfgSection);        mt[i].start();        zk[i] = new ZooKeeper("127.0.0.1:" + clientPorts[i], ClientBase.CONNECTION_TIMEOUT, this);    }    waitForAll(zk, States.CONNECTED);        for (int i = 0; i < SERVER_COUNT; i++) {        mt[i].shutdown();    }    waitForAll(zk, States.CONNECTING);    for (int i = 0; i < SERVER_COUNT; i++) {        mt[i].start();                zk[i] = new ZooKeeper("127.0.0.1:" + clientPorts[i], ClientBase.CONNECTION_TIMEOUT, this);    }    waitForAll(zk, States.CONNECTED);            int leader = -1;    Map<Long, Proposal> outstanding = null;    for (int i = 0; i < SERVER_COUNT; i++) {        if (mt[i].main.quorumPeer.leader == null) {            mt[i].shutdown();        } else {            leader = i;            outstanding = mt[leader].main.quorumPeer.leader.outstandingProposals;        }    }    try {        zk[leader].create("/zk" + leader, "zk".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        fail("create /zk" + leader + " should have failed");    } catch (KeeperException e) {    }            assertTrue(outstanding.size() == 1);    assertTrue(outstanding.values().iterator().next().request.getHdr().getType() == OpCode.create);        Thread.sleep(1000);    mt[leader].shutdown();    waitForAll(zk, States.CONNECTING);    for (int i = 0; i < SERVER_COUNT; i++) {        if (i != leader) {            mt[i].start();        }    }    for (int i = 0; i < SERVER_COUNT; i++) {        if (i != leader) {                        zk[i] = new ZooKeeper("127.0.0.1:" + clientPorts[i], ClientBase.CONNECTION_TIMEOUT, this);            waitForOne(zk[i], States.CONNECTED);            zk[i].create("/zk" + i, "zk".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        }    }    mt[leader].start();    waitForAll(zk, States.CONNECTED);        for (int i = 0; i < SERVER_COUNT; i++) {        for (int j = 0; j < SERVER_COUNT; j++) {            if (i == leader) {                assertTrue((j == leader ? ("Leader (" + leader + ")") : ("Follower " + j)) + " should not have /zk" + i, zk[j].exists("/zk" + i, false) == null);            } else {                assertTrue((j == leader ? ("Leader (" + leader + ")") : ("Follower " + j)) + " does not have /zk" + i, zk[j].exists("/zk" + i, false) != null);            }        }    }    for (int i = 0; i < SERVER_COUNT; i++) {        zk[i].close();    }    for (int i = 0; i < SERVER_COUNT; i++) {        mt[i].shutdown();    }}
testHighestZxidJoinLate
public void zookeeper_f5155_0() throws Exception
{    numServers = 3;    servers = LaunchServers(numServers);    String path = "/hzxidtest";    int leader = servers.findLeader();        assertTrue("There should be a leader", leader >= 0);    int nonleader = (leader + 1) % numServers;    byte[] input = new byte[1];    input[0] = 1;    byte[] output;        servers.zk[leader].create(path + leader, input, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    servers.zk[leader].create(path + nonleader, input, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);            output = servers.zk[leader].getData(path + nonleader, false, null);        for (int i = 0; i < numServers; i++) {        if (i != leader) {            servers.mt[i].shutdown();        }    }    input[0] = 2;        servers.zk[leader].setData(path + leader, input, -1, null, null);        Thread.sleep(500);        servers.mt[leader].shutdown();    System.gc();    waitForAll(servers.zk, States.CONNECTING);        for (int i = 0; i < numServers; i++) {        if (i != leader) {            servers.mt[i].start();        }    }        waitForOne(servers.zk[nonleader], States.CONNECTED);        output = servers.zk[nonleader].getData(path + leader, false, null);    assertEquals("Expecting old value 1 since 2 isn't committed yet", output[0], 1);            servers.zk[nonleader].setData(path + nonleader, input, -1);        servers.mt[leader].start();        waitForOne(servers.zk[leader], States.CONNECTED);        output = servers.zk[leader].getData(path + leader, false, null);    assertEquals("Validating that the deposed leader has rolled back that change it had written", output[0], 1);        output = servers.zk[leader].getData(path + nonleader, false, null);    assertEquals("Validating that the deposed leader caught up on changes it missed", output[0], 2);}
testElectionFraud
public void zookeeper_f5156_0() throws IOException, InterruptedException
{        ByteArrayOutputStream os = new ByteArrayOutputStream();    WriterAppender appender = getConsoleAppender(os, Level.INFO);    Logger qlogger = Logger.getLogger(QuorumPeer.class);    qlogger.addAppender(appender);    numServers = 3;        boolean foundLeading = false;    boolean foundLooking = false;    boolean foundFollowing = false;    try {                servers = LaunchServers(numServers, 500);                int trueLeader = servers.findLeader();        assertTrue("There should be a leader", trueLeader >= 0);                int falseLeader = (trueLeader + 1) % numServers;        assertTrue("All servers should join the quorum", servers.mt[falseLeader].main.quorumPeer.follower != null);                        servers.mt[falseLeader].main.quorumPeer.electionAlg.shutdown();        servers.mt[falseLeader].main.quorumPeer.follower.getSocket().close();                waitForOne(servers.zk[falseLeader], States.CONNECTING);                servers.mt[falseLeader].main.quorumPeer.setPeerState(QuorumPeer.ServerState.LEADING);                        Thread.sleep(2 * servers.mt[falseLeader].main.quorumPeer.initLimit * servers.mt[falseLeader].main.quorumPeer.tickTime);                servers.mt[falseLeader].main.quorumPeer.startLeaderElection();                servers.zk[falseLeader] = new ZooKeeper("127.0.0.1:" + servers.mt[falseLeader].getClientPort(), ClientBase.CONNECTION_TIMEOUT, this);                waitForOne(servers.zk[falseLeader], States.CONNECTED);                assertTrue(servers.mt[trueLeader].main.quorumPeer.leader != null);                LineNumberReader r = new LineNumberReader(new StringReader(os.toString()));        Pattern leading = Pattern.compile(".*myid=" + falseLeader + ".*LEADING.*");        Pattern looking = Pattern.compile(".*myid=" + falseLeader + ".*LOOKING.*");        Pattern following = Pattern.compile(".*myid=" + falseLeader + ".*FOLLOWING.*");        String line;        while ((line = r.readLine()) != null) {            if (!foundLeading) {                foundLeading = leading.matcher(line).matches();            } else if (!foundLooking) {                foundLooking = looking.matcher(line).matches();            } else if (following.matcher(line).matches()) {                foundFollowing = true;                break;            }        }    } finally {        qlogger.removeAppender(appender);    }    assertTrue("falseLeader never attempts to become leader", foundLeading);    assertTrue("falseLeader never gives up on leadership", foundLooking);    assertTrue("falseLeader never rejoins the quorum", foundFollowing);}
testBadPeerAddressInQuorum
public void zookeeper_f5157_0() throws Exception
{    ClientBase.setupTestEnv();        ByteArrayOutputStream os = new ByteArrayOutputStream();    WriterAppender appender = getConsoleAppender(os, Level.WARN);    Logger qlogger = Logger.getLogger("org.apache.zookeeper.server.quorum");    qlogger.addAppender(appender);    try {        final int CLIENT_PORT_QP1 = PortAssignment.unique();        final int CLIENT_PORT_QP2 = PortAssignment.unique();        String quorumCfgSection = "server.1=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ";" + CLIENT_PORT_QP1 + "\nserver.2=fee.fii.foo.fum:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ";" + CLIENT_PORT_QP2;        MainThread q1 = new MainThread(1, CLIENT_PORT_QP1, quorumCfgSection);        q1.start();        boolean isup = ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_QP1, 30000);        assertFalse("Server never came up", isup);        q1.shutdown();        assertTrue("waiting for server 1 down", ClientBase.waitForServerDown("127.0.0.1:" + CLIENT_PORT_QP1, ClientBase.CONNECTION_TIMEOUT));    } finally {        qlogger.removeAppender(appender);    }    LineNumberReader r = new LineNumberReader(new StringReader(os.toString()));    String line;    boolean found = false;    Pattern p = Pattern.compile(".*Cannot open channel to .* at election address .*");    while ((line = r.readLine()) != null) {        found = p.matcher(line).matches();        if (found) {            break;        }    }    assertTrue("complains about host", found);}
testInconsistentPeerType
public void zookeeper_f5158_0() throws Exception
{    ClientBase.setupTestEnv();        ByteArrayOutputStream os = new ByteArrayOutputStream();    WriterAppender appender = getConsoleAppender(os, Level.INFO);    Logger qlogger = Logger.getLogger("org.apache.zookeeper.server.quorum");    qlogger.addAppender(appender);        try {        final int CLIENT_PORT_QP1 = PortAssignment.unique();        final int CLIENT_PORT_QP2 = PortAssignment.unique();        final int CLIENT_PORT_QP3 = PortAssignment.unique();        String quorumCfgSection = "server.1=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ";" + CLIENT_PORT_QP1 + "\nserver.2=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ";" + CLIENT_PORT_QP2 + "\nserver.3=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ":observer" + ";" + CLIENT_PORT_QP3;        MainThread q1 = new MainThread(1, CLIENT_PORT_QP1, quorumCfgSection);        MainThread q2 = new MainThread(2, CLIENT_PORT_QP2, quorumCfgSection);        MainThread q3 = new MainThread(3, CLIENT_PORT_QP3, quorumCfgSection);        q1.start();        q2.start();        q3.start();        assertTrue("waiting for server 1 being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_QP1, CONNECTION_TIMEOUT));        assertTrue("waiting for server 2 being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_QP2, CONNECTION_TIMEOUT));        assertTrue("waiting for server 3 being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_QP3, CONNECTION_TIMEOUT));        q1.shutdown();        q2.shutdown();        q3.shutdown();        assertTrue("waiting for server 1 down", ClientBase.waitForServerDown("127.0.0.1:" + CLIENT_PORT_QP1, ClientBase.CONNECTION_TIMEOUT));        assertTrue("waiting for server 2 down", ClientBase.waitForServerDown("127.0.0.1:" + CLIENT_PORT_QP2, ClientBase.CONNECTION_TIMEOUT));        assertTrue("waiting for server 3 down", ClientBase.waitForServerDown("127.0.0.1:" + CLIENT_PORT_QP3, ClientBase.CONNECTION_TIMEOUT));    } finally {        qlogger.removeAppender(appender);    }    LineNumberReader r = new LineNumberReader(new StringReader(os.toString()));    String line;    boolean warningPresent = false;    boolean defaultedToObserver = false;    Pattern pWarn = Pattern.compile(".*Peer type from servers list.* doesn't match peerType.*");    Pattern pObserve = Pattern.compile(".*OBSERVING.*");    while ((line = r.readLine()) != null) {        if (pWarn.matcher(line).matches()) {            warningPresent = true;        }        if (pObserve.matcher(line).matches()) {            defaultedToObserver = true;        }        if (warningPresent && defaultedToObserver) {            break;        }    }    assertTrue("Should warn about inconsistent peer type", warningPresent && defaultedToObserver);}
testBadPackets
public void zookeeper_f5159_0() throws Exception
{    ClientBase.setupTestEnv();    final int CLIENT_PORT_QP1 = PortAssignment.unique();    final int CLIENT_PORT_QP2 = PortAssignment.unique();    int electionPort1 = PortAssignment.unique();    int electionPort2 = PortAssignment.unique();    String quorumCfgSection = "server.1=127.0.0.1:" + PortAssignment.unique() + ":" + electionPort1 + ";" + CLIENT_PORT_QP1 + "\nserver.2=127.0.0.1:" + PortAssignment.unique() + ":" + electionPort2 + ";" + CLIENT_PORT_QP2;    MainThread q1 = new MainThread(1, CLIENT_PORT_QP1, quorumCfgSection);    MainThread q2 = new MainThread(2, CLIENT_PORT_QP2, quorumCfgSection);    q1.start();    q2.start();    assertTrue("waiting for server 1 being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_QP1, CONNECTION_TIMEOUT));    assertTrue("waiting for server 2 being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_QP2, CONNECTION_TIMEOUT));    byte[] b = new byte[4];    int length = 1024 * 1024 * 1024;    ByteBuffer buff = ByteBuffer.wrap(b);    buff.putInt(length);    buff.position(0);    SocketChannel s = SocketChannel.open(new InetSocketAddress("127.0.0.1", electionPort1));    s.write(buff);    s.close();    buff.position(0);    s = SocketChannel.open(new InetSocketAddress("127.0.0.1", electionPort2));    s.write(buff);    s.close();    ZooKeeper zk = new ZooKeeper("127.0.0.1:" + CLIENT_PORT_QP1, ClientBase.CONNECTION_TIMEOUT, this);    waitForOne(zk, States.CONNECTED);    zk.create("/foo_q1", "foobar1".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    assertEquals(new String(zk.getData("/foo_q1", null, null)), "foobar1");    zk.close();    q1.shutdown();    q2.shutdown();}
testQuorumDefaults
public void zookeeper_f5160_0() throws Exception
{    ClientBase.setupTestEnv();        ByteArrayOutputStream os = new ByteArrayOutputStream();    WriterAppender appender = getConsoleAppender(os, Level.INFO);    appender.setImmediateFlush(true);    Logger zlogger = Logger.getLogger("org.apache.zookeeper");    zlogger.addAppender(appender);    try {        final int CLIENT_PORT_QP1 = PortAssignment.unique();        final int CLIENT_PORT_QP2 = PortAssignment.unique();        String quorumCfgSection = "server.1=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ";" + CLIENT_PORT_QP1 + "\nserver.2=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ";" + CLIENT_PORT_QP2;        MainThread q1 = new MainThread(1, CLIENT_PORT_QP1, quorumCfgSection);        MainThread q2 = new MainThread(2, CLIENT_PORT_QP2, quorumCfgSection);        q1.start();        q2.start();        assertTrue("waiting for server 1 being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_QP1, CONNECTION_TIMEOUT));        assertTrue("waiting for server 2 being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_QP2, CONNECTION_TIMEOUT));        q1.shutdown();        q2.shutdown();        assertTrue("waiting for server 1 down", ClientBase.waitForServerDown("127.0.0.1:" + CLIENT_PORT_QP1, ClientBase.CONNECTION_TIMEOUT));        assertTrue("waiting for server 2 down", ClientBase.waitForServerDown("127.0.0.1:" + CLIENT_PORT_QP2, ClientBase.CONNECTION_TIMEOUT));    } finally {        zlogger.removeAppender(appender);    }    os.close();    LineNumberReader r = new LineNumberReader(new StringReader(os.toString()));    String line;    boolean found = false;    Pattern p = Pattern.compile(".*FastLeaderElection.*");    while ((line = r.readLine()) != null) {        found = p.matcher(line).matches();        if (found) {            break;        }    }    assertTrue("fastleaderelection used", found);}
testQuorumPeerExitTime
public void zookeeper_f5161_0() throws Exception
{    long maxwait = 3000;    final int CLIENT_PORT_QP1 = PortAssignment.unique();    String quorumCfgSection = "server.1=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ";" + CLIENT_PORT_QP1 + "\nserver.2=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ";" + PortAssignment.unique();    MainThread q1 = new MainThread(1, CLIENT_PORT_QP1, quorumCfgSection);    q1.start();        Thread.sleep(30000);    long start = Time.currentElapsedTime();    q1.shutdown();    long end = Time.currentElapsedTime();    if ((end - start) > maxwait) {        fail("QuorumPeer took " + (end - start) + " to shutdown, expected " + maxwait);    }}
testMinMaxSessionTimeOut
public void zookeeper_f5162_0() throws Exception
{    ClientBase.setupTestEnv();    final int CLIENT_PORT_QP1 = PortAssignment.unique();    final int CLIENT_PORT_QP2 = PortAssignment.unique();    String quorumCfgSection = "server.1=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + "\nserver.2=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique();    final int minSessionTimeOut = 10000;    final int maxSessionTimeOut = 15000;    final String configs = "maxSessionTimeout=" + maxSessionTimeOut + "\n" + "minSessionTimeout=" + minSessionTimeOut + "\n";    MainThread q1 = new MainThread(1, CLIENT_PORT_QP1, quorumCfgSection, configs);    MainThread q2 = new MainThread(2, CLIENT_PORT_QP2, quorumCfgSection, configs);    q1.start();    q2.start();    assertTrue("waiting for server 1 being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_QP1, CONNECTION_TIMEOUT));    assertTrue("waiting for server 2 being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_QP2, CONNECTION_TIMEOUT));    QuorumPeer quorumPeer = q1.main.quorumPeer;    assertEquals("minimumSessionTimeOut is not considered", minSessionTimeOut, quorumPeer.getMinSessionTimeout());    assertEquals("maximumSessionTimeOut is not considered", maxSessionTimeOut, quorumPeer.getMaxSessionTimeout());}
testWithOnlyMinSessionTimeout
public void zookeeper_f5163_0() throws Exception
{    ClientBase.setupTestEnv();    final int CLIENT_PORT_QP1 = PortAssignment.unique();    final int CLIENT_PORT_QP2 = PortAssignment.unique();    String quorumCfgSection = "server.1=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + "\nserver.2=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique();    final int minSessionTimeOut = 15000;    final String configs = "minSessionTimeout=" + minSessionTimeOut + "\n";    MainThread q1 = new MainThread(1, CLIENT_PORT_QP1, quorumCfgSection, configs);    MainThread q2 = new MainThread(2, CLIENT_PORT_QP2, quorumCfgSection, configs);    q1.start();    q2.start();    assertTrue("waiting for server 1 being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_QP1, CONNECTION_TIMEOUT));    assertTrue("waiting for server 2 being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_QP2, CONNECTION_TIMEOUT));    QuorumPeer quorumPeer = q1.main.quorumPeer;    final int maxSessionTimeOut = quorumPeer.tickTime * 20;    assertEquals("minimumSessionTimeOut is not considered", minSessionTimeOut, quorumPeer.getMinSessionTimeout());    assertEquals("maximumSessionTimeOut is wrong", maxSessionTimeOut, quorumPeer.getMaxSessionTimeout());}
testFailedTxnAsPartOfQuorumLoss
public voidf5164_1) throws Exception
{    final int LEADER_TIMEOUT_MS = 10_000;        ClientBase.setupTestEnv();    final int SERVER_COUNT = 3;    servers = LaunchServers(SERVER_COUNT);    waitForAll(servers, States.CONNECTED);            servers.shutDownAllServers();    waitForAll(servers, States.CONNECTING);    servers.restartAllServersAndClients(this);    waitForAll(servers, States.CONNECTED);        int leader = servers.findLeader();    Map<Long, Proposal> outstanding = servers.mt[leader].main.quorumPeer.leader.outstandingProposals;        int previousTick = servers.mt[leader].main.quorumPeer.tickTime;    servers.mt[leader].main.quorumPeer.tickTime = LEADER_TIMEOUT_MS;        Thread.sleep(previousTick);        for (int i = 0; i < SERVER_COUNT; i++) {        if (i != leader) {            servers.mt[i].shutdown();        }    }        for (int i = 0; i < SERVER_COUNT; i++) {        if (i != leader) {            servers.mt[i].start();        }    }        for (int i = 0; i < SERVER_COUNT; i++) {        if (i != leader) {                        servers.restartClient(i, this);            waitForOne(servers.zk[i], States.CONNECTED);        }    }        try {        servers.zk[leader].create("/zk" + leader, "zk".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        fail("create /zk" + leader + " should have failed");    } catch (KeeperException e) {    }                assertTrue(outstanding.size() > 0);    Proposal p = findProposalOfType(outstanding, OpCode.create);        assertNotNull("Old leader doesn't have 'create' proposal", p);        int sleepTime = 0;    Long longLeader = Long.valueOf(leader);    while (!p.qvAcksetPairs.get(0).getAckset().contains(longLeader)) {        if (sleepTime > 2000) {            fail("Transaction not synced to disk within 1 second " + p.qvAcksetPairs.get(0).getAckset() + " expected " + leader);        }        Thread.sleep(100);        sleepTime += 100;    }            sleepTime = 0;    Follower f = servers.mt[leader].main.quorumPeer.follower;    while (f == null || !f.isRunning()) {        if (sleepTime > LEADER_TIMEOUT_MS * 2) {            fail("Took too long for old leader to time out " + servers.mt[leader].main.quorumPeer.getPeerState());        }        Thread.sleep(100);        sleepTime += 100;        f = servers.mt[leader].main.quorumPeer.follower;    }    int newLeader = servers.findLeader();        assertNotEquals(leader, newLeader);        servers.mt[leader].shutdown();    servers.mt[leader].start();        servers.restartClient(leader, this);    waitForAll(servers, States.CONNECTED);        for (int i = 0; i < SERVER_COUNT; i++) {        assertNull("server " + i + " should not have /zk" + leader, servers.zk[i].exists("/zk" + leader, false));    }}
testLeaderOutOfView
public void zookeeper_f5165_0() throws Exception
{    ClientBase.setupTestEnv();    int numServers = 3;        boolean foundLeading = false;    boolean foundFollowing = false;        ByteArrayOutputStream os = new ByteArrayOutputStream();    WriterAppender appender = getConsoleAppender(os, Level.DEBUG);    Logger qlogger = Logger.getLogger("org.apache.zookeeper.server.quorum");    qlogger.addAppender(appender);    try {        Servers svrs = new Servers();        svrs.clientPorts = new int[numServers];        for (int i = 0; i < numServers; i++) {            svrs.clientPorts[i] = PortAssignment.unique();        }        String quorumCfgIncomplete = getUniquePortCfgForId(1) + "\n" + getUniquePortCfgForId(2);        String quorumCfgComplete = quorumCfgIncomplete + "\n" + getUniquePortCfgForId(3);        svrs.mt = new MainThread[3];                svrs.mt[0] = new MainThread(1, svrs.clientPorts[0], quorumCfgIncomplete);        for (int i = 1; i < numServers; i++) {            svrs.mt[i] = new MainThread(i + 1, svrs.clientPorts[i], quorumCfgComplete);        }                svrs.mt[0].start();        QuorumPeer quorumPeer1 = waitForQuorumPeer(svrs.mt[0], CONNECTION_TIMEOUT);        assertTrue(quorumPeer1.getPeerState() == QuorumPeer.ServerState.LOOKING);                int highestServerIndex = numServers - 1;        svrs.mt[highestServerIndex].start();        QuorumPeer quorumPeer3 = waitForQuorumPeer(svrs.mt[highestServerIndex], CONNECTION_TIMEOUT);        assertTrue(quorumPeer3.getPeerState() == QuorumPeer.ServerState.LOOKING);                for (int i = 1; i < highestServerIndex; i++) {            svrs.mt[i].start();        }                for (int i = 1; i < numServers; i++) {            assertTrue("waiting for server to start", ClientBase.waitForServerUp("127.0.0.1:" + svrs.clientPorts[i], CONNECTION_TIMEOUT));        }        assertTrue(svrs.mt[0].getQuorumPeer().getPeerState() == QuorumPeer.ServerState.LOOKING);        assertTrue(svrs.mt[highestServerIndex].getQuorumPeer().getPeerState() == QuorumPeer.ServerState.LEADING);        for (int i = 1; i < highestServerIndex; i++) {            assertTrue(svrs.mt[i].getQuorumPeer().getPeerState() == QuorumPeer.ServerState.FOLLOWING);        }                LineNumberReader r = new LineNumberReader(new StringReader(os.toString()));        Pattern leading = Pattern.compile(".*myid=1.*QuorumPeer.*LEADING.*");        Pattern following = Pattern.compile(".*myid=1.*QuorumPeer.*FOLLOWING.*");        String line;        while ((line = r.readLine()) != null && !foundLeading && !foundFollowing) {            foundLeading = leading.matcher(line).matches();            foundFollowing = following.matcher(line).matches();        }    } finally {        qlogger.removeAppender(appender);    }    assertFalse("Corrupt peer should never become leader", foundLeading);    assertFalse("Corrupt peer should not attempt connection to out of view leader", foundFollowing);}
testDataDirAndDataLogDir
public void zookeeper_f5166_0() throws Exception
{    File dataDir = createEmptyTestDir();    File dataLogDir = createEmptyTestDir();        try {        QuorumPeerConfig configMock = mock(QuorumPeerConfig.class);        when(configMock.getDataDir()).thenReturn(dataDir);        when(configMock.getDataLogDir()).thenReturn(dataLogDir);        when(configMock.getMetricsProviderClassName()).thenReturn(NullMetricsProvider.class.getName());        QuorumPeer qpMock = mock(QuorumPeer.class);        doCallRealMethod().when(qpMock).setTxnFactory(any(FileTxnSnapLog.class));        when(qpMock.getTxnFactory()).thenCallRealMethod();        InjectableQuorumPeerMain qpMain = new InjectableQuorumPeerMain(qpMock);                qpMain.runFromConfig(configMock);                FileTxnSnapLog txnFactory = qpMain.getQuorumPeer().getTxnFactory();        assertEquals(Paths.get(dataLogDir.getAbsolutePath(), "version-2").toString(), txnFactory.getDataDir().getAbsolutePath());        assertEquals(Paths.get(dataDir.getAbsolutePath(), "version-2").toString(), txnFactory.getSnapDir().getAbsolutePath());    } finally {        FileUtils.deleteDirectory(dataDir);        FileUtils.deleteDirectory(dataLogDir);    }}
getQuorumPeer
protected QuorumPeer zookeeper_f5167_0()
{    return qp;}
getConsoleAppender
private WriterAppender zookeeper_f5168_0(ByteArrayOutputStream os, Level level)
{    String loggingPattern = ((PatternLayout) Logger.getRootLogger().getAppender("CONSOLE").getLayout()).getConversionPattern();    WriterAppender appender = new WriterAppender(new PatternLayout(loggingPattern), os);    appender.setThreshold(level);    return appender;}
getUniquePortCfgForId
private String zookeeper_f5169_0(int id)
{    return String.format("server.%d=127.0.0.1:%d:%d", id, PortAssignment.unique(), PortAssignment.unique());}
waitForQuorumPeer
private QuorumPeerf5170_1MainThread mainThread, int timeout) throws TimeoutException
{    long start = Time.currentElapsedTime();    while (true) {        QuorumPeer quorumPeer = mainThread.isAlive() ? mainThread.getQuorumPeer() : null;        if (quorumPeer != null) {            return quorumPeer;        }        if (Time.currentElapsedTime() > start + timeout) {                        throw new TimeoutException();        }        try {            Thread.sleep(250);        } catch (InterruptedException e) {                }    }}
findProposalOfType
private Proposal zookeeper_f5171_0(Map<Long, Proposal> proposals, int type)
{    for (Proposal proposal : proposals.values()) {        if (proposal.request.getHdr().getType() == type) {            return proposal;        }    }    return null;}
testInconsistentDueToNewLeaderOrder
public voidf5172_1) throws Exception
{        final int ENSEMBLE_SERVERS = 3;    final int[] clientPorts = new int[ENSEMBLE_SERVERS];    StringBuilder sb = new StringBuilder();    String server;    for (int i = 0; i < ENSEMBLE_SERVERS; i++) {        clientPorts[i] = PortAssignment.unique();        server = "server." + i + "=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ":participant;127.0.0.1:" + clientPorts[i];        sb.append(server + "\n");    }    String currentQuorumCfgSection = sb.toString();        MainThread[] mt = new MainThread[ENSEMBLE_SERVERS];    ZooKeeper[] zk = new ZooKeeper[ENSEMBLE_SERVERS];    Context[] contexts = new Context[ENSEMBLE_SERVERS];    for (int i = 0; i < ENSEMBLE_SERVERS; i++) {        final Context context = new Context();        contexts[i] = context;        mt[i] = new MainThread(i, clientPorts[i], currentQuorumCfgSection, false) {            @Override            public TestQPMain getTestQPMain() {                return new CustomizedQPMain(context);            }        };        mt[i].start();        zk[i] = new ZooKeeper("127.0.0.1:" + clientPorts[i], ClientBase.CONNECTION_TIMEOUT, this);    }    waitForAll(zk, States.CONNECTED);        String nodePath = "/testInconsistentDueToNewLeader";    int leaderId = -1;    int followerA = -1;    for (int i = 0; i < ENSEMBLE_SERVERS; i++) {        if (mt[i].main.quorumPeer.leader != null) {            leaderId = i;        } else if (followerA == -1) {            followerA = i;        }    }        mt[followerA].shutdown();    waitForOne(zk[followerA], States.CONNECTING);    try {                        System.setProperty(LearnerHandler.FORCE_SNAP_SYNC, "true");                String initialValue = "1";        final ZooKeeper leaderZk = zk[leaderId];        leaderZk.create(nodePath, initialValue.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);                CustomQuorumPeer leaderQuorumPeer = (CustomQuorumPeer) mt[leaderId].main.quorumPeer;                                        leaderQuorumPeer.setStartForwardingListener(new StartForwardingListener() {            @Override            public void start() {                if (!Boolean.getBoolean(LearnerHandler.FORCE_SNAP_SYNC)) {                    return;                }                final String value = "2";                                                try {                    leaderZk.setData(nodePath, value.getBytes(), -1, new AsyncCallback.StatCallback() {                        public void processResult(int rc, String path, Object ctx, Stat stat) {                        }                    }, null);                                        Thread.sleep(1000);                } catch (Exception e) {                                    }            }        });                                leaderQuorumPeer.setBeginSnapshotListener(new BeginSnapshotListener() {            @Override            public void start() {                String value = "3";                                try {                    leaderZk.setData(nodePath, value.getBytes(), -1);                                    } catch (Exception e) {                                    }            }        });                CustomQuorumPeer followerAQuorumPeer = ((CustomQuorumPeer) mt[followerA].main.quorumPeer);                contexts[followerA].exitWhenAckNewLeader = true;        CountDownLatch latch = new CountDownLatch(1);        final MainThread followerAMT = mt[followerA];        contexts[followerA].newLeaderAckCallback = new NewLeaderAckCallback() {            @Override            public void start() {                try {                    latch.countDown();                    followerAMT.shutdown();                } catch (Exception e) {                }            }        };                        mt[followerA].start();        assertTrue(latch.await(30, TimeUnit.SECONDS));                        System.setProperty(LearnerHandler.FORCE_SNAP_SYNC, "false");        contexts[followerA].exitWhenAckNewLeader = true;        contexts[followerA].newLeaderAckCallback = null;                mt[followerA].start();        zk[followerA].close();        zk[followerA] = new ZooKeeper("127.0.0.1:" + clientPorts[followerA], ClientBase.CONNECTION_TIMEOUT, this);                        waitForOne(zk[followerA], States.CONNECTED);        assertEquals(new String(zk[followerA].getData(nodePath, null, null)), new String(zk[leaderId].getData(nodePath, null, null)));    } finally {        System.clearProperty(LearnerHandler.FORCE_SNAP_SYNC);        for (int i = 0; i < ENSEMBLE_SERVERS; i++) {            mt[i].shutdown();            zk[i].close();        }    }}
getTestQPMain
public TestQPMain zookeeper_f5173_0()
{    return new CustomizedQPMain(context);}
start
public voidf5174_1)
{    if (!Boolean.getBoolean(LearnerHandler.FORCE_SNAP_SYNC)) {        return;    }    final String value = "2";            try {        leaderZk.setData(nodePath, value.getBytes(), -1, new AsyncCallback.StatCallback() {            public void processResult(int rc, String path, Object ctx, Stat stat) {            }        }, null);                Thread.sleep(1000);    } catch (Exception e) {            }}
processResult
public void zookeeper_f5175_0(int rc, String path, Object ctx, Stat stat)
{}
start
public voidf5176_1)
{    String value = "3";        try {        leaderZk.setData(nodePath, value.getBytes(), -1);            } catch (Exception e) {            }}
start
public void zookeeper_f5177_0()
{    try {        latch.countDown();        followerAMT.shutdown();    } catch (Exception e) {    }}
testLeaderElectionWithDisloyalVoter
public void zookeeper_f5178_0() throws IOException
{    testLeaderElection(5, 3, 1000, 10000);}
testLeaderElectionWithDisloyalVoter_stillHasMajority
public void zookeeper_f5179_0() throws IOException
{    testLeaderElection(5, 5, 3000, 20000);}
testLeaderElection
 void zookeeper_f5180_0(int totalServers, int serversToStart, int maxTimeToWaitForEpoch, int maxTimeWaitForServerUp) throws IOException
{    Leader.setMaxTimeToWaitForEpoch(maxTimeToWaitForEpoch);        servers = new Servers();    int ENSEMBLE_SERVERS = totalServers;    final int[] clientPorts = new int[ENSEMBLE_SERVERS];    StringBuilder sb = new StringBuilder();    String server;    for (int i = 0; i < ENSEMBLE_SERVERS; i++) {        clientPorts[i] = PortAssignment.unique();        server = "server." + i + "=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ":participant;127.0.0.1:" + clientPorts[i];        sb.append(server + "\n");    }    String currentQuorumCfgSection = sb.toString();        int SERVERS_TO_START = serversToStart;    MainThread[] mt = new MainThread[SERVERS_TO_START];    Context[] contexts = new Context[SERVERS_TO_START];    servers.mt = mt;    numServers = SERVERS_TO_START;    for (int i = 0; i < SERVERS_TO_START; i++) {                        final Context context = new Context();        if (i == 0) {            context.quitFollowing = true;        }        contexts[i] = context;        mt[i] = new MainThread(i, clientPorts[i], currentQuorumCfgSection, false) {            @Override            public TestQPMain getTestQPMain() {                return new CustomizedQPMain(context);            }        };        mt[i].start();    }        for (int i = 0; i < SERVERS_TO_START; i++) {        assertTrue("Server " + i + " should have joined quorum by now", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts[i], maxTimeWaitForServerUp));    }}
getTestQPMain
public TestQPMain zookeeper_f5181_0()
{    return new CustomizedQPMain(context);}
testMetricsProviderLifecycle
public void zookeeper_f5182_0() throws Exception
{    ClientBase.setupTestEnv();    BaseTestMetricsProvider.MetricsProviderCapturingLifecycle.reset();        ByteArrayOutputStream os = new ByteArrayOutputStream();    WriterAppender appender = getConsoleAppender(os, Level.WARN);    Logger qlogger = Logger.getLogger("org.apache.zookeeper.server.quorum");    qlogger.addAppender(appender);    try {        final int CLIENT_PORT_QP1 = PortAssignment.unique();        final int CLIENT_PORT_QP2 = PortAssignment.unique();        String quorumCfgSectionServer = "server.1=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ";" + CLIENT_PORT_QP1 + "\nserver.2=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ";" + CLIENT_PORT_QP2 + "\n";                String quorumCfgSectionServer1 = quorumCfgSectionServer + "metricsProvider.className=" + BaseTestMetricsProvider.MetricsProviderCapturingLifecycle.class.getName() + "\n";        MainThread q1 = new MainThread(1, CLIENT_PORT_QP1, quorumCfgSectionServer1);        MainThread q2 = new MainThread(2, CLIENT_PORT_QP2, quorumCfgSectionServer);        q1.start();        q2.start();        boolean isup1 = ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_QP1, 30000);        boolean isup2 = ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_QP2, 30000);        assertTrue("Server 1 never came up", isup1);        assertTrue("Server 2 never came up", isup2);        q1.shutdown();        q2.shutdown();        assertTrue("waiting for server 1 down", ClientBase.waitForServerDown("127.0.0.1:" + CLIENT_PORT_QP1, ClientBase.CONNECTION_TIMEOUT));        assertTrue("waiting for server 2 down", ClientBase.waitForServerDown("127.0.0.1:" + CLIENT_PORT_QP2, ClientBase.CONNECTION_TIMEOUT));    } finally {        qlogger.removeAppender(appender);    }    assertTrue("metrics provider lifecycle error", BaseTestMetricsProvider.MetricsProviderCapturingLifecycle.configureCalled.get());    assertTrue("metrics provider lifecycle error", BaseTestMetricsProvider.MetricsProviderCapturingLifecycle.startCalled.get());    assertTrue("metrics provider lifecycle error", BaseTestMetricsProvider.MetricsProviderCapturingLifecycle.getRootContextCalled.get());    assertTrue("metrics provider lifecycle error", BaseTestMetricsProvider.MetricsProviderCapturingLifecycle.stopCalled.get());}
testMetricsProviderConfiguration
public void zookeeper_f5183_0() throws Exception
{    ClientBase.setupTestEnv();    BaseTestMetricsProvider.MetricsProviderWithConfiguration.httpPort.set(0);        ByteArrayOutputStream os = new ByteArrayOutputStream();    WriterAppender appender = getConsoleAppender(os, Level.WARN);    Logger qlogger = Logger.getLogger("org.apache.zookeeper.server.quorum");    qlogger.addAppender(appender);    try {        final int CLIENT_PORT_QP1 = PortAssignment.unique();        final int CLIENT_PORT_QP2 = PortAssignment.unique();        String quorumCfgSectionServer = "server.1=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ";" + CLIENT_PORT_QP1 + "\n" + "server.2=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ";" + CLIENT_PORT_QP2 + "\n";                String quorumCfgSectionServer1 = quorumCfgSectionServer + "metricsProvider.className=" + BaseTestMetricsProvider.MetricsProviderWithConfiguration.class.getName() + "\n" + "metricsProvider.httpPort=1234";        MainThread q1 = new MainThread(1, CLIENT_PORT_QP1, quorumCfgSectionServer1);        MainThread q2 = new MainThread(2, CLIENT_PORT_QP2, quorumCfgSectionServer);        q1.start();        q2.start();        boolean isup1 = ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_QP1, 30000);        boolean isup2 = ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_QP2, 30000);        assertTrue("Server 1 never came up", isup1);        assertTrue("Server 2 never came up", isup2);        q1.shutdown();        q2.shutdown();        assertTrue("waiting for server 1 down", ClientBase.waitForServerDown("127.0.0.1:" + CLIENT_PORT_QP1, ClientBase.CONNECTION_TIMEOUT));        assertTrue("waiting for server 2 down", ClientBase.waitForServerDown("127.0.0.1:" + CLIENT_PORT_QP2, ClientBase.CONNECTION_TIMEOUT));    } finally {        qlogger.removeAppender(appender);    }    assertEquals(1234, BaseTestMetricsProvider.MetricsProviderWithConfiguration.httpPort.get());}
testFaultyMetricsProviderOnStop
public void zookeeper_f5184_0() throws Exception
{    ClientBase.setupTestEnv();    BaseTestMetricsProvider.MetricsProviderCapturingLifecycle.reset();        ByteArrayOutputStream os = new ByteArrayOutputStream();    WriterAppender appender = getConsoleAppender(os, Level.WARN);    Logger qlogger = Logger.getLogger("org.apache.zookeeper.server.quorum");    qlogger.addAppender(appender);    try {        final int CLIENT_PORT_QP1 = PortAssignment.unique();        final int CLIENT_PORT_QP2 = PortAssignment.unique();        String quorumCfgSectionServer = "server.1=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ";" + CLIENT_PORT_QP1 + "\n" + "server.2=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ";" + CLIENT_PORT_QP2 + "\n";                String quorumCfgSectionServer1 = quorumCfgSectionServer + "metricsProvider.className=" + BaseTestMetricsProvider.MetricsProviderWithErrorInStop.class.getName() + "\n";        MainThread q1 = new MainThread(1, CLIENT_PORT_QP1, quorumCfgSectionServer1);        MainThread q2 = new MainThread(2, CLIENT_PORT_QP2, quorumCfgSectionServer);        q1.start();        q2.start();        boolean isup1 = ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_QP1, 30000);        boolean isup2 = ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_QP2, 30000);        assertTrue("Server 1 never came up", isup1);        assertTrue("Server 2 never came up", isup2);        q1.shutdown();        q2.shutdown();        assertTrue("waiting for server 1 down", ClientBase.waitForServerDown("127.0.0.1:" + CLIENT_PORT_QP1, ClientBase.CONNECTION_TIMEOUT));        assertTrue("waiting for server 2 down", ClientBase.waitForServerDown("127.0.0.1:" + CLIENT_PORT_QP2, ClientBase.CONNECTION_TIMEOUT));    } finally {        qlogger.removeAppender(appender);    }    assertTrue("metrics provider lifecycle error", BaseTestMetricsProvider.MetricsProviderWithErrorInStop.stopCalled.get());    LineNumberReader r = new LineNumberReader(new StringReader(os.toString()));    String line;    boolean found = false;    Pattern p = Pattern.compile(".*Error while stopping metrics.*");    while ((line = r.readLine()) != null) {        found = p.matcher(line).matches();        if (found) {            break;        }    }    assertTrue("complains about metrics provider", found);}
testInvalidMetricsProvider
public void zookeeper_f5185_0() throws Exception
{    ClientBase.setupTestEnv();        ByteArrayOutputStream os = new ByteArrayOutputStream();    WriterAppender appender = getConsoleAppender(os, Level.WARN);    Logger qlogger = Logger.getLogger("org.apache.zookeeper.server.quorum");    qlogger.addAppender(appender);    try {        final int CLIENT_PORT_QP1 = PortAssignment.unique();        String quorumCfgSection = "server.1=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ";" + CLIENT_PORT_QP1 + "\n" + "server.2=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ";" + CLIENT_PORT_QP1 + "\n" + "metricsProvider.className=BadClass\n";        MainThread q1 = new MainThread(1, CLIENT_PORT_QP1, quorumCfgSection);        q1.start();        boolean isup = ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_QP1, 5000);        assertFalse("Server never came up", isup);        q1.shutdown();        assertTrue("waiting for server 1 down", ClientBase.waitForServerDown("127.0.0.1:" + CLIENT_PORT_QP1, ClientBase.CONNECTION_TIMEOUT));    } finally {        qlogger.removeAppender(appender);    }    LineNumberReader r = new LineNumberReader(new StringReader(os.toString()));    String line;    boolean found = false;    Pattern p = Pattern.compile(".*BadClass.*");    while ((line = r.readLine()) != null) {        found = p.matcher(line).matches();        if (found) {            break;        }    }    assertTrue("complains about metrics provider", found);}
testFaultyMetricsProviderOnStart
public void zookeeper_f5186_0() throws Exception
{    ClientBase.setupTestEnv();        ByteArrayOutputStream os = new ByteArrayOutputStream();    WriterAppender appender = getConsoleAppender(os, Level.WARN);    Logger qlogger = Logger.getLogger("org.apache.zookeeper.server.quorum");    qlogger.addAppender(appender);    try {        final int CLIENT_PORT_QP1 = PortAssignment.unique();        String quorumCfgSection = "server.1=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ";" + CLIENT_PORT_QP1 + "\n" + "server.2=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ";" + CLIENT_PORT_QP1 + "\n" + "metricsProvider.className=" + BaseTestMetricsProvider.MetricsProviderWithErrorInStart.class.getName() + "\n";        MainThread q1 = new MainThread(1, CLIENT_PORT_QP1, quorumCfgSection);        q1.start();        boolean isup = ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_QP1, 5000);        assertFalse("Server never came up", isup);        q1.shutdown();        assertTrue("waiting for server 1 down", ClientBase.waitForServerDown("127.0.0.1:" + CLIENT_PORT_QP1, ClientBase.CONNECTION_TIMEOUT));    } finally {        qlogger.removeAppender(appender);    }    LineNumberReader r = new LineNumberReader(new StringReader(os.toString()));    String line;    boolean found = false;    Pattern p = Pattern.compile(".*MetricsProviderLifeCycleException.*");    while ((line = r.readLine()) != null) {        found = p.matcher(line).matches();        if (found) {            break;        }    }    assertTrue("complains about metrics provider MetricsProviderLifeCycleException", found);}
testFaultyMetricsProviderOnConfigure
public void zookeeper_f5187_0() throws Exception
{    ClientBase.setupTestEnv();        ByteArrayOutputStream os = new ByteArrayOutputStream();    WriterAppender appender = getConsoleAppender(os, Level.WARN);    Logger qlogger = Logger.getLogger("org.apache.zookeeper.server.quorum");    qlogger.addAppender(appender);    try {        final int CLIENT_PORT_QP1 = PortAssignment.unique();        String quorumCfgSection = "server.1=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ";" + CLIENT_PORT_QP1 + "\n" + "server.2=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ";" + CLIENT_PORT_QP1 + "\n" + "metricsProvider.className=" + BaseTestMetricsProvider.MetricsProviderWithErrorInConfigure.class.getName() + "\n";        MainThread q1 = new MainThread(1, CLIENT_PORT_QP1, quorumCfgSection);        q1.start();        boolean isup = ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_QP1, 5000);        assertFalse("Server never came up", isup);        q1.shutdown();        assertTrue("waiting for server 1 down", ClientBase.waitForServerDown("127.0.0.1:" + CLIENT_PORT_QP1, ClientBase.CONNECTION_TIMEOUT));    } finally {        qlogger.removeAppender(appender);    }    LineNumberReader r = new LineNumberReader(new StringReader(os.toString()));    String line;    boolean found = false;    Pattern p = Pattern.compile(".*MetricsProviderLifeCycleException.*");    while ((line = r.readLine()) != null) {        found = p.matcher(line).matches();        if (found) {            break;        }    }    assertTrue("complains about metrics provider MetricsProviderLifeCycleException", found);}
getQuorumPeer
protected QuorumPeer zookeeper_f5188_0() throws SaslException
{    return new CustomQuorumPeer(context);}
setStartForwardingListener
public void zookeeper_f5189_0(StartForwardingListener startForwardingListener)
{    this.startForwardingListener = startForwardingListener;}
setBeginSnapshotListener
public void zookeeper_f5190_0(BeginSnapshotListener beginSnapshotListener)
{    this.beginSnapshotListener = beginSnapshotListener;}
makeFollower
protected Followerf5191_1FileTxnSnapLog logFactory) throws IOException
{    return new Follower(this, new FollowerZooKeeperServer(logFactory, this, this.getZkDb())) {        @Override        void followLeader() throws InterruptedException {            if (context.quitFollowing) {                                context.quitFollowing = false;                                return;            } else {                super.followLeader();            }        }        @Override        void writePacket(QuorumPacket pp, boolean flush) throws IOException {            if (pp != null && pp.getType() == Leader.ACK && context.exitWhenAckNewLeader) {                if (context.newLeaderAckCallback != null) {                    context.newLeaderAckCallback.start();                }            }            super.writePacket(pp, flush);        }    };}
followLeader
 voidf5192_1) throws InterruptedException
{    if (context.quitFollowing) {                context.quitFollowing = false;                return;    } else {        super.followLeader();    }}
writePacket
 void zookeeper_f5193_0(QuorumPacket pp, boolean flush) throws IOException
{    if (pp != null && pp.getType() == Leader.ACK && context.exitWhenAckNewLeader) {        if (context.newLeaderAckCallback != null) {            context.newLeaderAckCallback.start();        }    }    super.writePacket(pp, flush);}
makeLeader
protected Leader zookeeper_f5194_0(FileTxnSnapLog logFactory) throws IOException, X509Exception
{    return new Leader(this, new LeaderZooKeeperServer(logFactory, this, this.getZkDb())) {        @Override        public long startForwarding(LearnerHandler handler, long lastSeenZxid) {            if (startForwardingListener != null) {                startForwardingListener.start();            }            return super.startForwarding(handler, lastSeenZxid);        }        @Override        public LearnerSyncThrottler getLearnerSnapSyncThrottler() {            if (throttler == null) {                throttler = new LearnerSyncThrottler(getMaxConcurrentSnapSyncs(), LearnerSyncThrottler.SyncType.SNAP) {                    @Override                    public void beginSync(boolean essential) throws SyncThrottleException, InterruptedException {                        if (beginSnapshotListener != null) {                            beginSnapshotListener.start();                        }                        super.beginSync(essential);                    }                };            }            return throttler;        }    };}
startForwarding
public long zookeeper_f5195_0(LearnerHandler handler, long lastSeenZxid)
{    if (startForwardingListener != null) {        startForwardingListener.start();    }    return super.startForwarding(handler, lastSeenZxid);}
getLearnerSnapSyncThrottler
public LearnerSyncThrottler zookeeper_f5196_0()
{    if (throttler == null) {        throttler = new LearnerSyncThrottler(getMaxConcurrentSnapSyncs(), LearnerSyncThrottler.SyncType.SNAP) {            @Override            public void beginSync(boolean essential) throws SyncThrottleException, InterruptedException {                if (beginSnapshotListener != null) {                    beginSnapshotListener.start();                }                super.beginSync(essential);            }        };    }    return throttler;}
beginSync
public void zookeeper_f5197_0(boolean essential) throws SyncThrottleException, InterruptedException
{    if (beginSnapshotListener != null) {        beginSnapshotListener.start();    }    super.beginSync(essential);}
testQuorumPeerListendOnSpecifiedClientIP
public void zookeeper_f5198_0() throws IOException
{    long myId = 1;    File dataDir = ClientBase.createTmpDir();    int clientPort = PortAssignment.unique();    Map<Long, QuorumServer> peersView = new HashMap<Long, QuorumServer>();    InetAddress clientIP = InetAddress.getLoopbackAddress();    peersView.put(Long.valueOf(myId), new QuorumServer(myId, new InetSocketAddress(clientIP, PortAssignment.unique()), new InetSocketAddress(clientIP, PortAssignment.unique()), new InetSocketAddress(clientIP, clientPort), LearnerType.PARTICIPANT));    /**     * QuorumPeer constructor without QuorumVerifier     */    QuorumPeer peer1 = new QuorumPeer(peersView, dataDir, dataDir, clientPort, electionAlg, myId, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);    String hostString1 = peer1.cnxnFactory.getLocalAddress().getHostString();    assertEquals(clientIP.getHostAddress(), hostString1);        peer1.shutdown();    /**     * QuorumPeer constructor with QuorumVerifier     */    peersView.clear();    clientPort = PortAssignment.unique();    peersView.put(Long.valueOf(myId), new QuorumServer(myId, new InetSocketAddress(clientIP, PortAssignment.unique()), new InetSocketAddress(clientIP, PortAssignment.unique()), new InetSocketAddress(clientIP, clientPort), LearnerType.PARTICIPANT));    QuorumPeer peer2 = new QuorumPeer(peersView, dataDir, dataDir, clientPort, electionAlg, myId, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);    String hostString2 = peer2.cnxnFactory.getLocalAddress().getHostString();    assertEquals(clientIP.getHostAddress(), hostString2);        peer2.shutdown();}
testLocalPeerIsLeader
public void zookeeper_f5199_0() throws Exception
{    long localPeerId = 7;    QuorumPeer peer = new QuorumPeer();    peer.setId(localPeerId);    Vote voteLocalPeerIsLeader = new Vote(localPeerId, 0);    peer.setCurrentVote(voteLocalPeerIsLeader);    assertTrue(peer.isLeader(localPeerId));}
testLocalPeerIsNotLeader
public void zookeeper_f5200_0() throws Exception
{    long localPeerId = 7;    long otherPeerId = 17;    QuorumPeer peer = new QuorumPeer();    peer.setId(localPeerId);    Vote voteLocalPeerIsNotLeader = new Vote(otherPeerId, 0);    peer.setCurrentVote(voteLocalPeerIsNotLeader);    assertFalse(peer.isLeader(localPeerId));}
testIsNotLeaderBecauseNoVote
public void zookeeper_f5201_0() throws Exception
{    long localPeerId = 7;    QuorumPeer peer = new QuorumPeer();    peer.setId(localPeerId);    peer.setCurrentVote(null);    assertFalse(peer.isLeader(localPeerId));}
tearDown
public voidf5202_1) throws Exception
{    if (servers == null || servers.mt == null) {                return;    }    for (int i = 0; i < numServers; i++) {        if (i < servers.mt.length) {            servers.mt[i].shutdown();        }    }}
process
public void zookeeper_f5203_0(WatchedEvent event)
{}
shutdown
public void zookeeper_f5204_0()
{        if (quorumPeer != null) {        QuorumBase.shutdown(quorumPeer);    }}
createDynamicFile
private String zookeeper_f5205_0(String quorumCfgSection, String version) throws IOException
{    String filename = "zoo.cfg.dynamic";    if (version != null) {        filename = filename + "." + version;    }    File dynamicConfigFile = new File(tmpDir, filename);    String dynamicConfigFilename = PathUtils.normalizeFileSystemPath(dynamicConfigFile.toString());    FileWriter fDynamicConfigWriter = new FileWriter(dynamicConfigFile);    fDynamicConfigWriter.write(quorumCfgSection);    fDynamicConfigWriter.flush();    fDynamicConfigWriter.close();    return dynamicConfigFilename;}
getDynamicFiles
public File[] zookeeper_f5206_0()
{    return getFilesWithPrefix("zoo.cfg.dynamic");}
getFilesWithPrefix
public File[] zookeeper_f5207_0(final String prefix)
{    return tmpDir.listFiles(new FilenameFilter() {        @Override        public boolean accept(File dir, String name) {            return name.startsWith(prefix);        }    });}
accept
public boolean zookeeper_f5208_0(File dir, String name)
{    return name.startsWith(prefix);}
getFileByName
public File zookeeper_f5209_0(String filename)
{    File f = new File(tmpDir.getPath(), filename);    return f.isFile() ? f : null;}
writeTempDynamicConfigFile
public void zookeeper_f5210_0(String nextQuorumCfgSection, String version) throws IOException
{    File nextDynamicConfigFile = new File(tmpDir, "zoo.cfg" + QuorumPeerConfig.nextDynamicConfigFileSuffix);    FileWriter fwriter = new FileWriter(nextDynamicConfigFile);    fwriter.write(nextQuorumCfgSection + "\n" + "version=" + version);    fwriter.flush();    fwriter.close();}
start
public synchronized void zookeeper_f5211_0()
{    main = getTestQPMain();    currentThread = new Thread(this);    currentThread.start();}
getTestQPMain
public TestQPMain zookeeper_f5212_0()
{    return new TestQPMain();}
run
public voidf5213_1)
{    String[] args = new String[1];    args[0] = confFile.toString();    try {        main.initializeAndRun(args);    } catch (Exception e) {                    } finally {        currentThread = null;    }}
shutdown
public void zookeeper_f5214_0() throws InterruptedException
{    Thread t = currentThread;    if (t != null && t.isAlive()) {        main.shutdown();        t.join(500);    }}
join
public void zookeeper_f5215_0(long timeout) throws InterruptedException
{    Thread t = currentThread;    if (t != null) {        t.join(timeout);    }}
isAlive
public boolean zookeeper_f5216_0()
{    Thread t = currentThread;    return t != null && t.isAlive();}
reinitialize
public void zookeeper_f5217_0() throws IOException
{    File dataDir = main.quorumPeer.getTxnFactory().getDataDir();    ClientBase.recursiveDelete(dataDir);    ClientBase.createInitializeFile(dataDir.getParentFile());}
isQuorumPeerRunning
public boolean zookeeper_f5218_0()
{    return main.quorumPeer != null;}
getPropFromStaticFile
public String zookeeper_f5219_0(String key) throws IOException
{    Properties props = new Properties();    props.load(new FileReader(confFile));    return props.getProperty(key, "");}
getQuorumPeer
public QuorumPeer zookeeper_f5220_0()
{    return main.quorumPeer;}
deleteBaseDir
public void zookeeper_f5221_0()
{    ClientBase.recursiveDelete(baseDir);}
getMyid
public int zookeeper_f5222_0()
{    return myid;}
getClientPort
public int zookeeper_f5223_0()
{    return clientPort;}
getQuorumCfgSection
public String zookeeper_f5224_0()
{    return quorumCfgSection;}
getOtherConfigs
public Map<String, String> zookeeper_f5225_0()
{    return otherConfigs;}
getConfFile
public File zookeeper_f5226_0()
{    return confFile;}
shutDownAllServers
public void zookeeper_f5227_0() throws InterruptedException
{    for (MainThread t : mt) {        t.shutdown();    }}
restartAllServersAndClients
public void zookeeper_f5228_0(Watcher watcher) throws IOException, InterruptedException
{    for (MainThread t : mt) {        if (!t.isAlive()) {            t.start();        }    }    for (int i = 0; i < zk.length; i++) {        restartClient(i, watcher);    }}
restartClient
public void zookeeper_f5229_0(int clientIndex, Watcher watcher) throws IOException, InterruptedException
{    if (zk[clientIndex] != null) {        zk[clientIndex].close();    }    zk[clientIndex] = new ZooKeeper("127.0.0.1:" + clientPorts[clientIndex], ClientBase.CONNECTION_TIMEOUT, watcher);}
findLeader
public int zookeeper_f5230_0()
{    for (int i = 0; i < mt.length; i++) {        if (mt[i].main.quorumPeer.leader != null) {            return i;        }    }    return -1;}
LaunchServers
protected Servers zookeeper_f5231_0(int numServers) throws IOException, InterruptedException
{    return LaunchServers(numServers, null);}
LaunchServers
protected Servers zookeeper_f5232_0(int numServers, Integer tickTime) throws IOException, InterruptedException
{    int SERVER_COUNT = numServers;    QuorumPeerMainTest.Servers svrs = new QuorumPeerMainTest.Servers();    svrs.clientPorts = new int[SERVER_COUNT];    StringBuilder sb = new StringBuilder();    for (int i = 0; i < SERVER_COUNT; i++) {        svrs.clientPorts[i] = PortAssignment.unique();        sb.append("server." + i + "=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ";" + svrs.clientPorts[i] + "\n");    }    String quorumCfgSection = sb.toString();    svrs.mt = new MainThread[SERVER_COUNT];    svrs.zk = new ZooKeeper[SERVER_COUNT];    for (int i = 0; i < SERVER_COUNT; i++) {        if (tickTime != null) {            svrs.mt[i] = new MainThread(i, svrs.clientPorts[i], quorumCfgSection, new HashMap<String, String>(), tickTime);        } else {            svrs.mt[i] = new MainThread(i, svrs.clientPorts[i], quorumCfgSection);        }        svrs.mt[i].start();        svrs.restartClient(i, this);    }    waitForAll(svrs, ZooKeeper.States.CONNECTED);    return svrs;}
waitForOne
public static void zookeeper_f5233_0(ZooKeeper zk, ZooKeeper.States state) throws InterruptedException
{    int iterations = ClientBase.CONNECTION_TIMEOUT / 500;    while (zk.getState() != state) {        if (iterations-- == 0) {            throw new RuntimeException("Waiting too long " + zk.getState() + " != " + state);        }        Thread.sleep(500);    }}
waitForAll
protected void zookeeper_f5234_0(Servers servers, ZooKeeper.States state) throws InterruptedException
{    waitForAll(servers.zk, state);}
waitForAll
public static void zookeeper_f5235_0(ZooKeeper[] zks, ZooKeeper.States state) throws InterruptedException
{    int iterations = ClientBase.CONNECTION_TIMEOUT / 1000;    boolean someoneNotConnected = true;    while (someoneNotConnected) {        if (iterations-- == 0) {            logStates(zks);            ClientBase.logAllStackTraces();            throw new RuntimeException("Waiting too long");        }        someoneNotConnected = false;        for (ZooKeeper zk : zks) {            if (zk.getState() != state) {                someoneNotConnected = true;                break;            }        }        Thread.sleep(1000);    }}
logStates
public static voidf5236_1ZooKeeper[] zks)
{    StringBuilder sbBuilder = new StringBuilder("Connection States: {");    for (int i = 0; i < zks.length; i++) {        sbBuilder.append(i + " : " + zks[i].getState() + ", ");    }    sbBuilder.append('}');    }
data
public static Collection<Object[]> zookeeper_f5237_0()
{    return Arrays.asList(new Object[][] { { ServerState.LEADING }, { ServerState.FOLLOWING }, { ServerState.OBSERVING } });}
setUp
public void zookeeper_f5238_0() throws Exception
{    CountdownWatcher clientWatch = new CountdownWatcher();    super.setUp(true);    zkClient = createClient(clientWatch, getPeersMatching(serverState));    zkClient.addAuthInfo(AUTH_PROVIDER, AUTH);    clientWatch.waitForConnected(CONNECTION_TIMEOUT);}
tearDown
public void zookeeper_f5239_0() throws Exception
{    zkClient.close();    super.tearDown();}
create2EmptyNode
private Stat zookeeper_f5240_0(TestableZooKeeper zkClient, String path) throws Exception
{    Stat stat = new Stat();    zkClient.create(path, null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, stat);    return stat;}
testCreate
public void zookeeper_f5241_0() throws Exception
{    zkClient.create(PARENT_PATH, DATA, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    assertArrayEquals(String.format("%s Node created (create) with expected value", serverState), DATA, zkClient.getData(PARENT_PATH, false, null));}
testCreate2
public void zookeeper_f5242_0() throws Exception
{    zkClient.create(PARENT_PATH, DATA, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, null);    assertArrayEquals(String.format("%s Node created (create2) with expected value", serverState), DATA, zkClient.getData(PARENT_PATH, false, null));}
testDelete
public void zookeeper_f5243_0() throws Exception
{    create2EmptyNode(zkClient, PARENT_PATH);    zkClient.delete(PARENT_PATH, -1);    assertNull(String.format("%s Node no longer exists", serverState), zkClient.exists(PARENT_PATH, false));}
testExists
public void zookeeper_f5244_0() throws Exception
{    Stat stat = create2EmptyNode(zkClient, PARENT_PATH);    assertEquals(String.format("%s Exists returns correct node stat", serverState), stat, zkClient.exists(PARENT_PATH, false));}
testSetAndGetData
public void zookeeper_f5245_0() throws Exception
{    create2EmptyNode(zkClient, PARENT_PATH);    zkClient.setData(PARENT_PATH, DATA, -1);    assertArrayEquals(String.format("%s Node updated with expected value", serverState), DATA, zkClient.getData(PARENT_PATH, false, null));}
testSetAndGetACL
public void zookeeper_f5246_0() throws Exception
{    create2EmptyNode(zkClient, PARENT_PATH);    assertEquals(String.format("%s Node has open ACL", serverState), Ids.OPEN_ACL_UNSAFE, zkClient.getACL(PARENT_PATH, new Stat()));    zkClient.setACL(PARENT_PATH, Ids.READ_ACL_UNSAFE, -1);    assertEquals(String.format("%s Node has world read-only ACL", serverState), Ids.READ_ACL_UNSAFE, zkClient.getACL(PARENT_PATH, new Stat()));}
testSetAndGetChildren
public void zookeeper_f5247_0() throws Exception
{    create2EmptyNode(zkClient, PARENT_PATH);    for (String child : CHILDREN) {        create2EmptyNode(zkClient, PARENT_PATH + "/" + child);    }    assertEquals(String.format("%s Parent has expected children", serverState), CHILDREN, new HashSet<String>(zkClient.getChildren(PARENT_PATH, false)));}
testSetAndGetChildren2
public void zookeeper_f5248_0() throws Exception
{    create2EmptyNode(zkClient, PARENT_PATH);    for (String child : CHILDREN) {        create2EmptyNode(zkClient, PARENT_PATH + "/" + child);    }    assertEquals(String.format("%s Parent has expected children", serverState), CHILDREN, new HashSet<String>(zkClient.getChildren(PARENT_PATH, false, null)));}
testSync
public void zookeeper_f5249_0() throws Exception
{    complete = false;    create2EmptyNode(zkClient, PARENT_PATH);    VoidCallback onSync = new VoidCallback() {        @Override        public void processResult(int rc, String path, Object ctx) {            complete = true;            callComplete.countDown();        }    };    zkClient.sync(PARENT_PATH, onSync, null);    callComplete.await(30, TimeUnit.SECONDS);    assertTrue(String.format("%s Sync completed", serverState), complete);}
processResult
public void zookeeper_f5250_0(int rc, String path, Object ctx)
{    complete = true;    callComplete.countDown();}
testToString
public void zookeeper_f5251_0() throws ConfigException
{    String provided = ipv4config + ":participant;0.0.0.0:1237";    String expected = ipv4config + ":participant;0.0.0.0:1237";    QuorumServer qs = new QuorumServer(0, provided);    assertEquals("Use IP address", expected, qs.toString());    provided = ipv4config + ";0.0.0.0:1237";    expected = ipv4config + ":participant;0.0.0.0:1237";    qs = new QuorumServer(0, provided);    assertEquals("Type unspecified", expected, qs.toString());    provided = ipv4config + ":observer;0.0.0.0:1237";    expected = ipv4config + ":observer;0.0.0.0:1237";    qs = new QuorumServer(0, provided);    assertEquals("Observer type", expected, qs.toString());    provided = ipv4config + ":participant;1237";    expected = ipv4config + ":participant;0.0.0.0:1237";    qs = new QuorumServer(0, provided);    assertEquals("Client address unspecified", expected, qs.toString());    provided = ipv4config + ":participant;1.2.3.4:1237";    expected = ipv4config + ":participant;1.2.3.4:1237";    qs = new QuorumServer(0, provided);    assertEquals("Client address specified", expected, qs.toString());    provided = "example.com:1234:1236:participant;1237";    expected = "example.com:1234:1236:participant;0.0.0.0:1237";    qs = new QuorumServer(0, provided);    assertEquals("Use hostname", expected, qs.toString());}
constructionUnderstandsIpv6LiteralsInServerConfig
public void zookeeper_f5252_0() throws ConfigException
{    String config = "[::1]:1234:1236:participant";    QuorumServer qs = new QuorumServer(0, config);    assertEquals("[0:0:0:0:0:0:0:1]:1234:1236:participant", qs.toString());}
constructionUnderstandsIpv6LiteralsInClientConfig
public void zookeeper_f5253_0() throws ConfigException
{    String config = ipv4config + ":participant;[::1]:1237";    QuorumServer qs = new QuorumServer(0, config);    assertEquals(ipv4config + ":participant;[0:0:0:0:0:0:0:1]:1237", qs.toString());}
unbalancedIpv6LiteralsInServerConfigFailToBeParsed
public void zookeeper_f5254_0() throws ConfigException
{    new QuorumServer(0, "[::1:1234:1236:participant");}
unbalancedIpv6LiteralsInClientConfigFailToBeParsed
public void zookeeper_f5255_0() throws ConfigException
{    new QuorumServer(0, ipv4config + ":participant;[::1:1237");}
testWildcard
public void zookeeper_f5256_0() throws KeeperException.BadArgumentsException
{    String[] addrs = new String[] { "127.0.0.1", "[0:0:0:0:0:0:0:1]", "0.0.0.0", "[::]" };    for (int i = 0; i < addrs.length; i++) {        for (int j = i; j < addrs.length; j++) {            QuorumPeer.QuorumServer server1 = new             QuorumPeer.QuorumServer(            1,             new InetSocketAddress(ipv6n1, 1234),             new InetSocketAddress(ipv6n1, 1236),             new InetSocketAddress(addrs[i], 1237));            QuorumPeer.QuorumServer server2 = new             QuorumPeer.QuorumServer(            2,             new InetSocketAddress(ipv6n2, 1234),             new InetSocketAddress(ipv6n2, 1236),             new InetSocketAddress(addrs[j], 1237));            server1.checkAddressDuplicate(server2);        }    }}
testDuplicate
public void zookeeper_f5257_0() throws KeeperException.BadArgumentsException
{    QuorumPeer.QuorumServer server1 = new     QuorumPeer.QuorumServer(    1,     new InetSocketAddress(ipv6n1, 1234),     new InetSocketAddress(ipv6n1, 1236),     new InetSocketAddress(ipv6n1, 1237));    QuorumPeer.QuorumServer server2 = new     QuorumPeer.QuorumServer(    2,     new InetSocketAddress(ipv6n2, 1234),     new InetSocketAddress(ipv6n2, 1236),     new InetSocketAddress(ipv6n1, 1237));    server1.checkAddressDuplicate(server2);}
setup
public void zookeeper_f5258_0() throws Exception
{    quorumX509Util = new QuorumX509Util();    ClientBase.setupTestEnv();    tmpDir = createTmpDir().getAbsolutePath();    clientPortQp1 = PortAssignment.unique();    clientPortQp2 = PortAssignment.unique();    clientPortQp3 = PortAssignment.unique();    validKeystorePath = tmpDir + "/valid.jks";    truststorePath = tmpDir + "/truststore.jks";    quorumConfiguration = generateQuorumConfiguration();    Security.addProvider(new BouncyCastleProvider());    certStartTime = new Date();    Calendar cal = Calendar.getInstance();    cal.setTime(certStartTime);    cal.add(Calendar.YEAR, 1);    certEndTime = cal.getTime();    rootKeyPair = createKeyPair();    contentSigner = new JcaContentSignerBuilder("SHA256WithRSAEncryption").build(rootKeyPair.getPrivate());    rootCertificate = createSelfSignedCertifcate(rootKeyPair);        KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());    trustStore.load(null, PASSWORD);    trustStore.setCertificateEntry(rootCertificate.getSubjectDN().toString(), rootCertificate);    FileOutputStream outputStream = new FileOutputStream(truststorePath);    trustStore.store(outputStream, PASSWORD);    outputStream.flush();    outputStream.close();    defaultKeyPair = createKeyPair();    X509Certificate validCertificate = buildEndEntityCert(defaultKeyPair, rootCertificate, rootKeyPair.getPrivate(), HOSTNAME, "127.0.0.1", null, null);    writeKeystore(validCertificate, defaultKeyPair, validKeystorePath);    setSSLSystemProperties();}
writeKeystore
private void zookeeper_f5259_0(X509Certificate certificate, KeyPair entityKeyPair, String path) throws Exception
{    KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());    keyStore.load(null, PASSWORD);    keyStore.setKeyEntry("alias", entityKeyPair.getPrivate(), PASSWORD, new Certificate[] { certificate });    FileOutputStream outputStream = new FileOutputStream(path);    keyStore.store(outputStream, PASSWORD);    outputStream.flush();    outputStream.close();}
handle
public void zookeeper_f5260_0(com.sun.net.httpserver.HttpExchange httpExchange) throws IOException
{    byte[] responseBytes;    try {        InputStream request = httpExchange.getRequestBody();        byte[] requestBytes = new byte[10000];        request.read(requestBytes);        OCSPReq ocspRequest = new OCSPReq(requestBytes);        Req[] requestList = ocspRequest.getRequestList();        DigestCalculator digestCalculator = new JcaDigestCalculatorProviderBuilder().build().get(CertificateID.HASH_SHA1);        BasicOCSPRespBuilder responseBuilder = new JcaBasicOCSPRespBuilder(rootKeyPair.getPublic(), digestCalculator);        for (Req req : requestList) {            CertificateID certId = req.getCertID();            CertificateID revokedCertId = new JcaCertificateID(digestCalculator, rootCertificate, revokedCert.getSerialNumber());            CertificateStatus certificateStatus;            if (revokedCertId.equals(certId)) {                certificateStatus = new UnknownStatus();            } else {                certificateStatus = CertificateStatus.GOOD;            }            responseBuilder.addResponse(certId, certificateStatus, null);        }        X509CertificateHolder[] chain = new X509CertificateHolder[] { new JcaX509CertificateHolder(rootCertificate) };        ContentSigner signer = new JcaContentSignerBuilder("SHA1withRSA").setProvider("BC").build(rootKeyPair.getPrivate());        BasicOCSPResp ocspResponse = responseBuilder.build(signer, chain, Calendar.getInstance().getTime());        responseBytes = new OCSPRespBuilder().build(OCSPRespBuilder.SUCCESSFUL, ocspResponse).getEncoded();    } catch (OperatorException | CertificateEncodingException | OCSPException exception) {        responseBytes = new OCSPResp(new OCSPResponse(new OCSPResponseStatus(OCSPRespBuilder.INTERNAL_ERROR), null)).getEncoded();    }    Headers rh = httpExchange.getResponseHeaders();    rh.set("Content-Type", "application/ocsp-response");    httpExchange.sendResponseHeaders(200, responseBytes.length);    OutputStream os = httpExchange.getResponseBody();    os.write(responseBytes);    os.close();}
createSelfSignedCertifcate
private X509Certificate zookeeper_f5261_0(KeyPair keyPair) throws Exception
{    X500NameBuilder nameBuilder = new X500NameBuilder(BCStyle.INSTANCE);    nameBuilder.addRDN(BCStyle.CN, HOSTNAME);    BigInteger serialNumber = new BigInteger(128, new Random());    JcaX509v3CertificateBuilder jcaX509v3CertificateBuilder = new JcaX509v3CertificateBuilder(nameBuilder.build(), serialNumber, certStartTime, certEndTime, nameBuilder.build(), keyPair.getPublic());    X509v3CertificateBuilder certificateBuilder = jcaX509v3CertificateBuilder.addExtension(Extension.basicConstraints, true, new BasicConstraints(0)).addExtension(Extension.keyUsage, true, new KeyUsage(KeyUsage.digitalSignature | KeyUsage.keyCertSign | KeyUsage.cRLSign));    return new JcaX509CertificateConverter().getCertificate(certificateBuilder.build(contentSigner));}
buildCRL
private void zookeeper_f5262_0(X509Certificate x509Certificate, String crlPath) throws Exception
{    X509v2CRLBuilder builder = new JcaX509v2CRLBuilder(x509Certificate.getIssuerX500Principal(), certStartTime);    builder.addCRLEntry(x509Certificate.getSerialNumber(), certStartTime, CRLReason.cACompromise);    builder.setNextUpdate(certEndTime);    builder.addExtension(Extension.authorityKeyIdentifier, false, new JcaX509ExtensionUtils().createAuthorityKeyIdentifier(rootCertificate));    builder.addExtension(Extension.cRLNumber, false, new CRLNumber(new BigInteger("1000")));    X509CRLHolder cRLHolder = builder.build(contentSigner);    PemWriter pemWriter = new PemWriter(new FileWriter(crlPath));    pemWriter.writeObject(new MiscPEMGenerator(cRLHolder));    pemWriter.flush();    pemWriter.close();}
buildEndEntityCert
public X509Certificate zookeeper_f5263_0(KeyPair keyPair, X509Certificate caCert, PrivateKey caPrivateKey, String hostname, String ipAddress, String crlPath, Integer ocspPort) throws Exception
{    X509CertificateHolder holder = new JcaX509CertificateHolder(caCert);    ContentSigner signer = new JcaContentSignerBuilder("SHA256WithRSAEncryption").build(caPrivateKey);    List<GeneralName> generalNames = new ArrayList<>();    if (hostname != null) {        generalNames.add(new GeneralName(GeneralName.dNSName, hostname));    }    if (ipAddress != null) {        generalNames.add(new GeneralName(GeneralName.iPAddress, ipAddress));    }    SubjectPublicKeyInfo entityKeyInfo = SubjectPublicKeyInfoFactory.createSubjectPublicKeyInfo(PublicKeyFactory.createKey(keyPair.getPublic().getEncoded()));    X509ExtensionUtils extensionUtils = new BcX509ExtensionUtils();    JcaX509v3CertificateBuilder jcaX509v3CertificateBuilder = new JcaX509v3CertificateBuilder(holder.getSubject(), new BigInteger(128, new Random()), certStartTime, certEndTime, new X500Name("CN=Test End Entity Certificate"), keyPair.getPublic());    X509v3CertificateBuilder certificateBuilder = jcaX509v3CertificateBuilder.addExtension(Extension.authorityKeyIdentifier, false, extensionUtils.createAuthorityKeyIdentifier(holder)).addExtension(Extension.subjectKeyIdentifier, false, extensionUtils.createSubjectKeyIdentifier(entityKeyInfo)).addExtension(Extension.basicConstraints, true, new BasicConstraints(false)).addExtension(Extension.keyUsage, true, new KeyUsage(KeyUsage.digitalSignature | KeyUsage.keyEncipherment));    if (!generalNames.isEmpty()) {        certificateBuilder.addExtension(Extension.subjectAlternativeName, true, new GeneralNames(generalNames.toArray(new GeneralName[] {})));    }    if (crlPath != null) {        DistributionPointName distPointOne = new DistributionPointName(new GeneralNames(new GeneralName(GeneralName.uniformResourceIdentifier, "file://" + crlPath)));        certificateBuilder.addExtension(Extension.cRLDistributionPoints, false, new CRLDistPoint(new DistributionPoint[] { new DistributionPoint(distPointOne, null, null) }));    }    if (ocspPort != null) {        certificateBuilder.addExtension(Extension.authorityInfoAccess, false, new AuthorityInformationAccess(X509ObjectIdentifiers.ocspAccessMethod, new GeneralName(GeneralName.uniformResourceIdentifier, "http://" + hostname + ":" + ocspPort)));    }    return new JcaX509CertificateConverter().getCertificate(certificateBuilder.build(signer));}
createKeyPair
private KeyPair zookeeper_f5264_0() throws NoSuchProviderException, NoSuchAlgorithmException
{    KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("RSA", BouncyCastleProvider.PROVIDER_NAME);    keyPairGenerator.initialize(4096);    KeyPair keyPair = keyPairGenerator.genKeyPair();    return keyPair;}
generateQuorumConfiguration
private String zookeeper_f5265_0()
{    int portQp1 = PortAssignment.unique();    int portQp2 = PortAssignment.unique();    int portQp3 = PortAssignment.unique();    int portLe1 = PortAssignment.unique();    int portLe2 = PortAssignment.unique();    int portLe3 = PortAssignment.unique();    return "server.1=127.0.0.1:" + (portQp1) + ":" + (portLe1) + ";" + clientPortQp1 + "\n" + "server.2=127.0.0.1:" + (portQp2) + ":" + (portLe2) + ";" + clientPortQp2 + "\n" + "server.3=127.0.0.1:" + (portQp3) + ":" + (portLe3) + ";" + clientPortQp3;}
setSSLSystemProperties
public void zookeeper_f5266_0()
{    System.setProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY, "org.apache.zookeeper.server.NettyServerCnxnFactory");    System.setProperty(ZKClientConfig.ZOOKEEPER_CLIENT_CNXN_SOCKET, "org.apache.zookeeper.ClientCnxnSocketNetty");    System.setProperty(quorumX509Util.getSslKeystoreLocationProperty(), validKeystorePath);    System.setProperty(quorumX509Util.getSslKeystorePasswdProperty(), "testpass");    System.setProperty(quorumX509Util.getSslTruststoreLocationProperty(), truststorePath);    System.setProperty(quorumX509Util.getSslTruststorePasswdProperty(), "testpass");}
cleanUp
public void zookeeper_f5267_0() throws Exception
{    clearSSLSystemProperties();    if (q1 != null) {        q1.shutdown();    }    if (q2 != null) {        q2.shutdown();    }    if (q3 != null) {        q3.shutdown();    }    Security.removeProvider("BC");    quorumX509Util.close();}
clearSSLSystemProperties
private void zookeeper_f5268_0()
{    System.clearProperty(quorumX509Util.getSslKeystoreLocationProperty());    System.clearProperty(quorumX509Util.getSslKeystorePasswdProperty());    System.clearProperty(quorumX509Util.getSslTruststoreLocationProperty());    System.clearProperty(quorumX509Util.getSslTruststorePasswdProperty());    System.clearProperty(quorumX509Util.getSslHostnameVerificationEnabledProperty());    System.clearProperty(quorumX509Util.getSslOcspEnabledProperty());    System.clearProperty(quorumX509Util.getSslCrlEnabledProperty());    System.clearProperty(quorumX509Util.getCipherSuitesProperty());    System.clearProperty(quorumX509Util.getSslProtocolProperty());}
testQuorumSSL
public void zookeeper_f5269_0() throws Exception
{    q1 = new MainThread(1, clientPortQp1, quorumConfiguration, SSL_QUORUM_ENABLED);    q2 = new MainThread(2, clientPortQp2, quorumConfiguration, SSL_QUORUM_ENABLED);    q1.start();    q2.start();    assertTrue(ClientBase.waitForServerUp("127.0.0.1:" + clientPortQp1, CONNECTION_TIMEOUT));    assertTrue(ClientBase.waitForServerUp("127.0.0.1:" + clientPortQp2, CONNECTION_TIMEOUT));    clearSSLSystemProperties();        q3 = new MainThread(3, clientPortQp3, quorumConfiguration);    q3.start();    assertFalse(ClientBase.waitForServerUp("127.0.0.1:" + clientPortQp3, CONNECTION_TIMEOUT));}
testRollingUpgrade
public void zookeeper_f5270_0() throws Exception
{        q1 = new MainThread(1, clientPortQp1, quorumConfiguration);    q2 = new MainThread(2, clientPortQp2, quorumConfiguration);    q3 = new MainThread(3, clientPortQp3, quorumConfiguration);    Map<Integer, MainThread> members = new HashMap<>();    members.put(clientPortQp1, q1);    members.put(clientPortQp2, q2);    members.put(clientPortQp3, q3);    for (MainThread member : members.values()) {        member.start();    }    for (int clientPort : members.keySet()) {        assertTrue(ClientBase.waitForServerUp("127.0.0.1:" + clientPort, CONNECTION_TIMEOUT));    }        setSSLSystemProperties();    stopAppendConfigRestartAll(members, PORT_UNIFICATION_ENABLED);    stopAppendConfigRestartAll(members, SSL_QUORUM_ENABLED);    stopAppendConfigRestartAll(members, PORT_UNIFICATION_DISABLED);}
stopAppendConfigRestartAll
private void zookeeper_f5271_0(Map<Integer, MainThread> members, String config) throws Exception
{    for (Map.Entry<Integer, MainThread> entry : members.entrySet()) {        int clientPort = entry.getKey();        MainThread member = entry.getValue();        member.shutdown();        assertTrue(ClientBase.waitForServerDown("127.0.0.1:" + clientPort, CONNECTION_TIMEOUT));        FileWriter fileWriter = new FileWriter(member.getConfFile(), true);        fileWriter.write(config);        fileWriter.flush();        fileWriter.close();        member.start();        assertTrue(ClientBase.waitForServerUp("127.0.0.1:" + clientPort, CONNECTION_TIMEOUT));    }}
testHostnameVerificationWithInvalidHostname
public void zookeeper_f5272_0() throws Exception
{    String badhostnameKeystorePath = tmpDir + "/badhost.jks";    X509Certificate badHostCert = buildEndEntityCert(defaultKeyPair, rootCertificate, rootKeyPair.getPrivate(), "bleepbloop", null, null, null);    writeKeystore(badHostCert, defaultKeyPair, badhostnameKeystorePath);    testHostnameVerification(badhostnameKeystorePath, false);}
testHostnameVerificationWithInvalidIPAddress
public void zookeeper_f5273_0() throws Exception
{    String badhostnameKeystorePath = tmpDir + "/badhost.jks";    X509Certificate badHostCert = buildEndEntityCert(defaultKeyPair, rootCertificate, rootKeyPair.getPrivate(), null, "140.211.11.105", null, null);    writeKeystore(badHostCert, defaultKeyPair, badhostnameKeystorePath);    testHostnameVerification(badhostnameKeystorePath, false);}
testHostnameVerificationWithInvalidIpAddressAndInvalidHostname
public void zookeeper_f5274_0() throws Exception
{    String badhostnameKeystorePath = tmpDir + "/badhost.jks";    X509Certificate badHostCert = buildEndEntityCert(defaultKeyPair, rootCertificate, rootKeyPair.getPrivate(), "bleepbloop", "140.211.11.105", null, null);    writeKeystore(badHostCert, defaultKeyPair, badhostnameKeystorePath);    testHostnameVerification(badhostnameKeystorePath, false);}
testHostnameVerificationWithInvalidIpAddressAndValidHostname
public void zookeeper_f5275_0() throws Exception
{    String badhostnameKeystorePath = tmpDir + "/badhost.jks";    X509Certificate badHostCert = buildEndEntityCert(defaultKeyPair, rootCertificate, rootKeyPair.getPrivate(), "localhost", "140.211.11.105", null, null);    writeKeystore(badHostCert, defaultKeyPair, badhostnameKeystorePath);    testHostnameVerification(badhostnameKeystorePath, true);}
testHostnameVerificationWithValidIpAddressAndInvalidHostname
public void zookeeper_f5276_0() throws Exception
{    String badhostnameKeystorePath = tmpDir + "/badhost.jks";    X509Certificate badHostCert = buildEndEntityCert(defaultKeyPair, rootCertificate, rootKeyPair.getPrivate(), "bleepbloop", "127.0.0.1", null, null);    writeKeystore(badHostCert, defaultKeyPair, badhostnameKeystorePath);    testHostnameVerification(badhostnameKeystorePath, true);}
testHostnameVerification
private void zookeeper_f5277_0(String keystorePath, boolean expectSuccess) throws Exception
{    System.setProperty(quorumX509Util.getSslHostnameVerificationEnabledProperty(), "false");    q1 = new MainThread(1, clientPortQp1, quorumConfiguration, SSL_QUORUM_ENABLED);    q2 = new MainThread(2, clientPortQp2, quorumConfiguration, SSL_QUORUM_ENABLED);    q1.start();    q2.start();    assertTrue(ClientBase.waitForServerUp("127.0.0.1:" + clientPortQp1, CONNECTION_TIMEOUT));    assertTrue(ClientBase.waitForServerUp("127.0.0.1:" + clientPortQp2, CONNECTION_TIMEOUT));    System.setProperty(quorumX509Util.getSslKeystoreLocationProperty(), keystorePath);        q3 = new MainThread(3, clientPortQp3, quorumConfiguration, SSL_QUORUM_ENABLED);    q3.start();    assertTrue(ClientBase.waitForServerUp("127.0.0.1:" + clientPortQp3, CONNECTION_TIMEOUT));    q1.shutdown();    q2.shutdown();    q3.shutdown();    assertTrue(ClientBase.waitForServerDown("127.0.0.1:" + clientPortQp1, CONNECTION_TIMEOUT));    assertTrue(ClientBase.waitForServerDown("127.0.0.1:" + clientPortQp2, CONNECTION_TIMEOUT));    assertTrue(ClientBase.waitForServerDown("127.0.0.1:" + clientPortQp3, CONNECTION_TIMEOUT));    setSSLSystemProperties();    System.clearProperty(quorumX509Util.getSslHostnameVerificationEnabledProperty());    q1.start();    q2.start();    assertTrue(ClientBase.waitForServerUp("127.0.0.1:" + clientPortQp1, CONNECTION_TIMEOUT));    assertTrue(ClientBase.waitForServerUp("127.0.0.1:" + clientPortQp2, CONNECTION_TIMEOUT));    System.setProperty(quorumX509Util.getSslKeystoreLocationProperty(), keystorePath);    q3.start();    assertEquals(expectSuccess, ClientBase.waitForServerUp("127.0.0.1:" + clientPortQp3, CONNECTION_TIMEOUT));}
testCertificateRevocationList
public void zookeeper_f5278_0() throws Exception
{    q1 = new MainThread(1, clientPortQp1, quorumConfiguration, SSL_QUORUM_ENABLED);    q2 = new MainThread(2, clientPortQp2, quorumConfiguration, SSL_QUORUM_ENABLED);    q1.start();    q2.start();    assertTrue(ClientBase.waitForServerUp("127.0.0.1:" + clientPortQp1, CONNECTION_TIMEOUT));    assertTrue(ClientBase.waitForServerUp("127.0.0.1:" + clientPortQp2, CONNECTION_TIMEOUT));    String revokedInCRLKeystorePath = tmpDir + "/crl_revoked.jks";    String crlPath = tmpDir + "/crl.pem";    X509Certificate revokedInCRLCert = buildEndEntityCert(defaultKeyPair, rootCertificate, rootKeyPair.getPrivate(), HOSTNAME, null, crlPath, null);    writeKeystore(revokedInCRLCert, defaultKeyPair, revokedInCRLKeystorePath);    buildCRL(revokedInCRLCert, crlPath);    System.setProperty(quorumX509Util.getSslKeystoreLocationProperty(), revokedInCRLKeystorePath);        q3 = new MainThread(3, clientPortQp3, quorumConfiguration, SSL_QUORUM_ENABLED);    q3.start();    assertTrue(ClientBase.waitForServerUp("127.0.0.1:" + clientPortQp3, CONNECTION_TIMEOUT));    q1.shutdown();    q2.shutdown();    q3.shutdown();    assertTrue(ClientBase.waitForServerDown("127.0.0.1:" + clientPortQp1, CONNECTION_TIMEOUT));    assertTrue(ClientBase.waitForServerDown("127.0.0.1:" + clientPortQp2, CONNECTION_TIMEOUT));    assertTrue(ClientBase.waitForServerDown("127.0.0.1:" + clientPortQp3, CONNECTION_TIMEOUT));    setSSLSystemProperties();    System.setProperty(quorumX509Util.getSslCrlEnabledProperty(), "true");    X509Certificate validCertificate = buildEndEntityCert(defaultKeyPair, rootCertificate, rootKeyPair.getPrivate(), HOSTNAME, null, crlPath, null);    writeKeystore(validCertificate, defaultKeyPair, validKeystorePath);    q1.start();    q2.start();    assertTrue(ClientBase.waitForServerUp("127.0.0.1:" + clientPortQp1, CONNECTION_TIMEOUT));    assertTrue(ClientBase.waitForServerUp("127.0.0.1:" + clientPortQp2, CONNECTION_TIMEOUT));    System.setProperty(quorumX509Util.getSslKeystoreLocationProperty(), revokedInCRLKeystorePath);    q3.start();    assertFalse(ClientBase.waitForServerUp("127.0.0.1:" + clientPortQp3, CONNECTION_TIMEOUT));}
testOCSP
public void zookeeper_f5279_0() throws Exception
{    Integer ocspPort = PortAssignment.unique();    q1 = new MainThread(1, clientPortQp1, quorumConfiguration, SSL_QUORUM_ENABLED);    q2 = new MainThread(2, clientPortQp2, quorumConfiguration, SSL_QUORUM_ENABLED);    q1.start();    q2.start();    assertTrue(ClientBase.waitForServerUp("127.0.0.1:" + clientPortQp1, CONNECTION_TIMEOUT));    assertTrue(ClientBase.waitForServerUp("127.0.0.1:" + clientPortQp2, CONNECTION_TIMEOUT));    String revokedInOCSPKeystorePath = tmpDir + "/ocsp_revoked.jks";    X509Certificate revokedInOCSPCert = buildEndEntityCert(defaultKeyPair, rootCertificate, rootKeyPair.getPrivate(), HOSTNAME, null, null, ocspPort);    writeKeystore(revokedInOCSPCert, defaultKeyPair, revokedInOCSPKeystorePath);    HttpServer ocspServer = HttpServer.create(new InetSocketAddress(ocspPort), 0);    try {        ocspServer.createContext("/", new OCSPHandler(revokedInOCSPCert));        ocspServer.start();        System.setProperty(quorumX509Util.getSslKeystoreLocationProperty(), revokedInOCSPKeystorePath);                q3 = new MainThread(3, clientPortQp3, quorumConfiguration, SSL_QUORUM_ENABLED);        q3.start();        assertTrue(ClientBase.waitForServerUp("127.0.0.1:" + clientPortQp3, CONNECTION_TIMEOUT));        q1.shutdown();        q2.shutdown();        q3.shutdown();        assertTrue(ClientBase.waitForServerDown("127.0.0.1:" + clientPortQp1, CONNECTION_TIMEOUT));        assertTrue(ClientBase.waitForServerDown("127.0.0.1:" + clientPortQp2, CONNECTION_TIMEOUT));        assertTrue(ClientBase.waitForServerDown("127.0.0.1:" + clientPortQp3, CONNECTION_TIMEOUT));        setSSLSystemProperties();        System.setProperty(quorumX509Util.getSslOcspEnabledProperty(), "true");        X509Certificate validCertificate = buildEndEntityCert(defaultKeyPair, rootCertificate, rootKeyPair.getPrivate(), HOSTNAME, null, null, ocspPort);        writeKeystore(validCertificate, defaultKeyPair, validKeystorePath);        q1.start();        q2.start();        assertTrue(ClientBase.waitForServerUp("127.0.0.1:" + clientPortQp1, CONNECTION_TIMEOUT));        assertTrue(ClientBase.waitForServerUp("127.0.0.1:" + clientPortQp2, CONNECTION_TIMEOUT));        System.setProperty(quorumX509Util.getSslKeystoreLocationProperty(), revokedInOCSPKeystorePath);        q3.start();        assertFalse(ClientBase.waitForServerUp("127.0.0.1:" + clientPortQp3, CONNECTION_TIMEOUT));    } finally {        ocspServer.stop(0);    }}
testCipherSuites
public void zookeeper_f5280_0() throws Exception
{        SSLServerSocketFactory ssf = (SSLServerSocketFactory) SSLServerSocketFactory.getDefault();    List<String> defaultCiphers = new ArrayList<String>();    for (String cipher : ssf.getDefaultCipherSuites()) {        if (!cipher.matches(".*EMPTY.*") && cipher.startsWith("TLS") && cipher.contains("RSA")) {            defaultCiphers.add(cipher);        }    }    if (defaultCiphers.size() < 2) {        fail("JDK has to support at least 2 valid (RSA) cipher suites for this test to run");    }        String suitesOfEnsemble = String.join(",", defaultCiphers.subList(1, defaultCiphers.size()));    System.setProperty(quorumX509Util.getCipherSuitesProperty(), suitesOfEnsemble);    q1 = new MainThread(1, clientPortQp1, quorumConfiguration, SSL_QUORUM_ENABLED);    q2 = new MainThread(2, clientPortQp2, quorumConfiguration, SSL_QUORUM_ENABLED);    q1.start();    q2.start();    assertTrue(ClientBase.waitForServerUp("127.0.0.1:" + clientPortQp1, CONNECTION_TIMEOUT));    assertTrue(ClientBase.waitForServerUp("127.0.0.1:" + clientPortQp2, CONNECTION_TIMEOUT));        String suiteOfClient = defaultCiphers.get(0);    System.setProperty(quorumX509Util.getCipherSuitesProperty(), suiteOfClient);            q3 = new MainThread(3, clientPortQp3, quorumConfiguration, SSL_QUORUM_ENABLED);    q3.start();    assertFalse(ClientBase.waitForServerUp("127.0.0.1:" + clientPortQp3, CONNECTION_TIMEOUT));}
testProtocolVersion
public void zookeeper_f5281_0() throws Exception
{    System.setProperty(quorumX509Util.getSslProtocolProperty(), "TLSv1.2");    q1 = new MainThread(1, clientPortQp1, quorumConfiguration, SSL_QUORUM_ENABLED);    q2 = new MainThread(2, clientPortQp2, quorumConfiguration, SSL_QUORUM_ENABLED);    q1.start();    q2.start();    assertTrue(ClientBase.waitForServerUp("127.0.0.1:" + clientPortQp1, CONNECTION_TIMEOUT));    assertTrue(ClientBase.waitForServerUp("127.0.0.1:" + clientPortQp2, CONNECTION_TIMEOUT));    System.setProperty(quorumX509Util.getSslProtocolProperty(), "TLSv1.1");        q3 = new MainThread(3, clientPortQp3, quorumConfiguration, SSL_QUORUM_ENABLED);    q3.start();    assertFalse(ClientBase.waitForServerUp("127.0.0.1:" + clientPortQp3, CONNECTION_TIMEOUT));}
testRaceConditionBetweenLeaderAndAckRequestProcessor
public void zookeeper_f5282_0() throws Exception
{    mt = startQuorum();        QuorumPeer leader = getLeader(mt);    long oldLeaderCurrentEpoch = leader.getCurrentEpoch();    assertNotNull("Leader should not be null", leader);            shutdownFollowers(mt);    /**     * <pre>     * Verify that there is no deadlock in following ways:     * 1) If leader is in LOOKING or FOLLOWING, we are sure there is no deadlock.     * 2) If leader in in LEADING state then we have to check that this LEADING state is     * after the leader election, not the old LEADING state.     * </pre>     */    boolean leaderStateChanged = ClientBase.waitForServerState(leader, 15000, QuorumStats.Provider.LOOKING_STATE, QuorumStats.Provider.FOLLOWING_STATE);        assertTrue("Failed to bring up the old leader server", ClientBase.waitForServerUp("127.0.0.1:" + leader.getClientPort(), CONNECTION_TIMEOUT));    assertTrue("Leader failed to transition to new state. Current state is " + leader.getServerState(), leaderStateChanged || (leader.getCurrentEpoch() > oldLeaderCurrentEpoch));}
tearDown
public voidf5283_1)
{        if (null != mt) {        for (int i = 0; i < SERVER_COUNT; i++) {            try {                                                mt[i].shutdown();            } catch (InterruptedException e) {                            }        }    }}
startQuorum
private MainThread[] zookeeper_f5284_0() throws IOException
{    final int[] clientPorts = new int[SERVER_COUNT];    StringBuilder sb = new StringBuilder();    String server;    for (int i = 0; i < SERVER_COUNT; i++) {        clientPorts[i] = PortAssignment.unique();        server = "server." + i + "=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ":participant;127.0.0.1:" + clientPorts[i];        sb.append(server + "\n");    }    String currentQuorumCfgSection = sb.toString();    MainThread[] mt = new MainThread[SERVER_COUNT];        for (int i = 0; i < SERVER_COUNT; i++) {        mt[i] = new MainThread(i, clientPorts[i], currentQuorumCfgSection, false) {            @Override            public TestQPMain getTestQPMain() {                return new MockTestQPMain();            }        };        mt[i].start();    }        for (int i = 0; i < SERVER_COUNT; i++) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts[i], CONNECTION_TIMEOUT));    }    return mt;}
getTestQPMain
public TestQPMain zookeeper_f5285_0()
{    return new MockTestQPMain();}
getLeader
private QuorumPeer zookeeper_f5286_0(MainThread[] mt)
{    for (int i = mt.length - 1; i >= 0; i--) {        QuorumPeer quorumPeer = mt[i].getQuorumPeer();        if (quorumPeer != null && ServerState.LEADING == quorumPeer.getPeerState()) {            return quorumPeer;        }    }    return null;}
shutdownFollowers
private void zookeeper_f5287_0(MainThread[] mt)
{    for (int i = 0; i < mt.length; i++) {        CustomQuorumPeer quorumPeer = (CustomQuorumPeer) mt[i].getQuorumPeer();        if (quorumPeer != null && ServerState.FOLLOWING == quorumPeer.getPeerState()) {            quorumPeer.setStopPing(true);        }    }}
setStopPing
public void zookeeper_f5288_0(boolean stopPing)
{    this.stopPing = stopPing;}
makeFollower
protected Followerf5289_1FileTxnSnapLog logFactory) throws IOException
{    return new Follower(this, new FollowerZooKeeperServer(logFactory, this, this.getZkDb())) {        @Override        protected void processPacket(QuorumPacket qp) throws Exception {            if (stopPing && qp.getType() == Leader.PING) {                                throw new SocketException("Socket time out while sending the ping response");            } else {                super.processPacket(qp);            }        }    };}
processPacket
protected voidf5290_1QuorumPacket qp) throws Exception
{    if (stopPing && qp.getType() == Leader.PING) {                throw new SocketException("Socket time out while sending the ping response");    } else {        super.processPacket(qp);    }}
makeLeader
protected Leader zookeeper_f5291_0(FileTxnSnapLog logFactory) throws IOException, X509Exception
{    LeaderZooKeeperServer zk = new LeaderZooKeeperServer(logFactory, this, this.getZkDb()) {        @Override        protected void setupRequestProcessors() {            /**             * This method is overridden to make a place to inject             * MockSyncRequestProcessor             */            RequestProcessor finalProcessor = new FinalRequestProcessor(this);            RequestProcessor toBeAppliedProcessor = new Leader.ToBeAppliedRequestProcessor(finalProcessor, getLeader());            commitProcessor = new CommitProcessor(toBeAppliedProcessor, Long.toString(getServerId()), false, getZooKeeperServerListener());            commitProcessor.start();            ProposalRequestProcessor proposalProcessor = new MockProposalRequestProcessor(this, commitProcessor);            proposalProcessor.initialize();            prepRequestProcessor = new PrepRequestProcessor(this, proposalProcessor);            prepRequestProcessor.start();            firstProcessor = new LeaderRequestProcessor(this, prepRequestProcessor);        }    };    return new Leader(this, zk);}
setupRequestProcessors
protected void zookeeper_f5292_0()
{    /**     * This method is overridden to make a place to inject     * MockSyncRequestProcessor     */    RequestProcessor finalProcessor = new FinalRequestProcessor(this);    RequestProcessor toBeAppliedProcessor = new Leader.ToBeAppliedRequestProcessor(finalProcessor, getLeader());    commitProcessor = new CommitProcessor(toBeAppliedProcessor, Long.toString(getServerId()), false, getZooKeeperServerListener());    commitProcessor.start();    ProposalRequestProcessor proposalProcessor = new MockProposalRequestProcessor(this, commitProcessor);    proposalProcessor.initialize();    prepRequestProcessor = new PrepRequestProcessor(this, proposalProcessor);    prepRequestProcessor.start();    firstProcessor = new LeaderRequestProcessor(this, prepRequestProcessor);}
shutdown
public void zookeeper_f5293_0()
{    /**     * Add a request so that something is there for SyncRequestProcessor     * to process, while we are in shutdown flow     */    Request request = new Request(null, 0, 0, ZooDefs.OpCode.delete, ByteBuffer.wrap("/deadLockIssue".getBytes()), null);    processRequest(request);    super.shutdown();}
getQuorumPeer
protected QuorumPeer zookeeper_f5294_0() throws SaslException
{    return new CustomQuorumPeer();}
getVersionFromConfigStr
public static String zookeeper_f5295_0(String config) throws IOException
{    Properties props = new Properties();    props.load(new StringReader(config));    return props.getProperty("version", "");}
getFileContent
public static String zookeeper_f5296_0(File file) throws FileNotFoundException
{    Scanner sc = new Scanner(file);    StringBuilder sb = new StringBuilder();    while (sc.hasNextLine()) {        sb.append(sc.nextLine() + "\n");    }    return sb.toString();}
setup
public void zookeeper_f5297_0()
{    ClientBase.setupTestEnv();    System.setProperty("zookeeper.DigestAuthenticationProvider.superDigest", "super:D/InIHSb7yEEbrWz8b9l71RjZJU=");}
testBackupStatic
public void zookeeper_f5298_0() throws Exception
{    final int SERVER_COUNT = 3;    final int[] clientPorts = new int[SERVER_COUNT];    StringBuilder sb = new StringBuilder();    String server;    for (int i = 0; i < SERVER_COUNT; i++) {        clientPorts[i] = PortAssignment.unique();        server = "server." + i + "=localhost:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ":participant;localhost:" + clientPorts[i];        sb.append(server + "\n");    }    String currentQuorumCfgSection = sb.toString();    MainThread[] mt = new MainThread[SERVER_COUNT];    String[] staticFileContent = new String[SERVER_COUNT];    String[] staticBackupContent = new String[SERVER_COUNT];    for (int i = 0; i < SERVER_COUNT; i++) {        mt[i] = new MainThread(i, clientPorts[i], currentQuorumCfgSection, false);                assertNull("static file backup shouldn't exist before bootup", mt[i].getFileByName("zoo.cfg.bak"));        staticFileContent[i] = getFileContent(mt[i].confFile);        mt[i].start();    }    for (int i = 0; i < SERVER_COUNT; i++) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts[i], CONNECTION_TIMEOUT));        File backupFile = mt[i].getFileByName("zoo.cfg.bak");        assertNotNull("static file backup should exist", backupFile);        staticBackupContent[i] = getFileContent(backupFile);        assertEquals(staticFileContent[i], staticBackupContent[i]);    }    for (int i = 0; i < SERVER_COUNT; i++) {        mt[i].shutdown();    }}
testReconfigCreateNewVersionFile
public void zookeeper_f5299_0() throws Exception
{    final int SERVER_COUNT = 3;    final int NEW_SERVER_COUNT = 5;    final int[] clientPorts = new int[NEW_SERVER_COUNT];    final int[] quorumPorts = new int[NEW_SERVER_COUNT];    final int[] electionPorts = new int[NEW_SERVER_COUNT];    final String[] servers = new String[NEW_SERVER_COUNT];    StringBuilder sb = new StringBuilder();    ArrayList<String> oldServers = new ArrayList<String>();    ArrayList<String> newServers = new ArrayList<String>();    for (int i = 0; i < NEW_SERVER_COUNT; i++) {        clientPorts[i] = PortAssignment.unique();        quorumPorts[i] = PortAssignment.unique();        electionPorts[i] = PortAssignment.unique();        servers[i] = "server." + i + "=localhost:" + quorumPorts[i] + ":" + electionPorts[i] + ":participant;localhost:" + clientPorts[i];        newServers.add(servers[i]);        if (i >= SERVER_COUNT) {            continue;        }        oldServers.add(servers[i]);        sb.append(servers[i] + "\n");    }    String quorumCfgSection = sb.toString();    MainThread[] mt = new MainThread[NEW_SERVER_COUNT];    ZooKeeper[] zk = new ZooKeeper[NEW_SERVER_COUNT];    ZooKeeperAdmin[] zkAdmin = new ZooKeeperAdmin[NEW_SERVER_COUNT];        for (int i = 0; i < SERVER_COUNT; i++) {        mt[i] = new MainThread(i, clientPorts[i], quorumCfgSection, "reconfigEnabled=true\n");        mt[i].start();    }    String firstVersion = null, secondVersion = null;        for (int i = 0; i < SERVER_COUNT; i++) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts[i], CONNECTION_TIMEOUT));        zk[i] = ClientBase.createZKClient("127.0.0.1:" + clientPorts[i]);        zkAdmin[i] = new ZooKeeperAdmin("127.0.0.1:" + clientPorts[i], ClientBase.CONNECTION_TIMEOUT, this);        zkAdmin[i].addAuthInfo("digest", "super:test".getBytes());        Properties cfg = ReconfigLegacyTest.readPropertiesFromFile(mt[i].confFile);        String filename = cfg.getProperty("dynamicConfigFile", "");        String version = QuorumPeerConfig.getVersionFromFilename(filename);        assertNotNull(version);        String configStr = ReconfigTest.testServerHasConfig(zk[i], oldServers, null);        String configVersion = getVersionFromConfigStr(configStr);                        assertEquals(version, configVersion);        if (i == 0) {            firstVersion = version;        } else {            assertEquals(firstVersion, version);        }    }    ReconfigTest.reconfig(zkAdmin[1], null, null, newServers, -1);        for (int i = SERVER_COUNT; i < NEW_SERVER_COUNT; i++) {        mt[i] = new MainThread(i, clientPorts[i], quorumCfgSection + servers[i]);        mt[i].start();    }        for (int i = SERVER_COUNT; i < NEW_SERVER_COUNT; i++) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts[i], CONNECTION_TIMEOUT));        zk[i] = ClientBase.createZKClient("127.0.0.1:" + clientPorts[i]);    }        for (int i = 0; i < NEW_SERVER_COUNT; i++) {        Properties cfg = ReconfigLegacyTest.readPropertiesFromFile(mt[i].confFile);        String filename = cfg.getProperty("dynamicConfigFile", "");        String version = QuorumPeerConfig.getVersionFromFilename(filename);        assertNotNull(version);        String configStr = ReconfigTest.testServerHasConfig(zk[i], newServers, null);        String quorumVersion = getVersionFromConfigStr(configStr);        assertEquals(version, quorumVersion);        if (i == 0) {            secondVersion = version;            assertTrue(Long.parseLong(secondVersion, 16) > Long.parseLong(firstVersion, 16));        } else {            assertEquals(secondVersion, version);        }    }    for (int i = 0; i < SERVER_COUNT; i++) {        mt[i].shutdown();        zk[i].close();        zkAdmin[i].close();    }}
testVersionOfDynamicFilename
public void zookeeper_f5300_0() throws Exception
{    final int SERVER_COUNT = 5;    final int oldServerCount = 3;    final int lagOffServerId = 0;    final int[] clientPorts = new int[SERVER_COUNT];    StringBuilder sb = new StringBuilder();    String server;    StringBuilder oldSb = new StringBuilder();    ArrayList<String> allServers = new ArrayList<String>();    for (int i = 0; i < SERVER_COUNT; i++) {        clientPorts[i] = PortAssignment.unique();        server = "server." + i + "=localhost:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ":participant;localhost:" + clientPorts[i];        sb.append(server + "\n");        allServers.add(server);        if (i < oldServerCount) {                        oldSb.append(server + "\n");        }    }    String currentQuorumCfgSection = sb.toString();    String oldQuorumCfg = oldSb.toString();    MainThread[] mt = new MainThread[SERVER_COUNT];    for (int i = 0; i < SERVER_COUNT; i++) {        if (i == lagOffServerId) {            mt[i] = new MainThread(i, clientPorts[i], oldQuorumCfg, true, "100000000");        } else {            mt[i] = new MainThread(i, clientPorts[i], currentQuorumCfgSection, true, "200000000");        }                if (i == lagOffServerId) {            assertNotNull(mt[i].getFileByName("zoo.cfg.dynamic.100000000"));            assertNull(mt[i].getFileByName("zoo.cfg.dynamic.200000000"));            assertTrue(mt[i].getPropFromStaticFile("dynamicConfigFile").endsWith(".100000000"));        } else {            assertNotNull(mt[i].getFileByName("zoo.cfg.dynamic.200000000"));            assertTrue(mt[i].getPropFromStaticFile("dynamicConfigFile").endsWith(".200000000"));        }        mt[i].start();    }    String dynamicFileContent = null;    for (int i = 0; i < SERVER_COUNT; i++) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts[i], CONNECTION_TIMEOUT));        ZooKeeper zk = ClientBase.createZKClient("127.0.0.1:" + clientPorts[i]);                        String configStr = ReconfigTest.testServerHasConfig(zk, allServers, null);        assertEquals("200000000", getVersionFromConfigStr(configStr));        List<String> configLines = Arrays.asList(configStr.split("\n"));        Collections.sort(configLines);        String sortedConfigStr = StringUtils.joinStrings(configLines, "\n");        File dynamicConfigFile = mt[i].getFileByName("zoo.cfg.dynamic.200000000");        assertNotNull(dynamicConfigFile);                if (i == 0) {            dynamicFileContent = getFileContent(dynamicConfigFile);            assertEquals(sortedConfigStr, dynamicFileContent + "version=200000000");        } else {            String otherDynamicFileContent = getFileContent(dynamicConfigFile);            assertEquals(dynamicFileContent, otherDynamicFileContent);        }        zk.close();    }            assertTrue(mt[lagOffServerId].getPropFromStaticFile("dynamicConfigFile").endsWith(".200000000"));    for (int i = 0; i < SERVER_COUNT; i++) {        mt[i].shutdown();    }}
setup
public void zookeeper_f5301_0()
{    System.setProperty("zookeeper.DigestAuthenticationProvider.superDigest", "super:D/InIHSb7yEEbrWz8b9l71RjZJU=");    QuorumPeerConfig.setReconfigEnabled(true);}
testDuringLeaderSync
public void zookeeper_f5302_0() throws Exception
{    final int[] clientPorts = new int[SERVER_COUNT + 1];    StringBuilder sb = new StringBuilder();    String[] serverConfig = new String[SERVER_COUNT + 1];    for (int i = 0; i < SERVER_COUNT; i++) {        clientPorts[i] = PortAssignment.unique();        serverConfig[i] = "server." + i + "=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ":participant;127.0.0.1:" + clientPorts[i];        sb.append(serverConfig[i] + "\n");    }    String currentQuorumCfgSection = sb.toString();    mt = new MainThread[SERVER_COUNT + 1];        for (int i = 0; i < SERVER_COUNT; i++) {        mt[i] = new MainThread(i, clientPorts[i], currentQuorumCfgSection, false);        mt[i].start();    }        for (int i = 0; i < SERVER_COUNT; i++) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts[i], CONNECTION_TIMEOUT));    }    CountdownWatcher watch = new CountdownWatcher();    ZooKeeperAdmin preReconfigClient = new ZooKeeperAdmin("127.0.0.1:" + clientPorts[0], ClientBase.CONNECTION_TIMEOUT, watch);    preReconfigClient.addAuthInfo("digest", "super:test".getBytes());    watch.waitForConnected(ClientBase.CONNECTION_TIMEOUT);        int joinerId = SERVER_COUNT;    clientPorts[joinerId] = PortAssignment.unique();    serverConfig[joinerId] = "server." + joinerId + "=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ":participant;127.0.0.1:" + clientPorts[joinerId];        int leaderId = -1;    for (int i = 0; i < SERVER_COUNT; i++) {        if (mt[i].main.quorumPeer.leader != null) {            leaderId = i;            break;        }    }    assertFalse(leaderId == -1);        sb = new StringBuilder();    sb.append(serverConfig[leaderId] + "\n").append(serverConfig[joinerId] + "\n");    /**     * This server will delay the response to a NEWLEADER message, and run     * reconfig command so that message at this processed in bellow order     *     * <pre>     * NEWLEADER     * reconfig's PROPOSAL     * reconfig's COMMITANDACTIVATE     * UPTODATE     * </pre>     */    mt[joinerId] = new MainThread(joinerId, clientPorts[joinerId], sb.toString(), false) {        @Override        public TestQPMain getTestQPMain() {            return new MockTestQPMain();        }    };    mt[joinerId].start();    CustomQuorumPeer qp = getCustomQuorumPeer(mt[joinerId]);        String nextDynamicConfigFilename = qp.getNextDynamicConfigFilename();    File nextDynaFile = new File(nextDynamicConfigFilename);    nextDynaFile.delete();        while (true) {        if (qp.isNewLeaderMessage()) {            preReconfigClient.reconfigure(serverConfig[joinerId], null, null, -1, null, null);            break;        } else {                        Thread.sleep(10);        }    }    watch = new CountdownWatcher();    ZooKeeper postReconfigClient = new ZooKeeper("127.0.0.1:" + clientPorts[joinerId], ClientBase.CONNECTION_TIMEOUT, watch);    watch.waitForConnected(ClientBase.CONNECTION_TIMEOUT);        postReconfigClient.create("/reconfigIssue", "".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    assertFalse("zoo.cfg.dynamic.next is not deleted.", nextDynaFile.exists());        for (long j = 0; j <= SERVER_COUNT; j++) {        assertNotNull("server " + j + " is not present in the new quorum", qp.getQuorumVerifier().getVotingMembers().get(j));    }        preReconfigClient.close();    postReconfigClient.close();}
getTestQPMain
public TestQPMain zookeeper_f5303_0()
{    return new MockTestQPMain();}
getCustomQuorumPeer
private static CustomQuorumPeer zookeeper_f5304_0(MainThread mt)
{    while (true) {        QuorumPeer quorumPeer = mt.getQuorumPeer();        if (null != quorumPeer) {            return (CustomQuorumPeer) quorumPeer;        } else {            try {                Thread.sleep(10);            } catch (InterruptedException e) {                e.printStackTrace();            }        }    }}
tearDown
public voidf5305_1)
{        if (null != mt) {        for (int i = 0; i < mt.length; i++) {            try {                mt[i].shutdown();            } catch (InterruptedException e) {                            }        }    }}
isNewLeaderMessage
public boolean zookeeper_f5306_0()
{    return newLeaderMessage;}
makeFollower
protected Follower zookeeper_f5307_0(FileTxnSnapLog logFactory) throws IOException
{    return new Follower(this, new FollowerZooKeeperServer(logFactory, this, this.getZkDb())) {        @Override        void writePacket(QuorumPacket pp, boolean flush) throws IOException {            if (pp != null && pp.getType() == Leader.ACK) {                newLeaderMessage = true;                try {                    /**                     * Delaying the ACK message, a follower sends as                     * response to a NEWLEADER message, so that the                     * leader has a chance to send the reconfig and only                     * then the UPTODATE message.                     */                    Thread.sleep(100);                } catch (InterruptedException e) {                    e.printStackTrace();                }            }            super.writePacket(pp, flush);        }    };}
writePacket
 void zookeeper_f5308_0(QuorumPacket pp, boolean flush) throws IOException
{    if (pp != null && pp.getType() == Leader.ACK) {        newLeaderMessage = true;        try {            /**             * Delaying the ACK message, a follower sends as             * response to a NEWLEADER message, so that the             * leader has a chance to send the reconfig and only             * then the UPTODATE message.             */            Thread.sleep(100);        } catch (InterruptedException e) {            e.printStackTrace();        }    }    super.writePacket(pp, flush);}
runFromConfig
public voidf5309_1QuorumPeerConfig config) throws IOException, AdminServerException
{    quorumPeer = new CustomQuorumPeer(config.getQuorumVerifier().getAllMembers(), config.getDataDir(), config.getDataLogDir(), config.getClientPortAddress().getPort(), config.getElectionAlg(), config.getServerId(), config.getTickTime(), config.getInitLimit(), config.getSyncLimit(), config.getConnectToLearnerMasterLimit());    quorumPeer.setConfigFileName(config.getConfigFilename());    quorumPeer.start();    try {        quorumPeer.join();    } catch (InterruptedException e) {            }}
setup
public void zookeeper_f5310_0()
{    QuorumPeerConfig.setReconfigEnabled(true);    System.setProperty("zookeeper.DigestAuthenticationProvider.superDigest", "super:D/InIHSb7yEEbrWz8b9l71RjZJU=");}
tearDown
public void zookeeper_f5311_0() throws Exception
{    if (qu != null) {        qu.tearDown();    }}
testIncrementalReconfigInvokedOnHiearchicalQS
public void zookeeper_f5312_0() throws Exception
{        qu = new QuorumUtil(2);    qu.disableJMXTest = true;    qu.startAll();    ZooKeeper[] zkArr = ReconfigTest.createHandles(qu);    ZooKeeperAdmin[] zkAdminArr = ReconfigTest.createAdminHandles(qu);    ArrayList<String> members = new ArrayList<String>();    members.add("group.1=3:4:5");    members.add("group.2=1:2");    members.add("weight.1=0");    members.add("weight.2=0");    members.add("weight.3=1");    members.add("weight.4=1");    members.add("weight.5=1");    for (int i = 1; i <= 5; i++) {        members.add("server." + i + "=127.0.0.1:" + qu.getPeer(i).peer.getQuorumAddress().getPort() + ":" + qu.getPeer(i).peer.getElectionAddress().getPort() + ";" + "127.0.0.1:" + qu.getPeer(i).peer.getClientPort());    }        ReconfigTest.reconfig(zkAdminArr[1], null, null, members, -1);    ReconfigTest.testNormalOperation(zkArr[1], zkArr[2]);        List<String> leavingServers = new ArrayList<String>();    leavingServers.add("3");    try {        zkAdminArr[1].reconfigure(null, leavingServers, null, -1, null);        fail("Reconfig should have failed since the current config isn't Majority QS");    } catch (KeeperException.BadArgumentsException e) {        } catch (Exception e) {        fail("Should have been BadArgumentsException!");    }    ReconfigTest.closeAllHandles(zkArr, zkAdminArr);}
testTooFewRemainingPariticipants
public void zookeeper_f5313_0() throws Exception
{        qu = new QuorumUtil(1);    qu.disableJMXTest = true;    qu.startAll();    ZooKeeper[] zkArr = ReconfigTest.createHandles(qu);    ZooKeeperAdmin[] zkAdminArr = ReconfigTest.createAdminHandles(qu);    List<String> leavingServers = new ArrayList<String>();    leavingServers.add("2");    leavingServers.add("3");    try {        zkAdminArr[1].reconfigure(null, leavingServers, null, -1, null);        fail("Reconfig should have failed since the current config version is not 8");    } catch (KeeperException.BadArgumentsException e) {        } catch (Exception e) {        fail("Should have been BadArgumentsException!");    }    ReconfigTest.closeAllHandles(zkArr, zkAdminArr);}
testReconfigVersionConditionFails
public void zookeeper_f5314_0() throws Exception
{        qu = new QuorumUtil(1);    qu.disableJMXTest = true;    qu.startAll();    ZooKeeper[] zkArr = ReconfigTest.createHandles(qu);    ZooKeeperAdmin[] zkAdminArr = ReconfigTest.createAdminHandles(qu);    List<String> leavingServers = new ArrayList<String>();    leavingServers.add("3");    try {        zkAdminArr[1].reconfigure(null, leavingServers, null, 8, null);        fail("Reconfig should have failed since the current config version is not 8");    } catch (KeeperException.BadVersionException e) {        } catch (Exception e) {        fail("Should have been BadVersionException!");    }    ReconfigTest.closeAllHandles(zkArr, zkAdminArr);}
testObserverToParticipantConversionFails
public void zookeeper_f5315_0() throws Exception
{    ClientBase.setupTestEnv();    final int SERVER_COUNT = 4;    int[][] ports = ReconfigRecoveryTest.generatePorts(SERVER_COUNT);        Set<Integer> observers = new HashSet<Integer>();    observers.add(3);    StringBuilder sb = ReconfigRecoveryTest.generateConfig(SERVER_COUNT, ports, observers);    String currentQuorumCfgSection = sb.toString();    String nextQuorumCfgSection = currentQuorumCfgSection.replace("observer", "participant");    MainThread[] mt = new MainThread[SERVER_COUNT];    ZooKeeper[] zk = new ZooKeeper[SERVER_COUNT];    ZooKeeperAdmin[] zkAdmin = new ZooKeeperAdmin[SERVER_COUNT];        for (int i = 1; i < SERVER_COUNT; i++) {        mt[i] = new MainThread(i, ports[i][2], currentQuorumCfgSection, true, "100000000");        mt[i].start();        zk[i] = new ZooKeeper("127.0.0.1:" + ports[i][2], ClientBase.CONNECTION_TIMEOUT, this);        zkAdmin[i] = new ZooKeeperAdmin("127.0.0.1:" + ports[i][2], ClientBase.CONNECTION_TIMEOUT, this);        zkAdmin[i].addAuthInfo("digest", "super:test".getBytes());    }    for (int i = 1; i < SERVER_COUNT; i++) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + ports[i][2], CONNECTION_TIMEOUT * 2));    }    try {        zkAdmin[1].reconfigure("", "", nextQuorumCfgSection, -1, new Stat());        fail("Reconfig should have failed with NewConfigNoQuorum");    } catch (NewConfigNoQuorum e) {            } catch (Exception e) {        fail("Reconfig should have failed with NewConfigNoQuorum");    }        ArrayList<String> leavingServers = new ArrayList<String>();    leavingServers.add("3");    ReconfigTest.reconfig(zkAdmin[1], null, leavingServers, null, -1);    ReconfigTest.testNormalOperation(zk[2], zk[3]);    ReconfigTest.testServerHasConfig(zk[3], null, leavingServers);        List<String> newMembers = Arrays.asList(nextQuorumCfgSection.split("\n"));    ReconfigTest.reconfig(zkAdmin[1], null, null, newMembers, -1);    ReconfigTest.testNormalOperation(zk[2], zk[3]);    for (int i = 1; i < SERVER_COUNT; i++) {        ReconfigTest.testServerHasConfig(zk[i], newMembers, null);    }    for (int i = 1; i < SERVER_COUNT; i++) {        zk[i].close();        zkAdmin[i].close();        mt[i].shutdown();    }}
setup
public void zookeeper_f5316_0()
{    ClientBase.setupTestEnv();    QuorumPeerConfig.setReconfigEnabled(true);    System.setProperty("zookeeper.DigestAuthenticationProvider.superDigest", "super:D/InIHSb7yEEbrWz8b9l71RjZJU=");}
testConfigFileBackwardCompatibility
public void zookeeper_f5317_0() throws Exception
{    final int[] clientPorts = new int[SERVER_COUNT];    StringBuilder sb = new StringBuilder();    String server;    ArrayList<String> allServers = new ArrayList<String>();    for (int i = 0; i < SERVER_COUNT; i++) {        clientPorts[i] = PortAssignment.unique();        server = "server." + i + "=localhost:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ":participant;localhost:" + clientPorts[i];        allServers.add(server);        sb.append(server + "\n");    }    String currentQuorumCfgSection = sb.toString();    MainThread[] mt = new MainThread[SERVER_COUNT];    ZooKeeper[] zk = new ZooKeeper[SERVER_COUNT];        for (int i = 0; i < SERVER_COUNT; i++) {        mt[i] = new MainThread(i, clientPorts[i], currentQuorumCfgSection, "participant", false);                assertEquals(mt[i].getDynamicFiles().length, 0);        mt[i].start();    }        for (int i = 0; i < SERVER_COUNT; i++) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts[i], CONNECTION_TIMEOUT));        zk[i] = ClientBase.createZKClient("127.0.0.1:" + clientPorts[i]);        File[] dynamicFiles = mt[i].getDynamicFiles();        assertTrue(dynamicFiles.length == 1);        ReconfigTest.testServerHasConfig(zk[i], allServers, null);                                Properties cfg = readPropertiesFromFile(mt[i].confFile);        for (int j = 0; j < SERVER_COUNT; j++) {            assertFalse(cfg.containsKey("server." + j));        }        assertFalse(cfg.containsKey("peerType"));        assertTrue(cfg.containsKey("dynamicConfigFile"));        assertFalse(cfg.containsKey("clientPort"));                cfg = readPropertiesFromFile(dynamicFiles[0]);        for (int j = 0; j < SERVER_COUNT; j++) {            String serverLine = cfg.getProperty("server." + j, "");            assertEquals(allServers.get(j), "server." + j + "=" + serverLine);        }        assertFalse(cfg.containsKey("dynamicConfigFile"));    }    ReconfigTest.testNormalOperation(zk[0], zk[1]);        for (int i = 0; i < SERVER_COUNT; i++) {        zk[i].close();        mt[i].shutdown();    }    for (int i = 0; i < SERVER_COUNT; i++) {        mt[i].start();    }    for (int i = 0; i < SERVER_COUNT; i++) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts[i], CONNECTION_TIMEOUT));        zk[i] = ClientBase.createZKClient("127.0.0.1:" + clientPorts[i]);        ReconfigTest.testServerHasConfig(zk[i], allServers, null);    }    ReconfigTest.testNormalOperation(zk[0], zk[1]);    for (int i = 0; i < SERVER_COUNT; i++) {        mt[i].shutdown();        zk[i].close();    }}
testReconfigRemoveClientFromStatic
public void zookeeper_f5318_0() throws Exception
{    final int[] clientPorts = new int[SERVER_COUNT];    final int[] quorumPorts = new int[SERVER_COUNT];    final int[] electionPorts = new int[SERVER_COUNT];    final int changedServerId = 0;    final int newClientPort = PortAssignment.unique();    StringBuilder sb = new StringBuilder();    ArrayList<String> allServers = new ArrayList<String>();    ArrayList<String> newServers = new ArrayList<String>();    for (int i = 0; i < SERVER_COUNT; i++) {        clientPorts[i] = PortAssignment.unique();        quorumPorts[i] = PortAssignment.unique();        electionPorts[i] = PortAssignment.unique();        String server = "server." + i + "=localhost:" + quorumPorts[i] + ":" + electionPorts[i] + ":participant";        allServers.add(server);        sb.append(server + "\n");        if (i == changedServerId) {            newServers.add(server + ";0.0.0.0:" + newClientPort);        } else {            newServers.add(server);        }    }    String quorumCfgSection = sb.toString();    MainThread[] mt = new MainThread[SERVER_COUNT];    ZooKeeper[] zk = new ZooKeeper[SERVER_COUNT];    ZooKeeperAdmin[] zkAdmin = new ZooKeeperAdmin[SERVER_COUNT];        for (int i = 0; i < SERVER_COUNT; i++) {        mt[i] = new MainThread(i, clientPorts[i], quorumCfgSection, false);        mt[i].start();    }        for (int i = 0; i < SERVER_COUNT; i++) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts[i], CONNECTION_TIMEOUT));        zk[i] = ClientBase.createZKClient("127.0.0.1:" + clientPorts[i]);        zkAdmin[i] = new ZooKeeperAdmin("127.0.0.1:" + clientPorts[i], ClientBase.CONNECTION_TIMEOUT, this);        zkAdmin[i].addAuthInfo("digest", "super:test".getBytes());        ReconfigTest.testServerHasConfig(zk[i], allServers, null);        Properties cfg = readPropertiesFromFile(mt[i].confFile);        assertTrue(cfg.containsKey("dynamicConfigFile"));        assertTrue(cfg.containsKey("clientPort"));    }    ReconfigTest.testNormalOperation(zk[0], zk[1]);    ReconfigTest.reconfig(zkAdmin[1], null, null, newServers, -1);    ReconfigTest.testNormalOperation(zk[0], zk[1]);        Thread.sleep(1000);    for (int i = 0; i < SERVER_COUNT; i++) {        ReconfigTest.testServerHasConfig(zk[i], newServers, null);        Properties staticCfg = readPropertiesFromFile(mt[i].confFile);        if (i == changedServerId) {            assertFalse(staticCfg.containsKey("clientPort"));        } else {            assertTrue(staticCfg.containsKey("clientPort"));        }    }    for (int i = 0; i < SERVER_COUNT; i++) {        mt[i].shutdown();        zk[i].close();        zkAdmin[i].close();    }}
readPropertiesFromFile
public static Properties zookeeper_f5319_0(File file) throws IOException
{    Properties cfg = new Properties();    FileInputStream in = new FileInputStream(file);    try {        cfg.load(in);    } finally {        in.close();    }    return cfg;}
testRestartZooKeeperServer
public void zookeeper_f5320_0() throws Exception
{    final int[] clientPorts = new int[SERVER_COUNT];    StringBuilder sb = new StringBuilder();    String server;    for (int i = 0; i < SERVER_COUNT; i++) {        clientPorts[i] = PortAssignment.unique();        server = "server." + i + "=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ":participant;127.0.0.1:" + clientPorts[i];        sb.append(server + "\n");    }    String currentQuorumCfgSection = sb.toString();    MainThread[] mt = new MainThread[SERVER_COUNT];    for (int i = 0; i < SERVER_COUNT; i++) {        mt[i] = new MainThread(i, clientPorts[i], currentQuorumCfgSection, false);        mt[i].start();    }        for (int i = 0; i < SERVER_COUNT; i++) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts[i], CONNECTION_TIMEOUT));    }    ZooKeeper zk = ClientBase.createZKClient("127.0.0.1:" + clientPorts[0]);    String zNodePath = "/serverRestartTest";    String data = "originalData";    zk.create(zNodePath, data.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.close();    /**     * stop two servers out of three and again start them     */    mt[0].shutdown();    mt[1].shutdown();    mt[0].start();    mt[1].start();        for (int i = 0; i < SERVER_COUNT; i++) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts[i], CONNECTION_TIMEOUT));    }    zk = ClientBase.createZKClient("127.0.0.1:" + clientPorts[0]);    byte[] dataBytes = zk.getData(zNodePath, null, null);    String receivedData = new String(dataBytes);    assertEquals(data, receivedData);    for (int i = 0; i < SERVER_COUNT; i++) {        mt[i].shutdown();    }}
setup
public void zookeeper_f5321_0()
{    QuorumPeerConfig.setReconfigEnabled(true);}
testNextConfigCompletion
public void zookeeper_f5322_0() throws Exception
{    ClientBase.setupTestEnv();        final int SERVER_COUNT = 3;    final int[] clientPorts = new int[SERVER_COUNT];    StringBuilder sb = new StringBuilder();    String server;    ArrayList<String> allServers = new ArrayList<String>();    String currentQuorumCfgSection = null, nextQuorumCfgSection;    for (int i = 0; i < SERVER_COUNT; i++) {        clientPorts[i] = PortAssignment.unique();        server = "server." + i + "=localhost:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ":participant;localhost:" + clientPorts[i];        allServers.add(server);        sb.append(server + "\n");        if (i == 1) {            currentQuorumCfgSection = sb.toString();        }    }    nextQuorumCfgSection = sb.toString();                MainThread[] mt = new MainThread[SERVER_COUNT];    ZooKeeper[] zk = new ZooKeeper[SERVER_COUNT];    for (int i = 0; i < SERVER_COUNT - 1; i++) {        mt[i] = new MainThread(i, clientPorts[i], currentQuorumCfgSection, true, "100000000");                                        mt[i].writeTempDynamicConfigFile(nextQuorumCfgSection, "200000000");        mt[i].start();        zk[i] = new ZooKeeper("127.0.0.1:" + clientPorts[i], ClientBase.CONNECTION_TIMEOUT, this);    }    assertTrue("waiting for server 0 being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts[0], CONNECTION_TIMEOUT));    assertTrue("waiting for server 1 being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts[1], CONNECTION_TIMEOUT));    int leader = mt[0].main.quorumPeer.leader == null ? 1 : 0;        sb = new StringBuilder();    sb.append(allServers.get(leader) + "\n");    sb.append(allServers.get(2) + "\n");        String newServerInitialConfig = sb.toString();    mt[2] = new MainThread(2, clientPorts[2], newServerInitialConfig);    mt[2].start();    zk[2] = new ZooKeeper("127.0.0.1:" + clientPorts[2], ClientBase.CONNECTION_TIMEOUT, this);    assertTrue("waiting for server 2 being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts[2], CONNECTION_TIMEOUT));    ReconfigTest.testServerHasConfig(zk[0], allServers, null);    ReconfigTest.testServerHasConfig(zk[1], allServers, null);    ReconfigTest.testServerHasConfig(zk[2], allServers, null);    ReconfigTest.testNormalOperation(zk[0], zk[2]);    ReconfigTest.testNormalOperation(zk[2], zk[1]);    for (int i = 0; i < SERVER_COUNT; i++) {        mt[i].shutdown();        zk[i].close();    }}
testCurrentServersAreObserversInNextConfig
public void zookeeper_f5323_0() throws Exception
{    ClientBase.setupTestEnv();        final int SERVER_COUNT = 5;    final int[] clientPorts = new int[SERVER_COUNT];    final int[] oldClientPorts = new int[2];    StringBuilder sb = new StringBuilder();    String server;    String currentQuorumCfg, nextQuorumCfgSection;    ArrayList<String> allServersNext = new ArrayList<String>();    for (int i = 0; i < 2; i++) {        oldClientPorts[i] = PortAssignment.unique();        server = "server." + i + "=localhost:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ":participant;localhost:" + oldClientPorts[i];        sb.append(server + "\n");    }    currentQuorumCfg = sb.toString();    sb = new StringBuilder();    String role;    for (int i = 0; i < SERVER_COUNT; i++) {        clientPorts[i] = PortAssignment.unique();        if (i < 2) {            role = "observer";        } else {            role = "participant";        }        server = "server." + i + "=localhost:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ":" + role + ";localhost:" + clientPorts[i];        allServersNext.add(server);        sb.append(server + "\n");    }    nextQuorumCfgSection = sb.toString();    MainThread[] mt = new MainThread[SERVER_COUNT];    ZooKeeper[] zk = new ZooKeeper[SERVER_COUNT];        for (int i = 0; i < 2; i++) {        mt[i] = new MainThread(i, oldClientPorts[i], currentQuorumCfg, true, "100000000");        mt[i].start();        zk[i] = new ZooKeeper("127.0.0.1:" + oldClientPorts[i], ClientBase.CONNECTION_TIMEOUT, this);    }    for (int i = 0; i < 2; i++) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + oldClientPorts[i], CONNECTION_TIMEOUT * 2));    }    ReconfigTest.testNormalOperation(zk[0], zk[1]);        for (int i = 0; i < 2; i++) {        mt[i].shutdown();        zk[i].close();    }    for (int i = 0; i < 2; i++) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerDown("127.0.0.1:" + oldClientPorts[i], CONNECTION_TIMEOUT * 2));    }    for (int i = 0; i < 2; i++) {        mt[i].writeTempDynamicConfigFile(nextQuorumCfgSection, "200000000");        mt[i].start();        zk[i] = new ZooKeeper("127.0.0.1:" + clientPorts[i], ClientBase.CONNECTION_TIMEOUT, this);    }        for (int i = 2; i < SERVER_COUNT; i++) {        mt[i] = new MainThread(i, clientPorts[i], currentQuorumCfg + allServersNext.get(i));        mt[i].start();        zk[i] = new ZooKeeper("127.0.0.1:" + clientPorts[i], ClientBase.CONNECTION_TIMEOUT, this);    }    for (int i = 0; i < SERVER_COUNT; i++) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts[i], CONNECTION_TIMEOUT * 2));        ReconfigTest.testServerHasConfig(zk[i], allServersNext, null);    }    ReconfigTest.testNormalOperation(zk[0], zk[2]);    ReconfigTest.testNormalOperation(zk[4], zk[1]);    for (int i = 0; i < SERVER_COUNT; i++) {        zk[i].close();        mt[i].shutdown();    }}
testNextConfigUnreachable
public void zookeeper_f5324_0() throws Exception
{    ClientBase.setupTestEnv();        final int SERVER_COUNT = 5;    final int[] clientPorts = new int[SERVER_COUNT];    StringBuilder sb = new StringBuilder();    String server;    String currentQuorumCfgSection = null, nextQuorumCfgSection;    for (int i = 0; i < SERVER_COUNT; i++) {        clientPorts[i] = PortAssignment.unique();        server = "server." + i + "=localhost:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ":participant;localhost:" + clientPorts[i];        sb.append(server + "\n");        if (i == 1) {            currentQuorumCfgSection = sb.toString();        }    }    nextQuorumCfgSection = sb.toString();    MainThread[] mt = new MainThread[SERVER_COUNT];    ZooKeeper[] zk = new ZooKeeper[SERVER_COUNT];        for (int i = 0; i < 2; i++) {        mt[i] = new MainThread(i, clientPorts[i], currentQuorumCfgSection, true, "100000000");                                mt[i].writeTempDynamicConfigFile(nextQuorumCfgSection, "200000000");        mt[i].start();        zk[i] = new ZooKeeper("127.0.0.1:" + clientPorts[i], ClientBase.CONNECTION_TIMEOUT, this);    }    Thread.sleep(CONNECTION_TIMEOUT * 2);        for (int i = 0; i < 2; i++) {        assertFalse("server " + i + " is up but shouldn't be", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts[i], CONNECTION_TIMEOUT / 10));    }    for (int i = 0; i < 2; i++) {        zk[i].close();        mt[i].shutdown();    }}
testNextConfigAlreadyActive
public void zookeeper_f5325_0() throws Exception
{    ClientBase.setupTestEnv();        final int SERVER_COUNT = 5;    final int[] clientPorts = new int[SERVER_COUNT];    StringBuilder sb = new StringBuilder();    String server;    String currentQuorumCfgSection = null, nextQuorumCfgSection;    ArrayList<String> allServers = new ArrayList<String>();    for (int i = 0; i < SERVER_COUNT; i++) {        clientPorts[i] = PortAssignment.unique();        server = "server." + i + "=localhost:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ":participant;localhost:" + clientPorts[i];        allServers.add(server);        sb.append(server + "\n");        if (i == 1) {            currentQuorumCfgSection = sb.toString();        }    }    nextQuorumCfgSection = sb.toString();        MainThread[] mt = new MainThread[SERVER_COUNT];    ZooKeeper[] zk = new ZooKeeper[SERVER_COUNT];    for (int i = 2; i < SERVER_COUNT; i++) {        mt[i] = new MainThread(i, clientPorts[i], nextQuorumCfgSection, true, "200000000");        mt[i].start();        zk[i] = new ZooKeeper("127.0.0.1:" + clientPorts[i], ClientBase.CONNECTION_TIMEOUT, this);    }    for (int i = 2; i < SERVER_COUNT; i++) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts[i], CONNECTION_TIMEOUT));    }    ReconfigTest.testNormalOperation(zk[2], zk[3]);    long epoch = mt[2].main.quorumPeer.getAcceptedEpoch();        for (int i = 0; i < 2; i++) {        mt[i] = new MainThread(i, clientPorts[i], currentQuorumCfgSection, true, "100000000");        mt[i].writeTempDynamicConfigFile(nextQuorumCfgSection, "200000000");        mt[i].start();        zk[i] = new ZooKeeper("127.0.0.1:" + clientPorts[i], ClientBase.CONNECTION_TIMEOUT, this);    }        for (int i = 0; i < 2; i++) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts[i], CONNECTION_TIMEOUT * 2));    }        assertEquals(epoch, mt[0].main.quorumPeer.getAcceptedEpoch());    assertEquals(epoch, mt[1].main.quorumPeer.getAcceptedEpoch());    assertEquals(epoch, mt[2].main.quorumPeer.getAcceptedEpoch());    ReconfigTest.testServerHasConfig(zk[0], allServers, null);    ReconfigTest.testServerHasConfig(zk[1], allServers, null);    ReconfigTest.testNormalOperation(zk[0], zk[2]);    ReconfigTest.testNormalOperation(zk[4], zk[1]);    for (int i = 0; i < SERVER_COUNT; i++) {        zk[i].close();        mt[i].shutdown();    }}
testObserverConvertedToParticipantDuringFLE
public void zookeeper_f5326_0() throws Exception
{    ClientBase.setupTestEnv();    final int SERVER_COUNT = 4;    int[][] ports = generatePorts(SERVER_COUNT);    String currentQuorumCfgSection, nextQuorumCfgSection;        Set<Integer> observers = new HashSet<Integer>();    observers.add(2);    StringBuilder sb = generateConfig(3, ports, observers);    currentQuorumCfgSection = sb.toString();        ArrayList<String> allServersNext = new ArrayList<String>();    sb = new StringBuilder();    for (int i = 2; i < SERVER_COUNT; i++) {        String server = "server." + i + "=localhost:" + ports[i][0] + ":" + ports[i][1] + ":participant;localhost:" + ports[i][2];        allServersNext.add(server);        sb.append(server + "\n");    }    nextQuorumCfgSection = sb.toString();    MainThread[] mt = new MainThread[SERVER_COUNT];    ZooKeeper[] zk = new ZooKeeper[SERVER_COUNT];        mt[2] = new MainThread(2, ports[2][2], currentQuorumCfgSection, true, "100000000");    mt[2].start();    zk[2] = new ZooKeeper("127.0.0.1:" + ports[2][2], ClientBase.CONNECTION_TIMEOUT, this);        mt[3] = new MainThread(3, ports[3][2], nextQuorumCfgSection, true, "200000000");    mt[3].start();    zk[3] = new ZooKeeper("127.0.0.1:" + ports[3][2], ClientBase.CONNECTION_TIMEOUT, this);    for (int i = 2; i < SERVER_COUNT; i++) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + ports[i][2], CONNECTION_TIMEOUT * 2));        ReconfigTest.testServerHasConfig(zk[i], allServersNext, null);    }    assertEquals(nextQuorumCfgSection + "version=200000000", ReconfigTest.testServerHasConfig(zk[2], null, null));    assertEquals(nextQuorumCfgSection + "version=200000000", ReconfigTest.testServerHasConfig(zk[3], null, null));    ReconfigTest.testNormalOperation(zk[2], zk[2]);    ReconfigTest.testNormalOperation(zk[3], zk[2]);    for (int i = 2; i < SERVER_COUNT; i++) {        zk[i].close();        mt[i].shutdown();    }}
testCurrentObserverIsParticipantInNewConfig
public void zookeeper_f5327_0() throws Exception
{    ClientBase.setupTestEnv();    final int SERVER_COUNT = 4;    int[][] ports = generatePorts(SERVER_COUNT);    String currentQuorumCfg, nextQuorumCfgSection;        Set<Integer> observers = new HashSet<Integer>();    observers.add(2);    StringBuilder sb = generateConfig(3, ports, observers);    currentQuorumCfg = sb.toString();        MainThread[] mt = new MainThread[SERVER_COUNT];    ZooKeeper[] zk = new ZooKeeper[SERVER_COUNT];    for (int i = 0; i <= 2; i++) {        mt[i] = new MainThread(i, ports[i][2], currentQuorumCfg, true, "100000000");        mt[i].start();        zk[i] = new ZooKeeper("127.0.0.1:" + ports[i][2], ClientBase.CONNECTION_TIMEOUT, this);    }    ReconfigTest.testNormalOperation(zk[0], zk[2]);    for (int i = 0; i <= 2; i++) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + ports[i][2], CONNECTION_TIMEOUT * 2));    }        for (int i = 0; i <= 2; i++) {        mt[i].shutdown();        zk[i].close();    }        ArrayList<String> allServersNext = new ArrayList<String>();    sb = new StringBuilder();    for (int i = 2; i < SERVER_COUNT; i++) {        String server = "server." + i + "=localhost:" + ports[i][0] + ":" + ports[i][1] + ":participant;localhost:" + ports[i][2];        allServersNext.add(server);        sb.append(server + "\n");    }    nextQuorumCfgSection = sb.toString();        for (int i = 0; i <= 2; i++) {        mt[i].writeTempDynamicConfigFile(nextQuorumCfgSection, "200000000");        mt[i].start();        zk[i] = new ZooKeeper("127.0.0.1:" + ports[i][2], ClientBase.CONNECTION_TIMEOUT, this);    }            mt[3] = new MainThread(3, ports[3][2], currentQuorumCfg + allServersNext.get(1));    mt[3].start();    zk[3] = new ZooKeeper("127.0.0.1:" + ports[3][2], ClientBase.CONNECTION_TIMEOUT, this);    for (int i = 2; i < SERVER_COUNT; i++) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + ports[i][2], CONNECTION_TIMEOUT * 3));        ReconfigTest.testServerHasConfig(zk[i], allServersNext, null);    }    ReconfigTest.testNormalOperation(zk[0], zk[2]);    ReconfigTest.testNormalOperation(zk[3], zk[1]);    assertEquals(nextQuorumCfgSection + "version=200000000", ReconfigTest.testServerHasConfig(zk[2], null, null));    assertEquals(nextQuorumCfgSection + "version=200000000", ReconfigTest.testServerHasConfig(zk[3], null, null));    for (int i = 0; i < SERVER_COUNT; i++) {        zk[i].close();        mt[i].shutdown();    }}
generatePorts
public static int[][] zookeeper_f5328_0(int numServers)
{    int[][] ports = new int[numServers][];    for (int i = 0; i < numServers; i++) {        ports[i] = new int[3];        for (int j = 0; j < 3; j++) {            ports[i][j] = PortAssignment.unique();        }    }    return ports;}
generateConfig
public static StringBuilder zookeeper_f5329_0(int numServers, int[][] ports, Set<Integer> observerIds)
{    StringBuilder sb = new StringBuilder();    for (int i = 0; i < numServers; i++) {        String server = "server." + i + "=localhost:" + ports[i][0] + ":" + ports[i][1] + ":" + (observerIds.contains(i) ? "observer" : "participant") + ";localhost:" + ports[i][2];        sb.append(server + "\n");    }    return sb;}
generateNewQuorumConfig
private String zookeeper_f5330_0(int serverCount)
{    StringBuilder sb = new StringBuilder();    String server;    for (int i = 0; i < serverCount; i++) {        clientPorts.put(i, PortAssignment.unique());        server = "server." + i + "=localhost:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ":participant;localhost:" + clientPorts.get(i);        serverAddress.put(i, server);        sb.append(server + "\n");    }    return sb.toString();}
updateExistingQuorumConfig
private String zookeeper_f5331_0(List<Integer> sidsToAdd, List<Integer> sidsToRemove)
{    StringBuilder sb = new StringBuilder();    for (Integer sid : sidsToAdd) {        clientPorts.put(sid, PortAssignment.unique());        serverAddress.put(sid, "server." + sid + "=localhost:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ":participant;localhost:" + clientPorts.get(sid));    }    for (Integer sid : sidsToRemove) {        clientPorts.remove(sid);        serverAddress.remove(sid);    }    for (String server : serverAddress.values()) {        sb.append(server + "\n");    }    return sb.toString();}
testNoLocalDynamicConfigAndBackupFiles
public void zookeeper_f5332_0() throws InterruptedException, IOException
{    int serverCount = 3;    String config = generateNewQuorumConfig(serverCount);    QuorumPeerTestBase.MainThread[] mt = new QuorumPeerTestBase.MainThread[serverCount];    String[] staticFileContent = new String[serverCount];    for (int i = 0; i < serverCount; i++) {        mt[i] = new QuorumPeerTestBase.MainThread(i, clientPorts.get(i), config, false);        mt[i].start();    }    for (int i = 0; i < serverCount; i++) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts.get(i), CONNECTION_TIMEOUT));        assertNull("static file backup (zoo.cfg.bak) shouldn't exist!", mt[i].getFileByName(ZOO_CFG_BAK_FILE));        assertNull("dynamic configuration file (zoo.cfg.dynamic.*) shouldn't exist!", mt[i].getFileByName(mt[i].getQuorumPeer().getNextDynamicConfigFilename()));        staticFileContent[i] = Files.readAllLines(mt[i].confFile.toPath(), StandardCharsets.UTF_8).toString();        assertTrue("static config file should contain server entry " + serverAddress.get(i), staticFileContent[i].contains(serverAddress.get(i)));    }    for (int i = 0; i < serverCount; i++) {        mt[i].shutdown();    }}
testRollingRestartWithoutMembershipChange
public void zookeeper_f5333_0() throws Exception
{    int serverCount = 3;    String config = generateNewQuorumConfig(serverCount);    List<String> joiningServers = new ArrayList<>();    QuorumPeerTestBase.MainThread[] mt = new QuorumPeerTestBase.MainThread[serverCount];    for (int i = 0; i < serverCount; ++i) {        mt[i] = new QuorumPeerTestBase.MainThread(i, clientPorts.get(i), config, false);        mt[i].start();        joiningServers.add(serverAddress.get(i));    }    for (int i = 0; i < serverCount; ++i) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts.get(i), CONNECTION_TIMEOUT));    }    for (int i = 0; i < serverCount; ++i) {        mt[i].shutdown();        mt[i].start();        verifyQuorumConfig(i, joiningServers, null);        verifyQuorumMembers(mt[i]);    }    for (int i = 0; i < serverCount; i++) {        mt[i].shutdown();    }}
testRollingRestartWithMembershipChange
public void zookeeper_f5334_0() throws Exception
{    int serverCount = 3;    String config = generateNewQuorumConfig(serverCount);    QuorumPeerTestBase.MainThread[] mt = new QuorumPeerTestBase.MainThread[serverCount];    List<String> joiningServers = new ArrayList<>();    for (int i = 0; i < serverCount; ++i) {        mt[i] = new QuorumPeerTestBase.MainThread(i, clientPorts.get(i), config, false);        mt[i].start();        joiningServers.add(serverAddress.get(i));    }    for (int i = 0; i < serverCount; ++i) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts.get(i), CONNECTION_TIMEOUT));    }    for (int i = 0; i < serverCount; ++i) {        verifyQuorumConfig(i, joiningServers, null);        verifyQuorumMembers(mt[i]);    }    Map<Integer, String> oldServerAddress = new HashMap<>(serverAddress);    List<String> newServers = new ArrayList<>(joiningServers);    config = updateExistingQuorumConfig(Arrays.asList(3, 4), new ArrayList<Integer>());    newServers.add(serverAddress.get(3));    newServers.add(serverAddress.get(4));    serverCount = serverAddress.size();    assertEquals("Server count should be 5 after config update.", serverCount, 5);                    mt = Arrays.copyOf(mt, mt.length + 2);    for (int i = 3; i < 5; ++i) {        mt[i] = new QuorumPeerTestBase.MainThread(i, clientPorts.get(i), config, false);        mt[i].start();        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts.get(i), CONNECTION_TIMEOUT));        verifyQuorumConfig(i, newServers, null);        verifyQuorumMembers(mt[i]);    }    Set<String> expectedConfigs = new HashSet<>();    for (String conf : oldServerAddress.values()) {                expectedConfigs.add(conf.substring(conf.indexOf('=') + 1));    }    for (int i = 0; i < 3; ++i) {        verifyQuorumConfig(i, joiningServers, null);        verifyQuorumMembers(mt[i], expectedConfigs);    }    for (int i = 0; i < serverCount; ++i) {        mt[i].shutdown();    }}
verifyQuorumConfig
private void zookeeper_f5335_0(int sid, List<String> joiningServers, List<String> leavingServers) throws Exception
{    ZooKeeper zk = ClientBase.createZKClient("127.0.0.1:" + clientPorts.get(sid));    ReconfigTest.testNormalOperation(zk, zk);    ReconfigTest.testServerHasConfig(zk, joiningServers, leavingServers);    zk.close();}
verifyQuorumMembers
private void zookeeper_f5336_0(QuorumPeerTestBase.MainThread mt)
{    Set<String> expectedConfigs = new HashSet<>();    for (String config : serverAddress.values()) {        expectedConfigs.add(config.substring(config.indexOf('=') + 1));    }    verifyQuorumMembers(mt, expectedConfigs);}
verifyQuorumMembers
private void zookeeper_f5337_0(QuorumPeerTestBase.MainThread mt, Set<String> expectedConfigs)
{    Map<Long, QuorumPeer.QuorumServer> members = mt.getQuorumPeer().getQuorumVerifier().getAllMembers();    assertTrue("Quorum member should not change.", members.size() == expectedConfigs.size());    for (QuorumPeer.QuorumServer qs : members.values()) {        String actualConfig = qs.toString();        assertTrue("Unexpected config " + actualConfig + " found!", expectedConfigs.contains(actualConfig));    }}
testGetClientAddressShouldReturnEmptyStringWhenClientAddressIsNull
public void zookeeper_f5338_0()
{    InetSocketAddress peerCommunicationAddress = null;        QuorumServer peer = new QuorumServer(1, peerCommunicationAddress);    RemotePeerBean remotePeerBean = new RemotePeerBean(null, peer);    String clientAddress = remotePeerBean.getClientAddress();    assertNotNull(clientAddress);    assertEquals(0, clientAddress.length());}
testIsLeader
public void zookeeper_f5339_0()
{    long peerId = 7;    QuorumPeer.QuorumServer quorumServerMock = mock(QuorumPeer.QuorumServer.class);    when(quorumServerMock.getId()).thenReturn(peerId);    QuorumPeer peerMock = mock(QuorumPeer.class);    RemotePeerBean remotePeerBean = new RemotePeerBean(peerMock, quorumServerMock);    when(peerMock.isLeader(eq(peerId))).thenReturn(true);    assertTrue(remotePeerBean.isLeader());    when(peerMock.isLeader(eq(peerId))).thenReturn(false);    assertFalse(remotePeerBean.isLeader());}
setUp
public voidf5340_1) throws Exception
{            ClientBase.setupTestEnv();    mt = new MainThread[SERVER_COUNT];    clientPorts = new int[SERVER_COUNT];    StringBuilder sb = new StringBuilder();    for (int i = 0; i < SERVER_COUNT; i++) {        clientPorts[i] = PortAssignment.unique();        sb.append("server.").append(i).append("=127.0.0.1:").append(PortAssignment.unique()).append(":").append(PortAssignment.unique()).append("\n");    }    sb.append("localSessionsEnabled=true\n");    sb.append("localSessionsUpgradingEnabled=true\n");    String cfg = sb.toString();        qpMain = new TestQPMainDropSessionUpgrading[SERVER_COUNT];    for (int i = 0; i < SERVER_COUNT; i++) {        final TestQPMainDropSessionUpgrading qp = new TestQPMainDropSessionUpgrading();        qpMain[i] = qp;        mt[i] = new MainThread(i, clientPorts[i], cfg, false) {            @Override            public TestQPMain getTestQPMain() {                return qp;            }        };        mt[i].start();    }    for (int i = 0; i < SERVER_COUNT; i++) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts[i], CONNECTION_TIMEOUT));    }}
getTestQPMain
public TestQPMain zookeeper_f5341_0()
{    return qp;}
tearDown
public voidf5342_1) throws Exception
{        for (int i = 0; i < SERVER_COUNT; i++) {        mt[i].shutdown();    }}
testLocalSessionUpgradeSnapshot
public voidf5343_1) throws IOException, InterruptedException
{        int leader = -1;    int followerA = -1;    for (int i = SERVER_COUNT - 1; i >= 0; i--) {        if (mt[i].main.quorumPeer.leader != null) {            leader = i;        } else if (followerA == -1) {            followerA = i;        }    }        qpMain[followerA].setDropCreateSession(true);            final String node = "/node-1";    ZooKeeper zk = new ZooKeeper("127.0.0.1:" + clientPorts[followerA], ClientBase.CONNECTION_TIMEOUT, this);    waitForOne(zk, States.CONNECTED);        long sessionId = zk.getSessionId();        try {        zk.create(node, new byte[2], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);        fail("expect to failed to upgrade session due to the " + "TestQPMainDropSessionUpgrading is being used");    } catch (KeeperException e) {            }        qpMain[followerA].quorumPeer.follower.zk.takeSnapshot(true);        Thread.sleep(500);        for (int i = 0; i < SERVER_COUNT; i++) {        mt[i].shutdown();    }    ArrayList<States> waitStates = new ArrayList<States>();    waitStates.add(States.CONNECTING);    waitStates.add(States.CLOSED);    waitForOne(zk, waitStates);        for (int i = 0; i < SERVER_COUNT; i++) {        mt[i].start();    }    for (int i = 0; i < SERVER_COUNT; i++) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts[i], CONNECTION_TIMEOUT));    }        for (int i = 0; i < SERVER_COUNT; i++) {        ConcurrentHashMap<Long, Integer> sessions = mt[i].main.quorumPeer.getZkDb().getSessionWithTimeOuts();        assertFalse("server " + i + " should not have global " + "session " + sessionId, sessions.containsKey(sessionId));    }    zk.close();}
testOnlyUpgradeSessionOnce
public void zookeeper_f5344_0() throws IOException, InterruptedException, KeeperException
{            final String node = "/node-1";    ZooKeeper zk = new ZooKeeper("127.0.0.1:" + clientPorts[0], ClientBase.CONNECTION_TIMEOUT, this);    waitForOne(zk, States.CONNECTED);    long sessionId = zk.getSessionId();    QuorumZooKeeperServer server = (QuorumZooKeeperServer) mt[0].main.quorumPeer.getActiveServer();    Request create1 = createEphemeralRequest("/data-1", sessionId);    Request create2 = createEphemeralRequest("/data-2", sessionId);    assertNotNull("failed to upgrade on a ephemeral create", server.checkUpgradeSession(create1));    assertNull("tried to upgrade again", server.checkUpgradeSession(create2));        zk.close();}
setDropCreateSession
public void zookeeper_f5345_0(boolean dropCreateSession)
{    shouldDrop = dropCreateSession;}
getQuorumPeer
protected QuorumPeerf5346_1) throws SaslException
{    return new QuorumPeer() {        @Override        protected Follower makeFollower(FileTxnSnapLog logFactory) throws IOException {            return new Follower(this, new FollowerZooKeeperServer(logFactory, this, this.getZkDb())) {                @Override                protected void request(Request request) throws IOException {                    if (!shouldDrop) {                        super.request(request);                        return;                    }                                        if (request.type == ZooDefs.OpCode.createSession) {                                                return;                    }                    if (request.type == ZooDefs.OpCode.create && request.cnxn != null) {                        CreateRequest createRequest = new CreateRequest();                        request.request.rewind();                        ByteBufferInputStream.byteBuffer2Record(request.request, createRequest);                        request.request.rewind();                        try {                            CreateMode createMode = CreateMode.fromFlag(createRequest.getFlags());                            if (createMode.isEphemeral()) {                                request.cnxn.sendCloseSession();                            }                        } catch (KeeperException e) {                        }                        return;                    }                    super.request(request);                }            };        }    };}
makeFollower
protected Followerf5347_1FileTxnSnapLog logFactory) throws IOException
{    return new Follower(this, new FollowerZooKeeperServer(logFactory, this, this.getZkDb())) {        @Override        protected void request(Request request) throws IOException {            if (!shouldDrop) {                super.request(request);                return;            }                        if (request.type == ZooDefs.OpCode.createSession) {                                return;            }            if (request.type == ZooDefs.OpCode.create && request.cnxn != null) {                CreateRequest createRequest = new CreateRequest();                request.request.rewind();                ByteBufferInputStream.byteBuffer2Record(request.request, createRequest);                request.request.rewind();                try {                    CreateMode createMode = CreateMode.fromFlag(createRequest.getFlags());                    if (createMode.isEphemeral()) {                        request.cnxn.sendCloseSession();                    }                } catch (KeeperException e) {                }                return;            }            super.request(request);        }    };}
request
protected voidf5348_1Request request) throws IOException
{    if (!shouldDrop) {        super.request(request);        return;    }        if (request.type == ZooDefs.OpCode.createSession) {                return;    }    if (request.type == ZooDefs.OpCode.create && request.cnxn != null) {        CreateRequest createRequest = new CreateRequest();        request.request.rewind();        ByteBufferInputStream.byteBuffer2Record(request.request, createRequest);        request.request.rewind();        try {            CreateMode createMode = CreateMode.fromFlag(createRequest.getFlags());            if (createMode.isEphemeral()) {                request.cnxn.sendCloseSession();            }        } catch (KeeperException e) {        }        return;    }    super.request(request);}
waitForOne
private voidf5349_1ZooKeeper zk, ArrayList<States> states) throws InterruptedException
{    int iterations = ClientBase.CONNECTION_TIMEOUT / 500;    while (!states.contains(zk.getState())) {        if (iterations-- == 0) {                        throw new RuntimeException("Waiting too long");        }        Thread.sleep(500);    }}
createEphemeralRequest
private Request zookeeper_f5350_0(String path, long sessionId) throws IOException
{    ByteArrayOutputStream boas = new ByteArrayOutputStream();    BinaryOutputArchive boa = BinaryOutputArchive.getArchive(boas);    CreateRequest createRequest = new CreateRequest(path, "data".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL.toFlag());    createRequest.serialize(boa, "request");    ByteBuffer bb = ByteBuffer.wrap(boas.toByteArray());    return new Request(null, sessionId, 1, ZooDefs.OpCode.create2, bb, new ArrayList<Id>());}
startSingleServerTest
public voidf5351_1) throws Exception
{    setUpData();        startServer(leaderId, serverStrings.get(leaderId) + "\n");    ReconfigTest.testServerHasConfig(zkHandles[leaderId], null, null);            startFollowers();    testReconfig(leaderId, true, reconfigServers);            shutDownServer(leaderId);    ReconfigTest.testNormalOperation(zkHandles[follower1], zkHandles[follower2]);            reconfigServers.clear();    reconfigServers.add(Integer.toString(follower2));    try {        ReconfigTest.reconfig(zkAdminHandles[follower1], null, reconfigServers, null, -1);        fail("reconfig completed successfully even though there is no quorum up in new config!");    } catch (KeeperException.NewConfigNoQuorum e) {    }            reconfigServers.clear();    reconfigServers.add(Integer.toString(leaderId));    reconfigServers.add(Integer.toString(follower1));    testReconfig(follower2, false, reconfigServers);            shutDownServer(follower1);        reconfigServers.clear();    reconfigServers.add(Integer.toString(follower2));    try {        zkAdminHandles[follower2].reconfigure(null, reconfigServers, null, -1, new Stat());        fail("reconfig completed successfully even though there is no quorum up in new config!");    } catch (KeeperException.BadArgumentsException e) {        } catch (Exception e) {        fail("Should have been BadArgumentsException!");    }            ArrayList<String> observerStrings = new ArrayList<String>();    startObservers(observerStrings);        testReconfig(follower2, true, reconfigServers);        testReconfig(follower2, true, observerStrings);        shutDownData();}
setUpData
private void zookeeper_f5352_0() throws Exception
{    ClientBase.setupTestEnv();    QuorumPeerConfig.setStandaloneEnabled(false);    QuorumPeerConfig.setReconfigEnabled(true);    peers = new MainThread[NUM_SERVERS];    zkHandles = new ZooKeeper[NUM_SERVERS];    zkAdminHandles = new ZooKeeperAdmin[NUM_SERVERS];    clientPorts = new int[NUM_SERVERS];    serverStrings = buildServerStrings();    reconfigServers = new ArrayList<String>();    System.setProperty("zookeeper.DigestAuthenticationProvider.superDigest", "super:D/InIHSb7yEEbrWz8b9l71RjZJU=");}
shutDownData
private void zookeeper_f5353_0() throws Exception
{    for (int i = 0; i < NUM_SERVERS; i++) {        zkHandles[i].close();        zkAdminHandles[i].close();    }    for (int i = 1; i < NUM_SERVERS; i++) {        peers[i].shutdown();    }}
buildServerStrings
private ArrayList<String> zookeeper_f5354_0()
{    ArrayList<String> serverStrings = new ArrayList<String>();    for (int i = 0; i < NUM_SERVERS; i++) {        clientPorts[i] = PortAssignment.unique();        String server = "server." + i + "=localhost:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ":participant;" + "localhost:" + clientPorts[i];        serverStrings.add(server);    }    return serverStrings;}
startServer
private voidf5355_1int id, String config) throws Exception
{    peers[id] = new MainThread(id, clientPorts[id], config);    peers[id].start();    assertTrue("Server " + id + " is not up", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts[id], CONNECTION_TIMEOUT));    assertTrue("Error- Server started in Standalone Mode!", peers[id].isQuorumPeerRunning());    zkHandles[id] = ClientBase.createZKClient("127.0.0.1:" + clientPorts[id]);    zkAdminHandles[id] = new ZooKeeperAdmin("127.0.0.1:" + clientPorts[id], CONNECTION_TIMEOUT, this);    zkAdminHandles[id].addAuthInfo("digest", "super:test".getBytes());    String statCommandOut = FourLetterWordMain.send4LetterWord("127.0.0.1", clientPorts[id], "stat");    }
shutDownServer
private void zookeeper_f5356_0(int id) throws Exception
{    peers[id].shutdown();    ClientBase.waitForServerDown("127.0.0.1:" + clientPorts[id], CONNECTION_TIMEOUT);    TimeUnit.SECONDS.sleep(25);}
startFollowers
private void zookeeper_f5357_0() throws Exception
{    reconfigServers.clear();    for (int i = 1; i <= 2; i++) {        String config = serverStrings.get(leaderId) + "\n" + serverStrings.get(i) + "\n" + serverStrings.get(i % 2 + 1) + "\n";        startServer(i, config);        reconfigServers.add(serverStrings.get(i));    }}
startObservers
private void zookeeper_f5358_0(ArrayList<String> observerStrings) throws Exception
{    reconfigServers.clear();    for (int i = observer1; i <= observer2; i++) {        String config = serverStrings.get(follower2) + "\n" + serverStrings.get(i) + "\n";        startServer(i, config);        reconfigServers.add(serverStrings.get(i));        observerStrings.add(serverStrings.get(i).replace("participant", "observer"));    }}
testReconfig
private void zookeeper_f5359_0(int id, boolean adding, ArrayList<String> servers) throws Exception
{    if (adding) {        ReconfigTest.reconfig(zkAdminHandles[id], servers, null, null, -1);        for (String server : servers) {                        int id2 = Integer.parseInt(server.substring(7, 8));            ReconfigTest.testNormalOperation(zkHandles[id], zkHandles[id2]);        }        ReconfigTest.testServerHasConfig(zkHandles[id], servers, null);    } else {        ReconfigTest.reconfig(zkAdminHandles[id], null, servers, null, -1);        ReconfigTest.testServerHasConfig(zkHandles[id], null, servers);    }}
startObserver
public void zookeeper_f5360_0() throws Exception
{    int clientPort = PortAssignment.unique();    String config = "server." + observer1 + "=localhost:" + PortAssignment.unique() + ":" + clientPort + ":observer;" + "localhost:" + PortAssignment.unique();    MainThread observer = new MainThread(observer1, clientPort, config);    observer.start();    assertFalse("Observer was able to start by itself!", ClientBase.waitForServerUp("127.0.0.1:" + clientPort, CONNECTION_TIMEOUT));}
setUp
public void zookeeper_f5361_0()
{    outputWriter = new StringWriter();    ServerCnxn serverCnxnMock = mock(ServerCnxn.class);    LeaderZooKeeperServer zks = mock(LeaderZooKeeperServer.class);    when(zks.isRunning()).thenReturn(true);    providerMock = mock(ServerStats.Provider.class);    when(zks.serverStats()).thenReturn(new ServerStats(providerMock));    ZKDatabase zkDatabaseMock = mock(ZKDatabase.class);    when(zks.getZKDatabase()).thenReturn(zkDatabaseMock);    Leader leaderMock = mock(Leader.class);    when(leaderMock.getProposalStats()).thenReturn(new BufferStats());    when(zks.getLeader()).thenReturn(leaderMock);    ServerCnxnFactory serverCnxnFactory = mock(ServerCnxnFactory.class);    ServerCnxn serverCnxn = mock(ServerCnxn.class);    List<ServerCnxn> connections = new ArrayList<>();    connections.add(serverCnxn);    when(serverCnxnFactory.getConnections()).thenReturn(connections);    statCommand = new StatCommand(new PrintWriter(outputWriter), serverCnxnMock, FourLetterCommands.statCmd);    statCommand.setZkServer(zks);    statCommand.setFactory(serverCnxnFactory);}
testLeaderStatCommand
public void zookeeper_f5362_0()
{        when(providerMock.getState()).thenReturn("leader");        statCommand.commandRun();        String output = outputWriter.toString();    assertCommonStrings(output);    assertThat(output, containsString("Mode: leader"));    assertThat(output, containsString("Proposal sizes last/min/max:"));}
testFollowerStatCommand
public void zookeeper_f5363_0()
{        when(providerMock.getState()).thenReturn("follower");        statCommand.commandRun();        String output = outputWriter.toString();    assertCommonStrings(output);    assertThat(output, containsString("Mode: follower"));}
assertCommonStrings
private void zookeeper_f5364_0(String output)
{    assertThat(output, containsString("Clients:"));    assertThat(output, containsString("Zookeeper version:"));    assertThat(output, containsString("Node count:"));}
setUp
public void zookeeper_f5365_0()
{    outputWriter = new StringWriter();    ServerCnxn serverCnxnMock = mock(ServerCnxn.class);    zks = mock(ZooKeeperServer.class);    when(zks.isRunning()).thenReturn(true);    serverStats = mock(ServerStats.class);    when(zks.serverStats()).thenReturn(serverStats);    statResetCommand = new StatResetCommand(new PrintWriter(outputWriter), serverCnxnMock);    statResetCommand.setZkServer(zks);}
testStatResetWithZKNotRunning
public void zookeeper_f5366_0()
{        when(zks.isRunning()).thenReturn(false);        statResetCommand.commandRun();        String output = outputWriter.toString();    assertEquals(ZK_NOT_SERVING + "\n", output);}
testStatResetWithFollower
public void zookeeper_f5367_0()
{        when(zks.isRunning()).thenReturn(true);    when(serverStats.getServerState()).thenReturn("follower");        statResetCommand.commandRun();        String output = outputWriter.toString();    assertEquals("Server stats reset.\n", output);    verify(serverStats, times(1)).reset();}
testStatResetWithLeader
public void zookeeper_f5368_0()
{        LeaderZooKeeperServer leaderZks = mock(LeaderZooKeeperServer.class);    when(leaderZks.isRunning()).thenReturn(true);    when(leaderZks.serverStats()).thenReturn(serverStats);    Leader leader = mock(Leader.class);    when(leaderZks.getLeader()).thenReturn(leader);    statResetCommand.setZkServer(leaderZks);    when(serverStats.getServerState()).thenReturn("leader");    BufferStats bufferStats = mock(BufferStats.class);    when(leader.getProposalStats()).thenReturn(bufferStats);        statResetCommand.commandRun();        String output = outputWriter.toString();    assertEquals("Server stats reset.\n", output);    verify(serverStats, times(1)).reset();    verify(bufferStats, times(1)).reset();}
setup
public void zookeeper_f5369_0() throws Exception
{    ZKDatabase db = mock(ZKDatabase.class);    when(db.append(any(Request.class))).thenReturn(true);    doAnswer(invocation -> {        Thread.sleep(100);        return null;    }).when(db).commit();    zks = mock(ZooKeeperServer.class);    when(zks.getZKDatabase()).thenReturn(db);    nextProcessor = mock(RequestProcessor.class);    doAnswer(invocationOnMock -> {        allRequestsFlushed.countDown();        return null;    }).when(nextProcessor).processRequest(any(Request.class));}
createRquest
private Request zookeeper_f5370_0(long sessionId, int xid)
{    return new Request(null, sessionId, xid, ZooDefs.OpCode.setData, ByteBuffer.wrap(new byte[10]), null);}
testSyncProcessorMetrics
public void zookeeper_f5371_0() throws Exception
{    SyncRequestProcessor syncProcessor = new SyncRequestProcessor(zks, nextProcessor);    for (int i = 0; i < 500; i++) {        syncProcessor.processRequest(createRquest(1, i));    }    Map<String, Object> values = MetricsUtils.currentServerMetrics();    assertEquals(500L, values.get("sync_processor_request_queued"));    allRequestsFlushed = new CountDownLatch(500);    syncProcessor.start();    allRequestsFlushed.await(5000, TimeUnit.MILLISECONDS);    values = MetricsUtils.currentServerMetrics();    assertEquals(501L, values.get("cnt_sync_processor_queue_size"));    assertEquals(500L, values.get("max_sync_processor_queue_size"));    assertEquals(0L, values.get("min_sync_processor_queue_size"));    assertEquals(500L, values.get("cnt_sync_processor_queue_time_ms"));    assertThat((long) values.get("max_sync_processor_queue_time_ms"), greaterThan(0L));    assertEquals(500L, values.get("cnt_sync_processor_queue_and_flush_time_ms"));    assertThat((long) values.get("max_sync_processor_queue_and_flush_time_ms"), greaterThan(0L));    assertEquals(500L, values.get("cnt_sync_process_time"));    assertThat((long) values.get("max_sync_process_time"), greaterThan(0L));    assertEquals(500L, values.get("max_sync_processor_batch_size"));    assertEquals(1L, values.get("cnt_sync_processor_queue_flush_time_ms"));    assertThat((long) values.get("max_sync_processor_queue_flush_time_ms"), greaterThanOrEqualTo(100L));    syncProcessor.shutdown();}
params
public static Collection<Object[]> zookeeper_f5372_0()
{    ArrayList<Object[]> result = new ArrayList<>();    result.add(new Object[] { true });    result.add(new Object[] { false });    return result;}
setUpClass
public static void zookeeper_f5373_0() throws Exception
{    Security.addProvider(new BouncyCastleProvider());    tempDir = ClientBase.createEmptyTestDir();    x509TestContext = X509TestContext.newBuilder().setTempDir(tempDir).setKeyStoreKeyType(X509KeyType.EC).setTrustStoreKeyType(X509KeyType.EC).build();}
tearDownClass
public static void zookeeper_f5374_0()
{    try {        FileUtils.deleteDirectory(tempDir);    } catch (IOException e) {        }    Security.removeProvider(BouncyCastleProvider.PROVIDER_NAME);}
forceClose
private static void zookeeper_f5375_0(Socket s)
{    if (s == null || s.isClosed()) {        return;    }    try {        s.close();    } catch (IOException e) {    }}
forceClose
private static void zookeeper_f5376_0(ServerSocket s)
{    if (s == null || s.isClosed()) {        return;    }    try {        s.close();    } catch (IOException e) {    }}
setUp
public voidf5377_1) throws Exception
{    x509Util = new ClientX509Util();    x509TestContext.setSystemProperties(x509Util, KeyStoreFileType.JKS, KeyStoreFileType.JKS);    System.setProperty(x509Util.getSslHandshakeDetectionTimeoutMillisProperty(), "100");    workerPool = Executors.newCachedThreadPool();    port = PortAssignment.unique();    localServerAddress = new InetSocketAddress(InetAddress.getLoopbackAddress(), port);    listeningSocket = new UnifiedServerSocket(x509Util, true);    listeningSocket.bind(localServerAddress);    Future<UnifiedServerSocket.UnifiedSocket> acceptFuture;    acceptFuture = workerPool.submit(new Callable<UnifiedServerSocket.UnifiedSocket>() {        @Override        public UnifiedServerSocket.UnifiedSocket call() throws Exception {            try {                return (UnifiedServerSocket.UnifiedSocket) listeningSocket.accept();            } catch (IOException e) {                                throw e;            }        }    });    if (useSecureClient) {        clientSocket = x509Util.createSSLSocket();        clientSocket.connect(localServerAddress);    } else {        clientSocket = new Socket();        clientSocket.connect(localServerAddress);        clientSocket.getOutputStream().write(new byte[] { 1, 2, 3, 4, 5 });    }    serverSideSocket = acceptFuture.get();}
call
public UnifiedServerSocket.UnifiedSocketf5378_1) throws Exception
{    try {        return (UnifiedServerSocket.UnifiedSocket) listeningSocket.accept();    } catch (IOException e) {                throw e;    }}
tearDown
public void zookeeper_f5379_0() throws Exception
{    x509TestContext.clearSystemProperties(x509Util);    System.clearProperty(x509Util.getSslHandshakeDetectionTimeoutMillisProperty());    forceClose(listeningSocket);    forceClose(serverSideSocket);    forceClose(clientSocket);    workerPool.shutdown();    workerPool.awaitTermination(1000, TimeUnit.MILLISECONDS);    x509Util.close();}
testGetInetAddress
public void zookeeper_f5380_0()
{    serverSideSocket.getInetAddress();    assertFalse(serverSideSocket.isModeKnown());}
testGetLocalAddress
public void zookeeper_f5381_0()
{    serverSideSocket.getLocalAddress();    assertFalse(serverSideSocket.isModeKnown());}
testGetPort
public void zookeeper_f5382_0()
{    serverSideSocket.getPort();    assertFalse(serverSideSocket.isModeKnown());}
testGetLocalPort
public void zookeeper_f5383_0()
{    serverSideSocket.getLocalPort();    assertFalse(serverSideSocket.isModeKnown());}
testGetRemoteSocketAddress
public void zookeeper_f5384_0()
{    serverSideSocket.getRemoteSocketAddress();    assertFalse(serverSideSocket.isModeKnown());}
testGetLocalSocketAddress
public void zookeeper_f5385_0()
{    serverSideSocket.getLocalSocketAddress();    assertFalse(serverSideSocket.isModeKnown());}
testGetInputStream
public void zookeeper_f5386_0() throws IOException
{    serverSideSocket.getInputStream();    assertFalse(serverSideSocket.isModeKnown());}
testGetOutputStream
public void zookeeper_f5387_0() throws IOException
{    serverSideSocket.getOutputStream();    assertFalse(serverSideSocket.isModeKnown());}
testGetTcpNoDelay
public void zookeeper_f5388_0() throws IOException
{    serverSideSocket.getTcpNoDelay();    assertFalse(serverSideSocket.isModeKnown());}
testSetTcpNoDelay
public void zookeeper_f5389_0() throws IOException
{    boolean tcpNoDelay = serverSideSocket.getTcpNoDelay();    tcpNoDelay = !tcpNoDelay;    serverSideSocket.setTcpNoDelay(tcpNoDelay);    assertFalse(serverSideSocket.isModeKnown());    assertEquals(tcpNoDelay, serverSideSocket.getTcpNoDelay());}
testGetSoLinger
public void zookeeper_f5390_0() throws IOException
{    serverSideSocket.getSoLinger();    assertFalse(serverSideSocket.isModeKnown());}
testSetSoLinger
public void zookeeper_f5391_0() throws IOException
{    int soLinger = serverSideSocket.getSoLinger();    if (soLinger == -1) {                serverSideSocket.setSoLinger(true, 1);        assertFalse(serverSideSocket.isModeKnown());        assertEquals(1, serverSideSocket.getSoLinger());    } else {                serverSideSocket.setSoLinger(false, -1);        assertFalse(serverSideSocket.isModeKnown());        assertEquals(-1, serverSideSocket.getSoLinger());    }}
testGetSoTimeout
public void zookeeper_f5392_0() throws IOException
{    serverSideSocket.getSoTimeout();    assertFalse(serverSideSocket.isModeKnown());}
testSetSoTimeout
public void zookeeper_f5393_0() throws IOException
{    int timeout = serverSideSocket.getSoTimeout();    timeout = timeout + 10;    serverSideSocket.setSoTimeout(timeout);    assertFalse(serverSideSocket.isModeKnown());    assertEquals(timeout, serverSideSocket.getSoTimeout());}
testGetSendBufferSize
public void zookeeper_f5394_0() throws IOException
{    serverSideSocket.getSendBufferSize();    assertFalse(serverSideSocket.isModeKnown());}
testSetSendBufferSize
public void zookeeper_f5395_0() throws IOException
{    serverSideSocket.setSendBufferSize(serverSideSocket.getSendBufferSize() + 1024);    assertFalse(serverSideSocket.isModeKnown());}
testGetReceiveBufferSize
public void zookeeper_f5396_0() throws IOException
{    serverSideSocket.getReceiveBufferSize();    assertFalse(serverSideSocket.isModeKnown());}
testSetReceiveBufferSize
public void zookeeper_f5397_0() throws IOException
{    serverSideSocket.setReceiveBufferSize(serverSideSocket.getReceiveBufferSize() + 1024);    assertFalse(serverSideSocket.isModeKnown());}
testGetKeepAlive
public void zookeeper_f5398_0() throws IOException
{    serverSideSocket.getKeepAlive();    assertFalse(serverSideSocket.isModeKnown());}
testSetKeepAlive
public void zookeeper_f5399_0() throws IOException
{    boolean keepAlive = serverSideSocket.getKeepAlive();    keepAlive = !keepAlive;    serverSideSocket.setKeepAlive(keepAlive);    assertFalse(serverSideSocket.isModeKnown());    assertEquals(keepAlive, serverSideSocket.getKeepAlive());}
testGetTrafficClass
public void zookeeper_f5400_0() throws IOException
{    serverSideSocket.getTrafficClass();    assertFalse(serverSideSocket.isModeKnown());}
testSetTrafficClass
public void zookeeper_f5401_0() throws IOException
{    serverSideSocket.setTrafficClass(SocketOptions.IP_TOS);    assertFalse(serverSideSocket.isModeKnown());}
testGetReuseAddress
public void zookeeper_f5402_0() throws IOException
{    serverSideSocket.getReuseAddress();    assertFalse(serverSideSocket.isModeKnown());}
testSetReuseAddress
public void zookeeper_f5403_0() throws IOException
{    boolean reuseAddress = serverSideSocket.getReuseAddress();    reuseAddress = !reuseAddress;    serverSideSocket.setReuseAddress(reuseAddress);    assertFalse(serverSideSocket.isModeKnown());    assertEquals(reuseAddress, serverSideSocket.getReuseAddress());}
testClose
public void zookeeper_f5404_0() throws IOException
{    serverSideSocket.close();    assertFalse(serverSideSocket.isModeKnown());}
testShutdownInput
public void zookeeper_f5405_0() throws IOException
{    serverSideSocket.shutdownInput();    assertFalse(serverSideSocket.isModeKnown());}
testShutdownOutput
public void zookeeper_f5406_0() throws IOException
{    serverSideSocket.shutdownOutput();    assertFalse(serverSideSocket.isModeKnown());}
testIsConnected
public void zookeeper_f5407_0()
{    serverSideSocket.isConnected();    assertFalse(serverSideSocket.isModeKnown());}
testIsBound
public void zookeeper_f5408_0()
{    serverSideSocket.isBound();    assertFalse(serverSideSocket.isModeKnown());}
testIsClosed
public void zookeeper_f5409_0()
{    serverSideSocket.isClosed();    assertFalse(serverSideSocket.isModeKnown());}
testIsInputShutdown
public void zookeeper_f5410_0() throws IOException
{    serverSideSocket.isInputShutdown();    assertFalse(serverSideSocket.isModeKnown());    serverSideSocket.shutdownInput();    assertTrue(serverSideSocket.isInputShutdown());}
testIsOutputShutdown
public void zookeeper_f5411_0() throws IOException
{    serverSideSocket.isOutputShutdown();    assertFalse(serverSideSocket.isModeKnown());    serverSideSocket.shutdownOutput();    assertTrue(serverSideSocket.isOutputShutdown());}
params
public static Collection<Object[]> zookeeper_f5412_0()
{    ArrayList<Object[]> result = new ArrayList<>();    int paramIndex = 0;    for (X509KeyType caKeyType : X509KeyType.values()) {        for (X509KeyType certKeyType : X509KeyType.values()) {            for (Boolean hostnameVerification : new Boolean[] { true, false }) {                result.add(new Object[] { caKeyType, certKeyType, hostnameVerification, paramIndex++ });            }        }    }    return result;}
setUp
public void zookeeper_f5413_0() throws Exception
{    localServerAddress = new InetSocketAddress(InetAddress.getLoopbackAddress(), PortAssignment.unique());    x509Util = new ClientX509Util();    x509TestContext.setSystemProperties(x509Util, KeyStoreFileType.JKS, KeyStoreFileType.JKS);}
tearDown
public void zookeeper_f5414_0() throws Exception
{    x509TestContext.clearSystemProperties(x509Util);    x509Util.close();}
forceClose
private static void zookeeper_f5415_0(Socket s)
{    if (s == null || s.isClosed()) {        return;    }    try {        s.close();    } catch (IOException e) {    }}
forceClose
private static void zookeeper_f5416_0(ServerSocket s)
{    if (s == null || s.isClosed()) {        return;    }    try {        s.close();    } catch (IOException e) {    }}
run
public void zookeeper_f5417_0()
{    try {        Random rnd = new Random();        while (true) {            final Socket unifiedSocket = serverSocket.accept();            final boolean tcpNoDelay = rnd.nextBoolean();            unifiedSocket.setTcpNoDelay(tcpNoDelay);            unifiedSocket.setSoTimeout(TIMEOUT);            final boolean keepAlive = rnd.nextBoolean();            unifiedSocket.setKeepAlive(keepAlive);                        BufferedInputStream bis = new BufferedInputStream(unifiedSocket.getInputStream());            workerPool.submit(new Runnable() {                @Override                public void run() {                    try {                        byte[] buf = new byte[1024];                        int bytesRead = unifiedSocket.getInputStream().read(buf, 0, 1024);                                                                        assertEquals(tcpNoDelay, unifiedSocket.getTcpNoDelay());                        assertEquals(TIMEOUT, unifiedSocket.getSoTimeout());                        assertEquals(keepAlive, unifiedSocket.getKeepAlive());                        if (bytesRead > 0) {                            byte[] dataFromClient = new byte[bytesRead];                            System.arraycopy(buf, 0, dataFromClient, 0, bytesRead);                            synchronized (dataFromClients) {                                dataFromClients.add(dataFromClient);                            }                        }                        unifiedSocket.getOutputStream().write(dataToClient);                        unifiedSocket.getOutputStream().flush();                    } catch (IOException e) {                        throw new RuntimeException(e);                    } finally {                        forceClose(unifiedSocket);                    }                }            });        }    } catch (IOException e) {        throw new RuntimeException(e);    } finally {        forceClose(serverSocket);        workerPool.shutdown();    }}
run
public void zookeeper_f5418_0()
{    try {        byte[] buf = new byte[1024];        int bytesRead = unifiedSocket.getInputStream().read(buf, 0, 1024);                        assertEquals(tcpNoDelay, unifiedSocket.getTcpNoDelay());        assertEquals(TIMEOUT, unifiedSocket.getSoTimeout());        assertEquals(keepAlive, unifiedSocket.getKeepAlive());        if (bytesRead > 0) {            byte[] dataFromClient = new byte[bytesRead];            System.arraycopy(buf, 0, dataFromClient, 0, bytesRead);            synchronized (dataFromClients) {                dataFromClients.add(dataFromClient);            }        }        unifiedSocket.getOutputStream().write(dataToClient);        unifiedSocket.getOutputStream().flush();    } catch (IOException e) {        throw new RuntimeException(e);    } finally {        forceClose(unifiedSocket);    }}
shutdown
public void zookeeper_f5419_0(long millis) throws InterruptedException
{        forceClose(serverSocket);    workerPool.awaitTermination(millis, TimeUnit.MILLISECONDS);    this.join(millis);}
getDataFromClient
 synchronized byte[] zookeeper_f5420_0(int index)
{    return dataFromClients.get(index);}
receivedAnyDataFromClient
 synchronized boolean zookeeper_f5421_0()
{    return !dataFromClients.isEmpty();}
connectWithSSL
private SSLSocket zookeeper_f5422_0() throws IOException, X509Exception, InterruptedException
{    SSLSocket sslSocket = null;    int retries = 0;    while (retries < MAX_RETRIES) {        try {            sslSocket = x509Util.createSSLSocket();            sslSocket.addHandshakeCompletedListener(new HandshakeCompletedListener() {                @Override                public void handshakeCompleted(HandshakeCompletedEvent handshakeCompletedEvent) {                    synchronized (handshakeCompletedLock) {                        handshakeCompleted = true;                        handshakeCompletedLock.notifyAll();                    }                }            });            sslSocket.setSoTimeout(TIMEOUT);            sslSocket.connect(localServerAddress, TIMEOUT);            break;        } catch (ConnectException connectException) {            connectException.printStackTrace();            forceClose(sslSocket);            sslSocket = null;            Thread.sleep(TIMEOUT);        }        retries++;    }    assertNotNull("Failed to connect to server with SSL", sslSocket);    return sslSocket;}
handshakeCompleted
public void zookeeper_f5423_0(HandshakeCompletedEvent handshakeCompletedEvent)
{    synchronized (handshakeCompletedLock) {        handshakeCompleted = true;        handshakeCompletedLock.notifyAll();    }}
connectWithoutSSL
private Socket zookeeper_f5424_0() throws IOException, InterruptedException
{    Socket socket = null;    int retries = 0;    while (retries < MAX_RETRIES) {        try {            socket = new Socket();            socket.setSoTimeout(TIMEOUT);            socket.connect(localServerAddress, TIMEOUT);            break;        } catch (ConnectException connectException) {            connectException.printStackTrace();            forceClose(socket);            socket = null;            Thread.sleep(TIMEOUT);        }        retries++;    }    assertNotNull("Failed to connect to server without SSL", socket);    return socket;}
testConnectWithSSLToNonStrictServer
public void zookeeper_f5425_0() throws Exception
{    UnifiedServerThread serverThread = new UnifiedServerThread(x509Util, localServerAddress, true, DATA_TO_CLIENT);    serverThread.start();    Socket sslSocket = connectWithSSL();    try {        sslSocket.getOutputStream().write(DATA_FROM_CLIENT);        sslSocket.getOutputStream().flush();        byte[] buf = new byte[DATA_TO_CLIENT.length];        int bytesRead = sslSocket.getInputStream().read(buf, 0, buf.length);        assertEquals(buf.length, bytesRead);        assertArrayEquals(DATA_TO_CLIENT, buf);        synchronized (handshakeCompletedLock) {            if (!handshakeCompleted) {                handshakeCompletedLock.wait(TIMEOUT);            }            assertTrue(handshakeCompleted);        }        assertArrayEquals(DATA_FROM_CLIENT, serverThread.getDataFromClient(0));    } finally {        forceClose(sslSocket);        serverThread.shutdown(TIMEOUT);    }}
testConnectWithSSLToStrictServer
public void zookeeper_f5426_0() throws Exception
{    UnifiedServerThread serverThread = new UnifiedServerThread(x509Util, localServerAddress, false, DATA_TO_CLIENT);    serverThread.start();    Socket sslSocket = connectWithSSL();    try {        sslSocket.getOutputStream().write(DATA_FROM_CLIENT);        sslSocket.getOutputStream().flush();        byte[] buf = new byte[DATA_TO_CLIENT.length];        int bytesRead = sslSocket.getInputStream().read(buf, 0, buf.length);        assertEquals(buf.length, bytesRead);        assertArrayEquals(DATA_TO_CLIENT, buf);        synchronized (handshakeCompletedLock) {            if (!handshakeCompleted) {                handshakeCompletedLock.wait(TIMEOUT);            }            assertTrue(handshakeCompleted);        }        assertArrayEquals(DATA_FROM_CLIENT, serverThread.getDataFromClient(0));    } finally {        forceClose(sslSocket);        serverThread.shutdown(TIMEOUT);    }}
testConnectWithoutSSLToNonStrictServer
public void zookeeper_f5427_0() throws Exception
{    UnifiedServerThread serverThread = new UnifiedServerThread(x509Util, localServerAddress, true, DATA_TO_CLIENT);    serverThread.start();    Socket socket = connectWithoutSSL();    try {        socket.getOutputStream().write(DATA_FROM_CLIENT);        socket.getOutputStream().flush();        byte[] buf = new byte[DATA_TO_CLIENT.length];        int bytesRead = socket.getInputStream().read(buf, 0, buf.length);        assertEquals(buf.length, bytesRead);        assertArrayEquals(DATA_TO_CLIENT, buf);        assertArrayEquals(DATA_FROM_CLIENT, serverThread.getDataFromClient(0));    } finally {        forceClose(socket);        serverThread.shutdown(TIMEOUT);    }}
testConnectWithoutSSLToNonStrictServerPartialWrite
public void zookeeper_f5428_0() throws Exception
{    UnifiedServerThread serverThread = new UnifiedServerThread(x509Util, localServerAddress, true, DATA_TO_CLIENT);    serverThread.start();    Socket socket = connectWithoutSSL();    try {                                socket.getOutputStream().write(DATA_FROM_CLIENT, 0, 2);        socket.getOutputStream().flush();        Thread.sleep(TIMEOUT / 2);        socket.getOutputStream().write(DATA_FROM_CLIENT, 2, DATA_FROM_CLIENT.length - 2);        socket.getOutputStream().flush();        byte[] buf = new byte[DATA_TO_CLIENT.length];        int bytesRead = socket.getInputStream().read(buf, 0, buf.length);        assertEquals(buf.length, bytesRead);        assertArrayEquals(DATA_TO_CLIENT, buf);        assertArrayEquals(DATA_FROM_CLIENT, serverThread.getDataFromClient(0));    } finally {        forceClose(socket);        serverThread.shutdown(TIMEOUT);    }}
testConnectWithoutSSLToStrictServer
public void zookeeper_f5429_0() throws Exception
{    UnifiedServerThread serverThread = new UnifiedServerThread(x509Util, localServerAddress, false, DATA_TO_CLIENT);    serverThread.start();    Socket socket = connectWithoutSSL();    socket.getOutputStream().write(DATA_FROM_CLIENT);    socket.getOutputStream().flush();    byte[] buf = new byte[DATA_TO_CLIENT.length];    try {        int bytesRead = socket.getInputStream().read(buf, 0, buf.length);        if (bytesRead == -1) {                        return;        }    } catch (SocketException e) {                return;    } finally {        forceClose(socket);        serverThread.shutdown(TIMEOUT);                        assertFalse("The strict server accepted connection without SSL.", serverThread.receivedAnyDataFromClient());    }    fail("Expected server to hang up the connection. Read from server succeeded unexpectedly.");}
testTLSDetectionNonBlockingNonStrictServerIdleClient
public void zookeeper_f5430_0() throws Exception
{    Socket badClientSocket = null;    Socket clientSocket = null;    Socket secureClientSocket = null;    UnifiedServerThread serverThread = new UnifiedServerThread(x509Util, localServerAddress, true, DATA_TO_CLIENT);    serverThread.start();    try {                badClientSocket = connectWithoutSSL();        clientSocket = connectWithoutSSL();        clientSocket.getOutputStream().write(DATA_FROM_CLIENT);        clientSocket.getOutputStream().flush();        byte[] buf = new byte[DATA_TO_CLIENT.length];        int bytesRead = clientSocket.getInputStream().read(buf, 0, buf.length);        assertEquals(buf.length, bytesRead);        assertArrayEquals(DATA_TO_CLIENT, buf);        assertArrayEquals(DATA_FROM_CLIENT, serverThread.getDataFromClient(0));        synchronized (handshakeCompletedLock) {            assertFalse(handshakeCompleted);        }        secureClientSocket = connectWithSSL();        secureClientSocket.getOutputStream().write(DATA_FROM_CLIENT);        secureClientSocket.getOutputStream().flush();        buf = new byte[DATA_TO_CLIENT.length];        bytesRead = secureClientSocket.getInputStream().read(buf, 0, buf.length);        assertEquals(buf.length, bytesRead);        assertArrayEquals(DATA_TO_CLIENT, buf);        assertArrayEquals(DATA_FROM_CLIENT, serverThread.getDataFromClient(1));        synchronized (handshakeCompletedLock) {            if (!handshakeCompleted) {                handshakeCompletedLock.wait(TIMEOUT);            }            assertTrue(handshakeCompleted);        }    } finally {        forceClose(badClientSocket);        forceClose(clientSocket);        forceClose(secureClientSocket);        serverThread.shutdown(TIMEOUT);    }}
testTLSDetectionNonBlockingStrictServerIdleClient
public void zookeeper_f5431_0() throws Exception
{    Socket badClientSocket = null;    Socket secureClientSocket = null;    UnifiedServerThread serverThread = new UnifiedServerThread(x509Util, localServerAddress, false, DATA_TO_CLIENT);    serverThread.start();    try {                badClientSocket = connectWithoutSSL();        secureClientSocket = connectWithSSL();        secureClientSocket.getOutputStream().write(DATA_FROM_CLIENT);        secureClientSocket.getOutputStream().flush();        byte[] buf = new byte[DATA_TO_CLIENT.length];        int bytesRead = secureClientSocket.getInputStream().read(buf, 0, buf.length);        assertEquals(buf.length, bytesRead);        assertArrayEquals(DATA_TO_CLIENT, buf);        synchronized (handshakeCompletedLock) {            if (!handshakeCompleted) {                handshakeCompletedLock.wait(TIMEOUT);            }            assertTrue(handshakeCompleted);        }        assertArrayEquals(DATA_FROM_CLIENT, serverThread.getDataFromClient(0));    } finally {        forceClose(badClientSocket);        forceClose(secureClientSocket);        serverThread.shutdown(TIMEOUT);    }}
testTLSDetectionNonBlockingNonStrictServerDisconnectedClient
public void zookeeper_f5432_0() throws Exception
{    Socket clientSocket = null;    Socket secureClientSocket = null;    UnifiedServerThread serverThread = new UnifiedServerThread(x509Util, localServerAddress, true, DATA_TO_CLIENT);    serverThread.start();    try {        Socket badClientSocket = connectWithoutSSL();                forceClose(badClientSocket);        clientSocket = connectWithoutSSL();        clientSocket.getOutputStream().write(DATA_FROM_CLIENT);        clientSocket.getOutputStream().flush();        byte[] buf = new byte[DATA_TO_CLIENT.length];        int bytesRead = clientSocket.getInputStream().read(buf, 0, buf.length);        assertEquals(buf.length, bytesRead);        assertArrayEquals(DATA_TO_CLIENT, buf);        assertArrayEquals(DATA_FROM_CLIENT, serverThread.getDataFromClient(0));        synchronized (handshakeCompletedLock) {            assertFalse(handshakeCompleted);        }        secureClientSocket = connectWithSSL();        secureClientSocket.getOutputStream().write(DATA_FROM_CLIENT);        secureClientSocket.getOutputStream().flush();        buf = new byte[DATA_TO_CLIENT.length];        bytesRead = secureClientSocket.getInputStream().read(buf, 0, buf.length);        assertEquals(buf.length, bytesRead);        assertArrayEquals(DATA_TO_CLIENT, buf);        assertArrayEquals(DATA_FROM_CLIENT, serverThread.getDataFromClient(1));        synchronized (handshakeCompletedLock) {            if (!handshakeCompleted) {                handshakeCompletedLock.wait(TIMEOUT);            }            assertTrue(handshakeCompleted);        }    } finally {        forceClose(clientSocket);        forceClose(secureClientSocket);        serverThread.shutdown(TIMEOUT);    }}
testTLSDetectionNonBlockingStrictServerDisconnectedClient
public void zookeeper_f5433_0() throws Exception
{    Socket secureClientSocket = null;    UnifiedServerThread serverThread = new UnifiedServerThread(x509Util, localServerAddress, false, DATA_TO_CLIENT);    serverThread.start();    try {        Socket badClientSocket = connectWithoutSSL();                forceClose(badClientSocket);        secureClientSocket = connectWithSSL();        secureClientSocket.getOutputStream().write(DATA_FROM_CLIENT);        secureClientSocket.getOutputStream().flush();        byte[] buf = new byte[DATA_TO_CLIENT.length];        int bytesRead = secureClientSocket.getInputStream().read(buf, 0, buf.length);        assertEquals(buf.length, bytesRead);        assertArrayEquals(DATA_TO_CLIENT, buf);        synchronized (handshakeCompletedLock) {            if (!handshakeCompleted) {                handshakeCompletedLock.wait(TIMEOUT);            }            assertTrue(handshakeCompleted);        }        assertArrayEquals(DATA_FROM_CLIENT, serverThread.getDataFromClient(0));    } finally {        forceClose(secureClientSocket);        serverThread.shutdown(TIMEOUT);    }}
setUp
public void zookeeper_f5434_0()
{    System.setProperty("zookeeper.admin.enableServer", "false");}
configs
public static Collection<Object[]> zookeeper_f5435_0()
{    return Arrays.asList(new Object[][] { { false }, { true } });}
testWatchesLeak
public voidf5436_1) throws Exception
{    NIOServerCnxnFactory serverCnxnFactory = mock(NIOServerCnxnFactory.class);    final SelectionKey sk = new FakeSK();    MockSelectorThread selectorThread = mock(MockSelectorThread.class);    when(selectorThread.addInterestOpsUpdateRequest(any(SelectionKey.class))).thenAnswer(new Answer<Boolean>() {        @Override        public Boolean answer(InvocationOnMock invocation) throws Throwable {            SelectionKey sk = (SelectionKey) invocation.getArguments()[0];            NIOServerCnxn nioSrvCnx = (NIOServerCnxn) sk.attachment();            sk.interestOps(nioSrvCnx.getInterestOps());            return true;        }    });    ZKDatabase database = new ZKDatabase(null);    database.setlastProcessedZxid(2L);    QuorumPeer quorumPeer = mock(QuorumPeer.class);    FileTxnSnapLog logfactory = mock(FileTxnSnapLog.class);        when(logfactory.getDataDir()).thenReturn(new File(""));    when(logfactory.getSnapDir()).thenReturn(new File(""));    FollowerZooKeeperServer fzks = null;    try {                fzks = new FollowerZooKeeperServer(logfactory, quorumPeer, database);        fzks.startup();        fzks.setServerCnxnFactory(serverCnxnFactory);        quorumPeer.follower = new MyFollower(quorumPeer, fzks);                        final SocketChannel socketChannel = createClientSocketChannel();                final MockNIOServerCnxn nioCnxn = new MockNIOServerCnxn(fzks, socketChannel, sk, serverCnxnFactory, selectorThread);        sk.attach(nioCnxn);                nioCnxn.doIO(sk);                        QuorumPacket qp = createValidateSessionPacketResponse(!sessionTimedout);        quorumPeer.follower.processPacket(qp);                                nioCnxn.doIO(sk);                Thread.sleep(1000L);                        int watchCount = database.getDataTree().getWatchCount();        if (sessionTimedout) {                                    assertEquals("Session is not valid so there should be no watches", 0, watchCount);        } else {                                    assertEquals("Session is valid so the watch should be there", 1, watchCount);        }    } finally {        if (fzks != null) {            fzks.shutdown();        }    }}
answer
public Boolean zookeeper_f5437_0(InvocationOnMock invocation) throws Throwable
{    SelectionKey sk = (SelectionKey) invocation.getArguments()[0];    NIOServerCnxn nioSrvCnx = (NIOServerCnxn) sk.attachment();    sk.interestOps(nioSrvCnx.getInterestOps());    return true;}
channel
public SelectableChannel zookeeper_f5438_0()
{    return null;}
selector
public Selector zookeeper_f5439_0()
{    return mock(Selector.class);}
isValid
public boolean zookeeper_f5440_0()
{    return true;}
cancel
public void zookeeper_f5441_0()
{}
interestOps
public int zookeeper_f5442_0()
{    return ops;}
interestOps
public SelectionKey zookeeper_f5443_0(int ops)
{    this.ops = ops;    return this;}
readyOps
public intf5444_1)
{    boolean reading = (ops & OP_READ) != 0;    boolean writing = (ops & OP_WRITE) != 0;    if (reading && writing) {            } else if (reading) {            } else if (writing) {            }    return ops;}
createWatchesMessage
private ByteBuffer zookeeper_f5445_0()
{    List<String> dataWatches = new ArrayList<String>(1);    dataWatches.add("/");    List<String> existWatches = Collections.emptyList();    List<String> childWatches = Collections.emptyList();    SetWatches sw = new SetWatches(1L, dataWatches, existWatches, childWatches);    RequestHeader h = new RequestHeader();    h.setType(ZooDefs.OpCode.setWatches);    h.setXid(-8);    MockPacket p = new MockPacket(h, new ReplyHeader(), sw, null, null);    return p.createAndReturnBB();}
createConnRequest
private ByteBuffer zookeeper_f5446_0()
{    Random r = new Random(SESSION_ID ^ superSecret);    byte[] p = new byte[16];    r.nextBytes(p);    ConnectRequest conReq = new ConnectRequest(0, 1L, 30000, SESSION_ID, p);    MockPacket packet = new MockPacket(null, null, conReq, null, null, false);    return packet.createAndReturnBB();}
createClientSocketChannel
private SocketChannel zookeeper_f5447_0() throws IOException
{    SocketChannel socketChannel = mock(SocketChannel.class);    Socket socket = mock(Socket.class);    InetSocketAddress socketAddress = new InetSocketAddress(1234);    when(socket.getRemoteSocketAddress()).thenReturn(socketAddress);    when(socketChannel.socket()).thenReturn(socket);        final ByteBuffer connRequest = createConnRequest();    final ByteBuffer watchesMessage = createWatchesMessage();    final ByteBuffer request = ByteBuffer.allocate(connRequest.limit() + watchesMessage.limit());    request.put(connRequest);    request.put(watchesMessage);    Answer<Integer> answer = new Answer<Integer>() {        int i = 0;        @Override        public Integer answer(InvocationOnMock invocation) throws Throwable {            Object[] args = invocation.getArguments();            ByteBuffer bb = (ByteBuffer) args[0];            for (int k = 0; k < bb.limit(); k++) {                bb.put(request.get(i));                i = i + 1;            }            return bb.limit();        }    };    when(socketChannel.read(any(ByteBuffer.class))).thenAnswer(answer);    return socketChannel;}
answer
public Integer zookeeper_f5448_0(InvocationOnMock invocation) throws Throwable
{    Object[] args = invocation.getArguments();    ByteBuffer bb = (ByteBuffer) args[0];    for (int k = 0; k < bb.limit(); k++) {        bb.put(request.get(i));        i = i + 1;    }    return bb.limit();}
createValidateSessionPacketResponse
private QuorumPacket zookeeper_f5449_0(boolean valid) throws Exception
{    QuorumPacket qp = createValidateSessionPacket();    ByteArrayInputStream bis = new ByteArrayInputStream(qp.getData());    DataInputStream dis = new DataInputStream(bis);    long id = dis.readLong();    ByteArrayOutputStream bos = new ByteArrayOutputStream();    DataOutputStream dos = new DataOutputStream(bos);    dos.writeLong(id);        dos.writeBoolean(valid);    qp.setData(bos.toByteArray());    return qp;}
createValidateSessionPacket
private QuorumPacket zookeeper_f5450_0() throws Exception
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    DataOutputStream dos = new DataOutputStream(baos);    dos.writeLong(SESSION_ID);    dos.writeInt(3000);    dos.close();    QuorumPacket qp = new QuorumPacket(Leader.REVALIDATE, -1, baos.toByteArray(), null);    return qp;}
setUp
public void zookeeper_f5451_0()
{    System.setProperty("zookeeper.admin.enableServer", "false");}
run
public voidf5452_1)
{    try {        leader.lead();    } catch (InterruptedException e) {            } catch (Exception e) {            } finally {        leader.shutdown("lead ended");    }}
run
public void zookeeper_f5453_0()
{    if (onlyGetEpochToPropose) {        try {            epoch = leader.getEpochToPropose(followerSid, 0);        } catch (Exception e) {        }    } else {        try {            leader.waitForEpochAck(followerSid, new StateSummary(0, 0));            msg = "FollowerMockThread (id = " + followerSid + ")  returned from waitForEpochAck";        } catch (Exception e) {        }    }}
testLeaderInConnectingFollowers
public void zookeeper_f5454_0() throws Exception
{    File tmpDir = File.createTempFile("test", "dir", testData);    tmpDir.delete();    tmpDir.mkdir();    Leader leader = null;    try {        QuorumPeer peer = createQuorumPeer(tmpDir);        leader = createLeader(tmpDir, peer);        peer.leader = leader;        peer.setAcceptedEpoch(5);        FollowerMockThread f1 = new FollowerMockThread(1, leader, true);        FollowerMockThread f2 = new FollowerMockThread(2, leader, true);        f1.start();        f2.start();                                f1.join(leader.self.getInitLimit() * leader.self.getTickTime() + 5000);        f2.join(leader.self.getInitLimit() * leader.self.getTickTime() + 5000);                try {            long epoch = leader.getEpochToPropose(leader.self.getId(), leader.self.getAcceptedEpoch());            assertEquals("leader got wrong epoch from getEpochToPropose", 6, epoch);        } catch (Exception e) {            fail("leader timed out in getEpochToPropose");        }    } finally {        if (leader != null) {            leader.shutdown("end of test");        }        TestUtils.deleteFileRecursively(tmpDir);    }}
testLastAcceptedEpoch
public void zookeeper_f5455_0() throws Exception
{    File tmpDir = File.createTempFile("test", "dir", testData);    tmpDir.delete();    tmpDir.mkdir();    Leader leader = null;    LeadThread leadThread = null;    try {        QuorumPeer peer = createQuorumPeer(tmpDir);        leader = createMockLeader(tmpDir, peer);        peer.leader = leader;        peer.setAcceptedEpoch(5);        leadThread = new LeadThread(leader);        leadThread.start();        while (((MockLeader) leader).getCurrentEpochToPropose() != 6) {            Thread.sleep(20);        }        try {            long epoch = leader.getEpochToPropose(1, 6);            assertEquals("New proposed epoch is wrong", 7, epoch);        } catch (Exception e) {            fail("Timed out in getEpochToPropose");        }    } finally {        if (leader != null) {            leader.shutdown("end of test");        }        if (leadThread != null) {            leadThread.interrupt();            leadThread.join();        }        TestUtils.deleteFileRecursively(tmpDir);    }}
testLeaderInElectingFollowers
public void zookeeper_f5456_0() throws Exception
{    File tmpDir = File.createTempFile("test", "dir", testData);    tmpDir.delete();    tmpDir.mkdir();    Leader leader = null;    try {        QuorumPeer peer = createQuorumPeer(tmpDir);        leader = createLeader(tmpDir, peer);        peer.leader = leader;        FollowerMockThread f1 = new FollowerMockThread(1, leader, false);        FollowerMockThread f2 = new FollowerMockThread(2, leader, false);                leader.leaderStateSummary = new StateSummary(leader.self.getCurrentEpoch(), leader.zk.getLastProcessedZxid());        f1.start();        f2.start();                        f1.join(leader.self.getInitLimit() * leader.self.getTickTime() + 5000);        f2.join(leader.self.getInitLimit() * leader.self.getTickTime() + 5000);                assertTrue(f1.msg + " without waiting for leader", f1.msg == null);        assertTrue(f2.msg + " without waiting for leader", f2.msg == null);    } finally {        if (leader != null) {            leader.shutdown("end of test");        }        TestUtils.deleteFileRecursively(tmpDir);    }}
getSocketPair
 static Socket[] zookeeper_f5457_0() throws IOException
{    ServerSocket ss = new ServerSocket(0, 50, InetAddress.getByName("127.0.0.1"));    InetSocketAddress endPoint = (InetSocketAddress) ss.getLocalSocketAddress();    Socket s = new Socket(endPoint.getAddress(), endPoint.getPort());    return new Socket[] { s, ss.accept() };}
readPacketSkippingPing
 static void zookeeper_f5458_0(InputArchive ia, QuorumPacket qp) throws IOException
{    while (true) {        ia.readRecord(qp, null);        if (qp.getType() != Leader.PING) {            return;        }    }}
testLeaderConversation
public void zookeeper_f5459_0(LeaderConversation conversation) throws Exception
{    Socket[] pair = getSocketPair();    Socket leaderSocket = pair[0];    Socket followerSocket = pair[1];    File tmpDir = File.createTempFile("test", "dir", testData);    tmpDir.delete();    tmpDir.mkdir();    LeadThread leadThread = null;    Leader leader = null;    try {        QuorumPeer peer = createQuorumPeer(tmpDir);        leader = createLeader(tmpDir, peer);        peer.leader = leader;        leadThread = new LeadThread(leader);        leadThread.start();        while (leader.cnxAcceptor == null || !leader.cnxAcceptor.isAlive()) {            Thread.sleep(20);        }        LearnerHandler lh = new LearnerHandler(leaderSocket, new BufferedInputStream(leaderSocket.getInputStream()), leader);        lh.start();        leaderSocket.setSoTimeout(4000);        InputArchive ia = BinaryInputArchive.getArchive(followerSocket.getInputStream());        OutputArchive oa = BinaryOutputArchive.getArchive(followerSocket.getOutputStream());        conversation.converseWithLeader(ia, oa, leader);    } finally {        if (leader != null) {            leader.shutdown("end of test");        }        if (leadThread != null) {            leadThread.interrupt();            leadThread.join();        }        TestUtils.deleteFileRecursively(tmpDir);    }}
testPopulatedLeaderConversation
public void zookeeper_f5460_0(PopulatedLeaderConversation conversation, int ops) throws Exception
{    Socket[] pair = getSocketPair();    Socket leaderSocket = pair[0];    Socket followerSocket = pair[1];    File tmpDir = File.createTempFile("test", "dir", testData);    tmpDir.delete();    tmpDir.mkdir();    LeadThread leadThread = null;    Leader leader = null;    try {                FileTxnSnapLog snapLog = new FileTxnSnapLog(tmpDir, tmpDir);        ZKDatabase zkDb = new ZKDatabase(snapLog);        assertTrue(ops >= 1);        long zxid = ZxidUtils.makeZxid(1, 0);        for (int i = 1; i <= ops; i++) {            zxid = ZxidUtils.makeZxid(1, i);            String path = "/foo-" + i;            zkDb.processTxn(new TxnHeader(13, 1000 + i, zxid, 30 + i, ZooDefs.OpCode.create), new CreateTxn(path, "fpjwasalsohere".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, false, 1));            Stat stat = new Stat();            assertEquals("fpjwasalsohere", new String(zkDb.getData(path, stat, null)));        }        assertTrue(zxid > ZxidUtils.makeZxid(1, 0));                snapLog.save(zkDb.getDataTree(), zkDb.getSessionWithTimeOuts(), false);        snapLog.close();        QuorumPeer peer = createQuorumPeer(tmpDir);        leader = createLeader(tmpDir, peer);        peer.leader = leader;                peer.setAcceptedEpoch(1);        peer.setCurrentEpoch(1);        leadThread = new LeadThread(leader);        leadThread.start();        while (leader.cnxAcceptor == null || !leader.cnxAcceptor.isAlive()) {            Thread.sleep(20);        }        LearnerHandler lh = new LearnerHandler(leaderSocket, new BufferedInputStream(leaderSocket.getInputStream()), leader);        lh.start();        leaderSocket.setSoTimeout(4000);        InputArchive ia = BinaryInputArchive.getArchive(followerSocket.getInputStream());        OutputArchive oa = BinaryOutputArchive.getArchive(followerSocket.getOutputStream());        conversation.converseWithLeader(ia, oa, leader, zxid);    } finally {        if (leader != null) {            leader.shutdown("end of test");        }        if (leadThread != null) {            leadThread.interrupt();            leadThread.join();        }        TestUtils.deleteFileRecursively(tmpDir);    }}
testFollowerConversation
public voidf5461_1FollowerConversation conversation) throws Exception
{    File tmpDir = File.createTempFile("test", "dir", testData);    tmpDir.delete();    tmpDir.mkdir();    Thread followerThread = null;    ConversableFollower follower = null;    QuorumPeer peer = null;    try {        peer = createQuorumPeer(tmpDir);        follower = createFollower(tmpDir, peer);        peer.follower = follower;        ServerSocket ss = new ServerSocket(0, 50, InetAddress.getByName("127.0.0.1"));        QuorumServer leaderQS = new QuorumServer(1, (InetSocketAddress) ss.getLocalSocketAddress());        follower.setLeaderQuorumServer(leaderQS);        final Follower followerForThread = follower;        followerThread = new Thread() {            public void run() {                try {                    followerForThread.followLeader();                } catch (InterruptedException e) {                                    } catch (Exception e) {                                    }            }        };        followerThread.start();        Socket leaderSocket = ss.accept();        InputArchive ia = BinaryInputArchive.getArchive(leaderSocket.getInputStream());        OutputArchive oa = BinaryOutputArchive.getArchive(leaderSocket.getOutputStream());        conversation.converseWithFollower(ia, oa, follower);    } finally {        if (follower != null) {            follower.shutdown();        }        if (followerThread != null) {            followerThread.interrupt();            followerThread.join();        }        if (peer != null) {            peer.shutdown();        }        TestUtils.deleteFileRecursively(tmpDir);    }}
run
public voidf5462_1)
{    try {        followerForThread.followLeader();    } catch (InterruptedException e) {            } catch (Exception e) {            }}
testObserverConversation
public void zookeeper_f5463_0(ObserverConversation conversation) throws Exception
{    File tmpDir = File.createTempFile("test", "dir", testData);    tmpDir.delete();    tmpDir.mkdir();    Thread observerThread = null;    ConversableObserver observer = null;    QuorumPeer peer = null;    try {        peer = createQuorumPeer(tmpDir);        peer.setSyncEnabled(true);        observer = createObserver(tmpDir, peer);        peer.observer = observer;        ServerSocket ss = new ServerSocket(0, 50, InetAddress.getByName("127.0.0.1"));        QuorumServer leaderQS = new QuorumServer(1, (InetSocketAddress) ss.getLocalSocketAddress());        observer.setLeaderQuorumServer(leaderQS);        final Observer observerForThread = observer;        observerThread = new Thread() {            public void run() {                try {                    observerForThread.observeLeader();                } catch (Exception e) {                    e.printStackTrace();                }            }        };        observerThread.start();        Socket leaderSocket = ss.accept();        InputArchive ia = BinaryInputArchive.getArchive(leaderSocket.getInputStream());        OutputArchive oa = BinaryOutputArchive.getArchive(leaderSocket.getOutputStream());        conversation.converseWithObserver(ia, oa, observer);    } finally {        if (observer != null) {            observer.shutdown();        }        if (observerThread != null) {            observerThread.interrupt();            observerThread.join();        }        if (peer != null) {            peer.shutdown();        }        TestUtils.deleteFileRecursively(tmpDir);    }}
run
public void zookeeper_f5464_0()
{    try {        observerForThread.observeLeader();    } catch (Exception e) {        e.printStackTrace();    }}
testUnnecessarySnap
public void zookeeper_f5465_0() throws Exception
{    testPopulatedLeaderConversation(new PopulatedLeaderConversation() {        @Override        public void converseWithLeader(InputArchive ia, OutputArchive oa, Leader l, long zxid) throws Exception {            assertEquals(1, l.self.getAcceptedEpoch());            assertEquals(1, l.self.getCurrentEpoch());            /* we test a normal run. everything should work out well. */            LearnerInfo li = new LearnerInfo(1, 0x10000, 0);            byte[] liBytes = new byte[20];            ByteBufferOutputStream.record2ByteBuffer(li, ByteBuffer.wrap(liBytes));            QuorumPacket qp = new QuorumPacket(Leader.FOLLOWERINFO, 1, liBytes, null);            oa.writeRecord(qp, null);            readPacketSkippingPing(ia, qp);            assertEquals(Leader.LEADERINFO, qp.getType());            assertEquals(ZxidUtils.makeZxid(2, 0), qp.getZxid());            assertEquals(ByteBuffer.wrap(qp.getData()).getInt(), 0x10000);            assertEquals(2, l.self.getAcceptedEpoch());            assertEquals(1, l.self.getCurrentEpoch());            byte[] epochBytes = new byte[4];            final ByteBuffer wrappedEpochBytes = ByteBuffer.wrap(epochBytes);            wrappedEpochBytes.putInt(1);            qp = new QuorumPacket(Leader.ACKEPOCH, zxid, epochBytes, null);            oa.writeRecord(qp, null);            readPacketSkippingPing(ia, qp);            assertEquals(Leader.DIFF, qp.getType());        }    }, 2);}
converseWithLeader
public void zookeeper_f5466_0(InputArchive ia, OutputArchive oa, Leader l, long zxid) throws Exception
{    assertEquals(1, l.self.getAcceptedEpoch());    assertEquals(1, l.self.getCurrentEpoch());    /* we test a normal run. everything should work out well. */    LearnerInfo li = new LearnerInfo(1, 0x10000, 0);    byte[] liBytes = new byte[20];    ByteBufferOutputStream.record2ByteBuffer(li, ByteBuffer.wrap(liBytes));    QuorumPacket qp = new QuorumPacket(Leader.FOLLOWERINFO, 1, liBytes, null);    oa.writeRecord(qp, null);    readPacketSkippingPing(ia, qp);    assertEquals(Leader.LEADERINFO, qp.getType());    assertEquals(ZxidUtils.makeZxid(2, 0), qp.getZxid());    assertEquals(ByteBuffer.wrap(qp.getData()).getInt(), 0x10000);    assertEquals(2, l.self.getAcceptedEpoch());    assertEquals(1, l.self.getCurrentEpoch());    byte[] epochBytes = new byte[4];    final ByteBuffer wrappedEpochBytes = ByteBuffer.wrap(epochBytes);    wrappedEpochBytes.putInt(1);    qp = new QuorumPacket(Leader.ACKEPOCH, zxid, epochBytes, null);    oa.writeRecord(qp, null);    readPacketSkippingPing(ia, qp);    assertEquals(Leader.DIFF, qp.getType());}
waitForChange
 synchronized void zookeeper_f5467_0() throws InterruptedException
{    while (!changed) {        wait();    }}
process
public void zookeeper_f5468_0(WatchedEvent event)
{    if (event.getType() == EventType.NodeDataChanged) {        synchronized (this) {            changed = true;            notifyAll();        }    }}
changed
public synchronized boolean zookeeper_f5469_0()
{    return changed;}
testNormalFollowerRun
public void zookeeper_f5470_0() throws Exception
{    testFollowerConversation(new FollowerConversation() {        @Override        public void converseWithFollower(InputArchive ia, OutputArchive oa, Follower f) throws Exception {            File tmpDir = File.createTempFile("test", "dir", testData);            tmpDir.delete();            tmpDir.mkdir();            File logDir = f.fzk.getTxnLogFactory().getDataDir().getParentFile();            File snapDir = f.fzk.getTxnLogFactory().getSnapDir().getParentFile();                        f.zk = spy(f.zk);            try {                assertEquals(0, f.self.getAcceptedEpoch());                assertEquals(0, f.self.getCurrentEpoch());                                ZKDatabase zkDb = new ZKDatabase(new FileTxnSnapLog(tmpDir, tmpDir));                final long firstZxid = ZxidUtils.makeZxid(1, 1);                zkDb.processTxn(new TxnHeader(13, 1313, firstZxid, 33, ZooDefs.OpCode.create), new CreateTxn("/foo", "data1".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, false, 1));                Stat stat = new Stat();                assertEquals("data1", new String(zkDb.getData("/foo", stat, null)));                QuorumPacket qp = new QuorumPacket();                readPacketSkippingPing(ia, qp);                assertEquals(Leader.FOLLOWERINFO, qp.getType());                assertEquals(qp.getZxid(), 0);                LearnerInfo learnInfo = new LearnerInfo();                ByteBufferInputStream.byteBuffer2Record(ByteBuffer.wrap(qp.getData()), learnInfo);                assertEquals(learnInfo.getProtocolVersion(), 0x10000);                assertEquals(learnInfo.getServerid(), 0);                                qp.setType(Leader.LEADERINFO);                qp.setZxid(ZxidUtils.makeZxid(1, 0));                byte[] protoBytes = new byte[4];                ByteBuffer.wrap(protoBytes).putInt(0x10000);                qp.setData(protoBytes);                oa.writeRecord(qp, null);                readPacketSkippingPing(ia, qp);                assertEquals(Leader.ACKEPOCH, qp.getType());                assertEquals(0, qp.getZxid());                assertEquals(ZxidUtils.makeZxid(0, 0), ByteBuffer.wrap(qp.getData()).getInt());                assertEquals(1, f.self.getAcceptedEpoch());                assertEquals(0, f.self.getCurrentEpoch());                                qp.setType(Leader.SNAP);                qp.setData(new byte[0]);                qp.setZxid(zkDb.getDataTreeLastProcessedZxid());                oa.writeRecord(qp, null);                zkDb.serializeSnapshot(oa);                oa.writeString("BenWasHere", null);                                Thread.sleep(10);                                verify(f.zk, never()).takeSnapshot();                qp.setType(Leader.NEWLEADER);                qp.setZxid(ZxidUtils.makeZxid(1, 0));                oa.writeRecord(qp, null);                                readPacketSkippingPing(ia, qp);                assertEquals(Leader.ACK, qp.getType());                assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());                assertEquals(1, f.self.getAcceptedEpoch());                assertEquals(1, f.self.getCurrentEpoch());                                verify(f.zk).takeSnapshot(true);                assertEquals(firstZxid, f.fzk.getLastProcessedZxid());                                ZKDatabase zkDb2 = new ZKDatabase(new FileTxnSnapLog(logDir, snapDir));                long lastZxid = zkDb2.loadDataBase();                assertEquals("data1", new String(zkDb2.getData("/foo", stat, null)));                assertEquals(firstZxid, lastZxid);                                long proposalZxid = ZxidUtils.makeZxid(1, 1000);                proposeSetData(qp, proposalZxid, "data2", 2);                oa.writeRecord(qp, null);                TrackerWatcher watcher = new TrackerWatcher();                                assertEquals("data1", new String(f.fzk.getZKDatabase().getData("/foo", stat, watcher)));                                qp.setType(Leader.COMMIT);                qp.setZxid(proposalZxid);                oa.writeRecord(qp, null);                qp.setType(Leader.UPTODATE);                qp.setZxid(0);                oa.writeRecord(qp, null);                                readPacketSkippingPing(ia, qp);                assertEquals(Leader.ACK, qp.getType());                assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());                readPacketSkippingPing(ia, qp);                assertEquals(Leader.ACK, qp.getType());                assertEquals(proposalZxid, qp.getZxid());                watcher.waitForChange();                assertEquals("data2", new String(f.fzk.getZKDatabase().getData("/foo", stat, null)));                                zkDb2 = new ZKDatabase(new FileTxnSnapLog(logDir, snapDir));                lastZxid = zkDb2.loadDataBase();                assertEquals("data2", new String(zkDb2.getData("/foo", stat, null)));                assertEquals(proposalZxid, lastZxid);            } finally {                TestUtils.deleteFileRecursively(tmpDir);            }        }        private void proposeSetData(QuorumPacket qp, long zxid, String data, int version) throws IOException {            qp.setType(Leader.PROPOSAL);            qp.setZxid(zxid);            TxnHeader hdr = new TxnHeader(4, 1414, qp.getZxid(), 55, ZooDefs.OpCode.setData);            SetDataTxn sdt = new SetDataTxn("/foo", data.getBytes(), version);            ByteArrayOutputStream baos = new ByteArrayOutputStream();            OutputArchive boa = BinaryOutputArchive.getArchive(baos);            boa.writeRecord(hdr, null);            boa.writeRecord(sdt, null);            qp.setData(baos.toByteArray());        }    });}
converseWithFollower
public void zookeeper_f5471_0(InputArchive ia, OutputArchive oa, Follower f) throws Exception
{    File tmpDir = File.createTempFile("test", "dir", testData);    tmpDir.delete();    tmpDir.mkdir();    File logDir = f.fzk.getTxnLogFactory().getDataDir().getParentFile();    File snapDir = f.fzk.getTxnLogFactory().getSnapDir().getParentFile();        f.zk = spy(f.zk);    try {        assertEquals(0, f.self.getAcceptedEpoch());        assertEquals(0, f.self.getCurrentEpoch());                ZKDatabase zkDb = new ZKDatabase(new FileTxnSnapLog(tmpDir, tmpDir));        final long firstZxid = ZxidUtils.makeZxid(1, 1);        zkDb.processTxn(new TxnHeader(13, 1313, firstZxid, 33, ZooDefs.OpCode.create), new CreateTxn("/foo", "data1".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, false, 1));        Stat stat = new Stat();        assertEquals("data1", new String(zkDb.getData("/foo", stat, null)));        QuorumPacket qp = new QuorumPacket();        readPacketSkippingPing(ia, qp);        assertEquals(Leader.FOLLOWERINFO, qp.getType());        assertEquals(qp.getZxid(), 0);        LearnerInfo learnInfo = new LearnerInfo();        ByteBufferInputStream.byteBuffer2Record(ByteBuffer.wrap(qp.getData()), learnInfo);        assertEquals(learnInfo.getProtocolVersion(), 0x10000);        assertEquals(learnInfo.getServerid(), 0);                qp.setType(Leader.LEADERINFO);        qp.setZxid(ZxidUtils.makeZxid(1, 0));        byte[] protoBytes = new byte[4];        ByteBuffer.wrap(protoBytes).putInt(0x10000);        qp.setData(protoBytes);        oa.writeRecord(qp, null);        readPacketSkippingPing(ia, qp);        assertEquals(Leader.ACKEPOCH, qp.getType());        assertEquals(0, qp.getZxid());        assertEquals(ZxidUtils.makeZxid(0, 0), ByteBuffer.wrap(qp.getData()).getInt());        assertEquals(1, f.self.getAcceptedEpoch());        assertEquals(0, f.self.getCurrentEpoch());                qp.setType(Leader.SNAP);        qp.setData(new byte[0]);        qp.setZxid(zkDb.getDataTreeLastProcessedZxid());        oa.writeRecord(qp, null);        zkDb.serializeSnapshot(oa);        oa.writeString("BenWasHere", null);                Thread.sleep(10);                verify(f.zk, never()).takeSnapshot();        qp.setType(Leader.NEWLEADER);        qp.setZxid(ZxidUtils.makeZxid(1, 0));        oa.writeRecord(qp, null);                readPacketSkippingPing(ia, qp);        assertEquals(Leader.ACK, qp.getType());        assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());        assertEquals(1, f.self.getAcceptedEpoch());        assertEquals(1, f.self.getCurrentEpoch());                verify(f.zk).takeSnapshot(true);        assertEquals(firstZxid, f.fzk.getLastProcessedZxid());                ZKDatabase zkDb2 = new ZKDatabase(new FileTxnSnapLog(logDir, snapDir));        long lastZxid = zkDb2.loadDataBase();        assertEquals("data1", new String(zkDb2.getData("/foo", stat, null)));        assertEquals(firstZxid, lastZxid);                long proposalZxid = ZxidUtils.makeZxid(1, 1000);        proposeSetData(qp, proposalZxid, "data2", 2);        oa.writeRecord(qp, null);        TrackerWatcher watcher = new TrackerWatcher();                assertEquals("data1", new String(f.fzk.getZKDatabase().getData("/foo", stat, watcher)));                qp.setType(Leader.COMMIT);        qp.setZxid(proposalZxid);        oa.writeRecord(qp, null);        qp.setType(Leader.UPTODATE);        qp.setZxid(0);        oa.writeRecord(qp, null);                readPacketSkippingPing(ia, qp);        assertEquals(Leader.ACK, qp.getType());        assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());        readPacketSkippingPing(ia, qp);        assertEquals(Leader.ACK, qp.getType());        assertEquals(proposalZxid, qp.getZxid());        watcher.waitForChange();        assertEquals("data2", new String(f.fzk.getZKDatabase().getData("/foo", stat, null)));                zkDb2 = new ZKDatabase(new FileTxnSnapLog(logDir, snapDir));        lastZxid = zkDb2.loadDataBase();        assertEquals("data2", new String(zkDb2.getData("/foo", stat, null)));        assertEquals(proposalZxid, lastZxid);    } finally {        TestUtils.deleteFileRecursively(tmpDir);    }}
proposeSetData
private void zookeeper_f5472_0(QuorumPacket qp, long zxid, String data, int version) throws IOException
{    qp.setType(Leader.PROPOSAL);    qp.setZxid(zxid);    TxnHeader hdr = new TxnHeader(4, 1414, qp.getZxid(), 55, ZooDefs.OpCode.setData);    SetDataTxn sdt = new SetDataTxn("/foo", data.getBytes(), version);    ByteArrayOutputStream baos = new ByteArrayOutputStream();    OutputArchive boa = BinaryOutputArchive.getArchive(baos);    boa.writeRecord(hdr, null);    boa.writeRecord(sdt, null);    qp.setData(baos.toByteArray());}
testNormalFollowerRunWithDiff
public voidf5473_1) throws Exception
{    testFollowerConversation(new FollowerConversation() {        @Override        public void converseWithFollower(InputArchive ia, OutputArchive oa, Follower f) throws Exception {            File tmpDir = File.createTempFile("test", "dir", testData);            tmpDir.delete();            tmpDir.mkdir();            File logDir = f.fzk.getTxnLogFactory().getDataDir().getParentFile();            File snapDir = f.fzk.getTxnLogFactory().getSnapDir().getParentFile();                        f.zk = spy(f.zk);            try {                assertEquals(0, f.self.getAcceptedEpoch());                assertEquals(0, f.self.getCurrentEpoch());                                ZKDatabase zkDb = new ZKDatabase(new FileTxnSnapLog(tmpDir, tmpDir));                final long firstZxid = ZxidUtils.makeZxid(1, 1);                zkDb.processTxn(new TxnHeader(13, 1313, firstZxid, 33, ZooDefs.OpCode.create), new CreateTxn("/foo", "data1".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, false, 1));                Stat stat = new Stat();                assertEquals("data1", new String(zkDb.getData("/foo", stat, null)));                QuorumPacket qp = new QuorumPacket();                readPacketSkippingPing(ia, qp);                assertEquals(Leader.FOLLOWERINFO, qp.getType());                assertEquals(qp.getZxid(), 0);                LearnerInfo learnInfo = new LearnerInfo();                ByteBufferInputStream.byteBuffer2Record(ByteBuffer.wrap(qp.getData()), learnInfo);                assertEquals(learnInfo.getProtocolVersion(), 0x10000);                assertEquals(learnInfo.getServerid(), 0);                                qp.setType(Leader.LEADERINFO);                qp.setZxid(ZxidUtils.makeZxid(1, 0));                byte[] protoBytes = new byte[4];                ByteBuffer.wrap(protoBytes).putInt(0x10000);                qp.setData(protoBytes);                oa.writeRecord(qp, null);                readPacketSkippingPing(ia, qp);                assertEquals(Leader.ACKEPOCH, qp.getType());                assertEquals(0, qp.getZxid());                assertEquals(ZxidUtils.makeZxid(0, 0), ByteBuffer.wrap(qp.getData()).getInt());                assertEquals(1, f.self.getAcceptedEpoch());                assertEquals(0, f.self.getCurrentEpoch());                                qp.setType(Leader.DIFF);                qp.setData(new byte[0]);                qp.setZxid(zkDb.getDataTreeLastProcessedZxid());                oa.writeRecord(qp, null);                final long createSessionZxid = ZxidUtils.makeZxid(1, 2);                proposeNewSession(qp, createSessionZxid, 0x333);                oa.writeRecord(qp, null);                qp.setType(Leader.COMMIT);                qp.setZxid(createSessionZxid);                oa.writeRecord(qp, null);                qp.setType(Leader.NEWLEADER);                qp.setZxid(ZxidUtils.makeZxid(1, 0));                qp.setData(null);                oa.writeRecord(qp, null);                qp.setType(Leader.UPTODATE);                qp.setZxid(0);                oa.writeRecord(qp, null);                                readPacketSkippingPing(ia, qp);                assertEquals(Leader.ACK, qp.getType());                assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());                                readPacketSkippingPing(ia, qp);                assertEquals(Leader.ACK, qp.getType());                assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());                assertEquals(1, f.self.getAcceptedEpoch());                assertEquals(1, f.self.getCurrentEpoch());                                                long start = System.currentTimeMillis();                while (createSessionZxid != f.fzk.getLastProcessedZxid() && (System.currentTimeMillis() - start) < 50) {                    Thread.sleep(1);                }                assertEquals(createSessionZxid, f.fzk.getLastProcessedZxid());                                ZKDatabase zkDb2 = new ZKDatabase(new FileTxnSnapLog(logDir, snapDir));                start = System.currentTimeMillis();                zkDb2.loadDataBase();                while (zkDb2.getSessionWithTimeOuts().isEmpty() && (System.currentTimeMillis() - start) < 50) {                    Thread.sleep(1);                    zkDb2.loadDataBase();                }                                                assertNotNull(zkDb2.getSessionWithTimeOuts().get(4L));                                verify(f.zk, never()).takeSnapshot();            } finally {                TestUtils.deleteFileRecursively(tmpDir);            }        }        private void proposeNewSession(QuorumPacket qp, long zxid, long sessionId) throws IOException {            qp.setType(Leader.PROPOSAL);            qp.setZxid(zxid);            TxnHeader hdr = new TxnHeader(4, 1414, qp.getZxid(), 55, ZooDefs.OpCode.createSession);            CreateSessionTxn cst = new CreateSessionTxn(30000);            ByteArrayOutputStream baos = new ByteArrayOutputStream();            OutputArchive boa = BinaryOutputArchive.getArchive(baos);            boa.writeRecord(hdr, null);            boa.writeRecord(cst, null);            qp.setData(baos.toByteArray());        }    });}
converseWithFollower
public voidf5474_1InputArchive ia, OutputArchive oa, Follower f) throws Exception
{    File tmpDir = File.createTempFile("test", "dir", testData);    tmpDir.delete();    tmpDir.mkdir();    File logDir = f.fzk.getTxnLogFactory().getDataDir().getParentFile();    File snapDir = f.fzk.getTxnLogFactory().getSnapDir().getParentFile();        f.zk = spy(f.zk);    try {        assertEquals(0, f.self.getAcceptedEpoch());        assertEquals(0, f.self.getCurrentEpoch());                ZKDatabase zkDb = new ZKDatabase(new FileTxnSnapLog(tmpDir, tmpDir));        final long firstZxid = ZxidUtils.makeZxid(1, 1);        zkDb.processTxn(new TxnHeader(13, 1313, firstZxid, 33, ZooDefs.OpCode.create), new CreateTxn("/foo", "data1".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, false, 1));        Stat stat = new Stat();        assertEquals("data1", new String(zkDb.getData("/foo", stat, null)));        QuorumPacket qp = new QuorumPacket();        readPacketSkippingPing(ia, qp);        assertEquals(Leader.FOLLOWERINFO, qp.getType());        assertEquals(qp.getZxid(), 0);        LearnerInfo learnInfo = new LearnerInfo();        ByteBufferInputStream.byteBuffer2Record(ByteBuffer.wrap(qp.getData()), learnInfo);        assertEquals(learnInfo.getProtocolVersion(), 0x10000);        assertEquals(learnInfo.getServerid(), 0);                qp.setType(Leader.LEADERINFO);        qp.setZxid(ZxidUtils.makeZxid(1, 0));        byte[] protoBytes = new byte[4];        ByteBuffer.wrap(protoBytes).putInt(0x10000);        qp.setData(protoBytes);        oa.writeRecord(qp, null);        readPacketSkippingPing(ia, qp);        assertEquals(Leader.ACKEPOCH, qp.getType());        assertEquals(0, qp.getZxid());        assertEquals(ZxidUtils.makeZxid(0, 0), ByteBuffer.wrap(qp.getData()).getInt());        assertEquals(1, f.self.getAcceptedEpoch());        assertEquals(0, f.self.getCurrentEpoch());                qp.setType(Leader.DIFF);        qp.setData(new byte[0]);        qp.setZxid(zkDb.getDataTreeLastProcessedZxid());        oa.writeRecord(qp, null);        final long createSessionZxid = ZxidUtils.makeZxid(1, 2);        proposeNewSession(qp, createSessionZxid, 0x333);        oa.writeRecord(qp, null);        qp.setType(Leader.COMMIT);        qp.setZxid(createSessionZxid);        oa.writeRecord(qp, null);        qp.setType(Leader.NEWLEADER);        qp.setZxid(ZxidUtils.makeZxid(1, 0));        qp.setData(null);        oa.writeRecord(qp, null);        qp.setType(Leader.UPTODATE);        qp.setZxid(0);        oa.writeRecord(qp, null);                readPacketSkippingPing(ia, qp);        assertEquals(Leader.ACK, qp.getType());        assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());                readPacketSkippingPing(ia, qp);        assertEquals(Leader.ACK, qp.getType());        assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());        assertEquals(1, f.self.getAcceptedEpoch());        assertEquals(1, f.self.getCurrentEpoch());                        long start = System.currentTimeMillis();        while (createSessionZxid != f.fzk.getLastProcessedZxid() && (System.currentTimeMillis() - start) < 50) {            Thread.sleep(1);        }        assertEquals(createSessionZxid, f.fzk.getLastProcessedZxid());                ZKDatabase zkDb2 = new ZKDatabase(new FileTxnSnapLog(logDir, snapDir));        start = System.currentTimeMillis();        zkDb2.loadDataBase();        while (zkDb2.getSessionWithTimeOuts().isEmpty() && (System.currentTimeMillis() - start) < 50) {            Thread.sleep(1);            zkDb2.loadDataBase();        }                        assertNotNull(zkDb2.getSessionWithTimeOuts().get(4L));                verify(f.zk, never()).takeSnapshot();    } finally {        TestUtils.deleteFileRecursively(tmpDir);    }}
proposeNewSession
private void zookeeper_f5475_0(QuorumPacket qp, long zxid, long sessionId) throws IOException
{    qp.setType(Leader.PROPOSAL);    qp.setZxid(zxid);    TxnHeader hdr = new TxnHeader(4, 1414, qp.getZxid(), 55, ZooDefs.OpCode.createSession);    CreateSessionTxn cst = new CreateSessionTxn(30000);    ByteArrayOutputStream baos = new ByteArrayOutputStream();    OutputArchive boa = BinaryOutputArchive.getArchive(baos);    boa.writeRecord(hdr, null);    boa.writeRecord(cst, null);    qp.setData(baos.toByteArray());}
testNormalRun
public void zookeeper_f5476_0() throws Exception
{    testLeaderConversation(new LeaderConversation() {        public void converseWithLeader(InputArchive ia, OutputArchive oa, Leader l) throws IOException {            assertEquals(0, l.self.getAcceptedEpoch());            assertEquals(0, l.self.getCurrentEpoch());            /* we test a normal run. everything should work out well. */            LearnerInfo li = new LearnerInfo(1, 0x10000, 0);            byte[] liBytes = new byte[20];            ByteBufferOutputStream.record2ByteBuffer(li, ByteBuffer.wrap(liBytes));            QuorumPacket qp = new QuorumPacket(Leader.FOLLOWERINFO, 0, liBytes, null);            oa.writeRecord(qp, null);            readPacketSkippingPing(ia, qp);            assertEquals(Leader.LEADERINFO, qp.getType());            assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());            assertEquals(ByteBuffer.wrap(qp.getData()).getInt(), 0x10000);            assertEquals(1, l.self.getAcceptedEpoch());            assertEquals(0, l.self.getCurrentEpoch());            qp = new QuorumPacket(Leader.ACKEPOCH, 0, new byte[4], null);            oa.writeRecord(qp, null);            readPacketSkippingPing(ia, qp);            assertEquals(Leader.DIFF, qp.getType());            readPacketSkippingPing(ia, qp);            assertEquals(Leader.NEWLEADER, qp.getType());            assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());            assertEquals(1, l.self.getAcceptedEpoch());            assertEquals(1, l.self.getCurrentEpoch());            qp = new QuorumPacket(Leader.ACK, qp.getZxid(), null, null);            oa.writeRecord(qp, null);            readPacketSkippingPing(ia, qp);            assertEquals(Leader.UPTODATE, qp.getType());        }    });}
converseWithLeader
public void zookeeper_f5477_0(InputArchive ia, OutputArchive oa, Leader l) throws IOException
{    assertEquals(0, l.self.getAcceptedEpoch());    assertEquals(0, l.self.getCurrentEpoch());    /* we test a normal run. everything should work out well. */    LearnerInfo li = new LearnerInfo(1, 0x10000, 0);    byte[] liBytes = new byte[20];    ByteBufferOutputStream.record2ByteBuffer(li, ByteBuffer.wrap(liBytes));    QuorumPacket qp = new QuorumPacket(Leader.FOLLOWERINFO, 0, liBytes, null);    oa.writeRecord(qp, null);    readPacketSkippingPing(ia, qp);    assertEquals(Leader.LEADERINFO, qp.getType());    assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());    assertEquals(ByteBuffer.wrap(qp.getData()).getInt(), 0x10000);    assertEquals(1, l.self.getAcceptedEpoch());    assertEquals(0, l.self.getCurrentEpoch());    qp = new QuorumPacket(Leader.ACKEPOCH, 0, new byte[4], null);    oa.writeRecord(qp, null);    readPacketSkippingPing(ia, qp);    assertEquals(Leader.DIFF, qp.getType());    readPacketSkippingPing(ia, qp);    assertEquals(Leader.NEWLEADER, qp.getType());    assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());    assertEquals(1, l.self.getAcceptedEpoch());    assertEquals(1, l.self.getCurrentEpoch());    qp = new QuorumPacket(Leader.ACK, qp.getZxid(), null, null);    oa.writeRecord(qp, null);    readPacketSkippingPing(ia, qp);    assertEquals(Leader.UPTODATE, qp.getType());}
testTxnTimeout
public voidf5478_1) throws Exception
{    testLeaderConversation(new LeaderConversation() {        public void converseWithLeader(InputArchive ia, OutputArchive oa, Leader l) throws IOException, InterruptedException, org.apache.zookeeper.server.quorum.Leader.XidRolloverException {            assertEquals(0, l.self.getAcceptedEpoch());            assertEquals(0, l.self.getCurrentEpoch());            LearnerInfo li = new LearnerInfo(1, 0x10000, 0);            byte[] liBytes = new byte[20];            ByteBufferOutputStream.record2ByteBuffer(li, ByteBuffer.wrap(liBytes));            QuorumPacket qp = new QuorumPacket(Leader.FOLLOWERINFO, 0, liBytes, null);            oa.writeRecord(qp, null);            readPacketSkippingPing(ia, qp);            assertEquals(Leader.LEADERINFO, qp.getType());            assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());            assertEquals(ByteBuffer.wrap(qp.getData()).getInt(), 0x10000);            assertEquals(1, l.self.getAcceptedEpoch());            assertEquals(0, l.self.getCurrentEpoch());            qp = new QuorumPacket(Leader.ACKEPOCH, 0, new byte[4], null);            oa.writeRecord(qp, null);            readPacketSkippingPing(ia, qp);            assertEquals(Leader.DIFF, qp.getType());            readPacketSkippingPing(ia, qp);            assertEquals(Leader.NEWLEADER, qp.getType());            assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());            assertEquals(1, l.self.getAcceptedEpoch());            assertEquals(1, l.self.getCurrentEpoch());            qp = new QuorumPacket(Leader.ACK, qp.getZxid(), null, null);            oa.writeRecord(qp, null);            readPacketSkippingPing(ia, qp);            assertEquals(Leader.UPTODATE, qp.getType());            long zxid = l.zk.getZxid();            l.propose(new Request(1, 1, ZooDefs.OpCode.create, new TxnHeader(1, 1, zxid, 1, ZooDefs.OpCode.create), new CreateTxn("/test", "hola".getBytes(), null, true, 0), zxid));            readPacketSkippingPing(ia, qp);            assertEquals(Leader.PROPOSAL, qp.getType());                        for (int i = 0; i < (2 * ZabUtils.SYNC_LIMIT) + 2; i++) {                try {                    ia.readRecord(qp, null);                                        qp = new QuorumPacket(Leader.PING, qp.getZxid(), "".getBytes(), null);                    oa.writeRecord(qp, null);                } catch (EOFException e) {                    return;                }            }            fail("Connection hasn't been closed by leader after transaction times out.");        }    });}
converseWithLeader
public voidf5479_1InputArchive ia, OutputArchive oa, Leader l) throws IOException, InterruptedException, org.apache.zookeeper.server.quorum.Leader.XidRolloverException
{    assertEquals(0, l.self.getAcceptedEpoch());    assertEquals(0, l.self.getCurrentEpoch());    LearnerInfo li = new LearnerInfo(1, 0x10000, 0);    byte[] liBytes = new byte[20];    ByteBufferOutputStream.record2ByteBuffer(li, ByteBuffer.wrap(liBytes));    QuorumPacket qp = new QuorumPacket(Leader.FOLLOWERINFO, 0, liBytes, null);    oa.writeRecord(qp, null);    readPacketSkippingPing(ia, qp);    assertEquals(Leader.LEADERINFO, qp.getType());    assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());    assertEquals(ByteBuffer.wrap(qp.getData()).getInt(), 0x10000);    assertEquals(1, l.self.getAcceptedEpoch());    assertEquals(0, l.self.getCurrentEpoch());    qp = new QuorumPacket(Leader.ACKEPOCH, 0, new byte[4], null);    oa.writeRecord(qp, null);    readPacketSkippingPing(ia, qp);    assertEquals(Leader.DIFF, qp.getType());    readPacketSkippingPing(ia, qp);    assertEquals(Leader.NEWLEADER, qp.getType());    assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());    assertEquals(1, l.self.getAcceptedEpoch());    assertEquals(1, l.self.getCurrentEpoch());    qp = new QuorumPacket(Leader.ACK, qp.getZxid(), null, null);    oa.writeRecord(qp, null);    readPacketSkippingPing(ia, qp);    assertEquals(Leader.UPTODATE, qp.getType());    long zxid = l.zk.getZxid();    l.propose(new Request(1, 1, ZooDefs.OpCode.create, new TxnHeader(1, 1, zxid, 1, ZooDefs.OpCode.create), new CreateTxn("/test", "hola".getBytes(), null, true, 0), zxid));    readPacketSkippingPing(ia, qp);    assertEquals(Leader.PROPOSAL, qp.getType());        for (int i = 0; i < (2 * ZabUtils.SYNC_LIMIT) + 2; i++) {        try {            ia.readRecord(qp, null);                        qp = new QuorumPacket(Leader.PING, qp.getZxid(), "".getBytes(), null);            oa.writeRecord(qp, null);        } catch (EOFException e) {            return;        }    }    fail("Connection hasn't been closed by leader after transaction times out.");}
deserializeSnapshot
private void zookeeper_f5480_0(InputArchive ia) throws IOException
{    ZKDatabase zkdb = new ZKDatabase(null);    zkdb.deserializeSnapshot(ia);    String signature = ia.readString("signature");    assertEquals("BenWasHere", signature);}
testNormalObserverRun
public void zookeeper_f5481_0() throws Exception
{    testObserverConversation(new ObserverConversation() {        @Override        public void converseWithObserver(InputArchive ia, OutputArchive oa, Observer o) throws Exception {            File tmpDir = File.createTempFile("test", "dir", testData);            tmpDir.delete();            tmpDir.mkdir();            File logDir = o.zk.getTxnLogFactory().getDataDir().getParentFile();            File snapDir = o.zk.getTxnLogFactory().getSnapDir().getParentFile();            try {                assertEquals(0, o.self.getAcceptedEpoch());                assertEquals(0, o.self.getCurrentEpoch());                                ZKDatabase zkDb = new ZKDatabase(new FileTxnSnapLog(tmpDir, tmpDir));                final long foo1Zxid = ZxidUtils.makeZxid(1, 1);                final long foo2Zxid = ZxidUtils.makeZxid(1, 2);                zkDb.processTxn(new TxnHeader(13, 1313, foo1Zxid, 33, ZooDefs.OpCode.create), new CreateTxn("/foo1", "data1".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, false, 1));                zkDb.processTxn(new TxnHeader(13, 1313, foo2Zxid, 33, ZooDefs.OpCode.create), new CreateTxn("/foo2", "data1".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, false, 1));                Stat stat = new Stat();                assertEquals("data1", new String(zkDb.getData("/foo1", stat, null)));                assertEquals("data1", new String(zkDb.getData("/foo2", stat, null)));                QuorumPacket qp = new QuorumPacket();                readPacketSkippingPing(ia, qp);                assertEquals(Leader.OBSERVERINFO, qp.getType());                assertEquals(qp.getZxid(), 0);                LearnerInfo learnInfo = new LearnerInfo();                ByteBufferInputStream.byteBuffer2Record(ByteBuffer.wrap(qp.getData()), learnInfo);                assertEquals(learnInfo.getProtocolVersion(), 0x10000);                assertEquals(learnInfo.getServerid(), 0);                                qp.setType(Leader.LEADERINFO);                qp.setZxid(ZxidUtils.makeZxid(1, 0));                byte[] protoBytes = new byte[4];                ByteBuffer.wrap(protoBytes).putInt(0x10000);                qp.setData(protoBytes);                oa.writeRecord(qp, null);                readPacketSkippingPing(ia, qp);                assertEquals(Leader.ACKEPOCH, qp.getType());                assertEquals(0, qp.getZxid());                assertEquals(ZxidUtils.makeZxid(0, 0), ByteBuffer.wrap(qp.getData()).getInt());                assertEquals(1, o.self.getAcceptedEpoch());                assertEquals(0, o.self.getCurrentEpoch());                                qp.setType(Leader.SNAP);                qp.setData(new byte[0]);                qp.setZxid(zkDb.getDataTreeLastProcessedZxid());                oa.writeRecord(qp, null);                zkDb.serializeSnapshot(oa);                oa.writeString("BenWasHere", null);                qp.setType(Leader.NEWLEADER);                qp.setZxid(ZxidUtils.makeZxid(1, 0));                oa.writeRecord(qp, null);                                readPacketSkippingPing(ia, qp);                assertEquals(Leader.ACK, qp.getType());                assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());                assertEquals(1, o.self.getAcceptedEpoch());                assertEquals(1, o.self.getCurrentEpoch());                assertEquals(foo2Zxid, o.zk.getLastProcessedZxid());                                ZKDatabase zkDb2 = new ZKDatabase(new FileTxnSnapLog(logDir, snapDir));                long lastZxid = zkDb2.loadDataBase();                assertEquals("data1", new String(zkDb2.getData("/foo1", stat, null)));                assertEquals(foo2Zxid, lastZxid);                                TrackerWatcher watcher = new TrackerWatcher();                assertEquals("data1", new String(o.zk.getZKDatabase().getData("/foo2", stat, watcher)));                                long proposalZxid = ZxidUtils.makeZxid(1, 1000);                proposeSetData(qp, "/foo1", proposalZxid, "data2", 2);                oa.writeRecord(qp, null);                                qp.setType(Leader.COMMIT);                qp.setZxid(proposalZxid);                oa.writeRecord(qp, null);                                long informZxid = ZxidUtils.makeZxid(1, 1001);                proposeSetData(qp, "/foo2", informZxid, "data2", 2);                qp.setType(Leader.INFORM);                oa.writeRecord(qp, null);                qp.setType(Leader.UPTODATE);                qp.setZxid(0);                oa.writeRecord(qp, null);                                readPacketSkippingPing(ia, qp);                assertEquals(Leader.ACK, qp.getType());                assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());                                watcher.waitForChange();                assertEquals("data2", new String(o.zk.getZKDatabase().getData("/foo1", stat, null)));                assertEquals("data2", new String(o.zk.getZKDatabase().getData("/foo2", stat, null)));                                                o.zk.shutdown();                zkDb2 = new ZKDatabase(new FileTxnSnapLog(logDir, snapDir));                lastZxid = zkDb2.loadDataBase();                assertEquals("data2", new String(zkDb2.getData("/foo1", stat, null)));                assertEquals("data2", new String(zkDb2.getData("/foo2", stat, null)));                assertEquals(informZxid, lastZxid);            } finally {                TestUtils.deleteFileRecursively(tmpDir);            }        }        private void proposeSetData(QuorumPacket qp, String path, long zxid, String data, int version) throws IOException {            qp.setType(Leader.PROPOSAL);            qp.setZxid(zxid);            TxnHeader hdr = new TxnHeader(4, 1414, qp.getZxid(), 55, ZooDefs.OpCode.setData);            SetDataTxn sdt = new SetDataTxn(path, data.getBytes(), version);            ByteArrayOutputStream baos = new ByteArrayOutputStream();            OutputArchive boa = BinaryOutputArchive.getArchive(baos);            boa.writeRecord(hdr, null);            boa.writeRecord(sdt, null);            qp.setData(baos.toByteArray());        }    });}
converseWithObserver
public void zookeeper_f5482_0(InputArchive ia, OutputArchive oa, Observer o) throws Exception
{    File tmpDir = File.createTempFile("test", "dir", testData);    tmpDir.delete();    tmpDir.mkdir();    File logDir = o.zk.getTxnLogFactory().getDataDir().getParentFile();    File snapDir = o.zk.getTxnLogFactory().getSnapDir().getParentFile();    try {        assertEquals(0, o.self.getAcceptedEpoch());        assertEquals(0, o.self.getCurrentEpoch());                ZKDatabase zkDb = new ZKDatabase(new FileTxnSnapLog(tmpDir, tmpDir));        final long foo1Zxid = ZxidUtils.makeZxid(1, 1);        final long foo2Zxid = ZxidUtils.makeZxid(1, 2);        zkDb.processTxn(new TxnHeader(13, 1313, foo1Zxid, 33, ZooDefs.OpCode.create), new CreateTxn("/foo1", "data1".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, false, 1));        zkDb.processTxn(new TxnHeader(13, 1313, foo2Zxid, 33, ZooDefs.OpCode.create), new CreateTxn("/foo2", "data1".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, false, 1));        Stat stat = new Stat();        assertEquals("data1", new String(zkDb.getData("/foo1", stat, null)));        assertEquals("data1", new String(zkDb.getData("/foo2", stat, null)));        QuorumPacket qp = new QuorumPacket();        readPacketSkippingPing(ia, qp);        assertEquals(Leader.OBSERVERINFO, qp.getType());        assertEquals(qp.getZxid(), 0);        LearnerInfo learnInfo = new LearnerInfo();        ByteBufferInputStream.byteBuffer2Record(ByteBuffer.wrap(qp.getData()), learnInfo);        assertEquals(learnInfo.getProtocolVersion(), 0x10000);        assertEquals(learnInfo.getServerid(), 0);                qp.setType(Leader.LEADERINFO);        qp.setZxid(ZxidUtils.makeZxid(1, 0));        byte[] protoBytes = new byte[4];        ByteBuffer.wrap(protoBytes).putInt(0x10000);        qp.setData(protoBytes);        oa.writeRecord(qp, null);        readPacketSkippingPing(ia, qp);        assertEquals(Leader.ACKEPOCH, qp.getType());        assertEquals(0, qp.getZxid());        assertEquals(ZxidUtils.makeZxid(0, 0), ByteBuffer.wrap(qp.getData()).getInt());        assertEquals(1, o.self.getAcceptedEpoch());        assertEquals(0, o.self.getCurrentEpoch());                qp.setType(Leader.SNAP);        qp.setData(new byte[0]);        qp.setZxid(zkDb.getDataTreeLastProcessedZxid());        oa.writeRecord(qp, null);        zkDb.serializeSnapshot(oa);        oa.writeString("BenWasHere", null);        qp.setType(Leader.NEWLEADER);        qp.setZxid(ZxidUtils.makeZxid(1, 0));        oa.writeRecord(qp, null);                readPacketSkippingPing(ia, qp);        assertEquals(Leader.ACK, qp.getType());        assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());        assertEquals(1, o.self.getAcceptedEpoch());        assertEquals(1, o.self.getCurrentEpoch());        assertEquals(foo2Zxid, o.zk.getLastProcessedZxid());                ZKDatabase zkDb2 = new ZKDatabase(new FileTxnSnapLog(logDir, snapDir));        long lastZxid = zkDb2.loadDataBase();        assertEquals("data1", new String(zkDb2.getData("/foo1", stat, null)));        assertEquals(foo2Zxid, lastZxid);                TrackerWatcher watcher = new TrackerWatcher();        assertEquals("data1", new String(o.zk.getZKDatabase().getData("/foo2", stat, watcher)));                long proposalZxid = ZxidUtils.makeZxid(1, 1000);        proposeSetData(qp, "/foo1", proposalZxid, "data2", 2);        oa.writeRecord(qp, null);                qp.setType(Leader.COMMIT);        qp.setZxid(proposalZxid);        oa.writeRecord(qp, null);                long informZxid = ZxidUtils.makeZxid(1, 1001);        proposeSetData(qp, "/foo2", informZxid, "data2", 2);        qp.setType(Leader.INFORM);        oa.writeRecord(qp, null);        qp.setType(Leader.UPTODATE);        qp.setZxid(0);        oa.writeRecord(qp, null);                readPacketSkippingPing(ia, qp);        assertEquals(Leader.ACK, qp.getType());        assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());                watcher.waitForChange();        assertEquals("data2", new String(o.zk.getZKDatabase().getData("/foo1", stat, null)));        assertEquals("data2", new String(o.zk.getZKDatabase().getData("/foo2", stat, null)));                        o.zk.shutdown();        zkDb2 = new ZKDatabase(new FileTxnSnapLog(logDir, snapDir));        lastZxid = zkDb2.loadDataBase();        assertEquals("data2", new String(zkDb2.getData("/foo1", stat, null)));        assertEquals("data2", new String(zkDb2.getData("/foo2", stat, null)));        assertEquals(informZxid, lastZxid);    } finally {        TestUtils.deleteFileRecursively(tmpDir);    }}
proposeSetData
private void zookeeper_f5483_0(QuorumPacket qp, String path, long zxid, String data, int version) throws IOException
{    qp.setType(Leader.PROPOSAL);    qp.setZxid(zxid);    TxnHeader hdr = new TxnHeader(4, 1414, qp.getZxid(), 55, ZooDefs.OpCode.setData);    SetDataTxn sdt = new SetDataTxn(path, data.getBytes(), version);    ByteArrayOutputStream baos = new ByteArrayOutputStream();    OutputArchive boa = BinaryOutputArchive.getArchive(baos);    boa.writeRecord(hdr, null);    boa.writeRecord(sdt, null);    qp.setData(baos.toByteArray());}
testLeaderBehind
public void zookeeper_f5484_0() throws Exception
{    testLeaderConversation(new LeaderConversation() {        public void converseWithLeader(InputArchive ia, OutputArchive oa, Leader l) throws IOException {            /* we test a normal run. everything should work out well. */            LearnerInfo li = new LearnerInfo(1, 0x10000, 0);            byte[] liBytes = new byte[20];            ByteBufferOutputStream.record2ByteBuffer(li, ByteBuffer.wrap(liBytes));            /* we are going to say we last acked epoch 20 */            QuorumPacket qp = new QuorumPacket(Leader.FOLLOWERINFO, ZxidUtils.makeZxid(20, 0), liBytes, null);            oa.writeRecord(qp, null);            readPacketSkippingPing(ia, qp);            assertEquals(Leader.LEADERINFO, qp.getType());            assertEquals(ZxidUtils.makeZxid(21, 0), qp.getZxid());            assertEquals(ByteBuffer.wrap(qp.getData()).getInt(), 0x10000);            qp = new QuorumPacket(Leader.ACKEPOCH, 0, new byte[4], null);            oa.writeRecord(qp, null);            readPacketSkippingPing(ia, qp);            assertEquals(Leader.DIFF, qp.getType());            readPacketSkippingPing(ia, qp);            assertEquals(Leader.NEWLEADER, qp.getType());            assertEquals(ZxidUtils.makeZxid(21, 0), qp.getZxid());            qp = new QuorumPacket(Leader.ACK, qp.getZxid(), null, null);            oa.writeRecord(qp, null);            readPacketSkippingPing(ia, qp);            assertEquals(Leader.UPTODATE, qp.getType());        }    });}
converseWithLeader
public void zookeeper_f5485_0(InputArchive ia, OutputArchive oa, Leader l) throws IOException
{    /* we test a normal run. everything should work out well. */    LearnerInfo li = new LearnerInfo(1, 0x10000, 0);    byte[] liBytes = new byte[20];    ByteBufferOutputStream.record2ByteBuffer(li, ByteBuffer.wrap(liBytes));    /* we are going to say we last acked epoch 20 */    QuorumPacket qp = new QuorumPacket(Leader.FOLLOWERINFO, ZxidUtils.makeZxid(20, 0), liBytes, null);    oa.writeRecord(qp, null);    readPacketSkippingPing(ia, qp);    assertEquals(Leader.LEADERINFO, qp.getType());    assertEquals(ZxidUtils.makeZxid(21, 0), qp.getZxid());    assertEquals(ByteBuffer.wrap(qp.getData()).getInt(), 0x10000);    qp = new QuorumPacket(Leader.ACKEPOCH, 0, new byte[4], null);    oa.writeRecord(qp, null);    readPacketSkippingPing(ia, qp);    assertEquals(Leader.DIFF, qp.getType());    readPacketSkippingPing(ia, qp);    assertEquals(Leader.NEWLEADER, qp.getType());    assertEquals(ZxidUtils.makeZxid(21, 0), qp.getZxid());    qp = new QuorumPacket(Leader.ACK, qp.getZxid(), null, null);    oa.writeRecord(qp, null);    readPacketSkippingPing(ia, qp);    assertEquals(Leader.UPTODATE, qp.getType());}
testAbandonBeforeACKEpoch
public void zookeeper_f5486_0() throws Exception
{    testLeaderConversation(new LeaderConversation() {        public void converseWithLeader(InputArchive ia, OutputArchive oa, Leader l) throws IOException, InterruptedException {            /* we test a normal run. everything should work out well. */            LearnerInfo li = new LearnerInfo(1, 0x10000, 0);            byte[] liBytes = new byte[20];            ByteBufferOutputStream.record2ByteBuffer(li, ByteBuffer.wrap(liBytes));            QuorumPacket qp = new QuorumPacket(Leader.FOLLOWERINFO, 0, liBytes, null);            oa.writeRecord(qp, null);            readPacketSkippingPing(ia, qp);            assertEquals(Leader.LEADERINFO, qp.getType());            assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());            assertEquals(ByteBuffer.wrap(qp.getData()).getInt(), 0x10000);            Thread.sleep(l.self.getInitLimit() * l.self.getTickTime() + 5000);                        assertEquals(0, l.self.getCurrentEpoch());        }    });}
converseWithLeader
public void zookeeper_f5487_0(InputArchive ia, OutputArchive oa, Leader l) throws IOException, InterruptedException
{    /* we test a normal run. everything should work out well. */    LearnerInfo li = new LearnerInfo(1, 0x10000, 0);    byte[] liBytes = new byte[20];    ByteBufferOutputStream.record2ByteBuffer(li, ByteBuffer.wrap(liBytes));    QuorumPacket qp = new QuorumPacket(Leader.FOLLOWERINFO, 0, liBytes, null);    oa.writeRecord(qp, null);    readPacketSkippingPing(ia, qp);    assertEquals(Leader.LEADERINFO, qp.getType());    assertEquals(ZxidUtils.makeZxid(1, 0), qp.getZxid());    assertEquals(ByteBuffer.wrap(qp.getData()).getInt(), 0x10000);    Thread.sleep(l.self.getInitLimit() * l.self.getTickTime() + 5000);        assertEquals(0, l.self.getCurrentEpoch());}
setLeaderQuorumServer
public void zookeeper_f5488_0(QuorumServer quorumServer)
{    leaderQuorumServer = quorumServer;}
findLeader
protected QuorumServer zookeeper_f5489_0()
{    return leaderQuorumServer;}
createFollower
private ConversableFollower zookeeper_f5490_0(File tmpDir, QuorumPeer peer) throws IOException
{    FileTxnSnapLog logFactory = new FileTxnSnapLog(tmpDir, tmpDir);    peer.setTxnFactory(logFactory);    ZKDatabase zkDb = new ZKDatabase(logFactory);    FollowerZooKeeperServer zk = new FollowerZooKeeperServer(logFactory, peer, zkDb);    peer.setZKDatabase(zkDb);    return new ConversableFollower(peer, zk);}
setLeaderQuorumServer
public void zookeeper_f5491_0(QuorumServer quorumServer)
{    leaderQuorumServer = quorumServer;}
findLeader
protected QuorumServer zookeeper_f5492_0()
{    return leaderQuorumServer;}
createObserver
private ConversableObserver zookeeper_f5493_0(File tmpDir, QuorumPeer peer) throws IOException
{    FileTxnSnapLog logFactory = new FileTxnSnapLog(tmpDir, tmpDir);    peer.setTxnFactory(logFactory);    ZKDatabase zkDb = new ZKDatabase(logFactory);    ObserverZooKeeperServer zk = new ObserverZooKeeperServer(logFactory, peer, zkDb);    peer.setZKDatabase(zkDb);    return new ConversableObserver(peer, zk);}
readContentsOfFile
private String zookeeper_f5494_0(File f) throws IOException
{    return new BufferedReader(new FileReader(f)).readLine();}
testInitialAcceptedCurrent
public void zookeeper_f5495_0() throws Exception
{    File tmpDir = File.createTempFile("test", ".dir", testData);    tmpDir.delete();    tmpDir.mkdir();    try {        FileTxnSnapLog logFactory = new FileTxnSnapLog(tmpDir, tmpDir);        File version2 = new File(tmpDir, "version-2");        version2.mkdir();        logFactory.save(new DataTree(), new ConcurrentHashMap<Long, Integer>(), false);        long zxid = ZxidUtils.makeZxid(3, 3);        logFactory.append(new Request(1, 1, ZooDefs.OpCode.error, new TxnHeader(1, 1, zxid, 1, ZooDefs.OpCode.error), new ErrorTxn(1), zxid));        logFactory.commit();        ZKDatabase zkDb = new ZKDatabase(logFactory);        QuorumPeer peer = QuorumPeer.testingQuorumPeer();        peer.setZKDatabase(zkDb);        peer.setTxnFactory(logFactory);        peer.getLastLoggedZxid();        assertEquals(3, peer.getAcceptedEpoch());        assertEquals(3, peer.getCurrentEpoch());        assertEquals(3, Integer.parseInt(readContentsOfFile(new File(version2, QuorumPeer.CURRENT_EPOCH_FILENAME))));        assertEquals(3, Integer.parseInt(readContentsOfFile(new File(version2, QuorumPeer.ACCEPTED_EPOCH_FILENAME))));    } finally {        TestUtils.deleteFileRecursively(tmpDir);    }}
createQuorumPeer
public static QuorumPeer zookeeper_f5496_0(File tmpDir) throws IOException
{    HashMap<Long, QuorumPeer.QuorumServer> peers = new HashMap<Long, QuorumPeer.QuorumServer>();    QuorumPeer peer = QuorumPeer.testingQuorumPeer();    peer.syncLimit = SYNC_LIMIT;    peer.initLimit = 2;    peer.tickTime = 2000;    peers.put(0L, new QuorumPeer.QuorumServer(0, new InetSocketAddress("127.0.0.1", PortAssignment.unique()), new InetSocketAddress("127.0.0.1", PortAssignment.unique()), new InetSocketAddress("127.0.0.1", PortAssignment.unique())));    peers.put(1L, new QuorumPeer.QuorumServer(1, new InetSocketAddress("127.0.0.1", PortAssignment.unique()), new InetSocketAddress("127.0.0.1", PortAssignment.unique()), new InetSocketAddress("127.0.0.1", PortAssignment.unique())));    peers.put(2L, new QuorumPeer.QuorumServer(2, new InetSocketAddress("127.0.0.1", PortAssignment.unique()), new InetSocketAddress("127.0.0.1", PortAssignment.unique()), new InetSocketAddress("127.0.0.1", PortAssignment.unique())));    peer.setQuorumVerifier(new QuorumMaj(peers), false);    peer.setCnxnFactory(new NullServerCnxnFactory());    File version2 = new File(tmpDir, "version-2");    version2.mkdir();    ClientBase.createInitializeFile(tmpDir);    FileOutputStream fos = new FileOutputStream(new File(version2, "currentEpoch"));    fos.write("0\n".getBytes());    fos.close();    fos = new FileOutputStream(new File(version2, "acceptedEpoch"));    fos.write("0\n".getBytes());    fos.close();    return peer;}
createLeader
public static Leader zookeeper_f5497_0(File tmpDir, QuorumPeer peer) throws IOException, NoSuchFieldException, IllegalAccessException, X509Exception
{    LeaderZooKeeperServer zk = prepareLeader(tmpDir, peer);    return new Leader(peer, zk);}
createMockLeader
public static Leader zookeeper_f5498_0(File tmpDir, QuorumPeer peer) throws IOException, NoSuchFieldException, IllegalAccessException, X509Exception
{    LeaderZooKeeperServer zk = prepareLeader(tmpDir, peer);    return new MockLeader(peer, zk);}
prepareLeader
private static LeaderZooKeeperServer zookeeper_f5499_0(File tmpDir, QuorumPeer peer) throws IOException, NoSuchFieldException, IllegalAccessException
{    FileTxnSnapLog logFactory = new FileTxnSnapLog(tmpDir, tmpDir);    peer.setTxnFactory(logFactory);    ZKDatabase zkDb = new ZKDatabase(logFactory);    LeaderZooKeeperServer zk = new LeaderZooKeeperServer(logFactory, peer, zkDb);    return zk;}
startup
public void zookeeper_f5500_0(ZooKeeperServer zkServer, boolean startServer) throws IOException, InterruptedException
{}
start
public void zookeeper_f5501_0()
{}
shutdown
public void zookeeper_f5502_0()
{}
setMaxClientCnxnsPerHost
public void zookeeper_f5503_0(int max)
{}
join
public void zookeeper_f5504_0() throws InterruptedException
{}
getMaxClientCnxnsPerHost
public int zookeeper_f5505_0()
{    return 0;}
getSocketListenBacklog
public int zookeeper_f5506_0()
{    return -1;}
getLocalPort
public int zookeeper_f5507_0()
{    return 0;}
getLocalAddress
public InetSocketAddress zookeeper_f5508_0()
{    return null;}
getConnections
public Iterable<ServerCnxn> zookeeper_f5509_0()
{    return null;}
configure
public void zookeeper_f5510_0(InetSocketAddress addr, int maxcc, int listenBacklog, boolean secure) throws IOException
{}
closeSession
public boolean zookeeper_f5511_0(long sessionId, ServerCnxn.DisconnectReason reason)
{    return false;}
closeAll
public void zookeeper_f5512_0(ServerCnxn.DisconnectReason reason)
{}
getNumAliveConnections
public int zookeeper_f5513_0()
{    return 0;}
reconfigure
public void zookeeper_f5514_0(InetSocketAddress addr)
{}
resetAllConnectionStats
public void zookeeper_f5515_0()
{}
getAllConnectionInfo
public Iterable<Map<String, Object>> zookeeper_f5516_0(boolean brief)
{    return null;}
getCurrentEpochToPropose
public long zookeeper_f5517_0()
{    return epoch;}
testSameACLGivesSameID
public void zookeeper_f5518_0()
{    List<ACL> testACL = createACL("myid");    ReferenceCountedACLCache cache = new ReferenceCountedACLCache();    Long aclId = cache.convertAcls(testACL);    List<ACL> testACL2 = createACL("myid");    assertEquals(aclId, cache.convertAcls(testACL2));}
testWhetherOrderingMatters
public void zookeeper_f5519_0()
{    List<ACL> testACL = new ArrayList<ACL>();    testACL.add(new ACL(ZooDefs.Perms.READ, new Id("scheme", "ro")));    testACL.add(new ACL(ZooDefs.Perms.WRITE, new Id("scheme", "rw")));    ReferenceCountedACLCache cache = new ReferenceCountedACLCache();    Long aclId = cache.convertAcls(testACL);    List<ACL> testACL2 = new ArrayList<ACL>();    testACL2.add(new ACL(ZooDefs.Perms.WRITE, new Id("scheme", "rw")));    testACL2.add(new ACL(ZooDefs.Perms.READ, new Id("scheme", "ro")));    assertFalse(aclId.equals(cache.convertAcls(testACL2)));}
testBidirectionality
public void zookeeper_f5520_0()
{    List<ACL> testACL = createACL("myid");    ReferenceCountedACLCache cache = new ReferenceCountedACLCache();    Long aclId = cache.convertAcls(testACL);    assertEquals(testACL, cache.convertLong(aclId));}
testCacheSize
public void zookeeper_f5521_0()
{    List<ACL> testACL = createACL("myid");    ReferenceCountedACLCache cache = new ReferenceCountedACLCache();    Long aclId = cache.convertAcls(testACL);    assertEquals(1, cache.size());    List<ACL> testACL2 = createACL("myid");    assertEquals(aclId, cache.convertAcls(testACL2));    assertEquals(1, cache.size());    List<ACL> testACL3 = createACL("differentId");    Long aclId3 = cache.convertAcls(testACL3);    assertFalse(aclId3.equals(aclId));    assertEquals(2, cache.size());}
testAddThenRemove
public void zookeeper_f5522_0()
{    List<ACL> testACL = createACL("myid");    ReferenceCountedACLCache cache = new ReferenceCountedACLCache();    Long aclId = cache.convertAcls(testACL);    assertEquals(1, cache.size());    cache.removeUsage(aclId);    assertEquals(0, cache.size());}
testMultipleAddsAndRemove
public void zookeeper_f5523_0()
{    List<ACL> testACL = createACL("myid");    ReferenceCountedACLCache cache = new ReferenceCountedACLCache();    Long aclId = cache.convertAcls(testACL);    assertEquals(1, cache.size());    cache.convertAcls(testACL);    assertEquals(1, cache.size());    List<ACL> testACL2 = createACL("anotherId");    cache.convertAcls(testACL2);    cache.removeUsage(aclId);    assertEquals(2, cache.size());    cache.removeUsage(aclId);    assertEquals(1, cache.size());    Long newId = cache.convertAcls(testACL);    assertFalse(aclId.equals(newId));}
testAddUsage
public void zookeeper_f5524_0()
{    List<ACL> testACL = createACL("myid");    ReferenceCountedACLCache cache = new ReferenceCountedACLCache();    Long aclId = cache.convertAcls(testACL);    assertEquals(1, cache.size());    cache.addUsage(aclId);    assertEquals(1, cache.size());    cache.removeUsage(aclId);    assertEquals(1, cache.size());    cache.removeUsage(aclId);    assertEquals(0, cache.size());}
testAddNonExistentUsage
public void zookeeper_f5525_0()
{    ReferenceCountedACLCache cache = new ReferenceCountedACLCache();    cache.addUsage(1L);    assertEquals(0, cache.size());/*        On startup, it's possible that we'll try calling addUsage of an ID not in the cache.  This is safe to ignore        as it'll be added later when we traverse the tranlog.  See discussion here:        http://mail-archives.apache.org/mod_mbox/zookeeper-user/201507.mbox/%3CCAB5oV2_ujhvBA1sEkCG2WRakPjCy%2BNR10620WK2G1GGgmEO44g%40mail.gmail.com%3E        This test makes sure that we don't add the ID to the cache in this case as that would result in dupes later        and consequently incorrect counts and entries that will never be cleaned out.         */}
testSerializeDeserialize
public void zookeeper_f5526_0() throws IOException
{    ReferenceCountedACLCache cache = new ReferenceCountedACLCache();    List<ACL> acl1 = createACL("one");    List<ACL> acl2 = createACL("two");    List<ACL> acl3 = createACL("three");    List<ACL> acl4 = createACL("four");    List<ACL> acl5 = createACL("five");    Long aclId1 = convertACLsNTimes(cache, acl1, 1);    Long aclId2 = convertACLsNTimes(cache, acl2, 2);    Long aclId3 = convertACLsNTimes(cache, acl3, 3);    Long aclId4 = convertACLsNTimes(cache, acl4, 4);    Long aclId5 = convertACLsNTimes(cache, acl5, 5);    ByteArrayOutputStream baos = new ByteArrayOutputStream();    BinaryOutputArchive archive = BinaryOutputArchive.getArchive(baos);    cache.serialize(archive);    BinaryInputArchive inArchive = BinaryInputArchive.getArchive(new ByteArrayInputStream(baos.toByteArray()));    ReferenceCountedACLCache deserializedCache = new ReferenceCountedACLCache();    deserializedCache.deserialize(inArchive);    callAddUsageNTimes(deserializedCache, aclId1, 1);    callAddUsageNTimes(deserializedCache, aclId2, 2);    callAddUsageNTimes(deserializedCache, aclId3, 3);    callAddUsageNTimes(deserializedCache, aclId4, 4);    callAddUsageNTimes(deserializedCache, aclId5, 5);    assertCachesEqual(cache, deserializedCache);}
testNPEInDeserialize
public void zookeeper_f5527_0() throws IOException
{    ReferenceCountedACLCache serializeCache = new ReferenceCountedACLCache() {        @Override        public synchronized void serialize(OutputArchive oa) throws IOException {            oa.writeInt(1, "map");            oa.writeLong(1, "long");            oa.startVector(null, "acls");            oa.endVector(null, "acls");        }    };    ByteArrayOutputStream baos = new ByteArrayOutputStream();    BinaryOutputArchive archive = BinaryOutputArchive.getArchive(baos);    serializeCache.serialize(archive);    BinaryInputArchive inArchive = BinaryInputArchive.getArchive(new ByteArrayInputStream(baos.toByteArray()));    ReferenceCountedACLCache deserializedCache = new ReferenceCountedACLCache();    try {        deserializedCache.deserialize(inArchive);    } catch (NullPointerException e) {        fail("should not throw NPE while do deserialized");    } catch (RuntimeException e) {        }}
serialize
public synchronized void zookeeper_f5528_0(OutputArchive oa) throws IOException
{    oa.writeInt(1, "map");    oa.writeLong(1, "long");    oa.startVector(null, "acls");    oa.endVector(null, "acls");}
assertCachesEqual
private void zookeeper_f5529_0(ReferenceCountedACLCache expected, ReferenceCountedACLCache actual)
{    assertEquals(expected.aclIndex, actual.aclIndex);    assertEquals(expected.aclKeyMap, actual.aclKeyMap);    assertEquals(expected.longKeyMap, actual.longKeyMap);    assertEquals(expected.referenceCounter, actual.referenceCounter);}
testPurgeUnused
public void zookeeper_f5530_0() throws IOException
{    ReferenceCountedACLCache cache = new ReferenceCountedACLCache();    List<ACL> acl1 = createACL("one");    List<ACL> acl2 = createACL("two");    List<ACL> acl3 = createACL("three");    List<ACL> acl4 = createACL("four");    List<ACL> acl5 = createACL("five");    Long aclId1 = convertACLsNTimes(cache, acl1, 1);    Long aclId2 = convertACLsNTimes(cache, acl2, 2);    Long aclId3 = convertACLsNTimes(cache, acl3, 3);    Long aclId4 = convertACLsNTimes(cache, acl4, 4);    Long aclId5 = convertACLsNTimes(cache, acl5, 5);    ByteArrayOutputStream baos = new ByteArrayOutputStream();    BinaryOutputArchive archive = BinaryOutputArchive.getArchive(baos);    cache.serialize(archive);    BinaryInputArchive inArchive = BinaryInputArchive.getArchive(new ByteArrayInputStream(baos.toByteArray()));    ReferenceCountedACLCache deserializedCache = new ReferenceCountedACLCache();    deserializedCache.deserialize(inArchive);    callAddUsageNTimes(deserializedCache, aclId1, 1);    callAddUsageNTimes(deserializedCache, aclId2, 2);    deserializedCache.purgeUnused();    assertEquals(2, deserializedCache.size());    assertEquals(aclId1, deserializedCache.convertAcls(acl1));    assertEquals(aclId2, deserializedCache.convertAcls(acl2));    assertFalse(acl3.equals(deserializedCache.convertAcls(acl3)));    assertFalse(acl4.equals(deserializedCache.convertAcls(acl4)));    assertFalse(acl5.equals(deserializedCache.convertAcls(acl5)));}
callAddUsageNTimes
private void zookeeper_f5531_0(ReferenceCountedACLCache deserializedCache, Long aclId, int num)
{    for (int i = 0; i < num; i++) {        deserializedCache.addUsage(aclId);    }}
convertACLsNTimes
private Long zookeeper_f5532_0(ReferenceCountedACLCache cache, List<ACL> acl, int num)
{    if (num <= 0) {        return -1L;    }    for (int i = 0; i < num - 1; i++) {        cache.convertAcls(acl);    }    return cache.convertAcls(acl);}
createACL
private List<ACL> zookeeper_f5533_0(String id)
{    List<ACL> acl1 = new ArrayList<ACL>();    acl1.add(new ACL(ZooDefs.Perms.ADMIN, new Id("scheme", id)));    return acl1;}
setup
public voidf5534_1) throws Exception
{        File tmpDir = ClientBase.createTmpDir();    ClientBase.setupTestEnv();    zks = new TestZooKeeperServer(tmpDir, tmpDir, 3000);    final int PORT = Integer.parseInt(HOSTPORT.split(":")[1]);    f = ServerCnxnFactory.createFactory(PORT, -1);    f.startup(zks);        assertTrue("waiting for server being up", ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT));    resumeProcess = null;    submitted = null;    zk = ClientBase.createZKClient(HOSTPORT);}
tearDown
public void zookeeper_f5535_0() throws Exception
{        if (null != zk) {        zk.close();    }    if (null != f) {        f.shutdown();    }    if (null != zks) {        zks.shutdown();    }}
setupRequestProcessors
protected void zookeeper_f5536_0()
{    RequestProcessor finalProcessor = new FinalRequestProcessor(this);    RequestProcessor syncProcessor = new SyncRequestProcessor(this, finalProcessor);    ((SyncRequestProcessor) syncProcessor).start();    firstProcessor = new TestPrepRequestProcessor(this, syncProcessor);    ((TestPrepRequestProcessor) firstProcessor).start();}
submitRequest
public void zookeeper_f5537_0(Request si)
{    if (null != submitted) {        submitted.countDown();    }    super.submitRequest(si);}
requestFinished
public void zookeeper_f5538_0(Request request)
{    if (null != finished) {        finished.countDown();    }    super.requestFinished(request);}
pRequest
protected void zookeeper_f5539_0(Request request) throws RequestProcessorException
{        if (resumeProcess != null) {        try {            resumeProcess.await(20, TimeUnit.SECONDS);        } catch (Exception e) {        }    }    if (entered != null) {        entered.countDown();    }    super.pRequest(request);}
testRequestThrottler
public void zookeeper_f5540_0() throws Exception
{    ServerMetrics.getMetrics().resetAll();        RequestThrottler.setMaxRequests(2);    RequestThrottler.setStallTime(STALL_TIME);    RequestThrottler.setDropStaleRequests(false);        resumeProcess = new CountDownLatch(1);    submitted = new CountDownLatch(TOTAL_REQUESTS);    entered = new CountDownLatch(TOTAL_REQUESTS);        for (int i = 0; i < TOTAL_REQUESTS; i++) {        zk.create("/request_throttle_test- " + i, ("/request_throttle_test- " + i).getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, (rc, path, ctx, name) -> {        }, null);    }        submitted.await(5, TimeUnit.SECONDS);    Map<String, Object> metrics = MetricsUtils.currentServerMetrics();        assertEquals(2L, (long) metrics.get("prep_processor_request_queued"));    assertEquals(1L, (long) metrics.get("request_throttle_wait_count"));            resumeProcess.countDown();    entered.await(STALL_TIME, TimeUnit.MILLISECONDS);    metrics = MetricsUtils.currentServerMetrics();    assertEquals(TOTAL_REQUESTS, (long) metrics.get("prep_processor_request_queued"));}
testDropStaleRequests
public voidf5541_1) throws Exception
{    ServerMetrics.getMetrics().resetAll();        RequestThrottler.setMaxRequests(2);    RequestThrottler.setStallTime(STALL_TIME);    RequestThrottler.setDropStaleRequests(true);        resumeProcess = new CountDownLatch(1);    submitted = new CountDownLatch(TOTAL_REQUESTS);        for (int i = 0; i < TOTAL_REQUESTS; i++) {        zk.create("/request_throttle_test- " + i, ("/request_throttle_test- " + i).getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, (rc, path, ctx, name) -> {        }, null);    }        submitted.await(5, TimeUnit.SECONDS);    Map<String, Object> metrics = MetricsUtils.currentServerMetrics();        assertEquals(2L, (long) metrics.get("prep_processor_request_queued"));    assertEquals(1L, (long) metrics.get("request_throttle_wait_count"));    for (ServerCnxn cnxn : f.cnxns) {        cnxn.setStale();    }    zk = null;    resumeProcess.countDown();        while (zks.getInflight() > 0) {        Thread.sleep(50);    }            metrics = MetricsUtils.currentServerMetrics();    assertEquals(2L, (long) metrics.get("prep_processor_request_queued"));    assertEquals(1, (long) metrics.get("stale_requests_dropped"));}
testLargeRequestThrottling
public void zookeeper_f5542_0() throws Exception
{    ServerMetrics.getMetrics().resetAll();    AsyncCallback.StringCallback createCallback = (rc, path, ctx, name) -> {        if (KeeperException.Code.get(rc) == KeeperException.Code.CONNECTIONLOSS) {            disconnected.countDown();            connectionLossCount++;        }    };        RequestThrottler.setMaxRequests(5);        zks.setLargeRequestThreshold(150);    zks.setLargeRequestMaxBytes(400);        resumeProcess = new CountDownLatch(1);            disconnected = new CountDownLatch(TOTAL_REQUESTS);        byte[] data = new byte[100];        for (int i = 0; i < TOTAL_REQUESTS; i++) {        zk.create("/request_throttle_test- " + i, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, createCallback, null);    }        disconnected.await(5, TimeUnit.SECONDS);    Map<String, Object> metrics = MetricsUtils.currentServerMetrics();            Assert.assertEquals(2L, (long) metrics.get("prep_processor_request_queued"));    Assert.assertEquals(1L, (long) metrics.get("large_requests_rejected"));    Assert.assertEquals(5, connectionLossCount);    finished = new CountDownLatch(2);        resumeProcess.countDown();    finished.await(5, TimeUnit.SECONDS);        metrics = MetricsUtils.currentServerMetrics();    Assert.assertEquals(2, (long) metrics.get("stale_replies"));}
write
public void zookeeper_f5543_0(int b)
{}
createNodes
 static int zookeeper_f5544_0(DataTree tree, String path, int depth, int childcount, int parentCVersion, byte[] data) throws KeeperException.NodeExistsException, KeeperException.NoNodeException
{    path += "node" + depth;    tree.createNode(path, data, null, -1, ++parentCVersion, 1, 1);    if (--depth == 0) {        return 1;    }    path += "/";    int count = 1;    for (int i = 0; i < childcount; i++) {        count += createNodes(tree, path + i, depth, childcount, 1, data);    }    return count;}
serializeTree
private static voidf5545_1int depth, int width, int len) throws InterruptedException, IOException, KeeperException.NodeExistsException, KeeperException.NoNodeException
{    DataTree tree = new DataTree();    createNodes(tree, "/", depth, width, tree.getNode("/").stat.getCversion(), new byte[len]);    int count = tree.getNodeCount();    BinaryOutputArchive oa = BinaryOutputArchive.getArchive(new NullOutputStream());    System.gc();    long start = System.nanoTime();    tree.serialize(oa, "test");    long end = System.nanoTime();    long durationms = (end - start) / 1000000L;    long pernodeus = ((end - start) / 1000L) / count;    }
testSingleSerialize
public void zookeeper_f5546_0() throws InterruptedException, IOException, KeeperException.NodeExistsException, KeeperException.NoNodeException
{    serializeTree(1, 0, 20);}
testWideSerialize
public void zookeeper_f5547_0() throws InterruptedException, IOException, KeeperException.NodeExistsException, KeeperException.NoNodeException
{    serializeTree(2, 10000, 20);}
testDeepSerialize
public void zookeeper_f5548_0() throws InterruptedException, IOException, KeeperException.NodeExistsException, KeeperException.NoNodeException
{    serializeTree(400, 1, 20);}
test10Wide5DeepSerialize
public void zookeeper_f5549_0() throws InterruptedException, IOException, KeeperException.NodeExistsException, KeeperException.NoNodeException
{    serializeTree(5, 10, 20);}
test15Wide5DeepSerialize
public void zookeeper_f5550_0() throws InterruptedException, IOException, KeeperException.NodeExistsException, KeeperException.NoNodeException
{    serializeTree(5, 15, 20);}
test25Wide4DeepSerialize
public void zookeeper_f5551_0() throws InterruptedException, IOException, KeeperException.NodeExistsException, KeeperException.NoNodeException
{    serializeTree(4, 25, 20);}
test40Wide4DeepSerialize
public void zookeeper_f5552_0() throws InterruptedException, IOException, KeeperException.NodeExistsException, KeeperException.NoNodeException
{    serializeTree(4, 40, 20);}
test300Wide3DeepSerialize
public void zookeeper_f5553_0() throws InterruptedException, IOException, KeeperException.NodeExistsException, KeeperException.NoNodeException
{    serializeTree(3, 300, 20);}
data
public static List<TestType> zookeeper_f5554_0()
{    List<TestType> testTypes = new ArrayList<>();    for (boolean ttlsEnabled : new boolean[] { true, false }) {        for (int serverId = 0; serverId <= 255; ++serverId) {            testTypes.add(new TestType(ttlsEnabled, serverId));        }    }    return testTypes;}
tearDown
public void zookeeper_f5555_0() throws Exception
{    super.tearDown();    System.clearProperty("zookeeper.extendedTypesEnabled");}
setUp
public voidf5556_1) throws Exception
{    System.setProperty("zookeeper.extendedTypesEnabled", Boolean.toString(testType.ttlsEnabled));        try {        super.setUpWithServerId(testType.serverId);    } catch (RuntimeException e) {        if (testType.ttlsEnabled && (testType.serverId >= EphemeralType.MAX_EXTENDED_SERVER_ID)) {                        return;        }        throw e;    }}
doTest
public void zookeeper_f5557_0() throws Exception
{    if (testType.ttlsEnabled && (testType.serverId >= EphemeralType.MAX_EXTENDED_SERVER_ID)) {        return;    }    TestableZooKeeper zk = null;    try {        zk = createClient();        zk.create("/foo", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        zk.delete("/foo", -1);        if (testType.ttlsEnabled) {                        zk.create("/foo", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_WITH_TTL, new Stat(), 1000);        } else {            try {                zk.create("/foo", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_WITH_TTL, new Stat(), 1000);                fail("Should have thrown KeeperException.UnimplementedException");            } catch (KeeperException.UnimplementedException e) {                        }        }    } finally {        if (zk != null) {            zk.close();        }    }}
generateRandomValues
private long[] zookeeper_f5558_0(int size)
{        final long[] values = new long[size];    if (size == 0) {        return values;    }    final long rangeMin = Long.MIN_VALUE / size;    final long rangeMax = Long.MAX_VALUE / size;    for (int i = 0; i < size; ++i) {        values[i] = ThreadLocalRandom.current().nextLong(rangeMin, rangeMax);    }    return values;}
testAvgMinMaxCounter
public void zookeeper_f5559_0()
{    final AvgMinMaxCounter metric = new AvgMinMaxCounter("test");    testAvgMinMaxCounter(metric, 0);    testAvgMinMaxCounter(metric, 1);    for (int i = 0; i < RANDOM_TRIALS; ++i) {        testAvgMinMaxCounter(metric, RANDOM_SIZE);    }}
testAvgMinMaxCounter
private void zookeeper_f5560_0(AvgMinMaxCounter metric, int size)
{    final long[] values = generateRandomValues(size);    for (long value : values) {        metric.add(value);    }    long expectedMin = Arrays.stream(values).min().orElse(0);    long expectedMax = Arrays.stream(values).max().orElse(0);    long expectedSum = Arrays.stream(values).sum();    long expectedCnt = values.length;    double expectedAvg = expectedSum / Math.max(1, expectedCnt);    assertEquals(expectedAvg, metric.getAvg(), 200);    assertEquals(expectedMin, metric.getMin());    assertEquals(expectedMax, metric.getMax());    assertEquals(expectedCnt, metric.getCount());    assertEquals(expectedSum, metric.getTotal());    final Map<String, Object> results = metric.values();    assertEquals(expectedMax, (long) results.get("max_test"));    assertEquals(expectedMin, (long) results.get("min_test"));    assertEquals(expectedCnt, (long) results.get("cnt_test"));    assertEquals(expectedAvg, (double) results.get("avg_test"), 200);    metric.reset();}
testSimpleCounter
public void zookeeper_f5561_0()
{    SimpleCounter metric = new SimpleCounter("test");    testSimpleCounter(metric, 0);    testSimpleCounter(metric, 1);    for (int i = 0; i < RANDOM_TRIALS; ++i) {        testSimpleCounter(metric, RANDOM_SIZE);    }}
testSimpleCounter
private void zookeeper_f5562_0(SimpleCounter metric, int size)
{    final long[] values = generateRandomValues(size);    for (long value : values) {        metric.add(value);    }    long expectedCount = Arrays.stream(values).sum();    assertEquals(expectedCount, metric.get());    final Map<String, Object> results = metric.values();    assertEquals(expectedCount, (long) results.get("test"));    metric.reset();}
setUp
public void zookeeper_f5563_0()
{    providerMock = mock(ServerStats.Provider.class);}
testPacketsMetrics
public void zookeeper_f5564_0()
{        ServerStats serverStats = new ServerStats(providerMock);    int incrementCount = 20;        for (int i = 0; i < incrementCount; i++) {        serverStats.incrementPacketsSent();        serverStats.incrementPacketsReceived();        serverStats.incrementPacketsReceived();    }        assertEquals(incrementCount, serverStats.getPacketsSent());    assertEquals(incrementCount * 2, serverStats.getPacketsReceived());        serverStats.resetRequestCounters();        assertAllPacketsZero(serverStats);}
testLatencyMetrics
public void zookeeper_f5565_0()
{        ServerStats serverStats = new ServerStats(providerMock);        Request fakeRequest = new Request(0, 0, 0, null, null, 0);    serverStats.updateLatency(fakeRequest, fakeRequest.createTime + 1000);    serverStats.updateLatency(fakeRequest, fakeRequest.createTime + 2000);        assertThat("Max latency check", 2000L, lessThanOrEqualTo(serverStats.getMaxLatency()));    assertThat("Min latency check", 1000L, lessThanOrEqualTo(serverStats.getMinLatency()));    assertEquals(1500, serverStats.getAvgLatency(), 200);        serverStats.resetLatency();        assertAllLatencyZero(serverStats);}
testFsyncThresholdExceedMetrics
public void zookeeper_f5566_0()
{        ServerStats serverStats = new ServerStats(providerMock);    int incrementCount = 30;        for (int i = 0; i < incrementCount; i++) {        serverStats.incrementFsyncThresholdExceedCount();    }        assertEquals(incrementCount, serverStats.getFsyncThresholdExceedCount());        serverStats.resetFsyncThresholdExceedCount();        assertFsyncThresholdExceedCountZero(serverStats);}
testReset
public void zookeeper_f5567_0()
{        ServerStats serverStats = new ServerStats(providerMock);    assertAllPacketsZero(serverStats);    assertAllLatencyZero(serverStats);        Request fakeRequest = new Request(0, 0, 0, null, null, 0);    serverStats.incrementPacketsSent();    serverStats.incrementPacketsReceived();    serverStats.updateLatency(fakeRequest, fakeRequest.createTime + 1000);    serverStats.reset();        assertAllPacketsZero(serverStats);    assertAllLatencyZero(serverStats);}
assertAllPacketsZero
private void zookeeper_f5568_0(ServerStats serverStats)
{    assertEquals(0L, serverStats.getPacketsSent());    assertEquals(0L, serverStats.getPacketsReceived());}
assertAllLatencyZero
private void zookeeper_f5569_0(ServerStats serverStats)
{    assertEquals(0L, serverStats.getMaxLatency());    assertEquals(0L, serverStats.getMinLatency());    assertEquals(0, serverStats.getAvgLatency(), 0.00001);}
assertFsyncThresholdExceedCountZero
private void zookeeper_f5570_0(ServerStats serverStats)
{    assertEquals(0L, serverStats.getFsyncThresholdExceedCount());}
testAddSessionAfterSessionExpiry
public void zookeeper_f5571_0() throws Exception
{    RequestThrottler.setMaxRequests(0);    ZooKeeperServer zks = setupSessionTracker();    latch = new CountDownLatch(1);    zks.sessionTracker.trackSession(sessionId, sessionTimeout);    SessionTrackerImpl sessionTrackerImpl = (SessionTrackerImpl) zks.sessionTracker;    SessionImpl sessionImpl = sessionTrackerImpl.sessionsById.get(sessionId);    assertNotNull("Sessionid:" + sessionId + " doesn't exists in sessiontracker", sessionImpl);        Object sessionOwner = new Object();    sessionTrackerImpl.checkSession(sessionId, sessionOwner);        latch.await(sessionTimeout * 2, TimeUnit.MILLISECONDS);                sessionTrackerImpl.trackSession(sessionId, sessionTimeout);    try {        sessionTrackerImpl.checkSession(sessionId, sessionOwner);        fail("Should throw session expiry exception " + "as the session has expired and closed");    } catch (KeeperException.SessionExpiredException e) {        }    assertTrue("Session didn't expired", sessionImpl.isClosing());    assertFalse("Session didn't expired", sessionTrackerImpl.touchSession(sessionId, sessionTimeout));    assertEquals("Duplicate session expiry request has been generated", 1, firstProcessor.getCountOfCloseSessionReq());}
testCloseSessionRequestAfterSessionExpiry
public void zookeeper_f5572_0() throws Exception
{    ZooKeeperServer zks = setupSessionTracker();    latch = new CountDownLatch(1);    zks.sessionTracker.trackSession(sessionId, sessionTimeout);    SessionTrackerImpl sessionTrackerImpl = (SessionTrackerImpl) zks.sessionTracker;    SessionImpl sessionImpl = sessionTrackerImpl.sessionsById.get(sessionId);    assertNotNull("Sessionid:" + sessionId + " doesn't exists in sessiontracker", sessionImpl);        Object sessionOwner = new Object();    sessionTrackerImpl.checkSession(sessionId, sessionOwner);        latch.await(sessionTimeout * 2, TimeUnit.MILLISECONDS);            sessionTrackerImpl.removeSession(sessionId);    SessionImpl actualSession = sessionTrackerImpl.sessionsById.get(sessionId);    assertNull("Session:" + sessionId + " still exists after removal", actualSession);}
setupSessionTracker
private ZooKeeperServer zookeeper_f5573_0() throws IOException
{    File tmpDir = ClientBase.createTmpDir();    ClientBase.setupTestEnv();    ZooKeeperServer zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);    zks.setupRequestProcessors();    firstProcessor = new FirstProcessor(zks, null);    zks.firstProcessor = firstProcessor;        zks.createSessionTracker();    zks.startSessionTracker();    zks.startRequestThrottler();    return zks;}
processRequest
public void zookeeper_f5574_0(Request request)
{        if (request.type == OpCode.closeSession) {        countOfCloseSessionReq++;        latch.countDown();    }}
getCountOfCloseSessionReq
 int zookeeper_f5575_0()
{    return countOfCloseSessionReq;}
setUp
public void zookeeper_f5576_0() throws Exception
{    super.setUp();    server = serverFactory.getZooKeeperServer();    zk = createClient();}
tearDown
public void zookeeper_f5577_0() throws Exception
{        super.tearDown();    if (zk != null) {        zk.close();    }}
setupCustomizedEnv
public void zookeeper_f5578_0()
{    ZooKeeperServer.setDigestEnabled(true);    System.setProperty(ZooKeeperServer.SNAP_COUNT, "100");}
cleanUpCustomizedEnv
public void zookeeper_f5579_0()
{    ZooKeeperServer.setDigestEnabled(false);    System.clearProperty(ZooKeeperServer.SNAP_COUNT);}
testSnapshotDigest
public void zookeeper_f5580_0() throws Exception
{            server.takeSnapshot();    reloadSnapshotAndCheckDigest();        String pathPrefix = "/testSnapshotDigest";    for (int i = 0; i < 1000; i++) {        String path = pathPrefix + i;        zk.create(path, path.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    }        String firstNode = pathPrefix + 0;    zk.setData(firstNode, "new_setdata".getBytes(), -1);        zk.delete(firstNode, -1);        List<Op> subTxns = new ArrayList<Op>();    for (int i = 0; i < 3; i++) {        String path = pathPrefix + "-m" + i;        subTxns.add(Op.create(path, path.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT));    }    zk.multi(subTxns);    reloadSnapshotAndCheckDigest();        server = serverFactory.getZooKeeperServer();    server.takeSnapshot();    reloadSnapshotAndCheckDigest();}
testDifferentDigestVersion
public void zookeeper_f5581_0() throws Exception
{        int currentVersion = new DigestCalculator().getDigestVersion();        String path = "/testDifferentDigestVersion";    zk.create(path, path.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        server.takeSnapshot();        int newVersion = currentVersion + 1;    DigestCalculator newVersionDigestCalculator = Mockito.spy(DigestCalculator.class);    Mockito.when(newVersionDigestCalculator.getDigestVersion()).thenReturn(newVersion);    assertEquals(newVersion, newVersionDigestCalculator.getDigestVersion());            FileTxnSnapLog txnSnapLog = new FileTxnSnapLog(tmpDir, tmpDir);    DataTree dataTree = Mockito.spy(new DataTree(newVersionDigestCalculator));    Mockito.when(dataTree.getTreeDigest()).thenReturn(0L);    txnSnapLog.restore(dataTree, new ConcurrentHashMap<>(), Mockito.mock(FileTxnSnapLog.PlayBackListener.class));        Mockito.verify(dataTree, Mockito.never()).reportDigestMismatch(Mockito.anyLong());}
testBackwardCompatible
public void zookeeper_f5582_0() throws Exception
{    testCompatibleHelper(false, true);    testCompatibleHelper(true, false);}
testCompatibleHelper
private void zookeeper_f5583_0(Boolean enabledBefore, Boolean enabledAfter) throws Exception
{    ZooKeeperServer.setDigestEnabled(enabledBefore);        reloadSnapshotAndCheckDigest();        String path = "/testCompatible" + "-" + enabledBefore + "-" + enabledAfter;    zk.create(path, path.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        server.takeSnapshot();    ZooKeeperServer.setDigestEnabled(enabledAfter);    reloadSnapshotAndCheckDigest();    assertEquals(path, new String(zk.getData(path, false, null)));}
reloadSnapshotAndCheckDigest
private void zookeeper_f5584_0() throws Exception
{    stopServer();    QuorumPeerMainTest.waitForOne(zk, States.CONNECTING);    ((SimpleCounter) ServerMetrics.getMetrics().DIGEST_MISMATCHES_COUNT).reset();    startServer();    QuorumPeerMainTest.waitForOne(zk, States.CONNECTED);        assertEquals(0L, ServerMetrics.getMetrics().DIGEST_MISMATCHES_COUNT.get());        assertNull(server.getZKDatabase().getDataTree().getDigestFromLoadedSnapshot());}
testJuteToString
public void zookeeper_f5585_0()
{    SetDataRequest req = new SetDataRequest(null, null, 0);    assertNotSame("ERROR", req.toString());}
generateRandomHashes
private static List<Long> zookeeper_f5586_0(int count)
{    ArrayList<Long> list = new ArrayList<>(count);    for (int i = 0; i < count; i++) {        list.add(rand.nextLong());    }    return list;}
addListOfDigests
private static void zookeeper_f5587_0(AdHash hash, List<Long> digests)
{    for (long b : digests) {        hash.addDigest(b);    }}
removeListOfDigests
private static void zookeeper_f5588_0(AdHash hash, List<Long> digests)
{    for (long b : digests) {        hash.removeDigest(b);    }}
testAdHash
public void zookeeper_f5589_0() throws Exception
{    List<Long> bucket1 = generateRandomHashes(50);    List<Long> bucket2 = generateRandomHashes(3);    List<Long> bucket3 = generateRandomHashes(30);    List<Long> bucket4 = generateRandomHashes(10);    List<Long> bucket5 = generateRandomHashes(5);        AdHash hash12 = new AdHash();    addListOfDigests(hash12, bucket1);    addListOfDigests(hash12, bucket2);    AdHash hash21 = new AdHash();    addListOfDigests(hash21, bucket2);    addListOfDigests(hash21, bucket1);    assertEquals(hash12, hash21);    AdHash hashall = new AdHash();    addListOfDigests(hashall, bucket1);    addListOfDigests(hashall, bucket2);    addListOfDigests(hashall, bucket3);    addListOfDigests(hashall, bucket4);    addListOfDigests(hashall, bucket5);    assertFalse("digest of different set not different", hashall.equals(hash21));    removeListOfDigests(hashall, bucket4);    removeListOfDigests(hashall, bucket5);    addListOfDigests(hash21, bucket3);    assertEquals("hashall with 4 & 5 removed should match hash21 with 3 added", hashall, hash21);    removeListOfDigests(hashall, bucket3);    removeListOfDigests(hashall, bucket2);    removeListOfDigests(hashall, bucket1);    assertEquals("empty hashall's digest should be 0", hashall.toHexString(), "0");    AdHash hash45 = new AdHash();    addListOfDigests(hash45, bucket4);    addListOfDigests(hash45, bucket5);    addListOfDigests(hashall, bucket4);    addListOfDigests(hashall, bucket5);    assertEquals("empty hashall + 4&5 should equal hash45", hashall, hash45);}
testAddWatchBit
public void zookeeper_f5590_0()
{    int watcherCacheSize = 1;    BitHashSet ws = new BitHashSet(watcherCacheSize);    assertTrue(ws.add(1));    assertEquals(1, ws.size());    assertEquals(1, ws.cachedSize());    List<Integer> actualBits = new ArrayList<Integer>();    for (int bit : ws) {        actualBits.add(bit);    }    assertArrayEquals(new Integer[] { 1 }, actualBits.toArray(new Integer[actualBits.size()]));        assertFalse(ws.add(1));    assertEquals(1, ws.size());    assertEquals(1, ws.cachedSize());        assertTrue(ws.add(2));    assertEquals(2, ws.size());    assertEquals(1, ws.cachedSize());    assertTrue(ws.contains(1));    actualBits.clear();    for (int bit : ws) {        actualBits.add(bit);    }    assertArrayEquals(new Integer[] { 1, 2 }, actualBits.toArray(new Integer[actualBits.size()]));}
testRemoveWatchBit
public void zookeeper_f5591_0()
{    int watcherCacheSize = 1;    BitHashSet ws = new BitHashSet(watcherCacheSize);    ws.add(1);    ws.add(2);    assertTrue(ws.contains(1));    assertTrue(ws.contains(2));    ws.remove(1);    assertFalse(ws.contains(1));    assertEquals(1, ws.size());    assertEquals(0, ws.cachedSize());    List<Integer> actualBits = new ArrayList<Integer>();    for (int bit : ws) {        actualBits.add(bit);    }    assertArrayEquals(new Integer[] { 2 }, actualBits.toArray(new Integer[actualBits.size()]));    ws.add(3);    assertEquals(2, ws.size());    assertEquals(1, ws.cachedSize());    actualBits.clear();    for (int bit : ws) {        actualBits.add(bit);    }    assertArrayEquals(new Integer[] { 2, 3 }, actualBits.toArray(new Integer[actualBits.size()]));    ws.remove(2);    ws.remove(3);    assertEquals(0, ws.size());    assertEquals(0, ws.cachedSize());}
testAddAndRemove
public void zookeeper_f5592_0()
{    BitMap<String> bitMap = new BitMap<String>();    String v1 = "v1";    Integer bit = bitMap.add(v1);    assertEquals(1, bitMap.size());    assertTrue(bit >= 0);    assertEquals(v1, bitMap.get(bit));    assertEquals(bit, bitMap.getBit(v1));        Integer newBit = bitMap.add(v1);    assertEquals(bit, newBit);    assertEquals(1, bitMap.size());    String v2 = "v2";    Integer v2Bit = bitMap.add(v2);    assertEquals(2, bitMap.size());    assertNotEquals(v2Bit, bit);        bitMap.remove(v1);    assertEquals(1, bitMap.size());    assertNull(bitMap.get(bit));    assertNull(bitMap.getBit(v1));        bitMap.remove(v2Bit);    assertEquals(0, bitMap.size());    assertNull(bitMap.get(v2Bit));    assertNull(bitMap.getBit(v2));}
testBitReuse
public void zookeeper_f5593_0()
{    BitMap<String> bitMap = new BitMap<String>();    int v1Bit = bitMap.add("v1");    int v2Bit = bitMap.add("v2");    int v3Bit = bitMap.add("v3");    bitMap.remove(v2Bit);    int v4Bit = bitMap.add("v4");    assertEquals(v4Bit, v2Bit);}
testCircularBuffer
public void zookeeper_f5594_0()
{    final int capacity = 3;    CircularBuffer<String> buffer = new CircularBuffer<>(String.class, capacity);    Assert.assertTrue(buffer.isEmpty());    Assert.assertFalse(buffer.isFull());        buffer.write("A");    Assert.assertFalse(buffer.isEmpty());    Assert.assertFalse(buffer.isFull());    buffer.write("B");    Assert.assertFalse(buffer.isEmpty());    Assert.assertFalse(buffer.isFull());    buffer.write("C");    Assert.assertFalse(buffer.isEmpty());    Assert.assertTrue(buffer.isFull());            Assert.assertEquals("A", buffer.take());    Assert.assertFalse(buffer.isEmpty());    Assert.assertFalse(buffer.isFull());    Assert.assertEquals("B", buffer.take());    Assert.assertFalse(buffer.isEmpty());    Assert.assertFalse(buffer.isFull());    Assert.assertEquals("C", buffer.take());    Assert.assertTrue(buffer.isEmpty());    Assert.assertFalse(buffer.isFull());        buffer.write("1");    Assert.assertFalse(buffer.isEmpty());    Assert.assertFalse(buffer.isFull());    buffer.write("2");    Assert.assertFalse(buffer.isEmpty());    Assert.assertFalse(buffer.isFull());    buffer.write("3");    Assert.assertFalse(buffer.isEmpty());    Assert.assertTrue(buffer.isFull());        buffer.write("4");    Assert.assertFalse(buffer.isEmpty());    Assert.assertTrue(buffer.isFull());            Assert.assertEquals("2", buffer.take());    Assert.assertFalse(buffer.isEmpty());    Assert.assertFalse(buffer.isFull());    Assert.assertEquals("3", buffer.take());    Assert.assertFalse(buffer.isEmpty());    Assert.assertFalse(buffer.isFull());    Assert.assertEquals("4", buffer.take());    Assert.assertTrue(buffer.isEmpty());    Assert.assertFalse(buffer.isFull());        buffer.write("a");    Assert.assertFalse(buffer.isEmpty());    Assert.assertFalse(buffer.isFull());    buffer.write("b");    Assert.assertFalse(buffer.isEmpty());    Assert.assertFalse(buffer.isFull());    buffer.write("c");    Assert.assertFalse(buffer.isEmpty());    Assert.assertTrue(buffer.isFull());        buffer.write("d");    Assert.assertFalse(buffer.isEmpty());    Assert.assertTrue(buffer.isFull());        buffer.write("e");    Assert.assertFalse(buffer.isEmpty());    Assert.assertTrue(buffer.isFull());        buffer.write("f");    Assert.assertFalse(buffer.isEmpty());    Assert.assertTrue(buffer.isFull());        buffer.write("g");    Assert.assertFalse(buffer.isEmpty());    Assert.assertTrue(buffer.isFull());            Assert.assertEquals("e", buffer.take());    Assert.assertFalse(buffer.isEmpty());    Assert.assertFalse(buffer.isFull());    Assert.assertEquals("f", buffer.take());    Assert.assertFalse(buffer.isEmpty());    Assert.assertFalse(buffer.isFull());    Assert.assertEquals("g", buffer.take());    Assert.assertTrue(buffer.isEmpty());    Assert.assertFalse(buffer.isFull());}
testCircularBufferWithCapacity1
public void zookeeper_f5595_0()
{    final int capacity = 1;    CircularBuffer<String> buffer = new CircularBuffer<>(String.class, capacity);    Assert.assertTrue(buffer.isEmpty());    Assert.assertFalse(buffer.isFull());        buffer.write("A");    Assert.assertFalse(buffer.isEmpty());    Assert.assertTrue(buffer.isFull());        buffer.write("B");    Assert.assertFalse(buffer.isEmpty());    Assert.assertTrue(buffer.isFull());            Assert.assertEquals("B", buffer.take());    Assert.assertTrue(buffer.isEmpty());    Assert.assertFalse(buffer.isFull());}
testCircularBufferReset
public void zookeeper_f5596_0()
{    final int capacity = 3;    CircularBuffer<String> buffer = new CircularBuffer<>(String.class, capacity);    Assert.assertTrue(buffer.isEmpty());    Assert.assertFalse(buffer.isFull());        buffer.write("A");    Assert.assertFalse(buffer.isEmpty());    Assert.assertFalse(buffer.isFull());    Assert.assertEquals(1, buffer.size());    Assert.assertEquals("A", buffer.peek());    buffer.write("B");    Assert.assertFalse(buffer.isEmpty());    Assert.assertFalse(buffer.isFull());    Assert.assertEquals(2, buffer.size());    Assert.assertEquals("A", buffer.peek());        buffer.reset();    Assert.assertNull(buffer.peek());    Assert.assertTrue(buffer.isEmpty());    Assert.assertFalse(buffer.isFull());    Assert.assertEquals(0, buffer.size());}
testCircularBufferIllegalCapacity
public void zookeeper_f5597_0()
{    try {        CircularBuffer<String> buffer = new CircularBuffer<>(String.class, 0);        Assert.fail();    } catch (IllegalArgumentException e) {        Assert.assertEquals("CircularBuffer capacity should be greater than 0", e.getMessage());    }}
testGetHostAndPortWithIPv6
public void zookeeper_f5598_0() throws ConfigException
{    String[] nsa = ConfigUtils.getHostAndPort("[2001:db8:85a3:8d3:1319:8a2e:370:7348]:443");    assertEquals(nsa[0], "2001:db8:85a3:8d3:1319:8a2e:370:7348");    assertEquals(nsa[1], "443");    nsa = ConfigUtils.getHostAndPort("[2001:db8:1::242:ac11:2]:2888:3888");    assertEquals(nsa[0], "2001:db8:1::242:ac11:2");    assertEquals(nsa[1], "2888");    assertEquals(nsa[2], "3888");}
testGetHostAndPortWithIPv4
public void zookeeper_f5599_0() throws ConfigException
{    String[] nsa = ConfigUtils.getHostAndPort("127.0.0.1:443");    assertEquals(nsa[0], "127.0.0.1");    assertEquals(nsa[1], "443");    nsa = ConfigUtils.getHostAndPort("127.0.0.1:2888:3888");    assertEquals(nsa[0], "127.0.0.1");    assertEquals(nsa[1], "2888");    assertEquals(nsa[2], "3888");}
testGetHostAndPortWithoutBracket
public void zookeeper_f5600_0() throws ConfigException
{    String[] nsa = ConfigUtils.getHostAndPort("[2001:db8:85a3:8d3:1319:8a2e:370:7348");}
testGetHostAndPortWithoutPortAfterColon
public void zookeeper_f5601_0() throws ConfigException
{    String[] nsa = ConfigUtils.getHostAndPort("[2001:db8:1::242:ac11:2]:");}
testGetHostAndPortWithoutPort
public void zookeeper_f5602_0() throws ConfigException
{    String[] nsa = ConfigUtils.getHostAndPort("127.0.0.1");    assertEquals(nsa[0], "127.0.0.1");    assertEquals(nsa.length, 1);    nsa = ConfigUtils.getHostAndPort("[2001:db8:1::242:ac11:2]");    assertEquals(nsa[0], "2001:db8:1::242:ac11:2");    assertEquals(nsa.length, 1);}
testJvmPauseMonitorExceedInfoThreshold
public void zookeeper_f5603_0() throws InterruptedException
{    QuorumPeerConfig qpConfig = mock(QuorumPeerConfig.class);    when(qpConfig.getJvmPauseSleepTimeMs()).thenReturn(sleepTime);    when(qpConfig.getJvmPauseInfoThresholdMs()).thenReturn(infoTH);    pauseMonitor = new JvmPauseMonitor(qpConfig);    pauseMonitor.serviceStart();    assertEquals(sleepTime, Long.valueOf(pauseMonitor.sleepTimeMs));    assertEquals(infoTH, Long.valueOf(pauseMonitor.infoThresholdMs));    while (pauseMonitor.getNumGcInfoThresholdExceeded() == 0) {        Thread.sleep(200);    }}
testJvmPauseMonitorExceedWarnThreshold
public void zookeeper_f5604_0() throws InterruptedException
{    QuorumPeerConfig qpConfig = mock(QuorumPeerConfig.class);    when(qpConfig.getJvmPauseSleepTimeMs()).thenReturn(sleepTime);    when(qpConfig.getJvmPauseWarnThresholdMs()).thenReturn(warnTH);    pauseMonitor = new JvmPauseMonitor(qpConfig);    pauseMonitor.serviceStart();    assertEquals(sleepTime, Long.valueOf(pauseMonitor.sleepTimeMs));    assertEquals(warnTH, Long.valueOf(pauseMonitor.warnThresholdMs));    while (pauseMonitor.getNumGcWarnThresholdExceeded() == 0) {        Thread.sleep(200);    }}
teardown
public void zookeeper_f5605_0()
{    pauseMonitor.serviceStop();}
setup
public void zookeeper_f5606_0()
{    System.setProperty(MessageTracker.MESSAGE_TRACKER_ENABLED, "true");}
tearDown
public void zookeeper_f5607_0() throws Exception
{    System.clearProperty(MessageTracker.MESSAGE_TRACKER_ENABLED);}
testTrackSend
public void zookeeper_f5608_0() throws InterruptedException
{    long timestamp1 = System.currentTimeMillis();    MessageTracker messageTracker = new MessageTracker(BUFFERED_MESSAGE_SIZE);        messageTracker.trackSent(timestamp1);    Assert.assertEquals(messageTracker.peekSentTimestamp(), timestamp1);    Thread.sleep(2);        long timestamp2 = System.currentTimeMillis();    messageTracker.trackSent(timestamp2);    Assert.assertEquals(messageTracker.peekSentTimestamp(), timestamp1);}
testTrackReceived
public void zookeeper_f5609_0() throws InterruptedException
{    long timestamp1 = System.currentTimeMillis();    MessageTracker messageTracker = new MessageTracker(BUFFERED_MESSAGE_SIZE);        messageTracker.trackReceived(timestamp1);    Assert.assertEquals(messageTracker.peekReceivedTimestamp(), timestamp1);    Thread.sleep(2);        long timestamp2 = System.currentTimeMillis();    messageTracker.trackReceived(timestamp2);    Assert.assertEquals(messageTracker.peekReceivedTimestamp(), timestamp1);}
testMessageTrackerFull
public void zookeeper_f5610_0() throws InterruptedException
{    MessageTracker messageTracker = new MessageTracker(BUFFERED_MESSAGE_SIZE);        long timestampSent = 0;    long timestampReceived = 0;    for (int i = 0; i <= BUFFERED_MESSAGE_SIZE; i++) {        if (i == 1) {            timestampSent = System.currentTimeMillis();            messageTracker.trackSent(timestampSent);            Thread.sleep(2);            timestampReceived = System.currentTimeMillis();            messageTracker.trackReceived(timestampReceived);        } else {            messageTracker.trackSent(System.currentTimeMillis());            messageTracker.trackReceived(System.currentTimeMillis());        }        Thread.sleep(1);    }    Assert.assertEquals(messageTracker.peekSentTimestamp(), timestampSent);    Assert.assertEquals(messageTracker.peekReceivedTimestamp(), timestampReceived);}
testDumpToLog
public void zookeeper_f5611_0()
{    long timestamp1 = System.currentTimeMillis();    MessageTracker messageTracker = new MessageTracker(BUFFERED_MESSAGE_SIZE);    String sid = "127.0.0.1";        messageTracker.dumpToLog(sid);    Assert.assertNull(messageTracker.peekSent());    Assert.assertNull(messageTracker.peekReceived());        messageTracker.trackSent(timestamp1);    Assert.assertEquals(messageTracker.peekSentTimestamp(), timestamp1);    Assert.assertNull(messageTracker.peekReceived());    messageTracker.dumpToLog(sid);    Assert.assertNull(messageTracker.peekSent());    Assert.assertNull(messageTracker.peekReceived());        messageTracker.trackSent(timestamp1);    messageTracker.trackReceived(timestamp1);    Assert.assertEquals(messageTracker.peekSentTimestamp(), timestamp1);    Assert.assertEquals(messageTracker.peekReceivedTimestamp(), timestamp1);    messageTracker.dumpToLog(sid);    Assert.assertNull(messageTracker.peekSent());    Assert.assertNull(messageTracker.peekReceived());}
run
public voidf5612_1)
{    Thread.currentThread().setName(toClose.toString() + "-->" + toClose2.toString());    byte[] buf = new byte[1024];    try {        while (true) {            try {                int read = this.in.read(buf);                if (read > 0) {                    try {                        this.out.write(buf, 0, read);                    } catch (IOException e) {                                                break;                    }                } else if (read < 0) {                    throw new IOException("read " + read);                }            } catch (SocketTimeoutException e) {                            }        }        Thread.sleep(1);    } catch (InterruptedException e) {            } catch (SocketException e) {        if (!"Socket closed".equals(e.getMessage())) {                    }    } catch (IOException e) {            } finally {        shutdown();    }        isFinished = true;}
waitForShutdown
 boolean zookeeper_f5613_0(long timeoutMs) throws InterruptedException
{    synchronized (this) {        if (!isFinished) {            this.wait(timeoutMs);        }    }    return isFinished;}
shutdown
public void zookeeper_f5614_0()
{    try {        toClose.close();    } catch (IOException ex) {        }    try {        toClose2.close();    } catch (IOException ex) {        }}
run
public voidf5615_1)
{    try {        while (!stopped) {            Socket sock = null;            try {                                sock = serverSocket.accept();                                Socket target = null;                int retry = 10;                while (sock.isConnected()) {                    try {                        target = new Socket("localhost", to);                        break;                    } catch (IOException e) {                        if (retry == 0) {                            throw e;                        }                                            }                    Thread.sleep(TimeUnit.SECONDS.toMillis(1));                    retry--;                }                                sock.setSoTimeout(30000);                target.setSoTimeout(30000);                workers.add(new PortForwardWorker(sock, target, sock.getInputStream(), target.getOutputStream()));                workers.add(new PortForwardWorker(target, sock, target.getInputStream(), sock.getOutputStream()));                for (PortForwardWorker worker : workers) {                    workerExecutor.submit(worker);                }            } catch (SocketTimeoutException e) {                            } catch (ConnectException e) {                                sock.close();            } catch (IOException e) {                if (!"Socket closed".equals(e.getMessage())) {                                        throw e;                }            }        }    } catch (IOException e) {            } catch (InterruptedException e) {            }}
shutdown
public void zookeeper_f5616_0() throws Exception
{    this.stopped = true;    this.serverSocket.close();    this.join();    this.workerExecutor.shutdownNow();    for (PortForwardWorker worker : workers) {        worker.shutdown();    }    for (PortForwardWorker worker : workers) {        if (!worker.waitForShutdown(5000)) {            throw new Exception("Failed to stop forwarding within 5 seconds");        }    }}
setUp
public void zookeeper_f5617_0()
{    System.setProperty("zookeeper.pathStats.enabled", "true");    System.setProperty("zookeeper.pathStats.slotCapacity", "60");    System.setProperty("zookeeper.pathStats.slotDuration", "1");    System.setProperty("zookeeper.pathStats.maxDepth", "6");    System.setProperty("zookeeper.pathStats.sampleRate", "1.0");}
tearDown
public void zookeeper_f5618_0()
{    System.clearProperty("zookeeper.pathStats.enabled");    System.clearProperty("zookeeper.pathStats.slotCapacity");    System.clearProperty("zookeeper.pathStats.slotDuration");    System.clearProperty("zookeeper.pathStats.maxDepth");    System.clearProperty("zookeeper.pathStats.sampleRate");}
testTrimPath
public void zookeeper_f5619_0()
{        String trimedPath = RequestPathMetricsCollector.trimPathDepth("/p1/p2/p3", 1);    assertTrue(trimedPath.equalsIgnoreCase("/p1"));    trimedPath = RequestPathMetricsCollector.trimPathDepth("/p1/p2/p3", 2);    assertTrue(trimedPath.equalsIgnoreCase("/p1/p2"));    trimedPath = RequestPathMetricsCollector.trimPathDepth("/p1/p2/p3", 3);    assertTrue(trimedPath.equalsIgnoreCase("/p1/p2/p3"));    trimedPath = RequestPathMetricsCollector.trimPathDepth("/p1/p2/p3", 4);    assertTrue(trimedPath.equalsIgnoreCase("/p1/p2/p3"));        trimedPath = RequestPathMetricsCollector.trimPathDepth("//p1 next/p2.index/p3:next", 3);    assertTrue(trimedPath.equalsIgnoreCase("/p1 next/p2.index/p3:next"));    trimedPath = RequestPathMetricsCollector.trimPathDepth("//p1 next/p2.index/p3:next", 2);    assertTrue(trimedPath.equalsIgnoreCase("/p1 next/p2.index"));    trimedPath = RequestPathMetricsCollector.trimPathDepth("//p1 next/p2.index/p3:next", 6);    assertTrue(trimedPath.equalsIgnoreCase("/p1 next/p2.index/p3:next"));}
testQueueMapReduce
public void zookeeper_f5620_0() throws InterruptedException
{    RequestPathMetricsCollector requestPathMetricsCollector = new RequestPathMetricsCollector();    RequestPathMetricsCollector.PathStatsQueue pathStatsQueue = requestPathMetricsCollector.new PathStatsQueue(create2);    Thread path7 = new Thread(() -> {        for (int i = 0; i < 1000000; i++) {            pathStatsQueue.registerRequest("/path1/path2/path3/path4/path5/path6/path7" + "_" + i);        }    });    path7.start();    Thread path6 = new Thread(() -> {        pathStatsQueue.registerRequest("/path1/path2/path3/path4/path5/path6");        for (int i = 1; i < 100000; i++) {            pathStatsQueue.registerRequest("/path1/path2/path3/path4/path5/path6" + "_" + i);        }    });    path6.start();    for (int i = 0; i < 1; i++) {        pathStatsQueue.registerRequest("/path1");    }    for (int i = 0; i < 10; i++) {        pathStatsQueue.registerRequest("/path1/path2" + "_" + i);    }    for (int i = 0; i < 100; i++) {        pathStatsQueue.registerRequest("/path1/path2/path3" + "_" + i);    }    for (int i = 0; i < 1000; i++) {        pathStatsQueue.registerRequest("/path1/path2/path3/path4" + "_" + i);    }    for (int i = 0; i < 10000; i++) {        pathStatsQueue.registerRequest("/path1/path2/path3/path4/path5" + "_" + i);    }    path6.join();    path7.join();    Map<String, Integer> newSlot = pathStatsQueue.mapReducePaths(1, pathStatsQueue.getCurrentSlot());    assertTrue(newSlot.size() == 1);    assertTrue(newSlot.get("/path1").compareTo(1111111) == 0);        newSlot = pathStatsQueue.mapReducePaths(2, pathStatsQueue.getCurrentSlot());    assertTrue(newSlot.size() == 12);    assertTrue(newSlot.get("/path1").compareTo(1) == 0);    assertTrue(newSlot.get("/path1/path2").compareTo(1111100) == 0);        newSlot = pathStatsQueue.mapReducePaths(3, pathStatsQueue.getCurrentSlot());    assertTrue(newSlot.size() == 112);    assertTrue(newSlot.get("/path1").compareTo(1) == 0);    assertTrue(newSlot.get("/path1/path2/path3").compareTo(1111000) == 0);        newSlot = pathStatsQueue.mapReducePaths(4, pathStatsQueue.getCurrentSlot());    assertTrue(newSlot.size() == 1112);    assertTrue(newSlot.get("/path1/path2/path3/path4").compareTo(1110000) == 0);        newSlot = pathStatsQueue.mapReducePaths(5, pathStatsQueue.getCurrentSlot());    assertTrue(newSlot.size() == 11112);    assertTrue(newSlot.get("/path1/path2/path3/path4/path5").compareTo(1100000) == 0);        newSlot = pathStatsQueue.mapReducePaths(6, pathStatsQueue.getCurrentSlot());    assertTrue(newSlot.size() == 111111);    assertTrue(newSlot.get("/path1/path2/path3/path4/path5/path6").compareTo(1000001) == 0);        newSlot = pathStatsQueue.mapReducePaths(7, pathStatsQueue.getCurrentSlot());    assertTrue(newSlot.size() == 1111111);}
testCollectEmptyStats
public void zookeeper_f5621_0() throws InterruptedException
{    RequestPathMetricsCollector requestPathMetricsCollector = new RequestPathMetricsCollector();    RequestPathMetricsCollector.PathStatsQueue pathStatsQueue = requestPathMetricsCollector.new PathStatsQueue(getChildren);    Thread.sleep(5000);    Map<String, Integer> newSlot = pathStatsQueue.mapReducePaths(3, pathStatsQueue.getCurrentSlot());    assertTrue(newSlot.isEmpty());    pathStatsQueue.start();    Thread.sleep(15000);    newSlot = pathStatsQueue.collectStats(1);    assertTrue(newSlot.size() == 0);    newSlot = pathStatsQueue.collectStats(2);    assertTrue(newSlot.size() == 0);    newSlot = pathStatsQueue.collectStats(5);    assertTrue(newSlot.size() == 0);}
testCollectStats
public void zookeeper_f5622_0() throws InterruptedException
{    RequestPathMetricsCollector requestPathMetricsCollector = new RequestPathMetricsCollector(true);    RequestPathMetricsCollector.PathStatsQueue pathStatsQueue = requestPathMetricsCollector.new PathStatsQueue(getChildren);    pathStatsQueue.start();    Thread path7 = new Thread(() -> {        for (int i = 0; i < 10; i++) {            try {                Thread.sleep(500);            } catch (InterruptedException e) {                e.printStackTrace();            }            for (int j = 0; j < 100000; j++) {                pathStatsQueue.registerRequest("/path1/path2/path3/path4/path5/path6/path7" + "_" + i + "_" + j);            }        }    });    path7.start();    Thread path6 = new Thread(() -> {        pathStatsQueue.registerRequest("/path1/path2/path3/path4/path5/path6");        for (int i = 0; i < 10; i++) {            try {                Thread.sleep(100);            } catch (InterruptedException e) {                e.printStackTrace();            }            for (int j = 0; j < 10000; j++) {                pathStatsQueue.registerRequest("/path1/path2/path3/path4/path5/path6" + "_" + i + "_" + j);            }        }    });    path6.start();    for (int i = 0; i < 1; i++) {        pathStatsQueue.registerRequest("/path1");    }    for (int i = 0; i < 10; i++) {        pathStatsQueue.registerRequest("/path1/path2" + "_" + i);    }    for (int i = 0; i < 100; i++) {        pathStatsQueue.registerRequest("/path1/path2/path3" + "_" + i);    }    for (int i = 0; i < 1000; i++) {        pathStatsQueue.registerRequest("/path1/path2/path3/path4" + "_" + i);    }    try {        Thread.sleep(1000);    } catch (InterruptedException e) {        e.printStackTrace();    }    for (int i = 0; i < 10000; i++) {        pathStatsQueue.registerRequest("/path1/path2/path3/path4/path5" + "_" + i);    }    path6.join();    path7.join();    Map<String, Integer> newSlot = pathStatsQueue.collectStats(1);    assertEquals(newSlot.size(), 1);    assertEquals(newSlot.get("/path1").intValue(), 1111112);        newSlot = pathStatsQueue.collectStats(2);    assertEquals(newSlot.size(), 12);    assertEquals(newSlot.get("/path1").intValue(), 1);    assertEquals(newSlot.get("/path1/path2").intValue(), 1111101);        newSlot = pathStatsQueue.collectStats(3);    assertEquals(newSlot.size(), 112);    assertEquals(newSlot.get("/path1").intValue(), 1);    assertEquals(newSlot.get("/path1/path2/path3").intValue(), 1111001);        newSlot = pathStatsQueue.collectStats(4);    assertEquals(newSlot.size(), 1112);    assertEquals(newSlot.get("/path1/path2/path3/path4").intValue(), 1110001);        newSlot = pathStatsQueue.collectStats(5);    assertEquals(newSlot.size(), 11112);    assertEquals(newSlot.get("/path1/path2/path3/path4/path5").intValue(), 1100001);        newSlot = pathStatsQueue.collectStats(6);    assertEquals(newSlot.size(), 111112);    assertEquals(newSlot.get("/path1/path2/path3/path4/path5/path6").intValue(), 1000001);}
testAggregate
public void zookeeper_f5623_0() throws InterruptedException
{    RequestPathMetricsCollector requestPathMetricsCollector = new RequestPathMetricsCollector(true);    Thread path7 = new Thread(() -> {        for (int i = 0; i < 10; i++) {            try {                Thread.sleep(100);            } catch (InterruptedException e) {                e.printStackTrace();            }            for (int j = 0; j < 100000; j++) {                requestPathMetricsCollector.registerRequest(getData, "/path1/path2/path3/path4/path5/path6/path7" + "_" + i + "_" + j);            }        }    });    path7.start();    Thread path6 = new Thread(() -> {        requestPathMetricsCollector.registerRequest(getChildren2, "/path1/path2/path3/path4/path5/path6");        for (int i = 0; i < 10; i++) {            try {                Thread.sleep(1000);            } catch (InterruptedException e) {                e.printStackTrace();            }            for (int j = 0; j < 10000; j++) {                requestPathMetricsCollector.registerRequest(getChildren, "/path1/path2/path3/path4/path5/path6" + "_" + i + "_" + j);            }        }    });    path6.start();    for (int i = 0; i < 1; i++) {        requestPathMetricsCollector.registerRequest(create2, "/path1");    }    for (int i = 0; i < 10; i++) {        requestPathMetricsCollector.registerRequest(create, "/path1/path2" + "_" + i);    }    for (int i = 0; i < 100; i++) {        requestPathMetricsCollector.registerRequest(delete, "/path1/path2/path3" + "_" + i);    }    for (int i = 0; i < 1000; i++) {        requestPathMetricsCollector.registerRequest(setData, "/path1/path2/path3/path4" + "_" + i);    }    for (int i = 0; i < 10000; i++) {        requestPathMetricsCollector.registerRequest(exists, "/path1/path2/path3/path4/path5" + "_" + i);    }    path6.join();    path7.join();    Map<String, Integer> newSlot = requestPathMetricsCollector.aggregatePaths(2, queue -> true);    assertEquals(newSlot.size(), 12);    assertEquals(newSlot.get("/path1").intValue(), 1);    assertEquals(newSlot.get("/path1/path2").intValue(), 1111101);        newSlot = requestPathMetricsCollector.aggregatePaths(3, queue -> true);    assertEquals(newSlot.size(), 112);    assertEquals(newSlot.get("/path1").intValue(), 1);    assertEquals(newSlot.get("/path1/path2/path3").intValue(), 1111001);        newSlot = requestPathMetricsCollector.aggregatePaths(4, queue -> true);    assertEquals(newSlot.size(), 1112);    assertEquals(newSlot.get("/path1/path2/path3/path4").intValue(), 1110001);        newSlot = requestPathMetricsCollector.aggregatePaths(5, queue -> true);    assertEquals(newSlot.size(), 11112);    assertEquals(newSlot.get("/path1/path2/path3/path4/path5").intValue(), 1100001);        newSlot = requestPathMetricsCollector.aggregatePaths(6, queue -> true);    assertEquals(newSlot.size(), 111112);    assertEquals(newSlot.get("/path1/path2/path3/path4/path5/path6").intValue(), 1000001);        newSlot = requestPathMetricsCollector.aggregatePaths(7, queue -> true);    assertEquals(newSlot.size(), 111112);    assertEquals(newSlot.get("/path1/path2/path3/path4/path5/path6").intValue(), 1000001);            newSlot = requestPathMetricsCollector.aggregatePaths(4, queue -> !queue.isWriteOperation());    assertEquals(newSlot.size(), 1);    assertEquals(newSlot.get("/path1/path2/path3/path4").intValue(), 1110001);        newSlot = requestPathMetricsCollector.aggregatePaths(4, queue -> queue.isWriteOperation());    assertEquals(newSlot.size(), 1111);        newSlot = requestPathMetricsCollector.aggregatePaths(3, queue -> queue.isWriteOperation());    assertEquals(newSlot.size(), 112);    assertEquals(newSlot.get("/path1/path2/path3").intValue(), 1000);}
testTopPath
public void zookeeper_f5624_0() throws InterruptedException
{    RequestPathMetricsCollector requestPathMetricsCollector = new RequestPathMetricsCollector(true);    Thread path7 = new Thread(() -> {        for (int i = 0; i < 10; i++) {            try {                Thread.sleep(100);            } catch (InterruptedException e) {                e.printStackTrace();            }            for (int j = 0; j < 100000; j++) {                requestPathMetricsCollector.registerRequest(getData, "/path1/path2/path3/path4/path5/path6/path7" + "_" + i + "_" + j);            }        }    });    path7.start();    Thread path6 = new Thread(() -> {        requestPathMetricsCollector.registerRequest(getChildren2, "/path1/path2/path3/path4/path5/path6");        for (int i = 0; i < 10; i++) {            try {                Thread.sleep(1000);            } catch (InterruptedException e) {                e.printStackTrace();            }            for (int j = 0; j < 10000; j++) {                requestPathMetricsCollector.registerRequest(getChildren, "/path1/path2/path3/path4/path5/path6" + "_" + i + "_" + j);            }        }    });    path6.start();    for (int i = 0; i < 1; i++) {        requestPathMetricsCollector.registerRequest(create2, "/path1");    }    for (int i = 0; i < 10; i++) {        requestPathMetricsCollector.registerRequest(create, "/path1/path2" + "_" + i);    }    for (int i = 0; i < 100; i++) {        requestPathMetricsCollector.registerRequest(delete, "/path1/path2/path3" + "_" + i);    }    for (int i = 0; i < 1000; i++) {        requestPathMetricsCollector.registerRequest(setData, "/path1/path2/path3/path4" + "_" + i);    }    for (int i = 0; i < 10000; i++) {        requestPathMetricsCollector.registerRequest(exists, "/path1/path2/path3/path4/path5" + "_" + i);    }    path6.join();    path7.join();    StringBuilder sb1 = new StringBuilder();    Map<String, Integer> newSlot = requestPathMetricsCollector.aggregatePaths(3, queue -> queue.isWriteOperation());    requestPathMetricsCollector.logTopPaths(newSlot, entry -> sb1.append(entry.getKey() + " : " + entry.getValue() + "\n"));    assertTrue(sb1.toString().startsWith("/path1/path2/path3 : 1000"));    StringBuilder sb2 = new StringBuilder();    newSlot = requestPathMetricsCollector.aggregatePaths(3, queue -> !queue.isWriteOperation());    requestPathMetricsCollector.logTopPaths(newSlot, entry -> sb2.append(entry.getKey() + " : " + entry.getValue() + "\n"));    assertTrue(sb2.toString().startsWith("/path1/path2/path3 : 1110001"));    StringBuilder sb3 = new StringBuilder();    newSlot = requestPathMetricsCollector.aggregatePaths(4, queue -> true);    requestPathMetricsCollector.logTopPaths(newSlot, entry -> sb3.append(entry.getKey() + " : " + entry.getValue() + "\n"));    assertTrue(sb3.toString().startsWith("/path1/path2/path3/path4 : 1110001"));}
testMultiThreadPerf
public void zookeeper_f5625_0() throws InterruptedException
{    RequestPathMetricsCollector requestPathMetricsCollector = new RequestPathMetricsCollector();    Random rand = new Random(System.currentTimeMillis());    Long startTime = System.currentTimeMillis();    ThreadPoolExecutor executor = (ThreadPoolExecutor) Executors.newCachedThreadPool();        for (int i = 0; i < 100000; i++) {        executor.submit(new Thread(() -> requestPathMetricsCollector.registerRequest(getData, "/path1/path2/path" + rand.nextInt(10))));    }        for (int i = 0; i < 5000; i++) {        executor.submit(new Thread(() -> requestPathMetricsCollector.registerRequest(create2, "/path1/path2/path" + rand.nextInt(10))));    }        for (int i = 0; i < 5000; i++) {        executor.submit(new Thread(() -> requestPathMetricsCollector.registerRequest(delete, "/path1/path2/path" + rand.nextInt(10))));    }        for (int i = 0; i < 40000; i++) {        executor.submit(new Thread(() -> requestPathMetricsCollector.registerRequest(getChildren, "/path1/path2/path" + rand.nextInt(10))));    }    executor.shutdown();        executor.awaitTermination(10, TimeUnit.MILLISECONDS);    assertTrue(executor.isTerminated());    Long endTime = System.currentTimeMillis();        assertTrue(TimeUnit.MILLISECONDS.toSeconds(endTime - startTime) < 3);}
testSerializeRequestRequestIsNull
public void zookeeper_f5626_0()
{    byte[] data = SerializeUtils.serializeRequest(null);    assertNull(data);}
testSerializeRequestRequestHeaderIsNull
public void zookeeper_f5627_0()
{    Request request = new Request(0, 0, 0, null, null, 0);    byte[] data = SerializeUtils.serializeRequest(request);    assertNull(data);}
testSerializeRequestWithoutTxn
public void zookeeper_f5628_0() throws IOException
{        TxnHeader header = mock(TxnHeader.class);    doAnswer(new Answer() {        @Override        public Object answer(InvocationOnMock invocation) throws Throwable {            Object[] args = invocation.getArguments();            OutputArchive oa = (OutputArchive) args[0];            oa.writeString("header", "test");            return null;        }    }).when(header).serialize(any(OutputArchive.class), anyString());    Request request = new Request(1, 2, 3, header, null, 4);        byte[] data = SerializeUtils.serializeRequest(request);        assertNotNull(data);    verify(header).serialize(any(OutputArchive.class), eq("hdr"));    ByteArrayOutputStream baos = new ByteArrayOutputStream();    BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos);    boa.writeString("header", "test");    baos.close();    assertArrayEquals(baos.toByteArray(), data);}
answer
public Object zookeeper_f5629_0(InvocationOnMock invocation) throws Throwable
{    Object[] args = invocation.getArguments();    OutputArchive oa = (OutputArchive) args[0];    oa.writeString("header", "test");    return null;}
testSerializeRequestWithTxn
public void zookeeper_f5630_0() throws IOException
{        TxnHeader header = mock(TxnHeader.class);    doAnswer(new Answer() {        @Override        public Object answer(InvocationOnMock invocation) throws Throwable {            Object[] args = invocation.getArguments();            OutputArchive oa = (OutputArchive) args[0];            oa.writeString("header", "test");            return null;        }    }).when(header).serialize(any(OutputArchive.class), anyString());    Record txn = mock(Record.class);    doAnswer(new Answer() {        @Override        public Object answer(InvocationOnMock invocation) throws Throwable {            Object[] args = invocation.getArguments();            OutputArchive oa = (OutputArchive) args[0];            oa.writeString("record", "test");            return null;        }    }).when(txn).serialize(any(OutputArchive.class), anyString());    Request request = new Request(1, 2, 3, header, txn, 4);        byte[] data = SerializeUtils.serializeRequest(request);        assertNotNull(data);    InOrder inOrder = inOrder(header, txn);    inOrder.verify(header).serialize(any(OutputArchive.class), eq("hdr"));    inOrder.verify(txn).serialize(any(OutputArchive.class), eq("txn"));    ByteArrayOutputStream baos = new ByteArrayOutputStream();    BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos);    boa.writeString("header", "test");    boa.writeString("record", "test");    baos.close();    assertArrayEquals(baos.toByteArray(), data);}
answer
public Object zookeeper_f5631_0(InvocationOnMock invocation) throws Throwable
{    Object[] args = invocation.getArguments();    OutputArchive oa = (OutputArchive) args[0];    oa.writeString("header", "test");    return null;}
answer
public Object zookeeper_f5632_0(InvocationOnMock invocation) throws Throwable
{    Object[] args = invocation.getArguments();    OutputArchive oa = (OutputArchive) args[0];    oa.writeString("record", "test");    return null;}
setUp
public void zookeeper_f5633_0()
{    log = LoggerFactory.getLogger("TODO: Mock Logging");}
testForWarningOnRelativePath
public void zookeeper_f5634_0()
{    VerifyingFileFactory vff = new VerifyingFileFactory.Builder(log).warnForRelativePath().build();    vff.create("a/relative/path");}
testForNoWarningOnIntendedRelativePath
public void zookeeper_f5635_0()
{    VerifyingFileFactory vff = new VerifyingFileFactory.Builder(log).warnForRelativePath().build();    vff.create("./an/intended/relative/path");}
testForFailForNonExistingPath
public void zookeeper_f5636_0()
{    VerifyingFileFactory vff = new VerifyingFileFactory.Builder(log).failForNonExistingPath().build();    vff.create("/I/H0p3/this/path/d035/n0t/ex15t");}
testFileHasCorrectPath
public void zookeeper_f5637_0()
{    File file = new File("/some/path");    VerifyingFileFactory vff = new VerifyingFileFactory.Builder(log).build();    assertEquals(file, vff.create(file.getPath()));}
setCountDownLatch
public void zookeeper_f5638_0(CountDownLatch latch)
{    this.latch = latch;}
setDelayMs
public void zookeeper_f5639_0(int delayMs)
{    this.delayMs = delayMs;}
processDeadWatchers
public void zookeeper_f5640_0(Set<Integer> deadWatchers)
{    if (delayMs > 0) {        try {            Thread.sleep(delayMs);        } catch (InterruptedException e) {        }    }    this.deadWatchers.clear();    this.deadWatchers.addAll(deadWatchers);    latch.countDown();}
getDeadWatchers
public Set<Integer> zookeeper_f5641_0()
{    return deadWatchers;}
wait
public boolean zookeeper_f5642_0(int maxWaitMs)
{    try {        return latch.await(maxWaitMs, TimeUnit.MILLISECONDS);    } catch (InterruptedException e) {    }    return false;}
testProcessDeadWatchersBasedOnThreshold
public void zookeeper_f5643_0()
{    MyDeadWatcherListener listener = new MyDeadWatcherListener();    int threshold = 3;    WatcherCleaner cleaner = new WatcherCleaner(listener, threshold, 60, 1, 10);    cleaner.start();    int i = 0;    while (i++ < threshold - 1) {        cleaner.addDeadWatcher(i);    }        assertEquals(0, listener.getDeadWatchers().size());    listener.setCountDownLatch(new CountDownLatch(1));        cleaner.addDeadWatcher(i);    assertTrue(listener.wait(1000));    assertEquals(threshold, listener.getDeadWatchers().size());}
testProcessDeadWatchersBasedOnTime
public void zookeeper_f5644_0()
{    MyDeadWatcherListener listener = new MyDeadWatcherListener();    WatcherCleaner cleaner = new WatcherCleaner(listener, 10, 1, 1, 10);    cleaner.start();    cleaner.addDeadWatcher(1);        assertEquals(0, listener.getDeadWatchers().size());    listener.setCountDownLatch(new CountDownLatch(1));    assertTrue(listener.wait(2000));    assertEquals(1, listener.getDeadWatchers().size());        listener.setCountDownLatch(new CountDownLatch(1));    assertFalse(listener.wait(2000));}
testMaxInProcessingDeadWatchers
public void zookeeper_f5645_0()
{    MyDeadWatcherListener listener = new MyDeadWatcherListener();    int delayMs = 1000;    listener.setDelayMs(delayMs);    WatcherCleaner cleaner = new WatcherCleaner(listener, 1, 60, 1, 1);    cleaner.start();    listener.setCountDownLatch(new CountDownLatch(2));    long startTime = Time.currentElapsedTime();    cleaner.addDeadWatcher(1);    cleaner.addDeadWatcher(2);    long time = Time.currentElapsedTime() - startTime;    System.out.println("time used " + time);    assertTrue(Time.currentElapsedTime() - startTime >= delayMs);    assertTrue(listener.wait(5000));}
testDeadWatcherMetrics
public void zookeeper_f5646_0()
{    ServerMetrics.getMetrics().resetAll();    MyDeadWatcherListener listener = new MyDeadWatcherListener();    WatcherCleaner cleaner = new WatcherCleaner(listener, 1, 1, 1, 1);    listener.setDelayMs(20);    cleaner.start();    listener.setCountDownLatch(new CountDownLatch(3));            cleaner.addDeadWatcher(1);    cleaner.addDeadWatcher(2);    cleaner.addDeadWatcher(3);    assertTrue(listener.wait(5000));    Map<String, Object> values = MetricsUtils.currentServerMetrics();    assertThat("Adding dead watcher should be stalled twice", (Long) values.get("add_dead_watcher_stall_time"), greaterThan(0L));    assertEquals("Total dead watchers added to the queue should be 3", 3L, values.get("dead_watchers_queued"));    assertEquals("Total dead watchers cleared should be 3", 3L, values.get("dead_watchers_cleared"));    assertEquals(3L, values.get("cnt_dead_watchers_cleaner_latency"));        assertEquals(20D, (Double) values.get("avg_dead_watchers_cleaner_latency"), 5);    assertEquals(20D, ((Long) values.get("min_dead_watchers_cleaner_latency")).doubleValue(), 5);    assertEquals(20D, ((Long) values.get("max_dead_watchers_cleaner_latency")).doubleValue(), 5);    assertEquals(20D, ((Long) values.get("p50_dead_watchers_cleaner_latency")).doubleValue(), 5);    assertEquals(20D, ((Long) values.get("p95_dead_watchers_cleaner_latency")).doubleValue(), 5);    assertEquals(20D, ((Long) values.get("p99_dead_watchers_cleaner_latency")).doubleValue(), 5);}
testWatcherSet
public void zookeeper_f5647_0()
{    Set<Watcher> wset = new HashSet<Watcher>();    WatcherOrBitSet hashSet = new WatcherOrBitSet(wset);    assertEquals(0, hashSet.size());    DumbWatcher w1 = new DumbWatcher();    assertFalse(hashSet.contains(w1));    wset.add(w1);    assertTrue(hashSet.contains(w1));    assertEquals(1, hashSet.size());    assertFalse(hashSet.contains(1));}
testBitSet
public void zookeeper_f5648_0()
{    BitHashSet bset = new BitHashSet(0);    WatcherOrBitSet bitSet = new WatcherOrBitSet(bset);    assertEquals(0, bitSet.size());    Integer bit = 1;    assertFalse(bitSet.contains(1));    assertFalse(bitSet.contains(bit));    bset.add(bit);    assertTrue(bitSet.contains(1));    assertTrue(bitSet.contains(bit));    assertEquals(1, bitSet.size());}
setUp
public void zookeeper_f5649_0()
{    m = new HashMap<String, Set<Long>>();    Set<Long> s = new HashSet<Long>();    s.add(101L);    s.add(102L);    m.put("path1", s);    s = new HashSet<Long>();    s.add(201L);    m.put("path2", s);    r = new WatchesPathReport(m);}
testHasSessions
public void zookeeper_f5650_0()
{    assertTrue(r.hasSessions("path1"));    assertTrue(r.hasSessions("path2"));    assertFalse(r.hasSessions("path3"));}
testGetSessions
public void zookeeper_f5651_0()
{    Set<Long> s = r.getSessions("path1");    assertEquals(2, s.size());    assertTrue(s.contains(101L));    assertTrue(s.contains(102L));    s = r.getSessions("path2");    assertEquals(1, s.size());    assertTrue(s.contains(201L));    assertNull(r.getSessions("path3"));}
testToMap
public void zookeeper_f5652_0()
{    assertEquals(m, r.toMap());}
setUp
public void zookeeper_f5653_0()
{    m = new HashMap<Long, Set<String>>();    Set<String> s = new HashSet<String>();    s.add("path1a");    s.add("path1b");    m.put(1L, s);    s = new HashSet<String>();    s.add("path2a");    m.put(2L, s);    r = new WatchesReport(m);}
testHasPaths
public void zookeeper_f5654_0()
{    assertTrue(r.hasPaths(1L));    assertTrue(r.hasPaths(2L));    assertFalse(r.hasPaths(3L));}
testGetPaths
public void zookeeper_f5655_0()
{    Set<String> s = r.getPaths(1L);    assertEquals(2, s.size());    assertTrue(s.contains("path1a"));    assertTrue(s.contains("path1b"));    s = r.getPaths(2L);    assertEquals(1, s.size());    assertTrue(s.contains("path2a"));    assertNull(r.getPaths(3L));}
testToMap
public void zookeeper_f5656_0()
{    assertEquals(m, r.toMap());}
setUp
public void zookeeper_f5657_0()
{    s = new WatchesSummary(1, 2, 3);}
testGetters
public void zookeeper_f5658_0()
{    assertEquals(1, s.getNumConnections());    assertEquals(2, s.getNumPaths());    assertEquals(3, s.getTotalWatches());}
testToMap
public void zookeeper_f5659_0()
{    Map<String, Object> m = s.toMap();    assertEquals(3, m.size());    assertEquals(Integer.valueOf(1), m.get(WatchesSummary.KEY_NUM_CONNECTIONS));    assertEquals(Integer.valueOf(2), m.get(WatchesSummary.KEY_NUM_PATHS));    assertEquals(Integer.valueOf(3), m.get(WatchesSummary.KEY_NUM_TOTAL_WATCHES));}
data
public static List<Object[]> zookeeper_f5660_0()
{    return Arrays.asList(new Object[][] { { WatchManager.class.getName() }, { WatchManagerOptimized.class.getName() } });}
setUp
public void zookeeper_f5661_0()
{    ServerMetrics.getMetrics().resetAll();    watchers = new ConcurrentHashMap<Integer, DumbWatcher>();    r = new Random(System.nanoTime());}
getWatchManager
public IWatchManager zookeeper_f5662_0() throws IOException
{    System.setProperty(WatchManagerFactory.ZOOKEEPER_WATCH_MANAGER_NAME, className);    return WatchManagerFactory.createWatchManager();}
createOrGetWatcher
public DumbWatcher zookeeper_f5663_0(int watcherId)
{    if (!watchers.containsKey(watcherId)) {        DumbWatcher watcher = new DumbWatcher(watcherId);        watchers.putIfAbsent(watcherId, watcher);    }    return watchers.get(watcherId);}
run
public void zookeeper_f5664_0()
{    while (!stopped) {        String path = PATH_PREFIX + r.nextInt(paths);        Watcher watcher = createOrGetWatcher(r.nextInt(watchers));        if (manager.addWatch(path, watcher)) {            watchesAdded.addAndGet(1);        }    }}
shutdown
public void zookeeper_f5665_0()
{    stopped = true;}
run
public void zookeeper_f5666_0()
{    while (!stopped) {        String path = PATH_PREFIX + r.nextInt(paths);        WatcherOrBitSet s = manager.triggerWatch(path, EventType.NodeDeleted);        if (s != null) {            triggeredCount.addAndGet(s.size());        }        try {            Thread.sleep(r.nextInt(10));        } catch (InterruptedException e) {        }    }}
shutdown
public void zookeeper_f5667_0()
{    stopped = true;}
run
public void zookeeper_f5668_0()
{    while (!stopped) {        String path = PATH_PREFIX + r.nextInt(paths);        Watcher watcher = createOrGetWatcher(r.nextInt(watchers));        if (manager.removeWatcher(path, watcher)) {            watchesRemoved.addAndGet(1);        }        try {            Thread.sleep(r.nextInt(10));        } catch (InterruptedException e) {        }    }}
shutdown
public void zookeeper_f5669_0()
{    stopped = true;}
run
public void zookeeper_f5670_0()
{    while (!stopped) {        DumbWatcher watcher = createOrGetWatcher(r.nextInt(watchers));        watcher.setStale();        manager.removeWatcher(watcher);        synchronized (removedWatchers) {            removedWatchers.add(watcher);        }        try {            Thread.sleep(r.nextInt(10));        } catch (InterruptedException e) {        }    }}
shutdown
public void zookeeper_f5671_0()
{    stopped = true;}
testAddAndTriggerWatcher
public void zookeeper_f5672_0() throws IOException
{    IWatchManager manager = getWatchManager();    int paths = 1;    int watchers = 10000;            AtomicInteger watchTriggered = new AtomicInteger();    List<WatcherTriggerWorker> triggerWorkers = new ArrayList<WatcherTriggerWorker>();    for (int i = 0; i < 5; i++) {        WatcherTriggerWorker worker = new WatcherTriggerWorker(manager, paths, watchTriggered);        triggerWorkers.add(worker);        worker.start();    }            AtomicInteger watchesAdded = new AtomicInteger();    List<AddWatcherWorker> addWorkers = new ArrayList<AddWatcherWorker>();    for (int i = 0; i < 5; i++) {        AddWatcherWorker worker = new AddWatcherWorker(manager, paths, watchers, watchesAdded);        addWorkers.add(worker);        worker.start();    }    while (watchesAdded.get() < 100000) {        try {            Thread.sleep(100);        } catch (InterruptedException e) {        }    }        for (AddWatcherWorker worker : addWorkers) {        worker.shutdown();    }        try {        Thread.sleep(500);    } catch (InterruptedException e) {    }        for (WatcherTriggerWorker worker : triggerWorkers) {        worker.shutdown();    }        assertTrue(watchesAdded.get() > 0);    assertEquals(watchesAdded.get(), watchTriggered.get());}
testRemoveWatcherOnPath
public void zookeeper_f5673_0() throws IOException
{    IWatchManager manager = getWatchManager();    int paths = 10;    int watchers = 10000;            AtomicInteger watchesRemoved = new AtomicInteger();    List<RemoveWatcherWorker> removeWorkers = new ArrayList<RemoveWatcherWorker>();    for (int i = 0; i < 5; i++) {        RemoveWatcherWorker worker = new RemoveWatcherWorker(manager, paths, watchers, watchesRemoved);        removeWorkers.add(worker);        worker.start();    }            AtomicInteger watchesAdded = new AtomicInteger();    List<AddWatcherWorker> addWorkers = new ArrayList<AddWatcherWorker>();    for (int i = 0; i < 5; i++) {        AddWatcherWorker worker = new AddWatcherWorker(manager, paths, watchers, watchesAdded);        addWorkers.add(worker);        worker.start();    }    while (watchesAdded.get() < 100000) {        try {            Thread.sleep(100);        } catch (InterruptedException e) {        }    }        for (RemoveWatcherWorker worker : removeWorkers) {        worker.shutdown();    }    for (AddWatcherWorker worker : addWorkers) {        worker.shutdown();    }        try {        Thread.sleep(500);    } catch (InterruptedException e) {    }        assertTrue(watchesAdded.get() > 0);    assertTrue(watchesRemoved.get() > 0);    assertTrue(manager.size() > 0);    assertEquals(watchesAdded.get(), watchesRemoved.get() + manager.size());}
testDeadWatchers
public void zookeeper_f5674_0() throws IOException
{    System.setProperty("zookeeper.watcherCleanThreshold", "10");    System.setProperty("zookeeper.watcherCleanIntervalInSeconds", "1");    IWatchManager manager = getWatchManager();    int paths = 1;    int watchers = 100000;            Set<Watcher> deadWatchers = new HashSet<Watcher>();    List<CreateDeadWatchersWorker> deadWorkers = new ArrayList<CreateDeadWatchersWorker>();    for (int i = 0; i < 5; i++) {        CreateDeadWatchersWorker worker = new CreateDeadWatchersWorker(manager, watchers, deadWatchers);        deadWorkers.add(worker);        worker.start();    }        AtomicInteger watchesAdded = new AtomicInteger();    List<AddWatcherWorker> addWorkers = new ArrayList<AddWatcherWorker>();    for (int i = 0; i < 5; i++) {        AddWatcherWorker worker = new AddWatcherWorker(manager, paths, watchers, watchesAdded);        addWorkers.add(worker);        worker.start();    }    while (watchesAdded.get() < 50000) {        try {            Thread.sleep(100);        } catch (InterruptedException e) {        }    }        for (CreateDeadWatchersWorker worker : deadWorkers) {        worker.shutdown();    }    for (AddWatcherWorker worker : addWorkers) {        worker.shutdown();    }        try {        Thread.sleep(2000);    } catch (InterruptedException e) {    }        WatchesReport existingWatchers = manager.getWatches();    for (Watcher w : deadWatchers) {        assertFalse(existingWatchers.hasPaths(((ServerCnxn) w).getSessionId()));    }}
checkMetrics
private void zookeeper_f5675_0(String metricName, long min, long max, double avg, long cnt, long sum)
{    Map<String, Object> values = MetricsUtils.currentServerMetrics();    assertEquals(min, values.get("min_" + metricName));    assertEquals(max, values.get("max_" + metricName));    assertEquals(avg, (Double) values.get("avg_" + metricName), 0.000001);    assertEquals(cnt, values.get("cnt_" + metricName));    assertEquals(sum, values.get("sum_" + metricName));}
testWatcherMetrics
public void zookeeper_f5676_0() throws IOException
{    IWatchManager manager = getWatchManager();    ServerMetrics.getMetrics().resetAll();    DumbWatcher watcher1 = new DumbWatcher(1);    DumbWatcher watcher2 = new DumbWatcher(2);    final String path1 = "/path1";    final String path2 = "/path2";    final String path3 = "/path3";        manager.addWatch(path1, watcher1);    manager.addWatch(path1, watcher2);        manager.addWatch(path2, watcher1);    manager.triggerWatch(path3, EventType.NodeCreated);        checkMetrics("node_created_watch_count", 0L, 0L, 0D, 0L, 0L);        manager.triggerWatch(path1, EventType.NodeCreated);    checkMetrics("node_created_watch_count", 2L, 2L, 2D, 1L, 2L);        manager.triggerWatch(path2, EventType.NodeCreated);    checkMetrics("node_created_watch_count", 1L, 2L, 1.5D, 2L, 3L);        manager.triggerWatch(path1, EventType.NodeDataChanged);    checkMetrics("node_changed_watch_count", 0L, 0L, 0D, 0L, 0L);        manager.addWatch(path1, watcher1);    manager.addWatch(path1, watcher2);        manager.addWatch(path2, watcher1);    manager.triggerWatch(path1, EventType.NodeDataChanged);    checkMetrics("node_changed_watch_count", 2L, 2L, 2D, 1L, 2L);    manager.triggerWatch(path2, EventType.NodeDeleted);    checkMetrics("node_deleted_watch_count", 1L, 1L, 1D, 1L, 1L);        checkMetrics("node_created_watch_count", 1L, 2L, 1.5D, 2L, 3L);}
processRequest
public void zookeeper_f5677_0(Request request) throws RequestProcessorException
{        throw new RequestProcessorException("test", new Exception());}
shutdown
public void zookeeper_f5678_0()
{}
run
public void zookeeper_f5679_0()
{    super.run();    processed.countDown();}
testUnrecoverableErrorCountFromRequestProcessor
public void zookeeper_f5680_0() throws Exception
{    ServerMetrics.getMetrics().resetAll();    processed = new CountDownLatch(1);    PrepRequestProcessor processor = new MyPrepRequestProcessor();    processor.start();    processor.processRequest(new Request(null, 1L, 1, ZooDefs.OpCode.setData, ByteBuffer.wrap(new byte[10]), null));    processed.await();    processor.shutdown();    Map<String, Object> values = MetricsUtils.currentServerMetrics();    assertEquals(1L, values.get("unrecoverable_error_count"));}
testUnrecoverableErrorCount
public void zookeeper_f5681_0()
{    ServerMetrics.getMetrics().resetAll();    ZooKeeperServer zks = new ZooKeeperServer();    ZooKeeperCriticalThread thread = new ZooKeeperCriticalThread("test", zks.getZooKeeperServerListener());    thread.handleException("test", new Exception());    Map<String, Object> values = MetricsUtils.currentServerMetrics();    assertEquals(1L, values.get("unrecoverable_error_count"));}
setup
public void zookeeper_f5682_0()
{    System.setProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY, "org.apache.zookeeper.server.NettyServerCnxnFactory");}
teardown
public void zookeeper_f5683_0() throws Exception
{    System.clearProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY);}
testTxnLogElapsedSyncTime
public void zookeeper_f5684_0() throws IOException
{    File tmpDir = ClientBase.createEmptyTestDir();    FileTxnSnapLog fileTxnSnapLog = new FileTxnSnapLog(new File(tmpDir, "data"), new File(tmpDir, "data_txnlog"));    ZooKeeperServer zks = new ZooKeeperServer();    zks.setTxnLogFactory(fileTxnSnapLog);    ZooKeeperServerBean serverBean = new ZooKeeperServerBean(zks);    long elapsedTime = serverBean.getTxnLogElapsedSyncTime();    assertEquals(-1, elapsedTime);    TxnHeader hdr = new TxnHeader(1, 1, 1, 1, ZooDefs.OpCode.setData);    Record txn = new SetDataTxn("/foo", new byte[0], 1);    Request req = new Request(0, 0, 0, hdr, txn, 0);    try {        zks.getTxnLogFactory().append(req);        zks.getTxnLogFactory().commit();        elapsedTime = serverBean.getTxnLogElapsedSyncTime();        assertNotEquals(-1, elapsedTime);        assertEquals(elapsedTime, serverBean.getTxnLogElapsedSyncTime());    } finally {        fileTxnSnapLog.close();    }}
testGetSecureClientPort
public void zookeeper_f5685_0() throws IOException
{    ZooKeeperServer zks = new ZooKeeperServer();    /**     * case 1: When secure client is not configured GetSecureClientPort     * should return empty string     */    ZooKeeperServerBean serverBean = new ZooKeeperServerBean(zks);    String result = serverBean.getSecureClientPort();    assertEquals("", result);    /**     * case 2: When secure client is configured GetSecureClientPort should     * return configured port     */    ServerCnxnFactory cnxnFactory = ServerCnxnFactory.createFactory();    int secureClientPort = 8443;    InetSocketAddress address = new InetSocketAddress(secureClientPort);    cnxnFactory.configure(address, 5, -1, true);    zks.setSecureServerCnxnFactory(cnxnFactory);    result = serverBean.getSecureClientPort();    assertEquals(Integer.toString(secureClientPort), result);        cnxnFactory.shutdown();}
testGetSecureClientAddress
public void zookeeper_f5686_0() throws IOException
{    ZooKeeperServer zks = new ZooKeeperServer();    /**     * case 1: When secure client is not configured getSecureClientAddress     * should return empty string     */    ZooKeeperServerBean serverBean = new ZooKeeperServerBean(zks);    String result = serverBean.getSecureClientPort();    assertEquals("", result);    /**     * case 2: When secure client is configured getSecureClientAddress     * should return configured SecureClientAddress     */    ServerCnxnFactory cnxnFactory = ServerCnxnFactory.createFactory();    int secureClientPort = 8443;    InetSocketAddress address = new InetSocketAddress(secureClientPort);    cnxnFactory.configure(address, 5, -1, true);    zks.setSecureServerCnxnFactory(cnxnFactory);    result = serverBean.getSecureClientAddress();    String ipv4 = "0.0.0.0:" + secureClientPort;    String ipv6 = "0:0:0:0:0:0:0:0:" + secureClientPort;    assertTrue(result.equals(ipv4) || result.equals(ipv6));        cnxnFactory.shutdown();}
setUp
public void zookeeper_f5687_0()
{    c = new ZooKeeperServerConf(1, "a", "b", 2, 3, 4, 5, 6L, 7);}
testGetters
public void zookeeper_f5688_0()
{    assertEquals(1, c.getClientPort());    assertEquals("a", c.getDataDir());    assertEquals("b", c.getDataLogDir());    assertEquals(2, c.getTickTime());    assertEquals(3, c.getMaxClientCnxnsPerHost());    assertEquals(4, c.getMinSessionTimeout());    assertEquals(5, c.getMaxSessionTimeout());    assertEquals(6L, c.getServerId());    assertEquals(7, c.getClientPortListenBacklog());}
testToMap
public void zookeeper_f5689_0()
{    Map<String, Object> m = c.toMap();    assertEquals(9, m.size());    assertEquals(Integer.valueOf(1), m.get(ZooKeeperServerConf.KEY_CLIENT_PORT));    assertEquals("a", m.get(ZooKeeperServerConf.KEY_DATA_DIR));    assertEquals("b", m.get(ZooKeeperServerConf.KEY_DATA_LOG_DIR));    assertEquals(Integer.valueOf(2), m.get(ZooKeeperServerConf.KEY_TICK_TIME));    assertEquals(Integer.valueOf(3), m.get(ZooKeeperServerConf.KEY_MAX_CLIENT_CNXNS));    assertEquals(Integer.valueOf(4), m.get(ZooKeeperServerConf.KEY_MIN_SESSION_TIMEOUT));    assertEquals(Integer.valueOf(5), m.get(ZooKeeperServerConf.KEY_MAX_SESSION_TIMEOUT));    assertEquals(Long.valueOf(6L), m.get(ZooKeeperServerConf.KEY_SERVER_ID));    assertEquals(Integer.valueOf(7), m.get(ZooKeeperServerConf.KEY_CLIENT_PORT_LISTEN_BACKLOG));}
run
public voidf5690_1)
{    String[] args = new String[1];    args[0] = confFile.toString();    try {        main.initializeAndRun(args);    } catch (Exception e) {                    }}
shutdown
public void zookeeper_f5691_0() throws IOException
{    main.shutdown();}
deleteDirs
 void zookeeper_f5692_0() throws IOException
{    delete(tmpDir);}
delete
 void zookeeper_f5693_0(File f) throws IOException
{    if (f.isDirectory()) {        for (File c : f.listFiles()) {            delete(c);        }    }    if (!f.delete()) {                if (f.exists()) {            throw new IOException("Failed to delete file: " + f);        }    }}
getCnxnFactory
 ServerCnxnFactory zookeeper_f5694_0()
{    return main.getCnxnFactory();}
shutdown
public void zookeeper_f5695_0()
{    super.shutdown();}
testNonRecoverableError
public void zookeeper_f5696_0() throws Exception
{    ClientBase.setupTestEnv();    final int CLIENT_PORT = PortAssignment.unique();    MainThread main = new MainThread(CLIENT_PORT, true, null);    main.start();    assertTrue("waiting for server being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT, CONNECTION_TIMEOUT));    ZooKeeper zk = new ZooKeeper("127.0.0.1:" + CLIENT_PORT, ClientBase.CONNECTION_TIMEOUT, this);    zk.create("/foo1", "foobar".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    assertEquals(new String(zk.getData("/foo1", null, null)), "foobar");        ZooKeeperServer zooKeeperServer = main.getCnxnFactory().getZooKeeperServer();    FileTxnSnapLog snapLog = zooKeeperServer.getTxnLogFactory();    FileTxnSnapLog fileTxnSnapLogWithError = new FileTxnSnapLog(snapLog.getDataDir(), snapLog.getSnapDir()) {        @Override        public void commit() throws IOException {            throw new IOException("Input/output error");        }    };    ZKDatabase newDB = new ZKDatabase(fileTxnSnapLogWithError);    zooKeeperServer.setZKDatabase(newDB);    try {                zk.create("/foo2", "foobar".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        fail("IOException is expected as error is injected in transaction log commit funtionality");    } catch (Exception e) {        }    zk.close();    assertTrue("waiting for server down", ClientBase.waitForServerDown("127.0.0.1:" + CLIENT_PORT, ClientBase.CONNECTION_TIMEOUT));    fileTxnSnapLogWithError.close();    main.shutdown();    main.deleteDirs();}
commit
public void zookeeper_f5697_0() throws IOException
{    throw new IOException("Input/output error");}
testReadOnlySnapshotDir
public void zookeeper_f5698_0() throws Exception
{    ClientBase.setupTestEnv();    final int CLIENT_PORT = PortAssignment.unique();            MainThread main = new MainThread(CLIENT_PORT, true, null);    File tmpDir = main.tmpDir;    main.start();    assertTrue("waiting for server being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT, CONNECTION_TIMEOUT / 2));    main.shutdown();        File snapDir = new File(main.dataDir, FileTxnSnapLog.version + FileTxnSnapLog.VERSION);    snapDir.setWritable(false);        main = new MainThread(CLIENT_PORT, false, tmpDir, null);    main.start();    assertFalse("waiting for server being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT, CONNECTION_TIMEOUT / 2));    main.shutdown();    snapDir.setWritable(true);    main.deleteDirs();}
testReadOnlyTxnLogDir
public void zookeeper_f5699_0() throws Exception
{    ClientBase.setupTestEnv();    final int CLIENT_PORT = PortAssignment.unique();            MainThread main = new MainThread(CLIENT_PORT, true, null);    File tmpDir = main.tmpDir;    main.start();    assertTrue("waiting for server being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT, CONNECTION_TIMEOUT / 2));    main.shutdown();        File logDir = new File(main.logDir, FileTxnSnapLog.version + FileTxnSnapLog.VERSION);    logDir.setWritable(false);        main = new MainThread(CLIENT_PORT, false, tmpDir, null);    main.start();    assertFalse("waiting for server being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT, CONNECTION_TIMEOUT / 2));    main.shutdown();    logDir.setWritable(true);    main.deleteDirs();}
testStandalone
public void zookeeper_f5700_0() throws Exception
{    ClientBase.setupTestEnv();    final int CLIENT_PORT = PortAssignment.unique();    MainThread main = new MainThread(CLIENT_PORT, true, null);    main.start();    assertTrue("waiting for server being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT, CONNECTION_TIMEOUT));    clientConnected = new CountDownLatch(1);    ZooKeeper zk = new ZooKeeper("127.0.0.1:" + CLIENT_PORT, ClientBase.CONNECTION_TIMEOUT, this);    assertTrue("Failed to establish zkclient connection!", clientConnected.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS));    zk.create("/foo", "foobar".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    assertEquals(new String(zk.getData("/foo", null, null)), "foobar");    zk.close();    main.shutdown();    main.join();    main.deleteDirs();    assertTrue("waiting for server down", ClientBase.waitForServerDown("127.0.0.1:" + CLIENT_PORT, ClientBase.CONNECTION_TIMEOUT));}
testWithMinSessionTimeoutGreaterThanMaxSessionTimeout
public void zookeeper_f5701_0() throws Exception
{    ClientBase.setupTestEnv();    final int CLIENT_PORT = PortAssignment.unique();    final int tickTime = 2000;        final int minSessionTimeout = 20 * tickTime + 1000;        final int maxSessionTimeout = tickTime * 2 - 100;    final String configs = "maxSessionTimeout=" + maxSessionTimeout + "\n" + "minSessionTimeout=" + minSessionTimeout + "\n";    MainThread main = new MainThread(CLIENT_PORT, true, configs);    String[] args = new String[1];    args[0] = main.confFile.toString();    try {        main.main.initializeAndRun(args);        fail("Must throw exception as " + "minsessiontimeout > maxsessiontimeout");    } catch (ConfigException iae) {        }}
testInvalidMetricsProvider
public void zookeeper_f5702_0() throws Exception
{    ClientBase.setupTestEnv();    final int CLIENT_PORT = PortAssignment.unique();    final String configs = "metricsProvider.className=BadClass\n";    MainThread main = new MainThread(CLIENT_PORT, true, configs);    String[] args = new String[1];    args[0] = main.confFile.toString();    try {        main.main.initializeAndRun(args);        fail("Must throw exception as metrics provider is not " + "well configured");    } catch (ConfigException iae) {        }}
testFaultyMetricsProviderOnStart
public void zookeeper_f5703_0() throws Exception
{    ClientBase.setupTestEnv();    final int CLIENT_PORT = PortAssignment.unique();    final String configs = "metricsProvider.className=" + MetricsProviderWithErrorInStart.class.getName() + "\n";    MainThread main = new MainThread(CLIENT_PORT, true, configs);    String[] args = new String[1];    args[0] = main.confFile.toString();    try {        main.main.initializeAndRun(args);        fail("Must throw exception as metrics provider cannot boot");    } catch (IOException iae) {        }}
testFaultyMetricsProviderOnConfigure
public void zookeeper_f5704_0() throws Exception
{    ClientBase.setupTestEnv();    final int CLIENT_PORT = PortAssignment.unique();    final String configs = "metricsProvider.className=" + MetricsProviderWithErrorInConfigure.class.getName() + "\n";    MainThread main = new MainThread(CLIENT_PORT, true, configs);    String[] args = new String[1];    args[0] = main.confFile.toString();    try {        main.main.initializeAndRun(args);        fail("Must throw exception as metrics provider is cannot boot");    } catch (IOException iae) {        }}
testFaultyMetricsProviderOnStop
public void zookeeper_f5705_0() throws Exception
{    ClientBase.setupTestEnv();    final int CLIENT_PORT = PortAssignment.unique();    MetricsProviderWithErrorInStop.stopCalled.set(false);    final String configs = "metricsProvider.className=" + MetricsProviderWithErrorInStop.class.getName() + "\n";    MainThread main = new MainThread(CLIENT_PORT, true, configs);    main.start();    assertTrue("waiting for server being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT, CONNECTION_TIMEOUT));    clientConnected = new CountDownLatch(1);    ZooKeeper zk = new ZooKeeper("127.0.0.1:" + CLIENT_PORT, ClientBase.CONNECTION_TIMEOUT, this);    assertTrue("Failed to establish zkclient connection!", clientConnected.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS));    zk.create("/foo", "foobar".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    assertEquals(new String(zk.getData("/foo", null, null)), "foobar");    zk.close();    main.shutdown();    main.join();    main.deleteDirs();    assertTrue("waiting for server down", ClientBase.waitForServerDown("127.0.0.1:" + CLIENT_PORT, ClientBase.CONNECTION_TIMEOUT));    assertTrue(MetricsProviderWithErrorInStop.stopCalled.get());}
testMetricsProviderConfiguration
public void zookeeper_f5706_0() throws Exception
{    ClientBase.setupTestEnv();    final int CLIENT_PORT = PortAssignment.unique();    MetricsProviderWithConfiguration.httpPort.set(0);    final String configs = "metricsProvider.className=" + MetricsProviderWithConfiguration.class.getName() + "\n" + "metricsProvider.httpPort=1234\n";    MainThread main = new MainThread(CLIENT_PORT, true, configs);    main.start();    assertTrue("waiting for server being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT, CONNECTION_TIMEOUT));    clientConnected = new CountDownLatch(1);    ZooKeeper zk = new ZooKeeper("127.0.0.1:" + CLIENT_PORT, ClientBase.CONNECTION_TIMEOUT, this);    assertTrue("Failed to establish zkclient connection!", clientConnected.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS));    zk.create("/foo", "foobar".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    assertEquals(new String(zk.getData("/foo", null, null)), "foobar");    zk.close();    main.shutdown();    main.join();    main.deleteDirs();    assertTrue("waiting for server down", ClientBase.waitForServerDown("127.0.0.1:" + CLIENT_PORT, ClientBase.CONNECTION_TIMEOUT));    assertEquals(1234, MetricsProviderWithConfiguration.httpPort.get());}
testMetricsProviderLifecycle
public void zookeeper_f5707_0() throws Exception
{    ClientBase.setupTestEnv();    MetricsProviderCapturingLifecycle.reset();    final int CLIENT_PORT = PortAssignment.unique();    final String configs = "metricsProvider.className=" + MetricsProviderCapturingLifecycle.class.getName() + "\n" + "metricsProvider.httpPort=1234\n";    MainThread main = new MainThread(CLIENT_PORT, true, configs);    main.start();    assertTrue("waiting for server being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT, CONNECTION_TIMEOUT));    clientConnected = new CountDownLatch(1);    ZooKeeper zk = new ZooKeeper("127.0.0.1:" + CLIENT_PORT, ClientBase.CONNECTION_TIMEOUT, this);    assertTrue("Failed to establish zkclient connection!", clientConnected.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS));    zk.create("/foo", "foobar".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    assertEquals(new String(zk.getData("/foo", null, null)), "foobar");    zk.close();    main.shutdown();    main.join();    main.deleteDirs();    assertTrue("waiting for server down", ClientBase.waitForServerDown("127.0.0.1:" + CLIENT_PORT, ClientBase.CONNECTION_TIMEOUT));    assertTrue("metrics provider lifecycle error", BaseTestMetricsProvider.MetricsProviderCapturingLifecycle.configureCalled.get());    assertTrue("metrics provider lifecycle error", BaseTestMetricsProvider.MetricsProviderCapturingLifecycle.startCalled.get());    assertTrue("metrics provider lifecycle error", BaseTestMetricsProvider.MetricsProviderCapturingLifecycle.getRootContextCalled.get());    assertTrue("metrics provider lifecycle error", BaseTestMetricsProvider.MetricsProviderCapturingLifecycle.stopCalled.get());}
testWithOnlyMinSessionTimeout
public void zookeeper_f5708_0() throws Exception
{    ClientBase.setupTestEnv();    final int CLIENT_PORT = PortAssignment.unique();    final int tickTime = 2000;    final int minSessionTimeout = tickTime * 2 - 100;    int maxSessionTimeout = 20 * tickTime;    final String configs = "minSessionTimeout=" + minSessionTimeout + "\n";    MainThread main = new MainThread(CLIENT_PORT, true, configs);    main.start();    String HOSTPORT = "127.0.0.1:" + CLIENT_PORT;    assertTrue("waiting for server being up", ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT));        verifySessionTimeOut(minSessionTimeout, minSessionTimeout, HOSTPORT);    verifySessionTimeOut(minSessionTimeout - 2000, minSessionTimeout, HOSTPORT);        verifySessionTimeOut(maxSessionTimeout, maxSessionTimeout, HOSTPORT);    verifySessionTimeOut(maxSessionTimeout + 2000, maxSessionTimeout, HOSTPORT);    main.shutdown();    assertTrue("waiting for server down", ClientBase.waitForServerDown(HOSTPORT, ClientBase.CONNECTION_TIMEOUT));}
testMinMaxSessionTimeOut
public void zookeeper_f5709_0() throws Exception
{    ClientBase.setupTestEnv();    final int CLIENT_PORT = PortAssignment.unique();    final int tickTime = 2000;    final int minSessionTimeout = tickTime * 2 - 100;    final int maxSessionTimeout = 20 * tickTime + 1000;    final String configs = "maxSessionTimeout=" + maxSessionTimeout + "\n" + "minSessionTimeout=" + minSessionTimeout + "\n";    MainThread main = new MainThread(CLIENT_PORT, true, configs);    main.start();    String HOSTPORT = "127.0.0.1:" + CLIENT_PORT;    assertTrue("waiting for server being up", ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT));        verifySessionTimeOut(minSessionTimeout, minSessionTimeout, HOSTPORT);    verifySessionTimeOut(minSessionTimeout - 2000, minSessionTimeout, HOSTPORT);        verifySessionTimeOut(maxSessionTimeout, maxSessionTimeout, HOSTPORT);    verifySessionTimeOut(maxSessionTimeout + 2000, maxSessionTimeout, HOSTPORT);    main.shutdown();    assertTrue("waiting for server down", ClientBase.waitForServerDown(HOSTPORT, ClientBase.CONNECTION_TIMEOUT));}
verifySessionTimeOut
private void zookeeper_f5710_0(int sessionTimeout, int expectedSessionTimeout, String HOSTPORT) throws IOException, KeeperException, InterruptedException
{    clientConnected = new CountDownLatch(1);    ZooKeeper zk = new ZooKeeper(HOSTPORT, sessionTimeout, this);    assertTrue("Failed to establish zkclient connection!", clientConnected.await(sessionTimeout, TimeUnit.MILLISECONDS));    assertEquals("Not able to configure the sessionTimeout values", expectedSessionTimeout, zk.getSessionTimeout());    zk.close();}
testJMXRegistrationWithNIO
public void zookeeper_f5711_0() throws Exception
{    ClientBase.setupTestEnv();    File tmpDir_1 = ClientBase.createTmpDir();    ServerCnxnFactory server_1 = startServer(tmpDir_1);    File tmpDir_2 = ClientBase.createTmpDir();    ServerCnxnFactory server_2 = startServer(tmpDir_2);    server_1.shutdown();    server_2.shutdown();    deleteFile(tmpDir_1);    deleteFile(tmpDir_2);}
testJMXRegistrationWithNetty
public void zookeeper_f5712_0() throws Exception
{    String originalServerCnxnFactory = System.getProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY);    System.setProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY, NettyServerCnxnFactory.class.getName());    try {        ClientBase.setupTestEnv();        File tmpDir_1 = ClientBase.createTmpDir();        ServerCnxnFactory server_1 = startServer(tmpDir_1);        File tmpDir_2 = ClientBase.createTmpDir();        ServerCnxnFactory server_2 = startServer(tmpDir_2);        server_1.shutdown();        server_2.shutdown();        deleteFile(tmpDir_1);        deleteFile(tmpDir_2);    } finally {                if (originalServerCnxnFactory == null || originalServerCnxnFactory.isEmpty()) {            System.clearProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY);        } else {            System.setProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY, originalServerCnxnFactory);        }    }}
deleteFile
private void zookeeper_f5713_0(File f) throws IOException
{    if (f.isDirectory()) {        for (File c : f.listFiles()) {            deleteFile(c);        }    }    if (!f.delete()) {        if (f.exists()) {            throw new IOException("Failed to delete file: " + f);        }    }}
startServer
private ServerCnxnFactory zookeeper_f5714_0(File tmpDir) throws IOException, InterruptedException
{    final int CLIENT_PORT = PortAssignment.unique();    ZooKeeperServer zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);    ServerCnxnFactory f = ServerCnxnFactory.createFactory(CLIENT_PORT, -1);    f.startup(zks);    assertNotNull("JMX initialization failed!", zks.jmxServerBean);    assertTrue("waiting for server being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT, CONNECTION_TIMEOUT));    return f;}
process
public void zookeeper_f5715_0(WatchedEvent event)
{    if (event.getState() == KeeperState.SyncConnected) {        clientConnected.countDown();    }}
teardown
public void zookeeper_f5716_0() throws Exception
{            startupDelayLatch.countDown();    if (servcnxnf != null) {        servcnxnf.shutdown();    }    if (zks != null) {        zks.shutdown();    }    if (zks.getZKDatabase() != null) {        zks.getZKDatabase().close();    }    ClientBase.recursiveDelete(tmpDir);}
testClientConnectionRequestDuringStartupWithNIOServerCnxn
public voidf5717_1) throws Exception
{    tmpDir = ClientBase.createTmpDir();    ClientBase.setupTestEnv();    startSimpleZKServer(startupDelayLatch);    SimpleZooKeeperServer simplezks = (SimpleZooKeeperServer) zks;    assertTrue("Failed to invoke zks#startup() method during server startup", simplezks.waitForStartupInvocation(10));    CountdownWatcher watcher = new CountdownWatcher();    ZooKeeper zkClient = new ZooKeeper(HOSTPORT, ClientBase.CONNECTION_TIMEOUT, watcher);    assertFalse("Since server is not fully started, zks#createSession() shouldn't be invoked", simplezks.waitForSessionCreation(5));        startupDelayLatch.countDown();    assertTrue("waiting for server being up ", ClientBase.waitForServerUp(HOSTPORT, ClientBase.CONNECTION_TIMEOUT));    assertTrue("Failed to invoke zks#createSession() method during client session creation", simplezks.waitForSessionCreation(5));    watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT);    zkClient.close();}
testClientConnectionRequestDuringStartupWithNettyServerCnxn
public voidf5718_1) throws Exception
{    tmpDir = ClientBase.createTmpDir();    ClientBase.setupTestEnv();    String originalServerCnxnFactory = System.getProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY);    try {        System.setProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY, NettyServerCnxnFactory.class.getName());        startSimpleZKServer(startupDelayLatch);        SimpleZooKeeperServer simplezks = (SimpleZooKeeperServer) zks;        assertTrue("Failed to invoke zks#startup() method during server startup", simplezks.waitForStartupInvocation(10));        CountdownWatcher watcher = new CountdownWatcher();        ZooKeeper zkClient = new ZooKeeper(HOSTPORT, ClientBase.CONNECTION_TIMEOUT, watcher);        assertFalse("Since server is not fully started, zks#createSession() shouldn't be invoked", simplezks.waitForSessionCreation(5));                startupDelayLatch.countDown();        assertTrue("waiting for server being up ", ClientBase.waitForServerUp(HOSTPORT, ClientBase.CONNECTION_TIMEOUT));        assertTrue("Failed to invoke zks#createSession() method during client session creation", simplezks.waitForSessionCreation(5));        watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT);        zkClient.close();    } finally {                if (originalServerCnxnFactory == null) {            System.clearProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY);            return;        }        System.setProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY, originalServerCnxnFactory);    }}
testFourLetterWords
public void zookeeper_f5719_0() throws Exception
{    startSimpleZKServer(startupDelayLatch);    verify("conf", ZK_NOT_SERVING);    verify("crst", ZK_NOT_SERVING);    verify("cons", ZK_NOT_SERVING);    verify("dirs", ZK_NOT_SERVING);    verify("dump", ZK_NOT_SERVING);    verify("mntr", ZK_NOT_SERVING);    verify("stat", ZK_NOT_SERVING);    verify("srst", ZK_NOT_SERVING);    verify("wchp", ZK_NOT_SERVING);    verify("wchc", ZK_NOT_SERVING);    verify("wchs", ZK_NOT_SERVING);    verify("isro", "null");}
verify
private voidf5720_1String cmd, String expected) throws IOException, SSLContextException
{    String resp = sendRequest(cmd);        assertTrue("Unexpected response", resp.contains(expected));}
sendRequest
private String zookeeper_f5721_0(String cmd) throws IOException, SSLContextException
{    return send4LetterWord(HOST, PORT, cmd);}
startSimpleZKServer
private voidf5722_1CountDownLatch startupDelayLatch) throws IOException
{    zks = new SimpleZooKeeperServer(tmpDir, tmpDir, 3000, startupDelayLatch);    SyncRequestProcessor.setSnapCount(100);    final int PORT = Integer.parseInt(HOSTPORT.split(":")[1]);    servcnxnf = ServerCnxnFactory.createFactory(PORT, -1);    Thread startupThread = new Thread() {        public void run() {            try {                servcnxnf.startup(zks);            } catch (IOException e) {                                                    } catch (InterruptedException e) {                                                    }        }    };        startupThread.start();}
run
public voidf5723_1)
{    try {        servcnxnf.startup(zks);    } catch (IOException e) {                    } catch (InterruptedException e) {                    }}
startup
public synchronized void zookeeper_f5724_0()
{    try {        startupInvokedLatch.countDown();                                                        startupDelayLatch.await();    } catch (InterruptedException e) {        fail("Unexpected InterruptedException while startinng up!");    }    super.startup();}
createSession
 long zookeeper_f5725_0(ServerCnxn cnxn, byte[] passwd, int timeout)
{    createSessionInvokedLatch.countDown();    return super.createSession(cnxn, passwd, timeout);}
waitForStartupInvocation
 boolean zookeeper_f5726_0(long timeout) throws InterruptedException
{    return startupInvokedLatch.await(timeout, TimeUnit.SECONDS);}
waitForSessionCreation
 boolean zookeeper_f5727_0(long timeout) throws InterruptedException
{    return createSessionInvokedLatch.await(timeout, TimeUnit.SECONDS);}
testSortDataDirAscending
public void zookeeper_f5728_0()
{    File[] files = new File[5];    files[0] = new File("foo.10027c6de");    files[1] = new File("foo.10027c6df");    files[2] = new File("bar.10027c6dd");    files[3] = new File("foo.10027c6dc");    files[4] = new File("foo.20027c6dc");    File[] orig = files.clone();    List<File> filelist = Util.sortDataDir(files, "foo", true);    assertEquals(orig[2], filelist.get(0));    assertEquals(orig[3], filelist.get(1));    assertEquals(orig[0], filelist.get(2));    assertEquals(orig[1], filelist.get(3));    assertEquals(orig[4], filelist.get(4));}
testSortDataDirDescending
public void zookeeper_f5729_0()
{    File[] files = new File[5];    files[0] = new File("foo.10027c6de");    files[1] = new File("foo.10027c6df");    files[2] = new File("bar.10027c6dd");    files[3] = new File("foo.10027c6dc");    files[4] = new File("foo.20027c6dc");    File[] orig = files.clone();    List<File> filelist = Util.sortDataDir(files, "foo", false);    assertEquals(orig[4], filelist.get(0));    assertEquals(orig[1], filelist.get(1));    assertEquals(orig[0], filelist.get(2));    assertEquals(orig[3], filelist.get(3));    assertEquals(orig[2], filelist.get(4));}
testGetLogFiles
public void zookeeper_f5730_0()
{    File[] files = new File[5];    files[0] = new File("log.10027c6de");    files[1] = new File("log.10027c6df");    files[2] = new File("snapshot.10027c6dd");    files[3] = new File("log.10027c6dc");    files[4] = new File("log.20027c6dc");    File[] orig = files.clone();    File[] filelist = FileTxnLog.getLogFiles(files, Long.parseLong("10027c6de", 16));    assertEquals(3, filelist.length);    assertEquals(orig[0], filelist[0]);    assertEquals(orig[1], filelist[1]);    assertEquals(orig[4], filelist[2]);}
testForceSyncDefaultEnabled
public void zookeeper_f5731_0()
{    File file = new File("foo.10027c6de");    FileTxnLog log = new FileTxnLog(file);    assertTrue(log.isForceSync());}
testForceSyncDefaultDisabled
public void zookeeper_f5732_0()
{    try {        File file = new File("foo.10027c6de");        System.setProperty("zookeeper.forceSync", "no");        FileTxnLog log = new FileTxnLog(file);        assertFalse(log.isForceSync());    } finally {                System.setProperty("zookeeper.forceSync", "yes");    }}
testInvalidSnapshot
public void zookeeper_f5733_0()
{    File f = null;    File tmpFileDir = null;    try {        tmpFileDir = ClientBase.createTmpDir();        f = new File(tmpFileDir, "snapshot.0");        if (!f.exists()) {            f.createNewFile();        }        assertFalse("Snapshot file size is greater than 9 bytes", SnapStream.isValidSnapshot(f));        assertTrue("Can't delete file", f.delete());    } catch (IOException e) {    } finally {        if (null != tmpFileDir) {            ClientBase.recursiveDelete(tmpFileDir);        }    }}
run
public void zookeeper_f5734_0()
{    throw new Error();}
handleException
protected void zookeeper_f5735_0(String thName, Throwable e)
{    runningLatch.countDown();}
notifyStopping
public void zookeeper_f5736_0(String threadName, int erroCode)
{}
run
public void zookeeper_f5737_0()
{    throw new Error();}
handleException
protected void zookeeper_f5738_0(String thName, Throwable e)
{    runningLatch.countDown();}
testUncaughtException
public void zookeeper_f5739_0() throws Exception
{    MyThread t1 = new MyThread("Test-Thread");    t1.start();    assertTrue("Uncaught exception is not properly handled.", runningLatch.await(10000, TimeUnit.MILLISECONDS));    runningLatch = new CountDownLatch(1);    MyCriticalThread t2 = new MyCriticalThread("Test-Critical-Thread");    t2.start();    assertTrue("Uncaught exception is not properly handled.", runningLatch.await(10000, TimeUnit.MILLISECONDS));}
getClient
private ZooKeeper zookeeper_f5740_0(int idx)
{    return zkClients[idx - 1];}
setUp
public void zookeeper_f5741_0() throws Exception
{    System.setProperty("zookeeper.admin.enableServer", "false");            SyncRequestProcessor.setSnapCount(7);    qu = new QuorumUtil(1);    startAll();    for (int i = 0; i < zkClients.length; i++) {        zkClientWatchers[i] = new CountdownWatcher();        PeerStruct peer = qu.getPeer(i + 1);        zkClients[i] = new ZooKeeper("127.0.0.1:" + peer.clientPort, ClientTest.CONNECTION_TIMEOUT, zkClientWatchers[i]);    }    waitForClientsConnected();}
waitForClientsConnected
private void zookeeper_f5742_0() throws Exception
{    for (int i = 0; i < zkClients.length; i++) {        zkClientWatchers[i].waitForConnected(ClientTest.CONNECTION_TIMEOUT);        zkClientWatchers[i].reset();    }}
checkClientsConnected
private void zookeeper_f5743_0() throws Exception
{    for (int i = 0; i < zkClients.length; i++) {        checkClientConnected(i + 1);    }}
checkClientConnected
private void zookeeper_f5744_0(int idx) throws Exception
{    ZooKeeper zk = getClient(idx);    if (zk == null) {        return;    }    try {        assertNull(zk.exists("/foofoofoo-connected", false));    } catch (ConnectionLossException e) {                                                                        PeerStruct peer = qu.getPeer(idx);        assertTrue("Waiting for server down", ClientBase.waitForServerUp("127.0.0.1:" + peer.clientPort, ClientBase.CONNECTION_TIMEOUT));        assertNull(zk.exists("/foofoofoo-connected", false));    }}
checkClientsDisconnected
private void zookeeper_f5745_0() throws Exception
{    for (int i = 0; i < zkClients.length; i++) {        checkClientDisconnected(i + 1);    }}
checkClientDisconnected
private void zookeeper_f5746_0(int idx) throws Exception
{    ZooKeeper zk = getClient(idx);    if (zk == null) {        return;    }    try {        assertNull(zk.exists("/foofoofoo-disconnected", false));        fail("expected client to be disconnected");    } catch (KeeperException e) {        }}
startAll
private void zookeeper_f5747_0() throws Exception
{    qu.startAll();    checkLeader();        checkClientsConnected();}
start
private void zookeeper_f5748_0(int idx) throws Exception
{    qu.start(idx);    for (String hp : qu.getConnString().split(",")) {        assertTrue("waiting for server up", ClientBase.waitForServerUp(hp, ClientTest.CONNECTION_TIMEOUT));    }    checkLeader();        checkClientsConnected();}
checkLeader
private void zookeeper_f5749_0()
{    idxLeader = 1;    while (qu.getPeer(idxLeader).peer.leader == null) {        idxLeader++;    }    idxFollower = (idxLeader == 1 ? 2 : 1);    zksLeader = qu.getPeer(idxLeader).peer.getActiveServer();}
shutdownAll
private void zookeeper_f5750_0() throws Exception
{    qu.shutdownAll();        checkClientsDisconnected();}
shutdown
private void zookeeper_f5751_0(int idx) throws Exception
{    qu.shutdown(idx);        PeerStruct peer = qu.getPeer(idx);    assertTrue("Waiting for server down", ClientBase.waitForServerDown("127.0.0.1:" + peer.clientPort, ClientBase.CONNECTION_TIMEOUT));        if (idx == idxLeader) {        checkClientDisconnected(idx);        try {            checkClientsDisconnected();        } catch (AssertionError e) {                        }    } else {        checkClientDisconnected(idx);    }}
adjustEpochNearEnd
private void zookeeper_f5752_0()
{    zksLeader.setZxid((zksLeader.getZxid() & 0xffffffff00000000L) | 0xfffffffcL);}
tearDown
public voidf5753_1) throws Exception
{        for (int i = 0; i < zkClients.length; i++) {        zkClients[i].close();    }    qu.shutdownAll();}
createNodes
private intf5754_1ZooKeeper zk, int start, int count) throws Exception
{        int j = 0;    try {        for (int i = start; i < start + count; i++) {            zk.create("/foo" + i, new byte[0], Ids.READ_ACL_UNSAFE, CreateMode.EPHEMERAL);            j++;        }    } catch (ConnectionLossException e) {                waitForClientsConnected();    }    return j;}
checkNodes
private voidf5755_1ZooKeeper zk, int start, int count) throws Exception
{        for (int i = start; i < start + count; i++) {        assertNotNull(zk.exists("/foo" + i, false));            }    assertNull(zk.exists("/foo" + (start + count), false));}
testSimpleRolloverFollower
public void zookeeper_f5756_0() throws Exception
{    adjustEpochNearEnd();    ZooKeeper zk = getClient((idxLeader == 1 ? 2 : 1));    int countCreated = createNodes(zk, 0, 10);    checkNodes(zk, 0, countCreated);}
testRolloverThenRestart
public void zookeeper_f5757_0() throws Exception
{    ZooKeeper zk = getClient(idxFollower);    int countCreated = createNodes(zk, 0, 10);    adjustEpochNearEnd();    countCreated += createNodes(zk, countCreated, 10);    shutdownAll();    startAll();    zk = getClient(idxLeader);    checkNodes(zk, 0, countCreated);    countCreated += createNodes(zk, countCreated, 10);    adjustEpochNearEnd();    checkNodes(zk, 0, countCreated);    countCreated += createNodes(zk, countCreated, 10);    shutdownAll();    startAll();    zk = getClient(idxFollower);    checkNodes(zk, 0, countCreated);    countCreated += createNodes(zk, countCreated, 10);    shutdownAll();    startAll();    zk = getClient(idxLeader);    checkNodes(zk, 0, countCreated);    countCreated += createNodes(zk, countCreated, 10);        assertTrue(countCreated > 0);    assertTrue(countCreated < 60);}
testRolloverThenFollowerRestart
public void zookeeper_f5758_0() throws Exception
{    ZooKeeper zk = getClient(idxFollower);    int countCreated = createNodes(zk, 0, 10);    adjustEpochNearEnd();    countCreated += createNodes(zk, countCreated, 10);    shutdown(idxFollower);    start(idxFollower);    checkNodes(zk, 0, countCreated);    countCreated += createNodes(zk, countCreated, 10);    adjustEpochNearEnd();    checkNodes(zk, 0, countCreated);    countCreated += createNodes(zk, countCreated, 10);    shutdown(idxFollower);    start(idxFollower);    checkNodes(zk, 0, countCreated);    countCreated += createNodes(zk, countCreated, 10);    shutdown(idxFollower);    start(idxFollower);    checkNodes(zk, 0, countCreated);    countCreated += createNodes(zk, countCreated, 10);        assertTrue(countCreated > 0);    assertTrue(countCreated < 60);}
testRolloverThenLeaderRestart
public void zookeeper_f5759_0() throws Exception
{    ZooKeeper zk = getClient(idxLeader);    int countCreated = createNodes(zk, 0, 10);    adjustEpochNearEnd();    checkNodes(zk, 0, countCreated);    shutdown(idxLeader);    start(idxLeader);    zk = getClient(idxLeader);    checkNodes(zk, 0, countCreated);    countCreated += createNodes(zk, countCreated, 10);    adjustEpochNearEnd();    checkNodes(zk, 0, countCreated);    countCreated += createNodes(zk, countCreated, 10);    shutdown(idxLeader);    start(idxLeader);    zk = getClient(idxLeader);    checkNodes(zk, 0, countCreated);    countCreated += createNodes(zk, countCreated, 10);    shutdown(idxLeader);    start(idxLeader);    zk = getClient(idxFollower);    checkNodes(zk, 0, countCreated);    countCreated += createNodes(zk, countCreated, 10);        assertTrue(countCreated > 0);    assertTrue(countCreated < 50);}
testMultipleRollover
public void zookeeper_f5760_0() throws Exception
{    ZooKeeper zk = getClient(idxFollower);    int countCreated = createNodes(zk, 0, 10);    adjustEpochNearEnd();    countCreated += createNodes(zk, countCreated, 10);    adjustEpochNearEnd();    countCreated += createNodes(zk, countCreated, 10);    adjustEpochNearEnd();    countCreated += createNodes(zk, countCreated, 10);    adjustEpochNearEnd();    countCreated += createNodes(zk, countCreated, 10);    shutdownAll();    startAll();    zk = getClient(idxFollower);    adjustEpochNearEnd();    checkNodes(zk, 0, countCreated);    countCreated += createNodes(zk, countCreated, 10);    shutdown(idxLeader);    start(idxLeader);    zk = getClient(idxFollower);    checkNodes(zk, 0, countCreated);    countCreated += createNodes(zk, countCreated, 10);        assertTrue(countCreated > 0);    assertTrue(countCreated < 70);}
setUp
public void zookeeper_f5761_0()
{    serverConfig = new ServerConfig();}
testFewArguments
public void zookeeper_f5762_0()
{    String[] args = { "2181" };    serverConfig.parse(args);}
testValidArguments
public void zookeeper_f5763_0()
{    String[] args = { "2181", "/data/dir", "60000", "10000" };    serverConfig.parse(args);    assertEquals(2181, serverConfig.getClientPortAddress().getPort());    assertTrue(checkEquality("/data/dir", serverConfig.getDataDir()));    assertEquals(60000, serverConfig.getTickTime());    assertEquals(10000, serverConfig.getMaxClientCnxns());}
testTooManyArguments
public void zookeeper_f5764_0()
{    String[] args = { "2181", "/data/dir", "60000", "10000", "9999" };    serverConfig.parse(args);}
testJvmPauseMonitorConfigured
public void zookeeper_f5765_0()
{    final Long sleepTime = 444L;    final Long warnTH = 5555L;    final Long infoTH = 555L;    QuorumPeerConfig qpConfig = mock(QuorumPeerConfig.class);    when(qpConfig.isJvmPauseMonitorToRun()).thenReturn(true);    when(qpConfig.getJvmPauseSleepTimeMs()).thenReturn(sleepTime);    when(qpConfig.getJvmPauseWarnThresholdMs()).thenReturn(warnTH);    when(qpConfig.getJvmPauseInfoThresholdMs()).thenReturn(infoTH);    serverConfig.readFrom(qpConfig);    assertEquals(sleepTime, Long.valueOf(serverConfig.getJvmPauseSleepTimeMs()));    assertEquals(warnTH, Long.valueOf(serverConfig.getJvmPauseWarnThresholdMs()));    assertEquals(infoTH, Long.valueOf(serverConfig.getJvmPauseInfoThresholdMs()));    assertTrue(serverConfig.isJvmPauseMonitorToRun());}
checkEquality
 boolean zookeeper_f5766_0(String a, String b)
{    assertNotNull(a);    assertNotNull(b);    return a.equals(b);}
checkEquality
 boolean zookeeper_f5767_0(String a, File b)
{    assertNotNull(a);    assertNotNull(b);    return new File(a).equals(b);}
testAclCount
public voidf5768_1) throws Exception
{    File tmpDir = ClientBase.createTmpDir();    ClientBase.setupTestEnv();    ZooKeeperServer zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);    SyncRequestProcessor.setSnapCount(1000);    final int PORT = Integer.parseInt(HOSTPORT.split(":")[1]);    ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);    f.startup(zks);    ZooKeeper zk;    final ArrayList<ACL> CREATOR_ALL_AND_WORLD_READABLE = new ArrayList<ACL>() {        {            add(new ACL(ZooDefs.Perms.READ, ZooDefs.Ids.ANYONE_ID_UNSAFE));            add(new ACL(ZooDefs.Perms.ALL, ZooDefs.Ids.AUTH_IDS));            add(new ACL(ZooDefs.Perms.READ, ZooDefs.Ids.ANYONE_ID_UNSAFE));            add(new ACL(ZooDefs.Perms.ALL, ZooDefs.Ids.AUTH_IDS));        }    };    try {                assertTrue("waiting for server being up", ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT));        zk = ClientBase.createZKClient(HOSTPORT);        zk.addAuthInfo("digest", "pat:test".getBytes());        zk.setACL("/", Ids.CREATOR_ALL_ACL, -1);        String path = "/path";        try {            assertEquals(4, CREATOR_ALL_AND_WORLD_READABLE.size());        } catch (Exception e) {                        throw e;        }        zk.create(path, path.getBytes(), CREATOR_ALL_AND_WORLD_READABLE, CreateMode.PERSISTENT);        List<ACL> acls = zk.getACL("/path", new Stat());        assertEquals(2, acls.size());    } catch (Exception e) {                assertTrue(false);    }    f.shutdown();    zks.shutdown();}
testRootAcl
public void zookeeper_f5769_0() throws Exception
{    ZooKeeper zk = createClient();    try {                zk.addAuthInfo("digest", "pat:test".getBytes());        zk.setACL("/", Ids.CREATOR_ALL_ACL, -1);        zk.getData("/", false, null);        zk.close();                zk = createClient();        try {            zk.getData("/", false, null);            fail("validate auth");        } catch (KeeperException.NoAuthException e) {                }        try {            zk.create("/apps", null, Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT);            fail("validate auth");        } catch (KeeperException.InvalidACLException e) {                }        zk.addAuthInfo("digest", "world:anyone".getBytes());        try {            zk.create("/apps", null, Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT);            fail("validate auth");        } catch (KeeperException.NoAuthException e) {                }        zk.close();                zk = createClient();        zk.addAuthInfo("digest", "pat:test".getBytes());        zk.getData("/", false, null);        zk.create("/apps", null, Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT);        zk.delete("/apps", -1);                zk.setACL("/", Ids.OPEN_ACL_UNSAFE, -1);        zk.close();        zk = createClient();        zk.getData("/", false, null);        zk.create("/apps", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        try {            zk.create("/apps", null, Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT);            fail("validate auth");        } catch (KeeperException.InvalidACLException e) {                }        zk.delete("/apps", -1);        zk.addAuthInfo("digest", "world:anyone".getBytes());        zk.create("/apps", null, Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT);        zk.close();        zk = createClient();        zk.delete("/apps", -1);    } finally {        zk.close();    }}
testIPAuthenticationIsValidCIDR
public void zookeeper_f5770_0() throws Exception
{    IPAuthenticationProvider prov = new IPAuthenticationProvider();    assertTrue("testing no netmask", prov.isValid("127.0.0.1"));    assertTrue("testing single ip netmask", prov.isValid("127.0.0.1/32"));    assertTrue("testing lowest netmask possible", prov.isValid("127.0.0.1/0"));    assertFalse("testing netmask too high", prov.isValid("127.0.0.1/33"));    assertFalse("testing netmask too low", prov.isValid("10.0.0.1/-1"));}
testNettyIpAuthDefault
public voidf5771_1) throws Exception
{    String HOSTPORT = "127.0.0.1:" + PortAssignment.unique();    System.setProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY, "org.apache.zookeeper.server.NettyServerCnxnFactory");    ClientBase.setupTestEnv();    File tmpDir = ClientBase.createTmpDir();    ZooKeeperServer zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);    SyncRequestProcessor.setSnapCount(1000);    final int PORT = Integer.parseInt(HOSTPORT.split(":")[1]);    ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);    f.startup(zks);    try {                assertTrue("waiting for server being up", ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT));        ClientBase.createZKClient(HOSTPORT);        for (ServerCnxn cnxn : f.getConnections()) {            boolean foundID = false;            for (Id id : cnxn.getAuthInfo()) {                if (id.getScheme().equals("ip")) {                    foundID = true;                    break;                }            }            assertTrue(foundID);        }    } finally {        f.shutdown();        zks.shutdown();        assertTrue("waiting for server down", ClientBase.waitForServerDown(HOSTPORT, CONNECTION_TIMEOUT));        System.clearProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY);    }}
testDisconnectedAddAuth
public voidf5772_1) throws Exception
{    File tmpDir = ClientBase.createTmpDir();    ClientBase.setupTestEnv();    ZooKeeperServer zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);    SyncRequestProcessor.setSnapCount(1000);    final int PORT = Integer.parseInt(HOSTPORT.split(":")[1]);    ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);    f.startup(zks);    try {                assertTrue("waiting for server being up", ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT));        ZooKeeper zk = ClientBase.createZKClient(HOSTPORT);        try {            zk.addAuthInfo("digest", "pat:test".getBytes());            zk.setACL("/", Ids.CREATOR_ALL_ACL, -1);        } finally {            zk.close();        }    } finally {        f.shutdown();        zks.shutdown();        assertTrue("waiting for server down", ClientBase.waitForServerDown(HOSTPORT, ClientBase.CONNECTION_TIMEOUT));    }}
testAcls
public voidf5773_1) throws Exception
{    File tmpDir = ClientBase.createTmpDir();    ClientBase.setupTestEnv();    ZooKeeperServer zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);    SyncRequestProcessor.setSnapCount(1000);    final int PORT = Integer.parseInt(HOSTPORT.split(":")[1]);    ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);    f.startup(zks);    ZooKeeper zk;    String path;    try {                assertTrue("waiting for server being up", ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT));        zk = ClientBase.createZKClient(HOSTPORT);                for (int i = 0; i < 100; i++) {            path = "/" + i;            zk.create(path, path.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        }        int size = zks.getZKDatabase().getAclSize();        assertTrue("size of the acl map ", (2 == zks.getZKDatabase().getAclSize()));        for (int j = 100; j < 200; j++) {            path = "/" + j;            ACL acl = new ACL();            acl.setPerms(0);            Id id = new Id();            id.setId("1.1.1." + j);            id.setScheme("ip");            acl.setId(id);            List<ACL> list = new ArrayList<ACL>();            list.add(acl);            zk.create(path, path.getBytes(), list, CreateMode.PERSISTENT);        }        assertTrue("size of the acl map ", (102 == zks.getZKDatabase().getAclSize()));    } finally {                f.shutdown();        zks.shutdown();        assertTrue("waiting for server down", ClientBase.waitForServerDown(HOSTPORT, CONNECTION_TIMEOUT));    }    zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);    f = ServerCnxnFactory.createFactory(PORT, -1);    f.startup(zks);    try {        assertTrue("waiting for server up", ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT));        zk = ClientBase.createZKClient(HOSTPORT);        assertTrue("acl map ", (102 == zks.getZKDatabase().getAclSize()));        for (int j = 200; j < 205; j++) {            path = "/" + j;            ACL acl = new ACL();            acl.setPerms(0);            Id id = new Id();            id.setId("1.1.1." + j);            id.setScheme("ip");            acl.setId(id);            ArrayList<ACL> list = new ArrayList<ACL>();            list.add(acl);            zk.create(path, path.getBytes(), list, CreateMode.PERSISTENT);        }        assertTrue("acl map ", (107 == zks.getZKDatabase().getAclSize()));        zk.close();    } finally {        f.shutdown();        zks.shutdown();        assertTrue("waiting for server down", ClientBase.waitForServerDown(HOSTPORT, ClientBase.CONNECTION_TIMEOUT));    }}
process
public voidf5774_1WatchedEvent event)
{        if (event.getState() == KeeperState.SyncConnected) {        if (startSignal != null && startSignal.getCount() > 0) {                        startSignal.countDown();        } else {                    }    }}
testNullACL
public void zookeeper_f5775_0() throws Exception
{    File tmpDir = ClientBase.createTmpDir();    ClientBase.setupTestEnv();    ZooKeeperServer zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);    final int PORT = Integer.parseInt(HOSTPORT.split(":")[1]);    ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);    f.startup(zks);    ZooKeeper zk = ClientBase.createZKClient(HOSTPORT);    try {                try {            zk.create("/foo", "foo".getBytes(), null, CreateMode.PERSISTENT);            fail("Expected InvalidACLException for null ACL parameter");        } catch (InvalidACLException e) {                }                try {            zk.create("/foo", "foo".getBytes(), null, CreateMode.PERSISTENT, null);            fail("Expected InvalidACLException for null ACL parameter");        } catch (InvalidACLException e) {                }                try {            zk.setACL("/foo", null, 0);            fail("Expected InvalidACLException for null ACL parameter");        } catch (InvalidACLException e) {                }    } finally {        zk.close();        f.shutdown();        zks.shutdown();        assertTrue("waiting for server down", ClientBase.waitForServerDown(HOSTPORT, ClientBase.CONNECTION_TIMEOUT));    }}
testNullValueACL
public void zookeeper_f5776_0() throws Exception
{    File tmpDir = ClientBase.createTmpDir();    ClientBase.setupTestEnv();    ZooKeeperServer zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);    final int PORT = Integer.parseInt(HOSTPORT.split(":")[1]);    ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);    f.startup(zks);    ZooKeeper zk = ClientBase.createZKClient(HOSTPORT);    try {        List<ACL> acls = new ArrayList<ACL>();        acls.add(null);                try {            zk.create("/foo", "foo".getBytes(), acls, CreateMode.PERSISTENT);            fail("Expected InvalidACLException for null value in ACL List");        } catch (InvalidACLException e) {                }                try {            zk.create("/foo", "foo".getBytes(), acls, CreateMode.PERSISTENT, null);            fail("Expected InvalidACLException for null value in ACL List");        } catch (InvalidACLException e) {                }                try {            zk.setACL("/foo", acls, -1);            fail("Expected InvalidACLException for null value in ACL List");        } catch (InvalidACLException e) {                }    } finally {        zk.close();        f.shutdown();        zks.shutdown();        assertTrue("waiting for server down", ClientBase.waitForServerDown(HOSTPORT, ClientBase.CONNECTION_TIMEOUT));    }}
setUp
public void zookeeper_f5777_0(boolean withObservers) throws Exception
{    qb.setUp(withObservers);}
restart
protected voidf5778_1) throws Exception
{        qb.tearDown();        JMXEnv.setUp();    qb.startServers();}
tearDown
public voidf5779_1) throws Exception
{        qb.tearDown();}
run
public voidf5780_1)
{    try {        CountdownWatcher watcher = new CountdownWatcher();        zk = new TestableZooKeeper(qb.hostPort, CONNECTION_TIMEOUT, watcher);        watcher.waitForConnected(CONNECTION_TIMEOUT);        while (bang) {                        incOutstanding();            zk.create("/test-", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL, this, null);        }    } catch (InterruptedException e) {        if (bang) {                                    return;        }    } catch (Exception e) {                return;    } finally {        if (zk != null) {            try {                if (!zk.close(CONNECTION_TIMEOUT)) {                    failed = true;                                    }            } catch (InterruptedException e) {                            }        }    }}
incOutstanding
private synchronized void zookeeper_f5781_0() throws InterruptedException
{    outstanding++;    while (outstanding > MAX_OUTSTANDING) {        wait();    }}
decOutstanding
private synchronized void zookeeper_f5782_0()
{    outstanding--;    assertTrue("outstanding >= 0", outstanding >= 0);    notifyAll();}
process
public void zookeeper_f5783_0(WatchedEvent event)
{}
processResult
public voidf5784_1int rc, String path, Object ctx, String name)
{    if (rc != KeeperException.Code.OK.intValue()) {        if (bang) {            failed = true;                    }        decOutstanding();        return;    }    try {        decOutstanding();        zk.delete(name, -1, this, null);    } catch (Exception e) {        if (bang) {            failed = true;                    }    }}
processResult
public voidf5785_1int rc, String path, Object ctx)
{    if (rc != KeeperException.Code.OK.intValue()) {        if (bang) {            failed = true;                    }    }}
testHammer
public voidf5786_1) throws Exception
{    setUp(false);    bang = true;        HammerThread[] hammers = new HammerThread[100];    for (int i = 0; i < hammers.length; i++) {        hammers[i] = new HammerThread("HammerThread-" + i);        hammers[i].start();    }            Thread.sleep(5000);    bang = false;        for (int i = 0; i < hammers.length; i++) {        hammers[i].interrupt();        verifyThreadTerminated(hammers[i], 60000);        assertFalse(hammers[i].failed);    }            qb.verifyRootOfAllServersMatch(qb.hostPort);    restart();            qb.verifyRootOfAllServersMatch(qb.hostPort);    tearDown();}
testObserversHammer
public void zookeeper_f5787_0() throws Exception
{    setUp(true);    bang = true;    Thread[] hammers = new Thread[100];    for (int i = 0; i < hammers.length; i++) {        hammers[i] = new HammerThread("HammerThread-" + i);        hammers[i].start();    }        Thread.sleep(5000);    bang = false;    for (int i = 0; i < hammers.length; i++) {        hammers[i].interrupt();        verifyThreadTerminated(hammers[i], 60000);    }        qb.verifyRootOfAllServersMatch(qb.hostPort);    tearDown();}
processResult
public void zookeeper_f5788_0(int rc, String path, Object ctx, String name)
{    synchronized (ctx) {        ((LinkedList<Integer>) ctx).add(rc);        ctx.notifyAll();    }}
processResult
public void zookeeper_f5789_0(int rc, String path, Object ctx)
{    synchronized (ctx) {        ((LinkedList<Integer>) ctx).add(rc);        ctx.notifyAll();    }}
processResult
public void zookeeper_f5790_0(int rc, String path, Object ctx, byte[] data, Stat stat)
{    synchronized (ctx) {        ((LinkedList<Integer>) ctx).add(rc);        ctx.notifyAll();    }}
setRC
public void zookeeper_f5791_0(Code rc)
{    this.rc = rc;}
setPath
public void zookeeper_f5792_0(String path)
{    this.path = path;}
processResult
public void zookeeper_f5793_0(Code rc, String path, Object ctx)
{    this.rc = rc;    this.path = path;    this.expected = (String) ctx;    latch.countDown();}
toString
public String zookeeper_f5794_0()
{    return rc + ":" + path + ":";}
verify
protected void zookeeper_f5795_0()
{    try {        latch.await(defaultTimeoutMillis, TimeUnit.MILLISECONDS);    } catch (InterruptedException e) {        fail("unexpected interrupt");    }        assertSame(0L, latch.getCount());    String actual = toString();    assertEquals(expected, actual);}
setPath
public void zookeeper_f5796_0(String path)
{    super.setPath(path);    this.name = path;}
nodeName
public String zookeeper_f5797_0()
{    return path.substring(path.lastIndexOf('/') + 1);}
processResult
public void zookeeper_f5798_0(int rc, String path, Object ctx, String name)
{    this.name = name;    super.processResult(Code.get(rc), path, ctx);}
create
public AsyncCB zookeeper_f5799_0()
{    zk.create(path, data, acl, flags, this, toString());    return this;}
createEphemeral
public AsyncCB zookeeper_f5800_0()
{    zk.create(path, data, acl, CreateMode.EPHEMERAL, this, toString());    return this;}
verifyCreate
public void zookeeper_f5801_0()
{    create();    verify();}
verifyCreateEphemeral
public void zookeeper_f5802_0()
{    createEphemeral();    verify();}
verifyCreateFailure_NodeExists
public void zookeeper_f5803_0()
{    new StringCB(zk).verifyCreate();    rc = Code.NODEEXISTS;    name = null;    zk.create(path, data, acl, flags, this, toString());    verify();}
verifyCreateFailure_NoNode
public void zookeeper_f5804_0()
{    rc = Code.NONODE;    name = null;    path = path + "/bar";    zk.create(path, data, acl, flags, this, toString());    verify();}
verifyCreateFailure_NoChildForEphemeral
public void zookeeper_f5805_0()
{    new StringCB(zk).verifyCreateEphemeral();    rc = Code.NOCHILDRENFOREPHEMERALS;    name = null;    path = path + "/bar";    zk.create(path, data, acl, flags, this, toString());    verify();}
toString
public String zookeeper_f5806_0()
{    return super.toString() + name;}
processResult
public void zookeeper_f5807_0(int rc, String path, Object ctx, List<ACL> acl, Stat stat)
{    this.acl = acl;    this.stat = stat;    super.processResult(Code.get(rc), path, ctx);}
verifyGetACL
public void zookeeper_f5808_0()
{    new StringCB(zk).verifyCreate();    zk.getACL(path, stat, this, toString());    verify();}
verifyGetACLFailure_NoNode
public void zookeeper_f5809_0()
{    rc = Code.NONODE;    stat = null;    acl = null;    zk.getACL(path, stat, this, toString());    verify();}
toString
public String zookeeper_f5810_0(List<ACL> acls)
{    if (acls == null) {        return "";    }    StringBuilder result = new StringBuilder();    for (ACL acl : acls) {        result.append(acl.getPerms()).append("::");    }    return result.toString();}
toString
public String zookeeper_f5811_0()
{    return super.toString() + toString(acl) + ":" + ":" + version + ":" + new String(data) + ":" + (stat == null ? "null" : stat.getAversion() + ":" + stat.getCversion() + ":" + stat.getEphemeralOwner() + ":" + stat.getVersion());}
processResult
public void zookeeper_f5812_0(int rc, String path, Object ctx, List<String> children)
{    this.children = (children == null ? new ArrayList<String>() : children);    Collections.sort(this.children);    super.processResult(Code.get(rc), path, ctx);}
createNode
public StringCB zookeeper_f5813_0()
{    StringCB parent = new StringCB(zk);    parent.verifyCreate();    return parent;}
createNode
public StringCB zookeeper_f5814_0(StringCB parent)
{    String childName = "bar";    return createNode(parent, childName);}
createNode
public StringCB zookeeper_f5815_0(StringCB parent, String childName)
{    StringCB child = new StringCB(zk);    child.setPath(parent.path + "/" + childName);    child.verifyCreate();    return child;}
verifyGetChildrenEmpty
public void zookeeper_f5816_0()
{    StringCB parent = createNode();    path = parent.path;    verify();}
verifyGetChildrenSingle
public void zookeeper_f5817_0()
{    StringCB parent = createNode();    StringCB child = createNode(parent);    path = parent.path;    children.add(child.nodeName());    verify();}
verifyGetChildrenTwo
public void zookeeper_f5818_0()
{    StringCB parent = createNode();    StringCB child1 = createNode(parent, "child1");    StringCB child2 = createNode(parent, "child2");    path = parent.path;    children.add(child1.nodeName());    children.add(child2.nodeName());    verify();}
verifyGetChildrenFailure_NoNode
public void zookeeper_f5819_0()
{    rc = KeeperException.Code.NONODE;    verify();}
verify
public void zookeeper_f5820_0()
{    zk.getChildren(path, false, this, toString());    super.verify();}
toString
public String zookeeper_f5821_0()
{    return super.toString() + children.toString();}
processResult
public void zookeeper_f5822_0(int rc, String path, Object ctx, List<String> children, Stat stat)
{    this.children = (children == null ? new ArrayList<String>() : children);    Collections.sort(this.children);    super.processResult(Code.get(rc), path, ctx);}
createNode
public StringCB zookeeper_f5823_0()
{    StringCB parent = new StringCB(zk);    parent.verifyCreate();    return parent;}
createNode
public StringCB zookeeper_f5824_0(StringCB parent)
{    String childName = "bar";    return createNode(parent, childName);}
createNode
public StringCB zookeeper_f5825_0(StringCB parent, String childName)
{    StringCB child = new StringCB(zk);    child.setPath(parent.path + "/" + childName);    child.verifyCreate();    return child;}
verifyGetChildrenEmpty
public void zookeeper_f5826_0()
{    StringCB parent = createNode();    path = parent.path;    verify();}
verifyGetChildrenSingle
public void zookeeper_f5827_0()
{    StringCB parent = createNode();    StringCB child = createNode(parent);    path = parent.path;    children.add(child.nodeName());    verify();}
verifyGetChildrenTwo
public void zookeeper_f5828_0()
{    StringCB parent = createNode();    StringCB child1 = createNode(parent, "child1");    StringCB child2 = createNode(parent, "child2");    path = parent.path;    children.add(child1.nodeName());    children.add(child2.nodeName());    verify();}
verifyGetChildrenFailure_NoNode
public void zookeeper_f5829_0()
{    rc = KeeperException.Code.NONODE;    verify();}
verify
public void zookeeper_f5830_0()
{    zk.getChildren(path, false, this, toString());    super.verify();}
toString
public String zookeeper_f5831_0()
{    return super.toString() + children.toString();}
setPath
public void zookeeper_f5832_0(String path)
{    super.setPath(path);    this.name = path;}
nodeName
public String zookeeper_f5833_0()
{    return path.substring(path.lastIndexOf('/') + 1);}
processResult
public void zookeeper_f5834_0(int rc, String path, Object ctx, String name, Stat stat)
{    this.name = name;    this.stat = stat;    super.processResult(Code.get(rc), path, ctx);}
create
public AsyncCB zookeeper_f5835_0()
{    zk.create(path, data, acl, flags, this, toString());    return this;}
verifyCreate
public void zookeeper_f5836_0()
{    create();    verify();}
verifyCreateFailure_NodeExists
public void zookeeper_f5837_0()
{    new Create2CB(zk).verifyCreate();    rc = Code.NODEEXISTS;    name = null;    stat = null;    zk.create(path, data, acl, flags, this, toString());    verify();}
verifyCreateFailure_NoNode
public void zookeeper_f5838_0()
{    rc = Code.NONODE;    name = null;    stat = null;    path = path + "/bar";    zk.create(path, data, acl, flags, this, toString());    verify();}
verifyCreateFailure_NoChildForEphemeral
public void zookeeper_f5839_0()
{    new StringCB(zk).verifyCreateEphemeral();    rc = Code.NOCHILDRENFOREPHEMERALS;    name = null;    stat = null;    path = path + "/bar";    zk.create(path, data, acl, flags, this, toString());    verify();}
toString
public String zookeeper_f5840_0()
{    return super.toString() + name + ":" + (stat == null ? "null" : stat.getAversion() + ":" + stat.getCversion() + ":" + stat.getEphemeralOwner() + ":" + stat.getVersion());}
processResult
public void zookeeper_f5841_0(int rc, String path, Object ctx, byte[] data, Stat stat)
{    this.data = data;    this.stat = stat;    super.processResult(Code.get(rc), path, ctx);}
verifyGetData
public void zookeeper_f5842_0()
{    new StringCB(zk).verifyCreate();    zk.getData(path, false, this, toString());    verify();}
verifyGetDataFailure_NoNode
public void zookeeper_f5843_0()
{    rc = KeeperException.Code.NONODE;    data = null;    stat = null;    zk.getData(path, false, this, toString());    verify();}
toString
public String zookeeper_f5844_0()
{    return super.toString() + ":" + (data == null ? "null" : new String(data)) + ":" + (stat == null ? "null" : stat.getAversion() + ":" + stat.getCversion() + ":" + stat.getEphemeralOwner() + ":" + stat.getVersion());}
processResult
public void zookeeper_f5845_0(int rc, String path, Object ctx, Stat stat)
{    this.stat = stat;    super.processResult(Code.get(rc), path, ctx);}
verifySetACL
public void zookeeper_f5846_0()
{    stat.setAversion(1);    new StringCB(zk).verifyCreate();    zk.setACL(path, acl, version, this, toString());    verify();}
verifySetACLFailure_NoNode
public void zookeeper_f5847_0()
{    rc = KeeperException.Code.NONODE;    stat = null;    zk.setACL(path, acl, version, this, toString());    verify();}
verifySetACLFailure_BadVersion
public void zookeeper_f5848_0()
{    new StringCB(zk).verifyCreate();    rc = Code.BADVERSION;    stat = null;    zk.setACL(path, acl, version + 1, this, toString());    verify();}
setData
public void zookeeper_f5849_0()
{    zk.setData(path, data, version, this, toString());}
verifySetData
public void zookeeper_f5850_0()
{    stat.setVersion(1);    new StringCB(zk).verifyCreate();    setData();    verify();}
verifySetDataFailure_NoNode
public void zookeeper_f5851_0()
{    rc = KeeperException.Code.NONODE;    stat = null;    zk.setData(path, data, version, this, toString());    verify();}
verifySetDataFailure_BadVersion
public void zookeeper_f5852_0()
{    new StringCB(zk).verifyCreate();    rc = Code.BADVERSION;    stat = null;    zk.setData(path, data, version + 1, this, toString());    verify();}
verifyExists
public void zookeeper_f5853_0()
{    new StringCB(zk).verifyCreate();    zk.exists(path, false, this, toString());    verify();}
verifyExistsFailure_NoNode
public void zookeeper_f5854_0()
{    rc = KeeperException.Code.NONODE;    stat = null;    zk.exists(path, false, this, toString());    verify();}
toString
public String zookeeper_f5855_0()
{    return super.toString() + version + ":" + new String(data) + ":" + (stat == null ? "null" : stat.getAversion() + ":" + stat.getCversion() + ":" + stat.getEphemeralOwner() + ":" + stat.getVersion());}
processResult
public void zookeeper_f5856_0(int rc, String path, Object ctx)
{    super.processResult(Code.get(rc), path, ctx);}
delete
public void zookeeper_f5857_0()
{    zk.delete(path, version, this, toString());}
verifyDelete
public void zookeeper_f5858_0()
{    new StringCB(zk).verifyCreate();    delete();    verify();}
verifyDeleteFailure_NoNode
public void zookeeper_f5859_0()
{    rc = Code.NONODE;    zk.delete(path, version, this, toString());    verify();}
verifyDeleteFailure_BadVersion
public void zookeeper_f5860_0()
{    new StringCB(zk).verifyCreate();    rc = Code.BADVERSION;    zk.delete(path, version + 1, this, toString());    verify();}
verifyDeleteFailure_NotEmpty
public void zookeeper_f5861_0()
{    StringCB scb = new StringCB(zk);    scb.create();    scb.setPath(path + "/bar");    scb.create();    rc = Code.NOTEMPTY;    zk.delete(path, version, this, toString());    verify();}
sync
public void zookeeper_f5862_0()
{    zk.sync(path, this, toString());}
verifySync
public void zookeeper_f5863_0()
{    sync();    verify();}
toString
public String zookeeper_f5864_0()
{    return super.toString() + version;}
processResult
public void zookeeper_f5865_0(int rc, String path, Object ctx, List<OpResult> opResults)
{    this.rc = rc;    this.opResults = opResults;    latch.countDown();}
latch_await
 void zookeeper_f5866_0()
{    try {        latch.await(10000, TimeUnit.MILLISECONDS);    } catch (InterruptedException e) {        fail("unexpected interrupt");    }    assertSame(0L, latch.getCount());}
verifyMulti
public void zookeeper_f5867_0()
{    List<Op> ops = Arrays.asList(Op.create("/multi", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT), Op.delete("/multi", -1));    zk.multi(ops, this, null);    latch_await();    assertEquals(this.rc, KeeperException.Code.OK.intValue());    assertTrue(this.opResults.get(0) instanceof OpResult.CreateResult);    assertTrue(this.opResults.get(1) instanceof OpResult.DeleteResult);}
verifyMultiFailure_AllErrorResult
public void zookeeper_f5868_0()
{    List<Op> ops = Arrays.asList(Op.create("/multi", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT), Op.delete("/nonexist1", -1), Op.setData("/multi", "test".getBytes(), -1));    zk.multi(ops, this, null);    latch_await();    assertTrue(this.opResults.get(0) instanceof OpResult.ErrorResult);    assertTrue(this.opResults.get(1) instanceof OpResult.ErrorResult);    assertTrue(this.opResults.get(2) instanceof OpResult.ErrorResult);}
verifyMultiFailure_NoSideEffect
public void zookeeper_f5869_0() throws KeeperException, InterruptedException
{    List<Op> ops = Arrays.asList(Op.create("/multi", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT), Op.delete("/nonexist1", -1));    zk.multi(ops, this, null);    latch_await();    assertTrue(this.opResults.get(0) instanceof OpResult.ErrorResult);    assertNull(zk.exists("/multi", false));}
verifyMultiSequential_NoSideEffect
public void zookeeper_f5870_0() throws Exception
{    StringCB scb = new StringCB(zk);    scb.verifyCreate();    String path = scb.path + "-";    String seqPath = path + "0000000002";    zk.create(path, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);    assertNotNull(zk.exists(path + "0000000001", false));    List<Op> ops = Arrays.asList(Op.create(path, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL), Op.delete("/nonexist", -1));    zk.multi(ops, this, null);    latch_await();    assertNull(zk.exists(seqPath, false));    zk.create(path, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);    assertNotNull(zk.exists(seqPath, false));}
setUp
public voidf5871_1) throws Exception
{    super.setUp();        zk = createClient();    zk.addAuthInfo("digest", "ben:passwd".getBytes());}
tearDown
public voidf5872_1) throws Exception
{    zk.close();    super.tearDown();    }
testAsyncCreate
public void zookeeper_f5873_0()
{    new StringCB(zk).verifyCreate();}
testAsyncCreate2
public void zookeeper_f5874_0()
{    new Create2CB(zk).verifyCreate();}
testAsyncCreateThree
public void zookeeper_f5875_0()
{    CountDownLatch latch = new CountDownLatch(3);    StringCB op1 = new StringCB(zk, latch);    op1.setPath("/op1");    StringCB op2 = new StringCB(zk, latch);    op2.setPath("/op2");    StringCB op3 = new StringCB(zk, latch);    op3.setPath("/op3");    op1.create();    op2.create();    op3.create();    op1.verify();    op2.verify();    op3.verify();}
testAsyncCreateFailure_NodeExists
public void zookeeper_f5876_0()
{    new StringCB(zk).verifyCreateFailure_NodeExists();}
testAsyncCreateFailure_NoNode
public void zookeeper_f5877_0()
{    new StringCB(zk).verifyCreateFailure_NoNode();}
testAsyncCreateFailure_NoChildForEphemeral
public void zookeeper_f5878_0()
{    new StringCB(zk).verifyCreateFailure_NoChildForEphemeral();}
testAsyncCreate2Failure_NodeExists
public void zookeeper_f5879_0()
{    new Create2CB(zk).verifyCreateFailure_NodeExists();}
testAsyncCreate2Failure_NoNode
public void zookeeper_f5880_0()
{    new Create2CB(zk).verifyCreateFailure_NoNode();}
testAsyncCreate2Failure_NoChildForEphemeral
public void zookeeper_f5881_0()
{    new Create2CB(zk).verifyCreateFailure_NoChildForEphemeral();}
testAsyncDelete
public void zookeeper_f5882_0()
{    new VoidCB(zk).verifyDelete();}
testAsyncDeleteFailure_NoNode
public void zookeeper_f5883_0()
{    new VoidCB(zk).verifyDeleteFailure_NoNode();}
testAsyncDeleteFailure_BadVersion
public void zookeeper_f5884_0()
{    new VoidCB(zk).verifyDeleteFailure_BadVersion();}
testAsyncDeleteFailure_NotEmpty
public void zookeeper_f5885_0()
{    new VoidCB(zk).verifyDeleteFailure_NotEmpty();}
testAsyncSync
public void zookeeper_f5886_0()
{    new VoidCB(zk).verifySync();}
testAsyncSetACL
public void zookeeper_f5887_0()
{    new StatCB(zk).verifySetACL();}
testAsyncSetACLFailure_NoNode
public void zookeeper_f5888_0()
{    new StatCB(zk).verifySetACLFailure_NoNode();}
testAsyncSetACLFailure_BadVersion
public void zookeeper_f5889_0()
{    new StatCB(zk).verifySetACLFailure_BadVersion();}
testAsyncSetData
public void zookeeper_f5890_0()
{    new StatCB(zk).verifySetData();}
testAsyncSetDataFailure_NoNode
public void zookeeper_f5891_0()
{    new StatCB(zk).verifySetDataFailure_NoNode();}
testAsyncSetDataFailure_BadVersion
public void zookeeper_f5892_0()
{    new StatCB(zk).verifySetDataFailure_BadVersion();}
testAsyncExists
public void zookeeper_f5893_0()
{    new StatCB(zk).verifyExists();}
testAsyncExistsFailure_NoNode
public void zookeeper_f5894_0()
{    new StatCB(zk).verifyExistsFailure_NoNode();}
testAsyncGetACL
public void zookeeper_f5895_0()
{    new ACLCB(zk).verifyGetACL();}
testAsyncGetACLFailure_NoNode
public void zookeeper_f5896_0()
{    new ACLCB(zk).verifyGetACLFailure_NoNode();}
testAsyncGetChildrenEmpty
public void zookeeper_f5897_0()
{    new ChildrenCB(zk).verifyGetChildrenEmpty();}
testAsyncGetChildrenSingle
public void zookeeper_f5898_0()
{    new ChildrenCB(zk).verifyGetChildrenSingle();}
testAsyncGetChildrenTwo
public void zookeeper_f5899_0()
{    new ChildrenCB(zk).verifyGetChildrenTwo();}
testAsyncGetChildrenFailure_NoNode
public void zookeeper_f5900_0()
{    new ChildrenCB(zk).verifyGetChildrenFailure_NoNode();}
testAsyncGetChildren2Empty
public void zookeeper_f5901_0()
{    new Children2CB(zk).verifyGetChildrenEmpty();}
testAsyncGetChildren2Single
public void zookeeper_f5902_0()
{    new Children2CB(zk).verifyGetChildrenSingle();}
testAsyncGetChildren2Two
public void zookeeper_f5903_0()
{    new Children2CB(zk).verifyGetChildrenTwo();}
testAsyncGetChildren2Failure_NoNode
public void zookeeper_f5904_0()
{    new Children2CB(zk).verifyGetChildrenFailure_NoNode();}
testAsyncGetData
public void zookeeper_f5905_0()
{    new DataCB(zk).verifyGetData();}
testAsyncGetDataFailure_NoNode
public void zookeeper_f5906_0()
{    new DataCB(zk).verifyGetDataFailure_NoNode();}
testAsyncMulti
public void zookeeper_f5907_0()
{    new MultiCB(zk).verifyMulti();}
testAsyncMultiFailure_AllErrorResult
public void zookeeper_f5908_0()
{    new MultiCB(zk).verifyMultiFailure_AllErrorResult();}
testAsyncMultiFailure_NoSideEffect
public void zookeeper_f5909_0() throws Exception
{    new MultiCB(zk).verifyMultiFailure_NoSideEffect();}
testAsyncMultiSequential_NoSideEffect
public void zookeeper_f5910_0() throws Exception
{    new MultiCB(zk).verifyMultiSequential_NoSideEffect();}
setUp
public void zookeeper_f5911_0() throws Exception
{    qb.setUp();}
tearDown
public voidf5912_1) throws Exception
{        qb.tearDown();}
createClient
private ZooKeeper zookeeper_f5913_0() throws Exception
{    return createClient(qb.hostPort);}
createClient
private ZooKeeper zookeeper_f5914_0(String hp) throws Exception
{    ZooKeeper zk = ClientBase.createZKClient(hp);    return zk;}
testAsync
public void zookeeper_f5915_0() throws Exception
{    ZooKeeper zk = null;    zk = createClient();    try {        zk.addAuthInfo("digest", "ben:passwd".getBytes());        zk.create("/ben", new byte[0], Ids.READ_ACL_UNSAFE, CreateMode.PERSISTENT, this, results);        zk.create("/ben/2", new byte[0], Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT, this, results);        zk.delete("/ben", -1, this, results);        zk.create("/ben2", new byte[0], Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT, this, results);        zk.getData("/ben2", false, this, results);        synchronized (results) {            while (results.size() < 5) {                results.wait();            }        }        assertEquals(0, (int) results.get(0));        assertEquals(Code.NOAUTH, Code.get(results.get(1)));        assertEquals(0, (int) results.get(2));        assertEquals(0, (int) results.get(3));        assertEquals(0, (int) results.get(4));    } finally {        zk.close();    }    zk = createClient();    try {        zk.addAuthInfo("digest", "ben:passwd2".getBytes());        try {            zk.getData("/ben2", false, new Stat());            fail("Should have received a permission error");        } catch (KeeperException e) {            assertEquals(Code.NOAUTH, e.code());        }    } finally {        zk.close();    }    zk = createClient();    try {        zk.addAuthInfo("digest", "ben:passwd".getBytes());        zk.getData("/ben2", false, new Stat());    } finally {        zk.close();    }}
processResult
public void zookeeper_f5916_0(int rc, String path, Object ctx, String name)
{    synchronized (ctx) {        ((LinkedList<Integer>) ctx).add(rc);        ctx.notifyAll();    }}
processResult
public void zookeeper_f5917_0(int rc, String path, Object ctx)
{    synchronized (ctx) {        ((LinkedList<Integer>) ctx).add(rc);        ctx.notifyAll();    }}
processResult
public void zookeeper_f5918_0(int rc, String path, Object ctx, byte[] data, Stat stat)
{    synchronized (ctx) {        ((LinkedList<Integer>) ctx).add(rc);        ctx.notifyAll();    }}
setupTestDir
public void zookeeper_f5919_0() throws IOException
{    testDir = ClientBase.createEmptyTestDir();    dstFile = new File(testDir, "test.txt");}
cleanupTestDir
public void zookeeper_f5920_0() throws IOException
{    ClientBase.recursiveDelete(testDir);}
testWriteNewFile
public void zookeeper_f5921_0() throws IOException
{    OutputStream fos = new AtomicFileOutputStream(dstFile);    assertFalse(dstFile.exists());    fos.write(TEST_STRING.getBytes());    fos.flush();    assertFalse(dstFile.exists());    fos.close();    assertTrue(dstFile.exists());    String readBackData = ClientBase.readFile(dstFile);    assertEquals(TEST_STRING, readBackData);}
testOverwriteFile
public void zookeeper_f5922_0() throws IOException
{    assertTrue("Creating empty dst file", dstFile.createNewFile());    OutputStream fos = new AtomicFileOutputStream(dstFile);    assertTrue("Empty file still exists", dstFile.exists());    fos.write(TEST_STRING.getBytes());    fos.flush();        assertEquals("", ClientBase.readFile(dstFile));    fos.close();        String readBackData = ClientBase.readFile(dstFile);    assertEquals(TEST_STRING, readBackData);}
testFailToFlush
public void zookeeper_f5923_0() throws IOException
{        FileOutputStream fos = new FileOutputStream(dstFile);    fos.write(TEST_STRING_2.getBytes());    fos.close();    OutputStream failingStream = createFailingStream();    failingStream.write(TEST_STRING.getBytes());    try {        failingStream.close();        fail("Close didn't throw exception");    } catch (IOException ioe) {        }        assertEquals(TEST_STRING_2, ClientBase.readFile(dstFile));    assertEquals("Temporary file should have been cleaned up", dstFile.getName(), ClientBase.join(",", testDir.list()));}
createFailingStream
private OutputStream zookeeper_f5924_0() throws FileNotFoundException
{    return new AtomicFileOutputStream(dstFile) {        @Override        public void flush() throws IOException {            throw new IOException("injected failure");        }    };}
flush
public void zookeeper_f5925_0() throws IOException
{    throw new IOException("injected failure");}
testAbortNewFile
public void zookeeper_f5926_0() throws IOException
{    AtomicFileOutputStream fos = new AtomicFileOutputStream(dstFile);    fos.abort();    assertEquals(0, testDir.list().length);}
testAbortNewFileAfterFlush
public void zookeeper_f5927_0() throws IOException
{    AtomicFileOutputStream fos = new AtomicFileOutputStream(dstFile);    fos.write(TEST_STRING.getBytes());    fos.flush();    fos.abort();    assertEquals(0, testDir.list().length);}
testAbortExistingFile
public void zookeeper_f5928_0() throws IOException
{    FileOutputStream fos1 = new FileOutputStream(dstFile);    fos1.write(TEST_STRING.getBytes());    fos1.close();    AtomicFileOutputStream fos2 = new AtomicFileOutputStream(dstFile);    fos2.abort();        assertEquals(TEST_STRING, ClientBase.readFile(dstFile));    assertEquals(1, testDir.list().length);}
testAbortExistingFileAfterFlush
public void zookeeper_f5929_0() throws IOException
{    FileOutputStream fos1 = new FileOutputStream(dstFile);    fos1.write(TEST_STRING.getBytes());    fos1.close();    AtomicFileOutputStream fos2 = new AtomicFileOutputStream(dstFile);    fos2.write(TEST_STRING_2.getBytes());    fos2.flush();    fos2.abort();        assertEquals(TEST_STRING, ClientBase.readFile(dstFile));    assertEquals(1, testDir.list().length);}
createClient
protected TestableZooKeeper zookeeper_f5930_0(String hp) throws IOException, InterruptedException
{    MyWatcher watcher = new MyWatcher();    return createClient(watcher, hp);}
process
public synchronized void zookeeper_f5931_0(WatchedEvent event)
{    if (event.getState() == KeeperState.AuthFailed) {        authFailed.countDown();    } else {        super.process(event);    }}
testBadAuthNotifiesWatch
public void zookeeper_f5932_0() throws Exception
{    ZooKeeper zk = createClient();    try {        zk.addAuthInfo("FOO", "BAR".getBytes());        zk.getData("/path1", false, null);        fail("Should get auth state error");    } catch (KeeperException.AuthFailedException e) {        if (!authFailed.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS)) {            fail("Should have called my watcher");        }    } finally {        zk.close();    }}
testBadAuthThenSendOtherCommands
public void zookeeper_f5933_0() throws Exception
{    ZooKeeper zk = createClient();    try {        zk.addAuthInfo("INVALID", "BAR".getBytes());        zk.exists("/foobar", false);        zk.getData("/path1", false, null);        fail("Should get auth state error");    } catch (KeeperException.AuthFailedException e) {        if (!authFailed.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS)) {            fail("Should have called my watcher");        }    } finally {        zk.close();    }}
testSuper
public void zookeeper_f5934_0() throws Exception
{    ZooKeeper zk = createClient();    try {        zk.addAuthInfo("digest", "pat:pass".getBytes());        zk.create("/path1", null, Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT);        zk.close();                zk = createClient();        try {            zk.getData("/path1", false, null);            fail("auth verification");        } catch (KeeperException.NoAuthException e) {                }        zk.close();                zk = createClient();        zk.addAuthInfo("digest", "pat:pass2".getBytes());        try {            zk.getData("/path1", false, null);            fail("auth verification");        } catch (KeeperException.NoAuthException e) {                }        zk.close();                zk = createClient();        zk.addAuthInfo("digest", "super:test2".getBytes());        try {            zk.getData("/path1", false, null);            fail("auth verification");        } catch (KeeperException.NoAuthException e) {                }        zk.close();                zk = createClient();        zk.addAuthInfo("digest", "super:test".getBytes());        zk.getData("/path1", false, null);    } finally {        zk.close();    }}
testSuperACL
public void zookeeper_f5935_0() throws Exception
{    ZooKeeper zk = createClient();    try {        zk.addAuthInfo("digest", "pat:pass".getBytes());        zk.create("/path1", null, Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT);        zk.close();                zk = createClient();        zk.addAuthInfo("digest", "super:test".getBytes());        zk.getData("/path1", false, null);        zk.setACL("/path1", Ids.READ_ACL_UNSAFE, -1);        zk.create("/path1/foo", null, Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT);        zk.setACL("/path1", Ids.OPEN_ACL_UNSAFE, -1);    } finally {        zk.close();    }}
setMaxBuffer
public void zookeeper_f5936_0() throws IOException, InterruptedException
{    System.setProperty("jute.maxbuffer", "" + TEST_MAXBUFFER);    assertEquals("Can't set jute.maxbuffer!", TEST_MAXBUFFER, BinaryInputArchive.maxBuffer);    zk = createClient();}
testCreatesReqs
public void zookeeper_f5937_0() throws Exception
{    testRequests(new ClientOp() {        @Override        public void execute(byte[] data) throws Exception {            zk.create("/create_test", data, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);        }    });}
execute
public void zookeeper_f5938_0(byte[] data) throws Exception
{    zk.create("/create_test", data, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);}
testSetReqs
public void zookeeper_f5939_0() throws Exception
{    final String path = "/set_test";    zk.create(path, new byte[1], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    testRequests(new ClientOp() {        @Override        public void execute(byte[] data) throws Exception {            zk.setData(path, data, -1);        }    });}
execute
public void zookeeper_f5940_0(byte[] data) throws Exception
{    zk.setData(path, data, -1);}
testRequests
private void zookeeper_f5941_0(ClientOp clientOp) throws Exception
{    clientOp.execute(new byte[TEST_MAXBUFFER - 60]);    try {                clientOp.execute(new byte[TEST_MAXBUFFER]);        fail("Request exceeding jute.maxbuffer succeeded!");    } catch (KeeperException.ConnectionLossException e) {    }    try {        clientOp.execute(new byte[TEST_MAXBUFFER + 10]);        fail("Request exceeding jute.maxbuffer succeeded!");    } catch (KeeperException.ConnectionLossException e) {    }}
testStartup
public void zookeeper_f5942_0() throws Exception
{    final String path = "/test_node";    zk.create(path, new byte[TEST_MAXBUFFER - 60], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.setData(path, new byte[TEST_MAXBUFFER - 50], -1);    stopServer();    startServer();}
testStartupFailureCreate
public void zookeeper_f5943_0() throws Exception
{        testStartupFailure(new File(TEST_DATA, "create"), "Server started despite create exceeding jute.maxbuffer!");}
testStartupFailureSet
public void zookeeper_f5944_0() throws Exception
{        testStartupFailure(new File(TEST_DATA, "set"), "Server started despite set exceeding jute.maxbuffer!");}
testStartupFailureSnapshot
public void zookeeper_f5945_0() throws Exception
{        testStartupFailure(new File(TEST_DATA, "snapshot"), "Server started despite znode exceeding jute.maxbuffer!");}
testStartupFailure
private voidf5946_1File testDir, String failureMsg) throws Exception
{    stopServer();        File oldTmpDir = tmpDir;    tmpDir = testDir;    try {        startServer();        fail(failureMsg);    } catch (IOException e) {            } finally {        tmpDir = oldTmpDir;    }}
setUp
public voidf5947_1) throws Exception
{    String hp = hostPort;    hostPort = hostPort + "/chrootasynctest";    super.setUp();        ZooKeeper zk = createClient(hp);    try {        zk.create("/chrootasynctest", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    } finally {        zk.close();    }}
setUp
public voidf5948_1) throws Exception
{    String hp = hostPort;    hostPort = hostPort + "/chrootclienttest";    System.out.println(hostPort);    super.setUp();        ZooKeeper zk = createClient(hp);    try {        zk.create("/chrootclienttest", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    } finally {        zk.close();    }}
testPing
public void zookeeper_f5949_0() throws Exception
{}
process
public void zookeeper_f5950_0(WatchedEvent event)
{    System.out.println("latch:" + path + " " + event.getPath());    this.eventPath = event.getPath();    latch.countDown();}
matches
public boolean zookeeper_f5951_0() throws InterruptedException
{    if (!latch.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS)) {        fail("No watch received within timeout period " + path);    }    return path.equals(eventPath);}
testChrootSynchronous
public void zookeeper_f5952_0() throws IOException, InterruptedException, KeeperException
{    ZooKeeper zk1 = createClient();    try {        zk1.create("/ch1", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    } finally {        if (zk1 != null) {            zk1.close();        }    }    ZooKeeper zk2 = createClient(hostPort + "/ch1");    try {        assertEquals("/ch2", zk2.create("/ch2", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT));    } finally {        if (zk2 != null) {            zk2.close();        }    }    zk1 = createClient();    zk2 = createClient(hostPort + "/ch1");    try {                MyWatcher w1 = new MyWatcher("/ch1");        assertNotNull(zk1.exists("/ch1", w1));        MyWatcher w2 = new MyWatcher("/ch1/ch2");        assertNotNull(zk1.exists("/ch1/ch2", w2));        MyWatcher w3 = new MyWatcher("/ch2");        assertNotNull(zk2.exists("/ch2", w3));                MyWatcher w4 = new MyWatcher("/ch1");        zk1.getChildren("/ch1", w4);        MyWatcher w5 = new MyWatcher("/");        zk2.getChildren("/", w5);                zk1.setData("/ch1", "1".getBytes(), -1);        zk2.setData("/ch2", "2".getBytes(), -1);                assertTrue(w1.matches());        assertTrue(w2.matches());        assertTrue(w3.matches());                try {            zk2.setData("/ch3", "3".getBytes(), -1);        } catch (KeeperException.NoNodeException e) {            assertEquals("/ch3", e.getPath());        }        assertTrue(Arrays.equals("1".getBytes(), zk1.getData("/ch1", false, null)));        assertTrue(Arrays.equals("2".getBytes(), zk1.getData("/ch1/ch2", false, null)));        assertTrue(Arrays.equals("2".getBytes(), zk2.getData("/ch2", false, null)));                zk2.delete("/ch2", -1);        assertTrue(w4.matches());        assertTrue(w5.matches());        zk1.delete("/ch1", -1);        assertNull(zk1.exists("/ch1", false));        assertNull(zk1.exists("/ch1/ch2", false));        assertNull(zk2.exists("/ch2", false));    } finally {        if (zk1 != null) {            zk1.close();        }        if (zk2 != null) {            zk2.close();        }    }}
reset
public synchronized void zookeeper_f5953_0()
{    clientConnected = new CountDownLatch(1);    connected = false;    syncConnected = false;    readOnlyConnected = false;}
process
public synchronized void zookeeper_f5954_0(WatchedEvent event)
{    KeeperState state = event.getState();    if (state == KeeperState.SyncConnected) {        connected = true;        syncConnected = true;        readOnlyConnected = false;    } else if (state == KeeperState.ConnectedReadOnly) {        connected = true;        syncConnected = false;        readOnlyConnected = true;    } else {        connected = false;        syncConnected = false;        readOnlyConnected = false;    }    notifyAll();    if (connected) {        clientConnected.countDown();    }}
isConnected
public synchronized boolean zookeeper_f5955_0()
{    return connected;}
waitForConnected
public synchronized void zookeeper_f5956_0(long timeout) throws InterruptedException, TimeoutException
{    long expire = Time.currentElapsedTime() + timeout;    long left = timeout;    while (!connected && left > 0) {        wait(left);        left = expire - Time.currentElapsedTime();    }    if (!connected) {        throw new TimeoutException("Failed to connect to ZooKeeper server.");    }}
waitForSyncConnected
public synchronized void zookeeper_f5957_0(long timeout) throws InterruptedException, TimeoutException
{    long expire = Time.currentElapsedTime() + timeout;    long left = timeout;    while (!syncConnected && left > 0) {        wait(left);        left = expire - Time.currentElapsedTime();    }    if (!syncConnected) {        throw new TimeoutException("Failed to connect to read-write ZooKeeper server.");    }}
waitForReadOnlyConnected
public synchronized void zookeeper_f5958_0(long timeout) throws InterruptedException, TimeoutException
{    long expire = System.currentTimeMillis() + timeout;    long left = timeout;    while (!readOnlyConnected && left > 0) {        wait(left);        left = expire - System.currentTimeMillis();    }    if (!readOnlyConnected) {        throw new TimeoutException("Failed to connect in read-only mode to ZooKeeper server.");    }}
waitForDisconnected
public synchronized void zookeeper_f5959_0(long timeout) throws InterruptedException, TimeoutException
{    long expire = Time.currentElapsedTime() + timeout;    long left = timeout;    while (connected && left > 0) {        wait(left);        left = expire - Time.currentElapsedTime();    }    if (connected) {        throw new TimeoutException("Did not disconnect");    }}
createClient
protected TestableZooKeeper zookeeper_f5960_0() throws IOException, InterruptedException
{    return createClient(hostPort);}
createClient
protected TestableZooKeeper zookeeper_f5961_0(String hp) throws IOException, InterruptedException
{    CountdownWatcher watcher = new CountdownWatcher();    return createClient(watcher, hp);}
createClient
protected TestableZooKeeper zookeeper_f5962_0(CountdownWatcher watcher) throws IOException, InterruptedException
{    return createClient(watcher, hostPort);}
createClient
protected TestableZooKeeper zookeeper_f5963_0(CountdownWatcher watcher, String hp) throws IOException, InterruptedException
{    return createClient(watcher, hp, CONNECTION_TIMEOUT);}
createClient
protected TestableZooKeeperf5964_1CountdownWatcher watcher, String hp, int timeout) throws IOException, InterruptedException
{    watcher.reset();    TestableZooKeeper zk = new TestableZooKeeper(hp, timeout, watcher);    if (!watcher.clientConnected.await(timeout, TimeUnit.MILLISECONDS)) {        if (exceptionOnFailedConnect) {            throw new ProtocolException("Unable to connect to server");        }        fail("Unable to connect to server");    }    synchronized (this) {        if (!allClientsSetup) {                        fail("allClients never setup");        }        if (allClients != null) {            allClients.add(zk);            JMXEnv.ensureAll(getHexSessionId(zk.getSessionId()));        } else {                        zk.close();        }    }    return zk;}
parseHostPortList
public static List<HostPort> zookeeper_f5965_0(String hplist)
{    ArrayList<HostPort> alist = new ArrayList<HostPort>();    for (String hp : hplist.split(",")) {        int idx = hp.lastIndexOf(':');        String host = hp.substring(0, idx);        int port;        try {            port = Integer.parseInt(hp.substring(idx + 1));        } catch (RuntimeException e) {            throw new RuntimeException("Problem parsing " + hp + e.toString());        }        alist.add(new HostPort(host, port));    }    return alist;}
waitForServerUp
public static boolean zookeeper_f5966_0(String hp, long timeout)
{    return waitForServerUp(hp, timeout, false);}
waitForServerUp
public static booleanf5967_1String hp, long timeout, boolean secure)
{    long start = Time.currentElapsedTime();    while (true) {        try {                        HostPort hpobj = parseHostPortList(hp).get(0);            String result = send4LetterWord(hpobj.host, hpobj.port, "stat", secure);            if (result.startsWith("Zookeeper version:") && !result.contains("READ-ONLY")) {                return true;            }        } catch (ConnectException e) {                                } catch (IOException e) {                                } catch (SSLContextException e) {                    }        if (Time.currentElapsedTime() > start + timeout) {            break;        }        try {            Thread.sleep(250);        } catch (InterruptedException e) {                }    }    return false;}
waitForServerDown
public static boolean zookeeper_f5968_0(String hp, long timeout)
{    return waitForServerDown(hp, timeout, false);}
waitForServerDown
public static boolean zookeeper_f5969_0(String hp, long timeout, boolean secure)
{    long start = Time.currentElapsedTime();    while (true) {        try {            HostPort hpobj = parseHostPortList(hp).get(0);            send4LetterWord(hpobj.host, hpobj.port, "stat", secure);        } catch (IOException e) {            return true;        } catch (SSLContextException e) {            return true;        }        if (Time.currentElapsedTime() > start + timeout) {            break;        }        try {            Thread.sleep(250);        } catch (InterruptedException e) {                }    }    return false;}
waitForServerState
public static boolean zookeeper_f5970_0(QuorumPeer qp, int timeout, String... serverStates)
{    long start = Time.currentElapsedTime();    while (true) {        try {            Thread.sleep(250);        } catch (InterruptedException e) {                }        for (String state : serverStates) {            if (qp.getServerState().equals(state)) {                return true;            }        }        if (Time.currentElapsedTime() > start + timeout) {            return false;        }    }}
verifyThreadTerminated
 static voidf5971_1Thread thread, long millis) throws InterruptedException
{    thread.join(millis);    if (thread.isAlive()) {                assertFalse("thread " + thread.getName() + " still alive after join", true);    }}
createEmptyTestDir
public static File zookeeper_f5972_0() throws IOException
{    return createTmpDir(BASETEST, false);}
createTmpDir
public static File zookeeper_f5973_0() throws IOException
{    return createTmpDir(BASETEST, true);}
createTmpDir
 static File zookeeper_f5974_0(File parentDir, boolean createInitFile) throws IOException
{    File tmpFile = File.createTempFile("test", ".junit", parentDir);            File tmpDir = new File(tmpFile + ".dir");        assertFalse(tmpDir.exists());    assertTrue(tmpDir.mkdirs());        if (createInitFile) {        createInitializeFile(tmpDir);    }    return tmpDir;}
createInitializeFile
public static void zookeeper_f5975_0(File dir) throws IOException
{    File initFile = new File(dir, "initialize");    if (!initFile.exists()) {        assertTrue(initFile.createNewFile());    }}
getPort
private static int zookeeper_f5976_0(String hostPort)
{    String[] split = hostPort.split(":");    String portstr = split[split.length - 1];    String[] pc = portstr.split("/");    if (pc.length > 1) {        portstr = pc[0];    }    return Integer.parseInt(portstr);}
startServerInstance
public static voidf5977_1File dataDir, ServerCnxnFactory factory, String hostPort, int serverId) throws IOException, InterruptedException
{    final int port = getPort(hostPort);        ZooKeeperServer zks = new ZooKeeperServer(dataDir, dataDir, 3000);    zks.setCreateSessionTrackerServerId(serverId);    factory.startup(zks);    assertTrue("waiting for server up", ClientBase.waitForServerUp("127.0.0.1:" + port, CONNECTION_TIMEOUT, factory.isSecure()));}
createNewServerInstance
public static ServerCnxnFactoryf5978_1ServerCnxnFactory factory, String hostPort, int maxCnxns) throws IOException, InterruptedException
{    final int port = getPort(hostPort);        if (factory == null) {        factory = ServerCnxnFactory.createFactory(port, maxCnxns);    }    return factory;}
shutdownServerInstance
 static voidf5979_1ServerCnxnFactory factory, String hostPort)
{    if (factory != null) {        ZKDatabase zkDb = null;        {            ZooKeeperServer zs = factory.getZooKeeperServer();            if (zs != null) {                zkDb = zs.getZKDatabase();            }        }        factory.shutdown();        try {            if (zkDb != null) {                zkDb.close();            }        } catch (IOException ie) {                    }        final int PORT = getPort(hostPort);        assertTrue("waiting for server down", ClientBase.waitForServerDown("127.0.0.1:" + PORT, CONNECTION_TIMEOUT, factory.isSecure()));    }}
setupTestEnv
public static void zookeeper_f5980_0()
{                    System.setProperty("zookeeper.preAllocSize", "100");    FilePadding.setPreallocSize(100 * 1024);}
setUpAll
protected void zookeeper_f5981_0() throws Exception
{    allClients = new LinkedList<ZooKeeper>();    allClientsSetup = true;}
setUp
public void zookeeper_f5982_0() throws Exception
{    setUpWithServerId(1);}
setUpWithServerId
protected voidf5983_1int serverId) throws Exception
{    /* some useful information - log the number of fds used before         * and after a test is run. Helps to verify we are freeing resources         * correctly. Unfortunately this only works on unix systems (the         * only place sun has implemented as part of the mgmt bean api.         */    OSMXBean osMbean = new OSMXBean();    if (osMbean.getUnix()) {        initialFdCount = osMbean.getOpenFileDescriptorCount();            }    setupTestEnv();    setupCustomizedEnv();    JMXEnv.setUp();    setUpAll();    tmpDir = createTmpDir(BASETEST, true);    startServer(serverId);    }
startServer
protected void zookeeper_f5984_0() throws Exception
{    startServer(1);}
setupCustomizedEnv
public void zookeeper_f5985_0()
{/* do nothing by default */}
startServer
private voidf5986_1int serverId) throws Exception
{        serverFactory = createNewServerInstance(serverFactory, hostPort, maxCnxns);    startServerInstance(tmpDir, serverFactory, hostPort, serverId);        Set<ObjectName> children = JMXEnv.ensureParent("InMemoryDataTree", "StandaloneServer_port");                    verifyUnexpectedBeans(children);}
verifyUnexpectedBeans
private voidf5987_1Set<ObjectName> children)
{    if (allClients != null) {        for (ZooKeeper zkc : allClients) {            Iterator<ObjectName> childItr = children.iterator();            while (childItr.hasNext()) {                ObjectName clientBean = childItr.next();                if (clientBean.toString().contains(getHexSessionId(zkc.getSessionId()))) {                                        childItr.remove();                }            }        }    }    for (ObjectName bean : children) {            }    assertEquals("Unexpected bean exists!", 0, children.size());}
getHexSessionId
protected static String zookeeper_f5988_0(long sessionId)
{    return "0x" + Long.toHexString(sessionId);}
stopServer
protected voidf5989_1) throws Exception
{        shutdownServerInstance(serverFactory, hostPort);    serverFactory = null;        JMXEnv.ensureOnly();}
tearDownAll
protected voidf5990_1) throws Exception
{    synchronized (this) {        if (allClients != null) {            for (ZooKeeper zk : allClients) {                try {                    if (zk != null) {                        zk.close();                    }                } catch (InterruptedException e) {                                    }            }        }        allClients = null;    }}
tearDown
public voidf5991_1) throws Exception
{        tearDownAll();    stopServer();    if (tmpDir != null) {        assertTrue("delete " + tmpDir.toString(), recursiveDelete(tmpDir));    }        serverFactory = null;    JMXEnv.tearDown();    /* some useful information - log the number of fds used before         * and after a test is run. Helps to verify we are freeing resources         * correctly. Unfortunately this only works on unix systems (the         * only place sun has implemented as part of the mgmt bean api.         */    OSMXBean osMbean = new OSMXBean();    if (osMbean.getUnix()) {        long fdCount = osMbean.getOpenFileDescriptorCount();        String message = "fdcount after test is: " + fdCount + " at start it was " + initialFdCount;                if (fdCount > initialFdCount) {                                    }    }    cleanUpCustomizedEnv();}
cleanUpCustomizedEnv
public void zookeeper_f5992_0()
{/* do nothing by default */}
jmxConn
public static MBeanServerConnection zookeeper_f5993_0() throws IOException
{    return JMXEnv.conn();}
recursiveDelete
public static boolean zookeeper_f5994_0(File d)
{    return TestUtils.deleteFileRecursively(d, true);}
logAllStackTraces
public static voidf5995_1)
{    StringBuilder sb = new StringBuilder();    sb.append("Starting logAllStackTraces()\n");    Map<Thread, StackTraceElement[]> threads = Thread.getAllStackTraces();    for (Entry<Thread, StackTraceElement[]> e : threads.entrySet()) {        sb.append("Thread " + e.getKey().getName() + "\n");        for (StackTraceElement elem : e.getValue()) {            sb.append("\tat " + elem + "\n");        }    }    sb.append("Ending logAllStackTraces()\n");    }
verifyRootOfAllServersMatch
 voidf5996_1String hostPort) throws InterruptedException, KeeperException, IOException
{    String[] parts = hostPort.split(",");            int[] counts = new int[parts.length];    int failed = 0;    for (int j = 0; j < 100; j++) {        int[] newcounts = new int[parts.length];        int i = 0;        for (String hp : parts) {            try {                ZooKeeper zk = createClient(hp);                try {                    newcounts[i++] = zk.getChildren("/", false).size();                } finally {                    zk.close();                }            } catch (Throwable t) {                failed++;                                                logAllStackTraces();            }        }        if (Arrays.equals(newcounts, counts)) {                        counts = newcounts;            break;        } else {            counts = newcounts;            Thread.sleep(10000);        }                if (failed > 10) {            break;        }    }        String logmsg = "node count not consistent{} {}";    for (int i = 1; i < parts.length; i++) {        if (counts[i - 1] != counts[i]) {                    } else {                    }    }}
readFile
public static String zookeeper_f5997_0(File file) throws IOException
{    ByteArrayOutputStream os = new ByteArrayOutputStream();    BufferedInputStream is = new BufferedInputStream(new FileInputStream(file));    try {        IOUtils.copyBytes(is, os, 1024, true);    } finally {        is.close();    }    return os.toString();}
join
public static String zookeeper_f5998_0(String separator, Object[] parts)
{    StringBuilder sb = new StringBuilder();    boolean first = true;    for (Object part : parts) {        if (!first) {            sb.append(separator);            first = false;        }        sb.append(part);    }    return sb.toString();}
createZKClient
public static ZooKeeper zookeeper_f5999_0(String cxnString) throws Exception
{    return createZKClient(cxnString, CONNECTION_TIMEOUT);}
createZKClient
public static ZooKeeper zookeeper_f6000_0(String cxnString, int sessionTimeout) throws IOException
{    CountdownWatcher watcher = new CountdownWatcher();    ZooKeeper zk = new ZooKeeper(cxnString, sessionTimeout, watcher);    try {        watcher.waitForConnected(CONNECTION_TIMEOUT);    } catch (InterruptedException | TimeoutException e) {        fail("ZooKeeper client can not connect to " + cxnString);    }    return zk;}
run
public voidf6001_1)
{    byte[] b = new byte[256];    try {        for (; current < count; current++) {                        Thread.sleep(HAMMERTHREAD_LATENCY);            zk.create(prefix + current, b, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        }    } catch (Throwable t) {            } finally {        try {            zk.close();        } catch (InterruptedException e) {                    }    }}
run
public voidf6002_1)
{    byte[] b = new byte[256];    try {        for (; current < count; current++) {            ZooKeeper zk = parent.createClient();            try {                zk.create(prefix + current, b, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);            } finally {                try {                    zk.close();                } catch (InterruptedException e) {                                    }            }        }    } catch (Throwable t) {            }}
testHammerBasic
public void zookeeper_f6003_0() throws Throwable
{    runHammer(10, 1000);}
runHammer
public voidf6004_1final int threadCount, final int childCount) throws Throwable
{    try {        HammerThread[] threads = new HammerThread[threadCount];        long start = Time.currentElapsedTime();        for (int i = 0; i < threads.length; i++) {            ZooKeeper zk = createClient();            String prefix = "/test-" + i;            zk.create(prefix, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);            prefix += "/";            HammerThread thread = new BasicHammerThread("BasicHammerThread-" + i, zk, prefix, childCount);            thread.start();            threads[i] = thread;        }        verifyHammer(start, threads, childCount);    } catch (Throwable t) {                throw t;    }}
testHammerSuper
public voidf6005_1) throws Throwable
{    try {        final int threadCount = 5;        final int childCount = 10;        HammerThread[] threads = new HammerThread[threadCount];        long start = Time.currentElapsedTime();        for (int i = 0; i < threads.length; i++) {            String prefix = "/test-" + i;            {                ZooKeeper zk = createClient();                try {                    zk.create(prefix, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);                } finally {                    zk.close();                }            }            prefix += "/";            HammerThread thread = new SuperHammerThread("SuperHammerThread-" + i, this, prefix, childCount);            thread.start();            threads[i] = thread;        }        verifyHammer(start, threads, childCount);    } catch (Throwable t) {                throw t;    }}
verifyHammer
public voidf6006_1long start, HammerThread[] threads, int childCount) throws IOException, InterruptedException, KeeperException
{            int workingCount = threads.length;    for (int i = 0; i < 120; i++) {        Thread.sleep(10000);        for (HammerThread h : threads) {            if (!h.isAlive() || h.current == h.count) {                workingCount--;            }        }        if (workingCount == 0) {            break;        }        workingCount = threads.length;    }    if (workingCount > 0) {        for (HammerThread h : threads) {                    }    } else {            }    for (HammerThread h : threads) {        final int safetyFactor = 3;        verifyThreadTerminated(h, (long) threads.length * (long) childCount * HAMMERTHREAD_LATENCY * (long) safetyFactor);    }        ZooKeeper zk = createClient();    try {                for (int i = 0; i < threads.length; i++) {                        List<String> children = zk.getChildren("/test-" + i, false);            assertEquals(childCount, children.size());            children = zk.getChildren("/test-" + i, false, null);            assertEquals(childCount, children.size());        }        for (int i = 0; i < threads.length; i++) {            List<String> children = zk.getChildren("/test-" + i, false);            assertEquals(childCount, children.size());            children = zk.getChildren("/test-" + i, false, null);            assertEquals(childCount, children.size());        }    } finally {        zk.close();    }}
testBindByAddress
public voidf6007_1) throws Exception
{    String bindAddress = null;    Enumeration<NetworkInterface> intfs = NetworkInterface.getNetworkInterfaces();        while (intfs.hasMoreElements()) {        NetworkInterface i = intfs.nextElement();        try {            if (i.isLoopback()) {                Enumeration<InetAddress> addrs = i.getInetAddresses();                while (addrs.hasMoreElements()) {                    InetAddress a = addrs.nextElement();                    if (a.isLoopbackAddress()) {                        bindAddress = a.getHostAddress();                        if (a instanceof Inet6Address) {                            bindAddress = "[" + bindAddress + "]";                        }                        break;                    }                }            }        } catch (SocketException se) {                    }    }    if (bindAddress == null) {                return;    }    final int PORT = PortAssignment.unique();        final String HOSTPORT = bindAddress + ":" + PORT;        File tmpDir = ClientBase.createTmpDir();    ClientBase.setupTestEnv();    ZooKeeperServer zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);    ServerCnxnFactory f = ServerCnxnFactory.createFactory(new InetSocketAddress(bindAddress, PORT), -1);    f.startup(zks);        assertTrue("waiting for server up", ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT));    ZooKeeper zk = ClientBase.createZKClient(HOSTPORT);    try {        zk.close();    } finally {        f.shutdown();        zks.shutdown();        assertTrue("waiting for server down", ClientBase.waitForServerDown(HOSTPORT, CONNECTION_TIMEOUT));    }}
setUp
public void zookeeper_f6008_0() throws Exception
{    maxCnxns = 1;    super.setUp();}
testClientRetry
public void zookeeper_f6009_0() throws IOException, InterruptedException, TimeoutException
{    CountdownWatcher cdw1 = new CountdownWatcher();    CountdownWatcher cdw2 = new CountdownWatcher();    ZooKeeper zk = new ZooKeeper(hostPort, 10000, cdw1);    try {        cdw1.waitForConnected(CONNECTION_TIMEOUT);        ZooKeeper zk2 = new ZooKeeper(hostPort, 10000, cdw2);        try {            States s1 = zk.getState();            States s2 = zk2.getState();            assertSame(s1, States.CONNECTED);            assertSame(s2, States.CONNECTING);            cdw1.reset();            zk.close();            cdw1.waitForDisconnected(CONNECTION_TIMEOUT);            cdw2.waitForConnected(CONNECTION_TIMEOUT);            assertSame(zk2.getState(), States.CONNECTED);        } finally {            zk2.close();        }    } finally {        zk.close();    }}
setup
public static void zookeeper_f6010_0()
{    System.setProperty("zookeeper.skipACL", "yes");}
teardown
public static void zookeeper_f6011_0()
{    System.clearProperty("zookeeper.skipACL");}
setup
public void zookeeper_f6012_0()
{    System.setProperty(NettyServerCnxnFactory.PORT_UNIFICATION_KEY, Boolean.TRUE.toString());    clientX509Util = new ClientX509Util();    String testDataPath = System.getProperty("test.data.dir", "src/test/resources/data");    System.setProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY, "org.apache.zookeeper.server.NettyServerCnxnFactory");    System.setProperty(ZKClientConfig.ZOOKEEPER_CLIENT_CNXN_SOCKET, "org.apache.zookeeper.ClientCnxnSocketNetty");    System.setProperty(ZKClientConfig.SECURE_CLIENT, "true");    System.setProperty(clientX509Util.getSslKeystoreLocationProperty(), testDataPath + "/ssl/testKeyStore.jks");    System.setProperty(clientX509Util.getSslKeystorePasswdProperty(), "testpass");    System.setProperty(clientX509Util.getSslTruststoreLocationProperty(), testDataPath + "/ssl/testTrustStore.jks");    System.setProperty(clientX509Util.getSslTruststorePasswdProperty(), "testpass");}
teardown
public void zookeeper_f6013_0()
{    System.clearProperty(NettyServerCnxnFactory.PORT_UNIFICATION_KEY);    System.clearProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY);    System.clearProperty(ZKClientConfig.ZOOKEEPER_CLIENT_CNXN_SOCKET);    System.clearProperty(ZKClientConfig.SECURE_CLIENT);    System.clearProperty(clientX509Util.getSslKeystoreLocationProperty());    System.clearProperty(clientX509Util.getSslKeystorePasswdProperty());    System.clearProperty(clientX509Util.getSslTruststoreLocationProperty());    System.clearProperty(clientX509Util.getSslTruststorePasswdProperty());    clientX509Util.close();}
testClientServerUnifiedPort
public void zookeeper_f6014_0() throws Exception
{    testClientServerSSL(false);}
testClientServerSSL
public void zookeeper_f6015_0() throws Exception
{    testClientServerSSL(true);}
testClientServerSSL
public void zookeeper_f6016_0(boolean useSecurePort) throws Exception
{    final int SERVER_COUNT = 3;    final int[] clientPorts = new int[SERVER_COUNT];    final Integer[] secureClientPorts = new Integer[SERVER_COUNT];    StringBuilder sb = new StringBuilder();    for (int i = 0; i < SERVER_COUNT; i++) {        clientPorts[i] = PortAssignment.unique();        secureClientPorts[i] = PortAssignment.unique();        String server = String.format("server.%d=127.0.0.1:%d:%d:participant;127.0.0.1:%d%n", i, PortAssignment.unique(), PortAssignment.unique(), clientPorts[i]);        sb.append(server);    }    String quorumCfg = sb.toString();    MainThread[] mt = new MainThread[SERVER_COUNT];    for (int i = 0; i < SERVER_COUNT; i++) {        if (useSecurePort) {            mt[i] = new MainThread(i, quorumCfg, secureClientPorts[i], true);        } else {            mt[i] = new MainThread(i, quorumCfg, true);        }        mt[i].start();    }            ClientBase.waitForServerUp("127.0.0.1:" + clientPorts[0], 2 * TIMEOUT);        for (int i = 0; i < SERVER_COUNT; i++) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts[i], TIMEOUT));        final int port = useSecurePort ? secureClientPorts[i] : clientPorts[i];        ZooKeeper zk = ClientBase.createZKClient("127.0.0.1:" + port, TIMEOUT);                zk.create("/test", "".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        zk.delete("/test", -1);        zk.close();    }    for (int i = 0; i < mt.length; i++) {        mt[i].shutdown();    }}
testSecureStandaloneServer
public void zookeeper_f6017_0() throws Exception
{    Integer secureClientPort = PortAssignment.unique();    MainThread mt = new MainThread(MainThread.UNSET_MYID, "", secureClientPort, false);    mt.start();    ZooKeeper zk = ClientBase.createZKClient("127.0.0.1:" + secureClientPort, TIMEOUT);    zk.create("/test", "".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.delete("/test", -1);    zk.close();    mt.shutdown();}
testPing
public void zookeeper_f6018_0() throws Exception
{    ZooKeeper zkIdle = null;    ZooKeeper zkWatchCreator = null;    try {        CountdownWatcher watcher = new CountdownWatcher();        zkIdle = createClient(watcher, hostPort, 10000);        zkWatchCreator = createClient();        for (int i = 0; i < 10; i++) {            zkWatchCreator.create("/" + i, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        }        for (int i = 0; i < 10; i++) {            zkIdle.exists("/" + i, true);        }        for (int i = 0; i < 10; i++) {            Thread.sleep(1000);            zkWatchCreator.delete("/" + i, -1);        }                zkIdle.exists("/0", false);    } finally {        if (zkIdle != null) {            zkIdle.close();        }        if (zkWatchCreator != null) {            zkWatchCreator.close();        }    }}
testClientwithoutWatcherObj
public void zookeeper_f6019_0() throws IOException, InterruptedException, KeeperException
{    performClientTest(false);}
testClientWithWatcherObj
public void zookeeper_f6020_0() throws IOException, InterruptedException, KeeperException
{    performClientTest(true);}
testTestability
public voidf6021_1) throws Exception
{    TestableZooKeeper zk = createClient();    try {                            } finally {        zk.close(CONNECTION_TIMEOUT);                            }}
testACLs
public voidf6022_1) throws Exception
{    ZooKeeper zk = null;    try {        zk = createClient();        try {            zk.create("/acltest", new byte[0], Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT);            fail("Should have received an invalid acl error");        } catch (InvalidACLException e) {                    }        try {            ArrayList<ACL> testACL = new ArrayList<ACL>();            testACL.add(new ACL(Perms.ALL | Perms.ADMIN, Ids.AUTH_IDS));            testACL.add(new ACL(Perms.ALL | Perms.ADMIN, new Id("ip", "127.0.0.1/8")));            zk.create("/acltest", new byte[0], testACL, CreateMode.PERSISTENT);            fail("Should have received an invalid acl error");        } catch (InvalidACLException e) {                    }        try {            ArrayList<ACL> testACL = new ArrayList<ACL>();            testACL.add(new ACL(Perms.ALL | Perms.ADMIN, new Id()));            zk.create("/nullidtest", new byte[0], testACL, CreateMode.PERSISTENT);            fail("Should have received an invalid acl error");        } catch (InvalidACLException e) {                    }        zk.addAuthInfo("digest", "ben:passwd".getBytes());        ArrayList<ACL> testACL = new ArrayList<ACL>();        testACL.add(new ACL(Perms.ALL, new Id("auth", "")));        testACL.add(new ACL(Perms.WRITE, new Id("ip", "127.0.0.1")));        zk.create("/acltest", new byte[0], testACL, CreateMode.PERSISTENT);        zk.close();        zk = createClient();        zk.addAuthInfo("digest", "ben:passwd2".getBytes());        if (skipACL) {            try {                zk.getData("/acltest", false, null);            } catch (KeeperException e) {                fail("Badauth reads should succeed with skipACL.");            }        } else {            try {                zk.getData("/acltest", false, null);                fail("Should have received a permission error");            } catch (KeeperException e) {                assertEquals(Code.NOAUTH, e.code());            }        }        zk.addAuthInfo("digest", "ben:passwd".getBytes());        zk.getData("/acltest", false, null);        zk.setACL("/acltest", Ids.OPEN_ACL_UNSAFE, -1);        zk.close();        zk = createClient();        zk.getData("/acltest", false, null);        List<ACL> acls = zk.getACL("/acltest", new Stat());        assertEquals(1, acls.size());        assertEquals(Ids.OPEN_ACL_UNSAFE, acls);                acls = zk.getACL("/acltest", null);        assertEquals(1, acls.size());        assertEquals(Ids.OPEN_ACL_UNSAFE, acls);        zk.close();    } finally {        if (zk != null) {            zk.close();        }    }}
testNullAuthId
public void zookeeper_f6023_0() throws Exception
{    ZooKeeper zk = null;    try {        zk = createClient();        zk.addAuthInfo("digest", "ben:passwd".getBytes());        ArrayList<ACL> testACL = new ArrayList<ACL>();        testACL.add(new ACL(Perms.ALL, new Id("auth", null)));        zk.create("/acltest", new byte[0], testACL, CreateMode.PERSISTENT);        zk.close();        zk = createClient();        zk.addAuthInfo("digest", "ben:passwd2".getBytes());        if (skipACL) {            try {                zk.getData("/acltest", false, null);            } catch (KeeperException e) {                fail("Badauth reads should succeed with skipACL.");            }        } else {            try {                zk.getData("/acltest", false, null);                fail("Should have received a permission error");            } catch (KeeperException e) {                assertEquals(Code.NOAUTH, e.code());            }        }        zk.addAuthInfo("digest", "ben:passwd".getBytes());        zk.getData("/acltest", false, null);        zk.setACL("/acltest", Ids.OPEN_ACL_UNSAFE, -1);        zk.close();        zk = createClient();        zk.getData("/acltest", false, null);        List<ACL> acls = zk.getACL("/acltest", new Stat());        assertEquals(1, acls.size());        assertEquals(Ids.OPEN_ACL_UNSAFE, acls);    } finally {        if (zk != null) {            zk.close();        }    }}
process
public voidf6024_1WatchedEvent event)
{    super.process(event);    if (event.getType() != EventType.None) {        try {            events.put(event);        } catch (InterruptedException e) {                    }    }}
testMutipleWatcherObjs
public void zookeeper_f6025_0() throws IOException, InterruptedException, KeeperException
{    ZooKeeper zk = createClient(new CountdownWatcher(), hostPort);    try {        MyWatcher[] watchers = new MyWatcher[100];        MyWatcher[] watchers2 = new MyWatcher[watchers.length];        for (int i = 0; i < watchers.length; i++) {            watchers[i] = new MyWatcher();            watchers2[i] = new MyWatcher();            zk.create("/foo-" + i, ("foodata" + i).getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        }        Stat stat = new Stat();                for (int i = 0; i < watchers.length; i++) {            assertNotNull(zk.getData("/foo-" + i, watchers[i], stat));        }        for (int i = 0; i < watchers.length; i++) {            assertNotNull(zk.exists("/foo-" + i, watchers[i]));        }                for (int i = 0; i < watchers.length; i++) {            zk.setData("/foo-" + i, ("foodata2-" + i).getBytes(), -1);            zk.setData("/foo-" + i, ("foodata3-" + i).getBytes(), -1);        }        for (int i = 0; i < watchers.length; i++) {            WatchedEvent event = watchers[i].events.poll(10, TimeUnit.SECONDS);            assertEquals("/foo-" + i, event.getPath());            assertEquals(EventType.NodeDataChanged, event.getType());            assertEquals(KeeperState.SyncConnected, event.getState());                                                assertEquals(0, watchers[i].events.size());        }                for (int i = 0; i < watchers.length; i++) {            assertNotNull(zk.getData("/foo-" + i, watchers[i], stat));            assertNotNull(zk.exists("/foo-" + i, watchers[i]));        }                for (int i = 0; i < watchers.length; i++) {            zk.setData("/foo-" + i, ("foodata4-" + i).getBytes(), -1);            zk.setData("/foo-" + i, ("foodata5-" + i).getBytes(), -1);        }        for (int i = 0; i < watchers.length; i++) {            WatchedEvent event = watchers[i].events.poll(10, TimeUnit.SECONDS);            assertEquals("/foo-" + i, event.getPath());            assertEquals(EventType.NodeDataChanged, event.getType());            assertEquals(KeeperState.SyncConnected, event.getState());                                                assertEquals(0, watchers[i].events.size());        }                for (int i = 0; i < watchers.length; i++) {            assertNotNull(zk.getData("/foo-" + i, watchers[i], stat));            assertNotNull(zk.exists("/foo-" + i, watchers2[i]));        }                for (int i = 0; i < watchers.length; i++) {            zk.setData("/foo-" + i, ("foodata6-" + i).getBytes(), -1);            zk.setData("/foo-" + i, ("foodata7-" + i).getBytes(), -1);        }        for (int i = 0; i < watchers.length; i++) {            WatchedEvent event = watchers[i].events.poll(10, TimeUnit.SECONDS);            assertEquals("/foo-" + i, event.getPath());            assertEquals(EventType.NodeDataChanged, event.getType());            assertEquals(KeeperState.SyncConnected, event.getState());                                                assertEquals(0, watchers[i].events.size());                        WatchedEvent event2 = watchers2[i].events.poll(10, TimeUnit.SECONDS);            assertEquals("/foo-" + i, event2.getPath());            assertEquals(EventType.NodeDataChanged, event2.getType());            assertEquals(KeeperState.SyncConnected, event2.getState());                                                assertEquals(0, watchers2[i].events.size());        }    } finally {        if (zk != null) {            zk.close();        }    }}
performClientTest
private voidf6026_1boolean withWatcherObj) throws IOException, InterruptedException, KeeperException
{    ZooKeeper zk = null;    try {        MyWatcher watcher = new MyWatcher();        zk = createClient(watcher, hostPort);                zk.create("/benwashere", "".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);                try {            zk.setData("/benwashere", "hi".getBytes(), 57);            fail("Should have gotten BadVersion exception");        } catch (KeeperException.BadVersionException e) {                } catch (KeeperException e) {            fail("Should have gotten BadVersion exception");        }                zk.delete("/benwashere", 0);                zk.close();                Thread.sleep(2000);        zk = createClient(watcher, hostPort);                        try {            zk.delete("/", -1);            fail("deleted root!");        } catch (KeeperException.BadArgumentsException e) {                }        Stat stat = new Stat();                zk.create("/pat", "Pat was here".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);                zk.create("/pat/ben", "Ben was here".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);                List<String> children = zk.getChildren("/pat", false);        assertEquals(1, children.size());        assertEquals("ben", children.get(0));        List<String> children2 = zk.getChildren("/pat", false, null);        assertEquals(children, children2);        String value = new String(zk.getData("/pat/ben", false, stat));        assertEquals("Ben was here", value);        try {            if (withWatcherObj) {                assertEquals(null, zk.exists("/frog", watcher));            } else {                assertEquals(null, zk.exists("/frog", true));            }                    } catch (KeeperException.NoNodeException e) {                }        zk.create("/frog", "hi".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);                        WatchedEvent event = watcher.events.poll(10, TimeUnit.SECONDS);        assertEquals("/frog", event.getPath());        assertEquals(EventType.NodeCreated, event.getType());        assertEquals(KeeperState.SyncConnected, event.getState());                zk.getChildren("/pat/ben", true);        for (int i = 0; i < 10; i++) {            zk.create("/pat/ben/" + i + "-", Integer.toString(i).getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);        }        children = zk.getChildren("/pat/ben", false);        Collections.sort(children);        assertEquals(10, children.size());        for (int i = 0; i < 10; i++) {            final String name = children.get(i);            assertTrue("starts with -", name.startsWith(i + "-"));            byte[] b;            if (withWatcherObj) {                b = zk.getData("/pat/ben/" + name, watcher, stat);            } else {                b = zk.getData("/pat/ben/" + name, true, stat);            }            assertEquals(Integer.toString(i), new String(b));            zk.setData("/pat/ben/" + name, "new".getBytes(), stat.getVersion());            if (withWatcherObj) {                stat = zk.exists("/pat/ben/" + name, watcher);            } else {                stat = zk.exists("/pat/ben/" + name, true);            }            zk.delete("/pat/ben/" + name, stat.getVersion());        }        event = watcher.events.poll(10, TimeUnit.SECONDS);        assertEquals("/pat/ben", event.getPath());        assertEquals(EventType.NodeChildrenChanged, event.getType());        assertEquals(KeeperState.SyncConnected, event.getState());        for (int i = 0; i < 10; i++) {            event = watcher.events.poll(10, TimeUnit.SECONDS);            final String name = children.get(i);            assertEquals("/pat/ben/" + name, event.getPath());            assertEquals(EventType.NodeDataChanged, event.getType());            assertEquals(KeeperState.SyncConnected, event.getState());            event = watcher.events.poll(10, TimeUnit.SECONDS);            assertEquals("/pat/ben/" + name, event.getPath());            assertEquals(EventType.NodeDeleted, event.getType());            assertEquals(KeeperState.SyncConnected, event.getState());        }        zk.create("/good\u0040path", "".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        zk.create("/duplicate", "".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        try {            zk.create("/duplicate", "".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);            fail("duplicate create allowed");        } catch (KeeperException.NodeExistsException e) {                }    } finally {        if (zk != null) {            zk.close();        }    }}
testSequentialNodeNames
public void zookeeper_f6027_0() throws IOException, InterruptedException, KeeperException
{    String path = "/SEQUENCE";    String file = "TEST";    String filepath = path + "/" + file;    ZooKeeper zk = null;    try {        zk = createClient();        zk.create(path, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        zk.create(filepath, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);        List<String> children = zk.getChildren(path, false);        assertEquals(1, children.size());        assertEquals(file + "0000000000", children.get(0));        zk.create(filepath, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);        children = zk.getChildren(path, false);        assertEquals(2, children.size());        assertTrue("contains child 1", children.contains(file + "0000000001"));        zk.create(filepath, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);        children = zk.getChildren(path, false);        assertEquals(3, children.size());        assertTrue("contains child 2", children.contains(file + "0000000002"));                for (int i = children.size(); i < 105; i++) {            zk.create(filepath, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);        }        children = zk.getChildren(path, false);        assertTrue("contains child 104", children.contains(file + "0000000104"));    } finally {        if (zk != null) {            zk.close();        }    }}
testSequentialNodeData
public void zookeeper_f6028_0() throws Exception
{    ZooKeeper zk = null;    String queue_handle = "/queue";    try {        zk = createClient();        zk.create(queue_handle, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        zk.create(queue_handle + "/element", "0".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);        zk.create(queue_handle + "/element", "1".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);        List<String> children = zk.getChildren(queue_handle, true);        assertEquals(children.size(), 2);        String child1 = children.get(0);        String child2 = children.get(1);        int compareResult = child1.compareTo(child2);        assertNotSame(compareResult, 0);        if (compareResult < 0) {        } else {            String temp = child1;            child1 = child2;            child2 = temp;        }        String child1data = new String(zk.getData(queue_handle + "/" + child1, false, null));        String child2data = new String(zk.getData(queue_handle + "/" + child2, false, null));        assertEquals(child1data, "0");        assertEquals(child2data, "1");    } finally {        if (zk != null) {            zk.close();        }    }}
testLargeNodeData
public void zookeeper_f6029_0() throws Exception
{    ZooKeeper zk = null;    String queue_handle = "/large";    try {        zk = createClient();        zk.create(queue_handle, new byte[500000], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    } finally {        if (zk != null) {            zk.close();        }    }}
verifyCreateFails
private void zookeeper_f6030_0(String path, ZooKeeper zk) throws Exception
{    try {        zk.create(path, null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    } catch (IllegalArgumentException e) {                return;    }    fail("bad path \"" + path + "\" not caught");}
testPathValidation
public void zookeeper_f6031_0() throws Exception
{    ZooKeeper zk = createClient();    verifyCreateFails(null, zk);    verifyCreateFails("", zk);    verifyCreateFails("//", zk);    verifyCreateFails("///", zk);    verifyCreateFails("////", zk);    verifyCreateFails("/.", zk);    verifyCreateFails("/..", zk);    verifyCreateFails("/./", zk);    verifyCreateFails("/../", zk);    verifyCreateFails("/foo/./", zk);    verifyCreateFails("/foo/../", zk);    verifyCreateFails("/foo/.", zk);    verifyCreateFails("/foo/..", zk);    verifyCreateFails("/./.", zk);    verifyCreateFails("/../..", zk);    verifyCreateFails("/\u0001foo", zk);    verifyCreateFails("/foo/bar/", zk);    verifyCreateFails("/foo//bar", zk);    verifyCreateFails("/foo/bar//", zk);    verifyCreateFails("foo", zk);    verifyCreateFails("a", zk);    zk.create("/createseqpar", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        try {        zk.create("/createseqpar/", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        assertTrue(false);    } catch (IllegalArgumentException be) {        }        zk.create("/createseqpar/", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);    zk.create("/createseqpar/.", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);    zk.create("/createseqpar/..", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);    try {        zk.create("/createseqpar//", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);        assertTrue(false);    } catch (IllegalArgumentException be) {        }    try {        zk.create("/createseqpar/./", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);        assertTrue(false);    } catch (IllegalArgumentException be) {        }    try {        zk.create("/createseqpar/../", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);        assertTrue(false);    } catch (IllegalArgumentException be) {        }        PrepRequestProcessor.setFailCreate(true);    try {        zk.create("/m", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        assertTrue(false);    } catch (KeeperException.BadArgumentsException be) {        }    PrepRequestProcessor.setFailCreate(false);    zk.create("/.foo", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/.f.", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/..f", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/..f..", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/f.c", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/f\u0040f", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/f", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/f/.f", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/f/f.", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/f/..f", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/f/f..", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/f/.f/f", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/f/f./f", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);}
testDeleteWithChildren
public void zookeeper_f6032_0() throws Exception
{    ZooKeeper zk = createClient();    zk.create("/parent", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/parent/child", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    try {        zk.delete("/parent", -1);        fail("Should have received a not equals message");    } catch (KeeperException e) {        assertEquals(KeeperException.Code.NOTEMPTY, e.code());    }    zk.delete("/parent/child", -1);    zk.delete("/parent", -1);    zk.close();}
run
public voidf6033_1)
{    try {        for (; current < count; current++) {            TestableZooKeeper zk = createClient();                                                zk.close(CONNECTION_TIMEOUT);        }    } catch (Throwable t) {            }}
testClientCleanup
public voidf6034_1) throws Throwable
{    OSMXBean osMbean = new OSMXBean();    if (!osMbean.getUnix()) {                return;    }    final int threadCount = 3;    final int clientCount = 10;    /* Log the number of fds used before and after a test is run. Verifies         * we are freeing resources correctly. Unfortunately this only works         * on unix systems (the only place sun has implemented as part of the         * mgmt bean api).         */    long initialFdCount = osMbean.getOpenFileDescriptorCount();    VerifyClientCleanup[] threads = new VerifyClientCleanup[threadCount];    for (int i = 0; i < threads.length; i++) {        threads[i] = new VerifyClientCleanup("VCC" + i, clientCount);        threads[i].start();    }    for (int i = 0; i < threads.length; i++) {        threads[i].join(CONNECTION_TIMEOUT);        assertTrue(threads[i].current == threads[i].count);    }            long currentCount = osMbean.getOpenFileDescriptorCount();    final String logmsg = "open fds after test ({}) are not significantly higher than before ({})";    if (currentCount > initialFdCount + 10) {                    } else {            }}
testNonExistingOpCode
public void zookeeper_f6035_0() throws Exception
{    final CountDownLatch clientDisconnected = new CountDownLatch(1);    Watcher watcher = new Watcher() {        @Override        public synchronized void process(WatchedEvent event) {            if (event.getState() == KeeperState.Disconnected) {                clientDisconnected.countDown();            }        }    };    TestableZooKeeper zk = new TestableZooKeeper(hostPort, CONNECTION_TIMEOUT, watcher);    final String path = "/m1";    RequestHeader h = new RequestHeader();        h.setType(888);    ExistsRequest request = new ExistsRequest();    request.setPath(path);    request.setWatch(false);    ExistsResponse response = new ExistsResponse();    ReplyHeader r = zk.submitRequest(h, request, response, null);    assertEquals(r.getErr(), Code.UNIMPLEMENTED.intValue());        assertTrue("failed to disconnect", clientDisconnected.await(5000, TimeUnit.MILLISECONDS));    zk.close();}
process
public synchronized void zookeeper_f6036_0(WatchedEvent event)
{    if (event.getState() == KeeperState.Disconnected) {        clientDisconnected.countDown();    }}
testTryWithResources
public void zookeeper_f6037_0() throws Exception
{    ZooKeeper zooKeeper;    try (ZooKeeper zk = createClient()) {        zooKeeper = zk;        assertTrue(zooKeeper.getState().isAlive());    }    assertFalse(zooKeeper.getState().isAlive());}
testCXidRollover
public void zookeeper_f6038_0() throws Exception
{    TestableZooKeeper zk = null;    try {        zk = createClient();        zk.setXid(Integer.MAX_VALUE - 10);        zk.create("/testnode", "".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        for (int i = 0; i < 20; ++i) {            final CountDownLatch latch = new CountDownLatch(1);            final AtomicInteger rc = new AtomicInteger(0);            zk.setData("/testnode", "".getBytes(), -1, new AsyncCallback.StatCallback() {                @Override                public void processResult(int retcode, String path, Object ctx, Stat stat) {                    rc.set(retcode);                    latch.countDown();                }            }, null);            assertTrue("setData should complete within 5s", latch.await(zk.getSessionTimeout(), TimeUnit.MILLISECONDS));            assertEquals("setData should have succeeded", Code.OK.intValue(), rc.get());        }        zk.delete("/testnode", -1);        assertTrue("xid should be positive", zk.checkXid() > 0);    } finally {        if (zk != null) {            zk.close();        }    }}
processResult
public void zookeeper_f6039_0(int retcode, String path, Object ctx, Stat stat)
{    rc.set(retcode);    latch.countDown();}
testSingleServerChrootPath
public void zookeeper_f6040_0()
{    String chrootPath = "/hallo/welt";    String servers = "10.10.10.1";    assertChrootPath(chrootPath, new ConnectStringParser(servers + chrootPath));    servers = "[2001:db8:1::242:ac11:2]";    assertChrootPath(chrootPath, new ConnectStringParser(servers + chrootPath));}
testMultipleServersChrootPath
public void zookeeper_f6041_0()
{    String chrootPath = "/hallo/welt";    String servers = "10.10.10.1,10.10.10.2";    assertChrootPath(chrootPath, new ConnectStringParser(servers + chrootPath));    servers = "[2001:db8:1::242:ac11:2]:2181,[2001:db8:85a3:8d3:1319:8a2e:370:7348]:5678";    assertChrootPath(chrootPath, new ConnectStringParser(servers + chrootPath));}
testParseServersWithoutPort
public void zookeeper_f6042_0()
{    String servers = "10.10.10.1,10.10.10.2";    ConnectStringParser parser = new ConnectStringParser(servers);    assertEquals("10.10.10.1", parser.getServerAddresses().get(0).getHostString());    assertEquals(DEFAULT_PORT, parser.getServerAddresses().get(0).getPort());    assertEquals("10.10.10.2", parser.getServerAddresses().get(1).getHostString());    assertEquals(DEFAULT_PORT, parser.getServerAddresses().get(1).getPort());    servers = "[2001:db8:1::242:ac11:2],[2001:db8:85a3:8d3:1319:8a2e:370:7348]";    parser = new ConnectStringParser(servers);    assertEquals("2001:db8:1::242:ac11:2", parser.getServerAddresses().get(0).getHostString());    assertEquals(DEFAULT_PORT, parser.getServerAddresses().get(0).getPort());    assertEquals("2001:db8:85a3:8d3:1319:8a2e:370:7348", parser.getServerAddresses().get(1).getHostString());    assertEquals(DEFAULT_PORT, parser.getServerAddresses().get(1).getPort());}
testParseServersWithPort
public void zookeeper_f6043_0()
{    String servers = "10.10.10.1:112,10.10.10.2:110";    ConnectStringParser parser = new ConnectStringParser(servers);    assertEquals("10.10.10.1", parser.getServerAddresses().get(0).getHostString());    assertEquals("10.10.10.2", parser.getServerAddresses().get(1).getHostString());    assertEquals(112, parser.getServerAddresses().get(0).getPort());    assertEquals(110, parser.getServerAddresses().get(1).getPort());    servers = "[2001:db8:1::242:ac11:2]:1234,[2001:db8:85a3:8d3:1319:8a2e:370:7348]:5678";    parser = new ConnectStringParser(servers);    assertEquals("2001:db8:1::242:ac11:2", parser.getServerAddresses().get(0).getHostString());    assertEquals("2001:db8:85a3:8d3:1319:8a2e:370:7348", parser.getServerAddresses().get(1).getHostString());    assertEquals(1234, parser.getServerAddresses().get(0).getPort());    assertEquals(5678, parser.getServerAddresses().get(1).getPort());}
assertChrootPath
private void zookeeper_f6044_0(String expected, ConnectStringParser parser)
{    assertEquals(expected, parser.getChrootPath());}
testBasicCreateMode
public void zookeeper_f6045_0()
{    CreateMode cm = CreateMode.PERSISTENT;    assertEquals(cm.toFlag(), 0);    assertFalse(cm.isEphemeral());    assertFalse(cm.isSequential());    assertFalse(cm.isContainer());    cm = CreateMode.EPHEMERAL;    assertEquals(cm.toFlag(), 1);    assertTrue(cm.isEphemeral());    assertFalse(cm.isSequential());    assertFalse(cm.isContainer());    cm = CreateMode.PERSISTENT_SEQUENTIAL;    assertEquals(cm.toFlag(), 2);    assertFalse(cm.isEphemeral());    assertTrue(cm.isSequential());    assertFalse(cm.isContainer());    cm = CreateMode.EPHEMERAL_SEQUENTIAL;    assertEquals(cm.toFlag(), 3);    assertTrue(cm.isEphemeral());    assertTrue(cm.isSequential());    assertFalse(cm.isContainer());    cm = CreateMode.CONTAINER;    assertEquals(cm.toFlag(), 4);    assertFalse(cm.isEphemeral());    assertFalse(cm.isSequential());    assertTrue(cm.isContainer());}
testFlagConversion
public void zookeeper_f6046_0() throws KeeperException
{        EnumSet<CreateMode> allModes = EnumSet.allOf(CreateMode.class);    for (CreateMode cm : allModes) {        assertEquals(cm, CreateMode.fromFlag(cm.toFlag()));    }}
testInvalidFlagConversion
public void zookeeper_f6047_0() throws KeeperException
{    try {        CreateMode.fromFlag(99);        fail("Shouldn't be able to convert 99 to a CreateMode.");    } catch (KeeperException ke) {        assertEquals(Code.BADARGUMENTS, ke.code());    }    try {        CreateMode.fromFlag(-1);        fail("Shouldn't be able to convert -1 to a CreateMode.");    } catch (KeeperException ke) {        assertEquals(Code.BADARGUMENTS, ke.code());    }}
setUp
public void zookeeper_f6048_0() throws Exception
{    super.setUp();    zk = createClient();}
tearDown
public void zookeeper_f6049_0() throws Exception
{    super.tearDown();    zk.close();}
testCreate
public void zookeeper_f6050_0() throws IOException, KeeperException, InterruptedException
{    createNoStatVerifyResult("/foo");    createNoStatVerifyResult("/foo/child");}
testCreateWithStat
public void zookeeper_f6051_0() throws IOException, KeeperException, InterruptedException
{    String name = "/foo";    Stat stat = createWithStatVerifyResult("/foo");    Stat childStat = createWithStatVerifyResult("/foo/child");        assertFalse(stat.equals(childStat));}
testCreateWithNullStat
public void zookeeper_f6052_0() throws IOException, KeeperException, InterruptedException
{    String name = "/foo";    assertNull(zk.exists(name, false));    Stat stat = null;            String path = zk.create(name, name.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, stat);    assertNull(stat);    assertNotNull(zk.exists(name, false));}
createNoStatVerifyResult
private void zookeeper_f6053_0(String newName) throws KeeperException, InterruptedException
{    assertNull("Node existed before created", zk.exists(newName, false));    String path = zk.create(newName, newName.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    assertEquals(path, newName);    assertNotNull("Node was not created as expected", zk.exists(newName, false));}
createWithStatVerifyResult
private Stat zookeeper_f6054_0(String newName) throws KeeperException, InterruptedException
{    assertNull("Node existed before created", zk.exists(newName, false));    Stat stat = new Stat();    String path = zk.create(newName, newName.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, stat);    assertEquals(path, newName);    validateCreateStat(stat, newName);    Stat referenceStat = zk.exists(newName, false);    assertNotNull("Node was not created as expected", referenceStat);    assertEquals(referenceStat, stat);    return stat;}
validateCreateStat
private void zookeeper_f6055_0(Stat stat, String name)
{    assertEquals(stat.getCzxid(), stat.getMzxid());    assertEquals(stat.getCzxid(), stat.getPzxid());    assertEquals(stat.getCtime(), stat.getMtime());    assertEquals(0, stat.getCversion());    assertEquals(0, stat.getVersion());    assertEquals(0, stat.getAversion());    assertEquals(0, stat.getEphemeralOwner());    assertEquals(name.length(), stat.getDataLength());    assertEquals(0, stat.getNumChildren());}
disconnect
public void zookeeper_f6056_0() throws IOException
{    cnxn.disconnect();}
dontReconnect
public void zookeeper_f6057_0() throws Exception
{    java.lang.reflect.Field f = cnxn.getClass().getDeclaredField("closing");    f.setAccessible(true);    f.setBoolean(cnxn, true);}
process
public voidf6058_1WatchedEvent event)
{    super.process(event);    if (event.getType() != Event.EventType.None) {        try {            events.put(event);        } catch (InterruptedException e) {                    }    }}
setUp
public void zookeeper_f6059_0() throws Exception
{    super.setUp();    watcher1 = new CountdownWatcher();    zk1 = createClient(watcher1);    watcher2 = new MyWatcher();}
tearDown
public void zookeeper_f6060_0() throws Exception
{    if (zk2 != null) {        zk2.close();    }    if (zk1 != null) {        zk1.close();    }    super.tearDown();}
testChildWatcherAutoResetWithChroot
public void zookeeper_f6061_0() throws Exception
{    zk1.create("/ch1", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk2 = createClient(watcher2, hostPort + "/ch1");    zk2.getChildren("/", true);        zk1.create("/youdontmatter1", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        zk1.create("/ch1/youshouldmatter1", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    WatchedEvent e = watcher2.events.poll(TIMEOUT, TimeUnit.MILLISECONDS);    assertNotNull(e);    assertEquals(EventType.NodeChildrenChanged, e.getType());    assertEquals("/", e.getPath());    MyWatcher childWatcher = new MyWatcher();    zk2.getChildren("/", childWatcher);    stopServer();    watcher2.waitForDisconnected(3000);    startServer();    watcher2.waitForConnected(3000);    watcher1.waitForConnected(3000);        zk1.create("/ch1/youshouldmatter2", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    e = childWatcher.events.poll(TIMEOUT, TimeUnit.MILLISECONDS);    assertNotNull(e);    assertEquals(EventType.NodeChildrenChanged, e.getType());    assertEquals("/", e.getPath());}
testDefaultWatcherAutoResetWithChroot
public void zookeeper_f6062_0() throws Exception
{    zk1.create("/ch1", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk2 = createClient(watcher2, hostPort + "/ch1");    zk2.getChildren("/", true);        zk1.create("/youdontmatter1", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        zk1.create("/ch1/youshouldmatter1", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    WatchedEvent e = watcher2.events.poll(TIMEOUT, TimeUnit.MILLISECONDS);    assertNotNull(e);    assertEquals(EventType.NodeChildrenChanged, e.getType());    assertEquals("/", e.getPath());    zk2.getChildren("/", true);    stopServer();    watcher2.waitForDisconnected(3000);    startServer();    watcher2.waitForConnected(3000);    watcher1.waitForConnected(3000);        zk1.create("/ch1/youshouldmatter2", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    e = watcher2.events.poll(TIMEOUT, TimeUnit.MILLISECONDS);    assertNotNull(e);    assertEquals(EventType.NodeChildrenChanged, e.getType());    assertEquals("/", e.getPath());}
testDeepChildWatcherAutoResetWithChroot
public void zookeeper_f6063_0() throws Exception
{    zk1.create("/ch1", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk1.create("/ch1/here", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk1.create("/ch1/here/we", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk1.create("/ch1/here/we/are", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk2 = createClient(watcher2, hostPort + "/ch1/here/we");    zk2.getChildren("/are", true);        zk1.create("/ch1/here/we/are/now", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    WatchedEvent e = watcher2.events.poll(TIMEOUT, TimeUnit.MILLISECONDS);    assertNotNull(e);    assertEquals(EventType.NodeChildrenChanged, e.getType());    assertEquals("/are", e.getPath());    MyWatcher childWatcher = new MyWatcher();    zk2.getChildren("/are", childWatcher);    stopServer();    watcher2.waitForDisconnected(3000);    startServer();    watcher2.waitForConnected(3000);    watcher1.waitForConnected(3000);        zk1.create("/ch1/here/we/are/again", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    e = childWatcher.events.poll(TIMEOUT, TimeUnit.MILLISECONDS);    assertNotNull(e);    assertEquals(EventType.NodeChildrenChanged, e.getType());    assertEquals("/are", e.getPath());}
testManyChildWatchersAutoReset
public voidf6064_1) throws Exception
{    zk2 = createClient(watcher2);        String pathBase = "/long-path-000000000-111111111-222222222-333333333-444444444-" + "555555555-666666666-777777777-888888888-999999999";    zk1.create(pathBase, null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);            List<String> paths = new ArrayList<String>();    for (int i = 0; i < 10000; i++) {        String path = zk1.create(pathBase + "/ch-", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);        paths.add(path);    }        MyWatcher childWatcher = new MyWatcher();        int i = 0;    for (String path : paths) {        if (i % 3 == 0) {            zk2.getChildren(path, childWatcher);        } else if (i % 3 == 1) {            zk2.exists(path + "/foo", childWatcher);        } else if (i % 3 == 2) {            zk2.getData(path, childWatcher, null);        }        i++;    }    stopServer();    watcher2.waitForDisconnected(30000);    startServer();    watcher2.waitForConnected(30000);    watcher1.waitForConnected(30000);        i = 0;    for (String path : paths) {        if (i % 3 == 0) {            zk1.create(path + "/ch", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);            WatchedEvent e = childWatcher.events.poll(TIMEOUT, TimeUnit.MILLISECONDS);            assertNotNull(e);            assertEquals(EventType.NodeChildrenChanged, e.getType());            assertEquals(path, e.getPath());        } else if (i % 3 == 1) {            zk1.create(path + "/foo", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);            WatchedEvent e = childWatcher.events.poll(TIMEOUT, TimeUnit.MILLISECONDS);            assertNotNull(e);            assertEquals(EventType.NodeCreated, e.getType());            assertEquals(path + "/foo", e.getPath());        } else if (i % 3 == 2) {            zk1.setData(path, new byte[] { 1, 2, 3 }, -1);            WatchedEvent e = childWatcher.events.poll(TIMEOUT, TimeUnit.MILLISECONDS);            assertNotNull(e);            assertEquals(EventType.NodeDataChanged, e.getType());            assertEquals(path, e.getPath());        }        i++;    }}
setUp
public voidf6065_1) throws Exception
{        qb.localSessionsEnabled = true;    qb.localSessionsUpgradingEnabled = true;    qb.setUp();    ClientBase.waitForServerUp(qb.hostPort, 10000);}
tearDown
public voidf6066_1) throws Exception
{        qb.tearDown();}
testLocalSessionUpgradeOnFollower
public void zookeeper_f6067_0() throws Exception
{    testLocalSessionUpgrade(false);}
testLocalSessionUpgradeOnLeader
public void zookeeper_f6068_0() throws Exception
{    testLocalSessionUpgrade(true);}
testLocalSessionUpgrade
private void zookeeper_f6069_0(boolean testLeader) throws Exception
{    int leaderIdx = qb.getLeaderIndex();    assertFalse("No leader in quorum?", leaderIdx == -1);    int followerIdx = (leaderIdx + 1) % 5;    int testPeerIdx = testLeader ? leaderIdx : followerIdx;    String[] hostPorts = qb.hostPort.split(",");    CountdownWatcher watcher = new CountdownWatcher();    ZooKeeper zk = qb.createClient(watcher, hostPorts[testPeerIdx], CONNECTION_TIMEOUT);    watcher.waitForConnected(CONNECTION_TIMEOUT);    final String firstPath = "/first";    final String secondPath = "/ephemeral";        zk.create(firstPath, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);                zk.create(secondPath, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);    Stat firstStat = zk.exists(firstPath, null);    assertNotNull(firstStat);    Stat secondStat = zk.exists(secondPath, null);    assertNotNull(secondStat);    long zxidDiff = secondStat.getCzxid() - firstStat.getCzxid();                assertEquals(2L, zxidDiff);}
runTest
public voidf6070_1boolean leaveEmptyFile, boolean trustEmptySnap) throws Exception
{    File tmpSnapDir = ClientBase.createTmpDir();    File tmpLogDir = ClientBase.createTmpDir();    ClientBase.setupTestEnv();    ZooKeeperServer zks = new ZooKeeperServer(tmpSnapDir, tmpLogDir, 3000);    SyncRequestProcessor.setSnapCount(SNAP_COUNT);    final int PORT = Integer.parseInt(HOSTPORT.split(":")[1]);    ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);    f.startup(zks);    assertTrue("waiting for server being up ", ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT));    ZooKeeper zk = new ZooKeeper(HOSTPORT, CONNECTION_TIMEOUT, this);    try {        for (int i = 0; i < N_TRANSACTIONS; i++) {            zk.create("/node-" + i, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        }    } finally {        zk.close();    }    f.shutdown();    zks.shutdown();    assertTrue("waiting for server to shutdown", ClientBase.waitForServerDown(HOSTPORT, CONNECTION_TIMEOUT));        zks = new ZooKeeperServer(tmpSnapDir, tmpLogDir, 3000);    zks.startdata();    long zxid = zks.getZKDatabase().getDataTreeLastProcessedZxid();        assertTrue("zxid > 0", zxid > 0);    zks.shutdown();        FileTxnSnapLog txnLogFactory = zks.getTxnLogFactory();    List<File> snapshots = txnLogFactory.findNRecentSnapshots(10);    assertTrue("We have a snapshot to corrupt", snapshots.size() > 0);    for (File file : snapshots) {        if (leaveEmptyFile) {            new PrintWriter(file).close();        } else {            file.delete();        }    }    if (trustEmptySnap) {        System.setProperty(FileTxnSnapLog.ZOOKEEPER_SNAPSHOT_TRUST_EMPTY, "true");    }        zks = new ZooKeeperServer(tmpSnapDir, tmpLogDir, 3000);    try {        zks.startdata();        zxid = zks.getZKDatabase().loadDataBase();        if (!trustEmptySnap) {            fail("Should have gotten exception for corrupted database");        }    } catch (IOException e) {                if (trustEmptySnap) {            fail("Should not get exception for empty database");        }    } finally {        if (trustEmptySnap) {            System.clearProperty(FileTxnSnapLog.ZOOKEEPER_SNAPSHOT_TRUST_EMPTY);        }    }    zks.shutdown();}
testRestoreWithEmptySnapFiles
public void zookeeper_f6071_0() throws Exception
{    runTest(true, false);}
testRestoreWithNoSnapFiles
public void zookeeper_f6072_0() throws Exception
{    runTest(false, false);}
testRestoreWithTrustedEmptySnapFiles
public void zookeeper_f6073_0() throws Exception
{    runTest(false, true);}
process
public void zookeeper_f6074_0(WatchedEvent event)
{}
setUp
public void zookeeper_f6075_0() throws Exception
{    System.setProperty("zookeeper.authProvider.1", "org.apache.zookeeper.server.auth.EnsembleAuthenticationProvider");    super.setUp();}
tearDown
public void zookeeper_f6076_0() throws Exception
{    super.tearDown();    System.clearProperty("zookeeper.authProvider.1");    System.clearProperty(EnsembleAuthenticationProvider.ENSEMBLE_PROPERTY);    ProviderRegistry.removeProvider("ensemble");}
noAuth
public void zookeeper_f6077_0() throws Exception
{    resetEnsembleAuth(null, false);    connectToEnsemble(null);}
emptyAuth
public void zookeeper_f6078_0() throws Exception
{    resetEnsembleAuth(null, true);    connectToEnsemble("foo");}
skipAuth
public void zookeeper_f6079_0() throws Exception
{    resetEnsembleAuth("woo", true);    connectToEnsemble(null);}
passAuth
public void zookeeper_f6080_0() throws Exception
{    resetEnsembleAuth("woo", true);    connectToEnsemble("woo");}
passAuthCSV
public void zookeeper_f6081_0() throws Exception
{    resetEnsembleAuth(" foo,bar, baz ", true);    connectToEnsemble("foo");    connectToEnsemble("bar");    connectToEnsemble("baz");}
failAuth
public void zookeeper_f6082_0() throws Exception
{    resetEnsembleAuth("woo", true);    connectToEnsemble("goo");}
removeEnsembleAuthProvider
public void zookeeper_f6083_0() throws Exception
{    resetEnsembleAuth(null, false);    connectToEnsemble("goo");}
connectToEnsemble
private void zookeeper_f6084_0(final String auth) throws IOException, InterruptedException, KeeperException
{    try (ZooKeeper zk = createClient()) {                if (auth != null) {            zk.addAuthInfo("ensemble", auth.getBytes());        }        zk.getData("/", false, null);    }}
resetEnsembleAuth
private void zookeeper_f6085_0(final String auth, final boolean useAuth) throws Exception
{    stopServer();    if (auth == null) {        System.clearProperty(EnsembleAuthenticationProvider.ENSEMBLE_PROPERTY);    } else {        System.setProperty(EnsembleAuthenticationProvider.ENSEMBLE_PROPERTY, auth);    }    if (useAuth) {        System.setProperty("zookeeper.authProvider.1", "org.apache.zookeeper.server.auth.EnsembleAuthenticationProvider");    } else {        System.clearProperty("zookeeper.authProvider.1");    }    ProviderRegistry.removeProvider("ensemble");    ProviderRegistry.initialize();    startServer();}
testIntConversion
public void zookeeper_f6086_0()
{        EnumSet<EventType> allTypes = EnumSet.allOf(EventType.class);    for (EventType et : allTypes) {        assertEquals(et, EventType.fromInt(et.getIntValue()));    }}
testInvalidIntConversion
public void zookeeper_f6087_0()
{    try {        EventType.fromInt(324242);        fail("Was able to create an invalid EventType via an integer");    } catch (RuntimeException re) {        }}
setUp
public void zookeeper_f6088_0() throws Exception
{    count = 3;    peers = new HashMap<Long, QuorumServer>(count);    threads = new ArrayList<LEThread>(count);    tmpdir = new File[count];    port = new int[count];    round = new int[3];    round[0] = 0;    round[1] = 0;    round[2] = 0;    start0 = new Semaphore(0);    finish0 = new Semaphore(0);    finish3 = new Semaphore(0);}
tearDown
public void zookeeper_f6089_0() throws Exception
{    for (int i = 0; i < threads.size(); i++) {        threads.get(i).peer.getElectionAlg().shutdown();    }}
run
public voidf6090_1)
{    boolean flag = true;    try {        while (flag) {            Vote v = null;            peer.setPeerState(ServerState.LOOKING);                        v = peer.getElectionAlg().lookForLeader();            if (v == null) {                fail("Thread " + i + " got a null vote");            }            /*                     * A real zookeeper would take care of setting the current vote. Here                     * we do it manually.                     */            peer.setCurrentVote(v);                        switch(i) {                case 0:                                        if (finish0.tryAcquire(1000, java.util.concurrent.TimeUnit.MILLISECONDS)) {                                                                        flag = false;                    }                    break;                case 1:                                        if (round[1] != 0) {                        finish0.release();                        flag = false;                    } else {                        finish3.acquire();                        start0.release();                    }                                        round[1]++;                    break;                case 2:                                        QuorumBase.shutdown(peer);                    flag = false;                    round[2] = 1;                    finish3.release();                                        break;            }        }    } catch (Exception e) {        e.printStackTrace();    }}
testLENewEpoch
public voidf6091_1) throws Exception
{        for (int i = 0; i < count; i++) {        peers.put(Long.valueOf(i), new QuorumServer(i, new InetSocketAddress("127.0.0.1", PortAssignment.unique()), new InetSocketAddress("127.0.0.1", PortAssignment.unique())));        tmpdir[i] = ClientBase.createTmpDir();        port[i] = PortAssignment.unique();    }    for (int i = 1; i < count; i++) {        QuorumPeer peer = new QuorumPeer(peers, tmpdir[i], tmpdir[i], port[i], 3, i, 1000, 2, 2, 2);        peer.startLeaderElection();        LEThread thread = new LEThread(peer, i);        thread.start();        threads.add(thread);    }    if (!start0.tryAcquire(4000, java.util.concurrent.TimeUnit.MILLISECONDS)) {        fail("First leader election failed");    }    QuorumPeer peer = new QuorumPeer(peers, tmpdir[0], tmpdir[0], port[0], 3, 0, 1000, 2, 2, 2);    peer.startLeaderElection();    LEThread thread = new LEThread(peer, 0);    thread.start();    threads.add(thread);        for (int i = 0; i < threads.size(); i++) {        threads.get(i).join(10000);        if (threads.get(i).isAlive()) {            fail("Threads didn't join");        }    }}
predicate
 boolean zookeeper_f6092_0(long newId, long newZxid, long newEpoch, long curId, long curZxid, long curEpoch)
{    return this.totalOrderPredicate(newId, newZxid, newEpoch, curId, curZxid, curEpoch);}
testPredicate
public voidf6093_1) throws IOException
{    peers = new HashMap<Long, QuorumServer>(3);    /*         * Creates list of peers.         */    for (int i = 0; i < 3; i++) {        peers.put(Long.valueOf(i), new QuorumServer(i, new InetSocketAddress("127.0.0.1", PortAssignment.unique()), new InetSocketAddress("127.0.0.1", PortAssignment.unique())));    }    /*         * Creating peer.         */    try {        File tmpDir = ClientBase.createTmpDir();        QuorumPeer peer = new QuorumPeer(peers, tmpDir, tmpDir, PortAssignment.unique(), 3, 0, 1000, 2, 2, 2);        MockFLE mock = new MockFLE(peer);        mock.start();        /*             * Lower epoch must return false             */        assertFalse(mock.predicate(4L, 0L, 0L, 3L, 0L, 2L));        /*             * Later epoch             */        assertTrue(mock.predicate(0L, 0L, 1L, 1L, 0L, 0L));        /*             * Higher zxid             */        assertTrue(mock.predicate(0L, 1L, 0L, 1L, 0L, 0L));        /*             * Higher id             */        assertTrue(mock.predicate(1L, 1L, 0L, 0L, 1L, 0L));    } catch (IOException e) {                fail("Exception while creating quorum peer");    }}
countVotes
 int zookeeper_f6094_0(HashSet<TestVote> hs, long id)
{    int counter = 0;    for (TestVote v : hs) {        if (v.leader == id) {            counter++;        }    }    return counter;}
setUp
public void zookeeper_f6095_0() throws Exception
{    count = 3;    peers = new HashMap<Long, QuorumServer>(count);    restartThreads = new ArrayList<FLERestartThread>(count);    tmpdir = new File[count];    port = new int[count];    finish = new Semaphore(0);}
tearDown
public void zookeeper_f6096_0() throws Exception
{    for (int i = 0; i < restartThreads.size(); i++) {        restartThreads.get(i).peer.getElectionAlg().shutdown();    }}
run
public voidf6097_1)
{    try {        Vote v = null;        while (true) {            peer.setPeerState(ServerState.LOOKING);                        v = peer.getElectionAlg().lookForLeader();            if (v == null) {                                break;            }            /*                     * A real zookeeper would take care of setting the current vote. Here                     * we do it manually.                     */            peer.setCurrentVote(v);                        switch(i) {                case 0:                    if (peerRound == 0) {                                                QuorumBase.shutdown(peer);                        restartThreads.get(i).peer.getElectionAlg().shutdown();                        peer = new QuorumPeer(peers, tmpdir[i], tmpdir[i], port[i], 3, i, 1000, 2, 2, 2);                        peer.startLeaderElection();                        peerRound++;                    } else {                        finish.release(2);                        return;                    }                    break;                case 1:                                        finish.acquire();                                                            return;                case 2:                                        finish.acquire();                                                            return;            }        }    } catch (Exception e) {        e.printStackTrace();    }}
testLERestart
public voidf6098_1) throws Exception
{        for (int i = 0; i < count; i++) {        peers.put(Long.valueOf(i), new QuorumServer(i, new InetSocketAddress("127.0.0.1", PortAssignment.unique()), new InetSocketAddress("127.0.0.1", PortAssignment.unique())));        tmpdir[i] = ClientBase.createTmpDir();        port[i] = PortAssignment.unique();    }    for (int i = 0; i < count; i++) {        QuorumPeer peer = new QuorumPeer(peers, tmpdir[i], tmpdir[i], port[i], 3, i, 1000, 2, 2, 2);        peer.startLeaderElection();        FLERestartThread thread = new FLERestartThread(peer, i);        thread.start();        restartThreads.add(thread);    }        for (int i = 0; i < restartThreads.size(); i++) {        restartThreads.get(i).join(10000);        if (restartThreads.get(i).isAlive()) {            fail("Threads didn't join");        }    }}
countVotes
 int zookeeper_f6099_0(HashSet<TestVote> hs, long id)
{    int counter = 0;    for (TestVote v : hs) {        if (v.leader == id) {            counter++;        }    }    return counter;}
setUp
public void zookeeper_f6100_0() throws Exception
{    count = 7;    peers = new HashMap<Long, QuorumServer>(count);    threads = new ArrayList<LEThread>(count);    voteMap = new HashMap<Integer, HashSet<TestVote>>();    votes = new Vote[count];    tmpdir = new File[count];    port = new int[count];    successCount = 0;    joinedThreads = new HashSet<Long>();}
tearDown
public void zookeeper_f6101_0() throws Exception
{    for (int i = 0; i < threads.size(); i++) {        leThread = threads.get(i);        QuorumBase.shutdown(leThread.peer);    }}
run
public voidf6102_1)
{    try {        Vote v = null;        while (true) {            /*                     * Set the state of the peer to LOOKING and look for leader                     */            peer.setPeerState(ServerState.LOOKING);                        v = peer.getElectionAlg().lookForLeader();            if (v == null) {                                break;            }            /*                     * Done with the election round, so now we set the vote in                     * the peer. A real zookeeper would take care of setting the                     * current vote. Here we do it manually.                     */            peer.setCurrentVote(v);                        votes[i] = v;            /*                     * Get the current value of the logical clock for this peer                     * so that we know in which round this peer has executed.                     */            int lc = (int) ((FastLeaderElection) peer.getElectionAlg()).getLogicalClock();            /*                     * The leader executes the following block, which essentially shuts down                     * the peer if it is not the last round.                     */            if (v.getId() == i) {                                if (lc < this.totalRounds) {                                        FastLeaderElection election = (FastLeaderElection) peer.getElectionAlg();                    election.shutdown();                                        assertEquals(-1, election.getVote().getId());                                        break;                }            }            /*                     * If the peer has done enough rounds, then consider joining. The thread                     * will only join if it is part of a quorum supporting the current                     * leader. Otherwise it will try again.                     */            if (lc >= this.totalRounds) {                /*                         * quora keeps the supporters of a given leader, so                         * we first update it with the vote of this peer.                         */                if (quora.get(v.getId()) == null) {                    quora.put(v.getId(), new HashSet<Integer>());                }                quora.get(v.getId()).add(i);                /*                         * we now wait until a quorum supports the same leader.                         */                if (waitForQuorum(v.getId())) {                    synchronized (self) {                        /*                                 * Assert that the state of the thread is the one expected.                                 */                        if (v.getId() == i) {                            assertTrue("Wrong state" + peer.getPeerState(), peer.getPeerState() == ServerState.LEADING);                            leader = i;                        } else {                            assertTrue("Wrong state" + peer.getPeerState(), peer.getPeerState() == ServerState.FOLLOWING);                        }                        /*                                 * Global variable keeping track of                                 * how many peers have successfully                                 * joined.                                 */                        successCount++;                        joinedThreads.add((long) i);                        self.notify();                    }                    /*                             * I'm done so joining.                             */                    break;                } else {                    quora.get(v.getId()).remove(i);                }            }            /*                     * This sleep time represents the time a follower                     * would take to declare the leader dead and start                     * a new leader election.                     */            Thread.sleep(100);        }            } catch (InterruptedException e) {        fail(e.toString());    }}
waitForQuorum
 boolean zookeeper_f6103_0(long id) throws InterruptedException
{    int loopCounter = 0;    while ((quora.get(id).size() <= count / 2) && (loopCounter < MAX_LOOP_COUNTER)) {        Thread.sleep(100);        loopCounter++;    }    return (loopCounter < MAX_LOOP_COUNTER) || (quora.get(id).size() > count / 2);}
testSingleElection
public void zookeeper_f6104_0() throws Exception
{    try {        runElection(1);    } catch (Exception e) {        fail(e.toString());    }}
testDoubleElection
public void zookeeper_f6105_0() throws Exception
{    try {        runElection(2);    } catch (Exception e) {        fail(e.toString());    }}
testTripleElection
public void zookeeper_f6106_0() throws Exception
{    try {        runElection(3);    } catch (Exception e) {        fail(e.toString());    }}
runElection
private voidf6107_1int rounds) throws Exception
{    ConcurrentHashMap<Long, HashSet<Integer>> quora = new ConcurrentHashMap<Long, HashSet<Integer>>();        /*         * Creates list of peers.         */    for (int i = 0; i < count; i++) {        port[i] = PortAssignment.unique();        peers.put(Long.valueOf(i), new QuorumServer(i, new InetSocketAddress("127.0.0.1", PortAssignment.unique()), new InetSocketAddress("127.0.0.1", PortAssignment.unique()), new InetSocketAddress("127.0.0.1", port[i])));        tmpdir[i] = ClientBase.createTmpDir();    }    /*         * Start one LEThread for each peer we want to run.         */    for (int i = 0; i < count; i++) {        QuorumPeer peer = new QuorumPeer(peers, tmpdir[i], tmpdir[i], port[i], 3, i, 1000, 2, 2, 2);        peer.startLeaderElection();        LEThread thread = new LEThread(this, peer, i, rounds, quora);        thread.start();        threads.add(thread);    }        int waitCounter = 0;    synchronized (this) {        while (((successCount <= count / 2) || (leader == -1)) && (waitCounter < MAX_LOOP_COUNTER)) {            this.wait(200);            waitCounter++;        }    }        /*         * Lists what threads haven't joined. A thread doesn't join if         * it hasn't decided upon a leader yet. It can happen that a         * peer is slow or disconnected, and it can take longer to         * nominate and connect to the current leader.         */    for (int i = 0; i < threads.size(); i++) {        if (threads.get(i).isAlive()) {                    }    }    /*         * If we have a majority, then we are good to go.         */    if (successCount <= count / 2) {        fail("Fewer than a a majority has joined");    }    /*         * I'm done so joining.         */    if (!joinedThreads.contains(leader)) {        fail("Leader hasn't joined: " + leader);    }}
run
public voidf6108_1)
{    setName("VerifyState-" + peer.getId());    while (true) {        if (peer.getPeerState() == ServerState.FOLLOWING) {                        success = true;            break;        } else if (peer.getPeerState() == ServerState.LEADING) {                        success = false;            break;        }        try {            Thread.sleep(250);        } catch (Exception e) {                    }    }}
isSuccess
public boolean zookeeper_f6109_0()
{    return success;}
testJoin
public voidf6110_1) throws Exception
{    int sid;    QuorumPeer peer;    int waitTime = 10 * 1000;    ArrayList<QuorumPeer> peerList = new ArrayList<QuorumPeer>();    for (sid = 0; sid < 3; sid++) {        port[sid] = PortAssignment.unique();        peers.put(Long.valueOf(sid), new QuorumServer(sid, new InetSocketAddress("127.0.0.1", PortAssignment.unique()), new InetSocketAddress("127.0.0.1", PortAssignment.unique()), new InetSocketAddress("127.0.0.1", port[sid])));        tmpdir[sid] = ClientBase.createTmpDir();    }        for (sid = 0; sid < 2; sid++) {        peer = new QuorumPeer(peers, tmpdir[sid], tmpdir[sid], port[sid], 3, sid, 2000, 2, 2, 2);                peer.start();        peerList.add(sid, peer);    }    peer = peerList.get(0);    VerifyState v1 = new VerifyState(peerList.get(0));    v1.start();    v1.join(waitTime);    assertFalse("Unable to form cluster in " + waitTime + " ms", !v1.isSuccess());        peer = new QuorumPeer(peers, tmpdir[sid], tmpdir[sid], port[sid], 3, sid, 2000, 2, 2, 2);        peer.start();    peerList.add(sid, peer);    v1 = new VerifyState(peer);    v1.start();    v1.join(waitTime);    if (v1.isAlive()) {        fail("Peer " + peer.getId() + " failed to join the cluster " + "within " + waitTime + " ms");    } else if (!v1.isSuccess()) {        fail("Incorrect LEADING state for peer " + peer.getId());    }        for (int id = 0; id < 3; id++) {        peer = peerList.get(id);        if (peer != null) {            peer.shutdown();        }    }}
testJoinInconsistentEnsemble
public voidf6111_1) throws Exception
{    int sid;    QuorumPeer peer;    int waitTime = 10 * 1000;    ArrayList<QuorumPeer> peerList = new ArrayList<QuorumPeer>();    for (sid = 0; sid < 3; sid++) {        peers.put(Long.valueOf(sid), new QuorumServer(sid, new InetSocketAddress("127.0.0.1", PortAssignment.unique()), new InetSocketAddress("127.0.0.1", PortAssignment.unique())));        tmpdir[sid] = ClientBase.createTmpDir();        port[sid] = PortAssignment.unique();    }        for (sid = 0; sid < 2; sid++) {        peer = new QuorumPeer(peers, tmpdir[sid], tmpdir[sid], port[sid], 3, sid, 2000, 2, 2, 2);                peer.start();        peerList.add(sid, peer);    }    peer = peerList.get(0);    VerifyState v1 = new VerifyState(peerList.get(0));    v1.start();    v1.join(waitTime);    assertFalse("Unable to form cluster in " + waitTime + " ms", !v1.isSuccess());        long leaderSid = peer.getCurrentVote().getId();    long zxid = peer.getCurrentVote().getZxid();    long electionEpoch = peer.getCurrentVote().getElectionEpoch();    ServerState state = peer.getCurrentVote().getState();    long peerEpoch = peer.getCurrentVote().getPeerEpoch();    Vote newVote = new Vote(leaderSid, zxid + 100, electionEpoch + 100, peerEpoch, state);    peer.setCurrentVote(newVote);        peer = new QuorumPeer(peers, tmpdir[2], tmpdir[2], port[2], 3, 2, 2000, 2, 2, 2);        peer.start();    peerList.add(sid, peer);    v1 = new VerifyState(peer);    v1.start();    v1.join(waitTime);    if (v1.isAlive()) {        fail("Peer " + peer.getId() + " failed to join the cluster " + "within " + waitTime + " ms");    }        for (int id = 0; id < 3; id++) {        peer = peerList.get(id);        if (peer != null) {            peer.shutdown();        }    }}
testElectionTimeUnit
public void zookeeper_f6112_0() throws Exception
{    assertEquals("MS", QuorumPeer.FLE_TIME_UNIT);}
setUp
public void zookeeper_f6113_0() throws Exception
{    count = 9;    peers = new HashMap<Long, QuorumServer>(count);    threads = new ArrayList<LEThread>(count);    votes = new Vote[count];    tmpdir = new File[count];    port = new int[count];    String config = "group.1=0:1:2\n" + "group.2=3:4:5\n" + "group.3=6:7:8\n" + "weight.0=1\n" + "weight.1=1\n" + "weight.2=1\n" + "weight.3=0\n" + "weight.4=0\n" + "weight.5=0\n" + "weight.6=0\n" + "weight.7=0\n" + "weight.8=0";    ByteArrayInputStream is = new ByteArrayInputStream(config.getBytes());    this.qp = new Properties();    qp.load(is);}
tearDown
public void zookeeper_f6114_0() throws Exception
{    for (int i = 0; i < threads.size(); i++) {        LEThread leThread = threads.get(i);                                QuorumBase.shutdown(leThread.peer);    }}
run
public voidf6115_1)
{    try {        Vote v = null;        fail = false;        while (true) {                        peer.setPeerState(ServerState.LOOKING);                        v = peer.getElectionAlg().lookForLeader();            if (v == null) {                                return;            }            /*                     * A real zookeeper would take care of setting the current vote. Here                     * we do it manually.                     */            peer.setCurrentVote(v);                        votes[i] = v;            if ((peer.getPeerState() == ServerState.LEADING) && (peer.getId() > 2)) {                fail = true;            }            if ((peer.getPeerState() == ServerState.FOLLOWING) || (peer.getPeerState() == ServerState.LEADING)) {                break;            }        }            } catch (InterruptedException e) {        e.printStackTrace();    }}
testZeroWeightQuorum
public voidf6116_1) throws Exception
{        for (int i = 0; i < count; i++) {        InetSocketAddress addr1 = new InetSocketAddress("127.0.0.1", PortAssignment.unique());        InetSocketAddress addr2 = new InetSocketAddress("127.0.0.1", PortAssignment.unique());        InetSocketAddress addr3 = new InetSocketAddress("127.0.0.1", PortAssignment.unique());        port[i] = addr3.getPort();        qp.setProperty("server." + i, "127.0.0.1:" + addr1.getPort() + ":" + addr2.getPort() + ";" + port[i]);        peers.put(Long.valueOf(i), new QuorumServer(i, addr1, addr2, addr3));        tmpdir[i] = ClientBase.createTmpDir();    }    for (int i = 0; i < count; i++) {        QuorumHierarchical hq = new QuorumHierarchical(qp);        QuorumPeer peer = new QuorumPeer(peers, tmpdir[i], tmpdir[i], port[i], 3, i, 1000, 2, 2, 2, hq);        peer.startLeaderElection();        LEThread thread = new LEThread(peer, i);        thread.start();        threads.add(thread);    }        for (int i = 0; i < threads.size(); i++) {        threads.get(i).join(15000);        if (threads.get(i).isAlive()) {            fail("Threads didn't join");        } else {            if (threads.get(i).fail) {                fail("Elected zero-weight server");            }        }    }}
setUp
public void zookeeper_f6117_0() throws Exception
{    pending.set(0);    errors.set(0);    counter.set(0);}
tearDown
public voidf6118_1) throws Exception
{    }
testLaggingFollowerResyncsUnderNewEpoch
public voidf6119_1) throws Exception
{    CountdownWatcher watcher1 = new CountdownWatcher();    CountdownWatcher watcher2 = new CountdownWatcher();    CountdownWatcher watcher3 = new CountdownWatcher();    QuorumUtil qu = new QuorumUtil(1);    qu.shutdownAll();    qu.start(1);    qu.start(2);    assertTrue("Waiting for server up", ClientBase.waitForServerUp("127.0.0.1:" + qu.getPeer(1).clientPort, ClientBase.CONNECTION_TIMEOUT));    assertTrue("Waiting for server up", ClientBase.waitForServerUp("127.0.0.1:" + qu.getPeer(2).clientPort, ClientBase.CONNECTION_TIMEOUT));    ZooKeeper zk1 = createClient(qu.getPeer(1).peer.getClientPort(), watcher1);        final String resyncPath = "/resyncundernewepoch";    zk1.create(resyncPath, null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk1.close();    qu.shutdown(1);    qu.shutdown(2);    assertTrue("Waiting for server down", ClientBase.waitForServerDown("127.0.0.1:" + qu.getPeer(1).clientPort, ClientBase.CONNECTION_TIMEOUT));    assertTrue("Waiting for server down", ClientBase.waitForServerDown("127.0.0.1:" + qu.getPeer(2).clientPort, ClientBase.CONNECTION_TIMEOUT));    qu.start(1);    qu.start(2);    assertTrue("Waiting for server up", ClientBase.waitForServerUp("127.0.0.1:" + qu.getPeer(1).clientPort, ClientBase.CONNECTION_TIMEOUT));    assertTrue("Waiting for server up", ClientBase.waitForServerUp("127.0.0.1:" + qu.getPeer(2).clientPort, ClientBase.CONNECTION_TIMEOUT));    qu.start(3);    assertTrue("Waiting for server up", ClientBase.waitForServerUp("127.0.0.1:" + qu.getPeer(3).clientPort, ClientBase.CONNECTION_TIMEOUT));    zk1 = createClient(qu.getPeer(1).peer.getClientPort(), watcher1);        assertNotNull("zk1 has data", zk1.exists(resyncPath, false));    final ZooKeeper zk2 = createClient(qu.getPeer(2).peer.getClientPort(), watcher2);        assertNotNull("zk2 has data", zk2.exists(resyncPath, false));    final ZooKeeper zk3 = createClient(qu.getPeer(3).peer.getClientPort(), watcher3);        assertNotNull("zk3 has data", zk3.exists(resyncPath, false));    zk1.close();    zk2.close();    zk3.close();    qu.shutdownAll();}
testResyncBySnapThenDiffAfterFollowerCrashes
public void zookeeper_f6120_0() throws Throwable
{    followerResyncCrashTest(false);}
testResyncByTxnlogThenDiffAfterFollowerCrashes
public void zookeeper_f6121_0() throws Throwable
{    followerResyncCrashTest(true);}
followerResyncCrashTest
public voidf6122_1boolean useTxnLogResync) throws Throwable
{    final Semaphore sem = new Semaphore(0);    QuorumUtil qu = new QuorumUtil(1);    qu.startAll();    CountdownWatcher watcher1 = new CountdownWatcher();    CountdownWatcher watcher2 = new CountdownWatcher();    CountdownWatcher watcher3 = new CountdownWatcher();    int index = 1;    while (qu.getPeer(index).peer.leader == null) {        index++;    }    Leader leader = qu.getPeer(index).peer.leader;    assertNotNull(leader);    if (useTxnLogResync) {                        qu.getPeer(index).peer.getActiveServer().getZKDatabase().setSnapshotSizeFactor(1000);    } else {                        qu.getPeer(index).peer.getActiveServer().getZKDatabase().setSnapshotSizeFactor(-1);    }    /* Reusing the index variable to select a follower to connect to */    index = (index == 1) ? 2 : 1;        qu.shutdown(index);    final ZooKeeper zk3 = createClient(qu.getPeer(3).peer.getClientPort(), watcher3);        zk3.create("/mybar", null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);    qu.restart(index);    final ZooKeeper zk1 = createClient(qu.getPeer(index).peer.getClientPort(), watcher1);        final ZooKeeper zk2 = createClient(qu.getPeer(index).peer.getClientPort(), watcher2);        zk1.create("/first", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        Thread mytestfooThread = new Thread(new Runnable() {        @Override        public void run() {            for (int i = 0; i < 3000; i++) {                                zk3.create("/mytestfoo", null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL, new AsyncCallback.StringCallback() {                    @Override                    public void processResult(int rc, String path, Object ctx, String name) {                        pending.decrementAndGet();                        counter.incrementAndGet();                        if (rc != 0) {                            errors.incrementAndGet();                        }                        if (counter.get() == 16200) {                            sem.release();                        }                    }                }, null);                pending.incrementAndGet();                if (i % 10 == 0) {                    try {                        Thread.sleep(100);                    } catch (Exception e) {                    }                }            }        }    });        for (int i = 0; i < 13000; i++) {                zk3.create("/mybar", null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL, new AsyncCallback.StringCallback() {            @Override            public void processResult(int rc, String path, Object ctx, String name) {                pending.decrementAndGet();                counter.incrementAndGet();                if (rc != 0) {                    errors.incrementAndGet();                }                if (counter.get() == 16200) {                    sem.release();                }            }        }, null);        pending.incrementAndGet();        if (i == 5000) {            qu.shutdown(index);                    }        if (i == 12000) {                                                            mytestfooThread.start();                        qu.restart(index);            Thread.sleep(300);                        qu.shutdown(index);            Thread.sleep(300);                        qu.restart(index);                    }        if ((i % 1000) == 0) {            Thread.sleep(1000);        }        if (i % 50 == 0) {            zk2.create("/newbaz", null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL, new AsyncCallback.StringCallback() {                @Override                public void processResult(int rc, String path, Object ctx, String name) {                    pending.decrementAndGet();                    counter.incrementAndGet();                    if (rc != 0) {                        errors.incrementAndGet();                    }                    if (counter.get() == 16200) {                        sem.release();                    }                }            }, null);            pending.incrementAndGet();        }    }        if (!sem.tryAcquire(ClientBase.CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS)) {            }    mytestfooThread.join(ClientBase.CONNECTION_TIMEOUT);    if (mytestfooThread.isAlive()) {            }    assertTrue(waitForPendingRequests(60));    assertTrue(waitForSync(qu, index, 10));    verifyState(qu, index, leader);    zk1.close();    zk2.close();    zk3.close();    qu.shutdownAll();}
run
public void zookeeper_f6123_0()
{    for (int i = 0; i < 3000; i++) {                zk3.create("/mytestfoo", null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL, new AsyncCallback.StringCallback() {            @Override            public void processResult(int rc, String path, Object ctx, String name) {                pending.decrementAndGet();                counter.incrementAndGet();                if (rc != 0) {                    errors.incrementAndGet();                }                if (counter.get() == 16200) {                    sem.release();                }            }        }, null);        pending.incrementAndGet();        if (i % 10 == 0) {            try {                Thread.sleep(100);            } catch (Exception e) {            }        }    }}
processResult
public void zookeeper_f6124_0(int rc, String path, Object ctx, String name)
{    pending.decrementAndGet();    counter.incrementAndGet();    if (rc != 0) {        errors.incrementAndGet();    }    if (counter.get() == 16200) {        sem.release();    }}
processResult
public void zookeeper_f6125_0(int rc, String path, Object ctx, String name)
{    pending.decrementAndGet();    counter.incrementAndGet();    if (rc != 0) {        errors.incrementAndGet();    }    if (counter.get() == 16200) {        sem.release();    }}
processResult
public void zookeeper_f6126_0(int rc, String path, Object ctx, String name)
{    pending.decrementAndGet();    counter.incrementAndGet();    if (rc != 0) {        errors.incrementAndGet();    }    if (counter.get() == 16200) {        sem.release();    }}
testResyncByDiffAfterFollowerCrashes
public voidf6127_1) throws IOException, InterruptedException, KeeperException, Throwable
{    final Semaphore sem = new Semaphore(0);    QuorumUtil qu = new QuorumUtil(1);    qu.startAll();    CountdownWatcher watcher1 = new CountdownWatcher();    CountdownWatcher watcher2 = new CountdownWatcher();    CountdownWatcher watcher3 = new CountdownWatcher();    int index = 1;    while (qu.getPeer(index).peer.leader == null) {        index++;    }    Leader leader = qu.getPeer(index).peer.leader;    assertNotNull(leader);    /* Reusing the index variable to select a follower to connect to */    index = (index == 1) ? 2 : 1;        final ZooKeeper zk1 = createClient(qu.getPeer(index).peer.getClientPort(), watcher1);        final ZooKeeper zk2 = createClient(qu.getPeer(index).peer.getClientPort(), watcher2);        final ZooKeeper zk3 = createClient(qu.getPeer(3).peer.getClientPort(), watcher3);        zk1.create("/first", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk2.create("/mybar", null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);    final AtomicBoolean runNow = new AtomicBoolean(false);    Thread mytestfooThread = new Thread(new Runnable() {        @Override        public void run() {            int inSyncCounter = 0;            while (inSyncCounter < 400) {                if (runNow.get()) {                    zk3.create("/mytestfoo", null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL, new AsyncCallback.StringCallback() {                        @Override                        public void processResult(int rc, String path, Object ctx, String name) {                            pending.decrementAndGet();                            counter.incrementAndGet();                            if (rc != 0) {                                errors.incrementAndGet();                            }                            if (counter.get() > 7300) {                                sem.release();                            }                        }                    }, null);                    pending.incrementAndGet();                    try {                        Thread.sleep(10);                    } catch (Exception e) {                    }                    inSyncCounter++;                } else {                    Thread.yield();                }            }        }    });    mytestfooThread.start();    for (int i = 0; i < 5000; i++) {        zk2.create("/mybar", null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL, new AsyncCallback.StringCallback() {            @Override            public void processResult(int rc, String path, Object ctx, String name) {                pending.decrementAndGet();                counter.incrementAndGet();                if (rc != 0) {                    errors.incrementAndGet();                }                if (counter.get() > 7300) {                    sem.release();                }            }        }, null);        pending.incrementAndGet();        if (i == 1000) {            qu.shutdown(index);            Thread.sleep(1100);                    }        if (i == 1100 || i == 1150 || i == 1200) {            Thread.sleep(1000);        }        if (i == 1200) {            qu.startThenShutdown(index);            runNow.set(true);            qu.restart(index);                    }        if (i >= 1000 && i % 2 == 0) {            zk3.create("/newbaz", null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL, new AsyncCallback.StringCallback() {                @Override                public void processResult(int rc, String path, Object ctx, String name) {                    pending.decrementAndGet();                    counter.incrementAndGet();                    if (rc != 0) {                        errors.incrementAndGet();                    }                    if (counter.get() > 7300) {                        sem.release();                    }                }            }, null);            pending.incrementAndGet();        }        if (i == 1050 || i == 1100 || i == 1150) {            Thread.sleep(1000);        }    }        if (!sem.tryAcquire(ClientBase.CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS)) {            }    mytestfooThread.join(ClientBase.CONNECTION_TIMEOUT);    if (mytestfooThread.isAlive()) {            }    assertTrue(waitForPendingRequests(60));    assertTrue(waitForSync(qu, index, 10));        verifyState(qu, index, leader);    zk1.close();    zk2.close();    zk3.close();    qu.shutdownAll();}
run
public void zookeeper_f6128_0()
{    int inSyncCounter = 0;    while (inSyncCounter < 400) {        if (runNow.get()) {            zk3.create("/mytestfoo", null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL, new AsyncCallback.StringCallback() {                @Override                public void processResult(int rc, String path, Object ctx, String name) {                    pending.decrementAndGet();                    counter.incrementAndGet();                    if (rc != 0) {                        errors.incrementAndGet();                    }                    if (counter.get() > 7300) {                        sem.release();                    }                }            }, null);            pending.incrementAndGet();            try {                Thread.sleep(10);            } catch (Exception e) {            }            inSyncCounter++;        } else {            Thread.yield();        }    }}
processResult
public void zookeeper_f6129_0(int rc, String path, Object ctx, String name)
{    pending.decrementAndGet();    counter.incrementAndGet();    if (rc != 0) {        errors.incrementAndGet();    }    if (counter.get() > 7300) {        sem.release();    }}
processResult
public void zookeeper_f6130_0(int rc, String path, Object ctx, String name)
{    pending.decrementAndGet();    counter.incrementAndGet();    if (rc != 0) {        errors.incrementAndGet();    }    if (counter.get() > 7300) {        sem.release();    }}
processResult
public void zookeeper_f6131_0(int rc, String path, Object ctx, String name)
{    pending.decrementAndGet();    counter.incrementAndGet();    if (rc != 0) {        errors.incrementAndGet();    }    if (counter.get() > 7300) {        sem.release();    }}
createClient
private static DisconnectableZooKeeper zookeeper_f6132_0(int port, CountdownWatcher watcher) throws IOException, TimeoutException, InterruptedException
{    DisconnectableZooKeeper zk = new DisconnectableZooKeeper("127.0.0.1:" + port, ClientBase.CONNECTION_TIMEOUT, watcher);    watcher.waitForConnected(CONNECTION_TIMEOUT);    return zk;}
waitForPendingRequests
private booleanf6133_1int timeout) throws InterruptedException
{        for (int i = 0; i < timeout; ++i) {        Thread.sleep(1000);        if (pending.get() == 0) {            return true;        }    }        return false;}
waitForSync
private booleanf6134_1QuorumUtil qu, int index, int timeout) throws InterruptedException
{        int leaderIndex = (index == 1) ? 2 : 1;    ZKDatabase restartedDb = qu.getPeer(index).peer.getActiveServer().getZKDatabase();    ZKDatabase cleanDb = qu.getPeer(3).peer.getActiveServer().getZKDatabase();    ZKDatabase leadDb = qu.getPeer(leaderIndex).peer.getActiveServer().getZKDatabase();    long leadZxid = 0;    long cleanZxid = 0;    long restartedZxid = 0;    for (int i = 0; i < timeout; ++i) {        leadZxid = leadDb.getDataTreeLastProcessedZxid();        cleanZxid = cleanDb.getDataTreeLastProcessedZxid();        restartedZxid = restartedDb.getDataTreeLastProcessedZxid();        if (leadZxid == cleanZxid && leadZxid == restartedZxid) {            return true;        }        Thread.sleep(1000);    }        return false;}
createTestableClient
private static TestableZooKeeper zookeeper_f6135_0(String hp) throws IOException, TimeoutException, InterruptedException
{    CountdownWatcher watcher = new CountdownWatcher();    return createTestableClient(watcher, hp);}
createTestableClient
private static TestableZooKeeper zookeeper_f6136_0(CountdownWatcher watcher, String hp) throws IOException, TimeoutException, InterruptedException
{    TestableZooKeeper zk = new TestableZooKeeper(hp, ClientBase.CONNECTION_TIMEOUT, watcher);    watcher.waitForConnected(CONNECTION_TIMEOUT);    return zk;}
verifyState
private voidf6137_1QuorumUtil qu, int index, Leader leader)
{        assertTrue("Not following", qu.getPeer(index).peer.follower != null);    long epochF = (qu.getPeer(index).peer.getActiveServer().getZxid() >> 32L);    long epochL = (leader.getEpoch() >> 32L);    assertTrue("Zxid: " + qu.getPeer(index).peer.getActiveServer().getZKDatabase().getDataTreeLastProcessedZxid() + "Current epoch: " + epochF, epochF == epochL);    int leaderIndex = (index == 1) ? 2 : 1;    Collection<Long> sessionsRestarted = qu.getPeer(index).peer.getActiveServer().getZKDatabase().getSessions();    Collection<Long> sessionsNotRestarted = qu.getPeer(leaderIndex).peer.getActiveServer().getZKDatabase().getSessions();    for (Long l : sessionsRestarted) {        assertTrue("Should have same set of sessions in both servers, did not expect: " + l, sessionsNotRestarted.contains(l));    }    assertEquals("Should have same number of sessions", sessionsNotRestarted.size(), sessionsRestarted.size());    ZKDatabase restarted = qu.getPeer(index).peer.getActiveServer().getZKDatabase();    ZKDatabase clean = qu.getPeer(3).peer.getActiveServer().getZKDatabase();    ZKDatabase lead = qu.getPeer(leaderIndex).peer.getActiveServer().getZKDatabase();    for (Long l : sessionsRestarted) {                assertTrue("Should have same set of sessions in both servers, did not expect: " + l, sessionsNotRestarted.contains(l));        Set<String> ephemerals = restarted.getEphemerals(l);        Set<String> cleanEphemerals = clean.getEphemerals(l);        for (String o : cleanEphemerals) {            if (!ephemerals.contains(o)) {                            }        }        for (String o : ephemerals) {            if (!cleanEphemerals.contains(o)) {                            }        }        Set<String> leadEphemerals = lead.getEphemerals(l);        for (String o : leadEphemerals) {            if (!cleanEphemerals.contains(o)) {                            }        }        for (String o : cleanEphemerals) {            if (!leadEphemerals.contains(o)) {                            }        }        assertEquals("Should have same number of ephemerals in both followers", ephemerals.size(), cleanEphemerals.size());        assertEquals("Leader should equal follower", lead.getEphemerals(l).size(), cleanEphemerals.size());    }}
testFollowerSendsLastZxid
public voidf6138_1) throws Exception
{    QuorumUtil qu = new QuorumUtil(1);    qu.startAll();    int index = 1;    while (qu.getPeer(index).peer.follower == null) {        index++;    }        TestableZooKeeper zk = createTestableClient("localhost:" + qu.getPeer(index).peer.getClientPort());    assertEquals(0L, zk.testableLastZxid());    zk.exists("/", false);    long lzxid = zk.testableLastZxid();    assertTrue("lzxid:" + lzxid + " > 0", lzxid > 0);    zk.close();    qu.shutdownAll();}
process
public voidf6139_1WatchedEvent event)
{    super.process(event);    if (event.getType() != Event.EventType.None) {        try {            events.put(event);        } catch (InterruptedException e) {                    }    }}
testFollowerWatcherResync
public voidf6140_1) throws Exception
{    QuorumUtil qu = new QuorumUtil(1);    qu.startAll();    int index = 1;    while (qu.getPeer(index).peer.follower == null) {        index++;    }        TestableZooKeeper zk1 = createTestableClient("localhost:" + qu.getPeer(index).peer.getClientPort());    zk1.create("/foo", "foo".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    MyWatcher watcher = new MyWatcher();    TestableZooKeeper zk2 = createTestableClient(watcher, "localhost:" + qu.getPeer(index).peer.getClientPort());    zk2.exists("/foo", true);    watcher.reset();    zk2.testableConnloss();    if (!watcher.clientConnected.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS)) {        fail("Unable to connect to server");    }    assertArrayEquals("foo".getBytes(), zk2.getData("/foo", false, null));    assertNull(watcher.events.poll(5, TimeUnit.SECONDS));    zk1.close();    zk2.close();    qu.shutdownAll();}
testFourLetterWords
public void zookeeper_f6141_0() throws Exception
{    String[] servers = hostPort.split(",");    for (String hp : servers) {        verify(hp, "ruok", "imok");        verify(hp, "envi", "java.version");        verify(hp, "conf", "clientPort");        verify(hp, "stat", "Outstanding");        verify(hp, "srvr", "Outstanding");        verify(hp, "cons", "queued");        verify(hp, "dump", "Session");        verify(hp, "wchs", "watches");        verify(hp, "wchp", "");        verify(hp, "wchc", "");        verify(hp, "srst", "reset");        verify(hp, "crst", "reset");        verify(hp, "stat", "Outstanding");        verify(hp, "srvr", "Outstanding");        verify(hp, "cons", "queued");        TestableZooKeeper zk = createClient(hp);        String sid = getHexSessionId(zk.getSessionId());        verify(hp, "stat", "queued");        verify(hp, "srvr", "Outstanding");        verify(hp, "cons", sid);        verify(hp, "dump", sid);        verify(hp, "dirs", "size");        zk.getData("/", true, null);        verify(hp, "stat", "queued");        verify(hp, "srvr", "Outstanding");        verify(hp, "cons", sid);        verify(hp, "dump", sid);        verify(hp, "wchs", "watching 1");        verify(hp, "wchp", sid);        verify(hp, "wchc", sid);        verify(hp, "dirs", "size");        zk.close();        verify(hp, "ruok", "imok");        verify(hp, "envi", "java.version");        verify(hp, "conf", "clientPort");        verify(hp, "stat", "Outstanding");        verify(hp, "srvr", "Outstanding");        verify(hp, "cons", "queued");        verify(hp, "dump", "Session");        verify(hp, "wchs", "watch");        verify(hp, "wchp", "");        verify(hp, "wchc", "");        verify(hp, "dirs", "size");        verify(hp, "srst", "reset");        verify(hp, "crst", "reset");        verify(hp, "stat", "Outstanding");        verify(hp, "srvr", "Outstanding");        verify(hp, "cons", "queued");        verify(hp, "mntr", "zk_version\t");    }}
verify
private voidf6142_1String hp, String cmd, String expected) throws IOException, SSLContextException
{    for (HostPort hpobj : parseHostPortList(hp)) {        String resp = send4LetterWord(hpobj.host, hpobj.port, cmd);                if (cmd.equals("dump")) {            assertTrue(resp.contains(expected) || resp.contains("Sessions with Ephemerals"));        } else {            assertTrue(resp.contains(expected));        }    }}
testFourLetterWords
public void zookeeper_f6143_0() throws Exception
{    verify("ruok", "imok");    verify("envi", "java.version");    verify("conf", "clientPort");    verify("stat", "Outstanding");    verify("srvr", "Outstanding");    verify("cons", "queued");    verify("dump", "Session");    verify("wchs", "watches");    verify("wchp", "");    verify("wchc", "");    verify("srst", "reset");    verify("crst", "reset");    verify("stat", "Outstanding");    verify("srvr", "Outstanding");    verify("cons", "queued");    verify("gtmk", "306");    verify("isro", "rw");    TestableZooKeeper zk = createClient();    String sid = getHexSessionId(zk.getSessionId());    verify("stat", "queued");    verify("srvr", "Outstanding");    verify("cons", sid);    verify("dump", sid);    verify("dirs", "size");    zk.getData("/", true, null);    verify("stat", "queued");    verify("srvr", "Outstanding");    verify("cons", sid);    verify("dump", sid);    verify("wchs", "watching 1");    verify("wchp", sid);    verify("wchc", sid);    verify("dirs", "size");    zk.close();    verify("ruok", "imok");    verify("envi", "java.version");    verify("conf", "clientPort");    verify("stat", "Outstanding");    verify("srvr", "Outstanding");    verify("cons", "queued");    verify("dump", "Session");    verify("wchs", "watch");    verify("wchp", "");    verify("wchc", "");    verify("srst", "reset");    verify("crst", "reset");    verify("stat", "Outstanding");    verify("srvr", "Outstanding");    verify("cons", "queued");    verify("mntr", "zk_server_state\tstandalone");    verify("mntr", "num_alive_connections");    verify("stat", "Connections");    verify("srvr", "Connections");    verify("dirs", "size");}
sendRequest
private String zookeeper_f6144_0(String cmd) throws IOException, SSLContextException
{    HostPort hpobj = ClientBase.parseHostPortList(hostPort).get(0);    return send4LetterWord(hpobj.host, hpobj.port, cmd);}
sendRequest
private String zookeeper_f6145_0(String cmd, int timeout) throws IOException, SSLContextException
{    HostPort hpobj = ClientBase.parseHostPortList(hostPort).get(0);    return send4LetterWord(hpobj.host, hpobj.port, cmd, false, timeout);}
verify
private voidf6146_1String cmd, String expected) throws IOException, SSLContextException
{    String resp = sendRequest(cmd);        assertTrue(resp.contains(expected));}
testValidateStatOutput
public void zookeeper_f6147_0() throws Exception
{    ZooKeeper zk1 = createClient();    ZooKeeper zk2 = createClient();    String resp = sendRequest("stat");    BufferedReader in = new BufferedReader(new StringReader(resp));    String line;        line = in.readLine();    assertTrue(Pattern.matches("^.*\\s\\d+\\.\\d+\\.\\d+-.*$", line));    assertTrue(Pattern.matches("^Clients:$", in.readLine()));    int count = 0;    while ((line = in.readLine()).length() > 0) {        count++;        assertTrue(Pattern.matches("^ /.*:\\d+\\[\\d+\\]\\(queued=\\d+,recved=\\d+,sent=\\d+\\)$", line));    }        assertTrue(count >= 2);    line = in.readLine();    assertTrue(Pattern.matches("^Latency min/avg/max: \\d+/-?[0-9]*.?[0-9]*/\\d+$", line));    line = in.readLine();    assertTrue(Pattern.matches("^Received: \\d+$", line));    line = in.readLine();    assertTrue(Pattern.matches("^Sent: \\d+$", line));    line = in.readLine();    assertTrue(Pattern.matches("^Connections: \\d+$", line));    line = in.readLine();    assertTrue(Pattern.matches("^Outstanding: \\d+$", line));    line = in.readLine();    assertTrue(Pattern.matches("^Zxid: 0x[\\da-fA-F]+$", line));    line = in.readLine();    assertTrue(Pattern.matches("^Mode: .*$", line));    line = in.readLine();    assertTrue(Pattern.matches("^Node count: \\d+$", line));    zk1.close();    zk2.close();}
testValidateConsOutput
public void zookeeper_f6148_0() throws Exception
{    ZooKeeper zk1 = createClient();    ZooKeeper zk2 = createClient();    String resp = sendRequest("cons");    BufferedReader in = new BufferedReader(new StringReader(resp));    String line;    int count = 0;    while ((line = in.readLine()) != null && line.length() > 0) {        count++;        assertTrue(line, Pattern.matches("^ /.*:\\d+\\[\\d+\\]\\(queued=\\d+,recved=\\d+,sent=\\d+.*\\)$", line));    }        assertTrue(count >= 2);    zk1.close();    zk2.close();}
testValidateSocketTimeout
public void zookeeper_f6149_0() throws Exception
{    /**     * testing positive scenario that even with timeout parameter the     * functionality works fine     */    String resp = sendRequest("isro", 2000);    assertTrue(resp.contains("rw"));}
testSetTraceMask
public void zookeeper_f6150_0() throws Exception
{    String gtmkResp = sendRequest("gtmk");    assertNotNull(gtmkResp);    gtmkResp = gtmkResp.trim();    assertFalse(gtmkResp.isEmpty());    long formerMask = Long.valueOf(gtmkResp);    try {        verify(buildSetTraceMaskRequest(0), "0");        verify("gtmk", "0");    } finally {                sendRequest(buildSetTraceMaskRequest(formerMask));    }}
buildSetTraceMaskRequest
private String zookeeper_f6151_0(long mask) throws IOException
{    ByteArrayOutputStream baos = null;    DataOutputStream dos = null;    try {        baos = new ByteArrayOutputStream();        dos = new DataOutputStream(baos);        dos.writeBytes("stmk");        dos.writeLong(mask);    } finally {        IOUtils.closeStream(dos);        IOUtils.closeStream(baos);    }    return new String(baos.toByteArray());}
testFourLetterWordsAllDisabledByDefault
public void zookeeper_f6152_0() throws Exception
{    stopServer();    FourLetterCommands.resetWhiteList();    System.setProperty("zookeeper.4lw.commands.whitelist", "stat");    startServer();        verifyAllCommandsFail();    TestableZooKeeper zk = createClient();    verifyAllCommandsFail();    zk.getData("/", true, null);    verifyAllCommandsFail();    zk.close();    verifyFuzzyMatch("stat", "Outstanding");    verifyAllCommandsFail();}
testFourLetterWordsEnableSomeCommands
public void zookeeper_f6153_0() throws Exception
{    stopServer();    FourLetterCommands.resetWhiteList();    System.setProperty("zookeeper.4lw.commands.whitelist", "stat, ruok, isro");    startServer();        verifyFuzzyMatch("stat", "Outstanding");    verifyExactMatch("ruok", "imok");    verifyExactMatch("isro", "rw");        verifyExactMatch("conf", generateExpectedMessage("conf"));    verifyExactMatch("cons", generateExpectedMessage("cons"));    verifyExactMatch("crst", generateExpectedMessage("crst"));    verifyExactMatch("dirs", generateExpectedMessage("dirs"));    verifyExactMatch("dump", generateExpectedMessage("dump"));    verifyExactMatch("envi", generateExpectedMessage("envi"));    verifyExactMatch("gtmk", generateExpectedMessage("gtmk"));    verifyExactMatch("stmk", generateExpectedMessage("stmk"));    verifyExactMatch("srst", generateExpectedMessage("srst"));    verifyExactMatch("wchc", generateExpectedMessage("wchc"));    verifyExactMatch("wchp", generateExpectedMessage("wchp"));    verifyExactMatch("wchs", generateExpectedMessage("wchs"));    verifyExactMatch("mntr", generateExpectedMessage("mntr"));}
testISROEnabledWhenReadOnlyModeEnabled
public void zookeeper_f6154_0() throws Exception
{    stopServer();    FourLetterCommands.resetWhiteList();    System.setProperty("zookeeper.4lw.commands.whitelist", "stat");    System.setProperty("readonlymode.enabled", "true");    startServer();    verifyExactMatch("isro", "rw");    System.clearProperty("readonlymode.enabled");}
testFourLetterWordsInvalidConfiguration
public void zookeeper_f6155_0() throws Exception
{    stopServer();    FourLetterCommands.resetWhiteList();    System.setProperty("zookeeper.4lw.commands.whitelist", "foo bar" + " foo,,, " + "bar :.,@#$%^&*() , , , , bar, bar, stat,        ");    startServer();        verifyAllCommandsFail();        verifyFuzzyMatch("stat", "Outstanding");}
testFourLetterWordsEnableAllCommandsThroughAsterisk
public void zookeeper_f6156_0() throws Exception
{    stopServer();    FourLetterCommands.resetWhiteList();    System.setProperty("zookeeper.4lw.commands.whitelist", "*");    startServer();    verifyAllCommandsSuccess();}
testFourLetterWordsEnableAllCommandsThroughExplicitList
public void zookeeper_f6157_0() throws Exception
{    stopServer();    FourLetterCommands.resetWhiteList();    System.setProperty("zookeeper.4lw.commands.whitelist", "ruok, envi, conf, stat, srvr, cons, dump," + "wchs, wchp, wchc, srst, crst, " + "dirs, mntr, gtmk, isro, stmk");    startServer();    verifyAllCommandsSuccess();}
verifyAllCommandsSuccess
private void zookeeper_f6158_0() throws Exception
{    verifyExactMatch("ruok", "imok");    verifyFuzzyMatch("envi", "java.version");    verifyFuzzyMatch("conf", "clientPort");    verifyFuzzyMatch("stat", "Outstanding");    verifyFuzzyMatch("srvr", "Outstanding");    verifyFuzzyMatch("cons", "queued");    verifyFuzzyMatch("dump", "Session");    verifyFuzzyMatch("wchs", "watches");    verifyFuzzyMatch("wchp", "");    verifyFuzzyMatch("wchc", "");    verifyFuzzyMatch("srst", "reset");    verifyFuzzyMatch("crst", "reset");    verifyFuzzyMatch("stat", "Outstanding");    verifyFuzzyMatch("srvr", "Outstanding");    verifyFuzzyMatch("cons", "queued");    verifyFuzzyMatch("gtmk", "306");    verifyFuzzyMatch("isro", "rw");    TestableZooKeeper zk = createClient();    String sid = getHexSessionId(zk.getSessionId());    verifyFuzzyMatch("stat", "queued");    verifyFuzzyMatch("srvr", "Outstanding");    verifyFuzzyMatch("cons", sid);    verifyFuzzyMatch("dump", sid);    verifyFuzzyMatch("dirs", "size");    zk.getData("/", true, null);    verifyFuzzyMatch("stat", "queued");    verifyFuzzyMatch("srvr", "Outstanding");    verifyFuzzyMatch("cons", sid);    verifyFuzzyMatch("dump", sid);    verifyFuzzyMatch("wchs", "watching 1");    verifyFuzzyMatch("wchp", sid);    verifyFuzzyMatch("wchc", sid);    verifyFuzzyMatch("dirs", "size");    zk.close();    verifyExactMatch("ruok", "imok");    verifyFuzzyMatch("envi", "java.version");    verifyFuzzyMatch("conf", "clientPort");    verifyFuzzyMatch("stat", "Outstanding");    verifyFuzzyMatch("srvr", "Outstanding");    verifyFuzzyMatch("cons", "queued");    verifyFuzzyMatch("dump", "Session");    verifyFuzzyMatch("wchs", "watch");    verifyFuzzyMatch("wchp", "");    verifyFuzzyMatch("wchc", "");    verifyFuzzyMatch("srst", "reset");    verifyFuzzyMatch("crst", "reset");    verifyFuzzyMatch("stat", "Outstanding");    verifyFuzzyMatch("srvr", "Outstanding");    verifyFuzzyMatch("cons", "queued");    verifyFuzzyMatch("mntr", "zk_server_state\tstandalone");    verifyFuzzyMatch("mntr", "num_alive_connections");    verifyFuzzyMatch("stat", "Connections");    verifyFuzzyMatch("srvr", "Connections");    verifyFuzzyMatch("dirs", "size");}
verifyAllCommandsFail
private void zookeeper_f6159_0() throws Exception
{    verifyExactMatch("ruok", generateExpectedMessage("ruok"));    verifyExactMatch("conf", generateExpectedMessage("conf"));    verifyExactMatch("cons", generateExpectedMessage("cons"));    verifyExactMatch("crst", generateExpectedMessage("crst"));    verifyExactMatch("dirs", generateExpectedMessage("dirs"));    verifyExactMatch("dump", generateExpectedMessage("dump"));    verifyExactMatch("envi", generateExpectedMessage("envi"));    verifyExactMatch("gtmk", generateExpectedMessage("gtmk"));    verifyExactMatch("stmk", generateExpectedMessage("stmk"));    verifyExactMatch("srst", generateExpectedMessage("srst"));    verifyExactMatch("wchc", generateExpectedMessage("wchc"));    verifyExactMatch("wchp", generateExpectedMessage("wchp"));    verifyExactMatch("wchs", generateExpectedMessage("wchs"));    verifyExactMatch("mntr", generateExpectedMessage("mntr"));    verifyExactMatch("isro", generateExpectedMessage("isro"));        verifyFuzzyMatch("srvr", "Outstanding");}
sendRequest
private String zookeeper_f6160_0(String cmd) throws IOException, SSLContextException
{    HostPort hpobj = ClientBase.parseHostPortList(hostPort).get(0);    return send4LetterWord(hpobj.host, hpobj.port, cmd);}
verifyFuzzyMatch
private voidf6161_1String cmd, String expected) throws IOException, SSLContextException
{    String resp = sendRequest(cmd);        assertTrue(resp.contains(expected));}
generateExpectedMessage
private String zookeeper_f6162_0(String command)
{    return command + " is not executed because it is not in the whitelist.";}
setUp
public void zookeeper_f6164_0() throws Exception
{    super.setUp();    zk = createClient();}
tearDown
public void zookeeper_f6165_0() throws Exception
{    super.tearDown();    zk.close();}
testChild
public void zookeeper_f6166_0() throws IOException, KeeperException, InterruptedException
{    String name = "/foo";    zk.create(name, name.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    String childname = name + "/bar";    zk.create(childname, childname.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);    Stat stat = new Stat();    List<String> s = zk.getChildren(name, false, stat);    assertEquals(stat.getCzxid(), stat.getMzxid());    assertEquals(stat.getCzxid() + 1, stat.getPzxid());    assertEquals(stat.getCtime(), stat.getMtime());    assertEquals(1, stat.getCversion());    assertEquals(0, stat.getVersion());    assertEquals(0, stat.getAversion());    assertEquals(0, stat.getEphemeralOwner());    assertEquals(name.length(), stat.getDataLength());    assertEquals(1, stat.getNumChildren());    assertEquals(s.size(), stat.getNumChildren());    s = zk.getChildren(childname, false, stat);    assertEquals(stat.getCzxid(), stat.getMzxid());    assertEquals(stat.getCzxid(), stat.getPzxid());    assertEquals(stat.getCtime(), stat.getMtime());    assertEquals(0, stat.getCversion());    assertEquals(0, stat.getVersion());    assertEquals(0, stat.getAversion());    assertEquals(zk.getSessionId(), stat.getEphemeralOwner());    assertEquals(childname.length(), stat.getDataLength());    assertEquals(0, stat.getNumChildren());    assertEquals(s.size(), stat.getNumChildren());}
testChildren
public void zookeeper_f6167_0() throws IOException, KeeperException, InterruptedException
{    String name = "/foo";    zk.create(name, name.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    List<String> children = new ArrayList<String>();    List<String> children_s = new ArrayList<String>();    for (int i = 0; i < 10; i++) {        String childname = name + "/bar" + i;        String childname_s = "bar" + i;        children.add(childname);        children_s.add(childname_s);    }    for (int i = 0; i < children.size(); i++) {        String childname = children.get(i);        zk.create(childname, childname.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);        Stat stat = new Stat();        List<String> s = zk.getChildren(name, false, stat);        assertEquals(stat.getCzxid(), stat.getMzxid());        assertEquals(stat.getCzxid() + i + 1, stat.getPzxid());        assertEquals(stat.getCtime(), stat.getMtime());        assertEquals(i + 1, stat.getCversion());        assertEquals(0, stat.getVersion());        assertEquals(0, stat.getAversion());        assertEquals(0, stat.getEphemeralOwner());        assertEquals(name.length(), stat.getDataLength());        assertEquals(i + 1, stat.getNumChildren());        assertEquals(s.size(), stat.getNumChildren());    }    List<String> p = zk.getChildren(name, false, null);    List<String> c_a = children_s;    List<String> c_b = p;    Collections.sort(c_a);    Collections.sort(c_b);    assertEquals(c_a.size(), 10);    assertEquals(c_a, c_b);}
testGetProposalFromTxn
public void zookeeper_f6168_0() throws Exception
{    File tmpDir = ClientBase.createTmpDir();    ClientBase.setupTestEnv();    ZooKeeperServer zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);    SyncRequestProcessor.setSnapCount(100);    final int PORT = Integer.parseInt(HOSTPORT.split(":")[1]);    ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);    f.startup(zks);    assertTrue("waiting for server being up ", ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT));    ZooKeeper zk = ClientBase.createZKClient(HOSTPORT);        Long[] zxids = new Long[MSG_COUNT];    try {        String data = "data";        byte[] bytes = data.getBytes();        for (int i = 0; i < MSG_COUNT; i++) {            Stat stat = new Stat();            zk.create("/invalidsnap-" + i, bytes, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);            zk.getData("/invalidsnap-" + i, null, stat);            zxids[i] = stat.getCzxid();        }    } finally {        zk.close();    }        f.shutdown();    zks.shutdown();    assertTrue("waiting for server to shutdown", ClientBase.waitForServerDown(HOSTPORT, CONNECTION_TIMEOUT));    zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);    zks.startdata();    ZKDatabase db = zks.getZKDatabase();            Iterator<Proposal> itr = db.getProposalsFromTxnLog(zxids[0], 10000000);    int createCount = 0;    ArrayList<Long> retrievedZxids = new ArrayList<Long>(MSG_COUNT);        while (itr.hasNext()) {        Proposal proposal = itr.next();        TxnHeader hdr = new TxnHeader();        Record rec = SerializeUtils.deserializeTxn(proposal.packet.getData(), hdr);        if (hdr.getType() == OpCode.create) {            retrievedZxids.add(hdr.getZxid());            createCount++;        }    }        assertTrue("Zxids missmatches", Arrays.equals(zxids, retrievedZxids.toArray(new Long[0])));        assertTrue("create proposal count == " + MSG_COUNT, (createCount == MSG_COUNT));            db.setSnapshotSizeFactor(0.33);    long sizeLimit = db.calculateTxnLogSizeLimit();    itr = db.getProposalsFromTxnLog(zxids[MSG_COUNT / 2], sizeLimit);    assertFalse("Expect empty proposal", (itr.hasNext()));    f.shutdown();    zks.shutdown();}
setUp
public voidf6169_1) throws Exception
{    setupTestEnv();    JMXEnv.setUp();    setUpAll();    port1 = PortAssignment.unique();    port2 = PortAssignment.unique();    port3 = PortAssignment.unique();    port4 = PortAssignment.unique();    port5 = PortAssignment.unique();    leport1 = PortAssignment.unique();    leport2 = PortAssignment.unique();    leport3 = PortAssignment.unique();    leport4 = PortAssignment.unique();    leport5 = PortAssignment.unique();    clientport1 = PortAssignment.unique();    clientport2 = PortAssignment.unique();    clientport3 = PortAssignment.unique();    clientport4 = PortAssignment.unique();    clientport5 = PortAssignment.unique();    hostPort = "127.0.0.1:" + clientport1 + ",127.0.0.1:" + clientport2 + ",127.0.0.1:" + clientport3 + ",127.0.0.1:" + clientport4 + ",127.0.0.1:" + clientport5;        s1dir = ClientBase.createTmpDir();    s2dir = ClientBase.createTmpDir();    s3dir = ClientBase.createTmpDir();    s4dir = ClientBase.createTmpDir();    s5dir = ClientBase.createTmpDir();    String config = "group.1=1:2:3\n" + "group.2=4:5\n" + "weight.1=1\n" + "weight.2=1\n" + "weight.3=1\n" + "weight.4=0\n" + "weight.5=0\n" + "server.1=127.0.0.1:" + port1 + ":" + leport1 + ";" + clientport1 + "\n" + "server.2=127.0.0.1:" + port2 + ":" + leport2 + ";" + clientport2 + "\n" + "server.3=127.0.0.1:" + port3 + ":" + leport3 + ";" + clientport3 + "\n" + "server.4=127.0.0.1:" + port4 + ":" + leport4 + ";" + clientport4 + "\n" + "server.5=127.0.0.1:" + port5 + ":" + leport5 + ";" + clientport5 + "\n";    ByteArrayInputStream is = new ByteArrayInputStream(config.getBytes());    this.qp = new Properties();    qp.load(is);    startServers();    cht.hostPort = hostPort;    cht.setUpAll();    }
startServers
 void zookeeper_f6170_0() throws Exception
{    startServers(false);}
startServers
 voidf6171_1boolean withObservers) throws Exception
{    int tickTime = 2000;    int initLimit = 3;    int syncLimit = 3;    int connectToLearnerMasterLimit = 3;    HashMap<Long, QuorumServer> peers = new HashMap<>();    peers.put(Long.valueOf(1), new QuorumServer(1, new InetSocketAddress("127.0.0.1", port1), new InetSocketAddress("127.0.0.1", leport1), new InetSocketAddress("127.0.0.1", clientport1)));    peers.put(Long.valueOf(2), new QuorumServer(2, new InetSocketAddress("127.0.0.1", port2), new InetSocketAddress("127.0.0.1", leport2), new InetSocketAddress("127.0.0.1", clientport2)));    peers.put(Long.valueOf(3), new QuorumServer(3, new InetSocketAddress("127.0.0.1", port3), new InetSocketAddress("127.0.0.1", leport3), new InetSocketAddress("127.0.0.1", clientport3)));    peers.put(Long.valueOf(4), new QuorumServer(4, new InetSocketAddress("127.0.0.1", port4), new InetSocketAddress("127.0.0.1", leport4), new InetSocketAddress("127.0.0.1", clientport4), withObservers ? QuorumPeer.LearnerType.OBSERVER : QuorumPeer.LearnerType.PARTICIPANT));    peers.put(Long.valueOf(5), new QuorumServer(5, new InetSocketAddress("127.0.0.1", port5), new InetSocketAddress("127.0.0.1", leport5), new InetSocketAddress("127.0.0.1", clientport5), withObservers ? QuorumPeer.LearnerType.OBSERVER : QuorumPeer.LearnerType.PARTICIPANT));        if (withObservers) {        qp.setProperty("server.4", "127.0.0.1:" + port4 + ":" + leport4 + ":observer" + ";" + clientport4);        qp.setProperty("server.5", "127.0.0.1:" + port5 + ":" + leport5 + ":observer" + ";" + clientport5);    }    QuorumHierarchical hq1 = new QuorumHierarchical(qp);    s1 = new QuorumPeer(peers, s1dir, s1dir, clientport1, 3, 1, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit, hq1);    assertEquals(clientport1, s1.getClientPort());        QuorumHierarchical hq2 = new QuorumHierarchical(qp);    s2 = new QuorumPeer(peers, s2dir, s2dir, clientport2, 3, 2, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit, hq2);    assertEquals(clientport2, s2.getClientPort());        QuorumHierarchical hq3 = new QuorumHierarchical(qp);    s3 = new QuorumPeer(peers, s3dir, s3dir, clientport3, 3, 3, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit, hq3);    assertEquals(clientport3, s3.getClientPort());        QuorumHierarchical hq4 = new QuorumHierarchical(qp);    s4 = new QuorumPeer(peers, s4dir, s4dir, clientport4, 3, 4, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit, hq4);    if (withObservers) {        s4.setLearnerType(QuorumPeer.LearnerType.OBSERVER);    }    assertEquals(clientport4, s4.getClientPort());        QuorumHierarchical hq5 = new QuorumHierarchical(qp);    s5 = new QuorumPeer(peers, s5dir, s5dir, clientport5, 3, 5, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit, hq5);    if (withObservers) {        s5.setLearnerType(QuorumPeer.LearnerType.OBSERVER);    }    assertEquals(clientport5, s5.getClientPort());        s1.start();        s2.start();        s3.start();        s4.start();        s5.start();            for (String hp : hostPort.split(",")) {        assertTrue("waiting for server up", ClientBase.waitForServerUp(hp, CONNECTION_TIMEOUT));            }    final int numberOfPeers = 5;        JMXEnv.dump();        Set<String> ensureNames = new LinkedHashSet<String>();    for (int i = 1; i <= numberOfPeers; i++) {        ensureNames.add("InMemoryDataTree");    }    for (int i = 1; i <= numberOfPeers; i++) {        ensureNames.add("name0=ReplicatedServer_id" + i + ",name1=replica." + i + ",name2=");    }    for (int i = 1; i <= numberOfPeers; i++) {        for (int j = 1; j <= numberOfPeers; j++) {            ensureNames.add("name0=ReplicatedServer_id" + i + ",name1=replica." + j);        }    }    for (int i = 1; i <= numberOfPeers; i++) {        ensureNames.add("name0=ReplicatedServer_id" + i);    }    JMXEnv.ensureAll(ensureNames.toArray(new String[ensureNames.size()]));    for (int i = 1; i <= numberOfPeers; i++) {                String bean = MBeanRegistry.DOMAIN + ":name0=ReplicatedServer_id" + i + ",name1=replica." + i;        JMXEnv.ensureBeanAttribute(bean, "ConfigVersion");        JMXEnv.ensureBeanAttribute(bean, "LearnerType");        JMXEnv.ensureBeanAttribute(bean, "ClientAddress");        JMXEnv.ensureBeanAttribute(bean, "ElectionAddress");        JMXEnv.ensureBeanAttribute(bean, "QuorumSystemInfo");        JMXEnv.ensureBeanAttribute(bean, "Leader");    }    for (int i = 1; i <= numberOfPeers; i++) {        for (int j = 1; j <= numberOfPeers; j++) {            if (j != i) {                                String bean = MBeanRegistry.DOMAIN + ":name0=ReplicatedServer_id" + i + ",name1=replica." + j;                JMXEnv.ensureBeanAttribute(bean, "Name");                JMXEnv.ensureBeanAttribute(bean, "LearnerType");                JMXEnv.ensureBeanAttribute(bean, "ClientAddress");                JMXEnv.ensureBeanAttribute(bean, "ElectionAddress");                JMXEnv.ensureBeanAttribute(bean, "QuorumAddress");                JMXEnv.ensureBeanAttribute(bean, "Leader");            }        }    }}
tearDown
public voidf6172_1) throws Exception
{        cht.tearDownAll();        shutdown(s1);        shutdown(s2);        shutdown(s3);        shutdown(s4);        shutdown(s5);    for (String hp : hostPort.split(",")) {        assertTrue("waiting for server down", ClientBase.waitForServerDown(hp, ClientBase.CONNECTION_TIMEOUT));            }    JMXEnv.tearDown();}
shutdown
protected void zookeeper_f6173_0(QuorumPeer qp)
{    QuorumBase.shutdown(qp);}
createClient
protected TestableZooKeeper zookeeper_f6174_0() throws IOException, InterruptedException
{    return createClient(hostPort);}
createClient
protected TestableZooKeeper zookeeper_f6175_0(String hp) throws IOException, InterruptedException
{    CountdownWatcher watcher = new CountdownWatcher();    return createClient(watcher, hp);}
testHierarchicalQuorum
public void zookeeper_f6176_0() throws Throwable
{    cht.runHammer(5, 10);}
incOutstanding
 synchronized void zookeeper_f6177_0()
{    outstanding++;}
decOutstanding
 synchronized void zookeeper_f6178_0()
{    outstanding--;    notifyAll();}
waitOutstanding
 synchronized void zookeeper_f6179_0() throws InterruptedException
{    while (outstanding > 0) {        wait();    }}
run
public voidf6180_1) throws InterruptedException, KeeperException
{    try {                doCreate();                while (true) {                        doPopulate();            waitOutstanding();                        readAll();            waitOutstanding();        }    } finally {            }}
readAll
 void zookeeper_f6181_0()
{    for (int i = 0; i < count; i++) {        String cpath = path + "/" + i;        zk.getData(cpath, false, this, null);        incOutstanding();    }}
doCreate
 voidf6182_1) throws InterruptedException, KeeperException
{        try {        zk.create(path, null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    } catch (KeeperException.NodeExistsException e) {        }    iteration++;    byte[] v = ("" + iteration).getBytes();        for (int i = 0; i < count; i++) {        String cpath = path + "/" + i;        try {            if (i % 10 == 0) {                            }            zk.create(cpath, v, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        } catch (KeeperException.NodeExistsException e) {                }        lastValue.put(cpath, v);    }}
doPopulate
 void zookeeper_f6183_0()
{    iteration++;    byte[] v = ("" + iteration).getBytes();    for (int i = 0; i < count; i++) {        String cpath = path + "/" + i;        zk.setData(cpath, v, -1, this, v);        incOutstanding();    }}
ensureConnected
 synchronized void zookeeper_f6184_0()
{    while (zk.getState() != ZooKeeper.States.CONNECTED) {        try {            wait();        } catch (InterruptedException e) {            return;        }    }}
main
public static void zookeeper_f6185_0(String[] args)
{    if (args.length < 3) {        System.err.println("USAGE: IntegrityCheck zookeeperHostPort znode #children");        return;    }    int childrenCount = 0;    try {        childrenCount = Integer.parseInt(args[2]);    } catch (NumberFormatException e) {        e.printStackTrace();        System.exit(ExitCode.UNEXPECTED_ERROR.getValue());    }    try {        final IntegrityCheck ctest = new IntegrityCheck(args[0], args[1], childrenCount);        Runtime.getRuntime().addShutdownHook(new Thread() {            public void run() {                System.out.println(new Date().toString() + ": Error count = " + ctest.errorCount);            }        });        while (true) {            try {                ctest.ensureConnected();                ctest.run();            } catch (Exception e) {                e.printStackTrace();            }        }    } catch (Exception e) {        e.printStackTrace();        System.exit(ExitCode.INVALID_INVOCATION.getValue());    }}
run
public void zookeeper_f6186_0()
{    System.out.println(new Date().toString() + ": Error count = " + ctest.errorCount);}
processResult
public void zookeeper_f6187_0(int rc, String path, Object ctx, Stat stat)
{    if (rc == 0) {        lastValue.put(path, (byte[]) ctx);    }    decOutstanding();}
processResult
public voidf6188_1int rc, String path, Object ctx, byte[] data, Stat stat)
{    if (rc == 0) {        String string = new String(data);        String lastString = null;        byte[] v = lastValue.get(path);        if (v != null) {            lastString = new String(v);        }        if (lastString != null && Integer.parseInt(string) < Integer.parseInt(lastString)) {                        errorCount++;        }        lastValue.put(path, (byte[]) ctx);    }    decOutstanding();}
testLogFormatter
public void zookeeper_f6189_0() throws Exception
{    File snapDir = new File(testData, "invalidsnap");    File logfile = new File(new File(snapDir, "version-2"), "log.274");    String[] args = { logfile.getCanonicalFile().toString() };    org.apache.zookeeper.server.LogFormatter.main(args);}
testSnapshotFormatter
public void zookeeper_f6190_0() throws Exception
{    File snapDir = new File(testData, "invalidsnap");    File snapfile = new File(new File(snapDir, "version-2"), "snapshot.272");    String[] args = { snapfile.getCanonicalFile().toString() };    SnapshotFormatter.main(args);}
testSnapshotFormatterWithNull
public void zookeeper_f6191_0() throws Exception
{    File snapDir = new File(testData, "invalidsnap");    File snapfile = new File(new File(snapDir, "version-2"), "snapshot.273");    String[] args = { snapfile.getCanonicalFile().toString() };    SnapshotFormatter.main(args);}
testSnapshot
public voidf6192_1) throws Exception
{    File snapDir = new File(testData, "invalidsnap");    ZooKeeperServer zks = new ZooKeeperServer(snapDir, snapDir, 3000);    SyncRequestProcessor.setSnapCount(1000);    final int PORT = Integer.parseInt(HOSTPORT.split(":")[1]);    ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);    f.startup(zks);        assertTrue("waiting for server being up", ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT));    ZooKeeper zk = ClientBase.createZKClient(HOSTPORT);    try {                        assertTrue(zk.exists("/9/9/8", false) != null);    } finally {        zk.close();    }    f.shutdown();    zks.shutdown();    assertTrue("waiting for server down", ClientBase.waitForServerDown(HOSTPORT, ClientBase.CONNECTION_TIMEOUT));}
setUp
public static void zookeeper_f6193_0() throws IOException
{    MBeanServer mbs = MBeanRegistry.getInstance().getPlatformMBeanServer();    JMXServiceURL url = new JMXServiceURL("service:jmx:rmi://127.0.0.1");    cs = JMXConnectorServerFactory.newJMXConnectorServer(url, null, mbs);    cs.start();    JMXServiceURL addr = cs.getAddress();    cc = JMXConnectorFactory.connect(addr);}
tearDown
public static voidf6194_1)
{    try {        if (cc != null) {            cc.close();        }    } catch (IOException e) {            }    cc = null;    try {        if (cs != null) {            cs.stop();        }    } catch (IOException e) {            }    cs = null;}
conn
public static MBeanServerConnection zookeeper_f6195_0() throws IOException
{    return cc.getMBeanServerConnection();}
ensureAll
public static Set<ObjectName>f6196_1String... expectedNames) throws IOException, InterruptedException
{    Set<ObjectName> beans;    Set<ObjectName> found;    int nTry = 0;    do {        if (nTry++ > 0) {            Thread.sleep(100);        }        try {            beans = conn().queryNames(new ObjectName(MBeanRegistry.DOMAIN + ":*"), null);        } catch (MalformedObjectNameException e) {            throw new RuntimeException(e);        }        found = new HashSet<ObjectName>();        for (String name : expectedNames) {                        for (ObjectName bean : beans) {                if (bean.toString().contains(name)) {                                        found.add(bean);                    break;                }            }            beans.removeAll(found);        }    } while ((expectedNames.length != found.size()) && (nTry < 600));    assertEquals("expected " + Arrays.toString(expectedNames), expectedNames.length, found.size());    return beans;}
ensureOnly
public static Set<ObjectName>f6197_1String... expectedNames) throws IOException, InterruptedException
{        Set<ObjectName> beans = ensureAll(expectedNames);    for (ObjectName bean : beans) {            }    assertEquals(0, beans.size());    return beans;}
ensureNone
public static voidf6198_1String... expectedNames) throws IOException, InterruptedException
{    Set<ObjectName> beans;    int nTry = 0;    boolean foundUnexpected = false;    String unexpectedName = "";    do {        if (nTry++ > 0) {            Thread.sleep(100);        }        try {            beans = conn().queryNames(new ObjectName(MBeanRegistry.DOMAIN + ":*"), null);        } catch (MalformedObjectNameException e) {            throw new RuntimeException(e);        }        foundUnexpected = false;        for (String name : expectedNames) {            for (ObjectName bean : beans) {                if (bean.toString().contains(name)) {                                        foundUnexpected = true;                    unexpectedName = name + " " + bean.toString();                    break;                }            }            if (foundUnexpected) {                break;            }        }    } while ((foundUnexpected) && (nTry < 600));    if (foundUnexpected) {                for (ObjectName bean : beans) {                    }        fail(unexpectedName);    }}
dump
public static voidf6199_1) throws IOException
{        Set<ObjectName> beans;    try {        beans = conn().queryNames(new ObjectName(MBeanRegistry.DOMAIN + ":*"), null);    } catch (MalformedObjectNameException e) {        throw new RuntimeException(e);    }    for (ObjectName bean : beans) {            }}
ensureParent
public static Set<ObjectName>f6200_1String... expectedNames) throws IOException, InterruptedException
{        Set<ObjectName> beans;    int nTry = 0;    Set<ObjectName> found = new HashSet<ObjectName>();    do {        if (nTry++ > 0) {            Thread.sleep(500);        }        try {            beans = conn().queryNames(new ObjectName(MBeanRegistry.DOMAIN + ":*"), null);        } catch (MalformedObjectNameException e) {            throw new RuntimeException(e);        }        found.clear();        for (String name : expectedNames) {                        for (ObjectName bean : beans) {                                if (compare(bean.toString(), name)) {                                        found.add(bean);                    break;                }            }            beans.removeAll(found);        }    } while (expectedNames.length != found.size() && nTry < 120);    assertEquals("expected " + Arrays.toString(expectedNames), expectedNames.length, found.size());    return beans;}
ensureBeanAttribute
public static Objectf6201_1String expectedName, String expectedAttribute) throws Exception
{    String value = "";        Set<ObjectName> beans;    int nTry = 0;    do {        if (nTry++ > 0) {            Thread.sleep(500);        }        try {            beans = conn().queryNames(new ObjectName(MBeanRegistry.DOMAIN + ":*"), null);        } catch (MalformedObjectNameException e) {            throw new RuntimeException(e);        }                for (ObjectName bean : beans) {                        if (bean.toString().equals(expectedName)) {                                return conn().getAttribute(bean, expectedAttribute);            }        }    } while (nTry < 120);    fail("Failed to find bean:" + expectedName + ", attribute:" + expectedAttribute);    return value;}
compare
private static boolean zookeeper_f6202_0(String bean, String name)
{    String[] names = bean.split("=");    return names.length > 0 && names[names.length - 1].contains(name);}
getServerBeans
public static List<ObjectName>f6203_1) throws IOException
{    ArrayList<ObjectName> serverBeans = new ArrayList<>();    Set<ObjectName> beans;    try {        beans = conn().queryNames(new ObjectName(MBeanRegistry.DOMAIN + ":*"), null);    } catch (MalformedObjectNameException e) {        throw new RuntimeException(e);    }    for (ObjectName bean : beans) {        String name = bean.toString();                for (Pattern pattern : beanPatterns) {            if (pattern.matcher(name).find()) {                serverBeans.add(bean);            }        }    }    return serverBeans;}
getServerBean
public static ObjectName zookeeper_f6204_0() throws Exception
{    List<ObjectName> serverBeans = getServerBeans();    if (serverBeans.size() != 1) {        throw new RuntimeException("Unable to find one and only one server bean");    }    return serverBeans.get(0);}
testIntConversion
public void zookeeper_f6205_0()
{        EnumSet<KeeperState> allStates = EnumSet.allOf(KeeperState.class);    for (KeeperState as : allStates) {        assertEquals(as, KeeperState.fromInt(as.getIntValue()));    }}
testInvalidIntConversion
public void zookeeper_f6206_0()
{    try {        KeeperState.fromInt(324142);        fail("Was able to create an invalid KeeperState via an integer");    } catch (RuntimeException re) {        }}
testDeprecatedCodeOkInSwitch
public void zookeeper_f6207_0()
{    int test = 1;    switch(test) {        case Code.Ok:            assertTrue(true);            break;    }}
testCodeOKInSwitch
public void zookeeper_f6208_0()
{    Code test = Code.OK;    switch(test) {        case OK:            assertTrue(true);            break;    }}
createNodePrintAcl
public voidf6209_1ZooKeeper zk, String path, String testName)
{    try {                zk.create(path, null, Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT);        List<ACL> acls = zk.getACL(path, null);                for (ACL acl : acls) {                    }    } catch (Exception e) {            }}
preAuth
public void zookeeper_f6210_0() throws Exception
{    ZooKeeper zk = createClient();    zk.addAuthInfo("key", "25".getBytes());    try {        createNodePrintAcl(zk, "/pre", "testPreAuth");        zk.setACL("/", Ids.CREATOR_ALL_ACL, -1);        zk.getChildren("/", false);        zk.create("/abc", null, Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT);        zk.setData("/abc", "testData1".getBytes(), -1);        zk.create("/key", null, Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT);        zk.setData("/key", "5".getBytes(), -1);        Thread.sleep(1000);    } catch (KeeperException e) {        fail("test failed :" + e);    } finally {        zk.close();    }}
missingAuth
public void zookeeper_f6211_0() throws Exception
{    ZooKeeper zk = createClient();    try {        zk.getData("/abc", false, null);        fail("Should not be able to get data");    } catch (KeeperException correct) {        }    try {        zk.setData("/abc", "testData2".getBytes(), -1);        fail("Should not be able to set data");    } catch (KeeperException correct) {        } finally {        zk.close();    }}
validAuth
public void zookeeper_f6212_0() throws Exception
{    ZooKeeper zk = createClient();        zk.addAuthInfo("key", "25".getBytes());    try {        createNodePrintAcl(zk, "/valid", "testValidAuth");        zk.getData("/abc", false, null);        zk.setData("/abc", "testData3".getBytes(), -1);    } catch (KeeperException.AuthFailedException e) {        fail("test failed :" + e);    } finally {        zk.close();    }}
validAuth2
public void zookeeper_f6213_0() throws Exception
{    ZooKeeper zk = createClient();        zk.addAuthInfo("key", "125".getBytes());    try {        createNodePrintAcl(zk, "/valid2", "testValidAuth2");        zk.getData("/abc", false, null);        zk.setData("/abc", "testData3".getBytes(), -1);    } catch (KeeperException.AuthFailedException e) {        fail("test failed :" + e);    } finally {        zk.close();    }}
testAuth
public void zookeeper_f6214_0() throws Exception
{            preAuth();    missingAuth();    validAuth();    validAuth2();}
setUp
public void zookeeper_f6215_0() throws Exception
{    qu = new QuorumUtil(1);}
tearDown
public void zookeeper_f6216_0() throws Exception
{    qu.shutdownAll();}
testExpiredSessionWithLocalSession
public void zookeeper_f6217_0() throws Exception
{    testCreateEphemeral(true);}
testExpiredSessionWithoutLocalSession
public void zookeeper_f6218_0() throws Exception
{    testCreateEphemeral(false);}
testCreateEphemeral
public voidf6219_1boolean localSessionEnabled) throws Exception
{    if (localSessionEnabled) {        qu.enableLocalSession(true);    }    qu.startAll();    QuorumPeer leader = qu.getLeaderQuorumPeer();    ZooKeeper zk = ClientBase.createZKClient(qu.getConnectString(leader));    CreateRequest createRequest = new CreateRequest("/impossible", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL.toFlag());    ByteArrayOutputStream baos = new ByteArrayOutputStream();    BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos);    createRequest.serialize(boa, "request");    ByteBuffer bb = ByteBuffer.wrap(baos.toByteArray());        long sid = qu.getFollowerQuorumPeers().get(0).getActiveServer().getServerId();    long fakeSessionId = (sid << 56) + 1;        Request request = new Request(null, fakeSessionId, 0, OpCode.create, bb, new ArrayList<Id>());        leader.getActiveServer().submitRequest(request);        zk.create("/ok", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    Stat stat = zk.exists("/impossible", null);    assertEquals("Node from fake session get created", null, stat);}
testCreatePersistent
public voidf6220_1) throws Exception
{    qu.enableLocalSession(true);    qu.startAll();    QuorumPeer leader = qu.getLeaderQuorumPeer();    ZooKeeper zk = ClientBase.createZKClient(qu.getConnectString(leader));    CreateRequest createRequest = new CreateRequest("/success", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT.toFlag());    ByteArrayOutputStream baos = new ByteArrayOutputStream();    BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos);    createRequest.serialize(boa, "request");    ByteBuffer bb = ByteBuffer.wrap(baos.toByteArray());        long sid = qu.getFollowerQuorumPeers().get(0).getActiveServer().getServerId();    long locallSession = (sid << 56) + 1;        Request request = new Request(null, locallSession, 0, OpCode.create, bb, new ArrayList<Id>());        leader.getActiveServer().submitRequest(request);        zk.create("/ok", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    Stat stat = zk.exists("/success", null);    assertTrue("Request from local sesson failed", stat != null);}
testTxnFailure
public voidf6221_1) throws Exception
{    try {        ZooKeeperServer.setDigestEnabled(true);        long count = 1;        File tmpDir = ClientBase.createTmpDir();        FileTxnSnapLog logFile = new FileTxnSnapLog(tmpDir, tmpDir);        DataTree dt = new DataTree();        dt.createNode("/test", new byte[0], null, 0, -1, 1, 1);        for (count = 1; count <= 3; count++) {            dt.createNode("/test/" + count, new byte[0], null, 0, -1, count, Time.currentElapsedTime());        }        long digestBefore = dt.getTreeDigest();        DataNode zk = dt.getNode("/test");                        doOp(logFile, ZooDefs.OpCode.create, "/test/" + (count - 1), dt, zk, -1);        assertNotEquals(digestBefore, dt.getTreeDigest());                digestBefore = dt.getTreeDigest();        doOp(logFile, ZooDefs.OpCode.create, "/test/" + (count - 1), dt, zk, zk.stat.getCversion() + 1);        assertNotEquals(digestBefore, dt.getTreeDigest());                digestBefore = dt.getTreeDigest();        doOp(logFile, ZooDefs.OpCode.multi, "/test/" + (count - 1), dt, zk, zk.stat.getCversion() + 1);        assertNotEquals(digestBefore, dt.getTreeDigest());                digestBefore = dt.getTreeDigest();        doOp(logFile, ZooDefs.OpCode.multi, "/test/" + (count - 1), dt, zk, -1);        assertNotEquals(digestBefore, dt.getTreeDigest());                    } finally {        ZooKeeperServer.setDigestEnabled(false);    }}
doOp
private voidf6222_1FileTxnSnapLog logFile, int type, String path, DataTree dt, DataNode parent, int cversion) throws Exception
{    int lastSlash = path.lastIndexOf('/');    String parentName = path.substring(0, lastSlash);    int prevCversion = parent.stat.getCversion();    long prevPzxid = parent.stat.getPzxid();    List<String> child = dt.getChildren(parentName, null, null);    StringBuilder childStr = new StringBuilder();    for (String s : child) {        childStr.append(s).append(" ");    }            Record txn = null;    TxnHeader txnHeader = null;    if (type == ZooDefs.OpCode.delete) {        txn = new DeleteTxn(path);        txnHeader = new TxnHeader(0xabcd, 0x123, prevPzxid + 1, Time.currentElapsedTime(), ZooDefs.OpCode.delete);    } else if (type == ZooDefs.OpCode.create) {        txnHeader = new TxnHeader(0xabcd, 0x123, prevPzxid + 1, Time.currentElapsedTime(), ZooDefs.OpCode.create);        txn = new CreateTxn(path, new byte[0], null, false, cversion);    } else if (type == ZooDefs.OpCode.multi) {        txnHeader = new TxnHeader(0xabcd, 0x123, prevPzxid + 1, Time.currentElapsedTime(), ZooDefs.OpCode.create);        txn = new CreateTxn(path, new byte[0], null, false, cversion);        List<Txn> txnList = new ArrayList<Txn>();        ByteArrayOutputStream baos = new ByteArrayOutputStream();        BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos);        txn.serialize(boa, "request");        ByteBuffer bb = ByteBuffer.wrap(baos.toByteArray());        Txn txact = new Txn(ZooDefs.OpCode.create, bb.array());        txnList.add(txact);        txn = new MultiTxn(txnList);        txnHeader = new TxnHeader(0xabcd, 0x123, prevPzxid + 1, Time.currentElapsedTime(), ZooDefs.OpCode.multi);    }    logFile.processTransaction(txnHeader, dt, null, txn);    int newCversion = parent.stat.getCversion();    long newPzxid = parent.stat.getPzxid();    child = dt.getChildren(parentName, null, null);    childStr = new StringBuilder();    for (String s : child) {        childStr.append(s).append(" ");    }            assertTrue(type + " <cversion, pzxid> verification failed. Expected: <" + (prevCversion + 1) + ", " + (prevPzxid + 1) + ">, found: <" + newCversion + ", " + newPzxid + ">", (newCversion == prevCversion + 1 && newPzxid == prevPzxid + 1));}
testPad
public voidf6223_1) throws Exception
{    File tmpDir = ClientBase.createTmpDir();    FileTxnLog txnLog = new FileTxnLog(tmpDir);    TxnHeader txnHeader = new TxnHeader(0xabcd, 0x123, 0x123, Time.currentElapsedTime(), ZooDefs.OpCode.create);    Record txn = new CreateTxn("/Test", new byte[0], null, false, 1);    txnLog.append(txnHeader, txn);    FileInputStream in = new FileInputStream(tmpDir.getPath() + "/log." + Long.toHexString(txnHeader.getZxid()));    BinaryInputArchive ia = BinaryInputArchive.getArchive(in);    FileHeader header = new FileHeader();    header.deserialize(ia, "fileheader");        assertTrue("Missing magic number ", header.getMagic() == FileTxnLog.TXNLOG_MAGIC);}
setUp
public void zookeeper_f6224_0() throws Exception
{    SyncRequestProcessor.setSnapCount(50);    super.setUp();}
testLoad
public voidf6225_1) throws Exception
{        ZooKeeper zk = createZKClient(hostPort);    try {        for (int i = 0; i < NUM_MESSAGES; i++) {            zk.create("/invalidsnap-" + i, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        }    } finally {        zk.close();    }    stopServer();        File logDir = new File(tmpDir, FileTxnSnapLog.version + FileTxnSnapLog.VERSION);    FileTxnLog txnLog = new FileTxnLog(logDir);    TxnIterator itr = txnLog.read(0);        FileTxnIterator fileItr = (FileTxnIterator) itr;    long storageSize = fileItr.getStorageSize();        assertTrue("Storage size is greater than zero ", (storageSize > 0));    long expectedZxid = 0;    long lastZxid = 0;    TxnHeader hdr;    do {        hdr = itr.getHeader();        expectedZxid++;        assertTrue("not the same transaction. lastZxid=" + lastZxid + ", zxid=" + hdr.getZxid(), lastZxid != hdr.getZxid());        assertTrue("excepting next transaction. expected=" + expectedZxid + ", retrieved=" + hdr.getZxid(), (hdr.getZxid() == expectedZxid));        lastZxid = hdr.getZxid();    } while (itr.next());    assertTrue("processed all transactions. " + expectedZxid + " == " + TOTAL_TRANSACTIONS, (expectedZxid == TOTAL_TRANSACTIONS));}
testLoadFailure
public void zookeeper_f6226_0() throws Exception
{        ZooKeeper zk = createZKClient(hostPort);    try {        for (int i = 0; i < NUM_MESSAGES; i++) {            zk.create("/data-", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);        }    } finally {        zk.close();    }    stopServer();    File logDir = new File(tmpDir, FileTxnSnapLog.version + FileTxnSnapLog.VERSION);    File[] logFiles = FileTxnLog.getLogFiles(logDir.listFiles(), 0);        assertTrue(logFiles.length > NUM_MESSAGES / 100);        assertTrue("delete the first log file", logFiles[0].delete());        long secondStartZxid = Util.getZxidFromName(logFiles[1].getName(), "log");    FileTxnLog txnLog = new FileTxnLog(logDir);    TxnIterator itr = txnLog.read(1, false);            assertEquals(secondStartZxid, itr.getHeader().getZxid());    itr = txnLog.read(secondStartZxid, false);    assertEquals(secondStartZxid, itr.getHeader().getZxid());    assertTrue(itr.next());            long nextZxid = itr.getHeader().getZxid();    itr = txnLog.read(nextZxid, false);    assertEquals(secondStartZxid, itr.getHeader().getZxid());            long thirdStartZxid = Util.getZxidFromName(logFiles[2].getName(), "log");    itr = txnLog.read(thirdStartZxid, false);    assertEquals(secondStartZxid, itr.getHeader().getZxid());    assertTrue(itr.next());    nextZxid = itr.getHeader().getZxid();    itr = txnLog.read(nextZxid, false);    assertEquals(secondStartZxid, itr.getHeader().getZxid());}
testRestore
public voidf6227_1) throws Exception
{        ZooKeeper zk = createZKClient(hostPort);    String lastPath = null;    try {        zk.create("/invalidsnap", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        for (int i = 0; i < NUM_MESSAGES; i++) {            lastPath = zk.create("/invalidsnap/test-", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);        }    } finally {        zk.close();    }    String[] tokens = lastPath.split("-");    String expectedPath = "/invalidsnap/test-" + String.format("%010d", (Integer.parseInt(tokens[1])) + 1);    ZooKeeperServer zks = serverFactory.getZooKeeperServer();    long eZxid = zks.getZKDatabase().getDataTreeLastProcessedZxid();        zks.getZKDatabase().setlastProcessedZxid(zks.getZKDatabase().getDataTreeLastProcessedZxid() - 10);            zks.takeSnapshot();    zks.shutdown();    stopServer();    startServer();    zks = serverFactory.getZooKeeperServer();    long fZxid = zks.getZKDatabase().getDataTreeLastProcessedZxid();        assertTrue("Restore failed expected zxid=" + eZxid + " found=" + fZxid, fZxid == eZxid);    zk = createZKClient(hostPort);            String[] children;    String path;    try {        children = zk.getChildren("/invalidsnap", false).toArray(new String[0]);        path = zk.create("/invalidsnap/test-", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);    } finally {        zk.close();    }        assertTrue("Error in sequential znode creation expected " + expectedPath + " found " + path, path.equals(expectedPath));    assertTrue("Unexpected number of children " + children.length + " expected " + NUM_MESSAGES, (children.length == NUM_MESSAGES));}
testRestoreWithTransactionErrors
public voidf6228_1) throws Exception
{        ZooKeeper zk = createZKClient(hostPort);    try {        for (int i = 0; i < NUM_MESSAGES; i++) {            try {                zk.create("/invaliddir/test-", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);            } catch (NoNodeException e) {                        }        }    } finally {        zk.close();    }        ZooKeeperServer zks = serverFactory.getZooKeeperServer();    zks.getZKDatabase().setlastProcessedZxid(zks.getZKDatabase().getDataTreeLastProcessedZxid() - 10);            zks.takeSnapshot();    zks.shutdown();    stopServer();    zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);    startServer();}
testDatadirAutocreate
public voidf6229_1) throws Exception
{    stopServer();    try {                System.setProperty(FileTxnSnapLog.ZOOKEEPER_DATADIR_AUTOCREATE, "false");        tmpDir = createTmpDir();        startServer();        fail("Server should not have started without datadir");    } catch (IOException e) {            } finally {        System.setProperty(FileTxnSnapLog.ZOOKEEPER_DATADIR_AUTOCREATE, FileTxnSnapLog.ZOOKEEPER_DATADIR_AUTOCREATE_DEFAULT);    }}
testReloadSnapshotWithMissingParent
public voidf6230_1) throws Exception
{        ZooKeeper zk = createZKClient(hostPort);    zk.create("/a", "".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    Stat stat = zk.exists("/a", false);    long createZxId = stat.getMzxid();    zk.create("/a/b", "".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.delete("/a/b", -1);    zk.delete("/a", -1);        ZooKeeperServer zks = serverFactory.getZooKeeperServer();    zks.getZKDatabase().setlastProcessedZxid(createZxId);            zks.takeSnapshot();    zks.shutdown();    stopServer();    startServer();}
setUp
public voidf6231_1) throws Exception
{        qb.localSessionsEnabled = true;    qb.localSessionsUpgradingEnabled = true;    qb.setUp();    ClientBase.waitForServerUp(qb.hostPort, 10000);}
tearDown
public voidf6232_1) throws Exception
{        qb.tearDown();}
testLocalSessionsOnFollower
public void zookeeper_f6233_0() throws Exception
{    testOpenCloseSession(false);}
testLocalSessionsOnLeader
public void zookeeper_f6234_0() throws Exception
{    testOpenCloseSession(true);}
validateRequestLog
private voidf6235_1long sessionId, int peerId)
{    String session = Long.toHexString(sessionId);        String peerType = peerId == qb.getLeaderIndex() ? "leader" : "follower";    QuorumPeer peer = qb.getPeerList().get(peerId);    ZKDatabase db = peer.getActiveServer().getZKDatabase();    for (Proposal p : db.getCommittedLog()) {        assertFalse("Should not see " + Request.op2String(p.request.type) + " request from local session 0x" + session + " on the " + peerType, p.request.sessionId == sessionId);    }}
testOpenCloseSession
public void zookeeper_f6236_0(boolean onLeader) throws Exception
{    int leaderIdx = qb.getLeaderIndex();    assertFalse("No leader in quorum?", leaderIdx == -1);    int followerIdx = (leaderIdx + 1) % 5;    int testPeerIdx = onLeader ? leaderIdx : followerIdx;    int verifyPeerIdx = onLeader ? followerIdx : leaderIdx;    String[] hostPorts = qb.hostPort.split(",");    CountdownWatcher watcher = new CountdownWatcher();    DisconnectableZooKeeper client = new DisconnectableZooKeeper(hostPorts[testPeerIdx], CONNECTION_TIMEOUT, watcher);    watcher.waitForConnected(CONNECTION_TIMEOUT);    long localSessionId1 = client.getSessionId();            client.dontReconnect();    client.disconnect();    watcher.reset();        ZooKeeper zk = qb.createClient(watcher, hostPorts[testPeerIdx], CONNECTION_TIMEOUT);    watcher.waitForConnected(CONNECTION_TIMEOUT);    long localSessionId2 = zk.getSessionId();        zk.close();    watcher.reset();                    Thread.sleep(CONNECTION_TIMEOUT * 2);        validateRequestLog(localSessionId1, verifyPeerIdx);        validateRequestLog(localSessionId2, verifyPeerIdx);    qb.shutdownServers();}
setUp
public voidf6237_1) throws Exception
{        qb.localSessionsEnabled = true;    qb.localSessionsUpgradingEnabled = false;    qb.setUp();    ClientBase.waitForServerUp(qb.hostPort, 10000);}
tearDown
public voidf6238_1) throws Exception
{        qb.tearDown();}
testLocalSessionsOnFollower
public void zookeeper_f6239_0() throws Exception
{    testLocalSessions(false);}
testLocalSessionsOnLeader
public void zookeeper_f6240_0() throws Exception
{    testLocalSessions(true);}
testLocalSessions
private void zookeeper_f6241_0(boolean testLeader) throws Exception
{    String nodePrefix = "/testLocalSessions-" + (testLeader ? "leaderTest-" : "followerTest-");    int leaderIdx = qb.getLeaderIndex();    assertFalse("No leader in quorum?", leaderIdx == -1);    int followerIdx = (leaderIdx + 1) % 5;    int testPeerIdx = testLeader ? leaderIdx : followerIdx;    String[] hostPorts = qb.hostPort.split(",");    CountdownWatcher watcher = new CountdownWatcher();    ZooKeeper zk = qb.createClient(watcher, hostPorts[testPeerIdx], CONNECTION_TIMEOUT);    watcher.waitForConnected(CONNECTION_TIMEOUT);    long localSessionId = zk.getSessionId();        for (int i = 0; i < 5; i++) {        zk.create(nodePrefix + i, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    }        try {        zk.create(nodePrefix + "ephemeral", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);        fail("Ephemeral node creation should fail.");    } catch (KeeperException.EphemeralOnLocalSessionException e) {    }        zk.close();        Map<String, Integer> peers = new HashMap<String, Integer>();    peers.put("leader", leaderIdx);    peers.put("follower", followerIdx);    for (Entry<String, Integer> entry : peers.entrySet()) {        watcher.reset();                        zk = qb.createClient(watcher, hostPorts[entry.getValue()], CONNECTION_TIMEOUT);        watcher.waitForConnected(CONNECTION_TIMEOUT);        long newSessionId = zk.getSessionId();        assertFalse(newSessionId == localSessionId);        for (int i = 0; i < 5; i++) {            assertNotNull("Data not exists in " + entry.getKey(), zk.exists(nodePrefix + i, null));        }                assertNull("Data exists in " + entry.getKey(), zk.exists(nodePrefix + "ephemeral", null));        zk.close();    }    qb.shutdownServers();}
getFirst
public V1 zookeeper_f6242_0()
{    return v1;}
getSecond
public V2 zookeeper_f6243_0()
{    return v2;}
rmr
 void zookeeper_f6244_0(File dir) throws IOException
{    Files.walkFileTree(dir.toPath(), new SimpleFileVisitor<Path>() {        @Override        public FileVisitResult visitFile(Path file, BasicFileAttributes a) throws IOException {            Files.delete(file);            return FileVisitResult.CONTINUE;        }        @Override        public FileVisitResult postVisitDirectory(Path dir, IOException e) throws IOException {            Files.delete(dir);            return FileVisitResult.CONTINUE;        }    });}
visitFile
public FileVisitResult zookeeper_f6245_0(Path file, BasicFileAttributes a) throws IOException
{    Files.delete(file);    return FileVisitResult.CONTINUE;}
postVisitDirectory
public FileVisitResult zookeeper_f6246_0(Path dir, IOException e) throws IOException
{    Files.delete(dir);    return FileVisitResult.CONTINUE;}
getFirstLastZxid
 Pair<Long, Long> zookeeper_f6247_0(File logFile) throws IOException
{    File tmp = createTmpDir();    Files.copy(logFile.toPath(), new File(tmp, "log.0").toPath());    FileTxnLog txnLog = new FileTxnLog(tmp);    TxnLog.TxnIterator it = txnLog.read(0);    long firstZxid = it.getHeader().getZxid();    long lastZxid = firstZxid;    while (it.next()) {        lastZxid = it.getHeader().getZxid();    }    txnLog.close();    rmr(tmp);    return new Pair<Long, Long>(firstZxid, lastZxid);}
testChopper
public void zookeeper_f6248_0() throws IOException
{    long clientId = 17;    int cxid = 77;    long zxid = 1000;    long time = 1;    int type = ZooDefs.OpCode.delete;    DeleteTxn txn = new DeleteTxn("/foo");    File tmpDir = createTmpDir();    FileTxnLog txnLog = new FileTxnLog(tmpDir);    for (int i = 0; i < 100; i++) {        TxnHeader hdr = new TxnHeader(clientId, cxid, ++zxid, ++time, type);        txnLog.append(hdr, txn);    }        TxnHeader hdr = new TxnHeader(clientId, cxid, zxid + 10, ++time, type);    txnLog.append(hdr, txn);    txnLog.commit();        final File logFile = new File(tmpDir, "log." + Integer.toHexString(1001));    Pair<Long, Long> firstLast = getFirstLastZxid(logFile);    assertEquals(1001, (long) firstLast.getFirst());    assertEquals(1110, (long) firstLast.getSecond());    File choppedFile = new File(tmpDir, "chopped_failed");    assertFalse(LogChopper.chop(new FileInputStream(logFile), new FileOutputStream(choppedFile), 1107));    choppedFile = new File(tmpDir, "chopped");    assertTrue(LogChopper.chop(new FileInputStream(logFile), new FileOutputStream(choppedFile), 1017));    firstLast = getFirstLastZxid(choppedFile);    assertEquals(1001, (long) firstLast.getFirst());    assertEquals(1017, (long) firstLast.getSecond());}
setUp
public void zookeeper_f6249_0() throws Exception
{    maxCnxns = numCnxns;    super.setUp();}
run
public void zookeeper_f6250_0()
{    SocketChannel sChannel = null;    try {        /*                 * For future unwary socket programmers: although connect 'blocks' it                 * does not require an accept on the server side to return. Therefore                 * you can not assume that all the sockets are connected at the end of                 * this for loop.                 */        sChannel = SocketChannel.open();        sChannel.connect(new InetSocketAddress(host, port));                ConnectRequest conReq = new ConnectRequest(0, 0, 10000, 0, "password".getBytes());        ByteArrayOutputStream baos = new ByteArrayOutputStream();        BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos);        boa.writeInt(-1, "len");        conReq.serialize(boa, "connect");        baos.close();        ByteBuffer bb = ByteBuffer.wrap(baos.toByteArray());        bb.putInt(bb.capacity() - 4);        bb.rewind();        /* Send a connect request. Any socket that has been closed (or at least                 * not added to the cnxn list on the server) will not have any bytes to                 * read and get an eof.                 *                 *  The trick here was finding a call that caused the server to put                 *  bytes in the input stream without closing the cnxn. None of                 *  the four letter commands do that, so we actually try to create                 *  a session which should send us something back, while maintaining                 *  the connection.                 */        int eof = sChannel.write(bb);                        sChannel.socket().setSoTimeout(10000);        if (!sChannel.socket().isClosed()) {            eof = sChannel.socket().getInputStream().read();            if (eof != -1) {                numConnected.incrementAndGet();            }        }    } catch (IOException io) {        } finally {        if (sChannel != null) {            try {                sChannel.close();            } catch (Exception e) {                        }        }    }}
testMaxCnxns
public void zookeeper_f6251_0() throws IOException, InterruptedException
{    String[] split = hostPort.split(":");    host = split[0];    port = Integer.parseInt(split[1]);    int numThreads = numCnxns + 5;    CnxnThread[] threads = new CnxnThread[numThreads];    for (int i = 0; i < numCnxns; ++i) {        threads[i] = new CnxnThread(i);    }    for (int i = 0; i < numCnxns; ++i) {        threads[i].start();    }    for (int i = 0; i < numCnxns; ++i) {        threads[i].join();    }    assertSame(numCnxns, numConnected.get());}
setUp
public void zookeeper_f6252_0() throws Exception
{    super.setUp();    zk = createClient();    pendingOps.set(0);}
finishPendingOps
private void zookeeper_f6253_0()
{    if (pendingOps.decrementAndGet() == 0) {        synchronized (pendingOps) {            pendingOps.notifyAll();        }    }}
waitForPendingOps
private void zookeeper_f6254_0(int timeout) throws Exception
{    synchronized (pendingOps) {        while (pendingOps.get() > 0) {            pendingOps.wait(timeout);        }    }}
testSequentialNodeCreateInAsyncMulti
public void zookeeper_f6255_0() throws Exception
{    final int iteration = 4;    final List<MultiResult> results = new ArrayList<MultiResult>();    pendingOps.set(iteration);    List<Op> ops = Arrays.asList(Op.create("/node-", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL), Op.create("/dup", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT));    for (int i = 0; i < iteration; ++i) {        zk.multi(ops, new MultiCallback() {            @Override            public void processResult(int rc, String path, Object ctx, List<OpResult> opResults) {                MultiResult result = new MultiResult();                result.results = opResults;                result.rc = rc;                results.add(result);                finishPendingOps();            }        }, null);    }    waitForPendingOps(CONNECTION_TIMEOUT);        assertEquals(KeeperException.Code.OK.intValue(), results.get(0).rc);    assertEquals(KeeperException.Code.NODEEXISTS.intValue(), results.get(1).rc);    assertEquals(KeeperException.Code.NODEEXISTS.intValue(), results.get(2).rc);    assertEquals(KeeperException.Code.NODEEXISTS.intValue(), results.get(3).rc);        assertTrue(results.get(0).results.get(0) instanceof CreateResult);    assertEquals(KeeperException.Code.OK.intValue(), ((ErrorResult) results.get(1).results.get(0)).getErr());    assertEquals(KeeperException.Code.OK.intValue(), ((ErrorResult) results.get(2).results.get(0)).getErr());    assertEquals(KeeperException.Code.OK.intValue(), ((ErrorResult) results.get(3).results.get(0)).getErr());        assertEquals(KeeperException.Code.NODEEXISTS.intValue(), ((ErrorResult) results.get(1).results.get(1)).getErr());    assertEquals(KeeperException.Code.NODEEXISTS.intValue(), ((ErrorResult) results.get(2).results.get(1)).getErr());    assertEquals(KeeperException.Code.NODEEXISTS.intValue(), ((ErrorResult) results.get(3).results.get(1)).getErr());}
processResult
public void zookeeper_f6256_0(int rc, String path, Object ctx, List<OpResult> opResults)
{    MultiResult result = new MultiResult();    result.results = opResults;    result.rc = rc;    results.add(result);    finishPendingOps();}
configs
public static Collection<Object[]> zookeeper_f6257_0()
{    return Arrays.asList(new Object[][] { { false }, { true } });}
setUp
public void zookeeper_f6258_0() throws Exception
{    SyncRequestProcessor.setSnapCount(150);    super.setUp();    zk = createClient();}
multi
private List<OpResult> zookeeper_f6259_0(ZooKeeper zk, Iterable<Op> ops) throws KeeperException, InterruptedException
{    if (useAsync) {        final MultiResult res = new MultiResult();        zk.multi(ops, new MultiCallback() {            @Override            public void processResult(int rc, String path, Object ctx, List<OpResult> opResults) {                synchronized (res) {                    res.rc = rc;                    res.results = opResults;                    res.finished = true;                    res.notifyAll();                }            }        }, null);        synchronized (res) {            while (!res.finished) {                res.wait();            }        }                if (KeeperException.Code.OK.intValue() != res.rc && ops.iterator().next().getKind() != Op.OpKind.READ) {            KeeperException ke = KeeperException.create(KeeperException.Code.get(res.rc));            throw ke;        }        return res.results;    } else {        return zk.multi(ops);    }}
processResult
public void zookeeper_f6260_0(int rc, String path, Object ctx, List<OpResult> opResults)
{    synchronized (res) {        res.rc = rc;        res.results = opResults;        res.finished = true;        res.notifyAll();    }}
multiHavingErrors
private void zookeeper_f6261_0(ZooKeeper zk, Iterable<Op> ops, List<Integer> expectedResultCodes, String expectedErr) throws KeeperException, InterruptedException
{    if (useAsync) {        final MultiResult res = new MultiResult();        zk.multi(ops, new MultiCallback() {            @Override            public void processResult(int rc, String path, Object ctx, List<OpResult> opResults) {                synchronized (res) {                    res.rc = rc;                    res.results = opResults;                    res.finished = true;                    res.notifyAll();                }            }        }, null);        synchronized (res) {            while (!res.finished) {                res.wait();            }        }        for (int i = 0; i < res.results.size(); i++) {            OpResult opResult = res.results.get(i);            assertTrue("Did't receive proper error response", opResult instanceof ErrorResult);            ErrorResult errRes = (ErrorResult) opResult;            assertEquals("Did't receive proper error code", expectedResultCodes.get(i).intValue(), errRes.getErr());        }    } else {        try {            zk.multi(ops);            fail("Shouldn't have validated in ZooKeeper client!");        } catch (KeeperException e) {            assertEquals("Wrong exception", expectedErr, e.code().name());        } catch (IllegalArgumentException e) {            assertEquals("Wrong exception", expectedErr, e.getMessage());        }    }}
processResult
public void zookeeper_f6262_0(int rc, String path, Object ctx, List<OpResult> opResults)
{    synchronized (res) {        res.rc = rc;        res.results = opResults;        res.finished = true;        res.notifyAll();    }}
commit
private List<OpResult> zookeeper_f6263_0(Transaction txn) throws KeeperException, InterruptedException
{    if (useAsync) {        final MultiResult res = new MultiResult();        txn.commit(new MultiCallback() {            @Override            public void processResult(int rc, String path, Object ctx, List<OpResult> opResults) {                synchronized (res) {                    res.rc = rc;                    res.results = opResults;                    res.finished = true;                    res.notifyAll();                }            }        }, null);        synchronized (res) {            while (!res.finished) {                res.wait();            }        }        if (KeeperException.Code.OK.intValue() != res.rc) {            KeeperException ke = KeeperException.create(KeeperException.Code.get(res.rc));            throw ke;        }        return res.results;    } else {        return txn.commit();    }}
processResult
public void zookeeper_f6264_0(int rc, String path, Object ctx, List<OpResult> opResults)
{    synchronized (res) {        res.rc = rc;        res.results = opResults;        res.finished = true;        res.notifyAll();    }}
testInvalidPath
public void zookeeper_f6265_0() throws Exception
{    List<Integer> expectedResultCodes = new ArrayList<Integer>();    expectedResultCodes.add(KeeperException.Code.RUNTIMEINCONSISTENCY.intValue());    expectedResultCodes.add(KeeperException.Code.BADARGUMENTS.intValue());    expectedResultCodes.add(KeeperException.Code.RUNTIMEINCONSISTENCY.intValue());        List<Op> opList = Arrays.asList(Op.create("/multi0", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT), Op.create("/multi1/", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT), Op.create("/multi2", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT));    String expectedErr = "Path must not end with / character";    multiHavingErrors(zk, opList, expectedResultCodes, expectedErr);        opList = Arrays.asList(Op.create("/multi0", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT), Op.create("multi1/", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL.toFlag()), Op.create("/multi2", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT));    expectedErr = "Path must start with / character";    multiHavingErrors(zk, opList, expectedResultCodes, expectedErr);        opList = Arrays.asList(Op.check("/multi0", -1), Op.check("/multi1/", 100), Op.check("/multi2", 5));    expectedErr = "Path must not end with / character";    multiHavingErrors(zk, opList, expectedResultCodes, expectedErr);        opList = Arrays.asList(Op.delete("/multi0", -1), Op.delete("/multi1/", 100), Op.delete("/multi2", 5));    multiHavingErrors(zk, opList, expectedResultCodes, expectedErr);        expectedResultCodes.add(KeeperException.Code.BADARGUMENTS.intValue());        opList = Arrays.asList(Op.setData("/multi0", new byte[0], -1), Op.setData("/multi1/", new byte[0], -1), Op.setData("/multi2", new byte[0], -1), Op.setData("multi3", new byte[0], -1));    multiHavingErrors(zk, opList, expectedResultCodes, expectedErr);}
testMultiRollback
public void zookeeper_f6266_0() throws Exception
{    zk.create("/foo", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    ZooKeeper epheZk = createClient();    epheZk.create("/foo/bar", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);    List<Op> opList = Arrays.asList(Op.delete("/foo", -1));    try {        zk.multi(opList);        fail("multi delete should failed for not empty directory");    } catch (KeeperException.NotEmptyException e) {    }    final CountDownLatch latch = new CountDownLatch(1);    zk.exists("/foo/bar", event -> {        if (event.getType() == Watcher.Event.EventType.NodeDeleted) {            latch.countDown();        }    });    epheZk.close();    latch.await();    try {        zk.getData("/foo/bar", false, null);        fail("ephemeral node should have been deleted");    } catch (KeeperException.NoNodeException e) {    }    zk.multi(opList);    try {        zk.getData("/foo", false, null);        fail("persistent node should have been deleted after multi");    } catch (KeeperException.NoNodeException e) {    }}
testBlankPath
public void zookeeper_f6267_0() throws Exception
{    List<Integer> expectedResultCodes = new ArrayList<Integer>();    expectedResultCodes.add(KeeperException.Code.RUNTIMEINCONSISTENCY.intValue());    expectedResultCodes.add(KeeperException.Code.BADARGUMENTS.intValue());    expectedResultCodes.add(KeeperException.Code.RUNTIMEINCONSISTENCY.intValue());    expectedResultCodes.add(KeeperException.Code.BADARGUMENTS.intValue());        String expectedErr = "Path cannot be null";    List<Op> opList = Arrays.asList(Op.delete("/multi0", -1), Op.delete(null, 100), Op.delete("/multi2", 5), Op.delete("", -1));    multiHavingErrors(zk, opList, expectedResultCodes, expectedErr);}
testInvalidCreateModeFlag
public void zookeeper_f6268_0() throws Exception
{    List<Integer> expectedResultCodes = new ArrayList<Integer>();    expectedResultCodes.add(KeeperException.Code.RUNTIMEINCONSISTENCY.intValue());    expectedResultCodes.add(KeeperException.Code.BADARGUMENTS.intValue());    expectedResultCodes.add(KeeperException.Code.RUNTIMEINCONSISTENCY.intValue());    int createModeFlag = 6789;    List<Op> opList = Arrays.asList(Op.create("/multi0", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT), Op.create("/multi1", new byte[0], Ids.OPEN_ACL_UNSAFE, createModeFlag), Op.create("/multi2", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT));    String expectedErr = KeeperException.Code.BADARGUMENTS.name();    multiHavingErrors(zk, opList, expectedResultCodes, expectedErr);}
testChRootCreateDelete
public void zookeeper_f6269_0() throws Exception
{        String chRoot = createNameSpace();        zk_chroot = createClient(this.hostPort + chRoot);    Op createChild = Op.create("/myid", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    multi(zk_chroot, Arrays.asList(createChild));    assertNotNull("zNode is not created under chroot:" + chRoot, zk.exists(chRoot + "/myid", false));    assertNotNull("zNode is not created under chroot:" + chRoot, zk_chroot.exists("/myid", false));    assertNull("zNode is created directly under '/', ignored configured chroot", zk.exists("/myid", false));        Op deleteChild = Op.delete("/myid", 0);    multi(zk_chroot, Arrays.asList(deleteChild));    assertNull("zNode exists under chroot:" + chRoot, zk.exists(chRoot + "/myid", false));    assertNull("zNode exists under chroot:" + chRoot, zk_chroot.exists("/myid", false));}
testChRootSetData
public void zookeeper_f6270_0() throws Exception
{        String chRoot = createNameSpace();        zk_chroot = createClient(this.hostPort + chRoot);    String[] names = { "/multi0", "/multi1", "/multi2" };    List<Op> ops = new ArrayList<Op>();    for (int i = 0; i < names.length; i++) {        ops.add(Op.create(names[i], new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT));        ops.add(Op.setData(names[i], names[i].getBytes(), 0));    }    multi(zk_chroot, ops);    for (int i = 0; i < names.length; i++) {        assertArrayEquals("zNode data not matching", names[i].getBytes(), zk_chroot.getData(names[i], false, null));    }}
testChRootCheck
public void zookeeper_f6271_0() throws Exception
{        String chRoot = createNameSpace();        zk_chroot = createClient(this.hostPort + chRoot);    String[] names = { "/multi0", "/multi1", "/multi2" };    List<Op> ops = new ArrayList<Op>();    for (int i = 0; i < names.length; i++) {        zk.create(chRoot + names[i], new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    }    for (int i = 0; i < names.length; i++) {        ops.add(Op.check(names[i], 0));    }    multi(zk_chroot, ops);}
testChRootTransaction
public void zookeeper_f6272_0() throws Exception
{        String chRoot = createNameSpace();        zk_chroot = createClient(this.hostPort + chRoot);    String childPath = "/myid";    Transaction transaction = zk_chroot.transaction();    transaction.create(childPath, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    transaction.check(childPath, 0);    transaction.setData(childPath, childPath.getBytes(), 0);    commit(transaction);    assertNotNull("zNode is not created under chroot:" + chRoot, zk.exists(chRoot + childPath, false));    assertNotNull("zNode is not created under chroot:" + chRoot, zk_chroot.exists(childPath, false));    assertNull("zNode is created directly under '/', ignored configured chroot", zk.exists(childPath, false));    assertArrayEquals("zNode data not matching", childPath.getBytes(), zk_chroot.getData(childPath, false, null));    transaction = zk_chroot.transaction();        transaction.delete(childPath, 1);    commit(transaction);    assertNull("chroot:" + chRoot + " exists after delete", zk.exists(chRoot + "/myid", false));    assertNull("chroot:" + chRoot + " exists after delete", zk_chroot.exists("/myid", false));}
createNameSpace
private String zookeeper_f6273_0() throws InterruptedException, KeeperException
{        String chRoot = "/appsX";    Op createChRoot = Op.create(chRoot, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    multi(zk, Arrays.asList(createChRoot));    return chRoot;}
testCreate
public void zookeeper_f6274_0() throws Exception
{    multi(zk, Arrays.asList(Op.create("/multi0", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT), Op.create("/multi1", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT), Op.create("/multi2", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT)));    zk.getData("/multi0", false, null);    zk.getData("/multi1", false, null);    zk.getData("/multi2", false, null);}
testCreateDelete
public void zookeeper_f6275_0() throws Exception
{    multi(zk, Arrays.asList(Op.create("/multi", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT), Op.delete("/multi", 0)));        assertNull(zk.exists("/multi", null));}
testInvalidVersion
public void zookeeper_f6276_0() throws Exception
{    try {        multi(zk, Arrays.asList(Op.create("/multi", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT), Op.delete("/multi", 1)));        fail("delete /multi should have failed");    } catch (KeeperException e) {    /* PASS */    }}
testNestedCreate
public void zookeeper_f6277_0() throws Exception
{    multi(zk, Arrays.asList(/* Create */    Op.create("/multi", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT), Op.create("/multi/a", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT), Op.create("/multi/a/1", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT), /* Delete */    Op.delete("/multi/a/1", 0), Op.delete("/multi/a", 0), Op.delete("/multi", 0)));        assertNull(zk.exists("/multi/a/1", null));    assertNull(zk.exists("/multi/a", null));    assertNull(zk.exists("/multi", null));}
testSetData
public void zookeeper_f6278_0() throws Exception
{    String[] names = { "/multi0", "/multi1", "/multi2" };    List<Op> ops = new ArrayList<Op>();    for (int i = 0; i < names.length; i++) {        ops.add(Op.create(names[i], new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT));        ops.add(Op.setData(names[i], names[i].getBytes(), 0));    }    multi(zk, ops);    for (int i = 0; i < names.length; i++) {        assertArrayEquals(names[i].getBytes(), zk.getData(names[i], false, null));    }}
testUpdateConflict
public voidf6279_1) throws Exception
{    assertNull(zk.exists("/multi", null));    try {        multi(zk, Arrays.asList(Op.create("/multi", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT), Op.setData("/multi", "X".getBytes(), 0), Op.setData("/multi", "Y".getBytes(), 0)));        fail("Should have thrown a KeeperException for invalid version");    } catch (KeeperException e) {                    }    assertNull(zk.exists("/multi", null));        multi(zk, Arrays.asList(Op.create("/multi", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT), Op.setData("/multi", "X".getBytes(), 0), Op.setData("/multi", "Y".getBytes(), 1)));    assertArrayEquals(zk.getData("/multi", false, null), "Y".getBytes());}
testDeleteUpdateConflict
public void zookeeper_f6280_0() throws Exception
{    /* Delete of a node folowed by an update of the (now) deleted node */    try {        multi(zk, Arrays.asList(Op.create("/multi", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT), Op.delete("/multi", 0), Op.setData("/multi", "Y".getBytes(), 0)));        fail("/multi should have been deleted so setData should have failed");    } catch (KeeperException e) {    /* PASS */    }        assertNull(zk.exists("/multi", null));}
testGetResults
public voidf6281_1) throws Exception
{    /* Delete of a node folowed by an update of the (now) deleted node */    Iterable<Op> ops = Arrays.asList(Op.create("/multi", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT), Op.delete("/multi", 0), Op.setData("/multi", "Y".getBytes(), 0), Op.create("/foo", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT));    List<OpResult> results = null;    if (useAsync) {        final MultiResult res = new MultiResult();        zk.multi(ops, new MultiCallback() {            @Override            public void processResult(int rc, String path, Object ctx, List<OpResult> opResults) {                synchronized (res) {                    res.rc = rc;                    res.results = opResults;                    res.finished = true;                    res.notifyAll();                }            }        }, null);        synchronized (res) {            while (!res.finished) {                res.wait();            }        }        assertFalse("/multi should have been deleted so setData should have failed", KeeperException.Code.OK.intValue() == res.rc);        assertNull(zk.exists("/multi", null));        results = res.results;    } else {        try {            zk.multi(ops);            fail("/multi should have been deleted so setData should have failed");        } catch (KeeperException e) {                        assertNull(zk.exists("/multi", null));            results = e.getResults();        }    }    assertNotNull(results);    for (OpResult r : results) {                if (r instanceof ErrorResult) {            ErrorResult er = (ErrorResult) r;                    }    }}
processResult
public void zookeeper_f6282_0(int rc, String path, Object ctx, List<OpResult> opResults)
{    synchronized (res) {        res.rc = rc;        res.results = opResults;        res.finished = true;        res.notifyAll();    }}
testOpResultEquals
public void zookeeper_f6283_0()
{    opEquals(new CreateResult("/foo"), new CreateResult("/foo"), new CreateResult("nope"));    opEquals(new CreateResult("/foo"), new CreateResult("/foo"), new CreateResult("/foo", new Stat(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11)));    opEquals(new CreateResult("/foo", new Stat(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11)), new CreateResult("/foo", new Stat(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11)), new CreateResult("nope", new Stat(11, 12, 13, 14, 15, 16, 17, 18, 19, 110, 111)));    opEquals(new CreateResult("/foo", new Stat(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11)), new CreateResult("/foo", new Stat(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11)), new CreateResult("/foo"));    opEquals(new CheckResult(), new CheckResult(), null);    opEquals(new SetDataResult(new Stat(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11)), new SetDataResult(new Stat(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11)), new SetDataResult(new Stat(11, 12, 13, 14, 15, 16, 17, 18, 19, 110, 111)));    opEquals(new ErrorResult(1), new ErrorResult(1), new ErrorResult(2));    opEquals(new DeleteResult(), new DeleteResult(), null);    opEquals(new ErrorResult(1), new ErrorResult(1), new ErrorResult(2));}
opEquals
private void zookeeper_f6284_0(OpResult expected, OpResult value, OpResult near)
{    assertEquals(value, value);    assertFalse(value.equals(new Object()));    assertFalse(value.equals(near));    assertFalse(value.equals(value instanceof CreateResult ? new ErrorResult(1) : new CreateResult("nope2")));    assertTrue(value.equals(expected));}
testWatchesTriggered
public void zookeeper_f6285_0() throws KeeperException, InterruptedException
{    HasTriggeredWatcher watcher = new HasTriggeredWatcher();    zk.getChildren("/", watcher);    multi(zk, Arrays.asList(Op.create("/t", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT), Op.delete("/t", -1)));    assertTrue(watcher.triggered.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS));}
testNoWatchesTriggeredForFailedMultiRequest
public void zookeeper_f6286_0() throws InterruptedException, KeeperException
{    HasTriggeredWatcher watcher = new HasTriggeredWatcher();    zk.getChildren("/", watcher);    try {        multi(zk, Arrays.asList(Op.create("/t", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT), Op.delete("/nonexisting", -1)));        fail("expected previous multi op to fail!");    } catch (KeeperException.NoNodeException e) {        }    SyncCallback cb = new SyncCallback();    zk.sync("/", cb, null);        cb.done.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS);    assertEquals(1, watcher.triggered.getCount());}
testTransactionBuilder
public void zookeeper_f6287_0() throws Exception
{    List<OpResult> results = commit(zk.transaction().create("/t1", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT).create("/t1/child", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT).create("/t2", null, Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL));    assertEquals(3, results.size());    for (OpResult r : results) {        CreateResult c = (CreateResult) r;        assertTrue(c.getPath().startsWith("/t"));        assertNotNull(c.toString());    }    assertNotNull(zk.exists("/t1", false));    assertNotNull(zk.exists("/t1/child", false));    assertNotNull(zk.exists("/t2", false));    results = commit(zk.transaction().check("/t1", 0).check("/t1/child", 0).check("/t2", 0));    assertEquals(3, results.size());    for (OpResult r : results) {        CheckResult c = (CheckResult) r;        assertNotNull(c.toString());    }    try {        results = commit(zk.transaction().check("/t1", 0).check("/t1/child", 0).check("/t2", 1));        fail();    } catch (KeeperException.BadVersionException e) {        }    results = commit(zk.transaction().check("/t1", 0).setData("/t1", new byte[0], 0));    assertEquals(2, results.size());    for (OpResult r : results) {        assertNotNull(r.toString());    }    try {        results = commit(zk.transaction().check("/t1", 1).setData("/t1", new byte[0], 2));        fail();    } catch (KeeperException.BadVersionException e) {        }    results = commit(zk.transaction().check("/t1", 1).check("/t1/child", 0).check("/t2", 0));    assertEquals(3, results.size());    results = commit(zk.transaction().delete("/t2", -1).delete("/t1/child", -1));    assertEquals(2, results.size());    for (OpResult r : results) {        DeleteResult d = (DeleteResult) r;        assertNotNull(d.toString());    }    assertNotNull(zk.exists("/t1", false));    assertNull(zk.exists("/t1/child", false));    assertNull(zk.exists("/t2", false));}
testMultiGetChildren
public void zookeeper_f6288_0() throws Exception
{    List<String> topLevelNodes = new ArrayList<String>();    Map<String, List<String>> childrenNodes = new HashMap<String, List<String>>();        for (int i = 0; i < 10; i++) {        String name = "/foo" + i;        zk.create(name, name.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        topLevelNodes.add(name);        childrenNodes.put(name, new ArrayList<>());        for (int j = 0; j < 10; j++) {            String childname = name + "/bar" + i + j;            String childname_s = "bar" + i + j;            zk.create(childname, childname.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);            childrenNodes.get(name).add(childname_s);        }    }        List<OpResult> multiChildrenList = multi(zk, topLevelNodes.stream().map(Op::getChildren).collect(Collectors.toList()));    for (int i = 0; i < topLevelNodes.size(); i++) {        String nodeName = topLevelNodes.get(i);        assertTrue(multiChildrenList.get(i) instanceof OpResult.GetChildrenResult);        List<String> childrenList = ((OpResult.GetChildrenResult) multiChildrenList.get(i)).getChildren();                assertEquals(new TreeSet<String>(childrenList), new TreeSet<String>(childrenNodes.get(nodeName)));        List<String> children = zk.getChildren(nodeName, false);        assertEquals(childrenList, children);    }}
testMultiGetChildrenSameNode
public void zookeeper_f6289_0() throws Exception
{    List<String> childrenNodes = new ArrayList<String>();        String topLevelNode = "/foo";    zk.create(topLevelNode, topLevelNode.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    for (int i = 0; i < 10; i++) {        String childname = topLevelNode + "/bar" + i;        String childname_s = "bar" + i;        zk.create(childname, childname.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);        childrenNodes.add(childname_s);    }        List<OpResult> sameChildrenList = multi(zk, Arrays.asList(Op.getChildren(topLevelNode), Op.getChildren(topLevelNode)));        assertEquals(sameChildrenList.size(), 2);    assertEquals(sameChildrenList.get(0), sameChildrenList.get(1));        assertTrue(sameChildrenList.get(0) instanceof OpResult.GetChildrenResult);    OpResult.GetChildrenResult gcr = (OpResult.GetChildrenResult) sameChildrenList.get(0);        assertEquals(new TreeSet<String>(gcr.getChildren()), new TreeSet<String>(childrenNodes));}
testMultiGetChildrenAuthentication
public void zookeeper_f6290_0() throws KeeperException, InterruptedException
{    List<ACL> writeOnly = Collections.singletonList(new ACL(ZooDefs.Perms.WRITE, new Id("world", "anyone")));    zk.create("/foo_auth", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/foo_auth/bar", null, Ids.READ_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/foo_no_auth", null, writeOnly, CreateMode.PERSISTENT);        List<OpResult> multiChildrenList = multi(zk, Arrays.asList(Op.getChildren("/foo_auth")));    assertEquals(multiChildrenList.size(), 1);    assertTrue(multiChildrenList.get(0) instanceof OpResult.GetChildrenResult);    List<String> childrenList = ((OpResult.GetChildrenResult) multiChildrenList.get(0)).getChildren();    assertEquals(childrenList.size(), 1);    assertEquals(childrenList.get(0), "bar");        multiChildrenList = multi(zk, Arrays.asList(Op.getChildren("/foo_no_auth")));    assertEquals(multiChildrenList.size(), 1);    assertTrue(multiChildrenList.get(0) instanceof OpResult.ErrorResult);    assertEquals("Expected NoAuthException for getting the children of a write only node", ((OpResult.ErrorResult) multiChildrenList.get(0)).getErr(), KeeperException.Code.NOAUTH.intValue());}
testMultiGetChildrenMixedAuthenticationErrorFirst
public void zookeeper_f6291_0() throws KeeperException, InterruptedException
{    List<ACL> writeOnly = Collections.singletonList(new ACL(ZooDefs.Perms.WRITE, new Id("world", "anyone")));    zk.create("/foo_auth", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/foo_auth/bar", null, Ids.READ_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/foo_no_auth", null, writeOnly, CreateMode.PERSISTENT);    List<OpResult> multiChildrenList;        multiChildrenList = multi(zk, Arrays.asList(Op.getChildren("/foo_no_auth"), Op.getChildren("/foo_auth")));    assertEquals(multiChildrenList.size(), 2);    assertTrue(multiChildrenList.get(0) instanceof OpResult.ErrorResult);    assertEquals("Expected NoAuthException for getting the children of a write only node", ((OpResult.ErrorResult) multiChildrenList.get(0)).getErr(), KeeperException.Code.NOAUTH.intValue());    assertTrue(multiChildrenList.get(1) instanceof OpResult.GetChildrenResult);    List<String> childrenList = ((OpResult.GetChildrenResult) multiChildrenList.get(1)).getChildren();    assertEquals(childrenList.size(), 1);    assertEquals(childrenList.get(0), "bar");}
testMultiGetChildrenMixedAuthenticationCorrectFirst
public void zookeeper_f6292_0() throws KeeperException, InterruptedException
{    List<ACL> writeOnly = Collections.singletonList(new ACL(ZooDefs.Perms.WRITE, new Id("world", "anyone")));    zk.create("/foo_auth", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/foo_auth/bar", null, Ids.READ_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/foo_no_auth", null, writeOnly, CreateMode.PERSISTENT);            List<OpResult> multiChildrenList;    multiChildrenList = multi(zk, Arrays.asList(Op.getChildren("/foo_auth"), Op.getChildren("/foo_no_auth")));    assertSame(multiChildrenList.size(), 2);    assertTrue(multiChildrenList.get(0) instanceof OpResult.GetChildrenResult);    List<String> childrenList = ((OpResult.GetChildrenResult) multiChildrenList.get(0)).getChildren();    assertEquals(childrenList.size(), 1);    assertEquals(childrenList.get(0), "bar");    assertTrue(multiChildrenList.get(1) instanceof OpResult.ErrorResult);    assertEquals("Expected NoAuthException for getting the children of a write only node", ((OpResult.ErrorResult) multiChildrenList.get(1)).getErr(), KeeperException.Code.NOAUTH.intValue());}
testMultiGetData
public void zookeeper_f6293_0() throws Exception
{    zk.create("/node1", "data1".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/node2", "data2".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    List<OpResult> multiData = multi(zk, Arrays.asList(Op.getData("/node1"), Op.getData("/node2")));    assertEquals(multiData.size(), 2);    assertArrayEquals(((OpResult.GetDataResult) multiData.get(0)).getData(), "data1".getBytes());    assertArrayEquals(((OpResult.GetDataResult) multiData.get(1)).getData(), "data2".getBytes());}
testMultiRead
public void zookeeper_f6294_0() throws Exception
{    zk.create("/node1", "data1".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/node2", "data2".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);    zk.create("/node1/node1", "data11".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/node1/node2", "data12".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    List<OpResult> multiRead = multi(zk, Arrays.asList(Op.getChildren("/node1"), Op.getData("/node1"), Op.getChildren("/node2"), Op.getData("/node2")));    assertEquals(multiRead.size(), 4);    assertTrue(multiRead.get(0) instanceof OpResult.GetChildrenResult);    List<String> childrenList = ((OpResult.GetChildrenResult) multiRead.get(0)).getChildren();    assertEquals(childrenList.size(), 2);    assertEquals(new TreeSet<String>(childrenList), new TreeSet<String>(Arrays.asList("node1", "node2")));    assertArrayEquals(((OpResult.GetDataResult) multiRead.get(1)).getData(), "data1".getBytes());    Stat stat = ((OpResult.GetDataResult) multiRead.get(1)).getStat();    assertEquals(stat.getMzxid(), stat.getCzxid());    assertEquals(stat.getCtime(), stat.getMtime());    assertEquals(2, stat.getCversion());    assertEquals(0, stat.getVersion());    assertEquals(0, stat.getAversion());    assertEquals(0, stat.getEphemeralOwner());    assertEquals(5, stat.getDataLength());    assertEquals(2, stat.getNumChildren());    assertTrue(multiRead.get(2) instanceof OpResult.GetChildrenResult);    childrenList = ((OpResult.GetChildrenResult) multiRead.get(2)).getChildren();    assertTrue(childrenList.isEmpty());    assertArrayEquals(((OpResult.GetDataResult) multiRead.get(3)).getData(), "data2".getBytes());    stat = ((OpResult.GetDataResult) multiRead.get(3)).getStat();    assertEquals(stat.getMzxid(), stat.getCzxid());    assertEquals(stat.getMzxid(), stat.getPzxid());    assertEquals(stat.getCtime(), stat.getMtime());    assertEquals(0, stat.getCversion());    assertEquals(0, stat.getVersion());    assertEquals(0, stat.getAversion());    assertEquals(zk.getSessionId(), stat.getEphemeralOwner());    assertEquals(5, stat.getDataLength());    assertEquals(0, stat.getNumChildren());}
testMixedReadAndTransaction
public void zookeeper_f6295_0() throws Exception
{    zk.create("/node", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    try {        List<OpResult> multiRead = multi(zk, Arrays.asList(Op.setData("/node1", "data1".getBytes(), -1), Op.getData("/node1")));        fail("Mixed kind of operations are not allowed");    } catch (IllegalArgumentException e) {        }}
process
public void zookeeper_f6296_0(WatchedEvent event)
{    triggered.countDown();}
processResult
public void zookeeper_f6297_0(int rc, String path, Object ctx)
{    done.countDown();}
setUp
public static void zookeeper_f6298_0()
{    System.setProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY, NettyServerCnxnFactory.class.getName());    System.setProperty(ZKClientConfig.ZOOKEEPER_CLIENT_CNXN_SOCKET, ClientCnxnSocketNetty.class.getName());    System.setProperty("zookeeper.admin.enableServer", "false");}
tearDown
public static void zookeeper_f6299_0()
{    System.clearProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY);    System.clearProperty(ZKClientConfig.ZOOKEEPER_CLIENT_CNXN_SOCKET);}
setUpTest
public void zookeeper_f6300_0() throws Exception
{    TestByteBufAllocatorTestHelper.setTestAllocator(TestByteBufAllocator.getInstance());}
tearDownTest
public void zookeeper_f6301_0() throws Exception
{    TestByteBufAllocatorTestHelper.clearTestAllocator();    TestByteBufAllocator.checkForLeaks();}
testFileDescriptorLeak
public voidf6302_1) throws Exception
{    OSMXBean osMbean = new OSMXBean();    if (!osMbean.getUnix()) {                return;    }    long startFdCount = osMbean.getOpenFileDescriptorCount();        for (int i = 0; i < 50; ++i) {        NIOServerCnxnFactory factory = new NIOServerCnxnFactory();        factory.configure(new InetSocketAddress("127.0.0.1", PortAssignment.unique()), 10);        factory.start();        Thread.sleep(100);        factory.shutdown();    }    long endFdCount = osMbean.getOpenFileDescriptorCount();            assertTrue("Possible fd leakage", ((endFdCount - startFdCount) < 50));}
setUp
public static void zookeeper_f6303_0()
{    System.setProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY, NettyServerCnxnFactory.class.getName());    System.setProperty("zookeeper.admin.enableServer", "false");}
tearDown
public static void zookeeper_f6304_0()
{    System.clearProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY);}
setUpTest
public void zookeeper_f6305_0() throws Exception
{    TestByteBufAllocatorTestHelper.setTestAllocator(TestByteBufAllocator.getInstance());}
tearDownTest
public void zookeeper_f6306_0() throws Exception
{    TestByteBufAllocatorTestHelper.clearTestAllocator();    TestByteBufAllocator.checkForLeaks();}
testZooKeeperServiceAvailableOnLeader
public void zookeeper_f6307_0() throws Exception
{    int SERVER_COUNT = 3;    final int[] clientPorts = new int[SERVER_COUNT];    StringBuilder sb = new StringBuilder();    String server;    for (int i = 0; i < SERVER_COUNT; i++) {        clientPorts[i] = PortAssignment.unique();        server = "server." + i + "=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ":participant;127.0.0.1:" + clientPorts[i];        sb.append(server + "\n");    }    String currentQuorumCfgSection = sb.toString();    MainThread[] mt = new MainThread[SERVER_COUNT];    for (int i = 0; i < SERVER_COUNT; i++) {        mt[i] = new MainThread(i, clientPorts[i], currentQuorumCfgSection, false);        mt[i].start();    }        for (int i = 0; i < SERVER_COUNT; i++) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts[i], CONNECTION_TIMEOUT));    }    CountdownWatcher watcher = new CountdownWatcher();    ZooKeeper zk = new ZooKeeper("127.0.0.1:" + clientPorts[0], ClientBase.CONNECTION_TIMEOUT, watcher);    watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT);    String data = "originalData";    zk.create(NODE_PATH, data.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        QuorumPeer leader = getLeaderQuorumPeer(mt);    assertNotNull("Leader must have been elected by now", leader);        FileTxnSnapLog snapLog = leader.getActiveServer().getTxnLogFactory();    FileTxnSnapLog fileTxnSnapLogWithError = new FileTxnSnapLog(snapLog.getDataDir(), snapLog.getSnapDir()) {        @Override        public void commit() throws IOException {            throw new IOException("Input/output error");        }    };    ZKDatabase originalZKDatabase = leader.getActiveServer().getZKDatabase();    long leaderCurrentEpoch = leader.getCurrentEpoch();    ZKDatabase newDB = new ZKDatabase(fileTxnSnapLogWithError);    leader.getActiveServer().setZKDatabase(newDB);    try {                zk.create(uniqueZnode(), data.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        fail("IOException is expected due to error injected to transaction log commit");    } catch (Exception e) {        }                watcher.reset();    waitForNewLeaderElection(leader, leaderCurrentEpoch);        for (int i = 0; i < SERVER_COUNT; i++) {        assertTrue("waiting for server " + i + " being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPorts[i], CONNECTION_TIMEOUT));    }        leader.getActiveServer().setZKDatabase(originalZKDatabase);        leader = getLeaderQuorumPeer(mt);    assertNotNull("New leader must have been elected by now", leader);    String uniqueNode = uniqueZnode();    watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT);    String createNode = zk.create(uniqueNode, data.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);            assertEquals("Failed to create znode", uniqueNode, createNode);    zk.close();        for (int i = 0; i < SERVER_COUNT; i++) {        mt[i].shutdown();    }}
commit
public void zookeeper_f6308_0() throws IOException
{    throw new IOException("Input/output error");}
waitForNewLeaderElection
private voidf6309_1QuorumPeer peer, long leaderCurrentEpoch) throws IOException, InterruptedException
{            int count = 100;    while (count > 0) {        if (leaderCurrentEpoch == peer.getCurrentEpoch()) {            Thread.sleep(100);        }        count--;    }    assertNotEquals("New LE cycle must have triggered", leaderCurrentEpoch, peer.getCurrentEpoch());}
getLeaderQuorumPeer
private QuorumPeer zookeeper_f6310_0(MainThread[] mt)
{    for (int i = mt.length - 1; i >= 0; i--) {        QuorumPeer quorumPeer = mt[i].getQuorumPeer();        if (null != quorumPeer && ServerState.LEADING == quorumPeer.getPeerState()) {            return quorumPeer;        }    }    return null;}
uniqueZnode
private String zookeeper_f6311_0()
{    UUID randomUUID = UUID.randomUUID();    String node = NODE_PATH + "/" + randomUUID.toString();    return node;}
setUp
public void zookeeper_f6312_0() throws Exception
{        snapCount = System.getProperty("zookeeper.snapCount", "1024");    System.setProperty("zookeeper.snapCount", "10");    super.setUp();}
tearDown
public void zookeeper_f6313_0() throws Exception
{    System.setProperty("zookeeper.snapCount", snapCount);    super.tearDown();}
testNullData
public void zookeeper_f6314_0() throws IOException, InterruptedException, KeeperException
{    String path = "/SIZE";    ZooKeeper zk = null;    zk = createClient();    try {        zk.create(path, null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);                zk.exists(path, false);        zk.exists(path, false, this, null);        cn.await(10, TimeUnit.SECONDS);        assertSame(0L, cn.getCount());    } finally {        if (zk != null) {            zk.close();        }    }}
processResult
public void zookeeper_f6315_0(int rc, String path, Object ctx, Stat stat)
{    cn.countDown();}
startServers
 void zookeeper_f6316_0() throws Exception
{    startServers(true);}
shutdown
protected void zookeeper_f6317_0(QuorumPeer qp)
{    QuorumBase.shutdown(qp);}
testHierarchicalQuorum
public void zookeeper_f6318_0() throws Throwable
{    cht.runHammer(5, 10);}
establishThreeParticipantOneObserverEnsemble
public void zookeeper_f6319_0() throws Exception
{    qb.setUp(true);    ct.hostPort = qb.hostPort;    ct.setUpAll();    qb.s5.shutdown();}
shutdownQuorum
public void zookeeper_f6320_0() throws Exception
{    ct.tearDownAll();    qb.tearDown();}
testLEWithObserver
public void zookeeper_f6321_0() throws Exception
{    QuorumPeer leader = null;    for (QuorumPeer server : Arrays.asList(qb.s1, qb.s2, qb.s3)) {        if (server.getServerState().equals(QuorumStats.Provider.FOLLOWING_STATE)) {            server.shutdown();            assertTrue("Waiting for server down", ClientBase.waitForServerDown("127.0.0.1:" + server.getClientPort(), ClientBase.CONNECTION_TIMEOUT));        } else {            assertNull("More than one leader found", leader);            leader = server;        }    }    assertTrue("Leader is not in Looking state", ClientBase.waitForServerState(leader, ClientBase.CONNECTION_TIMEOUT, QuorumStats.Provider.LOOKING_STATE));}
data
public static List<Object[]> zookeeper_f6322_0()
{    return Arrays.asList(new Object[][] { { Boolean.TRUE }, { Boolean.FALSE } });}
setUp
private PortForwarder zookeeper_f6323_0(final int omProxyPort) throws IOException
{    ClientBase.setupTestEnv();    final int PORT_QP1 = PortAssignment.unique();    final int PORT_QP2 = PortAssignment.unique();    final int PORT_OBS = PortAssignment.unique();    final int PORT_QP_LE1 = PortAssignment.unique();    final int PORT_QP_LE2 = PortAssignment.unique();    final int PORT_OBS_LE = PortAssignment.unique();    CLIENT_PORT_QP1 = PortAssignment.unique();    CLIENT_PORT_QP2 = PortAssignment.unique();    CLIENT_PORT_OBS = PortAssignment.unique();    OM_PORT = PortAssignment.unique();    String quorumCfgSection = "server.1=127.0.0.1:" + (PORT_QP1) + ":" + (PORT_QP_LE1) + ";" + CLIENT_PORT_QP1 + "\nserver.2=127.0.0.1:" + (PORT_QP2) + ":" + (PORT_QP_LE2) + ";" + CLIENT_PORT_QP2 + "\nserver.3=127.0.0.1:" + (PORT_OBS) + ":" + (PORT_OBS_LE) + ":observer" + ";" + CLIENT_PORT_OBS;    String extraCfgs = testObserverMaster ? String.format("observerMasterPort=%d%n", OM_PORT) : "";    String extraCfgsObs = testObserverMaster ? String.format("observerMasterPort=%d%n", omProxyPort <= 0 ? OM_PORT : omProxyPort) : "";    PortForwarder forwarder = null;    if (testObserverMaster && omProxyPort >= 0) {        forwarder = new PortForwarder(omProxyPort, OM_PORT);    }    q1 = new MainThread(1, CLIENT_PORT_QP1, quorumCfgSection, extraCfgs);    q2 = new MainThread(2, CLIENT_PORT_QP2, quorumCfgSection, extraCfgs);    q3 = new MainThread(3, CLIENT_PORT_OBS, quorumCfgSection, extraCfgsObs);    q1.start();    q2.start();    assertTrue("waiting for server 1 being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_QP1, CONNECTION_TIMEOUT));    assertTrue("waiting for server 2 being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_QP2, CONNECTION_TIMEOUT));    return forwarder;}
shutdown
private voidf6324_1) throws InterruptedException
{        zk.close();    q1.shutdown();    q2.shutdown();    q3.shutdown();    assertTrue("Waiting for server 1 to shut down", ClientBase.waitForServerDown("127.0.0.1:" + CLIENT_PORT_QP1, ClientBase.CONNECTION_TIMEOUT));    assertTrue("Waiting for server 2 to shut down", ClientBase.waitForServerDown("127.0.0.1:" + CLIENT_PORT_QP2, ClientBase.CONNECTION_TIMEOUT));    assertTrue("Waiting for server 3 to shut down", ClientBase.waitForServerDown("127.0.0.1:" + CLIENT_PORT_OBS, ClientBase.CONNECTION_TIMEOUT));}
testLaggingObserverMaster
public voidf6325_1) throws Exception
{    final int OM_PROXY_PORT = PortAssignment.unique();    PortForwarder forwarder = setUp(OM_PROXY_PORT);        int leaderPort;    MainThread leader;    MainThread follower;    if (q1.getQuorumPeer().leader != null) {        leaderPort = CLIENT_PORT_QP1;        leader = q1;        follower = q2;    } else if (q2.getQuorumPeer().leader != null) {        leaderPort = CLIENT_PORT_QP2;        leader = q2;        follower = q1;    } else {        throw new RuntimeException("No leader");    }        zk = new ZooKeeper("127.0.0.1:" + leaderPort, ClientBase.CONNECTION_TIMEOUT, this);    for (int i = 0; i < 10; i++) {        zk.create("/bulk" + i, ("initial data of some size").getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    }    zk.close();    q3.start();    assertTrue("waiting for server 3 being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_OBS, CONNECTION_TIMEOUT));    latch = new CountDownLatch(1);    zk = new ZooKeeper("127.0.0.1:" + leaderPort, ClientBase.CONNECTION_TIMEOUT, this);    latch.await();    assertEquals(zk.getState(), States.CONNECTED);    zk.create("/init", "first".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    final long lastLoggedZxid = leader.getQuorumPeer().getLastLoggedZxid();        waitFor("Timeout waiting for observer sync", new WaitForCondition() {        public boolean evaluate() {            return lastLoggedZxid == q3.getQuorumPeer().getLastLoggedZxid();        }    }, 30);        if (forwarder != null) {        forwarder.shutdown();    }    for (int i = 0; i < 10; i++) {        zk.create("/basic" + i, "second".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    }    DelayRequestProcessor delayRequestProcessor = null;    if (testObserverMaster) {        FollowerZooKeeperServer followerZooKeeperServer = (FollowerZooKeeperServer) follower.getQuorumPeer().getActiveServer();        delayRequestProcessor = DelayRequestProcessor.injectDelayRequestProcessor(followerZooKeeperServer);    }    zk.create("/target1", "third".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/target2", "third".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);            forwarder = testObserverMaster ? new PortForwarder(OM_PROXY_PORT, OM_PORT) : null;    assertTrue("waiting for server 3 being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_OBS, CONNECTION_TIMEOUT));    assertNotNull("Leader switched", leader.getQuorumPeer().leader);    if (delayRequestProcessor != null) {        delayRequestProcessor.unblockQueue();    }    latch = new CountDownLatch(1);    ZooKeeper obsZk = new ZooKeeper("127.0.0.1:" + CLIENT_PORT_OBS, ClientBase.CONNECTION_TIMEOUT, this);    latch.await();    zk.create("/finalop", "fourth".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    assertEquals("first", new String(obsZk.getData("/init", null, null)));    assertEquals("third", new String(obsZk.getData("/target1", null, null)));    obsZk.close();    shutdown();    try {        if (forwarder != null) {            forwarder.shutdown();        }    } catch (Exception e) {        }}
evaluate
public boolean zookeeper_f6326_0()
{    return lastLoggedZxid == q3.getQuorumPeer().getLastLoggedZxid();}
testObserver
public voidf6327_1) throws Exception
{        latch = new CountDownLatch(2);    setUp(-1);    q3.start();    assertTrue("waiting for server 3 being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_OBS, CONNECTION_TIMEOUT));    if (testObserverMaster) {        int masterPort = q3.getQuorumPeer().observer.getSocket().getPort();                assertEquals("observer failed to connect to observer master", masterPort, OM_PORT);    }    zk = new ZooKeeper("127.0.0.1:" + CLIENT_PORT_OBS, ClientBase.CONNECTION_TIMEOUT, this);    zk.create("/obstest", "test".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        assertEquals(new String(zk.getData("/obstest", null, null)), "test");        zk.sync("/", null, null);    zk.setData("/obstest", "test2".getBytes(), -1);    zk.getChildren("/", false);    assertEquals(zk.getState(), States.CONNECTED);            q2.shutdown();    assertTrue("Waiting for server 2 to shut down", ClientBase.waitForServerDown("127.0.0.1:" + CLIENT_PORT_QP2, ClientBase.CONNECTION_TIMEOUT));            latch.await();    assertNotSame("Client is still connected to non-quorate cluster", KeeperState.SyncConnected, lastEvent.getState());        try {        assertNotEquals("Shouldn't get a response when cluster not quorate!", "test", new String(zk.getData("/obstest", null, null)));    } catch (ConnectionLossException c) {            }    latch = new CountDownLatch(1);                q2.start();        assertTrue("waiting for server 2 being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_QP2, CONNECTION_TIMEOUT));        latch.await();            assertTrue("Client didn't reconnect to quorate ensemble (state was" + lastEvent.getState() + ")", (KeeperState.SyncConnected == lastEvent.getState() || KeeperState.Expired == lastEvent.getState()));        int leaderProxyPort = PortAssignment.unique();    int obsProxyPort = PortAssignment.unique();    int leaderPort = q1.getQuorumPeer().leader == null ? CLIENT_PORT_QP2 : CLIENT_PORT_QP1;    PortForwarder leaderPF = new PortForwarder(leaderProxyPort, leaderPort);    latch = new CountDownLatch(1);    ZooKeeper client = new ZooKeeper(String.format("127.0.0.1:%d,127.0.0.1:%d", leaderProxyPort, obsProxyPort), ClientBase.CONNECTION_TIMEOUT, this);    latch.await();    client.create("/revalidtest", "test".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);    assertNotNull("Read-after write failed", client.exists("/revalidtest", null));    latch = new CountDownLatch(2);    PortForwarder obsPF = new PortForwarder(obsProxyPort, CLIENT_PORT_OBS);    try {        leaderPF.shutdown();    } catch (Exception e) {        }    latch.await();    assertEquals(new String(client.getData("/revalidtest", null, null)), "test");    client.close();    obsPF.shutdown();    shutdown();}
testRevalidation
public void zookeeper_f6328_0() throws Exception
{    setUp(-1);    q3.start();    assertTrue("waiting for server 3 being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_OBS, CONNECTION_TIMEOUT));    final int leaderProxyPort = PortAssignment.unique();    final int obsProxyPort = PortAssignment.unique();    int leaderPort = q1.getQuorumPeer().leader == null ? CLIENT_PORT_QP2 : CLIENT_PORT_QP1;    PortForwarder leaderPF = new PortForwarder(leaderProxyPort, leaderPort);    latch = new CountDownLatch(1);    zk = new ZooKeeper(String.format("127.0.0.1:%d,127.0.0.1:%d", leaderProxyPort, obsProxyPort), ClientBase.CONNECTION_TIMEOUT, this);    latch.await();    zk.create("/revalidtest", "test".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);    assertNotNull("Read-after write failed", zk.exists("/revalidtest", null));    latch = new CountDownLatch(2);    PortForwarder obsPF = new PortForwarder(obsProxyPort, CLIENT_PORT_OBS);    try {        leaderPF.shutdown();    } catch (Exception e) {        }    latch.await();    assertEquals(new String(zk.getData("/revalidtest", null, null)), "test");    obsPF.shutdown();    shutdown();}
testInOrderCommits
public voidf6329_1) throws Exception
{    setUp(-1);    zk = new ZooKeeper("127.0.0.1:" + CLIENT_PORT_QP1, ClientBase.CONNECTION_TIMEOUT, null);    for (int i = 0; i < 10; i++) {        zk.create("/bulk" + i, ("Initial data of some size").getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    }    zk.close();    q3.start();    assertTrue("waiting for observer to be up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_OBS, CONNECTION_TIMEOUT));    latch = new CountDownLatch(1);    zk = new ZooKeeper("127.0.0.1:" + CLIENT_PORT_QP1, ClientBase.CONNECTION_TIMEOUT, this);    latch.await();    assertEquals(zk.getState(), States.CONNECTED);    zk.create("/init", "first".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    final long zxid = q1.getQuorumPeer().getLastLoggedZxid();        waitFor("Timeout waiting for observer sync", new WaitForCondition() {        public boolean evaluate() {            return zxid == q3.getQuorumPeer().getLastLoggedZxid();        }    }, 30);    ZooKeeper obsZk = new ZooKeeper("127.0.0.1:" + CLIENT_PORT_OBS, ClientBase.CONNECTION_TIMEOUT, this);    int followerPort = q1.getQuorumPeer().leader == null ? CLIENT_PORT_QP1 : CLIENT_PORT_QP2;    ZooKeeper fZk = new ZooKeeper("127.0.0.1:" + followerPort, ClientBase.CONNECTION_TIMEOUT, this);    final int numTransactions = 10001;    CountDownLatch gate = new CountDownLatch(1);    CountDownLatch oAsyncLatch = new CountDownLatch(numTransactions);    Thread oAsyncWriteThread = new Thread(new AsyncWriter(obsZk, numTransactions, true, oAsyncLatch, "/obs", gate));    CountDownLatch fAsyncLatch = new CountDownLatch(numTransactions);    Thread fAsyncWriteThread = new Thread(new AsyncWriter(fZk, numTransactions, true, fAsyncLatch, "/follower", gate));        oAsyncWriteThread.start();    fAsyncWriteThread.start();    gate.countDown();    oAsyncLatch.await();    fAsyncLatch.await();    oAsyncWriteThread.join(ClientBase.CONNECTION_TIMEOUT);    if (oAsyncWriteThread.isAlive()) {            }    fAsyncWriteThread.join(ClientBase.CONNECTION_TIMEOUT);    if (fAsyncWriteThread.isAlive()) {            }    obsZk.close();    fZk.close();    shutdown();}
evaluate
public boolean zookeeper_f6330_0()
{    return zxid == q3.getQuorumPeer().getLastLoggedZxid();}
testAdminCommands
public void zookeeper_f6331_0() throws IOException, MBeanException, InstanceNotFoundException, ReflectionException, InterruptedException, MalformedObjectNameException, AttributeNotFoundException, InvalidAttributeValueException, KeeperException
{        for (ZKMBeanInfo beanInfo : MBeanRegistry.getInstance().getRegisteredBeans()) {        MBeanRegistry.getInstance().unregister(beanInfo);    }    JMXEnv.setUp();    setUp(-1);    q3.start();    assertTrue("waiting for observer to be up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_OBS, CONNECTION_TIMEOUT));        zk = new ZooKeeper("127.0.0.1:" + CLIENT_PORT_OBS, ClientBase.CONNECTION_TIMEOUT, this);    zk.create("/obstest", "test".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    assertEquals(new String(zk.getData("/obstest", null, null)), "test");        final Map<String, String> emptyMap = Collections.emptyMap();    Map<String, Object> stats = Commands.runCommand("mntr", q3.getQuorumPeer().getActiveServer(), emptyMap).toMap();    assertTrue("observer not emitting observer_master_id", stats.containsKey("observer_master_id"));        if (testObserverMaster) {        if (q1.getQuorumPeer().leader == null) {            assertEquals(Integer.valueOf(1), q1.getQuorumPeer().getSynced_observers_metric());        } else {            assertEquals(Integer.valueOf(0), q1.getQuorumPeer().getSynced_observers_metric());        }    } else {        if (q1.getQuorumPeer().leader == null) {            assertNull(q1.getQuorumPeer().getSynced_observers_metric());        } else {            assertEquals(Integer.valueOf(1), q1.getQuorumPeer().getSynced_observers_metric());        }    }        if (testObserverMaster) {        if (q2.getQuorumPeer().leader == null) {            assertEquals(Integer.valueOf(1), q2.getQuorumPeer().getSynced_observers_metric());        } else {            assertEquals(Integer.valueOf(0), q2.getQuorumPeer().getSynced_observers_metric());        }    } else {        if (q2.getQuorumPeer().leader == null) {            assertNull(q2.getQuorumPeer().getSynced_observers_metric());        } else {            assertEquals(Integer.valueOf(1), q2.getQuorumPeer().getSynced_observers_metric());        }    }        ObjectName connBean = null;    for (ObjectName bean : JMXEnv.conn().queryNames(new ObjectName(MBeanRegistry.DOMAIN + ":*"), null)) {        if (bean.getCanonicalName().contains("Learner_Connections") && bean.getCanonicalName().contains("id:" + q3.getQuorumPeer().getId())) {            connBean = bean;            break;        }    }    assertNotNull("could not find connection bean", connBean);    latch = new CountDownLatch(1);    JMXEnv.conn().invoke(connBean, "terminateConnection", new Object[0], null);    assertTrue("server failed to disconnect on terminate", latch.await(CONNECTION_TIMEOUT / 2, TimeUnit.MILLISECONDS));    assertTrue("waiting for server 3 being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_OBS, CONNECTION_TIMEOUT));    final String obsBeanName = String.format("org.apache.ZooKeeperService:name0=ReplicatedServer_id%d,name1=replica.%d,name2=Observer", q3.getQuorumPeer().getId(), q3.getQuorumPeer().getId());    Set<ObjectName> names = JMXEnv.conn().queryNames(new ObjectName(obsBeanName), null);    assertEquals("expecting singular observer bean", 1, names.size());    ObjectName obsBean = names.iterator().next();    if (testObserverMaster) {                long observerMasterId = q3.getQuorumPeer().observer.getLearnerMasterId();        latch = new CountDownLatch(1);        JMXEnv.conn().setAttribute(obsBean, new Attribute("LearnerMaster", Long.toString(3 - observerMasterId)));        assertTrue("server failed to disconnect on terminate", latch.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS));        assertTrue("waiting for server 3 being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_OBS, CONNECTION_TIMEOUT));    } else {                final long leaderId = q1.getQuorumPeer().leader == null ? 2 : 1;        try {            JMXEnv.conn().setAttribute(obsBean, new Attribute("LearnerMaster", Long.toString(3 - leaderId)));            fail("should have seen an exception on previous command");        } catch (RuntimeMBeanException e) {            assertEquals("mbean failed for the wrong reason", IllegalArgumentException.class, e.getCause().getClass());        }    }    shutdown();    JMXEnv.tearDown();}
createServerString
private String zookeeper_f6332_0(String type, long serverId, int clientPort)
{    return "server." + serverId + "=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ":" + type + ";" + clientPort;}
waitServerUp
private void zookeeper_f6333_0(int clientPort)
{    assertTrue("waiting for server being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPort, CONNECTION_TIMEOUT));}
createAdmin
private ZooKeeperAdmin zookeeper_f6334_0(int clientPort) throws IOException
{    System.setProperty("zookeeper.DigestAuthenticationProvider.superDigest", "super:D/InIHSb7yEEbrWz8b9l71RjZJU=");    QuorumPeerConfig.setReconfigEnabled(true);    ZooKeeperAdmin admin = new ZooKeeperAdmin("127.0.0.1:" + clientPort, ClientBase.CONNECTION_TIMEOUT, DummyWatcher.INSTANCE);    admin.addAuthInfo("digest", "super:test".getBytes());    return admin;}
testDynamicReconfig
public voidf6335_1) throws InterruptedException, IOException, KeeperException
{    if (!testObserverMaster) {        return;    }    ClientBase.setupTestEnv();                            int clientPort1 = PortAssignment.unique();    int clientPort2 = PortAssignment.unique();    int omPort1 = PortAssignment.unique();    int omPort2 = PortAssignment.unique();    String quorumCfgSection = createServerString("participant", 1, clientPort1) + "\n" + createServerString("participant", 2, clientPort2);    MainThread s1 = new MainThread(1, clientPort1, quorumCfgSection, String.format("observerMasterPort=%d%n", omPort1));    MainThread s2 = new MainThread(2, clientPort2, quorumCfgSection, String.format("observerMasterPort=%d%n", omPort2));    s1.start();    s2.start();    waitServerUp(clientPort1);    waitServerUp(clientPort2);        long nonLeaderOMPort = s1.getQuorumPeer().leader == null ? omPort1 : omPort2;    int observerClientPort = PortAssignment.unique();    int observerId = 10;    MainThread observer = new MainThread(observerId, observerClientPort, quorumCfgSection + "\n" + createServerString("observer", observerId, observerClientPort), String.format("observerMasterPort=%d%n", nonLeaderOMPort));        observer.start();    waitServerUp(observerClientPort);        final LinkedBlockingQueue<KeeperState> states = new LinkedBlockingQueue<KeeperState>();    ZooKeeper observerClient = new ZooKeeper("127.0.0.1:" + observerClientPort, ClientBase.CONNECTION_TIMEOUT, event -> {        try {            states.put(event.getState());        } catch (InterruptedException ignore) {        }    });        KeeperState state = states.poll(1000, TimeUnit.MILLISECONDS);    assertEquals(KeeperState.SyncConnected, state);        ArrayList<String> newServers = new ArrayList<String>();    String server = "server.3=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ":participant;localhost:" + PortAssignment.unique();    newServers.add(server);    ZooKeeperAdmin admin = createAdmin(clientPort1);    ReconfigTest.reconfig(admin, newServers, null, null, -1);        ReconfigTest.testServerHasConfig(observerClient, newServers, null);            state = states.poll(1000, TimeUnit.MILLISECONDS);    assertNull(state);    admin.close();    observerClient.close();    observer.shutdown();    s2.shutdown();    s1.shutdown();}
process
public voidf6336_1WatchedEvent event)
{    lastEvent = event;    if (latch != null) {        latch.countDown();    }    }
run
public voidf6337_1)
{    if (gate != null) {        try {            gate.await();        } catch (InterruptedException e) {                        return;        }    }    for (int i = 0; i < numTransactions; i++) {        final boolean pleaseLog = i % 100 == 0;        client.create(root + i, "inner thread".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, new AsyncCallback.StringCallback() {            @Override            public void processResult(int rc, String path, Object ctx, String name) {                writerLatch.countDown();                if (pleaseLog) {                                    }            }        }, null);        if (pleaseLog) {                        if (issueSync) {                client.sync(root + "0", null, null);            }        }    }}
processResult
public voidf6338_1int rc, String path, Object ctx, String name)
{    writerLatch.countDown();    if (pleaseLog) {            }}
setUp
public void zookeeper_f6339_0() throws Exception
{    qb.setUp(true);    cht.hostPort = qb.hostPort;    cht.setUpAll();}
testHammerBasic
public void zookeeper_f6340_0() throws Throwable
{    cht.testHammerBasic();}
testObserverOnly
public void zookeeper_f6341_0() throws Exception
{    ClientBase.setupTestEnv();    final int CLIENT_PORT_QP1 = PortAssignment.unique();    String quorumCfgSection = "server.1=127.0.0.1:" + (PortAssignment.unique()) + ":" + (PortAssignment.unique()) + ":observer;" + CLIENT_PORT_QP1 + "\n";    MainThread q1 = new MainThread(1, CLIENT_PORT_QP1, quorumCfgSection);    q1.start();    q1.join(ClientBase.CONNECTION_TIMEOUT);    assertFalse(q1.isAlive());}
testObserverWithStandlone
public void zookeeper_f6342_0() throws Exception
{    ClientBase.setupTestEnv();    final int CLIENT_PORT_QP1 = PortAssignment.unique();    String quorumCfgSection = "server.1=127.0.0.1:" + (PortAssignment.unique()) + ":" + (PortAssignment.unique()) + ":observer\n" + "server.2=127.0.0.1:" + (PortAssignment.unique()) + ":" + (PortAssignment.unique()) + "\npeerType=observer\n";    MainThread q1 = new MainThread(1, CLIENT_PORT_QP1, quorumCfgSection);    q1.start();    q1.join(ClientBase.CONNECTION_TIMEOUT);    assertFalse(q1.isAlive());}
testOOM
public void zookeeper_f6343_0() throws IOException, InterruptedException, KeeperException
{    File tmpDir = ClientBase.createTmpDir();            List<byte[]> hog = new ArrayList<>();    while (true) {        try {            hog.add(new byte[1024 * 1024 * 2]);        } catch (OutOfMemoryError e) {            hog.remove(0);            break;        }    }    ClientBase.setupTestEnv();    ZooKeeperServer zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);    final int PORT = PortAssignment.unique();    ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);    f.startup(zks);    assertTrue("waiting for server up", ClientBase.waitForServerUp("127.0.0.1:" + PORT, CONNECTION_TIMEOUT));    System.err.println("OOM Stage 0");    utestPrep(PORT);    System.out.println("Free = " + Runtime.getRuntime().freeMemory() + " total = " + Runtime.getRuntime().totalMemory() + " max = " + Runtime.getRuntime().maxMemory());    System.err.println("OOM Stage 1");    for (int i = 0; i < 1000; i++) {        System.out.println(i);        utestExists(PORT);    }    System.out.println("Free = " + Runtime.getRuntime().freeMemory() + " total = " + Runtime.getRuntime().totalMemory() + " max = " + Runtime.getRuntime().maxMemory());    System.err.println("OOM Stage 2");    for (int i = 0; i < 1000; i++) {        System.out.println(i);        utestGet(PORT);    }    System.out.println("Free = " + Runtime.getRuntime().freeMemory() + " total = " + Runtime.getRuntime().totalMemory() + " max = " + Runtime.getRuntime().maxMemory());    System.err.println("OOM Stage 3");    for (int i = 0; i < 1000; i++) {        System.out.println(i);        utestChildren(PORT);    }    System.out.println("Free = " + Runtime.getRuntime().freeMemory() + " total = " + Runtime.getRuntime().totalMemory() + " max = " + Runtime.getRuntime().maxMemory());    hog.get(0)[0] = (byte) 1;    f.shutdown();    zks.shutdown();    assertTrue("waiting for server down", ClientBase.waitForServerDown("127.0.0.1:" + PORT, CONNECTION_TIMEOUT));}
utestExists
private void zookeeper_f6344_0(int port) throws IOException, InterruptedException, KeeperException
{    ZooKeeper zk = new ZooKeeper("127.0.0.1:" + port, CONNECTION_TIMEOUT, TEST_WATCHER);    for (int i = 0; i < 10000; i++) {        zk.exists("/this/path/doesnt_exist!", true);    }    zk.close();}
utestPrep
private void zookeeper_f6345_0(int port) throws IOException, InterruptedException, KeeperException
{    ZooKeeper zk = new ZooKeeper("127.0.0.1:" + port, CONNECTION_TIMEOUT, TEST_WATCHER);    for (int i = 0; i < 10000; i++) {        zk.create("/" + i, null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    }    zk.close();}
utestGet
private void zookeeper_f6346_0(int port) throws IOException, InterruptedException, KeeperException
{    ZooKeeper zk = new ZooKeeper("127.0.0.1:" + port, CONNECTION_TIMEOUT, TEST_WATCHER);    for (int i = 0; i < 10000; i++) {        Stat stat = new Stat();        zk.getData("/" + i, true, stat);    }    zk.close();}
utestChildren
private void zookeeper_f6347_0(int port) throws IOException, InterruptedException, KeeperException
{    ZooKeeper zk = new ZooKeeper("127.0.0.1:" + port, CONNECTION_TIMEOUT, TEST_WATCHER);    for (int i = 0; i < 10000; i++) {        zk.getChildren("/" + i, true);    }    zk.close();}
initialize
public void zookeeper_f6348_0()
{    this.osMbean = new OSMXBean();    assertNotNull("Could not initialize OSMXBean object!", osMbean);}
testGetUnix
public final voidf6349_1)
{    boolean isUnix = osMbean.getUnix();    if (!isUnix) {            } else {            }}
testGetOpenFileDescriptorCount
public final voidf6350_1)
{    if (osMbean != null && osMbean.getUnix()) {        ofdc = osMbean.getOpenFileDescriptorCount();            }    assertFalse("The number of open file descriptor is negative", (ofdc < 0));}
testGetMaxFileDescriptorCount
public final voidf6351_1)
{    if (osMbean != null && osMbean.getUnix()) {        mfdc = osMbean.getMaxFileDescriptorCount();            }    assertFalse("The max file descriptor number is negative", (mfdc < 0));}
testNull
public void zookeeper_f6352_0()
{}
setUp
public void zookeeper_f6353_0() throws Exception
{    setUp(false);}
setUp
protected voidf6354_1boolean withObservers) throws Exception
{        setupTestEnv();    JMXEnv.setUp();    setUpAll();    port1 = PortAssignment.unique();    port2 = PortAssignment.unique();    port3 = PortAssignment.unique();    port4 = PortAssignment.unique();    port5 = PortAssignment.unique();    portLE1 = PortAssignment.unique();    portLE2 = PortAssignment.unique();    portLE3 = PortAssignment.unique();    portLE4 = PortAssignment.unique();    portLE5 = PortAssignment.unique();    portClient1 = PortAssignment.unique();    portClient2 = PortAssignment.unique();    portClient3 = PortAssignment.unique();    portClient4 = PortAssignment.unique();    portClient5 = PortAssignment.unique();    hostPort = "127.0.0.1:" + portClient1 + ",127.0.0.1:" + portClient2 + ",127.0.0.1:" + portClient3 + ",127.0.0.1:" + portClient4 + ",127.0.0.1:" + portClient5;        s1dir = ClientBase.createTmpDir();    s2dir = ClientBase.createTmpDir();    s3dir = ClientBase.createTmpDir();    s4dir = ClientBase.createTmpDir();    s5dir = ClientBase.createTmpDir();    startServers(withObservers);    OSMXBean osMbean = new OSMXBean();    if (osMbean.getUnix()) {            }    }
startServers
 void zookeeper_f6355_0() throws Exception
{    startServers(false);}
startServers
 voidf6356_1boolean withObservers) throws Exception
{    int tickTime = 2000;    int initLimit = 3;    int syncLimit = 3;    int connectToLearnerMasterLimit = 3;    Map<Long, QuorumServer> peers = new HashMap<Long, QuorumServer>();    peers.put(Long.valueOf(1), new QuorumServer(1, new InetSocketAddress(LOCALADDR, port1), new InetSocketAddress(LOCALADDR, portLE1), new InetSocketAddress(LOCALADDR, portClient1), LearnerType.PARTICIPANT));    peers.put(Long.valueOf(2), new QuorumServer(2, new InetSocketAddress(LOCALADDR, port2), new InetSocketAddress(LOCALADDR, portLE2), new InetSocketAddress(LOCALADDR, portClient2), LearnerType.PARTICIPANT));    peers.put(Long.valueOf(3), new QuorumServer(3, new InetSocketAddress(LOCALADDR, port3), new InetSocketAddress(LOCALADDR, portLE3), new InetSocketAddress(LOCALADDR, portClient3), LearnerType.PARTICIPANT));    peers.put(Long.valueOf(4), new QuorumServer(4, new InetSocketAddress(LOCALADDR, port4), new InetSocketAddress(LOCALADDR, portLE4), new InetSocketAddress(LOCALADDR, portClient4), LearnerType.PARTICIPANT));    peers.put(Long.valueOf(5), new QuorumServer(5, new InetSocketAddress(LOCALADDR, port5), new InetSocketAddress(LOCALADDR, portLE5), new InetSocketAddress(LOCALADDR, portClient5), LearnerType.PARTICIPANT));    if (withObservers) {        peers.get(Long.valueOf(4)).type = LearnerType.OBSERVER;        peers.get(Long.valueOf(5)).type = LearnerType.OBSERVER;    }        s1 = new QuorumPeer(peers, s1dir, s1dir, portClient1, 3, 1, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);    assertEquals(portClient1, s1.getClientPort());        s2 = new QuorumPeer(peers, s2dir, s2dir, portClient2, 3, 2, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);    assertEquals(portClient2, s2.getClientPort());        s3 = new QuorumPeer(peers, s3dir, s3dir, portClient3, 3, 3, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);    assertEquals(portClient3, s3.getClientPort());        s4 = new QuorumPeer(peers, s4dir, s4dir, portClient4, 3, 4, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);    assertEquals(portClient4, s4.getClientPort());        s5 = new QuorumPeer(peers, s5dir, s5dir, portClient5, 3, 5, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);    assertEquals(portClient5, s5.getClientPort());    if (withObservers) {        s4.setLearnerType(LearnerType.OBSERVER);        s5.setLearnerType(LearnerType.OBSERVER);    }                        s1.enableLocalSessions(localSessionsEnabled);    s2.enableLocalSessions(localSessionsEnabled);    s3.enableLocalSessions(localSessionsEnabled);    s4.enableLocalSessions(localSessionsEnabled);    s5.enableLocalSessions(localSessionsEnabled);    s1.enableLocalSessionsUpgrading(localSessionsUpgradingEnabled);    s2.enableLocalSessionsUpgrading(localSessionsUpgradingEnabled);    s3.enableLocalSessionsUpgrading(localSessionsUpgradingEnabled);    s4.enableLocalSessionsUpgrading(localSessionsUpgradingEnabled);    s5.enableLocalSessionsUpgrading(localSessionsUpgradingEnabled);        s1.start();        s2.start();        s3.start();        s4.start();        s5.start();            for (String hp : hostPort.split(",")) {        assertTrue("waiting for server up", ClientBase.waitForServerUp(hp, CONNECTION_TIMEOUT));            }        JMXEnv.dump();        Set<String> ensureNames = new LinkedHashSet<String>();    for (int i = 1; i <= 5; i++) {        ensureNames.add("InMemoryDataTree");    }    for (int i = 1; i <= 5; i++) {        ensureNames.add("name0=ReplicatedServer_id" + i + ",name1=replica." + i + ",name2=");    }    for (int i = 1; i <= 5; i++) {        for (int j = 1; j <= 5; j++) {            ensureNames.add("name0=ReplicatedServer_id" + i + ",name1=replica." + j);        }    }    for (int i = 1; i <= 5; i++) {        ensureNames.add("name0=ReplicatedServer_id" + i);    }    JMXEnv.ensureAll(ensureNames.toArray(new String[ensureNames.size()]));}
getLeaderIndex
public int zookeeper_f6357_0()
{    if (s1.getPeerState() == ServerState.LEADING) {        return 0;    } else if (s2.getPeerState() == ServerState.LEADING) {        return 1;    } else if (s3.getPeerState() == ServerState.LEADING) {        return 2;    } else if (s4.getPeerState() == ServerState.LEADING) {        return 3;    } else if (s5.getPeerState() == ServerState.LEADING) {        return 4;    }    return -1;}
getPeersMatching
public Stringf6358_1ServerState state)
{    StringBuilder hosts = new StringBuilder();    for (QuorumPeer p : getPeerList()) {        if (p.getPeerState() == state) {            hosts.append(String.format("%s:%d,", LOCALADDR, p.getClientAddress().getPort()));        }    }        return hosts.toString();}
getPeerList
public ArrayList<QuorumPeer> zookeeper_f6359_0()
{    ArrayList<QuorumPeer> peers = new ArrayList<QuorumPeer>();    peers.add(s1);    peers.add(s2);    peers.add(s3);    peers.add(s4);    peers.add(s5);    return peers;}
getPeerByClientPort
public QuorumPeer zookeeper_f6360_0(int clientPort)
{    for (QuorumPeer p : getPeerList()) {        if (p.getClientAddress().getPort() == clientPort) {            return p;        }    }    return null;}
setupServers
public void zookeeper_f6361_0() throws IOException
{    setupServer(1);    setupServer(2);    setupServer(3);    setupServer(4);    setupServer(5);}
setupServer
public voidf6362_1int i) throws IOException
{    int tickTime = 2000;    int initLimit = 3;    int syncLimit = 3;    int connectToLearnerMasterLimit = 3;    if (peers == null) {        peers = new HashMap<Long, QuorumServer>();        peers.put(Long.valueOf(1), new QuorumServer(1, new InetSocketAddress(LOCALADDR, port1), new InetSocketAddress(LOCALADDR, portLE1), new InetSocketAddress(LOCALADDR, portClient1), LearnerType.PARTICIPANT));        peers.put(Long.valueOf(2), new QuorumServer(2, new InetSocketAddress(LOCALADDR, port2), new InetSocketAddress(LOCALADDR, portLE2), new InetSocketAddress(LOCALADDR, portClient2), LearnerType.PARTICIPANT));        peers.put(Long.valueOf(3), new QuorumServer(3, new InetSocketAddress(LOCALADDR, port3), new InetSocketAddress(LOCALADDR, portLE3), new InetSocketAddress(LOCALADDR, portClient3), LearnerType.PARTICIPANT));        peers.put(Long.valueOf(4), new QuorumServer(4, new InetSocketAddress(LOCALADDR, port4), new InetSocketAddress(LOCALADDR, portLE4), new InetSocketAddress(LOCALADDR, portClient4), LearnerType.PARTICIPANT));        peers.put(Long.valueOf(5), new QuorumServer(5, new InetSocketAddress(LOCALADDR, port5), new InetSocketAddress(LOCALADDR, portLE5), new InetSocketAddress(LOCALADDR, portClient5), LearnerType.PARTICIPANT));    }    switch(i) {        case 1:                        s1 = new QuorumPeer(peers, s1dir, s1dir, portClient1, 3, 1, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);            assertEquals(portClient1, s1.getClientPort());            break;        case 2:                        s2 = new QuorumPeer(peers, s2dir, s2dir, portClient2, 3, 2, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);            assertEquals(portClient2, s2.getClientPort());            break;        case 3:                        s3 = new QuorumPeer(peers, s3dir, s3dir, portClient3, 3, 3, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);            assertEquals(portClient3, s3.getClientPort());            break;        case 4:                        s4 = new QuorumPeer(peers, s4dir, s4dir, portClient4, 3, 4, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);            assertEquals(portClient4, s4.getClientPort());            break;        case 5:                        s5 = new QuorumPeer(peers, s5dir, s5dir, portClient5, 3, 5, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);            assertEquals(portClient5, s5.getClientPort());    }}
tearDown
public voidf6363_1) throws Exception
{        OSMXBean osMbean = new OSMXBean();    if (osMbean.getUnix()) {            }    shutdownServers();    for (String hp : hostPort.split(",")) {        assertTrue("waiting for server down", ClientBase.waitForServerDown(hp, ClientBase.CONNECTION_TIMEOUT));            }    JMXEnv.tearDown();}
shutdownServers
public void zookeeper_f6364_0()
{    shutdown(s1);    shutdown(s2);    shutdown(s3);    shutdown(s4);    shutdown(s5);}
shutdown
public static voidf6365_1QuorumPeer qp)
{    if (qp == null) {        return;    }    try {                qp.shutdown();        Election e = qp.getElectionAlg();        if (e != null) {                        e.shutdown();        } else {                    }                long readTimeout = qp.getTickTime() * qp.getInitLimit();        long connectTimeout = qp.getTickTime() * qp.getSyncLimit();        long maxTimeout = Math.max(readTimeout, connectTimeout);        maxTimeout = Math.max(maxTimeout, ClientBase.CONNECTION_TIMEOUT);        qp.join(maxTimeout * 2);        if (qp.isAlive()) {            fail("QP failed to shutdown in " + (maxTimeout * 2) + " seconds: " + qp.getName());        }    } catch (InterruptedException e) {            }}
createClient
protected TestableZooKeeper zookeeper_f6366_0() throws IOException, InterruptedException
{    return createClient(hostPort);}
createClient
protected TestableZooKeeper zookeeper_f6367_0(String hp) throws IOException, InterruptedException
{    CountdownWatcher watcher = new CountdownWatcher();    return createClient(watcher, hp);}
createClient
protected TestableZooKeeper zookeeper_f6368_0(CountdownWatcher watcher, ServerState state) throws IOException, InterruptedException
{    return createClient(watcher, getPeersMatching(state));}
setUp
public void zookeeper_f6369_0() throws Exception
{    qb.setUp();    cht.hostPort = qb.hostPort;    cht.setUpAll();}
tearDown
public void zookeeper_f6370_0() throws Exception
{    cht.tearDownAll();    qb.tearDown();}
testHammerBasic
public void zookeeper_f6371_0() throws Throwable
{    cht.testHammerBasic();}
testMajQuorums
public voidf6372_1) throws Throwable
{        ArrayList<QuorumPeer> peers = getPeerList();    for (int i = 1; i <= peers.size(); i++) {        QuorumPeer qp = peers.get(i - 1);        Long electionTimeTaken = -1L;        String bean = "";        if (qp.getPeerState() == ServerState.FOLLOWING) {            bean = String.format("%s:name0=ReplicatedServer_id%d,name1=replica.%d,name2=Follower", MBeanRegistry.DOMAIN, i, i);        } else if (qp.getPeerState() == ServerState.LEADING) {            bean = String.format("%s:name0=ReplicatedServer_id%d,name1=replica.%d,name2=Leader", MBeanRegistry.DOMAIN, i, i);        }        electionTimeTaken = (Long) JMXEnv.ensureBeanAttribute(bean, "ElectionTimeTaken");        assertTrue("Wrong electionTimeTaken value!", electionTimeTaken >= 0);    }        setUp(false);    Proposal p = new Proposal();    p.addQuorumVerifier(s1.getQuorumVerifier());        p.addAck(Long.valueOf(1));    p.addAck(Long.valueOf(2));    assertEquals(false, p.hasAllQuorums());        p.addAck(Long.valueOf(6));    assertEquals(false, p.hasAllQuorums());        p.addAck(Long.valueOf(3));    assertEquals(true, p.hasAllQuorums());        setUp(true);    p = new Proposal();    p.addQuorumVerifier(s1.getQuorumVerifier());        p.addAck(Long.valueOf(1));    assertEquals(false, p.hasAllQuorums());        p.addAck(Long.valueOf(4));    p.addAck(Long.valueOf(5));    assertEquals(false, p.hasAllQuorums());        p.addAck(Long.valueOf(6));    assertEquals(false, p.hasAllQuorums());        p.addAck(Long.valueOf(2));    assertEquals(true, p.hasAllQuorums());}
testQuotaWithQuorum
public void zookeeper_f6373_0() throws Exception
{    ZooKeeper zk = createClient();    zk.setData("/", "some".getBytes(), -1);    zk.create("/a", "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    int i = 0;    for (i = 0; i < 300; i++) {        zk.create("/a/" + i, "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    }    SetQuotaCommand.createQuota(zk, "/a", 1000L, 5000);    String statPath = Quotas.quotaZookeeper + "/a" + "/" + Quotas.statNode;    byte[] data = zk.getData(statPath, false, new Stat());    StatsTrack st = new StatsTrack(new String(data));    assertTrue("bytes are set", st.getBytes() == 1204L);    assertTrue("num count is set", st.getCount() == 301);    for (i = 300; i < 600; i++) {        zk.create("/a/" + i, "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    }    data = zk.getData(statPath, false, new Stat());    st = new StatsTrack(new String(data));    assertTrue("bytes are set", st.getBytes() == 2404L);    assertTrue("num count is set", st.getCount() == 601);}
setUp
public void zookeeper_f6374_0() throws Exception
{    qb.setUp();    ct.hostPort = qb.hostPort;    ct.setUpAll();}
tearDown
public void zookeeper_f6375_0() throws Exception
{    ct.tearDownAll();    qb.tearDown();    if (qu != null) {        qu.tearDown();    }}
testDeleteWithChildren
public void zookeeper_f6376_0() throws Exception
{    ct.testDeleteWithChildren();}
testPing
public void zookeeper_f6377_0() throws Exception
{    ct.testPing();}
testSequentialNodeNames
public void zookeeper_f6378_0() throws IOException, InterruptedException, KeeperException
{    ct.testSequentialNodeNames();}
testACLs
public void zookeeper_f6379_0() throws Exception
{    ct.testACLs();}
testClientwithoutWatcherObj
public void zookeeper_f6380_0() throws IOException, InterruptedException, KeeperException
{    ct.testClientwithoutWatcherObj();}
testClientWithWatcherObj
public void zookeeper_f6381_0() throws IOException, InterruptedException, KeeperException
{    ct.testClientWithWatcherObj();}
testGetView
public void zookeeper_f6382_0()
{    assertEquals(5, qb.s1.getView().size());    assertEquals(5, qb.s2.getView().size());    assertEquals(5, qb.s3.getView().size());    assertEquals(5, qb.s4.getView().size());    assertEquals(5, qb.s5.getView().size());}
testViewContains
public void zookeeper_f6383_0()
{        assertTrue(qb.s1.viewContains(qb.s1.getId()));        assertTrue(qb.s1.viewContains(qb.s2.getId()));        assertFalse(qb.s1.viewContains(-1L));}
testLeaderShutdown
public void zookeeper_f6384_0() throws IOException, InterruptedException, KeeperException
{    ZooKeeper zk = new DisconnectableZooKeeper(qb.hostPort, ClientBase.CONNECTION_TIMEOUT, DummyWatcher.INSTANCE);    zk.create("/blah", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/blah/blah", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    Leader leader = qb.s1.leader;    if (leader == null) {        leader = qb.s2.leader;    }    if (leader == null) {        leader = qb.s3.leader;    }    if (leader == null) {        leader = qb.s4.leader;    }    if (leader == null) {        leader = qb.s5.leader;    }    assertNotNull(leader);    for (int i = 0; i < 5000; i++) {        zk.setData("/blah/blah", new byte[0], -1, new AsyncCallback.StatCallback() {            public void processResult(int rc, String path, Object ctx, Stat stat) {                counter++;                if (rc != 0) {                    errors++;                }            }        }, null);    }    for (LearnerHandler f : leader.getForwardingFollowers()) {        f.getSocket().shutdownInput();    }    for (int i = 0; i < 5000; i++) {        zk.setData("/blah/blah", new byte[0], -1, new AsyncCallback.StatCallback() {            public void processResult(int rc, String path, Object ctx, Stat stat) {                counter++;                if (rc != 0) {                    errors++;                }            }        }, null);    }        assertTrue(qb.s1.isAlive());    assertTrue(qb.s2.isAlive());    assertTrue(qb.s3.isAlive());    assertTrue(qb.s4.isAlive());    assertTrue(qb.s5.isAlive());    zk.close();}
processResult
public void zookeeper_f6385_0(int rc, String path, Object ctx, Stat stat)
{    counter++;    if (rc != 0) {        errors++;    }}
processResult
public void zookeeper_f6386_0(int rc, String path, Object ctx, Stat stat)
{    counter++;    if (rc != 0) {        errors++;    }}
testMultipleWatcherObjs
public void zookeeper_f6387_0() throws IOException, InterruptedException, KeeperException
{    ct.testMutipleWatcherObjs();}
testSessionMoved
public voidf6388_1) throws Exception
{    String[] hostPorts = qb.hostPort.split(",");    DisconnectableZooKeeper zk = new DisconnectableZooKeeper(hostPorts[0], ClientBase.CONNECTION_TIMEOUT, DummyWatcher.INSTANCE);    zk.create("/sessionMoveTest", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);        for (int i = 0; i < hostPorts.length * 2; i++) {        zk.dontReconnect();                DisconnectableZooKeeper zknew = new DisconnectableZooKeeper(hostPorts[(i + 1) % hostPorts.length], ClientBase.CONNECTION_TIMEOUT, DummyWatcher.INSTANCE, zk.getSessionId(), zk.getSessionPasswd());        zknew.setData("/", new byte[1], -1);        final int[] result = new int[1];        result[0] = Integer.MAX_VALUE;        zknew.sync("/", new AsyncCallback.VoidCallback() {            public void processResult(int rc, String path, Object ctx) {                synchronized (result) {                    result[0] = rc;                    result.notify();                }            }        }, null);        synchronized (result) {            if (result[0] == Integer.MAX_VALUE) {                result.wait(5000);            }        }                assertTrue(result[0] == KeeperException.Code.OK.intValue());        try {            zk.setData("/", new byte[1], -1);            fail("Should have lost the connection");        } catch (KeeperException.ConnectionLossException e) {        }        zk = zknew;    }    zk.close();}
processResult
public void zookeeper_f6389_0(int rc, String path, Object ctx)
{    synchronized (result) {        result[0] = rc;        result.notify();    }}
process
public void zookeeper_f6390_0(WatchedEvent event)
{    if (event.getState() == KeeperState.Disconnected) {        zkDisco = true;    }}
testSessionMovedWithMultiOp
public void zookeeper_f6391_0() throws Exception
{    String[] hostPorts = qb.hostPort.split(",");    DisconnectableZooKeeper zk = new DisconnectableZooKeeper(hostPorts[0], ClientBase.CONNECTION_TIMEOUT, DummyWatcher.INSTANCE);    zk.multi(Arrays.asList(Op.create("/testSessionMovedWithMultiOp", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL)));        ZooKeeper zknew = new ZooKeeper(hostPorts[1], ClientBase.CONNECTION_TIMEOUT, DummyWatcher.INSTANCE, zk.getSessionId(), zk.getSessionPasswd());    zknew.multi(Arrays.asList(Op.create("/testSessionMovedWithMultiOp-1", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL)));        try {        zk.multi(Arrays.asList(Op.create("/testSessionMovedWithMultiOp-Failed", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL)));        fail("Should have lost the connection");    } catch (KeeperException.ConnectionLossException e) {    }    zk.close();    zknew.close();}
testSessionMove
public void zookeeper_f6392_0() throws Exception
{    String[] hps = qb.hostPort.split(",");    DiscoWatcher oldWatcher = new DiscoWatcher();    DisconnectableZooKeeper zk = new DisconnectableZooKeeper(hps[0], ClientBase.CONNECTION_TIMEOUT, oldWatcher);    zk.create("/t1", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);    zk.dontReconnect();        DiscoWatcher watcher = new DiscoWatcher();    DisconnectableZooKeeper zknew = new DisconnectableZooKeeper(hps[1], ClientBase.CONNECTION_TIMEOUT, watcher, zk.getSessionId(), zk.getSessionPasswd());    zknew.create("/t2", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);    try {        zk.create("/t3", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);        fail("Should have lost the connection");    } catch (KeeperException.ConnectionLossException e) {                for (int i = 0; i < 30; i++) {            if (oldWatcher.zkDisco) {                break;            }            Thread.sleep(1000);        }        assertTrue(oldWatcher.zkDisco);    }    ArrayList<ZooKeeper> toClose = new ArrayList<ZooKeeper>();    toClose.add(zknew);        for (int i = 0; i < 10; i++) {        zknew.dontReconnect();        zknew = new DisconnectableZooKeeper(hps[1], ClientBase.CONNECTION_TIMEOUT, new DiscoWatcher(), zk.getSessionId(), zk.getSessionPasswd());        toClose.add(zknew);        zknew.create("/t-" + i, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);    }    for (ZooKeeper z : toClose) {        z.close();    }    zk.close();}
testFollowersStartAfterLeader
public void zookeeper_f6393_0() throws Exception
{    qu = new QuorumUtil(1);    CountdownWatcher watcher = new CountdownWatcher();    qu.startQuorum();    int index = 1;    while (qu.getPeer(index).peer.leader == null) {        index++;    }        qu.shutdown(index);        qu.start(index);            ZooKeeper zk = new ZooKeeper("127.0.0.1:" + qu.getPeer((index == 1) ? 2 : 1).peer.getClientPort(), ClientBase.CONNECTION_TIMEOUT, watcher);    try {        watcher.waitForConnected(CONNECTION_TIMEOUT);    } catch (TimeoutException e) {        fail("client could not connect to reestablished quorum: giving up after 30+ seconds.");    }    zk.close();}
testMultiToFollower
public void zookeeper_f6394_0() throws Exception
{    qu = new QuorumUtil(1);    CountdownWatcher watcher = new CountdownWatcher();    qu.startQuorum();    int index = 1;    while (qu.getPeer(index).peer.leader == null) {        index++;    }    ZooKeeper zk = new ZooKeeper("127.0.0.1:" + qu.getPeer((index == 1) ? 2 : 1).peer.getClientPort(), ClientBase.CONNECTION_TIMEOUT, watcher);    watcher.waitForConnected(CONNECTION_TIMEOUT);    zk.multi(Arrays.asList(Op.create("/multi0", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT), Op.create("/multi1", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT), Op.create("/multi2", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT)));    zk.getData("/multi0", false, null);    zk.getData("/multi1", false, null);    zk.getData("/multi2", false, null);    zk.close();}
getPeer
public PeerStruct zookeeper_f6395_0(int id)
{    return peers.get(id);}
enableLocalSession
public void zookeeper_f6396_0(boolean localSessionEnabled)
{    this.localSessionEnabled = localSessionEnabled;}
startAll
public voidf6397_1) throws IOException
{    shutdownAll();    for (int i = 1; i <= ALL; ++i) {        start(i);            }        for (String hp : hostPort.split(",")) {        assertTrue("waiting for server up", ClientBase.waitForServerUp(hp, ClientBase.CONNECTION_TIMEOUT));            }        if (disableJMXTest) {        return;    }        try {        JMXEnv.dump();                Set<String> ensureNames = new LinkedHashSet<String>();        for (int i = 1; i <= ALL; ++i) {            ensureNames.add("InMemoryDataTree");        }        for (int i = 1; i <= ALL; ++i) {            ensureNames.add("name0=ReplicatedServer_id" + i + ",name1=replica." + i + ",name2=");        }        for (int i = 1; i <= ALL; ++i) {            for (int j = 1; j <= ALL; ++j) {                ensureNames.add("name0=ReplicatedServer_id" + i + ",name1=replica." + j);            }        }        for (int i = 1; i <= ALL; ++i) {            ensureNames.add("name0=ReplicatedServer_id" + i);        }        JMXEnv.ensureAll(ensureNames.toArray(new String[ensureNames.size()]));    } catch (IOException e) {            } catch (InterruptedException e) {            }}
startQuorum
public void zookeeper_f6398_0() throws IOException
{    shutdownAll();    for (int i = 1; i <= N + 1; ++i) {        start(i);    }    for (int i = 1; i <= N + 1; ++i) {        assertTrue("Waiting for server up", ClientBase.waitForServerUp("127.0.0.1:" + getPeer(i).clientPort, ClientBase.CONNECTION_TIMEOUT));    }}
restart
public void zookeeper_f6400_0(int id) throws IOException
{    start(id);    assertTrue("Waiting for server up", ClientBase.waitForServerUp("127.0.0.1:" + getPeer(id).clientPort, ClientBase.CONNECTION_TIMEOUT));}
shutdownAll
public voidf6402_1)
{    for (int i = 1; i <= ALL; ++i) {        shutdown(i);    }    for (String hp : hostPort.split(",")) {        assertTrue("Waiting for server down", ClientBase.waitForServerDown(hp, ClientBase.CONNECTION_TIMEOUT));            }}
shutdown
public voidf6403_1int id)
{    QuorumPeer qp = getPeer(id).peer;    try {                qp.shutdown();        Election e = qp.getElectionAlg();        if (e != null) {                        e.shutdown();        } else {                    }                qp.join(30000);        if (qp.isAlive()) {            fail("QP failed to shutdown in 30 seconds: " + qp.getName());        }    } catch (InterruptedException e) {            }}
getConnString
public String zookeeper_f6404_0()
{    return hostPort;}
getConnectString
public String zookeeper_f6405_0(QuorumPeer peer)
{    return "127.0.0.1:" + peer.getClientPort();}
getLeaderQuorumPeer
public QuorumPeer zookeeper_f6406_0()
{    for (PeerStruct ps : peers.values()) {        if (ps.peer.leader != null) {            return ps.peer;        }    }    throw new RuntimeException("Unable to find a leader peer");}
getFollowerQuorumPeers
public List<QuorumPeer> zookeeper_f6407_0()
{    List<QuorumPeer> peerList = new ArrayList<QuorumPeer>(ALL - 1);    for (PeerStruct ps : peers.values()) {        if (ps.peer.leader == null) {            peerList.add(ps.peer);        }    }    return Collections.unmodifiableList(peerList);}
tearDown
public voidf6408_1) throws Exception
{        OSMXBean osMbean = new OSMXBean();    if (osMbean.getUnix()) {            }    shutdownAll();    JMXEnv.tearDown();}
getLeaderServer
public int zookeeper_f6409_0()
{    int index = 0;    for (int i = 1; i <= ALL; i++) {        if (getPeer(i).peer.leader != null) {            index = i;            break;        }    }    assertTrue("Leader server not found.", index > 0);    return index;}
getConnectionStringForServer
public String zookeeper_f6410_0(final int index)
{    return "127.0.0.1:" + getPeer(index).clientPort;}
validateAllMXBeanAreUnregistered
public voidf6411_1) throws IOException
{    QuorumUtil qU = new QuorumUtil(1);        qU.startAll();        int leaderIndex = qU.getLeaderServer();    int firstFollowerIndex = 0;    int secondFollowerIndex = 0;    switch(leaderIndex) {        case 1:            firstFollowerIndex = 2;            secondFollowerIndex = 3;            break;        case 2:            firstFollowerIndex = 1;            secondFollowerIndex = 3;            break;        case 3:            firstFollowerIndex = 1;            secondFollowerIndex = 2;            break;        default:            fail("Unexpected leaderIndex value: " + leaderIndex);            break;    }        qU.shutdown(firstFollowerIndex);        qU.shutdown(secondFollowerIndex);        qU.restart(firstFollowerIndex);        qU.restart(secondFollowerIndex);    qU.shutdownAll();    Set<ZKMBeanInfo> pending = MBeanRegistry.getInstance().getRegisteredBeans();    assertTrue("The following beans should have been unregistered: " + pending, pending.isEmpty());}
setUp
public void zookeeper_f6412_0() throws Exception
{    qb.setUp();}
testBehindLeader
public void zookeeper_f6413_0() throws Exception
{        ClientBase.waitForServerUp(qb.hostPort, 10000);    ClientBase.waitForServerUp(qb.hostPort, 10000);    ZooKeeper zk = new ZooKeeper(qb.hostPort, 10000, DummyWatcher.INSTANCE);    zk.create("/0", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.close();    qb.shutdownServers();    qb.startServers();    ClientBase.waitForServerUp(qb.hostPort, 10000);    qb.shutdownServers();    qb.startServers();    ClientBase.waitForServerUp(qb.hostPort, 10000);    zk = new ZooKeeper(qb.hostPort, 10000, DummyWatcher.INSTANCE);    zk.create("/1", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.close();    qb.shutdownServers();    qb.startServers();    ClientBase.waitForServerUp(qb.hostPort, 10000);    qb.shutdownServers();    qb.startServers();    ClientBase.waitForServerUp(qb.hostPort, 10000);    zk = new ZooKeeper(qb.hostPort, 10000, DummyWatcher.INSTANCE);    zk.create("/2", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.close();    qb.shutdownServers();    cleanAndInitializeDataDir(qb.s1dir);    cleanAndInitializeDataDir(qb.s2dir);    cleanAndInitializeDataDir(qb.s3dir);    cleanAndInitializeDataDir(qb.s4dir);    qb.setupServers();    qb.s1.start();    qb.s2.start();    qb.s3.start();    qb.s4.start();    assertTrue("Servers didn't come up", ClientBase.waitForServerUp(qb.hostPort, 10000));    qb.s5.start();    String hostPort = "127.0.0.1:" + qb.s5.getClientPort();    assertFalse("Servers came up, but shouldn't have since it's ahead of leader", ClientBase.waitForServerUp(hostPort, 10000));}
cleanAndInitializeDataDir
private void zookeeper_f6414_0(File f) throws IOException
{    File v = new File(f, "version-2");    for (File c : v.listFiles()) {        c.delete();    }    ClientBase.createInitializeFile(f);}
testLateLogs
public void zookeeper_f6415_0() throws Exception
{        ClientBase.waitForServerUp(qb.hostPort, 10000);    ClientBase.waitForServerUp(qb.hostPort, 10000);    ZooKeeper zk = new ZooKeeper(qb.hostPort, 10000, DummyWatcher.INSTANCE);    zk.create("/0", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.close();    qb.shutdownServers();    qb.startServers();    ClientBase.waitForServerUp(qb.hostPort, 10000);    qb.shutdownServers();    qb.startServers();    ClientBase.waitForServerUp(qb.hostPort, 10000);    zk = new ZooKeeper(qb.hostPort, 10000, DummyWatcher.INSTANCE);    zk.create("/1", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.close();    qb.shutdownServers();    qb.startServers();    ClientBase.waitForServerUp(qb.hostPort, 10000);    qb.shutdownServers();    deleteLogs(qb.s1dir);    deleteLogs(qb.s2dir);    deleteLogs(qb.s3dir);    deleteLogs(qb.s4dir);    deleteLogs(qb.s5dir);    qb.startServers();    ClientBase.waitForServerUp(qb.hostPort, 10000);    zk = new ZooKeeper(qb.hostPort, 10000, DummyWatcher.INSTANCE);    zk.create("/2", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.close();    qb.shutdownServers();    qb.startServers();    ClientBase.waitForServerUp(qb.hostPort, 10000);    zk = new ZooKeeper(qb.hostPort, 10000, DummyWatcher.INSTANCE);    boolean saw2 = false;    for (String child : zk.getChildren("/", false)) {        if (child.equals("2")) {            saw2 = true;        }    }    zk.close();    assertTrue("Didn't see /2 (went back in time)", saw2);}
deleteLogs
private void zookeeper_f6416_0(File f)
{    File v = new File(f, "version-2");    for (File c : v.listFiles()) {        if (c.getName().startsWith("log")) {            c.delete();        }    }}
tearDown
public void zookeeper_f6417_0() throws Exception
{    qb.tearDown();}
setUp
public void zookeeper_f6418_0() throws Exception
{    System.setProperty("readonlymode.enabled", "true");    qu.startQuorum();}
tearDown
public void zookeeper_f6419_0() throws Exception
{    System.setProperty("readonlymode.enabled", "false");    qu.tearDown();}
testMultiTransaction
public void zookeeper_f6420_0() throws Exception
{    CountdownWatcher watcher = new CountdownWatcher();    ZooKeeper zk = new ZooKeeper(qu.getConnString(), CONNECTION_TIMEOUT, watcher, true);        watcher.waitForConnected(CONNECTION_TIMEOUT);    final String data = "Data to be read in RO mode";    final String node1 = "/tnode1";    final String node2 = "/tnode2";    zk.create(node1, data.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    watcher.reset();    qu.shutdown(2);    watcher.waitForConnected(CONNECTION_TIMEOUT);    assertEquals("Should be in r-o mode", States.CONNECTEDREADONLY, zk.getState());        String remoteData = new String(zk.getData(node1, false, null));    assertEquals("Failed to read data in r-o mode", data, remoteData);    try {        Transaction transaction = zk.transaction();        transaction.setData(node1, "no way".getBytes(), -1);        transaction.create(node2, data.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        transaction.commit();        fail("Write operation using multi-transaction" + " api has succeeded during RO mode");    } catch (NotReadOnlyException e) {        }    assertNull("Should have created the znode:" + node2, zk.exists(node2, false));}
testReadOnlyClient
public void zookeeper_f6421_0() throws Exception
{    CountdownWatcher watcher = new CountdownWatcher();    ZooKeeper zk = new ZooKeeper(qu.getConnString(), CONNECTION_TIMEOUT, watcher, true);        watcher.waitForConnected(CONNECTION_TIMEOUT);    final String data = "Data to be read in RO mode";    final String node = "/tnode";    zk.create(node, data.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    watcher.reset();    qu.shutdown(2);    zk.close();            zk = new ZooKeeper(qu.getConnString(), CONNECTION_TIMEOUT, watcher, true);    watcher.waitForConnected(CONNECTION_TIMEOUT);        String remoteData = new String(zk.getData(node, false, null));    assertEquals(data, remoteData);    try {        zk.setData(node, "no way".getBytes(), -1);        fail("Write operation has succeeded during RO mode");    } catch (NotReadOnlyException e) {        }    watcher.reset();    qu.start(2);    assertTrue("waiting for server up", ClientBase.waitForServerUp("127.0.0.1:" + qu.getPeer(2).clientPort, CONNECTION_TIMEOUT));    zk.close();    watcher.reset();            zk = new ZooKeeper(qu.getConnString(), CONNECTION_TIMEOUT, watcher, true);    watcher.waitForConnected(CONNECTION_TIMEOUT);    zk.setData(node, "We're in the quorum now".getBytes(), -1);    zk.close();}
testConnectionEvents
public void zookeeper_f6422_0() throws Exception
{    CountdownWatcher watcher = new CountdownWatcher();    ZooKeeper zk = new ZooKeeper(qu.getConnString(), CONNECTION_TIMEOUT, watcher, true);    boolean success = false;    for (int i = 0; i < 30; i++) {        try {            zk.create("/test", "test".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);            success = true;            break;        } catch (KeeperException.ConnectionLossException e) {            Thread.sleep(1000);        }    }    assertTrue("Did not succeed in connecting in 30s", success);    assertFalse("The connection should not be read-only yet", watcher.readOnlyConnected);            qu.shutdown(2);            zk = new ZooKeeper(qu.getConnString(), CONNECTION_TIMEOUT, watcher, true);    long start = Time.currentElapsedTime();    while (!(zk.getState() == States.CONNECTEDREADONLY)) {        Thread.sleep(200);                assertTrue("Can't connect to the server", Time.currentElapsedTime() - start < 30000);    }    watcher.waitForReadOnlyConnected(5000);    zk.close();}
testSessionEstablishment
public voidf6423_1) throws Exception
{    qu.shutdown(2);    CountdownWatcher watcher = new CountdownWatcher();    ZooKeeper zk = new ZooKeeper(qu.getConnString(), CONNECTION_TIMEOUT, watcher, true);    watcher.waitForConnected(CONNECTION_TIMEOUT);    assertSame("should be in r/o mode", States.CONNECTEDREADONLY, zk.getState());    long fakeId = zk.getSessionId();        watcher.reset();    qu.start(2);    assertTrue("waiting for server up", ClientBase.waitForServerUp("127.0.0.1:" + qu.getPeer(2).clientPort, CONNECTION_TIMEOUT));                                watcher.waitForSyncConnected(CONNECTION_TIMEOUT);    assertEquals("Should be in read-write mode", States.CONNECTED, zk.getState());        zk.create("/test", "test".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    assertFalse("fake session and real session have same id", zk.getSessionId() == fakeId);    zk.close();}
testSeekForRwServer
public void zookeeper_f6424_0() throws Exception
{        Layout layout = Logger.getRootLogger().getAppender("CONSOLE").getLayout();    ByteArrayOutputStream os = new ByteArrayOutputStream();    WriterAppender appender = new WriterAppender(layout, os);    appender.setImmediateFlush(true);    appender.setThreshold(Level.INFO);    Logger zlogger = Logger.getLogger("org.apache.zookeeper");    zlogger.addAppender(appender);    try {        qu.shutdown(2);        CountdownWatcher watcher = new CountdownWatcher();        ZooKeeper zk = new ZooKeeper(qu.getConnString(), CONNECTION_TIMEOUT, watcher, true);        watcher.waitForConnected(CONNECTION_TIMEOUT);                qu.getPeer(1).peer.suspend();                        watcher.reset();        qu.start(2);        qu.start(3);        ClientBase.waitForServerUp(qu.getConnString(), 2000);        watcher.waitForConnected(CONNECTION_TIMEOUT);        zk.create("/test", "test".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);                qu.getPeer(1).peer.resume();    } finally {        zlogger.removeAppender(appender);    }    os.close();    LineNumberReader r = new LineNumberReader(new StringReader(os.toString()));    String line;    Pattern p = Pattern.compile(".*Majority server found.*");    boolean found = false;    while ((line = r.readLine()) != null) {        if (p.matcher(line).matches()) {            found = true;            break;        }    }    assertTrue("Majority server wasn't found while connected to r/o server", found);}
setup
public void zookeeper_f6425_0() throws InterruptedException
{    System.setProperty(authProvider, superDigest);    QuorumPeerConfig.setReconfigEnabled(true);        qu = new QuorumUtil(1);    qu.disableJMXTest = true;    try {        qu.startAll();    } catch (IOException e) {        fail("Fail to start quorum servers.");    }    resetZKAdmin();}
tearDown
public void zookeeper_f6426_0() throws Exception
{    System.clearProperty(authProvider);    try {        if (qu != null) {            qu.tearDown();        }        if (zkAdmin != null) {            zkAdmin.close();        }    } catch (Exception e) {        }}
testReconfigDisabled
public void zookeeper_f6427_0() throws InterruptedException
{    QuorumPeerConfig.setReconfigEnabled(false);    try {        reconfigPort();        fail("Reconfig should be disabled.");    } catch (KeeperException e) {        assertTrue(e.code() == KeeperException.Code.RECONFIGDISABLED);    }}
testReconfigFailWithoutAuth
public void zookeeper_f6428_0() throws InterruptedException
{    try {        reconfigPort();        fail("Reconfig should fail without auth.");    } catch (KeeperException e) {                assertTrue(e.code() == KeeperException.Code.NOAUTH);    }}
testReconfigEnabledWithSuperUser
public void zookeeper_f6429_0() throws InterruptedException
{    try {        zkAdmin.addAuthInfo("digest", "super:test".getBytes());        assertTrue(reconfigPort());    } catch (KeeperException e) {        fail("Reconfig should not fail, but failed with exception : " + e.getMessage());    }}
testReconfigFailWithAuthWithNoACL
public void zookeeper_f6430_0() throws InterruptedException
{    resetZKAdmin();    try {        zkAdmin.addAuthInfo("digest", "user:test".getBytes());        reconfigPort();        fail("Reconfig should fail without a valid ACL associated with user.");    } catch (KeeperException e) {                assertTrue(e.code() == KeeperException.Code.NOAUTH);    }}
testReconfigEnabledWithAuthAndWrongACL
public void zookeeper_f6431_0() throws InterruptedException
{    resetZKAdmin();    try {        zkAdmin.addAuthInfo("digest", "super:test".getBytes());                ArrayList<ACL> acls = new ArrayList<ACL>(Collections.singletonList(new ACL(ZooDefs.Perms.READ, new Id("digest", "user:tl+z3z0vO6PfPfEENfLF96E6pM0="))));        zkAdmin.setACL(ZooDefs.CONFIG_NODE, acls, -1);        resetZKAdmin();        zkAdmin.addAuthInfo("digest", "user:test".getBytes());        reconfigPort();        fail("Reconfig should fail with an ACL that is read only!");    } catch (KeeperException e) {        assertTrue(e.code() == KeeperException.Code.NOAUTH);    }}
testReconfigEnabledWithAuthAndACL
public void zookeeper_f6432_0() throws InterruptedException
{    resetZKAdmin();    try {        zkAdmin.addAuthInfo("digest", "super:test".getBytes());        ArrayList<ACL> acls = new ArrayList<ACL>(Collections.singletonList(new ACL(ZooDefs.Perms.WRITE, new Id("digest", "user:tl+z3z0vO6PfPfEENfLF96E6pM0="))));        zkAdmin.setACL(ZooDefs.CONFIG_NODE, acls, -1);        resetZKAdmin();        zkAdmin.addAuthInfo("digest", "user:test".getBytes());        assertTrue(reconfigPort());    } catch (KeeperException e) {        fail("Reconfig should not fail, but failed with exception : " + e.getMessage());    }}
resetZKAdmin
private void zookeeper_f6433_0() throws InterruptedException
{    String cnxString;    ClientBase.CountdownWatcher watcher = new ClientBase.CountdownWatcher();    try {        cnxString = "127.0.0.1:" + qu.getPeer(1).peer.getClientPort();        if (zkAdmin != null) {            zkAdmin.close();        }        zkAdmin = new ZooKeeperAdmin(cnxString, ClientBase.CONNECTION_TIMEOUT, watcher);    } catch (IOException e) {        fail("Fail to create ZooKeeperAdmin handle.");        return;    }    try {        watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT);    } catch (InterruptedException | TimeoutException e) {        fail("ZooKeeper admin client can not connect to " + cnxString);    }}
reconfigPort
private boolean zookeeper_f6434_0() throws KeeperException, InterruptedException
{    List<String> joiningServers = new ArrayList<String>();    int leaderId = 1;    while (qu.getPeer(leaderId).peer.leader == null) {        leaderId++;    }    int followerId = leaderId == 1 ? 2 : 1;    joiningServers.add("server." + followerId + "=localhost:" + qu.getPeer(followerId).peer.getQuorumAddress().getPort() + /*quorum port*/    ":" + qu.getPeer(followerId).peer.getElectionAddress().getPort() + /*election port*/    ":participant;localhost:" + PortAssignment.unique());    zkAdmin.reconfigure(joiningServers, null, null, -1, new Stat());    return true;}
setup
public void zookeeper_f6435_0() throws InterruptedException
{    QuorumPeerConfig.setReconfigEnabled(true);        qu = new QuorumUtil(1);    qu.disableJMXTest = true;    try {        qu.startAll();    } catch (IOException e) {        fail("Fail to start quorum servers.");    }    instantiateZKAdmin();}
tearDown
public void zookeeper_f6436_0() throws Exception
{    try {        if (qu != null) {            qu.tearDown();        }        if (zkAdmin != null) {            zkAdmin.close();        }    } catch (Exception e) {        }}
testReconfigFailWithoutSuperuserPasswordConfiguredOnServer
public void zookeeper_f6437_0() throws InterruptedException
{        try {        reconfigPort();        fail(errorMsg);    } catch (KeeperException e) {        assertTrue(e.code() == KeeperException.Code.NOAUTH);    }    try {        zkAdmin.addAuthInfo("digest", "super:".getBytes());        reconfigPort();        fail(errorMsg);    } catch (KeeperException e) {        assertTrue(e.code() == KeeperException.Code.NOAUTH);    }}
instantiateZKAdmin
private void zookeeper_f6438_0() throws InterruptedException
{    String cnxString;    ClientBase.CountdownWatcher watcher = new ClientBase.CountdownWatcher();    try {        cnxString = "127.0.0.1:" + qu.getPeer(1).peer.getClientPort();        zkAdmin = new ZooKeeperAdmin(cnxString, ClientBase.CONNECTION_TIMEOUT, watcher);    } catch (IOException e) {        fail("Fail to create ZooKeeperAdmin handle.");        return;    }    try {        watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT);    } catch (InterruptedException | TimeoutException e) {        fail("ZooKeeper admin client can not connect to " + cnxString);    }}
reconfigPort
private boolean zookeeper_f6439_0() throws KeeperException, InterruptedException
{    List<String> joiningServers = new ArrayList<String>();    int leaderId = 1;    while (qu.getPeer(leaderId).peer.leader == null) {        leaderId++;    }    int followerId = leaderId == 1 ? 2 : 1;    joiningServers.add("server." + followerId + "=localhost:" + qu.getPeer(followerId).peer.getQuorumAddress().getPort() + /*quorum port*/    ":" + qu.getPeer(followerId).peer.getElectionAddress().getPort() + /*election port*/    ":participant;localhost:" + PortAssignment.unique());    zkAdmin.reconfigure(joiningServers, null, null, -1, new Stat());    return true;}
setup
public void zookeeper_f6440_0()
{    System.setProperty("zookeeper.DigestAuthenticationProvider.superDigest", "super:D/InIHSb7yEEbrWz8b9l71RjZJU=");    QuorumPeerConfig.setReconfigEnabled(true);}
tearDown
public void zookeeper_f6441_0() throws Exception
{    closeAllHandles(zkArr, zkAdminArr);    if (qu != null) {        qu.tearDown();    }}
reconfig
public static String zookeeper_f6442_0(ZooKeeperAdmin zkAdmin, List<String> joiningServers, List<String> leavingServers, List<String> newMembers, long fromConfig) throws KeeperException, InterruptedException
{    byte[] config = null;    String failure = null;    for (int j = 0; j < 30; j++) {        try {            config = zkAdmin.reconfigure(joiningServers, leavingServers, newMembers, fromConfig, new Stat());            failure = null;            break;        } catch (KeeperException.ConnectionLossException e) {            failure = "client could not connect to reestablished quorum: giving up after 30+ seconds.";        } catch (KeeperException.ReconfigInProgress e) {            failure = "reconfig still in progress: giving up after 30+ seconds.";        }        Thread.sleep(1000);    }    if (failure != null) {        fail(failure);    }    String configStr = new String(config);    if (joiningServers != null) {        for (String joiner : joiningServers) {            assertTrue(configStr.contains(joiner));        }    }    if (leavingServers != null) {        for (String leaving : leavingServers) {            assertFalse(configStr.contains("server.".concat(leaving)));        }    }    return configStr;}
testServerHasConfig
public static String zookeeper_f6443_0(ZooKeeper zk, List<String> joiningServers, List<String> leavingServers) throws KeeperException, InterruptedException
{    boolean testNodeExists = false;    byte[] config = null;    for (int j = 0; j < 30; j++) {        try {            if (!testNodeExists) {                createZNode(zk, "/dummy", "dummy");                testNodeExists = true;            }                                    zk.setData("/dummy", "dummy".getBytes(), -1);            config = zk.getConfig(false, new Stat());            break;        } catch (KeeperException.ConnectionLossException e) {            if (j < 29) {                Thread.sleep(1000);            } else {                                                fail("client could not connect to reestablished quorum: giving up after 30+ seconds.");            }        }    }    String configStr = new String(config);    if (joiningServers != null) {        for (String joiner : joiningServers) {            assertTrue(configStr.contains(joiner));        }    }    if (leavingServers != null) {        for (String leaving : leavingServers) {            assertFalse(configStr.contains("server.".concat(leaving)));        }    }    return configStr;}
testNormalOperation
public static void zookeeper_f6444_0(ZooKeeper writer, ZooKeeper reader) throws KeeperException, InterruptedException
{    boolean testReaderNodeExists = false;    boolean testWriterNodeExists = false;    for (int j = 0; j < 30; j++) {        try {            if (!testWriterNodeExists) {                createZNode(writer, "/test", "test");                testWriterNodeExists = true;            }            if (!testReaderNodeExists) {                createZNode(reader, "/dummy", "dummy");                testReaderNodeExists = true;            }            String data = "test" + j;            writer.setData("/test", data.getBytes(), -1);                                    reader.setData("/dummy", "dummy".getBytes(), -1);            byte[] res = reader.getData("/test", null, new Stat());            assertEquals(data, new String(res));            break;        } catch (KeeperException.ConnectionLossException e) {            if (j < 29) {                Thread.sleep(1000);            } else {                                                fail("client could not connect to reestablished quorum: giving up after 30+ seconds.");            }        }    }}
createZNode
private static void zookeeper_f6445_0(ZooKeeper zk, String path, String data) throws KeeperException, InterruptedException
{    try {        zk.create(path, data.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    } catch (KeeperException.NodeExistsException e) {    }}
getLeaderId
private int zookeeper_f6446_0(QuorumUtil qu)
{    int leaderId = 1;    while (qu.getPeer(leaderId).peer.leader == null) {        leaderId++;    }    return leaderId;}
createHandles
public static ZooKeeper[] zookeeper_f6447_0(QuorumUtil qu) throws IOException
{            ZooKeeper[] zkArr = new ZooKeeper[qu.ALL + 1];        zkArr[0] = null;    for (int i = 1; i <= qu.ALL; i++) {                zkArr[i] = new ZooKeeper("127.0.0.1:" + qu.getPeer(i).peer.getClientPort(), ClientBase.CONNECTION_TIMEOUT, DummyWatcher.INSTANCE);    }    return zkArr;}
createAdminHandles
public static ZooKeeperAdmin[] zookeeper_f6448_0(QuorumUtil qu) throws IOException
{            ZooKeeperAdmin[] zkAdminArr = new ZooKeeperAdmin[qu.ALL + 1];        zkAdminArr[0] = null;    for (int i = 1; i <= qu.ALL; i++) {                zkAdminArr[i] = new ZooKeeperAdmin("127.0.0.1:" + qu.getPeer(i).peer.getClientPort(), ClientBase.CONNECTION_TIMEOUT, DummyWatcher.INSTANCE);        zkAdminArr[i].addAuthInfo("digest", "super:test".getBytes());    }    return zkAdminArr;}
closeAllHandles
public static void zookeeper_f6449_0(ZooKeeper[] zkArr, ZooKeeperAdmin[] zkAdminArr) throws InterruptedException
{    if (zkArr != null) {        for (ZooKeeper zk : zkArr) {            if (zk != null) {                zk.close();            }        }    }    if (zkAdminArr != null) {        for (ZooKeeperAdmin zkAdmin : zkAdminArr) {            if (zkAdmin != null) {                zkAdmin.close();            }        }    }}
testRemoveAddOne
public void zookeeper_f6450_0() throws Exception
{        qu = new QuorumUtil(1);    qu.disableJMXTest = true;    qu.startAll();    zkArr = createHandles(qu);    zkAdminArr = createAdminHandles(qu);    List<String> leavingServers = new ArrayList<String>();    List<String> joiningServers = new ArrayList<String>();    int leaderIndex = getLeaderId(qu);            int leavingIndex = (leaderIndex == 1) ? 2 : 1;    for (int i = 0; i < 2; i++) {                                                        ZooKeeper zk1 = (leavingIndex == leaderIndex) ? zkArr[leaderIndex] : zkArr[(leaderIndex % qu.ALL) + 1];        ZooKeeper zk2 = (leavingIndex == leaderIndex) ? zkArr[(leaderIndex % qu.ALL) + 1] : zkArr[leaderIndex];        ZooKeeperAdmin zkAdmin1 = (leavingIndex == leaderIndex) ? zkAdminArr[leaderIndex] : zkAdminArr[(leaderIndex % qu.ALL) + 1];        ZooKeeperAdmin zkAdmin2 = (leavingIndex == leaderIndex) ? zkAdminArr[(leaderIndex % qu.ALL) + 1] : zkAdminArr[leaderIndex];        leavingServers.add(Integer.toString(leavingIndex));                joiningServers.add("server." + leavingIndex + "=localhost:" + qu.getPeer(leavingIndex).peer.getQuorumAddress().getPort() + ":" + qu.getPeer(leavingIndex).peer.getElectionAddress().getPort() + ":participant;localhost:" + qu.getPeer(leavingIndex).peer.getClientPort());        String configStr = reconfig(zkAdmin1, null, leavingServers, null, -1);        testServerHasConfig(zk2, null, leavingServers);        testNormalOperation(zk2, zk1);        QuorumVerifier qv = qu.getPeer(1).peer.configFromString(configStr);        long version = qv.getVersion();                try {            reconfig(zkAdmin2, joiningServers, null, null, version + 1);            fail("reconfig succeeded even though version condition was incorrect!");        } catch (KeeperException.BadVersionException e) {        }        reconfig(zkAdmin2, joiningServers, null, null, version);        testNormalOperation(zk1, zk2);        testServerHasConfig(zk1, joiningServers, null);                        leavingIndex = leaderIndex = getLeaderId(qu);        leavingServers.clear();        joiningServers.clear();    }}
testRemoveAddTwo
public void zookeeper_f6451_0() throws Exception
{        qu = new QuorumUtil(2);    qu.disableJMXTest = true;    qu.startAll();    zkArr = createHandles(qu);    zkAdminArr = createAdminHandles(qu);    List<String> leavingServers = new ArrayList<String>();    List<String> joiningServers = new ArrayList<String>();    int leaderIndex = getLeaderId(qu);        int leavingIndex1 = leaderIndex;    int leavingIndex2 = (leaderIndex == 1) ? 2 : 1;        int stayingIndex1 = 1, stayingIndex2 = 1, stayingIndex3 = 1;    while (stayingIndex1 == leavingIndex1 || stayingIndex1 == leavingIndex2) {        stayingIndex1++;    }    while (stayingIndex2 == leavingIndex1 || stayingIndex2 == leavingIndex2 || stayingIndex2 == stayingIndex1) {        stayingIndex2++;    }    while (stayingIndex3 == leavingIndex1 || stayingIndex3 == leavingIndex2 || stayingIndex3 == stayingIndex1 || stayingIndex3 == stayingIndex2) {        stayingIndex3++;    }    leavingServers.add(Integer.toString(leavingIndex1));    leavingServers.add(Integer.toString(leavingIndex2));        joiningServers.add("server." + leavingIndex1 + "=localhost:" + qu.getPeer(leavingIndex1).peer.getQuorumAddress().getPort() + ":" + qu.getPeer(leavingIndex1).peer.getElectionAddress().getPort() + ":participant;localhost:" + qu.getPeer(leavingIndex1).peer.getClientPort());        joiningServers.add("server." + leavingIndex2 + "=localhost:" + qu.getPeer(leavingIndex2).peer.getQuorumAddress().getPort() + ":" + qu.getPeer(leavingIndex2).peer.getElectionAddress().getPort() + ":observer;localhost:" + qu.getPeer(leavingIndex2).peer.getClientPort());    qu.shutdown(leavingIndex1);    qu.shutdown(leavingIndex2);        reconfig(zkAdminArr[stayingIndex2], null, leavingServers, null, -1);    qu.shutdown(stayingIndex2);                testServerHasConfig(zkArr[stayingIndex1], null, leavingServers);    testServerHasConfig(zkArr[stayingIndex3], null, leavingServers);    testNormalOperation(zkArr[stayingIndex1], zkArr[stayingIndex3]);                        Thread.sleep(10000);    try {        reconfig(zkAdminArr[stayingIndex1], joiningServers, null, null, -1);        fail("reconfig completed successfully even though there is no quorum up in new config!");    } catch (KeeperException.NewConfigNoQuorum e) {    }        qu.restart(stayingIndex2);    reconfig(zkAdminArr[stayingIndex1], joiningServers, null, null, -1);    testNormalOperation(zkArr[stayingIndex2], zkArr[stayingIndex3]);    testServerHasConfig(zkArr[stayingIndex2], joiningServers, null);                qu.restart(leavingIndex2);    assertTrue(qu.getPeer(leavingIndex2).peer.getPeerState() == ServerState.OBSERVING);    testNormalOperation(zkArr[stayingIndex2], zkArr[leavingIndex2]);    testServerHasConfig(zkArr[leavingIndex2], joiningServers, null);}
testBulkReconfig
public void zookeeper_f6452_0() throws Exception
{        qu = new QuorumUtil(3);    qu.disableJMXTest = true;    qu.startAll();    zkArr = createHandles(qu);    zkAdminArr = createAdminHandles(qu);            ArrayList<String> newServers = new ArrayList<String>();    for (int i = 1; i <= 5; i++) {        String server = "server." + i + "=localhost:" + PortAssignment.unique() + ":" + PortAssignment.unique() + ":" + ((i == 4 || i == 5) ? "observer" : "participant") + ";localhost:" + qu.getPeer(i).peer.getClientPort();        newServers.add(server);    }    qu.shutdown(3);    qu.shutdown(6);    qu.shutdown(7);    reconfig(zkAdminArr[1], null, null, newServers, -1);    testNormalOperation(zkArr[1], zkArr[2]);    testServerHasConfig(zkArr[1], newServers, null);    testServerHasConfig(zkArr[2], newServers, null);    testServerHasConfig(zkArr[4], newServers, null);    testServerHasConfig(zkArr[5], newServers, null);    qu.shutdown(5);    qu.shutdown(4);    testNormalOperation(zkArr[1], zkArr[2]);}
testRemoveOneAsynchronous
public void zookeeper_f6453_0() throws Exception
{    qu = new QuorumUtil(2);    qu.disableJMXTest = true;    qu.startAll();    zkArr = createHandles(qu);    zkAdminArr = createAdminHandles(qu);    List<String> leavingServers = new ArrayList<String>();        leavingServers.add(getLeaderId(qu) == 5 ? "4" : "5");    List<Integer> results = new LinkedList<Integer>();    zkAdminArr[1].reconfigure(null, leavingServers, null, -1, this, results);    synchronized (results) {        while (results.size() < 1) {            results.wait();        }    }    assertEquals(0, (int) results.get(0));    testNormalOperation(zkArr[1], zkArr[2]);    for (int i = 1; i <= 5; i++) {        testServerHasConfig(zkArr[i], null, leavingServers);    }}
processResult
public void zookeeper_f6454_0(int rc, String path, Object ctx, byte[] data, Stat stat)
{    synchronized (ctx) {        ((LinkedList<Integer>) ctx).add(rc);        ctx.notifyAll();    }}
testRoleChange
public void zookeeper_f6455_0() throws Exception
{        qu = new QuorumUtil(1);    qu.disableJMXTest = true;    qu.startAll();    zkArr = createHandles(qu);    zkAdminArr = createAdminHandles(qu);            List<String> joiningServers = new ArrayList<String>();    int leaderIndex = getLeaderId(qu);                    int changingIndex = (leaderIndex == 1) ? 2 : 1;            String newRole = "observer";    for (int i = 0; i < 4; i++) {                                                        ZooKeeper zk1 = (changingIndex == leaderIndex) ? zkArr[leaderIndex] : zkArr[(leaderIndex % qu.ALL) + 1];        ZooKeeperAdmin zkAdmin1 = (changingIndex == leaderIndex) ? zkAdminArr[leaderIndex] : zkAdminArr[(leaderIndex % qu.ALL) + 1];                joiningServers.add("server." + changingIndex + "=localhost:" + qu.getPeer(changingIndex).peer.getQuorumAddress().getPort() + ":" + qu.getPeer(changingIndex).peer.getElectionAddress().getPort() + ":" + newRole + ";localhost:" + qu.getPeer(changingIndex).peer.getClientPort());        reconfig(zkAdmin1, joiningServers, null, null, -1);        testNormalOperation(zkArr[changingIndex], zk1);        if (newRole.equals("observer")) {            assertTrue(qu.getPeer(changingIndex).peer.observer != null && qu.getPeer(changingIndex).peer.follower == null && qu.getPeer(changingIndex).peer.leader == null);            assertTrue(qu.getPeer(changingIndex).peer.getPeerState() == ServerState.OBSERVING);        } else {            assertTrue(qu.getPeer(changingIndex).peer.observer == null && (qu.getPeer(changingIndex).peer.follower != null || qu.getPeer(changingIndex).peer.leader != null));            assertTrue(qu.getPeer(changingIndex).peer.getPeerState() == ServerState.FOLLOWING || qu.getPeer(changingIndex).peer.getPeerState() == ServerState.LEADING);        }        joiningServers.clear();        if (newRole.equals("observer")) {            newRole = "participant";        } else {                        newRole = "observer";            leaderIndex = getLeaderId(qu);            changingIndex = leaderIndex;        }    }}
testPortChange
public void zookeeper_f6456_0() throws Exception
{        qu = new QuorumUtil(1);    qu.disableJMXTest = true;    qu.startAll();    zkArr = createHandles(qu);    zkAdminArr = createAdminHandles(qu);    List<String> joiningServers = new ArrayList<String>();    int leaderIndex = getLeaderId(qu);    int followerIndex = leaderIndex == 1 ? 2 : 1;        int quorumPort = qu.getPeer(followerIndex).peer.getQuorumAddress().getPort();    int electionPort = qu.getPeer(followerIndex).peer.getElectionAddress().getPort();    int oldClientPort = qu.getPeer(followerIndex).peer.getClientPort();    int newClientPort = PortAssignment.unique();    joiningServers.add("server." + followerIndex + "=localhost:" + quorumPort + ":" + electionPort + ":participant;localhost:" + newClientPort);            testNormalOperation(zkArr[followerIndex], zkArr[leaderIndex]);    reconfig(zkAdminArr[followerIndex], joiningServers, null, null, -1);    try {        for (int i = 0; i < 20; i++) {            Thread.sleep(1000);            zkArr[followerIndex].setData("/test", "teststr".getBytes(), -1);        }    } catch (KeeperException.ConnectionLossException e) {        fail("Existing client disconnected when client port changed!");    }    zkArr[followerIndex].close();    zkArr[followerIndex] = new ZooKeeper("127.0.0.1:" + oldClientPort, ClientBase.CONNECTION_TIMEOUT, DummyWatcher.INSTANCE);    zkAdminArr[followerIndex].close();    zkAdminArr[followerIndex] = new ZooKeeperAdmin("127.0.0.1:" + oldClientPort, ClientBase.CONNECTION_TIMEOUT, DummyWatcher.INSTANCE);    zkAdminArr[followerIndex].addAuthInfo("digest", "super:test".getBytes());    for (int i = 0; i < 10; i++) {        try {            Thread.sleep(1000);            zkArr[followerIndex].setData("/test", "teststr".getBytes(), -1);            fail("New client connected to old client port!");        } catch (KeeperException.ConnectionLossException e) {        }    }    zkArr[followerIndex].close();    zkArr[followerIndex] = new ZooKeeper("127.0.0.1:" + newClientPort, ClientBase.CONNECTION_TIMEOUT, DummyWatcher.INSTANCE);    zkAdminArr[followerIndex].close();    zkAdminArr[followerIndex] = new ZooKeeperAdmin("127.0.0.1:" + newClientPort, ClientBase.CONNECTION_TIMEOUT, DummyWatcher.INSTANCE);    zkAdminArr[followerIndex].addAuthInfo("digest", "super:test".getBytes());    testNormalOperation(zkArr[followerIndex], zkArr[leaderIndex]);    testServerHasConfig(zkArr[followerIndex], joiningServers, null);    assertEquals(newClientPort, qu.getPeer(followerIndex).peer.getClientPort());    joiningServers.clear();        int newQuorumPort = PortAssignment.unique();    joiningServers.add("server." + leaderIndex + "=localhost:" + newQuorumPort + ":" + qu.getPeer(leaderIndex).peer.getElectionAddress().getPort() + ":participant;localhost:" + qu.getPeer(leaderIndex).peer.getClientPort());    reconfig(zkAdminArr[leaderIndex], joiningServers, null, null, -1);    testNormalOperation(zkArr[followerIndex], zkArr[leaderIndex]);    assertTrue(qu.getPeer(leaderIndex).peer.getQuorumAddress().getPort() == newQuorumPort);    joiningServers.clear();    for (int i = 1; i <= 3; i++) {        joiningServers.add("server." + i + "=localhost:" + qu.getPeer(i).peer.getQuorumAddress().getPort() + ":" + PortAssignment.unique() + ":participant;localhost:" + qu.getPeer(i).peer.getClientPort());    }    reconfig(zkAdminArr[1], joiningServers, null, null, -1);    leaderIndex = getLeaderId(qu);    int follower1 = leaderIndex == 1 ? 2 : 1;    int follower2 = 1;    while (follower2 == leaderIndex || follower2 == follower1) {        follower2++;    }        qu.shutdown(getLeaderId(qu));    testNormalOperation(zkArr[follower2], zkArr[follower1]);    testServerHasConfig(zkArr[follower1], joiningServers, null);    testServerHasConfig(zkArr[follower2], joiningServers, null);}
testPortChangeToBlockedPortFollower
public void zookeeper_f6457_0() throws Exception
{    testPortChangeToBlockedPort(false);}
testPortChangeToBlockedPortLeader
public void zookeeper_f6458_0() throws Exception
{    testPortChangeToBlockedPort(true);}
testPortChangeToBlockedPort
private void zookeeper_f6459_0(boolean testLeader) throws Exception
{        qu = new QuorumUtil(1);    qu.disableJMXTest = true;    qu.startAll();    zkArr = createHandles(qu);    zkAdminArr = createAdminHandles(qu);    List<String> joiningServers = new ArrayList<String>();    int leaderIndex = getLeaderId(qu);    int followerIndex = leaderIndex == 1 ? 2 : 1;    int serverIndex = testLeader ? leaderIndex : followerIndex;    int reconfigIndex = testLeader ? followerIndex : leaderIndex;        int quorumPort = qu.getPeer(serverIndex).peer.getQuorumAddress().getPort();    int electionPort = qu.getPeer(serverIndex).peer.getElectionAddress().getPort();    int oldClientPort = qu.getPeer(serverIndex).peer.getClientPort();    int newClientPort = PortAssignment.unique();    try (ServerSocket ss = new ServerSocket()) {        ss.bind(new InetSocketAddress(getLoopbackAddress(), newClientPort));        joiningServers.add("server." + serverIndex + "=localhost:" + quorumPort + ":" + electionPort + ":participant;localhost:" + newClientPort);                        testNormalOperation(zkArr[followerIndex], zkArr[leaderIndex]);                reconfig(zkAdminArr[reconfigIndex], joiningServers, null, null, -1);        Thread.sleep(1000);                zkArr[serverIndex].close();        zkArr[serverIndex] = new ZooKeeper("127.0.0.1:" + newClientPort, ClientBase.CONNECTION_TIMEOUT, DummyWatcher.INSTANCE);        zkAdminArr[serverIndex].close();        zkAdminArr[serverIndex] = new ZooKeeperAdmin("127.0.0.1:" + newClientPort, ClientBase.CONNECTION_TIMEOUT, DummyWatcher.INSTANCE);        try {            Thread.sleep(1000);            zkArr[serverIndex].setData("/test", "teststr".getBytes(), -1);            fail("New client connected to new client port!");        } catch (KeeperException.ConnectionLossException e) {                }        try (ServerSocket ss2 = new ServerSocket()) {            ss2.bind(new InetSocketAddress(getLoopbackAddress(), oldClientPort));        }                joiningServers.clear();        joiningServers.add("server." + serverIndex + "=localhost:" + quorumPort + ":" + electionPort + ":participant;localhost:" + oldClientPort);        reconfig(zkAdminArr[reconfigIndex], joiningServers, null, null, -1);        zkArr[serverIndex].close();        zkArr[serverIndex] = new ZooKeeper("127.0.0.1:" + oldClientPort, ClientBase.CONNECTION_TIMEOUT, DummyWatcher.INSTANCE);        testNormalOperation(zkArr[followerIndex], zkArr[leaderIndex]);        testServerHasConfig(zkArr[serverIndex], joiningServers, null);        assertEquals(oldClientPort, qu.getPeer(serverIndex).peer.getClientPort());    }}
testUnspecifiedClientAddress
public void zookeeper_f6460_0() throws Exception
{    int[] ports = { PortAssignment.unique(), PortAssignment.unique(), PortAssignment.unique() };    String server = "server.0=localhost:" + ports[0] + ":" + ports[1] + ";" + ports[2];    QuorumServer qs = new QuorumServer(0, server);    assertEquals(qs.clientAddr.getHostString(), "0.0.0.0");    assertEquals(qs.clientAddr.getPort(), ports[2]);}
testQuorumSystemChange
public void zookeeper_f6461_0() throws Exception
{        qu = new QuorumUtil(3);    qu.disableJMXTest = true;    qu.startAll();    zkArr = createHandles(qu);    zkAdminArr = createAdminHandles(qu);    ArrayList<String> members = new ArrayList<>();    members.add("group.1=3:4:5");    members.add("group.2=1:2");    members.add("weight.1=0");    members.add("weight.2=0");    members.add("weight.3=1");    members.add("weight.4=1");    members.add("weight.5=1");    for (int i = 1; i <= 5; i++) {        members.add("server." + i + "=127.0.0.1:" + qu.getPeer(i).peer.getQuorumAddress().getPort() + ":" + qu.getPeer(i).peer.getElectionAddress().getPort() + ";" + "127.0.0.1:" + qu.getPeer(i).peer.getClientPort());    }    reconfig(zkAdminArr[1], null, null, members, -1);        testNormalOperation(zkArr[2], zkArr[3]);    testNormalOperation(zkArr[4], zkArr[5]);    for (int i = 1; i <= 5; i++) {        if (!(qu.getPeer(i).peer.getQuorumVerifier() instanceof QuorumHierarchical)) {            fail("peer " + i + " doesn't think the quorum system is Hieararchical!");        }    }    qu.shutdown(1);    qu.shutdown(2);    qu.shutdown(3);    qu.shutdown(7);    qu.shutdown(6);        testNormalOperation(zkArr[4], zkArr[5]);    qu.restart(1);    qu.restart(2);    members.clear();    for (int i = 1; i <= 3; i++) {        members.add("server." + i + "=127.0.0.1:" + qu.getPeer(i).peer.getQuorumAddress().getPort() + ":" + qu.getPeer(i).peer.getElectionAddress().getPort() + ";" + "127.0.0.1:" + qu.getPeer(i).peer.getClientPort());    }    reconfig(zkAdminArr[1], null, null, members, -1);        testNormalOperation(zkArr[1], zkArr[2]);    qu.shutdown(4);    qu.shutdown(5);        testNormalOperation(zkArr[1], zkArr[2]);    for (int i = 1; i <= 2; i++) {        if (!(qu.getPeer(i).peer.getQuorumVerifier() instanceof QuorumMaj)) {            fail("peer " + i + " doesn't think the quorum system is a majority quorum system!");        }    }}
testInitialConfigHasPositiveVersion
public void zookeeper_f6462_0() throws Exception
{        qu = new QuorumUtil(1);    qu.disableJMXTest = true;    qu.startAll();    zkArr = createHandles(qu);    testNormalOperation(zkArr[1], zkArr[2]);    for (int i = 1; i < 4; i++) {        String configStr = testServerHasConfig(zkArr[i], null, null);        QuorumVerifier qv = qu.getPeer(i).peer.configFromString(configStr);        long version = qv.getVersion();        assertTrue(version == 0x100000000L);    }}
testJMXBeanAfterRemoveAddOne
public void zookeeper_f6463_0() throws Exception
{        qu = new QuorumUtil(1);    qu.disableJMXTest = true;    qu.startAll();    zkArr = createHandles(qu);    zkAdminArr = createAdminHandles(qu);    List<String> leavingServers = new ArrayList<String>();    List<String> joiningServers = new ArrayList<String>();        int leavingIndex = 1;    int replica2 = 2;    QuorumPeer peer2 = qu.getPeer(replica2).peer;    QuorumServer leavingQS2 = peer2.getView().get(Long.valueOf(leavingIndex));    String remotePeerBean2 = MBeanRegistry.DOMAIN + ":name0=ReplicatedServer_id" + replica2 + ",name1=replica." + leavingIndex;    assertRemotePeerMXBeanAttributes(leavingQS2, remotePeerBean2);        int replica3 = 3;    QuorumPeer peer3 = qu.getPeer(replica3).peer;    QuorumServer leavingQS3 = peer3.getView().get(Long.valueOf(leavingIndex));    String remotePeerBean3 = MBeanRegistry.DOMAIN + ":name0=ReplicatedServer_id" + replica3 + ",name1=replica." + leavingIndex;    assertRemotePeerMXBeanAttributes(leavingQS3, remotePeerBean3);    ZooKeeper zk = zkArr[leavingIndex];    ZooKeeperAdmin zkAdmin = zkAdminArr[leavingIndex];    leavingServers.add(Integer.toString(leavingIndex));        joiningServers.add("server." + leavingIndex + "=127.0.0.1:" + qu.getPeer(leavingIndex).peer.getQuorumAddress().getPort() + ":" + qu.getPeer(leavingIndex).peer.getElectionAddress().getPort() + ":participant;127.0.0.1:" + qu.getPeer(leavingIndex).peer.getClientPort());        reconfig(zkAdmin, null, leavingServers, null, -1);        QuorumPeer removedPeer = qu.getPeer(leavingIndex).peer;    String localPeerBean = MBeanRegistry.DOMAIN + ":name0=ReplicatedServer_id" + leavingIndex + ",name1=replica." + leavingIndex;    assertLocalPeerMXBeanAttributes(removedPeer, localPeerBean, false);        JMXEnv.ensureNone(remotePeerBean2);        JMXEnv.ensureNone(remotePeerBean3);        reconfig(zkAdmin, joiningServers, null, null, -1);        assertLocalPeerMXBeanAttributes(removedPeer, localPeerBean, true);        leavingQS2 = peer2.getView().get(Long.valueOf(leavingIndex));    assertRemotePeerMXBeanAttributes(leavingQS2, remotePeerBean2);        leavingQS3 = peer3.getView().get(Long.valueOf(leavingIndex));    assertRemotePeerMXBeanAttributes(leavingQS3, remotePeerBean3);}
testJMXBeanAfterRoleChange
public void zookeeper_f6464_0() throws Exception
{        qu = new QuorumUtil(1);    qu.disableJMXTest = true;    qu.startAll();    zkArr = createHandles(qu);    zkAdminArr = createAdminHandles(qu);            List<String> joiningServers = new ArrayList<String>();        int changingIndex = 1;    int replica2 = 2;    QuorumPeer peer2 = qu.getPeer(replica2).peer;    QuorumServer changingQS2 = peer2.getView().get(Long.valueOf(changingIndex));    String remotePeerBean2 = MBeanRegistry.DOMAIN + ":name0=ReplicatedServer_id" + replica2 + ",name1=replica." + changingIndex;    assertRemotePeerMXBeanAttributes(changingQS2, remotePeerBean2);        int replica3 = 3;    QuorumPeer peer3 = qu.getPeer(replica3).peer;    QuorumServer changingQS3 = peer3.getView().get(Long.valueOf(changingIndex));    String remotePeerBean3 = MBeanRegistry.DOMAIN + ":name0=ReplicatedServer_id" + replica3 + ",name1=replica." + changingIndex;    assertRemotePeerMXBeanAttributes(changingQS3, remotePeerBean3);    String newRole = "observer";    ZooKeeper zk = zkArr[changingIndex];    ZooKeeperAdmin zkAdmin = zkAdminArr[changingIndex];        joiningServers.add("server." + changingIndex + "=127.0.0.1:" + qu.getPeer(changingIndex).peer.getQuorumAddress().getPort() + ":" + qu.getPeer(changingIndex).peer.getElectionAddress().getPort() + ":" + newRole + ";127.0.0.1:" + qu.getPeer(changingIndex).peer.getClientPort());    reconfig(zkAdmin, joiningServers, null, null, -1);    testNormalOperation(zkArr[changingIndex], zk);    assertTrue(qu.getPeer(changingIndex).peer.observer != null && qu.getPeer(changingIndex).peer.follower == null && qu.getPeer(changingIndex).peer.leader == null);    assertTrue(qu.getPeer(changingIndex).peer.getPeerState() == ServerState.OBSERVING);    QuorumPeer qp = qu.getPeer(changingIndex).peer;    String localPeerBeanName = MBeanRegistry.DOMAIN + ":name0=ReplicatedServer_id" + changingIndex + ",name1=replica." + changingIndex;        assertLocalPeerMXBeanAttributes(qp, localPeerBeanName, true);        changingQS2 = peer2.getView().get(Long.valueOf(changingIndex));    assertRemotePeerMXBeanAttributes(changingQS2, remotePeerBean2);        changingQS3 = peer3.getView().get(Long.valueOf(changingIndex));    assertRemotePeerMXBeanAttributes(changingQS3, remotePeerBean3);}
assertLocalPeerMXBeanAttributes
private void zookeeper_f6465_0(QuorumPeer qp, String beanName, Boolean isPartOfEnsemble) throws Exception
{    assertEquals("Mismatches LearnerType!", qp.getLearnerType().name(), JMXEnv.ensureBeanAttribute(beanName, "LearnerType"));    assertEquals("Mismatches ClientAddress!", qp.getClientAddress().getHostString() + ":" + qp.getClientAddress().getPort(), JMXEnv.ensureBeanAttribute(beanName, "ClientAddress"));    assertEquals("Mismatches LearnerType!", qp.getElectionAddress().getHostString() + ":" + qp.getElectionAddress().getPort(), JMXEnv.ensureBeanAttribute(beanName, "ElectionAddress"));    assertEquals("Mismatches PartOfEnsemble!", isPartOfEnsemble, JMXEnv.ensureBeanAttribute(beanName, "PartOfEnsemble"));    assertEquals("Mismatches ConfigVersion!", qp.getQuorumVerifier().getVersion(), JMXEnv.ensureBeanAttribute(beanName, "ConfigVersion"));    assertEquals("Mismatches QuorumSystemInfo!", qp.getQuorumVerifier().toString(), JMXEnv.ensureBeanAttribute(beanName, "QuorumSystemInfo"));}
getAddrPortFromBean
 String zookeeper_f6466_0(String beanName, String attribute) throws Exception
{    String name = (String) JMXEnv.ensureBeanAttribute(beanName, attribute);    if (!name.contains(":")) {        return name;    }    return getNumericalAddrPort(name);}
getNumericalAddrPort
 String zookeeper_f6467_0(String name) throws UnknownHostException
{    String port = name.split(":")[1];    String addr = name.split(":")[0];    addr = InetAddress.getByName(addr).getHostAddress();    return addr + ":" + port;}
assertRemotePeerMXBeanAttributes
private void zookeeper_f6468_0(QuorumServer qs, String beanName) throws Exception
{    assertEquals("Mismatches LearnerType!", qs.type.name(), JMXEnv.ensureBeanAttribute(beanName, "LearnerType"));    assertEquals("Mismatches ClientAddress!", getNumericalAddrPort(qs.clientAddr.getHostString() + ":" + qs.clientAddr.getPort()), getAddrPortFromBean(beanName, "ClientAddress"));    assertEquals("Mismatches ElectionAddress!", getNumericalAddrPort(qs.electionAddr.getHostString() + ":" + qs.electionAddr.getPort()), getAddrPortFromBean(beanName, "ElectionAddress"));    assertEquals("Mismatches QuorumAddress!", getNumericalAddrPort(qs.addr.getHostString() + ":" + qs.addr.getPort()), getAddrPortFromBean(beanName, "QuorumAddress"));}
testRecovery
public voidf6469_1) throws Exception
{    File tmpDir = ClientBase.createTmpDir();    ClientBase.setupTestEnv();    ZooKeeperServer zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);    int oldSnapCount = SyncRequestProcessor.getSnapCount();    SyncRequestProcessor.setSnapCount(1000);    try {        final int PORT = Integer.parseInt(HOSTPORT.split(":")[1]);        ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);        f.startup(zks);                assertTrue("waiting for server up", ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT));        startSignal = new CountDownLatch(1);        ZooKeeper zk = new ZooKeeper(HOSTPORT, CONNECTION_TIMEOUT, this);        startSignal.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS);        assertTrue("count == 0", startSignal.getCount() == 0);        String path;                for (int i = 0; i < 10; i++) {            path = "/" + i;            zk.create(path, (path + "!").getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);            for (int j = 0; j < 10; j++) {                String subpath = path + "/" + j;                zk.create(subpath, (subpath + "!").getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);                for (int k = 0; k < 20; k++) {                    String subsubpath = subpath + "/" + k;                    zk.create(subsubpath, (subsubpath + "!").getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);                }            }        }        f.shutdown();        zks.shutdown();        assertTrue("waiting for server down", ClientBase.waitForServerDown(HOSTPORT, CONNECTION_TIMEOUT));        zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);        f = ServerCnxnFactory.createFactory(PORT, -1);        startSignal = new CountDownLatch(1);        f.startup(zks);        assertTrue("waiting for server up", ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT));        startSignal.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS);        assertTrue("count == 0", startSignal.getCount() == 0);        Stat stat = new Stat();        for (int i = 0; i < 10; i++) {            path = "/" + i;                        assertEquals(new String(zk.getData(path, false, stat)), path + "!");            for (int j = 0; j < 10; j++) {                String subpath = path + "/" + j;                assertEquals(new String(zk.getData(subpath, false, stat)), subpath + "!");                for (int k = 0; k < 20; k++) {                    String subsubpath = subpath + "/" + k;                    assertEquals(new String(zk.getData(subsubpath, false, stat)), subsubpath + "!");                }            }        }        f.shutdown();        zks.shutdown();        assertTrue("waiting for server down", ClientBase.waitForServerDown(HOSTPORT, ClientBase.CONNECTION_TIMEOUT));        zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);        f = ServerCnxnFactory.createFactory(PORT, -1);        startSignal = new CountDownLatch(1);        f.startup(zks);        assertTrue("waiting for server up", ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT));        startSignal.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS);        assertTrue("count == 0", startSignal.getCount() == 0);        stat = new Stat();                for (int i = 0; i < 10; i++) {            path = "/" + i;            assertEquals(new String(zk.getData(path, false, stat)), path + "!");            for (int j = 0; j < 10; j++) {                String subpath = path + "/" + j;                assertEquals(new String(zk.getData(subpath, false, stat)), subpath + "!");                for (int k = 0; k < 20; k++) {                    String subsubpath = subpath + "/" + k;                    assertEquals(new String(zk.getData(subsubpath, false, stat)), subsubpath + "!");                }            }        }        zk.close();        f.shutdown();        zks.shutdown();        assertTrue("waiting for server down", ClientBase.waitForServerDown(HOSTPORT, CONNECTION_TIMEOUT));    } finally {        SyncRequestProcessor.setSnapCount(oldSnapCount);    }}
process
public voidf6470_1WatchedEvent event)
{        if (event.getState() == KeeperState.SyncConnected && startSignal != null && startSignal.getCount() > 0) {        startSignal.countDown();    }}
testFail
public void zookeeper_f6471_0() throws Exception
{    QuorumBase qb = new QuorumBase();    qb.setUp();    System.out.println("Comment: the servers are at " + qb.hostPort);    ZooKeeper zk = qb.createClient();    zk.create("/test", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.close();    QuorumBase.shutdown(qb.s1);    QuorumBase.shutdown(qb.s2);    QuorumBase.shutdown(qb.s3);    QuorumBase.shutdown(qb.s4);    QuorumBase.shutdown(qb.s5);    String hp = qb.hostPort.split(",")[0];    ZooKeeperServer zks = new ZooKeeperServer(qb.s1.getTxnFactory().getSnapDir(), qb.s1.getTxnFactory().getDataDir(), 3000);    final int PORT = Integer.parseInt(hp.split(":")[1]);    ServerCnxnFactory factory = ServerCnxnFactory.createFactory(PORT, -1);    factory.startup(zks);    System.out.println("Comment: starting factory");    assertTrue("waiting for server up", ClientBase.waitForServerUp("127.0.0.1:" + PORT, QuorumTest.CONNECTION_TIMEOUT));    factory.shutdown();    zks.shutdown();    assertTrue("waiting for server down", ClientBase.waitForServerDown("127.0.0.1:" + PORT, QuorumTest.CONNECTION_TIMEOUT));    System.out.println("Comment: shutting down standalone");}
testResponseCache
public void zookeeper_f6472_0() throws Exception
{    ZooKeeper zk = createClient();    try {        performCacheTest(zk, "/cache", true);        performCacheTest(zk, "/nocache", false);    } finally {        zk.close();    }}
checkCacheStatus
private void zookeeper_f6473_0(long expectedHits, long expectedMisses)
{    Map<String, Object> metrics = MetricsUtils.currentServerMetrics();    assertEquals(expectedHits, metrics.get("response_packet_cache_hits"));    assertEquals(expectedMisses, metrics.get("response_packet_cache_misses"));}
performCacheTest
public voidf6474_1ZooKeeper zk, String path, boolean useCache) throws Exception
{    ServerMetrics.getMetrics().resetAll();    Stat writeStat = new Stat();    Stat readStat = new Stat();    byte[] readData = null;    int reads = 10;    long expectedHits = 0;    long expectedMisses = 0;    serverFactory.getZooKeeperServer().setResponseCachingEnabled(useCache);        byte[] writeData = "test1".getBytes();    zk.create(path, writeData, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, writeStat);    for (int i = 0; i < reads; ++i) {        readData = zk.getData(path, false, readStat);        assertArrayEquals(writeData, readData);        assertEquals(writeStat, readStat);    }    if (useCache) {        expectedMisses += 1;        expectedHits += reads - 1;    }    checkCacheStatus(expectedHits, expectedMisses);    writeData = "test2".getBytes();    writeStat = zk.setData(path, writeData, -1);    for (int i = 0; i < 10; ++i) {        readData = zk.getData(path, false, readStat);        assertArrayEquals(writeData, readData);        assertEquals(writeStat, readStat);    }    if (useCache) {        expectedMisses += 1;        expectedHits += reads - 1;    }    checkCacheStatus(expectedHits, expectedMisses);                    zk.create(path + "/child", "child".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, null);    readData = zk.getData(path, false, readStat);    if (useCache) {        expectedMisses++;    }    assertArrayEquals(writeData, readData);    assertNotSame(writeStat, readStat);    checkCacheStatus(expectedHits, expectedMisses);}
testRestoreCommittedLogWithSnapSize
public void zookeeper_f6475_0() throws Exception
{    final int minExpectedSnapshots = 5;    final int minTxnsToSnap = 256;    final int numTransactions = minExpectedSnapshots * minTxnsToSnap;    final StringBuilder sb = new StringBuilder();    for (int i = 0; i < 4 * 1024; i++) {        sb.append("0");    }    final byte[] data = sb.toString().getBytes();    SyncRequestProcessor.setSnapCount(numTransactions * 1000);                SyncRequestProcessor.setSnapSizeInBytes(minTxnsToSnap * data.length);    testRestoreCommittedLog(numTransactions, data, minExpectedSnapshots);}
testRestoreCommittedLogWithSnapCount
public void zookeeper_f6476_0() throws Exception
{    final int minExpectedSnapshots = 30;    final int snapCount = 100;    SyncRequestProcessor.setSnapCount(snapCount);    SyncRequestProcessor.setSnapSizeInBytes(4294967296L);    testRestoreCommittedLog(minExpectedSnapshots * snapCount, new byte[0], minExpectedSnapshots);}
testRestoreCommittedLog
private voidf6477_1int totalTransactions, byte[] data, int minExpectedSnapshots) throws Exception
{    File tmpDir = ClientBase.createTmpDir();    ClientBase.setupTestEnv();    ZooKeeperServer zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);    final int PORT = Integer.parseInt(HOSTPORT.split(":")[1]);    ServerCnxnFactory f = ServerCnxnFactory.createFactory(PORT, -1);    f.startup(zks);    assertTrue("waiting for server being up ", ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT));    ZooKeeper zk = ClientBase.createZKClient(HOSTPORT);    try {        for (int i = 0; i < totalTransactions; i++) {            zk.create("/invalidsnap-" + i, data, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        }    } finally {        zk.close();    }    final int numSnaps = zks.getTxnLogFactory().findNRecentSnapshots(10 * minExpectedSnapshots).size();        f.shutdown();    zks.shutdown();    assertTrue("waiting for server to shutdown", ClientBase.waitForServerDown(HOSTPORT, CONNECTION_TIMEOUT));    assertTrue("too few snapshot files", numSnaps > minExpectedSnapshots);    assertTrue("too many snapshot files", numSnaps <= minExpectedSnapshots * 2);        zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);    zks.startdata();    Collection<Proposal> committedLog = zks.getZKDatabase().getCommittedLog();    int logsize = committedLog.size();        assertTrue("log size != 0", (logsize != 0));    zks.shutdown();}
testAuth
public void zookeeper_f6478_0() throws Exception
{    ZooKeeper zk = createClient();    try {        zk.create("/path1", null, Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT);        Thread.sleep(1000);    } catch (KeeperException e) {        fail("test failed :" + e);    } finally {        zk.close();    }}
testSaslConfig
public void zookeeper_f6479_0() throws Exception
{    ZooKeeper zk = createClient();    try {        zk.getChildren("/", false);        assertFalse(zk.getSaslClient().clientTunneledAuthenticationInProgress());        assertEquals(zk.getSaslClient().getSaslState(), ZooKeeperSaslClient.SaslState.COMPLETE);        assertNotNull(javax.security.auth.login.Configuration.getConfiguration().getAppConfigurationEntry("MyZookeeperClient"));        assertSame(zk.getSaslClient().getLoginContext(), "MyZookeeperClient");    } catch (KeeperException e) {        fail("test failed :" + e);    } finally {        zk.close();    }}
testReadAccessUser
public void zookeeper_f6480_0() throws Exception
{    System.setProperty("zookeeper.letAnySaslUserDoX", "anyone");    ZooKeeper zk = createClient();    List<ACL> aclList = new ArrayList<ACL>();    ACL acl = new ACL(Perms.ADMIN | Perms.CREATE | Perms.WRITE | Perms.DELETE, new Id("sasl", "fakeuser"));    ACL acl1 = new ACL(Perms.READ, new Id("sasl", "anyone"));    aclList.add(acl);    aclList.add(acl1);    try {        zk.create("/abc", "testData".getBytes(), aclList, CreateMode.PERSISTENT);    } catch (KeeperException e) {        fail("Unable to create znode");    }    zk.close();    Thread.sleep(100);        zk = createClient();    try {        zk.setData("/abc", "testData1".getBytes(), -1);        fail("Should not be able to set data");    } catch (KeeperException.NoAuthException e) {        }    try {        byte[] bytedata = zk.getData("/abc", null, null);        String data = new String(bytedata);        assertTrue("testData".equals(data));    } catch (KeeperException e) {        fail("failed to get data");    }    zk.close();    Thread.sleep(100);        System.setProperty(ZKClientConfig.ENABLE_CLIENT_SASL_KEY, "false");    try {        zk = createClient();        try {            zk.getData("/abc", null, null);            fail("Should not be able to read data when not authenticated");        } catch (KeeperException.NoAuthException e) {                }        zk.close();    } finally {                System.setProperty(ZKClientConfig.ENABLE_CLIENT_SASL_KEY, "true");    }}
reset
public synchronized void zookeeper_f6481_0()
{    authCompleted = new CountDownLatch(1);    super.reset();}
process
public synchronized void zookeeper_f6482_0(WatchedEvent event)
{    if (event.getState() == KeeperState.AuthFailed) {        authFailed.incrementAndGet();        authCompleted.countDown();    } else if (event.getState() == KeeperState.SaslAuthenticated) {        authCompleted.countDown();    } else {        super.process(event);    }}
testAuth
public void zookeeper_f6483_0() throws Exception
{    MyWatcher watcher = new MyWatcher();    ZooKeeper zk = createClient(watcher);    watcher.authCompleted.await(AUTHENTICATION_TIMEOUT, TimeUnit.MILLISECONDS);    assertEquals(authFailed.get(), 0);    try {        zk.create("/path1", null, Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT);    } catch (KeeperException e) {        fail("test failed :" + e);    } finally {        zk.close();    }}
testAuth
public voidf6484_1) throws Exception
{            CountdownWatcher watcher = new CountdownWatcher();    TestableZooKeeper zk = new TestableZooKeeper(hostPort, CONNECTION_TIMEOUT, watcher);    if (!watcher.clientConnected.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS)) {        fail("Unable to connect to server");    }    try {        zk.create("/path1", null, Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT);        fail("Should have gotten exception.");    } catch (KeeperException e) {                    } finally {        zk.close();    }}
process
public synchronized void zookeeper_f6485_0(WatchedEvent event)
{    if (event.getState() == KeeperState.AuthFailed) {        authFailed.countDown();    } else {        super.process(event);    }}
testAuthFail
public voidf6486_1)
{    try (ZooKeeper zk = createClient()) {        zk.create("/path1", null, Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT);        fail("Should have gotten exception.");    } catch (Exception e) {                    }}
testBadSaslAuthNotifiesWatch
public void zookeeper_f6487_0() throws Exception
{    try (ZooKeeper ignored = createClient(new MyWatcher(), hostPort)) {                authFailed.await();    }}
testAuth
public voidf6488_1) throws Exception
{    ZooKeeper zk = createClient();    try {        zk.create("/path1", null, Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT);        fail("Should have gotten exception.");    } catch (KeeperException e) {                    } finally {        zk.close();    }}
setup
public void zookeeper_f6489_0()
{    System.setProperty(SaslTestUtil.requireSASLAuthProperty, "true");}
tearDown
public void zookeeper_f6490_0() throws Exception
{    System.clearProperty(SaslTestUtil.requireSASLAuthProperty);}
testClientOpWithoutSASLConfigured
public void zookeeper_f6491_0() throws Exception
{    ZooKeeper zk = null;    CountdownWatcher watcher = new CountdownWatcher();    try {        zk = createClient(watcher);        zk.create("/foo", null, Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT);        fail("Client is not configured with SASL authentication, so zk.create operation should fail.");    } catch (KeeperException e) {        assertTrue(e.code() == KeeperException.Code.SESSIONCLOSEDREQUIRESASLAUTH);                        watcher.waitForDisconnected(SaslTestUtil.CLIENT_DISCONNECT_TIMEOUT);    } finally {        if (zk != null) {            zk.close();        }    }}
setUpBeforeClass
public static void zookeeper_f6492_0()
{    System.setProperty(SaslTestUtil.requireSASLAuthProperty, "true");    System.setProperty(SaslTestUtil.authProviderProperty, SaslTestUtil.authProvider);    System.setProperty(SaslTestUtil.jaasConfig, SaslTestUtil.createJAASConfigFile("jaas_wrong.conf", "test1"));}
tearDownAfterClass
public static void zookeeper_f6493_0()
{    System.clearProperty(SaslTestUtil.requireSASLAuthProperty);    System.clearProperty(SaslTestUtil.authProviderProperty);    System.clearProperty(SaslTestUtil.jaasConfig);}
testClientOpWithFailedSASLAuth
public void zookeeper_f6494_0() throws Exception
{    ZooKeeper zk = null;    CountdownWatcher watcher = new CountdownWatcher();    try {        zk = createClient(watcher);        zk.create("/bar", null, Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT);        fail("Client with wrong SASL config should not pass SASL authentication.");    } catch (KeeperException e) {        assertTrue(e.code() == KeeperException.Code.AUTHFAILED);                watcher.waitForDisconnected(SaslTestUtil.CLIENT_DISCONNECT_TIMEOUT);    } finally {        if (zk != null) {            zk.close();        }    }}
setUpBeforeClass
public static void zookeeper_f6495_0()
{    System.setProperty(SaslTestUtil.requireSASLAuthProperty, "true");    System.setProperty(SaslTestUtil.authProviderProperty, SaslTestUtil.authProvider);    System.setProperty(SaslTestUtil.jaasConfig, SaslTestUtil.createJAASConfigFile("jaas.conf", "test"));}
tearDownAfterClass
public static void zookeeper_f6496_0()
{    System.clearProperty(SaslTestUtil.requireSASLAuthProperty);    System.clearProperty(SaslTestUtil.authProviderProperty);    System.clearProperty(SaslTestUtil.jaasConfig);}
testClientOpWithValidSASLAuth
public void zookeeper_f6497_0() throws Exception
{    ZooKeeper zk = null;    CountdownWatcher watcher = new CountdownWatcher();    try {        zk = createClient(watcher);        zk.create("/foobar", null, Ids.CREATOR_ALL_ACL, CreateMode.PERSISTENT);    } catch (KeeperException e) {        fail("Client operation should succeed with valid SASL configuration.");    } finally {        if (zk != null) {            zk.close();        }    }}
setUp
public void zookeeper_f6498_0()
{    existingPropertyValue = System.getProperty(ZKClientConfig.ENABLE_CLIENT_SASL_KEY);}
tearDown
public void zookeeper_f6499_0()
{        if (existingPropertyValue != null) {        System.setProperty(ZKClientConfig.ENABLE_CLIENT_SASL_KEY, existingPropertyValue);    }}
testSaslClientDisabled
public void zookeeper_f6500_0()
{    System.clearProperty(ZKClientConfig.ENABLE_CLIENT_SASL_KEY);    assertTrue("SASL client disabled", new ZKClientConfig().isSaslClientEnabled());    for (String value : Arrays.asList("true", "TRUE")) {        System.setProperty(ZKClientConfig.ENABLE_CLIENT_SASL_KEY, value);        assertTrue("SASL client disabled", new ZKClientConfig().isSaslClientEnabled());    }    for (String value : Arrays.asList("false", "FALSE")) {        System.setProperty(ZKClientConfig.ENABLE_CLIENT_SASL_KEY, value);        assertFalse("SASL client disabled", new ZKClientConfig().isSaslClientEnabled());    }}
setupStatic
public static void zookeeper_f6501_0() throws Exception
{    oldAuthProvider = System.setProperty("zookeeper.authProvider.1", "org.apache.zookeeper.server.auth.SASLAuthenticationProvider");    File tmpDir = createTmpDir();    File saslConfFile = new File(tmpDir, "jaas.conf");    FileWriter fwriter = new FileWriter(saslConfFile);    fwriter.write("" + "Server {\n" + "          org.apache.zookeeper.server.auth.DigestLoginModule required\n" + "          user_super_duper=\"test\";\n" + "};\n" + "Client {\n" + "       org.apache.zookeeper.server.auth.DigestLoginModule required\n" + "       username=\"super_duper\"\n" + "       password=\"test\";\n" + "};" + "\n");    fwriter.close();    oldLoginConfig = System.setProperty("java.security.auth.login.config", saslConfFile.getAbsolutePath());    oldSuperUser = System.setProperty("zookeeper.superUser", "super_duper");    otherDigestUser = new Id("digest", DigestAuthenticationProvider.generateDigest("jack:jack"));}
cleanupStatic
public static void zookeeper_f6502_0()
{    if (oldAuthProvider != null) {        System.setProperty("zookeeper.authProvider.1", oldAuthProvider);    } else {        System.clearProperty("zookeeper.authProvider.1");    }    oldAuthProvider = null;    if (oldLoginConfig != null) {        System.setProperty("java.security.auth.login.config", oldLoginConfig);    } else {        System.clearProperty("java.security.auth.login.config");    }    oldLoginConfig = null;    if (oldSuperUser != null) {        System.setProperty("zookeeper.superUser", oldSuperUser);    } else {        System.clearProperty("zookeeper.superUser");    }    oldSuperUser = null;}
createClient
protected TestableZooKeeper zookeeper_f6503_0(String hp) throws IOException, InterruptedException
{    MyWatcher watcher = new MyWatcher();    return createClient(watcher, hp);}
process
public synchronized void zookeeper_f6504_0(WatchedEvent event)
{    if (event.getState() == KeeperState.AuthFailed) {        authFailed.incrementAndGet();    } else {        super.process(event);    }}
testSuperIsSuper
public void zookeeper_f6505_0() throws Exception
{    ZooKeeper zk = createClient();    try {        zk.create("/digest_read", null, Arrays.asList(new ACL(Perms.READ, otherDigestUser)), CreateMode.PERSISTENT);        zk.create("/digest_read/sub", null, Arrays.asList(new ACL(Perms.READ, otherDigestUser)), CreateMode.PERSISTENT);        zk.create("/sasl_read", null, Arrays.asList(new ACL(Perms.READ, otherSaslUser)), CreateMode.PERSISTENT);        zk.create("/sasl_read/sub", null, Arrays.asList(new ACL(Perms.READ, otherSaslUser)), CreateMode.PERSISTENT);        zk.delete("/digest_read/sub", -1);        zk.delete("/digest_read", -1);        zk.delete("/sasl_read/sub", -1);        zk.delete("/sasl_read", -1);                assertEquals(authFailed.get(), 0);    } finally {        zk.close();    }}
createJAASConfigFile
 static String zookeeper_f6506_0(String fileName, String password)
{    String ret = null;    try {        File tmpDir = createTmpDir();        File jaasFile = new File(tmpDir, fileName);        FileWriter fwriter = new FileWriter(jaasFile);        fwriter.write("" + "Server {\n" + "          " + digestLoginModule + " required\n" + "          user_super=\"test\";\n" + "};\n" + "Client {\n" + "       " + digestLoginModule + " required\n" + "       username=\"super\"\n" + "       password=\"" + password + "\";\n" + "};" + "\n");        fwriter.close();        ret = jaasFile.getAbsolutePath();    } catch (IOException e) {        fail("Unable to create JaaS configuration file!");    }    return ret;}
setUp
public void zookeeper_f6507_0() throws Exception
{    System.setProperty(NIOServerCnxnFactory.ZOOKEEPER_NIO_SESSIONLESS_CNXN_TIMEOUT, Integer.toString(cnxnTimeout));    super.setUp();}
tearDown
public void zookeeper_f6508_0() throws Exception
{    super.tearDown();    System.clearProperty(NIOServerCnxnFactory.ZOOKEEPER_NIO_SESSIONLESS_CNXN_TIMEOUT);}
testServerCnxnExpiry
public void zookeeper_f6509_0() throws Exception
{    verify("ruok", "imok");                String resp = sendRequest("ruok", 2 * cnxnTimeout + 1000);    assertEquals("Connection should have closed", "", resp);}
verify
private voidf6510_1String cmd, String expected) throws IOException
{    String resp = sendRequest(cmd, 0);        assertTrue(resp.contains(expected));}
sendRequest
private String zookeeper_f6511_0(String cmd, int delay) throws IOException
{    HostPort hpobj = ClientBase.parseHostPortList(hostPort).get(0);    return send4LetterWord(hpobj.host, hpobj.port, cmd, delay);}
send4LetterWord
private static Stringf6512_1String host, int port, String cmd, int delay) throws IOException
{        Socket sock = new Socket(host, port);    BufferedReader reader = null;    try {        try {                        Thread.sleep(delay);        } catch (InterruptedException e) {                }        OutputStream outstream = sock.getOutputStream();        outstream.write(cmd.getBytes());        outstream.flush();                sock.shutdownOutput();        reader = new BufferedReader(new InputStreamReader(sock.getInputStream()));        StringBuilder sb = readLine(reader);        return sb.toString();    } finally {        sock.close();        if (reader != null) {            reader.close();        }    }}
readLine
private static StringBuilderf6513_1BufferedReader reader)
{    StringBuilder sb = new StringBuilder();    String line;    try {        while ((line = reader.readLine()) != null) {            sb.append(line + "\n");        }    } catch (IOException ioe) {                                            }    return sb;}
testCreateAfterCloseShouldFail
public void zookeeper_f6514_0() throws Exception
{    for (int i = 0; i < 10; i++) {        ByteArrayOutputStream baos = new ByteArrayOutputStream();        BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos);                boa.writeInt(44, "len");        ConnectRequest conReq = new ConnectRequest(0, 0, 30000, 0, new byte[16]);        conReq.serialize(boa, "connect");                boa.writeInt(8, "len");        RequestHeader h = new RequestHeader(1, ZooDefs.OpCode.closeSession);        h.serialize(boa, "header");                        boa.writeInt(52, "len");        RequestHeader header = new RequestHeader(2, OpCode.create);        header.serialize(boa, "header");        CreateRequest createReq = new CreateRequest("/foo" + i, new byte[0], Ids.OPEN_ACL_UNSAFE, 1);        createReq.serialize(boa, "request");        baos.close();        System.out.println("Length:" + baos.toByteArray().length);        String[] hp = hostPort.split(":");        Socket sock = new Socket(hp[0], Integer.parseInt(hp[1]));        InputStream resultStream = null;        try {            OutputStream outstream = sock.getOutputStream();            byte[] data = baos.toByteArray();            outstream.write(data);            outstream.flush();            resultStream = sock.getInputStream();            byte[] b = new byte[10000];            int len;            while ((len = resultStream.read(b)) >= 0) {                                System.out.println("gotlen:" + len);            }        } finally {            if (resultStream != null) {                resultStream.close();            }            sock.close();        }    }    ZooKeeper zk = createClient();    assertEquals(1, zk.getChildren("/", false).size());    zk.close();}
setUp
public void zookeeper_f6515_0() throws Exception
{    if (tmpDir == null) {        tmpDir = ClientBase.createTmpDir();    }    ClientBase.setupTestEnv();    zs = new ZooKeeperServer(tmpDir, tmpDir, TICK_TIME);    final int PORT = Integer.parseInt(HOSTPORT.split(":")[1]);    serverFactory = ServerCnxnFactory.createFactory(PORT, -1);    serverFactory.startup(zs);    assertTrue("waiting for server up", ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT));}
tearDown
public void zookeeper_f6516_0() throws Exception
{    serverFactory.shutdown();    zs.shutdown();    assertTrue("waiting for server down", ClientBase.waitForServerDown(HOSTPORT, CONNECTION_TIMEOUT));}
process
public void zookeeper_f6517_0(WatchedEvent event)
{    if (event.getState() == KeeperState.SyncConnected) {        clientConnected.countDown();    }}
createClient
private DisconnectableZooKeeper zookeeper_f6518_0() throws IOException, InterruptedException
{    CountdownWatcher watcher = new CountdownWatcher();    return createClient(CONNECTION_TIMEOUT, watcher);}
createClient
private DisconnectableZooKeeper zookeeper_f6519_0(int timeout) throws IOException, InterruptedException
{    CountdownWatcher watcher = new CountdownWatcher();    return createClient(timeout, watcher);}
createClient
private DisconnectableZooKeeper zookeeper_f6520_0(int timeout, CountdownWatcher watcher) throws IOException, InterruptedException
{    DisconnectableZooKeeper zk = new DisconnectableZooKeeper(HOSTPORT, timeout, watcher);    if (!watcher.clientConnected.await(timeout, TimeUnit.MILLISECONDS)) {        fail("Unable to connect to server");    }    return zk;}
process
public voidf6521_1WatchedEvent event)
{        if (event.getState() == KeeperState.SyncConnected && startSignal != null && startSignal.getCount() > 0) {        startSignal.countDown();    }}
testSession
public voidf6522_1) throws IOException, InterruptedException, KeeperException
{    DisconnectableZooKeeper zk = createClient();    zk.create("/e", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);                    zk.disconnect();    Stat stat = new Stat();    startSignal = new CountDownLatch(1);    zk = new DisconnectableZooKeeper(HOSTPORT, CONNECTION_TIMEOUT, new MyWatcher("testSession"), zk.getSessionId(), zk.getSessionPasswd());    startSignal.await();        zk.getData("/e", false, stat);        zk.close();    zk = createClient();    assertEquals(null, zk.exists("/e", false));        zk.close();    try {        zk.getData("/e", false, stat);        fail("Should have received a SessionExpiredException");    } catch (KeeperException.SessionExpiredException e) {    }    AsyncCallback.DataCallback cb = new AsyncCallback.DataCallback() {        String status = "not done";        public void processResult(int rc, String p, Object c, byte[] b, Stat s) {            synchronized (this) {                status = KeeperException.Code.get(rc).toString();                this.notify();            }        }        public String toString() {            return status;        }    };    zk.getData("/e", false, cb, null);    synchronized (cb) {        if (cb.toString().equals("not done")) {            cb.wait(1000);        }    }    assertEquals(KeeperException.Code.SESSIONEXPIRED.toString(), cb.toString());}
processResult
public void zookeeper_f6523_0(int rc, String p, Object c, byte[] b, Stat s)
{    synchronized (this) {        status = KeeperException.Code.get(rc).toString();        this.notify();    }}
toString
public String zookeeper_f6524_0()
{    return status;}
testSessionMove
public voidf6525_1) throws Exception
{    String[] hostPorts = HOSTPORT.split(",");    DisconnectableZooKeeper zk = new DisconnectableZooKeeper(hostPorts[0], CONNECTION_TIMEOUT, new MyWatcher("0"));    zk.create("/sessionMoveTest", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);        for (int i = 0; i < hostPorts.length * 2; i++) {        zk.dontReconnect();                DisconnectableZooKeeper zknew = new DisconnectableZooKeeper(hostPorts[(i + 1) % hostPorts.length], CONNECTION_TIMEOUT, new MyWatcher(Integer.toString(i + 1)), zk.getSessionId(), zk.getSessionPasswd());        final int[] result = new int[1];        result[0] = Integer.MAX_VALUE;        zknew.sync("/", new AsyncCallback.VoidCallback() {            public void processResult(int rc, String path, Object ctx) {                synchronized (result) {                    result[0] = rc;                    result.notify();                }            }        }, null);        synchronized (result) {            if (result[0] == Integer.MAX_VALUE) {                result.wait(5000);            }        }                assertTrue(result[0] == KeeperException.Code.OK.intValue());        zknew.setData("/", new byte[1], -1);        try {            zk.setData("/", new byte[1], -1);            fail("Should have lost the connection");        } catch (KeeperException.ConnectionLossException e) {                    }                zk = zknew;    }    zk.close();}
processResult
public void zookeeper_f6526_0(int rc, String path, Object ctx)
{    synchronized (result) {        result[0] = rc;        result.notify();    }}
testSessionStateNoDupStateReporting
public void zookeeper_f6527_0() throws IOException, InterruptedException, KeeperException
{    final int TIMEOUT = 3000;    DupWatcher watcher = new DupWatcher();    ZooKeeper zk = createClient(TIMEOUT, watcher);        serverFactory.shutdown();    try {        Thread.sleep(10000);    } catch (InterruptedException e) {        }                    assertEquals(2, watcher.states.size());    zk.close();}
testSessionTimeoutAccess
public voidf6528_1) throws Exception
{        DisconnectableZooKeeper zk = createClient(TICK_TIME * 4);    assertEquals(TICK_TIME * 4, zk.getSessionTimeout());            zk.close();            zk = createClient(TICK_TIME);    assertEquals(TICK_TIME * 2, zk.getSessionTimeout());        zk.close();            zk = createClient(TICK_TIME * 30);    assertEquals(TICK_TIME * 20, zk.getSessionTimeout());        zk.close();    }
process
public void zookeeper_f6529_0(WatchedEvent event)
{    super.process(event);    if (event.getType() == EventType.None) {        states.add(event);    }}
testMinMaxSessionTimeout
public voidf6530_1) throws Exception
{        final int MINSESS = 20000;    final int MAXSESS = 240000;    {        ZooKeeperServer zs = serverFactory.getZooKeeperServer();        zs.setMinSessionTimeout(MINSESS);        zs.setMaxSessionTimeout(MAXSESS);    }        int timeout = 120000;    DisconnectableZooKeeper zk = createClient(timeout);    assertEquals(timeout, zk.getSessionTimeout());            zk.close();            zk = createClient(MINSESS / 2);    assertEquals(MINSESS, zk.getSessionTimeout());        zk.close();            zk = createClient(MAXSESS * 2);    assertEquals(MAXSESS, zk.getSessionTimeout());        zk.close();    }
testMaximumCnxnPerIP
public void zookeeper_f6531_0() throws Exception
{    final int maxClientCnxnsPerIP = 3;    serverFactory.setMaxClientCnxnsPerHost(maxClientCnxnsPerIP);    ZooKeeper[] clients = new ZooKeeper[maxClientCnxnsPerIP + 1];    for (int i = 0; i < clients.length; i++) {        CountdownWatcher watcher = new CountdownWatcher();                int timeout = 3000;        clients[i] = new DisconnectableZooKeeper(HOSTPORT, timeout, watcher);        boolean result = watcher.clientConnected.await(timeout, TimeUnit.MILLISECONDS);        if (i >= maxClientCnxnsPerIP) {            assertFalse(result);        } else {            assertTrue(result);        }    }}
setUp
public void zookeeper_f6532_0() throws Exception
{    super.setUp();    zk = createClient();}
testSessionExpiration
public void zookeeper_f6533_0() throws InterruptedException, KeeperException
{    final CountDownLatch expirationLatch = new CountDownLatch(1);    Watcher watcher = event -> {        if (event.getState() == Watcher.Event.KeeperState.Expired) {            expirationLatch.countDown();        }    };    zk.exists("/foo", watcher);    zk.getTestable().injectSessionExpiration();    assertTrue(expirationLatch.await(5, TimeUnit.SECONDS));    boolean gotException = false;    try {        zk.exists("/foo", false);        fail("Should have thrown a SessionExpiredException");    } catch (KeeperException.SessionExpiredException e) {                gotException = true;    }    assertTrue(gotException);}
testQueueEvent
public void zookeeper_f6534_0() throws InterruptedException, KeeperException
{    final CountDownLatch eventLatch = new CountDownLatch(1);    Watcher watcher = event -> {        if (event.getType() == Watcher.Event.EventType.NodeDataChanged) {            if (event.getPath().equals("/foo/bar")) {                eventLatch.countDown();            }        }    };    zk.exists("/foo/bar", watcher);    WatchedEvent event = new WatchedEvent(Watcher.Event.EventType.NodeDataChanged, Watcher.Event.KeeperState.SyncConnected, "/foo/bar");    zk.getTestable().queueEvent(event);    assertTrue(eventLatch.await(5, TimeUnit.SECONDS));}
testSessionDisconnect
public void zookeeper_f6535_0() throws KeeperException, InterruptedException, IOException
{    zk.create("/sdisconnect", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);    assertNotNull("Ephemeral node has not been created", zk.exists("/sdisconnect", null));    zk.close();    zk = createClient();    assertNull("Ephemeral node shouldn't exist after client disconnect", zk.exists("/sdisconnect", null));}
testSessionRestore
public void zookeeper_f6536_0() throws KeeperException, InterruptedException, IOException
{    zk.create("/srestore", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);    assertNotNull("Ephemeral node has not been created", zk.exists("/srestore", null));    zk.disconnect();    zk.close();    zk = createClient();    assertNotNull("Ephemeral node should be present when session is restored", zk.exists("/srestore", null));}
testSessionSurviveServerRestart
public void zookeeper_f6537_0() throws Exception
{    zk.create("/sdeath", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);    assertNotNull("Ephemeral node has not been created", zk.exists("/sdeath", null));    zk.disconnect();    stopServer();    startServer();    zk = createClient();    assertNotNull("Ephemeral node should be present when server restarted", zk.exists("/sdeath", null));}
expire
public void zookeeper_f6538_0(Session session)
{}
getServerId
public long zookeeper_f6539_0()
{    return sid;}
setUp
public void zookeeper_f6540_0() throws Exception
{    sessionsWithTimeouts.clear();}
tearDown
public void zookeeper_f6541_0() throws Exception
{}
testLearnerSessionTracker
public void zookeeper_f6542_0() throws Exception
{    Expirer expirer = new Expirer(1);        LearnerSessionTracker tracker = new LearnerSessionTracker(expirer, sessionsWithTimeouts, TICK_TIME, expirer.sid, true, testZKSListener());        long sessionId = 0xb100ded;    try {        tracker.checkSession(sessionId, null);        fail("Unknown session should have failed");    } catch (SessionExpiredException e) {        }        sessionsWithTimeouts.put(sessionId, CONNECTION_TIMEOUT);    try {        tracker.checkSession(sessionId, null);    } catch (Exception e) {        fail("Global session should not fail");    }        sessionId = tracker.createSession(CONNECTION_TIMEOUT);    try {        tracker.checkSession(sessionId, null);    } catch (Exception e) {        fail("Local session should not fail");    }        sessionsWithTimeouts.put(sessionId, CONNECTION_TIMEOUT);    try {        tracker.checkSession(sessionId, null);    } catch (Exception e) {        fail("Session during upgrade should not fail");    }        tracker = new LearnerSessionTracker(expirer, sessionsWithTimeouts, TICK_TIME, expirer.sid, false, testZKSListener());        sessionId = 0xdeadbeef;    try {        tracker.checkSession(sessionId, null);    } catch (Exception e) {        fail("Should not get any exception");    }}
testLeaderSessionTracker
public void zookeeper_f6543_0() throws Exception
{    Expirer expirer = new Expirer(2);        LeaderSessionTracker tracker = new LeaderSessionTracker(expirer, sessionsWithTimeouts, TICK_TIME, expirer.sid, true, testZKSListener());        long sessionId = ((expirer.sid + 1) << 56) + 1;    try {        tracker.checkSession(sessionId, null);    } catch (Exception e) {        fail("local session from other server should not fail");    }        tracker.trackSession(sessionId, CONNECTION_TIMEOUT);    try {        tracker.checkSession(sessionId, null);    } catch (Exception e) {        fail("Global session should not fail");    }    try {        tracker.checkGlobalSession(sessionId, null);    } catch (Exception e) {        fail("Global session should not fail " + e);    }        sessionId = tracker.createSession(CONNECTION_TIMEOUT);    try {        tracker.checkSession(sessionId, null);    } catch (Exception e) {        fail("Local session on the leader should not fail");    }        tracker.trackSession(sessionId, CONNECTION_TIMEOUT);    try {        tracker.checkSession(sessionId, null);    } catch (Exception e) {        fail("Session during upgrade should not fail");    }    try {        tracker.checkGlobalSession(sessionId, null);    } catch (Exception e) {        fail("Global session should not fail " + e);    }        tracker = new LeaderSessionTracker(expirer, sessionsWithTimeouts, TICK_TIME, expirer.sid, false, testZKSListener());        sessionId = 0xdeadbeef;    tracker.trackSession(sessionId, CONNECTION_TIMEOUT);    try {        tracker.checkSession(sessionId, null);    } catch (Exception e) {        fail("Global session should not fail");    }    try {        tracker.checkGlobalSession(sessionId, null);    } catch (Exception e) {        fail("Global session should not fail");    }        sessionId = ((expirer.sid + 1) << 56) + 2;    try {        tracker.checkSession(sessionId, null);        fail("local session from other server should fail");    } catch (SessionExpiredException e) {        }        sessionId = ((expirer.sid) << 56) + 2;    try {        tracker.checkSession(sessionId, null);        fail("local session from the leader should fail");    } catch (SessionExpiredException e) {        }}
testZKSListener
 ZooKeeperServerListener zookeeper_f6544_0()
{    return new ZooKeeperServerListener() {        @Override        public void notifyStopping(String errMsg, int exitCode) {        }    };}
notifyStopping
public void zookeeper_f6545_0(String errMsg, int exitCode)
{}
setUp
public voidf6546_1) throws Exception
{        qb.localSessionsEnabled = true;    qb.localSessionsUpgradingEnabled = true;    qb.setUp();    ClientBase.waitForServerUp(qb.hostPort, 10000);}
tearDown
public voidf6547_1) throws Exception
{        qb.tearDown();}
testLocalSessionsWithoutEphemeralOnFollower
public void zookeeper_f6548_0() throws Exception
{    testLocalSessionsWithoutEphemeral(false);}
testLocalSessionsWithoutEphemeralOnLeader
public void zookeeper_f6549_0() throws Exception
{    testLocalSessionsWithoutEphemeral(true);}
testLocalSessionsWithoutEphemeral
private void zookeeper_f6550_0(boolean testLeader) throws Exception
{    String nodePrefix = "/testLocalSessions-" + (testLeader ? "leaderTest-" : "followerTest-");    int leaderIdx = qb.getLeaderIndex();    assertFalse("No leader in quorum?", leaderIdx == -1);    int followerIdx = (leaderIdx + 1) % 5;    int otherFollowerIdx = (leaderIdx + 2) % 5;    int testPeerIdx = testLeader ? leaderIdx : followerIdx;    String[] hostPorts = qb.hostPort.split(",");    CountdownWatcher watcher = new CountdownWatcher();    DisconnectableZooKeeper zk = new DisconnectableZooKeeper(hostPorts[testPeerIdx], CONNECTION_TIMEOUT, watcher);    watcher.waitForConnected(CONNECTION_TIMEOUT);        for (int i = 0; i < 5; i++) {        zk.create(nodePrefix + i, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    }    long localSessionId = zk.getSessionId();    byte[] localSessionPwd = zk.getSessionPasswd().clone();        try {        watcher.reset();        DisconnectableZooKeeper zknew = new DisconnectableZooKeeper(hostPorts[otherFollowerIdx], CONNECTION_TIMEOUT, watcher, localSessionId, localSessionPwd);        zknew.create(nodePrefix + "5", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        fail("Connection on the same session ID should fail.");    } catch (KeeperException.SessionExpiredException e) {    } catch (KeeperException.ConnectionLossException e) {    }        if (!testLeader) {        try {            watcher.reset();            DisconnectableZooKeeper zknew = new DisconnectableZooKeeper(hostPorts[leaderIdx], CONNECTION_TIMEOUT, watcher, localSessionId, localSessionPwd);            zknew.create(nodePrefix + "5", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);            fail("Connection on the same session ID should fail.");        } catch (KeeperException.SessionExpiredException e) {        } catch (KeeperException.ConnectionLossException e) {        }    }                zk.disconnect();    watcher.reset();    zk = new DisconnectableZooKeeper(hostPorts[testPeerIdx], CONNECTION_TIMEOUT, watcher, localSessionId, localSessionPwd);    watcher.waitForConnected(CONNECTION_TIMEOUT);    zk.create(nodePrefix + "6", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);            zk.close();    try {        watcher.reset();        zk = new DisconnectableZooKeeper(hostPorts[testPeerIdx], CONNECTION_TIMEOUT, watcher, localSessionId, localSessionPwd);        zk.create(nodePrefix + "7", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        fail("Reconnecting to a closed session ID should fail.");    } catch (KeeperException.SessionExpiredException e) {    }}
testUpgradeWithEphemeralOnFollower
public void zookeeper_f6551_0() throws Exception
{    testUpgradeWithEphemeral(false);}
testUpgradeWithEphemeralOnLeader
public void zookeeper_f6552_0() throws Exception
{    testUpgradeWithEphemeral(true);}
testUpgradeWithEphemeral
private void zookeeper_f6553_0(boolean testLeader) throws Exception
{    String nodePrefix = "/testUpgrade-" + (testLeader ? "leaderTest-" : "followerTest-");    int leaderIdx = qb.getLeaderIndex();    assertFalse("No leader in quorum?", leaderIdx == -1);    int followerIdx = (leaderIdx + 1) % 5;    int otherFollowerIdx = (leaderIdx + 2) % 5;    int testPeerIdx = testLeader ? leaderIdx : followerIdx;    String[] hostPorts = qb.hostPort.split(",");    CountdownWatcher watcher = new CountdownWatcher();    DisconnectableZooKeeper zk = new DisconnectableZooKeeper(hostPorts[testPeerIdx], CONNECTION_TIMEOUT, watcher);    watcher.waitForConnected(CONNECTION_TIMEOUT);        for (int i = 0; i < 5; i++) {        zk.create(nodePrefix + i, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);    }            long localSessionId = zk.getSessionId();    byte[] localSessionPwd = zk.getSessionPasswd().clone();    zk.disconnect();    watcher.reset();    zk = new DisconnectableZooKeeper(hostPorts[otherFollowerIdx], CONNECTION_TIMEOUT, watcher, localSessionId, localSessionPwd);    watcher.waitForConnected(CONNECTION_TIMEOUT);        for (int i = 0; i < 5; i++) {        assertNotNull(zk.exists(nodePrefix + i, null));    }            zk.close();    try {        watcher.reset();        zk = new DisconnectableZooKeeper(hostPorts[otherFollowerIdx], CONNECTION_TIMEOUT, watcher, localSessionId, localSessionPwd);        zk.exists(nodePrefix + "0", null);        fail("Reconnecting to a closed session ID should fail.");    } catch (KeeperException.SessionExpiredException e) {    }    watcher.reset();        zk = new DisconnectableZooKeeper(hostPorts[testPeerIdx], CONNECTION_TIMEOUT, watcher);    watcher.waitForConnected(CONNECTION_TIMEOUT);    for (int i = 0; i < 5; i++) {        assertNull(zk.exists(nodePrefix + i, null));    }}
run
public void zookeeper_f6554_0()
{    try {        Stat stat = new Stat();        String path = zk.create("/hammers/hammer-", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);        byte[] tag = (path + " was here!").getBytes();        synchronized (this) {            String startPath = "/hammers/start";            System.out.println("Waiting for " + startPath);            while (zk.exists(startPath, true) == null) {                wait();            }            System.out.println("Running");        }        for (int i = 0; i < count; i++) {            try {                System.out.print(i + "\r");                List<String> childs = zk.getChildren("/hammers", false);                Collections.shuffle(childs);                for (String s : childs) {                    if (s.startsWith("hammer-")) {                        s = "/hammers/" + s;                        zk.setData(s, tag, -1);                        for (int j = 0; j < readsPerWrite; j++) {                            zk.getData(s, false, stat);                        }                        break;                    }                }            } catch (KeeperException.ConnectionLossException e) {                        } catch (KeeperException e) {                e.printStackTrace();            }        }        System.out.println();        zk.close();    } catch (RuntimeException e) {        e.printStackTrace();    } catch (InterruptedException e) {        e.printStackTrace();    } catch (KeeperException e) {        e.printStackTrace();    }}
main
public static void zookeeper_f6555_0(String[] args) throws Exception
{    if (args.length != 3) {        System.err.println("USAGE: SledgeHammer zookeeper_server reps reads_per_rep");        System.exit(ExitCode.UNABLE_TO_ACCESS_DATADIR.getValue());    }    SledgeHammer h = new SledgeHammer(args[0], Integer.parseInt(args[1]), Integer.parseInt(args[2]));    h.start();    System.exit(ExitCode.EXECUTION_FINISHED.getValue());}
setUpSecure
public static ClientX509Util zookeeper_f6556_0() throws Exception
{    ClientX509Util x509Util = new ClientX509Util();    String testDataPath = System.getProperty("test.data.dir", "src/test/resources/data");    System.setProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY, "org.apache.zookeeper.server.NettyServerCnxnFactory");    System.setProperty(ZKClientConfig.ZOOKEEPER_CLIENT_CNXN_SOCKET, "org.apache.zookeeper.ClientCnxnSocketNetty");    System.setProperty(ZKClientConfig.SECURE_CLIENT, "true");    System.setProperty(x509Util.getSslAuthProviderProperty(), "x509");    System.setProperty(x509Util.getSslKeystoreLocationProperty(), testDataPath + "/ssl/testKeyStore.jks");    System.setProperty(x509Util.getSslKeystorePasswdProperty(), "testpass");    System.setProperty(x509Util.getSslTruststoreLocationProperty(), testDataPath + "/ssl/testTrustStore.jks");    System.setProperty(x509Util.getSslTruststorePasswdProperty(), "testpass");    System.setProperty("javax.net.debug", "ssl");    System.setProperty("zookeeper.authProvider.x509", "org.apache.zookeeper.server.auth.X509AuthenticationProvider");    return x509Util;}
clearSecureSetting
public static void zookeeper_f6557_0(ClientX509Util clientX509Util)
{    System.clearProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY);    System.clearProperty(ZKClientConfig.ZOOKEEPER_CLIENT_CNXN_SOCKET);    System.clearProperty(ZKClientConfig.SECURE_CLIENT);    System.clearProperty(clientX509Util.getSslAuthProviderProperty());    System.clearProperty(clientX509Util.getSslKeystoreLocationProperty());    System.clearProperty(clientX509Util.getSslKeystorePasswdProperty());    System.clearProperty(clientX509Util.getSslTruststoreLocationProperty());    System.clearProperty(clientX509Util.getSslTruststorePasswdProperty());    System.clearProperty("javax.net.debug");    System.clearProperty("zookeeper.authProvider.x509");    clientX509Util.close();}
setUp
public void zookeeper_f6558_0() throws Exception
{    clientX509Util = setUpSecure();    String host = "localhost";    int port = PortAssignment.unique();    hostPort = host + ":" + port;    serverFactory = ServerCnxnFactory.createFactory();    serverFactory.configure(new InetSocketAddress(host, port), maxCnxns, -1, true);    super.setUp();}
teardown
public void zookeeper_f6559_0() throws Exception
{    clearSecureSetting(clientX509Util);}
testRejection
public void zookeeper_f6560_0() throws Exception
{    String testDataPath = System.getProperty("test.data.dir", "src/test/resources/data");        System.setProperty(clientX509Util.getSslKeystoreLocationProperty(), testDataPath + "/ssl/testUntrustedKeyStore.jks");    System.setProperty(clientX509Util.getSslKeystorePasswdProperty(), "testpass");    CountdownWatcher watcher = new CountdownWatcher();        new TestableZooKeeper(hostPort, CONNECTION_TIMEOUT, watcher);    assertFalse("Untrusted certificate should not result in successful connection", watcher.clientConnected.await(1000, TimeUnit.MILLISECONDS));}
testMisconfiguration
public void zookeeper_f6561_0() throws Exception
{    System.clearProperty(clientX509Util.getSslAuthProviderProperty());    System.clearProperty(clientX509Util.getSslKeystoreLocationProperty());    System.clearProperty(clientX509Util.getSslKeystorePasswdProperty());    System.clearProperty(clientX509Util.getSslTruststoreLocationProperty());    System.clearProperty(clientX509Util.getSslTruststorePasswdProperty());    CountdownWatcher watcher = new CountdownWatcher();    new TestableZooKeeper(hostPort, CONNECTION_TIMEOUT, watcher);    assertFalse("Missing SSL configuration should not result in successful connection", watcher.clientConnected.await(1000, TimeUnit.MILLISECONDS));}
setup
public void zookeeper_f6562_0()
{    System.setProperty("zookeeper.DigestAuthenticationProvider.superDigest", "super:D/InIHSb7yEEbrWz8b9l71RjZJU=");    QuorumPeerConfig.setReconfigEnabled(true);}
testNoDynamicConfig
public void zookeeper_f6563_0() throws Exception
{    ClientBase.setupTestEnv();    final int CLIENT_PORT = PortAssignment.unique();    MainThread mt = new MainThread(MainThread.UNSET_MYID, CLIENT_PORT, "", false);    verifyStandalone(mt, CLIENT_PORT);}
testClientPortInDynamicFile
public void zookeeper_f6564_0() throws Exception
{    ClientBase.setupTestEnv();    final int CLIENT_PORT = PortAssignment.unique();    String quorumCfgSection = "server.1=127.0.0.1:" + (PortAssignment.unique()) + ":" + (PortAssignment.unique()) + ":participant;" + CLIENT_PORT + "\n";    MainThread mt = new MainThread(1, quorumCfgSection);    verifyStandalone(mt, CLIENT_PORT);}
testClientPortInStaticFile
public void zookeeper_f6565_0() throws Exception
{    ClientBase.setupTestEnv();    final int CLIENT_PORT = PortAssignment.unique();    String quorumCfgSection = "server.1=127.0.0.1:" + (PortAssignment.unique()) + ":" + (PortAssignment.unique()) + ":participant;" + CLIENT_PORT + "\n";    MainThread mt = new MainThread(1, quorumCfgSection, false);    verifyStandalone(mt, CLIENT_PORT);}
verifyStandalone
 void zookeeper_f6566_0(MainThread mt, int clientPort) throws InterruptedException
{    mt.start();    try {        assertTrue("waiting for server 1 being up", ClientBase.waitForServerUp("127.0.0.1:" + clientPort, CONNECTION_TIMEOUT));    } finally {        assertFalse("Error- MainThread started in Quorum Mode!", mt.isQuorumPeerRunning());        mt.shutdown();    }}
testStandaloneReconfigFails
public void zookeeper_f6567_0() throws Exception
{    ClientBase.setupTestEnv();    final int CLIENT_PORT = PortAssignment.unique();    final String HOSTPORT = "127.0.0.1:" + CLIENT_PORT;    File tmpDir = ClientBase.createTmpDir();    ZooKeeperServer zks = new ZooKeeperServer(tmpDir, tmpDir, 3000);    ServerCnxnFactory f = ServerCnxnFactory.createFactory(CLIENT_PORT, -1);    f.startup(zks);    assertTrue("waiting for server being up ", ClientBase.waitForServerUp(HOSTPORT, CONNECTION_TIMEOUT));    CountdownWatcher watcher = new CountdownWatcher();    ZooKeeper zk = new ZooKeeper(HOSTPORT, CONNECTION_TIMEOUT, watcher);    ZooKeeperAdmin zkAdmin = new ZooKeeperAdmin(HOSTPORT, CONNECTION_TIMEOUT, watcher);    watcher.waitForConnected(CONNECTION_TIMEOUT);    List<String> joiners = new ArrayList<String>();    joiners.add("server.2=localhost:1234:1235;1236");        try {        zkAdmin.addAuthInfo("digest", "super:test".getBytes());        zkAdmin.reconfigure(joiners, null, null, -1, new Stat());        fail("Reconfiguration in standalone should trigger " + "UnimplementedException");    } catch (KeeperException.UnimplementedException ex) {        }    zk.close();    zks.shutdown();    f.shutdown();    assertTrue("waiting for server being down ", ClientBase.waitForServerDown(HOSTPORT, CONNECTION_TIMEOUT));}
testNextGoesRound
public void zookeeper_f6568_0()
{    HostProvider hostProvider = getHostProvider((byte) 2);    InetSocketAddress first = hostProvider.next(0);    assertTrue(first != null);    hostProvider.next(0);    assertEquals(first, hostProvider.next(0));}
testNextGoesRoundAndSleeps
public void zookeeper_f6569_0()
{    byte size = 2;    HostProvider hostProvider = getHostProvider(size);    while (size > 0) {        hostProvider.next(0);        --size;    }    long start = Time.currentElapsedTime();    hostProvider.next(1000);    long stop = Time.currentElapsedTime();    assertTrue(900 <= stop - start);}
testNextDoesNotSleepForZero
public void zookeeper_f6570_0()
{    byte size = 2;    HostProvider hostProvider = getHostProvider(size);    while (size > 0) {        hostProvider.next(0);        --size;    }    long start = Time.currentElapsedTime();    hostProvider.next(0);    long stop = Time.currentElapsedTime();    assertTrue(5 > stop - start);}
testEmptyServerAddressesList
public void zookeeper_f6571_0()
{    HostProvider hp = new StaticHostProvider(new ArrayList<>());}
testInvalidHostAddresses
public void zookeeper_f6572_0()
{        final List<InetSocketAddress> invalidAddresses = new ArrayList<>();    InetSocketAddress unresolved = InetSocketAddress.createUnresolved("a", 1234);    invalidAddresses.add(unresolved);    StaticHostProvider.Resolver resolver = new StaticHostProvider.Resolver() {        @Override        public InetAddress[] getAllByName(String name) throws UnknownHostException {            throw new UnknownHostException();        }    };    StaticHostProvider sp = new StaticHostProvider(invalidAddresses, resolver);        InetSocketAddress n1 = sp.next(0);    assertTrue("Provider should return unresolved address is host is unresolvable", n1.isUnresolved());    assertSame("Provider should return original address is host is unresolvable", unresolved, n1);}
getAllByName
public InetAddress[] zookeeper_f6573_0(String name) throws UnknownHostException
{    throw new UnknownHostException();}
testTwoConsequitiveCallsToNextReturnDifferentElement
public void zookeeper_f6574_0()
{    HostProvider hostProvider = getHostProvider((byte) 2);    assertNotSame(hostProvider.next(0), hostProvider.next(0));}
testOnConnectDoesNotReset
public void zookeeper_f6575_0()
{    HostProvider hostProvider = getHostProvider((byte) 2);    InetSocketAddress first = hostProvider.next(0);    hostProvider.onConnected();    InetSocketAddress second = hostProvider.next(0);    assertNotSame(first, second);}
testUpdateClientMigrateOrNot
public void zookeeper_f6576_0() throws UnknownHostException
{        HostProvider hostProvider = getHostProvider((byte) 4);        Collection<InetSocketAddress> newList = getServerAddresses((byte) 3);    InetSocketAddress myServer = new InetSocketAddress(InetAddress.getByAddress(new byte[] { 10, 10, 10, 3 }), 1237);        boolean disconnectRequired = hostProvider.updateServerList(newList, myServer);    assertFalse(disconnectRequired);    hostProvider.onConnected();        disconnectRequired = hostProvider.updateServerList(newList, myServer);    assertFalse(disconnectRequired);    hostProvider.onConnected();                newList = getServerAddresses((byte) 2);    disconnectRequired = hostProvider.updateServerList(newList, myServer);    assertTrue(disconnectRequired);    hostProvider.onConnected();            disconnectRequired = hostProvider.updateServerList(newList, myServer);    assertTrue(disconnectRequired);    hostProvider.onConnected();        newList = new ArrayList<InetSocketAddress>(3);    for (byte i = 4; i > 1; i--) {                newList.add(new InetSocketAddress(InetAddress.getByAddress(new byte[] { 10, 10, 10, i }), 1234 + i));    }    myServer = new InetSocketAddress(InetAddress.getByAddress(new byte[] { 10, 10, 10, 1 }), 1235);    disconnectRequired = hostProvider.updateServerList(newList, myServer);    assertTrue(disconnectRequired);    hostProvider.onConnected();                        HostProvider[] hostProviderArray = new HostProvider[numClients];    newList = getServerAddresses((byte) 10);    int numDisconnects = 0;    for (int i = 0; i < numClients; i++) {        hostProviderArray[i] = getHostProvider((byte) 9);        disconnectRequired = hostProviderArray[i].updateServerList(newList, myServer);        if (disconnectRequired) {            numDisconnects++;        }    }    hostProvider.onConnected();        assertTrue(numDisconnects < upperboundCPS(numClients, 10));}
testUpdateMigrationGoesRound
public void zookeeper_f6577_0() throws UnknownHostException
{    HostProvider hostProvider = getHostProvider((byte) 4);        Collection<InetSocketAddress> newList = new ArrayList<InetSocketAddress>(10);    for (byte i = 12; i > 2; i--) {                        newList.add(new InetSocketAddress(InetAddress.getByAddress(new byte[] { 10, 10, 10, i }), 1234 + i));    }        Collection<InetSocketAddress> oldStaying = new ArrayList<InetSocketAddress>(2);    for (byte i = 4; i > 2; i--) {                oldStaying.add(new InetSocketAddress(InetAddress.getByAddress(new byte[] { 10, 10, 10, i }), 1234 + i));    }        Collection<InetSocketAddress> newComing = new ArrayList<InetSocketAddress>(10);    for (byte i = 12; i > 4; i--) {                newComing.add(new InetSocketAddress(InetAddress.getByAddress(new byte[] { 10, 10, 10, i }), 1234 + i));    }                    boolean disconnectRequired = hostProvider.updateServerList(newList, new InetSocketAddress(InetAddress.getByAddress(new byte[] { 10, 10, 10, 1 }), 1235));    assertTrue(disconnectRequired);                ArrayList<InetSocketAddress> seen = new ArrayList<InetSocketAddress>();    for (int i = 0; i < newComing.size(); i++) {        InetSocketAddress addr = hostProvider.next(0);        assertTrue(newComing.contains(addr));        assertTrue(!seen.contains(addr));        seen.add(addr);    }        seen.clear();    for (int i = 0; i < oldStaying.size(); i++) {        InetSocketAddress addr = hostProvider.next(0);        assertTrue(oldStaying.contains(addr));        assertTrue(!seen.contains(addr));        seen.add(addr);    }            InetSocketAddress first = hostProvider.next(0);    assertTrue(first != null);    for (int i = 0; i < newList.size() - 1; i++) {        hostProvider.next(0);    }    assertEquals(first, hostProvider.next(0));    hostProvider.onConnected();}
testUpdateLoadBalancing
public void zookeeper_f6578_0() throws UnknownHostException
{        boolean disconnectRequired;    HostProvider[] hostProviderArray = new HostProvider[numClients];    InetSocketAddress[] curHostForEachClient = new InetSocketAddress[numClients];    int[] numClientsPerHost = new int[9];        for (int i = 0; i < numClients; i++) {        hostProviderArray[i] = getHostProvider((byte) 9);        curHostForEachClient[i] = hostProviderArray[i].next(0);        numClientsPerHost[curHostForEachClient[i].getPort() - 1235]++;        hostProviderArray[i].onConnected();    }    for (int i = 0; i < 9; i++) {        assertTrue(numClientsPerHost[i] <= upperboundCPS(numClients, 9));        assertTrue(numClientsPerHost[i] >= lowerboundCPS(numClients, 9));                numClientsPerHost[i] = 0;    }        Collection<InetSocketAddress> newList = getServerAddresses((byte) 8);    for (int i = 0; i < numClients; i++) {        disconnectRequired = hostProviderArray[i].updateServerList(newList, curHostForEachClient[i]);        if (disconnectRequired) {            curHostForEachClient[i] = hostProviderArray[i].next(0);        }        numClientsPerHost[curHostForEachClient[i].getPort() - 1235]++;        hostProviderArray[i].onConnected();    }    for (int i = 0; i < 8; i++) {        assertTrue(numClientsPerHost[i] <= upperboundCPS(numClients, 8));        assertTrue(numClientsPerHost[i] >= lowerboundCPS(numClients, 8));                numClientsPerHost[i] = 0;    }    assertTrue(numClientsPerHost[8] == 0);        newList = getServerAddresses((byte) 6);    for (int i = 0; i < numClients; i++) {        disconnectRequired = hostProviderArray[i].updateServerList(newList, curHostForEachClient[i]);        if (disconnectRequired) {            curHostForEachClient[i] = hostProviderArray[i].next(0);        }        numClientsPerHost[curHostForEachClient[i].getPort() - 1235]++;        hostProviderArray[i].onConnected();    }    for (int i = 0; i < 6; i++) {        assertTrue(numClientsPerHost[i] <= upperboundCPS(numClients, 6));        assertTrue(numClientsPerHost[i] >= lowerboundCPS(numClients, 6));                numClientsPerHost[i] = 0;    }    assertTrue(numClientsPerHost[6] == 0);    assertTrue(numClientsPerHost[7] == 0);    assertTrue(numClientsPerHost[8] == 0);            newList = new ArrayList<InetSocketAddress>(8);    for (byte i = 9; i > 1; i--) {        newList.add(new InetSocketAddress(InetAddress.getByAddress(new byte[] { 10, 10, 10, i }), 1234 + i));    }    for (int i = 0; i < numClients; i++) {        disconnectRequired = hostProviderArray[i].updateServerList(newList, curHostForEachClient[i]);        if (disconnectRequired) {            curHostForEachClient[i] = hostProviderArray[i].next(0);        }        numClientsPerHost[curHostForEachClient[i].getPort() - 1235]++;        hostProviderArray[i].onConnected();    }    assertTrue(numClientsPerHost[0] == 0);    for (int i = 1; i < 9; i++) {        assertTrue(numClientsPerHost[i] <= upperboundCPS(numClients, 8));        assertTrue(numClientsPerHost[i] >= lowerboundCPS(numClients, 8));                numClientsPerHost[i] = 0;    }        newList = getServerAddresses((byte) 9);    for (int i = 0; i < numClients; i++) {        disconnectRequired = hostProviderArray[i].updateServerList(newList, curHostForEachClient[i]);        if (disconnectRequired) {            curHostForEachClient[i] = hostProviderArray[i].next(0);        }        numClientsPerHost[curHostForEachClient[i].getPort() - 1235]++;        hostProviderArray[i].onConnected();    }    for (int i = 0; i < 9; i++) {        assertTrue(numClientsPerHost[i] <= upperboundCPS(numClients, 9));        assertTrue(numClientsPerHost[i] >= lowerboundCPS(numClients, 9));    }}
testNoCurrentHostDuringNormalMode
public void zookeeper_f6579_0() throws UnknownHostException
{        boolean disconnectRequired;    StaticHostProvider[] hostProviderArray = new StaticHostProvider[numClients];    InetSocketAddress[] curHostForEachClient = new InetSocketAddress[numClients];    int[] numClientsPerHost = new int[9];        for (int i = 0; i < numClients; i++) {        hostProviderArray[i] = getHostProvider((byte) 9);        if (i >= (numClients / 2)) {            curHostForEachClient[i] = hostProviderArray[i].next(0);        } else {                                    curHostForEachClient[i] = null;        }    }        Collection<InetSocketAddress> newList = getServerAddresses((byte) 7);    for (int i = 0; i < numClients; i++) {                        disconnectRequired = hostProviderArray[i].updateServerList(newList, curHostForEachClient[i]);        if (disconnectRequired) {            curHostForEachClient[i] = hostProviderArray[i].next(0);        } else if (curHostForEachClient[i] == null) {                        curHostForEachClient[i] = hostProviderArray[i].getServerAtIndex(0);        }        numClientsPerHost[curHostForEachClient[i].getPort() - 1235]++;                hostProviderArray[i].onConnected();    }    for (int i = 0; i < 7; i++) {        assertTrue(numClientsPerHost[i] <= upperboundCPS(numClients, 7));        assertTrue(numClientsPerHost[i] >= lowerboundCPS(numClients, 7));                numClientsPerHost[i] = 0;    }    assertTrue(numClientsPerHost[7] == 0);    assertTrue(numClientsPerHost[8] == 0);        newList = getServerAddresses((byte) 8);    for (int i = 0; i < numClients; i++) {        InetSocketAddress myServer = (i < (numClients / 2)) ? null : curHostForEachClient[i];                disconnectRequired = hostProviderArray[i].updateServerList(newList, myServer);        if (disconnectRequired) {            curHostForEachClient[i] = hostProviderArray[i].next(0);        }        numClientsPerHost[curHostForEachClient[i].getPort() - 1235]++;        hostProviderArray[i].onConnected();    }    for (int i = 0; i < 8; i++) {        assertTrue(numClientsPerHost[i] <= upperboundCPS(numClients, 8));        assertTrue(numClientsPerHost[i] >= lowerboundCPS(numClients, 8));    }}
testReconfigDuringReconfigMode
public void zookeeper_f6580_0() throws UnknownHostException
{        boolean disconnectRequired;    StaticHostProvider[] hostProviderArray = new StaticHostProvider[numClients];    InetSocketAddress[] curHostForEachClient = new InetSocketAddress[numClients];    int[] numClientsPerHost = new int[9];        for (int i = 0; i < numClients; i++) {        hostProviderArray[i] = getHostProvider((byte) 9);        curHostForEachClient[i] = hostProviderArray[i].next(0);    }        Collection<InetSocketAddress> newList = getServerAddresses((byte) 7);    for (int i = 0; i < numClients; i++) {                hostProviderArray[i].updateServerList(newList, curHostForEachClient[i]);    }            newList = getServerAddresses((byte) 9);    for (int i = 0; i < numClients; i++) {        InetSocketAddress myServer = (i < (numClients / 2)) ? null : curHostForEachClient[i];                                        disconnectRequired = hostProviderArray[i].updateServerList(newList, myServer);        if (disconnectRequired) {            curHostForEachClient[i] = hostProviderArray[i].next(0);        } else {                                    curHostForEachClient[i] = hostProviderArray[i].getServerAtCurrentIndex();        }        numClientsPerHost[curHostForEachClient[i].getPort() - 1235]++;        hostProviderArray[i].onConnected();    }    for (int i = 0; i < 9; i++) {        assertTrue(numClientsPerHost[i] <= upperboundCPS(numClients, 9));        assertTrue(numClientsPerHost[i] >= lowerboundCPS(numClients, 9));    }}
getHostProvider
private StaticHostProvider zookeeper_f6581_0(byte size)
{    return new StaticHostProvider(getServerAddresses(size), r.nextLong());}
getServerAddresses
private Collection<InetSocketAddress> zookeeper_f6582_0(byte size)
{    ArrayList<InetSocketAddress> list = new ArrayList<InetSocketAddress>(size);    while (size > 0) {        try {            list.add(new InetSocketAddress(InetAddress.getByAddress(new byte[] { 10, 10, 10, size }), 1234 + size));        } catch (UnknownHostException e) {                        e.printStackTrace();        }        --size;    }    return list;}
testUpdateServerList_UnresolvedHostnames_NoDisconnection1
public void zookeeper_f6583_0()
{            HostProvider hostProvider = getHostProviderWithUnresolvedHostnames(4);        Collection<InetSocketAddress> newList = getUnresolvedHostnames(3);    InetSocketAddress myServer = InetSocketAddress.createUnresolved("testhost-3.testdomain.com", 1237);        boolean disconnectRequired = hostProvider.updateServerList(newList, myServer);        assertFalse(disconnectRequired);    hostProvider.onConnected();}
testUpdateServerList_UnresolvedHostnames_NoDisconnection2
public void zookeeper_f6584_0()
{            HostProvider hostProvider = getHostProviderWithUnresolvedHostnames(3);        Collection<InetSocketAddress> newList = getUnresolvedHostnames(3);    InetSocketAddress myServer = InetSocketAddress.createUnresolved("testhost-3.testdomain.com", 1237);        boolean disconnectRequired = hostProvider.updateServerList(newList, myServer);        assertFalse(disconnectRequired);    hostProvider.onConnected();}
testUpdateServerList_UnresolvedHostnames_Disconnection1
public void zookeeper_f6585_0()
{            HostProvider hostProvider = getHostProviderWithUnresolvedHostnames(3);        Collection<InetSocketAddress> newList = getUnresolvedHostnames(2);    InetSocketAddress myServer = InetSocketAddress.createUnresolved("testhost-3.testdomain.com", 1237);        boolean disconnectRequired = hostProvider.updateServerList(newList, myServer);        assertTrue(disconnectRequired);    hostProvider.onConnected();}
testUpdateServerList_UnresolvedHostnames_Disconnection2
public void zookeeper_f6586_0()
{            HostProvider hostProvider = getHostProviderWithUnresolvedHostnames(3);        Collection<InetSocketAddress> newList = getUnresolvedHostnames(3);    InetSocketAddress myServer = InetSocketAddress.createUnresolved("testhost-4.testdomain.com", 1237);        boolean disconnectRequired = hostProvider.updateServerList(newList, myServer);        assertTrue(disconnectRequired);    hostProvider.onConnected();}
testUpdateServerList_ResolvedWithUnResolvedAddress_ForceDisconnect
public void zookeeper_f6587_0()
{            List<InetSocketAddress> addresses = Collections.singletonList(InetSocketAddress.createUnresolved("testhost-1.resolvable.zk", 1235));    HostProvider hostProvider = new StaticHostProvider(addresses, new TestResolver());    InetSocketAddress currentHost = hostProvider.next(100);    assertThat("CurrentHost is which the client is currently connecting to, it should be resolved", currentHost.isUnresolved(), is(false));        InetSocketAddress replaceHost = InetSocketAddress.createUnresolved("testhost-1.resolvable.zk", 1235);    assertThat("Replace host must be unresolved in this test case", replaceHost.isUnresolved(), is(true));    boolean disconnect = hostProvider.updateServerList(new ArrayList<>(Collections.singletonList(replaceHost)), currentHost);        assertThat(disconnect, is(false));}
testUpdateServerList_ResolvedWithResolvedAddress_NoDisconnect
public void zookeeper_f6588_0() throws UnknownHostException
{            List<InetSocketAddress> addresses = Collections.singletonList(InetSocketAddress.createUnresolved("testhost-1.resolvable.zk", 1235));    HostProvider hostProvider = new StaticHostProvider(addresses, new TestResolver());    InetSocketAddress currentHost = hostProvider.next(100);    assertThat("CurrentHost is which the client is currently connecting to, it should be resolved", currentHost.isUnresolved(), is(false));        InetSocketAddress replaceHost = new InetSocketAddress(InetAddress.getByAddress(currentHost.getHostString(), currentHost.getAddress().getAddress()), currentHost.getPort());    assertThat("Replace host must be resolved in this test case", replaceHost.isUnresolved(), is(false));    boolean disconnect = hostProvider.updateServerList(new ArrayList<>(Collections.singletonList(replaceHost)), currentHost);        assertThat(disconnect, equalTo(false));}
testUpdateServerList_UnResolvedWithUnResolvedAddress_ForceDisconnect
public void zookeeper_f6589_0()
{            List<InetSocketAddress> addresses = Collections.singletonList(InetSocketAddress.createUnresolved("testhost-1.zookeepertest.zk", 1235));    HostProvider hostProvider = new StaticHostProvider(addresses, new TestResolver());    InetSocketAddress currentHost = hostProvider.next(100);    assertThat("CurrentHost is not resolvable in this test case", currentHost.isUnresolved(), is(true));        InetSocketAddress replaceHost = InetSocketAddress.createUnresolved("testhost-1.resolvable.zk", 1235);    assertThat("Replace host must be unresolved in this test case", replaceHost.isUnresolved(), is(true));    boolean disconnect = hostProvider.updateServerList(new ArrayList<>(Collections.singletonList(replaceHost)), currentHost);        assertThat(disconnect, is(true));}
testUpdateServerList_UnResolvedWithResolvedAddress_ForceDisconnect
public void zookeeper_f6590_0() throws UnknownHostException
{            List<InetSocketAddress> addresses = Collections.singletonList(InetSocketAddress.createUnresolved("testhost-1.zookeepertest.zk", 1235));    HostProvider hostProvider = new StaticHostProvider(addresses, new TestResolver());    InetSocketAddress currentHost = hostProvider.next(100);    assertThat("CurrentHost not resolvable in this test case", currentHost.isUnresolved(), is(true));        byte[] addr = new byte[] { 10, 0, 0, 1 };    InetSocketAddress replaceHost = new InetSocketAddress(InetAddress.getByAddress(currentHost.getHostString(), addr), currentHost.getPort());    assertThat("Replace host must be resolved in this test case", replaceHost.isUnresolved(), is(false));    boolean disconnect = hostProvider.updateServerList(new ArrayList<>(Collections.singletonList(replaceHost)), currentHost);        assertThat(disconnect, equalTo(false));}
getAllByName
public InetAddress[] zookeeper_f6591_0(String name) throws UnknownHostException
{    if (name.contains("resolvable")) {        byte[] addr = new byte[] { 10, 0, 0, (byte) (counter++ % 10) };        return new InetAddress[] { InetAddress.getByAddress(name, addr) };    }    throw new UnknownHostException();}
lowerboundCPS
private double zookeeper_f6592_0(int numClients, int numServers)
{    return (1 - slackPercent / 100.0) * numClients / numServers;}
upperboundCPS
private double zookeeper_f6593_0(int numClients, int numServers)
{    return (1 + slackPercent / 100.0) * numClients / numServers;}
testLiteralIPNoReverseNS
public void zookeeper_f6594_0()
{    byte size = 30;    HostProvider hostProvider = getHostProviderUnresolved(size);    for (int i = 0; i < size; i++) {        InetSocketAddress next = hostProvider.next(0);        assertThat(next, instanceOf(InetSocketAddress.class));        assertFalse(next.isUnresolved());        assertTrue(next.toString().startsWith("/"));                String hostname = next.getHostString();                assertEquals(next.getAddress().getHostAddress(), hostname);    }}
testReResolvingSingle
public void zookeeper_f6595_0() throws UnknownHostException
{        byte size = 1;    ArrayList<InetSocketAddress> list = new ArrayList<InetSocketAddress>(size);        list.add(InetSocketAddress.createUnresolved("issues.apache.org", 1234));    final InetAddress issuesApacheOrg = mock(InetAddress.class);    when(issuesApacheOrg.getHostAddress()).thenReturn("192.168.1.1");    when(issuesApacheOrg.toString()).thenReturn("issues.apache.org");    when(issuesApacheOrg.getHostName()).thenReturn("issues.apache.org");    StaticHostProvider.Resolver resolver = new StaticHostProvider.Resolver() {        @Override        public InetAddress[] getAllByName(String name) {            return new InetAddress[] { issuesApacheOrg };        }    };    StaticHostProvider.Resolver spyResolver = spy(resolver);        StaticHostProvider hostProvider = new StaticHostProvider(list, spyResolver);    for (int i = 0; i < 10; i++) {        InetSocketAddress next = hostProvider.next(0);        assertEquals(issuesApacheOrg, next.getAddress());    }                verify(spyResolver, times(10)).getAllByName("issues.apache.org");}
getAllByName
public InetAddress[] zookeeper_f6596_0(String name)
{    return new InetAddress[] { issuesApacheOrg };}
testReResolvingMultiple
public void zookeeper_f6597_0() throws UnknownHostException
{        byte size = 1;    ArrayList<InetSocketAddress> list = new ArrayList<InetSocketAddress>(size);        list.add(InetSocketAddress.createUnresolved("www.apache.org", 1234));    final InetAddress apacheOrg1 = mock(InetAddress.class);    when(apacheOrg1.getHostAddress()).thenReturn("192.168.1.1");    when(apacheOrg1.toString()).thenReturn("www.apache.org");    when(apacheOrg1.getHostName()).thenReturn("www.apache.org");    final InetAddress apacheOrg2 = mock(InetAddress.class);    when(apacheOrg2.getHostAddress()).thenReturn("192.168.1.2");    when(apacheOrg2.toString()).thenReturn("www.apache.org");    when(apacheOrg2.getHostName()).thenReturn("www.apache.org");    final List<InetAddress> resolvedAddresses = new ArrayList<InetAddress>();    resolvedAddresses.add(apacheOrg1);    resolvedAddresses.add(apacheOrg2);    StaticHostProvider.Resolver resolver = new StaticHostProvider.Resolver() {        @Override        public InetAddress[] getAllByName(String name) {            return resolvedAddresses.toArray(new InetAddress[resolvedAddresses.size()]);        }    };    StaticHostProvider.Resolver spyResolver = spy(resolver);        StaticHostProvider hostProvider = new StaticHostProvider(list, spyResolver);        assertEquals(1, hostProvider.size());    for (int i = 0; i < 10; i++) {        InetSocketAddress next = hostProvider.next(0);        assertThat("Bad IP address returned", next.getAddress().getHostAddress(), anyOf(equalTo(apacheOrg1.getHostAddress()), equalTo(apacheOrg2.getHostAddress())));                assertEquals(1, hostProvider.size());    }            verify(spyResolver, times(10)).getAllByName("www.apache.org");}
getAllByName
public InetAddress[] zookeeper_f6598_0(String name)
{    return resolvedAddresses.toArray(new InetAddress[resolvedAddresses.size()]);}
testReResolveMultipleOneFailing
public void zookeeper_f6599_0() throws UnknownHostException
{        final List<InetSocketAddress> list = new ArrayList<InetSocketAddress>();    list.add(InetSocketAddress.createUnresolved("www.apache.org", 1234));    final List<String> ipList = new ArrayList<String>();    final List<InetAddress> resolvedAddresses = new ArrayList<InetAddress>();    for (int i = 0; i < 3; i++) {        ipList.add(String.format("192.168.1.%d", i + 1));        final InetAddress apacheOrg = mock(InetAddress.class);        when(apacheOrg.getHostAddress()).thenReturn(String.format("192.168.1.%d", i + 1));        when(apacheOrg.toString()).thenReturn(String.format("192.168.1.%d", i + 1));        when(apacheOrg.getHostName()).thenReturn("www.apache.org");        resolvedAddresses.add(apacheOrg);    }    StaticHostProvider.Resolver resolver = new StaticHostProvider.Resolver() {        @Override        public InetAddress[] getAllByName(String name) {            return resolvedAddresses.toArray(new InetAddress[resolvedAddresses.size()]);        }    };    StaticHostProvider.Resolver spyResolver = spy(resolver);    StaticHostProvider hostProvider = new StaticHostProvider(list, spyResolver);        InetSocketAddress resolvedFirst = hostProvider.next(0);    assertFalse("HostProvider should return resolved addresses", resolvedFirst.isUnresolved());    assertThat("Bad IP address returned", ipList, hasItems(resolvedFirst.getAddress().getHostAddress()));        hostProvider.onConnected();    InetSocketAddress resolvedSecond = hostProvider.next(0);    assertFalse("HostProvider should return resolved addresses", resolvedSecond.isUnresolved());    assertThat("Bad IP address returned", ipList, hasItems(resolvedSecond.getAddress().getHostAddress()));            InetSocketAddress resolvedThird = hostProvider.next(0);    assertFalse("HostProvider should return resolved addresses", resolvedThird.isUnresolved());    assertThat("Bad IP address returned", ipList, hasItems(resolvedThird.getAddress().getHostAddress()));        verify(spyResolver, times(3)).getAllByName("www.apache.org");}
getAllByName
public InetAddress[] zookeeper_f6600_0(String name)
{    return resolvedAddresses.toArray(new InetAddress[resolvedAddresses.size()]);}
testEmptyResolution
public void zookeeper_f6601_0() throws UnknownHostException
{        final List<InetSocketAddress> list = new ArrayList<InetSocketAddress>();    list.add(InetSocketAddress.createUnresolved("www.apache.org", 1234));    list.add(InetSocketAddress.createUnresolved("www.google.com", 1234));    final List<InetAddress> resolvedAddresses = new ArrayList<InetAddress>();    final InetAddress apacheOrg1 = mock(InetAddress.class);    when(apacheOrg1.getHostAddress()).thenReturn("192.168.1.1");    when(apacheOrg1.toString()).thenReturn("www.apache.org");    when(apacheOrg1.getHostName()).thenReturn("www.apache.org");    resolvedAddresses.add(apacheOrg1);    StaticHostProvider.Resolver resolver = new StaticHostProvider.Resolver() {        @Override        public InetAddress[] getAllByName(String name) {            if ("www.apache.org".equalsIgnoreCase(name)) {                return resolvedAddresses.toArray(new InetAddress[resolvedAddresses.size()]);            } else {                return new InetAddress[0];            }        }    };    StaticHostProvider.Resolver spyResolver = spy(resolver);    StaticHostProvider hostProvider = new StaticHostProvider(list, spyResolver);        for (int i = 0; i < 10; i++) {        InetSocketAddress resolved = hostProvider.next(0);        hostProvider.onConnected();        if (resolved.getHostName().equals("www.google.com")) {            assertTrue("HostProvider should return unresolved address if host is unresolvable", resolved.isUnresolved());        } else {            assertFalse("HostProvider should return resolved addresses", resolved.isUnresolved());            assertEquals("192.168.1.1", resolved.getAddress().getHostAddress());        }    }    verify(spyResolver, times(5)).getAllByName("www.apache.org");    verify(spyResolver, times(5)).getAllByName("www.google.com");}
getAllByName
public InetAddress[] zookeeper_f6602_0(String name)
{    if ("www.apache.org".equalsIgnoreCase(name)) {        return resolvedAddresses.toArray(new InetAddress[resolvedAddresses.size()]);    } else {        return new InetAddress[0];    }}
testReResolvingLocalhost
public void zookeeper_f6603_0()
{    byte size = 2;    ArrayList<InetSocketAddress> list = new ArrayList<InetSocketAddress>(size);        list.add(InetSocketAddress.createUnresolved("localhost", 1234));    list.add(InetSocketAddress.createUnresolved("localhost", 1235));    StaticHostProvider hostProvider = new StaticHostProvider(list);    int sizeBefore = hostProvider.size();    InetSocketAddress next = hostProvider.next(0);    next = hostProvider.next(0);    assertTrue("Different number of addresses in the list: " + hostProvider.size() + " (after), " + sizeBefore + " (before)", hostProvider.size() == sizeBefore);}
getHostProviderUnresolved
private StaticHostProvider zookeeper_f6604_0(byte size)
{    return new StaticHostProvider(getUnresolvedServerAddresses(size), r.nextLong());}
getUnresolvedServerAddresses
private Collection<InetSocketAddress> zookeeper_f6605_0(byte size)
{    ArrayList<InetSocketAddress> list = new ArrayList<InetSocketAddress>(size);    while (size > 0) {        list.add(InetSocketAddress.createUnresolved("10.10.10." + size, 1234 + size));        --size;    }    return list;}
getHostProviderWithUnresolvedHostnames
private StaticHostProvider zookeeper_f6606_0(int size)
{    return new StaticHostProvider(getUnresolvedHostnames(size), r.nextLong());}
getUnresolvedHostnames
private Collection<InetSocketAddress> zookeeper_f6607_0(int size)
{    ArrayList<InetSocketAddress> list = new ArrayList<>(size);    while (size > 0) {        list.add(InetSocketAddress.createUnresolved(String.format("testhost-%d.testdomain.com", size), 1234 + size));        --size;    }    System.out.println(Arrays.toString(list.toArray()));    return list;}
setUp
public void zookeeper_f6608_0() throws Exception
{    super.setUp();    zk = createClient();}
tearDown
public void zookeeper_f6609_0() throws Exception
{    super.tearDown();    zk.close();}
newStat
private Stat zookeeper_f6610_0()
{    Stat stat = new Stat();    stat.setAversion(100);    stat.setCtime(100);    stat.setCversion(100);    stat.setCzxid(100);    stat.setDataLength(100);    stat.setEphemeralOwner(100);    stat.setMtime(100);    stat.setMzxid(100);    stat.setNumChildren(100);    stat.setPzxid(100);    stat.setVersion(100);    return stat;}
testBasic
public void zookeeper_f6611_0() throws IOException, KeeperException, InterruptedException
{    String name = "/foo";    zk.create(name, name.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    Stat stat;    stat = newStat();    zk.getData(name, false, stat);    assertEquals(stat.getCzxid(), stat.getMzxid());    assertEquals(stat.getCzxid(), stat.getPzxid());    assertEquals(stat.getCtime(), stat.getMtime());    assertEquals(0, stat.getCversion());    assertEquals(0, stat.getVersion());    assertEquals(0, stat.getAversion());    assertEquals(0, stat.getEphemeralOwner());    assertEquals(name.length(), stat.getDataLength());    assertEquals(0, stat.getNumChildren());}
testChild
public void zookeeper_f6612_0() throws IOException, KeeperException, InterruptedException
{    String name = "/foo";    zk.create(name, name.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    String childname = name + "/bar";    zk.create(childname, childname.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);    Stat stat;    stat = newStat();    zk.getData(name, false, stat);    assertEquals(stat.getCzxid(), stat.getMzxid());    assertEquals(stat.getCzxid() + 1, stat.getPzxid());    assertEquals(stat.getCtime(), stat.getMtime());    assertEquals(1, stat.getCversion());    assertEquals(0, stat.getVersion());    assertEquals(0, stat.getAversion());    assertEquals(0, stat.getEphemeralOwner());    assertEquals(name.length(), stat.getDataLength());    assertEquals(1, stat.getNumChildren());    stat = newStat();    zk.getData(childname, false, stat);    assertEquals(stat.getCzxid(), stat.getMzxid());    assertEquals(stat.getCzxid(), stat.getPzxid());    assertEquals(stat.getCtime(), stat.getMtime());    assertEquals(0, stat.getCversion());    assertEquals(0, stat.getVersion());    assertEquals(0, stat.getAversion());    assertEquals(zk.getSessionId(), stat.getEphemeralOwner());    assertEquals(childname.length(), stat.getDataLength());    assertEquals(0, stat.getNumChildren());}
testChildren
public void zookeeper_f6613_0() throws IOException, KeeperException, InterruptedException
{    String name = "/foo";    zk.create(name, name.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    for (int i = 0; i < 10; i++) {        String childname = name + "/bar" + i;        zk.create(childname, childname.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);        Stat stat;        stat = newStat();        zk.getData(name, false, stat);        assertEquals(stat.getCzxid(), stat.getMzxid());        assertEquals(stat.getCzxid() + i + 1, stat.getPzxid());        assertEquals(stat.getCtime(), stat.getMtime());        assertEquals(i + 1, stat.getCversion());        assertEquals(0, stat.getVersion());        assertEquals(0, stat.getAversion());        assertEquals(0, stat.getEphemeralOwner());        assertEquals(name.length(), stat.getDataLength());        assertEquals(i + 1, stat.getNumChildren());    }}
testDataSizeChange
public void zookeeper_f6614_0() throws IOException, KeeperException, InterruptedException
{    String name = "/foo";    zk.create(name, name.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    Stat stat;    stat = newStat();    zk.getData(name, false, stat);    assertEquals(stat.getCzxid(), stat.getMzxid());    assertEquals(stat.getCzxid(), stat.getPzxid());    assertEquals(stat.getCtime(), stat.getMtime());    assertEquals(0, stat.getCversion());    assertEquals(0, stat.getVersion());    assertEquals(0, stat.getAversion());    assertEquals(0, stat.getEphemeralOwner());    assertEquals(name.length(), stat.getDataLength());    assertEquals(0, stat.getNumChildren());    zk.setData(name, (name + name).getBytes(), -1);    stat = newStat();    zk.getData(name, false, stat);    assertNotSame(stat.getCzxid(), stat.getMzxid());    assertEquals(stat.getCzxid(), stat.getPzxid());    assertNotSame(stat.getCtime(), stat.getMtime());    assertEquals(0, stat.getCversion());    assertEquals(1, stat.getVersion());    assertEquals(0, stat.getAversion());    assertEquals(0, stat.getEphemeralOwner());    assertEquals(name.length() * 2, stat.getDataLength());    assertEquals(0, stat.getNumChildren());}
testStrings
public void zookeeper_f6615_0()
{    String s1 = "   a  ,   b  , ";    assertEquals("[a, b]", StringUtils.split(s1, ",").toString());    String s2 = "";    assertEquals(0, StringUtils.split(s2, ",").size());    String s3 = "1, , 2";    assertEquals("[1, 2]", StringUtils.split(s3, ",").toString());}
testSync
public voidf6616_1) throws Exception
{    try {                opsCount = new CountDownLatch(limit);        ZooKeeper zk = createClient();                for (int i = 0; i < 50; i++) {            zk.create("/test" + i, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, (StringCallback) this, results);        }        for (int i = 50; i < 100; i++) {            zk.create("/test" + i, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, (Create2Callback) this, results);        }        zk.sync("/test", this, results);        for (int i = 0; i < 100; i++) {            zk.delete("/test" + i, 0, this, results);        }        for (int i = 0; i < 100; i++) {            zk.getChildren("/", DummyWatcher.INSTANCE, (ChildrenCallback) this, results);        }        for (int i = 0; i < 100; i++) {            zk.getChildren("/", DummyWatcher.INSTANCE, (Children2Callback) this, results);        }                if (!opsCount.await(10000, TimeUnit.MILLISECONDS)) {            fail("Haven't received all confirmations" + opsCount.getCount());        }        for (int i = 0; i < limit; i++) {            assertEquals(0, (int) results.get(i));        }    } catch (IOException e) {        System.out.println(e.toString());    }}
processResult
public void zookeeper_f6617_0(int rc, String path, Object ctx, List<String> children)
{    ((List<Integer>) ctx).add(rc);    opsCount.countDown();}
processResult
public void zookeeper_f6618_0(int rc, String path, Object ctx, List<String> children, Stat stat)
{    ((List<Integer>) ctx).add(rc);    opsCount.countDown();}
processResult
public void zookeeper_f6619_0(int rc, String path, Object ctx, String name)
{    ((List<Integer>) ctx).add(rc);    opsCount.countDown();}
processResult
public void zookeeper_f6620_0(int rc, String path, Object ctx)
{    ((List<Integer>) ctx).add(rc);    opsCount.countDown();}
processResult
public void zookeeper_f6621_0(int rc, String path, Object ctx, String name, Stat stat)
{    ((List<Integer>) ctx).add(rc);    opsCount.countDown();}
getInstance
public static TestByteBufAllocator zookeeper_f6622_0()
{    TestByteBufAllocator result = INSTANCE.get();    if (result == null) {        ResourceLeakDetector.Level oldLevel = ResourceLeakDetector.getLevel();        ResourceLeakDetector.setLevel(ResourceLeakDetector.Level.PARANOID);        INSTANCE.compareAndSet(null, new TestByteBufAllocator(oldLevel));        result = INSTANCE.get();    }    return result;}
checkForLeaks
public static void zookeeper_f6623_0()
{    TestByteBufAllocator result = INSTANCE.getAndSet(null);    if (result != null) {        result.checkInstanceForLeaks();    }}
newHeapBuffer
protected ByteBuf zookeeper_f6624_0(int initialCapacity, int maxCapacity)
{    return track(super.newHeapBuffer(initialCapacity, maxCapacity));}
newDirectBuffer
protected ByteBuf zookeeper_f6625_0(int initialCapacity, int maxCapacity)
{    return track(super.newDirectBuffer(initialCapacity, maxCapacity));}
compositeHeapBuffer
public CompositeByteBuf zookeeper_f6626_0(int maxNumComponents)
{    return track(super.compositeHeapBuffer(maxNumComponents));}
compositeDirectBuffer
public CompositeByteBuf zookeeper_f6627_0(int maxNumComponents)
{    return track(super.compositeDirectBuffer(maxNumComponents));}
track
private synchronized CompositeByteBuf zookeeper_f6628_0(CompositeByteBuf byteBuf)
{    trackedBuffers.add(Objects.requireNonNull(byteBuf));    return byteBuf;}
track
private synchronized ByteBuf zookeeper_f6629_0(ByteBuf byteBuf)
{    trackedBuffers.add(Objects.requireNonNull(byteBuf));    return byteBuf;}
checkInstanceForLeaks
private void zookeeper_f6630_0()
{    try {        long referencedBuffersCount = 0;        synchronized (this) {            referencedBuffersCount = trackedBuffers.stream().filter(byteBuf -> byteBuf.refCnt() > 0).count();                        trackedBuffers.clear();        }                if (referencedBuffersCount > 0) {                                                System.gc();            throw new AssertionError("Found a netty ByteBuf leak!");        }    } finally {        ResourceLeakDetector.setLevel(oldLevel);    }}
setTestAllocator
public static void zookeeper_f6631_0(ByteBufAllocator allocator) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException
{    Method m1 = NettyServerCnxnFactory.class.getDeclaredMethod("setTestAllocator", ByteBufAllocator.class);    m1.setAccessible(true);    m1.invoke(null, allocator);    Method m2 = ClientCnxnSocketNetty.class.getDeclaredMethod("setTestAllocator", ByteBufAllocator.class);    m2.setAccessible(true);    m2.invoke(null, allocator);}
clearTestAllocator
public static void zookeeper_f6632_0() throws NoSuchMethodException, IllegalAccessException, InvocationTargetException
{    Method m1 = NettyServerCnxnFactory.class.getDeclaredMethod("clearTestAllocator");    m1.setAccessible(true);    m1.invoke(null);    Method m2 = ClientCnxnSocketNetty.class.getDeclaredMethod("clearTestAllocator");    m2.setAccessible(true);    m2.invoke(null);}
main
public static void zookeeper_f6633_0(String[] args)
{    long startTime = Time.currentElapsedTime();    ZooKeeper zk = null;    try {        zk = ClientBase.createZKClient(args[0], 10000);    } catch (Exception e1) {        e1.printStackTrace();        throw new RuntimeException(e1);    }    for (int i = 0; i < REPS; i++) {        try {            String name = zk.create("/testFile-", new byte[16], Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);            zk.delete(name, -1, new TestHammer(), null);        } catch (Exception e) {            i--;            e.printStackTrace();        }    }    System.out.println("creates/sec=" + (REPS * 1000 / (Time.currentElapsedTime() - startTime)));}
processResult
public void zookeeper_f6634_0(int rc, String path, Object ctx)
{}
deleteFileRecursively
public static boolean zookeeper_f6635_0(File file, final boolean failOnError)
{    if (file != null) {        if (file.isDirectory()) {            File[] files = file.listFiles();            int size = files.length;            for (int i = 0; i < size; i++) {                File f = files[i];                boolean deleted = deleteFileRecursively(files[i], failOnError);                if (!deleted && failOnError) {                    fail("file '" + f.getAbsolutePath() + "' deletion failed");                }            }        }        return file.delete();    }    return true;}
deleteFileRecursively
public static boolean zookeeper_f6636_0(File file)
{    return deleteFileRecursively(file, false);}
setUp
public void zookeeper_f6637_0() throws IOException
{    dataDir1 = ClientBase.createTmpDir();    dataDir2 = ClientBase.createTmpDir();    dataDir3 = ClientBase.createTmpDir();}
tearDown
public void zookeeper_f6638_0()
{    ClientBase.recursiveDelete(dataDir1);    ClientBase.recursiveDelete(dataDir2);    ClientBase.recursiveDelete(dataDir3);}
testTruncationStreamReset
public void zookeeper_f6639_0() throws Exception
{    File tmpdir = ClientBase.createTmpDir();    FileTxnSnapLog snaplog = new FileTxnSnapLog(tmpdir, tmpdir);    ZKDatabase zkdb = new ZKDatabase(snaplog);            snaplog.save(zkdb.getDataTree(), zkdb.getSessionWithTimeOuts(), false);    for (int i = 1; i <= 100; i++) {        append(zkdb, i);    }    zkdb.truncateLog(1);    append(zkdb, 200);    zkdb.close();            FileTxnLog txnlog = new FileTxnLog(new File(tmpdir, "version-2"));    TxnIterator iter = txnlog.read(1);    TxnHeader hdr = iter.getHeader();    Record txn = iter.getTxn();    assertEquals(1, hdr.getZxid());    assertTrue(txn instanceof SetDataTxn);    iter.next();    hdr = iter.getHeader();    txn = iter.getTxn();    assertEquals(200, hdr.getZxid());    assertTrue(txn instanceof SetDataTxn);    iter.close();    ClientBase.recursiveDelete(tmpdir);}
testTruncationNullLog
public voidf6640_1) throws Exception
{    File tmpdir = ClientBase.createTmpDir();    FileTxnSnapLog snaplog = new FileTxnSnapLog(tmpdir, tmpdir);    ZKDatabase zkdb = new ZKDatabase(snaplog);    for (int i = 1; i <= 100; i++) {        append(zkdb, i);    }    zkdb.close();    File[] logs = snaplog.getDataDir().listFiles();    for (int i = 0; i < logs.length; i++) {                assertTrue("Failed to delete log file: " + logs[i].getName(), logs[i].delete());    }    try {        zkdb.truncateLog(1);        assertTrue("Should not get here", false);    } catch (IOException e) {        assertTrue("Should have received an IOException", true);    } catch (NullPointerException npe) {        fail("This should not throw NPE!");    }    ClientBase.recursiveDelete(tmpdir);}
append
private void zookeeper_f6641_0(ZKDatabase zkdb, int i) throws IOException
{    TxnHeader hdr = new TxnHeader(1, 1, i, 1, ZooDefs.OpCode.setData);    Record txn = new SetDataTxn("/foo" + i, new byte[0], 1);    Request req = new Request(0, 0, 0, hdr, txn, 0);    zkdb.append(req);    zkdb.commit();}
testTruncate
public voidf6642_1) throws Exception
{        String hostPort = "127.0.0.1:" + PortAssignment.unique();    int maxCnxns = 100;    ServerCnxnFactory factory = ClientBase.createNewServerInstance(null, hostPort, maxCnxns);    ClientBase.startServerInstance(dataDir1, factory, hostPort, 1);    ClientBase.shutdownServerInstance(factory, hostPort);        File origfile = new File(new File(dataDir1, "version-2"), "snapshot.0");    File newfile = new File(new File(dataDir1, "version-2"), "snapshot.100000000");    origfile.renameTo(newfile);    factory = ClientBase.createNewServerInstance(null, hostPort, maxCnxns);    ClientBase.startServerInstance(dataDir1, factory, hostPort, 1);    ZooKeeper zk = ClientBase.createZKClient(hostPort, 15000);    for (int i = 0; i < 50; i++) {        zk.create("/" + i, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    }    zk.close();    ZKDatabase zkDb;    {        ZooKeeperServer zs = factory.getZooKeeperServer();        zkDb = zs.getZKDatabase();    }    factory.shutdown();    try {        zkDb.close();    } catch (IOException ie) {            }    int tickTime = 2000;    int initLimit = 3;    int syncLimit = 3;    int connectToLearnerMasterLimit = 3;    int port1 = PortAssignment.unique();    int port2 = PortAssignment.unique();    int port3 = PortAssignment.unique();        Map<Long, QuorumServer> peers = new HashMap<Long, QuorumServer>();    peers.put(Long.valueOf(1), new QuorumServer(1, new InetSocketAddress("127.0.0.1", PortAssignment.unique()), new InetSocketAddress("127.0.0.1", PortAssignment.unique()), new InetSocketAddress("127.0.0.1", port1)));    peers.put(Long.valueOf(2), new QuorumServer(2, new InetSocketAddress("127.0.0.1", PortAssignment.unique()), new InetSocketAddress("127.0.0.1", PortAssignment.unique()), new InetSocketAddress("127.0.0.1", port2)));    peers.put(Long.valueOf(3), new QuorumServer(3, new InetSocketAddress("127.0.0.1", PortAssignment.unique()), new InetSocketAddress("127.0.0.1", PortAssignment.unique()), new InetSocketAddress("127.0.0.1", port3)));    QuorumPeer s2 = new QuorumPeer(peers, dataDir2, dataDir2, port2, 3, 2, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);    s2.start();    QuorumPeer s3 = new QuorumPeer(peers, dataDir3, dataDir3, port3, 3, 3, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);    s3.start();    zk = ClientBase.createZKClient("127.0.0.1:" + port2, 15000);    for (int i = 0; i < 10; i++) {        zk.create("/" + i, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    }    zk.close();    final ZooKeeper zk2 = ClientBase.createZKClient("127.0.0.1:" + port2, 15000);    zk2.getData("/9", false, new Stat());    try {        zk2.getData("/10", false, new Stat());        fail("Should have gotten an error");    } catch (KeeperException.NoNodeException e) {        }    QuorumPeer s1 = new QuorumPeer(peers, dataDir1, dataDir1, port1, 3, 1, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit);    s1.start();    ZooKeeper zk1 = ClientBase.createZKClient("127.0.0.1:" + port1, 15000);    zk1.getData("/9", false, new Stat());    try {                                                        zk1.getData("/12", false, new Stat());        fail("Should have gotten an error");    } catch (KeeperException.NoNodeException e) {        }    zk1.close();    QuorumBase.shutdown(s1);    QuorumBase.shutdown(s2);    QuorumBase.shutdown(s3);}
testCreatingWatchedEvent
public void zookeeper_f6643_0()
{            EnumSet<EventType> allTypes = EnumSet.allOf(EventType.class);    EnumSet<KeeperState> allStates = EnumSet.allOf(KeeperState.class);    WatchedEvent we;    for (EventType et : allTypes) {        for (KeeperState ks : allStates) {            we = new WatchedEvent(et, ks, "blah");            assertEquals(et, we.getType());            assertEquals(ks, we.getState());            assertEquals("blah", we.getPath());        }    }}
testCreatingWatchedEventFromWrapper
public void zookeeper_f6644_0()
{        EnumSet<EventType> allTypes = EnumSet.allOf(EventType.class);    EnumSet<KeeperState> allStates = EnumSet.allOf(KeeperState.class);    WatchedEvent we;    WatcherEvent wep;    for (EventType et : allTypes) {        for (KeeperState ks : allStates) {            wep = new WatcherEvent(et.getIntValue(), ks.getIntValue(), "blah");            we = new WatchedEvent(wep);            assertEquals(et, we.getType());            assertEquals(ks, we.getState());            assertEquals("blah", we.getPath());        }    }}
testCreatingWatchedEventFromInvalidWrapper
public void zookeeper_f6645_0()
{    try {        WatcherEvent wep = new WatcherEvent(-2342, -252352, "foo");        new WatchedEvent(wep);        fail("Was able to create WatchedEvent from bad wrapper");    } catch (RuntimeException re) {        }}
testConvertingToEventWrapper
public void zookeeper_f6646_0()
{    WatchedEvent we = new WatchedEvent(EventType.NodeCreated, KeeperState.Expired, "blah");    WatcherEvent wew = we.getWrapper();    assertEquals(EventType.NodeCreated.getIntValue(), wew.getType());    assertEquals(KeeperState.Expired.getIntValue(), wew.getState());    assertEquals("blah", wew.getPath());}
process
public void zookeeper_f6647_0(WatchedEvent event)
{    if (event.getState() == KeeperState.SyncConnected) {        if (latch != null) {            latch.countDown();        }    }    if (event.getType() == EventType.None) {        return;    }    try {        events.put(event);    } catch (InterruptedException e) {        assertTrue("interruption unexpected", false);    }}
verify
public void zookeeper_f6648_0(List<EventType> expected) throws InterruptedException
{    WatchedEvent event;    int count = 0;    while (count < expected.size() && (event = events.poll(30, TimeUnit.SECONDS)) != null) {        assertEquals(expected.get(count), event.getType());        count++;    }    assertEquals(expected.size(), count);    events.clear();}
setUp
public void zookeeper_f6649_0() throws Exception
{    super.setUp();    client_latch = new CountDownLatch(1);    client_dwatch = new SimpleWatcher(client_latch);    client = createClient(client_dwatch, client_latch);    lsnr_latch = new CountDownLatch(1);    lsnr_dwatch = new SimpleWatcher(lsnr_latch);    lsnr = createClient(lsnr_dwatch, lsnr_latch);    expected = new ArrayList<EventType>();}
tearDown
public void zookeeper_f6650_0() throws Exception
{    client.close();    lsnr.close();    super.tearDown();}
createClient
protected ZooKeeper zookeeper_f6651_0(Watcher watcher, CountDownLatch latch) throws IOException, InterruptedException
{    ZooKeeper zk = new ZooKeeper(hostPort, CONNECTION_TIMEOUT, watcher);    if (!latch.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS)) {        fail("Unable to connect to server");    }    return zk;}
verify
private void zookeeper_f6652_0() throws InterruptedException
{    lsnr_dwatch.verify(expected);    expected.clear();}
testExistsSync
public void zookeeper_f6653_0() throws IOException, InterruptedException, KeeperException
{    assertNull(lsnr.exists("/foo", true));    assertNull(lsnr.exists("/foo/bar", true));    client.create("/foo", "parent".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    expected.add(EventType.NodeCreated);    client.create("/foo/bar", "child".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    expected.add(EventType.NodeCreated);    verify();    assertNotNull(lsnr.exists("/foo", true));    assertNotNull(lsnr.exists("/foo/bar", true));    try {        assertNull(lsnr.exists("/car", true));        client.setData("/car", "missing".getBytes(), -1);        fail();    } catch (KeeperException e) {        assertEquals(KeeperException.Code.NONODE, e.code());        assertEquals("/car", e.getPath());    }    try {        assertNull(lsnr.exists("/foo/car", true));        client.setData("/foo/car", "missing".getBytes(), -1);        fail();    } catch (KeeperException e) {        assertEquals(KeeperException.Code.NONODE, e.code());        assertEquals("/foo/car", e.getPath());    }    client.setData("/foo", "parent".getBytes(), -1);    expected.add(EventType.NodeDataChanged);    client.setData("/foo/bar", "child".getBytes(), -1);    expected.add(EventType.NodeDataChanged);    verify();    assertNotNull(lsnr.exists("/foo", true));    assertNotNull(lsnr.exists("/foo/bar", true));    client.delete("/foo/bar", -1);    expected.add(EventType.NodeDeleted);    client.delete("/foo", -1);    expected.add(EventType.NodeDeleted);    verify();}
testGetDataSync
public void zookeeper_f6654_0() throws IOException, InterruptedException, KeeperException
{    try {        lsnr.getData("/foo", true, null);        fail();    } catch (KeeperException e) {        assertEquals(KeeperException.Code.NONODE, e.code());        assertEquals("/foo", e.getPath());    }    try {        lsnr.getData("/foo/bar", true, null);        fail();    } catch (KeeperException e) {        assertEquals(KeeperException.Code.NONODE, e.code());        assertEquals("/foo/bar", e.getPath());    }    client.create("/foo", "parent".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    assertNotNull(lsnr.getData("/foo", true, null));    client.create("/foo/bar", "child".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    assertNotNull(lsnr.getData("/foo/bar", true, null));    client.setData("/foo", "parent".getBytes(), -1);    expected.add(EventType.NodeDataChanged);    client.setData("/foo/bar", "child".getBytes(), -1);    expected.add(EventType.NodeDataChanged);    verify();    assertNotNull(lsnr.getData("/foo", true, null));    assertNotNull(lsnr.getData("/foo/bar", true, null));    client.delete("/foo/bar", -1);    expected.add(EventType.NodeDeleted);    client.delete("/foo", -1);    expected.add(EventType.NodeDeleted);    verify();}
testGetChildrenSync
public void zookeeper_f6655_0() throws IOException, InterruptedException, KeeperException
{    try {        lsnr.getChildren("/foo", true);        fail();    } catch (KeeperException e) {        assertEquals(KeeperException.Code.NONODE, e.code());        assertEquals("/foo", e.getPath());    }    try {        lsnr.getChildren("/foo/bar", true);        fail();    } catch (KeeperException e) {        assertEquals(KeeperException.Code.NONODE, e.code());        assertEquals("/foo/bar", e.getPath());    }    client.create("/foo", "parent".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    assertNotNull(lsnr.getChildren("/foo", true));    client.create("/foo/bar", "child".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        expected.add(EventType.NodeChildrenChanged);    assertNotNull(lsnr.getChildren("/foo/bar", true));    client.setData("/foo", "parent".getBytes(), -1);    client.setData("/foo/bar", "child".getBytes(), -1);    assertNotNull(lsnr.exists("/foo", true));    assertNotNull(lsnr.getChildren("/foo", true));    assertNotNull(lsnr.getChildren("/foo/bar", true));    client.delete("/foo/bar", -1);        expected.add(EventType.NodeDeleted);        expected.add(EventType.NodeChildrenChanged);    client.delete("/foo", -1);    expected.add(EventType.NodeDeleted);    verify();}
testExistsSyncWObj
public void zookeeper_f6656_0() throws IOException, InterruptedException, KeeperException
{    SimpleWatcher w1 = new SimpleWatcher(null);    SimpleWatcher w2 = new SimpleWatcher(null);    SimpleWatcher w3 = new SimpleWatcher(null);    SimpleWatcher w4 = new SimpleWatcher(null);    List<EventType> e2 = new ArrayList<EventType>();    assertNull(lsnr.exists("/foo", true));    assertNull(lsnr.exists("/foo", w1));    assertNull(lsnr.exists("/foo/bar", w2));    assertNull(lsnr.exists("/foo/bar", w3));    assertNull(lsnr.exists("/foo/bar", w3));    assertNull(lsnr.exists("/foo/bar", w4));    client.create("/foo", "parent".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    expected.add(EventType.NodeCreated);    client.create("/foo/bar", "child".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    e2.add(EventType.NodeCreated);    lsnr_dwatch.verify(expected);    w1.verify(expected);    w2.verify(e2);    w3.verify(e2);    w4.verify(e2);    expected.clear();    e2.clear();        assertNotNull(lsnr.exists("/foo", w1));    assertNotNull(lsnr.exists("/foo/bar", w2));    assertNotNull(lsnr.exists("/foo/bar", w3));    assertNotNull(lsnr.exists("/foo/bar", w4));    assertNotNull(lsnr.exists("/foo/bar", w4));    client.setData("/foo", "parent".getBytes(), -1);    expected.add(EventType.NodeDataChanged);    client.setData("/foo/bar", "child".getBytes(), -1);    e2.add(EventType.NodeDataChanged);        lsnr_dwatch.verify(new ArrayList<EventType>());    w1.verify(expected);    w2.verify(e2);    w3.verify(e2);    w4.verify(e2);    expected.clear();    e2.clear();    assertNotNull(lsnr.exists("/foo", true));    assertNotNull(lsnr.exists("/foo", w1));    assertNotNull(lsnr.exists("/foo", w1));    assertNotNull(lsnr.exists("/foo/bar", w2));    assertNotNull(lsnr.exists("/foo/bar", w2));    assertNotNull(lsnr.exists("/foo/bar", w3));    assertNotNull(lsnr.exists("/foo/bar", w4));    client.delete("/foo/bar", -1);    expected.add(EventType.NodeDeleted);    client.delete("/foo", -1);    e2.add(EventType.NodeDeleted);    lsnr_dwatch.verify(expected);    w1.verify(expected);    w2.verify(e2);    w3.verify(e2);    w4.verify(e2);    expected.clear();    e2.clear();}
testGetDataSyncWObj
public void zookeeper_f6657_0() throws IOException, InterruptedException, KeeperException
{    SimpleWatcher w1 = new SimpleWatcher(null);    SimpleWatcher w2 = new SimpleWatcher(null);    SimpleWatcher w3 = new SimpleWatcher(null);    SimpleWatcher w4 = new SimpleWatcher(null);    List<EventType> e2 = new ArrayList<EventType>();    try {        lsnr.getData("/foo", w1, null);        fail();    } catch (KeeperException e) {        assertEquals(KeeperException.Code.NONODE, e.code());        assertEquals("/foo", e.getPath());    }    try {        lsnr.getData("/foo/bar", w2, null);        fail();    } catch (KeeperException e) {        assertEquals(KeeperException.Code.NONODE, e.code());        assertEquals("/foo/bar", e.getPath());    }    client.create("/foo", "parent".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    assertNotNull(lsnr.getData("/foo", true, null));    assertNotNull(lsnr.getData("/foo", w1, null));    client.create("/foo/bar", "child".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    assertNotNull(lsnr.getData("/foo/bar", w2, null));    assertNotNull(lsnr.getData("/foo/bar", w3, null));    assertNotNull(lsnr.getData("/foo/bar", w4, null));    assertNotNull(lsnr.getData("/foo/bar", w4, null));    client.setData("/foo", "parent".getBytes(), -1);    expected.add(EventType.NodeDataChanged);    client.setData("/foo/bar", "child".getBytes(), -1);    e2.add(EventType.NodeDataChanged);    lsnr_dwatch.verify(expected);    w1.verify(expected);    w2.verify(e2);    w3.verify(e2);    w4.verify(e2);    expected.clear();    e2.clear();    assertNotNull(lsnr.getData("/foo", true, null));    assertNotNull(lsnr.getData("/foo", w1, null));    assertNotNull(lsnr.getData("/foo/bar", w2, null));    assertNotNull(lsnr.getData("/foo/bar", w3, null));    assertNotNull(lsnr.getData("/foo/bar", w3, null));    assertNotNull(lsnr.getData("/foo/bar", w4, null));    client.delete("/foo/bar", -1);    expected.add(EventType.NodeDeleted);    client.delete("/foo", -1);    e2.add(EventType.NodeDeleted);    lsnr_dwatch.verify(expected);    w1.verify(expected);    w2.verify(e2);    w3.verify(e2);    w4.verify(e2);    expected.clear();    e2.clear();}
testGetChildrenSyncWObj
public void zookeeper_f6658_0() throws IOException, InterruptedException, KeeperException
{    SimpleWatcher w1 = new SimpleWatcher(null);    SimpleWatcher w2 = new SimpleWatcher(null);    SimpleWatcher w3 = new SimpleWatcher(null);    SimpleWatcher w4 = new SimpleWatcher(null);    List<EventType> e2 = new ArrayList<EventType>();    try {        lsnr.getChildren("/foo", true);        fail();    } catch (KeeperException e) {        assertEquals(KeeperException.Code.NONODE, e.code());        assertEquals("/foo", e.getPath());    }    try {        lsnr.getChildren("/foo/bar", true);        fail();    } catch (KeeperException e) {        assertEquals(KeeperException.Code.NONODE, e.code());        assertEquals("/foo/bar", e.getPath());    }    client.create("/foo", "parent".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    assertNotNull(lsnr.getChildren("/foo", true));    assertNotNull(lsnr.getChildren("/foo", w1));    client.create("/foo/bar", "child".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        expected.add(EventType.NodeChildrenChanged);    assertNotNull(lsnr.getChildren("/foo/bar", w2));    assertNotNull(lsnr.getChildren("/foo/bar", w2));    assertNotNull(lsnr.getChildren("/foo/bar", w3));    assertNotNull(lsnr.getChildren("/foo/bar", w4));    client.setData("/foo", "parent".getBytes(), -1);    client.setData("/foo/bar", "child".getBytes(), -1);    assertNotNull(lsnr.exists("/foo", true));    assertNotNull(lsnr.exists("/foo", w1));    assertNotNull(lsnr.exists("/foo", true));    assertNotNull(lsnr.exists("/foo", w1));    assertNotNull(lsnr.getChildren("/foo", true));    assertNotNull(lsnr.getChildren("/foo", w1));    assertNotNull(lsnr.getChildren("/foo/bar", w2));    assertNotNull(lsnr.getChildren("/foo/bar", w3));    assertNotNull(lsnr.getChildren("/foo/bar", w4));    assertNotNull(lsnr.getChildren("/foo/bar", w4));    client.delete("/foo/bar", -1);        e2.add(EventType.NodeDeleted);        expected.add(EventType.NodeChildrenChanged);    client.delete("/foo", -1);    expected.add(EventType.NodeDeleted);    lsnr_dwatch.verify(expected);    w1.verify(expected);    w2.verify(e2);    w3.verify(e2);    w4.verify(e2);    expected.clear();    e2.clear();}
processResult
public void zookeeper_f6659_0(int rc, String path, Object ctx, Stat stat)
{    ((int[]) ctx)[0]++;    this.rc = rc;}
process
public voidf6660_1WatchedEvent event)
{    super.process(event);    if (event.getType() != Event.EventType.None) {        timeOfLastWatcherInvocation = System.currentTimeMillis();        try {            events.put(event);        } catch (InterruptedException e) {                    }    }}
setUp
public void zookeeper_f6661_0() throws Exception
{    super.setUp();            System.setProperty(ZKClientConfig.DISABLE_AUTO_WATCH_RESET, "false");}
testWatcherCorrectness
public void zookeeper_f6662_0() throws IOException, InterruptedException, KeeperException
{    ZooKeeper zk = null;    try {        MyWatcher watcher = new MyWatcher();        zk = createClient(watcher, hostPort);        StatCallback scb = new StatCallback() {            public void processResult(int rc, String path, Object ctx, Stat stat) {                        }        };        VoidCallback vcb = new VoidCallback() {            public void processResult(int rc, String path, Object ctx) {                        }        };        String[] names = new String[10];        for (int i = 0; i < names.length; i++) {            String name = zk.create("/tc-", "initialvalue".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);            names[i] = name;            Stat stat = new Stat();            zk.getData(name, watcher, stat);            zk.setData(name, "new".getBytes(), stat.getVersion(), scb, null);            stat = zk.exists(name, watcher);            zk.delete(name, stat.getVersion(), vcb, null);        }        for (int i = 0; i < names.length; i++) {            String name = names[i];            WatchedEvent event = watcher.events.poll(10, TimeUnit.SECONDS);            assertEquals(name, event.getPath());            assertEquals(Event.EventType.NodeDataChanged, event.getType());            assertEquals(Event.KeeperState.SyncConnected, event.getState());            event = watcher.events.poll(10, TimeUnit.SECONDS);            assertEquals(name, event.getPath());            assertEquals(Event.EventType.NodeDeleted, event.getType());            assertEquals(Event.KeeperState.SyncConnected, event.getState());        }    } finally {        if (zk != null) {            zk.close();        }    }}
processResult
public void zookeeper_f6663_0(int rc, String path, Object ctx, Stat stat)
{}
processResult
public void zookeeper_f6664_0(int rc, String path, Object ctx)
{}
testWatcherDisconnectOnClose
public void zookeeper_f6665_0() throws IOException, InterruptedException, KeeperException
{    ZooKeeper zk = null;    try {        final BlockingQueue<WatchedEvent> queue = new LinkedBlockingQueue<>();        MyWatcher connWatcher = new MyWatcher();        Watcher watcher = event -> {            try {                queue.put(event);            } catch (InterruptedException e) {                        }        };        zk = createClient(connWatcher, hostPort);        StatCallback scb = new StatCallback() {            public void processResult(int rc, String path, Object ctx, Stat stat) {                        }        };                zk.exists("/missing", watcher, scb, null);                zk.close();        WatchedEvent event = queue.poll(10, TimeUnit.SECONDS);        assertNotNull("No watch event was received after closing the Zookeeper client. A 'Closed' event should have occurred", event);        assertEquals("Closed events are not generated by the server, and so should have a type of 'None'", Event.EventType.None, event.getType());        assertEquals("A 'Closed' event was expected as the Zookeeper client was closed without altering the node it was watching", Event.KeeperState.Closed, event.getState());    } finally {        if (zk != null) {            zk.close();        }    }}
processResult
public void zookeeper_f6666_0(int rc, String path, Object ctx, Stat stat)
{}
testWatcherCount
public void zookeeper_f6667_0() throws IOException, InterruptedException, KeeperException
{    ZooKeeper zk1 = null, zk2 = null;    try {        MyWatcher w1 = new MyWatcher();        zk1 = createClient(w1, hostPort);        MyWatcher w2 = new MyWatcher();        zk2 = createClient(w2, hostPort);        Stat stat = new Stat();        zk1.create("/watch-count-test", "value".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);        zk1.create("/watch-count-test-2", "value".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);        zk1.getData("/watch-count-test", w1, stat);        zk1.getData("/watch-count-test-2", w1, stat);        zk2.getData("/watch-count-test", w2, stat);        assertEquals(serverFactory.getZooKeeperServer().getZKDatabase().getDataTree().getWatchCount(), 3);    } finally {        if (zk1 != null) {            zk1.close();        }        if (zk2 != null) {            zk2.close();        }    }}
testWatchAutoResetWithPending
public void zookeeper_f6668_0() throws Exception
{    MyWatcher[] watches = new MyWatcher[COUNT];    MyStatCallback[] cbs = new MyStatCallback[COUNT];    MyWatcher watcher = new MyWatcher();    int[] count = new int[1];    TestableZooKeeper zk = createClient(watcher, hostPort, 6000);    ZooKeeper zk2 = createClient(watcher, hostPort, 5000);    zk2.create("/test", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);    for (int i = 0; i < COUNT / 2; i++) {        watches[i] = new MyWatcher();        cbs[i] = new MyStatCallback();        zk.exists("/test", watches[i], cbs[i], count);    }    zk.exists("/test", false);    assertTrue("Failed to pause the connection!", zk.pauseCnxn(3000));    zk2.close();    stopServer();    watches[0].waitForDisconnected(60000);    for (int i = COUNT / 2; i < COUNT; i++) {        watches[i] = new MyWatcher();        cbs[i] = new MyStatCallback();        zk.exists("/test", watches[i], cbs[i], count);    }    startServer();    watches[COUNT / 2 - 1].waitForConnected(60000);    assertEquals(null, zk.exists("/test", false));    waitForAllWatchers();    for (int i = 0; i < COUNT / 2; i++) {        assertEquals("For " + i, 1, watches[i].events.size());    }    for (int i = COUNT / 2; i < COUNT; i++) {        if (cbs[i].rc == 0) {            assertEquals("For " + i, 1, watches[i].events.size());        } else {            assertEquals("For " + i, 0, watches[i].events.size());        }    }    assertEquals(COUNT, count[0]);    zk.close();}
waitForAllWatchers
private void zookeeper_f6669_0() throws Exception
{    timeOfLastWatcherInvocation = System.currentTimeMillis();    while (System.currentTimeMillis() - timeOfLastWatcherInvocation < 1000) {        Thread.sleep(1000);    }}
testWatcherAutoResetWithGlobal
public void zookeeper_f6670_0() throws Exception
{    ZooKeeper zk = null;    MyWatcher watcher = new MyWatcher();    zk = createClient(watcher, hostPort, TIMEOUT);    testWatcherAutoReset(zk, watcher, watcher);    zk.close();}
testWatcherAutoResetWithLocal
public void zookeeper_f6671_0() throws Exception
{    ZooKeeper zk = null;    MyWatcher watcher = new MyWatcher();    zk = createClient(watcher, hostPort, TIMEOUT);    testWatcherAutoReset(zk, watcher, new MyWatcher());    zk.close();}
testWatcherAutoResetDisabledWithGlobal
public void zookeeper_f6672_0() throws Exception
{    /**     * When ZooKeeper is created this property will get used.     */    System.setProperty(ZKClientConfig.DISABLE_AUTO_WATCH_RESET, "true");    testWatcherAutoResetWithGlobal();}
testWatcherAutoResetDisabledWithLocal
public void zookeeper_f6673_0() throws Exception
{    System.setProperty(ZKClientConfig.DISABLE_AUTO_WATCH_RESET, "true");    testWatcherAutoResetWithLocal();}
testWatcherAutoReset
private voidf6674_1ZooKeeper zk, MyWatcher globalWatcher, MyWatcher localWatcher) throws Exception
{    boolean isGlobal = (localWatcher == globalWatcher);        zk.create("/watchtest", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/watchtest/child", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);    if (isGlobal) {        zk.getChildren("/watchtest", true);        zk.getData("/watchtest/child", true, new Stat());        zk.exists("/watchtest/child2", true);    } else {        zk.getChildren("/watchtest", localWatcher);        zk.getData("/watchtest/child", localWatcher, new Stat());        zk.exists("/watchtest/child2", localWatcher);    }    assertTrue(localWatcher.events.isEmpty());    stopServer();    globalWatcher.waitForDisconnected(3000);    localWatcher.waitForDisconnected(500);    startServer();    globalWatcher.waitForConnected(3000);    boolean disableAutoWatchReset = zk.getClientConfig().getBoolean(ZKClientConfig.DISABLE_AUTO_WATCH_RESET);    if (!isGlobal && !disableAutoWatchReset) {        localWatcher.waitForConnected(500);    }    assertTrue(localWatcher.events.isEmpty());    zk.setData("/watchtest/child", new byte[1], -1);    zk.create("/watchtest/child2", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    WatchedEvent e;    if (!disableAutoWatchReset) {        e = localWatcher.events.poll(TIMEOUT, TimeUnit.MILLISECONDS);        assertEquals(e.getPath(), EventType.NodeDataChanged, e.getType());        assertEquals("/watchtest/child", e.getPath());    } else {            }    if (!disableAutoWatchReset) {        e = localWatcher.events.poll(TIMEOUT, TimeUnit.MILLISECONDS);                        assertEquals(EventType.NodeCreated, e.getType());        assertEquals("/watchtest/child2", e.getPath());    } else {            }    if (!disableAutoWatchReset) {        e = localWatcher.events.poll(TIMEOUT, TimeUnit.MILLISECONDS);        assertEquals(EventType.NodeChildrenChanged, e.getType());        assertEquals("/watchtest", e.getPath());    } else {            }        assertTrue(localWatcher.events.isEmpty());    stopServer();    globalWatcher.waitForDisconnected(TIMEOUT);    try {        try {            localWatcher.waitForDisconnected(500);            if (!isGlobal && !disableAutoWatchReset) {                fail("Got an event when I shouldn't have");            }        } catch (TimeoutException toe) {            if (disableAutoWatchReset) {                fail("Didn't get an event when I should have");            }                }    } catch (Exception e1) {                throw new RuntimeException(e1);    }    startServer();    globalWatcher.waitForConnected(TIMEOUT);    if (isGlobal) {        zk.getChildren("/watchtest", true);        zk.getData("/watchtest/child", true, new Stat());        zk.exists("/watchtest/child2", true);    } else {        zk.getChildren("/watchtest", localWatcher);        zk.getData("/watchtest/child", localWatcher, new Stat());        zk.exists("/watchtest/child2", localWatcher);    }            zk.delete("/watchtest/child2", -1);    e = localWatcher.events.poll(TIMEOUT, TimeUnit.MILLISECONDS);    assertEquals(EventType.NodeDeleted, e.getType());    assertEquals("/watchtest/child2", e.getPath());    e = localWatcher.events.poll(TIMEOUT, TimeUnit.MILLISECONDS);    assertEquals(EventType.NodeChildrenChanged, e.getType());    assertEquals("/watchtest", e.getPath());    assertTrue(localWatcher.events.isEmpty());    stopServer();    globalWatcher.waitForDisconnected(TIMEOUT);    localWatcher.waitForDisconnected(500);    startServer();    globalWatcher.waitForConnected(TIMEOUT);    if (!isGlobal && !disableAutoWatchReset) {        localWatcher.waitForConnected(500);    }    zk.delete("/watchtest/child", -1);    zk.delete("/watchtest", -1);    if (!disableAutoWatchReset) {        e = localWatcher.events.poll(TIMEOUT, TimeUnit.MILLISECONDS);        assertEquals(EventType.NodeDeleted, e.getType());        assertEquals("/watchtest/child", e.getPath());    } else {            }        Thread.sleep(1000);    assertTrue(localWatcher.events.isEmpty());}
process
public voidf6675_1WatchedEvent event)
{    super.process(event);    try {        if (event.getType() != Event.EventType.None) {            dataEvents.put(event);        }    } catch (InterruptedException e) {            }}
assertEvent
public voidf6676_1long timeout, EventType eventType)
{    try {        WatchedEvent event = dataEvents.poll(timeout, TimeUnit.MILLISECONDS);        assertNotNull("do not receive a " + eventType, event);        assertEquals(eventType, event.getType());    } catch (InterruptedException e) {            }}
createClient
private ZooKeeper zookeeper_f6677_0(QuorumUtil qu, int id, EventsWatcher watcher) throws IOException
{    String hostPort = "127.0.0.1:" + qu.getPeer(id).clientPort;    ZooKeeper zk = new ZooKeeper(hostPort, TIMEOUT, watcher);    try {        watcher.waitForConnected(TIMEOUT);    } catch (InterruptedException e) {        } catch (TimeoutException e) {        fail("can not connect to " + hostPort);    }    return zk;}
createClient
private ZooKeeper zookeeper_f6678_0(QuorumUtil qu, int id) throws IOException
{    return createClient(qu, id, new EventsWatcher());}
setUp
public void zookeeper_f6679_0() throws IOException
{    System.setProperty("zookeeper.admin.enableServer", "false");    qu = new QuorumUtil(1);    qu.startAll();    watcher = new EventsWatcher();    zk1 = createClient(qu, 1, watcher);    zk2 = createClient(qu, 2);}
tearDown
public void zookeeper_f6680_0() throws InterruptedException
{    if (zk1 != null) {        zk1.close();        zk1 = null;    }    if (zk2 != null) {        zk2.close();        zk2 = null;    }    if (watcher != null) {        watcher = null;    }    if (qu != null) {        qu.shutdownAll();        qu = null;    }}
testNodeDataChanged
public void zookeeper_f6681_0() throws Exception
{    String path = "/test-changed";    zk1.create(path, new byte[1], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    Stat stat1 = zk1.exists(path, watcher);    qu.shutdown(1);    zk2.setData(path, new byte[2], stat1.getVersion());    qu.start(1);    watcher.waitForConnected(TIMEOUT);    watcher.assertEvent(TIMEOUT, EventType.NodeDataChanged);}
testNodeCreated
public void zookeeper_f6682_0() throws Exception
{    String path = "/test1-created";    zk1.exists(path, watcher);    qu.shutdown(1);    zk2.create(path, new byte[2], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    qu.start(1);    watcher.waitForConnected(TIMEOUT * 1000L);    watcher.assertEvent(TIMEOUT, EventType.NodeCreated);}
testNodeDeleted
public void zookeeper_f6683_0() throws Exception
{    String path = "/test-deleted";    zk1.create(path, new byte[1], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk1.getData(path, watcher, null);    qu.shutdown(1);    zk2.delete(path, -1);    qu.start(1);    watcher.waitForConnected(TIMEOUT * 1000L);    watcher.assertEvent(TIMEOUT, EventType.NodeDeleted);    zk1.create(path, new byte[1], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk1.exists(path, watcher);    qu.shutdown(1);    zk2.delete(path, -1);    qu.start(1);    watcher.waitForConnected(TIMEOUT * 1000L);    watcher.assertEvent(TIMEOUT, EventType.NodeDeleted);    zk1.create(path, new byte[1], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk1.getChildren(path, watcher);    qu.shutdown(1);    zk2.delete(path, -1);    qu.start(1);    watcher.waitForConnected(TIMEOUT * 1000L);    watcher.assertEvent(TIMEOUT, EventType.NodeDeleted);}
testNodeChildrenChanged
public void zookeeper_f6684_0() throws Exception
{    String path = "/test-children-changed";    zk1.create(path, new byte[1], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk1.getChildren(path, watcher);    qu.shutdown(1);    zk2.create(path + "/children-1", new byte[2], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    qu.start(1);    watcher.waitForConnected(TIMEOUT * 1000L);    watcher.assertEvent(TIMEOUT, EventType.NodeChildrenChanged);}
setUp
public void zookeeper_f6685_0()
{    System.setProperty("zookeeper.X509AuthenticationProvider.superUser", "CN=SUPER");    System.setProperty("zookeeper.ssl.keyManager", "org.apache.zookeeper.test.X509AuthTest.TestKeyManager");    System.setProperty("zookeeper.ssl.trustManager", "org.apache.zookeeper.test.X509AuthTest.TestTrustManager");    clientCert = new TestCertificate("CLIENT");    superCert = new TestCertificate("SUPER");    unknownCert = new TestCertificate("UNKNOWN");}
testTrustedAuth
public void zookeeper_f6686_0()
{    X509AuthenticationProvider provider = createProvider(clientCert);    MockServerCnxn cnxn = new MockServerCnxn();    cnxn.clientChain = new X509Certificate[] { clientCert };    assertEquals(KeeperException.Code.OK, provider.handleAuthentication(cnxn, null));}
testSuperAuth
public void zookeeper_f6687_0()
{    X509AuthenticationProvider provider = createProvider(superCert);    MockServerCnxn cnxn = new MockServerCnxn();    cnxn.clientChain = new X509Certificate[] { superCert };    assertEquals(KeeperException.Code.OK, provider.handleAuthentication(cnxn, null));    assertEquals("super", cnxn.getAuthInfo().get(0).getScheme());}
testUntrustedAuth
public void zookeeper_f6688_0()
{    X509AuthenticationProvider provider = createProvider(clientCert);    MockServerCnxn cnxn = new MockServerCnxn();    cnxn.clientChain = new X509Certificate[] { unknownCert };    assertEquals(KeeperException.Code.AUTHFAILED, provider.handleAuthentication(cnxn, null));}
getAlgorithm
public String zookeeper_f6689_0()
{    return null;}
getFormat
public String zookeeper_f6690_0()
{    return null;}
getEncoded
public byte[] zookeeper_f6691_0()
{    return null;}
hasUnsupportedCriticalExtension
public boolean zookeeper_f6692_0()
{    return false;}
getCriticalExtensionOIDs
public Set<String> zookeeper_f6693_0()
{    return null;}
getNonCriticalExtensionOIDs
public Set<String> zookeeper_f6694_0()
{    return null;}
getExtensionValue
public byte[] zookeeper_f6695_0(String oid)
{    return null;}
checkValidity
public void zookeeper_f6696_0() throws CertificateExpiredException, CertificateNotYetValidException
{}
checkValidity
public void zookeeper_f6697_0(Date date) throws CertificateExpiredException, CertificateNotYetValidException
{}
getVersion
public int zookeeper_f6698_0()
{    return 0;}
getSerialNumber
public BigInteger zookeeper_f6699_0()
{    return null;}
getIssuerDN
public Principal zookeeper_f6700_0()
{    return null;}
getSubjectDN
public Principal zookeeper_f6701_0()
{    return null;}
getNotBefore
public Date zookeeper_f6702_0()
{    return null;}
getNotAfter
public Date zookeeper_f6703_0()
{    return null;}
getTBSCertificate
public byte[] zookeeper_f6704_0() throws CertificateEncodingException
{    return null;}
getSignature
public byte[] zookeeper_f6705_0()
{    return null;}
getSigAlgName
public String zookeeper_f6706_0()
{    return null;}
getSigAlgOID
public String zookeeper_f6707_0()
{    return null;}
getSigAlgParams
public byte[] zookeeper_f6708_0()
{    return null;}
getIssuerUniqueID
public boolean[] zookeeper_f6709_0()
{    return null;}
getSubjectUniqueID
public boolean[] zookeeper_f6710_0()
{    return null;}
getKeyUsage
public boolean[] zookeeper_f6711_0()
{    return null;}
getBasicConstraints
public int zookeeper_f6712_0()
{    return 0;}
getEncoded
public byte[] zookeeper_f6713_0() throws CertificateEncodingException
{    return encoded;}
verify
public void zookeeper_f6714_0(PublicKey key) throws CertificateException, NoSuchAlgorithmException, InvalidKeyException, NoSuchProviderException, SignatureException
{}
verify
public void zookeeper_f6715_0(PublicKey key, String sigProvider) throws CertificateException, NoSuchAlgorithmException, InvalidKeyException, NoSuchProviderException, SignatureException
{}
toString
public String zookeeper_f6716_0()
{    return null;}
getPublicKey
public PublicKey zookeeper_f6717_0()
{    return publicKey;}
getSubjectX500Principal
public X500Principal zookeeper_f6718_0()
{    return principal;}
chooseClientAlias
public String zookeeper_f6719_0(String[] keyType, Principal[] issuers, Socket socket)
{    return null;}
chooseServerAlias
public String zookeeper_f6720_0(String keyType, Principal[] issuers, Socket socket)
{    return null;}
getCertificateChain
public X509Certificate[] zookeeper_f6721_0(String alias)
{    return null;}
getClientAliases
public String[] zookeeper_f6722_0(String keyType, Principal[] issuers)
{    return null;}
getPrivateKey
public PrivateKey zookeeper_f6723_0(String alias)
{    return null;}
getServerAliases
public String[] zookeeper_f6724_0(String keyType, Principal[] issuers)
{    return null;}
checkClientTrusted
public void zookeeper_f6725_0(X509Certificate[] chain, String authType) throws CertificateException
{    if (!Arrays.equals(cert.getEncoded(), chain[0].getEncoded())) {        throw new CertificateException("Client cert not trusted");    }}
checkServerTrusted
public void zookeeper_f6726_0(X509Certificate[] chain, String authType) throws CertificateException
{    if (!Arrays.equals(cert.getEncoded(), chain[0].getEncoded())) {        throw new CertificateException("Server cert not trusted");    }}
getAcceptedIssuers
public X509Certificate[] zookeeper_f6727_0()
{    return null;}
createProvider
protected X509AuthenticationProvider zookeeper_f6728_0(X509Certificate trustedCert)
{    return new X509AuthenticationProvider(new TestTrustManager(trustedCert), new TestKeyManager());}
setUp
public voidf6729_1) throws Exception
{        qb.setUp();}
tearDown
public voidf6730_1) throws Exception
{    }
corruptFile
private void zookeeper_f6731_0(File f) throws IOException
{    RandomAccessFile outFile = new RandomAccessFile(f, "rw");    outFile.write("fail servers".getBytes());    outFile.close();}
corruptAllSnapshots
private void zookeeper_f6732_0(File snapDir) throws IOException
{    File[] listFiles = snapDir.listFiles();    for (File f : listFiles) {        if (f.getName().startsWith("snapshot")) {            corruptFile(f);        }    }}
processResult
public void zookeeper_f6733_0(int rc, String path, Object ctx, String name)
{}
testCorruption
public voidf6734_1) throws Exception
{    ClientBase.waitForServerUp(qb.hostPort, 10000);    ClientBase.waitForServerUp(qb.hostPort, 10000);    ZooKeeper zk = ClientBase.createZKClient(qb.hostPort, 10000);    SyncRequestProcessor.setSnapCount(100);    for (int i = 0; i < 2000; i++) {        zk.create("/0-" + i, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, new NoopStringCallback(), null);    }    zk.close();    long leaderSid = 1;    QuorumPeer leader = null;        for (QuorumPeer quorumPeer : Arrays.asList(qb.s1, qb.s2, qb.s3, qb.s4, qb.s5)) {        if (quorumPeer.getPeerState() == ServerState.LEADING) {            leader = quorumPeer;            break;        }        ++leaderSid;    }    assertNotNull("Cannot find the leader.", leader);    leader.shutdown();        FileTxnSnapLog snapLog = leader.getTxnFactory();    File snapDir = snapLog.getSnapDir();        corruptAllSnapshots(snapDir);    qb.shutdownServers();    qb.setupServers();    if (leaderSid != 1) {        qb.s1.start();    } else {        leader = qb.s1;    }    if (leaderSid != 2) {        qb.s2.start();    } else {        leader = qb.s2;    }    if (leaderSid != 3) {        qb.s3.start();    } else {        leader = qb.s3;    }    if (leaderSid != 4) {        qb.s4.start();    } else {        leader = qb.s4;    }    if (leaderSid != 5) {        qb.s5.start();    } else {        leader = qb.s5;    }    try {        leader.start();        assertTrue(false);    } catch (RuntimeException re) {            }        String[] list = qb.hostPort.split(",");    for (int i = 0; i < 5; i++) {        if (leaderSid != (i + 1)) {            String hp = list[i];            assertTrue("waiting for server up", ClientBase.waitForServerUp(hp, CONNECTION_TIMEOUT));                    } else {                    }    }    zk = qb.createClient();    SyncRequestProcessor.setSnapCount(100);    for (int i = 2000; i < 4000; i++) {        zk.create("/0-" + i, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, new NoopStringCallback(), null);    }    zk.close();    if (leaderSid != 1) {        QuorumBase.shutdown(qb.s1);    }    if (leaderSid != 2) {        QuorumBase.shutdown(qb.s2);    }    if (leaderSid != 3) {        QuorumBase.shutdown(qb.s3);    }    if (leaderSid != 4) {        QuorumBase.shutdown(qb.s4);    }    if (leaderSid != 5) {        QuorumBase.shutdown(qb.s5);    }}
testAbsentRecentSnapshot
public void zookeeper_f6735_0() throws IOException
{    ZKDatabase zkDatabase = new ZKDatabase(new FileTxnSnapLog(new File("foo"), new File("bar")) {        @Override        public File findMostRecentSnapshot() throws IOException {            return null;        }    });    assertEquals(0, zkDatabase.calculateTxnLogSizeLimit());}
findMostRecentSnapshot
public File zookeeper_f6736_0() throws IOException
{    return null;}
testQuota
public void zookeeper_f6737_0() throws Exception
{    final ZooKeeper zk = createClient();    final String path = "/a/b/v";        zk.setData("/", "some".getBytes(), -1);    zk.create("/a", "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/a/b", "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/a/b/v", "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/a/b/v/d", "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    SetQuotaCommand.createQuota(zk, path, 5L, 10);        String absolutePath = Quotas.quotaZookeeper + path + "/" + Quotas.limitNode;    byte[] data = zk.getData(absolutePath, false, new Stat());    StatsTrack st = new StatsTrack(new String(data));    assertTrue("bytes are set", st.getBytes() == 5L);    assertTrue("num count is set", st.getCount() == 10);    String statPath = Quotas.quotaZookeeper + path + "/" + Quotas.statNode;    byte[] qdata = zk.getData(statPath, false, new Stat());    StatsTrack qst = new StatsTrack(new String(qdata));    assertTrue("bytes are set", qst.getBytes() == 8L);    assertTrue("count is set", qst.getCount() == 2);        stopServer();    startServer();    stopServer();    startServer();    ZooKeeperServer server = serverFactory.getZooKeeperServer();    assertNotNull("Quota is still set", server.getZKDatabase().getDataTree().getMaxPrefixWithQuota(path) != null);}
testSetQuota
public void zookeeper_f6738_0() throws IOException, InterruptedException, KeeperException, MalformedPathException
{    final ZooKeeper zk = createClient();    String path = "/c1";    String nodeData = "foo";    zk.create(path, nodeData.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    int count = 10;    long bytes = 5L;    SetQuotaCommand.createQuota(zk, path, bytes, count);        String absoluteLimitPath = Quotas.quotaZookeeper + path + "/" + Quotas.limitNode;    byte[] data = zk.getData(absoluteLimitPath, false, null);    StatsTrack st = new StatsTrack(new String(data));    assertEquals(bytes, st.getBytes());    assertEquals(count, st.getCount());        String absoluteStatPath = Quotas.quotaZookeeper + path + "/" + Quotas.statNode;    data = zk.getData(absoluteStatPath, false, null);    st = new StatsTrack(new String(data));    assertEquals(nodeData.length(), st.getBytes());    assertEquals(1, st.getCount());        String path2 = "/c1/c2";    String nodeData2 = "bar";    zk.create(path2, nodeData2.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    absoluteStatPath = Quotas.quotaZookeeper + path + "/" + Quotas.statNode;    data = zk.getData(absoluteStatPath, false, null);    st = new StatsTrack(new String(data));        assertEquals(nodeData.length() + nodeData2.length(), st.getBytes());    assertEquals(2, st.getCount());}
testSetQuotaWhenSetQuotaOnParentOrChildPath
public void zookeeper_f6739_0() throws IOException, InterruptedException, KeeperException, MalformedPathException
{    final ZooKeeper zk = createClient();    zk.create("/c1", "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/c1/c2", "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/c1/c2/c3", "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/c1/c2/c3/c4", "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/c1/c2/c3/c4/c5", "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        SetQuotaCommand.createQuota(zk, "/c1/c2/c3", 5L, 10);    try {        SetQuotaCommand.createQuota(zk, "/c1", 5L, 10);    } catch (IllegalArgumentException e) {        assertEquals("/c1 has a child /c1/c2/c3 which has a quota", e.getMessage());    }    try {        SetQuotaCommand.createQuota(zk, "/c1/c2/c3/c4/c5", 5L, 10);    } catch (IllegalArgumentException e) {        assertEquals("/c1/c2/c3/c4/c5 has a parent /c1/c2/c3 which has a quota", e.getMessage());    }}
getEvent
private WatchedEvent zookeeper_f6740_0(int numTries) throws InterruptedException
{    WatchedEvent event = null;    for (int i = 0; i < numTries; i++) {        System.out.println("i = " + i);        event = events.poll(10, TimeUnit.SECONDS);        if (event != null) {            break;        }        Thread.sleep(5000);    }    return event;}
deleteZKDir
private void zookeeper_f6741_0(ZooKeeper zk, String nodeName) throws IOException, InterruptedException, KeeperException
{    Stat stat = zk.exists(nodeName, false);    if (stat == null) {        return;    }    List<String> children1 = zk.getChildren(nodeName, false);    List<String> c2 = zk.getChildren(nodeName, false, stat);    if (!children1.equals(c2)) {        fail("children lists from getChildren()/getChildren2() do not match");    }    if (!stat.equals(stat)) {        fail("stats from exists()/getChildren2() do not match");    }    if (children1.size() == 0) {        zk.delete(nodeName, -1);        return;    }    for (String n : children1) {        deleteZKDir(zk, n);    }}
checkRoot
private void zookeeper_f6742_0() throws IOException, InterruptedException
{    ZooKeeper zk = new ZooKeeper(hostPort, 10000, this);    try {        zk.create(dirOnZK, null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    } catch (KeeperException.NodeExistsException ke) {        } catch (KeeperException ke) {        fail("Unexpected exception code for create " + dirOnZK + ": " + ke.getMessage());    }    try {        zk.create(testDirOnZK, null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    } catch (KeeperException.NodeExistsException ke) {        } catch (KeeperException ke) {        fail("Unexpected exception code for create " + testDirOnZK + ": " + ke.getMessage());    }    zk.close();}
enode_test_1
private void zookeeper_f6743_0() throws IOException, InterruptedException, KeeperException
{    checkRoot();    String parentName = testDirOnZK;    String nodeName = parentName + "/enode_abc";    ZooKeeper zk = new ZooKeeper(hostPort, 10000, this);    Stat stat = zk.exists(parentName, false);    if (stat == null) {        try {            zk.create(parentName, null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        } catch (KeeperException ke) {            fail("Creating node " + parentName + ke.getMessage());        }    }    try {        zk.create(nodeName, null, Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);    } catch (KeeperException ke) {        Code code = ke.code();        boolean valid = code == KeeperException.Code.NODEEXISTS;        if (!valid) {            fail("Unexpected exception code for createin: " + ke.getMessage());        }    }    stat = zk.exists(nodeName, false);    if (stat == null) {        fail("node " + nodeName + " should exist");    }    System.out.println("Closing client with sessionid: 0x" + Long.toHexString(zk.getSessionId()));    zk.close();    zk = new ZooKeeper(hostPort, 10000, this);    for (int i = 0; i < 10; i++) {        System.out.println("i = " + i);        stat = zk.exists(nodeName, false);        if (stat != null) {            System.out.println("node " + nodeName + " should not exist after reconnection close");        } else {            System.out.println("node " + nodeName + " is gone after reconnection close!");            break;        }        Thread.sleep(5000);    }    deleteZKDir(zk, nodeName);    zk.close();}
enode_test_2
private void zookeeper_f6744_0() throws IOException, InterruptedException, KeeperException
{    checkRoot();    String parentName = testDirOnZK;    String nodeName = parentName + "/enode_abc";    ZooKeeper zk = new ZooKeeper(hostPort, 10000, this);    ZooKeeper zk_1 = new ZooKeeper(hostPort, 10000, this);    Stat stat_parent = zk_1.exists(parentName, false);    if (stat_parent == null) {        try {            zk.create(parentName, null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);        } catch (KeeperException ke) {            fail("Creating node " + parentName + ke.getMessage());        }    }    Stat stat_node = zk_1.exists(nodeName, false);    if (stat_node != null) {        try {            zk.delete(nodeName, -1);        } catch (KeeperException ke) {            Code code = ke.code();            boolean valid = code == KeeperException.Code.NONODE || code == KeeperException.Code.NOTEMPTY;            if (!valid) {                fail("Unexpected exception code for delete: " + ke.getMessage());            }        }    }    List<String> firstGen1 = zk_1.getChildren(parentName, true);    Stat stat = new Stat();    List<String> firstGen2 = zk_1.getChildren(parentName, true, stat);    if (!firstGen1.equals(firstGen2)) {        fail("children lists from getChildren()/getChildren2() do not match");    }    if (!stat_parent.equals(stat)) {        fail("stat from exists()/getChildren() do not match");    }    try {        zk.create(nodeName, null, Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);    } catch (KeeperException ke) {        Code code = ke.code();        boolean valid = code == KeeperException.Code.NODEEXISTS;        if (!valid) {            fail("Unexpected exception code for createin: " + ke.getMessage());        }    }    Thread.sleep(5000);    WatchedEvent event = events.poll(10, TimeUnit.SECONDS);    if (event == null) {        throw new IOException("No event was delivered promptly");    }    if (event.getType() != EventType.NodeChildrenChanged || !event.getPath().equalsIgnoreCase(parentName)) {        fail("Unexpected event was delivered: " + event.toString());    }    stat_node = zk_1.exists(nodeName, false);    if (stat_node == null) {        fail("node " + nodeName + " should exist");    }    try {        zk.delete(parentName, -1);        fail("Should be impossible to delete a non-empty node " + parentName);    } catch (KeeperException ke) {        Code code = ke.code();        boolean valid = code == KeeperException.Code.NOTEMPTY;        if (!valid) {            fail("Unexpected exception code for delete: " + code);        }    }    try {        zk.create(nodeName + "/def", null, Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);        fail("Should be impossible to create child off Ephemeral node " + nodeName);    } catch (KeeperException ke) {        Code code = ke.code();        boolean valid = code == KeeperException.Code.NOCHILDRENFOREPHEMERALS;        if (!valid) {            fail("Unexpected exception code for createin: " + code);        }    }    try {        List<String> children1 = zk.getChildren(nodeName, false);        List<String> children2 = zk.getChildren(nodeName, false, null);        if (!children1.equals(children2)) {            fail("children lists from getChildren()/getChildren2() does not match");        }        if (children1.size() > 0) {            fail("ephemeral node " + nodeName + " should not have children");        }    } catch (KeeperException ke) {        Code code = ke.code();        boolean valid = code == KeeperException.Code.NONODE;        if (!valid) {            fail("Unexpected exception code for createin: " + code);        }    }    firstGen1 = zk_1.getChildren(parentName, true);    firstGen2 = zk_1.getChildren(parentName, true, null);    if (!firstGen1.equals(firstGen2)) {        fail("children list from getChildren()/getChildren2() does not match");    }    stat_node = zk_1.exists(nodeName, true);    if (stat_node == null) {        fail("node " + nodeName + " should exist");    }    System.out.println("session id of zk: " + zk.getSessionId());    System.out.println("session id of zk_1: " + zk_1.getSessionId());    zk.close();    zk_1.exists("nosuchnode", false);    event = this.getEvent(10);    if (event == null) {        throw new Error("First event was not delivered promptly");    }    if (!((event.getType() == EventType.NodeChildrenChanged && event.getPath().equalsIgnoreCase(parentName)) || (event.getType() == EventType.NodeDeleted && event.getPath().equalsIgnoreCase(nodeName)))) {        System.out.print(parentName + " " + EventType.NodeChildrenChanged + " " + nodeName + " " + EventType.NodeDeleted);        fail("Unexpected first event was delivered: " + event.toString());    }    event = this.getEvent(10);    if (event == null) {        throw new Error("Second event was not delivered promptly");    }    if (!((event.getType() == EventType.NodeChildrenChanged && event.getPath().equalsIgnoreCase(parentName)) || (event.getType() == EventType.NodeDeleted && event.getPath().equalsIgnoreCase(nodeName)))) {        System.out.print(parentName + " " + EventType.NodeChildrenChanged + " " + nodeName + " " + EventType.NodeDeleted);        fail("Unexpected second event was delivered: " + event.toString());    }    firstGen1 = zk_1.getChildren(parentName, false);    stat_node = zk_1.exists(nodeName, false);    if (stat_node != null) {        fail("node " + nodeName + " should have been deleted");    }    if (firstGen1.contains(nodeName)) {        fail("node " + nodeName + " should not be a children");    }    deleteZKDir(zk_1, nodeName);    zk_1.close();}
delete_create_get_set_test_1
private void zookeeper_f6745_0() throws IOException, InterruptedException, KeeperException
{    checkRoot();    ZooKeeper zk = new ZooKeeper(hostPort, 10000, this);    String parentName = testDirOnZK;    String nodeName = parentName + "/benwashere";    try {        zk.delete(nodeName, -1);    } catch (KeeperException ke) {        Code code = ke.code();        boolean valid = code == KeeperException.Code.NONODE || code == KeeperException.Code.NOTEMPTY;        if (!valid) {            fail("Unexpected exception code for delete: " + ke.getMessage());        }    }    try {        zk.create(nodeName, null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    } catch (KeeperException ke) {        Code code = ke.code();        boolean valid = code == KeeperException.Code.NODEEXISTS;        if (!valid) {            fail("Unexpected exception code for create: " + ke.getMessage());        }    }    try {        zk.setData(nodeName, "hi".getBytes(), 5700);        fail("Should have gotten BadVersion exception");    } catch (KeeperException ke) {        if (ke.code() != Code.BADVERSION) {            fail("Should have gotten BadVersion exception");        }    }    zk.setData(nodeName, "hi".getBytes(), -1);    Stat st = new Stat();    byte[] bytes = zk.getData(nodeName, false, st);    String retrieved = new String(bytes);    if (!"hi".equals(retrieved)) {        fail("The retrieved data [" + retrieved + "] is differented than the expected [hi]");    }    try {        zk.delete(nodeName, 6800);        fail("Should have gotten BadVersion exception");    } catch (KeeperException ke) {        Code code = ke.code();        boolean valid = code == KeeperException.Code.NOTEMPTY || code == KeeperException.Code.BADVERSION;        if (!valid) {            fail("Unexpected exception code for delete: " + ke.getMessage());        }    }    try {        zk.delete(nodeName, -1);    } catch (KeeperException ke) {        Code code = ke.code();        boolean valid = code == KeeperException.Code.NOTEMPTY;        if (!valid) {            fail("Unexpected exception code for delete: " + code);        }    }    deleteZKDir(zk, nodeName);    zk.close();}
deleteNodeIfExists
private void zookeeper_f6746_0(ZooKeeper zk, String nodeName) throws InterruptedException
{    try {        zk.delete(nodeName, -1);    } catch (KeeperException ke) {        Code code = ke.code();        boolean valid = code == KeeperException.Code.NONODE || code == KeeperException.Code.NOTEMPTY;        if (!valid) {            fail("Unexpected exception code for delete: " + ke.getMessage());        }    }}
create_get_stat_test
private void zookeeper_f6747_0() throws IOException, InterruptedException, KeeperException
{    checkRoot();    ZooKeeper zk = new ZooKeeper(hostPort, 10000, this);    String parentName = testDirOnZK;    String nodeName = parentName + "/create_with_stat_tmp";    deleteNodeIfExists(zk, nodeName);    deleteNodeIfExists(zk, nodeName + "_2");    Stat stat = new Stat();    zk.create(nodeName, null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, stat);    assertNotNull(stat);    assertTrue(stat.getCzxid() > 0);    assertTrue(stat.getCtime() > 0);    Stat stat2 = new Stat();    zk.create(nodeName + "_2", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, stat2);    assertNotNull(stat2);    assertTrue(stat2.getCzxid() > stat.getCzxid());    assertTrue(stat2.getCtime() > stat.getCtime());    deleteNodeIfExists(zk, nodeName);    deleteNodeIfExists(zk, nodeName + "_2");    zk.close();}
my_test_1
public void zookeeper_f6748_0() throws IOException, InterruptedException, KeeperException
{    enode_test_1();    enode_test_2();    delete_create_get_set_test_1();    create_get_stat_test();}
process
public synchronized void zookeeper_f6749_0(WatchedEvent event)
{    try {        System.out.println("Got an event " + event.toString());        events.put(event);    } catch (InterruptedException e) {        e.printStackTrace();    }}
main
public static void zookeeper_f6750_0(String[] args)
{    ZooKeeperTestClient zktc = new ZooKeeperTestClient();    try {        zktc.my_test_1();    } catch (Exception e) {        e.printStackTrace();    }}
setXid
 void zookeeper_f6751_0(int newXid)
{    xid = newXid;}
checkXid
 int zookeeper_f6752_0()
{    return xid;}
createConnection
protected ClientCnxn zookeeper_f6753_0(String chrootPath, HostProvider hostProvider, int sessionTimeout, ZooKeeper zooKeeper, ClientWatchManager watcher, ClientCnxnSocket clientCnxnSocket, boolean canBeReadOnly) throws IOException
{    return new TestableClientCnxn(chrootPath, hostProvider, sessionTimeout, this, watcher, clientCnxnSocket, canBeReadOnly);}
setXid
public void zookeeper_f6754_0(int xid)
{    ((TestableClientCnxn) cnxn).setXid(xid);}
checkXid
public int zookeeper_f6755_0()
{    return ((TestableClientCnxn) cnxn).checkXid();}
getChildWatches
public List<String> zookeeper_f6756_0()
{    return super.getChildWatches();}
getDataWatches
public List<String> zookeeper_f6757_0()
{    return super.getDataWatches();}
getExistWatches
public List<String> zookeeper_f6758_0()
{    return super.getExistWatches();}
testableConnloss
public void zookeeper_f6759_0() throws IOException
{    synchronized (cnxn) {        cnxn.sendThread.testableCloseSocket();    }}
pauseCnxn
public boolean zookeeper_f6760_0(final long ms)
{    final CountDownLatch initiatedPause = new CountDownLatch(1);    new Thread() {        public void run() {            synchronized (cnxn) {                try {                    try {                        cnxn.sendThread.testableCloseSocket();                    } catch (IOException e) {                        e.printStackTrace();                    } finally {                        initiatedPause.countDown();                    }                    Thread.sleep(ms);                } catch (InterruptedException e) {                }            }        }    }.start();    try {        return initiatedPause.await(ms, TimeUnit.MILLISECONDS);    } catch (InterruptedException e) {        e.printStackTrace();        return false;    }}
run
public void zookeeper_f6761_0()
{    synchronized (cnxn) {        try {            try {                cnxn.sendThread.testableCloseSocket();            } catch (IOException e) {                e.printStackTrace();            } finally {                initiatedPause.countDown();            }            Thread.sleep(ms);        } catch (InterruptedException e) {        }    }}
testableLocalSocketAddress
public SocketAddress zookeeper_f6762_0()
{    return super.testableLocalSocketAddress();}
testableRemoteSocketAddress
public SocketAddress zookeeper_f6763_0()
{    return super.testableRemoteSocketAddress();}
testableLastZxid
public long zookeeper_f6764_0()
{    return cnxn.getLastZxid();}
submitRequest
public ReplyHeader zookeeper_f6765_0(RequestHeader h, Record request, Record response, WatchRegistration watchRegistration) throws InterruptedException
{    return cnxn.submitRequest(h, request, response, watchRegistration);}
disconnect
public void zookeeper_f6766_0()
{    cnxn.disconnect();}
params
public static Collection<Object[]> zookeeper_f6767_0()
{    return BaseX509ParameterizedTestCase.defaultParams();}
testLoadPrivateKeyFromKeyStore
public void zookeeper_f6768_0() throws IOException, GeneralSecurityException
{    Optional<String> optPassword = x509TestContext.getKeyStorePassword().length() > 0 ? Optional.of(x509TestContext.getKeyStorePassword()) : Optional.empty();    PrivateKey privateKey = PemReader.loadPrivateKey(x509TestContext.getKeyStoreFile(KeyStoreFileType.PEM), optPassword);    assertEquals(x509TestContext.getKeyStoreKeyPair().getPrivate(), privateKey);}
testLoadEncryptedPrivateKeyFromKeyStoreWithoutPassword
public void zookeeper_f6769_0() throws GeneralSecurityException, IOException
{    if (!x509TestContext.isKeyStoreEncrypted()) {                throw new GeneralSecurityException();    }    PemReader.loadPrivateKey(x509TestContext.getKeyStoreFile(KeyStoreFileType.PEM), Optional.empty());}
testLoadEncryptedPrivateKeyFromKeyStoreWithWrongPassword
public void zookeeper_f6770_0() throws GeneralSecurityException, IOException
{    if (!x509TestContext.isKeyStoreEncrypted()) {                throw new GeneralSecurityException();    }    PemReader.loadPrivateKey(x509TestContext.getKeyStoreFile(KeyStoreFileType.PEM), Optional.of("wrong password"));}
testLoadUnencryptedPrivateKeyFromKeyStoreWithWrongPassword
public void zookeeper_f6771_0() throws GeneralSecurityException, IOException
{    if (x509TestContext.isKeyStoreEncrypted()) {        throw new IOException();    }    PemReader.loadPrivateKey(x509TestContext.getKeyStoreFile(KeyStoreFileType.PEM), Optional.of("wrong password"));}
testLoadPrivateKeyFromTrustStore
public void zookeeper_f6772_0() throws IOException, GeneralSecurityException
{    PemReader.loadPrivateKey(x509TestContext.getTrustStoreFile(KeyStoreFileType.PEM), Optional.empty());}
testLoadPrivateKeyFromTrustStoreWithPassword
public void zookeeper_f6773_0() throws IOException, GeneralSecurityException
{    PemReader.loadPrivateKey(x509TestContext.getTrustStoreFile(KeyStoreFileType.PEM), Optional.of("foobar"));}
testLoadCertificateFromKeyStore
public void zookeeper_f6774_0() throws IOException, GeneralSecurityException
{    List<X509Certificate> certs = PemReader.readCertificateChain(x509TestContext.getKeyStoreFile(KeyStoreFileType.PEM));    assertEquals(1, certs.size());    assertEquals(x509TestContext.getKeyStoreCertificate(), certs.get(0));}
testLoadCertificateFromTrustStore
public void zookeeper_f6775_0() throws IOException, GeneralSecurityException
{    List<X509Certificate> certs = PemReader.readCertificateChain(x509TestContext.getTrustStoreFile(KeyStoreFileType.PEM));    assertEquals(1, certs.size());    assertEquals(x509TestContext.getTrustStoreCertificate(), certs.get(0));}
data
public static Collection<Object[]> zookeeper_f6776_0()
{    return Arrays.asList(new Object[][] { { "1.2.3", new Object[] { 1, 2, 3, null } }, { "1.2.3-dev", new Object[] { 1, 2, 3, "dev" } }, { "1.2.3-SNAPSHOT", new Object[] { 1, 2, 3, "SNAPSHOT" } }, { "1.2.3-SNAPSHOT", new Object[] { 1, 2, 3, "SNAPSHOT" } }, { "1.2.3-foo-bar+123", new Object[] { 1, 2, 3, "foo-bar+123" } }, { "1.2.3.4.5-SNAPSHOT", new Object[] { 1, 2, 3, "SNAPSHOT" } }, { "1.2.3.4.5-foo-bar+123", new Object[] { 1, 2, 3, "foo-bar+123" } } });}
testParser
public void zookeeper_f6777_0()
{    VerGen.Version v = VerGen.parseVersionString(input);    assertEquals(expected[0], v.maj);    assertEquals(expected[1], v.min);    assertEquals(expected[2], v.micro);    assertEquals(expected[3], v.qualifier);}
testGenFile
public void zookeeper_f6778_0() throws Exception
{    VerGen.Version v = VerGen.parseVersionString(input);    File outputDir = ClientBase.createTmpDir();    VerGen.generateFile(outputDir, v, "1", "Nov1");    ClientBase.recursiveDelete(outputDir);}
createRunnerForTestWithParameters
public org.junit.runner.Runner zookeeper_f6779_0(TestWithParameters test) throws InitializationError
{    return new ZKParameterized.Runner(test);}
computeTestMethods
protected List<FrameworkMethod> zookeeper_f6780_0()
{    return JUnit4ZKTestRunner.computeTestMethodsForClass(getTestClass().getJavaClass(), super.computeTestMethods());}
methodInvoker
protected Statement zookeeper_f6781_0(FrameworkMethod method, Object test)
{    return new JUnit4ZKTestRunner.LoggedInvokeMethod(method, test);}
getTestName
protected String zookeeper_f6782_0()
{    return testName;}
starting
public voidf6783_1Description method)
{                System.setProperty("zookeeper.admin.enableServer", "false");            System.setProperty("zookeeper.4lw.commands.whitelist", "*");    testName = method.getMethodName();    }
finished
public voidf6784_1Description method)
{    }
succeeded
public voidf6785_1Description method)
{    }
failed
public voidf6786_1Throwable e, Description method)
{    }
waitFor
public void zookeeper_f6787_0(String msg, WaitForCondition condition, int timeout) throws InterruptedException
{    final LocalDateTime deadline = LocalDateTime.now().plusSeconds(timeout);    while (LocalDateTime.now().isBefore(deadline)) {        if (condition.evaluate()) {            return;        }        Thread.sleep(100);    }    fail(msg);}
init
public static void zookeeper_f6788_0()
{    testData.mkdirs();}
testValidateFileInput
public void zookeeper_f6789_0() throws IOException
{    File file = File.createTempFile("test", ".junit", testData);    file.deleteOnExit();    String absolutePath = file.getAbsolutePath();    String error = ZKUtil.validateFileInput(absolutePath);    assertNull(error);}
testValidateFileInputNotExist
public void zookeeper_f6790_0()
{    String fileName = UUID.randomUUID().toString();    File file = new File(testData, fileName);    String absolutePath = file.getAbsolutePath();    String error = ZKUtil.validateFileInput(absolutePath);    assertNotNull(error);    String expectedMessage = "File '" + absolutePath + "' does not exist.";    assertEquals(expectedMessage, error);}
testValidateFileInputDirectory
public void zookeeper_f6791_0() throws Exception
{    File file = File.createTempFile("test", ".junit", testData);    file.deleteOnExit();        file.delete();    file.mkdir();    String absolutePath = file.getAbsolutePath();    String error = ZKUtil.validateFileInput(absolutePath);    assertNotNull(error);    String expectedMessage = "'" + absolutePath + "' is a direcory. it must be a file.";    assertEquals(expectedMessage, error);}
testUnreadableFileInput
public void zookeeper_f6792_0() throws Exception
{        assumeTrue(!org.apache.zookeeper.Shell.WINDOWS);    File file = File.createTempFile("test", ".junit", testData);    file.setReadable(false, false);    file.deleteOnExit();    String absolutePath = file.getAbsolutePath();    String error = ZKUtil.validateFileInput(absolutePath);    assertNotNull(error);    String expectedMessage = "Read permission is denied on the file '" + absolutePath + "'";    assertEquals(expectedMessage, error);}
testDeleteRecursive
public void zookeeper_f6793_0() throws IOException, InterruptedException, KeeperException
{    final ZooKeeper zk = createClient();    setupDataTree(zk);    assertTrue(ZKUtil.deleteRecursive(zk, "/a/c", 1000));    List<String> children = zk.getChildren("/a", false);    assertEquals("1 children - c should be deleted ", 1, children.size());    assertTrue(children.contains("b"));    assertTrue(ZKUtil.deleteRecursive(zk, "/a", 1000));    assertNull(zk.exists("/a", null));}
testDeleteRecursiveFail
public void zookeeper_f6794_0() throws IOException, InterruptedException, KeeperException
{    final ZooKeeper zk = createClient();    setupDataTree(zk);    ACL deleteProtection = new ACL(ZooDefs.Perms.DELETE, new Id("digest", "user:tl+z3z0vO6PfPfEENfLF96E6pM0="));    List<ACL> acls = Arrays.asList(new ACL(ZooDefs.Perms.READ, Ids.ANYONE_ID_UNSAFE), deleteProtection);        zk.create("/a/c/0/surprise", "".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    assertEquals(1, zk.getACL("/a/c/0", new Stat()).size());    zk.setACL("/a/c/0", acls, -1);    assertEquals(2, zk.getACL("/a/c/0", new Stat()).size());    assertFalse(ZKUtil.deleteRecursive(zk, "/a/c", 1000));    List<String> children = zk.getChildren("/a", false);    assertEquals("2 children - c should fail to be deleted ", 2, children.size());    assertTrue(children.contains("b"));    assertTrue(ZKUtil.deleteRecursive(zk, "/a/b", 1000));    children = zk.getChildren("/a", false);    assertEquals("1 children - b should be deleted ", 1, children.size());        zk.addAuthInfo(deleteProtection.getId().getScheme(), "user:test".getBytes());    assertTrue(ZKUtil.deleteRecursive(zk, "/a", 1000));    assertNull(zk.exists("/a", null));}
setupDataTree
private void zookeeper_f6795_0(ZooKeeper zk) throws KeeperException, InterruptedException
{        zk.setData("/", "some".getBytes(), -1);    zk.create("/a", "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/a/b", "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/a/b/v", "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    for (int i = 1000; i < 3000; ++i) {        zk.create("/a/b/v/" + i, "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    }    zk.create("/a/c", "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/a/c/v", "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    for (int i = 0; i < 500; ++i) {        zk.create("/a/c/" + i, "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    }    List<String> children = zk.getChildren("/a", false);    assertEquals("2 children - b & c should be present ", 2, children.size());    assertTrue(children.contains("b"));    assertTrue(children.contains("c"));}
testDeleteRecursiveCli
public void zookeeper_f6796_0() throws IOException, InterruptedException, CliException, KeeperException
{    final ZooKeeper zk = createClient();        zk.setData("/", "some".getBytes(), -1);    zk.create("/a", "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/a/b", "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/a/b/v", "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/a/b/v/1", "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/a/c", "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/a/c/v", "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    List<String> children = zk.getChildren("/a", false);    assertEquals("2 children - b & c should be present ", children.size(), 2);    assertTrue(children.contains("b"));    assertTrue(children.contains("c"));    ZooKeeperMain zkMain = new ZooKeeperMain(zk);            String cmdstring0 = "rmr /a/b/v";    String cmdstring1 = "deleteall /a";    zkMain.cl.parseCommand(cmdstring0);    assertFalse(zkMain.processZKCmd(zkMain.cl));    assertEquals(null, zk.exists("/a/b/v", null));    zkMain.cl.parseCommand(cmdstring1);    assertFalse(zkMain.processZKCmd(zkMain.cl));    assertNull(zk.exists("/a", null));}
testDeleteRecursiveAsync
public void zookeeper_f6797_0() throws IOException, InterruptedException, KeeperException
{    final ZooKeeper zk = createClient();        zk.setData("/", "some".getBytes(), -1);    zk.create("/a", "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/a/b", "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/a/b/v", "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/a/b/v/1", "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/a/c", "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/a/c/v", "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    for (int i = 0; i < 50; ++i) {        zk.create("/a/c/" + i, "some".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    }    List<String> children = zk.getChildren("/a", false);    assertEquals("2 children - b & c should be present ", children.size(), 2);    assertTrue(children.contains("b"));    assertTrue(children.contains("c"));    VoidCallback cb = new VoidCallback() {        @Override        public void processResult(int rc, String path, Object ctx) {            synchronized (ctx) {                ((AtomicInteger) ctx).set(4);                ctx.notify();            }        }    };    final AtomicInteger ctx = new AtomicInteger(3);    ZKUtil.deleteRecursive(zk, "/a", cb, ctx);    synchronized (ctx) {        ctx.wait();    }    assertEquals(4, ctx.get());}
processResult
public void zookeeper_f6798_0(int rc, String path, Object ctx)
{    synchronized (ctx) {        ((AtomicInteger) ctx).set(4);        ctx.notify();    }}
testStatWhenPathDoesNotExist
public void zookeeper_f6799_0() throws IOException, InterruptedException, MalformedCommandException
{    final ZooKeeper zk = createClient();    ZooKeeperMain main = new ZooKeeperMain(zk);    String cmdstring = "stat /invalidPath";    main.cl.parseCommand(cmdstring);    try {        main.processZKCmd(main.cl);        fail("As Node does not exist, command should fail by throwing No Node Exception.");    } catch (CliException e) {        assertEquals("Node does not exist: /invalidPath", e.getMessage());    }}
testParseWithExtraSpaces
public void zookeeper_f6800_0() throws Exception
{    final ZooKeeper zk = createClient();    ZooKeeperMain zkMain = new ZooKeeperMain(zk);    String cmdstring = "      ls       /  ";    zkMain.cl.parseCommand(cmdstring);    assertEquals("Spaces also considered as characters", zkMain.cl.getNumArguments(), 2);    assertEquals("ls is not taken as first argument", zkMain.cl.getCmdArgument(0), "ls");    assertEquals("/ is not taken as second argument", zkMain.cl.getCmdArgument(1), "/");}
testParseWithQuotes
public void zookeeper_f6801_0() throws Exception
{    final ZooKeeper zk = createClient();    ZooKeeperMain zkMain = new ZooKeeperMain(zk);    for (String quoteChar : new String[] { "'", "\"" }) {        String cmdstring = String.format("create /node %1$squoted data%1$s", quoteChar);        zkMain.cl.parseCommand(cmdstring);        assertEquals("quotes combine arguments", zkMain.cl.getNumArguments(), 3);        assertEquals("create is not taken as first argument", zkMain.cl.getCmdArgument(0), "create");        assertEquals("/node is not taken as second argument", zkMain.cl.getCmdArgument(1), "/node");        assertEquals("quoted data is not taken as third argument", zkMain.cl.getCmdArgument(2), "quoted data");    }}
testParseWithMixedQuotes
public void zookeeper_f6802_0() throws Exception
{    final ZooKeeper zk = createClient();    ZooKeeperMain zkMain = new ZooKeeperMain(zk);    for (String[] quoteChars : new String[][] { { "'", "\"" }, { "\"", "'" } }) {        String outerQuotes = quoteChars[0];        String innerQuotes = quoteChars[1];        String cmdstring = String.format("create /node %1$s%2$squoted data%2$s%1$s", outerQuotes, innerQuotes);        zkMain.cl.parseCommand(cmdstring);        assertEquals("quotes combine arguments", zkMain.cl.getNumArguments(), 3);        assertEquals("create is not taken as first argument", zkMain.cl.getCmdArgument(0), "create");        assertEquals("/node is not taken as second argument", zkMain.cl.getCmdArgument(1), "/node");        assertEquals("quoted data is not taken as third argument", zkMain.cl.getCmdArgument(2), innerQuotes + "quoted data" + innerQuotes);    }}
testParseWithEmptyQuotes
public void zookeeper_f6803_0() throws Exception
{    final ZooKeeper zk = createClient();    ZooKeeperMain zkMain = new ZooKeeperMain(zk);    String cmdstring = "create /node ''";    zkMain.cl.parseCommand(cmdstring);    assertEquals("empty quotes should produce arguments", zkMain.cl.getNumArguments(), 3);    assertEquals("create is not taken as first argument", zkMain.cl.getCmdArgument(0), "create");    assertEquals("/node is not taken as second argument", zkMain.cl.getCmdArgument(1), "/node");    assertEquals("empty string is not taken as third argument", zkMain.cl.getCmdArgument(2), "");}
testParseWithMultipleQuotes
public void zookeeper_f6804_0() throws Exception
{    final ZooKeeper zk = createClient();    ZooKeeperMain zkMain = new ZooKeeperMain(zk);    String cmdstring = "create /node '' ''";    zkMain.cl.parseCommand(cmdstring);    assertEquals("expected 5 arguments", zkMain.cl.getNumArguments(), 4);    assertEquals("create is not taken as first argument", zkMain.cl.getCmdArgument(0), "create");    assertEquals("/node is not taken as second argument", zkMain.cl.getCmdArgument(1), "/node");    assertEquals("empty string is not taken as third argument", zkMain.cl.getCmdArgument(2), "");    assertEquals("empty string is not taken as fourth argument", zkMain.cl.getCmdArgument(3), "");}
testNonexistantCommand
public void zookeeper_f6805_0() throws Exception
{    testInvalidCommand("cret -s /node1", 127);}
testCreateCommandWithoutPath
public void zookeeper_f6806_0() throws Exception
{    testInvalidCommand("create", 1);}
testCreateEphemeralCommandWithoutPath
public void zookeeper_f6807_0() throws Exception
{    testInvalidCommand("create -e ", 1);}
testCreateSequentialCommandWithoutPath
public void zookeeper_f6808_0() throws Exception
{    testInvalidCommand("create -s ", 1);}
testCreateEphemeralSequentialCommandWithoutPath
public void zookeeper_f6809_0() throws Exception
{    testInvalidCommand("create -s -e ", 1);}
testInvalidCommand
private void zookeeper_f6810_0(String cmdString, int exitCode) throws Exception
{    final ZooKeeper zk = createClient();    ZooKeeperMain zkMain = new ZooKeeperMain(zk);    zkMain.cl.parseCommand(cmdString);        zkMain.processCmd(zkMain.cl);    assertEquals(exitCode, zkMain.exitCode);        try {        zkMain.processZKCmd(zkMain.cl);        fail();    } catch (CliException e) {        return;    }    fail("invalid command should throw CliException");}
testCreateNodeWithoutData
public void zookeeper_f6811_0() throws Exception
{    final ZooKeeper zk = createClient();    ZooKeeperMain zkMain = new ZooKeeperMain(zk);        String cmdstring = "create -s /node ";    zkMain.cl.parseCommand(cmdstring);    assertTrue("Doesn't create node without data", zkMain.processZKCmd(zkMain.cl));        cmdstring = "create  -e /node ";    zkMain.cl.parseCommand(cmdstring);    assertTrue("Doesn't create node without data", zkMain.processZKCmd(zkMain.cl));        cmdstring = "create -s -e /node ";    zkMain.cl.parseCommand(cmdstring);    assertTrue("Doesn't create node without data", zkMain.processZKCmd(zkMain.cl));        cmdstring = "create -s y /node";    zkMain.cl.parseCommand(cmdstring);    try {        assertTrue("Created node with wrong option", zkMain.processZKCmd(zkMain.cl));        fail("Created the node with wrong option should " + "throw Exception.");    } catch (MalformedPathException e) {        assertEquals("Path must start with / character", e.getMessage());    }}
testACLWithExtraAgruments
public void zookeeper_f6812_0() throws Exception
{    final ZooKeeper zk = createClient();    ZooKeeperMain zkMain = new ZooKeeperMain(zk);        String cmdstring = "create -s /l data ip:10.18.52.144:cdrwa f g h";    zkMain.cl.parseCommand(cmdstring);    assertTrue("Not considering the extra arguments after the acls.", zkMain.processZKCmd(zkMain.cl));}
testCreatePersistentNode
public void zookeeper_f6813_0() throws Exception
{    final ZooKeeper zk = createClient();    ZooKeeperMain zkMain = new ZooKeeperMain(zk);    String cmdstring = "create /node2";    zkMain.cl.parseCommand(cmdstring);    assertTrue("Not creating Persistent node.", zkMain.processZKCmd(zkMain.cl));}
testDelete
public void zookeeper_f6814_0() throws Exception
{    final ZooKeeper zk = createClient();    ZooKeeperMain zkMain = new ZooKeeperMain(zk);    String cmdstring1 = "create -e /node2 data";    String cmdstring2 = "delete /node2";    String cmdstring3 = "ls /node2";    zkMain.cl.parseCommand(cmdstring1);    assertTrue(zkMain.processZKCmd(zkMain.cl));    zkMain.cl.parseCommand(cmdstring2);    assertFalse(zkMain.processZKCmd(zkMain.cl));    zkMain.cl.parseCommand(cmdstring3);    assertFalse("", zkMain.processCmd(zkMain.cl));}
testDeleteNonexistantNode
public void zookeeper_f6815_0() throws Exception
{    testInvalidCommand("delete /blahblahblah", 1);}
testStatCommand
public void zookeeper_f6816_0() throws Exception
{    final ZooKeeper zk = createClient();    ZooKeeperMain zkMain = new ZooKeeperMain(zk);    String cmdstring1 = "create -e /node3 data";    String cmdstring2 = "stat /node3";    String cmdstring3 = "delete /node3";    zkMain.cl.parseCommand(cmdstring1);    assertTrue(zkMain.processZKCmd(zkMain.cl));    zkMain.cl.parseCommand(cmdstring2);    assertFalse(zkMain.processZKCmd(zkMain.cl));    zkMain.cl.parseCommand(cmdstring3);    assertFalse(zkMain.processZKCmd(zkMain.cl));}
testInvalidStatCommand
public void zookeeper_f6817_0() throws Exception
{    final ZooKeeper zk = createClient();    ZooKeeperMain zkMain = new ZooKeeperMain(zk);        String cmdstring1 = "stat /node123";    zkMain.cl.parseCommand(cmdstring1);    try {        assertFalse(zkMain.processZKCmd(zkMain.cl));        fail("Path doesn't exists so, command should fail.");    } catch (CliWrapperException e) {        assertEquals(KeeperException.Code.NONODE, ((KeeperException) e.getCause()).code());    }}
testSetData
public void zookeeper_f6818_0() throws Exception
{    final ZooKeeper zk = createClient();    ZooKeeperMain zkMain = new ZooKeeperMain(zk);    String cmdstring1 = "create -e /node4 data";    String cmdstring2 = "set /node4 " + "data";    String cmdstring3 = "delete /node4";    Stat stat = new Stat();    int version = 0;    zkMain.cl.parseCommand(cmdstring1);    assertTrue(zkMain.processZKCmd(zkMain.cl));    stat = zk.exists("/node4", true);    version = stat.getVersion();    zkMain.cl.parseCommand(cmdstring2);    assertFalse(zkMain.processZKCmd(zkMain.cl));    stat = zk.exists("/node4", true);    assertEquals(version + 1, stat.getVersion());    zkMain.cl.parseCommand(cmdstring3);    assertFalse(zkMain.processZKCmd(zkMain.cl));}
testCheckInvalidAcls
public void zookeeper_f6819_0() throws Exception
{    final ZooKeeper zk = createClient();    ZooKeeperMain zkMain = new ZooKeeperMain(zk);        String cmdstring = "create -s -e /node data ip:scheme:gggsd";        zkMain.executeLine(cmdstring);}
testDeleteWithInvalidVersionNo
public void zookeeper_f6820_0() throws Exception
{    final ZooKeeper zk = createClient();    ZooKeeperMain zkMain = new ZooKeeperMain(zk);    String cmdstring = "create -s -e /node1 data ";        String cmdstring1 = "delete /node1 2";    zkMain.executeLine(cmdstring);        zkMain.executeLine(cmdstring1);}
testCliCommandsNotEchoingUsage
public void zookeeper_f6821_0() throws Exception
{            final PrintStream systemErr = System.err;    final ByteArrayOutputStream errContent = new ByteArrayOutputStream();    System.setErr(new PrintStream(errContent));    final ZooKeeper zk = createClient();    ZooKeeperMain zkMain = new ZooKeeperMain(zk);    String cmd1 = "printwatches";    zkMain.executeLine(cmd1);    String cmd2 = "history";    zkMain.executeLine(cmd2);    String cmd3 = "redo";    zkMain.executeLine(cmd3);        System.setErr(systemErr);    if (errContent.toString().contains("ZooKeeper -server host:port cmd args")) {        fail("CLI commands (history, redo, connect, printwatches) display usage info!");    }}
testRedoWithNegativeCmdNumber
public void zookeeper_f6822_0() throws Exception
{    final ZooKeeper zk = createClient();    ZooKeeperMain zkMain = new ZooKeeperMain(zk);    String cmd1 = "redo -1";                final PrintStream systemErr = System.err;    final ByteArrayOutputStream errContent = new ByteArrayOutputStream();    System.setErr(new PrintStream(errContent));    try {        zkMain.executeLine(cmd1);        assertEquals("Command index out of range", errContent.toString().trim());    } finally {                System.setErr(systemErr);    }}
runCommandExpect
private static void zookeeper_f6823_0(CliCommand command, List<String> expectedResults) throws Exception
{        ByteArrayOutputStream byteStream = new ByteArrayOutputStream();    PrintStream out = new PrintStream(byteStream);    command.setOut(out);    command.exec();    String result = byteStream.toString();    assertTrue(result, result.contains(StringUtils.joinStrings(expectedResults, LINE_SEPARATOR)));}
testSortedLs
public void zookeeper_f6824_0() throws Exception
{    final ZooKeeper zk = createClient();    ZooKeeperMain zkMain = new ZooKeeperMain(zk);    zkMain.executeLine("create /aa1");    zkMain.executeLine("create /aa2");    zkMain.executeLine("create /aa3");    zkMain.executeLine("create /test1");    zkMain.executeLine("create /zk1");    LsCommand cmd = new LsCommand();    cmd.setZk(zk);    cmd.parse("ls /".split(" "));    List<String> expected = new ArrayList<String>();    expected.add("[aa1, aa2, aa3, test1, zk1, zookeeper]");    runCommandExpect(cmd, expected);}
testLsrCommand
public void zookeeper_f6825_0() throws Exception
{    final ZooKeeper zk = createClient();    ZooKeeperMain zkMain = new ZooKeeperMain(zk);    zkMain.executeLine("create /a");    zkMain.executeLine("create /a/b");    zkMain.executeLine("create /a/c");    zkMain.executeLine("create /a/b/d");    zkMain.executeLine("create /a/c/e");    zkMain.executeLine("create /a/f");    LsCommand cmd = new LsCommand();    cmd.setZk(zk);    cmd.parse("ls -R /a".split(" "));    List<String> expected = new ArrayList<String>();    expected.add("/a");    expected.add("/a/b");    expected.add("/a/c");    expected.add("/a/f");    expected.add("/a/b/d");    expected.add("/a/c/e");    runCommandExpect(cmd, expected);}
testLsrRootCommand
public void zookeeper_f6826_0() throws Exception
{    final ZooKeeper zk = createClient();    ZooKeeperMain zkMain = new ZooKeeperMain(zk);    LsCommand cmd = new LsCommand();    cmd.setZk(zk);    cmd.parse("ls -R /".split(" "));    List<String> expected = new ArrayList<String>();    expected.add("/");    expected.add("/zookeeper");    runCommandExpect(cmd, expected);}
testLsrLeafCommand
public void zookeeper_f6827_0() throws Exception
{    final ZooKeeper zk = createClient();    ZooKeeperMain zkMain = new ZooKeeperMain(zk);    zkMain.executeLine("create /b");    zkMain.executeLine("create /b/c");    LsCommand cmd = new LsCommand();    cmd.setZk(zk);    cmd.parse("ls -R /b/c".split(" "));    List<String> expected = new ArrayList<String>();    expected.add("/b/c");    runCommandExpect(cmd, expected);}
testLsrNonexistantZnodeCommand
public void zookeeper_f6828_0() throws Exception
{    final ZooKeeper zk = createClient();    ZooKeeperMain zkMain = new ZooKeeperMain(zk);    zkMain.executeLine("create /b");    zkMain.executeLine("create /b/c");    LsCommand cmd = new LsCommand();    cmd.setZk(zk);    cmd.parse("ls -R /b/c/d".split(" "));    try {        runCommandExpect(cmd, new ArrayList<String>());        fail("Path doesn't exists so, command should fail.");    } catch (CliWrapperException e) {        assertEquals(KeeperException.Code.NONODE, ((KeeperException) e.getCause()).code());    }}
testSetAclRecursive
public void zookeeper_f6829_0() throws Exception
{    final ZooKeeper zk = createClient();    final byte[] EMPTY = new byte[0];    zk.setData("/", EMPTY, -1);    zk.create("/a", EMPTY, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/a/b", EMPTY, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/a/b/c", EMPTY, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/a/d", EMPTY, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    zk.create("/e", EMPTY, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);    ZooKeeperMain zkMain = new ZooKeeperMain(zk);    String setAclCommand = "setAcl -R /a world:anyone:r";    zkMain.cl.parseCommand(setAclCommand);    assertFalse(zkMain.processZKCmd(zkMain.cl));    assertEquals(Ids.READ_ACL_UNSAFE, zk.getACL("/a", new Stat()));    assertEquals(Ids.READ_ACL_UNSAFE, zk.getACL("/a/b", new Stat()));    assertEquals(Ids.READ_ACL_UNSAFE, zk.getACL("/a/b/c", new Stat()));    assertEquals(Ids.READ_ACL_UNSAFE, zk.getACL("/a/d", new Stat()));        assertEquals(Ids.OPEN_ACL_UNSAFE, zk.getACL("/e", new Stat()));}
testClientReconnectWithZKClientConfig
public void zookeeper_f6830_0() throws Exception
{    ZooKeeper zk = null;    ZooKeeper newZKClient = null;    try {        zk = createClient();        ZKClientConfig clientConfig = new ZKClientConfig();        clientConfig.setProperty(ZKClientConfig.ZOOKEEPER_CLIENT_CNXN_SOCKET, "org.apache.zookeeper.ClientCnxnSocketNetty");        CountdownWatcher watcher = new CountdownWatcher();        HostProvider aHostProvider = new StaticHostProvider(new ConnectStringParser(hostPort).getServerAddresses());        newZKClient = new ZooKeeper(hostPort, zk.getSessionTimeout(), watcher, zk.getSessionId(), zk.getSessionPasswd(), false, aHostProvider, clientConfig);        watcher.waitForConnected(CONNECTION_TIMEOUT);        assertEquals("Old client session id and new clinet session id must be same", zk.getSessionId(), newZKClient.getSessionId());    } finally {        zk.close();        newZKClient.close();    }}
testSyncCommand
public void zookeeper_f6831_0() throws Exception
{    final ZooKeeper zk = createClient();    SyncCommand cmd = new SyncCommand();    cmd.setZk(zk);    cmd.parse("sync /".split(" "));    List<String> expected = new ArrayList<String>();    expected.add("Sync is OK");    runCommandExpect(cmd, expected);}
