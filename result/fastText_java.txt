7f820eeb69ca0b6ba212f7fa738d25f53ebc1bc5cfb29c2200e154ad62791a65
getValue
public int getValue()
{    return this.value;}
9366082d7b59d78882bd257efa92d581ab198ffa9d9b11478558188c598e8827
fromValue
public static model_name fromValue(int value) throws IllegalArgumentException
{    try {        value -= 1;        return model_name.values()[value];    } catch (ArrayIndexOutOfBoundsException e) {        throw new IllegalArgumentException("Unknown model_name enum value :" + value);    }}
7f820eeb69ca0b6ba212f7fa738d25f53ebc1bc5cfb29c2200e154ad62791a65
getValue
public int getValue()
{    return this.value;}
a2b279961a4d6ac634534135b03a6332360545ccdbba8277a8bc340ce371b422
fromValue
public static loss_name fromValue(int value) throws IllegalArgumentException
{    try {        value -= 1;        return loss_name.values()[value];    } catch (ArrayIndexOutOfBoundsException e) {        throw new IllegalArgumentException("Unknown loss_name enum value :" + value);    }}
c3e114ac418ed2df2a9c0903970d107708abbc41e2ed52c7781a526524f0870d
printHelp
public void printHelp()
{    System.out.println("\n" + "The following arguments are mandatory:\n" + "  -input              training file path\n" + "  -output             output file path\n\n" + "The following arguments are optional:\n" + "  -lr                 learning rate [" + lr + "]\n" + "  -lrUpdateRate       change the rate of updates for the learning rate [" + lrUpdateRate + "]\n" + "  -dim                size of word vectors [" + dim + "]\n" + "  -ws                 size of the context window [" + ws + "]\n" + "  -epoch              number of epochs [" + epoch + "]\n" + "  -minCount           minimal number of word occurences [" + minCount + "]\n" + "  -minCountLabel      minimal number of label occurences [" + minCountLabel + "]\n" + "  -neg                number of negatives sampled [" + neg + "]\n" + "  -wordNgrams         max length of word ngram [" + wordNgrams + "]\n" + "  -loss               loss function {ns, hs, softmax} [ns]\n" + "  -bucket             number of buckets [" + bucket + "]\n" + "  -minn               min length of char ngram [" + minn + "]\n" + "  -maxn               max length of char ngram [" + maxn + "]\n" + "  -thread             number of threads [" + thread + "]\n" + "  -t                  sampling threshold [" + t + "]\n" + "  -label              labels prefix [" + label + "]\n" + "  -verbose            verbosity level [" + verbose + "]\n" + "  -pretrainedVectors  pretrained word vectors for supervised learning []");}
4ce9f8ebe11b9e2148e101376b5f964d78813696da3361f5909f7533d88d28d1
save
public void save(OutputStream ofs) throws IOException
{    IOUtil ioutil = new IOUtil();    ofs.write(ioutil.intToByteArray(dim));    ofs.write(ioutil.intToByteArray(ws));    ofs.write(ioutil.intToByteArray(epoch));    ofs.write(ioutil.intToByteArray(minCount));    ofs.write(ioutil.intToByteArray(neg));    ofs.write(ioutil.intToByteArray(wordNgrams));    ofs.write(ioutil.intToByteArray(loss.value));    ofs.write(ioutil.intToByteArray(model.value));    ofs.write(ioutil.intToByteArray(bucket));    ofs.write(ioutil.intToByteArray(minn));    ofs.write(ioutil.intToByteArray(maxn));    ofs.write(ioutil.intToByteArray(lrUpdateRate));    ofs.write(ioutil.doubleToByteArray(t));}
3a8946cfb43327bb024d4cc4affaeb32da8f3132edaab40015cddaf465c03c6a
load
public void load(InputStream input) throws IOException
{    IOUtil ioutil = new IOUtil();    dim = ioutil.readInt(input);    ws = ioutil.readInt(input);    epoch = ioutil.readInt(input);    minCount = ioutil.readInt(input);    neg = ioutil.readInt(input);    wordNgrams = ioutil.readInt(input);    loss = loss_name.fromValue(ioutil.readInt(input));    model = model_name.fromValue(ioutil.readInt(input));    bucket = ioutil.readInt(input);    minn = ioutil.readInt(input);    maxn = ioutil.readInt(input);    lrUpdateRate = ioutil.readInt(input);    t = ioutil.readDouble(input);}
c6f6b3e68fcdc4484375b13790443dbce16576637df09c3045509419a1cde5d7
parseArgs
public void parseArgs(String[] args)
{    String command = args[0];    if ("supervised".equalsIgnoreCase(command)) {        model = model_name.sup;        loss = loss_name.softmax;        minCount = 1;        minn = 0;        maxn = 0;        lr = 0.1;    } else if ("cbow".equalsIgnoreCase(command)) {        model = model_name.cbow;    }    int ai = 1;    while (ai < args.length) {        if (args[ai].charAt(0) != '-') {            System.out.println("Provided argument without a dash! Usage:");            printHelp();            System.exit(1);        }        if ("-h".equals(args[ai])) {            System.out.println("Here is the help! Usage:");            printHelp();            System.exit(1);        } else if ("-input".equals(args[ai])) {            input = args[ai + 1];        } else if ("-test".equals(args[ai])) {            test = args[ai + 1];        } else if ("-output".equals(args[ai])) {            output = args[ai + 1];        } else if ("-lr".equals(args[ai])) {            lr = Double.parseDouble(args[ai + 1]);        } else if ("-lrUpdateRate".equals(args[ai])) {            lrUpdateRate = Integer.parseInt(args[ai + 1]);        } else if ("-dim".equals(args[ai])) {            dim = Integer.parseInt(args[ai + 1]);        } else if ("-ws".equals(args[ai])) {            ws = Integer.parseInt(args[ai + 1]);        } else if ("-epoch".equals(args[ai])) {            epoch = Integer.parseInt(args[ai + 1]);        } else if ("-minCount".equals(args[ai])) {            minCount = Integer.parseInt(args[ai + 1]);        } else if ("-minCountLabel".equals(args[ai])) {            minCountLabel = Integer.parseInt(args[ai + 1]);        } else if ("-neg".equals(args[ai])) {            neg = Integer.parseInt(args[ai + 1]);        } else if ("-wordNgrams".equals(args[ai])) {            wordNgrams = Integer.parseInt(args[ai + 1]);        } else if ("-loss".equals(args[ai])) {            if ("hs".equalsIgnoreCase(args[ai + 1])) {                loss = loss_name.hs;            } else if ("ns".equalsIgnoreCase(args[ai + 1])) {                loss = loss_name.ns;            } else if ("softmax".equalsIgnoreCase(args[ai + 1])) {                loss = loss_name.softmax;            } else {                System.out.println("Unknown loss: " + args[ai + 1]);                printHelp();                System.exit(1);            }        } else if ("-bucket".equals(args[ai])) {            bucket = Integer.parseInt(args[ai + 1]);        } else if ("-minn".equals(args[ai])) {            minn = Integer.parseInt(args[ai + 1]);        } else if ("-maxn".equals(args[ai])) {            maxn = Integer.parseInt(args[ai + 1]);        } else if ("-thread".equals(args[ai])) {            thread = Integer.parseInt(args[ai + 1]);        } else if ("-t".equals(args[ai])) {            t = Double.parseDouble(args[ai + 1]);        } else if ("-label".equals(args[ai])) {            label = args[ai + 1];        } else if ("-verbose".equals(args[ai])) {            verbose = Integer.parseInt(args[ai + 1]);        } else if ("-pretrainedVectors".equals(args[ai])) {            pretrainedVectors = args[ai + 1];        } else {            System.out.println("Unknown argument: " + args[ai]);            printHelp();            System.exit(1);        }        ai += 2;    }    if (Utils.isEmpty(input) || Utils.isEmpty(output)) {        System.out.println("Empty input or output path.");        printHelp();        System.exit(1);    }    if (wordNgrams <= 1 && maxn == 0) {        bucket = 0;    }}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    StringBuilder builder = new StringBuilder();    builder.append("Args [input=");    builder.append(input);    builder.append(", output=");    builder.append(output);    builder.append(", test=");    builder.append(test);    builder.append(", lr=");    builder.append(lr);    builder.append(", lrUpdateRate=");    builder.append(lrUpdateRate);    builder.append(", dim=");    builder.append(dim);    builder.append(", ws=");    builder.append(ws);    builder.append(", epoch=");    builder.append(epoch);    builder.append(", minCount=");    builder.append(minCount);    builder.append(", minCountLabel=");    builder.append(minCountLabel);    builder.append(", neg=");    builder.append(neg);    builder.append(", wordNgrams=");    builder.append(wordNgrams);    builder.append(", loss=");    builder.append(loss);    builder.append(", model=");    builder.append(model);    builder.append(", bucket=");    builder.append(bucket);    builder.append(", minn=");    builder.append(minn);    builder.append(", maxn=");    builder.append(maxn);    builder.append(", thread=");    builder.append(thread);    builder.append(", t=");    builder.append(t);    builder.append(", label=");    builder.append(label);    builder.append(", verbose=");    builder.append(verbose);    builder.append(", pretrainedVectors=");    builder.append(pretrainedVectors);    builder.append("]");    return builder.toString();}
7f820eeb69ca0b6ba212f7fa738d25f53ebc1bc5cfb29c2200e154ad62791a65
getValue
public int getValue()
{    return this.value;}
1814c44ce56d9e733032b08d40e1d88a1fcb80622f2270a89822136af27bb2f5
fromValue
public static entry_type fromValue(int value) throws IllegalArgumentException
{    try {        return entry_type.values()[value];    } catch (ArrayIndexOutOfBoundsException e) {        throw new IllegalArgumentException("Unknown entry_type enum value :" + value);    }}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return value == 0 ? "word" : value == 1 ? "label" : "unknown";}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    StringBuilder builder = new StringBuilder();    builder.append("entry [word=");    builder.append(word);    builder.append(", count=");    builder.append(count);    builder.append(", type=");    builder.append(type);    builder.append(", subwords=");    builder.append(subwords);    builder.append("]");    return builder.toString();}
b2c1118f88c26d416ba3b101505cd32b9a282b885d75741c216957ef1f32823b
find
public long find(final String w)
{    long h = hash(w) % MAX_VOCAB_SIZE;    entry e = null;    while (Utils.mapGetOrDefault(word2int_, h, WORDID_DEFAULT) != WORDID_DEFAULT && ((e = words_.get(word2int_.get(h))) != null && !w.equals(e.word))) {        h = (h + 1) % MAX_VOCAB_SIZE;    }    return h;}
337ebb9fcb0fc0a221664328399ee99545d3401424d3dcf97babcb7ea85b5970
add
public void add(final String w)
{    long h = find(w);    ntokens_++;    if (Utils.mapGetOrDefault(word2int_, h, WORDID_DEFAULT) == WORDID_DEFAULT) {        entry e = new entry();        e.word = w;        e.count = 1;        e.type = w.startsWith(args_.label) ? entry_type.label : entry_type.word;        words_.add(e);        word2int_.put(h, size_++);    } else {        words_.get(word2int_.get(h)).count++;    }}
32b4c8c917300e2e071916834280ae4ab99ca8225738f1d2934f9daa21f9176d
nwords
public int nwords()
{    return nwords_;}
8c23d141df36325da00d4d1ecde36df34341f0d7ce8f42bd3271dec925278d10
nlabels
public int nlabels()
{    return nlabels_;}
fad0f79bad3451b0aa93bc70cd3e158249f75d871e695f85ff6675ac461a3fd3
ntokens
public long ntokens()
{    return ntokens_;}
6acecd5dd70252bd6bb6138affbb90af5b62c1fb29b5b99f5fa41b72478fd066
getNgrams
public final List<Integer> getNgrams(int i)
{    Utils.checkArgument(i >= 0);    Utils.checkArgument(i < nwords_);    return words_.get(i).subwords;}
f82b051e2063f898d28353e1155ae28702b55d1a02c8c6f3b8d274f1dd168c7d
getNgrams
public final List<Integer> getNgrams(final String word)
{    List<Integer> ngrams = new ArrayList<Integer>();    int i = getId(word);    if (i >= 0) {        ngrams = words_.get(i).subwords;    } else {        computeNgrams(BOW + word + EOW, ngrams);    }    return ngrams;}
64bf7cf73a5f3025d3387f0d58cf66bfb59ae1cf76ef3ea1b0030de57143b8f3
discard
public boolean discard(int id, float rand)
{    Utils.checkArgument(id >= 0);    Utils.checkArgument(id < nwords_);    if (args_.model == model_name.sup)        return false;    return rand > pdiscard_.get(id);}
3d9990f4b586404240cc788ab7fb328c634c0faa54bc7a1bc6804726bc312eed
getId
public int getId(final String w)
{    long h = find(w);    return Utils.mapGetOrDefault(word2int_, h, WORDID_DEFAULT);}
28986b2ceb352b0256d8f9217c17691bc005ea7fffb8f9de514cecdb87d76eeb
getType
public entry_type getType(int id)
{    Utils.checkArgument(id >= 0);    Utils.checkArgument(id < size_);    return words_.get(id).type;}
e711721b5400596622d245a26a77c311385561ddd4465ed0e44f6fb0cae3a04b
getWord
public String getWord(int id)
{    Utils.checkArgument(id >= 0);    Utils.checkArgument(id < size_);    return words_.get(id).word;}
53a2dcbd03302f2325287c5dc8e7030e928c3fb6b0ef2dbe0f8a4cc560039148
hash
public long hash(final String str)
{        int h = (int) 2166136261L;    for (byte strByte : str.getBytes()) {                h = (h ^ strByte) * 16777619;        }    return h & 0xffffffffL;}
6281a11d33475157ae2d74c61f6e58ec73ab41c9c6e6a74a731fe7bf8be7a881
computeNgrams
public void computeNgrams(final String word, List<Integer> ngrams)
{    for (int i = 0; i < word.length(); i++) {        StringBuilder ngram = new StringBuilder();        if (charMatches(word.charAt(i))) {            continue;        }        for (int j = i, n = 1; j < word.length() && n <= args_.maxn; n++) {            ngram.append(word.charAt(j++));            while (j < word.length() && charMatches(word.charAt(j))) {                ngram.append(word.charAt(j++));            }            if (n >= args_.minn && !(n == 1 && (i == 0 || j == word.length()))) {                int h = (int) (nwords_ + (hash(ngram.toString()) % args_.bucket));                if (h < 0) {                    System.err.println("computeNgrams h<0: " + h + " on word: " + word);                }                ngrams.add(h);            }        }    }}
e490496ee8223a9cac6c296e9b45529f60b4c5c14e1726f977c6e2d82a47b8ab
charMatches
private boolean charMatches(char ch)
{    if (ch == ' ' || ch == '\t' || ch == '\n' || ch == '\f' || ch == '\r') {        return true;    }    return false;}
a93c328887fbf74e8a8f5f514f2cd6122b8ec558f91cf8d66eecb9bebce1fb26
initNgrams
public void initNgrams()
{    for (int i = 0; i < size_; i++) {        String word = BOW + words_.get(i).word + EOW;        entry e = words_.get(i);        if (e.subwords == null) {            e.subwords = new ArrayList<Integer>();        }        e.subwords.add(i);        computeNgrams(word, e.subwords);    }}
6c64452625f2a64fe425e793423928e7bb7e9f53ee03be44f61270dc2524b93c
readFromFile
public void readFromFile(String file) throws IOException, Exception
{    LineReader lineReader = null;    try {        lineReader = lineReaderClass_.getConstructor(String.class, String.class).newInstance(file, charsetName_);        long minThreshold = 1;        String[] lineTokens;        while ((lineTokens = lineReader.readLineTokens()) != null) {            for (int i = 0; i <= lineTokens.length; i++) {                if (i == lineTokens.length) {                    add(EOS);                } else {                    if (Utils.isEmpty(lineTokens[i])) {                        continue;                    }                    add(lineTokens[i]);                }                if (ntokens_ % 1000000 == 0 && args_.verbose > 1) {                    System.out.printf("\rRead %dM words", ntokens_ / 1000000);                }                if (size_ > 0.75 * MAX_VOCAB_SIZE) {                    minThreshold++;                    threshold(minThreshold, minThreshold);                }            }        }    } finally {        if (lineReader != null) {            lineReader.close();        }    }    threshold(args_.minCount, args_.minCountLabel);    initTableDiscard();    if (model_name.cbow == args_.model || model_name.sg == args_.model) {        initNgrams();    }    if (args_.verbose > 0) {        System.out.printf("\rRead %dM words\n", ntokens_ / 1000000);        System.out.println("Number of words:  " + nwords_);        System.out.println("Number of labels: " + nlabels_);    }    if (size_ == 0) {        System.err.println("Empty vocabulary. Try a smaller -minCount value.");        System.exit(1);    }}
b13a4d70f6da2fef6b2a8ab232defdd2db1d3f08ce045e56c33ac97b3fe60f60
threshold
public void threshold(long t, long tl)
{    Collections.sort(words_, entry_comparator);    Iterator<entry> iterator = words_.iterator();    while (iterator.hasNext()) {        entry _entry = iterator.next();        if ((entry_type.word == _entry.type && _entry.count < t) || (entry_type.label == _entry.type && _entry.count < tl)) {            iterator.remove();        }    }    ((ArrayList<entry>) words_).trimToSize();    size_ = 0;    nwords_ = 0;    nlabels_ = 0;        word2int_ = new HashMap<Long, Integer>(words_.size());    for (entry _entry : words_) {        long h = find(_entry.word);        word2int_.put(h, size_++);        if (entry_type.word == _entry.type) {            nwords_++;        } else if (entry_type.label == _entry.type) {            nlabels_++;        }    }}
3286e129e183ef266b9cd395368ff7a1f4861ff6dc60b1a1a6482eb7e4977d6b
compare
public int compare(entry o1, entry o2)
{    int cmp = (o1.type.value < o2.type.value) ? -1 : ((o1.type.value == o2.type.value) ? 0 : 1);    if (cmp == 0) {        cmp = (o2.count < o1.count) ? -1 : ((o2.count == o1.count) ? 0 : 1);    }    return cmp;}
b60354e1eb641a6d93e723ba33878ef25e33f0001907a5b51dc461c2c329a311
initTableDiscard
public void initTableDiscard()
{    pdiscard_ = new ArrayList<Float>(size_);    for (int i = 0; i < size_; i++) {        float f = (float) (words_.get(i).count) / (float) ntokens_;        pdiscard_.add((float) (Math.sqrt(args_.t / f) + args_.t / f));    }}
5f2c5046c172bb8f45df15f1ac71fd6822dd1b7fe6b40c6488560324ec453f48
getCounts
public List<Long> getCounts(entry_type type)
{    List<Long> counts = entry_type.label == type ? new ArrayList<Long>(nlabels()) : new ArrayList<Long>(nwords());    for (entry w : words_) {        if (w.type == type)            counts.add(w.count);    }    return counts;}
5c1e8c148e012fd1877ccad07522f2abbee6c650d523629c4cce32e30fcfb100
addNgrams
public void addNgrams(List<Integer> line, int n)
{    if (n <= 1) {        return;    }    int line_size = line.size();    for (int i = 0; i < line_size; i++) {        BigInteger h = BigInteger.valueOf(line.get(i));        BigInteger r = BigInteger.valueOf(116049371l);        BigInteger b = BigInteger.valueOf(args_.bucket);        for (int j = i + 1; j < line_size && j < i + n; j++) {            h = h.multiply(r).add(BigInteger.valueOf(line.get(j)));            ;            line.add(nwords_ + h.remainder(b).intValue());        }    }}
22669849e525846b2e6e4a97487092228d200dc35f0b3a5506bfec25d9f74689
getLine
public int getLine(String[] tokens, List<Integer> words, List<Integer> labels, Random urd)
{    int ntokens = 0;    words.clear();    labels.clear();    if (tokens != null) {        for (int i = 0; i <= tokens.length; i++) {            if (i < tokens.length && Utils.isEmpty(tokens[i])) {                continue;            }            int wid = i == tokens.length ? getId(EOS) : getId(tokens[i]);            if (wid < 0) {                continue;            }            entry_type type = getType(wid);            ntokens++;            if (type == entry_type.word && !discard(wid, Utils.randomFloat(urd, 0, 1))) {                words.add(wid);            }            if (type == entry_type.label) {                labels.add(wid - nwords_);            }            if (words.size() > MAX_LINE_SIZE && args_.model != model_name.sup) {                break;            }                                }    }    return ntokens;}
52f4eca9a494c95446647d17c0bcf1329fba40b5803095faea70cec57ba890ae
getLabel
public String getLabel(int lid)
{    Utils.checkArgument(lid >= 0);    Utils.checkArgument(lid < nlabels_);    return words_.get(lid + nwords_).word;}
4ce9f8ebe11b9e2148e101376b5f964d78813696da3361f5909f7533d88d28d1
save
public void save(OutputStream ofs) throws IOException
{    IOUtil ioutil = new IOUtil();    ofs.write(ioutil.intToByteArray(size_));    ofs.write(ioutil.intToByteArray(nwords_));    ofs.write(ioutil.intToByteArray(nlabels_));    ofs.write(ioutil.longToByteArray(ntokens_));        for (int i = 0; i < size_; i++) {        entry e = words_.get(i);        ofs.write(e.word.getBytes());        ofs.write(0);        ofs.write(ioutil.longToByteArray(e.count));        ofs.write(ioutil.intToByte(e.type.value));    }}
442ea81048720b62bb8b74c992eada371194bc442c7695e103fe71c5bebe254b
load
public void load(InputStream ifs) throws IOException
{            IOUtil ioutil = new IOUtil();    size_ = ioutil.readInt(ifs);    nwords_ = ioutil.readInt(ifs);    nlabels_ = ioutil.readInt(ifs);    ntokens_ = ioutil.readLong(ifs);    word2int_ = new HashMap<Long, Integer>(size_);    words_ = new ArrayList<entry>(size_);    for (int i = 0; i < size_; i++) {        entry e = new entry();        e.word = ioutil.readString(ifs);        e.count = ioutil.readLong(ifs);        e.type = entry_type.fromValue(ioutil.readByte(ifs));        words_.add(e);        word2int_.put(find(e.word), i);    }    initTableDiscard();    if (model_name.cbow == args_.model || model_name.sg == args_.model) {        initNgrams();    }}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    StringBuilder builder = new StringBuilder();    builder.append("Dictionary [words_=");    builder.append(words_);    builder.append(", pdiscard_=");    builder.append(pdiscard_);    builder.append(", word2int_=");    builder.append(word2int_);    builder.append(", size_=");    builder.append(size_);    builder.append(", nwords_=");    builder.append(nwords_);    builder.append(", nlabels_=");    builder.append(nlabels_);    builder.append(", ntokens_=");    builder.append(ntokens_);    builder.append("]");    return builder.toString();}
21b41361d37ea260037fab818323bb69e52834918751bc9d245406330b051979
getWords
public List<entry> getWords()
{    return words_;}
fa8253d166570e5ab9c7b2153cc85c805364b62d9c2f27fe77e4361d39a6f524
getPdiscard
public List<Float> getPdiscard()
{    return pdiscard_;}
caa3868b3c5669cea648d4f586d524bf4dc2cb72e05134a1e2b79e401cfeb4d1
getWord2int
public Map<Long, Integer> getWord2int()
{    return word2int_;}
941db94d6268e6af95af0456d14a8e0ddcf7f7ed2bb867b918ae21dbe3f2de3d
getSize
public int getSize()
{    return size_;}
e4a8231e4250db06fc8351b7ac35c8ab193736d89381d955f1ac290275c6f96f
getArgs
public Args getArgs()
{    return args_;}
383e00a711f8d23620e8bb2e8791ed6085e1fb5582de5a35ec761091a534d035
getCharsetName
public String getCharsetName()
{    return charsetName_;}
d63cdc7ea32669152bd231f01d39d28225f21f70def3c2ec8d54c089c99a8584
getLineReaderClass
public Class<? extends LineReader> getLineReaderClass()
{    return lineReaderClass_;}
a75fa92f246a2e9c0d0e5ec3993defa26388a63747a0450395002075dab6771b
setCharsetName
public void setCharsetName(String charsetName)
{    this.charsetName_ = charsetName;}
47d80552966f7dfca3dc353b6b62dd9768b8cac76e0501084b30466d2d12d303
setLineReaderClass
public void setLineReaderClass(Class<? extends LineReader> lineReaderClass)
{    this.lineReaderClass_ = lineReaderClass;}
7bc6e99fed3d9888d4699b76f3f23fef15c0e64001659db920d4a099f502fa9f
getVector
public void getVector(Vector vec, final String word)
{    final List<Integer> ngrams = dict_.getNgrams(word);    vec.zero();    for (Integer it : ngrams) {        vec.addRow(input_, it);    }    if (ngrams.size() > 0) {        vec.mul(1.0f / ngrams.size());    }}
9d30f691aca09b65be2964e13fcddcc81a760821aedf46deb4eb877bcc8d6d00
saveVectors
public void saveVectors() throws IOException
{    if (Utils.isEmpty(args_.output)) {        if (args_.verbose > 1) {            System.out.println("output is empty, skip save vector file");        }        return;    }    File file = new File(args_.output + ".vec");    if (file.exists()) {        file.delete();    }    if (file.getParentFile() != null) {        file.getParentFile().mkdirs();    }    if (args_.verbose > 1) {        System.out.println("Saving Vectors to " + file.getCanonicalPath().toString());    }    Vector vec = new Vector(args_.dim);    DecimalFormat df = new DecimalFormat("0.#####");    Writer writer = new OutputStreamWriter(new BufferedOutputStream(new FileOutputStream(file)), "UTF-8");    try {        writer.write(dict_.nwords() + " " + args_.dim + "\n");        for (int i = 0; i < dict_.nwords(); i++) {            String word = dict_.getWord(i);            getVector(vec, word);            writer.write(word);            for (int j = 0; j < vec.m_; j++) {                writer.write(" ");                writer.write(df.format(vec.data_[j]));            }            writer.write("\n");        }    } finally {        writer.flush();        writer.close();    }}
d00258dab180c3b5dc6c6eb9449c2fc0b692ccf46ea4b8ad11f87a9d3ad00569
saveModel
public void saveModel() throws IOException
{    if (Utils.isEmpty(args_.output)) {        if (args_.verbose > 1) {            System.out.println("output is empty, skip save model file");        }        return;    }    File file = new File(args_.output + ".bin");    if (file.exists()) {        file.delete();    }    if (file.getParentFile() != null) {        file.getParentFile().mkdirs();    }    if (args_.verbose > 1) {        System.out.println("Saving model to " + file.getCanonicalPath().toString());    }    OutputStream ofs = new BufferedOutputStream(new FileOutputStream(file));    try {        args_.save(ofs);        dict_.save(ofs);        input_.save(ofs);        output_.save(ofs);    } finally {        ofs.flush();        ofs.close();    }}
4647a858c3be618ccb488ee2dd84cab975054c770998d577e170528b078b62b1
loadModel
public void loadModel(String filename) throws IOException
{    DataInputStream dis = null;    BufferedInputStream bis = null;    try {        File file = new File(filename);        if (!(file.exists() && file.isFile() && file.canRead())) {            throw new IOException("Model file cannot be opened for loading!");        }        bis = new BufferedInputStream(new FileInputStream(file));        dis = new DataInputStream(bis);        args_ = new Args();        dict_ = new Dictionary(args_);        input_ = new Matrix();        output_ = new Matrix();        args_.load(dis);        dict_.load(dis);        input_.load(dis);        output_.load(dis);        model_ = new Model(input_, output_, args_, 0);        if (args_.model == model_name.sup) {            model_.setTargetCounts(dict_.getCounts(entry_type.label));        } else {            model_.setTargetCounts(dict_.getCounts(entry_type.word));        }    } finally {        if (bis != null) {            bis.close();        }        if (dis != null) {            dis.close();        }    }}
c3b5de16a790954a96365bc1866403f8045c269994e04388bf28ed25299a0869
printInfo
public void printInfo(float progress, float loss)
{    float t = (float) (System.currentTimeMillis() - start_) / 1000;    float ws = (float) (tokenCount_.get()) / t;    float wst = (float) (tokenCount_.get()) / t / args_.thread;    float lr = (float) (args_.lr * (1.0f - progress));    int eta = (int) (t / progress * (1 - progress));    int etah = eta / 3600;    int etam = (eta - etah * 3600) / 60;    System.out.printf("\rProgress: %.1f%% words/sec: %d words/sec/thread: %d lr: %.6f loss: %.6f eta: %d h %d m", 100 * progress, (int) ws, (int) wst, lr, loss, etah, etam);}
3cfcfb1e8fa4d9b87f753fe086954ce7031860dfa560cdd181824689199c6ceb
supervised
public void supervised(Model model, float lr, final List<Integer> line, final List<Integer> labels)
{    if (labels.size() == 0 || line.size() == 0)        return;    int i = Utils.randomInt(model.rng, 1, labels.size()) - 1;    model.update(line, labels.get(i), lr);}
6d964632a3ab7658c91170e97d82d46f3c76d48febc5654e7a44dec2bb797230
cbow
public void cbow(Model model, float lr, final List<Integer> line)
{    List<Integer> bow = new ArrayList<Integer>();    for (int w = 0; w < line.size(); w++) {        int boundary = Utils.randomInt(model.rng, 1, args_.ws);        bow.clear();        for (int c = -boundary; c <= boundary; c++) {            if (c != 0 && w + c >= 0 && w + c < line.size()) {                final List<Integer> ngrams = dict_.getNgrams(line.get(w + c));                bow.addAll(ngrams);            }        }        model.update(bow, line.get(w), lr);    }}
3216a20cfd373ff54ed31e2143abc9eff7177e8cc5eb8a5be00c45dda3ebc9c9
skipgram
public void skipgram(Model model, float lr, final List<Integer> line)
{    for (int w = 0; w < line.size(); w++) {        int boundary = Utils.randomInt(model.rng, 1, args_.ws);        final List<Integer> ngrams = dict_.getNgrams(line.get(w));        for (int c = -boundary; c <= boundary; c++) {            if (c != 0 && w + c >= 0 && w + c < line.size()) {                model.update(ngrams, line.get(w + c), lr);            }        }    }}
857c1396be03e762c4cc268825a550eba54a999e1f3f1706abf1ecd15afd6225
test
public void test(InputStream in, int k) throws IOException, Exception
{    int nexamples = 0, nlabels = 0;    double precision = 0.0f;    List<Integer> line = new ArrayList<Integer>();    List<Integer> labels = new ArrayList<Integer>();    LineReader lineReader = null;    try {        lineReader = lineReaderClass_.getConstructor(InputStream.class, String.class).newInstance(in, charsetName_);        String[] lineTokens;        while ((lineTokens = lineReader.readLineTokens()) != null) {            if (lineTokens.length == 1 && "quit".equals(lineTokens[0])) {                break;            }            dict_.getLine(lineTokens, line, labels, model_.rng);            dict_.addNgrams(line, args_.wordNgrams);            if (labels.size() > 0 && line.size() > 0) {                List<Pair<Float, Integer>> modelPredictions = new ArrayList<Pair<Float, Integer>>();                model_.predict(line, k, modelPredictions);                for (Pair<Float, Integer> pair : modelPredictions) {                    if (labels.contains(pair.getValue())) {                        precision += 1.0f;                    }                }                nexamples++;                nlabels += labels.size();                                                }        }    } finally {        if (lineReader != null) {            lineReader.close();        }    }    System.out.printf("P@%d: %.3f%n", k, precision / (k * nexamples));    System.out.printf("R@%d: %.3f%n", k, precision / nlabels);    System.out.println("Number of examples: " + nexamples);}
937c6a9779af0c17520422537cb000b1160f3cc92b8bd80653fb4b58a6c19cbc
predict
public List<Pair<Float, String>> predict(String[] lineTokens, int k)
{    List<Integer> words = new ArrayList<Integer>();    List<Integer> labels = new ArrayList<Integer>();    dict_.getLine(lineTokens, words, labels, model_.rng);    dict_.addNgrams(words, args_.wordNgrams);    if (words.isEmpty()) {        return null;    }    Vector hidden = new Vector(args_.dim);    Vector output = new Vector(dict_.nlabels());    List<Pair<Float, Integer>> modelPredictions = new ArrayList<Pair<Float, Integer>>(k + 1);    model_.predict(words, k, modelPredictions, hidden, output);    List<Pair<Float, String>> predictions = new ArrayList<Pair<Float, String>>(k);    for (Pair<Float, Integer> pair : modelPredictions) {        predictions.add(new Pair<Float, String>(pair.getKey(), dict_.getLabel(pair.getValue())));    }    return predictions;}
d6c54df68f575a079bc5fc5a050a2914979d468edd01b2f5c1199351c92c1a18
predict
public void predict(String[] lineTokens, int k, List<Pair<Float, String>> predictions) throws IOException
{    List<Integer> words = new ArrayList<Integer>();    List<Integer> labels = new ArrayList<Integer>();    dict_.getLine(lineTokens, words, labels, model_.rng);    dict_.addNgrams(words, args_.wordNgrams);    if (words.isEmpty()) {        return;    }    List<Pair<Float, Integer>> modelPredictions = new ArrayList<Pair<Float, Integer>>(k + 1);    model_.predict(words, k, modelPredictions);    predictions.clear();    for (Pair<Float, Integer> pair : modelPredictions) {        predictions.add(new Pair<Float, String>(pair.getKey(), dict_.getLabel(pair.getValue())));    }}
7e53510afcc8f48e1027229b0c6c3c834f31a3325accb4524e5ccdb4c88b02a0
predict
public void predict(InputStream in, int k, boolean print_prob) throws IOException, Exception
{    List<Pair<Float, String>> predictions = new ArrayList<Pair<Float, String>>(k);    LineReader lineReader = null;    try {        lineReader = lineReaderClass_.getConstructor(InputStream.class, String.class).newInstance(in, charsetName_);        String[] lineTokens;        while ((lineTokens = lineReader.readLineTokens()) != null) {            if (lineTokens.length == 1 && "quit".equals(lineTokens[0])) {                break;            }            predictions.clear();            predict(lineTokens, k, predictions);            if (predictions.isEmpty()) {                System.out.println("n/a");                continue;            }            for (Pair<Float, String> pair : predictions) {                System.out.print(pair.getValue());                if (print_prob) {                    System.out.printf(" %f", Math.exp(pair.getKey()));                }            }            System.out.println();        }    } finally {        if (lineReader != null) {            lineReader.close();        }    }}
cc1edca6aaadb2e2e635fedf51de0a3978440a6e4c2da4e3fc1b264a9c56b87c
wordVectors
public void wordVectors()
{    Vector vec = new Vector(args_.dim);    LineReader lineReader = null;    try {        lineReader = lineReaderClass_.getConstructor(InputStream.class, String.class).newInstance(System.in, charsetName_);        String word;        while (!Utils.isEmpty((word = lineReader.readLine()))) {            getVector(vec, word);            System.out.println(word + " " + vec);        }    } catch (Exception e) {        e.printStackTrace();    } finally {        if (lineReader != null) {            try {                lineReader.close();            } catch (IOException e) {                e.printStackTrace();            }        }    }}
38df44b40970f00ac8db529ba5b0e53cb579f45f8e00493adfad9559f3602eb6
textVectors
public void textVectors()
{    List<Integer> line = new ArrayList<Integer>();    List<Integer> labels = new ArrayList<Integer>();    Vector vec = new Vector(args_.dim);    LineReader lineReader = null;    try {        lineReader = lineReaderClass_.getConstructor(InputStream.class, String.class).newInstance(System.in, charsetName_);        String[] lineTokens;        while ((lineTokens = lineReader.readLineTokens()) != null) {            if (lineTokens.length == 1 && "quit".equals(lineTokens[0])) {                break;            }            dict_.getLine(lineTokens, line, labels, model_.rng);            dict_.addNgrams(line, args_.wordNgrams);            vec.zero();            for (Integer it : line) {                vec.addRow(input_, it);            }            if (!line.isEmpty()) {                vec.mul(1.0f / line.size());            }            System.out.println(vec);        }    } catch (Exception e) {        e.printStackTrace();    } finally {        if (lineReader != null) {            try {                lineReader.close();            } catch (IOException e) {                e.printStackTrace();            }        }    }}
05dd35e9636e9bf09b2355c7c48cfbd1a855db354dca191e7a90d60b9ae008d4
printVectors
public void printVectors()
{    if (args_.model == model_name.sup) {        textVectors();    } else {        wordVectors();    }}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    if (args_.verbose > 2) {        System.out.println("thread: " + threadId + " RUNNING!");    }    Exception catchedException = null;    LineReader lineReader = null;    try {        lineReader = lineReaderClass_.getConstructor(String.class, String.class).newInstance(args_.input, charsetName_);        lineReader.skipLine(threadId * threadFileSize / args_.thread);        Model model = new Model(input_, output_, args_, threadId);        if (args_.model == model_name.sup) {            model.setTargetCounts(dict_.getCounts(entry_type.label));        } else {            model.setTargetCounts(dict_.getCounts(entry_type.word));        }        final long ntokens = dict_.ntokens();        long localTokenCount = 0;        List<Integer> line = new ArrayList<Integer>();        List<Integer> labels = new ArrayList<Integer>();        String[] lineTokens;        while (tokenCount_.get() < args_.epoch * ntokens) {            lineTokens = lineReader.readLineTokens();            if (lineTokens == null) {                try {                    lineReader.rewind();                    if (args_.verbose > 2) {                        System.out.println("Input file reloaded!");                    }                } catch (Exception e) {                    e.printStackTrace();                }                lineTokens = lineReader.readLineTokens();            }            float progress = (float) (tokenCount_.get()) / (args_.epoch * ntokens);            float lr = (float) (args_.lr * (1.0 - progress));            localTokenCount += dict_.getLine(lineTokens, line, labels, model.rng);            if (args_.model == model_name.sup) {                dict_.addNgrams(line, args_.wordNgrams);                if (labels.size() == 0 || line.size() == 0) {                    continue;                }                supervised(model, lr, line, labels);            } else if (args_.model == model_name.cbow) {                cbow(model, lr, line);            } else if (args_.model == model_name.sg) {                skipgram(model, lr, line);            }            if (localTokenCount > args_.lrUpdateRate) {                tokenCount_.addAndGet(localTokenCount);                localTokenCount = 0;                if (threadId == 0 && args_.verbose > 1 && (System.currentTimeMillis() - start_) % 1000 == 0) {                    printInfo(progress, model.getLoss());                }            }        }        if (threadId == 0 && args_.verbose > 1) {            printInfo(1.0f, model.getLoss());        }    } catch (Exception e) {        catchedException = e;    } finally {        if (lineReader != null)            try {                lineReader.close();            } catch (IOException e) {                e.printStackTrace();            }    }        synchronized (ft) {        if (args_.verbose > 2) {            System.out.println("\nthread: " + threadId + " EXIT!");        }        ft.threadCount--;        ft.notify();        if (catchedException != null) {            throw new RuntimeException(catchedException);        }    }}
560ff946205c94f2ed09326456e933b31f106897266920cf577663d632e770ba
loadVectors
public void loadVectors(String filename) throws IOException
{    List<String> words;        Matrix mat;    int n, dim;    BufferedReader dis = null;    String line;    String[] lineParts;    try {        dis = new BufferedReader(new InputStreamReader(new FileInputStream(filename), "UTF-8"));        line = dis.readLine();        lineParts = line.split(" ");        n = Integer.parseInt(lineParts[0]);        dim = Integer.parseInt(lineParts[1]);        words = new ArrayList<String>(n);        if (dim != args_.dim) {            throw new IllegalArgumentException("Dimension of pretrained vectors does not match args -dim option, pretrain dim is " + dim + ", args dim is " + args_.dim);        }        mat = new Matrix(n, dim);        for (int i = 0; i < n; i++) {            line = dis.readLine();            lineParts = line.split(" ");            String word = lineParts[0];            for (int j = 1; j <= dim; j++) {                mat.data_[i][j - 1] = Float.parseFloat(lineParts[j]);            }            words.add(word);            dict_.add(word);        }        dict_.threshold(1, 0);        input_ = new Matrix(dict_.nwords() + args_.bucket, args_.dim);        input_.uniform(1.0f / args_.dim);        for (int i = 0; i < n; i++) {            int idx = dict_.getId(words.get(i));            if (idx < 0 || idx >= dict_.nwords())                continue;            for (int j = 0; j < dim; j++) {                input_.data_[idx][j] = mat.data_[i][j];            }        }    } catch (IOException e) {        throw new IOException("Pretrained vectors file cannot be opened!", e);    } finally {        try {            if (dis != null) {                dis.close();            }        } catch (IOException e) {            e.printStackTrace();        }    }}
c943ffc01ad9f69bfe38d9efa339741f823cb111517aabfa76872e4e2dbfd148
train
public void train(Args args) throws IOException, Exception
{    args_ = args;    dict_ = new Dictionary(args_);    dict_.setCharsetName(charsetName_);    dict_.setLineReaderClass(lineReaderClass_);    if ("-".equals(args_.input)) {        throw new IOException("Cannot use stdin for training!");    }    File file = new File(args_.input);    if (!(file.exists() && file.isFile() && file.canRead())) {        throw new IOException("Input file cannot be opened! " + args_.input);    }    dict_.readFromFile(args_.input);    threadFileSize = Utils.sizeLine(args_.input);    if (!Utils.isEmpty(args_.pretrainedVectors)) {        loadVectors(args_.pretrainedVectors);    } else {        input_ = new Matrix(dict_.nwords() + args_.bucket, args_.dim);        input_.uniform(1.0f / args_.dim);    }    if (args_.model == model_name.sup) {        output_ = new Matrix(dict_.nlabels(), args_.dim);    } else {        output_ = new Matrix(dict_.nwords(), args_.dim);    }    output_.zero();    start_ = System.currentTimeMillis();    tokenCount_ = new AtomicLong(0);    long t0 = System.currentTimeMillis();    threadCount = args_.thread;    for (int i = 0; i < args_.thread; i++) {        Thread t = new TrainThread(this, i);        t.setUncaughtExceptionHandler(trainThreadExcpetionHandler);        t.start();    }    synchronized (this) {        while (threadCount > 0) {            try {                wait();            } catch (InterruptedException ignored) {            }        }    }    model_ = new Model(input_, output_, args_, 0);    if (args.verbose > 1) {        long trainTime = (System.currentTimeMillis() - t0) / 1000;        System.out.printf("\nTrain time used: %d sec\n", trainTime);    }    saveModel();    if (args_.model != model_name.sup) {        saveVectors();    }}
cd9cdd6a27f508fb94de676d29f280ab5a72cc93d1ea94bf3c85e93d16846fcf
uncaughtException
public void uncaughtException(Thread th, Throwable ex)
{    ex.printStackTrace();}
e4a8231e4250db06fc8351b7ac35c8ab193736d89381d955f1ac290275c6f96f
getArgs
public Args getArgs()
{    return args_;}
708504c55a5671e4d19e2438662ea3960d60d4fd3a8720f1e78458b7973fc574
getDict
public Dictionary getDict()
{    return dict_;}
b3a397c6c9c9fc262a50cbbb79e8daedfabffe6f663008c1ba174140b1c9bfed
getInput
public Matrix getInput()
{    return input_;}
e553a0acac76bd28f258119b7f4d499347decac6141bf2437e5251a6c5b818ec
getOutput
public Matrix getOutput()
{    return output_;}
f938998a08eadbdbb54a4592f85c356494c5fd4a09480ef41473d448461d6a49
getModel
public Model getModel()
{    return model_;}
8d290d4850927790eaff67c84222137c0d75177f5544e3c0ffccea0049418111
setArgs
public void setArgs(Args args)
{    this.args_ = args;}
cf7e3030be8245c6dd8f05d443686fabc418da04e5f87354614fb4482ee0fa0d
setDict
public void setDict(Dictionary dict)
{    this.dict_ = dict;}
3ed757e4f1d0bfdab5d9cd5405644435765a9f511e39f07b884eb199920b389d
setInput
public void setInput(Matrix input)
{    this.input_ = input;}
32955ffd3085a1ee49047d933cc09f74688ea88ca50553f400558d3ceccb70af
setOutput
public void setOutput(Matrix output)
{    this.output_ = output;}
bed66aab2d230f0da58021af59b552451fbdb0495ff7e0cfeed543eadd9b29bc
setModel
public void setModel(Model model)
{    this.model_ = model;}
383e00a711f8d23620e8bb2e8791ed6085e1fb5582de5a35ec761091a534d035
getCharsetName
public String getCharsetName()
{    return charsetName_;}
d63cdc7ea32669152bd231f01d39d28225f21f70def3c2ec8d54c089c99a8584
getLineReaderClass
public Class<? extends LineReader> getLineReaderClass()
{    return lineReaderClass_;}
a75fa92f246a2e9c0d0e5ec3993defa26388a63747a0450395002075dab6771b
setCharsetName
public void setCharsetName(String charsetName)
{    this.charsetName_ = charsetName;}
47d80552966f7dfca3dc353b6b62dd9768b8cac76e0501084b30466d2d12d303
setLineReaderClass
public void setLineReaderClass(Class<? extends LineReader> lineReaderClass)
{    this.lineReaderClass_ = lineReaderClass;}
8a559fa74e986c3be350ca3e29b6e7171cfdb68b128251843fa39e52324ae291
skipLine
public long skipLine(long n) throws IOException
{    if (n < 0L) {        throw new IllegalArgumentException("skip value is negative");    }    String line;    long currentLine = 0;    long readLine = 0;    synchronized (lock) {        while (currentLine < n && (line = br_.readLine()) != null) {            readLine++;            if (line == null || line.isEmpty() || line.startsWith("#")) {                continue;            }            currentLine++;        }        return readLine;    }}
d9e40951c6eaf8a5c3d18659b21f2ad4a49bbafb0a2ca47cbeb6f6f03387f4b4
readLine
public String readLine() throws IOException
{    synchronized (lock) {        String lineString = br_.readLine();        while (lineString != null && (lineString.isEmpty() || lineString.startsWith("#"))) {            lineString = br_.readLine();        }        return lineString;    }}
46d7db13444bef3cacd099f303d2c08062c9881e8765c2acbab052032527e97d
readLineTokens
public String[] readLineTokens() throws IOException
{    String line = readLine();    if (line == null)        return null;    else        return line.split(lineDelimitingRegex_, -1);}
5b278cce8f760eeae625892d05dbf15b58becec33f0ffc51fc725304dfbf2bf9
read
public int read(char[] cbuf, int off, int len) throws IOException
{    synchronized (lock) {        return br_.read(cbuf, off, len);    }}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    synchronized (lock) {        if (br_ != null) {            br_.close();        }    }}
b5659a86fccc64e02c1cafa4a01e5244bd3776cfb3a37c09a8255fc0536dd44a
rewind
public void rewind() throws IOException
{    synchronized (lock) {        if (br_ != null) {            br_.close();        }        if (file_ != null) {            FileInputStream fis = new FileInputStream(file_);            br_ = new BufferedReader(new InputStreamReader(fis, charset_));        } else {                        throw new UnsupportedOperationException("InputStream rewind not supported");        }    }}
054377408b029c2196d169d31f9f63fe8a8336f01284d7182f947012d02d779a
getLineDelimitingRege
public String getLineDelimitingRege()
{    return lineDelimitingRegex_;}
c41f4073d4fc6e06ee6e467967c4fbd467ae0ae02476dd990a67db82383aeb93
setLineDelimitingRegex
public void setLineDelimitingRegex(String lineDelimitingRegex)
{    this.lineDelimitingRegex_ = lineDelimitingRegex;}
8a559fa74e986c3be350ca3e29b6e7171cfdb68b128251843fa39e52324ae291
skipLine
public long skipLine(long n) throws IOException
{    if (n < 0L) {        throw new IllegalArgumentException("skip value is negative");    }    String line;    long currentLine = 0;    long readLine = 0;    synchronized (lock) {        ensureOpen();        while (currentLine < n && (line = getLine()) != null) {            readLine++;            if (line == null || line.isEmpty() || line.startsWith("#")) {                continue;            }            currentLine++;        }    }    return readLine;}
d9e40951c6eaf8a5c3d18659b21f2ad4a49bbafb0a2ca47cbeb6f6f03387f4b4
readLine
public String readLine() throws IOException
{    synchronized (lock) {        ensureOpen();        String lineString = getLine();        while (lineString != null && (lineString.isEmpty() || lineString.startsWith("#"))) {            lineString = getLine();        }        return lineString;    }}
46d7db13444bef3cacd099f303d2c08062c9881e8765c2acbab052032527e97d
readLineTokens
public String[] readLineTokens() throws IOException
{    synchronized (lock) {        ensureOpen();        String[] tokens = getLineTokens();        while (tokens != null && ((tokens.length == 1 && tokens[0].isEmpty()) || tokens[0].startsWith("#"))) {            tokens = getLineTokens();        }        return tokens;    }}
b5659a86fccc64e02c1cafa4a01e5244bd3776cfb3a37c09a8255fc0536dd44a
rewind
public void rewind() throws IOException
{    synchronized (lock) {        ensureOpen();        if (raf_ != null) {            raf_.seek(0);            channel_.position(0);        }        byteBuffer_.position(0);    }}
5b278cce8f760eeae625892d05dbf15b58becec33f0ffc51fc725304dfbf2bf9
read
public int read(char[] cbuf, int off, int len) throws IOException
{    synchronized (lock) {        ensureOpen();        if ((off < 0) || (off > cbuf.length) || (len < 0) || ((off + len) > cbuf.length) || ((off + len) < 0)) {            throw new IndexOutOfBoundsException();        } else if (len == 0) {            return 0;        }        CharBuffer charBuffer = byteBuffer_.asCharBuffer();        int length = Math.min(len, charBuffer.remaining());        charBuffer.get(cbuf, off, length);        if (inputStream_ != null) {            off += length;            while (off < len) {                fillByteBuffer();                if (!byteBuffer_.hasRemaining()) {                    break;                }                charBuffer = byteBuffer_.asCharBuffer();                length = Math.min(len, charBuffer.remaining());                charBuffer.get(cbuf, off, length);                off += length;            }        }        return length == len ? len : -1;    }}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    synchronized (lock) {        if (raf_ != null) {            raf_.close();        } else if (inputStream_ != null) {            inputStream_.close();        }        channel_ = null;        byteBuffer_ = null;    }}
efad6d3741d7f806e6f7f5ba6e9c3eacd4fd4292d5cb48ab94a6dc87ca3d93df
ensureOpen
private void ensureOpen() throws IOException
{    if (byteBuffer_ == null)        throw new IOException("Stream closed");}
32262e7caf171f57ca62473f0ac788e6ac47a09d0962cc28d3b737bb859ad4cd
getLine
protected String getLine() throws IOException
{    fillByteBuffer();    if (!byteBuffer_.hasRemaining()) {        return null;    }    sb_.setLength(0);    int b = -1;    int i = -1;    do {        b = byteBuffer_.get();        if ((b >= 10 && b <= 13) || b == 0) {            break;        }        bytes_[++i] = (byte) b;        if (i == string_buf_size_ - 1) {            sb_.append(new String(bytes_, charset_));            i = -1;        }        fillByteBuffer();    } while (byteBuffer_.hasRemaining());    sb_.append(new String(bytes_, 0, i + 1, charset_));    return sb_.toString();}
a756556181e6eaae0d978eeb18e5d6580cb7dad9f01e2300ccebe4c5b000f63a
getLineTokens
protected String[] getLineTokens() throws IOException
{    fillByteBuffer();    if (!byteBuffer_.hasRemaining()) {        return null;    }    tokens_.clear();    sb_.setLength(0);    int b = -1;    int i = -1;    do {        b = byteBuffer_.get();        if ((b >= 10 && b <= 13) || b == 0) {            break;        } else if (b == 9 || b == 32) {            sb_.append(new String(bytes_, 0, i + 1, charset_));            tokens_.add(sb_.toString());            sb_.setLength(0);            i = -1;        } else {            bytes_[++i] = (byte) b;            if (i == string_buf_size_ - 1) {                sb_.append(new String(bytes_, charset_));                i = -1;            }        }        fillByteBuffer();    } while (byteBuffer_.hasRemaining());    sb_.append(new String(bytes_, 0, i + 1, charset_));    tokens_.add(sb_.toString());    return tokens_.toArray(new String[tokens_.size()]);}
021e16fc1525646382f8fe7bd02da2b49c685f9694b9055f96a226a3df95410f
fillByteBuffer
private void fillByteBuffer() throws IOException
{    if (inputStream_ == null || byteBuffer_.hasRemaining()) {        return;    }    byteBuffer_.clear();    int b;    for (int i = 0; i < string_buf_size_; i++) {        b = inputStream_.read();        if (b < 0) {                        break;        }        byteBuffer_.put((byte) b);        if (fillLine_) {            if ((b >= 10 && b <= 13) || b == 0) {                break;            }        }    }    byteBuffer_.flip();}
815b8ca057fe05ea050a6833bcc3746615974522cb887557c659a1da33b0d319
setStringBufferSize
public void setStringBufferSize(int size)
{    string_buf_size_ = size;    string_bytes_ = new byte[string_buf_size_];}
e72bcda52cc692df8f76beb9ce1ab2f5c6cbde897e3c9990f62acefb5ebdb28f
setFloatArrayBufferSize
public void setFloatArrayBufferSize(int itemSize)
{    float_array_bytebuffer_ = ByteBuffer.allocate(itemSize * 4).order(ByteOrder.LITTLE_ENDIAN);    float_array_bytes_ = new byte[itemSize * 4];}
4075a6c47f3763a5abdf31646b86180517aa6ff7103fbe6b1facc1aae0b05c39
readByte
public int readByte(InputStream is) throws IOException
{    return is.read() & 0xFF;}
204caf4a9b1f1c9a434010802498c313c4579a100350f51b108fc88878b2b7bf
readInt
public int readInt(InputStream is) throws IOException
{    is.read(int_bytes_);    return getInt(int_bytes_);}
093b694e38538148497a2b0f97739b547c41c63bc2ed48c75b756e9d91b57e25
getInt
public int getInt(byte[] b)
{    return (b[0] & 0xFF) << 0 | (b[1] & 0xFF) << 8 | (b[2] & 0xFF) << 16 | (b[3] & 0xFF) << 24;}
10332b5c39363d191903098b29fd7dde3f980b7ac115d9e0ea86755f2c6baff8
readLong
public long readLong(InputStream is) throws IOException
{    is.read(long_bytes_);    return getLong(long_bytes_);}
a838e3e0c84845205184b889a2e4231f0dc98c93f6b9a6c511d2d47670fc235d
getLong
public long getLong(byte[] b)
{    return (b[0] & 0xFFL) << 0 | (b[1] & 0xFFL) << 8 | (b[2] & 0xFFL) << 16 | (b[3] & 0xFFL) << 24 | (b[4] & 0xFFL) << 32 | (b[5] & 0xFFL) << 40 | (b[6] & 0xFFL) << 48 | (b[7] & 0xFFL) << 56;}
922c7e40551d8235ecc25524408cdd16c7ea1d5b48517e9623dec85fd1303d60
readFloat
public float readFloat(InputStream is) throws IOException
{    is.read(float_bytes_);    return getFloat(float_bytes_);}
490d6670e346984df06f966174b2e971d7f8e5bdb3c6585abd4b8aea2f5edc36
readFloat
public void readFloat(InputStream is, float[] data) throws IOException
{    is.read(float_array_bytes_);    float_array_bytebuffer_.clear();    ((ByteBuffer) float_array_bytebuffer_.put(float_array_bytes_).flip()).asFloatBuffer().get(data);}
1e119c09784efa3b3ea0f7592ee253bfed38c4d5aad1f4bb215e1b5981410a53
getFloat
public float getFloat(byte[] b)
{    return Float.intBitsToFloat((b[0] & 0xFF) << 0 | (b[1] & 0xFF) << 8 | (b[2] & 0xFF) << 16 | (b[3] & 0xFF) << 24);}
c95618e03a0d13010b447ecef16c51b76fc87aee3e4758b78886fbebd9727d3e
readDouble
public double readDouble(InputStream is) throws IOException
{    is.read(double_bytes_);    return getDouble(double_bytes_);}
23cdf5d3aba350bb1c3c8f3db155915033ec930310e84330c0bae5bb59eb7925
getDouble
public double getDouble(byte[] b)
{    return Double.longBitsToDouble(getLong(b));}
b9659d21dffb988783ff966bcf321ec20ab9f2a811f400a85b62893772f22b9a
readString
public String readString(InputStream is) throws IOException
{    int b = is.read();    if (b < 0) {        return null;    }    int i = -1;    stringBuilder_.setLength(0);        while (b > -1 && b != 32 && b != 10 && b != 0) {        string_bytes_[++i] = (byte) b;        b = is.read();        if (i == string_buf_size_ - 1) {            stringBuilder_.append(new String(string_bytes_));            i = -1;        }    }    stringBuilder_.append(new String(string_bytes_, 0, i + 1));    return stringBuilder_.toString();}
e10fc57105d94cfd92bf198b422727714fc7ce292828b6b788099d423dbe4451
intToByte
public int intToByte(int i)
{    return (i & 0xFF);}
31eb14c30a70f7900ab3dbc699f0eed6db9dc9083b957686a1ef9efcfc16b893
intToByteArray
public byte[] intToByteArray(int i)
{    int_bytes_[0] = (byte) ((i >> 0) & 0xff);    int_bytes_[1] = (byte) ((i >> 8) & 0xff);    int_bytes_[2] = (byte) ((i >> 16) & 0xff);    int_bytes_[3] = (byte) ((i >> 24) & 0xff);    return int_bytes_;}
363bbae44e8de7e1965843b734404933388bf084899240e0d477dc3e1838a4ec
longToByteArray
public byte[] longToByteArray(long l)
{    long_bytes_[0] = (byte) ((l >> 0) & 0xff);    long_bytes_[1] = (byte) ((l >> 8) & 0xff);    long_bytes_[2] = (byte) ((l >> 16) & 0xff);    long_bytes_[3] = (byte) ((l >> 24) & 0xff);    long_bytes_[4] = (byte) ((l >> 32) & 0xff);    long_bytes_[5] = (byte) ((l >> 40) & 0xff);    long_bytes_[6] = (byte) ((l >> 48) & 0xff);    long_bytes_[7] = (byte) ((l >> 56) & 0xff);    return long_bytes_;}
7388426ef06b7e004295ed290e17932901cc12187cda9ef1e0e007d700662e91
floatToByteArray
public byte[] floatToByteArray(float f)
{    return intToByteArray(Float.floatToIntBits(f));}
8fb037cd212a1f127bd79bf28cd824a67914a587e94b75c549011e5bcd804910
floatToByteArray
public byte[] floatToByteArray(float[] f)
{    float_array_bytebuffer_.clear();    float_array_bytebuffer_.asFloatBuffer().put(f);    return float_array_bytebuffer_.array();}
3a36107526273a40d9385b6ae560346ad944d5fa86b336f6c7f6cd5c8ad7a4eb
doubleToByteArray
public byte[] doubleToByteArray(double d)
{    return longToByteArray(Double.doubleToRawLongBits(d));}
5bd7cde0f316de1cacc1db662c03a9ac91a5481ba738ff77f581e37e32be3e05
printUsage
public static void printUsage()
{    System.out.print("usage: java -jar fasttext.jar <command> <args>\n\n" + "The commands supported by fasttext are:\n\n" + "  supervised          train a supervised classifier\n" + "  test                evaluate a supervised classifier\n" + "  predict             predict most likely labels\n" + "  predict-prob        predict most likely labels with probabilities\n" + "  skipgram            train a skipgram model\n" + "  cbow                train a cbow model\n" + "  print-vectors       print vectors given a trained model\n");}
fcfc17472333ea32ddcc0844456992a08b98b0ee3cc2dfe174fba90418a55008
printTestUsage
public static void printTestUsage()
{    System.out.print("usage: java -jar fasttext.jar test <model> <test-data> [<k>]\n\n" + "  <model>      model filename\n" + "  <test-data>  test data filename (if -, read from stdin)\n" + "  <k>          (optional; 1 by default) predict top k labels\n");}
c4d68bdfde1170891ed1dd6a55a83dbf456b50479191ca62520968e481ee6013
printPredictUsage
public static void printPredictUsage()
{    System.out.print("usage: java -jar fasttext.jar predict[-prob] <model> <test-data> [<k>]\n\n" + "  <model>      model filename\n" + "  <test-data>  test data filename (if -, read from stdin)\n" + "  <k>          (optional; 1 by default) predict top k labels\n");}
cd648c9c08cd387f752fc4fcaa2b5e9369fa168255a496197b1cc293bb158920
printPrintVectorsUsage
public static void printPrintVectorsUsage()
{    System.out.print("usage: java -jar fasttext.jar print-vectors <model>\n\n" + " <model> model filename\n");}
c6fa9333375c8c3ee8709f0ab9c83c6c0fcc8c58292a8a31ac19a409134c3db2
test
public void test(String[] args) throws IOException, Exception
{    int k = 1;    if (args.length == 3) {        k = 1;    } else if (args.length == 4) {        k = Integer.parseInt(args[3]);    } else {        printTestUsage();        System.exit(1);    }    FastText fasttext = new FastText();    fasttext.loadModel(args[1]);    String infile = args[2];    if ("-".equals(infile)) {        fasttext.test(System.in, k);    } else {        File file = new File(infile);        if (!(file.exists() && file.isFile() && file.canRead())) {            throw new IOException("Test file cannot be opened!");        }        fasttext.test(new FileInputStream(file), k);    }}
6910bcfc428d9c7df11fc0b800c4df079e7a3f56c58574df5ec39bab5c1520a3
predict
public void predict(String[] args) throws IOException, Exception
{    int k = 1;    if (args.length == 3) {        k = 1;    } else if (args.length == 4) {        k = Integer.parseInt(args[3]);    } else {        printPredictUsage();        System.exit(1);    }    boolean print_prob = "predict-prob".equalsIgnoreCase(args[0]);    FastText fasttext = new FastText();    fasttext.loadModel(args[1]);    String infile = args[2];    if ("-".equals(infile)) {        fasttext.predict(System.in, k, print_prob);    } else {        File file = new File(infile);        if (!(file.exists() && file.isFile() && file.canRead())) {            throw new IOException("Input file cannot be opened!");        }        fasttext.predict(new FileInputStream(file), k, print_prob);    }}
6d9941508465e8ff942d6d2a119b89ed1b5683137452634262d9dceee76e0302
printVectors
public void printVectors(String[] args) throws IOException
{    if (args.length != 2) {        printPrintVectorsUsage();        System.exit(1);    }    FastText fasttext = new FastText();    fasttext.loadModel(args[1]);    fasttext.printVectors();}
b81c62d7d49d1fb70ce38987dc24303479dd64c26560e34d0e0335ba281902a3
train
public void train(String[] args) throws IOException, Exception
{    Args a = new Args();    a.parseArgs(args);    FastText fasttext = new FastText();    fasttext.train(a);}
3116ea2053d9de960ec3753eb07f3d243c370662aa1f0175ad357057c9ce5a52
main
public static void main(String[] args)
{    Main op = new Main();    if (args.length == 0) {        printUsage();        System.exit(1);    }    try {        String command = args[0];        if ("skipgram".equalsIgnoreCase(command) || "cbow".equalsIgnoreCase(command) || "supervised".equalsIgnoreCase(command)) {            op.train(args);        } else if ("test".equalsIgnoreCase(command)) {            op.test(args);        } else if ("print-vectors".equalsIgnoreCase(command)) {            op.printVectors(args);        } else if ("predict".equalsIgnoreCase(command) || "predict-prob".equalsIgnoreCase(command)) {            op.predict(args);        } else {            printUsage();            System.exit(1);        }    } catch (Exception e) {        e.printStackTrace();        System.exit(1);    }    System.exit(0);}
966873cf73315c7dccf8bb622165de22a03f49dbd88a5df74d7d4d374eb2ce10
zero
public void zero()
{    for (int i = 0; i < m_; i++) {        for (int j = 0; j < n_; j++) {            data_[i][j] = 0.0f;        }    }}
44e3aee2e1df4fb6fa23599c320ef409048419d94bad0cc3e06275173a83d9dc
uniform
public void uniform(float a)
{    Random random = new Random(1l);    for (int i = 0; i < m_; i++) {        for (int j = 0; j < n_; j++) {            data_[i][j] = Utils.randomFloat(random, -a, a);        }    }}
a373eecc3d3966edd1e6046deff98f4cf3c41b9d70519156fbaf7b78bac4b83e
addRow
public void addRow(final Vector vec, int i, float a)
{    Utils.checkArgument(i >= 0);    Utils.checkArgument(i < m_);    Utils.checkArgument(vec.m_ == n_);    for (int j = 0; j < n_; j++) {        data_[i][j] += a * vec.data_[j];    }}
8f260a29c15c7741433f28ce9217681816c7d239e2ffb99bde2ecf374cec2246
dotRow
public float dotRow(final Vector vec, int i)
{    Utils.checkArgument(i >= 0);    Utils.checkArgument(i < m_);    Utils.checkArgument(vec.m_ == n_);    float d = 0.0f;    for (int j = 0; j < n_; j++) {        d += data_[i][j] * vec.data_[j];    }    return d;}
3a8946cfb43327bb024d4cc4affaeb32da8f3132edaab40015cddaf465c03c6a
load
public void load(InputStream input) throws IOException
{    IOUtil ioutil = new IOUtil();    m_ = (int) ioutil.readLong(input);    n_ = (int) ioutil.readLong(input);    ioutil.setFloatArrayBufferSize(n_);    data_ = new float[m_][n_];    for (int i = 0; i < m_; i++) {        ioutil.readFloat(input, data_[i]);    }}
4ce9f8ebe11b9e2148e101376b5f964d78813696da3361f5909f7533d88d28d1
save
public void save(OutputStream ofs) throws IOException
{    IOUtil ioutil = new IOUtil();    ioutil.setFloatArrayBufferSize(n_);    ofs.write(ioutil.longToByteArray(m_));    ofs.write(ioutil.longToByteArray(n_));    for (int i = 0; i < m_; i++) {        ofs.write(ioutil.floatToByteArray(data_[i]));    }}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    StringBuilder builder = new StringBuilder();    builder.append("Matrix [data_=");    if (data_ != null) {        builder.append("[");        for (int i = 0; i < m_ && i < 10; i++) {            for (int j = 0; j < n_ && j < 10; j++) {                builder.append(data_[i][j]).append(",");            }        }        builder.setLength(builder.length() - 1);        builder.append("]");    } else {        builder.append("null");    }    builder.append(", m_=");    builder.append(m_);    builder.append(", n_=");    builder.append(n_);    builder.append("]");    return builder.toString();}
1b5cc933a309190fc5c0ef3e1905967301f3daf7810df786a13eb8409adef2ca
binaryLogistic
public float binaryLogistic(int target, boolean label, float lr)
{    float score = sigmoid(wo_.dotRow(hidden_, target));    float alpha = lr * ((label ? 1.0f : 0.0f) - score);    grad_.addRow(wo_, target, alpha);    wo_.addRow(hidden_, target, alpha);    if (label) {        return -log(score);    } else {        return -log(1.0f - score);    }}
7f0633848e2940f8ae4143f66c44162fe6e9c906a8539fe6123932696f9487fb
negativeSampling
public float negativeSampling(int target, float lr)
{    float loss = 0.0f;    grad_.zero();    for (int n = 0; n <= args_.neg; n++) {        if (n == 0) {            loss += binaryLogistic(target, true, lr);        } else {            loss += binaryLogistic(getNegative(target), false, lr);        }    }    return loss;}
1bbd6852d188f72a93250fcdc45859c8f0a009c5fc438920ef07559624f8490d
hierarchicalSoftmax
public float hierarchicalSoftmax(int target, float lr)
{    float loss = 0.0f;    grad_.zero();    final List<Boolean> binaryCode = codes.get(target);    final List<Integer> pathToRoot = paths.get(target);    for (int i = 0; i < pathToRoot.size(); i++) {        loss += binaryLogistic(pathToRoot.get(i), binaryCode.get(i), lr);    }    return loss;}
f1b6e1d771b1404e5fe488cbe186da0686a5fd22096462ada9ae28b2cba29cc5
computeOutputSoftmax
public void computeOutputSoftmax(Vector hidden, Vector output)
{    output.mul(wo_, hidden);    float max = output.get(0), z = 0.0f;    for (int i = 1; i < osz_; i++) {        max = Math.max(output.get(i), max);    }    for (int i = 0; i < osz_; i++) {        output.set(i, (float) Math.exp(output.get(i) - max));        z += output.get(i);    }    for (int i = 0; i < osz_; i++) {        output.set(i, output.get(i) / z);    }}
e9cfc85c7353dfb5c11d230aaa96ab1e9513da0634d2ab780506f7a843304fd5
computeOutputSoftmax
public void computeOutputSoftmax()
{    computeOutputSoftmax(hidden_, output_);}
b1a86569bfe2cb2a07d713545f753ead5a5b344eef5a214bd8bd21f94a1c54d0
softmax
public float softmax(int target, float lr)
{    grad_.zero();    computeOutputSoftmax();    for (int i = 0; i < osz_; i++) {        float label = (i == target) ? 1.0f : 0.0f;        float alpha = lr * (label - output_.get(i));        grad_.addRow(wo_, i, alpha);        wo_.addRow(hidden_, i, alpha);    }    return -log(output_.get(target));}
9e566a5ae66ab886fa862f1f31fc20d6d96a1bc17ce0897049f2ae45bfcc27ef
computeHidden
public void computeHidden(final List<Integer> input, Vector hidden)
{    Utils.checkArgument(hidden.size() == hsz_);    hidden.zero();    for (Integer it : input) {        hidden.addRow(wi_, it);    }    hidden.mul(1.0f / input.size());}
93480a70674605df1ce12c984a5dfbe2f9876f7a8bb1ac4d0e3c69ed5c83b507
compare
public int compare(Pair<Float, Integer> o1, Pair<Float, Integer> o2)
{    return o2.getKey().compareTo(o1.getKey());}
81c0b289368f748444650c47d6c28ab1abf02bf037713752779d97d456bca7b7
predict
public void predict(final List<Integer> input, int k, List<Pair<Float, Integer>> heap, Vector hidden, Vector output)
{    Utils.checkArgument(k > 0);    if (heap instanceof ArrayList) {        ((ArrayList<Pair<Float, Integer>>) heap).ensureCapacity(k + 1);    }    computeHidden(input, hidden);    if (args_.loss == loss_name.hs) {        dfs(k, 2 * osz_ - 2, 0.0f, heap, hidden);    } else {        findKBest(k, heap, hidden, output);    }    Collections.sort(heap, comparePairs);}
21b7ff3754cddc77f04c772e5e2f210906be6ed1af4f75f1fbe153d9b5721fd4
predict
public void predict(final List<Integer> input, int k, List<Pair<Float, Integer>> heap)
{    predict(input, k, heap, hidden_, output_);}
4a77ceeb3092a438a208aa539dcd783656f185a69ffd408e12889bf9aaf2e0a9
findKBest
public void findKBest(int k, List<Pair<Float, Integer>> heap, Vector hidden, Vector output)
{    computeOutputSoftmax(hidden, output);    for (int i = 0; i < osz_; i++) {        if (heap.size() == k && log(output.get(i)) < heap.get(heap.size() - 1).getKey()) {            continue;        }        heap.add(new Pair<Float, Integer>(log(output.get(i)), i));        Collections.sort(heap, comparePairs);        if (heap.size() > k) {            Collections.sort(heap, comparePairs);                        heap.remove(heap.size() - 1);        }    }}
daa242eab66e94fb673fb35caeb850d8363bf2ca947ffd90d198e8b3a0c86509
dfs
public void dfs(int k, int node, float score, List<Pair<Float, Integer>> heap, Vector hidden)
{    if (heap.size() == k && score < heap.get(heap.size() - 1).getKey()) {        return;    }    if (tree.get(node).left == -1 && tree.get(node).right == -1) {        heap.add(new Pair<Float, Integer>(score, node));        Collections.sort(heap, comparePairs);        if (heap.size() > k) {            Collections.sort(heap, comparePairs);                        heap.remove(heap.size() - 1);        }        return;    }    float f = sigmoid(wo_.dotRow(hidden, node - osz_));    dfs(k, tree.get(node).left, score + log(1.0f - f), heap, hidden);    dfs(k, tree.get(node).right, score + log(f), heap, hidden);}
7a97a3d3ef2e275d3e31b78208b1af5f1bb6ec111f8008cf2afb06efd98b0434
update
public void update(final List<Integer> input, int target, float lr)
{    Utils.checkArgument(target >= 0);    Utils.checkArgument(target < osz_);    if (input.size() == 0) {        return;    }    computeHidden(input, hidden_);    if (args_.loss == loss_name.ns) {        loss_ += negativeSampling(target, lr);    } else if (args_.loss == loss_name.hs) {        loss_ += hierarchicalSoftmax(target, lr);    } else {        loss_ += softmax(target, lr);    }    nexamples_ += 1;    if (args_.model == model_name.sup) {        grad_.mul(1.0f / input.size());    }    for (Integer it : input) {        wi_.addRow(grad_, it, 1.0f);    }}
f091ee59909036cdc3199ccc60d8500d5a79e92d4e3cb2604769fa97d644594b
setTargetCounts
public void setTargetCounts(final List<Long> counts)
{    Utils.checkArgument(counts.size() == osz_);    if (args_.loss == loss_name.ns) {        initTableNegatives(counts);    }    if (args_.loss == loss_name.hs) {        buildTree(counts);    }}
8f576f21df36ad5197aff916a8194c9ea48c189c31d2ae357bebe7dff371b941
initTableNegatives
public void initTableNegatives(final List<Long> counts)
{    negatives = new ArrayList<Integer>(counts.size());    float z = 0.0f;    for (int i = 0; i < counts.size(); i++) {        z += (float) Math.pow(counts.get(i), 0.5f);    }    for (int i = 0; i < counts.size(); i++) {        float c = (float) Math.pow(counts.get(i), 0.5f);        for (int j = 0; j < c * NEGATIVE_TABLE_SIZE / z; j++) {            negatives.add(i);        }    }    Utils.shuffle(negatives, rng);}
45e16158139b8d64ff88105ad6293fa06e561218c524c342dbb6564a0ca4d386
getNegative
public int getNegative(int target)
{    int negative;    do {        negative = negatives.get(negpos);        negpos = (negpos + 1) % negatives.size();    } while (target == negative);    return negative;}
e4b19b65a61a48bc2d614804585743a1a4594206bd6678f8b10b451c1fd81033
buildTree
public void buildTree(final List<Long> counts)
{    paths = new ArrayList<List<Integer>>(osz_);    codes = new ArrayList<List<Boolean>>(osz_);    tree = new ArrayList<Node>(2 * osz_ - 1);    for (int i = 0; i < 2 * osz_ - 1; i++) {        Node node = new Node();        node.parent = -1;        node.left = -1;        node.right = -1;                node.count = 1000000000000000L;        node.binary = false;        tree.add(i, node);    }    for (int i = 0; i < osz_; i++) {        tree.get(i).count = counts.get(i);    }    int leaf = osz_ - 1;    int node = osz_;    for (int i = osz_; i < 2 * osz_ - 1; i++) {        int[] mini = new int[2];        for (int j = 0; j < 2; j++) {            if (leaf >= 0 && tree.get(leaf).count < tree.get(node).count) {                mini[j] = leaf--;            } else {                mini[j] = node++;            }        }        tree.get(i).left = mini[0];        tree.get(i).right = mini[1];        tree.get(i).count = tree.get(mini[0]).count + tree.get(mini[1]).count;        tree.get(mini[0]).parent = i;        tree.get(mini[1]).parent = i;        tree.get(mini[1]).binary = true;    }    for (int i = 0; i < osz_; i++) {        List<Integer> path = new ArrayList<Integer>();        List<Boolean> code = new ArrayList<Boolean>();        int j = i;        while (tree.get(j).parent != -1) {            path.add(tree.get(j).parent - osz_);            code.add(tree.get(j).binary);            j = tree.get(j).parent;        }        paths.add(path);        codes.add(code);    }}
6183edc8d2e52bb264f746b8553bf05aa63ab08406d4fd0e1eb9ef60cd26d4fc
getLoss
public float getLoss()
{    return loss_ / nexamples_;}
ba9a5badb41a0c46b87ffba22a7e8bc1de17c234f491abe74747207d3987ab41
initSigmoid
private void initSigmoid()
{    t_sigmoid = new float[SIGMOID_TABLE_SIZE + 1];    for (int i = 0; i < SIGMOID_TABLE_SIZE + 1; i++) {        float x = (float) (i * 2 * MAX_SIGMOID) / SIGMOID_TABLE_SIZE - MAX_SIGMOID;        t_sigmoid[i] = (float) (1.0f / (1.0f + Math.exp(-x)));    }}
93344583bbab1eb41046f793621ce326080e42f167ee8dfadfeaa78b629b43b7
initLog
private void initLog()
{    t_log = new float[LOG_TABLE_SIZE + 1];    for (int i = 0; i < LOG_TABLE_SIZE + 1; i++) {        float x = (float) (((float) (i) + 1e-5f) / LOG_TABLE_SIZE);        t_log[i] = (float) Math.log(x);    }}
f3bf5a558d385989f1f49402eb17210bf60fcb13cf2c75c0849cca4c2e4779f4
log
public float log(float x)
{    if (x > 1.0f) {        return 0.0f;    }    int i = (int) (x * LOG_TABLE_SIZE);    return t_log[i];}
2677cc37623b765b8843445e736b571c8a287cf83b7f44a976ef8d99c41336d8
sigmoid
public float sigmoid(float x)
{    if (x < -MAX_SIGMOID) {        return 0.0f;    } else if (x > MAX_SIGMOID) {        return 1.0f;    } else {        int i = (int) ((x + MAX_SIGMOID) * SIGMOID_TABLE_SIZE / MAX_SIGMOID / 2);        return t_sigmoid[i];    }}
408af2012690314114a03f0ca626970e41121b2f610127a0eacfc4e43e74dbfe
getKey
public K getKey()
{    return key_;}
5a159708665ed864d795a0702d525a75a1e0d877881ccd093ed97ed18e382934
getValue
public V getValue()
{    return value_;}
1ccb95d9d0b86425ab1f1d0da9ec56e6ea0e4f118d4059bab00823cc75ac1a31
setKey
public void setKey(K key)
{    this.key_ = key;}
f3b7bc10b50507b4ebcfd7933f905497eb338e8546a2cef76c532b2e800cc12b
setValue
public void setValue(V value)
{    this.value_ = value;}
2241bc6524133ba5e7c5a42b06534efd767f7831422e5529e1f1983c14b817fc
checkArgument
public static void checkArgument(boolean expression)
{    if (!expression) {        throw new IllegalArgumentException();    }}
68df6893cfc51ac042542e9fc0ed6c1ea962b91dfdccb6121df9b1be91709c43
checkArgument
public static void checkArgument(boolean expression, String message)
{    if (!expression) {        throw new IllegalArgumentException(message);    }}
c1bebd808b9a2e1c65e5d75f5f2a0df27ab80fc39f23365534752cd950fe9564
isEmpty
public static boolean isEmpty(String str)
{    return (str == null || str.isEmpty());}
9758a2aab75bcb6c6399ccbfce8b68c2ba4360624400d3d2bec1a5b2b7e641e7
mapGetOrDefault
public static V mapGetOrDefault(Map<K, V> map, K key, V defaultValue)
{    return map.containsKey(key) ? map.get(key) : defaultValue;}
61c0358347fef6995afad61b1f9f949521fd5f8e75b3aee4511b24bac1f0c057
randomInt
public static int randomInt(Random rnd, int lower, int upper)
{    checkArgument(lower <= upper & lower > 0);    if (lower == upper) {        return lower;    }    return rnd.nextInt(upper - lower) + lower;}
81d7c25bc48e3fbc014138dc04a6be5314a0d0dc242cee5c2c386f380bff72dd
randomFloat
public static float randomFloat(Random rnd, float lower, float upper)
{    checkArgument(lower <= upper);    if (lower == upper) {        return lower;    }    return (rnd.nextFloat() * (upper - lower)) + lower;}
8c32be04d295481e60c3ee44afe4986f0d8db1815979eb5a810c695fe4accc53
sizeLine
public static long sizeLine(String filename) throws IOException
{    InputStream is = new BufferedInputStream(new FileInputStream(filename));    try {        byte[] c = new byte[1024];        long count = 0;        int readChars = 0;        boolean endsWithoutNewLine = false;        while ((readChars = is.read(c)) != -1) {            for (int i = 0; i < readChars; ++i) {                if (c[i] == '\n')                    ++count;            }            endsWithoutNewLine = (c[readChars - 1] != '\n');        }        if (endsWithoutNewLine) {            ++count;        }        return count;    } finally {        is.close();    }}
2944bbc963faea615ef262fefc7d4310dab61c27e2ffc268325b5da9365b351a
seekLine
public static void seekLine(BufferedReader br, long pos) throws IOException
{        String line;    int currentLine = 1;    while (currentLine < pos && (line = br.readLine()) != null) {        if (Utils.isEmpty(line) || line.startsWith("#")) {            continue;        }        currentLine++;    }}
bc43dd0182fad9ab2466b9949b899bfab543065f9bab4b41d1631f5685de5a62
shuffle
public static void shuffle(List<?> list, Random rnd)
{    int size = list.size();    if (size < SHUFFLE_THRESHOLD || list instanceof RandomAccess) {        for (int i = size; i > 1; i--) swap(list, i - 1, rnd.nextInt(i));    } else {        Object[] arr = list.toArray();                for (int i = size; i > 1; i--) swap(arr, i - 1, rnd.nextInt(i));                                        ListIterator it = list.listIterator();        for (int i = 0; i < arr.length; i++) {            it.next();            it.set(arr[i]);        }    }}
ef3b49116dbc0d8ff5662e49f1c88147a714262c1c9317bc7df6a3063608b066
swap
public static void swap(Object[] arr, int i, int j)
{    Object tmp = arr[i];    arr[i] = arr[j];    arr[j] = tmp;}
de056932365d27df48061d302f59afa57421ee5bd086b31abc416726fab654b0
swap
public static void swap(List<?> list, int i, int j)
{                final List l = list;    l.set(i, l.set(j, l.get(i)));}
72ef1e59027007ffe0950edfd2670ad03bb65cd6463d5d1d282dfeb1750435b0
size
public int size()
{    return m_;}
966873cf73315c7dccf8bb622165de22a03f49dbd88a5df74d7d4d374eb2ce10
zero
public void zero()
{    for (int i = 0; i < m_; i++) {        data_[i] = 0.0f;    }}
2d9faf5728b4c530d2046f8afdba964a5bd738e8d5b223943e6d6c88e139143e
mul
public void mul(float a)
{    for (int i = 0; i < m_; i++) {        data_[i] *= a;    }}
014c1385fce0a3b0403a2075088688c79e09b91178a2c784abdcb826a3f215dd
addRow
public void addRow(final Matrix A, int i)
{    Utils.checkArgument(i >= 0);    Utils.checkArgument(i < A.m_);    Utils.checkArgument(m_ == A.n_);    for (int j = 0; j < A.n_; j++) {                data_[j] += A.data_[i][j];    }}
ac078e4c47fb638662d85267d7a26b9fcfdddc32b5f5924b85a5938952ed3de1
addRow
public void addRow(final Matrix A, int i, float a)
{    Utils.checkArgument(i >= 0);    Utils.checkArgument(i < A.m_);    Utils.checkArgument(m_ == A.n_);    for (int j = 0; j < A.n_; j++) {        data_[j] += a * A.data_[i][j];    }}
bfff89cdbea1b5108458474a527cdf000d6aab62a9e454f3d076a0b0d2670a9e
mul
public void mul(final Matrix A, final Vector vec)
{    Utils.checkArgument(A.m_ == m_);    Utils.checkArgument(A.n_ == vec.m_);    for (int i = 0; i < m_; i++) {        data_[i] = 0.0f;        for (int j = 0; j < A.n_; j++) {            data_[i] += A.data_[i][j] * vec.data_[j];        }    }}
4626a3ea725f4c9827c156155821cc5a186c5e6ad6df76de58ea291cb341324b
argmax
public int argmax()
{    float max = data_[0];    int argmax = 0;    for (int i = 1; i < m_; i++) {        if (data_[i] > max) {            max = data_[i];            argmax = i;        }    }    return argmax;}
0a490f9fe7e2c1071dc33c0e4eaf5b93cbfcf628646f3d62527a730435df0121
get
public float get(int i)
{    return data_[i];}
74c4d2bc2d6d609e0f418f42e3bcacaf496b68ba18505d268c32bd3a11d353e9
set
public void set(int i, float value)
{    data_[i] = value;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    StringBuilder builder = new StringBuilder();    for (float data : data_) {        builder.append(data).append(' ');    }    if (builder.length() > 1) {        builder.setLength(builder.length() - 1);    }    return builder.toString();}
258a355b7adc5507dac77b94e185af0fd12c830c4794a285dd95390d84ea7ad3
testHash
public void testHash()
{    assertEquals(dictionary.hash(","), 688690635l);    assertEquals(dictionary.hash("is"), 1312329493l);    assertEquals(dictionary.hash("</s>"), 3617362777l);}
12116ac41d53bf6ab147dfaa5e30a8e7f3880441b492ef407e9fd22f730ac367
testFind
public void testFind()
{    assertEquals(dictionary.find(","), 28690635l);    assertEquals(dictionary.find("is"), 22329493l);    assertEquals(dictionary.find("</s>"), 17362777l);}
bcf1d07217a83c8fe4f4ee28780bb564d4c8c0b59bce39694ab4d5fe330b89d0
testAdd
public void testAdd()
{    dictionary.add(",");    dictionary.add("is");    dictionary.add("is");    String w = "";    dictionary.add(w);    dictionary.add(w);    dictionary.add(w);    Map<Long, Integer> word2int = dictionary.getWord2int();    assertEquals(3, dictionary.getWords().get(word2int.get(dictionary.find(w))).count);    assertEquals(2, dictionary.getWords().get(word2int.get(dictionary.find("is"))).count);    assertEquals(1, dictionary.getWords().get(word2int.get(dictionary.find(","))).count);}
