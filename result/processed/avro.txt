365a24fc75086b6a0e91f9b072bd58c9280846cc05f333f28ede18388f27ce89
main
public static void main(String[] args) throws IOException
{    Schema schema = new Parser().parse(new File("./../user.avsc"));    GenericRecord user1 = new GenericData.Record(schema);    user1.put("name", "Alyssa");    user1.put("favorite_number", 256);        GenericRecord user2 = new GenericData.Record(schema);    user2.put("name", "Ben");    user2.put("favorite_number", 7);    user2.put("favorite_color", "red");        File file = new File("users.avro");    DatumWriter<GenericRecord> datumWriter = new GenericDatumWriter<GenericRecord>(schema);    DataFileWriter<GenericRecord> dataFileWriter = new DataFileWriter<GenericRecord>(datumWriter);    dataFileWriter.create(schema, file);    dataFileWriter.append(user1);    dataFileWriter.append(user2);    dataFileWriter.close();        DatumReader<GenericRecord> datumReader = new GenericDatumReader<GenericRecord>(schema);    DataFileReader<GenericRecord> dataFileReader = new DataFileReader<GenericRecord>(file, datumReader);    GenericRecord user = null;    while (dataFileReader.hasNext()) {                                user = dataFileReader.next(user);        System.out.println(user);    }}
365a24fc75086b6a0e91f9b072bd58c9280846cc05f333f28ede18388f27ce89
main
public static void main(String[] args) throws IOException
{    User user1 = new User();    user1.setName("Alyssa");    user1.setFavoriteNumber(256);            User user2 = new User("Ben", 7, "red");        User user3 = User.newBuilder().setName("Charlie").setFavoriteColor("blue").setFavoriteNumber(null).build();        File file = new File("users.avro");    DatumWriter<User> userDatumWriter = new SpecificDatumWriter<User>(User.class);    DataFileWriter<User> dataFileWriter = new DataFileWriter<User>(userDatumWriter);    dataFileWriter.create(user1.getSchema(), file);    dataFileWriter.append(user1);    dataFileWriter.append(user2);    dataFileWriter.append(user3);    dataFileWriter.close();        DatumReader<User> userDatumReader = new SpecificDatumReader<User>(User.class);    DataFileReader<User> dataFileReader = new DataFileReader<User>(file, userDatumReader);    User user = null;    while (dataFileReader.hasNext()) {                                user = dataFileReader.next(user);        System.out.println(user);    }}
4a740b12dd53052e56c55b02a77efe82cac207ecf8692e4e07fc08e4556c9bd1
map
public void map(LongWritable key, Text value, OutputCollector<Text, IntWritable> output, Reporter reporter) throws IOException
{    String line = value.toString();    StringTokenizer tokenizer = new StringTokenizer(line);    while (tokenizer.hasMoreTokens()) {        word.set(tokenizer.nextToken());        output.collect(word, one);    }}
70c1febef0442297f5874568c4bd5950648eb703f96d92b2c9816afd1382197e
reduce
public void reduce(Text key, Iterator<IntWritable> values, OutputCollector<AvroWrapper<Pair<CharSequence, Integer>>, NullWritable> output, Reporter reporter) throws IOException
{    int sum = 0;    while (values.hasNext()) {        sum += values.next().get();    }    output.collect(new AvroWrapper<Pair<CharSequence, Integer>>(new Pair<CharSequence, Integer>(key.toString(), sum)), NullWritable.get());}
aacecb0f01750d985b78d806dc3c134f0da79efe2752957e0f93ecf5cbf9e492
run
public int run(String[] args) throws Exception
{    if (args.length != 2) {        System.err.println("Usage: AvroWordCount <input path> <output path>");        return -1;    }    JobConf conf = new JobConf(AvroWordCount.class);    conf.setJobName("wordcount");            AvroJob.setOutputSchema(conf, Pair.getPairSchema(Schema.create(Type.STRING), Schema.create(Type.INT)));    conf.setMapperClass(Map.class);    conf.setReducerClass(Reduce.class);    conf.setInputFormat(TextInputFormat.class);    conf.setMapOutputKeyClass(Text.class);    conf.setMapOutputValueClass(IntWritable.class);    conf.setOutputKeyComparatorClass(Text.Comparator.class);    FileInputFormat.setInputPaths(conf, new Path(args[0]));    FileOutputFormat.setOutputPath(conf, new Path(args[1]));    JobClient.runJob(conf);    return 0;}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    int res = ToolRunner.run(new Configuration(), new AvroWordCount(), args);    System.exit(res);}
365a24fc75086b6a0e91f9b072bd58c9280846cc05f333f28ede18388f27ce89
main
public static void main(String[] args) throws IOException
{        File file = new File(PATH);    if (file.getParentFile() != null) {        file.getParentFile().mkdirs();    }    DatumWriter<User> userDatumWriter = new SpecificDatumWriter<User>(User.class);    DataFileWriter<User> dataFileWriter = new DataFileWriter<User>(userDatumWriter);    dataFileWriter.create(User.SCHEMA$, file);        User user;    Random random = new Random();    for (int i = 0; i < USERS; i++) {        user = new User("user", null, COLORS[random.nextInt(COLORS.length)]);        dataFileWriter.append(user);        System.out.println(user);    }    dataFileWriter.close();}
40dc324563a8d88b8bafb341aab4d04220f3c32d87958e0a60ac4710cecfe067
map
public void map(User user, AvroCollector<Pair<CharSequence, Integer>> collector, Reporter reporter) throws IOException
{    CharSequence color = user.getFavoriteColor();        if (color == null) {        color = "none";    }    collector.collect(new Pair<CharSequence, Integer>(color, 1));}
ef202442e66ac7f6728f4ee4936534a0b2e882c6717b51c891cd45bff141df04
reduce
public void reduce(CharSequence key, Iterable<Integer> values, AvroCollector<Pair<CharSequence, Integer>> collector, Reporter reporter) throws IOException
{    int sum = 0;    for (Integer value : values) {        sum += value;    }    collector.collect(new Pair<CharSequence, Integer>(key, sum));}
aacecb0f01750d985b78d806dc3c134f0da79efe2752957e0f93ecf5cbf9e492
run
public int run(String[] args) throws Exception
{    if (args.length != 2) {        System.err.println("Usage: MapredColorCount <input path> <output path>");        return -1;    }    JobConf conf = new JobConf(getConf(), MapredColorCount.class);    conf.setJobName("colorcount");    FileInputFormat.setInputPaths(conf, new Path(args[0]));    FileOutputFormat.setOutputPath(conf, new Path(args[1]));    AvroJob.setMapperClass(conf, ColorCountMapper.class);    AvroJob.setReducerClass(conf, ColorCountReducer.class);                AvroJob.setInputSchema(conf, User.getClassSchema());    AvroJob.setOutputSchema(conf, Pair.getPairSchema(Schema.create(Type.STRING), Schema.create(Type.INT)));    JobClient.runJob(conf);    return 0;}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    int res = ToolRunner.run(new Configuration(), new MapredColorCount(), args);    System.exit(res);}
6052a40636191540c70243d95cc32851b5bbe24011a9d2a534dfcfdc078678a4
map
public void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException
{    String line = value.toString();    StringTokenizer tokenizer = new StringTokenizer(line);    while (tokenizer.hasMoreTokens()) {        word.set(tokenizer.nextToken());        context.write(word, one);    }}
621b2407bce415327759f2e6543d3741f889f0f0892717204c7b1dd4309d00b3
reduce
public void reduce(Text key, Iterable<IntWritable> values, Context context) throws IOException, InterruptedException
{    int sum = 0;    for (IntWritable value : values) {        sum += value.get();    }    context.write(new AvroWrapper<Pair<CharSequence, Integer>>(new Pair<CharSequence, Integer>(key.toString(), sum)), NullWritable.get());}
aacecb0f01750d985b78d806dc3c134f0da79efe2752957e0f93ecf5cbf9e492
run
public int run(String[] args) throws Exception
{    if (args.length != 2) {        System.err.println("Usage: AvroWordCount <input path> <output path>");        return -1;    }    Job job = new Job(getConf());    job.setJarByClass(MapReduceAvroWordCount.class);    job.setJobName("wordcount");            AvroJob.setOutputKeySchema(job, Pair.getPairSchema(Schema.create(Type.STRING), Schema.create(Type.INT)));    job.setOutputValueClass(NullWritable.class);    job.setMapperClass(Map.class);    job.setReducerClass(Reduce.class);    job.setInputFormatClass(TextInputFormat.class);    job.setMapOutputKeyClass(Text.class);    job.setMapOutputValueClass(IntWritable.class);    job.setSortComparatorClass(Text.Comparator.class);    FileInputFormat.setInputPaths(job, new Path(args[0]));    FileOutputFormat.setOutputPath(job, new Path(args[1]));    job.waitForCompletion(true);    return 0;}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    int res = ToolRunner.run(new Configuration(), new MapReduceAvroWordCount(), args);    System.exit(res);}
6f856ed4f483f79ad2ff78ce9b3fe9a9e0e64ea5e6018d0be48884fd6101e293
map
public void map(AvroKey<User> key, NullWritable value, Context context) throws IOException, InterruptedException
{    CharSequence color = key.datum().getFavoriteColor();    if (color == null) {        color = "none";    }    context.write(new Text(color.toString()), new IntWritable(1));}
621b2407bce415327759f2e6543d3741f889f0f0892717204c7b1dd4309d00b3
reduce
public void reduce(Text key, Iterable<IntWritable> values, Context context) throws IOException, InterruptedException
{    int sum = 0;    for (IntWritable value : values) {        sum += value.get();    }    context.write(new AvroKey<CharSequence>(key.toString()), new AvroValue<Integer>(sum));}
aacecb0f01750d985b78d806dc3c134f0da79efe2752957e0f93ecf5cbf9e492
run
public int run(String[] args) throws Exception
{    if (args.length != 2) {        System.err.println("Usage: MapReduceColorCount <input path> <output path>");        return -1;    }    Job job = new Job(getConf());    job.setJarByClass(MapReduceColorCount.class);    job.setJobName("Color Count");    FileInputFormat.setInputPaths(job, new Path(args[0]));    FileOutputFormat.setOutputPath(job, new Path(args[1]));    job.setInputFormatClass(AvroKeyInputFormat.class);    job.setMapperClass(ColorCountMapper.class);    AvroJob.setInputKeySchema(job, User.getClassSchema());    job.setMapOutputKeyClass(Text.class);    job.setMapOutputValueClass(IntWritable.class);    job.setOutputFormatClass(AvroKeyValueOutputFormat.class);    job.setReducerClass(ColorCountReducer.class);    AvroJob.setOutputKeySchema(job, Schema.create(Schema.Type.STRING));    AvroJob.setOutputValueSchema(job, Schema.create(Schema.Type.INT));    return (job.waitForCompletion(true) ? 0 : 1);}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    int res = ToolRunner.run(new MapReduceColorCount(), args);    System.exit(res);}
6105452cb478a8f1aa96f8df117305dafcf22ea624ad2b05d8dff879c948e3a6
addParentField
public void addParentField(Field field)
{    chainOfFields.add(field);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    StringBuilder result = new StringBuilder();    for (Field field : chainOfFields) {        result.insert(0, " --> " + field.name());    }    return "Path in schema:" + result;}
cc9131919df0823e8e8ee6054b03ea6d4a394f817422ddb0f9240211f097bcaf
getValue
public Object getValue()
{    return value;}
888b14e074992baaeb081de01c4d43abce3c300b2a7d4df2f387997e91f7eb14
adjustAndSetValue
public String adjustAndSetValue(String varName, String valParamName)
{    return varName + " = " + valParamName + ";";}
44afca78eb2f944191717c831b23c212dab4c09d5ffc0c38e3839f3ca0d439cd
getRecommendedSchema
public Schema getRecommendedSchema()
{    throw new UnsupportedOperationException("No recommended schema for " + getLogicalTypeName());}
ae8107d1d2021decf71661998f59541e9fccb04eee0025f30213453c84ed6d48
fromBoolean
public T fromBoolean(Boolean value, Schema schema, LogicalType type)
{    throw new UnsupportedOperationException("fromBoolean is not supported for " + type.getName());}
430d4b9e7addc529915877de9b49be11d3317dc69178c4b78984f090318b5f06
fromInt
public T fromInt(Integer value, Schema schema, LogicalType type)
{    throw new UnsupportedOperationException("fromInt is not supported for " + type.getName());}
390ed5253227db662b334556fdbe11c68441a7608a65b265516e178d336ac3d3
fromLong
public T fromLong(Long value, Schema schema, LogicalType type)
{    throw new UnsupportedOperationException("fromLong is not supported for " + type.getName());}
c07bed1dbe9a43ca2bae8aa74d3d2d8e20c7176c6a4bbc59170ea4bc80a0d744
fromFloat
public T fromFloat(Float value, Schema schema, LogicalType type)
{    throw new UnsupportedOperationException("fromFloat is not supported for " + type.getName());}
4163d50c5f43274fc03f9684ebf220df72e8e30d29905de029a5046b39f948cf
fromDouble
public T fromDouble(Double value, Schema schema, LogicalType type)
{    throw new UnsupportedOperationException("fromDouble is not supported for " + type.getName());}
33d4c35e15ecbca2b5b1cb10806b55f398ccbfa2b9822d776b49efb2bbaf4432
fromCharSequence
public T fromCharSequence(CharSequence value, Schema schema, LogicalType type)
{    throw new UnsupportedOperationException("fromCharSequence is not supported for " + type.getName());}
b1ad8c2fcfdc1b79002c0faa5f772b7a42d441fda9cc6ae5e59d10b734b2f93d
fromEnumSymbol
public T fromEnumSymbol(GenericEnumSymbol value, Schema schema, LogicalType type)
{    throw new UnsupportedOperationException("fromEnumSymbol is not supported for " + type.getName());}
4dc72ee02b8e59612b79142817092e922f1b8e38f79b0c4fb2e758b5a997c35b
fromFixed
public T fromFixed(GenericFixed value, Schema schema, LogicalType type)
{    throw new UnsupportedOperationException("fromFixed is not supported for " + type.getName());}
cdcd278f792851d0bf2444c7c1d32a7acd0fe57cdcf245f45c83c002fc1a04ab
fromBytes
public T fromBytes(ByteBuffer value, Schema schema, LogicalType type)
{    throw new UnsupportedOperationException("fromBytes is not supported for " + type.getName());}
54f9bb8e1e58236ae29c8d75cc6be18952df1dcc27d624d47a85b09200c4204b
fromArray
public T fromArray(Collection<?> value, Schema schema, LogicalType type)
{    throw new UnsupportedOperationException("fromArray is not supported for " + type.getName());}
9d85ce38d47abfc4394094ddba9238cac1ae07df41e1f6a13220bc6073307c77
fromMap
public T fromMap(Map<?, ?> value, Schema schema, LogicalType type)
{    throw new UnsupportedOperationException("fromMap is not supported for " + type.getName());}
592c7ce119d15ae33fc15cdc368a59450c1ce1d0bd4b45fac28387efe22c6d09
fromRecord
public T fromRecord(IndexedRecord value, Schema schema, LogicalType type)
{    throw new UnsupportedOperationException("fromRecord is not supported for " + type.getName());}
cc4f730b6a636cc7313ac3b17913c2ccfaf0c89cbc723199748676c447fff20d
toBoolean
public Boolean toBoolean(T value, Schema schema, LogicalType type)
{    throw new UnsupportedOperationException("toBoolean is not supported for " + type.getName());}
6e8052967a3fe791a69ab5095a75b558398778f2c65b2412de6183b006fab67d
toInt
public Integer toInt(T value, Schema schema, LogicalType type)
{    throw new UnsupportedOperationException("toInt is not supported for " + type.getName());}
e8b24c2163cdb891505f236900b893f9a284ff07c80a829f6f09c19f92b34882
toLong
public Long toLong(T value, Schema schema, LogicalType type)
{    throw new UnsupportedOperationException("toLong is not supported for " + type.getName());}
7433040096a8c39e129eed73f9e20f46e4b03697caba72973e50674b73548205
toFloat
public Float toFloat(T value, Schema schema, LogicalType type)
{    throw new UnsupportedOperationException("toFloat is not supported for " + type.getName());}
e7eef7cb6d2b06287313034fb8e9476130b996639190dbb792cbf28314da0fdb
toDouble
public Double toDouble(T value, Schema schema, LogicalType type)
{    throw new UnsupportedOperationException("toDouble is not supported for " + type.getName());}
aabf2ee5faa1384405b93c53b8ac344fa96e892d14975a754cf9f7785ef9c720
toCharSequence
public CharSequence toCharSequence(T value, Schema schema, LogicalType type)
{    throw new UnsupportedOperationException("toCharSequence is not supported for " + type.getName());}
340b6ba0250dba76cf2897d3488cbb4ae869c988d64bec8375e6dc297922f89a
toEnumSymbol
public GenericEnumSymbol toEnumSymbol(T value, Schema schema, LogicalType type)
{    throw new UnsupportedOperationException("toEnumSymbol is not supported for " + type.getName());}
84461052e5bbbc23b1bb87ae51dc70900315ec7dc9dbf32634fe0a95addb378b
toFixed
public GenericFixed toFixed(T value, Schema schema, LogicalType type)
{    throw new UnsupportedOperationException("toFixed is not supported for " + type.getName());}
ab542b8090492b8fecc94fc9f1d73b54f7378b451fcfb7bc025869cb4d9b6738
toBytes
public ByteBuffer toBytes(T value, Schema schema, LogicalType type)
{    throw new UnsupportedOperationException("toBytes is not supported for " + type.getName());}
686acdc950b07a64af1007b6b6ca4b6214cd63624abbd0eb2a77558f299a8cb6
toArray
public Collection<?> toArray(T value, Schema schema, LogicalType type)
{    throw new UnsupportedOperationException("toArray is not supported for " + type.getName());}
ecc0938dcae8c1e8b6be23b7941b14260668ea0a81eb9684080474c402d896b6
toMap
public Map<?, ?> toMap(T value, Schema schema, LogicalType type)
{    throw new UnsupportedOperationException("toMap is not supported for " + type.getName());}
528a146662f2135775c1e8c878a0995b2e87c0019814fad6d631abdbdfb79bbf
toRecord
public IndexedRecord toRecord(T value, Schema schema, LogicalType type)
{    throw new UnsupportedOperationException("toRecord is not supported for " + type.getName());}
b408a1ed60c0b3ad456d6bbb111e327a19b29cd9ad3f4aef8c20ab86df593afe
getConvertedType
public Class<UUID> getConvertedType()
{    return UUID.class;}
44afca78eb2f944191717c831b23c212dab4c09d5ffc0c38e3839f3ca0d439cd
getRecommendedSchema
public Schema getRecommendedSchema()
{    return LogicalTypes.uuid().addToSchema(Schema.create(Schema.Type.STRING));}
79c42293ac3a43d7598dc0ac8104dd9a114e436cd5a14a6241ebbe2b10b5f8ba
getLogicalTypeName
public String getLogicalTypeName()
{    return "uuid";}
e0c9229af28d78cd97d6ce361aa923dfde604425592aa7bb36fb655a3716a7ef
fromCharSequence
public UUID fromCharSequence(CharSequence value, Schema schema, LogicalType type)
{    return UUID.fromString(value.toString());}
eb81a47f8538bd2292c38690716693b85625357a96424976fc5f6990262e7c78
toCharSequence
public CharSequence toCharSequence(UUID value, Schema schema, LogicalType type)
{    return value.toString();}
aa7ef9a4390d79c1fa196b65d387ee1e12f1bb32f37a9ab73364cf14ffbd1901
getConvertedType
public Class<BigDecimal> getConvertedType()
{    return BigDecimal.class;}
44afca78eb2f944191717c831b23c212dab4c09d5ffc0c38e3839f3ca0d439cd
getRecommendedSchema
public Schema getRecommendedSchema()
{    throw new UnsupportedOperationException("No recommended schema for decimal (scale is required)");}
79c42293ac3a43d7598dc0ac8104dd9a114e436cd5a14a6241ebbe2b10b5f8ba
getLogicalTypeName
public String getLogicalTypeName()
{    return "decimal";}
a1aa447775787356738a19698ead22622a9b0811f50125d8d1b6e8f9e378be12
fromBytes
public BigDecimal fromBytes(ByteBuffer value, Schema schema, LogicalType type)
{    int scale = ((LogicalTypes.Decimal) type).getScale();        byte[] bytes = new byte[value.remaining()];    value.get(bytes);    return new BigDecimal(new BigInteger(bytes), scale);}
8d3e843131a924ba47e094fbabecb11b1e76549127fdb8189bd296f6d2db853f
toBytes
public ByteBuffer toBytes(BigDecimal value, Schema schema, LogicalType type)
{    int scale = ((LogicalTypes.Decimal) type).getScale();    if (scale != value.scale()) {        throw new AvroTypeException("Cannot encode decimal with scale " + value.scale() + " as scale " + scale);    }    return ByteBuffer.wrap(value.unscaledValue().toByteArray());}
c272b31156d0cc0bb01541acd01c44628b9a4401ca665f8a4261eef411470c74
fromFixed
public BigDecimal fromFixed(GenericFixed value, Schema schema, LogicalType type)
{    int scale = ((LogicalTypes.Decimal) type).getScale();    return new BigDecimal(new BigInteger(value.bytes()), scale);}
078b051fb65961242d210112af1c405db6e8641ded127ccc6a0e4fbae5a3efcc
toFixed
public GenericFixed toFixed(BigDecimal value, Schema schema, LogicalType type)
{    int scale = ((LogicalTypes.Decimal) type).getScale();    if (scale != value.scale()) {        throw new AvroTypeException("Cannot encode decimal with scale " + value.scale() + " as scale " + scale);    }    byte fillByte = (byte) (value.signum() < 0 ? 0xFF : 0x00);    byte[] unscaled = value.unscaledValue().toByteArray();    byte[] bytes = new byte[schema.getFixedSize()];    int offset = bytes.length - unscaled.length;        Arrays.fill(bytes, 0, offset, fillByte);    System.arraycopy(unscaled, 0, bytes, offset, bytes.length - offset);    return new GenericData.Fixed(schema, bytes);}
a9a532fa4cabdfc63ecd86b4ca9fd717e54196bbd93a29c74c70fef3ac7d8b3d
convertToLogicalType
public static Object convertToLogicalType(Object datum, Schema schema, LogicalType type, Conversion<?> conversion)
{    if (datum == null) {        return null;    }    if (schema == null || type == null || conversion == null) {        throw new IllegalArgumentException("Parameters cannot be null! Parameter values:" + Arrays.deepToString(new Object[] { datum, schema, type, conversion }));    }    try {        switch(schema.getType()) {            case RECORD:                return conversion.fromRecord((IndexedRecord) datum, schema, type);            case ENUM:                return conversion.fromEnumSymbol((GenericEnumSymbol) datum, schema, type);            case ARRAY:                return conversion.fromArray((Collection) datum, schema, type);            case MAP:                return conversion.fromMap((Map<?, ?>) datum, schema, type);            case FIXED:                return conversion.fromFixed((GenericFixed) datum, schema, type);            case STRING:                return conversion.fromCharSequence((CharSequence) datum, schema, type);            case BYTES:                return conversion.fromBytes((ByteBuffer) datum, schema, type);            case INT:                return conversion.fromInt((Integer) datum, schema, type);            case LONG:                return conversion.fromLong((Long) datum, schema, type);            case FLOAT:                return conversion.fromFloat((Float) datum, schema, type);            case DOUBLE:                return conversion.fromDouble((Double) datum, schema, type);            case BOOLEAN:                return conversion.fromBoolean((Boolean) datum, schema, type);        }        return datum;    } catch (ClassCastException e) {        throw new AvroRuntimeException("Cannot convert " + datum + ":" + datum.getClass().getSimpleName() + ": expected generic type", e);    }}
08d074221f715398060b587a0b83c08b5a10d0c0ade6eb77af390591f7ab44bc
convertToRawType
public static Object convertToRawType(Object datum, Schema schema, LogicalType type, Conversion<T> conversion)
{    if (datum == null) {        return null;    }    if (schema == null || type == null || conversion == null) {        throw new IllegalArgumentException("Parameters cannot be null! Parameter values:" + Arrays.deepToString(new Object[] { datum, schema, type, conversion }));    }    try {        Class<T> fromClass = conversion.getConvertedType();        switch(schema.getType()) {            case RECORD:                return conversion.toRecord(fromClass.cast(datum), schema, type);            case ENUM:                return conversion.toEnumSymbol(fromClass.cast(datum), schema, type);            case ARRAY:                return conversion.toArray(fromClass.cast(datum), schema, type);            case MAP:                return conversion.toMap(fromClass.cast(datum), schema, type);            case FIXED:                return conversion.toFixed(fromClass.cast(datum), schema, type);            case STRING:                return conversion.toCharSequence(fromClass.cast(datum), schema, type);            case BYTES:                return conversion.toBytes(fromClass.cast(datum), schema, type);            case INT:                return conversion.toInt(fromClass.cast(datum), schema, type);            case LONG:                return conversion.toLong(fromClass.cast(datum), schema, type);            case FLOAT:                return conversion.toFloat(fromClass.cast(datum), schema, type);            case DOUBLE:                return conversion.toDouble(fromClass.cast(datum), schema, type);            case BOOLEAN:                return conversion.toBoolean(fromClass.cast(datum), schema, type);        }        return datum;    } catch (ClassCastException e) {        throw new AvroRuntimeException("Cannot convert " + datum + ":" + datum.getClass().getSimpleName() + ": expected logical type", e);    }}
aa6b6ef371edf8852376bc422cb876c13dc23c17cf667940f25b6d69dbfc1f06
setSchema
public void setSchema(Schema schema)
{    if (!SCHEMA.equals(schema))        throw new RuntimeException("Not the Json schema: " + schema);}
2e938e3dd86c708f75077b4fe8846d656bf665839234016c0a047cb7ed5f72a5
write
public void write(Object datum, Encoder out) throws IOException
{    Json.writeObject(datum, out);}
aa6b6ef371edf8852376bc422cb876c13dc23c17cf667940f25b6d69dbfc1f06
setSchema
public void setSchema(Schema schema)
{    this.written = SCHEMA.equals(written) ? null : schema;}
691f454954e47de24a6a1ce34769d811d925684ba300d04e1bdd850f42a4e1b1
read
public Object read(Object reuse, Decoder in) throws IOException
{    if (    written == null)        return Json.readObject(in);        if (resolver == null)        resolver = DecoderFactory.get().resolvingDecoder(written, SCHEMA, null);    resolver.configure(in);    Object result = Json.readObject(resolver);    resolver.drain();    return result;}
a6fd22cd2ab46dc994bc3977c27933fab3c8b9c5dff5fce81328513f6c220453
parseJson
public static Object parseJson(String s)
{    try {        return JacksonUtils.toObject(MAPPER.readTree(FACTORY.createParser(s)));    } catch (IOException e) {        throw new RuntimeException(e);    }}
fee392b24507e73b3a76b1e8396ed5a3f6b31cfbbdae9398cded7b5b60fb2a3e
toString
public static String toString(Object datum)
{    return JacksonUtils.toJsonNode(datum).toString();}
d2cdbd0be3024f6316bb301375c983b2fa6f523a7470d43fd287c950f0dde2da
write
private static void write(JsonNode node, Encoder out) throws IOException
{    switch(node.asToken()) {        case VALUE_NUMBER_INT:            out.writeIndex(JsonType.LONG.ordinal());            out.writeLong(node.longValue());            break;        case VALUE_NUMBER_FLOAT:            out.writeIndex(JsonType.DOUBLE.ordinal());            out.writeDouble(node.doubleValue());            break;        case VALUE_STRING:            out.writeIndex(JsonType.STRING.ordinal());            out.writeString(node.textValue());            break;        case VALUE_TRUE:            out.writeIndex(JsonType.BOOLEAN.ordinal());            out.writeBoolean(true);            break;        case VALUE_FALSE:            out.writeIndex(JsonType.BOOLEAN.ordinal());            out.writeBoolean(false);            break;        case VALUE_NULL:            out.writeIndex(JsonType.NULL.ordinal());            out.writeNull();            break;        case START_ARRAY:            out.writeIndex(JsonType.ARRAY.ordinal());            out.writeArrayStart();            out.setItemCount(node.size());            for (JsonNode element : node) {                out.startItem();                write(element, out);            }            out.writeArrayEnd();            break;        case START_OBJECT:            out.writeIndex(JsonType.OBJECT.ordinal());            out.writeMapStart();            out.setItemCount(node.size());            Iterator<String> i = node.fieldNames();            while (i.hasNext()) {                out.startItem();                String name = i.next();                out.writeString(name);                write(node.get(name), out);            }            out.writeMapEnd();            break;        default:            throw new AvroRuntimeException(node.asToken() + " unexpected: " + node);    }}
0e2a946e5003fea8e1656d92069cb5d1520dc5927071190cac5ddc4ace34c4c0
read
private static JsonNode read(Decoder in) throws IOException
{    switch(JsonType.values()[in.readIndex()]) {        case LONG:            return new LongNode(in.readLong());        case DOUBLE:            return new DoubleNode(in.readDouble());        case STRING:            return new TextNode(in.readString());        case BOOLEAN:            return in.readBoolean() ? BooleanNode.TRUE : BooleanNode.FALSE;        case NULL:            in.readNull();            return NullNode.getInstance();        case ARRAY:            ArrayNode array = JsonNodeFactory.instance.arrayNode();            for (long l = in.readArrayStart(); l > 0; l = in.arrayNext()) for (long i = 0; i < l; i++) array.add(read(in));            return array;        case OBJECT:            ObjectNode object = JsonNodeFactory.instance.objectNode();            for (long l = in.readMapStart(); l > 0; l = in.mapNext()) for (long i = 0; i < l; i++) object.set(in.readString(), read(in));            return object;        default:            throw new AvroRuntimeException("Unexpected Json node type");    }}
3b34be4ea6025b97a3b4557e958a146836e6ccf38bd08bfc67ae194adef68d35
writeObject
private static void writeObject(Object datum, Encoder out) throws IOException
{    write(JacksonUtils.toJsonNode(datum), out);}
d6f5386bb1164994f50bdafd513eef927c6aa48ac5d13c3647d294303d07cf87
readObject
private static Object readObject(Decoder in) throws IOException
{    return JacksonUtils.toObject(read(in));}
ca8fce73a4acf9f639e85259a3a634efcb826698d21f345547180f67b9aea5eb
schema
protected final Schema schema()
{    return schema;}
655a06890d9025d05e8af35692e6242cb4f1f3d122824a91c534f5acef477692
fields
protected final Field[] fields()
{    return fields;}
2faa135fffc789fcc2dbd28f69b7082ed5cfcf20bcc31e08812cb19d353e8f2d
fieldSetFlags
protected final boolean[] fieldSetFlags()
{    return fieldSetFlags;}
4e458de8c9f9e7062907d08996c71a147feefe1e415780d5f3f6df3f216de29c
data
protected final GenericData data()
{    return data;}
56778fa853404434de86c8902cbe8d76b0fb1f56af09846217e978daa2132af7
validate
protected void validate(Field field, Object value)
{    if (isValidValue(field, value)) {    } else if (field.defaultVal() != null) {    } else {        throw new AvroRuntimeException("Field " + field + " does not accept null values");    }}
c794656167ccb0e654e23c58d29611e96bc708ffbd4f785f41e307bdcc18387b
isValidValue
protected static boolean isValidValue(Field f, Object value)
{    if (value != null) {        return true;    }    Schema schema = f.schema();    Type type = schema.getType();        if (type == Type.NULL) {        return true;    }        if (type == Type.UNION) {        for (Schema s : schema.getTypes()) {            if (s.getType() == Type.NULL) {                return true;            }        }    }        return false;}
65cb868f5c103db43a7ca9dbb2d3f11f3e9106b33c11c969c56779a825e911b8
defaultValue
protected Object defaultValue(Field field) throws IOException
{    return data.deepCopy(field.schema(), data.getDefaultValue(field));}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    final int prime = 31;    int result = 1;    result = prime * result + Arrays.hashCode(fieldSetFlags);    result = prime * result + ((schema == null) ? 0 : schema.hashCode());    return result;}
4afeb0868b55bdd8e18a00a3cb43d83e0714378d1c4bb36f0936daefc060e2e8
equals
public boolean equals(Object obj)
{    if (this == obj)        return true;    if (obj == null)        return false;    if (getClass() != obj.getClass())        return false;    @SuppressWarnings("rawtypes")    RecordBuilderBase other = (RecordBuilderBase) obj;    if (!Arrays.equals(fieldSetFlags, other.fieldSetFlags))        return false;    if (schema == null) {        return other.schema == null;    } else {        return schema.equals(other.schema);    }}
f7b392a14420c710b564a84b8c0112d4990d0c6665a3edef067a764c436e8d01
getConvertedType
public Class<LocalDate> getConvertedType()
{    return LocalDate.class;}
79c42293ac3a43d7598dc0ac8104dd9a114e436cd5a14a6241ebbe2b10b5f8ba
getLogicalTypeName
public String getLogicalTypeName()
{    return "date";}
8ef0d38ec26d3f5eb90f29006487b0020ddcb0ef26439f587988537a7c08875e
fromInt
public LocalDate fromInt(Integer daysFromEpoch, Schema schema, LogicalType type)
{    return LocalDate.ofEpochDay(daysFromEpoch);}
600021ce1b8c61d5f18f787e4bdfde1528998b969c0bdef5c99cab23642fac22
toInt
public Integer toInt(LocalDate date, Schema schema, LogicalType type)
{    long epochDays = date.toEpochDay();    return (int) epochDays;}
44afca78eb2f944191717c831b23c212dab4c09d5ffc0c38e3839f3ca0d439cd
getRecommendedSchema
public Schema getRecommendedSchema()
{    return LogicalTypes.date().addToSchema(Schema.create(Schema.Type.INT));}
ca5a4991a87b08bb3d00a23c8e29ed710f3584d9b73c07baf5ca2a0eef9ed1b0
getConvertedType
public Class<LocalTime> getConvertedType()
{    return LocalTime.class;}
79c42293ac3a43d7598dc0ac8104dd9a114e436cd5a14a6241ebbe2b10b5f8ba
getLogicalTypeName
public String getLogicalTypeName()
{    return "time-millis";}
888b14e074992baaeb081de01c4d43abce3c300b2a7d4df2f387997e91f7eb14
adjustAndSetValue
public String adjustAndSetValue(String varName, String valParamName)
{    return varName + " = " + valParamName + ".truncatedTo(java.time.temporal.ChronoUnit.MILLIS);";}
0ea5abb9573f6234b5ddfa94ae97657c659ccb6ec39fdc560edda3f263516cc7
fromInt
public LocalTime fromInt(Integer millisFromMidnight, Schema schema, LogicalType type)
{    return LocalTime.ofNanoOfDay(TimeUnit.MILLISECONDS.toNanos(millisFromMidnight));}
1c7f7addde78b12ba324b08a76a40a67e08f25299e6b809d09c39d6fafa7a21e
toInt
public Integer toInt(LocalTime time, Schema schema, LogicalType type)
{    return (int) TimeUnit.NANOSECONDS.toMillis(time.toNanoOfDay());}
44afca78eb2f944191717c831b23c212dab4c09d5ffc0c38e3839f3ca0d439cd
getRecommendedSchema
public Schema getRecommendedSchema()
{    return LogicalTypes.timeMillis().addToSchema(Schema.create(Schema.Type.INT));}
ca5a4991a87b08bb3d00a23c8e29ed710f3584d9b73c07baf5ca2a0eef9ed1b0
getConvertedType
public Class<LocalTime> getConvertedType()
{    return LocalTime.class;}
79c42293ac3a43d7598dc0ac8104dd9a114e436cd5a14a6241ebbe2b10b5f8ba
getLogicalTypeName
public String getLogicalTypeName()
{    return "time-micros";}
888b14e074992baaeb081de01c4d43abce3c300b2a7d4df2f387997e91f7eb14
adjustAndSetValue
public String adjustAndSetValue(String varName, String valParamName)
{    return varName + " = " + valParamName + ".truncatedTo(java.time.temporal.ChronoUnit.MICROS);";}
1981b533260c37960853f20a0ebf8e967edcf728ead63bf6adbf92cf24f54482
fromLong
public LocalTime fromLong(Long microsFromMidnight, Schema schema, LogicalType type)
{    return LocalTime.ofNanoOfDay(TimeUnit.MICROSECONDS.toNanos(microsFromMidnight));}
86133704ac936c81b4f3f60738d3b7b5b2313f961c132701f49370a0c9e1f234
toLong
public Long toLong(LocalTime time, Schema schema, LogicalType type)
{    return TimeUnit.NANOSECONDS.toMicros(time.toNanoOfDay());}
44afca78eb2f944191717c831b23c212dab4c09d5ffc0c38e3839f3ca0d439cd
getRecommendedSchema
public Schema getRecommendedSchema()
{    return LogicalTypes.timeMicros().addToSchema(Schema.create(Schema.Type.LONG));}
f21a8195ac4dd378b42f499ae0f437da76c8a98d8a06b176fcfecaf83ce148a7
getConvertedType
public Class<Instant> getConvertedType()
{    return Instant.class;}
79c42293ac3a43d7598dc0ac8104dd9a114e436cd5a14a6241ebbe2b10b5f8ba
getLogicalTypeName
public String getLogicalTypeName()
{    return "timestamp-millis";}
888b14e074992baaeb081de01c4d43abce3c300b2a7d4df2f387997e91f7eb14
adjustAndSetValue
public String adjustAndSetValue(String varName, String valParamName)
{    return varName + " = " + valParamName + ".truncatedTo(java.time.temporal.ChronoUnit.MILLIS);";}
b1be35cfcc17fb2d277e9b5af580b6fea3e8f6a1d42fad025945e7940f9992c8
fromLong
public Instant fromLong(Long millisFromEpoch, Schema schema, LogicalType type)
{    return Instant.ofEpochMilli(millisFromEpoch);}
98d0a4ffd88d6444153ee84505f136b4dba580885d45d147dd12f0bbd1eb59eb
toLong
public Long toLong(Instant timestamp, Schema schema, LogicalType type)
{    return timestamp.toEpochMilli();}
44afca78eb2f944191717c831b23c212dab4c09d5ffc0c38e3839f3ca0d439cd
getRecommendedSchema
public Schema getRecommendedSchema()
{    return LogicalTypes.timestampMillis().addToSchema(Schema.create(Schema.Type.LONG));}
f21a8195ac4dd378b42f499ae0f437da76c8a98d8a06b176fcfecaf83ce148a7
getConvertedType
public Class<Instant> getConvertedType()
{    return Instant.class;}
79c42293ac3a43d7598dc0ac8104dd9a114e436cd5a14a6241ebbe2b10b5f8ba
getLogicalTypeName
public String getLogicalTypeName()
{    return "timestamp-micros";}
888b14e074992baaeb081de01c4d43abce3c300b2a7d4df2f387997e91f7eb14
adjustAndSetValue
public String adjustAndSetValue(String varName, String valParamName)
{    return varName + " = " + valParamName + ".truncatedTo(java.time.temporal.ChronoUnit.MICROS);";}
360340bce2b383a143df8a2e76476583bf76165304de5ada3d98a2ca254618fb
fromLong
public Instant fromLong(Long microsFromEpoch, Schema schema, LogicalType type)
{    long epochSeconds = microsFromEpoch / (1_000_000);    long nanoAdjustment = (microsFromEpoch % (1_000_000)) * 1_000;    return Instant.ofEpochSecond(epochSeconds, nanoAdjustment);}
3bffeffc194c2339f8c9b07d5fbacc708b6f0e72953bb62f243e18dad592a104
toLong
public Long toLong(Instant instant, Schema schema, LogicalType type)
{    long seconds = instant.getEpochSecond();    int nanos = instant.getNano();    if (seconds < 0 && nanos > 0) {        long micros = Math.multiplyExact(seconds + 1, 1_000_000);        long adjustment = (nanos / 1_000L) - 1_000_000;        return Math.addExact(micros, adjustment);    } else {        long micros = Math.multiplyExact(seconds, 1_000_000);        return Math.addExact(micros, nanos / 1_000);    }}
44afca78eb2f944191717c831b23c212dab4c09d5ffc0c38e3839f3ca0d439cd
getRecommendedSchema
public Schema getRecommendedSchema()
{    return LogicalTypes.timestampMicros().addToSchema(Schema.create(Schema.Type.LONG));}
fe6313efc00228b421abe8b77a284f4682aa4c5681a1c04eede6f769cf07816e
getConvertedType
public Class<LocalDateTime> getConvertedType()
{    return LocalDateTime.class;}
79c42293ac3a43d7598dc0ac8104dd9a114e436cd5a14a6241ebbe2b10b5f8ba
getLogicalTypeName
public String getLogicalTypeName()
{    return "local-timestamp-millis";}
072c6db82277176f7169b2d52ab23bbc6933efc185e97a773fbee5863d928371
fromLong
public LocalDateTime fromLong(Long millisFromEpoch, Schema schema, LogicalType type)
{    Instant instant = timestampMillisConversion.fromLong(millisFromEpoch, schema, type);    return LocalDateTime.ofInstant(instant, ZoneOffset.UTC);}
9aae39ef4d29094423cfeb1a52d6093328cb96f31fbd4b41953f6385417ef8bc
toLong
public Long toLong(LocalDateTime timestamp, Schema schema, LogicalType type)
{    Instant instant = timestamp.toInstant(ZoneOffset.UTC);    return timestampMillisConversion.toLong(instant, schema, type);}
44afca78eb2f944191717c831b23c212dab4c09d5ffc0c38e3839f3ca0d439cd
getRecommendedSchema
public Schema getRecommendedSchema()
{    return LogicalTypes.localTimestampMillis().addToSchema(Schema.create(Schema.Type.LONG));}
fe6313efc00228b421abe8b77a284f4682aa4c5681a1c04eede6f769cf07816e
getConvertedType
public Class<LocalDateTime> getConvertedType()
{    return LocalDateTime.class;}
79c42293ac3a43d7598dc0ac8104dd9a114e436cd5a14a6241ebbe2b10b5f8ba
getLogicalTypeName
public String getLogicalTypeName()
{    return "local-timestamp-micros";}
103aea5effeeb8721ff7fe169f1d8d60f36c38463ac2067c7340350cc867f3ba
fromLong
public LocalDateTime fromLong(Long microsFromEpoch, Schema schema, LogicalType type)
{    Instant instant = timestampMicrosConversion.fromLong(microsFromEpoch, schema, type);    return LocalDateTime.ofInstant(instant, ZoneOffset.UTC);}
9aae39ef4d29094423cfeb1a52d6093328cb96f31fbd4b41953f6385417ef8bc
toLong
public Long toLong(LocalDateTime timestamp, Schema schema, LogicalType type)
{    Instant instant = timestamp.toInstant(ZoneOffset.UTC);    return timestampMicrosConversion.toLong(instant, schema, type);}
44afca78eb2f944191717c831b23c212dab4c09d5ffc0c38e3839f3ca0d439cd
getRecommendedSchema
public Schema getRecommendedSchema()
{    return LogicalTypes.localTimestampMicros().addToSchema(Schema.create(Schema.Type.LONG));}
81a04e0fa34035715e5fcd328c7c64ca44bc44216a36ae2dfa47e39fb2251b93
createInstance
protected Codec createInstance()
{    return new BZip2Codec();}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return DataFileConstants.BZIP2_CODEC;}
fa244c50e50f15ca5796769418ba04b60e3455574dfb2e26c7320373aa416bbb
compress
public ByteBuffer compress(ByteBuffer uncompressedData) throws IOException
{    ByteArrayOutputStream baos = getOutputBuffer(uncompressedData.remaining());    try (BZip2CompressorOutputStream outputStream = new BZip2CompressorOutputStream(baos)) {        outputStream.write(uncompressedData.array(), computeOffset(uncompressedData), uncompressedData.remaining());    }    return ByteBuffer.wrap(baos.toByteArray());}
2891f7d8f7e1726c3c7c8e9e1adbeb7b13f1bfc6a89c5663266d5c3e375edab9
decompress
public ByteBuffer decompress(ByteBuffer compressedData) throws IOException
{    ByteArrayInputStream bais = new ByteArrayInputStream(compressedData.array(), computeOffset(compressedData), compressedData.remaining());    try (BZip2CompressorInputStream inputStream = new BZip2CompressorInputStream(bais)) {        ByteArrayOutputStream baos = new ByteArrayOutputStream();        int readCount = -1;        while ((readCount = inputStream.read(buffer, compressedData.position(), buffer.length)) > 0) {            baos.write(buffer, 0, readCount);        }        return ByteBuffer.wrap(baos.toByteArray());    }}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return getName().hashCode();}
4afeb0868b55bdd8e18a00a3cb43d83e0714378d1c4bb36f0936daefc060e2e8
equals
public boolean equals(Object obj)
{    if (this == obj)        return true;    return obj != null && obj.getClass() == getClass();}
401b1ec2640fcf0263c4f04854301af09f7e01a9e464c8d29e1cf62288406fc5
getOutputBuffer
private ByteArrayOutputStream getOutputBuffer(int suggestedLength)
{    if (null == outputBuffer) {        outputBuffer = new ByteArrayOutputStream(suggestedLength);    }    outputBuffer.reset();    return outputBuffer;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return getName();}
b0482a21aa95c822aaaf2985730863f1cef72e4c372b89fc69af09af34a45ccc
computeOffset
protected static int computeOffset(ByteBuffer data)
{    return data.arrayOffset() + data.position();}
2e5517f435f9dc699820d68e4cb432ff69a00551a511d1f1304d145859704f33
nullCodec
public static CodecFactory nullCodec()
{    return NullCodec.OPTION;}
4ef0ce8306cd140ca95513fe873241bea3b18b65909bd3b8c7d21d386c4d981c
deflateCodec
public static CodecFactory deflateCodec(int compressionLevel)
{    return new DeflateCodec.Option(compressionLevel);}
4a5bd019d818a87f35a12161eb8de3279d177cf5fbfa7f0edc99515eb0dfbb9d
xzCodec
public static CodecFactory xzCodec(int compressionLevel)
{    return new XZCodec.Option(compressionLevel);}
fb9cecc813b3b16f9a04d9927a5546dbba4ec761aee02882fbefc144ea93526b
snappyCodec
public static CodecFactory snappyCodec()
{    try {        return new SnappyCodec.Option();    } catch (Throwable t) {        LOG.debug("Snappy was not available", t);        return null;    }}
732e6516fbdd8959a4fbc5ff2daf39a910143963432013e9163760ea0a69bd40
bzip2Codec
public static CodecFactory bzip2Codec()
{    return new BZip2Codec.Option();}
e7739bc4eb93bb222d550c1284607ed2638fe5ecec0808eb9738d28f93740fca
zstandardCodec
public static CodecFactory zstandardCodec(int level)
{    return new ZstandardCodec.Option(level, false);}
270f55cd2b77409544aaa8b23a122596f267a0f5f91b7c8b54e1bbdde961330d
zstandardCodec
public static CodecFactory zstandardCodec(int level, boolean useChecksum)
{    return new ZstandardCodec.Option(level, useChecksum);}
b52543911d5c1f942f8395c500cc5906c6a720e5cdbd4822af80ea9e44a2352f
fromString
public static CodecFactory fromString(String s)
{    CodecFactory o = REGISTERED.get(s);    if (o == null) {        throw new AvroRuntimeException("Unrecognized codec: " + s);    }    return o;}
834d5bc5455dba171e7b94a549040ce0c9edca3849bb04a70ea579943c4c2187
addCodec
public static CodecFactory addCodec(String name, CodecFactory c)
{    if (c != null) {        return REGISTERED.put(name, c);    }    return null;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    Codec instance = this.createInstance();    return instance.toString();}
5beb0067017e308772622c62655cdaf02eb6d3cf8f6ee70eae27aa41def89765
openReader
public static FileReader<D> openReader(File file, DatumReader<D> reader) throws IOException
{    SeekableFileInput input = new SeekableFileInput(file);    try {        return openReader(input, reader);    } catch (final Throwable e) {        IOUtils.closeQuietly(input);        throw e;    }}
2dc8121046a06e8ed9eede6af9e75fc1023cc4b22ae72bdc5794697cb87fc8ca
openReader
public static FileReader<D> openReader(SeekableInput in, DatumReader<D> reader) throws IOException
{    if (in.length() < MAGIC.length)        throw new InvalidAvroMagicException("Not an Avro data file");        byte[] magic = new byte[MAGIC.length];    in.seek(0);    for (int c = 0; c < magic.length; c = in.read(magic, c, magic.length - c)) {    }    in.seek(0);    if (    Arrays.equals(MAGIC, magic))        return new DataFileReader<>(in, reader);    if (    Arrays.equals(DataFileReader12.MAGIC, magic))        return new DataFileReader12<>(in, reader);    throw new InvalidAvroMagicException("Not an Avro data file");}
0de08c55bad6e89d3edf439260fa064eced5901dca019b6a62deaebfa3edb0bf
openReader
public static DataFileReader<D> openReader(SeekableInput in, DatumReader<D> reader, Header header, boolean sync) throws IOException
{    DataFileReader<D> dreader = new DataFileReader<>(in, reader, header);        if (sync)        dreader.sync(in.tell());    else        dreader.seek(in.tell());    return dreader;}
62032bfd4a1c0bb1c932a4c527e1d71aebf93308af8494a3c9f3705168a09088
seek
public void seek(long position) throws IOException
{    sin.seek(position);    vin = DecoderFactory.get().binaryDecoder(this.sin, vin);    datumIn = null;    blockRemaining = 0;    blockStart = position;}
1ef31825c3ea730717cd39903131dde1e7da428add57c8d2d35fe425543ec29b
sync
public void sync(long position) throws IOException
{    seek(position);        if ((position == 0) && (getMeta("avro.sync") != null)) {                initialize(sin);        return;    }    try {        int i = 0, b;        InputStream in = vin.inputStream();        vin.readFixed(syncBuffer);        do {            int j = 0;            for (; j < SYNC_SIZE; j++) {                if (getHeader().sync[j] != syncBuffer[(i + j) % SYNC_SIZE])                    break;            }            if (j == SYNC_SIZE) {                                blockStart = position + i + SYNC_SIZE;                return;            }            b = in.read();            syncBuffer[i++ % SYNC_SIZE] = (byte) b;        } while (b != -1);    } catch (EOFException e) {        }        blockStart = sin.tell();}
b97a40a536f41e88ef2119a6853e48bcf778faa6d8f80ec45ab255d1b8fc68fc
blockFinished
protected void blockFinished() throws IOException
{    blockStart = sin.tell() - vin.inputStream().available();}
1c5b10e1e7062d09b64b27ed3bc6e2ce17937217f930597d89f38ccab5866421
previousSync
public long previousSync()
{    return blockStart;}
fc3db9c636510e5e099bba6cc5b15e2a96a29d25a27e0519fd4dfdc8dcb26f4d
pastSync
public boolean pastSync(long position) throws IOException
{    return ((blockStart >= position + SYNC_SIZE) || (blockStart >= sin.length()));}
0efa2bd8fc7bc3d72996c492a3eaca80646290caeceea873a5afabb84aa9504c
tell
public long tell() throws IOException
{    return sin.tell();}
d82b4dff89e8597e847f70bbec619b3fbe6165fdff6be403c9711e93ebce3d4d
seek
public void seek(long p) throws IOException
{    if (p < 0)        throw new IOException("Illegal seek: " + p);    in.seek(p);}
0efa2bd8fc7bc3d72996c492a3eaca80646290caeceea873a5afabb84aa9504c
tell
public long tell() throws IOException
{    return in.tell();}
6be07d6c52de04a91907264c1c435ebdd48a3b2cf48f2e117699a543fff56681
length
public long length() throws IOException
{    return in.length();}
f1bd356e482fbc023feab89d2655df447ac6f2bcd456f7c68cc5c21e4167b36b
read
public int read(byte[] b) throws IOException
{    return in.read(b, 0, b.length);}
56e08d87e6bd0be2a60f9b2de3195d58bc9d56a2637f6fed6210d21e832632ea
read
public int read(byte[] b, int off, int len) throws IOException
{    return in.read(b, off, len);}
00c6cb892813c6b89e072a7f09dccdece629f30849daab28245b06f3e679bf54
read
public int read() throws IOException
{    int n = read(oneByte, 0, 1);    if (n == 1) {        return oneByte[0] & 0xff;    } else {        return n;    }}
3971c4ae38a1eaf0d2eb3c259cb42d3dd3d921316fc11725afe8b8fbc5c5a62e
skip
public long skip(long skip) throws IOException
{    long position = in.tell();    long length = in.length();    long remaining = length - position;    if (remaining > skip) {        in.seek(skip);        return in.tell() - position;    } else {        in.seek(remaining);        return in.tell() - position;    }}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    in.close();    super.close();}
02422e619fc950e443408bbd36203c4155e09261ea21c537537f17f6e4a56d8f
available
public int available() throws IOException
{    long remaining = (in.length() - in.tell());    return (remaining > Integer.MAX_VALUE) ? Integer.MAX_VALUE : (int) remaining;}
e7632a64960c6cb2841aec7f4203d818e222f15bd52bca3b53bedf40ea8dc0e1
getMeta
public synchronized byte[] getMeta(String key)
{    return meta.get(key);}
062dffb3860a979ec9b6c46012f8414d7638262754f42b8918da20d035de3a70
getMetaString
public synchronized String getMetaString(String key)
{    byte[] value = getMeta(key);    if (value == null) {        return null;    }    return new String(value, StandardCharsets.UTF_8);}
b3684ca5ed3e75c653cfa42b2553f14007a756e57716d07ef2e84ad387ed3cdf
getMetaLong
public synchronized long getMetaLong(String key)
{    return Long.parseLong(getMetaString(key));}
b74ae948bba816a824396f5fcd959e744592a67ff01eb79c422acb487a04550a
getSchema
public Schema getSchema()
{    return schema;}
a031f950dbcd28fec27c8f208752c6708e5dc1766a501104b5206d52cec12976
iterator
public Iterator<D> iterator()
{    return this;}
d51e5f7450eca0a0f63da1a466189e262d053b84aa767ba3be5cea740af7251b
hasNext
public boolean hasNext()
{    if (peek != null || blockCount != 0)        return true;    this.peek = next();    return peek != null;}
bcf3741d1e793bddf2847f47034bb3e589dc0cdc8a62c7d8a34bf22ea417a01e
next
public D next()
{    if (peek != null) {        D result = peek;        peek = null;        return result;    }    try {        return next(null);    } catch (IOException e) {        throw new RuntimeException(e);    }}
eb35e4acc0ab2c89fd30970f01fba35488b3a4581b2af1986091209043508a3e
remove
public void remove()
{    throw new UnsupportedOperationException();}
e8fc227d7fe1acec6543b595bcef3e5f678015d33555f748ca67da3277841d91
next
public synchronized D next(D reuse) throws IOException
{    while (blockCount == 0) {        if (        in.tell() == in.length())            return null;                skipSync();                blockCount = vin.readLong();        if (blockCount == FOOTER_BLOCK) {                        seek(vin.readLong() + in.tell());        }    }    blockCount--;    return reader.read(reuse, vin);}
fa292791fa03cf4f2bf816dde9252a8853cc2abe8ac65cbefc6617fddb82ec9a
skipSync
private void skipSync() throws IOException
{    vin.readFixed(syncBuffer);    if (!Arrays.equals(syncBuffer, sync))        throw new IOException("Invalid sync!");}
67ae810c140a7d118747d9132210dde985b5b6e02fee5147e10d77a2082e91d2
seek
public synchronized void seek(long position) throws IOException
{    in.seek(position);    blockCount = 0;    blockStart = position;    vin = DecoderFactory.get().binaryDecoder(in, vin);}
c56f7ea5d74a1f0cfa07d9ccf94d6b43963a48bf3cfc993b04aa5946a45f5d02
sync
public synchronized void sync(long position) throws IOException
{    if (in.tell() + SYNC_SIZE >= in.length()) {        seek(in.length());        return;    }    in.seek(position);    vin.readFixed(syncBuffer);    for (int i = 0; in.tell() < in.length(); i++) {        int j = 0;        for (; j < sync.length; j++) {            if (sync[j] != syncBuffer[(i + j) % sync.length])                break;        }        if (j == sync.length) {                        seek(in.tell() - SYNC_SIZE);            return;        }        syncBuffer[i % sync.length] = (byte) in.read();    }    seek(in.length());}
fc3db9c636510e5e099bba6cc5b15e2a96a29d25a27e0519fd4dfdc8dcb26f4d
pastSync
public boolean pastSync(long position) throws IOException
{    return ((blockStart >= position + SYNC_SIZE) || (blockStart >= in.length()));}
0efa2bd8fc7bc3d72996c492a3eaca80646290caeceea873a5afabb84aa9504c
tell
public long tell() throws IOException
{    return in.tell();}
9b54ee9eb50c9cbdd959f0273108f77f9dc460339fff2b1de4192c511db8fe67
close
public synchronized void close() throws IOException
{    in.close();}
29d4aafe01c309209f4fc1962573acc3a6ffeaef9673961241e48c48a3b3ffc2
initialize
 void initialize(InputStream in) throws IOException
{    this.header = new Header();    this.vin = DecoderFactory.get().binaryDecoder(in, vin);    byte[] magic = new byte[DataFileConstants.MAGIC.length];    try {                vin.readFixed(magic);    } catch (IOException e) {        throw new IOException("Not an Avro data file.", e);    }    if (!Arrays.equals(DataFileConstants.MAGIC, magic))        throw new InvalidAvroMagicException("Not an Avro data file.");        long l = vin.readMapStart();    if (l > 0) {        do {            for (long i = 0; i < l; i++) {                String key = vin.readString(null).toString();                ByteBuffer value = vin.readBytes(null);                byte[] bb = new byte[value.remaining()];                value.get(bb);                header.meta.put(key, bb);                header.metaKeyList.add(key);            }        } while ((l = vin.mapNext()) != 0);    }        vin.readFixed(header.sync);        header.metaKeyList = Collections.unmodifiableList(header.metaKeyList);    header.schema = new Schema.Parser().setValidate(false).parse(getMetaString(DataFileConstants.SCHEMA));    this.codec = resolveCodec();    reader.setSchema(header.schema);}
05c9d2badc4ca13c0e3d66d690132c62b70b3807591054321d929341cf428d15
initialize
 void initialize(InputStream in, Header header) throws IOException
{    this.header = header;    this.codec = resolveCodec();    reader.setSchema(header.schema);}
846cf26bc1dda464275a57f4f036e7c223d33e7463918b43c4b84a566662eb40
resolveCodec
 Codec resolveCodec()
{    String codecStr = getMetaString(DataFileConstants.CODEC);    if (codecStr != null) {        return CodecFactory.fromString(codecStr).createInstance();    } else {        return CodecFactory.nullCodec().createInstance();    }}
c680900ae37d77c429d202ae1f2fa7a22ba008ce9546fbf14d70bd81fc9a27a8
getHeader
public Header getHeader()
{    return header;}
b74ae948bba816a824396f5fcd959e744592a67ff01eb79c422acb487a04550a
getSchema
public Schema getSchema()
{    return header.schema;}
32bd0271771a4a9f5d2289099b427c0ce49e1e88faa0301e1e6a898a3b184d2f
getMetaKeys
public List<String> getMetaKeys()
{    return header.metaKeyList;}
0cf89edd7325555b52b730c58cdc76a1f739cf8b22b25abe4e35ad196178d80d
getMeta
public byte[] getMeta(String key)
{    return header.meta.get(key);}
9b9d53e96de6a5897a506350149e7306faabae01d008bdf773af6f3007d08dc8
getMetaString
public String getMetaString(String key)
{    byte[] value = getMeta(key);    if (value == null) {        return null;    }    return new String(value, StandardCharsets.UTF_8);}
ba8da7c5703700d68e737146d6d703ef4e059fc726d4954571e161ad3f2a8c71
getMetaLong
public long getMetaLong(String key)
{    return Long.parseLong(getMetaString(key));}
a031f950dbcd28fec27c8f208752c6708e5dc1766a501104b5206d52cec12976
iterator
public Iterator<D> iterator()
{    return this;}
d51e5f7450eca0a0f63da1a466189e262d053b84aa767ba3be5cea740af7251b
hasNext
public boolean hasNext()
{    try {        if (blockRemaining == 0) {                        if (null != datumIn) {                boolean atEnd = datumIn.isEnd();                if (!atEnd) {                    throw new IOException("Block read partially, the data may be corrupt");                }            }            if (hasNextBlock()) {                block = nextRawBlock(block);                block.decompressUsing(codec);                blockBuffer = block.getAsByteBuffer();                datumIn = DecoderFactory.get().binaryDecoder(blockBuffer.array(), blockBuffer.arrayOffset() + blockBuffer.position(), blockBuffer.remaining(), datumIn);            }        }        return blockRemaining != 0;    } catch (EOFException e) {                return false;    } catch (IOException e) {        throw new AvroRuntimeException(e);    }}
bcf3741d1e793bddf2847f47034bb3e589dc0cdc8a62c7d8a34bf22ea417a01e
next
public D next()
{    try {        return next(null);    } catch (IOException e) {        throw new AvroRuntimeException(e);    }}
e76b0d78fb9f5a42e67b546eca50f3acf21ed241182ead5032ec278d7f27eb86
next
public D next(D reuse) throws IOException
{    if (!hasNext())        throw new NoSuchElementException();    D result = reader.read(reuse, datumIn);    if (0 == --blockRemaining) {        blockFinished();    }    return result;}
84fc23fbf8fa9064aad119cdd05586e7dd105e1ed4d283c21194f1ec548feaf8
nextBlock
public ByteBuffer nextBlock() throws IOException
{    if (!hasNext())        throw new NoSuchElementException();    if (blockRemaining != blockCount)        throw new IllegalStateException("Not at block start.");    blockRemaining = 0;    datumIn = null;    return blockBuffer;}
8ede378199ee41c612b4419c09d39d42ac8f07a44a043e09595100694ab5cb64
getBlockCount
public long getBlockCount()
{    return blockCount;}
d4c9f4338b18f336c215c62cf6a930a54cd1bb17e39f6ae821829146d7b8866a
getBlockSize
public long getBlockSize()
{    return blockSize;}
b97a40a536f41e88ef2119a6853e48bcf778faa6d8f80ec45ab255d1b8fc68fc
blockFinished
protected void blockFinished() throws IOException
{}
4f1f14de7d830001bd6be5d274854c60072ca7d4df1b9ae46a9c0df05f547c99
hasNextBlock
 boolean hasNextBlock()
{    try {        if (availableBlock)            return true;        if (vin.isEnd())            return false;                blockRemaining = vin.readLong();                blockSize = vin.readLong();        if (blockSize > Integer.MAX_VALUE || blockSize < 0) {            throw new IOException("Block size invalid or too large for this " + "implementation: " + blockSize);        }        blockCount = blockRemaining;        availableBlock = true;        return true;    } catch (EOFException eof) {        return false;    } catch (IOException e) {        throw new AvroRuntimeException(e);    }}
1c9bc3847dd991a3c428654e1d14c830f02318b0641db78faf97c0d95b73271d
nextRawBlock
 DataBlock nextRawBlock(DataBlock reuse) throws IOException
{    if (!hasNextBlock()) {        throw new NoSuchElementException();    }    if (reuse == null || reuse.data.length < (int) blockSize) {        reuse = new DataBlock(blockRemaining, (int) blockSize);    } else {        reuse.numEntries = blockRemaining;        reuse.blockSize = (int) blockSize;    }        vin.readFixed(reuse.data, 0, reuse.blockSize);    vin.readFixed(syncBuffer);    availableBlock = false;    if (!Arrays.equals(syncBuffer, header.sync))        throw new IOException("Invalid sync!");    return reuse;}
eb35e4acc0ab2c89fd30970f01fba35488b3a4581b2af1986091209043508a3e
remove
public void remove()
{    throw new UnsupportedOperationException();}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    vin.inputStream().close();}
d7620fd719a908c8e70d2ed09444dbfecccb5c8f880f191eb48650f2b409dfa3
getData
 byte[] getData()
{    return data;}
ed0d128ffe639ae4bdb7deddd932be358ca1fbe6265a433443623f3a5742d02e
getNumEntries
 long getNumEntries()
{    return numEntries;}
57be26346ff7d7559f7635a04cb7ce84e18f74e80a8d58293f64987079ddc406
getBlockSize
 int getBlockSize()
{    return blockSize;}
5ecb506f56d624378b86bc8d9483b9db83731f33b6b7b2aa75df258a7cfd4a6d
isFlushOnWrite
 boolean isFlushOnWrite()
{    return flushOnWrite;}
b4c2967f71c1da705f8c7e6f799583edafb4aa63ccd6ec574e589b5035318326
setFlushOnWrite
 void setFlushOnWrite(boolean flushOnWrite)
{    this.flushOnWrite = flushOnWrite;}
56617914a84dff67990bef0894584cfc0c7f5cb3288a788bf262201de6877199
getAsByteBuffer
 ByteBuffer getAsByteBuffer()
{    return ByteBuffer.wrap(data, offset, blockSize);}
bff680fb9b4b1623552b131e97640e2206c4ceaef97ec20db78b0b540cf5c514
decompressUsing
 void decompressUsing(Codec c) throws IOException
{    ByteBuffer result = c.decompress(getAsByteBuffer());    data = result.array();    blockSize = result.remaining();}
3af9ece79652d7ace8d808de82ca6a7ac402af48b6d19be185a695ef4229f5ac
compressUsing
 void compressUsing(Codec c) throws IOException
{    ByteBuffer result = c.compress(getAsByteBuffer());    data = result.array();    blockSize = result.remaining();}
5b25b8b1dc82995c6b64d65bcb12375a9727fd18fa07df53812291e48e9478c6
writeBlockTo
 void writeBlockTo(BinaryEncoder e, byte[] sync) throws IOException
{    e.writeLong(this.numEntries);    e.writeLong(this.blockSize);    e.writeFixed(this.data, offset, this.blockSize);    e.writeFixed(sync);    if (flushOnWrite) {        e.flush();    }}
b1a36d9de111aedae947c0b6db250c80b625846b51f765894d6aa598f8f5a03e
assertOpen
private void assertOpen()
{    if (!isOpen)        throw new AvroRuntimeException("not open");}
aea02ddc045960590738e9511feebe8c3cbbb4a1d88083c3ac6ce9d6779ab5e0
assertNotOpen
private void assertNotOpen()
{    if (isOpen)        throw new AvroRuntimeException("already open");}
75117435f3d8dcc5a97c44148f34f3b4c8b454671e7e47abad4599d160ed0dcb
setCodec
public DataFileWriter<D> setCodec(CodecFactory c)
{    assertNotOpen();    this.codec = c.createInstance();    setMetaInternal(DataFileConstants.CODEC, codec.getName());    return this;}
401c7b149838fa24190e3225a942b7f370c72d1a3ebc69a2b3b0df6fdda89142
setSyncInterval
public DataFileWriter<D> setSyncInterval(int syncInterval)
{    if (syncInterval < 32 || syncInterval > (1 << 30)) {        throw new IllegalArgumentException("Invalid syncInterval value: " + syncInterval);    }    this.syncInterval = syncInterval;    return this;}
e1ee9f474de2d20f23c9856731cf999e6b522ee1d90af756f741250b2f05b9cf
create
public DataFileWriter<D> create(Schema schema, File file) throws IOException
{    SyncableFileOutputStream sfos = new SyncableFileOutputStream(file);    try {        return create(schema, sfos, null);    } catch (final Throwable e) {        IOUtils.closeQuietly(sfos);        throw e;    }}
c1234b48079713a566f2afa079cdf932e44d410685a9142a69302f5f610118a8
create
public DataFileWriter<D> create(Schema schema, OutputStream outs) throws IOException
{    return create(schema, outs, null);}
f19e96e0673b30b8b5ed5cf8d1b0c55e517d1fc45241f383bd809c5c89210681
create
public DataFileWriter<D> create(Schema schema, OutputStream outs, byte[] sync) throws IOException
{    assertNotOpen();    this.schema = schema;    setMetaInternal(DataFileConstants.SCHEMA, schema.toString());    if (sync == null) {        this.sync = generateSync();    } else if (sync.length == 16) {        this.sync = sync;    } else {        throw new IOException("sync must be exactly 16 bytes");    }    init(outs);        vout.writeFixed(DataFileConstants.MAGIC);        vout.writeMapStart();    vout.setItemCount(meta.size());    for (Map.Entry<String, byte[]> entry : meta.entrySet()) {        vout.startItem();        vout.writeString(entry.getKey());        vout.writeBytes(entry.getValue());    }    vout.writeMapEnd();        vout.writeFixed(this.sync);        vout.flush();    return this;}
fede312ae4dbb7ee13149711895e146f3228f4f90fe3ca7554f342816a58c258
setFlushOnEveryBlock
public void setFlushOnEveryBlock(boolean flushOnEveryBlock)
{    this.flushOnEveryBlock = flushOnEveryBlock;}
8499d239c80237bf1bcd6345c434feacbe5eecb0cefa8dab287e9a1690dc0c1e
isFlushOnEveryBlock
public boolean isFlushOnEveryBlock()
{    return this.flushOnEveryBlock;}
0c13b487d8d646492244935afa36ae34127a9dfd46b589a0d881f4bb20d7010a
appendTo
public DataFileWriter<D> appendTo(File file) throws IOException
{    try (SeekableInput input = new SeekableFileInput(file)) {        OutputStream output = new SyncableFileOutputStream(file, true);        return appendTo(input, output);    }}
1e050a8e087b7a99870f543e5deb39cfbf6dba3c7924d7598b3b906ff67f869a
appendTo
public DataFileWriter<D> appendTo(SeekableInput in, OutputStream out) throws IOException
{    assertNotOpen();    DataFileReader<D> reader = new DataFileReader<>(in, new GenericDatumReader<>());    this.schema = reader.getSchema();    this.sync = reader.getHeader().sync;    this.meta.putAll(reader.getHeader().meta);    byte[] codecBytes = this.meta.get(DataFileConstants.CODEC);    if (codecBytes != null) {        String strCodec = new String(codecBytes, StandardCharsets.UTF_8);        this.codec = CodecFactory.fromString(strCodec).createInstance();    } else {        this.codec = CodecFactory.nullCodec().createInstance();    }    init(out);    return this;}
cfdfb76f146a4164b1a145ea619d07d5f342ced4b98b9b94910c8e381c8cccf6
init
private void init(OutputStream outs) throws IOException
{    this.underlyingStream = outs;    this.out = new BufferedFileOutputStream(outs);    EncoderFactory efactory = new EncoderFactory();    this.vout = efactory.binaryEncoder(out, null);    dout.setSchema(schema);    buffer = new NonCopyingByteArrayOutputStream(Math.min((int) (syncInterval * 1.25), Integer.MAX_VALUE / 2 - 1));    this.bufOut = efactory.binaryEncoder(buffer, null);    if (this.codec == null) {        this.codec = CodecFactory.nullCodec().createInstance();    }    this.isOpen = true;}
0cdfda99c450b02d3728040872d1f92517e8edb52eba6cbb0a55cfeea7ca6583
generateSync
private static byte[] generateSync()
{    try {        MessageDigest digester = MessageDigest.getInstance("MD5");        long time = System.currentTimeMillis();        digester.update((UUID.randomUUID() + "@" + time).getBytes(UTF_8));        return digester.digest();    } catch (NoSuchAlgorithmException e) {        throw new RuntimeException(e);    }}
9af143a2c17ba3b42ad317cb71efa09d54c761f3b119fc9b06ecf7917ac46d4f
setMetaInternal
private DataFileWriter<D> setMetaInternal(String key, byte[] value)
{    assertNotOpen();    meta.put(key, value);    return this;}
1aa09ac0de9980ce4c9cfbd9367edf4715adf118a30128204371f989e2c7e069
setMetaInternal
private DataFileWriter<D> setMetaInternal(String key, String value)
{    return setMetaInternal(key, value.getBytes(UTF_8));}
e23b691039f1b2f2aa42713deedc9aa2daccc9c2e8f562756f21b5fd6e106474
setMeta
public DataFileWriter<D> setMeta(String key, byte[] value)
{    if (isReservedMeta(key)) {        throw new AvroRuntimeException("Cannot set reserved meta key: " + key);    }    return setMetaInternal(key, value);}
37e79204db20b29f7986b5a050796de3b769c3a537c2425be3b8a10942be44ec
isReservedMeta
public static boolean isReservedMeta(String key)
{    return key.startsWith("avro.");}
00506dcef1344ffd0ba2e7b694b75e60031844420b3015b9756bf783fd017915
setMeta
public DataFileWriter<D> setMeta(String key, String value)
{    return setMeta(key, value.getBytes(UTF_8));}
203e055e0c0d580cc1e3bc3e51fb1e776b3779c01c5803a7fdd530d67a7ae487
setMeta
public DataFileWriter<D> setMeta(String key, long value)
{    return setMeta(key, Long.toString(value));}
6fee0a0134308c6b817f51074f62bc4ba51a9c58f6091ea9e587b65d1f9c5c92
append
public void append(D datum) throws IOException
{    assertOpen();    int usedBuffer = bufferInUse();    try {        dout.write(datum, bufOut);    } catch (IOException | RuntimeException e) {        resetBufferTo(usedBuffer);        throw new AppendWriteException(e);    }    blockCount++;    writeIfBlockFull();}
8e1b1f5b680e50a136912409157dea66ffa2806ac5dbfd51cdccdee3d45d4c2a
resetBufferTo
private void resetBufferTo(int size) throws IOException
{    bufOut.flush();    byte[] data = buffer.toByteArray();    buffer.reset();    buffer.write(data, 0, size);}
1e729138e76374d16f6e16ef7463bc06ee4804fcfe33d5ef292bc4b469c31779
appendEncoded
public void appendEncoded(ByteBuffer datum) throws IOException
{    assertOpen();    bufOut.writeFixed(datum);    blockCount++;    writeIfBlockFull();}
4d79d0075540c7d4310d95c73723d929c817eaa2d00b375d668f7fa5c6cf0ada
bufferInUse
private int bufferInUse()
{    return (buffer.size() + bufOut.bytesBuffered());}
31fb92894405422448c41ff049e1a1b77eb4914ba3f2e995d72277bf5f6ea411
writeIfBlockFull
private void writeIfBlockFull() throws IOException
{    if (bufferInUse() >= syncInterval)        writeBlock();}
d464097bd3b12f89d4bac347cdcb2c86d3b9b82f4532f138d267208323b046eb
appendAllFrom
public void appendAllFrom(DataFileStream<D> otherFile, boolean recompress) throws IOException
{    assertOpen();        Schema otherSchema = otherFile.getSchema();    if (!this.schema.equals(otherSchema)) {        throw new IOException("Schema from file " + otherFile + " does not match");    }        writeBlock();    Codec otherCodec = otherFile.resolveCodec();    DataBlock nextBlockRaw = null;    if (codec.equals(otherCodec) && !recompress) {                while (otherFile.hasNextBlock()) {            nextBlockRaw = otherFile.nextRawBlock(nextBlockRaw);            nextBlockRaw.writeBlockTo(vout, sync);        }    } else {        while (otherFile.hasNextBlock()) {            nextBlockRaw = otherFile.nextRawBlock(nextBlockRaw);            nextBlockRaw.decompressUsing(otherCodec);            nextBlockRaw.compressUsing(codec);            nextBlockRaw.writeBlockTo(vout, sync);        }    }}
b95f23725dab578853681972d344e5df9ec4a7129afef60d2702613b4e8d7441
writeBlock
private void writeBlock() throws IOException
{    if (blockCount > 0) {        try {            bufOut.flush();            ByteBuffer uncompressed = buffer.getByteArrayAsByteBuffer();            DataBlock block = new DataBlock(uncompressed, blockCount);            block.setFlushOnWrite(flushOnEveryBlock);            block.compressUsing(codec);            block.writeBlockTo(vout, sync);        } finally {            buffer.reset();            blockCount = 0;        }    }}
68700e282dedb2cc4a3744ccbce0c3ac94d8bd81bb44dbc5f75e7030ae6be445
sync
public long sync() throws IOException
{    assertOpen();    writeBlock();    return out.tell();}
c3e67ec76f1b008887f1caba645a2614900cde6e477acca1bc3ecc36bf357fcf
flush
public void flush() throws IOException
{    sync();    vout.flush();}
bc8ab7f193ad777a21ff6584c2fb47e7ff385ede24b9d2d22d7e179b4969c9a3
fSync
public void fSync() throws IOException
{    flush();    if (underlyingStream instanceof Syncable) {        ((Syncable) underlyingStream).sync();    }}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    if (isOpen) {        flush();        out.close();        isOpen = false;    }}
6426ce3b66c4d2446558d8b5b93fe8a019e350f1ed5c2b61732f1efce14f0e67
write
public void write(byte[] b, int off, int len) throws IOException
{    out.write(b, off, len);        position += len;}
a10404ada8f0ac4c8bb65aec979730d7859aedb403c2b420b86e5a135b648a4f
tell
public long tell()
{    return position + count;}
53db422df1dffab79e0429a1422b1560618d4897f0be80d64f24a6aba28f9ba0
flush
public synchronized void flush() throws IOException
{    try {        super.flush();    } finally {                                count = 0;    }}
3015798d68c9532617bc86198b7f72080af862a45c24471f3fa214912b2dde58
getByteArrayAsByteBuffer
 ByteBuffer getByteArrayAsByteBuffer()
{    return ByteBuffer.wrap(buf, 0, count);}
81a04e0fa34035715e5fcd328c7c64ca44bc44216a36ae2dfa47e39fb2251b93
createInstance
protected Codec createInstance()
{    return new DeflateCodec(compressionLevel);}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return DataFileConstants.DEFLATE_CODEC;}
e0f931f2fa9291fa0526f21c81af2316aabf954f10f71f0ba4328bc069249bef
compress
public ByteBuffer compress(ByteBuffer data) throws IOException
{    ByteArrayOutputStream baos = getOutputBuffer(data.remaining());    try (OutputStream outputStream = new DeflaterOutputStream(baos, getDeflater())) {        outputStream.write(data.array(), computeOffset(data), data.remaining());    }    return ByteBuffer.wrap(baos.toByteArray());}
8199c42b1315c45dfead0e468f6a3e591ffb1b7edd9c2adbda199b6538eba83a
decompress
public ByteBuffer decompress(ByteBuffer data) throws IOException
{    ByteArrayOutputStream baos = getOutputBuffer(data.remaining());    try (OutputStream outputStream = new InflaterOutputStream(baos, getInflater())) {        outputStream.write(data.array(), computeOffset(data), data.remaining());    }    return ByteBuffer.wrap(baos.toByteArray());}
09b02b9fee25b62b33a95139a30e3e006b6567625690194e257770c53d0b2ef6
getInflater
private Inflater getInflater()
{    if (null == inflater) {        inflater = new Inflater(nowrap);    }    inflater.reset();    return inflater;}
6e3bbec9964dd46b0123dc955df183f251bd84ca10b84debc9d2e120c4de411e
getDeflater
private Deflater getDeflater()
{    if (null == deflater) {        deflater = new Deflater(compressionLevel, nowrap);    }    deflater.reset();    return deflater;}
401b1ec2640fcf0263c4f04854301af09f7e01a9e464c8d29e1cf62288406fc5
getOutputBuffer
private ByteArrayOutputStream getOutputBuffer(int suggestedLength)
{    if (null == outputBuffer) {        outputBuffer = new ByteArrayOutputStream(suggestedLength);    }    outputBuffer.reset();    return outputBuffer;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return nowrap ? 0 : 1;}
4afeb0868b55bdd8e18a00a3cb43d83e0714378d1c4bb36f0936daefc060e2e8
equals
public boolean equals(Object obj)
{    if (this == obj)        return true;    if (obj == null || obj.getClass() != getClass())        return false;    DeflateCodec other = (DeflateCodec) obj;    return (this.nowrap == other.nowrap);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return getName() + "-" + compressionLevel;}
81a04e0fa34035715e5fcd328c7c64ca44bc44216a36ae2dfa47e39fb2251b93
createInstance
protected Codec createInstance()
{    return INSTANCE;}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return DataFileConstants.NULL_CODEC;}
352831a2a648aafd1708edd0016066bfb81b74a80ad00ab57dfa1d4fd15b398c
compress
public ByteBuffer compress(ByteBuffer buffer) throws IOException
{    return buffer;}
8199c42b1315c45dfead0e468f6a3e591ffb1b7edd9c2adbda199b6538eba83a
decompress
public ByteBuffer decompress(ByteBuffer data) throws IOException
{    return data;}
74e378df448c6c3cd090d6daf881cfac8957dd555869ea4c13a46bdc6cdcf9a6
equals
public boolean equals(Object other)
{    if (this == other)        return true;    return (other != null && other.getClass() == getClass());}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return 2;}
6be07d6c52de04a91907264c1c435ebdd48a3b2cf48f2e117699a543fff56681
length
public long length() throws IOException
{    return this.count;}
d82b4dff89e8597e847f70bbec619b3fbe6165fdff6be403c9711e93ebce3d4d
seek
public void seek(long p) throws IOException
{    this.reset();    this.skip(p);}
0efa2bd8fc7bc3d72996c492a3eaca80646290caeceea873a5afabb84aa9504c
tell
public long tell() throws IOException
{    return this.pos;}
d82b4dff89e8597e847f70bbec619b3fbe6165fdff6be403c9711e93ebce3d4d
seek
public void seek(long p) throws IOException
{    getChannel().position(p);}
0efa2bd8fc7bc3d72996c492a3eaca80646290caeceea873a5afabb84aa9504c
tell
public long tell() throws IOException
{    return getChannel().position();}
6be07d6c52de04a91907264c1c435ebdd48a3b2cf48f2e117699a543fff56681
length
public long length() throws IOException
{    return getChannel().size();}
81a04e0fa34035715e5fcd328c7c64ca44bc44216a36ae2dfa47e39fb2251b93
createInstance
protected Codec createInstance()
{    return new SnappyCodec();}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return DataFileConstants.SNAPPY_CODEC;}
c8499e54f06b8a6c1a49ad640265ef3c41c4c9fd8ba3d35f0ca08560ae47cd45
compress
public ByteBuffer compress(ByteBuffer in) throws IOException
{    int offset = computeOffset(in);    ByteBuffer out = ByteBuffer.allocate(Snappy.maxCompressedLength(in.remaining()) + 4);    int size = Snappy.compress(in.array(), offset, in.remaining(), out.array(), 0);    crc32.reset();    crc32.update(in.array(), offset, in.remaining());    out.putInt(size, (int) crc32.getValue());    out.limit(size + 4);    return out;}
b842dd74745fcf59fd140f434ef6db57885e171d9375fbe02a564bcb94d31bdf
decompress
public ByteBuffer decompress(ByteBuffer in) throws IOException
{    int offset = computeOffset(in);    ByteBuffer out = ByteBuffer.allocate(Snappy.uncompressedLength(in.array(), offset, in.remaining() - 4));    int size = Snappy.uncompress(in.array(), offset, in.remaining() - 4, out.array(), 0);    out.limit(size);    crc32.reset();    crc32.update(out.array(), 0, size);    if (in.getInt(in.limit() - 4) != (int) crc32.getValue())        throw new IOException("Checksum failure");    return out;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return getName().hashCode();}
4afeb0868b55bdd8e18a00a3cb43d83e0714378d1c4bb36f0936daefc060e2e8
equals
public boolean equals(Object obj)
{    if (this == obj)        return true;    return obj != null && obj.getClass() == getClass();}
ebf6369c0a538e889b3acec39360edad82f3c2ebed8c3c27b004adbf0ab4b95a
sync
public void sync() throws IOException
{    getFD().sync();}
81a04e0fa34035715e5fcd328c7c64ca44bc44216a36ae2dfa47e39fb2251b93
createInstance
protected Codec createInstance()
{    return new XZCodec(compressionLevel);}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return DataFileConstants.XZ_CODEC;}
e0f931f2fa9291fa0526f21c81af2316aabf954f10f71f0ba4328bc069249bef
compress
public ByteBuffer compress(ByteBuffer data) throws IOException
{    ByteArrayOutputStream baos = getOutputBuffer(data.remaining());    try (OutputStream outputStream = new XZCompressorOutputStream(baos, compressionLevel)) {        outputStream.write(data.array(), computeOffset(data), data.remaining());    }    return ByteBuffer.wrap(baos.toByteArray());}
8199c42b1315c45dfead0e468f6a3e591ffb1b7edd9c2adbda199b6538eba83a
decompress
public ByteBuffer decompress(ByteBuffer data) throws IOException
{    ByteArrayOutputStream baos = getOutputBuffer(data.remaining());    InputStream bytesIn = new ByteArrayInputStream(data.array(), computeOffset(data), data.remaining());    try (InputStream ios = new XZCompressorInputStream(bytesIn)) {        IOUtils.copy(ios, baos);    }    return ByteBuffer.wrap(baos.toByteArray());}
401b1ec2640fcf0263c4f04854301af09f7e01a9e464c8d29e1cf62288406fc5
getOutputBuffer
private ByteArrayOutputStream getOutputBuffer(int suggestedLength)
{    if (null == outputBuffer) {        outputBuffer = new ByteArrayOutputStream(suggestedLength);    }    outputBuffer.reset();    return outputBuffer;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return compressionLevel;}
4afeb0868b55bdd8e18a00a3cb43d83e0714378d1c4bb36f0936daefc060e2e8
equals
public boolean equals(Object obj)
{    if (this == obj)        return true;    if (obj == null || obj.getClass() != getClass())        return false;    XZCodec other = (XZCodec) obj;    return (this.compressionLevel == other.compressionLevel);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return getName() + "-" + compressionLevel;}
81a04e0fa34035715e5fcd328c7c64ca44bc44216a36ae2dfa47e39fb2251b93
createInstance
protected Codec createInstance()
{    return new ZstandardCodec(compressionLevel, useChecksum);}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return DataFileConstants.ZSTANDARD_CODEC;}
e0f931f2fa9291fa0526f21c81af2316aabf954f10f71f0ba4328bc069249bef
compress
public ByteBuffer compress(ByteBuffer data) throws IOException
{    ByteArrayOutputStream baos = getOutputBuffer(data.remaining());    try (OutputStream outputStream = ZstandardLoader.output(baos, compressionLevel, useChecksum)) {        outputStream.write(data.array(), computeOffset(data), data.remaining());    }    return ByteBuffer.wrap(baos.toByteArray());}
2891f7d8f7e1726c3c7c8e9e1adbeb7b13f1bfc6a89c5663266d5c3e375edab9
decompress
public ByteBuffer decompress(ByteBuffer compressedData) throws IOException
{    ByteArrayOutputStream baos = getOutputBuffer(compressedData.remaining());    InputStream bytesIn = new ByteArrayInputStream(compressedData.array(), computeOffset(compressedData), compressedData.remaining());    try (InputStream ios = ZstandardLoader.input(bytesIn)) {        IOUtils.copy(ios, baos);    }    return ByteBuffer.wrap(baos.toByteArray());}
401b1ec2640fcf0263c4f04854301af09f7e01a9e464c8d29e1cf62288406fc5
getOutputBuffer
private ByteArrayOutputStream getOutputBuffer(int suggestedLength)
{    if (outputBuffer == null) {        outputBuffer = new ByteArrayOutputStream(suggestedLength);    }    outputBuffer.reset();    return outputBuffer;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return getName().hashCode();}
4afeb0868b55bdd8e18a00a3cb43d83e0714378d1c4bb36f0936daefc060e2e8
equals
public boolean equals(Object obj)
{    return (this == obj) || (obj != null && obj.getClass() == this.getClass());}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return getName() + "[" + compressionLevel + "]";}
908a70cfa16377dba69074a3b06d49a54956b39a0b75361277ea681866dbd20e
input
 static InputStream input(InputStream compressed) throws IOException
{    return new ZstdInputStream(compressed);}
6e2d84ff852ca0aeae849aeee2f6f23bc26455edcfdf7d356680fe0bcb760aab
output
 static OutputStream output(OutputStream compressed, int level, boolean checksum) throws IOException
{    int bounded = Math.max(Math.min(level, Zstd.maxCompressionLevel()), Zstd.minCompressionLevel());    return new ZstdOutputStream(compressed, bounded, false, checksum);}
e81ce61afa6023c409f59e893a8e2992ea2dc468dba82aa6b7b33dc22be7eaff
reset
 void reset()
{    clear();}
7379be61b06cc085441b9e9be2ff2b80b2b2e1029f3733d53afb95f371e7c4fd
prune
 void prune()
{}
5880e19e29079facf22f1442c95003ff006956a248853e8116bf6f95df9b426d
setStringType
public static void setStringType(Schema s, StringType stringType)
{        if (stringType == StringType.String)        s.addProp(GenericData.STRING_PROP, GenericData.STRING_TYPE_STRING);}
2c73d705c4d86072d780f685dc2bf3ebe820a508f3b3e42089a8b11c079d4e65
get
public static GenericData get()
{    return INSTANCE;}
7e2af6083bdace22985574985e5e274f9fe159af2ce7078444be9e066d947995
getClassLoader
public ClassLoader getClassLoader()
{    return classLoader;}
ad66e42b0f921c531cada9d2695af119c201cc4527f197289d2374128744ff7d
getConversions
public Collection<Conversion<?>> getConversions()
{    return conversions.values();}
88a178bcd49c28be906b3a754b195138bc9e24a1fdaf2cd992436a75ce2cfeaa
addLogicalTypeConversion
public void addLogicalTypeConversion(Conversion<?> conversion)
{    conversions.put(conversion.getLogicalTypeName(), conversion);    Class<?> type = conversion.getConvertedType();    if (conversionsByClass.containsKey(type)) {        conversionsByClass.get(type).put(conversion.getLogicalTypeName(), conversion);    } else {        Map<String, Conversion<?>> conversions = new LinkedHashMap<>();        conversions.put(conversion.getLogicalTypeName(), conversion);        conversionsByClass.put(type, conversions);    }}
ba218ca6b8caa844a55b903974031dd03a365dee88bae576beb6d37566c5eb07
getConversionByClass
public Conversion<T> getConversionByClass(Class<T> datumClass)
{    Map<String, Conversion<?>> conversions = conversionsByClass.get(datumClass);    if (conversions != null) {        return (Conversion<T>) conversions.values().iterator().next();    }    return null;}
3f7a6b7cf520e6dce43fea6af5e2439f0ad61dca22ac45347c960c37fa8fca96
getConversionByClass
public Conversion<T> getConversionByClass(Class<T> datumClass, LogicalType logicalType)
{    Map<String, Conversion<?>> conversions = conversionsByClass.get(datumClass);    if (conversions != null) {        return (Conversion<T>) conversions.get(logicalType.getName());    }    return null;}
a05babeff5db59f966a0f336d36cb6077d6ac8699e75e3b71ce14354ea05865a
getConversionFor
public Conversion<Object> getConversionFor(LogicalType logicalType)
{    if (logicalType == null) {        return null;    }    return (Conversion<Object>) conversions.get(logicalType.getName());}
b74ae948bba816a824396f5fcd959e744592a67ff01eb79c422acb487a04550a
getSchema
public Schema getSchema()
{    return schema;}
cbcbcdbcabfab5ca9ae3793d39ae77085058a494d667add62ade590ec734b5ca
put
public void put(String key, Object value)
{    Schema.Field field = schema.getField(key);    if (field == null)        throw new AvroRuntimeException("Not a valid schema field: " + key);    values[field.pos()] = value;}
24a0e8f4089701b155328460d08976411ba0d7f744b77ab2e712496ffa81b814
put
public void put(int i, Object v)
{    values[i] = v;}
07a31c79995bdd80ff83c00a9172d7c1908b853d51bd3733caa321df96b29f87
get
public Object get(String key)
{    Field field = schema.getField(key);    if (field == null)        return null;    return values[field.pos()];}
2ea0205e522ed62ca511b522fdeaf1cedf0c2afbc5adfc3869c76d9961e32934
get
public Object get(int i)
{    return values[i];}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (o == this)                return true;    if (!(o instanceof Record))                return false;    Record that = (Record) o;    if (!this.schema.equals(that.schema))                return false;    return GenericData.get().compare(this, that, schema, true) == 0;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return GenericData.get().hashCode(this, schema);}
a050ab4ed2408cd2b7934545bf564fce8959335a2c2812cb20276ec8cb04b297
compareTo
public int compareTo(Record that)
{    return GenericData.get().compare(this, that, schema);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return GenericData.get().toString(this);}
b74ae948bba816a824396f5fcd959e744592a67ff01eb79c422acb487a04550a
getSchema
public Schema getSchema()
{    return schema;}
72ef1e59027007ffe0950edfd2670ad03bb65cd6463d5d1d282dfeb1750435b0
size
public int size()
{    return size;}
21ac40bb9a99614b6ac18fa4043acb6173fccff96066fdfab963dba597923aa8
clear
public void clear()
{        Arrays.fill(elements, 0, size, null);    size = 0;}
97d2d353f08aa5a1da8b18b0800b6e778df65f48d34726e5f17800df7e0d88e2
reset
public void reset()
{    size = 0;}
440e9a2eacadd06346162f4d84461587bddaa2b36a10b56afc5ce262cfa853be
prune
public void prune()
{    if (size < elements.length) {        Arrays.fill(elements, size, elements.length, null);    }}
f953961d64692f9b59701c434fe1f9537bac98f3f86c59d94e709afc4047563e
iterator
public Iterator<T> iterator()
{    return new Iterator<T>() {        private int position = 0;        @Override        public boolean hasNext() {            return position < size;        }        @Override        public T next() {            return (T) elements[position++];        }        @Override        public void remove() {            throw new UnsupportedOperationException();        }    };}
d51e5f7450eca0a0f63da1a466189e262d053b84aa767ba3be5cea740af7251b
hasNext
public boolean hasNext()
{    return position < size;}
0065325c0b6db8e2da52a39fd2e7ee6b3c2e4399e222206472be21a840aad14f
next
public T next()
{    return (T) elements[position++];}
eb35e4acc0ab2c89fd30970f01fba35488b3a4581b2af1986091209043508a3e
remove
public void remove()
{    throw new UnsupportedOperationException();}
a723c1a3ddff76f90e3dc5191e63f878ab5bbe4638cad05c1bcb9fb4d50129eb
get
public T get(int i)
{    if (i >= size)        throw new IndexOutOfBoundsException("Index " + i + " out of bounds.");    return (T) elements[i];}
6fce4eb7b15848385f7de51f660fa7daa65c49f598f718e359ab50c19c046494
add
public void add(int location, T o)
{    if (location > size || location < 0) {        throw new IndexOutOfBoundsException("Index " + location + " out of bounds.");    }    if (size == elements.length) {                final int newSize = size + (size >> 1) + 1;        elements = Arrays.copyOf(elements, newSize);    }    System.arraycopy(elements, location, elements, location + 1, size - location);    elements[location] = o;    size++;}
349c322effa544163c156376257ff99c03b3c1c37b6c61f5122e1a78f7419647
set
public T set(int i, T o)
{    if (i >= size)        throw new IndexOutOfBoundsException("Index " + i + " out of bounds.");    T response = (T) elements[i];    elements[i] = o;    return response;}
3c26ef54c23bc322386990710a5b188a4a307ae1c50611b313c231bcdf8e7ccf
remove
public T remove(int i)
{    if (i >= size)        throw new IndexOutOfBoundsException("Index " + i + " out of bounds.");    T result = (T) elements[i];    --size;    System.arraycopy(elements, i + 1, elements, i, (size - i));    elements[size] = null;    return result;}
09cc981054659940115b1fc093b0d70c2ad02da14b8590647cab1baa1a679c76
peek
public T peek()
{    return (size < elements.length) ? (T) elements[size] : null;}
bc762351f637ca72964d168d81adc1d0566e719edabf528b62131e9eb088db6a
compareTo
public int compareTo(GenericArray<T> that)
{    return GenericData.get().compare(this, that, this.getSchema());}
e9cd56aec1b5462fc8dd3242dac0377e66cb728e3d4dd814234d4428968b6ab3
reverse
public void reverse()
{    int left = 0;    int right = elements.length - 1;    while (left < right) {        Object tmp = elements[left];        elements[left] = elements[right];        elements[right] = tmp;        left++;        right--;    }}
f9fb748b61b1a160f4d60825048381437b41303dbeeb1bc01df785bc43915ad6
setSchema
protected void setSchema(Schema schema)
{    this.schema = schema;    this.bytes = new byte[schema.getFixedSize()];}
b74ae948bba816a824396f5fcd959e744592a67ff01eb79c422acb487a04550a
getSchema
public Schema getSchema()
{    return schema;}
0ebdc42efb188446d741b97a6df5d96648a495197c65beeba1fbed594575116b
bytes
public void bytes(byte[] bytes)
{    this.bytes = bytes;}
a1528398c6f8bd447ff6dc9c5f661a8eb0772003264c65121cd798751908d562
bytes
public byte[] bytes()
{    return bytes;}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (o == this)        return true;    return o instanceof GenericFixed && Arrays.equals(bytes, ((GenericFixed) o).bytes());}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return Arrays.hashCode(bytes);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return Arrays.toString(bytes);}
6763473e8521dcaa015c2d53944f646f3609da4997384c87b33d24c48834674f
compareTo
public int compareTo(Fixed that)
{    return BinaryData.compareBytes(this.bytes, 0, this.bytes.length, that.bytes, 0, that.bytes.length);}
b74ae948bba816a824396f5fcd959e744592a67ff01eb79c422acb487a04550a
getSchema
public Schema getSchema()
{    return schema;}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (o == this)        return true;    return o instanceof GenericEnumSymbol && symbol.equals(o.toString());}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return symbol.hashCode();}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return symbol;}
f9aa5cf6311fb3c343c338c44fa42819ffa9787aa5d335983e48806391008a74
compareTo
public int compareTo(EnumSymbol that)
{    return GenericData.get().compare(this, that, schema);}
7303aaf9e45ab4c8c624b0e6a5d7b5941d362a96397a811d275ccc7e47c2ece3
createDatumReader
public DatumReader createDatumReader(Schema schema)
{    return new GenericDatumReader(schema, schema, this);}
d21900c7941122070f06c2bc5bc41ce259bc840f1c278c43da933de5ac71ea45
createDatumReader
public DatumReader createDatumReader(Schema writer, Schema reader)
{    return new GenericDatumReader(writer, reader, this);}
3d2aa170a9dc9e88ce5dff8d9760bdd18b4ddcbfb1066b36a9661ff0df2e90fb
createDatumWriter
public DatumWriter createDatumWriter(Schema schema)
{    return new GenericDatumWriter(schema, this);}
6663bde0da8c466d276c699166abe0bd66cb345ed1bb17897c01dfe260f57b9d
validate
public boolean validate(Schema schema, Object datum)
{    switch(schema.getType()) {        case RECORD:            if (!isRecord(datum))                return false;            for (Field f : schema.getFields()) {                if (!validate(f.schema(), getField(datum, f.name(), f.pos())))                    return false;            }            return true;        case ENUM:            if (!isEnum(datum))                return false;            return schema.getEnumSymbols().contains(datum.toString());        case ARRAY:            if (!(isArray(datum)))                return false;            for (Object element : getArrayAsCollection(datum)) if (!validate(schema.getElementType(), element))                return false;            return true;        case MAP:            if (!(isMap(datum)))                return false;            @SuppressWarnings(value = "unchecked")            Map<Object, Object> map = (Map<Object, Object>) datum;            for (Map.Entry<Object, Object> entry : map.entrySet()) if (!validate(schema.getValueType(), entry.getValue()))                return false;            return true;        case UNION:            try {                int i = resolveUnion(schema, datum);                return validate(schema.getTypes().get(i), datum);            } catch (UnresolvedUnionException e) {                return false;            }        case FIXED:            return datum instanceof GenericFixed && ((GenericFixed) datum).bytes().length == schema.getFixedSize();        case STRING:            return isString(datum);        case BYTES:            return isBytes(datum);        case INT:            return isInteger(datum);        case LONG:            return isLong(datum);        case FLOAT:            return isFloat(datum);        case DOUBLE:            return isDouble(datum);        case BOOLEAN:            return isBoolean(datum);        case NULL:            return datum == null;        default:            return false;    }}
78b1dc780263d765d10d9e15af87ffaddb08c1a79694d4b66c812794d811091b
toString
public String toString(Object datum)
{    StringBuilder buffer = new StringBuilder();    toString(datum, buffer, new IdentityHashMap<>(128));    return buffer.toString();}
c1c5db748b4d5c6fca79dda923750d82f5a6755f65a61f26e3f202a691d3a1f0
toString
protected void toString(Object datum, StringBuilder buffer, IdentityHashMap<Object, Object> seenObjects)
{    if (isRecord(datum)) {        if (seenObjects.containsKey(datum)) {            buffer.append(TOSTRING_CIRCULAR_REFERENCE_ERROR_TEXT);            return;        }        seenObjects.put(datum, datum);        buffer.append("{");        int count = 0;        Schema schema = getRecordSchema(datum);        for (Field f : schema.getFields()) {            toString(f.name(), buffer, seenObjects);            buffer.append(": ");            toString(getField(datum, f.name(), f.pos()), buffer, seenObjects);            if (++count < schema.getFields().size())                buffer.append(", ");        }        buffer.append("}");        seenObjects.remove(datum);    } else if (isArray(datum)) {        if (seenObjects.containsKey(datum)) {            buffer.append(TOSTRING_CIRCULAR_REFERENCE_ERROR_TEXT);            return;        }        seenObjects.put(datum, datum);        Collection<?> array = getArrayAsCollection(datum);        buffer.append("[");        long last = array.size() - 1;        int i = 0;        for (Object element : array) {            toString(element, buffer, seenObjects);            if (i++ < last)                buffer.append(", ");        }        buffer.append("]");        seenObjects.remove(datum);    } else if (isMap(datum)) {        if (seenObjects.containsKey(datum)) {            buffer.append(TOSTRING_CIRCULAR_REFERENCE_ERROR_TEXT);            return;        }        seenObjects.put(datum, datum);        buffer.append("{");        int count = 0;        @SuppressWarnings(value = "unchecked")        Map<Object, Object> map = (Map<Object, Object>) datum;        for (Map.Entry<Object, Object> entry : map.entrySet()) {            buffer.append("\"");            writeEscapedString(String.valueOf(entry.getKey()), buffer);            buffer.append("\": ");            toString(entry.getValue(), buffer, seenObjects);            if (++count < map.size())                buffer.append(", ");        }        buffer.append("}");        seenObjects.remove(datum);    } else if (isString(datum) || isEnum(datum)) {        buffer.append("\"");        writeEscapedString(datum.toString(), buffer);        buffer.append("\"");    } else if (isBytes(datum)) {        buffer.append("\"");        ByteBuffer bytes = ((ByteBuffer) datum).duplicate();        writeEscapedString(StandardCharsets.ISO_8859_1.decode(bytes), buffer);        buffer.append("\"");    } else if ((    (datum instanceof Float) && (((Float) datum).isInfinite() || ((Float) datum).isNaN())) || ((datum instanceof Double) && (((Double) datum).isInfinite() || ((Double) datum).isNaN()))) {        buffer.append("\"");        buffer.append(datum);        buffer.append("\"");    } else if (datum instanceof GenericData) {        if (seenObjects.containsKey(datum)) {            buffer.append(TOSTRING_CIRCULAR_REFERENCE_ERROR_TEXT);            return;        }        seenObjects.put(datum, datum);        toString(datum, buffer, seenObjects);        seenObjects.remove(datum);    } else {        buffer.append(datum);    }}
2eee622f309b7004e70c4858048a151b947083fc72ad1d18c0f51d3e04a5c97c
writeEscapedString
private void writeEscapedString(CharSequence string, StringBuilder builder)
{    for (int i = 0; i < string.length(); i++) {        char ch = string.charAt(i);        switch(ch) {            case '"':                builder.append("\\\"");                break;            case '\\':                builder.append("\\\\");                break;            case '\b':                builder.append("\\b");                break;            case '\f':                builder.append("\\f");                break;            case '\n':                builder.append("\\n");                break;            case '\r':                builder.append("\\r");                break;            case '\t':                builder.append("\\t");                break;            default:                                if ((ch >= '\u0000' && ch <= '\u001F') || (ch >= '\u007F' && ch <= '\u009F') || (ch >= '\u2000' && ch <= '\u20FF')) {                    String hex = Integer.toHexString(ch);                    builder.append("\\u");                    for (int j = 0; j < 4 - hex.length(); j++) builder.append('0');                    builder.append(hex.toUpperCase());                } else {                    builder.append(ch);                }        }    }}
40cbd9022e81331b671e356836623ac1c2a9771ef3510ad96970e02880f81478
induce
public Schema induce(Object datum)
{    if (isRecord(datum)) {        return getRecordSchema(datum);    } else if (isArray(datum)) {        Schema elementType = null;        for (Object element : getArrayAsCollection(datum)) {            if (elementType == null) {                elementType = induce(element);            } else if (!elementType.equals(induce(element))) {                throw new AvroTypeException("No mixed type arrays.");            }        }        if (elementType == null) {            throw new AvroTypeException("Empty array: " + datum);        }        return Schema.createArray(elementType);    } else if (isMap(datum)) {        @SuppressWarnings(value = "unchecked")        Map<Object, Object> map = (Map<Object, Object>) datum;        Schema value = null;        for (Map.Entry<Object, Object> entry : map.entrySet()) {            if (value == null) {                value = induce(entry.getValue());            } else if (!value.equals(induce(entry.getValue()))) {                throw new AvroTypeException("No mixed type map values.");            }        }        if (value == null) {            throw new AvroTypeException("Empty map: " + datum);        }        return Schema.createMap(value);    } else if (datum instanceof GenericFixed) {        return Schema.createFixed(null, null, null, ((GenericFixed) datum).bytes().length);    } else if (isString(datum))        return Schema.create(Type.STRING);    else if (isBytes(datum))        return Schema.create(Type.BYTES);    else if (isInteger(datum))        return Schema.create(Type.INT);    else if (isLong(datum))        return Schema.create(Type.LONG);    else if (isFloat(datum))        return Schema.create(Type.FLOAT);    else if (isDouble(datum))        return Schema.create(Type.DOUBLE);    else if (isBoolean(datum))        return Schema.create(Type.BOOLEAN);    else if (datum == null)        return Schema.create(Type.NULL);    else        throw new AvroTypeException("Can't create schema for: " + datum);}
2284c2976b7804b74035de264c3d7049a71a0a0ecfc3277071f28be4fc97b835
setField
public void setField(Object record, String name, int position, Object o)
{    ((IndexedRecord) record).put(position, o);}
a4c1c35b6cb0d86153e50d1f9f5efd8fd4328615aab976da47d2c0416fdb73fc
getField
public Object getField(Object record, String name, int position)
{    return ((IndexedRecord) record).get(position);}
0d444d11f35623a106b078917619d310055e3ac4ece48255899791ab6864a69a
getRecordState
protected Object getRecordState(Object record, Schema schema)
{    return null;}
5bc19a5fb998190de00154a99290f4a07b17c33d29f48c3ea4c73a825eaebe9f
setField
protected void setField(Object r, String n, int p, Object o, Object state)
{    setField(r, n, p, o);}
61e87990300aa265dffc2843e9002d5e5aea256de7f2e53dec5ca66ff32170a1
getField
protected Object getField(Object record, String name, int pos, Object state)
{    return getField(record, name, pos);}
2da82379ff1a29b8f47a75188912730ae8e4e91ef6926bba5891be85135953f5
resolveUnion
public int resolveUnion(Schema union, Object datum)
{        if (datum != null) {        Map<String, Conversion<?>> conversions = conversionsByClass.get(datum.getClass());        if (conversions != null) {            List<Schema> candidates = union.getTypes();            for (int i = 0; i < candidates.size(); i += 1) {                LogicalType candidateType = candidates.get(i).getLogicalType();                if (candidateType != null) {                    Conversion<?> conversion = conversions.get(candidateType.getName());                    if (conversion != null) {                        return i;                    }                }            }        }    }    Integer i = union.getIndexNamed(getSchemaName(datum));    if (i != null)        return i;    throw new UnresolvedUnionException(union, datum);}
cdd96ec067b8dcb31118b105538f4c0303b1e6ac47ba1af2c8403a287d499a28
getSchemaName
protected String getSchemaName(Object datum)
{    if (datum == null || datum == JsonProperties.NULL_VALUE)        return Type.NULL.getName();    if (isRecord(datum))        return getRecordSchema(datum).getFullName();    if (isEnum(datum))        return getEnumSchema(datum).getFullName();    if (isArray(datum))        return Type.ARRAY.getName();    if (isMap(datum))        return Type.MAP.getName();    if (isFixed(datum))        return getFixedSchema(datum).getFullName();    if (isString(datum))        return Type.STRING.getName();    if (isBytes(datum))        return Type.BYTES.getName();    if (isInteger(datum))        return Type.INT.getName();    if (isLong(datum))        return Type.LONG.getName();    if (isFloat(datum))        return Type.FLOAT.getName();    if (isDouble(datum))        return Type.DOUBLE.getName();    if (isBoolean(datum))        return Type.BOOLEAN.getName();    throw new AvroRuntimeException(String.format("Unknown datum type %s: %s", datum.getClass().getName(), datum));}
bbfa4f3c86f48e133a7fb4c4039515d7e7b3a5d57ca8e582f3dd6f7b1fecdd64
instanceOf
protected boolean instanceOf(Schema schema, Object datum)
{    switch(schema.getType()) {        case RECORD:            if (!isRecord(datum))                return false;            return (schema.getFullName() == null) ? getRecordSchema(datum).getFullName() == null : schema.getFullName().equals(getRecordSchema(datum).getFullName());        case ENUM:            if (!isEnum(datum))                return false;            return schema.getFullName().equals(getEnumSchema(datum).getFullName());        case ARRAY:            return isArray(datum);        case MAP:            return isMap(datum);        case FIXED:            if (!isFixed(datum))                return false;            return schema.getFullName().equals(getFixedSchema(datum).getFullName());        case STRING:            return isString(datum);        case BYTES:            return isBytes(datum);        case INT:            return isInteger(datum);        case LONG:            return isLong(datum);        case FLOAT:            return isFloat(datum);        case DOUBLE:            return isDouble(datum);        case BOOLEAN:            return isBoolean(datum);        case NULL:            return datum == null;        default:            throw new AvroRuntimeException("Unexpected type: " + schema);    }}
544f1c34befadc3c9aa6e8a9976e5699018508396f3bbc8d42eb8027b3d830fb
isArray
protected boolean isArray(Object datum)
{    return datum instanceof Collection;}
4c687c9af8c642732c0418216904a06af3e7a03ee487ecf33ddebaf73ad8d2ff
getArrayAsCollection
protected Collection getArrayAsCollection(Object datum)
{    return (Collection) datum;}
1b134742de945abb4e613bd1016bdba9127aba26e8e578964be50af2bb864d19
isRecord
protected boolean isRecord(Object datum)
{    return datum instanceof IndexedRecord;}
e0ccc1e06ae00a2a60c371353533514f62b4e4bb097a1e40a212a8240b20fe10
getRecordSchema
protected Schema getRecordSchema(Object record)
{    return ((GenericContainer) record).getSchema();}
2c6b4c3e5e1b5ae8caf706d48722ac1779ce6fdfd9deb370b38ef7d438742cb4
isEnum
protected boolean isEnum(Object datum)
{    return datum instanceof GenericEnumSymbol;}
593c3e122d6436a1bba9416772c499fb856a4d9f0c046cebb9120cfcccd1a8bc
getEnumSchema
protected Schema getEnumSchema(Object enu)
{    return ((GenericContainer) enu).getSchema();}
8f4ac4a01f0496b5f1af8e3b340d123bbec375958bb9eb555c593ef76d27ae93
isMap
protected boolean isMap(Object datum)
{    return datum instanceof Map;}
c5e67f78cf3c3cbd52c3669106c56f3a68dd37ecd2343e4b5025801ec99e52cd
isFixed
protected boolean isFixed(Object datum)
{    return datum instanceof GenericFixed;}
e2f9ea3beefc0453c5b7457806185e213ffe91f4ba1f8ea66208dcd38d9b3e0f
getFixedSchema
protected Schema getFixedSchema(Object fixed)
{    return ((GenericContainer) fixed).getSchema();}
8108cd71220b582f7f1cf61dc9db5dfa4f71f5bd4909e9da223176abde1ddb00
isString
protected boolean isString(Object datum)
{    return datum instanceof CharSequence;}
c19f2258b56e6bb84785b44422325e6dd35d0cd9e9b7c47a7b0e85b56e643c83
isBytes
protected boolean isBytes(Object datum)
{    return datum instanceof ByteBuffer;}
b6729d02e00b59dadfa432a34fd5a1596991a3e49f87ab5f65a705034fa8fc37
isInteger
protected boolean isInteger(Object datum)
{    return datum instanceof Integer;}
cb704b42de4940d73cf76ca2ef9638a6ffe6e4561a2ef5618324c8ef5776855b
isLong
protected boolean isLong(Object datum)
{    return datum instanceof Long;}
e420d13928db5a182cfc6d6baafe122aa14c721d7cb6276487f061bbc9aab29c
isFloat
protected boolean isFloat(Object datum)
{    return datum instanceof Float;}
ccea4b5c320bf1551a6f3afe7628ad8672298a77de64b780fd3802ff017368d0
isDouble
protected boolean isDouble(Object datum)
{    return datum instanceof Double;}
b0265e37714bb4f8f2dc37239490d2158974e46e3f7fe1193967a8e255a3ac74
isBoolean
protected boolean isBoolean(Object datum)
{    return datum instanceof Boolean;}
8224c8aa5afa75c3840e562cd3c6153737fa18cd8f83d7237d23719a9216691d
hashCode
public int hashCode(Object o, Schema s)
{    if (o == null)                return 0;    int hashCode = 1;    switch(s.getType()) {        case RECORD:            for (Field f : s.getFields()) {                if (f.order() == Field.Order.IGNORE)                    continue;                hashCode = hashCodeAdd(hashCode, getField(o, f.name(), f.pos()), f.schema());            }            return hashCode;        case ARRAY:            Collection<?> a = (Collection<?>) o;            Schema elementType = s.getElementType();            for (Object e : a) hashCode = hashCodeAdd(hashCode, e, elementType);            return hashCode;        case UNION:            return hashCode(o, s.getTypes().get(resolveUnion(s, o)));        case ENUM:            return s.getEnumOrdinal(o.toString());        case NULL:            return 0;        case STRING:            return (o instanceof Utf8 ? o : new Utf8(o.toString())).hashCode();        default:            return o.hashCode();    }}
f0779a6974db6f6b6dac136ebe2712f63a3e88bf37ed9d2c430fa9481c245ed1
hashCodeAdd
protected int hashCodeAdd(int hashCode, Object o, Schema s)
{    return 31 * hashCode + hashCode(o, s);}
31966f40a68c607333a6b97ce4edf27197f339b4a0c84b94bcbe41cf1256fe54
compare
public int compare(Object o1, Object o2, Schema s)
{    return compare(o1, o2, s, false);}
693fe1bba7c4377dda6767f2284e0c31876667e482d6316360ac97a9d2280afd
compare
protected int compare(Object o1, Object o2, Schema s, boolean equals)
{    if (o1 == o2)        return 0;    switch(s.getType()) {        case RECORD:            for (Field f : s.getFields()) {                if (f.order() == Field.Order.IGNORE)                                        continue;                int pos = f.pos();                String name = f.name();                int compare = compare(getField(o1, name, pos), getField(o2, name, pos), f.schema(), equals);                if (                compare != 0)                    return f.order() == Field.Order.DESCENDING ? -compare : compare;            }            return 0;        case ENUM:            return s.getEnumOrdinal(o1.toString()) - s.getEnumOrdinal(o2.toString());        case ARRAY:            Collection a1 = (Collection) o1;            Collection a2 = (Collection) o2;            Iterator e1 = a1.iterator();            Iterator e2 = a2.iterator();            Schema elementType = s.getElementType();            while (e1.hasNext() && e2.hasNext()) {                int compare = compare(e1.next(), e2.next(), elementType, equals);                if (compare != 0)                    return compare;            }            return e1.hasNext() ? 1 : (e2.hasNext() ? -1 : 0);        case MAP:            if (equals)                return o1.equals(o2) ? 0 : 1;            throw new AvroRuntimeException("Can't compare maps!");        case UNION:            int i1 = resolveUnion(s, o1);            int i2 = resolveUnion(s, o2);            return (i1 == i2) ? compare(o1, o2, s.getTypes().get(i1), equals) : Integer.compare(i1, i2);        case NULL:            return 0;        case STRING:            Utf8 u1 = o1 instanceof Utf8 ? (Utf8) o1 : new Utf8(o1.toString());            Utf8 u2 = o2 instanceof Utf8 ? (Utf8) o2 : new Utf8(o2.toString());            return u1.compareTo(u2);        default:            return ((Comparable) o1).compareTo(o2);    }}
8e661ea5482d8786e675370d4286c33f481d336186ecb16fddac5a31d4dfe17f
getDefaultValue
public Object getDefaultValue(Field field)
{    JsonNode json = Accessor.defaultValue(field);    if (json == null)        throw new AvroMissingFieldException("Field " + field + " not set and has no default value", field);    if (json.isNull() && (field.schema().getType() == Type.NULL || (field.schema().getType() == Type.UNION && field.schema().getTypes().get(0).getType() == Type.NULL))) {        return null;    }        Object defaultValue = defaultValueCache.get(field);        if (defaultValue == null)        try {            ByteArrayOutputStream baos = new ByteArrayOutputStream();            BinaryEncoder encoder = EncoderFactory.get().binaryEncoder(baos, null);            Accessor.encode(encoder, field.schema(), json);            encoder.flush();            BinaryDecoder decoder = DecoderFactory.get().binaryDecoder(baos.toByteArray(), null);            defaultValue = createDatumReader(field.schema()).read(null, decoder);                                                defaultValueCache.put(field, defaultValue);        } catch (IOException e) {            throw new AvroRuntimeException(e);        }    return defaultValue;}
11443a4e1ba0922504803658ad0df32f40ecf6f9a5877416f0ff9dc3d7a96517
deepCopy
public T deepCopy(Schema schema, T value)
{    if (value == null)        return null;    LogicalType logicalType = schema.getLogicalType();    if (    logicalType == null)        return (T) deepCopyRaw(schema, value);    Conversion conversion = getConversionByClass(value.getClass(), logicalType);    if (    conversion == null)        return (T) deepCopyRaw(schema, value);            Object raw = Conversions.convertToRawType(value, schema, logicalType, conversion);        Object copy = deepCopyRaw(schema, raw);    return (T) Conversions.convertToLogicalType(copy, schema, logicalType, conversion);}
1be6a6670b667f93ea0707524c1a47fb79b11ec6934109992d5fe4cbeaba2d72
deepCopyRaw
private Object deepCopyRaw(Schema schema, Object value)
{    if (value == null) {        return null;    }    switch(schema.getType()) {        case ARRAY:            List<Object> arrayValue = (List) value;            List<Object> arrayCopy = new GenericData.Array<>(arrayValue.size(), schema);            for (Object obj : arrayValue) {                arrayCopy.add(deepCopy(schema.getElementType(), obj));            }            return arrayCopy;        case BOOLEAN:                        return value;        case BYTES:            ByteBuffer byteBufferValue = (ByteBuffer) value;            int start = byteBufferValue.position();            int length = byteBufferValue.limit() - start;            byte[] bytesCopy = new byte[length];            byteBufferValue.get(bytesCopy, 0, length);            byteBufferValue.position(start);            return ByteBuffer.wrap(bytesCopy, 0, length);        case DOUBLE:                        return value;        case ENUM:            return createEnum(value.toString(), schema);        case FIXED:            return createFixed(null, ((GenericFixed) value).bytes(), schema);        case FLOAT:                        return value;        case INT:                        return value;        case LONG:                        return value;        case MAP:            Map<CharSequence, Object> mapValue = (Map) value;            Map<CharSequence, Object> mapCopy = new HashMap<>(mapValue.size());            for (Map.Entry<CharSequence, Object> entry : mapValue.entrySet()) {                mapCopy.put(deepCopy(STRINGS, entry.getKey()), deepCopy(schema.getValueType(), entry.getValue()));            }            return mapCopy;        case NULL:            return null;        case RECORD:            Object oldState = getRecordState(value, schema);            Object newRecord = newRecord(null, schema);            Object newState = getRecordState(newRecord, schema);            for (Field f : schema.getFields()) {                int pos = f.pos();                String name = f.name();                Object newValue = deepCopy(f.schema(), getField(value, name, pos, oldState));                setField(newRecord, name, pos, newValue, newState);            }            return newRecord;        case STRING:                        if (value instanceof String) {                return value;            } else             if (value instanceof Utf8) {                                return new Utf8((Utf8) value);            }            return new Utf8(value.toString());        case UNION:            return deepCopy(schema.getTypes().get(resolveUnion(schema, value)), value);        default:            throw new AvroRuntimeException("Deep copy failed for schema \"" + schema + "\" and value \"" + value + "\"");    }}
e9f985f61755456b769f1756d4f69f9d6ecd02540acbc734c3fdaf9ef00419d1
createFixed
public Object createFixed(Object old, Schema schema)
{    if ((old instanceof GenericFixed) && ((GenericFixed) old).bytes().length == schema.getFixedSize())        return old;    return new GenericData.Fixed(schema);}
b15c812f09eec776b998809c45741aa2b1bac49b272ccca6d9ab1a25016c3f17
createFixed
public Object createFixed(Object old, byte[] bytes, Schema schema)
{    GenericFixed fixed = (GenericFixed) createFixed(old, schema);    System.arraycopy(bytes, 0, fixed.bytes(), 0, schema.getFixedSize());    return fixed;}
4fc0c5d95b684c99b56ed1131802df61d448960ef74a43b82b2f15885486e240
createEnum
public Object createEnum(String symbol, Schema schema)
{    return new EnumSymbol(schema, symbol);}
29054906d4af7be8dc8790cace3ee77ee70e4d288fe6c3430ecd85a8301c0864
newRecord
public Object newRecord(Object old, Schema schema)
{    if (old instanceof IndexedRecord) {        IndexedRecord record = (IndexedRecord) old;        if (record.getSchema() == schema)            return record;    }    return new GenericData.Record(schema);}
e1a0b35e10428018416a3c0c82fb61dd2d40e29c2c446724d72fc2d30947c06a
getData
public GenericData getData()
{    return data;}
b74ae948bba816a824396f5fcd959e744592a67ff01eb79c422acb487a04550a
getSchema
public Schema getSchema()
{    return actual;}
7f7601d677a6c33cd1cae10583764e2560564183702e411d7a1e9d6cfed1fea5
setSchema
public void setSchema(Schema writer)
{    this.actual = writer;    if (expected == null) {        expected = actual;    }    creatorResolver = null;}
a72e4d0d071d550f4518fce9f99816727fcdfa1a0455518435b9b17f0c740b96
getExpected
public Schema getExpected()
{    return expected;}
56c8f22d49b58027f5baa04b319659d91a909af4b6343d110fa5635feaab72ef
setExpected
public void setExpected(Schema reader)
{    this.expected = reader;    creatorResolver = null;}
f8f927dc95b1d7920eb2064814de71ee1d916b70f767aeb524f9ad482f94ecab
getResolver
protected final ResolvingDecoder getResolver(Schema actual, Schema expected) throws IOException
{    Thread currThread = Thread.currentThread();    ResolvingDecoder resolver;    if (currThread == creator && creatorResolver != null) {        return creatorResolver;    }    Map<Schema, ResolvingDecoder> cache = RESOLVER_CACHE.get().get(actual);    if (cache == null) {        cache = new WeakIdentityHashMap<>();        RESOLVER_CACHE.get().put(actual, cache);    }    resolver = cache.get(expected);    if (resolver == null) {        resolver = DecoderFactory.get().resolvingDecoder(Schema.applyAliases(actual, expected), expected, null);        cache.put(expected, resolver);    }    if (currThread == creator) {        creatorResolver = resolver;    }    return resolver;}
deb02f608e41e6b0e17ab69366c2423bcd86b1102f04133e04e3c267365f7732
read
public D read(D reuse, Decoder in) throws IOException
{    ResolvingDecoder resolver = getResolver(actual, expected);    resolver.configure(in);    D result = (D) read(reuse, expected, resolver);    resolver.drain();    return result;}
e642e74255338e01ba949a5038201067e5f4d166be1232af23741a69b4bc2852
read
protected Object read(Object old, Schema expected, ResolvingDecoder in) throws IOException
{    Object datum = readWithoutConversion(old, expected, in);    LogicalType logicalType = expected.getLogicalType();    if (logicalType != null) {        Conversion<?> conversion = getData().getConversionFor(logicalType);        if (conversion != null) {            return convert(datum, expected, logicalType, conversion);        }    }    return datum;}
4039e20ef02ce90afb5efa3c4772aa89338cafa18b4d28f7683c5129d429241c
readWithConversion
protected Object readWithConversion(Object old, Schema expected, LogicalType logicalType, Conversion<?> conversion, ResolvingDecoder in) throws IOException
{    return convert(readWithoutConversion(old, expected, in), expected, logicalType, conversion);}
c85296b6efda6d4c4fb01ad0d671b8742715a8912969afeb08777056703d58da
readWithoutConversion
protected Object readWithoutConversion(Object old, Schema expected, ResolvingDecoder in) throws IOException
{    switch(expected.getType()) {        case RECORD:            return readRecord(old, expected, in);        case ENUM:            return readEnum(expected, in);        case ARRAY:            return readArray(old, expected, in);        case MAP:            return readMap(old, expected, in);        case UNION:            return read(old, expected.getTypes().get(in.readIndex()), in);        case FIXED:            return readFixed(old, expected, in);        case STRING:            return readString(old, expected, in);        case BYTES:            return readBytes(old, expected, in);        case INT:            return readInt(old, expected, in);        case LONG:            return in.readLong();        case FLOAT:            return in.readFloat();        case DOUBLE:            return in.readDouble();        case BOOLEAN:            return in.readBoolean();        case NULL:            in.readNull();            return null;        default:            throw new AvroRuntimeException("Unknown type: " + expected);    }}
90366f6c00ffe072dcd088dbb324d683fc8d0c016ce95f9d029a46de63edeaa1
convert
protected Object convert(Object datum, Schema schema, LogicalType type, Conversion<?> conversion)
{    return Conversions.convertToLogicalType(datum, schema, type, conversion);}
53d42b61ceafb918d7034fad0c71fbf84442dc73259eea122f38ea53fd89bc7e
readRecord
protected Object readRecord(Object old, Schema expected, ResolvingDecoder in) throws IOException
{    Object r = data.newRecord(old, expected);    Object state = data.getRecordState(r, expected);    for (Field f : in.readFieldOrder()) {        int pos = f.pos();        String name = f.name();        Object oldDatum = null;        if (old != null) {            oldDatum = data.getField(r, name, pos, state);        }        readField(r, f, oldDatum, in, state);    }    return r;}
d6178e9dc6b9c56d9561a67effb4947d3127d1933d0d087ede9eae21322839c5
readField
protected void readField(Object r, Field f, Object oldDatum, ResolvingDecoder in, Object state) throws IOException
{    data.setField(r, f.name(), f.pos(), read(oldDatum, f.schema(), in), state);}
8e5bf4921068b89412d1c2ed8fa0c3355ca3ad9f24395ed760618a1510dc9bb5
readEnum
protected Object readEnum(Schema expected, Decoder in) throws IOException
{    return createEnum(expected.getEnumSymbols().get(in.readEnum()), expected);}
ba3551741c67b001580a4f329a6837cd872aeca67c8d5f82b3324af5f30f4676
createEnum
protected Object createEnum(String symbol, Schema schema)
{    return data.createEnum(symbol, schema);}
77d5b290c28f53bb07613a8be6e8a305f81973a17dfcca38d0c15a55225f2eea
readArray
protected Object readArray(Object old, Schema expected, ResolvingDecoder in) throws IOException
{    Schema expectedType = expected.getElementType();    long l = in.readArrayStart();    long base = 0;    if (l > 0) {        LogicalType logicalType = expectedType.getLogicalType();        Conversion<?> conversion = getData().getConversionFor(logicalType);        Object array = newArray(old, (int) l, expected);        do {            if (logicalType != null && conversion != null) {                for (long i = 0; i < l; i++) {                    addToArray(array, base + i, readWithConversion(peekArray(array), expectedType, logicalType, conversion, in));                }            } else {                for (long i = 0; i < l; i++) {                    addToArray(array, base + i, readWithoutConversion(peekArray(array), expectedType, in));                }            }            base += l;        } while ((l = in.arrayNext()) > 0);        return pruneArray(array);    } else {        return pruneArray(newArray(old, 0, expected));    }}
f54d9b8c13cd44e7e2b92f3d72c374a40749bb716a6178c8372597f7f3453d2c
pruneArray
private Object pruneArray(Object object)
{    if (object instanceof GenericArray<?>) {        ((GenericArray<?>) object).prune();    }    return object;}
7d52c3389ede984a8d4ba356e6ebab0005dd1ebcc0d415117c10e7f7b41d2d0b
peekArray
protected Object peekArray(Object array)
{    return (array instanceof GenericArray) ? ((GenericArray) array).peek() : null;}
ca5ac785ef75d2f5aea164c36c1d8e10adced1b96dbf8b653b5f41aab3b0e9e7
addToArray
protected void addToArray(Object array, long pos, Object e)
{    ((Collection) array).add(e);}
3657670b8638ba3c5dfafcea3192da631085fc5e8ff0b9c7ecd387b1feb7e37c
readMap
protected Object readMap(Object old, Schema expected, ResolvingDecoder in) throws IOException
{    Schema eValue = expected.getValueType();    long l = in.readMapStart();    LogicalType logicalType = eValue.getLogicalType();    Conversion<?> conversion = getData().getConversionFor(logicalType);    Object map = newMap(old, (int) l);    if (l > 0) {        do {            if (logicalType != null && conversion != null) {                for (int i = 0; i < l; i++) {                    addToMap(map, readMapKey(null, expected, in), readWithConversion(null, eValue, logicalType, conversion, in));                }            } else {                for (int i = 0; i < l; i++) {                    addToMap(map, readMapKey(null, expected, in), readWithoutConversion(null, eValue, in));                }            }        } while ((l = in.mapNext()) > 0);    }    return map;}
88debfa0f6fdee2fbbddbe9693d54e9f74537f56e5ecf8089fb5dd78ec9a93d5
readMapKey
protected Object readMapKey(Object old, Schema expected, Decoder in) throws IOException
{    return readString(old, expected, in);}
85adfd985d5561103bed96ece6448ddf8c6469449fe82f33537b1820adcbd004
addToMap
protected void addToMap(Object map, Object key, Object value)
{    ((Map) map).put(key, value);}
2d0fc4b58685acec8bb84e600a7be9841c7efc7848b6ad6e43ff3ad614a03dca
readFixed
protected Object readFixed(Object old, Schema expected, Decoder in) throws IOException
{    GenericFixed fixed = (GenericFixed) data.createFixed(old, expected);    in.readFixed(fixed.bytes(), 0, expected.getFixedSize());    return fixed;}
38df1c449b59aa1a8d49b1fd5095c4fd43741b373ea66a6442088351c64988ca
createFixed
protected Object createFixed(Object old, Schema schema)
{    return data.createFixed(old, schema);}
8cf7861cd65665ce38d43222b44caa12d314c10010f610e86eb82604b089c02e
createFixed
protected Object createFixed(Object old, byte[] bytes, Schema schema)
{    return data.createFixed(old, bytes, schema);}
abf43121cb5f967e0b970754a13cc7e3e03f5d89b08a10328ef64182c12e941a
newRecord
protected Object newRecord(Object old, Schema schema)
{    return data.newRecord(old, schema);}
7b6478bb11455a8339c97fa72e2e0c6aceb763cfb0762f80b4dd1a5cab3a715e
newArray
protected Object newArray(Object old, int size, Schema schema)
{    if (old instanceof GenericArray) {        ((GenericArray) old).reset();        return old;    } else if (old instanceof Collection) {        ((Collection) old).clear();        return old;    } else        return new GenericData.Array(size, schema);}
70dd6e4bf3121530d8d37c00df3e5e8fc4006e85966736be2089de8c0f021e2c
newMap
protected Object newMap(Object old, int size)
{    if (old instanceof Map) {        ((Map) old).clear();        return old;    } else        return new HashMap<>(size);}
d4b93696567bc733b58683a297b4409de4ea9719174332bc67b1523be6c46fea
readString
protected Object readString(Object old, Schema expected, Decoder in) throws IOException
{    Class stringClass = getStringClass(expected);    if (stringClass == String.class)        return in.readString();    if (stringClass == CharSequence.class)        return readString(old, in);    return newInstanceFromString(stringClass, in.readString());}
a0834ef5ec2d0a6e35ec0732d5a78c26d4ce86621a3b476c86c490ba40430ae4
readString
protected Object readString(Object old, Decoder in) throws IOException
{    return in.readString(old instanceof Utf8 ? (Utf8) old : null);}
742901a750f7561684d1d9e33db837879409972712244704569037109c2ee0c7
createString
protected Object createString(String value)
{    return new Utf8(value);}
d4c41b1db4917b34a87e87357091b704b8e1924023626519d08e35518107417b
findStringClass
protected Class findStringClass(Schema schema)
{    String name = schema.getProp(GenericData.STRING_PROP);    if (name == null)        return CharSequence.class;    switch(GenericData.StringType.valueOf(name)) {        case String:            return String.class;        default:            return CharSequence.class;    }}
5b7a5bdc596785fbfd46c228235391f053a81532842d91f65d6f3433f33ec93e
getStringClass
private Class getStringClass(Schema s)
{    Class c = stringClassCache.get(s);    if (c == null) {        c = findStringClass(s);        stringClassCache.put(s, c);    }    return c;}
35c63eb694f2484271982d3f71d0ee64826478f26d885ea356b745a75c416410
newInstanceFromString
protected Object newInstanceFromString(Class c, String s)
{    try {        Constructor ctor = stringCtorCache.get(c);        if (ctor == null) {            ctor = c.getDeclaredConstructor(String.class);            ctor.setAccessible(true);            stringCtorCache.put(c, ctor);        }        return ctor.newInstance(s);    } catch (NoSuchMethodException | InvocationTargetException | IllegalAccessException | InstantiationException e) {        throw new AvroRuntimeException(e);    }}
38a21e7f48f857d2650804b073b1aa6b1ce4c7d983dfe247f847ad7faecf91e2
readBytes
protected Object readBytes(Object old, Schema s, Decoder in) throws IOException
{    return readBytes(old, in);}
c6f75186ab2e2828fa9b15d13656669627d1a96b79c7406b70c69db615e78a04
readBytes
protected Object readBytes(Object old, Decoder in) throws IOException
{    return in.readBytes(old instanceof ByteBuffer ? (ByteBuffer) old : null);}
0e1e9acd057d4701e6a3a7945c5ea190f1b0aa9ce7dbf7d60b87f35c34b3cde6
readInt
protected Object readInt(Object old, Schema expected, Decoder in) throws IOException
{    return in.readInt();}
7322b32c20945db981796d96c00eb9334cee716f0d9b3231182a650fd023f3b1
createBytes
protected Object createBytes(byte[] value)
{    return ByteBuffer.wrap(value);}
0e66713ff16fc3237a2a0ae3747fcc5a9942142f4f6f34179b145105942c62b4
skip
public static void skip(Schema schema, Decoder in) throws IOException
{    switch(schema.getType()) {        case RECORD:            for (Field field : schema.getFields()) skip(field.schema(), in);            break;        case ENUM:            in.readInt();            break;        case ARRAY:            Schema elementType = schema.getElementType();            for (long l = in.skipArray(); l > 0; l = in.skipArray()) {                for (long i = 0; i < l; i++) {                    skip(elementType, in);                }            }            break;        case MAP:            Schema value = schema.getValueType();            for (long l = in.skipMap(); l > 0; l = in.skipMap()) {                for (long i = 0; i < l; i++) {                    in.skipString();                    skip(value, in);                }            }            break;        case UNION:            skip(schema.getTypes().get(in.readIndex()), in);            break;        case FIXED:            in.skipFixed(schema.getFixedSize());            break;        case STRING:            in.skipString();            break;        case BYTES:            in.skipBytes();            break;        case INT:            in.readInt();            break;        case LONG:            in.readLong();            break;        case FLOAT:            in.readFloat();            break;        case DOUBLE:            in.readDouble();            break;        case BOOLEAN:            in.readBoolean();            break;        case NULL:            break;        default:            throw new RuntimeException("Unknown type: " + schema);    }}
e1a0b35e10428018416a3c0c82fb61dd2d40e29c2c446724d72fc2d30947c06a
getData
public GenericData getData()
{    return data;}
2f28a452193f50bd5b91371894eb0431a2ea606299f2914399c7a9df549a736f
setSchema
public void setSchema(Schema root)
{    this.root = root;}
58f042597882f70639ab5c14fb7c97c8ad5cef9bef734a4768ee16546ea3dc56
write
public void write(D datum, Encoder out) throws IOException
{    Objects.requireNonNull(out, "Encoder cannot be null");    write(root, datum, out);}
7005d3b39d1ee319568585f964aa76be79fe2ae97c0065ebb85fc9e91fea53ba
write
protected void write(Schema schema, Object datum, Encoder out) throws IOException
{    LogicalType logicalType = schema.getLogicalType();    if (datum != null && logicalType != null) {        Conversion<?> conversion = getData().getConversionByClass(datum.getClass(), logicalType);        writeWithoutConversion(schema, convert(schema, logicalType, conversion, datum), out);    } else {        writeWithoutConversion(schema, datum, out);    }}
c876298af20905d4b4b5e52c89c04888e1dac4fe162219bca8f2a2b87882fe6b
convert
protected Object convert(Schema schema, LogicalType logicalType, Conversion<T> conversion, Object datum)
{    try {        if (conversion == null) {            return datum;        } else {            return Conversions.convertToRawType(datum, schema, logicalType, conversion);        }    } catch (AvroRuntimeException e) {        Throwable cause = e.getCause();        if (cause != null && cause.getClass() == ClassCastException.class) {                        throw (ClassCastException) cause;        } else {            throw e;        }    }}
a1a2d1ba97b29270ffd20716dbee50b1b79f3538e35e81a3cf2724d7058c92f0
writeWithoutConversion
protected void writeWithoutConversion(Schema schema, Object datum, Encoder out) throws IOException
{    try {        switch(schema.getType()) {            case RECORD:                writeRecord(schema, datum, out);                break;            case ENUM:                writeEnum(schema, datum, out);                break;            case ARRAY:                writeArray(schema, datum, out);                break;            case MAP:                writeMap(schema, datum, out);                break;            case UNION:                int index = resolveUnion(schema, datum);                out.writeIndex(index);                write(schema.getTypes().get(index), datum, out);                break;            case FIXED:                writeFixed(schema, datum, out);                break;            case STRING:                writeString(schema, datum, out);                break;            case BYTES:                writeBytes(datum, out);                break;            case INT:                out.writeInt(((Number) datum).intValue());                break;            case LONG:                out.writeLong((Long) datum);                break;            case FLOAT:                out.writeFloat((Float) datum);                break;            case DOUBLE:                out.writeDouble((Double) datum);                break;            case BOOLEAN:                out.writeBoolean((Boolean) datum);                break;            case NULL:                out.writeNull();                break;            default:                error(schema, datum);        }    } catch (NullPointerException e) {        throw npe(e, " of " + schema.getFullName());    }}
a5ddd3f509b7bac131ce7068915e4804dfeca250a477b989dcd51ca3f14e6c17
npe
protected NullPointerException npe(NullPointerException e, String s)
{    NullPointerException result = new NullPointerException(e.getMessage() + s);    result.initCause(e.getCause() == null ? e : e.getCause());    return result;}
231c86f7e1f982553774a596296e6507032115afbd20b06cd154cd810f6a6172
writeRecord
protected void writeRecord(Schema schema, Object datum, Encoder out) throws IOException
{    Object state = data.getRecordState(datum, schema);    for (Field f : schema.getFields()) {        writeField(datum, f, out, state);    }}
a8f549116c2f7556ff4d7e08718b94c4bf7a985c87e0ff7e80eae503c4000901
writeField
protected void writeField(Object datum, Field f, Encoder out, Object state) throws IOException
{    Object value = data.getField(datum, f.name(), f.pos(), state);    try {        write(f.schema(), value, out);    } catch (NullPointerException e) {        throw npe(e, " in field " + f.name());    }}
4991313986c666ab7d89ef913042220d7e658389c5ff820c0c2890814b8ef1ce
writeEnum
protected void writeEnum(Schema schema, Object datum, Encoder out) throws IOException
{    if (!data.isEnum(datum))        throw new AvroTypeException("Not an enum: " + datum + " for schema: " + schema);    out.writeEnum(schema.getEnumOrdinal(datum.toString()));}
8e0159f1f906fcc7cd471bf035f56eaf9df0762a0f0186a99d7db9d3a9c72c23
writeArray
protected void writeArray(Schema schema, Object datum, Encoder out) throws IOException
{    Schema element = schema.getElementType();    long size = getArraySize(datum);    long actualSize = 0;    out.writeArrayStart();    out.setItemCount(size);    for (Iterator<? extends Object> it = getArrayElements(datum); it.hasNext(); ) {        out.startItem();        write(element, it.next(), out);        actualSize++;    }    out.writeArrayEnd();    if (actualSize != size) {        throw new ConcurrentModificationException("Size of array written was " + size + ", but number of elements written was " + actualSize + ". ");    }}
d791681bbbe092bba134cf9fe3036c8f128598c2e36b2b3b3c217a6e7d2a70e0
resolveUnion
protected int resolveUnion(Schema union, Object datum)
{    return data.resolveUnion(union, datum);}
8e576ef88bd3e1b8395d97ffc6d3dfb595dd488097d641467bc2e7b1114e2685
getArraySize
protected long getArraySize(Object array)
{    return ((Collection) array).size();}
167360fc67467b9e5d10fcf0b2c0c7b3fa0a533b4c969095fa60dadf3ee0ba38
getArrayElements
protected Iterator<? extends Object> getArrayElements(Object array)
{    return ((Collection) array).iterator();}
fec09a52c4960edd5eac30f7c84ac0112c80a1de7c6b8cc1bab378444f6bc571
writeMap
protected void writeMap(Schema schema, Object datum, Encoder out) throws IOException
{    Schema value = schema.getValueType();    int size = getMapSize(datum);    int actualSize = 0;    out.writeMapStart();    out.setItemCount(size);    for (Map.Entry<Object, Object> entry : getMapEntries(datum)) {        out.startItem();        writeString(entry.getKey().toString(), out);        write(value, entry.getValue(), out);        actualSize++;    }    out.writeMapEnd();    if (actualSize != size) {        throw new ConcurrentModificationException("Size of map written was " + size + ", but number of entries written was " + actualSize + ". ");    }}
66388a3aeeaf0e065d4e4c68f6d304e770d971bd531a0115597491b3988b27a3
getMapSize
protected int getMapSize(Object map)
{    return ((Map) map).size();}
e09bbe0c1545701ee402a159f03f93efdad5867144eddff24094ea18446ea831
getMapEntries
protected Iterable<Map.Entry<Object, Object>> getMapEntries(Object map)
{    return ((Map) map).entrySet();}
a4fb16253b93561ac2bbac8de69e799569e7c9f2ea9f1480af61479dbe9b5d55
writeString
protected void writeString(Schema schema, Object datum, Encoder out) throws IOException
{    writeString(datum, out);}
2b02feeb9b7bef8f66e1c053002b8e7eeafc44316035b2a78a1878630a002d92
writeString
protected void writeString(Object datum, Encoder out) throws IOException
{    out.writeString((CharSequence) datum);}
7e2854bd80d8b97a030073ac1adfa38a98546f188df05d53b4035e30b0129a18
writeBytes
protected void writeBytes(Object datum, Encoder out) throws IOException
{    out.writeBytes((ByteBuffer) datum);}
2cce8d2bfc9bb24763ce6b12b66e60da9690f2fdde0b9f59fe6d98afda36546e
writeFixed
protected void writeFixed(Schema schema, Object datum, Encoder out) throws IOException
{    out.writeFixed(((GenericFixed) datum).bytes(), 0, schema.getFixedSize());}
b7e7acbdf105054be21ba6a76f4e273cf55c838c4e378ef2bc962db135f48d7c
error
private void error(Schema schema, Object datum)
{    throw new AvroTypeException("Not a " + schema + ": " + datum);}
3f1c898ac3c2d7ef683a7f5663fea81e77983c3f25d8c83b0b35640de3f215b2
get
public Object get(String fieldName)
{    return get(schema().getField(fieldName));}
c52355ef3bc7a00551b6f85f5d0a9a17716fbbabd3d9ccbc44962bd38ada51bf
get
public Object get(Field field)
{    return get(field.pos());}
808775c4650a680b5261625e9d32d11f71426fa9925e8225bcea28aaa2116fe8
get
protected Object get(int pos)
{    return record.get(pos);}
0bcfff6444619afa0d042faf254f2211c9ad7669d1afb3766d482b035c7effb1
set
public GenericRecordBuilder set(String fieldName, Object value)
{    return set(schema().getField(fieldName), value);}
afe1ac35f6bd1a9fb476b389865a733cf5edbccc377a5c25a53c5083cf731d32
set
public GenericRecordBuilder set(Field field, Object value)
{    return set(field, field.pos(), value);}
a4f537edae3a461f9561f0637b612fcc4c263b1b641c3a03e8bbbf7d852f3258
set
protected GenericRecordBuilder set(int pos, Object value)
{    return set(fields()[pos], pos, value);}
ffcdd252433e62762fe9e8cc83039485a4669436463f768fec4ce1e88161ee67
set
private GenericRecordBuilder set(Field field, int pos, Object value)
{    validate(field, value);    record.put(pos, value);    fieldSetFlags()[pos] = true;    return this;}
497b408dd5c3f0b4001ceb194cf1659a0b50ee7a5db0359fc4091350931b0147
has
public boolean has(String fieldName)
{    return has(schema().getField(fieldName));}
3c713d8d5fd169452a635085275158ae3a23ca8de7c382c806b2e779e500dd72
has
public boolean has(Field field)
{    return has(field.pos());}
23303135430dd2903312e1b8e34fb31d83f18a56c1c424ee49fc2f69989bece9
has
protected boolean has(int pos)
{    return fieldSetFlags()[pos];}
eae3b0a3321fc20e661a1dda2d53540ccf9a602f5ab459e9554b66138abb2d9b
clear
public GenericRecordBuilder clear(String fieldName)
{    return clear(schema().getField(fieldName));}
9d6b37d61a5194923efcca007be88590d81e2fa750296549d363f16b4ad3f062
clear
public GenericRecordBuilder clear(Field field)
{    return clear(field.pos());}
309115e05176656d8260bdda4d243d15fbe0628fddd421f6ba4c82da41b1fc21
clear
protected GenericRecordBuilder clear(int pos)
{    record.put(pos, null);    fieldSetFlags()[pos] = false;    return this;}
7baac58c5093ede0a9ad8bbac718ca6978435af02210cab076d6027d29802a26
build
public Record build()
{    Record record;    try {        record = new GenericData.Record(schema());    } catch (Exception e) {        throw new AvroRuntimeException(e);    }    for (Field field : fields()) {        Object value;        try {            value = getWithDefault(field);        } catch (IOException e) {            throw new AvroRuntimeException(e);        }        if (value != null) {            record.put(field.pos(), value);        }    }    return record;}
c31866189a0de829c349b410e2d5891900433f9ed7f7b6ccecb02f057f256f95
getWithDefault
private Object getWithDefault(Field field) throws IOException
{    return fieldSetFlags()[field.pos()] ? record.get(field.pos()) : defaultValue(field);}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    final int prime = 31;    int result = super.hashCode();    result = prime * result + ((record == null) ? 0 : record.hashCode());    return result;}
4afeb0868b55bdd8e18a00a3cb43d83e0714378d1c4bb36f0936daefc060e2e8
equals
public boolean equals(Object obj)
{    if (this == obj)        return true;    if (!super.equals(obj))        return false;    if (getClass() != obj.getClass())        return false;    GenericRecordBuilder other = (GenericRecordBuilder) obj;    if (record == null) {        return other.record == null;    } else        return record.equals(other.record);}
b4f9890f1857d0846f550efaf9cd9b260accb6b449ae50bf8bf0f2049d0dc529
set
public void set(byte[] data1, int off1, int len1, byte[] data2, int off2, int len2)
{    d1.setBuf(data1, off1, len1);    d2.setBuf(data2, off2, len2);}
21ac40bb9a99614b6ac18fa4043acb6173fccff96066fdfab963dba597923aa8
clear
public void clear()
{    d1.clearBuf();    d2.clearBuf();}
e61dc109f7a557ae85fa8a12652d1eb0d075e21c6ad1d929e45adf314d8db493
compare
public static int compare(byte[] b1, int s1, byte[] b2, int s2, Schema schema)
{    return compare(b1, s1, b1.length - s1, b2, s2, b2.length - s2, schema);}
e924f065c39268919573138cb86c5fc5bc18b304bd3d42c3fede53e66990a801
compare
public static int compare(byte[] b1, int s1, int l1, byte[] b2, int s2, int l2, Schema schema)
{    Decoders decoders = DECODERS.get();    decoders.set(b1, s1, l1, b2, s2, l2);    try {        return compare(decoders, schema);    } catch (IOException e) {        throw new AvroRuntimeException(e);    } finally {        decoders.clear();    }}
99566febe80695fed160b4471f6bcd65899bffe385205eeee934631b45008d45
compare
private static int compare(Decoders d, Schema schema) throws IOException
{    Decoder d1 = d.d1;    Decoder d2 = d.d2;    switch(schema.getType()) {        case RECORD:            {                for (Field field : schema.getFields()) {                    if (field.order() == Field.Order.IGNORE) {                        GenericDatumReader.skip(field.schema(), d1);                        GenericDatumReader.skip(field.schema(), d2);                        continue;                    }                    int c = compare(d, field.schema());                    if (c != 0) {                        return (field.order() != Field.Order.DESCENDING) ? c : -c;                    }                }                return 0;            }        case ENUM:        case INT:            return Integer.compare(d1.readInt(), d2.readInt());        case LONG:            return Long.compare(d1.readLong(), d2.readLong());        case FLOAT:            return Float.compare(d1.readFloat(), d2.readFloat());        case DOUBLE:            return Double.compare(d1.readDouble(), d2.readDouble());        case BOOLEAN:            return Boolean.compare(d1.readBoolean(), d2.readBoolean());        case ARRAY:            {                                long i = 0;                                long r1 = 0, r2 = 0;                                long l1 = 0, l2 = 0;                while (true) {                    if (r1 == 0) {                                                r1 = d1.readLong();                        if (r1 < 0) {                            r1 = -r1;                            d1.readLong();                        }                        l1 += r1;                    }                    if (r2 == 0) {                        r2 = d2.readLong();                        if (r2 < 0) {                            r2 = -r2;                            d2.readLong();                        }                        l2 += r2;                    }                    if (                    r1 == 0 || r2 == 0)                        return Long.compare(l1, l2);                    long l = Math.min(l1, l2);                    while (i < l) {                                                int c = compare(d, schema.getElementType());                        if (c != 0)                            return c;                        i++;                        r1--;                        r2--;                    }                }            }        case MAP:            throw new AvroRuntimeException("Can't compare maps!");        case UNION:            {                int i1 = d1.readInt();                int i2 = d2.readInt();                int c = Integer.compare(i1, i2);                return c == 0 ? compare(d, schema.getTypes().get(i1)) : c;            }        case FIXED:            {                int size = schema.getFixedSize();                int c = compareBytes(d.d1.getBuf(), d.d1.getPos(), size, d.d2.getBuf(), d.d2.getPos(), size);                d.d1.skipFixed(size);                d.d2.skipFixed(size);                return c;            }        case STRING:        case BYTES:            {                int l1 = d1.readInt();                int l2 = d2.readInt();                int c = compareBytes(d.d1.getBuf(), d.d1.getPos(), l1, d.d2.getBuf(), d.d2.getPos(), l2);                d.d1.skipFixed(l1);                d.d2.skipFixed(l2);                return c;            }        case NULL:            return 0;        default:            throw new AvroRuntimeException("Unexpected schema to compare!");    }}
ca72c23e02ba6ff1d56dcab7c055e54c17d55a6c65fe29a2cd995608cbb1162f
compareBytes
public static int compareBytes(byte[] b1, int s1, int l1, byte[] b2, int s2, int l2)
{    int end1 = s1 + l1;    int end2 = s2 + l2;    for (int i = s1, j = s2; i < end1 && j < end2; i++, j++) {        int a = (b1[i] & 0xff);        int b = (b2[j] & 0xff);        if (a != b) {            return a - b;        }    }    return l1 - l2;}
573c5f282809da9e80aaf9008487a412e4aaacbe4f716f1c58880fb038f67526
set
public void set(byte[] bytes, int start, int len)
{    this.decoder.setBuf(bytes, start, len);}
9e2edaeb21303b5384640ea093d5ed29c1198740d4e3cc478b3869a191d1d4b8
hashCode
public static int hashCode(byte[] bytes, int start, int length, Schema schema)
{    HashData data = HASH_DATA.get();    data.set(bytes, start, length);    try {        return hashCode(data, schema);    } catch (IOException e) {        throw new AvroRuntimeException(e);    }}
f28f605b32fca0b7bc359589ed51565212a81f11e9519e31a641c509dfeeb64b
hashCode
private static int hashCode(HashData data, Schema schema) throws IOException
{    Decoder decoder = data.decoder;    switch(schema.getType()) {        case RECORD:            {                int hashCode = 1;                for (Field field : schema.getFields()) {                    if (field.order() == Field.Order.IGNORE) {                        GenericDatumReader.skip(field.schema(), decoder);                        continue;                    }                    hashCode = hashCode * 31 + hashCode(data, field.schema());                }                return hashCode;            }        case ENUM:        case INT:            return decoder.readInt();        case BOOLEAN:            return Boolean.hashCode(decoder.readBoolean());        case FLOAT:            return Float.hashCode(decoder.readFloat());        case LONG:            return Long.hashCode(decoder.readLong());        case DOUBLE:            return Double.hashCode(decoder.readDouble());        case ARRAY:            {                Schema elementType = schema.getElementType();                int hashCode = 1;                for (long l = decoder.readArrayStart(); l != 0; l = decoder.arrayNext()) {                    for (long i = 0; i < l; i++) {                        hashCode = hashCode * 31 + hashCode(data, elementType);                    }                }                return hashCode;            }        case MAP:            throw new AvroRuntimeException("Can't hashCode maps!");        case UNION:            return hashCode(data, schema.getTypes().get(decoder.readInt()));        case FIXED:            return hashBytes(1, data, schema.getFixedSize(), false);        case STRING:            return hashBytes(0, data, decoder.readInt(), false);        case BYTES:            return hashBytes(1, data, decoder.readInt(), true);        case NULL:            return 0;        default:            throw new AvroRuntimeException("Unexpected schema to hashCode!");    }}
9ebf397f5b05d4001a733a214f19df2d46e36eddc2f6425eec4f52092fb4ce08
hashBytes
private static int hashBytes(int init, HashData data, int len, boolean rev) throws IOException
{    int hashCode = init;    byte[] bytes = data.decoder.getBuf();    int start = data.decoder.getPos();    int end = start + len;    if (rev)        for (int i = end - 1; i >= start; i--) hashCode = hashCode * 31 + bytes[i];    else        for (int i = start; i < end; i++) hashCode = hashCode * 31 + bytes[i];    data.decoder.skipFixed(len);    return hashCode;}
34e4f726113d43b1180a394ba578387a49b343ba08a304b2a15a2da3fd63eb52
skipLong
public static int skipLong(byte[] bytes, int start)
{    int i = start;    for (int b = bytes[i++]; ((b & 0x80) != 0); b = bytes[i++]) {    }    return i;}
5d8f726f9294caafb3286b695550a5ecdcbf7b31b9518e3bcfe6742d40d765bb
encodeBoolean
public static int encodeBoolean(boolean b, byte[] buf, int pos)
{    buf[pos] = b ? (byte) 1 : (byte) 0;    return 1;}
e5d3f3cf65bcdcc137251b01613ec381e616890fed15e3781c3945ad7386fbe3
encodeInt
public static int encodeInt(int n, byte[] buf, int pos)
{        n = (n << 1) ^ (n >> 31);    int start = pos;    if ((n & ~0x7F) != 0) {        buf[pos++] = (byte) ((n | 0x80) & 0xFF);        n >>>= 7;        if (n > 0x7F) {            buf[pos++] = (byte) ((n | 0x80) & 0xFF);            n >>>= 7;            if (n > 0x7F) {                buf[pos++] = (byte) ((n | 0x80) & 0xFF);                n >>>= 7;                if (n > 0x7F) {                    buf[pos++] = (byte) ((n | 0x80) & 0xFF);                    n >>>= 7;                }            }        }    }    buf[pos++] = (byte) n;    return pos - start;}
085d8bb40199ea5d025b5a79ceab5944c1132b93b8b4c0a59b4355c750845409
encodeLong
public static int encodeLong(long n, byte[] buf, int pos)
{        n = (n << 1) ^ (n >> 63);    int start = pos;    if ((n & ~0x7FL) != 0) {        buf[pos++] = (byte) ((n | 0x80) & 0xFF);        n >>>= 7;        if (n > 0x7F) {            buf[pos++] = (byte) ((n | 0x80) & 0xFF);            n >>>= 7;            if (n > 0x7F) {                buf[pos++] = (byte) ((n | 0x80) & 0xFF);                n >>>= 7;                if (n > 0x7F) {                    buf[pos++] = (byte) ((n | 0x80) & 0xFF);                    n >>>= 7;                    if (n > 0x7F) {                        buf[pos++] = (byte) ((n | 0x80) & 0xFF);                        n >>>= 7;                        if (n > 0x7F) {                            buf[pos++] = (byte) ((n | 0x80) & 0xFF);                            n >>>= 7;                            if (n > 0x7F) {                                buf[pos++] = (byte) ((n | 0x80) & 0xFF);                                n >>>= 7;                                if (n > 0x7F) {                                    buf[pos++] = (byte) ((n | 0x80) & 0xFF);                                    n >>>= 7;                                    if (n > 0x7F) {                                        buf[pos++] = (byte) ((n | 0x80) & 0xFF);                                        n >>>= 7;                                    }                                }                            }                        }                    }                }            }        }    }    buf[pos++] = (byte) n;    return pos - start;}
cf36fcac6afb3487700e1fe7a797d8910748b6490c50493c4dec53d5120ac587
encodeFloat
public static int encodeFloat(float f, byte[] buf, int pos)
{    int len = 1;    int bits = Float.floatToRawIntBits(f);        buf[pos] = (byte) ((bits) & 0xFF);    buf[pos + len++] = (byte) ((bits >>> 8) & 0xFF);    buf[pos + len++] = (byte) ((bits >>> 16) & 0xFF);    buf[pos + len++] = (byte) ((bits >>> 24) & 0xFF);    return 4;}
8eb1cf8d1188b13fe37bf138f9b39f78c89b53fbc701f75851f056cca43b38ed
encodeDouble
public static int encodeDouble(double d, byte[] buf, int pos)
{    long bits = Double.doubleToRawLongBits(d);    int first = (int) (bits & 0xFFFFFFFF);    int second = (int) ((bits >>> 32) & 0xFFFFFFFF);            buf[pos] = (byte) ((first) & 0xFF);    buf[pos + 4] = (byte) ((second) & 0xFF);    buf[pos + 5] = (byte) ((second >>> 8) & 0xFF);    buf[pos + 1] = (byte) ((first >>> 8) & 0xFF);    buf[pos + 2] = (byte) ((first >>> 16) & 0xFF);    buf[pos + 6] = (byte) ((second >>> 16) & 0xFF);    buf[pos + 7] = (byte) ((second >>> 24) & 0xFF);    buf[pos + 3] = (byte) ((first >>> 24) & 0xFF);    return 8;}
2ea9e166129c94eb4065f2ec14cb5359bbfcdf5e77c3c865db2f96750ffc6a38
getBuf
 byte[] getBuf()
{    return buf;}
af08c2256eb47f39ec99a381f7a5b35b4bae00d668255e0b81345ee5caa1709f
getPos
 int getPos()
{    return pos;}
5501d46f3b9ad982e86cc755db1c0f40477859879ee550ed963940471898a67d
getLimit
 int getLimit()
{    return limit;}
1660128c84614e8f86f69d23b5531cba552942d04240ec7d3736b5accbe82656
setBuf
 void setBuf(byte[] buf, int pos, int len)
{    this.buf = buf;    this.pos = pos;    this.limit = pos + len;}
be5b13e1e89598d1119c7b095e28c562e558001b18ed76bec250abb09d9e1954
clearBuf
 void clearBuf()
{    this.buf = null;}
24654c32634bf2cc6f9589555491dca297369261a56c3c7b3b2ec00bde5d0655
configure
 BinaryDecoder configure(InputStream in, int bufferSize)
{    configureSource(bufferSize, new InputStreamByteSource(in));    return this;}
8b7b78cced720f07388704f25dcb35b556dcd30e5714db81e7b5d91a4f9c7c79
configure
 BinaryDecoder configure(byte[] data, int offset, int length)
{    configureSource(DecoderFactory.DEFAULT_BUFFER_SIZE, new ByteArrayByteSource(data, offset, length));    return this;}
7949d1859efa5c31cbb311ad599ca6cfcc96af38969980d0619e35b29cf1ac0c
configureSource
private void configureSource(int bufferSize, ByteSource source)
{    if (null != this.source) {        this.source.detach();    }    source.attach(bufferSize, this);    this.source = source;}
79ed759dc329689cccee5da68f5c322be3893b5ca69e4b1bbe6fbd1d2e16f7a7
readNull
public void readNull() throws IOException
{}
fbc49599759f8cdcf441295a1ef45ca6ee3d99e9d996d9533ab06d2378b36f10
readBoolean
public boolean readBoolean() throws IOException
{        if (limit == pos) {        limit = source.tryReadRaw(buf, 0, buf.length);        pos = 0;        if (limit == 0) {            throw new EOFException();        }    }    int n = buf[pos++] & 0xff;    return n == 1;}
f236e7fb1e87c9b6c5be0f35fb6c4eb85b118d1b426358e70800a74f43350299
readInt
public int readInt() throws IOException
{        ensureBounds(5);    int len = 1;    int b = buf[pos] & 0xff;    int n = b & 0x7f;    if (b > 0x7f) {        b = buf[pos + len++] & 0xff;        n ^= (b & 0x7f) << 7;        if (b > 0x7f) {            b = buf[pos + len++] & 0xff;            n ^= (b & 0x7f) << 14;            if (b > 0x7f) {                b = buf[pos + len++] & 0xff;                n ^= (b & 0x7f) << 21;                if (b > 0x7f) {                    b = buf[pos + len++] & 0xff;                    n ^= (b & 0x7f) << 28;                    if (b > 0x7f) {                        throw new InvalidNumberEncodingException("Invalid int encoding");                    }                }            }        }    }    pos += len;    if (pos > limit) {        throw new EOFException();    }        return (n >>> 1) ^ -(n & 1);}
b6042ee68b2b47bac163d020b1d36c009b0f5b2b9d1a110e94e722663331fdf1
readLong
public long readLong() throws IOException
{    ensureBounds(10);    int b = buf[pos++] & 0xff;    int n = b & 0x7f;    long l;    if (b > 0x7f) {        b = buf[pos++] & 0xff;        n ^= (b & 0x7f) << 7;        if (b > 0x7f) {            b = buf[pos++] & 0xff;            n ^= (b & 0x7f) << 14;            if (b > 0x7f) {                b = buf[pos++] & 0xff;                n ^= (b & 0x7f) << 21;                if (b > 0x7f) {                                                            l = innerLongDecode((long) n);                } else {                    l = n;                }            } else {                l = n;            }        } else {            l = n;        }    } else {        l = n;    }    if (pos > limit) {        throw new EOFException();    }        return (l >>> 1) ^ -(l & 1);}
015998b3253c88688ad5486d8019a59bfc22ec3e8a0066ca1ae7918ab650e948
innerLongDecode
private long innerLongDecode(long l) throws IOException
{    int len = 1;    int b = buf[pos] & 0xff;    l ^= (b & 0x7fL) << 28;    if (b > 0x7f) {        b = buf[pos + len++] & 0xff;        l ^= (b & 0x7fL) << 35;        if (b > 0x7f) {            b = buf[pos + len++] & 0xff;            l ^= (b & 0x7fL) << 42;            if (b > 0x7f) {                b = buf[pos + len++] & 0xff;                l ^= (b & 0x7fL) << 49;                if (b > 0x7f) {                    b = buf[pos + len++] & 0xff;                    l ^= (b & 0x7fL) << 56;                    if (b > 0x7f) {                        b = buf[pos + len++] & 0xff;                        l ^= (b & 0x7fL) << 63;                        if (b > 0x7f) {                            throw new InvalidNumberEncodingException("Invalid long encoding");                        }                    }                }            }        }    }    pos += len;    return l;}
3a29df2e279a1aa87799d508d3c09fea77ff7a4a1d2b413b32851226858ddce4
readFloat
public float readFloat() throws IOException
{    ensureBounds(4);    int len = 1;    int n = (buf[pos] & 0xff) | ((buf[pos + len++] & 0xff) << 8) | ((buf[pos + len++] & 0xff) << 16) | ((buf[pos + len++] & 0xff) << 24);    if ((pos + 4) > limit) {        throw new EOFException();    }    pos += 4;    return Float.intBitsToFloat(n);}
5c17280cb2bd5e36b11f2e528a4a0334e3401e73556b4cd475f437cbff7261e1
readDouble
public double readDouble() throws IOException
{    ensureBounds(8);    int len = 1;    int n1 = (buf[pos] & 0xff) | ((buf[pos + len++] & 0xff) << 8) | ((buf[pos + len++] & 0xff) << 16) | ((buf[pos + len++] & 0xff) << 24);    int n2 = (buf[pos + len++] & 0xff) | ((buf[pos + len++] & 0xff) << 8) | ((buf[pos + len++] & 0xff) << 16) | ((buf[pos + len++] & 0xff) << 24);    if ((pos + 8) > limit) {        throw new EOFException();    }    pos += 8;    return Double.longBitsToDouble((((long) n1) & 0xffffffffL) | (((long) n2) << 32));}
c053fcdbfc387a7ac67d44a07f524f8f2ea428c07c8e3590f0ed50bdc4aff483
readString
public Utf8 readString(Utf8 old) throws IOException
{    long length = readLong();    if (length > MAX_ARRAY_SIZE) {        throw new UnsupportedOperationException("Cannot read strings longer than " + MAX_ARRAY_SIZE + " bytes");    }    if (length < 0L) {        throw new AvroRuntimeException("Malformed data. Length is negative: " + length);    }    Utf8 result = (old != null ? old : new Utf8());    result.setByteLength((int) length);    if (0L != length) {        doReadBytes(result.getBytes(), 0, (int) length);    }    return result;}
ef9970bf7628dc4396fc3849d6482ac8a961658c0482c2176ac2ba144c6112c6
readString
public String readString() throws IOException
{    return readString(scratchUtf8).toString();}
382ea2955da9cd92c1638ec68af3df3645c63648bd3c7436582fc6d114d32dc3
skipString
public void skipString() throws IOException
{    doSkipBytes(readLong());}
3f9351d2d96b71b9ade6333ab2de3b2fedb54eccbebc9ac546b7000019518e0f
readBytes
public ByteBuffer readBytes(ByteBuffer old) throws IOException
{    int length = readInt();    ByteBuffer result;    if (old != null && length <= old.capacity()) {        result = old;        result.clear();    } else {        result = ByteBuffer.allocate(length);    }    doReadBytes(result.array(), result.position(), length);    result.limit(length);    return result;}
2b7cdc89689872436aab53b6467b336e2c628ced0f6e4bbfc31fb05f7b33fc9c
skipBytes
public void skipBytes() throws IOException
{    doSkipBytes(readLong());}
572441d1ff810ce0d44341eed07e1afc88c0ffc21219640a43beec4fa40e0b55
readFixed
public void readFixed(byte[] bytes, int start, int length) throws IOException
{    doReadBytes(bytes, start, length);}
fd8d4a96aa39b53251c8c74a21c8896db0ba3c1b277095d249e5eb06c38e7ca7
skipFixed
public void skipFixed(int length) throws IOException
{    doSkipBytes(length);}
9374ccd890881cceb7e56edb9a895bc9db6fbbbe8b0c849cf1090cbf7493f44c
readEnum
public int readEnum() throws IOException
{    return readInt();}
f3ffede918a1d8814dde31d6b5d7c1de0246947c8745eb30ad0ef5f2da622feb
doSkipBytes
protected void doSkipBytes(long length) throws IOException
{    int remaining = limit - pos;    if (length <= remaining) {        pos = (int) (pos + length);    } else {        limit = pos = 0;        length -= remaining;        source.skipSourceBytes(length);    }}
f4fe1b9dad64d1112b7cccf1eb13797acf30433e649867ee5f93427d6dbd2638
doReadBytes
protected void doReadBytes(byte[] bytes, int start, int length) throws IOException
{    if (length < 0)        throw new AvroRuntimeException("Malformed data. Length is negative: " + length);    int remaining = limit - pos;    if (length <= remaining) {        System.arraycopy(buf, pos, bytes, start, length);        pos += length;    } else {                System.arraycopy(buf, pos, bytes, start, remaining);        start += remaining;        length -= remaining;        pos = limit;                source.readRaw(bytes, start, length);    }}
da4ac803fb6561f88d50899de03327213aa8f309646b62ce118f76ff68a47562
doReadItemCount
protected long doReadItemCount() throws IOException
{    long result = readLong();    if (result < 0L) {                readLong();        result = -result;    }    return result;}
20987c9155ae8cff87a22f219d795735fe7e3646c1ed7a8548503bca5de5e749
doSkipItems
private long doSkipItems() throws IOException
{    long result = readLong();    while (result < 0L) {        final long bytecount = readLong();        doSkipBytes(bytecount);        result = readLong();    }    return result;}
e6add0bc5e95e909949d20835efe8b60b03e5bcbc465b6ed385868efaa03433d
readArrayStart
public long readArrayStart() throws IOException
{    return doReadItemCount();}
b875ce5110599d9cbc3dee00e4aa55cb0a57d1a9573cbb258a671ce79c649910
arrayNext
public long arrayNext() throws IOException
{    return doReadItemCount();}
50c9a94efe953551ebfe49b73eadd4db5a332ca0b3a3650f3336e996f5e88c7f
skipArray
public long skipArray() throws IOException
{    return doSkipItems();}
e6bc36a0bc14db0154507596b987d5b0b1c5ad572a5ef56fc85c9dc13e23f964
readMapStart
public long readMapStart() throws IOException
{    return doReadItemCount();}
cf2dd4f4b7450866b8f7c0b58e3817a1f8aad0f3978d831c76efd87c84fd4dcd
mapNext
public long mapNext() throws IOException
{    return doReadItemCount();}
d9353ecbd03723a8a9e9f6a886bfef387f4f65291d9de544d01d5d5502f78a27
skipMap
public long skipMap() throws IOException
{    return doSkipItems();}
ed45fee8aef2b75e580e16f8fd6df1adc125a82cfee5ebc3632541573629672c
readIndex
public int readIndex() throws IOException
{    return readInt();}
6639106b8c9d2beaca04e0a9a275b97a17b1986a73e862250612b9edb607455c
isEnd
public boolean isEnd() throws IOException
{    if (pos < limit) {        return false;    }    if (source.isEof()) {        return true;    }        final int read = source.tryReadRaw(buf, 0, buf.length);    pos = 0;    limit = read;    return (0 == read);}
b9d20c9986273440a1d38c0701b82eaf215e36cf9ab0e612b76bdb048f971cca
ensureBounds
private void ensureBounds(int num) throws IOException
{    int remaining = limit - pos;    if (remaining < num) {                source.compactAndFill(buf, pos, minPos, remaining);        if (pos >= limit)            throw new EOFException();    }}
80d0547143111d06f42bae9df5d36de38f354dcf84101ce0250c8941588f8afc
inputStream
public InputStream inputStream()
{    return source;}
d3873652c2d8c21baf9367be813e406360a277838360d411113305022c8d44fd
detach
 void detach()
{    this.buf = decoder.buf;    this.pos = decoder.pos;    this.limit = decoder.limit;    detached = true;}
af08c2256eb47f39ec99a381f7a5b35b4bae00d668255e0b81345ee5caa1709f
getPos
 int getPos()
{    if (detached)        return this.pos;    else        return decoder.pos;}
4cece8e3a18a166d7045e93a43b8838da1f08affc25b9d5a07e74e46e5940556
getLim
 int getLim()
{    if (detached)        return this.limit;    else        return decoder.limit;}
2ea9e166129c94eb4065f2ec14cb5359bbfcdf5e77c3c865db2f96750ffc6a38
getBuf
 byte[] getBuf()
{    if (detached)        return this.buf;    else        return decoder.buf;}
58b4c98be9e26b991e363fe0a6c3b06357dafe17c9b709fa0f01e71590755e9a
setPos
 void setPos(int pos)
{    if (detached)        this.pos = pos;    else        decoder.pos = pos;}
9c4f34da3bf6124da1b490319c8d7454275f7ae768c3448ac2cb4d930227981f
setLimit
 void setLimit(int limit)
{    if (detached)        this.limit = limit;    else        decoder.limit = limit;}
3febf4735f9d4b44f2d7bdbd2c89652967f9419959cc743305ca4aa6ba2ba37c
setBuf
 void setBuf(byte[] buf, int offset, int length)
{    if (detached) {        this.buf = buf;        this.limit = offset + length;        this.pos = offset;    } else {        decoder.buf = buf;        decoder.limit = offset + length;        decoder.pos = offset;        decoder.minPos = offset;    }}
c999c2ed09cab24807af3d7b6281c8c05d53994533e1a1012bfc999cb64a687b
attach
protected void attach(int bufferSize, BinaryDecoder decoder)
{    decoder.buf = new byte[bufferSize];    decoder.pos = 0;    decoder.minPos = 0;    decoder.limit = 0;    this.ba = new BufferAccessor(decoder);}
8fcb3012c5ebc4f03cac83ac1ef2ea3730952edf7abf71d5f3ea5dc88dca9c5c
detach
protected void detach()
{    ba.detach();}
f92b3149647ccc572b1c8f9405226add5927db05b10ebaa097935d405d0fc1e6
compactAndFill
protected void compactAndFill(byte[] buf, int pos, int minPos, int remaining) throws IOException
{    System.arraycopy(buf, pos, buf, minPos, remaining);    ba.setPos(minPos);    int newLimit = remaining + tryReadRaw(buf, minPos + remaining, buf.length - remaining);    ba.setLimit(newLimit);}
56e08d87e6bd0be2a60f9b2de3195d58bc9d56a2637f6fed6210d21e832632ea
read
public int read(byte[] b, int off, int len) throws IOException
{    int lim = ba.getLim();    int pos = ba.getPos();    byte[] buf = ba.getBuf();    int remaining = (lim - pos);    if (remaining >= len) {        System.arraycopy(buf, pos, b, off, len);        pos = pos + len;        ba.setPos(pos);        return len;    } else {                System.arraycopy(buf, pos, b, off, remaining);        pos = pos + remaining;        ba.setPos(pos);                int inputRead = remaining + tryReadRaw(b, off + remaining, len - remaining);        if (inputRead == 0) {            return -1;        } else {            return inputRead;        }    }}
ce76f6aac8f77c67074f3b19112ca15bf61b65a883c96fe1c58af7e5620e8d94
skip
public long skip(long n) throws IOException
{    int lim = ba.getLim();    int pos = ba.getPos();    int remaining = lim - pos;    if (remaining > n) {        pos = (int) (pos + n);        ba.setPos(pos);        return n;    } else {        pos = lim;        ba.setPos(pos);        long isSkipCount = trySkipBytes(n - remaining);        return isSkipCount + remaining;    }}
02422e619fc950e443408bbd36203c4155e09261ea21c537537f17f6e4a56d8f
available
public int available() throws IOException
{    return (ba.getLim() - ba.getPos());}
fcbb5f72c9e50d8fb693af4622d77142e488ed4a0f96b31e8e4158095adccbc5
skipSourceBytes
protected void skipSourceBytes(long length) throws IOException
{    boolean readZero = false;    while (length > 0) {        long n = in.skip(length);        if (n > 0) {            length -= n;            continue;        }                if (n == 0) {            if (readZero) {                isEof = true;                throw new EOFException();            }            readZero = true;            continue;        }                isEof = true;        throw new EOFException();    }}
4a0bb6675216e4809b075b95a2bb8cd9019ee70ee6165ad363af0079ac07c522
trySkipBytes
protected long trySkipBytes(long length) throws IOException
{    long leftToSkip = length;    try {        boolean readZero = false;        while (leftToSkip > 0) {            long n = in.skip(length);            if (n > 0) {                leftToSkip -= n;                continue;            }                        if (n == 0) {                if (readZero) {                    isEof = true;                    break;                }                readZero = true;                continue;            }                        isEof = true;            break;        }    } catch (EOFException eof) {        isEof = true;    }    return length - leftToSkip;}
e4d690f30038dec1753141e40ef03bd756dce37276496ec671ef3d95b254964c
readRaw
protected void readRaw(byte[] data, int off, int len) throws IOException
{    while (len > 0) {        int read = in.read(data, off, len);        if (read < 0) {            isEof = true;            throw new EOFException();        }        len -= read;        off += read;    }}
b1467863e58131b1c8e75d7a67c721d64cbecd8073f47ffebf3ad9b732febc4e
tryReadRaw
protected int tryReadRaw(byte[] data, int off, int len) throws IOException
{    int leftToCopy = len;    try {        while (leftToCopy > 0) {            int read = in.read(data, off, leftToCopy);            if (read < 0) {                isEof = true;                break;            }            leftToCopy -= read;            off += read;        }    } catch (EOFException eof) {        isEof = true;    }    return len - leftToCopy;}
00c6cb892813c6b89e072a7f09dccdece629f30849daab28245b06f3e679bf54
read
public int read() throws IOException
{    if (ba.getLim() - ba.getPos() == 0) {        return in.read();    } else {        int position = ba.getPos();        int result = ba.getBuf()[position] & 0xff;        ba.setPos(position + 1);        return result;    }}
e0b5511a41e7db61d99fc37b9f7209c0e2f6d9b51583649c6623c339b5563064
isEof
public boolean isEof()
{    return isEof;}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    in.close();}
c999c2ed09cab24807af3d7b6281c8c05d53994533e1a1012bfc999cb64a687b
attach
protected void attach(int bufferSize, BinaryDecoder decoder)
{        decoder.buf = this.data;    decoder.pos = this.position;    decoder.minPos = this.position;    decoder.limit = this.max;    this.ba = new BufferAccessor(decoder);}
fcbb5f72c9e50d8fb693af4622d77142e488ed4a0f96b31e8e4158095adccbc5
skipSourceBytes
protected void skipSourceBytes(long length) throws IOException
{    long skipped = trySkipBytes(length);    if (skipped < length) {        throw new EOFException();    }}
4a0bb6675216e4809b075b95a2bb8cd9019ee70ee6165ad363af0079ac07c522
trySkipBytes
protected long trySkipBytes(long length) throws IOException
{        max = ba.getLim();    position = ba.getPos();    long remaining = (long) max - position;    if (remaining >= length) {        position = (int) (position + length);        ba.setPos(position);        return length;    } else {        position += remaining;        ba.setPos(position);        return remaining;    }}
e4d690f30038dec1753141e40ef03bd756dce37276496ec671ef3d95b254964c
readRaw
protected void readRaw(byte[] data, int off, int len) throws IOException
{    int read = tryReadRaw(data, off, len);    if (read < len) {        throw new EOFException();    }}
b1467863e58131b1c8e75d7a67c721d64cbecd8073f47ffebf3ad9b732febc4e
tryReadRaw
protected int tryReadRaw(byte[] data, int off, int len) throws IOException
{        return 0;}
f92b3149647ccc572b1c8f9405226add5927db05b10ebaa097935d405d0fc1e6
compactAndFill
protected void compactAndFill(byte[] buf, int pos, int minPos, int remaining) throws IOException
{        if (!compacted) {                byte[] tinybuf = new byte[remaining + 16];        System.arraycopy(buf, pos, tinybuf, 0, remaining);        ba.setBuf(tinybuf, 0, remaining);        compacted = true;    }}
00c6cb892813c6b89e072a7f09dccdece629f30849daab28245b06f3e679bf54
read
public int read() throws IOException
{    max = ba.getLim();    position = ba.getPos();    if (position >= max) {        return -1;    } else {        int result = ba.getBuf()[position++] & 0xff;        ba.setPos(position);        return result;    }}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{        ba.setPos(ba.getLim());}
e0b5511a41e7db61d99fc37b9f7209c0e2f6d9b51583649c6623c339b5563064
isEof
public boolean isEof()
{    int remaining = ba.getLim() - ba.getPos();    return (remaining == 0);}
07c3270fe1b73532e66eb6f555ff312e3202b8435cf61382c5aa1c0dc4ce9a22
writeNull
public void writeNull() throws IOException
{}
34bdbb4029a48cb89270af40e256732c5b672fb11b54336d3f7efc90b7df5ab2
writeString
public void writeString(Utf8 utf8) throws IOException
{    this.writeBytes(utf8.getBytes(), 0, utf8.getByteLength());}
96bc6a095954cfd9254d26f959f52e92cd7b9fee81a771dc57d7d1d251dd6db8
writeString
public void writeString(String string) throws IOException
{    if (0 == string.length()) {        writeZero();        return;    }    byte[] bytes = string.getBytes(StandardCharsets.UTF_8);    writeInt(bytes.length);    writeFixed(bytes, 0, bytes.length);}
ef77a45285e12605fa0ac332653126204dbd8aeb25f392f6b9900d3df7110e24
writeBytes
public void writeBytes(ByteBuffer bytes) throws IOException
{    int len = bytes.limit() - bytes.position();    if (0 == len) {        writeZero();    } else {        writeInt(len);        writeFixed(bytes);    }}
5686b3aa744852e31cb4ae1e0044e20a94ff28b7620cb59b1eb1a47c8ef69565
writeBytes
public void writeBytes(byte[] bytes, int start, int len) throws IOException
{    if (0 == len) {        writeZero();        return;    }    this.writeInt(len);    this.writeFixed(bytes, start, len);}
9c2c1c74b0f6ed303f5a2809268552b5b4c2121bcc71b39f52e22e9cfb232cc6
writeEnum
public void writeEnum(int e) throws IOException
{    this.writeInt(e);}
397b6502072ea3a1ac72a07bee65a462902e7e78c46d167fac7946bd2eee93fb
writeArrayStart
public void writeArrayStart() throws IOException
{}
b85783ea95d3093dd3e304d9bd3da87a2a232aaf24ea3f4113e86bf54caa8ad5
setItemCount
public void setItemCount(long itemCount) throws IOException
{    if (itemCount > 0) {        this.writeLong(itemCount);    }}
bed0009bb8139bc1ffb6ee9ad42162880141e39749c278e1724abb291a79cd42
startItem
public void startItem() throws IOException
{}
ed98fbed6a1d613e764dba378ccb5b19a641d3ecbc93a5f3d50f0010442034de
writeArrayEnd
public void writeArrayEnd() throws IOException
{    writeZero();}
06a13fe57e24d2460afd3389759c84bd57ee09e14710364b77d081005edff6eb
writeMapStart
public void writeMapStart() throws IOException
{}
44f6ecf1e519c8992d2b321f4cf40cfe49a47d580d58e41fd28fe573a1ea47c4
writeMapEnd
public void writeMapEnd() throws IOException
{    writeZero();}
5e98b24f5d4da4c35f9e7f9247f0fdca1daf147afc1971fff5a25067084cf67d
writeIndex
public void writeIndex(int unionIndex) throws IOException
{    writeInt(unionIndex);}
b25e78d8574e9627bb198bc035ee079927b9b8d75caf0325feca891803c6e88f
check
public boolean check(BlockedValue prev, int pos)
{    assert state != State.ROOT || type == null;    assert (state == State.ROOT || type == Schema.Type.ARRAY || type == Schema.Type.MAP);    assert 0 <= items;        assert 0 != items || start == pos;        assert 1 < items || start == lastFullItem;        assert items <= 1 || start <= lastFullItem;    assert lastFullItem <= pos;    switch(state) {        case ROOT:            assert start == 0;            assert prev == null;            break;        case REGULAR:            assert start >= 0;            assert prev.lastFullItem <= start;            assert 1 <= prev.items;            break;        case OVERFLOW:            assert start == 0;            assert items == 1;            assert prev.state == State.ROOT || prev.state == State.OVERFLOW;            break;    }    return false;}
468dd70b749787c86dd8cfdd230dd9c6d89ef7043c629afce0df0ca205023a15
check
private boolean check()
{    assert buf != null;    assert 0 <= pos;    assert pos <= buf.length : pos + " " + buf.length;    assert blockStack != null;    BlockedValue prev = null;    for (int i = 0; i <= stackTop; i++) {        BlockedValue v = blockStack[i];        v.check(prev, pos);        prev = v;    }    return true;}
97be99acf8b5ab519c9e56b67d4c5e7e2524747e43f911b82959ee99cdb94825
expandStack
private void expandStack()
{    int oldLength = blockStack.length;    blockStack = Arrays.copyOf(blockStack, blockStack.length + STACK_STEP);    for (int i = oldLength; i < blockStack.length; i++) {        blockStack[i] = new BlockedValue();    }}
1e9cf3f82c92084ef18a665c8f8ed21f1004ac84f835b1564d0b8941a7ef14ee
configure
 BlockingBinaryEncoder configure(OutputStream out, int blockBufferSize, int binaryEncoderBufferSize)
{    super.configure(out, binaryEncoderBufferSize);    pos = 0;    stackTop = 0;    if (null == buf || buf.length != blockBufferSize) {        buf = new byte[blockBufferSize];    }    assert check();    return this;}
c3e67ec76f1b008887f1caba645a2614900cde6e477acca1bc3ecc36bf357fcf
flush
public void flush() throws IOException
{    BlockedValue bv = blockStack[stackTop];    if (bv.state == BlockedValue.State.ROOT) {        super.writeFixed(buf, 0, pos);        pos = 0;    } else {        while (bv.state != BlockedValue.State.OVERFLOW) {            compact();        }    }    super.flush();    assert check();}
9d2c4a8e17244c43f6c9a688d920b81cfa21c5d72f09e261b40e4539894a93a4
writeBoolean
public void writeBoolean(boolean b) throws IOException
{    ensureBounds(1);    pos += BinaryData.encodeBoolean(b, buf, pos);}
3d8eb176faa04ef3aa5f28bd1c308daf64cdee2071894b3447ade0d0891ac95b
writeInt
public void writeInt(int n) throws IOException
{    ensureBounds(5);    pos += BinaryData.encodeInt(n, buf, pos);}
9d5f02c473bb90aaa95e11d7e93625ba8050b2ae1b4b94e45331333ecc81fb92
writeLong
public void writeLong(long n) throws IOException
{    ensureBounds(10);    pos += BinaryData.encodeLong(n, buf, pos);}
485832ef5d131a3779da1c259796c40decbe270ca77fd7c3bd67453210649270
writeFloat
public void writeFloat(float f) throws IOException
{    ensureBounds(4);    pos += BinaryData.encodeFloat(f, buf, pos);}
b0e7b254d45c2210c8fda5ed2caaef6ca76fec51fb5d6a536add22a8a39ae5e9
writeDouble
public void writeDouble(double d) throws IOException
{    ensureBounds(8);    pos += BinaryData.encodeDouble(d, buf, pos);}
23ad82833b3f2bd0c47b14f7e1f984068754ba8fea96d9cf72a5dc7b0df27779
writeFixed
public void writeFixed(byte[] bytes, int start, int len) throws IOException
{    doWriteBytes(bytes, start, len);}
5e740d6f8c55b38881e1bb1bc30511d25ebe87b9d0b243439031c5d34cea4eef
writeFixed
public void writeFixed(ByteBuffer bytes) throws IOException
{    int pos = bytes.position();    int len = bytes.remaining();    if (bytes.hasArray()) {        doWriteBytes(bytes.array(), bytes.arrayOffset() + pos, len);    } else {        byte[] b = new byte[len];        bytes.duplicate().get(b, 0, len);        doWriteBytes(b, 0, len);    }}
5023a0d096f1ab95489d9dac609515d3f09547e8ac1f5d97777396559f2c0103
writeZero
protected void writeZero() throws IOException
{    ensureBounds(1);    buf[pos++] = (byte) 0;}
397b6502072ea3a1ac72a07bee65a462902e7e78c46d167fac7946bd2eee93fb
writeArrayStart
public void writeArrayStart() throws IOException
{    if (stackTop + 1 == blockStack.length) {        expandStack();    }    BlockedValue bv = blockStack[++stackTop];    bv.type = Schema.Type.ARRAY;    bv.state = BlockedValue.State.REGULAR;    bv.start = bv.lastFullItem = pos;    bv.items = 0;    assert check();}
b85783ea95d3093dd3e304d9bd3da87a2a232aaf24ea3f4113e86bf54caa8ad5
setItemCount
public void setItemCount(long itemCount) throws IOException
{    BlockedValue v = blockStack[stackTop];    assert v.type == Schema.Type.ARRAY || v.type == Schema.Type.MAP;    assert v.itemsLeftToWrite == 0;    v.itemsLeftToWrite = itemCount;    assert check();}
bed0009bb8139bc1ffb6ee9ad42162880141e39749c278e1724abb291a79cd42
startItem
public void startItem() throws IOException
{    if (blockStack[stackTop].state == BlockedValue.State.OVERFLOW) {        finishOverflow();    }    BlockedValue t = blockStack[stackTop];    t.items++;    t.lastFullItem = pos;    t.itemsLeftToWrite--;    assert check();}
ed98fbed6a1d613e764dba378ccb5b19a641d3ecbc93a5f3d50f0010442034de
writeArrayEnd
public void writeArrayEnd() throws IOException
{    BlockedValue top = blockStack[stackTop];    if (top.type != Schema.Type.ARRAY) {        throw new AvroTypeException("Called writeArrayEnd outside of an array.");    }    if (top.itemsLeftToWrite != 0) {        throw new AvroTypeException("Failed to write expected number of array elements.");    }    endBlockedValue();    assert check();}
06a13fe57e24d2460afd3389759c84bd57ee09e14710364b77d081005edff6eb
writeMapStart
public void writeMapStart() throws IOException
{    if (stackTop + 1 == blockStack.length) {        expandStack();    }    BlockedValue bv = blockStack[++stackTop];    bv.type = Schema.Type.MAP;    bv.state = BlockedValue.State.REGULAR;    bv.start = bv.lastFullItem = pos;    bv.items = 0;    assert check();}
44f6ecf1e519c8992d2b321f4cf40cfe49a47d580d58e41fd28fe573a1ea47c4
writeMapEnd
public void writeMapEnd() throws IOException
{    BlockedValue top = blockStack[stackTop];    if (top.type != Schema.Type.MAP) {        throw new AvroTypeException("Called writeMapEnd outside of a map.");    }    if (top.itemsLeftToWrite != 0) {        throw new AvroTypeException("Failed to read write expected number of array elements.");    }    endBlockedValue();    assert check();}
5e98b24f5d4da4c35f9e7f9247f0fdca1daf147afc1971fff5a25067084cf67d
writeIndex
public void writeIndex(int unionIndex) throws IOException
{    ensureBounds(5);    pos += BinaryData.encodeInt(unionIndex, buf, pos);}
290667f29222305cd4c14aa05dc573ac3b21f965174d024f9ae834291ba61b1a
bytesBuffered
public int bytesBuffered()
{    return pos + super.bytesBuffered();}
f6b0ba33231f4a0df050c871e2d27bb649a1035c9e5312e2bc5e021736e01ff1
endBlockedValue
private void endBlockedValue() throws IOException
{    for (; ; ) {        assert check();        BlockedValue t = blockStack[stackTop];        assert t.state != BlockedValue.State.ROOT;        if (t.state == BlockedValue.State.OVERFLOW) {            finishOverflow();        }        assert t.state == BlockedValue.State.REGULAR;        if (0 < t.items) {            int byteCount = pos - t.start;            if (t.start == 0 && blockStack[stackTop - 1].state != BlockedValue.State.REGULAR) {                                                super.writeInt(-t.items);                super.writeInt(byteCount);            } else {                int headerSize = 0;                headerSize += BinaryData.encodeInt(-t.items, headerBuffer, headerSize);                headerSize += BinaryData.encodeInt(byteCount, headerBuffer, headerSize);                if (buf.length >= pos + headerSize) {                    pos += headerSize;                    final int m = t.start;                    System.arraycopy(buf, m, buf, m + headerSize, byteCount);                    System.arraycopy(headerBuffer, 0, buf, m, headerSize);                } else {                    compact();                    continue;                }            }        }        stackTop--;        ensureBounds(1);                buf[pos++] = 0;        assert check();        if (blockStack[stackTop].state == BlockedValue.State.ROOT) {            flush();        }        return;    }}
c1899447cbcfe5544ace8017e67051c51fcd104874d8f3b28c34aec5669865bd
finishOverflow
private void finishOverflow() throws IOException
{    BlockedValue s = blockStack[stackTop];    if (s.state != BlockedValue.State.OVERFLOW) {        throw new IllegalStateException("Not an overflow block");    }    assert check();        super.writeFixed(buf, 0, pos);    pos = 0;        s.state = BlockedValue.State.REGULAR;    s.start = s.lastFullItem = 0;    s.items = 0;    assert check();}
973a12465bc10d36e20ba0f0f8c6f303dc0633c93581dd7999eaa4918ef4f716
ensureBounds
private void ensureBounds(int l) throws IOException
{    while (buf.length < (pos + l)) {        if (blockStack[stackTop].state == BlockedValue.State.REGULAR) {            compact();        } else {            super.writeFixed(buf, 0, pos);            pos = 0;        }    }}
b6d0219627d7f7881da3142fe04eb1f0026bfec0fc1e3fcc2fcd1fef934fbc61
doWriteBytes
private void doWriteBytes(byte[] bytes, int start, int len) throws IOException
{    if (len < buf.length) {        ensureBounds(len);        System.arraycopy(bytes, start, buf, pos, len);        pos += len;    } else {        ensureBounds(buf.length);        assert blockStack[stackTop].state == BlockedValue.State.ROOT || blockStack[stackTop].state == BlockedValue.State.OVERFLOW;        write(bytes, start, len);    }}
00aa483b7c94f185a79d7aadb7dd7d485446151975b7518c1c3cd56b774fba84
write
private void write(byte[] b, int off, int len) throws IOException
{    if (blockStack[stackTop].state == BlockedValue.State.ROOT) {        super.writeFixed(b, off, len);    } else {        assert check();        while (buf.length < (pos + len)) {            if (blockStack[stackTop].state == BlockedValue.State.REGULAR) {                compact();            } else {                super.writeFixed(buf, 0, pos);                pos = 0;                if (buf.length <= len) {                    super.writeFixed(b, off, len);                    len = 0;                }            }        }        System.arraycopy(b, off, buf, pos, len);        pos += len;    }    assert check();}
1d65d757a840515033bb13306d9a3d64642f6fc409cded9e17096b935f703c5b
compact
private void compact() throws IOException
{    assert check();        BlockedValue s = null;    int i;    for (i = 1; i <= stackTop; i++) {        s = blockStack[i];        if (s.state == BlockedValue.State.REGULAR)            break;    }    assert s != null;                                    super.writeFixed(buf, 0, s.start);        if (1 < s.items) {        super.writeInt(-(s.items - 1));        super.writeInt(s.lastFullItem - s.start);        super.writeFixed(buf, s.start, s.lastFullItem - s.start);        s.start = s.lastFullItem;        s.items = 1;    }        super.writeInt(1);            BlockedValue n = ((i + 1) <= stackTop ? blockStack[i + 1] : null);    int end = (n == null ? pos : n.start);    super.writeFixed(buf, s.lastFullItem, end - s.lastFullItem);        System.arraycopy(buf, end, buf, 0, pos - end);    for (int j = i + 1; j <= stackTop; j++) {        n = blockStack[j];        n.start -= end;        n.lastFullItem -= end;    }    pos -= end;    assert s.items == 1;    s.start = s.lastFullItem = 0;    s.state = BlockedValue.State.OVERFLOW;    assert check();}
880a1b8f3bdcd00a4e814711b79cfc4f79dd7600edcc2680c078ed7ef07af759
configure
 BufferedBinaryEncoder configure(OutputStream out, int bufferSize)
{    if (null == out)        throw new NullPointerException("OutputStream cannot be null!");    if (null != this.sink) {        if (pos > 0) {            try {                flushBuffer();            } catch (IOException e) {                throw new AvroRuntimeException("Failure flushing old output", e);            }        }    }    this.sink = new OutputStreamSink(out);    pos = 0;    if (null == buf || buf.length != bufferSize) {        buf = new byte[bufferSize];    }    bulkLimit = buf.length >>> 1;    if (bulkLimit > 512) {        bulkLimit = 512;    }    return this;}
c3e67ec76f1b008887f1caba645a2614900cde6e477acca1bc3ecc36bf357fcf
flush
public void flush() throws IOException
{    flushBuffer();    sink.innerFlush();}
07ef00ba94aad6f95fef7dca51813c3d32f67833456f0ffb75e266962b81b157
flushBuffer
private void flushBuffer() throws IOException
{    if (pos > 0) {        try {            sink.innerWrite(buf, 0, pos);        } finally {            pos = 0;        }    }}
b9d20c9986273440a1d38c0701b82eaf215e36cf9ab0e612b76bdb048f971cca
ensureBounds
private void ensureBounds(int num) throws IOException
{    int remaining = buf.length - pos;    if (remaining < num) {        flushBuffer();    }}
9d2c4a8e17244c43f6c9a688d920b81cfa21c5d72f09e261b40e4539894a93a4
writeBoolean
public void writeBoolean(boolean b) throws IOException
{        if (buf.length == pos) {        flushBuffer();    }    pos += BinaryData.encodeBoolean(b, buf, pos);}
3d8eb176faa04ef3aa5f28bd1c308daf64cdee2071894b3447ade0d0891ac95b
writeInt
public void writeInt(int n) throws IOException
{    ensureBounds(5);    pos += BinaryData.encodeInt(n, buf, pos);}
9d5f02c473bb90aaa95e11d7e93625ba8050b2ae1b4b94e45331333ecc81fb92
writeLong
public void writeLong(long n) throws IOException
{    ensureBounds(10);    pos += BinaryData.encodeLong(n, buf, pos);}
485832ef5d131a3779da1c259796c40decbe270ca77fd7c3bd67453210649270
writeFloat
public void writeFloat(float f) throws IOException
{    ensureBounds(4);    pos += BinaryData.encodeFloat(f, buf, pos);}
b0e7b254d45c2210c8fda5ed2caaef6ca76fec51fb5d6a536add22a8a39ae5e9
writeDouble
public void writeDouble(double d) throws IOException
{    ensureBounds(8);    pos += BinaryData.encodeDouble(d, buf, pos);}
23ad82833b3f2bd0c47b14f7e1f984068754ba8fea96d9cf72a5dc7b0df27779
writeFixed
public void writeFixed(byte[] bytes, int start, int len) throws IOException
{    if (len > bulkLimit) {                flushBuffer();        sink.innerWrite(bytes, start, len);        return;    }    ensureBounds(len);    System.arraycopy(bytes, start, buf, pos, len);    pos += len;}
5e740d6f8c55b38881e1bb1bc30511d25ebe87b9d0b243439031c5d34cea4eef
writeFixed
public void writeFixed(ByteBuffer bytes) throws IOException
{    ByteBuffer readOnlyBytes = bytes.asReadOnlyBuffer();    if (!bytes.hasArray() && bytes.remaining() > bulkLimit) {        flushBuffer();                sink.innerWrite(readOnlyBytes);    } else {        super.writeFixed(readOnlyBytes);    }}
5023a0d096f1ab95489d9dac609515d3f09547e8ac1f5d97777396559f2c0103
writeZero
protected void writeZero() throws IOException
{    writeByte(0);}
ae3e0632fa48b01160335673a75f65879381e2a1b4649be811af048464da7772
writeByte
private void writeByte(int b) throws IOException
{    if (pos == buf.length) {        flushBuffer();    }    buf[pos++] = (byte) (b & 0xFF);}
290667f29222305cd4c14aa05dc573ac3b21f965174d024f9ae834291ba61b1a
bytesBuffered
public int bytesBuffered()
{    return pos;}
e7547bb14923f000316d81c64fb50a16ede97ee7b65b0e7d5332a65d331574d9
innerWrite
protected void innerWrite(byte[] bytes, int off, int len) throws IOException
{    out.write(bytes, off, len);}
5efda43389e9e00484e20262ef6c9d08ed8f6613773b1604c1815d73a1f695e7
innerFlush
protected void innerFlush() throws IOException
{    out.flush();}
25adb5210e5a77c4c0beefd7940a349d54c512f71cb97bf1762a05c91188cbe4
innerWrite
protected void innerWrite(ByteBuffer buff) throws IOException
{    channel.write(buff);}
36a1e0627779b7533b86a40300bae869a56f676f130a454effc8c1b906c1f05f
readFixed
public void readFixed(byte[] bytes) throws IOException
{    readFixed(bytes, 0, bytes.length);}
5ddb5541023ee8662a24b3dbddc67def9bc2db4e13ec34e9aa66bc820faa4215
defaultFactory
public static DecoderFactory defaultFactory()
{    return get();}
f8d65939662d2dffd0cee70fde42e26e0e4c215c80170944d16633d7472aea7a
get
public static DecoderFactory get()
{    return DEFAULT_FACTORY;}
1c805e5ce4855849357f7beec0585e395cd2a4055f033bd2c6d68abaefe3604d
configureDecoderBufferSize
public DecoderFactory configureDecoderBufferSize(int size)
{    if (size < 32)        size = 32;    if (size > 16 * 1024 * 1024)        size = 16 * 1024 * 1024;    this.binaryDecoderBufferSize = size;    return this;}
827e4807cee5b56eedf2adfbc79f0dc1a8f263152406cd26308a626bb5a27a6b
getConfiguredBufferSize
public int getConfiguredBufferSize()
{    return this.binaryDecoderBufferSize;}
8858729041a367c162dfb88298a4740de6bef005ac3c387e163eb03fcf927688
createBinaryDecoder
public BinaryDecoder createBinaryDecoder(InputStream in, BinaryDecoder reuse)
{    return binaryDecoder(in, reuse);}
5b8c2c079130ddcdd5d3399d90ae11617622d2638b40f98ec31bf06603b5fa62
binaryDecoder
public BinaryDecoder binaryDecoder(InputStream in, BinaryDecoder reuse)
{    if (null == reuse || !reuse.getClass().equals(BinaryDecoder.class)) {        return new BinaryDecoder(in, binaryDecoderBufferSize);    } else {        return reuse.configure(in, binaryDecoderBufferSize);    }}
f66b4068aaf559e86c8c790168ccf7a75bd3e32bd775790cb7f2ae6529672f5d
directBinaryDecoder
public BinaryDecoder directBinaryDecoder(InputStream in, BinaryDecoder reuse)
{    if (null == reuse || !reuse.getClass().equals(DirectBinaryDecoder.class)) {        return new DirectBinaryDecoder(in);    } else {        return ((DirectBinaryDecoder) reuse).configure(in);    }}
cf36537cd38b50d4f4466cbf4c09577306285d89fee8182b6fcedf111c49b43c
createBinaryDecoder
public BinaryDecoder createBinaryDecoder(byte[] bytes, int offset, int length, BinaryDecoder reuse)
{    if (null == reuse || !reuse.getClass().equals(BinaryDecoder.class)) {        return new BinaryDecoder(bytes, offset, length);    } else {        return reuse.configure(bytes, offset, length);    }}
662c3b709aa63373ef8087f1d40d857d63f13469912ed2bad84ffee0a74942af
binaryDecoder
public BinaryDecoder binaryDecoder(byte[] bytes, int offset, int length, BinaryDecoder reuse)
{    if (null == reuse || !reuse.getClass().equals(BinaryDecoder.class)) {        return new BinaryDecoder(bytes, offset, length);    } else {        return reuse.configure(bytes, offset, length);    }}
e36bf6a5d5c423747ebbd8846b01b8066d10eb6372b72d6bbfc2e779ae541be3
createBinaryDecoder
public BinaryDecoder createBinaryDecoder(byte[] bytes, BinaryDecoder reuse)
{    return binaryDecoder(bytes, 0, bytes.length, reuse);}
3e7c46b3457103504d6a77899ef925fa5128084666b1cca160f2436b1c051670
binaryDecoder
public BinaryDecoder binaryDecoder(byte[] bytes, BinaryDecoder reuse)
{    return binaryDecoder(bytes, 0, bytes.length, reuse);}
7a214ca7c1c583ba9ab119cb6d64438d3b2325476360b1bc07e3a6a9abc6163f
jsonDecoder
public JsonDecoder jsonDecoder(Schema schema, InputStream input) throws IOException
{    return new JsonDecoder(schema, input);}
22e9fc70e042f6880d44cf96ae2b4c1c316973bce371dd2880d352b2aa2bf5d4
jsonDecoder
public JsonDecoder jsonDecoder(Schema schema, String input) throws IOException
{    return new JsonDecoder(schema, input);}
421ded6af2e81bc29f7684da91246155870d4d6caca75a45910f7700b3ff3da9
validatingDecoder
public ValidatingDecoder validatingDecoder(Schema schema, Decoder wrapped) throws IOException
{    return new ValidatingDecoder(schema, wrapped);}
f543948ab4ad0bced350e30976cc0c83b9b65616a35258401c0822b174758b8d
resolvingDecoder
public ResolvingDecoder resolvingDecoder(Schema writer, Schema reader, Decoder wrapped) throws IOException
{    return new ResolvingDecoder(writer, reader, wrapped);}
47c73717c615b077de34e0f8eeb5b1516898196ac0ec2373754fdbc3d8a3cbb2
configureDecoderBufferSize
public DecoderFactory configureDecoderBufferSize(int bufferSize)
{    throw new IllegalArgumentException("This Factory instance is Immutable");}
540abd273b7a1f35c1d68c8fa5b9f099f6ba68366550893940bd4ada9a6d8e9e
read
public ByteBuffer read(ByteBuffer old, int length) throws IOException
{    ByteBuffer result;    if (old != null && length <= old.capacity()) {        result = old;        result.clear();    } else {        result = ByteBuffer.allocate(length);    }    doReadBytes(result.array(), result.position(), length);    result.limit(length);    return result;}
540abd273b7a1f35c1d68c8fa5b9f099f6ba68366550893940bd4ada9a6d8e9e
read
public ByteBuffer read(ByteBuffer old, int length) throws IOException
{    if (old != null) {        return super.read(old, length);    } else {        return bbi.readBuffer(length);    }}
1eea1ba5860ed9dc2747d5ff4962c587da900bcbba06325e59e4c6303636fb73
configure
 DirectBinaryDecoder configure(InputStream in)
{    this.in = in;    byteReader = (in instanceof ByteBufferInputStream) ? new ReuseByteReader((ByteBufferInputStream) in) : new ByteReader();    return this;}
fbc49599759f8cdcf441295a1ef45ca6ee3d99e9d996d9533ab06d2378b36f10
readBoolean
public boolean readBoolean() throws IOException
{    int n = in.read();    if (n < 0) {        throw new EOFException();    }    return n == 1;}
f236e7fb1e87c9b6c5be0f35fb6c4eb85b118d1b426358e70800a74f43350299
readInt
public int readInt() throws IOException
{    int n = 0;    int b;    int shift = 0;    do {        b = in.read();        if (b >= 0) {            n |= (b & 0x7F) << shift;            if ((b & 0x80) == 0) {                                return (n >>> 1) ^ -(n & 1);            }        } else {            throw new EOFException();        }        shift += 7;    } while (shift < 32);    throw new InvalidNumberEncodingException("Invalid int encoding");}
b6042ee68b2b47bac163d020b1d36c009b0f5b2b9d1a110e94e722663331fdf1
readLong
public long readLong() throws IOException
{    long n = 0;    int b;    int shift = 0;    do {        b = in.read();        if (b >= 0) {            n |= (b & 0x7FL) << shift;            if ((b & 0x80) == 0) {                                return (n >>> 1) ^ -(n & 1);            }        } else {            throw new EOFException();        }        shift += 7;    } while (shift < 64);    throw new InvalidNumberEncodingException("Invalid long encoding");}
3a29df2e279a1aa87799d508d3c09fea77ff7a4a1d2b413b32851226858ddce4
readFloat
public float readFloat() throws IOException
{    doReadBytes(buf, 0, 4);    int n = (((int) buf[0]) & 0xff) | ((((int) buf[1]) & 0xff) << 8) | ((((int) buf[2]) & 0xff) << 16) | ((((int) buf[3]) & 0xff) << 24);    return Float.intBitsToFloat(n);}
5c17280cb2bd5e36b11f2e528a4a0334e3401e73556b4cd475f437cbff7261e1
readDouble
public double readDouble() throws IOException
{    doReadBytes(buf, 0, 8);    long n = (((long) buf[0]) & 0xff) | ((((long) buf[1]) & 0xff) << 8) | ((((long) buf[2]) & 0xff) << 16) | ((((long) buf[3]) & 0xff) << 24) | ((((long) buf[4]) & 0xff) << 32) | ((((long) buf[5]) & 0xff) << 40) | ((((long) buf[6]) & 0xff) << 48) | ((((long) buf[7]) & 0xff) << 56);    return Double.longBitsToDouble(n);}
3f9351d2d96b71b9ade6333ab2de3b2fedb54eccbebc9ac546b7000019518e0f
readBytes
public ByteBuffer readBytes(ByteBuffer old) throws IOException
{    int length = readInt();    return byteReader.read(old, length);}
f3ffede918a1d8814dde31d6b5d7c1de0246947c8745eb30ad0ef5f2da622feb
doSkipBytes
protected void doSkipBytes(long length) throws IOException
{    while (length > 0) {        long n = in.skip(length);        if (n <= 0) {            throw new EOFException();        }        length -= n;    }}
f4fe1b9dad64d1112b7cccf1eb13797acf30433e649867ee5f93427d6dbd2638
doReadBytes
protected void doReadBytes(byte[] bytes, int start, int length) throws IOException
{    for (; ; ) {        int n = in.read(bytes, start, length);        if (n == length || length == 0) {            return;        } else if (n < 0) {            throw new EOFException();        }        start += n;        length -= n;    }}
80d0547143111d06f42bae9df5d36de38f354dcf84101ce0250c8941588f8afc
inputStream
public InputStream inputStream()
{    return in;}
6639106b8c9d2beaca04e0a9a275b97a17b1986a73e862250612b9edb607455c
isEnd
public boolean isEnd() throws IOException
{    throw new UnsupportedOperationException();}
e9644608994709a94ef49400b8b0dab6de8c13fbd0672dd2646db654cb14806a
configure
 DirectBinaryEncoder configure(OutputStream out)
{    if (null == out)        throw new NullPointerException("OutputStream cannot be null!");    this.out = out;    return this;}
c3e67ec76f1b008887f1caba645a2614900cde6e477acca1bc3ecc36bf357fcf
flush
public void flush() throws IOException
{    out.flush();}
9d2c4a8e17244c43f6c9a688d920b81cfa21c5d72f09e261b40e4539894a93a4
writeBoolean
public void writeBoolean(boolean b) throws IOException
{    out.write(b ? 1 : 0);}
3d8eb176faa04ef3aa5f28bd1c308daf64cdee2071894b3447ade0d0891ac95b
writeInt
public void writeInt(int n) throws IOException
{    int val = (n << 1) ^ (n >> 31);    if ((val & ~0x7F) == 0) {        out.write(val);        return;    } else if ((val & ~0x3FFF) == 0) {        out.write(0x80 | val);        out.write(val >>> 7);        return;    }    int len = BinaryData.encodeInt(n, buf, 0);    out.write(buf, 0, len);}
9d5f02c473bb90aaa95e11d7e93625ba8050b2ae1b4b94e45331333ecc81fb92
writeLong
public void writeLong(long n) throws IOException
{        long val = (n << 1) ^ (n >> 63);    if ((val & ~0x7FFFFFFFL) == 0) {        int i = (int) val;        while ((i & ~0x7F) != 0) {            out.write((byte) ((0x80 | i) & 0xFF));            i >>>= 7;        }        out.write((byte) i);        return;    }    int len = BinaryData.encodeLong(n, buf, 0);    out.write(buf, 0, len);}
485832ef5d131a3779da1c259796c40decbe270ca77fd7c3bd67453210649270
writeFloat
public void writeFloat(float f) throws IOException
{    int len = BinaryData.encodeFloat(f, buf, 0);    out.write(buf, 0, len);}
b0e7b254d45c2210c8fda5ed2caaef6ca76fec51fb5d6a536add22a8a39ae5e9
writeDouble
public void writeDouble(double d) throws IOException
{    int len = BinaryData.encodeDouble(d, buf, 0);    out.write(buf, 0, len);}
23ad82833b3f2bd0c47b14f7e1f984068754ba8fea96d9cf72a5dc7b0df27779
writeFixed
public void writeFixed(byte[] bytes, int start, int len) throws IOException
{    out.write(bytes, start, len);}
5023a0d096f1ab95489d9dac609515d3f09547e8ac1f5d97777396559f2c0103
writeZero
protected void writeZero() throws IOException
{    out.write(0);}
290667f29222305cd4c14aa05dc573ac3b21f965174d024f9ae834291ba61b1a
bytesBuffered
public int bytesBuffered()
{    return 0;}
be522bdc069e00fedad1d530e53eaeeecbe14ec57a058d6c1eb3025c7dcdd5fa
writeString
public void writeString(String str) throws IOException
{    writeString(new Utf8(str));}
18d3303aacad3eafe0f36c97283482e7fff96820f5d43ca49e74c0c283209a58
writeString
public void writeString(CharSequence charSequence) throws IOException
{    if (charSequence instanceof Utf8)        writeString((Utf8) charSequence);    else        writeString(charSequence.toString());}
2b7bf25085609d6fe223d2f9fa98378cbaf87b2c2eb15127d148845ddf2eee4a
writeBytes
public void writeBytes(byte[] bytes) throws IOException
{    writeBytes(bytes, 0, bytes.length);}
e7bb8fe82bf5478da7266b62f684568c5ff6658f1ef4ba1dc2197a133112b1a1
writeFixed
public void writeFixed(byte[] bytes) throws IOException
{    writeFixed(bytes, 0, bytes.length);}
5e740d6f8c55b38881e1bb1bc30511d25ebe87b9d0b243439031c5d34cea4eef
writeFixed
public void writeFixed(ByteBuffer bytes) throws IOException
{    int pos = bytes.position();    int len = bytes.limit() - pos;    if (bytes.hasArray()) {        writeFixed(bytes.array(), bytes.arrayOffset() + pos, len);    } else {        byte[] b = new byte[len];        bytes.duplicate().get(b, 0, len);        writeFixed(b, 0, len);    }}
02b325f9beee4371d3c9569e3d2221d584e5d1bed0b5b3388a6d541abbaf3870
get
public static EncoderFactory get()
{    return DEFAULT_FACTORY;}
f53f2466ccc18fc0546e839d53aa2fee02df318a0f7f4b97edf4b9829a6c4968
configureBufferSize
public EncoderFactory configureBufferSize(int size)
{    if (size < 32)        size = 32;    if (size > 16 * 1024 * 1024)        size = 16 * 1024 * 1024;    this.binaryBufferSize = size;    return this;}
2e6eda184436ee2e284ddcc9dbbe010f011ca3b9df271a0f8ee3fd2f7bf19efb
getBufferSize
public int getBufferSize()
{    return this.binaryBufferSize;}
8a2eff6b7091f99a46aa0ac5187dfdef3e3688000ed83c2d1ccb9aebe63f844b
configureBlockSize
public EncoderFactory configureBlockSize(int size)
{    if (size < MIN_BLOCK_BUFFER_SIZE)        size = MIN_BLOCK_BUFFER_SIZE;    if (size > MAX_BLOCK_BUFFER_SIZE)        size = MAX_BLOCK_BUFFER_SIZE;    this.binaryBlockSize = size;    return this;}
3476c2e9b8d443ecde4493ebe30034f70a1af257fc1f7b2692b835dc2e7a38d5
getBlockSize
public int getBlockSize()
{    return this.binaryBlockSize;}
55934276961b876ceef90112258d63abfaab7cc8b95986634e3f2d55ecdac1b1
binaryEncoder
public BinaryEncoder binaryEncoder(OutputStream out, BinaryEncoder reuse)
{    if (null == reuse || !reuse.getClass().equals(BufferedBinaryEncoder.class)) {        return new BufferedBinaryEncoder(out, this.binaryBufferSize);    } else {        return ((BufferedBinaryEncoder) reuse).configure(out, this.binaryBufferSize);    }}
b138d918738f74bb9ef9455331b4ca60f3894f9d88aef7ed8e7bc5fa17e7cb6b
directBinaryEncoder
public BinaryEncoder directBinaryEncoder(OutputStream out, BinaryEncoder reuse)
{    if (null == reuse || !reuse.getClass().equals(DirectBinaryEncoder.class)) {        return new DirectBinaryEncoder(out);    } else {        return ((DirectBinaryEncoder) reuse).configure(out);    }}
5f9940cd19241b1d387134f4ba43b7b22ed386eff617700486d2481a18083ef8
blockingBinaryEncoder
public BinaryEncoder blockingBinaryEncoder(OutputStream out, BinaryEncoder reuse)
{    int blockSize = this.binaryBlockSize;    int bufferSize = (blockSize * 2 >= this.binaryBufferSize) ? 32 : this.binaryBufferSize;    if (null == reuse || !reuse.getClass().equals(BlockingBinaryEncoder.class)) {        return new BlockingBinaryEncoder(out, blockSize, bufferSize);    } else {        return ((BlockingBinaryEncoder) reuse).configure(out, blockSize, bufferSize);    }}
5f3019d2231e4904495d3d35ad275b08451c50f2d502413992f6aac35f2afef7
jsonEncoder
public JsonEncoder jsonEncoder(Schema schema, OutputStream out) throws IOException
{    return new JsonEncoder(schema, out);}
654efdd804421350484bcb25d5ac4f514faff74900553f5ea5be22d8155d2bc3
jsonEncoder
public JsonEncoder jsonEncoder(Schema schema, OutputStream out, boolean pretty) throws IOException
{    return new JsonEncoder(schema, out, pretty);}
fa5c39ea76b05e235c8448298e72a10178b68b81f5dfad8a2d07545335d340cc
jsonEncoder
 JsonEncoder jsonEncoder(Schema schema, JsonGenerator gen) throws IOException
{    return new JsonEncoder(schema, gen);}
496d1f2a2cede475447617a3d7545e8841e3fe71159d34a9bc8a08a804d8d137
validatingEncoder
public ValidatingEncoder validatingEncoder(Schema schema, Encoder encoder) throws IOException
{    return new ValidatingEncoder(schema, encoder);}
8a2eff6b7091f99a46aa0ac5187dfdef3e3688000ed83c2d1ccb9aebe63f844b
configureBlockSize
public EncoderFactory configureBlockSize(int size)
{    throw new AvroRuntimeException("Default EncoderFactory cannot be configured");}
f53f2466ccc18fc0546e839d53aa2fee02df318a0f7f4b97edf4b9829a6c4968
configureBufferSize
public EncoderFactory configureBufferSize(int size)
{    throw new AvroRuntimeException("Default EncoderFactory cannot be configured");}
2487c7a0f2e07cbf9b8b1ead62cd7b79450a4b6f5ace1ece6f1b4b7fe64212b3
getSymbol
private static Symbol getSymbol(Schema schema)
{    if (null == schema) {        throw new NullPointerException("Schema cannot be null!");    }    return new JsonGrammarGenerator().generate(schema);}
a22d8bd18c9c4420385fb4010221349fdde064d1b00bfe266063dbe139e25484
configure
public JsonDecoder configure(InputStream in) throws IOException
{    if (null == in) {        throw new NullPointerException("InputStream to read from cannot be null!");    }    parser.reset();    reorderBuffers.clear();    currentReorderBuffer = null;    this.in = jsonFactory.createParser(in);    this.in.nextToken();    return this;}
67ce69556a586a020bf4fcd5dc87af60e617984baf6681521a4cd6ddf5e258c6
configure
public JsonDecoder configure(String in) throws IOException
{    if (null == in) {        throw new NullPointerException("String to read from cannot be null!");    }    parser.reset();    reorderBuffers.clear();    currentReorderBuffer = null;    this.in = new JsonFactory().createParser(in);    this.in.nextToken();    return this;}
535a61a4200164d2adc7f9870355c5649bf7c9e240896f9b794cd03f32f39abd
advance
private void advance(Symbol symbol) throws IOException
{    this.parser.processTrailingImplicitActions();    if (in.getCurrentToken() == null && this.parser.depth() == 1)        throw new EOFException();    parser.advance(symbol);}
79ed759dc329689cccee5da68f5c322be3893b5ca69e4b1bbe6fbd1d2e16f7a7
readNull
public void readNull() throws IOException
{    advance(Symbol.NULL);    if (in.getCurrentToken() == JsonToken.VALUE_NULL) {        in.nextToken();    } else {        throw error("null");    }}
fbc49599759f8cdcf441295a1ef45ca6ee3d99e9d996d9533ab06d2378b36f10
readBoolean
public boolean readBoolean() throws IOException
{    advance(Symbol.BOOLEAN);    JsonToken t = in.getCurrentToken();    if (t == JsonToken.VALUE_TRUE || t == JsonToken.VALUE_FALSE) {        in.nextToken();        return t == JsonToken.VALUE_TRUE;    } else {        throw error("boolean");    }}
f236e7fb1e87c9b6c5be0f35fb6c4eb85b118d1b426358e70800a74f43350299
readInt
public int readInt() throws IOException
{    advance(Symbol.INT);    if (in.getCurrentToken().isNumeric()) {        int result = in.getIntValue();        in.nextToken();        return result;    } else {        throw error("int");    }}
b6042ee68b2b47bac163d020b1d36c009b0f5b2b9d1a110e94e722663331fdf1
readLong
public long readLong() throws IOException
{    advance(Symbol.LONG);    if (in.getCurrentToken().isNumeric()) {        long result = in.getLongValue();        in.nextToken();        return result;    } else {        throw error("long");    }}
3a29df2e279a1aa87799d508d3c09fea77ff7a4a1d2b413b32851226858ddce4
readFloat
public float readFloat() throws IOException
{    advance(Symbol.FLOAT);    if (in.getCurrentToken().isNumeric()) {        float result = in.getFloatValue();        in.nextToken();        return result;    } else {        throw error("float");    }}
5c17280cb2bd5e36b11f2e528a4a0334e3401e73556b4cd475f437cbff7261e1
readDouble
public double readDouble() throws IOException
{    advance(Symbol.DOUBLE);    if (in.getCurrentToken().isNumeric()) {        double result = in.getDoubleValue();        in.nextToken();        return result;    } else {        throw error("double");    }}
c053fcdbfc387a7ac67d44a07f524f8f2ea428c07c8e3590f0ed50bdc4aff483
readString
public Utf8 readString(Utf8 old) throws IOException
{    return new Utf8(readString());}
ef9970bf7628dc4396fc3849d6482ac8a961658c0482c2176ac2ba144c6112c6
readString
public String readString() throws IOException
{    advance(Symbol.STRING);    if (parser.topSymbol() == Symbol.MAP_KEY_MARKER) {        parser.advance(Symbol.MAP_KEY_MARKER);        if (in.getCurrentToken() != JsonToken.FIELD_NAME) {            throw error("map-key");        }    } else {        if (in.getCurrentToken() != JsonToken.VALUE_STRING) {            throw error("string");        }    }    String result = in.getText();    in.nextToken();    return result;}
382ea2955da9cd92c1638ec68af3df3645c63648bd3c7436582fc6d114d32dc3
skipString
public void skipString() throws IOException
{    advance(Symbol.STRING);    if (parser.topSymbol() == Symbol.MAP_KEY_MARKER) {        parser.advance(Symbol.MAP_KEY_MARKER);        if (in.getCurrentToken() != JsonToken.FIELD_NAME) {            throw error("map-key");        }    } else {        if (in.getCurrentToken() != JsonToken.VALUE_STRING) {            throw error("string");        }    }    in.nextToken();}
3f9351d2d96b71b9ade6333ab2de3b2fedb54eccbebc9ac546b7000019518e0f
readBytes
public ByteBuffer readBytes(ByteBuffer old) throws IOException
{    advance(Symbol.BYTES);    if (in.getCurrentToken() == JsonToken.VALUE_STRING) {        byte[] result = readByteArray();        in.nextToken();        return ByteBuffer.wrap(result);    } else {        throw error("bytes");    }}
d4d22788bd9b9ab86c33f80a1d52f66a7520a18e979ed7105e4f0010d0984429
readByteArray
private byte[] readByteArray() throws IOException
{    byte[] result = in.getText().getBytes(StandardCharsets.ISO_8859_1);    return result;}
2b7cdc89689872436aab53b6467b336e2c628ced0f6e4bbfc31fb05f7b33fc9c
skipBytes
public void skipBytes() throws IOException
{    advance(Symbol.BYTES);    if (in.getCurrentToken() == JsonToken.VALUE_STRING) {        in.nextToken();    } else {        throw error("bytes");    }}
77aebccb2ddb0de2a2d63691201e8f7bf578eddf39f2b3338d56e2c2cedfe6e6
checkFixed
private void checkFixed(int size) throws IOException
{    advance(Symbol.FIXED);    Symbol.IntCheckAction top = (Symbol.IntCheckAction) parser.popSymbol();    if (size != top.size) {        throw new AvroTypeException("Incorrect length for fixed binary: expected " + top.size + " but received " + size + " bytes.");    }}
e9fd530ed3f8f181f8b42a5f953bf9aa73fd331bc0c9033abf247cd28f51c99c
readFixed
public void readFixed(byte[] bytes, int start, int len) throws IOException
{    checkFixed(len);    if (in.getCurrentToken() == JsonToken.VALUE_STRING) {        byte[] result = readByteArray();        in.nextToken();        if (result.length != len) {            throw new AvroTypeException("Expected fixed length " + len + ", but got" + result.length);        }        System.arraycopy(result, 0, bytes, start, len);    } else {        throw error("fixed");    }}
fd8d4a96aa39b53251c8c74a21c8896db0ba3c1b277095d249e5eb06c38e7ca7
skipFixed
public void skipFixed(int length) throws IOException
{    checkFixed(length);    doSkipFixed(length);}
d5c9ebbb310a89e1e8282ad7c64d63f5fcf0bcece45738511dd1ca2406317581
doSkipFixed
private void doSkipFixed(int length) throws IOException
{    if (in.getCurrentToken() == JsonToken.VALUE_STRING) {        byte[] result = readByteArray();        in.nextToken();        if (result.length != length) {            throw new AvroTypeException("Expected fixed length " + length + ", but got" + result.length);        }    } else {        throw error("fixed");    }}
92d9fba0ba2214219dfa0718f8afa4f53eb8efa1d73bb030d33c52b54ebefaad
skipFixed
protected void skipFixed() throws IOException
{    advance(Symbol.FIXED);    Symbol.IntCheckAction top = (Symbol.IntCheckAction) parser.popSymbol();    doSkipFixed(top.size);}
9374ccd890881cceb7e56edb9a895bc9db6fbbbe8b0c849cf1090cbf7493f44c
readEnum
public int readEnum() throws IOException
{    advance(Symbol.ENUM);    Symbol.EnumLabelsAction top = (Symbol.EnumLabelsAction) parser.popSymbol();    if (in.getCurrentToken() == JsonToken.VALUE_STRING) {        in.getText();        int n = top.findLabel(in.getText());        if (n >= 0) {            in.nextToken();            return n;        }        throw new AvroTypeException("Unknown symbol in enum " + in.getText());    } else {        throw error("fixed");    }}
e6add0bc5e95e909949d20835efe8b60b03e5bcbc465b6ed385868efaa03433d
readArrayStart
public long readArrayStart() throws IOException
{    advance(Symbol.ARRAY_START);    if (in.getCurrentToken() == JsonToken.START_ARRAY) {        in.nextToken();        return doArrayNext();    } else {        throw error("array-start");    }}
b875ce5110599d9cbc3dee00e4aa55cb0a57d1a9573cbb258a671ce79c649910
arrayNext
public long arrayNext() throws IOException
{    advance(Symbol.ITEM_END);    return doArrayNext();}
283225108c8450149f436e2d35b471733dd19d6c203b27441280d18f6f844e8d
doArrayNext
private long doArrayNext() throws IOException
{    if (in.getCurrentToken() == JsonToken.END_ARRAY) {        parser.advance(Symbol.ARRAY_END);        in.nextToken();        return 0;    } else {        return 1;    }}
50c9a94efe953551ebfe49b73eadd4db5a332ca0b3a3650f3336e996f5e88c7f
skipArray
public long skipArray() throws IOException
{    advance(Symbol.ARRAY_START);    if (in.getCurrentToken() == JsonToken.START_ARRAY) {        in.skipChildren();        in.nextToken();        advance(Symbol.ARRAY_END);    } else {        throw error("array-start");    }    return 0;}
e6bc36a0bc14db0154507596b987d5b0b1c5ad572a5ef56fc85c9dc13e23f964
readMapStart
public long readMapStart() throws IOException
{    advance(Symbol.MAP_START);    if (in.getCurrentToken() == JsonToken.START_OBJECT) {        in.nextToken();        return doMapNext();    } else {        throw error("map-start");    }}
cf2dd4f4b7450866b8f7c0b58e3817a1f8aad0f3978d831c76efd87c84fd4dcd
mapNext
public long mapNext() throws IOException
{    advance(Symbol.ITEM_END);    return doMapNext();}
44416047676feb4da3b905a5e76d1f3b47dfc3d9b09e0dc2f9cb1681281b73e1
doMapNext
private long doMapNext() throws IOException
{    if (in.getCurrentToken() == JsonToken.END_OBJECT) {        in.nextToken();        advance(Symbol.MAP_END);        return 0;    } else {        return 1;    }}
d9353ecbd03723a8a9e9f6a886bfef387f4f65291d9de544d01d5d5502f78a27
skipMap
public long skipMap() throws IOException
{    advance(Symbol.MAP_START);    if (in.getCurrentToken() == JsonToken.START_OBJECT) {        in.skipChildren();        in.nextToken();        advance(Symbol.MAP_END);    } else {        throw error("map-start");    }    return 0;}
ed45fee8aef2b75e580e16f8fd6df1adc125a82cfee5ebc3632541573629672c
readIndex
public int readIndex() throws IOException
{    advance(Symbol.UNION);    Symbol.Alternative a = (Symbol.Alternative) parser.popSymbol();    String label;    if (in.getCurrentToken() == JsonToken.VALUE_NULL) {        label = "null";    } else if (in.getCurrentToken() == JsonToken.START_OBJECT && in.nextToken() == JsonToken.FIELD_NAME) {        label = in.getText();        in.nextToken();        parser.pushSymbol(Symbol.UNION_END);    } else {        throw error("start-union");    }    int n = a.findLabel(label);    if (n < 0)        throw new AvroTypeException("Unknown union branch " + label);    parser.pushSymbol(a.getSymbol(n));    return n;}
4bc406c880da45c1b625fe343f923d7798a5cc94ccbcc02295ee6611a8cb47e2
doAction
public Symbol doAction(Symbol input, Symbol top) throws IOException
{    if (top instanceof Symbol.FieldAdjustAction) {        Symbol.FieldAdjustAction fa = (Symbol.FieldAdjustAction) top;        String name = fa.fname;        if (currentReorderBuffer != null) {            try (TokenBuffer tokenBuffer = currentReorderBuffer.savedFields.get(name)) {                if (tokenBuffer != null) {                    currentReorderBuffer.savedFields.remove(name);                    currentReorderBuffer.origParser = in;                    in = tokenBuffer.asParser();                    in.nextToken();                    return null;                }            }        }        if (in.getCurrentToken() == JsonToken.FIELD_NAME) {            do {                String fn = in.getText();                in.nextToken();                if (name.equals(fn) || fa.aliases.contains(fn)) {                    return null;                } else {                    if (currentReorderBuffer == null) {                        currentReorderBuffer = new ReorderBuffer();                    }                    try (TokenBuffer tokenBuffer = new TokenBuffer(in)) {                                                tokenBuffer.copyCurrentStructure(in);                        currentReorderBuffer.savedFields.put(fn, tokenBuffer);                    }                    in.nextToken();                }            } while (in.getCurrentToken() == JsonToken.FIELD_NAME);            throw new AvroTypeException("Expected field name not found: " + fa.fname);        }    } else if (top == Symbol.FIELD_END) {        if (currentReorderBuffer != null && currentReorderBuffer.origParser != null) {            in = currentReorderBuffer.origParser;            currentReorderBuffer.origParser = null;        }    } else if (top == Symbol.RECORD_START) {        if (in.getCurrentToken() == JsonToken.START_OBJECT) {            in.nextToken();            reorderBuffers.push(currentReorderBuffer);            currentReorderBuffer = null;        } else {            throw error("record-start");        }    } else if (top == Symbol.RECORD_END || top == Symbol.UNION_END) {                while (in.getCurrentToken() != JsonToken.END_OBJECT) {            in.nextToken();        }        if (top == Symbol.RECORD_END) {            if (currentReorderBuffer != null && !currentReorderBuffer.savedFields.isEmpty()) {                throw error("Unknown fields: " + currentReorderBuffer.savedFields.keySet());            }            currentReorderBuffer = reorderBuffers.pop();        }                in.nextToken();    } else {        throw new AvroTypeException("Unknown action symbol " + top);    }    return null;}
f4914cda2948c985f19777a2e16c33e71246f12f02f84a2f27c8fedfd8ee93d2
error
private AvroTypeException error(String type)
{    return new AvroTypeException("Expected " + type + ". Got " + in.getCurrentToken());}
c3e67ec76f1b008887f1caba645a2614900cde6e477acca1bc3ecc36bf357fcf
flush
public void flush() throws IOException
{    parser.processImplicitActions();    if (out != null) {        out.flush();    }}
f536b55328cfddc7ab0003f8876cec15db8082462823186f6bcf1180015517b7
getJsonGenerator
private static JsonGenerator getJsonGenerator(OutputStream out, boolean pretty) throws IOException
{    if (null == out)        throw new NullPointerException("OutputStream cannot be null");    JsonGenerator g = new JsonFactory().createGenerator(out, JsonEncoding.UTF8);    if (pretty) {        DefaultPrettyPrinter pp = new DefaultPrettyPrinter() {            @Override            public void writeRootValueSeparator(JsonGenerator jg) throws IOException {                jg.writeRaw(LINE_SEPARATOR);            }        };        g.setPrettyPrinter(pp);    } else {        MinimalPrettyPrinter pp = new MinimalPrettyPrinter();        pp.setRootValueSeparator(LINE_SEPARATOR);        g.setPrettyPrinter(pp);    }    return g;}
62539a76f157bf2d19611f7de31b54973658f53b041c9b23908ea991897f15e3
writeRootValueSeparator
public void writeRootValueSeparator(JsonGenerator jg) throws IOException
{    jg.writeRaw(LINE_SEPARATOR);}
218fc74b76dcf5179eb580935440e3e8964d3b91ac256ef0b91402c4e526b35e
isIncludeNamespace
public boolean isIncludeNamespace()
{    return includeNamespace;}
3f8791c39064b94642fbe88d529d1255ba3f78811692952053c609bae893c8c3
setIncludeNamespace
public void setIncludeNamespace(final boolean includeNamespace)
{    this.includeNamespace = includeNamespace;}
c1d5e1246fce6cda8189938f681858f94f732fe19e20a919e20734a4969fa9b8
configure
public JsonEncoder configure(OutputStream out) throws IOException
{    this.configure(getJsonGenerator(out, false));    return this;}
475b096cec6fd3438a020511b7b0989454a20541814c7994322b0b54cbe10545
configure
private JsonEncoder configure(JsonGenerator generator) throws IOException
{    if (null == generator)        throw new NullPointerException("JsonGenerator cannot be null");    if (null != parser) {        flush();    }    this.out = generator;    return this;}
07c3270fe1b73532e66eb6f555ff312e3202b8435cf61382c5aa1c0dc4ce9a22
writeNull
public void writeNull() throws IOException
{    parser.advance(Symbol.NULL);    out.writeNull();}
9d2c4a8e17244c43f6c9a688d920b81cfa21c5d72f09e261b40e4539894a93a4
writeBoolean
public void writeBoolean(boolean b) throws IOException
{    parser.advance(Symbol.BOOLEAN);    out.writeBoolean(b);}
3d8eb176faa04ef3aa5f28bd1c308daf64cdee2071894b3447ade0d0891ac95b
writeInt
public void writeInt(int n) throws IOException
{    parser.advance(Symbol.INT);    out.writeNumber(n);}
9d5f02c473bb90aaa95e11d7e93625ba8050b2ae1b4b94e45331333ecc81fb92
writeLong
public void writeLong(long n) throws IOException
{    parser.advance(Symbol.LONG);    out.writeNumber(n);}
485832ef5d131a3779da1c259796c40decbe270ca77fd7c3bd67453210649270
writeFloat
public void writeFloat(float f) throws IOException
{    parser.advance(Symbol.FLOAT);    out.writeNumber(f);}
b0e7b254d45c2210c8fda5ed2caaef6ca76fec51fb5d6a536add22a8a39ae5e9
writeDouble
public void writeDouble(double d) throws IOException
{    parser.advance(Symbol.DOUBLE);    out.writeNumber(d);}
34bdbb4029a48cb89270af40e256732c5b672fb11b54336d3f7efc90b7df5ab2
writeString
public void writeString(Utf8 utf8) throws IOException
{    writeString(utf8.toString());}
be522bdc069e00fedad1d530e53eaeeecbe14ec57a058d6c1eb3025c7dcdd5fa
writeString
public void writeString(String str) throws IOException
{    parser.advance(Symbol.STRING);    if (parser.topSymbol() == Symbol.MAP_KEY_MARKER) {        parser.advance(Symbol.MAP_KEY_MARKER);        out.writeFieldName(str);    } else {        out.writeString(str);    }}
ef77a45285e12605fa0ac332653126204dbd8aeb25f392f6b9900d3df7110e24
writeBytes
public void writeBytes(ByteBuffer bytes) throws IOException
{    if (bytes.hasArray()) {        writeBytes(bytes.array(), bytes.position(), bytes.remaining());    } else {        byte[] b = new byte[bytes.remaining()];        bytes.duplicate().get(b);        writeBytes(b);    }}
5686b3aa744852e31cb4ae1e0044e20a94ff28b7620cb59b1eb1a47c8ef69565
writeBytes
public void writeBytes(byte[] bytes, int start, int len) throws IOException
{    parser.advance(Symbol.BYTES);    writeByteArray(bytes, start, len);}
a7cb3d20669d5a7d27a19a8ed62acc09f382ed5810dcde24285125516f8031b8
writeByteArray
private void writeByteArray(byte[] bytes, int start, int len) throws IOException
{    out.writeString(new String(bytes, start, len, StandardCharsets.ISO_8859_1));}
23ad82833b3f2bd0c47b14f7e1f984068754ba8fea96d9cf72a5dc7b0df27779
writeFixed
public void writeFixed(byte[] bytes, int start, int len) throws IOException
{    parser.advance(Symbol.FIXED);    Symbol.IntCheckAction top = (Symbol.IntCheckAction) parser.popSymbol();    if (len != top.size) {        throw new AvroTypeException("Incorrect length for fixed binary: expected " + top.size + " but received " + len + " bytes.");    }    writeByteArray(bytes, start, len);}
9c2c1c74b0f6ed303f5a2809268552b5b4c2121bcc71b39f52e22e9cfb232cc6
writeEnum
public void writeEnum(int e) throws IOException
{    parser.advance(Symbol.ENUM);    Symbol.EnumLabelsAction top = (Symbol.EnumLabelsAction) parser.popSymbol();    if (e < 0 || e >= top.size) {        throw new AvroTypeException("Enumeration out of range: max is " + top.size + " but received " + e);    }    out.writeString(top.getLabel(e));}
397b6502072ea3a1ac72a07bee65a462902e7e78c46d167fac7946bd2eee93fb
writeArrayStart
public void writeArrayStart() throws IOException
{    parser.advance(Symbol.ARRAY_START);    out.writeStartArray();    push();    isEmpty.set(depth());}
ed98fbed6a1d613e764dba378ccb5b19a641d3ecbc93a5f3d50f0010442034de
writeArrayEnd
public void writeArrayEnd() throws IOException
{    if (!isEmpty.get(pos)) {        parser.advance(Symbol.ITEM_END);    }    pop();    parser.advance(Symbol.ARRAY_END);    out.writeEndArray();}
06a13fe57e24d2460afd3389759c84bd57ee09e14710364b77d081005edff6eb
writeMapStart
public void writeMapStart() throws IOException
{    push();    isEmpty.set(depth());    parser.advance(Symbol.MAP_START);    out.writeStartObject();}
44f6ecf1e519c8992d2b321f4cf40cfe49a47d580d58e41fd28fe573a1ea47c4
writeMapEnd
public void writeMapEnd() throws IOException
{    if (!isEmpty.get(pos)) {        parser.advance(Symbol.ITEM_END);    }    pop();    parser.advance(Symbol.MAP_END);    out.writeEndObject();}
bed0009bb8139bc1ffb6ee9ad42162880141e39749c278e1724abb291a79cd42
startItem
public void startItem() throws IOException
{    if (!isEmpty.get(pos)) {        parser.advance(Symbol.ITEM_END);    }    super.startItem();    isEmpty.clear(depth());}
5e98b24f5d4da4c35f9e7f9247f0fdca1daf147afc1971fff5a25067084cf67d
writeIndex
public void writeIndex(int unionIndex) throws IOException
{    parser.advance(Symbol.UNION);    Symbol.Alternative top = (Symbol.Alternative) parser.popSymbol();    Symbol symbol = top.getSymbol(unionIndex);    if (symbol != Symbol.NULL && includeNamespace) {        out.writeStartObject();        out.writeFieldName(top.getLabel(unionIndex));        parser.pushSymbol(Symbol.UNION_END);    }    parser.pushSymbol(symbol);}
4bc406c880da45c1b625fe343f923d7798a5cc94ccbcc02295ee6611a8cb47e2
doAction
public Symbol doAction(Symbol input, Symbol top) throws IOException
{    if (top instanceof Symbol.FieldAdjustAction) {        Symbol.FieldAdjustAction fa = (Symbol.FieldAdjustAction) top;        out.writeFieldName(fa.fname);    } else if (top == Symbol.RECORD_START) {        out.writeStartObject();    } else if (top == Symbol.RECORD_END || top == Symbol.UNION_END) {        out.writeEndObject();    } else if (top != Symbol.FIELD_END) {        throw new AvroTypeException("Unknown action symbol " + top);    }    return null;}
791e770fb93e47bbeda4cdaeb78bde31e339ebc906a1796ee4cbecbb221a3106
generate
public Symbol generate(Schema schema)
{    return Symbol.root(generate(schema, new HashMap<>()));}
b5da8291a417a71b776dac069759645db7a862fe740a3bf06534d58a5fe539f4
generate
public Symbol generate(Schema sc, Map<LitS, Symbol> seen)
{    switch(sc.getType()) {        case NULL:        case BOOLEAN:        case INT:        case LONG:        case FLOAT:        case DOUBLE:        case STRING:        case BYTES:        case FIXED:        case UNION:            return super.generate(sc, seen);        case ENUM:            return Symbol.seq(Symbol.enumLabelsAction(sc.getEnumSymbols()), Symbol.ENUM);        case ARRAY:            return Symbol.seq(Symbol.repeat(Symbol.ARRAY_END, Symbol.ITEM_END, generate(sc.getElementType(), seen)), Symbol.ARRAY_START);        case MAP:            return Symbol.seq(Symbol.repeat(Symbol.MAP_END, Symbol.ITEM_END, generate(sc.getValueType(), seen), Symbol.MAP_KEY_MARKER, Symbol.STRING), Symbol.MAP_START);        case RECORD:            {                LitS wsc = new LitS(sc);                Symbol rresult = seen.get(wsc);                if (rresult == null) {                    Symbol[] production = new Symbol[sc.getFields().size() * 3 + 2];                    rresult = Symbol.seq(production);                    seen.put(wsc, rresult);                    int i = production.length;                    int n = 0;                    production[--i] = Symbol.RECORD_START;                    for (Field f : sc.getFields()) {                        production[--i] = Symbol.fieldAdjustAction(n, f.name(), f.aliases());                        production[--i] = generate(f.schema(), seen);                        production[--i] = Symbol.FIELD_END;                        n++;                    }                    production[--i] = Symbol.RECORD_END;                }                return rresult;            }        default:            throw new RuntimeException("Unexpected schema type");    }}
97be99acf8b5ab519c9e56b67d4c5e7e2524747e43f911b82959ee99cdb94825
expandStack
private void expandStack()
{    stack = Arrays.copyOf(stack, stack.length + Math.max(stack.length, 1024));}
73b90709690d73b7fb9cdd63d58fa0657ea2914a3a7dfe0374a1525040951f3f
advance
public final Symbol advance(Symbol input) throws IOException
{    for (; ; ) {        Symbol top = stack[--pos];        if (top == input) {                        return top;        }        Symbol.Kind k = top.kind;        if (k == Symbol.Kind.IMPLICIT_ACTION) {            Symbol result = symbolHandler.doAction(input, top);            if (result != null) {                return result;            }        } else if (k == Symbol.Kind.TERMINAL) {            throw new AvroTypeException("Attempt to process a " + input + " when a " + top + " was expected.");        } else if (k == Symbol.Kind.REPEATER && input == ((Symbol.Repeater) top).end) {            return input;        } else {            pushProduction(top);        }    }}
8e141036ed28bf1842a6e3752b1cacc3b7416ed535e33dac1829e331bd8f6dae
processImplicitActions
public final void processImplicitActions() throws IOException
{    while (pos > 1) {        Symbol top = stack[pos - 1];        if (top.kind == Symbol.Kind.IMPLICIT_ACTION) {            pos--;            symbolHandler.doAction(null, top);        } else if (top.kind != Symbol.Kind.TERMINAL) {            pos--;            pushProduction(top);        } else {            break;        }    }}
e7bae0ccd637c1fb0e59d4ce07f406be5c5f53ffd5089d5cebb9d73de1bd9a55
processTrailingImplicitActions
public final void processTrailingImplicitActions() throws IOException
{    while (pos >= 1) {        Symbol top = stack[pos - 1];        if (top.kind == Symbol.Kind.IMPLICIT_ACTION && ((Symbol.ImplicitAction) top).isTrailing) {            pos--;            symbolHandler.doAction(null, top);        } else {            break;        }    }}
1b39f875896419245f4b1278176cdcf4f37d895de66e82d28df573f09649394e
pushProduction
public final void pushProduction(Symbol sym)
{    Symbol[] p = sym.production;    while (pos + p.length > stack.length) {        expandStack();    }    System.arraycopy(p, 0, stack, pos, p.length);    pos += p.length;}
40e7dc397ace947e9fa98afae6cab1b9b6aac5c2be126dd927e026b87f593440
popSymbol
public Symbol popSymbol()
{    return stack[--pos];}
973b0b6afe2daec1f26083ecfcd669f16196aa8313ef2562553a7e658dc890ae
topSymbol
public Symbol topSymbol()
{    return stack[pos - 1];}
2300c3352e4db5f24737221cf4504a6bc3f5df58bfc6e381a3b44f6877ab7e5f
pushSymbol
public void pushSymbol(Symbol sym)
{    if (pos == stack.length) {        expandStack();    }    stack[pos++] = sym;}
7f03d74747ed71c87bc11017b6882c343ec2ac89aad575cdd4493c9bfcd645ad
depth
public int depth()
{    return pos;}
97d2d353f08aa5a1da8b18b0800b6e778df65f48d34726e5f17800df7e0d88e2
reset
public void reset()
{    pos = 1;}
4cab2747220a8d6b46b863bd2abdb7e67486a1872df243256ebeeaf5b5903422
encode
protected void encode(Encoder e, Schema s, JsonNode n) throws IOException
{    ResolvingGrammarGenerator.encode(e, s, n);}
61d00fb675df239d0a10b48500364c9e44b1549f2b0479a42f384e02f90667af
generate
public final Symbol generate(Schema writer, Schema reader) throws IOException
{    Resolver.Action r = Resolver.resolve(writer, reader);    return Symbol.root(generate(r, new HashMap<>()));}
6d3dbc7a98bc68cdee68714c9c62214b58ba0251ffad9b208649b2cbd4c49224
generate
private Symbol generate(Resolver.Action action, Map<Object, Symbol> seen) throws IOException
{    if (action instanceof Resolver.DoNothing) {        return simpleGen(action.writer, seen);    } else if (action instanceof Resolver.ErrorAction) {        return Symbol.error(action.toString());    } else if (action instanceof Resolver.Skip) {        return Symbol.skipAction(simpleGen(action.writer, seen));    } else if (action instanceof Resolver.Promote) {        return Symbol.resolve(simpleGen(action.writer, seen), simpleGen(action.reader, seen));    } else if (action instanceof Resolver.ReaderUnion) {        Resolver.ReaderUnion ru = (Resolver.ReaderUnion) action;        Symbol s = generate(ru.actualAction, seen);        return Symbol.seq(Symbol.unionAdjustAction(ru.firstMatch, s), Symbol.UNION);    } else if (action.writer.getType() == Schema.Type.ARRAY) {        Symbol es = generate(((Resolver.Container) action).elementAction, seen);        return Symbol.seq(Symbol.repeat(Symbol.ARRAY_END, es), Symbol.ARRAY_START);    } else if (action.writer.getType() == Schema.Type.MAP) {        Symbol es = generate(((Resolver.Container) action).elementAction, seen);        return Symbol.seq(Symbol.repeat(Symbol.MAP_END, es, Symbol.STRING), Symbol.MAP_START);    } else if (action.writer.getType() == Schema.Type.UNION) {        if (((Resolver.WriterUnion) action).unionEquiv)            return simpleGen(action.writer, seen);        Resolver.Action[] branches = ((Resolver.WriterUnion) action).actions;        Symbol[] symbols = new Symbol[branches.length];        String[] labels = new String[branches.length];        int i = 0;        for (Resolver.Action branch : branches) {            symbols[i] = generate(branch, seen);            labels[i] = action.writer.getTypes().get(i).getFullName();            i++;        }        return Symbol.seq(Symbol.alt(symbols, labels), Symbol.WRITER_UNION_ACTION);    } else if (action instanceof Resolver.EnumAdjust) {        Resolver.EnumAdjust e = (Resolver.EnumAdjust) action;        Object[] adjs = new Object[e.adjustments.length];        for (int i = 0; i < adjs.length; i++) adjs[i] = (0 <= e.adjustments[i] ? new Integer(e.adjustments[i]) : "No match for " + e.writer.getEnumSymbols().get(i));        return Symbol.seq(Symbol.enumAdjustAction(e.reader.getEnumSymbols().size(), adjs), Symbol.ENUM);    } else if (action instanceof Resolver.RecordAdjust) {        Symbol result = seen.get(action);        if (result == null) {            final Resolver.RecordAdjust ra = (Resolver.RecordAdjust) action;            int defaultCount = ra.readerOrder.length - ra.firstDefault;            int count = 1 + ra.fieldActions.length + 3 * defaultCount;            Symbol[] production = new Symbol[count];            result = Symbol.seq(production);            seen.put(action, result);            production[--count] = Symbol.fieldOrderAction(ra.readerOrder);            for (Resolver.Action wfa : ra.fieldActions) production[--count] = generate(wfa, seen);            for (int i = ra.firstDefault; i < ra.readerOrder.length; i++) {                Schema.Field rf = ra.readerOrder[i];                byte[] bb = getBinary(rf.schema(), Accessor.defaultValue(rf));                production[--count] = Symbol.defaultStartAction(bb);                production[--count] = simpleGen(rf.schema(), seen);                production[--count] = Symbol.DEFAULT_END_ACTION;            }        }        return result;    }    throw new IllegalArgumentException("Unrecognized Resolver.Action: " + action);}
985212bd7ddd338fa3d03f2e1d2d96974ed08d8867e670244b0ef4d279ca2f07
simpleGen
private Symbol simpleGen(Schema s, Map<Object, Symbol> seen)
{    switch(s.getType()) {        case NULL:            return Symbol.NULL;        case BOOLEAN:            return Symbol.BOOLEAN;        case INT:            return Symbol.INT;        case LONG:            return Symbol.LONG;        case FLOAT:            return Symbol.FLOAT;        case DOUBLE:            return Symbol.DOUBLE;        case BYTES:            return Symbol.BYTES;        case STRING:            return Symbol.STRING;        case FIXED:            return Symbol.seq(new Symbol.IntCheckAction(s.getFixedSize()), Symbol.FIXED);        case ENUM:            return Symbol.seq(Symbol.enumAdjustAction(s.getEnumSymbols().size(), null), Symbol.ENUM);        case ARRAY:            return Symbol.seq(Symbol.repeat(Symbol.ARRAY_END, simpleGen(s.getElementType(), seen)), Symbol.ARRAY_START);        case MAP:            return Symbol.seq(Symbol.repeat(Symbol.MAP_END, simpleGen(s.getValueType(), seen), Symbol.STRING), Symbol.MAP_START);        case UNION:            {                List<Schema> subs = s.getTypes();                Symbol[] symbols = new Symbol[subs.size()];                String[] labels = new String[subs.size()];                int i = 0;                for (Schema b : s.getTypes()) {                    symbols[i] = simpleGen(b, seen);                    labels[i++] = b.getFullName();                }                return Symbol.seq(Symbol.alt(symbols, labels), Symbol.UNION);            }        case RECORD:            {                Symbol result = seen.get(s);                if (result == null) {                    Symbol[] production = new Symbol[s.getFields().size() + 1];                    result = Symbol.seq(production);                    seen.put(s, result);                    int i = production.length;                    production[--i] = Symbol.fieldOrderAction(s.getFields().toArray(new Schema.Field[0]));                    for (Field f : s.getFields()) production[--i] = simpleGen(f.schema(), seen);                                                                }                return result;            }        default:            throw new IllegalArgumentException("Unexpected schema: " + s);    }}
9d046ee133a663b9ede71f4cbbc9b194aee14493e22fa99edc1245cb43a21f22
getBinary
private static byte[] getBinary(Schema s, JsonNode n) throws IOException
{    ByteArrayOutputStream out = new ByteArrayOutputStream();    Encoder e = factory.binaryEncoder(out, null);    encode(e, s, n);    e.flush();    return out.toByteArray();}
0684a6d05da4856f26f3c25af740356f2f1b498f650dd7aba258c3a3e095432b
encode
 static void encode(Encoder e, Schema s, JsonNode n) throws IOException
{    switch(s.getType()) {        case RECORD:            for (Field f : s.getFields()) {                String name = f.name();                JsonNode v = n.get(name);                if (v == null) {                    v = Accessor.defaultValue(f);                }                if (v == null) {                    throw new AvroTypeException("No default value for: " + name);                }                encode(e, f.schema(), v);            }            break;        case ENUM:            e.writeEnum(s.getEnumOrdinal(n.textValue()));            break;        case ARRAY:            e.writeArrayStart();            e.setItemCount(n.size());            Schema i = s.getElementType();            for (JsonNode node : n) {                e.startItem();                encode(e, i, node);            }            e.writeArrayEnd();            break;        case MAP:            e.writeMapStart();            e.setItemCount(n.size());            Schema v = s.getValueType();            for (Iterator<String> it = n.fieldNames(); it.hasNext(); ) {                e.startItem();                String key = it.next();                e.writeString(key);                encode(e, v, n.get(key));            }            e.writeMapEnd();            break;        case UNION:            e.writeIndex(0);            encode(e, s.getTypes().get(0), n);            break;        case FIXED:            if (!n.isTextual())                throw new AvroTypeException("Non-string default value for fixed: " + n);            byte[] bb = n.textValue().getBytes(StandardCharsets.ISO_8859_1);            if (bb.length != s.getFixedSize()) {                bb = Arrays.copyOf(bb, s.getFixedSize());            }            e.writeFixed(bb);            break;        case STRING:            if (!n.isTextual())                throw new AvroTypeException("Non-string default value for string: " + n);            e.writeString(n.textValue());            break;        case BYTES:            if (!n.isTextual())                throw new AvroTypeException("Non-string default value for bytes: " + n);            e.writeBytes(n.textValue().getBytes(StandardCharsets.ISO_8859_1));            break;        case INT:            if (!n.isNumber())                throw new AvroTypeException("Non-numeric default value for int: " + n);            e.writeInt(n.intValue());            break;        case LONG:            if (!n.isNumber())                throw new AvroTypeException("Non-numeric default value for long: " + n);            e.writeLong(n.longValue());            break;        case FLOAT:            if (!n.isNumber())                throw new AvroTypeException("Non-numeric default value for float: " + n);            e.writeFloat((float) n.doubleValue());            break;        case DOUBLE:            if (!n.isNumber())                throw new AvroTypeException("Non-numeric default value for double: " + n);            e.writeDouble(n.doubleValue());            break;        case BOOLEAN:            if (!n.isBoolean())                throw new AvroTypeException("Non-boolean default for boolean: " + n);            e.writeBoolean(n.booleanValue());            break;        case NULL:            if (!n.isNull())                throw new AvroTypeException("Non-null default value for null type: " + n);            e.writeNull();            break;    }}
3a74d956746dd29a326d0c779c62298efb25977f15c2b66a7f380ee1280afdcf
skipTo
public final void skipTo(int target) throws IOException
{    outer: while (target < pos) {        Symbol top = stack[pos - 1];        while (top.kind != Symbol.Kind.TERMINAL) {            if (top.kind == Symbol.Kind.IMPLICIT_ACTION || top.kind == Symbol.Kind.EXPLICIT_ACTION) {                skipHandler.skipAction();            } else {                --pos;                pushProduction(top);            }            continue outer;        }        skipHandler.skipTopSymbol();    }}
3958c174c7ee5b4e343c6bd5f7c7b56422b34d5ff8a55bb74a05e3ccd4334a1d
skipRepeater
public final void skipRepeater() throws IOException
{    int target = pos;    Symbol repeater = stack[--pos];    assert repeater.kind == Symbol.Kind.REPEATER;    pushProduction(repeater);    skipTo(target);}
029bb33a446ecb288617ecb2f3f1cebe741c265d362141a7892e6fcd35720084
skipSymbol
public final void skipSymbol(Symbol symToSkip) throws IOException
{    int target = pos;    pushSymbol(symToSkip);    skipTo(target);}
20e2bf68714122d39109950172a279e864757d9397b456194824448bd2616b1a
root
 static Symbol root(Symbol... symbols)
{    return new Root(symbols);}
31a6d3e7f20d2a83d78a2463e10c919b289633f7b66db1fe756a776b682fd634
seq
 static Symbol seq(Symbol... production)
{    return new Sequence(production);}
ed64d0788f49f6145b1da62db53eb5ec63aa23e781c05d359458abeb5c2115c5
repeat
 static Symbol repeat(Symbol endSymbol, Symbol... symsToRepeat)
{    return new Repeater(endSymbol, symsToRepeat);}
92f1001984828aaef23a7d183d4e37f32f4652bdc8e552023de37eeb30e0752b
alt
 static Symbol alt(Symbol[] symbols, String[] labels)
{    return new Alternative(symbols, labels);}
c38592b77e5bff5cb2dc55b7f56af882668e0fb018fbc5dcf7b33a792538563a
error
 static Symbol error(String e)
{    return new ErrorAction(e);}
a6c2d038465e21d1f7c76bdbd1176c6ee1a2df10a0b6a16df9ec67594684d237
resolve
 static Symbol resolve(Symbol w, Symbol r)
{    return new ResolvingAction(w, r);}
b2245ffb9e88d51ab3aeb0fbadf41ccc6e59fef1f6deffb44b4f29b15294ce27
flatten
public Symbol flatten(Map<Sequence, Sequence> map, Map<Sequence, List<Fixup>> map2)
{    return this;}
c01a6e004b77253402253bf0dc561e325cb085357621177a67b6534224237ab6
flattenedSize
public int flattenedSize()
{    return 1;}
dc1d15998caad9f89f6c07cff41e5cfde02963c999ff7c198888ceb5d27c4867
flatten
 static void flatten(Symbol[] in, int start, Symbol[] out, int skip, Map<Sequence, Sequence> map, Map<Sequence, List<Fixup>> map2)
{    for (int i = start, j = skip; i < in.length; i++) {        Symbol s = in[i].flatten(map, map2);        if (s instanceof Sequence) {            Symbol[] p = s.production;            List<Fixup> l = map2.get(s);            if (l == null) {                System.arraycopy(p, 0, out, j, p.length);                                for (List<Fixup> fixups : map2.values()) {                    copyFixups(fixups, out, j, p);                }            } else {                l.add(new Fixup(out, j));            }            j += p.length;        } else {            out[j++] = s;        }    }}
fcac045cccc5ca26f0ef062ebf1ce5425af6e905935a308910fa0ee782cc806a
copyFixups
private static void copyFixups(List<Fixup> fixups, Symbol[] out, int outPos, Symbol[] toCopy)
{    for (int i = 0, n = fixups.size(); i < n; i += 1) {        Fixup fixup = fixups.get(i);        if (fixup.symbols == toCopy) {            fixups.add(new Fixup(out, fixup.pos + outPos));        }    }}
3f1934cc9cc2a9ce73abc39296f79bfd1c06033a047e2aad81f0a1dbbe0ad0d6
flattenedSize
protected static int flattenedSize(Symbol[] symbols, int start)
{    int result = 0;    for (int i = start; i < symbols.length; i++) {        if (symbols[i] instanceof Sequence) {            Sequence s = (Sequence) symbols[i];            result += s.flattenedSize();        } else {            result += 1;        }    }    return result;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return printName;}
f52361639cd670049b1a926a5c33dc27d475b26604d601f53f5efc60010e8406
makeProduction
private static Symbol[] makeProduction(Symbol[] symbols)
{    Symbol[] result = new Symbol[flattenedSize(symbols, 0) + 1];    flatten(symbols, 0, result, 1, new HashMap<>(), new HashMap<>());    return result;}
c1d1680afba16509e0850324e46ddad771abf12b6a2af4f282818b1998d10731
get
public Symbol get(int index)
{    return production[index];}
72ef1e59027007ffe0950edfd2670ad03bb65cd6463d5d1d282dfeb1750435b0
size
public int size()
{    return production.length;}
1b00e9773d035399afdf2a1fc4f2d8a760388a3db76b60233bc48298321e1028
iterator
public Iterator<Symbol> iterator()
{    return new Iterator<Symbol>() {        private int pos = production.length;        @Override        public boolean hasNext() {            return 0 < pos;        }        @Override        public Symbol next() {            if (0 < pos) {                return production[--pos];            } else {                throw new NoSuchElementException();            }        }        @Override        public void remove() {            throw new UnsupportedOperationException();        }    };}
d51e5f7450eca0a0f63da1a466189e262d053b84aa767ba3be5cea740af7251b
hasNext
public boolean hasNext()
{    return 0 < pos;}
990ed851c2251e413d8ea71765af57a7d9365ca28f4a16af014dbc14e43344bd
next
public Symbol next()
{    if (0 < pos) {        return production[--pos];    } else {        throw new NoSuchElementException();    }}
eb35e4acc0ab2c89fd30970f01fba35488b3a4581b2af1986091209043508a3e
remove
public void remove()
{    throw new UnsupportedOperationException();}
1f330e462e74680e055820ff507049532676a814f838d824a125faec95ce9ddc
flatten
public Sequence flatten(Map<Sequence, Sequence> map, Map<Sequence, List<Fixup>> map2)
{    Sequence result = map.get(this);    if (result == null) {        result = new Sequence(new Symbol[flattenedSize()]);        map.put(this, result);        List<Fixup> l = new ArrayList<>();        map2.put(result, l);        flatten(production, 0, result.production, 0, map, map2);        for (Fixup f : l) {            System.arraycopy(result.production, 0, f.symbols, f.pos, result.production.length);        }        map2.remove(result);    }    return result;}
de1ef2cdda67e6449ce34ffb6d8bfe4f30939e5944be4c7e4a2a7aec22b3aa8d
flattenedSize
public final int flattenedSize()
{    return flattenedSize(production, 0);}
bb84c7af554e35561d130a3b69ed283d97035b99a09dc4a6bfcf729737d566a6
makeProduction
private static Symbol[] makeProduction(Symbol[] p)
{    Symbol[] result = new Symbol[p.length + 1];    System.arraycopy(p, 0, result, 1, p.length);    return result;}
a83f6339720c4eee1f7a525fc6f4632765be249648492e5d1aaf6d776cf4b238
flatten
public Repeater flatten(Map<Sequence, Sequence> map, Map<Sequence, List<Fixup>> map2)
{    Repeater result = new Repeater(end, new Symbol[flattenedSize(production, 1)]);    flatten(production, 1, result.production, 1, map, map2);    return result;}
50af9b2fb641275882078318f151dc31f53a244579b6357042fee772589c872a
hasErrors
public static boolean hasErrors(Symbol symbol)
{    return hasErrors(symbol, new HashSet<>());}
021f1978bd3da8175620ab93206dde455100b22f9397c7160a2d0123898bdc8d
hasErrors
private static boolean hasErrors(Symbol symbol, Set<Symbol> visited)
{        if (visited.contains(symbol)) {        return false;    }    visited.add(symbol);    switch(symbol.kind) {        case ALTERNATIVE:            return hasErrors(symbol, ((Alternative) symbol).symbols, visited);        case EXPLICIT_ACTION:            return false;        case IMPLICIT_ACTION:            if (symbol instanceof ErrorAction) {                return true;            }            if (symbol instanceof UnionAdjustAction) {                return hasErrors(((UnionAdjustAction) symbol).symToParse, visited);            }            return false;        case REPEATER:            Repeater r = (Repeater) symbol;            return hasErrors(r.end, visited) || hasErrors(symbol, r.production, visited);        case ROOT:        case SEQUENCE:            return hasErrors(symbol, symbol.production, visited);        case TERMINAL:            return false;        default:            throw new RuntimeException("unknown symbol kind: " + symbol.kind);    }}
1cb725601221f7aef1b475f1d35060e1cd8b0af8cdb02b9b229381fc90adbe61
hasErrors
private static boolean hasErrors(Symbol root, Symbol[] symbols, Set<Symbol> visited)
{    if (null != symbols) {        for (Symbol s : symbols) {            if (s == root) {                continue;            }            if (hasErrors(s, visited)) {                return true;            }        }    }    return false;}
3bba2ec3e561da5e9f99017fea298026bf39a1cb1095a74051be4a4e9b03fa94
getSymbol
public Symbol getSymbol(int index)
{    return symbols[index];}
d1f96abb74a0a12afc59baca0cd3ac2ac33a56a6c69367841db044491f3f9ef0
getLabel
public String getLabel(int index)
{    return labels[index];}
72ef1e59027007ffe0950edfd2670ad03bb65cd6463d5d1d282dfeb1750435b0
size
public int size()
{    return symbols.length;}
50b3cd9f9e6a25f0feb0f39fb1729b006675c6130cfc96c8b8fc85712a40b7de
findLabel
public int findLabel(String label)
{    if (label != null) {        for (int i = 0; i < labels.length; i++) {            if (label.equals(labels[i])) {                return i;            }        }    }    return -1;}
a324f69ce65546abdd11beb641d1bbfdcdd1c77c1728f8fe52ed667c68a52e23
flatten
public Alternative flatten(Map<Sequence, Sequence> map, Map<Sequence, List<Fixup>> map2)
{    Symbol[] ss = new Symbol[symbols.length];    for (int i = 0; i < ss.length; i++) {        ss[i] = symbols[i].flatten(map, map2);    }    return new Alternative(ss, labels);}
93076d5125c4acdc1b8b34077767013742db8996f02f5cc6e40e292c36ee8141
intCheckAction
public static IntCheckAction intCheckAction(int size)
{    return new IntCheckAction(size);}
61102d582498f5265fb3c678e01b4c0f3c57e24a570c98d2458bc6f8a27bfdae
enumAdjustAction
public static EnumAdjustAction enumAdjustAction(int rsymCount, Object[] adj)
{    return new EnumAdjustAction(rsymCount, adj);}
89833ddb26ea686a66eae4414507a875d1f90078e4b98b494636bd180c12af0b
writerUnionAction
public static WriterUnionAction writerUnionAction()
{    return new WriterUnionAction();}
6ab3e1af1298371a3136dc009b1db72e8ef6a0d971844070f8b70887d9981517
flatten
public ResolvingAction flatten(Map<Sequence, Sequence> map, Map<Sequence, List<Fixup>> map2)
{    return new ResolvingAction(writer.flatten(map, map2), reader.flatten(map, map2));}
b5fdae940b25ce1d62d9c64494abc796340228f4bb55ec42a11571e5bfcb7497
skipAction
public static SkipAction skipAction(Symbol symToSkip)
{    return new SkipAction(symToSkip);}
9f0e3be1d9c4e1e020bb75b85df0f7012ab5a5cbb0ff19d9ce3e499a715ac9f0
flatten
public SkipAction flatten(Map<Sequence, Sequence> map, Map<Sequence, List<Fixup>> map2)
{    return new SkipAction(symToSkip.flatten(map, map2));}
48163ee7fa4aa218433bbbf554e8553139578df17cd741def7c42db73793fb59
fieldAdjustAction
public static FieldAdjustAction fieldAdjustAction(int rindex, String fname, Set<String> aliases)
{    return new FieldAdjustAction(rindex, fname, aliases);}
df335a2363462289ee565225502461e2248d9c680b19eae51b6a99796ba14422
fieldOrderAction
public static FieldOrderAction fieldOrderAction(Schema.Field[] fields)
{    return new FieldOrderAction(fields);}
11ef17fea7eec1a21bb6a8e390c867b20db0f6126a5c5aba8f4214ef9575fcd3
defaultStartAction
public static DefaultStartAction defaultStartAction(byte[] contents)
{    return new DefaultStartAction(contents);}
0a1e46162c20f2a44985e230a0ebb16e0e3f0dd996bedd7d3c039afe0276fe93
unionAdjustAction
public static UnionAdjustAction unionAdjustAction(int rindex, Symbol sym)
{    return new UnionAdjustAction(rindex, sym);}
a44885a8b02511cad81fe5c1d4030054094b24d58d76b7af5da7bae327d70721
flatten
public UnionAdjustAction flatten(Map<Sequence, Sequence> map, Map<Sequence, List<Fixup>> map2)
{    return new UnionAdjustAction(rindex, symToParse.flatten(map, map2));}
476bd31543cc2c4115fbd61277d56d02b3cda58e36e6d753d2b2c2d3e7efbd41
enumLabelsAction
public static EnumLabelsAction enumLabelsAction(List<String> symbols)
{    return new EnumLabelsAction(symbols);}
d59a19394f697fa1425961526b69b9be8a283ff9212e426fdd25ead1fc126e36
getLabel
public String getLabel(int n)
{    return symbols.get(n);}
7d2f5dd9edf0638d0d3fab2535cad34f814254df654f4fc5e37fa9ab2ede9302
findLabel
public int findLabel(String l)
{    if (l != null) {        for (int i = 0; i < symbols.size(); i++) {            if (l.equals(symbols.get(i))) {                return i;            }        }    }    return -1;}
791e770fb93e47bbeda4cdaeb78bde31e339ebc906a1796ee4cbecbb221a3106
generate
public Symbol generate(Schema schema)
{    return Symbol.root(generate(schema, new HashMap<>()));}
b5da8291a417a71b776dac069759645db7a862fe740a3bf06534d58a5fe539f4
generate
public Symbol generate(Schema sc, Map<LitS, Symbol> seen)
{    switch(sc.getType()) {        case NULL:            return Symbol.NULL;        case BOOLEAN:            return Symbol.BOOLEAN;        case INT:            return Symbol.INT;        case LONG:            return Symbol.LONG;        case FLOAT:            return Symbol.FLOAT;        case DOUBLE:            return Symbol.DOUBLE;        case STRING:            return Symbol.STRING;        case BYTES:            return Symbol.BYTES;        case FIXED:            return Symbol.seq(Symbol.intCheckAction(sc.getFixedSize()), Symbol.FIXED);        case ENUM:            return Symbol.seq(Symbol.intCheckAction(sc.getEnumSymbols().size()), Symbol.ENUM);        case ARRAY:            return Symbol.seq(Symbol.repeat(Symbol.ARRAY_END, generate(sc.getElementType(), seen)), Symbol.ARRAY_START);        case MAP:            return Symbol.seq(Symbol.repeat(Symbol.MAP_END, generate(sc.getValueType(), seen), Symbol.STRING), Symbol.MAP_START);        case RECORD:            {                LitS wsc = new LitS(sc);                Symbol rresult = seen.get(wsc);                if (rresult == null) {                    Symbol[] production = new Symbol[sc.getFields().size()];                    /**                     * We construct a symbol without filling the array. Please see                     * {@link Symbol#production} for the reason.                     */                    rresult = Symbol.seq(production);                    seen.put(wsc, rresult);                    int i = production.length;                    for (Field f : sc.getFields()) {                        production[--i] = generate(f.schema(), seen);                    }                }                return rresult;            }        case UNION:            List<Schema> subs = sc.getTypes();            Symbol[] symbols = new Symbol[subs.size()];            String[] labels = new String[subs.size()];            int i = 0;            for (Schema b : sc.getTypes()) {                symbols[i] = generate(b, seen);                labels[i] = b.getFullName();                i++;            }            return Symbol.seq(Symbol.alt(symbols, labels), Symbol.UNION);        default:            throw new RuntimeException("Unexpected schema type");    }}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (!(o instanceof LitS))        return false;    return actual.equals(((LitS) o).actual);}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return actual.hashCode();}
a045e8e72e21420716c7873acb642cfc67af1cf78ea0e447f39261c81bb2bfab
skipAction
public void skipAction() throws IOException
{    parser.popSymbol();}
85f34ec69d9dde422e3cb967a0130b1e567d93d590f526f8134ed1bbcb489abe
skipTopSymbol
public void skipTopSymbol() throws IOException
{    Symbol top = parser.topSymbol();    if (top == Symbol.NULL) {        readNull();    }    if (top == Symbol.BOOLEAN) {        readBoolean();    } else if (top == Symbol.INT) {        readInt();    } else if (top == Symbol.LONG) {        readLong();    } else if (top == Symbol.FLOAT) {        readFloat();    } else if (top == Symbol.DOUBLE) {        readDouble();    } else if (top == Symbol.STRING) {        skipString();    } else if (top == Symbol.BYTES) {        skipBytes();    } else if (top == Symbol.ENUM) {        readEnum();    } else if (top == Symbol.FIXED) {        skipFixed();    } else if (top == Symbol.UNION) {        readIndex();    } else if (top == Symbol.ARRAY_START) {        skipArray();    } else if (top == Symbol.MAP_START) {        skipMap();    }}
b85783ea95d3093dd3e304d9bd3da87a2a232aaf24ea3f4113e86bf54caa8ad5
setItemCount
public void setItemCount(long itemCount) throws IOException
{    if (counts[pos] != 0) {        throw new AvroTypeException("Incorrect number of items written. " + counts[pos] + " more required.");    }    counts[pos] = itemCount;}
bed0009bb8139bc1ffb6ee9ad42162880141e39749c278e1724abb291a79cd42
startItem
public void startItem() throws IOException
{    counts[pos]--;}
7046d295dbba666cdffb03332b8f945246f4b7678576b9bd9a52f2410134107c
push
protected final void push()
{    if (++pos == counts.length) {        counts = Arrays.copyOf(counts, pos + 10);    }    counts[pos] = 0;}
541ff64b04c99d0d0f2b63c3a26e97ceb3d662b5188dc2070592e9741f98a544
pop
protected final void pop()
{    if (counts[pos] != 0) {        throw new AvroTypeException("Incorrect number of items written. " + counts[pos] + " more required.");    }    pos--;}
abaee5469d3f7bc2d5d2545c48f3daaa3d52ff817935a687fbee06912a650711
depth
protected final int depth()
{    return pos;}
5db7a34b623660686b2ceadb74ea975a0e0f8275029925cfdfdd03add6855aac
resolve
public static Object resolve(Schema writer, Schema reader) throws IOException
{    if (null == writer) {        throw new NullPointerException("writer cannot be null!");    }    if (null == reader) {        throw new NullPointerException("reader cannot be null!");    }    return new ResolvingGrammarGenerator().generate(writer, reader);}
35fbad8a190d4e32f1ea045769bc84e89a0f5864401116c1e26a403ce0b70f03
readFieldOrder
public final Schema.Field[] readFieldOrder() throws IOException
{    return ((Symbol.FieldOrderAction) parser.advance(Symbol.FIELD_ACTION)).fields;}
c956d3a6ef888adec5d5d04df2810cb5371bcc0e6efc091a570e115642dfc2fc
readFieldOrderIfDiff
public final Schema.Field[] readFieldOrderIfDiff() throws IOException
{    Symbol.FieldOrderAction top = (Symbol.FieldOrderAction) parser.advance(Symbol.FIELD_ACTION);    return (top.noReorder ? null : top.fields);}
216c709caa30259bc2ffd3dd8e6866b91da4471d89ece857cf840338d672f413
drain
public final void drain() throws IOException
{    parser.processImplicitActions();}
b6042ee68b2b47bac163d020b1d36c009b0f5b2b9d1a110e94e722663331fdf1
readLong
public long readLong() throws IOException
{    Symbol actual = parser.advance(Symbol.LONG);    if (actual == Symbol.INT) {        return in.readInt();    } else if (actual == Symbol.DOUBLE) {        return (long) in.readDouble();    } else {        assert actual == Symbol.LONG;        return in.readLong();    }}
3a29df2e279a1aa87799d508d3c09fea77ff7a4a1d2b413b32851226858ddce4
readFloat
public float readFloat() throws IOException
{    Symbol actual = parser.advance(Symbol.FLOAT);    if (actual == Symbol.INT) {        return (float) in.readInt();    } else if (actual == Symbol.LONG) {        return (float) in.readLong();    } else {        assert actual == Symbol.FLOAT;        return in.readFloat();    }}
5c17280cb2bd5e36b11f2e528a4a0334e3401e73556b4cd475f437cbff7261e1
readDouble
public double readDouble() throws IOException
{    Symbol actual = parser.advance(Symbol.DOUBLE);    if (actual == Symbol.INT) {        return (double) in.readInt();    } else if (actual == Symbol.LONG) {        return (double) in.readLong();    } else if (actual == Symbol.FLOAT) {        return (double) in.readFloat();    } else {        assert actual == Symbol.DOUBLE;        return in.readDouble();    }}
c053fcdbfc387a7ac67d44a07f524f8f2ea428c07c8e3590f0ed50bdc4aff483
readString
public Utf8 readString(Utf8 old) throws IOException
{    Symbol actual = parser.advance(Symbol.STRING);    if (actual == Symbol.BYTES) {        return new Utf8(in.readBytes(null).array());    } else {        assert actual == Symbol.STRING;        return in.readString(old);    }}
ef9970bf7628dc4396fc3849d6482ac8a961658c0482c2176ac2ba144c6112c6
readString
public String readString() throws IOException
{    Symbol actual = parser.advance(Symbol.STRING);    if (actual == Symbol.BYTES) {        return new String(in.readBytes(null).array(), StandardCharsets.UTF_8);    } else {        assert actual == Symbol.STRING;        return in.readString();    }}
382ea2955da9cd92c1638ec68af3df3645c63648bd3c7436582fc6d114d32dc3
skipString
public void skipString() throws IOException
{    Symbol actual = parser.advance(Symbol.STRING);    if (actual == Symbol.BYTES) {        in.skipBytes();    } else {        assert actual == Symbol.STRING;        in.skipString();    }}
3f9351d2d96b71b9ade6333ab2de3b2fedb54eccbebc9ac546b7000019518e0f
readBytes
public ByteBuffer readBytes(ByteBuffer old) throws IOException
{    Symbol actual = parser.advance(Symbol.BYTES);    if (actual == Symbol.STRING) {        Utf8 s = in.readString(null);        return ByteBuffer.wrap(s.getBytes(), 0, s.getByteLength());    } else {        assert actual == Symbol.BYTES;        return in.readBytes(old);    }}
2b7cdc89689872436aab53b6467b336e2c628ced0f6e4bbfc31fb05f7b33fc9c
skipBytes
public void skipBytes() throws IOException
{    Symbol actual = parser.advance(Symbol.BYTES);    if (actual == Symbol.STRING) {        in.skipString();    } else {        assert actual == Symbol.BYTES;        in.skipBytes();    }}
9374ccd890881cceb7e56edb9a895bc9db6fbbbe8b0c849cf1090cbf7493f44c
readEnum
public int readEnum() throws IOException
{    parser.advance(Symbol.ENUM);    Symbol.EnumAdjustAction top = (Symbol.EnumAdjustAction) parser.popSymbol();    int n = in.readEnum();    if (top.noAdjustments)        return n;    Object o = top.adjustments[n];    if (o instanceof Integer) {        return (Integer) o;    } else {        throw new AvroTypeException((String) o);    }}
ed45fee8aef2b75e580e16f8fd6df1adc125a82cfee5ebc3632541573629672c
readIndex
public int readIndex() throws IOException
{    parser.advance(Symbol.UNION);    Symbol top = parser.popSymbol();    int result;    if (top instanceof Symbol.UnionAdjustAction) {        result = ((Symbol.UnionAdjustAction) top).rindex;        top = ((Symbol.UnionAdjustAction) top).symToParse;    } else {        result = in.readIndex();        top = ((Symbol.Alternative) top).getSymbol(result);    }    parser.pushSymbol(top);    return result;}
4bc406c880da45c1b625fe343f923d7798a5cc94ccbcc02295ee6611a8cb47e2
doAction
public Symbol doAction(Symbol input, Symbol top) throws IOException
{    if (top instanceof Symbol.FieldOrderAction) {        return input == Symbol.FIELD_ACTION ? top : null;    }    if (top instanceof Symbol.ResolvingAction) {        Symbol.ResolvingAction t = (Symbol.ResolvingAction) top;        if (t.reader != input) {            throw new AvroTypeException("Found " + t.reader + " while looking for " + input);        } else {            return t.writer;        }    } else if (top instanceof Symbol.SkipAction) {        Symbol symToSkip = ((Symbol.SkipAction) top).symToSkip;        parser.skipSymbol(symToSkip);    } else if (top instanceof Symbol.WriterUnionAction) {        Symbol.Alternative branches = (Symbol.Alternative) parser.popSymbol();        parser.pushSymbol(branches.getSymbol(in.readIndex()));    } else if (top instanceof Symbol.ErrorAction) {        throw new AvroTypeException(((Symbol.ErrorAction) top).msg);    } else if (top instanceof Symbol.DefaultStartAction) {        Symbol.DefaultStartAction dsa = (Symbol.DefaultStartAction) top;        backup = in;        in = DecoderFactory.get().binaryDecoder(dsa.contents, null);    } else if (top == Symbol.DEFAULT_END_ACTION) {        in = backup;    } else {        throw new AvroTypeException("Unknown action: " + top);    }    return null;}
a045e8e72e21420716c7873acb642cfc67af1cf78ea0e447f39261c81bb2bfab
skipAction
public void skipAction() throws IOException
{    Symbol top = parser.popSymbol();    if (top instanceof Symbol.ResolvingAction) {        parser.pushSymbol(((Symbol.ResolvingAction) top).writer);    } else if (top instanceof Symbol.SkipAction) {        parser.pushSymbol(((Symbol.SkipAction) top).symToSkip);    } else if (top instanceof Symbol.WriterUnionAction) {        Symbol.Alternative branches = (Symbol.Alternative) parser.popSymbol();        parser.pushSymbol(branches.getSymbol(in.readIndex()));    } else if (top instanceof Symbol.ErrorAction) {        throw new AvroTypeException(((Symbol.ErrorAction) top).msg);    } else if (top instanceof Symbol.DefaultStartAction) {        Symbol.DefaultStartAction dsa = (Symbol.DefaultStartAction) top;        backup = in;        in = DecoderFactory.get().binaryDecoder(dsa.contents, null);    } else if (top == Symbol.DEFAULT_END_ACTION) {        in = backup;    }}
2487c7a0f2e07cbf9b8b1ead62cd7b79450a4b6f5ace1ece6f1b4b7fe64212b3
getSymbol
private static Symbol getSymbol(Schema schema)
{    if (null == schema) {        throw new NullPointerException("Schema cannot be null");    }    return new ValidatingGrammarGenerator().generate(schema);}
544e9aa43894632af9d19d7cd68b4a9684cc8de6f15b950558a7f853d81fdb8d
configure
public ValidatingDecoder configure(Decoder in) throws IOException
{    this.parser.reset();    this.in = in;    return this;}
79ed759dc329689cccee5da68f5c322be3893b5ca69e4b1bbe6fbd1d2e16f7a7
readNull
public void readNull() throws IOException
{    parser.advance(Symbol.NULL);    in.readNull();}
fbc49599759f8cdcf441295a1ef45ca6ee3d99e9d996d9533ab06d2378b36f10
readBoolean
public boolean readBoolean() throws IOException
{    parser.advance(Symbol.BOOLEAN);    return in.readBoolean();}
f236e7fb1e87c9b6c5be0f35fb6c4eb85b118d1b426358e70800a74f43350299
readInt
public int readInt() throws IOException
{    parser.advance(Symbol.INT);    return in.readInt();}
b6042ee68b2b47bac163d020b1d36c009b0f5b2b9d1a110e94e722663331fdf1
readLong
public long readLong() throws IOException
{    parser.advance(Symbol.LONG);    return in.readLong();}
3a29df2e279a1aa87799d508d3c09fea77ff7a4a1d2b413b32851226858ddce4
readFloat
public float readFloat() throws IOException
{    parser.advance(Symbol.FLOAT);    return in.readFloat();}
5c17280cb2bd5e36b11f2e528a4a0334e3401e73556b4cd475f437cbff7261e1
readDouble
public double readDouble() throws IOException
{    parser.advance(Symbol.DOUBLE);    return in.readDouble();}
c053fcdbfc387a7ac67d44a07f524f8f2ea428c07c8e3590f0ed50bdc4aff483
readString
public Utf8 readString(Utf8 old) throws IOException
{    parser.advance(Symbol.STRING);    return in.readString(old);}
ef9970bf7628dc4396fc3849d6482ac8a961658c0482c2176ac2ba144c6112c6
readString
public String readString() throws IOException
{    parser.advance(Symbol.STRING);    return in.readString();}
382ea2955da9cd92c1638ec68af3df3645c63648bd3c7436582fc6d114d32dc3
skipString
public void skipString() throws IOException
{    parser.advance(Symbol.STRING);    in.skipString();}
3f9351d2d96b71b9ade6333ab2de3b2fedb54eccbebc9ac546b7000019518e0f
readBytes
public ByteBuffer readBytes(ByteBuffer old) throws IOException
{    parser.advance(Symbol.BYTES);    return in.readBytes(old);}
2b7cdc89689872436aab53b6467b336e2c628ced0f6e4bbfc31fb05f7b33fc9c
skipBytes
public void skipBytes() throws IOException
{    parser.advance(Symbol.BYTES);    in.skipBytes();}
77aebccb2ddb0de2a2d63691201e8f7bf578eddf39f2b3338d56e2c2cedfe6e6
checkFixed
private void checkFixed(int size) throws IOException
{    parser.advance(Symbol.FIXED);    Symbol.IntCheckAction top = (Symbol.IntCheckAction) parser.popSymbol();    if (size != top.size) {        throw new AvroTypeException("Incorrect length for fixed binary: expected " + top.size + " but received " + size + " bytes.");    }}
e9fd530ed3f8f181f8b42a5f953bf9aa73fd331bc0c9033abf247cd28f51c99c
readFixed
public void readFixed(byte[] bytes, int start, int len) throws IOException
{    checkFixed(len);    in.readFixed(bytes, start, len);}
fd8d4a96aa39b53251c8c74a21c8896db0ba3c1b277095d249e5eb06c38e7ca7
skipFixed
public void skipFixed(int length) throws IOException
{    checkFixed(length);    in.skipFixed(length);}
92d9fba0ba2214219dfa0718f8afa4f53eb8efa1d73bb030d33c52b54ebefaad
skipFixed
protected void skipFixed() throws IOException
{    parser.advance(Symbol.FIXED);    Symbol.IntCheckAction top = (Symbol.IntCheckAction) parser.popSymbol();    in.skipFixed(top.size);}
9374ccd890881cceb7e56edb9a895bc9db6fbbbe8b0c849cf1090cbf7493f44c
readEnum
public int readEnum() throws IOException
{    parser.advance(Symbol.ENUM);    Symbol.IntCheckAction top = (Symbol.IntCheckAction) parser.popSymbol();    int result = in.readEnum();    if (result < 0 || result >= top.size) {        throw new AvroTypeException("Enumeration out of range: max is " + top.size + " but received " + result);    }    return result;}
e6add0bc5e95e909949d20835efe8b60b03e5bcbc465b6ed385868efaa03433d
readArrayStart
public long readArrayStart() throws IOException
{    parser.advance(Symbol.ARRAY_START);    long result = in.readArrayStart();    if (result == 0) {        parser.advance(Symbol.ARRAY_END);    }    return result;}
b875ce5110599d9cbc3dee00e4aa55cb0a57d1a9573cbb258a671ce79c649910
arrayNext
public long arrayNext() throws IOException
{    parser.processTrailingImplicitActions();    long result = in.arrayNext();    if (result == 0) {        parser.advance(Symbol.ARRAY_END);    }    return result;}
50c9a94efe953551ebfe49b73eadd4db5a332ca0b3a3650f3336e996f5e88c7f
skipArray
public long skipArray() throws IOException
{    parser.advance(Symbol.ARRAY_START);    for (long c = in.skipArray(); c != 0; c = in.skipArray()) {        while (c-- > 0) {            parser.skipRepeater();        }    }    parser.advance(Symbol.ARRAY_END);    return 0;}
e6bc36a0bc14db0154507596b987d5b0b1c5ad572a5ef56fc85c9dc13e23f964
readMapStart
public long readMapStart() throws IOException
{    parser.advance(Symbol.MAP_START);    long result = in.readMapStart();    if (result == 0) {        parser.advance(Symbol.MAP_END);    }    return result;}
cf2dd4f4b7450866b8f7c0b58e3817a1f8aad0f3978d831c76efd87c84fd4dcd
mapNext
public long mapNext() throws IOException
{    parser.processTrailingImplicitActions();    long result = in.mapNext();    if (result == 0) {        parser.advance(Symbol.MAP_END);    }    return result;}
d9353ecbd03723a8a9e9f6a886bfef387f4f65291d9de544d01d5d5502f78a27
skipMap
public long skipMap() throws IOException
{    parser.advance(Symbol.MAP_START);    for (long c = in.skipMap(); c != 0; c = in.skipMap()) {        while (c-- > 0) {            parser.skipRepeater();        }    }    parser.advance(Symbol.MAP_END);    return 0;}
ed45fee8aef2b75e580e16f8fd6df1adc125a82cfee5ebc3632541573629672c
readIndex
public int readIndex() throws IOException
{    parser.advance(Symbol.UNION);    Symbol.Alternative top = (Symbol.Alternative) parser.popSymbol();    int result = in.readIndex();    parser.pushSymbol(top.getSymbol(result));    return result;}
4bc406c880da45c1b625fe343f923d7798a5cc94ccbcc02295ee6611a8cb47e2
doAction
public Symbol doAction(Symbol input, Symbol top) throws IOException
{    return null;}
c3e67ec76f1b008887f1caba645a2614900cde6e477acca1bc3ecc36bf357fcf
flush
public void flush() throws IOException
{    out.flush();}
833f2ea6300c2d38be025f608db3a3c60b3e142907a36ccf5f372faf0ea4eafe
configure
public ValidatingEncoder configure(Encoder encoder)
{    this.parser.reset();    this.out = encoder;    return this;}
07c3270fe1b73532e66eb6f555ff312e3202b8435cf61382c5aa1c0dc4ce9a22
writeNull
public void writeNull() throws IOException
{    parser.advance(Symbol.NULL);    out.writeNull();}
9d2c4a8e17244c43f6c9a688d920b81cfa21c5d72f09e261b40e4539894a93a4
writeBoolean
public void writeBoolean(boolean b) throws IOException
{    parser.advance(Symbol.BOOLEAN);    out.writeBoolean(b);}
3d8eb176faa04ef3aa5f28bd1c308daf64cdee2071894b3447ade0d0891ac95b
writeInt
public void writeInt(int n) throws IOException
{    parser.advance(Symbol.INT);    out.writeInt(n);}
9d5f02c473bb90aaa95e11d7e93625ba8050b2ae1b4b94e45331333ecc81fb92
writeLong
public void writeLong(long n) throws IOException
{    parser.advance(Symbol.LONG);    out.writeLong(n);}
485832ef5d131a3779da1c259796c40decbe270ca77fd7c3bd67453210649270
writeFloat
public void writeFloat(float f) throws IOException
{    parser.advance(Symbol.FLOAT);    out.writeFloat(f);}
b0e7b254d45c2210c8fda5ed2caaef6ca76fec51fb5d6a536add22a8a39ae5e9
writeDouble
public void writeDouble(double d) throws IOException
{    parser.advance(Symbol.DOUBLE);    out.writeDouble(d);}
34bdbb4029a48cb89270af40e256732c5b672fb11b54336d3f7efc90b7df5ab2
writeString
public void writeString(Utf8 utf8) throws IOException
{    parser.advance(Symbol.STRING);    out.writeString(utf8);}
be522bdc069e00fedad1d530e53eaeeecbe14ec57a058d6c1eb3025c7dcdd5fa
writeString
public void writeString(String str) throws IOException
{    parser.advance(Symbol.STRING);    out.writeString(str);}
18d3303aacad3eafe0f36c97283482e7fff96820f5d43ca49e74c0c283209a58
writeString
public void writeString(CharSequence charSequence) throws IOException
{    parser.advance(Symbol.STRING);    out.writeString(charSequence);}
ef77a45285e12605fa0ac332653126204dbd8aeb25f392f6b9900d3df7110e24
writeBytes
public void writeBytes(ByteBuffer bytes) throws IOException
{    parser.advance(Symbol.BYTES);    out.writeBytes(bytes);}
5686b3aa744852e31cb4ae1e0044e20a94ff28b7620cb59b1eb1a47c8ef69565
writeBytes
public void writeBytes(byte[] bytes, int start, int len) throws IOException
{    parser.advance(Symbol.BYTES);    out.writeBytes(bytes, start, len);}
23ad82833b3f2bd0c47b14f7e1f984068754ba8fea96d9cf72a5dc7b0df27779
writeFixed
public void writeFixed(byte[] bytes, int start, int len) throws IOException
{    parser.advance(Symbol.FIXED);    Symbol.IntCheckAction top = (Symbol.IntCheckAction) parser.popSymbol();    if (len != top.size) {        throw new AvroTypeException("Incorrect length for fixed binary: expected " + top.size + " but received " + len + " bytes.");    }    out.writeFixed(bytes, start, len);}
9c2c1c74b0f6ed303f5a2809268552b5b4c2121bcc71b39f52e22e9cfb232cc6
writeEnum
public void writeEnum(int e) throws IOException
{    parser.advance(Symbol.ENUM);    Symbol.IntCheckAction top = (Symbol.IntCheckAction) parser.popSymbol();    if (e < 0 || e >= top.size) {        throw new AvroTypeException("Enumeration out of range: max is " + top.size + " but received " + e);    }    out.writeEnum(e);}
397b6502072ea3a1ac72a07bee65a462902e7e78c46d167fac7946bd2eee93fb
writeArrayStart
public void writeArrayStart() throws IOException
{    push();    parser.advance(Symbol.ARRAY_START);    out.writeArrayStart();}
ed98fbed6a1d613e764dba378ccb5b19a641d3ecbc93a5f3d50f0010442034de
writeArrayEnd
public void writeArrayEnd() throws IOException
{    parser.advance(Symbol.ARRAY_END);    out.writeArrayEnd();    pop();}
06a13fe57e24d2460afd3389759c84bd57ee09e14710364b77d081005edff6eb
writeMapStart
public void writeMapStart() throws IOException
{    push();    parser.advance(Symbol.MAP_START);    out.writeMapStart();}
44f6ecf1e519c8992d2b321f4cf40cfe49a47d580d58e41fd28fe573a1ea47c4
writeMapEnd
public void writeMapEnd() throws IOException
{    parser.advance(Symbol.MAP_END);    out.writeMapEnd();    pop();}
b85783ea95d3093dd3e304d9bd3da87a2a232aaf24ea3f4113e86bf54caa8ad5
setItemCount
public void setItemCount(long itemCount) throws IOException
{    super.setItemCount(itemCount);    out.setItemCount(itemCount);}
bed0009bb8139bc1ffb6ee9ad42162880141e39749c278e1724abb291a79cd42
startItem
public void startItem() throws IOException
{    super.startItem();    out.startItem();}
5e98b24f5d4da4c35f9e7f9247f0fdca1daf147afc1971fff5a25067084cf67d
writeIndex
public void writeIndex(int unionIndex) throws IOException
{    parser.advance(Symbol.UNION);    Symbol.Alternative top = (Symbol.Alternative) parser.popSymbol();    parser.pushSymbol(top.getSymbol(unionIndex));    out.writeIndex(unionIndex);}
4bc406c880da45c1b625fe343f923d7798a5cc94ccbcc02295ee6611a8cb47e2
doAction
public Symbol doAction(Symbol input, Symbol top) throws IOException
{    return null;}
543a2f2b63783bfff1e31d23fb1c6a37d08f343318910aada1f02e34acfe3c51
addProp
protected void addProp(JsonProperties props, String name, JsonNode value)
{    props.addProp(name, value);}
6ff7c6f6a66e22b7b382606c46835ddb156b23b5e13ae6c848e45aae3ae89901
putIfAbsent
public JsonNode putIfAbsent(String key, JsonNode value)
{    JsonNode r = super.putIfAbsent(key, value);    if (r == null) {        propOrder.add(new MapEntry<>(key, value));    }    return r;}
68fc516355f7507bc80331466d93fb360abbbcc6322a61f22bd5a69d321ef6dd
put
public JsonNode put(String key, JsonNode value)
{    return putIfAbsent(key, value);}
abc70ec7394d4340ec8e20d00daa9fadef87e8f6bc4dc276dab5e4299ad39acc
entrySet
public Set<Map.Entry<String, JsonNode>> entrySet()
{    return new AbstractSet<Map.Entry<String, JsonNode>>() {        @Override        public Iterator<Map.Entry<String, JsonNode>> iterator() {            return new Iterator<Map.Entry<String, JsonNode>>() {                Iterator<MapEntry<String, JsonNode>> it = propOrder.iterator();                @Override                public boolean hasNext() {                    return it.hasNext();                }                @Override                public java.util.Map.Entry<String, JsonNode> next() {                    return it.next();                }            };        }        @Override        public int size() {            return propOrder.size();        }    };}
ffb63430e1af455a633fe5e4da08dcfda4e831468eed036cb427bfac8c582255
iterator
public Iterator<Map.Entry<String, JsonNode>> iterator()
{    return new Iterator<Map.Entry<String, JsonNode>>() {        Iterator<MapEntry<String, JsonNode>> it = propOrder.iterator();        @Override        public boolean hasNext() {            return it.hasNext();        }        @Override        public java.util.Map.Entry<String, JsonNode> next() {            return it.next();        }    };}
d51e5f7450eca0a0f63da1a466189e262d053b84aa767ba3be5cea740af7251b
hasNext
public boolean hasNext()
{    return it.hasNext();}
bdfd4e19dfd2ffbd7684be40fad63ac790084fe9aaff20476f69fc11dcaf88c3
next
public java.util.Map.Entry<String, JsonNode> next()
{    return it.next();}
72ef1e59027007ffe0950edfd2670ad03bb65cd6463d5d1d282dfeb1750435b0
size
public int size()
{    return propOrder.size();}
9284740726b7b5bd5e42562eac9fcd317f7ba6df2e2893ea02dbb673547ef321
getProp
public String getProp(String name)
{    JsonNode value = getJsonProp(name);    return value != null && value.isTextual() ? value.textValue() : null;}
6808d86fc955459a8695168060e47a08c558b2ec4725e0797249cc3dc4dd563c
getJsonProp
private JsonNode getJsonProp(String name)
{    return props.get(name);}
4ccd4d020a28fcc3a834f9f29029b879112dbd700350ad4987afd566708fd034
getObjectProp
public Object getObjectProp(String name)
{    return JacksonUtils.toObject(props.get(name));}
7be3af9c1e6b6b7541a6237a7d09bd325457bd8e891e1b000a96d3692be536be
addProp
public void addProp(String name, String value)
{    addProp(name, TextNode.valueOf(value));}
82358048e1ba682db68ba1b1f55b2a8c018ccdab351fa9b502adf8709f592cf8
addProp
public void addProp(String name, Object value)
{    if (value instanceof JsonNode) {        addProp(name, (JsonNode) value);    } else {        addProp(name, JacksonUtils.toJsonNode(value));    }}
90a9688e40e9a1ef82e1a46661e3b012536dc3c55a2427ca882558261829aba0
putAll
public void putAll(JsonProperties np)
{    for (Map.Entry<? extends String, ? extends JsonNode> e : np.props.entrySet()) addProp(e.getKey(), e.getValue());}
179c9d8c263f285cf25ebcb5b9c055c14db037496188a9af1d00d8414863e395
addProp
private void addProp(String name, JsonNode value)
{    if (reserved.contains(name))        throw new AvroRuntimeException("Can't set reserved property: " + name);    if (value == null)        throw new AvroRuntimeException("Can't set a property to null: " + name);    JsonNode old = props.putIfAbsent(name, value);    if (old != null && !old.equals(value)) {        throw new AvroRuntimeException("Can't overwrite property: " + name);    }}
cc966fca91450591ed3e5ca30adbf93209a3b92761006725b314b3c35f9764fc
addAllProps
public void addAllProps(JsonProperties properties)
{    for (Entry<String, JsonNode> entry : properties.props.entrySet()) addProp(entry.getKey(), entry.getValue());}
0ca88504510d8c05abaef31f1f0add1f806d098bf2edec276be6eaaa91198305
getObjectProps
public Map<String, Object> getObjectProps()
{    Map<String, Object> result = new LinkedHashMap<>();    for (Map.Entry<String, JsonNode> e : props.entrySet()) result.put(e.getKey(), JacksonUtils.toObject(e.getValue()));    return Collections.unmodifiableMap(result);}
843e92bd46685455ad81f12e0a0794a9594e350fea188535ff6b206aee7c536c
writeProps
 void writeProps(JsonGenerator gen) throws IOException
{    for (Map.Entry<String, JsonNode> e : props.entrySet()) gen.writeObjectField(e.getKey(), e.getValue());}
154b2ffa3ba10fdfdf64e53baf1cdc9e26521f5b273eedbb070e9e1edbd9bac0
propsHashCode
 int propsHashCode()
{    return props.hashCode();}
e9230431ccbbc50af09d35a28a425a87cf62cb42bd29c8bbdc92b74238d4d221
propsEqual
 boolean propsEqual(JsonProperties np)
{    return props.equals(np.props);}
fe04dfab41a8dfba2a17a715706cfb262f7335ac07691d2b074be157c01c903e
hasProps
public boolean hasProps()
{    return !props.isEmpty();}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return name;}
289f1597a90218f911e45f224f3873845000475f617e37a65359e3bd3730e2bb
addToSchema
public Schema addToSchema(Schema schema)
{    validate(schema);    schema.addProp(LOGICAL_TYPE_PROP, name);    schema.setLogicalType(this);    return schema;}
9c8753af4248bc6cfdffb49d546cd09255922836141b423436c52fa0aa74ca10
validate
public void validate(Schema schema)
{    for (String incompatible : INCOMPATIBLE_PROPS) {        if (schema.getProp(incompatible) != null) {            throw new IllegalArgumentException(LOGICAL_TYPE_PROP + " cannot be used with " + incompatible);        }    }}
2494f72a8fa8019e6f2f8b3fce9f8c885554adb1d86ca6830be0736ef55ccc20
register
public static void register(String logicalTypeName, LogicalTypeFactory factory)
{    if (logicalTypeName == null) {        throw new NullPointerException("Invalid logical type name: null");    }    if (factory == null) {        throw new NullPointerException("Invalid logical type factory: null");    }    REGISTERED_TYPES.put(logicalTypeName, factory);}
97f7ce487df2583cacc1443c48eae79ca1b30319e11bca163f2c4e7f3a5bc26f
fromSchema
public static LogicalType fromSchema(Schema schema)
{    return fromSchemaImpl(schema, true);}
ca3885ffa880a9bb9c7b3d7d30f100bcc70a1cf5e78b05d4edb1e7cb59d72f64
fromSchemaIgnoreInvalid
public static LogicalType fromSchemaIgnoreInvalid(Schema schema)
{    return fromSchemaImpl(schema, false);}
d8c4a1ceb7cead382c8baaca2a6aea384a17643a13f0b578c40789d49048ba9f
fromSchemaImpl
private static LogicalType fromSchemaImpl(Schema schema, boolean throwErrors)
{    final LogicalType logicalType;    final String typeName = schema.getProp(LogicalType.LOGICAL_TYPE_PROP);    if (typeName == null) {        return null;    }    try {        switch(typeName) {            case TIMESTAMP_MILLIS:                logicalType = TIMESTAMP_MILLIS_TYPE;                break;            case DECIMAL:                logicalType = new Decimal(schema);                break;            case UUID:                logicalType = UUID_TYPE;                break;            case DATE:                logicalType = DATE_TYPE;                break;            case TIMESTAMP_MICROS:                logicalType = TIMESTAMP_MICROS_TYPE;                break;            case TIME_MILLIS:                logicalType = TIME_MILLIS_TYPE;                break;            case TIME_MICROS:                logicalType = TIME_MICROS_TYPE;                break;            case LOCAL_TIMESTAMP_MICROS:                logicalType = LOCAL_TIMESTAMP_MICROS_TYPE;                break;            case LOCAL_TIMESTAMP_MILLIS:                logicalType = LOCAL_TIMESTAMP_MILLIS_TYPE;                break;            default:                final LogicalTypeFactory typeFactory = REGISTERED_TYPES.get(typeName);                if (typeFactory != null) {                    logicalType = REGISTERED_TYPES.get(typeName).fromSchema(schema);                } else {                    logicalType = null;                }                break;        }                if (logicalType != null) {            logicalType.validate(schema);        }    } catch (RuntimeException e) {        LOG.debug("Invalid logical type found", e);        if (throwErrors) {            throw e;        }        LOG.warn("Ignoring invalid logical type for name: {}", typeName);                return null;    }    return logicalType;}
56e1508c0ced206e12a54836cee26d3a551ad894bfa27bb9b50d0023bf5a2c6d
decimal
public static Decimal decimal(int precision)
{    return decimal(precision, 0);}
97938c28a25dae4bb3e188860328ef07be12f602e3bc8b243c4a1969e7d998d5
decimal
public static Decimal decimal(int precision, int scale)
{    return new Decimal(precision, scale);}
515e9161a6deaf1425e672fb4a6b97a8596338a9ec93fbc002604450fc29a65a
uuid
public static LogicalType uuid()
{    return UUID_TYPE;}
f27ad5a44317771846dc4d1caf79e82283c720fc94fe76c0eade4150696a0f0f
date
public static Date date()
{    return DATE_TYPE;}
d5bff709be8d52ef5241c26f8a0273923c7610753f804b8fe2f640560a0d9bb0
timeMillis
public static TimeMillis timeMillis()
{    return TIME_MILLIS_TYPE;}
e48b98aeb865c57ebfc18b4e492ca385ccc68ea1686502257d3dd6a74e6a4676
timeMicros
public static TimeMicros timeMicros()
{    return TIME_MICROS_TYPE;}
31ff9f93f6dbf758cbf9a833af5743065c401f05fc192d0a1626fa34382129ef
timestampMillis
public static TimestampMillis timestampMillis()
{    return TIMESTAMP_MILLIS_TYPE;}
b1ae4358c481686a65492b31a8081f5cda0bb42cc3723b93bad28e5282dd06df
timestampMicros
public static TimestampMicros timestampMicros()
{    return TIMESTAMP_MICROS_TYPE;}
ee82617aae3236b686eae2d32e6639527e014c637fede6546946e1f497071f2f
localTimestampMillis
public static LocalTimestampMillis localTimestampMillis()
{    return LOCAL_TIMESTAMP_MILLIS_TYPE;}
35d9c4e34af5d44f9efa797eea23aba7524b517065390384c70aa93b27529466
localTimestampMicros
public static LocalTimestampMicros localTimestampMicros()
{    return LOCAL_TIMESTAMP_MICROS_TYPE;}
289f1597a90218f911e45f224f3873845000475f617e37a65359e3bd3730e2bb
addToSchema
public Schema addToSchema(Schema schema)
{    super.addToSchema(schema);    schema.addProp(PRECISION_PROP, precision);    schema.addProp(SCALE_PROP, scale);    return schema;}
04b0d6ce48769ecd57e9f98b18b0ae90ce26ff84d57caeb757b661ab95767ae9
getPrecision
public int getPrecision()
{    return precision;}
ea33ee7ee3f2a787129440e365474df599156f24ce9f2ea68dbbefd7f8f25d0a
getScale
public int getScale()
{    return scale;}
9c8753af4248bc6cfdffb49d546cd09255922836141b423436c52fa0aa74ca10
validate
public void validate(Schema schema)
{    super.validate(schema);        if (schema.getType() != Schema.Type.FIXED && schema.getType() != Schema.Type.BYTES) {        throw new IllegalArgumentException("Logical type decimal must be backed by fixed or bytes");    }    if (precision <= 0) {        throw new IllegalArgumentException("Invalid decimal precision: " + precision + " (must be positive)");    } else if (precision > maxPrecision(schema)) {        throw new IllegalArgumentException("fixed(" + schema.getFixedSize() + ") cannot store " + precision + " digits (max " + maxPrecision(schema) + ")");    }    if (scale < 0) {        throw new IllegalArgumentException("Invalid decimal scale: " + scale + " (must be positive)");    } else if (scale > precision) {        throw new IllegalArgumentException("Invalid decimal scale: " + scale + " (greater than precision: " + precision + ")");    }}
3e525550a28fc631f1aed0b2a05e4fff1657d0a3326fe01e97f0b71ddf3d8cd4
maxPrecision
private long maxPrecision(Schema schema)
{    if (schema.getType() == Schema.Type.BYTES) {                return Integer.MAX_VALUE;    } else if (schema.getType() == Schema.Type.FIXED) {        int size = schema.getFixedSize();        return         Math.round(Math.floor(        Math.log10(        Math.pow(2, 8 * size - 1) - 1)));    } else {                return 0;    }}
ce628d5bb61441cb428fb6fd39ac6ae522f7da4e407b8b8bf29862765f596599
hasProperty
private boolean hasProperty(Schema schema, String name)
{    return (schema.getObjectProp(name) != null);}
0a75aff03b60c457c889f1c4aec7f2f5f2086dad3cc4c3fd26415a56b2587091
getInt
private int getInt(Schema schema, String name)
{    Object obj = schema.getObjectProp(name);    if (obj instanceof Integer) {        return (Integer) obj;    }    throw new IllegalArgumentException("Expected int " + name + ": " + (obj == null ? "null" : obj + ":" + obj.getClass().getSimpleName()));}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (this == o)        return true;    if (o == null || getClass() != o.getClass())        return false;    Decimal decimal = (Decimal) o;    if (precision != decimal.precision)        return false;    return scale == decimal.scale;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    int result = precision;    result = 31 * result + scale;    return result;}
9c8753af4248bc6cfdffb49d546cd09255922836141b423436c52fa0aa74ca10
validate
public void validate(Schema schema)
{    super.validate(schema);    if (schema.getType() != Schema.Type.INT) {        throw new IllegalArgumentException("Date can only be used with an underlying int type");    }}
9c8753af4248bc6cfdffb49d546cd09255922836141b423436c52fa0aa74ca10
validate
public void validate(Schema schema)
{    super.validate(schema);    if (schema.getType() != Schema.Type.INT) {        throw new IllegalArgumentException("Time (millis) can only be used with an underlying int type");    }}
9c8753af4248bc6cfdffb49d546cd09255922836141b423436c52fa0aa74ca10
validate
public void validate(Schema schema)
{    super.validate(schema);    if (schema.getType() != Schema.Type.LONG) {        throw new IllegalArgumentException("Time (micros) can only be used with an underlying long type");    }}
9c8753af4248bc6cfdffb49d546cd09255922836141b423436c52fa0aa74ca10
validate
public void validate(Schema schema)
{    super.validate(schema);    if (schema.getType() != Schema.Type.LONG) {        throw new IllegalArgumentException("Timestamp (millis) can only be used with an underlying long type");    }}
9c8753af4248bc6cfdffb49d546cd09255922836141b423436c52fa0aa74ca10
validate
public void validate(Schema schema)
{    super.validate(schema);    if (schema.getType() != Schema.Type.LONG) {        throw new IllegalArgumentException("Timestamp (micros) can only be used with an underlying long type");    }}
9c8753af4248bc6cfdffb49d546cd09255922836141b423436c52fa0aa74ca10
validate
public void validate(Schema schema)
{    super.validate(schema);    if (schema.getType() != Schema.Type.LONG) {        throw new IllegalArgumentException("Local timestamp (millis) can only be used with an underlying long type");    }}
9c8753af4248bc6cfdffb49d546cd09255922836141b423436c52fa0aa74ca10
validate
public void validate(Schema schema)
{    super.validate(schema);    if (schema.getType() != Schema.Type.LONG) {        throw new IllegalArgumentException("Local timestamp (micros) can only be used with an underlying long type");    }}
5f813cc62607bb1a9db7aeb70998fd0f4d09291b7b0062ebf5f5c3f80e44ad7b
addSchema
public void addSchema(Schema writeSchema)
{    long fp = SchemaNormalization.parsingFingerprint64(writeSchema);    final Schema actualReadSchema = this.readSchema != null ? this.readSchema : writeSchema;    codecByFingerprint.put(fp, new RawMessageDecoder<D>(model, writeSchema, actualReadSchema));}
a74aa2345473139edce463f3808532ded13d4cb30704de10f81a163f6cff2d8a
getDecoder
private RawMessageDecoder<D> getDecoder(long fp)
{    RawMessageDecoder<D> decoder = codecByFingerprint.get(fp);    if (decoder != null) {        return decoder;    }    if (resolver != null) {        Schema writeSchema = resolver.findByFingerprint(fp);        if (writeSchema != null) {            addSchema(writeSchema);            return codecByFingerprint.get(fp);        }    }    throw new MissingSchemaException("Cannot resolve schema for fingerprint: " + fp);}
36bafe7833d67d7d7ee13f8f2b11158c659cdb6c9c747343457f15d51e7252d3
decode
public D decode(InputStream stream, D reuse) throws IOException
{    byte[] header = HEADER_BUFFER.get();    try {        if (!readFully(stream, header)) {            throw new BadHeaderException("Not enough header bytes");        }    } catch (IOException e) {        throw new IOException("Failed to read header and fingerprint bytes", e);    }    if (BinaryMessageEncoder.V1_HEADER[0] != header[0] || BinaryMessageEncoder.V1_HEADER[1] != header[1]) {        throw new BadHeaderException(String.format("Unrecognized header bytes: 0x%02X 0x%02X", header[0], header[1]));    }    RawMessageDecoder<D> decoder = getDecoder(FP_BUFFER.get().getLong(2));    return decoder.decode(stream, reuse);}
206461944f65d8e759cc61b1008f11bfe2b4fe880786b13b397a899163758d35
readFully
private boolean readFully(InputStream stream, byte[] bytes) throws IOException
{    int pos = 0;    int bytesRead;    while ((bytes.length - pos) > 0 && (bytesRead = stream.read(bytes, pos, bytes.length - pos)) > 0) {        pos += bytesRead;    }    return (pos == bytes.length);}
346e76eb7478523cf1e703755e1a82eaeb965b8c2272c68da4a3bfca9b618fdd
encode
public ByteBuffer encode(D datum) throws IOException
{    return writeCodec.encode(datum);}
d649b5eacffefc2f9b695958086386da4836b50ef0c6c305aee436014bc9db9b
encode
public void encode(D datum, OutputStream stream) throws IOException
{    writeCodec.encode(datum, stream);}
d649b5eacffefc2f9b695958086386da4836b50ef0c6c305aee436014bc9db9b
encode
public void encode(D datum, OutputStream stream) throws IOException
{    stream.write(headerBytes);    super.encode(datum, stream);}
2d4b5e28088e8c522a0a9148e47c37c42789c12a880a0bf15d77b3ed352ef233
getWriteHeader
private static byte[] getWriteHeader(Schema schema)
{    try {        byte[] fp = SchemaNormalization.parsingFingerprint("CRC-64-AVRO", schema);        byte[] ret = new byte[V1_HEADER.length + fp.length];        System.arraycopy(V1_HEADER, 0, ret, 0, V1_HEADER.length);        System.arraycopy(fp, 0, ret, V1_HEADER.length, fp.length);        return ret;    } catch (NoSuchAlgorithmException e) {        throw new AvroRuntimeException(e);    }}
008f3314298bce5102d27aeb77d391c855bde834b618f009712356726948b1b5
decode
public D decode(InputStream stream) throws IOException
{    return decode(stream, null);}
39c256389984e68cd117748d7d0139e2c1248d042115858a60df4566c90ea533
decode
public D decode(ByteBuffer encoded) throws IOException
{    return decode(encoded, null);}
7df53475738d57a1a47e53364e1bd9770e11ff15b4ad8ee28490f355513558ef
decode
public D decode(byte[] encoded) throws IOException
{    return decode(encoded, null);}
22142b57e84f79d11b282344519b1dfc53b8d6c60565f590fdac8839dd970da7
decode
public D decode(ByteBuffer encoded, D reuse) throws IOException
{    ReusableByteBufferInputStream in = BYTE_BUFFER_IN.get();    in.setByteBuffer(encoded);    return decode(in, reuse);}
d752da4eae15a807d3abf30d0c3bbc3ff3dd6ae5ee95419a3e8923f3414a02fc
decode
public D decode(byte[] encoded, D reuse) throws IOException
{    ReusableByteArrayInputStream in = BYTE_ARRAY_IN.get();    in.setByteArray(encoded, 0, encoded.length);    return decode(in, reuse);}
807137f46d74b65c22c5b09b89c975af131685f98bbd0e1d99f595450d55dab6
decode
public D decode(InputStream stream, D reuse)
{    BinaryDecoder decoder = DecoderFactory.get().directBinaryDecoder(stream, DECODER.get());    DECODER.set(decoder);    try {        return reader.read(reuse, decoder);    } catch (IOException e) {        throw new AvroRuntimeException("Decoding datum failed", e);    }}
346e76eb7478523cf1e703755e1a82eaeb965b8c2272c68da4a3bfca9b618fdd
encode
public ByteBuffer encode(D datum) throws IOException
{    BufferOutputStream temp = TEMP.get();    temp.reset();    encode(datum, temp);    if (copyOutputBytes) {        return temp.toBufferWithCopy();    } else {        return temp.toBufferWithoutCopy();    }}
d649b5eacffefc2f9b695958086386da4836b50ef0c6c305aee436014bc9db9b
encode
public void encode(D datum, OutputStream stream) throws IOException
{    BinaryEncoder encoder = EncoderFactory.get().directBinaryEncoder(stream, ENCODER.get());    ENCODER.set(encoder);    writer.write(datum, encoder);    encoder.flush();}
2358c86679c1609c0a0ca2380be19dc8fd71d45bff74a7a8503b1c1b9b6427aa
toBufferWithoutCopy
 ByteBuffer toBufferWithoutCopy()
{    return ByteBuffer.wrap(buf, 0, count);}
65c39722d5f699650ef55bda4f3bbbc05227d8b74ffb006305f30a72824bd5c5
toBufferWithCopy
 ByteBuffer toBufferWithCopy()
{    return ByteBuffer.wrap(toByteArray());}
6ea3f4a8c39ec05fc83ca04553d9dff7549e88f09cf77656e4b81caa53e2c6a8
addSchema
public void addSchema(Schema schema)
{    long fp = SchemaNormalization.parsingFingerprint64(schema);    schemas.put(fp, schema);}
ff123e49dd193ff9b28ef0afcf4a4d75fe1a84ea3ce53e53024c53940af9aaed
findByFingerprint
public Schema findByFingerprint(long fingerprint)
{    return schemas.get(fingerprint);}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return name;}
c16687c6aa61c8ad136af8b8ef8329b908fd6743ccf87adbe7d38c75f8c8eac9
getRequest
public Schema getRequest()
{    return request;}
017b06b77f42ef0a1947578d9a2ab18ecf42aa735cc9fa270c01ebf2c09fc7ac
getResponse
public Schema getResponse()
{    return Schema.create(Schema.Type.NULL);}
48b5c2a3d84ca3c97d81fd9548d187b09be5ce687c3e2478e466775455465dfd
getErrors
public Schema getErrors()
{    return Schema.createUnion(new ArrayList<>());}
c3c7a57d4603ba8b55b8ab3f7e787b5a0c8af0f0321e9b44b20c41daad04c934
isOneWay
public boolean isOneWay()
{    return true;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    try {        StringWriter writer = new StringWriter();        JsonGenerator gen = Schema.FACTORY.createGenerator(writer);        toJson(gen);        gen.flush();        return writer.toString();    } catch (IOException e) {        throw new AvroRuntimeException(e);    }}
56f56fad0cfca57246a0a546ec87491ace8c0e7564800e1583c01f29c9e3892b
toJson
 void toJson(JsonGenerator gen) throws IOException
{    gen.writeStartObject();    if (doc != null)        gen.writeStringField("doc", doc);        writeProps(gen);    gen.writeFieldName("request");    request.fieldsToJson(types, gen);    toJson1(gen);    gen.writeEndObject();}
a773c296e3ec06d2e81362c082eae030d22de3b268311b9f947785e111982a53
toJson1
 void toJson1(JsonGenerator gen) throws IOException
{    gen.writeStringField("response", "null");    gen.writeBooleanField("one-way", true);}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (o == this)        return true;    if (!(o instanceof Message))        return false;    Message that = (Message) o;    return this.name.equals(that.name) && this.request.equals(that.request) && propsEqual(that);}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return name.hashCode() + request.hashCode() + propsHashCode();}
5999360274d9a522474168c24725752a4aae8dc4e9365423eb9f82baf4400700
getDoc
public String getDoc()
{    return doc;}
017b06b77f42ef0a1947578d9a2ab18ecf42aa735cc9fa270c01ebf2c09fc7ac
getResponse
public Schema getResponse()
{    return response;}
48b5c2a3d84ca3c97d81fd9548d187b09be5ce687c3e2478e466775455465dfd
getErrors
public Schema getErrors()
{    return errors;}
c3c7a57d4603ba8b55b8ab3f7e787b5a0c8af0f0321e9b44b20c41daad04c934
isOneWay
public boolean isOneWay()
{    return false;}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (!super.equals(o))        return false;    if (!(o instanceof TwoWayMessage))        return false;    TwoWayMessage that = (TwoWayMessage) o;    return this.response.equals(that.response) && this.errors.equals(that.errors);}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return super.hashCode() + response.hashCode() + errors.hashCode();}
a773c296e3ec06d2e81362c082eae030d22de3b268311b9f947785e111982a53
toJson1
 void toJson1(JsonGenerator gen) throws IOException
{    gen.writeFieldName("response");    response.toJson(types, gen);        List<Schema> errs = errors.getTypes();    if (errs.size() > 1) {        Schema union = Schema.createUnion(errs.subList(1, errs.size()));        gen.writeFieldName("errors");        union.toJson(types, gen);    }}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return name;}
4c9ff74e20a72d5f7b2e4ef2a83e03a78836fed625f24259c12254b95b6af94e
getNamespace
public String getNamespace()
{    return namespace;}
5999360274d9a522474168c24725752a4aae8dc4e9365423eb9f82baf4400700
getDoc
public String getDoc()
{    return doc;}
4007d3bc73ee15dd944082cea5a1967b71989444c321575b6d9bf9879bc27adb
getTypes
public Collection<Schema> getTypes()
{    return types.values();}
9640768509ad2bdf1184bbadec5429bfc3629341b803e2b2e08e1b0b657a5426
getType
public Schema getType(String name)
{    return types.get(name);}
618fc63bf6f6d9d07d215aa2cdc0c32acf45783497046cf618cda5abda9463e3
setTypes
public void setTypes(Collection<Schema> newTypes)
{    types = new Schema.Names();    for (Schema s : newTypes) types.add(s);}
3c1121d6294a20749f712561a1c294335d242e91e9ab5faea88fb6279f4de066
getMessages
public Map<String, Message> getMessages()
{    return messages;}
7d201fee80320a87a9c8883161042a53c58e2fb6d4e4fddf8f73ad856f4a789b
createMessage
public Message createMessage(String name, String doc, Schema request)
{    return new Message(name, doc, new LinkedHashMap<String, String>(), request);}
91ed0b2947aa4498029489a468391c594520f53775670dffd03d9996e49e6ceb
createMessage
public Message createMessage(Message m, Schema request)
{    return new Message(name, doc, m, request);}
3cd519d2c389a4ce9c613084a97054673479929b0dc1bb51edad727e67c655dd
createMessage
public Message createMessage(String name, String doc, JsonProperties propMap, Schema request)
{    return new Message(name, doc, propMap, request);}
25607d147204f8548fad082af3db8130df0c4f7bbe1b19c11d7f8bac778b7420
createMessage
public Message createMessage(String name, String doc, Map<String, ?> propMap, Schema request)
{    return new Message(name, doc, propMap, request);}
d48b10ce4c9cbf721098dc2967645c753d67d988521ef9840af57adf82c572ac
createMessage
public Message createMessage(String name, String doc, Schema request, Schema response, Schema errors)
{    return new TwoWayMessage(name, doc, new LinkedHashMap<String, String>(), request, response, errors);}
57f0cdb60b8a7e00f95bc8d7605f7a1ecc683090cfd60b5fd3f73a17c0d7097f
createMessage
public Message createMessage(Message m, Schema request, Schema response, Schema errors)
{    return new TwoWayMessage(m.getName(), m.getDoc(), m, request, response, errors);}
4eb1c026bdbd07efeefa13115c33e93acba7229a63eed6c582bc099561f3d67f
createMessage
public Message createMessage(String name, String doc, JsonProperties propMap, Schema request, Schema response, Schema errors)
{    return new TwoWayMessage(name, doc, propMap, request, response, errors);}
aac7686b186372403029b8d16334590dc4ec35d209c9fb782d5e09338a35deb4
createMessage
public Message createMessage(String name, String doc, Map<String, ?> propMap, Schema request, Schema response, Schema errors)
{    return new TwoWayMessage(name, doc, propMap, request, response, errors);}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (o == this)        return true;    if (!(o instanceof Protocol))        return false;    Protocol that = (Protocol) o;    return this.name.equals(that.name) && this.namespace.equals(that.namespace) && this.types.equals(that.types) && this.messages.equals(that.messages) && this.propsEqual(that);}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return name.hashCode() + namespace.hashCode() + types.hashCode() + messages.hashCode() + propsHashCode();}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return toString(false);}
f11bbdaa9e14a22c2e415a843d09db39d07d2ccd758940db7fbe0bb1f0f385b7
toString
public String toString(boolean pretty)
{    try {        StringWriter writer = new StringWriter();        JsonGenerator gen = Schema.FACTORY.createGenerator(writer);        if (pretty)            gen.useDefaultPrettyPrinter();        toJson(gen);        gen.flush();        return writer.toString();    } catch (IOException e) {        throw new AvroRuntimeException(e);    }}
56f56fad0cfca57246a0a546ec87491ace8c0e7564800e1583c01f29c9e3892b
toJson
 void toJson(JsonGenerator gen) throws IOException
{    types.space(namespace);    gen.writeStartObject();    gen.writeStringField("protocol", name);    gen.writeStringField("namespace", namespace);    if (doc != null)        gen.writeStringField("doc", doc);    writeProps(gen);    gen.writeArrayFieldStart("types");    Schema.Names resolved = new Schema.Names(namespace);    for (Schema type : types.values()) if (!resolved.contains(type))        type.toJson(resolved, gen);    gen.writeEndArray();    gen.writeObjectFieldStart("messages");    for (Map.Entry<String, Message> e : messages.entrySet()) {        gen.writeFieldName(e.getKey());        e.getValue().toJson(gen);    }    gen.writeEndObject();    gen.writeEndObject();}
7899e796f92f8c05fdc4cf56a2c75a433ea6f9651deb39fb814021ee0a722855
getMD5
public byte[] getMD5()
{    if (md5 == null)        try {            md5 = MessageDigest.getInstance("MD5").digest(this.toString().getBytes(StandardCharsets.UTF_8));        } catch (Exception e) {            throw new AvroRuntimeException(e);        }    return md5;}
dc03aabdb2d15a2e4eaa42ce8889009316b6383e8b8ba814be348fb13bc332b7
parse
public static Protocol parse(File file) throws IOException
{    return parse(Schema.FACTORY.createParser(file));}
2c4edf32d4722d3c1751d65b9e7043979b76623aac12497a024e141e7a98ea33
parse
public static Protocol parse(InputStream stream) throws IOException
{    return parse(Schema.FACTORY.createParser(stream));}
b77d36fd2780b3534e5b3d41cd3df035a3664544826ccbbb4838e1d7f00e3751
parse
public static Protocol parse(String string, String... more)
{    StringBuilder b = new StringBuilder(string);    for (String part : more) b.append(part);    return parse(b.toString());}
d5954de8d8a8eb2d3ca2d70ef1ca13774a9c05b822a7317a850d59d196218860
parse
public static Protocol parse(String string)
{    try {        return parse(Schema.FACTORY.createParser(new ByteArrayInputStream(string.getBytes(StandardCharsets.UTF_8))));    } catch (IOException e) {        throw new AvroRuntimeException(e);    }}
d2dd55c6f2e7325f43d035b04af8007c2e38645fc3ecc719c5725d9710605d49
parse
private static Protocol parse(JsonParser parser)
{    try {        Protocol protocol = new Protocol();        protocol.parse((JsonNode) Schema.MAPPER.readTree(parser));        return protocol;    } catch (IOException e) {        throw new SchemaParseException(e);    }}
2c0b30e33d32a64409660baa606f70484239434085663500e6e6ddc6a18d4c02
parse
private void parse(JsonNode json)
{    parseNamespace(json);    parseName(json);    parseTypes(json);    parseMessages(json);    parseDoc(json);    parseProps(json);}
fe2b8b006d4cbcc28c01ce5a31707c9dadba64974c2680b90198664902a97af7
parseNamespace
private void parseNamespace(JsonNode json)
{    JsonNode nameNode = json.get("namespace");    if (nameNode == null)                return;    this.namespace = nameNode.textValue();    types.space(this.namespace);}
37f63f7dbf5ee260397d543c2faec14d37cc451662b798f0d7dee56f95e29b6f
parseDoc
private void parseDoc(JsonNode json)
{    this.doc = parseDocNode(json);}
a24cd3fb2213efe452b05d3b30a6cea9cb7a79d37a5c163f4ecc89643103dd0f
parseDocNode
private String parseDocNode(JsonNode json)
{    JsonNode nameNode = json.get("doc");    if (nameNode == null)                return null;    return nameNode.textValue();}
15f48373f641a23e3b5b5fd8d6514b38c06d6f302ea8d7b6303c97a7a83f0b2e
parseName
private void parseName(JsonNode json)
{    JsonNode nameNode = json.get("protocol");    if (nameNode == null)        throw new SchemaParseException("No protocol name specified: " + json);    this.name = nameNode.textValue();}
b589fb7e6a9b2af34bf1b3ed6b2fe3f5ab6bc2700b248e4cead811c80a4e5647
parseTypes
private void parseTypes(JsonNode json)
{    JsonNode defs = json.get("types");    if (defs == null)                return;    if (!defs.isArray())        throw new SchemaParseException("Types not an array: " + defs);    for (JsonNode type : defs) {        if (!type.isObject())            throw new SchemaParseException("Type not an object: " + type);        Schema.parse(type, types);    }}
50b3eeb952983c7f4b883c0f83fd11c9216154e7fd4d9f711ad45c474c39c955
parseProps
private void parseProps(JsonNode json)
{    for (Iterator<String> i = json.fieldNames(); i.hasNext(); ) {                String p = i.next();        if (!PROTOCOL_RESERVED.contains(p))            this.addProp(p, json.get(p));    }}
5e2c7256bf588df686fe608da7ed39d27fd0af8d4e8d138f0704619b0b78f0dd
parseMessages
private void parseMessages(JsonNode json)
{    JsonNode defs = json.get("messages");    if (defs == null)                return;    for (Iterator<String> i = defs.fieldNames(); i.hasNext(); ) {        String prop = i.next();        this.messages.put(prop, parseMessage(prop, defs.get(prop)));    }}
74eff0c4e77bd7aababdf9f8ef80d8f26b2dd78d6280c728af2ece1e35ff979e
parseMessage
private Message parseMessage(String messageName, JsonNode json)
{    String doc = parseDocNode(json);    Map<String, JsonNode> mProps = new LinkedHashMap<>();    for (Iterator<String> i = json.fieldNames(); i.hasNext(); ) {                String p = i.next();        if (!MESSAGE_RESERVED.contains(p))            mProps.put(p, json.get(p));    }    JsonNode requestNode = json.get("request");    if (requestNode == null || !requestNode.isArray())        throw new SchemaParseException("No request specified: " + json);    List<Field> fields = new ArrayList<>();    for (JsonNode field : requestNode) {        JsonNode fieldNameNode = field.get("name");        if (fieldNameNode == null)            throw new SchemaParseException("No param name: " + field);        JsonNode fieldTypeNode = field.get("type");        if (fieldTypeNode == null)            throw new SchemaParseException("No param type: " + field);        String name = fieldNameNode.textValue();        String fieldDoc = null;        JsonNode fieldDocNode = field.get("doc");        if (fieldDocNode != null)            fieldDoc = fieldDocNode.textValue();        Field newField = new Field(name, Schema.parse(fieldTypeNode, types), fieldDoc, field.get("default"), true, Order.ASCENDING);        Set<String> aliases = Schema.parseAliases(field);        if (aliases != null) {                        for (String alias : aliases) newField.addAlias(alias);        }        Iterator<String> i = field.fieldNames();        while (i.hasNext()) {                        String prop = i.next();            if (            !FIELD_RESERVED.contains(prop))                newField.addProp(prop, field.get(prop));        }        fields.add(newField);    }    Schema request = Schema.createRecord(fields);    boolean oneWay = false;    JsonNode oneWayNode = json.get("one-way");    if (oneWayNode != null) {        if (!oneWayNode.isBoolean())            throw new SchemaParseException("one-way must be boolean: " + json);        oneWay = oneWayNode.booleanValue();    }    JsonNode responseNode = json.get("response");    if (!oneWay && responseNode == null)        throw new SchemaParseException("No response specified: " + json);    JsonNode decls = json.get("errors");    if (oneWay) {        if (decls != null)            throw new SchemaParseException("one-way can't have errors: " + json);        if (responseNode != null && Schema.parse(responseNode, types).getType() != Schema.Type.NULL)            throw new SchemaParseException("One way response must be null: " + json);        return new Message(messageName, doc, mProps, request);    }    Schema response = Schema.parse(responseNode, types);    List<Schema> errs = new ArrayList<>();        errs.add(SYSTEM_ERROR);    if (decls != null) {        if (!decls.isArray())            throw new SchemaParseException("Errors not an array: " + json);        for (JsonNode decl : decls) {            String name = decl.textValue();            Schema schema = this.types.get(name);            if (schema == null)                throw new SchemaParseException("Undefined error: " + name);            if (!schema.isError())                throw new SchemaParseException("Not an error: " + name);            errs.add(schema);        }    }    return new TwoWayMessage(messageName, doc, mProps, request, response, Schema.createUnion(errs));}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    System.out.println(Protocol.parse(new File(args[0])));}
f7f8635602fed9db7c3a30be9bc29960b775640d9a73d643fe6d5251f9ad7202
writeArray
 static void writeArray(boolean[] data, Encoder out) throws IOException
{    int size = data.length;    out.setItemCount(size);    for (boolean datum : data) {        out.startItem();        out.writeBoolean(datum);    }}
64a22324a21a8d5189dd753c64ac98a4c13a00fc2d0927db88eb7b9df3f58acc
writeArray
 static void writeArray(short[] data, Encoder out) throws IOException
{    int size = data.length;    out.setItemCount(size);    for (short datum : data) {        out.startItem();        out.writeInt(datum);    }}
ba92ea10e0805e09223569b78731504fa9aa360e1d44d090adbc4b96d85f20c0
writeArray
 static void writeArray(char[] data, Encoder out) throws IOException
{    int size = data.length;    out.setItemCount(size);    for (char datum : data) {        out.startItem();        out.writeInt(datum);    }}
4091789abb63bf8380ee3e1566ffa6106970e6cd4ac816079667d2c62e81a721
writeArray
 static void writeArray(int[] data, Encoder out) throws IOException
{    int size = data.length;    out.setItemCount(size);    for (int datum : data) {        out.startItem();        out.writeInt(datum);    }}
a2e6ba1ab6d3ff83c0acc7ee96b9da5e3750fc7846b072f095bdfd8116510502
writeArray
 static void writeArray(long[] data, Encoder out) throws IOException
{    int size = data.length;    out.setItemCount(size);    for (long datum : data) {        out.startItem();        out.writeLong(datum);    }}
f751554fd3a60056cffb3c6d3b858ffca86f1da9fc9b1a7a8c4beb827734d632
writeArray
 static void writeArray(float[] data, Encoder out) throws IOException
{    int size = data.length;    out.setItemCount(size);    for (float datum : data) {        out.startItem();        out.writeFloat(datum);    }}
3df99d0ab77ee6ae53ae19f9a6b1b7ae595b7e1eed08b54a5c7d27cce0a8e075
writeArray
 static void writeArray(double[] data, Encoder out) throws IOException
{    int size = data.length;    out.setItemCount(size);    for (double datum : data) {        out.startItem();        out.writeDouble(datum);    }}
058437b1e0cbbcd0d30fe464d1ee8d71a8cc7d8d31c78e22b106635312da47f8
readArray
 static Object readArray(Object array, Class<?> elementType, long l, ResolvingDecoder in) throws IOException
{    if (elementType == int.class)        return readArray((int[]) array, l, in);    if (elementType == long.class)        return readArray((long[]) array, l, in);    if (elementType == float.class)        return readArray((float[]) array, l, in);    if (elementType == double.class)        return readArray((double[]) array, l, in);    if (elementType == boolean.class)        return readArray((boolean[]) array, l, in);    if (elementType == char.class)        return readArray((char[]) array, l, in);    if (elementType == short.class)        return readArray((short[]) array, l, in);    return null;}
9ae4003c51662e83d9c4be75db372eb4ecae24299f43782c355efb05ea133570
readArray
 static boolean[] readArray(boolean[] array, long l, ResolvingDecoder in) throws IOException
{    int index = 0;    do {        int limit = index + (int) l;        if (array.length < limit) {            array = Arrays.copyOf(array, limit);        }        while (index < limit) {            array[index] = in.readBoolean();            index++;        }    } while ((l = in.arrayNext()) > 0);    return array;}
212b1495dde5455917361057f5b336cb48aeef45d07c6e73f5986467731c998d
readArray
 static int[] readArray(int[] array, long l, ResolvingDecoder in) throws IOException
{    int index = 0;    do {        int limit = index + (int) l;        if (array.length < limit) {            array = Arrays.copyOf(array, limit);        }        while (index < limit) {            array[index] = in.readInt();            index++;        }    } while ((l = in.arrayNext()) > 0);    return array;}
f71a07670be664ffdbe720057f734876144a402909bea51d5564c9f4830dcb29
readArray
 static short[] readArray(short[] array, long l, ResolvingDecoder in) throws IOException
{    int index = 0;    do {        int limit = index + (int) l;        if (array.length < limit) {            array = Arrays.copyOf(array, limit);        }        while (index < limit) {            array[index] = (short) in.readInt();            index++;        }    } while ((l = in.arrayNext()) > 0);    return array;}
a46cef78d2d729aa7bb6bff71d0d321fd37aa55bccac802408f10a0bc3bbe4b5
readArray
 static char[] readArray(char[] array, long l, ResolvingDecoder in) throws IOException
{    int index = 0;    do {        int limit = index + (int) l;        if (array.length < limit) {            array = Arrays.copyOf(array, limit);        }        while (index < limit) {            array[index] = (char) in.readInt();            index++;        }    } while ((l = in.arrayNext()) > 0);    return array;}
52138c6ddd968fe683d0bee9307e6267f3fecc5af25e8ff93dcc6262013bf16b
readArray
 static long[] readArray(long[] array, long l, ResolvingDecoder in) throws IOException
{    int index = 0;    do {        int limit = index + (int) l;        if (array.length < limit) {            array = Arrays.copyOf(array, limit);        }        while (index < limit) {            array[index] = in.readLong();            index++;        }    } while ((l = in.arrayNext()) > 0);    return array;}
822dc7331256a047025593f849af336ff15d35efa08fe2869cf9a82bc5a1d72e
readArray
 static float[] readArray(float[] array, long l, ResolvingDecoder in) throws IOException
{    int index = 0;    do {        int limit = index + (int) l;        if (array.length < limit) {            array = Arrays.copyOf(array, limit);        }        while (index < limit) {            array[index] = in.readFloat();            index++;        }    } while ((l = in.arrayNext()) > 0);    return array;}
121f8063232cc0cfcd3da0ccef06ff62cf2fcdfba97f34dd0ce019a0d5cd619b
readArray
 static double[] readArray(double[] array, long l, ResolvingDecoder in) throws IOException
{    int index = 0;    do {        int limit = index + (int) l;        if (array.length < limit) {            array = Arrays.copyOf(array, limit);        }        while (index < limit) {            array[index] = in.readDouble();            index++;        }    } while ((l = in.arrayNext()) > 0);    return array;}
7d96630424e5a1995e26a9bccd51d9fa53ca35d07de72451baad2a60a0f3d60c
read
 T read(Decoder in) throws IOException
{    return this.read(null, in);}
83126e46f74779f8ca7db78442694c63703e46d31d53234da4174f2af8bfc162
getSchema
protected Schema getSchema()
{    return schema;}
498b7600c96cd9377fe7215e08ec46b12c1c2a8c3c43094ef0b58ed7e6858b69
write
protected final void write(Object datum, Encoder out) throws IOException
{    out.writeLong(((Date) datum).getTime());}
8e0315779d3d6b7ba5dabdeb07ecd99e4b3c75ba9bbbfbb830facfd471f4bf0b
read
protected final Date read(Object reuse, Decoder in) throws IOException
{    if (reuse instanceof Date) {        ((Date) reuse).setTime(in.readLong());        return (Date) reuse;    } else        return new Date(in.readLong());}
4d178745dd442bf0b3c2f061002877e60af5d9895d235030eb5bca3a3d75d4d0
read
protected void read(Object object, Decoder in) throws IOException
{}
f8b3daad7221182b38415252daffcd400355e42f859dae673ded1f49e8b0f5a5
write
protected void write(Object object, Encoder out) throws IOException
{}
2139142e0c4c6993db03ba457fdf347aefcff636ad748cd1759c85231b8bc48e
supportsIO
protected boolean supportsIO()
{    return false;}
9a80a137cb85e417f6a47f7c3724d6455d914a47e54a1d48ed376ad76a960d55
isStringable
protected boolean isStringable()
{    return false;}
a058d419cce962b8c184dd3e98a8d6652cc822781dd3095f7a804adebac482d3
isCustomEncoded
protected boolean isCustomEncoded()
{    return false;}
866fe15e323e5ec3ba9521987ba58050a113e03a7c1da508d70a74c1a6b87b7c
getAccessor
protected FieldAccessor getAccessor(Field field)
{    AvroEncode enc = field.getAnnotation(AvroEncode.class);    if (enc != null)        try {            return new ReflectionBasesAccessorCustomEncoded(field, enc.using().getDeclaredConstructor().newInstance());        } catch (Exception e) {            throw new AvroRuntimeException("Could not instantiate custom Encoding");        }    return new ReflectionBasedAccessor(field);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return field.getName();}
1395bdcf1738533d1929c8ca16826a5148dc33a34a79245d0789ca23b18f4682
get
public Object get(Object object) throws IllegalAccessException
{    return field.get(object);}
5d18cb1b7ae5579c4be76d40468ad49abbeb5895e219f5460900afbfa28a277c
set
public void set(Object object, Object value) throws IllegalAccessException, IOException
{    field.set(object, value);}
10f0d5c6866a6e725b5b22fde85f81b488c1e3582bcd1965756b2ce221c1ba75
getField
protected Field getField()
{    return field;}
9a80a137cb85e417f6a47f7c3724d6455d914a47e54a1d48ed376ad76a960d55
isStringable
protected boolean isStringable()
{    return isStringable;}
a058d419cce962b8c184dd3e98a8d6652cc822781dd3095f7a804adebac482d3
isCustomEncoded
protected boolean isCustomEncoded()
{    return isCustomEncoded;}
4d178745dd442bf0b3c2f061002877e60af5d9895d235030eb5bca3a3d75d4d0
read
protected void read(Object object, Decoder in) throws IOException
{    try {        field.set(object, encoding.read(in));    } catch (IllegalAccessException e) {        throw new AvroRuntimeException(e);    }}
f8b3daad7221182b38415252daffcd400355e42f859dae673ded1f49e8b0f5a5
write
protected void write(Object object, Encoder out) throws IOException
{    try {        encoding.write(field.get(object), out);    } catch (IllegalAccessException e) {        throw new AvroRuntimeException(e);    }}
a058d419cce962b8c184dd3e98a8d6652cc822781dd3095f7a804adebac482d3
isCustomEncoded
protected boolean isCustomEncoded()
{    return true;}
2139142e0c4c6993db03ba457fdf347aefcff636ad748cd1759c85231b8bc48e
supportsIO
protected boolean supportsIO()
{    return true;}
866fe15e323e5ec3ba9521987ba58050a113e03a7c1da508d70a74c1a6b87b7c
getAccessor
protected FieldAccessor getAccessor(Field field)
{    AvroEncode enc = field.getAnnotation(AvroEncode.class);    if (enc != null)        try {            return new UnsafeCustomEncodedField(field, enc.using().getDeclaredConstructor().newInstance());        } catch (Exception e) {            throw new AvroRuntimeException("Could not instantiate custom Encoding");        }    Class<?> c = field.getType();    if (c == int.class)        return new UnsafeIntField(field);    else if (c == long.class)        return new UnsafeLongField(field);    else if (c == byte.class)        return new UnsafeByteField(field);    else if (c == float.class)        return new UnsafeFloatField(field);    else if (c == double.class)        return new UnsafeDoubleField(field);    else if (c == char.class)        return new UnsafeCharField(field);    else if (c == boolean.class)        return new UnsafeBooleanField(field);    else if (c == short.class)        return new UnsafeShortField(field);    else        return new UnsafeObjectField(field);}
10f0d5c6866a6e725b5b22fde85f81b488c1e3582bcd1965756b2ce221c1ba75
getField
protected Field getField()
{    return field;}
2139142e0c4c6993db03ba457fdf347aefcff636ad748cd1759c85231b8bc48e
supportsIO
protected boolean supportsIO()
{    return true;}
9a80a137cb85e417f6a47f7c3724d6455d914a47e54a1d48ed376ad76a960d55
isStringable
protected boolean isStringable()
{    return isStringable;}
5df72ca54055fee7f8e97b708b8ba946d7d3e23c7db05b8b9b79377bbc4033e5
set
protected void set(Object object, Object value)
{    UNSAFE.putInt(object, offset, (Integer) value);}
0bd764893d0f4a943be98b3e3c15d1c1dac9129e368e6bd99a28e2ef9072bcb1
get
protected Object get(Object object)
{    return UNSAFE.getInt(object, offset);}
4d178745dd442bf0b3c2f061002877e60af5d9895d235030eb5bca3a3d75d4d0
read
protected void read(Object object, Decoder in) throws IOException
{    UNSAFE.putInt(object, offset, in.readInt());}
f8b3daad7221182b38415252daffcd400355e42f859dae673ded1f49e8b0f5a5
write
protected void write(Object object, Encoder out) throws IOException
{    out.writeInt(UNSAFE.getInt(object, offset));}
5df72ca54055fee7f8e97b708b8ba946d7d3e23c7db05b8b9b79377bbc4033e5
set
protected void set(Object object, Object value)
{    UNSAFE.putFloat(object, offset, (Float) value);}
0bd764893d0f4a943be98b3e3c15d1c1dac9129e368e6bd99a28e2ef9072bcb1
get
protected Object get(Object object)
{    return UNSAFE.getFloat(object, offset);}
4d178745dd442bf0b3c2f061002877e60af5d9895d235030eb5bca3a3d75d4d0
read
protected void read(Object object, Decoder in) throws IOException
{    UNSAFE.putFloat(object, offset, in.readFloat());}
f8b3daad7221182b38415252daffcd400355e42f859dae673ded1f49e8b0f5a5
write
protected void write(Object object, Encoder out) throws IOException
{    out.writeFloat(UNSAFE.getFloat(object, offset));}
5df72ca54055fee7f8e97b708b8ba946d7d3e23c7db05b8b9b79377bbc4033e5
set
protected void set(Object object, Object value)
{    UNSAFE.putShort(object, offset, (Short) value);}
0bd764893d0f4a943be98b3e3c15d1c1dac9129e368e6bd99a28e2ef9072bcb1
get
protected Object get(Object object)
{    return UNSAFE.getShort(object, offset);}
4d178745dd442bf0b3c2f061002877e60af5d9895d235030eb5bca3a3d75d4d0
read
protected void read(Object object, Decoder in) throws IOException
{    UNSAFE.putShort(object, offset, (short) in.readInt());}
f8b3daad7221182b38415252daffcd400355e42f859dae673ded1f49e8b0f5a5
write
protected void write(Object object, Encoder out) throws IOException
{    out.writeInt(UNSAFE.getShort(object, offset));}
5df72ca54055fee7f8e97b708b8ba946d7d3e23c7db05b8b9b79377bbc4033e5
set
protected void set(Object object, Object value)
{    UNSAFE.putByte(object, offset, (Byte) value);}
0bd764893d0f4a943be98b3e3c15d1c1dac9129e368e6bd99a28e2ef9072bcb1
get
protected Object get(Object object)
{    return UNSAFE.getByte(object, offset);}
4d178745dd442bf0b3c2f061002877e60af5d9895d235030eb5bca3a3d75d4d0
read
protected void read(Object object, Decoder in) throws IOException
{    UNSAFE.putByte(object, offset, (byte) in.readInt());}
f8b3daad7221182b38415252daffcd400355e42f859dae673ded1f49e8b0f5a5
write
protected void write(Object object, Encoder out) throws IOException
{    out.writeInt(UNSAFE.getByte(object, offset));}
5df72ca54055fee7f8e97b708b8ba946d7d3e23c7db05b8b9b79377bbc4033e5
set
protected void set(Object object, Object value)
{    UNSAFE.putBoolean(object, offset, (Boolean) value);}
0bd764893d0f4a943be98b3e3c15d1c1dac9129e368e6bd99a28e2ef9072bcb1
get
protected Object get(Object object)
{    return UNSAFE.getBoolean(object, offset);}
4d178745dd442bf0b3c2f061002877e60af5d9895d235030eb5bca3a3d75d4d0
read
protected void read(Object object, Decoder in) throws IOException
{    UNSAFE.putBoolean(object, offset, in.readBoolean());}
f8b3daad7221182b38415252daffcd400355e42f859dae673ded1f49e8b0f5a5
write
protected void write(Object object, Encoder out) throws IOException
{    out.writeBoolean(UNSAFE.getBoolean(object, offset));}
5df72ca54055fee7f8e97b708b8ba946d7d3e23c7db05b8b9b79377bbc4033e5
set
protected void set(Object object, Object value)
{    UNSAFE.putChar(object, offset, (Character) value);}
0bd764893d0f4a943be98b3e3c15d1c1dac9129e368e6bd99a28e2ef9072bcb1
get
protected Object get(Object object)
{    return UNSAFE.getChar(object, offset);}
4d178745dd442bf0b3c2f061002877e60af5d9895d235030eb5bca3a3d75d4d0
read
protected void read(Object object, Decoder in) throws IOException
{    UNSAFE.putChar(object, offset, (char) in.readInt());}
f8b3daad7221182b38415252daffcd400355e42f859dae673ded1f49e8b0f5a5
write
protected void write(Object object, Encoder out) throws IOException
{    out.writeInt(UNSAFE.getChar(object, offset));}
5df72ca54055fee7f8e97b708b8ba946d7d3e23c7db05b8b9b79377bbc4033e5
set
protected void set(Object object, Object value)
{    UNSAFE.putLong(object, offset, (Long) value);}
0bd764893d0f4a943be98b3e3c15d1c1dac9129e368e6bd99a28e2ef9072bcb1
get
protected Object get(Object object)
{    return UNSAFE.getLong(object, offset);}
4d178745dd442bf0b3c2f061002877e60af5d9895d235030eb5bca3a3d75d4d0
read
protected void read(Object object, Decoder in) throws IOException
{    UNSAFE.putLong(object, offset, in.readLong());}
f8b3daad7221182b38415252daffcd400355e42f859dae673ded1f49e8b0f5a5
write
protected void write(Object object, Encoder out) throws IOException
{    out.writeLong(UNSAFE.getLong(object, offset));}
5df72ca54055fee7f8e97b708b8ba946d7d3e23c7db05b8b9b79377bbc4033e5
set
protected void set(Object object, Object value)
{    UNSAFE.putDouble(object, offset, (Double) value);}
0bd764893d0f4a943be98b3e3c15d1c1dac9129e368e6bd99a28e2ef9072bcb1
get
protected Object get(Object object)
{    return UNSAFE.getDouble(object, offset);}
4d178745dd442bf0b3c2f061002877e60af5d9895d235030eb5bca3a3d75d4d0
read
protected void read(Object object, Decoder in) throws IOException
{    UNSAFE.putDouble(object, offset, in.readDouble());}
f8b3daad7221182b38415252daffcd400355e42f859dae673ded1f49e8b0f5a5
write
protected void write(Object object, Encoder out) throws IOException
{    out.writeDouble(UNSAFE.getDouble(object, offset));}
5df72ca54055fee7f8e97b708b8ba946d7d3e23c7db05b8b9b79377bbc4033e5
set
protected void set(Object object, Object value)
{    UNSAFE.putObject(object, offset, value);}
0bd764893d0f4a943be98b3e3c15d1c1dac9129e368e6bd99a28e2ef9072bcb1
get
protected Object get(Object object)
{    return UNSAFE.getObject(object, offset);}
2139142e0c4c6993db03ba457fdf347aefcff636ad748cd1759c85231b8bc48e
supportsIO
protected boolean supportsIO()
{    return false;}
0ebb10c89b6c8797fc249226efd35095d3b5c2dbbd61e51ae4bc6156fb4ec661
get
protected Object get(Object object) throws IllegalAccessException
{    return UNSAFE.getObject(object, offset);}
500b939748b4cb13212c3a7cf9c75a3b380ac45ea7ebabfb38fc672acceb45b3
set
protected void set(Object object, Object value) throws IllegalAccessException, IOException
{    UNSAFE.putObject(object, offset, value);}
4d178745dd442bf0b3c2f061002877e60af5d9895d235030eb5bca3a3d75d4d0
read
protected void read(Object object, Decoder in) throws IOException
{    UNSAFE.putObject(object, offset, encoding.read(in));}
f8b3daad7221182b38415252daffcd400355e42f859dae673ded1f49e8b0f5a5
write
protected void write(Object object, Encoder out) throws IOException
{    encoding.write(UNSAFE.getObject(object, offset), out);}
a058d419cce962b8c184dd3e98a8d6652cc822781dd3095f7a804adebac482d3
isCustomEncoded
protected boolean isCustomEncoded()
{    return true;}
408af2012690314114a03f0ca626970e41121b2f610127a0eacfc4e43e74dbfe
getKey
public K getKey()
{    return key;}
5a159708665ed864d795a0702d525a75a1e0d877881ccd093ed97ed18e382934
getValue
public V getValue()
{    return value;}
d8401f424036b4f728f70be90e19de421f30843cb3cd58fa6f7257c274ce398d
setValue
public V setValue(V value)
{    V oldValue = this.value;    this.value = value;    return oldValue;}
0fbdb2140ad4e5e766cc5531ed093da5673989f2479706f1bbb30f4fe4703765
useCustomCoders
public boolean useCustomCoders()
{    return false;}
b9abb5f7bd2a445ab57b6af845d25995a83795af9f34ffce0d23e2c03fb25022
get
public static AllowNull get()
{    return INSTANCE;}
f0cc5ae38d1a2d1b9a6cf74d2e8f1719141353d5818b0deea141f4d6e9ad1249
createFieldSchema
protected Schema createFieldSchema(Field field, Map<String, Schema> names)
{    Schema schema = super.createFieldSchema(field, names);    if (field.getType().isPrimitive()) {                return schema;    }    return makeNullable(schema);}
a5e424ad66da13109aaa150c746db3eed8da683d929445f9275b536d7007d64d
get
public static ReflectData get()
{    return INSTANCE;}
d14ca0747118b2c728d73f86199be3ae3dee9c88001eb99de1fb09811f4a6176
addStringable
public ReflectData addStringable(Class c)
{    stringableClasses.add(c);    return this;}
7303aaf9e45ab4c8c624b0e6a5d7b5941d362a96397a811d275ccc7e47c2ece3
createDatumReader
public DatumReader createDatumReader(Schema schema)
{    return new ReflectDatumReader(schema, schema, this);}
d21900c7941122070f06c2bc5bc41ce259bc840f1c278c43da933de5ac71ea45
createDatumReader
public DatumReader createDatumReader(Schema writer, Schema reader)
{    return new ReflectDatumReader(writer, reader, this);}
3d2aa170a9dc9e88ce5dff8d9760bdd18b4ddcbfb1066b36a9661ff0df2e90fb
createDatumWriter
public DatumWriter createDatumWriter(Schema schema)
{    return new ReflectDatumWriter(schema, this);}
2284c2976b7804b74035de264c3d7049a71a0a0ecfc3277071f28be4fc97b835
setField
public void setField(Object record, String name, int position, Object o)
{    setField(record, name, position, o, null);}
6e12059b88d42405cf060978f7f4b86d6e3d7159f1d88091242c4bb31e50061e
setField
protected void setField(Object record, String name, int pos, Object o, Object state)
{    if (record instanceof IndexedRecord) {        super.setField(record, name, pos, o);        return;    }    try {        getAccessorForField(record, name, pos, state).set(record, o);    } catch (IllegalAccessException | IOException e) {        throw new AvroRuntimeException(e);    }}
a4c1c35b6cb0d86153e50d1f9f5efd8fd4328615aab976da47d2c0416fdb73fc
getField
public Object getField(Object record, String name, int position)
{    return getField(record, name, position, null);}
61e87990300aa265dffc2843e9002d5e5aea256de7f2e53dec5ca66ff32170a1
getField
protected Object getField(Object record, String name, int pos, Object state)
{    if (record instanceof IndexedRecord) {        return super.getField(record, name, pos);    }    try {        return getAccessorForField(record, name, pos, state).get(record);    } catch (IllegalAccessException e) {        throw new AvroRuntimeException(e);    }}
2e1ef9c0582186b6dd8dce21d0722c5b6554bc8fb0b0f14c213b8640f09cc862
getAccessorForField
private FieldAccessor getAccessorForField(Object record, String name, int pos, Object optionalState)
{    if (optionalState != null) {        return ((FieldAccessor[]) optionalState)[pos];    }    return getFieldAccessor(record.getClass(), name);}
1b134742de945abb4e613bd1016bdba9127aba26e8e578964be50af2bb864d19
isRecord
protected boolean isRecord(Object datum)
{    if (datum == null)        return false;    if (super.isRecord(datum))        return true;    if (datum instanceof Collection)        return false;    if (datum instanceof Map)        return false;    if (datum instanceof GenericFixed)        return false;    return getSchema(datum.getClass()).getType() == Schema.Type.RECORD;}
544f1c34befadc3c9aa6e8a9976e5699018508396f3bbc8d42eb8027b3d830fb
isArray
protected boolean isArray(Object datum)
{    if (datum == null)        return false;    Class c = datum.getClass();    return (datum instanceof Collection) || (c.isArray() && c.getComponentType() != Byte.TYPE) || isNonStringMap(datum);}
4c687c9af8c642732c0418216904a06af3e7a03ee487ecf33ddebaf73ad8d2ff
getArrayAsCollection
protected Collection getArrayAsCollection(Object datum)
{    return (datum instanceof Map) ? ((Map) datum).entrySet() : (Collection) datum;}
c19f2258b56e6bb84785b44422325e6dd35d0cd9e9b7c47a7b0e85b56e643c83
isBytes
protected boolean isBytes(Object datum)
{    if (datum == null)        return false;    if (super.isBytes(datum))        return true;    Class c = datum.getClass();    return c.isArray() && c.getComponentType() == Byte.TYPE;}
e0ccc1e06ae00a2a60c371353533514f62b4e4bb097a1e40a212a8240b20fe10
getRecordSchema
protected Schema getRecordSchema(Object record)
{    if (record instanceof GenericContainer)        return super.getRecordSchema(record);    return getSchema(record.getClass());}
6663bde0da8c466d276c699166abe0bd66cb345ed1bb17897c01dfe260f57b9d
validate
public boolean validate(Schema schema, Object datum)
{    switch(schema.getType()) {        case ARRAY:            if (!datum.getClass().isArray())                return super.validate(schema, datum);            int length = java.lang.reflect.Array.getLength(datum);            for (int i = 0; i < length; i++) if (!validate(schema.getElementType(), java.lang.reflect.Array.get(datum, i)))                return false;            return true;        default:            return super.validate(schema, datum);    }}
6ccb299f4edd5c6df318ee85d497920439023d2037e8220cf8509c32f5e1d874
computeValue
protected ClassAccessorData computeValue(Class<?> c)
{    if (!IndexedRecord.class.isAssignableFrom(c)) {        return new ClassAccessorData(c);    }    return null;}
d439cbcb68996aaa7fb88d8f9139e98a02f9dedaa8cf3f528211f0fd11c0909e
getAccessorsFor
private synchronized FieldAccessor[] getAccessorsFor(Schema schema)
{        FieldAccessor[] result = bySchema.get(schema);    if (result == null) {        result = createAccessorsFor(schema);        bySchema.put(schema, result);    }    return result;}
8b66405927bc19fc99b458446f1f3deab1663e4388c0e19d74347ed6276bf4e9
createAccessorsFor
private FieldAccessor[] createAccessorsFor(Schema schema)
{    List<Schema.Field> avroFields = schema.getFields();    FieldAccessor[] result = new FieldAccessor[avroFields.size()];    for (Schema.Field avroField : schema.getFields()) {        result[avroField.pos()] = byName.get(avroField.name());    }    return result;}
eb7d59fbdae5a7d95e2df99c34eb6a6b690bea04c5ee4084cadbb8cbe2d4f446
getAccessorFor
private FieldAccessor getAccessorFor(String fieldName)
{    FieldAccessor result = byName.get(fieldName);    if (result == null) {        throw new AvroRuntimeException("No field named " + fieldName + " in: " + clazz);    }    return result;}
e47a32a95007617b139cb0bd8b40c23185737d3cc558c7161e4c09ccf40cbda5
getClassAccessorData
private ClassAccessorData getClassAccessorData(Class<?> c)
{    return ACCESSOR_CACHE.get(c);}
9f56939411dc22ddb51f8e3d7d5d0c6cebad51055709f3f1a7a4b09f32c6ff53
getFieldAccessors
private FieldAccessor[] getFieldAccessors(Class<?> c, Schema s)
{    ClassAccessorData data = getClassAccessorData(c);    if (data != null) {        return data.getAccessorsFor(s);    }    return null;}
5e5b184d8af89553434d8bbc9c94ca8bbd62a64ea8b7518b9092f34c25a16e6c
getFieldAccessor
private FieldAccessor getFieldAccessor(Class<?> c, String fieldName)
{    ClassAccessorData data = getClassAccessorData(c);    if (data != null) {        return data.getAccessorFor(fieldName);    }    return null;}
c05cb88d6896bf48aab43dc7c0e0d49718cc2287727cf380bb9021c7a875a662
getClassProp
 static Class getClassProp(Schema schema, String prop)
{    String name = schema.getProp(prop);    if (name == null)        return null;    Class c = CLASS_CACHE.get(name);    if (c != null)        return c;    try {        c = ClassUtils.forName(name);        CLASS_CACHE.put(name, c);    } catch (ClassNotFoundException e) {        throw new AvroRuntimeException(e);    }    return c;}
8f4ac4a01f0496b5f1af8e3b340d123bbec375958bb9eb555c593ef76d27ae93
isMap
protected boolean isMap(Object datum)
{    return (datum instanceof Map) && !isNonStringMap(datum);}
e3344c07d5f2b09f6d126ef650e0fa290b016af4d864c8866629127b0238075f
isNonStringMap
private boolean isNonStringMap(Object datum)
{    if (datum instanceof Map) {        Map m = (Map) datum;        if (m.size() > 0) {            Class keyClass = m.keySet().iterator().next().getClass();            return !isStringable(keyClass) && !isStringType(keyClass);        }    }    return false;}
7bab8e367e2f292e6cbbd55346a5a1277826d41ce8cd319804b5966308adbeca
getClass
public Class getClass(Schema schema)
{        Conversion<?> conversion = getConversionFor(schema.getLogicalType());    if (conversion != null) {        return conversion.getConvertedType();    }    switch(schema.getType()) {        case ARRAY:            Class collectionClass = getClassProp(schema, CLASS_PROP);            if (collectionClass != null)                return collectionClass;            Class elementClass = getClass(schema.getElementType());            if (elementClass.isPrimitive()) {                                return ARRAY_CLASSES.get(elementClass);            } else {                return java.lang.reflect.Array.newInstance(elementClass, 0).getClass();            }        case STRING:            Class stringClass = getClassProp(schema, CLASS_PROP);            if (stringClass != null)                return stringClass;            return String.class;        case BYTES:            return BYTES_CLASS;        case INT:            String intClass = schema.getProp(CLASS_PROP);            if (Byte.class.getName().equals(intClass))                return Byte.TYPE;            if (Short.class.getName().equals(intClass))                return Short.TYPE;            if (Character.class.getName().equals(intClass))                return Character.TYPE;        default:            return super.getClass(schema);    }}
71e733414f2d94e0f901c9cee3a7b450281d70cad7ba190b77a24319c368a172
createNonStringMapSchema
 Schema createNonStringMapSchema(Type keyType, Type valueType, Map<String, Schema> names)
{    Schema keySchema = createSchema(keyType, names);    Schema valueSchema = createSchema(valueType, names);    Schema.Field keyField = new Schema.Field(NS_MAP_KEY, keySchema, null, null);    Schema.Field valueField = new Schema.Field(NS_MAP_VALUE, valueSchema, null, null);    String name = getNameForNonStringMapRecord(keyType, valueType, keySchema, valueSchema);    Schema elementSchema = Schema.createRecord(name, null, null, false);    elementSchema.setFields(Arrays.asList(keyField, valueField));    Schema arraySchema = Schema.createArray(elementSchema);    return arraySchema;}
7b653a32fccebad004ea51c11c5528bb6d08cc3bce384d6ddd44f9aad8062ff5
getNameForNonStringMapRecord
private String getNameForNonStringMapRecord(Type keyType, Type valueType, Schema keySchema, Schema valueSchema)
{        if (keyType instanceof Class && valueType instanceof Class) {        Class keyClass = (Class) keyType;        Class valueClass = (Class) valueType;        Package pkg1 = keyClass.getPackage();        Package pkg2 = valueClass.getPackage();        if (pkg1 != null && pkg1.getName().startsWith("java") && pkg2 != null && pkg2.getName().startsWith("java")) {            return NS_MAP_ARRAY_RECORD + keyClass.getSimpleName() + valueClass.getSimpleName();        }    }    String name = keySchema.getFullName() + valueSchema.getFullName();    long fingerprint = SchemaNormalization.fingerprint64(name.getBytes(StandardCharsets.UTF_8));    if (fingerprint < 0)                fingerprint = -fingerprint;        String fpString = Long.toString(fingerprint, 16);    return NS_MAP_ARRAY_RECORD + fpString;}
b1ab60f4b7395820b608043e8f44d3a40ad500f05f627ed5ed38f67166e9cce5
isNonStringMapSchema
 static boolean isNonStringMapSchema(Schema s)
{    if (s != null && s.getType() == Schema.Type.ARRAY) {        Class c = getClassProp(s, CLASS_PROP);        return c != null && Map.class.isAssignableFrom(c);    }    return false;}
9531a98edd04ef2925503083240c866edfd897667d5c99732f0021d88df61334
createSchema
protected Schema createSchema(Type type, Map<String, Schema> names)
{    if (type instanceof GenericArrayType) {                Type component = ((GenericArrayType) type).getGenericComponentType();        if (        component == Byte.TYPE)            return Schema.create(Schema.Type.BYTES);        Schema result = Schema.createArray(createSchema(component, names));        setElement(result, component);        return result;    } else if (type instanceof ParameterizedType) {        ParameterizedType ptype = (ParameterizedType) type;        Class raw = (Class) ptype.getRawType();        Type[] params = ptype.getActualTypeArguments();        if (Map.class.isAssignableFrom(raw)) {                        Class key = (Class) params[0];            if (isStringable(key)) {                                Schema schema = Schema.createMap(createSchema(params[1], names));                schema.addProp(KEY_CLASS_PROP, key.getName());                return schema;            } else if (key != String.class) {                Schema schema = createNonStringMapSchema(params[0], params[1], names);                schema.addProp(CLASS_PROP, raw.getName());                return schema;            }        } else if (Collection.class.isAssignableFrom(raw)) {                        if (params.length != 1)                throw new AvroTypeException("No array type specified.");            Schema schema = Schema.createArray(createSchema(params[0], names));            schema.addProp(CLASS_PROP, raw.getName());            return schema;        }    } else if ((type == Byte.class) || (type == Byte.TYPE)) {        Schema result = Schema.create(Schema.Type.INT);        result.addProp(CLASS_PROP, Byte.class.getName());        return result;    } else if ((type == Short.class) || (type == Short.TYPE)) {        Schema result = Schema.create(Schema.Type.INT);        result.addProp(CLASS_PROP, Short.class.getName());        return result;    } else if ((type == Character.class) || (type == Character.TYPE)) {        Schema result = Schema.create(Schema.Type.INT);        result.addProp(CLASS_PROP, Character.class.getName());        return result;    } else if (type instanceof Class) {                Class<?> c = (Class<?>) type;        if (        c.isPrimitive() || c == Void.class || c == Boolean.class || c == Integer.class || c == Long.class || c == Float.class || c == Double.class || c == Byte.class || c == Short.class || c == Character.class)            return super.createSchema(type, names);        if (c.isArray()) {                        Class component = c.getComponentType();            if (component == Byte.TYPE) {                                Schema result = Schema.create(Schema.Type.BYTES);                result.addProp(CLASS_PROP, c.getName());                return result;            }            Schema result = Schema.createArray(createSchema(component, names));            result.addProp(CLASS_PROP, c.getName());            setElement(result, component);            return result;        }        AvroSchema explicit = c.getAnnotation(AvroSchema.class);        if (        explicit != null)            return new Schema.Parser().parse(explicit.value());        if (        CharSequence.class.isAssignableFrom(c))            return Schema.create(Schema.Type.STRING);        if (        ByteBuffer.class.isAssignableFrom(c))            return Schema.create(Schema.Type.BYTES);        if (        Collection.class.isAssignableFrom(c))            throw new AvroRuntimeException("Can't find element type of Collection");        Conversion<?> conversion = getConversionByClass(c);        if (conversion != null) {            return conversion.getRecommendedSchema();        }        String fullName = c.getName();        Schema schema = names.get(fullName);        if (schema == null) {                        AvroDoc annotatedDoc = c.getAnnotation(AvroDoc.class);            String doc = (annotatedDoc != null) ? annotatedDoc.value() : null;            String name = c.getSimpleName();            String space = c.getPackage() == null ? "" : c.getPackage().getName();            if (            c.getEnclosingClass() != null)                space = c.getEnclosingClass().getName();            Union union = c.getAnnotation(Union.class);            if (union != null) {                                return getAnnotatedUnion(union, names);            } else if (isStringable(c)) {                                Schema result = Schema.create(Schema.Type.STRING);                result.addProp(CLASS_PROP, c.getName());                return result;            } else if (c.isEnum()) {                                List<String> symbols = new ArrayList<>();                Enum[] constants = (Enum[]) c.getEnumConstants();                for (Enum constant : constants) symbols.add(constant.name());                schema = Schema.createEnum(name, doc, space, symbols);                consumeAvroAliasAnnotation(c, schema);            } else if (GenericFixed.class.isAssignableFrom(c)) {                                int size = c.getAnnotation(FixedSize.class).value();                schema = Schema.createFixed(name, doc, space, size);                consumeAvroAliasAnnotation(c, schema);            } else if (IndexedRecord.class.isAssignableFrom(c)) {                                return super.createSchema(type, names);            } else {                                List<Schema.Field> fields = new ArrayList<>();                boolean error = Throwable.class.isAssignableFrom(c);                schema = Schema.createRecord(name, doc, space, error);                consumeAvroAliasAnnotation(c, schema);                names.put(c.getName(), schema);                for (Field field : getCachedFields(c)) if ((field.getModifiers() & (Modifier.TRANSIENT | Modifier.STATIC)) == 0 && !field.isAnnotationPresent(AvroIgnore.class)) {                    Schema fieldSchema = createFieldSchema(field, names);                    AvroDefault defaultAnnotation = field.getAnnotation(AvroDefault.class);                    Object defaultValue = (defaultAnnotation == null) ? null : Schema.parseJsonToObject(defaultAnnotation.value());                                        annotatedDoc = field.getAnnotation(AvroDoc.class);                    doc = (annotatedDoc != null) ? annotatedDoc.value() : null;                    if (defaultValue == null && fieldSchema.getType() == Schema.Type.UNION) {                        Schema defaultType = fieldSchema.getTypes().get(0);                        if (defaultType.getType() == Schema.Type.NULL) {                            defaultValue = JsonProperties.NULL_VALUE;                        }                    }                                        AvroName annotatedName = field.getAnnotation(AvroName.class);                    String fieldName = (annotatedName != null) ? annotatedName.value() : field.getName();                    Schema.Field recordField = new Schema.Field(fieldName, fieldSchema, doc, defaultValue);                                        AvroMeta[] metadata = field.getAnnotationsByType(AvroMeta.class);                    for (AvroMeta meta : metadata) {                        if (recordField.getObjectProps().containsKey(meta.key())) {                            throw new AvroTypeException("Duplicate field prop key: " + meta.key());                        }                        recordField.addProp(meta.key(), meta.value());                    }                    for (Schema.Field f : fields) {                        if (f.name().equals(fieldName))                            throw new AvroTypeException("double field entry: " + fieldName);                    }                    consumeFieldAlias(field, recordField);                    fields.add(recordField);                }                if (                error)                    fields.add(new Schema.Field("detailMessage", THROWABLE_MESSAGE, null, null));                schema.setFields(fields);                AvroMeta[] metadata = c.getAnnotationsByType(AvroMeta.class);                for (AvroMeta meta : metadata) {                    if (schema.getObjectProps().containsKey(meta.key())) {                        throw new AvroTypeException("Duplicate type prop key: " + meta.key());                    }                    schema.addProp(meta.key(), meta.value());                }            }            names.put(fullName, schema);        }        return schema;    }    return super.createSchema(type, names);}
4e5d39adece14125e36b43aed4da6eb493af92260be4076f69a79253f56968e0
isStringable
protected boolean isStringable(Class<?> c)
{    return c.isAnnotationPresent(Stringable.class) || super.isStringable(c);}
2b63ad833e31c6c27ba3387a710a2957ca3e1c0747e84cccc7d2e5cf393c6dfb
setElement
private void setElement(Schema schema, Type element)
{    if (!(element instanceof Class))        return;    Class<?> c = (Class<?>) element;    Union union = c.getAnnotation(Union.class);    if (    union != null)        schema.addProp(ELEMENT_PROP, c.getName());}
9cbcff7278fa0c60ffd13b18771691e53228c09e969ca5b32134672a4d7fdc6c
getAnnotatedUnion
private Schema getAnnotatedUnion(Union union, Map<String, Schema> names)
{    List<Schema> branches = new ArrayList<>();    for (Class branch : union.value()) branches.add(createSchema(branch, names));    return Schema.createUnion(branches);}
10fc149d3626394d74ef8547ccd60104a51990818c31994de83dc4d62865e741
makeNullable
public static Schema makeNullable(Schema schema)
{    if (schema.getType() == Schema.Type.UNION) {                for (Schema subType : schema.getTypes()) {            if (subType.getType() == Schema.Type.NULL) {                return schema;            }        }                List<Schema> withNull = new ArrayList<>();        withNull.add(Schema.create(Schema.Type.NULL));        withNull.addAll(schema.getTypes());        return Schema.createUnion(withNull);    } else {                return Schema.createUnion(Arrays.asList(Schema.create(Schema.Type.NULL), schema));    }}
bd211f810f91a01ab1fcd34b66f90d8ced960f3cd7ca0ce59441fb92df016af3
getCachedFields
private static Field[] getCachedFields(Class<?> recordClass)
{    Field[] fieldsList = FIELDS_CACHE.get(recordClass);    if (fieldsList != null)        return fieldsList;    fieldsList = getFields(recordClass, true);    FIELDS_CACHE.put(recordClass, fieldsList);    return fieldsList;}
54747afae138c203f6629d4de65d555c5529459e879588e3257490982792d8c9
getFields
private static Field[] getFields(Class<?> recordClass, boolean excludeJava)
{    Field[] fieldsList;    Map<String, Field> fields = new LinkedHashMap<>();    Class<?> c = recordClass;    do {        if (excludeJava && c.getPackage() != null && c.getPackage().getName().startsWith("java."))                        break;        for (Field field : c.getDeclaredFields()) if ((field.getModifiers() & (Modifier.TRANSIENT | Modifier.STATIC)) == 0)            if (fields.put(field.getName(), field) != null)                throw new AvroTypeException(c + " contains two fields named: " + field);        c = c.getSuperclass();    } while (c != null);    fieldsList = fields.values().toArray(new Field[0]);    return fieldsList;}
f0cc5ae38d1a2d1b9a6cf74d2e8f1719141353d5818b0deea141f4d6e9ad1249
createFieldSchema
protected Schema createFieldSchema(Field field, Map<String, Schema> names)
{    AvroEncode enc = field.getAnnotation(AvroEncode.class);    if (enc != null)        try {            return enc.using().getDeclaredConstructor().newInstance().getSchema();        } catch (Exception e) {            throw new AvroRuntimeException("Could not create schema from custom serializer for " + field.getName());        }    AvroSchema explicit = field.getAnnotation(AvroSchema.class);    if (    explicit != null)        return new Schema.Parser().parse(explicit.value());    Union union = field.getAnnotation(Union.class);    if (union != null)        return getAnnotatedUnion(union, names);    Schema schema = createSchema(field.getGenericType(), names);    if (field.isAnnotationPresent(Stringable.class)) {                schema = Schema.create(Schema.Type.STRING);    }    if (    field.isAnnotationPresent(Nullable.class))        schema = makeNullable(schema);    return schema;}
20fdd2ad4c5bb3e4e60a846fdb617933768777f451eb95cbf9630e145ef13fdd
getProtocol
public Protocol getProtocol(Class iface)
{    Protocol protocol = new Protocol(iface.getSimpleName(), iface.getPackage() == null ? "" : iface.getPackage().getName());    Map<String, Schema> names = new LinkedHashMap<>();    Map<String, Message> messages = protocol.getMessages();    Map<TypeVariable<?>, Type> genericTypeVariableMap = ReflectionUtil.resolveTypeVariables(iface);    for (Method method : iface.getMethods()) {        if ((method.getModifiers() & Modifier.STATIC) == 0) {            String name = method.getName();            if (messages.containsKey(name))                throw new AvroTypeException("Two methods with same name: " + name);            messages.put(name, getMessage(method, protocol, names, genericTypeVariableMap));        }    }        List<Schema> types = new ArrayList<>(names.values());    Collections.reverse(types);    protocol.setTypes(types);    return protocol;}
891099443f347fc050b3224f9b65cdb5099286c01d07055c1234f604c07e2093
getMessage
private Message getMessage(Method method, Protocol protocol, Map<String, Schema> names, Map<? extends Type, Type> genericTypeMap)
{    List<Schema.Field> fields = new ArrayList<>();    for (Parameter parameter : method.getParameters()) {        Schema paramSchema = getSchema(genericTypeMap.getOrDefault(parameter.getParameterizedType(), parameter.getType()), names);        for (Annotation annotation : parameter.getAnnotations()) {            if (            annotation instanceof AvroSchema)                paramSchema = new Schema.Parser().parse(((AvroSchema) annotation).value());            else if (            annotation instanceof Union)                paramSchema = getAnnotatedUnion(((Union) annotation), names);            else if (            annotation instanceof Nullable)                paramSchema = makeNullable(paramSchema);        }        fields.add(new Schema.Field(parameter.getName(), paramSchema, null, /* doc */        null));    }    Schema request = Schema.createRecord(fields);    Type genericReturnType = method.getGenericReturnType();    Type returnType = genericTypeMap.getOrDefault(genericReturnType, genericReturnType);    Union union = method.getAnnotation(Union.class);    Schema response = union == null ? getSchema(returnType, names) : getAnnotatedUnion(union, names);    if (    method.isAnnotationPresent(Nullable.class))        response = makeNullable(response);    AvroSchema explicit = method.getAnnotation(AvroSchema.class);    if (    explicit != null)        response = new Schema.Parser().parse(explicit.value());    List<Schema> errs = new ArrayList<>();        errs.add(Protocol.SYSTEM_ERROR);    for (Type err : method.getGenericExceptionTypes()) errs.add(getSchema(err, names));    Schema errors = Schema.createUnion(errs);    return protocol.createMessage(method.getName(), null, /* doc */    new LinkedHashMap<String, String>(), /* propMap */    request, response, errors);}
790ed77182bc19aa59ca927815ade523b25f0a3916a7d0215e625c890df7254d
getSchema
private Schema getSchema(Type type, Map<String, Schema> names)
{    try {        return createSchema(type, names);    } catch (AvroTypeException e) {                throw new AvroTypeException("Error getting schema for " + type + ": " + e.getMessage(), e);    }}
693fe1bba7c4377dda6767f2284e0c31876667e482d6316360ac97a9d2280afd
compare
protected int compare(Object o1, Object o2, Schema s, boolean equals)
{    switch(s.getType()) {        case ARRAY:            if (!o1.getClass().isArray())                break;            Schema elementType = s.getElementType();            int l1 = java.lang.reflect.Array.getLength(o1);            int l2 = java.lang.reflect.Array.getLength(o2);            int l = Math.min(l1, l2);            for (int i = 0; i < l; i++) {                int compare = compare(java.lang.reflect.Array.get(o1, i), java.lang.reflect.Array.get(o2, i), elementType, equals);                if (compare != 0)                    return compare;            }            return Integer.compare(l1, l2);        case BYTES:            if (!o1.getClass().isArray())                break;            byte[] b1 = (byte[]) o1;            byte[] b2 = (byte[]) o2;            return BinaryData.compareBytes(b1, 0, b1.length, b2, 0, b2.length);    }    return super.compare(o1, o2, s, equals);}
0d444d11f35623a106b078917619d310055e3ac4ece48255899791ab6864a69a
getRecordState
protected Object getRecordState(Object record, Schema schema)
{    return getFieldAccessors(record.getClass(), schema);}
4278f027eec4c98eb0c06e4bbc548bafec6fb1ec4772e79cf246005336fc2b2e
consumeAvroAliasAnnotation
private void consumeAvroAliasAnnotation(Class<?> c, Schema schema)
{    AvroAlias[] aliases = c.getAnnotationsByType(AvroAlias.class);    for (AvroAlias alias : aliases) {        String space = alias.space();        if (AvroAlias.NULL.equals(space))            space = null;        schema.addAlias(alias.alias(), space);    }}
b6548f4ad2d77c882463ec02f46bfb8745cd896d6a91c208e05cb223849b70e8
consumeFieldAlias
private void consumeFieldAlias(Field field, Schema.Field recordField)
{    AvroAlias[] aliases = field.getAnnotationsByType(AvroAlias.class);    for (AvroAlias alias : aliases) {        if (!alias.space().equals(AvroAlias.NULL)) {            throw new AvroRuntimeException("Namespaces are not allowed on field aliases. " + "Offending field: " + recordField.name());        }        recordField.addAlias(alias.alias());    }}
e9f985f61755456b769f1756d4f69f9d6ecd02540acbc734c3fdaf9ef00419d1
createFixed
public Object createFixed(Object old, Schema schema)
{            LogicalType logicalType = schema.getLogicalType();    if (logicalType != null) {        Conversion<?> conversion = getConversionFor(schema.getLogicalType());        if (conversion != null) {            return new GenericData.Fixed(schema);        }    }    return super.createFixed(old, schema);}
29054906d4af7be8dc8790cace3ee77ee70e4d288fe6c3430ecd85a8301c0864
newRecord
public Object newRecord(Object old, Schema schema)
{            LogicalType logicalType = schema.getLogicalType();    if (logicalType != null) {        Conversion<?> conversion = getConversionFor(schema.getLogicalType());        if (conversion != null) {            return new GenericData.Record(schema);        }    }    return super.newRecord(old, schema);}
7b6478bb11455a8339c97fa72e2e0c6aceb763cfb0762f80b4dd1a5cab3a715e
newArray
protected Object newArray(Object old, int size, Schema schema)
{    Class<?> collectionClass = ReflectData.getClassProp(schema, SpecificData.CLASS_PROP);    Class<?> elementClass = ReflectData.getClassProp(schema, SpecificData.ELEMENT_PROP);    if (elementClass == null) {                        Conversion<?> elementConversion = getData().getConversionFor(schema.getElementType().getLogicalType());        if (elementConversion != null) {            elementClass = elementConversion.getConvertedType();        }    }    if (collectionClass == null && elementClass == null)                return super.newArray(old, size, schema);    if (collectionClass != null && !collectionClass.isArray()) {        if (old instanceof Collection) {            ((Collection<?>) old).clear();            return old;        }        if (collectionClass.isAssignableFrom(ArrayList.class))            return new ArrayList<>();        return SpecificData.newInstance(collectionClass, schema);    }    if (elementClass == null) {        elementClass = collectionClass.getComponentType();    }    if (elementClass == null) {        ReflectData data = (ReflectData) getData();        elementClass = data.getClass(schema.getElementType());    }    return Array.newInstance(elementClass, size);}
7d52c3389ede984a8d4ba356e6ebab0005dd1ebcc0d415117c10e7f7b41d2d0b
peekArray
protected Object peekArray(Object array)
{    return null;}
ca5ac785ef75d2f5aea164c36c1d8e10adced1b96dbf8b653b5f41aab3b0e9e7
addToArray
protected void addToArray(Object array, long pos, Object e)
{    throw new AvroRuntimeException("reflectDatumReader does not use addToArray");}
77d5b290c28f53bb07613a8be6e8a305f81973a17dfcca38d0c15a55225f2eea
readArray
protected Object readArray(Object old, Schema expected, ResolvingDecoder in) throws IOException
{    Schema expectedType = expected.getElementType();    long l = in.readArrayStart();    if (l <= 0) {        return newArray(old, 0, expected);    }    Object array = newArray(old, (int) l, expected);    if (array instanceof Collection) {        @SuppressWarnings("unchecked")        Collection<Object> c = (Collection<Object>) array;        return readCollection(c, expectedType, l, in);    } else if (array instanceof Map) {                if (ReflectData.isNonStringMapSchema(expected)) {            Collection<Object> c = new ArrayList<>();            readCollection(c, expectedType, l, in);            Map m = (Map) array;            for (Object ele : c) {                IndexedRecord rec = ((IndexedRecord) ele);                Object key = rec.get(ReflectData.NS_MAP_KEY_INDEX);                Object value = rec.get(ReflectData.NS_MAP_VALUE_INDEX);                m.put(key, value);            }            return array;        } else {            String msg = "Expected a schema of map with non-string keys but got " + expected;            throw new AvroRuntimeException(msg);        }    } else {        return readJavaArray(array, expectedType, l, in);    }}
4bdf55bb69d85e7884ee6a2ad2574a647c8b6c0c27d2a2bce283732761970374
readJavaArray
private Object readJavaArray(Object array, Schema expectedType, long l, ResolvingDecoder in) throws IOException
{    Class<?> elementType = array.getClass().getComponentType();    if (elementType.isPrimitive()) {        return readPrimitiveArray(array, elementType, l, in);    } else {        return readObjectArray((Object[]) array, expectedType, l, in);    }}
d835e26223a4e55d0dfaed14a5c05ae7922dc399462abeabb36eb5306cdc6636
readPrimitiveArray
private Object readPrimitiveArray(Object array, Class<?> c, long l, ResolvingDecoder in) throws IOException
{    return ArrayAccessor.readArray(array, c, l, in);}
6e1d76b08833bb12fc253b34da8332ff29692678289ac3dd0e3a285dbea593c2
readObjectArray
private Object readObjectArray(Object[] array, Schema expectedType, long l, ResolvingDecoder in) throws IOException
{    LogicalType logicalType = expectedType.getLogicalType();    Conversion<?> conversion = getData().getConversionFor(logicalType);    int index = 0;    if (logicalType != null && conversion != null) {        do {            int limit = index + (int) l;            while (index < limit) {                Object element = readWithConversion(null, expectedType, logicalType, conversion, in);                array[index] = element;                index++;            }        } while ((l = in.arrayNext()) > 0);    } else {        do {            int limit = index + (int) l;            while (index < limit) {                Object element = readWithoutConversion(null, expectedType, in);                array[index] = element;                index++;            }        } while ((l = in.arrayNext()) > 0);    }    return array;}
1783a13afe9325f88b74a2c3185f361e80aa5335ec82e3782c1ec990d026b9e2
readCollection
private Object readCollection(Collection<Object> c, Schema expectedType, long l, ResolvingDecoder in) throws IOException
{    LogicalType logicalType = expectedType.getLogicalType();    Conversion<?> conversion = getData().getConversionFor(logicalType);    if (logicalType != null && conversion != null) {        do {            for (int i = 0; i < l; i++) {                Object element = readWithConversion(null, expectedType, logicalType, conversion, in);                c.add(element);            }        } while ((l = in.arrayNext()) > 0);    } else {        do {            for (int i = 0; i < l; i++) {                Object element = readWithoutConversion(null, expectedType, in);                c.add(element);            }        } while ((l = in.arrayNext()) > 0);    }    return c;}
a0834ef5ec2d0a6e35ec0732d5a78c26d4ce86621a3b476c86c490ba40430ae4
readString
protected Object readString(Object old, Decoder in) throws IOException
{    return super.readString(null, in).toString();}
742901a750f7561684d1d9e33db837879409972712244704569037109c2ee0c7
createString
protected Object createString(String value)
{    return value;}
38a21e7f48f857d2650804b073b1aa6b1ce4c7d983dfe247f847ad7faecf91e2
readBytes
protected Object readBytes(Object old, Schema s, Decoder in) throws IOException
{    ByteBuffer bytes = in.readBytes(null);    Class<?> c = ReflectData.getClassProp(s, SpecificData.CLASS_PROP);    if (c != null && c.isArray()) {        byte[] result = new byte[bytes.remaining()];        bytes.get(result);        return result;    } else {        return bytes;    }}
0e1e9acd057d4701e6a3a7945c5ea190f1b0aa9ce7dbf7d60b87f35c34b3cde6
readInt
protected Object readInt(Object old, Schema expected, Decoder in) throws IOException
{    Object value = in.readInt();    String intClass = expected.getProp(SpecificData.CLASS_PROP);    if (Byte.class.getName().equals(intClass))        value = ((Integer) value).byteValue();    else if (Short.class.getName().equals(intClass))        value = ((Integer) value).shortValue();    else if (Character.class.getName().equals(intClass))        value = (char) (int) (Integer) value;    return value;}
3b11a1352547489749de7c5c6c19409b0099fae53eed28c0357ee828afa07b15
readField
protected void readField(Object record, Field f, Object oldDatum, ResolvingDecoder in, Object state) throws IOException
{    if (state != null) {        FieldAccessor accessor = ((FieldAccessor[]) state)[f.pos()];        if (accessor != null) {            if (accessor.supportsIO() && (!Schema.Type.UNION.equals(f.schema().getType()) || accessor.isCustomEncoded())) {                accessor.read(record, in);                return;            }            if (accessor.isStringable()) {                try {                    String asString = (String) read(null, f.schema(), in);                    accessor.set(record, asString == null ? null : newInstanceFromString(accessor.getField().getType(), asString));                    return;                } catch (Exception e) {                    throw new AvroRuntimeException("Failed to read Stringable", e);                }            }            LogicalType logicalType = f.schema().getLogicalType();            if (logicalType != null) {                Conversion<?> conversion = getData().getConversionByClass(accessor.getField().getType(), logicalType);                if (conversion != null) {                    try {                        accessor.set(record, convert(readWithoutConversion(oldDatum, f.schema(), in), f.schema(), logicalType, conversion));                    } catch (IllegalAccessException e) {                        throw new AvroRuntimeException("Failed to set " + f);                    }                    return;                }            }            try {                accessor.set(record, readWithoutConversion(oldDatum, f.schema(), in));                return;            } catch (IllegalAccessException e) {                throw new AvroRuntimeException("Failed to set " + f);            }        }    }    super.readField(record, f, oldDatum, in, state);}
8e0159f1f906fcc7cd471bf035f56eaf9df0762a0f0186a99d7db9d3a9c72c23
writeArray
protected void writeArray(Schema schema, Object datum, Encoder out) throws IOException
{    if (datum instanceof Collection) {        super.writeArray(schema, datum, out);        return;    }    Class<?> elementClass = datum.getClass().getComponentType();    if (null == elementClass) {                throw new AvroRuntimeException("Array data must be a Collection or Array");    }    Schema element = schema.getElementType();    if (elementClass.isPrimitive()) {        Schema.Type type = element.getType();        out.writeArrayStart();        switch(type) {            case BOOLEAN:                if (elementClass.isPrimitive())                    ArrayAccessor.writeArray((boolean[]) datum, out);                break;            case DOUBLE:                ArrayAccessor.writeArray((double[]) datum, out);                break;            case FLOAT:                ArrayAccessor.writeArray((float[]) datum, out);                break;            case INT:                if (elementClass.equals(int.class)) {                    ArrayAccessor.writeArray((int[]) datum, out);                } else if (elementClass.equals(char.class)) {                    ArrayAccessor.writeArray((char[]) datum, out);                } else if (elementClass.equals(short.class)) {                    ArrayAccessor.writeArray((short[]) datum, out);                } else {                    arrayError(elementClass, type);                }                break;            case LONG:                ArrayAccessor.writeArray((long[]) datum, out);                break;            default:                arrayError(elementClass, type);        }        out.writeArrayEnd();    } else {        out.writeArrayStart();        writeObjectArray(element, (Object[]) datum, out);        out.writeArrayEnd();    }}
8fe08da6080ea8705eb969c6bc79975f03203216b11a38c396dd8ff86917b73e
writeObjectArray
private void writeObjectArray(Schema element, Object[] data, Encoder out) throws IOException
{    int size = data.length;    out.setItemCount(size);    for (Object datum : data) {        this.write(element, datum, out);    }}
3312e44cb7b5ba358395ce4c7a2dba87557260453fd5fe92fb5b96cf9702be02
arrayError
private void arrayError(Class<?> cl, Schema.Type type)
{    throw new AvroRuntimeException("Error writing array with inner type " + cl + " and avro type: " + type);}
7e2854bd80d8b97a030073ac1adfa38a98546f188df05d53b4035e30b0129a18
writeBytes
protected void writeBytes(Object datum, Encoder out) throws IOException
{    if (datum instanceof byte[])        out.writeBytes((byte[]) datum);    else        super.writeBytes(datum, out);}
7005d3b39d1ee319568585f964aa76be79fe2ae97c0065ebb85fc9e91fea53ba
write
protected void write(Schema schema, Object datum, Encoder out) throws IOException
{    if (datum instanceof Byte)        datum = ((Byte) datum).intValue();    else if (datum instanceof Short)        datum = ((Short) datum).intValue();    else if (datum instanceof Character)        datum = (int) (char) (Character) datum;    else if (datum instanceof Map && ReflectData.isNonStringMapSchema(schema)) {                                Set entries = ((Map) datum).entrySet();        List<Map.Entry> entryList = new ArrayList<>(entries.size());        for (Object obj : ((Map) datum).entrySet()) {            Map.Entry e = (Map.Entry) obj;            entryList.add(new MapEntry(e.getKey(), e.getValue()));        }        datum = entryList;    }    try {        super.write(schema, datum, out);    } catch (NullPointerException e) {                NullPointerException result = new NullPointerException("in " + schema.getFullName() + " " + e.getMessage());        result.initCause(e.getCause() == null ? e : e.getCause());        throw result;    }}
48b0a09d7116226e3b6015c5e3ade71293765e00af8e5a5fff29d09ef448bad2
writeField
protected void writeField(Object record, Field f, Encoder out, Object state) throws IOException
{    if (state != null) {        FieldAccessor accessor = ((FieldAccessor[]) state)[f.pos()];        if (accessor != null) {            if (accessor.supportsIO() && (!Schema.Type.UNION.equals(f.schema().getType()) || accessor.isCustomEncoded())) {                accessor.write(record, out);                return;            }            if (accessor.isStringable()) {                try {                    Object object = accessor.get(record);                    write(f.schema(), (object == null) ? null : object.toString(), out);                } catch (IllegalAccessException e) {                    throw new AvroRuntimeException("Failed to write Stringable", e);                }                return;            }        }    }    super.writeField(record, f, out, state);}
62681ebb44f23d6580e599430441ede22c43654cf6cb3e0f86cc9fe97f01e819
resetFieldAccess
 static void resetFieldAccess()
{            FieldAccess access = null;    try {        if (null == System.getProperty("avro.disable.unsafe")) {            FieldAccess unsafeAccess = load("org.apache.avro.reflect.FieldAccessUnsafe", FieldAccess.class);            if (validate(unsafeAccess)) {                access = unsafeAccess;            }        }    } catch (Throwable ignored) {    }    if (access == null) {        try {            FieldAccess reflectAccess = load("org.apache.avro.reflect.FieldAccessReflect", FieldAccess.class);            if (validate(reflectAccess)) {                access = reflectAccess;            }        } catch (Throwable oops) {            throw new AvroRuntimeException("Unable to load a functional FieldAccess class!");        }    }    fieldAccess = access;}
10440db710f45575a1a96c1759d0d33961887894009ebc90812883bd7276f8d8
load
private static T load(String name, Class<T> type) throws Exception
{    return ReflectionUtil.class.getClassLoader().loadClass(name).asSubclass(type).getDeclaredConstructor().newInstance();}
9a71d4db27a40317b47a13c8b957f8b5de1f125872ecf5941c41d5c22220f9f7
getFieldAccess
public static FieldAccess getFieldAccess()
{    return fieldAccess;}
bfc50825a52ea5bd93a484cf47bffc22236355b2a46f51f9bb887fdaa6c3ca63
validate
private static boolean validate(FieldAccess access) throws Exception
{    return new AccessorTestClass().validate(access);}
7307b4391b0bae79ed78758d3d315877c3383df887662e4a4e7eeea96ad5b147
validate
private boolean validate(FieldAccess access) throws Exception
{    boolean valid = true;    valid &= validField(access, "b", b, false);    valid &= validField(access, "by", by, (byte) 0xaf);    valid &= validField(access, "c", c, 'C');    valid &= validField(access, "s", s, (short) 321);    valid &= validField(access, "i", i, 111);    valid &= validField(access, "l", l, 54321L);    valid &= validField(access, "f", f, 0.2f);    valid &= validField(access, "d", d, 0.4d);    valid &= validField(access, "o", o, new Object());    valid &= validField(access, "i2", i2, -555);    return valid;}
96004565213ff676cf09ff2a61471f018c8fa253bf5cc97e19d1a97b80d62605
validField
private boolean validField(FieldAccess access, String name, Object original, Object toSet) throws Exception
{    FieldAccessor a;    boolean valid = true;    a = accessor(access, name);    valid &= original.equals(a.get(this));    a.set(this, toSet);    valid &= !original.equals(a.get(this));    return valid;}
7992d5f1d54d11c2a4d1f41b051cb6f3f36c3dcd57030bd9dcc1a40d16461ae8
accessor
private FieldAccessor accessor(FieldAccess access, String name) throws Exception
{    return access.getAccessor(this.getClass().getDeclaredField(name));}
9889411cf14c9101d7a39e3504ce118930b622a505ec80ab29acd827058b6b3a
resolveTypeVariables
protected static Map<TypeVariable<?>, Type> resolveTypeVariables(Class<?> iface)
{    return resolveTypeVariables(iface, new IdentityHashMap<>());}
295ee99b075aa688e831ae18e9a67ef543bd42877a99620f1837522d349bd5f2
resolveTypeVariables
private static Map<TypeVariable<?>, Type> resolveTypeVariables(Class<?> iface, Map<TypeVariable<?>, Type> reuse)
{    for (Type type : iface.getGenericInterfaces()) {        if (type instanceof ParameterizedType) {            ParameterizedType parameterizedType = (ParameterizedType) type;            Type rawType = parameterizedType.getRawType();            if (rawType instanceof Class<?>) {                Class<?> classType = (Class<?>) rawType;                TypeVariable<? extends Class<?>>[] typeParameters = classType.getTypeParameters();                Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();                for (int i = 0; i < typeParameters.length; i++) {                    reuse.putIfAbsent(typeParameters[i], reuse.getOrDefault(actualTypeArguments[i], actualTypeArguments[i]));                }                resolveTypeVariables(classType, reuse);            }        }    }    return reuse;}
6401fec13ffcd4b01bd98554c448b216c29eabaa724d96ec2ef80a99558bf833
resolve
public static Action resolve(Schema writer, Schema reader, GenericData data)
{    return resolve(Schema.applyAliases(writer, reader), reader, data, new HashMap<>());}
8ca98b2d489d5976abcc99dc85a1485b58198c048989e2f3c1118bd312b539b8
resolve
public static Action resolve(Schema writer, Schema reader)
{    return resolve(writer, reader, GenericData.get());}
a086b2dfb743b619665c5370c17dbd2363ebd2a0b410900daef70e932842964d
resolve
private static Action resolve(Schema w, Schema r, GenericData d, Map<SeenPair, Action> seen)
{    final Schema.Type wType = w.getType();    final Schema.Type rType = r.getType();    if (wType == Schema.Type.UNION)        return WriterUnion.resolve(w, r, d, seen);    if (wType == rType) {        switch(wType) {            case NULL:            case BOOLEAN:            case INT:            case LONG:            case FLOAT:            case DOUBLE:            case STRING:            case BYTES:                return new DoNothing(w, r, d);            case FIXED:                if (w.getFullName() != null && !w.getFullName().equals(r.getFullName()))                    return new ErrorAction(w, r, d, ErrorType.NAMES_DONT_MATCH);                else if (w.getFixedSize() != r.getFixedSize())                    return new ErrorAction(w, r, d, ErrorType.SIZES_DONT_MATCH);                else                    return new DoNothing(w, r, d);            case ARRAY:                Action et = resolve(w.getElementType(), r.getElementType(), d, seen);                return new Container(w, r, d, et);            case MAP:                Action vt = resolve(w.getValueType(), r.getValueType(), d, seen);                return new Container(w, r, d, vt);            case ENUM:                return EnumAdjust.resolve(w, r, d);            case RECORD:                return RecordAdjust.resolve(w, r, d, seen);            default:                throw new IllegalArgumentException("Unknown type for schema: " + wType);        }    } else if (rType == Schema.Type.UNION)        return ReaderUnion.resolve(w, r, d, seen);    else        return Promote.resolve(w, r, d);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    switch(this.error) {        case INCOMPATIBLE_SCHEMA_TYPES:        case NAMES_DONT_MATCH:        case SIZES_DONT_MATCH:        case NO_MATCHING_BRANCH:            return "Found " + writer.getFullName() + ", expecting " + reader.getFullName();        case MISSING_REQUIRED_FIELD:            {                List<Field> wfields = writer.getFields();                List<Field> rfields = reader.getFields();                String fname = "<oops>";                for (Field rf : rfields) if (writer.getField(rf.name()) == null && rf.defaultValue() == null)                    fname = rf.name();                return ("Found " + writer.getFullName() + ", expecting " + reader.getFullName() + ", missing required field " + fname);            }        default:            throw new IllegalArgumentException("Unknown error.");    }}
811df2b7efc3b4516eb19b847d55c4f5903fce275c1400f1e2069e7a19a327dd
resolve
public static Action resolve(Schema w, Schema r, GenericData d)
{    if (isValid(w, r))        return new Promote(w, r, d);    else        return new ErrorAction(w, r, d, ErrorType.INCOMPATIBLE_SCHEMA_TYPES);}
6511e265c179bf728b614c83f350c7c4ab406afabb3bebc3cc8623720972c2fc
isValid
public static boolean isValid(Schema w, Schema r)
{    if (w.getType() == r.getType())        throw new IllegalArgumentException("Only use when reader and writer are different.");    Schema.Type wt = w.getType();    switch(r.getType()) {        case INT:            switch(wt) {                case INT:                    return true;            }            break;        case LONG:            switch(wt) {                case INT:                case LONG:                    return true;            }            break;        case FLOAT:            switch(wt) {                case INT:                case LONG:                case FLOAT:                    return true;            }            break;        case DOUBLE:            switch(wt) {                case INT:                case LONG:                case FLOAT:                case DOUBLE:                    return true;            }            break;        case BYTES:        case STRING:            switch(wt) {                case STRING:                case BYTES:                    return true;            }            break;    }    return false;}
811df2b7efc3b4516eb19b847d55c4f5903fce275c1400f1e2069e7a19a327dd
resolve
public static Action resolve(Schema w, Schema r, GenericData d)
{    if (w.getFullName() != null && !w.getFullName().equals(r.getFullName()))        return new ErrorAction(w, r, d, ErrorType.NAMES_DONT_MATCH);    final List<String> wsymbols = w.getEnumSymbols();    final List<String> rsymbols = r.getEnumSymbols();    final int defaultIndex = (r.getEnumDefault() == null ? -1 : rsymbols.indexOf(r.getEnumDefault()));    int[] adjustments = new int[wsymbols.size()];    for (int i = 0; i < adjustments.length; i++) {        int j = rsymbols.indexOf(wsymbols.get(i));        adjustments[i] = (0 <= j ? j : defaultIndex);    }    return new EnumAdjust(w, r, d, adjustments);}
373c385f59bb8cf8dced8e06798a2f9ef7475aede9eae7bcbc1c6cee5c9917bd
noReorder
public boolean noReorder()
{    boolean result = true;    for (int i = 0; result && i < readerOrder.length; i++) result &= (i == readerOrder[i].pos());    return result;}
683d953b59790a3a24de5e72b0e1e2eb0398ca48a4a8aad907434b71d6c5a995
resolve
 static Action resolve(Schema w, Schema r, GenericData d, Map<SeenPair, Action> seen)
{    SeenPair wr = new SeenPair(w, r);    Action result = seen.get(wr);    if (result != null)        return result;    /*       * Current implementation doesn't do this check. To pass regressions tests, we       * can't either. if (w.getFullName() != null && !       * w.getFullName().equals(r.getFullName())) { result = new ErrorAction(w, r, d,       * ErrorType.NAMES_DONT_MATCH); seen.put(wr, result); return result; }       */    List<Field> wfields = w.getFields();    List<Field> rfields = r.getFields();    int firstDefault = 0;    for (Schema.Field wf : wfields) if (r.getField(wf.name()) != null)        firstDefault++;    Action[] actions = new Action[wfields.size()];    Field[] reordered = new Field[rfields.size()];    Object[] defaults = new Object[reordered.length - firstDefault];    result = new RecordAdjust(w, r, d, actions, reordered, firstDefault, defaults);        seen.put(wr, result);    int i = 0;    int ridx = 0;    for (Field wField : wfields) {        Field rField = r.getField(wField.name());        if (rField != null) {            reordered[ridx++] = rField;            actions[i++] = Resolver.resolve(wField.schema(), rField.schema(), d, seen);        } else            actions[i++] = new Skip(wField.schema(), d);    }    for (Field rf : rfields) if (w.getField(rf.name()) == null)        if (rf.defaultValue() == null) {            result = new ErrorAction(w, r, d, ErrorType.MISSING_REQUIRED_FIELD);            seen.put(wr, result);            return result;        } else {            defaults[ridx - firstDefault] = d.getDefaultValue(rf);            reordered[ridx++] = rf;        }    return result;}
f05163a89e229da5400750abe002b01d1763caacb34e491c65b4d6be4243e6ef
resolve
public static Action resolve(Schema w, Schema r, GenericData d, Map<SeenPair, Action> seen)
{    boolean ueqv = unionEquiv(w, r, new HashMap<>());    List<Schema> wb = w.getTypes();    List<Schema> rb = (ueqv ? r.getTypes() : null);    int sz = wb.size();    Action[] actions = new Action[sz];    for (int i = 0; i < sz; i++) actions[i] = Resolver.resolve(wb.get(i), (ueqv ? rb.get(i) : r), d, seen);    return new WriterUnion(w, r, d, ueqv, actions);}
f05163a89e229da5400750abe002b01d1763caacb34e491c65b4d6be4243e6ef
resolve
public static Action resolve(Schema w, Schema r, GenericData d, Map<SeenPair, Action> seen)
{    if (w.getType() == Schema.Type.UNION)        throw new IllegalArgumentException("Writer schema is union.");    int i = firstMatchingBranch(w, r, d, seen);    if (0 <= i)        return new ReaderUnion(w, r, d, i, Resolver.resolve(w, r.getTypes().get(i), d, seen));    return new ErrorAction(w, r, d, ErrorType.NO_MATCHING_BRANCH);}
d4e0a8e69317032ee618de8c229de51d384cd1c3821fccd44d30a4eb4717053f
firstMatchingBranch
private static int firstMatchingBranch(Schema w, Schema r, GenericData d, Map<SeenPair, Action> seen)
{    Schema.Type vt = w.getType();        int j = 0;    int structureMatch = -1;    for (Schema b : r.getTypes()) {        if (vt == b.getType())            if (vt == Schema.Type.RECORD || vt == Schema.Type.ENUM || vt == Schema.Type.FIXED) {                String vname = w.getFullName();                String bname = b.getFullName();                                if (vname != null && vname.equals(bname))                    return j;                if (vt == Schema.Type.RECORD && !hasMatchError(RecordAdjust.resolve(w, b, d, seen))) {                    String vShortName = w.getName();                    String bShortName = b.getName();                                        if ((structureMatch < 0) || (vShortName != null && vShortName.equals(bShortName))) {                        structureMatch = j;                    }                }            } else                return j;        j++;    }        if (structureMatch >= 0)        return structureMatch;        j = 0;    for (Schema b : r.getTypes()) {        switch(vt) {            case INT:                switch(b.getType()) {                    case LONG:                    case DOUBLE:                    case FLOAT:                        return j;                }                break;            case LONG:                switch(b.getType()) {                    case DOUBLE:                    case FLOAT:                        return j;                }                break;            case FLOAT:                switch(b.getType()) {                    case DOUBLE:                        return j;                }                break;            case STRING:                switch(b.getType()) {                    case BYTES:                        return j;                }                break;            case BYTES:                switch(b.getType()) {                    case STRING:                        return j;                }                break;        }        j++;    }    return -1;}
7357e2f9e760656d76d3672c0e3bd42dda9efedbe48c1e290f66e8f0f3780e90
hasMatchError
private static boolean hasMatchError(Action action)
{    if (action instanceof ErrorAction)        return true;    else        for (Action a : ((RecordAdjust) action).fieldActions) if (a instanceof ErrorAction)            return true;    return false;}
55c2695cae4e5510e72965e16936388add8324e418678e263baf8e0cef5e6351
unionEquiv
private static boolean unionEquiv(Schema w, Schema r, Map<SeenPair, Boolean> seen)
{    Schema.Type wt = w.getType();    if (wt != r.getType())        return false;        if ((wt == Schema.Type.RECORD || wt == Schema.Type.FIXED || wt == Schema.Type.ENUM) && !(w.getName() == null || w.getName().equals(r.getName())))        return false;    switch(w.getType()) {        case NULL:        case BOOLEAN:        case INT:        case LONG:        case FLOAT:        case DOUBLE:        case STRING:        case BYTES:            return true;        case ARRAY:            return unionEquiv(w.getElementType(), r.getElementType(), seen);        case MAP:            return unionEquiv(w.getValueType(), r.getValueType(), seen);        case FIXED:            return w.getFixedSize() == r.getFixedSize();        case ENUM:            {                List<String> ws = w.getEnumSymbols();                List<String> rs = r.getEnumSymbols();                if (ws.size() != rs.size())                    return false;                int i = 0;                for (i = 0; i < ws.size(); i++) if (!ws.get(i).equals(rs.get(i)))                    break;                return i == ws.size();            }        case UNION:            {                List<Schema> wb = w.getTypes();                List<Schema> rb = r.getTypes();                if (wb.size() != rb.size())                    return false;                int i = 0;                for (i = 0; i < wb.size(); i++) if (!unionEquiv(wb.get(i), rb.get(i), seen))                    break;                return i == wb.size();            }        case RECORD:            {                SeenPair wsc = new SeenPair(w, r);                if (!seen.containsKey(wsc)) {                                        seen.put(wsc, true);                    List<Field> wb = w.getFields();                    List<Field> rb = r.getFields();                    if (wb.size() != rb.size())                        seen.put(wsc, false);                    else {                        int i = 0;                        for (i = 0; i < wb.size(); i++) if (!unionEquiv(wb.get(i).schema(), rb.get(i).schema(), seen))                            break;                        seen.put(wsc, (i == wb.size()));                    }                }                return seen.get(wsc);            }        default:            throw new IllegalArgumentException("Unknown schema type: " + w.getType());    }}
cda92268b252d82637141782f44f9e5cb265fe0cf912b1d74968340382f7282f
writeReplace
protected Object writeReplace()
{    SerializableSchema ss = new SerializableSchema();    ss.schemaString = toString();    return ss;}
137ce78a02f765c99ce22bc4cf4a8dc4880a7f58319489dd72ca9bd9f9ce55c4
readResolve
private Object readResolve()
{    return new Schema.Parser().parse(schemaString);}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return name;}
13003b86e2a67a2580f9e45e5368b8a79c5fe7869da1ee22adfe0b8868960749
create
public static Schema create(Type type)
{    switch(type) {        case STRING:            return new StringSchema();        case BYTES:            return new BytesSchema();        case INT:            return new IntSchema();        case LONG:            return new LongSchema();        case FLOAT:            return new FloatSchema();        case DOUBLE:            return new DoubleSchema();        case BOOLEAN:            return new BooleanSchema();        case NULL:            return new NullSchema();        default:            throw new AvroRuntimeException("Can't create a: " + type);    }}
7be3af9c1e6b6b7541a6237a7d09bd325457bd8e891e1b000a96d3692be536be
addProp
public void addProp(String name, String value)
{    super.addProp(name, value);    hashCode = NO_HASHCODE;}
82358048e1ba682db68ba1b1f55b2a8c018ccdab351fa9b502adf8709f592cf8
addProp
public void addProp(String name, Object value)
{    super.addProp(name, value);    hashCode = NO_HASHCODE;}
2427764fd1b59a6e8d6f1e8ff0b2f46d1110cff664a546213ae997a620663e14
getLogicalType
public LogicalType getLogicalType()
{    return logicalType;}
3668a0beeafa5a52d5318b0f36dadfe8a268a11b2badd96a39e6f5a9135fa005
setLogicalType
 void setLogicalType(LogicalType logicalType)
{    this.logicalType = logicalType;}
7cd40d5daa9567d8f7fe56ea8caef42f21d3b881c2da3a90f3f62090f274720b
createRecord
public static Schema createRecord(List<Field> fields)
{    Schema result = createRecord(null, null, null, false);    result.setFields(fields);    return result;}
2139fa870099483951084e1199cdf2cc9f6fd3c25afcf5fcd17f2f7ff80feb46
createRecord
public static Schema createRecord(String name, String doc, String namespace, boolean isError)
{    return new RecordSchema(new Name(name, namespace), doc, isError);}
1db0fcd77295e3723ad29528405c9f9632f36fa7b40e6d1dce98534bfebf96ce
createRecord
public static Schema createRecord(String name, String doc, String namespace, boolean isError, List<Field> fields)
{    return new RecordSchema(new Name(name, namespace), doc, isError, fields);}
e88d2a01b19d95741eb566286d8d2b689f8c1cd2142731c338153e0e290f4fc3
createEnum
public static Schema createEnum(String name, String doc, String namespace, List<String> values)
{    return new EnumSchema(new Name(name, namespace), doc, new LockableArrayList<>(values), null);}
da6337de751357d04c8ac806c3ec4eb44b26edf3deb7a518aa20d89d947a1387
createEnum
public static Schema createEnum(String name, String doc, String namespace, List<String> values, String enumDefault)
{    return new EnumSchema(new Name(name, namespace), doc, new LockableArrayList<>(values), enumDefault);}
c2456b810d9a07e1832b4d964ebc6ae20a76f3ea09f4cb362933328c0320ab05
createArray
public static Schema createArray(Schema elementType)
{    return new ArraySchema(elementType);}
2463048282cce3d6a83e711c857e069210f86a92cd27debd753e111a70149629
createMap
public static Schema createMap(Schema valueType)
{    return new MapSchema(valueType);}
a0cdad8cceb1ebe5c9b45338747df1ffd271311c913cd4d07d2f35487b53cfaf
createUnion
public static Schema createUnion(List<Schema> types)
{    return new UnionSchema(new LockableArrayList<>(types));}
66508a11337655581cfa8d0aaa9eff53da3a2e43ad7ef8fb48055f127b9d1087
createUnion
public static Schema createUnion(Schema... types)
{    return createUnion(new LockableArrayList<>(types));}
b30fec3794780856c61cd7d3325d5f52a8b8761ac49ed7bf569ccb7915e42e7b
createFixed
public static Schema createFixed(String name, String doc, String space, int size)
{    return new FixedSchema(new Name(name, space), doc, size);}
b36c0cb78d388571653840506cba5d90e12b262c755658912fc2224c314bcbf6
getType
public Type getType()
{    return type;}
b465333bf63c0013f3655c5f7f2bf05b2565bbff5bfd7699186d440f50887ce3
getField
public Field getField(String fieldname)
{    throw new AvroRuntimeException("Not a record: " + this);}
43fa7b53315497aba6e86b4fae0ba81b558020d6ec6c6c9801bc0ca1c2af3e7e
getFields
public List<Field> getFields()
{    throw new AvroRuntimeException("Not a record: " + this);}
a988a2660e5c615be934fcf5810e5c66982945f4bb81ddc54756b806cbd01594
setFields
public void setFields(List<Field> fields)
{    throw new AvroRuntimeException("Not a record: " + this);}
23ffac876d34c956f291f24e04c798c0188f155f2903119b863e4dd69fd042db
getEnumSymbols
public List<String> getEnumSymbols()
{    throw new AvroRuntimeException("Not an enum: " + this);}
731878ceb2d7d5a55b84abb45601275097bf78d72aad49deb0fd066b4bac457e
getEnumDefault
public String getEnumDefault()
{    throw new AvroRuntimeException("Not an enum: " + this);}
ded9e689223a12eb93a2082f6c6cdbabb7db2d07eb12717ea2b0132472b493cf
getEnumOrdinal
public int getEnumOrdinal(String symbol)
{    throw new AvroRuntimeException("Not an enum: " + this);}
6097905b02ac099c888c3b811e2dd5c1eefe3554b078dc9f263ae3e541c862ef
hasEnumSymbol
public boolean hasEnumSymbol(String symbol)
{    throw new AvroRuntimeException("Not an enum: " + this);}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return type.name;}
5999360274d9a522474168c24725752a4aae8dc4e9365423eb9f82baf4400700
getDoc
public String getDoc()
{    return null;}
4c9ff74e20a72d5f7b2e4ef2a83e03a78836fed625f24259c12254b95b6af94e
getNamespace
public String getNamespace()
{    throw new AvroRuntimeException("Not a named type: " + this);}
2e28f0529eb6680366f46ed34b0f3734f6e0f4ab84823a5db23ac37c5f527d71
getFullName
public String getFullName()
{    return getName();}
50e60c0d9c0fd3d59567273ac4ae49e0c0ec36ec99043f7d8921b60ceab3cbf4
addAlias
public void addAlias(String alias)
{    throw new AvroRuntimeException("Not a named type: " + this);}
da540bb1f9c25ab8e6b66eec28d025c8e613b7f8ccd2d1276f3d27c707e0169e
addAlias
public void addAlias(String alias, String space)
{    throw new AvroRuntimeException("Not a named type: " + this);}
a0d480b3f43fbbf686c1649e9a02f1f6e8d5d3fea9c80322c7ce5dc94a94c91d
getAliases
public Set<String> getAliases()
{    throw new AvroRuntimeException("Not a named type: " + this);}
fd9504dee16080e07420afd6a5d3ae609db08e44a33146c0a95ec89a5654c2f0
isError
public boolean isError()
{    throw new AvroRuntimeException("Not a record: " + this);}
a97a76e0e16419b2b4ad9fe4d0bbc4c1b79e55859645236a07c832b031d54e3f
getElementType
public Schema getElementType()
{    throw new AvroRuntimeException("Not an array: " + this);}
89513bc79f138e02ede43fd67452d975bef03b3e692aebc0dd1ec719dea30ba0
getValueType
public Schema getValueType()
{    throw new AvroRuntimeException("Not a map: " + this);}
27394adefa313e35ceb0cb3000fc8f94fc70efe25403d3ea23ef229a6f93ec21
getTypes
public List<Schema> getTypes()
{    throw new AvroRuntimeException("Not a union: " + this);}
77c300ffeab917bc6745dcdd1fe0b7ee7788a18341a0cb5fae0c55f8843c333c
getIndexNamed
public Integer getIndexNamed(String name)
{    throw new AvroRuntimeException("Not a union: " + this);}
ae09754a606df2c090b563d347062af623a4748c97165114dfc6659928e97a97
getFixedSize
public int getFixedSize()
{    throw new AvroRuntimeException("Not fixed: " + this);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return toString(false);}
f11bbdaa9e14a22c2e415a843d09db39d07d2ccd758940db7fbe0bb1f0f385b7
toString
public String toString(boolean pretty)
{    try {        StringWriter writer = new StringWriter();        JsonGenerator gen = FACTORY.createGenerator(writer);        if (pretty)            gen.useDefaultPrettyPrinter();        toJson(new Names(), gen);        gen.flush();        return writer.toString();    } catch (IOException e) {        throw new AvroRuntimeException(e);    }}
cf579266fed50e27a8a04b645cb3cc0f1a0e17dd9d4419120aecbc4cbb3116ef
toJson
 void toJson(Names names, JsonGenerator gen) throws IOException
{    if (!hasProps()) {                        gen.writeString(getName());    } else {        gen.writeStartObject();        gen.writeStringField("type", getName());        writeProps(gen);        gen.writeEndObject();    }}
ac07fffcef90350c664cb3a36c561a557627a6e3f91dd6acc81bc28d53b3f640
fieldsToJson
 void fieldsToJson(Names names, JsonGenerator gen) throws IOException
{    throw new AvroRuntimeException("Not a record: " + this);}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (o == this)        return true;    if (!(o instanceof Schema))        return false;    Schema that = (Schema) o;    if (!(this.type == that.type))        return false;    return equalCachedHash(that) && propsEqual(that);}
4f4b30ef9e77d69826fc287e8231afec1214e492489fa08d216ef0155748d3f0
hashCode
public final int hashCode()
{    if (hashCode == NO_HASHCODE)        hashCode = computeHash();    return hashCode;}
e914c3b13e41025331386c8a07395a195efcda4c07392b973ebd2b424435084d
computeHash
 int computeHash()
{    return getType().hashCode() + propsHashCode();}
3a7f1f75ab1f38e6edacbfe913eaa532f42d41de48113b58a4775b8829b2ca43
equalCachedHash
 final boolean equalCachedHash(Schema other)
{    return (hashCode == other.hashCode) || (hashCode == NO_HASHCODE) || (other.hashCode == NO_HASHCODE);}
fd5e8cea6f759bf0ff44ef3632893f699ea9c435918ecb7b2d1ed8616bcaacf3
isUnion
public boolean isUnion()
{    return this instanceof UnionSchema;}
314e55b7bbed034c9046047880cc5df5c7ae7f0997ed1d105d24dd1fc90e1cbe
isNullable
public boolean isNullable()
{    if (!isUnion()) {        return getType().equals(Schema.Type.NULL);    }    for (Schema schema : getTypes()) {        if (schema.isNullable()) {            return true;        }    }    return false;}
ac00ef71529ca81c1fe90008038fb40e5ec8e651a2fd2bfbe7554e21c0a3765d
defaultValue
protected JsonNode defaultValue(Field field)
{    return field.defaultValue();}
c33fd6bdce770882b4fd431e7e3c782a1d8ee3915f9a8e4ef404cb4a1a6afda0
createField
protected Field createField(String name, Schema schema, String doc, JsonNode defaultValue)
{    return new Field(name, schema, doc, defaultValue, true, Order.ASCENDING);}
17258ec40b67bfff9a4bfc07511cbf2583adb4ed7dd1d95220af9542ccfffb45
createField
protected Field createField(String name, Schema schema, String doc, JsonNode defaultValue, boolean validate, Order order)
{    return new Field(name, schema, doc, defaultValue, validate, order);}
381128365d1314b5f05c81a0d52df7ef30ba6dfba5aedbf9c56defe916311f78
name
public String name()
{    return name;}
279137768cca3577c14b56545802b699f26c0448f95dbeade9090434e942ffc3
pos
public int pos()
{    return position;}
c52dad28bb284c1b557b01c79e8d70d378e1f5f78fa5aa60eba6515bed5959ab
schema
public Schema schema()
{    return schema;}
c73ee246a45b68bd5ead3ad544d86dd9cf9d4225080a496be258f66453550fb8
doc
public String doc()
{    return doc;}
3b7278fa881e4b64f47bfdc2b16d128030a632878952e70616c6499c1a9f0068
hasDefaultValue
public boolean hasDefaultValue()
{    return defaultValue != null;}
31890b5b33aea005b462db135aa0b4e75d12ec29d5c9f3a6ed6b850560d0aa33
defaultValue
 JsonNode defaultValue()
{    return defaultValue;}
684e7c3839ca2cd13027bf52a029e0f2130859382fb13c075661b6603e031d3a
defaultVal
public Object defaultVal()
{    return JacksonUtils.toObject(defaultValue, schema);}
f14ec06efac1b5e569e513083b18d358ef9634eef966fb432438308931ffa749
order
public Order order()
{    return order;}
50e60c0d9c0fd3d59567273ac4ae49e0c0ec36ec99043f7d8921b60ceab3cbf4
addAlias
public void addAlias(String alias)
{    if (aliases == null)        this.aliases = new LinkedHashSet<>();    aliases.add(alias);}
9eb6989f90469da6dabcc8662a0012d5704cd0635cbb2016f84b072daaff0916
aliases
public Set<String> aliases()
{    if (aliases == null)        return Collections.emptySet();    return Collections.unmodifiableSet(aliases);}
74e378df448c6c3cd090d6daf881cfac8957dd555869ea4c13a46bdc6cdcf9a6
equals
public boolean equals(Object other)
{    if (other == this)        return true;    if (!(other instanceof Field))        return false;    Field that = (Field) other;    return (name.equals(that.name)) && (schema.equals(that.schema)) && defaultValueEquals(that.defaultValue) && (order == that.order) && propsEqual(that);}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return name.hashCode() + schema.computeHash();}
b04800511b3b49659fbc76f51e163a6e6b4b8f7d5e365a1ae0bd92b3e93089db
defaultValueEquals
private boolean defaultValueEquals(JsonNode thatDefaultValue)
{    if (defaultValue == null)        return thatDefaultValue == null;    if (thatDefaultValue == null)        return false;    if (Double.isNaN(defaultValue.doubleValue()))        return Double.isNaN(thatDefaultValue.doubleValue());    return defaultValue.equals(thatDefaultValue);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return name + " type:" + schema.type + " pos:" + position;}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (o == this)        return true;    if (!(o instanceof Name))        return false;    Name that = (Name) o;    return Objects.equals(full, that.full);}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return full == null ? 0 : full.hashCode();}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return full;}
9d3482e43e2d761a62633e4aa1879781b1264ab4ba4085e589a756916c6a9345
writeName
public void writeName(Names names, JsonGenerator gen) throws IOException
{    if (name != null)        gen.writeStringField("name", name);    if (space != null) {        if (!space.equals(names.space()))            gen.writeStringField("namespace", space);    } else if (names.space() != null) {                gen.writeStringField("namespace", "");    }}
b8f8caa2b196b06676c71203e2a2489060be4c01974e198d5346de371b9208a1
getQualified
public String getQualified(String defaultSpace)
{    return (space == null || space.equals(defaultSpace)) ? name : full;}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return name.name;}
5999360274d9a522474168c24725752a4aae8dc4e9365423eb9f82baf4400700
getDoc
public String getDoc()
{    return doc;}
4c9ff74e20a72d5f7b2e4ef2a83e03a78836fed625f24259c12254b95b6af94e
getNamespace
public String getNamespace()
{    return name.space;}
2e28f0529eb6680366f46ed34b0f3734f6e0f4ab84823a5db23ac37c5f527d71
getFullName
public String getFullName()
{    return name.full;}
50e60c0d9c0fd3d59567273ac4ae49e0c0ec36ec99043f7d8921b60ceab3cbf4
addAlias
public void addAlias(String alias)
{    addAlias(alias, null);}
4589da35cc62c68d4ed14c0f0b69f07c9eabd4db2a94a57f660eff76f9397933
addAlias
public void addAlias(String name, String space)
{    if (aliases == null)        this.aliases = new LinkedHashSet<>();    if (space == null)        space = this.name.space;    aliases.add(new Name(name, space));}
a0d480b3f43fbbf686c1649e9a02f1f6e8d5d3fea9c80322c7ce5dc94a94c91d
getAliases
public Set<String> getAliases()
{    Set<String> result = new LinkedHashSet<>();    if (aliases != null)        for (Name alias : aliases) result.add(alias.full);    return result;}
33cfc8050a05097198963a4f598ee2000cb81078e48bca11a0b7cd3b7db4b405
writeNameRef
public boolean writeNameRef(Names names, JsonGenerator gen) throws IOException
{    if (this.equals(names.get(name))) {        gen.writeString(name.getQualified(names.space()));        return true;    } else if (name.name != null) {        names.put(name, this);    }    return false;}
9d3482e43e2d761a62633e4aa1879781b1264ab4ba4085e589a756916c6a9345
writeName
public void writeName(Names names, JsonGenerator gen) throws IOException
{    name.writeName(names, gen);}
c4d2d0ac3d3218dd1144c6deafb9d8b17d637c3798eacc6a07b151470ba3ebbf
equalNames
public boolean equalNames(NamedSchema that)
{    return this.name.equals(that.name);}
e914c3b13e41025331386c8a07395a195efcda4c07392b973ebd2b424435084d
computeHash
 int computeHash()
{    return super.computeHash() + name.hashCode();}
063b18da5dceaa9f5c6b9c51732c991709ef7e55a95df4aa4c8db37ae6f590a2
aliasesToJson
public void aliasesToJson(JsonGenerator gen) throws IOException
{    if (aliases == null || aliases.size() == 0)        return;    gen.writeFieldName("aliases");    gen.writeStartArray();    for (Name alias : aliases) gen.writeString(alias.getQualified(name.space));    gen.writeEndArray();}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (!(o instanceof SeenPair))        return false;    return this.s1 == ((SeenPair) o).s1 && this.s2 == ((SeenPair) o).s2;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return System.identityHashCode(s1) + System.identityHashCode(s2);}
fd9504dee16080e07420afd6a5d3ae609db08e44a33146c0a95ec89a5654c2f0
isError
public boolean isError()
{    return isError;}
b465333bf63c0013f3655c5f7f2bf05b2565bbff5bfd7699186d440f50887ce3
getField
public Field getField(String fieldname)
{    if (fieldMap == null)        throw new AvroRuntimeException("Schema fields not set yet");    return fieldMap.get(fieldname);}
43fa7b53315497aba6e86b4fae0ba81b558020d6ec6c6c9801bc0ca1c2af3e7e
getFields
public List<Field> getFields()
{    if (fields == null)        throw new AvroRuntimeException("Schema fields not set yet");    return fields;}
a988a2660e5c615be934fcf5810e5c66982945f4bb81ddc54756b806cbd01594
setFields
public void setFields(List<Field> fields)
{    if (this.fields != null) {        throw new AvroRuntimeException("Fields are already set");    }    int i = 0;    fieldMap = new HashMap<>();    LockableArrayList ff = new LockableArrayList();    for (Field f : fields) {        if (f.position != -1)            throw new AvroRuntimeException("Field already used: " + f);        f.position = i++;        final Field existingField = fieldMap.put(f.name(), f);        if (existingField != null) {            throw new AvroRuntimeException(String.format("Duplicate field %s in record %s: %s and %s.", f.name(), name, f, existingField));        }        ff.add(f);    }    this.fields = ff.lock();    this.hashCode = NO_HASHCODE;}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (o == this)        return true;    if (!(o instanceof RecordSchema))        return false;    RecordSchema that = (RecordSchema) o;    if (!equalCachedHash(that))        return false;    if (!equalNames(that))        return false;    if (!propsEqual(that))        return false;    Set seen = SEEN_EQUALS.get();    SeenPair here = new SeenPair(this, o);    if (seen.contains(here))                return true;    boolean first = seen.isEmpty();    try {        seen.add(here);        return Objects.equals(fields, that.fields);    } finally {        if (first)            seen.clear();    }}
e914c3b13e41025331386c8a07395a195efcda4c07392b973ebd2b424435084d
computeHash
 int computeHash()
{    Map seen = SEEN_HASHCODE.get();    if (seen.containsKey(this))                return 0;    boolean first = seen.isEmpty();    try {        seen.put(this, this);        return super.computeHash() + fields.hashCode();    } finally {        if (first)            seen.clear();    }}
cf579266fed50e27a8a04b645cb3cc0f1a0e17dd9d4419120aecbc4cbb3116ef
toJson
 void toJson(Names names, JsonGenerator gen) throws IOException
{    if (writeNameRef(names, gen))        return;        String savedSpace = names.space;    gen.writeStartObject();    gen.writeStringField("type", isError ? "error" : "record");    writeName(names, gen);        names.space = name.space;    if (getDoc() != null)        gen.writeStringField("doc", getDoc());    if (fields != null) {        gen.writeFieldName("fields");        fieldsToJson(names, gen);    }    writeProps(gen);    aliasesToJson(gen);    gen.writeEndObject();        names.space = savedSpace;}
ac07fffcef90350c664cb3a36c561a557627a6e3f91dd6acc81bc28d53b3f640
fieldsToJson
 void fieldsToJson(Names names, JsonGenerator gen) throws IOException
{    gen.writeStartArray();    for (Field f : fields) {        gen.writeStartObject();        gen.writeStringField("name", f.name());        gen.writeFieldName("type");        f.schema().toJson(names, gen);        if (f.doc() != null)            gen.writeStringField("doc", f.doc());        if (f.hasDefaultValue()) {            gen.writeFieldName("default");            gen.writeTree(f.defaultValue());        }        if (f.order() != Field.Order.ASCENDING)            gen.writeStringField("order", f.order().name);        if (f.aliases != null && f.aliases.size() != 0) {            gen.writeFieldName("aliases");            gen.writeStartArray();            for (String alias : f.aliases) gen.writeString(alias);            gen.writeEndArray();        }        f.writeProps(gen);        gen.writeEndObject();    }    gen.writeEndArray();}
23ffac876d34c956f291f24e04c798c0188f155f2903119b863e4dd69fd042db
getEnumSymbols
public List<String> getEnumSymbols()
{    return symbols;}
6097905b02ac099c888c3b811e2dd5c1eefe3554b078dc9f263ae3e541c862ef
hasEnumSymbol
public boolean hasEnumSymbol(String symbol)
{    return ordinals.containsKey(symbol);}
ded9e689223a12eb93a2082f6c6cdbabb7db2d07eb12717ea2b0132472b493cf
getEnumOrdinal
public int getEnumOrdinal(String symbol)
{    return ordinals.get(symbol);}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (o == this)        return true;    if (!(o instanceof EnumSchema))        return false;    EnumSchema that = (EnumSchema) o;    return equalCachedHash(that) && equalNames(that) && symbols.equals(that.symbols) && propsEqual(that);}
731878ceb2d7d5a55b84abb45601275097bf78d72aad49deb0fd066b4bac457e
getEnumDefault
public String getEnumDefault()
{    return enumDefault;}
e914c3b13e41025331386c8a07395a195efcda4c07392b973ebd2b424435084d
computeHash
 int computeHash()
{    return super.computeHash() + symbols.hashCode();}
cf579266fed50e27a8a04b645cb3cc0f1a0e17dd9d4419120aecbc4cbb3116ef
toJson
 void toJson(Names names, JsonGenerator gen) throws IOException
{    if (writeNameRef(names, gen))        return;    gen.writeStartObject();    gen.writeStringField("type", "enum");    writeName(names, gen);    if (getDoc() != null)        gen.writeStringField("doc", getDoc());    gen.writeArrayFieldStart("symbols");    for (String symbol : symbols) gen.writeString(symbol);    gen.writeEndArray();    if (getEnumDefault() != null)        gen.writeStringField("default", getEnumDefault());    writeProps(gen);    aliasesToJson(gen);    gen.writeEndObject();}
a97a76e0e16419b2b4ad9fe4d0bbc4c1b79e55859645236a07c832b031d54e3f
getElementType
public Schema getElementType()
{    return elementType;}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (o == this)        return true;    if (!(o instanceof ArraySchema))        return false;    ArraySchema that = (ArraySchema) o;    return equalCachedHash(that) && elementType.equals(that.elementType) && propsEqual(that);}
e914c3b13e41025331386c8a07395a195efcda4c07392b973ebd2b424435084d
computeHash
 int computeHash()
{    return super.computeHash() + elementType.computeHash();}
cf579266fed50e27a8a04b645cb3cc0f1a0e17dd9d4419120aecbc4cbb3116ef
toJson
 void toJson(Names names, JsonGenerator gen) throws IOException
{    gen.writeStartObject();    gen.writeStringField("type", "array");    gen.writeFieldName("items");    elementType.toJson(names, gen);    writeProps(gen);    gen.writeEndObject();}
89513bc79f138e02ede43fd67452d975bef03b3e692aebc0dd1ec719dea30ba0
getValueType
public Schema getValueType()
{    return valueType;}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (o == this)        return true;    if (!(o instanceof MapSchema))        return false;    MapSchema that = (MapSchema) o;    return equalCachedHash(that) && valueType.equals(that.valueType) && propsEqual(that);}
e914c3b13e41025331386c8a07395a195efcda4c07392b973ebd2b424435084d
computeHash
 int computeHash()
{    return super.computeHash() + valueType.computeHash();}
cf579266fed50e27a8a04b645cb3cc0f1a0e17dd9d4419120aecbc4cbb3116ef
toJson
 void toJson(Names names, JsonGenerator gen) throws IOException
{    gen.writeStartObject();    gen.writeStringField("type", "map");    gen.writeFieldName("values");    valueType.toJson(names, gen);    writeProps(gen);    gen.writeEndObject();}
27394adefa313e35ceb0cb3000fc8f94fc70efe25403d3ea23ef229a6f93ec21
getTypes
public List<Schema> getTypes()
{    return types;}
77c300ffeab917bc6745dcdd1fe0b7ee7788a18341a0cb5fae0c55f8843c333c
getIndexNamed
public Integer getIndexNamed(String name)
{    return indexByName.get(name);}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (o == this)        return true;    if (!(o instanceof UnionSchema))        return false;    UnionSchema that = (UnionSchema) o;    return equalCachedHash(that) && types.equals(that.types) && propsEqual(that);}
e914c3b13e41025331386c8a07395a195efcda4c07392b973ebd2b424435084d
computeHash
 int computeHash()
{    int hash = super.computeHash();    for (Schema type : types) hash += type.computeHash();    return hash;}
7be3af9c1e6b6b7541a6237a7d09bd325457bd8e891e1b000a96d3692be536be
addProp
public void addProp(String name, String value)
{    throw new AvroRuntimeException("Can't set properties on a union: " + this);}
cf579266fed50e27a8a04b645cb3cc0f1a0e17dd9d4419120aecbc4cbb3116ef
toJson
 void toJson(Names names, JsonGenerator gen) throws IOException
{    gen.writeStartArray();    for (Schema type : types) type.toJson(names, gen);    gen.writeEndArray();}
ae09754a606df2c090b563d347062af623a4748c97165114dfc6659928e97a97
getFixedSize
public int getFixedSize()
{    return size;}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (o == this)        return true;    if (!(o instanceof FixedSchema))        return false;    FixedSchema that = (FixedSchema) o;    return equalCachedHash(that) && equalNames(that) && size == that.size && propsEqual(that);}
e914c3b13e41025331386c8a07395a195efcda4c07392b973ebd2b424435084d
computeHash
 int computeHash()
{    return super.computeHash() + size;}
cf579266fed50e27a8a04b645cb3cc0f1a0e17dd9d4419120aecbc4cbb3116ef
toJson
 void toJson(Names names, JsonGenerator gen) throws IOException
{    if (writeNameRef(names, gen))        return;    gen.writeStartObject();    gen.writeStringField("type", "fixed");    writeName(names, gen);    if (getDoc() != null)        gen.writeStringField("doc", getDoc());    gen.writeNumberField("size", size);    writeProps(gen);    aliasesToJson(gen);    gen.writeEndObject();}
4399f67fcc806208f60c1552b96f00860868e7a783ab80d54887c9c7f4787c08
addTypes
public Parser addTypes(Map<String, Schema> types)
{    for (Schema s : types.values()) names.add(s);    return this;}
2564a3861a57cbb7732a61ff1e55ef4128d4244dbeb10032e46f2b8c5be72c3c
getTypes
public Map<String, Schema> getTypes()
{    Map<String, Schema> result = new LinkedHashMap<>();    for (Schema s : names.values()) result.put(s.getFullName(), s);    return result;}
359fee34d65c06c274ecf96cb8c2808014ddab6842ff431875a4ef4406d383ff
setValidate
public Parser setValidate(boolean validate)
{    this.validate = validate;    return this;}
a7a29ee5de8210e3f7bf08a0c273723797157fffa1c753e4fad9ecaf003e965b
getValidate
public boolean getValidate()
{    return this.validate;}
764e33d14ca39acc2ad091073a061ec4139b622bfaa9b09a8dbdade78b094d79
setValidateDefaults
public Parser setValidateDefaults(boolean validateDefaults)
{    this.validateDefaults = validateDefaults;    return this;}
ec61e3e0565fc075525e733c28d9076c05818c8b749db5874cc1a320ffe89684
getValidateDefaults
public boolean getValidateDefaults()
{    return this.validateDefaults;}
e5d6ea6a6254c1fe3e2e66bbce7c7fe16156cdd3af80f019927242ed129dfd2c
parse
public Schema parse(File file) throws IOException
{    return parse(FACTORY.createParser(file));}
96455068cc5275d9378cc204c06a0e4784c77c76f41446aa266a7c0900fe4716
parse
public Schema parse(InputStream in) throws IOException
{    return parse(FACTORY.createParser(in).disable(JsonParser.Feature.AUTO_CLOSE_SOURCE));}
968829d9fc3dce54daa29c88da12bdbbb133bb56829edaa0cae8ae3e30c1351a
parse
public Schema parse(String s, String... more)
{    StringBuilder b = new StringBuilder(s);    for (String part : more) b.append(part);    return parse(b.toString());}
8c690d059697fb52655074ec5a0c14602b39f286b66448bb5db7e512a6cf6278
parse
public Schema parse(String s)
{    try {        return parse(FACTORY.createParser(s));    } catch (IOException e) {        throw new SchemaParseException(e);    }}
041b0e4748f0ab464b22d2485d6cfefed1df398a56a42341306ff432b2576a0a
parse
private Schema parse(JsonParser parser) throws IOException
{    boolean saved = validateNames.get();    boolean savedValidateDefaults = VALIDATE_DEFAULTS.get();    try {        validateNames.set(validate);        VALIDATE_DEFAULTS.set(validateDefaults);        return Schema.parse(MAPPER.readTree(parser), names);    } catch (JsonParseException e) {        throw new SchemaParseException(e);    } finally {        parser.close();        validateNames.set(saved);        VALIDATE_DEFAULTS.set(savedValidateDefaults);    }}
1d5d0e85a85fe4de762719904247f4804cf24aed331e58c17240ba170499d55e
parse
public static Schema parse(File file) throws IOException
{    return new Parser().parse(file);}
df7839a8442c557c246b7723555c4b34ee27af24b13c2b15767b239d119a8b5e
parse
public static Schema parse(InputStream in) throws IOException
{    return new Parser().parse(in);}
4e7260464f4635b3df403e096c64b2a3d2798e07b55144c7ad32874393681e3e
parse
public static Schema parse(String jsonSchema)
{    return new Parser().parse(jsonSchema);}
b39785cc85aa6a8fc37a18c2b494bea47c231e50ab1ea61ff4cdb0b2820e3372
parse
public static Schema parse(String jsonSchema, boolean validate)
{    return new Parser().setValidate(validate).parse(jsonSchema);}
102dfe74087968d14366d35b500cd72a60782a7348f6f6663fb58231d39c35eb
space
public String space()
{    return space;}
5b382234c259ee358173e7ee231531101aeed8f6799fd10aa17d6e4579580856
space
public void space(String space)
{    this.space = space;}
633155afebef98b043c7cdc247328473d8b4c7d0d55aa6b762de0e9abeadb1d9
get
public Schema get(String o)
{    Type primitive = PRIMITIVES.get(o);    if (primitive != null) {        return Schema.create(primitive);    }    Name name = new Name(o, space);    if (!containsKey(name)) {                name = new Name(o, "");    }    return super.get(name);}
db853d16e6ba1a6520465398596c747d6f88cdecf8909cea96f487189f8b2041
contains
public boolean contains(Schema schema)
{    return get(((NamedSchema) schema).name) != null;}
30cace4c924ca31064ce4399517b08de1c2eb631cd7fbc546e2457e3448c6fec
add
public void add(Schema schema)
{    put(((NamedSchema) schema).name, schema);}
9b478aca88e3e0c6db73573108496421f66821d2d8675a2ab11147b6b78c40ea
put
public Schema put(Name name, Schema schema)
{    if (containsKey(name))        throw new SchemaParseException("Can't redefine: " + name);    return super.put(name, schema);}
c31b0bac75c05e79229aa67e8d1c6b3bc4a6ecbce02a4c804fbb3881e4ac9b87
validateName
private static String validateName(String name)
{    if (!validateNames.get())                return name;    int length = name.length();    if (length == 0)        throw new SchemaParseException("Empty name");    char first = name.charAt(0);    if (!(Character.isLetter(first) || first == '_'))        throw new SchemaParseException("Illegal initial character: " + name);    for (int i = 1; i < length; i++) {        char c = name.charAt(i);        if (!(Character.isLetterOrDigit(c) || c == '_'))            throw new SchemaParseException("Illegal character in: " + name);    }    return name;}
b89ffed88c0686fbf5f794bb176dfda8cd6fbf0e9982a8ea195e12fd47eec7fc
validateDefault
private static JsonNode validateDefault(String fieldName, Schema schema, JsonNode defaultValue)
{    if (VALIDATE_DEFAULTS.get() && (defaultValue != null) && !isValidDefault(schema, defaultValue)) {                String message = "Invalid default for field " + fieldName + ": " + defaultValue + " not a " + schema;                throw new AvroTypeException(message);    }    return defaultValue;}
493fd0ac555d1a5b0c756bc49b124d0885eed0cac68efb0bbee229ebad206697
isValidDefault
private static boolean isValidDefault(Schema schema, JsonNode defaultValue)
{    if (defaultValue == null)        return false;    switch(schema.getType()) {        case STRING:        case BYTES:        case ENUM:        case FIXED:            return defaultValue.isTextual();        case INT:        case LONG:        case FLOAT:        case DOUBLE:            return defaultValue.isNumber();        case BOOLEAN:            return defaultValue.isBoolean();        case NULL:            return defaultValue.isNull();        case ARRAY:            if (!defaultValue.isArray())                return false;            for (JsonNode element : defaultValue) if (!isValidDefault(schema.getElementType(), element))                return false;            return true;        case MAP:            if (!defaultValue.isObject())                return false;            for (JsonNode value : defaultValue) if (!isValidDefault(schema.getValueType(), value))                return false;            return true;        case         UNION:            return isValidDefault(schema.getTypes().get(0), defaultValue);        case RECORD:            if (!defaultValue.isObject())                return false;            for (Field field : schema.getFields()) if (!isValidDefault(field.schema(), defaultValue.has(field.name()) ? defaultValue.get(field.name()) : field.defaultValue()))                return false;            return true;        default:            return false;    }}
448898bef0ff61027629fa40aca084fb7d5e7ccb44b3b858fc2f4c87c0d141ac
parse
 static Schema parse(JsonNode schema, Names names)
{    if (schema == null) {        throw new SchemaParseException("Cannot parse <null> schema");    }    if (schema.isTextual()) {                Schema result = names.get(schema.textValue());        if (result == null)            throw new SchemaParseException("Undefined name: " + schema);        return result;    } else if (schema.isObject()) {        Schema result;        String type = getRequiredText(schema, "type", "No type");        Name name = null;        String savedSpace = names.space();        String doc = null;        if (type.equals("record") || type.equals("error") || type.equals("enum") || type.equals("fixed")) {            String space = getOptionalText(schema, "namespace");            doc = getOptionalText(schema, "doc");            if (space == null)                space = names.space();            name = new Name(getRequiredText(schema, "name", "No name in schema"), space);            if (name.space != null) {                                names.space(name.space);            }        }        if (PRIMITIVES.containsKey(type)) {                        result = create(PRIMITIVES.get(type));        } else if (type.equals("record") || type.equals("error")) {                        List<Field> fields = new ArrayList<>();            result = new RecordSchema(name, doc, type.equals("error"));            if (name != null)                names.add(result);            JsonNode fieldsNode = schema.get("fields");            if (fieldsNode == null || !fieldsNode.isArray())                throw new SchemaParseException("Record has no fields: " + schema);            for (JsonNode field : fieldsNode) {                String fieldName = getRequiredText(field, "name", "No field name");                String fieldDoc = getOptionalText(field, "doc");                JsonNode fieldTypeNode = field.get("type");                if (fieldTypeNode == null)                    throw new SchemaParseException("No field type: " + field);                if (fieldTypeNode.isTextual() && names.get(fieldTypeNode.textValue()) == null)                    throw new SchemaParseException(fieldTypeNode + " is not a defined name." + " The type of the \"" + fieldName + "\" field must be" + " a defined name or a {\"type\": ...} expression.");                Schema fieldSchema = parse(fieldTypeNode, names);                Field.Order order = Field.Order.ASCENDING;                JsonNode orderNode = field.get("order");                if (orderNode != null)                    order = Field.Order.valueOf(orderNode.textValue().toUpperCase(Locale.ENGLISH));                JsonNode defaultValue = field.get("default");                if (defaultValue != null && (Type.FLOAT.equals(fieldSchema.getType()) || Type.DOUBLE.equals(fieldSchema.getType())) && defaultValue.isTextual())                    defaultValue = new DoubleNode(Double.valueOf(defaultValue.textValue()));                Field f = new Field(fieldName, fieldSchema, fieldDoc, defaultValue, true, order);                Iterator<String> i = field.fieldNames();                while (i.hasNext()) {                                        String prop = i.next();                    if (!FIELD_RESERVED.contains(prop))                        f.addProp(prop, field.get(prop));                }                f.aliases = parseAliases(field);                fields.add(f);            }            result.setFields(fields);        } else if (type.equals("enum")) {                        JsonNode symbolsNode = schema.get("symbols");            if (symbolsNode == null || !symbolsNode.isArray())                throw new SchemaParseException("Enum has no symbols: " + schema);            LockableArrayList<String> symbols = new LockableArrayList<>(symbolsNode.size());            for (JsonNode n : symbolsNode) symbols.add(n.textValue());            JsonNode enumDefault = schema.get("default");            String defaultSymbol = null;            if (enumDefault != null)                defaultSymbol = enumDefault.textValue();            result = new EnumSchema(name, doc, symbols, defaultSymbol);            if (name != null)                names.add(result);        } else if (type.equals("array")) {                        JsonNode itemsNode = schema.get("items");            if (itemsNode == null)                throw new SchemaParseException("Array has no items type: " + schema);            result = new ArraySchema(parse(itemsNode, names));        } else if (type.equals("map")) {                        JsonNode valuesNode = schema.get("values");            if (valuesNode == null)                throw new SchemaParseException("Map has no values type: " + schema);            result = new MapSchema(parse(valuesNode, names));        } else if (type.equals("fixed")) {                        JsonNode sizeNode = schema.get("size");            if (sizeNode == null || !sizeNode.isInt())                throw new SchemaParseException("Invalid or no size: " + schema);            result = new FixedSchema(name, doc, sizeNode.intValue());            if (name != null)                names.add(result);        } else {                        Name nameFromType = new Name(type, names.space);            if (names.containsKey(nameFromType)) {                return names.get(nameFromType);            }            throw new SchemaParseException("Type not supported: " + type);        }        Iterator<String> i = schema.fieldNames();        Set reserved = SCHEMA_RESERVED;        if (type.equals("enum")) {            reserved = ENUM_RESERVED;        }        while (i.hasNext()) {                        String prop = i.next();            if (            !reserved.contains(prop))                result.addProp(prop, schema.get(prop));        }                result.logicalType = LogicalTypes.fromSchemaIgnoreInvalid(result);                names.space(savedSpace);        if (result instanceof NamedSchema) {            Set<String> aliases = parseAliases(schema);            if (            aliases != null)                for (String alias : aliases) result.addAlias(alias);        }        return result;    } else if (schema.isArray()) {                LockableArrayList<Schema> types = new LockableArrayList<>(schema.size());        for (JsonNode typeNode : schema) types.add(parse(typeNode, names));        return new UnionSchema(types);    } else {        throw new SchemaParseException("Schema not yet supported: " + schema);    }}
5a53ce7d80f1b0d754a25f89db6a523543146e9ed6029c78e98d5a67225c0493
parseAliases
 static Set<String> parseAliases(JsonNode node)
{    JsonNode aliasesNode = node.get("aliases");    if (aliasesNode == null)        return null;    if (!aliasesNode.isArray())        throw new SchemaParseException("aliases not an array: " + node);    Set<String> aliases = new LinkedHashSet<>();    for (JsonNode aliasNode : aliasesNode) {        if (!aliasNode.isTextual())            throw new SchemaParseException("alias not a string: " + aliasNode);        aliases.add(aliasNode.textValue());    }    return aliases;}
e6664f107a00a858ad84a1eefe385fba98c336c8cb48e52bfe19ce01e1d327b3
getRequiredText
private static String getRequiredText(JsonNode container, String key, String error)
{    String out = getOptionalText(container, key);    if (null == out) {        throw new SchemaParseException(error + ": " + container);    }    return out;}
c185592dd47ede77dbb7a1c1188f46612f989f3d2db458cb46567eff3fd8c08a
getOptionalText
private static String getOptionalText(JsonNode container, String key)
{    JsonNode jsonNode = container.get(key);    return jsonNode != null ? jsonNode.textValue() : null;}
cad72e8e3bbf0b56d2e5fb71682e870f5c5ee44783e20c6360f6a7aee176c49d
parseJson
 static JsonNode parseJson(String s)
{    try {        return MAPPER.readTree(FACTORY.createParser(s));    } catch (IOException e) {        throw new RuntimeException(e);    }}
0cb13a2a2b0c212c72e623521fa5592a4d38860283d3a42ad47e437ac6d89b3a
parseJsonToObject
public static Object parseJsonToObject(String s)
{    return JacksonUtils.toObject(parseJson(s));}
766812f3fc3a3c8b6bd07be1a6d359df6c1d943a3e6ff63ae0786182c4015381
applyAliases
public static Schema applyAliases(Schema writer, Schema reader)
{    if (writer.equals(reader))                return writer;        Map<Schema, Schema> seen = new IdentityHashMap<>(1);    Map<Name, Name> aliases = new HashMap<>(1);    Map<Name, Map<String, String>> fieldAliases = new HashMap<>(1);    getAliases(reader, seen, aliases, fieldAliases);    if (aliases.size() == 0 && fieldAliases.size() == 0)                return writer;    seen.clear();    return applyAliases(writer, seen, aliases, fieldAliases);}
77c8b4d3b6d494c1971b8131f9d2917d8b4f68aac262aaf437aaec89bdd3078c
applyAliases
private static Schema applyAliases(Schema s, Map<Schema, Schema> seen, Map<Name, Name> aliases, Map<Name, Map<String, String>> fieldAliases)
{    Name name = s instanceof NamedSchema ? ((NamedSchema) s).name : null;    Schema result = s;    switch(s.getType()) {        case RECORD:            if (seen.containsKey(s))                                return seen.get(s);            if (aliases.containsKey(name))                name = aliases.get(name);            result = Schema.createRecord(name.full, s.getDoc(), null, s.isError());            seen.put(s, result);            List<Field> newFields = new ArrayList<>();            for (Field f : s.getFields()) {                Schema fSchema = applyAliases(f.schema, seen, aliases, fieldAliases);                String fName = getFieldAlias(name, f.name, fieldAliases);                Field newF = new Field(fName, fSchema, f.doc, f.defaultValue, true, f.order);                                newF.putAll(f);                newFields.add(newF);            }            result.setFields(newFields);            break;        case ENUM:            if (aliases.containsKey(name))                result = Schema.createEnum(aliases.get(name).full, s.getDoc(), null, s.getEnumSymbols(), s.getEnumDefault());            break;        case ARRAY:            Schema e = applyAliases(s.getElementType(), seen, aliases, fieldAliases);            if (!e.equals(s.getElementType()))                result = Schema.createArray(e);            break;        case MAP:            Schema v = applyAliases(s.getValueType(), seen, aliases, fieldAliases);            if (!v.equals(s.getValueType()))                result = Schema.createMap(v);            break;        case UNION:            List<Schema> types = new ArrayList<>();            for (Schema branch : s.getTypes()) types.add(applyAliases(branch, seen, aliases, fieldAliases));            result = Schema.createUnion(types);            break;        case FIXED:            if (aliases.containsKey(name))                result = Schema.createFixed(aliases.get(name).full, s.getDoc(), null, s.getFixedSize());            break;        default:    }    if (!result.equals(s))                result.putAll(s);    return result;}
c97d1da0a3f89332d4f63b3604ce29c4254b08ba95e743133afd978b2a4c04e7
getAliases
private static void getAliases(Schema schema, Map<Schema, Schema> seen, Map<Name, Name> aliases, Map<Name, Map<String, String>> fieldAliases)
{    if (schema instanceof NamedSchema) {        NamedSchema namedSchema = (NamedSchema) schema;        if (namedSchema.aliases != null)            for (Name alias : namedSchema.aliases) aliases.put(alias, namedSchema.name);    }    switch(schema.getType()) {        case RECORD:            if (seen.containsKey(schema))                                return;            seen.put(schema, schema);            RecordSchema record = (RecordSchema) schema;            for (Field field : schema.getFields()) {                if (field.aliases != null)                    for (String fieldAlias : field.aliases) {                        Map<String, String> recordAliases = fieldAliases.computeIfAbsent(record.name, k -> new HashMap<>());                        recordAliases.put(fieldAlias, field.name);                    }                getAliases(field.schema, seen, aliases, fieldAliases);            }            if (record.aliases != null && fieldAliases.containsKey(record.name))                for (Name recordAlias : record.aliases) fieldAliases.put(recordAlias, fieldAliases.get(record.name));            break;        case ARRAY:            getAliases(schema.getElementType(), seen, aliases, fieldAliases);            break;        case MAP:            getAliases(schema.getValueType(), seen, aliases, fieldAliases);            break;        case UNION:            for (Schema s : schema.getTypes()) getAliases(s, seen, aliases, fieldAliases);            break;    }}
3268f7c1d2242a21322f7dadc3b17d297d2c09bb80b0b289f161e0f13a5b3a0b
getFieldAlias
private static String getFieldAlias(Name record, String field, Map<Name, Map<String, String>> fieldAliases)
{    Map<String, String> recordAliases = fieldAliases.get(record);    if (recordAliases == null)        return field;    String alias = recordAliases.get(field);    if (alias == null)        return field;    return alias;}
b125e5872b3408794f6842e0d8c48710e02a5883aff3ad6ea419671f59e40b63
lock
public List<E> lock()
{    locked = true;    return this;}
4764e9df434e208d827bc4a488e3c9e921b848d76a0c2595cb9808a8eaeda8e6
ensureUnlocked
private void ensureUnlocked()
{    if (locked) {        throw new IllegalStateException();    }}
a3fff62fa31f9c7eb78d855d851ff46be0a7dde5acf47c6beee7c3e20b5b39a1
add
public boolean add(E e)
{    ensureUnlocked();    return super.add(e);}
419b436ee630c006c73c2ce3e35dc2241b7dd30a231c66d85f12ec2d22e1463b
remove
public boolean remove(Object o)
{    ensureUnlocked();    return super.remove(o);}
8a5486aad20f4a7f483a51f469758c8d1d71030c32f7c560fec9c951af734010
remove
public E remove(int index)
{    ensureUnlocked();    return super.remove(index);}
8bbab571d73e21453c7cafd9879a935b1554b79cad5e9c6aa418422ff37280b3
addAll
public boolean addAll(Collection<? extends E> c)
{    ensureUnlocked();    return super.addAll(c);}
98a9cf1b4b18a59c9115c5216bfa9ffbaca97e3b3682bfeb785ad4c271d00e5f
addAll
public boolean addAll(int index, Collection<? extends E> c)
{    ensureUnlocked();    return super.addAll(index, c);}
ffff7401397d7a097478dc98b31fe0fa2424d40a29232401684bbb6dc7f20b7c
removeAll
public boolean removeAll(Collection<?> c)
{    ensureUnlocked();    return super.removeAll(c);}
609acc2fd25fb3bb1f6a5af53227b6ccef0e2d5ba6c913c6d67ce78625568ff0
retainAll
public boolean retainAll(Collection<?> c)
{    ensureUnlocked();    return super.retainAll(c);}
21ac40bb9a99614b6ac18fa4043acb6173fccff96066fdfab963dba597923aa8
clear
public void clear()
{    ensureUnlocked();    super.clear();}
7cba1ea9234f942f47ce787ca66095e68047cae3f6687297ddb5ba8b6545eef5
builder
public static TypeBuilder<Schema> builder()
{    return new TypeBuilder<>(new SchemaCompletion(), new NameContext());}
a7e5c768e33942c7ebc3fb890b1952bce802345e042d6bbe595a1b8d22c6f697
builder
public static TypeBuilder<Schema> builder(String namespace)
{    return new TypeBuilder<>(new SchemaCompletion(), new NameContext().namespace(namespace));}
68c59ec91f4f9e8ee11f0031f9ba6838822236b0209142e2fe3054d2a46f9d5d
record
public static RecordBuilder<Schema> record(String name)
{    return builder().record(name);}
657bb57c804412a0496fd886d29c8a6f6d8ca0f6255d8680d50f3396bd495f66
enumeration
public static EnumBuilder<Schema> enumeration(String name)
{    return builder().enumeration(name);}
c74528c1694cd50e39e99301d8209468be55cd9abb724d55dff3e3395374756c
fixed
public static FixedBuilder<Schema> fixed(String name)
{    return builder().fixed(name);}
07857daf0e4866c1603705497a5cc2dd7b47b14c64717dcb60a77cd6bcef2dc3
array
public static ArrayBuilder<Schema> array()
{    return builder().array();}
9ae32b253c36518c420f2b979ed52cdaf1a094e8e121866506e3bcd4619c7a1e
map
public static MapBuilder<Schema> map()
{    return builder().map();}
dc90ab90b38d268b6f22312dd4f199b8f1be21a639ede945bb40085d97ca5b60
unionOf
public static BaseTypeBuilder<UnionAccumulator<Schema>> unionOf()
{    return builder().unionOf();}
2e460685935260d4c02925213072c4c1025e657f77af37c547843364ad47e8d6
nullable
public static BaseTypeBuilder<Schema> nullable()
{    return builder().nullable();}
af5a7eecd84fa03b560202551ba4905ed86b3bc4220e4549714dee65de753900
prop
public final S prop(String name, String val)
{    return prop(name, TextNode.valueOf(val));}
22df7e479e0c7c880f757f0727f299fe86715699ebcd7076d0d431729411b02a
prop
public final S prop(String name, Object value)
{    return prop(name, JacksonUtils.toJsonNode(value));}
b871f90aa09010f8fd8925f135ad0ca13e417b694d0b985d79a7e5f0778b8862
prop
 final S prop(String name, JsonNode val)
{    if (!hasProps()) {        props = new HashMap<>();    }    props.put(name, val);    return self();}
190622a3ce3feaef3e09b96b3ac2b40d3b3b1903bd66dde4c6d8abc31f7e37b2
hasProps
private boolean hasProps()
{    return (props != null);}
7d87763cdd9fd50b71f119b336a5f8e5fe7e0e2148fd5e08937dc91bc8e905ef
addPropsTo
 final T addPropsTo(T jsonable)
{    if (hasProps()) {        for (Map.Entry<String, JsonNode> prop : props.entrySet()) {            jsonable.addProp(prop.getKey(), prop.getValue());        }    }    return jsonable;}
514e3fffb5be6057dfd00b44633ad7159b5006b79c1136d1dcc2e69785a18760
doc
public final S doc(String doc)
{    this.doc = doc;    return self();}
e83b027accd9d65696ff7ee97f0a073be16e01ca5d90248f29f9083f7c375c78
aliases
public final S aliases(String... aliases)
{    this.aliases = aliases;    return self();}
0b4e25c7367241df59199b76cd8a799536a8a62f3e5d39dbe6539030442683b5
doc
 final String doc()
{    return doc;}
2ab14aad58ad7a86d8089eccfefb56815c44494d806b767ae21d307e1649067c
name
 final String name()
{    return name;}
ba39c3a5af3d2dd4347cea82e5e54ac5f81be70e5132be11fb5d91a5b872b87b
names
 final NameContext names()
{    return names;}
84bd02a6513d75a9943cc8d19da0baa637ad357ba3ff4f7fb5e2ef15afdeec3a
addAliasesTo
 final Schema addAliasesTo(Schema schema)
{    if (null != aliases) {        for (String alias : aliases) {            schema.addAlias(alias);        }    }    return schema;}
0aefcf4d3c63df35edad57e0aa7fa6c5608f65ec3ce01f69409ab90d87c1f8ef
addAliasesTo
 final Field addAliasesTo(Field field)
{    if (null != aliases) {        for (String alias : aliases) {            field.addAlias(alias);        }    }    return field;}
ecd08df5ebe86a492fb9cc08ce1e2377e224f842e327b8547b6bf3d4ab6e88ce
namespace
public final S namespace(String namespace)
{    this.namespace = namespace;    return self();}
05c217ebb8747ad020a55d4e06e6cab3b26751ee13ccda66cbeb589aa87c8546
space
 final String space()
{    if (null == namespace) {        return names().namespace;    }    return namespace;}
b1439df79227df44351e3821fbab0c4f59b50f1326207cd9e6bbdfa85fd21d27
completeSchema
 final Schema completeSchema(Schema schema)
{    addPropsTo(schema);    addAliasesTo(schema);    names().put(schema);    return schema;}
8da063fb199d1d30c3d8ba50f636441bca6c566084baa0ad02211f5d535b6f4b
context
 final Completion<R> context()
{    return context;}
285bfbb81c5593bde27facda2245bf910179d8503995dbcc3f177035da76cea5
end
private R end()
{    Schema schema = immutable;    if (super.hasProps()) {        schema = Schema.create(immutable.getType());        addPropsTo(schema);    }    return context.complete(schema);}
916906f0c80d1e1b6447ac28fe779376734fd0fc187c982f1e774d6b805faf88
create
private static BooleanBuilder<R> create(Completion<R> context, NameContext names)
{    return new BooleanBuilder<>(context, names);}
68795c9d822273085275c06cf6a251ec30da40c50395bae84ba7901f4fbbcb12
self
protected BooleanBuilder<R> self()
{    return this;}
1062ced847d63d3dd3339b7f1e155501b5616b61b588415d1d6ccb16a6506bb9
endBoolean
public R endBoolean()
{    return super.end();}
fb202246539ffb31afb43b6c230e9470a7ac7234493a4c425d0c4e3e782de978
create
private static IntBuilder<R> create(Completion<R> context, NameContext names)
{    return new IntBuilder<>(context, names);}
d10afe184cd71a39902ea7fcd448efc3587913cc5e96d17e8344c8cb3d79fe0b
self
protected IntBuilder<R> self()
{    return this;}
ff2551792adea8f386b3a2064884bd32b21f1c9ba1965b4a98b95809b1123148
endInt
public R endInt()
{    return super.end();}
51c0fd5b391644d0dadaf548db7c83cc00789fb162727fc0dcea09fcc63c1e0d
create
private static LongBuilder<R> create(Completion<R> context, NameContext names)
{    return new LongBuilder<>(context, names);}
be1891fa949c0f043872ac03591d37a998fa7bc64a3e5494853bd3f78eae4b7e
self
protected LongBuilder<R> self()
{    return this;}
3f4affd17eb752f682e04a6c5bf78e98d24b566014def0af8ab4a681ebd6b511
endLong
public R endLong()
{    return super.end();}
0901f3de955ed4577a7d9ea4c909497b7cc71b104d0597d1f08d989bbc9e2981
create
private static FloatBuilder<R> create(Completion<R> context, NameContext names)
{    return new FloatBuilder<>(context, names);}
a4a51a8ce70d07c738231aa5c194f62edeb39c9c74c5546c07ba686610a07293
self
protected FloatBuilder<R> self()
{    return this;}
5a0c852a8310a1fc35bcce6ffd800891e5d8788999e2f07ea5c8e95d3808461f
endFloat
public R endFloat()
{    return super.end();}
fbc93195c8ff715049f3174146bc921744b59c3ebc520cb9def9cc46b38f7e01
create
private static DoubleBuilder<R> create(Completion<R> context, NameContext names)
{    return new DoubleBuilder<>(context, names);}
ac2943b15c5b1ddbe482edb6be898c6539061d9b5203c01914c7d9ae28eda122
self
protected DoubleBuilder<R> self()
{    return this;}
4aef98b5aad6c9e0ce74a2e0aec6847eba890ebfffd90d74975867a7c36f1bdd
endDouble
public R endDouble()
{    return super.end();}
76e5668d73ec739c9e056e90e8ac74b2a3afc3b05ae1bfe22b1373e0deb623b4
create
private static StringBldr<R> create(Completion<R> context, NameContext names)
{    return new StringBldr<>(context, names);}
11fc23ce4e7221a247de6ad9c12bebf8cbaaac64a82513e54d498eaa2630ba9f
self
protected StringBldr<R> self()
{    return this;}
25c80270162d44bc377c0f80b66505b8e4417894c59492f4168672a61724ba3c
endString
public R endString()
{    return super.end();}
12ee243b9fa16e4474a06a18045df3c65ffa334d429df511a4bbccab48ec368b
create
private static BytesBuilder<R> create(Completion<R> context, NameContext names)
{    return new BytesBuilder<>(context, names);}
25fc0e49d8f5c52d0405b6b757d0f12bf7543e5c4fd71d5716c181b88ef29f4d
self
protected BytesBuilder<R> self()
{    return this;}
219a70b8ceb12e2f8c5fd7e757dac7b932fc5449be68f867feb602f7c27ec277
endBytes
public R endBytes()
{    return super.end();}
38a8f3ddda8910021b13cb138619d85bcb53fd78370d167e744130523393656e
create
private static NullBuilder<R> create(Completion<R> context, NameContext names)
{    return new NullBuilder<>(context, names);}
a00bb5da178638e92e4c18b51f908a7126f50005b86ff2b8a5972a4457eb448c
self
protected NullBuilder<R> self()
{    return this;}
4970604ba9cde98e0979009dc249df7436e00dfb2ed3915b3a0d738e6b20e7d3
endNull
public R endNull()
{    return super.end();}
81c96cd28e2095ed05973fbc91fe1360da6f53f2ddbd211a4e640ab120344c56
create
private static FixedBuilder<R> create(Completion<R> context, NameContext names, String name)
{    return new FixedBuilder<>(context, names, name);}
0da2af250bce8c8777a7d3554fc2b085956fc84f97666e82265b986f13d0ebb2
self
protected FixedBuilder<R> self()
{    return this;}
706f79988808f70265cb7416dd7ef24c0104db9fde4bd5c599f44c54e0909881
size
public R size(int size)
{    Schema schema = Schema.createFixed(name(), super.doc(), space(), size);    completeSchema(schema);    return context().complete(schema);}
fa68a86c6cb90dbca0a69a3cb6b625eca9b112482bef7e6d7018b2c34acb7a23
create
private static EnumBuilder<R> create(Completion<R> context, NameContext names, String name)
{    return new EnumBuilder<>(context, names, name);}
b5b571f50c5402014a90ec488443ddddca456e3942f8177d76614823d2eefef5
self
protected EnumBuilder<R> self()
{    return this;}
fb543f239caf0929eb846a14f6c32919262c009c0acb4b4170357a534688968b
symbols
public R symbols(String... symbols)
{    Schema schema = Schema.createEnum(name(), doc(), space(), Arrays.asList(symbols), this.enumDefault);    completeSchema(schema);    return context().complete(schema);}
8ca3f7015ae582e9cdd069bfab066b6746390552c73a3074e6cc244c40d33767
defaultSymbol
public EnumBuilder<R> defaultSymbol(String enumDefault)
{    this.enumDefault = enumDefault;    return self();}
5691c1956ea3b54db61f6c9bb876521129a8ded8d4cdc9ac6912b268d7cc39d2
create
private static MapBuilder<R> create(Completion<R> context, NameContext names)
{    return new MapBuilder<>(context, names);}
8bc86ead03214af8bd2a816d1ebc353c48d6d337a4c75e8eaab7ef3332063d56
self
protected MapBuilder<R> self()
{    return this;}
0c496421ad6790ba893439bac46c8066694b329a0a305a4438a81cd2160b174f
values
public TypeBuilder<R> values()
{    return new TypeBuilder<>(new MapCompletion<>(this, context), names);}
a7ec14f0b47f98f5383c702371c11d3adeeebad70d0cffb5d9b6b845e201d04e
values
public R values(Schema valueSchema)
{    return new MapCompletion<>(this, context).complete(valueSchema);}
884c5aaec466c6b6aacfb7123b2bb20e7a44c3b78590439dd7acb07cdad287cd
create
private static ArrayBuilder<R> create(Completion<R> context, NameContext names)
{    return new ArrayBuilder<>(context, names);}
64fcdca1520519f47a8ebb2ed78138c224307460e8c89c1a7dfa696fe3646ec7
self
protected ArrayBuilder<R> self()
{    return this;}
dc2112f4673e99840724985e6d4035402ceb071ef2dc02da9ad7f049b3abd86b
items
public TypeBuilder<R> items()
{    return new TypeBuilder<>(new ArrayCompletion<>(this, context), names);}
a1cc2f2d3d3005625324071babf325cd9599d2ed37c99883f5b6575063f9aa63
items
public R items(Schema itemsSchema)
{    return new ArrayCompletion<>(this, context).complete(itemsSchema);}
0f959b208e9ff06cc427cd4b6c959fc3ca2257b694a7c841df1ec3c3aaad69f0
namespace
private NameContext namespace(String namespace)
{    return new NameContext(schemas, namespace);}
30285f1db028582774d8df33e6c2e7a72df952fb566b9d7933692a06c5f55f94
get
private Schema get(String name, String namespace)
{    return getFullname(resolveName(name, namespace));}
29930766c61e13209795299c48771102ac6c3d4784bacb6fcce4ca50315f844c
getFullname
private Schema getFullname(String fullName)
{    Schema schema = schemas.get(fullName);    if (schema == null) {        throw new SchemaParseException("Undefined name: " + fullName);    }    return schema;}
6a73c3c025e83edb73520b91ffec70dcea7cd343d9b9c4ba056acf39693dfa47
put
private void put(Schema schema)
{    String fullName = schema.getFullName();    if (schemas.containsKey(fullName)) {        throw new SchemaParseException("Can't redefine: " + fullName);    }    schemas.put(fullName, schema);}
50ec51849a34f691f183e4a061aa6dced13e8788b3ebb806049faf0661807abb
resolveName
private String resolveName(String name, String space)
{    if (PRIMITIVES.contains(name) && space == null) {        return name;    }    int lastDot = name.lastIndexOf('.');    if (lastDot < 0) {                if (space == null) {            space = namespace;        }        if (space != null && !"".equals(space)) {            return space + "." + name;        }    }    return name;}
8201e32388f50ce2735861155caa525098d2485df7c8e05564c22adf3eae0637
type
public final R type(Schema schema)
{    return context.complete(schema);}
c278c518fa0f6d9848ebb046c0041d11f9ed8ec686505061c3e234b74bbb3fee
type
public final R type(String name)
{    return type(name, null);}
ab5eb5c74034088ca098633e2441ecd7d1ac306996a11073410d554df491d05a
type
public final R type(String name, String namespace)
{    return type(names.get(name, namespace));}
431a16271293dc3c6c68d242d484fb159675fd2543469a32c16be96c5c25de49
booleanType
public final R booleanType()
{    return booleanBuilder().endBoolean();}
b73386d2c9944d4e8e8748fa2a5d7386ee61e34299619e4edf73b937bce767e1
booleanBuilder
public final BooleanBuilder<R> booleanBuilder()
{    return BooleanBuilder.create(context, names);}
dee50496e572f404531bc439b540b46c5bd2f47650c3ae75bccd89f967d44311
intType
public final R intType()
{    return intBuilder().endInt();}
5bd0c16ccfbce96a442eff64ddfe8d92befda3a82dae44da76647b756c93753d
intBuilder
public final IntBuilder<R> intBuilder()
{    return IntBuilder.create(context, names);}
7530e17884c89918fd6380f88ac1a61856da49f2e864372c4992fe42f372ebd8
longType
public final R longType()
{    return longBuilder().endLong();}
dc382043a82572cee819f8f0381417df886361489f2e92dba1ae8ddec9a27d2b
longBuilder
public final LongBuilder<R> longBuilder()
{    return LongBuilder.create(context, names);}
ea0d0df83f9d3ca8aef20ac6665d17a3f589c9521a59a39970392de61c1d18b7
floatType
public final R floatType()
{    return floatBuilder().endFloat();}
2c6f2d90e274b0bda147ce0615478838269b3d62553696b6c93b790a0400265d
floatBuilder
public final FloatBuilder<R> floatBuilder()
{    return FloatBuilder.create(context, names);}
5738601a4aaf7fafb6a1eb87717d360ad5831fab947e0be9e33665c4d432b959
doubleType
public final R doubleType()
{    return doubleBuilder().endDouble();}
d3d0b12289df1048bb8c87fb8185f291f4c2ac33396dcc7f1e1e29fe0b441271
doubleBuilder
public final DoubleBuilder<R> doubleBuilder()
{    return DoubleBuilder.create(context, names);}
2ab33c90b488206dbfec734855199f4dd08c9e25f7a504e96331cd86c45c33f8
stringType
public final R stringType()
{    return stringBuilder().endString();}
276759a4338c7d2509e393b29c32a5493d890523831d5c765f565ef872243e42
stringBuilder
public final StringBldr<R> stringBuilder()
{    return StringBldr.create(context, names);}
802c9efcee883d85f43b186abd79469ff4d8828bfaef5316497d81307a50ae0e
bytesType
public final R bytesType()
{    return bytesBuilder().endBytes();}
d1cfb1162e4bbfaa640d66f858fe8d59da17562f33b6ce3bc5df0cc4ea53a487
bytesBuilder
public final BytesBuilder<R> bytesBuilder()
{    return BytesBuilder.create(context, names);}
18fd636446676cd6c695274eabe706411c7cc8c2fb9f307aac8c595a127caff0
nullType
public final R nullType()
{    return nullBuilder().endNull();}
9d9571a8a2908bce4c1499b9a682096a3cc08335f09a6e50a4c5996bd50434e3
nullBuilder
public final NullBuilder<R> nullBuilder()
{    return NullBuilder.create(context, names);}
ff6f74d9bb66a0bad404ff4d39c9f46654aa7b55dfe857d395f5644dd2bea9ea
map
public final MapBuilder<R> map()
{    return MapBuilder.create(context, names);}
2b08289142c4c041a7a1123fa5d3400b8f41bc5eb3615ff653ec7aa9db64f0e9
array
public final ArrayBuilder<R> array()
{    return ArrayBuilder.create(context, names);}
06ebd5667d83b88d18c8b1ec8c66c115935e8cab602132b478996347cd11d2fc
fixed
public final FixedBuilder<R> fixed(String name)
{    return FixedBuilder.create(context, names, name);}
533e37b71f7b2994f01f7991af48a1a67ed005903a673dc0bdd4dfbb016fe0c0
enumeration
public final EnumBuilder<R> enumeration(String name)
{    return EnumBuilder.create(context, names, name);}
461da2931753157135f0ed3db1eeb5b756c132a55c2019d56f26011cdcd7e425
record
public final RecordBuilder<R> record(String name)
{    return RecordBuilder.create(context, names, name);}
309a1dec7bf65e2925648d67daf3accdeb6cd5076c56b3ebd4879ffbe054c51e
unionOf
protected BaseTypeBuilder<UnionAccumulator<R>> unionOf()
{    return UnionBuilder.create(context, names);}
5079bda18cce2094118c4d71c99ed07bc1c73f2e3ea28e372fbee3b685286064
nullable
protected BaseTypeBuilder<R> nullable()
{    return new BaseTypeBuilder<>(new NullableCompletion<>(context), names);}
b6f965f6dcc3bef355807a88df01535c95a3f447755f75e8e99f77fb1912d15f
unionOf
public BaseTypeBuilder<UnionAccumulator<R>> unionOf()
{    return super.unionOf();}
8efdb57c4b732ed31f3cf6004f7bc00b8cf367784e51a55a729858851f0abd35
nullable
public BaseTypeBuilder<R> nullable()
{    return super.nullable();}
440f5c3b662eda08b7ff87872d736b9afd393541439902990ed74c52ff93b753
create
private static UnionBuilder<R> create(Completion<R> context, NameContext names)
{    return new UnionBuilder<>(context, names);}
74d26efc34fb0a19aa8c6682a68883a68f05ca02d86eb262cd6643cb181b0e8d
booleanType
public final BooleanDefault<R> booleanType()
{    return booleanBuilder().endBoolean();}
d1b565b199cab0a3aa9d79ac2732618e3672a5c35d1fd2f53cef4066690b7921
booleanBuilder
public final BooleanBuilder<BooleanDefault<R>> booleanBuilder()
{    return BooleanBuilder.create(wrap(new BooleanDefault<>(bldr)), names);}
09ca367b61a5a9efb7bd7cf1352bb1ad86583d19ced2350b83ccca708d27392d
intType
public final IntDefault<R> intType()
{    return intBuilder().endInt();}
acdb6899c67475d87617768e8d2f4512bd7b5b58d92b3221b51e1f26019d39a5
intBuilder
public final IntBuilder<IntDefault<R>> intBuilder()
{    return IntBuilder.create(wrap(new IntDefault<>(bldr)), names);}
642ce2415fed044eb5e01856d9892d05f1dfcaf8fdd4e5bb6673cafd7fcc7d8d
longType
public final LongDefault<R> longType()
{    return longBuilder().endLong();}
6bba4722121d1dbdf542aa563102e4719bbc7cd87a93f7c4287712117912d032
longBuilder
public final LongBuilder<LongDefault<R>> longBuilder()
{    return LongBuilder.create(wrap(new LongDefault<>(bldr)), names);}
566d4c8e1a7e65c2a22912e259833d079982d9199e01376ce7e2f26534a0b494
floatType
public final FloatDefault<R> floatType()
{    return floatBuilder().endFloat();}
6eee3794a24877638649e1f2fe969d4fbf988889db45d6f2826c2386e9c190a0
floatBuilder
public final FloatBuilder<FloatDefault<R>> floatBuilder()
{    return FloatBuilder.create(wrap(new FloatDefault<>(bldr)), names);}
b61cca033e510126f450c17197ad070dfa3bdd3024f4140c1a7cfa324f46a0a5
doubleType
public final DoubleDefault<R> doubleType()
{    return doubleBuilder().endDouble();}
e43bcf9d01acfa7f6f8cd35e987bcc3aed610efc73b971bb084b3107ee813f15
doubleBuilder
public final DoubleBuilder<DoubleDefault<R>> doubleBuilder()
{    return DoubleBuilder.create(wrap(new DoubleDefault<>(bldr)), names);}
c8e2d553b0f60b66c2ecc09a2758b30a4a19e93153c10f2a536803cdb0aafdca
stringType
public final StringDefault<R> stringType()
{    return stringBuilder().endString();}
5f0fee9d2fd1f713ef25edd07e5478ae68b9ad115874b109c2294e556117467b
stringBuilder
public final StringBldr<StringDefault<R>> stringBuilder()
{    return StringBldr.create(wrap(new StringDefault<>(bldr)), names);}
fc6fd4e19ba431e824c0597069065e9cd58d2a8956ff87bf4ba01464755879b4
bytesType
public final BytesDefault<R> bytesType()
{    return bytesBuilder().endBytes();}
a5b9b400f9378cc44dbb07c6183458153ca419a374bf69744e7f137aa6d92bd4
bytesBuilder
public final BytesBuilder<BytesDefault<R>> bytesBuilder()
{    return BytesBuilder.create(wrap(new BytesDefault<>(bldr)), names);}
805515b7745a8788444bdc52e9c2b5f9c77d3fc0f1c703cd7db6f840eded393f
nullType
public final NullDefault<R> nullType()
{    return nullBuilder().endNull();}
e5d54226e75e2f527d355a147232489765823ed7f5518260f81bc19f7365cc04
nullBuilder
public final NullBuilder<NullDefault<R>> nullBuilder()
{    return NullBuilder.create(wrap(new NullDefault<>(bldr)), names);}
9cc487f74a6c93ab2b625ecb947a160b21c2c7c9586e08d9cdbfd417c5b90524
map
public final MapBuilder<MapDefault<R>> map()
{    return MapBuilder.create(wrap(new MapDefault<>(bldr)), names);}
1ad683d0f6ae705b622d2a5d6786093505cd70cdb2f77d6d4026442dc5e67523
array
public final ArrayBuilder<ArrayDefault<R>> array()
{    return ArrayBuilder.create(wrap(new ArrayDefault<>(bldr)), names);}
d8db598b27accba7e3d6faeded6024786f55f07429c67af3a5013548aa3927e5
fixed
public final FixedBuilder<FixedDefault<R>> fixed(String name)
{    return FixedBuilder.create(wrap(new FixedDefault<>(bldr)), names, name);}
3a051051b919e2c68ec96d9441cac12435376ec1e60dab5a1927ca2653543cc9
enumeration
public final EnumBuilder<EnumDefault<R>> enumeration(String name)
{    return EnumBuilder.create(wrap(new EnumDefault<>(bldr)), names, name);}
601ceca8228a1a65d6830621ba6692663690a05ddd15dc5adc7bc1b40782ddd6
record
public final RecordBuilder<RecordDefault<R>> record(String name)
{    return RecordBuilder.create(wrap(new RecordDefault<>(bldr)), names, name);}
9db1e5f75d4571fe31d5c48ff69f4a73bd3accd6a0b5007e9322425d067fa8a1
wrap
private Completion<C> wrap(Completion<C> completion)
{    if (wrapper != null) {        return wrapper.wrap(completion);    }    return completion;}
8f10ef68cabbfa3bcd1821c7327780d49280eede04c61491e319efeea4f2f52b
unionOf
public UnionFieldTypeBuilder<R> unionOf()
{    return new UnionFieldTypeBuilder<>(bldr);}
6c5c5cad8c725055d1a25ad45d8bcf9e2a8bd64f188e930d7a482b3e121df8d0
nullable
public BaseFieldTypeBuilder<R> nullable()
{    return new BaseFieldTypeBuilder<>(bldr, new NullableCompletionWrapper());}
0e135ab2a6af461828f7a7b61110bf76f1fd847cd03b772c0172afea0475d32f
optional
public BaseTypeBuilder<FieldAssembler<R>> optional()
{    return new BaseTypeBuilder<>(new OptionalCompletion<>(bldr), names);}
5f6a8e2f8a817c6171b9d4174c5b6ee4dc0b0dbbdc17e16cadf8f31cdf81e4b7
booleanType
public UnionAccumulator<BooleanDefault<R>> booleanType()
{    return booleanBuilder().endBoolean();}
70ac6226fc47cb59e0d252d6be59f961e96fb3588ce31ea3ffbdbc792444b1b4
booleanBuilder
public BooleanBuilder<UnionAccumulator<BooleanDefault<R>>> booleanBuilder()
{    return BooleanBuilder.create(completion(new BooleanDefault<>(bldr)), names);}
f539cc21626c8111e71a432d62ff57a7151e381181172c51219ab3a5843ff6d4
intType
public UnionAccumulator<IntDefault<R>> intType()
{    return intBuilder().endInt();}
5590a41c946e7a3c752a03d612878b0004fdf34d5c46400cf6fc2a7a578cc275
intBuilder
public IntBuilder<UnionAccumulator<IntDefault<R>>> intBuilder()
{    return IntBuilder.create(completion(new IntDefault<>(bldr)), names);}
bb06efa366e8717f1abb765acd6c6b9e7279d0051ac7c0250d13c1d11e25cc21
longType
public UnionAccumulator<LongDefault<R>> longType()
{    return longBuilder().endLong();}
db9a19920d6b200ba4caec5bf0ece9d7013dfada1ce33fa888c9d43a8f8c8071
longBuilder
public LongBuilder<UnionAccumulator<LongDefault<R>>> longBuilder()
{    return LongBuilder.create(completion(new LongDefault<>(bldr)), names);}
76d40f6f4f0624d9d8d9f7635a3c06d7337df837b6ff39377ed0e3848f8f8e7d
floatType
public UnionAccumulator<FloatDefault<R>> floatType()
{    return floatBuilder().endFloat();}
cab84f32a5cff0761f5011ec7c3f92e2fe7cdf25c10b06422d80d20b32b569ec
floatBuilder
public FloatBuilder<UnionAccumulator<FloatDefault<R>>> floatBuilder()
{    return FloatBuilder.create(completion(new FloatDefault<>(bldr)), names);}
aa8c3617021caf3a17b544cc06bd36d6eebe4ed60d6451153293ccdbcb68a526
doubleType
public UnionAccumulator<DoubleDefault<R>> doubleType()
{    return doubleBuilder().endDouble();}
353839ad84bf4b314b91c86adf2b441c492a0dee0404b929105926694d9232bb
doubleBuilder
public DoubleBuilder<UnionAccumulator<DoubleDefault<R>>> doubleBuilder()
{    return DoubleBuilder.create(completion(new DoubleDefault<>(bldr)), names);}
17e3fa7a677a4436a5e08b5b9c0a85252f24ebe17acb8ac1f37b70260d32cd31
stringType
public UnionAccumulator<StringDefault<R>> stringType()
{    return stringBuilder().endString();}
db37506c2d60d952d85e13376ddb83614333ae936c98bbe386e020fd1cc98561
stringBuilder
public StringBldr<UnionAccumulator<StringDefault<R>>> stringBuilder()
{    return StringBldr.create(completion(new StringDefault<>(bldr)), names);}
a1c7d62a49d7892796378561ec426c0b9e1896c4bc15d16a4fe654b66770eb59
bytesType
public UnionAccumulator<BytesDefault<R>> bytesType()
{    return bytesBuilder().endBytes();}
012c0b010acb90e852da0665634fdf9461ada3c7500e8e7e2557deeffe2a9c75
bytesBuilder
public BytesBuilder<UnionAccumulator<BytesDefault<R>>> bytesBuilder()
{    return BytesBuilder.create(completion(new BytesDefault<>(bldr)), names);}
a3a397e0d82ad5f5bd406037a2e2c67f652e0dbf6cd46a43578cd15898931453
nullType
public UnionAccumulator<NullDefault<R>> nullType()
{    return nullBuilder().endNull();}
b143c108ea55cfcbdbec54e1ce1663343105e263ae598518297d87c9d0a92924
nullBuilder
public NullBuilder<UnionAccumulator<NullDefault<R>>> nullBuilder()
{    return NullBuilder.create(completion(new NullDefault<>(bldr)), names);}
bd7aefadbdc9be0904432511ca6cbc9d956b7c44f9dc5e2a098ef587639f814c
map
public MapBuilder<UnionAccumulator<MapDefault<R>>> map()
{    return MapBuilder.create(completion(new MapDefault<>(bldr)), names);}
cecf49bd7cd9ad3621b1ded13cdd94c286c3a06687f4a4d77abafc98d6d75a83
array
public ArrayBuilder<UnionAccumulator<ArrayDefault<R>>> array()
{    return ArrayBuilder.create(completion(new ArrayDefault<>(bldr)), names);}
5cedbd553b103f94310658d12124c3b50f260f7a49a564c999cfc8bc0c6f52c2
fixed
public FixedBuilder<UnionAccumulator<FixedDefault<R>>> fixed(String name)
{    return FixedBuilder.create(completion(new FixedDefault<>(bldr)), names, name);}
cd0a8fc4b054e4aa734eba7b02db12f7e5898b4c43a75047f02b6521202eaef2
enumeration
public EnumBuilder<UnionAccumulator<EnumDefault<R>>> enumeration(String name)
{    return EnumBuilder.create(completion(new EnumDefault<>(bldr)), names, name);}
3cdc8290a73732d0c8472f1f2cf370e9af8ac0403a5d1c16ee4709426be2f8e5
record
public RecordBuilder<UnionAccumulator<RecordDefault<R>>> record(String name)
{    return RecordBuilder.create(completion(new RecordDefault<>(bldr)), names, name);}
d67fc79c874a3d1fd64fec950504df64e8a0f19549408405dafb27e7604ac0c5
completion
private UnionCompletion<C> completion(Completion<C> context)
{    return new UnionCompletion<>(context, names, new ArrayList<>());}
e2e464eb99495858f62bda972c69898543209a0030f4b709e39925f37d519645
create
private static RecordBuilder<R> create(Completion<R> context, NameContext names, String name)
{    return new RecordBuilder<>(context, names, name);}
b6d93c730b0cc5117eec04be6990ddedd42dce9abc1e3962bbbf7a0fc7687222
self
protected RecordBuilder<R> self()
{    return this;}
ee1ed001bbdf15a379de5812227ff0529995197a34aaca72e96873d83e5fb78b
fields
public FieldAssembler<R> fields()
{    Schema record = Schema.createRecord(name(), doc(), space(), false);        completeSchema(record);    return new FieldAssembler<>(context(), names().namespace(record.getNamespace()), record);}
4789cd26b33457719143dd2ac412795e1116649f627f2312cc44e80ea020d3e5
name
public FieldBuilder<R> name(String fieldName)
{    return new FieldBuilder<>(this, names, fieldName);}
bcf5a529fe3b0e06cf7125335460bedd1dc0a353bf59f3496a000278c29063a9
requiredBoolean
public FieldAssembler<R> requiredBoolean(String fieldName)
{    return name(fieldName).type().booleanType().noDefault();}
0960c96cd981420d7a118b119c5c96a691735d7c9fd04031b41d68b8af7eb03f
optionalBoolean
public FieldAssembler<R> optionalBoolean(String fieldName)
{    return name(fieldName).type().optional().booleanType();}
d010bbc870464ce2cadd2bff72cfdb0662144560abf1ed9b2a2ec6eef105e7c8
nullableBoolean
public FieldAssembler<R> nullableBoolean(String fieldName, boolean defaultVal)
{    return name(fieldName).type().nullable().booleanType().booleanDefault(defaultVal);}
80f8c818390ac0ae0f8eec775111a5068369a9f33b875961c73626cf8e07f948
requiredInt
public FieldAssembler<R> requiredInt(String fieldName)
{    return name(fieldName).type().intType().noDefault();}
b1378568b7a1dd08143504a3b7a9624e3be97774f2e30518fa843a3c1962bfdb
optionalInt
public FieldAssembler<R> optionalInt(String fieldName)
{    return name(fieldName).type().optional().intType();}
7845f4e22ea3e744e2c14aa4fb96af0e5b586f55f0eb55548541cc6a0325c84a
nullableInt
public FieldAssembler<R> nullableInt(String fieldName, int defaultVal)
{    return name(fieldName).type().nullable().intType().intDefault(defaultVal);}
29272f0bbaa503b5ab903f5dcafbd486fc762128d8a836740ba7ddf29a96f618
requiredLong
public FieldAssembler<R> requiredLong(String fieldName)
{    return name(fieldName).type().longType().noDefault();}
0d0e028684497ee80837dafc5198440bfe74f22ba3a21f071205d85859604ccb
optionalLong
public FieldAssembler<R> optionalLong(String fieldName)
{    return name(fieldName).type().optional().longType();}
aa75f651fcc8fcb9d10f2aa806bf3e419f1afe0bed14fd3e7303a2555176398d
nullableLong
public FieldAssembler<R> nullableLong(String fieldName, long defaultVal)
{    return name(fieldName).type().nullable().longType().longDefault(defaultVal);}
cf3ea59974d3e36fbcfbaa62af99f226a9231382fb9a0452022a05dad0f37a7f
requiredFloat
public FieldAssembler<R> requiredFloat(String fieldName)
{    return name(fieldName).type().floatType().noDefault();}
a164b2e8e7456bfe51e6d53c61a5b6b5e7e04d696b1b33a143f61136e704c9af
optionalFloat
public FieldAssembler<R> optionalFloat(String fieldName)
{    return name(fieldName).type().optional().floatType();}
70ac352a2c0623bbbb6b48fd34940577c3cf116e8de639dff1bfc1a5447ed261
nullableFloat
public FieldAssembler<R> nullableFloat(String fieldName, float defaultVal)
{    return name(fieldName).type().nullable().floatType().floatDefault(defaultVal);}
1dd716d70d04439f2ab40bed7892df9097c45a58850b43d3aaf4fa033b76191b
requiredDouble
public FieldAssembler<R> requiredDouble(String fieldName)
{    return name(fieldName).type().doubleType().noDefault();}
1952a828283e4ff8d83587cc57f273e39e3a2f83676a6185ec34389480947b7c
optionalDouble
public FieldAssembler<R> optionalDouble(String fieldName)
{    return name(fieldName).type().optional().doubleType();}
d36fc41d2e39eba982e66b8a9ca363b3e37a7fcbe1e55aa7ee9338bb825efb1f
nullableDouble
public FieldAssembler<R> nullableDouble(String fieldName, double defaultVal)
{    return name(fieldName).type().nullable().doubleType().doubleDefault(defaultVal);}
513886cf8c4d106109bfbd0e242a4f6b4490dd51a6a065ed5a4c1a5eec096e38
requiredString
public FieldAssembler<R> requiredString(String fieldName)
{    return name(fieldName).type().stringType().noDefault();}
4e0f39202d9857d8724bffa4ff7741ba3c910e4a6652107a0bcccd7f9837c487
optionalString
public FieldAssembler<R> optionalString(String fieldName)
{    return name(fieldName).type().optional().stringType();}
c489dfc45eec8902ab6ea68d060b47aba55b7405db08c5c25560ec4569809112
nullableString
public FieldAssembler<R> nullableString(String fieldName, String defaultVal)
{    return name(fieldName).type().nullable().stringType().stringDefault(defaultVal);}
39dfed6348d616f24f554f01af359c54b2bbeb13f3471bedf0157abf6b2e400c
requiredBytes
public FieldAssembler<R> requiredBytes(String fieldName)
{    return name(fieldName).type().bytesType().noDefault();}
ecec2429d68a52e2e5bd3134e254651d7057782ad306b26a5199ade50c71c5cf
optionalBytes
public FieldAssembler<R> optionalBytes(String fieldName)
{    return name(fieldName).type().optional().bytesType();}
cd2b87152d40f4249385ac7d6d0899677877f61119dcebd76b201fa64f32c6ba
nullableBytes
public FieldAssembler<R> nullableBytes(String fieldName, byte[] defaultVal)
{    return name(fieldName).type().nullable().bytesType().bytesDefault(defaultVal);}
0d9318c3d5dfa07eb5431ee2eadcb8e405080cdf11550ac2297f1c557ea7f68e
endRecord
public R endRecord()
{    record.setFields(fields);    return context.complete(record);}
8618b2d89a41d78c3d5c4759c3de29fc99d971c39034248c1f84dda44865b78f
addField
private FieldAssembler<R> addField(Field field)
{    fields.add(field);    return this;}
f99c48696e193f495f0cec7fbbe6f3c84f8618d95a6982089ce32cc00f05acb9
orderAscending
public FieldBuilder<R> orderAscending()
{    order = Schema.Field.Order.ASCENDING;    return self();}
7a72ed340a16aad4262b885f1c3ddc011c648976cc0720114d2551cbf22b120d
orderDescending
public FieldBuilder<R> orderDescending()
{    order = Schema.Field.Order.DESCENDING;    return self();}
499bd895016a8af5bdb1645134032d940f078f0db51ab04061c73db98c1f5d8a
orderIgnore
public FieldBuilder<R> orderIgnore()
{    order = Schema.Field.Order.IGNORE;    return self();}
34676b889d0d3ee8ac8170cdc905fb8d8cd45ef52cef8574dd374ae2e784f20a
type
public FieldTypeBuilder<R> type()
{    return new FieldTypeBuilder<>(this);}
ab63616331a1f6fbffc4a387f33e7e31f20632641519564f961295d49dca216a
type
public GenericDefault<R> type(Schema type)
{    return new GenericDefault<>(this, type);}
c807fc5255e1e428f7aee9c124305c59c6028282ed6cda8e17872b5a55221d80
type
public GenericDefault<R> type(String name)
{    return type(name, null);}
36e4f1c21909cf24983d65ca1783c393b1748da34d4fa148a9452a4a8e86ea78
type
public GenericDefault<R> type(String name, String namespace)
{    Schema schema = names().get(name, namespace);    return type(schema);}
dbe025428aa4e85e1d9fecd604411586a7bdac21fea21ffe54258cd55c913708
completeField
private FieldAssembler<R> completeField(Schema schema, Object defaultVal)
{    JsonNode defaultNode = defaultVal == null ? NullNode.getInstance() : toJsonNode(defaultVal);    return completeField(schema, defaultNode);}
4936f061cb6c43871f6b6c6bba4cdce4c54002e048753a169c8f8436400b6e1a
completeField
private FieldAssembler<R> completeField(Schema schema)
{    return completeField(schema, (JsonNode) null);}
8c4c3e62ec1a943dbd6af058f8ac11de32f7282efe7ce21fb150f219ea335242
completeField
private FieldAssembler<R> completeField(Schema schema, JsonNode defaultVal)
{    Field field = new Field(name(), schema, doc(), defaultVal, true, order);    addPropsTo(field);    addAliasesTo(field);    return fields.addField(field);}
2cb59911d2c02470848d85703515e56033471d04341562dd179f5713ac1d7a7a
self
protected FieldBuilder<R> self()
{    return this;}
056e14e32ca17432f9ae2fcf974ef8543d5a5d7d9434e40c44acdba69e2891ec
noDefault
public final FieldAssembler<R> noDefault()
{    return field.completeField(schema);}
6a482c7c82a9cd22981ea838a51b1473c27af292b0c64c6211d29d1cb0ac5108
usingDefault
private FieldAssembler<R> usingDefault(Object defaultVal)
{    return field.completeField(schema, defaultVal);}
1bff11f0493b4f02d4b485ec50a456b5439ec04b76c1e9e42fe8529e6bbaea10
complete
 final S complete(Schema schema)
{    this.schema = schema;    return self();}
d1a14186733f58e4f733deb95cd6771135757cf6d9fc11afd80f71c2036f1a2a
booleanDefault
public final FieldAssembler<R> booleanDefault(boolean defaultVal)
{    return super.usingDefault(defaultVal);}
5728c3668f91191975c7bebecb5b409d91b5ede56b6d078407e9b21d92a90c26
self
 final BooleanDefault<R> self()
{    return this;}
ddc0d04a650df7ddaac04e03d44bdf6518cee13f5ec1d798c546c672d5de2962
intDefault
public final FieldAssembler<R> intDefault(int defaultVal)
{    return super.usingDefault(defaultVal);}
f4d3ae26d6bcd0e6e46cf3c410dcb7f3763f77df0787278e046fa12f692f564e
self
 final IntDefault<R> self()
{    return this;}
d78dc1e80e4716be4f97e06510c1c115954da40fadf5a1901bff6510791dc68a
longDefault
public final FieldAssembler<R> longDefault(long defaultVal)
{    return super.usingDefault(defaultVal);}
d16b7934dca604589b021956d71653225e00964024e6be4a30be964fc4c0b1e8
self
 final LongDefault<R> self()
{    return this;}
e417dfadf27d798c65776e4ca463af9719399d69b35d52c865e5dd6e9e02188a
floatDefault
public final FieldAssembler<R> floatDefault(float defaultVal)
{    return super.usingDefault(defaultVal);}
dad779985071b79116ce25159a3b74fb3ca26f2d18c636236cb2388086b7b001
self
 final FloatDefault<R> self()
{    return this;}
3b7324496dbf68967baf6fc4e6dae15d50b2a8e71b035cbe3518de6cc1e0fce0
doubleDefault
public final FieldAssembler<R> doubleDefault(double defaultVal)
{    return super.usingDefault(defaultVal);}
47521269594bf2f44395c3c49a4eecbc1611c18cc508c002bdb9cde7bb8f8fd4
self
 final DoubleDefault<R> self()
{    return this;}
406091921ec0dae9e09d7e18ee35a01cad99adc67036158ddab277c78170410a
stringDefault
public final FieldAssembler<R> stringDefault(String defaultVal)
{    return super.usingDefault(defaultVal);}
cbc51dce209144a2de49d2d1f61e8b0ae73d131be56637330f8839bb9b57337c
self
 final StringDefault<R> self()
{    return this;}
ea8afcd7eda1b5994848730e72c6d612828b0a089b495281d4a5424cba2ecc3c
bytesDefault
public final FieldAssembler<R> bytesDefault(byte[] defaultVal)
{    return super.usingDefault(ByteBuffer.wrap(defaultVal));}
79f12048f6f6a0d2e3fd173027439e33e3a2ce5eb3e2339095e9d58f91673abf
bytesDefault
public final FieldAssembler<R> bytesDefault(ByteBuffer defaultVal)
{    return super.usingDefault(defaultVal);}
35793a8fe3c2b926336843335b80406cb90357cfaa476fd2cb4c2814595c00d3
bytesDefault
public final FieldAssembler<R> bytesDefault(String defaultVal)
{    return super.usingDefault(defaultVal);}
76caecccb5ac70fc392cc3bb42e60a0d2daeb0611ebb4f78547458e85891b1d6
self
 final BytesDefault<R> self()
{    return this;}
17568cd14b7e4b4abf40979c3fa865dad234d7b798d12419546ac891d57a6cc6
nullDefault
public final FieldAssembler<R> nullDefault()
{    return super.usingDefault(null);}
fee1e1ee97592a9e9320751814695360018143f2e00100c9bc2c7036746941ea
self
 final NullDefault<R> self()
{    return this;}
85d508072666d9219715fa93eec93ed1dc0c16d6423b34c8fedbb11bc3c301ba
mapDefault
public final FieldAssembler<R> mapDefault(Map<K, V> defaultVal)
{    return super.usingDefault(defaultVal);}
1eba42f42180b4696039233867ec2eca413b2f77dd370a64620bf384eca72b0c
self
 final MapDefault<R> self()
{    return this;}
6736e19fce1eb77826cfe900aa9321c66177a4f6f9a5453bd993a17e3b466ea3
arrayDefault
public final FieldAssembler<R> arrayDefault(List<V> defaultVal)
{    return super.usingDefault(defaultVal);}
5468029848ae0cb6a0e7e0fad794ea0a2b6ff14210a35f14de009c3480d5bd1e
self
 final ArrayDefault<R> self()
{    return this;}
966b6bc7d3575bed02750c93e00e4bb4138cbb3de734c987e03debc169197f6b
fixedDefault
public final FieldAssembler<R> fixedDefault(byte[] defaultVal)
{    return super.usingDefault(ByteBuffer.wrap(defaultVal));}
1e9790423baff375657cc93177c404f48fa0f4c0b783779d8412f327152eda79
fixedDefault
public final FieldAssembler<R> fixedDefault(ByteBuffer defaultVal)
{    return super.usingDefault(defaultVal);}
8f89d18b31db7a5177d6c3c55dbd0c29649502df003a48c81c4458069a16c4b5
fixedDefault
public final FieldAssembler<R> fixedDefault(String defaultVal)
{    return super.usingDefault(defaultVal);}
15f6cb5dd06842b20358eedba6deb73b6a29f836bb26faafceea57593071f430
self
 final FixedDefault<R> self()
{    return this;}
18f76f4ea058a5a00094a55d5e3f5b02fac3b86872274f0f7706e40bffc0392a
enumDefault
public final FieldAssembler<R> enumDefault(String defaultVal)
{    return super.usingDefault(defaultVal);}
9d2008926a6b998e6e8d4e23ff91e5ca4dcdfe6f4db4787a1e727548a2c4ce15
self
 final EnumDefault<R> self()
{    return this;}
41cd1148059a81229f2daa034497cf92fa6a9d6387b8345190a3443a1968e5fe
recordDefault
public final FieldAssembler<R> recordDefault(GenericRecord defaultVal)
{    return super.usingDefault(defaultVal);}
1e629c2fc0eec11e5a3b6d712d54874316fc702f17f6ba7552d4a696f5e321cc
self
 final RecordDefault<R> self()
{    return this;}
1b45ca455c2b62bcaa392e9a48941eda7ca9dcf84303a0cded0d848ba82a4fd1
noDefault
public FieldAssembler<R> noDefault()
{    return field.completeField(schema);}
3f5f694af70ab8ee99239d8397450243ad8a3a7fec1476444c59771f916d231d
withDefault
public FieldAssembler<R> withDefault(Object defaultVal)
{    return field.completeField(schema, defaultVal);}
9b98a7e47dfea16c314eace8b2050682d74cf28a2c37472ddb36fd91c1dac885
complete
protected Schema complete(Schema schema)
{    return schema;}
c1c2032975cdec6f2edbf0d91aaa9b5c4dbbdb2350afe627c7a411d629c04a64
complete
protected R complete(Schema schema)
{        Schema nullable = Schema.createUnion(Arrays.asList(schema, NULL_SCHEMA));    return context.complete(nullable);}
ae29280d6366b8902ea93d2a08fb8d6d406bf812e8dd7a53201a197d68a93ee0
complete
protected FieldAssembler<R> complete(Schema schema)
{        Schema optional = Schema.createUnion(Arrays.asList(NULL_SCHEMA, schema));    return bldr.completeField(optional, (Object) null);}
734d27790897695bcd708ebb00ecb30ad9e884c30da5e4ec75679b03cc1eb6d3
wrap
 Completion<R> wrap(Completion<R> completion)
{    return new NullableCompletion<>(completion);}
d73570ff9fc8f885151c9dc451c26f88c32e5ce41f60a00cdaf0f24a563a3d1e
complete
protected final R complete(Schema schema)
{    Schema outer = outerSchema(schema);    assembler.addPropsTo(outer);    return context.complete(outer);}
784b2442de6b245e13f9e5952c9ae373c68aa99bb9e78e1ae7982ca4ff497223
outerSchema
protected Schema outerSchema(Schema inner)
{    return Schema.createMap(inner);}
784b2442de6b245e13f9e5952c9ae373c68aa99bb9e78e1ae7982ca4ff497223
outerSchema
protected Schema outerSchema(Schema inner)
{    return Schema.createArray(inner);}
efdfbe04cf969aa94c6c6959cf175063ad4c5cb792950edaf46c0d42fe00fa0a
complete
protected UnionAccumulator<R> complete(Schema schema)
{    List<Schema> updated = new ArrayList<>(this.schemas);    updated.add(schema);    return new UnionAccumulator<>(context, names, updated);}
b5edbb19e5a891ad9a26666ff84296aef6b90d96faa707e7e3d187543512ea2a
and
public BaseTypeBuilder<UnionAccumulator<R>> and()
{    return new UnionBuilder<>(context, names, schemas);}
0fe70474a2cc86e04f1a7b6af0674058cc2664343e24ad3c7467ce6c8d3a0370
endUnion
public R endUnion()
{    Schema schema = Schema.createUnion(schemas);    return context.complete(schema);}
211951e5f4a88b5bd01d98658b031bb0302ba4ad103dce8b4d142dfabc777128
checkRequired
private static void checkRequired(Object reference, String errorMessage)
{    if (reference == null) {        throw new NullPointerException(errorMessage);    }}
784913946b853215689d41bf5ae36d3c7080026123642d47f67cf9f24ffd6cfa
toJsonNode
private static JsonNode toJsonNode(Object o)
{    try {        String s;        if (o instanceof ByteBuffer) {                                    ByteBuffer bytes = ((ByteBuffer) o);            bytes.mark();            byte[] data = new byte[bytes.remaining()];            bytes.get(data);                        bytes.reset();            s = new String(data, StandardCharsets.ISO_8859_1);            char[] quoted = BufferRecyclers.getJsonStringEncoder().quoteAsString(s);            s = "\"" + new String(quoted) + "\"";        } else if (o instanceof byte[]) {            s = new String((byte[]) o, StandardCharsets.ISO_8859_1);            char[] quoted = BufferRecyclers.getJsonStringEncoder().quoteAsString(s);            s = '\"' + new String(quoted) + '\"';        } else {            s = GenericData.get().toString(o);        }        return new ObjectMapper().readTree(s);    } catch (IOException e) {        throw new SchemaBuilderException(e);    }}
9d996618023a5e235076183c11a68dd3379b451e14d236f756b45d3ee1533b65
checkReaderWriterCompatibility
public static SchemaPairCompatibility checkReaderWriterCompatibility(final Schema reader, final Schema writer)
{    final SchemaCompatibilityResult compatibility = new ReaderWriterCompatibilityChecker().getCompatibility(reader, writer);    final String message;    switch(compatibility.getCompatibility()) {        case INCOMPATIBLE:            {                message = String.format("Data encoded using writer schema:%n%s%n" + "will or may fail to decode using reader schema:%n%s%n", writer.toString(true), reader.toString(true));                break;            }        case COMPATIBLE:            {                message = READER_WRITER_COMPATIBLE_MESSAGE;                break;            }        default:            throw new AvroRuntimeException("Unknown compatibility: " + compatibility);    }    return new SchemaPairCompatibility(compatibility, reader, writer, message);}
2ab28c250155a426ac4d3a0325c03097279ac85021171b2722ee1b2f81f25b05
schemaNameEquals
public static boolean schemaNameEquals(final Schema reader, final Schema writer)
{    if (objectsEqual(reader.getName(), writer.getName())) {        return true;    }        return reader.getAliases().contains(writer.getFullName());}
391df563d1b4bc1e1cc3be8af7f608172ceae552a9a9275c3c35652748ff75ec
lookupWriterField
public static Field lookupWriterField(final Schema writerSchema, final Field readerField)
{    assert (writerSchema.getType() == Type.RECORD);    final List<Field> writerFields = new ArrayList<>();    final Field direct = writerSchema.getField(readerField.name());    if (direct != null) {        writerFields.add(direct);    }    for (final String readerFieldAliasName : readerField.aliases()) {        final Field writerField = writerSchema.getField(readerFieldAliasName);        if (writerField != null) {            writerFields.add(writerField);        }    }    switch(writerFields.size()) {        case 0:            return null;        case 1:            return writerFields.get(0);        default:            {                throw new AvroRuntimeException(String.format("Reader record field %s matches multiple fields in writer record schema %s", readerField, writerSchema));            }    }}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return System.identityHashCode(mReader) ^ System.identityHashCode(mWriter);}
4afeb0868b55bdd8e18a00a3cb43d83e0714378d1c4bb36f0936daefc060e2e8
equals
public boolean equals(Object obj)
{    if (!(obj instanceof ReaderWriter)) {        return false;    }    final ReaderWriter that = (ReaderWriter) obj;        return (this.mReader == that.mReader) && (this.mWriter == that.mWriter);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return String.format("ReaderWriter{reader:%s, writer:%s}", mReader, mWriter);}
3d14eae82e9a743ea74b28b7ebcddb98ae1feea866569705556cadbc5cdaf3ed
getCompatibility
public SchemaCompatibilityResult getCompatibility(final Schema reader, final Schema writer)
{    Deque<String> location = new ArrayDeque<>();    return getCompatibility(ROOT_REFERENCE_TOKEN, reader, writer, location);}
49f6ebf085dcea5560d9274b950bd3904a976fffc7dee74608f20b8761616a60
getCompatibility
private SchemaCompatibilityResult getCompatibility(String referenceToken, final Schema reader, final Schema writer, final Deque<String> location)
{    location.addFirst(referenceToken);    LOG.debug("Checking compatibility of reader {} with writer {}", reader, writer);    final ReaderWriter pair = new ReaderWriter(reader, writer);    SchemaCompatibilityResult result = mMemoizeMap.get(pair);    if (result != null) {        if (result.getCompatibility() == SchemaCompatibilityType.RECURSION_IN_PROGRESS) {                                    result = SchemaCompatibilityResult.compatible();        }    } else {                mMemoizeMap.put(pair, SchemaCompatibilityResult.recursionInProgress());        result = calculateCompatibility(reader, writer, location);        mMemoizeMap.put(pair, result);    }    location.removeFirst();    return result;}
dfc68689eb05144feecf58b37b9dd2fe5d1b8cfcf1fd524ac7005352e1a1b660
calculateCompatibility
private SchemaCompatibilityResult calculateCompatibility(final Schema reader, final Schema writer, final Deque<String> location)
{    assert (reader != null);    assert (writer != null);    SchemaCompatibilityResult result = SchemaCompatibilityResult.compatible();    if (reader.getType() == writer.getType()) {        switch(reader.getType()) {            case NULL:            case BOOLEAN:            case INT:            case LONG:            case FLOAT:            case DOUBLE:            case BYTES:            case STRING:                {                    return result;                }            case ARRAY:                {                    return result.mergedWith(getCompatibility("items", reader.getElementType(), writer.getElementType(), location));                }            case MAP:                {                    return result.mergedWith(getCompatibility("values", reader.getValueType(), writer.getValueType(), location));                }            case FIXED:                {                    result = result.mergedWith(checkSchemaNames(reader, writer, location));                    return result.mergedWith(checkFixedSize(reader, writer, location));                }            case ENUM:                {                    result = result.mergedWith(checkSchemaNames(reader, writer, location));                    return result.mergedWith(checkReaderEnumContainsAllWriterEnumSymbols(reader, writer, location));                }            case RECORD:                {                    result = result.mergedWith(checkSchemaNames(reader, writer, location));                    return result.mergedWith(checkReaderWriterRecordFields(reader, writer, location));                }            case UNION:                {                                        int i = 0;                    for (final Schema writerBranch : writer.getTypes()) {                        location.addFirst(Integer.toString(i));                        SchemaCompatibilityResult compatibility = getCompatibility(reader, writerBranch);                        if (compatibility.getCompatibility() == SchemaCompatibilityType.INCOMPATIBLE) {                            String message = String.format("reader union lacking writer type: %s", writerBranch.getType());                            result = result.mergedWith(SchemaCompatibilityResult.incompatible(SchemaIncompatibilityType.MISSING_UNION_BRANCH, reader, writer, message, asList(location)));                        }                        location.removeFirst();                        i++;                    }                                        return result;                }            default:                {                    throw new AvroRuntimeException("Unknown schema type: " + reader.getType());                }        }    } else {                if (writer.getType() == Schema.Type.UNION) {            for (Schema s : writer.getTypes()) {                result = result.mergedWith(getCompatibility(reader, s));            }            return result;        }        switch(reader.getType()) {            case NULL:                return result.mergedWith(typeMismatch(reader, writer, location));            case BOOLEAN:                return result.mergedWith(typeMismatch(reader, writer, location));            case INT:                return result.mergedWith(typeMismatch(reader, writer, location));            case LONG:                {                    return (writer.getType() == Type.INT) ? result : result.mergedWith(typeMismatch(reader, writer, location));                }            case FLOAT:                {                    return ((writer.getType() == Type.INT) || (writer.getType() == Type.LONG)) ? result : result.mergedWith(typeMismatch(reader, writer, location));                }            case DOUBLE:                {                    return ((writer.getType() == Type.INT) || (writer.getType() == Type.LONG) || (writer.getType() == Type.FLOAT)) ? result : result.mergedWith(typeMismatch(reader, writer, location));                }            case BYTES:                {                    return (writer.getType() == Type.STRING) ? result : result.mergedWith(typeMismatch(reader, writer, location));                }            case STRING:                {                    return (writer.getType() == Type.BYTES) ? result : result.mergedWith(typeMismatch(reader, writer, location));                }            case ARRAY:                return result.mergedWith(typeMismatch(reader, writer, location));            case MAP:                return result.mergedWith(typeMismatch(reader, writer, location));            case FIXED:                return result.mergedWith(typeMismatch(reader, writer, location));            case ENUM:                return result.mergedWith(typeMismatch(reader, writer, location));            case RECORD:                return result.mergedWith(typeMismatch(reader, writer, location));            case UNION:                {                    for (final Schema readerBranch : reader.getTypes()) {                        SchemaCompatibilityResult compatibility = getCompatibility(readerBranch, writer);                        if (compatibility.getCompatibility() == SchemaCompatibilityType.COMPATIBLE) {                            return result;                        }                    }                                                            String message = String.format("reader union lacking writer type: %s", writer.getType());                    return result.mergedWith(SchemaCompatibilityResult.incompatible(SchemaIncompatibilityType.MISSING_UNION_BRANCH, reader, writer, message, asList(location)));                }            default:                {                    throw new AvroRuntimeException("Unknown schema type: " + reader.getType());                }        }    }}
4808e9bd61382275d338ed5ab32add329d343e0f32327c1d8281a265021e2ad5
checkReaderWriterRecordFields
private SchemaCompatibilityResult checkReaderWriterRecordFields(final Schema reader, final Schema writer, final Deque<String> location)
{    SchemaCompatibilityResult result = SchemaCompatibilityResult.compatible();    location.addFirst("fields");        for (final Field readerField : reader.getFields()) {        location.addFirst(Integer.toString(readerField.pos()));        final Field writerField = lookupWriterField(writer, readerField);        if (writerField == null) {                        if (!readerField.hasDefaultValue()) {                                if (readerField.schema().getType() == Type.ENUM && readerField.schema().getEnumDefault() != null) {                    result = result.mergedWith(getCompatibility("type", readerField.schema(), writer, location));                } else {                    result = result.mergedWith(SchemaCompatibilityResult.incompatible(SchemaIncompatibilityType.READER_FIELD_MISSING_DEFAULT_VALUE, reader, writer, readerField.name(), asList(location)));                }            }        } else {            result = result.mergedWith(getCompatibility("type", readerField.schema(), writerField.schema(), location));        }                location.removeFirst();    }            location.removeFirst();    return result;}
e6edc79ff0ad5b0b83f2ad6f83a6a0da50dfd486a4a6e2485ffac93e4e8c9cb8
checkReaderEnumContainsAllWriterEnumSymbols
private SchemaCompatibilityResult checkReaderEnumContainsAllWriterEnumSymbols(final Schema reader, final Schema writer, final Deque<String> location)
{    SchemaCompatibilityResult result = SchemaCompatibilityResult.compatible();    location.addFirst("symbols");    final Set<String> symbols = new TreeSet<>(writer.getEnumSymbols());    symbols.removeAll(reader.getEnumSymbols());    if (!symbols.isEmpty()) {        if (reader.getEnumDefault() != null && reader.getEnumSymbols().contains(reader.getEnumDefault())) {            symbols.clear();            result = SchemaCompatibilityResult.compatible();        } else {            result = SchemaCompatibilityResult.incompatible(SchemaIncompatibilityType.MISSING_ENUM_SYMBOLS, reader, writer, symbols.toString(), asList(location));        }    }        location.removeFirst();    return result;}
81b9d0f7fc903ff0dd8b587b44ada92d8134ce78f35909b52b55bebcc43ab8bf
checkFixedSize
private SchemaCompatibilityResult checkFixedSize(final Schema reader, final Schema writer, final Deque<String> location)
{    SchemaCompatibilityResult result = SchemaCompatibilityResult.compatible();    location.addFirst("size");    int actual = reader.getFixedSize();    int expected = writer.getFixedSize();    if (actual != expected) {        String message = String.format("expected: %d, found: %d", expected, actual);        result = SchemaCompatibilityResult.incompatible(SchemaIncompatibilityType.FIXED_SIZE_MISMATCH, reader, writer, message, asList(location));    }        location.removeFirst();    return result;}
6b61c29c08a290bee9204d5b099d9185370672f7365a3ace123a2e76b03d18f2
checkSchemaNames
private SchemaCompatibilityResult checkSchemaNames(final Schema reader, final Schema writer, final Deque<String> location)
{    SchemaCompatibilityResult result = SchemaCompatibilityResult.compatible();    location.addFirst("name");    if (!schemaNameEquals(reader, writer)) {        String message = String.format("expected: %s", writer.getFullName());        result = SchemaCompatibilityResult.incompatible(SchemaIncompatibilityType.NAME_MISMATCH, reader, writer, message, asList(location));    }        location.removeFirst();    return result;}
2f5c7d3f80ad52def0c1c7b7343987f6820b9121278f90e7734ac700585195be
typeMismatch
private SchemaCompatibilityResult typeMismatch(final Schema reader, final Schema writer, final Deque<String> location)
{    String message = String.format("reader type: %s not compatible with writer type: %s", reader.getType(), writer.getType());    return SchemaCompatibilityResult.incompatible(SchemaIncompatibilityType.TYPE_MISMATCH, reader, writer, message, asList(location));}
0cad5ad928d5d74cd6dc6e32ac4a6ed3ea990806ce7d8ba057bbb949feeae866
mergedWith
public SchemaCompatibilityResult mergedWith(SchemaCompatibilityResult toMerge)
{    List<Incompatibility> mergedIncompatibilities = new ArrayList<>(mIncompatibilities);    mergedIncompatibilities.addAll(toMerge.getIncompatibilities());    SchemaCompatibilityType compatibilityType = mCompatibilityType == SchemaCompatibilityType.COMPATIBLE ? toMerge.mCompatibilityType : SchemaCompatibilityType.INCOMPATIBLE;    return new SchemaCompatibilityResult(compatibilityType, mergedIncompatibilities);}
448d963d60a42bda0e9cd84d6e7a155627c25c181946b5a3ee5e9599143bcff2
compatible
public static SchemaCompatibilityResult compatible()
{    return COMPATIBLE;}
14267ce556a3288fdc380ebd3d52a83dd60a350c4a6ec33f02145805930a4447
recursionInProgress
public static SchemaCompatibilityResult recursionInProgress()
{    return RECURSION_IN_PROGRESS;}
62f469399628037cfcbe4d43b6892af54661bc296f59d58639a9fcf68352d9fb
incompatible
public static SchemaCompatibilityResult incompatible(SchemaIncompatibilityType incompatibilityType, Schema readerFragment, Schema writerFragment, String message, List<String> location)
{    Incompatibility incompatibility = new Incompatibility(incompatibilityType, readerFragment, writerFragment, message, location);    return new SchemaCompatibilityResult(SchemaCompatibilityType.INCOMPATIBLE, Collections.singletonList(incompatibility));}
30e0b2ba8bd01fa0cd505e00d611dc7fbf4698c7d3230fc883feaa7c3fac405f
getCompatibility
public SchemaCompatibilityType getCompatibility()
{    return mCompatibilityType;}
001d7524bfd9c9977a3d7af54cc65b5fac83fdf80892ecea36f0d6835b41efd3
getIncompatibilities
public List<Incompatibility> getIncompatibilities()
{    return mIncompatibilities;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    final int prime = 31;    int result = 1;    result = prime * result + ((mCompatibilityType == null) ? 0 : mCompatibilityType.hashCode());    result = prime * result + ((mIncompatibilities == null) ? 0 : mIncompatibilities.hashCode());    return result;}
4afeb0868b55bdd8e18a00a3cb43d83e0714378d1c4bb36f0936daefc060e2e8
equals
public boolean equals(Object obj)
{    if (this == obj)        return true;    if (obj == null)        return false;    if (getClass() != obj.getClass())        return false;    SchemaCompatibilityResult other = (SchemaCompatibilityResult) obj;    if (mIncompatibilities == null) {        if (other.mIncompatibilities != null)            return false;    } else if (!mIncompatibilities.equals(other.mIncompatibilities))        return false;    return mCompatibilityType == other.mCompatibilityType;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return String.format("SchemaCompatibilityResult{compatibility:%s, incompatibilities:%s}", mCompatibilityType, mIncompatibilities);}
ce34b65b5bfaf382e5c7c0ef283f752e8d4479e6c74491b29e9654da9f00f039
getType
public SchemaIncompatibilityType getType()
{    return mType;}
d9b7feef69123c9f1bc7d3b43bdde4d51842e1d888a07ee03d4045ee173ae248
getReaderFragment
public Schema getReaderFragment()
{    return mReaderFragment;}
337ef64163bffd92dfc3ca6047638168b9fbfd6d7c7320a0c9193c6647c02eb6
getWriterFragment
public Schema getWriterFragment()
{    return mWriterFragment;}
b46153cc21231cb60e014b6b3c49b437699575e4012681cb08026e5238c66751
getMessage
public String getMessage()
{    return mMessage;}
a50882ead68e94dcbbdf96fb8dae09b529366434d16e69e44544e30f2176d810
getLocation
public String getLocation()
{    StringBuilder s = new StringBuilder("/");    boolean first = true;        for (String coordinate : mLocation.subList(1, mLocation.size())) {        if (first) {            first = false;        } else {            s.append('/');        }                s.append(coordinate.replace("~", "~0").replace("/", "~1"));    }    return s.toString();}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    final int prime = 31;    int result = 1;    result = prime * result + ((mType == null) ? 0 : mType.hashCode());    result = prime * result + ((mReaderFragment == null) ? 0 : mReaderFragment.hashCode());    result = prime * result + ((mWriterFragment == null) ? 0 : mWriterFragment.hashCode());    result = prime * result + ((mMessage == null) ? 0 : mMessage.hashCode());    result = prime * result + ((mLocation == null) ? 0 : mLocation.hashCode());    return result;}
4afeb0868b55bdd8e18a00a3cb43d83e0714378d1c4bb36f0936daefc060e2e8
equals
public boolean equals(Object obj)
{    if (this == obj) {        return true;    }    if (obj == null) {        return false;    }    if (getClass() != obj.getClass()) {        return false;    }    Incompatibility other = (Incompatibility) obj;    if (mType != other.mType) {        return false;    }    if (mReaderFragment == null) {        if (other.mReaderFragment != null) {            return false;        }    } else if (!mReaderFragment.equals(other.mReaderFragment)) {        return false;    }    if (mWriterFragment == null) {        if (other.mWriterFragment != null) {            return false;        }    } else if (!mWriterFragment.equals(other.mWriterFragment)) {        return false;    }    if (mMessage == null) {        if (other.mMessage != null) {            return false;        }    } else if (!mMessage.equals(other.mMessage)) {        return false;    }    if (mLocation == null) {        return other.mLocation == null;    } else        return mLocation.equals(other.mLocation);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return String.format("Incompatibility{type:%s, location:%s, message:%s, reader:%s, writer:%s}", mType, getLocation(), mMessage, mReaderFragment, mWriterFragment);}
b7b3cbf19e2ae07517a244f34a8cac563b51e540bbe9aca47f2063b248fe16cb
getType
public SchemaCompatibilityType getType()
{    return mResult.getCompatibility();}
fa35b72eebbfe20d8bfad9753741554be4692552e9b78ea1e2654b21201654c2
getResult
public SchemaCompatibilityResult getResult()
{    return mResult;}
7caaf6e44f56f03c64859257e777dc26e4d64e31f0975cb9df7e81c29a04b681
getReader
public Schema getReader()
{    return mReader;}
db56f892dfd3ccbe02e1d06385cd26298e72a05b81990a86865b96790c64596a
getWriter
public Schema getWriter()
{    return mWriter;}
706203ef14181d53971fddf5ab6603fcf31442cdccb19cc5e237bca9faee9d63
getDescription
public String getDescription()
{    return mDescription;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return String.format("SchemaPairCompatibility{result:%s, readerSchema:%s, writerSchema:%s, description:%s}", mResult, mReader, mWriter, mDescription);}
74e378df448c6c3cd090d6daf881cfac8957dd555869ea4c13a46bdc6cdcf9a6
equals
public boolean equals(Object other)
{    if ((other instanceof SchemaPairCompatibility)) {        final SchemaPairCompatibility result = (SchemaPairCompatibility) other;        return objectsEqual(result.mResult, mResult) && objectsEqual(result.mReader, mReader) && objectsEqual(result.mWriter, mWriter) && objectsEqual(result.mDescription, mDescription);    } else {        return false;    }}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return Arrays.hashCode(new Object[] { mResult, mReader, mWriter, mDescription });}
23736771787c9da1cfb5ec04f967b66377bf811332ab6eb20db8a611d85ef99d
objectsEqual
private static boolean objectsEqual(Object obj1, Object obj2)
{    return Objects.equals(obj1, obj2);}
f064485d00cb5d73c81d96cd4f8dc83bdefae910a3e57eeb33af223f87e8f44c
asList
private static List<String> asList(Deque<String> deque)
{    List<String> list = new ArrayList<>(deque);    Collections.reverse(list);    return Collections.unmodifiableList(list);}
237da1a154de03c2548b4b9b0c075618d28a513002254ec681415e8e0e29301d
toParsingForm
public static String toParsingForm(Schema s)
{    try {        Map<String, String> env = new HashMap<>();        return build(env, s, new StringBuilder()).toString();    } catch (IOException e) {                throw new RuntimeException(e);    }}
517cd99037ab17489c52c991dcd1da3e5c166aac252b5a684df5cab3ba0230a8
fingerprint
public static byte[] fingerprint(String fpName, byte[] data) throws NoSuchAlgorithmException
{    if (fpName.equals("CRC-64-AVRO")) {        long fp = fingerprint64(data);        byte[] result = new byte[8];        for (int i = 0; i < 8; i++) {            result[i] = (byte) fp;            fp >>= 8;        }        return result;    }    MessageDigest md = MessageDigest.getInstance(fpName);    return md.digest(data);}
5b4ef95a4e9a8be408c9e163ff8b7a51aa4ddcc96372961589cdf657783fe62d
fingerprint64
public static long fingerprint64(byte[] data)
{    long result = EMPTY64;    for (byte b : data) result = (result >>> 8) ^ FP64.FP_TABLE[(int) (result ^ b) & 0xff];    return result;}
6990d02b8d719e8845ee68376d9db60eb616e1c778119da4ce3e699f73053f61
parsingFingerprint
public static byte[] parsingFingerprint(String fpName, Schema s) throws NoSuchAlgorithmException
{    return fingerprint(fpName, toParsingForm(s).getBytes(StandardCharsets.UTF_8));}
2c7b1ef54123952ce6c5ec1beb963bb042715ad50abbafe9026892cdd707790a
parsingFingerprint64
public static long parsingFingerprint64(Schema s)
{    return fingerprint64(toParsingForm(s).getBytes(StandardCharsets.UTF_8));}
85dfb2dd865a4eb7628e1086b6bd95a0c26e12e9512f14aff1aec77a586ba198
build
private static Appendable build(Map<String, String> env, Schema s, Appendable o) throws IOException
{    boolean firstTime = true;    Schema.Type st = s.getType();    switch(st) {        default:                        return o.append('"').append(st.getName()).append('"');        case UNION:            o.append('[');            for (Schema b : s.getTypes()) {                if (!firstTime)                    o.append(',');                else                    firstTime = false;                build(env, b, o);            }            return o.append(']');        case ARRAY:        case MAP:            o.append("{\"type\":\"").append(st.getName()).append("\"");            if (st == Schema.Type.ARRAY)                build(env, s.getElementType(), o.append(",\"items\":"));            else                build(env, s.getValueType(), o.append(",\"values\":"));            return o.append("}");        case ENUM:        case FIXED:        case RECORD:            String name = s.getFullName();            if (env.get(name) != null)                return o.append(env.get(name));            String qname = "\"" + name + "\"";            env.put(name, qname);            o.append("{\"name\":").append(qname);            o.append(",\"type\":\"").append(st.getName()).append("\"");            if (st == Schema.Type.ENUM) {                o.append(",\"symbols\":[");                for (String enumSymbol : s.getEnumSymbols()) {                    if (!firstTime)                        o.append(',');                    else                        firstTime = false;                    o.append('"').append(enumSymbol).append('"');                }                o.append("]");            } else if (st == Schema.Type.FIXED) {                o.append(",\"size\":").append(Integer.toString(s.getFixedSize()));            } else {                                o.append(",\"fields\":[");                for (Schema.Field f : s.getFields()) {                    if (!firstTime)                        o.append(',');                    else                        firstTime = false;                    o.append("{\"name\":\"").append(f.name()).append("\"");                    build(env, f.schema(), o.append(",\"type\":")).append("}");                }                o.append("]");            }            return o.append("}");    }}
f7294b102babf9281644d736961ae92b15d373dae6c93c1bed5e2b057b5c749b
getMessage
private static String getMessage(Schema reader, Schema writer)
{    return "Unable to read schema: \n" + writer.toString(true) + "\nusing schema:\n" + reader.toString(true);}
3ec5c3ef122c8f1ec49952d7ac82f4abd4888a4247b02d618416ccf2ed41b4c0
strategy
public SchemaValidatorBuilder strategy(SchemaValidationStrategy strategy)
{    this.strategy = strategy;    return this;}
f47e054e3519c3315ad5b46a63609b294a6bfa7b68cf0b0f9754f695eb8ed44d
canReadStrategy
public SchemaValidatorBuilder canReadStrategy()
{    this.strategy = new ValidateCanRead();    return this;}
b42fe8aa3a35018d5cc17a8476d5559cc8af1c5d9d765d018c72c0437c355309
canBeReadStrategy
public SchemaValidatorBuilder canBeReadStrategy()
{    this.strategy = new ValidateCanBeRead();    return this;}
0f17b864b265ef3e73baf9d8aa3f871d9a80591f0d739b2e6cc9b6b1b6fab78e
mutualReadStrategy
public SchemaValidatorBuilder mutualReadStrategy()
{    this.strategy = new ValidateMutualRead();    return this;}
6c340ff91b688f2d90cbc668a7085fe7bffba0693a2ef5383fd297b03c214a31
validateLatest
public SchemaValidator validateLatest()
{    valid();    return new ValidateLatest(strategy);}
03902a3971b4dde327acbc3dec74bbabe25c6e82ce6476755d68659ccb8ff9b1
validateAll
public SchemaValidator validateAll()
{    valid();    return new ValidateAll(strategy);}
1b6a5d89bf85e7936eafd381c7b0f94b3b588820fdb3596074702dd8fd8cf3d4
valid
private void valid()
{    if (null == strategy) {        throw new AvroRuntimeException("SchemaValidationStrategy not specified in builder");    }}
02422e619fc950e443408bbd36203c4155e09261ea21c537537f17f6e4a56d8f
available
public int available() throws IOException
{    return in.available();}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    in.close();}
23a63ca46da6513daeb255dee9f0a6e74737bbe34c04911d002213961e2f7cc9
markSupported
public boolean markSupported()
{    return false;}
00c6cb892813c6b89e072a7f09dccdece629f30849daab28245b06f3e679bf54
read
public int read() throws IOException
{    return in.read();}
f1bd356e482fbc023feab89d2655df447ac6f2bcd456f7c68cc5c21e4167b36b
read
public int read(byte[] b) throws IOException
{    return in.read(b);}
7c29d2ca5a5da10f1223f4ab55cac18aaed37c1bd49c7ed31be42cef9121fa2e
read
public int read(byte[] b, int offset, int len) throws IOException
{    return in.read(b, offset, len);}
ce76f6aac8f77c67074f3b19112ca15bf61b65a883c96fe1c58af7e5620e8d94
skip
public long skip(long n) throws IOException
{    return in.skip(n);}
c3e67ec76f1b008887f1caba645a2614900cde6e477acca1bc3ecc36bf357fcf
flush
public void flush() throws IOException
{    out.flush();}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    out.close();}
30521fb6e3c2fd5393f830ef40008f4af280bb1fcd1951a0670a10e13dbdc276
write
public void write(int c) throws IOException
{    out.write(c);}
9dc05e09d787e6afa8b5d2cf4cacaf1f65f348fcc597daca5502cd46ac6e898a
write
public void write(byte[] b) throws IOException
{    out.write(b);}
f962862cfe25fe74e4f0ebb9066c383ab26af323b74d14e278c837aaad341afd
write
public void write(byte[] b, int offset, int len) throws IOException
{    out.write(b, offset, len);}
c8b42ddf85fd1412373519fa7ca4651d7c59b7b6dd4be4893a44696e64bd6330
computeValue
protected Constructor computeValue(Class<?> c)
{    boolean useSchema = SchemaConstructable.class.isAssignableFrom(c);    try {        Constructor meth = c.getDeclaredConstructor(useSchema ? SCHEMA_ARG : NO_ARG);        meth.setAccessible(true);        return meth;    } catch (Exception e) {        throw new RuntimeException(e);    }}
7303aaf9e45ab4c8c624b0e6a5d7b5941d362a96397a811d275ccc7e47c2ece3
createDatumReader
public DatumReader createDatumReader(Schema schema)
{    return new SpecificDatumReader(schema, schema, this);}
d21900c7941122070f06c2bc5bc41ce259bc840f1c278c43da933de5ac71ea45
createDatumReader
public DatumReader createDatumReader(Schema writer, Schema reader)
{    return new SpecificDatumReader(writer, reader, this);}
3d2aa170a9dc9e88ce5dff8d9760bdd18b4ddcbfb1066b36a9661ff0df2e90fb
createDatumWriter
public DatumWriter createDatumWriter(Schema schema)
{    return new SpecificDatumWriter(schema, this);}
033bdf8558953e83efef11c5e005e214a1295af7995212872e652951f88985bb
get
public static SpecificData get()
{    return INSTANCE;}
79a576a118ea9608a8cd497d45c2065340a7bf09765f35665abe2abc0061c0aa
getForSchema
public static SpecificData getForSchema(Schema reader)
{    if (reader.getType() == Type.RECORD) {        final String className = getClassName(reader);        if (className != null) {            final Class<?> clazz;            try {                clazz = Class.forName(className);                return getForClass(clazz);            } catch (ClassNotFoundException e) {                return SpecificData.get();            }        }    }    return SpecificData.get();}
b276c433875ab4d9371fd0b9d7f3d7263d5f58b87c58eb0ad74a9d22305816be
getForClass
public static SpecificData getForClass(Class<T> c)
{    if (SpecificRecordBase.class.isAssignableFrom(c)) {        final Field specificDataField;        try {            specificDataField = c.getDeclaredField("MODEL$");            specificDataField.setAccessible(true);            return (SpecificData) specificDataField.get(null);        } catch (NoSuchFieldException e) {                        return SpecificData.get();        } catch (IllegalAccessException e) {            throw new AvroRuntimeException(e);        }    }    return SpecificData.get();}
0fbdb2140ad4e5e766cc5531ed093da5673989f2479706f1bbb30f4fe4703765
useCustomCoders
public boolean useCustomCoders()
{    return useCustomCoderFlag;}
1cd1493175701a1b258f2180486e268b6b056c489cebc110a094a66dc25b29f8
setCustomCoders
public void setCustomCoders(boolean flag)
{    useCustomCoderFlag = flag;}
2c6b4c3e5e1b5ae8caf706d48722ac1779ce6fdfd9deb370b38ef7d438742cb4
isEnum
protected boolean isEnum(Object datum)
{    return datum instanceof Enum || super.isEnum(datum);}
4fc0c5d95b684c99b56ed1131802df61d448960ef74a43b82b2f15885486e240
createEnum
public Object createEnum(String symbol, Schema schema)
{    Class c = getClass(schema);    if (c == null)                return super.createEnum(symbol, schema);    if (RESERVED_WORDS.contains(symbol))        symbol += "$";    return Enum.valueOf(c, symbol);}
efe31e9c514d611d8e133686ecb5d76ca6af03aed27c9a00582fe16e460a135b
getEnumSchema
protected Schema getEnumSchema(Object datum)
{    return (datum instanceof Enum) ? getSchema(datum.getClass()) : super.getEnumSchema(datum);}
7bab8e367e2f292e6cbbd55346a5a1277826d41ce8cd319804b5966308adbeca
getClass
public Class getClass(Schema schema)
{    switch(schema.getType()) {        case FIXED:        case RECORD:        case ENUM:            String name = schema.getFullName();            if (name == null)                return null;            Class c = classCache.get(name);            if (c == null) {                try {                    c = ClassUtils.forName(getClassLoader(), getClassName(schema));                } catch (ClassNotFoundException e) {                    try {                                                c = ClassUtils.forName(getClassLoader(), getNestedClassName(schema));                    } catch (ClassNotFoundException ex) {                        c = NO_CLASS;                    }                }                classCache.put(name, c);            }            return c == NO_CLASS ? null : c;        case ARRAY:            return List.class;        case MAP:            return Map.class;        case UNION:                        List<Schema> types = schema.getTypes();            if ((types.size() == 2) && types.contains(NULL_SCHEMA))                return getWrapper(types.get(types.get(0).equals(NULL_SCHEMA) ? 1 : 0));            return Object.class;        case STRING:            if (STRING_TYPE_STRING.equals(schema.getProp(STRING_PROP)))                return String.class;            return CharSequence.class;        case BYTES:            return ByteBuffer.class;        case INT:            return Integer.TYPE;        case LONG:            return Long.TYPE;        case FLOAT:            return Float.TYPE;        case DOUBLE:            return Double.TYPE;        case BOOLEAN:            return Boolean.TYPE;        case NULL:            return Void.TYPE;        default:            throw new AvroRuntimeException("Unknown type: " + schema);    }}
f9b0e6c5a976b3e7bc9dfa3275e68308e063045ad549187738590cd3a898a1c8
getWrapper
private Class getWrapper(Schema schema)
{    switch(schema.getType()) {        case INT:            return Integer.class;        case LONG:            return Long.class;        case FLOAT:            return Float.class;        case DOUBLE:            return Double.class;        case BOOLEAN:            return Boolean.class;    }    return getClass(schema);}
934b27bb8167b0f727c634f7ffc05dd3127a9d8b23738557a5c96211d36b8a3c
getClassName
public static String getClassName(Schema schema)
{    String namespace = schema.getNamespace();    String name = schema.getName();    if (namespace == null || "".equals(namespace))        return name;        String dot = namespace.endsWith("$") ? "" : ".";    return namespace + dot + name;}
e8ba4301b06acd72dc34d1436101b2794e02ccc30617ed641d33b433bd755874
getNestedClassName
private String getNestedClassName(Schema schema)
{    String namespace = schema.getNamespace();    String name = schema.getName();    if (namespace == null || "".equals(namespace))        return name;    return namespace + "$" + name;}
21bd3087c02c128568ff514645878f7f8533c3555279b29ab3458765f86ea051
computeValue
protected Schema computeValue(Class<?> type)
{    return createSchema(type, new LinkedHashMap<>());}
fb3a2ee1e87f6dc697d459d9468f0b5d56bcb320d4e154c4738c046f66e26294
getSchema
public Schema getSchema(java.lang.reflect.Type type)
{    try {        if (type instanceof Class) {            return schemaClassCache.get((Class<?>) type);        }        return schemaTypeCache.computeIfAbsent(type, t -> createSchema(t, new LinkedHashMap<>()));    } catch (Exception e) {        throw (e instanceof AvroRuntimeException) ? (AvroRuntimeException) e : new AvroRuntimeException(e);    }}
617b6e500ac0f56be398cec4a29291330d2494869e05061cb21c6bb11d64bbd3
createSchema
protected Schema createSchema(java.lang.reflect.Type type, Map<String, Schema> names)
{    if (type instanceof Class && CharSequence.class.isAssignableFrom((Class) type))        return Schema.create(Type.STRING);    else if (type == ByteBuffer.class)        return Schema.create(Type.BYTES);    else if ((type == Integer.class) || (type == Integer.TYPE))        return Schema.create(Type.INT);    else if ((type == Long.class) || (type == Long.TYPE))        return Schema.create(Type.LONG);    else if ((type == Float.class) || (type == Float.TYPE))        return Schema.create(Type.FLOAT);    else if ((type == Double.class) || (type == Double.TYPE))        return Schema.create(Type.DOUBLE);    else if ((type == Boolean.class) || (type == Boolean.TYPE))        return Schema.create(Type.BOOLEAN);    else if ((type == Void.class) || (type == Void.TYPE))        return Schema.create(Type.NULL);    else if (type instanceof ParameterizedType) {        ParameterizedType ptype = (ParameterizedType) type;        Class raw = (Class) ptype.getRawType();        java.lang.reflect.Type[] params = ptype.getActualTypeArguments();        if (Collection.class.isAssignableFrom(raw)) {                        if (params.length != 1)                throw new AvroTypeException("No array type specified.");            return Schema.createArray(createSchema(params[0], names));        } else if (Map.class.isAssignableFrom(raw)) {                        java.lang.reflect.Type key = params[0];            java.lang.reflect.Type value = params[1];            if (!(key instanceof Class && CharSequence.class.isAssignableFrom((Class) key)))                throw new AvroTypeException("Map key class not CharSequence: " + key);            return Schema.createMap(createSchema(value, names));        } else {            return createSchema(raw, names);        }    } else if (type instanceof Class) {                Class c = (Class) type;        String fullName = c.getName();        Schema schema = names.get(fullName);        if (schema == null)            try {                schema = (Schema) (c.getDeclaredField("SCHEMA$").get(null));                if (!fullName.equals(getClassName(schema)))                                        schema = new Schema.Parser().parse(schema.toString().replace(schema.getNamespace(), c.getPackage().getName()));            } catch (NoSuchFieldException e) {                throw new AvroRuntimeException("Not a Specific class: " + c);            } catch (IllegalAccessException e) {                throw new AvroRuntimeException(e);            }        names.put(fullName, schema);        return schema;    }    throw new AvroTypeException("Unknown type: " + type);}
cdd96ec067b8dcb31118b105538f4c0303b1e6ac47ba1af2c8403a287d499a28
getSchemaName
protected String getSchemaName(Object datum)
{    if (datum != null) {        Class c = datum.getClass();        if (isStringable(c))            return Schema.Type.STRING.getName();    }    return super.getSchemaName(datum);}
4e5d39adece14125e36b43aed4da6eb493af92260be4076f69a79253f56968e0
isStringable
protected boolean isStringable(Class<?> c)
{    return stringableClasses.contains(c);}
e26c30626f9ffeecded2f47d4da47723bf44b5c827136e7022ee46c1781e3b70
isStringType
protected boolean isStringType(Class<?> c)
{        return CharSequence.class.isAssignableFrom(c);}
20fdd2ad4c5bb3e4e60a846fdb617933768777f451eb95cbf9630e145ef13fdd
getProtocol
public Protocol getProtocol(Class iface)
{    try {        Protocol p = (Protocol) (iface.getDeclaredField("PROTOCOL").get(null));        if (!p.getNamespace().equals(iface.getPackage().getName()))                        p = Protocol.parse(p.toString().replace(p.getNamespace(), iface.getPackage().getName()));        return p;    } catch (NoSuchFieldException e) {        throw new AvroRuntimeException("Not a Specific protocol: " + iface);    } catch (IllegalAccessException e) {        throw new AvroRuntimeException(e);    }}
97178ab179401811ebdd3e76d74d84e5358d5e1216505d8d8420e1c6ef5ee500
compare
protected int compare(Object o1, Object o2, Schema s, boolean eq)
{    switch(s.getType()) {        case ENUM:            if (o1 instanceof Enum)                return ((Enum) o1).ordinal() - ((Enum) o2).ordinal();        default:            return super.compare(o1, o2, s, eq);    }}
9724b9c832c7be5f0c1a4ec0e5d453b50afb13d8fcc8fe179b1720f21c8e389d
newInstance
public static Object newInstance(Class c, Schema s)
{    boolean useSchema = SchemaConstructable.class.isAssignableFrom(c);    Object result;    try {        Constructor meth = CTOR_CACHE.get(c);        result = meth.newInstance(useSchema ? new Object[] { s } : null);    } catch (Exception e) {        throw new RuntimeException(e);    }    return result;}
e9f985f61755456b769f1756d4f69f9d6ecd02540acbc734c3fdaf9ef00419d1
createFixed
public Object createFixed(Object old, Schema schema)
{    Class c = getClass(schema);    if (c == null)                return super.createFixed(old, schema);    return c.isInstance(old) ? old : newInstance(c, schema);}
29054906d4af7be8dc8790cace3ee77ee70e4d288fe6c3430ecd85a8301c0864
newRecord
public Object newRecord(Object old, Schema schema)
{    Class c = getClass(schema);    if (c == null)                return super.newRecord(old, schema);    return (c.isInstance(old) ? old : newInstance(c, schema));}
e9591c4e631651eb35a40d8eb8904ea88dd4a12cd8cb9560a5f9a095f7497ea4
getDecoder
public static BinaryDecoder getDecoder(ObjectInput in)
{    return DecoderFactory.get().directBinaryDecoder(new ExternalizableInput(in), null);}
e095026c98b9fb4dee8b29cbf800b0703b670d50beec16c5f8cef7eebae03eb3
getEncoder
public static BinaryEncoder getEncoder(ObjectOutput out)
{    return EncoderFactory.get().directBinaryEncoder(new ExternalizableOutput(out), null);}
b29b116b51cf90cb4852275e4c13929f6821310bf77a722d1dd150e9b330b0ca
getSpecificData
public SpecificData getSpecificData()
{    return (SpecificData) getData();}
07f621e20ade7c93838a09d197fd6ea733f826eb24f3f2c49ac3ebd372e45432
setSchema
public void setSchema(Schema actual)
{        if (getExpected() == null && actual != null && actual.getType() == Schema.Type.RECORD) {        SpecificData data = getSpecificData();        Class c = data.getClass(actual);        if (c != null && SpecificRecord.class.isAssignableFrom(c))            setExpected(data.getSchema(c));    }    super.setSchema(actual);}
d4c41b1db4917b34a87e87357091b704b8e1924023626519d08e35518107417b
findStringClass
protected Class findStringClass(Schema schema)
{    Class stringClass = null;    switch(schema.getType()) {        case STRING:            stringClass = getPropAsClass(schema, SpecificData.CLASS_PROP);            break;        case MAP:            stringClass = getPropAsClass(schema, SpecificData.KEY_CLASS_PROP);            break;    }    if (stringClass != null)        return stringClass;    return super.findStringClass(schema);}
fad06382c20816d096819119b99a4b626b4dc98dff229ddedf1781f548f9b4ef
getPropAsClass
private Class getPropAsClass(Schema schema, String prop)
{    String name = schema.getProp(prop);    if (name == null)        return null;    try {        return ClassUtils.forName(getData().getClassLoader(), name);    } catch (ClassNotFoundException e) {        throw new AvroRuntimeException(e);    }}
53d42b61ceafb918d7034fad0c71fbf84442dc73259eea122f38ea53fd89bc7e
readRecord
protected Object readRecord(Object old, Schema expected, ResolvingDecoder in) throws IOException
{    SpecificData data = getSpecificData();    if (data.useCustomCoders()) {        old = data.newRecord(old, expected);        if (old instanceof SpecificRecordBase) {            SpecificRecordBase d = (SpecificRecordBase) old;            if (d.hasCustomCoders()) {                d.customDecode(in);                return d;            }        }    }    return super.readRecord(old, expected, in);}
466a452902386342bc0edce6f94a8cdbc8d1b294f9643a7067a8ddeb046a3fcd
readField
protected void readField(Object r, Schema.Field f, Object oldDatum, ResolvingDecoder in, Object state) throws IOException
{    if (r instanceof SpecificRecordBase) {        Conversion<?> conversion = ((SpecificRecordBase) r).getConversion(f.pos());        Object datum;        if (conversion != null) {            datum = readWithConversion(oldDatum, f.schema(), f.schema().getLogicalType(), conversion, in);        } else {            datum = readWithoutConversion(oldDatum, f.schema(), in);        }        getData().setField(r, f.name(), f.pos(), datum);    } else {        super.readField(r, f, oldDatum, in, state);    }}
b29b116b51cf90cb4852275e4c13929f6821310bf77a722d1dd150e9b330b0ca
getSpecificData
public SpecificData getSpecificData()
{    return (SpecificData) getData();}
4991313986c666ab7d89ef913042220d7e658389c5ff820c0c2890814b8ef1ce
writeEnum
protected void writeEnum(Schema schema, Object datum, Encoder out) throws IOException
{    if (!(datum instanceof Enum))                super.writeEnum(schema, datum, out);    else        out.writeEnum(((Enum) datum).ordinal());}
a4fb16253b93561ac2bbac8de69e799569e7c9f2ea9f1480af61479dbe9b5d55
writeString
protected void writeString(Schema schema, Object datum, Encoder out) throws IOException
{    if (!(datum instanceof CharSequence) && getSpecificData().isStringable(datum.getClass())) {                datum = datum.toString();    }    writeString(datum, out);}
231c86f7e1f982553774a596296e6507032115afbd20b06cd154cd810f6a6172
writeRecord
protected void writeRecord(Schema schema, Object datum, Encoder out) throws IOException
{    if (datum instanceof SpecificRecordBase && this.getSpecificData().useCustomCoders()) {        SpecificRecordBase d = (SpecificRecordBase) datum;        if (d.hasCustomCoders()) {            d.customEncode(out);            return;        }    }    super.writeRecord(schema, datum, out);}
cbe21d807d9b1484a319c68056b34b3e53f3060b8b8cd8188c65a6c4975d57cb
writeField
protected void writeField(Object datum, Schema.Field f, Encoder out, Object state) throws IOException
{    if (datum instanceof SpecificRecordBase) {        Conversion<?> conversion = ((SpecificRecordBase) datum).getConversion(f.pos());        Schema fieldSchema = f.schema();        LogicalType logicalType = fieldSchema.getLogicalType();        Object value = getData().getField(datum, f.name(), f.pos());        if (conversion != null && logicalType != null) {            value = convert(fieldSchema, logicalType, conversion, value);        }        writeWithoutConversion(fieldSchema, value, out);    } else {        super.writeField(datum, f, out, state);    }}
cc9131919df0823e8e8ee6054b03ea6d4a394f817422ddb0f9240211f097bcaf
getValue
public Object getValue()
{    return value;}
1f0cfc061971d2811412b1c495d165cf6b432edee17642b906fe96e9601e73d3
setValue
public SpecificErrorBuilderBase<T> setValue(Object value)
{    this.value = value;    hasValue = true;    return this;}
258d74581b7c36a36f14ac351a56248c96622e4794d629fa1d8f556bd5b32cfc
hasValue
public boolean hasValue()
{    return hasValue;}
a32c85213995baef206a187f3f3d936784fb5a7a677aae5a48e5281de10d1c69
clearValue
public SpecificErrorBuilderBase<T> clearValue()
{    value = null;    hasValue = false;    return this;}
3e7d70044d393c21fe2b8a32bb324941f159bc4a69cb81127e56e927719c28fd
getCause
public Throwable getCause()
{    return cause;}
ca9aecbe421fedb5dfccb246c61e6aa53ba2e77c0e3c938e278ed4bde14a9c89
setCause
public SpecificErrorBuilderBase<T> setCause(Throwable cause)
{    this.cause = cause;    hasCause = true;    return this;}
55f15fe517471f698cd9e3c6c016219efd8f59957ee99d83eb6cab262bb82049
hasCause
public boolean hasCause()
{    return hasCause;}
6d8063655532d72b84256a753470fe2f097dccec5cd8a921e03405d411a5ee7f
clearCause
public SpecificErrorBuilderBase<T> clearCause()
{    cause = null;    hasCause = false;    return this;}
6b3ab298cb5d88dbb2c510c786f53e377489a40e2716e63c26a3e1691765f6c5
equals
public boolean equals(Object that)
{    if (that == this)                return true;    if (!(that instanceof SpecificExceptionBase))                return false;    if (this.getClass() != that.getClass())                return false;    return SpecificData.get().compare(this, that, this.getSchema()) == 0;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return SpecificData.get().hashCode(this, this.getSchema());}
0ebdc42efb188446d741b97a6df5d96648a495197c65beeba1fbed594575116b
bytes
public void bytes(byte[] bytes)
{    this.bytes = bytes;}
a1528398c6f8bd447ff6dc9c5f661a8eb0772003264c65121cd798751908d562
bytes
public byte[] bytes()
{    return bytes;}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (o == this)        return true;    return o instanceof GenericFixed && Arrays.equals(bytes, ((GenericFixed) o).bytes());}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return Arrays.hashCode(bytes);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return Arrays.toString(bytes);}
ccf331e242ac0c55ca53cc57095b643d6a2b96895af20c15be3b86a874e1e2c7
compareTo
public int compareTo(SpecificFixed that)
{    return BinaryData.compareBytes(this.bytes, 0, this.bytes.length, that.bytes, 0, that.bytes.length);}
b29b116b51cf90cb4852275e4c13929f6821310bf77a722d1dd150e9b330b0ca
getSpecificData
public SpecificData getSpecificData()
{        return SpecificData.get();}
8663638f2dfc16ac26e2ed724fe26d77ae0743cb4494fca59ef7ef8e5a941e2f
getConversion
public Conversion<?> getConversion(int field)
{        return null;}
29da2b24ef1d6a6c846255e95273d2884f37cc0ef557f634b0885fb8dac759c0
put
public void put(String fieldName, Object value)
{    put(getSchema().getField(fieldName).pos(), value);}
3f1c898ac3c2d7ef683a7f5663fea81e77983c3f25d8c83b0b35640de3f215b2
get
public Object get(String fieldName)
{    return get(getSchema().getField(fieldName).pos());}
21e4424b375477bf6d73c64dfa3f4b75d17ad1d29e26e532562892083321b122
getConversion
public Conversion<?> getConversion(String fieldName)
{    return getConversion(getSchema().getField(fieldName).pos());}
6b3ab298cb5d88dbb2c510c786f53e377489a40e2716e63c26a3e1691765f6c5
equals
public boolean equals(Object that)
{    if (that == this)                return true;    if (!(that instanceof SpecificRecord))                return false;    if (this.getClass() != that.getClass())                return false;    return getSpecificData().compare(this, that, this.getSchema(), true) == 0;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return getSpecificData().hashCode(this, this.getSchema());}
bdb62e62e67477faa8afbf2c318e037bb9934fb0721ad7c40a2706b3867ab0e3
compareTo
public int compareTo(SpecificRecord that)
{    return getSpecificData().compare(this, that, this.getSchema());}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return getSpecificData().toString(this);}
e353b9034bf1e60c7967278cc71265b61235ede76db5c3f146554b657effa0f5
writeExternal
public void writeExternal(ObjectOutput out) throws IOException
{    new SpecificDatumWriter(getSchema()).write(this, SpecificData.getEncoder(out));}
fd32a092bc244b6996bd8dadaf2801d7b1a2f6d1e5ef2bd29d52df950d010fa5
readExternal
public void readExternal(ObjectInput in) throws IOException
{    new SpecificDatumReader(getSchema()).read(this, SpecificData.getDecoder(in));}
f9766a02b20bb399ad69d92ada896e23691f38494421a4be07acaf852bb87f9c
hasCustomCoders
protected boolean hasCustomCoders()
{    return false;}
f490c2fbb6b1b731b287af9d1f5068304b91bf67c8673dd36bff8493e58de2c5
customEncode
public void customEncode(Encoder out) throws IOException
{    throw new UnsupportedOperationException();}
3379528162c573443b6f042b0834b38dde45d6bc2f5f0da832cfe4ab144bbd6b
customDecode
public void customDecode(ResolvingDecoder in) throws IOException
{    throw new UnsupportedOperationException();}
4a8dc087a1ca0929c4359ee7bde729378da5198cd7699a2f67e0ecc28c95f2bb
getUnresolvedDatum
public Object getUnresolvedDatum()
{    return unresolvedDatum;}
424c4afbbbe44889f77f8694031244b1375dfabbd11ed164acf0c770e71b1f7e
getUnionSchema
public Schema getUnionSchema()
{    return unionSchema;}
00c6cb892813c6b89e072a7f09dccdece629f30849daab28245b06f3e679bf54
read
public int read() throws IOException
{    ByteBuffer buffer = getBuffer();    if (buffer == null) {        return -1;    }    return buffer.get() & 0xff;}
56e08d87e6bd0be2a60f9b2de3195d58bc9d56a2637f6fed6210d21e832632ea
read
public int read(byte[] b, int off, int len) throws IOException
{    if (len == 0)        return 0;    ByteBuffer buffer = getBuffer();    if (buffer == null) {        return -1;    }    int remaining = buffer.remaining();    if (len > remaining) {        buffer.get(b, off, remaining);        return remaining;    } else {        buffer.get(b, off, len);        return len;    }}
55499205e95409f9921427d05c49593c06eb8411e4b7b4dd7afac78bca8a820e
readBuffer
public ByteBuffer readBuffer(int length) throws IOException
{    if (length == 0)        return ByteBuffer.allocate(0);    ByteBuffer buffer = getBuffer();    if (buffer == null) {        return ByteBuffer.allocate(0);    }    if (buffer.remaining() == length) {                current++;                return buffer;    }        ByteBuffer result = ByteBuffer.allocate(length);    int start = 0;    while (start < length) start += read(result.array(), start, length - start);    return result;}
dd7a8f955a7f303833599828fd356b9276a178986afc7121fbf03b9194b7341c
getBuffer
private ByteBuffer getBuffer() throws IOException
{    while (current < buffers.size()) {        ByteBuffer buffer = buffers.get(current);        if (buffer.hasRemaining())            return buffer;        current++;    }    return null;}
9de5fecf302cf84753338d5cec1d42d44ac5da73c8e780ff15c37f49256235ab
getBufferList
public List<ByteBuffer> getBufferList()
{    List<ByteBuffer> result = buffers;    reset();    for (ByteBuffer buffer : result) buffer.flip();    return result;}
e253a5a956ebefae467f85c432cb97c344d6e6441a295edd38a86dcf487d57ae
prepend
public void prepend(List<ByteBuffer> lists)
{    for (ByteBuffer buffer : lists) {        buffer.position(buffer.limit());    }    buffers.addAll(0, lists);}
141e533c7f21b0447a446e8d813fd890cc7fa6ea628d8f96055cf862bbf590b1
append
public void append(List<ByteBuffer> lists)
{    for (ByteBuffer buffer : lists) {        buffer.position(buffer.limit());    }    buffers.addAll(lists);}
97d2d353f08aa5a1da8b18b0800b6e778df65f48d34726e5f17800df7e0d88e2
reset
public void reset()
{    buffers = new ArrayList<>();    buffers.add(ByteBuffer.allocate(BUFFER_SIZE));}
6aa710bec1ac7ed2fe9afe54a82f23c5e6f5a2cb241b4c24f7dbc4f492b164ab
write
public void write(ByteBuffer buffer)
{    buffers.add(buffer);}
25b35cf2ca566b5b4b14451f4ded1a3f4e745f0a14883c16b91d1495a5574ab6
write
public void write(int b)
{    ByteBuffer buffer = buffers.get(buffers.size() - 1);    if (buffer.remaining() < 1) {        buffer = ByteBuffer.allocate(BUFFER_SIZE);        buffers.add(buffer);    }    buffer.put((byte) b);}
ff0b219f0fb5d98769feafdb43b42bceec5beac4330d68da85f0f922f1b42b7f
write
public void write(byte[] b, int off, int len)
{    ByteBuffer buffer = buffers.get(buffers.size() - 1);    int remaining = buffer.remaining();    while (len > remaining) {        buffer.put(b, off, remaining);        len -= remaining;        off += remaining;        buffer = ByteBuffer.allocate(BUFFER_SIZE);        buffers.add(buffer);        remaining = buffer.remaining();    }    buffer.put(b, off, len);}
953ba2f3c5736bcd94b51b7cc4b0c1f72f2a7712118d6e5321c10e1ae4500969
writeBuffer
public void writeBuffer(ByteBuffer buffer) throws IOException
{    if (buffer.remaining() < BUFFER_SIZE) {        write(buffer.array(), buffer.position(), buffer.remaining());    } else {                ByteBuffer dup = buffer.duplicate();                dup.position(buffer.limit());        buffers.add(dup);    }}
ba472f0276299a649671243466986c28f8fbecefbbb1e4a2119ac22960ad9cc4
forName
public static Class<?> forName(String className) throws ClassNotFoundException
{    return ClassUtils.forName(ClassUtils.class, className);}
77906b4a60479e36ad9b858e47370a4163a7987cca06a506e025b1da2321ee29
forName
public static Class<?> forName(Class<?> contextClass, String className) throws ClassNotFoundException
{    Class<?> c = null;    if (contextClass.getClassLoader() != null) {        c = forName(className, contextClass.getClassLoader());    }    if (c == null && Thread.currentThread().getContextClassLoader() != null) {        c = forName(className, Thread.currentThread().getContextClassLoader());    }    if (c == null) {        throw new ClassNotFoundException("Failed to load class" + className);    }    return c;}
7ce15a84af737a96a016441c4affc67aec40c53f5afae0ab09ad92be82eb0c73
forName
public static Class<?> forName(ClassLoader classLoader, String className) throws ClassNotFoundException
{    Class<?> c = null;    if (classLoader != null) {        c = forName(className, classLoader);    }    if (c == null && Thread.currentThread().getContextClassLoader() != null) {        c = forName(className, Thread.currentThread().getContextClassLoader());    }    if (c == null) {        throw new ClassNotFoundException("Failed to load class" + className);    }    return c;}
3de9994f055f8a71d30d8859468add7c6682ac5ff1e64b4013557a3a2735d2fd
forName
private static Class<?> forName(String className, ClassLoader classLoader)
{    Class<?> c = null;    if (classLoader != null && className != null) {        try {            c = Class.forName(className, true, classLoader);        } catch (ClassNotFoundException e) {                }    }    return c;}
e1a8b6f1aca8eb7712370436d428b55c0691c14c02a271a800459a7fbda5b979
setAccessor
public static void setAccessor(JsonPropertiesAccessor accessor)
{    if (jsonPropertiesAccessor != null)        throw new IllegalStateException("JsonPropertiesAccessor already initialized");    jsonPropertiesAccessor = accessor;}
4a67305e5538df233e53ed4b8331217a84f7691d20a3cbaa6a1f920243e9f73c
setAccessor
public static void setAccessor(FieldAccessor accessor)
{    if (fieldAccessor != null)        throw new IllegalStateException("FieldAccessor already initialized");    fieldAccessor = accessor;}
56d01fce7892d89a6a1f728c49acc3b918ffc1ee321fcac2dd084e0c2450ee62
fieldAccessor
private static FieldAccessor fieldAccessor()
{    if (fieldAccessor == null)        ensureLoaded(Field.class);    return fieldAccessor;}
6c9878a13386a2de56a9d937033abcc5131a983f88cf13f1cd603f6f564d34de
setAccessor
public static void setAccessor(ResolvingGrammarGeneratorAccessor accessor)
{    if (resolvingGrammarGeneratorAccessor != null)        throw new IllegalStateException("ResolvingGrammarGeneratorAccessor already initialized");    resolvingGrammarGeneratorAccessor = accessor;}
6be62350d5f971582400431bf94938307f1908fe3da04199126dc872aedcb8b2
resolvingGrammarGeneratorAccessor
private static ResolvingGrammarGeneratorAccessor resolvingGrammarGeneratorAccessor()
{    if (resolvingGrammarGeneratorAccessor == null)        ensureLoaded(ResolvingGrammarGenerator.class);    return resolvingGrammarGeneratorAccessor;}
06e43935461ed8bee643de03fa5b1aa4eb975c7850341029058d60a5a5457b6a
ensureLoaded
private static void ensureLoaded(Class<?> c)
{    try {        Class.forName(c.getName());    } catch (ClassNotFoundException e) {        }}
2b549165acf549bea585022e6bf5752bbc71b19ba4485aff9119ce697ddd9817
addProp
public static void addProp(JsonProperties props, String name, JsonNode value)
{    jsonPropertiesAccessor.addProp(props, name, value);}
c8f32cc1d17cc8d25c89a36e69b36f80c3a3dee3f23644bc05503c20de98fa37
defaultValue
public static JsonNode defaultValue(Field field)
{    return fieldAccessor.defaultValue(field);}
92c718bd9193a0c59789c7979849b6f87dd8c1f5078ee5a2a2a2f63e2237d193
encode
public static void encode(Encoder e, Schema s, JsonNode n) throws IOException
{    resolvingGrammarGeneratorAccessor().encode(e, s, n);}
27337a911d10e628a1bdcfe5983a7da1654878d5759f0644ad592a9739c04ba3
createField
public static Field createField(String name, Schema schema, String doc, JsonNode defaultValue, boolean validate, Order order)
{    return fieldAccessor().createField(name, schema, doc, defaultValue, validate, order);}
7fcb589c4e59685f9a8cc07290c01b59f93fd824c24b5b23eb4996696323f540
createField
public static Field createField(String name, Schema schema, String doc, JsonNode defaultValue)
{    return fieldAccessor().createField(name, schema, doc, defaultValue);}
7f5da595ad218e50eb04575080989fa4341191ada0e748797d7c214cab7ee981
toJsonNode
public static JsonNode toJsonNode(Object datum)
{    if (datum == null) {        return null;    }    try {        TokenBuffer generator = new TokenBuffer(new ObjectMapper(), false);        toJson(datum, generator);        return new ObjectMapper().readTree(generator.asParser());    } catch (IOException e) {        throw new AvroRuntimeException(e);    }}
ad3be5eaa842de660c5dc4ea035084839d1bd156a73444f1ce1a7847ead5893b
toJson
 static void toJson(Object datum, JsonGenerator generator) throws IOException
{    if (datum == JsonProperties.NULL_VALUE) {                generator.writeNull();    } else if (datum instanceof Map) {                generator.writeStartObject();        for (Map.Entry<Object, Object> entry : ((Map<Object, Object>) datum).entrySet()) {            generator.writeFieldName(entry.getKey().toString());            toJson(entry.getValue(), generator);        }        generator.writeEndObject();    } else if (datum instanceof Collection) {                generator.writeStartArray();        for (Object element : (Collection<?>) datum) {            toJson(element, generator);        }        generator.writeEndArray();    } else if (datum instanceof byte[]) {                generator.writeString(new String((byte[]) datum, StandardCharsets.ISO_8859_1));    } else if (datum instanceof CharSequence || datum instanceof Enum<?>) {                generator.writeString(datum.toString());    } else if (datum instanceof Double) {                generator.writeNumber((Double) datum);    } else if (datum instanceof Float) {                generator.writeNumber((Float) datum);    } else if (datum instanceof Long) {                generator.writeNumber((Long) datum);    } else if (datum instanceof Integer) {                generator.writeNumber((Integer) datum);    } else if (datum instanceof Boolean) {                generator.writeBoolean((Boolean) datum);    } else {        throw new AvroRuntimeException("Unknown datum class: " + datum.getClass());    }}
fc57f9dccc8e47805870af131522b94b098595d25eb5fb8800da5a2e5dfcc7d9
toObject
public static Object toObject(JsonNode jsonNode)
{    return toObject(jsonNode, null);}
b71f31c6d9a0e24ef797396f554546f483da43180d388dc2ae268d77abebc08a
toObject
public static Object toObject(JsonNode jsonNode, Schema schema)
{    if (schema != null && schema.getType().equals(Schema.Type.UNION)) {        return toObject(jsonNode, schema.getTypes().get(0));    }    if (jsonNode == null) {        return null;    } else if (jsonNode.isNull()) {        return JsonProperties.NULL_VALUE;    } else if (jsonNode.isBoolean()) {        return jsonNode.asBoolean();    } else if (jsonNode.isInt()) {        if (schema == null || schema.getType().equals(Schema.Type.INT)) {            return jsonNode.asInt();        } else if (schema.getType().equals(Schema.Type.LONG)) {            return jsonNode.asLong();        }    } else if (jsonNode.isLong()) {        return jsonNode.asLong();    } else if (jsonNode.isDouble() || jsonNode.isFloat()) {        if (schema == null || schema.getType().equals(Schema.Type.DOUBLE)) {            return jsonNode.asDouble();        } else if (schema.getType().equals(Schema.Type.FLOAT)) {            return (float) jsonNode.asDouble();        }    } else if (jsonNode.isTextual()) {        if (schema == null || schema.getType().equals(Schema.Type.STRING) || schema.getType().equals(Schema.Type.ENUM)) {            return jsonNode.asText();        } else if (schema.getType().equals(Schema.Type.BYTES) || schema.getType().equals(Schema.Type.FIXED)) {            return jsonNode.textValue().getBytes(StandardCharsets.ISO_8859_1);        }    } else if (jsonNode.isArray()) {        List l = new ArrayList();        for (JsonNode node : jsonNode) {            l.add(toObject(node, schema == null ? null : schema.getElementType()));        }        return l;    } else if (jsonNode.isObject()) {        Map m = new LinkedHashMap();        for (Iterator<String> it = jsonNode.fieldNames(); it.hasNext(); ) {            String key = it.next();            Schema s = null;            if (schema == null) {                s = null;            } else if (schema.getType().equals(Schema.Type.MAP)) {                s = schema.getValueType();            } else if (schema.getType().equals(Schema.Type.RECORD)) {                s = schema.getField(key).schema();            }            Object value = toObject(jsonNode.get(key), s);            m.put(key, value);        }        return m;    }    return null;}
9b6f1738b73576e5dd727082e75be93d01a1de9cbbbfe3775e151380b303762a
iterator
public Iterator<Object> iterator()
{    return new Iterator<Object>() {        private int n;        private Random random = new Random(seed);        @Override        public boolean hasNext() {            return n < count;        }        @Override        public Object next() {            n++;            return generate(root, random, 0);        }        @Override        public void remove() {            throw new UnsupportedOperationException();        }    };}
d51e5f7450eca0a0f63da1a466189e262d053b84aa767ba3be5cea740af7251b
hasNext
public boolean hasNext()
{    return n < count;}
884880fd5e310dd1ce8eab45c21d6aafbaa7291ad8e22163521fd6a1125719ac
next
public Object next()
{    n++;    return generate(root, random, 0);}
eb35e4acc0ab2c89fd30970f01fba35488b3a4581b2af1986091209043508a3e
remove
public void remove()
{    throw new UnsupportedOperationException();}
d94b7d1ec597645b5e5a28ad0f14079d1ffcd7580afff61a59f7314da083f526
generate
private Object generate(Schema schema, Random random, int d)
{    switch(schema.getType()) {        case RECORD:            GenericRecord record = new GenericData.Record(schema);            for (Schema.Field field : schema.getFields()) {                Object value = (field.getObjectProp(USE_DEFAULT) == null) ? generate(field.schema(), random, d + 1) : GenericData.get().getDefaultValue(field);                record.put(field.name(), value);            }            return record;        case ENUM:            List<String> symbols = schema.getEnumSymbols();            return new GenericData.EnumSymbol(schema, symbols.get(random.nextInt(symbols.size())));        case ARRAY:            int length = (random.nextInt(5) + 2) - d;            @SuppressWarnings("rawtypes")            GenericArray<Object> array = new GenericData.Array(length <= 0 ? 0 : length, schema);            for (int i = 0; i < length; i++) array.add(generate(schema.getElementType(), random, d + 1));            return array;        case MAP:            length = (random.nextInt(5) + 2) - d;            Map<Object, Object> map = new HashMap<>(length <= 0 ? 0 : length);            for (int i = 0; i < length; i++) {                map.put(randomString(random, 40), generate(schema.getValueType(), random, d + 1));            }            return map;        case UNION:            List<Schema> types = schema.getTypes();            return generate(types.get(random.nextInt(types.size())), random, d);        case FIXED:            byte[] bytes = new byte[schema.getFixedSize()];            random.nextBytes(bytes);            return new GenericData.Fixed(schema, bytes);        case STRING:            return randomString(random, 40);        case BYTES:            return randomBytes(random, 40);        case INT:            return random.nextInt();        case LONG:            return random.nextLong();        case FLOAT:            return random.nextFloat();        case DOUBLE:            return random.nextDouble();        case BOOLEAN:            return random.nextBoolean();        case NULL:            return null;        default:            throw new RuntimeException("Unknown type: " + schema);    }}
0d6d57acb24ea4d66f28a74bdaa15f54556b7c64bc3eaea2238d016110ac65f4
randomString
private Object randomString(Random random, int maxLength)
{    int length = random.nextInt(maxLength);    byte[] bytes = new byte[length];    for (int i = 0; i < length; i++) {        bytes[i] = (byte) ('a' + random.nextInt('z' - 'a'));    }    return utf8ForString ? new Utf8(bytes) : new String(bytes, UTF8);}
2d452e62f9c1f111e80a7b8c9dcd7c7f3286e66273d01ff1e23e80843a81827c
randomBytes
private static ByteBuffer randomBytes(Random rand, int maxLength)
{    ByteBuffer bytes = ByteBuffer.allocate(rand.nextInt(maxLength));    bytes.limit(bytes.capacity());    rand.nextBytes(bytes.array());    return bytes;}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    if (args.length < 3 || args.length > 4) {        System.out.println("Usage: RandomData <schemafile> <outputfile> <count> [codec]");        System.exit(-1);    }    Schema sch = new Schema.Parser().parse(new File(args[0]));    DataFileWriter<Object> writer = new DataFileWriter<>(new GenericDatumWriter<>());    writer.setCodec(CodecFactory.fromString(args.length >= 4 ? args[3] : "null"));    writer.create(sch, new File(args[1]));    try {        for (Object datum : new RandomData(sch, Integer.parseInt(args[2]))) {            writer.append(datum);        }    } finally {        writer.close();    }}
e2bfd2c1981931d465d0e1ae89010e80092dd454db8039a30052e94606fc0981
setByteArray
public void setByteArray(byte[] buf, int offset, int length)
{    this.buf = buf;    this.pos = offset;    this.count = Math.min(offset + length, buf.length);    this.mark = offset;}
5292fe655e1d1e2c69c8e8ee27e05b589040e6174b71c90ce83b1599f02fbcd2
setByteBuffer
public void setByteBuffer(ByteBuffer buf)
{        this.buffer = buf.duplicate();    this.mark = buf.position();}
00c6cb892813c6b89e072a7f09dccdece629f30849daab28245b06f3e679bf54
read
public int read() throws IOException
{    if (buffer.hasRemaining()) {        return buffer.get() & 0xff;    } else {        return -1;    }}
56e08d87e6bd0be2a60f9b2de3195d58bc9d56a2637f6fed6210d21e832632ea
read
public int read(byte[] b, int off, int len) throws IOException
{    if (buffer.remaining() <= 0) {        return -1;    }        int bytesToRead = Math.min(len, buffer.remaining());    buffer.get(b, off, bytesToRead);    return bytesToRead;}
ce76f6aac8f77c67074f3b19112ca15bf61b65a883c96fe1c58af7e5620e8d94
skip
public long skip(long n) throws IOException
{    if (n <= 0) {                return 0;    }        int bytesToSkip = n > buffer.remaining() ? buffer.remaining() : (int) n;    buffer.position(buffer.position() + bytesToSkip);    return bytesToSkip;}
f72a3e1f3f4caafeed1a74b352c5e2f1916582c57ba908df90b4b67c4f16cc3d
mark
public synchronized void mark(int readLimit)
{                this.mark = buffer.position();}
8dffc85e05aab40453485468b7327673d537932322af366b28f0c26e5fcccd02
reset
public synchronized void reset() throws IOException
{    buffer.position(mark);}
23a63ca46da6513daeb255dee9f0a6e74737bbe34c04911d002213961e2f7cc9
markSupported
public boolean markSupported()
{    return true;}
c159a0fb57e2ba9a7fb373b47eabbc552079ef89a4a50bbca7903b879542d25a
getBytes
public byte[] getBytes()
{    return bytes;}
1e7a9ccf869d4ffcaafdb7996c8f1f820d6f2af9eb816b65ead1db5bcfc3f744
getLength
public int getLength()
{    return length;}
b338aac3b4ae6820f3ae3eb5ba4bcfdffb7f467fa5f4a3ba653889c1d256850f
getByteLength
public int getByteLength()
{    return length;}
87f234edcb35815c106ab68deac61360784a561629328dbc2c196e764194fb32
setLength
public Utf8 setLength(int newLength)
{    return setByteLength(newLength);}
52736f5facbd33734025fd3937063b835833da2b53572b6d14bf5b3dde4ab08f
setByteLength
public Utf8 setByteLength(int newLength)
{    if (newLength > MAX_LENGTH) {        throw new AvroRuntimeException("String length " + newLength + " exceeds maximum allowed");    }    if (this.bytes.length < newLength) {        byte[] newBytes = new byte[newLength];        System.arraycopy(bytes, 0, newBytes, 0, this.length);        this.bytes = newBytes;    }    this.length = newLength;    this.string = null;    return this;}
bdea92f3e0a77912a958c549e5bbffa762a5d7b4473b897f347728bf1ab0bcb9
set
public Utf8 set(String string)
{    this.bytes = getBytesFor(string);    this.length = bytes.length;    this.string = string;    return this;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    if (this.length == 0)        return "";    if (this.string == null) {        this.string = new String(bytes, 0, length, StandardCharsets.UTF_8);    }    return this.string;}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (o == this)        return true;    if (!(o instanceof Utf8))        return false;    Utf8 that = (Utf8) o;    if (!(this.length == that.length))        return false;    byte[] thatBytes = that.bytes;    for (int i = 0; i < this.length; i++) if (bytes[i] != thatBytes[i])        return false;    return true;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    int hash = 0;    for (int i = 0; i < this.length; i++) hash = hash * 31 + bytes[i];    return hash;}
0741eff13b33ea78cc5b2920a75b4de316a364fef43b890d0175d262dbd2ec0b
compareTo
public int compareTo(Utf8 that)
{    return BinaryData.compareBytes(this.bytes, 0, this.length, that.bytes, 0, that.length);}
6549f0e711c8fc459feaa1b0ff840b1c26966b2985317c7f3261c45237220e68
charAt
public char charAt(int index)
{    return toString().charAt(index);}
1d1ebdb99c526da23d9a06ed6c089d39abc457289b7aff9cbe5f58a377b283b2
length
public int length()
{    return toString().length();}
8646fa067eb0ec1aae8146a9e94c0696dba88247c127afe0f9f0af672b0f68f3
subSequence
public CharSequence subSequence(int start, int end)
{    return toString().subSequence(start, end);}
b8544761df583eecc344d35fe86a81d89e62398d99fae91a346abfbd44d526e0
getBytesFor
public static byte[] getBytesFor(String str)
{    return str.getBytes(StandardCharsets.UTF_8);}
21ac40bb9a99614b6ac18fa4043acb6173fccff96066fdfab963dba597923aa8
clear
public void clear()
{    backingStore.clear();    reap();}
10251f6cf636f49b599299432df558beac5bc221e8b028def33778ce8ebe248a
containsKey
public boolean containsKey(Object key)
{    reap();    return backingStore.containsKey(new IdentityWeakReference(key));}
c628f36c081e450f86a9e82a881e3e7747dea6b3d315f9d7efd8f5266497cb73
containsValue
public boolean containsValue(Object value)
{    reap();    return backingStore.containsValue(value);}
131bb4f4440624fd9db5faf1720923c352ba37d48ee8db62980269dadb55eaae
entrySet
public Set<Map.Entry<K, V>> entrySet()
{    reap();    Set<Map.Entry<K, V>> ret = new HashSet<>();    for (Map.Entry<IdentityWeakReference, V> ref : backingStore.entrySet()) {        final K key = ref.getKey().get();        final V value = ref.getValue();        Map.Entry<K, V> entry = new Map.Entry<K, V>() {            @Override            public K getKey() {                return key;            }            @Override            public V getValue() {                return value;            }            @Override            public V setValue(V value) {                throw new UnsupportedOperationException();            }        };        ret.add(entry);    }    return Collections.unmodifiableSet(ret);}
408af2012690314114a03f0ca626970e41121b2f610127a0eacfc4e43e74dbfe
getKey
public K getKey()
{    return key;}
5a159708665ed864d795a0702d525a75a1e0d877881ccd093ed97ed18e382934
getValue
public V getValue()
{    return value;}
d8401f424036b4f728f70be90e19de421f30843cb3cd58fa6f7257c274ce398d
setValue
public V setValue(V value)
{    throw new UnsupportedOperationException();}
c619c5c247e00c82e132c731db2d7dd646000c405d071795fcbfcba581649b68
keySet
public Set<K> keySet()
{    reap();    Set<K> ret = new HashSet<>();    for (IdentityWeakReference ref : backingStore.keySet()) {        ret.add(ref.get());    }    return Collections.unmodifiableSet(ret);}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (!(o instanceof WeakIdentityHashMap)) {        return false;    }    return backingStore.equals(((WeakIdentityHashMap) o).backingStore);}
bff87e54075ba5d5421bf5ff5db42cbe90d6f2d40bf112005070d80ee9873381
get
public V get(Object key)
{    reap();    return backingStore.get(new IdentityWeakReference(key));}
1872e986b4afc45b25826345adf05e6c986d61445f72dd373c75c28af725bf99
put
public V put(K key, V value)
{    reap();    return backingStore.put(new IdentityWeakReference(key), value);}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    reap();    return backingStore.hashCode();}
803915e853382ad445a6e2333fabb8beb8e4acd70e908a0d818400f7baac42af
isEmpty
public boolean isEmpty()
{    reap();    return backingStore.isEmpty();}
9f36c4452c1755ba2406416222adfc6dac19b1a0fea3499138d2ec7773763295
putAll
public void putAll(Map t)
{    throw new UnsupportedOperationException();}
d3d9cbefed45d3eba7ffb31735e6c0cc3079bba6649ecef7eae69b6429c3717d
remove
public V remove(Object key)
{    reap();    return backingStore.remove(new IdentityWeakReference(key));}
72ef1e59027007ffe0950edfd2670ad03bb65cd6463d5d1d282dfeb1750435b0
size
public int size()
{    reap();    return backingStore.size();}
86f8cd7f78364ea8a0d36935cf2e3d294cee8b3b9e21cfe6a555d22e54e37f60
values
public Collection<V> values()
{    reap();    return backingStore.values();}
9ffce21ab6735dfe6bf6d2620eef506328f616fe8483ff70b6ad15d8deca8cf2
reap
private synchronized void reap()
{    Object zombie = queue.poll();    while (zombie != null) {        IdentityWeakReference victim = (IdentityWeakReference) zombie;        backingStore.remove(victim);        zombie = queue.poll();    }}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return hash;}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (!(o instanceof WeakIdentityHashMap.IdentityWeakReference)) {        return false;    }    IdentityWeakReference ref = (IdentityWeakReference) o;    return this.get() == ref.get();}
e30785c62422d841a71a1ea73f6edf5b6410b24e1f45fb073753edd620427204
validate
public void validate(Schema toValidate, Iterable<Schema> schemasInOrder) throws SchemaValidationException
{    for (Schema existing : schemasInOrder) {        strategy.validate(toValidate, existing);    }}
1c30090d02b995e2a24f8998ab1d6f2882ad6b421eb5f4b8ba92513ba5b7cfaf
validate
public void validate(Schema toValidate, Schema existing) throws SchemaValidationException
{    ValidateMutualRead.canRead(toValidate, existing);}
1c30090d02b995e2a24f8998ab1d6f2882ad6b421eb5f4b8ba92513ba5b7cfaf
validate
public void validate(Schema toValidate, Schema existing) throws SchemaValidationException
{    ValidateMutualRead.canRead(existing, toValidate);}
e30785c62422d841a71a1ea73f6edf5b6410b24e1f45fb073753edd620427204
validate
public void validate(Schema toValidate, Iterable<Schema> schemasInOrder) throws SchemaValidationException
{    Iterator<Schema> schemas = schemasInOrder.iterator();    if (schemas.hasNext()) {        Schema existing = schemas.next();        strategy.validate(toValidate, existing);    }}
1c30090d02b995e2a24f8998ab1d6f2882ad6b421eb5f4b8ba92513ba5b7cfaf
validate
public void validate(Schema toValidate, Schema existing) throws SchemaValidationException
{    canRead(toValidate, existing);    canRead(existing, toValidate);}
d443728628b9f0ea8685bcfa7c191de0d7f152281d1526bf48bd6ae81a044de2
canRead
 static void canRead(Schema writtenWith, Schema readUsing) throws SchemaValidationException
{    boolean error;    try {        error = Symbol.hasErrors(new ResolvingGrammarGenerator().generate(writtenWith, readUsing));    } catch (IOException e) {        throw new SchemaValidationException(readUsing, writtenWith, e);    }    if (error) {        throw new SchemaValidationException(readUsing, writtenWith);    }}
6b3ab298cb5d88dbb2c510c786f53e377489a40e2716e63c26a3e1691765f6c5
equals
public boolean equals(Object that)
{    if (that instanceof BarRecord) {        if (this.beerMsg == null) {            return ((BarRecord) that).beerMsg == null;        } else {            return this.beerMsg.equals(((BarRecord) that).beerMsg);        }    }    return false;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return beerMsg.hashCode();}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return BarRecord.class.getSimpleName() + "{msg=" + beerMsg + "}";}
a768a5ed6cfc9d569264bb2700d314c46732c6e6304f0b753b33ea82105f11a9
getPayload
public ByteBuffer getPayload()
{    return payload;}
eff89bee2cdbc8cdb8b84d1c819c21ea74898fa1567fe770208d46236f2ac93b
setPayload
public void setPayload(ByteBuffer payload)
{    this.payload = payload;}
240b3472c4808fc7db42f4a8cf907a7d23f78b3beb3bf0d76e36bdf64a559c91
getTp
public TypeEnum getTp()
{    return tp;}
af997281e61b18d386dde2cd3aef8b8da7446235eb8f016c10b440c37b348bf5
setTp
public void setTp(TypeEnum tp)
{    this.tp = tp;}
ac5d1b56d563a5343668396be17ef51b25d533ae8b9b46f11f1207836d171cac
equals
public boolean equals(Object ob)
{    if (this == ob)        return true;    if (!(ob instanceof ByteBufferRecord))        return false;    ByteBufferRecord that = (ByteBufferRecord) ob;    if (this.getPayload() == null)        return that.getPayload() == null;    if (!this.getPayload().equals(that.getPayload()))        return false;    if (this.getTp() == null)        return that.getTp() == null;    return this.getTp().equals(that.getTp());}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return this.payload.hashCode();}
4b8f45af0d1f955ed705ca68f3beffeba21aaa9000e02370e7e3981dd7b9b4d8
setUpBeforeClass
public static void setUpBeforeClass()
{    primitives = new HashSet<>(Arrays.asList(Type.values()));    primitives.removeAll(Arrays.asList(Type.RECORD, Type.ENUM, Type.ARRAY, Type.MAP, Type.UNION, Type.FIXED));    nonNullPrimitives = new HashSet<>(primitives);    nonNullPrimitives.remove(Type.NULL);}
878f2a0956e22cd4c0e88271e15a66958159b9642687983286d947f78e76e1fd
testIsValidValueWithPrimitives
public void testIsValidValueWithPrimitives()
{        for (Type type : primitives) {        Field f = new Field("f", Schema.create(type), null, null);        Assert.assertTrue(RecordBuilderBase.isValidValue(f, new Object()));    }        for (Type type : nonNullPrimitives) {        Field f = new Field("f", Schema.create(type), null, null);        Assert.assertFalse(RecordBuilderBase.isValidValue(f, null));    }}
31472348dad901d63b2f66bf4a2fc6c8309eff9fd02047bc084ecac7ffce46c8
testIsValidValueWithNullField
public void testIsValidValueWithNullField()
{        Assert.assertTrue(RecordBuilderBase.isValidValue(new Field("f", Schema.create(Type.NULL), null, null), null));}
3ca9b8d7a2f91fe55b9ec2ae79daddbc94bfe05230df35355f663840d018e4cd
testIsValidValueWithUnion
public void testIsValidValueWithUnion()
{        Schema unionWithoutNull = Schema.createUnion(Arrays.asList(Schema.create(Type.STRING), Schema.create(Type.BOOLEAN)));    Assert.assertTrue(RecordBuilderBase.isValidValue(new Field("f", unionWithoutNull, null, null), new Object()));    Assert.assertFalse(RecordBuilderBase.isValidValue(new Field("f", unionWithoutNull, null, null), null));        Schema unionWithNull = Schema.createUnion(Arrays.asList(Schema.create(Type.STRING), Schema.create(Type.NULL)));    Assert.assertTrue(RecordBuilderBase.isValidValue(new Field("f", unionWithNull, null, null), new Object()));    Assert.assertTrue(RecordBuilderBase.isValidValue(new Field("f", unionWithNull, null, null), null));}
9bd67a87eed70168f832099b3c979f50df99900ebb86244f8dab5e2ae909d4ba
createSchemas
public static void createSchemas()
{    TestTimeConversions.DATE_SCHEMA = LogicalTypes.date().addToSchema(Schema.create(Schema.Type.INT));    TestTimeConversions.TIME_MILLIS_SCHEMA = LogicalTypes.timeMillis().addToSchema(Schema.create(Schema.Type.INT));    TestTimeConversions.TIME_MICROS_SCHEMA = LogicalTypes.timeMicros().addToSchema(Schema.create(Schema.Type.LONG));    TestTimeConversions.TIMESTAMP_MILLIS_SCHEMA = LogicalTypes.timestampMillis().addToSchema(Schema.create(Schema.Type.LONG));    TestTimeConversions.TIMESTAMP_MICROS_SCHEMA = LogicalTypes.timestampMicros().addToSchema(Schema.create(Schema.Type.LONG));}
255329d14824615172d1b812d242e1b762fae6ef5669421f02a8dfeba9133b28
testDateConversion
public void testDateConversion() throws Exception
{    DateConversion conversion = new DateConversion();        LocalDate Jan_6_1970 = LocalDate.of(1970, 1, 6);        LocalDate Jan_1_1970 = LocalDate.of(1970, 1, 1);        LocalDate Dec_27_1969 = LocalDate.of(1969, 12, 27);    Assert.assertEquals("6 Jan 1970 should be 5", 5, (int) conversion.toInt(Jan_6_1970, DATE_SCHEMA, LogicalTypes.date()));    Assert.assertEquals("1 Jan 1970 should be 0", 0, (int) conversion.toInt(Jan_1_1970, DATE_SCHEMA, LogicalTypes.date()));    Assert.assertEquals("27 Dec 1969 should be -5", -5, (int) conversion.toInt(Dec_27_1969, DATE_SCHEMA, LogicalTypes.date()));    Assert.assertEquals("6 Jan 1970 should be 5", conversion.fromInt(5, DATE_SCHEMA, LogicalTypes.date()), Jan_6_1970);    Assert.assertEquals("1 Jan 1970 should be 0", conversion.fromInt(0, DATE_SCHEMA, LogicalTypes.date()), Jan_1_1970);    Assert.assertEquals("27 Dec 1969 should be -5", conversion.fromInt(-5, DATE_SCHEMA, LogicalTypes.date()), Dec_27_1969);}
99e9a031bfb949a8a31e902d566037419a12162fcc753ad5380a4b446d1a29e1
testTimeMillisConversion
public void testTimeMillisConversion()
{    TimeMillisConversion conversion = new TimeMillisConversion();    LocalTime oneAM = LocalTime.of(1, 0);    LocalTime afternoon = LocalTime.of(15, 14, 15, 926_000_000);    int afternoonMillis = ((15 * 60 + 14) * 60 + 15) * 1000 + 926;    Assert.assertEquals("Midnight should be 0", 0, (int) conversion.toInt(LocalTime.MIDNIGHT, TIME_MILLIS_SCHEMA, LogicalTypes.timeMillis()));    Assert.assertEquals("01:00 should be 3,600,000", 3_600_000, (int) conversion.toInt(oneAM, TIME_MILLIS_SCHEMA, LogicalTypes.timeMillis()));    Assert.assertEquals("15:14:15.926 should be " + afternoonMillis, afternoonMillis, (int) conversion.toInt(afternoon, TIME_MILLIS_SCHEMA, LogicalTypes.timeMillis()));    Assert.assertEquals("Midnight should be 0", LocalTime.MIDNIGHT, conversion.fromInt(0, TIME_MILLIS_SCHEMA, LogicalTypes.timeMillis()));    Assert.assertEquals("01:00 should be 3,600,000", oneAM, conversion.fromInt(3600000, TIME_MILLIS_SCHEMA, LogicalTypes.timeMillis()));    Assert.assertEquals("15:14:15.926 should be " + afternoonMillis, afternoon, conversion.fromInt(afternoonMillis, TIME_MILLIS_SCHEMA, LogicalTypes.timeMillis()));}
1ecdefff15c7b272b4da1987beb068cb6246b5f02befe0ed610d58f640ce6ea6
testTimeMicrosConversion
public void testTimeMicrosConversion() throws Exception
{    TimeMicrosConversion conversion = new TimeMicrosConversion();    LocalTime oneAM = LocalTime.of(1, 0);    LocalTime afternoon = LocalTime.of(15, 14, 15, 926_551_000);    long afternoonMicros = ((long) (15 * 60 + 14) * 60 + 15) * 1_000_000 + 926_551;    Assert.assertEquals("Midnight should be 0", LocalTime.MIDNIGHT, conversion.fromLong(0L, TIME_MICROS_SCHEMA, LogicalTypes.timeMicros()));    Assert.assertEquals("01:00 should be 3,600,000,000", oneAM, conversion.fromLong(3_600_000_000L, TIME_MICROS_SCHEMA, LogicalTypes.timeMicros()));    Assert.assertEquals("15:14:15.926551 should be " + afternoonMicros, afternoon, conversion.fromLong(afternoonMicros, TIME_MICROS_SCHEMA, LogicalTypes.timeMicros()));    Assert.assertEquals("Midnight should be 0", 0, (long) conversion.toLong(LocalTime.MIDNIGHT, TIME_MICROS_SCHEMA, LogicalTypes.timeMicros()));    Assert.assertEquals("01:00 should be 3,600,000,000", 3_600_000_000L, (long) conversion.toLong(oneAM, TIME_MICROS_SCHEMA, LogicalTypes.timeMicros()));    Assert.assertEquals("15:14:15.926551 should be " + afternoonMicros, afternoonMicros, (long) conversion.toLong(afternoon, TIME_MICROS_SCHEMA, LogicalTypes.timeMicros()));}
be9c511344ef35e006bcdc18269d7d40d60db24d939caec0eced7c5e30f239fa
testTimestampMillisConversion
public void testTimestampMillisConversion() throws Exception
{    TimestampMillisConversion conversion = new TimestampMillisConversion();        long nowInstant = Instant.now().toEpochMilli();        Instant now = conversion.fromLong(nowInstant, TIMESTAMP_MILLIS_SCHEMA, LogicalTypes.timestampMillis());    long roundTrip = conversion.toLong(now, TIMESTAMP_MILLIS_SCHEMA, LogicalTypes.timestampMillis());    Assert.assertEquals("Round-trip conversion should work", nowInstant, roundTrip);    long May_28_2015_21_46_53_221_instant = 1432849613221L;    Instant May_28_2015_21_46_53_221 = ZonedDateTime.of(2015, 5, 28, 21, 46, 53, 221_000_000, ZoneOffset.UTC).toInstant();            Assert.assertEquals("Known date should be correct", May_28_2015_21_46_53_221, conversion.fromLong(May_28_2015_21_46_53_221_instant, TIMESTAMP_MILLIS_SCHEMA, LogicalTypes.timestampMillis()));    Assert.assertEquals("Known date should be correct", May_28_2015_21_46_53_221_instant, (long) conversion.toLong(May_28_2015_21_46_53_221, TIMESTAMP_MILLIS_SCHEMA, LogicalTypes.timestampMillis()));        Assert.assertEquals("1970-01-01 should be 0", Instant.EPOCH, conversion.fromLong(0L, TIMESTAMP_MILLIS_SCHEMA, LogicalTypes.timestampMillis()));    Assert.assertEquals("1970-01-01 should be 0", 0L, (long) conversion.toLong(ZonedDateTime.ofInstant(Instant.EPOCH, ZoneOffset.UTC).toInstant(), TIMESTAMP_MILLIS_SCHEMA, LogicalTypes.timestampMillis()));        long Jul_01_1969_12_00_00_123_instant = -15854400000L + 123;    Instant Jul_01_1969_12_00_00_123 = ZonedDateTime.of(1969, 7, 1, 12, 0, 0, 123_000_000, ZoneOffset.UTC).toInstant();    Assert.assertEquals("Pre 1970 date should be correct", Jul_01_1969_12_00_00_123, conversion.fromLong(Jul_01_1969_12_00_00_123_instant, TIMESTAMP_MILLIS_SCHEMA, LogicalTypes.timestampMillis()));    Assert.assertEquals("Pre 1970 date should be correct", Jul_01_1969_12_00_00_123_instant, (long) conversion.toLong(Jul_01_1969_12_00_00_123, TIMESTAMP_MILLIS_SCHEMA, LogicalTypes.timestampMillis()));}
a2fc0d9ec264207c911d8488a7b0ab53164d51f4c54dc9dae92d7ed623fecac7
testTimestampMicrosConversion
public void testTimestampMicrosConversion() throws Exception
{    TimestampMicrosConversion conversion = new TimestampMicrosConversion();            long May_28_2015_21_46_53_221_843_instant = 1432849613221L * 1000 + 843;    Instant May_28_2015_21_46_53_221_843 = ZonedDateTime.of(2015, 5, 28, 21, 46, 53, 221_843_000, ZoneOffset.UTC).toInstant();    Assert.assertEquals("Known date should be correct", May_28_2015_21_46_53_221_843, conversion.fromLong(May_28_2015_21_46_53_221_843_instant, TIMESTAMP_MICROS_SCHEMA, LogicalTypes.timestampMicros()));    Assert.assertEquals("Known date should be correct", May_28_2015_21_46_53_221_843_instant, (long) conversion.toLong(May_28_2015_21_46_53_221_843, TIMESTAMP_MICROS_SCHEMA, LogicalTypes.timestampMillis()));        Assert.assertEquals("1970-01-01 should be 0", Instant.EPOCH, conversion.fromLong(0L, TIMESTAMP_MILLIS_SCHEMA, LogicalTypes.timestampMillis()));    Assert.assertEquals("1970-01-01 should be 0", 0L, (long) conversion.toLong(ZonedDateTime.ofInstant(Instant.EPOCH, ZoneOffset.UTC).toInstant(), TIMESTAMP_MILLIS_SCHEMA, LogicalTypes.timestampMillis()));        long Jul_01_1969_12_00_00_000_123_instant = -15854400000L * 1000 + 123;    Instant Jul_01_1969_12_00_00_000_123 = ZonedDateTime.of(1969, 7, 1, 12, 0, 0, 123_000, ZoneOffset.UTC).toInstant();    Assert.assertEquals("Pre 1970 date should be correct", Jul_01_1969_12_00_00_000_123, conversion.fromLong(Jul_01_1969_12_00_00_000_123_instant, TIMESTAMP_MILLIS_SCHEMA, LogicalTypes.timestampMillis()));    Assert.assertEquals("Pre 1970 date should be correct", Jul_01_1969_12_00_00_000_123_instant, (long) conversion.toLong(Jul_01_1969_12_00_00_000_123, TIMESTAMP_MILLIS_SCHEMA, LogicalTypes.timestampMillis()));}
51ea5abe60a29b25fec085717742a15b0a70ba4449c9dbf0fde8d491e04c2898
testDynamicSchemaWithDateConversion
public void testDynamicSchemaWithDateConversion() throws ClassNotFoundException
{    Schema schema = getReflectedSchemaByName("java.time.LocalDate", new TimeConversions.DateConversion());    Assert.assertEquals("Reflected schema should be logicalType date", DATE_SCHEMA, schema);}
9dbdade4bd8dc3326a6b9919d89cfa23da6804c7c87458ae3fe34e83fa81ca8b
testDynamicSchemaWithTimeConversion
public void testDynamicSchemaWithTimeConversion() throws ClassNotFoundException
{    Schema schema = getReflectedSchemaByName("java.time.LocalTime", new TimeConversions.TimeMillisConversion());    Assert.assertEquals("Reflected schema should be logicalType timeMillis", TIME_MILLIS_SCHEMA, schema);}
4f2612d5b205221211fe26d49eabc7478f346950b69f95c6a164f998008402b7
testDynamicSchemaWithTimeMicrosConversion
public void testDynamicSchemaWithTimeMicrosConversion() throws ClassNotFoundException
{    Schema schema = getReflectedSchemaByName("java.time.LocalTime", new TimeConversions.TimeMicrosConversion());    Assert.assertEquals("Reflected schema should be logicalType timeMicros", TIME_MICROS_SCHEMA, schema);}
f4f3d8a8a313ab5627835341529679aba3137ed54175a1707d99f5886abcc53b
testDynamicSchemaWithDateTimeConversion
public void testDynamicSchemaWithDateTimeConversion() throws ClassNotFoundException
{    Schema schema = getReflectedSchemaByName("java.time.Instant", new TimeConversions.TimestampMillisConversion());    Assert.assertEquals("Reflected schema should be logicalType timestampMillis", TIMESTAMP_MILLIS_SCHEMA, schema);}
125091aa5c5efa0c1f40c447112e582ecf791e8349bd2bdd155525fc3fc6d5e6
testDynamicSchemaWithDateTimeMicrosConversion
public void testDynamicSchemaWithDateTimeMicrosConversion() throws ClassNotFoundException
{    Schema schema = getReflectedSchemaByName("java.time.Instant", new TimeConversions.TimestampMicrosConversion());    Assert.assertEquals("Reflected schema should be logicalType timestampMicros", TIMESTAMP_MICROS_SCHEMA, schema);}
ec3c7532b17505db41141225db05fffaa4720e34850d377be154f485c84d6993
getReflectedSchemaByName
private Schema getReflectedSchemaByName(String className, Conversion<?> conversion) throws ClassNotFoundException
{        Class<?> cls = Class.forName(className);        ReflectData model = new ReflectData();    model.addLogicalTypeConversion(conversion);    return model.getSchema(cls);}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return CODECNAME;}
c8499e54f06b8a6c1a49ad640265ef3c41c4c9fd8ba3d35f0ca08560ae47cd45
compress
public ByteBuffer compress(ByteBuffer in) throws IOException
{    ByteBuffer out = ByteBuffer.allocate(in.remaining());    while (in.position() < in.capacity()) out.put((byte) ~in.get());    return out;}
b842dd74745fcf59fd140f434ef6db57885e171d9375fbe02a564bcb94d31bdf
decompress
public ByteBuffer decompress(ByteBuffer in) throws IOException
{    ByteBuffer out = ByteBuffer.allocate(in.remaining());    while (in.position() < in.capacity()) out.put((byte) ~in.get());    return out;}
74e378df448c6c3cd090d6daf881cfac8957dd555869ea4c13a46bdc6cdcf9a6
equals
public boolean equals(Object other)
{    if (this == other)        return true;    if (other instanceof Codec) {        ByteBuffer original = ByteBuffer.allocate(getName().getBytes(UTF_8).length);        original.put(getName().getBytes(UTF_8));        original.rewind();        try {            return compareDecompress((Codec) other, original);        } catch (IOException e) {            return false;        }    } else        return false;}
9a2cbcab230ae7548ab9532afbc20fdadafbebcc5f5da1b403127ab54c700d7b
compareDecompress
private boolean compareDecompress(Codec other, ByteBuffer original) throws IOException
{    ByteBuffer compressedA = this.compress(original);    original.rewind();    ByteBuffer compressedB = other.compress(original);    return this.decompress(compressedA).equals(other.decompress((ByteBuffer) compressedA.rewind())) && this.decompress(compressedB).equals(other.decompress((ByteBuffer) compressedB.rewind()));}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return getName().hashCode();}
e159cd20e5d846e508be922f0450be0db638ed2ba32c3229ae07c0ea68938d77
data
public static Collection<Object[]> data()
{    return Arrays.asList(new Object[][] { { "bzip2", BZip2Codec.class }, { "zstandard", ZstandardCodec.class }, { "null", NullCodec.class }, { "xz", XZCodec.class }, { "snappy", SnappyCodec.class }, { "deflate", DeflateCodec.class } });}
74004d1248596cf610bf69e1bdad7d4bd1e01f0ebae1197efc526fd4c21bd6f1
testCodec
public void testCodec() throws IOException
{    int inputSize = 500_000;    byte[] input = generateTestData(inputSize);    Codec codecInstance = CodecFactory.fromString(codec).createInstance();    assertTrue(codecClass.isInstance(codecInstance));    assertTrue(codecInstance.getName().equals(codec));    ByteBuffer inputByteBuffer = ByteBuffer.wrap(input);    ByteBuffer compressedBuffer = codecInstance.compress(inputByteBuffer);    int compressedSize = compressedBuffer.remaining();        assertTrue(compressedSize > 0);                    assertTrue(compressedSize < inputSize || codec.equals("null"));        ByteBuffer decompressedBuffer = codecInstance.decompress(compressedBuffer);        inputByteBuffer.rewind();    Assert.assertEquals(decompressedBuffer, inputByteBuffer);}
178730ac257f852048351ca5bb0db251ae808b8017f03ab661c24b5889ae297a
testCodecSlice
public void testCodecSlice() throws IOException
{    int inputSize = 500_000;    byte[] input = generateTestData(inputSize);    Codec codecInstance = CodecFactory.fromString(codec).createInstance();    ByteBuffer partialBuffer = ByteBuffer.wrap(input);    partialBuffer.position(17);    ByteBuffer inputByteBuffer = partialBuffer.slice();    ByteBuffer compressedBuffer = codecInstance.compress(inputByteBuffer);    int compressedSize = compressedBuffer.remaining();        assertTrue(compressedSize > 0);        ByteBuffer sliceBuffer = ByteBuffer.allocate(compressedSize + 100);    sliceBuffer.position(50);    sliceBuffer.put(compressedBuffer);    sliceBuffer.limit(compressedSize + 50);    sliceBuffer.position(50);        ByteBuffer decompressedBuffer = codecInstance.decompress(sliceBuffer.slice());        inputByteBuffer.rewind();    Assert.assertEquals(decompressedBuffer, inputByteBuffer);}
5a5b7943a95db297e8c649ee607131c66590b61f336c018e50bff5d5ace6a88e
generateTestData
public static byte[] generateTestData(int inputSize)
{    byte[] arr = new byte[inputSize];    for (int i = 0; i < arr.length; i++) {        arr[i] = (byte) (65 + i % 10);    }    return arr;}
b222567e8bfd4bff64496eb76de8e8aef113f143ea005206b2c6d0bcf7ca15b9
testCustomCodec
public void testCustomCodec()
{    CustomCodec customCodec = new CustomCodec();    Codec snappyCodec = new SnappyCodec.Option().createInstance();    assertTrue(customCodec.equals(new CustomCodec()));    assertFalse(customCodec.equals(snappyCodec));    String testString = "Testing 123";    ByteBuffer original = ByteBuffer.allocate(testString.getBytes(UTF_8).length);    original.put(testString.getBytes(UTF_8));    original.rewind();    ByteBuffer decompressed = null;    try {        ByteBuffer compressed = customCodec.compress(original);        compressed.rewind();        decompressed = customCodec.decompress(compressed);    } catch (IOException e) {        e.printStackTrace();    }    assertEquals(testString, new String(decompressed.array(), UTF_8));}
28b71ced43af8c83f8eb799b762b9363eea3393c08bf12a29b90de2304757b0c
write
public void write(int b) throws IOException
{    if (byteCnt > 0) {        --byteCnt;    } else if (byteCnt == 0) {        --byteCnt;        throw new IOException("Artificial failure from FailingOutputStream");    } else {        fail("No bytes should have been written after IOException");    }}
bc4fdc25bf54e964b6a8639f59bfabdf22e487546807438ee0f0bab414742403
testNoWritingAfterException
public void testNoWritingAfterException() throws IOException
{    try (DataFileWriter<Object> writer = new DataFileWriter<>(new GenericDatumWriter<>())) {        writer.create(SCHEMA, new FailingOutputStream(100000));        int recordCnt = 0;        for (Object datum : new RandomData(SCHEMA, 100000, 42)) {            writer.append(datum);            if (++recordCnt % 17 == 0) {                writer.flush();            }        }    } catch (IOException e) {        return;    }    fail("IOException should have been thrown");}
456a264b5ca7e593ada90f405856673d744773871076532574a5e41f23e8f428
getSerializedMessage
private byte[] getSerializedMessage(IndexedRecord message, Schema schema) throws Exception
{    ByteArrayOutputStream baos = new ByteArrayOutputStream(4096);    SpecificDatumWriter<IndexedRecord> writer = new SpecificDatumWriter<>();    try (DataFileWriter<IndexedRecord> dfw = new DataFileWriter<>(writer).create(schema, baos)) {        dfw.append(message);    }    return baos.toByteArray();}
012cd80873989d4eebdb1a554f1c2432c8794ff9152ca6314074f6463e99ca03
getTestSchema
private Schema getTestSchema() throws Exception
{    Schema schema = Schema.createRecord("TestRecord", "this is a test record", "org.apache.avro.file", false);    List<Field> fields = new ArrayList<>();    fields.add(new Field("name", Schema.create(Type.STRING), "this is a test field"));    schema.setFields(fields);    return schema;}
201ceaeec1d6c505857a11e3f4b3b5be8dba93fda85e1105434de73759a3825a
testSerialization
public void testSerialization() throws Exception
{    Schema testSchema = getTestSchema();    GenericRecord message = new Record(testSchema);    message.put("name", "testValue");    byte[] data = getSerializedMessage(message, testSchema);    GenericDatumReader<IndexedRecord> reader = new GenericDatumReader<>(testSchema);    final IndexedRecord result;    try (SeekableInput in = new SeekableByteArrayInput(data);        FileReader<IndexedRecord> dfr = DataFileReader.openReader(in, reader)) {        result = dfr.next();    }    Assert.assertNotNull(result);    Assert.assertTrue(result instanceof GenericRecord);    Assert.assertEquals(new Utf8("testValue"), ((GenericRecord) result).get("name"));}
024979f70f562946b4c461d54e6c781c095f813a80fc8426e55f19c72b1a9a38
testZstandardToStringAndName
public void testZstandardToStringAndName() throws IOException
{    Codec codec = CodecFactory.zstandardCodec(3).createInstance();    assertTrue(codec instanceof ZstandardCodec);    assertTrue(codec.getName().equals("zstandard"));    assertTrue(codec.toString().equals("zstandard[3]"));}
64706bfcdc25a6308d11d702baacbf9dbac8176e7848be0e819da8d1859b6bdb
getClassSchema
public static org.apache.avro.Schema getClassSchema()
{    return SCHEMA$;}
f788bccd7dce0fa91d689fdbc962f699666800b099200588675ab235a5c48ca7
getDecoder
public static BinaryMessageDecoder<FooBarSpecificRecord> getDecoder()
{    return DECODER;}
4041fad605086660d19c787769c2ecfecb6300e02d39a6349de376d090e96624
createDecoder
public static BinaryMessageDecoder<FooBarSpecificRecord> createDecoder(SchemaStore resolver)
{    return new BinaryMessageDecoder<>(MODEL$, SCHEMA$, resolver);}
473bffa2e264c9a7f493a4236175e1428e5d97836bf372b01eb5b1692afcd748
toByteBuffer
public java.nio.ByteBuffer toByteBuffer() throws java.io.IOException
{    return ENCODER.encode(this);}
f20e760938efc64e972129102b3f15cf2b5564a6f03ae3881fb4d933114e3729
fromByteBuffer
public static FooBarSpecificRecord fromByteBuffer(java.nio.ByteBuffer b) throws java.io.IOException
{    return DECODER.decode(b);}
1fa124aa67dc73ccd01002de70d29d68ea9dacd5d97cf4663025da360e9c4749
getSchema
public org.apache.avro.Schema getSchema()
{    return SCHEMA$;}
233b384682c68bdb89ad70c35a2e59b7341b16a68e84517dc4f51d4ce5753ebf
get
public java.lang.Object get(int field$)
{    switch(field$) {        case 0:            return id;        case 1:            return name;        case 2:            return nicknames;        case 3:            return relatedids;        case 4:            return typeEnum;        default:            throw new org.apache.avro.AvroRuntimeException("Bad index");    }}
f13ccb2ddd4dfda02b51ba2bf6b82a34d33026ae9bcb3de86f779f47722fb1ac
put
public void put(int field$, java.lang.Object value$)
{    switch(field$) {        case 0:            id = (java.lang.Integer) value$;            break;        case 1:            name = (java.lang.String) value$;            break;        case 2:            nicknames = (java.util.List<java.lang.String>) value$;            break;        case 3:            relatedids = (java.util.List<java.lang.Integer>) value$;            break;        case 4:            typeEnum = (org.apache.avro.TypeEnum) value$;            break;        default:            throw new org.apache.avro.AvroRuntimeException("Bad index");    }}
22d2b2fbabe580fc33e67ad27a512e82d458e4c351aa3b6aae186fc7c02d3004
getId
public java.lang.Integer getId()
{    return id;}
1c7d44a0f60134ce66fc1f0b537a0a95adbbeeb99f3e7a1a2f8edbfffe05abdd
setId
public void setId(java.lang.Integer value)
{    this.id = value;}
4387bc4b14c9017c85e5fb19bfa870ef546f911a1da8768a4ebd9b4f153b1564
getName
public java.lang.String getName()
{    return name;}
ae1fe108b8ac4d0a9f1c14df03169ad5d73c799fc1781a30a19d0b9605302864
setName
public void setName(java.lang.String value)
{    this.name = value;}
b97cf58965fa8836d782f6c5592e64ddcb8fcd752d24c67bc3a401ac00837686
getNicknames
public java.util.List<java.lang.String> getNicknames()
{    return nicknames;}
0d8112bff3d11db3e97b9f67fa42643f161d38f0f56785722858f7f418c4712b
setNicknames
public void setNicknames(java.util.List<java.lang.String> value)
{    this.nicknames = value;}
15459a1c3d09c667de864d374b91e7b7c8fd37ac01f315f8822c97ca5376c147
getRelatedids
public java.util.List<java.lang.Integer> getRelatedids()
{    return relatedids;}
6e8c8a74e62a2d2799a5e7b91c6ea4c7200ec4793ff0df3ecc54fcc893bb0ed6
setRelatedids
public void setRelatedids(java.util.List<java.lang.Integer> value)
{    this.relatedids = value;}
47e7d5882d68af1bc891f137498af0756d4ac5d4c16ba02635820746d079ef1b
getTypeEnum
public org.apache.avro.TypeEnum getTypeEnum()
{    return typeEnum;}
cd7a1be776da5b8f94eea3ec5a3684a0ac330a1118253d238bfc35574513fdfd
setTypeEnum
public void setTypeEnum(org.apache.avro.TypeEnum value)
{    this.typeEnum = value;}
51cfc2083c8dadbd409370afc2298702383a55676e14a76854707b853c73b2a6
newBuilder
public static org.apache.avro.FooBarSpecificRecord.Builder newBuilder()
{    return new org.apache.avro.FooBarSpecificRecord.Builder();}
5eed2818b218a9647cb333d0b1f0cd5e2797f71c3f874358bc1662e8837ab59a
newBuilder
public static org.apache.avro.FooBarSpecificRecord.Builder newBuilder(org.apache.avro.FooBarSpecificRecord.Builder other)
{    if (other == null) {        return new org.apache.avro.FooBarSpecificRecord.Builder();    } else {        return new org.apache.avro.FooBarSpecificRecord.Builder(other);    }}
54388584d3620ccf727779b544e5ce3a602dfed6f774f23a57d64c6d59779cd7
newBuilder
public static org.apache.avro.FooBarSpecificRecord.Builder newBuilder(org.apache.avro.FooBarSpecificRecord other)
{    if (other == null) {        return new org.apache.avro.FooBarSpecificRecord.Builder();    } else {        return new org.apache.avro.FooBarSpecificRecord.Builder(other);    }}
22d2b2fbabe580fc33e67ad27a512e82d458e4c351aa3b6aae186fc7c02d3004
getId
public java.lang.Integer getId()
{    return id;}
4919ec5bd1d36758eb90a35fe88365f03070a458f1a8592a78cdeb5e410469ce
setId
public org.apache.avro.FooBarSpecificRecord.Builder setId(int value)
{    validate(fields()[0], value);    this.id = value;    fieldSetFlags()[0] = true;    return this;}
e0e69252a7f2d4544cfdf323d4bdd27e125e0ef348ca473e692c0ddd75004f23
hasId
public boolean hasId()
{    return fieldSetFlags()[0];}
4c6b6d67817f408ecdda99244a8b41fab0b7021fef822f7d16c95abcb948ed8e
clearId
public org.apache.avro.FooBarSpecificRecord.Builder clearId()
{    fieldSetFlags()[0] = false;    return this;}
4387bc4b14c9017c85e5fb19bfa870ef546f911a1da8768a4ebd9b4f153b1564
getName
public java.lang.String getName()
{    return name;}
bb1558890b4a39e51817ef01b7ff5c3f53abcbddc8bf17085e71a20548b62b60
setName
public org.apache.avro.FooBarSpecificRecord.Builder setName(java.lang.String value)
{    validate(fields()[1], value);    this.name = value;    fieldSetFlags()[1] = true;    return this;}
31d714910ec70d05605e9d54b49a52751e0e035d37c60650f64c335fc85e8a2e
hasName
public boolean hasName()
{    return fieldSetFlags()[1];}
19a1286ce26cff76cf213bce4c81dd04ace88009b00b22a0bcd9cf0eb4722def
clearName
public org.apache.avro.FooBarSpecificRecord.Builder clearName()
{    name = null;    fieldSetFlags()[1] = false;    return this;}
b97cf58965fa8836d782f6c5592e64ddcb8fcd752d24c67bc3a401ac00837686
getNicknames
public java.util.List<java.lang.String> getNicknames()
{    return nicknames;}
412c194a053b117564faf9309e7a4e3f38700582359b0facd331a3142ecd532a
setNicknames
public org.apache.avro.FooBarSpecificRecord.Builder setNicknames(java.util.List<java.lang.String> value)
{    validate(fields()[2], value);    this.nicknames = value;    fieldSetFlags()[2] = true;    return this;}
61ec0f832e521aef041127d37c9cb8032711044221d0db67527f331248df88fd
hasNicknames
public boolean hasNicknames()
{    return fieldSetFlags()[2];}
5a74ce7a79d7c4bd6657101d74a6de2bf897a89868db46d44adff4a2307c40b5
clearNicknames
public org.apache.avro.FooBarSpecificRecord.Builder clearNicknames()
{    nicknames = null;    fieldSetFlags()[2] = false;    return this;}
15459a1c3d09c667de864d374b91e7b7c8fd37ac01f315f8822c97ca5376c147
getRelatedids
public java.util.List<java.lang.Integer> getRelatedids()
{    return relatedids;}
576a6b765378091fe8aa55f60a3aaff4a9834600db0f89049f0f9f6c1ae56c25
setRelatedids
public org.apache.avro.FooBarSpecificRecord.Builder setRelatedids(java.util.List<java.lang.Integer> value)
{    validate(fields()[3], value);    this.relatedids = value;    fieldSetFlags()[3] = true;    return this;}
3ba6979eabd8307e652800fb8c454a6bd230167b11b72ac73bd2c61b22568e3b
hasRelatedids
public boolean hasRelatedids()
{    return fieldSetFlags()[3];}
7ec2a43c1fe73a36250c7d3d12479edad3cf21bac771a6b2ab43792c21c6a1af
clearRelatedids
public org.apache.avro.FooBarSpecificRecord.Builder clearRelatedids()
{    relatedids = null;    fieldSetFlags()[3] = false;    return this;}
47e7d5882d68af1bc891f137498af0756d4ac5d4c16ba02635820746d079ef1b
getTypeEnum
public org.apache.avro.TypeEnum getTypeEnum()
{    return typeEnum;}
ddbf66ea2832ad7516ea35653d3acaadab9643a0a372f0ca5bbcb275874507c3
setTypeEnum
public org.apache.avro.FooBarSpecificRecord.Builder setTypeEnum(org.apache.avro.TypeEnum value)
{    validate(fields()[4], value);    this.typeEnum = value;    fieldSetFlags()[4] = true;    return this;}
b1f7eb95fb5d4a01a9fd92883b1f2c642ec0fe978b4c948886fb2603344fdc01
hasTypeEnum
public boolean hasTypeEnum()
{    return fieldSetFlags()[4];}
1892b33fa3ae62fa3277ff050fc19aebb20a041d4d323d703fce29c36867f14d
clearTypeEnum
public org.apache.avro.FooBarSpecificRecord.Builder clearTypeEnum()
{    typeEnum = null;    fieldSetFlags()[4] = false;    return this;}
76d185c47bc4fa282ed75967c0d549006cf74318be1162f42b3b9ab57e9804af
build
public FooBarSpecificRecord build()
{    try {        FooBarSpecificRecord record = new FooBarSpecificRecord();        record.id = fieldSetFlags()[0] ? this.id : (java.lang.Integer) defaultValue(fields()[0]);        record.name = fieldSetFlags()[1] ? this.name : (java.lang.String) defaultValue(fields()[1]);        record.nicknames = fieldSetFlags()[2] ? this.nicknames : (java.util.List<java.lang.String>) defaultValue(fields()[2]);        record.relatedids = fieldSetFlags()[3] ? this.relatedids : (java.util.List<java.lang.Integer>) defaultValue(fields()[3]);        record.typeEnum = fieldSetFlags()[4] ? this.typeEnum : (org.apache.avro.TypeEnum) defaultValue(fields()[4]);        return record;    } catch (org.apache.avro.AvroMissingFieldException e) {        throw e;    } catch (java.lang.Exception e) {        throw new org.apache.avro.AvroRuntimeException(e);    }}
6d36b57419a3667bad09c1fd5c626a8bbcaa3071bb613cccc8d36de3695f7d49
writeExternal
public void writeExternal(java.io.ObjectOutput out) throws java.io.IOException
{    WRITER$.write(this, SpecificData.getEncoder(out));}
d60b919d286c4bc0127bcfa26c40b7baeb61384a75f05a3630240b5b84af9aa8
readExternal
public void readExternal(java.io.ObjectInput in) throws java.io.IOException
{    READER$.read(this, SpecificData.getDecoder(in));}
6b3ab298cb5d88dbb2c510c786f53e377489a40e2716e63c26a3e1691765f6c5
equals
public boolean equals(Object that)
{    if (that instanceof FooRecord) {        return this.fooCount == ((FooRecord) that).fooCount;    }    return false;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return fooCount;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return FooRecord.class.getSimpleName() + "{count=" + fooCount + "}";}
692e618fea13fafd63750029f3ac2e4573ae6047c04eeaa966e7468a9afaacdc
writeBlock
private static void writeBlock(Encoder vout, FileOutputStream out) throws IOException
{    vout.writeLong(blockCount);    bufOut.flush();    buffer.writeTo(out);    buffer.reset();    blockCount = 0;}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    if (args.length != 3) {        System.out.println("Usage: GenerateBlockingData <schemafile> <outputfile> <count>");        System.exit(-1);    }    Schema sch = new Schema.Parser().parse(new File(args[0]));    File outputFile = new File(args[1]);    int numObjects = Integer.parseInt(args[2]);    FileOutputStream out = new FileOutputStream(outputFile, false);    DatumWriter<Object> dout = new GenericDatumWriter<>();    dout.setSchema(sch);    Encoder vout = factory.directBinaryEncoder(out, null);        vout.writeLong(numObjects);    for (Object datum : new RandomData(sch, numObjects)) {        dout.write(datum, bufOut);        blockCount++;        if (buffer.size() >= SYNC_INTERVAL) {            writeBlock(vout, out);        }    }    if (blockCount > 0) {        writeBlock(vout, out);    }    out.flush();    out.close();}
1738acafab3a098388ef29247242c15cbf79bd401700adbe5fe8c90a6f2bb135
serializeRecord
private static byte[] serializeRecord(FooBarSpecificRecord fooBarSpecificRecord) throws IOException
{    GenericDatumWriter<FooBarSpecificRecord> datumWriter = new GenericDatumWriter<>(FooBarSpecificRecord.SCHEMA$);    ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();    Encoder encoder = EncoderFactory.get().binaryEncoder(byteArrayOutputStream, null);    datumWriter.write(fooBarSpecificRecord, encoder);    encoder.flush();    return byteArrayOutputStream.toByteArray();}
ff7170322b571c68b324bc39d5a3fe7739dcf521f4d45d1d37b91912094b836a
testGenericWriteAndRead
public void testGenericWriteAndRead() throws IOException
{    FooBarSpecificRecord specificRecord = getRecord();    byte[] bytes = serializeRecord(specificRecord);    Decoder decoder = DecoderFactory.get().binaryDecoder(bytes, null);    GenericDatumReader<IndexedRecord> genericDatumReader = new GenericDatumReader<>(FooBarSpecificRecord.SCHEMA$);    IndexedRecord deserialized = new GenericData.Record(FooBarSpecificRecord.SCHEMA$);    genericDatumReader.read(deserialized, decoder);    assertEquals(0, GenericData.get().compare(specificRecord, deserialized, FooBarSpecificRecord.SCHEMA$));}
fe6ee2276d7061277f14ac49098a7276c93f5eb919ad3719dc248e0fc6d57394
testGenericWriteSpecificRead
public void testGenericWriteSpecificRead() throws IOException
{    FooBarSpecificRecord specificRecord = getRecord();    byte[] bytes = serializeRecord(specificRecord);    Decoder decoder = DecoderFactory.get().binaryDecoder(bytes, null);    SpecificDatumReader<FooBarSpecificRecord> specificDatumReader = new SpecificDatumReader<>(FooBarSpecificRecord.SCHEMA$);    FooBarSpecificRecord deserialized = new FooBarSpecificRecord();    specificDatumReader.read(deserialized, decoder);    assertEquals(specificRecord, deserialized);}
ea7c4674fdf2299e6e0312bd2b8de2b931e26d745bd4107d019eca7af7b6319b
getRecord
private FooBarSpecificRecord getRecord()
{    return FooBarSpecificRecord.newBuilder().setId(42).setName("foo").setNicknames(Collections.singletonList("bar")).setRelatedids(Collections.singletonList(3)).setTypeEnum(TypeEnum.a).build();}
4e8b6fab155ad9e79f73f3ab8802ce3f250d916dade9e6267088e24527524952
testrecordConstructorNullSchema
public void testrecordConstructorNullSchema() throws Exception
{    new GenericData.Record(null);}
e48e67736db7aef9d4fdd647eb9f3b5c0ce617cf3dae9d9ebaeba82c3cbfff69
testrecordConstructorWrongSchema
public void testrecordConstructorWrongSchema() throws Exception
{    new GenericData.Record(Schema.create(Schema.Type.INT));}
bf939fe16bb2a6451bde74e3cdf6b4ecc26036c1e7044d2c85df0744beb9481c
testArrayConstructorNullSchema
public void testArrayConstructorNullSchema() throws Exception
{    new GenericData.Array<>(1, null);}
f7f8a808fa977e475e460ba5240026538f3a1f7bd5a700bfb1ea6120f09cd2e0
testArrayConstructorWrongSchema
public void testArrayConstructorWrongSchema() throws Exception
{    new GenericData.Array<>(1, Schema.create(Schema.Type.INT));}
e629cbb2b0ec77e7f9910973b8d528935ba971212dd463536f42fe496ca9aa8f
testRecordCreateEmptySchema
public void testRecordCreateEmptySchema() throws Exception
{    Schema s = Schema.createRecord("schemaName", "schemaDoc", "namespace", false);    Record r = new GenericData.Record(s);}
938b945ded620e9134989f3abf7f4533c2b140038395ca6bbd54ed5437446792
testGetEmptySchemaFields
public void testGetEmptySchemaFields() throws Exception
{    Schema s = Schema.createRecord("schemaName", "schemaDoc", "namespace", false);    s.getFields();}
16e2b1e20a1c597098edef72e425850c34907afc4b976dbbbd008946f637a50e
testGetEmptySchemaField
public void testGetEmptySchemaField() throws Exception
{    Schema s = Schema.createRecord("schemaName", "schemaDoc", "namespace", false);    s.getField("foo");}
71e504ce819283fea7d8a7eefebd062d6c41c8b5271802db163fa57ca6600edb
testRecordPutInvalidField
public void testRecordPutInvalidField() throws Exception
{    Schema s = Schema.createRecord("schemaName", "schemaDoc", "namespace", false);    List<Schema.Field> fields = new ArrayList<>();    fields.add(new Schema.Field("someFieldName", s, "docs", null));    s.setFields(fields);    Record r = new GenericData.Record(s);    r.put("invalidFieldName", "someValue");}
ad6f12d30164517b5d8852c2595ff6dcc9e828122d198b1d26eaebfe2762e22e
testHashCode
public void testHashCode()
{    GenericData.get().hashCode(null, Schema.create(Type.NULL));    GenericData.get().hashCode(null, Schema.createUnion(Arrays.asList(Schema.create(Type.BOOLEAN), Schema.create(Type.STRING))));    List<CharSequence> stuff = new ArrayList<>();    stuff.add("string");    Schema schema = recordSchema();    GenericRecord r = new GenericData.Record(schema);    r.put(0, stuff);    GenericData.get().hashCode(r, schema);}
d743635326590d02d09b08382668302390b29ae4396743be077aaaa0d7b5353f
testEquals
public void testEquals()
{    Schema s = recordSchema();    GenericRecord r0 = new GenericData.Record(s);    GenericRecord r1 = new GenericData.Record(s);    GenericRecord r2 = new GenericData.Record(s);    Collection<CharSequence> l0 = new ArrayDeque<>();    List<CharSequence> l1 = new ArrayList<>();    GenericArray<CharSequence> l2 = new GenericData.Array<>(1, s.getFields().get(0).schema());    String foo = "foo";    l0.add(new StringBuilder(foo));    l1.add(foo);    l2.add(new Utf8(foo));    r0.put(0, l0);    r1.put(0, l1);    r2.put(0, l2);    assertEquals(r0, r1);    assertEquals(r0, r2);    assertEquals(r1, r2);}
278f9f8702db2680bc2b174c88ce7e26c5c1faf3f72308a6053b453fe09bb40b
recordSchema
private Schema recordSchema()
{    List<Field> fields = new ArrayList<>();    fields.add(new Field("anArray", Schema.createArray(Schema.create(Type.STRING)), null, null));    Schema schema = Schema.createRecord("arrayFoo", "test", "mytest", false);    schema.setFields(fields);    return schema;}
6a9979feaa21eb6abf9102024fc5818dfa1db35ec4f8f42542b16bebc3352bbd
testEquals2
public void testEquals2()
{    Schema schema1 = Schema.createRecord("r", null, "x", false);    List<Field> fields1 = new ArrayList<>();    fields1.add(new Field("a", Schema.create(Schema.Type.STRING), null, null, Field.Order.IGNORE));    schema1.setFields(fields1);        Schema schema2 = Schema.createRecord("r", null, "x", false);    List<Field> fields2 = new ArrayList<>();    fields2.add(new Field("a", Schema.create(Schema.Type.STRING), null, null, Field.Order.ASCENDING));    schema2.setFields(fields2);    GenericRecord record1 = new GenericData.Record(schema1);    record1.put("a", "1");    GenericRecord record2 = new GenericData.Record(schema2);    record2.put("a", "2");    assertFalse(record2.equals(record1));    assertFalse(record1.equals(record2));}
32f3ed334b347cf76676c4f72baec3eb1dcd1cc48ef5e264aa743399397ff397
testRecordGetFieldDoesntExist
public void testRecordGetFieldDoesntExist() throws Exception
{    List<Field> fields = new ArrayList<>();    Schema schema = Schema.createRecord(fields);    GenericData.Record record = new GenericData.Record(schema);    assertNull(record.get("does not exist"));}
dc61ce919e652bd059355e99c409774d75abf58e8b0b774c09b64f2f1d5b3717
testArrayReversal
public void testArrayReversal()
{    Schema schema = Schema.createArray(Schema.create(Schema.Type.INT));    GenericArray<Integer> forward = new GenericData.Array<>(10, schema);    GenericArray<Integer> backward = new GenericData.Array<>(10, schema);    for (int i = 0; i <= 9; i++) {        forward.add(i);    }    for (int i = 9; i >= 0; i--) {        backward.add(i);    }    forward.reverse();    assertTrue(forward.equals(backward));}
7d492cd936f5020fc86c4dce2228130a1c9c7e6a15435fe406af84e1a3ef4dc6
testArrayListInterface
public void testArrayListInterface()
{    Schema schema = Schema.createArray(Schema.create(Schema.Type.INT));    GenericArray<Integer> array = new GenericData.Array<>(1, schema);    array.add(99);    assertEquals(Integer.valueOf(99), array.get(0));    List<Integer> list = new ArrayList<>();    list.add(99);    assertEquals(array, list);    assertEquals(list, array);    assertEquals(list.hashCode(), array.hashCode());    try {        array.get(2);        fail("Expected IndexOutOfBoundsException getting index 2");    } catch (IndexOutOfBoundsException e) {    }    array.clear();    assertEquals(0, array.size());    try {        array.get(0);        fail("Expected IndexOutOfBoundsException getting index 0 after clear()");    } catch (IndexOutOfBoundsException e) {    }}
d2228cf4207704ec7c55fbfb4e5e715af08841ea0782e9ed6c12a1c2eeda1d17
testArrayAddAtLocation
public void testArrayAddAtLocation()
{    Schema schema = Schema.createArray(Schema.create(Schema.Type.INT));    GenericArray<Integer> array = new GenericData.Array<>(6, schema);    array.clear();    for (int i = 0; i < 5; ++i) array.add(i);    assertEquals(5, array.size());    array.add(0, 6);    assertEquals(Integer.valueOf(6), array.get(0));    assertEquals(6, array.size());    assertEquals(Integer.valueOf(0), array.get(1));    assertEquals(Integer.valueOf(4), array.get(5));    array.add(6, 7);    assertEquals(Integer.valueOf(7), array.get(6));    assertEquals(7, array.size());    assertEquals(Integer.valueOf(6), array.get(0));    assertEquals(Integer.valueOf(4), array.get(5));    array.add(1, 8);    assertEquals(Integer.valueOf(8), array.get(1));    assertEquals(Integer.valueOf(0), array.get(2));    assertEquals(Integer.valueOf(6), array.get(0));    assertEquals(8, array.size());    try {        array.get(9);        fail("Expected IndexOutOfBoundsException after adding elements");    } catch (IndexOutOfBoundsException e) {    }}
87dfd41866efffe4972f0c940ab09aace5877e9b31510cffa364df1fe3c30f4a
testArrayRemove
public void testArrayRemove()
{    Schema schema = Schema.createArray(Schema.create(Schema.Type.INT));    GenericArray<Integer> array = new GenericData.Array<>(10, schema);    array.clear();    for (int i = 0; i < 10; ++i) array.add(i);    assertEquals(10, array.size());    assertEquals(Integer.valueOf(0), array.get(0));    assertEquals(Integer.valueOf(9), array.get(9));    array.remove(0);    assertEquals(9, array.size());    assertEquals(Integer.valueOf(1), array.get(0));    assertEquals(Integer.valueOf(2), array.get(1));    assertEquals(Integer.valueOf(9), array.get(8));        try {        array.get(9);        fail("Expected IndexOutOfBoundsException after removing an element");    } catch (IndexOutOfBoundsException e) {    }    try {        array.set(9, 99);        fail("Expected IndexOutOfBoundsException after removing an element");    } catch (IndexOutOfBoundsException e) {    }    try {        array.remove(9);        fail("Expected IndexOutOfBoundsException after removing an element");    } catch (IndexOutOfBoundsException e) {    }        assertEquals(Integer.valueOf(9), array.remove(8));    assertEquals(8, array.size());        array.add(88);    assertEquals(Integer.valueOf(88), array.get(8));}
74433ce74ea6217a50a271063832608361507d0701d0961979ca0d8db503b7b1
testArraySet
public void testArraySet()
{    Schema schema = Schema.createArray(Schema.create(Schema.Type.INT));    GenericArray<Integer> array = new GenericData.Array<>(10, schema);    array.clear();    for (int i = 0; i < 10; ++i) array.add(i);    assertEquals(10, array.size());    assertEquals(Integer.valueOf(0), array.get(0));    assertEquals(Integer.valueOf(5), array.get(5));    assertEquals(Integer.valueOf(5), array.set(5, 55));    assertEquals(10, array.size());    assertEquals(Integer.valueOf(55), array.get(5));}
7daebc8d4e5a84341489f5893e6245d9a2dd5a1149668625d9ffe0db2c9e9ad0
testToStringIsJson
public void testToStringIsJson() throws JsonParseException, IOException
{    Field stringField = new Field("string", Schema.create(Type.STRING), null, null);    Field enumField = new Field("enum", Schema.createEnum("my_enum", "doc", null, Arrays.asList("a", "b", "c")), null, null);    Schema schema = Schema.createRecord("my_record", "doc", "mytest", false);    schema.setFields(Arrays.asList(stringField, enumField));    GenericRecord r = new GenericData.Record(schema);        r.put(stringField.name(), "hello\nthere\"\tyou\u2013}");    r.put(enumField.name(), new GenericData.EnumSymbol(enumField.schema(), "a"));    String json = r.toString();    JsonFactory factory = new JsonFactory();    JsonParser parser = factory.createParser(json);    ObjectMapper mapper = new ObjectMapper();        mapper.readTree(parser);}
267699a83aa4fa5424ebd56b3638a52470724e84518691032db36c31d9b3eac5
testMapWithNonStringKeyToStringIsJson
public void testMapWithNonStringKeyToStringIsJson() throws Exception
{    Schema intMapSchema = new Schema.Parser().parse("{\"type\": \"map\", \"values\": \"string\", \"java-key-class\" : \"java.lang.Integer\"}");    Field intMapField = new Field("intMap", Schema.createMap(intMapSchema), null, null);    Schema decMapSchema = new Schema.Parser().parse("{\"type\": \"map\", \"values\": \"string\", \"java-key-class\" : \"java.math.BigDecimal\"}");    Field decMapField = new Field("decMap", Schema.createMap(decMapSchema), null, null);    Schema boolMapSchema = new Schema.Parser().parse("{\"type\": \"map\", \"values\": \"string\", \"java-key-class\" : \"java.lang.Boolean\"}");    Field boolMapField = new Field("boolMap", Schema.createMap(boolMapSchema), null, null);    Schema fileMapSchema = new Schema.Parser().parse("{\"type\": \"map\", \"values\": \"string\", \"java-key-class\" : \"java.io.File\"}");    Field fileMapField = new Field("fileMap", Schema.createMap(fileMapSchema), null, null);    Schema schema = Schema.createRecord("my_record", "doc", "mytest", false);    schema.setFields(Arrays.asList(intMapField, decMapField, boolMapField, fileMapField));    HashMap<Integer, String> intPair = new HashMap<>();    intPair.put(1, "one");    intPair.put(2, "two");    HashMap<java.math.BigDecimal, String> decPair = new HashMap<>();    decPair.put(java.math.BigDecimal.valueOf(1), "one");    decPair.put(java.math.BigDecimal.valueOf(2), "two");    HashMap<Boolean, String> boolPair = new HashMap<>();    boolPair.put(true, "isTrue");    boolPair.put(false, "isFalse");    boolPair.put(null, null);    HashMap<java.io.File, String> filePair = new HashMap<>();    java.io.File f = new java.io.File(getClass().getResource("/SchemaBuilder.avsc").toURI());    filePair.put(f, "File");    GenericRecord r = new GenericData.Record(schema);    r.put(intMapField.name(), intPair);    r.put(decMapField.name(), decPair);    r.put(boolMapField.name(), boolPair);    r.put(fileMapField.name(), filePair);    String json = r.toString();    JsonFactory factory = new JsonFactory();    JsonParser parser = factory.createParser(json);    ObjectMapper mapper = new ObjectMapper();        mapper.readTree(parser);}
952c4a8d51a48d83c384fc08a0f9290fbd7ec6e219c2db21e02d7a553e342c5e
testToStringEscapesControlCharsInBytes
public void testToStringEscapesControlCharsInBytes() throws Exception
{    GenericData data = GenericData.get();    ByteBuffer bytes = ByteBuffer.wrap(new byte[] { 'a', '\n', 'b' });    assertEquals("\"a\\nb\"", data.toString(bytes));    assertEquals("\"a\\nb\"", data.toString(bytes));}
5e3908aebd4d86c76e78bee4b087accf0693e51385661d3c8149d75027d3b5dc
testToStringEscapesControlCharsInMap
public void testToStringEscapesControlCharsInMap()
{    GenericData data = GenericData.get();    Map<String, String> m = new HashMap<>();    m.put("a\n\\b", "a\n\\b");    assertEquals("{\"a\\n\\\\b\": \"a\\n\\\\b\"}", data.toString(m));}
882f6a2e448d32c30f32654dbcb258aa2068ca654ec472d379fe4377cf9ca33f
testToStringFixed
public void testToStringFixed() throws Exception
{    GenericData data = GenericData.get();    assertEquals("[97, 10, 98]", data.toString(new GenericData.Fixed(Schema.createFixed("test", null, null, 3), new byte[] { 'a', '\n', 'b' })));}
46de1493e364ee9ee4ea38d135906c88816cd7e96a0bbc061288fd4b3889a8f6
testToStringDoesNotEscapeForwardSlash
public void testToStringDoesNotEscapeForwardSlash() throws Exception
{    GenericData data = GenericData.get();    assertEquals("\"/\"", data.toString("/"));}
518382fac7f9c265b0cb5b0164a6f9d8475d9bcf7e8e9fea703c0c8f4157e675
testToStringNanInfinity
public void testToStringNanInfinity() throws Exception
{    GenericData data = GenericData.get();    assertEquals("\"Infinity\"", data.toString(Float.POSITIVE_INFINITY));    assertEquals("\"-Infinity\"", data.toString(Float.NEGATIVE_INFINITY));    assertEquals("\"NaN\"", data.toString(Float.NaN));    assertEquals("\"Infinity\"", data.toString(Double.POSITIVE_INFINITY));    assertEquals("\"-Infinity\"", data.toString(Double.NEGATIVE_INFINITY));    assertEquals("\"NaN\"", data.toString(Double.NaN));}
41dd1440e007f2271227d7c71b61d3195aee2817e4050f0a3daaa94d827cbb23
testCompare
public void testCompare()
{        Field integerField = new Field("test", Schema.create(Type.INT), null, null);    List<Field> fields = new ArrayList<>();    fields.add(integerField);    Schema record = Schema.createRecord("test", null, null, false);    record.setFields(fields);    ByteArrayOutputStream b1 = new ByteArrayOutputStream(5);    ByteArrayOutputStream b2 = new ByteArrayOutputStream(5);    BinaryEncoder b1Enc = EncoderFactory.get().binaryEncoder(b1, null);    BinaryEncoder b2Enc = EncoderFactory.get().binaryEncoder(b2, null);        Record testDatum1 = new Record(record);    testDatum1.put(0, 1);    Record testDatum2 = new Record(record);    testDatum2.put(0, 2);    GenericDatumWriter<Record> gWriter = new GenericDatumWriter<>(record);    Integer start1 = 0, start2 = 0;    try {                        gWriter.write(testDatum1, b1Enc);        b1Enc.flush();        start1 = b1.size();        gWriter.write(testDatum1, b1Enc);        b1Enc.flush();        b1.close();        gWriter.write(testDatum2, b2Enc);        b2Enc.flush();        start2 = b2.size();        gWriter.write(testDatum2, b2Enc);        b2Enc.flush();        b2.close();                assertEquals(-1, BinaryData.compare(b1.toByteArray(), start1, b2.toByteArray(), start2, record));    } catch (IOException e) {        fail("IOException while writing records to output stream.");    }}
79df3b82fbeef7dcda4f3371fedd0a45bf2cef049417ce498a2b25c368d33711
testEnumCompare
public void testEnumCompare()
{    Schema s = Schema.createEnum("Kind", null, null, Arrays.asList("Z", "Y", "X"));    GenericEnumSymbol z = new GenericData.EnumSymbol(s, "Z");    GenericEnumSymbol z2 = new GenericData.EnumSymbol(s, "Z");    assertEquals(0, z.compareTo(z2));    GenericEnumSymbol y = new GenericData.EnumSymbol(s, "Y");    assertTrue(y.compareTo(z) > 0);    assertTrue(z.compareTo(y) < 0);}
531a4a73350e65cd1ce3f6ac3d4710e5d0cf03fff1893615e06188bc8715ae5d
testByteBufferDeepCopy
public void testByteBufferDeepCopy()
{            byte[] buffer_value = { 0, 1, 2, 3, 0, 0, 0 };    ByteBuffer buffer = ByteBuffer.wrap(buffer_value, 1, 4);    Schema schema = Schema.createRecord("my_record", "doc", "mytest", false);    Field byte_field = new Field("bytes", Schema.create(Type.BYTES), null, null);    schema.setFields(Collections.singletonList(byte_field));    GenericRecord record = new GenericData.Record(schema);    record.put(byte_field.name(), buffer);    GenericRecord copy = GenericData.get().deepCopy(schema, record);    ByteBuffer buffer_copy = (ByteBuffer) copy.get(byte_field.name());    assertEquals(buffer, buffer_copy);}
33daef52373115b4c089c56cc5a88ea1881ba753274ec3796b403b68ac3433ea
testValidateNullableEnum
public void testValidateNullableEnum()
{    List<Schema> unionTypes = new ArrayList<>();    Schema schema;    Schema nullSchema = Schema.create(Type.NULL);    Schema enumSchema = Schema.createEnum("AnEnum", null, null, Arrays.asList("X", "Y", "Z"));    GenericEnumSymbol w = new GenericData.EnumSymbol(enumSchema, "W");    GenericEnumSymbol x = new GenericData.EnumSymbol(enumSchema, "X");    GenericEnumSymbol y = new GenericData.EnumSymbol(enumSchema, "Y");    GenericEnumSymbol z = new GenericData.EnumSymbol(enumSchema, "Z");        unionTypes.clear();    unionTypes.add(nullSchema);    unionTypes.add(enumSchema);    schema = Schema.createUnion(unionTypes);    assertTrue(GenericData.get().validate(schema, z));    assertTrue(GenericData.get().validate(schema, y));    assertTrue(GenericData.get().validate(schema, x));    assertFalse(GenericData.get().validate(schema, w));    assertTrue(GenericData.get().validate(schema, null));        unionTypes.clear();    unionTypes.add(enumSchema);    unionTypes.add(nullSchema);    schema = Schema.createUnion(unionTypes);    assertTrue(GenericData.get().validate(schema, z));    assertTrue(GenericData.get().validate(schema, y));    assertTrue(GenericData.get().validate(schema, x));    assertFalse(GenericData.get().validate(schema, w));    assertTrue(GenericData.get().validate(schema, null));}
a02250a95fe9c2ed92a1740785cc7b06f4b4436079481bc36040d4796233cf40
validateRequiresGenericSymbolForEnumSchema
public void validateRequiresGenericSymbolForEnumSchema()
{    final Schema schema = Schema.createEnum("my_enum", "doc", "namespace", Arrays.asList("ONE", "TWO", "THREE"));    final GenericData gd = GenericData.get();    /* positive cases */    assertTrue(gd.validate(schema, new GenericData.EnumSymbol(schema, "ONE")));    assertTrue(gd.validate(schema, new GenericData.EnumSymbol(schema, anEnum.ONE)));    /* negative cases */    assertFalse("We don't expect GenericData to allow a String datum for an enum schema", gd.validate(schema, "ONE"));    assertFalse("We don't expect GenericData to allow a Java Enum for an enum schema", gd.validate(schema, anEnum.ONE));}
b19d0470a9ae9a8852e46a6ae9ca7bbfc908257c894218ecdf1d415a2477f145
testValidateUnion
public void testValidateUnion()
{    Schema type1Schema = SchemaBuilder.record("Type1").fields().requiredString("myString").requiredInt("myInt").endRecord();    Schema type2Schema = SchemaBuilder.record("Type2").fields().requiredString("myString").endRecord();    Schema unionSchema = SchemaBuilder.unionOf().type(type1Schema).and().type(type2Schema).endUnion();    GenericRecord record = new GenericData.Record(type2Schema);    record.put("myString", "myValue");    assertTrue(GenericData.get().validate(unionSchema, record));}
02f5cce930adc3b8846d4c8b6324b42abe3f05a22cdab7d342f412e4c6670154
testToStringSameValues
public void testToStringSameValues() throws IOException
{    List<Field> fields = new ArrayList<>();    fields.add(new Field("nullstring1", Schema.create(Type.STRING), null, null));    fields.add(new Field("nullstring2", Schema.create(Type.STRING), null, null));    fields.add(new Field("string1", Schema.create(Type.STRING), null, null));    fields.add(new Field("string2", Schema.create(Type.STRING), null, null));    fields.add(new Field("bytes1", Schema.create(Type.BYTES), null, null));    fields.add(new Field("bytes2", Schema.create(Type.BYTES), null, null));    fields.add(new Field("int1", Schema.create(Type.INT), null, null));    fields.add(new Field("int2", Schema.create(Type.INT), null, null));    fields.add(new Field("long1", Schema.create(Type.LONG), null, null));    fields.add(new Field("long2", Schema.create(Type.LONG), null, null));    fields.add(new Field("float1", Schema.create(Type.FLOAT), null, null));    fields.add(new Field("float2", Schema.create(Type.FLOAT), null, null));    fields.add(new Field("double1", Schema.create(Type.DOUBLE), null, null));    fields.add(new Field("double2", Schema.create(Type.DOUBLE), null, null));    fields.add(new Field("boolean1", Schema.create(Type.BOOLEAN), null, null));    fields.add(new Field("boolean2", Schema.create(Type.BOOLEAN), null, null));    List<String> enumValues = new ArrayList<>();    enumValues.add("One");    enumValues.add("Two");    Schema enumSchema = Schema.createEnum("myEnum", null, null, enumValues);    fields.add(new Field("enum1", enumSchema, null, null));    fields.add(new Field("enum2", enumSchema, null, null));    Schema recordSchema = SchemaBuilder.record("aRecord").fields().requiredString("myString").endRecord();    fields.add(new Field("record1", recordSchema, null, null));    fields.add(new Field("record2", recordSchema, null, null));    Schema arraySchema = Schema.createArray(Schema.create(Type.STRING));    fields.add(new Field("array1", arraySchema, null, null));    fields.add(new Field("array2", arraySchema, null, null));    Schema mapSchema = Schema.createMap(Schema.create(Type.STRING));    fields.add(new Field("map1", mapSchema, null, null));    fields.add(new Field("map2", mapSchema, null, null));    Schema schema = Schema.createRecord("Foo", "test", "mytest", false);    schema.setFields(fields);    Record testRecord = new Record(schema);    testRecord.put("nullstring1", null);    testRecord.put("nullstring2", null);    String fortyTwo = "42";    testRecord.put("string1", fortyTwo);    testRecord.put("string2", fortyTwo);    testRecord.put("bytes1", 0x42);    testRecord.put("bytes2", 0x42);    testRecord.put("int1", 42);    testRecord.put("int2", 42);    testRecord.put("long1", 42L);    testRecord.put("long2", 42L);    testRecord.put("float1", 42F);    testRecord.put("float2", 42F);    testRecord.put("double1", 42D);    testRecord.put("double2", 42D);    testRecord.put("boolean1", true);    testRecord.put("boolean2", true);    testRecord.put("enum1", "One");    testRecord.put("enum2", "One");    GenericRecord record = new GenericData.Record(recordSchema);    record.put("myString", "42");    testRecord.put("record1", record);    testRecord.put("record2", record);    GenericArray<String> array = new GenericData.Array<>(1, arraySchema);    array.clear();    array.add("42");    testRecord.put("array1", array);    testRecord.put("array2", array);    Map<String, String> map = new HashMap<>();    map.put("42", "42");    testRecord.put("map1", map);    testRecord.put("map2", map);    String testString = testRecord.toString();    assertFalse("Record with duplicated values results in wrong 'toString()'", testString.contains("CIRCULAR REFERENCE"));}
47f91041be893dbef80c7f2b9e77248dfa0e97793a8b4ac57f1ee8ee8ecc0c65
testToStringRecursive
public void testToStringRecursive() throws IOException
{    ReferenceManager manager = new ReferenceManager();    GenericData model = new GenericData();    model.addLogicalTypeConversion(manager.getTracker());    model.addLogicalTypeConversion(manager.getHandler());    Schema parentSchema = Schema.createRecord("Parent", null, null, false);    Schema placeholderSchema = Schema.createRecord("Placeholder", null, null, false);    List<Schema.Field> placeholderFields = new ArrayList<>();        placeholderFields.add(new Schema.Field("id", Schema.create(Schema.Type.LONG), null, null));    placeholderSchema.setFields(placeholderFields);    Referenceable idRef = new Referenceable("id");    Schema parentRefSchema = Schema.createUnion(Schema.create(Schema.Type.NULL), Schema.create(Schema.Type.LONG), idRef.addToSchema(placeholderSchema));    Reference parentRef = new Reference("parent");    List<Schema.Field> childFields = new ArrayList<>();    childFields.add(new Schema.Field("c", Schema.create(Schema.Type.STRING), null, null));    childFields.add(new Schema.Field("parent", parentRefSchema, null, null));    Schema childSchema = parentRef.addToSchema(Schema.createRecord("Child", null, null, false, childFields));    List<Schema.Field> parentFields = new ArrayList<>();    parentFields.add(new Schema.Field("id", Schema.create(Schema.Type.LONG), null, null));    parentFields.add(new Schema.Field("p", Schema.create(Schema.Type.STRING), null, null));    parentFields.add(new Schema.Field("child", childSchema, null, null));    parentSchema.setFields(parentFields);    Schema schema = idRef.addToSchema(parentSchema);    Record parent = new Record(schema);    parent.put("id", 1L);    parent.put("p", "parent data!");    Record child = new Record(childSchema);    child.put("c", "child data!");    child.put("parent", parent);    parent.put("child", child);    try {                assertNotNull(parent.toString());    } catch (StackOverflowError e) {        fail("StackOverflowError occurred");    }}
4cd4e5d52375965bb078c44620f283d3424f6ee4524698b42241e91c8ad8f0c2
testGenericArrayPeek
public void testGenericArrayPeek()
{    Schema elementSchema = SchemaBuilder.record("element").fields().requiredString("value").endRecord();    Schema arraySchema = Schema.createArray(elementSchema);    GenericRecord record = new GenericData.Record(elementSchema);    record.put("value", "string");    GenericArray<GenericRecord> list = new GenericData.Array<>(1, arraySchema);    list.add(record);    list.reset();    assertTrue(record == list.peek());    list.prune();    assertNull(list.peek());}
a0d21f2da4a70f218d0e18876357fddaa83563d59cf205a7eb7099c9803c11d4
testWrite
public void testWrite() throws IOException
{    String json = "{\"type\": \"record\", \"name\": \"r\", \"fields\": [" + "{ \"name\": \"f1\", \"type\": \"long\" }" + "]}";    Schema s = new Schema.Parser().parse(json);    GenericRecord r = new GenericData.Record(s);    r.put("f1", 100L);    ByteArrayOutputStream bao = new ByteArrayOutputStream();    GenericDatumWriter<GenericRecord> w = new GenericDatumWriter<>(s);    Encoder e = EncoderFactory.get().jsonEncoder(s, bao);    w.write(r, e);    e.flush();    Object o = new GenericDatumReader<GenericRecord>(s).read(null, DecoderFactory.get().jsonDecoder(s, new ByteArrayInputStream(bao.toByteArray())));    assertEquals(r, o);}
e8d5ae39ed694cf0c5530ac2e3eb695f8d4f47eace2c4dd149309b8348fe3f4a
testArrayConcurrentModification
public void testArrayConcurrentModification() throws Exception
{    String json = "{\"type\": \"array\", \"items\": \"int\" }";    Schema s = new Schema.Parser().parse(json);    final GenericArray<Integer> a = new GenericData.Array<>(1, s);    ByteArrayOutputStream bao = new ByteArrayOutputStream();    final GenericDatumWriter<GenericArray<Integer>> w = new GenericDatumWriter<>(s);    CountDownLatch sizeWrittenSignal = new CountDownLatch(1);    CountDownLatch eltAddedSignal = new CountDownLatch(1);    final TestEncoder e = new TestEncoder(EncoderFactory.get().directBinaryEncoder(bao, null), sizeWrittenSignal, eltAddedSignal);        ExecutorService executor = Executors.newSingleThreadExecutor();    Future<Void> result = executor.submit(() -> {        w.write(a, e);        return null;    });    sizeWrittenSignal.await();        a.add(7);        eltAddedSignal.countDown();    try {        result.get();        fail("Expected ConcurrentModificationException");    } catch (ExecutionException ex) {        assertTrue(ex.getCause() instanceof ConcurrentModificationException);    }}
ceef9a649f1e0446ddd2bdc96e5f15f76587f4a0e36a6ea6c24c5a9094cd24ed
testMapConcurrentModification
public void testMapConcurrentModification() throws Exception
{    String json = "{\"type\": \"map\", \"values\": \"int\" }";    Schema s = new Schema.Parser().parse(json);    final Map<String, Integer> m = new HashMap<>();    ByteArrayOutputStream bao = new ByteArrayOutputStream();    final GenericDatumWriter<Map<String, Integer>> w = new GenericDatumWriter<>(s);    CountDownLatch sizeWrittenSignal = new CountDownLatch(1);    CountDownLatch eltAddedSignal = new CountDownLatch(1);    final TestEncoder e = new TestEncoder(EncoderFactory.get().directBinaryEncoder(bao, null), sizeWrittenSignal, eltAddedSignal);        ExecutorService executor = Executors.newSingleThreadExecutor();    Future<Void> result = executor.submit(() -> {        w.write(m, e);        return null;    });    sizeWrittenSignal.await();        m.put("a", 7);        eltAddedSignal.countDown();    try {        result.get();        fail("Expected ConcurrentModificationException");    } catch (ExecutionException ex) {        assertTrue(ex.getCause() instanceof ConcurrentModificationException);    }}
397b6502072ea3a1ac72a07bee65a462902e7e78c46d167fac7946bd2eee93fb
writeArrayStart
public void writeArrayStart() throws IOException
{    e.writeArrayStart();    sizeWrittenSignal.countDown();    try {        eltAddedSignal.await();    } catch (InterruptedException e) {        }}
06a13fe57e24d2460afd3389759c84bd57ee09e14710364b77d081005edff6eb
writeMapStart
public void writeMapStart() throws IOException
{    e.writeMapStart();    sizeWrittenSignal.countDown();    try {        eltAddedSignal.await();    } catch (InterruptedException e) {        }}
c3e67ec76f1b008887f1caba645a2614900cde6e477acca1bc3ecc36bf357fcf
flush
public void flush() throws IOException
{    e.flush();}
07c3270fe1b73532e66eb6f555ff312e3202b8435cf61382c5aa1c0dc4ce9a22
writeNull
public void writeNull() throws IOException
{    e.writeNull();}
9d2c4a8e17244c43f6c9a688d920b81cfa21c5d72f09e261b40e4539894a93a4
writeBoolean
public void writeBoolean(boolean b) throws IOException
{    e.writeBoolean(b);}
3d8eb176faa04ef3aa5f28bd1c308daf64cdee2071894b3447ade0d0891ac95b
writeInt
public void writeInt(int n) throws IOException
{    e.writeInt(n);}
9d5f02c473bb90aaa95e11d7e93625ba8050b2ae1b4b94e45331333ecc81fb92
writeLong
public void writeLong(long n) throws IOException
{    e.writeLong(n);}
485832ef5d131a3779da1c259796c40decbe270ca77fd7c3bd67453210649270
writeFloat
public void writeFloat(float f) throws IOException
{    e.writeFloat(f);}
b0e7b254d45c2210c8fda5ed2caaef6ca76fec51fb5d6a536add22a8a39ae5e9
writeDouble
public void writeDouble(double d) throws IOException
{    e.writeDouble(d);}
34bdbb4029a48cb89270af40e256732c5b672fb11b54336d3f7efc90b7df5ab2
writeString
public void writeString(Utf8 utf8) throws IOException
{    e.writeString(utf8);}
ef77a45285e12605fa0ac332653126204dbd8aeb25f392f6b9900d3df7110e24
writeBytes
public void writeBytes(ByteBuffer bytes) throws IOException
{    e.writeBytes(bytes);}
5686b3aa744852e31cb4ae1e0044e20a94ff28b7620cb59b1eb1a47c8ef69565
writeBytes
public void writeBytes(byte[] bytes, int start, int len) throws IOException
{    e.writeBytes(bytes, start, len);}
23ad82833b3f2bd0c47b14f7e1f984068754ba8fea96d9cf72a5dc7b0df27779
writeFixed
public void writeFixed(byte[] bytes, int start, int len) throws IOException
{    e.writeFixed(bytes, start, len);}
f232f04663ec90cf9182356191954ac0c3812bd61283d95cb5934dadcc7b22a0
writeEnum
public void writeEnum(int en) throws IOException
{    e.writeEnum(en);}
b85783ea95d3093dd3e304d9bd3da87a2a232aaf24ea3f4113e86bf54caa8ad5
setItemCount
public void setItemCount(long itemCount) throws IOException
{    e.setItemCount(itemCount);}
bed0009bb8139bc1ffb6ee9ad42162880141e39749c278e1724abb291a79cd42
startItem
public void startItem() throws IOException
{    e.startItem();}
ed98fbed6a1d613e764dba378ccb5b19a641d3ecbc93a5f3d50f0010442034de
writeArrayEnd
public void writeArrayEnd() throws IOException
{    e.writeArrayEnd();}
44f6ecf1e519c8992d2b321f4cf40cfe49a47d580d58e41fd28fe573a1ea47c4
writeMapEnd
public void writeMapEnd() throws IOException
{    e.writeMapEnd();}
5e98b24f5d4da4c35f9e7f9247f0fdca1daf147afc1971fff5a25067084cf67d
writeIndex
public void writeIndex(int unionIndex) throws IOException
{    e.writeIndex(unionIndex);}
73650531c7fd04bd7b301c581eafb6f620ef43b6a21d94892f0effc37d1b4d44
writeDoesNotAllowStringForGenericEnum
public void writeDoesNotAllowStringForGenericEnum() throws IOException
{    final String json = "{\"type\": \"record\", \"name\": \"recordWithEnum\"," + "\"fields\": [ " + "{\"name\": \"field\", \"type\": " + "{\"type\": \"enum\", \"name\": \"enum\", \"symbols\": " + "[\"ONE\",\"TWO\",\"THREE\"] " + "}" + "}" + "]}";    Schema schema = new Schema.Parser().parse(json);    GenericRecord record = new GenericData.Record(schema);    record.put("field", "ONE");    ByteArrayOutputStream bao = new ByteArrayOutputStream();    GenericDatumWriter<GenericRecord> writer = new GenericDatumWriter<>(schema);    Encoder encoder = EncoderFactory.get().jsonEncoder(schema, bao);    writer.write(record, encoder);}
9475604f33e29b6ce3bf18f60520099cf0d8a6e6e7f14bcce35b790e8e121f9e
writeDoesNotAllowJavaEnumForGenericEnum
public void writeDoesNotAllowJavaEnumForGenericEnum() throws IOException
{    final String json = "{\"type\": \"record\", \"name\": \"recordWithEnum\"," + "\"fields\": [ " + "{\"name\": \"field\", \"type\": " + "{\"type\": \"enum\", \"name\": \"enum\", \"symbols\": " + "[\"ONE\",\"TWO\",\"THREE\"] " + "}" + "}" + "]}";    Schema schema = new Schema.Parser().parse(json);    GenericRecord record = new GenericData.Record(schema);    record.put("field", AnEnum.ONE);    ByteArrayOutputStream bao = new ByteArrayOutputStream();    GenericDatumWriter<GenericRecord> writer = new GenericDatumWriter<>(schema);    Encoder encoder = EncoderFactory.get().jsonEncoder(schema, bao);    writer.write(record, encoder);}
57357b22741517e3d3f0345c8a30f22fce101fd2180f026a20d567d5f8315dd4
writeFieldWithDefaultWithExplicitNullDefaultInSchema
public void writeFieldWithDefaultWithExplicitNullDefaultInSchema() throws Exception
{    Schema schema = schemaWithExplicitNullDefault();    GenericRecord record = createRecordWithDefaultField(schema);    writeObject(schema, record);}
d0259e19e80ecbffbd7792bf6c09ffdc75956ac8fc711ea6a8a6397a5c548c08
writeFieldWithDefaultWithoutExplicitNullDefaultInSchema
public void writeFieldWithDefaultWithoutExplicitNullDefaultInSchema() throws Exception
{    Schema schema = schemaWithoutExplicitNullDefault();    GenericRecord record = createRecordWithDefaultField(schema);    writeObject(schema, record);}
d068e9f84c0577c230dd73c05d04634331bf97ceb7fcccdce3d6a8ca0f273120
schemaWithExplicitNullDefault
private Schema schemaWithExplicitNullDefault()
{    String schema = "{\"type\":\"record\",\"name\":\"my_record\",\"namespace\":\"mytest.namespace\",\"doc\":\"doc\"," + "\"fields\":[{\"name\":\"f\",\"type\":[\"null\",\"string\"],\"doc\":\"field doc doc\", " + "\"default\":null}]}";    return new Schema.Parser().parse(schema);}
c4a2a9d80deb83d3b0524e0cc5c0aab605f88c9d59d6c1ae92d4eb7d942a0f68
schemaWithoutExplicitNullDefault
private Schema schemaWithoutExplicitNullDefault()
{    String schema = "{\"type\":\"record\",\"name\":\"my_record\",\"namespace\":\"mytest.namespace\",\"doc\":\"doc\"," + "\"fields\":[{\"name\":\"f\",\"type\":[\"null\",\"string\"],\"doc\":\"field doc doc\"}]}";    return new Schema.Parser().parse(schema);}
aea8170500a986933058e5cf5cff2bfb9aea4fc4fffbf51d269b08022a43fc04
writeObject
private void writeObject(Schema schema, GenericRecord datum) throws Exception
{    BinaryEncoder encoder = EncoderFactory.get().binaryEncoder(new ByteArrayOutputStream(), null);    GenericDatumWriter<GenericData.Record> writer = new GenericDatumWriter<>(schema);    writer.write(schema, datum, encoder);}
3397fe5181ed359887d02423efdef028dd2dff7ddbeddde8c97a0fef34df1c67
createRecordWithDefaultField
private GenericRecord createRecordWithDefaultField(Schema schema)
{    GenericRecord record = new GenericData.Record(schema);    record.put("f", schema.getField("f").defaultVal());    return record;}
6071529378689cc44aae9c733d0a6544b35fae01aa5341738b54452454b89295
addLogicalTypes
public static void addLogicalTypes()
{    GENERIC.addLogicalTypeConversion(new Conversions.DecimalConversion());    GENERIC.addLogicalTypeConversion(new Conversions.UUIDConversion());    GENERIC.addLogicalTypeConversion(new TimeConversions.LocalTimestampMicrosConversion());    GENERIC.addLogicalTypeConversion(new TimeConversions.LocalTimestampMillisConversion());}
341a32cdb578b032c85976394fe125322cbb295129f6fa0c4687a1cf7fcac9b7
testReadUUID
public void testReadUUID() throws IOException
{    Schema uuidSchema = Schema.create(Schema.Type.STRING);    LogicalTypes.uuid().addToSchema(uuidSchema);    UUID u1 = UUID.randomUUID();    UUID u2 = UUID.randomUUID();    List<UUID> expected = Arrays.asList(u1, u2);    File test = write(Schema.create(Schema.Type.STRING), u1.toString(), u2.toString());    Assert.assertEquals("Should convert Strings to UUIDs", expected, read(GENERIC.createDatumReader(uuidSchema), test));}
f676a4d4af81cef00217a0e7b523cf04ddf8dae70106924cb49096112ed8f83a
testWriteUUID
public void testWriteUUID() throws IOException
{    Schema stringSchema = Schema.create(Schema.Type.STRING);    stringSchema.addProp(GenericData.STRING_PROP, "String");    Schema uuidSchema = Schema.create(Schema.Type.STRING);    LogicalTypes.uuid().addToSchema(uuidSchema);    UUID u1 = UUID.randomUUID();    UUID u2 = UUID.randomUUID();    List<String> expected = Arrays.asList(u1.toString(), u2.toString());    File test = write(GENERIC, uuidSchema, u1, u2);    Assert.assertEquals("Should read UUIDs as Strings", expected, read(GenericData.get().createDatumReader(stringSchema), test));}
9530cd72742c23bd9ab88394040d60173676edfbea92b7ef409b7641a156f56b
testWriteNullableUUID
public void testWriteNullableUUID() throws IOException
{    Schema stringSchema = Schema.create(Schema.Type.STRING);    stringSchema.addProp(GenericData.STRING_PROP, "String");    Schema nullableStringSchema = Schema.createUnion(Schema.create(Schema.Type.NULL), stringSchema);    Schema uuidSchema = Schema.create(Schema.Type.STRING);    LogicalTypes.uuid().addToSchema(uuidSchema);    Schema nullableUuidSchema = Schema.createUnion(Schema.create(Schema.Type.NULL), uuidSchema);    UUID u1 = UUID.randomUUID();    UUID u2 = UUID.randomUUID();    List<String> expected = Arrays.asList(u1.toString(), u2.toString());    File test = write(GENERIC, nullableUuidSchema, u1, u2);    Assert.assertEquals("Should read UUIDs as Strings", expected, read(GenericData.get().createDatumReader(nullableStringSchema), test));}
5060b48984de48816a469c0d95e3de5b5c8982f66dde753bbecd0912842f0df7
testReadDecimalFixed
public void testReadDecimalFixed() throws IOException
{    LogicalType decimal = LogicalTypes.decimal(9, 2);    Schema fixedSchema = Schema.createFixed("aFixed", null, null, 4);    Schema decimalSchema = decimal.addToSchema(Schema.createFixed("aFixed", null, null, 4));    BigDecimal d1 = new BigDecimal("-34.34");    BigDecimal d2 = new BigDecimal("117230.00");    List<BigDecimal> expected = Arrays.asList(d1, d2);    Conversion<BigDecimal> conversion = new Conversions.DecimalConversion();        GenericFixed d1fixed = conversion.toFixed(d1, fixedSchema, decimal);    GenericFixed d2fixed = conversion.toFixed(d2, fixedSchema, decimal);    File test = write(fixedSchema, d1fixed, d2fixed);    Assert.assertEquals("Should convert fixed to BigDecimals", expected, read(GENERIC.createDatumReader(decimalSchema), test));}
731e610b329037c1e22d7edf66e741db7a7007dbe3cb7f21155624d7c86a7730
testWriteDecimalFixed
public void testWriteDecimalFixed() throws IOException
{    LogicalType decimal = LogicalTypes.decimal(9, 2);    Schema fixedSchema = Schema.createFixed("aFixed", null, null, 4);    Schema decimalSchema = decimal.addToSchema(Schema.createFixed("aFixed", null, null, 4));    BigDecimal d1 = new BigDecimal("-34.34");    BigDecimal d2 = new BigDecimal("117230.00");    Conversion<BigDecimal> conversion = new Conversions.DecimalConversion();    GenericFixed d1fixed = conversion.toFixed(d1, fixedSchema, decimal);    GenericFixed d2fixed = conversion.toFixed(d2, fixedSchema, decimal);    List<GenericFixed> expected = Arrays.asList(d1fixed, d2fixed);    File test = write(GENERIC, decimalSchema, d1, d2);    Assert.assertEquals("Should read BigDecimals as fixed", expected, read(GenericData.get().createDatumReader(fixedSchema), test));}
ad6cb5bdde2f993b28778e7ed7dafb834ea9c9385e057a76e5813458efec26d2
testReadDecimalBytes
public void testReadDecimalBytes() throws IOException
{    LogicalType decimal = LogicalTypes.decimal(9, 2);    Schema bytesSchema = Schema.create(Schema.Type.BYTES);    Schema decimalSchema = decimal.addToSchema(Schema.create(Schema.Type.BYTES));    BigDecimal d1 = new BigDecimal("-34.34");    BigDecimal d2 = new BigDecimal("117230.00");    List<BigDecimal> expected = Arrays.asList(d1, d2);    Conversion<BigDecimal> conversion = new Conversions.DecimalConversion();        ByteBuffer d1bytes = conversion.toBytes(d1, bytesSchema, decimal);    ByteBuffer d2bytes = conversion.toBytes(d2, bytesSchema, decimal);    File test = write(bytesSchema, d1bytes, d2bytes);    Assert.assertEquals("Should convert bytes to BigDecimals", expected, read(GENERIC.createDatumReader(decimalSchema), test));}
a68ec1f6d5ee8399aa5e81bba11ac539f0e71d07013950882a57a0ebe0bf1805
testWriteDecimalBytes
public void testWriteDecimalBytes() throws IOException
{    LogicalType decimal = LogicalTypes.decimal(9, 2);    Schema bytesSchema = Schema.create(Schema.Type.BYTES);    Schema decimalSchema = decimal.addToSchema(Schema.create(Schema.Type.BYTES));    BigDecimal d1 = new BigDecimal("-34.34");    BigDecimal d2 = new BigDecimal("117230.00");    Conversion<BigDecimal> conversion = new Conversions.DecimalConversion();        ByteBuffer d1bytes = conversion.toBytes(d1, bytesSchema, decimal);    ByteBuffer d2bytes = conversion.toBytes(d2, bytesSchema, decimal);    List<ByteBuffer> expected = Arrays.asList(d1bytes, d2bytes);    File test = write(GENERIC, decimalSchema, d1bytes, d2bytes);    Assert.assertEquals("Should read BigDecimals as bytes", expected, read(GenericData.get().createDatumReader(bytesSchema), test));}
ef1ea9cc46570733f91ec2e7f2ee5171ae1bd2994b4fb54ce530084ce64a9e2d
read
private List<D> read(DatumReader<D> reader, File file) throws IOException
{    List<D> data = new ArrayList<>();    try (FileReader<D> fileReader = new DataFileReader<>(file, reader)) {        for (D datum : fileReader) {            data.add(datum);        }    }    return data;}
7266ec28b8527de20895c66429c2ca054a197631a9a47bd401e7254cbbc068a7
write
private File write(Schema schema, D... data) throws IOException
{    return write(GenericData.get(), schema, data);}
28e27a5e2a408002182af84ed4939b4f658ea15840fb2ad3c9de4f0e687bfabe
write
private File write(GenericData model, Schema schema, D... data) throws IOException
{    File file = temp.newFile();    DatumWriter<D> writer = model.createDatumWriter(schema);    try (DataFileWriter<D> fileWriter = new DataFileWriter<>(writer)) {        fileWriter.create(schema, file);        for (D datum : data) {            fileWriter.append(datum);        }    }    return file;}
ec1d16bf64ce332fedbd376fc55936bd523f74bcb13bdb4a1747ef17290632b4
testCopyUuid
public void testCopyUuid()
{    testCopy(LogicalTypes.uuid().addToSchema(Schema.create(Schema.Type.STRING)), UUID.randomUUID(), GENERIC);}
0739afd291ff180a0cc77835bc82d29263eba8dd74c53b1a0cd8a19e3d9f7264
testCopyUuidRaw
public void testCopyUuidRaw()
{    testCopy(    LogicalTypes.uuid().addToSchema(Schema.create(Schema.Type.STRING)),     UUID.randomUUID().toString(),     GenericData.get());}
d6e3a3583029c97d644394dd54ea7275e992f0b6a140a5ed474beddf1cfb168d
testCopyDecimal
public void testCopyDecimal()
{    testCopy(LogicalTypes.decimal(9, 2).addToSchema(Schema.create(Schema.Type.BYTES)), new BigDecimal("-34.34"), GENERIC);}
90ce5e940a33187757405c9c3d20593d185a7432d993e4021cd6f8da137f7dfe
testCopyDecimalRaw
public void testCopyDecimalRaw()
{    testCopy(LogicalTypes.decimal(9, 2).addToSchema(Schema.create(Schema.Type.BYTES)), ByteBuffer.wrap(new BigDecimal("-34.34").unscaledValue().toByteArray()),     GenericData.get());}
6ee53299db983328566ed61b642177b381e33b089b1a88af4c7f36f3865fc8de
testCopy
private void testCopy(Schema schema, Object value, GenericData model)
{        checkCopy(value, model.deepCopy(schema, value), false);        Schema recordSchema = Schema.createRecord("X", "", "test", false);    List<Schema.Field> fields = new ArrayList<>();    fields.add(new Schema.Field("x", schema, "", null));    recordSchema.setFields(fields);    GenericRecordBuilder builder = new GenericRecordBuilder(recordSchema);    builder.set("x", value);    GenericData.Record record = builder.build();    checkCopy(record, model.deepCopy(recordSchema, record), true);        Schema arraySchema = Schema.createArray(schema);    ArrayList array = new ArrayList(Collections.singletonList(value));    checkCopy(array, model.deepCopy(arraySchema, array), true);        Schema recordArraySchema = Schema.createArray(recordSchema);    ArrayList recordArray = new ArrayList(Collections.singletonList(record));    checkCopy(recordArray, model.deepCopy(recordArraySchema, recordArray), true);}
e974da9f356009cc433ff863e5fa91729c820b413cb22e0623a86bdaf618d713
checkCopy
private void checkCopy(Object original, Object copy, boolean notSame)
{    if (notSame)        Assert.assertNotSame(original, copy);    Assert.assertEquals(original, copy);}
5379d7233d5386bfdf8b22c2cd49a77633bfcb7f53a31b28cb205dbacc930785
testReadLocalTimestampMillis
public void testReadLocalTimestampMillis() throws IOException
{    LogicalType timestamp = LogicalTypes.localTimestampMillis();    Schema longSchema = Schema.create(Schema.Type.LONG);    Schema timestampSchema = timestamp.addToSchema(Schema.create(Schema.Type.LONG));    LocalDateTime i1 = LocalDateTime.of(1986, 06, 26, 12, 07, 11, 42000000);    LocalDateTime i2 = LocalDateTime.ofInstant(Instant.ofEpochMilli(0), ZoneOffset.UTC);    List<LocalDateTime> expected = Arrays.asList(i1, i2);    Conversion<LocalDateTime> conversion = new TimeConversions.LocalTimestampMillisConversion();        Long i1long = conversion.toLong(i1, longSchema, timestamp);    Long i2long = 0L;    File test = write(longSchema, i1long, i2long);    Assert.assertEquals("Should convert long to LocalDateTime", expected, read(GENERIC.createDatumReader(timestampSchema), test));}
ebe6b3b4c8d6a3780023404418f50f6e1e99e3dbbdac2e85269eeef033a397d4
testWriteLocalTimestampMillis
public void testWriteLocalTimestampMillis() throws IOException
{    LogicalType timestamp = LogicalTypes.localTimestampMillis();    Schema longSchema = Schema.create(Schema.Type.LONG);    Schema timestampSchema = timestamp.addToSchema(Schema.create(Schema.Type.LONG));    LocalDateTime i1 = LocalDateTime.of(1986, 06, 26, 12, 07, 11, 42000000);    LocalDateTime i2 = LocalDateTime.ofInstant(Instant.ofEpochMilli(0), ZoneOffset.UTC);    Conversion<LocalDateTime> conversion = new TimeConversions.LocalTimestampMillisConversion();    Long d1long = conversion.toLong(i1, longSchema, timestamp);    Long d2long = 0L;    List<Long> expected = Arrays.asList(d1long, d2long);    File test = write(GENERIC, timestampSchema, i1, i2);    Assert.assertEquals("Should read LocalDateTime as longs", expected, read(GenericData.get().createDatumReader(timestampSchema), test));}
dd46918d0093c33ca9ed77c539dc55d2c3a1f869ef12a03ad18f8585cbb1b5a3
testReadLocalTimestampMicros
public void testReadLocalTimestampMicros() throws IOException
{    LogicalType timestamp = LogicalTypes.localTimestampMicros();    Schema longSchema = Schema.create(Schema.Type.LONG);    Schema timestampSchema = timestamp.addToSchema(Schema.create(Schema.Type.LONG));    LocalDateTime i1 = LocalDateTime.of(1986, 06, 26, 12, 07, 11, 420000);    LocalDateTime i2 = LocalDateTime.ofInstant(Instant.ofEpochSecond(0, 4000), ZoneOffset.UTC);    List<LocalDateTime> expected = Arrays.asList(i1, i2);    Conversion<LocalDateTime> conversion = new TimeConversions.LocalTimestampMicrosConversion();        Long i1long = conversion.toLong(i1, longSchema, timestamp);    Long i2long = conversion.toLong(i2, longSchema, timestamp);    File test = write(longSchema, i1long, i2long);    Assert.assertEquals("Should convert long to LocalDateTime", expected, read(GENERIC.createDatumReader(timestampSchema), test));}
af77091823367b79cbe2bbb262d936daf263db2ec6a75281ef978401ba5b095a
testWriteLocalTimestampMicros
public void testWriteLocalTimestampMicros() throws IOException
{    LogicalType timestamp = LogicalTypes.localTimestampMicros();    Schema longSchema = Schema.create(Schema.Type.LONG);    Schema timestampSchema = timestamp.addToSchema(Schema.create(Schema.Type.LONG));    LocalDateTime i1 = LocalDateTime.of(1986, 06, 26, 12, 07, 11, 420000);    LocalDateTime i2 = LocalDateTime.ofInstant(Instant.ofEpochSecond(0, 4000), ZoneOffset.UTC);    Conversion<LocalDateTime> conversion = new TimeConversions.LocalTimestampMicrosConversion();    Long d1long = conversion.toLong(i1, longSchema, timestamp);    Long d2long = conversion.toLong(i2, longSchema, timestamp);    List<Long> expected = Arrays.asList(d1long, d2long);    File test = write(GENERIC, timestampSchema, i1, i2);    Assert.assertEquals("Should read LocalDateTime as longs", expected, read(GenericData.get().createDatumReader(timestampSchema), test));}
fea58a766552d5db77e81d23d871070cac203bbeb598b7b8dc6fa6fa219466ac
testGenericBuilder
public void testGenericBuilder()
{    Schema schema = recordSchema();    GenericRecordBuilder builder = new GenericRecordBuilder(schema);        for (Field field : schema.getFields()) {        Assert.assertFalse("RecordBuilder should not have field " + field.name(), builder.has(field.name()));        Assert.assertNull("Field " + field.name() + " should be null", builder.get(field.name()));    }        builder.set("intField", 1);    List<String> anArray = Arrays.asList("one", "two", "three");    builder.set("anArray", anArray);    Assert.assertTrue("anArray should be set", builder.has("anArray"));    Assert.assertEquals(anArray, builder.get("anArray"));    Assert.assertFalse("id should not be set", builder.has("id"));    Assert.assertNull(builder.get("id"));        Record record = builder.build();    Assert.assertEquals(1, record.get("intField"));    Assert.assertEquals(anArray, record.get("anArray"));    Assert.assertNotNull(record.get("id"));    Assert.assertEquals("0", record.get("id").toString());        Assert.assertEquals(builder, new GenericRecordBuilder(builder));    Assert.assertEquals(record, new GenericRecordBuilder(record).build());        builder.clear("intField");    Assert.assertFalse(builder.has("intField"));    Assert.assertNull(builder.get("intField"));}
ed0682c387eaec05aa8a5bb81e7a12793e1aca4faeee372e329464a70731b29b
attemptToSetNonNullableFieldToNull
public void attemptToSetNonNullableFieldToNull()
{    new GenericRecordBuilder(recordSchema()).set("intField", null);}
dd4ccb789ab17bbb505c5299de279807183d91777351cce848c98417fb8bd309
buildWithoutSettingRequiredFields1
public void buildWithoutSettingRequiredFields1()
{    new GenericRecordBuilder(recordSchema()).build();}
e6a80493b8b0eff98b004dbfb2c1a8bf6fe810f521adc4433afe35dae892c612
buildWithoutSettingRequiredFields2
public void buildWithoutSettingRequiredFields2()
{    try {        new GenericRecordBuilder(recordSchema()).set("anArray", Collections.singletonList("one")).build();        Assert.fail("Should have thrown " + AvroRuntimeException.class.getCanonicalName());    } catch (AvroRuntimeException e) {        Assert.assertTrue(e.getMessage().contains("intField"));    }}
726442c5225063f2a129f664caee4a4d84fbf364acc5c8284cdf185d2031ff9d
recordSchema
private static Schema recordSchema()
{    List<Field> fields = new ArrayList<>();    fields.add(new Field("id", Schema.create(Type.STRING), null, "0"));    fields.add(new Field("intField", Schema.create(Type.INT), null, null));    fields.add(new Field("anArray", Schema.createArray(Schema.create(Type.STRING)), null, null));    fields.add(new Field("optionalInt", Schema.createUnion(Arrays.asList(Schema.create(Type.NULL), Schema.create(Type.INT))), null, Schema.NULL_VALUE));    Schema schema = Schema.createRecord("Foo", "test", "mytest", false);    schema.setFields(fields);    return schema;}
45117364ffa829e9c40ce60f5e26913ca8a73f3277b163a4bb8a24bd1b7e1b0a
write
public void write(ByteBuffer bytes) throws IOException
{    encodeLong(bytes.remaining(), out);    out.write(bytes.array(), bytes.position(), bytes.remaining());}
c3e67ec76f1b008887f1caba645a2614900cde6e477acca1bc3ecc36bf357fcf
flush
public void flush() throws IOException
{    if (out != null) {        out.flush();    }}
07c3270fe1b73532e66eb6f555ff312e3202b8435cf61382c5aa1c0dc4ce9a22
writeNull
public void writeNull() throws IOException
{}
9d2c4a8e17244c43f6c9a688d920b81cfa21c5d72f09e261b40e4539894a93a4
writeBoolean
public void writeBoolean(boolean b) throws IOException
{    out.write(b ? 1 : 0);}
3d8eb176faa04ef3aa5f28bd1c308daf64cdee2071894b3447ade0d0891ac95b
writeInt
public void writeInt(int n) throws IOException
{    encodeLong(n, out);}
9d5f02c473bb90aaa95e11d7e93625ba8050b2ae1b4b94e45331333ecc81fb92
writeLong
public void writeLong(long n) throws IOException
{    encodeLong(n, out);}
485832ef5d131a3779da1c259796c40decbe270ca77fd7c3bd67453210649270
writeFloat
public void writeFloat(float f) throws IOException
{    encodeFloat(f, out);}
b0e7b254d45c2210c8fda5ed2caaef6ca76fec51fb5d6a536add22a8a39ae5e9
writeDouble
public void writeDouble(double d) throws IOException
{    encodeDouble(d, out);}
34bdbb4029a48cb89270af40e256732c5b672fb11b54336d3f7efc90b7df5ab2
writeString
public void writeString(Utf8 utf8) throws IOException
{    encodeString(utf8.getBytes(), 0, utf8.getByteLength());}
96bc6a095954cfd9254d26f959f52e92cd7b9fee81a771dc57d7d1d251dd6db8
writeString
public void writeString(String string) throws IOException
{    byte[] bytes = Utf8.getBytesFor(string);    encodeString(bytes, 0, bytes.length);}
f33903203d9bc65266eb3d65a626811a5b96ad88019d3b2c73fda57cb74b63d3
encodeString
private void encodeString(byte[] bytes, int offset, int length) throws IOException
{    encodeLong(length, out);    out.write(bytes, offset, length);}
ef77a45285e12605fa0ac332653126204dbd8aeb25f392f6b9900d3df7110e24
writeBytes
public void writeBytes(ByteBuffer bytes) throws IOException
{    byteWriter.write(bytes);}
5686b3aa744852e31cb4ae1e0044e20a94ff28b7620cb59b1eb1a47c8ef69565
writeBytes
public void writeBytes(byte[] bytes, int start, int len) throws IOException
{    encodeLong(len, out);    out.write(bytes, start, len);}
23ad82833b3f2bd0c47b14f7e1f984068754ba8fea96d9cf72a5dc7b0df27779
writeFixed
public void writeFixed(byte[] bytes, int start, int len) throws IOException
{    out.write(bytes, start, len);}
9c2c1c74b0f6ed303f5a2809268552b5b4c2121bcc71b39f52e22e9cfb232cc6
writeEnum
public void writeEnum(int e) throws IOException
{    encodeLong(e, out);}
397b6502072ea3a1ac72a07bee65a462902e7e78c46d167fac7946bd2eee93fb
writeArrayStart
public void writeArrayStart() throws IOException
{}
b85783ea95d3093dd3e304d9bd3da87a2a232aaf24ea3f4113e86bf54caa8ad5
setItemCount
public void setItemCount(long itemCount) throws IOException
{    if (itemCount > 0) {        writeLong(itemCount);    }}
bed0009bb8139bc1ffb6ee9ad42162880141e39749c278e1724abb291a79cd42
startItem
public void startItem() throws IOException
{}
ed98fbed6a1d613e764dba378ccb5b19a641d3ecbc93a5f3d50f0010442034de
writeArrayEnd
public void writeArrayEnd() throws IOException
{    encodeLong(0, out);}
06a13fe57e24d2460afd3389759c84bd57ee09e14710364b77d081005edff6eb
writeMapStart
public void writeMapStart() throws IOException
{}
44f6ecf1e519c8992d2b321f4cf40cfe49a47d580d58e41fd28fe573a1ea47c4
writeMapEnd
public void writeMapEnd() throws IOException
{    encodeLong(0, out);}
5e98b24f5d4da4c35f9e7f9247f0fdca1daf147afc1971fff5a25067084cf67d
writeIndex
public void writeIndex(int unionIndex) throws IOException
{    encodeLong(unionIndex, out);}
4b8a30be77c5d449529b6d301525c51b3641aad932b6fd14f4f3465684169925
encodeLong
protected static void encodeLong(long n, OutputStream o) throws IOException
{        n = (n << 1) ^ (n >> 63);    while ((n & ~0x7F) != 0) {        o.write((byte) ((n & 0x7f) | 0x80));        n >>>= 7;    }    o.write((byte) n);}
f28a0df370c66d420d145677f8953f5b80bacdf6e9c37daaff3a9a687250024a
encodeFloat
protected static void encodeFloat(float f, OutputStream o) throws IOException
{    long bits = Float.floatToRawIntBits(f);    o.write((int) (bits) & 0xFF);    o.write((int) (bits >> 8) & 0xFF);    o.write((int) (bits >> 16) & 0xFF);    o.write((int) (bits >> 24) & 0xFF);}
f378abf789fb3751fb0e3af2a0d5716fc91f8701a2cef5a3ebc4b994fc108a72
encodeDouble
protected static void encodeDouble(double d, OutputStream o) throws IOException
{    long bits = Double.doubleToRawLongBits(d);    o.write((int) (bits) & 0xFF);    o.write((int) (bits >> 8) & 0xFF);    o.write((int) (bits >> 16) & 0xFF);    o.write((int) (bits >> 24) & 0xFF);    o.write((int) (bits >> 32) & 0xFF);    o.write((int) (bits >> 40) & 0xFF);    o.write((int) (bits >> 48) & 0xFF);    o.write((int) (bits >> 56) & 0xFF);}
856b14682ce9710c336c58cd5f18ca341d2f7002aebc01c61cad557b80bf5484
testSomeMethod
public void testSomeMethod() throws IOException
{    Schema schema = new Schema.Parser().parse(SCHEMA);    Symbol root = new ResolvingGrammarGenerator().generate(schema, schema);    validateNonNull(root, new HashSet<>());}
35ba92e6f04024d2430b6cc8dd93f457cc336db56b01bda66791d9320343ac6d
validateNonNull
private static void validateNonNull(final Symbol symb, Set<Symbol> seen)
{    if (seen.contains(symb)) {        return;    } else {        seen.add(symb);    }    if (symb.production != null) {        for (Symbol s : symb.production) {            if (s == null) {                fail("invalid parsing tree should not contain nulls");            }            if (s.kind != Symbol.Kind.ROOT) {                validateNonNull(s, seen);            }        }    }}
a2a314ef22554dd92e27423b4f2d7f98b9f605698c00bf86585d1f2c50b7ab22
test
public void test() throws IOException
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    EncoderFactory factory = EncoderFactory.get();    Encoder e = factory.validatingEncoder(schema, factory.binaryEncoder(baos, null));    ResolvingGrammarGenerator.encode(e, schema, data);    e.flush();}
9d9d5145fa5fa846f2f6413da00e006504cc8d10938a01d9efcb94ef68dfd526
testRecordMissingRequiredFieldError
public void testRecordMissingRequiredFieldError() throws Exception
{    Schema schemaWithoutField = SchemaBuilder.record("MyRecord").namespace("ns").fields().name("field1").type().stringType().noDefault().endRecord();    Schema schemaWithField = SchemaBuilder.record("MyRecord").namespace("ns").fields().name("field1").type().stringType().noDefault().name("field2").type().stringType().noDefault().endRecord();    GenericData.Record record = new GenericRecordBuilder(schemaWithoutField).set("field1", "someValue").build();    byte[] data = writeRecord(schemaWithoutField, record);    try {        readRecord(schemaWithField, data);        Assert.fail("Expected exception not thrown");    } catch (AvroTypeException typeException) {        Assert.assertEquals("Incorrect exception message", "Found ns.MyRecord, expecting ns.MyRecord, missing required field field2", typeException.getMessage());    }}
e159cd20e5d846e508be922f0450be0db638ed2ba32c3229ae07c0ea68938d77
data
public static Collection<Object[]> data()
{    Collection<Object[]> ret = Arrays.asList(new Object[][] { { "{ \"type\": \"record\", \"name\": \"r\", \"fields\": [ " + " { \"name\" : \"f1\", \"type\": \"int\" }, " + " { \"name\" : \"f2\", \"type\": \"float\" } " + "] } }", "{ \"f2\": 10.4, \"f1\": 10 } " }, { "{ \"type\": \"enum\", \"name\": \"e\", \"symbols\": " + "[ \"s1\", \"s2\"] } }", " \"s1\" " }, { "{ \"type\": \"enum\", \"name\": \"e\", \"symbols\": " + "[ \"s1\", \"s2\"] } }", " \"s2\" " }, { "{ \"type\": \"fixed\", \"name\": \"f\", \"size\": 10 }", "\"hello\"" }, { "{ \"type\": \"array\", \"items\": \"int\" }", "[ 10, 20, 30 ]" }, { "{ \"type\": \"map\", \"values\": \"int\" }", "{ \"k1\": 10, \"k3\": 20, \"k3\": 30 }" }, { "[ \"int\", \"long\" ]", "10" }, { "\"string\"", "\"hello\"" }, { "\"bytes\"", "\"hello\"" }, { "\"int\"", "10" }, { "\"long\"", "10" }, { "\"float\"", "10.0" }, { "\"double\"", "10.0" }, { "\"boolean\"", "true" }, { "\"boolean\"", "false" }, { "\"null\"", "null" } });    return ret;}
74e09b66d4ab87892dc49ed8e50f48beee4395807f86410aa785dab77c0098c7
writeRecord
private byte[] writeRecord(Schema schema, GenericData.Record record) throws Exception
{    ByteArrayOutputStream byteStream = new ByteArrayOutputStream();    GenericDatumWriter<GenericData.Record> datumWriter = new GenericDatumWriter<>(schema);    try (DataFileWriter<GenericData.Record> writer = new DataFileWriter<>(datumWriter)) {        writer.create(schema, byteStream);        writer.append(record);    }    return byteStream.toByteArray();}
c0175b78359536ab31175924f01aebf16cc6606ceed957905fd1e5598f4ea436
readRecord
private GenericData.Record readRecord(Schema schema, byte[] data) throws Exception
{    ByteArrayInputStream byteStream = new ByteArrayInputStream(data);    GenericDatumReader<GenericData.Record> datumReader = new GenericDatumReader<>(schema);    try (DataFileStream<GenericData.Record> reader = new DataFileStream<>(byteStream, datumReader)) {        return reader.next();    }}
525cf606894c4cd9dad9d8fd00319c6522163395b69878ee82a90dd7879a586a
testFixed
public void testFixed() throws java.io.IOException
{    new ResolvingGrammarGenerator().generate(Schema.createFixed("MyFixed", null, null, 10), Schema.create(Schema.Type.BYTES));    new ResolvingGrammarGenerator().generate(Schema.create(Schema.Type.BYTES), Schema.createFixed("MyFixed", null, null, 10));}
21ee584bbc0ac1d1a5c7b8464d9da3a81e588ff59b21b48c32b00e21056a6dce
testUnionResolutionNoStructureMatch
public void testUnionResolutionNoStructureMatch() throws Exception
{        Schema read = Schema.createUnion(Arrays.asList(Schema.create(Schema.Type.NULL), point3dNoDefault));    new SchemaValidatorBuilder().canBeReadStrategy().validateAll().validate(point2dFullname, Collections.singletonList(read));}
615e3e1a4f4cd1ee84d3ca8675a80fa6df77b529b3509df134379aa9e08123c4
testUnionResolutionFirstStructureMatch2d
public void testUnionResolutionFirstStructureMatch2d() throws Exception
{        Schema read = Schema.createUnion(Arrays.asList(Schema.create(Schema.Type.NULL), point3dNoDefault, point2d, point3d));    Symbol grammar = new ResolvingGrammarGenerator().generate(point2dFullname, read);    Assert.assertTrue(grammar.production[1] instanceof Symbol.UnionAdjustAction);    Symbol.UnionAdjustAction action = (Symbol.UnionAdjustAction) grammar.production[1];    Assert.assertEquals(2, action.rindex);}
86e1e50f65a44cfcbc664552c4d817bfb8cd05f67fa74f23f75b4f4ff51a45d4
testUnionResolutionFirstStructureMatch3d
public void testUnionResolutionFirstStructureMatch3d() throws Exception
{        Schema read = Schema.createUnion(Arrays.asList(Schema.create(Schema.Type.NULL), point3dNoDefault, point3d, point2d));    Symbol grammar = new ResolvingGrammarGenerator().generate(point2dFullname, read);    Assert.assertTrue(grammar.production[1] instanceof Symbol.UnionAdjustAction);    Symbol.UnionAdjustAction action = (Symbol.UnionAdjustAction) grammar.production[1];    Assert.assertEquals(2, action.rindex);}
9f4ddf0a942a27b4a04b36f886c1f793c704666d17c7e53b65fb2a4eed79cdcb
testUnionResolutionNamedStructureMatch
public void testUnionResolutionNamedStructureMatch() throws Exception
{        Schema read = Schema.createUnion(Arrays.asList(Schema.create(Schema.Type.NULL), point2d, point3dMatchName, point3d));    Symbol grammar = new ResolvingGrammarGenerator().generate(point2dFullname, read);    Assert.assertTrue(grammar.production[1] instanceof Symbol.UnionAdjustAction);    Symbol.UnionAdjustAction action = (Symbol.UnionAdjustAction) grammar.production[1];    Assert.assertEquals(2, action.rindex);}
0afbfc2264ba70969b9936d2451fd5dedf01ff3b2582caae468f5d1f7211f594
testUnionResolutionFullNameMatch
public void testUnionResolutionFullNameMatch() throws Exception
{        Schema read = Schema.createUnion(Arrays.asList(Schema.create(Schema.Type.NULL), point2d, point3dMatchName, point3d, point2dFullname));    Symbol grammar = new ResolvingGrammarGenerator().generate(point2dFullname, read);    Assert.assertTrue(grammar.production[1] instanceof Symbol.UnionAdjustAction);    Symbol.UnionAdjustAction action = (Symbol.UnionAdjustAction) grammar.production[1];    Assert.assertEquals(4, action.rindex);}
e159cd20e5d846e508be922f0450be0db638ed2ba32c3229ae07c0ea68938d77
data
public static Collection<Object[]> data()
{    return Arrays.asList(new Object[][] { { true }, { false } });}
35a62c0c6c360858b95a529045e64c6aaabc4885b6adc466176f95c407d17819
newDecoderWithNoData
private Decoder newDecoderWithNoData() throws IOException
{    return newDecoder(new byte[0]);}
1a9fdcc97250d43e980c37f8a0ca1a0965141a326308068f2254702c7c24c6f3
newDecoder
private Decoder newDecoder(byte[] bytes, int start, int len) throws IOException
{    return factory.binaryDecoder(bytes, start, len, null);}
b33047a62fce2ce895fdcbe01c6c66f0e9e5e62dc53e8bcb88379b9cfded454f
newDecoder
private Decoder newDecoder(InputStream in)
{    if (useDirect) {        return factory.directBinaryDecoder(in, null);    } else {        return factory.binaryDecoder(in, null);    }}
53db2d34f65a29e3325f6ac2f6b75803d665f06e42677ea4eb89250de442aaa2
newDecoder
private Decoder newDecoder(byte[] bytes) throws IOException
{    return factory.binaryDecoder(bytes, null);}
796b7f1ff4a2839228c32b441ed942fcf62e4b7b86091aa709e518ae1dc4fcfa
testEOFBoolean
public void testEOFBoolean() throws IOException
{    newDecoderWithNoData().readBoolean();}
9afaf38b3895728d04a4a574e3f15801d5ae7014ad3d9ec4779da8786ea37859
testEOFInt
public void testEOFInt() throws IOException
{    newDecoderWithNoData().readInt();}
6c74a6d49357a9f3f935706543c15a157d21f54661886daf3a8376ee228ac309
testEOFLong
public void testEOFLong() throws IOException
{    newDecoderWithNoData().readLong();}
cdef98a78ca36f3c6d5c5291643508eda15f30b9125d954755d2e24c20719f6f
testEOFFloat
public void testEOFFloat() throws IOException
{    newDecoderWithNoData().readFloat();}
4a3a1f9576df1c8da191047b72fa882d9614b0c05211f79d9788ced92ff1c33a
testEOFDouble
public void testEOFDouble() throws IOException
{    newDecoderWithNoData().readDouble();}
0ce2219288853b0ae96c5d156ef7e182157d6671701074d9cc813192afa33e6c
testEOFBytes
public void testEOFBytes() throws IOException
{    newDecoderWithNoData().readBytes(null);}
b6e4857d6057633c961a73babac376a8b741f941c27608eb10249b807bf21243
testEOFString
public void testEOFString() throws IOException
{    newDecoderWithNoData().readString(new Utf8("a"));}
d40c94c11ae12b0dddd85233922fbe92ee20e93a69f340aed29e6cec7093a779
testEOFFixed
public void testEOFFixed() throws IOException
{    newDecoderWithNoData().readFixed(new byte[1]);}
6d50d352c05928ee462f8e5430b5cae0b766586191eb94e9bd31a3e358079b7c
testEOFEnum
public void testEOFEnum() throws IOException
{    newDecoderWithNoData().readEnum();}
43015d97f2e46c75cfe46d9740b2a94f9dad1ccc3b938c3efd821c65ae45892c
testReuse
public void testReuse() throws IOException
{    ByteBufferOutputStream bbo1 = new ByteBufferOutputStream();    ByteBufferOutputStream bbo2 = new ByteBufferOutputStream();    byte[] b1 = new byte[] { 1, 2 };    BinaryEncoder e1 = e_factory.binaryEncoder(bbo1, null);    e1.writeBytes(b1);    e1.flush();    BinaryEncoder e2 = e_factory.binaryEncoder(bbo2, null);    e2.writeBytes(b1);    e2.flush();    DirectBinaryDecoder d = new DirectBinaryDecoder(new ByteBufferInputStream(bbo1.getBufferList()));    ByteBuffer bb1 = d.readBytes(null);    Assert.assertEquals(b1.length, bb1.limit() - bb1.position());    d.configure(new ByteBufferInputStream(bbo2.getBufferList()));    ByteBuffer bb2 = d.readBytes(null);    Assert.assertEquals(b1.length, bb2.limit() - bb2.position());}
c653a9806821b6c73237ebb656cbb15992f8a0f87bff3388bf62cab54323c383
generateData
public static void generateData() throws IOException
{    int seed = (int) System.currentTimeMillis();        String jsonSchema = "{\"type\": \"record\", \"name\": \"Test\", \"fields\": [" + "{\"name\":\"intField\", \"type\":\"int\"}," + "{\"name\":\"bytesField\", \"type\":\"bytes\"}," + "{\"name\":\"booleanField\", \"type\":\"boolean\"}," + "{\"name\":\"stringField\", \"type\":\"string\"}," + "{\"name\":\"floatField\", \"type\":\"float\"}," + "{\"name\":\"doubleField\", \"type\":\"double\"}," + "{\"name\":\"arrayField\", \"type\": " + "{\"type\":\"array\", \"items\":\"boolean\"}}," + "{\"name\":\"longField\", \"type\":\"long\"}]}";    schema = new Schema.Parser().parse(jsonSchema);    GenericDatumWriter<Object> writer = new GenericDatumWriter<>();    writer.setSchema(schema);    ByteArrayOutputStream baos = new ByteArrayOutputStream(8192);    BinaryEncoder encoder = e_factory.binaryEncoder(baos, null);    for (Object datum : new RandomData(schema, count, seed)) {        writer.write(datum, encoder);        records.add(datum);    }    encoder.flush();    data = baos.toByteArray();}
0b2092b4963e4a6a63ea413e4045933a208ecdc3e4cee26709f51e79e09d3889
testDecodeFromSources
public void testDecodeFromSources() throws IOException
{    GenericDatumReader<Object> reader = new GenericDatumReader<>();    reader.setSchema(schema);    ByteArrayInputStream is = new ByteArrayInputStream(data);    ByteArrayInputStream is2 = new ByteArrayInputStream(data);    ByteArrayInputStream is3 = new ByteArrayInputStream(data);    Decoder fromInputStream = newDecoder(is);    Decoder fromArray = newDecoder(data);    byte[] data2 = new byte[data.length + 30];    Arrays.fill(data2, (byte) 0xff);    System.arraycopy(data, 0, data2, 15, data.length);    Decoder fromOffsetArray = newDecoder(data2, 15, data.length);    BinaryDecoder initOnInputStream = factory.binaryDecoder(new byte[50], 0, 30, null);    initOnInputStream = factory.binaryDecoder(is2, initOnInputStream);    BinaryDecoder initOnArray = factory.binaryDecoder(is3, null);    initOnArray = factory.binaryDecoder(data, 0, data.length, initOnArray);    for (Object datum : records) {        Assert.assertEquals("InputStream based BinaryDecoder result does not match", datum, reader.read(null, fromInputStream));        Assert.assertEquals("Array based BinaryDecoder result does not match", datum, reader.read(null, fromArray));        Assert.assertEquals("offset Array based BinaryDecoder result does not match", datum, reader.read(null, fromOffsetArray));        Assert.assertEquals("InputStream initialized BinaryDecoder result does not match", datum, reader.read(null, initOnInputStream));        Assert.assertEquals("Array initialized BinaryDecoder result does not match", datum, reader.read(null, initOnArray));    }}
a575eab215b883629a71bd014be83762ba21388721973e86f968ca61b6be261d
testInputStreamProxy
public void testInputStreamProxy() throws IOException
{    Decoder d = newDecoder(data);    if (d instanceof BinaryDecoder) {        BinaryDecoder bd = (BinaryDecoder) d;        InputStream test = bd.inputStream();        InputStream check = new ByteArrayInputStream(data);        validateInputStreamReads(test, check);        bd = factory.binaryDecoder(data, bd);        test = bd.inputStream();        check = new ByteArrayInputStream(data);        validateInputStreamSkips(test, check);                bd = factory.binaryDecoder(new ByteArrayInputStream(data), bd);        test = bd.inputStream();        check = new ByteArrayInputStream(data);        validateInputStreamReads(test, check);        bd = factory.binaryDecoder(new ByteArrayInputStream(data), bd);        test = bd.inputStream();        check = new ByteArrayInputStream(data);        validateInputStreamSkips(test, check);    }}
cf8cc73ef8215e2fd659d05c7c3a0e57e3b50bdcc545e09f519d1b6b73a4a6ea
testInputStreamProxyDetached
public void testInputStreamProxyDetached() throws IOException
{    Decoder d = newDecoder(data);    if (d instanceof BinaryDecoder) {        BinaryDecoder bd = (BinaryDecoder) d;        InputStream test = bd.inputStream();        InputStream check = new ByteArrayInputStream(data);                factory.binaryDecoder(new byte[56], null);        InputStream bad = bd.inputStream();        InputStream check2 = new ByteArrayInputStream(data);        validateInputStreamReads(test, check);        Assert.assertFalse(bad.read() == check2.read());    }}
e3c51c349624e2f07073ab9274fa255e912cfe35260060d09c596afc3d5cef21
testInputStreamPartiallyUsed
public void testInputStreamPartiallyUsed() throws IOException
{    BinaryDecoder bd = factory.binaryDecoder(new ByteArrayInputStream(data), null);    InputStream test = bd.inputStream();    InputStream check = new ByteArrayInputStream(data);        try {        Assert.assertFalse(bd.isEnd());    } catch (UnsupportedOperationException e) {                if (bd.getClass() != DirectBinaryDecoder.class) {            throw e;        }    }        bd.readFloat();        check.skip(4);    validateInputStreamReads(test, check);}
896fa484a0a584c5cce03891facdd54393b7b458f1d3941b83b3c52ed7c6f331
validateInputStreamReads
private void validateInputStreamReads(InputStream test, InputStream check) throws IOException
{    byte[] bt = new byte[7];    byte[] bc = new byte[7];    while (true) {        int t = test.read();        int c = check.read();        Assert.assertEquals(c, t);        if (-1 == t)            break;        t = test.read(bt);        c = check.read(bc);        Assert.assertEquals(c, t);        Assert.assertArrayEquals(bt, bc);        if (-1 == t)            break;        t = test.read(bt, 1, 4);        c = check.read(bc, 1, 4);        Assert.assertEquals(c, t);        Assert.assertArrayEquals(bt, bc);        if (-1 == t)            break;    }    Assert.assertEquals(0, test.skip(5));    Assert.assertEquals(0, test.available());    Assert.assertFalse(test.getClass() != ByteArrayInputStream.class && test.markSupported());    test.close();}
670a9ba4ceca44e5ab21b1634a8b89622b8be62d48da927a2cd76b11dfc1efb7
validateInputStreamSkips
private void validateInputStreamSkips(InputStream test, InputStream check) throws IOException
{    while (true) {        long t2 = test.skip(19);        long c2 = check.skip(19);        Assert.assertEquals(c2, t2);        if (0 == t2)            break;    }    Assert.assertEquals(-1, test.read());}
3011024c2c314b2520ccd2244eae2c08f6a2db2d42c6e3f769c30514191002e5
testBadIntEncoding
public void testBadIntEncoding() throws IOException
{    byte[] badint = new byte[5];    Arrays.fill(badint, (byte) 0xff);    Decoder bd = factory.binaryDecoder(badint, null);    String message = "";    try {        bd.readInt();    } catch (IOException ioe) {        message = ioe.getMessage();    }    Assert.assertEquals("Invalid int encoding", message);}
5d39666262584a0e16c559a1557c6f13c8294eac3e06491735093f42ae8f55a2
testBadLongEncoding
public void testBadLongEncoding() throws IOException
{    byte[] badint = new byte[10];    Arrays.fill(badint, (byte) 0xff);    Decoder bd = factory.binaryDecoder(badint, null);    String message = "";    try {        bd.readLong();    } catch (IOException ioe) {        message = ioe.getMessage();    }    Assert.assertEquals("Invalid long encoding", message);}
d5259d7915178663116bc74ec950fa4233b30e6c345a9a90d557cfd2da09e0e3
testNegativeLengthEncoding
public void testNegativeLengthEncoding() throws IOException
{    byte[] bad = new byte[] { (byte) 1 };    Decoder bd = factory.binaryDecoder(bad, null);    String message = "";    try {        bd.readString();    } catch (AvroRuntimeException e) {        message = e.getMessage();    }    Assert.assertEquals("Malformed data. Length is negative: -1", message);}
1213a8ad5f1f0de1886effe63521ac9807af0c32fc53521057495ed21bef62a4
testLongLengthEncoding
public void testLongLengthEncoding() throws IOException
{        byte[] bad = new byte[] { (byte) -128, (byte) -128, (byte) -128, (byte) -128, (byte) 16 };    Decoder bd = factory.binaryDecoder(bad, null);    bd.readString();}
01fe91d877e1ecd312921fcf193355b427a180e6cdc987405ee22b1c41165415
testIntTooShort
public void testIntTooShort() throws IOException
{    byte[] badint = new byte[4];    Arrays.fill(badint, (byte) 0xff);    newDecoder(badint).readInt();}
3454f14d5328112a19b341274583d0864f8cffb8d4586e46a0e960547286a87c
testLongTooShort
public void testLongTooShort() throws IOException
{    byte[] badint = new byte[9];    Arrays.fill(badint, (byte) 0xff);    newDecoder(badint).readLong();}
9828016748912074e5215cac2cdb8e74b950ec1f079b7a3cec3f2505b30ec40e
testFloatTooShort
public void testFloatTooShort() throws IOException
{    byte[] badint = new byte[3];    Arrays.fill(badint, (byte) 0xff);    newDecoder(badint).readInt();}
ac4001db9b44a20b4e14fd973d5ae8f2b15c0b5ef49c78d6b57338f374bce45d
testDoubleTooShort
public void testDoubleTooShort() throws IOException
{    byte[] badint = new byte[7];    Arrays.fill(badint, (byte) 0xff);    newDecoder(badint).readLong();}
45a36642bb33c476c389e93e349ad1917f9a580d543b51032e3bcd015e8cfa2a
testSkipping
public void testSkipping() throws IOException
{    Decoder d = newDecoder(data);    skipGenerated(d);    if (d instanceof BinaryDecoder) {        BinaryDecoder bd = (BinaryDecoder) d;        try {            Assert.assertTrue(bd.isEnd());        } catch (UnsupportedOperationException e) {                        if (bd.getClass() != DirectBinaryDecoder.class) {                throw e;            }        }        bd = factory.binaryDecoder(new ByteArrayInputStream(data), bd);        skipGenerated(bd);        try {            Assert.assertTrue(bd.isEnd());        } catch (UnsupportedOperationException e) {                        if (bd.getClass() != DirectBinaryDecoder.class) {                throw e;            }        }    }}
e696d7db33b6adf3dc3421d6c673123b29d9c96acc3d4e2860a2742eb9e447fd
skipGenerated
private void skipGenerated(Decoder bd) throws IOException
{    for (int i = 0; i < records.size(); i++) {        bd.readInt();        bd.skipBytes();        bd.skipFixed(1);        bd.skipString();        bd.skipFixed(4);        bd.skipFixed(8);        long leftover = bd.skipArray();                bd.skipFixed((int) leftover + 1);        bd.skipFixed(0);        bd.readLong();    }    EOFException eof = null;    try {        bd.skipFixed(4);    } catch (EOFException e) {        eof = e;    }    Assert.assertTrue(null != eof);}
c1fe4d3d75f7f30db39cb1c329e3c120e305d0bded3dbfdf8a151e1e47af3d71
testEOF
public void testEOF() throws IOException
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    Encoder e = EncoderFactory.get().binaryEncoder(baos, null);    e.writeLong(0x10000000000000L);    e.flush();    Decoder d = newDecoder(new ByteArrayInputStream(baos.toByteArray()));    Assert.assertEquals(0x10000000000000L, d.readLong());    d.readInt();}
d75ec8d64a3abdc2ea962d1583b60cc48dcf4ec20e4f04573c1c90efab9ff029
generateData
public static void generateData(Encoder e, boolean useReadOnlyByteBuffer) throws IOException
{        Random r = new Random(665321);    e.writeNull();    e.writeBoolean(true);    e.writeBoolean(false);    byte[] bytes = new byte[10];    ByteBuffer bb;    if (useReadOnlyByteBuffer) {        bb = ByteBuffer.wrap(bytes, 4, 4).asReadOnlyBuffer();    } else {        bb = ByteBuffer.wrap(bytes, 4, 4);    }    r.nextBytes(bytes);    e.writeBytes(bytes);    e.writeBytes(new byte[0]);    e.writeBytes(bytes, 3, 3);    e.writeBytes(new byte[0], 0, 0);    e.writeBytes(ByteBuffer.wrap(bytes, 2, 2));    e.writeBytes(bb);    e.writeBytes(bb);    e.writeDouble(0.0);    e.writeDouble(-0.0);    e.writeDouble(Double.NaN);    e.writeDouble(r.nextDouble());    e.writeDouble(Double.NEGATIVE_INFINITY);    e.writeEnum(65);    e.writeFixed(bytes);    e.writeFixed(bytes, 7, 2);    e.writeFloat(1.0f);    e.writeFloat(r.nextFloat());    e.writeFloat(Float.POSITIVE_INFINITY);    e.writeFloat(Float.MIN_NORMAL);    e.writeIndex(-2);    e.writeInt(0);    e.writeInt(-1);    e.writeInt(1);    e.writeInt(0x40);    e.writeInt(-0x41);    e.writeInt(0x2000);    e.writeInt(-0x2001);    e.writeInt(0x80000);    e.writeInt(-0x80001);    e.writeInt(0x4000000);    e.writeInt(-0x4000001);    e.writeInt(r.nextInt());    e.writeInt(r.nextInt());    e.writeInt(Integer.MAX_VALUE);    e.writeInt(Integer.MIN_VALUE);    e.writeLong(0);    e.writeLong(-1);    e.writeLong(1);    e.writeLong(0x40);    e.writeLong(-0x41);    e.writeLong(0x2000);    e.writeLong(-0x2001);    e.writeLong(0x80000);    e.writeLong(-0x80001);    e.writeLong(0x4000000);    e.writeLong(-0x4000001);    e.writeLong(0x200000000L);    e.writeLong(-0x200000001L);    e.writeLong(0x10000000000L);    e.writeLong(-0x10000000001L);    e.writeLong(0x800000000000L);    e.writeLong(-0x800000000001L);    e.writeLong(0x40000000000000L);    e.writeLong(-0x40000000000001L);    e.writeLong(0x2000000000000000L);    e.writeLong(-0x2000000000000001L);    e.writeLong(r.nextLong());    e.writeLong(r.nextLong());    e.writeLong(Long.MAX_VALUE);    e.writeLong(Long.MIN_VALUE);    e.writeString(new StringBuilder("StringBuilder\u00A2"));    e.writeString("String\u20AC");    e.writeString("");    e.writeString(new Utf8("Utf8\uD834\uDD1E"));    if (e instanceof BinaryEncoder) {        int count = ((BinaryEncoder) e).bytesBuffered();        System.out.println(e.getClass().getSimpleName() + " buffered: " + count);    }    e.flush();}
bd37f66a80951ab2490a84511177ea791938c189bae14fac948351d95e7d8916
generateComplexData
 static void generateComplexData(Encoder e) throws IOException
{    e.writeArrayStart();    e.setItemCount(1);    e.startItem();    e.writeInt(1);    e.writeArrayEnd();    e.writeMapStart();    e.setItemCount(2);    e.startItem();    e.writeString("foo");    e.writeInt(-1);    e.writeDouble(33.3);    e.startItem();    e.writeString("bar");    e.writeInt(1);    e.writeDouble(-33.3);    e.writeMapEnd();    e.flush();}
eac04fe6a81c8d89486ff1cca7841544fb818ee517c478685be92a1e9e5a57cd
generateLegacyData
public static void generateLegacyData() throws IOException
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    Encoder e = new LegacyBinaryEncoder(baos);    generateData(e, false);    legacydata = baos.toByteArray();    baos.reset();    generateComplexData(e);    complexdata = baos.toByteArray();}
5fb6c1717422efb633ebc4ac75093271a5dbf38052df9f62c1fff21b82ac43d5
testBinaryEncoder
public void testBinaryEncoder() throws IOException
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    BinaryEncoder e = factory.binaryEncoder(baos, null);    generateData(e, true);    byte[] result = baos.toByteArray();    Assert.assertEquals(legacydata.length, result.length);    Assert.assertArrayEquals(legacydata, result);    baos.reset();    generateComplexData(e);    byte[] result2 = baos.toByteArray();    Assert.assertEquals(complexdata.length, result2.length);    Assert.assertArrayEquals(complexdata, result2);}
28714df7dbd95b8ac31a1a729584385230ba6bb09f9d5abaa07a7d4982358967
testDirectBinaryEncoder
public void testDirectBinaryEncoder() throws IOException
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    BinaryEncoder e = factory.directBinaryEncoder(baos, null);    generateData(e, true);    byte[] result = baos.toByteArray();    Assert.assertEquals(legacydata.length, result.length);    Assert.assertArrayEquals(legacydata, result);    baos.reset();    generateComplexData(e);    byte[] result2 = baos.toByteArray();    Assert.assertEquals(complexdata.length, result2.length);    Assert.assertArrayEquals(complexdata, result2);}
b396167750093dabf6622010704215a3a8aeeabbee48542a70d018d6aaf63083
testBlockingBinaryEncoder
public void testBlockingBinaryEncoder() throws IOException
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    BinaryEncoder e = factory.blockingBinaryEncoder(baos, null);    generateData(e, true);    byte[] result = baos.toByteArray();    Assert.assertEquals(legacydata.length, result.length);    Assert.assertArrayEquals(legacydata, result);    baos.reset();    generateComplexData(e);    byte[] result2 = baos.toByteArray();        Assert.assertEquals(complexdata.length + 2, result2.length);        Assert.assertEquals(complexdata[0] >>> 1, result2[0]);}
752baddc9293fcf34e5d42c851d9429607415fc309a4101f1559b9a30c575bd1
scan
public void scan() throws IOException
{    ArrayDeque<S> countStack = new ArrayDeque<>();    long count = 0;    while (parser.nextToken() != null) {        switch(parser.getCurrentToken()) {            case END_ARRAY:                assertEquals(0, count);                assertTrue(countStack.peek().isArray);                count = countStack.pop().count;                break;            case END_OBJECT:                assertEquals(0, count);                assertFalse(countStack.peek().isArray);                count = countStack.pop().count;                break;            case START_ARRAY:                countStack.push(new S(count, true));                count = input.readArrayStart();                continue;            case VALUE_STRING:                {                    String s = parser.getText();                    int n = s.getBytes(StandardCharsets.UTF_8).length;                    checkString(s, input, n);                    break;                }            case FIELD_NAME:                {                    String s = parser.getCurrentName();                    int n = s.getBytes(StandardCharsets.UTF_8).length;                    checkString(s, input, n);                    continue;                }            case START_OBJECT:                countStack.push(new S(count, false));                count = input.readMapStart();                if (count < 0) {                    count = -count;                                        input.readLong();                }                continue;            default:                throw new RuntimeException("Unsupported: " + parser.getCurrentToken());        }        count--;        if (count == 0) {            count = countStack.peek().isArray ? input.arrayNext() : input.mapNext();        }    }}
c0871cf27d50a2708243f036cdd0653618dd659e6a04e19c776156f5df2d6dfa
skip
public void skip(int skipLevel) throws IOException
{    ArrayDeque<S> countStack = new ArrayDeque<>();    long count = 0;    while (parser.nextToken() != null) {        switch(parser.getCurrentToken()) {            case END_ARRAY:                                assertTrue(countStack.peek().isArray);                count = countStack.pop().count;                break;            case END_OBJECT:                                assertFalse(countStack.peek().isArray);                count = countStack.pop().count;                break;            case START_ARRAY:                if (countStack.size() == skipLevel) {                    skipArray(parser, input, depth - skipLevel);                    break;                } else {                    countStack.push(new S(count, true));                    count = input.readArrayStart();                    continue;                }            case VALUE_STRING:                {                    if (countStack.size() == skipLevel) {                        input.skipBytes();                    } else {                        String s = parser.getText();                        int n = s.getBytes(StandardCharsets.UTF_8).length;                        checkString(s, input, n);                    }                    break;                }            case FIELD_NAME:                {                    String s = parser.getCurrentName();                    int n = s.getBytes(StandardCharsets.UTF_8).length;                    checkString(s, input, n);                    continue;                }            case START_OBJECT:                if (countStack.size() == skipLevel) {                    skipMap(parser, input, depth - skipLevel);                    break;                } else {                    countStack.push(new S(count, false));                    count = input.readMapStart();                    if (count < 0) {                        count = -count;                                                input.readLong();                    }                    continue;                }            default:                throw new RuntimeException("Unsupported: " + parser.getCurrentToken());        }        count--;        if (count == 0) {            count = countStack.peek().isArray ? input.arrayNext() : input.mapNext();        }    }}
94bfd0b2184c18c641ae7454db1803143367547afda278017f042a4c0ea8f302
dump
protected static void dump(byte[] bb)
{    int col = 0;    for (byte b : bb) {        if (col % 16 == 0) {            System.out.println();        }        col++;        System.out.print(Integer.toHexString(b & 0xff) + " ");    }    System.out.println();}
ca7d48d6d1fdb05bf1a430a8f598249c2c84ef2a5dc404037a18eb0b048c4b70
testScan
public void testScan() throws IOException
{    Tests t = new Tests(iSize, iDepth, sInput);    t.scan();}
90fcf6878ec1cdccf11924a4108241a72a27d2b02c8abb6676fdaf13789be4f5
testSkip1
public void testSkip1() throws IOException
{    testSkip(iSize, iDepth, sInput, 0);}
7c1197800f0f91677b3f68b4b66b42040c9c6de6f58968951f69c56c72024cc9
testSkip2
public void testSkip2() throws IOException
{    testSkip(iSize, iDepth, sInput, 1);}
d49a6f15200f167dedbf0a3b840454fbd49d383dbe58d5f36d1c2abf337bf534
testSkip3
public void testSkip3() throws IOException
{    testSkip(iSize, iDepth, sInput, 2);}
f0ee58a2379c355335cb2f1cca6ae93782db2434791becce683a06eec386f3d6
testSkip
private void testSkip(int bufferSize, int depth, String input, int skipLevel) throws IOException
{    Tests t = new Tests(bufferSize, depth, input);    t.skip(skipLevel);}
fa4b063c124bb4365473524a25f3784c15cb6bcd8a733aed88ca4568d8d8a0f8
skipMap
private static void skipMap(JsonParser parser, Decoder input, int depth) throws IOException
{    for (long l = input.skipMap(); l != 0; l = input.skipMap()) {        for (long i = 0; i < l; i++) {            if (depth == 0) {                input.skipBytes();            } else {                skipArray(parser, input, depth - 1);            }        }    }    parser.skipChildren();}
c738021c6bbd805b18fa5bb39bb8fd76ae5c2c84bbc007089b1f77848b31c913
skipArray
private static void skipArray(JsonParser parser, Decoder input, int depth) throws IOException
{    for (long l = input.skipArray(); l != 0; l = input.skipArray()) {        for (long i = 0; i < l; i++) {            if (depth == 1) {                input.skipBytes();            } else {                skipArray(parser, input, depth - 1);            }        }    }    parser.skipChildren();}
8fad3a4d920f3dedaf142feea1ce05e42c7a247e7598d475df97f7c8d7b9ce84
checkString
private static void checkString(String s, Decoder input, int n) throws IOException
{    ByteBuffer buf = input.readBytes(null);    assertEquals(n, buf.remaining());    String s2 = new String(buf.array(), buf.position(), buf.remaining(), StandardCharsets.UTF_8);    assertEquals(s, s2);}
5a54ffdefb7264547c508f3921fb4dd20ab366b12e85f32c8358754c6c694250
serialize
private static void serialize(Encoder cos, JsonParser p, ByteArrayOutputStream os) throws IOException
{    boolean[] isArray = new boolean[100];    int[] counts = new int[100];    int stackTop = -1;    while (p.nextToken() != null) {        switch(p.getCurrentToken()) {            case END_ARRAY:                assertTrue(isArray[stackTop]);                cos.writeArrayEnd();                stackTop--;                break;            case END_OBJECT:                assertFalse(isArray[stackTop]);                cos.writeMapEnd();                stackTop--;                break;            case START_ARRAY:                if (stackTop >= 0 && isArray[stackTop]) {                    cos.setItemCount(1);                    cos.startItem();                    counts[stackTop]++;                }                cos.writeArrayStart();                isArray[++stackTop] = true;                counts[stackTop] = 0;                continue;            case VALUE_STRING:                if (stackTop >= 0 && isArray[stackTop]) {                    cos.setItemCount(1);                    cos.startItem();                    counts[stackTop]++;                }                byte[] bb = p.getText().getBytes(StandardCharsets.UTF_8);                cos.writeBytes(bb);                break;            case START_OBJECT:                if (stackTop >= 0 && isArray[stackTop]) {                    cos.setItemCount(1);                    cos.startItem();                    counts[stackTop]++;                }                cos.writeMapStart();                isArray[++stackTop] = false;                counts[stackTop] = 0;                continue;            case FIELD_NAME:                cos.setItemCount(1);                cos.startItem();                counts[stackTop]++;                cos.writeBytes(p.getCurrentName().getBytes(StandardCharsets.UTF_8));                break;            default:                throw new RuntimeException("Unsupported: " + p.getCurrentToken());        }    }}
e159cd20e5d846e508be922f0450be0db638ed2ba32c3229ae07c0ea68938d77
data
public static Collection<Object[]> data()
{    return Arrays.asList(new Object[][] { { 64, 0, "" }, { 64, 0, jss(0, 'a') }, { 64, 0, jss(3, 'a') }, { 64, 0, jss(64, 'a') }, { 64, 0, jss(65, 'a') }, { 64, 0, jss(100, 'a') }, { 64, 1, "[]" }, { 64, 1, "[" + jss(0, 'a') + "]" }, { 64, 1, "[" + jss(3, 'a') + "]" }, { 64, 1, "[" + jss(61, 'a') + "]" }, { 64, 1, "[" + jss(62, 'a') + "]" }, { 64, 1, "[" + jss(64, 'a') + "]" }, { 64, 1, "[" + jss(65, 'a') + "]" }, { 64, 1, "[" + jss(0, 'a') + "," + jss(0, '0') + "]" }, { 64, 1, "[" + jss(0, 'a') + "," + jss(10, '0') + "]" }, { 64, 1, "[" + jss(0, 'a') + "," + jss(63, '0') + "]" }, { 64, 1, "[" + jss(0, 'a') + "," + jss(64, '0') + "]" }, { 64, 1, "[" + jss(0, 'a') + "," + jss(65, '0') + "]" }, { 64, 1, "[" + jss(10, 'a') + "," + jss(0, '0') + "]" }, { 64, 1, "[" + jss(10, 'a') + "," + jss(10, '0') + "]" }, { 64, 1, "[" + jss(10, 'a') + "," + jss(51, '0') + "]" }, { 64, 1, "[" + jss(10, 'a') + "," + jss(52, '0') + "]" }, { 64, 1, "[" + jss(10, 'a') + "," + jss(54, '0') + "]" }, { 64, 1, "[" + jss(10, 'a') + "," + jss(55, '0') + "]" }, { 64, 1, "[" + jss(0, 'a') + "," + jss(0, 'a') + "," + jss(0, '0') + "]" }, { 64, 1, "[" + jss(0, 'a') + "," + jss(0, 'a') + "," + jss(63, '0') + "]" }, { 64, 1, "[" + jss(0, 'a') + "," + jss(0, 'a') + "," + jss(64, '0') + "]" }, { 64, 1, "[" + jss(0, 'a') + "," + jss(0, 'a') + "," + jss(65, '0') + "]" }, { 64, 1, "[" + jss(10, 'a') + "," + jss(20, 'A') + "," + jss(10, '0') + "]" }, { 64, 1, "[" + jss(10, 'a') + "," + jss(20, 'A') + "," + jss(23, '0') + "]" }, { 64, 1, "[" + jss(10, 'a') + "," + jss(20, 'A') + "," + jss(24, '0') + "]" }, { 64, 1, "[" + jss(10, 'a') + "," + jss(20, 'A') + "," + jss(25, '0') + "]" }, { 64, 2, "[[]]" }, { 64, 2, "[[" + jss(0, 'a') + "], []]" }, { 64, 2, "[[" + jss(10, 'a') + "], []]" }, { 64, 2, "[[" + jss(59, 'a') + "], []]" }, { 64, 2, "[[" + jss(60, 'a') + "], []]" }, { 64, 2, "[[" + jss(100, 'a') + "], []]" }, { 64, 2, "[[" + jss(10, '0') + ", " + jss(53, 'a') + "], []]" }, { 64, 2, "[[" + jss(10, '0') + ", " + jss(54, 'a') + "], []]" }, { 64, 2, "[[" + jss(10, '0') + ", " + jss(55, 'a') + "], []]" }, { 64, 2, "[[], [" + jss(0, 'a') + "]]" }, { 64, 2, "[[], [" + jss(10, 'a') + "]]" }, { 64, 2, "[[], [" + jss(63, 'a') + "]]" }, { 64, 2, "[[], [" + jss(64, 'a') + "]]" }, { 64, 2, "[[], [" + jss(65, 'a') + "]]" }, { 64, 2, "[[], [" + jss(10, '0') + ", " + jss(53, 'a') + "]]" }, { 64, 2, "[[], [" + jss(10, '0') + ", " + jss(54, 'a') + "]]" }, { 64, 2, "[[], [" + jss(10, '0') + ", " + jss(55, 'a') + "]]" }, { 64, 2, "[[" + jss(10, '0') + "]]" }, { 64, 2, "[[" + jss(62, '0') + "]]" }, { 64, 2, "[[" + jss(63, '0') + "]]" }, { 64, 2, "[[" + jss(64, '0') + "]]" }, { 64, 2, "[[" + jss(10, 'a') + ", " + jss(10, '0') + "]]" }, { 64, 2, "[[" + jss(10, 'a') + ", " + jss(52, '0') + "]]" }, { 64, 2, "[[" + jss(10, 'a') + ", " + jss(53, '0') + "]]" }, { 64, 2, "[[" + jss(10, 'a') + ", " + jss(54, '0') + "]]" }, { 64, 3, "[[[" + jss(10, '0') + "]]]" }, { 64, 3, "[[[" + jss(62, '0') + "]]]" }, { 64, 3, "[[[" + jss(63, '0') + "]]]" }, { 64, 3, "[[[" + jss(64, '0') + "]]]" }, { 64, 3, "[[[" + jss(10, 'a') + ", " + jss(10, '0') + "]]]" }, { 64, 3, "[[[" + jss(10, 'a') + ", " + jss(52, '0') + "]]]" }, { 64, 3, "[[[" + jss(10, 'a') + ", " + jss(53, '0') + "]]]" }, { 64, 3, "[[[" + jss(10, 'a') + "], [" + jss(54, '0') + "]]]" }, { 64, 3, "[[[" + jss(10, 'a') + "], [" + jss(10, '0') + "]]]" }, { 64, 3, "[[[" + jss(10, 'a') + "], [" + jss(52, '0') + "]]]" }, { 64, 3, "[[[" + jss(10, 'a') + "], [" + jss(53, '0') + "]]]" }, { 64, 3, "[[[" + jss(10, 'a') + "], [" + jss(54, '0') + "]]]" }, { 64, 2, "[[\"p\"], [\"mn\"]]" }, { 64, 2, "[[\"pqr\"], [\"mn\"]]" }, { 64, 2, "[[\"pqrstuvwxyz\"], [\"mn\"]]" }, { 64, 2, "[[\"abc\", \"pqrstuvwxyz\"], [\"mn\"]]" }, { 64, 2, "[[\"mn\"], [\"\"]]" }, { 64, 2, "[[\"mn\"], \"abc\"]" }, { 64, 2, "[[\"mn\"], \"abcdefghijk\"]" }, { 64, 2, "[[\"mn\"], \"pqr\", \"abc\"]" }, { 64, 2, "[[\"mn\"]]" }, { 64, 2, "[[\"p\"], [\"mnopqrstuvwx\"]]" }, { 64, 2, "[[\"pqr\"], [\"mnopqrstuvwx\"]]" }, { 64, 2, "[[\"pqrstuvwxyz\"], [\"mnopqrstuvwx\"]]" }, { 64, 2, "[[\"abc\"], \"pqrstuvwxyz\", [\"mnopqrstuvwx\"]]" }, { 64, 2, "[[\"mnopqrstuvwx\"], [\"\"]]" }, { 64, 2, "[[\"mnopqrstuvwx\"], [\"abc\"]]" }, { 64, 2, "[[\"mnopqrstuvwx\"], [\"abcdefghijk\"]]" }, { 64, 2, "[[\"mnopqrstuvwx\"], [\"pqr\", \"abc\"]]" }, { 100, 2, "[[\"pqr\", \"mnopqrstuvwx\"]]" }, { 100, 2, "[[\"pqr\", \"ab\", \"mnopqrstuvwx\"]]" }, { 64, 2, "[[[\"pqr\"]], [[\"ab\"], [\"mnopqrstuvwx\"]]]" }, { 64, 1, "{}" }, { 64, 1, "{\"n\": \"v\"}" }, { 64, 1, "{\"n1\": \"v\", \"n2\": []}" }, { 100, 1, "{\"n1\": \"v\", \"n2\": []}" }, { 100, 1, "{\"n1\": \"v\", \"n2\": [\"abc\"]}" } });}
6ba6af63e963dbedce9488ec969cc1ae515a3104d25373f496f5f9b505dd02cf
jss
private static String jss(final int n, char c)
{    char[] cc = new char[n + 2];    cc[0] = cc[n + 1] = '"';    for (int i = 1; i < n + 1; i++) {        if (c == 'Z') {            c = 'a';        } else if (c == 'z') {            c = '0';        } else if (c == '9') {            c = 'A';        } else {            c++;        }        cc[i] = c;    }    return new String(cc);}
ca7d48d6d1fdb05bf1a430a8f598249c2c84ef2a5dc404037a18eb0b048c4b70
testScan
public void testScan() throws IOException
{    TestValidatingIO.check(msg, decoder, calls, values, -1);}
e159cd20e5d846e508be922f0450be0db638ed2ba32c3229ae07c0ea68938d77
data
public static Collection<Object[]> data()
{    return Arrays.asList(new Object[][] { { 64, 0, "" }, { 64, 0, "S0" }, { 64, 0, "S3" }, { 64, 0, "S64" }, { 64, 0, "S65" }, { 64, 0, "S100" }, { 64, 1, "[]" }, { 64, 1, "[c1sS0]" }, { 64, 1, "[c1sS3]" }, { 64, 1, "[c1sS61]" }, { 64, 1, "[c1sS62]" }, { 64, 1, "[c1sS64]" }, { 64, 1, "[c1sS65]" }, { 64, 1, "[c2sS0sS0]" }, { 64, 1, "[c2sS0sS10]" }, { 64, 1, "[c2sS0sS63]" }, { 64, 1, "[c2sS0sS64]" }, { 64, 1, "[c2sS0sS65]" }, { 64, 1, "[c2sS10sS0]" }, { 64, 1, "[c2sS10sS10]" }, { 64, 1, "[c2sS10sS51]" }, { 64, 1, "[c2sS10sS52]" }, { 64, 1, "[c2sS10sS54]" }, { 64, 1, "[c2sS10sS55]" }, { 64, 1, "[c3sS0sS0sS0]" }, { 64, 1, "[c3sS0sS0sS63]" }, { 64, 1, "[c3sS0sS0sS64]" }, { 64, 1, "[c3sS0sS0sS65]" }, { 64, 1, "[c3sS10sS20sS10]" }, { 64, 1, "[c3sS10sS20sS23]" }, { 64, 1, "[c3sS10sS20sS24]" }, { 64, 1, "[c3sS10sS20sS25]" }, { 64, 1, "[c1s[]]" }, { 64, 1, "[c1s[c1sS0]]" }, { 64, 1, "[c1s[c1sS10]]" }, { 64, 1, "[c2s[c1sS10]s[]]" }, { 64, 1, "[c2s[c1sS59]s[]]" }, { 64, 1, "[c2s[c1sS60]s[]]" }, { 64, 1, "[c2s[c1sS100]s[]]" }, { 64, 1, "[c2s[c2sS10sS53]s[]]" }, { 64, 1, "[c2s[c2sS10sS54]s[]]" }, { 64, 1, "[c2s[c2sS10sS55]s[]]" }, { 64, 1, "[c2s[]s[c1sS0]]" }, { 64, 1, "[c2s[]s[c1sS10]]" }, { 64, 1, "[c2s[]s[c1sS63]]" }, { 64, 1, "[c2s[]s[c1sS64]]" }, { 64, 1, "[c2s[]s[c1sS65]]" }, { 64, 1, "[c2s[]s[c2sS10sS53]]" }, { 64, 1, "[c2s[]s[c2sS10sS54]]" }, { 64, 1, "[c2s[]s[c2sS10sS55]]" }, { 64, 1, "[c1s[c1sS10]]" }, { 64, 1, "[c1s[c1sS62]]" }, { 64, 1, "[c1s[c1sS63]]" }, { 64, 1, "[c1s[c1sS64]]" }, { 64, 1, "[c1s[c2sS10sS10]]" }, { 64, 1, "[c1s[c2sS10sS52]]" }, { 64, 1, "[c1s[c2sS10sS53]]" }, { 64, 1, "[c1s[c2sS10sS54]]" }, { 64, 1, "[c1s[c1s[c1sS10]]]" }, { 64, 1, "[c1s[c1s[c1sS62]]]" }, { 64, 1, "[c1s[c1s[c1sS63]]]" }, { 64, 1, "[c1s[c1s[c1sS64]]]" }, { 64, 1, "[c1s[c1s[c2sS10sS10]]]" }, { 64, 1, "[c1s[c1s[c2sS10sS52]]]" }, { 64, 1, "[c1s[c1s[c2sS10sS53]]]" }, { 64, 1, "[c1s[c1s[c2sS10sS54]]]" }, { 64, 1, "[c1s[c2sS10s[c1sS10]]]" }, { 64, 1, "[c1s[c2sS10s[c1sS52]]]" }, { 64, 1, "[c1s[c2sS10s[c1sS53]]]" }, { 64, 1, "[c1s[c2sS10s[c1sS54]]]" }, { 64, 1, "{}" }, { 64, 1, "{c1sK5S1}" }, { 64, 1, "{c1sK5[]}" }, { 100, 1, "{c1sK5[]}" }, { 100, 1, "{c1sK5[c1sS10]}" }, { 100, 1, "{c1sK5e10}" }, { 100, 1, "{c1sK5U1S10}" }, { 100, 1, "{c1sK5f10S10}" }, { 100, 1, "{c1sK5NS10}" }, { 100, 1, "{c1sK5BS10}" }, { 100, 1, "{c1sK5IS10}" }, { 100, 1, "{c1sK5LS10}" }, { 100, 1, "{c1sK5FS10}" }, { 100, 1, "{c1sK5DS10}" } });}
e24ee57b612bfb05ed5c31db773aac06532e7d25ab29e2d922eb27cde922a357
testBinaryEncoderInit
public void testBinaryEncoderInit() throws IOException
{    OutputStream out = new ByteArrayOutputStream();    BinaryEncoder enc = factory.binaryEncoder(out, null);    Assert.assertSame(enc, factory.binaryEncoder(out, enc));}
7f35d0091a34de8e7720facbdaa2b6938abfcfb56509d7f08abee3df4545a6bd
testBadBinaryEncoderInit
public void testBadBinaryEncoderInit()
{    factory.binaryEncoder(null, null);}
34399dd83c2ab5193a4955ebd858e07c0234be8d37ed5ac2d7c98f30215e7ec0
testBlockingBinaryEncoderInit
public void testBlockingBinaryEncoderInit() throws IOException
{    OutputStream out = new ByteArrayOutputStream();    BinaryEncoder reuse = null;    reuse = factory.blockingBinaryEncoder(out, reuse);    Assert.assertSame(reuse, factory.blockingBinaryEncoder(out, reuse));}
35f3e4ac26e3e0d0da7a4e50b78b4de83305730ccdb1484a56d5f97c502bd08d
testBadBlockintBinaryEncoderInit
public void testBadBlockintBinaryEncoderInit()
{    factory.binaryEncoder(null, null);}
9facc1a08b9df2fcb40a9a4bb7f5921c8f572f350a62b910ead79098be2887a6
testDirectBinaryEncoderInit
public void testDirectBinaryEncoderInit() throws IOException
{    OutputStream out = new ByteArrayOutputStream();    BinaryEncoder enc = factory.directBinaryEncoder(out, null);    Assert.assertSame(enc, factory.directBinaryEncoder(out, enc));}
2eed3b68236a4b27f31ea169c2c73ed3728f5035fbe3eb9ef28657bb8a2410c7
testBadDirectBinaryEncoderInit
public void testBadDirectBinaryEncoderInit()
{    factory.directBinaryEncoder(null, null);}
45fff39cad0a3a48972dc1b8abd784fd4b499a909128f3eb737a69b67a0b5ba6
testJsonEncoderInit
public void testJsonEncoderInit() throws IOException
{    Schema s = new Schema.Parser().parse("\"int\"");    OutputStream out = new ByteArrayOutputStream();    factory.jsonEncoder(s, out);    JsonEncoder enc = factory.jsonEncoder(s, new JsonFactory().createGenerator(out, JsonEncoding.UTF8));    enc.configure(out);}
c8f40be69eba454798f8ab539a662d219a821e752db124626c179c4ffcf63b9d
testBadJsonEncoderInitOS
public void testBadJsonEncoderInitOS() throws IOException
{    factory.jsonEncoder(Schema.create(Type.INT), (OutputStream) null);}
1ff8e03a9fc3374d2d94db8aedde0c10aee55089685ce41a6ad15ecf176d7469
testBadJsonEncoderInit
public void testBadJsonEncoderInit() throws IOException
{    factory.jsonEncoder(Schema.create(Type.INT), (JsonGenerator) null);}
39d67dfd79680ec3e6fde50e254b83ee0aba6be656b5c24e316d21e678a35ff5
testJsonEncoderNewlineDelimited
public void testJsonEncoderNewlineDelimited() throws IOException
{    OutputStream out = new ByteArrayOutputStream();    Schema ints = Schema.create(Type.INT);    Encoder e = factory.jsonEncoder(ints, out);    String separator = System.getProperty("line.separator");    GenericDatumWriter<Integer> writer = new GenericDatumWriter<>(ints);    writer.write(1, e);    writer.write(2, e);    e.flush();    Assert.assertEquals("1" + separator + "2", out.toString());}
dce904f7e7d24f6f4d548ce508bdbcd6d56f6f45bab6b58f11049b2c252fd26d
testJsonEncoderWhenIncludeNamespaceOptionIsFalse
public void testJsonEncoderWhenIncludeNamespaceOptionIsFalse() throws IOException
{    String value = "{\"b\": {\"string\":\"myVal\"}, \"a\": 1}";    String schemaStr = "{\"type\": \"record\", \"name\": \"ab\", \"fields\": [" + "{\"name\": \"a\", \"type\": \"int\"}, {\"name\": \"b\", \"type\": [\"null\", \"string\"]}" + "]}";    Schema schema = new Schema.Parser().parse(schemaStr);    byte[] avroBytes = fromJsonToAvro(value, schema);    ObjectMapper mapper = new ObjectMapper();    Assert.assertEquals(mapper.readTree("{\"b\":\"myVal\",\"a\":1}"), mapper.readTree(fromAvroToJson(avroBytes, schema, false)));}
a88f241f285d740f97d578396638065bf6f42478a9476ac6a4d189e772a91ea7
testJsonEncoderWhenIncludeNamespaceOptionIsTrue
public void testJsonEncoderWhenIncludeNamespaceOptionIsTrue() throws IOException
{    String value = "{\"b\": {\"string\":\"myVal\"}, \"a\": 1}";    String schemaStr = "{\"type\": \"record\", \"name\": \"ab\", \"fields\": [" + "{\"name\": \"a\", \"type\": \"int\"}, {\"name\": \"b\", \"type\": [\"null\", \"string\"]}" + "]}";    Schema schema = new Schema.Parser().parse(schemaStr);    byte[] avroBytes = fromJsonToAvro(value, schema);    ObjectMapper mapper = new ObjectMapper();    Assert.assertEquals(mapper.readTree("{\"b\":{\"string\":\"myVal\"},\"a\":1}"), mapper.readTree(fromAvroToJson(avroBytes, schema, true)));}
d1f8f590e59095fd23b42840d7b177b7219c36bf9d51d2eb649ae7727ea95a47
testValidatingEncoderInit
public void testValidatingEncoderInit() throws IOException
{    Schema s = new Schema.Parser().parse("\"int\"");    OutputStream out = new ByteArrayOutputStream();    Encoder e = factory.directBinaryEncoder(out, null);    factory.validatingEncoder(s, e).configure(e);}
f145e0722dfc075af7a536decd8e67bbf4ceacd8798099bda9dfc28cf6fd86be
testJsonRecordOrdering
public void testJsonRecordOrdering() throws IOException
{    String value = "{\"b\": 2, \"a\": 1}";    Schema schema = new Schema.Parser().parse("{\"type\": \"record\", \"name\": \"ab\", \"fields\": [" + "{\"name\": \"a\", \"type\": \"int\"}, {\"name\": \"b\", \"type\": \"int\"}" + "]}");    GenericDatumReader<Object> reader = new GenericDatumReader<>(schema);    Decoder decoder = DecoderFactory.get().jsonDecoder(schema, value);    Object o = reader.read(null, decoder);    Assert.assertEquals("{\"a\": 1, \"b\": 2}", o.toString());}
b2a8ec4b6351cedd04c051385f124cec53797157eeaa3a029d035adc1fb79700
testJsonExcessFields
public void testJsonExcessFields() throws IOException
{    String value = "{\"b\": { \"b3\": 1.4, \"b2\": 3.14, \"b1\": \"h\"}, \"a\": {\"a0\": 45, \"a2\":true, \"a1\": null}}";    Schema schema = new Schema.Parser().parse("{\"type\": \"record\", \"name\": \"ab\", \"fields\": [\n" + "{\"name\": \"a\", \"type\": {\"type\":\"record\",\"name\":\"A\",\"fields\":\n" + "[{\"name\":\"a1\", \"type\":\"null\"}, {\"name\":\"a2\", \"type\":\"boolean\"}]}},\n" + "{\"name\": \"b\", \"type\": {\"type\":\"record\",\"name\":\"B\",\"fields\":\n" + "[{\"name\":\"b1\", \"type\":\"string\"}, {\"name\":\"b2\", \"type\":\"float\"}, {\"name\":\"b3\", \"type\":\"double\"}]}}\n" + "]}");    GenericDatumReader<Object> reader = new GenericDatumReader<>(schema);    Decoder decoder = DecoderFactory.get().jsonDecoder(schema, value);    reader.read(null, decoder);}
053ca9888abc8c4978440f681b35177cf25bb428d6ba501378adf727d61f11c6
testJsonRecordOrdering2
public void testJsonRecordOrdering2() throws IOException
{    String value = "{\"b\": { \"b3\": 1.4, \"b2\": 3.14, \"b1\": \"h\"}, \"a\": {\"a2\":true, \"a1\": null}}";    Schema schema = new Schema.Parser().parse("{\"type\": \"record\", \"name\": \"ab\", \"fields\": [\n" + "{\"name\": \"a\", \"type\": {\"type\":\"record\",\"name\":\"A\",\"fields\":\n" + "[{\"name\":\"a1\", \"type\":\"null\"}, {\"name\":\"a2\", \"type\":\"boolean\"}]}},\n" + "{\"name\": \"b\", \"type\": {\"type\":\"record\",\"name\":\"B\",\"fields\":\n" + "[{\"name\":\"b1\", \"type\":\"string\"}, {\"name\":\"b2\", \"type\":\"float\"}, {\"name\":\"b3\", \"type\":\"double\"}]}}\n" + "]}");    GenericDatumReader<Object> reader = new GenericDatumReader<>(schema);    Decoder decoder = DecoderFactory.get().jsonDecoder(schema, value);    Object o = reader.read(null, decoder);    Assert.assertEquals("{\"a\": {\"a1\": null, \"a2\": true}, \"b\": {\"b1\": \"h\", \"b2\": 3.14, \"b3\": 1.4}}", o.toString());}
9326182237c49d5c7c6ba601e815cfb994cf9810eb5b8064f0ddca03ec8524a5
testJsonRecordOrderingWithProjection
public void testJsonRecordOrderingWithProjection() throws IOException
{    String value = "{\"b\": { \"b3\": 1.4, \"b2\": 3.14, \"b1\": \"h\"}, \"a\": {\"a2\":true, \"a1\": null}}";    Schema writerSchema = new Schema.Parser().parse("{\"type\": \"record\", \"name\": \"ab\", \"fields\": [\n" + "{\"name\": \"a\", \"type\": {\"type\":\"record\",\"name\":\"A\",\"fields\":\n" + "[{\"name\":\"a1\", \"type\":\"null\"}, {\"name\":\"a2\", \"type\":\"boolean\"}]}},\n" + "{\"name\": \"b\", \"type\": {\"type\":\"record\",\"name\":\"B\",\"fields\":\n" + "[{\"name\":\"b1\", \"type\":\"string\"}, {\"name\":\"b2\", \"type\":\"float\"}, {\"name\":\"b3\", \"type\":\"double\"}]}}\n" + "]}");    Schema readerSchema = new Schema.Parser().parse("{\"type\": \"record\", \"name\": \"ab\", \"fields\": [\n" + "{\"name\": \"a\", \"type\": {\"type\":\"record\",\"name\":\"A\",\"fields\":\n" + "[{\"name\":\"a1\", \"type\":\"null\"}, {\"name\":\"a2\", \"type\":\"boolean\"}]}}\n" + "]}");    GenericDatumReader<Object> reader = new GenericDatumReader<>(writerSchema, readerSchema);    Decoder decoder = DecoderFactory.get().jsonDecoder(writerSchema, value);    Object o = reader.read(null, decoder);    Assert.assertEquals("{\"a\": {\"a1\": null, \"a2\": true}}", o.toString());}
854672bdfa8fa0b34f463a93e588280de7eb4dc9583eda05ffdcc037b89aa64c
testJsonRecordOrderingWithProjection2
public void testJsonRecordOrderingWithProjection2() throws IOException
{    String value = "{\"b\": { \"b1\": \"h\", \"b2\": [3.14, 3.56], \"b3\": 1.4}, \"a\": {\"a2\":true, \"a1\": null}}";    Schema writerSchema = new Schema.Parser().parse("{\"type\": \"record\", \"name\": \"ab\", \"fields\": [\n" + "{\"name\": \"a\", \"type\": {\"type\":\"record\",\"name\":\"A\",\"fields\":\n" + "[{\"name\":\"a1\", \"type\":\"null\"}, {\"name\":\"a2\", \"type\":\"boolean\"}]}},\n" + "{\"name\": \"b\", \"type\": {\"type\":\"record\",\"name\":\"B\",\"fields\":\n" + "[{\"name\":\"b1\", \"type\":\"string\"}, {\"name\":\"b2\", \"type\":{\"type\":\"array\", \"items\":\"float\"}}, {\"name\":\"b3\", \"type\":\"double\"}]}}\n" + "]}");    Schema readerSchema = new Schema.Parser().parse("{\"type\": \"record\", \"name\": \"ab\", \"fields\": [\n" + "{\"name\": \"a\", \"type\": {\"type\":\"record\",\"name\":\"A\",\"fields\":\n" + "[{\"name\":\"a1\", \"type\":\"null\"}, {\"name\":\"a2\", \"type\":\"boolean\"}]}}\n" + "]}");    GenericDatumReader<Object> reader = new GenericDatumReader<>(writerSchema, readerSchema);    Decoder decoder = DecoderFactory.get().jsonDecoder(writerSchema, value);    Object o = reader.read(null, decoder);    Assert.assertEquals("{\"a\": {\"a1\": null, \"a2\": true}}", o.toString());}
f8e3781a77a8078f49c0519533eb6e241f8f3c021a5800176891c88676dcfadc
testArrayBackedByteBuffer
public void testArrayBackedByteBuffer() throws IOException
{    ByteBuffer buffer = ByteBuffer.wrap(someBytes(EXAMPLE_DATA_SIZE));    testWithBuffer(buffer);}
7d2902cba3f8b43e7f4e4926a0a67f2eb77f9c8cb382efd1ff039afcaaa3c213
testMappedByteBuffer
public void testMappedByteBuffer() throws IOException
{    Path file = Paths.get(DIR.getRoot().getPath() + "testMappedByteBuffer.avro");    Files.write(file, someBytes(EXAMPLE_DATA_SIZE));    MappedByteBuffer buffer = FileChannel.open(file, StandardOpenOption.READ).map(FileChannel.MapMode.READ_ONLY, 0, EXAMPLE_DATA_SIZE);    testWithBuffer(buffer);}
a4d9d53e8227df95b46d13a4dec13c346cc7759a923f9df68020fc4002d15829
testWithBuffer
private void testWithBuffer(ByteBuffer buffer) throws IOException
{    assertThat(asList(buffer.position(), buffer.remaining()), is(asList(0, EXAMPLE_DATA_SIZE)));    ByteArrayOutputStream output = new ByteArrayOutputStream(EXAMPLE_DATA_SIZE * 2);    EncoderFactory encoderFactory = new EncoderFactory();    encoderFactory.configureBufferSize(ENCODER_BUFFER_SIZE);    Encoder encoder = encoderFactory.binaryEncoder(output, null);    new GenericDatumWriter<ByteBuffer>(Schema.create(Schema.Type.BYTES)).write(buffer, encoder);    encoder.flush();    assertThat(output.toByteArray(), equalTo(avroEncoded(someBytes(EXAMPLE_DATA_SIZE))));        assertThat(asList(buffer.position(), buffer.remaining()), is(asList(0, EXAMPLE_DATA_SIZE)));}
c886aec1d58170553787455888b984974fd4494a156a3bf59a69d5d958bf7b3a
someBytes
private byte[] someBytes(int size)
{    byte[] result = new byte[size];    for (int i = 0; i < size; i++) {        result[i] = (byte) i;    }    return result;}
c9ee3b1d34b1cfe6dc112ad962f8f54cb2068caf656fc742ac2785dcbe3dd828
avroEncoded
private byte[] avroEncoded(byte[] bytes)
{    assert bytes.length < 64;    byte[] result = new byte[1 + bytes.length];        result[0] = (byte) (bytes.length * 2);    System.arraycopy(bytes, 0, result, 1, bytes.length);    return result;}
a5ea7934263f1d15c6494a5e44a62f89fce916a10799cf0a00bba1b91b2490b6
fromJsonToAvro
private byte[] fromJsonToAvro(String json, Schema schema) throws IOException
{    DatumReader<Object> reader = new GenericDatumReader<>(schema);    GenericDatumWriter<Object> writer = new GenericDatumWriter<>(schema);    ByteArrayOutputStream output = new ByteArrayOutputStream();    Decoder decoder = DecoderFactory.get().jsonDecoder(schema, json);    Encoder encoder = EncoderFactory.get().binaryEncoder(output, null);    Object datum = reader.read(null, decoder);    writer.write(datum, encoder);    encoder.flush();    return output.toByteArray();}
fc4224eeeccbe21209e5a7f8c4dd4036df8802b5481cb12e62d47b8da22244fc
fromAvroToJson
private String fromAvroToJson(byte[] avroBytes, Schema schema, boolean includeNamespace) throws IOException
{    GenericDatumReader<Object> reader = new GenericDatumReader<>(schema);    DatumWriter<Object> writer = new GenericDatumWriter<>(schema);    ByteArrayOutputStream output = new ByteArrayOutputStream();    JsonEncoder encoder = factory.jsonEncoder(schema, output);    encoder.setIncludeNamespace(includeNamespace);    Decoder decoder = DecoderFactory.get().binaryDecoder(avroBytes, null);    Object datum = reader.read(null, decoder);    writer.write(datum, encoder);    encoder.flush();    output.flush();    return new String(output.toByteArray(), StandardCharsets.UTF_8.name());}
7d308bd607294c47e283d31de15a82aeaaad961e02fc7aca32909747cfcabcad
testInt
public void testInt() throws Exception
{    checkNumeric("int", 1);}
610de3ad7cc1d54bdbc9a4fe9c41e2c012a37ae58dac4466b22979a25e1b08e7
testLong
public void testLong() throws Exception
{    checkNumeric("long", 1L);}
b7f222c157daee3f00a40a6f98b21c2806a0bfbf7a58e847930af5420b976276
testFloat
public void testFloat() throws Exception
{    checkNumeric("float", 1.0F);}
d1cc0c0b6a548d4db9fe52df21cce3b0c12faae6479bc1660611b03839fdb710
testDouble
public void testDouble() throws Exception
{    checkNumeric("double", 1.0);}
5f23330b36d2185ee875c24dea6cf94745b8bb0b6dcf381ed0afb2aa742e444e
checkNumeric
private void checkNumeric(String type, Object value) throws Exception
{    String def = "{\"type\":\"record\",\"name\":\"X\",\"fields\":" + "[{\"type\":\"" + type + "\",\"name\":\"n\"}]}";    Schema schema = new Schema.Parser().parse(def);    DatumReader<GenericRecord> reader = new GenericDatumReader<>(schema);    String[] records = { "{\"n\":1}", "{\"n\":1.0}" };    for (String record : records) {        Decoder decoder = DecoderFactory.get().jsonDecoder(schema, record);        GenericRecord r = reader.read(null, decoder);        Assert.assertEquals(value, r.get("n"));    }}
1eae125b1b9a4582782125a5399eb9b3299c5e1c405eaa12c3ed4bf5dfccff0f
testReorderFields
public void testReorderFields() throws Exception
{    String w = "{\"type\":\"record\",\"name\":\"R\",\"fields\":" + "[{\"type\":\"long\",\"name\":\"l\"}," + "{\"type\":{\"type\":\"array\",\"items\":\"int\"},\"name\":\"a\"}" + "]}";    Schema ws = new Schema.Parser().parse(w);    DecoderFactory df = DecoderFactory.get();    String data = "{\"a\":[1,2],\"l\":100}{\"l\": 200, \"a\":[1,2]}";    JsonDecoder in = df.jsonDecoder(ws, data);    Assert.assertEquals(100, in.readLong());    in.skipArray();    Assert.assertEquals(200, in.readLong());    in.skipArray();}
942d09eae39079cdae5b56ac13f9ff5fd3b4be4c819a7aa82cbe7feb55d70d92
testIdentical
public void testIdentical() throws IOException
{    performTest(eEnc, iSkipL, sJsWrtSchm, sWrtCls, sJsWrtSchm, sWrtCls);}
8dcd7ecb1be3d829e73372fa3286bcdf0daf55e71a3684e811b4f5a180f097e2
testCompatible
public void testCompatible() throws IOException
{    performTest(eEnc, iSkipL, sJsWrtSchm, sWrtCls, sJsRdrSchm, sRdrCls);}
3393d52e3e6879c15acc9330c7c050e653b0b307020e7051b70379dd3165a6f3
performTest
private void performTest(Encoding encoding, int skipLevel, String jsonWriterSchema, String writerCalls, String jsonReaderSchema, String readerCalls) throws IOException
{    for (int i = 0; i < COUNT; i++) {        testOnce(jsonWriterSchema, writerCalls, jsonReaderSchema, readerCalls, encoding, skipLevel);    }}
1eab30de31b0eacaf20968b227c36203ba3d911b4cf8cab8df0882e2eaee3959
testOnce
private void testOnce(String jsonWriterSchema, String writerCalls, String jsonReaderSchema, String readerCalls, Encoding encoding, int skipLevel) throws IOException
{    Object[] values = TestValidatingIO.randomValues(writerCalls);    Object[] expected = TestValidatingIO.randomValues(readerCalls);    Schema writerSchema = new Schema.Parser().parse(jsonWriterSchema);    byte[] bytes = TestValidatingIO.make(writerSchema, writerCalls, values, encoding);    Schema readerSchema = new Schema.Parser().parse(jsonReaderSchema);    TestValidatingIO.print(encoding, skipLevel, writerSchema, readerSchema, values, expected);    check(writerSchema, readerSchema, bytes, readerCalls, expected, encoding, skipLevel);}
68031be702c20ed27d45cf9813ba7959c1929af497dd6313c8d4a418e33ef06a
check
 static void check(Schema wsc, Schema rsc, byte[] bytes, String calls, Object[] values, Encoding encoding, int skipLevel) throws IOException
{            Decoder bvi = null;    switch(encoding) {        case BINARY:        case BLOCKING_BINARY:            bvi = DecoderFactory.get().binaryDecoder(bytes, null);            break;        case JSON:            InputStream in = new ByteArrayInputStream(bytes);            bvi = new JsonDecoder(wsc, in);            break;    }    Decoder vi = new ResolvingDecoder(wsc, rsc, bvi);    String msg = "Error in resolving case: w=" + wsc + ", r=" + rsc;    TestValidatingIO.check(msg, vi, calls, values, skipLevel);}
049745ad51f30df5156139d87ceb4e99d591acc20da5a726dd99d3136a6e32ce
data2
public static Collection<Object[]> data2()
{    return Arrays.asList(TestValidatingIO.convertTo2dArray(encodings, skipLevels, testSchemas()));}
9d2417b437116a77ef72960139ae05444bb6c219c82cb04c0ecf5cbebc252570
testSchemas
private static Object[][] testSchemas()
{        return new Object[][] { { "\"int\"", "I", "\"float\"", "F" }, { "\"int\"", "I", "\"double\"", "D" }, { "\"int\"", "I", "\"long\"", "L" }, { "\"long\"", "L", "\"float\"", "F" }, { "\"long\"", "L", "\"double\"", "D" }, { "\"float\"", "F", "\"double\"", "D" }, { "{\"type\":\"array\", \"items\": \"int\"}", "[]", "{\"type\":\"array\", \"items\": \"long\"}", "[]" }, { "{\"type\":\"array\", \"items\": \"int\"}", "[]", "{\"type\":\"array\", \"items\": \"double\"}", "[]" }, { "{\"type\":\"array\", \"items\": \"long\"}", "[]", "{\"type\":\"array\", \"items\": \"double\"}", "[]" }, { "{\"type\":\"array\", \"items\": \"float\"}", "[]", "{\"type\":\"array\", \"items\": \"double\"}", "[]" }, { "{\"type\":\"array\", \"items\": \"int\"}", "[c1sI]", "{\"type\":\"array\", \"items\": \"long\"}", "[c1sL]" }, { "{\"type\":\"array\", \"items\": \"int\"}", "[c1sI]", "{\"type\":\"array\", \"items\": \"double\"}", "[c1sD]" }, { "{\"type\":\"array\", \"items\": \"long\"}", "[c1sL]", "{\"type\":\"array\", \"items\": \"double\"}", "[c1sD]" }, { "{\"type\":\"array\", \"items\": \"float\"}", "[c1sF]", "{\"type\":\"array\", \"items\": \"double\"}", "[c1sD]" }, { "{\"type\":\"map\", \"values\": \"int\"}", "{}", "{\"type\":\"map\", \"values\": \"long\"}", "{}" }, { "{\"type\":\"map\", \"values\": \"int\"}", "{}", "{\"type\":\"map\", \"values\": \"double\"}", "{}" }, { "{\"type\":\"map\", \"values\": \"long\"}", "{}", "{\"type\":\"map\", \"values\": \"double\"}", "{}" }, { "{\"type\":\"map\", \"values\": \"float\"}", "{}", "{\"type\":\"map\", \"values\": \"double\"}", "{}" }, { "{\"type\":\"map\", \"values\": \"int\"}", "{c1sK5I}", "{\"type\":\"map\", \"values\": \"long\"}", "{c1sK5L}" }, { "{\"type\":\"map\", \"values\": \"int\"}", "{c1sK5I}", "{\"type\":\"map\", \"values\": \"double\"}", "{c1sK5D}" }, { "{\"type\":\"map\", \"values\": \"long\"}", "{c1sK5L}", "{\"type\":\"map\", \"values\": \"double\"}", "{c1sK5D}" }, { "{\"type\":\"map\", \"values\": \"float\"}", "{c1sK5F}", "{\"type\":\"map\", \"values\": \"double\"}", "{c1sK5D}" }, { "{\"type\":\"record\",\"name\":\"r\",\"fields\":[" + "{\"name\":\"f\", \"type\":\"int\"}]}", "I", "{\"type\":\"record\",\"name\":\"r\",\"fields\":[" + "{\"name\":\"f\", \"type\":\"long\"}]}", "L" }, { "{\"type\":\"record\",\"name\":\"r\",\"fields\":[" + "{\"name\":\"f\", \"type\":\"int\"}]}", "I", "{\"type\":\"record\",\"name\":\"r\",\"fields\":[" + "{\"name\":\"f\", \"type\":\"double\"}]}", "D" },     { "{\"type\":\"record\",\"name\":\"r\",\"fields\":[" + "{\"name\":\"f0\", \"type\":\"boolean\"}," + "{\"name\":\"f1\", \"type\":\"int\"}," + "{\"name\":\"f2\", \"type\":\"float\"}," + "{\"name\":\"f3\", \"type\":\"bytes\"}," + "{\"name\":\"f4\", \"type\":\"string\"}]}", "BIFbS", "{\"type\":\"record\",\"name\":\"r\",\"fields\":[" + "{\"name\":\"f0\", \"type\":\"boolean\"}," + "{\"name\":\"f1\", \"type\":\"long\"}," + "{\"name\":\"f2\", \"type\":\"double\"}," + "{\"name\":\"f3\", \"type\":\"string\"}," + "{\"name\":\"f4\", \"type\":\"bytes\"}]}", "BLDSb" }, { "[\"int\"]", "U0I", "[\"long\"]", "U0L" }, { "[\"int\"]", "U0I", "[\"double\"]", "U0D" }, { "[\"long\"]", "U0L", "[\"double\"]", "U0D" }, { "[\"float\"]", "U0F", "[\"double\"]", "U0D" }, { "\"int\"", "I", "[\"int\"]", "U0I" }, { "[\"int\"]", "U0I", "\"int\"", "I" }, { "[\"int\"]", "U0I", "\"long\"", "L" }, { "[\"boolean\", \"int\"]", "U1I", "[\"boolean\", \"long\"]", "U1L" }, { "[\"boolean\", \"int\"]", "U1I", "[\"long\", \"boolean\"]", "U0L" } };}
f8e7f8bd8dbd44ce944f544027879bad53e2bc2f422d4806944e8ca7c8c1b870
testResolving
public void testResolving() throws IOException
{    Schema writerSchema = new Schema.Parser().parse(sJsWrtSchm);    byte[] bytes = TestValidatingIO.make(writerSchema, sWrtCls, oaWrtVals, eEnc);    Schema readerSchema = new Schema.Parser().parse(sJsRdrSchm);    TestValidatingIO.print(eEnc, iSkipL, writerSchema, readerSchema, oaWrtVals, oaRdrVals);    TestResolvingIO.check(writerSchema, readerSchema, bytes, sRdrCls, oaRdrVals, eEnc, iSkipL);}
58798e57d7e681eedf9de9be413abfa84fd0617b6d1ba171e52165980a2707a3
data3
public static Collection<Object[]> data3()
{    Collection<Object[]> ret = Arrays.asList(TestValidatingIO.convertTo2dArray(TestResolvingIO.encodings, TestResolvingIO.skipLevels, dataForResolvingTests()));    return ret;}
7412d366af9c632f19129b1adca2b3c154f562a6601bd899a6805ca01e1cec68
dataForResolvingTests
private static Object[][] dataForResolvingTests()
{        return new Object[][] {     { "{\"type\":\"record\",\"name\":\"r\",\"fields\":[" + "{\"name\":\"f1\", \"type\":\"string\"}," + "{\"name\":\"f2\", \"type\":\"string\"}," + "{\"name\":\"f3\", \"type\":\"int\"}]}", "S10S10IS10S10I", new Object[] { "s1", "s2", 100, "t1", "t2", 200 }, "{\"type\":\"record\",\"name\":\"r\",\"fields\":[" + "{\"name\":\"f1\", \"type\":\"string\" }," + "{\"name\":\"f2\", \"type\":\"string\"}]}", "RS10S10RS10S10", new Object[] { "s1", "s2", "t1", "t2" } },     { "{\"type\":\"record\",\"name\":\"r\",\"fields\":[" + "{\"name\":\"f1\", \"type\":\"int\"}," + "{\"name\":\"f2\", \"type\":\"string\"}]}", "IS10", new Object[] { 10, "hello" }, "{\"type\":\"record\",\"name\":\"r\",\"fields\":[" + "{\"name\":\"f2\", \"type\":\"string\" }," + "{\"name\":\"f1\", \"type\":\"long\"}]}", "RLS10", new Object[] { 10L, "hello" } },     { "{\"type\":\"record\",\"name\":\"r\",\"fields\":[]}", "", new Object[] {}, "{\"type\":\"record\",\"name\":\"r\",\"fields\":[" + "{\"name\":\"f\", \"type\":\"int\", \"default\": 100}]}", "RI", new Object[] { 100 } }, { "{\"type\":\"record\",\"name\":\"r\",\"fields\":[" + "{\"name\":\"f2\", \"type\":\"int\"}]}", "I", new Object[] { 10 }, "{\"type\":\"record\",\"name\":\"r\",\"fields\":[" + "{\"name\":\"f1\", \"type\":\"int\", \"default\": 101}," + "{\"name\":\"f2\", \"type\":\"int\"}]}", "RII", new Object[] { 10, 101 } }, { "{\"type\":\"record\",\"name\":\"outer\",\"fields\":[" + "{\"name\": \"g1\", " + "\"type\":{\"type\":\"record\",\"name\":\"inner\",\"fields\":[" + "{\"name\":\"f2\", \"type\":\"int\"}]}}, " + "{\"name\": \"g2\", \"type\": \"long\"}]}", "IL", new Object[] { 10, 11L }, "{\"type\":\"record\",\"name\":\"outer\",\"fields\":[" + "{\"name\": \"g1\", " + "\"type\":{\"type\":\"record\",\"name\":\"inner\",\"fields\":[" + "{\"name\":\"f1\", \"type\":\"int\", \"default\": 101}," + "{\"name\":\"f2\", \"type\":\"int\"}]}}, " + "{\"name\": \"g2\", \"type\": \"long\"}]}}", "RRIIL", new Object[] { 10, 101, 11L } },     { "{\"type\":\"record\",\"name\":\"outer\",\"fields\":[" + "{\"name\": \"g2\", \"type\": \"long\"}]}", "L", new Object[] { 11L }, "{\"type\":\"record\",\"name\":\"outer\",\"fields\":[" + "{\"name\": \"g1\", " + "\"type\":{\"type\":\"record\",\"name\":\"inner\",\"fields\":[" + "{\"name\":\"f1\", \"type\":\"int\" }," + "{\"name\":\"f2\", \"type\":\"int\"}] }, " + "\"default\": { \"f1\": 10, \"f2\": 101 } }, " + "{\"name\": \"g2\", \"type\": \"long\"}]}", "RLRII", new Object[] { 11L, 10, 101 } }, { "{\"type\":\"record\",\"name\":\"r\",\"fields\":[]}", "", new Object[] {}, "{\"type\":\"record\",\"name\":\"r\",\"fields\":[" + "{\"name\":\"f\", \"type\":{ \"type\": \"array\", \"items\": \"int\" }, " + "\"default\": [100]}]}", "[c1sI]", new Object[] { 100 } }, { "{ \"type\": \"array\", \"items\": {\"type\":\"record\"," + "\"name\":\"r\",\"fields\":[]} }", "[c1s]", new Object[] {}, "{ \"type\": \"array\", \"items\": {\"type\":\"record\"," + "\"name\":\"r\",\"fields\":[" + "{\"name\":\"f\", \"type\":\"int\", \"default\": 100}]} }", "[c1sI]", new Object[] { 100 } },     { "{\"type\":\"enum\",\"name\":\"e\",\"symbols\":[\"x\",\"y\",\"z\"]}", "e2", new Object[] {}, "{\"type\":\"enum\",\"name\":\"e\",\"symbols\":[ \"y\", \"z\" ]}", "e1", new Object[] {} }, { "{\"type\":\"enum\",\"name\":\"e\",\"symbols\":[ \"x\", \"y\" ]}", "e1", new Object[] {}, "{\"type\":\"enum\",\"name\":\"e\",\"symbols\":[ \"y\", \"z\" ]}", "e0", new Object[] {} },     { "\"int\"", "I", new Object[] { 100 }, "[ \"long\", \"int\"]", "U1I", new Object[] { 100 } }, { "[ \"long\", \"int\"]", "U1I", new Object[] { 100 }, "\"int\"", "I", new Object[] { 100 } },     { "\"int\"", "I", new Object[] { 100 }, "[ \"long\", \"string\"]", "U0L", new Object[] { 100L } }, { "[ \"int\", \"string\"]", "U0I", new Object[] { 100 }, "\"long\"", "L", new Object[] { 100L } },     { "{\"type\":\"record\",\"name\":\"r\",\"fields\":[" + "{\"name\":\"f0\", \"type\":\"boolean\"}," + "{\"name\":\"f1\", \"type\":\"int\"}," + "{\"name\":\"f2\", \"type\":[\"int\", \"long\"]}," + "{\"name\":\"f3\", \"type\":\"float\"}" + "]}", "BIU0IF", new Object[] { true, 100, 121, 10.75f }, "{\"type\":\"record\",\"name\":\"r\",\"fields\":[" + "{\"name\":\"f0\", \"type\":\"boolean\"}," + "{\"name\":\"f1\", \"type\":\"long\"}," + "{\"name\":\"f3\", \"type\":\"double\"}]}", "BLD", new Object[] { true, 100L, 10.75d } },     { "{ \"type\": \"array\", \"items\":" + "{\"type\":\"record\",\"name\":\"r\",\"fields\":[" + "{\"name\":\"f0\", \"type\":\"boolean\"}," + "{\"name\":\"f1\", \"type\": {\"type\":\"array\", \"items\": \"boolean\" }}" + "]}}", "[c2sB[c2sBsB]sB[c3sBsBsB]]", new Object[] { true, false, false, false, true, true, true }, "{ \"type\": \"array\", \"items\":" + "{\"type\":\"record\",\"name\":\"r\",\"fields\":[" + "{\"name\":\"f0\", \"type\":\"boolean\"}" + "]}}", "[c2sBsB]", new Object[] { true, false } } };}
6439558ab6430cdc53dec7869df9533d60dee60af835a956813e6e9a91dab686
testMain
public void testMain() throws IOException
{    for (int i = 0; i < COUNT; i++) {        testOnce(new Schema.Parser().parse(sJsSch), sCl, iSkipL, eEnc);    }}
51d0fb3caa1334abe6f213ad880027be1fb3a4f0619f574817d32d03e9dfc7e8
testOnce
private void testOnce(Schema schema, String calls, int skipLevel, Encoding encoding) throws IOException
{    Object[] values = randomValues(calls);    print(eEnc, iSkipL, schema, schema, values, values);    byte[] bytes = make(schema, calls, values, encoding);    check(schema, bytes, calls, values, skipLevel, encoding);}
00cdc9db5faf2ad1d7a1eafda4505f763cc3ed19bc5c5444e7ceb763d7511e20
make
public static byte[] make(Schema sc, String calls, Object[] values, Encoding encoding) throws IOException
{    EncoderFactory factory = EncoderFactory.get();    ByteArrayOutputStream ba = new ByteArrayOutputStream();    Encoder bvo = null;    switch(encoding) {        case BINARY:            bvo = factory.binaryEncoder(ba, null);            break;        case BLOCKING_BINARY:            bvo = factory.blockingBinaryEncoder(ba, null);            break;        case JSON:            bvo = factory.jsonEncoder(sc, ba);            break;    }    Encoder vo = factory.validatingEncoder(sc, bvo);    generate(vo, calls, values);    vo.flush();    return ba.toByteArray();}
1e2b5704e7cfa0e720b3cbb80b8f6a1ef5a745120c4f0dd11e8fc4b87d3d2283
next
public boolean next()
{    if (cpos < chars.length) {        cpos++;    }    return cpos != chars.length;}
b7acf6ca2ee3173216e6fb9ce58072709a4de12b1f999a56afb8cda48f70b153
cur
public char cur()
{    return chars[cpos];}
7cf382bf6532528601afc0572ff7a4051fb2bd1cf2c9b7df66165750bb63dcd3
isDone
public boolean isDone()
{    return cpos == chars.length;}
7b707b4edb6b21046337feff2eae42cc446b607d46bf87012d44493f0b487f20
generate
public static void generate(Encoder vw, String calls, Object[] values) throws IOException
{    InputScanner cs = new InputScanner(calls.toCharArray());    int p = 0;    while (!cs.isDone()) {        char c = cs.cur();        cs.next();        switch(c) {            case 'N':                vw.writeNull();                break;            case 'B':                boolean b = (Boolean) values[p++];                vw.writeBoolean(b);                break;            case 'I':                int ii = (Integer) values[p++];                vw.writeInt(ii);                break;            case 'L':                long l = (Long) values[p++];                vw.writeLong(l);                break;            case 'F':                float f = (Float) values[p++];                vw.writeFloat(f);                break;            case 'D':                double d = (Double) values[p++];                vw.writeDouble(d);                break;            case 'S':                {                    extractInt(cs);                    String s = (String) values[p++];                    vw.writeString(new Utf8(s));                    break;                }            case 'K':                {                    extractInt(cs);                    String s = (String) values[p++];                    vw.writeString(s);                    break;                }            case 'b':                {                    extractInt(cs);                    byte[] bb = (byte[]) values[p++];                    vw.writeBytes(bb);                    break;                }            case 'f':                {                    extractInt(cs);                    byte[] bb = (byte[]) values[p++];                    vw.writeFixed(bb);                    break;                }            case 'e':                {                    int e = extractInt(cs);                    vw.writeEnum(e);                    break;                }            case '[':                vw.writeArrayStart();                break;            case ']':                vw.writeArrayEnd();                break;            case '{':                vw.writeMapStart();                break;            case '}':                vw.writeMapEnd();                break;            case 'c':                vw.setItemCount(extractInt(cs));                break;            case 's':                vw.startItem();                break;            case 'U':                {                    vw.writeIndex(extractInt(cs));                    break;                }            default:                fail();                break;        }    }}
f2e73e7efdde0b1f1c2d1620ef4a905430dbe6b23f21416c843bf743849d43b4
randomValues
public static Object[] randomValues(String calls)
{    Random r = new Random(0L);    InputScanner cs = new InputScanner(calls.toCharArray());    List<Object> result = new ArrayList<>();    while (!cs.isDone()) {        char c = cs.cur();        cs.next();        switch(c) {            case 'N':                break;            case 'B':                result.add(r.nextBoolean());                break;            case 'I':                result.add(r.nextInt());                break;            case 'L':                result.add((long) r.nextInt());                break;            case 'F':                result.add((float) r.nextInt());                break;            case 'D':                result.add((double) r.nextInt());                break;            case 'S':            case 'K':                result.add(nextString(r, extractInt(cs)));                break;            case 'b':            case 'f':                result.add(nextBytes(r, extractInt(cs)));                break;            case 'e':            case 'c':            case 'U':                extractInt(cs);            case '[':            case ']':            case '{':            case '}':            case 's':                break;            default:                fail();                break;        }    }    return result.toArray();}
e5d05cac2606890f8abd222c4f0d16fc9f7a25d3e236cc54acf89378165dfe0d
extractInt
private static int extractInt(InputScanner sc)
{    int r = 0;    while (!sc.isDone()) {        if (Character.isDigit(sc.cur())) {            r = r * 10 + sc.cur() - '0';            sc.next();        } else {            break;        }    }    return r;}
9cba15d89d22b952377dd5787c5f54e5608960b1205291af46750f3a48fe9e7d
nextBytes
private static byte[] nextBytes(Random r, int length)
{    byte[] bb = new byte[length];    r.nextBytes(bb);    return bb;}
aae287943af9994635af39ec09d3aeaaa1669dc948ddb274540d48841f1f657d
nextString
private static String nextString(Random r, int length)
{    char[] cc = new char[length];    for (int i = 0; i < length; i++) {        cc[i] = (char) ('A' + r.nextInt(26));    }    return new String(cc);}
2adaad04964b1898ca24d19c361ca418c8eda2487badc263c5ad1a150892eb22
check
private static void check(Schema sc, byte[] bytes, String calls, Object[] values, final int skipLevel, Encoding encoding) throws IOException
{            Decoder bvi = null;    switch(encoding) {        case BINARY:        case BLOCKING_BINARY:            bvi = DecoderFactory.get().binaryDecoder(bytes, null);            break;        case JSON:            InputStream in = new ByteArrayInputStream(bytes);            bvi = new JsonDecoder(sc, in);    }    Decoder vi = new ValidatingDecoder(sc, bvi);    String msg = "Error in validating case: " + sc;    check(msg, vi, calls, values, skipLevel);}
3c21818ce8cfd3971f429e484ada603a46e1eef46d50dbb32a3ad5ad0f51dedb
check
public static void check(String msg, Decoder vi, String calls, Object[] values, final int skipLevel) throws IOException
{    InputScanner cs = new InputScanner(calls.toCharArray());    int p = 0;    int level = 0;    long[] counts = new long[100];    boolean[] isArray = new boolean[100];    boolean[] isEmpty = new boolean[100];    while (!cs.isDone()) {        final char c = cs.cur();        cs.next();        try {            switch(c) {                case 'N':                    vi.readNull();                    break;                case 'B':                    assertEquals(msg, values[p++], vi.readBoolean());                    break;                case 'I':                    assertEquals(msg, values[p++], vi.readInt());                    break;                case 'L':                    assertEquals(msg, values[p++], vi.readLong());                    break;                case 'F':                    if (!(values[p] instanceof Float))                        fail();                    float f = (Float) values[p++];                    assertEquals(msg, f, vi.readFloat(), Math.abs(f / 1000));                    break;                case 'D':                    if (!(values[p] instanceof Double))                        fail();                    double d = (Double) values[p++];                    assertEquals(msg, d, vi.readDouble(), Math.abs(d / 1000));                    break;                case 'S':                    extractInt(cs);                    if (level == skipLevel) {                        vi.skipString();                        p++;                    } else {                        String s = (String) values[p++];                        assertEquals(msg, new Utf8(s), vi.readString(null));                    }                    break;                case 'K':                    extractInt(cs);                    if (level == skipLevel) {                        vi.skipString();                        p++;                    } else {                        String s = (String) values[p++];                        assertEquals(msg, new Utf8(s), vi.readString(null));                    }                    break;                case 'b':                    extractInt(cs);                    if (level == skipLevel) {                        vi.skipBytes();                        p++;                    } else {                        byte[] bb = (byte[]) values[p++];                        ByteBuffer bb2 = vi.readBytes(null);                        byte[] actBytes = new byte[bb2.remaining()];                        System.arraycopy(bb2.array(), bb2.position(), actBytes, 0, bb2.remaining());                        assertArrayEquals(msg, bb, actBytes);                    }                    break;                case 'f':                    {                        int len = extractInt(cs);                        if (level == skipLevel) {                            vi.skipFixed(len);                            p++;                        } else {                            byte[] bb = (byte[]) values[p++];                            byte[] actBytes = new byte[len];                            vi.readFixed(actBytes);                            assertArrayEquals(msg, bb, actBytes);                        }                    }                    break;                case 'e':                    {                        int e = extractInt(cs);                        if (level == skipLevel) {                            vi.readEnum();                        } else {                            assertEquals(msg, e, vi.readEnum());                        }                    }                    break;                case '[':                    if (level == skipLevel) {                        p += skip(msg, cs, vi, true);                        break;                    } else {                        level++;                        counts[level] = vi.readArrayStart();                        isArray[level] = true;                        isEmpty[level] = counts[level] == 0;                        continue;                    }                case '{':                    if (level == skipLevel) {                        p += skip(msg, cs, vi, false);                        break;                    } else {                        level++;                        counts[level] = vi.readMapStart();                        isArray[level] = false;                        isEmpty[level] = counts[level] == 0;                        continue;                    }                case ']':                    assertEquals(msg, 0, counts[level]);                    if (!isEmpty[level]) {                        assertEquals(msg, 0, vi.arrayNext());                    }                    level--;                    break;                case '}':                    assertEquals(0, counts[level]);                    if (!isEmpty[level]) {                        assertEquals(msg, 0, vi.mapNext());                    }                    level--;                    break;                case 's':                    if (counts[level] == 0) {                        if (isArray[level]) {                            counts[level] = vi.arrayNext();                        } else {                            counts[level] = vi.mapNext();                        }                    }                    counts[level]--;                    continue;                case 'c':                    extractInt(cs);                    continue;                case 'U':                    {                        int idx = extractInt(cs);                        assertEquals(msg, idx, vi.readIndex());                        continue;                    }                case 'R':                    ((ResolvingDecoder) vi).readFieldOrder();                    continue;                default:                    fail(msg);            }        } catch (RuntimeException e) {            throw new RuntimeException(msg, e);        }    }    assertEquals(msg, values.length, p);}
500cc5272a80c3eb017c34a14c6c974b489f5fa42356c640dbb90761eb7bc922
skip
private static int skip(String msg, InputScanner cs, Decoder vi, boolean isArray) throws IOException
{    final char end = isArray ? ']' : '}';    if (isArray) {        assertEquals(msg, 0, vi.skipArray());    } else if (end == '}') {        assertEquals(msg, 0, vi.skipMap());    }    int level = 0;    int p = 0;    while (!cs.isDone()) {        char c = cs.cur();        cs.next();        switch(c) {            case '[':            case '{':                ++level;                break;            case ']':            case '}':                if (c == end && level == 0) {                    return p;                }                level--;                break;            case 'B':            case 'I':            case 'L':            case 'F':            case 'D':            case 'S':            case 'K':            case 'b':            case 'f':            case 'e':                p++;                break;        }    }    throw new RuntimeException("Don't know how to skip");}
e159cd20e5d846e508be922f0450be0db638ed2ba32c3229ae07c0ea68938d77
data
public static Collection<Object[]> data()
{    return Arrays.asList(convertTo2dArray(encodings, skipLevels, testSchemas()));}
8da5d6453f3b542fba1317a3f490d6a404c7f49724faf454b975cf9bb50248e8
convertTo2dArray
public static Object[][] convertTo2dArray(final Object[][]... values)
{    ArrayList<Object[]> ret = new ArrayList<>();    Iterator<Object[]> iter = cartesian(values);    while (iter.hasNext()) {        Object[] objects = iter.next();        ret.add(objects);    }    Object[][] retArrays = new Object[ret.size()][];    for (int i = 0; i < ret.size(); i++) {        retArrays[i] = ret.get(i);    }    return retArrays;}
5e8cc41b16d7079a3e2a65e40efe46f15aebd1030814ca886a5a0b952c02b22d
cartesian
public static Iterator<Object[]> cartesian(final Object[][]... values)
{    return new Iterator<Object[]>() {        private int[] pos = new int[values.length];        @Override        public boolean hasNext() {            return pos[0] < values[0].length;        }        @Override        public Object[] next() {            Object[][] v = new Object[values.length][];            for (int i = 0; i < v.length; i++) {                v[i] = values[i][pos[i]];            }            for (int i = v.length - 1; i >= 0; i--) {                if (++pos[i] == values[i].length) {                    if (i != 0) {                        pos[i] = 0;                    }                } else {                    break;                }            }            return concat(v);        }        @Override        public void remove() {            throw new UnsupportedOperationException();        }    };}
d51e5f7450eca0a0f63da1a466189e262d053b84aa767ba3be5cea740af7251b
hasNext
public boolean hasNext()
{    return pos[0] < values[0].length;}
b24f8b94faa75a3b2128d649a63e9f3bfbc84a0b7e1689e89eab0990818dfbe2
next
public Object[] next()
{    Object[][] v = new Object[values.length][];    for (int i = 0; i < v.length; i++) {        v[i] = values[i][pos[i]];    }    for (int i = v.length - 1; i >= 0; i--) {        if (++pos[i] == values[i].length) {            if (i != 0) {                pos[i] = 0;            }        } else {            break;        }    }    return concat(v);}
eb35e4acc0ab2c89fd30970f01fba35488b3a4581b2af1986091209043508a3e
remove
public void remove()
{    throw new UnsupportedOperationException();}
bbd186a334b5014c7d0c8d68eb0c7d648208873b9e9ff308635862f97b0387f9
concat
public static Object[] concat(Object[]... oo)
{    int l = 0;    for (Object[] o : oo) {        l += o.length;    }    Object[] result = new Object[l];    l = 0;    for (Object[] o : oo) {        System.arraycopy(o, 0, result, l, o.length);        l += o.length;    }    return result;}
3aa7548031d180c1187e9f2ccd2204ceacac554ce2e68cab3b0cdaab54a16997
paste
 static Object[][] paste(Object[][]... in)
{    Object[][] result = new Object[in[0].length][];    Object[][] cc = new Object[in.length][];    for (int i = 0; i < result.length; i++) {        for (int j = 0; j < cc.length; j++) {            cc[j] = in[j][i];        }        result[i] = concat(cc);    }    return result;}
f4d8c65a5e4e446d3761fc1f5c311c03184ba77eb997c1145c0b1117d27003fa
testSchemas
public static Object[][] testSchemas()
{    /**     * The first argument is a schema. The second one is a sequence of (single     * character) mnemonics: N null B boolean I int L long F float D double K     * followed by integer - key-name (and its length) in a map S followed by     * integer - string and its length b followed by integer - bytes and length f     * followed by integer - fixed and length c Number of items to follow in an     * array/map. U followed by integer - Union and its branch e followed by integer     * - Enum and its value [ Start array ] End array { Start map } End map s start     * item     */    return new Object[][] { { "\"null\"", "N" }, { "\"boolean\"", "B" }, { "\"int\"", "I" }, { "\"long\"", "L" }, { "\"float\"", "F" }, { "\"double\"", "D" }, { "\"string\"", "S0" }, { "\"string\"", "S10" }, { "\"bytes\"", "b0" }, { "\"bytes\"", "b10" }, { "{\"type\":\"fixed\", \"name\":\"fi\", \"size\": 1}", "f1" }, { "{\"type\":\"fixed\", \"name\":\"fi\", \"size\": 10}", "f10" }, { "{\"type\":\"enum\", \"name\":\"en\", \"symbols\":[\"v1\", \"v2\"]}", "e1" }, { "{\"type\":\"array\", \"items\": \"boolean\"}", "[]" }, { "{\"type\":\"array\", \"items\": \"int\"}", "[]" }, { "{\"type\":\"array\", \"items\": \"long\"}", "[]" }, { "{\"type\":\"array\", \"items\": \"float\"}", "[]" }, { "{\"type\":\"array\", \"items\": \"double\"}", "[]" }, { "{\"type\":\"array\", \"items\": \"string\"}", "[]" }, { "{\"type\":\"array\", \"items\": \"bytes\"}", "[]" }, { "{\"type\":\"array\", \"items\":{\"type\":\"fixed\", " + "\"name\":\"fi\", \"size\": 10}}", "[]" }, { "{\"type\":\"array\", \"items\": \"boolean\"}", "[c1sB]" }, { "{\"type\":\"array\", \"items\": \"int\"}", "[c1sI]" }, { "{\"type\":\"array\", \"items\": \"long\"}", "[c1sL]" }, { "{\"type\":\"array\", \"items\": \"float\"}", "[c1sF]" }, { "{\"type\":\"array\", \"items\": \"double\"}", "[c1sD]" }, { "{\"type\":\"array\", \"items\": \"string\"}", "[c1sS10]" }, { "{\"type\":\"array\", \"items\": \"bytes\"}", "[c1sb10]" }, { "{\"type\":\"array\", \"items\": \"int\"}", "[c1sIc1sI]" }, { "{\"type\":\"array\", \"items\": \"int\"}", "[c2sIsI]" }, { "{\"type\":\"array\", \"items\":{\"type\":\"fixed\", " + "\"name\":\"fi\", \"size\": 10}}", "[c2sf10sf10]" }, { "{\"type\":\"map\", \"values\": \"boolean\"}", "{}" }, { "{\"type\":\"map\", \"values\": \"int\"}", "{}" }, { "{\"type\":\"map\", \"values\": \"long\"}", "{}" }, { "{\"type\":\"map\", \"values\": \"float\"}", "{}" }, { "{\"type\":\"map\", \"values\": \"double\"}", "{}" }, { "{\"type\":\"map\", \"values\": \"string\"}", "{}" }, { "{\"type\":\"map\", \"values\": \"bytes\"}", "{}" }, { "{\"type\":\"map\", \"values\": " + "{\"type\":\"array\", \"items\":\"int\"}}", "{}" }, { "{\"type\":\"map\", \"values\": \"boolean\"}", "{c1sK5B}" }, { "{\"type\":\"map\", \"values\": \"int\"}", "{c1sK5I}" }, { "{\"type\":\"map\", \"values\": \"long\"}", "{c1sK5L}" }, { "{\"type\":\"map\", \"values\": \"float\"}", "{c1sK5F}" }, { "{\"type\":\"map\", \"values\": \"double\"}", "{c1sK5D}" }, { "{\"type\":\"map\", \"values\": \"string\"}", "{c1sK5S10}" }, { "{\"type\":\"map\", \"values\": \"bytes\"}", "{c1sK5b10}" }, { "{\"type\":\"map\", \"values\": " + "{\"type\":\"array\", \"items\":\"int\"}}", "{c1sK5[c3sIsIsI]}" }, { "{\"type\":\"map\", \"values\": \"boolean\"}", "{c1sK5Bc2sK5BsK5B}" }, { "{\"type\":\"record\",\"name\":\"r\",\"fields\":[" + "{\"name\":\"f\", \"type\":\"boolean\"}]}", "B" }, { "{\"type\":\"record\",\"name\":\"r\",\"fields\":[" + "{\"name\":\"f\", \"type\":\"int\"}]}", "I" }, { "{\"type\":\"record\",\"name\":\"r\",\"fields\":[" + "{\"name\":\"f\", \"type\":\"long\"}]}", "L" }, { "{\"type\":\"record\",\"name\":\"r\",\"fields\":[" + "{\"name\":\"f\", \"type\":\"float\"}]}", "F" }, { "{\"type\":\"record\",\"name\":\"r\",\"fields\":[" + "{\"name\":\"f\", \"type\":\"double\"}]}", "D" }, { "{\"type\":\"record\",\"name\":\"r\",\"fields\":[" + "{\"name\":\"f\", \"type\":\"string\"}]}", "S10" }, { "{\"type\":\"record\",\"name\":\"r\",\"fields\":[" + "{\"name\":\"f\", \"type\":\"bytes\"}]}", "b10" },     { "{\"type\":\"record\",\"name\":\"r\",\"fields\":[" + "{\"name\":\"f1\", \"type\":\"int\"}," + "{\"name\":\"f2\", \"type\":\"double\"}," + "{\"name\":\"f3\", \"type\":\"string\"}]}", "IDS10" }, { "{\"type\":\"record\",\"name\":\"r\",\"fields\":[" + "{\"name\":\"f0\", \"type\":\"null\"}," + "{\"name\":\"f1\", \"type\":\"boolean\"}," + "{\"name\":\"f2\", \"type\":\"int\"}," + "{\"name\":\"f3\", \"type\":\"long\"}," + "{\"name\":\"f4\", \"type\":\"float\"}," + "{\"name\":\"f5\", \"type\":\"double\"}," + "{\"name\":\"f6\", \"type\":\"string\"}," + "{\"name\":\"f7\", \"type\":\"bytes\"}]}", "NBILFDS10b25" },     { "{\"type\":\"record\",\"name\":\"outer\",\"fields\":[" + "{\"name\":\"f1\", \"type\":{\"type\":\"record\", " + "\"name\":\"inner\", \"fields\":[" + "{\"name\":\"g1\", \"type\":\"int\"}, {\"name\":\"g2\", " + "\"type\":\"double\"}]}}," + "{\"name\":\"f2\", \"type\":\"string\"}," + "{\"name\":\"f3\", \"type\":\"inner\"}]}", "IDS10ID" },     { "{\"type\":\"record\",\"name\":\"r\",\"fields\":[" + "{\"name\":\"f1\", \"type\":\"long\"}," + "{\"name\":\"f2\", " + "\"type\":{\"type\":\"array\", \"items\":\"int\"}}]}", "L[c1sI]" },     { "{\"type\":\"record\",\"name\":\"r\",\"fields\":[" + "{\"name\":\"f1\", \"type\":\"long\"}," + "{\"name\":\"f2\", " + "\"type\":{\"type\":\"map\", \"values\":\"int\"}}]}", "L{c1sK5I}" },     { "{\"type\":\"array\", \"items\":" + "{\"type\":\"record\",\"name\":\"r\",\"fields\":[" + "{\"name\":\"f1\", \"type\":\"long\"}," + "{\"name\":\"f2\", \"type\":\"null\"}]}}", "[c2sLNsLN]" }, { "{\"type\":\"array\", \"items\":" + "{\"type\":\"record\",\"name\":\"r\",\"fields\":[" + "{\"name\":\"f1\", \"type\":\"long\"}," + "{\"name\":\"f2\", " + "\"type\":{\"type\":\"array\", \"items\":\"int\"}}]}}", "[c2sL[c1sI]sL[c2sIsI]]" }, { "{\"type\":\"array\", \"items\":" + "{\"type\":\"record\",\"name\":\"r\",\"fields\":[" + "{\"name\":\"f1\", \"type\":\"long\"}," + "{\"name\":\"f2\", " + "\"type\":{\"type\":\"map\", \"values\":\"int\"}}]}}", "[c2sL{c1sK5I}sL{c2sK5IsK5I}]" }, { "{\"type\":\"array\", \"items\":" + "{\"type\":\"record\",\"name\":\"r\",\"fields\":[" + "{\"name\":\"f1\", \"type\":\"long\"}," + "{\"name\":\"f2\", " + "\"type\":[\"null\", \"int\"]}]}}", "[c2sLU0NsLU1I]" }, { "[\"boolean\"]", "U0B" }, { "[\"int\"]", "U0I" }, { "[\"long\"]", "U0L" }, { "[\"float\"]", "U0F" }, { "[\"double\"]", "U0D" }, { "[\"string\"]", "U0S10" }, { "[\"bytes\"]", "U0b10" }, { "[\"null\", \"int\"]", "U0N" }, { "[\"boolean\", \"int\"]", "U0B" }, { "[\"boolean\", \"int\"]", "U1I" }, { "[\"boolean\", {\"type\":\"array\", \"items\":\"int\"} ]", "U0B" }, { "[\"boolean\", {\"type\":\"array\", \"items\":\"int\"} ]", "U1[c1sI]" },     { "{\"type\": \"record\", \"name\": \"Node\", \"fields\": [" + "{\"name\":\"label\", \"type\":\"string\"}," + "{\"name\":\"children\", \"type\":" + "{\"type\": \"array\", \"items\": \"Node\" }}]}", "S10[c1sS10[]]" }, { "{\"type\": \"record\", \"name\": \"Lisp\", \"fields\": [" + "{\"name\":\"value\", \"type\":[\"null\", \"string\"," + "{\"type\": \"record\", \"name\": \"Cons\", \"fields\": [" + "{\"name\":\"car\", \"type\":\"Lisp\"}," + "{\"name\":\"cdr\", \"type\":\"Lisp\"}]}]}]}", "U0N" }, { "{\"type\": \"record\", \"name\": \"Lisp\", \"fields\": [" + "{\"name\":\"value\", \"type\":[\"null\", \"string\"," + "{\"type\": \"record\", \"name\": \"Cons\", \"fields\": [" + "{\"name\":\"car\", \"type\":\"Lisp\"}," + "{\"name\":\"cdr\", \"type\":\"Lisp\"}]}]}]}", "U1S10" }, { "{\"type\": \"record\", \"name\": \"Lisp\", \"fields\": [" + "{\"name\":\"value\", \"type\":[\"null\", \"string\"," + "{\"type\": \"record\", \"name\": \"Cons\", \"fields\": [" + "{\"name\":\"car\", \"type\":\"Lisp\"}," + "{\"name\":\"cdr\", \"type\":\"Lisp\"}]}]}]}", "U2U1S10U0N" },     { "{\"type\": \"record\", \"name\": \"Node\", \"fields\": [" + "{\"name\":\"children\", \"type\":" + "{\"type\": \"array\", \"items\": \"Node\" }}]}", "[c1s[c1s[c1s[c1s[c1s[c1s[c1s[c1s[c1s[c1s[c1s[]]]]]]]]]]]]" } };}
e3db5627fe29701c24734610060a2f682352d91dc51759eff7e34169793c8b0e
dump
 static void dump(byte[] bb)
{    int col = 0;    for (byte b : bb) {        if (col % 16 == 0) {            System.out.println();        }        col++;        System.out.print(Integer.toHexString(b & 0xff) + " ");    }    System.out.println();}
9c820914cc559d31eab6763863b8dfad0e54d86fe241f4aaed1a8cbb0367c3ad
print
 static void print(Encoding encoding, int skipLevel, Schema writerSchema, Schema readerSchema, Object[] writtenValues, Object[] expectedValues)
{    LOG.debug("{} Skip Level {}", encoding, skipLevel);    printSchemaAndValues("Writer", writerSchema, writtenValues);    printSchemaAndValues("Reader", readerSchema, expectedValues);}
3eaf3d8697500c15596fbbc778c883a7ac104144db6e26686bc8d75c18962449
printSchemaAndValues
private static void printSchemaAndValues(String schemaType, Schema schema, Object[] values)
{    LOG.debug("{} Schema {}", schemaType, schema);    for (Object value : values) {        LOG.debug("{} -> {}", value, value.getClass().getSimpleName());    }}
3fe22573781172784b47b94280c5d68d18961c4a24a78c3d4ece762799640001
testByteBufferRoundTrip
public void testByteBufferRoundTrip() throws Exception
{    MessageEncoder<Record> encoder = new BinaryMessageEncoder<>(GenericData.get(), SCHEMA_V2);    MessageDecoder<Record> decoder = new BinaryMessageDecoder<>(GenericData.get(), SCHEMA_V2);    Record copy = decoder.decode(encoder.encode(V2_RECORDS.get(0)));    Assert.assertNotSame("Copy should not be the same object", copy, V2_RECORDS.get(0));    Assert.assertEquals("Record should be identical after round-trip", V2_RECORDS.get(0), copy);}
8d0afd848123f90889fd1ed2998206698a9b0d2d93f6b0cd48f38c04def6c67c
testSchemaEvolution
public void testSchemaEvolution() throws Exception
{    List<ByteBuffer> buffers = new ArrayList<>();    List<Record> records = new ArrayList<>();    records.addAll(V1_RECORDS);    records.addAll(V2_RECORDS);    MessageEncoder<Record> v1Encoder = new BinaryMessageEncoder<>(GenericData.get(), SCHEMA_V1);    MessageEncoder<Record> v2Encoder = new BinaryMessageEncoder<>(GenericData.get(), SCHEMA_V2);    for (Record record : records) {        if (record.getSchema().equals(SCHEMA_V1)) {            buffers.add(v1Encoder.encode(record));        } else {            buffers.add(v2Encoder.encode(record));        }    }    Set<Record> allAsV2 = new HashSet<>(V2_RECORDS);    allAsV2.add(V2_BUILDER.set("id", 1L).set("message", "m-1").clear("data").build());    allAsV2.add(V2_BUILDER.set("id", 2L).set("message", "m-2").clear("data").build());    allAsV2.add(V2_BUILDER.set("id", 4L).set("message", "m-4").clear("data").build());    allAsV2.add(V2_BUILDER.set("id", 6L).set("message", "m-6").clear("data").build());    BinaryMessageDecoder<Record> v2Decoder = new BinaryMessageDecoder<>(GenericData.get(), SCHEMA_V2);    v2Decoder.addSchema(SCHEMA_V1);    Set<Record> decodedUsingV2 = new HashSet<>();    for (ByteBuffer buffer : buffers) {        decodedUsingV2.add(v2Decoder.decode(buffer));    }    Assert.assertEquals(allAsV2, decodedUsingV2);}
a5e3fb827e9aacc54e2832b1d8619413fdbeda3d760bfd500b53daf2b3bf48c0
testCompatibleReadFailsWithoutSchema
public void testCompatibleReadFailsWithoutSchema() throws Exception
{    MessageEncoder<Record> v1Encoder = new BinaryMessageEncoder<>(GenericData.get(), SCHEMA_V1);    BinaryMessageDecoder<Record> v2Decoder = new BinaryMessageDecoder<>(GenericData.get(), SCHEMA_V2);    ByteBuffer v1Buffer = v1Encoder.encode(V1_RECORDS.get(3));    v2Decoder.decode(v1Buffer);}
a7137b0f163a4906dfeeb9f768545dcaf2eaf846e15e89bc7c20ddcc231df963
testCompatibleReadWithSchema
public void testCompatibleReadWithSchema() throws Exception
{    MessageEncoder<Record> v1Encoder = new BinaryMessageEncoder<>(GenericData.get(), SCHEMA_V1);    BinaryMessageDecoder<Record> v2Decoder = new BinaryMessageDecoder<>(GenericData.get(), SCHEMA_V2);    v2Decoder.addSchema(SCHEMA_V1);    ByteBuffer v1Buffer = v1Encoder.encode(V1_RECORDS.get(3));    Record record = v2Decoder.decode(v1Buffer);    Assert.assertEquals(V2_BUILDER.set("id", 6L).set("message", "m-6").clear("data").build(), record);}
5a84dae8371d3d6dc6c78b93734faf8df2849c03cba28efd51bd74d1fe67845f
testCompatibleReadWithSchemaFromLookup
public void testCompatibleReadWithSchemaFromLookup() throws Exception
{    MessageEncoder<Record> v1Encoder = new BinaryMessageEncoder<>(GenericData.get(), SCHEMA_V1);    SchemaStore.Cache schemaCache = new SchemaStore.Cache();    schemaCache.addSchema(SCHEMA_V1);    BinaryMessageDecoder<Record> v2Decoder = new BinaryMessageDecoder<>(GenericData.get(), SCHEMA_V2, schemaCache);    ByteBuffer v1Buffer = v1Encoder.encode(V1_RECORDS.get(2));    Record record = v2Decoder.decode(v1Buffer);    Assert.assertEquals(V2_BUILDER.set("id", 4L).set("message", "m-4").clear("data").build(), record);}
3de621fd75e9ed9af920ee88209e15880637d0a2c07c860eeb5a405a536002cd
testIdenticalReadWithSchemaFromLookup
public void testIdenticalReadWithSchemaFromLookup() throws Exception
{    MessageEncoder<Record> v1Encoder = new BinaryMessageEncoder<>(GenericData.get(), SCHEMA_V1);    SchemaStore.Cache schemaCache = new SchemaStore.Cache();    schemaCache.addSchema(SCHEMA_V1);            BinaryMessageDecoder<Record> genericDecoder = new BinaryMessageDecoder<>(GenericData.get(), null, schemaCache);    ByteBuffer v1Buffer = v1Encoder.encode(V1_RECORDS.get(2));    Record record = genericDecoder.decode(v1Buffer);    Assert.assertEquals(V1_RECORDS.get(2), record);}
2bf95fd11c6e27fa0f8deafb9b73a2a997c024aadaa16e76fbc1d45664220bd8
testBufferReuse
public void testBufferReuse() throws Exception
{                MessageEncoder<Record> encoder = new BinaryMessageEncoder<>(GenericData.get(), SCHEMA_V1, false);    ByteBuffer b0 = encoder.encode(V1_RECORDS.get(0));    ByteBuffer b1 = encoder.encode(V1_RECORDS.get(1));    Assert.assertEquals(b0.array(), b1.array());    MessageDecoder<Record> decoder = new BinaryMessageDecoder<>(GenericData.get(), SCHEMA_V1);    Assert.assertEquals("Buffer was reused, decode(b0) should be record 1", V1_RECORDS.get(1), decoder.decode(b0));}
36218d7667e6442752258c10dfec3b4650a2a57419ba5102968174d385904d7d
testBufferCopy
public void testBufferCopy() throws Exception
{    MessageEncoder<Record> encoder = new BinaryMessageEncoder<>(GenericData.get(), SCHEMA_V1);    ByteBuffer b0 = encoder.encode(V1_RECORDS.get(0));    ByteBuffer b1 = encoder.encode(V1_RECORDS.get(1));    Assert.assertNotEquals(b0.array(), b1.array());    MessageDecoder<Record> decoder = new BinaryMessageDecoder<>(GenericData.get(), SCHEMA_V1);        Assert.assertEquals("Buffer was copied, decode(b0) should be record 0", V1_RECORDS.get(0), decoder.decode(b0));}
2e2cef6a488212c6c839bde3b19d25c37aef06fe1cfde3bd148167ba5a280d11
testByteBufferMissingPayload
public void testByteBufferMissingPayload() throws Exception
{    MessageEncoder<Record> encoder = new BinaryMessageEncoder<>(GenericData.get(), SCHEMA_V2);    MessageDecoder<Record> decoder = new BinaryMessageDecoder<>(GenericData.get(), SCHEMA_V2);    ByteBuffer buffer = encoder.encode(V2_RECORDS.get(0));    buffer.limit(12);    decoder.decode(buffer);}
b30d8c8bbd598bdcc38211817edf62f589a1d59f1cab7fbe90876eefd19810bf
testByteBufferMissingFullHeader
public void testByteBufferMissingFullHeader() throws Exception
{    MessageEncoder<Record> encoder = new BinaryMessageEncoder<>(GenericData.get(), SCHEMA_V2);    MessageDecoder<Record> decoder = new BinaryMessageDecoder<>(GenericData.get(), SCHEMA_V2);    ByteBuffer buffer = encoder.encode(V2_RECORDS.get(0));    buffer.limit(8);    decoder.decode(buffer);}
31e2aca472359cf1db79414bc79ecd73f35cdd4932e62572a9708255784b3883
testByteBufferBadMarkerByte
public void testByteBufferBadMarkerByte() throws Exception
{    MessageEncoder<Record> encoder = new BinaryMessageEncoder<>(GenericData.get(), SCHEMA_V2);    MessageDecoder<Record> decoder = new BinaryMessageDecoder<>(GenericData.get(), SCHEMA_V2);    ByteBuffer buffer = encoder.encode(V2_RECORDS.get(0));    buffer.array()[0] = 0x00;    decoder.decode(buffer);}
89fca15e8791c23240ec95f2f0d5d4bef0ddc0902b4379ff7a925070cd89fadb
testByteBufferBadVersionByte
public void testByteBufferBadVersionByte() throws Exception
{    MessageEncoder<Record> encoder = new BinaryMessageEncoder<>(GenericData.get(), SCHEMA_V2);    MessageDecoder<Record> decoder = new BinaryMessageDecoder<>(GenericData.get(), SCHEMA_V2);    ByteBuffer buffer = encoder.encode(V2_RECORDS.get(0));    buffer.array()[1] = 0x00;    decoder.decode(buffer);}
064cd74178b489494416c1b64aad4a1b56ff0820fb50bab07434e761a80cdd84
testByteBufferUnknownSchema
public void testByteBufferUnknownSchema() throws Exception
{    MessageEncoder<Record> encoder = new BinaryMessageEncoder<>(GenericData.get(), SCHEMA_V2);    MessageDecoder<Record> decoder = new BinaryMessageDecoder<>(GenericData.get(), SCHEMA_V2);    ByteBuffer buffer = encoder.encode(V2_RECORDS.get(0));    buffer.array()[4] = 0x00;    decoder.decode(buffer);}
41c4887fd0644c92bf90084dbf97a8963aaaf731d3995a7cdd1efd4d6bee1c68
before
public void before() throws IOException
{    content = new File(DIR.getRoot().getPath(), "test-content");    try (FileOutputStream out = new FileOutputStream(content)) {        for (int i = 0; i < 100000; i++) {            out.write("hello world\n".getBytes(UTF_8));        }    }}
ced3637227837bc8935023b279f6d11e541ba2dd6bbaff26ba3afa81b2fd1240
test
public void test() throws Exception
{    Schema schema = ReflectData.get().getSchema(X.class);    ByteArrayOutputStream bout = new ByteArrayOutputStream();    writeOneXAsAvro(schema, bout);    X record = readOneXFromAvro(schema, bout);    String expected = getmd5(content);    String actual = getmd5(record.content);    assertEquals("md5 for result differed from input", expected, actual);}
4728c12ccbebb5a751e27a4219362fb06b253f30d2ce535c6d51e4da3a8461b3
readOneXFromAvro
private X readOneXFromAvro(Schema schema, ByteArrayOutputStream bout) throws IOException
{    SeekableByteArrayInput input = new SeekableByteArrayInput(bout.toByteArray());    ReflectDatumReader<X> datumReader = new ReflectDatumReader<>(schema);    FileReader<X> reader = DataFileReader.openReader(input, datumReader);    Iterator<X> it = reader.iterator();    assertTrue("missing first record", it.hasNext());    X record = it.next();    assertFalse("should be no more records - only wrote one out", it.hasNext());    return record;}
4241bcfd61d5d21aa0931e8489abe980d3062928fa9b82e38260e58c2a35245d
writeOneXAsAvro
private void writeOneXAsAvro(Schema schema, ByteArrayOutputStream bout) throws IOException, FileNotFoundException
{    DatumWriter<X> datumWriter = new ReflectDatumWriter<>(schema);    try (DataFileWriter<X> writer = new DataFileWriter<>(datumWriter)) {        writer.create(schema, bout);        X x = new X();        x.name = "xxx";        try (FileInputStream fis = new FileInputStream(content)) {            try (FileChannel channel = fis.getChannel()) {                long contentLength = content.length();                                ByteBuffer buffer = channel.map(FileChannel.MapMode.READ_ONLY, 0, contentLength);                x.content = buffer;                writer.append(x);            }        }        writer.flush();    }}
d3bbffea452de2825a56ca27f75a3c3fc83149d0419197f5a843782ed16171b9
getmd5
private String getmd5(File content) throws Exception
{    try (FileInputStream fis = new FileInputStream(content)) {        try (FileChannel channel = fis.getChannel()) {            long contentLength = content.length();            ByteBuffer buffer = channel.map(FileChannel.MapMode.READ_ONLY, 0, contentLength);            return getmd5(buffer);        }    }}
9554dc6c5097724c45020ec7684c150a2a79cb3d7755cc54a1bc259d237da84d
getmd5
 String getmd5(ByteBuffer buffer) throws NoSuchAlgorithmException
{    MessageDigest mdEnc = MessageDigest.getInstance("MD5");    mdEnc.reset();    mdEnc.update(buffer);    return new BigInteger(1, mdEnc.digest()).toString(16);}
ab70eead3cc3dae36a81fcce718bd81d86f8ce337bcbddd04304094fb1c78494
testNonStringMapKeys
public void testNonStringMapKeys() throws Exception
{    Company entityObj1 = buildCompany();    Company entityObj2 = buildCompany();    String testType = "NonStringKeysTest";    Company[] entityObjs = { entityObj1, entityObj2 };    byte[] bytes = testSerialization(testType, entityObj1, entityObj2);    List<GenericRecord> records = testGenericDatumRead(testType, bytes, entityObjs);    GenericRecord record = records.get(0);    Object employees = record.get("employees");    assertTrue("Unable to read 'employees' map", employees instanceof GenericArray);    GenericArray arrayEmployees = ((GenericArray) employees);    Object employeeRecord = arrayEmployees.get(0);    assertTrue(employeeRecord instanceof GenericRecord);    Object key = ((GenericRecord) employeeRecord).get(ReflectData.NS_MAP_KEY);    Object value = ((GenericRecord) employeeRecord).get(ReflectData.NS_MAP_VALUE);    assertTrue(key instanceof GenericRecord);    assertTrue(value instanceof GenericRecord);        Object id = ((GenericRecord) key).get("id");    Object name = ((GenericRecord) value).get("name").toString();    assertTrue((id.equals(1) && name.equals("Foo")) || (id.equals(2) && name.equals("Bar")));    List<Company> records2 = testReflectDatumRead(testType, bytes, entityObjs);    Company co = records2.get(0);    log("Read: " + co);    assertNotNull(co.getEmployees());    assertEquals(2, co.getEmployees().size());    for (Entry<EmployeeId, EmployeeInfo> e : co.getEmployees().entrySet()) {        id = e.getKey().getId();        name = e.getValue().getName();        assertTrue((id.equals(1) && name.equals("Foo")) || (id.equals(2) && name.equals("Bar")));    }    byte[] jsonBytes = testJsonEncoder(testType, entityObj1);    assertNotNull("Unable to serialize using jsonEncoder", jsonBytes);    GenericRecord jsonRecord = testJsonDecoder(testType, jsonBytes, entityObj1);    assertEquals("JSON decoder output not same as Binary Decoder", record, jsonRecord);}
e8191029159a414af67173824f0128b585edf764047aa648ac7d7a1dc2ed01c3
testNonStringMapKeysInNestedMaps
public void testNonStringMapKeysInNestedMaps() throws Exception
{    Company2 entityObj1 = buildCompany2();    String testType = "NestedMapsTest";    Company2[] entityObjs = { entityObj1 };    byte[] bytes = testSerialization(testType, entityObj1);    List<GenericRecord> records = testGenericDatumRead(testType, bytes, entityObjs);    GenericRecord record = records.get(0);    Object employees = record.get("employees");    assertTrue("Unable to read 'employees' map", employees instanceof GenericArray);    GenericArray employeesMapArray = ((GenericArray) employees);    Object employeeMapElement = employeesMapArray.get(0);    assertTrue(employeeMapElement instanceof GenericRecord);    Object key = ((GenericRecord) employeeMapElement).get(ReflectData.NS_MAP_KEY);    Object value = ((GenericRecord) employeeMapElement).get(ReflectData.NS_MAP_VALUE);    assertEquals(11, key);    assertTrue(value instanceof GenericRecord);    GenericRecord employeeInfo = (GenericRecord) value;    Object name = employeeInfo.get("name").toString();    assertEquals("Foo", name);    Object companyMap = employeeInfo.get("companyMap");    assertTrue(companyMap instanceof GenericArray);    GenericArray companyMapArray = (GenericArray) companyMap;    Object companyMapElement = companyMapArray.get(0);    assertTrue(companyMapElement instanceof GenericRecord);    key = ((GenericRecord) companyMapElement).get(ReflectData.NS_MAP_KEY);    value = ((GenericRecord) companyMapElement).get(ReflectData.NS_MAP_VALUE);    assertEquals(14, key);    if (value instanceof Utf8)        value = ((Utf8) value).toString();    assertEquals("CompanyFoo", value);    List<Company2> records2 = testReflectDatumRead(testType, bytes, entityObjs);    Company2 co = records2.get(0);    log("Read: " + co);    assertNotNull(co.getEmployees());    assertEquals(1, co.getEmployees().size());    for (Entry<Integer, EmployeeInfo2> e : co.getEmployees().entrySet()) {        Integer id = e.getKey();        name = e.getValue().getName();        assertTrue(id.equals(11) && name.equals("Foo"));        assertEquals("CompanyFoo", e.getValue().companyMap.values().iterator().next());    }    byte[] jsonBytes = testJsonEncoder(testType, entityObj1);    assertNotNull("Unable to serialize using jsonEncoder", jsonBytes);    GenericRecord jsonRecord = testJsonDecoder(testType, jsonBytes, entityObj1);    assertEquals("JSON decoder output not same as Binary Decoder", record, jsonRecord);}
79ed4e41e02dba117bdc8f8f0fa8b03db742b3b66189f612f2b255e6fe8a91ba
testRecordNameInvariance
public void testRecordNameInvariance() throws Exception
{    SameMapSignature entityObj1 = buildSameMapSignature();    String testType = "RecordNameInvariance";    SameMapSignature[] entityObjs = { entityObj1 };    byte[] bytes = testSerialization(testType, entityObj1);    List<GenericRecord> records = testGenericDatumRead(testType, bytes, entityObjs);    GenericRecord record = records.get(0);    Object map1obj = record.get("map1");    assertTrue("Unable to read map1", map1obj instanceof GenericArray);    GenericArray map1array = ((GenericArray) map1obj);    Object map1element = map1array.get(0);    assertTrue(map1element instanceof GenericRecord);    Object key = ((GenericRecord) map1element).get(ReflectData.NS_MAP_KEY);    Object value = ((GenericRecord) map1element).get(ReflectData.NS_MAP_VALUE);    assertEquals(1, key);    assertEquals("Foo", value.toString());    Object map2obj = record.get("map2");    assertEquals(map1obj, map2obj);    List<SameMapSignature> records2 = testReflectDatumRead(testType, bytes, entityObjs);    SameMapSignature entity = records2.get(0);    log("Read: " + entity);    assertNotNull(entity.getMap1());    assertEquals(1, entity.getMap1().size());    for (Entry<Integer, String> e : entity.getMap1().entrySet()) {        key = e.getKey();        value = e.getValue();        assertEquals(1, key);        assertEquals("Foo", value.toString());    }    assertEquals(entity.getMap1(), entity.getMap2());    assertEquals(entity.getMap1(), entity.getMap3());    assertEquals(entity.getMap1(), entity.getMap4());    ReflectData rdata = ReflectData.get();    Schema schema = rdata.getSchema(SameMapSignature.class);    Schema map1schema = schema.getField("map1").schema().getElementType();    Schema map2schema = schema.getField("map2").schema().getElementType();    Schema map3schema = schema.getField("map3").schema().getElementType();    Schema map4schema = schema.getField("map4").schema().getElementType();    log("Schema for map1 = " + map1schema);    log("Schema for map2 = " + map2schema);    log("Schema for map3 = " + map3schema);    log("Schema for map4 = " + map4schema);    assertEquals(map1schema.getFullName(), "org.apache.avro.reflect.PairIntegerString");    assertEquals(map1schema, map2schema);    assertEquals(map1schema, map3schema);    assertEquals(map1schema, map4schema);    byte[] jsonBytes = testJsonEncoder(testType, entityObj1);    assertNotNull("Unable to serialize using jsonEncoder", jsonBytes);    GenericRecord jsonRecord = testJsonDecoder(testType, jsonBytes, entityObj1);    assertEquals("JSON decoder output not same as Binary Decoder", record.get("map1"), jsonRecord.get("map1"));    assertEquals("JSON decoder output not same as Binary Decoder", record.get("map2"), jsonRecord.get("map2"));}
43cd8fb78abc95186e0d40c357bf306321b3a0c12f0e897471b20e5590e35af0
testSerialization
public byte[] testSerialization(String testType, T... entityObjs) throws Exception
{    log("---- Beginning " + testType + " ----");    T entityObj1 = entityObjs[0];    ReflectData rdata = ReflectData.AllowNull.get();    Schema schema = rdata.getSchema(entityObj1.getClass());    assertNotNull("Unable to get schema for " + testType, schema);    log(schema.toString(true));    ReflectDatumWriter<T> datumWriter = new ReflectDatumWriter(entityObj1.getClass(), rdata);    DataFileWriter<T> fileWriter = new DataFileWriter<>(datumWriter);    ByteArrayOutputStream baos = new ByteArrayOutputStream();    fileWriter.create(schema, baos);    for (T entityObj : entityObjs) {        fileWriter.append(entityObj);    }    fileWriter.close();    byte[] bytes = baos.toByteArray();    return bytes;}
a9263fde522528315d0fb279974186a20b52028a1432fd2ff7606e2812e2b22e
testGenericDatumRead
private List<GenericRecord> testGenericDatumRead(String testType, byte[] bytes, T... entityObjs) throws IOException
{    GenericDatumReader<GenericRecord> datumReader = new GenericDatumReader<>();    SeekableByteArrayInput avroInputStream = new SeekableByteArrayInput(bytes);    DataFileReader<GenericRecord> fileReader = new DataFileReader<>(avroInputStream, datumReader);    Schema schema = fileReader.getSchema();    assertNotNull("Unable to get schema for " + testType, schema);    GenericRecord record = null;    List<GenericRecord> records = new ArrayList<>();    while (fileReader.hasNext()) {        try {            records.add(fileReader.next(record));        } catch (Exception e) {            fail("Fail with schema: " + schema);        }    }    return records;}
ae50228ce1a5280d25dc680070107e05c63d60c7bd112b56319a50bf21446647
testReflectDatumRead
private List<T> testReflectDatumRead(String testType, byte[] bytes, T... entityObjs) throws IOException
{    ReflectDatumReader<T> datumReader = new ReflectDatumReader<>();    SeekableByteArrayInput avroInputStream = new SeekableByteArrayInput(bytes);    DataFileReader<T> fileReader = new DataFileReader<>(avroInputStream, datumReader);    Schema schema = fileReader.getSchema();    T record = null;    List<T> records = new ArrayList<>();    while (fileReader.hasNext()) {        records.add(fileReader.next(record));    }    return records;}
bfbdc6d410768d7c1b1ff40014e4d6cbc30a1374fa84af8ead56389c3d425cf9
testJsonEncoder
private byte[] testJsonEncoder(String testType, T entityObj) throws IOException
{    ReflectData rdata = ReflectData.AllowNull.get();    Schema schema = rdata.getSchema(entityObj.getClass());    ByteArrayOutputStream os = new ByteArrayOutputStream();    Encoder encoder = EncoderFactory.get().jsonEncoder(schema, os);    ReflectDatumWriter<T> datumWriter = new ReflectDatumWriter<>(schema, rdata);    datumWriter.write(entityObj, encoder);    encoder.flush();    byte[] bytes = os.toByteArray();    System.out.println("JSON encoder output:\n" + new String(bytes, UTF_8));    return bytes;}
6b1347a7e1dd8855b245686ab4eef5a8e3b4d5ffc84d8088ad38fd5846a7e922
testJsonDecoder
private GenericRecord testJsonDecoder(String testType, byte[] bytes, T entityObj) throws IOException
{    ReflectData rdata = ReflectData.AllowNull.get();    Schema schema = rdata.getSchema(entityObj.getClass());    GenericDatumReader<GenericRecord> datumReader = new GenericDatumReader<>(schema);    Decoder decoder = DecoderFactory.get().jsonDecoder(schema, new String(bytes, UTF_8));    GenericRecord r = datumReader.read(null, decoder);    return r;}
2bb4959e7e2c04b417bd7631172f2f0b5e16079a436f79de9161ff5c64e8c73a
buildCompany
private Company buildCompany()
{    Company co = new Company();    HashMap<EmployeeId, EmployeeInfo> employees = new HashMap<>();    co.setEmployees(employees);    employees.put(new EmployeeId(1), new EmployeeInfo("Foo"));    employees.put(new EmployeeId(2), new EmployeeInfo("Bar"));    return co;}
722f554ab8fd2b9d69d69e6ef159fa19ce59d3e78e17cb86d864c335aea3d4ba
buildCompany2
private Company2 buildCompany2()
{    Company2 co = new Company2();    HashMap<Integer, EmployeeInfo2> employees = new HashMap<>();    co.setEmployees(employees);    EmployeeId2 empId = new EmployeeId2(1);    EmployeeInfo2 empInfo = new EmployeeInfo2("Foo");    HashMap<Integer, String> companyMap = new HashMap<>();    empInfo.setCompanyMap(companyMap);    companyMap.put(14, "CompanyFoo");    employees.put(11, empInfo);    return co;}
93c5c4a8aaf1c8c92590d727eecde2e6fb63f370ce78972f91d8790dc3334d07
buildSameMapSignature
private SameMapSignature buildSameMapSignature()
{    SameMapSignature obj = new SameMapSignature();    obj.setMap1(new HashMap<>());    obj.getMap1().put(1, "Foo");    obj.setMap2(new ConcurrentHashMap<>());    obj.getMap2().put(1, "Foo");    obj.setMap3(new LinkedHashMap<>());    obj.getMap3().put(1, "Foo");    obj.setMap4(new TreeMap<>());    obj.getMap4().put(1, "Foo");    return obj;}
b836f3680b807c3e1e4831a1b75a8929941ed841d2f532c75fdff0cd5f0be9af
log
private void log(String msg)
{    System.out.println(msg);}
e8b3489934603b3b6c1cb22df2c0571017e16c702aef6fb13c079a00e7eee5c9
getEmployees
public HashMap<EmployeeId, EmployeeInfo> getEmployees()
{    return employees;}
4f5ad5b2e2997e2c26b175e00aa053ebe928782e0667fe8d38af6e65bef243a2
setEmployees
public void setEmployees(HashMap<EmployeeId, EmployeeInfo> employees)
{    this.employees = employees;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "Company [employees=" + employees + "]";}
140d6b8c9b41cf799705c04bd96ae47dbc5c17d04361d67f59f707b39618275c
getId
public Integer getId()
{    return id;}
59a40580e301fc17b1c3006a2307086859ba0b99fe5a1cd4e97ab1f63dcc1eeb
setId
public void setId(Integer zip)
{    this.id = zip;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "EmployeeId [id=" + id + "]";}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return name;}
f498f22eaf0816bf385a43365651d1b6d0455905fdd2d6be01ceefeb84e8f432
setName
public void setName(String name)
{    this.name = name;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "EmployeeInfo [name=" + name + "]";}
b8378073d42b646fa613812401245384f910f541b35bd354162eb8badbbed33f
getEmployees
public HashMap<Integer, EmployeeInfo2> getEmployees()
{    return employees;}
62b44ae8f85f468f5c2b7fee835d2b8941a0583c8962d01e5a240144d1a298e7
setEmployees
public void setEmployees(HashMap<Integer, EmployeeInfo2> employees)
{    this.employees = employees;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "Company2 [employees=" + employees + "]";}
140d6b8c9b41cf799705c04bd96ae47dbc5c17d04361d67f59f707b39618275c
getId
public Integer getId()
{    return id;}
59a40580e301fc17b1c3006a2307086859ba0b99fe5a1cd4e97ab1f63dcc1eeb
setId
public void setId(Integer zip)
{    this.id = zip;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "EmployeeId2 [id=" + id + "]";}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return name;}
f498f22eaf0816bf385a43365651d1b6d0455905fdd2d6be01ceefeb84e8f432
setName
public void setName(String name)
{    this.name = name;}
e0623f946d390cf61c39c60060c407aee93c6095b5a26c18a97e519b841f0fb3
getCompanyMap
public HashMap<Integer, String> getCompanyMap()
{    return companyMap;}
61d667c4e8c5ed797af1f15c794d67d7872dfdc4423d044ffe6e403da01b3970
setCompanyMap
public void setCompanyMap(HashMap<Integer, String> companyMap)
{    this.companyMap = companyMap;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "EmployeeInfo2 [name=" + name + "]";}
87cce7932e377934bf008aa8524080141172777c5e786ab01f79476cfa6ececb
getMap1
public Map<Integer, String> getMap1()
{    return map1;}
cf19e061f095fe15f832a514b113d24e0a650c045c74fe565b49fdd2cc71781b
setMap1
public void setMap1(HashMap<Integer, String> map1)
{    this.map1 = map1;}
c64d6013a5aa65c9182545d07c9757d77dfab94c3414531fb070ac53681377fa
getMap2
public Map<Integer, String> getMap2()
{    return map2;}
888a5b13c0785b8c16e9bf36316818d7009532f45a611e7c8fc1c2d661aaa1d3
setMap2
public void setMap2(ConcurrentHashMap<Integer, String> map2)
{    this.map2 = map2;}
b32be610a83e45753cda2d6c665cbe8f2993503481d7c38d35ae92e606805828
getMap3
public Map<Integer, String> getMap3()
{    return map3;}
882578895f5738a83974aeb819c6a28e5994482eb3f6cb8c223fd4026dc94167
setMap3
public void setMap3(LinkedHashMap<Integer, String> map3)
{    this.map3 = map3;}
9d8bbeb0f58d63ff0b09ff5b53738efdd0a403561e8c91c3081bf236a53723da
getMap4
public Map<Integer, String> getMap4()
{    return map4;}
d9bb9e7aa0ac8e67810813c1601fc5bc6259aabcfb70d1521126539f802625d4
setMap4
public void setMap4(TreeMap<Integer, String> map4)
{    this.map4 = map4;}
63f4590394c97c2fa6ba78944dd62465c20da68490fd93327123cf76ba879768
testVoid
public void testVoid()
{    check(Void.TYPE, "\"null\"");    check(Void.class, "\"null\"");}
f7309da99bbf2f65fcc40413a07dc3116033c984e29575452667e56d8c0af727
testBoolean
public void testBoolean()
{    check(Boolean.TYPE, "\"boolean\"");    check(Boolean.class, "\"boolean\"");}
2f10d36bafbb2b3dfe9117c739286851614ea4b4edaacb4a39d77c0ba7e40abd
testInt
public void testInt()
{    check(Integer.TYPE, "\"int\"");    check(Integer.class, "\"int\"");}
83fafc0cf73f1c3fc8f1c90ab2ceb7c532b651f2d159ebbfdee16d4df6918c5d
testByte
public void testByte()
{    check(Byte.TYPE, "{\"type\":\"int\",\"java-class\":\"java.lang.Byte\"}");    check(Byte.class, "{\"type\":\"int\",\"java-class\":\"java.lang.Byte\"}");}
fba53a6b679fae5beaacfb33cc0cde1ce3d35fcaccc9150de53875abe89f56c2
testShort
public void testShort()
{    check(Short.TYPE, "{\"type\":\"int\",\"java-class\":\"java.lang.Short\"}");    check(Short.class, "{\"type\":\"int\",\"java-class\":\"java.lang.Short\"}");}
e3cd863ea844b8a94e88cc8e7d19f74cf45b8304c4590efe6a1296e74eed8eb6
testChar
public void testChar()
{    check(Character.TYPE, "{\"type\":\"int\",\"java-class\":\"java.lang.Character\"}");    check(Character.class, "{\"type\":\"int\",\"java-class\":\"java.lang.Character\"}");}
985b9885790e103635773f647e9df79e69cb31098a6e2b9d5fc211ca917a295d
testLong
public void testLong()
{    check(Long.TYPE, "\"long\"");    check(Long.class, "\"long\"");}
305242112461377069be291ad69495bf1e1db9d018e7721514c34899670969e1
testFloat
public void testFloat()
{    check(Float.TYPE, "\"float\"");    check(Float.class, "\"float\"");}
c5220b2b43a81a5c3331a84039191e97649ce2b6be86398d7d8981dd5be2fff4
testDouble
public void testDouble()
{    check(Double.TYPE, "\"double\"");    check(Double.class, "\"double\"");}
eeeafcd44575acfda0a5acf65dc9f11e90ef70e62392a3884ffe471fde22edb3
testString
public void testString()
{    check("Foo", "\"string\"");}
e303814592e5f8396cae35d4cabac3e308b4356ca97326151852932c5b86487b
testBytes
public void testBytes()
{    check(ByteBuffer.allocate(0), "\"bytes\"");    check(new byte[0], "{\"type\":\"bytes\",\"java-class\":\"[B\"}");}
ed05fc153f81beeab4979c3a67aa3acf97ab31aa95930461322958f61bcc66cf
testUnionWithCollection
public void testUnionWithCollection()
{    Schema s = new Schema.Parser().parse("[\"null\", {\"type\":\"array\",\"items\":\"float\"}]");    GenericData data = ReflectData.get();    assertEquals(1, data.resolveUnion(s, new ArrayList<Float>()));}
90b09826cd1c74ee0251ee69a2f7ccbdfb4360a9aafeb7d66906ec8876d11bef
testUnionWithMap
public void testUnionWithMap()
{    Schema s = new Schema.Parser().parse("[\"null\", {\"type\":\"map\",\"values\":\"float\"}]");    GenericData data = ReflectData.get();    assertEquals(1, data.resolveUnion(s, new HashMap<String, Float>()));}
f27c1ff9906d89eaadb52d63f4c87236da2650c3f3814d6ceadb9baa7726a205
testUnionWithMapWithUtf8Keys
public void testUnionWithMapWithUtf8Keys()
{    Schema s = new Schema.Parser().parse("[\"null\", {\"type\":\"map\",\"values\":\"float\"}]");    GenericData data = ReflectData.get();    HashMap<Utf8, Float> map = new HashMap<>();    map.put(new Utf8("foo"), 1.0f);    assertEquals(1, data.resolveUnion(s, map));}
bfdbca29430e973ed2ecd96c2be6e212fa4f7d7e4413a532ab23dce86b718f99
testUnionWithFixed
public void testUnionWithFixed()
{    Schema s = new Schema.Parser().parse("[\"null\", {\"type\":\"fixed\",\"name\":\"f\",\"size\":1}]");    Schema f = new Schema.Parser().parse("{\"type\":\"fixed\",\"name\":\"f\",\"size\":1}");    GenericData data = ReflectData.get();    assertEquals(1, data.resolveUnion(s, new GenericData.Fixed(f)));}
0deea3068049f1ca1c927afcf07622aa41f275a427f78adbb0d728f60293bebd
testUnionWithEnum
public void testUnionWithEnum()
{    Schema s = new Schema.Parser().parse("[\"null\", {\"type\":\"enum\",\"name\":\"E\",\"namespace\":" + "\"org.apache.avro.reflect.TestReflect\",\"symbols\":[\"A\",\"B\"]}]");    GenericData data = ReflectData.get();    assertEquals(1, data.resolveUnion(s, E.A));}
a490bc13bebe1d2c209efa52d319ab4cd96ef53ecc13e1ff6505a502113b53cb
testUnionWithBytes
public void testUnionWithBytes()
{    Schema s = new Schema.Parser().parse("[\"null\", \"bytes\"]");    GenericData data = ReflectData.get();    assertEquals(1, data.resolveUnion(s, ByteBuffer.wrap(new byte[] { 1 })));}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (!(o instanceof R1))        return false;    R1 that = (R1) o;    return mapField.equals(that.mapField) && Arrays.equals(this.arrayField, that.arrayField) && listField.equals(that.listField);}
7e3f62689a52f5cfc8f5889d1068814d43f1f4feaa85df375762f0f9cb0ab82c
testMap
public void testMap() throws Exception
{    check(R1.class.getDeclaredField("mapField").getGenericType(), "{\"type\":\"map\",\"values\":\"string\"}");}
7749ea47bc1c162d12a2c024fc5b3f5a5ed16bb6c8cb8dfaf741cc6e5cc57239
testArray
public void testArray() throws Exception
{    check(R1.class.getDeclaredField("arrayField").getGenericType(), "{\"type\":\"array\",\"items\":\"string\",\"java-class\":\"[Ljava.lang.String;\"}");}
e918f0025d803e61cf4292d7b9d56988625c98df51dc1bf4eca3d7c4d0289ccb
testList
public void testList() throws Exception
{    check(R1.class.getDeclaredField("listField").getGenericType(), "{\"type\":\"array\",\"items\":\"string\"" + ",\"java-class\":\"java.util.List\"}");}
d0ae2de241b9eeaa29880bae752362523bef60a0e04c833443f8228bf9bc5f70
testR1
public void testR1() throws Exception
{    checkReadWrite(new R1());}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (!(o instanceof R2))        return false;    R2 that = (R2) o;    return Arrays.equals(this.arrayField, that.arrayField) && collectionField.equals(that.collectionField);}
0358e687fe251396d8ff7a956998c552eedaa662820e1e7975a01df6b640d82b
testR2
public void testR2() throws Exception
{    R2 r2 = new R2();    r2.arrayField = new String[] { "foo" };    r2.collectionField = new ArrayList<>();    r2.collectionField.add("foo");    checkReadWrite(r2);}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (!(o instanceof R3))        return false;    R3 that = (R3) o;    return Arrays.equals(this.intArray, that.intArray);}
40d69d808b172b1b3dfcb6da9f5d0236f3a675563cd3494998cbd5c94111214f
testR3
public void testR3() throws Exception
{    R3 r3 = new R3();    r3.intArray = new int[] { 1 };    checkReadWrite(r3);}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (!(o instanceof R4))        return false;    R4 that = (R4) o;    return this.value == that.value && Arrays.equals(this.shorts, that.shorts) && this.b == that.b && this.c == that.c;}
d956d258d4ed6f8d831096dce126ba8ee21819e4d0140b55f1f04b22c3977da9
testR5
public void testR5() throws Exception
{    R5 r5 = new R5();    r5.value = 1;    r5.shorts = new short[] { 3, 255, 256, Short.MAX_VALUE, Short.MIN_VALUE };    r5.b = 99;    r5.c = 'a';    checkReadWrite(r5);}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (!(o instanceof R7))        return false;    return this.value == ((R7) o).value;}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (!(o instanceof R8))        return false;    return this.value == ((R8) o).value;}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (!(o instanceof R9))        return false;    return Arrays.equals(this.r6s, ((R9) o).r6s);}
2e947873f60d6a54c6bb718bfc9b75123bc11d322c67b242353b8f528768169a
testR6
public void testR6() throws Exception
{    R7 r7 = new R7();    r7.value = 1;    checkReadWrite(r7, ReflectData.get().getSchema(R6.class));    R8 r8 = new R8();    r8.value = 1;    checkReadWrite(r8, ReflectData.get().getSchema(R6.class));    R9 r9 = new R9();    r9.r6s = new R6[] { r7, r8 };    checkReadWrite(r9, ReflectData.get().getSchema(R9.class));}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (!(o instanceof R9_1))        return false;    if (this.value == null)        return ((R9_1) o).value == null;    return this.value.equals(((R9_1) o).value);}
117f31d60ccf86be6d16e3b8bfd744029e883c36dd41100e3926f6eb5354c12b
testR6_1
public void testR6_1() throws Exception
{    R7 r7 = new R7();    r7.value = 1;    checkReadWrite(r7, ReflectData.get().getSchema(R6.class));    R8 r8 = new R8();    r8.value = 1;    checkReadWrite(r8, ReflectData.get().getSchema(R6.class));    R9_1 r9_1 = new R9_1();    r9_1.value = null;    checkReadWrite(r9_1, ReflectData.get().getSchema(R9_1.class));    r9_1.value = r7;    checkReadWrite(r9_1, ReflectData.get().getSchema(R9_1.class));    r9_1.value = r8;    checkReadWrite(r9_1, ReflectData.get().getSchema(R9_1.class));}
6f630b27efa6f96cef82ddf34efb025948d9d056990f5dc1314feeb7edefa68e
testP0
public void testP0() throws Exception
{    Protocol p0 = ReflectData.get().getProtocol(P0.class);    Protocol.Message message = p0.getMessages().get("foo");        Schema response = message.getResponse();    assertEquals(Schema.Type.UNION, response.getType());    assertEquals(Schema.Type.NULL, response.getTypes().get(0).getType());    assertEquals(Schema.Type.STRING, response.getTypes().get(1).getType());        Schema request = message.getRequest();    Field field = request.getField("s");    assertNotNull("field 's' should not be null", field);    Schema param = field.schema();    assertEquals(Schema.Type.UNION, param.getType());    assertEquals(Schema.Type.NULL, param.getTypes().get(0).getType());    assertEquals(Schema.Type.STRING, param.getTypes().get(1).getType());        assertEquals(String.class, ReflectData.get().getClass(response));    assertEquals(String.class, ReflectData.get().getClass(param));}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return text;}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (!(o instanceof R10))        return false;    return this.text.equals(((R10) o).text);}
1295ea34f523ae81ec52a3fee9a934b00d40e61e8d6a63c411746cc9ef86da97
testR10
public void testR10() throws Exception
{    Schema r10Schema = ReflectData.get().getSchema(R10.class);    assertEquals(Schema.Type.STRING, r10Schema.getType());    assertEquals(R10.class.getName(), r10Schema.getProp("java-class"));    checkReadWrite(new R10("foo"), r10Schema);}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (!(o instanceof R11))        return false;    R11 that = (R11) o;    if (this.text == null)        return that.text == null;    return this.text.equals(that.text);}
8f0bdd5ccab2abc38d09722eac995929266ce9db62cd4d3407fc9ae03911f0d0
testR11
public void testR11() throws Exception
{    Schema r11Record = ReflectData.get().getSchema(R11.class);    assertEquals(Schema.Type.RECORD, r11Record.getType());    Field r11Field = r11Record.getField("text");    assertEquals(JsonProperties.NULL_VALUE, r11Field.defaultVal());    Schema r11FieldSchema = r11Field.schema();    assertEquals(Schema.Type.UNION, r11FieldSchema.getType());    assertEquals(Schema.Type.NULL, r11FieldSchema.getTypes().get(0).getType());    Schema r11String = r11FieldSchema.getTypes().get(1);    assertEquals(Schema.Type.STRING, r11String.getType());    R11 r11 = new R11();    checkReadWrite(r11, r11Record);    r11.text = "foo";    checkReadWrite(r11, r11Record);}
c97a78dfb2144796bd8b5a951088a0495d5aa3e37f7204fa8d6c4dac7a9026a3
testP1
public void testP1() throws Exception
{    Protocol p1 = ReflectData.get().getProtocol(P1.class);    Protocol.Message message = p1.getMessages().get("foo");        Schema response = message.getResponse();    assertEquals(Schema.Type.UNION, response.getType());    assertEquals(Schema.Type.NULL, response.getTypes().get(0).getType());    assertEquals(Schema.Type.STRING, response.getTypes().get(1).getType());        Schema request = message.getRequest();    Field field = request.getField("s");    assertNotNull("field 's' should not be null", field);    Schema param = field.schema();    assertEquals(Schema.Type.UNION, param.getType());    assertEquals(Schema.Type.NULL, param.getTypes().get(0).getType());    assertEquals(Schema.Type.STRING, param.getTypes().get(1).getType());        assertEquals(String.class, ReflectData.get().getClass(response));    assertEquals(String.class, ReflectData.get().getClass(param));}
8ca5ffb5a6ce2c0a957824d63f8ff8a786dd43aad4864cecd9c041a07ae34650
testR12
public void testR12() throws Exception
{    Schema s = ReflectData.get().getSchema(R12.class);    assertEquals(Schema.Type.INT, s.getField("x").schema().getType());    assertEquals(new Schema.Parser().parse("{\"type\":\"array\",\"items\":[\"null\",\"string\"]}"), s.getField("strings").schema());}
1cf0d8beb3b4700bff716c1429cacc10bfee21658f2a4e1c408abda3fd3dc34b
testR13
public void testR13() throws Exception
{    Schema s = ReflectData.get().getSchema(R13.class);    assertEquals(Schema.Type.NULL, s.getType());}
c3cda23b53790e150e4e6b5fd0852827f9b665816a130334f4f7fc44d016f254
testP4
public void testP4() throws Exception
{    Protocol p = ReflectData.get().getProtocol(P4.class);    Protocol.Message message = p.getMessages().get("foo");    assertEquals(Schema.Type.INT, message.getResponse().getType());    Field field = message.getRequest().getField("x");    assertEquals(Schema.Type.INT, field.schema().getType());}
ec24a1cfd3388a9ac505d1f9aeab827d1dd4b14f4f2a4ac018506fe8ef9859a1
testP2
public void testP2() throws Exception
{    Schema e1 = ReflectData.get().getSchema(E1.class);    assertEquals(Schema.Type.RECORD, e1.getType());    assertTrue(e1.isError());    Field message = e1.getField("detailMessage");    assertNotNull("field 'detailMessage' should not be null", message);    Schema messageSchema = message.schema();    assertEquals(Schema.Type.UNION, messageSchema.getType());    assertEquals(Schema.Type.NULL, messageSchema.getTypes().get(0).getType());    assertEquals(Schema.Type.STRING, messageSchema.getTypes().get(1).getType());    Protocol p2 = ReflectData.get().getProtocol(P2.class);    Protocol.Message m = p2.getMessages().get("error");        Schema response = m.getErrors();    assertEquals(Schema.Type.UNION, response.getType());    assertEquals(Schema.Type.STRING, response.getTypes().get(0).getType());    assertEquals(e1, response.getTypes().get(1));}
3aa4c3655f0b85c33b9175ee549251bad8fe83672cb3f17004cf0211ae914ec7
testNoPackage
public void testNoPackage() throws Exception
{    Class<?> noPackage = Class.forName("NoPackage");    Schema s = ReflectData.get().getSchema(noPackage);    assertEquals(noPackage.getName(), ReflectData.getClassName(s));}
78f9af126c1d4f0ec8d02039f88d4fd62c3b2afbf2609e9d91a0341ac7cc19b5
checkReadWrite
 void checkReadWrite(Object object) throws Exception
{    checkReadWrite(object, ReflectData.get().getSchema(object.getClass()));}
de3eaabdca73cc439311a9569e1114bf201a7b94376234b50d627d606540b5f7
checkReadWrite
 void checkReadWrite(Object object, Schema s) throws Exception
{    ReflectDatumWriter<Object> writer = new ReflectDatumWriter<>(s);    ByteArrayOutputStream out = new ByteArrayOutputStream();    writer.write(object, factory.directBinaryEncoder(out, null));    ReflectDatumReader<Object> reader = new ReflectDatumReader<>(s);    Object after = reader.read(null, DecoderFactory.get().binaryDecoder(out.toByteArray(), null));    assertEquals(object, after);        if (s.getType().equals(Schema.Type.RECORD)) {        Object copy = object.getClass().getDeclaredConstructor().newInstance();        for (Field f : s.getFields()) {            Object val = ReflectData.get().getField(object, f.name(), f.pos());            ReflectData.get().setField(copy, f.name(), f.pos(), val);        }        assertEquals("setField", object, copy);    }}
3776f415ff726e12f4d27d6f94a41798d7873f7ae8f7190bf152d378efc74b28
testEnum
public void testEnum() throws Exception
{    check(E.class, "{\"type\":\"enum\",\"name\":\"E\",\"namespace\":" + "\"org.apache.avro.reflect.TestReflect\",\"symbols\":[\"A\",\"B\"]}");}
bc60056fba07c84186113a44978125e27ff567860e028682a7e6e98bb36c39eb
testRecord
public void testRecord() throws Exception
{    check(R.class, "{\"type\":\"record\",\"name\":\"R\",\"namespace\":" + "\"org.apache.avro.reflect.TestReflect\",\"fields\":[" + "{\"name\":\"a\",\"type\":\"int\"}," + "{\"name\":\"b\",\"type\":\"long\"}]}");}
cdd1d5a570b23d66e3340d5784bc60ac18c25a9a8b6074dbebaa92eeb1961513
testAnnotationAvroIgnore
public void testAnnotationAvroIgnore() throws Exception
{    check(RAvroIgnore.class, "{\"type\":\"record\",\"name\":\"RAvroIgnore\",\"namespace\":" + "\"org.apache.avro.reflect.TestReflect\",\"fields\":[]}");}
bbf149272773ada7c99a6f59ecbd0b3b31f8a6fbadea41852617a3aec785cdc9
testAnnotationAvroMeta
public void testAnnotationAvroMeta() throws Exception
{    check(RAvroMeta.class, "{\"type\":\"record\",\"name\":\"RAvroMeta\",\"namespace\":" + "\"org.apache.avro.reflect.TestReflect\",\"fields\":[" + "{\"name\":\"a\",\"type\":\"int\",\"K\":\"V\"}]" + ",\"X\":\"Y\"}");}
dc6d37771f7baf095144e16f0c69a1a5d6a6cc0dc817742b029d4713200c5618
testAnnotationMultiAvroMeta
public void testAnnotationMultiAvroMeta()
{    check(RAvroMultiMeta.class, "{\"type\":\"record\",\"name\":\"RAvroMultiMeta\",\"namespace\":" + "\"org.apache.avro.reflect.TestReflect\",\"fields\":[" + "{\"name\":\"a\",\"type\":\"int\",\"K\":\"V\",\"L\":\"W\"}]" + ",\"X\":\"Y\",\"A\":\"B\"}");}
6c673c68956b91871fc2106f25c99682a53c516dcc434e8b3de1fcc96d7607cc
testAnnotationDuplicateFieldAvroMeta
public void testAnnotationDuplicateFieldAvroMeta()
{    ReflectData.get().getSchema(RAvroDuplicateFieldMeta.class);}
ab847d5ad2c8c58deea5b4758f2678422c37e964834b439bb1b7e639ef05bce9
testAnnotationDuplicateTypeAvroMeta
public void testAnnotationDuplicateTypeAvroMeta()
{    ReflectData.get().getSchema(RAvroDuplicateTypeMeta.class);}
18f52e33403a89a1d39432f93b2df3e636c2d8c535c852a0863c1b5e733e6f8c
testAnnotationAvroName
public void testAnnotationAvroName() throws Exception
{    check(RAvroName.class, "{\"type\":\"record\",\"name\":\"RAvroName\",\"namespace\":" + "\"org.apache.avro.reflect.TestReflect\",\"fields\":[" + "{\"name\":\"b\",\"type\":\"int\"}]}");}
0fdf5a98fc6e83a1b2a03d314fef0bf9f987ff203987cfb59e7567828fccb3bd
testAnnotationAvroNameCollide
public void testAnnotationAvroNameCollide() throws Exception
{    check(RAvroNameCollide.class, "{\"type\":\"record\",\"name\":\"RAvroNameCollide\",\"namespace\":" + "\"org.apache.avro.reflect.TestReflect\",\"fields\":[" + "{\"name\":\"b\",\"type\":\"int\"}," + "{\"name\":\"b\",\"type\":\"int\"}]}");}
f10cb565ae14b95795bdf5d888b772987f360e8a5998b3e501d70561c9c3cdc6
testAnnotationAvroStringableFields
public void testAnnotationAvroStringableFields() throws Exception
{    check(RAvroStringableField.class, "{\"type\":\"record\",\"name\":\"RAvroStringableField\",\"namespace\":" + "\"org.apache.avro.reflect.TestReflect\",\"fields\":[" + "{\"name\":\"a\",\"type\":\"string\"}]}");}
662bcb9273f220290ee7c699d999818e5e55cca340d24de89b42b2ac1d6df49e
check
private void check(Object o, String schemaJson)
{    check(o.getClass(), schemaJson);}
a902554a72bf2a6c90cf8fa93face973c3a3433da76f931c0a39631009a57092
check
private void check(java.lang.reflect.Type type, String schemaJson)
{    assertEquals(schemaJson, ReflectData.get().getSchema(type).toString());}
8de99d46c3c158be654f72a1862eb870559b61621b61597fa076c528e7e5803a
testRecordIO
public void testRecordIO() throws IOException
{    Schema schm = ReflectData.get().getSchema(SampleRecord.class);    ReflectDatumWriter<SampleRecord> writer = new ReflectDatumWriter<>(schm);    ByteArrayOutputStream out = new ByteArrayOutputStream();    SampleRecord record = new SampleRecord();    record.x = 5;    record.y = 10;    writer.write(record, factory.directBinaryEncoder(out, null));    ReflectDatumReader<SampleRecord> reader = new ReflectDatumReader<>(schm);    SampleRecord decoded = reader.read(null, DecoderFactory.get().binaryDecoder(out.toByteArray(), null));    assertEquals(record, decoded);}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (!(o instanceof AvroEncRecord))        return false;    return date.equals(((AvroEncRecord) o).date);}
e523acbc1b50ef0b8c7195a60e6e3dfeabf4597360b0c6e49e3cc2d3a1b0942c
testMultipleAnnotations
public void testMultipleAnnotations() throws IOException
{    Schema schm = ReflectData.get().getSchema(multipleAnnotationRecord.class);    ReflectDatumWriter<multipleAnnotationRecord> writer = new ReflectDatumWriter<>(schm);    ByteArrayOutputStream out = new ByteArrayOutputStream();    multipleAnnotationRecord record = new multipleAnnotationRecord();    record.i1 = 1;    record.i2 = 2;    record.i3 = 3;    record.i4 = new java.util.Date(4L);    record.i5 = 5;    record.i6 = 6;    record.i7 = new java.util.Date(7L);    record.i8 = 8;    record.i9 = new java.util.Date(9L);    record.i10 = new java.util.Date(10L);    record.i11 = new java.util.Date(11L);    writer.write(record, factory.directBinaryEncoder(out, null));    ReflectDatumReader<multipleAnnotationRecord> reader = new ReflectDatumReader<>(schm);    multipleAnnotationRecord decoded = reader.read(new multipleAnnotationRecord(), DecoderFactory.get().binaryDecoder(out.toByteArray(), null));    assertTrue(decoded.i1 == null);    assertTrue(decoded.i2 == null);    assertTrue(decoded.i3 == null);    assertTrue(decoded.i4 == null);    assertTrue(decoded.i5 == 5);    assertTrue(decoded.i6 == 6);    assertTrue(decoded.i7.getTime() == 7);    assertTrue(decoded.i8 == 8);    assertTrue(decoded.i9.getTime() == 9);    assertTrue(decoded.i10.getTime() == 10);    assertTrue(decoded.i11.getTime() == 11);}
4ae7545d82834363cb0405794374b96e588cb1f6db3cb6abdbd578977e4dba73
testAvroEncodeInducing
public void testAvroEncodeInducing() throws IOException
{    Schema schm = ReflectData.get().getSchema(AvroEncRecord.class);    assertEquals(schm.toString(), "{\"type\":\"record\",\"name\":\"AvroEncRecord\",\"namespace" + "\":\"org.apache.avro.reflect.TestReflect\",\"fields\":[{\"name\":\"date\"," + "\"type\":{\"type\":\"long\",\"CustomEncoding\":\"DateAsLongEncoding\"}}]}");}
6782c2a4ce1fe9754c4d2173775d9e91aa89b48e57448055151485a00cb2eba7
testAvroEncodeIO
public void testAvroEncodeIO() throws IOException
{    Schema schm = ReflectData.get().getSchema(AvroEncRecord.class);    ReflectDatumWriter<AvroEncRecord> writer = new ReflectDatumWriter<>(schm);    ByteArrayOutputStream out = new ByteArrayOutputStream();    AvroEncRecord record = new AvroEncRecord();    record.date = new java.util.Date(948833323L);    writer.write(record, factory.directBinaryEncoder(out, null));    ReflectDatumReader<AvroEncRecord> reader = new ReflectDatumReader<>(schm);    AvroEncRecord decoded = reader.read(new AvroEncRecord(), DecoderFactory.get().binaryDecoder(out.toByteArray(), null));    assertEquals(record, decoded);}
8b5a85f8cae1e5c2d3ebf22fb085f685d85ffcb45923ee1294f57218e595bbce
testRecordWithNullIO
public void testRecordWithNullIO() throws IOException
{    ReflectData reflectData = ReflectData.AllowNull.get();    Schema schm = reflectData.getSchema(AnotherSampleRecord.class);    ReflectDatumWriter<AnotherSampleRecord> writer = new ReflectDatumWriter<>(schm);    ByteArrayOutputStream out = new ByteArrayOutputStream();        Encoder e = factory.directBinaryEncoder(out, null);    AnotherSampleRecord a = new AnotherSampleRecord();    writer.write(a, e);    AnotherSampleRecord b = new AnotherSampleRecord(10);    writer.write(b, e);    e.flush();    ReflectDatumReader<AnotherSampleRecord> reader = new ReflectDatumReader<>(schm);    ByteArrayInputStream in = new ByteArrayInputStream(out.toByteArray());    Decoder d = DecoderFactory.get().binaryDecoder(in, null);    AnotherSampleRecord decoded = reader.read(null, d);    assertEquals(a, decoded);    decoded = reader.read(null, d);    assertEquals(b, decoded);}
6dd49f1d1d5344406ca4d6b197ba4e94407745f4d9b5cdacaff9c6c6d7148584
testDisableUnsafe
public void testDisableUnsafe() throws Exception
{    String saved = System.getProperty("avro.disable.unsafe");    try {        System.setProperty("avro.disable.unsafe", "true");        ReflectData.ACCESSOR_CACHE.remove(multipleAnnotationRecord.class);        ReflectData.ACCESSOR_CACHE.remove(AnotherSampleRecord.class);        ReflectionUtil.resetFieldAccess();        testMultipleAnnotations();        testRecordWithNullIO();    } finally {        if (saved == null)            System.clearProperty("avro.disable.unsafe");        else            System.setProperty("avro.disable.unsafe", saved);        ReflectData.ACCESSOR_CACHE.remove(multipleAnnotationRecord.class);        ReflectData.ACCESSOR_CACHE.remove(AnotherSampleRecord.class);        ReflectionUtil.resetFieldAccess();    }}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return x + y;}
4afeb0868b55bdd8e18a00a3cb43d83e0714378d1c4bb36f0936daefc060e2e8
equals
public boolean equals(Object obj)
{    if (this == obj)        return true;    if (obj == null)        return false;    if (getClass() != obj.getClass())        return false;    final SampleRecord other = (SampleRecord) obj;    if (x != other.x)        return false;    return y == other.y;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    int hash = (a != null ? a.hashCode() : 0);    hash += (s != null ? s.hashCode() : 0);    return hash;}
74e378df448c6c3cd090d6daf881cfac8957dd555869ea4c13a46bdc6cdcf9a6
equals
public boolean equals(Object other)
{    if (other instanceof AnotherSampleRecord) {        AnotherSampleRecord o = (AnotherSampleRecord) other;        return (this.a != null || o.a == null) && (this.a == null || this.a.equals(o.a)) && (this.s != null || o.s == null) && (this.s == null || this.s.equals(o.s));    } else {        return false;    }}
b3866a220d1eaf230e3c05a897b7695b5492c60d6c3f1f000ca876242dd26c97
testForwardReference
public void testForwardReference()
{    ReflectData data = ReflectData.get();    Protocol reflected = data.getProtocol(C.class);    Protocol reparsed = Protocol.parse(reflected.toString());    assertEquals(reflected, reparsed);    assert (reparsed.getTypes().contains(data.getSchema(A.class)));    assert (reparsed.getTypes().contains(data.getSchema(B1.class)));    assert (reparsed.getTypes().contains(data.getSchema(B2.class)));    assert (reparsed.getTypes().contains(data.getSchema(X.class)));}
9c325065b82844ea3ccfdd765d77af91e629ad4cc0eae04c94c4a6ff763b14a4
testOverloadedMethod
public void testOverloadedMethod()
{    ReflectData.get().getProtocol(P3.class);}
0c11319b1f1a3ee465a850f8d89a0c73be13f9f24bcb75ecedcb4cced324db41
testNoPackageSchema
public void testNoPackageSchema() throws Exception
{    ReflectData.get().getSchema(Class.forName("NoPackage"));}
8e6db439361b867125173cd71c8044aad1fb9955b791f81cd54a5ed0ada7f8f1
testNoPackageProtocol
public void testNoPackageProtocol() throws Exception
{    ReflectData.get().getProtocol(Class.forName("NoPackage"));}
e711f0818eb7c8c09b03ffe286c1ccba0d84173571790faee66e17515d4aea0e
testReflectWithinGeneric
public void testReflectWithinGeneric() throws Exception
{    ReflectData data = ReflectData.get();        Schema schema = Schema.createRecord("Foo", "", "x.y.z", false);    List<Schema.Field> fields = new ArrayList<>();    fields.add(new Schema.Field("f", data.getSchema(Y.class), "", null));    schema.setFields(fields);        Y y = new Y();    y.i = 1;    GenericData.Record record = new GenericData.Record(schema);    record.put("f", y);        checkBinary(schema, record);}
d51ac34fa3601b8448f7ab66dae5127a3d59ac4ff65997e78b44fdab69c72708
testPrimitiveArray
public void testPrimitiveArray() throws Exception
{    testPrimitiveArrays(false);}
f3d8c5f0f528ac0d70decb3e74e19de986bb35dbae96deec5d070082f09880a6
testPrimitiveArrayBlocking
public void testPrimitiveArrayBlocking() throws Exception
{    testPrimitiveArrays(true);}
4e597236f36491e50884e005450ab33dcf826db1ad11430ce026c473cf497307
testPrimitiveArrays
private void testPrimitiveArrays(boolean blocking) throws Exception
{    testPrimitiveArray(boolean.class, blocking);    testPrimitiveArray(byte.class, blocking);    testPrimitiveArray(short.class, blocking);    testPrimitiveArray(char.class, blocking);    testPrimitiveArray(int.class, blocking);    testPrimitiveArray(long.class, blocking);    testPrimitiveArray(float.class, blocking);    testPrimitiveArray(double.class, blocking);}
d1d2af7b13879c9f03606fde1556c880b5fac39523f68e90bdf31a5252bffd41
testPrimitiveArray
private void testPrimitiveArray(Class<?> c, boolean blocking) throws Exception
{    ReflectData data = new ReflectData();    Random r = new Random();    int size = 200;    Object array = Array.newInstance(c, size);    Schema s = data.getSchema(array.getClass());    for (int i = 0; i < size; i++) {        Array.set(array, i, randomFor(c, r));    }    checkBinary(data, s, array, false, blocking);}
f0bc2641b8b68c24dd17af8e17d23cef9b4b5a03fdf685c67d2e07f897064a7c
randomFor
private Object randomFor(Class<?> c, Random r)
{    if (c == boolean.class)        return r.nextBoolean();    if (c == int.class)        return r.nextInt();    if (c == long.class)        return r.nextLong();    if (c == byte.class)        return (byte) r.nextInt();    if (c == float.class)        return r.nextFloat();    if (c == double.class)        return r.nextDouble();    if (c == char.class)        return (char) r.nextInt();    if (c == short.class)        return (short) r.nextInt();    return null;}
f1c4d41eb277a20fbcc122098be8d85155f82e171d2076644b0baa9751f29b0b
testNullArray
public void testNullArray() throws Exception
{    String json = "[{\"type\":\"array\", \"items\": \"long\"}, \"null\"]";    Schema schema = new Schema.Parser().parse(json);    checkBinary(schema, null);}
e6f3dbbdc8c1999b15e1fc982e11dc9402afb2001271ecccabe061c3a4d0b3aa
testStringables
public void testStringables() throws Exception
{    checkStringable(java.math.BigDecimal.class, "10");    checkStringable(java.math.BigInteger.class, "20");    checkStringable(java.net.URI.class, "foo://bar:9000/baz");    checkStringable(java.net.URL.class, "http://bar:9000/baz");    checkStringable(java.io.File.class, "foo.bar");}
d90a4ba93992fe8230028e3ddb7f097a06c62da5160060db5b6bc26fbc91290f
checkStringable
public void checkStringable(Class c, String value) throws Exception
{    ReflectData data = new ReflectData();    Schema schema = data.getSchema(c);    assertEquals("{\"type\":\"string\",\"java-class\":\"" + c.getName() + "\"}", schema.toString());    checkBinary(schema, c.getConstructor(String.class).newInstance(value));}
5741571ce5ea584461db226cb6c405a4ee5d58124273c228ecda90cdd9dc7b5a
testStringableMapKeys
public void testStringableMapKeys() throws Exception
{    M1 record = new M1();    record.integerKeyMap = new HashMap<>(1);    record.integerKeyMap.put(10, "foo");    record.bigIntegerKeyMap = new HashMap<>(1);    record.bigIntegerKeyMap.put(java.math.BigInteger.TEN, "bar");    record.bigDecimalKeyMap = new HashMap<>(1);    record.bigDecimalKeyMap.put(java.math.BigDecimal.ONE, "bigDecimal");    record.fileKeyMap = new HashMap<>(1);    record.fileKeyMap.put(new java.io.File("foo.bar"), "file");    ReflectData data = new ReflectData().addStringable(Integer.class);    checkBinary(data, data.getSchema(M1.class), record, true);}
3a777428735fdf98a1efae0300a81fd2cafbba0cc68d83f66c364afc7d1f04c7
testNullableStringableField
public void testNullableStringableField() throws Exception
{    NullableStringable datum = new NullableStringable();    datum.number = java.math.BigDecimal.TEN;    Schema schema = ReflectData.AllowNull.get().getSchema(NullableStringable.class);    checkBinary(schema, datum);}
db598316f5426c1505b80414dc0921bc926316dfdadb4d1d5a8f5940a790ac6f
checkBinary
public static void checkBinary(ReflectData reflectData, Schema schema, Object datum, boolean equals) throws IOException
{    checkBinary(reflectData, schema, datum, equals, false);}
0eb2d14e4a2d15cc8e36716bc848ab553be7f7f28420fde32bd72c1c303a76a5
checkBinary
private static void checkBinary(ReflectData reflectData, Schema schema, Object datum, boolean equals, boolean blocking) throws IOException
{    ReflectDatumWriter<Object> writer = new ReflectDatumWriter<>(schema);    ByteArrayOutputStream out = new ByteArrayOutputStream();    if (!blocking) {        writer.write(datum, EncoderFactory.get().directBinaryEncoder(out, null));    } else {        writer.write(datum, new EncoderFactory().configureBlockSize(64).blockingBinaryEncoder(out, null));    }    writer.write(datum, EncoderFactory.get().directBinaryEncoder(out, null));    byte[] data = out.toByteArray();    ReflectDatumReader<Object> reader = new ReflectDatumReader<>(schema);    Object decoded = reader.read(null, DecoderFactory.get().binaryDecoder(data, null));    assertEquals(0, reflectData.compare(datum, decoded, schema, equals));}
453bf58f14cc61a2067aaf501f4d24486428326c5cdd17d4dc91adaa005caff6
checkBinary
public static void checkBinary(Schema schema, Object datum) throws IOException
{    checkBinary(ReflectData.get(), schema, datum, false);}
41542ebe3a7d92a82d9745ff9bdfe9251a90d14f5937b1b765f00bcbd08d5f75
testReflectFieldError
public void testReflectFieldError() throws Exception
{    Object datum = "";    try {        ReflectData.get().getField(datum, "notAFieldOfString", 0);    } catch (AvroRuntimeException e) {        assertTrue(e.getMessage().contains(datum.getClass().getName()));    }}
dd2a4c9b04068b8d911a229f1e85c29aa6ab8ccfa7bb9105974ae9c64464ed02
testAvroAliasOnClass
public void testAvroAliasOnClass()
{    check(AliasA.class, "{\"type\":\"record\",\"name\":\"AliasA\",\"namespace\":\"org.apache.avro.reflect.TestReflect\",\"fields\":[],\"aliases\":[\"b.a\"]}");    check(AliasB.class, "{\"type\":\"record\",\"name\":\"AliasB\",\"namespace\":\"org.apache.avro.reflect.TestReflect\",\"fields\":[],\"aliases\":[\"a\"]}");    check(AliasC.class, "{\"type\":\"record\",\"name\":\"AliasC\",\"namespace\":\"org.apache.avro.reflect.TestReflect\",\"fields\":[],\"aliases\":[\"a\"]}");}
790ff8442cb3f90ce58b5a367d47a6fa290be934383d18971577af74b6b3eb2d
testMultipleAliasAnnotationsOnClass
public void testMultipleAliasAnnotationsOnClass()
{    check(MultipleAliasRecord.class, "{\"type\":\"record\",\"name\":\"MultipleAliasRecord\",\"namespace\":\"org.apache.avro.reflect.TestReflect\",\"fields\":[],\"aliases\":[\"space1.alias1\",\"space2.alias2\"]}");}
546a0c3702273ad31ecef258529a1dd0185c56ac65ed8f0436659faf6bb12cab
testDollarTerminatedNamespaceCompatibility
public void testDollarTerminatedNamespaceCompatibility()
{    ReflectData data = ReflectData.get();    Schema s = new Schema.Parser().parse("{\"type\":\"record\",\"name\":\"Z\",\"namespace\":\"org.apache.avro.reflect.TestReflect$\",\"fields\":[]}");    assertEquals(data.getSchema(data.getClass(s)).toString(), "{\"type\":\"record\",\"name\":\"Z\",\"namespace\":\"org.apache.avro.reflect.TestReflect\",\"fields\":[]}");}
be16bf563f8f6cc1c9be767721318518ce4493dc11221e708de5e994639a3d30
testAvroAliasOnField
public void testAvroAliasOnField()
{    Schema expectedSchema = SchemaBuilder.record(ClassWithAliasOnField.class.getSimpleName()).namespace("org.apache.avro.reflect.TestReflect").fields().name("primitiveField").aliases("aliasName").type(Schema.create(org.apache.avro.Schema.Type.INT)).noDefault().endRecord();    check(ClassWithAliasOnField.class, expectedSchema.toString());}
384d0ac16482e43201d47dd27bc3dd2c0ba9000280a02e62e322feb80bec944f
namespaceDefinitionOnFieldAliasMustThrowException
public void namespaceDefinitionOnFieldAliasMustThrowException()
{    ReflectData.get().getSchema(ClassWithAliasAndNamespaceOnField.class);}
afc66f7e9f6c19644410d1b13c25e53cccb72bc93fc7ae53ed231b07823ca42f
testMultipleFieldAliases
public void testMultipleFieldAliases()
{    Schema expectedSchema = SchemaBuilder.record(ClassWithMultipleAliasesOnField.class.getSimpleName()).namespace("org.apache.avro.reflect.TestReflect").fields().name("primitiveField").aliases("alias1", "alias2").type(Schema.create(org.apache.avro.Schema.Type.INT)).noDefault().endRecord();    check(ClassWithMultipleAliasesOnField.class, expectedSchema.toString());}
0250b65c94ae21443d067940cdb1c6694e115d5e29fc44bcd81e3a10c90de6b0
testAvroDefault
public void testAvroDefault()
{    check(DefaultTest.class, "{\"type\":\"record\",\"name\":\"DefaultTest\"," + "\"namespace\":\"org.apache.avro.reflect.TestReflect\",\"fields\":[" + "{\"name\":\"foo\",\"type\":\"int\",\"default\":1}]}");}
4afeb0868b55bdd8e18a00a3cb43d83e0714378d1c4bb36f0936daefc060e2e8
equals
public boolean equals(Object obj)
{    return obj instanceof NullableBytesTest && Arrays.equals(((NullableBytesTest) obj).bytes, this.bytes);}
fce638ea9331fa00a33f36b81bbfb27f8a20a8d02a36fa85532d2634dbfc4ee3
testNullableByteArrayNotNullValue
public void testNullableByteArrayNotNullValue() throws Exception
{    checkReadWrite(new NullableBytesTest("foo".getBytes(UTF_8)));}
3049ca844be7aa885f94cb50229d3ad3121bcec098a3084e5b5d14d2816b928a
testNullableByteArrayNullValue
public void testNullableByteArrayNullValue() throws Exception
{    checkReadWrite(new NullableBytesTest());}
6beb4adb4b92cbff122b9b0cc92ea244f90a60ea51c1303a8130140b2eb60fe1
testAvroDoc
public void testAvroDoc()
{    check(DocTest.class, "{\"type\":\"record\",\"name\":\"DocTest\",\"namespace\":\"org.apache.avro.reflect.TestReflect\"," + "\"doc\":\"DocTest class docs\"," + "\"fields\":[{\"name\":\"foo\",\"type\":\"int\",\"doc\":\"Some Documentation\"}," + "{\"name\":\"enums\",\"type\":{\"type\":\"enum\",\"name\":\"DocTestEnum\"," + "\"symbols\":[\"ENUM_1\",\"ENUM_2\"]},\"doc\":\"Some other Documentation\"}," + "{\"name\":\"defaultTest\",\"type\":{\"type\":\"record\",\"name\":\"DefaultTest\"," + "\"fields\":[{\"name\":\"foo\",\"type\":\"int\",\"default\":1}]},\"doc\":\"And again\"}]}");}
b146c7dfc09ba6a01734886ae95a5588d85088bb1687b5d6f9418bca5caf6bbd
testPrimitives
public void testPrimitives()
{        Schema primitives = ReflectData.AllowNull.get().getSchema(Primitives.class);    Assert.assertEquals(requiredSchema(boolean.class), primitives.getField("aBoolean").schema());    Assert.assertEquals(requiredSchema(byte.class), primitives.getField("aByte").schema());    Assert.assertEquals(requiredSchema(short.class), primitives.getField("aShort").schema());    Assert.assertEquals(requiredSchema(int.class), primitives.getField("anInt").schema());    Assert.assertEquals(requiredSchema(long.class), primitives.getField("aLong").schema());    Assert.assertEquals(requiredSchema(float.class), primitives.getField("aFloat").schema());    Assert.assertEquals(requiredSchema(double.class), primitives.getField("aDouble").schema());}
aee70e6fb32beff5d5fc68fd4827754adff2ed02ac4e32c3e01b6c824a081832
testWrappers
public void testWrappers()
{        Schema wrappers = ReflectData.AllowNull.get().getSchema(Wrappers.class);    Assert.assertEquals(nullableSchema(boolean.class), wrappers.getField("aBoolean").schema());    Assert.assertEquals(nullableSchema(byte.class), wrappers.getField("aByte").schema());    Assert.assertEquals(nullableSchema(short.class), wrappers.getField("aShort").schema());    Assert.assertEquals(nullableSchema(int.class), wrappers.getField("anInt").schema());    Assert.assertEquals(nullableSchema(long.class), wrappers.getField("aLong").schema());    Assert.assertEquals(nullableSchema(float.class), wrappers.getField("aFloat").schema());    Assert.assertEquals(nullableSchema(double.class), wrappers.getField("aDouble").schema());    Assert.assertEquals(nullableSchema(Primitives.class), wrappers.getField("anObject").schema());}
ecac27d26fdda1e3c9468377d783c3617eafe105d06cd66c76d9e41c003a11e8
testAllowNullWithNullableAnnotation
public void testAllowNullWithNullableAnnotation()
{    Schema withNullable = ReflectData.AllowNull.get().getSchema(AllowNullWithNullable.class);    Assert.assertEquals("Should produce a nullable double", nullableSchema(double.class), withNullable.getField("aDouble").schema());    Schema nullableDoubleOrLong = Schema.createUnion(Arrays.asList(Schema.create(Schema.Type.NULL), Schema.create(Schema.Type.DOUBLE), Schema.create(Schema.Type.LONG)));    Assert.assertEquals("Should add null to a non-null union", nullableDoubleOrLong, withNullable.getField("doubleOrLong").schema());    Assert.assertEquals("Should add null to a non-null union", nullableDoubleOrLong, withNullable.getField("doubleOrLongOrNull1").schema());    Schema doubleOrLongOrNull = Schema.createUnion(Arrays.asList(Schema.create(Schema.Type.DOUBLE), Schema.create(Schema.Type.LONG), Schema.create(Schema.Type.NULL)));    Assert.assertEquals("Should add null to a non-null union", doubleOrLongOrNull, withNullable.getField("doubleOrLongOrNull2").schema());    Assert.assertEquals("Should add null to a non-null union", doubleOrLongOrNull, withNullable.getField("doubleOrLongOrNull3").schema());}
d9954ffb73ed45549333885a768ff7d614c36d354b76dcc80cf5331e5ebc539b
requiredSchema
private Schema requiredSchema(Class<?> type)
{    return ReflectData.get().getSchema(type);}
738676b7b336cc3d6d456e2ecaf80d375b6154130a4ce3466b6bd2e893d4c356
nullableSchema
private Schema nullableSchema(Class<?> type)
{    return Schema.createUnion(Arrays.asList(Schema.create(Schema.Type.NULL), ReflectData.get().getSchema(type)));}
1a94a984dd5caa3d30c85573fb9c607ff40603bd74eeebac2631c6f372fffe5d
testWeakSchemaCaching
public void testWeakSchemaCaching() throws Exception
{    int numSchemas = 1000000;    for (int i = 0; i < numSchemas; i++) {                Schema schema = Schema.createRecord("schema", null, null, false);        schema.setFields(Collections.emptyList());        ReflectData.get().getRecordState(new Object(), schema);    }        ReflectData.ClassAccessorData classData = ReflectData.ACCESSOR_CACHE.get(Object.class);        System.gc();    assertThat("ReflectData cache should release references", classData.bySchema.size(), lessThan(numSchemas));}
f01ea55be8b765dd0e5ff29513051587ee07418f995118dae19998141d6fcd2c
testGenericProtocol
public void testGenericProtocol()
{    Protocol protocol = ReflectData.get().getProtocol(FooBarProtocol.class);    Schema recordSchema = ReflectData.get().getSchema(FooBarReflectiveRecord.class);    assertThat(protocol.getTypes(), contains(recordSchema));    assertThat(protocol.getMessages().keySet(), containsInAnyOrder("store", "findById", "exists"));    Schema.Field storeArgument = protocol.getMessages().get("store").getRequest().getFields().get(0);    assertThat(storeArgument.schema(), equalTo(recordSchema));    Schema.Field findByIdArgument = protocol.getMessages().get("findById").getRequest().getFields().get(0);    assertThat(findByIdArgument.schema(), equalTo(Schema.create(Schema.Type.STRING)));    Schema findByIdResponse = protocol.getMessages().get("findById").getResponse();    assertThat(findByIdResponse, equalTo(recordSchema));    Schema.Field existsArgument = protocol.getMessages().get("exists").getRequest().getFields().get(0);    assertThat(existsArgument.schema(), equalTo(Schema.create(Schema.Type.STRING)));}
ae063b9f668030201a3ecc2bec398f029ff3f947fe40297daad8d1a21aa9ba9e
serializeWithReflectDatumWriter
private static byte[] serializeWithReflectDatumWriter(T toSerialize, Class<T> toSerializeClass) throws IOException
{    ReflectDatumWriter<T> datumWriter = new ReflectDatumWriter<>(toSerializeClass);    ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();    Encoder encoder = EncoderFactory.get().binaryEncoder(byteArrayOutputStream, null);    datumWriter.write(toSerialize, encoder);    encoder.flush();    return byteArrayOutputStream.toByteArray();}
35f85ff7c2ba7139b23e24cdc7403ba01e6d6a7b40e67881e35af0fd9d664d9c
testRead_PojoWithList
public void testRead_PojoWithList() throws IOException
{    PojoWithList pojoWithList = new PojoWithList();    pojoWithList.setId(42);    pojoWithList.setRelatedIds(Arrays.asList(1, 2, 3));    byte[] serializedBytes = serializeWithReflectDatumWriter(pojoWithList, PojoWithList.class);    Decoder decoder = DecoderFactory.get().binaryDecoder(serializedBytes, null);    ReflectDatumReader<PojoWithList> reflectDatumReader = new ReflectDatumReader<>(PojoWithList.class);    PojoWithList deserialized = new PojoWithList();    reflectDatumReader.read(deserialized, decoder);    assertEquals(pojoWithList, deserialized);}
b3e440afb1591a7df514f228c2772523fe2facc959d379a6eeaffcb7da6146dc
testRead_PojoWithArray
public void testRead_PojoWithArray() throws IOException
{    PojoWithArray pojoWithArray = new PojoWithArray();    pojoWithArray.setId(42);    pojoWithArray.setRelatedIds(new int[] { 1, 2, 3 });    byte[] serializedBytes = serializeWithReflectDatumWriter(pojoWithArray, PojoWithArray.class);    Decoder decoder = DecoderFactory.get().binaryDecoder(serializedBytes, null);    ReflectDatumReader<PojoWithArray> reflectDatumReader = new ReflectDatumReader<>(PojoWithArray.class);    PojoWithArray deserialized = new PojoWithArray();    reflectDatumReader.read(deserialized, decoder);    assertEquals(pojoWithArray, deserialized);}
cea1c2c1f10d4b97004da212612fc3f2159fe44d7c7e24cd3c5e70653f0143a5
getId
public int getId()
{    return id;}
7062c1bfe9919ab8c7f67a87a016d04f81ac6c31a31838d4009b2440a3dec97c
setId
public void setId(int id)
{    this.id = id;}
e6131991a85fbd8856950771b27924baeb71ec175c3d88864baaec2353ea74b0
getRelatedIds
public List<Integer> getRelatedIds()
{    return relatedIds;}
cdda163e89ab5afe7241d67bad9a615e19244d67029da0cfbfc8972c1a7951cb
setRelatedIds
public void setRelatedIds(List<Integer> relatedIds)
{    this.relatedIds = relatedIds;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    final int prime = 31;    int result = 1;    result = prime * result + id;    result = prime * result + ((relatedIds == null) ? 0 : relatedIds.hashCode());    return result;}
4afeb0868b55bdd8e18a00a3cb43d83e0714378d1c4bb36f0936daefc060e2e8
equals
public boolean equals(Object obj)
{    if (this == obj)        return true;    if (obj == null)        return false;    if (getClass() != obj.getClass())        return false;    PojoWithList other = (PojoWithList) obj;    if (id != other.id)        return false;    if (relatedIds == null) {        return other.relatedIds == null;    } else        return relatedIds.equals(other.relatedIds);}
cea1c2c1f10d4b97004da212612fc3f2159fe44d7c7e24cd3c5e70653f0143a5
getId
public int getId()
{    return id;}
7062c1bfe9919ab8c7f67a87a016d04f81ac6c31a31838d4009b2440a3dec97c
setId
public void setId(int id)
{    this.id = id;}
c4e3d55f9ec47d3020affbf45225f370892ef3a46d208e917a9290c0a06806ae
getRelatedIds
public int[] getRelatedIds()
{    return relatedIds;}
f152ac7e22315ce64016c2da1bf3edfb4e4ed46035e0d4ea0c7e2eb6fcb6eb12
setRelatedIds
public void setRelatedIds(int[] relatedIds)
{    this.relatedIds = relatedIds;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    final int prime = 31;    int result = 1;    result = prime * result + id;    result = prime * result + Arrays.hashCode(relatedIds);    return result;}
4afeb0868b55bdd8e18a00a3cb43d83e0714378d1c4bb36f0936daefc060e2e8
equals
public boolean equals(Object obj)
{    if (this == obj)        return true;    if (obj == null)        return false;    if (getClass() != obj.getClass())        return false;    PojoWithArray other = (PojoWithArray) obj;    if (id != other.id)        return false;    return Arrays.equals(relatedIds, other.relatedIds);}
4a6b959b5ea1b946089fcf32ee1f78c90a410f8566334e188ad74be196aea9ca
testUnsafeUtil
public void testUnsafeUtil()
{    new Tester().checkUnsafe();}
827c2cac720533507dfa237fe99ae4b646e12876c15c15a98277d079e6ed6314
testUnsafeWhenNotExists
public void testUnsafeWhenNotExists() throws Exception
{    ClassLoader cl = new NoUnsafe();    Class<?> testerClass = cl.loadClass(Tester.class.getName());    testerClass.getDeclaredMethod("checkUnsafe").invoke(testerClass.getDeclaredConstructor().newInstance());}
25231a35cb3834e113474277a82d263b9d8d1790d860b300befbbf81da1f5b98
checkUnsafe
public void checkUnsafe()
{    ReflectionUtil.getFieldAccess();}
6d5fa0dc3c11b395b5c61610ea0ab7aaa9ad7e25921e10ec8b6b99355e94af17
loadClass
public java.lang.Class<?> loadClass(String name) throws ClassNotFoundException
{    Class<?> clazz = findLoadedClass(name);    if (clazz != null) {        return clazz;    }    if ("sun.misc.Unsafe".equals(name)) {        throw new ClassNotFoundException(name);    }    if (!name.startsWith("org.apache.avro.")) {        return parent.loadClass(name);    }    InputStream data = parent.getResourceAsStream(name.replace('.', '/') + ".class");        byte[] buf = new byte[10240];    int size;    try {        size = data.read(buf);    } catch (IOException e) {        throw new ClassNotFoundException();    }    clazz = defineClass(name, buf, 0, size);    resolveClass(clazz);    return clazz;}
c78a2cc719311a35d2269da4b94079757dab5a1616c68abe27876bcfd26dc419
addUUID
public static void addUUID()
{    REFLECT.addLogicalTypeConversion(new Conversions.UUIDConversion());    REFLECT.addLogicalTypeConversion(new Conversions.DecimalConversion());    REFLECT.addLogicalTypeConversion(new TimeConversions.LocalTimestampMillisConversion());}
071efc21ec33a61a65413f9da20ec49f6cc5cae6962150c32cf6ef9c89737a64
testReflectedSchema
public void testReflectedSchema()
{    Schema expected = SchemaBuilder.record(RecordWithUUIDList.class.getName()).fields().name("uuids").type().array().items().stringType().noDefault().endRecord();    expected.getField("uuids").schema().addProp(SpecificData.CLASS_PROP, List.class.getName());    LogicalTypes.uuid().addToSchema(expected.getField("uuids").schema().getElementType());    Schema actual = REFLECT.getSchema(RecordWithUUIDList.class);    Assert.assertEquals("Should use the UUID logical type", expected, actual);}
74e378df448c6c3cd090d6daf881cfac8957dd555869ea4c13a46bdc6cdcf9a6
equals
public boolean equals(Object other)
{    if (this == other) {        return true;    }    if (other == null || getClass() != other.getClass()) {        return false;    }    DecimalRecordBytes that = (DecimalRecordBytes) other;    if (decimal == null) {        return (that.decimal == null);    }    return decimal.equals(that.decimal);}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return decimal != null ? decimal.hashCode() : 0;}
1b965e6f6f2059c42aec81533e0ae549d07f781c803aca3564de1d4fdc8b27ac
testDecimalBytes
public void testDecimalBytes() throws IOException
{    Schema schema = REFLECT.getSchema(DecimalRecordBytes.class);    Assert.assertEquals("Should have the correct record name", "org.apache.avro.reflect.TestReflectLogicalTypes", schema.getNamespace());    Assert.assertEquals("Should have the correct record name", "DecimalRecordBytes", schema.getName());    Assert.assertEquals("Should have the correct logical type", LogicalTypes.decimal(9, 2), LogicalTypes.fromSchema(schema.getField("decimal").schema()));    DecimalRecordBytes record = new DecimalRecordBytes();    record.decimal = new BigDecimal("3.14");    File test = write(REFLECT, schema, record);    Assert.assertEquals("Should match the decimal after round trip", Collections.singletonList(record), read(REFLECT.createDatumReader(schema), test));}
74e378df448c6c3cd090d6daf881cfac8957dd555869ea4c13a46bdc6cdcf9a6
equals
public boolean equals(Object other)
{    if (this == other) {        return true;    }    if (other == null || getClass() != other.getClass()) {        return false;    }    DecimalRecordFixed that = (DecimalRecordFixed) other;    if (decimal == null) {        return (that.decimal == null);    }    return decimal.equals(that.decimal);}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return decimal != null ? decimal.hashCode() : 0;}
62b5715c7bfc33517db7a7a2c02a7d6191cd3abf2f5b837e8f0f19b3b952f794
testDecimalFixed
public void testDecimalFixed() throws IOException
{    Schema schema = REFLECT.getSchema(DecimalRecordFixed.class);    Assert.assertEquals("Should have the correct record name", "org.apache.avro.reflect.TestReflectLogicalTypes", schema.getNamespace());    Assert.assertEquals("Should have the correct record name", "DecimalRecordFixed", schema.getName());    Assert.assertEquals("Should have the correct logical type", LogicalTypes.decimal(9, 2), LogicalTypes.fromSchema(schema.getField("decimal").schema()));    DecimalRecordFixed record = new DecimalRecordFixed();    record.decimal = new BigDecimal("3.14");    File test = write(REFLECT, schema, record);    Assert.assertEquals("Should match the decimal after round trip", Collections.singletonList(record), read(REFLECT.createDatumReader(schema), test));}
74e378df448c6c3cd090d6daf881cfac8957dd555869ea4c13a46bdc6cdcf9a6
equals
public boolean equals(Object other)
{    if (this == other) {        return true;    }    if (other == null || getClass() != other.getClass()) {        return false;    }    Pair<?, ?> that = (Pair<?, ?>) other;    if (first == null) {        if (that.first != null) {            return false;        }    } else if (first.equals(that.first)) {        return false;    }    if (second == null) {        return that.second == null;    } else        return !second.equals(that.second);}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return Arrays.hashCode(new Object[] { first, second });}
4731bda55f30a54c171eed7c76d740820313a690ee2451f8a913b230c9fd0ff8
of
public static Pair<X, Y> of(X first, Y second)
{    return new Pair<>(first, second);}
2c04dbb7a88bca04cb2bc2f834d6bf675f22af801cb282779bcecc25be03224c
testPairRecord
public void testPairRecord() throws IOException
{    ReflectData model = new ReflectData();    model.addLogicalTypeConversion(new Conversion<Pair>() {        @Override        public Class<Pair> getConvertedType() {            return Pair.class;        }        @Override        public String getLogicalTypeName() {            return "pair";        }        @Override        public Pair fromRecord(IndexedRecord value, Schema schema, LogicalType type) {            return Pair.of(value.get(0), value.get(1));        }        @Override        public IndexedRecord toRecord(Pair value, Schema schema, LogicalType type) {            GenericData.Record record = new GenericData.Record(schema);            record.put(0, value.first);            record.put(1, value.second);            return record;        }    });    LogicalTypes.register("pair", new LogicalTypes.LogicalTypeFactory() {        private final LogicalType PAIR = new LogicalType("pair");        @Override        public LogicalType fromSchema(Schema schema) {            return PAIR;        }    });    Schema schema = model.getSchema(PairRecord.class);    Assert.assertEquals("Should have the correct record name", "org.apache.avro.reflect.TestReflectLogicalTypes", schema.getNamespace());    Assert.assertEquals("Should have the correct record name", "PairRecord", schema.getName());    Assert.assertEquals("Should have the correct logical type", "pair", LogicalTypes.fromSchema(schema.getField("pair").schema()).getName());    PairRecord record = new PairRecord();    record.pair = Pair.of(34L, 35L);    List<PairRecord> expected = new ArrayList<>();    expected.add(record);    File test = write(model, schema, record);    Pair<Long, Long> actual = ((PairRecord) TestReflectLogicalTypes.<PairRecord>read(model.createDatumReader(schema), test).get(0)).pair;    Assert.assertEquals("Data should match after serialization round-trip", 34L, (long) actual.first);    Assert.assertEquals("Data should match after serialization round-trip", 35L, (long) actual.second);}
c47891dc46949f710f7acd64b42a5744d272939b18e20c720b0af99fbc450d83
getConvertedType
public Class<Pair> getConvertedType()
{    return Pair.class;}
79c42293ac3a43d7598dc0ac8104dd9a114e436cd5a14a6241ebbe2b10b5f8ba
getLogicalTypeName
public String getLogicalTypeName()
{    return "pair";}
1909abfe0c0ba443d0b29e153662518cbbc0c6976153a009e5cd7d919e5bcf32
fromRecord
public Pair fromRecord(IndexedRecord value, Schema schema, LogicalType type)
{    return Pair.of(value.get(0), value.get(1));}
f3412facdc8cda4f04818667af26a55ce091194372af534c62a27e784bf397b3
toRecord
public IndexedRecord toRecord(Pair value, Schema schema, LogicalType type)
{    GenericData.Record record = new GenericData.Record(schema);    record.put(0, value.first);    record.put(1, value.second);    return record;}
36dfb5961f1202e55daceaf634633d8efcfa821d6e42fb8a497c9c8192f70340
fromSchema
public LogicalType fromSchema(Schema schema)
{    return PAIR;}
341a32cdb578b032c85976394fe125322cbb295129f6fa0c4687a1cf7fcac9b7
testReadUUID
public void testReadUUID() throws IOException
{    Schema uuidSchema = SchemaBuilder.record(RecordWithUUID.class.getName()).fields().requiredString("uuid").endRecord();    LogicalTypes.uuid().addToSchema(uuidSchema.getField("uuid").schema());    UUID u1 = UUID.randomUUID();    UUID u2 = UUID.randomUUID();    RecordWithStringUUID r1 = new RecordWithStringUUID();    r1.uuid = u1.toString();    RecordWithStringUUID r2 = new RecordWithStringUUID();    r2.uuid = u2.toString();    List<RecordWithUUID> expected = Arrays.asList(new RecordWithUUID(), new RecordWithUUID());    expected.get(0).uuid = u1;    expected.get(1).uuid = u2;    File test = write(ReflectData.get().getSchema(RecordWithStringUUID.class), r1, r2);    Assert.assertEquals("Should convert Strings to UUIDs", expected, read(REFLECT.createDatumReader(uuidSchema), test));        Schema uuidStringSchema = SchemaBuilder.record(RecordWithStringUUID.class.getName()).fields().requiredString("uuid").endRecord();    LogicalTypes.uuid().addToSchema(uuidStringSchema.getField("uuid").schema());    Assert.assertEquals("Should not convert to UUID if accessor is String", Arrays.asList(r1, r2), read(REFLECT.createDatumReader(uuidStringSchema), test));}
f676a4d4af81cef00217a0e7b523cf04ddf8dae70106924cb49096112ed8f83a
testWriteUUID
public void testWriteUUID() throws IOException
{    Schema uuidSchema = SchemaBuilder.record(RecordWithUUID.class.getName()).fields().requiredString("uuid").endRecord();    LogicalTypes.uuid().addToSchema(uuidSchema.getField("uuid").schema());    UUID u1 = UUID.randomUUID();    UUID u2 = UUID.randomUUID();    RecordWithUUID r1 = new RecordWithUUID();    r1.uuid = u1;    RecordWithUUID r2 = new RecordWithUUID();    r2.uuid = u2;    List<RecordWithStringUUID> expected = Arrays.asList(new RecordWithStringUUID(), new RecordWithStringUUID());    expected.get(0).uuid = u1.toString();    expected.get(1).uuid = u2.toString();    File test = write(REFLECT, uuidSchema, r1, r2);        Schema uuidStringSchema = SchemaBuilder.record(RecordWithStringUUID.class.getName()).fields().requiredString("uuid").endRecord();    Assert.assertEquals("Should read uuid as String without UUID conversion", expected, read(REFLECT.createDatumReader(uuidStringSchema), test));    LogicalTypes.uuid().addToSchema(uuidStringSchema.getField("uuid").schema());    Assert.assertEquals("Should read uuid as String without UUID logical type", expected, read(ReflectData.get().createDatumReader(uuidStringSchema), test));}
9530cd72742c23bd9ab88394040d60173676edfbea92b7ef409b7641a156f56b
testWriteNullableUUID
public void testWriteNullableUUID() throws IOException
{    Schema nullableUuidSchema = SchemaBuilder.record(RecordWithUUID.class.getName()).fields().optionalString("uuid").endRecord();    LogicalTypes.uuid().addToSchema(nullableUuidSchema.getField("uuid").schema().getTypes().get(1));    UUID u1 = UUID.randomUUID();    UUID u2 = UUID.randomUUID();    RecordWithUUID r1 = new RecordWithUUID();    r1.uuid = u1;    RecordWithUUID r2 = new RecordWithUUID();    r2.uuid = u2;    List<RecordWithStringUUID> expected = Arrays.asList(new RecordWithStringUUID(), new RecordWithStringUUID());    expected.get(0).uuid = u1.toString();    expected.get(1).uuid = u2.toString();    File test = write(REFLECT, nullableUuidSchema, r1, r2);        Schema nullableUuidStringSchema = SchemaBuilder.record(RecordWithStringUUID.class.getName()).fields().optionalString("uuid").endRecord();    Assert.assertEquals("Should read uuid as String without UUID conversion", expected, read(ReflectData.get().createDatumReader(nullableUuidStringSchema), test));}
c57fc2b46baa9fc44ae3cc0da0c82a807b67801fed4c7c70de464ba5d17ef49c
testWriteNullableUUIDReadRequiredString
public void testWriteNullableUUIDReadRequiredString() throws IOException
{    Schema nullableUuidSchema = SchemaBuilder.record(RecordWithUUID.class.getName()).fields().optionalString("uuid").endRecord();    LogicalTypes.uuid().addToSchema(nullableUuidSchema.getField("uuid").schema().getTypes().get(1));    UUID u1 = UUID.randomUUID();    UUID u2 = UUID.randomUUID();    RecordWithUUID r1 = new RecordWithUUID();    r1.uuid = u1;    RecordWithUUID r2 = new RecordWithUUID();    r2.uuid = u2;    List<RecordWithStringUUID> expected = Arrays.asList(new RecordWithStringUUID(), new RecordWithStringUUID());    expected.get(0).uuid = u1.toString();    expected.get(1).uuid = u2.toString();    File test = write(REFLECT, nullableUuidSchema, r1, r2);        Schema uuidStringSchema = SchemaBuilder.record(RecordWithStringUUID.class.getName()).fields().requiredString("uuid").endRecord();    Assert.assertEquals("Should read uuid as String without UUID conversion", expected, read(REFLECT.createDatumReader(uuidStringSchema), test));}
c9c43ac2dc47fbade1f2df4db19c363e1ad5db6b888ab97c4b1edef46b6d107e
testReadUUIDMissingLogicalTypeUnsafe
public void testReadUUIDMissingLogicalTypeUnsafe() throws IOException
{    String unsafeValue = System.getProperty("avro.disable.unsafe");    try {                System.clearProperty("avro.disable.unsafe");        Assume.assumeTrue(ReflectionUtil.getFieldAccess() instanceof FieldAccessUnsafe);        Schema uuidSchema = SchemaBuilder.record(RecordWithUUID.class.getName()).fields().requiredString("uuid").endRecord();        LogicalTypes.uuid().addToSchema(uuidSchema.getField("uuid").schema());        UUID u1 = UUID.randomUUID();        RecordWithStringUUID r1 = new RecordWithStringUUID();        r1.uuid = u1.toString();        File test = write(ReflectData.get().getSchema(RecordWithStringUUID.class), r1);        RecordWithUUID datum = (RecordWithUUID) read(ReflectData.get().createDatumReader(uuidSchema), test).get(0);        Object uuid = datum.uuid;        Assert.assertTrue("UUID should be a String (unsafe)", uuid instanceof String);    } finally {        if (unsafeValue != null) {            System.setProperty("avro.disable.unsafe", unsafeValue);        }    }}
2c7464e0df6bb4b1208a217f24e01b7d42391907846543c9c2c9f3abf7426a19
testReadUUIDMissingLogicalTypeReflect
public void testReadUUIDMissingLogicalTypeReflect() throws IOException
{    String unsafeValue = System.getProperty("avro.disable.unsafe");    try {                System.setProperty("avro.disable.unsafe", "true");        Assume.assumeTrue(ReflectionUtil.getFieldAccess() instanceof FieldAccessReflect);        Schema uuidSchema = SchemaBuilder.record(RecordWithUUID.class.getName()).fields().requiredString("uuid").endRecord();        LogicalTypes.uuid().addToSchema(uuidSchema.getField("uuid").schema());        UUID u1 = UUID.randomUUID();        RecordWithStringUUID r1 = new RecordWithStringUUID();        r1.uuid = u1.toString();        File test = write(ReflectData.get().getSchema(RecordWithStringUUID.class), r1);        read(ReflectData.get().createDatumReader(uuidSchema), test).get(0);    } finally {        if (unsafeValue != null) {            System.setProperty("avro.disable.unsafe", unsafeValue);        }    }}
105367f5a66c82cb5ab17a1960182e4980311dfd970926dc292c3a8014dd3fd0
testWriteUUIDMissingLogicalType
public void testWriteUUIDMissingLogicalType() throws IOException
{    Schema uuidSchema = SchemaBuilder.record(RecordWithUUID.class.getName()).fields().requiredString("uuid").endRecord();    LogicalTypes.uuid().addToSchema(uuidSchema.getField("uuid").schema());    UUID u1 = UUID.randomUUID();    UUID u2 = UUID.randomUUID();    RecordWithUUID r1 = new RecordWithUUID();    r1.uuid = u1;    RecordWithUUID r2 = new RecordWithUUID();    r2.uuid = u2;        File test = write(uuidSchema, r1, r2);        Schema uuidStringSchema = SchemaBuilder.record(RecordWithStringUUID.class.getName()).fields().requiredString("uuid").endRecord();            read(ReflectData.get().createDatumReader(uuidStringSchema), test);}
019cd0f0172c3c08147773723ce04b8582434d681775f4895f43d05f9cf695a5
testReadUUIDGenericRecord
public void testReadUUIDGenericRecord() throws IOException
{    Schema uuidSchema = SchemaBuilder.record("RecordWithUUID").fields().requiredString("uuid").endRecord();    LogicalTypes.uuid().addToSchema(uuidSchema.getField("uuid").schema());    UUID u1 = UUID.randomUUID();    UUID u2 = UUID.randomUUID();    RecordWithStringUUID r1 = new RecordWithStringUUID();    r1.uuid = u1.toString();    RecordWithStringUUID r2 = new RecordWithStringUUID();    r2.uuid = u2.toString();    List<GenericData.Record> expected = Arrays.asList(new GenericData.Record(uuidSchema), new GenericData.Record(uuidSchema));    expected.get(0).put("uuid", u1);    expected.get(1).put("uuid", u2);    File test = write(ReflectData.get().getSchema(RecordWithStringUUID.class), r1, r2);    Assert.assertEquals("Should convert Strings to UUIDs", expected, read(REFLECT.createDatumReader(uuidSchema), test));        Schema uuidStringSchema = SchemaBuilder.record(RecordWithStringUUID.class.getName()).fields().requiredString("uuid").endRecord();    LogicalTypes.uuid().addToSchema(uuidSchema.getField("uuid").schema());    Assert.assertEquals("Should not convert to UUID if accessor is String", Arrays.asList(r1, r2), read(REFLECT.createDatumReader(uuidStringSchema), test));}
50361a62e41561873c0f47a341ad84c7a27c3c5392444fd7bf162d1bdfba6a90
testReadUUIDArray
public void testReadUUIDArray() throws IOException
{    Schema uuidArraySchema = SchemaBuilder.record(RecordWithUUIDArray.class.getName()).fields().name("uuids").type().array().items().stringType().noDefault().endRecord();    LogicalTypes.uuid().addToSchema(uuidArraySchema.getField("uuids").schema().getElementType());    UUID u1 = UUID.randomUUID();    UUID u2 = UUID.randomUUID();    GenericRecord r = new GenericData.Record(uuidArraySchema);    r.put("uuids", Arrays.asList(u1.toString(), u2.toString()));    RecordWithUUIDArray expected = new RecordWithUUIDArray();    expected.uuids = new UUID[] { u1, u2 };    File test = write(uuidArraySchema, r);    Assert.assertEquals("Should convert Strings to UUIDs", expected, read(REFLECT.createDatumReader(uuidArraySchema), test).get(0));}
531554f7a7efcaa6336fd72ed5e3dd580b60a4ffcdb4f9ba760e0c0e7468b983
testWriteUUIDArray
public void testWriteUUIDArray() throws IOException
{    Schema uuidArraySchema = SchemaBuilder.record(RecordWithUUIDArray.class.getName()).fields().name("uuids").type().array().items().stringType().noDefault().endRecord();    LogicalTypes.uuid().addToSchema(uuidArraySchema.getField("uuids").schema().getElementType());    Schema stringArraySchema = SchemaBuilder.record("RecordWithUUIDArray").fields().name("uuids").type().array().items().stringType().noDefault().endRecord();    stringArraySchema.getField("uuids").schema().addProp(SpecificData.CLASS_PROP, List.class.getName());    UUID u1 = UUID.randomUUID();    UUID u2 = UUID.randomUUID();    GenericRecord expected = new GenericData.Record(stringArraySchema);    List<String> uuids = new ArrayList<>();    uuids.add(u1.toString());    uuids.add(u2.toString());    expected.put("uuids", uuids);    RecordWithUUIDArray r = new RecordWithUUIDArray();    r.uuids = new UUID[] { u1, u2 };    File test = write(REFLECT, uuidArraySchema, r);    Assert.assertEquals("Should read UUIDs as Strings", expected, read(ReflectData.get().createDatumReader(stringArraySchema), test).get(0));}
614828981f4219d9de96b3f274b55e3649fd9c3256302c3bbcf68b61ac941293
testReadUUIDList
public void testReadUUIDList() throws IOException
{    Schema uuidListSchema = SchemaBuilder.record(RecordWithUUIDList.class.getName()).fields().name("uuids").type().array().items().stringType().noDefault().endRecord();    uuidListSchema.getField("uuids").schema().addProp(SpecificData.CLASS_PROP, List.class.getName());    LogicalTypes.uuid().addToSchema(uuidListSchema.getField("uuids").schema().getElementType());    UUID u1 = UUID.randomUUID();    UUID u2 = UUID.randomUUID();    GenericRecord r = new GenericData.Record(uuidListSchema);    r.put("uuids", Arrays.asList(u1.toString(), u2.toString()));    RecordWithUUIDList expected = new RecordWithUUIDList();    expected.uuids = Arrays.asList(u1, u2);    File test = write(uuidListSchema, r);    Assert.assertEquals("Should convert Strings to UUIDs", expected, read(REFLECT.createDatumReader(uuidListSchema), test).get(0));}
a8fe40c2000d9deeed638f97c318ec6aca2b0293c73b19631d80c04142046ad3
testWriteUUIDList
public void testWriteUUIDList() throws IOException
{    Schema uuidListSchema = SchemaBuilder.record(RecordWithUUIDList.class.getName()).fields().name("uuids").type().array().items().stringType().noDefault().endRecord();    uuidListSchema.getField("uuids").schema().addProp(SpecificData.CLASS_PROP, List.class.getName());    LogicalTypes.uuid().addToSchema(uuidListSchema.getField("uuids").schema().getElementType());    Schema stringArraySchema = SchemaBuilder.record("RecordWithUUIDArray").fields().name("uuids").type().array().items().stringType().noDefault().endRecord();    stringArraySchema.getField("uuids").schema().addProp(SpecificData.CLASS_PROP, List.class.getName());    UUID u1 = UUID.randomUUID();    UUID u2 = UUID.randomUUID();    GenericRecord expected = new GenericData.Record(stringArraySchema);    expected.put("uuids", Arrays.asList(u1.toString(), u2.toString()));    RecordWithUUIDList r = new RecordWithUUIDList();    r.uuids = Arrays.asList(u1, u2);    File test = write(REFLECT, uuidListSchema, r);    Assert.assertEquals("Should read UUIDs as Strings", expected, read(REFLECT.createDatumReader(stringArraySchema), test).get(0));}
993b4a4edb8457b0c2e0c7f0f83a4fcf2f9015a6b70f8f0f7b529241c63e3144
testReflectedSchemaLocalDateTime
public void testReflectedSchemaLocalDateTime()
{    Schema actual = REFLECT.getSchema(RecordWithTimestamps.class);    Assert.assertEquals("Should have the correct record name", "org.apache.avro.reflect", actual.getNamespace());    Assert.assertEquals("Should have the correct record name", "RecordWithTimestamps", actual.getName());    Assert.assertEquals("Should have the correct physical type", Schema.Type.LONG, actual.getField("localDateTime").schema().getType());    Assert.assertEquals("Should have the correct logical type", LogicalTypes.localTimestampMillis(), LogicalTypes.fromSchema(actual.getField("localDateTime").schema()));}
985d53dec096c145411fdbe8660b2df72370c6d6189d84f11d6a80530672a95b
read
private static List<D> read(DatumReader<D> reader, File file) throws IOException
{    List<D> data = new ArrayList<>();    try (FileReader<D> fileReader = new DataFileReader<>(file, reader)) {        for (D datum : fileReader) {            data.add(datum);        }    }    return data;}
7266ec28b8527de20895c66429c2ca054a197631a9a47bd401e7254cbbc068a7
write
private File write(Schema schema, D... data) throws IOException
{    return write(ReflectData.get(), schema, data);}
28e27a5e2a408002182af84ed4939b4f658ea15840fb2ad3c9de4f0e687bfabe
write
private File write(GenericData model, Schema schema, D... data) throws IOException
{    File file = temp.newFile();    DatumWriter<D> writer = model.createDatumWriter(schema);    try (DataFileWriter<D> fileWriter = new DataFileWriter<>(writer)) {        fileWriter.create(schema, file);        for (D datum : data) {            fileWriter.append(datum);        }    }    return file;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return uuid.hashCode();}
4afeb0868b55bdd8e18a00a3cb43d83e0714378d1c4bb36f0936daefc060e2e8
equals
public boolean equals(Object obj)
{    if (obj == null) {        return false;    }    if (!(obj instanceof RecordWithUUID)) {        return false;    }    RecordWithUUID that = (RecordWithUUID) obj;    return this.uuid.equals(that.uuid);}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return uuid.hashCode();}
4afeb0868b55bdd8e18a00a3cb43d83e0714378d1c4bb36f0936daefc060e2e8
equals
public boolean equals(Object obj)
{    if (obj == null) {        return false;    }    if (!(obj instanceof RecordWithStringUUID)) {        return false;    }    RecordWithStringUUID that = (RecordWithStringUUID) obj;    return this.uuid.equals(that.uuid);}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return Arrays.hashCode(uuids);}
4afeb0868b55bdd8e18a00a3cb43d83e0714378d1c4bb36f0936daefc060e2e8
equals
public boolean equals(Object obj)
{    if (obj == null) {        return false;    }    if (!(obj instanceof RecordWithUUIDArray)) {        return false;    }    RecordWithUUIDArray that = (RecordWithUUIDArray) obj;    return Arrays.equals(this.uuids, that.uuids);}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return uuids.hashCode();}
4afeb0868b55bdd8e18a00a3cb43d83e0714378d1c4bb36f0936daefc060e2e8
equals
public boolean equals(Object obj)
{    if (obj == null) {        return false;    }    if (!(obj instanceof RecordWithUUIDList)) {        return false;    }    RecordWithUUIDList that = (RecordWithUUIDList) obj;    return this.uuids.equals(that.uuids);}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return Objects.hash(localDateTime);}
4afeb0868b55bdd8e18a00a3cb43d83e0714378d1c4bb36f0936daefc060e2e8
equals
public boolean equals(Object obj)
{    if (obj == null) {        return false;    }    if (!(obj instanceof RecordWithTimestamps)) {        return false;    }    RecordWithTimestamps that = (RecordWithTimestamps) obj;    return Objects.equals(that.localDateTime, that.localDateTime);}
64706bfcdc25a6308d11d702baacbf9dbac8176e7848be0e819da8d1859b6bdb
getClassSchema
public static org.apache.avro.Schema getClassSchema()
{    return SCHEMA$;}
0264c77363528029939532675a231c880279f3f7af300cc0fd1433685c23711c
getDecoder
public static BinaryMessageDecoder<TestRecordWithLogicalTypes> getDecoder()
{    return DECODER;}
9ced02703e28a5d7900c8781d6ce97b788c8cc12698b175d41e31745f8386cfe
createDecoder
public static BinaryMessageDecoder<TestRecordWithLogicalTypes> createDecoder(SchemaStore resolver)
{    return new BinaryMessageDecoder<TestRecordWithLogicalTypes>(MODEL$, SCHEMA$, resolver);}
473bffa2e264c9a7f493a4236175e1428e5d97836bf372b01eb5b1692afcd748
toByteBuffer
public java.nio.ByteBuffer toByteBuffer() throws java.io.IOException
{    return ENCODER.encode(this);}
ab01b44532dc1748cebcaea0891e36cf343428e5bcda806d86b587b1b10ded0e
fromByteBuffer
public static TestRecordWithLogicalTypes fromByteBuffer(java.nio.ByteBuffer b) throws java.io.IOException
{    return DECODER.decode(b);}
1fa124aa67dc73ccd01002de70d29d68ea9dacd5d97cf4663025da360e9c4749
getSchema
public org.apache.avro.Schema getSchema()
{    return SCHEMA$;}
233b384682c68bdb89ad70c35a2e59b7341b16a68e84517dc4f51d4ce5753ebf
get
public java.lang.Object get(int field$)
{    switch(field$) {        case 0:            return b;        case 1:            return i32;        case 2:            return i64;        case 3:            return f32;        case 4:            return f64;        case 5:            return s;        case 6:            return d;        case 7:            return t;        case 8:            return ts;        case 9:            return dec;        default:            throw new org.apache.avro.AvroRuntimeException("Bad index");    }}
5d771c696600ecd230514c4bcb92450e7aeedfc92ab71e9837199a0477dd3382
getConversion
public org.apache.avro.Conversion<?> getConversion(int field)
{    return conversions[field];}
f13ccb2ddd4dfda02b51ba2bf6b82a34d33026ae9bcb3de86f779f47722fb1ac
put
public void put(int field$, java.lang.Object value$)
{    switch(field$) {        case 0:            b = (java.lang.Boolean) value$;            break;        case 1:            i32 = (java.lang.Integer) value$;            break;        case 2:            i64 = (java.lang.Long) value$;            break;        case 3:            f32 = (java.lang.Float) value$;            break;        case 4:            f64 = (java.lang.Double) value$;            break;        case 5:            s = (java.lang.CharSequence) value$;            break;        case 6:            d = (java.time.LocalDate) value$;            break;        case 7:            t = (java.time.LocalTime) value$;            break;        case 8:            ts = (java.time.Instant) value$;            break;        case 9:            dec = (java.math.BigDecimal) value$;            break;        default:            throw new org.apache.avro.AvroRuntimeException("Bad index");    }}
7be044410605f84731a969c1b6a9e0984b22d26ddb7b1155ff69caaa71883b5b
getB
public java.lang.Boolean getB()
{    return b;}
11df67c5a9928383745a6b39f51bbd3f8d04d172ebecd52877566f8418ff487e
setB
public void setB(java.lang.Boolean value)
{    this.b = value;}
fa55ba440fc6920db55e4e28bc15d274accf419b63eee4539168ab67eb8df55d
getI32
public java.lang.Integer getI32()
{    return i32;}
100ed79d1a0cbf60191b8d50d627ccca478f9687e34ffd339766fb91df864ddd
setI32
public void setI32(java.lang.Integer value)
{    this.i32 = value;}
f457ad9327e25bbc419304b244f8ffdefad1759b6a858f2e0f5dc0a27630edb0
getI64
public java.lang.Long getI64()
{    return i64;}
aa4a65e6a222255644277806724ee08a14422f4cc0420966acb1380de5fbb49e
setI64
public void setI64(java.lang.Long value)
{    this.i64 = value;}
4d012d4bd950267cb39749e5dfd759ae93993695a6ffc6565124167522495bba
getF32
public java.lang.Float getF32()
{    return f32;}
168acaa03fabde7df545473f56d862a537d8aa4273bd9b8b9e6c4163f87133d7
setF32
public void setF32(java.lang.Float value)
{    this.f32 = value;}
4c4d3a2cb45de216d27df8a8d37c5db0be6e7faae2f3eb34aed5e4b14c20fa04
getF64
public java.lang.Double getF64()
{    return f64;}
be249fa37e6b0b57043a2bee4202ca7e57b6b8244b5ef5fa60f528837e8b6dc7
setF64
public void setF64(java.lang.Double value)
{    this.f64 = value;}
5a37eb77c2b53ca3d5130cbc9418a33ba01e94c4913deccff86834cc2e3f352a
getS
public java.lang.CharSequence getS()
{    return s;}
edfa62515a9c6306a2c9f207b92c13ac5bb39da45fee212af03e5666966a7c7a
setS
public void setS(java.lang.CharSequence value)
{    this.s = value;}
64e333d56ab829ff437f25e300ded13e7cbc0da22820edbdc828b2336019f699
getD
public java.time.LocalDate getD()
{    return d;}
7c0006a487525148b4fc1bdf8d13d4e1afd25562e86d7a4a87517ad0b2188911
setD
public void setD(java.time.LocalDate value)
{    this.d = value;}
ad23f7e5cc4da24ce0a53429e108a31ad3db0d599d0900184a26bdf38658eddd
getT
public java.time.LocalTime getT()
{    return t;}
c5ff422571920041ccc7ee9cc8515e6ed4cd977ea6c2624bad8e6c741723f039
setT
public void setT(java.time.LocalTime value)
{    this.t = value;}
ca82eda7390c93018741e49ba3211cc48fc8c1ae5c97f55c2ade76444702d382
getTs
public java.time.Instant getTs()
{    return ts;}
8b0be48ff4710d64486c0337670f3a885083ac006e4f85269cb9082cd5c5cf56
setTs
public void setTs(java.time.Instant value)
{    this.ts = value;}
9c8e71db63b48140fee854a5f7a26ab099b5d5d215bcb896f9a149039e155072
getDec
public java.math.BigDecimal getDec()
{    return dec;}
f4eb06994d2f057e77974dfb2c2b55cdbf910a947aac891367ed5bd6f48224cf
setDec
public void setDec(java.math.BigDecimal value)
{    this.dec = value;}
2a2b3e8f9b2e18e69cf4dbcb117af734a485037a8d5aa20c95415faddae6d3e8
newBuilder
public static TestRecordWithLogicalTypes.Builder newBuilder()
{    return new TestRecordWithLogicalTypes.Builder();}
7587da3a3a7cac1557b424bbbc74aed95368b34f6be805a90253789a455e65a6
newBuilder
public static TestRecordWithLogicalTypes.Builder newBuilder(TestRecordWithLogicalTypes.Builder other)
{    if (other == null) {        return new TestRecordWithLogicalTypes.Builder();    } else {        return new TestRecordWithLogicalTypes.Builder(other);    }}
2d646aad86dd899d6b9c49649342194beacbcc6e4878a7522b486218b32ad495
newBuilder
public static TestRecordWithLogicalTypes.Builder newBuilder(TestRecordWithLogicalTypes other)
{    if (other == null) {        return new TestRecordWithLogicalTypes.Builder();    } else {        return new TestRecordWithLogicalTypes.Builder(other);    }}
7be044410605f84731a969c1b6a9e0984b22d26ddb7b1155ff69caaa71883b5b
getB
public java.lang.Boolean getB()
{    return b;}
d18b9c78e0dbd34f9efb758f0dc4aabd29af08be9d05d3bc44be3529eecbf061
setB
public TestRecordWithLogicalTypes.Builder setB(boolean value)
{    validate(fields()[0], value);    this.b = value;    fieldSetFlags()[0] = true;    return this;}
81309c48615a7f190cfebfc0bc44cbd67345867e070ead3dc544487cf1e4d328
hasB
public boolean hasB()
{    return fieldSetFlags()[0];}
c69e1e954aed6dee4c01f66338db369dcab056c5d3b4f2c8dd65a0ca421597a7
clearB
public TestRecordWithLogicalTypes.Builder clearB()
{    fieldSetFlags()[0] = false;    return this;}
fa55ba440fc6920db55e4e28bc15d274accf419b63eee4539168ab67eb8df55d
getI32
public java.lang.Integer getI32()
{    return i32;}
0affdfd9a4528c50920ba18e77e1da561034e6bc28f9dcb6f5d6477ec8ddd600
setI32
public TestRecordWithLogicalTypes.Builder setI32(int value)
{    validate(fields()[1], value);    this.i32 = value;    fieldSetFlags()[1] = true;    return this;}
4b309c40463993b308dc788947c4e1262748a6d75918286eca956cb95e5ac23e
hasI32
public boolean hasI32()
{    return fieldSetFlags()[1];}
402fcf54453b8d5c80eedb32104243953988e4c8092d942d072ccccee92311c7
clearI32
public TestRecordWithLogicalTypes.Builder clearI32()
{    fieldSetFlags()[1] = false;    return this;}
f457ad9327e25bbc419304b244f8ffdefad1759b6a858f2e0f5dc0a27630edb0
getI64
public java.lang.Long getI64()
{    return i64;}
0da9e0a32f83ecbd94ef338180ba49b23a368a68b0e350e64115eaab6f29a93b
setI64
public TestRecordWithLogicalTypes.Builder setI64(long value)
{    validate(fields()[2], value);    this.i64 = value;    fieldSetFlags()[2] = true;    return this;}
eff9ba731264a67992c5ec2d6b9dc2caa8120b6ee015d9ab33da8b770a355b13
hasI64
public boolean hasI64()
{    return fieldSetFlags()[2];}
527af1ef2ddc5d93b5dc1501fa88cc55fe593c522cd36912be2bcd3b3fa7af4b
clearI64
public TestRecordWithLogicalTypes.Builder clearI64()
{    fieldSetFlags()[2] = false;    return this;}
4d012d4bd950267cb39749e5dfd759ae93993695a6ffc6565124167522495bba
getF32
public java.lang.Float getF32()
{    return f32;}
97d16bd73f60feebffe87d4ca9bc0ba9393ab6feb0967c516adf3d7a79f9a40c
setF32
public TestRecordWithLogicalTypes.Builder setF32(float value)
{    validate(fields()[3], value);    this.f32 = value;    fieldSetFlags()[3] = true;    return this;}
6bfe4cbf03fa75c08fc5baccdda3be66e4724f3659636e2190c79761044081fc
hasF32
public boolean hasF32()
{    return fieldSetFlags()[3];}
5fc6b4280cec1a791df2cbeedd6f950c2736a4b3d3d2c2cc30956b658a86cca5
clearF32
public TestRecordWithLogicalTypes.Builder clearF32()
{    fieldSetFlags()[3] = false;    return this;}
4c4d3a2cb45de216d27df8a8d37c5db0be6e7faae2f3eb34aed5e4b14c20fa04
getF64
public java.lang.Double getF64()
{    return f64;}
78ca7f574eabb4da08280afc5f2ce6db3b5fad9772073d9f0d2723b1c457e942
setF64
public TestRecordWithLogicalTypes.Builder setF64(double value)
{    validate(fields()[4], value);    this.f64 = value;    fieldSetFlags()[4] = true;    return this;}
3563f329578e95c686e30429b597b20ee5698f640509ccbbdbec450315ab5413
hasF64
public boolean hasF64()
{    return fieldSetFlags()[4];}
2423a600bc4c1f1e30ae56b81b588a5c80c291670e622d2122d8f17cb73532e9
clearF64
public TestRecordWithLogicalTypes.Builder clearF64()
{    fieldSetFlags()[4] = false;    return this;}
5a37eb77c2b53ca3d5130cbc9418a33ba01e94c4913deccff86834cc2e3f352a
getS
public java.lang.CharSequence getS()
{    return s;}
d1b3729612483749f5f4693b974f9d1e8b219fdc61693aa4b4b0f77cf3a53b0b
setS
public TestRecordWithLogicalTypes.Builder setS(java.lang.CharSequence value)
{    validate(fields()[5], value);    this.s = value;    fieldSetFlags()[5] = true;    return this;}
c87c0532c9cc7f0c5410b791d5388f0397a6e1c029dc0639b399949557365b92
hasS
public boolean hasS()
{    return fieldSetFlags()[5];}
32b512bf32762187c5b3d9a5c22d9b0065406ceb7dca36f3dbb571080e64623e
clearS
public TestRecordWithLogicalTypes.Builder clearS()
{    s = null;    fieldSetFlags()[5] = false;    return this;}
64e333d56ab829ff437f25e300ded13e7cbc0da22820edbdc828b2336019f699
getD
public java.time.LocalDate getD()
{    return d;}
cdc5d6f8239877edbd1de716c13a89ffaeb0e3cc3e5a20461fb5d5eddd4c190a
setD
public TestRecordWithLogicalTypes.Builder setD(java.time.LocalDate value)
{    validate(fields()[6], value);    this.d = value;    fieldSetFlags()[6] = true;    return this;}
977bb2e80d004814aadfab9564d94ac230ac447f75341e3a7d871d4fec1f43b1
hasD
public boolean hasD()
{    return fieldSetFlags()[6];}
1d754f8f6b6e9bedfb6a7f84d4a0be24c931490bde53fc6e5b604826484570ba
clearD
public TestRecordWithLogicalTypes.Builder clearD()
{    fieldSetFlags()[6] = false;    return this;}
ad23f7e5cc4da24ce0a53429e108a31ad3db0d599d0900184a26bdf38658eddd
getT
public java.time.LocalTime getT()
{    return t;}
cfc5a2e1859c0a9d78690b6b1b824fcca981b0028100a04ae701c3722677f19a
setT
public TestRecordWithLogicalTypes.Builder setT(java.time.LocalTime value)
{    validate(fields()[7], value);    this.t = value;    fieldSetFlags()[7] = true;    return this;}
20c05b5e480fe5554af886cdf555cfb7869ca99214e1d6f757d4fd61162dfb0d
hasT
public boolean hasT()
{    return fieldSetFlags()[7];}
502af6b785dd60318ea507338016263c47d84e5af88d74117b89e7135d0312d9
clearT
public TestRecordWithLogicalTypes.Builder clearT()
{    fieldSetFlags()[7] = false;    return this;}
ca82eda7390c93018741e49ba3211cc48fc8c1ae5c97f55c2ade76444702d382
getTs
public java.time.Instant getTs()
{    return ts;}
5786ec1e54cd4ae8709c3cb7d12aef54e7d2756e16a4f7075beb4741170db64c
setTs
public TestRecordWithLogicalTypes.Builder setTs(java.time.Instant value)
{    validate(fields()[8], value);    this.ts = value;    fieldSetFlags()[8] = true;    return this;}
dbb01070df9f942bd2b0421dd8bb5f885c9fb3b1424046edab0997d383d4ae69
hasTs
public boolean hasTs()
{    return fieldSetFlags()[8];}
254689644e945c7224c726ea33766b8c38945095b299d6e7625d8319138fef34
clearTs
public TestRecordWithLogicalTypes.Builder clearTs()
{    fieldSetFlags()[8] = false;    return this;}
9c8e71db63b48140fee854a5f7a26ab099b5d5d215bcb896f9a149039e155072
getDec
public java.math.BigDecimal getDec()
{    return dec;}
35be4ded769350229b2757ba65f70a68659667480c55a317ed87458aea246f93
setDec
public TestRecordWithLogicalTypes.Builder setDec(java.math.BigDecimal value)
{    validate(fields()[9], value);    this.dec = value;    fieldSetFlags()[9] = true;    return this;}
ea0ab15142016ed051113b0fe96b1234f27411b000b4c309b5156a97ec7c3211
hasDec
public boolean hasDec()
{    return fieldSetFlags()[9];}
a3793c6a3f63e23e4d141fdec7e5dae3c2cbe0b396c0fcdec1e388fc5f97a87a
clearDec
public TestRecordWithLogicalTypes.Builder clearDec()
{    dec = null;    fieldSetFlags()[9] = false;    return this;}
2fe75df30c878be05a0ffa86e444f678108e7b7106b8a20deca8e98e959b9bf8
build
public TestRecordWithLogicalTypes build()
{    try {        TestRecordWithLogicalTypes record = new TestRecordWithLogicalTypes();        record.b = fieldSetFlags()[0] ? this.b : (java.lang.Boolean) defaultValue(fields()[0]);        record.i32 = fieldSetFlags()[1] ? this.i32 : (java.lang.Integer) defaultValue(fields()[1]);        record.i64 = fieldSetFlags()[2] ? this.i64 : (java.lang.Long) defaultValue(fields()[2]);        record.f32 = fieldSetFlags()[3] ? this.f32 : (java.lang.Float) defaultValue(fields()[3]);        record.f64 = fieldSetFlags()[4] ? this.f64 : (java.lang.Double) defaultValue(fields()[4]);        record.s = fieldSetFlags()[5] ? this.s : (java.lang.CharSequence) defaultValue(fields()[5]);        record.d = fieldSetFlags()[6] ? this.d : (java.time.LocalDate) defaultValue(fields()[6]);        record.t = fieldSetFlags()[7] ? this.t : (java.time.LocalTime) defaultValue(fields()[7]);        record.ts = fieldSetFlags()[8] ? this.ts : (java.time.Instant) defaultValue(fields()[8]);        record.dec = fieldSetFlags()[9] ? this.dec : (java.math.BigDecimal) defaultValue(fields()[9]);        return record;    } catch (java.lang.Exception e) {        throw new org.apache.avro.AvroRuntimeException(e);    }}
6d36b57419a3667bad09c1fd5c626a8bbcaa3071bb613cccc8d36de3695f7d49
writeExternal
public void writeExternal(java.io.ObjectOutput out) throws java.io.IOException
{    WRITER$.write(this, SpecificData.getEncoder(out));}
d60b919d286c4bc0127bcfa26c40b7baeb61384a75f05a3630240b5b84af9aa8
readExternal
public void readExternal(java.io.ObjectInput in) throws java.io.IOException
{    READER$.read(this, SpecificData.getDecoder(in));}
64706bfcdc25a6308d11d702baacbf9dbac8176e7848be0e819da8d1859b6bdb
getClassSchema
public static org.apache.avro.Schema getClassSchema()
{    return SCHEMA$;}
473bffa2e264c9a7f493a4236175e1428e5d97836bf372b01eb5b1692afcd748
toByteBuffer
public java.nio.ByteBuffer toByteBuffer() throws java.io.IOException
{    return ENCODER.encode(this);}
fa3f4a10c993575cbd465218fc27921377d615165535605b7884e584e26fe798
fromByteBuffer
public static TestRecordWithoutLogicalTypes fromByteBuffer(java.nio.ByteBuffer b) throws java.io.IOException
{    return DECODER.decode(b);}
1fa124aa67dc73ccd01002de70d29d68ea9dacd5d97cf4663025da360e9c4749
getSchema
public org.apache.avro.Schema getSchema()
{    return SCHEMA$;}
233b384682c68bdb89ad70c35a2e59b7341b16a68e84517dc4f51d4ce5753ebf
get
public java.lang.Object get(int field$)
{    switch(field$) {        case 0:            return b;        case 1:            return i32;        case 2:            return i64;        case 3:            return f32;        case 4:            return f64;        case 5:            return s;        case 6:            return d;        case 7:            return t;        case 8:            return ts;        case 9:            return dec;        default:            throw new org.apache.avro.AvroRuntimeException("Bad index");    }}
f13ccb2ddd4dfda02b51ba2bf6b82a34d33026ae9bcb3de86f779f47722fb1ac
put
public void put(int field$, java.lang.Object value$)
{    switch(field$) {        case 0:            b = (java.lang.Boolean) value$;            break;        case 1:            i32 = (java.lang.Integer) value$;            break;        case 2:            i64 = (java.lang.Long) value$;            break;        case 3:            f32 = (java.lang.Float) value$;            break;        case 4:            f64 = (java.lang.Double) value$;            break;        case 5:            s = (java.lang.String) value$;            break;        case 6:            d = (java.lang.Integer) value$;            break;        case 7:            t = (java.lang.Integer) value$;            break;        case 8:            ts = (java.lang.Long) value$;            break;        case 9:            dec = (java.nio.ByteBuffer) value$;            break;        default:            throw new org.apache.avro.AvroRuntimeException("Bad index");    }}
7be044410605f84731a969c1b6a9e0984b22d26ddb7b1155ff69caaa71883b5b
getB
public java.lang.Boolean getB()
{    return b;}
fa55ba440fc6920db55e4e28bc15d274accf419b63eee4539168ab67eb8df55d
getI32
public java.lang.Integer getI32()
{    return i32;}
f457ad9327e25bbc419304b244f8ffdefad1759b6a858f2e0f5dc0a27630edb0
getI64
public java.lang.Long getI64()
{    return i64;}
4d012d4bd950267cb39749e5dfd759ae93993695a6ffc6565124167522495bba
getF32
public java.lang.Float getF32()
{    return f32;}
4c4d3a2cb45de216d27df8a8d37c5db0be6e7faae2f3eb34aed5e4b14c20fa04
getF64
public java.lang.Double getF64()
{    return f64;}
95d135864882f21a8b024ae45a335985125d48db6ef1573c383b0b03a0639e36
getS
public java.lang.String getS()
{    return s;}
b892f808c912532ec22441c4920eada0fefa9c63997b7faf7c728387b78d7eb8
getD
public java.lang.Integer getD()
{    return d;}
8724d77b1a60e317e22e6bb264747639a2f33cb75db76250bf0ae4bfacebea3a
getT
public java.lang.Integer getT()
{    return t;}
28212ec4b755ac4dceb74bf86bb46676f15a91fd50f116fdb6936ca8ab126093
getTs
public java.lang.Long getTs()
{    return ts;}
423a03b9fb52b79cd1a03b8688bd7ca791c759b23c0259a3056ee966721e32c3
getDec
public java.nio.ByteBuffer getDec()
{    return dec;}
36bc23e54f5a75e525c6c238badf5cca1049836354e86b7f7c9765231d91ae27
newBuilder
public static TestRecordWithoutLogicalTypes.Builder newBuilder()
{    return new TestRecordWithoutLogicalTypes.Builder();}
6f023268b755623eebe9c72bdffc73d322b507d07bfe01dfac8d33459ed8aac4
newBuilder
public static TestRecordWithoutLogicalTypes.Builder newBuilder(TestRecordWithoutLogicalTypes.Builder other)
{    return new TestRecordWithoutLogicalTypes.Builder(other);}
ea3b885b5074e5405dd0a87b610d75356345bdae088ef99d1ff3391e0c26b2de
newBuilder
public static TestRecordWithoutLogicalTypes.Builder newBuilder(TestRecordWithoutLogicalTypes other)
{    return new TestRecordWithoutLogicalTypes.Builder(other);}
7be044410605f84731a969c1b6a9e0984b22d26ddb7b1155ff69caaa71883b5b
getB
public java.lang.Boolean getB()
{    return b;}
2bb537d71c832d7db9f60a98f4d2b635642112c5e6a64a6d2da75a756294f710
setB
public TestRecordWithoutLogicalTypes.Builder setB(boolean value)
{    validate(fields()[0], value);    this.b = value;    fieldSetFlags()[0] = true;    return this;}
81309c48615a7f190cfebfc0bc44cbd67345867e070ead3dc544487cf1e4d328
hasB
public boolean hasB()
{    return fieldSetFlags()[0];}
d0308a6fe828af48c03e96e076c240b4b5b3637428f2f2c21f17ac3751fe0512
clearB
public TestRecordWithoutLogicalTypes.Builder clearB()
{    fieldSetFlags()[0] = false;    return this;}
fa55ba440fc6920db55e4e28bc15d274accf419b63eee4539168ab67eb8df55d
getI32
public java.lang.Integer getI32()
{    return i32;}
055c2fcab182493137b601ba809a6af8eac79ba2127734af79770ad555d64e98
setI32
public TestRecordWithoutLogicalTypes.Builder setI32(int value)
{    validate(fields()[1], value);    this.i32 = value;    fieldSetFlags()[1] = true;    return this;}
4b309c40463993b308dc788947c4e1262748a6d75918286eca956cb95e5ac23e
hasI32
public boolean hasI32()
{    return fieldSetFlags()[1];}
b00cd58ec29faa262eb519812694af43acf0860c1eeb1e33f64058862c508e97
clearI32
public TestRecordWithoutLogicalTypes.Builder clearI32()
{    fieldSetFlags()[1] = false;    return this;}
f457ad9327e25bbc419304b244f8ffdefad1759b6a858f2e0f5dc0a27630edb0
getI64
public java.lang.Long getI64()
{    return i64;}
11325abe9a060976a27db29759e5f4aaadb99f9b0b4e3ff7a2511cfc3ded6f76
setI64
public TestRecordWithoutLogicalTypes.Builder setI64(long value)
{    validate(fields()[2], value);    this.i64 = value;    fieldSetFlags()[2] = true;    return this;}
eff9ba731264a67992c5ec2d6b9dc2caa8120b6ee015d9ab33da8b770a355b13
hasI64
public boolean hasI64()
{    return fieldSetFlags()[2];}
a6fe199dd65a2ff856d94aa96a56a84c3aeb17505d9f52a933ecfc85a5370165
clearI64
public TestRecordWithoutLogicalTypes.Builder clearI64()
{    fieldSetFlags()[2] = false;    return this;}
4d012d4bd950267cb39749e5dfd759ae93993695a6ffc6565124167522495bba
getF32
public java.lang.Float getF32()
{    return f32;}
df18b52b2abbde198784be49d32e14888f62f9bfa69fcc45753b82dba96fa42e
setF32
public TestRecordWithoutLogicalTypes.Builder setF32(float value)
{    validate(fields()[3], value);    this.f32 = value;    fieldSetFlags()[3] = true;    return this;}
6bfe4cbf03fa75c08fc5baccdda3be66e4724f3659636e2190c79761044081fc
hasF32
public boolean hasF32()
{    return fieldSetFlags()[3];}
ca35e49d7b7232d21d7433675b57335656bfded84cd9a5a4bee3af9ea11a1284
clearF32
public TestRecordWithoutLogicalTypes.Builder clearF32()
{    fieldSetFlags()[3] = false;    return this;}
4c4d3a2cb45de216d27df8a8d37c5db0be6e7faae2f3eb34aed5e4b14c20fa04
getF64
public java.lang.Double getF64()
{    return f64;}
755ff585955228424ddeb75d2bac03bafb4252b696790676282771417d46802e
setF64
public TestRecordWithoutLogicalTypes.Builder setF64(double value)
{    validate(fields()[4], value);    this.f64 = value;    fieldSetFlags()[4] = true;    return this;}
3563f329578e95c686e30429b597b20ee5698f640509ccbbdbec450315ab5413
hasF64
public boolean hasF64()
{    return fieldSetFlags()[4];}
8ee6a40b2bc7319c3b6eb24560b28df9b9b83afc68bf092ae05d5ee173ec348b
clearF64
public TestRecordWithoutLogicalTypes.Builder clearF64()
{    fieldSetFlags()[4] = false;    return this;}
95d135864882f21a8b024ae45a335985125d48db6ef1573c383b0b03a0639e36
getS
public java.lang.String getS()
{    return s;}
4098ba41ed7ab5478f90d35406bbc9f2b3bc897c1039660793a4e49aaed04e3a
setS
public TestRecordWithoutLogicalTypes.Builder setS(java.lang.String value)
{    validate(fields()[5], value);    this.s = value;    fieldSetFlags()[5] = true;    return this;}
c87c0532c9cc7f0c5410b791d5388f0397a6e1c029dc0639b399949557365b92
hasS
public boolean hasS()
{    return fieldSetFlags()[5];}
5037b73048e2188038b98b9373d2ef57c250e564e37b8f8b6d072c8c78d2ee23
clearS
public TestRecordWithoutLogicalTypes.Builder clearS()
{    s = null;    fieldSetFlags()[5] = false;    return this;}
b892f808c912532ec22441c4920eada0fefa9c63997b7faf7c728387b78d7eb8
getD
public java.lang.Integer getD()
{    return d;}
f373ec3f0225a9b4f4c370965dc51fe8d16bb5e32eea0479158581df78969859
setD
public TestRecordWithoutLogicalTypes.Builder setD(int value)
{    validate(fields()[6], value);    this.d = value;    fieldSetFlags()[6] = true;    return this;}
977bb2e80d004814aadfab9564d94ac230ac447f75341e3a7d871d4fec1f43b1
hasD
public boolean hasD()
{    return fieldSetFlags()[6];}
8078dd183475200e7fb3da437720e9755dd2aba137cb43e8e9422100bb5544df
clearD
public TestRecordWithoutLogicalTypes.Builder clearD()
{    fieldSetFlags()[6] = false;    return this;}
8724d77b1a60e317e22e6bb264747639a2f33cb75db76250bf0ae4bfacebea3a
getT
public java.lang.Integer getT()
{    return t;}
40d4ea5a28d423f949abaf520a3e8f70065197f6f3c9166104098665d3520017
setT
public TestRecordWithoutLogicalTypes.Builder setT(int value)
{    validate(fields()[7], value);    this.t = value;    fieldSetFlags()[7] = true;    return this;}
20c05b5e480fe5554af886cdf555cfb7869ca99214e1d6f757d4fd61162dfb0d
hasT
public boolean hasT()
{    return fieldSetFlags()[7];}
96f679761253a70e83b826c1a5ffc900d87ec906515495733e99e1a089afca39
clearT
public TestRecordWithoutLogicalTypes.Builder clearT()
{    fieldSetFlags()[7] = false;    return this;}
28212ec4b755ac4dceb74bf86bb46676f15a91fd50f116fdb6936ca8ab126093
getTs
public java.lang.Long getTs()
{    return ts;}
53171a9b8e9137dc408cf7d26e671930f0707e5199c6aaa9eb8a238727ca4f61
setTs
public TestRecordWithoutLogicalTypes.Builder setTs(long value)
{    validate(fields()[8], value);    this.ts = value;    fieldSetFlags()[8] = true;    return this;}
dbb01070df9f942bd2b0421dd8bb5f885c9fb3b1424046edab0997d383d4ae69
hasTs
public boolean hasTs()
{    return fieldSetFlags()[8];}
e18330125f4881d542a6dfac7a67bc45292ced039650f4259e5e41d0d2d1520f
clearTs
public TestRecordWithoutLogicalTypes.Builder clearTs()
{    fieldSetFlags()[8] = false;    return this;}
423a03b9fb52b79cd1a03b8688bd7ca791c759b23c0259a3056ee966721e32c3
getDec
public java.nio.ByteBuffer getDec()
{    return dec;}
cbc143c1eb2f66ef46c0d3e1c82173ad6af986d03b1d2bdb5945a22f73e3fe59
setDec
public TestRecordWithoutLogicalTypes.Builder setDec(java.nio.ByteBuffer value)
{    validate(fields()[9], value);    this.dec = value;    fieldSetFlags()[9] = true;    return this;}
ea0ab15142016ed051113b0fe96b1234f27411b000b4c309b5156a97ec7c3211
hasDec
public boolean hasDec()
{    return fieldSetFlags()[9];}
5d8ac85f6e4d9dee4f8d7a91507ae3ad0b5e0dfbb51dcb50f69e4f098a48a31e
clearDec
public TestRecordWithoutLogicalTypes.Builder clearDec()
{    fieldSetFlags()[9] = false;    return this;}
1da92f1327457c714df6c5414fed350ea50db69a3070392ba460b6021d79d8cb
build
public TestRecordWithoutLogicalTypes build()
{    try {        TestRecordWithoutLogicalTypes record = new TestRecordWithoutLogicalTypes();        record.b = fieldSetFlags()[0] ? this.b : (java.lang.Boolean) defaultValue(fields()[0]);        record.i32 = fieldSetFlags()[1] ? this.i32 : (java.lang.Integer) defaultValue(fields()[1]);        record.i64 = fieldSetFlags()[2] ? this.i64 : (java.lang.Long) defaultValue(fields()[2]);        record.f32 = fieldSetFlags()[3] ? this.f32 : (java.lang.Float) defaultValue(fields()[3]);        record.f64 = fieldSetFlags()[4] ? this.f64 : (java.lang.Double) defaultValue(fields()[4]);        record.s = fieldSetFlags()[5] ? this.s : (java.lang.String) defaultValue(fields()[5]);        record.d = fieldSetFlags()[6] ? this.d : (java.lang.Integer) defaultValue(fields()[6]);        record.t = fieldSetFlags()[7] ? this.t : (java.lang.Integer) defaultValue(fields()[7]);        record.ts = fieldSetFlags()[8] ? this.ts : (java.lang.Long) defaultValue(fields()[8]);        record.dec = fieldSetFlags()[9] ? this.dec : (java.nio.ByteBuffer) defaultValue(fields()[9]);        return record;    } catch (Exception e) {        throw new org.apache.avro.AvroRuntimeException(e);    }}
4adaefafec562702d887f5960a1408e5f9d1add92c42fab7cb857d701c42d2a2
setUp
public void setUp()
{    Schema intSchema = Schema.create(Type.INT);    intClass = SpecificData.get().getClass(intSchema);    Schema nullSchema = Schema.create(Type.NULL);    Schema nullIntUnionSchema = Schema.createUnion(Arrays.asList(nullSchema, intSchema));    integerClass = SpecificData.get().getClass(nullIntUnionSchema);}
cd3703ccbf8ced3bc240e49e9c33c8196cca3801837f36fc8462c03e7d13225e
testClassTypes
public void testClassTypes()
{    assertTrue(intClass.isPrimitive());    assertFalse(integerClass.isPrimitive());}
6f508a779069f42a04332ba8ab24fa904f53e12f4a052d1e003194c7438c06ab
testPrimitiveParam
public void testPrimitiveParam() throws Exception
{    assertNotNull(Reflection.class.getMethod("primitive", intClass));}
744abc9f33abaf981e6104d05dbba404ccfe6db5b14faa8e53226ca6bcc697a3
testPrimitiveParamError
public void testPrimitiveParamError() throws Exception
{    Reflection.class.getMethod("primitiveWrapper", intClass);}
707735c8508097bbc883d282b2bf7c6e59067abe74c324c60e765413663e4d57
testPrimitiveWrapperParam
public void testPrimitiveWrapperParam() throws Exception
{    assertNotNull(Reflection.class.getMethod("primitiveWrapper", integerClass));}
c0cf66b10805f49eeffdf0e18b736e50e1e86c558b8ffc83bb59f89a59aab45c
testPrimitiveWrapperParamError
public void testPrimitiveWrapperParamError() throws Exception
{    Reflection.class.getMethod("primitive", integerClass);}
e13c5470041b12d135b696bf3b70f73322e423098b986d3893d0bba028d6f2c2
primitive
public void primitive(int i)
{}
9ae748638fb4777df79cb1faa2d63364abb38b75f73349767ec6298b75d9af6c
primitiveWrapper
public void primitiveWrapper(Integer i)
{}
24a0e8f4089701b155328460d08976411ba0d7f744b77ab2e712496ffa81b814
put
public void put(int i, Object v)
{    switch(i) {        case 0:            x = (Integer) v;            break;        case 1:            y = (String) v;            break;        default:            throw new RuntimeException();    }}
2ea0205e522ed62ca511b522fdeaf1cedf0c2afbc5adfc3869c76d9961e32934
get
public Object get(int i)
{    switch(i) {        case 0:            return x;        case 1:            return y;    }    throw new RuntimeException();}
b74ae948bba816a824396f5fcd959e744592a67ff01eb79c422acb487a04550a
getSchema
public Schema getSchema()
{    return SCHEMA;}
b0acb15e9bb93338d55f77f5dfae23f602aaada348feeb3cdebf0339a8f364dc
testSpecificRecordBase
public void testSpecificRecordBase()
{    final TestRecord record = new TestRecord();    record.put("x", 1);    record.put("y", "str");    assertEquals(1, record.get("x"));    assertEquals("str", record.get("y"));}
be5d247f84109f4838d7902701a9d142b52ae94facc72e4ac928d1b2a9e15ebc
testExternalizeable
public void testExternalizeable() throws Exception
{    final TestRecord before = new TestRecord();    before.put("x", 1);    before.put("y", "str");    ByteArrayOutputStream bytes = new ByteArrayOutputStream();    ObjectOutputStream out = new ObjectOutputStream(bytes);    out.writeObject(before);    out.close();    ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(bytes.toByteArray()));    TestRecord after = (TestRecord) in.readObject();    assertEquals(before, after);}
388e51db2db201f8c8397f66d83e556c2aa54cdc131fbae4894cd04bc68b89d1
testNonStringable
public void testNonStringable() throws Exception
{    final Schema string = Schema.create(Type.STRING);    final ByteArrayOutputStream baos = new ByteArrayOutputStream();    final Encoder encoder = EncoderFactory.get().directBinaryEncoder(baos, null);    final DatumWriter<Object> writer = new SpecificDatumWriter<>(string);    try {        writer.write(new Object(), encoder);        fail("Non stringable object should be rejected.");    } catch (ClassCastException cce) {        }}
bcf147a5d3bb492b7f9e130b71d701989bcf70ca00770e500e18f749fd6b7085
testSpecificToFromByteBufferWithLogicalTypes
public void testSpecificToFromByteBufferWithLogicalTypes() throws IOException
{                LocalTime t = LocalTime.now().truncatedTo(ChronoUnit.MILLIS);    Instant instant = Instant.now().truncatedTo(ChronoUnit.MILLIS);    final TestRecordWithLogicalTypes record = new TestRecordWithLogicalTypes(true, 34, 35L, 3.14F, 3019.34, null, LocalDate.now(), t, instant, new BigDecimal("123.45"));    final ByteBuffer b = record.toByteBuffer();    final TestRecordWithLogicalTypes copy = TestRecordWithLogicalTypes.fromByteBuffer(b);    assertEquals(record, copy);}
f07553a9e021fca234100e9d0cadd8736e46d31acb5ec5f552c4265047b408c0
testSpecificToFromByteBufferWithoutLogicalTypes
public void testSpecificToFromByteBufferWithoutLogicalTypes() throws IOException
{    final TestRecordWithoutLogicalTypes record = new TestRecordWithoutLogicalTypes(true, 34, 35L, 3.14F, 3019.34, null, (int) System.currentTimeMillis() / 1000, (int) System.currentTimeMillis() / 1000, System.currentTimeMillis(), new Conversions.DecimalConversion().toBytes(new BigDecimal("123.45"), null, LogicalTypes.decimal(9, 2)));    final ByteBuffer b = record.toByteBuffer();    final TestRecordWithoutLogicalTypes copy = TestRecordWithoutLogicalTypes.fromByteBuffer(b);    assertEquals(record, copy);}
851d620a52d2d1ba3fb96338061a6c849ebeefa1a07f80737e27e4ead65afd43
testSpecificByteArrayIncompatibleWithLogicalTypes
public void testSpecificByteArrayIncompatibleWithLogicalTypes() throws IOException
{    final TestRecordWithoutLogicalTypes withoutLogicalTypes = new TestRecordWithoutLogicalTypes(true, 34, 35L, 3.14F, 3019.34, null, (int) System.currentTimeMillis() / 1000, (int) System.currentTimeMillis() / 1000, System.currentTimeMillis(), new Conversions.DecimalConversion().toBytes(new BigDecimal("123.45"), null, LogicalTypes.decimal(9, 2)));    final ByteBuffer b = withoutLogicalTypes.toByteBuffer();    TestRecordWithLogicalTypes.fromByteBuffer(b);}
373f45cda5b7c71c4d78004bb86aae4e17e6a70bfd95895ea83a380d7450955c
testSpecificByteArrayIncompatibleWithoutLogicalTypes
public void testSpecificByteArrayIncompatibleWithoutLogicalTypes() throws IOException
{    final TestRecordWithLogicalTypes withLogicalTypes = new TestRecordWithLogicalTypes(true, 34, 35L, 3.14F, 3019.34, null, LocalDate.now(), LocalTime.now(), Instant.now(), new BigDecimal("123.45"));    final ByteBuffer b = withLogicalTypes.toByteBuffer();    TestRecordWithoutLogicalTypes.fromByteBuffer(b);}
289f1597a90218f911e45f224f3873845000475f617e37a65359e3bd3730e2bb
addToSchema
public Schema addToSchema(Schema schema)
{    super.addToSchema(schema);    schema.addProp(REF_FIELD_NAME, refFieldName);    return schema;}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return REFERENCE;}
01aa68945a139be25e68182e6c2ace30ccb9c3f7d0434c19b73ba2eb738d249f
getRefFieldName
public String getRefFieldName()
{    return refFieldName;}
9c8753af4248bc6cfdffb49d546cd09255922836141b423436c52fa0aa74ca10
validate
public void validate(Schema schema)
{    super.validate(schema);    if (schema.getField(refFieldName) == null) {        throw new IllegalArgumentException("Invalid field name for reference field: " + refFieldName);    }}
289f1597a90218f911e45f224f3873845000475f617e37a65359e3bd3730e2bb
addToSchema
public Schema addToSchema(Schema schema)
{    super.addToSchema(schema);    schema.addProp(ID_FIELD_NAME, idFieldName);    return schema;}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return REFERENCEABLE;}
f8e09dad628707a829c0e2d23d88c8458496eac0226a41d3b1aff69ac1a5c7e0
getIdFieldName
public String getIdFieldName()
{    return idFieldName;}
9c8753af4248bc6cfdffb49d546cd09255922836141b423436c52fa0aa74ca10
validate
public void validate(Schema schema)
{    super.validate(schema);    Schema.Field idField = schema.getField(idFieldName);    if (idField == null || idField.schema().getType() != Schema.Type.LONG) {        throw new IllegalArgumentException("Invalid ID field: " + idFieldName + ": " + idField);    }}
8934432fbfaf426d90a3233ebe4bbb4328f5f426473c0e3f93d68cd56a5a3633
addReferenceTypes
public static void addReferenceTypes()
{    LogicalTypes.register(Referenceable.REFERENCEABLE, Referenceable::new);    LogicalTypes.register(Reference.REFERENCE, Reference::new);}
80b91eb29d1cd366cfa574b40daa486878dbcadcefc58689e978239cb4b55523
getTracker
public ReferenceableTracker getTracker()
{    return tracker;}
fd3d35b5e0b88bf86decbf7d01f1146f1a48a8c745e135894dd7f7463d2e27be
getHandler
public ReferenceHandler getHandler()
{    return handler;}
f92605823fb7877eeb08f467eea27b2cdaca618b4e506aad7289bc8911942951
getConvertedType
public Class<IndexedRecord> getConvertedType()
{    return (Class) Record.class;}
79c42293ac3a43d7598dc0ac8104dd9a114e436cd5a14a6241ebbe2b10b5f8ba
getLogicalTypeName
public String getLogicalTypeName()
{    return Referenceable.REFERENCEABLE;}
74f1d0d8347b078c3b2e80d2b57e1459534d5500aa6e5912e00bb4e78f7ff936
fromRecord
public IndexedRecord fromRecord(IndexedRecord value, Schema schema, LogicalType type)
{        long id = getId(value, schema);        references.put(id, value);        List<Callback> callbacks = callbacksById.get(id);    for (Callback callback : callbacks) {        callback.set(value);    }    return value;}
76fb806e3f145050af6e203e07da7cbe15b55ad008a8369e9d7c7f93f5062ecc
toRecord
public IndexedRecord toRecord(IndexedRecord value, Schema schema, LogicalType type)
{        long id = getId(value, schema);            ids.put(value, id);    return value;}
768814ab06160ca6ffe6b225238703ca62c561757d27bbcc0c1ed72d254851f9
getId
private long getId(IndexedRecord referenceable, Schema schema)
{    Referenceable info = (Referenceable) schema.getLogicalType();    int idField = schema.getField(info.getIdFieldName()).pos();    return (Long) referenceable.get(idField);}
f92605823fb7877eeb08f467eea27b2cdaca618b4e506aad7289bc8911942951
getConvertedType
public Class<IndexedRecord> getConvertedType()
{    return (Class) Record.class;}
79c42293ac3a43d7598dc0ac8104dd9a114e436cd5a14a6241ebbe2b10b5f8ba
getLogicalTypeName
public String getLogicalTypeName()
{    return Reference.REFERENCE;}
e6501f7e3f02931fb2bc84f12d9c39b3dc51f0041acd59b2270fdc980c2b4c13
fromRecord
public IndexedRecord fromRecord(final IndexedRecord record, Schema schema, LogicalType type)
{        final Schema.Field refField = schema.getField(((Reference) type).getRefFieldName());    Long id = (Long) record.get(refField.pos());    if (id != null) {        if (references.containsKey(id)) {            record.put(refField.pos(), references.get(id));        } else {            List<Callback> callbacks = callbacksById.computeIfAbsent(id, k -> new ArrayList<>());                        callbacks.add(referenceable -> record.put(refField.pos(), referenceable));        }    }    return record;}
1a66c5f5007aea6c5778b0b239109e79c7fff31a257d038f5e31b37a4659b567
toRecord
public IndexedRecord toRecord(IndexedRecord record, Schema schema, LogicalType type)
{        Schema.Field refField = schema.getField(((Reference) type).getRefFieldName());    IndexedRecord referenced = (IndexedRecord) record.get(refField.pos());    if (referenced == null) {        return record;    }        return new HijackingIndexedRecord(record, refField.pos(), ids.get(referenced));}
24a0e8f4089701b155328460d08976411ba0d7f744b77ab2e712496ffa81b814
put
public void put(int i, Object v)
{    throw new RuntimeException("[BUG] This is a read-only class.");}
2ea0205e522ed62ca511b522fdeaf1cedf0c2afbc5adfc3869c76d9961e32934
get
public Object get(int i)
{    if (i == index) {        return data;    }    return wrapped.get(i);}
b74ae948bba816a824396f5fcd959e744592a67ff01eb79c422acb487a04550a
getSchema
public Schema getSchema()
{    return wrapped.getSchema();}
a2a314ef22554dd92e27423b4f2d7f98b9f605698c00bf86585d1f2c50b7ab22
test
public void test() throws IOException
{    ReferenceManager manager = new ReferenceManager();    GenericData model = new GenericData();    model.addLogicalTypeConversion(manager.getTracker());    model.addLogicalTypeConversion(manager.getHandler());    Schema parentSchema = Schema.createRecord("Parent", null, null, false);    Schema parentRefSchema = Schema.createUnion(Schema.create(Schema.Type.NULL), Schema.create(Schema.Type.LONG), parentSchema);    Reference parentRef = new Reference("parent");    List<Schema.Field> childFields = new ArrayList<>();    childFields.add(new Schema.Field("c", Schema.create(Schema.Type.STRING)));    childFields.add(new Schema.Field("parent", parentRefSchema));    Schema childSchema = parentRef.addToSchema(Schema.createRecord("Child", null, null, false, childFields));    List<Schema.Field> parentFields = new ArrayList<>();    parentFields.add(new Schema.Field("id", Schema.create(Schema.Type.LONG)));    parentFields.add(new Schema.Field("p", Schema.create(Schema.Type.STRING)));    parentFields.add(new Schema.Field("child", childSchema));    parentSchema.setFields(parentFields);    Referenceable idRef = new Referenceable("id");    Schema schema = idRef.addToSchema(parentSchema);    System.out.println("Schema: " + schema.toString(true));    Record parent = new Record(schema);    parent.put("id", 1L);    parent.put("p", "parent data!");    Record child = new Record(childSchema);    child.put("c", "child data!");    child.put("parent", parent);    parent.put("child", child);        File data = write(model, schema, parent);    List<Record> records = read(model, schema, data);    Record actual = records.get(0);        Assert.assertEquals("Should correctly read back the parent id", 1L, actual.get("id"));    Assert.assertEquals("Should correctly read back the parent data", new Utf8("parent data!"), actual.get("p"));    Record actualChild = (Record) actual.get("child");    Assert.assertEquals("Should correctly read back the child data", new Utf8("child data!"), actualChild.get("c"));    Object childParent = actualChild.get("parent");    Assert.assertTrue("Should have a parent Record object", childParent instanceof Record);    Record childParentRecord = (Record) actualChild.get("parent");    Assert.assertEquals("Should have the right parent id", 1L, childParentRecord.get("id"));    Assert.assertEquals("Should have the right parent data", new Utf8("parent data!"), childParentRecord.get("p"));}
c4a100b593ab090ec2cf3a2d876828f1672c9fd67fc6970b3daf7a63359da998
read
private List<D> read(GenericData model, Schema schema, File file) throws IOException
{    DatumReader<D> reader = newReader(model, schema);    List<D> data = new ArrayList<>();    try (FileReader<D> fileReader = new DataFileReader<>(file, reader)) {        for (D datum : fileReader) {            data.add(datum);        }    }    return data;}
1477653d597d32c98b7096205acbae5e34afaf976ac45367ad406ff9f4c015ea
newReader
private DatumReader<D> newReader(GenericData model, Schema schema)
{    return model.createDatumReader(schema);}
28e27a5e2a408002182af84ed4939b4f658ea15840fb2ad3c9de4f0e687bfabe
write
private File write(GenericData model, Schema schema, D... data) throws IOException
{    File file = temp.newFile();    DatumWriter<D> writer = model.createDatumWriter(schema);    try (DataFileWriter<D> fileWriter = new DataFileWriter<>(writer)) {        fileWriter.create(schema, file);        for (D datum : data) {            fileWriter.append(datum);        }    }    return file;}
3b38ddf3ca4f5c32afc04b3392a741e468684178216cd5380dbcd4b822c3e1d6
codecs
public static List<Object[]> codecs()
{    List<Object[]> r = new ArrayList<>();    r.add(new Object[] { null });    r.add(new Object[] { CodecFactory.deflateCodec(0) });    r.add(new Object[] { CodecFactory.deflateCodec(1) });    r.add(new Object[] { CodecFactory.deflateCodec(9) });    r.add(new Object[] { CodecFactory.nullCodec() });    r.add(new Object[] { CodecFactory.snappyCodec() });    r.add(new Object[] { CodecFactory.xzCodec(0) });    r.add(new Object[] { CodecFactory.xzCodec(1) });    r.add(new Object[] { CodecFactory.xzCodec(6) });    r.add(new Object[] { CodecFactory.zstandardCodec(-5) });    r.add(new Object[] { CodecFactory.zstandardCodec(0, true) });    r.add(new Object[] { CodecFactory.zstandardCodec(5, false) });    r.add(new Object[] { CodecFactory.zstandardCodec(18, true) });    return r;}
6b75fd1716bafc331e5b920453b62dfb9bd224b195aa798018605262a208e9ae
makeFile
private File makeFile()
{    return new File(DIR.getRoot().getPath(), "test-" + codec + ".avro");}
3e79f00488eb1e51412af24aff162ecb29c178f612062ebc2a2ed74b5fa0ac77
runTestsInOrder
public void runTestsInOrder() throws Exception
{    testGenericWrite();    testGenericRead();    testSplits();    testSyncDiscovery();    testGenericAppend();    testReadWithHeader();    testFSync(false);    testFSync(true);}
7b952aa7e494c554c315b3dd857ed040b4e6b77ec75f5ac6e6820c18b6be4c5b
testGenericWrite
private void testGenericWrite() throws IOException
{    DataFileWriter<Object> writer = new DataFileWriter<>(new GenericDatumWriter<>()).setSyncInterval(100);    if (codec != null) {        writer.setCodec(codec);    }    writer.create(SCHEMA, makeFile());    try {        int count = 0;        for (Object datum : new RandomData(SCHEMA, COUNT, SEED)) {            writer.append(datum);            if (++count % (COUNT / 3) == 0)                                writer.sync();            if (count == 5) {                                boolean threwProperly = false;                try {                    GenericData.Record record = (GenericData.Record) datum;                    record.put(1, null);                    threwProperly = true;                    writer.append(record);                    threwProperly = false;                } catch (DataFileWriter.AppendWriteException e) {                    System.out.println("Ignoring: " + e);                }                assertTrue("failed to throw when expected", threwProperly);            }        }    } finally {        writer.close();    }        Exception doubleCloseEx = null;    try {        writer.close();    } catch (Exception e) {        doubleCloseEx = e;    }    assertNull("Double close() threw an unexpected exception", doubleCloseEx);}
270bc533877a1e25f50077401da3c4f565a3c0433798296d170e20981766e91e
testGenericRead
private void testGenericRead() throws IOException
{    try (DataFileReader<Object> reader = new DataFileReader<>(makeFile(), new GenericDatumReader<>())) {        Object datum = null;        if (VALIDATE) {            for (Object expected : new RandomData(SCHEMA, COUNT, SEED)) {                datum = reader.next(datum);                assertEquals(expected, datum);            }        } else {            for (int i = 0; i < COUNT; i++) {                datum = reader.next(datum);            }        }    }}
dd21769b215bcf8a8c9eb173ed394070ac1da6082c137710a6ab045657e987a0
testSplits
private void testSplits() throws IOException
{    File file = makeFile();    try (DataFileReader<Object> reader = new DataFileReader<>(file, new GenericDatumReader<>())) {        Random rand = new Random(SEED);                int splits = 10;                int length = (int) file.length();                int end = length;                int remaining = end;                int count = 0;        while (remaining > 0) {            int start = Math.max(0, end - rand.nextInt(2 * length / splits));                        reader.sync(start);            while (!reader.pastSync(end)) {                reader.next();                count++;            }            remaining -= end - start;            end = start;        }        assertEquals(COUNT, count);    }}
0131751ff9dd78641f22c220e472c75a25d91b52ffcc61202aff38366aff44c9
testSyncDiscovery
private void testSyncDiscovery() throws IOException
{    File file = makeFile();    try (DataFileReader<Object> reader = new DataFileReader<>(file, new GenericDatumReader<>())) {                ArrayList<Long> syncs = new ArrayList<>();        long previousSync = -1;        while (reader.hasNext()) {            if (reader.previousSync() != previousSync) {                previousSync = reader.previousSync();                syncs.add(previousSync);            }            reader.next();        }                reader.sync(0);        assertEquals(reader.previousSync(), (long) syncs.get(0));                for (Long sync : syncs) {            reader.seek(sync);            assertNotNull(reader.next());        }    }}
a3c3175ba2007bbbb781bac6edb504e570e004575b165fc7046f5e42492f58f7
testGenericAppend
private void testGenericAppend() throws IOException
{    File file = makeFile();    long start = file.length();    try (DataFileWriter<Object> writer = new DataFileWriter<>(new GenericDatumWriter<>()).appendTo(file)) {        for (Object datum : new RandomData(SCHEMA, COUNT, SEED + 1)) {            writer.append(datum);        }    }    try (DataFileReader<Object> reader = new DataFileReader<>(file, new GenericDatumReader<>())) {        reader.seek(start);        Object datum = null;        if (VALIDATE) {            for (Object expected : new RandomData(SCHEMA, COUNT, SEED + 1)) {                datum = reader.next(datum);                assertEquals(expected, datum);            }        } else {            for (int i = 0; i < COUNT; i++) {                datum = reader.next(datum);            }        }    }}
728dceb6b7bc5bb7a9037770ceb432e94b371c6a4b07080d2d084bcb17e15656
testReadWithHeader
private void testReadWithHeader() throws IOException
{    File file = makeFile();    DataFileReader<Object> reader = new DataFileReader<>(file, new GenericDatumReader<>());        DataFileStream.Header header = reader.getHeader();        SeekableFileInput sin = new SeekableFileInput(file);    sin.seek(sin.length() / 2);    reader = DataFileReader.openReader(sin, new GenericDatumReader<>(), header, true);    assertNotNull("Should be able to reopen from arbitrary point", reader.next());    long validPos = reader.previousSync();        sin.seek(validPos);    reader = DataFileReader.openReader(sin, new GenericDatumReader<>(), header, false);    assertEquals("Should not move from sync point on reopen", validPos, sin.tell());    assertNotNull("Should be able to reopen at sync point", reader.next());}
6baaa13d9175d6a3d30f18fcd30deb2b9dba885e1a7c04e678cf4a60f2c67348
testSyncInHeader
public void testSyncInHeader() throws IOException
{    DataFileReader<Object> reader = new DataFileReader<>(new File("../../../share/test/data/syncInMeta.avro"), new GenericDatumReader<>());    reader.sync(0);    for (Object datum : reader) assertNotNull(datum);}
cee3a581ae83797519d03949ac4a131efaa1a17e8518ebd93d7d4947932137a9
test12
public void test12() throws IOException
{    readFile(new File("../../../share/test/data/test.avro12"), new GenericDatumReader<>());}
3395c8936c7d0f889e835780457e6720c14defc014f1bc23ffb9dd1e53e72ed2
testFlushCount
public void testFlushCount() throws IOException
{    DataFileWriter<Object> writer = new DataFileWriter<>(new GenericDatumWriter<>());    writer.setFlushOnEveryBlock(false);    TestingByteArrayOutputStream out = new TestingByteArrayOutputStream();    writer.create(SCHEMA, out);    int currentCount = 0;    int flushCounter = 0;    try {        for (Object datum : new RandomData(SCHEMA, COUNT, SEED + 1)) {            currentCount++;            writer.append(datum);            writer.sync();            if (currentCount % 10 == 0) {                flushCounter++;                writer.flush();            }        }    } finally {        writer.close();    }    System.out.println("Total number of flushes: " + out.flushCount);                        assertTrue(out.flushCount < currentCount && out.flushCount >= flushCounter);}
b00efa070324176ecea8c8981766f0e9a6eb164f0609464bddb289d449520962
testFSync
private void testFSync(boolean useFile) throws IOException
{    try (DataFileWriter<Object> writer = new DataFileWriter<>(new GenericDatumWriter<>())) {        writer.setFlushOnEveryBlock(false);        TestingByteArrayOutputStream out = new TestingByteArrayOutputStream();        if (useFile) {            File f = makeFile();            try (SeekableFileInput in = new SeekableFileInput(f)) {                writer.appendTo(in, out);            }        } else {            writer.create(SCHEMA, out);        }        int currentCount = 0;        int syncCounter = 0;        for (Object datum : new RandomData(SCHEMA, COUNT, SEED + 1)) {            currentCount++;            writer.append(datum);            if (currentCount % 10 == 0) {                writer.fSync();                syncCounter++;            }        }        System.out.println("Total number of syncs: " + out.syncCount);        assertEquals(syncCounter, out.syncCount);    }}
3db4d1cb149009e16758625ddb269e84cc6cdba464b1d7249da96d7e30ec2002
readFile
 static void readFile(File f, DatumReader<? extends Object> datumReader) throws IOException
{    FileReader<? extends Object> reader = DataFileReader.openReader(f, datumReader);    for (Object datum : reader) {        assertNotNull(datum);    }}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    File input = new File(args[0]);    Schema projection = null;    if (args.length > 1)        projection = new Schema.Parser().parse(new File(args[1]));    TestDataFile.readFile(input, new GenericDatumReader<>(null, projection));    long start = System.currentTimeMillis();    for (int i = 0; i < 4; i++) TestDataFile.readFile(input, new GenericDatumReader<>(null, projection));    System.out.println("Time: " + (System.currentTimeMillis() - start));}
c3e67ec76f1b008887f1caba645a2614900cde6e477acca1bc3ecc36bf357fcf
flush
public void flush() throws IOException
{    super.flush();    flushCount++;}
ebf6369c0a538e889b3acec39360edad82f3c2ebed8c3c27b004adbf0ab4b95a
sync
public void sync() throws IOException
{    syncCount++;}
3b38ddf3ca4f5c32afc04b3392a741e468684178216cd5380dbcd4b822c3e1d6
codecs
public static List<Object[]> codecs()
{    List<Object[]> r = new ArrayList<>();    r.add(new Object[] { null, null, false });    r.add(new Object[] { null, null, true });    r.add(new Object[] { CodecFactory.deflateCodec(1), CodecFactory.deflateCodec(6), false });    r.add(new Object[] { CodecFactory.deflateCodec(1), CodecFactory.deflateCodec(6), true });    r.add(new Object[] { CodecFactory.deflateCodec(3), CodecFactory.nullCodec(), false });    r.add(new Object[] { CodecFactory.nullCodec(), CodecFactory.deflateCodec(6), false });    r.add(new Object[] { CodecFactory.xzCodec(1), CodecFactory.xzCodec(2), false });    r.add(new Object[] { CodecFactory.xzCodec(1), CodecFactory.xzCodec(2), true });    r.add(new Object[] { CodecFactory.xzCodec(2), CodecFactory.nullCodec(), false });    r.add(new Object[] { CodecFactory.nullCodec(), CodecFactory.xzCodec(2), false });    return r;}
1304309e788d57d290ed130f441cf17d19d216b47211bb2ec756c0bb22a48951
makeFile
private File makeFile(String name)
{    return new File(DIR.getRoot().getPath(), "test-" + name + ".avro");}
d341554e215e17a26db0eca3bb63a5a3627f3c8141f4ce21f9e63aa786996dbc
testConcatenateFiles
public void testConcatenateFiles() throws IOException
{    System.out.println("SEED = " + SEED);    System.out.println("COUNT = " + COUNT);    for (int k = 0; k < 5; k++) {        int syncInterval = 460 + k;        RandomData data1 = new RandomData(SCHEMA, COUNT, SEED);        RandomData data2 = new RandomData(SCHEMA, COUNT, SEED + 1);        File file1 = makeFile((codec == null ? "null" : codec.toString()) + "-A");        File file2 = makeFile((codec2 == null ? "null" : codec2.toString()) + "-B");        DataFileWriter<Object> writer = new DataFileWriter<>(new GenericDatumWriter<>()).setSyncInterval(syncInterval);        if (codec != null) {            writer.setCodec(codec);        }        writer.create(SCHEMA, file1);        try {            for (Object datum : data1) {                writer.append(datum);            }        } finally {            writer.close();        }        DataFileWriter<Object> writer2 = new DataFileWriter<>(new GenericDatumWriter<>()).setSyncInterval(syncInterval);        if (codec2 != null) {            writer2.setCodec(codec2);        }        writer2.create(SCHEMA, file2);        try {            for (Object datum : data2) {                writer2.append(datum);            }        } finally {            writer2.close();        }        DataFileWriter<Object> concatinto = new DataFileWriter<>(new GenericDatumWriter<>()).setSyncInterval(syncInterval);        concatinto.appendTo(file1);        DataFileReader<Object> concatfrom = new DataFileReader<>(file2, new GenericDatumReader<>());        concatinto.appendAllFrom(concatfrom, recompress);        concatinto.close();        concatfrom.close();        concatfrom = new DataFileReader<>(file2, new GenericDatumReader<>());        DataFileReader<Object> concat = new DataFileReader<>(file1, new GenericDatumReader<>());        int count = 0;        try {            Object datum = null;            if (VALIDATE) {                for (Object expected : data1) {                    datum = concat.next(datum);                    assertEquals("at " + count++, expected, datum);                }                for (Object expected : data2) {                    datum = concatfrom.next(datum);                    assertEquals("at " + count++, expected, datum);                }                for (Object expected : data2) {                    datum = concat.next(datum);                    assertEquals("at " + count++, expected, datum);                }            } else {                for (int i = 0; i < COUNT * 2; i++) {                    datum = concat.next(datum);                }            }        } finally {            if (count != 3 * COUNT) {                System.out.println(count + " " + k);            }            concat.close();            concatfrom.close();        }    }}
1304309e788d57d290ed130f441cf17d19d216b47211bb2ec756c0bb22a48951
makeFile
private File makeFile(String name)
{    return new File(DIR, "test-" + name + ".avro");}
28031d8a6a0deddef2a17ea33e9d99115fb5afc4a942b48b1f9e413e57dedf4e
testCorruptedFile
public void testCorruptedFile() throws IOException
{    Schema schema = Schema.create(Type.STRING);        DataFileWriter<Utf8> w = new DataFileWriter<>(new GenericDatumWriter<>(schema));    ByteArrayOutputStream baos = new ByteArrayOutputStream();    w.create(schema, baos);    w.append(new Utf8("apple"));    w.append(new Utf8("banana"));    w.sync();    w.append(new Utf8("celery"));    w.append(new Utf8("date"));    long pos = w.sync();    w.append(new Utf8("endive"));    w.append(new Utf8("fig"));    w.close();            byte[] original = baos.toByteArray();    int corruptPosition = (int) pos - DataFileConstants.SYNC_SIZE;    int corruptedBytes = 3;    byte[] corrupted = new byte[original.length + corruptedBytes];    System.arraycopy(original, 0, corrupted, 0, corruptPosition);    System.arraycopy(original, corruptPosition, corrupted, corruptPosition + corruptedBytes, original.length - corruptPosition);    File file = makeFile("corrupt");    file.deleteOnExit();    FileOutputStream out = new FileOutputStream(file);    out.write(corrupted);    out.close();        DataFileReader r = new DataFileReader<>(file, new GenericDatumReader<>(schema));    assertEquals("apple", r.next().toString());    assertEquals("banana", r.next().toString());    long prevSync = r.previousSync();    try {        r.next();        fail("Corrupt block should throw exception");    } catch (AvroRuntimeException e) {        assertEquals("Invalid sync!", e.getCause().getMessage());    }        r.sync(prevSync);    assertEquals("endive", r.next().toString());    assertEquals("fig", r.next().toString());    assertFalse(r.hasNext());}
e2f8f5bccda7b099cacd47499198770e9eb794f5d4cfa98484a97f82e1d3135a
createDataFile
private byte[] createDataFile(byte[] sync) throws IOException
{    Schema schema = Schema.create(Type.STRING);    DataFileWriter<Utf8> w = new DataFileWriter<>(new GenericDatumWriter<>(schema));    ByteArrayOutputStream baos = new ByteArrayOutputStream();    w.create(schema, baos, sync);    w.append(new Utf8("apple"));    w.append(new Utf8("banana"));    w.sync();    w.append(new Utf8("celery"));    w.append(new Utf8("date"));    w.sync();    w.append(new Utf8("endive"));    w.append(new Utf8("fig"));    w.close();    return baos.toByteArray();}
0cdfda99c450b02d3728040872d1f92517e8edb52eba6cbb0a55cfeea7ca6583
generateSync
private static byte[] generateSync()
{    try {        MessageDigest digester = MessageDigest.getInstance("MD5");        long time = System.currentTimeMillis();        digester.update((UUID.randomUUID() + "@" + time).getBytes(UTF_8));        return digester.digest();    } catch (NoSuchAlgorithmException e) {        throw new RuntimeException(e);    }}
69a7af48eb05bc463a12f07470cbe937e068e60db9793541204c20fc5528ba65
testInvalidSync
public void testInvalidSync() throws IOException
{        byte[] sync = new byte[8];    createDataFile(sync);}
4508041c0650a510fcb43cf963d3088f8a18c98abb769a231d9d21173c24e79d
testRandomSync
public void testRandomSync() throws IOException
{    byte[] sync = generateSync();    byte[] randSyncFile = createDataFile(null);    byte[] customSyncFile = createDataFile(sync);    assertFalse(Arrays.equals(randSyncFile, customSyncFile));}
c6149910c16ceaaf8421c58cd13741e6a16d0f2d04a45277f0121c292b430e90
testCustomSync
public void testCustomSync() throws IOException
{    byte[] sync = generateSync();    byte[] customSyncFile = createDataFile(sync);    byte[] sameCustomSyncFile = createDataFile(sync);    assertTrue(Arrays.equals(customSyncFile, sameCustomSyncFile));}
956af36ec6e9e50e56d4ddbd503c78066dd904898b1d682376ab58c853c8c29f
testWriteAndRead
public void testWriteAndRead() throws IOException
{    Schema schema = Schema.create(Type.STRING);        DataFileWriter<Utf8> w = new DataFileWriter<>(new GenericDatumWriter<>(schema));    w.setCodec(CodecFactory.deflateCodec(6));    ByteArrayOutputStream baos = new ByteArrayOutputStream();    w.create(schema, baos);    w.append(new Utf8("hello world"));    w.append(new Utf8("hello moon"));    w.sync();    w.append(new Utf8("bye bye world"));    w.append(new Utf8("bye bye moon"));    w.close();        DataFileStream<Utf8> r = new DataFileStream<>(new ByteArrayInputStream(baos.toByteArray()), new GenericDatumReader<>(schema));    assertEquals("hello world", r.next().toString());    assertEquals("hello moon", r.next().toString());    assertEquals("bye bye world", r.next().toString());    assertEquals("bye bye moon", r.next().toString());    assertFalse(r.hasNext());}
e47b185a686c84cbc00559436314da05c137504460bc64b53e715817b525fb7f
testUseReservedMeta
public void testUseReservedMeta()
{    DataFileWriter<?> w = new DataFileWriter<>(new GenericDatumWriter<>());    w.setMeta("avro.foo", "bar");}
23caf17cb25eb3e4a2a6cce31267658a9aa4e6dba47763fd98fd066924a369a6
testUseMeta
public void testUseMeta() throws IOException
{    DataFileWriter<?> w = new DataFileWriter<>(new GenericDatumWriter<>());    File f = new File(DIR.getRoot().getPath(), "testDataFileMeta.avro");    w.setMeta("hello", "bar");    w.create(Schema.create(Type.NULL), f);    w.close();    DataFileStream<Void> r = new DataFileStream<>(new FileInputStream(f), new GenericDatumReader<>());    assertTrue(r.getMetaKeys().contains("hello"));    assertEquals("bar", r.getMetaString("hello"));}
23cd1ccec60242c371056325b37f7bb81b0dbc400cef76bd242b9babdd153bad
testUseMetaAfterCreate
public void testUseMetaAfterCreate() throws IOException
{    DataFileWriter<?> w = new DataFileWriter<>(new GenericDatumWriter<>());    w.create(Schema.create(Type.NULL), new ByteArrayOutputStream());    w.setMeta("foo", "bar");}
2e7e586ddfeee8bc21ac2a910a31dc593d1e7cb510d9ca91ba10f4b163e095e5
testBlockSizeSetInvalid
public void testBlockSizeSetInvalid()
{    int exceptions = 0;    for (int i = -1; i < 33; i++) {                try {            new DataFileWriter<>(new GenericDatumWriter<>()).setSyncInterval(i);        } catch (IllegalArgumentException iae) {            exceptions++;        }    }    assertEquals(33, exceptions);}
cdcb0c67109c3855677df55f341b7ce2437f33c59a0e69c682abb9fe0ff30d78
testForLeakingFileDescriptors
public void testForLeakingFileDescriptors() throws IOException
{    Path emptyFile = Files.createTempFile("empty", ".avro");    Files.deleteIfExists(emptyFile);    Files.createFile(emptyFile);    long openFilesBeforeOperation = getNumberOfOpenFileDescriptors();    try (DataFileReader<Object> reader = new DataFileReader<>(emptyFile.toFile(), new GenericDatumReader<>())) {        fail("Reading on empty file is supposed to fail.");    } catch (IOException e) {        }    Files.delete(emptyFile);    long openFilesAfterOperation = getNumberOfOpenFileDescriptors();        assertTrue("File descriptor leaked from new DataFileReader() (expected:" + openFilesBeforeOperation + " actual:" + openFilesAfterOperation + ")", openFilesBeforeOperation >= openFilesAfterOperation);}
c7035375694cb7d67f99ec6739ff090b1d7b5bc1ab823f963bd49398b0477c26
getNumberOfOpenFileDescriptors
private long getNumberOfOpenFileDescriptors()
{    OperatingSystemMXBean osMxBean = ManagementFactory.getOperatingSystemMXBean();    if (osMxBean instanceof UnixOperatingSystemMXBean) {        return ((UnixOperatingSystemMXBean) osMxBean).getOpenFileDescriptorCount();    }    return 0;}
3ce1e39fc24050563f847e096f93abbae67fb4438d87607c75b05f4fa4822795
testMultiReflectWithUnionBeforeWriting
public void testMultiReflectWithUnionBeforeWriting() throws IOException
{    File file = new File(DIR.getRoot().getPath(), "testMultiReflectWithUnionBeforeWriting.avro");    CheckList<Object> check = new CheckList<>();    try (FileOutputStream fos = new FileOutputStream(file)) {        ReflectData reflectData = ReflectData.get();        List<Schema> schemas = Arrays.asList(reflectData.getSchema(FooRecord.class), reflectData.getSchema(BarRecord.class));        Schema union = Schema.createUnion(schemas);        try (DataFileWriter<Object> writer = new DataFileWriter<>(new ReflectDatumWriter<>(union))) {            writer.create(union, fos);                        write(writer, new BarRecord("One beer please"), check);            write(writer, new FooRecord(10), check);            write(writer, new BarRecord("Two beers please"), check);            write(writer, new FooRecord(20), check);        }    }        ReflectDatumReader<Object> din = new ReflectDatumReader<>();    SeekableFileInput sin = new SeekableFileInput(file);    try (DataFileReader<Object> reader = new DataFileReader<>(sin, din)) {        int count = 0;        for (Object datum : reader) {            check.assertEquals(datum, count++);        }        Assert.assertEquals(count, check.size());    }}
bb3bb3570e77d63f00373dcec894fadff119015978ceac2d568889c679a5e157
testNull
public void testNull() throws IOException
{    File file = new File(DIR.getRoot().getPath(), "testNull.avro");    CheckList<BarRecord> check = new CheckList<>();    try (FileOutputStream fos = new FileOutputStream(file)) {        ReflectData reflectData = ReflectData.AllowNull.get();        Schema schema = reflectData.getSchema(BarRecord.class);        try (DataFileWriter<BarRecord> writer = new DataFileWriter<>(new ReflectDatumWriter<>(BarRecord.class, reflectData))) {            writer.create(schema, fos);                        write(writer, new BarRecord("One beer please"), check);                        write(writer, new BarRecord(), check);            write(writer, new BarRecord("Two beers please"), check);        }    }    ReflectDatumReader<BarRecord> din = new ReflectDatumReader<>();    try (SeekableFileInput sin = new SeekableFileInput(file)) {        try (DataFileReader<BarRecord> reader = new DataFileReader<>(sin, din)) {            int count = 0;            for (BarRecord datum : reader) {                check.assertEquals(datum, count++);            }            Assert.assertEquals(count, check.size());        }    }}
0b5e9dcb60d3035bd7b42f5f0def17565fb7c0a5a366bee63ebef8694831c3c6
testNew
public void testNew() throws IOException
{    ByteBuffer payload = ByteBuffer.allocateDirect(8 * 1024);    for (int i = 0; i < 500; i++) {        payload.putInt(1);    }    payload.flip();    ByteBufferRecord bbr = new ByteBufferRecord();    bbr.setPayload(payload);    bbr.setTp(TypeEnum.b);    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();    ReflectDatumWriter<ByteBufferRecord> writer = new ReflectDatumWriter<>(ByteBufferRecord.class);    BinaryEncoder avroEncoder = EncoderFactory.get().blockingBinaryEncoder(outputStream, null);    writer.write(bbr, avroEncoder);    avroEncoder.flush();    byte[] bytes = outputStream.toByteArray();    ByteArrayInputStream inputStream = new ByteArrayInputStream(bytes);    ReflectDatumReader<ByteBufferRecord> datumReader = new ReflectDatumReader<>(ByteBufferRecord.class);    BinaryDecoder avroDecoder = DecoderFactory.get().binaryDecoder(inputStream, null);    ByteBufferRecord deserialized = datumReader.read(null, avroDecoder);    Assert.assertEquals(bbr, deserialized);}
af923efdaf9cdbf6270e199c30865510c0651dade6f2507cb85d4f6ecf8a10fb
testNestedClass
public void testNestedClass() throws IOException
{    File file = new File(DIR.getRoot().getPath(), "testNull.avro");    CheckList<BazRecord> check = new CheckList<>();    try (FileOutputStream fos = new FileOutputStream(file)) {        Schema schema = ReflectData.get().getSchema(BazRecord.class);        try (DataFileWriter<BazRecord> writer = new DataFileWriter<>(new ReflectDatumWriter<>(schema))) {            writer.create(schema, fos);                        write(writer, new BazRecord(10), check);            write(writer, new BazRecord(20), check);        }    }    ReflectDatumReader<BazRecord> din = new ReflectDatumReader<>();    try (SeekableFileInput sin = new SeekableFileInput(file)) {        try (DataFileReader<BazRecord> reader = new DataFileReader<>(sin, din)) {            int count = 0;            for (BazRecord datum : reader) {                check.assertEquals(datum, count++);            }            Assert.assertEquals(count, check.size());        }    }}
81c9074dd41841980f16d107cbc4492c03cacc98a110840aa03708e75345f43a
write
private void write(DataFileWriter<T> writer, T o, CheckList<T> l) throws IOException
{    writer.append(l.addAndReturn(o));}
5f94c66ee8c080fc408b23cfd7655c352e9863db83d3781179ec1c52de2f5345
addAndReturn
 T addAndReturn(T check)
{    add(check);    return check;}
f2a32a2e729aff1f84cbb4a8dc9f76fa9bdeda5cebc5a2f727126e768aaad731
assertEquals
 void assertEquals(Object toCheck, int i)
{    Assert.assertNotNull(toCheck);    Object o = get(i);    Assert.assertNotNull(o);    Assert.assertEquals(toCheck, o);}
6b3ab298cb5d88dbb2c510c786f53e377489a40e2716e63c26a3e1691765f6c5
equals
public boolean equals(Object that)
{    if (that instanceof BazRecord) {        return this.nbr == ((BazRecord) that).nbr;    }    return false;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return nbr;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return BazRecord.class.getSimpleName() + "{cnt=" + nbr + "}";}
386ca65a16494ccfd7c6311aad0b63ddbd20d6591d4d1c2711bfa94723ea76d2
testFixedDefaultValueDrop
public void testFixedDefaultValueDrop()
{    Schema md5 = SchemaBuilder.builder().fixed("MD5").size(16);    Schema frec = SchemaBuilder.builder().record("test").fields().name("hash").type(md5).withDefault(new byte[16]).endRecord();    Schema.Field field = frec.getField("hash");    Assert.assertNotNull(field.defaultVal());    Assert.assertArrayEquals(new byte[16], (byte[]) field.defaultVal());}
2bdae670607a8670a9f2dfd81d3aa3994924347fc747f1d8cd331b386783ebd8
testDecimalFromSchema
public void testDecimalFromSchema()
{    Schema schema = Schema.createFixed("aFixed", null, null, 4);    schema.addProp("logicalType", "decimal");    schema.addProp("precision", 9);    schema.addProp("scale", 2);    LogicalType logicalType = LogicalTypes.fromSchemaIgnoreInvalid(schema);    Assert.assertTrue("Should be a Decimal", logicalType instanceof LogicalTypes.Decimal);    LogicalTypes.Decimal decimal = (LogicalTypes.Decimal) logicalType;    Assert.assertEquals("Should have correct precision", 9, decimal.getPrecision());    Assert.assertEquals("Should have correct scale", 2, decimal.getScale());}
5556ec5b265004fc3f2d328dc1df7dc7e46358eb7bd7d993b8770f0a0b625a61
testInvalidLogicalTypeIgnored
public void testInvalidLogicalTypeIgnored()
{    final Schema schema = Schema.createFixed("aFixed", null, null, 2);    schema.addProp("logicalType", "decimal");    schema.addProp("precision", 9);    schema.addProp("scale", 2);    Assert.assertNull("Should ignore invalid logical type", LogicalTypes.fromSchemaIgnoreInvalid(schema));}
8785737672c6738595acab481f184df69c7a0f2a85df1352ffcbe319eb460bab
testDecimalWithNonByteArrayTypes
public void testDecimalWithNonByteArrayTypes()
{    final LogicalType decimal = LogicalTypes.decimal(5, 2);        Schema[] nonBytes = new Schema[] { Schema.createRecord("Record", null, null, false), Schema.createArray(Schema.create(Schema.Type.BYTES)), Schema.createMap(Schema.create(Schema.Type.BYTES)), Schema.createEnum("Enum", null, null, Arrays.asList("a", "b")), Schema.createUnion(Arrays.asList(Schema.create(Schema.Type.BYTES), Schema.createFixed("fixed", null, null, 4))), Schema.create(Schema.Type.BOOLEAN), Schema.create(Schema.Type.INT), Schema.create(Schema.Type.LONG), Schema.create(Schema.Type.FLOAT), Schema.create(Schema.Type.DOUBLE), Schema.create(Schema.Type.NULL), Schema.create(Schema.Type.STRING) };    for (final Schema schema : nonBytes) {        assertThrows("Should reject type: " + schema.getType(), IllegalArgumentException.class, "Logical type decimal must be backed by fixed or bytes", () -> {            decimal.addToSchema(schema);            return null;        });    }}
2f926a682bb128c3ade0cedefe9a7e01463b155aacf1f3ccc854fc27f00d1630
testUnknownFromJsonNode
public void testUnknownFromJsonNode()
{    Schema schema = Schema.create(Schema.Type.STRING);    schema.addProp("logicalType", "unknown");    schema.addProp("someProperty", 34);    LogicalType logicalType = LogicalTypes.fromSchemaIgnoreInvalid(schema);    Assert.assertNull("Should not return a LogicalType instance", logicalType);}
b5e312246e5ae04af5e2f5e0fe60b1d3421b04f2da90f80b4f4a5669242a5753
testDecimalBytesHasNoPrecisionLimit
public void testDecimalBytesHasNoPrecisionLimit()
{    Schema schema = Schema.create(Schema.Type.BYTES);        LogicalTypes.decimal(Integer.MAX_VALUE).addToSchema(schema);    Assert.assertEquals("Precision should be an Integer.MAX_VALUE", Integer.MAX_VALUE, ((LogicalTypes.Decimal) LogicalTypes.fromSchemaIgnoreInvalid(schema)).getPrecision());}
a6befc1b59d49423c7bce242d3573b3b17384f8299503dbaf774d3d1679b5550
testDecimalFixedPrecisionLimit
public void testDecimalFixedPrecisionLimit()
{        final Schema schema = Schema.createFixed("aDecimal", null, null, 4);    assertThrows("Should reject precision", IllegalArgumentException.class, "fixed(4) cannot store 10 digits (max 9)", () -> {        LogicalTypes.decimal(10).addToSchema(schema);        return null;    });    Assert.assertNull("Invalid logical type should not be set on schema", LogicalTypes.fromSchemaIgnoreInvalid(schema));}
b36c6f14274d555294adf1bcbff1d463790459963861b694f496368bbf5f7d7e
testDecimalFailsWithZeroPrecision
public void testDecimalFailsWithZeroPrecision()
{    final Schema schema = Schema.createFixed("aDecimal", null, null, 4);    assertThrows("Should reject precision", IllegalArgumentException.class, "Invalid decimal precision: 0 (must be positive)", () -> {        LogicalTypes.decimal(0).addToSchema(schema);        return null;    });    Assert.assertNull("Invalid logical type should not be set on schema", LogicalTypes.fromSchemaIgnoreInvalid(schema));}
81a7c67dddcc1e6066a61006d4606bff4feb7a5fef9732addf0cdce6bc0dd692
testDecimalFailsWithNegativePrecision
public void testDecimalFailsWithNegativePrecision()
{    final Schema schema = Schema.createFixed("aDecimal", null, null, 4);    assertThrows("Should reject precision", IllegalArgumentException.class, "Invalid decimal precision: -9 (must be positive)", () -> {        LogicalTypes.decimal(-9).addToSchema(schema);        return null;    });    Assert.assertNull("Invalid logical type should not be set on schema", LogicalTypes.fromSchemaIgnoreInvalid(schema));}
4c3eb8a4c2243a4847f86d4a85d70b2a60039f404f95e7925e136b9d5bbb29aa
testDecimalScaleBoundedByPrecision
public void testDecimalScaleBoundedByPrecision()
{    final Schema schema = Schema.createFixed("aDecimal", null, null, 4);    assertThrows("Should reject precision", IllegalArgumentException.class, "Invalid decimal scale: 10 (greater than precision: 9)", () -> {        LogicalTypes.decimal(9, 10).addToSchema(schema);        return null;    });    Assert.assertNull("Invalid logical type should not be set on schema", LogicalTypes.fromSchemaIgnoreInvalid(schema));}
28955f32badb444873dc09088c40de3767abe637bb6da2ec9f9d8160777ec176
testDecimalFailsWithNegativeScale
public void testDecimalFailsWithNegativeScale()
{    final Schema schema = Schema.createFixed("aDecimal", null, null, 4);    assertThrows("Should reject precision", IllegalArgumentException.class, "Invalid decimal scale: -2 (must be positive)", () -> {        LogicalTypes.decimal(9, -2).addToSchema(schema);        return null;    });    Assert.assertNull("Invalid logical type should not be set on schema", LogicalTypes.fromSchemaIgnoreInvalid(schema));}
66916eab9057411dc1985f00ade76726b4cc5bdedde8a26bd472da6aaee94c50
testSchemaRejectsSecondLogicalType
public void testSchemaRejectsSecondLogicalType()
{    final Schema schema = Schema.createFixed("aDecimal", null, null, 4);    LogicalTypes.decimal(9).addToSchema(schema);    assertThrows("Should reject second logical type", AvroRuntimeException.class, "Can't overwrite property: scale", () -> {        LogicalTypes.decimal(9, 2).addToSchema(schema);        return null;    });    Assert.assertEquals("First logical type should still be set on schema", LogicalTypes.decimal(9), LogicalTypes.fromSchemaIgnoreInvalid(schema));}
d14bcb9542b7e86ece6f25a344a701f9924088e849dda18aaca39373cdb9f104
testDecimalDefaultScale
public void testDecimalDefaultScale()
{    Schema schema = Schema.createFixed("aDecimal", null, null, 4);        LogicalTypes.decimal(9).addToSchema(schema);    Assert.assertEquals("Scale should be a 0", 0, ((LogicalTypes.Decimal) LogicalTypes.fromSchemaIgnoreInvalid(schema)).getScale());}
e8672ab6b26a67cd6982daa31d69132eb93d2a3dcb8578dfe2aa58f41e34298e
testFixedDecimalToFromJson
public void testFixedDecimalToFromJson()
{    Schema schema = Schema.createFixed("aDecimal", null, null, 4);    LogicalTypes.decimal(9, 2).addToSchema(schema);    Schema parsed = new Schema.Parser().parse(schema.toString(true));    Assert.assertEquals("Constructed and parsed schemas should match", schema, parsed);}
77fe0d0e0dc7414ee543eacb5a05757d5fecefd9558fc0b33493fbcecaa8beda
testBytesDecimalToFromJson
public void testBytesDecimalToFromJson()
{    Schema schema = Schema.create(Schema.Type.BYTES);    LogicalTypes.decimal(9, 2).addToSchema(schema);    Schema parsed = new Schema.Parser().parse(schema.toString(true));    Assert.assertEquals("Constructed and parsed schemas should match", schema, parsed);}
c7b1da3fa164c68546421e53000053a7ee2b14b66523406583cc39f54b35b37f
testLogicalTypeEquals
public void testLogicalTypeEquals()
{    LogicalTypes.Decimal decimal90 = LogicalTypes.decimal(9);    LogicalTypes.Decimal decimal80 = LogicalTypes.decimal(8);    LogicalTypes.Decimal decimal92 = LogicalTypes.decimal(9, 2);    assertEqualsTrue("Same decimal", LogicalTypes.decimal(9, 0), decimal90);    assertEqualsTrue("Same decimal", LogicalTypes.decimal(8, 0), decimal80);    assertEqualsTrue("Same decimal", LogicalTypes.decimal(9, 2), decimal92);    assertEqualsFalse("Different logical type", LogicalTypes.uuid(), decimal90);    assertEqualsFalse("Different precision", decimal90, decimal80);    assertEqualsFalse("Different scale", decimal90, decimal92);}
8de007d5fb1cc96da1e8a3431601b493dbe3a1788f5b17bfc86d2cc025fc0adc
testLogicalTypeInSchemaEquals
public void testLogicalTypeInSchemaEquals()
{    Schema schema1 = Schema.createFixed("aDecimal", null, null, 4);    Schema schema2 = Schema.createFixed("aDecimal", null, null, 4);    Schema schema3 = Schema.createFixed("aDecimal", null, null, 4);    Assert.assertNotSame(schema1, schema2);    Assert.assertNotSame(schema1, schema3);    assertEqualsTrue("No logical types", schema1, schema2);    assertEqualsTrue("No logical types", schema1, schema3);    LogicalTypes.decimal(9).addToSchema(schema1);    assertEqualsFalse("Two has no logical type", schema1, schema2);    LogicalTypes.decimal(9).addToSchema(schema2);    assertEqualsTrue("Same logical types", schema1, schema2);    LogicalTypes.decimal(9, 2).addToSchema(schema3);    assertEqualsFalse("Different logical type", schema1, schema3);}
9469e33ebd0254451e2d0b0e7153f88a7164ee7e01172b24886a84e2f2cf0c14
assertEqualsTrue
public static void assertEqualsTrue(String message, Object o1, Object o2)
{    Assert.assertTrue("Should be equal (forward): " + message, o1.equals(o2));    Assert.assertTrue("Should be equal (reverse): " + message, o2.equals(o1));}
8db0409f34908c7ae58a456f29041f7ddc01e1ec895f76267d9b6b286106aa56
assertEqualsFalse
public static void assertEqualsFalse(String message, Object o1, Object o2)
{    Assert.assertFalse("Should be equal (forward): " + message, o1.equals(o2));    Assert.assertFalse("Should be equal (reverse): " + message, o2.equals(o1));}
031b5b5484c6c86db8fe574cb57229721f101a5089f897cbfb0fec2b8595c4b7
assertThrows
public static void assertThrows(String message, Class<? extends Exception> expected, String containedInMessage, Callable callable)
{    try {        callable.call();        Assert.fail("No exception was thrown (" + message + "), expected: " + expected.getName());    } catch (Exception actual) {        Assert.assertEquals(message, expected, actual.getClass());        Assert.assertTrue("Expected exception message (" + containedInMessage + ") missing: " + actual.getMessage(), actual.getMessage().contains(containedInMessage));    }}
c1ad4ea790defe1de1a909db22098318b64a4094c419244d388e9b0246191d73
testSingleSubRecord
public void testSingleSubRecord() throws IOException
{    final Schema child = SchemaBuilder.record("Child").namespace("org.apache.avro.nested").fields().requiredString("childField").endRecord();    final Schema parent = SchemaBuilder.record("Parent").namespace("org.apache.avro.nested").fields().requiredString("parentField1").name("child1").type(child).noDefault().requiredString("parentField2").endRecord();    final String inputAsExpected = "{\n" + " \"parentField1\": \"parentValue1\",\n" + " \"child1\":{\n" + "    \"childField\":\"childValue1\"\n" + " },\n" + " \"parentField2\":\"parentValue2\"\n" + "}";    final ByteArrayInputStream inputStream = new ByteArrayInputStream(inputAsExpected.getBytes(UTF_8));    final JsonDecoder decoder = DecoderFactory.get().jsonDecoder(parent, inputStream);    final DatumReader<Object> reader = new GenericDatumReader<>(parent);    final GenericData.Record decoded = (GenericData.Record) reader.read(null, decoder);    assertThat(decoded.get("parentField1").toString(), equalTo("parentValue1"));    assertThat(decoded.get("parentField2").toString(), equalTo("parentValue2"));    assertThat(((GenericData.Record) decoded.get("child1")).get("childField").toString(), equalTo("childValue1"));}
f4f4d478bb24539d14414dc1b409fe47885a26cbfa93d510ae4b7e0ac921e0db
testSingleSubRecordExtraField
public void testSingleSubRecordExtraField() throws IOException
{    final Schema child = SchemaBuilder.record("Child").namespace("org.apache.avro.nested").fields().requiredString("childField").endRecord();    final Schema parent = SchemaBuilder.record("Parent").namespace("org.apache.avro.nested").fields().requiredString("parentField1").name("child1").type(child).noDefault().requiredString("parentField2").endRecord();    final String inputAsExpected = "{\n" + " \"parentField1\": \"parentValue1\",\n" + " \"child1\":{\n" + "    \"childField\":\"childValue1\",\n" +     "    \"extraField\":\"extraValue\"\n" + " },\n" + " \"parentField2\":\"parentValue2\"\n" + "}";    final ByteArrayInputStream inputStream = new ByteArrayInputStream(inputAsExpected.getBytes(UTF_8));    final JsonDecoder decoder = DecoderFactory.get().jsonDecoder(parent, inputStream);    final DatumReader<Object> reader = new GenericDatumReader<>(parent);    final GenericData.Record decoded = (GenericData.Record) reader.read(null, decoder);    assertThat(decoded.get("parentField1").toString(), equalTo("parentValue1"));    assertThat(decoded.get("parentField2").toString(), equalTo("parentValue2"));    assertThat(((GenericData.Record) decoded.get("child1")).get("childField").toString(), equalTo("childValue1"));}
ed2f3801de512f76f0ba64d4024ae2e8981c4af7e6b256bb1528fe0be98642a5
testPropEquals
public void testPropEquals()
{    Protocol p1 = new Protocol("P", null, "foo");    p1.addProp("a", "1");    Protocol p2 = new Protocol("P", null, "foo");    p2.addProp("a", "2");    assertFalse(p1.equals(p2));}
513ae29edcca2f34a2324acb9d408fa75a6d392b35367c446d19e20a6a12aa4c
testSplitProtocolBuild
public void testSplitProtocolBuild()
{    Protocol p = new Protocol("P", null, "foo");    p.addProp("property", "some value");    String protocolString = p.toString();    final int mid = protocolString.length() / 2;    String[] parts = { protocolString.substring(0, mid), protocolString.substring(mid) };    Protocol parsedStringProtocol = org.apache.avro.Protocol.parse(protocolString);    Protocol parsedArrayOfStringProtocol = org.apache.avro.Protocol.parse(protocolString.substring(0, mid), protocolString.substring(mid));    assertNotNull(parsedStringProtocol);    assertNotNull(parsedArrayOfStringProtocol);    assertEquals(parsedStringProtocol.toString(), parsedArrayOfStringProtocol.toString());}
e159cd20e5d846e508be922f0450be0db638ed2ba32c3229ae07c0ea68938d77
data
public static Collection<Object[]> data()
{    return Arrays.asList(new EncoderType[][] { { EncoderType.BINARY }, { EncoderType.JSON } });}
baeff785a6d1ffa6365bc80bc8fa1fc228d17cd672bf1404c1bd9324b3b60c5b
doubleWrittenWithUnionSchemaIsConvertedToDoubleSchema
public void doubleWrittenWithUnionSchemaIsConvertedToDoubleSchema() throws Exception
{    Schema writer = UNION_INT_LONG_FLOAT_DOUBLE_RECORD;    Record record = defaultRecordWithSchema(writer, FIELD_A, 42.0);    byte[] encoded = encodeGenericBlob(record);    Record decoded = decodeGenericBlob(DOUBLE_RECORD, writer, encoded);    assertEquals(42.0, decoded.get(FIELD_A));}
05e656746d78e0c9c151e0c00523d8f2f4e37e42a2f85b5636f1cc917c630bf5
longWrittenWithUnionSchemaIsConvertedToUnionLongFloatSchema
public void longWrittenWithUnionSchemaIsConvertedToUnionLongFloatSchema() throws Exception
{    Schema writer = UNION_LONG_RECORD;    Record record = defaultRecordWithSchema(writer, FIELD_A, 42L);    byte[] encoded = encodeGenericBlob(record);    Record decoded = decodeGenericBlob(UNION_LONG_FLOAT_RECORD, writer, encoded);    assertEquals(42L, decoded.get(FIELD_A));}
02b104afebafa2736bd1bbe4b501dfc11aacfd183d3f473fc203ef51ed306c9a
longWrittenWithUnionSchemaIsConvertedToDoubleSchema
public void longWrittenWithUnionSchemaIsConvertedToDoubleSchema() throws Exception
{    Schema writer = UNION_LONG_RECORD;    Record record = defaultRecordWithSchema(writer, FIELD_A, 42L);    byte[] encoded = encodeGenericBlob(record);    Record decoded = decodeGenericBlob(UNION_DOUBLE_RECORD, writer, encoded);    assertEquals(42.0, decoded.get(FIELD_A));}
5daecdee10b06d6789de6f4a2edb4d2ad3833db08bf11092e6dca249ce29e777
intWrittenWithUnionSchemaIsConvertedToDoubleSchema
public void intWrittenWithUnionSchemaIsConvertedToDoubleSchema() throws Exception
{    Schema writer = UNION_INT_RECORD;    Record record = defaultRecordWithSchema(writer, FIELD_A, 42);    byte[] encoded = encodeGenericBlob(record);    Record decoded = decodeGenericBlob(UNION_DOUBLE_RECORD, writer, encoded);    assertEquals(42.0, decoded.get(FIELD_A));}
3ea35bdbf51f8239ea9dfa2193cde8cb82ad444f1020d00d6932fd94fdf71f68
intWrittenWithUnionSchemaIsReadableByFloatSchema
public void intWrittenWithUnionSchemaIsReadableByFloatSchema() throws Exception
{    Schema writer = UNION_INT_RECORD;    Record record = defaultRecordWithSchema(writer, FIELD_A, 42);    byte[] encoded = encodeGenericBlob(record);    Record decoded = decodeGenericBlob(FLOAT_RECORD, writer, encoded);    assertEquals(42.0f, decoded.get(FIELD_A));}
573dfc8a608cb97515c71decaee40bee506e27cca072379fefc1f31d5af06a42
intWrittenWithUnionSchemaIsReadableByFloatUnionSchema
public void intWrittenWithUnionSchemaIsReadableByFloatUnionSchema() throws Exception
{    Schema writer = UNION_INT_RECORD;    Record record = defaultRecordWithSchema(writer, FIELD_A, 42);    byte[] encoded = encodeGenericBlob(record);    Record decoded = decodeGenericBlob(UNION_FLOAT_RECORD, writer, encoded);    assertEquals(42.0f, decoded.get(FIELD_A));}
e334e6044c60d2ca720db5b3f5c6952610fcb2490f8ed51b53c2b2a11f282264
longWrittenWithUnionSchemaIsReadableByFloatSchema
public void longWrittenWithUnionSchemaIsReadableByFloatSchema() throws Exception
{    Schema writer = UNION_LONG_RECORD;    Record record = defaultRecordWithSchema(writer, FIELD_A, 42L);    byte[] encoded = encodeGenericBlob(record);    Record decoded = decodeGenericBlob(FLOAT_RECORD, writer, encoded);    assertEquals(42.0f, decoded.get(FIELD_A));}
04f7fc686d1e05db0ff2e07054d4c475af8d93ddb6b37dd983f46220ac5df153
longWrittenWithUnionSchemaIsReadableByFloatUnionSchema
public void longWrittenWithUnionSchemaIsReadableByFloatUnionSchema() throws Exception
{    Schema writer = UNION_LONG_RECORD;    Record record = defaultRecordWithSchema(writer, FIELD_A, 42L);    byte[] encoded = encodeGenericBlob(record);    Record decoded = decodeGenericBlob(UNION_FLOAT_RECORD, writer, encoded);    assertEquals(42.0f, decoded.get(FIELD_A));}
9554665965b4d0b998beec13a00d2a1f823a3b4050428e446eb04367915fe11f
longWrittenWithUnionSchemaIsConvertedToLongFloatUnionSchema
public void longWrittenWithUnionSchemaIsConvertedToLongFloatUnionSchema() throws Exception
{    Schema writer = UNION_LONG_RECORD;    Record record = defaultRecordWithSchema(writer, FIELD_A, 42L);    byte[] encoded = encodeGenericBlob(record);    Record decoded = decodeGenericBlob(UNION_LONG_FLOAT_RECORD, writer, encoded);    assertEquals(42L, decoded.get(FIELD_A));}
780237a28fb223e0bdf22384ef7fd553909db36e566e9bb846ac6fb624e5f046
longWrittenWithUnionSchemaIsConvertedToFloatDoubleUnionSchema
public void longWrittenWithUnionSchemaIsConvertedToFloatDoubleUnionSchema() throws Exception
{    Schema writer = UNION_LONG_RECORD;    Record record = defaultRecordWithSchema(writer, FIELD_A, 42L);    byte[] encoded = encodeGenericBlob(record);    Record decoded = decodeGenericBlob(UNION_FLOAT_DOUBLE_RECORD, writer, encoded);    assertEquals(42.0F, decoded.get(FIELD_A));}
8d2ff917b1aa79a306003f8479ba44b333149d4786a67801b2311a9f24e5623d
doubleWrittenWithUnionSchemaIsNotConvertedToFloatSchema
public void doubleWrittenWithUnionSchemaIsNotConvertedToFloatSchema() throws Exception
{    expectedException.expect(AvroTypeException.class);    expectedException.expectMessage("Found double, expecting float");    Schema writer = UNION_INT_LONG_FLOAT_DOUBLE_RECORD;    Record record = defaultRecordWithSchema(writer, FIELD_A, 42.0);    byte[] encoded = encodeGenericBlob(record);    decodeGenericBlob(FLOAT_RECORD, writer, encoded);}
572513058872798fea16530bac4ceee1af576047dd2d8d52c7ea06642e383f00
floatWrittenWithUnionSchemaIsNotConvertedToLongSchema
public void floatWrittenWithUnionSchemaIsNotConvertedToLongSchema() throws Exception
{    expectedException.expect(AvroTypeException.class);    expectedException.expectMessage("Found float, expecting long");    Schema writer = UNION_INT_LONG_FLOAT_DOUBLE_RECORD;    Record record = defaultRecordWithSchema(writer, FIELD_A, 42.0f);    byte[] encoded = encodeGenericBlob(record);    decodeGenericBlob(LONG_RECORD, writer, encoded);}
ba043c569b728a97feee069ea4ac7c3b374de4bb60bdf0296050a17afe6134f4
longWrittenWithUnionSchemaIsNotConvertedToIntSchema
public void longWrittenWithUnionSchemaIsNotConvertedToIntSchema() throws Exception
{    expectedException.expect(AvroTypeException.class);    expectedException.expectMessage("Found long, expecting int");    Schema writer = UNION_INT_LONG_FLOAT_DOUBLE_RECORD;    Record record = defaultRecordWithSchema(writer, FIELD_A, 42L);    byte[] encoded = encodeGenericBlob(record);    decodeGenericBlob(INT_RECORD, writer, encoded);}
edfed9581fb6f4ac19dbfb6362ffa2b3a8f78bd30fdd533729a8dad544a550fd
intWrittenWithUnionSchemaIsConvertedToAllNumberSchemas
public void intWrittenWithUnionSchemaIsConvertedToAllNumberSchemas() throws Exception
{    Schema writer = UNION_INT_LONG_FLOAT_DOUBLE_RECORD;    Record record = defaultRecordWithSchema(writer, FIELD_A, 42);    byte[] encoded = encodeGenericBlob(record);    assertEquals(42.0, decodeGenericBlob(DOUBLE_RECORD, writer, encoded).get(FIELD_A));    assertEquals(42.0f, decodeGenericBlob(FLOAT_RECORD, writer, encoded).get(FIELD_A));    assertEquals(42L, decodeGenericBlob(LONG_RECORD, writer, encoded).get(FIELD_A));    assertEquals(42, decodeGenericBlob(INT_RECORD, writer, encoded).get(FIELD_A));}
89795abae0cd4918156f7bd1697c3e5a43a703a92d54e8cc3f549e6f7cf70090
asciiStringWrittenWithUnionSchemaIsConvertedToBytesSchema
public void asciiStringWrittenWithUnionSchemaIsConvertedToBytesSchema() throws Exception
{    Schema writer = UNION_STRING_BYTES_RECORD;    Record record = defaultRecordWithSchema(writer, FIELD_A, "42");    byte[] encoded = encodeGenericBlob(record);    ByteBuffer actual = (ByteBuffer) decodeGenericBlob(BYTES_RECORD, writer, encoded).get(FIELD_A);    assertArrayEquals("42".getBytes(StandardCharsets.UTF_8), actual.array());}
012483c024c3fa9ce31fcfebbb06b8bd0d9a96e83c2e9c5477528dc50ebcba03
utf8StringWrittenWithUnionSchemaIsConvertedToBytesSchema
public void utf8StringWrittenWithUnionSchemaIsConvertedToBytesSchema() throws Exception
{    String goeran = String.format("G%sran", LATIN_SMALL_LETTER_O_WITH_DIARESIS);    Schema writer = UNION_STRING_BYTES_RECORD;    Record record = defaultRecordWithSchema(writer, FIELD_A, goeran);    byte[] encoded = encodeGenericBlob(record);    ByteBuffer actual = (ByteBuffer) decodeGenericBlob(BYTES_RECORD, writer, encoded).get(FIELD_A);    assertArrayEquals(goeran.getBytes(StandardCharsets.UTF_8), actual.array());}
1a55d98a4e496a93545734a648105bca75c295cc52e59458bc3cb8b3ac1f6993
asciiBytesWrittenWithUnionSchemaIsConvertedToStringSchema
public void asciiBytesWrittenWithUnionSchemaIsConvertedToStringSchema() throws Exception
{    Schema writer = UNION_STRING_BYTES_RECORD;    ByteBuffer buf = ByteBuffer.wrap("42".getBytes(StandardCharsets.UTF_8));    Record record = defaultRecordWithSchema(writer, FIELD_A, buf);    byte[] encoded = encodeGenericBlob(record);    CharSequence read = (CharSequence) decodeGenericBlob(STRING_RECORD, writer, encoded).get(FIELD_A);    assertEquals("42", read.toString());}
22f5c9d1d69f6b4c2d74a41ac130459c01bf47fed824c10e583f5c0b003377ce
utf8BytesWrittenWithUnionSchemaIsConvertedToStringSchema
public void utf8BytesWrittenWithUnionSchemaIsConvertedToStringSchema() throws Exception
{    String goeran = String.format("G%sran", LATIN_SMALL_LETTER_O_WITH_DIARESIS);    Schema writer = UNION_STRING_BYTES_RECORD;    Record record = defaultRecordWithSchema(writer, FIELD_A, goeran);    byte[] encoded = encodeGenericBlob(record);    CharSequence read = (CharSequence) decodeGenericBlob(STRING_RECORD, writer, encoded).get(FIELD_A);    assertEquals(goeran, read.toString());}
fb4f527a3cfd855623e322410bbf1c5ce6bc0273f192008d16e182dc4523ad39
enumRecordCanBeReadWithExtendedEnumSchema
public void enumRecordCanBeReadWithExtendedEnumSchema() throws Exception
{    Schema writer = ENUM_AB_RECORD;    Record record = defaultRecordWithSchema(writer, FIELD_A, new EnumSymbol(writer, "A"));    byte[] encoded = encodeGenericBlob(record);    Record decoded = decodeGenericBlob(ENUM_ABC_RECORD, writer, encoded);    assertEquals("A", decoded.get(FIELD_A).toString());}
236c5e5663ffc9a2817b1119d546e4ae7d31779a3349803757d9b3eeb0083726
enumRecordWithExtendedSchemaCanBeReadWithOriginalEnumSchemaIfOnlyOldValues
public void enumRecordWithExtendedSchemaCanBeReadWithOriginalEnumSchemaIfOnlyOldValues() throws Exception
{    Schema writer = ENUM_ABC_RECORD;    Record record = defaultRecordWithSchema(writer, FIELD_A, new EnumSymbol(writer, "A"));    byte[] encoded = encodeGenericBlob(record);    Record decoded = decodeGenericBlob(ENUM_AB_RECORD, writer, encoded);    assertEquals("A", decoded.get(FIELD_A).toString());}
144fecd1e4c58845057f0dfc031579ceff483beaaa3e708bc03584eb289f9819
enumRecordWithExtendedSchemaCanNotBeReadIfNewValuesAreUsed
public void enumRecordWithExtendedSchemaCanNotBeReadIfNewValuesAreUsed() throws Exception
{    expectedException.expect(AvroTypeException.class);    expectedException.expectMessage("No match for C");    Schema writer = ENUM_ABC_RECORD;    Record record = defaultRecordWithSchema(writer, FIELD_A, new EnumSymbol(writer, "C"));    byte[] encoded = encodeGenericBlob(record);    decodeGenericBlob(ENUM_AB_RECORD, writer, encoded);}
7dbb405f67661cd2d5c1270517300cefccf9d29d8f9844b55fdcbb0d7b3c4ad0
recordWrittenWithExtendedSchemaCanBeReadWithOriginalSchemaButLossOfData
public void recordWrittenWithExtendedSchemaCanBeReadWithOriginalSchemaButLossOfData() throws Exception
{    Schema writer =     SchemaBuilder.record(RECORD_A).fields().name("newTopField").type().stringType().noDefault().name(FIELD_A).type().intType().noDefault().endRecord();    Record record = defaultRecordWithSchema(writer, FIELD_A, 42);    record.put("newTopField", "not decoded");    byte[] encoded = encodeGenericBlob(record);    Record decoded = decodeGenericBlob(INT_RECORD, writer, encoded);    assertEquals(42, decoded.get(FIELD_A));    assertNull(decoded.get("newTopField"));}
37ff9a923a5734a27a7c1574470a66ba187e4d4e4c82e8ba04b1ea31600ec169
readerWithoutDefaultValueThrowsException
public void readerWithoutDefaultValueThrowsException() throws Exception
{    expectedException.expect(AvroTypeException.class);    expectedException.expectMessage("missing required field newField");    Schema reader =     SchemaBuilder.record(RECORD_A).fields().name("newField").type().intType().noDefault().name(FIELD_A).type().intType().noDefault().endRecord();    Record record = defaultRecordWithSchema(INT_RECORD, FIELD_A, 42);    byte[] encoded = encodeGenericBlob(record);    decodeGenericBlob(reader, INT_RECORD, encoded);}
49b1c5a1f2a52e61e3459acbba32460c3c73c00be12563f91ba0b1a28551aaf7
readerWithDefaultValueIsApplied
public void readerWithDefaultValueIsApplied() throws Exception
{    Schema reader =     SchemaBuilder.record(RECORD_A).fields().name("newFieldWithDefault").type().intType().intDefault(    314).name(FIELD_A).type().intType().noDefault().endRecord();    Record record = defaultRecordWithSchema(INT_RECORD, FIELD_A, 42);    byte[] encoded = encodeGenericBlob(record);    Record decoded = decodeGenericBlob(reader, INT_RECORD, encoded);    assertEquals(42, decoded.get(FIELD_A));    assertEquals(314, decoded.get("newFieldWithDefault"));}
f99edfd52c7cf712f0be586a4e24d91c6d47f18597ab72a0b2125fde5495c64c
aliasesInSchema
public void aliasesInSchema() throws Exception
{    Schema writer = new Schema.Parser().parse("{\"namespace\": \"example.avro\", \"type\": \"record\", \"name\": \"User\", \"fields\": [" + "{\"name\": \"name\", \"type\": \"int\"}\n" + "]}\n");    Schema reader = new Schema.Parser().parse("{\"namespace\": \"example.avro\", \"type\": \"record\", \"name\": \"User\", \"fields\": [" + "{\"name\": \"fname\", \"type\": \"int\", \"aliases\" : [ \"name\" ]}\n" + "]}\n");    GenericData.Record record = defaultRecordWithSchema(writer, "name", 1);    byte[] encoded = encodeGenericBlob(record);    GenericData.Record decoded = decodeGenericBlob(reader, reader, encoded);    assertEquals(1, decoded.get("fname"));}
0ffde2d393e48e98a3c5dc6f5b59e0a3c10565106c1c732b26f60e03d28d9f0b
defaultRecordWithSchema
private Record defaultRecordWithSchema(Schema schema, String key, T value)
{    Record data = new GenericData.Record(schema);    data.put(key, value);    return data;}
f4eb21c53a13299729b5500bc6df1e95c8b8b2a3cd5d2ac201378443b57b4bf4
encodeGenericBlob
private byte[] encodeGenericBlob(GenericRecord data) throws IOException
{    DatumWriter<GenericRecord> writer = new GenericDatumWriter<>(data.getSchema());    ByteArrayOutputStream outStream = new ByteArrayOutputStream();    Encoder encoder = encoderType == EncoderType.BINARY ? EncoderFactory.get().binaryEncoder(outStream, null) : EncoderFactory.get().jsonEncoder(data.getSchema(), outStream);    writer.write(data, encoder);    encoder.flush();    outStream.close();    return outStream.toByteArray();}
d3509935774e19f75a9efa53fac22c06fd577dea80dca19fc1770506b2bdadfb
decodeGenericBlob
private Record decodeGenericBlob(Schema expectedSchema, Schema schemaOfBlob, byte[] blob) throws IOException
{    if (blob == null) {        return null;    }    GenericDatumReader<Record> reader = new GenericDatumReader<>();    reader.setExpected(expectedSchema);    reader.setSchema(schemaOfBlob);    Decoder decoder = encoderType == EncoderType.BINARY ? DecoderFactory.get().binaryDecoder(blob, null) : DecoderFactory.get().jsonDecoder(schemaOfBlob, new ByteArrayInputStream(blob));    return reader.read(null, decoder);}
132e4fd0859dcf7854a9fab62b3b0c6ae080155f8f9dc2c14a2da90eb909aa21
testSplitSchemaBuild
public void testSplitSchemaBuild()
{    Schema s = SchemaBuilder.record("HandshakeRequest").namespace("org.apache.avro.ipc").fields().name("clientProtocol").type().optional().stringType().name("meta").type().optional().map().values().bytesType().endRecord();    String schemaString = s.toString();    int mid = schemaString.length() / 2;    Schema parsedStringSchema = new org.apache.avro.Schema.Parser().parse(s.toString());    Schema parsedArrayOfStringSchema = new org.apache.avro.Schema.Parser().parse(schemaString.substring(0, mid), schemaString.substring(mid));    assertNotNull(parsedStringSchema);    assertNotNull(parsedArrayOfStringSchema);    assertEquals(parsedStringSchema.toString(), parsedArrayOfStringSchema.toString());}
abdb74bc007c8aa48fc5ca513e0480a6b779301dccd85b6ad05162f5626b7785
testDefaultRecordWithDuplicateFieldName
public void testDefaultRecordWithDuplicateFieldName()
{    String recordName = "name";    Schema schema = Schema.createRecord(recordName, "doc", "namespace", false);    List<Field> fields = new ArrayList<>();    fields.add(new Field("field_name", Schema.create(Type.NULL), null, null));    fields.add(new Field("field_name", Schema.create(Type.INT), null, null));    try {        schema.setFields(fields);        fail("Should not be able to create a record with duplicate field name.");    } catch (AvroRuntimeException are) {        assertTrue(are.getMessage().contains("Duplicate field field_name in record " + recordName));    }}
574287f28870af79bda982930fa2a056a4886bf7c0b6e4274b71c407b7276c0f
testCreateUnionVarargs
public void testCreateUnionVarargs()
{    List<Schema> types = new ArrayList<>();    types.add(Schema.create(Type.NULL));    types.add(Schema.create(Type.LONG));    Schema expected = Schema.createUnion(types);    Schema schema = Schema.createUnion(Schema.create(Type.NULL), Schema.create(Type.LONG));    assertEquals(expected, schema);}
0066c9abc8163cf8f6b4daaf6f946e080594063cd5ab1ca4ee9f0c9afae798d7
testRecordWithNullDoc
public void testRecordWithNullDoc()
{    Schema schema = Schema.createRecord("name", null, "namespace", false);    String schemaString = schema.toString();    assertNotNull(schemaString);}
b60aea73b477ba02c089f89ea48331b94ddaa14c8fda9db6d66fe0c0b532e710
testRecordWithNullNamespace
public void testRecordWithNullNamespace()
{    Schema schema = Schema.createRecord("name", "doc", null, false);    String schemaString = schema.toString();    assertNotNull(schemaString);}
4ab39f15cf71e7897e140ead3c08b746eabb08b47beda64c5791f0f7ec8fcd65
testEmptyRecordSchema
public void testEmptyRecordSchema()
{    Schema schema = createDefaultRecord();    String schemaString = schema.toString();    assertNotNull(schemaString);}
ac7a4d3de7d2464e9b3a5df5b0c2975c039f0604df69a5b1b5bdbb4eea125162
testParseEmptySchema
public void testParseEmptySchema()
{    Schema schema = new Schema.Parser().parse("");}
64cb56f2e2a3262c254043199faa90b7560f7d91080fcc469fdd7b7c0a891b26
testSchemaWithFields
public void testSchemaWithFields()
{    List<Field> fields = new ArrayList<>();    fields.add(new Field("field_name1", Schema.create(Type.NULL), null, null));    fields.add(new Field("field_name2", Schema.create(Type.INT), null, null));    Schema schema = createDefaultRecord();    schema.setFields(fields);    String schemaString = schema.toString();    assertNotNull(schemaString);    assertEquals(2, schema.getFields().size());}
2a570bed9ab2f6a5539fa3a15d6effa1640b09b4fe11dab3f1d18811f369695a
testSchemaWithNullFields
public void testSchemaWithNullFields()
{    Schema.createRecord("name", "doc", "namespace", false, null);}
2c00ae14d2649b990c2a35295463daf78da21146e415cf881f28ee7139789b5e
testIsUnionOnUnionWithMultipleElements
public void testIsUnionOnUnionWithMultipleElements()
{    Schema schema = Schema.createUnion(Schema.create(Type.NULL), Schema.create(Type.LONG));    assertTrue(schema.isUnion());}
a392abf0067f6d2ca8ee530c3a20a63d6d467361437e9ea01318693cd0ba3228
testIsUnionOnUnionWithOneElement
public void testIsUnionOnUnionWithOneElement()
{    Schema schema = Schema.createUnion(Schema.create(Type.LONG));    assertTrue(schema.isUnion());}
ef655c0eac47aedf3b91f731bacd53827ce7d21cf0fe43280d6ea343ae14095d
testIsUnionOnRecord
public void testIsUnionOnRecord()
{    Schema schema = createDefaultRecord();    assertFalse(schema.isUnion());}
a1b0facf98eec572676421c99ec5d722c50031f0637f56c2074d902f55ab48ef
testIsUnionOnArray
public void testIsUnionOnArray()
{    Schema schema = Schema.createArray(Schema.create(Type.LONG));    assertFalse(schema.isUnion());}
f0300e26ee39babefe2a9dcac9f9063da3343712eb89b83a70b09d8a5d69236a
testIsUnionOnEnum
public void testIsUnionOnEnum()
{    Schema schema = Schema.createEnum("name", "doc", "namespace", Collections.singletonList("value"));    assertFalse(schema.isUnion());}
7d41fde88ab8c117f6a7b21d9087fd1aecf1b25e5ce0561219610adaa155a45e
testIsUnionOnFixed
public void testIsUnionOnFixed()
{    Schema schema = Schema.createFixed("name", "doc", "space", 10);    assertFalse(schema.isUnion());}
78a3ad473e73eb25db4e4436f5b83a6b090215d26b2650ae3fab770dbfabc0a9
testIsUnionOnMap
public void testIsUnionOnMap()
{    Schema schema = Schema.createMap(Schema.create(Type.LONG));    assertFalse(schema.isUnion());}
0be671e97d872781b110a6305e92f89799c905766266589f1e5896948ebf45ac
testIsNullableOnUnionWithNull
public void testIsNullableOnUnionWithNull()
{    Schema schema = Schema.createUnion(Schema.create(Type.NULL), Schema.create(Type.LONG));    assertTrue(schema.isNullable());}
98c4b10706951ca5c1f8db3337f68409e7424960aba64e9899cfa94c0f5b5682
testIsNullableOnUnionWithoutNull
public void testIsNullableOnUnionWithoutNull()
{    Schema schema = Schema.createUnion(Schema.create(Type.LONG));    assertFalse(schema.isNullable());}
e02d791d1e145e8784245ef2578e3fa253e1c8b960e3b563487fd17a3197b491
testIsNullableOnRecord
public void testIsNullableOnRecord()
{    Schema schema = createDefaultRecord();    assertFalse(schema.isNullable());}
a94b989355521dfd0a8907e12830d61376fbc6b252be654efb497d78bc4bc581
createDefaultRecord
private Schema createDefaultRecord()
{    return Schema.createRecord("name", "doc", "namespace", false);}
10ab196950b2379e9f55224fddeceaeea574a2eccbf20c94daa6abea45c22fc4
testSerialization
public void testSerialization() throws IOException, ClassNotFoundException
{    try (ByteArrayOutputStream bos = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(bos);        InputStream jsonSchema = getClass().getResourceAsStream("/SchemaBuilder.avsc")) {        Schema payload = new Schema.Parser().parse(jsonSchema);        oos.writeObject(payload);        try (ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());            ObjectInputStream ois = new ObjectInputStream(bis)) {            Schema sp = (Schema) ois.readObject();            assertEquals(payload, sp);        }    }}
4786c67fdaf5cea157f21bcd4321d743bdeeda7318bddbbed72d6682fed6e375
testRecord
public void testRecord()
{    Schema schema = SchemaBuilder.record("myrecord").namespace("org.example").aliases("oldrecord").fields().name("f0").aliases("f0alias").type().stringType().noDefault().name("f1").doc("This is f1").type().longType().noDefault().name("f2").type().nullable().booleanType().booleanDefault(true).name("f3").type().unionOf().nullType().and().booleanType().endUnion().nullDefault().endRecord();    Assert.assertEquals("myrecord", schema.getName());    Assert.assertEquals("org.example", schema.getNamespace());    Assert.assertEquals("org.example.oldrecord", schema.getAliases().iterator().next());    Assert.assertFalse(schema.isError());    List<Schema.Field> fields = schema.getFields();    Assert.assertEquals(4, fields.size());    Assert.assertEquals(new Schema.Field("f0", Schema.create(Schema.Type.STRING)), fields.get(0));    Assert.assertTrue(fields.get(0).aliases().contains("f0alias"));    Assert.assertEquals(new Schema.Field("f1", Schema.create(Schema.Type.LONG), "This is f1"), fields.get(1));    List<Schema> types = new ArrayList<>();    types.add(Schema.create(Schema.Type.BOOLEAN));    types.add(Schema.create(Schema.Type.NULL));    Schema optional = Schema.createUnion(types);    Assert.assertEquals(new Schema.Field("f2", optional, null, true), fields.get(2));    List<Schema> types2 = new ArrayList<>();    types2.add(Schema.create(Schema.Type.NULL));    types2.add(Schema.create(Schema.Type.BOOLEAN));    Schema optional2 = Schema.createUnion(types2);    Assert.assertNotEquals(new Schema.Field("f3", optional2, null, (Object) null), fields.get(3));    Assert.assertEquals(new Schema.Field("f3", optional2, null, Schema.Field.NULL_DEFAULT_VALUE), fields.get(3));}
7c8f683879aafe150ab849c4ad2304d4f2e50f363de0cf23ae8115e47590aeb4
testDoc
public void testDoc()
{    Schema s = SchemaBuilder.fixed("myfixed").doc("mydoc").size(1);    Assert.assertEquals("mydoc", s.getDoc());}
03a9bf30ea8c2266945af82b1886bebd23ef1b7ee835570ea4f1970bf28a618c
testProps
public void testProps()
{    Schema s =     SchemaBuilder.builder().intBuilder().prop("p1", "v1").prop("p2", "v2").prop("p2", "v2real").endInt();    int size = s.getObjectProps().size();    Assert.assertEquals(2, size);    Assert.assertEquals("v1", s.getProp("p1"));    Assert.assertEquals("v2real", s.getProp("p2"));}
b9fdf8e71cc2ee300f4112efc1480602b21b4e6de132107820b3d1cfd750bec7
testObjectProps
public void testObjectProps()
{    Schema s = SchemaBuilder.builder().intBuilder().prop("booleanProp", true).prop("intProp", Integer.MAX_VALUE).prop("longProp", Long.MAX_VALUE).prop("floatProp", 1.0f).prop("doubleProp", Double.MAX_VALUE).prop("byteProp", new byte[] { 0x41, 0x42, 0x43 }).prop("stringProp", "abc").endInt();        Assert.assertEquals(7, s.getObjectProps().size());    Assert.assertTrue(s.getObjectProp("booleanProp") instanceof Boolean);    Assert.assertEquals(true, s.getObjectProp("booleanProp"));    Assert.assertTrue(s.getObjectProp("intProp") instanceof Integer);    Assert.assertEquals(Integer.MAX_VALUE, s.getObjectProp("intProp"));    Assert.assertTrue(s.getObjectProp("intProp") instanceof Integer);    Assert.assertTrue(s.getObjectProp("longProp") instanceof Long);    Assert.assertEquals(Long.MAX_VALUE, s.getObjectProp("longProp"));    Assert.assertTrue(s.getObjectProp("floatProp") instanceof Double);        Assert.assertEquals(1.0d, s.getObjectProp("floatProp"));    Assert.assertTrue(s.getObjectProp("doubleProp") instanceof Double);    Assert.assertEquals(Double.MAX_VALUE, s.getObjectProp("doubleProp"));        Assert.assertTrue(s.getObjectProp("byteProp") instanceof String);    Assert.assertEquals("ABC", s.getObjectProp("byteProp"));    Assert.assertTrue(s.getObjectProp("stringProp") instanceof String);    Assert.assertEquals("abc", s.getObjectProp("stringProp"));}
c8eca1d15b57076b0a28ded57e06c03eb61d8c1edaf082bdb1107ebbc547b6e6
testFieldObjectProps
public void testFieldObjectProps()
{    Schema s = SchemaBuilder.builder().record("MyRecord").fields().name("myField").prop("booleanProp", true).prop("intProp", Integer.MAX_VALUE).prop("longProp", Long.MAX_VALUE).prop("floatProp", 1.0f).prop("doubleProp", Double.MAX_VALUE).prop("byteProp", new byte[] { 0x41, 0x42, 0x43 }).prop("stringProp", "abc").type().intType().noDefault().endRecord();    Schema.Field f = s.getField("myField");        Assert.assertEquals(7, f.getObjectProps().size());    Assert.assertTrue(f.getObjectProp("booleanProp") instanceof Boolean);    Assert.assertEquals(true, f.getObjectProp("booleanProp"));    Assert.assertTrue(f.getObjectProp("intProp") instanceof Integer);    Assert.assertEquals(Integer.MAX_VALUE, f.getObjectProp("intProp"));    Assert.assertTrue(f.getObjectProp("intProp") instanceof Integer);    Assert.assertTrue(f.getObjectProp("longProp") instanceof Long);    Assert.assertEquals(Long.MAX_VALUE, f.getObjectProp("longProp"));    Assert.assertTrue(f.getObjectProp("floatProp") instanceof Double);        Assert.assertEquals(1.0d, f.getObjectProp("floatProp"));    Assert.assertTrue(f.getObjectProp("doubleProp") instanceof Double);    Assert.assertEquals(Double.MAX_VALUE, f.getObjectProp("doubleProp"));        Assert.assertTrue(f.getObjectProp("byteProp") instanceof String);    Assert.assertEquals("ABC", f.getObjectProp("byteProp"));    Assert.assertTrue(f.getObjectProp("stringProp") instanceof String);    Assert.assertEquals("abc", f.getObjectProp("stringProp"));}
fa2080e90f98d45b0056d9c64b4e4a42a8b39733287c7a77590e347ecca69e7c
testArrayObjectProp
public void testArrayObjectProp()
{    List<Object> values = new ArrayList<>();    values.add(true);    values.add(Integer.MAX_VALUE);    values.add(Long.MAX_VALUE);    values.add(1.0f);    values.add(Double.MAX_VALUE);    values.add(new byte[] { 0x41, 0x42, 0x43 });    values.add("abc");    Schema s = SchemaBuilder.builder().intBuilder().prop("arrayProp", values).endInt();        Assert.assertEquals(1, s.getObjectProps().size());    Assert.assertTrue(s.getObjectProp("arrayProp") instanceof Collection);    @SuppressWarnings("unchecked")    Collection<Object> valueCollection = (Collection<Object>) s.getObjectProp("arrayProp");    Iterator<Object> iter = valueCollection.iterator();    Assert.assertEquals(7, valueCollection.size());    Assert.assertEquals(true, iter.next());    Assert.assertEquals(Integer.MAX_VALUE, iter.next());    Assert.assertEquals(Long.MAX_VALUE, iter.next());        Assert.assertEquals(1.0d, iter.next());    Assert.assertEquals(Double.MAX_VALUE, iter.next());        Assert.assertEquals("ABC", iter.next());    Assert.assertEquals("abc", iter.next());}
8980a48798b2e4faa5f64c22d018f60daf734afbad27cec26b5f6210b7d6a6d9
testFieldArrayObjectProp
public void testFieldArrayObjectProp()
{    List<Object> values = new ArrayList<>();    values.add(true);    values.add(Integer.MAX_VALUE);    values.add(Long.MAX_VALUE);    values.add(1.0f);    values.add(Double.MAX_VALUE);    values.add(new byte[] { 0x41, 0x42, 0x43 });    values.add("abc");    Schema s = SchemaBuilder.builder().record("MyRecord").fields().name("myField").prop("arrayProp", values).type().intType().noDefault().endRecord();    Schema.Field f = s.getField("myField");        Assert.assertEquals(1, f.getObjectProps().size());    Assert.assertTrue(f.getObjectProp("arrayProp") instanceof Collection);    @SuppressWarnings("unchecked")    Collection<Object> valueCollection = (Collection<Object>) f.getObjectProp("arrayProp");    Iterator<Object> iter = valueCollection.iterator();    Assert.assertEquals(7, valueCollection.size());    Assert.assertEquals(true, iter.next());    Assert.assertEquals(Integer.MAX_VALUE, iter.next());    Assert.assertEquals(Long.MAX_VALUE, iter.next());        Assert.assertEquals(1.0d, iter.next());    Assert.assertEquals(Double.MAX_VALUE, iter.next());        Assert.assertEquals("ABC", iter.next());    Assert.assertEquals("abc", iter.next());}
153d56018de6d3ae52c481367bb3dfd3f734fcb5117321c4de20c5aee6082758
testMapObjectProp
public void testMapObjectProp()
{    Map<String, Object> values = new HashMap<>();    values.put("booleanKey", true);    values.put("intKey", Integer.MAX_VALUE);    values.put("longKey", Long.MAX_VALUE);    values.put("floatKey", 1.0f);    values.put("doubleKey", Double.MAX_VALUE);    values.put("byteKey", new byte[] { 0x41, 0x42, 0x43 });    values.put("stringKey", "abc");    Schema s = SchemaBuilder.builder().intBuilder().prop("mapProp", values).endInt();        Assert.assertTrue(s.getObjectProp("mapProp") instanceof Map);    @SuppressWarnings("unchecked")    Map<String, Object> valueMap = (Map<String, Object>) s.getObjectProp("mapProp");    Assert.assertEquals(values.size(), valueMap.size());    Assert.assertTrue(valueMap.get("booleanKey") instanceof Boolean);    Assert.assertEquals(true, valueMap.get("booleanKey"));    Assert.assertTrue(valueMap.get("intKey") instanceof Integer);    Assert.assertEquals(Integer.MAX_VALUE, valueMap.get("intKey"));    Assert.assertTrue(valueMap.get("longKey") instanceof Long);    Assert.assertEquals(Long.MAX_VALUE, valueMap.get("longKey"));        Assert.assertTrue(valueMap.get("floatKey") instanceof Double);    Assert.assertEquals(1.0d, valueMap.get("floatKey"));    Assert.assertTrue(valueMap.get("doubleKey") instanceof Double);    Assert.assertEquals(Double.MAX_VALUE, valueMap.get("doubleKey"));        Assert.assertTrue(valueMap.get("byteKey") instanceof String);    Assert.assertEquals("ABC", valueMap.get("byteKey"));    Assert.assertTrue(valueMap.get("stringKey") instanceof String);    Assert.assertEquals("abc", valueMap.get("stringKey"));}
c8c005c3b2beac809982d4426d86f15e7777d76d90131c9a93a7c9670ff519e5
testFieldMapObjectProp
public void testFieldMapObjectProp()
{    Map<String, Object> values = new HashMap<>();    values.put("booleanKey", true);    values.put("intKey", Integer.MAX_VALUE);    values.put("longKey", Long.MAX_VALUE);    values.put("floatKey", 1.0f);    values.put("doubleKey", Double.MAX_VALUE);    values.put("byteKey", new byte[] { 0x41, 0x42, 0x43 });    values.put("stringKey", "abc");    Schema s = SchemaBuilder.builder().record("MyRecord").fields().name("myField").prop("mapProp", values).type().intType().noDefault().endRecord();    Schema.Field f = s.getField("myField");        Assert.assertTrue(f.getObjectProp("mapProp") instanceof Map);    @SuppressWarnings("unchecked")    Map<String, Object> valueMap = (Map<String, Object>) f.getObjectProp("mapProp");    Assert.assertEquals(values.size(), valueMap.size());    Assert.assertTrue(valueMap.get("booleanKey") instanceof Boolean);    Assert.assertEquals(true, valueMap.get("booleanKey"));    Assert.assertTrue(valueMap.get("intKey") instanceof Integer);    Assert.assertEquals(Integer.MAX_VALUE, valueMap.get("intKey"));    Assert.assertTrue(valueMap.get("longKey") instanceof Long);    Assert.assertEquals(Long.MAX_VALUE, valueMap.get("longKey"));        Assert.assertTrue(valueMap.get("floatKey") instanceof Double);    Assert.assertEquals(1.0d, valueMap.get("floatKey"));    Assert.assertTrue(valueMap.get("doubleKey") instanceof Double);    Assert.assertEquals(Double.MAX_VALUE, valueMap.get("doubleKey"));        Assert.assertTrue(valueMap.get("byteKey") instanceof String);    Assert.assertEquals("ABC", valueMap.get("byteKey"));    Assert.assertTrue(valueMap.get("stringKey") instanceof String);    Assert.assertEquals("abc", valueMap.get("stringKey"));}
403dd026f892ca00ef098dd1766e222436c38775e988a499d40992841cfdd9e2
testNullObjectProp
public void testNullObjectProp()
{    SchemaBuilder.builder().intBuilder().prop("nullProp", (Object) null).endInt();}
fdc2ff87bd7ff240a2c6b8699589af0fea0d20077572360dfb593c7b62e23e58
testFieldNullObjectProp
public void testFieldNullObjectProp()
{    SchemaBuilder.builder().record("MyRecord").fields().name("myField").prop("nullProp", (Object) null).type().intType().noDefault().endRecord();}
2635a157c76b071e0d340cd5786491ced4d27e7fcf4112a8152b6ef35eecf96e
testNamespaces
public void testNamespaces()
{    Schema s1 = SchemaBuilder.record("myrecord").namespace("org.example").fields().name("myint").type().intType().noDefault().endRecord();    Schema s2 = SchemaBuilder.record("org.example.myrecord").fields().name("myint").type().intType().noDefault().endRecord();    Schema s3 = SchemaBuilder.record("org.example.myrecord").namespace("org.example2").fields().name("myint").type().intType().noDefault().endRecord();    Schema s4 = SchemaBuilder.builder("org.example").record("myrecord").fields().name("myint").type().intType().noDefault().endRecord();    Assert.assertEquals("myrecord", s1.getName());    Assert.assertEquals("myrecord", s2.getName());    Assert.assertEquals("myrecord", s3.getName());    Assert.assertEquals("myrecord", s4.getName());    Assert.assertEquals("org.example", s1.getNamespace());    Assert.assertEquals("org.example", s2.getNamespace());        Assert.assertEquals("org.example", s3.getNamespace());    Assert.assertEquals("org.example", s4.getNamespace());    Assert.assertEquals("org.example.myrecord", s1.getFullName());    Assert.assertEquals("org.example.myrecord", s2.getFullName());    Assert.assertEquals("org.example.myrecord", s3.getFullName());    Assert.assertEquals("org.example.myrecord", s4.getFullName());}
a1d3cfb5c69a9c9a7add0f01882694c3e0d1bc0b3051a32c5646aeaab59db584
testMissingRecordName
public void testMissingRecordName()
{        SchemaBuilder.record(null).fields().name("f0").type().stringType().noDefault().endRecord();}
f7309da99bbf2f65fcc40413a07dc3116033c984e29575452667e56d8c0af727
testBoolean
public void testBoolean()
{    Schema.Type type = Schema.Type.BOOLEAN;    Schema simple = SchemaBuilder.builder().booleanType();    Schema expected = primitive(type, simple);    Schema built1 = SchemaBuilder.builder().booleanBuilder().prop("p", "v").endBoolean();    Assert.assertEquals(expected, built1);}
2f10d36bafbb2b3dfe9117c739286851614ea4b4edaacb4a39d77c0ba7e40abd
testInt
public void testInt()
{    Schema.Type type = Schema.Type.INT;    Schema simple = SchemaBuilder.builder().intType();    Schema expected = primitive(type, simple);    Schema built1 = SchemaBuilder.builder().intBuilder().prop("p", "v").endInt();    Assert.assertEquals(expected, built1);}
985b9885790e103635773f647e9df79e69cb31098a6e2b9d5fc211ca917a295d
testLong
public void testLong()
{    Schema.Type type = Schema.Type.LONG;    Schema simple = SchemaBuilder.builder().longType();    Schema expected = primitive(type, simple);    Schema built1 = SchemaBuilder.builder().longBuilder().prop("p", "v").endLong();    Assert.assertEquals(expected, built1);}
305242112461377069be291ad69495bf1e1db9d018e7721514c34899670969e1
testFloat
public void testFloat()
{    Schema.Type type = Schema.Type.FLOAT;    Schema simple = SchemaBuilder.builder().floatType();    Schema expected = primitive(type, simple);    Schema built1 = SchemaBuilder.builder().floatBuilder().prop("p", "v").endFloat();    Assert.assertEquals(expected, built1);}
5b36811e287c242b491c92521811c23e5d167e0bdafd583c415f6538be8cd004
testDuble
public void testDuble()
{    Schema.Type type = Schema.Type.DOUBLE;    Schema simple = SchemaBuilder.builder().doubleType();    Schema expected = primitive(type, simple);    Schema built1 = SchemaBuilder.builder().doubleBuilder().prop("p", "v").endDouble();    Assert.assertEquals(expected, built1);}
eeeafcd44575acfda0a5acf65dc9f11e90ef70e62392a3884ffe471fde22edb3
testString
public void testString()
{    Schema.Type type = Schema.Type.STRING;    Schema simple = SchemaBuilder.builder().stringType();    Schema expected = primitive(type, simple);    Schema built1 = SchemaBuilder.builder().stringBuilder().prop("p", "v").endString();    Assert.assertEquals(expected, built1);}
e303814592e5f8396cae35d4cabac3e308b4356ca97326151852932c5b86487b
testBytes
public void testBytes()
{    Schema.Type type = Schema.Type.BYTES;    Schema simple = SchemaBuilder.builder().bytesType();    Schema expected = primitive(type, simple);    Schema built1 = SchemaBuilder.builder().bytesBuilder().prop("p", "v").endBytes();    Assert.assertEquals(expected, built1);}
1eeb1102bce7e6e987c547d40b38c59192fcbd975c451ef3811bb29a90c72382
testNull
public void testNull()
{    Schema.Type type = Schema.Type.NULL;    Schema simple = SchemaBuilder.builder().nullType();    Schema expected = primitive(type, simple);    Schema built1 = SchemaBuilder.builder().nullBuilder().prop("p", "v").endNull();    Assert.assertEquals(expected, built1);}
04fed816b6236a2bf61a6214c8de5bbac17bfe18c87b19efbaf39b39c154a5c9
primitive
private Schema primitive(Schema.Type type, Schema bare)
{        Schema bareByName = SchemaBuilder.builder().type(type.getName());    Assert.assertEquals(Schema.create(type), bareByName);    Assert.assertEquals(bareByName, bare);        Schema p = Schema.create(type);    p.addProp("p", "v");    return p;}
4aaeeb4e9e566200374abe24f6a59ff4fd34cff470b7463d232f0a4c8cba60ae
testRecursiveRecord
public void testRecursiveRecord()
{    Schema schema = SchemaBuilder.record("LongList").fields().name("value").type().longType().noDefault().name("next").type().optional().type("LongList").endRecord();    Assert.assertEquals("LongList", schema.getName());    List<Schema.Field> fields = schema.getFields();    Assert.assertEquals(2, fields.size());    Assert.assertEquals(new Schema.Field("value", Schema.create(Schema.Type.LONG), null), fields.get(0));    Assert.assertEquals(Schema.Type.UNION, fields.get(1).schema().getType());    Assert.assertEquals(Schema.Type.NULL, fields.get(1).schema().getTypes().get(0).getType());    Schema recordSchema = fields.get(1).schema().getTypes().get(1);    Assert.assertEquals(Schema.Type.RECORD, recordSchema.getType());    Assert.assertEquals("LongList", recordSchema.getName());    Assert.assertEquals(NullNode.getInstance(), fields.get(1).defaultValue());}
95704a8f6b7a6ae50950de75dbfeac67293ef8dda758688ed94610819ab5e965
testEnum
public void testEnum()
{    List<String> symbols = Arrays.asList("a", "b");    Schema expected = Schema.createEnum("myenum", null, null, symbols);    expected.addProp("p", "v");    Schema schema = SchemaBuilder.enumeration("myenum").prop("p", "v").symbols("a", "b");    Assert.assertEquals(expected, schema);}
336309b4ae145795af01e1de832848efea6473c9dfc8eadfd36dbbd7a19277df
testEnumWithDefault
public void testEnumWithDefault()
{    List<String> symbols = Arrays.asList("a", "b");    String enumDefault = "a";    Schema expected = Schema.createEnum("myenum", null, null, symbols, enumDefault);    expected.addProp("p", "v");    Schema schema = SchemaBuilder.enumeration("myenum").prop("p", "v").defaultSymbol(enumDefault).symbols("a", "b");    Assert.assertEquals(expected, schema);}
62b7b5bde35373f7e3af0d8512fbaa4c5f52f8b467d5162de1e3b40815417e91
testFixed
public void testFixed()
{    Schema expected = Schema.createFixed("myfixed", null, null, 16);    expected.addAlias("myOldFixed");    Schema schema = SchemaBuilder.fixed("myfixed").aliases("myOldFixed").size(16);    Assert.assertEquals(expected, schema);}
2939b62b9b0a83879a561bf6f2ede3780e42992ee7bd61e1146f2044b924bd44
testArray
public void testArray()
{    Schema longSchema = Schema.create(Schema.Type.LONG);    Schema expected = Schema.createArray(longSchema);    Schema schema1 = SchemaBuilder.array().items().longType();    Assert.assertEquals(expected, schema1);    Schema schema2 = SchemaBuilder.array().items(longSchema);    Assert.assertEquals(expected, schema2);    Schema schema3 = SchemaBuilder.array().prop("p", "v").items().type("long");    expected.addProp("p", "v");    Assert.assertEquals(expected, schema3);}
2711789c51604791e3f1d9e60fd013245613e5695ae4ad755db102d34cdf3cb8
testMap
public void testMap()
{    Schema intSchema = Schema.create(Schema.Type.INT);    Schema expected = Schema.createMap(intSchema);    Schema schema1 = SchemaBuilder.map().values().intType();    Assert.assertEquals(expected, schema1);    Schema schema2 = SchemaBuilder.map().values(intSchema);    Assert.assertEquals(expected, schema2);    Schema schema3 = SchemaBuilder.map().prop("p", "v").values().type("int");    expected.addProp("p", "v");    Assert.assertEquals(expected, schema3);}
e73fecc421a0f539def031bee7e24049f27312527c1e287bf28add4bb3cbaf57
testUnionAndNullable
public void testUnionAndNullable()
{    List<Schema> types = new ArrayList<>();    types.add(Schema.create(Schema.Type.LONG));    types.add(Schema.create(Schema.Type.NULL));    Schema expected = Schema.createUnion(types);    Schema schema = SchemaBuilder.unionOf().longType().and().nullType().endUnion();    Assert.assertEquals(expected, schema);    schema = SchemaBuilder.nullable().longType();    Assert.assertEquals(expected, schema);}
7e5420de774d54acb24255b0e471792881a3ef2d3578f061e649cd5203b0dabc
testFields
public void testFields()
{    Schema rec = SchemaBuilder.record("Rec").fields().name("documented").doc("documented").type().nullType().noDefault().name("ascending").orderAscending().type().booleanType().noDefault().name("descending").orderDescending().type().floatType().noDefault().name("ignored").orderIgnore().type().doubleType().noDefault().name("aliased").aliases("anAlias").type().stringType().noDefault().endRecord();    Assert.assertEquals("documented", rec.getField("documented").doc());    Assert.assertEquals(Order.ASCENDING, rec.getField("ascending").order());    Assert.assertEquals(Order.DESCENDING, rec.getField("descending").order());    Assert.assertEquals(Order.IGNORE, rec.getField("ignored").order());    Assert.assertTrue(rec.getField("aliased").aliases().contains("anAlias"));}
0486452829ca3b73b5ca295af916cc155ed98f8ff447c50f984ec3b76d48afbc
testFieldShortcuts
public void testFieldShortcuts()
{    Schema full = SchemaBuilder.record("Blah").fields().name("rbool").type().booleanType().noDefault().name("obool").type().optional().booleanType().name("nbool").type().nullable().booleanType().booleanDefault(true).name("rint").type().intType().noDefault().name("oint").type().optional().intType().name("nint").type().nullable().intType().intDefault(1).name("rlong").type().longType().noDefault().name("olong").type().optional().longType().name("nlong").type().nullable().longType().longDefault(2L).name("rfloat").type().floatType().noDefault().name("ofloat").type().optional().floatType().name("nfloat").type().nullable().floatType().floatDefault(-1.1f).name("rdouble").type().doubleType().noDefault().name("odouble").type().optional().doubleType().name("ndouble").type().nullable().doubleType().doubleDefault(99.9d).name("rstring").type().stringType().noDefault().name("ostring").type().optional().stringType().name("nstring").type().nullable().stringType().stringDefault("def").name("rbytes").type().bytesType().noDefault().name("obytes").type().optional().bytesType().name("nbytes").type().nullable().bytesType().bytesDefault(new byte[] { 1, 2, 3 }).endRecord();    Schema shortcut = SchemaBuilder.record("Blah").fields().requiredBoolean("rbool").optionalBoolean("obool").nullableBoolean("nbool", true).requiredInt("rint").optionalInt("oint").nullableInt("nint", 1).requiredLong("rlong").optionalLong("olong").nullableLong("nlong", 2L).requiredFloat("rfloat").optionalFloat("ofloat").nullableFloat("nfloat", -1.1f).requiredDouble("rdouble").optionalDouble("odouble").nullableDouble("ndouble", 99.9d).requiredString("rstring").optionalString("ostring").nullableString("nstring", "def").requiredBytes("rbytes").optionalBytes("obytes").nullableBytes("nbytes", new byte[] { 1, 2, 3 }).endRecord();    Assert.assertEquals(full, shortcut);}
14e6f5f6ed7a7edfaa3fa989d5ccc69b90bcedace0ec78ee064d632d0550c936
testNames
public void testNames()
{        Schema r = SchemaBuilder.record("Rec").fields().name("f0").type().fixed("org.foo.MyFixed").size(1).noDefault().name("f1").type("org.foo.MyFixed").noDefault().name("f2").type("org.foo.MyFixed", "").noDefault().name("f3").type("org.foo.MyFixed", null).noDefault().name("f4").type("org.foo.MyFixed", "ignorethis").noDefault().name("f5").type("MyFixed", "org.foo").noDefault().endRecord();    Schema expected = Schema.createFixed("org.foo.MyFixed", null, null, 1);    checkField(r, expected, "f0");    checkField(r, expected, "f1");    checkField(r, expected, "f2");    checkField(r, expected, "f3");    checkField(r, expected, "f4");    checkField(r, expected, "f5");        Schema f = SchemaBuilder.builder("").fixed("Foo").size(1);    Assert.assertEquals(Schema.createFixed("Foo", null, null, 1), f);        r = SchemaBuilder.record("Rec").namespace("org.foo").fields().name("f0").type().fixed("MyFixed").size(1).noDefault().name("f1").type("org.foo.MyFixed").noDefault().name("f2").type("org.foo.MyFixed", "").noDefault().name("f3").type("org.foo.MyFixed", null).noDefault().name("f4").type("org.foo.MyFixed", "ignorethis").noDefault().name("f5").type("MyFixed", "org.foo").noDefault().name("f6").type("MyFixed", null).noDefault().name("f7").type("MyFixed").noDefault().endRecord();    checkField(r, expected, "f0");    checkField(r, expected, "f1");    checkField(r, expected, "f2");    checkField(r, expected, "f3");    checkField(r, expected, "f4");    checkField(r, expected, "f5");    checkField(r, expected, "f6");    checkField(r, expected, "f7");        r = SchemaBuilder.record("Rec").namespace("org.rec").fields().name("f0").type().fixed("MyFixed").namespace("org.foo").size(1).noDefault().name("f1").type("org.foo.MyFixed").noDefault().name("f2").type("org.foo.MyFixed", "").noDefault().name("f3").type("org.foo.MyFixed", null).noDefault().name("f4").type("org.foo.MyFixed", "ignorethis").noDefault().name("f5").type("MyFixed", "org.foo").noDefault().endRecord();    checkField(r, expected, "f0");    checkField(r, expected, "f1");    checkField(r, expected, "f2");    checkField(r, expected, "f3");    checkField(r, expected, "f4");    checkField(r, expected, "f5");        expected = Schema.createFixed("MyFixed", null, null, 1);    r = SchemaBuilder.record("Rec").namespace("org.rec").fields().name("f0").type().fixed("MyFixed").namespace("").size(1).noDefault().name("f1").type("MyFixed", "").noDefault().endRecord();    checkField(r, expected, "f0");    checkField(r, expected, "f1");        SchemaBuilder.fixed("org.test.long").size(1);    SchemaBuilder.fixed("long").namespace("org.test").size(1);    SchemaBuilder.builder("org.test").fixed("long").size(1);}
13b70522f895721d32cf4f553b1447878f9df4690ad3ad45bd8be7cecbcb75e4
checkField
private void checkField(Schema r, Schema expected, String name)
{    Assert.assertEquals(expected, r.getField(name).schema());}
2bbdb95a1dbd6c0f30b885d7b3ee8da94a888f2d7e5160b077e814220d1e8851
testNamesFailRedefined
public void testNamesFailRedefined()
{    SchemaBuilder.record("Rec").fields().name("f0").type().enumeration("MyEnum").symbols("A", "B").enumDefault("A").name("f1").type().enumeration("MyEnum").symbols("X", "Y").noDefault().endRecord();}
f5fbe871ab23092a4a48c6128f6fc98c73d7567639795c165a619a8296e219da
testNamesFailAbsent
public void testNamesFailAbsent()
{    SchemaBuilder.builder().type("notdefined");}
1feadd85988899426f152dcb5b1a3f0d05f1a1e118a523c49a5be4d9ff70f6fc
testNameReserved
public void testNameReserved()
{    SchemaBuilder.fixed("long").namespace("").size(1);}
11966a366fadcf70ad02d8e2a1f97040e2921341f55a912ac74c4ce4894328b3
testFieldTypesAndDefaultValues
public void testFieldTypesAndDefaultValues()
{    byte[] bytedef = new byte[] { 3 };    ByteBuffer bufdef = ByteBuffer.wrap(bytedef);    String strdef = "\u0003";    HashMap<String, String> mapdef = new HashMap<>();    mapdef.put("a", "A");    ArrayList<String> arrdef = new ArrayList<>();    arrdef.add("arr");    Schema rec = SchemaBuilder.record("inner").fields().name("f").type().intType().noDefault().endRecord();    Schema rec2 = SchemaBuilder.record("inner2").fields().name("f2").type().intType().noDefault().endRecord();    GenericData.Record recdef = new GenericRecordBuilder(rec).set("f", 1).build();    GenericData.Record recdef2 = new GenericRecordBuilder(rec2).set("f2", 2).build();    Schema r = SchemaBuilder.record("r").fields().name("boolF").type().booleanType().booleanDefault(false).name("intF").type().intType().intDefault(1).name("longF").type().longType().longDefault(2L).name("floatF").type().floatType().floatDefault(3.0f).name("doubleF").type().doubleType().doubleDefault(4.0d).name("stringF").type().stringType().stringDefault("def").name("bytesF1").type().bytesType().bytesDefault(bytedef).name("bytesF2").type().bytesType().bytesDefault(bufdef).name("bytesF3").type().bytesType().bytesDefault(strdef).name("nullF").type().nullType().nullDefault().name("fixedF1").type().fixed("F1").size(1).fixedDefault(bytedef).name("fixedF2").type().fixed("F2").size(1).fixedDefault(bufdef).name("fixedF3").type().fixed("F3").size(1).fixedDefault(strdef).name("enumF").type().enumeration("E1").symbols("S").enumDefault("S").name("mapF").type().map().values().stringType().mapDefault(mapdef).name("arrayF").type().array().items().stringType().arrayDefault(arrdef).name("recordF").type().record("inner").fields().name("f").type().intType().noDefault().endRecord().recordDefault(recdef).name("byName").type("E1").withDefault("S").name("boolU").type().unionOf().booleanType().and().intType().endUnion().booleanDefault(false).name("intU").type().unionOf().intType().and().longType().endUnion().intDefault(1).name("longU").type().unionOf().longType().and().intType().endUnion().longDefault(2L).name("floatU").type().unionOf().floatType().and().intType().endUnion().floatDefault(3.0f).name("doubleU").type().unionOf().doubleType().and().intType().endUnion().doubleDefault(4.0d).name("stringU").type().unionOf().stringType().and().intType().endUnion().stringDefault("def").name("bytesU").type().unionOf().bytesType().and().intType().endUnion().bytesDefault(bytedef).name("nullU").type().unionOf().nullType().and().intType().endUnion().nullDefault().name("fixedU").type().unionOf().fixed("F4").size(1).and().intType().endUnion().fixedDefault(bytedef).name("enumU").type().unionOf().enumeration("E2").symbols("SS").and().intType().endUnion().enumDefault("SS").name("mapU").type().unionOf().map().values().stringType().and().intType().endUnion().mapDefault(mapdef).name("arrayU").type().unionOf().array().items().stringType().and().intType().endUnion().arrayDefault(arrdef).name("recordU").type().unionOf().record("inner2").fields().name("f2").type().intType().noDefault().endRecord().and().intType().endUnion().recordDefault(recdef2).endRecord();    GenericData.Record newRec = new GenericRecordBuilder(r).build();    Assert.assertEquals(false, newRec.get("boolF"));    Assert.assertEquals(false, newRec.get("boolU"));    Assert.assertEquals(1, newRec.get("intF"));    Assert.assertEquals(1, newRec.get("intU"));    Assert.assertEquals(2L, newRec.get("longF"));    Assert.assertEquals(2L, newRec.get("longU"));    Assert.assertEquals(3f, newRec.get("floatF"));    Assert.assertEquals(3f, newRec.get("floatU"));    Assert.assertEquals(4d, newRec.get("doubleF"));    Assert.assertEquals(4d, newRec.get("doubleU"));    Assert.assertEquals("def", newRec.get("stringF").toString());    Assert.assertEquals("def", newRec.get("stringU").toString());    Assert.assertEquals(bufdef, newRec.get("bytesF1"));    Assert.assertEquals(bufdef, newRec.get("bytesF2"));    Assert.assertEquals(bufdef, newRec.get("bytesF3"));    Assert.assertEquals(bufdef, newRec.get("bytesU"));    Assert.assertNull(newRec.get("nullF"));    Assert.assertNull(newRec.get("nullU"));    Assert.assertArrayEquals(bytedef, ((GenericData.Fixed) newRec.get("fixedF1")).bytes());    Assert.assertArrayEquals(bytedef, ((GenericData.Fixed) newRec.get("fixedF2")).bytes());    Assert.assertArrayEquals(bytedef, ((GenericData.Fixed) newRec.get("fixedF3")).bytes());    Assert.assertArrayEquals(bytedef, ((GenericData.Fixed) newRec.get("fixedU")).bytes());    Assert.assertEquals("S", newRec.get("enumF").toString());    Assert.assertEquals("SS", newRec.get("enumU").toString());    @SuppressWarnings("unchecked")    Map<CharSequence, CharSequence> map = (Map<CharSequence, CharSequence>) newRec.get("mapF");    Assert.assertEquals(mapdef.size(), map.size());    for (Map.Entry<CharSequence, CharSequence> e : map.entrySet()) {        Assert.assertEquals(mapdef.get(e.getKey().toString()), e.getValue().toString());    }    Assert.assertEquals(newRec.get("mapF"), newRec.get("mapU"));    @SuppressWarnings("unchecked")    GenericData.Array<CharSequence> arr = (GenericData.Array<CharSequence>) newRec.get("arrayF");    Assert.assertEquals(arrdef.size(), arr.size());    for (CharSequence c : arr) {        Assert.assertTrue(arrdef.contains(c.toString()));    }    Assert.assertEquals(newRec.get("arrF"), newRec.get("arrU"));    Assert.assertEquals(recdef, newRec.get("recordF"));    Assert.assertEquals(recdef2, newRec.get("recordU"));    Assert.assertEquals("S", newRec.get("byName").toString());}
3f71e798f56f221198d13b9bfc5e7450c2ee88163070f94905a9c8c3d36657d4
testBadDefault
public void testBadDefault()
{    SchemaBuilder.record("r").fields().name("f").type(Schema.create(Schema.Type.INT)).withDefault(new Object()).endRecord();}
985b885a68e0f5289c6759ab2588ed5637ef96862bbd4746d7fcd4869a57f274
testUnionFieldBuild
public void testUnionFieldBuild()
{    SchemaBuilder.record("r").fields().name("allUnion").type().unionOf().booleanType().and().intType().and().longType().and().floatType().and().doubleType().and().stringType().and().bytesType().and().nullType().and().fixed("Fix").size(1).and().enumeration("Enu").symbols("Q").and().array().items().intType().and().map().values().longType().and().record("Rec").fields().name("one").type("Fix").noDefault().endRecord().endUnion().booleanDefault(false).endRecord();}
52c2304dc2886f45b5e4a5f0b25445d5e0ab63afc3bb51e93908a773bdc8adcb
testDefaults
public void testDefaults() throws IOException
{    Schema writeSchema = SchemaBuilder.record("r").fields().name("requiredInt").type().intType().noDefault().name("optionalInt").type().optional().intType().name("nullableIntWithDefault").type().nullable().intType().intDefault(3).endRecord();    GenericData.Record rec1 = new GenericRecordBuilder(writeSchema).set("requiredInt", 1).build();    Assert.assertEquals(1, rec1.get("requiredInt"));    Assert.assertEquals(null, rec1.get("optionalInt"));    Assert.assertEquals(3, rec1.get("nullableIntWithDefault"));    GenericData.Record rec2 = new GenericRecordBuilder(writeSchema).set("requiredInt", 1).set("optionalInt", 2).set("nullableIntWithDefault", 13).build();    Assert.assertEquals(1, rec2.get("requiredInt"));    Assert.assertEquals(2, rec2.get("optionalInt"));    Assert.assertEquals(13, rec2.get("nullableIntWithDefault"));        File file = new File(DIR.getRoot().getPath(), "testDefaults.avro");    try (DataFileWriter<Object> writer = new DataFileWriter<>(new GenericDatumWriter<>())) {        writer.create(writeSchema, file);        writer.append(rec1);        writer.append(rec2);    }    Schema readSchema = SchemaBuilder.record("r").fields().name("requiredInt").type().intType().noDefault().name("optionalInt").type().optional().intType().name("nullableIntWithDefault").type().nullable().intType().intDefault(3).name("newOptionalInt").type().optional().intType().name("newNullableIntWithDefault").type().nullable().intType().intDefault(5).endRecord();    DataFileReader<GenericData.Record> reader = new DataFileReader<>(file, new GenericDatumReader<>(writeSchema, readSchema));    GenericData.Record rec1read = reader.iterator().next();    Assert.assertEquals(1, rec1read.get("requiredInt"));    Assert.assertNull(rec1read.get("optionalInt"));    Assert.assertEquals(3, rec1read.get("nullableIntWithDefault"));    Assert.assertNull(rec1read.get("newOptionalInt"));    Assert.assertEquals(5, rec1read.get("newNullableIntWithDefault"));    GenericData.Record rec2read = reader.iterator().next();    Assert.assertEquals(1, rec2read.get("requiredInt"));    Assert.assertEquals(2, rec2read.get("optionalInt"));    Assert.assertEquals(13, rec2read.get("nullableIntWithDefault"));    Assert.assertNull(rec2read.get("newOptionalInt"));    Assert.assertEquals(5, rec2read.get("newNullableIntWithDefault"));}
755b9b17b1b2a75bab327a066264bd294ff1719e182ae32a118e7a7b129f17ec
testDefaultTypes
public void testDefaultTypes()
{    Integer intDef = 1;    Long longDef = 2L;    Float floatDef = 3F;    Double doubleDef = 4D;    Schema schema = SchemaBuilder.record("r").fields().name("int").type().intType().intDefault(intDef).name("long").type().longType().longDefault(longDef).name("float").type().floatType().floatDefault(floatDef).name("double").type().doubleType().doubleDefault(doubleDef).endRecord();    Assert.assertEquals("int field default type or value mismatch", intDef, schema.getField("int").defaultVal());    Assert.assertEquals("long field default type or value mismatch", longDef, schema.getField("long").defaultVal());    Assert.assertEquals("float field default type or value mismatch", floatDef, schema.getField("float").defaultVal());    Assert.assertEquals("double field default type or value mismatch", doubleDef, schema.getField("double").defaultVal());}
ea8d17f0219119f3983fc206a80ed29ae8b35dbfb9f7c85b646d104431b3f396
testValidateSchemaPairMissingField
public void testValidateSchemaPairMissingField() throws Exception
{    final List<Schema.Field> readerFields = list(new Schema.Field("oldfield1", INT_SCHEMA, null, null));    final Schema reader = Schema.createRecord(readerFields);    final SchemaCompatibility.SchemaPairCompatibility expectedResult = new SchemaCompatibility.SchemaPairCompatibility(SchemaCompatibility.SchemaCompatibilityResult.compatible(), reader, WRITER_SCHEMA, SchemaCompatibility.READER_WRITER_COMPATIBLE_MESSAGE);        assertEquals(expectedResult, checkReaderWriterCompatibility(reader, WRITER_SCHEMA));}
5281ca4dc05c595be4eabed346dfc49a2f0a96b4f26835cbd5fea77497dea22d
testValidateSchemaPairMissingSecondField
public void testValidateSchemaPairMissingSecondField() throws Exception
{    final List<Schema.Field> readerFields = list(new Schema.Field("oldfield2", STRING_SCHEMA, null, null));    final Schema reader = Schema.createRecord(readerFields);    final SchemaCompatibility.SchemaPairCompatibility expectedResult = new SchemaCompatibility.SchemaPairCompatibility(SchemaCompatibility.SchemaCompatibilityResult.compatible(), reader, WRITER_SCHEMA, SchemaCompatibility.READER_WRITER_COMPATIBLE_MESSAGE);        assertEquals(expectedResult, checkReaderWriterCompatibility(reader, WRITER_SCHEMA));}
a9d6fbb6be69b8fb542a5bf4140bcb2dca3200d7412c1b6a8320848bdd32e33e
testValidateSchemaPairAllFields
public void testValidateSchemaPairAllFields() throws Exception
{    final List<Schema.Field> readerFields = list(new Schema.Field("oldfield1", INT_SCHEMA, null, null), new Schema.Field("oldfield2", STRING_SCHEMA, null, null));    final Schema reader = Schema.createRecord(readerFields);    final SchemaCompatibility.SchemaPairCompatibility expectedResult = new SchemaCompatibility.SchemaPairCompatibility(SchemaCompatibility.SchemaCompatibilityResult.compatible(), reader, WRITER_SCHEMA, SchemaCompatibility.READER_WRITER_COMPATIBLE_MESSAGE);        assertEquals(expectedResult, checkReaderWriterCompatibility(reader, WRITER_SCHEMA));}
d80171d36a1918c91d53926430849a2e7b316884de3aa922823f77684e3991dd
testValidateSchemaNewFieldWithDefault
public void testValidateSchemaNewFieldWithDefault() throws Exception
{    final List<Schema.Field> readerFields = list(new Schema.Field("oldfield1", INT_SCHEMA, null, null), new Schema.Field("newfield1", INT_SCHEMA, null, 42));    final Schema reader = Schema.createRecord(readerFields);    final SchemaCompatibility.SchemaPairCompatibility expectedResult = new SchemaCompatibility.SchemaPairCompatibility(SchemaCompatibility.SchemaCompatibilityResult.compatible(), reader, WRITER_SCHEMA, SchemaCompatibility.READER_WRITER_COMPATIBLE_MESSAGE);        assertEquals(expectedResult, checkReaderWriterCompatibility(reader, WRITER_SCHEMA));}
1154eb8d439c2df11fd0b2e2f114e6b44b3b428c13047fcc20f9e4c3823b5a9d
testValidateSchemaNewField
public void testValidateSchemaNewField() throws Exception
{    final List<Schema.Field> readerFields = list(new Schema.Field("oldfield1", INT_SCHEMA, null, null), new Schema.Field("newfield1", INT_SCHEMA, null, null));    final Schema reader = Schema.createRecord(readerFields);    SchemaPairCompatibility compatibility = checkReaderWriterCompatibility(reader, WRITER_SCHEMA);        assertEquals(SchemaCompatibility.SchemaCompatibilityType.INCOMPATIBLE, compatibility.getType());    assertEquals(SchemaCompatibility.SchemaCompatibilityResult.incompatible(SchemaIncompatibilityType.READER_FIELD_MISSING_DEFAULT_VALUE, reader, WRITER_SCHEMA, "newfield1", asList("", "fields", "1")), compatibility.getResult());    assertEquals(String.format("Data encoded using writer schema:%n%s%n" + "will or may fail to decode using reader schema:%n%s%n", WRITER_SCHEMA.toString(true), reader.toString(true)), compatibility.getDescription());    assertEquals(reader, compatibility.getReader());    assertEquals(WRITER_SCHEMA, compatibility.getWriter());}
edbe251e09921809d1b9a61723dbdae775c328d733bf21d776853b2ec8e954fb
testValidateArrayWriterSchema
public void testValidateArrayWriterSchema() throws Exception
{    final Schema validReader = Schema.createArray(STRING_SCHEMA);    final Schema invalidReader = Schema.createMap(STRING_SCHEMA);    final SchemaCompatibility.SchemaPairCompatibility validResult = new SchemaCompatibility.SchemaPairCompatibility(SchemaCompatibility.SchemaCompatibilityResult.compatible(), validReader, STRING_ARRAY_SCHEMA, SchemaCompatibility.READER_WRITER_COMPATIBLE_MESSAGE);    final SchemaCompatibility.SchemaPairCompatibility invalidResult = new SchemaCompatibility.SchemaPairCompatibility(SchemaCompatibility.SchemaCompatibilityResult.incompatible(SchemaIncompatibilityType.TYPE_MISMATCH, invalidReader, STRING_ARRAY_SCHEMA, "reader type: MAP not compatible with writer type: ARRAY", Collections.singletonList("")), invalidReader, STRING_ARRAY_SCHEMA, String.format("Data encoded using writer schema:%n%s%n" + "will or may fail to decode using reader schema:%n%s%n", STRING_ARRAY_SCHEMA.toString(true), invalidReader.toString(true)));    assertEquals(validResult, checkReaderWriterCompatibility(validReader, STRING_ARRAY_SCHEMA));    assertEquals(invalidResult, checkReaderWriterCompatibility(invalidReader, STRING_ARRAY_SCHEMA));}
4a8e0a94b17d58f222e5ba01d9a8813f3322f09bd6546774bea5633a4f8b047b
testValidatePrimitiveWriterSchema
public void testValidatePrimitiveWriterSchema() throws Exception
{    final Schema validReader = Schema.create(Schema.Type.STRING);    final SchemaCompatibility.SchemaPairCompatibility validResult = new SchemaCompatibility.SchemaPairCompatibility(SchemaCompatibility.SchemaCompatibilityResult.compatible(), validReader, STRING_SCHEMA, SchemaCompatibility.READER_WRITER_COMPATIBLE_MESSAGE);    final SchemaCompatibility.SchemaPairCompatibility invalidResult = new SchemaCompatibility.SchemaPairCompatibility(SchemaCompatibility.SchemaCompatibilityResult.incompatible(SchemaIncompatibilityType.TYPE_MISMATCH, INT_SCHEMA, STRING_SCHEMA, "reader type: INT not compatible with writer type: STRING", Collections.singletonList("")), INT_SCHEMA, STRING_SCHEMA, String.format("Data encoded using writer schema:%n%s%n" + "will or may fail to decode using reader schema:%n%s%n", STRING_SCHEMA.toString(true), INT_SCHEMA.toString(true)));    assertEquals(validResult, checkReaderWriterCompatibility(validReader, STRING_SCHEMA));    assertEquals(invalidResult, checkReaderWriterCompatibility(INT_SCHEMA, STRING_SCHEMA));}
4e639b32dee01f9ecc5e829fac54637f7515cad545356a57dd642665a34e39ac
testUnionReaderWriterSubsetIncompatibility
public void testUnionReaderWriterSubsetIncompatibility()
{    final Schema unionWriter = Schema.createUnion(list(INT_SCHEMA, STRING_SCHEMA, LONG_SCHEMA));    final Schema unionReader = Schema.createUnion(list(INT_SCHEMA, STRING_SCHEMA));    final SchemaPairCompatibility result = checkReaderWriterCompatibility(unionReader, unionWriter);    assertEquals(SchemaCompatibilityType.INCOMPATIBLE, result.getType());}
8b00712b61555f714b137ff20c28ac897e87e401fb9c360c6cd816acc178c2ed
validateIncompatibleSchemas
public static void validateIncompatibleSchemas(Schema reader, Schema writer, SchemaIncompatibilityType incompatibility, String message, String location)
{    validateIncompatibleSchemas(reader, writer, Collections.singletonList(incompatibility), Collections.singletonList(message), Collections.singletonList(location));}
b6c319ab30a8773909df5ac64e3c5f8279d76426422cb1c5d2146a80efc58e33
validateIncompatibleSchemas
public static void validateIncompatibleSchemas(Schema reader, Schema writer, List<SchemaIncompatibilityType> incompatibilityTypes, List<String> messages, List<String> locations)
{    SchemaPairCompatibility compatibility = checkReaderWriterCompatibility(reader, writer);    SchemaCompatibilityResult compatibilityResult = compatibility.getResult();    assertEquals(reader, compatibility.getReader());    assertEquals(writer, compatibility.getWriter());    assertEquals(SchemaCompatibilityType.INCOMPATIBLE, compatibilityResult.getCompatibility());    assertEquals(incompatibilityTypes.size(), compatibilityResult.getIncompatibilities().size());    for (int i = 0; i < incompatibilityTypes.size(); i++) {        Incompatibility incompatibility = compatibilityResult.getIncompatibilities().get(i);        assertSchemaContains(incompatibility.getReaderFragment(), reader);        assertSchemaContains(incompatibility.getWriterFragment(), writer);        assertEquals(incompatibilityTypes.get(i), incompatibility.getType());        assertEquals(messages.get(i), incompatibility.getMessage());        assertEquals(locations.get(i), incompatibility.getLocation());    }    String description = String.format("Data encoded using writer schema:%n%s%n" + "will or may fail to decode using reader schema:%n%s%n", writer.toString(true), reader.toString(true));    assertEquals(description, compatibility.getDescription());}
ea638d8ddb03d4e9a251c78303e633d0f32b969447c0a4794fe55ee9fc8d1c69
testReaderWriterCompatibility
public void testReaderWriterCompatibility()
{    for (ReaderWriter readerWriter : COMPATIBLE_READER_WRITER_TEST_CASES) {        final Schema reader = readerWriter.getReader();        final Schema writer = readerWriter.getWriter();        LOG.debug("Testing compatibility of reader {} with writer {}.", reader, writer);        final SchemaPairCompatibility result = checkReaderWriterCompatibility(reader, writer);        assertEquals(String.format("Expecting reader %s to be compatible with writer %s, but tested incompatible.", reader, writer), SchemaCompatibilityType.COMPATIBLE, result.getType());    }}
609bc53c26c1611df5d71785c0fd210d472072777ab448c35ffef5da7ed45e8d
getReaderSchema
public Schema getReaderSchema()
{    return mReaderSchema;}
ed3c0ab53c4805f275920fe7ad5d6189de4ea944c88d3ed82ef2df2dd2523e14
getWriterSchema
public Schema getWriterSchema()
{    return mWriterSchema;}
10acbd41cfd99d832235a7119bd79be8e640d0be65618448c909209b402f5185
getDatum
public Object getDatum()
{    return mDatum;}
74033c2914e06318a6676f35789d00274e23ba993396d9bf84e92ba0422dec45
getDecodedDatum
public Object getDecodedDatum()
{    return mDecodedDatum;}
b89a42d883ce10680e93a05a824ffe754b0712f9a4e6e6daeb73e7a324c98e2d
testReaderWriterDecodingCompatibility
public void testReaderWriterDecodingCompatibility() throws Exception
{    for (DecodingTestCase testCase : DECODING_COMPATIBILITY_TEST_CASES) {        final Schema readerSchema = testCase.getReaderSchema();        final Schema writerSchema = testCase.getWriterSchema();        final Object datum = testCase.getDatum();        final Object expectedDecodedDatum = testCase.getDecodedDatum();        LOG.debug("Testing incompatibility of reader {} with writer {}.", readerSchema, writerSchema);        LOG.debug("Encode datum {} with writer {}.", datum, writerSchema);        final ByteArrayOutputStream baos = new ByteArrayOutputStream();        final Encoder encoder = EncoderFactory.get().binaryEncoder(baos, null);        final DatumWriter<Object> datumWriter = new GenericDatumWriter<>(writerSchema);        datumWriter.write(datum, encoder);        encoder.flush();        LOG.debug("Decode datum {} whose writer is {} with reader {}.", datum, writerSchema, readerSchema);        final byte[] bytes = baos.toByteArray();        final Decoder decoder = DecoderFactory.get().resolvingDecoder(writerSchema, readerSchema, DecoderFactory.get().binaryDecoder(bytes, null));        final DatumReader<Object> datumReader = new GenericDatumReader<>(readerSchema);        final Object decodedDatum = datumReader.read(null, decoder);        assertEquals(String.format("Expecting decoded value %s when decoding value %s whose writer schema is %s " + "using reader schema %s, but value was %s.", expectedDecodedDatum, datum, writerSchema, readerSchema, decodedDatum), expectedDecodedDatum, decodedDatum);    }}
f4cdb83d3b638a5d619cd5fc19c3721c4e6ce4a4066791ef96605a9e30df5215
asDeqeue
 Deque<String> asDeqeue(String... args)
{    List<String> x = Arrays.asList(args);    Collections.reverse(x);    Deque<String> dq = new ArrayDeque<>(x);    return dq;}
a467bf1d8aca1608e9507709f61d1b9161ccfb9ff90c9e66fbca8a3ac20a5904
testEnumDefaultNotAppliedWhenWriterFieldMissing
public void testEnumDefaultNotAppliedWhenWriterFieldMissing() throws Exception
{    expectedException.expect(AvroTypeException.class);    expectedException.expectMessage("Found Record1, expecting Record1, missing required field field1");    Schema writerSchema = SchemaBuilder.record("Record1").fields().name("field2").type(ENUM2_AB_SCHEMA).noDefault().endRecord();    Schema readerSchema = SchemaBuilder.record("Record1").fields().name("field1").type(ENUM_AB_ENUM_DEFAULT_A_SCHEMA).noDefault().endRecord();    GenericRecord datum = new GenericData.Record(writerSchema);    datum.put("field2", new GenericData.EnumSymbol(writerSchema, "B"));    serializeWithWriterThenDeserializeWithReader(writerSchema, datum, readerSchema);}
53432911df72b6cf5c5d820348cac7296d50d876bcee778706948421d8a31126
testEnumDefaultAppliedWhenNoFieldDefaultDefined
public void testEnumDefaultAppliedWhenNoFieldDefaultDefined() throws Exception
{    Schema writerSchema = SchemaBuilder.record("Record1").fields().name("field1").type(ENUM_ABC_ENUM_DEFAULT_A_SCHEMA).noDefault().endRecord();    Schema readerSchema = SchemaBuilder.record("Record1").fields().name("field1").type(ENUM_AB_ENUM_DEFAULT_A_SCHEMA).noDefault().endRecord();    GenericRecord datum = new GenericData.Record(writerSchema);    datum.put("field1", new GenericData.EnumSymbol(writerSchema, "C"));    GenericRecord decodedDatum = serializeWithWriterThenDeserializeWithReader(writerSchema, datum, readerSchema);        assertEquals("A", decodedDatum.get("field1").toString());}
3203bc1a8ae0364644ff2db499eeced7b1c4bc0d2c9139033bab67332e3ab362
testEnumDefaultNotAppliedWhenCompatibleSymbolIsFound
public void testEnumDefaultNotAppliedWhenCompatibleSymbolIsFound() throws Exception
{    Schema writerSchema = SchemaBuilder.record("Record1").fields().name("field1").type(ENUM_ABC_ENUM_DEFAULT_A_SCHEMA).noDefault().endRecord();    Schema readerSchema = SchemaBuilder.record("Record1").fields().name("field1").type(ENUM_AB_ENUM_DEFAULT_A_SCHEMA).noDefault().endRecord();    GenericRecord datum = new GenericData.Record(writerSchema);    datum.put("field1", new GenericData.EnumSymbol(writerSchema, "B"));    GenericRecord decodedDatum = serializeWithWriterThenDeserializeWithReader(writerSchema, datum, readerSchema);    assertEquals("B", decodedDatum.get("field1").toString());}
808e00768fb49e4d4dc9bfe5c2b8927cecc4b9b75bd42325447d496524f9735f
testEnumDefaultAppliedWhenFieldDefaultDefined
public void testEnumDefaultAppliedWhenFieldDefaultDefined() throws Exception
{    Schema writerSchema = SchemaBuilder.record("Record1").fields().name("field1").type(ENUM_ABC_ENUM_DEFAULT_A_SCHEMA).noDefault().endRecord();    Schema readerSchema = SchemaBuilder.record("Record1").fields().name("field1").type(ENUM_AB_ENUM_DEFAULT_A_SCHEMA).withDefault("B").endRecord();    GenericRecord datum = new GenericData.Record(writerSchema);    datum.put("field1", new GenericData.EnumSymbol(writerSchema, "C"));    GenericRecord decodedDatum = serializeWithWriterThenDeserializeWithReader(writerSchema, datum, readerSchema);        assertEquals("A", decodedDatum.get("field1").toString());}
bfe927313017206e966d771040c980fd284e186b93f7edc7b0fa9f65f50533ac
testFieldDefaultNotAppliedForUnknownSymbol
public void testFieldDefaultNotAppliedForUnknownSymbol() throws Exception
{    expectedException.expect(AvroTypeException.class);    expectedException.expectMessage("No match for C");    Schema writerSchema = SchemaBuilder.record("Record1").fields().name("field1").type(ENUM1_ABC_SCHEMA).noDefault().endRecord();    Schema readerSchema = SchemaBuilder.record("Record1").fields().name("field1").type(ENUM1_AB_SCHEMA).withDefault("A").endRecord();    GenericRecord datum = new GenericData.Record(writerSchema);    datum.put("field1", new GenericData.EnumSymbol(writerSchema, "C"));    serializeWithWriterThenDeserializeWithReader(writerSchema, datum, readerSchema);}
e6b4e642b6f5dc7f12f299aaa86b26d24a11912ee3e81432648870c25e5d0aee
serializeWithWriterThenDeserializeWithReader
private GenericRecord serializeWithWriterThenDeserializeWithReader(Schema writerSchema, GenericRecord datum, Schema readerSchema) throws Exception
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    Encoder encoder = EncoderFactory.get().binaryEncoder(baos, null);    DatumWriter<Object> datumWriter = new GenericDatumWriter<>(writerSchema);    datumWriter.write(datum, encoder);    encoder.flush();    byte[] bytes = baos.toByteArray();    Decoder decoder = DecoderFactory.get().resolvingDecoder(writerSchema, readerSchema, DecoderFactory.get().binaryDecoder(bytes, null));    DatumReader<Object> datumReader = new GenericDatumReader<>(readerSchema);    return (GenericRecord) datumReader.read(null, decoder);}
db254bc51571d8d7d80a984227485f282b6a1318b1c3335f54deaa7b1df4faf7
data
public static Iterable<Object[]> data()
{    Object[][] fields = {     { FIXED_4_BYTES, FIXED_8_BYTES, "expected: 8, found: 4", "/size" }, { FIXED_8_BYTES, FIXED_4_BYTES, "expected: 4, found: 8", "/size" }, { A_DINT_B_DFIXED_8_BYTES_RECORD1, A_DINT_B_DFIXED_4_BYTES_RECORD1, "expected: 4, found: 8", "/fields/1/type/size" }, { A_DINT_B_DFIXED_4_BYTES_RECORD1, A_DINT_B_DFIXED_8_BYTES_RECORD1, "expected: 8, found: 4", "/fields/1/type/size" } };    return Arrays.asList(fields);}
bc167e28b465e0123366883330008973c0f67f71f45dddca8a1b2bff665a5a7b
testFixedSizeMismatchSchemas
public void testFixedSizeMismatchSchemas() throws Exception
{    validateIncompatibleSchemas(reader, writer, SchemaIncompatibilityType.FIXED_SIZE_MISMATCH, details, location);}
db254bc51571d8d7d80a984227485f282b6a1318b1c3335f54deaa7b1df4faf7
data
public static Iterable<Object[]> data()
{    Object[][] fields = {     { ENUM1_AB_SCHEMA, ENUM1_ABC_SCHEMA, "[C]", "/symbols" }, { ENUM1_BC_SCHEMA, ENUM1_ABC_SCHEMA, "[A]", "/symbols" }, { RECORD1_WITH_ENUM_AB, RECORD1_WITH_ENUM_ABC, "[C]", "/fields/0/type/symbols" } };    return Arrays.asList(fields);}
ea69cf06219e3b1a657df3718fd3c44e5d7a20b0643449215adfdd70fe224794
testTypeMismatchSchemas
public void testTypeMismatchSchemas() throws Exception
{    validateIncompatibleSchemas(reader, writer, SchemaIncompatibilityType.MISSING_ENUM_SYMBOLS, details, location);}
db254bc51571d8d7d80a984227485f282b6a1318b1c3335f54deaa7b1df4faf7
data
public static Iterable<Object[]> data()
{    Object[][] fields = {     { INT_UNION_SCHEMA, INT_STRING_UNION_SCHEMA, Collections.singletonList("reader union lacking writer type: STRING"), Collections.singletonList("/1") }, { STRING_UNION_SCHEMA, INT_STRING_UNION_SCHEMA, Collections.singletonList("reader union lacking writer type: INT"), Collections.singletonList("/0") }, { INT_UNION_SCHEMA, UNION_INT_RECORD1, Collections.singletonList("reader union lacking writer type: RECORD"), Collections.singletonList("/1") }, { INT_UNION_SCHEMA, UNION_INT_RECORD2, Collections.singletonList("reader union lacking writer type: RECORD"), Collections.singletonList("/1") },     { UNION_INT_RECORD1, UNION_INT_RECORD2, Collections.singletonList("reader union lacking writer type: RECORD"), Collections.singletonList("/1") }, { INT_UNION_SCHEMA, UNION_INT_ENUM1_AB, Collections.singletonList("reader union lacking writer type: ENUM"), Collections.singletonList("/1") }, { INT_UNION_SCHEMA, UNION_INT_FIXED_4_BYTES, Collections.singletonList("reader union lacking writer type: FIXED"), Collections.singletonList("/1") }, { INT_UNION_SCHEMA, UNION_INT_BOOLEAN, Collections.singletonList("reader union lacking writer type: BOOLEAN"), Collections.singletonList("/1") }, { INT_UNION_SCHEMA, LONG_UNION_SCHEMA, Collections.singletonList("reader union lacking writer type: LONG"), Collections.singletonList("/0") }, { INT_UNION_SCHEMA, FLOAT_UNION_SCHEMA, Collections.singletonList("reader union lacking writer type: FLOAT"), Collections.singletonList("/0") }, { INT_UNION_SCHEMA, DOUBLE_UNION_SCHEMA, Collections.singletonList("reader union lacking writer type: DOUBLE"), Collections.singletonList("/0") }, { INT_UNION_SCHEMA, BYTES_UNION_SCHEMA, Collections.singletonList("reader union lacking writer type: BYTES"), Collections.singletonList("/0") }, { INT_UNION_SCHEMA, UNION_INT_ARRAY_INT, Collections.singletonList("reader union lacking writer type: ARRAY"), Collections.singletonList("/1") }, { INT_UNION_SCHEMA, UNION_INT_MAP_INT, Collections.singletonList("reader union lacking writer type: MAP"), Collections.singletonList("/1") }, { INT_UNION_SCHEMA, UNION_INT_NULL, Collections.singletonList("reader union lacking writer type: NULL"), Collections.singletonList("/1") }, { INT_UNION_SCHEMA, INT_LONG_FLOAT_DOUBLE_UNION_SCHEMA, asList("reader union lacking writer type: LONG", "reader union lacking writer type: FLOAT", "reader union lacking writer type: DOUBLE"), asList("/1", "/2", "/3") }, { A_DINT_B_DINT_UNION_RECORD1, A_DINT_B_DINT_STRING_UNION_RECORD1, Collections.singletonList("reader union lacking writer type: STRING"), Collections.singletonList("/fields/1/type/1") } };    return Arrays.asList(fields);}
aa9ad8df67c4e9311d41daa1c4a442246f2f9673f5d066ddfefb91a97ab2617c
testMissingUnionBranch
public void testMissingUnionBranch() throws Exception
{    List<SchemaIncompatibilityType> types = Collections.nCopies(details.size(), SchemaIncompatibilityType.MISSING_UNION_BRANCH);    validateIncompatibleSchemas(reader, writer, types, details, location);}
4690cc75f2267616c8658c93dfb83f93e84565b6589640aafeaf32e76a946881
testMultipleIncompatibilities
public void testMultipleIncompatibilities() throws Exception
{    Schema reader = SchemaBuilder.record("base").fields().name("check_enum_symbols_field").type().enumeration("check_enum_symbols_type").symbols("A", "C").noDefault().name("check_enum_name_field").type().enumeration("check_enum_name_type").symbols("A", "B", "C", "D").noDefault().name("type_mismatch_field").type().stringType().noDefault().name("sub_record").type().record("sub_record_type").fields().name("identical_1_field").type().longType().longDefault(42L).name("extra_no_default_field").type().longType().noDefault().name("fixed_length_mismatch_field").type().fixed("fixed_length_mismatch_type").size(4).noDefault().name("union_missing_branches_field").type().unionOf().booleanType().endUnion().noDefault().name("reader_union_does_not_support_type_field").type().unionOf().booleanType().endUnion().noDefault().name("record_fqn_mismatch_field").type().record("recordA").namespace("not_nsA").fields().name("A_field_0").type().booleanType().booleanDefault(true).name("array_type_mismatch_field").type().array().items().stringType().noDefault().endRecord().noDefault().endRecord().noDefault().endRecord();    Schema writer = SchemaBuilder.record("base").fields().name("check_enum_symbols_field").type().enumeration("check_enum_symbols_type").symbols("A", "B", "C", "D").noDefault().name("check_enum_name_field").type().enumeration("check_enum_name_type_ERR").symbols("A", "B", "C", "D").noDefault().name("type_mismatch_field").type().longType().noDefault().name("sub_record").type().record("sub_record_type").fields().name("identical_1_field").type().longType().longDefault(42L).name("fixed_length_mismatch_field").type().fixed("fixed_length_mismatch_type").size(8).noDefault().name("union_missing_branches_field").type().unionOf().booleanType().and().doubleType().and().stringType().endUnion().noDefault().name("reader_union_does_not_support_type_field").type().longType().noDefault().name("record_fqn_mismatch_field").type().record("recordA").namespace("nsA").fields().name("A_field_0").type().booleanType().booleanDefault(true).name("array_type_mismatch_field").type().array().items().booleanType().noDefault().endRecord().noDefault().endRecord().noDefault().endRecord();    List<SchemaIncompatibilityType> types = Arrays.asList(SchemaIncompatibilityType.MISSING_ENUM_SYMBOLS, SchemaIncompatibilityType.NAME_MISMATCH, SchemaIncompatibilityType.TYPE_MISMATCH, SchemaIncompatibilityType.READER_FIELD_MISSING_DEFAULT_VALUE, SchemaIncompatibilityType.FIXED_SIZE_MISMATCH, SchemaIncompatibilityType.MISSING_UNION_BRANCH, SchemaIncompatibilityType.MISSING_UNION_BRANCH, SchemaIncompatibilityType.MISSING_UNION_BRANCH, SchemaIncompatibilityType.TYPE_MISMATCH);    List<String> details = Arrays.asList("[B, D]", "expected: check_enum_name_type_ERR", "reader type: STRING not compatible with writer type: LONG", "extra_no_default_field", "expected: 8, found: 4", "reader union lacking writer type: DOUBLE", "reader union lacking writer type: STRING", "reader union lacking writer type: LONG", "reader type: STRING not compatible with writer type: BOOLEAN");    List<String> location = Arrays.asList("/fields/0/type/symbols", "/fields/1/type/name", "/fields/2/type", "/fields/3/type/fields/1", "/fields/3/type/fields/2/type/size", "/fields/3/type/fields/3/type/1", "/fields/3/type/fields/3/type/2", "/fields/3/type/fields/4/type", "/fields/3/type/fields/5/type/fields/1/type/items");    validateIncompatibleSchemas(reader, writer, types, details, location);}
db254bc51571d8d7d80a984227485f282b6a1318b1c3335f54deaa7b1df4faf7
data
public static Iterable<Object[]> data()
{    Object[][] fields = {     { ENUM1_AB_SCHEMA, ENUM2_AB_SCHEMA, "expected: Enum2", "/name" }, { EMPTY_RECORD2, EMPTY_RECORD1, "expected: Record1", "/name" }, { FIXED_4_BYTES, FIXED_4_ANOTHER_NAME, "expected: AnotherName", "/name" }, { A_DINT_B_DENUM_1_RECORD1, A_DINT_B_DENUM_2_RECORD1, "expected: Enum2", "/fields/1/type/name" } };    return Arrays.asList(fields);}
014f530c8779643ba6dc1e80c92231b6a98ed827346f0dfba6073ae29fd95a11
testNameMismatchSchemas
public void testNameMismatchSchemas() throws Exception
{    validateIncompatibleSchemas(reader, writer, SchemaIncompatibilityType.NAME_MISMATCH, details, location);}
db254bc51571d8d7d80a984227485f282b6a1318b1c3335f54deaa7b1df4faf7
data
public static Iterable<Object[]> data()
{    Object[][] fields = {     { A_INT_RECORD1, EMPTY_RECORD1, "a", "/fields/0" }, { A_INT_B_DINT_RECORD1, EMPTY_RECORD1, "a", "/fields/0" } };    return Arrays.asList(fields);}
c3792a5a492d5bc03309ba88578b5b0130431860dd1aa96c528d11b18eef259a
testReaderFieldMissingDefaultValueSchemas
public void testReaderFieldMissingDefaultValueSchemas() throws Exception
{    validateIncompatibleSchemas(reader, writer, SchemaIncompatibilityType.READER_FIELD_MISSING_DEFAULT_VALUE, details, location);}
db254bc51571d8d7d80a984227485f282b6a1318b1c3335f54deaa7b1df4faf7
data
public static Iterable<Object[]> data()
{    Object[][] fields = {     { NULL_SCHEMA, INT_SCHEMA, "reader type: NULL not compatible with writer type: INT", "/" }, { NULL_SCHEMA, LONG_SCHEMA, "reader type: NULL not compatible with writer type: LONG", "/" }, { BOOLEAN_SCHEMA, INT_SCHEMA, "reader type: BOOLEAN not compatible with writer type: INT", "/" }, { INT_SCHEMA, NULL_SCHEMA, "reader type: INT not compatible with writer type: NULL", "/" }, { INT_SCHEMA, BOOLEAN_SCHEMA, "reader type: INT not compatible with writer type: BOOLEAN", "/" }, { INT_SCHEMA, LONG_SCHEMA, "reader type: INT not compatible with writer type: LONG", "/" }, { INT_SCHEMA, FLOAT_SCHEMA, "reader type: INT not compatible with writer type: FLOAT", "/" }, { INT_SCHEMA, DOUBLE_SCHEMA, "reader type: INT not compatible with writer type: DOUBLE", "/" }, { LONG_SCHEMA, FLOAT_SCHEMA, "reader type: LONG not compatible with writer type: FLOAT", "/" }, { LONG_SCHEMA, DOUBLE_SCHEMA, "reader type: LONG not compatible with writer type: DOUBLE", "/" }, { FLOAT_SCHEMA, DOUBLE_SCHEMA, "reader type: FLOAT not compatible with writer type: DOUBLE", "/" }, { DOUBLE_SCHEMA, STRING_SCHEMA, "reader type: DOUBLE not compatible with writer type: STRING", "/" }, { FIXED_4_BYTES, STRING_SCHEMA, "reader type: FIXED not compatible with writer type: STRING", "/" }, { STRING_SCHEMA, BOOLEAN_SCHEMA, "reader type: STRING not compatible with writer type: BOOLEAN", "/" }, { STRING_SCHEMA, INT_SCHEMA, "reader type: STRING not compatible with writer type: INT", "/" }, { BYTES_SCHEMA, NULL_SCHEMA, "reader type: BYTES not compatible with writer type: NULL", "/" }, { BYTES_SCHEMA, INT_SCHEMA, "reader type: BYTES not compatible with writer type: INT", "/" }, { A_INT_RECORD1, INT_SCHEMA, "reader type: RECORD not compatible with writer type: INT", "/" }, { INT_ARRAY_SCHEMA, LONG_ARRAY_SCHEMA, "reader type: INT not compatible with writer type: LONG", "/items" }, { INT_MAP_SCHEMA, INT_ARRAY_SCHEMA, "reader type: MAP not compatible with writer type: ARRAY", "/" }, { INT_ARRAY_SCHEMA, INT_MAP_SCHEMA, "reader type: ARRAY not compatible with writer type: MAP", "/" }, { INT_MAP_SCHEMA, LONG_MAP_SCHEMA, "reader type: INT not compatible with writer type: LONG", "/values" }, { INT_SCHEMA, ENUM2_AB_SCHEMA, "reader type: INT not compatible with writer type: ENUM", "/" }, { ENUM2_AB_SCHEMA, INT_SCHEMA, "reader type: ENUM not compatible with writer type: INT", "/" }, { FLOAT_SCHEMA, INT_LONG_FLOAT_DOUBLE_UNION_SCHEMA, "reader type: FLOAT not compatible with writer type: DOUBLE", "/" }, { LONG_SCHEMA, INT_FLOAT_UNION_SCHEMA, "reader type: LONG not compatible with writer type: FLOAT", "/" }, { INT_SCHEMA, INT_FLOAT_UNION_SCHEMA, "reader type: INT not compatible with writer type: FLOAT", "/" }, { INT_LIST_RECORD, LONG_LIST_RECORD, "reader type: INT not compatible with writer type: LONG", "/fields/0/type" }, { NULL_SCHEMA, INT_SCHEMA, "reader type: NULL not compatible with writer type: INT", "/" } };    return Arrays.asList(fields);}
ea69cf06219e3b1a657df3718fd3c44e5d7a20b0643449215adfdd70fe224794
testTypeMismatchSchemas
public void testTypeMismatchSchemas() throws Exception
{    validateIncompatibleSchemas(reader, writer, SchemaIncompatibilityType.TYPE_MISMATCH, details, location);}
cfcfa741b82b6402119e615eafdfffad08ddb9774df99732a782c99582d7687d
cases
public static List<Object[]> cases() throws IOException
{    return CaseFinder.find(data(), "canonical", new ArrayList<>());}
7f387e329d1e39482f03c39243ee3dc04d2855a43a519cdc7de085efddffcb5a
testCanonicalization
public void testCanonicalization() throws Exception
{    assertEquals(SchemaNormalization.toParsingForm(new Schema.Parser().parse(input)), expectedOutput);}
cfcfa741b82b6402119e615eafdfffad08ddb9774df99732a782c99582d7687d
cases
public static List<Object[]> cases() throws IOException
{    return CaseFinder.find(data(), "fingerprint", new ArrayList<>());}
7f387e329d1e39482f03c39243ee3dc04d2855a43a519cdc7de085efddffcb5a
testCanonicalization
public void testCanonicalization() throws Exception
{    Schema s = new Schema.Parser().parse(input);    long carefulFP = altFingerprint(SchemaNormalization.toParsingForm(s));    assertEquals(carefulFP, Long.parseLong(expectedOutput));    assertEqHex(carefulFP, SchemaNormalization.parsingFingerprint64(s));}
cfcfa741b82b6402119e615eafdfffad08ddb9774df99732a782c99582d7687d
cases
public static List<Object[]> cases() throws IOException
{    return CaseFinder.find(data(), "fingerprint", new ArrayList<>());}
7f387e329d1e39482f03c39243ee3dc04d2855a43a519cdc7de085efddffcb5a
testCanonicalization
public void testCanonicalization() throws Exception
{    Locale originalDefaultLocale = Locale.getDefault();    Locale.setDefault(Locale.forLanguageTag("tr"));    Schema s = new Schema.Parser().parse(input);    long carefulFP = altFingerprint(SchemaNormalization.toParsingForm(s));    assertEquals(carefulFP, Long.parseLong(expectedOutput));    assertEqHex(carefulFP, SchemaNormalization.parsingFingerprint64(s));    Locale.setDefault(originalDefaultLocale);}
d4f7a7ccedc53476c320a0680bccc4d4f65c65362fb78e7d7e8e071669eb3422
data
private static BufferedReader data() throws IOException
{    return Files.newBufferedReader(Paths.get(DATA_FILE), UTF_8);}
40dfe2ddf6326456a3247b2bb54501e54bb98dc0ee0734d396cc548bb6908aad
altFingerprint
public static long altFingerprint(String s)
{                        long tmp = altExtend(SchemaNormalization.EMPTY64, 64, ONE, s.getBytes(UTF_8));    return altExtend(SchemaNormalization.EMPTY64, 64, tmp, POSTFIX);}
105cb31d71876fd931180d91199b72403463773996ee7696d39c7b4281fa3546
altExtend
private static long altExtend(long poly, int degree, long fp, byte[] b)
{    final long overflowBit = 1L << (64 - degree);    for (byte b1 : b) {        for (int j = 1; j < 129; j = j << 1) {            boolean overflow = (0 != (fp & overflowBit));            fp >>>= 1;            if (0 != (j & b1))                                fp |= ONE;            if (overflow) {                                fp ^= poly;            }        }    }    return fp;}
822e09bc7a20bb51629770912c965d1ac38557b1e1a91ce2d339b2cd2904ef31
assertEqHex
private static void assertEqHex(long expected, long actual)
{    String m = format("0x%016x != 0x%016x", expected, actual);    assertTrue(m, expected == actual);}
c067f33ce19db6c73b94fe88e795000a4138606688d7fdcd295fe82af16a79e2
format
private static String format(String f, Object... args)
{    return (new Formatter()).format(f, args).toString();}
7caaf6e44f56f03c64859257e777dc26e4d64e31f0975cb9df7e81c29a04b681
getReader
public Schema getReader()
{    return mReader;}
db56f892dfd3ccbe02e1d06385cd26298e72a05b81990a86865b96790c64596a
getWriter
public Schema getWriter()
{    return mWriter;}
4c8f249424fd797740f0f504b5f0c44906781dd4961fa59182c2c1c8579857f8
list
 static ArrayList<E> list(E... elements)
{    final ArrayList<E> list = new ArrayList<>();    Collections.addAll(list, elements);    return list;}
934f2d7a1fc6b69f37c36871cb3d7e364570d6c682731195d915308b483fd8b0
assertSchemaContains
 static void assertSchemaContains(Schema schemaSubset, Schema original)
{    String subset = schemaSubset.toString(false);    String whole = original.toString(false);    assertTrue(String.format("Subset '%s' not found in '%s'", subset, whole), whole.contains(subset));}
76bc6ee2dbbf9295e5ed632acd560b2f1a1625e5cf7192efcc2cfa6323ef198d
testAllTypes
public void testAllTypes() throws SchemaValidationException
{    Schema s = SchemaBuilder.record("r").fields().requiredBoolean("boolF").requiredInt("intF").requiredLong("longF").requiredFloat("floatF").requiredDouble("doubleF").requiredString("stringF").requiredBytes("bytesF").name("fixedF1").type().fixed("F1").size(1).noDefault().name("enumF").type().enumeration("E1").symbols("S").noDefault().name("mapF").type().map().values().stringType().noDefault().name("arrayF").type().array().items().stringType().noDefault().name("recordF").type().record("inner").fields().name("f").type().intType().noDefault().endRecord().noDefault().optionalBoolean("boolO").endRecord();    testValidatorPasses(builder.mutualReadStrategy().validateLatest(), s, s);}
3b2a667fbf9c264c30adbd6b9b637edad453e2e6fa94b5adbb489098f56fe889
testReadOnePrior
public void testReadOnePrior() throws SchemaValidationException
{    testValidatorPasses(builder.canReadStrategy().validateLatest(), rec3, rec);    testValidatorPasses(builder.canReadStrategy().validateLatest(), rec5, rec3);    testValidatorFails(builder.canReadStrategy().validateLatest(), rec4, rec);}
5160d26d4cbda73f92bbee9377248f3b493e9caa9db3178c1217358a29cd7421
testReadAllPrior
public void testReadAllPrior() throws SchemaValidationException
{    testValidatorPasses(builder.canReadStrategy().validateAll(), rec3, rec, rec2);    testValidatorFails(builder.canReadStrategy().validateAll(), rec4, rec, rec2, rec3);    testValidatorFails(builder.canReadStrategy().validateAll(), rec5, rec, rec2, rec3);}
1f415dc295a1b45911401f25c924602d7fb2ab09d61525df015131ec2f0bad6c
testOnePriorCanRead
public void testOnePriorCanRead() throws SchemaValidationException
{    testValidatorPasses(builder.canBeReadStrategy().validateLatest(), rec, rec3);    testValidatorFails(builder.canBeReadStrategy().validateLatest(), rec, rec4);}
d3df08bfd5a1b2a5b5c89ba6af8c381e59b287a576424cf25b1c759f6012ff19
testAllPriorCanRead
public void testAllPriorCanRead() throws SchemaValidationException
{    testValidatorPasses(builder.canBeReadStrategy().validateAll(), rec, rec3, rec2);    testValidatorFails(builder.canBeReadStrategy().validateAll(), rec, rec4, rec3, rec2);}
101ee6a14a7e29f581cea2fe72f9ae1adf438a7b4a78c498738641922363b1f2
testOnePriorCompatible
public void testOnePriorCompatible() throws SchemaValidationException
{    testValidatorPasses(builder.mutualReadStrategy().validateLatest(), rec, rec3);    testValidatorFails(builder.mutualReadStrategy().validateLatest(), rec, rec4);}
a45696d3f5d74480ef2c41a28b13a6912b5108897f41bd0df5c089563edd4a19
testAllPriorCompatible
public void testAllPriorCompatible() throws SchemaValidationException
{    testValidatorPasses(builder.mutualReadStrategy().validateAll(), rec, rec3, rec2);    testValidatorFails(builder.mutualReadStrategy().validateAll(), rec, rec4, rec3, rec2);}
ee99cf620e8a85f7d954daf2c4b9e160ef285287a472b8a3f91b05547c6715c1
testInvalidBuild
public void testInvalidBuild()
{    builder.strategy(null).validateAll();}
841e67814c2c4a2c488d11b8dbe2f5c6351e48a84729ba11a19330430a9dc2e0
testReflectMatchStructure
public void testReflectMatchStructure() throws SchemaValidationException
{    testValidatorPasses(builder.canBeReadStrategy().validateAll(), circleSchemaDifferentNames, ReflectData.get().getSchema(Circle.class));}
6910947115b419b4e773fee314d52ce719ace35590e2a9dfce362f62d4322367
testReflectWithAllowNullMatchStructure
public void testReflectWithAllowNullMatchStructure() throws SchemaValidationException
{    testValidatorPasses(builder.canBeReadStrategy().validateAll(), circleSchemaDifferentNames, ReflectData.AllowNull.get().getSchema(Circle.class));}
ba6fc938a905068e9aeaf5856570499cd6f4c3c8202f61c8f9f02be31c0676ff
testUnionWithIncompatibleElements
public void testUnionWithIncompatibleElements() throws SchemaValidationException
{    Schema union1 = Schema.createUnion(Collections.singletonList(rec));    Schema union2 = Schema.createUnion(Collections.singletonList(rec4));    testValidatorFails(builder.canReadStrategy().validateAll(), union2, union1);}
bb831ad4bed0f0b1c0789d9fa8cc61ccc130ac3974fb0aad6378eb459626c9e2
testUnionWithCompatibleElements
public void testUnionWithCompatibleElements() throws SchemaValidationException
{    Schema union1 = Schema.createUnion(Collections.singletonList(rec));    Schema union2 = Schema.createUnion(Collections.singletonList(rec3));    testValidatorPasses(builder.canReadStrategy().validateAll(), union2, union1);}
3181df65d8b0e830f0460335c7fdee71fb7f0f46dc7fea3e96f960bec62d07c1
testSchemaCompatibilitySuccesses
public void testSchemaCompatibilitySuccesses() throws SchemaValidationException
{        for (ReaderWriter tc : COMPATIBLE_READER_WRITER_TEST_CASES) {        testValidatorPasses(builder.canReadStrategy().validateAll(), tc.getReader(), tc.getWriter());    }}
b501b20ee8f0055aa51bf5ed1a381efce17f2b329fe4892619cd112acec86e07
testSchemaCompatibilityFailures
public void testSchemaCompatibilityFailures() throws SchemaValidationException
{    for (ReaderWriter tc : INCOMPATIBLE_READER_WRITER_TEST_CASES) {        Schema reader = tc.getReader();        Schema writer = tc.getWriter();        expectedException.expect(SchemaValidationException.class);        expectedException.expectMessage("Unable to read schema: \n" + writer.toString());        SchemaValidator validator = builder.canReadStrategy().validateAll();        validator.validate(reader, Collections.singleton(writer));    }}
13a3905f5ff30654d34e3db6b3ed67e0c4b117916a3a3badb35e6e8eef6b0893
testValidatorPasses
private void testValidatorPasses(SchemaValidator validator, Schema schema, Schema... prev) throws SchemaValidationException
{    ArrayList<Schema> prior = new ArrayList<>();    for (int i = prev.length - 1; i >= 0; i--) {        prior.add(prev[i]);    }    validator.validate(schema, prior);}
24cc098abb1fba268ace79e579fafdcd37d35d119af1a25705bd70e53cdad5b4
testValidatorFails
private void testValidatorFails(SchemaValidator validator, Schema schemaFails, Schema... prev) throws SchemaValidationException
{    ArrayList<Schema> prior = new ArrayList<>();    for (int i = prev.length - 1; i >= 0; i--) {        prior.add(prev[i]);    }    boolean threw = false;    try {                validator.validate(schemaFails, prior);    } catch (SchemaValidationException sve) {        threw = true;    }    Assert.assertTrue(threw);}
6053ff48c6fbd382e2c5e2092c81761ceace141a434f9e7e1b1dce49baca87a2
testRecursiveSchemaValidation
public void testRecursiveSchemaValidation() throws SchemaValidationException
{        final SchemaValidator backwardValidator = builder.canReadStrategy().validateLatest();    backwardValidator.validate(recursiveSchema, Collections.singletonList(recursiveSchema));}
74c609d4cf870d9229edcac60f6ffd07f20be824b3d7f70ce1906cdadbc141ef
testSelfReferenceInUnion
public void testSelfReferenceInUnion()
{    Schema schema = new Schema.Parser().parse(SIMPLE_BINARY_TREE);    Field leftField = schema.getField("left");    assertEquals(JsonProperties.NULL_VALUE, leftField.defaultVal());    final Schema leftFieldSchema = leftField.schema();    assertEquals(Type.UNION, leftFieldSchema.getType());    assertEquals("null", leftFieldSchema.getTypes().get(0).getName());    assertEquals("Node", leftFieldSchema.getTypes().get(1).getName());    Field rightField = schema.getField("right");    assertEquals(JsonProperties.NULL_VALUE, rightField.defaultVal());    final Schema rightFieldSchema = rightField.schema();    assertEquals(Type.UNION, rightFieldSchema.getType());    assertEquals("null", rightFieldSchema.getTypes().get(0).getName());    assertEquals("Node", rightFieldSchema.getTypes().get(1).getName());}
01b4e52d46db752aff9b4fce52b527d5209f74b6980219a89054552d74e50cbb
testSelfReferenceInThreeUnion
public void testSelfReferenceInThreeUnion()
{    Schema schema = new Schema.Parser().parse(THREE_TYPE_UNION);    Field leftField = schema.getField("left");    assertEquals(JsonProperties.NULL_VALUE, leftField.defaultVal());    final Schema leftFieldSchema = leftField.schema();    assertEquals(Type.UNION, leftFieldSchema.getType());    assertEquals("null", leftFieldSchema.getTypes().get(0).getName());    assertEquals("string", leftFieldSchema.getTypes().get(1).getName());    assertEquals("Node", leftFieldSchema.getTypes().get(2).getName());    Field rightField = schema.getField("right");    assertEquals(JsonProperties.NULL_VALUE, rightField.defaultVal());    final Schema rightFieldSchema = rightField.schema();    assertEquals(Type.UNION, rightFieldSchema.getType());    assertEquals("null", rightFieldSchema.getTypes().get(0).getName());    assertEquals("string", rightFieldSchema.getTypes().get(1).getName());    assertEquals("Node", rightFieldSchema.getTypes().get(2).getName());}
64706bfcdc25a6308d11d702baacbf9dbac8176e7848be0e819da8d1859b6bdb
getClassSchema
public static org.apache.avro.Schema getClassSchema()
{    return SCHEMA$;}
1fa124aa67dc73ccd01002de70d29d68ea9dacd5d97cf4663025da360e9c4749
getSchema
public org.apache.avro.Schema getSchema()
{    return SCHEMA$;}
056f6946a476494cad3fe0612d15fc02bdb7ce2460e85433243bd27f98dc9120
find
public static List<Object[]> find(BufferedReader in, String label, List<Object[]> cases) throws IOException
{    if (!Pattern.matches(LABEL_REGEX, label))        throw new IllegalArgumentException("Bad case subcase label: " + label);    final String subcaseMarker = "<<" + label;    for (String line = in.readLine(); ; ) {                while (line != null && !line.startsWith(NEW_CASE_MARKER)) line = in.readLine();        if (line == null)            break;        String input;        input = processHereDoc(in, line);        if (label.equals(NEW_CASE_NAME)) {            cases.add(new Object[] { input, null });            line = in.readLine();            continue;        }                do {            line = in.readLine();        } while (line != null && (!line.startsWith(NEW_CASE_MARKER) && !line.startsWith(subcaseMarker)));        if (line == null || line.startsWith(NEW_CASE_MARKER))            continue;        String expectedOutput = processHereDoc(in, line);        cases.add(new Object[] { input, expectedOutput });    }    in.close();    return cases;}
e7f1131ed3d92f9e0bf9818c8bde955c4b80957f63174461c771a64d4a1d52ad
processHereDoc
private static String processHereDoc(BufferedReader in, String docStart) throws IOException
{    Matcher m = START_LINE_PATTERN.matcher(docStart);    if (!m.matches())        throw new IllegalArgumentException("Wasn't given the start of a heredoc (\"" + docStart + "\")");    String docName = m.group(1);        String singleLineText = m.group(2);    if (singleLineText.length() != 0) {        if (!singleLineText.startsWith(" "))            throw new IOException("Single-line heredoc missing initial space (\"" + docStart + "\")");        return singleLineText.substring(1);    }        StringBuilder result = new StringBuilder();    String line = in.readLine();    String prevLine = "";    boolean firstTime = true;    while (line != null && !line.equals(docName)) {        if (!firstTime)            result.append(prevLine).append('\n');        else            firstTime = false;        prevLine = line;        line = in.readLine();    }    if (line == null)        throw new IOException("Here document (" + docName + ") terminated by end-of-file.");    return result.append(prevLine).toString();}
aeadebe095ba120a52249c0f5dd3144d50195950ea9d6d0f371a22139fd619f7
testToJsonNode
public void testToJsonNode()
{    assertEquals(null, toJsonNode(null));    assertEquals(NullNode.getInstance(), toJsonNode(JsonProperties.NULL_VALUE));    assertEquals(BooleanNode.TRUE, toJsonNode(true));    assertEquals(IntNode.valueOf(1), toJsonNode(1));    assertEquals(LongNode.valueOf(2), toJsonNode(2L));    assertEquals(FloatNode.valueOf(1.0f), toJsonNode(1.0f));    assertEquals(DoubleNode.valueOf(2.0), toJsonNode(2.0));    assertEquals(TextNode.valueOf("\u0001\u0002"), toJsonNode(new byte[] { 1, 2 }));    assertEquals(TextNode.valueOf("a"), toJsonNode("a"));    assertEquals(TextNode.valueOf("UP"), toJsonNode(Direction.UP));    ArrayNode an = JsonNodeFactory.instance.arrayNode();    an.add(1);    assertEquals(an, toJsonNode(Collections.singletonList(1)));    ObjectNode on = JsonNodeFactory.instance.objectNode();    on.put("a", 1);    assertEquals(on, toJsonNode(Collections.singletonMap("a", 1)));}
e60ecaa88d33b1b60c19ea3936de43e0860e89b969b26555fffaaf05f8725605
testToObject
public void testToObject()
{    assertEquals(null, toObject(null));    assertEquals(JsonProperties.NULL_VALUE, toObject(NullNode.getInstance()));    assertEquals(true, toObject(BooleanNode.TRUE));    assertEquals(1, toObject(IntNode.valueOf(1)));    assertEquals(2L, toObject(IntNode.valueOf(2), Schema.create(Schema.Type.LONG)));    assertEquals(1.0f, toObject(DoubleNode.valueOf(1.0), Schema.create(Schema.Type.FLOAT)));    assertEquals(2.0, toObject(DoubleNode.valueOf(2.0)));    assertEquals(TextNode.valueOf("\u0001\u0002"), toJsonNode(new byte[] { 1, 2 }));    assertArrayEquals(new byte[] { 1, 2 }, (byte[]) toObject(TextNode.valueOf("\u0001\u0002"), Schema.create(Schema.Type.BYTES)));    assertEquals("a", toObject(TextNode.valueOf("a")));    assertEquals("UP", toObject(TextNode.valueOf("UP"), SchemaBuilder.enumeration("Direction").symbols("UP", "DOWN")));    ArrayNode an = JsonNodeFactory.instance.arrayNode();    an.add(1);    assertEquals(Collections.singletonList(1), toObject(an));    ObjectNode on = JsonNodeFactory.instance.objectNode();    on.put("a", 1);    assertEquals(Collections.singletonMap("a", 1), toObject(on));    assertEquals(Collections.singletonMap("a", 1L), toObject(on, SchemaBuilder.record("r").fields().requiredLong("a").endRecord()));    assertEquals(JsonProperties.NULL_VALUE, toObject(NullNode.getInstance(), SchemaBuilder.unionOf().nullType().and().intType().endUnion()));    assertEquals("a", toObject(TextNode.valueOf("a"), SchemaBuilder.unionOf().stringType().and().intType().endUnion()));}
cab82d9406efbd1077326977a4e7d301a9c863e4661a66d263d2fd7082a44aca
testOutput
public void testOutput() throws Exception
{    List<Object[]> result = new ArrayList<>();    CaseFinder.find(mk(input), label, result);    assertTrue(pr(result), eq(result, expectedOutput));}
18910abd4e22d5fe0068e41b791178acd31d35c1baf1c42a6d0798ac9bf9615c
testBadDocLabel1
public void testBadDocLabel1() throws Exception
{    List<Object[]> result = new ArrayList<>();    CaseFinder.find(mk("<<INPUT blah"), "", result);}
9c49faffece6a8890669858392c04072cd775a02aa3eb19c2ea538ae49b505f8
testBadDocLabel2
public void testBadDocLabel2() throws Exception
{    List<Object[]> result = new ArrayList<>();    CaseFinder.find(mk("<<INPUT blah"), "kill-er", result);}
54e0603bea9ea191751222c7fc05940fc1ca1d1680d9d3cce0020f828a577824
testBadSingleLineHeredoc
public void testBadSingleLineHeredoc() throws Exception
{    List<Object[]> result = new ArrayList<>();    CaseFinder.find(mk("<<INPUTblah"), "foo", result);}
84374e4addd08df968982a799df20500e5f487997024c0f7035d298d56cf7ae3
testUnterminatedHeredoc
public void testUnterminatedHeredoc() throws Exception
{    List<Object[]> result = new ArrayList<>();    CaseFinder.find(mk("<<INPUT"), "foo", result);}
b45be997c91f90dc4331fb0e90f6a4dce8bab77ac0ef9be39fc7211ed0ae1c22
mk
private static BufferedReader mk(String s)
{    return new BufferedReader(new StringReader(s));}
d61a56782741b49aebb6c0f9037d8b206b296a0498df8b7cb6614a6cf13d4414
pr
private static String pr(List<Object[]> t)
{    StringBuilder b = new StringBuilder();    b.append("{ ");    boolean firstTime = true;    for (Object[] p : t) {        if (!firstTime)            b.append(", ");        else            firstTime = false;        b.append("{ \"").append(p[0]).append("\", \"").append(p[1]).append("\" }");    }    b.append("}");    return b.toString();}
8ed5ca132169a89c7bddea9c648ed04fabb5ad39af803f2e666c18aa4bdea313
eq
private static boolean eq(List<Object[]> l1, List<Object[]> l2)
{    if (l1 == null || l2 == null)        return l1 == l2;    if (l1.size() != l2.size())        return false;    for (int i = 0; i < l1.size(); i++) if (!Arrays.equals(l1.get(i), l2.get(i)))        return false;    return true;}
bf63d5794960b7dca8235778b42961952e9a113c60a2e66a267c5fbe1e956578
testByteConstructor
public void testByteConstructor() throws Exception
{    byte[] bs = "Foo".getBytes(StandardCharsets.UTF_8);    Utf8 u = new Utf8(bs);    assertEquals(bs.length, u.getByteLength());    for (int i = 0; i < bs.length; i++) {        assertEquals(bs[i], u.getBytes()[i]);    }}
42706b3c63e7190c1d35433b95300e988e512cd13fee11cf65cfa28818b06a18
testArrayReusedWhenLargerThanRequestedSize
public void testArrayReusedWhenLargerThanRequestedSize()
{    byte[] bs = "55555".getBytes(StandardCharsets.UTF_8);    Utf8 u = new Utf8(bs);    assertEquals(5, u.getByteLength());    byte[] content = u.getBytes();    u.setByteLength(3);    assertEquals(3, u.getByteLength());    assertSame(content, u.getBytes());    u.setByteLength(4);    assertEquals(4, u.getByteLength());    assertSame(content, u.getBytes());}
505831e412aa85a32f6025a88d5853981145d95c5a9acfae4f042b96d22e05c9
visitTerminal
public SchemaVisitorAction visitTerminal(final Schema terminal)
{    Schema.Type type = terminal.getType();    Schema newSchema;    switch(type) {                case RECORD:        case ARRAY:        case MAP:        case UNION:            if (!replace.containsKey(terminal)) {                throw new IllegalStateException("Schema " + terminal + " must be already processed");            }            return SchemaVisitorAction.CONTINUE;        case BOOLEAN:        case BYTES:        case DOUBLE:        case FLOAT:        case INT:        case LONG:        case NULL:        case STRING:            newSchema = Schema.create(type);            break;        case ENUM:            newSchema = Schema.createEnum(terminal.getName(), terminal.getDoc(), terminal.getNamespace(), terminal.getEnumSymbols(), terminal.getEnumDefault());            break;        case FIXED:            newSchema = Schema.createFixed(terminal.getName(), terminal.getDoc(), terminal.getNamespace(), terminal.getFixedSize());            break;        default:            throw new IllegalStateException("Unsupported schema " + terminal);    }    copyAllProperties(terminal, newSchema);    replace.put(terminal, newSchema);    return SchemaVisitorAction.CONTINUE;}
b587d81ab28b4acec317899460496c51c204a219f8db6c384be67b828df2bf8f
copyAllProperties
public static void copyAllProperties(final Schema first, final Schema second)
{    Schemas.copyLogicalTypes(first, second);    Schemas.copyAliases(first, second);    Schemas.copyProperties(first, second);}
67723d4dcc423240173ca230ea9f84ac71b773ba0640c3999bf45608100239b9
copyAllProperties
public static void copyAllProperties(final Field first, final Field second)
{    Schemas.copyAliases(first, second);    Schemas.copyProperties(first, second);}
3dedbf1fe8d326434cfd67954fa1f4ad37b672f39b2adecf0827c0854d45b252
visitNonTerminal
public SchemaVisitorAction visitNonTerminal(final Schema nt)
{    Schema.Type type = nt.getType();    if (type == Schema.Type.RECORD) {        if (SchemaResolver.isUnresolvedSchema(nt)) {                                    final String unresolvedSchemaName = SchemaResolver.getUnresolvedSchemaName(nt);            Schema resSchema = symbolTable.apply(unresolvedSchemaName);            if (resSchema == null) {                throw new AvroTypeException("Unable to resolve " + unresolvedSchemaName);            }            Schema replacement = replace.get(resSchema);            if (replacement == null) {                replace.put(nt, Schemas.visit(resSchema, new ResolvingVisitor(resSchema, new IdentityHashMap<>(), symbolTable)));            } else {                replace.put(nt, replacement);            }        } else {                        Schema newSchema = Schema.createRecord(nt.getName(), nt.getDoc(), nt.getNamespace(), nt.isError());            copyAllProperties(nt, newSchema);            replace.put(nt, newSchema);        }    }    return SchemaVisitorAction.CONTINUE;}
b7d6c2c0c98c752500c74a2a6ad0d8528f06d1a1dec1070d2f9a83dbb9fcae0b
afterVisitNonTerminal
public SchemaVisitorAction afterVisitNonTerminal(final Schema nt)
{    Schema.Type type = nt.getType();    Schema newSchema;    switch(type) {        case RECORD:            if (!SchemaResolver.isUnresolvedSchema(nt)) {                newSchema = replace.get(nt);                List<Schema.Field> fields = nt.getFields();                List<Schema.Field> newFields = new ArrayList<>(fields.size());                for (Schema.Field field : fields) {                    Schema.Field newField = new Schema.Field(field.name(), replace.get(field.schema()), field.doc(), field.defaultVal(), field.order());                    copyAllProperties(field, newField);                    newFields.add(newField);                }                newSchema.setFields(newFields);            }            return SchemaVisitorAction.CONTINUE;        case UNION:            List<Schema> types = nt.getTypes();            List<Schema> newTypes = new ArrayList<>(types.size());            for (Schema sch : types) {                newTypes.add(replace.get(sch));            }            newSchema = Schema.createUnion(newTypes);            break;        case ARRAY:            newSchema = Schema.createArray(replace.get(nt.getElementType()));            break;        case MAP:            newSchema = Schema.createMap(replace.get(nt.getValueType()));            break;        default:            throw new IllegalStateException("Illegal type " + type + ", schema " + nt);    }    copyAllProperties(nt, newSchema);    replace.put(nt, newSchema);    return SchemaVisitorAction.CONTINUE;}
53c9a70a6fd530b7bae94d81656a887d06af4431acc656fee461a450ed3f0c4b
get
public Schema get()
{    return replace.get(root);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "ResolvingVisitor{" + "replace=" + replace + ", symbolTable=" + symbolTable + ", root=" + root + '}';}
b03fc8e1383a1cbd92ae273a8f129d693f8c5314df85b5b126ff111bd6deff3f
unresolvedSchema
 static Schema unresolvedSchema(final String name)
{    Schema schema = Schema.createRecord(UR_SCHEMA_NAME, "unresolved schema", UR_SCHEMA_NS, false, Collections.EMPTY_LIST);    schema.addProp(UR_SCHEMA_ATTR, name);    return schema;}
aa59521b28babd7b9ec953a535fafa62f1e69ba6a6a4911fa693551680f66ce2
isUnresolvedSchema
 static boolean isUnresolvedSchema(final Schema schema)
{    return (schema.getType() == Schema.Type.RECORD && schema.getProp(UR_SCHEMA_ATTR) != null && UR_SCHEMA_NAME.equals(schema.getName()) && UR_SCHEMA_NS.equals(schema.getNamespace()));}
4e23f457ce56ac1b0ed9efbb6a38b2bf97800be64bea80bbdb6d2985b56fd09c
getUnresolvedSchemaName
 static String getUnresolvedSchemaName(final Schema schema)
{    if (!isUnresolvedSchema(schema)) {        throw new IllegalArgumentException("Not a unresolved schema: " + schema);    }    return schema.getProp(UR_SCHEMA_ATTR);}
7774a78a999dcc5b420b2ecd75e455cfdd0456be87baf92f2fed274bec7e59cd
resolve
 static Protocol resolve(final Protocol protocol)
{    Protocol result = new Protocol(protocol.getName(), protocol.getDoc(), protocol.getNamespace());    final Collection<Schema> types = protocol.getTypes();        List<Schema> newSchemas = new ArrayList<>(types.size());    IdentityHashMap<Schema, Schema> replacements = new IdentityHashMap<>();    for (Schema schema : types) {        newSchemas.add(Schemas.visit(schema, new ResolvingVisitor(schema, replacements, new SymbolTable(protocol))));    }        result.setTypes(newSchemas);        for (Map.Entry<String, Protocol.Message> entry : protocol.getMessages().entrySet()) {        Protocol.Message value = entry.getValue();        Protocol.Message nvalue;        if (value.isOneWay()) {            Schema replacement = resolve(replacements, value.getRequest(), protocol);            nvalue = result.createMessage(value.getName(), value.getDoc(), value, replacement);        } else {            Schema request = resolve(replacements, value.getRequest(), protocol);            Schema response = resolve(replacements, value.getResponse(), protocol);            Schema errors = resolve(replacements, value.getErrors(), protocol);            nvalue = result.createMessage(value.getName(), value.getDoc(), value, request, response, errors);        }        result.getMessages().put(entry.getKey(), nvalue);    }    Schemas.copyProperties(protocol, result);    return result;}
45e048865b8cd3d0b2ae913f9eb2f1f31a79952418cbd51077b4602654bdfdea
resolve
private static Schema resolve(final IdentityHashMap<Schema, Schema> replacements, final Schema request, final Protocol protocol)
{    Schema replacement = replacements.get(request);    if (replacement == null) {        replacement = Schemas.visit(request, new ResolvingVisitor(request, replacements, new SymbolTable(protocol)));    }    return replacement;}
a36011f214e838c850f040b826a3e4f70cd67db048244936dec6d003378a5241
apply
public Schema apply(final String f)
{    return symbolTable.getType(f);}
dc09f1abbb7e8d64dad6fcb17048e23df0962ec99a33691d6a12e9322dee1a4b
copy
public void copy(final Schema first, final Schema second)
{    Schemas.copyLogicalTypes(first, second);    Schemas.copyAliases(first, second);}
d282a4ab425d3ca2efc6e38388c2e2df47775af9616080d5b995c04c58464a74
copy
public void copy(final Schema.Field first, final Schema.Field second)
{    Schemas.copyAliases(first, second);}
505831e412aa85a32f6025a88d5853981145d95c5a9acfae4f042b96d22e05c9
visitTerminal
public SchemaVisitorAction visitTerminal(final Schema terminal)
{    Schema.Type type = terminal.getType();    Schema newSchema;    switch(type) {                case RECORD:        case ARRAY:        case MAP:        case UNION:            if (!replace.containsKey(terminal)) {                throw new IllegalStateException("Schema " + terminal + " must be already processed");            }            return SchemaVisitorAction.CONTINUE;        case BOOLEAN:        case BYTES:        case DOUBLE:        case FLOAT:        case INT:        case LONG:        case NULL:        case STRING:            newSchema = Schema.create(type);            break;        case ENUM:            newSchema = Schema.createEnum(terminal.getName(), copyDocs ? terminal.getDoc() : null, terminal.getNamespace(), terminal.getEnumSymbols());            break;        case FIXED:            newSchema = Schema.createFixed(terminal.getName(), copyDocs ? terminal.getDoc() : null, terminal.getNamespace(), terminal.getFixedSize());            break;        default:            throw new IllegalStateException("Unsupported schema " + terminal);    }    copyProperties.copy(terminal, newSchema);    replace.put(terminal, newSchema);    return SchemaVisitorAction.CONTINUE;}
3dedbf1fe8d326434cfd67954fa1f4ad37b672f39b2adecf0827c0854d45b252
visitNonTerminal
public SchemaVisitorAction visitNonTerminal(final Schema nt)
{    Schema.Type type = nt.getType();    if (type == RECORD) {        Schema newSchema = Schema.createRecord(nt.getName(), copyDocs ? nt.getDoc() : null, nt.getNamespace(), nt.isError());        copyProperties.copy(nt, newSchema);        replace.put(nt, newSchema);    }    return SchemaVisitorAction.CONTINUE;}
b7d6c2c0c98c752500c74a2a6ad0d8528f06d1a1dec1070d2f9a83dbb9fcae0b
afterVisitNonTerminal
public SchemaVisitorAction afterVisitNonTerminal(final Schema nt)
{    Schema.Type type = nt.getType();    Schema newSchema;    switch(type) {        case RECORD:            newSchema = replace.get(nt);            List<Schema.Field> fields = nt.getFields();            List<Schema.Field> newFields = new ArrayList<>(fields.size());            for (Schema.Field field : fields) {                Schema.Field newField = new Schema.Field(field.name(), replace.get(field.schema()), copyDocs ? field.doc() : null, field.defaultVal(), field.order());                copyProperties.copy(field, newField);                newFields.add(newField);            }            newSchema.setFields(newFields);            return SchemaVisitorAction.CONTINUE;        case UNION:            List<Schema> types = nt.getTypes();            List<Schema> newTypes = new ArrayList<>(types.size());            for (Schema sch : types) {                newTypes.add(replace.get(sch));            }            newSchema = Schema.createUnion(newTypes);            break;        case ARRAY:            newSchema = Schema.createArray(replace.get(nt.getElementType()));            break;        case MAP:            newSchema = Schema.createMap(replace.get(nt.getValueType()));            break;        default:            throw new IllegalStateException("Illegal type " + type + ", schema " + nt);    }    copyProperties.copy(nt, newSchema);    replace.put(nt, newSchema);    return SchemaVisitorAction.CONTINUE;}
53c9a70a6fd530b7bae94d81656a887d06af4431acc656fee461a450ed3f0c4b
get
public Schema get()
{    return replace.get(root);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "CloningVisitor{" + "replace=" + replace + ", root=" + root + '}';}
4783b7e403a71797142a7eb7bb2cb6e976fb0b3710f1200d266891f953ae7081
copyAliases
public static void copyAliases(final Schema from, final Schema to)
{    switch(    from.getType()) {        case RECORD:        case ENUM:        case FIXED:            Set<String> aliases = from.getAliases();            for (String alias : aliases) {                to.addAlias(alias);            }    }}
524383f04d037ef717d77c6869f451a1a5fabd7f37edcbbb0243244c809dec24
copyAliases
public static void copyAliases(final Schema.Field from, final Schema.Field to)
{    Set<String> aliases = from.aliases();    for (String alias : aliases) {        to.addAlias(alias);    }}
e2ce6f23b24286a83181686e1199cf16be8d5de6afb874f23f7129d6e00f79b6
copyLogicalTypes
public static void copyLogicalTypes(final Schema from, final Schema to)
{    LogicalType logicalType = from.getLogicalType();    if (logicalType != null) {        logicalType.addToSchema(to);    }}
8e879dbef01a9bc2ebe54ed1edf7b63d314b84621a9f83baa9c93aabc31c7469
copyProperties
public static void copyProperties(final JsonProperties from, final JsonProperties to)
{    Map<String, Object> objectProps = from.getObjectProps();    for (Map.Entry<String, Object> entry : objectProps.entrySet()) {        to.addProp(entry.getKey(), entry.getValue());    }}
a085dead82fd08d050ab740108e2147cc08e18bcee28090bfeb786aa75ec5cf6
hasGeneratedJavaClass
public static boolean hasGeneratedJavaClass(final Schema schema)
{    Schema.Type type = schema.getType();    switch(type) {        case ENUM:        case RECORD:        case FIXED:            return true;        default:            return false;    }}
af244038a388827e86029657ed7c0a2262c25340d6c7e1d7a3c96e8d54885e18
getJavaClassName
public static String getJavaClassName(final Schema schema)
{    String namespace = schema.getNamespace();    if (namespace == null) {        return SpecificCompiler.mangle(schema.getName());    } else {        return namespace + '.' + SpecificCompiler.mangle(schema.getName());    }}
56268c6f22fb40604a9096a84935ce002b10a152ddc779a47156685ae02e2627
visit
public static T visit(final Schema start, final SchemaVisitor<T> visitor)
{        IdentityHashMap<Schema, Schema> visited = new IdentityHashMap<>();                    Deque<Object> dq = new ArrayDeque<>();    dq.addLast(start);    Object current;    while ((current = dq.pollLast()) != null) {        if (current instanceof Supplier) {                        SchemaVisitorAction action = ((Supplier<SchemaVisitorAction>) current).get();            switch(action) {                case CONTINUE:                    break;                case SKIP_SUBTREE:                    throw new UnsupportedOperationException();                case SKIP_SIBLINGS:                    while (dq.getLast() instanceof Schema) {                        dq.removeLast();                    }                    break;                case TERMINATE:                    return visitor.get();                default:                    throw new UnsupportedOperationException("Invalid action " + action);            }        } else {            Schema schema = (Schema) current;            boolean terminate;            if (!visited.containsKey(schema)) {                Schema.Type type = schema.getType();                switch(type) {                    case ARRAY:                        terminate = visitNonTerminal(visitor, schema, dq, Collections.singleton(schema.getElementType()));                        visited.put(schema, schema);                        break;                    case RECORD:                        Iterator<Schema> reverseSchemas = schema.getFields().stream().map(Field::schema).collect(Collectors.toCollection(ArrayDeque::new)).descendingIterator();                        terminate = visitNonTerminal(visitor, schema, dq, () -> reverseSchemas);                        visited.put(schema, schema);                        break;                    case UNION:                        terminate = visitNonTerminal(visitor, schema, dq, schema.getTypes());                        visited.put(schema, schema);                        break;                    case MAP:                        terminate = visitNonTerminal(visitor, schema, dq, Collections.singleton(schema.getValueType()));                        visited.put(schema, schema);                        break;                    case NULL:                    case BOOLEAN:                    case BYTES:                    case DOUBLE:                    case ENUM:                    case FIXED:                    case FLOAT:                    case INT:                    case LONG:                    case STRING:                        terminate = visitTerminal(visitor, schema, dq);                        break;                    default:                        throw new UnsupportedOperationException("Invalid type " + type);                }            } else {                terminate = visitTerminal(visitor, schema, dq);            }            if (terminate) {                return visitor.get();            }        }    }    return visitor.get();}
a2c18b3c723a28c84686d06dce732fb0980c8974ac9c4cedd4e61b503b67230b
visitNonTerminal
private static boolean visitNonTerminal(final SchemaVisitor visitor, final Schema schema, final Deque<Object> dq, final Iterable<Schema> itSupp)
{    SchemaVisitorAction action = visitor.visitNonTerminal(schema);    switch(action) {        case CONTINUE:            dq.addLast((Supplier<SchemaVisitorAction>) () -> visitor.afterVisitNonTerminal(schema));            for (Schema child : itSupp) {                dq.addLast(child);            }            break;        case SKIP_SUBTREE:            dq.addLast((Supplier<SchemaVisitorAction>) () -> visitor.afterVisitNonTerminal(schema));            break;        case SKIP_SIBLINGS:            while (!dq.isEmpty() && dq.getLast() instanceof Schema) {                dq.removeLast();            }            break;        case TERMINATE:            return true;        default:            throw new UnsupportedOperationException("Invalid action " + action + " for " + schema);    }    return false;}
79a1fc88c74b12eae3d497f8877f460d52b6df6c8cf10af6d47db28975756d97
visitTerminal
private static boolean visitTerminal(final SchemaVisitor visitor, final Schema schema, final Deque<Object> dq)
{    SchemaVisitorAction action = visitor.visitTerminal(schema);    switch(action) {        case CONTINUE:            break;        case SKIP_SUBTREE:            throw new UnsupportedOperationException("Invalid action " + action + " for " + schema);        case SKIP_SIBLINGS:            while (!dq.isEmpty() && dq.getLast() instanceof Schema) {                dq.removeLast();            }            break;        case TERMINATE:            return true;        default:            throw new UnsupportedOperationException("Invalid action " + action + " for " + schema);    }    return false;}
5e248210883b15055dbb92bcae692722adb76b511c50cc45408180b9a2a63764
setFile
public void setFile(File file)
{    this.src = file;}
e108b70d8f9bc436b741daa04bead80c952f0ebd0e95d00a078938fc017b6046
setDestdir
public void setDestdir(File dir)
{    this.dest = dir;}
acf283dd5d984b49475bbada2a71a3d03b9dfedce43b173dc4039c08d7980ea3
setStringType
public void setStringType(StringType type)
{    this.stringType = type;}
716dc634e043a097785f839913592cfe2cd35eec76d2a1c45ea3e6913a4562d0
getStringType
public StringType getStringType()
{    return this.stringType;}
0f53472e15d36f3065f30395d281c764bdf1fa9c93008cd2bb8110aaa16c523c
addFileset
public void addFileset(FileSet set)
{    filesets.add(set);}
bede5934779a409518dbb3042b91a5857baf593afc99995b9cc8a397e22c9a6b
execute
public void execute()
{    if (src == null && filesets.size() == 0)        throw new BuildException("No file or fileset specified.");    if (src != null)        compile(src);    Project myProject = getProject();    for (FileSet fs : filesets) {        DirectoryScanner ds = fs.getDirectoryScanner(myProject);        File dir = fs.getDir(myProject);        String[] srcs = ds.getIncludedFiles();        for (String src1 : srcs) {            compile(new File(dir, src1));        }    }}
f757a50bf19633e16ac77e0da54fa452dd952f423ff6ffbee41c370c767013d2
doCompile
protected void doCompile(File src, File dir) throws IOException
{    Protocol protocol = Protocol.parse(src);    SpecificCompiler compiler = new SpecificCompiler(protocol);    compiler.setStringType(getStringType());    compiler.compileToDestination(src, dest);}
ee56ea60c5e56467af9ed27fcb6e0d693a7ade1e1585c6839ac2c72e0a5c243c
compile
private void compile(File file)
{    try {        doCompile(file, dest);    } catch (AvroRuntimeException | IOException e) {        throw new BuildException(e);    }}
444366f26eda58096cbaa1f9f9b737d6bb2ffe0c0788e4e6bb016df6a1c26279
doCompile
protected void doCompile(File src, File dest) throws IOException
{    final Schema.Parser parser = new Schema.Parser();    final Schema schema = parser.parse(src);    final SpecificCompiler compiler = new SpecificCompiler(schema);    compiler.setStringType(getStringType());    compiler.compileToDestination(src, dest);}
365a24fc75086b6a0e91f9b072bd58c9280846cc05f333f28ede18388f27ce89
main
public static void main(String[] args) throws IOException
{    if (args.length < 2) {        System.err.println("Usage: SchemaTask <schema.avsc>... <output-folder>");        System.exit(1);    }    File dst = new File(args[args.length - 1]);    for (int i = 0; i < args.length - 1; i++) new SchemaTask().doCompile(new File(args[i]), dst);}
a8fc2a59cb48a3eb00575c6f08838f91251a5e34fd939823471b19cc15f77cea
addLogicalTypeConversions
 void addLogicalTypeConversions(SpecificData specificData)
{    specificData.addLogicalTypeConversion(new TimeConversions.DateConversion());    specificData.addLogicalTypeConversion(new TimeConversions.TimeMillisConversion());    specificData.addLogicalTypeConversion(new TimeConversions.TimeMicrosConversion());    specificData.addLogicalTypeConversion(new TimeConversions.TimestampMillisConversion());    specificData.addLogicalTypeConversion(new TimeConversions.TimestampMicrosConversion());}
f4bd1a0073712dc1d4c1a68b57d6479ed28f0c474c56dcc21b2bc005fc7e7414
isCreateAllArgsConstructor
public boolean isCreateAllArgsConstructor()
{    return createAllArgsConstructor;}
65c9319da84a03ca4921e80e9c76e04fbfbf2163e11c1c54f50ec3d889405bb2
setAdditionalVelocityTools
public void setAdditionalVelocityTools(List<Object> additionalVelocityTools)
{    this.additionalVelocityTools = additionalVelocityTools;}
7cfe4087bf94e91fb275e8dd514b806ee27888d8a3c45128a5c06409e0749594
setTemplateDir
public void setTemplateDir(String templateDir)
{    this.templateDir = templateDir;}
5f8d18885f941d622c3f608b8ec0d47daffda4528b377a8d6565e00863606930
setSuffix
public void setSuffix(String suffix)
{    this.suffix = suffix;}
12db65dc78f2f6d6c562463ccd8fcc98182455fdba463d0102ba4ef75642467b
deprecatedFields
public boolean deprecatedFields()
{    return (this.fieldVisibility == FieldVisibility.PUBLIC_DEPRECATED);}
1a066930cbbac679e4448d2111705cdf0db18663db825e68670f09bb7724e043
publicFields
public boolean publicFields()
{    return (this.fieldVisibility == FieldVisibility.PUBLIC || this.fieldVisibility == FieldVisibility.PUBLIC_DEPRECATED);}
a755afec1fe92f0b41fa27c3771cdaac52e2277c6fff57f67a5e8d291a7baab8
privateFields
public boolean privateFields()
{    return (this.fieldVisibility == FieldVisibility.PRIVATE);}
d7a4f6c89d9fd066797a39dbdf31ab398d99467d8237a67e7b303b71d04ccbb6
setFieldVisibility
public void setFieldVisibility(FieldVisibility fieldVisibility)
{    this.fieldVisibility = fieldVisibility;}
213f670b477311c65a02ef545f763a2431dacd58144c12844ff12648a830bd9d
isCreateSetters
public boolean isCreateSetters()
{    return this.createSetters;}
d427df9f89dd879db77f7e3fe887d75193c12a9391ce501e962659d010ec8b33
setCreateSetters
public void setCreateSetters(boolean createSetters)
{    this.createSetters = createSetters;}
c83db6144c87a3068305aea87a6a3b66436dcd13327dee42790e14eddbf02d41
isCreateOptionalGetters
public boolean isCreateOptionalGetters()
{    return this.createOptionalGetters;}
7cc6b295b59b67c301932dbebf252dafb5ba918a51d83c1c7d23cbb1fa418cd7
setCreateOptionalGetters
public void setCreateOptionalGetters(boolean createOptionalGetters)
{    this.createOptionalGetters = createOptionalGetters;}
cd12fd1db0ec7827f44eeaf810f971c2c8db997fe26524a418a08ef2961120ce
isGettersReturnOptional
public boolean isGettersReturnOptional()
{    return this.gettersReturnOptional;}
6e9073ae2f647b4b4d7af38aef7df90fd90a7511a05f43e2818406bcec9198e5
setGettersReturnOptional
public void setGettersReturnOptional(boolean gettersReturnOptional)
{    this.gettersReturnOptional = gettersReturnOptional;}
e79436860b27c9a94f923a453469a91ba4869a9bc17f3c9108c3ba85dff0b414
setEnableDecimalLogicalType
public void setEnableDecimalLogicalType(boolean enableDecimalLogicalType)
{    this.enableDecimalLogicalType = enableDecimalLogicalType;}
85e5013c50bd30786f27a8cd81bb613508b26df4b283f33e3ce1b1a61d1b0d92
addCustomConversion
public void addCustomConversion(Class<?> conversionClass)
{    try {        final Conversion<?> conversion = (Conversion<?>) conversionClass.getDeclaredConstructor().newInstance();        specificData.addLogicalTypeConversion(conversion);    } catch (IllegalAccessException | InstantiationException | NoSuchMethodException | InvocationTargetException e) {        throw new RuntimeException("Failed to instantiate conversion class " + conversionClass, e);    }}
8e29f18e06c14226189024ffb6f25ad0a7ef845235390f9dccda9dbbbfcca79f
getUsedConversionClasses
public Collection<String> getUsedConversionClasses(Schema schema)
{    LinkedHashMap<String, Conversion<?>> classnameToConversion = new LinkedHashMap<>();    for (Conversion<?> conversion : specificData.getConversions()) {        classnameToConversion.put(conversion.getConvertedType().getCanonicalName(), conversion);    }    Collection<String> result = new HashSet<>();    for (String className : getClassNamesOfPrimitiveFields(schema)) {        if (classnameToConversion.containsKey(className)) {            result.add(classnameToConversion.get(className).getClass().getCanonicalName());        }    }    return result;}
c973802f63c2a34c51c822021e3a7184bf7517292ddc1afa041db6abd65ce740
getClassNamesOfPrimitiveFields
private Set<String> getClassNamesOfPrimitiveFields(Schema schema)
{    Set<String> result = new HashSet<>();    getClassNamesOfPrimitiveFields(schema, result, new HashSet<>());    return result;}
274a46966e2cb9ac7929e46864589edd18489c5e168ab79c2f1d599137c32a09
getClassNamesOfPrimitiveFields
private void getClassNamesOfPrimitiveFields(Schema schema, Set<String> result, Set<Schema> seenSchemas)
{    if (seenSchemas.contains(schema)) {        return;    }    seenSchemas.add(schema);    switch(schema.getType()) {        case RECORD:            for (Schema.Field field : schema.getFields()) {                getClassNamesOfPrimitiveFields(field.schema(), result, seenSchemas);            }            break;        case MAP:            getClassNamesOfPrimitiveFields(schema.getValueType(), result, seenSchemas);            break;        case ARRAY:            getClassNamesOfPrimitiveFields(schema.getElementType(), result, seenSchemas);            break;        case UNION:            for (Schema s : schema.getTypes()) getClassNamesOfPrimitiveFields(s, result, seenSchemas);            break;        case ENUM:        case FIXED:        case NULL:            break;        case STRING:        case BYTES:        case INT:        case LONG:        case FLOAT:        case DOUBLE:        case BOOLEAN:            result.add(javaType(schema));            break;        default:            throw new RuntimeException("Unknown type: " + schema);    }}
f1b23ff77539a299402cd989ebcc19c67d947eea5cc703df66bf03cae774c511
initializeVelocity
private void initializeVelocity()
{    this.velocityEngine = new VelocityEngine();            velocityEngine.addProperty("resource.loader", "class, file");    velocityEngine.addProperty("class.resource.loader.class", "org.apache.velocity.runtime.resource.loader.ClasspathResourceLoader");    velocityEngine.addProperty("file.resource.loader.class", "org.apache.velocity.runtime.resource.loader.FileResourceLoader");    velocityEngine.addProperty("file.resource.loader.path", "/, .");    velocityEngine.setProperty("runtime.references.strict", true);            velocityEngine.setProperty("space.gobbling", "bc");}
98f6ad63b843abdd202675c5b7069f7bb566b073dd5d926af314b643549047f6
initializeSpecificData
private void initializeSpecificData()
{    addLogicalTypeConversions(specificData);    specificData.addLogicalTypeConversion(new Conversions.DecimalConversion());}
e1ad650803ae8564aea5c370bc63dc1737f18671f1d11c859cccb78fc132e868
writeToDestination
 File writeToDestination(File src, File destDir) throws IOException
{    File f = new File(destDir, path);    if (src != null && f.exists() && f.lastModified() >= src.lastModified())                return f;    f.getParentFile().mkdirs();    Writer fw = null;    FileOutputStream fos = null;    try {        if (outputCharacterEncoding != null) {            fos = new FileOutputStream(f);            fw = new OutputStreamWriter(fos, outputCharacterEncoding);        } else {            fw = Files.newBufferedWriter(f.toPath(), UTF_8);        }        fw.write(FILE_HEADER);        fw.write(contents);    } finally {        if (fw != null)            fw.close();        if (fos != null)            fos.close();    }    return f;}
2c8194af6d87b24e2c312d2705e30c8e2561489fe22239d8377a6d446ff009e6
compileProtocol
public static void compileProtocol(File src, File dest) throws IOException
{    compileProtocol(new File[] { src }, dest);}
802f3dc0cbf00361bcdbd42e514908f34f0e7883617558f0a8490dd37b4835e9
compileProtocol
public static void compileProtocol(File[] srcFiles, File dest) throws IOException
{    for (File src : srcFiles) {        Protocol protocol = Protocol.parse(src);        SpecificCompiler compiler = new SpecificCompiler(protocol);        compiler.compileToDestination(src, dest);    }}
598da2041f4e1ec5bafdbf43007577d498623acb7d16f4531ac3dbbadcf05e6f
compileSchema
public static void compileSchema(File src, File dest) throws IOException
{    compileSchema(new File[] { src }, dest);}
104428c64fb0370ce1c1c00a537c30dcf65da107436a5b4d1789f7980421f1be
compileSchema
public static void compileSchema(File[] srcFiles, File dest) throws IOException
{    Schema.Parser parser = new Schema.Parser();    for (File src : srcFiles) {        Schema schema = parser.parse(src);        SpecificCompiler compiler = new SpecificCompiler(schema);        compiler.compileToDestination(src, dest);    }}
3b3ac9ed25c537b379403eb0df38d2456e99638e7bc8d23777c0ba47b6508879
enqueue
private void enqueue(Schema schema)
{    if (queue.contains(schema))        return;    switch(schema.getType()) {        case RECORD:            queue.add(schema);            for (Schema.Field field : schema.getFields()) enqueue(field.schema());            break;        case MAP:            enqueue(schema.getValueType());            break;        case ARRAY:            enqueue(schema.getElementType());            break;        case UNION:            for (Schema s : schema.getTypes()) enqueue(s);            break;        case ENUM:        case FIXED:            queue.add(schema);            break;        case STRING:        case BYTES:        case INT:        case LONG:        case FLOAT:        case DOUBLE:        case BOOLEAN:        case NULL:            break;        default:            throw new RuntimeException("Unknown type: " + schema);    }}
d14c90043468f3e32b921564edeb2fc5f59e7e53bdffe825841b1bb19230d14d
compile
 Collection<OutputFile> compile()
{    List<OutputFile> out = new ArrayList<>();    for (Schema schema : queue) {        out.add(compile(schema));    }    if (protocol != null) {        out.add(compileInterface(protocol));    }    return out;}
6c24dd3458255660a00ebbb5f21a369f0d66b4c53f109090160c32f68485c0a2
compileToDestination
public void compileToDestination(File src, File dst) throws IOException
{    for (Schema schema : queue) {        OutputFile o = compile(schema);        o.writeToDestination(src, dst);    }    if (protocol != null) {        compileInterface(protocol).writeToDestination(src, dst);    }}
17a81c7009dedbbb32d82be30499ac682ace1f268046cb13d5f0f7a4d5032d9d
renderTemplate
private String renderTemplate(String templateName, VelocityContext context)
{    Template template;    try {        template = this.velocityEngine.getTemplate(templateName);    } catch (Exception e) {        throw new RuntimeException(e);    }    StringWriter writer = new StringWriter();    template.merge(context, writer);    return writer.toString();}
220eba4d1d6a8a3edf97cf03c498f325c8fe9d3ee8e41898ca06e6a9be5210d6
compileInterface
 OutputFile compileInterface(Protocol protocol)
{        protocol = addStringType(protocol);    VelocityContext context = new VelocityContext();    context.put("protocol", protocol);    context.put("this", this);    for (Object velocityTool : additionalVelocityTools) {        String toolName = velocityTool.getClass().getSimpleName().toLowerCase();        context.put(toolName, velocityTool);    }    String out = renderTemplate(templateDir + "protocol.vm", context);    OutputFile outputFile = new OutputFile();    String mangledName = mangle(protocol.getName());    outputFile.path = makePath(mangledName, protocol.getNamespace());    outputFile.contents = out;    outputFile.outputCharacterEncoding = outputCharacterEncoding;    return outputFile;}
917bca454cfb221eb144f298477ca9b04929d15148aa3c351a6e74dc5a7bb28a
makePath
 String makePath(String name, String space)
{    if (space == null || space.isEmpty()) {        return name + suffix;    } else {        return space.replace('.', File.separatorChar) + File.separatorChar + name + suffix;    }}
98cf444812fc623e853a38236111e5e6efb746fbb11fc0deb7f0aa889429892e
calcAllArgConstructorParameterUnits
protected int calcAllArgConstructorParameterUnits(Schema record)
{    if (record.getType() != Schema.Type.RECORD)        throw new RuntimeException("This method must only be called for record schemas.");    return record.getFields().size();}
76674e55c9717a212eabea99f69d40da4e3c450d536ab80b0c9cb6081ed0bfe7
validateRecordForCompilation
protected void validateRecordForCompilation(Schema record)
{    this.createAllArgsConstructor = calcAllArgConstructorParameterUnits(record) <= MAX_FIELD_PARAMETER_UNIT_COUNT;    if (!this.createAllArgsConstructor) {        Logger logger = LoggerFactory.getLogger(SpecificCompiler.class);        logger.warn("Record '" + record.getFullName() + "' contains more than " + MAX_FIELD_PARAMETER_UNIT_COUNT + " parameters which exceeds the JVM " + "spec for the number of permitted constructor arguments. Clients must " + "rely on the builder pattern to create objects instead. For more info " + "see JIRA ticket AVRO-1642.");    }}
ab6e571430c6e948142334964ebc2ba68cf71d76c3eec35308f23fbdfed76b76
compile
 OutputFile compile(Schema schema)
{        schema = addStringType(schema);    String output = "";    VelocityContext context = new VelocityContext();    context.put("this", this);    context.put("schema", schema);    for (Object velocityTool : additionalVelocityTools) {        String toolName = velocityTool.getClass().getSimpleName().toLowerCase();        context.put(toolName, velocityTool);    }    switch(schema.getType()) {        case RECORD:            validateRecordForCompilation(schema);            output = renderTemplate(templateDir + "record.vm", context);            break;        case ENUM:            output = renderTemplate(templateDir + "enum.vm", context);            break;        case FIXED:            output = renderTemplate(templateDir + "fixed.vm", context);            break;        case BOOLEAN:        case NULL:            break;        default:            throw new RuntimeException("Unknown type: " + schema);    }    OutputFile outputFile = new OutputFile();    String name = mangle(schema.getName());    outputFile.path = makePath(name, schema.getNamespace());    outputFile.contents = output;    outputFile.outputCharacterEncoding = outputCharacterEncoding;    return outputFile;}
c4be991b848c6cfb57e46d42018c1b8034324cd232eff1460e79314bd22c7ff8
setStringType
public void setStringType(StringType t)
{    this.stringType = t;}
fbc68ea9e7d9606b24c1c4ac7ea50b907ccc3b3cb6b7c5f32cb56786857a150e
addStringType
private Protocol addStringType(Protocol p)
{    if (stringType != StringType.String)        return p;    Protocol newP = new Protocol(p.getName(), p.getDoc(), p.getNamespace());    Map<Schema, Schema> types = new LinkedHashMap<>();    for (Map.Entry<String, Object> a : p.getObjectProps().entrySet()) {        newP.addProp(a.getKey(), a.getValue());    }        Collection<Schema> namedTypes = new LinkedHashSet<>();    for (Schema s : p.getTypes()) namedTypes.add(addStringType(s, types));    newP.setTypes(namedTypes);        Map<String, Message> newM = newP.getMessages();    for (Message m : p.getMessages().values()) newM.put(m.getName(), m.isOneWay() ? newP.createMessage(m, addStringType(m.getRequest(), types)) : newP.createMessage(m, addStringType(m.getRequest(), types), addStringType(m.getResponse(), types), addStringType(m.getErrors(), types)));    return newP;}
a51942dd59039ef8abe85dd657b70a02b68b027470dbfa45384d3445522c5407
addStringType
private Schema addStringType(Schema s)
{    if (stringType != StringType.String)        return s;    return addStringType(s, new LinkedHashMap<>());}
fb6e5fc31a4c82a19e16a4a49ee90306c9617a4bce06baa5eeafcbb336563763
addStringType
private Schema addStringType(Schema s, Map<Schema, Schema> seen)
{    if (seen.containsKey(s))                return seen.get(s);    Schema result = s;    switch(s.getType()) {        case STRING:            result = Schema.create(Schema.Type.STRING);            GenericData.setStringType(result, stringType);            break;        case RECORD:            result = Schema.createRecord(s.getFullName(), s.getDoc(), null, s.isError());            for (String alias : s.getAliases())             result.addAlias(alias, null);            seen.put(s, result);            List<Field> newFields = new ArrayList<>();            for (Field f : s.getFields()) {                Schema fSchema = addStringType(f.schema(), seen);                Field newF = new Field(f, fSchema);                newFields.add(newF);            }            result.setFields(newFields);            break;        case ARRAY:            Schema e = addStringType(s.getElementType(), seen);            result = Schema.createArray(e);            break;        case MAP:            Schema v = addStringType(s.getValueType(), seen);            result = Schema.createMap(v);            GenericData.setStringType(result, stringType);            break;        case UNION:            List<Schema> types = new ArrayList<>();            for (Schema branch : s.getTypes()) types.add(addStringType(branch, seen));            result = Schema.createUnion(types);            break;    }    result.addAllProps(s);    seen.put(s, result);    return result;}
4f3d5aa7e8711a59ed6886a3464064943cbc91bf54bd2396ef455db56dad6508
getStringType
public String getStringType(Schema s)
{    String prop;    switch(s.getType()) {        case MAP:            prop = SpecificData.KEY_CLASS_PROP;            break;        case STRING:            prop = SpecificData.CLASS_PROP;            break;        default:            throw new IllegalArgumentException("Can't check string-type of non-string/map type: " + s);    }    return getStringType(s.getObjectProp(prop));}
45dbac3eeafdd0189fda3047634e9f5c6f87822a9573ac0590c4d0501a547960
getStringType
private String getStringType(Object overrideClassProperty)
{    if (overrideClassProperty != null)        return overrideClassProperty.toString();    switch(stringType) {        case String:            return "java.lang.String";        case Utf8:            return "org.apache.avro.util.Utf8";        case CharSequence:            return "java.lang.CharSequence";        default:            throw new RuntimeException("Unknown string type: " + stringType);    }}
bf40806f31e5bc3466bab1cc19a3d3fae13d35b8550a5cb264f46818e49c7fb0
isStringable
public boolean isStringable(Schema schema)
{    String t = getStringType(schema);    return !(t.equals("java.lang.String") || t.equals("java.lang.CharSequence") || t.equals("org.apache.avro.util.Utf8"));}
c5228567847d54d151c68b075f7ea5826af5e44ea2c8b217ff8794f0725beaaa
javaType
public String javaType(Schema schema)
{    return javaType(schema, true);}
399a675d961f470f7caaeea9020195a6e5f9e4c5b09726a5c1ef211d1c87e296
javaType
private String javaType(Schema schema, boolean checkConvertedLogicalType)
{    if (checkConvertedLogicalType) {        String convertedLogicalType = getConvertedLogicalType(schema);        if (convertedLogicalType != null) {            return convertedLogicalType;        }    }    switch(schema.getType()) {        case RECORD:        case ENUM:        case FIXED:            return mangle(schema.getFullName());        case ARRAY:            return "java.util.List<" + javaType(schema.getElementType()) + ">";        case MAP:            return "java.util.Map<" + getStringType(schema.getObjectProp(SpecificData.KEY_CLASS_PROP)) + "," + javaType(schema.getValueType()) + ">";        case UNION:                        List<Schema> types = schema.getTypes();            if ((types.size() == 2) && types.contains(NULL_SCHEMA))                return javaType(types.get(types.get(0).equals(NULL_SCHEMA) ? 1 : 0));            return "java.lang.Object";        case STRING:            return getStringType(schema.getObjectProp(SpecificData.CLASS_PROP));        case BYTES:            return "java.nio.ByteBuffer";        case INT:            return "java.lang.Integer";        case LONG:            return "java.lang.Long";        case FLOAT:            return "java.lang.Float";        case DOUBLE:            return "java.lang.Double";        case BOOLEAN:            return "java.lang.Boolean";        case NULL:            return "java.lang.Void";        default:            throw new RuntimeException("Unknown type: " + schema);    }}
cd8fe432fc54d6d2be469136cf1632d16e490de020bc24cc9e86632d3cc66b8b
getConvertedLogicalType
private String getConvertedLogicalType(Schema schema)
{    if (enableDecimalLogicalType || !(schema.getLogicalType() instanceof LogicalTypes.Decimal)) {        Conversion<?> conversion = specificData.getConversionFor(schema.getLogicalType());        if (conversion != null) {            return conversion.getConvertedType().getName();        }    }    return null;}
9fde78a7b3fc292f218b1f7112bb2fe14894c66a581be6c0c096755839e0110b
generateSetterCode
public String generateSetterCode(Schema schema, String name, String pname)
{    Conversion<?> conversion = specificData.getConversionFor(schema.getLogicalType());    if (conversion != null) {        return conversion.adjustAndSetValue("this." + name, pname);    }    return "this." + name + " = " + pname + ";";}
d497dd5688d7c373c838295c71c90af77e3b8ff68592b902da4dd2bcdfdc01a5
javaUnbox
public String javaUnbox(Schema schema)
{    return javaUnbox(schema, false);}
24589d75d40b63fe7a56e046486e41efce8aca5673d32b3ffcec5de75835173a
javaUnbox
public String javaUnbox(Schema schema, boolean unboxNullToVoid)
{    String convertedLogicalType = getConvertedLogicalType(schema);    if (convertedLogicalType != null) {        return convertedLogicalType;    }    switch(schema.getType()) {        case INT:            return "int";        case LONG:            return "long";        case FLOAT:            return "float";        case DOUBLE:            return "double";        case BOOLEAN:            return "boolean";        case NULL:            if (unboxNullToVoid) {                                return "void";            }        default:            return javaType(schema, false);    }}
62651ef2ecf33a6322a223dcf1b62f763eefe244400d2ac99f46c8fde0978510
indent
public String indent(int n)
{    return new String(new char[n]).replace('\0', ' ');}
c2642c5cd05c29a3f33493a5850bc666996ba3cce86358ce62b8990eb3356975
getNonNullIndex
public int getNonNullIndex(Schema s)
{    if (s.getType() != Schema.Type.UNION || s.getTypes().size() != 2 || !s.getTypes().contains(NULL_SCHEMA))        throw new IllegalArgumentException("Can only be used on 2-branch union with a null branch: " + s);    return (s.getTypes().get(0).equals(NULL_SCHEMA) ? 1 : 0);}
d226fdb5587c54a45b2fc3a5bfd0243c11b76eb3943c116be57ece14ec686cd5
isCustomCodable
public boolean isCustomCodable(Schema schema)
{    if (schema.isError())        return false;    return isCustomCodable(schema, new HashSet<>());}
28db331255b158a28a0c14122c289a3bedb382d27074d38f0a367986fabce73e
isCustomCodable
private boolean isCustomCodable(Schema schema, Set<Schema> seen)
{    if (!seen.add(schema))        return true;    if (schema.getLogicalType() != null)        return false;    boolean result = true;    switch(schema.getType()) {        case RECORD:            for (Schema.Field f : schema.getFields()) result &= isCustomCodable(f.schema(), seen);            break;        case MAP:            result = isCustomCodable(schema.getValueType(), seen);            break;        case ARRAY:            result = isCustomCodable(schema.getElementType(), seen);            break;        case UNION:            List<Schema> types = schema.getTypes();                        if (types.size() != 2 || !types.contains(NULL_SCHEMA))                return false;            for (Schema s : types) result &= isCustomCodable(s, seen);            break;        default:    }    return result;}
6cec06928b65ae9ed1604d09128a85a7518ea47aa91fda436534ad828b8bab2c
hasLogicalTypeField
public boolean hasLogicalTypeField(Schema schema)
{    for (Schema.Field field : schema.getFields()) {        if (field.schema().getLogicalType() != null) {            return true;        }    }    return false;}
53464264f9be6f7e3d8264c341183342e13fbfc6cca922fdadbe4babd463b39c
conversionInstance
public String conversionInstance(Schema schema)
{    if (schema == null || schema.getLogicalType() == null) {        return "null";    }    if (LogicalTypes.Decimal.class.equals(schema.getLogicalType().getClass()) && !enableDecimalLogicalType) {        return "null";    }    final Conversion<Object> conversion = specificData.getConversionFor(schema.getLogicalType());    if (conversion != null) {        return "new " + conversion.getClass().getCanonicalName() + "()";    }    return "null";}
e31a0cb2b235d5dad6f1c7f302f5293b69445de4d9bcefe7070ef84b5ee8802a
javaAnnotations
public String[] javaAnnotations(JsonProperties props)
{    final Object value = props.getObjectProp("javaAnnotation");    if (value == null)        return new String[0];    if (value instanceof String)        return new String[] { value.toString() };    if (value instanceof List) {        final List<?> list = (List<?>) value;        final List<String> annots = new ArrayList<>();        for (Object o : list) {            annots.add(o.toString());        }        return annots.toArray(new String[0]);    }    return new String[0];}
4e94bf9e5085c2665e943e85e1530c61aa56c6f61a130c997ce7f5de9b3b40a5
javaSplit
public String javaSplit(String s) throws IOException
{        StringBuilder b = new StringBuilder("\"");    for (int i = 0; i < s.length(); i += maxStringChars) {        if (i != 0)                        b.append("\",\"");        String chunk = s.substring(i, Math.min(s.length(), i + maxStringChars));                b.append(javaEscape(chunk));    }        b.append("\"");    return b.toString();}
7b7accb1b1318cc84bb06f0f6b05980ea22ac2eca8b490153adc26ddb858a136
javaEscape
public static String javaEscape(Object o)
{    return o.toString().replace("\\", "\\\\").replace("\"", "\\\"");}
fe4a3883ad3863d496333df64e2e3cf0d1c1afc4a5b7d10aaeca083760c749b6
escapeForJavadoc
public static String escapeForJavadoc(String s)
{    return s.replace("*/", "*&#47;");}
1cf925ef67020805df44058dad92ef33cd8d83b7b66613bde23c3b4cf391e8ef
nullToEmpty
public static String nullToEmpty(String x)
{    return x == null ? "" : x;}
25353e3544f732ce265152ccd89d34dc8e8e0896c58b6ee86d5550d32d23b2ad
mangle
public static String mangle(String word)
{    return mangle(word, false);}
e04783a137029b223953d845bdef3939dbfd289f860f10e2ac136f773df9306a
mangle
public static String mangle(String word, boolean isError)
{    return mangle(word, isError ? ERROR_RESERVED_WORDS : RESERVED_WORDS);}
dac01985d6d9705f63a7b01fbc19754a16257b907b1d08ffcfc525dd9c4cec8c
mangle
public static String mangle(String word, Set<String> reservedWords)
{    return mangle(word, reservedWords, false);}
93404906128491a369f36854c5dbb2ec853372f92640cdad598fac4352b40d41
mangle
public static String mangle(String word, Set<String> reservedWords, boolean isMethod)
{    if (word.contains(".")) {                        int lastDot = word.lastIndexOf(".");        String packageName = word.substring(0, lastDot + 1);        String className = word.substring(lastDot + 1);        return packageName + mangle(className, reservedWords, isMethod);    }    if (reservedWords.contains(word) || (isMethod && reservedWords.contains(Character.toLowerCase(word.charAt(0)) + ((word.length() > 1) ? word.substring(1) : "")))) {        return word + "$";    }    return word;}
ed64c47e41c3b0ed677cdde06d303ebd67683041d8e60a442c9e519329338659
fingerprint64
public static long fingerprint64(Schema schema)
{    return SchemaNormalization.parsingFingerprint64(schema);}
f471ed0d56f472273864c2753214d470a646e86bdb33f3d1895df82931ca5465
generateGetMethod
public static String generateGetMethod(Schema schema, Field field)
{    return generateMethodName(schema, field, "get", "");}
e64a55e06ad409cb3fbeae6b3beaa4e4fb0a174fd8316c43f722885c26812787
generateGetOptionalMethod
public static String generateGetOptionalMethod(Schema schema, Field field)
{    return generateMethodName(schema, field, "getOptional", "");}
d820053203972e473d4c5a366aa035467b7d6fadcf1f39dc126f33bcb7ac6691
generateSetMethod
public static String generateSetMethod(Schema schema, Field field)
{    return generateMethodName(schema, field, "set", "");}
e300b803e3361e8d3b8c829651256f432d39d097b59acfe08eac71b6977b115e
generateHasMethod
public static String generateHasMethod(Schema schema, Field field)
{    return generateMethodName(schema, field, "has", "");}
b0e515c94b612ba727b4cc39bda034a2f7e265bb7627a70e4bcdd40fa9710a43
generateClearMethod
public static String generateClearMethod(Schema schema, Field field)
{    return generateMethodName(schema, field, "clear", "");}
1646b6ca453e436254cfda5cfe785214fd8e6303f424ae790435edf8c87fe3e1
hasBuilder
public static boolean hasBuilder(Schema schema)
{    switch(schema.getType()) {        case RECORD:            return true;        case UNION:                        List<Schema> types = schema.getTypes();            if ((types.size() == 2) && types.contains(NULL_SCHEMA)) {                return hasBuilder(types.get(types.get(0).equals(NULL_SCHEMA) ? 1 : 0));            }            return false;        default:            return false;    }}
9a2ca3761f41846624d00b2aeff7d74c7f5b6698bb7ea4b4596c5122fe906e5d
generateGetBuilderMethod
public static String generateGetBuilderMethod(Schema schema, Field field)
{    return generateMethodName(schema, field, "get", "Builder");}
39a65d81e7ebc0c38b490e6171b8107b187f0ec82348f5a93064bd3db6b0d053
generateSetBuilderMethod
public static String generateSetBuilderMethod(Schema schema, Field field)
{    return generateMethodName(schema, field, "set", "Builder");}
d335107305b7228fbc9e3990b8b5dac0cae86b9ecbfcc4b8219d425c37b0faa0
generateHasBuilderMethod
public static String generateHasBuilderMethod(Schema schema, Field field)
{    return generateMethodName(schema, field, "has", "Builder");}
bae4a6f169210a537dddee22b2058fce66c1d8044b44d40d570e8ce4a31b8b6e
generateMethodName
private static String generateMethodName(Schema schema, Field field, String prefix, String postfix)
{            char firstChar = field.name().charAt(0);    String conflictingFieldName = (Character.isLowerCase(firstChar) ? Character.toUpperCase(firstChar) : Character.toLowerCase(firstChar)) + (field.name().length() > 1 ? field.name().substring(1) : "");    boolean fieldNameConflict = schema.getField(conflictingFieldName) != null;    StringBuilder methodBuilder = new StringBuilder(prefix);    String fieldName = mangle(field.name(), schema.isError() ? ERROR_RESERVED_WORDS : ACCESSOR_MUTATOR_RESERVED_WORDS, true);    boolean nextCharToUpper = true;    for (int ii = 0; ii < fieldName.length(); ii++) {        if (fieldName.charAt(ii) == '_') {            nextCharToUpper = true;        } else if (nextCharToUpper) {            methodBuilder.append(Character.toUpperCase(fieldName.charAt(ii)));            nextCharToUpper = false;        } else {            methodBuilder.append(fieldName.charAt(ii));        }    }    methodBuilder.append(postfix);        if (fieldNameConflict) {        if (methodBuilder.charAt(methodBuilder.length() - 1) != '$') {            methodBuilder.append('$');        }        methodBuilder.append(Character.isLowerCase(firstChar) ? '0' : '1');    }    return methodBuilder.toString();}
998f2031b7b2e28e1566a1b78aaacec7e420e2a2f8cbb4c5161e7fe5363cdca2
isUnboxedJavaTypeNullable
public static boolean isUnboxedJavaTypeNullable(Schema schema)
{    switch(schema.getType()) {                case INT:        case LONG:        case FLOAT:        case DOUBLE:        case BOOLEAN:            return false;        default:            return true;    }}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{        compileProtocol(new File(args[0]), new File(args[1]));}
83556d504cf8449425e125c1c3c308cd8b76fd48e6033d9d5d81290d2fa11600
setOutputCharacterEncoding
public void setOutputCharacterEncoding(String outputCharacterEncoding)
{    this.outputCharacterEncoding = outputCharacterEncoding;}
47ddeb7d01b23b720cbbd1f6cc84dbcf2afba122df549c746f12f8595747c11a
testCycleGeneration
public void testCycleGeneration() throws ParseException, IOException
{    final ClassLoader cl = Thread.currentThread().getContextClassLoader();    Idl idl = new Idl(cl.getResourceAsStream("input/cycle.avdl"), "UTF-8");    Protocol protocol = idl.CompilationUnit();    String json = protocol.toString();    LOG.info(json);    SpecificCompiler compiler = new SpecificCompiler(protocol);    compiler.setStringType(GenericData.StringType.String);    File output = new File("./target");    compiler.compileToDestination(null, output);    Map<String, Schema> schemas = new HashMap<>();    for (Schema schema : protocol.getTypes()) {        final String name = schema.getName();        schemas.put(name, schema);    }    GenericRecordBuilder rb2 = new GenericRecordBuilder(schemas.get("SampleNode"));    rb2.set("count", 10);    rb2.set("subNodes", Collections.EMPTY_LIST);    GenericData.Record node = rb2.build();    GenericRecordBuilder mb = new GenericRecordBuilder(schemas.get("Method"));    mb.set("declaringClass", "Test");    mb.set("methodName", "test");    GenericData.Record method = mb.build();    GenericRecordBuilder spb = new GenericRecordBuilder(schemas.get("SamplePair"));    spb.set("method", method);    spb.set("node", node);    GenericData.Record sp = spb.build();    GenericRecordBuilder rb = new GenericRecordBuilder(schemas.get("SampleNode"));    rb.set("count", 10);    rb.set("subNodes", Collections.singletonList(sp));    GenericData.Record record = rb.build();    serDeserRecord(record);}
a7cd6f7b2afca68452df2d942c951c6bdd10d34a2d9b13de4332958a2cc79e76
serDeserRecord
private static void serDeserRecord(GenericData.Record data) throws IOException
{    ByteArrayOutputStream bab = new ByteArrayOutputStream();    GenericDatumWriter writer = new GenericDatumWriter(data.getSchema());    final BinaryEncoder directBinaryEncoder = EncoderFactory.get().directBinaryEncoder(bab, null);    writer.write(data, directBinaryEncoder);    directBinaryEncoder.flush();    ByteArrayInputStream bis = new ByteArrayInputStream(bab.toByteArray(), 0, bab.size());    GenericDatumReader reader = new GenericDatumReader(data.getSchema());    BinaryDecoder directBinaryDecoder = DecoderFactory.get().directBinaryDecoder(bis, null);    GenericData.Record read = (GenericData.Record) reader.read(null, directBinaryDecoder);    Assert.assertEquals(data.toString(), read.toString());}
8f414ed0e364598a4c9817b960dc64d21931d3a24b3454bd3a2ab1a1ec828815
loadTests
public void loadTests()
{    assertTrue(TEST_DIR.exists());    assertTrue(TEST_INPUT_DIR.exists());    assertTrue(TEST_OUTPUT_DIR.exists());    tests = new ArrayList<>();    for (File inF : TEST_INPUT_DIR.listFiles()) {        if (!inF.getName().endsWith(".avdl"))            continue;        if (inF.getName().startsWith("."))            continue;        File outF = new File(TEST_OUTPUT_DIR, inF.getName().replaceFirst("\\.avdl$", ".avpr"));        tests.add(new GenTest(inF, outF));    }}
8b274e17f719b4dcb2d021e6f18ce533e0bd38a3f4a78f0120a5e90c3cdf65d2
runTests
public void runTests() throws Exception
{    if (!"run".equals(TEST_MODE))        return;    int passed = 0, failed = 0;    for (GenTest t : tests) {        try {            t.run();            passed++;        } catch (Exception e) {            failed++;            System.err.println("Failed: " + t.testName());            e.printStackTrace(System.err);        }    }    if (failed > 0) {        fail(String.valueOf(failed) + " tests failed");    }}
c89b22195f8dcc88156a985a9c48277e0e689deaf30d3fb0f19de0914689e3ba
writeTests
public void writeTests() throws Exception
{    if (!"write".equals(TEST_MODE))        return;    for (GenTest t : tests) {        t.write();    }}
d8a769722d36cc3d8011b23f63abf15adc95da87285be2783347440c6eac2dbe
generate
private String generate() throws Exception
{    ClassLoader cl = Thread.currentThread().getContextClassLoader();        File file = new File(".");    String currentWorkPath = file.toURI().toURL().toString();    String newPath = currentWorkPath + "src" + File.separator + "test" + File.separator + "idl" + File.separator + "putOnClassPath" + File.separator;    URL[] newPathURL = new URL[] { new URL(newPath) };    URLClassLoader ucl = new URLClassLoader(newPathURL, cl);    Idl parser = new Idl(in, ucl);    Protocol p = parser.CompilationUnit();    parser.close();    return p.toString();}
46e90e08e84b1f73e1d8dcea797c78e4b5c18ec243de4aab1036e009d70eb6eb
testName
public String testName()
{    return this.in.getName();}
2aba2796d23ccdc848a9f114e1d4e2f8f3328e9c2e4503e11cac4130f18f63ff
run
public void run() throws Exception
{    String output = generate();    String slurped = slurp(expectedOut);    assertEquals(slurped.trim(), output.replace("\\r", "").trim());}
a0a63f3a6d4a14b2e08f52a91b0878b1c1b7afe1605920d1e034263ee8242241
write
public void write() throws Exception
{    writeFile(expectedOut, generate());}
2ecb507a7686b755284e17de4e77e22e78b6117e5b83863006548e8e7e47389c
slurp
private static String slurp(File f) throws IOException
{    BufferedReader in = new BufferedReader(new InputStreamReader(new FileInputStream(f), "UTF-8"));    String line = null;    StringBuilder builder = new StringBuilder();    while ((line = in.readLine()) != null) {        builder.append(line);    }    in.close();    ObjectMapper mapper = new ObjectMapper();    JsonNode json = mapper.readTree(builder.toString());    return mapper.writer().writeValueAsString(json);}
b5e20884fe68c9f702e9a82acc3235261499e5893cf6cd8a913c651ca436595e
writeFile
private static void writeFile(File f, String s) throws IOException
{    FileWriter w = new FileWriter(f);    w.write(s);    w.close();}
e776cd691b868aa960e1f746de9fb86b5cf3d1a6287eaa85f969d27b430d949b
testResolving
public void testResolving() throws ParseException, MalformedURLException, IOException
{    File file = new File(".");    String currentWorkPath = file.getAbsolutePath();    String testIdl = currentWorkPath + File.separator + "src" + File.separator + "test" + File.separator + "idl" + File.separator + "cycle.avdl";    Idl compiler = new Idl(new File(testIdl));    Protocol protocol = compiler.CompilationUnit();    System.out.println(protocol);    Assert.assertEquals(5, protocol.getTypes().size());}
fad05bb46430eff59da32785cbcc3fd528007d6726cfd3a1a5ac31b6a5ddfded
testIsUnresolvedSchemaError1
public void testIsUnresolvedSchemaError1()
{        Schema s = SchemaBuilder.record("R").fields().endRecord();    SchemaResolver.getUnresolvedSchemaName(s);}
88ae6bdf77f8daedb8ca118a0af0bae9143419655f33080944f5618e798e12bc
testIsUnresolvedSchemaError2
public void testIsUnresolvedSchemaError2()
{        Schema s = SchemaBuilder.record("R").prop("org.apache.avro.compiler.idl.unresolved.name", "x").fields().endRecord();    SchemaResolver.getUnresolvedSchemaName(s);}
cbc7b55de553de96b1edd27d06ecc7622a145fb03aac83b978eb2dc812d9643b
testIsUnresolvedSchemaError3
public void testIsUnresolvedSchemaError3()
{        Schema s = SchemaBuilder.record("UnresolvedSchema").prop("org.apache.avro.compiler.idl.unresolved.name", "x").fields().endRecord();    SchemaResolver.getUnresolvedSchemaName(s);}
13e4dbb5cecc74428de7568ae219927b8eba2c073d92acfc78dad524aa266c12
testGetUnresolvedSchemaNameError
public void testGetUnresolvedSchemaNameError()
{    Schema s = SchemaBuilder.fixed("a").size(10);    SchemaResolver.getUnresolvedSchemaName(s);}
410c5535db53ad9094a629f26fa1affb90e3b55375f8773d775c9ff01e38ee83
visitTerminal
public SchemaVisitorAction visitTerminal(Schema terminal)
{    System.out.println("Terminal: " + terminal.getFullName());    return SchemaVisitorAction.CONTINUE;}
2c678ce0c7418f01a1ab5ef818da74b76a850453a61b888ce8d6ef6694ac5f26
visitNonTerminal
public SchemaVisitorAction visitNonTerminal(Schema terminal)
{    System.out.println("NONTerminal start: " + terminal.getFullName());    return SchemaVisitorAction.CONTINUE;}
a81e8cc2607270b43dc5e57bf53469c5c65995700857ff9e921fe5d264971d8c
afterVisitNonTerminal
public SchemaVisitorAction afterVisitNonTerminal(Schema terminal)
{    System.out.println("NONTerminal end: " + terminal.getFullName());    return SchemaVisitorAction.CONTINUE;}
7879542e1c9692937bb06c057e45be2786184b48bff93d8e155d0e61dbdf105b
get
public Object get()
{    return null;}
fcbbdcb1025fc58c7397ba41c45b6f8142c638f69428459ec102cb9d4c4e33f3
textCloning
public void textCloning()
{    Schema recSchema = new Schema.Parser().parse(SCHEMA);    Schemas.visit(recSchema, new PrintingVisitor());    CloningVisitor cv = new CloningVisitor(recSchema);    Schema trimmed = Schemas.visit(recSchema, cv);    Assert.assertNull(trimmed.getDoc());    Assert.assertNotNull(recSchema.getDoc());    SchemaCompatibility.SchemaCompatibilityType compat = SchemaCompatibility.checkReaderWriterCompatibility(trimmed, recSchema).getType();    Assert.assertEquals(SchemaCompatibility.SchemaCompatibilityType.COMPATIBLE, compat);    compat = SchemaCompatibility.checkReaderWriterCompatibility(recSchema, trimmed).getType();    Assert.assertEquals(SchemaCompatibility.SchemaCompatibilityType.COMPATIBLE, compat);    Assert.assertNotNull(cv.toString());}
c059dc3d635ca04964399cfea1699962232acf1b6c862340bc546cdd123185fc
textCloningCopyDocs
public void textCloningCopyDocs()
{    Schema recSchema = new Schema.Parser().parse(SCHEMA);    Schemas.visit(recSchema, new PrintingVisitor());    Schema trimmed = Schemas.visit(recSchema, new CloningVisitor(new CloningVisitor.PropertyCopier() {        @Override        public void copy(final Schema first, final Schema second) {            Schemas.copyLogicalTypes(first, second);            Schemas.copyAliases(first, second);        }        @Override        public void copy(final Schema.Field first, final Schema.Field second) {            Schemas.copyAliases(first, second);        }    }, true, recSchema));    Assert.assertEquals("caca", trimmed.getDoc());    Assert.assertNotNull(recSchema.getDoc());    SchemaCompatibility.SchemaCompatibilityType compat = SchemaCompatibility.checkReaderWriterCompatibility(trimmed, recSchema).getType();    Assert.assertEquals(SchemaCompatibility.SchemaCompatibilityType.COMPATIBLE, compat);    compat = SchemaCompatibility.checkReaderWriterCompatibility(recSchema, trimmed).getType();    Assert.assertEquals(SchemaCompatibility.SchemaCompatibilityType.COMPATIBLE, compat);}
dc09f1abbb7e8d64dad6fcb17048e23df0962ec99a33691d6a12e9322dee1a4b
copy
public void copy(final Schema first, final Schema second)
{    Schemas.copyLogicalTypes(first, second);    Schemas.copyAliases(first, second);}
d282a4ab425d3ca2efc6e38388c2e2df47775af9616080d5b995c04c58464a74
copy
public void copy(final Schema.Field first, final Schema.Field second)
{    Schemas.copyAliases(first, second);}
cb1b7d8a1555d846cd4ecb796faa05190fe35749e0bb09a2dc5edb4e2ef4bada
testCloningError1
public void testCloningError1()
{        Schema recordSchema = new Schema.Parser().parse("{\"type\": \"record\", \"name\": \"R\", \"fields\":[{\"name\": \"f1\", \"type\": [\"int\", \"long\"]}]}");    new CloningVisitor(recordSchema).visitTerminal(recordSchema.getField("f1").schema());}
33da326bafe257f5c4421e8442eb643cf2e2e2d93a1e779886d8cd84e39aa4a5
testCloningError2
public void testCloningError2()
{        Schema recordSchema = new Schema.Parser().parse("{\"type\": \"record\", \"name\": \"R\", \"fields\":[{\"name\": \"f1\", \"type\": \"int\"}]}");    new CloningVisitor(recordSchema).afterVisitNonTerminal(recordSchema.getField("f1").schema());}
73e932db0d4653def56a96dc8f25375949ad15af6b7ee2bb70e7a15719a70592
testHasGeneratedJavaClass
public void testHasGeneratedJavaClass()
{    Assert.assertTrue(Schemas.hasGeneratedJavaClass(new Schema.Parser().parse("{\"type\": \"fixed\", \"name\": \"N\", \"size\": 10}")));    Assert.assertFalse(Schemas.hasGeneratedJavaClass(new Schema.Parser().parse("{\"type\": \"int\"}")));}
07dd16f894c6f5ec3e9b89d53d56dc2939e1e9437264bf08d514d9b4c45e7a82
testGetJavaClassName
public void testGetJavaClassName()
{    Assert.assertEquals("N", Schemas.getJavaClassName(new Schema.Parser().parse("{\"type\": \"fixed\", \"name\": \"N\", \"size\": 10}")));    Assert.assertEquals("N", Schemas.getJavaClassName(new Schema.Parser().parse("{\"type\": \"fixed\", \"name\": \"N\", \"size\": 10, \"namespace\": \"\"}")));    Assert.assertEquals("com.example.N", Schemas.getJavaClassName(new Schema.Parser().parse("{\"type\": \"fixed\", \"name\": \"N\", \"size\": 10, \"namespace\": \"com.example\"}")));}
410c5535db53ad9094a629f26fa1affb90e3b55375f8773d775c9ff01e38ee83
visitTerminal
public SchemaVisitorAction visitTerminal(Schema terminal)
{    sb.append(terminal);    return SchemaVisitorAction.CONTINUE;}
c1fc1f73e63fcf7357613131a352b5046b613c02437ca80de1ec05e9f1feb55a
visitNonTerminal
public SchemaVisitorAction visitNonTerminal(Schema nonTerminal)
{    String n = nonTerminal.getName();    sb.append(n).append('.');    if (n.startsWith("t")) {        return SchemaVisitorAction.TERMINATE;    } else if (n.startsWith("ss")) {        return SchemaVisitorAction.SKIP_SIBLINGS;    } else if (n.startsWith("st")) {        return SchemaVisitorAction.SKIP_SUBTREE;    } else {        return SchemaVisitorAction.CONTINUE;    }}
a3c1580193e940c8c33c9bf2f8448b2676155d7fba29eabf87c243dfc944603e
afterVisitNonTerminal
public SchemaVisitorAction afterVisitNonTerminal(Schema nonTerminal)
{    sb.append("!");    String n = nonTerminal.getName();    if (n.startsWith("ct")) {        return SchemaVisitorAction.TERMINATE;    } else if (n.startsWith("css")) {        return SchemaVisitorAction.SKIP_SIBLINGS;    } else if (n.startsWith("cst")) {        return SchemaVisitorAction.SKIP_SUBTREE;    } else {        return SchemaVisitorAction.CONTINUE;    }}
3bdfb82158e514af8fa8e4bf41a4e69a6b9317d48597b72409f899318865ae1b
get
public String get()
{    return sb.toString();}
b3c138d34f3d32c1dfa80d170fd39028140dae847be66b32c3361115da98bbf4
testVisit1
public void testVisit1()
{    String s1 = "{\"type\": \"record\", \"name\": \"t1\", \"fields\": [" + "{\"name\": \"f1\", \"type\": \"int\"}" + "]}";    Assert.assertEquals("t1.", Schemas.visit(new Schema.Parser().parse(s1), new TestVisitor()));}
500c6e7d5fa785d098b212ecce177789631d3da9db841e8105194dc3ed10b4ae
testVisit2
public void testVisit2()
{    String s2 = "{\"type\": \"record\", \"name\": \"c1\", \"fields\": [" + "{\"name\": \"f1\", \"type\": \"int\"}" + "]}";    Assert.assertEquals("c1.\"int\"!", Schemas.visit(new Schema.Parser().parse(s2), new TestVisitor()));}
b499b3c586d90bb8a9555681e787947c239bb4554dcd0bbb9ec2098ddaeb26f4
testVisit3
public void testVisit3()
{    String s3 = "{\"type\": \"record\", \"name\": \"ss1\", \"fields\": [" + "{\"name\": \"f1\", \"type\": \"int\"}" + "]}";    Assert.assertEquals("ss1.", Schemas.visit(new Schema.Parser().parse(s3), new TestVisitor()));}
35a26d49b77977d08d1a3d99ace92b1b748741a2c0e650e47ac59d4127ccb07d
testVisit4
public void testVisit4()
{    String s4 = "{\"type\": \"record\", \"name\": \"st1\", \"fields\": [" + "{\"name\": \"f1\", \"type\": \"int\"}" + "]}";    Assert.assertEquals("st1.!", Schemas.visit(new Schema.Parser().parse(s4), new TestVisitor()));}
554a4c386277d891e1fc80db645686d53f125e4309230ca6ae1bdd27ff2087a4
testVisit5
public void testVisit5()
{    String s5 = "{\"type\": \"record\", \"name\": \"c1\", \"fields\": [" + "{\"name\": \"f1\", \"type\": {\"type\": \"record\", \"name\": \"c2\", \"fields\": " + "[{\"name\": \"f11\", \"type\": \"int\"}]}}," + "{\"name\": \"f2\", \"type\": \"long\"}" + "]}";    Assert.assertEquals("c1.c2.\"int\"!\"long\"!", Schemas.visit(new Schema.Parser().parse(s5), new TestVisitor()));}
a4bb1331a29ed95e202307da8aa3e5d7823723c73ef32c57b884aae46fb62fd2
testVisit6
public void testVisit6()
{    String s6 = "{\"type\": \"record\", \"name\": \"c1\", \"fields\": [" + "{\"name\": \"f1\", \"type\": {\"type\": \"record\", \"name\": \"ss2\", \"fields\": " + "[{\"name\": \"f11\", \"type\": \"int\"}]}}," + "{\"name\": \"f2\", \"type\": \"long\"}" + "]}";    Assert.assertEquals("c1.ss2.!", Schemas.visit(new Schema.Parser().parse(s6), new TestVisitor()));}
7c97b9c1a8620cb1882e40e3509cd46aa4383569c914aa23b26cbfde1c81e061
testVisit7
public void testVisit7()
{    String s7 = "{\"type\": \"record\", \"name\": \"c1\", \"fields\": [" + "{\"name\": \"f1\", \"type\": {\"type\": \"record\", \"name\": \"css2\", \"fields\": " + "[{\"name\": \"f11\", \"type\": \"int\"}]}}," + "{\"name\": \"f2\", \"type\": \"long\"}" + "]}";    Assert.assertEquals("c1.css2.\"int\"!!", Schemas.visit(new Schema.Parser().parse(s7), new TestVisitor()));}
11de586b0fdbbe7aeb2fe82935006bf1467f686a25180f600a8c5ec79b0822b9
testVisit8
public void testVisit8()
{    String s8 = "{\"type\": \"record\", \"name\": \"c1\", \"fields\": [" + "{\"name\": \"f1\", \"type\": {\"type\": \"record\", \"name\": \"cst2\", \"fields\": " + "[{\"name\": \"f11\", \"type\": \"int\"}]}}," + "{\"name\": \"f2\", \"type\": \"int\"}" + "]}";    Schemas.visit(new Schema.Parser().parse(s8), new TestVisitor());}
f0fe7cbbefb96b5c5ad4b54be7c06d7877135b3330fa49106d18043b82ecb8e0
testVisit9
public void testVisit9()
{    String s9 = "{\"type\": \"record\", \"name\": \"c1\", \"fields\": [" + "{\"name\": \"f1\", \"type\": {\"type\": \"record\", \"name\": \"ct2\", \"fields\": " + "[{\"name\": \"f11\", \"type\": \"int\"}]}}," + "{\"name\": \"f2\", \"type\": \"long\"}" + "]}";    Assert.assertEquals("c1.ct2.\"int\"!", Schemas.visit(new Schema.Parser().parse(s9), new TestVisitor()));}
d015c637b267812bbd8bd3de4551ffd9dd96ba1a6716ff5f0b25110f3605125a
testVisit10
public void testVisit10()
{    String s10 = "{\"type\": \"record\", \"name\": \"c1\", \"fields\": [" + "{\"name\": \"f1\", \"type\": {\"type\": \"record\", \"name\": \"ct2\", \"fields\": " + "[{\"name\": \"f11\", \"type\": \"int\"}]}}," + "{\"name\": \"f2\", \"type\": \"int\"}" + "]}";    Schemas.visit(new Schema.Parser().parse(s10), new TestVisitor() {        public SchemaVisitorAction visitTerminal(Schema terminal) {            return SchemaVisitorAction.SKIP_SUBTREE;        }    });}
410c5535db53ad9094a629f26fa1affb90e3b55375f8773d775c9ff01e38ee83
visitTerminal
public SchemaVisitorAction visitTerminal(Schema terminal)
{    return SchemaVisitorAction.SKIP_SUBTREE;}
d2b3ed6b10efa5f1d494542d51cf8611b7827d8a0fff8a923dd067131f863193
testVisit11
public void testVisit11()
{    String s11 = "{\"type\": \"record\", \"name\": \"c1\", \"fields\": [" + "{\"name\": \"f1\", \"type\": {\"type\": \"record\", \"name\": \"c2\", \"fields\": " + "[{\"name\": \"f11\", \"type\": \"int\"},{\"name\": \"f12\", \"type\": \"double\"}" + "]}}," + "{\"name\": \"f2\", \"type\": \"long\"}" + "]}";    Assert.assertEquals("c1.c2.\"int\".!\"long\".!", Schemas.visit(new Schema.Parser().parse(s11), new TestVisitor() {        public SchemaVisitorAction visitTerminal(Schema terminal) {            sb.append(terminal).append('.');            return SchemaVisitorAction.SKIP_SIBLINGS;        }    }));}
410c5535db53ad9094a629f26fa1affb90e3b55375f8773d775c9ff01e38ee83
visitTerminal
public SchemaVisitorAction visitTerminal(Schema terminal)
{    sb.append(terminal).append('.');    return SchemaVisitorAction.SKIP_SIBLINGS;}
01679ea2cfca10cc17fab347f4de45b22d51ddb68e45e4e7152dd3ad5a3afbf2
testVisit12
public void testVisit12()
{    String s12 = "{\"type\": \"record\", \"name\": \"c1\", \"fields\": [" + "{\"name\": \"f1\", \"type\": {\"type\": \"record\", \"name\": \"ct2\", \"fields\": " + "[{\"name\": \"f11\", \"type\": \"int\"}]}}," + "{\"name\": \"f2\", \"type\": \"long\"}" + "]}";    Assert.assertEquals("c1.ct2.\"int\".", Schemas.visit(new Schema.Parser().parse(s12), new TestVisitor() {        public SchemaVisitorAction visitTerminal(Schema terminal) {            sb.append(terminal).append('.');            return SchemaVisitorAction.TERMINATE;        }    }));}
410c5535db53ad9094a629f26fa1affb90e3b55375f8773d775c9ff01e38ee83
visitTerminal
public SchemaVisitorAction visitTerminal(Schema terminal)
{    sb.append(terminal).append('.');    return SchemaVisitorAction.TERMINATE;}
20b9e2d51d4c99d0ae4fef929c8aa88b4919a3567237aafbb3c48e31bb5ece09
testVisit13
public void testVisit13()
{    String s12 = "{\"type\": \"int\"}";    Assert.assertEquals("\"int\".", Schemas.visit(new Schema.Parser().parse(s12), new TestVisitor() {        public SchemaVisitorAction visitTerminal(Schema terminal) {            sb.append(terminal).append('.');            return SchemaVisitorAction.SKIP_SIBLINGS;        }    }));}
410c5535db53ad9094a629f26fa1affb90e3b55375f8773d775c9ff01e38ee83
visitTerminal
public SchemaVisitorAction visitTerminal(Schema terminal)
{    sb.append(terminal).append('.');    return SchemaVisitorAction.SKIP_SIBLINGS;}
4adaefafec562702d887f5960a1408e5f9d1add92c42fab7cb857d701c42d2a2
setUp
public void setUp()
{    this.outputFile = new File(this.OUTPUT_DIR.getRoot(), "SimpleRecord.java");}
c220a8adedf6b07409435568d8de0288db4d7b33b4f8e452162d951cd80cfa9c
assertCompilesWithJavaCompiler
 static void assertCompilesWithJavaCompiler(File dstDir, Collection<SpecificCompiler.OutputFile> outputs) throws IOException
{    assertCompilesWithJavaCompiler(dstDir, outputs, false);}
916c0f7fd6ccf2a2709a6ac1a00b1ca475ccfd0f9a7fba917db8bab7e82d4ba8
assertCompilesWithJavaCompiler
 static void assertCompilesWithJavaCompiler(File dstDir, Collection<SpecificCompiler.OutputFile> outputs, boolean ignoreWarnings) throws IOException
{    if (outputs.isEmpty()) {                return;    }    JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();    StandardJavaFileManager fileManager = compiler.getStandardFileManager(null, null, null);    List<File> javaFiles = new ArrayList<>();    for (SpecificCompiler.OutputFile o : outputs) {        javaFiles.add(o.writeToDestination(null, dstDir));    }    final List<Diagnostic<?>> warnings = new ArrayList<>();    DiagnosticListener<JavaFileObject> diagnosticListener = diagnostic -> {        switch(diagnostic.getKind()) {            case ERROR:                                LOG.error("{}", diagnostic);                break;            case WARNING:            case MANDATORY_WARNING:                LOG.warn("{}", diagnostic);                warnings.add(diagnostic);                break;            case NOTE:            case OTHER:                LOG.debug("{}", diagnostic);                break;        }    };    JavaCompiler.CompilationTask cTask = compiler.getTask(null, fileManager, diagnosticListener, Collections.singletonList("-Xlint:all"), null, fileManager.getJavaFileObjects(javaFiles.toArray(new File[0])));    boolean compilesWithoutError = cTask.call();    assertTrue(compilesWithoutError);    if (!ignoreWarnings) {        assertEquals("Warnings produced when compiling generated code with -Xlint:all", 0, warnings.size());    }}
a4ba3a2980a5658406fa7fcc72786bf279ddf60a689d892fc5cc556d620a9633
createSampleRecordSchema
private static Schema createSampleRecordSchema(int numStringFields, int numDoubleFields)
{    SchemaBuilder.FieldAssembler<Schema> sb = SchemaBuilder.record("sample.record").fields();    for (int i = 0; i < numStringFields; i++) {        sb.name("sf_" + i).type().stringType().noDefault();    }    for (int i = 0; i < numDoubleFields; i++) {        sb.name("df_" + i).type().doubleType().noDefault();    }    return sb.endRecord();}
cfc9c456a4296fa00756aea604e43d3c69ffb58c385436b75a2d032dde228d56
createCompiler
private SpecificCompiler createCompiler() throws IOException
{    Schema.Parser parser = new Schema.Parser();    Schema schema = parser.parse(this.src);    SpecificCompiler compiler = new SpecificCompiler(schema);    String velocityTemplateDir = "src/main/velocity/org/apache/avro/compiler/specific/templates/java/classic/";    compiler.setTemplateDir(velocityTemplateDir);    compiler.setStringType(StringType.CharSequence);    return compiler;}
7f912fde8522048c5e3ed3c4f9ae53c0601e38fe2b99056e3765f318dd120c3f
testCanReadTemplateFilesOnTheFilesystem
public void testCanReadTemplateFilesOnTheFilesystem() throws IOException
{    SpecificCompiler compiler = createCompiler();    compiler.compileToDestination(this.src, OUTPUT_DIR.getRoot());    assertTrue(new File(OUTPUT_DIR.getRoot(), "SimpleRecord.java").exists());}
6d3778cfa45412a4a1ea2e1d08d7391349bc362ecacae8a0c0d43c8509b4f96c
testPublicFieldVisibility
public void testPublicFieldVisibility() throws IOException
{    SpecificCompiler compiler = createCompiler();    compiler.setFieldVisibility(SpecificCompiler.FieldVisibility.PUBLIC);    assertFalse(compiler.deprecatedFields());    assertTrue(compiler.publicFields());    assertFalse(compiler.privateFields());    compiler.compileToDestination(this.src, this.OUTPUT_DIR.getRoot());    assertTrue(this.outputFile.exists());    try (BufferedReader reader = new BufferedReader(new FileReader(this.outputFile))) {        String line;        while ((line = reader.readLine()) != null) {                                                line = line.trim();            assertFalse("Line started with a deprecated field declaration: " + line, line.startsWith("@Deprecated public int value"));        }    }}
bc3d6c23709bc39a728e36b2138ea6278d89c47118083733e7253640c8f486e9
testCreateAllArgsConstructor
public void testCreateAllArgsConstructor() throws Exception
{    SpecificCompiler compiler = createCompiler();    compiler.compileToDestination(this.src, this.OUTPUT_DIR.getRoot());    assertTrue(this.outputFile.exists());    boolean foundAllArgsConstructor = false;    try (BufferedReader reader = new BufferedReader(new FileReader(this.outputFile))) {        String line;        while (!foundAllArgsConstructor && (line = reader.readLine()) != null) {            foundAllArgsConstructor = line.contains("All-args constructor");        }    }    assertTrue(foundAllArgsConstructor);}
944bc534e24fa803c87e0448e6fdf5f7bccc79c354c5e122f2286fed23d13891
testMaxValidParameterCounts
public void testMaxValidParameterCounts() throws Exception
{    Schema validSchema1 = createSampleRecordSchema(SpecificCompiler.MAX_FIELD_PARAMETER_UNIT_COUNT, 0);    assertCompilesWithJavaCompiler(new File(OUTPUT_DIR.getRoot(), name.getMethodName() + "1"), new SpecificCompiler(validSchema1).compile());    Schema validSchema2 = createSampleRecordSchema(SpecificCompiler.MAX_FIELD_PARAMETER_UNIT_COUNT - 2, 1);    assertCompilesWithJavaCompiler(new File(OUTPUT_DIR.getRoot(), name.getMethodName() + "2"), new SpecificCompiler(validSchema1).compile());}
e61dadcc7d317c08ca81c3de48b754b4ec2b831c06affd88709565df4cdf5479
testInvalidParameterCounts
public void testInvalidParameterCounts() throws Exception
{    Schema invalidSchema1 = createSampleRecordSchema(SpecificCompiler.MAX_FIELD_PARAMETER_UNIT_COUNT + 1, 0);    SpecificCompiler compiler = new SpecificCompiler(invalidSchema1);    assertCompilesWithJavaCompiler(new File(OUTPUT_DIR.getRoot(), name.getMethodName() + "1"), compiler.compile());    Schema invalidSchema2 = createSampleRecordSchema(SpecificCompiler.MAX_FIELD_PARAMETER_UNIT_COUNT, 10);    compiler = new SpecificCompiler(invalidSchema2);    assertCompilesWithJavaCompiler(new File(OUTPUT_DIR.getRoot(), name.getMethodName() + "2"), compiler.compile());}
311643e6bf61c11172934e31faf4ed15032c0dc68a537ee7edf91bbdc6cefca3
testMaxParameterCounts
public void testMaxParameterCounts() throws Exception
{    Schema validSchema1 = createSampleRecordSchema(SpecificCompiler.MAX_FIELD_PARAMETER_UNIT_COUNT, 0);    assertTrue(new SpecificCompiler(validSchema1).compile().size() > 0);    Schema validSchema2 = createSampleRecordSchema(SpecificCompiler.MAX_FIELD_PARAMETER_UNIT_COUNT - 2, 1);    assertTrue(new SpecificCompiler(validSchema2).compile().size() > 0);    Schema validSchema3 = createSampleRecordSchema(SpecificCompiler.MAX_FIELD_PARAMETER_UNIT_COUNT - 1, 1);    assertTrue(new SpecificCompiler(validSchema3).compile().size() > 0);    Schema validSchema4 = createSampleRecordSchema(SpecificCompiler.MAX_FIELD_PARAMETER_UNIT_COUNT + 1, 0);    assertTrue(new SpecificCompiler(validSchema4).compile().size() > 0);}
43e99df4cb10f518da58cef7b529dc4a69fabf8721d4e2736958d212ab8043ef
testCalcAllArgConstructorParameterUnitsFailure
public void testCalcAllArgConstructorParameterUnitsFailure()
{    Schema nonRecordSchema = SchemaBuilder.array().items().booleanType();    new SpecificCompiler().calcAllArgConstructorParameterUnits(nonRecordSchema);}
3bcc1a30883de16f1979524eb9924528fab08e0042cd3cb9f65bde2ec5f679c1
testPublicDeprecatedFieldVisibility
public void testPublicDeprecatedFieldVisibility() throws IOException
{    SpecificCompiler compiler = createCompiler();    compiler.setFieldVisibility(SpecificCompiler.FieldVisibility.PUBLIC_DEPRECATED);    assertTrue(compiler.deprecatedFields());    assertTrue(compiler.publicFields());    assertFalse(compiler.privateFields());    compiler.compileToDestination(this.src, this.OUTPUT_DIR.getRoot());    assertTrue(this.outputFile.exists());    try (BufferedReader reader = new BufferedReader(new FileReader(this.outputFile))) {        String line;        while ((line = reader.readLine()) != null) {                        line = line.trim();            assertFalse("Line started with a public field declaration: " + line, line.startsWith("public int value"));        }    }}
4e7cb0e45fd3bccdd57405826acedf17493bba841395da1f92acb684c258fb8e
testPrivateFieldVisibility
public void testPrivateFieldVisibility() throws IOException
{    SpecificCompiler compiler = createCompiler();    compiler.setFieldVisibility(SpecificCompiler.FieldVisibility.PRIVATE);    assertFalse(compiler.deprecatedFields());    assertFalse(compiler.publicFields());    assertTrue(compiler.privateFields());    compiler.compileToDestination(this.src, this.OUTPUT_DIR.getRoot());    assertTrue(this.outputFile.exists());    try (BufferedReader reader = new BufferedReader(new FileReader(this.outputFile))) {        String line = null;        while ((line = reader.readLine()) != null) {                                    line = line.trim();            assertFalse("Line started with a public field declaration: " + line, line.startsWith("public int value"));            assertFalse("Line started with a deprecated field declaration: " + line, line.startsWith("@Deprecated public int value"));        }    }}
abb10bdf7a15ed652674cbb3861f9027446bd9036f521b484cc1c0e1ee8362bf
testSettersCreatedByDefault
public void testSettersCreatedByDefault() throws IOException
{    SpecificCompiler compiler = createCompiler();    assertTrue(compiler.isCreateSetters());    compiler.compileToDestination(this.src, this.OUTPUT_DIR.getRoot());    assertTrue(this.outputFile.exists());    int foundSetters = 0;    try (BufferedReader reader = new BufferedReader(new FileReader(this.outputFile))) {        String line;        while ((line = reader.readLine()) != null) {                        line = line.trim();            if (line.startsWith("public void setValue(")) {                foundSetters++;            }        }    }    assertEquals("Found the wrong number of setters", 1, foundSetters);}
efb60ba1a822b041eb95b72319c328cb14fdbe38f5b0086ee897bc183d81a932
testSettersNotCreatedWhenOptionTurnedOff
public void testSettersNotCreatedWhenOptionTurnedOff() throws IOException
{    SpecificCompiler compiler = createCompiler();    compiler.setCreateSetters(false);    assertFalse(compiler.isCreateSetters());    compiler.compileToDestination(this.src, this.OUTPUT_DIR.getRoot());    assertTrue(this.outputFile.exists());    try (BufferedReader reader = new BufferedReader(new FileReader(this.outputFile))) {        String line;        while ((line = reader.readLine()) != null) {                        line = line.trim();            assertFalse("No line should include the setter: " + line, line.startsWith("public void setValue("));        }    }}
14e204dbc63ceecb13dc7f2bcef9410f9075114752e74419efcfce2adb24329d
testSettingOutputCharacterEncoding
public void testSettingOutputCharacterEncoding() throws Exception
{    SpecificCompiler compiler = createCompiler();        compiler.compileToDestination(this.src, this.OUTPUT_DIR.getRoot());    byte[] fileInDefaultEncoding = new byte[(int) this.outputFile.length()];    FileInputStream is = new FileInputStream(this.outputFile);    is.read(fileInDefaultEncoding);        is.close();    if (!this.outputFile.delete()) {                throw new IllegalStateException("unable to delete " + this.outputFile);            }            String differentEncoding = Charset.defaultCharset().equals(Charset.forName("UTF-16")) ? "UTF-32" : "UTF-16";    compiler.setOutputCharacterEncoding(differentEncoding);    compiler.compileToDestination(this.src, this.OUTPUT_DIR.getRoot());    byte[] fileInDifferentEncoding = new byte[(int) this.outputFile.length()];    is = new FileInputStream(this.outputFile);    is.read(fileInDifferentEncoding);    is.close();        assertThat("Generated file should contain different bytes after setting non-default encoding", fileInDefaultEncoding, not(equalTo(fileInDifferentEncoding)));        assertThat("Generated files should contain the same characters in the proper encodings", new String(fileInDefaultEncoding), equalTo(new String(fileInDifferentEncoding, differentEncoding)));}
9a7fca344ccd468e4c865ffbf7f3d43db973ff576d71320985cc8ef66ac4e82c
testJavaTypeWithDecimalLogicalTypeEnabled
public void testJavaTypeWithDecimalLogicalTypeEnabled() throws Exception
{    SpecificCompiler compiler = createCompiler();    compiler.setEnableDecimalLogicalType(true);    Schema dateSchema = LogicalTypes.date().addToSchema(Schema.create(Schema.Type.INT));    Schema timeSchema = LogicalTypes.timeMillis().addToSchema(Schema.create(Schema.Type.INT));    Schema timestampSchema = LogicalTypes.timestampMillis().addToSchema(Schema.create(Schema.Type.LONG));    Schema decimalSchema = LogicalTypes.decimal(9, 2).addToSchema(Schema.create(Schema.Type.BYTES));    Schema uuidSchema = LogicalTypes.uuid().addToSchema(Schema.create(Schema.Type.STRING));                    Assert.assertEquals("Should use LocalDate for date type", "java.time.LocalDate", compiler.javaType(dateSchema));    Assert.assertEquals("Should use LocalTime for time-millis type", "java.time.LocalTime", compiler.javaType(timeSchema));    Assert.assertEquals("Should use DateTime for timestamp-millis type", "java.time.Instant", compiler.javaType(timestampSchema));    Assert.assertEquals("Should use Java BigDecimal type", "java.math.BigDecimal", compiler.javaType(decimalSchema));    Assert.assertEquals("Should use Java CharSequence type", "java.lang.CharSequence", compiler.javaType(uuidSchema));}
514b780e4b45c5b0b8b0dc17eb37517d2be3b74ed745c158bf8cd0d806b005e4
testJavaTypeWithDecimalLogicalTypeDisabled
public void testJavaTypeWithDecimalLogicalTypeDisabled() throws Exception
{    SpecificCompiler compiler = createCompiler();    compiler.setEnableDecimalLogicalType(false);    Schema dateSchema = LogicalTypes.date().addToSchema(Schema.create(Schema.Type.INT));    Schema timeSchema = LogicalTypes.timeMillis().addToSchema(Schema.create(Schema.Type.INT));    Schema timestampSchema = LogicalTypes.timestampMillis().addToSchema(Schema.create(Schema.Type.LONG));    Schema decimalSchema = LogicalTypes.decimal(9, 2).addToSchema(Schema.create(Schema.Type.BYTES));    Schema uuidSchema = LogicalTypes.uuid().addToSchema(Schema.create(Schema.Type.STRING));                    Assert.assertEquals("Should use LocalDate for date type", "java.time.LocalDate", compiler.javaType(dateSchema));    Assert.assertEquals("Should use LocalTime for time-millis type", "java.time.LocalTime", compiler.javaType(timeSchema));    Assert.assertEquals("Should use DateTime for timestamp-millis type", "java.time.Instant", compiler.javaType(timestampSchema));    Assert.assertEquals("Should use ByteBuffer type", "java.nio.ByteBuffer", compiler.javaType(decimalSchema));    Assert.assertEquals("Should use Java CharSequence type", "java.lang.CharSequence", compiler.javaType(uuidSchema));}
a5f8ac764da48c2b93dba6417757bf18c50f04dfd4506ce3405cb12dc78df3d7
testJavaTypeWithDateTimeTypes
public void testJavaTypeWithDateTimeTypes() throws Exception
{    SpecificCompiler compiler = createCompiler();    Schema dateSchema = LogicalTypes.date().addToSchema(Schema.create(Schema.Type.INT));    Schema timeSchema = LogicalTypes.timeMillis().addToSchema(Schema.create(Schema.Type.INT));    Schema timeMicrosSchema = LogicalTypes.timeMicros().addToSchema(Schema.create(Schema.Type.LONG));    Schema timestampSchema = LogicalTypes.timestampMillis().addToSchema(Schema.create(Schema.Type.LONG));    Schema timestampMicrosSchema = LogicalTypes.timestampMicros().addToSchema(Schema.create(Schema.Type.LONG));        Assert.assertEquals("Should use java.time.LocalDate for date type", "java.time.LocalDate", compiler.javaType(dateSchema));    Assert.assertEquals("Should use java.time.LocalTime for time-millis type", "java.time.LocalTime", compiler.javaType(timeSchema));    Assert.assertEquals("Should use java.time.Instant for timestamp-millis type", "java.time.Instant", compiler.javaType(timestampSchema));    Assert.assertEquals("Should use java.time.LocalTime for time-micros type", "java.time.LocalTime", compiler.javaType(timeMicrosSchema));    Assert.assertEquals("Should use java.time.Instant for timestamp-micros type", "java.time.Instant", compiler.javaType(timestampMicrosSchema));}
60100e5d41da4d3a056d6854010f4ba00d33f8b4f31c910732041ecc002ce923
testJavaUnbox
public void testJavaUnbox() throws Exception
{    SpecificCompiler compiler = createCompiler();    compiler.setEnableDecimalLogicalType(false);    Schema intSchema = Schema.create(Schema.Type.INT);    Schema longSchema = Schema.create(Schema.Type.LONG);    Schema floatSchema = Schema.create(Schema.Type.FLOAT);    Schema doubleSchema = Schema.create(Schema.Type.DOUBLE);    Schema boolSchema = Schema.create(Schema.Type.BOOLEAN);    Assert.assertEquals("Should use int for Type.INT", "int", compiler.javaUnbox(intSchema));    Assert.assertEquals("Should use long for Type.LONG", "long", compiler.javaUnbox(longSchema));    Assert.assertEquals("Should use float for Type.FLOAT", "float", compiler.javaUnbox(floatSchema));    Assert.assertEquals("Should use double for Type.DOUBLE", "double", compiler.javaUnbox(doubleSchema));    Assert.assertEquals("Should use boolean for Type.BOOLEAN", "boolean", compiler.javaUnbox(boolSchema));    Schema dateSchema = LogicalTypes.date().addToSchema(Schema.create(Schema.Type.INT));    Schema timeSchema = LogicalTypes.timeMillis().addToSchema(Schema.create(Schema.Type.INT));    Schema timestampSchema = LogicalTypes.timestampMillis().addToSchema(Schema.create(Schema.Type.LONG));            Assert.assertEquals("Should use LocalDate for date type", "java.time.LocalDate", compiler.javaUnbox(dateSchema));    Assert.assertEquals("Should use LocalTime for time-millis type", "java.time.LocalTime", compiler.javaUnbox(timeSchema));    Assert.assertEquals("Should use DateTime for timestamp-millis type", "java.time.Instant", compiler.javaUnbox(timestampSchema));}
27e442a0fc47c401bd40d04b1bce93ad416430e0afa355c7eb2b82d43550075d
testJavaUnboxDateTime
public void testJavaUnboxDateTime() throws Exception
{    SpecificCompiler compiler = createCompiler();    Schema dateSchema = LogicalTypes.date().addToSchema(Schema.create(Schema.Type.INT));    Schema timeSchema = LogicalTypes.timeMillis().addToSchema(Schema.create(Schema.Type.INT));    Schema timestampSchema = LogicalTypes.timestampMillis().addToSchema(Schema.create(Schema.Type.LONG));            Assert.assertEquals("Should use java.time.LocalDate for date type", "java.time.LocalDate", compiler.javaUnbox(dateSchema));    Assert.assertEquals("Should use java.time.LocalTime for time-millis type", "java.time.LocalTime", compiler.javaUnbox(timeSchema));    Assert.assertEquals("Should use java.time.Instant for timestamp-millis type", "java.time.Instant", compiler.javaUnbox(timestampSchema));}
13e0409ffd31c39f20a2120c431402a675db0804c48a617066ec6bc31ee5cfaf
testNullableLogicalTypesJavaUnboxDecimalTypesEnabled
public void testNullableLogicalTypesJavaUnboxDecimalTypesEnabled() throws Exception
{    SpecificCompiler compiler = createCompiler();    compiler.setEnableDecimalLogicalType(true);        Schema nullableDecimalSchema1 = Schema.createUnion(Schema.create(Schema.Type.NULL), LogicalTypes.decimal(9, 2).addToSchema(Schema.create(Schema.Type.BYTES)));    Schema nullableDecimalSchema2 = Schema.createUnion(LogicalTypes.decimal(9, 2).addToSchema(Schema.create(Schema.Type.BYTES)), Schema.create(Schema.Type.NULL));    Assert.assertEquals("Should return boxed type", compiler.javaUnbox(nullableDecimalSchema1), "java.math.BigDecimal");    Assert.assertEquals("Should return boxed type", compiler.javaUnbox(nullableDecimalSchema2), "java.math.BigDecimal");}
731fa40d238ab526f935a2e741fda7e52be4ff71c30fcca325d3b1d6a6cfed2c
testNullableLogicalTypesJavaUnboxDecimalTypesDisabled
public void testNullableLogicalTypesJavaUnboxDecimalTypesDisabled() throws Exception
{    SpecificCompiler compiler = createCompiler();    compiler.setEnableDecimalLogicalType(false);        Schema nullableDecimalSchema1 = Schema.createUnion(Schema.create(Schema.Type.NULL), LogicalTypes.decimal(9, 2).addToSchema(Schema.create(Schema.Type.BYTES)));    Schema nullableDecimalSchema2 = Schema.createUnion(LogicalTypes.decimal(9, 2).addToSchema(Schema.create(Schema.Type.BYTES)), Schema.create(Schema.Type.NULL));    Assert.assertEquals("Should return boxed type", compiler.javaUnbox(nullableDecimalSchema1), "java.nio.ByteBuffer");    Assert.assertEquals("Should return boxed type", compiler.javaUnbox(nullableDecimalSchema2), "java.nio.ByteBuffer");}
eccb075ef515b0d54ff5fc39dec1db5f209dd96c43f5e2927181410ea86b47b7
testNullableTypesJavaUnbox
public void testNullableTypesJavaUnbox() throws Exception
{    SpecificCompiler compiler = createCompiler();    compiler.setEnableDecimalLogicalType(false);        Schema nullableIntSchema1 = Schema.createUnion(Schema.create(Schema.Type.NULL), Schema.create(Schema.Type.INT));    Schema nullableIntSchema2 = Schema.createUnion(Schema.create(Schema.Type.INT), Schema.create(Schema.Type.NULL));    Assert.assertEquals("Should return boxed type", compiler.javaUnbox(nullableIntSchema1), "java.lang.Integer");    Assert.assertEquals("Should return boxed type", compiler.javaUnbox(nullableIntSchema2), "java.lang.Integer");    Schema nullableLongSchema1 = Schema.createUnion(Schema.create(Schema.Type.NULL), Schema.create(Schema.Type.LONG));    Schema nullableLongSchema2 = Schema.createUnion(Schema.create(Schema.Type.LONG), Schema.create(Schema.Type.NULL));    Assert.assertEquals("Should return boxed type", compiler.javaUnbox(nullableLongSchema1), "java.lang.Long");    Assert.assertEquals("Should return boxed type", compiler.javaUnbox(nullableLongSchema2), "java.lang.Long");    Schema nullableFloatSchema1 = Schema.createUnion(Schema.create(Schema.Type.NULL), Schema.create(Schema.Type.FLOAT));    Schema nullableFloatSchema2 = Schema.createUnion(Schema.create(Schema.Type.FLOAT), Schema.create(Schema.Type.NULL));    Assert.assertEquals("Should return boxed type", compiler.javaUnbox(nullableFloatSchema1), "java.lang.Float");    Assert.assertEquals("Should return boxed type", compiler.javaUnbox(nullableFloatSchema2), "java.lang.Float");    Schema nullableDoubleSchema1 = Schema.createUnion(Schema.create(Schema.Type.NULL), Schema.create(Schema.Type.DOUBLE));    Schema nullableDoubleSchema2 = Schema.createUnion(Schema.create(Schema.Type.DOUBLE), Schema.create(Schema.Type.NULL));    Assert.assertEquals("Should return boxed type", compiler.javaUnbox(nullableDoubleSchema1), "java.lang.Double");    Assert.assertEquals("Should return boxed type", compiler.javaUnbox(nullableDoubleSchema2), "java.lang.Double");    Schema nullableBooleanSchema1 = Schema.createUnion(Schema.create(Schema.Type.NULL), Schema.create(Schema.Type.BOOLEAN));    Schema nullableBooleanSchema2 = Schema.createUnion(Schema.create(Schema.Type.BOOLEAN), Schema.create(Schema.Type.NULL));    Assert.assertEquals("Should return boxed type", compiler.javaUnbox(nullableBooleanSchema1), "java.lang.Boolean");    Assert.assertEquals("Should return boxed type", compiler.javaUnbox(nullableBooleanSchema2), "java.lang.Boolean");}
2107e37cd563c92819280d02c8e3dcec5d1a223c7508e6223e182a1e7e8eafcb
testGetUsedConversionClassesForNullableLogicalTypes
public void testGetUsedConversionClassesForNullableLogicalTypes() throws Exception
{    SpecificCompiler compiler = createCompiler();    compiler.setEnableDecimalLogicalType(true);    Schema nullableDecimal1 = Schema.createUnion(Schema.create(Schema.Type.NULL), LogicalTypes.decimal(9, 2).addToSchema(Schema.create(Schema.Type.BYTES)));    Schema schemaWithNullableDecimal1 = Schema.createRecord("WithNullableDecimal", "", "", false, Collections.singletonList(new Schema.Field("decimal", nullableDecimal1, "", null)));    final Collection<String> usedConversionClasses = compiler.getUsedConversionClasses(schemaWithNullableDecimal1);    Assert.assertEquals(1, usedConversionClasses.size());    Assert.assertEquals("org.apache.avro.Conversions.DecimalConversion", usedConversionClasses.iterator().next());}
22999fe55a2e44c93891e0b9f7bcff0097016ffd91f31a367004e368e9d1aee8
testGetUsedConversionClassesForNullableLogicalTypesInNestedRecord
public void testGetUsedConversionClassesForNullableLogicalTypesInNestedRecord() throws Exception
{    SpecificCompiler compiler = createCompiler();    final Schema schema = new Schema.Parser().parse("{\"type\":\"record\",\"name\":\"NestedLogicalTypesRecord\",\"namespace\":\"org.apache.avro.codegentest.testdata\",\"doc\":\"Test nested types with logical types in generated Java classes\",\"fields\":[{\"name\":\"nestedRecord\",\"type\":{\"type\":\"record\",\"name\":\"NestedRecord\",\"fields\":[{\"name\":\"nullableDateField\",\"type\":[\"null\",{\"type\":\"int\",\"logicalType\":\"date\"}]}]}}]}");    final Collection<String> usedConversionClasses = compiler.getUsedConversionClasses(schema);    Assert.assertEquals(1, usedConversionClasses.size());    Assert.assertEquals("org.apache.avro.data.TimeConversions.DateConversion", usedConversionClasses.iterator().next());}
609dac9d51045a01ad538576f610a51b8991b34f148f462931d34feed59825c0
testGetUsedConversionClassesForNullableLogicalTypesInArray
public void testGetUsedConversionClassesForNullableLogicalTypesInArray() throws Exception
{    SpecificCompiler compiler = createCompiler();    final Schema schema = new Schema.Parser().parse("{\"type\":\"record\",\"name\":\"NullableLogicalTypesArray\",\"namespace\":\"org.apache.avro.codegentest.testdata\",\"doc\":\"Test nested types with logical types in generated Java classes\",\"fields\":[{\"name\":\"arrayOfLogicalType\",\"type\":{\"type\":\"array\",\"items\":[\"null\",{\"type\":\"int\",\"logicalType\":\"date\"}]}}]}");    final Collection<String> usedConversionClasses = compiler.getUsedConversionClasses(schema);    Assert.assertEquals(1, usedConversionClasses.size());    Assert.assertEquals("org.apache.avro.data.TimeConversions.DateConversion", usedConversionClasses.iterator().next());}
d1bc5784096ba81ce9afea747d5e65f7fab5081b0deab80f8aae7fff74f993e0
testGetUsedConversionClassesForNullableLogicalTypesInArrayOfRecords
public void testGetUsedConversionClassesForNullableLogicalTypesInArrayOfRecords() throws Exception
{    SpecificCompiler compiler = createCompiler();    final Schema schema = new Schema.Parser().parse("{\"type\":\"record\",\"name\":\"NestedLogicalTypesArray\",\"namespace\":\"org.apache.avro.codegentest.testdata\",\"doc\":\"Test nested types with logical types in generated Java classes\",\"fields\":[{\"name\":\"arrayOfRecords\",\"type\":{\"type\":\"array\",\"items\":{\"type\":\"record\",\"name\":\"RecordInArray\",\"fields\":[{\"name\":\"nullableDateField\",\"type\":[\"null\",{\"type\":\"int\",\"logicalType\":\"date\"}]}]}}}]}");    final Collection<String> usedConversionClasses = compiler.getUsedConversionClasses(schema);    Assert.assertEquals(1, usedConversionClasses.size());    Assert.assertEquals("org.apache.avro.data.TimeConversions.DateConversion", usedConversionClasses.iterator().next());}
927b2f55df75b44ebb57394d6db48cb38a7b6c56b249b5d11ad3404e8c1b504d
testGetUsedConversionClassesForNullableLogicalTypesInUnionOfRecords
public void testGetUsedConversionClassesForNullableLogicalTypesInUnionOfRecords() throws Exception
{    SpecificCompiler compiler = createCompiler();    final Schema schema = new Schema.Parser().parse("{\"type\":\"record\",\"name\":\"NestedLogicalTypesUnion\",\"namespace\":\"org.apache.avro.codegentest.testdata\",\"doc\":\"Test nested types with logical types in generated Java classes\",\"fields\":[{\"name\":\"unionOfRecords\",\"type\":[\"null\",{\"type\":\"record\",\"name\":\"RecordInUnion\",\"fields\":[{\"name\":\"nullableDateField\",\"type\":[\"null\",{\"type\":\"int\",\"logicalType\":\"date\"}]}]}]}]}");    final Collection<String> usedConversionClasses = compiler.getUsedConversionClasses(schema);    Assert.assertEquals(1, usedConversionClasses.size());    Assert.assertEquals("org.apache.avro.data.TimeConversions.DateConversion", usedConversionClasses.iterator().next());}
71514aa31e904ef569c559bdae62cdf9804e84e9dfd72f6eeef5d6bf2076c266
testGetUsedConversionClassesForNullableLogicalTypesInMapOfRecords
public void testGetUsedConversionClassesForNullableLogicalTypesInMapOfRecords() throws Exception
{    SpecificCompiler compiler = createCompiler();    final Schema schema = new Schema.Parser().parse("{\"type\":\"record\",\"name\":\"NestedLogicalTypesMap\",\"namespace\":\"org.apache.avro.codegentest.testdata\",\"doc\":\"Test nested types with logical types in generated Java classes\",\"fields\":[{\"name\":\"mapOfRecords\",\"type\":{\"type\":\"map\",\"values\":{\"type\":\"record\",\"name\":\"RecordInMap\",\"fields\":[{\"name\":\"nullableDateField\",\"type\":[\"null\",{\"type\":\"int\",\"logicalType\":\"date\"}]}]},\"avro.java.string\":\"String\"}}]}");    final Collection<String> usedConversionClasses = compiler.getUsedConversionClasses(schema);    Assert.assertEquals(1, usedConversionClasses.size());    Assert.assertEquals("org.apache.avro.data.TimeConversions.DateConversion", usedConversionClasses.iterator().next());}
80f2a1c511882e1b8a2e201c82015879d6df28435188ce3b56d47d1e7a2bd876
testLogicalTypesWithMultipleFields
public void testLogicalTypesWithMultipleFields() throws Exception
{    Schema logicalTypesWithMultipleFields = new Schema.Parser().parse(new File("src/test/resources/logical_types_with_multiple_fields.avsc"));    assertCompilesWithJavaCompiler(new File(OUTPUT_DIR.getRoot(), name.getMethodName()), new SpecificCompiler(logicalTypesWithMultipleFields).compile(), true);}
129b4cb98400dcd1c14297d0c84671c4beb4348319fad0531d15865f17e992ff
testUnionAndFixedFields
public void testUnionAndFixedFields() throws Exception
{    Schema unionTypesWithMultipleFields = new Schema.Parser().parse(new File("src/test/resources/union_and_fixed_fields.avsc"));    assertCompilesWithJavaCompiler(new File(this.outputFile, name.getMethodName()), new SpecificCompiler(unionTypesWithMultipleFields).compile());}
0078bb83fd072fad87716be8f456e50d4b9a80c51900683831f23a58feed0774
testLogicalTypesWithMultipleFieldsDateTime
public void testLogicalTypesWithMultipleFieldsDateTime() throws Exception
{    Schema logicalTypesWithMultipleFields = new Schema.Parser().parse(new File("src/test/resources/logical_types_with_multiple_fields.avsc"));    assertCompilesWithJavaCompiler(new File(this.outputFile, name.getMethodName()), new SpecificCompiler(logicalTypesWithMultipleFields).compile());}
9487d7869f2fa62245e804e96a832aaded84666e76d8cd1c16c120dc115643ee
testConversionInstanceWithDecimalLogicalTypeDisabled
public void testConversionInstanceWithDecimalLogicalTypeDisabled() throws Exception
{    final SpecificCompiler compiler = createCompiler();    compiler.setEnableDecimalLogicalType(false);    final Schema dateSchema = LogicalTypes.date().addToSchema(Schema.create(Schema.Type.INT));    final Schema timeSchema = LogicalTypes.timeMillis().addToSchema(Schema.create(Schema.Type.INT));    final Schema timestampSchema = LogicalTypes.timestampMillis().addToSchema(Schema.create(Schema.Type.LONG));    final Schema decimalSchema = LogicalTypes.decimal(9, 2).addToSchema(Schema.create(Schema.Type.BYTES));    final Schema uuidSchema = LogicalTypes.uuid().addToSchema(Schema.create(Schema.Type.STRING));    Assert.assertEquals("Should use date conversion for date type", "new org.apache.avro.data.TimeConversions.DateConversion()", compiler.conversionInstance(dateSchema));    Assert.assertEquals("Should use time conversion for time type", "new org.apache.avro.data.TimeConversions.TimeMillisConversion()", compiler.conversionInstance(timeSchema));    Assert.assertEquals("Should use timestamp conversion for date type", "new org.apache.avro.data.TimeConversions.TimestampMillisConversion()", compiler.conversionInstance(timestampSchema));    Assert.assertEquals("Should use null for decimal if the flag is off", "null", compiler.conversionInstance(decimalSchema));    Assert.assertEquals("Should use null for decimal if the flag is off", "null", compiler.conversionInstance(uuidSchema));}
55177a9a665cc699379bd38ce4dd946a8e07f12f06f6c2836c9e7a8e16ba6988
testConversionInstanceWithDecimalLogicalTypeEnabled
public void testConversionInstanceWithDecimalLogicalTypeEnabled() throws Exception
{    SpecificCompiler compiler = createCompiler();    compiler.setEnableDecimalLogicalType(true);    Schema dateSchema = LogicalTypes.date().addToSchema(Schema.create(Schema.Type.INT));    Schema timeSchema = LogicalTypes.timeMillis().addToSchema(Schema.create(Schema.Type.INT));    Schema timestampSchema = LogicalTypes.timestampMillis().addToSchema(Schema.create(Schema.Type.LONG));    Schema decimalSchema = LogicalTypes.decimal(9, 2).addToSchema(Schema.create(Schema.Type.BYTES));    Schema uuidSchema = LogicalTypes.uuid().addToSchema(Schema.create(Schema.Type.STRING));    Assert.assertEquals("Should use date conversion for date type", "new org.apache.avro.data.TimeConversions.DateConversion()", compiler.conversionInstance(dateSchema));    Assert.assertEquals("Should use time conversion for time type", "new org.apache.avro.data.TimeConversions.TimeMillisConversion()", compiler.conversionInstance(timeSchema));    Assert.assertEquals("Should use timestamp conversion for date type", "new org.apache.avro.data.TimeConversions.TimestampMillisConversion()", compiler.conversionInstance(timestampSchema));    Assert.assertEquals("Should use null for decimal if the flag is off", "new org.apache.avro.Conversions.DecimalConversion()", compiler.conversionInstance(decimalSchema));    Assert.assertEquals("Should use null for decimal if the flag is off", "null", compiler.conversionInstance(uuidSchema));}
f5cff2b1ce69a31058623ffa8681d74572c5c8ae8605c6547b9f9206258c9aef
testPojoWithOptionalTurnedOffByDefault
public void testPojoWithOptionalTurnedOffByDefault() throws IOException
{    SpecificCompiler compiler = createCompiler();    compiler.compileToDestination(this.src, OUTPUT_DIR.getRoot());    assertTrue(this.outputFile.exists());    try (BufferedReader reader = new BufferedReader(new FileReader(this.outputFile))) {        String line;        while ((line = reader.readLine()) != null) {            line = line.trim();            assertFalse(line.contains("Optional"));        }    }}
aedeb1dc80890232903e4553def5ed4a2b4b7829c8bf1aba11c4f4211302fecb
testPojoWithOptionalCreatedWhenOptionTurnedOn
public void testPojoWithOptionalCreatedWhenOptionTurnedOn() throws IOException
{    SpecificCompiler compiler = createCompiler();    compiler.setGettersReturnOptional(true);        compiler.compileToDestination(this.src, OUTPUT_DIR.getRoot());    assertTrue(this.outputFile.exists());    int optionalFound = 0;    try (BufferedReader reader = new BufferedReader(new FileReader(this.outputFile))) {        String line;        while ((line = reader.readLine()) != null) {            line = line.trim();            if (line.contains("Optional")) {                optionalFound++;            }        }    }    assertEquals(9, optionalFound);}
79d7c1607361a20dc5a62ed86c78ecadda8258127d29899fc4333a8fd9c45700
testPojoWithOptionalCreatedWhenOptionalForEverythingTurnedOn
public void testPojoWithOptionalCreatedWhenOptionalForEverythingTurnedOn() throws IOException
{    SpecificCompiler compiler = createCompiler();        compiler.setCreateOptionalGetters(true);    compiler.compileToDestination(this.src, OUTPUT_DIR.getRoot());    assertTrue(this.outputFile.exists());    int optionalFound = 0;    try (BufferedReader reader = new BufferedReader(new FileReader(this.outputFile))) {        String line;        while ((line = reader.readLine()) != null) {            line = line.trim();            if (line.contains("Optional")) {                optionalFound++;            }        }    }    assertEquals(17, optionalFound);}
81da572c1602b3b306dc2e27654c23500b95c1e788a628fac155ac8d152e4a21
testAdditionalToolsAreInjectedIntoTemplate
public void testAdditionalToolsAreInjectedIntoTemplate() throws Exception
{    SpecificCompiler compiler = createCompiler();    List<Object> customTools = new ArrayList<>();    customTools.add(new String());    compiler.setAdditionalVelocityTools(customTools);    compiler.setTemplateDir("src/test/resources/templates_with_custom_tools/");    compiler.compileToDestination(this.src, this.OUTPUT_DIR.getRoot());    assertTrue(this.outputFile.exists());    int itWorksFound = 0;    try (BufferedReader reader = new BufferedReader(new FileReader(this.outputFile))) {        String line;        while ((line = reader.readLine()) != null) {            line = line.trim();            if (line.contains("It works!")) {                itWorksFound++;            }        }    }    assertEquals(1, itWorksFound);}
4adaefafec562702d887f5960a1408e5f9d1add92c42fab7cb857d701c42d2a2
setUp
public void setUp()
{    MODEL.setCustomCoders(true);}
3a4c7533ab5547ad372a54e258a817afc3b2f01a092a3357d21ebfa90f525064
withoutSchemaMigration
public void withoutSchemaMigration() throws IOException
{    FullRecordV1 src = new FullRecordV1(true, 87231, 731L, 54.2832F, 38.321, "Hi there", null);    Assert.assertTrue("Test schema must allow for custom coders.", ((SpecificRecordBase) src).hasCustomCoders());    ByteArrayOutputStream out = new ByteArrayOutputStream(1024);    Encoder e = EncoderFactory.get().directBinaryEncoder(out, null);    DatumWriter<FullRecordV1> w = (DatumWriter<FullRecordV1>) MODEL.createDatumWriter(V1S);    w.write(src, e);    e.flush();    ByteArrayInputStream in = new ByteArrayInputStream(out.toByteArray());    Decoder d = DecoderFactory.get().directBinaryDecoder(in, null);    DatumReader<FullRecordV1> r = (DatumReader<FullRecordV1>) MODEL.createDatumReader(V1S);    FullRecordV1 dst = r.read(null, d);    Assert.assertEquals(src, dst);}
b0d680a7489a12a001e30decac8844e0cbb324c5b17f5a81e592bc6b8e24f6af
withSchemaMigration
public void withSchemaMigration() throws IOException
{    FullRecordV2 src = new FullRecordV2(true, 731, 87231, 38L, 54.2832F, "Hi there", ByteBuffer.wrap(Utf8.getBytesFor("Hello, world!")));    Assert.assertTrue("Test schema must allow for custom coders.", ((SpecificRecordBase) src).hasCustomCoders());    ByteArrayOutputStream out = new ByteArrayOutputStream(1024);    Encoder e = EncoderFactory.get().directBinaryEncoder(out, null);    DatumWriter<FullRecordV2> w = (DatumWriter<FullRecordV2>) MODEL.createDatumWriter(V2S);    w.write(src, e);    e.flush();    ByteArrayInputStream in = new ByteArrayInputStream(out.toByteArray());    Decoder d = DecoderFactory.get().directBinaryDecoder(in, null);    DatumReader<FullRecordV1> r = (DatumReader<FullRecordV1>) MODEL.createDatumReader(V2S, V1S);    FullRecordV1 dst = r.read(null, d);    FullRecordV1 expected = new FullRecordV1(true, 87231, 731L, 54.2832F, 38.0, null, "Hello, world!");    Assert.assertEquals(expected, dst);}
bae3eec4421a3950632177affadd4506ddfe65116eb02d7ec9c62fea153771ab
create
public static T create(Channel channel, Class<T> iface)
{    return create(channel, iface, CallOptions.DEFAULT);}
b031f65a931819c59632c4a12d145a747a59520dd88f2377201be4148dbc3a7a
create
public static T create(Channel channel, Class<T> iface, CallOptions callOptions)
{    Protocol protocol = AvroGrpcUtils.getProtocol(iface);    ServiceDescriptor serviceDescriptor = ServiceDescriptor.create(iface);    ServiceInvocationHandler proxyHandler = new ServiceInvocationHandler(channel, callOptions, protocol, serviceDescriptor);    return (T) Proxy.newProxyInstance(iface.getClassLoader(), new Class[] { iface }, proxyHandler);}
c8cf409827c9c02d61d115df754cdc44ab22d275a15b4a955d5e90712865c441
invoke
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable
{    try {        return invokeUnaryMethod(method, args);    } catch (RuntimeException re) {                throw re;    } catch (Exception e) {                for (Class<?> exceptionClass : method.getExceptionTypes()) {            if (exceptionClass.isInstance(e)) {                throw e;            }        }                throw new AvroRemoteException(e);    }}
445f93fcb231dc9277643e18ce02be0f378b73e5bad15eb53025ff6f9a8b7bf8
invokeUnaryMethod
private Object invokeUnaryMethod(Method method, Object[] args) throws Exception
{    Type[] parameterTypes = method.getParameterTypes();    if ((parameterTypes.length > 0) && (parameterTypes[parameterTypes.length - 1] instanceof Class) && Callback.class.isAssignableFrom(((Class<?>) parameterTypes[parameterTypes.length - 1]))) {                Object[] finalArgs = Arrays.copyOf(args, args.length - 1);        Callback<?> callback = (Callback<?>) args[args.length - 1];        unaryRequest(method.getName(), finalArgs, callback);        return null;    } else {        return unaryRequest(method.getName(), args);    }}
7acfd45b7faeb9464ae905d9ec81b7707cc5c6f7912406eb9566f2407ec2febc
unaryRequest
private Object unaryRequest(String methodName, Object[] args) throws Exception
{    CallFuture<Object> callFuture = new CallFuture<>();    unaryRequest(methodName, args, callFuture);    try {        return callFuture.get();    } catch (Exception e) {        if (e.getCause() instanceof Exception) {            throw (Exception) e.getCause();        }        throw new AvroRemoteException(e.getCause());    }}
6e51dce8698b8c5c4696c77b4e2f514cc18653506c09b847e265ef26fbc26335
unaryRequest
private void unaryRequest(String methodName, Object[] args, Callback<RespT> callback) throws Exception
{    StreamObserver<Object> observerAdpater = new CallbackToResponseStreamObserverAdpater<>(callback);    ClientCalls.asyncUnaryCall(channel.newCall(serviceDescriptor.getMethod(methodName, MethodDescriptor.MethodType.UNARY), callOptions), args, observerAdpater);}
7075303df0850ba7d59c5e9469c9484e6f185d166f114ea85f889e7c4ea05b28
onNext
public void onNext(Object value)
{    if (value instanceof Throwable) {        callback.handleError((Throwable) value);    } else {        callback.handleResult((T) value);    }}
21d7f35e809059272e6d09844941387010448e45ff02a146e4764f98fc3d1fa4
onError
public void onError(Throwable t)
{    callback.handleError(new AvroRuntimeException(t));}
ee375c03ff981fc2b6e251cd996aac3a105e75cac475195e1dd0795bf813e7f7
onCompleted
public void onCompleted()
{}
98dc5e034567c249729853f3990f4deaec66ded3dd7d44650d0733aa566fea76
createServiceDefinition
public static ServerServiceDefinition createServiceDefinition(Class iface, Object impl)
{    Protocol protocol = AvroGrpcUtils.getProtocol(iface);    ServiceDescriptor serviceDescriptor = ServiceDescriptor.create(iface);    ServerServiceDefinition.Builder serviceDefinitionBuilder = ServerServiceDefinition.builder(serviceDescriptor.getServiceName());    Map<String, Protocol.Message> messages = protocol.getMessages();    for (Method method : iface.getMethods()) {        Protocol.Message msg = messages.get(method.getName());                if (msg != null) {            UnaryMethodHandler methodHandler = msg.isOneWay() ? new OneWayUnaryMethodHandler(impl, method) : new UnaryMethodHandler(impl, method);            serviceDefinitionBuilder.addMethod(serviceDescriptor.getMethod(method.getName(), MethodDescriptor.MethodType.UNARY), ServerCalls.asyncUnaryCall(methodHandler));        }    }    return serviceDefinitionBuilder.build();}
032ac38cb5a94d912eaf6dc769e595f93ac149ea7e34b25089b9a7e42aeadc0b
invoke
public void invoke(Object[] request, StreamObserver<Object> responseObserver)
{    Object methodResponse = null;    try {        methodResponse = method.invoke(getServiceImpl(), request);    } catch (InvocationTargetException e) {        methodResponse = e.getTargetException();    } catch (Exception e) {        methodResponse = e;    }    responseObserver.onNext(methodResponse);    responseObserver.onCompleted();}
16e4501d146132f0d2fae26807b36220aec005795fc6efafb7f90440a4081abd
getMethod
public Method getMethod()
{    return method;}
f5b949d267bac3c0dca46563d0143f59d14ff3500d1caec7c5dc780a75da6104
getServiceImpl
public Object getServiceImpl()
{    return serviceImpl;}
032ac38cb5a94d912eaf6dc769e595f93ac149ea7e34b25089b9a7e42aeadc0b
invoke
public void invoke(Object[] request, StreamObserver<Object> responseObserver)
{            responseObserver.onNext(null);    responseObserver.onCompleted();        try {        getMethod().invoke(getServiceImpl(), request);    } catch (Exception e) {        Throwable cause = e;        while (cause.getCause() != null && cause != cause.getCause()) {            cause = cause.getCause();        }        LOG.log(Level.WARNING, "Error processing one-way rpc", cause);    }}
1ca0cd31934789673a62f856bf15dbee8aa6006ab0dcd96cbf3078d822b01506
getServiceName
public static String getServiceName(Class iface)
{    Protocol protocol = getProtocol(iface);    return protocol.getNamespace() + "." + protocol.getName();}
d732056a73f4ca08ac3470ac5a6693190f7695d0d0984be910b76aa56488579f
getProtocol
public static Protocol getProtocol(Class iface)
{    try {        Protocol p = (Protocol) (iface.getDeclaredField("PROTOCOL").get(null));        return p;    } catch (NoSuchFieldException e) {        throw new AvroRuntimeException("Not a Specific protocol: " + iface);    } catch (IllegalAccessException e) {        throw new AvroRuntimeException(e);    }}
61a7beb40fa792ed002b06fe9f0ffcd37fbdf8ec25b3761f9aed6007e1c0fd89
skipAndCloseQuietly
 static void skipAndCloseQuietly(InputStream stream)
{    try {        if (stream instanceof KnownLength && stream.available() > 0) {            stream.skip(stream.available());        } else {                                    byte[] skipBuffer = new byte[4096];            while (true) {                int read = stream.read(skipBuffer);                if (read < skipBuffer.length) {                    break;                }            }        }        stream.close();    } catch (Exception e) {        LOG.log(Level.WARNING, "failed to skip/close the input stream, may cause memory leak", e);    }}
56e08d87e6bd0be2a60f9b2de3195d58bc9d56a2637f6fed6210d21e832632ea
read
public int read(byte[] b, int off, int len) throws IOException
{    return getPartialInternal().read(b, off, len);}
00c6cb892813c6b89e072a7f09dccdece629f30849daab28245b06f3e679bf54
read
public int read() throws IOException
{    return getPartialInternal().read();}
b6a5c56af4169e63a7d67d85fcadabe7138dc7110ef39f9522421848e78ee1b3
getPartialInternal
private ByteArrayInputStream getPartialInternal() throws IOException
{    if (partial == null) {        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();        drainTo(outputStream);        partial = new ByteArrayInputStream(outputStream.toByteArray());    }    return partial;}
fc36f8537e06789834a2a6b2afb34a96216db3582b07d93541592f8e01c620c0
getPartial
protected ByteArrayInputStream getPartial()
{    return partial;}
6426ce3b66c4d2446558d8b5b93fe8a019e350f1ed5c2b61732f1efce14f0e67
write
public void write(byte[] b, int off, int len) throws IOException
{    target.write(b, off, len);    writtenCount += len;}
28b71ced43af8c83f8eb799b762b9363eea3393c08bf12a29b90de2304757b0c
write
public void write(int b) throws IOException
{    target.write(b);    writtenCount += 1;}
c3e67ec76f1b008887f1caba645a2614900cde6e477acca1bc3ecc36bf357fcf
flush
public void flush() throws IOException
{    target.flush();}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    target.close();}
cc3e700129d9f510a5f4d146875e87355fd04f31c25487facd62443926e94964
getWrittenCount
public int getWrittenCount()
{    return writtenCount;}
4bef14c24eb0e232e79eb2996565de916cdb556482ba2332ae3fe49f9523c4eb
stream
public InputStream stream(Object[] value)
{    return new AvroRequestInputStream(value, message);}
4a5af271f1969617cfb5b9d2da2755bc7dba1cfd83955bbb1f8ec7a40645e56f
parse
public Object[] parse(InputStream stream)
{    try {        BinaryDecoder in = DECODER_FACTORY.binaryDecoder(stream, null);        Schema reqSchema = message.getRequest();        GenericRecord request = (GenericRecord) new SpecificDatumReader<>(reqSchema).read(null, in);        Object[] args = new Object[reqSchema.getFields().size()];        int i = 0;        for (Schema.Field field : reqSchema.getFields()) {            args[i++] = request.get(field.name());        }        return args;    } catch (IOException e) {        throw Status.INTERNAL.withCause(e).withDescription("Error deserializing avro request arguments").asRuntimeException();    } finally {        AvroGrpcUtils.skipAndCloseQuietly(stream);    }}
2c619ef3e19603e7f044aa5d76bc0e71147130068c8c6484166774eb24b7150d
drainTo
public int drainTo(OutputStream target) throws IOException
{    int written;    if (getPartial() != null) {        written = (int) ByteStreams.copy(getPartial(), target);    } else {        Schema reqSchema = message.getRequest();        CountingOutputStream outputStream = new CountingOutputStream(target);        BinaryEncoder out = ENCODER_FACTORY.binaryEncoder(outputStream, null);        int i = 0;        for (Schema.Field param : reqSchema.getFields()) {            new SpecificDatumWriter<>(param.schema()).write(args[i++], out);        }        out.flush();        args = null;        written = outputStream.getWrittenCount();    }    return written;}
9f0705d7d41397240de93fca7430f55ad5daaf31e3324425cf5a8d4e5d84e71e
stream
public InputStream stream(Object value)
{    return new AvroResponseInputStream(value, message);}
d1e03c9a867f30f32f45f95acd2b3af1c05a9f8640b873a78a3cbdb8354aa88f
parse
public Object parse(InputStream stream)
{    try {        if (message.isOneWay())            return null;        BinaryDecoder in = DECODER_FACTORY.binaryDecoder(stream, null);        if (!in.readBoolean()) {            Object response = new SpecificDatumReader(message.getResponse()).read(null, in);            return response;        } else {            Object value = new SpecificDatumReader(message.getErrors()).read(null, in);            if (value instanceof Exception) {                return value;            }            return new AvroRuntimeException(value.toString());        }    } catch (IOException e) {        throw Status.INTERNAL.withCause(e).withDescription("Error deserializing avro response").asRuntimeException();    } finally {        AvroGrpcUtils.skipAndCloseQuietly(stream);    }}
2c619ef3e19603e7f044aa5d76bc0e71147130068c8c6484166774eb24b7150d
drainTo
public int drainTo(OutputStream target) throws IOException
{    int written;    if (getPartial() != null) {        written = (int) ByteStreams.copy(getPartial(), target);    } else {        written = writeResponse(target);    }    return written;}
f19eaa0f37ef307150868ffc72cdfa7fc9e206d3a9ee7d0dab7782998de7ca70
writeResponse
private int writeResponse(OutputStream target) throws IOException
{    int written;    if (message.isOneWay()) {        written = 0;    } else if (response instanceof Exception) {        ByteArrayOutputStream bao = new ByteArrayOutputStream();        BinaryEncoder out = ENCODER_FACTORY.binaryEncoder(bao, null);        try {            out.writeBoolean(true);            new SpecificDatumWriter(message.getErrors()).write(response, out);        } catch (Exception e) {            bao = new ByteArrayOutputStream();            out = ENCODER_FACTORY.binaryEncoder(bao, null);            out.writeBoolean(true);            new SpecificDatumWriter(Protocol.SYSTEM_ERRORS).write(new Utf8(e.toString()), out);        }        out.flush();        byte[] serializedError = bao.toByteArray();        target.write(serializedError);        written = serializedError.length;    } else {        CountingOutputStream outputStream = new CountingOutputStream(target);        BinaryEncoder out = ENCODER_FACTORY.binaryEncoder(outputStream, null);        out.writeBoolean(false);        new SpecificDatumWriter(message.getResponse()).write(response, out);        out.flush();        written = outputStream.getWrittenCount();    }    response = null;    return written;}
d9376e4c393cf795dd42166189641d9a39d8df125605db783fca498a4f47643f
create
public static ServiceDescriptor create(Class iface)
{    String serviceName = AvroGrpcUtils.getServiceName(iface);    return SERVICE_DESCRIPTORS.computeIfAbsent(serviceName, key -> new ServiceDescriptor(iface, serviceName));}
f75495abe1583cc2df4944c282c6a55c229516fe8ca77ba5d21036bf9eae604d
getServiceName
public String getServiceName()
{    return serviceName;}
5ae7b04a89b61d0ff89f00cea7f5175b73a704544dd3689aea29ae095f99dff1
getMethod
public MethodDescriptor<Object[], Object> getMethod(String methodName, MethodDescriptor.MethodType methodType)
{    return methods.computeIfAbsent(methodName, key -> MethodDescriptor.<Object[], Object>newBuilder().setFullMethodName(generateFullMethodName(serviceName, methodName)).setType(methodType).setRequestMarshaller(new AvroRequestMarshaller(protocol.getMessages().get(methodName))).setResponseMarshaller(new AvroResponseMarshaller(protocol.getMessages().get(methodName))).build());}
5d842d13c8f5648b9d57fcbb9bc9d6a81f02fe37542792646bdb57326f2d690f
readPratialAndDrain
private void readPratialAndDrain(int partialToRead, InputStream inputStream, OutputStream target) throws IOException
{        for (int i = 0; i < partialToRead; i++) {        int readByte = inputStream.read();        if (readByte >= 0) {            target.write(readByte);        } else {            break;        }    }    Drainable drainableRequest = (Drainable) inputStream;    drainableRequest.drainTo(target);}
c974564da42b0c88b63e3e0a5a5425b29e8abeac6629922df307b11c1328aca9
testAvroRequestReadPartialAndDrain
public void testAvroRequestReadPartialAndDrain() throws IOException
{    AvroRequestMarshaller requestMarshaller = new AvroRequestMarshaller(message);    InputStream requestInputStream = requestMarshaller.stream(new Object[] { record });    ByteArrayOutputStream requestOutputStream = new ByteArrayOutputStream();    readPratialAndDrain(random.nextInt(7) + 1, requestInputStream, requestOutputStream);    InputStream serialized = new ByteArrayInputStream(requestOutputStream.toByteArray());    Object[] parsedArgs = requestMarshaller.parse(serialized);    assertEquals(1, parsedArgs.length);    assertEquals(record, parsedArgs[0]);}
ab731dfd88dc845708369963ddfd1042018914b0082fc25d30daedfd665c930e
testAvroResponseReadPartialAndDrain
public void testAvroResponseReadPartialAndDrain() throws IOException
{    AvroResponseMarshaller responseMarshaller = new AvroResponseMarshaller(message);    InputStream responseInputStream = responseMarshaller.stream(record);    ByteArrayOutputStream responseOutputStream = new ByteArrayOutputStream();    readPratialAndDrain(random.nextInt(7) + 1, responseInputStream, responseOutputStream);    InputStream serialized = new ByteArrayInputStream(responseOutputStream.toByteArray());    Object parsedResponse = responseMarshaller.parse(serialized);    assertEquals(record, parsedResponse);}
c536957a0359efaba4fa041a9429ed02027b66c9e6f5cc21d07eb308cc675a0d
setUp
public void setUp() throws IOException
{    TestService serviceImpl = new TestServiceImplBase();    setUpServerAndClient(serviceImpl);}
0e8696f91adf16491f631a9cac5bc063881a796489ee854eef4980d22ee049f0
setUpServerAndClient
private void setUpServerAndClient(TestService serviceImpl) throws IOException
{    if (server != null && !server.isShutdown()) {        server.shutdown();    }    if (channel != null && !channel.isShutdown()) {        channel.shutdownNow();    }    server = ServerBuilder.forPort(0).addService(AvroGrpcServer.createServiceDefinition(TestService.class, serviceImpl)).build();    server.start();    int port = server.getPort();    channel = ManagedChannelBuilder.forAddress("localhost", port).usePlaintext().build();    stub = AvroGrpcClient.create(channel, TestService.class);    callbackStub = AvroGrpcClient.create(channel, TestService.Callback.class);}
8d9ec964cb2b1702f35510b65dc80717f83aa9b6d06f2d7caf8545c5d3f9a1d1
cleanUp
public void cleanUp()
{    channel.shutdownNow();    server.shutdownNow();}
be09b1aea4e167bdf3b5b63652f4bc50c911939e88a25aec74d792720abae38d
testEchoRecord
public void testEchoRecord() throws Exception
{    TestRecord echoedRecord = stub.echo(record);    assertEquals(record, echoedRecord);}
78a42cb3bd6283eca00615e29863c049e51e9aa017b51ca2e4224bfb6eecb9c6
testMultipleArgsAdd
public void testMultipleArgsAdd() throws Exception
{    int result = stub.add(3, 5, 2);    assertEquals(10, result);}
58886fb4f81399627bf28071d6abeef47a725c0ccc37e2665df0c631853a5e51
testMultipleArgsConcatenate
public void testMultipleArgsConcatenate() throws Exception
{    String val1 = "foo-bar";    Boolean val2 = true;    long val3 = 123321L;    int val4 = 42;    assertEquals(val1 + val2 + val3 + val4, stub.concatenate(val1, val2, val3, val4));}
bf4c2ab6e237b52cc2029094200b16a0d6398837b54b9793318a0fcb5a67bae7
testCallbackInterface
public void testCallbackInterface() throws Exception
{    CallFuture<TestRecord> future = new CallFuture<>();    callbackStub.echo(record, future);    assertEquals(record, future.get(1, TimeUnit.SECONDS));}
c6158ebb167c0e104f6b0c3054c133ee800ee281ca2cdeffeaa39d8a2fda4e1b
testOneWayRpc
public void testOneWayRpc() throws Exception
{    oneWayStart = new CountDownLatch(1);    oneWayDone = new CountDownLatch(3);    oneWayCount = new AtomicInteger();    stub.ping();    stub.ping();        assertEquals(0, oneWayCount.get());    oneWayStart.countDown();    stub.ping();    oneWayDone.await(1, TimeUnit.SECONDS);    assertEquals(3, oneWayCount.get());}
659fdefdcb7d8bafb8ef6357864d3fad45d4c287b13beb17443c232226f6f426
testDeclaredError
public void testDeclaredError() throws Exception
{    try {        stub.error(true);        fail("Expected exception but none thrown");    } catch (TestError te) {        assertEquals(declaredErrMsg, te.getMessage$());    }}
a1fc56e2b6d18de77311527dc7eaa364451cd0f1f10c2c618d3fb090af6cfc11
testUndeclaredError
public void testUndeclaredError() throws Exception
{    try {        stub.error(false);        fail("Expected exception but none thrown");    } catch (AvroRuntimeException e) {        assertTrue(e.getMessage().contains(undeclaredErrMsg));    }}
92ffa8c814ad0d8906ff0b29a61c1b1df731f39bf2703f084f72f462559d3e6f
testNullableResponse
public void testNullableResponse() throws Exception
{    setUpServerAndClient(new TestServiceImplBase() {        @Override        public String concatenate(String val1, boolean val2, long val3, int val4) {            return null;        }    });    assertEquals(null, stub.concatenate("foo", true, 42L, 42));}
65ae056af2d4f88dbfece75e9ba51fa9272e5618e728ca4dd136156284acbc09
concatenate
public String concatenate(String val1, boolean val2, long val3, int val4)
{    return null;}
ad5b8c119fc1c4c5c1d1aa4ccc79a267ab501298271bfc47e9694085a26e5ebf
testGrpcConnectionError
public void testGrpcConnectionError() throws Exception
{        channel.shutdownNow();    stub.add(0, 1, 2);}
9813dc313ac31f9b0676822c1c5d16f54906f00e927913eb11185e3c269edd1e
testRepeatedRequests
public void testRepeatedRequests() throws Exception
{    TestRecord[] echoedRecords = new TestRecord[5];        for (int i = 0; i < 5; i++) {        echoedRecords[i] = stub.echo(record);    }    for (TestRecord result : echoedRecords) {        assertEquals(record, result);    }}
2ccb9a9ed37d43d9798282c45e9fcc9b022a2a71896e890e460c01c7082f1bd2
testConcurrentClientAccess
public void testConcurrentClientAccess() throws Exception
{    ExecutorService es = Executors.newCachedThreadPool();    Future<TestRecord>[] records = new Future[5];    Future<Integer>[] adds = new Future[5];        for (int i = 0; i < 5; i++) {        records[i] = es.submit(() -> stub.echo(record));        int j = i;        adds[i] = es.submit(() -> stub.add(j, 2 * j, 3 * j));    }        for (int i = 0; i < 5; i++) {        assertEquals(record, records[i].get());        assertEquals(6 * i, (long) adds[i].get());    }}
854efbb79b4887058467c8f7508d4092dc082f0c794999915e41da42a3e2acc3
testConcurrentChannels
public void testConcurrentChannels() throws Exception
{    ManagedChannel otherChannel = ManagedChannelBuilder.forAddress("localhost", server.getPort()).usePlaintext().build();    TestService otherStub = AvroGrpcClient.create(otherChannel, TestService.class);    Future<Integer>[] adds = new Future[5];    Future<Integer>[] otherAdds = new Future[5];    ExecutorService es = Executors.newCachedThreadPool();        for (int i = 0; i < 5; i++) {        int j = i;        adds[i] = es.submit(() -> stub.add(j, j - 1, j - 2));        otherAdds[i] = es.submit(() -> otherStub.add(j, j + 1, j + 2));    }        for (int i = 0; i < 5; i++) {        assertEquals((3 * i) - 3, (long) adds[i].get());        assertEquals((3 * i) + 3, (long) otherAdds[i].get());    }    otherChannel.shutdownNow();}
767eaba11e63cf2e86776ef6e0be715d65225118dbf3a9d7787a13c5ab8fc405
echo
public TestRecord echo(TestRecord record)
{    return record;}
bad2dd4df6569b1f334873859be20ba4d28b459b508ca23cd735872eb69059dc
add
public int add(int arg1, int arg2, int arg3)
{    return arg1 + arg2 + arg3;}
a4ae79c74f314c25964b0807cbeca3f2bc3dd24fc520f2eab3300e737afdea3b
error
public void error(boolean declared) throws TestError
{    if (declared) {        throw declaredError;    }    throw undeclaredError;}
040c9691fa71f5c1923452e5014b9d631c4e1f287c925e4fbe1aead83373154c
ping
public void ping()
{    try {        oneWayStart.await();        oneWayCount.incrementAndGet();        oneWayDone.countDown();    } catch (InterruptedException e) {        fail("thread interrupted when waiting for all one-way messages");    }}
65ae056af2d4f88dbfece75e9ba51fa9272e5618e728ca4dd136156284acbc09
concatenate
public String concatenate(String val1, boolean val2, long val3, int val4)
{    return val1 + val2 + val3 + val4;}
772caeee8204dcdabc1678b59d208010ed851c7fc662477350a48eaea7225dd5
verifySerDeAndStandardMethods
 void verifySerDeAndStandardMethods(T original)
{    final SpecificDatumWriter<T> datumWriterFromSchema = new SpecificDatumWriter<>(original.getSchema());    final SpecificDatumReader<T> datumReaderFromSchema = new SpecificDatumReader<>(original.getSchema(), original.getSchema());    verifySerDeAndStandardMethods(original, datumWriterFromSchema, datumReaderFromSchema);    final SpecificDatumWriter<T> datumWriterFromClass = new SpecificDatumWriter(original.getClass());    final SpecificDatumReader<T> datumReaderFromClass = new SpecificDatumReader(original.getClass());    verifySerDeAndStandardMethods(original, datumWriterFromClass, datumReaderFromClass);}
65b02b90820f53fa013df8f0c95ee4dfe88ba176a5c61f31fd3bb297c604182e
verifySerDeAndStandardMethods
private void verifySerDeAndStandardMethods(T original, SpecificDatumWriter<T> datumWriter, SpecificDatumReader<T> datumReader)
{    final byte[] serialized = serialize(original, datumWriter);    final T copy = deserialize(serialized, datumReader);    Assert.assertEquals(original, copy);                        Assert.assertEquals(original.hashCode(), copy.hashCode());    Assert.assertEquals(original.toString(), copy.toString());}
7428e139806a46a59ca3f8f21817687298da96b9fc881772dd74e3b0069f252c
serialize
private byte[] serialize(T object, SpecificDatumWriter<T> datumWriter)
{    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();    try {        datumWriter.write(object, EncoderFactory.get().directBinaryEncoder(outputStream, null));        return outputStream.toByteArray();    } catch (IOException e) {        throw new RuntimeException(e);    }}
0426d0fe7185075f7c459170b8dd401d6f6bb2edeb283deecd251f78271ffe4d
deserialize
private T deserialize(byte[] bytes, SpecificDatumReader<T> datumReader)
{    try {        final ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(bytes);        return datumReader.read(null, DecoderFactory.get().directBinaryDecoder(byteArrayInputStream, null));    } catch (IOException e) {        throw new RuntimeException(e);    }}
8b9fb16cee40c5f4970287e6947993ed9f586732998f9e78729c334ba8766346
testNullValues
public void testNullValues() throws IOException
{    LogicalTypesWithCustomConversion instanceOfGeneratedClass = LogicalTypesWithCustomConversion.newBuilder().setNonNullCustomField(new CustomDecimal(BigInteger.valueOf(100), 2)).build();    verifySerDeAndStandardMethods(instanceOfGeneratedClass);}
d218aec0c8913c53e109fbd05806b9f4355a3ea466c44fb1ae52a68e64a2e9a5
testNonNullValues
public void testNonNullValues() throws IOException
{    LogicalTypesWithCustomConversion instanceOfGeneratedClass = LogicalTypesWithCustomConversion.newBuilder().setNonNullCustomField(new CustomDecimal(BigInteger.valueOf(100), 2)).setNullableCustomField(new CustomDecimal(BigInteger.valueOf(3000), 2)).build();    verifySerDeAndStandardMethods(instanceOfGeneratedClass);}
12d59dd1dedd0519fc878859fe1be209f5f9584559ed1bdb8559bd2bc3446fce
testDefaultValueOfNullableField
public void testDefaultValueOfNullableField() throws IOException
{    LogicalTypesWithDefaults instanceOfGeneratedClass = LogicalTypesWithDefaults.newBuilder().setNonNullDate(LocalDate.now()).build();    verifySerDeAndStandardMethods(instanceOfGeneratedClass);}
c57c132b7c6b207111e4a0d4b34b01cc2b41f26018b598618d73e9e9bc0d0593
testDefaultValueOfNonNullField
public void testDefaultValueOfNonNullField() throws IOException
{    LogicalTypesWithDefaults instanceOfGeneratedClass = LogicalTypesWithDefaults.newBuilder().setNullableDate(LocalDate.now()).build();    Assert.assertEquals(DEFAULT_VALUE, instanceOfGeneratedClass.getNonNullDate());    verifySerDeAndStandardMethods(instanceOfGeneratedClass);}
0231e7677a4bd739d7017e14c47e952b0e2da5bf954cac819b4ba16aae8ef88d
testWithValues
public void testWithValues() throws IOException
{    LogicalTypesWithDefaults instanceOfGeneratedClass = LogicalTypesWithDefaults.newBuilder().setNullableDate(LocalDate.now()).setNonNullDate(LocalDate.now()).build();    verifySerDeAndStandardMethods(instanceOfGeneratedClass);}
784b272866ce2394a5db9c24c2e7e1b87a07cc26f7685fa8f94803d18bb2efbb
testNullableLogicalTypeInNestedRecord
public void testNullableLogicalTypeInNestedRecord()
{    final NestedLogicalTypesRecord nestedLogicalTypesRecord = NestedLogicalTypesRecord.newBuilder().setNestedRecord(NestedRecord.newBuilder().setNullableDateField(LocalDate.now()).build()).build();    verifySerDeAndStandardMethods(nestedLogicalTypesRecord);}
efd012fb27bb7b7f97ffca849ccda1c8cdcdd6a65808fe376c434065ab433563
testNullableLogicalTypeInArray
public void testNullableLogicalTypeInArray()
{    final NullableLogicalTypesArray logicalTypesArray = NullableLogicalTypesArray.newBuilder().setArrayOfLogicalType(Collections.singletonList(LocalDate.now())).build();    verifySerDeAndStandardMethods(logicalTypesArray);}
8ba0d2b6d1e24f1971dfd8c51f5631f6895c1c4f6ebaa92db76c0d4be49eaab9
testNullableLogicalTypeInRecordInArray
public void testNullableLogicalTypeInRecordInArray()
{    final NestedLogicalTypesArray nestedLogicalTypesArray = NestedLogicalTypesArray.newBuilder().setArrayOfRecords(Collections.singletonList(RecordInArray.newBuilder().setNullableDateField(LocalDate.now()).build())).build();    verifySerDeAndStandardMethods(nestedLogicalTypesArray);}
90611b4f257aaae4be93b89aa30c438a6c7e68f0c5a17d430f4435005aaf4b4f
testNullableLogicalTypeInRecordInUnion
public void testNullableLogicalTypeInRecordInUnion()
{    final NestedLogicalTypesUnion nestedLogicalTypesUnion = NestedLogicalTypesUnion.newBuilder().setUnionOfRecords(RecordInUnion.newBuilder().setNullableDateField(LocalDate.now()).build()).build();    verifySerDeAndStandardMethods(nestedLogicalTypesUnion);}
e81b77798387267a0b11f716f3078343b8404924e7f552b0c1c470c02e21c797
testNullableLogicalTypeInRecordInMap
public void testNullableLogicalTypeInRecordInMap()
{    final NestedLogicalTypesMap nestedLogicalTypesMap = NestedLogicalTypesMap.newBuilder().setMapOfRecords(Collections.singletonMap("key", RecordInMap.newBuilder().setNullableDateField(LocalDate.now()).build())).build();    verifySerDeAndStandardMethods(nestedLogicalTypesMap);}
493d0db61bc30de89e9cc8e762684b0527c13dac4da7aa15e8f1df9a2c5eee4b
testNestedRecordsWithDifferentNamespaces
public void testNestedRecordsWithDifferentNamespaces()
{    NestedSomeNamespaceRecord instanceOfGeneratedClass = NestedSomeNamespaceRecord.newBuilder().setNestedRecordBuilder(NestedOtherNamespaceRecord.newBuilder().setSomeField(1)).build();    verifySerDeAndStandardMethods(instanceOfGeneratedClass);}
86706947fa75f396fa9d838404f00484d20c00eea93745f43758f06ab6e71248
testWithNullValues
public void testWithNullValues() throws IOException
{    NullableLogicalTypes instanceOfGeneratedClass = NullableLogicalTypes.newBuilder().setNullableDate(null).build();    verifySerDeAndStandardMethods(instanceOfGeneratedClass);}
64405170f122675c7f1bf34a8068c9ac85f6dd9345970f0b0f0bad6e2cf5cf79
testDate
public void testDate() throws IOException
{    NullableLogicalTypes instanceOfGeneratedClass = NullableLogicalTypes.newBuilder().setNullableDate(LocalDate.now()).build();    verifySerDeAndStandardMethods(instanceOfGeneratedClass);}
dadff6a4777239ee14d0bb00ad23d06646ad05d3a1f564b8519c957ecdc019f4
toByteArray
public byte[] toByteArray(int scale)
{    final BigDecimal correctlyScaledValue;    if (scale != internalValue.scale()) {        correctlyScaledValue = internalValue.setScale(scale, RoundingMode.HALF_UP);    } else {        correctlyScaledValue = internalValue;    }    return correctlyScaledValue.unscaledValue().toByteArray();}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (this == o)        return true;    if (o == null || getClass() != o.getClass())        return false;    CustomDecimal that = (CustomDecimal) o;    return internalValue.equals(that.internalValue);}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return internalValue.hashCode();}
d003724bbadc8fec75e87f2878c45646e3af1dbdb4c17493ff2a40b5fe7b238c
compareTo
public int compareTo(CustomDecimal o)
{    return this.internalValue.compareTo(o.internalValue);}
b44a3362d1754c2ae1d5451c218e0eee1f4677d596ffd5cef12038a03d8477c0
getConvertedType
public Class<CustomDecimal> getConvertedType()
{    return CustomDecimal.class;}
79c42293ac3a43d7598dc0ac8104dd9a114e436cd5a14a6241ebbe2b10b5f8ba
getLogicalTypeName
public String getLogicalTypeName()
{    return "decimal";}
8d0333cc3744976862e60af6c99e1ddb91873bb21847d32f4cdeb15a694458d2
fromBytes
public CustomDecimal fromBytes(ByteBuffer value, Schema schema, LogicalType type)
{    int scale = ((LogicalTypes.Decimal) type).getScale();    byte[] bytes = value.get(new byte[value.remaining()]).array();    return new CustomDecimal(new BigInteger(bytes), scale);}
22e2cb2fe2b43f3f6804d246752aa36a3721332cf8b8fd8a09780b6af7f9b3df
toBytes
public ByteBuffer toBytes(CustomDecimal value, Schema schema, LogicalType type)
{    int scale = ((LogicalTypes.Decimal) type).getScale();    return ByteBuffer.wrap(value.toByteArray(scale));}
246c51d426fb1d1e5bc73f2c05fea9208674a3bd48fc738868fe2808c8bbffd0
handleResult
public void handleResult(T result)
{    this.result = result;    latch.countDown();    if (chainedCallback != null) {        chainedCallback.handleResult(result);    }}
035b837624c44e5dc14a38f958d2fc58e6fff4a720b43c0bb73dbb869a99aaaf
handleError
public void handleError(Throwable error)
{    this.error = error;    latch.countDown();    if (chainedCallback != null) {        chainedCallback.handleError(error);    }}
342804a0c536e2e853a5de8fec0a69330295e80ae71571e42de6694039f78e0c
getResult
public T getResult()
{    return result;}
3213c4b1232fe3da862aa75b985a6eb1a02684101a9c0656a279b0541b492ddc
getError
public Throwable getError()
{    return error;}
48530026505cdfe67d1c7fc290cc255e01f3598aca06b9847db640c1bbe0076d
cancel
public boolean cancel(boolean mayInterruptIfRunning)
{    return false;}
1f8a60a8e7947244fd77c6226b688ce5cec6e83a6095e9c3a7f05fd821648396
isCancelled
public boolean isCancelled()
{    return false;}
0dd1da9d49e8628c0c9398d80a0da2fee8c148d84f8e11c2a83f179f6de4b1f7
get
public T get() throws InterruptedException, ExecutionException
{    latch.await();    if (error != null) {        throw new ExecutionException(error);    }    return result;}
45f55e69d27dd2fa0db8c2a3aea3d1ac12339be6dc00591a2757526255b661fc
get
public T get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException
{    if (latch.await(timeout, unit)) {        if (error != null) {            throw new ExecutionException(error);        }        return result;    } else {        throw new TimeoutException();    }}
b0b375d75fcbcf03ddaf3f6d24561fde6f05fcbeacce1d0b8bfabda8c8fd9899
await
public void await() throws InterruptedException
{    latch.await();}
a8bfc54f2cfe213876f01d09790ffc038ae1b06bae268cf534e2861e8cb129d9
await
public void await(long timeout, TimeUnit unit) throws InterruptedException, TimeoutException
{    if (!latch.await(timeout, unit)) {        throw new TimeoutException();    }}
7cf382bf6532528601afc0572ff7a4051fb2bd1cf2c9b7df66165750bb63dcd3
isDone
public boolean isDone()
{    return latch.getCount() <= 0;}
eedb587f68470407e820d49bf6bb9be573d78555382d32a0743e8fea8ced15d6
getPort
public int getPort()
{    return channel.socket().getLocalPort();}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    while (true) {        try {            transceiver.writeBuffers(responder.respond(transceiver.readBuffers()));        } catch (ClosedChannelException e) {            return;        } catch (IOException e) {            LOG.warn("unexpected error", e);            throw new RuntimeException(e);        }    }}
5df6118bc0e745d8b18e0a6a99b2e3f2ddba8140cbeb1423ce2df50a9f140574
close
public void close()
{    this.interrupt();}
3ef56d6ee4ee16c6751b88264516f31ecca3b355966f833d7a818cc538ccb6de
main
public static void main(String[] arg) throws Exception
{    DatagramServer server = new DatagramServer(null, new InetSocketAddress(0));    server.start();    System.out.println("started");    server.join();}
791cf839ace78741bf544103a7fbd239d689111fd7fbb765da4b532af4d6085e
getRemoteName
public String getRemoteName()
{    return remote.toString();}
ffd324fa490861d9cf8682f4c4abde52d33814b89fc764d5ce5930a5a654e67e
readBuffers
public synchronized List<ByteBuffer> readBuffers() throws IOException
{    buffer.clear();    remote = channel.receive(buffer);    LOG.info("received from " + remote);    buffer.flip();    List<ByteBuffer> buffers = new ArrayList<>();    while (true) {        int length = buffer.getInt();        if (length == 0) {                        return buffers;        }                ByteBuffer chunk = buffer.slice();        chunk.limit(length);        buffer.position(buffer.position() + length);        buffers.add(chunk);    }}
b3113f0afc418dbdd251c31795761cb914245f3974348135fd38e83ec63c2aaa
writeBuffers
public synchronized void writeBuffers(List<ByteBuffer> buffers) throws IOException
{    buffer.clear();    for (ByteBuffer b : buffers) {        buffer.putInt(b.remaining());                buffer.put(b);    }    buffer.putInt(0);    buffer.flip();    channel.send(buffer, remote);    LOG.info("sent to " + remote);}
618b65ffbb0771e0d376b24c1d1871c0f3ebba8d5023bd1108b06af1127158b4
getGenericData
public GenericData getGenericData()
{    return data;}
482a4a2f1ea900cca086aab814e23cc10f983d3b6837cbdf07521b8645885a71
writeRequest
public void writeRequest(Schema schema, Object request, Encoder out) throws IOException
{    new GenericDatumWriter<>(schema, data).write(request, out);}
08fe54bb238fd4eb602cc69910252c824b13e023830a05817ddccd3c835c1a86
readResponse
public Object readResponse(Schema writer, Schema reader, Decoder in) throws IOException
{    return new GenericDatumReader<>(writer, reader, data).read(null, in);}
af07219e25674750d46d2f64aaeb414b2a55c746e3526993a1fc6cd05c8dc7d3
readError
public Exception readError(Schema writer, Schema reader, Decoder in) throws IOException
{    Object error = new GenericDatumReader<>(writer, reader, data).read(null, in);    if (error instanceof CharSequence)                return new AvroRuntimeException(error.toString());    return new AvroRemoteException(error);}
618b65ffbb0771e0d376b24c1d1871c0f3ebba8d5023bd1108b06af1127158b4
getGenericData
public GenericData getGenericData()
{    return data;}
560fc0d19092cf4055d65776141015eb1032b138ac4c5be7160fbc32bbf6628d
getDatumWriter
protected DatumWriter<Object> getDatumWriter(Schema schema)
{    return new GenericDatumWriter<>(schema, data);}
7316ad7dea265abac3b6ed873e36e7ce7f846c6bb35631016ca533a880733b8e
getDatumReader
protected DatumReader<Object> getDatumReader(Schema actual, Schema expected)
{    return new GenericDatumReader<>(actual, expected, data);}
98439d55a74ef97291cc1593693058631931a37fe960a4b7d5beef8331fffbf8
readRequest
public Object readRequest(Schema actual, Schema expected, Decoder in) throws IOException
{    return getDatumReader(actual, expected).read(null, in);}
bd486c02c698d3d0d6852498ce69d7210d464a20a28961f1387f658246b52d59
writeResponse
public void writeResponse(Schema schema, Object response, Encoder out) throws IOException
{    getDatumWriter(schema).write(response, out);}
8582632205bd479415059358a7d0dcd15d1050b9f0744d1b4713510cad612e8e
writeError
public void writeError(Schema schema, Object error, Encoder out) throws IOException
{    if (error instanceof AvroRemoteException)        error = ((AvroRemoteException) error).getValue();    getDatumWriter(schema).write(error, out);}
c664289d9c6d38c192909efb8d5d4b660482cde67deb7d1661597d2725f7f027
setTimeout
public void setTimeout(int timeout)
{    this.timeout = timeout;}
791cf839ace78741bf544103a7fbd239d689111fd7fbb765da4b532af4d6085e
getRemoteName
public String getRemoteName()
{    return this.url.toString();}
ffd324fa490861d9cf8682f4c4abde52d33814b89fc764d5ce5930a5a654e67e
readBuffers
public synchronized List<ByteBuffer> readBuffers() throws IOException
{    try (InputStream in = connection.getInputStream()) {        return readBuffers(in);    }}
b3113f0afc418dbdd251c31795761cb914245f3974348135fd38e83ec63c2aaa
writeBuffers
public synchronized void writeBuffers(List<ByteBuffer> buffers) throws IOException
{    if (proxy == null)        connection = (HttpURLConnection) url.openConnection();    else        connection = (HttpURLConnection) url.openConnection(proxy);    connection.setRequestMethod("POST");    connection.setRequestProperty("Content-Type", CONTENT_TYPE);    connection.setRequestProperty("Content-Length", Integer.toString(getLength(buffers)));    connection.setDoOutput(true);    connection.setReadTimeout(timeout);    connection.setConnectTimeout(timeout);    try (OutputStream out = connection.getOutputStream()) {        writeBuffers(buffers, out);    }}
5137cd62c3fa905ad2fd1ac1009935a7cf102858aa2aa75f404ae02398a97ae4
getLength
 static int getLength(List<ByteBuffer> buffers)
{    int length = 0;    for (ByteBuffer buffer : buffers) {        length += 4;        length += buffer.remaining();    }    length += 4;    return length;}
ba2d60b2f33e508243aa645fbac85e4f5773e69628f5dcdebe276b6e75117b86
readBuffers
 static List<ByteBuffer> readBuffers(InputStream in) throws IOException
{    List<ByteBuffer> buffers = new ArrayList<>();    while (true) {        int length = (in.read() << 24) + (in.read() << 16) + (in.read() << 8) + in.read();        if (length == 0) {                        return buffers;        }        ByteBuffer buffer = ByteBuffer.allocate(length);        while (buffer.hasRemaining()) {            int p = buffer.position();            int i = in.read(buffer.array(), p, buffer.remaining());            if (i < 0)                throw new EOFException("Unexpected EOF");            buffer.position(p + i);        }        buffer.flip();        buffers.add(buffer);    }}
3aceb8922125d2edb9c14b49594b5aac3cc55098e00ff55cb217bf07bffbc023
writeBuffers
 static void writeBuffers(List<ByteBuffer> buffers, OutputStream out) throws IOException
{    for (ByteBuffer buffer : buffers) {                writeLength(buffer.limit(), out);        out.write(buffer.array(), buffer.position(), buffer.remaining());        buffer.position(buffer.limit());    }        writeLength(0, out);}
721ef0f718c0bb2e7f36d2717e47319072e279e8dd9d3bba1489677885914f14
writeLength
private static void writeLength(int length, OutputStream out) throws IOException
{    out.write(0xff & (length >>> 24));    out.write(0xff & (length >>> 16));    out.write(0xff & (length >>> 8));    out.write(0xff & length);}
c203cb23afbbdde3e5e447d49210d7cfab0c479da65aae82217eaea0ef9a234e
createTransceiver
public static Transceiver createTransceiver(URI uri) throws IOException
{    if ("http".equals(uri.getScheme()))        return new HttpTransceiver(uri.toURL());    else if ("avro".equals(uri.getScheme()))        return new SaslSocketTransceiver(new InetSocketAddress(uri.getHost(), uri.getPort()));    else        throw new IOException("unknown uri scheme: " + uri);}
3d20508211c6430a07d6dfb1288f4dd4ac6cef3b23ed67c526e1e2429804cbf8
createServer
public static Server createServer(Responder responder, URI uri) throws IOException
{    if ("avro".equals(uri.getScheme())) {        return new SaslSocketServer(responder, new InetSocketAddress(uri.getHost(), uri.getPort()));    } else if ("http".equals(uri.getScheme())) {        if (!warned) {            LoggerFactory.getLogger(Ipc.class).error("Using Ipc.createServer to create http instances is deprecated.  Create " + " an instace of org.apache.avro.ipc.jetty.HttpServer directly.");            warned = true;        }        try {            Class<?> cls = Class.forName("org.apache.avro.ipc.jetty.HttpServer");            return (Server) cls.getConstructor(Responder.class, Integer.TYPE).newInstance(responder, uri.getPort());        } catch (Throwable t) {                }    }    throw new IOException("unknown uri scheme: " + uri);}
791cf839ace78741bf544103a7fbd239d689111fd7fbb765da4b532af4d6085e
getRemoteName
public String getRemoteName()
{    return "local";}
f29f455f544a014333b5e52d94d0152fe4836453e7e9bc43c486c29d10db39ab
transceive
public List<ByteBuffer> transceive(List<ByteBuffer> request) throws IOException
{    return responder.respond(request);}
89c18d8119bb8e23a979cc72feb30546e4ca979755f432bbc62f745e41a4b271
readBuffers
public List<ByteBuffer> readBuffers() throws IOException
{    throw new UnsupportedOperationException();}
d2039ee4a63e50f584a154d5a9d9e91539d85c3e5dadbbc9ba49b5cb1bd1eadb
writeBuffers
public void writeBuffers(List<ByteBuffer> buffers) throws IOException
{    throw new UnsupportedOperationException();}
de3bdedc622d5803d9ef93d8d216090d1de27f265fbbf7689756118eef082118
getReflectData
public ReflectData getReflectData()
{    return (ReflectData) getSpecificData();}
560fc0d19092cf4055d65776141015eb1032b138ac4c5be7160fbc32bbf6628d
getDatumWriter
protected DatumWriter<Object> getDatumWriter(Schema schema)
{    return new ReflectDatumWriter<>(schema, getReflectData());}
4eaf0cf842661f2277f86e9d57a283a3aa7abcd31739262c611aac5e797e1f4e
getDatumReader
protected DatumReader<Object> getDatumReader(Schema writer, Schema reader)
{    return new ReflectDatumReader<>(writer, reader, getReflectData());}
ac20205c76c006b2fef671c9995fad58dfa2f7a129e8d42a47df95fc9112193d
getClient
public static T getClient(Class<T> iface, Transceiver transceiver) throws IOException
{    return getClient(iface, transceiver, new ReflectData(iface.getClassLoader()));}
21ba1b72cee59a8e1ef6270ceff27cf6cb21e268c49ffa81cd68c5aa6efac0e0
getClient
public static T getClient(Class<T> iface, Transceiver transceiver, ReflectData reflectData) throws IOException
{    Protocol protocol = reflectData.getProtocol(iface);    return (T) Proxy.newProxyInstance(reflectData.getClassLoader(), new Class[] { iface }, new ReflectRequestor(protocol, transceiver, reflectData));}
81f3e37713bb99b56d44b6750655bb815004083eadb6aa73b1e1de50c651450a
getClient
public static T getClient(Class<T> iface, ReflectRequestor rreq) throws IOException
{    return (T) Proxy.newProxyInstance(rreq.getReflectData().getClassLoader(), new Class[] { iface }, rreq);}
de3bdedc622d5803d9ef93d8d216090d1de27f265fbbf7689756118eef082118
getReflectData
public ReflectData getReflectData()
{    return (ReflectData) getSpecificData();}
560fc0d19092cf4055d65776141015eb1032b138ac4c5be7160fbc32bbf6628d
getDatumWriter
protected DatumWriter<Object> getDatumWriter(Schema schema)
{    return new ReflectDatumWriter<>(schema, getReflectData());}
7316ad7dea265abac3b6ed873e36e7ce7f846c6bb35631016ca533a880733b8e
getDatumReader
protected DatumReader<Object> getDatumReader(Schema actual, Schema expected)
{    return new ReflectDatumReader<>(actual, expected, getReflectData());}
8582632205bd479415059358a7d0dcd15d1050b9f0744d1b4713510cad612e8e
writeError
public void writeError(Schema schema, Object error, Encoder out) throws IOException
{    if (error instanceof CharSequence)                error = error.toString();    super.writeError(schema, error, out);}
7783c154e65ab0acb46c7004d06b46e0a58324057f50de2350a41a435ef73992
getLocal
public Protocol getLocal()
{    return local;}
a63b69655110c2fb6cf3d34f1f4c2456c51ec57b9ef72d8ee3f6727cd2c39842
getTransceiver
public Transceiver getTransceiver()
{    return transceiver;}
d6c55aed9d43d9fffc7696305cebb4027b66792f5006ce2a86c7d2d3a76d4781
addRPCPlugin
public void addRPCPlugin(RPCPlugin plugin)
{    rpcMetaPlugins.add(plugin);}
2b357523bba2d4029e8eaf79f888bbd6f6ec7ed231fc9dba73c37a0cab437602
request
public Object request(String messageName, Object request) throws Exception
{        Request rpcRequest = new Request(messageName, request, new RPCContext());    CallFuture<Object> future = /* only need a Future for two-way messages */    rpcRequest.getMessage().isOneWay() ? null : new CallFuture<>();        request(rpcRequest, future);    if (    future == null)        return null;    try {                return future.get();    } catch (ExecutionException e) {        Throwable error = e.getCause();        if (error instanceof Exception) {            throw (Exception) error;        } else {            throw new AvroRuntimeException(error);        }    }}
ed2e59209980c89dc26003d00b46adc3215405a4659abb1303c5bccd68681fbf
request
public void request(String messageName, Object request, Callback<T> callback) throws AvroRemoteException, IOException
{    request(new Request(messageName, request, new RPCContext()), callback);}
3c1005dcede388c93be0d619ce60c53c42175490c4e33dce43557a53f16b1e56
request
 void request(Request request, Callback<T> callback) throws AvroRemoteException, IOException
{    Transceiver t = getTransceiver();    if (!t.isConnected()) {                        handshakeLock.lock();        try {            if (t.isConnected()) {                                                handshakeLock.unlock();            } else {                CallFuture<T> callFuture = new CallFuture<>(callback);                t.transceive(request.getBytes(), new TransceiverCallback<>(request, callFuture));                try {                                        callFuture.await();                } catch (InterruptedException e) {                                        Thread.currentThread().interrupt();                }                if (request.getMessage().isOneWay()) {                    Throwable error = callFuture.getError();                    if (error != null) {                        if (error instanceof AvroRemoteException) {                            throw (AvroRemoteException) error;                        } else if (error instanceof AvroRuntimeException) {                            throw (AvroRuntimeException) error;                        } else if (error instanceof IOException) {                            throw (IOException) error;                        } else {                            throw new AvroRuntimeException(error);                        }                    }                }                return;            }        } finally {            if (handshakeLock.isHeldByCurrentThread()) {                handshakeLock.unlock();            }        }    }    if (request.getMessage().isOneWay()) {        t.lockChannel();        try {            t.writeBuffers(request.getBytes());            if (callback != null) {                callback.handleResult(null);            }        } finally {            t.unlockChannel();        }    } else {        t.transceive(request.getBytes(), new TransceiverCallback<>(request, callback));    }}
441c08d837509fb0d67e6015b9f887b003d9d8c44468f42adfab8b313f91a459
writeHandshake
private void writeHandshake(Encoder out) throws IOException
{    if (getTransceiver().isConnected())        return;    MD5 localHash = new MD5();    localHash.bytes(local.getMD5());    String remoteName = transceiver.getRemoteName();    MD5 remoteHash = REMOTE_HASHES.get(remoteName);    if (remoteHash == null) {                remoteHash = localHash;        remote = local;    } else {        remote = REMOTE_PROTOCOLS.get(remoteHash);    }    HandshakeRequest handshake = new HandshakeRequest();    handshake.setClientHash(localHash);    handshake.setServerHash(remoteHash);    if (sendLocalText)        handshake.setClientProtocol(local.toString());    RPCContext context = new RPCContext();    context.setHandshakeRequest(handshake);    for (RPCPlugin plugin : rpcMetaPlugins) {        plugin.clientStartConnect(context);    }    handshake.setMeta(context.requestHandshakeMeta());    HANDSHAKE_WRITER.write(handshake, out);}
73b8450433591250f0d543594a2aaf7faa09771628d38bb16f364bf245d12cf9
readHandshake
private boolean readHandshake(Decoder in) throws IOException
{    if (getTransceiver().isConnected())        return true;    boolean established = false;    HandshakeResponse handshake = HANDSHAKE_READER.read(null, in);    switch(handshake.getMatch()) {        case BOTH:            established = true;            sendLocalText = false;            break;        case CLIENT:            LOG.debug("Handshake match = CLIENT");            setRemote(handshake);            established = true;            sendLocalText = false;            break;        case NONE:            LOG.debug("Handshake match = NONE");            setRemote(handshake);            sendLocalText = true;            break;        default:            throw new AvroRuntimeException("Unexpected match: " + handshake.getMatch());    }    RPCContext context = new RPCContext();    context.setHandshakeResponse(handshake);    for (RPCPlugin plugin : rpcMetaPlugins) {        plugin.clientFinishConnect(context);    }    if (established)        getTransceiver().setRemote(remote);    return established;}
92d381622348290bf20020e5899b8103e02499c329ca60d3a0a27ede6d6054f5
setRemote
private void setRemote(HandshakeResponse handshake) throws IOException
{    remote = Protocol.parse(handshake.getServerProtocol().toString());    MD5 remoteHash = handshake.getServerHash();    REMOTE_HASHES.put(transceiver.getRemoteName(), remoteHash);    REMOTE_PROTOCOLS.putIfAbsent(remoteHash, remote);}
708b85e9c8f5f0d1384652c374d4b1b77874909a2cefc910c8088e27caf0699d
getRemote
public Protocol getRemote() throws IOException
{    if (remote != null)                return remote;    MD5 remoteHash = REMOTE_HASHES.get(transceiver.getRemoteName());    if (remoteHash != null) {        remote = REMOTE_PROTOCOLS.get(remoteHash);        if (remote != null)                        return remote;    }    handshakeLock.lock();    try {                ByteBufferOutputStream bbo = new ByteBufferOutputStream();                Encoder out = ENCODER_FACTORY.directBinaryEncoder(bbo, null);        writeHandshake(out);                out.writeInt(0);                out.writeString("");        List<ByteBuffer> response = getTransceiver().transceive(bbo.getBufferList());        ByteBufferInputStream bbi = new ByteBufferInputStream(response);        BinaryDecoder in = DecoderFactory.get().binaryDecoder(bbi, null);        readHandshake(in);        return this.remote;    } finally {        handshakeLock.unlock();    }}
7e9536dee85f2040fd3b0ba71e40b272a5a0ac520691f1a0de989a72dc350350
readResponse
public Object readResponse(Schema schema, Decoder in) throws IOException
{    return readResponse(schema, schema, in);}
f16db16f8fd75117f6ac35b47b5e417b41b357eb9db9847313eea3cdfd030951
readError
public Object readError(Schema schema, Decoder in) throws IOException
{    return readError(schema, schema, in);}
28b8b14a19ce93eea4a05c7876ce26cdc7918c905b67a14dd2071f86ab5a49d0
handleResult
public void handleResult(List<ByteBuffer> responseBytes)
{    ByteBufferInputStream bbi = new ByteBufferInputStream(responseBytes);    BinaryDecoder in = DecoderFactory.get().binaryDecoder(bbi, null);    try {        if (!readHandshake(in)) {                        Request handshake = new Request(request);            getTransceiver().transceive(handshake.getBytes(), new TransceiverCallback<>(handshake, callback));            return;        }    } catch (Exception e) {        LOG.error("Error handling transceiver callback: " + e, e);    }        Response response = new Response(request, in);    Object responseObject;    try {        try {            responseObject = response.getResponse();        } catch (Exception e) {            if (callback != null) {                callback.handleError(e);            }            return;        }        if (callback != null) {            callback.handleResult((T) responseObject);        }    } catch (Throwable t) {        LOG.error("Error in callback handler: " + t, t);    }}
035b837624c44e5dc14a38f958d2fc58e6fff4a720b43c0bb73dbb869a99aaaf
handleError
public void handleError(Throwable error)
{    callback.handleError(error);}
32d83720f7a999661738809a5d5340acca76da47a7cdfdd0649b27bf6ea42373
getMessageName
public String getMessageName()
{    return messageName;}
0615d77938bf43a914095eeeaf5a596e63e6ceb2fb1c8deed020e7896c639585
getContext
public RPCContext getContext()
{    return context;}
3100717ae74f6d36db4042701a952d4213d880bdb6e0f5885f0e1fa939447df1
getMessage
public Message getMessage()
{    if (message == null) {        message = getLocal().getMessages().get(messageName);        if (message == null) {            throw new AvroRuntimeException("Not a local message: " + messageName);        }    }    return message;}
29bfddba634326a55640325712158a3dab19c194b9fd3a86568d2916d79570ab
getBytes
public List<ByteBuffer> getBytes() throws IOException
{    if (requestBytes == null) {        ByteBufferOutputStream bbo = new ByteBufferOutputStream();        BinaryEncoder out = ENCODER_FACTORY.binaryEncoder(bbo, encoder);                Message m = getMessage();        context.setMessage(m);                writeRequest(m.getRequest(), request, out);        out.flush();        List<ByteBuffer> payload = bbo.getBufferList();                writeHandshake(out);        context.setRequestPayload(payload);        for (RPCPlugin plugin : rpcMetaPlugins) {                        plugin.clientSendRequest(context);        }        META_WRITER.write(context.requestCallMeta(), out);                out.writeString(m.getName());        out.flush();        bbo.append(payload);        requestBytes = bbo.getBufferList();    }    return requestBytes;}
eb9fd3243b0cfc970993358a8412f0bb7bc285b329ca7bdcce683fc9627fcabb
getResponse
public Object getResponse() throws Exception
{    Message lm = request.getMessage();    Message rm = remote.getMessages().get(request.getMessageName());    if (rm == null)        throw new AvroRuntimeException("Not a remote message: " + request.getMessageName());    Transceiver t = getTransceiver();    if ((lm.isOneWay() != rm.isOneWay()) && t.isConnected())        throw new AvroRuntimeException("Not both one-way messages: " + request.getMessageName());    if (lm.isOneWay() && t.isConnected())                return null;    RPCContext context = request.getContext();    context.setResponseCallMeta(META_READER.read(null, in));    if (!in.readBoolean()) {                Object response = readResponse(rm.getResponse(), lm.getResponse(), in);        context.setResponse(response);        for (RPCPlugin plugin : rpcMetaPlugins) {            plugin.clientReceiveResponse(context);        }        return response;    } else {        Exception error = readError(rm.getErrors(), lm.getErrors(), in);        context.setError(error);        for (RPCPlugin plugin : rpcMetaPlugins) {            plugin.clientReceiveResponse(context);        }        throw error;    }}
25a3498e19208b79555e5390ee90f3e00b24702c70842f7494bf408ddb348e34
getRemote
public static Protocol getRemote()
{    return REMOTE.get();}
7783c154e65ab0acb46c7004d06b46e0a58324057f50de2350a41a435ef73992
getLocal
public Protocol getLocal()
{    return local;}
d6c55aed9d43d9fffc7696305cebb4027b66792f5006ce2a86c7d2d3a76d4781
addRPCPlugin
public void addRPCPlugin(RPCPlugin plugin)
{    rpcMetaPlugins.add(plugin);}
8ce1fd7cf1ce021c059317d8b8e58259a7cf4c10023774444b2215de729c69ce
respond
public List<ByteBuffer> respond(List<ByteBuffer> buffers) throws IOException
{    return respond(buffers, null);}
a792d37985fd92183c8d02b4b9cafcf897872aaba5c50e7980d661230c948a1f
respond
public List<ByteBuffer> respond(List<ByteBuffer> buffers, Transceiver connection) throws IOException
{    Decoder in = DecoderFactory.get().binaryDecoder(new ByteBufferInputStream(buffers), null);    ByteBufferOutputStream bbo = new ByteBufferOutputStream();    BinaryEncoder out = EncoderFactory.get().binaryEncoder(bbo, null);    Exception error = null;    RPCContext context = new RPCContext();    List<ByteBuffer> payload = null;    List<ByteBuffer> handshake = null;    boolean wasConnected = connection != null && connection.isConnected();    try {        Protocol remote = handshake(in, out, connection);        out.flush();        if (        remote == null)            return bbo.getBufferList();        handshake = bbo.getBufferList();                context.setRequestCallMeta(META_READER.read(null, in));        String messageName = in.readString(null).toString();        if (        messageName.equals(""))            return handshake;        Message rm = remote.getMessages().get(messageName);        if (rm == null)            throw new AvroRuntimeException("No such remote message: " + messageName);        Message m = getLocal().getMessages().get(messageName);        if (m == null)            throw new AvroRuntimeException("No message named " + messageName + " in " + getLocal());        Object request = readRequest(rm.getRequest(), m.getRequest(), in);        context.setMessage(rm);        for (RPCPlugin plugin : rpcMetaPlugins) {            plugin.serverReceiveRequest(context);        }                if ((m.isOneWay() != rm.isOneWay()) && wasConnected)            throw new AvroRuntimeException("Not both one-way: " + messageName);        Object response = null;        try {            REMOTE.set(remote);            response = respond(m, request);            context.setResponse(response);        } catch (Exception e) {            error = e;            context.setError(error);            LOG.warn("user error", e);        } finally {            REMOTE.set(null);        }        if (        m.isOneWay() && wasConnected)            return null;        out.writeBoolean(error != null);        if (error == null)            writeResponse(m.getResponse(), response, out);        else            try {                writeError(m.getErrors(), error, out);            } catch (UnresolvedUnionException e) {                                throw error;            }    } catch (Exception e) {                LOG.warn("system error", e);        context.setError(e);        bbo = new ByteBufferOutputStream();        out = EncoderFactory.get().binaryEncoder(bbo, null);        out.writeBoolean(true);        writeError(Protocol.SYSTEM_ERRORS, new Utf8(e.toString()), out);        if (null == handshake) {            handshake = new ByteBufferOutputStream().getBufferList();        }    }    out.flush();    payload = bbo.getBufferList();        context.setResponsePayload(payload);    for (RPCPlugin plugin : rpcMetaPlugins) {        plugin.serverSendResponse(context);    }    META_WRITER.write(context.responseCallMeta(), out);    out.flush();        bbo.prepend(handshake);    bbo.append(payload);    return bbo.getBufferList();}
984010ca86ac4370c528ca22e8227c9e4485077427342caf9f1b27dcb8449cda
handshake
private Protocol handshake(Decoder in, Encoder out, Transceiver connection) throws IOException
{    if (connection != null && connection.isConnected())        return connection.getRemote();    HandshakeRequest request = handshakeReader.read(null, in);    Protocol remote = protocols.get(request.getClientHash());    if (remote == null && request.getClientProtocol() != null) {        remote = Protocol.parse(request.getClientProtocol().toString());        protocols.put(request.getClientHash(), remote);    }    HandshakeResponse response = new HandshakeResponse();    if (localHash.equals(request.getServerHash())) {        response.setMatch(remote == null ? HandshakeMatch.NONE : HandshakeMatch.BOTH);    } else {        response.setMatch(remote == null ? HandshakeMatch.NONE : HandshakeMatch.CLIENT);    }    if (response.getMatch() != HandshakeMatch.BOTH) {        response.setServerProtocol(local.toString());        response.setServerHash(localHash);    }    RPCContext context = new RPCContext();    context.setHandshakeRequest(request);    context.setHandshakeResponse(response);    for (RPCPlugin plugin : rpcMetaPlugins) {        plugin.serverConnecting(context);    }    handshakeWriter.write(response, out);    if (connection != null && response.getMatch() != HandshakeMatch.NONE)        connection.setRemote(remote);    return remote;}
024f2e2fc77b2097112c7525bb7301389d6ef53b12e99e1ac60042aa017b8615
doPost
protected void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException
{    response.setContentType(HttpTransceiver.CONTENT_TYPE);    List<ByteBuffer> requestBufs = HttpTransceiver.readBuffers(request.getInputStream());    try {        List<ByteBuffer> responseBufs = responder.respond(requestBufs);        response.setContentLength(HttpTransceiver.getLength(responseBufs));        HttpTransceiver.writeBuffers(responseBufs, response.getOutputStream());    } catch (AvroRuntimeException e) {        throw new ServletException(e);    }}
631ed56a631f7cba7fbd1100d40d468b55978e7ed26593f5b313e8afe2d7df7c
setHandshakeRequest
public void setHandshakeRequest(HandshakeRequest handshakeRequest)
{    this.handshakeRequest = handshakeRequest;}
9f794d24019dd2233f61961fc5efdfc378cd6ac641271de3cb64fd603137918a
getHandshakeRequest
public HandshakeRequest getHandshakeRequest()
{    return this.handshakeRequest;}
015e55a324d280286518d07af8cd4d99692ee6ea276ce444b4b9aad0c2afc2dd
setHandshakeResponse
public void setHandshakeResponse(HandshakeResponse handshakeResponse)
{    this.handshakeResponse = handshakeResponse;}
95800a9bce63ab80406883aa0a912db9b82cc5429d024808fd5c83158f1d46b6
getHandshakeResponse
public HandshakeResponse getHandshakeResponse()
{    return this.handshakeResponse;}
f5ab08a4c087e26938c4d278c41f42ff72ad46a6b02b28e5596c2dab354f775d
requestHandshakeMeta
public Map<String, ByteBuffer> requestHandshakeMeta()
{    if (handshakeRequest.getMeta() == null)        handshakeRequest.setMeta(new HashMap<>());    return handshakeRequest.getMeta();}
49d31b9f99975dc7118795b5bd4dccf837721128aeeae4be491b310b8765efe2
setRequestHandshakeMeta
 void setRequestHandshakeMeta(Map<String, ByteBuffer> newmeta)
{    handshakeRequest.setMeta(newmeta);}
331c4cd5a111365f10991cd68279c5fc4fed922eacff7bf08196303141df9d72
responseHandshakeMeta
public Map<String, ByteBuffer> responseHandshakeMeta()
{    if (handshakeResponse.getMeta() == null)        handshakeResponse.setMeta(new HashMap<>());    return handshakeResponse.getMeta();}
5ca82a769cf934afb7b119bbe1ee40a43d21397ade117fa00e377c3edfc4aa4d
setResponseHandshakeMeta
 void setResponseHandshakeMeta(Map<String, ByteBuffer> newmeta)
{    handshakeResponse.setMeta(newmeta);}
4e9009c600863acbbe65b6446e1034f96766037171bf6b65296f694bceca73f1
requestCallMeta
public Map<String, ByteBuffer> requestCallMeta()
{    if (requestCallMeta == null) {        requestCallMeta = new HashMap<>();    }    return requestCallMeta;}
3289868002962af8ed7a52c86e1715d12c250b350060fcc8b4f2ec6a8d3654f2
setRequestCallMeta
 void setRequestCallMeta(Map<String, ByteBuffer> newmeta)
{    requestCallMeta = newmeta;}
5bbb2a60d7f0de8437dcc1d4ec93d5df236b9c523dfded5d053fd9c172438de9
responseCallMeta
public Map<String, ByteBuffer> responseCallMeta()
{    if (responseCallMeta == null) {        responseCallMeta = new HashMap<>();    }    return responseCallMeta;}
783c5fcedb077e3383a805768c347f4365f465cea7068315b7977e9c0cad3681
setResponseCallMeta
 void setResponseCallMeta(Map<String, ByteBuffer> newmeta)
{    responseCallMeta = newmeta;}
75b7621411cad2af0addcff94b8c56734e92144aff566516bad8c7680d524b67
setResponse
 void setResponse(Object response)
{    this.response = response;    this.error = null;}
b5dcff577e8657d4fbceaefbaa1c1e4f159f50a01aa2768675c4d5c8dfe044a3
response
public Object response()
{    return response;}
ba0c85ab0c635e03b8c0b3d8d11b4dbc41128f3c43da54873fdaa21ee892dbfc
setError
 void setError(Exception error)
{    this.response = null;    this.error = error;}
1b29f09e18223c8db5c26f9324e548ba08ed6b2cdb59a6f2c050dc2caac9ab1a
error
public Exception error()
{    return error;}
fd9504dee16080e07420afd6a5d3ae609db08e44a33146c0a95ec89a5654c2f0
isError
public boolean isError()
{    return error != null;}
dd6238f7428590f3586569ff413800732a3a8e3c14800bd1cd3dac96484541b6
setMessage
public void setMessage(Message message)
{    this.message = message;}
3100717ae74f6d36db4042701a952d4213d880bdb6e0f5885f0e1fa939447df1
getMessage
public Message getMessage()
{    return message;}
17c869a91a3b226490f3a223632bd1f5804c347b6275b3b3df3c3640d5bbf0ab
setRequestPayload
public void setRequestPayload(List<ByteBuffer> payload)
{    this.requestPayload = payload;}
deaad72128372d302cc49311b8cd6f3abc4f51016d9d22fb7140c68da4fa0df3
getRequestPayload
public List<ByteBuffer> getRequestPayload()
{    return this.requestPayload;}
8f1597d6834b0429ad829f6fe8c7066d5fe3d457311b7a2e5a58fcbbb18c8a09
getResponsePayload
public List<ByteBuffer> getResponsePayload()
{    return this.responsePayload;}
e8c1d0369079318fcd685b4138d313ecb90cec2c1d489192a8704e9f4f69c4ca
setResponsePayload
public void setResponsePayload(List<ByteBuffer> payload)
{    this.responsePayload = payload;}
86672a69924af85607e17bda9b81162a1caa903c12d0f3640afc629342d5cf11
clientStartConnect
public void clientStartConnect(RPCContext context)
{}
074781ff684c8b35bb8fdf244f06cefb51029229fec7ca609376e62d2f6dd542
serverConnecting
public void serverConnecting(RPCContext context)
{}
35a828a5d4c33136d609d86db7d1115d1dad467cdd93361a18e4c3e160ea2b74
clientFinishConnect
public void clientFinishConnect(RPCContext context)
{}
ea6bdcf9c835c22d11bd66ab2a18e412782107ab4560b183070c75314a39ab4c
clientSendRequest
public void clientSendRequest(RPCContext context)
{}
21ae579f39574168939b76c5f0d979b2fd12fc74b9755beb51bda97afbd24a1d
serverReceiveRequest
public void serverReceiveRequest(RPCContext context)
{}
034bcb1b9d0fa94a3160cb15a7f3143a37209f5031c7eda428c29ee5a11bd34b
serverSendResponse
public void serverSendResponse(RPCContext context)
{}
f693dea6d9558ef56d9f642b77c1fc4e9ecd73f48c0ce6e08732a21b4d5894bd
clientReceiveResponse
public void clientReceiveResponse(RPCContext context)
{}
19dec37d02a772245d403c87303fa96aa606468528033b0fbdbeeb7470069b2c
getServer
public SaslServer getServer()
{    return new AnonymousServer();}
bd38735492dab4738cc719a23cb2f8ebf69aad838e95839b015a6bd88cb1ebff
getServer
public SaslServer getServer() throws SaslException
{    return Sasl.createSaslServer(mechanism, protocol, serverName, props, cbh);}
3f5b3b644369a3319ebe5514cdfa065b08143d55c5c980fe741ae55bb0557230
getTransceiver
protected Transceiver getTransceiver(SocketChannel channel) throws IOException
{    return new SaslSocketTransceiver(channel, factory.getServer());}
5f07f10aa2251a4cb8179f66652537b55bd6732749cc7e61b6efb005426f493b
getMechanismName
public String getMechanismName()
{    return "ANONYMOUS";}
1c263f708f74295d86756090093039fd02ad5f172db418d1b85ffff8f74bdba8
evaluateResponse
public byte[] evaluateResponse(byte[] response) throws SaslException
{    this.user = new String(response, StandardCharsets.UTF_8);    return null;}
6b8341e3bf79cd81024e28fa7df191b8c1cc2c3e26c486ea6fa2a5e58e89ef5d
isComplete
public boolean isComplete()
{    return user != null;}
4a1d29d789ce0c0cf799c3534b4cc2ab33c00f205b421915994ebcc3e521e1cf
getAuthorizationID
public String getAuthorizationID()
{    return user;}
e31cc4c331a3645994a491ca2e8d788e776e18456e4221c936442773ebaef098
unwrap
public byte[] unwrap(byte[] incoming, int offset, int len)
{    throw new UnsupportedOperationException();}
41bf333878e1c00919842b076b0923866376a7da655fd1c36212684084f7bf70
wrap
public byte[] wrap(byte[] outgoing, int offset, int len)
{    throw new UnsupportedOperationException();}
c2cc9a7f2a9aca541b81b822ea5705f97c6f870e758ed7b197c224f1f0565986
getNegotiatedProperty
public Object getNegotiatedProperty(String propName)
{    return null;}
b9fb45dfe6e038cbb203f12831a900a458fc92323c8db50edb08712565a288f2
dispose
public void dispose()
{}
d281b583c7876c25d7ad9fa27ea2d785aca24efb5315460c0e085a5cb6230e07
isConnected
public boolean isConnected()
{    return remote != null;}
913ed75cceb8eb315c8ba559f12f46cb86ae54e5f3d2c720415d09b17b57a1e5
setRemote
public void setRemote(Protocol remote)
{    this.remote = remote;}
211112435fc9aad0c85f999abf759f93ba0c11c2cc8f361d136bde6e5d96d6ee
getRemote
public Protocol getRemote()
{    return remote;}
791cf839ace78741bf544103a7fbd239d689111fd7fbb765da4b532af4d6085e
getRemoteName
public String getRemoteName()
{    return channel.socket().getRemoteSocketAddress().toString();}
cca3e5cbb2346a9dff8e99b617446077a27e43912b791ba261a35fc346ceacda
transceive
public synchronized List<ByteBuffer> transceive(List<ByteBuffer> request) throws IOException
{    if (saslResponsePiggybacked) {                saslResponsePiggybacked = false;        Status status = readStatus();        ByteBuffer frame = readFrame();        switch(status) {            case COMPLETE:                break;            case FAIL:                throw new SaslException("Fail: " + toString(frame));            default:                throw new IOException("Unexpected SASL status: " + status);        }    }    return super.transceive(request);}
73d67c95b883d52baaefd20ce7c882f9b81a6ed290839339994104911fd4a7ed
open
private void open(boolean isClient) throws IOException
{    LOG.debug("beginning SASL negotiation");    if (isClient) {        ByteBuffer response = EMPTY;        if (sasl.client.hasInitialResponse())            response = ByteBuffer.wrap(sasl.evaluate(response.array()));        write(Status.START, sasl.getMechanismName(), response);        if (sasl.isComplete())            saslResponsePiggybacked = true;    }    while (!sasl.isComplete()) {        Status status = readStatus();        ByteBuffer frame = readFrame();        switch(status) {            case START:                String mechanism = toString(frame);                frame = readFrame();                if (!mechanism.equalsIgnoreCase(sasl.getMechanismName())) {                    write(Status.FAIL, "Wrong mechanism: " + mechanism);                    throw new SaslException("Wrong mechanism: " + mechanism);                }            case CONTINUE:                byte[] response;                try {                    response = sasl.evaluate(frame.array());                    status = sasl.isComplete() ? Status.COMPLETE : Status.CONTINUE;                } catch (SaslException e) {                    response = e.toString().getBytes(StandardCharsets.UTF_8);                    status = Status.FAIL;                }                write(status, response != null ? ByteBuffer.wrap(response) : EMPTY);                break;            case COMPLETE:                sasl.evaluate(frame.array());                if (!sasl.isComplete())                    throw new SaslException("Expected completion!");                break;            case FAIL:                throw new SaslException("Fail: " + toString(frame));            default:                throw new IOException("Unexpected SASL status: " + status);        }    }    LOG.debug("SASL opened");    String qop = (String) sasl.getNegotiatedProperty(Sasl.QOP);    LOG.debug("QOP = {}", qop);    dataIsWrapped = (qop != null && !qop.equalsIgnoreCase("auth"));}
5196b600bd292024464de570e1d14e37cbddfe9e4664e47c62832ce4019d44b5
toString
private String toString(ByteBuffer buffer)
{    return new String(buffer.array(), StandardCharsets.UTF_8);}
ffd324fa490861d9cf8682f4c4abde52d33814b89fc764d5ce5930a5a654e67e
readBuffers
public synchronized List<ByteBuffer> readBuffers() throws IOException
{    List<ByteBuffer> buffers = new ArrayList<>();    while (true) {        ByteBuffer buffer = readFrameAndUnwrap();        if (buffer.remaining() == 0)            return buffers;        buffers.add(buffer);    }}
2ddd95bb28501d8d393a82ff2f733324b08f06879be6a47aee5d5808e0dc2347
readStatus
private Status readStatus() throws IOException
{    ByteBuffer buffer = ByteBuffer.allocate(1);    read(buffer);    int status = buffer.get();    if (status > Status.values().length)        throw new IOException("Unexpected SASL status byte: " + status);    return Status.values()[status];}
febeb60d43f83972991d67d6f178bced7582287ee2714de3819954d9a2f372df
readFrameAndUnwrap
private ByteBuffer readFrameAndUnwrap() throws IOException
{    ByteBuffer frame = readFrame();    if (!dataIsWrapped)        return frame;    ByteBuffer unwrapped = ByteBuffer.wrap(sasl.unwrap(frame.array()));    LOG.debug("unwrapped data of length: {}", unwrapped.remaining());    return unwrapped;}
f53cab336e29578026bcef3f39bce581f254242b8475c897d15d24f59124e6d2
readFrame
private ByteBuffer readFrame() throws IOException
{    read(readHeader);    ByteBuffer buffer = ByteBuffer.allocate(readHeader.getInt());    LOG.debug("about to read: {} bytes", buffer.capacity());    read(buffer);    return buffer;}
6649c803f56947a2190bf799211d83403907468d1de51596f6ffa686d80c6f5b
read
private void read(ByteBuffer buffer) throws IOException
{    buffer.clear();    while (buffer.hasRemaining()) if (channel.read(buffer) == -1)        throw new EOFException();    buffer.flip();}
b3113f0afc418dbdd251c31795761cb914245f3974348135fd38e83ec63c2aaa
writeBuffers
public synchronized void writeBuffers(List<ByteBuffer> buffers) throws IOException
{    if (buffers == null)                return;    List<ByteBuffer> writes = new ArrayList<>(buffers.size() * 2 + 1);    int currentLength = 0;    ByteBuffer currentHeader = writeHeader;    for (ByteBuffer buffer : buffers) {                if (buffer.remaining() == 0)                        continue;        if (dataIsWrapped) {            LOG.debug("wrapping data of length: {}", buffer.remaining());            buffer = ByteBuffer.wrap(sasl.wrap(buffer.array(), buffer.position(), buffer.remaining()));        }        int length = buffer.remaining();        if (        !dataIsWrapped && (currentLength + length) <= ByteBufferOutputStream.BUFFER_SIZE) {            if (currentLength == 0)                writes.add(currentHeader);            currentLength += length;            currentHeader.clear();            currentHeader.putInt(currentLength);            LOG.debug("adding {} to write, total now {}", length, currentLength);        } else {            currentLength = length;            currentHeader = ByteBuffer.allocate(4).putInt(length);            writes.add(currentHeader);            LOG.debug("planning write of {}", length);        }        currentHeader.flip();        writes.add(buffer);    }        zeroHeader.flip();    writes.add(zeroHeader);    writeFully(writes.toArray(new ByteBuffer[0]));}
b05d794c46d3c8c9f2a870d8474aef36f3565782b3da9c8204676710c877d067
write
private void write(Status status, String prefix, ByteBuffer response) throws IOException
{    LOG.debug("write status: {} {}", status, prefix);    write(status, prefix);    write(response);}
f0265c1d7e89820b04bb3a7202131e152180d5938d2ad48be100ad5a7a7bafce
write
private void write(Status status, String response) throws IOException
{    write(status, ByteBuffer.wrap(response.getBytes(StandardCharsets.UTF_8)));}
231e000e98e7aae86e26e9f698e3284c4c847a0d2e83742831fb7f50f73d6ef0
write
private void write(Status status, ByteBuffer response) throws IOException
{    LOG.debug("write status: {}", status);    ByteBuffer statusBuffer = ByteBuffer.allocate(1);    statusBuffer.clear();    statusBuffer.put((byte) (status.ordinal())).flip();    writeFully(statusBuffer);    write(response);}
adec432ca68153b1bbda2d2338822d98d708a65005ceff73a6149d01dcfa9f9b
write
private void write(ByteBuffer response) throws IOException
{    LOG.debug("writing: {}", response.remaining());    writeHeader.clear();    writeHeader.putInt(response.remaining()).flip();    writeFully(writeHeader, response);}
1edc009a3deea0bf2e9f7b74facb1e2c08ff3bc3a92a44d7b98182ecfab2e392
writeFully
private void writeFully(ByteBuffer... buffers) throws IOException
{    int length = buffers.length;    int start = 0;    do {        channel.write(buffers, start, length - start);        while (buffers[start].remaining() == 0) {            start++;            if (start == length)                return;        }    } while (true);}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    if (channel.isOpen()) {        LOG.info("closing to " + getRemoteName());        channel.close();    }    sasl.dispose();}
5f07f10aa2251a4cb8179f66652537b55bd6732749cc7e61b6efb005426f493b
getMechanismName
public String getMechanismName()
{    if (client != null)        return client.getMechanismName();    else        return server.getMechanismName();}
6b8341e3bf79cd81024e28fa7df191b8c1cc2c3e26c486ea6fa2a5e58e89ef5d
isComplete
public boolean isComplete()
{    if (client != null)        return client.isComplete();    else        return server.isComplete();}
d400f9f671571e122d6197edc5da68257a1c21657c293fe2f1d283a5bdf8c1d4
dispose
public void dispose() throws SaslException
{    if (client != null)        client.dispose();    else        server.dispose();}
1cff89609f3aba6c983f6d93f7e5aa52773290a7e231444f3ea7abf9b149c2a0
unwrap
public byte[] unwrap(byte[] buf) throws SaslException
{    if (client != null)        return client.unwrap(buf, 0, buf.length);    else        return server.unwrap(buf, 0, buf.length);}
ab7826638e0ff490833d5a5ff83a5f88ac9c58dfaee75a99d7a68fd3c9576ca3
wrap
public byte[] wrap(byte[] buf) throws SaslException
{    return wrap(buf, 0, buf.length);}
531b0bc7a858d8376da7dda513e65f7dea8c815ede9afbbf4e9b5773d84f2f49
wrap
public byte[] wrap(byte[] buf, int start, int len) throws SaslException
{    if (client != null)        return client.wrap(buf, start, len);    else        return server.wrap(buf, start, len);}
c2cc9a7f2a9aca541b81b822ea5705f97c6f870e758ed7b197c224f1f0565986
getNegotiatedProperty
public Object getNegotiatedProperty(String propName)
{    if (client != null)        return client.getNegotiatedProperty(propName);    else        return server.getNegotiatedProperty(propName);}
6bd7464cc2c35f474ffdcf4ea9749bc1eb522325deceb4864c17e893adfa87bb
evaluate
public byte[] evaluate(byte[] buf) throws SaslException
{    if (client != null)        return client.evaluateChallenge(buf);    else        return server.evaluateResponse(buf);}
5f07f10aa2251a4cb8179f66652537b55bd6732749cc7e61b6efb005426f493b
getMechanismName
public String getMechanismName()
{    return "ANONYMOUS";}
7ef8d0c50ebd36c604bf4e55dc8c6fff27a642600acac57c28f586b456285dae
hasInitialResponse
public boolean hasInitialResponse()
{    return true;}
d426c645d62d5b234eea21ba44d39f4d865a3da3f3668ecc9bda1188f16b1428
evaluateChallenge
public byte[] evaluateChallenge(byte[] challenge) throws SaslException
{    return System.getProperty("user.name").getBytes(StandardCharsets.UTF_8);}
6b8341e3bf79cd81024e28fa7df191b8c1cc2c3e26c486ea6fa2a5e58e89ef5d
isComplete
public boolean isComplete()
{    return true;}
e31cc4c331a3645994a491ca2e8d788e776e18456e4221c936442773ebaef098
unwrap
public byte[] unwrap(byte[] incoming, int offset, int len)
{    throw new UnsupportedOperationException();}
41bf333878e1c00919842b076b0923866376a7da655fd1c36212684084f7bf70
wrap
public byte[] wrap(byte[] outgoing, int offset, int len)
{    throw new UnsupportedOperationException();}
c2cc9a7f2a9aca541b81b822ea5705f97c6f870e758ed7b197c224f1f0565986
getNegotiatedProperty
public Object getNegotiatedProperty(String propName)
{    return null;}
b9fb45dfe6e038cbb203f12831a900a458fc92323c8db50edb08712565a288f2
dispose
public void dispose()
{}
eedb587f68470407e820d49bf6bb9be573d78555382d32a0743e8fea8ced15d6
getPort
public int getPort()
{    return channel.socket().getLocalPort();}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    LOG.info("starting " + channel.socket().getInetAddress());    try {        while (true) {            try {                new Connection(channel.accept());            } catch (ClosedChannelException e) {                return;            } catch (IOException e) {                LOG.warn("unexpected error", e);                throw new RuntimeException(e);            }        }    } finally {        LOG.info("stopping " + channel.socket().getInetAddress());        try {            channel.close();        } catch (IOException e) {        }    }}
5df6118bc0e745d8b18e0a6a99b2e3f2ddba8140cbeb1423ce2df50a9f140574
close
public void close()
{    this.interrupt();    group.interrupt();}
3f5b3b644369a3319ebe5514cdfa065b08143d55c5c980fe741ae55bb0557230
getTransceiver
protected Transceiver getTransceiver(SocketChannel channel) throws IOException
{    return new SocketTransceiver(channel);}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    try {        try {            this.xc = getTransceiver(channel);            while (true) {                xc.writeBuffers(responder.respond(xc.readBuffers(), xc));            }        } catch (EOFException | ClosedChannelException e) {        } finally {            xc.close();        }    } catch (IOException e) {        LOG.warn("unexpected error", e);    }}
3ef56d6ee4ee16c6751b88264516f31ecca3b355966f833d7a818cc538ccb6de
main
public static void main(String[] arg) throws Exception
{    Responder responder = new GenericResponder(Protocol.parse("{\"protocol\": \"X\"}")) {        @Override        public Object respond(Message message, Object request) throws Exception {            throw new AvroRemoteException("no messages!");        }    };    SocketServer server = new SocketServer(responder, new InetSocketAddress(0));    server.start();    System.out.println("server started on port: " + server.getPort());    server.join();}
73248d7e83db2d91e2c6c653030a712878a3b402a2ec7da4d45c916cd7846d05
respond
public Object respond(Message message, Object request) throws Exception
{    throw new AvroRemoteException("no messages!");}
791cf839ace78741bf544103a7fbd239d689111fd7fbb765da4b532af4d6085e
getRemoteName
public String getRemoteName()
{    return channel.socket().getRemoteSocketAddress().toString();}
ffd324fa490861d9cf8682f4c4abde52d33814b89fc764d5ce5930a5a654e67e
readBuffers
public synchronized List<ByteBuffer> readBuffers() throws IOException
{    List<ByteBuffer> buffers = new ArrayList<>();    while (true) {        header.clear();        while (header.hasRemaining()) {            if (channel.read(header) < 0)                throw new ClosedChannelException();        }        header.flip();        int length = header.getInt();        if (length == 0) {                        return buffers;        }        ByteBuffer buffer = ByteBuffer.allocate(length);        while (buffer.hasRemaining()) {            if (channel.read(buffer) < 0)                throw new ClosedChannelException();        }        buffer.flip();        buffers.add(buffer);    }}
b3113f0afc418dbdd251c31795761cb914245f3974348135fd38e83ec63c2aaa
writeBuffers
public synchronized void writeBuffers(List<ByteBuffer> buffers) throws IOException
{    if (buffers == null)                return;    for (ByteBuffer buffer : buffers) {        if (buffer.limit() == 0)            continue;                writeLength(buffer.limit());        channel.write(buffer);    }        writeLength(0);}
8cd02db67e1c2565fc00985e99aea5f3964a136bca51114d1e225054a1769c60
writeLength
private void writeLength(int length) throws IOException
{    header.clear();    header.putInt(length);    header.flip();    channel.write(header);}
d281b583c7876c25d7ad9fa27ea2d785aca24efb5315460c0e085a5cb6230e07
isConnected
public boolean isConnected()
{    return remote != null;}
913ed75cceb8eb315c8ba559f12f46cb86ae54e5f3d2c720415d09b17b57a1e5
setRemote
public void setRemote(Protocol remote)
{    this.remote = remote;}
211112435fc9aad0c85f999abf759f93ba0c11c2cc8f361d136bde6e5d96d6ee
getRemote
public Protocol getRemote()
{    return remote;}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    if (channel.isOpen()) {        LOG.info("closing to " + getRemoteName());        channel.close();    }}
b29b116b51cf90cb4852275e4c13929f6821310bf77a722d1dd150e9b330b0ca
getSpecificData
public SpecificData getSpecificData()
{    return data;}
c8cf409827c9c02d61d115df754cdc44ab22d275a15b4a955d5e90712865c441
invoke
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable
{    String name = method.getName();    switch(name) {        case "hashCode":            return hashCode();        case "equals":            Object obj = args[0];            return (proxy == obj) || (obj != null && Proxy.isProxyClass(obj.getClass()) && this.equals(Proxy.getInvocationHandler(obj)));        case "toString":            String protocol = "unknown";            String remote = "unknown";            Class<?>[] interfaces = proxy.getClass().getInterfaces();            if (interfaces.length > 0) {                try {                    protocol = Class.forName(interfaces[0].getName()).getSimpleName();                } catch (ClassNotFoundException e) {                }                InvocationHandler handler = Proxy.getInvocationHandler(proxy);                if (handler instanceof Requestor) {                    try {                        remote = ((Requestor) handler).getTransceiver().getRemoteName();                    } catch (IOException e) {                    }                }            }            return "Proxy[" + protocol + "," + remote + "]";        default:            try {                                Type[] parameterTypes = method.getParameterTypes();                if ((parameterTypes.length > 0) && (parameterTypes[parameterTypes.length - 1] instanceof Class) && Callback.class.isAssignableFrom(((Class<?>) parameterTypes[parameterTypes.length - 1]))) {                                        Object[] finalArgs = Arrays.copyOf(args, args.length - 1);                    Callback<?> callback = (Callback<?>) args[args.length - 1];                    request(method.getName(), finalArgs, callback);                    return null;                } else {                    return request(method.getName(), args);                }            } catch (Exception e) {                                for (Class<?> exceptionClass : method.getExceptionTypes()) {                    if (exceptionClass.isAssignableFrom(e.getClass())) {                        throw e;                    }                }                                if (e instanceof RuntimeException) {                    throw e;                }                                throw new AvroRuntimeException(e);            }    }}
560fc0d19092cf4055d65776141015eb1032b138ac4c5be7160fbc32bbf6628d
getDatumWriter
protected DatumWriter<Object> getDatumWriter(Schema schema)
{    return new SpecificDatumWriter<>(schema, data);}
50ab59825356fee719f05dc8bb6c6a07ecbd5a3d2816799303d7e0d3213d7366
getDatumReader
protected DatumReader<Object> getDatumReader(Schema schema)
{    return getDatumReader(schema, schema);}
4eaf0cf842661f2277f86e9d57a283a3aa7abcd31739262c611aac5e797e1f4e
getDatumReader
protected DatumReader<Object> getDatumReader(Schema writer, Schema reader)
{    return new SpecificDatumReader<>(writer, reader, data);}
482a4a2f1ea900cca086aab814e23cc10f983d3b6837cbdf07521b8645885a71
writeRequest
public void writeRequest(Schema schema, Object request, Encoder out) throws IOException
{    Object[] args = (Object[]) request;    int i = 0;    for (Schema.Field param : schema.getFields()) getDatumWriter(param.schema()).write(args[i++], out);}
08fe54bb238fd4eb602cc69910252c824b13e023830a05817ddccd3c835c1a86
readResponse
public Object readResponse(Schema writer, Schema reader, Decoder in) throws IOException
{    return getDatumReader(writer, reader).read(null, in);}
af07219e25674750d46d2f64aaeb414b2a55c746e3526993a1fc6cd05c8dc7d3
readError
public Exception readError(Schema writer, Schema reader, Decoder in) throws IOException
{    Object value = getDatumReader(writer, reader).read(null, in);    if (value instanceof Exception)        return (Exception) value;    return new AvroRuntimeException(value.toString());}
ac20205c76c006b2fef671c9995fad58dfa2f7a129e8d42a47df95fc9112193d
getClient
public static T getClient(Class<T> iface, Transceiver transceiver) throws IOException
{    return getClient(iface, transceiver, new SpecificData(iface.getClassLoader()));}
5ee144a401c5f6dff2d87f2d55f3f41fff962e11536e8e5a5318bedd34903f84
getClient
public static T getClient(Class<T> iface, Transceiver transceiver, SpecificData data) throws IOException
{    Protocol protocol = data.getProtocol(iface);    return (T) Proxy.newProxyInstance(data.getClassLoader(), new Class[] { iface }, new SpecificRequestor(protocol, transceiver, data));}
f4d7bf1db3d24d2fb8d83a639c7037275e68cd535e36d79255d47efe0a3930ee
getClient
public static T getClient(Class<T> iface, SpecificRequestor requestor) throws IOException
{    return (T) Proxy.newProxyInstance(requestor.data.getClassLoader(), new Class[] { iface }, requestor);}
fb99f1fc289b1ef0d8e869c6207d92884ca8cb9f8ca72c1fe7897c5c6294781c
getRemote
public static Protocol getRemote(Object proxy) throws IOException
{    return ((Requestor) Proxy.getInvocationHandler(proxy)).getRemote();}
b29b116b51cf90cb4852275e4c13929f6821310bf77a722d1dd150e9b330b0ca
getSpecificData
public SpecificData getSpecificData()
{    return (SpecificData) getGenericData();}
560fc0d19092cf4055d65776141015eb1032b138ac4c5be7160fbc32bbf6628d
getDatumWriter
protected DatumWriter<Object> getDatumWriter(Schema schema)
{    return new SpecificDatumWriter<>(schema, getSpecificData());}
7316ad7dea265abac3b6ed873e36e7ce7f846c6bb35631016ca533a880733b8e
getDatumReader
protected DatumReader<Object> getDatumReader(Schema actual, Schema expected)
{    return new SpecificDatumReader<>(actual, expected, getSpecificData());}
8582632205bd479415059358a7d0dcd15d1050b9f0744d1b4713510cad612e8e
writeError
public void writeError(Schema schema, Object error, Encoder out) throws IOException
{    getDatumWriter(schema).write(error, out);}
73248d7e83db2d91e2c6c653030a712878a3b402a2ec7da4d45c916cd7846d05
respond
public Object respond(Message message, Object request) throws Exception
{    int numParams = message.getRequest().getFields().size();    Object[] params = new Object[numParams];    Class[] paramTypes = new Class[numParams];    int i = 0;    try {        for (Schema.Field param : message.getRequest().getFields()) {            params[i] = ((GenericRecord) request).get(param.name());            paramTypes[i] = getSpecificData().getClass(param.schema());            i++;        }        Method method = impl.getClass().getMethod(message.getName(), paramTypes);        method.setAccessible(true);        return method.invoke(impl, params);    } catch (InvocationTargetException e) {        Throwable error = e.getTargetException();        if (error instanceof Exception) {            throw (Exception) error;        } else {            throw new AvroRuntimeException(error);        }    } catch (NoSuchMethodException | IllegalAccessException e) {        throw new AvroRuntimeException(e);    }}
c6b5792e775aa291bf8c936424b6b4de15a8e1dd8a322570bccffce6485b2042
add
public void add(Float value)
{    super.add(value);    runningSum += value;    runningSumOfSquares += value * value;}
d82c3efb7c04147e88b5fb9e9bf9b3039ae962d96c4f224376414ea4a2ec2201
getMean
public float getMean()
{    if (totalCount == 0) {        return Float.NaN;    }    return runningSum / totalCount;}
a562d6061351da0c3b9274cd75322fd28a4ec306943491281114af5006422f00
getUnbiasedStdDev
public float getUnbiasedStdDev()
{    if (totalCount <= 1) {        return Float.NaN;    }    float mean = getMean();    return (float) Math.sqrt((runningSumOfSquares - totalCount * mean * mean) / (totalCount - 1));}
b0ebb637a1bbe9e757cb8a4f78806178004ae86344996c8a9ce86042ee4eedf9
segment
public int segment(T value)
{    Map.Entry<T, Integer> e = index.floorEntry(value);    if (e == null) {        throw new SegmenterException("Could not find bucket for: " + value);    }    return e.getValue();}
72ef1e59027007ffe0950edfd2670ad03bb65cd6463d5d1d282dfeb1750435b0
size
public int size()
{    return index.size();}
4f5c29f28c0054c8aeb2a4de091bebe25374f359a152d3ba70667d6b0c55806e
rangeAsString
private String rangeAsString(T a, T b)
{    return String.format("[%s,%s)", a, b == null ? "infinity" : b);}
a3d449cc0c5d5f83b1eedb59eceed30a094da0f04ced8d18792798538f298eb5
getBoundaryLabels
public ArrayList<String> getBoundaryLabels()
{    ArrayList<String> outArray = new ArrayList<>(index.keySet().size());    for (T obj : index.keySet()) {        outArray.add(obj.toString());    }    return outArray;}
eb45c861a8905a9bbf3fc79fb1289bd875e748795394b90795b9b42718c58a4a
getBucketLabels
public ArrayList<String> getBucketLabels()
{    ArrayList<String> outArray = new ArrayList<>(index.keySet().size());    Iterator<String> bucketsIt = this.getBuckets();    while (bucketsIt.hasNext()) {        outArray.add(bucketsIt.next());    }    return outArray;}
30d7d21b201ff0bda84f9d20810108a46d64bc89086085206361ca2e307529ac
getBuckets
public Iterator<String> getBuckets()
{    return new Iterator<String>() {        Iterator<T> it = index.keySet().iterator();                T cur = it.next();        int pos = 0;        @Override        public boolean hasNext() {            return (pos < index.keySet().size());        }        @Override        public String next() {            pos = pos + 1;            T left = cur;            cur = it.hasNext() ? it.next() : null;            return rangeAsString(left, cur);        }        @Override        public void remove() {            throw new UnsupportedOperationException();        }    };}
d51e5f7450eca0a0f63da1a466189e262d053b84aa767ba3be5cea740af7251b
hasNext
public boolean hasNext()
{    return (pos < index.keySet().size());}
ed77fe77645381f593549d391060b177bb8ec6f91272c174b21fac104b2be013
next
public String next()
{    pos = pos + 1;    T left = cur;    cur = it.hasNext() ? it.next() : null;    return rangeAsString(left, cur);}
eb35e4acc0ab2c89fd30970f01fba35488b3a4581b2af1986091209043508a3e
remove
public void remove()
{    throw new UnsupportedOperationException();}
0ecc88cadac648a4c9428ba865dca13002db82bea2cf67e717dd4a5056f61683
add
public void add(T value)
{    int i = segmenter.segment(value);    counts[i]++;    totalCount++;    if (this.recentAdditions.size() > Histogram.MAX_HISTORY_SIZE) {        this.recentAdditions.pollLast();    }    this.recentAdditions.push(value);}
89411c4792b23acd9b51f23913b6cb562a64eb23380c681c927aab614cc49431
getHistogram
public int[] getHistogram()
{    return counts;}
8ee80f3797e129ed454511f5e54eeb1e083fb1166949989fa51102f062892606
getSegmenter
public Segmenter<B, T> getSegmenter()
{    return this.segmenter;}
d9a1f711a676e0ba67847369a1126d41f6f105e9c7a575795732a86f4590ce24
getRecentAdditions
public List<T> getRecentAdditions()
{    return this.recentAdditions;}
29fa59e92e8a9fa433fd7b38ebb21e8ece484149bc8e4a2726bba6f5dab39acf
getCount
public int getCount()
{    return totalCount;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    StringBuilder sb = new StringBuilder();    boolean first = true;    for (Entry<B> e : entries()) {        if (!first) {            sb.append(";");        } else {            first = false;        }        sb.append(e.bucket).append("=").append(e.count);    }    return sb.toString();}
e8b45b03b72fc8111d90c75fe7c7f92faaf4078fcab0d3a36a63d135c272e948
iterator
public Iterator<Entry<B>> iterator()
{    return this;}
d51e5f7450eca0a0f63da1a466189e262d053b84aa767ba3be5cea740af7251b
hasNext
public boolean hasNext()
{    return i < segmenter.size();}
62cc8bd77141c7f18c5c043863e0396d14301e3a979c32fbd220abd71e41002e
next
public Entry<B> next()
{    return new Entry<>(bucketNameIterator.next(), counts[i++]);}
eb35e4acc0ab2c89fd30970f01fba35488b3a4581b2af1986091209043508a3e
remove
public void remove()
{    throw new UnsupportedOperationException();}
931f80afc6fc9d2f38cbdaa76722b16b824871f6b1be719a4b8d27f074021339
entries
public Iterable<Entry<B>> entries()
{    return new EntryIterator();}
b1a5e74ca579a78dc541ce76453c980dcaf767727f0cbf32e7a82f123ea5de20
add
public void add(Integer value)
{    super.add(value);    runningSum += value;    runningSumOfSquares += value * value;}
d82c3efb7c04147e88b5fb9e9bf9b3039ae962d96c4f224376414ea4a2ec2201
getMean
public float getMean()
{    if (totalCount == 0) {        return -1;    }    return runningSum / (float) totalCount;}
a562d6061351da0c3b9274cd75322fd28a4ec306943491281114af5006422f00
getUnbiasedStdDev
public float getUnbiasedStdDev()
{    if (totalCount <= 1) {        return -1;    }    float mean = getMean();    return (float) Math.sqrt((runningSumOfSquares - totalCount * mean * mean) / (float) (totalCount - 1));}
1cca73098f37c5de74e90bc1306a7bf152ddb06dd9b24e52e3d4b4eaa834a792
getPayloadSize
private int getPayloadSize(List<ByteBuffer> payload)
{    if (payload == null) {        return 0;    }    int size = 0;    for (ByteBuffer bb : payload) {        size = size + bb.limit();    }    return size;}
21ae579f39574168939b76c5f0d979b2fd12fc74b9755beb51bda97afbd24a1d
serverReceiveRequest
public void serverReceiveRequest(RPCContext context)
{    Stopwatch t = new Stopwatch(ticks);    t.start();    this.activeRpcs.put(context, t);    synchronized (receivePayloads) {        IntegerHistogram<?> h = receivePayloads.get(context.getMessage());        if (h == null) {            h = createNewIntegerHistogram();            receivePayloads.put(context.getMessage(), h);        }        h.add(getPayloadSize(context.getRequestPayload()));    }}
034bcb1b9d0fa94a3160cb15a7f3143a37209f5031c7eda428c29ee5a11bd34b
serverSendResponse
public void serverSendResponse(RPCContext context)
{    Stopwatch t = this.activeRpcs.remove(context);    t.stop();    publish(context, t);    synchronized (sendPayloads) {        IntegerHistogram<?> h = sendPayloads.get(context.getMessage());        if (h == null) {            h = createNewIntegerHistogram();            sendPayloads.put(context.getMessage(), h);        }        h.add(getPayloadSize(context.getResponsePayload()));    }}
ea6bdcf9c835c22d11bd66ab2a18e412782107ab4560b183070c75314a39ab4c
clientSendRequest
public void clientSendRequest(RPCContext context)
{    Stopwatch t = new Stopwatch(ticks);    t.start();    this.activeRpcs.put(context, t);    synchronized (sendPayloads) {        IntegerHistogram<?> h = sendPayloads.get(context.getMessage());        if (h == null) {            h = createNewIntegerHistogram();            sendPayloads.put(context.getMessage(), h);        }        h.add(getPayloadSize(context.getRequestPayload()));    }}
f693dea6d9558ef56d9f642b77c1fc4e9ecd73f48c0ce6e08732a21b4d5894bd
clientReceiveResponse
public void clientReceiveResponse(RPCContext context)
{    Stopwatch t = this.activeRpcs.remove(context);    t.stop();    publish(context, t);    synchronized (receivePayloads) {        IntegerHistogram<?> h = receivePayloads.get(context.getMessage());        if (h == null) {            h = createNewIntegerHistogram();            receivePayloads.put(context.getMessage(), h);        }        h.add(getPayloadSize(context.getRequestPayload()));    }}
94944c248680eee14e21fa2a8b2283c83e4ac900f487f3808b957b2a7e794b24
publish
private void publish(RPCContext context, Stopwatch t)
{    Message message = context.getMessage();    if (message == null)        throw new IllegalArgumentException();    synchronized (methodTimings) {        FloatHistogram<?> h = methodTimings.get(context.getMessage());        if (h == null) {            h = createNewFloatHistogram();            methodTimings.put(context.getMessage(), h);        }        h.add(nanosToMillis(t.elapsedNanos()));    }}
d46b7ff7e7bdf757d69c7210b310715332448614476f5043332bf6d4ddadd731
createNewFloatHistogram
private FloatHistogram<?> createNewFloatHistogram()
{    return new FloatHistogram<>(floatSegmenter);}
344b8ab42a4370ddce039fd3130cd446b6fbc3ff18583fd2ac35c28377fbb75d
createNewIntegerHistogram
private IntegerHistogram<?> createNewIntegerHistogram()
{    return new IntegerHistogram<>(integerSegmenter);}
9c98138f24bab80bf0e4b4b3bda7ae05f6c399df95fb226b55def4dc5cedbf3f
nanosToMillis
 static float nanosToMillis(long elapsedNanos)
{    return elapsedNanos / 1000000.0f;}
2835ea794c0f1025b6ac99c8b37ea14a9a69c630c3b24deed40ea21a6525f819
getCharts
public ArrayList<HashMap<String, String>> getCharts()
{    return this.charts;}
c5243f659ed66060195d256ecf2dcaede54442fa558291b02d2412d42be3c377
getname
public String getname()
{    return this.name;}
a833642e21cbcc39703830875f7cad01330579ec9a889f9c7e21d2499f32783e
getNumCalls
public int getNumCalls()
{    return this.numCalls;}
680957eb5029a34230ef2da709bca7a863370aa6282e4acb37c1c7ef5bdc0d06
escapeStringArray
protected static List<String> escapeStringArray(List<String> input)
{    for (int i = 0; i < input.size(); i++) {        input.set(i, "\"" + input.get(i).replace("\"", "\\\"") + "\"");    }    return input;}
3ff3be40d7de1879a58f8349e25ae9978778e99ed2ab7aefd27e6c1059e7bdee
doGet
protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException
{    resp.setContentType("text/html");    String url = req.getRequestURL().toString();    String[] parts = url.split("//")[1].split("/");    try {        writeStats(resp.getWriter());    } catch (Exception e) {        e.printStackTrace();    }}
5299098df0f3f101d6a1fdb3b59dbb855e97c7ac78bd50b8e2bab5079ed45200
writeStats
public void writeStats(Writer w) throws IOException
{    VelocityContext context = new VelocityContext();    context.put("title", "Avro RPC Stats");        ArrayList<String> rpcs = new ArrayList<>();    ArrayList<RenderableMessage> messages = new ArrayList<>();    for (Entry<RPCContext, Stopwatch> rpc : this.statsPlugin.activeRpcs.entrySet()) {        rpcs.add(renderActiveRpc(rpc.getKey(), rpc.getValue()));    }        Set<Message> keys = null;    synchronized (this.statsPlugin.methodTimings) {        keys = this.statsPlugin.methodTimings.keySet();        for (Message m : keys) {            messages.add(renderMethod(m));        }    }    context.put("inFlightRpcs", rpcs);    context.put("messages", messages);    context.put("currTime", FORMATTER.format(new Date()));    context.put("startupTime", FORMATTER.format(statsPlugin.startupTime));    Template t;    try {        t = velocityEngine.getTemplate("org/apache/avro/ipc/stats/templates/statsview.vm");    } catch (Exception e) {        throw new IOException();    }    t.merge(context, w);}
4a7b51e8e7c7ddf2cd60fd828253317635def3fa60fe1f60f0f1eb6ffcaf25e4
renderActiveRpc
private String renderActiveRpc(RPCContext rpc, Stopwatch stopwatch) throws IOException
{    String out = new String();    out += rpc.getMessage().getName() + ": " + formatMillis(StatsPlugin.nanosToMillis(stopwatch.elapsedNanos()));    return out;}
64d6b960d24f5d37f74ec8294290eff6941748333dad4dbb61a573a4a6e8b08f
renderMethod
private RenderableMessage renderMethod(Message message)
{    RenderableMessage out = new RenderableMessage(message.getName());    synchronized (this.statsPlugin.methodTimings) {        FloatHistogram<?> hist = this.statsPlugin.methodTimings.get(message);        out.numCalls = hist.getCount();        HashMap<String, String> latencyBar = new HashMap<>();                latencyBar.put("type", "bar");        latencyBar.put("title", "All-Time Latency");        latencyBar.put("units", "ms");        latencyBar.put("numCalls", Integer.toString(hist.getCount()));        latencyBar.put("avg", Float.toString(hist.getMean()));        latencyBar.put("stdDev", Float.toString(hist.getUnbiasedStdDev()));        latencyBar.put("labelStr", Arrays.toString(hist.getSegmenter().getBoundaryLabels().toArray()));        latencyBar.put("boundaryStr", Arrays.toString(escapeStringArray(hist.getSegmenter().getBucketLabels()).toArray()));        latencyBar.put("dataStr", Arrays.toString(hist.getHistogram()));        out.charts.add(latencyBar);        HashMap<String, String> latencyDot = new HashMap<>();        latencyDot.put("title", "Latency");        latencyDot.put("type", "dot");        latencyDot.put("dataStr", Arrays.toString(hist.getRecentAdditions().toArray()));        out.charts.add(latencyDot);    }    synchronized (this.statsPlugin.sendPayloads) {        IntegerHistogram<?> hist = this.statsPlugin.sendPayloads.get(message);        HashMap<String, String> latencyBar = new HashMap<>();                latencyBar.put("type", "bar");        latencyBar.put("title", "All-Time Send Payload");        latencyBar.put("units", "ms");        latencyBar.put("numCalls", Integer.toString(hist.getCount()));        latencyBar.put("avg", Float.toString(hist.getMean()));        latencyBar.put("stdDev", Float.toString(hist.getUnbiasedStdDev()));        latencyBar.put("labelStr", Arrays.toString(hist.getSegmenter().getBoundaryLabels().toArray()));        latencyBar.put("boundaryStr", Arrays.toString(escapeStringArray(hist.getSegmenter().getBucketLabels()).toArray()));        latencyBar.put("dataStr", Arrays.toString(hist.getHistogram()));        out.charts.add(latencyBar);        HashMap<String, String> latencyDot = new HashMap<>();        latencyDot.put("title", "Send Payload");        latencyDot.put("type", "dot");        latencyDot.put("dataStr", Arrays.toString(hist.getRecentAdditions().toArray()));        out.charts.add(latencyDot);    }    synchronized (this.statsPlugin.receivePayloads) {        IntegerHistogram<?> hist = this.statsPlugin.receivePayloads.get(message);        HashMap<String, String> latencyBar = new HashMap<>();                latencyBar.put("type", "bar");        latencyBar.put("title", "All-Time Receive Payload");        latencyBar.put("units", "ms");        latencyBar.put("numCalls", Integer.toString(hist.getCount()));        latencyBar.put("avg", Float.toString(hist.getMean()));        latencyBar.put("stdDev", Float.toString(hist.getUnbiasedStdDev()));        latencyBar.put("labelStr", Arrays.toString(hist.getSegmenter().getBoundaryLabels().toArray()));        latencyBar.put("boundaryStr", Arrays.toString(escapeStringArray(hist.getSegmenter().getBucketLabels()).toArray()));        latencyBar.put("dataStr", Arrays.toString(hist.getHistogram()));        out.charts.add(latencyBar);        HashMap<String, String> latencyDot = new HashMap<>();        latencyDot.put("title", "Recv Payload");        latencyDot.put("type", "dot");        latencyDot.put("dataStr", Arrays.toString(hist.getRecentAdditions().toArray()));        out.charts.add(latencyDot);    }    return out;}
2c49000f404b3c103d5c03075bb94b66a96c92abe652069cedd345ddf3108f0e
formatMillis
private CharSequence formatMillis(float millis)
{    return String.format("%.0fms", millis);}
9547e461d50d201715950ee3152ccdb71cee3032efa22e86048916361211f927
elapsedNanos
public long elapsedNanos()
{    if (running) {        return this.ticks.ticks() - start;    } else {        if (elapsed == -1)            throw new IllegalStateException();        return elapsed;    }}
fe470100a468aa20bc462dab09f768d6e2ce225f184a550d87d7243e3d0f5667
start
public void start()
{    if (running)        throw new IllegalStateException();    start = ticks.ticks();    running = true;}
4e5c4125627f8fae3fcb8fa1c2fa25ff160d3eec452770c97bbb601a580fe141
stop
public void stop()
{    if (!running)        throw new IllegalStateException();    elapsed = ticks.ticks() - start;    running = false;}
313517c88a42e9484c4f16be1ef8a7155c465e375f1737fa18fb1386a4d4b3c4
ticks
public long ticks()
{    return System.nanoTime();}
f2a967c1674261f748af83ed2c160fd554943b290544c7488e35d26b313fab86
lockChannel
public void lockChannel()
{    channelLock.lock();}
6f1a1f017d3834ee5d55731778f7c000c9aa42d9390b4a2da9f41a907a725e47
unlockChannel
public void unlockChannel()
{    if (channelLock.isHeldByCurrentThread()) {        channelLock.unlock();    }}
f29f455f544a014333b5e52d94d0152fe4836453e7e9bc43c486c29d10db39ab
transceive
public List<ByteBuffer> transceive(List<ByteBuffer> request) throws IOException
{    lockChannel();    try {        writeBuffers(request);        return readBuffers();    } finally {        unlockChannel();    }}
60dfff4994d627a2e1774b2793f26971ec7953a0972bb77271a1378ea772529c
transceive
public void transceive(List<ByteBuffer> request, Callback<List<ByteBuffer>> callback) throws IOException
{        try {        List<ByteBuffer> response = transceive(request);        callback.handleResult(response);    } catch (IOException e) {        callback.handleError(e);    }}
d281b583c7876c25d7ad9fa27ea2d785aca24efb5315460c0e085a5cb6230e07
isConnected
public boolean isConnected()
{    return false;}
bd73d43970ff6893cf230d0ad5a84e57b8b0b930bcdb11b3ddbc1f3ca652f1f7
setRemote
public void setRemote(Protocol protocol)
{}
211112435fc9aad0c85f999abf759f93ba0c11c2cc8f361d136bde6e5d96d6ee
getRemote
public Protocol getRemote()
{    throw new IllegalStateException("Not connected.");}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{}
4ffd2730d2302e1ab91fe32a49cc7f6dbc9b471ad06f1a2c33da87a9519639d3
testEsc
public void testEsc()
{    assertEquals("\\\"", SpecificCompiler.javaEscape("\""));}
24ee6ee4240c0ab0ed6b50c55c9e3efafbb85ea88c1563396200b6d179d691d4
testMakePath
public void testMakePath()
{    SpecificCompiler compiler = new SpecificCompiler();    assertEquals("foo/bar/Baz.java".replace("/", File.separator), compiler.makePath("Baz", "foo.bar"));    assertEquals("baz.java", compiler.makePath("baz", ""));}
ad545a285dd93b03e7af5bed00165126fbf773ff00f853df39b609d5a09c29c2
testPrimitiveSchemaGeneratesNothing
public void testPrimitiveSchemaGeneratesNothing()
{    assertEquals(0, new SpecificCompiler(new Schema.Parser().parse("\"double\"")).compile().size());}
b57932bfd3f59964c6b7cc4a75a26a7bb8d59284b7c5a71a754913c009f58789
testSimpleEnumSchema
public void testSimpleEnumSchema() throws IOException
{    Collection<OutputFile> outputs = new SpecificCompiler(new Schema.Parser().parse(TestSchema.BASIC_ENUM_SCHEMA)).compile();    assertEquals(1, outputs.size());    OutputFile o = outputs.iterator().next();    assertEquals(o.path, "Test.java");    assertTrue(o.contents.contains("public enum Test"));    assertCompilesWithJavaCompiler(new File(INPUT_DIR.getRoot(), name.getMethodName()), outputs);}
4e9cfa7d7d978100f763e0a89efab0f15da634dde105e76d861034f1f4e7476a
testMangleIfReserved
public void testMangleIfReserved()
{    assertEquals("foo", SpecificCompiler.mangle("foo"));    assertEquals("goto$", SpecificCompiler.mangle("goto"));}
5f3a973dcd08bced5ef3eaeb21a7ece9ff943637d6857d573606751eb348e0d1
testManglingForProtocols
public void testManglingForProtocols() throws IOException
{    Collection<OutputFile> outputs = new SpecificCompiler(Protocol.parse(PROTOCOL)).compile();    Iterator<OutputFile> i = outputs.iterator();    String errType = i.next().contents;    String protocol = i.next().contents;    assertTrue(errType.contains("public class finally$ extends org.apache.avro.specific.SpecificExceptionBase"));    assertTrue(errType.contains("private boolean catch$;"));    assertTrue(protocol.contains("java.lang.CharSequence goto$(java.lang.CharSequence break$)"));    assertTrue(protocol.contains("public interface default$"));    assertTrue(protocol.contains(" finally$"));    assertCompilesWithJavaCompiler(new File(INPUT_DIR.getRoot(), name.getMethodName()), outputs);}
c792741d02e7a4e25cedefcf59f341fab16c9b915195c3593987d916516bbe22
testManglingForRecords
public void testManglingForRecords() throws IOException
{    Collection<OutputFile> outputs = new SpecificCompiler(new Schema.Parser().parse(SCHEMA)).compile();    assertEquals(1, outputs.size());    String contents = outputs.iterator().next().contents;    assertTrue(contents.contains("private java.lang.CharSequence package$;"));    assertTrue(contents.contains("class volatile$ extends"));    assertTrue(contents.contains("volatile$ short$;"));    assertCompilesWithJavaCompiler(new File(INPUT_DIR.getRoot(), name.getMethodName()), outputs);}
e8e91b0a1a6327a012e1e9edd34cb4b2ba3a9a16bb1fb2265e52729748dcb156
testManglingForEnums
public void testManglingForEnums() throws IOException
{    String enumSchema = "" + "{ \"name\": \"instanceof\", \"type\": \"enum\"," + "  \"symbols\": [\"new\", \"super\", \"switch\"] }";    Collection<OutputFile> outputs = new SpecificCompiler(new Schema.Parser().parse(enumSchema)).compile();    assertEquals(1, outputs.size());    String contents = outputs.iterator().next().contents;    assertTrue(contents.contains("new$"));    assertCompilesWithJavaCompiler(new File(INPUT_DIR.getRoot(), name.getMethodName()), outputs);}
14f77162f95c1502a74541b6afe4cbd40ae0e357cb6f1676fbd38fadc2989538
testSchemaSplit
public void testSchemaSplit() throws IOException
{    SpecificCompiler compiler = new SpecificCompiler(new Schema.Parser().parse(SCHEMA));    compiler.maxStringChars = 10;    Collection<OutputFile> files = compiler.compile();    assertCompilesWithJavaCompiler(new File(INPUT_DIR.getRoot(), name.getMethodName()), files);}
75986334d5c70fc5f49068a17b182a430b084452be1dffe70baf3e21811419d5
testProtocolSplit
public void testProtocolSplit() throws IOException
{    SpecificCompiler compiler = new SpecificCompiler(Protocol.parse(PROTOCOL));    compiler.maxStringChars = 10;    Collection<OutputFile> files = compiler.compile();    assertCompilesWithJavaCompiler(new File(INPUT_DIR.getRoot(), name.getMethodName()), files);}
505d73b22fe4ec63b6752738cc4bebc88587b659f371538d8b4f808b4e6dd495
testSchemaWithDocs
public void testSchemaWithDocs()
{    Collection<OutputFile> outputs = new SpecificCompiler(new Schema.Parser().parse(TestSchema.SCHEMA_WITH_DOC_TAGS)).compile();    assertEquals(3, outputs.size());    int count = 0;    for (OutputFile o : outputs) {        if (o.path.endsWith("outer_record.java")) {            count++;            assertTrue(o.contents.contains("/** This is not a world record. */"));            assertTrue(o.contents.contains("/** Inner Fixed */"));            assertTrue(o.contents.contains("/** Inner Enum */"));            assertTrue(o.contents.contains("/** Inner String */"));        }        if (o.path.endsWith("very_inner_fixed.java")) {            count++;            assertTrue(o.contents.contains("/** Very Inner Fixed */"));            assertTrue(o.contents.contains("@org.apache.avro.specific.FixedSize(1)"));        }        if (o.path.endsWith("very_inner_enum.java")) {            count++;            assertTrue(o.contents.contains("/** Very Inner Enum */"));        }    }    assertEquals(3, count);}
bb07e842a0f64300e919ef82cf4cbd9fd97c80506149b6d827de69fa65b0a234
testProtocolWithDocs
public void testProtocolWithDocs() throws IOException
{    Protocol protocol = TestProtocolParsing.getSimpleProtocol();    Collection<OutputFile> out = new SpecificCompiler(protocol).compile();    assertEquals(6, out.size());    int count = 0;    for (OutputFile o : out) {        if (o.path.endsWith("Simple.java")) {            count++;            assertTrue(o.contents.contains("/** Protocol used for testing. */"));            assertTrue(o.contents.contains("* Send a greeting"));        }    }    assertEquals("Missed generated protocol!", 1, count);}
9a0bb7f903f78b74fd85ba6c08335cadd87db32be3ae3175e434fc5b0bc4353b
testNeedCompile
public void testNeedCompile() throws IOException, InterruptedException
{    String schema = "" + "{ \"name\": \"Foo\", \"type\": \"record\", " + "  \"fields\": [ {\"name\": \"package\", \"type\": \"string\" }," + "                {\"name\": \"short\", \"type\": \"Foo\" } ] }";    File inputFile = new File(INPUT_DIR.getRoot().getPath(), "input.avsc");    try (FileWriter fw = new FileWriter(inputFile)) {        fw.write(schema);    }    File outputDir = OUTPUT_DIR.getRoot();    File outputFile = new File(outputDir, "Foo.java");    outputFile.delete();    assertTrue(!outputFile.exists());    outputDir.delete();    assertTrue(!outputDir.exists());    SpecificCompiler.compileSchema(inputFile, outputDir);    assertTrue(outputDir.exists());    assertTrue(outputFile.exists());    long lastModified = outputFile.lastModified();        Thread.sleep(1000);    SpecificCompiler.compileSchema(inputFile, outputDir);    assertEquals(lastModified, outputFile.lastModified());    try (FileWriter fw = new FileWriter(inputFile)) {        fw.write(schema);    }    SpecificCompiler.compileSchema(inputFile, outputDir);    assertTrue(lastModified != outputFile.lastModified());}
7044a9847b0cd3163425ee76cb099d194735eaccb78728eceddadeb90d95e8ef
createRecord
private Schema createRecord(String name, boolean isError, Field... fields)
{    Schema record = Schema.createRecord(name, null, null, isError);    record.setFields(Arrays.asList(fields));    return record;}
7318a11d3fd74dbd5c0e00406053bdb162c0c9299ba1b2a5f3be25e2503a3433
generateGetMethod
public void generateGetMethod()
{    Field height = new Field("height", Schema.create(Type.INT), null, null);    Field Height = new Field("Height", Schema.create(Type.INT), null, null);    Field height_and_width = new Field("height_and_width", Schema.create(Type.STRING), null, null);    Field message = new Field("message", Schema.create(Type.STRING), null, null);    Field Message = new Field("Message", Schema.create(Type.STRING), null, null);    Field cause = new Field("cause", Schema.create(Type.STRING), null, null);    Field clasz = new Field("class", Schema.create(Type.STRING), null, null);    Field schema = new Field("schema", Schema.create(Type.STRING), null, null);    Field Schema$ = new Field("Schema", Schema.create(Type.STRING), null, null);    assertEquals("getHeight", SpecificCompiler.generateGetMethod(createRecord("test", false, height), height));    assertEquals("getHeightAndWidth", SpecificCompiler.generateGetMethod(createRecord("test", false, height_and_width), height_and_width));    assertEquals("getMessage", SpecificCompiler.generateGetMethod(createRecord("test", false, message), message));    message = new Field("message", Schema.create(Type.STRING), null, null);    assertEquals("getMessage$", SpecificCompiler.generateGetMethod(createRecord("test", true, message), message));    assertEquals("getCause", SpecificCompiler.generateGetMethod(createRecord("test", false, cause), cause));    cause = new Field("cause", Schema.create(Type.STRING), null, null);    assertEquals("getCause$", SpecificCompiler.generateGetMethod(createRecord("test", true, cause), cause));    assertEquals("getClass$", SpecificCompiler.generateGetMethod(createRecord("test", false, clasz), clasz));    clasz = new Field("class", Schema.create(Type.STRING), null, null);    assertEquals("getClass$", SpecificCompiler.generateGetMethod(createRecord("test", true, clasz), clasz));    assertEquals("getSchema$", SpecificCompiler.generateGetMethod(createRecord("test", false, schema), schema));    schema = new Field("schema", Schema.create(Type.STRING), null, null);    assertEquals("getSchema$", SpecificCompiler.generateGetMethod(createRecord("test", true, schema), schema));    height = new Field("height", Schema.create(Type.INT), null, null);    Height = new Field("Height", Schema.create(Type.INT), null, null);    assertEquals("getHeight", SpecificCompiler.generateGetMethod(createRecord("test", false, Height), Height));    height = new Field("height", Schema.create(Type.INT), null, null);    Height = new Field("Height", Schema.create(Type.INT), null, null);    assertEquals("getHeight$0", SpecificCompiler.generateGetMethod(createRecord("test", false, height, Height), height));    height = new Field("height", Schema.create(Type.INT), null, null);    Height = new Field("Height", Schema.create(Type.INT), null, null);    assertEquals("getHeight$1", SpecificCompiler.generateGetMethod(createRecord("test", false, height, Height), Height));    message = new Field("message", Schema.create(Type.STRING), null, null);    Message = new Field("Message", Schema.create(Type.STRING), null, null);    assertEquals("getMessage$", SpecificCompiler.generateGetMethod(createRecord("test", true, Message), Message));    message = new Field("message", Schema.create(Type.STRING), null, null);    Message = new Field("Message", Schema.create(Type.STRING), null, null);    assertEquals("getMessage$0", SpecificCompiler.generateGetMethod(createRecord("test", true, message, Message), message));    message = new Field("message", Schema.create(Type.STRING), null, null);    Message = new Field("Message", Schema.create(Type.STRING), null, null);    assertEquals("getMessage$1", SpecificCompiler.generateGetMethod(createRecord("test", true, message, Message), Message));    schema = new Field("schema", Schema.create(Type.STRING), null, null);    Schema$ = new Field("Schema", Schema.create(Type.STRING), null, null);    assertEquals("getSchema$", SpecificCompiler.generateGetMethod(createRecord("test", false, Schema$), Schema$));    schema = new Field("schema", Schema.create(Type.STRING), null, null);    Schema$ = new Field("Schema", Schema.create(Type.STRING), null, null);    assertEquals("getSchema$0", SpecificCompiler.generateGetMethod(createRecord("test", false, schema, Schema$), schema));    schema = new Field("schema", Schema.create(Type.STRING), null, null);    Schema$ = new Field("Schema", Schema.create(Type.STRING), null, null);    assertEquals("getSchema$1", SpecificCompiler.generateGetMethod(createRecord("test", false, schema, Schema$), Schema$));}
aa666d2c0a7896d84f4a7058d81bc770f29decc8f8e1d6bb92457b47ebb93999
generateSetMethod
public void generateSetMethod()
{    Field height = new Field("height", Schema.create(Type.INT), null, null);    Field Height = new Field("Height", Schema.create(Type.INT), null, null);    Field height_and_width = new Field("height_and_width", Schema.create(Type.STRING), null, null);    Field message = new Field("message", Schema.create(Type.STRING), null, null);    Field Message = new Field("Message", Schema.create(Type.STRING), null, null);    Field cause = new Field("cause", Schema.create(Type.STRING), null, null);    Field clasz = new Field("class", Schema.create(Type.STRING), null, null);    Field schema = new Field("schema", Schema.create(Type.STRING), null, null);    Field Schema$ = new Field("Schema", Schema.create(Type.STRING), null, null);    assertEquals("setHeight", SpecificCompiler.generateSetMethod(createRecord("test", false, height), height));    assertEquals("setHeightAndWidth", SpecificCompiler.generateSetMethod(createRecord("test", false, height_and_width), height_and_width));    assertEquals("setMessage", SpecificCompiler.generateSetMethod(createRecord("test", false, message), message));    message = new Field("message", Schema.create(Type.STRING), null, null);    assertEquals("setMessage$", SpecificCompiler.generateSetMethod(createRecord("test", true, message), message));    assertEquals("setCause", SpecificCompiler.generateSetMethod(createRecord("test", false, cause), cause));    cause = new Field("cause", Schema.create(Type.STRING), null, null);    assertEquals("setCause$", SpecificCompiler.generateSetMethod(createRecord("test", true, cause), cause));    assertEquals("setClass$", SpecificCompiler.generateSetMethod(createRecord("test", false, clasz), clasz));    clasz = new Field("class", Schema.create(Type.STRING), null, null);    assertEquals("setClass$", SpecificCompiler.generateSetMethod(createRecord("test", true, clasz), clasz));    assertEquals("setSchema$", SpecificCompiler.generateSetMethod(createRecord("test", false, schema), schema));    schema = new Field("schema", Schema.create(Type.STRING), null, null);    assertEquals("setSchema$", SpecificCompiler.generateSetMethod(createRecord("test", true, schema), schema));    height = new Field("height", Schema.create(Type.INT), null, null);    Height = new Field("Height", Schema.create(Type.INT), null, null);    assertEquals("setHeight", SpecificCompiler.generateSetMethod(createRecord("test", false, Height), Height));    height = new Field("height", Schema.create(Type.INT), null, null);    Height = new Field("Height", Schema.create(Type.INT), null, null);    assertEquals("setHeight$0", SpecificCompiler.generateSetMethod(createRecord("test", false, height, Height), height));    height = new Field("height", Schema.create(Type.INT), null, null);    Height = new Field("Height", Schema.create(Type.INT), null, null);    assertEquals("setHeight$1", SpecificCompiler.generateSetMethod(createRecord("test", false, height, Height), Height));    message = new Field("message", Schema.create(Type.STRING), null, null);    Message = new Field("Message", Schema.create(Type.STRING), null, null);    assertEquals("setMessage$", SpecificCompiler.generateSetMethod(createRecord("test", true, Message), Message));    message = new Field("message", Schema.create(Type.STRING), null, null);    Message = new Field("Message", Schema.create(Type.STRING), null, null);    assertEquals("setMessage$0", SpecificCompiler.generateSetMethod(createRecord("test", true, message, Message), message));    message = new Field("message", Schema.create(Type.STRING), null, null);    Message = new Field("Message", Schema.create(Type.STRING), null, null);    assertEquals("setMessage$1", SpecificCompiler.generateSetMethod(createRecord("test", true, message, Message), Message));    schema = new Field("schema", Schema.create(Type.STRING), null, null);    Schema$ = new Field("Schema", Schema.create(Type.STRING), null, null);    assertEquals("setSchema$", SpecificCompiler.generateSetMethod(createRecord("test", false, Schema$), Schema$));    schema = new Field("schema", Schema.create(Type.STRING), null, null);    Schema$ = new Field("Schema", Schema.create(Type.STRING), null, null);    assertEquals("setSchema$0", SpecificCompiler.generateSetMethod(createRecord("test", false, schema, Schema$), schema));    schema = new Field("schema", Schema.create(Type.STRING), null, null);    Schema$ = new Field("Schema", Schema.create(Type.STRING), null, null);    assertEquals("setSchema$1", SpecificCompiler.generateSetMethod(createRecord("test", false, schema, Schema$), Schema$));}
255d102ff214c7a0a7e20ae899df20ce486c40b7b527f68ea672c3e04a934351
generateHasMethod
public void generateHasMethod()
{    Field height = new Field("height", Schema.create(Type.INT), null, null);    Field Height = new Field("Height", Schema.create(Type.INT), null, null);    Field height_and_width = new Field("height_and_width", Schema.create(Type.STRING), null, null);    Field message = new Field("message", Schema.create(Type.STRING), null, null);    Field Message = new Field("Message", Schema.create(Type.STRING), null, null);    Field cause = new Field("cause", Schema.create(Type.STRING), null, null);    Field clasz = new Field("class", Schema.create(Type.STRING), null, null);    Field schema = new Field("schema", Schema.create(Type.STRING), null, null);    Field Schema$ = new Field("Schema", Schema.create(Type.STRING), null, null);    assertEquals("hasHeight", SpecificCompiler.generateHasMethod(createRecord("test", false, height), height));    assertEquals("hasHeightAndWidth", SpecificCompiler.generateHasMethod(createRecord("test", false, height_and_width), height_and_width));    assertEquals("hasMessage", SpecificCompiler.generateHasMethod(createRecord("test", false, message), message));    message = new Field("message", Schema.create(Type.STRING), null, null);    assertEquals("hasMessage$", SpecificCompiler.generateHasMethod(createRecord("test", true, message), message));    assertEquals("hasCause", SpecificCompiler.generateHasMethod(createRecord("test", false, cause), cause));    cause = new Field("cause", Schema.create(Type.STRING), null, null);    assertEquals("hasCause$", SpecificCompiler.generateHasMethod(createRecord("test", true, cause), cause));    assertEquals("hasClass$", SpecificCompiler.generateHasMethod(createRecord("test", false, clasz), clasz));    clasz = new Field("class", Schema.create(Type.STRING), null, null);    assertEquals("hasClass$", SpecificCompiler.generateHasMethod(createRecord("test", true, clasz), clasz));    assertEquals("hasSchema$", SpecificCompiler.generateHasMethod(createRecord("test", false, schema), schema));    schema = new Field("schema", Schema.create(Type.STRING), null, null);    assertEquals("hasSchema$", SpecificCompiler.generateHasMethod(createRecord("test", true, schema), schema));    height = new Field("height", Schema.create(Type.INT), null, null);    Height = new Field("Height", Schema.create(Type.INT), null, null);    assertEquals("hasHeight", SpecificCompiler.generateHasMethod(createRecord("test", false, Height), Height));    height = new Field("height", Schema.create(Type.INT), null, null);    Height = new Field("Height", Schema.create(Type.INT), null, null);    assertEquals("hasHeight$0", SpecificCompiler.generateHasMethod(createRecord("test", false, height, Height), height));    height = new Field("height", Schema.create(Type.INT), null, null);    Height = new Field("Height", Schema.create(Type.INT), null, null);    assertEquals("hasHeight$1", SpecificCompiler.generateHasMethod(createRecord("test", false, height, Height), Height));    message = new Field("message", Schema.create(Type.STRING), null, null);    Message = new Field("Message", Schema.create(Type.STRING), null, null);    assertEquals("hasMessage$", SpecificCompiler.generateHasMethod(createRecord("test", true, Message), Message));    message = new Field("message", Schema.create(Type.STRING), null, null);    Message = new Field("Message", Schema.create(Type.STRING), null, null);    assertEquals("hasMessage$0", SpecificCompiler.generateHasMethod(createRecord("test", true, message, Message), message));    message = new Field("message", Schema.create(Type.STRING), null, null);    Message = new Field("Message", Schema.create(Type.STRING), null, null);    assertEquals("hasMessage$1", SpecificCompiler.generateHasMethod(createRecord("test", true, message, Message), Message));    schema = new Field("schema", Schema.create(Type.STRING), null, null);    Schema$ = new Field("Schema", Schema.create(Type.STRING), null, null);    assertEquals("hasSchema$", SpecificCompiler.generateHasMethod(createRecord("test", false, Schema$), Schema$));    schema = new Field("schema", Schema.create(Type.STRING), null, null);    Schema$ = new Field("Schema", Schema.create(Type.STRING), null, null);    assertEquals("hasSchema$0", SpecificCompiler.generateHasMethod(createRecord("test", false, schema, Schema$), schema));    schema = new Field("schema", Schema.create(Type.STRING), null, null);    Schema$ = new Field("Schema", Schema.create(Type.STRING), null, null);    assertEquals("hasSchema$1", SpecificCompiler.generateHasMethod(createRecord("test", false, schema, Schema$), Schema$));}
d76e3754740c3186154542cbd2934835e4cb2932be9639b6c29bfb02bfffa0cc
generateClearMethod
public void generateClearMethod()
{    Field height = new Field("height", Schema.create(Type.INT), null, null);    Field Height = new Field("Height", Schema.create(Type.INT), null, null);    Field height_and_width = new Field("height_and_width", Schema.create(Type.STRING), null, null);    Field message = new Field("message", Schema.create(Type.STRING), null, null);    Field Message = new Field("Message", Schema.create(Type.STRING), null, null);    Field cause = new Field("cause", Schema.create(Type.STRING), null, null);    Field clasz = new Field("class", Schema.create(Type.STRING), null, null);    Field schema = new Field("schema", Schema.create(Type.STRING), null, null);    Field Schema$ = new Field("Schema", Schema.create(Type.STRING), null, null);    assertEquals("clearHeight", SpecificCompiler.generateClearMethod(createRecord("test", false, height), height));    assertEquals("clearHeightAndWidth", SpecificCompiler.generateClearMethod(createRecord("test", false, height_and_width), height_and_width));    assertEquals("clearMessage", SpecificCompiler.generateClearMethod(createRecord("test", false, message), message));    message = new Field("message", Schema.create(Type.STRING), null, null);    assertEquals("clearMessage$", SpecificCompiler.generateClearMethod(createRecord("test", true, message), message));    assertEquals("clearCause", SpecificCompiler.generateClearMethod(createRecord("test", false, cause), cause));    cause = new Field("cause", Schema.create(Type.STRING), null, null);    assertEquals("clearCause$", SpecificCompiler.generateClearMethod(createRecord("test", true, cause), cause));    assertEquals("clearClass$", SpecificCompiler.generateClearMethod(createRecord("test", false, clasz), clasz));    clasz = new Field("class", Schema.create(Type.STRING), null, null);    assertEquals("clearClass$", SpecificCompiler.generateClearMethod(createRecord("test", true, clasz), clasz));    assertEquals("clearSchema$", SpecificCompiler.generateClearMethod(createRecord("test", false, schema), schema));    schema = new Field("schema", Schema.create(Type.STRING), null, null);    assertEquals("clearSchema$", SpecificCompiler.generateClearMethod(createRecord("test", true, schema), schema));    height = new Field("height", Schema.create(Type.INT), null, null);    Height = new Field("Height", Schema.create(Type.INT), null, null);    assertEquals("clearHeight", SpecificCompiler.generateClearMethod(createRecord("test", false, Height), Height));    height = new Field("height", Schema.create(Type.INT), null, null);    Height = new Field("Height", Schema.create(Type.INT), null, null);    assertEquals("clearHeight$0", SpecificCompiler.generateClearMethod(createRecord("test", false, height, Height), height));    height = new Field("height", Schema.create(Type.INT), null, null);    Height = new Field("Height", Schema.create(Type.INT), null, null);    assertEquals("clearHeight$1", SpecificCompiler.generateClearMethod(createRecord("test", false, height, Height), Height));    message = new Field("message", Schema.create(Type.STRING), null, null);    Message = new Field("Message", Schema.create(Type.STRING), null, null);    assertEquals("clearMessage$", SpecificCompiler.generateClearMethod(createRecord("test", true, Message), Message));    message = new Field("message", Schema.create(Type.STRING), null, null);    Message = new Field("Message", Schema.create(Type.STRING), null, null);    assertEquals("clearMessage$0", SpecificCompiler.generateClearMethod(createRecord("test", true, message, Message), message));    message = new Field("message", Schema.create(Type.STRING), null, null);    Message = new Field("Message", Schema.create(Type.STRING), null, null);    assertEquals("clearMessage$1", SpecificCompiler.generateClearMethod(createRecord("test", true, message, Message), Message));    schema = new Field("schema", Schema.create(Type.STRING), null, null);    Schema$ = new Field("Schema", Schema.create(Type.STRING), null, null);    assertEquals("clearSchema$", SpecificCompiler.generateClearMethod(createRecord("test", false, Schema$), Schema$));    schema = new Field("schema", Schema.create(Type.STRING), null, null);    Schema$ = new Field("Schema", Schema.create(Type.STRING), null, null);    assertEquals("clearSchema$0", SpecificCompiler.generateClearMethod(createRecord("test", false, schema, Schema$), schema));    schema = new Field("schema", Schema.create(Type.STRING), null, null);    Schema$ = new Field("Schema", Schema.create(Type.STRING), null, null);    assertEquals("clearSchema$1", SpecificCompiler.generateClearMethod(createRecord("test", false, schema, Schema$), Schema$));}
e6c567dde7bfc4c2c255b00a0efbeb30beb4535ce0f5d58126dae35e0f512775
testAnnotations
public void testAnnotations() throws Exception
{        assertNotNull(Simple.class.getAnnotation(TestAnnotation.class));        assertNotNull(TestRecord.class.getAnnotation(TestAnnotation.class));        assertNotNull(MD5.class.getAnnotation(TestAnnotation.class));        assertNotNull(Kind.class.getAnnotation(TestAnnotation.class));        assertNotNull(TestRecord.class.getField("name").getAnnotation(TestAnnotation.class));        assertNotNull(Simple.class.getMethod("ack").getAnnotation(TestAnnotation.class));}
e1d91aa6041c07f5feab9796921d2f19811f8b2828e1362693881355d7d24be7
testAliases
public void testAliases() throws IOException
{    Schema s = new Schema.Parser().parse("{\"name\":\"X\",\"type\":\"record\",\"aliases\":[\"Y\"],\"fields\":[" + "{\"name\":\"f\",\"type\":\"int\",\"aliases\":[\"g\"]}]}");    SpecificCompiler compiler = new SpecificCompiler(s);    compiler.setStringType(StringType.valueOf("String"));    Collection<OutputFile> outputs = compiler.compile();    assertEquals(1, outputs.size());    OutputFile o = outputs.iterator().next();    assertEquals(o.path, "X.java");    assertTrue(o.contents.contains("[\\\"Y\\\"]"));    assertTrue(o.contents.contains("[\\\"g\\\"]"));}
eed0452464c6b7abfc8a7deebfb4787fa70f7c02bd504b6a53773a41ab7d140e
assertCompiles
public static void assertCompiles(File dstDir, Schema schema, boolean useJavaCompiler) throws IOException
{    Collection<OutputFile> outputs = new SpecificCompiler(schema).compile();    assertNotNull(outputs);    if (useJavaCompiler) {        assertCompilesWithJavaCompiler(dstDir, outputs);    }}
ca0e1f398beffc685782e4457f3e7dc5deb7a30c0027942c2a663b15e2c25fd4
assertCompiles
public static void assertCompiles(File dstDir, Protocol protocol, boolean useJavaCompiler) throws IOException
{    Collection<OutputFile> outputs = new SpecificCompiler(protocol).compile();    assertNotNull(outputs);    if (useJavaCompiler) {        assertCompilesWithJavaCompiler(dstDir, outputs);    }}
0b1d9c89774f3b33f5762a01bdcfbfc3e96eb5f54675e7b17ed792c60b883e3a
assertCompilesWithJavaCompiler
 static void assertCompilesWithJavaCompiler(File dstDir, Collection<OutputFile> outputs) throws IOException
{    if (outputs.isEmpty()) {                return;    }    List<File> javaFiles = new ArrayList<>();    for (OutputFile o : outputs) {        javaFiles.add(o.writeToDestination(null, dstDir));    }    JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();    StandardJavaFileManager fileManager = compiler.getStandardFileManager(null, null, null);    CompilationTask cTask = compiler.getTask(null, fileManager, null, null, null, fileManager.getJavaFileObjects(javaFiles.toArray(new File[0])));    assertTrue(cTask.call());}
c1cf4f2d42c74ce4af8ff22de262026fe6314d782aa2f0accdb472aa936050cc
printDir
public static void printDir()
{    System.out.println("Reading data files from directory: " + DATAFILE_DIR.getAbsolutePath());}
1c5d8932178201a9032a39c0c6b2c515dfe2fd12bec388792866b20cfb18f839
testGeneratedGeneric
public void testGeneratedGeneric() throws IOException
{    System.out.println("Reading with generic:");    DatumReaderProvider<Object> provider = GenericDatumReader::new;    readFiles(provider);}
44064ae6362860afc19edd0a80660a1962237ff9832b26f4e454313372be2c03
testGeneratedSpecific
public void testGeneratedSpecific() throws IOException
{    System.out.println("Reading with specific:");    DatumReaderProvider<Interop> provider = SpecificDatumReader::new;    readFiles(provider);}
f7d8e447583c090b92abef2d9a3a18df7c85a551713f34d3047f2e727c053983
readFiles
private void readFiles(DatumReaderProvider<T> provider) throws IOException
{    for (File f : Objects.requireNonNull(DATAFILE_DIR.listFiles())) {        System.out.println("Reading: " + f.getName());        try (FileReader<? extends Object> reader = DataFileReader.openReader(f, provider.get())) {            int i = 0;            for (Object datum : reader) {                i++;                Assert.assertNotNull(datum);            }            Assert.assertNotEquals(0, i);        }    }}
f75ec3e46d935c1a3bc1174434aa1f43b769424a71ff0cfc4ef4a6f154b97de9
testDeepCopy
public void testDeepCopy()
{        Interop.Builder interopBuilder = Interop.newBuilder();    interopBuilder.setArrayField(Arrays.asList(1.1, 1.2, 1.3, 1.4));    interopBuilder.setBoolField(true);    interopBuilder.setBytesField(ByteBuffer.wrap(new byte[] { 1, 2, 3, 4 }));    interopBuilder.setDoubleField(3.14d);    interopBuilder.setEnumField(Kind.B);    interopBuilder.setFixedField(new MD5(new byte[] { 4, 3, 2, 1, 4, 3, 2, 1, 4, 3, 2, 1, 4, 3, 2, 1 }));    interopBuilder.setFloatField(6.022f);    interopBuilder.setIntField(32);    interopBuilder.setLongField(64L);    Map<java.lang.String, org.apache.avro.Foo> map = new HashMap<>(1);    map.put("foo", Foo.newBuilder().setLabel("bar").build());    interopBuilder.setMapField(map);    interopBuilder.setNullField(null);    Node.Builder rootBuilder = Node.newBuilder().setLabel("/");    Node.Builder homeBuilder = Node.newBuilder().setLabel("home");    homeBuilder.setChildren(new ArrayList<>(0));    rootBuilder.setChildren(Collections.singletonList(homeBuilder.build()));    interopBuilder.setRecordField(rootBuilder.build());    interopBuilder.setStringField("Hello");    interopBuilder.setUnionField(Collections.singletonList(ByteBuffer.wrap(new byte[] { 1, 2 })));    Interop interop = interopBuilder.build();        for (Field field : Interop.SCHEMA$.getFields()) {                if (interop.get(field.pos()) instanceof ByteBuffer) {            assertTrue(Arrays.equals(((ByteBuffer) interop.get(field.pos())).array(), ((ByteBuffer) GenericData.get().deepCopy(field.schema(), interop.get(field.pos()))).array()));        } else {            assertEquals(interop.get(field.pos()), SpecificData.get().deepCopy(field.schema(), interop.get(field.pos())));        }                if ((field.schema().getType() != Type.ENUM) && (field.schema().getType() != Type.NULL) && (field.schema().getType() != Type.BOOLEAN) && (field.schema().getType() != Type.INT) && (field.schema().getType() != Type.LONG) && (field.schema().getType() != Type.FLOAT) && (field.schema().getType() != Type.DOUBLE) && (field.schema().getType() != Type.STRING)) {            assertFalse("Field " + field.name() + " is same instance in deep copy", interop.get(field.pos()) == GenericData.get().deepCopy(field.schema(), interop.get(field.pos())));        }    }}
19e0d784d42fc4f1e9f21e965dba33f6899e763d41df02a398cd51e5af53a6be
newRandom
protected static Random newRandom()
{    return new Random(SEED);}
82ec77135897c0a29a86c00d120de510a708b6bebe2cbc08a80860fdcff2e2d5
add
 void add(List<TestDescriptor> typeList)
{    ALL_TESTS.put(param, this);    typeList.add(this);}
6c655505072f20944de454aea0c62e0c64dc3a771527717e8ff71d825b651203
usage
private static void usage()
{    StringBuilder usage = new StringBuilder("Usage: Perf [-o <file>] [-c <spec>] { -nowrite | -noread }");    StringBuilder details = new StringBuilder();    details.append(" -o file   (send output to a file)\n");    details.append(" -c [n][t][e][b][c][m] (format as no-header CSV; include Name, Time, Entries/sec, Bytes/sec, bytes/Cycle, and/or min time/op; no spec=all fields)\n");    details.append(" -nowrite   (do not execute write tests)\n");    details.append(" -noread   (do not execute write tests)\n");    for (Map.Entry<String, List<TestDescriptor>> entry : BATCHES.entrySet()) {        List<TestDescriptor> lt = entry.getValue();        String param = entry.getKey();        String paramName = param.substring(1);        usage.append(param).append(" | ");        details.append(" ").append(param).append("   (executes all ").append(paramName).append(" tests):\n");        for (TestDescriptor t : lt) {            usage.append(t.param).append(" | ");            details.append("      ").append(t.param).append("  (").append(t.test.getSimpleName()).append(")\n");        }    }    usage.setLength(usage.length() - 2);    usage.append("}\n");    System.out.println(usage.toString());    System.out.print(details.toString());}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    if (0 != (COUNT % 4)) {        System.out.println("Property 'org.apache.avro.io.perf.count' must be a multiple of 4.");        System.exit(1);    }    List<Test> tests = new ArrayList<>();    boolean writeTests = true;    boolean readTests = true;    String outputfilename = null;    PrintStream out = System.out;    boolean[] csvFormat = null;    String csvFormatString = null;    for (int i = 0; i < args.length; i++) {        String a = args[i];        TestDescriptor t = ALL_TESTS.get(a);        if (null != t) {            tests.add(t.test.newInstance());            continue;        }        List<TestDescriptor> lt = BATCHES.get(a);        if (null != lt) {            for (TestDescriptor td : lt) {                tests.add(td.test.newInstance());            }            continue;        }        if (i < args.length - 1 && "-o".equals(a)) {            outputfilename = args[++i];            out = new PrintStream(new FileOutputStream(outputfilename));            continue;        }        if ("-c".equals(a)) {            if (i == args.length - 1 || args[i + 1].startsWith("-")) {                                csvFormatString = "ntebcm";                csvFormat = new boolean[] { true, true, true, true, true, true };            } else {                csvFormatString = args[++i];                csvFormat = new boolean[MAX_FIELD_TAG + 1];                for (char c : csvFormatString.toCharArray()) switch(c) {                    case 'n':                        csvFormat[NAME_FIELD] = true;                        break;                    case 't':                        csvFormat[TIME_FIELD] = true;                        break;                    case 'e':                        csvFormat[BYTES_PS_FIELD] = true;                        break;                    case 'b':                        csvFormat[ENTRIES_PS_FIELD] = true;                        break;                    case 'c':                        csvFormat[BYTES_PC_FIELD] = true;                        break;                    case 'm':                        csvFormat[MIN_TIME_FIELD] = true;                        break;                    default:                        usage();                        System.exit(1);                }            }            continue;        }        if ("-nowrite".equals(a)) {            writeTests = false;            continue;        }        if ("-noread".equals(a)) {            readTests = false;            continue;        }        usage();        System.exit(1);    }    if (tests.isEmpty()) {        for (Map.Entry<String, TestDescriptor> entry : ALL_TESTS.entrySet()) {            TestDescriptor t = entry.getValue();            Test test = t.test.newInstance();            tests.add(test);        }    }    System.out.println("Executing tests: \n" + tests + "\n readTests:" + readTests + "\n writeTests:" + writeTests + "\n cycles=" + CYCLES + "\n count=" + (COUNT / 1000) + "K");    if (out != System.out)        System.out.println(" Writing to: " + outputfilename);    if (csvFormat != null)        System.out.println(" CSV format: " + csvFormatString);    TestResult tr = new TestResult();    for (Test t : tests) {        try {                        t.init();            if (t.isReadTest()) {                t.readTest();            }            if (t.isWriteTest()) {                t.writeTest();            }            t.reset();        } catch (Exception e) {            System.out.println("Failed to execute test: " + t.getClass().getSimpleName());            throw e;        }    }    if (csvFormat == null)        printHeader();    for (Test t : tests) {                t.init();        if (t.isReadTest() && readTests) {            for (int i = 0; i < t.cycles / 2; i++) {                t.readTest();            }        }        if (t.isWriteTest() && writeTests) {            for (int i = 0; i < t.cycles / 2; i++) {                t.writeTest();            }        }                System.gc();        if (t.isReadTest() && readTests) {            tr.reset();            for (int i = 0; i < t.cycles; i++) {                tr.update(t.readTest());            }            printResult(out, csvFormat, tr, t, t.name + "Read");        }        if (t.isWriteTest() && writeTests) {            tr.reset();            for (int i = 0; i < t.cycles; i++) {                tr.update(t.writeTest());            }            printResult(out, csvFormat, tr, t, t.name + "Write");        }        t.reset();    }}
97d2d353f08aa5a1da8b18b0800b6e778df65f48d34726e5f17800df7e0d88e2
reset
public void reset()
{    totalTime = 0L;    minTime = Long.MAX_VALUE;}
e428b216a5736b419f7bccc3c90644a1f1f7826646b6a5ea2a01b929640f652a
update
public long update(long t)
{    totalTime += t;    minTime = Math.min(t, minTime);    return t;}
5b0a57ffe722ff5c3a24526d6c2084c15706c3679194e38962fb047c781b3005
printHeader
private static void printHeader()
{    String header = String.format("%60s     time    M entries/sec   M bytes/sec  bytes/cycle", "test name");    System.out.println(header.toString());}
de1d796d8f577f372c4ed9e59f882d3f13a2e71d665ba708fe6388b8ded1c0d8
printResult
private static void printResult(PrintStream o, boolean[] csv, TestResult tr, Test t, String name)
{    long s = tr.totalTime / 1000;    double entries = (t.cycles * (double) t.count);    double bytes = t.cycles * (double) t.encodedSize;    StringBuilder result = new StringBuilder();    if (csv != null) {        boolean commaneeded = false;        for (int i = 0; i <= MAX_FIELD_TAG; i++) {            if (!csv[i])                continue;            if (commaneeded)                result.append(",");            else                commaneeded = true;            switch(i) {                case NAME_FIELD:                    result.append(name);                    break;                case TIME_FIELD:                    result.append(String.format("%d", (s / 1000)));                    break;                case BYTES_PS_FIELD:                    result.append(String.format("%.3f", (entries / s)));                    break;                case ENTRIES_PS_FIELD:                    result.append(String.format("%.3f", (bytes / s)));                    break;                case BYTES_PC_FIELD:                    result.append(String.format("%d", t.encodedSize));                    break;                case MIN_TIME_FIELD:                    result.append(String.format("%d", tr.minTime));                    break;            }        }    } else {        result.append(String.format("%42s: %6d ms  ", name, (s / 1000)));        result.append(String.format("%10.3f   %11.3f   %11d", (entries / s), (bytes / s), t.encodedSize));    }    o.println(result.toString());}
f565103cef43982eb984339e3ad44efb4ec9c42d45652bf793dd9a4a5f77277e
isWriteTest
 final boolean isWriteTest()
{    return isWriteTest;}
e4f1f497e1156b8333a95874a646e71aea57616c0a67924e9e442d07fe38629f
isReadTest
 final boolean isReadTest()
{    return isReadTest;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return this.getClass().getSimpleName();}
013723fa69cf54455d95c5260db748da8fa528e684b052ad1f422fbbd6fc9913
readTest
public final long readTest() throws IOException
{    Decoder d = getDecoder();    long t = System.nanoTime();    readInternal(d);    return (System.nanoTime() - t);}
7f253961c0372ffd55a7d445493e8fdc3a7e5366398fa7f153582641b2c35e4a
writeTest
public final long writeTest() throws IOException
{    Encoder e = getEncoder();    long t = System.nanoTime();    writeInternal(e);    e.flush();    return (System.nanoTime() - t);}
e1feaab098ea89d7f19af0fa0ca58f97860ebbc07954069434c3f99d7e703f33
getDecoder
protected Decoder getDecoder() throws IOException
{    return newDecoder();}
cbf01a0aff1b35e2c473cf51a833144ba921532429822444572ddcd7334ef820
getEncoder
private Encoder getEncoder() throws IOException
{    return newEncoder(getOutputStream());}
4ceb4585cd5fc86b823aa25564cad5bc782765ed240c103c534daf5cad4601e9
newDecoder
protected Decoder newDecoder()
{    return decoder_factory.binaryDecoder(data, null);}
6d0e089a5948987203abaed6452377e811d8a586e485132121ba7072a061d466
newEncoder
protected Encoder newEncoder(ByteArrayOutputStream out) throws IOException
{    Encoder e = (USE_DIRECT_ENCODER ? encoder_factory.directBinaryEncoder(out, null) : encoder_factory.binaryEncoder(out, null));        return e;}
359e1023d897e9fcf114181c674c334edc33363cc16bca84b6eaa7001fa97905
getOutputStream
private ByteArrayOutputStream getOutputStream()
{    return new ByteArrayOutputStream((int) (encodedSize > 0 ? encodedSize : count));}
fc259524ccbd012f922831b0ebc8388017d3ec5b5915344d1a0e351db2800107
init
 void init() throws IOException
{    genSourceData();    ByteArrayOutputStream baos = getOutputStream();    Encoder e = newEncoder(baos);    writeInternal(e);    e.flush();    data = baos.toByteArray();    encodedSize = data.length;}
b53df483a43e0f9bab6a0f39d506fb6268e87075408ef67bfdbae923b3b7cd7d
genSourceData
 void genSourceData()
{    Random r = newRandom();    sourceData = new int[count];    for (int i = 0; i < sourceData.length; i += 4) {                sourceData[i] = r.nextInt(50);                sourceData[i + 1] = r.nextInt(5000);                sourceData[i + 2] = r.nextInt(500000);                sourceData[i + 3] = r.nextInt(150000000);    }}
34c6a6745e452b98ea32962278b293a245c2939d9704eb9d3cef4b9dd6b51d44
readInternal
 void readInternal(Decoder d) throws IOException
{    for (int i = 0; i < count / 4; i++) {        d.readInt();        d.readInt();        d.readInt();        d.readInt();    }}
b39962fd86bcb8be852f94f33b2787b02be04a22c93b6b43a39e1410cf805a54
writeInternal
 void writeInternal(Encoder e) throws IOException
{    for (int i = 0; i < sourceData.length; i += 4) {        e.writeInt(sourceData[i]);        e.writeInt(sourceData[i + 1]);        e.writeInt(sourceData[i + 2]);        e.writeInt(sourceData[i + 3]);    }}
e81ce61afa6023c409f59e893a8e2992ea2dc468dba82aa6b7b33dc22be7eaff
reset
 void reset()
{    sourceData = null;    data = null;}
34c6a6745e452b98ea32962278b293a245c2939d9704eb9d3cef4b9dd6b51d44
readInternal
 void readInternal(Decoder d) throws IOException
{    for (int i = 0; i < count / 4; i++) {        d.readLong();        d.readLong();        d.readLong();        d.readLong();    }}
b39962fd86bcb8be852f94f33b2787b02be04a22c93b6b43a39e1410cf805a54
writeInternal
 void writeInternal(Encoder e) throws IOException
{    for (int i = 0; i < sourceData.length; i += 4) {        e.writeLong(sourceData[i]);        e.writeLong(sourceData[i + 1]);        e.writeLong(sourceData[i + 2]);        e.writeLong(sourceData[i + 3]);    }}
b53df483a43e0f9bab6a0f39d506fb6268e87075408ef67bfdbae923b3b7cd7d
genSourceData
 void genSourceData()
{    Random r = newRandom();    sourceData = new long[count];    for (int i = 0; i < sourceData.length; i += 4) {                sourceData[i] = r.nextLong() % 0x7FL;                sourceData[i + 1] = r.nextLong() % 0x1FFFFFL;                sourceData[i + 2] = r.nextLong() % 0x3FFFFFFFFL;                sourceData[i + 3] = r.nextLong() % 0x1FFFFFFFFFFFFL;    }        for (int i = sourceData.length - 16; i < sourceData.length; i++) {        sourceData[i] = r.nextLong();    }}
34c6a6745e452b98ea32962278b293a245c2939d9704eb9d3cef4b9dd6b51d44
readInternal
 void readInternal(Decoder d) throws IOException
{    for (int i = 0; i < count / 4; i++) {        d.readLong();        d.readLong();        d.readLong();        d.readLong();    }}
b39962fd86bcb8be852f94f33b2787b02be04a22c93b6b43a39e1410cf805a54
writeInternal
 void writeInternal(Encoder e) throws IOException
{    for (int i = 0; i < sourceData.length; i += 4) {        e.writeLong(sourceData[i]);        e.writeLong(sourceData[i + 1]);        e.writeLong(sourceData[i + 2]);        e.writeLong(sourceData[i + 3]);    }}
e81ce61afa6023c409f59e893a8e2992ea2dc468dba82aa6b7b33dc22be7eaff
reset
 void reset()
{    sourceData = null;    data = null;}
b53df483a43e0f9bab6a0f39d506fb6268e87075408ef67bfdbae923b3b7cd7d
genSourceData
 void genSourceData()
{    Random r = newRandom();    sourceData = new float[count];    for (int i = 0; i < sourceData.length; ) {        sourceData[i++] = r.nextFloat();    }}
34c6a6745e452b98ea32962278b293a245c2939d9704eb9d3cef4b9dd6b51d44
readInternal
 void readInternal(Decoder d) throws IOException
{    for (int i = 0; i < count; i += 4) {        d.readFloat();        d.readFloat();        d.readFloat();        d.readFloat();    }}
b39962fd86bcb8be852f94f33b2787b02be04a22c93b6b43a39e1410cf805a54
writeInternal
 void writeInternal(Encoder e) throws IOException
{    for (int i = 0; i < sourceData.length; i += 4) {        e.writeFloat(sourceData[i]);        e.writeFloat(sourceData[i + 1]);        e.writeFloat(sourceData[i + 2]);        e.writeFloat(sourceData[i + 3]);    }}
e81ce61afa6023c409f59e893a8e2992ea2dc468dba82aa6b7b33dc22be7eaff
reset
 void reset()
{    sourceData = null;    data = null;}
b53df483a43e0f9bab6a0f39d506fb6268e87075408ef67bfdbae923b3b7cd7d
genSourceData
 void genSourceData()
{    Random r = newRandom();    sourceData = new double[count];    for (int i = 0; i < sourceData.length; ) {        sourceData[i++] = r.nextDouble();    }}
34c6a6745e452b98ea32962278b293a245c2939d9704eb9d3cef4b9dd6b51d44
readInternal
 void readInternal(Decoder d) throws IOException
{    for (int i = 0; i < count; i += 4) {        d.readDouble();        d.readDouble();        d.readDouble();        d.readDouble();    }}
b39962fd86bcb8be852f94f33b2787b02be04a22c93b6b43a39e1410cf805a54
writeInternal
 void writeInternal(Encoder e) throws IOException
{    for (int i = 0; i < sourceData.length; i += 4) {        e.writeDouble(sourceData[i]);        e.writeDouble(sourceData[i + 1]);        e.writeDouble(sourceData[i + 2]);        e.writeDouble(sourceData[i + 3]);    }}
e81ce61afa6023c409f59e893a8e2992ea2dc468dba82aa6b7b33dc22be7eaff
reset
 void reset()
{    sourceData = null;    data = null;}
b53df483a43e0f9bab6a0f39d506fb6268e87075408ef67bfdbae923b3b7cd7d
genSourceData
 void genSourceData()
{    Random r = newRandom();    sourceData = new boolean[count];    for (int i = 0; i < sourceData.length; ) {        sourceData[i++] = r.nextBoolean();    }}
34c6a6745e452b98ea32962278b293a245c2939d9704eb9d3cef4b9dd6b51d44
readInternal
 void readInternal(Decoder d) throws IOException
{    for (int i = 0; i < count / 4; i++) {        d.readBoolean();        d.readBoolean();        d.readBoolean();        d.readBoolean();    }}
b39962fd86bcb8be852f94f33b2787b02be04a22c93b6b43a39e1410cf805a54
writeInternal
 void writeInternal(Encoder e) throws IOException
{    for (int i = 0; i < sourceData.length; i += 4) {        e.writeBoolean(sourceData[i]);        e.writeBoolean(sourceData[i + 1]);        e.writeBoolean(sourceData[i + 2]);        e.writeBoolean(sourceData[i + 3]);    }}
e81ce61afa6023c409f59e893a8e2992ea2dc468dba82aa6b7b33dc22be7eaff
reset
 void reset()
{    sourceData = null;    data = null;}
b53df483a43e0f9bab6a0f39d506fb6268e87075408ef67bfdbae923b3b7cd7d
genSourceData
 void genSourceData()
{    Random r = newRandom();    sourceData = new byte[count][];    for (int i = 0; i < sourceData.length; ) {        byte[] data = new byte[r.nextInt(70)];        r.nextBytes(data);        sourceData[i++] = data;    }}
34c6a6745e452b98ea32962278b293a245c2939d9704eb9d3cef4b9dd6b51d44
readInternal
 void readInternal(Decoder d) throws IOException
{    ByteBuffer bb = ByteBuffer.allocate(70);    for (int i = 0; i < count / 4; i++) {        d.readBytes(bb);        d.readBytes(bb);        d.readBytes(bb);        d.readBytes(bb);    }}
b39962fd86bcb8be852f94f33b2787b02be04a22c93b6b43a39e1410cf805a54
writeInternal
 void writeInternal(Encoder e) throws IOException
{    for (int i = 0; i < sourceData.length; i += 4) {        e.writeBytes(sourceData[i]);        e.writeBytes(sourceData[i + 1]);        e.writeBytes(sourceData[i + 2]);        e.writeBytes(sourceData[i + 3]);    }}
e81ce61afa6023c409f59e893a8e2992ea2dc468dba82aa6b7b33dc22be7eaff
reset
 void reset()
{    sourceData = null;    data = null;}
2b5161bc0aa88f89f87046a356c1fdd2782b4275a0cc9af61dc8fff12d5d0f8d
randomString
private static String randomString(Random r)
{    char[] data = new char[r.nextInt(70)];    for (int j = 0; j < data.length; j++) {        data[j] = (char) ('a' + r.nextInt('z' - 'a'));    }    return new String(data);}
b53df483a43e0f9bab6a0f39d506fb6268e87075408ef67bfdbae923b3b7cd7d
genSourceData
 void genSourceData()
{    Random r = newRandom();    sourceData = new String[count];    for (int i = 0; i < sourceData.length; ) sourceData[i++] = randomString(r);}
34c6a6745e452b98ea32962278b293a245c2939d9704eb9d3cef4b9dd6b51d44
readInternal
 void readInternal(Decoder d) throws IOException
{    Utf8 utf = new Utf8();    for (int i = 0; i < count / 4; i++) {        d.readString(utf).toString();        d.readString(utf).toString();        d.readString(utf).toString();        d.readString(utf).toString();    }}
b39962fd86bcb8be852f94f33b2787b02be04a22c93b6b43a39e1410cf805a54
writeInternal
 void writeInternal(Encoder e) throws IOException
{    for (int i = 0; i < sourceData.length; i += 4) {        e.writeString(sourceData[i]);        e.writeString(sourceData[i + 1]);        e.writeString(sourceData[i + 2]);        e.writeString(sourceData[i + 3]);    }}
e81ce61afa6023c409f59e893a8e2992ea2dc468dba82aa6b7b33dc22be7eaff
reset
 void reset()
{    sourceData = null;    data = null;}
34c6a6745e452b98ea32962278b293a245c2939d9704eb9d3cef4b9dd6b51d44
readInternal
 void readInternal(Decoder d) throws IOException
{    d.readArrayStart();    for (long i = d.readArrayStart(); i != 0; i = d.arrayNext()) {        for (long j = 0; j < i; j++) {            d.readFloat();            d.readFloat();            d.readFloat();            d.readFloat();        }    }    d.arrayNext();}
b39962fd86bcb8be852f94f33b2787b02be04a22c93b6b43a39e1410cf805a54
writeInternal
 void writeInternal(Encoder e) throws IOException
{    int items = sourceData.length / 4;    e.writeArrayStart();    e.setItemCount(1);    e.startItem();    e.writeArrayStart();    e.setItemCount(items);    for (int i = 0; i < sourceData.length; i += 4) {        e.startItem();        e.writeFloat(sourceData[i]);        e.writeFloat(sourceData[i + 1]);        e.writeFloat(sourceData[i + 2]);        e.writeFloat(sourceData[i + 3]);    }    e.writeArrayEnd();    e.writeArrayEnd();}
34c6a6745e452b98ea32962278b293a245c2939d9704eb9d3cef4b9dd6b51d44
readInternal
 void readInternal(Decoder d) throws IOException
{    Utf8 key = new Utf8();    for (long i = d.readMapStart(); i != 0; i = d.mapNext()) {        for (long j = 0; j < i; j++) {            key = d.readString(key);            d.readFloat();            d.readFloat();            d.readFloat();            d.readFloat();        }    }}
b39962fd86bcb8be852f94f33b2787b02be04a22c93b6b43a39e1410cf805a54
writeInternal
 void writeInternal(Encoder e) throws IOException
{    int items = sourceData.length / 4;    e.writeMapStart();    e.setItemCount(items);    Utf8 foo = new Utf8("foo");    for (int i = 0; i < sourceData.length; i += 4) {        e.startItem();        e.writeString(foo);        e.writeFloat(sourceData[i]);        e.writeFloat(sourceData[i + 1]);        e.writeFloat(sourceData[i + 2]);        e.writeFloat(sourceData[i + 3]);    }    e.writeMapEnd();}
b53df483a43e0f9bab6a0f39d506fb6268e87075408ef67bfdbae923b3b7cd7d
genSourceData
 void genSourceData()
{    Random r = newRandom();    sourceData = new Rec[count];    for (int i = 0; i < sourceData.length; i++) {        sourceData[i] = new Rec(r);    }}
34c6a6745e452b98ea32962278b293a245c2939d9704eb9d3cef4b9dd6b51d44
readInternal
 void readInternal(Decoder d) throws IOException
{    for (int i = 0; i < count; i++) {        d.readDouble();        d.readDouble();        d.readDouble();        d.readInt();        d.readInt();        d.readInt();    }}
b39962fd86bcb8be852f94f33b2787b02be04a22c93b6b43a39e1410cf805a54
writeInternal
 void writeInternal(Encoder e) throws IOException
{    for (Rec r : sourceData) {        e.writeDouble(r.f1);        e.writeDouble(r.f2);        e.writeDouble(r.f3);        e.writeInt(r.f4);        e.writeInt(r.f5);        e.writeInt(r.f6);    }}
e81ce61afa6023c409f59e893a8e2992ea2dc468dba82aa6b7b33dc22be7eaff
reset
 void reset()
{    sourceData = null;    data = null;}
e1feaab098ea89d7f19af0fa0ca58f97860ebbc07954069434c3f99d7e703f33
getDecoder
protected Decoder getDecoder() throws IOException
{    return new ValidatingDecoder(schema, super.getDecoder());}
6d0e089a5948987203abaed6452377e811d8a586e485132121ba7072a061d466
newEncoder
protected Encoder newEncoder(ByteArrayOutputStream out) throws IOException
{    return encoder_factory.validatingEncoder(schema, super.newEncoder(out));}
e1feaab098ea89d7f19af0fa0ca58f97860ebbc07954069434c3f99d7e703f33
getDecoder
protected Decoder getDecoder() throws IOException
{    return new ResolvingDecoder(schema, schema, super.getDecoder());}
e1feaab098ea89d7f19af0fa0ca58f97860ebbc07954069434c3f99d7e703f33
getDecoder
protected Decoder getDecoder() throws IOException
{    return new ResolvingDecoder(schema, readerSchema, super.getDecoder());}
6328757cce6cb24a77ef81ce70ae375630066eae9c3b015fc22754450a302b16
readInternal
protected void readInternal(Decoder d) throws IOException
{    ResolvingDecoder r = (ResolvingDecoder) d;    Field[] ff = r.readFieldOrder();    for (int i = 0; i < count; i++) {        for (Field f : ff) {            switch(f.pos()) {                case 0:                case 1:                case 2:                    r.readDouble();                    break;                case 3:                case 4:                case 5:                    r.readInt();                    break;                case 6:                case 7:                    r.readString(null);                    break;            }        }    }}
e1feaab098ea89d7f19af0fa0ca58f97860ebbc07954069434c3f99d7e703f33
getDecoder
protected Decoder getDecoder() throws IOException
{    return new ResolvingDecoder(schema, readerSchema, super.getDecoder());}
6328757cce6cb24a77ef81ce70ae375630066eae9c3b015fc22754450a302b16
readInternal
protected void readInternal(Decoder d) throws IOException
{    ResolvingDecoder r = (ResolvingDecoder) d;    Field[] ff = r.readFieldOrder();    for (int i = 0; i < count; i++) {        for (Field f : ff) {            switch(f.pos()) {                case 0:                case 1:                case 3:                    r.readDouble();                    break;                case 2:                case 4:                case 5:                    r.readInt();                    break;            }        }    }}
e1feaab098ea89d7f19af0fa0ca58f97860ebbc07954069434c3f99d7e703f33
getDecoder
protected Decoder getDecoder() throws IOException
{    return new ResolvingDecoder(schema, readerSchema, super.getDecoder());}
6328757cce6cb24a77ef81ce70ae375630066eae9c3b015fc22754450a302b16
readInternal
protected void readInternal(Decoder d) throws IOException
{    ResolvingDecoder r = (ResolvingDecoder) d;    Field[] ff = r.readFieldOrder();    for (int i = 0; i < count; i++) {        for (Field f : ff) {            switch(f.pos()) {                case 0:                case 1:                case 2:                    r.readDouble();                    break;                case 3:                case 4:                case 5:                    r.readLong();                    break;            }        }    }}
61654ddd5b32f50cbe451015a3af70d09848f7ff673f304d7b3163f8d86b0621
getReader
protected GenericDatumReader<Object> getReader()
{    return reader;}
60ec2d878795b52e49472535d052b688e3029296e6f80b33953b0c1090059350
newReader
protected GenericDatumReader<Object> newReader()
{    return new GenericDatumReader<>(schema);}
b53df483a43e0f9bab6a0f39d506fb6268e87075408ef67bfdbae923b3b7cd7d
genSourceData
 void genSourceData()
{    Random r = newRandom();    sourceData = new GenericRecord[count];    for (int i = 0; i < sourceData.length; i++) {        GenericRecord rec = new GenericData.Record(schema);        rec.put(0, r.nextDouble());        rec.put(1, r.nextDouble());        rec.put(2, r.nextDouble());        rec.put(3, r.nextInt());        rec.put(4, r.nextInt());        rec.put(5, r.nextInt());        sourceData[i] = rec;    }}
34c6a6745e452b98ea32962278b293a245c2939d9704eb9d3cef4b9dd6b51d44
readInternal
 void readInternal(Decoder d) throws IOException
{    for (int i = 0; i < count; i++) {        getReader().read(null, d);    }}
b39962fd86bcb8be852f94f33b2787b02be04a22c93b6b43a39e1410cf805a54
writeInternal
 void writeInternal(Encoder e) throws IOException
{    GenericDatumWriter<Object> writer = new GenericDatumWriter<>(schema);    for (GenericRecord rec : sourceData) {        writer.write(rec, e);    }}
e81ce61afa6023c409f59e893a8e2992ea2dc468dba82aa6b7b33dc22be7eaff
reset
 void reset()
{    sourceData = null;    data = null;}
b53df483a43e0f9bab6a0f39d506fb6268e87075408ef67bfdbae923b3b7cd7d
genSourceData
 void genSourceData()
{    Random r = newRandom();    sourceData = new GenericRecord[count];    for (int i = 0; i < sourceData.length; i++) {        GenericRecord rec = new GenericData.Record(schema);        rec.put(0, randomString(r));        rec.put(1, randomString(r));        rec.put(2, randomString(r));        sourceData[i] = rec;    }}
b53df483a43e0f9bab6a0f39d506fb6268e87075408ef67bfdbae923b3b7cd7d
genSourceData
 void genSourceData()
{    sourceData = generateGenericNested(schema, count);}
4a8bee2e24070d60088358a59e88214f65b550cce99a6689ec42ff183e8352f5
generateGenericNested
 static GenericRecord[] generateGenericNested(Schema schema, int count)
{    Random r = newRandom();    GenericRecord[] sourceData = new GenericRecord[count];    Schema doubleSchema = schema.getFields().get(0).schema();    for (int i = 0; i < sourceData.length; i++) {        GenericRecord rec = new GenericData.Record(schema);        GenericRecord inner;        inner = new GenericData.Record(doubleSchema);        inner.put(0, r.nextDouble());        rec.put(0, inner);        inner = new GenericData.Record(doubleSchema);        inner.put(0, r.nextDouble());        rec.put(1, inner);        inner = new GenericData.Record(doubleSchema);        inner.put(0, r.nextDouble());        rec.put(2, inner);        rec.put(3, r.nextInt());        rec.put(4, r.nextInt());        rec.put(5, r.nextInt());        sourceData[i] = rec;    }    return sourceData;}
34c6a6745e452b98ea32962278b293a245c2939d9704eb9d3cef4b9dd6b51d44
readInternal
 void readInternal(Decoder d) throws IOException
{    Schema doubleSchema = schema.getFields().get(0).schema();    for (int i = 0; i < count; i++) {        GenericRecord rec = new GenericData.Record(schema);        GenericRecord inner;        inner = new GenericData.Record(doubleSchema);        inner.put(0, d.readDouble());        rec.put(0, inner);        inner = new GenericData.Record(doubleSchema);        inner.put(0, d.readDouble());        rec.put(1, inner);        inner = new GenericData.Record(doubleSchema);        inner.put(0, d.readDouble());        rec.put(2, inner);        rec.put(3, d.readInt());        rec.put(4, d.readInt());        rec.put(5, d.readInt());    }}
b39962fd86bcb8be852f94f33b2787b02be04a22c93b6b43a39e1410cf805a54
writeInternal
 void writeInternal(Encoder e) throws IOException
{    for (GenericRecord rec : sourceData) {        GenericRecord inner;        inner = (GenericRecord) rec.get(0);        e.writeDouble((Double) inner.get(0));        inner = (GenericRecord) rec.get(1);        e.writeDouble((Double) inner.get(0));        inner = (GenericRecord) rec.get(2);        e.writeDouble((Double) inner.get(0));        e.writeInt((Integer) rec.get(3));        e.writeInt((Integer) rec.get(4));        e.writeInt((Integer) rec.get(5));    }}
b53df483a43e0f9bab6a0f39d506fb6268e87075408ef67bfdbae923b3b7cd7d
genSourceData
 void genSourceData()
{    sourceData = generateGenericNested(schema, count);}
e81ce61afa6023c409f59e893a8e2992ea2dc468dba82aa6b7b33dc22be7eaff
reset
 void reset()
{    data = null;    sourceData = null;}
60ec2d878795b52e49472535d052b688e3029296e6f80b33953b0c1090059350
newReader
protected GenericDatumReader<Object> newReader()
{    return new GenericDatumReader<>(schema, getReaderSchema());}
a9af5e874d404bd6418414b2c19e50f741879945c8970eaa526a83c4e06b18cb
getReaderSchema
protected Schema getReaderSchema()
{    return new Schema.Parser().parse(RECORD_SCHEMA_WITH_DEFAULT);}
a9af5e874d404bd6418414b2c19e50f741879945c8970eaa526a83c4e06b18cb
getReaderSchema
protected Schema getReaderSchema()
{    return new Schema.Parser().parse(RECORD_SCHEMA_WITH_OUT_OF_ORDER);}
a9af5e874d404bd6418414b2c19e50f741879945c8970eaa526a83c4e06b18cb
getReaderSchema
protected Schema getReaderSchema()
{    return new Schema.Parser().parse(RECORD_SCHEMA_WITH_PROMOTION);}
85653516fbbde0d3769731438b822419bdb93559c250acc46771fd68e1d601e4
getDecoder
protected Decoder getDecoder()
{    return newDecoder();}
61654ddd5b32f50cbe451015a3af70d09848f7ff673f304d7b3163f8d86b0621
getReader
protected GenericDatumReader<Object> getReader()
{    return newReader();}
61654ddd5b32f50cbe451015a3af70d09848f7ff673f304d7b3163f8d86b0621
getReader
protected GenericDatumReader<Object> getReader()
{    return newReader();}
85653516fbbde0d3769731438b822419bdb93559c250acc46771fd68e1d601e4
getDecoder
protected Decoder getDecoder()
{    return newDecoder();}
37f145c47c642c5a1ac4764cf3c60067c555bc17c0c7c8e982bdc759bf090e1b
newReader
protected SpecificDatumReader<T> newReader()
{    return new SpecificDatumReader<>(schema);}
db3a253a8f7cba708851134bf3a088c18fe2b1ecd4db2afdd508e4ab59c7a7f0
newWriter
protected SpecificDatumWriter<T> newWriter()
{    return new SpecificDatumWriter<>(schema);}
b53df483a43e0f9bab6a0f39d506fb6268e87075408ef67bfdbae923b3b7cd7d
genSourceData
 void genSourceData()
{    Random r = newRandom();    sourceData = new Object[count];    for (int i = 0; i < sourceData.length; i++) {        sourceData[i] = genSingleRecord(r);    }    reuse = genSingleRecord(r);}
34c6a6745e452b98ea32962278b293a245c2939d9704eb9d3cef4b9dd6b51d44
readInternal
 void readInternal(Decoder d) throws IOException
{    for (int i = 0; i < count; i++) {        reader.read(reuse, d);    }}
b39962fd86bcb8be852f94f33b2787b02be04a22c93b6b43a39e1410cf805a54
writeInternal
 void writeInternal(Encoder e) throws IOException
{    for (Object sourceDatum : sourceData) {        @SuppressWarnings("unchecked")        T rec = (T) sourceDatum;        writer.write(rec, e);    }}
e81ce61afa6023c409f59e893a8e2992ea2dc468dba82aa6b7b33dc22be7eaff
reset
 void reset()
{    sourceData = null;    data = null;}
c567f1a4bf19bed9a44c3249932cc824e48c42190ebffffffe6c6c56b60ee3df
genSingleRecord
protected FooBarSpecificRecord genSingleRecord(Random r)
{    TypeEnum[] typeEnums = TypeEnum.values();    List<Integer> relatedIds = new ArrayList<>(10);    for (int i = 0; i < 10; i++) {        relatedIds.add(r.nextInt());    }    try {        String[] nicknames = { randomString(r), randomString(r) };        return FooBarSpecificRecord.newBuilder().setId(r.nextInt()).setName(randomString(r)).setNicknames(new ArrayList<>(Arrays.asList(nicknames))).setTypeEnum(typeEnums[r.nextInt(typeEnums.length)]).setRelatedids(relatedIds).build();    } catch (Exception e) {        throw new RuntimeException(e);    }}
db9cd369bd4fd484d14a4aebeee2b3e744743d4d7ae838778430aab52a88de7a
genSourceData
protected final void genSourceData()
{    Random r = newRandom();    sourceData = (T[]) Array.newInstance(clazz, count);    for (int i = 0; i < sourceData.length; i++) {        sourceData[i] = createDatum(r);    }}
e3717b33eb5c75053157eb4cee32be7e9d76ebce9141dd6556d3ab743f2fa4b4
readInternal
protected final void readInternal(Decoder d) throws IOException
{    for (int i = 0; i < count; i++) {        reader.read(null, d);    }}
d18d445c7b2592e5383caa82f96488364433483e70beb50bb4e891da041dd691
writeInternal
protected final void writeInternal(Encoder e) throws IOException
{    for (T sourceDatum : sourceData) {        writer.write(sourceDatum, e);    }}
cc216df91b9145d8b64cd941a1545d828b1341b4b873eacbabf7109ab26a4eee
reset
protected final void reset()
{    sourceData = null;    data = null;}
be7a0f9c39176adff9c9a90fd50100a2613e754a1fb662ae6348c4ab9c842936
createDatum
protected Rec createDatum(Random r)
{    return new Rec(r);}
c6f7e514f50b229a46a7f6ed13444f8c60c17a3e27e69cbb91622a02a0e914f2
createDatum
protected float[] createDatum(Random r)
{    return populateFloatArray(r, COUNT / count);}
3befde0a1642d86204c8173b24e511b7d09fd33162e88f1721d1385f8583bf40
createDatum
protected double[] createDatum(Random r)
{    return populateDoubleArray(r, COUNT / count);}
c6f7e514f50b229a46a7f6ed13444f8c60c17a3e27e69cbb91622a02a0e914f2
createDatum
protected float[] createDatum(Random r)
{    return populateFloatArray(r, false);}
3befde0a1642d86204c8173b24e511b7d09fd33162e88f1721d1385f8583bf40
createDatum
protected double[] createDatum(Random r)
{    return populateDoubleArray(r);}
defff99955b50cd7486e7cfdc940d9ed0efcc7cbc7e8030924e61dcbe28c320e
createDatum
protected int[] createDatum(Random r)
{    return populateIntArray(r);}
27dd7c943d80dab311d170f7a83f9c1f1fc36d1ae2d09aead0ce58f94f4ff44f
createDatum
protected long[] createDatum(Random r)
{    return populateLongArray(r);}
d15b0efdc62c5cb538a59ade3bbc220091f899016b56dfbfcea045a281a178c3
createDatum
protected Foo createDatum(Random r)
{    return new Foo(r);}
2ba9c83ba0faab7ff776e0180b3ca59d731c50158860389d7f5a71842d638ea4
smallArraySize
private static int smallArraySize(Random r)
{    return r.nextInt(15) + 1;}
969ea7a03c636886593a26a40a6e4d907a5796f575bfc3f7dc4f001e61ef4ee0
largeArraySize
private static int largeArraySize(Random r)
{    return r.nextInt(97) + 16;}
684abf3d852aaeb3b172cc80c129b3376e1d2fe04a92b96082b3bf5bf5becc90
populateFloatArray
 static float[] populateFloatArray(Random r, boolean large)
{    int size = large ? largeArraySize(r) : smallArraySize(r);    return populateFloatArray(r, size);}
913b6d5031202259c9b376994e7e8eb36331649a337514f4cec45480cf8468d1
populateFloatArray
 static float[] populateFloatArray(Random r, int size)
{    float[] result = new float[size];    for (int i = 0; i < result.length; i++) {        result[i] = r.nextFloat();    }    return result;}
33de8638c9ccce04b34d880656e4494ac63e36c9473d5110006105d6e40f8aba
populateDoubleArray
 static double[] populateDoubleArray(Random r)
{    return populateDoubleArray(r, smallArraySize(r));}
2e2119a75077c54c4b6b2aadff942fcd7cfdbbbe6b7acda6b4219eafe1e6f193
populateDoubleArray
 static double[] populateDoubleArray(Random r, int size)
{    double[] result = new double[size];    for (int i = 0; i < result.length; i++) {        result[i] = r.nextDouble();    }    return result;}
1f848f30cfe403aad2a8fe2c557e12cf62991812b1ba207db7e47d5689d55c68
populateIntArray
 static int[] populateIntArray(Random r)
{    int size = smallArraySize(r);    int[] result = new int[size];    for (int i = 0; i < result.length; i++) {        result[i] = r.nextInt();    }    return result;}
bb177b20f42e5f418bd45a9dda546ec6a3776e3ae6201fd55b068adc766cef6b
populateLongArray
 static long[] populateLongArray(Random r)
{    int size = smallArraySize(r);    long[] result = new long[size];    for (int i = 0; i < result.length; i++) {        result[i] = r.nextLong();    }    return result;}
6e08a2d049718ce0561af62a008b9a47925e3211d34aa1417912c91d4b520106
createDatum
protected FloatFoo createDatum(Random r)
{    return new FloatFoo(r, false);}
6e08a2d049718ce0561af62a008b9a47925e3211d34aa1417912c91d4b520106
createDatum
protected FloatFoo createDatum(Random r)
{    return new FloatFoo(r, true);}
6e08a2d049718ce0561af62a008b9a47925e3211d34aa1417912c91d4b520106
createDatum
protected FloatFoo createDatum(Random r)
{    return new FloatFoo(r, true);}
6d0e089a5948987203abaed6452377e811d8a586e485132121ba7072a061d466
newEncoder
protected Encoder newEncoder(ByteArrayOutputStream out) throws IOException
{    return new EncoderFactory().configureBlockSize(254).blockingBinaryEncoder(out, null);}
d05079e441c3a789b8af874d859acc9e09e4b80c13644ea8e7d32053a7a38ae4
createDatum
protected Rec1 createDatum(Random r)
{    return new Rec1(r);}
ad95260c3a49f7259b71d0569f9761975b03bbd0f159a46f911ab92fd530c317
mkSchema
private static String mkSchema(String subschema)
{    return ("{ \"type\": \"record\", \"name\": \"R\", \"fields\": [\n" + "{ \"name\": \"f\", \"type\": " + subschema + "}\n" + "] }");}
e1feaab098ea89d7f19af0fa0ca58f97860ebbc07954069434c3f99d7e703f33
getDecoder
protected Decoder getDecoder() throws IOException
{    return new ResolvingDecoder(writeSchema, schema, super.getDecoder());}
34c6a6745e452b98ea32962278b293a245c2939d9704eb9d3cef4b9dd6b51d44
readInternal
 void readInternal(Decoder d) throws IOException
{    GenericDatumReader<Object> reader = new GenericDatumReader<>(schema);    for (int i = 0; i < count; i++) {        reader.read(null, d);    }}
b39962fd86bcb8be852f94f33b2787b02be04a22c93b6b43a39e1410cf805a54
writeInternal
 void writeInternal(Encoder e) throws IOException
{    GenericDatumWriter<Object> writer = new GenericDatumWriter<>(writeSchema);    for (GenericRecord sourceDatum : sourceData) {        writer.write(sourceDatum, e);    }}
e81ce61afa6023c409f59e893a8e2992ea2dc468dba82aa6b7b33dc22be7eaff
reset
 void reset()
{    sourceData = null;    data = null;}
b53df483a43e0f9bab6a0f39d506fb6268e87075408ef67bfdbae923b3b7cd7d
genSourceData
 void genSourceData()
{    Random r = newRandom();    Schema eSchema = writeSchema.getField("f").schema();    sourceData = new GenericRecord[count];    for (int i = 0; i < sourceData.length; i++) {        GenericRecord rec = new GenericData.Record(writeSchema);        int tag = r.nextInt(2);        rec.put("f", GenericData.get().createEnum(eSchema.getEnumSymbols().get(tag), eSchema));        sourceData[i] = rec;    }}
b53df483a43e0f9bab6a0f39d506fb6268e87075408ef67bfdbae923b3b7cd7d
genSourceData
 void genSourceData()
{    Random r = newRandom();    Schema uSchema = writeSchema.getField("f").schema();    sourceData = new GenericRecord[count];    for (int i = 0; i < sourceData.length; i++) {        GenericRecord rec = new GenericData.Record(writeSchema);        int val = r.nextInt(1000000);        Integer v = (val < 750000 ? val : null);        rec.put("f", v);        sourceData[i] = rec;    }}
9c7c83d098f06fb2d7b1c70ad0c2a2b5577463423aa556eef30030b15319f3c0
initializeProxy
public static void initializeProxy() throws Exception
{    HttpTransceiver client = new HttpTransceiver(new URL("http://localhost"));    SpecificRequestor requestor = new SpecificRequestor(SampleSpecificProtocol.class, client);    proxy = SpecificRequestor.getClient(SampleSpecificProtocol.class, requestor);}
b2e3a75a7714c7bd8e1edbb13061d9728cc198b1d3900b35b3f14f67cf57374d
testHashCode
public void testHashCode() throws IOException
{    try {        proxy.hashCode();    } catch (AvroRuntimeException e) {        fail(e.getMessage());    }}
ff210197a81bc900e609fe743b32bf51b902c3af9470a330f8ddf7026ee74a4c
testEquals
public void testEquals() throws IOException
{    try {        proxy.equals(proxy);    } catch (AvroRuntimeException e) {        fail(e.getMessage());    }}
063d545859aab585cd2d49dd6da4c9c9cbcafe989b737c593a5791bcb39b718e
testToString
public void testToString() throws IOException
{    try {        proxy.toString();    } catch (AvroRuntimeException e) {        fail(e.getMessage());    }}
313517c88a42e9484c4f16be1ef8a7155c465e375f1737fa18fb1386a4d4b3c4
ticks
public long ticks()
{    return time;}
bed5e50de0bddbf83bfc10a6db407bc40ad1696ff8e7c776a9fd3a03c32387f4
passTime
public void passTime(long nanos)
{    time += nanos;}
11ef520db3f95b5dcb7abd306ae44e78afddf143c7174cc955ecadabfd1fefd0
testBasicOperation
public void testBasicOperation()
{    Segmenter<String, Integer> s = new Histogram.TreeMapSegmenter<>(new TreeSet<>(Arrays.asList(0, 1, 2, 4, 8, 16)));    Histogram<String, Integer> h = new Histogram<>(s);    for (int i = 0; i < 20; ++i) {        h.add(i);    }    assertEquals(20, h.getCount());    assertArrayEquals(new int[] { 1, 1, 2, 4, 8, 4 }, h.getHistogram());    assertEquals("[0,1)=1;[1,2)=1;[2,4)=2;[4,8)=4;[8,16)=8;[16,infinity)=4", h.toString());    String[] correctBucketLabels = { "[0,1)", "[1,2)", "[2,4)", "[4,8)", "[8,16)", "[16,infinity)" };        int pos = 0;    Iterator<String> it = h.getSegmenter().getBuckets();    while (it.hasNext()) {        assertEquals(correctBucketLabels[pos], it.next());        pos = pos + 1;    }    assertEquals(correctBucketLabels.length, pos);    List<String> labels = h.getSegmenter().getBucketLabels();    assertEquals(correctBucketLabels.length, labels.size());    if (labels.size() == correctBucketLabels.length) {        for (int i = 0; i < labels.size(); i++) {            assertEquals(correctBucketLabels[i], labels.get(i));        }    }    String[] correctBoundryLabels = { "0", "1", "2", "4", "8", "16" };    List<String> boundryLabels = h.getSegmenter().getBoundaryLabels();    assertEquals(correctBoundryLabels.length, boundryLabels.size());    if (boundryLabels.size() == correctBoundryLabels.length) {        for (int i = 0; i < boundryLabels.size(); i++) {            assertEquals(correctBoundryLabels[i], boundryLabels.get(i));        }    }    List<Entry<String>> entries = new ArrayList<>();    for (Entry<String> entry : h.entries()) {        entries.add(entry);    }    assertEquals("[0,1)", entries.get(0).bucket);    assertEquals(4, entries.get(5).count);    assertEquals(6, entries.size());    h.add(1010);    h.add(9191);    List<Integer> recent = h.getRecentAdditions();    assertTrue(recent.contains(1010));    assertTrue(recent.contains(9191));}
f6ada02b23e334f18cd4efc770dc2a6b1950fe4848914935f91b1db319a9119d
testBadValue
public void testBadValue()
{    Segmenter<String, Long> s = new Histogram.TreeMapSegmenter<>(new TreeSet<>(Arrays.asList(0L, 1L, 2L, 4L, 8L, 16L)));    Histogram<String, Long> h = new Histogram<>(s);    h.add(-1L);}
30d7d21b201ff0bda84f9d20810108a46d64bc89086085206361ca2e307529ac
getBuckets
public Iterator<String> getBuckets()
{    return Collections.singletonList("X").iterator();}
be76b81d3e880cff8d190d061b853276837e751dd2a7978fbb6ae38be6fe2081
getBoundaryLabels
public List<String> getBoundaryLabels()
{    return Collections.singletonList("X");}
325ca0ba8bb257df6ccec1f0a555a0405096027ab764be0baa9b2816d2058da9
getBucketLabels
public List<String> getBucketLabels()
{    return Collections.singletonList("X");}
c139550ddbdf060f4f8a710003b20d0c430380684888ba3580cc8b795870d92b
segment
public int segment(Float value)
{    return 0;}
72ef1e59027007ffe0950edfd2670ad03bb65cd6463d5d1d282dfeb1750435b0
size
public int size()
{    return 1;}
a62759975cc42a24f09dda35909642bf88a0a207f5094bcfbd0fc9b2075e1573
testFloatHistogram
public void testFloatHistogram()
{    FloatHistogram<String> h = new FloatHistogram<>(new SingleBucketSegmenter());    h.add(12.0f);    h.add(10.0f);    h.add(20.0f);    assertEquals(3, h.getCount());    assertEquals(14.0f, h.getMean(), 0.0001);    assertEquals(5.291f, h.getUnbiasedStdDev(), 0.001);}
729896a5d66c8bfd8bfb919e1d2082ca301ce6c0bf6990548235b7e140248ffa
testNormal
public void testNormal()
{    FakeTicks f = new FakeTicks();    Stopwatch s = new Stopwatch(f);    f.passTime(10);    s.start();    f.passTime(20);    assertEquals(20, s.elapsedNanos());    f.passTime(40);    s.stop();    f.passTime(80);    assertEquals(60, s.elapsedNanos());}
121e343b2533b183cf3bfef7362776dcc8acea4ca73b7ef2668c68ac2b539a69
testNotStarted1
public void testNotStarted1()
{    FakeTicks f = new FakeTicks();    Stopwatch s = new Stopwatch(f);    s.elapsedNanos();}
010f2cc89d9dd02aaff5877a9825d8f2645009aef64226bee81877a97ee38f3a
testNotStarted2
public void testNotStarted2()
{    FakeTicks f = new FakeTicks();    Stopwatch s = new Stopwatch(f);    s.stop();}
639a7ef37be83c6a76f523a3cc3545cd652adbb7b114270974e581bc99b075d3
testTwiceStarted
public void testTwiceStarted()
{    FakeTicks f = new FakeTicks();    Stopwatch s = new Stopwatch(f);    s.start();    s.start();}
e307154f82063f536ea9f30832a340c2260f8b0f31106ae4b38f43602054bbb5
testTwiceStopped
public void testTwiceStopped()
{    FakeTicks f = new FakeTicks();    Stopwatch s = new Stopwatch(f);    s.start();    s.stop();    s.stop();}
b916e24430b1c119a8f623f490027262ebd5aef95e0534415d69b985ab2650be
testSystemStopwatch
public void testSystemStopwatch()
{    Stopwatch s = new Stopwatch(Stopwatch.SYSTEM_TICKS);    s.start();    s.stop();    assertTrue(s.elapsedNanos() >= 0);}
29d68ea2271f298d01258b511c540f1756974c3e264f466c06a5e849f796bce4
respond
public Object respond(Message message, Object request) throws AvroRemoteException
{    assertEquals(new Utf8("hello"), ((GenericRecord) request).get("x"));    return new Utf8("there");}
5b3e7dcde0eee5ce5397c3934997af20519c71e7cafb04e1275471df90c56f28
testSingleRpc
public void testSingleRpc() throws Exception
{    Transceiver t = new LocalTransceiver(new TestResponder(protocol));    GenericRecord params = new GenericData.Record(protocol.getMessages().get("m").getRequest());    params.put("x", new Utf8("hello"));    GenericRequestor r = new GenericRequestor(protocol, t);    for (int x = 0; x < 5; x++) assertEquals(new Utf8("there"), r.request("m", params));}
86672a69924af85607e17bda9b81162a1caa903c12d0f3640afc629342d5cf11
clientStartConnect
public void clientStartConnect(RPCContext context)
{    assertEquals(0, orderCounter.getAndIncrement());}
ea6bdcf9c835c22d11bd66ab2a18e412782107ab4560b183070c75314a39ab4c
clientSendRequest
public void clientSendRequest(RPCContext context)
{    assertEquals(1, orderCounter.getAndIncrement());}
f693dea6d9558ef56d9f642b77c1fc4e9ecd73f48c0ce6e08732a21b4d5894bd
clientReceiveResponse
public void clientReceiveResponse(RPCContext context)
{    assertEquals(6, orderCounter.getAndIncrement());}
35a828a5d4c33136d609d86db7d1115d1dad467cdd93361a18e4c3e160ea2b74
clientFinishConnect
public void clientFinishConnect(RPCContext context)
{    assertEquals(5, orderCounter.getAndIncrement());}
074781ff684c8b35bb8fdf244f06cefb51029229fec7ca609376e62d2f6dd542
serverConnecting
public void serverConnecting(RPCContext context)
{    assertEquals(2, orderCounter.getAndIncrement());}
21ae579f39574168939b76c5f0d979b2fd12fc74b9755beb51bda97afbd24a1d
serverReceiveRequest
public void serverReceiveRequest(RPCContext context)
{    assertEquals(3, orderCounter.getAndIncrement());}
034bcb1b9d0fa94a3160cb15a7f3143a37209f5031c7eda428c29ee5a11bd34b
serverSendResponse
public void serverSendResponse(RPCContext context)
{    assertEquals(4, orderCounter.getAndIncrement());}
77b36f72622ee227e229e6c810bf24450a554cfb293c92a067f0ac9f943ad320
testRpcPluginOrdering
public void testRpcPluginOrdering() throws Exception
{    OrderPlugin plugin = new OrderPlugin();    SpecificResponder responder = new SpecificResponder(Mail.class, new TestMailImpl());    SpecificRequestor requestor = new SpecificRequestor(Mail.class, new LocalTransceiver(responder));    responder.addRPCPlugin(plugin);    requestor.addRPCPlugin(plugin);    Mail client = SpecificRequestor.getClient(Mail.class, requestor);    Message message = createTestMessage();    client.send(message);}
77108fcd035b5c2ed82f20fd558fa8e8c2f5786df1635079147f54167004a507
createTestMessage
private Message createTestMessage()
{    Message message = Message.newBuilder().setTo("me@test.com").setFrom("you@test.com").setBody("plugin testing").build();    return message;}
e7b0f4dd09b8acdf8e45997c4d331159daca34623f03f962953950c4a2e5af40
send
public String send(Message message)
{    return "Received";}
ace0e54253dfb5d86f8d9d33046a3cecd9ebb3a304b6576ef35cb86c7e1c2357
fireandforget
public void fireandforget(Message message)
{}
343dd7475cc0a9e06af2ddc0b430549da23f7c44b2571ea30dd9c1104b8f64f7
testStartServer
public void testStartServer() throws Exception
{    if (server != null)        return;    server = new SaslSocketServer(new TestResponder(), new InetSocketAddress(0));    server.start();    client = new SaslSocketTransceiver(new InetSocketAddress(server.getPort()));    requestor = new GenericRequestor(PROTOCOL, client);}
eeda2339590a5a9e713de7d24e0f72257f9de198caf36fcd3f7dc5331da600d1
testHandshake
public void testHandshake() throws IOException
{}
dd985e83d9f7c5617044275130424fc46c1730caccbcb100e041028175dbf9c5
testResponseChange
public void testResponseChange() throws IOException
{}
bc75676e5e78ce5927e48e79c2fcc9a31ac5cd4b8854d9c47bc7885299c0fc8f
test64kRequest
public void test64kRequest() throws Exception
{    SaslSocketServer s = new SaslSocketServer(new ReflectResponder(ProtoInterface.class, (ProtoInterface) b -> b), new InetSocketAddress(0));    s.start();    SaslSocketTransceiver client = new SaslSocketTransceiver(new InetSocketAddress(s.getPort()));    ProtoInterface proxy = ReflectRequestor.getClient(ProtoInterface.class, client);    byte[] result = proxy.test(new byte[64 * 1024]);    client.close();    s.close();}
ee65ed56bb2938850280a3fa4590de39e193bc3246fc3d9c62eaf82c5e6d9255
handle
public void handle(Callback[] callbacks) throws IOException, UnsupportedCallbackException
{    for (Callback c : callbacks) {        if (c instanceof NameCallback) {            ((NameCallback) c).setName(PRINCIPAL);        } else if (c instanceof PasswordCallback) {            ((PasswordCallback) c).setPassword(PASSWORD.toCharArray());        } else if (c instanceof AuthorizeCallback) {            ((AuthorizeCallback) c).setAuthorized(true);        } else if (c instanceof RealmCallback) {            ((RealmCallback) c).setText(REALM);        } else {            throw new UnsupportedCallbackException(c);        }    }}
343dd7475cc0a9e06af2ddc0b430549da23f7c44b2571ea30dd9c1104b8f64f7
testStartServer
public void testStartServer() throws Exception
{    if (server != null)        return;    server = new SaslSocketServer(new TestResponder(), new InetSocketAddress(0), DIGEST_MD5_MECHANISM, SERVICE, HOST, DIGEST_MD5_PROPS, new TestSaslCallbackHandler());    server.start();    SaslClient saslClient = Sasl.createSaslClient(new String[] { DIGEST_MD5_MECHANISM }, PRINCIPAL, SERVICE, HOST, DIGEST_MD5_PROPS, new TestSaslCallbackHandler());    client = new SaslSocketTransceiver(new InetSocketAddress(server.getPort()), saslClient);    requestor = new GenericRequestor(PROTOCOL, client);}
d6945fc52953512a9743879eabc39436a2f01550a55453adc02e773164dbcbe3
testAnonymousClient
public void testAnonymousClient() throws Exception
{    Server s = new SaslSocketServer(new TestResponder(), new InetSocketAddress(0), DIGEST_MD5_MECHANISM, SERVICE, HOST, DIGEST_MD5_PROPS, new TestSaslCallbackHandler());    s.start();    Transceiver c = new SaslSocketTransceiver(new InetSocketAddress(s.getPort()));    GenericRequestor requestor = new GenericRequestor(PROTOCOL, c);    GenericRecord params = new GenericData.Record(PROTOCOL.getMessages().get("hello").getRequest());    params.put("greeting", "bob");    Utf8 response = (Utf8) requestor.request("hello", params);    assertEquals(new Utf8("goodbye"), response);    s.close();    c.close();}
ee65ed56bb2938850280a3fa4590de39e193bc3246fc3d9c62eaf82c5e6d9255
handle
public void handle(Callback[] callbacks) throws IOException, UnsupportedCallbackException
{    for (Callback c : callbacks) {        if (c instanceof NameCallback) {            ((NameCallback) c).setName(PRINCIPAL);        } else if (c instanceof PasswordCallback) {            ((PasswordCallback) c).setPassword("wrong".toCharArray());        } else if (c instanceof AuthorizeCallback) {            ((AuthorizeCallback) c).setAuthorized(true);        } else if (c instanceof RealmCallback) {            ((RealmCallback) c).setText(REALM);        } else {            throw new UnsupportedCallbackException(c);        }    }}
e58f04a1d0e76c68a3c90397ff279d8ddb1eeebf1f20b4feeb9fdb2d184dae73
testWrongPassword
public void testWrongPassword() throws Exception
{    Server s = new SaslSocketServer(new TestResponder(), new InetSocketAddress(0), DIGEST_MD5_MECHANISM, SERVICE, HOST, DIGEST_MD5_PROPS, new TestSaslCallbackHandler());    s.start();    SaslClient saslClient = Sasl.createSaslClient(new String[] { DIGEST_MD5_MECHANISM }, PRINCIPAL, SERVICE, HOST, DIGEST_MD5_PROPS, new WrongPasswordCallbackHandler());    Transceiver c = new SaslSocketTransceiver(new InetSocketAddress(server.getPort()), saslClient);    GenericRequestor requestor = new GenericRequestor(PROTOCOL, c);    GenericRecord params = new GenericData.Record(PROTOCOL.getMessages().get("hello").getRequest());    params.put("greeting", "bob");    Utf8 response = (Utf8) requestor.request("hello", params);    assertEquals(new Utf8("goodbye"), response);    s.close();    c.close();}
eeda2339590a5a9e713de7d24e0f72257f9de198caf36fcd3f7dc5331da600d1
testHandshake
public void testHandshake() throws IOException
{}
dd985e83d9f7c5617044275130424fc46c1730caccbcb100e041028175dbf9c5
testResponseChange
public void testResponseChange() throws IOException
{}
ff123e49dd193ff9b28ef0afcf4a4d75fe1a84ea3ce53e53024c53940af9aaed
findByFingerprint
public Schema findByFingerprint(long fingerprint)
{    return cache.findByFingerprint(fingerprint);}
b195a34900a22a658d4e7e12a428ca8984b1d44c1c8277108f9515fb565a1ced
testCompatibleReadWithSchemaFromSchemaStore
public void testCompatibleReadWithSchemaFromSchemaStore() throws Exception
{        NestedEvolve2.Builder rootBuilder = NestedEvolve2.newBuilder().setRootName("RootName");    rootBuilder.setNested(TestRecord2.newBuilder().setName("Name").setValue(1).setData("Data").build());    ByteBuffer nestedEvolve2Buffer = rootBuilder.build().toByteBuffer();        NestedEvolve1 nestedEvolve1 = decoder.decode(nestedEvolve2Buffer);        assertEquals(nestedEvolve1.getRootName(), "RootName");    assertEquals(nestedEvolve1.getNested().getName(), "Name");    assertEquals(nestedEvolve1.getNested().getValue(), 1);}
1eaac025a5d429cb1127f88dde4b1fbbdb3d3071558a517a4045e5692a96ce8e
testIncompatibleReadWithSchemaFromSchemaStore
public void testIncompatibleReadWithSchemaFromSchemaStore() throws Exception
{        NestedEvolve3.Builder rootBuilder = NestedEvolve3.newBuilder().setRootName("RootName");    rootBuilder.setNested(TestRecord3.newBuilder().setName("Name").setData("Data").build());    ByteBuffer nestedEvolve3Buffer = rootBuilder.build().toByteBuffer();            decoder.decode(nestedEvolve3Buffer);}
86672a69924af85607e17bda9b81162a1caa903c12d0f3640afc629342d5cf11
clientStartConnect
public void clientStartConnect(RPCContext context)
{    ByteBuffer buf = ByteBuffer.wrap("ap".getBytes(StandardCharsets.UTF_8));    context.requestHandshakeMeta().put(key, buf);}
074781ff684c8b35bb8fdf244f06cefb51029229fec7ca609376e62d2f6dd542
serverConnecting
public void serverConnecting(RPCContext context)
{    Assert.assertNotNull(context.requestHandshakeMeta());    Assert.assertNotNull(context.responseHandshakeMeta());    Assert.assertNull(context.getRequestPayload());    Assert.assertNull(context.getResponsePayload());    if (!context.requestHandshakeMeta().containsKey(key))        return;    ByteBuffer buf = context.requestHandshakeMeta().get(key);    Assert.assertNotNull(buf);    Assert.assertNotNull(buf.array());    String partialstr = new String(buf.array(), StandardCharsets.UTF_8);    Assert.assertNotNull(partialstr);    Assert.assertEquals("partial string mismatch", "ap", partialstr);    buf = ByteBuffer.wrap((partialstr + "ac").getBytes(StandardCharsets.UTF_8));    Assert.assertTrue(buf.remaining() > 0);    context.responseHandshakeMeta().put(key, buf);}
35a828a5d4c33136d609d86db7d1115d1dad467cdd93361a18e4c3e160ea2b74
clientFinishConnect
public void clientFinishConnect(RPCContext context)
{    Map<String, ByteBuffer> handshakeMeta = context.responseHandshakeMeta();    Assert.assertNull(context.getRequestPayload());    Assert.assertNull(context.getResponsePayload());    Assert.assertNotNull(handshakeMeta);    if (!handshakeMeta.containsKey(key))        return;    ByteBuffer buf = handshakeMeta.get(key);    Assert.assertNotNull(buf);    Assert.assertNotNull(buf.array());    String partialstr = new String(buf.array(), StandardCharsets.UTF_8);    Assert.assertNotNull(partialstr);    Assert.assertEquals("partial string mismatch", "apac", partialstr);    buf = ByteBuffer.wrap((partialstr + "he").getBytes(StandardCharsets.UTF_8));    Assert.assertTrue(buf.remaining() > 0);    handshakeMeta.put(key, buf);    checkRPCMetaMap(handshakeMeta);}
ea6bdcf9c835c22d11bd66ab2a18e412782107ab4560b183070c75314a39ab4c
clientSendRequest
public void clientSendRequest(RPCContext context)
{    ByteBuffer buf = ByteBuffer.wrap("ap".getBytes(StandardCharsets.UTF_8));    context.requestCallMeta().put(key, buf);    Assert.assertNotNull(context.getMessage());    Assert.assertNotNull(context.getRequestPayload());    Assert.assertNull(context.getResponsePayload());}
21ae579f39574168939b76c5f0d979b2fd12fc74b9755beb51bda97afbd24a1d
serverReceiveRequest
public void serverReceiveRequest(RPCContext context)
{    Map<String, ByteBuffer> meta = context.requestCallMeta();    Assert.assertNotNull(meta);    Assert.assertNotNull(context.getMessage());    Assert.assertNull(context.getResponsePayload());    if (!meta.containsKey(key))        return;    ByteBuffer buf = meta.get(key);    Assert.assertNotNull(buf);    Assert.assertNotNull(buf.array());    String partialstr = new String(buf.array(), StandardCharsets.UTF_8);    Assert.assertNotNull(partialstr);    Assert.assertEquals("partial string mismatch", "ap", partialstr);    buf = ByteBuffer.wrap((partialstr + "a").getBytes(StandardCharsets.UTF_8));    Assert.assertTrue(buf.remaining() > 0);    meta.put(key, buf);}
034bcb1b9d0fa94a3160cb15a7f3143a37209f5031c7eda428c29ee5a11bd34b
serverSendResponse
public void serverSendResponse(RPCContext context)
{    Assert.assertNotNull(context.requestCallMeta());    Assert.assertNotNull(context.responseCallMeta());    Assert.assertNotNull(context.getResponsePayload());    if (!context.requestCallMeta().containsKey(key))        return;    ByteBuffer buf = context.requestCallMeta().get(key);    Assert.assertNotNull(buf);    Assert.assertNotNull(buf.array());    String partialstr = new String(buf.array(), StandardCharsets.UTF_8);    Assert.assertNotNull(partialstr);    Assert.assertEquals("partial string mismatch", "apa", partialstr);    buf = ByteBuffer.wrap((partialstr + "c").getBytes(StandardCharsets.UTF_8));    Assert.assertTrue(buf.remaining() > 0);    context.responseCallMeta().put(key, buf);}
f693dea6d9558ef56d9f642b77c1fc4e9ecd73f48c0ce6e08732a21b4d5894bd
clientReceiveResponse
public void clientReceiveResponse(RPCContext context)
{    Assert.assertNotNull(context.responseCallMeta());    Assert.assertNotNull(context.getRequestPayload());    if (!context.responseCallMeta().containsKey(key))        return;    ByteBuffer buf = context.responseCallMeta().get(key);    Assert.assertNotNull(buf);    Assert.assertNotNull(buf.array());    String partialstr = new String(buf.array(), StandardCharsets.UTF_8);    Assert.assertNotNull(partialstr);    Assert.assertEquals("partial string mismatch", "apac", partialstr);    buf = ByteBuffer.wrap((partialstr + "he").getBytes(StandardCharsets.UTF_8));    Assert.assertTrue(buf.remaining() > 0);    context.responseCallMeta().put(key, buf);    checkRPCMetaMap(context.responseCallMeta());}
467058907795e55dbb569963e7b7d899fe57690846796bed70f6671738f85dc4
checkRPCMetaMap
protected void checkRPCMetaMap(Map<String, ByteBuffer> rpcMeta)
{    Assert.assertNotNull(rpcMeta);    Assert.assertTrue("key not present in map", rpcMeta.containsKey(key));    ByteBuffer keybuf = rpcMeta.get(key);    Assert.assertNotNull(keybuf);    Assert.assertTrue("key BB had nothing remaining", keybuf.remaining() > 0);    String str = new String(keybuf.array(), StandardCharsets.UTF_8);    Assert.assertEquals("apache", str);}
24c8ba349d5605cf85c5f3536956ddec90098f169bea3ee7b52d838dcee66423
createPartialBuilder
private Request.Builder createPartialBuilder()
{    Request.Builder requestBuilder = Request.newBuilder();    requestBuilder.setTimestamp(1234567890);    requestBuilder.getConnectionBuilder().setNetworkType(NetworkType.IPv4);    requestBuilder.getHttpRequestBuilder().getUserAgentBuilder().setUseragent("Chrome 123").setId("Foo");    requestBuilder.getHttpRequestBuilder().getURIBuilder().setMethod(HttpMethod.GET).setPath("/index.html");    if (!requestBuilder.getHttpRequestBuilder().getURIBuilder().hasParameters()) {        requestBuilder.getHttpRequestBuilder().getURIBuilder().setParameters(new ArrayList<>());    }    requestBuilder.getHttpRequestBuilder().getURIBuilder().getParameters().add(QueryParameter.newBuilder().setName("Foo").setValue("Bar").build());    return requestBuilder;}
16e8d8f85b164ca9fc24c7aa601c64f18fecfa5575f62914e67ce409f20246fd
failOnIncompleteTree
public void failOnIncompleteTree()
{    try {        createPartialBuilder().build();    } catch (AvroMissingFieldException amfe) {        assertEquals("Field networkAddress type:STRING pos:1 not set and has no default value", amfe.getMessage());        assertEquals("Path in schema: --> connection --> networkAddress", amfe.toString());        throw amfe;    }    fail("Should NEVER get here");}
03b608145ea33153b90bdcb4e75553aa71afdec2a1be54a24f04be301c26ea3a
copyBuilder
public void copyBuilder()
{    Request.Builder requestBuilder1 = createPartialBuilder();    Request.Builder requestBuilder2 = Request.newBuilder(requestBuilder1);    requestBuilder1.getConnectionBuilder().setNetworkAddress("1.1.1.1");    requestBuilder2.getConnectionBuilder().setNetworkAddress("2.2.2.2");    requestBuilder2.getHttpRequestBuilder().getUserAgentBuilder().setId("Bar");    Request request1 = requestBuilder1.build();    Request request2 = requestBuilder2.build();    assertEquals(NetworkType.IPv4, request1.getConnection().getNetworkType());    assertEquals("1.1.1.1", request1.getConnection().getNetworkAddress());    assertEquals("Chrome 123", request1.getHttpRequest().getUserAgent().getUseragent());    assertEquals("Foo", request1.getHttpRequest().getUserAgent().getId());    assertEquals(HttpMethod.GET, request1.getHttpRequest().getURI().getMethod());    assertEquals("/index.html", request1.getHttpRequest().getURI().getPath());    assertEquals(1, request1.getHttpRequest().getURI().getParameters().size());    assertEquals("Foo", request1.getHttpRequest().getURI().getParameters().get(0).getName());    assertEquals("Bar", request1.getHttpRequest().getURI().getParameters().get(0).getValue());    assertEquals(NetworkType.IPv4, request2.getConnection().getNetworkType());    assertEquals("2.2.2.2", request2.getConnection().getNetworkAddress());    assertEquals("Chrome 123", request2.getHttpRequest().getUserAgent().getUseragent());    assertEquals("Bar", request2.getHttpRequest().getUserAgent().getId());    assertEquals(HttpMethod.GET, request2.getHttpRequest().getURI().getMethod());    assertEquals("/index.html", request2.getHttpRequest().getURI().getPath());    assertEquals(1, request2.getHttpRequest().getURI().getParameters().size());    assertEquals("Foo", request2.getHttpRequest().getURI().getParameters().get(0).getName());    assertEquals("Bar", request2.getHttpRequest().getURI().getParameters().get(0).getValue());}
3cc6937a5cce0ddfc0f0429ea301d6533fb6d7df52822a9744185ec2458df09c
createBuilderFromInstance
public void createBuilderFromInstance()
{    Request.Builder requestBuilder1 = createPartialBuilder();    requestBuilder1.getConnectionBuilder().setNetworkAddress("1.1.1.1");    Request request1 = requestBuilder1.build();    Request.Builder requestBuilder2 = Request.newBuilder(request1);    requestBuilder2.getConnectionBuilder().setNetworkAddress("2.2.2.2");    requestBuilder2.getHttpRequestBuilder().getUserAgentBuilder().setId("Bar");    requestBuilder2.getHttpRequestBuilder().getURIBuilder().setMethod(HttpMethod.POST);    requestBuilder2.getHttpRequestBuilder().getUserAgentBuilder().setUseragent("Firefox 456");    Request request2 = requestBuilder2.build();    assertEquals(NetworkType.IPv4, request1.getConnection().getNetworkType());    assertEquals("1.1.1.1", request1.getConnection().getNetworkAddress());    assertEquals("Chrome 123", request1.getHttpRequest().getUserAgent().getUseragent());    assertEquals("Foo", request1.getHttpRequest().getUserAgent().getId());    assertEquals(HttpMethod.GET, request1.getHttpRequest().getURI().getMethod());    assertEquals("/index.html", request1.getHttpRequest().getURI().getPath());    assertEquals(1, request1.getHttpRequest().getURI().getParameters().size());    assertEquals("Foo", request1.getHttpRequest().getURI().getParameters().get(0).getName());    assertEquals("Bar", request1.getHttpRequest().getURI().getParameters().get(0).getValue());    assertEquals(NetworkType.IPv4, request2.getConnection().getNetworkType());    assertEquals("2.2.2.2", request2.getConnection().getNetworkAddress());    assertEquals("Firefox 456", request2.getHttpRequest().getUserAgent().getUseragent());    assertEquals("Bar", request2.getHttpRequest().getUserAgent().getId());    assertEquals(HttpMethod.POST, request2.getHttpRequest().getURI().getMethod());    assertEquals("/index.html", request2.getHttpRequest().getURI().getPath());    assertEquals(1, request2.getHttpRequest().getURI().getParameters().size());    assertEquals("Foo", request2.getHttpRequest().getURI().getParameters().get(0).getName());    assertEquals("Bar", request2.getHttpRequest().getURI().getParameters().get(0).getValue());}
f45ab67bacbae949787046017abca7c7d7a8b8536acb5c4f6f2a6fa3eb72993b
createLastOneTestsBuilder
private Request.Builder createLastOneTestsBuilder()
{    Request.Builder requestBuilder = Request.newBuilder();    requestBuilder.setTimestamp(1234567890);    requestBuilder.getConnectionBuilder().setNetworkType(NetworkType.IPv4).setNetworkAddress("1.1.1.1");    return requestBuilder;}
6b5a33c6e1ea766021c3c4ea183d9708b5729a5f0e8c6630d72a186da283151d
lastOneWins_Setter
public void lastOneWins_Setter()
{    Request.Builder requestBuilder = createLastOneTestsBuilder();    requestBuilder.getHttpRequestBuilder().getURIBuilder().setMethod(HttpMethod.GET).setPath("/index.html");    requestBuilder.getHttpRequestBuilder().getUserAgentBuilder().setUseragent("Chrome 123").setId("Foo");    HttpRequest httpRequest = HttpRequest.newBuilder().setUserAgent(new UserAgent("Bar", "Firefox 321")).setURI(HttpURI.newBuilder().setMethod(HttpMethod.POST).setPath("/login.php").build()).build();    Request request = requestBuilder.setHttpRequest(httpRequest).build();    assertEquals(NetworkType.IPv4, request.getConnection().getNetworkType());    assertEquals("1.1.1.1", request.getConnection().getNetworkAddress());    assertEquals(0, request.getHttpRequest().getURI().getParameters().size());    assertEquals("Firefox 321", request.getHttpRequest().getUserAgent().getUseragent());    assertEquals("Bar", request.getHttpRequest().getUserAgent().getId());    assertEquals(HttpMethod.POST, request.getHttpRequest().getURI().getMethod());    assertEquals("/login.php", request.getHttpRequest().getURI().getPath());}
6d63c35cbbe6bd6ffa2865e2af65261f35b2bac38b560ac4670bf373c04c873e
lastOneWins_Builder
public void lastOneWins_Builder()
{    Request.Builder requestBuilder = createLastOneTestsBuilder();    HttpRequest httpRequest = HttpRequest.newBuilder().setUserAgent(new UserAgent("Bar", "Firefox 321")).setURI(HttpURI.newBuilder().setMethod(HttpMethod.POST).setPath("/login.php").build()).build();    requestBuilder.setHttpRequest(httpRequest);    requestBuilder.getHttpRequestBuilder().getURIBuilder().setMethod(HttpMethod.GET).setPath("/index.html");    requestBuilder.getHttpRequestBuilder().getUserAgentBuilder().setUseragent("Chrome 123").setId("Foo");    Request request = requestBuilder.build();    assertEquals(NetworkType.IPv4, request.getConnection().getNetworkType());    assertEquals("1.1.1.1", request.getConnection().getNetworkAddress());    assertEquals("Chrome 123", request.getHttpRequest().getUserAgent().getUseragent());    assertEquals("Foo", request.getHttpRequest().getUserAgent().getId());    assertEquals(0, request.getHttpRequest().getURI().getParameters().size());    assertEquals(HttpMethod.GET, request.getHttpRequest().getURI().getMethod());    assertEquals("/index.html", request.getHttpRequest().getURI().getPath());}
b187e2a611365cc2a6a0d5b19de0b948b4aa347728cad61e046a75289dd9a637
copyBuilderWithNullables
public void copyBuilderWithNullables()
{    RecordWithNullables.Builder builder = RecordWithNullables.newBuilder();    assertFalse(builder.hasNullableRecordBuilder());    assertFalse(builder.hasNullableRecord());    assertFalse(builder.hasNullableString());    assertFalse(builder.hasNullableLong());    assertFalse(builder.hasNullableInt());    assertFalse(builder.hasNullableMap());    assertFalse(builder.hasNullableArray());    RecordWithNullables.Builder builderCopy = RecordWithNullables.newBuilder(builder);    assertFalse(builderCopy.hasNullableRecordBuilder());    assertFalse(builderCopy.hasNullableRecord());    assertFalse(builderCopy.hasNullableString());    assertFalse(builderCopy.hasNullableLong());    assertFalse(builderCopy.hasNullableInt());    assertFalse(builderCopy.hasNullableMap());    assertFalse(builderCopy.hasNullableArray());    builderCopy.getNullableRecordBuilder();}
7c0d7cdc29a7b9816e673255fcb53edf7f8310b0d01f869e48d85dd5e8684e22
copyBuilderWithNullablesAndSetToNull
public void copyBuilderWithNullablesAndSetToNull()
{        RecordWithNullables.Builder builder = RecordWithNullables.newBuilder();        assertFalse(builder.hasNullableRecordBuilder());    assertFalse(builder.hasNullableRecord());    assertFalse(builder.hasNullableString());    assertFalse(builder.hasNullableLong());    assertFalse(builder.hasNullableInt());    assertFalse(builder.hasNullableMap());    assertFalse(builder.hasNullableArray());        builder.setNullableRecordBuilder(null);    builder.setNullableRecord(null);    builder.setNullableString(null);    builder.setNullableLong(null);    builder.setNullableInt(null);    builder.setNullableMap(null);    builder.setNullableArray(null);        assertFalse(builder.hasNullableRecordBuilder());        assertTrue(builder.hasNullableRecord());    assertTrue(builder.hasNullableString());    assertTrue(builder.hasNullableLong());    assertTrue(builder.hasNullableInt());    assertTrue(builder.hasNullableMap());    assertTrue(builder.hasNullableArray());        builder.getNullableRecordBuilder();    assertTrue(builder.hasNullableRecordBuilder());    assertFalse(builder.hasNullableRecord());        RecordWithNullables.Builder builderCopy = RecordWithNullables.newBuilder(builder);        assertTrue(builder.hasNullableRecordBuilder());    assertFalse(builder.hasNullableRecord());    assertTrue(builder.hasNullableString());    assertTrue(builder.hasNullableLong());    assertTrue(builder.hasNullableInt());    assertTrue(builder.hasNullableMap());    assertTrue(builder.hasNullableArray());}
aeb5b139e73a1b1123245b286bbb0ac284d4eb377cb04a4b1fd112dd973603b5
getBuilderForRecordWithNullRecord
public void getBuilderForRecordWithNullRecord()
{        RecordWithNullables recordWithNullables = RecordWithNullables.newBuilder().build();        RecordWithNullables.Builder builder = RecordWithNullables.newBuilder(recordWithNullables);        builder.getNullableRecordBuilder();}
2c77514f3a026e2e6029d269f0ce98348d7d26d59d671d49adf04c017de0a5af
getBuilderForNullRecord
public void getBuilderForNullRecord()
{        RecordWithNullables.newBuilder((RecordWithNullables) null);}
63953518617d9790989dfea00deb6bf9efc53187e4ee510ef4e02842f199e07a
getBuilderForNullBuilder
public void getBuilderForNullBuilder()
{        RecordWithNullables.newBuilder((RecordWithNullables.Builder) null);}
aaacfcb2dd4ed1bcaa5b4ba65d97fdd42330815e1ad49c6bacaa9cf64fd84b4c
validateBrowsingOptionals
public void validateBrowsingOptionals()
{    Request.Builder requestBuilder = Request.newBuilder();    requestBuilder.setTimestamp(1234567890);    requestBuilder.getHttpRequestBuilder().getUserAgentBuilder().setUseragent("Chrome 123");    requestBuilder.getHttpRequestBuilder().getURIBuilder().setMethod(HttpMethod.GET).setPath("/index.html");    Request request = requestBuilder.build();    assertEquals("Chrome 123", Optional.of(request).flatMap(Request::getOptionalHttpRequest).flatMap(HttpRequest::getOptionalUserAgent).flatMap(UserAgent::getOptionalUseragent).orElse("UNKNOWN"));    assertFalse(Optional.of(request).flatMap(Request::getOptionalHttpRequest).flatMap(HttpRequest::getOptionalUserAgent).flatMap(UserAgent::getOptionalId).isPresent());    assertEquals(HttpMethod.GET, Optional.of(request).flatMap(Request::getOptionalHttpRequest).flatMap(HttpRequest::getOptionalURI).flatMap(HttpURI::getOptionalMethod).orElse(null));    assertEquals("/index.html", Optional.of(request).flatMap(Request::getOptionalHttpRequest).flatMap(HttpRequest::getOptionalURI).flatMap(HttpURI::getOptionalPath).orElse(null));}
ad6f12d30164517b5d8852c2595ff6dcc9e828122d198b1d26eaebfe2762e22e
testHashCode
public void testHashCode()
{    new TestRecord().hashCode();    SpecificData.get().hashCode(null, TestRecord.SCHEMA$);}
cd89046fb8911fa4a6595be8ff9a8156398ebfad5d0c95e20ca6a68135c4b5d2
testToString
public void testToString()
{    new TestRecord().toString();}
156dbf6ef69cb4f18a53f5b5838945d6ae2356e55eda8601614ed4bd6d5382f5
testGetMapSchema
public void testGetMapSchema() throws Exception
{    SpecificData.get().getSchema(X.class.getField("map").getGenericType());}
8c4c0499f82db40d58da9171765886e3b510088ca60ed94b57e0f2ce88659e36
testSpecificWithinGeneric
public void testSpecificWithinGeneric() throws Exception
{        Schema schema = Schema.createRecord("Foo", "", "x.y.z", false);    List<Schema.Field> fields = new ArrayList<>();    fields.add(new Schema.Field("f", TestRecord.SCHEMA$, "", null));    schema.setFields(fields);        TestRecord nested = new TestRecord();    nested.setName("foo");    nested.setKind(Kind.BAR);    nested.setHash(new MD5(new byte[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5 }));    GenericData.Record record = new GenericData.Record(schema);    record.put("f", nested);        TestSchema.checkBinary(schema, record, new SpecificDatumWriter<>(), new SpecificDatumReader<>());    TestSchema.checkDirectBinary(schema, record, new SpecificDatumWriter<>(), new SpecificDatumReader<>());    TestSchema.checkBlockingBinary(schema, record, new SpecificDatumWriter<>(), new SpecificDatumReader<>());}
cd6f7c6490285a4484d0a9414938b9385c69e7dafa5c7d74c7e903ebec4bcb32
testConvertGenericToSpecific
public void testConvertGenericToSpecific()
{    GenericRecord generic = new GenericData.Record(TestRecord.SCHEMA$);    generic.put("name", "foo");    generic.put("kind", new GenericData.EnumSymbol(Kind.SCHEMA$, "BAR"));    generic.put("hash", new GenericData.Fixed(MD5.SCHEMA$, new byte[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5 }));    TestRecord specific = (TestRecord) SpecificData.get().deepCopy(TestRecord.SCHEMA$, generic);}
dd822154e384b9fd8618ec936b2c5f7bfe260fcc7f3f021b37ab81bccafb5c31
testGetClassSchema
public void testGetClassSchema() throws Exception
{    Assert.assertEquals(TestRecord.getClassSchema(), TestRecord.SCHEMA$);    Assert.assertEquals(MD5.getClassSchema(), MD5.SCHEMA$);    Assert.assertEquals(Kind.getClassSchema(), Kind.SCHEMA$);}
2ff9d7f51dd09cfb6a9530b16a15d29fc8669554953d53174d2dfcd496241d09
testSpecificRecordToString
public void testSpecificRecordToString() throws IOException
{    FooBarSpecificRecord foo = FooBarSpecificRecord.newBuilder().setId(123).setName("foo").setNicknames(Collections.singletonList("bar")).setRelatedids(Arrays.asList(1, 2, 3)).setTypeEnum(TypeEnum.c).build();    String json = foo.toString();    JsonFactory factory = new JsonFactory();    JsonParser parser = factory.createParser(json);    ObjectMapper mapper = new ObjectMapper();        mapper.readTree(parser);}
be5d247f84109f4838d7902701a9d142b52ae94facc72e4ac928d1b2a9e15ebc
testExternalizeable
public void testExternalizeable() throws Exception
{    TestRecord before = new TestRecord();    before.setName("foo");    before.setKind(Kind.BAR);    before.setHash(new MD5(new byte[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5 }));    ByteArrayOutputStream bytes = new ByteArrayOutputStream();    ObjectOutputStream out = new ObjectOutputStream(bytes);    out.writeObject(before);    out.close();    ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(bytes.toByteArray()));    TestRecord after = (TestRecord) in.readObject();    Assert.assertEquals(before, after);}
f5edf8b3c181ac996fa783cba98fb7765e10cb64ded4dbb72ba4e5c309eaab4d
testReservedEnumSymbol
public void testReservedEnumSymbol() throws Exception
{    Assert.assertEquals(Reserved.default$, SpecificData.get().createEnum("default", Reserved.SCHEMA$));}
e8b8b2186cdcf44eb2d968349d2d591adefd65fc1ad2584d0ebcf1af3253fb28
serializeRecord
public static byte[] serializeRecord(FooBarSpecificRecord fooBarSpecificRecord) throws IOException
{    SpecificDatumWriter<FooBarSpecificRecord> datumWriter = new SpecificDatumWriter<>(FooBarSpecificRecord.SCHEMA$);    ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();    Encoder encoder = EncoderFactory.get().binaryEncoder(byteArrayOutputStream, null);    datumWriter.write(fooBarSpecificRecord, encoder);    encoder.flush();    return byteArrayOutputStream.toByteArray();}
cb93c6cb91b673d28d0e02b05c54624dd0bdcaf8698560c288453f0ab60eb4e1
serializeRecord
public static byte[] serializeRecord(StringablesRecord stringablesRecord) throws IOException
{    SpecificDatumWriter<StringablesRecord> datumWriter = new SpecificDatumWriter<>(StringablesRecord.SCHEMA$);    ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();    Encoder encoder = EncoderFactory.get().binaryEncoder(byteArrayOutputStream, null);    datumWriter.write(stringablesRecord, encoder);    encoder.flush();    return byteArrayOutputStream.toByteArray();}
767dbe978d8c4fc5b320d7c3421d54216c421ab70b70c93a7c0410ee0757a269
testRead
public void testRead() throws IOException
{    Builder newBuilder = FooBarSpecificRecord.newBuilder();    newBuilder.setId(42);    newBuilder.setName("foo");    newBuilder.setNicknames(Collections.singletonList("bar"));    newBuilder.setRelatedids(Arrays.asList(1, 2, 3));    FooBarSpecificRecord specificRecord = newBuilder.build();    byte[] recordBytes = serializeRecord(specificRecord);    Decoder decoder = DecoderFactory.get().binaryDecoder(recordBytes, null);    SpecificDatumReader<FooBarSpecificRecord> specificDatumReader = new SpecificDatumReader<>(FooBarSpecificRecord.SCHEMA$);    FooBarSpecificRecord deserialized = new FooBarSpecificRecord();    specificDatumReader.read(deserialized, decoder);    assertEquals(specificRecord, deserialized);}
a642f68ce7a9882d56b03c1530bc520bb6b8937747c2f36a8e8d36142c90bf6c
testStringables
public void testStringables() throws IOException
{    StringablesRecord.Builder newBuilder = StringablesRecord.newBuilder();    newBuilder.setValue(new BigDecimal("42.11"));    HashMap<String, BigDecimal> mapWithBigDecimalElements = new HashMap<>();    mapWithBigDecimalElements.put("test", new BigDecimal("11.11"));    newBuilder.setMapWithBigDecimalElements(mapWithBigDecimalElements);    HashMap<BigInteger, String> mapWithBigIntKeys = new HashMap<>();    mapWithBigIntKeys.put(BigInteger.ONE, "test");    newBuilder.setMapWithBigIntKeys(mapWithBigIntKeys);    StringablesRecord stringablesRecord = newBuilder.build();    byte[] recordBytes = serializeRecord(stringablesRecord);    Decoder decoder = DecoderFactory.get().binaryDecoder(recordBytes, null);    SpecificDatumReader<StringablesRecord> specificDatumReader = new SpecificDatumReader<>(StringablesRecord.SCHEMA$);    StringablesRecord deserialized = new StringablesRecord();    specificDatumReader.read(deserialized, decoder);    assertEquals(stringablesRecord, deserialized);}
c8c4c4bc914accf9cc59922b47c445e76e60bb22cf653f1ab7180e113dd83063
testResolveUnion
public void testResolveUnion() throws IOException
{    final SpecificDatumWriter<TestRecordWithUnion> writer = new SpecificDatumWriter<>();    Schema schema = TestRecordWithUnion.SCHEMA$;    ByteArrayOutputStream out = new ByteArrayOutputStream();    JsonEncoder encoder = EncoderFactory.get().jsonEncoder(schema, out);    writer.setSchema(schema);    TestRecordWithUnion c = TestRecordWithUnion.newBuilder().setKind(Kind.BAR).setValue("rab").build();    writer.write(c, encoder);    encoder.flush();    out.close();    String expectedJson = String.format("{'kind':{'org.apache.avro.test.Kind':'%s'},'value':{'string':'%s'}}", c.getKind().toString(), c.getValue()).replace('\'', '"');    assertEquals(expectedJson, out.toString("UTF-8"));}
68d3c6efa9a7e81459385f8fee9245bf8c4c6fea9b3e75a7460670b2d7741fea
testSpecificErrorBuilder
public void testSpecificErrorBuilder()
{    TestError.Builder testErrorBuilder = TestError.newBuilder().setValue("value").setCause(new NullPointerException()).setMessage$("message$");        Assert.assertTrue(testErrorBuilder.hasValue());    Assert.assertNotNull(testErrorBuilder.getValue());    Assert.assertTrue(testErrorBuilder.hasCause());    Assert.assertNotNull(testErrorBuilder.getCause());    Assert.assertTrue(testErrorBuilder.hasMessage$());    Assert.assertNotNull(testErrorBuilder.getMessage$());    TestError testError = testErrorBuilder.build();    Assert.assertEquals("value", testError.getValue());    Assert.assertEquals("value", testError.getMessage());    Assert.assertEquals("message$", testError.getMessage$());        Assert.assertEquals(testErrorBuilder, TestError.newBuilder(testErrorBuilder));    Assert.assertEquals(testErrorBuilder, TestError.newBuilder(testError));    TestError error = new TestError("value", new NullPointerException());    error.setMessage$("message");    Assert.assertEquals(error, TestError.newBuilder().setValue("value").setCause(new NullPointerException()).setMessage$("message").build());        testErrorBuilder.clearValue();    Assert.assertFalse(testErrorBuilder.hasValue());    Assert.assertNull(testErrorBuilder.getValue());    testErrorBuilder.clearCause();    Assert.assertFalse(testErrorBuilder.hasCause());    Assert.assertNull(testErrorBuilder.getCause());    testErrorBuilder.clearMessage$();    Assert.assertFalse(testErrorBuilder.hasMessage$());    Assert.assertNull(testErrorBuilder.getMessage$());}
ed0682c387eaec05aa8a5bb81e7a12793e1aca4faeee372e329464a70731b29b
attemptToSetNonNullableFieldToNull
public void attemptToSetNonNullableFieldToNull()
{    TestError.newBuilder().setMessage$(null);}
7177deac45382746c798c25ec20ba893e8c10b2c828bb8f6a9b90c4ad40db276
testSpecificBuilder
public void testSpecificBuilder()
{        Person.Builder builder = Person.newBuilder().setName("James Gosling").setYearOfBirth(1955).setState("CA");    Assert.assertTrue(builder.hasName());    Assert.assertEquals("James Gosling", builder.getName());    Assert.assertTrue(builder.hasYearOfBirth());    Assert.assertEquals(1955, builder.getYearOfBirth());    Assert.assertFalse(builder.hasCountry());    Assert.assertNull(builder.getCountry());    Assert.assertTrue(builder.hasState());    Assert.assertEquals("CA", builder.getState());    Assert.assertFalse(builder.hasFriends());    Assert.assertNull(builder.getFriends());    Assert.assertFalse(builder.hasLanguages());    Assert.assertNull(builder.getLanguages());    Person person = builder.build();    Assert.assertEquals("James Gosling", person.getName());    Assert.assertEquals(1955, person.getYearOfBirth());        Assert.assertEquals("US", person.getCountry());    Assert.assertEquals("CA", person.getState());        Assert.assertNotNull(person.getFriends());    Assert.assertEquals(0, person.getFriends().size());        Assert.assertNotNull(person.getLanguages());    Assert.assertEquals(2, person.getLanguages().size());    Assert.assertEquals("English", person.getLanguages().get(0));    Assert.assertEquals("Java", person.getLanguages().get(1));        Assert.assertEquals(builder, Person.newBuilder(builder));    Assert.assertEquals(person, Person.newBuilder(person).build());    Person.Builder builderCopy = Person.newBuilder(person);    Assert.assertEquals("James Gosling", builderCopy.getName());    Assert.assertEquals(1955, builderCopy.getYearOfBirth());        Assert.assertEquals("US", builderCopy.getCountry());    Assert.assertEquals("CA", builderCopy.getState());        Assert.assertNotNull(builderCopy.getFriends());    Assert.assertEquals(0, builderCopy.getFriends().size());        builderCopy.clearFriends().clearCountry();    Assert.assertFalse(builderCopy.hasFriends());    Assert.assertFalse(builderCopy.hasCountry());    Assert.assertNull(builderCopy.getFriends());    Assert.assertNull(builderCopy.getCountry());    Person person2 = builderCopy.build();    Assert.assertNotNull(person2.getFriends());    Assert.assertTrue(person2.getFriends().isEmpty());}
03408c502291bbb22870f0e23b7fb915e7f754f56e5f7bde1bf0660ed8d3add3
testUnions
public void testUnions()
{    long datetime = 1234L;    String product = "widget";    PageView p = PageView.newBuilder().setDatetime(1234L).setPageContext(ProductPage.newBuilder().setProduct(product).build()).build();    Assert.assertEquals(datetime, p.getDatetime());    Assert.assertEquals(ProductPage.class, p.getPageContext().getClass());    Assert.assertEquals(product, ((ProductPage) p.getPageContext()).getProduct());    PageView p2 = PageView.newBuilder(p).build();    Assert.assertEquals(datetime, p2.getDatetime());    Assert.assertEquals(ProductPage.class, p2.getPageContext().getClass());    Assert.assertEquals(product, ((ProductPage) p2.getPageContext()).getProduct());    Assert.assertEquals(p, p2);}
3ba7794015520e67c60566f2f0e7acadb8e8abc9ea1b45f84de59057af2e0af1
testInterop
public void testInterop()
{    Interop interop = Interop.newBuilder().setNullField(null).setArrayField(Arrays.asList(3.14159265, 6.022)).setBoolField(true).setBytesField(ByteBuffer.allocate(4).put(new byte[] { 3, 2, 1, 0 })).setDoubleField(1.41421).setEnumField(Kind.C).setFixedField(new MD5(new byte[] { 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3 })).setFloatField(1.61803f).setIntField(64).setLongField(1024).setMapField(Collections.singletonMap("Foo1", new Foo())).setRecordField(new Node()).setStringField("MyInterop").setUnionField(2.71828).build();    Interop copy = Interop.newBuilder(interop).build();    Assert.assertEquals(interop.getArrayField().size(), copy.getArrayField().size());    Assert.assertEquals(interop.getArrayField(), copy.getArrayField());    Assert.assertEquals(interop.getBoolField(), copy.getBoolField());    Assert.assertEquals(interop.getBytesField(), copy.getBytesField());    Assert.assertEquals(interop.getDoubleField(), copy.getDoubleField(), 0.001);    Assert.assertEquals(interop.getEnumField(), copy.getEnumField());    Assert.assertEquals(interop.getFixedField(), copy.getFixedField());    Assert.assertEquals(interop.getFloatField(), copy.getFloatField(), 0.001);    Assert.assertEquals(interop.getIntField(), copy.getIntField());    Assert.assertEquals(interop.getLongField(), copy.getLongField());    Assert.assertEquals(interop.getMapField(), copy.getMapField());    Assert.assertEquals(interop.getRecordField(), copy.getRecordField());    Assert.assertEquals(interop.getStringField(), copy.getStringField());    Assert.assertEquals(interop.getUnionField(), copy.getUnionField());    Assert.assertEquals(interop, copy);}
ed0682c387eaec05aa8a5bb81e7a12793e1aca4faeee372e329464a70731b29b
attemptToSetNonNullableFieldToNull
public void attemptToSetNonNullableFieldToNull()
{    Person.newBuilder().setName(null);}
dd4ccb789ab17bbb505c5299de279807183d91777351cce848c98417fb8bd309
buildWithoutSettingRequiredFields1
public void buildWithoutSettingRequiredFields1()
{    Person.newBuilder().build();}
e6a80493b8b0eff98b004dbfb2c1a8bf6fe810f521adc4433afe35dae892c612
buildWithoutSettingRequiredFields2
public void buildWithoutSettingRequiredFields2()
{        try {        Person.newBuilder().setYearOfBirth(1900).setState("MA").build();        Assert.fail("Should have thrown " + AvroRuntimeException.class.getCanonicalName());    } catch (AvroRuntimeException e) {                Assert.assertTrue(e.getMessage().contains("name"));    }}
a4bf7643c86fd680c25684340a38faac59b22278189b451ebba8f12918495145
buildWithoutSettingRequiredFields3
public void buildWithoutSettingRequiredFields3()
{        try {        Person.newBuilder().setName("Anon").setState("CA").build();        Assert.fail("Should have thrown " + AvroRuntimeException.class.getCanonicalName());    } catch (AvroRuntimeException e) {                Assert.assertTrue(e.getMessage().contains("year_of_birth"));    }}
7f499f9127d0c0add862db48bda46c3f948e66bdaf4c8dfdb1c7e9d78dd54dea
testBuilderPerformance
public void testBuilderPerformance()
{    int count = 1000000;    List<Person> friends = new ArrayList<>(0);    List<String> languages = new ArrayList<>(Arrays.asList("English", "Java"));    long startTimeNanos = System.nanoTime();    for (int ii = 0; ii < count; ii++) {        Person.newBuilder().setName("James Gosling").setYearOfBirth(1955).setCountry("US").setState("CA").setFriends(friends).setLanguages(languages).build();    }    long durationNanos = System.nanoTime() - startTimeNanos;    double durationMillis = durationNanos / 1e6d;    System.out.println("Built " + count + " records in " + durationMillis + "ms (" + (count / (durationMillis / 1000d)) + " records/sec, " + (durationMillis / count) + "ms/record");}
de74e8e3682fd913360c1840519bd33b2dd54665bf9933841a8f3774a2ea0eef
testBuilderPerformanceWithDefaultValues
public void testBuilderPerformanceWithDefaultValues()
{    int count = 1000000;    long startTimeNanos = System.nanoTime();    for (int ii = 0; ii < count; ii++) {        Person.newBuilder().setName("James Gosling").setYearOfBirth(1955).setState("CA").build();    }    long durationNanos = System.nanoTime() - startTimeNanos;    double durationMillis = durationNanos / 1e6d;    System.out.println("Built " + count + " records in " + durationMillis + "ms (" + (count / (durationMillis / 1000d)) + " records/sec, " + (durationMillis / count) + "ms/record");}
836ba5b217abe9b83575e5dea05e84b2d2e5d6d00352812eaf734be45082a195
testManualBuildPerformance
public void testManualBuildPerformance()
{    int count = 1000000;    List<Person> friends = new ArrayList<>(0);    List<String> languages = new ArrayList<>(Arrays.asList("English", "Java"));    long startTimeNanos = System.nanoTime();    for (int ii = 0; ii < count; ii++) {        Person person = new Person();        person.name = "James Gosling";        person.year_of_birth = 1955;        person.state = "CA";        person.country = "US";        person.friends = friends;        person.languages = languages;    }    long durationNanos = System.nanoTime() - startTimeNanos;    double durationMillis = durationNanos / 1e6d;    System.out.println("Built " + count + " records in " + durationMillis + "ms (" + (count / (durationMillis / 1000d)) + " records/sec, " + (durationMillis / count) + "ms/record");}
54ab17508299828a7087f00ae2e6fc6d917df30ed0bfccb16fa6bfd3fe681052
testNull
public void testNull() throws Exception
{    Schema schema = new Schema.Parser().parse("\"null\"");    byte[] b = render(null, schema, new GenericDatumWriter<>());    assertEquals(0, BinaryData.compare(b, 0, b, 0, schema));}
1c4ead9765938332059d76104de2519bbd7b9057fd53ed73120e527efd881e7a
testBoolean
public void testBoolean() throws Exception
{    check("\"boolean\"", Boolean.FALSE, Boolean.TRUE);}
47091a22b52c1ea805d7739df5201a4e7327af110691372a168e229d498ce84a
testString
public void testString() throws Exception
{    check("\"string\"", new Utf8(""), new Utf8("a"));    check("\"string\"", new Utf8("a"), new Utf8("b"));    check("\"string\"", new Utf8("a"), new Utf8("ab"));    check("\"string\"", new Utf8("ab"), new Utf8("b"));}
a4e6b9f25ced9157a314ef8ee378dda6c12353478243004ff437e919eacbc247
testBytes
public void testBytes() throws Exception
{    check("\"bytes\"", ByteBuffer.wrap(new byte[] {}), ByteBuffer.wrap(new byte[] { 1 }));    check("\"bytes\"", ByteBuffer.wrap(new byte[] { 1 }), ByteBuffer.wrap(new byte[] { 2 }));    check("\"bytes\"", ByteBuffer.wrap(new byte[] { 1, 2 }), ByteBuffer.wrap(new byte[] { 2 }));}
7d308bd607294c47e283d31de15a82aeaaad961e02fc7aca32909747cfcabcad
testInt
public void testInt() throws Exception
{    check("\"int\"", -1, 0);    check("\"int\"", 0, 1);}
610de3ad7cc1d54bdbc9a4fe9c41e2c012a37ae58dac4466b22979a25e1b08e7
testLong
public void testLong() throws Exception
{    check("\"long\"", 11L, 12L);    check("\"long\"", (long) -1, 1L);}
b7f222c157daee3f00a40a6f98b21c2806a0bfbf7a58e847930af5420b976276
testFloat
public void testFloat() throws Exception
{    check("\"float\"", 1.1f, 1.2f);    check("\"float\"", (float) -1.1, 1.0f);}
d1cc0c0b6a548d4db9fe52df21cce3b0c12faae6479bc1660611b03839fdb710
testDouble
public void testDouble() throws Exception
{    check("\"double\"", 1.2, 1.3);    check("\"double\"", -1.2, 1.3);}
7749ea47bc1c162d12a2c024fc5b3f5a5ed16bb6c8cb8dfaf741cc6e5cc57239
testArray
public void testArray() throws Exception
{    String json = "{\"type\":\"array\", \"items\": \"long\"}";    Schema schema = new Schema.Parser().parse(json);    GenericArray<Long> a1 = new GenericData.Array<>(1, schema);    a1.add(1L);    GenericArray<Long> a2 = new GenericData.Array<>(1, schema);    a2.add(1L);    a2.add(0L);    check(json, a1, a2);}
bc60056fba07c84186113a44978125e27ff567860e028682a7e6e98bb36c39eb
testRecord
public void testRecord() throws Exception
{    String fields = " \"fields\":[" + "{\"name\":\"f\",\"type\":\"int\",\"order\":\"ignore\"}," + "{\"name\":\"g\",\"type\":\"int\",\"order\":\"descending\"}," + "{\"name\":\"h\",\"type\":\"int\"}]}";    String recordJson = "{\"type\":\"record\", \"name\":\"Test\"," + fields;    Schema schema = new Schema.Parser().parse(recordJson);    GenericData.Record r1 = new GenericData.Record(schema);    r1.put("f", 1);    r1.put("g", 13);    r1.put("h", 41);    GenericData.Record r2 = new GenericData.Record(schema);    r2.put("f", 0);    r2.put("g", 12);    r2.put("h", 41);    check(recordJson, r1, r2);    r2.put("f", 0);    r2.put("g", 13);    r2.put("h", 42);    check(recordJson, r1, r2);    String record2Json = "{\"type\":\"record\", \"name\":\"Test2\"," + fields;    Schema schema2 = new Schema.Parser().parse(record2Json);    GenericData.Record r3 = new GenericData.Record(schema2);    r3.put("f", 1);    r3.put("g", 13);    r3.put("h", 41);        assert (!r1.equals(r3));}
3776f415ff726e12f4d27d6f94a41798d7873f7ae8f7190bf152d378efc74b28
testEnum
public void testEnum() throws Exception
{    String json = "{\"type\":\"enum\", \"name\":\"Test\",\"symbols\": [\"A\", \"B\"]}";    Schema schema = new Schema.Parser().parse(json);    check(json, new GenericData.EnumSymbol(schema, "A"), new GenericData.EnumSymbol(schema, "B"));}
21b7e6e86390c7d6c8c8decf9248b88719cb745ebf6b49e78c010e39e520c041
testFixed
public void testFixed() throws Exception
{    String json = "{\"type\": \"fixed\", \"name\":\"Test\", \"size\": 1}";    Schema schema = new Schema.Parser().parse(json);    check(json, new GenericData.Fixed(schema, new byte[] { (byte) 'a' }), new GenericData.Fixed(schema, new byte[] { (byte) 'b' }));}
885adce170ee8976432efbf14891fef8562a01c79e29888906018818c2983c1a
testUnion
public void testUnion() throws Exception
{    check("[\"string\", \"long\"]", new Utf8("a"), new Utf8("b"), false);    check("[\"string\", \"long\"]", 1L, 2L, false);    check("[\"string\", \"long\"]", new Utf8("a"), 1L, false);}
55206163fda9156129092150b04a0896401598be3800f9f727f41e360ab9a3f6
testSpecificRecord
public void testSpecificRecord() throws Exception
{    TestRecord s1 = new TestRecord();    TestRecord s2 = new TestRecord();    s1.setName("foo");    s1.setKind(Kind.BAZ);    s1.setHash(new MD5(new byte[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5 }));    s2.setName("bar");    s2.setKind(Kind.BAR);    s2.setHash(new MD5(new byte[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 6 }));    Schema schema = SpecificData.get().getSchema(TestRecord.class);    check(schema, s1, s2, true, new SpecificDatumWriter<>(schema), SpecificData.get());    s2.setKind(Kind.BAZ);    check(schema, s1, s2, true, new SpecificDatumWriter<>(schema), SpecificData.get());}
6f93bdb757d115059cb0dbbf9780974d510b808b04255e88987b39a64b926f0c
check
private static void check(String schemaJson, T o1, T o2) throws Exception
{    check(schemaJson, o1, o2, true);}
52a55fd79638ef840af881839869bb5ad85740dc0dd016cee6647e6862d37e15
check
private static void check(String schemaJson, T o1, T o2, boolean comparable) throws Exception
{    check(new Schema.Parser().parse(schemaJson), o1, o2, comparable, new GenericDatumWriter<>(), GenericData.get());}
61f6bcd89d70a9c691722104c5a0ba237f4837f4adb3dcc7ad753d90b686b681
check
private static void check(Schema schema, T o1, T o2, boolean comparable, DatumWriter<T> writer, GenericData comparator) throws Exception
{    byte[] b1 = render(o1, schema, writer);    byte[] b2 = render(o2, schema, writer);    assertEquals(-1, BinaryData.compare(b1, 0, b2, 0, schema));    assertEquals(1, BinaryData.compare(b2, 0, b1, 0, schema));    assertEquals(0, BinaryData.compare(b1, 0, b1, 0, schema));    assertEquals(0, BinaryData.compare(b2, 0, b2, 0, schema));    assertEquals(-1, compare(o1, o2, schema, comparable, comparator));    assertEquals(1, compare(o2, o1, schema, comparable, comparator));    assertEquals(0, compare(o1, o1, schema, comparable, comparator));    assertEquals(0, compare(o2, o2, schema, comparable, comparator));    assert (o1.equals(o1));    assert (o2.equals(o2));    assert (!o1.equals(o2));    assert (!o2.equals(o1));    assert (!o1.equals(new Object()));    assert (!o2.equals(new Object()));    assert (!o1.equals(null));    assert (!o2.equals(null));    assert (o1.hashCode() != o2.hashCode());        if (schema.getType() != Schema.Type.ENUM) {        assertEquals(o1.hashCode(), BinaryData.hashCode(b1, 0, b1.length, schema));        assertEquals(o2.hashCode(), BinaryData.hashCode(b2, 0, b2.length, schema));    }        assertEquals(comparator.hashCode(o1, schema), BinaryData.hashCode(b1, 0, b1.length, schema));    assertEquals(comparator.hashCode(o2, schema), BinaryData.hashCode(b2, 0, b2.length, schema));}
ade5bfcbe7d05f85610e5934df12373ada491031dbd4b88d1a6e4a35ba95b163
compare
private static int compare(Object o1, Object o2, Schema schema, boolean comparable, GenericData comparator)
{    return comparable ? ((Comparable<Object>) o1).compareTo(o2) : comparator.compare(o1, o2, schema);}
8815e8a479b903ff5644307e1d97a2085e20a79e98396f58eeed89bf5d6601ec
render
private static byte[] render(T datum, Schema schema, DatumWriter<T> writer) throws IOException
{    ByteArrayOutputStream out = new ByteArrayOutputStream();    writer.setSchema(schema);    Encoder enc = new EncoderFactory().directBinaryEncoder(out, null);    writer.write(datum, enc);    enc.flush();    return out.toByteArray();}
6ec4f97576f3961583252a124a0eb08d1d74a3a280ef07ec54073d4954f65ddf
testSpecificDatumReaderDefaultCtor
public void testSpecificDatumReaderDefaultCtor() throws IOException
{    File file = new File(DIR.getRoot().getPath(), "testSpecificDatumReaderDefaultCtor");        Schema s1 = new Schema.Parser().parse("{\"type\":\"record\",\"name\":\"Foo\"," + "\"namespace\":\"org.apache.avro\",\"fields\":[" + "{\"name\":\"label\",\"type\":\"string\"}," + "{\"name\":\"id\",\"type\":\"int\"}]}");        try (DataFileWriter<Record> writer = new DataFileWriter<>(new GenericDatumWriter<Record>(s1)).create(s1, file)) {        for (int i = 0; i < 10; i++) {            Record r = new Record(s1);            r.put("label", "" + i);            r.put("id", i);            writer.append(r);        }    }        try (DataFileReader<Foo> reader = new DataFileReader<>(file, new SpecificDatumReader<>())) {        int i = 0;        for (Foo f : reader) {            Assert.assertEquals("" + (i++), f.getLabel());        }        Assert.assertEquals(10, i);    }}
343dd7475cc0a9e06af2ddc0b430549da23f7c44b2571ea30dd9c1104b8f64f7
testStartServer
public void testStartServer() throws Exception
{    if (server != null)        return;    server = new SocketServer(new ReflectResponder(TestNamespace.class, new TestImpl()), new InetSocketAddress(0));    server.start();    client = new SocketTransceiver(new InetSocketAddress(server.getPort()));    proxy = ReflectRequestor.getClient(TestNamespace.class, client);}
767eaba11e63cf2e86776ef6e0be715d65225118dbf3a9d7787a13c5ab8fc405
echo
public TestRecord echo(TestRecord record)
{    return record;}
26100e3e2a24aa3c3355cc9bad6d49cc2c801ee035658567f5a783f9d7f7fea8
error
public void error() throws TestError
{    throw TestError.newBuilder().setMessage$("an error").build();}
343dd7475cc0a9e06af2ddc0b430549da23f7c44b2571ea30dd9c1104b8f64f7
testStartServer
public void testStartServer() throws Exception
{    if (server != null)        return;    server = new SocketServer(new SpecificResponder(TestNamespace.class, new TestImpl()), new InetSocketAddress(0));    server.start();    client = new SocketTransceiver(new InetSocketAddress(server.getPort()));    proxy = SpecificRequestor.getClient(TestNamespace.class, client);}
e70809ca532ff0845bcba016a10b52320b72044e5a2e9689e0ade2dbe3169dd7
testEcho
public void testEcho() throws IOException
{    TestRecord record = new TestRecord();    record.setHash(new MD5(new byte[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5 }));    TestRecord echoed = proxy.echo(record);    assertEquals(record, echoed);    assertEquals(record.hashCode(), echoed.hashCode());}
3e93c1fb120879875fc82ed77fb354e91166c1c2a1cb5e2c4cb49dfdc9c53d5a
testError
public void testError() throws IOException
{    TestError error = null;    try {        proxy.error();    } catch (TestError e) {        error = e;    }    assertNotNull(error);    assertEquals("an error", error.getMessage$());}
4128984afffe9c943bdc7e9272b1a5ce978c0e5978a753e7299b25f568c6c016
testStopServer
public static void testStopServer() throws IOException
{    client.close();    server.close();}
d2c969c3d001f4cb8ee4faf386f2b39208dd1de1af42947372b3ba149b948da2
createServer
public Server createServer(Responder testResponder) throws Exception
{    return new DatagramServer(new SpecificResponder(Simple.class, new TestImpl()), new InetSocketAddress("localhost", new Random().nextInt(10000) + 10000));}
b723b1ec8e0ad25b5fa0c50c217e5a3f9380f12f0fa602f368cec8d7c19fdad2
createTransceiver
public Transceiver createTransceiver() throws Exception
{    return new DatagramTransceiver(new InetSocketAddress("localhost", server.getPort()));}
38f6f275e4665b7bc5553d8f196e583a98d4b5bc53049915ab8fab55edcd57e7
getExpectedHandshakeCount
protected int getExpectedHandshakeCount()
{    return 0;}
29d68ea2271f298d01258b511c540f1756974c3e264f466c06a5e849f796bce4
respond
public Object respond(Message message, Object request) throws AvroRemoteException
{    GenericRecord params = (GenericRecord) request;    if ("hello".equals(message.getName())) {        LOG.info("hello: " + params.get("greeting"));        return new Utf8("goodbye");    }    if ("echo".equals(message.getName())) {        Object record = params.get("record");        LOG.info("echo: " + record);        return record;    }    if ("echoBytes".equals(message.getName())) {        Object data = params.get("data");        LOG.info("echoBytes: " + data);        return data;    }    if ("error".equals(message.getName())) {        if (throwUndeclaredError)            throw new RuntimeException("foo");        GenericRecord error = new GenericData.Record(PROTOCOL.getType("TestError"));        error.put("message", new Utf8("an error"));        throw new AvroRemoteException(error);    }    throw new AvroRuntimeException("unexpected message: " + message.getName());}
343dd7475cc0a9e06af2ddc0b430549da23f7c44b2571ea30dd9c1104b8f64f7
testStartServer
public void testStartServer() throws Exception
{    if (server != null)        return;    server = new SocketServer(new TestResponder(), new InetSocketAddress(0));    server.start();    client = new SocketTransceiver(new InetSocketAddress(server.getPort()));    requestor = new GenericRequestor(PROTOCOL, client);}
6f605d02064a36c4ddb22872055eaba688b64fbc5a3490d5913c9ea59025b380
testHello
public void testHello() throws Exception
{    GenericRecord params = new GenericData.Record(PROTOCOL.getMessages().get("hello").getRequest());    params.put("greeting", new Utf8("bob"));    Utf8 response = (Utf8) requestor.request("hello", params);    assertEquals(new Utf8("goodbye"), response);}
e530274c5036675893121be1afbb475d0ed0702f8090b516ddfee68b4db1a49d
testEcho
public void testEcho() throws Exception
{    GenericRecord record = new GenericData.Record(PROTOCOL.getType("TestRecord"));    record.put("name", new Utf8("foo"));    record.put("kind", new GenericData.EnumSymbol(PROTOCOL.getType("Kind"), "BAR"));    record.put("hash", new GenericData.Fixed(PROTOCOL.getType("MD5"), new byte[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5 }));    GenericRecord params = new GenericData.Record(PROTOCOL.getMessages().get("echo").getRequest());    params.put("record", record);    Object echoed = requestor.request("echo", params);    assertEquals(record, echoed);}
4b0635e92b5a15be59da927cbfdbc309aa8841095c4bf013496754dd7c714fc0
testEchoBytes
public void testEchoBytes() throws Exception
{    Random random = new Random();    int length = random.nextInt(1024 * 16);    GenericRecord params = new GenericData.Record(PROTOCOL.getMessages().get("echoBytes").getRequest());    ByteBuffer data = ByteBuffer.allocate(length);    random.nextBytes(data.array());    data.flip();    params.put("data", data);    Object echoed = requestor.request("echoBytes", params);    assertEquals(data, echoed);}
efff5c7c8ff559172f6b752e68370b28bcc16ba0162834827c3752bbecd71505
testError
public void testError() throws Exception
{    GenericRecord params = new GenericData.Record(PROTOCOL.getMessages().get("error").getRequest());    AvroRemoteException error = null;    try {        requestor.request("error", params);    } catch (AvroRemoteException e) {        error = e;    }    assertNotNull(error);    assertEquals("an error", ((GenericRecord) error.getValue()).get("message").toString());}
a1fc56e2b6d18de77311527dc7eaa364451cd0f1f10c2c618d3fb090af6cfc11
testUndeclaredError
public void testUndeclaredError() throws Exception
{    this.throwUndeclaredError = true;    RuntimeException error = null;    GenericRecord params = new GenericData.Record(PROTOCOL.getMessages().get("error").getRequest());    try {        requestor.request("error", params);    } catch (RuntimeException e) {        error = e;    } finally {        this.throwUndeclaredError = false;    }    assertNotNull(error);    assertTrue(error.toString().contains("foo"));}
48e902d2a0bd0e2f57dd34f612f149054f5fd70858824b3cf26cc60d2ed8bf3d
testHandshake
public void testHandshake() throws Exception
{    Protocol protocol = new Protocol("Simple", "org.apache.avro.test");    List<Field> fields = new ArrayList<>();    fields.add(new Schema.Field("extra", Schema.create(Schema.Type.BOOLEAN), null, null));    fields.add(new Schema.Field("greeting", Schema.create(Schema.Type.STRING), null, null));    Protocol.Message message = protocol.createMessage("hello", null, /* doc */    new LinkedHashMap<String, String>(), Schema.createRecord(fields), Schema.create(Schema.Type.STRING), Schema.createUnion(new ArrayList<>()));    protocol.getMessages().put("hello", message);    try (Transceiver t = new SocketTransceiver(new InetSocketAddress(server.getPort()))) {        GenericRequestor r = new GenericRequestor(protocol, t);        GenericRecord params = new GenericData.Record(message.getRequest());        params.put("extra", Boolean.TRUE);        params.put("greeting", new Utf8("bob"));        Utf8 response = (Utf8) r.request("hello", params);        assertEquals(new Utf8("goodbye"), response);    }}
2cf47b250c5d6c4083da5fc7fc46163a0699f9b2bae49bb875658b8026f590d2
testResponseChange
public void testResponseChange() throws Exception
{    List<Field> fields = new ArrayList<>();    for (Field f : PROTOCOL.getType("TestRecord").getFields()) fields.add(new Field(f.name(), f.schema(), null, null));    fields.add(new Field("extra", Schema.create(Schema.Type.BOOLEAN), null, true));    Schema record = Schema.createRecord("TestRecord", null, "org.apache.avro.test", false);    record.setFields(fields);    Protocol protocol = new Protocol("Simple", "org.apache.avro.test");    List<Field> params = new ArrayList<>();    params.add(new Field("record", record, null, null));    Protocol.Message message = protocol.createMessage("echo", null, new LinkedHashMap<String, String>(), Schema.createRecord(params), record, Schema.createUnion(new ArrayList<>()));    protocol.getMessages().put("echo", message);    try (Transceiver t = new SocketTransceiver(new InetSocketAddress(server.getPort()))) {        GenericRequestor r = new GenericRequestor(protocol, t);        GenericRecord args = new GenericData.Record(message.getRequest());        GenericRecord rec = new GenericData.Record(record);        rec.put("name", new Utf8("foo"));        rec.put("kind", new GenericData.EnumSymbol(PROTOCOL.getType("Kind"), "BAR"));        rec.put("hash", new GenericData.Fixed(PROTOCOL.getType("MD5"), new byte[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5 }));        rec.put("extra", Boolean.TRUE);        args.put("record", rec);        GenericRecord response = (GenericRecord) r.request("echo", args);        assertEquals(rec, response);    }}
6799cf9a972d1adda56eb425a8fa7cb0616a528d7355f02cbbbcf86b0a3e40eb
testStopServer
public static void testStopServer() throws Exception
{    client.close();    server.close();}
343dd7475cc0a9e06af2ddc0b430549da23f7c44b2571ea30dd9c1104b8f64f7
testStartServer
public void testStartServer() throws Exception
{    if (server != null)        return;    Responder responder = new TestResponder();    responder.addRPCPlugin(new RPCMetaTestPlugin("key1"));    responder.addRPCPlugin(new RPCMetaTestPlugin("key2"));    server = new SocketServer(responder, new InetSocketAddress(0));    server.start();    client = new SocketTransceiver(new InetSocketAddress(server.getPort()));    requestor = new GenericRequestor(PROTOCOL, client);    requestor.addRPCPlugin(new RPCMetaTestPlugin("key1"));    requestor.addRPCPlugin(new RPCMetaTestPlugin("key2"));}
51f21f5cce3c179bfe9277ec557dcd4f97b0e67226c372c59657162192a4d119
getSimpleProtocol
public static Protocol getSimpleProtocol() throws IOException
{    File file = new File("../../../share/test/schemas/simple.avpr");    return Protocol.parse(file);}
c221ab2b4dcf1ae4fe6a68ef2356c0cafd4134198259c8b9287ce545675ef320
testParsing
public void testParsing() throws IOException
{    Protocol protocol = getSimpleProtocol();    assertEquals(protocol.getDoc(), "Protocol used for testing.");    assertEquals(6, protocol.getMessages().size());    assertEquals("Pretend you're in a cave!", protocol.getMessages().get("echo").getDoc());}
5defe1310378b2c7a9a11b883e39ee38640b01adbdf830f8f6f09786e4f4c0bf
parseMessage
private static Message parseMessage(String message) throws Exception
{    return Protocol.parse("{\"protocol\": \"org.foo.Bar\"," + "\"types\": []," + "\"messages\": {" + message + "}}").getMessages().values().iterator().next();}
e55f9a9dcfe794c9555f1aa7374c3551caf5a0abe223e09cd73c1bb82e5a4890
oneWay
public void oneWay() throws Exception
{    Message m;        m = parseMessage("\"ack\": {" + "\"request\": []," + "\"response\": \"null\"," + "\"one-way\": true}");    assertTrue(m.isOneWay());        m = parseMessage("\"ack\": {" + "\"request\": []," + "\"one-way\": true}");    assertTrue(m.isOneWay());}
adcfeda6ff81b77235c84118c0da9828def05962aed01e33960c59ff18308a27
oneWayResponse
public void oneWayResponse() throws Exception
{        parseMessage("\"ack\": {" + "\"request\": [\"string\"]," + "\"response\": \"string\"," + "\"one-way\": true}");}
5ed48cf64e6356b6ae157f0308ba81cb56fa4b8d17474bead9877fe64878dfc5
oneWayError
public void oneWayError() throws Exception
{        parseMessage("\"ack\": {" + "\"request\": [\"string\"]," + "\"errors\": []," + "\"one-way\": true}");}
5cd6fc4925a5517dbafce14ba529becc782b1a7b5651cd958db30d66f696b2da
testMessageFieldAliases
public void testMessageFieldAliases() throws IOException
{    Protocol protocol = getSimpleProtocol();    final Message msg = protocol.getMessages().get("hello");    assertNotNull(msg);    final Schema.Field field = msg.getRequest().getField("greeting");    assertNotNull(field);    assertTrue(field.aliases().contains("salute"));}
7e7fa88c64d40fc1cc0358bb4e8d836f4de764ee907ff782e62830a8894c4471
testMessageCustomProperties
public void testMessageCustomProperties() throws IOException
{    Protocol protocol = getSimpleProtocol();    final Message msg = protocol.getMessages().get("hello");    assertNotNull(msg);    final Schema.Field field = msg.getRequest().getField("greeting");    assertNotNull(field);    assertEquals("customValue", field.getProp("customProp"));}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return this.name.hashCode();}
6b3ab298cb5d88dbb2c510c786f53e377489a40e2716e63c26a3e1691765f6c5
equals
public boolean equals(Object that)
{    return this.name.equals(((TestRecord) that).name);}
6d87b3f488a79535ec22d9b4fdeb6b2778f1602e9990699ee093ee5141d8890e
hello
public String hello(String greeting)
{    return "goodbye";}
f8e26015fb530ca98a71d6c55902e1e0bfd266b78c1980474b7b2c18a5771c7b
add
public int add(int arg1, int arg2)
{    return arg1 + arg2;}
767eaba11e63cf2e86776ef6e0be715d65225118dbf3a9d7787a13c5ab8fc405
echo
public TestRecord echo(TestRecord record)
{    return record;}
68ed15716fad26180a853c59337e9ff2f3ff798304a9a894a4d9ba11f186ae0c
echoBytes
public byte[] echoBytes(byte[] data)
{    return data;}
4e73197aeef6860acba6c0c5529241900b22cf82157f3fe2fdd4f1371f704e36
error
public void error() throws SimpleException
{    if (throwUndeclaredError)        throw new RuntimeException("foo");    throw new SimpleException("foo");}
343dd7475cc0a9e06af2ddc0b430549da23f7c44b2571ea30dd9c1104b8f64f7
testStartServer
public void testStartServer() throws Exception
{    if (server != null)        return;    server = new SocketServer(new ReflectResponder(Simple.class, new TestImpl()), new InetSocketAddress(0));    server.start();    client = new SocketTransceiver(new InetSocketAddress(server.getPort()));    proxy = ReflectRequestor.getClient(Simple.class, client);}
fe85c1c06caf067670e099368a992f0fbed82a90d2f77105ada88fc0274488a3
testClassLoader
public void testClassLoader() throws Exception
{    ClassLoader loader = new ClassLoader() {    };    ReflectResponder responder = new ReflectResponder(Simple.class, new TestImpl(), new ReflectData(loader));    assertEquals(responder.getReflectData().getClassLoader(), loader);    ReflectRequestor requestor = new ReflectRequestor(Simple.class, client, new ReflectData(loader));    assertEquals(requestor.getReflectData().getClassLoader(), loader);}
8034c4e28218e781759c766ec02979f4a366c0ac8f1de025abe0f4e132cd8be2
testHello
public void testHello() throws IOException
{    String response = proxy.hello("bob");    assertEquals("goodbye", response);}
e70809ca532ff0845bcba016a10b52320b72044e5a2e9689e0ade2dbe3169dd7
testEcho
public void testEcho() throws IOException
{    TestRecord record = new TestRecord();    record.name = "foo";    TestRecord echoed = proxy.echo(record);    assertEquals(record, echoed);}
bbb5a7f776f18e43de3aadc041894a563d0df8994eae99b8ac6f11cd91920484
testAdd
public void testAdd() throws IOException
{    int result = proxy.add(1, 2);    assertEquals(3, result);}
13c68635e456e7c74662449a17104798a32e2b2925be3c66df8cb978fbfed0f8
testEchoBytes
public void testEchoBytes() throws IOException
{    Random random = new Random();    int length = random.nextInt(1024 * 16);    byte[] data = new byte[length];    random.nextBytes(data);    byte[] echoed = proxy.echoBytes(data);    assertArrayEquals(data, echoed);}
3e93c1fb120879875fc82ed77fb354e91166c1c2a1cb5e2c4cb49dfdc9c53d5a
testError
public void testError() throws IOException
{    SimpleException error = null;    try {        proxy.error();    } catch (SimpleException e) {        error = e;    }    assertNotNull(error);    assertEquals("foo", error.getMessage());}
a1fc56e2b6d18de77311527dc7eaa364451cd0f1f10c2c618d3fb090af6cfc11
testUndeclaredError
public void testUndeclaredError() throws Exception
{    this.throwUndeclaredError = true;    RuntimeException error = null;    try {        proxy.error();    } catch (AvroRuntimeException e) {        error = e;    } finally {        this.throwUndeclaredError = false;    }    assertNotNull(error);    assertTrue(error.toString().contains("foo"));}
4128984afffe9c943bdc7e9272b1a5ce978c0e5978a753e7299b25f568c6c016
testStopServer
public static void testStopServer() throws IOException
{    client.close();    server.close();}
343dd7475cc0a9e06af2ddc0b430549da23f7c44b2571ea30dd9c1104b8f64f7
testStartServer
public void testStartServer() throws Exception
{    if (server != null)        return;    ReflectResponder rresp = new ReflectResponder(Simple.class, new TestImpl());    rresp.addRPCPlugin(new RPCMetaTestPlugin("key1"));    rresp.addRPCPlugin(new RPCMetaTestPlugin("key2"));    server = new SocketServer(rresp, new InetSocketAddress(0));    server.start();    client = new SocketTransceiver(new InetSocketAddress(server.getPort()));    ReflectRequestor requestor = new ReflectRequestor(Simple.class, client);    requestor.addRPCPlugin(new RPCMetaTestPlugin("key1"));    requestor.addRPCPlugin(new RPCMetaTestPlugin("key2"));    proxy = ReflectRequestor.getClient(Simple.class, requestor);}
6d87b3f488a79535ec22d9b4fdeb6b2778f1602e9990699ee093ee5141d8890e
hello
public String hello(String greeting)
{    return "goodbye";}
f8e26015fb530ca98a71d6c55902e1e0bfd266b78c1980474b7b2c18a5771c7b
add
public int add(int arg1, int arg2)
{    return arg1 + arg2;}
767eaba11e63cf2e86776ef6e0be715d65225118dbf3a9d7787a13c5ab8fc405
echo
public TestRecord echo(TestRecord record)
{    return record;}
7a176e7a426d536573df303093e9266cf04f09724bec8e6addabaa80e67a7089
echoBytes
public ByteBuffer echoBytes(ByteBuffer data)
{    return data;}
26100e3e2a24aa3c3355cc9bad6d49cc2c801ee035658567f5a783f9d7f7fea8
error
public void error() throws TestError
{    if (throwUndeclaredError)        throw new RuntimeException("foo");    throw TestError.newBuilder().setMessage$("an error").build();}
3d8d0014cc6b0e65cefa6505611c89ca5ac6939b904da588c889ccea39b2f664
ack
public void ack()
{    ackCount++;}
343dd7475cc0a9e06af2ddc0b430549da23f7c44b2571ea30dd9c1104b8f64f7
testStartServer
public void testStartServer() throws Exception
{    if (server != null)        return;    responder = new SpecificResponder(Simple.class, new TestImpl());    server = createServer(responder);    server.start();    client = createTransceiver();    SpecificRequestor req = new SpecificRequestor(Simple.class, client);    addRpcPlugins(req);    proxy = SpecificRequestor.getClient(Simple.class, req);    monitor = new HandshakeMonitor();    responder.addRPCPlugin(monitor);}
e43bc81c7dba1ca214bb02a27df20c82596b1ebd4ebb8fd0a528ef9f489d2212
addRpcPlugins
public void addRpcPlugins(Requestor requestor)
{}
d2c969c3d001f4cb8ee4faf386f2b39208dd1de1af42947372b3ba149b948da2
createServer
public Server createServer(Responder testResponder) throws Exception
{    return server = new SocketServer(testResponder, new InetSocketAddress(0));}
b723b1ec8e0ad25b5fa0c50c217e5a3f9380f12f0fa602f368cec8d7c19fdad2
createTransceiver
public Transceiver createTransceiver() throws Exception
{    return new SocketTransceiver(new InetSocketAddress(server.getPort()));}
fe85c1c06caf067670e099368a992f0fbed82a90d2f77105ada88fc0274488a3
testClassLoader
public void testClassLoader() throws Exception
{    ClassLoader loader = new ClassLoader() {    };    SpecificResponder responder = new SpecificResponder(Simple.class, new TestImpl(), new SpecificData(loader));    assertEquals(responder.getSpecificData().getClassLoader(), loader);    SpecificRequestor requestor = new SpecificRequestor(Simple.class, client, new SpecificData(loader));    assertEquals(requestor.getSpecificData().getClassLoader(), loader);}
bd1554b0980725f6bc6ce34ed393e351962aa1a9bd779eb03e874b10559bf3e4
testGetRemote
public void testGetRemote() throws IOException
{    assertEquals(Simple.PROTOCOL, SpecificRequestor.getRemote(proxy));}
8034c4e28218e781759c766ec02979f4a366c0ac8f1de025abe0f4e132cd8be2
testHello
public void testHello() throws IOException
{    String response = proxy.hello("bob");    assertEquals("goodbye", response);}
b2e3a75a7714c7bd8e1edbb13061d9728cc198b1d3900b35b3f14f67cf57374d
testHashCode
public void testHashCode() throws IOException
{    TestError error = new TestError();    error.hashCode();}
e70809ca532ff0845bcba016a10b52320b72044e5a2e9689e0ade2dbe3169dd7
testEcho
public void testEcho() throws IOException
{    TestRecord record = new TestRecord();    record.setName("foo");    record.setKind(Kind.BAR);    record.setHash(new MD5(new byte[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5 }));    TestRecord echoed = proxy.echo(record);    assertEquals(record, echoed);    assertEquals(record.hashCode(), echoed.hashCode());}
bbb5a7f776f18e43de3aadc041894a563d0df8994eae99b8ac6f11cd91920484
testAdd
public void testAdd() throws IOException
{    int result = proxy.add(1, 2);    assertEquals(3, result);}
13c68635e456e7c74662449a17104798a32e2b2925be3c66df8cb978fbfed0f8
testEchoBytes
public void testEchoBytes() throws IOException
{    Random random = new Random();    int length = random.nextInt(1024 * 16);    ByteBuffer data = ByteBuffer.allocate(length);    random.nextBytes(data.array());    data.flip();    ByteBuffer echoed = proxy.echoBytes(data);    assertEquals(data, echoed);}
68995a9b88784ea72221f73dee7e1bd1777997fff8de9932c903ce73014419ab
testEmptyEchoBytes
public void testEmptyEchoBytes() throws IOException
{    ByteBuffer data = ByteBuffer.allocate(0);    ByteBuffer echoed = proxy.echoBytes(data);    data.flip();    assertEquals(data, echoed);}
3e93c1fb120879875fc82ed77fb354e91166c1c2a1cb5e2c4cb49dfdc9c53d5a
testError
public void testError() throws IOException
{    TestError error = null;    try {        proxy.error();    } catch (TestError e) {        error = e;    }    assertNotNull(error);    assertEquals("an error", error.getMessage$());}
a1fc56e2b6d18de77311527dc7eaa364451cd0f1f10c2c618d3fb090af6cfc11
testUndeclaredError
public void testUndeclaredError() throws Exception
{    this.throwUndeclaredError = true;    RuntimeException error = null;    try {        proxy.error();    } catch (RuntimeException e) {        error = e;    } finally {        this.throwUndeclaredError = false;    }    assertNotNull(error);    assertTrue(error.toString().contains("foo"));}
6ace38c56d538ea17d55e2491add509a01138cc5eb4be4b2a2f0bb433cb9a634
testOneWay
public void testOneWay() throws IOException
{    ackCount = 0;    proxy.ack();        proxy.hello("foo");    proxy.ack();    try {        Thread.sleep(100);    } catch (InterruptedException e) {    }    assertEquals(2, ackCount);}
7dcde1ccec448277437cf4fab46e4ddea03c6cb2ac02d1cf850d0bf8dc4fac01
testRepeatedAccess
public void testRepeatedAccess() throws Exception
{    for (int x = 0; x < 1000; x++) {        proxy.hello("hi!");    }}
9b950ccc7e7d02b42c6ec4dd7e4f897f41a019b4f4b8e550dc9d0e40bdc09d8c
testConnectionRefusedOneWay
public void testConnectionRefusedOneWay() throws IOException
{    Transceiver client = new HttpTransceiver(new URL("http://localhost:4444"));    SpecificRequestor req = new SpecificRequestor(Simple.class, client);    addRpcPlugins(req);    Simple proxy = SpecificRequestor.getClient(Simple.class, req);    proxy.ack();}
3e737afb7d89449940d843165c61c076f9987d5339e6a68e02d063555c7a6e95
testParamVariation
public void testParamVariation() throws Exception
{    Protocol protocol = new Protocol("Simple", "org.apache.avro.test");    List<Schema.Field> fields = new ArrayList<>();    fields.add(new Schema.Field("extra", Schema.create(Schema.Type.BOOLEAN), null, null));    fields.add(new Schema.Field("greeting", Schema.create(Schema.Type.STRING), null, null));    Protocol.Message message = protocol.createMessage("hello", null, /* doc */    new LinkedHashMap<String, String>(), Schema.createRecord(fields), Schema.create(Schema.Type.STRING), Schema.createUnion(new ArrayList<>()));    protocol.getMessages().put("hello", message);    try (Transceiver t = createTransceiver()) {        GenericRequestor r = new GenericRequestor(protocol, t);        addRpcPlugins(r);        GenericRecord params = new GenericData.Record(message.getRequest());        params.put("extra", Boolean.TRUE);        params.put("greeting", "bob");        String response = r.request("hello", params).toString();        assertEquals("goodbye", response);    }}
a96de8ee51c79f8841dfa0df1319cc107ffc72a68f846e9c711b5704cc9c5666
testHandshakeCount
public static void testHandshakeCount() throws IOException
{    monitor.assertHandshake();}
4128984afffe9c943bdc7e9272b1a5ce978c0e5978a753e7299b25f568c6c016
testStopServer
public static void testStopServer() throws IOException
{    client.close();    server.close();    server = null;}
074781ff684c8b35bb8fdf244f06cefb51029229fec7ca609376e62d2f6dd542
serverConnecting
public void serverConnecting(RPCContext context)
{    handshakes++;    int expected = getExpectedHandshakeCount();    if (expected > 0 && handshakes > expected) {        throw new IllegalStateException("Expected number of Protocol negotiation handshakes exceeded expected " + expected + " was " + handshakes);    }        String clientProtocol = context.getHandshakeRequest().clientProtocol;    if (clientProtocol != null) {        assertFalse(seenProtocols.contains(clientProtocol));        seenProtocols.add(clientProtocol);    }}
b773a4fdf40fb6360e98d30df70f5727378a8b874c9bb01c08bdd6e8368ca648
assertHandshake
public void assertHandshake()
{    int expected = getExpectedHandshakeCount();    if (expected != REPEATING) {        assertEquals("Expected number of handshakes did not take place.", expected, handshakes);    }}
38f6f275e4665b7bc5553d8f196e583a98d4b5bc53049915ab8fab55edcd57e7
getExpectedHandshakeCount
protected int getExpectedHandshakeCount()
{    return 3;}
761457857eac4f28f22768140253b5da0218f17dc6b9ed0cc4cf3e5b2f247060
testClient
public void testClient() throws Exception
{    for (File f : Objects.requireNonNull(SERVER_PORTS_DIR.listFiles())) {        LineNumberReader reader = new LineNumberReader(new FileReader(f));        int port = Integer.parseInt(reader.readLine());        System.out.println("Validating java client to " + f.getName() + " - " + port);        Transceiver client = new SocketTransceiver(new InetSocketAddress("localhost", port));        proxy = SpecificRequestor.getClient(Simple.class, client);        TestProtocolSpecific proto = new TestProtocolSpecific();        proto.testHello();        proto.testEcho();        proto.testEchoBytes();        proto.testError();        System.out.println("Done! Validation java client to " + f.getName() + " - " + port);    }}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    SocketServer server = new SocketServer(new SpecificResponder(Simple.class, new TestImpl()), new InetSocketAddress(0));    server.start();    File portFile = new File(SERVER_PORTS_DIR, "java-port");    FileWriter w = new FileWriter(portFile);    w.write(Integer.toString(server.getPort()));    w.close();}
d2c969c3d001f4cb8ee4faf386f2b39208dd1de1af42947372b3ba149b948da2
createServer
public Server createServer(Responder testResponder) throws Exception
{    responder.addRPCPlugin(new RPCMetaTestPlugin("key1"));    responder.addRPCPlugin(new RPCMetaTestPlugin("key2"));    return new SocketServer(responder, new InetSocketAddress(0));}
b723b1ec8e0ad25b5fa0c50c217e5a3f9380f12f0fa602f368cec8d7c19fdad2
createTransceiver
public Transceiver createTransceiver() throws Exception
{    return new SocketTransceiver(new InetSocketAddress(server.getPort()));}
e2a849d2835c0b076622a56681ad0c9173f32a456483d709d2f8afb6164c862f
addRpcPlugins
public void addRpcPlugins(Requestor req)
{    req.addRPCPlugin(new RPCMetaTestPlugin("key1"));    req.addRPCPlugin(new RPCMetaTestPlugin("key2"));}
54ab17508299828a7087f00ae2e6fc6d917df30ed0bfccb16fa6bfd3fe681052
testNull
public void testNull() throws Exception
{    assertEquals(Schema.create(Type.NULL), new Schema.Parser().parse("\"null\""));    assertEquals(Schema.create(Type.NULL), new Schema.Parser().parse("{\"type\":\"null\"}"));    check(new File(DIR.getRoot(), name.getMethodName()), "\"null\"", "null", null);}
1c4ead9765938332059d76104de2519bbd7b9057fd53ed73120e527efd881e7a
testBoolean
public void testBoolean() throws Exception
{    assertEquals(Schema.create(Type.BOOLEAN), new Schema.Parser().parse("\"boolean\""));    assertEquals(Schema.create(Type.BOOLEAN), new Schema.Parser().parse("{\"type\":\"boolean\"}"));    check(new File(DIR.getRoot(), name.getMethodName()), "\"boolean\"", "true", Boolean.TRUE);}
47091a22b52c1ea805d7739df5201a4e7327af110691372a168e229d498ce84a
testString
public void testString() throws Exception
{    assertEquals(Schema.create(Type.STRING), new Schema.Parser().parse("\"string\""));    assertEquals(Schema.create(Type.STRING), new Schema.Parser().parse("{\"type\":\"string\"}"));    check(new File(DIR.getRoot(), name.getMethodName()), "\"string\"", "\"foo\"", new Utf8("foo"));}
a4e6b9f25ced9157a314ef8ee378dda6c12353478243004ff437e919eacbc247
testBytes
public void testBytes() throws Exception
{    assertEquals(Schema.create(Type.BYTES), new Schema.Parser().parse("\"bytes\""));    assertEquals(Schema.create(Type.BYTES), new Schema.Parser().parse("{\"type\":\"bytes\"}"));    check(new File(DIR.getRoot(), name.getMethodName()), "\"bytes\"", "\"\\u0000ABC\\u00FF\"", ByteBuffer.wrap(new byte[] { 0, 65, 66, 67, -1 }));}
7d308bd607294c47e283d31de15a82aeaaad961e02fc7aca32909747cfcabcad
testInt
public void testInt() throws Exception
{    assertEquals(Schema.create(Type.INT), new Schema.Parser().parse("\"int\""));    assertEquals(Schema.create(Type.INT), new Schema.Parser().parse("{\"type\":\"int\"}"));    check(new File(DIR.getRoot(), name.getMethodName()), "\"int\"", "9", 9);}
610de3ad7cc1d54bdbc9a4fe9c41e2c012a37ae58dac4466b22979a25e1b08e7
testLong
public void testLong() throws Exception
{    assertEquals(Schema.create(Type.LONG), new Schema.Parser().parse("\"long\""));    assertEquals(Schema.create(Type.LONG), new Schema.Parser().parse("{\"type\":\"long\"}"));    check(new File(DIR.getRoot(), name.getMethodName()), "\"long\"", "11", 11L);}
b7f222c157daee3f00a40a6f98b21c2806a0bfbf7a58e847930af5420b976276
testFloat
public void testFloat() throws Exception
{    assertEquals(Schema.create(Type.FLOAT), new Schema.Parser().parse("\"float\""));    assertEquals(Schema.create(Type.FLOAT), new Schema.Parser().parse("{\"type\":\"float\"}"));    check(new File(DIR.getRoot(), name.getMethodName()), "\"float\"", "1.1", 1.1f);    checkDefault("\"float\"", "\"NaN\"", Float.NaN);    checkDefault("\"float\"", "\"Infinity\"", Float.POSITIVE_INFINITY);    checkDefault("\"float\"", "\"-Infinity\"", Float.NEGATIVE_INFINITY);}
d1cc0c0b6a548d4db9fe52df21cce3b0c12faae6479bc1660611b03839fdb710
testDouble
public void testDouble() throws Exception
{    assertEquals(Schema.create(Type.DOUBLE), new Schema.Parser().parse("\"double\""));    assertEquals(Schema.create(Type.DOUBLE), new Schema.Parser().parse("{\"type\":\"double\"}"));    check(new File(DIR.getRoot(), name.getMethodName()), "\"double\"", "1.2", 1.2);    checkDefault("\"double\"", "\"NaN\"", Double.NaN);    checkDefault("\"double\"", "\"Infinity\"", Double.POSITIVE_INFINITY);    checkDefault("\"double\"", "\"-Infinity\"", Double.NEGATIVE_INFINITY);}
7749ea47bc1c162d12a2c024fc5b3f5a5ed16bb6c8cb8dfaf741cc6e5cc57239
testArray
public void testArray() throws Exception
{    String json = "{\"type\":\"array\", \"items\": \"long\"}";    Schema schema = new Schema.Parser().parse(json);    Collection<Long> array = new GenericData.Array<>(1, schema);    array.add(1L);    check(new File(DIR.getRoot(), name.getMethodName()), json, "[1]", array);    array = new ArrayList<>(1);    array.add(1L);    check(new File(DIR.getRoot(), name.getMethodName()), json, "[1]", array);        checkParseError("{\"type\":\"array\"}");}
7e3f62689a52f5cfc8f5889d1068814d43f1f4feaa85df375762f0f9cb0ab82c
testMap
public void testMap() throws Exception
{    HashMap<Utf8, Long> map = new HashMap<>();    map.put(new Utf8("a"), 1L);    check(new File(DIR.getRoot(), name.getMethodName()), "{\"type\":\"map\", \"values\":\"long\"}", "{\"a\":1}", map);        checkParseError("{\"type\":\"map\"}");}
ed97b8cecb7a4047198a24d4e631f7f1da8c5104d348e811b4b331b3cd0f3e63
testUnionMap
public void testUnionMap() throws Exception
{    String unionMapSchema = "{\"name\":\"foo\", \"type\":\"record\"," + " \"fields\":[ {\"name\":\"mymap\", \"type\":" + "   [{\"type\":\"map\", \"values\":" + "      [\"int\",\"long\",\"float\",\"string\"]}," + "    \"null\"]" + "   }]" + " }";    check(new File(DIR.getRoot(), name.getMethodName()), unionMapSchema, true);}
bc60056fba07c84186113a44978125e27ff567860e028682a7e6e98bb36c39eb
testRecord
public void testRecord() throws Exception
{    String recordJson = "{\"type\":\"record\", \"name\":\"Test\", \"fields\":" + "[{\"name\":\"f\", \"type\":\"long\", \"foo\":\"bar\"}]}";    Schema schema = new Schema.Parser().parse(recordJson);    GenericData.Record record = new GenericData.Record(schema);    record.put("f", 11L);    check(new File(DIR.getRoot(), name.getMethodName()), recordJson, "{\"f\":11}", record, false);        assertEquals("bar", schema.getField("f").getProp("foo"));    assertEquals("bar", new Schema.Parser().parse(schema.toString()).getField("f").getProp("foo"));    schema.getField("f").addProp("baz", "boo");    assertEquals("boo", schema.getField("f").getProp("baz"));    checkParseError("{\"type\":\"record\"}");    checkParseError("{\"type\":\"record\",\"name\":\"X\"}");    checkParseError("{\"type\":\"record\",\"name\":\"X\",\"fields\":\"Y\"}");        checkParseError("{\"type\":\"record\",\"name\":\"X\",\"fields\":" + "[{\"name\":\"f\"}]}");        checkParseError("{\"type\":\"record\",\"name\":\"X\",\"fields\":" + "[{\"type\":\"long\"}]}");        checkParseError("{\"type\":\"record\",\"name\":\"1X\",\"fields\":[]}");    checkParseError("{\"type\":\"record\",\"name\":\"X$\",\"fields\":[]}");        checkParseError("{\"type\":\"record\",\"name\":\"X\",\"fields\":[" + "{\"name\":\"1f\",\"type\":\"int\"}]}");    checkParseError("{\"type\":\"record\",\"name\":\"X\",\"fields\":[" + "{\"name\":\"f$\",\"type\":\"int\"}]}");    checkParseError("{\"type\":\"record\",\"name\":\"X\",\"fields\":[" + "{\"name\":\"f.g\",\"type\":\"int\"}]}");}
04fbd6b1fe4dc6e8bb442ac268f32cd57ea31e94c228005f4ee5a163f4bee46f
testInvalidNameTolerance
public void testInvalidNameTolerance()
{    new Schema.Parser().setValidate(false).parse("{\"type\":\"record\",\"name\":\"1X\",\"fields\":[]}");    new Schema.Parser().setValidate(false).parse("{\"type\":\"record\",\"name\":\"X-\",\"fields\":[]}");    new Schema.Parser().setValidate(false).parse("{\"type\":\"record\",\"name\":\"X$\",\"fields\":[]}");}
99f3f459b222122df26483c5267431341c36e84bc7289141726760361a2891e7
testMapInRecord
public void testMapInRecord() throws Exception
{    String json = "{\"type\":\"record\", \"name\":\"Test\", \"fields\":" + "[{\"name\":\"f\", \"type\": {\"type\":\"map\", \"values\":\"long\"}}]}";    Schema schema = new Schema.Parser().parse(json);    HashMap<Utf8, Long> map = new HashMap<>();    map.put(new Utf8("a"), 1L);    GenericData.Record record = new GenericData.Record(schema);    record.put("f", map);    check(new File(DIR.getRoot(), name.getMethodName()), json, "{\"f\":{\"a\":1}}", record, false);}
3776f415ff726e12f4d27d6f94a41798d7873f7ae8f7190bf152d378efc74b28
testEnum
public void testEnum() throws Exception
{    check(new File(DIR.getRoot(), name.getMethodName()), BASIC_ENUM_SCHEMA, "\"B\"", new GenericData.EnumSymbol(new Schema.Parser().parse(BASIC_ENUM_SCHEMA), "B"), false);        checkParseError("{\"type\":\"enum\"}");        checkParseError("{\"type\":\"enum\",\"symbols\": [\"X\"]}");        checkParseError("{\"type\":\"enum\",\"name\":\"X\",\"symbols\":[\"X\",\"X\"]}");        checkParseError("{\"type\":\"enum\",\"name\":\"X\",\"symbols\":[\"1X\"]}");    checkParseError("{\"type\":\"enum\",\"name\":\"X\",\"symbols\":[\"X$\"]}");    checkParseError("{\"type\":\"enum\",\"name\":\"X\",\"symbols\":[\"X.Y\"]}");}
21b7e6e86390c7d6c8c8decf9248b88719cb745ebf6b49e78c010e39e520c041
testFixed
public void testFixed() throws Exception
{    String json = "{\"type\": \"fixed\", \"name\":\"Test\", \"size\": 1}";    Schema schema = new Schema.Parser().parse(json);    check(new File(DIR.getRoot(), name.getMethodName()), json, "\"a\"", new GenericData.Fixed(schema, new byte[] { (byte) 'a' }), false);        checkParseError("{\"type\":\"fixed\"}");}
404a2a28659c37c7444b07b7ae4c7574e60cc80e8110d144d5e88f7cbd9edc51
testRecursive
public void testRecursive() throws Exception
{    check(new File(DIR.getRoot(), name.getMethodName()), "{\"type\": \"record\", \"name\": \"Node\", \"fields\": [" + "{\"name\":\"label\", \"type\":\"string\"}," + "{\"name\":\"children\", \"type\":" + "{\"type\": \"array\", \"items\": \"Node\" }}]}", false);}
126f0172286940a607e28ac93e5e0b70241ebd5aa5a74aaa38f82e415777310a
testRecursiveEquals
public void testRecursiveEquals() throws Exception
{    String jsonSchema = "{\"type\":\"record\", \"name\":\"List\", \"fields\": [" + "{\"name\":\"next\", \"type\":\"List\"}]}";    Schema s1 = new Schema.Parser().parse(jsonSchema);    Schema s2 = new Schema.Parser().parse(jsonSchema);    assertEquals(s1, s2);        s1.hashCode();}
8f0a3e115bcceacd438a9cbb25885d4c4db1d4a34aea2fbb7502cdecc14031bf
testSchemaExplosion
public void testSchemaExplosion() throws Exception
{    for (int i = 1; i < 15; i++) {                                List<Schema> recs = new ArrayList<>();        for (int j = 0; j < i; j++) recs.add(Schema.createRecord("" + (char) ('A' + j), null, null, false));        for (Schema s : recs) {            Schema union = Schema.createUnion(recs);            Field f = new Field("x", union, null, null);            List<Field> fields = new ArrayList<>();            fields.add(f);            s.setFields(fields);        }                for (Schema s1 : recs) {            Schema s2 = new Schema.Parser().parse(s1.toString());            assertEquals(s1.hashCode(), s2.hashCode());            assertEquals(s1, s2);        }    }}
6995005dafecb523ca1abe9799027a237322be76b0d2ba2d792b8fe1f6c840e8
testLisp
public void testLisp() throws Exception
{    check(new File(DIR.getRoot(), name.getMethodName()), LISP_SCHEMA, false);}
885adce170ee8976432efbf14891fef8562a01c79e29888906018818c2983c1a
testUnion
public void testUnion() throws Exception
{    check(new File(DIR.getRoot(), name.getMethodName()), "[\"string\", \"long\"]", false);    checkDefault("[\"double\", \"long\"]", "1.1", 1.1);        for (String type : new String[] { "int", "long", "float", "double", "string", "bytes", "boolean" }) {                checkValidateDefaults("[\"" + type + "\", \"null\"]", "null");        boolean error = false;        try {                        checkDefault("[\"" + type + "\", \"null\"]", "null", 0);        } catch (AvroTypeException e) {            error = true;        }        assertTrue(error);                checkValidateDefaults("[\"null\", \"" + type + "\"]", "0");        error = false;        try {                        checkDefault("[\"null\", \"" + type + "\"]", "0", null);        } catch (AvroTypeException e) {            error = true;        }        assertTrue(error);    }        String record = "{\"type\":\"record\",\"name\":\"Foo\",\"fields\":[]}";    String fixed = "{\"type\":\"fixed\",\"name\":\"Bar\",\"size\": 1}";    String enu = "{\"type\":\"enum\",\"name\":\"Baz\",\"symbols\": [\"X\"]}";    Schema union = new Schema.Parser().parse("[\"null\",\"string\"," + record + "," + enu + "," + fixed + "]");    checkJson(union, null, "null");    checkJson(union, new Utf8("foo"), "{\"string\":\"foo\"}");    checkJson(union, new GenericData.Record(new Schema.Parser().parse(record)), "{\"Foo\":{}}");    checkJson(union, new GenericData.Fixed(new Schema.Parser().parse(fixed), new byte[] { (byte) 'a' }), "{\"Bar\":\"a\"}");    checkJson(union, new GenericData.EnumSymbol(new Schema.Parser().parse(enu), "X"), "{\"Baz\":\"X\"}");}
558dc296762fa4e7250d0d06a0328c185e0b8b17e4b1eaa5ec8684cb95db0421
testComplexUnions
public void testComplexUnions() throws Exception
{        String partial = "[\"int\", \"long\", \"float\", \"double\", \"boolean\", \"bytes\"," + " \"string\", {\"type\":\"array\", \"items\": \"long\"}," + " {\"type\":\"map\", \"values\":\"long\"}";    String namedTypes = ", {\"type\":\"record\",\"name\":\"Foo\",\"fields\":[]}," + " {\"type\":\"fixed\",\"name\":\"Bar\",\"size\": 1}," + " {\"type\":\"enum\",\"name\":\"Baz\",\"symbols\": [\"X\"]}";    String namedTypes2 = ", {\"type\":\"record\",\"name\":\"Foo2\",\"fields\":[]}," + " {\"type\":\"fixed\",\"name\":\"Bar2\",\"size\": 1}," + " {\"type\":\"enum\",\"name\":\"Baz2\",\"symbols\": [\"X\"]}";    check(new File(DIR.getRoot(), name.getMethodName()), partial + namedTypes + "]", false);    check(new File(DIR.getRoot(), name.getMethodName()), partial + namedTypes + namedTypes2 + "]", false);    checkParseError(partial + namedTypes + namedTypes + "]");        checkUnionError(new Schema[] { Schema.create(Type.INT), Schema.create(Type.INT) });    checkUnionError(new Schema[] { Schema.create(Type.LONG), Schema.create(Type.LONG) });    checkUnionError(new Schema[] { Schema.create(Type.FLOAT), Schema.create(Type.FLOAT) });    checkUnionError(new Schema[] { Schema.create(Type.DOUBLE), Schema.create(Type.DOUBLE) });    checkUnionError(new Schema[] { Schema.create(Type.BOOLEAN), Schema.create(Type.BOOLEAN) });    checkUnionError(new Schema[] { Schema.create(Type.BYTES), Schema.create(Type.BYTES) });    checkUnionError(new Schema[] { Schema.create(Type.STRING), Schema.create(Type.STRING) });    checkUnionError(new Schema[] { Schema.createArray(Schema.create(Type.INT)), Schema.createArray(Schema.create(Type.INT)) });    checkUnionError(new Schema[] { Schema.createMap(Schema.create(Type.INT)), Schema.createMap(Schema.create(Type.INT)) });    List<String> symbols = new ArrayList<>();    symbols.add("NOTHING");        Schema u;    u = buildUnion(new Schema[] { new Schema.Parser().parse("{\"type\":\"record\",\"name\":\"x.A\",\"fields\":[]}"), new Schema.Parser().parse("{\"type\":\"record\",\"name\":\"y.A\",\"fields\":[]}") });    check(new File(DIR.getRoot(), name.getMethodName()), u.toString(), false);    u = buildUnion(new Schema[] { new Schema.Parser().parse("{\"type\":\"enum\",\"name\":\"x.A\",\"symbols\":[\"X\"]}"), new Schema.Parser().parse("{\"type\":\"enum\",\"name\":\"y.A\",\"symbols\":[\"Y\"]}") });    check(new File(DIR.getRoot(), name.getMethodName()), u.toString(), false);    u = buildUnion(new Schema[] { new Schema.Parser().parse("{\"type\":\"fixed\",\"name\":\"x.A\",\"size\":4}"), new Schema.Parser().parse("{\"type\":\"fixed\",\"name\":\"y.A\",\"size\":8}") });    check(new File(DIR.getRoot(), name.getMethodName()), u.toString(), false);        checkUnionError(new Schema[] { Schema.createRecord("Foo", null, "org.test", false), Schema.createRecord("Foo", null, "org.test", false) });    checkUnionError(new Schema[] { Schema.createEnum("Bar", null, "org.test", symbols), Schema.createEnum("Bar", null, "org.test", symbols) });    checkUnionError(new Schema[] { Schema.createFixed("Baz", null, "org.test", 2), Schema.createFixed("Baz", null, "org.test", 1) });    Schema union = buildUnion(new Schema[] { Schema.create(Type.INT) });        checkUnionError(new Schema[] { union });}
6245fa025165a645b101d0ae7067b7f1af928584f46977d326e408f57a5413e2
testComplexProp
public void testComplexProp()
{    String json = "{\"type\":\"null\", \"foo\": [0]}";    Schema s = new Schema.Parser().parse(json);    assertNull(s.getProp("foo"));}
aefdc0efb70131254e06b6288f53238df6d4cf877e35512755f6288b765c4c8e
testPropOrdering
public void testPropOrdering()
{    String json = "{\"type\":\"int\",\"z\":\"c\",\"yy\":\"b\",\"x\":\"a\"}";    Schema s = new Schema.Parser().parse(json);    assertEquals(json, s.toString());}
2e0e1358e11df187f56fa9ee5c175bc3dbc39b2c7bc3c7558ff8b133d2ee4250
testParseInputStream
public void testParseInputStream() throws IOException
{    Schema s = new Schema.Parser().parse(new ByteArrayInputStream("\"boolean\"".getBytes(StandardCharsets.UTF_8)));    assertEquals(new Schema.Parser().parse("\"boolean\""), s);}
002a3beae26cf3d9880b888b7706a4c5c2ff157321feb66d642e9b4bbef9f588
testNamespaceScope
public void testNamespaceScope()
{    String z = "{\"type\":\"record\",\"name\":\"Z\",\"fields\":[]}";    String y = "{\"type\":\"record\",\"name\":\"q.Y\",\"fields\":[" + "{\"name\":\"f\",\"type\":" + z + "}]}";    String x = "{\"type\":\"record\",\"name\":\"p.X\",\"fields\":[" + "{\"name\":\"f\",\"type\":" + y + "}," + "{\"name\":\"g\",\"type\":" + z + "}" + "]}";    Schema xs = new Schema.Parser().parse(x);    Schema ys = xs.getField("f").schema();    assertEquals("p.Z", xs.getField("g").schema().getFullName());    assertEquals("q.Z", ys.getField("f").schema().getFullName());}
806d6a5f142e1b62bf7ff964be57cc2e4b64daa5f670f01052213f1414e4159a
testNamespaceNesting
public void testNamespaceNesting()
{    String y = "{\"type\":\"record\",\"name\":\"y.Y\",\"fields\":[" + "{\"name\":\"f\",\"type\":\"x.X\"}]}";    String x = "{\"type\":\"record\",\"name\":\"x.X\",\"fields\":[" + "{\"name\":\"f\",\"type\":" + y + "}" + "]}";    Schema xs = new Schema.Parser().parse(x);    assertEquals(xs, new Schema.Parser().parse(xs.toString()));}
f135e80350cebdf5d9db026cc1bd74ac4ffecdcf37b776048eb89609e4d5fd0c
testNestedNullNamespace
public void testNestedNullNamespace()
{    Schema inner = new Schema.Parser().parse("{\"type\":\"record\",\"name\":\"Inner\",\"fields\":[]}");    Schema outer = Schema.createRecord("Outer", null, "space", false);    outer.setFields(Collections.singletonList(new Field("f", inner, null, null)));    assertEquals(outer, new Schema.Parser().parse(outer.toString()));}
a0012ace187ab0393e722a3be2cec205b12b2fc6d6137cc47299b374fd8ddb75
testNestedNullNamespaceReferencing
public void testNestedNullNamespaceReferencing()
{    Schema inner = new Schema.Parser().parse("{\"type\":\"record\",\"name\":\"Inner\",\"fields\":[]}");    Schema outer = Schema.createRecord("Outer", null, "space", false);    outer.setFields(Arrays.asList(new Field("f1", inner, null, null), new Field("f2", inner, null, null)));    assertEquals(outer, new Schema.Parser().parse(outer.toString()));}
ef7a2aedae51911e6ad8adb2cedb740a341834b9ceaef90123e469ce8cf49d2f
testNestedNullNamespaceReferencingWithUnion
public void testNestedNullNamespaceReferencingWithUnion()
{    Schema inner = new Schema.Parser().parse("{\"type\":\"record\",\"name\":\"Inner\",\"fields\":[]}");    Schema innerUnion = Schema.createUnion(Arrays.asList(inner, Schema.create(Type.NULL)));    Schema outer = Schema.createRecord("Outer", null, "space", false);    outer.setFields(Arrays.asList(new Field("f1", innerUnion, null, null), new Field("f2", innerUnion, null, null)));    assertEquals(outer, new Schema.Parser().parse(outer.toString()));}
8dad922d0390ff2b6287f8abfbc41ddcb167478b4ff04337634b2402ccb64e1f
testNestedNonNullNamespace1
public void testNestedNonNullNamespace1()
{    Schema inner1 = Schema.createEnum("InnerEnum", null, "space", Collections.singletonList("x"));    Schema inner2 = new Schema.Parser().parse("{\"type\":\"record\",\"namespace\":\"space\",\"name\":" + "\"InnerRecord\",\"fields\":[]}");    Schema nullOuter = Schema.createRecord("Outer", null, null, false);    nullOuter.setFields(Arrays.asList(new Field("f1", inner1, null, null), new Field("f2", inner2, null, null)));    assertEquals(nullOuter, new Schema.Parser().parse(nullOuter.toString()));}
45eb4ca8a3332139bff3176a1324cf5b239d848c86161b7753cf873cf0e83386
testNestedNonNullNamespace2
public void testNestedNonNullNamespace2()
{    Schema inner1 = Schema.createFixed("InnerFixed", null, "space", 1);    Schema inner2 = new Schema.Parser().parse("{\"type\":\"record\",\"namespace\":\"space\",\"name\":" + "\"InnerRecord\",\"fields\":[]}");    Schema nullOuter = Schema.createRecord("Outer", null, null, false);    nullOuter.setFields(Arrays.asList(new Field("f1", inner1, null, null), new Field("f2", inner2, null, null)));    assertEquals(nullOuter, new Schema.Parser().parse(nullOuter.toString()));}
d2db663d6d60e2d374032e6fae5068c7b1ec93ea13bdcfeb09ecaf227d72c2a8
testNullNamespaceAlias
public void testNullNamespaceAlias()
{    Schema s = new Schema.Parser().parse("{\"type\":\"record\",\"name\":\"Z\",\"fields\":[]}");    Schema t = new Schema.Parser().parse("{\"type\":\"record\",\"name\":\"x.Y\",\"aliases\":[\".Z\"]," + "\"fields\":[]}");    Schema u = Schema.applyAliases(s, t);    assertEquals("x.Y", u.getFullName());}
56ff637d1874e5afbfa9e6441bfd2e64e186e32295cef79ac073587b4311b068
testNullPointer
public void testNullPointer() throws Exception
{    String recordJson = "{\"type\":\"record\", \"name\":\"Test\", \"fields\":" + "[{\"name\":\"x\", \"type\":\"string\"}]}";    Schema schema = new Schema.Parser().parse(recordJson);    GenericData.Record record = new GenericData.Record(schema);    try {        checkBinary(schema, record, new GenericDatumWriter<>(), new GenericDatumReader<>());    } catch (NullPointerException e) {        assertEquals("null of string in field x of Test", e.getMessage());    }}
e9e00ab22577bde608e72160814bc3027c4e2aff137b84c050e328e8644a2546
checkParseError
private static void checkParseError(String json)
{    try {        new Schema.Parser().parse(json);    } catch (SchemaParseException e) {        return;    }    fail("Should not have parsed: " + json);}
2181464b39c05b8f5d861afc5326b28760e57f9dd26832fd0bf94c7570100e11
checkUnionError
private static void checkUnionError(Schema[] branches)
{    List<Schema> branchList = Arrays.asList(branches);    try {        Schema.createUnion(branchList);        fail("Union should not have constructed from: " + branchList);    } catch (AvroRuntimeException ignored) {    }}
3f742dff45895c575a77c4456315d724e836a4b5f6fe7cc41a5d88779d2e91a9
buildUnion
private static Schema buildUnion(Schema[] branches)
{    List<Schema> branchList = Arrays.asList(branches);    return Schema.createUnion(branchList);}
9a5f5dda88663a9a2608b18c6ebf0adcb278f12100eedbbd3c8dd96f3f6825fa
testDocs
public void testDocs()
{    Schema schema = new Schema.Parser().parse(SCHEMA_WITH_DOC_TAGS);    assertEquals("This is not a world record.", schema.getDoc());    assertEquals("Inner Fixed", schema.getField("inner_fixed").doc());    assertEquals("Very Inner Fixed", schema.getField("inner_fixed").schema().getDoc());    assertEquals("Inner String", schema.getField("inner_string").doc());    assertEquals("Inner Enum", schema.getField("inner_enum").doc());    assertEquals("Very Inner Enum", schema.getField("inner_enum").schema().getDoc());    assertEquals("Inner Union", schema.getField("inner_union").doc());}
66d4d9a109d36dcd8e901d410c2b6fc04cae85b4d0285d5d64ffd66e97ed68ac
testFieldDocs
public void testFieldDocs()
{    String schemaStr = "{\"name\": \"Rec\",\"type\": \"record\",\"fields\" : [" + "{\"name\": \"f\", \"type\": \"int\", \"doc\": \"test\"}]}";        Schema schema = new Schema.Parser().parse(schemaStr);    assertEquals("test", schema.getField("f").doc());        schema = new Schema.Parser().parse(schema.toString());    assertEquals("test", schema.getField("f").doc());}
39e19b05a73bcc4dcff954eb6263d1fe1bb4edfaca633a1ad526b38ba6b3487d
testAliases
public void testAliases()
{    String t1 = "{\"type\":\"record\",\"name\":\"a.b\",\"fields\":[" + "{\"name\":\"f\",\"type\":\"long\"}," + "{\"name\":\"h\",\"type\":\"int\"}]}";    String t2 = "{\"type\":\"record\",\"name\":\"x.y\",\"aliases\":[\"a.b\"]," + "\"fields\":[{\"name\":\"g\",\"type\":\"long\",\"aliases\":[\"f\"]}," + "{\"name\":\"h\",\"type\":\"int\"}]}";    Schema s1 = new Schema.Parser().parse(t1);    Schema s2 = new Schema.Parser().parse(t2);    assertEquals(s1.getAliases(), Collections.emptySet());    assertEquals(s1.getField("f").aliases(), Collections.emptySet());    assertEquals(s2.getAliases(), Collections.singleton("a.b"));    assertEquals(s2.getField("g").aliases(), Collections.singleton("f"));    Schema s3 = Schema.applyAliases(s1, s2);    assertNotSame(s2, s3);    assertEquals(s2, s3);    t1 = "{\"type\":\"enum\",\"name\":\"a.b\"," + "\"symbols\":[\"x\"]}";    t2 = "{\"type\":\"enum\",\"name\":\"a.c\",\"aliases\":[\"b\"]," + "\"symbols\":[\"x\"]}";    s1 = new Schema.Parser().parse(t1);    s2 = new Schema.Parser().parse(t2);    s3 = Schema.applyAliases(s1, s2);    assertNotSame(s2, s3);    assertEquals(s2, s3);    t1 = "{\"type\":\"fixed\",\"name\":\"a\"," + "\"size\": 5}";    t2 = "{\"type\":\"fixed\",\"name\":\"b\",\"aliases\":[\"a\"]," + "\"size\": 5}";    s1 = new Schema.Parser().parse(t1);    s2 = new Schema.Parser().parse(t2);    s3 = Schema.applyAliases(s1, s2);    assertNotSame(s2, s3);    assertEquals(s2, s3);}
3184245fecebdbaa24ab2f34ae7a90fb6c08257faafae461f818f6b8d4fc1384
testAliasesSelfReferential
public void testAliasesSelfReferential()
{    String t1 = "{\"type\":\"record\",\"name\":\"a\",\"fields\":[{\"name\":\"f\",\"type\":{\"type\":\"record\",\"name\":\"C\",\"fields\":[{\"name\":\"c\",\"type\":{\"type\":\"array\",\"items\":[\"null\",\"C\"]}}]}}]}";    String t2 = "{\"type\":\"record\",\"name\":\"x\",\"fields\":[{\"name\":\"f\",\"type\":{\"type\":\"record\",\"name\":\"C\",\"fields\":[{\"name\":\"d\",\"type\":{\"type\":\"array\",\"items\":[\"null\",\"C\"]},\"aliases\":[\"c\"]}]}}],\"aliases\":[\"a\"]}";    Schema s1 = new Schema.Parser().parse(t1);    Schema s2 = new Schema.Parser().parse(t2);    assertEquals(s1.getAliases(), Collections.emptySet());    assertEquals(s2.getAliases(), Collections.singleton("a"));    Schema s3 = Schema.applyAliases(s1, s2);    assertNotSame(s2, s3);    assertEquals(s2, s3);}
1fb387cf38a4811bc5f4ed3dfccf14c7f435bb2c6ba4526d0ca400c7a26ece3a
check
private static void check(File dst, String schemaJson, String defaultJson, Object defaultValue) throws Exception
{    check(dst, schemaJson, defaultJson, defaultValue, true);}
eb1e4fe266a9bd84326ed5a53db2570e6373726e1d05f191511ad0cd62c6b577
check
private static void check(File dst, String schemaJson, String defaultJson, Object defaultValue, boolean induce) throws Exception
{    check(dst, schemaJson, induce);    checkDefault(schemaJson, defaultJson, defaultValue);}
b8521e150b6e4b128d9c44e56c03c6a7ba48972e5b9f8b37cc584880f23f2840
check
private static void check(File dst, String jsonSchema, boolean induce) throws Exception
{    Schema schema = new Schema.Parser().parse(jsonSchema);    checkProp(schema);    Object reuse = null;    for (Object datum : new RandomData(schema, COUNT, true)) {        if (induce) {            Schema induced = GenericData.get().induce(datum);            assertEquals("Induced schema does not match.", schema, induced);        }        assertTrue("Datum does not validate against schema " + datum, GenericData.get().validate(schema, datum));        checkBinary(schema, datum, new GenericDatumWriter<>(), new GenericDatumReader<>(), null);        reuse = checkBinary(schema, datum, new GenericDatumWriter<>(), new GenericDatumReader<>(), reuse);        checkDirectBinary(schema, datum, new GenericDatumWriter<>(), new GenericDatumReader<>());        checkBlockingBinary(schema, datum, new GenericDatumWriter<>(), new GenericDatumReader<>());        checkJson(schema, datum, new GenericDatumWriter<>(), new GenericDatumReader<>());                TestSpecificCompiler.assertCompiles(dst, schema, false);                checkBinaryJson(jsonSchema);    }}
0f92fe4e44c98fa69380d6750734f50cc2f534c988ffcb6d725a75c0daeaf810
checkProp
private static void checkProp(Schema s0) throws Exception
{    if (s0.getType().equals(Schema.Type.UNION))                return;    assertNull(s0.getProp("foo"));    Schema s1 = new Schema.Parser().parse(s0.toString());    s1.addProp("foo", "bar");    assertEquals("bar", s1.getProp("foo"));    assertNotEquals(s0, s1);    Schema s2 = new Schema.Parser().parse(s1.toString());    assertEquals("bar", s2.getProp("foo"));    assertEquals(s1, s2);    assertNotEquals(s0, s2);}
b89664631f96874d6a83b459bff232f53653c9337ef213f450e87ea86b3dd97d
checkBinary
public static void checkBinary(Schema schema, Object datum, DatumWriter<Object> writer, DatumReader<Object> reader) throws IOException
{    checkBinary(schema, datum, writer, reader, null);}
4d30085422375f43bfd6736829604b78080ea5ed2e2aee8dd72b652b32eba1f9
checkBinary
public static Object checkBinary(Schema schema, Object datum, DatumWriter<Object> writer, DatumReader<Object> reader, Object reuse) throws IOException
{    ByteArrayOutputStream out = new ByteArrayOutputStream();    writer.setSchema(schema);    Encoder encoder = EncoderFactory.get().binaryEncoder(out, null);    writer.write(datum, encoder);    encoder.flush();    byte[] data = out.toByteArray();    reader.setSchema(schema);    Object decoded = reader.read(reuse, DecoderFactory.get().binaryDecoder(data, null));    assertEquals("Decoded data does not match.", datum, decoded);    return decoded;}
9c27abd8ccf72847c5b924d944163419dac6d80387c11a9dcb4d559b990639d7
checkDirectBinary
public static void checkDirectBinary(Schema schema, Object datum, DatumWriter<Object> writer, DatumReader<Object> reader) throws IOException
{    ByteArrayOutputStream out = new ByteArrayOutputStream();    writer.setSchema(schema);    Encoder encoder = EncoderFactory.get().directBinaryEncoder(out, null);    writer.write(datum, encoder);        byte[] data = out.toByteArray();    reader.setSchema(schema);    Object decoded = reader.read(null, DecoderFactory.get().binaryDecoder(data, null));    assertEquals("Decoded data does not match.", datum, decoded);}
9f8858ffa53fa3a147a7ad4404a14e16c50197fe049b3fbffacf1708122cf5eb
checkBlockingBinary
public static void checkBlockingBinary(Schema schema, Object datum, DatumWriter<Object> writer, DatumReader<Object> reader) throws IOException
{    ByteArrayOutputStream out = new ByteArrayOutputStream();    writer.setSchema(schema);    Encoder encoder = EncoderFactory.get().blockingBinaryEncoder(out, null);    writer.write(datum, encoder);    encoder.flush();    byte[] data = out.toByteArray();    reader.setSchema(schema);    Object decoded = reader.read(null, DecoderFactory.get().binaryDecoder(data, null));    assertEquals("Decoded data does not match.", datum, decoded);}
a8c6ae28504239ae1387abaebc2e823b268daf598895a8a038779a23c2cb003f
checkJson
private static void checkJson(Schema schema, Object datum, DatumWriter<Object> writer, DatumReader<Object> reader) throws IOException
{    ByteArrayOutputStream out = new ByteArrayOutputStream();    Encoder encoder = EncoderFactory.get().jsonEncoder(schema, out);    writer.setSchema(schema);    writer.write(datum, encoder);    writer.write(datum, encoder);    encoder.flush();    byte[] data = out.toByteArray();    reader.setSchema(schema);    Decoder decoder = DecoderFactory.get().jsonDecoder(schema, new ByteArrayInputStream(data));    Object decoded = reader.read(null, decoder);    assertEquals("Decoded data does not match.", datum, decoded);    decoded = reader.read(decoded, decoder);    assertEquals("Decoded data does not match.", datum, decoded);}
f1ac0a7e4ba515ba6e14856fa4fe16cc6a2e88f74542dc5cf936835642e18b37
checkJson
private static void checkJson(Schema schema, Object datum, String json) throws Exception
{    ByteArrayOutputStream out = new ByteArrayOutputStream();    Encoder encoder = EncoderFactory.get().jsonEncoder(schema, out);    DatumWriter<Object> writer = new GenericDatumWriter<>();    writer.setSchema(schema);    writer.write(datum, encoder);    encoder.flush();    byte[] data = out.toByteArray();    String encoded = new String(data, StandardCharsets.UTF_8);    assertEquals("Encoded data does not match.", json, encoded);    DatumReader<Object> reader = new GenericDatumReader<>();    reader.setSchema(schema);    Object decoded = reader.read(null, DecoderFactory.get().jsonDecoder(schema, new ByteArrayInputStream(data)));    assertEquals("Decoded data does not match.", datum, decoded);}
99cdbc08e5dcb41c2f52cd6329943ca115f7a1177c1140aeacd8a62e99b6984f
checkBinaryJson
public static void checkBinaryJson(String json) throws Exception
{    Object node = Json.parseJson(json);    ByteArrayOutputStream out = new ByteArrayOutputStream();    DatumWriter<Object> writer = new Json.ObjectWriter();    Encoder encoder = EncoderFactory.get().binaryEncoder(out, null);    encoder = EncoderFactory.get().validatingEncoder(Json.SCHEMA, encoder);    writer.write(node, encoder);    encoder.flush();    byte[] bytes = out.toByteArray();    DatumReader<Object> reader = new Json.ObjectReader();    Decoder decoder = DecoderFactory.get().binaryDecoder(bytes, null);    decoder = DecoderFactory.get().validatingDecoder(Json.SCHEMA, decoder);    Object decoded = reader.read(null, decoder);    assertEquals("Decoded json does not match.", Json.toString(node), Json.toString(decoded));}
b2c01c48b94262d41b1b38b5be8ccc8c985c04db69951dd015e9bb42d66d2aa4
checkDefault
private static void checkDefault(String schemaJson, String defaultJson, Object defaultValue) throws Exception
{    String recordJson = "{\"type\":\"record\", \"name\":\"Foo\", \"fields\":[{\"name\":\"f\", " + "\"type\":" + schemaJson + ", " + "\"default\":" + defaultJson + "}]}";    Schema expected = new Schema.Parser().parse(recordJson);    DatumReader<Object> in = new GenericDatumReader<>(ACTUAL, expected);    GenericData.Record record = (GenericData.Record) in.read(null, DecoderFactory.get().binaryDecoder(new byte[0], null));    assertEquals("Wrong default.", defaultValue, record.get("f"));    assertEquals("Wrong toString", expected, new Schema.Parser().parse(expected.toString()));}
392cc93fbc8c2ab25cefa39ae914907e5acb25abacc350ea46b43ea720f902f4
checkValidateDefaults
private static void checkValidateDefaults(String schemaJson, String defaultJson)
{    try {        Schema.Parser parser = new Schema.Parser();        String recordJson = "{\"type\":\"record\", \"name\":\"Foo\", \"fields\":[{\"name\":\"f\", " + "\"type\":" + schemaJson + ", " + "\"default\":" + defaultJson + "}]}";        parser.parse(recordJson);        fail("Schema of type " + schemaJson + " should not have default " + defaultJson);    } catch (AvroTypeException ignored) {    }}
a22e351413c21e0d0a8911267bdc9d7899ce15acb8ceaf43a0861e55a784517e
testNoDefaultField
public void testNoDefaultField() throws Exception
{    Schema expected = new Schema.Parser().parse("{\"type\":\"record\", \"name\":\"Foo\", \"fields\":" + "[{\"name\":\"f\", \"type\": \"string\"}]}");    DatumReader<Object> in = new GenericDatumReader<>(ACTUAL, expected);    in.read(null, DecoderFactory.get().binaryDecoder(new ByteArrayInputStream(new byte[0]), null));}
12b9080e62d782922e65dd45d92fc2066a110cc05f9f50ee74f659aaf9525630
testEnumMismatch
public void testEnumMismatch() throws Exception
{    Schema actual = new Schema.Parser().parse("{\"type\":\"enum\",\"name\":\"E\",\"symbols\":[\"X\",\"Y\"]}");    Schema expected = new Schema.Parser().parse("{\"type\":\"enum\",\"name\":\"E\",\"symbols\":[\"Y\",\"Z\"]}");    ByteArrayOutputStream out = new ByteArrayOutputStream();    DatumWriter<Object> writer = new GenericDatumWriter<>(actual);    Encoder encoder = EncoderFactory.get().directBinaryEncoder(out, null);    writer.write(new GenericData.EnumSymbol(actual, "Y"), encoder);    writer.write(new GenericData.EnumSymbol(actual, "X"), encoder);    encoder.flush();    byte[] data = out.toByteArray();    Decoder decoder = DecoderFactory.get().binaryDecoder(data, null);    DatumReader<String> in = new GenericDatumReader<>(actual, expected);    assertEquals("Wrong value", new GenericData.EnumSymbol(expected, "Y"), in.read(null, decoder));    try {        in.read(null, decoder);        fail("Should have thrown exception.");    } catch (AvroTypeException e) {        }}
76473d4c54f5ed26a687711d4494439923488f0e6c95dddb4cf71a41d9581363
testRecordWithPrimitiveName
public void testRecordWithPrimitiveName()
{    new Schema.Parser().parse("{\"type\":\"record\", \"name\":\"string\", \"fields\": []}");}
85b1be66e6bcd53e65b18631944612f140e0bfaf61458104a4c1cd064567f0bf
testEnumWithPrimitiveName
public void testEnumWithPrimitiveName()
{    new Schema.Parser().parse("{\"type\":\"enum\", \"name\":\"null\", \"symbols\": [\"A\"]}");}
10de3a839a6a678aae59c479aab737401370dd29884db08edfa28534f27ab711
enumSchema
private static Schema enumSchema()
{    return new Schema.Parser().parse("{ \"type\": \"enum\", \"name\": \"e\", " + "\"symbols\": [\"a\", \"b\"]}");}
1b294354e560e0e9c5b5581adc188a510fc115718600b1ac62243a8ac4f4e10a
testImmutability1
public void testImmutability1()
{    Schema s = enumSchema();    s.addProp("p1", "1");    s.addProp("p1", "2");}
4f9ae058ad79b019ffc8b7e8d89568578c5309d2fe4ce8a0b47833b5c69acb93
testImmutability2
public void testImmutability2()
{    Schema s = enumSchema();    s.addProp("p1", null);}
08db41befa8037c254a43a3b4354d0442f66ac606d66431f857beb3514671716
lockedArrayList
private static List<String> lockedArrayList()
{    return new Schema.LockableArrayList<>(Arrays.asList("a", "b", "c")).lock();}
57b92577b12d78768fae1726431bead28c3c6795adac496c29d4939d9177c656
testLockedArrayList1
public void testLockedArrayList1()
{    lockedArrayList().add("p");}
cb272a67960b001cd141d169e60be76af7696a462b7b2831f4b10cbe2f11eac7
testLockedArrayList2
public void testLockedArrayList2()
{    lockedArrayList().remove("a");}
cc5874eb6a77e36e1871b2ea2c2ecd9ed4018b188a2372b5faa9c221d812ad6d
testLockedArrayList3
public void testLockedArrayList3()
{    lockedArrayList().addAll(Collections.singletonList("p"));}
9b3d195e9d6c57b031233d0cbd7495ae622f3721776031cbb6d3c8c43c61034f
testLockedArrayList4
public void testLockedArrayList4()
{    lockedArrayList().addAll(0, Collections.singletonList("p"));}
c89d6adf01ddf77fc52474e363cfe943ba5871bbc7fe1733d6d91ba3b4987ab2
testLockedArrayList5
public void testLockedArrayList5()
{    lockedArrayList().removeAll(Collections.singletonList("a"));}
51702bda8d03541727bc136d582a6f90c00032f8c4f7f534809553fa09459eaf
testLockedArrayList6
public void testLockedArrayList6()
{    lockedArrayList().retainAll(Collections.singletonList("a"));}
8e0aa3752eeb5cd9e942a64c537a56f6ac75c81e111f5ad6d286185774002f4c
testLockedArrayList7
public void testLockedArrayList7()
{    lockedArrayList().clear();}
45e35163f68983c6d9cfc7f0118adfefbb22d8145d1523627855cc0c3b82cfe7
testLockedArrayList8
public void testLockedArrayList8()
{    lockedArrayList().iterator().remove();}
94454144a649eedb9c67d0905f63c8e8325ff4397f70b4c9e8f1aa3fd99bcc38
testLockedArrayList9
public void testLockedArrayList9()
{    Iterator<String> it = lockedArrayList().iterator();    it.next();    it.remove();}
afc0b07295ffa59c82b8c00462960a08252a6b9cbe1cbd173d1a9e0173b95d24
testLockedArrayList10
public void testLockedArrayList10()
{    lockedArrayList().remove(1);}
daf2b4362bca5a061c808e257b9895aa06f962ebfa33de2ee3e1612f538aae67
testNames_GetWithInheritedNamespace
public void testNames_GetWithInheritedNamespace()
{    Schema schema = Schema.create(Type.STRING);    Schema.Names names = new Schema.Names("space");    names.put(new Schema.Name("Name", "space"), schema);    assertEquals(schema, names.get(new Schema.Name("Name", "space")));    assertEquals(schema, names.get("Name"));}
d38ed9e2d5bab0883ec1cc714cfbf5603735baee903d49618b1a2cf5b549fb76
testNames_GetWithNullNamespace
public void testNames_GetWithNullNamespace()
{    Schema schema = Schema.create(Type.STRING);    Schema.Names names = new Schema.Names("space");    names.put(new Schema.Name("Name", ""), schema);    assertEquals(schema, names.get(new Schema.Name("Name", "")));    assertEquals(schema, names.get("Name"));}
4db128a996b94291db3d1de664d437265df000e4763df1122ca4f5de9fbbd1a2
testNames_GetNotFound
public void testNames_GetNotFound()
{    Schema.Names names = new Schema.Names("space");    names.put(new Schema.Name("Name", "otherspace"), Schema.create(Type.STRING));    assertNull(names.get("Name"));}
a74c937addaf854cc46e7c51227fb5c0232187cc39cb7a062b714c69693ac42c
addConnector
public void addConnector(Connector connector)
{    server.addConnector(connector);}
eedb587f68470407e820d49bf6bb9be573d78555382d32a0743e8fea8ced15d6
getPort
public int getPort()
{    return ((ServerConnector) server.getConnectors()[0]).getLocalPort();}
5df6118bc0e745d8b18e0a6a99b2e3f2ddba8140cbeb1423ce2df50a9f140574
close
public void close()
{    try {        server.stop();    } catch (Exception e) {        throw new AvroRuntimeException(e);    }}
fe470100a468aa20bc462dab09f768d6e2ce225f184a550d87d7243e3d0f5667
start
public void start()
{    try {        server.start();    } catch (Exception e) {        throw new AvroRuntimeException(e);    }}
297bf729764d09cd4f41f34d36692cfb5bb2f8beb881a5ceb1af47a65563da7a
join
public void join() throws InterruptedException
{    server.join();}
dd92329ea00da47ad7605fa5ae23ceaaab96e3b45eb99d748b9903063b49a380
getResource
public Resource getResource(String pathInContext)
{            String[] parts = pathInContext.split("/");    String filename = parts[parts.length - 1];    URL resource = getClass().getClassLoader().getResource("org/apache/avro/ipc/stats/static/" + filename);    if (resource == null) {        return null;    }    return Resource.newResource(resource);}
58a3bb0fa8ecc3e0a1306beb26f516223d2bf3d47efcbf1262a44af030c64a22
stop
public void stop() throws Exception
{    this.httpServer.stop();}
29d68ea2271f298d01258b511c540f1756974c3e264f466c06a5e849f796bce4
respond
public Object respond(Message message, Object request) throws AvroRemoteException
{    return request;}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    double with = sendRpcs(true) / 1000000000.0;    double without = sendRpcs(false) / 1000000000.0;    System.out.println(String.format("Overhead: %f%%.  RPC/s: %f (with) vs %f (without).  " + "RPC time (ms): %f vs %f", 100 * (with - without) / (without), COUNT / with, COUNT / without, 1000 * with / COUNT, 1000 * without / COUNT));}
04ca9dde1c5961469db016232ce66fb7db7a18611b9b1f4615fbcd6c5a796abd
sendRpcs
private static long sendRpcs(boolean withPlugin) throws Exception
{    HttpServer server = createServer(withPlugin);    Transceiver t = new HttpTransceiver(new URL("http://127.0.0.1:" + server.getPort() + "/"));    GenericRequestor requestor = new GenericRequestor(NULL_PROTOCOL, t);    long now = System.nanoTime();    for (int i = 0; i < COUNT; ++i) {        requestor.request("null", null);    }    long elapsed = System.nanoTime() - now;    t.close();    server.close();    return elapsed;}
9a496c8e46ac52d462ee7e5f9c5600f451115fe640503ae3fb8903d391183736
createServer
private static HttpServer createServer(boolean withPlugin) throws IOException
{    Responder r = new IdentityResponder(NULL_PROTOCOL);    if (withPlugin) {        r.addRPCPlugin(new StatsPlugin());    }        HttpServer server = new HttpServer(r, 0);    server.start();    return server;}
5b1a95da9cd63843d217dbd3ba44ba763073f2a24d4a28ce75e520d24cbab82e
read
public ByteBuffer read()
{    return DATA.duplicate();}
6adcd8f3bf1b6ee698b0e95a8818949de5767cbc304b6c7654d36ca534d2ca09
write
public void write(ByteBuffer data)
{    Assert.assertEquals(SIZE, data.remaining());}
90dff5193214a882a35471dadd59ef03862bf46bd6086560dc9800bae0bc371e
startServer
public void startServer() throws Exception
{    if (server != null)        return;    server = new HttpServer(new SpecificResponder(BulkData.class, new BulkDataImpl()), 0);    server.start();    Transceiver client = new HttpTransceiver(new URL("http://127.0.0.1:" + server.getPort() + "/"));    proxy = SpecificRequestor.getClient(BulkData.class, client);}
767dbe978d8c4fc5b320d7c3421d54216c421ab70b70c93a7c0410ee0757a269
testRead
public void testRead() throws IOException
{    for (int i = 0; i < COUNT; i++) Assert.assertEquals(SIZE, proxy.read().remaining());}
a0d21f2da4a70f218d0e18876357fddaa83563d59cf205a7eb7099c9803c11d4
testWrite
public void testWrite() throws IOException
{    for (int i = 0; i < COUNT; i++) proxy.write(DATA.duplicate());}
9a2f5caa4fb10f889996f83f1387d1c624fb0bd960f26b175ca2947a5f1debae
stopServer
public static void stopServer() throws Exception
{    server.close();}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    TestBulkData test = new TestBulkData();    test.startServer();    System.out.println("READ");    long start = System.currentTimeMillis();    test.testRead();    printStats(start);    System.out.println("WRITE");    start = System.currentTimeMillis();    test.testWrite();    printStats(start);    test.stopServer();}
7ab202e76e9e43766d3e86366e9ec42c75c62cf8d1457029969337cbd7531172
printStats
private static void printStats(long start)
{    double seconds = (System.currentTimeMillis() - start) / 1000.0;    System.out.println("seconds = " + (int) seconds);    System.out.println("requests/second = " + (int) (COUNT / seconds));    double megabytes = (COUNT * SIZE) / (1024 * 1024.0);    System.out.println("MB = " + (int) megabytes);    System.out.println("MB/second = " + (int) (megabytes / seconds));}
d2c969c3d001f4cb8ee4faf386f2b39208dd1de1af42947372b3ba149b948da2
createServer
public Server createServer(Responder testResponder) throws Exception
{    return new HttpServer(testResponder, 0);}
b723b1ec8e0ad25b5fa0c50c217e5a3f9380f12f0fa602f368cec8d7c19fdad2
createTransceiver
public Transceiver createTransceiver() throws Exception
{    return new HttpTransceiver(new URL("http://127.0.0.1:" + server.getPort() + "/"));}
38f6f275e4665b7bc5553d8f196e583a98d4b5bc53049915ab8fab55edcd57e7
getExpectedHandshakeCount
protected int getExpectedHandshakeCount()
{    return REPEATING;}
11b8a0794b5679b30570f1d2473b359dcff1a4fe5b8d715d01ef99e44905caa3
testTimeout
public void testTimeout() throws Throwable
{    ServerSocket s = new ServerSocket(0);    HttpTransceiver client = new HttpTransceiver(new URL("http://127.0.0.1:" + s.getLocalPort() + "/"));    client.setTimeout(100);    Simple proxy = SpecificRequestor.getClient(Simple.class, client);    try {        proxy.hello("foo");        fail("Should have failed with an exception");    } catch (AvroRuntimeException e) {        assertTrue("Got unwanted exception: " + e.getCause(), e.getCause() instanceof SocketTimeoutException);    } finally {        s.close();    }}
e0d1b1b1551900e93586bd06692b789657d8e7d2000f9876dd5e64c6a7180481
testStatelessOneway
public void testStatelessOneway() throws Exception
{        Protocol protocol = new Protocol("Simple", "org.apache.avro.test");    Protocol.Message message = protocol.createMessage("ack", null, new LinkedHashMap<String, String>(), Schema.createRecord(new ArrayList<>()), Schema.create(Schema.Type.NULL), Schema.createUnion(new ArrayList<>()));    protocol.getMessages().put("ack", message);        GenericRequestor requestor = new GenericRequestor(protocol, createTransceiver());    requestor.request("ack", new GenericData.Record(message.getRequest()));        requestor.request("ack", new GenericData.Record(message.getRequest()));}
d2c969c3d001f4cb8ee4faf386f2b39208dd1de1af42947372b3ba149b948da2
createServer
public Server createServer(Responder testResponder) throws Exception
{    System.setProperty("javax.net.ssl.keyStore", "src/test/keystore");    System.setProperty("javax.net.ssl.keyStorePassword", "avrotest");    System.setProperty("javax.net.ssl.password", "avrotest");    System.setProperty("javax.net.ssl.trustStore", "src/test/truststore");    System.setProperty("javax.net.ssl.trustStorePassword", "avrotest");    SslConnectionFactory connectionFactory = new SslConnectionFactory("HTTP/1.1");    SslContextFactory sslContextFactory = connectionFactory.getSslContextFactory();    sslContextFactory.setKeyStorePath(System.getProperty("javax.net.ssl.keyStore"));    sslContextFactory.setKeyManagerPassword(System.getProperty("javax.net.ssl.password"));    sslContextFactory.setKeyStorePassword(System.getProperty("javax.net.ssl.keyStorePassword"));    sslContextFactory.setNeedClientAuth(false);    return new HttpServer(testResponder, connectionFactory, "localhost", 18443);}
b723b1ec8e0ad25b5fa0c50c217e5a3f9380f12f0fa602f368cec8d7c19fdad2
createTransceiver
public Transceiver createTransceiver() throws Exception
{    return new HttpTransceiver(new URL("https://localhost:" + server.getPort() + "/"));}
38f6f275e4665b7bc5553d8f196e583a98d4b5bc53049915ab8fab55edcd57e7
getExpectedHandshakeCount
protected int getExpectedHandshakeCount()
{    return REPEATING;}
2fd9aab3dda9289c93727e9525d19a7db6f21cad59d113d3a1328cb1463fa388
generateServletResponse
private String generateServletResponse(StatsPlugin statsPlugin) throws IOException
{    StatsServlet servlet;    try {        servlet = new StatsServlet(statsPlugin);    } catch (UnavailableException e1) {        throw new IOException();    }    StringWriter w = new StringWriter();    try {        servlet.writeStats(w);    } catch (Exception e) {        e.printStackTrace();    }    String o = w.toString();    return o;}
29d68ea2271f298d01258b511c540f1756974c3e264f466c06a5e849f796bce4
respond
public Object respond(Message message, Object request) throws AvroRemoteException
{    assertEquals(0, ((GenericRecord) request).get("x"));    return 1;}
ddef3fc43f3cac28e08232711a64c9c0178c90d875596b3558c7dd0b2cf13274
makeRequest
private void makeRequest(Transceiver t) throws Exception
{    GenericRecord params = new GenericData.Record(protocol.getMessages().get("m").getRequest());    params.put("x", 0);    GenericRequestor r = new GenericRequestor(protocol, t);    assertEquals(1, r.request("m", params));}
2e02f148186c5fc358d99f733c8a40614a6957c773dfa58ae727de1a2d6cbaba
testFullServerPath
public void testFullServerPath() throws Exception
{    Responder r = new TestResponder(protocol);    StatsPlugin statsPlugin = new StatsPlugin();    r.addRPCPlugin(statsPlugin);    Transceiver t = new LocalTransceiver(r);    for (int i = 0; i < 10; ++i) {        makeRequest(t);    }    String o = generateServletResponse(statsPlugin);    assertTrue(o.contains("10 calls"));}
5688f0efd4fbc20646bf4327424ea3ee7168e1a2c6893d17e0ec4948b31d7a3b
testMultipleRPCs
public void testMultipleRPCs() throws IOException
{    org.apache.avro.ipc.stats.FakeTicks t = new org.apache.avro.ipc.stats.FakeTicks();    StatsPlugin statsPlugin = new StatsPlugin(t, StatsPlugin.LATENCY_SEGMENTER, StatsPlugin.PAYLOAD_SEGMENTER);    RPCContext context1 = makeContext();    RPCContext context2 = makeContext();    statsPlugin.serverReceiveRequest(context1);        t.passTime(100 * MS);    statsPlugin.serverReceiveRequest(context2);    String r = generateServletResponse(statsPlugin);        assertTrue(r.contains("m: 0ms"));    assertTrue(r.contains("m: 100ms"));    statsPlugin.serverSendResponse(context1);        t.passTime(900 * MS);    statsPlugin.serverSendResponse(context2);    r = generateServletResponse(statsPlugin);    assertTrue(r.contains("Average: 500.0ms"));}
eb6f1c8759c430d5e54cf536a07b587c61d24d382bedb0521a23413e7d1be61a
testPayloadSize
public void testPayloadSize() throws Exception
{    Responder r = new TestResponder(protocol);    StatsPlugin statsPlugin = new StatsPlugin();    r.addRPCPlugin(statsPlugin);    Transceiver t = new LocalTransceiver(r);    makeRequest(t);    String resp = generateServletResponse(statsPlugin);    assertTrue(resp.contains("Average: 2.0"));}
5ff1e8375616f302b652668fd5d219ad4b4595f9df2dbbcfd087ced8509b83aa
makeContext
private RPCContext makeContext()
{    RPCContext context = new RPCContext();    context.setMessage(message);    return context;}
29d68ea2271f298d01258b511c540f1756974c3e264f466c06a5e849f796bce4
respond
public Object respond(Message message, Object request) throws AvroRemoteException
{    try {        Thread.sleep((Long) ((GenericRecord) request).get("millis"));    } catch (InterruptedException e) {        throw new AvroRemoteException(e);    }    return null;}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    if (args.length == 0) {        args = new String[] { "7002", "7003" };    }    Protocol protocol = Protocol.parse("{\"protocol\": \"sleepy\", " + "\"messages\": { \"sleep\": {" + "   \"request\": [{\"name\": \"millis\", \"type\": \"long\"}," + "{\"name\": \"data\", \"type\": \"bytes\"}], " + "   \"response\": \"null\"} } }");    Responder r = new SleepyResponder(protocol);    StatsPlugin p = new StatsPlugin();    r.addRPCPlugin(p);        HttpServer avroServer = new HttpServer(r, Integer.parseInt(args[0]));    avroServer.start();    StatsServer ss = new StatsServer(p, 8080);    HttpTransceiver trans = new HttpTransceiver(new URL("http://localhost:" + Integer.parseInt(args[0])));    GenericRequestor req = new GenericRequestor(protocol, trans);    while (true) {        Thread.sleep(1000);        GenericRecord params = new GenericData.Record(protocol.getMessages().get("sleep").getRequest());        Random rand = new Random();        params.put("millis", Math.abs(rand.nextLong()) % 1000);        int payloadSize = Math.abs(rand.nextInt()) % 10000;        byte[] payload = new byte[payloadSize];        rand.nextBytes(payload);        params.put("data", ByteBuffer.wrap(payload));        req.request("sleep", params);    }}
fe470100a468aa20bc462dab09f768d6e2ce225f184a550d87d7243e3d0f5667
start
public void start()
{}
5df6118bc0e745d8b18e0a6a99b2e3f2ddba8140cbeb1423ce2df50a9f140574
close
public void close()
{    ChannelGroupFuture future = allChannels.close();    future.awaitUninterruptibly();    channelFactory.releaseExternalResources();    closed.countDown();}
eedb587f68470407e820d49bf6bb9be573d78555382d32a0743e8fea8ced15d6
getPort
public int getPort()
{    return ((InetSocketAddress) serverChannel.getLocalAddress()).getPort();}
297bf729764d09cd4f41f34d36692cfb5bb2f8beb881a5ceb1af47a65563da7a
join
public void join() throws InterruptedException
{    closed.await();}
0428fd62ea809896ccb590d44fba12a706db3ec35ba4842cb773162827d883f6
getNumActiveConnections
public int getNumActiveConnections()
{        return allChannels.size() - 1;}
d7413d793f7215cc67b6e909e373d27c14eed0efdaf1634640bb857be70a8bc1
handleUpstream
public void handleUpstream(ChannelHandlerContext ctx, ChannelEvent e) throws Exception
{    if (e instanceof ChannelStateEvent) {        LOG.info(e.toString());    }    super.handleUpstream(ctx, e);}
98786538894d72e6bd019cc49c42a9087e6ddf125866bf26563f978ce39ab0e0
channelOpen
public void channelOpen(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception
{    allChannels.add(e.getChannel());    super.channelOpen(ctx, e);}
f6655f683c8da94d7477aa66c4101e7fac91a67b19c16f716b821abe34318cce
messageReceived
public void messageReceived(ChannelHandlerContext ctx, MessageEvent e)
{    try {        NettyDataPack dataPack = (NettyDataPack) e.getMessage();        List<ByteBuffer> req = dataPack.getDatas();        List<ByteBuffer> res = responder.respond(req, connectionMetadata);                if (res != null) {            dataPack.setDatas(res);            e.getChannel().write(dataPack);        }    } catch (IOException ex) {        LOG.warn("unexpected error");    }}
c4c9f74c3c6d4afc667f87dd02c265c06a929ba39d044c1b28669f2d7ad0910d
exceptionCaught
public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e)
{    LOG.warn("Unexpected exception from downstream.", e.getCause());    e.getChannel().close();    allChannels.remove(e.getChannel());}
bf958ef8f67b566077fd273dba369ff1782ca1b8edc1855f7f85a18add42f97d
channelClosed
public void channelClosed(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception
{    LOG.info("Connection to {} disconnected.", e.getChannel().getRemoteAddress());    super.channelClosed(ctx, e);    e.getChannel().close();    allChannels.remove(e.getChannel());}
51e585dab9a6aa1dbd659f2d58a780b5db6a0def1aecad3098b409e1b2e0776b
createNettyClientAvroHandler
protected ChannelUpstreamHandler createNettyClientAvroHandler()
{    return new NettyClientAvroHandler();}
e70668a3746c2a61173d2e2d3a54a7502c83782031e18cef0c518c23e54761e1
buildDefaultBootstrapOptions
protected static Map<String, Object> buildDefaultBootstrapOptions(Long connectTimeoutMillis)
{    Map<String, Object> options = new HashMap<>(3);    options.put(NETTY_TCP_NODELAY_OPTION, DEFAULT_TCP_NODELAY_VALUE);    options.put(NETTY_KEEPALIVE_OPTION, true);    options.put(NETTY_CONNECT_TIMEOUT_OPTION, connectTimeoutMillis == null ? DEFAULT_CONNECTION_TIMEOUT_MILLIS : connectTimeoutMillis);    return options;}
e77eed2c6df4fcaa3ffadb4c52e7bb87419642f763b45b9d935d3e031d3c1fa6
isChannelReady
private static boolean isChannelReady(Channel channel)
{    return (channel != null) && channel.isOpen() && channel.isBound() && channel.isConnected();}
e49d9e4eee280c8bc30886f899e20e6c45b1e32b2372637047fb49bbc60a35b6
getChannel
private Channel getChannel() throws IOException
{    if (!isChannelReady(channel)) {                        stateLock.readLock().unlock();        stateLock.writeLock().lock();        try {            if (!isChannelReady(channel)) {                synchronized (channelFutureLock) {                    if (!stopping) {                        LOG.debug("Connecting to " + remoteAddr);                        channelFuture = bootstrap.connect(remoteAddr);                    }                }                if (channelFuture != null) {                    try {                        channelFuture.await(connectTimeoutMillis);                    } catch (InterruptedException e) {                                                Thread.currentThread().interrupt();                        throw new IOException("Interrupted while connecting to " + remoteAddr);                    }                    synchronized (channelFutureLock) {                        if (!channelFuture.isSuccess()) {                            throw new IOException("Error connecting to " + remoteAddr, channelFuture.getCause());                        }                        channel = channelFuture.getChannel();                        channelFuture = null;                    }                }            }        } finally {                        stateLock.readLock().lock();            stateLock.writeLock().unlock();        }    }    return channel;}
e1a1d47f8f2cd86311c11ec2501a3e5aba7c0d9a03737c2bbf514fb255baebaa
disconnect
private void disconnect()
{    disconnect(false, false, null);}
8efd1f36a9223c0a684b89acf1f58915463aff1c6fcdf5fb18c6b0ef2d8b5c1d
disconnect
private void disconnect(boolean awaitCompletion, boolean cancelPendingRequests, Throwable cause)
{    Channel channelToClose = null;    Map<Integer, Callback<List<ByteBuffer>>> requestsToCancel = null;    boolean stateReadLockHeld = stateLock.getReadHoldCount() != 0;    ChannelFuture channelFutureToCancel = null;    synchronized (channelFutureLock) {        if (stopping && channelFuture != null) {            channelFutureToCancel = channelFuture;            channelFuture = null;        }    }    if (channelFutureToCancel != null) {        channelFutureToCancel.cancel();    }    if (stateReadLockHeld) {        stateLock.readLock().unlock();    }    stateLock.writeLock().lock();    try {        if (channel != null) {            if (cause != null) {                LOG.debug("Disconnecting from " + remoteAddr, cause);            } else {                LOG.debug("Disconnecting from " + remoteAddr);            }            channelToClose = channel;            channel = null;            remote = null;            if (cancelPendingRequests) {                                                requestsToCancel = new ConcurrentHashMap<>(requests);                requests.clear();            }        }    } finally {        if (stateReadLockHeld) {            stateLock.readLock().lock();        }        stateLock.writeLock().unlock();    }        if ((requestsToCancel != null) && !requestsToCancel.isEmpty()) {        LOG.debug("Removing " + requestsToCancel.size() + " pending request(s).");        for (Callback<List<ByteBuffer>> request : requestsToCancel.values()) {            request.handleError(cause != null ? cause : new IOException(getClass().getSimpleName() + " closed"));        }    }        if (channelToClose != null) {        ChannelFuture closeFuture = channelToClose.close();        if (awaitCompletion && (closeFuture != null)) {            try {                closeFuture.await(connectTimeoutMillis);            } catch (InterruptedException e) {                                Thread.currentThread().interrupt();                LOG.warn("Interrupted while disconnecting", e);            }        }    }}
f2a967c1674261f748af83ed2c160fd554943b290544c7488e35d26b313fab86
lockChannel
public void lockChannel()
{}
6f1a1f017d3834ee5d55731778f7c000c9aa42d9390b4a2da9f41a907a725e47
unlockChannel
public void unlockChannel()
{}
5df6118bc0e745d8b18e0a6a99b2e3f2ddba8140cbeb1423ce2df50a9f140574
close
public void close()
{    close(true);}
51bb36f0fb99acba21582d21062f81c4d1d46d521622378359c9ceeffe136f73
close
public void close(boolean awaitCompletion)
{    try {                stopping = true;        disconnect(awaitCompletion, true, null);    } finally {                channelFactory.releaseExternalResources();    }}
f53fe91764dbe05aabc593d6888e316fe2942e2d131dcd64c36d30ba7def4ddf
getRemoteName
public String getRemoteName() throws IOException
{    stateLock.readLock().lock();    try {        return getChannel().getRemoteAddress().toString();    } finally {        stateLock.readLock().unlock();    }}
f29f455f544a014333b5e52d94d0152fe4836453e7e9bc43c486c29d10db39ab
transceive
public List<ByteBuffer> transceive(List<ByteBuffer> request) throws IOException
{    try {        CallFuture<List<ByteBuffer>> transceiverFuture = new CallFuture<>();        transceive(request, transceiverFuture);        return transceiverFuture.get();    } catch (InterruptedException | ExecutionException e) {        LOG.debug("failed to get the response", e);        return null;    }}
60dfff4994d627a2e1774b2793f26971ec7953a0972bb77271a1378ea772529c
transceive
public void transceive(List<ByteBuffer> request, Callback<List<ByteBuffer>> callback) throws IOException
{    stateLock.readLock().lock();    try {        int serial = serialGenerator.incrementAndGet();        NettyDataPack dataPack = new NettyDataPack(serial, request);        requests.put(serial, callback);        writeDataPack(dataPack);    } finally {        stateLock.readLock().unlock();    }}
d2039ee4a63e50f584a154d5a9d9e91539d85c3e5dadbbc9ba49b5cb1bd1eadb
writeBuffers
public void writeBuffers(List<ByteBuffer> buffers) throws IOException
{    ChannelFuture writeFuture;    stateLock.readLock().lock();    try {        writeFuture = writeDataPack(new NettyDataPack(serialGenerator.incrementAndGet(), buffers));    } finally {        stateLock.readLock().unlock();    }    if (!writeFuture.isDone()) {        try {            writeFuture.await();        } catch (InterruptedException e) {                        Thread.currentThread().interrupt();            throw new IOException("Interrupted while writing Netty data pack", e);        }    }    if (!writeFuture.isSuccess()) {        throw new IOException("Error writing buffers", writeFuture.getCause());    }}
e4af1637ada5281ea2ceb44133c8bc3aced82f2220c15d9e2255b2cc62283364
writeDataPack
private ChannelFuture writeDataPack(NettyDataPack dataPack) throws IOException
{    return getChannel().write(dataPack);}
89c18d8119bb8e23a979cc72feb30546e4ca979755f432bbc62f745e41a4b271
readBuffers
public List<ByteBuffer> readBuffers() throws IOException
{    throw new UnsupportedOperationException();}
211112435fc9aad0c85f999abf759f93ba0c11c2cc8f361d136bde6e5d96d6ee
getRemote
public Protocol getRemote()
{    stateLock.readLock().lock();    try {        return remote;    } finally {        stateLock.readLock().unlock();    }}
d281b583c7876c25d7ad9fa27ea2d785aca24efb5315460c0e085a5cb6230e07
isConnected
public boolean isConnected()
{    stateLock.readLock().lock();    try {        return remote != null;    } finally {        stateLock.readLock().unlock();    }}
bd73d43970ff6893cf230d0ad5a84e57b8b0b930bcdb11b3ddbc1f3ca652f1f7
setRemote
public void setRemote(Protocol protocol)
{    stateLock.writeLock().lock();    try {        this.remote = protocol;    } finally {        stateLock.writeLock().unlock();    }}
6599203e79a86bb7db69cbac696e1ee06390c9dd2cc876398911eae0de6c9afd
operationComplete
public void operationComplete(ChannelFuture future) throws Exception
{    if (!future.isSuccess() && (callback != null)) {        callback.handleError(new IOException("Error writing buffers", future.getCause()));    }}
d7413d793f7215cc67b6e909e373d27c14eed0efdaf1634640bb857be70a8bc1
handleUpstream
public void handleUpstream(ChannelHandlerContext ctx, ChannelEvent e) throws Exception
{    if (e instanceof ChannelStateEvent) {        LOG.debug(e.toString());        ChannelStateEvent cse = (ChannelStateEvent) e;        if ((cse.getState() == ChannelState.OPEN) && (Boolean.FALSE.equals(cse.getValue()))) {                        LOG.debug("Remote peer " + remoteAddr + " closed connection.");            disconnect(false, true, null);        }    }    super.handleUpstream(ctx, e);}
98786538894d72e6bd019cc49c42a9087e6ddf125866bf26563f978ce39ab0e0
channelOpen
public void channelOpen(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception
{        super.channelOpen(ctx, e);}
e90e7074a112666652c54b79a6e14942d907d0149fd5ff655da10a91b0784f44
messageReceived
public void messageReceived(ChannelHandlerContext ctx, final MessageEvent e)
{    NettyDataPack dataPack = (NettyDataPack) e.getMessage();    Callback<List<ByteBuffer>> callback = requests.get(dataPack.getSerial());    if (callback == null) {        throw new RuntimeException("Missing previous call info");    }    try {        callback.handleResult(dataPack.getDatas());    } finally {        requests.remove(dataPack.getSerial());    }}
c4c9f74c3c6d4afc667f87dd02c265c06a929ba39d044c1b28669f2d7ad0910d
exceptionCaught
public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e)
{    disconnect(false, true, e.getCause());}
02166686c9ffef8abcca97b0bc3e38cb95c97860d78686958b46127a2ecadb18
newThread
public Thread newThread(Runnable r)
{    Thread thread = new Thread(r);    thread.setName(prefix + " " + threadId.incrementAndGet());    return thread;}
8334e8c1ca53a5f94087f63f707edc0b0ccb212446cc676ef3f7adb892fe775d
setSerial
public void setSerial(int serial)
{    this.serial = serial;}
878f16c26fcfd63875a9098de55cbfa56f7e911c6c5e1a0ccfc0a1b94b9e23d7
getSerial
public int getSerial()
{    return serial;}
6f1eedf18c2f730bf666cbd0f0fab2771fcffd84da915a9d2e5d2429f78f8cd0
setDatas
public void setDatas(List<ByteBuffer> datas)
{    this.datas = datas;}
530e551cccfe72dc81b6817077d03af93c19d4242402e3e4ec537d947b35b2db
getDatas
public List<ByteBuffer> getDatas()
{    return datas;}
2a103db4fbdfc6ed8057e2126c84b9a694813caca73a2506adf63cb761db0ee4
encode
protected Object encode(ChannelHandlerContext ctx, Channel channel, Object msg) throws Exception
{    NettyDataPack dataPack = (NettyDataPack) msg;    List<ByteBuffer> origs = dataPack.getDatas();    List<ByteBuffer> bbs = new ArrayList<>(origs.size() * 2 + 1);        bbs.add(getPackHeader(dataPack));    for (ByteBuffer b : origs) {                bbs.add(getLengthHeader(b));        bbs.add(b);    }    return ChannelBuffers.wrappedBuffer(bbs.toArray(new ByteBuffer[0]));}
d51570a6520b6bdace85f8561f988b944e357d28af5aada1fc72b882c72e9053
getPackHeader
private ByteBuffer getPackHeader(NettyDataPack dataPack)
{    ByteBuffer header = ByteBuffer.allocate(8);    header.putInt(dataPack.getSerial());    header.putInt(dataPack.getDatas().size());    header.flip();    return header;}
41a61e5f2762ad64a32c66167330be4680a11d0ec43b347752076f7e380b5f7f
getLengthHeader
private ByteBuffer getLengthHeader(ByteBuffer buf)
{    ByteBuffer header = ByteBuffer.allocate(4);    header.putInt(buf.limit());    header.flip();    return header;}
0f21feab278f2a98920f1dddf2222cd18aa390d003cee08f68ee4ef68f209a23
decode
protected Object decode(ChannelHandlerContext ctx, Channel channel, ChannelBuffer buffer) throws Exception
{    if (!packHeaderRead) {        if (decodePackHeader(ctx, channel, buffer)) {            packHeaderRead = true;        }        return null;    } else {        if (decodePackBody(ctx, channel, buffer)) {                        packHeaderRead = false;            return dataPack;        } else {            return null;        }    }}
f39aae18edd3dd2c1e396c07214f839d2ac915ad5576c52a4140450d2fe7f7ec
decodePackHeader
private boolean decodePackHeader(ChannelHandlerContext ctx, Channel channel, ChannelBuffer buffer) throws Exception
{    if (buffer.readableBytes() < 8) {        return false;    }    int serial = buffer.readInt();    int listSize = buffer.readInt();        if (listSize * SIZEOF_REF > 0.1 * maxMem) {        channel.close().await();        throw new AvroRuntimeException("Excessively large list allocation " + "request detected: " + listSize + " items! Connection closed.");    }    this.listSize = listSize;    dataPack = new NettyDataPack(serial, new ArrayList<>(listSize));    return true;}
890176071a8e68593a5e3070070a2ec5e80964e3e3e35cb0b87d65230b46645f
decodePackBody
private boolean decodePackBody(ChannelHandlerContext ctx, Channel channel, ChannelBuffer buffer) throws Exception
{    if (buffer.readableBytes() < 4) {        return false;    }    buffer.markReaderIndex();    int length = buffer.readInt();    if (buffer.readableBytes() < length) {        buffer.resetReaderIndex();        return false;    }    ByteBuffer bb = ByteBuffer.allocate(length);    buffer.readBytes(bb);    bb.flip();    dataPack.getDatas().add(bb);    return dataPack.getDatas().size() == listSize;}
232212a7b5ed9dc0635b15a0fa043325a4cc44cb0f6e78eb6959a98548a3c6cf
testNettyTransceiverReleasesNettyChannelOnFailingToConnect
public void testNettyTransceiverReleasesNettyChannelOnFailingToConnect() throws Exception
{    LastChannelRememberingChannelFactory socketChannelFactory = null;    try (ServerSocket serverSocket = new ServerSocket(0)) {        socketChannelFactory = new LastChannelRememberingChannelFactory();        try {            new NettyTransceiver(new InetSocketAddress(serverSocket.getLocalPort()), socketChannelFactory, 1L);        } finally {            assertFalse("expected that the channel opened by the transceiver is closed", socketChannelFactory.lastChannel.isOpen());        }    } finally {        if (socketChannelFactory != null) {            socketChannelFactory.releaseExternalResources();        }    }}
f1d152743f68a17edf485ca7b0b821c356590cf73312288f7adcb6c93907e077
newChannel
public SocketChannel newChannel(ChannelPipeline pipeline)
{    return lastChannel = super.newChannel(pipeline);}
e7b0f4dd09b8acdf8e45997c4d331159daca34623f03f962953950c4a2e5af40
send
public String send(Message message)
{    return "Sent message to [" + message.getTo() + "] from [" + message.getFrom() + "] with body [" + message.getBody() + "]";}
ace0e54253dfb5d86f8d9d33046a3cecd9ebb3a304b6576ef35cb86c7e1c2357
fireandforget
public void fireandforget(Message message)
{    allMessages.countDown();}
2745bbd5ffb0a2dc8e0bfbd964b7d4857c47b59073fff69441625d798f129eae
awaitMessages
private void awaitMessages() throws InterruptedException
{    allMessages.await(2, TimeUnit.SECONDS);}
a2b49ad5d09f96eba285724a1490e333ce403ad1322ea7177e8eb72e5c6af50b
assertAllMessagesReceived
private void assertAllMessagesReceived()
{    assertEquals(0, allMessages.getCount());}
97d2d353f08aa5a1da8b18b0800b6e778df65f48d34726e5f17800df7e0d88e2
reset
public void reset()
{    allMessages = new CountDownLatch(5);}
5d675b7b7cf7917a3929e0cbb7018e96fb155aff0ac819e05e2b80ef1b79f51f
initializeConnections
public static void initializeConnections() throws Exception
{        System.out.println("starting server...");    mailService = new MailImpl();    Responder responder = new SpecificResponder(Mail.class, mailService);    server = initializeServer(responder);    server.start();    int serverPort = server.getPort();    System.out.println("server port : " + serverPort);    transceiver = initializeTransceiver(serverPort);    proxy = SpecificRequestor.getClient(Mail.class, transceiver);}
37d68d0c9d08a63a0e8651406104a22c8398bff2e7efc6e9ee68164f74a0bc03
initializeServer
protected static Server initializeServer(Responder responder)
{    return new NettyServer(responder, new InetSocketAddress(0));}
9134a2bafd455356612169aad3f9cd9e836ad8ecb5339bc6a20c9bc88d7994e6
initializeTransceiver
protected static Transceiver initializeTransceiver(int serverPort) throws IOException
{    return new NettyTransceiver(new InetSocketAddress(serverPort), CONNECT_TIMEOUT_MILLIS);}
a35c54ddcb783cbf18c438c74529a721ec5d5d2587db55c49bd984c72f514c31
tearDownConnections
public static void tearDownConnections() throws Exception
{    transceiver.close();    server.close();}
869ac1effc24bc3b92d14e259c9ddb90897240db4a9d9ef29ecd53dd915b7235
testRequestResponse
public void testRequestResponse() throws Exception
{    for (int x = 0; x < 5; x++) {        verifyResponse(proxy.send(createMessage()));    }}
b77fdc6c60d8a3f638db7d8cd4bffb42b2de8d485d7d2f2351d90aa2a7282b22
verifyResponse
private void verifyResponse(String result)
{    Assert.assertEquals("Sent message to [wife] from [husband] with body [I love you!]", result);}
a58616a64112b6b291215c70b92371efa579e7c6b6742f58c3bf08da54edad79
testOneway
public void testOneway() throws Exception
{    for (int x = 0; x < 5; x++) {        proxy.fireandforget(createMessage());    }    mailService.awaitMessages();    mailService.assertAllMessagesReceived();}
b72574709fc32fa096292e16fee30359239ad8500f011adb86eb45abfd88536f
testMixtureOfRequests
public void testMixtureOfRequests() throws Exception
{    mailService.reset();    for (int x = 0; x < 5; x++) {        Message createMessage = createMessage();        proxy.fireandforget(createMessage);        verifyResponse(proxy.send(createMessage));    }    mailService.awaitMessages();    mailService.assertAllMessagesReceived();}
6f39edd60add6ae7ab1e3e5a22f92f719f3239b538f53d755a7334f327ebb5ca
testConnectionsCount
public void testConnectionsCount() throws Exception
{    Transceiver transceiver2 = new NettyTransceiver(new InetSocketAddress(server.getPort()), CONNECT_TIMEOUT_MILLIS);    Mail proxy2 = SpecificRequestor.getClient(Mail.class, transceiver2);    proxy.fireandforget(createMessage());    proxy2.fireandforget(createMessage());    Assert.assertEquals(2, ((NettyServer) server).getNumActiveConnections());    transceiver2.close();            int numActiveConnections = ((NettyServer) server).getNumActiveConnections();    for (int i = 0; i < 50 && numActiveConnections == 2; ++i) {        System.out.println("Server still has 2 active connections; retrying...");        Thread.sleep(100);        numActiveConnections = ((NettyServer) server).getNumActiveConnections();    }    Assert.assertEquals(1, numActiveConnections);}
2a1514b355237336b88a3aa0d1e3ad6470410c973f0bcd66b1ba31fff86b20eb
createMessage
private Message createMessage()
{    Message msg = Message.newBuilder().setTo("wife").setFrom("husband").setBody("I love you!").build();    return msg;}
797ffe45b7d41d4e980a7a3e8ab02fafb5696ae855b5dfa696a2358739ca23db
testBadRequest
public void testBadRequest() throws IOException
{    int port = server.getPort();    String msg = "GET /status HTTP/1.1\n\n";    InetSocketAddress sockAddr = new InetSocketAddress("127.0.0.1", port);    Socket sock = new Socket();    sock.connect(sockAddr);    OutputStream out = sock.getOutputStream();    out.write(msg.getBytes(StandardCharsets.UTF_8));    out.flush();    byte[] buf = new byte[2048];    int bytesRead = sock.getInputStream().read(buf);    Assert.assertTrue("Connection should have been closed", bytesRead == -1);}
25e60c6ed2066c9d2f491b11c677de4e18398c15631e2562c4813185eb1753d9
cleanUpAfter
public void cleanUpAfter() throws Exception
{    try {        if (transceiver != null) {            transceiver.close();        }    } catch (IOException e) {        e.printStackTrace();    }    try {        if (server != null) {            server.close();        }    } catch (Exception e) {        e.printStackTrace();    }}
ced3637227837bc8935023b279f6d11e541ba2dd6bbaff26ba3afa81b2fd1240
test
public void test() throws Exception
{    final CountDownLatch waitLatch = new CountDownLatch(1);    server = new NettyServer(new SpecificResponder(Simple.class, new SimpleImpl(waitLatch)), new InetSocketAddress(0), new NioServerSocketChannelFactory(Executors.newCachedThreadPool(), Executors.newCachedThreadPool()), new ExecutionHandler(Executors.newCachedThreadPool()));    server.start();    transceiver = new NettyTransceiver(new InetSocketAddress(server.getPort()), TestNettyServer.CONNECT_TIMEOUT_MILLIS);        final Simple.Callback simpleClient = SpecificRequestor.getClient(Simple.Callback.class, transceiver);        SpecificRequestor.getRemote(simpleClient);    /*     * 2a. In a background thread, wait for the Client.hello("wait") call to be     * received by the server, then: 2b. Execute the Client.ack() RPC, which will     * unblock the Client.hello("wait") call, allowing it to return to the main     * thread.     */    new Thread() {        @Override        public void run() {            setName(TestNettyServerConcurrentExecution.class.getSimpleName() + "Ack Thread");            try {                                waitLatch.await();                                simpleClient.ack();            } catch (InterruptedException e) {                e.printStackTrace();            }        }    }.start();    /*     * 3. Execute the Client.hello("wait") RPC, which will block until the     * Client.ack() call has completed in the background thread.     */    String response = simpleClient.hello("wait");        Assert.assertEquals("wait", response);}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    setName(TestNettyServerConcurrentExecution.class.getSimpleName() + "Ack Thread");    try {                waitLatch.await();                simpleClient.ack();    } catch (InterruptedException e) {        e.printStackTrace();    }}
f8e26015fb530ca98a71d6c55902e1e0bfd266b78c1980474b7b2c18a5771c7b
add
public int add(int arg1, int arg2)
{        return arg1 + arg2;}
6d87b3f488a79535ec22d9b4fdeb6b2778f1602e9990699ee093ee5141d8890e
hello
public String hello(String greeting)
{    if (greeting.equals("wait")) {        try {                        waitLatch.countDown();                        ackLatch.await();        } catch (InterruptedException e) {            Thread.currentThread().interrupt();            return e.toString();        }    }    return greeting;}
3d8d0014cc6b0e65cefa6505611c89ca5ac6939b904da588c889ccea39b2f664
ack
public void ack()
{        ackLatch.countDown();}
767eaba11e63cf2e86776ef6e0be715d65225118dbf3a9d7787a13c5ab8fc405
echo
public TestRecord echo(TestRecord record)
{    return record;}
7a176e7a426d536573df303093e9266cf04f09724bec8e6addabaa80e67a7089
echoBytes
public ByteBuffer echoBytes(ByteBuffer data)
{    return data;}
26100e3e2a24aa3c3355cc9bad6d49cc2c801ee035658567f5a783f9d7f7fea8
error
public void error() throws TestError
{    throw new TestError("TestError");}
5d675b7b7cf7917a3929e0cbb7018e96fb155aff0ac819e05e2b80ef1b79f51f
initializeConnections
public static void initializeConnections() throws Exception
{        Responder responder = new SpecificResponder(Simple.class, simpleService);    server = new NettyServer(responder, new InetSocketAddress(0));    server.start();    int serverPort = server.getPort();    System.out.println("server port : " + serverPort);    transceiver = new NettyTransceiver(new InetSocketAddress(serverPort), TestNettyServer.CONNECT_TIMEOUT_MILLIS);    simpleClient = SpecificRequestor.getClient(Simple.Callback.class, transceiver);}
a35c54ddcb783cbf18c438c74529a721ec5d5d2587db55c49bd984c72f514c31
tearDownConnections
public static void tearDownConnections() throws Exception
{    if (transceiver != null) {        transceiver.close();    }    if (server != null) {        server.close();    }}
6e958d2e50b2a0fb3c7ea6dc719ee4ba0b6e9af6ae5c39b8a2e9ffa0c64bdb4f
greeting
public void greeting() throws Exception
{        Assert.assertEquals("Hello, how are you?", simpleClient.hello("how are you?"));        CallFuture<String> future1 = new CallFuture<>();    simpleClient.hello("World!", future1);    Assert.assertEquals("Hello, World!", future1.get(2, TimeUnit.SECONDS));    Assert.assertNull(future1.getError());        final CallFuture<String> future2 = new CallFuture<>();    simpleClient.hello("what's up?", new Callback<String>() {        @Override        public void handleResult(String result) {            future2.handleResult(result);        }        @Override        public void handleError(Throwable error) {            future2.handleError(error);        }    });    Assert.assertEquals("Hello, what's up?", future2.get(2, TimeUnit.SECONDS));    Assert.assertNull(future2.getError());}
e3e60302abdb2ec1de375edff9a5d2d8d07325c915062b888d6ba0396d58cab6
handleResult
public void handleResult(String result)
{    future2.handleResult(result);}
035b837624c44e5dc14a38f958d2fc58e6fff4a720b43c0bb73dbb869a99aaaf
handleError
public void handleError(Throwable error)
{    future2.handleError(error);}
b350d81808a16fac4cd542700a3541f2296f3062f4c01ceab40fe6c6fa6593d2
echo
public void echo() throws Exception
{    TestRecord record = TestRecord.newBuilder().setHash(new org.apache.avro.test.MD5(new byte[] { 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8 })).setKind(org.apache.avro.test.Kind.FOO).setName("My Record").build();        Assert.assertEquals(record, simpleClient.echo(record));        CallFuture<TestRecord> future1 = new CallFuture<>();    simpleClient.echo(record, future1);    Assert.assertEquals(record, future1.get(2, TimeUnit.SECONDS));    Assert.assertNull(future1.getError());        final CallFuture<TestRecord> future2 = new CallFuture<>();    simpleClient.echo(record, new Callback<TestRecord>() {        @Override        public void handleResult(TestRecord result) {            future2.handleResult(result);        }        @Override        public void handleError(Throwable error) {            future2.handleError(error);        }    });    Assert.assertEquals(record, future2.get(2, TimeUnit.SECONDS));    Assert.assertNull(future2.getError());}
c95cdd0386b64ba0f11f023ce0892d662cd7a87276e5012b38fa8bd0bce6a7ca
handleResult
public void handleResult(TestRecord result)
{    future2.handleResult(result);}
035b837624c44e5dc14a38f958d2fc58e6fff4a720b43c0bb73dbb869a99aaaf
handleError
public void handleError(Throwable error)
{    future2.handleError(error);}
7321f243363c0d7b609b4f6c5ad5f6e398c2ccc7ca1ff95acabd290c96ef1d0f
add
public void add() throws Exception
{        Assert.assertEquals(8, simpleClient.add(2, 6));        CallFuture<Integer> future1 = new CallFuture<>();    simpleClient.add(8, 8, future1);    Assert.assertEquals(new Integer(16), future1.get(2, TimeUnit.SECONDS));    Assert.assertNull(future1.getError());        final CallFuture<Integer> future2 = new CallFuture<>();    simpleClient.add(512, 256, new Callback<Integer>() {        @Override        public void handleResult(Integer result) {            future2.handleResult(result);        }        @Override        public void handleError(Throwable error) {            future2.handleError(error);        }    });    Assert.assertEquals(new Integer(768), future2.get(2, TimeUnit.SECONDS));    Assert.assertNull(future2.getError());}
14288447355b179df3a5fb042b135e63a7343e90ac03aef3f015800745d29ac6
handleResult
public void handleResult(Integer result)
{    future2.handleResult(result);}
035b837624c44e5dc14a38f958d2fc58e6fff4a720b43c0bb73dbb869a99aaaf
handleError
public void handleError(Throwable error)
{    future2.handleError(error);}
1af4b53ac10c24b1f1cfc9358a2df18de6096d4a875e7f6278858f1f434cd176
echoBytes
public void echoBytes() throws Exception
{    ByteBuffer byteBuffer = ByteBuffer.wrap(new byte[] { 1, 2, 3, 4, 5, 6, 7, 8 });        Assert.assertEquals(byteBuffer, simpleClient.echoBytes(byteBuffer));        CallFuture<ByteBuffer> future1 = new CallFuture<>();    simpleClient.echoBytes(byteBuffer, future1);    Assert.assertEquals(byteBuffer, future1.get(2, TimeUnit.SECONDS));    Assert.assertNull(future1.getError());        final CallFuture<ByteBuffer> future2 = new CallFuture<>();    simpleClient.echoBytes(byteBuffer, new Callback<ByteBuffer>() {        @Override        public void handleResult(ByteBuffer result) {            future2.handleResult(result);        }        @Override        public void handleError(Throwable error) {            future2.handleError(error);        }    });    Assert.assertEquals(byteBuffer, future2.get(2, TimeUnit.SECONDS));    Assert.assertNull(future2.getError());}
b127cba52c71d9bd811e4c0d6f873845850ae98be9b13ce645622b44879c49e0
handleResult
public void handleResult(ByteBuffer result)
{    future2.handleResult(result);}
035b837624c44e5dc14a38f958d2fc58e6fff4a720b43c0bb73dbb869a99aaaf
handleError
public void handleError(Throwable error)
{    future2.handleError(error);}
023bc3c79031c2d56f060212933d11f8e89a1f427083d7e4cb8ebd2ccdf7f1bc
error
public void error() throws IOException, InterruptedException, TimeoutException
{        try {        simpleClient.error();        Assert.fail("Expected " + TestError.class.getCanonicalName());    } catch (TestError e) {        } catch (AvroRemoteException e) {        e.printStackTrace();        Assert.fail("Unexpected error: " + e.toString());    }        CallFuture<Void> future = new CallFuture<>();    simpleClient.error(future);    try {        future.get(2, TimeUnit.SECONDS);        Assert.fail("Expected " + TestError.class.getCanonicalName() + " to be thrown");    } catch (ExecutionException e) {        Assert.assertTrue("Expected " + TestError.class.getCanonicalName(), e.getCause() instanceof TestError);    }    Assert.assertNotNull(future.getError());    Assert.assertTrue("Expected " + TestError.class.getCanonicalName(), future.getError() instanceof TestError);    Assert.assertNull(future.getResult());        final CountDownLatch latch = new CountDownLatch(1);    final AtomicReference<Throwable> errorRef = new AtomicReference<>();    simpleClient.error(new Callback<Void>() {        @Override        public void handleResult(Void result) {            Assert.fail("Expected " + TestError.class.getCanonicalName());        }        @Override        public void handleError(Throwable error) {            errorRef.set(error);            latch.countDown();        }    });    Assert.assertTrue("Timed out waiting for error", latch.await(2, TimeUnit.SECONDS));    Assert.assertNotNull(errorRef.get());    Assert.assertTrue(errorRef.get() instanceof TestError);}
c74b14b7960ae04cad81a10ecdce088af9075c90af8bc941ef9b45e87fe7ee08
handleResult
public void handleResult(Void result)
{    Assert.fail("Expected " + TestError.class.getCanonicalName());}
035b837624c44e5dc14a38f958d2fc58e6fff4a720b43c0bb73dbb869a99aaaf
handleError
public void handleError(Throwable error)
{    errorRef.set(error);    latch.countDown();}
2e66377270bdba5b14360d230d5b72cb91a338ff20035b8036384691575a2277
ack
public void ack() throws Exception
{    simpleClient.ack();    ackLatch.get().await(2, TimeUnit.SECONDS);    Assert.assertTrue("Expected ack flag to be set", ackFlag.get());    ackLatch.set(new CountDownLatch(1));    simpleClient.ack();    ackLatch.get().await(2, TimeUnit.SECONDS);    Assert.assertFalse("Expected ack flag to be cleared", ackFlag.get());}
5d680ae9641e41d8cb9d133f348b82e65f3f440136eee35632a190def539ce35
testSendAfterChannelClose
public void testSendAfterChannelClose() throws Exception
{            Server server2 = new NettyServer(new SpecificResponder(Simple.class, simpleService), new InetSocketAddress(0));    server2.start();    try {        int serverPort = server2.getPort();        System.out.println("server2 port : " + serverPort);        try (Transceiver transceiver2 = new NettyTransceiver(new InetSocketAddress(serverPort), TestNettyServer.CONNECT_TIMEOUT_MILLIS)) {            Simple.Callback simpleClient2 = SpecificRequestor.getClient(Simple.Callback.class, transceiver2);                        Assert.assertEquals(3, simpleClient2.add(1, 2));                        CallFuture<Integer> addFuture = new CallFuture<>();            simpleClient2.add(1, 2, addFuture);            Assert.assertEquals(new Integer(3), addFuture.get());                        server2.close();            Thread.sleep(1000L);                                    boolean ioeCaught = false;            try {                simpleClient2.add(1, 2);                Assert.fail("Send after server close should have thrown Exception");            } catch (AvroRuntimeException e) {                ioeCaught = e.getCause() instanceof IOException;                Assert.assertTrue("Expected IOException", ioeCaught);            } catch (Exception e) {                e.printStackTrace();                throw e;            }            Assert.assertTrue("Expected IOException", ioeCaught);                                    ioeCaught = false;            try {                addFuture = new CallFuture<>();                simpleClient2.add(1, 2, addFuture);                addFuture.get();                Assert.fail("Send after server close should have thrown Exception");            } catch (IOException e) {                ioeCaught = true;            } catch (Exception e) {                e.printStackTrace();                throw e;            }            Assert.assertTrue("Expected IOException", ioeCaught);        }    } finally {        server2.close();    }}
2bb628358c977b14dfa8f80adfaacd02ba51ced455cd2dc273df3dd77139ae97
cancelPendingRequestsOnTransceiverClose
public void cancelPendingRequestsOnTransceiverClose() throws Exception
{            BlockingSimpleImpl blockingSimpleImpl = new BlockingSimpleImpl();    Server server2 = new NettyServer(new SpecificResponder(Simple.class, blockingSimpleImpl), new InetSocketAddress(0));    server2.start();    try {        int serverPort = server2.getPort();        System.out.println("server2 port : " + serverPort);        CallFuture<Integer> addFuture = new CallFuture<>();        try (Transceiver transceiver2 = new NettyTransceiver(new InetSocketAddress(serverPort), TestNettyServer.CONNECT_TIMEOUT_MILLIS)) {            Simple.Callback simpleClient2 = SpecificRequestor.getClient(Simple.Callback.class, transceiver2);                        Assert.assertEquals(3, simpleClient2.add(1, 2));                        blockingSimpleImpl.acquireRunPermit();            simpleClient2.add(1, 2, addFuture);        }                        boolean ioeThrown = false;        try {            addFuture.get();        } catch (ExecutionException e) {            ioeThrown = e.getCause() instanceof IOException;            Assert.assertTrue(e.getCause() instanceof IOException);        } catch (Exception e) {            e.printStackTrace();            Assert.fail("Unexpected Exception: " + e.toString());        }        Assert.assertTrue("Expected IOException to be thrown", ioeThrown);    } finally {        blockingSimpleImpl.releaseRunPermit();        server2.close();    }}
809e02be052dbc724ac97c2cf748ad9ba89f9552713fe73338b557800ac57dde
cancelPendingRequestsAfterChannelCloseByServerShutdown
public void cancelPendingRequestsAfterChannelCloseByServerShutdown() throws Throwable
{                                BlockingSimpleImpl blockingSimpleImpl = new BlockingSimpleImpl();    final Server server2 = new NettyServer(new SpecificResponder(Simple.class, blockingSimpleImpl), new InetSocketAddress(0));    server2.start();    Transceiver transceiver2 = null;    try {        int serverPort = server2.getPort();        System.out.println("server2 port : " + serverPort);        transceiver2 = new NettyTransceiver(new InetSocketAddress(serverPort), TestNettyServer.CONNECT_TIMEOUT_MILLIS);        final Simple.Callback simpleClient2 = SpecificRequestor.getClient(Simple.Callback.class, transceiver2);                        blockingSimpleImpl.acquireEnterPermit();                blockingSimpleImpl.acquireRunPermit();                Future<?> clientFuture = Executors.newSingleThreadExecutor().submit(() -> {            try {                simpleClient2.add(3, 4);                Assert.fail("Expected an exception");            } catch (Exception e) {                        }        });                blockingSimpleImpl.acquireEnterPermit();                                                new Thread(server2::close).start();                try {            clientFuture.get(10, TimeUnit.SECONDS);        } catch (ExecutionException e) {            throw e.getCause();        } catch (TimeoutException e) {            Assert.fail("Client request should not be blocked on server shutdown");        }    } finally {        blockingSimpleImpl.releaseRunPermit();        server2.close();        if (transceiver2 != null)            transceiver2.close();    }}
2a813ebabc21cb4a888e34d0ce25b845477978200c708c705d2a0b63990587dd
clientReconnectAfterServerRestart
public void clientReconnectAfterServerRestart() throws Exception
{            SimpleImpl simpleImpl = new BlockingSimpleImpl();    Server server2 = new NettyServer(new SpecificResponder(Simple.class, simpleImpl), new InetSocketAddress(0));    try {        server2.start();        int serverPort = server2.getPort();        System.out.println("server2 port : " + serverPort);                Transceiver transceiver2 = new NettyTransceiver(new InetSocketAddress(serverPort), TestNettyServer.CONNECT_TIMEOUT_MILLIS);        Simple.Callback simpleClient2 = SpecificRequestor.getClient(Simple.Callback.class, transceiver2);        Assert.assertEquals(3, simpleClient2.add(1, 2));                server2.close();        try {            simpleClient2.add(2, -1);            Assert.fail("Client should not be able to invoke RPCs " + "because server is no longer running");        } catch (Exception e) {                }        Thread.sleep(2000L);        server2 = new NettyServer(new SpecificResponder(Simple.class, simpleImpl), new InetSocketAddress(serverPort));        server2.start();                        Assert.assertEquals(3, simpleClient2.add(1, 2));    } finally {        server2.close();    }}
ab64ceaf51526e12bff330aadb90e85f388215105c8e7534622b14fb707b46f2
performanceTest
public void performanceTest() throws Exception
{    final int threadCount = 8;    final long runTimeMillis = 10 * 1000L;    ExecutorService threadPool = Executors.newFixedThreadPool(threadCount);    System.out.println("Running performance test for " + runTimeMillis + "ms...");    final AtomicLong rpcCount = new AtomicLong(0L);    final AtomicBoolean runFlag = new AtomicBoolean(true);    final CountDownLatch startLatch = new CountDownLatch(threadCount);    for (int ii = 0; ii < threadCount; ii++) {        threadPool.submit(() -> {            try {                startLatch.countDown();                startLatch.await(2, TimeUnit.SECONDS);                while (runFlag.get()) {                    rpcCount.incrementAndGet();                    Assert.assertEquals("Hello, World!", simpleClient.hello("World!"));                }            } catch (Exception e) {                e.printStackTrace();            }        });    }    startLatch.await(2, TimeUnit.SECONDS);    Thread.sleep(runTimeMillis);    runFlag.set(false);    threadPool.shutdown();    Assert.assertTrue("Timed out shutting down thread pool", threadPool.awaitTermination(2, TimeUnit.SECONDS));    System.out.println("Completed " + rpcCount.get() + " RPCs in " + runTimeMillis + "ms => " + (((double) rpcCount.get() / (double) runTimeMillis) * 1000) + " RPCs/sec, " + ((double) runTimeMillis / (double) rpcCount.get()) + " ms/RPC.");}
6d87b3f488a79535ec22d9b4fdeb6b2778f1602e9990699ee093ee5141d8890e
hello
public String hello(String greeting)
{    return "Hello, " + greeting;}
767eaba11e63cf2e86776ef6e0be715d65225118dbf3a9d7787a13c5ab8fc405
echo
public TestRecord echo(TestRecord record)
{    return record;}
f8e26015fb530ca98a71d6c55902e1e0bfd266b78c1980474b7b2c18a5771c7b
add
public int add(int arg1, int arg2)
{    return arg1 + arg2;}
7a176e7a426d536573df303093e9266cf04f09724bec8e6addabaa80e67a7089
echoBytes
public ByteBuffer echoBytes(ByteBuffer data)
{    return data;}
26100e3e2a24aa3c3355cc9bad6d49cc2c801ee035658567f5a783f9d7f7fea8
error
public void error() throws TestError
{    throw TestError.newBuilder().setMessage$("Test Message").build();}
1fd1ed5727bb51b88247a034139a6c5848bc54c752f138179e9efb4771bd3cee
ack
public synchronized void ack()
{    ackFlag.set(!ackFlag.get());    ackLatch.get().countDown();}
6d87b3f488a79535ec22d9b4fdeb6b2778f1602e9990699ee093ee5141d8890e
hello
public String hello(String greeting)
{    releaseEnterPermit();    acquireRunPermit();    try {        return super.hello(greeting);    } finally {        releaseRunPermit();    }}
767eaba11e63cf2e86776ef6e0be715d65225118dbf3a9d7787a13c5ab8fc405
echo
public TestRecord echo(TestRecord record)
{    releaseEnterPermit();    acquireRunPermit();    try {        return super.echo(record);    } finally {        releaseRunPermit();    }}
f8e26015fb530ca98a71d6c55902e1e0bfd266b78c1980474b7b2c18a5771c7b
add
public int add(int arg1, int arg2)
{    releaseEnterPermit();    acquireRunPermit();    try {        return super.add(arg1, arg2);    } finally {        releaseRunPermit();    }}
7a176e7a426d536573df303093e9266cf04f09724bec8e6addabaa80e67a7089
echoBytes
public ByteBuffer echoBytes(ByteBuffer data)
{    releaseEnterPermit();    acquireRunPermit();    try {        return super.echoBytes(data);    } finally {        releaseRunPermit();    }}
26100e3e2a24aa3c3355cc9bad6d49cc2c801ee035658567f5a783f9d7f7fea8
error
public void error() throws TestError
{    releaseEnterPermit();    acquireRunPermit();    try {        super.error();    } finally {        releaseRunPermit();    }}
3d8d0014cc6b0e65cefa6505611c89ca5ac6939b904da588c889ccea39b2f664
ack
public void ack()
{    releaseEnterPermit();    acquireRunPermit();    try {        super.ack();    } finally {        releaseRunPermit();    }}
2a0ed6a31c9a6dfcb4b94fbb57ae8846d0a74d71a2c0043fb6e3e1134a7ada17
acquireRunPermit
public void acquireRunPermit()
{    try {        runSemaphore.acquire();    } catch (InterruptedException e) {        Thread.currentThread().interrupt();        throw new RuntimeException(e);    }}
dc766a08875549eb0c0e4af0c66afaeafc49188b7511f9bf334291d0e0517dfb
releaseRunPermit
public void releaseRunPermit()
{    runSemaphore.release();}
672527985fa36415d6a68ec9d16bf7f3af74095a6e708530344ca626a83ec7da
acquireEnterPermit
public void acquireEnterPermit()
{    try {        enterSemaphore.acquire();    } catch (InterruptedException e) {        Thread.currentThread().interrupt();        throw new RuntimeException(e);    }}
32d5cb291daeaf3a1f7106bc70ab849846c26ca9c5b8269e083f66a02fbb055b
releaseEnterPermit
public void releaseEnterPermit()
{    enterSemaphore.release();}
37d68d0c9d08a63a0e8651406104a22c8398bff2e7efc6e9ee68164f74a0bc03
initializeServer
protected static Server initializeServer(Responder responder)
{    ChannelFactory channelFactory = new NioServerSocketChannelFactory(Executors.newCachedThreadPool(), Executors.newCachedThreadPool());    return new NettyServer(responder, new InetSocketAddress(0), channelFactory, new CompressionChannelPipelineFactory(), null);}
9134a2bafd455356612169aad3f9cd9e836ad8ecb5339bc6a20c9bc88d7994e6
initializeTransceiver
protected static Transceiver initializeTransceiver(int serverPort) throws IOException
{    return new NettyTransceiver(new InetSocketAddress(serverPort), new CompressionChannelFactory(), CONNECT_TIMEOUT_MILLIS);}
f1d152743f68a17edf485ca7b0b821c356590cf73312288f7adcb6c93907e077
newChannel
public SocketChannel newChannel(ChannelPipeline pipeline)
{    try {        ZlibEncoder encoder = new ZlibEncoder(6);        pipeline.addFirst("deflater", encoder);        pipeline.addFirst("inflater", new ZlibDecoder());        return super.newChannel(pipeline);    } catch (Exception ex) {        throw new RuntimeException("Cannot create Compression channel", ex);    }}
cad0ca6670898490d4708d44f6fd87df22865c8cca5776775b5fc8cd9e37c866
getPipeline
public ChannelPipeline getPipeline() throws Exception
{    ChannelPipeline pipeline = Channels.pipeline();    ZlibEncoder encoder = new ZlibEncoder(6);    pipeline.addFirst("deflater", encoder);    pipeline.addFirst("inflater", new ZlibDecoder());    return pipeline;}
37d68d0c9d08a63a0e8651406104a22c8398bff2e7efc6e9ee68164f74a0bc03
initializeServer
protected static Server initializeServer(Responder responder)
{    ChannelFactory channelFactory = new NioServerSocketChannelFactory(Executors.newCachedThreadPool(), Executors.newCachedThreadPool());    return new NettyServer(responder, new InetSocketAddress(0), channelFactory, new SSLChannelPipelineFactory(), null);}
9134a2bafd455356612169aad3f9cd9e836ad8ecb5339bc6a20c9bc88d7994e6
initializeTransceiver
protected static Transceiver initializeTransceiver(int serverPort) throws IOException
{    return new NettyTransceiver(new InetSocketAddress(serverPort), new SSLChannelFactory(), CONNECT_TIMEOUT_MILLIS);}
f1d152743f68a17edf485ca7b0b821c356590cf73312288f7adcb6c93907e077
newChannel
public SocketChannel newChannel(ChannelPipeline pipeline)
{    try {        SSLContext sslContext = SSLContext.getInstance("TLS");        sslContext.init(null, new TrustManager[] { new BogusTrustManager() }, null);        SSLEngine sslEngine = sslContext.createSSLEngine();        sslEngine.setUseClientMode(true);        pipeline.addFirst("ssl", new SslHandler(sslEngine));        return super.newChannel(pipeline);    } catch (Exception ex) {        throw new RuntimeException("Cannot create SSL channel", ex);    }}
ff4e4a28c0a152e6e1627ea02e0bba88ca318bc15e775b9321ba555aa17a72e5
checkClientTrusted
public void checkClientTrusted(X509Certificate[] certs, String s)
{}
9c224c0159aa7449b31fb34da6b66aa554f1404356900809ff3fb435bc2ca415
checkServerTrusted
public void checkServerTrusted(X509Certificate[] certs, String s)
{}
b516c58bc22bde695ccdef782f17985d051ddc0b89329e35483cf2a3a576c7fe
getAcceptedIssuers
public X509Certificate[] getAcceptedIssuers()
{    return new X509Certificate[0];}
1ba4580af5abb23ba6240c843d2da0abc4be225dfb5b9dee1e58f621a8eac35e
createServerSSLContext
private SSLContext createServerSSLContext()
{    try {        KeyStore ks = KeyStore.getInstance("PKCS12");        ks.load(TestNettyServer.class.getResource(TEST_CERTIFICATE).openStream(), TEST_CERTIFICATE_PASSWORD.toCharArray());                KeyManagerFactory kmf = KeyManagerFactory.getInstance(getAlgorithm());        kmf.init(ks, TEST_CERTIFICATE_PASSWORD.toCharArray());        SSLContext serverContext = SSLContext.getInstance("TLS");        serverContext.init(kmf.getKeyManagers(), null, null);        return serverContext;    } catch (Exception e) {        throw new Error("Failed to initialize the server-side SSLContext", e);    }}
ab89e51d439a571b4cdf36b539e8e831eac3a07807def7af75c7032c6d752079
getAlgorithm
private String getAlgorithm()
{    String algorithm = Security.getProperty("ssl.KeyManagerFactory.algorithm");    if (algorithm == null) {        algorithm = "SunX509";    }    return algorithm;}
cad0ca6670898490d4708d44f6fd87df22865c8cca5776775b5fc8cd9e37c866
getPipeline
public ChannelPipeline getPipeline() throws Exception
{    ChannelPipeline pipeline = Channels.pipeline();    SSLEngine sslEngine = createServerSSLContext().createSSLEngine();    sslEngine.setUseClientMode(false);    pipeline.addLast("ssl", new SslHandler(sslEngine));    return pipeline;}
6430ffe527c49c6cb5e64900b237ce2642e9efd4a7c1c4ecbfd5147e0cd99d60
testNettyTransceiverWhenServerStops
public void testNettyTransceiverWhenServerStops() throws Exception
{    Mail mailService = new TestNettyServer.MailImpl();    Responder responder = new SpecificResponder(Mail.class, mailService);    NettyServer server = new NettyServer(responder, new InetSocketAddress(0));    server.start();    int serverPort = server.getPort();    final NettyTransceiver transceiver = new NettyTransceiver(new InetSocketAddress(serverPort), 60000L);    final Mail mail = SpecificRequestor.getClient(Mail.class, transceiver);    final AtomicInteger successes = new AtomicInteger();    final AtomicInteger failures = new AtomicInteger();    final AtomicBoolean quitOnFailure = new AtomicBoolean();    List<Thread> threads = new ArrayList<>();        for (int i = 0; i < 100; i++) {        Thread thread = new Thread(() -> {            while (true) {                try {                    mail.send(createMessage());                    successes.incrementAndGet();                } catch (Exception e) {                    failures.incrementAndGet();                    if (quitOnFailure.get()) {                        return;                    }                }            }        });        threads.add(thread);        thread.start();    }        while (successes.get() < 10000) {        Thread.sleep(50);    }        server.close();        while (true) {        int previousSuccesses = successes.get();        Thread.sleep(500);        if (previousSuccesses == successes.get()) {            break;        }    }        server.start();                        long now = System.currentTimeMillis();    /*     * System.out.println("Waiting on requests to continue"); int previousSuccesses     * = successes.get(); while (true) { Thread.sleep(500); if (successes.get() >     * previousSuccesses) { break; } if (System.currentTimeMillis() - now > 5000) {     * System.out.println("FYI: requests don't continue immediately..."); break; } }     */        System.out.println("Stopping transceiver");    quitOnFailure.set(true);    now = System.currentTimeMillis();        transceiver.close();        for (Thread thread : threads) {        thread.join();    }    if (System.currentTimeMillis() - now > 10000) {        fail("Stopping NettyTransceiver and waiting for client threads to quit took too long.");    } else {        System.out.println("Stopping NettyTransceiver and waiting for client threads to quit took " + (System.currentTimeMillis() - now) + " ms");    }}
2a1514b355237336b88a3aa0d1e3ad6470410c973f0bcd66b1ba31fff86b20eb
createMessage
private Message createMessage()
{    Message msg = Message.newBuilder().setTo("wife").setFrom("husband").setBody("I love you!").build();    return msg;}
d2c969c3d001f4cb8ee4faf386f2b39208dd1de1af42947372b3ba149b948da2
createServer
public Server createServer(Responder testResponder) throws Exception
{    return new NettyServer(responder, new InetSocketAddress(0));}
b723b1ec8e0ad25b5fa0c50c217e5a3f9380f12f0fa602f368cec8d7c19fdad2
createTransceiver
public Transceiver createTransceiver() throws Exception
{    return new NettyTransceiver(new InetSocketAddress(server.getPort()), 2000L);}
38f6f275e4665b7bc5553d8f196e583a98d4b5bc53049915ab8fab55edcd57e7
getExpectedHandshakeCount
protected int getExpectedHandshakeCount()
{    return REPEATING;}
dc25def6b391ac0def0007bd36ccbdb7d5b2582fd3994ef86d605a33ab3d4288
fromHadoopString
public static CodecFactory fromHadoopString(String hadoopCodecClass)
{    CodecFactory o = null;    try {        String avroCodec = HADOOP_AVRO_NAME_MAP.get(hadoopCodecClass);        if (avroCodec != null) {            o = CodecFactory.fromString(avroCodec);        }    } catch (Exception e) {        throw new AvroRuntimeException("Unrecognized hadoop codec: " + hadoopCodecClass, e);    }    return o;}
422a271e4586306ff2235a83f1a1ca91990a6899b4f18461de8061b52e3c6001
getAvroCodecName
public static String getAvroCodecName(String hadoopCodecClass)
{    return HADOOP_AVRO_NAME_MAP.get(hadoopCodecClass);}
066e2930d8a5ca57a491feb2aafd204f4f5faad8a4bb103510677ebf32f70219
withConfiguration
public Options withConfiguration(Configuration conf)
{    mConf = conf;    return this;}
4ab32fd1c0fc8b7e0975a577f547cc7a82d509b4844a391bcce9e94e9bd47854
getConfiguration
public Configuration getConfiguration()
{    return mConf;}
c246bd1ecf5c2a1ba7014a313f2cc41d059f775e25f0376fd1b2bf48b459f960
withPath
public Options withPath(Path path)
{    mPath = path;    return this;}
8db7848085b680ef314213a1bef8feee4e1decb8072466d9168d74d75362d8fb
getPath
public Path getPath()
{    return mPath;}
11e8138b3863c421e45422570c7f0d4bac72b8a885c24c42ce45a187b649f38e
withKeySchema
public Options withKeySchema(Schema keySchema)
{    mKeySchema = keySchema;    return this;}
618581fdf61e3b4219ce5809001e93611d998d213c0212f8dd5683bec92e9473
getKeySchema
public Schema getKeySchema()
{    return mKeySchema;}
2546d978c03a628e80caf908da682324773f9998c51dddb54f20dae6ff21730f
withValueSchema
public Options withValueSchema(Schema valueSchema)
{    mValueSchema = valueSchema;    return this;}
5a060f8c3dd27a0ecc8214caee6210e548eeb0883c0bd73cda4dee95ec2e293d
getValueSchema
public Schema getValueSchema()
{    return mValueSchema;}
9b4bd2eec569b13dfd9020a8cbf68ecaf9ae2f6cf3aefe8fb5d1f8d4eefcf2ac
withDataModel
public Options withDataModel(GenericData model)
{    this.model = model;    return this;}
5659051a7b5e7bf40bff39b431efb23e681de7b97716a715b500121eac282f8c
getDataModel
public GenericData getDataModel()
{    return model;}
3272a8433c77ed893ae9705d0fa261ec1b6c5fdab96289ff334b5b6dc07e0c70
get
public V get(K key) throws IOException
{        LOG.debug("Looking up key " + key + " in the index.");    Map.Entry<K, Long> indexEntry = mIndex.floorEntry(key);    if (null == indexEntry) {        LOG.debug("Key " + key + " was not found in the index (it is before the first entry)");        return null;    }    LOG.debug("Key was found in the index, seeking to syncpoint " + indexEntry.getValue());        mDataFileReader.seek(indexEntry.getValue());        for (AvroKeyValue<K, V> record : this) {        int comparison = model.compare(record.getKey(), key, mKeySchema);        if (0 == comparison) {                        LOG.debug("Found record for key " + key);            return record.getValue();        }        if (comparison > 0) {                        LOG.debug("Searched beyond the point where key " + key + " would appear in the file.");            return null;        }    }        LOG.debug("Searched to the end of the file but did not find key " + key);    return null;}
b79ed4312bd345da88882ce8998cb9ab55f542187c4d2b319dd5c32465718560
iterator
public Iterator<AvroKeyValue<K, V>> iterator()
{    return new AvroKeyValue.Iterator<>(mDataFileReader.iterator());}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    mDataFileReader.close();}
2d95ef068baf6a4de60d093d24c10735e6e4da3f5dbf9da6551358f220d2c453
loadIndexFile
private NavigableMap<K, Long> loadIndexFile(Configuration conf, Path path, Schema keySchema) throws IOException
{    DatumReader<GenericRecord> datumReader = model.createDatumReader(AvroKeyValue.getSchema(keySchema, Schema.create(Schema.Type.LONG)));    NavigableMap<K, Long> index = new TreeMap<>();    try (DataFileReader<GenericRecord> fileReader = new DataFileReader<>(new FsInput(path, conf), datumReader)) {        if (Schema.create(Schema.Type.STRING).equals(keySchema)) {                                                                                                                        index = new TreeMap<>(new AvroCharSequenceComparator<>());        }        for (GenericRecord genericRecord : fileReader) {            AvroKeyValue<K, Long> indexRecord = new AvroKeyValue<>(genericRecord);            index.put(indexRecord.getKey(), indexRecord.getValue());        }    }    return index;}
11e8138b3863c421e45422570c7f0d4bac72b8a885c24c42ce45a187b649f38e
withKeySchema
public Options withKeySchema(Schema keySchema)
{    mKeySchema = keySchema;    return this;}
618581fdf61e3b4219ce5809001e93611d998d213c0212f8dd5683bec92e9473
getKeySchema
public Schema getKeySchema()
{    return mKeySchema;}
2546d978c03a628e80caf908da682324773f9998c51dddb54f20dae6ff21730f
withValueSchema
public Options withValueSchema(Schema valueSchema)
{    mValueSchema = valueSchema;    return this;}
5a060f8c3dd27a0ecc8214caee6210e548eeb0883c0bd73cda4dee95ec2e293d
getValueSchema
public Schema getValueSchema()
{    return mValueSchema;}
066e2930d8a5ca57a491feb2aafd204f4f5faad8a4bb103510677ebf32f70219
withConfiguration
public Options withConfiguration(Configuration conf)
{    mConf = conf;    return this;}
4ab32fd1c0fc8b7e0975a577f547cc7a82d509b4844a391bcce9e94e9bd47854
getConfiguration
public Configuration getConfiguration()
{    return mConf;}
c246bd1ecf5c2a1ba7014a313f2cc41d059f775e25f0376fd1b2bf48b459f960
withPath
public Options withPath(Path path)
{    mPath = path;    return this;}
8db7848085b680ef314213a1bef8feee4e1decb8072466d9168d74d75362d8fb
getPath
public Path getPath()
{    return mPath;}
c8c9a225c93b8e63569d44a65c75923560759e48fb73f728b6f6d2bb1cebb6c5
withIndexInterval
public Options withIndexInterval(int indexInterval)
{    mIndexInterval = indexInterval;    return this;}
f0fac13dc099f5d644bd009a8b8843c4773f716a6dbe36162715e2b734eaba2b
getIndexInterval
public int getIndexInterval()
{    return mIndexInterval;}
9b4bd2eec569b13dfd9020a8cbf68ecaf9ae2f6cf3aefe8fb5d1f8d4eefcf2ac
withDataModel
public Options withDataModel(GenericData model)
{    this.model = model;    return this;}
5659051a7b5e7bf40bff39b431efb23e681de7b97716a715b500121eac282f8c
getDataModel
public GenericData getDataModel()
{    return model;}
8e3f9c1b8d6c8ba52ef41b43d9e4813abf65774f67657e2a93acc9bccafce03d
withCodec
public Options withCodec(String codec)
{    this.codec = CodecFactory.fromString(codec);    return this;}
7edd2d0b96726ee01562cd96dc16c67ae149bb6a265a94c066bca9791630789a
withCodec
public Options withCodec(CodecFactory codec)
{    this.codec = codec;    return this;}
37e025c0b344729d9e400c6782b67a41158ed1708198bd09b17a4d7180d6ade5
getCodec
public CodecFactory getCodec()
{    return this.codec;}
a42fa2726604a2da72526a102b3a667287cb14d457771ee5dd50dd805901c4f1
append
public void append(K key, V value) throws IOException
{        if (null != mPreviousKey && model.compare(key, mPreviousKey, mKeySchema) < 0) {        throw new IllegalArgumentException("Records must be inserted in sorted key order." + " Attempted to insert key " + key + " after " + mPreviousKey + ".");    }    mPreviousKey = model.deepCopy(mKeySchema, key);        AvroKeyValue<K, V> dataRecord = new AvroKeyValue<>(new GenericData.Record(mRecordSchema));    dataRecord.setKey(key);    dataRecord.setValue(value);        if (0 == mRecordsWritten++ % mIndexInterval) {                        long position = mDataFileWriter.sync();                AvroKeyValue<K, Long> indexRecord = new AvroKeyValue<>(new GenericData.Record(mIndexSchema));        indexRecord.setKey(key);        indexRecord.setValue(position);        mIndexFileWriter.append(indexRecord.get());    }        mDataFileWriter.append(dataRecord.get());}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    mIndexFileWriter.close();    mDataFileWriter.close();}
d4632db9cade0c556113513c370fde48f9e1585679e796d3f84a4ec0de173155
create
public AvroDatumConverter<IN, OUT> create(Class<IN> inputClass)
{    boolean isMapOnly = ((JobConf) getConf()).getNumReduceTasks() == 0;    if (AvroKey.class.isAssignableFrom(inputClass)) {        Schema schema;        if (isMapOnly) {            schema = AvroJob.getMapOutputKeySchema(getConf());            if (null == schema) {                schema = AvroJob.getOutputKeySchema(getConf());            }        } else {            schema = AvroJob.getOutputKeySchema(getConf());        }        if (null == schema) {            throw new IllegalStateException("Writer schema for output key was not set. Use AvroJob.setOutputKeySchema().");        }        return (AvroDatumConverter<IN, OUT>) new AvroWrapperConverter(schema);    }    if (AvroValue.class.isAssignableFrom(inputClass)) {        Schema schema;        if (isMapOnly) {            schema = AvroJob.getMapOutputValueSchema(getConf());            if (null == schema) {                schema = AvroJob.getOutputValueSchema(getConf());            }        } else {            schema = AvroJob.getOutputValueSchema(getConf());        }        if (null == schema) {            throw new IllegalStateException("Writer schema for output value was not set. Use AvroJob.setOutputValueSchema().");        }        return (AvroDatumConverter<IN, OUT>) new AvroWrapperConverter(schema);    }    if (BooleanWritable.class.isAssignableFrom(inputClass)) {        return (AvroDatumConverter<IN, OUT>) new BooleanWritableConverter();    }    if (BytesWritable.class.isAssignableFrom(inputClass)) {        return (AvroDatumConverter<IN, OUT>) new BytesWritableConverter();    }    if (ByteWritable.class.isAssignableFrom(inputClass)) {        return (AvroDatumConverter<IN, OUT>) new ByteWritableConverter();    }    if (DoubleWritable.class.isAssignableFrom(inputClass)) {        return (AvroDatumConverter<IN, OUT>) new DoubleWritableConverter();    }    if (FloatWritable.class.isAssignableFrom(inputClass)) {        return (AvroDatumConverter<IN, OUT>) new FloatWritableConverter();    }    if (IntWritable.class.isAssignableFrom(inputClass)) {        return (AvroDatumConverter<IN, OUT>) new IntWritableConverter();    }    if (LongWritable.class.isAssignableFrom(inputClass)) {        return (AvroDatumConverter<IN, OUT>) new LongWritableConverter();    }    if (NullWritable.class.isAssignableFrom(inputClass)) {        return (AvroDatumConverter<IN, OUT>) new NullWritableConverter();    }    if (Text.class.isAssignableFrom(inputClass)) {        return (AvroDatumConverter<IN, OUT>) new TextConverter();    }    throw new UnsupportedOperationException("Unsupported input type: " + inputClass.getName());}
eff13b7c0a7c133af772c4fa56fb133747824bc97e15d644c26f19e0ca012c67
convert
public Object convert(AvroWrapper<?> input)
{    return input.datum();}
ed3c0ab53c4805f275920fe7ad5d6189de4ea944c88d3ed82ef2df2dd2523e14
getWriterSchema
public Schema getWriterSchema()
{    return mSchema;}
20561872d26f70b1fd592f3ca0edabc2dcebf4cb6a221831e235ef1a58564970
convert
public Boolean convert(BooleanWritable input)
{    return input.get();}
ed3c0ab53c4805f275920fe7ad5d6189de4ea944c88d3ed82ef2df2dd2523e14
getWriterSchema
public Schema getWriterSchema()
{    return mSchema;}
9ed757508183d3eb87344780027601629700c5e6a2afb79a719caaa7db570d1f
convert
public ByteBuffer convert(BytesWritable input)
{    return ByteBuffer.wrap(input.getBytes());}
ed3c0ab53c4805f275920fe7ad5d6189de4ea944c88d3ed82ef2df2dd2523e14
getWriterSchema
public Schema getWriterSchema()
{    return mSchema;}
462b9da32d93134734b54882649010b463dea261b7e03b2a464a3d2dc6e0c2d4
convert
public GenericFixed convert(ByteWritable input)
{    return new GenericData.Fixed(mSchema, new byte[] { input.get() });}
ed3c0ab53c4805f275920fe7ad5d6189de4ea944c88d3ed82ef2df2dd2523e14
getWriterSchema
public Schema getWriterSchema()
{    return mSchema;}
e6e5db1d01bbf0fe048fa9e9856d9f24fd6771dae9213485c41a337300029c3e
convert
public Double convert(DoubleWritable input)
{    return input.get();}
ed3c0ab53c4805f275920fe7ad5d6189de4ea944c88d3ed82ef2df2dd2523e14
getWriterSchema
public Schema getWriterSchema()
{    return mSchema;}
73e65b8320fb3489bf3167b473294c1cac58f5b7a3e5ff35333fd39166ab54d9
convert
public Float convert(FloatWritable input)
{    return input.get();}
ed3c0ab53c4805f275920fe7ad5d6189de4ea944c88d3ed82ef2df2dd2523e14
getWriterSchema
public Schema getWriterSchema()
{    return mSchema;}
b2810ad829d255fdb5fd0361186be311b615d2406d7749825be40bd3af691d13
convert
public Integer convert(IntWritable input)
{    return input.get();}
ed3c0ab53c4805f275920fe7ad5d6189de4ea944c88d3ed82ef2df2dd2523e14
getWriterSchema
public Schema getWriterSchema()
{    return mSchema;}
06c39659679e3d354c002a1088630a187cffdf5780e6a4eb0052bb71dee13170
convert
public Long convert(LongWritable input)
{    return input.get();}
ed3c0ab53c4805f275920fe7ad5d6189de4ea944c88d3ed82ef2df2dd2523e14
getWriterSchema
public Schema getWriterSchema()
{    return mSchema;}
c5bd6eff61db04dbdbb3345a12fb499e5408b7f93810fa7a096d3d024e51bfec
convert
public Object convert(NullWritable input)
{    return null;}
ed3c0ab53c4805f275920fe7ad5d6189de4ea944c88d3ed82ef2df2dd2523e14
getWriterSchema
public Schema getWriterSchema()
{    return mSchema;}
ece42c88ae777794a0cb3b403574ed25f7ed885b027af9741c0dcf4d5a2f2edf
convert
public CharSequence convert(Text input)
{    return input.toString();}
ed3c0ab53c4805f275920fe7ad5d6189de4ea944c88d3ed82ef2df2dd2523e14
getWriterSchema
public Schema getWriterSchema()
{    return mSchema;}
ed3c0ab53c4805f275920fe7ad5d6189de4ea944c88d3ed82ef2df2dd2523e14
getWriterSchema
public Schema getWriterSchema()
{    return mWriterSchema;}
609bc53c26c1611df5d71785c0fd210d472072777ab448c35ffef5da7ed45e8d
getReaderSchema
public Schema getReaderSchema()
{    return mReaderSchema;}
338a46cf86d0574d232d3081358c77222e82ddd80da550b3fadcf224e207b998
open
public void open(InputStream inputStream) throws IOException
{    mAvroDecoder = DecoderFactory.get().directBinaryDecoder(inputStream, mAvroDecoder);}
34f704a488036cc5dc938d58b39073b5cd9c9c221429b1791eb5f8d04a633f03
deserialize
public T deserialize(T avroWrapperToReuse) throws IOException
{        if (null == avroWrapperToReuse) {        avroWrapperToReuse = createAvroWrapper();    }        avroWrapperToReuse.datum(mAvroDatumReader.read(avroWrapperToReuse.datum(), mAvroDecoder));    return avroWrapperToReuse;}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    mAvroDecoder.inputStream().close();}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    super.setConf(conf);    if (null != conf) {                                mSchema = AvroJob.getMapOutputKeySchema(conf);        mDataModel = AvroSerialization.createDataModel(conf);    }}
8cd74526bc7e7f20597a504e1ed768d1c3a048c7a382f95e889101f52fd94ec3
compare
public int compare(byte[] b1, int s1, int l1, byte[] b2, int s2, int l2)
{    return BinaryData.compare(b1, s1, b2, s2, mSchema);}
d2c8c4120536eb71dd013f9a310e56bdd0502f9241e2bd54fcf1310e03e544fa
compare
public int compare(AvroKey<T> x, AvroKey<T> y)
{    return mDataModel.compare(x.datum(), y.datum(), mSchema);}
126da58ab8719d24311b3ad326110a2bd39f52238ed35aa4824b7b2a03dd08d5
createAvroWrapper
protected AvroWrapper<D> createAvroWrapper()
{    return new AvroKey<>(null);}
30c4e93305c9bbd4133a98e29355171d7913e21f5cabdae7542de639b32d50a9
get
public GenericRecord get()
{    return mKeyValueRecord;}
408af2012690314114a03f0ca626970e41121b2f610127a0eacfc4e43e74dbfe
getKey
public K getKey()
{    return (K) mKeyValueRecord.get(KEY_FIELD);}
5a159708665ed864d795a0702d525a75a1e0d877881ccd093ed97ed18e382934
getValue
public V getValue()
{    return (V) mKeyValueRecord.get(VALUE_FIELD);}
1ccb95d9d0b86425ab1f1d0da9ec56e6ea0e4f118d4059bab00823cc75ac1a31
setKey
public void setKey(K key)
{    mKeyValueRecord.put(KEY_FIELD, key);}
f3b7bc10b50507b4ebcfd7933f905497eb338e8546a2cef76c532b2e800cc12b
setValue
public void setValue(V value)
{    mKeyValueRecord.put(VALUE_FIELD, value);}
895ec94764d05abd8b762f45af6f860de4cc6cd5322339e3f609095285731bf5
getSchema
public static Schema getSchema(Schema keySchema, Schema valueSchema)
{    Schema schema = Schema.createRecord(KEY_VALUE_PAIR_RECORD_NAME, "A key/value pair", KEY_VALUE_PAIR_RECORD_NAMESPACE, false);    schema.setFields(Arrays.asList(new Schema.Field(KEY_FIELD, keySchema, "The key", null), new Schema.Field(VALUE_FIELD, valueSchema, "The value", null)));    return schema;}
d51e5f7450eca0a0f63da1a466189e262d053b84aa767ba3be5cea740af7251b
hasNext
public boolean hasNext()
{    return mGenericIterator.hasNext();}
87d27af21d8f7adb2da76e5fd4701a218070bb25a932dd1eb9c32f010e52da29
next
public AvroKeyValue<K, V> next()
{    GenericRecord genericRecord = mGenericIterator.next();    if (null == genericRecord) {        return null;    }    return new AvroKeyValue<>(genericRecord);}
eb35e4acc0ab2c89fd30970f01fba35488b3a4581b2af1986091209043508a3e
remove
public void remove()
{    mGenericIterator.remove();}
2fa1512ef9ed1d025a9c77ae6c533d308ce9a1caead7d7fba7dbd9c5c0dd2231
createWriter
public static SequenceFile.Writer createWriter(Writer.Options options) throws IOException
{    return SequenceFile.createWriter(options.getFileSystem(), options.getConfigurationWithAvroSerialization(), options.getOutputPath(), options.getKeyClass(), options.getValueClass(), options.getBufferSizeBytes(), options.getReplicationFactor(), options.getBlockSizeBytes(), options.getCompressionType(), options.getCompressionCodec(), options.getProgressable(), options.getMetadataWithAvroSchemas());}
2a583b032de31a7e518c8278e0042e3339edb899a80b112cd74ae560662c07a8
withFileSystem
public Options withFileSystem(FileSystem fileSystem)
{    if (null == fileSystem) {        throw new IllegalArgumentException("Filesystem may not be null");    }    mFileSystem = fileSystem;    return this;}
066e2930d8a5ca57a491feb2aafd204f4f5faad8a4bb103510677ebf32f70219
withConfiguration
public Options withConfiguration(Configuration conf)
{    if (null == conf) {        throw new IllegalArgumentException("Configuration may not be null");    }    mConf = conf;    return this;}
e5f70610cbae31b724bf202228eb5d3970de9e29f1e1fe90fdf8d3b809306ede
withOutputPath
public Options withOutputPath(Path outputPath)
{    if (null == outputPath) {        throw new IllegalArgumentException("Output path may not be null");    }    mOutputPath = outputPath;    return this;}
a1b52c3e699cc866493311ff9755680ade466fb660d0ac2dd081dd27b9df5f29
withKeyClass
public Options withKeyClass(Class<?> keyClass)
{    if (null == keyClass) {        throw new IllegalArgumentException("Key class may not be null");    }    mKeyClass = keyClass;    return this;}
67d1fa86bdc06267c4f8b6b71654f561ca09869403e5db3aabc62de1aa2b97d7
withKeySchema
public Options withKeySchema(Schema keyWriterSchema)
{    if (null == keyWriterSchema) {        throw new IllegalArgumentException("Key schema may not be null");    }    withKeyClass(AvroKey.class);    mKeyWriterSchema = keyWriterSchema;    return this;}
4ecfb5fe455989b1a9b06a004289814febf59100dabebe23b9aaf4f9c4518fbb
withValueClass
public Options withValueClass(Class<?> valueClass)
{    if (null == valueClass) {        throw new IllegalArgumentException("Value class may not be null");    }    mValueClass = valueClass;    return this;}
bc98897884374891a69f31ae813650cde0c4544c4557bfc747aca9ba73a4cc1c
withValueSchema
public Options withValueSchema(Schema valueWriterSchema)
{    if (null == valueWriterSchema) {        throw new IllegalArgumentException("Value schema may not be null");    }    withValueClass(AvroValue.class);    mValueWriterSchema = valueWriterSchema;    return this;}
f8c3b2500bf7366690d44f5d82e18ad45a16971c465105c667c009e9199c3515
withBufferSizeBytes
public Options withBufferSizeBytes(int bytes)
{    if (bytes < 0) {        throw new IllegalArgumentException("Buffer size may not be negative");    }    mBufferSizeBytes = bytes;    return this;}
76d59a72fb4732fe70a8d9f0641adefe763218316b7a3192bb438bb66f101025
withReplicationFactor
public Options withReplicationFactor(short replicationFactor)
{    if (replicationFactor <= 0) {        throw new IllegalArgumentException("Replication factor must be positive");    }    mReplicationFactor = replicationFactor;    return this;}
595e27d761ef1426b0b7f6108e1122e97ca03420cbffa756e1ccf49839a57ec4
withBlockSizeBytes
public Options withBlockSizeBytes(long bytes)
{    if (bytes <= 0) {        throw new IllegalArgumentException("Block size must be positive");    }    mBlockSizeBytes = bytes;    return this;}
672cc1247deb179f8c065c469b2065bc91b47e1620853670bdc539cc34b7f2ba
withProgressable
public Options withProgressable(Progressable progressable)
{    mProgressable = progressable;    return this;}
1b37fd6517db47f4e1f157c6f46465816b9c3cc3d16101d60dcbb525dcfc87dc
withCompressionType
public Options withCompressionType(CompressionType compressionType)
{    mCompressionType = compressionType;    return this;}
3131933e3c708ff482c06dace2db7dbc4daab6fbb8192b9758754facab556f95
withCompressionCodec
public Options withCompressionCodec(CompressionCodec compressionCodec)
{    mCompressionCodec = compressionCodec;    return this;}
fa6d9a392e1b22632b0277deddc559a52f133a0ae3b7b22561208c2aad84e3fd
withMetadata
public Options withMetadata(Metadata metadata)
{    if (null == metadata) {        throw new IllegalArgumentException("Metadata may not be null");    }    mMetadata = metadata;    return this;}
005888c3d3db99d143d764e597263f6aeb89e0a3689eee5db34601e278323238
getFileSystem
public FileSystem getFileSystem()
{    if (null == mFileSystem) {        throw new RuntimeException("Must call Options.withFileSystem()");    }    return mFileSystem;}
4ab32fd1c0fc8b7e0975a577f547cc7a82d509b4844a391bcce9e94e9bd47854
getConfiguration
public Configuration getConfiguration()
{    return mConf;}
dd51e17b86ec54a9f713f00d4f37f7ff5138690bf8f0f3fe8afe2a89ee50f5ff
getConfigurationWithAvroSerialization
public Configuration getConfigurationWithAvroSerialization()
{    Configuration conf = getConfiguration();    if (null == conf) {        throw new RuntimeException("Must call Options.withConfiguration()");    }    Configuration confWithAvro = new Configuration(conf);    if (null != mKeyWriterSchema) {        AvroSerialization.setKeyWriterSchema(confWithAvro, mKeyWriterSchema);    }    if (null != mValueWriterSchema) {        AvroSerialization.setValueWriterSchema(confWithAvro, mValueWriterSchema);    }    AvroSerialization.addToConfiguration(confWithAvro);    return confWithAvro;}
db28369403f9d37371cf6996d2bda50e8576441fe937e5cb2e75d5e93eddd2db
getOutputPath
public Path getOutputPath()
{    if (null == mOutputPath) {        throw new RuntimeException("Must call Options.withOutputPath()");    }    return mOutputPath;}
b2d9eca3fc418eac066cdaa2e0a9517cce4e7c177a81168c320b5a8c2206bb7a
getKeyClass
public Class<?> getKeyClass()
{    if (null == mKeyClass) {        throw new RuntimeException("Must call Options.withKeyClass() or Options.withKeySchema()");    }    return mKeyClass;}
40fa5b56c246f0284c17a1521c27885446448d4338b91e9d8e2978bcbfacc2cf
getValueClass
public Class<?> getValueClass()
{    if (null == mValueClass) {        throw new RuntimeException("Must call Options.withValueClass() or Options.withValueSchema()");    }    return mValueClass;}
67edb5f50fc30b26286c23efc0981c31fa63f5c1b65772318ac763bd3da7b4a8
getBufferSizeBytes
public int getBufferSizeBytes()
{    if (DEFAULT == mBufferSizeBytes) {        return getConfiguration().getInt(IO_FILE_BUFFER_SIZE_KEY, IO_FILE_BUFFER_SIZE_DEFAULT);    }    return mBufferSizeBytes;}
948bef0e72f3a95fed4ceab9fea93cc5e9f15992b22724aa34e72a5ec482a9ca
getReplicationFactor
public short getReplicationFactor()
{    if (DEFAULT == mReplicationFactor) {        return getFileSystem().getDefaultReplication();    }    return mReplicationFactor;}
dd722686e24fbac04afc5c19d02fbc03c2a717b33276e9f073ec8609c919d648
getBlockSizeBytes
public long getBlockSizeBytes()
{    if (DEFAULT == mBlockSizeBytes) {        return getFileSystem().getDefaultBlockSize();    }    return mBlockSizeBytes;}
0990c41d515fa6815ad4492ca4152640a6f434f08b584bc3c9c0d731ebc34646
getProgressable
public Progressable getProgressable()
{    return mProgressable;}
685fc9892d87958020f5d3eae4e8c9133e0af7f95e26356df42b49c0fe624a23
getCompressionType
public CompressionType getCompressionType()
{    return mCompressionType;}
a42e9aa3345595292363a3855b857a0effe92b890498a1aae271eb6cbf5c33cf
getCompressionCodec
public CompressionCodec getCompressionCodec()
{    return mCompressionCodec;}
3278491613baf75b185ed9d8d57b8e0f596c9babb670aa112cc72d53896855cf
getMetadata
public Metadata getMetadata()
{    return mMetadata;}
48b059775d4e2806820b7052d23296cddd9b9c3cb407ab0cee24fefad2c13f24
getMetadataWithAvroSchemas
private Metadata getMetadataWithAvroSchemas()
{        assert null != mMetadata;    if (null != mKeyWriterSchema) {        mMetadata.set(METADATA_FIELD_KEY_SCHEMA, new Text(mKeyWriterSchema.toString()));    }    if (null != mValueWriterSchema) {        mMetadata.set(METADATA_FIELD_VALUE_SCHEMA, new Text(mValueWriterSchema.toString()));    }    return mMetadata;}
2a583b032de31a7e518c8278e0042e3339edb899a80b112cd74ae560662c07a8
withFileSystem
public Options withFileSystem(FileSystem fileSystem)
{    if (null == fileSystem) {        throw new IllegalArgumentException("Filesystem may not be null");    }    mFileSystem = fileSystem;    return this;}
302f811808e7622e943a2353fe7348e0b8da7ea0865c7782f52cd5e99a5e096d
withInputPath
public Options withInputPath(Path inputPath)
{    if (null == inputPath) {        throw new IllegalArgumentException("Input path may not be null");    }    mInputPath = inputPath;    return this;}
066e2930d8a5ca57a491feb2aafd204f4f5faad8a4bb103510677ebf32f70219
withConfiguration
public Options withConfiguration(Configuration conf)
{    if (null == conf) {        throw new IllegalArgumentException("Configuration may not be null");    }    mConf = conf;    return this;}
6c341a7e5178a917ead242319783d98adacece3471604fe6fece29a2ee0d38ab
withKeySchema
public Options withKeySchema(Schema keyReaderSchema)
{    mKeyReaderSchema = keyReaderSchema;    return this;}
90ac1f43e3745783bd1980aa0c2786bb29728caf80e2ce408bf0c4363c3c9307
withValueSchema
public Options withValueSchema(Schema valueReaderSchema)
{    mValueReaderSchema = valueReaderSchema;    return this;}
005888c3d3db99d143d764e597263f6aeb89e0a3689eee5db34601e278323238
getFileSystem
public FileSystem getFileSystem()
{    if (null == mFileSystem) {        throw new RuntimeException("Must call Options.withFileSystem()");    }    return mFileSystem;}
d97d095b4dbbb8c9e4451ff3115d111390f5505e224112b43cd675a7024dfb15
getInputPath
public Path getInputPath()
{    if (null == mInputPath) {        throw new RuntimeException("Must call Options.withInputPath()");    }    return mInputPath;}
4ab32fd1c0fc8b7e0975a577f547cc7a82d509b4844a391bcce9e94e9bd47854
getConfiguration
public Configuration getConfiguration()
{    return mConf;}
fc7a21aa1766cd48c3a63948134f9051342d0e73254929802bf59ed7b51f98f6
getConfigurationWithAvroSerialization
public Configuration getConfigurationWithAvroSerialization() throws IOException
{    Configuration conf = getConfiguration();    if (null == conf) {        throw new RuntimeException("Must call Options.withConfiguration()");    }        Configuration confWithAvro = new Configuration(conf);    AvroSerialization.addToConfiguration(confWithAvro);        Metadata metadata = AvroSequenceFile.getMetadata(getFileSystem(), getInputPath(), confWithAvro);        Text keySchemaText = metadata.get(METADATA_FIELD_KEY_SCHEMA);    if (null != keySchemaText) {        LOG.debug("Using key writer schema from SequenceFile metadata: " + keySchemaText.toString());        AvroSerialization.setKeyWriterSchema(confWithAvro, new Schema.Parser().parse(keySchemaText.toString()));        if (null != mKeyReaderSchema) {            AvroSerialization.setKeyReaderSchema(confWithAvro, mKeyReaderSchema);        }    }        Text valueSchemaText = metadata.get(METADATA_FIELD_VALUE_SCHEMA);    if (null != valueSchemaText) {        LOG.debug("Using value writer schema from SequenceFile metadata: " + valueSchemaText.toString());        AvroSerialization.setValueWriterSchema(confWithAvro, new Schema.Parser().parse(valueSchemaText.toString()));        if (null != mValueReaderSchema) {            AvroSerialization.setValueReaderSchema(confWithAvro, mValueReaderSchema);        }    }    return confWithAvro;}
544ce613aa3e8c6a9191f77dd6bdc4d7169553d35f4fc3c045290b18d08f4695
getMetadata
private static Metadata getMetadata(FileSystem fs, Path path, Configuration conf) throws IOException
{    try (SequenceFile.Reader metadataReader = new SequenceFile.Reader(fs, path, conf)) {        return metadataReader.getMetadata();    }}
d4a9a2025868f52f4f027b79964e10f636bb7daee456976aadc01e2089aa003c
accept
public boolean accept(Class<?> c)
{    return AvroKey.class.isAssignableFrom(c) || AvroValue.class.isAssignableFrom(c);}
3541db5476c97e20861d774d1a0699553eba6503a257a6df67bfe0fc4b200210
getDeserializer
public Deserializer<AvroWrapper<T>> getDeserializer(Class<AvroWrapper<T>> c)
{    Configuration conf = getConf();    GenericData dataModel = createDataModel(conf);    if (AvroKey.class.isAssignableFrom(c)) {        Schema writerSchema = getKeyWriterSchema(conf);        Schema readerSchema = getKeyReaderSchema(conf);        DatumReader<T> datumReader = (readerSchema != null) ? dataModel.createDatumReader(writerSchema, readerSchema) : dataModel.createDatumReader(writerSchema);        return new AvroKeyDeserializer<>(writerSchema, readerSchema, datumReader);    } else if (AvroValue.class.isAssignableFrom(c)) {        Schema writerSchema = getValueWriterSchema(conf);        Schema readerSchema = getValueReaderSchema(conf);        DatumReader<T> datumReader = (readerSchema != null) ? dataModel.createDatumReader(writerSchema, readerSchema) : dataModel.createDatumReader(writerSchema);        return new AvroValueDeserializer<>(writerSchema, readerSchema, datumReader);    } else {        throw new IllegalStateException("Only AvroKey and AvroValue are supported.");    }}
e1083aa42d589f1021abbb850d6d621a88376c3af9c7072ebc9e47e782b68a61
getSerializer
public Serializer<AvroWrapper<T>> getSerializer(Class<AvroWrapper<T>> c)
{    Configuration conf = getConf();    Schema schema;    if (AvroKey.class.isAssignableFrom(c)) {        schema = getKeyWriterSchema(conf);    } else if (AvroValue.class.isAssignableFrom(c)) {        schema = getValueWriterSchema(conf);    } else {        throw new IllegalStateException("Only AvroKey and AvroValue are supported.");    }    GenericData dataModel = createDataModel(conf);    DatumWriter<T> datumWriter = dataModel.createDatumWriter(schema);    return new AvroSerializer<>(schema, datumWriter);}
8a6ba6bd2154e7e4e03c3c68d6d1b1848262164851db6029d9981c2f50174f8f
addToConfiguration
public static void addToConfiguration(Configuration conf)
{    Collection<String> serializations = conf.getStringCollection("io.serializations");    if (!serializations.contains(AvroSerialization.class.getName())) {        serializations.add(AvroSerialization.class.getName());        conf.setStrings("io.serializations", serializations.toArray(new String[0]));    }}
a241e29689b64ecfa57071dd53def711e5104346d9db3b82165199dec56b6c8f
setKeyWriterSchema
public static void setKeyWriterSchema(Configuration conf, Schema schema)
{    if (null == schema) {        throw new IllegalArgumentException("Writer schema may not be null");    }    conf.set(CONF_KEY_WRITER_SCHEMA, schema.toString());}
ab048f540cdcec057d9ad4b493b0c92fc1cc250b4812268075be883ce6c7296d
setKeyReaderSchema
public static void setKeyReaderSchema(Configuration conf, Schema schema)
{    conf.set(CONF_KEY_READER_SCHEMA, schema.toString());}
854565e403b6b33434007c44d8432ef478decc79959cd71ed99ba4be58923eb8
setValueWriterSchema
public static void setValueWriterSchema(Configuration conf, Schema schema)
{    if (null == schema) {        throw new IllegalArgumentException("Writer schema may not be null");    }    conf.set(CONF_VALUE_WRITER_SCHEMA, schema.toString());}
901dc0fad9019068998be54854e719c4807fa7c708643916cea74036d5d9c058
setValueReaderSchema
public static void setValueReaderSchema(Configuration conf, Schema schema)
{    conf.set(CONF_VALUE_READER_SCHEMA, schema.toString());}
d6909e4289bcfe1e02abad20fc04a613995e632ae202ceb7ef4b1d91692e7b9d
setDataModelClass
public static void setDataModelClass(Configuration conf, Class<? extends GenericData> modelClass)
{    conf.setClass(CONF_DATA_MODEL, modelClass, GenericData.class);}
c6eb269e7c718ae3a44a31ff43f5bacf7dd894a22a211eed2370177802820503
getKeyWriterSchema
public static Schema getKeyWriterSchema(Configuration conf)
{    String json = conf.get(CONF_KEY_WRITER_SCHEMA);    return null == json ? null : new Schema.Parser().parse(json);}
2444de8848207086dbef4a2f3b5c815d2847d3c06b328fa73dc5d13e8fe17a24
getKeyReaderSchema
public static Schema getKeyReaderSchema(Configuration conf)
{    String json = conf.get(CONF_KEY_READER_SCHEMA);    return null == json ? null : new Schema.Parser().parse(json);}
cfda58e8d057e7d42d162fb0afa8d240a779a6bf83b157fcd9a8ae7ad653bdd8
getValueWriterSchema
public static Schema getValueWriterSchema(Configuration conf)
{    String json = conf.get(CONF_VALUE_WRITER_SCHEMA);    return null == json ? null : new Schema.Parser().parse(json);}
9e4be4d330f914097418d69af6fc4a3943f50f5db6e7371c759f90f8e82de912
getValueReaderSchema
public static Schema getValueReaderSchema(Configuration conf)
{    String json = conf.get(CONF_VALUE_READER_SCHEMA);    return null == json ? null : new Schema.Parser().parse(json);}
04531e6edbb8aaa7ec7e9d2975ee2ba86403ff7b83374adaa1ac68b566cc0f14
getDataModelClass
public static Class<? extends GenericData> getDataModelClass(Configuration conf)
{    return conf.getClass(CONF_DATA_MODEL, ReflectData.class, GenericData.class);}
d9f3f001fe1b5576269856444264404ddea87b20a0765b5567b5f149a5d03613
newDataModelInstance
private static GenericData newDataModelInstance(Class<? extends GenericData> modelClass, Configuration conf)
{    GenericData dataModel;    try {        Constructor<? extends GenericData> ctor = modelClass.getDeclaredConstructor(ClassLoader.class);        ctor.setAccessible(true);        dataModel = ctor.newInstance(conf.getClassLoader());    } catch (Exception e) {        throw new RuntimeException(e);    }    ReflectionUtils.setConf(dataModel, conf);    return dataModel;}
9ae4bcfe0be98ccc78319960b48a2ecbc1158cf29ff3e99472974d5bf4900495
createDataModel
public static GenericData createDataModel(Configuration conf)
{    Class<? extends GenericData> modelClass = getDataModelClass(conf);    return newDataModelInstance(modelClass, conf);}
ed3c0ab53c4805f275920fe7ad5d6189de4ea944c88d3ed82ef2df2dd2523e14
getWriterSchema
public Schema getWriterSchema()
{    return mWriterSchema;}
2ee7c04218347d7a1bca5b251f93c5b42ec72bc664a45a919b52ba68ab4bd02f
open
public void open(OutputStream outputStream) throws IOException
{    mOutputStream = outputStream;    mAvroEncoder = ENCODER_FACTORY.binaryEncoder(outputStream, mAvroEncoder);}
265c0cfede2f5f656c29d128d2565ed3bb6d2dcebff9e3c65daf8d352cab887b
serialize
public void serialize(AvroWrapper<T> avroWrapper) throws IOException
{    mAvroDatumWriter.write(avroWrapper.datum(), mAvroEncoder);                    mAvroEncoder.flush();}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    mOutputStream.close();}
126da58ab8719d24311b3ad326110a2bd39f52238ed35aa4824b7b2a03dd08d5
createAvroWrapper
protected AvroWrapper<D> createAvroWrapper()
{    return new AvroValue<>(null);}
38efdbac3ee0ad95a6874ca5a183498eb7b060d836d36b982c373252d084e602
compare
public int compare(T o1, T o2)
{    if (!(o1 instanceof CharSequence) || !(o2 instanceof CharSequence)) {        throw new RuntimeException("Attempted use of AvroCharSequenceComparator on non-CharSequence objects: " + o1.getClass().getName() + " and " + o2.getClass().getName());    }    return compareCharSequence((CharSequence) o1, (CharSequence) o2);}
39265133bcfcaa033c24488b1a47f2e1684a790357a047f4de8000763c6e8d16
compareCharSequence
private int compareCharSequence(CharSequence o1, CharSequence o2)
{    for (int i = 0; i < Math.max(o1.length(), o2.length()); i++) {        int charComparison = compareCharacter(o1, o2, i);        if (0 != charComparison) {            return charComparison;        }    }    return 0;}
e7260ea0fbdbce71bc70d28c4fdd0b938c96c2a9e41522182a2fe00cb2cc8abb
compareCharacter
private int compareCharacter(CharSequence o1, CharSequence o2, int index)
{    if (index < o1.length() && index < o2.length()) {        return Character.compare(o1.charAt(index), o2.charAt(index));    }    if (index >= o1.length() && index >= o2.length()) {        return 0;    }    return o1.length() - o2.length();}
5661a76f0bcc12fcf3dadab9dfa86940dbf494c03c97d219f02bb45245883e4b
listStatus
protected FileStatus[] listStatus(JobConf job) throws IOException
{    if (job.getBoolean(AvroInputFormat.IGNORE_FILES_WITHOUT_EXTENSION_KEY, AvroInputFormat.IGNORE_INPUTS_WITHOUT_EXTENSION_DEFAULT)) {        List<FileStatus> result = new ArrayList<>();        for (FileStatus file : super.listStatus(job)) if (file.getPath().getName().endsWith(AvroOutputFormat.EXT))            result.add(file);        return result.toArray(new FileStatus[0]);    } else {        return super.listStatus(job);    }}
88b7282257ef9caeb491e7350bb85fcf8b882eacb1931e6833baa60018c99929
getRecordReader
public RecordReader<Text, Text> getRecordReader(InputSplit split, JobConf job, Reporter reporter) throws IOException
{    reporter.setStatus(split.toString());    return new AvroAsTextRecordReader(job, (FileSplit) split);}
7bedc625521f341c3528178b629e8c2c53322b88fa6ebc73414d70092712211d
createKey
public Text createKey()
{    return new Text();}
611709fc7595550895ec08a3c0680e98f70becd8f78c010a1696f35b79086809
createValue
public Text createValue()
{    return new Text();}
ff5dc80ac55c185096cf7024b3059332cbd72838c3fa5a20ce8bf785fca5d57b
next
public boolean next(Text key, Text ignore) throws IOException
{    if (!reader.hasNext() || reader.pastSync(end))        return false;    datum = reader.next(datum);    if (datum instanceof ByteBuffer) {        ByteBuffer b = (ByteBuffer) datum;        if (b.hasArray()) {            int offset = b.arrayOffset();            int start = b.position();            int length = b.remaining();            key.set(b.array(), offset + start, offset + start + length);        } else {            byte[] bytes = new byte[b.remaining()];            b.duplicate().get(bytes);            key.set(bytes);        }    } else {        key.set(GenericData.get().toString(datum));    }    return true;}
46dc59cbf7e4d6aafe0869ef2726ed2c5c897b673d9e37f94ab9b0e962f65f7f
getProgress
public float getProgress() throws IOException
{    if (end == start) {        return 0.0f;    } else {        return Math.min(1.0f, (getPos() - start) / (float) (end - start));    }}
5800a0f531c192e683ef74c0c5de6015daf6261d1f8e5c0ce6d8e043b01926c7
getPos
public long getPos() throws IOException
{    return reader.tell();}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    reader.close();}
5661a76f0bcc12fcf3dadab9dfa86940dbf494c03c97d219f02bb45245883e4b
listStatus
protected FileStatus[] listStatus(JobConf job) throws IOException
{    if (job.getBoolean(IGNORE_FILES_WITHOUT_EXTENSION_KEY, IGNORE_INPUTS_WITHOUT_EXTENSION_DEFAULT)) {        List<FileStatus> result = new ArrayList<>();        for (FileStatus file : super.listStatus(job)) if (file.getPath().getName().endsWith(AvroOutputFormat.EXT))            result.add(file);        return result.toArray(new FileStatus[0]);    } else {        return super.listStatus(job);    }}
3126d8b36d125d84754e43a16d55b84f0683238646388da695d21b496fbff4ef
getRecordReader
public RecordReader<AvroWrapper<T>, NullWritable> getRecordReader(InputSplit split, JobConf job, Reporter reporter) throws IOException
{    reporter.setStatus(split.toString());    return new AvroRecordReader<>(job, (FileSplit) split);}
0447f8fbdac2b23d27454411e33d9bba48536dbbe74ee9e7a95635edb8cbecb1
setInputSchema
public static void setInputSchema(JobConf job, Schema s)
{    job.set(INPUT_SCHEMA, s.toString());    configureAvroInput(job);}
ed2ce006788f0cb803121f209c537a453eba4753fabcdd2b1ce4c04be996959d
getInputSchema
public static Schema getInputSchema(Configuration job)
{    String schemaString = job.get(INPUT_SCHEMA);    return schemaString != null ? new Schema.Parser().parse(schemaString) : null;}
3e04258f92744be9b1639ba119b47c480b6cf42e5e8633498134f66dbfb7ed76
setMapOutputSchema
public static void setMapOutputSchema(JobConf job, Schema s)
{    job.set(MAP_OUTPUT_SCHEMA, s.toString());    configureAvroShuffle(job);}
354d673874ef7410a4fdf4ba996f241bcc67c2cff038251cc95eee900d0560c7
getMapOutputSchema
public static Schema getMapOutputSchema(Configuration job)
{    return new Schema.Parser().parse(job.get(MAP_OUTPUT_SCHEMA, job.get(OUTPUT_SCHEMA)));}
40cf077e459120f5b73a8ac4856dfdd40564d319965cbbbce9dc67cf82460e2f
setOutputSchema
public static void setOutputSchema(JobConf job, Schema s)
{    job.set(OUTPUT_SCHEMA, s.toString());    configureAvroOutput(job);}
2854991367c5736ff435dfd51543b3fd627d6f80fbdabd8402913f73269dd270
setOutputCodec
public static void setOutputCodec(JobConf job, String codec)
{    job.set(OUTPUT_CODEC, codec);}
97843247551db98a06b9dcaf13ccd2db9cd26a84eb0b182c0394e0f942cb4e58
setOutputMeta
public static void setOutputMeta(JobConf job, String key, String value)
{    job.set(TEXT_PREFIX + key, value);}
fc552c1d53f56c00c825d93cd3b3fc2e0b9bf389318241f0ad08325a1411f3f3
setOutputMeta
public static void setOutputMeta(JobConf job, String key, long value)
{    job.set(TEXT_PREFIX + key, Long.toString(value));}
5c443c556b2b156f8cdeda81c21a7d2f1280a9789737c4750812ebddfd205d3b
setOutputMeta
public static void setOutputMeta(JobConf job, String key, byte[] value)
{    try {        job.set(BINARY_PREFIX + key, URLEncoder.encode(new String(value, StandardCharsets.ISO_8859_1), StandardCharsets.ISO_8859_1.name()));    } catch (UnsupportedEncodingException e) {    }}
ca21f7a98879e0df18fea753879037e0bb8b185753d0063c4541fb62dd4daee2
setInputSequenceFile
public static void setInputSequenceFile(JobConf job)
{    job.setInputFormat(SequenceFileInputFormat.class);}
ad1d3d1085a6f2d44da7731b7d02a9ca2f08468551b36002a9acf1a42c7481d2
setReflect
public static void setReflect(JobConf job)
{    setInputReflect(job);    setMapOutputReflect(job);}
ebabe920b96a766dad6ff68f27798a22eec5985a17a1c31825bec1edd80a9365
setInputReflect
public static void setInputReflect(JobConf job)
{    job.setBoolean(INPUT_IS_REFLECT, true);}
6421c58012661dca46dffd3ab15c2d1bd6e0357ae1156f9a616d385c466bcfc5
setMapOutputReflect
public static void setMapOutputReflect(JobConf job)
{    job.setBoolean(MAP_OUTPUT_IS_REFLECT, true);}
de4bfd0ce5e962f8db094fd8ba3cb9e1dce1d27b59d7d11d751b55cb86bcf22e
getOutputSchema
public static Schema getOutputSchema(Configuration job)
{    return new Schema.Parser().parse(job.get(OUTPUT_SCHEMA));}
bda466e28b72efb4d56d93f1cc0822659a9dc0b1ebb76a451c0c3f7a9431d37d
configureAvroInput
private static void configureAvroInput(JobConf job)
{    if (job.get("mapred.input.format.class") == null)        job.setInputFormat(AvroInputFormat.class);    if (job.getMapperClass() == IdentityMapper.class)        job.setMapperClass(HadoopMapper.class);    configureAvroShuffle(job);}
7b70aafc89e4e75ed4081c16cb55700132e3a967743cb48eeae85ff4a63b445c
configureAvroOutput
private static void configureAvroOutput(JobConf job)
{    if (job.get("mapred.output.format.class") == null)        job.setOutputFormat(AvroOutputFormat.class);    if (job.getReducerClass() == IdentityReducer.class)        job.setReducerClass(HadoopReducer.class);    job.setOutputKeyClass(AvroWrapper.class);    configureAvroShuffle(job);}
52a67512f6b7b1992caa7bffa0054140ab5a712eb034f9872262ecb480c786f1
configureAvroShuffle
private static void configureAvroShuffle(JobConf job)
{    job.setOutputKeyComparatorClass(AvroKeyComparator.class);    job.setMapOutputKeyClass(AvroKey.class);    job.setMapOutputValueClass(AvroValue.class);        Collection<String> serializations = job.getStringCollection("io.serializations");    if (!serializations.contains(AvroSerialization.class.getName())) {        serializations.add(AvroSerialization.class.getName());        job.setStrings("io.serializations", serializations.toArray(new String[0]));    }}
af2d827e2cac0b813522319ef692080b0e12e7334d7fadc2eb1acd07df71e97e
setMapperClass
public static void setMapperClass(JobConf job, Class<? extends AvroMapper> c)
{    job.set(MAPPER, c.getName());}
14d93969413f2462ce7bfad4f867d4644dca57846e6eebe310eb57688b296ed9
setCombinerClass
public static void setCombinerClass(JobConf job, Class<? extends AvroReducer> c)
{    job.set(COMBINER, c.getName());    job.setCombinerClass(HadoopCombiner.class);}
474fd2bcebba07b1af471c09879d86394b620b641510a0fe3928e013b727d786
setReducerClass
public static void setReducerClass(JobConf job, Class<? extends AvroReducer> c)
{    job.set(REDUCER, c.getName());}
db7b2de8bc8805db1ba35596d7745742a730879a3304a810628badf127f60df3
setDataModelClass
public static void setDataModelClass(JobConf job, Class<? extends GenericData> modelClass)
{    job.setClass(CONF_DATA_MODEL, modelClass, GenericData.class);}
04531e6edbb8aaa7ec7e9d2975ee2ba86403ff7b83374adaa1ac68b566cc0f14
getDataModelClass
public static Class<? extends GenericData> getDataModelClass(Configuration conf)
{    return conf.getClass(CONF_DATA_MODEL, ReflectData.class, GenericData.class);}
d9f3f001fe1b5576269856444264404ddea87b20a0765b5567b5f149a5d03613
newDataModelInstance
private static GenericData newDataModelInstance(Class<? extends GenericData> modelClass, Configuration conf)
{    GenericData dataModel;    try {        Constructor<? extends GenericData> ctor = modelClass.getDeclaredConstructor(ClassLoader.class);        ctor.setAccessible(true);        dataModel = ctor.newInstance(conf.getClassLoader());    } catch (Exception e) {        throw new RuntimeException(e);    }    ReflectionUtils.setConf(dataModel, conf);    return dataModel;}
9ae4bcfe0be98ccc78319960b48a2ecbc1158cf29ff3e99472974d5bf4900495
createDataModel
public static GenericData createDataModel(Configuration conf)
{    return newDataModelInstance(getDataModelClass(conf), conf);}
03323c73ebd95442d65e78ce58ea4e0faf11f1cd7cd34f84bce510ba71377c5c
createInputDataModel
public static GenericData createInputDataModel(Configuration conf)
{    String className = conf.get(CONF_DATA_MODEL, null);    Class<? extends GenericData> modelClass;    if (className != null) {        modelClass = getDataModelClass(conf);    } else if (conf.getBoolean(INPUT_IS_REFLECT, false)) {        modelClass = ReflectData.class;    } else {        modelClass = SpecificData.class;    }    return newDataModelInstance(modelClass, conf);}
2cff69e4ca4193604242d77bd2145feda381b0e4223fff078a38eb3bf45f857d
createMapOutputDataModel
public static GenericData createMapOutputDataModel(Configuration conf)
{    String className = conf.get(CONF_DATA_MODEL, null);    Class<? extends GenericData> modelClass;    if (className != null) {        modelClass = getDataModelClass(conf);    } else if (conf.getBoolean(MAP_OUTPUT_IS_REFLECT, false)) {        modelClass = ReflectData.class;    } else {        modelClass = SpecificData.class;    }    return newDataModelInstance(modelClass, conf);}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    super.setConf(conf);    if (conf != null)        schema = Pair.getKeySchema(AvroJob.getMapOutputSchema(conf));}
8cd74526bc7e7f20597a504e1ed768d1c3a048c7a382f95e889101f52fd94ec3
compare
public int compare(byte[] b1, int s1, int l1, byte[] b2, int s2, int l2)
{    return BinaryData.compare(b1, s1, l1, b2, s2, l2, schema);}
20abe5d6eefe97afc75dc39219985e874fe38976b90ee6594f950aa3059f9a25
compare
public int compare(AvroWrapper<T> x, AvroWrapper<T> y)
{    return ReflectData.get().compare(x.datum(), y.datum(), schema);}
a2f83058e7c6df37a2e60e36d109653e2891d78b9217cb13c1197d300ea17431
map
public void map(IN datum, AvroCollector<OUT> collector, Reporter reporter) throws IOException
{    collector.collect((OUT) datum);}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{}
711139ba85089e8c83d383c716e53a6995c50f3b5bdb4f79367877d626bd4bd1
configure
public void configure(JobConf jobConf)
{}
7c10d0c327338d0b5c2563bd7c7edc34b7cac776ae68548ae9c34d0cd719541e
addInputPath
private static void addInputPath(JobConf conf, Path path, Schema inputSchema)
{    String schemaMapping = path.toString() + ";" + toBase64(inputSchema.toString());    String schemas = conf.get(SCHEMA_KEY);    conf.set(SCHEMA_KEY, schemas == null ? schemaMapping : schemas + "," + schemaMapping);    conf.setInputFormat(DelegatingInputFormat.class);}
34580ecb71a016ea9979c36ce07bda7ef708e84789985adb1123bc7d2e7d338c
addInputPath
public static void addInputPath(JobConf conf, Path path, Class<? extends AvroMapper> mapperClass, Schema inputSchema)
{    addInputPath(conf, path, inputSchema);    String mapperMapping = path.toString() + ";" + mapperClass.getName();    System.out.println(mapperMapping);    String mappers = conf.get(MAPPERS_KEY);    conf.set(MAPPERS_KEY, mappers == null ? mapperMapping : mappers + "," + mapperMapping);    conf.setMapperClass(DelegatingMapper.class);}
6964ee729b5704ee8855eb72e67269ee5105c4a77c8ac53c57caba5a96b4d822
getMapperTypeMap
 static Map<Path, Class<? extends AvroMapper>> getMapperTypeMap(JobConf conf)
{    if (conf.get(MAPPERS_KEY) == null) {        return Collections.emptyMap();    }    Map<Path, Class<? extends AvroMapper>> m = new HashMap<>();    String[] pathMappings = conf.get(MAPPERS_KEY).split(",");    for (String pathMapping : pathMappings) {        String[] split = pathMapping.split(";");        Class<? extends AvroMapper> mapClass;        try {            mapClass = (Class<? extends AvroMapper>) conf.getClassByName(split[1]);        } catch (ClassNotFoundException e) {            throw new RuntimeException(e);        }        m.put(new Path(split[0]), mapClass);    }    return m;}
11b7d5e00a877e7212f254b8e1946ba136fcedd704d4c9ed4511267fa08f355d
getInputSchemaMap
 static Map<Path, Schema> getInputSchemaMap(JobConf conf)
{    if (conf.get(SCHEMA_KEY) == null) {        return Collections.emptyMap();    }    Map<Path, Schema> m = new HashMap<>();    String[] schemaMappings = conf.get(SCHEMA_KEY).split(",");    Schema.Parser schemaParser = new Schema.Parser();    for (String schemaMapping : schemaMappings) {        String[] split = schemaMapping.split(";");        String schemaString = fromBase64(split[1]);        Schema inputSchema;        try {            inputSchema = schemaParser.parse(schemaString);        } catch (SchemaParseException e) {            throw new RuntimeException(e);        }        m.put(new Path(split[0]), inputSchema);    }    return m;}
ed3518e4ea2a28896a2b98e2b749efc57d301c7a01b10332ae8a8b89a6fef6e6
toBase64
private static String toBase64(String rawString)
{    final byte[] buf = rawString.getBytes(UTF_8);    return new String(Base64.getMimeEncoder().encode(buf), UTF_8);}
2f10b97ddcb99b5edcbbb39649b944727e36d13434c1b2cac0f3c093c32a0bbe
fromBase64
private static String fromBase64(String base64String)
{    final byte[] buf = base64String.getBytes(UTF_8);    return new String(Base64.getMimeDecoder().decode(buf), UTF_8);}
1ed62770c0c88543be243149df8af8088eb90f56b95b4fe1682ce43055ab2bcd
checkNamedOutput
private static void checkNamedOutput(JobConf conf, String namedOutput, boolean alreadyDefined)
{    List<String> definedChannels = getNamedOutputsList(conf);    if (alreadyDefined && definedChannels.contains(namedOutput)) {        throw new IllegalArgumentException("Named output '" + namedOutput + "' already alreadyDefined");    } else if (!alreadyDefined && !definedChannels.contains(namedOutput)) {        throw new IllegalArgumentException("Named output '" + namedOutput + "' not defined");    }}
475ccce25bb06ed93161835e138832bde7f55dbcc9c569fa0573b1a0c337f9ff
checkTokenName
private static void checkTokenName(String namedOutput)
{    if (namedOutput == null || namedOutput.length() == 0) {        throw new IllegalArgumentException("Name cannot be NULL or empty");    }    for (char ch : namedOutput.toCharArray()) {        if ((ch >= 'A') && (ch <= 'Z')) {            continue;        }        if ((ch >= 'a') && (ch <= 'z')) {            continue;        }        if ((ch >= '0') && (ch <= '9')) {            continue;        }        throw new IllegalArgumentException("Name cannot have a '" + ch + "' char");    }}
7d87f86eb63ad6c20e13b2295eee5aed99a5b2d2e136f3bebbdff5386a3d6020
checkNamedOutputName
private static void checkNamedOutputName(String namedOutput)
{    checkTokenName(namedOutput);        if (namedOutput.equals("part")) {        throw new IllegalArgumentException("Named output name cannot be 'part'");    }}
2d63ffbcad085301310dba422f6faae41e6432570d8c62e1614e1e8ec9521528
getNamedOutputsList
public static List<String> getNamedOutputsList(JobConf conf)
{    List<String> names = new ArrayList<>();    StringTokenizer st = new StringTokenizer(conf.get(NAMED_OUTPUTS, ""), " ");    while (st.hasMoreTokens()) {        names.add(st.nextToken());    }    return names;}
4015bccaf77145555708ed7e514f0abac2c3af85c1ccab566f7e43dcf12dc905
isMultiNamedOutput
public static boolean isMultiNamedOutput(JobConf conf, String namedOutput)
{    checkNamedOutput(conf, namedOutput, false);    return conf.getBoolean(MO_PREFIX + namedOutput + MULTI, false);}
9063bda18a45be47faf322a2e6a59d78870da2bed12d2f302ba916c0b32f0198
getNamedOutputFormatClass
public static Class<? extends OutputFormat> getNamedOutputFormatClass(JobConf conf, String namedOutput)
{    checkNamedOutput(conf, namedOutput, false);    return conf.getClass(MO_PREFIX + namedOutput + FORMAT, null, OutputFormat.class);}
0a4779a23075e3795847e70a6dcd9395cb41526c4f09e3df3fedc02caf92d063
addNamedOutput
public static void addNamedOutput(JobConf conf, String namedOutput, Class<? extends OutputFormat> outputFormatClass, Schema schema)
{    addNamedOutput(conf, namedOutput, false, outputFormatClass, schema);}
f747c1c1144eba1cb9d34705c26270658516d1c4ec2a4d9025b38e0cfd65c8da
addMultiNamedOutput
public static void addMultiNamedOutput(JobConf conf, String namedOutput, Class<? extends OutputFormat> outputFormatClass, Schema schema)
{    addNamedOutput(conf, namedOutput, true, outputFormatClass, schema);}
5087c5a143f99638b6a4cca6abae6bea805c12f8fd908fff97765ca7ef502d5e
addNamedOutput
private static void addNamedOutput(JobConf conf, String namedOutput, boolean multi, Class<? extends OutputFormat> outputFormatClass, Schema schema)
{    checkNamedOutputName(namedOutput);    checkNamedOutput(conf, namedOutput, true);    boolean isMapOnly = conf.getNumReduceTasks() == 0;    if (schema != null)        conf.set(MO_PREFIX + namedOutput + ".schema", schema.toString());    conf.set(NAMED_OUTPUTS, conf.get(NAMED_OUTPUTS, "") + " " + namedOutput);    conf.setClass(MO_PREFIX + namedOutput + FORMAT, outputFormatClass, OutputFormat.class);    conf.setBoolean(MO_PREFIX + namedOutput + MULTI, multi);}
de0b2c4a581ff80392e911aafcdbb967a40872a878c8dc9d0e44c17ff794e3af
setCountersEnabled
public static void setCountersEnabled(JobConf conf, boolean enabled)
{    conf.setBoolean(COUNTERS_ENABLED, enabled);}
5a6285e79ed2015df2090196da1a9e569db4caf3c4ae9f33b4915c5fd7cac51d
getCountersEnabled
public static boolean getCountersEnabled(JobConf conf)
{    return conf.getBoolean(COUNTERS_ENABLED, false);}
7a56ad8d6d7d9082fcdb90af02c1751c9a710634ebda0c39f4ac840cf2073a6d
getNamedOutputs
public Iterator<String> getNamedOutputs()
{    return namedOutputs.iterator();}
f407ab0d6ac058e8ef1cbe4edf5205ec54ee920853dbb7b51f2db9c7cbce76db
getRecordWriter
private synchronized RecordWriter getRecordWriter(String namedOutput, String baseFileName, final Reporter reporter, Schema schema) throws IOException
{    RecordWriter writer = recordWriters.get(baseFileName);    if (writer == null) {        if (countersEnabled && reporter == null) {            throw new IllegalArgumentException("Counters are enabled, Reporter cannot be NULL");        }        if (schema != null)            conf.set(MO_PREFIX + namedOutput + ".schema", schema.toString());        JobConf jobConf = new JobConf(conf);        jobConf.set(InternalFileOutputFormat.CONFIG_NAMED_OUTPUT, namedOutput);        FileSystem fs = FileSystem.get(conf);        writer = outputFormat.getRecordWriter(fs, jobConf, baseFileName, reporter);        if (countersEnabled) {            if (reporter == null) {                throw new IllegalArgumentException("Counters are enabled, Reporter cannot be NULL");            }            writer = new RecordWriterWithCounter(writer, baseFileName, reporter);        }        recordWriters.put(baseFileName, writer);    }    return writer;}
6d5d885e99c923e3a046e17ad7b77ae0fa97e4aecbcda2785a48bab66cd813d6
write
public void write(Object key, Object value) throws IOException
{    reporter.incrCounter(COUNTERS_GROUP, counterName, 1);    writer.write(key, value);}
d217b17bf131ccc7d63327b9a21715cc03224e14acdccb70a58b2ad62544d0f8
close
public void close(Reporter reporter) throws IOException
{    writer.close(reporter);}
1dba3e40658bd6d0498a7e9d10a146890fddfb291924afe6f1e4faefba01d3e3
collect
public void collect(String namedOutput, Reporter reporter, Object datum) throws IOException
{    getCollector(namedOutput, reporter).collect(datum);}
ded9039e8bea0f722a89a60226231baa860654be34b1d85a36823dc34753f904
collect
public void collect(String namedOutput, Reporter reporter, Schema schema, Object datum) throws IOException
{    getCollector(namedOutput, reporter, schema).collect(datum);}
eaec8b20ef5165ae28e58be76cf47648b23e1ed2aac0460b495f39f1293960ba
collect
public void collect(String namedOutput, Reporter reporter, Schema schema, Object datum, String baseOutputPath) throws IOException
{    getCollector(namedOutput, null, reporter, baseOutputPath, schema).collect(datum);}
37b63dd8d65a417e325e9f3566492004c2e87cc81c19631f133cf92f5dfccd8d
getCollector
public AvroCollector getCollector(String namedOutput, Reporter reporter) throws IOException
{    return getCollector(namedOutput, null, reporter, namedOutput, null);}
0c9bfeee8b9e4878fdbcd2d3ca045b2cd893bbcf32ccb200a752ef469d37f375
getCollector
private AvroCollector getCollector(String namedOutput, Reporter reporter, Schema schema) throws IOException
{    return getCollector(namedOutput, null, reporter, namedOutput, schema);}
5f27c71dcf96b559f68e59c06c6bf19fe571fed0dba3f4ee5df51d7190b4c3af
getCollector
public AvroCollector getCollector(String namedOutput, String multiName, Reporter reporter) throws IOException
{    return getCollector(namedOutput, multiName, reporter, namedOutput, null);}
f060b05e192fd18a3af2502e47f7fe87e208e12457288255f75afec9812fd6e7
getCollector
private AvroCollector getCollector(String namedOutput, Schema schema, Reporter reporter, String baseFileName) throws IOException
{        return getCollector(namedOutput, null, reporter, baseFileName, schema);}
cabdb4da7864454ad486ba614ebdaf538597cf99362eae61b1cfbd0449a0b14d
getCollector
private AvroCollector getCollector(String namedOutput, String multiName, Reporter reporter, String baseOutputFileName, Schema schema) throws IOException
{    checkNamedOutputName(namedOutput);    if (!namedOutputs.contains(namedOutput)) {        throw new IllegalArgumentException("Undefined named output '" + namedOutput + "'");    }    boolean multi = isMultiNamedOutput(conf, namedOutput);    if (!multi && multiName != null) {        throw new IllegalArgumentException("Name output '" + namedOutput + "' has not been defined as multi");    }    if (multi) {        checkTokenName(multiName);    }    String baseFileName = (multi) ? namedOutput + "_" + multiName : baseOutputFileName;    final RecordWriter writer = getRecordWriter(namedOutput, baseFileName, reporter, schema);    return new AvroCollector() {        @SuppressWarnings({ "unchecked" })        @Override        public void collect(Object key) throws IOException {            AvroWrapper wrapper = new AvroWrapper(key);            writer.write(wrapper, NullWritable.get());        }        public void collect(Object key, Object value) throws IOException {            writer.write(key, value);        }    };}
48e5319883bb6cbf00f3d8d370e1daaec21d53e157a0170119edd2d6b64c7ef0
collect
public void collect(Object key) throws IOException
{    AvroWrapper wrapper = new AvroWrapper(key);    writer.write(wrapper, NullWritable.get());}
75bc204f1d5dd36fec8411d84b53466b8508207b203ba963c8ef486e5e62cff5
collect
public void collect(Object key, Object value) throws IOException
{    writer.write(key, value);}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    for (RecordWriter writer : recordWriters.values()) {        writer.close(null);    }}
09ee4a0a5d15b8aa935101432f247e8798e5a0fbc73764825e49a9a2d325ce19
getRecordWriter
public RecordWriter<Object, Object> getRecordWriter(FileSystem fs, JobConf job, String baseFileName, Progressable arg3) throws IOException
{    String nameOutput = job.get(CONFIG_NAMED_OUTPUT, null);    String fileName = getUniqueName(job, baseFileName);    Schema schema = null;    String schemastr = job.get(MO_PREFIX + nameOutput + ".schema", null);    if (schemastr != null)        schema = Schema.parse(schemastr);    JobConf outputConf = new JobConf(job);    outputConf.setOutputFormat(getNamedOutputFormatClass(job, nameOutput));    boolean isMapOnly = job.getNumReduceTasks() == 0;    if (schema != null) {        if (isMapOnly)            AvroJob.setMapOutputSchema(outputConf, schema);        else            AvroJob.setOutputSchema(outputConf, schema);    }    OutputFormat outputFormat = outputConf.getOutputFormat();    return outputFormat.getRecordWriter(fs, outputConf, fileName, arg3);}
71681897224d0bd0d1a488c7f1568cb6bf1552dd985c21e778561f6cd07ba006
setDeflateLevel
public static void setDeflateLevel(JobConf job, int level)
{    FileOutputFormat.setCompressOutput(job, true);    job.setInt(DEFLATE_LEVEL_KEY, level);}
24721ea68906e7bebbcd317d758007840fa761bb2d4a5553ad66499505df23ac
setSyncInterval
public static void setSyncInterval(JobConf job, int syncIntervalInBytes)
{    job.setInt(SYNC_INTERVAL_KEY, syncIntervalInBytes);}
cc7465c93682569755623fc94568b325e428c51720f14e3760ac6bbb3af64ec0
configureDataFileWriter
 static void configureDataFileWriter(DataFileWriter<T> writer, JobConf job) throws UnsupportedEncodingException
{    CodecFactory factory = getCodecFactory(job);    if (factory != null) {        writer.setCodec(factory);    }    writer.setSyncInterval(job.getInt(SYNC_INTERVAL_KEY, DEFAULT_SYNC_INTERVAL));        for (Map.Entry<String, String> e : job) {        if (e.getKey().startsWith(AvroJob.TEXT_PREFIX))            writer.setMeta(e.getKey().substring(AvroJob.TEXT_PREFIX.length()), e.getValue());        if (e.getKey().startsWith(AvroJob.BINARY_PREFIX))            writer.setMeta(e.getKey().substring(AvroJob.BINARY_PREFIX.length()), URLDecoder.decode(e.getValue(), StandardCharsets.ISO_8859_1.name()).getBytes(StandardCharsets.ISO_8859_1));    }}
9689848434e829466faf58e3e5d8bf0be4490092954f2cc6eb069ec29ef20496
getCodecFactory
 static CodecFactory getCodecFactory(JobConf job)
{    CodecFactory factory = null;    if (FileOutputFormat.getCompressOutput(job)) {        int deflateLevel = job.getInt(DEFLATE_LEVEL_KEY, DEFAULT_DEFLATE_LEVEL);        int xzLevel = job.getInt(XZ_LEVEL_KEY, DEFAULT_XZ_LEVEL);        String codecName = job.get(AvroJob.OUTPUT_CODEC);        if (codecName == null) {            String codecClassName = job.get("mapred.output.compression.codec", null);            String avroCodecName = HadoopCodecFactory.getAvroCodecName(codecClassName);            if (codecClassName != null && avroCodecName != null) {                factory = HadoopCodecFactory.fromHadoopString(codecClassName);                job.set(AvroJob.OUTPUT_CODEC, avroCodecName);                return factory;            } else {                return CodecFactory.deflateCodec(deflateLevel);            }        } else {            if (codecName.equals(DEFLATE_CODEC)) {                factory = CodecFactory.deflateCodec(deflateLevel);            } else if (codecName.equals(XZ_CODEC)) {                factory = CodecFactory.xzCodec(xzLevel);            } else {                factory = CodecFactory.fromString(codecName);            }        }    }    return factory;}
452864732206c1242ed15175f30fe6602f0f40b5e30a44c2743e226a3a044151
getRecordWriter
public RecordWriter<AvroWrapper<T>, NullWritable> getRecordWriter(FileSystem ignore, JobConf job, String name, Progressable prog) throws IOException
{    boolean isMapOnly = job.getNumReduceTasks() == 0;    Schema schema = isMapOnly ? AvroJob.getMapOutputSchema(job) : AvroJob.getOutputSchema(job);    GenericData dataModel = AvroJob.createDataModel(job);    final DataFileWriter<T> writer = new DataFileWriter<T>(dataModel.createDatumWriter(null));    configureDataFileWriter(writer, job);    Path path = FileOutputFormat.getTaskOutputPath(job, name + EXT);    writer.create(schema, path.getFileSystem(job).create(path));    return new RecordWriter<AvroWrapper<T>, NullWritable>() {        @Override        public void write(AvroWrapper<T> wrapper, NullWritable ignore) throws IOException {            writer.append(wrapper.datum());        }        @Override        public void close(Reporter reporter) throws IOException {            writer.close();        }    };}
00f58e341bbb31b14a13f0d372cb41dc9d440067f290cac22d7e3d4ff25ab8c5
write
public void write(AvroWrapper<T> wrapper, NullWritable ignore) throws IOException
{    writer.append(wrapper.datum());}
d217b17bf131ccc7d63327b9a21715cc03224e14acdccb70a58b2ad62544d0f8
close
public void close(Reporter reporter) throws IOException
{    writer.close();}
4a9f8c2f98279900835e618fd45086b675d0d88913f4d5b78f09934da53da06f
createKey
public AvroWrapper<T> createKey()
{    return new AvroWrapper<>(null);}
bb893145c84686d5b66c614a366a7233624450939702ad466536347c434aeb3f
createValue
public NullWritable createValue()
{    return NullWritable.get();}
1ad423ccee660df3ccf8bd087651bb0b2e79759133a5e3f8de8a38e3479da5b7
next
public boolean next(AvroWrapper<T> wrapper, NullWritable ignore) throws IOException
{    if (!reader.hasNext() || reader.pastSync(end))        return false;    wrapper.datum(reader.next(wrapper.datum()));    return true;}
46dc59cbf7e4d6aafe0869ef2726ed2c5c897b673d9e37f94ab9b0e962f65f7f
getProgress
public float getProgress() throws IOException
{    if (end == start) {        return 0.0f;    } else {        return Math.min(1.0f, (getPos() - start) / (float) (end - start));    }}
5800a0f531c192e683ef74c0c5de6015daf6261d1f8e5c0ce6d8e043b01926c7
getPos
public long getPos() throws IOException
{    return reader.tell();}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    reader.close();}
da10d5ec2946237f772a28adc3daf019c57ef0ea5b46fd296b96bfdf619b41fa
reduce
public void reduce(K key, Iterable<V> values, AvroCollector<OUT> collector, Reporter reporter) throws IOException
{    if (outputPair == null)        outputPair = new Pair<>(AvroJob.getOutputSchema(getConf()));    for (V value : values) {        outputPair.set(key, value);        collector.collect((OUT) outputPair);    }}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{}
711139ba85089e8c83d383c716e53a6995c50f3b5bdb4f79367877d626bd4bd1
configure
public void configure(JobConf jobConf)
{}
d4a9a2025868f52f4f027b79964e10f636bb7daee456976aadc01e2089aa003c
accept
public boolean accept(Class<?> c)
{    return AvroWrapper.class.isAssignableFrom(c);}
3541db5476c97e20861d774d1a0699553eba6503a257a6df67bfe0fc4b200210
getDeserializer
public Deserializer<AvroWrapper<T>> getDeserializer(Class<AvroWrapper<T>> c)
{    Configuration conf = getConf();    boolean isKey = AvroKey.class.isAssignableFrom(c);    Schema schema = isKey ? Pair.getKeySchema(AvroJob.getMapOutputSchema(conf)) : Pair.getValueSchema(AvroJob.getMapOutputSchema(conf));    GenericData dataModel = AvroJob.createMapOutputDataModel(conf);    DatumReader<T> datumReader = dataModel.createDatumReader(schema);    return new AvroWrapperDeserializer(datumReader, isKey);}
d95d451c844607e347c0a78cf76729e81cfa227199cb713026ab5a96d3d1fcc5
open
public void open(InputStream in)
{    this.decoder = FACTORY.directBinaryDecoder(in, decoder);}
bec434513666a1810b2dc7751230eef4c3d300c98612ecc53148b41e00046d50
deserialize
public AvroWrapper<T> deserialize(AvroWrapper<T> wrapper) throws IOException
{    T datum = reader.read(wrapper == null ? null : wrapper.datum(), decoder);    if (wrapper == null) {        wrapper = isKey ? new AvroKey<>(datum) : new AvroValue<>(datum);    } else {        wrapper.datum(datum);    }    return wrapper;}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    decoder.inputStream().close();}
e1083aa42d589f1021abbb850d6d621a88376c3af9c7072ebc9e47e782b68a61
getSerializer
public Serializer<AvroWrapper<T>> getSerializer(Class<AvroWrapper<T>> c)
{        boolean isFinalOutput = c.equals(AvroWrapper.class);    Configuration conf = getConf();    Schema schema = isFinalOutput ? AvroJob.getOutputSchema(conf) : (AvroKey.class.isAssignableFrom(c) ? Pair.getKeySchema(AvroJob.getMapOutputSchema(conf)) : Pair.getValueSchema(AvroJob.getMapOutputSchema(conf)));    GenericData dataModel = AvroJob.createDataModel(conf);    return new AvroWrapperSerializer(dataModel.createDatumWriter(schema));}
5c7765297ee616456cf8e2746b1d314f4095bca1cd70e443a84f2a9a87309902
open
public void open(OutputStream out)
{    this.out = out;    this.encoder = new EncoderFactory().binaryEncoder(out, null);}
41e3ed3ff7e45dda240edf91b5ec99875304c5ab10f24104cc9fe93abd9aaea2
serialize
public void serialize(AvroWrapper<T> wrapper) throws IOException
{    writer.write(wrapper.datum(), encoder);                encoder.flush();}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    out.close();}
edcc03fc2b577ffc5b2ea9b9abb865400b9fd95d6c9dbb5778d0481dc65dc262
getRecordWriter
public RecordWriter<K, V> getRecordWriter(FileSystem ignore, JobConf job, String name, Progressable prog) throws IOException
{    Schema schema = Schema.create(Schema.Type.BYTES);    final byte[] keyValueSeparator = job.get("mapreduce.output.textoutputformat.separator", "\t").getBytes(StandardCharsets.UTF_8);    final DataFileWriter<ByteBuffer> writer = new DataFileWriter<>(new ReflectDatumWriter<>());    AvroOutputFormat.configureDataFileWriter(writer, job);    Path path = FileOutputFormat.getTaskOutputPath(job, name + EXT);    writer.create(schema, path.getFileSystem(job).create(path));    return new AvroTextRecordWriter(writer, keyValueSeparator);}
44b3b7401a140e39e62134b31a2a6741d6ac4c1f92c94603b1986ce9900a2a21
write
public void write(K key, V value) throws IOException
{    boolean nullKey = key == null || key instanceof NullWritable;    boolean nullValue = value == null || value instanceof NullWritable;    if (nullKey && nullValue) {        } else if (!nullKey && nullValue) {        writer.append(toByteBuffer(key));    } else if (nullKey && !nullValue) {        writer.append(toByteBuffer(value));    } else {        writer.append(toByteBuffer(key, keyValueSeparator, value));    }}
d217b17bf131ccc7d63327b9a21715cc03224e14acdccb70a58b2ad62544d0f8
close
public void close(Reporter reporter) throws IOException
{    writer.close();}
1d7cb302e69a72fbc4fc4c00c6ae9d4768d69e86549b11fc841ab6cde53c47ab
toByteBuffer
private ByteBuffer toByteBuffer(Object o) throws IOException
{    if (o instanceof Text) {        Text to = (Text) o;        return ByteBuffer.wrap(to.getBytes(), 0, to.getLength());    } else {        return ByteBuffer.wrap(o.toString().getBytes(StandardCharsets.UTF_8));    }}
b4e7b32ec879d4a0fa760971f9c41c6c529e5a655da59b6b14b94d64f17dec7a
toByteBuffer
private ByteBuffer toByteBuffer(Object key, byte[] sep, Object value) throws IOException
{    byte[] keyBytes, valBytes;    int keyLength, valLength;    if (key instanceof Text) {        Text tkey = (Text) key;        keyBytes = tkey.getBytes();        keyLength = tkey.getLength();    } else {        keyBytes = key.toString().getBytes(StandardCharsets.UTF_8);        keyLength = keyBytes.length;    }    if (value instanceof Text) {        Text tval = (Text) value;        valBytes = tval.getBytes();        valLength = tval.getLength();    } else {        valBytes = value.toString().getBytes(StandardCharsets.UTF_8);        valLength = valBytes.length;    }    ByteBuffer buf = ByteBuffer.allocate(keyLength + sep.length + valLength);    buf.put(keyBytes, 0, keyLength);    buf.put(sep);    buf.put(valBytes, 0, valLength);    buf.rewind();    return buf;}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    lineRecordReader.close();}
5800a0f531c192e683ef74c0c5de6015daf6261d1f8e5c0ce6d8e043b01926c7
getPos
public long getPos() throws IOException
{    return lineRecordReader.getPos();}
46dc59cbf7e4d6aafe0869ef2726ed2c5c897b673d9e37f94ab9b0e962f65f7f
getProgress
public float getProgress() throws IOException
{    return lineRecordReader.getProgress();}
843bfa8b7ec6588c70e6ab9305b1003feafb227c8e62470c7ca863a4eed986c0
next
public boolean next(AvroWrapper<Utf8> key, NullWritable value) throws IOException
{    boolean success = lineRecordReader.next(currentKeyHolder, currentValueHolder);    if (success) {        key.datum(new Utf8(currentValueHolder.getBytes()).setByteLength(currentValueHolder.getLength()));    } else {        key.datum(null);    }    return success;}
edbe70d2009dcb90ef81bc74eaf5ccbb3f2e35725d63d073b6873e0f2581d274
createKey
public AvroWrapper<Utf8> createKey()
{    return new AvroWrapper<>(null);}
bb893145c84686d5b66c614a366a7233624450939702ad466536347c434aeb3f
createValue
public NullWritable createValue()
{    return NullWritable.get();}
168ba1f397fa7f98e4fd97e21643283e5d4241368ae53225b4df290815323453
configure
public void configure(JobConf conf)
{    compressionCodecs = new CompressionCodecFactory(conf);}
a3ec9e222ba9345fc51b6e190b075aace67ab8313bee3832a33f63f34d080973
isSplitable
protected boolean isSplitable(FileSystem fs, Path file)
{    return compressionCodecs.getCodec(file) == null;}
2e0f812a5f6a1c3ecd7e45f1953bf6b18b3741282415a56c5b6e63a41ebec669
getRecordReader
public RecordReader<AvroWrapper<Utf8>, NullWritable> getRecordReader(InputSplit split, JobConf job, Reporter reporter) throws IOException
{    reporter.setStatus(split.toString());    return new Utf8LineRecordReader(job, (FileSplit) split);}
9932400388b478bcc0f1b6e3c54fa211f898b1a9cda59e8e14dc4d08d54d8daa
datum
public T datum()
{    return datum;}
687e9b16d0244b1bb9c2374870ad8eb3f11120812086a603a0fe1fad31f4b0cb
datum
public void datum(T datum)
{    this.datum = datum;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return (datum == null) ? 0 : datum.hashCode();}
4afeb0868b55bdd8e18a00a3cb43d83e0714378d1c4bb36f0936daefc060e2e8
equals
public boolean equals(Object obj)
{    if (this == obj)        return true;    if (obj == null)        return false;    if (getClass() != obj.getClass())        return false;    AvroWrapper that = (AvroWrapper) obj;    if (this.datum == null) {        return that.datum == null;    } else        return datum.equals(that.datum);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return datum.toString();}
67b6106e309c319e8b155bb47bd002e29b51d674e6f8eef9f2d4f352bcacf536
getSplits
public InputSplit[] getSplits(JobConf conf, int numSplits) throws IOException
{    JobConf confCopy = new JobConf(conf);    List<InputSplit> splits = new ArrayList<>();    Map<Path, Class<? extends AvroMapper>> mapperMap = AvroMultipleInputs.getMapperTypeMap(conf);    Map<Path, Schema> schemaMap = AvroMultipleInputs.getInputSchemaMap(conf);    Map<Schema, List<Path>> schemaPaths = new HashMap<>();        for (Entry<Path, Schema> entry : schemaMap.entrySet()) {        if (!schemaPaths.containsKey(entry.getValue())) {            schemaPaths.put(entry.getValue(), new ArrayList<>());            System.out.println(entry.getValue());            System.out.println(entry.getKey());        }        schemaPaths.get(entry.getValue()).add(entry.getKey());    }    for (Entry<Schema, List<Path>> schemaEntry : schemaPaths.entrySet()) {        Schema schema = schemaEntry.getKey();        System.out.println(schema);        InputFormat format = ReflectionUtils.newInstance(AvroInputFormat.class, conf);        List<Path> paths = schemaEntry.getValue();        Map<Class<? extends AvroMapper>, List<Path>> mapperPaths = new HashMap<>();                for (Path path : paths) {            Class<? extends AvroMapper> mapperClass = mapperMap.get(path);            if (!mapperPaths.containsKey(mapperClass)) {                mapperPaths.put(mapperClass, new ArrayList<>());            }            mapperPaths.get(mapperClass).add(path);        }                for (Entry<Class<? extends AvroMapper>, List<Path>> mapEntry : mapperPaths.entrySet()) {            paths = mapEntry.getValue();            Class<? extends AvroMapper> mapperClass = mapEntry.getKey();            if (mapperClass == null) {                mapperClass = (Class<? extends AvroMapper>) conf.getMapperClass();            }            FileInputFormat.setInputPaths(confCopy, paths.toArray(new Path[0]));                                    InputSplit[] pathSplits = format.getSplits(confCopy, numSplits);            for (InputSplit pathSplit : pathSplits) {                splits.add(new TaggedInputSplit(pathSplit, conf, format.getClass(), mapperClass, schema));            }        }    }    return splits.toArray(new InputSplit[0]);}
484eb3c3aea46a8046a05fb869f852ef40912f0819ec604dbfc2fdeec0d2f0d7
getRecordReader
public RecordReader<K, V> getRecordReader(InputSplit split, JobConf conf, Reporter reporter) throws IOException
{            TaggedInputSplit taggedInputSplit = (TaggedInputSplit) split;    Schema schema = taggedInputSplit.getSchema();    AvroJob.setInputSchema(conf, schema);    InputFormat<K, V> inputFormat = (InputFormat<K, V>) ReflectionUtils.newInstance(taggedInputSplit.getInputFormatClass(), conf);    return inputFormat.getRecordReader(taggedInputSplit.getInputSplit(), conf, reporter);}
168ba1f397fa7f98e4fd97e21643283e5d4241368ae53225b4df290815323453
configure
public void configure(JobConf conf)
{    this.conf = conf;    this.isMapOnly = conf.getNumReduceTasks() == 0;}
a25ec7136d2b717cb943a560716734868059f81c5f1bf97e0fded0ce3492805a
map
public void map(AvroWrapper<IN> wrapper, NullWritable value, OutputCollector<KO, VO> collector, Reporter reporter) throws IOException
{    if (mapper == null) {        TaggedInputSplit is = (TaggedInputSplit) reporter.getInputSplit();        Class<? extends AvroMapper> mapperClass = is.getMapperClass();        mapper = (AvroMapper<IN, OUT>) ReflectionUtils.newInstance(mapperClass, conf);    }    if (out == null)        out = new MapCollector<OUT, K, V, KO, VO>(collector, isMapOnly);    mapper.map(wrapper.datum(), out, reporter);}
585528c061f4edf5b2b70ad857f58312659dac5be1809f2fc803a9ccaa2fb93e
length
public long length()
{    return len;}
56e08d87e6bd0be2a60f9b2de3195d58bc9d56a2637f6fed6210d21e832632ea
read
public int read(byte[] b, int off, int len) throws IOException
{    return stream.read(b, off, len);}
d82b4dff89e8597e847f70bbec619b3fbe6165fdff6be403c9711e93ebce3d4d
seek
public void seek(long p) throws IOException
{    stream.seek(p);}
0efa2bd8fc7bc3d72996c492a3eaca80646290caeceea873a5afabb84aa9504c
tell
public long tell() throws IOException
{    return stream.getPos();}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    stream.close();}
1d89996585eb84c9c0b2e1643f0646427c427b24e440d36a24ed68b4a9c99ac2
getReducer
protected AvroReducer<K, V, Pair<K, V>> getReducer(JobConf conf)
{    return ReflectionUtils.newInstance(conf.getClass(AvroJob.COMBINER, AvroReducer.class, AvroReducer.class), conf);}
58714ce24f1bc2b20521b61c9c3baf86abdd453c458442c3ce3b65d02a1ea93f
collect
public void collect(Pair<K, V> datum) throws IOException
{        keyWrapper.datum(datum.key());    valueWrapper.datum(datum.value());    collector.collect(keyWrapper, valueWrapper);}
163b7e283cdd969493296ec7f92ae4ec37a13f43f2356b58460da76d55721c5c
getCollector
protected AvroCollector<Pair<K, V>> getCollector(OutputCollector<AvroKey<K>, AvroValue<V>> collector)
{    return new PairCollector(collector);}
168ba1f397fa7f98e4fd97e21643283e5d4241368ae53225b4df290815323453
configure
public void configure(JobConf conf)
{    this.mapper = ReflectionUtils.newInstance(conf.getClass(AvroJob.MAPPER, AvroMapper.class, AvroMapper.class), conf);    this.isMapOnly = conf.getNumReduceTasks() == 0;}
a25ec7136d2b717cb943a560716734868059f81c5f1bf97e0fded0ce3492805a
map
public void map(AvroWrapper<IN> wrapper, NullWritable value, OutputCollector<KO, VO> collector, Reporter reporter) throws IOException
{    if (this.out == null)        this.out = new MapCollector<>(collector, isMapOnly);    mapper.map(wrapper.datum(), out, reporter);}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    this.mapper.close();}
481e29df5fc846acfbbc8ecb939f765b18baa4b60850a9de518d408b270a14ee
getReducer
protected AvroReducer<K, V, OUT> getReducer(JobConf conf)
{    return ReflectionUtils.newInstance(conf.getClass(AvroJob.REDUCER, AvroReducer.class, AvroReducer.class), conf);}
e9b1421d532216c87fa2592c1db82be968bec0dfa96f26796f89fe713b205124
collect
public void collect(OUT datum) throws IOException
{    wrapper.datum(datum);    out.collect(wrapper, NullWritable.get());}
ded0773db8063b65e5a20b64e189a717b525188eed55bc391509c4601ef0f223
getCollector
protected AvroCollector<OUT> getCollector(OutputCollector<AvroWrapper<OUT>, NullWritable> collector)
{    return new ReduceCollector(collector);}
168ba1f397fa7f98e4fd97e21643283e5d4241368ae53225b4df290815323453
configure
public void configure(JobConf conf)
{    this.reducer = getReducer(conf);}
d51e5f7450eca0a0f63da1a466189e262d053b84aa767ba3be5cea740af7251b
hasNext
public boolean hasNext()
{    return values.hasNext();}
7b0548984c463aeccab5907670bd1d5e009140134aeeee67c4d5885e5a9e69b6
next
public V next()
{    return values.next().datum();}
eb35e4acc0ab2c89fd30970f01fba35488b3a4581b2af1986091209043508a3e
remove
public void remove()
{    throw new UnsupportedOperationException();}
d40381ab6f038666ae133df9f475ec0ae3c2f19a5af68da0ebdc4aa1776ccba6
iterator
public Iterator<V> iterator()
{    return this;}
ac486ef772205197eb7ed1b4b4ea850dad5cecb0f0e3d7f9a0b8a4a67ca145eb
reduce
public final void reduce(AvroKey<K> key, Iterator<AvroValue<V>> values, OutputCollector<KO, VO> out, Reporter reporter) throws IOException
{    if (this.collector == null)        this.collector = getCollector(out);    reduceIterable.values = values;    reducer.reduce(key.datum(), reduceIterable, collector, reporter);}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    this.reducer.close();}
e9b1421d532216c87fa2592c1db82be968bec0dfa96f26796f89fe713b205124
collect
public void collect(OUT datum) throws IOException
{    if (isMapOnly) {        wrapper.datum(datum);        collector.collect((KO) wrapper, (VO) NullWritable.get());    } else {                Pair<K, V> pair = (Pair<K, V>) datum;        keyWrapper.datum(pair.key());        valueWrapper.datum(pair.value());        collector.collect((KO) keyWrapper, (VO) valueWrapper);    }}
656e8e3b747d6635096b3f2bed35bdb35d5a06c4a6d84f3d9c2a3b053bd62990
checkIsPairSchema
private static void checkIsPairSchema(Schema schema)
{    if (!PAIR.equals(schema.getFullName()))        throw new IllegalArgumentException("Not a Pair schema: " + schema);}
58849949cda87741c622ee1ea11d9629f8b6cf2aa58f87bd8cb17e3282d4b229
getKeySchema
public static Schema getKeySchema(Schema pair)
{    checkIsPairSchema(pair);    return pair.getField(KEY).schema();}
5066d1c8903bf5a821bf1d0b255253558ec4d8785c31a1ea17f0c8a45aefa38b
getValueSchema
public static Schema getValueSchema(Schema pair)
{    checkIsPairSchema(pair);    return pair.getField(VALUE).schema();}
c2f1b59370f2f45aae65bdd1edc5e639d565c655b44149d6a1453ebf543509ff
getPairSchema
public static Schema getPairSchema(Schema key, Schema value)
{    Map<Schema, Schema> valueSchemas;    synchronized (SCHEMA_CACHE) {        valueSchemas = SCHEMA_CACHE.computeIfAbsent(key, k -> new WeakHashMap<>());        Schema result;        result = valueSchemas.get(value);        if (result == null) {            result = makePairSchema(key, value);            valueSchemas.put(value, result);        }        return result;    }}
6385a0160c1bb3c2d2d7e783df4551b58756c921be69e3e2350d0bcbb6be8dc2
makePairSchema
private static Schema makePairSchema(Schema key, Schema value)
{    Schema pair = Schema.createRecord(PAIR, null, null, false);    List<Field> fields = new ArrayList<>();    fields.add(new Field(KEY, key, "", null));    fields.add(new Field(VALUE, value, "", null, Field.Order.IGNORE));    pair.setFields(fields);    return pair;}
b74ae948bba816a824396f5fcd959e744592a67ff01eb79c422acb487a04550a
getSchema
public Schema getSchema()
{    return schema;}
79395f134a06973aaaeb86d116a0253a2ef662fd76a287ef44f1c2a324db65e2
key
public K key()
{    return key;}
75f1dce6241a92aef170f0626bc2abefb932fbce6c149b2a4c5217fb2094ffbd
key
public void key(K key)
{    this.key = key;}
d5d7a269868d88e914e1e84a136272c0c64e18d3dff367196c77d47c0fd0498d
value
public V value()
{    return value;}
b823bc48d4fe37fe150213aa9eb8a6b4e13ff3e4aafa2163b212d08afa2bab74
value
public void value(V value)
{    this.value = value;}
23e8edb925db33b29b47858b55284d279264cbbe8c4231ccdcfb5263f8ddb6ea
set
public void set(K key, V value)
{    this.key = key;    this.value = value;}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (o == this)                return true;    if (!(o instanceof Pair))                return false;    Pair that = (Pair) o;    if (!this.schema.equals(that.schema))                return false;    return this.compareTo(that) == 0;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return GenericData.get().hashCode(this, schema);}
da2ce22ede20fa2e70222d2df06a22c2d63a5be7b4c64dc7b0db1795e2ae2d22
compareTo
public int compareTo(Pair that)
{    return GenericData.get().compare(this, that, schema);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return GenericData.get().toString(this);}
2ea0205e522ed62ca511b522fdeaf1cedf0c2afbc5adfc3869c76d9961e32934
get
public Object get(int i)
{    switch(i) {        case 0:            return key;        case 1:            return value;        default:            throw new org.apache.avro.AvroRuntimeException("Bad index: " + i);    }}
36f8aa2e6be03c3073a4ccedc93062a93424b89870f3d5065d0ff7ae1826024b
put
public void put(int i, Object o)
{    switch(i) {        case 0:            this.key = (K) o;            break;        case 1:            this.value = (V) o;            break;        default:            throw new org.apache.avro.AvroRuntimeException("Bad index: " + i);    }}
dbe091a4c892b7c72d498b0f736f0a4941170b028d701f47569fc106bb9400ef
getSchema
private static Schema getSchema(Object o)
{    try {        return ReflectData.get().getSchema(o.getClass());    } catch (AvroRuntimeException e) {        throw new AvroRuntimeException("Cannot infer schema for : " + o.getClass() + ".  Must create Pair with explicit key and value schemas.", e);    }}
fd89a2b841976f498edf7a88e502948184a97cbd06ed2c60d9306ff6a0e60b83
getRecordReader
public RecordReader<AvroWrapper<Pair<K, V>>, NullWritable> getRecordReader(InputSplit split, JobConf job, Reporter reporter) throws IOException
{    reporter.setStatus(split.toString());    return new SequenceFileRecordReader<>(job, (FileSplit) split);}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    reader.close();}
eb35e4acc0ab2c89fd30970f01fba35488b3a4581b2af1986091209043508a3e
remove
public void remove()
{    throw new UnsupportedOperationException();}
577ab0167978f2e3bc0d79f78e8bef546c1a14ba21fb581d1134adcbd6c1b152
iterator
public Iterator<Pair<K, V>> iterator()
{    return this;}
b74ae948bba816a824396f5fcd959e744592a67ff01eb79c422acb487a04550a
getSchema
public Schema getSchema()
{    return schema;}
91d8464a878a7b22724116604f6b03b73505070ab2487addd2daa4057791ab28
prepare
private void prepare() throws IOException
{    if (ready)        return;    this.done = !reader.next(key);    ready = true;}
d51e5f7450eca0a0f63da1a466189e262d053b84aa767ba3be5cea740af7251b
hasNext
public boolean hasNext()
{    try {        prepare();        return !done;    } catch (IOException e) {        throw new AvroRuntimeException(e);    }}
b5526130fc4feae8d14ab5f93ea206824ea5aa2d05b6abcacad717f11189f9b9
next
public Pair<K, V> next()
{    try {        return next(null);    } catch (IOException e) {        throw new AvroRuntimeException(e);    }}
918e80c8ccc05f2f572f4173e22a0ae05d1d864b6391fbf32d9960b90500b600
next
public Pair<K, V> next(Pair<K, V> reuse) throws IOException
{    prepare();    if (!hasNext())        throw new NoSuchElementException();    Pair<K, V> result = reuse;    if (result == null)        result = new Pair<>(schema);    result.key(keyConverter.convert(key));    reader.getCurrentValue(value);    result.value(valConverter.convert(value));        Writable k = key;    key = spareKey;    spareKey = k;    ready = false;    return result;}
1ef31825c3ea730717cd39903131dde1e7da428add57c8d2d35fe425543ec29b
sync
public void sync(long position) throws IOException
{    if (position > reader.getPosition())        reader.sync(position);    ready = false;}
fc3db9c636510e5e099bba6cc5b15e2a96a29d25a27e0519fd4dfdc8dcb26f4d
pastSync
public boolean pastSync(long position) throws IOException
{    return reader.getPosition() >= position && reader.syncSeen();}
0efa2bd8fc7bc3d72996c492a3eaca80646290caeceea873a5afabb84aa9504c
tell
public long tell() throws IOException
{    return reader.getPosition();}
0cc5646329ac92eeef6961356ec251ead95dda55592b7e3b8daf91e5b06b0bc8
get
public static WritableData get()
{    return INSTANCE;}
fb3a2ee1e87f6dc697d459d9468f0b5d56bcb320d4e154c4738c046f66e26294
getSchema
public Schema getSchema(java.lang.reflect.Type type)
{    if (WRITABLE_SCHEMAS.containsKey(type))        return WRITABLE_SCHEMAS.get(type);    else        return super.getSchema(type);}
af88a97040c5a4412de870b61a166a909170b9b4f2445232f653007c8b5510fc
getInputSplit
public InputSplit getInputSplit()
{    return inputSplit;}
a95487eaf79ba339e05a7a8de81ece6b326699223ff40d6c657f3a2ccdec1350
getInputFormatClass
public Class<? extends InputFormat> getInputFormatClass()
{    return inputFormatClass;}
055a88ea35e55aabc3090638f6be937d8b94ed9f916b0bb3ab9f00711239d7ac
getMapperClass
public Class<? extends AvroMapper> getMapperClass()
{    return mapperClass;}
b74ae948bba816a824396f5fcd959e744592a67ff01eb79c422acb487a04550a
getSchema
public Schema getSchema()
{    return schema;}
9cd3ad9bf4a05b331833c639755ae4f81500bf1da82c30049ab97309a4bb3d9f
getLength
public long getLength() throws IOException
{    return inputSplit.getLength();}
09395a9599cab7bb2e1f34feff81cbbcfc81ea48b04f555c84abc6a47cf73117
getLocations
public String[] getLocations() throws IOException
{    return inputSplit.getLocations();}
5478cc5683f6dfd4515c383752d7c803555efc63d03fd84a03ba8dcd17eb4324
readFields
public void readFields(DataInput in) throws IOException
{    inputSplitClass = (Class<? extends InputSplit>) readClass(in);    inputSplit = ReflectionUtils.newInstance(inputSplitClass, conf);    inputSplit.readFields(in);    inputFormatClass = (Class<? extends InputFormat>) readClass(in);    mapperClass = (Class<? extends AvroMapper>) readClass(in);    String schemaString = Text.readString(in);    schema = schemaParser.parse(schemaString);}
2dae4236abc74bff8e2f7763284a1ed9add95907e5da3356185dd22e5b83169d
readClass
private Class<?> readClass(DataInput in) throws IOException
{    String className = Text.readString(in);    try {        return conf.getClassByName(className);    } catch (ClassNotFoundException e) {        throw new RuntimeException("readObject can't find class", e);    }}
a894510dd4db439ff8e17ae1059489dc3abc97178e5932ceed0c70c3af165401
write
public void write(DataOutput out) throws IOException
{    Text.writeString(out, inputSplitClass.getName());    inputSplit.write(out);    Text.writeString(out, inputFormatClass.getName());    Text.writeString(out, mapperClass.getName());    Text.writeString(out, schema.toString());}
d221713f567be6c3a854157b6beb8a5fd5dd64b69c1ef157fb4bac811a41c3f7
getConf
public Configuration getConf()
{    return conf;}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    this.conf = conf;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return inputSplit.toString();}
e4f1a1fb9d49d84a01c8f523b13b2984e20b3d9032426ed0b94c11278333f756
count
public int count()
{    return count;}
546b6725c721e3905ae9691a8266b3f83f186205bd290c7c684d3101c67e664f
count
public void count(int count)
{    this.count = count;}
0fd43f233999eabeb666e05e46a70e1607d7baf864982974e200c1c5294d1f3e
buffer
public ByteBuffer buffer()
{    return buffer;}
e58c4766f26924c31af9d55f1a250c25144fe48edc9a5e418ff631f921eafe08
buffer
public void buffer(ByteBuffer buffer)
{    this.buffer = buffer;}
5df6118bc0e745d8b18e0a6a99b2e3f2ddba8140cbeb1423ce2df50a9f140574
close
public void close()
{    if (clientTransceiver != null)        try {            clientTransceiver.close();        } catch (IOException e) {        }        if (subprocess != null)        subprocess.destroy();    if (outputServer != null)        outputServer.close();}
0455f1f2d8f41b54e036daab284e972aa7ef3627b4679643f512986e39e3c38c
startSubprocess
private Process startSubprocess(JobConf job) throws IOException, InterruptedException
{        List<String> command = new ArrayList<>();    String executable = "";    if (job.getBoolean(TetherJob.TETHER_EXEC_CACHED, false)) {                Path[] localFiles = DistributedCache.getLocalCacheFiles(job);        if (localFiles == null) {                        URI[] files = DistributedCache.getCacheFiles(job);            localFiles = new Path[] { new Path(files[0].toString()) };        }        executable = localFiles[0].toString();        FileUtil.chmod(executable.toString(), "a+x");    } else {        executable = job.get(TetherJob.TETHER_EXEC);    }    command.add(executable);                            String args = job.get(TetherJob.TETHER_EXEC_ARGS);        if (args != null) {        String[] aparams = args.split("\n");        for (int i = 0; i < aparams.length; i++) {            aparams[i] = aparams[i].trim();            if (aparams[i].length() > 0) {                command.add(aparams[i]);            }        }    }    if (System.getProperty("hadoop.log.dir") == null && System.getenv("HADOOP_LOG_DIR") != null)        System.setProperty("hadoop.log.dir", System.getenv("HADOOP_LOG_DIR"));        TaskAttemptID taskid = TaskAttemptID.forName(job.get("mapred.task.id"));    File stdout = TaskLog.getTaskLogFile(taskid, false, TaskLog.LogName.STDOUT);    File stderr = TaskLog.getTaskLogFile(taskid, false, TaskLog.LogName.STDERR);    long logLength = TaskLog.getTaskLogLength(job);    command = TaskLog.captureOutAndError(null, command, stdout, stderr, logLength, false);    stdout.getParentFile().mkdirs();    stderr.getParentFile().mkdirs();        Map<String, String> env = new HashMap<>();    env.put("AVRO_TETHER_OUTPUT_PORT", Integer.toString(outputServer.getPort()));        env.put("AVRO_TETHER_PROTOCOL", job.get(TetherJob.TETHER_PROTOCOL));        String imsg = "";    for (String s : command) {        imsg = s + " ";    }    LOG.info("TetheredProcess.startSubprocess: command: " + imsg);    LOG.info("Tetheredprocess.startSubprocess: stdout logged to: " + stdout.toString());    LOG.info("Tetheredprocess.startSubprocess: stderr logged to: " + stderr.toString());        ProcessBuilder builder = new ProcessBuilder(command);    System.out.println(command);    builder.environment().putAll(env);    return builder.start();}
5661a76f0bcc12fcf3dadab9dfa86940dbf494c03c97d219f02bb45245883e4b
listStatus
protected FileStatus[] listStatus(JobConf job) throws IOException
{    if (job.getBoolean(AvroInputFormat.IGNORE_FILES_WITHOUT_EXTENSION_KEY, AvroInputFormat.IGNORE_INPUTS_WITHOUT_EXTENSION_DEFAULT)) {        List<FileStatus> result = new ArrayList<>();        for (FileStatus file : super.listStatus(job)) if (file.getPath().getName().endsWith(AvroOutputFormat.EXT))            result.add(file);        return result.toArray(new FileStatus[0]);    } else {        return super.listStatus(job);    }}
4db606bc333db158e72966a262b05be7929dbaaf4c1773561a43adebc1111125
getRecordReader
public RecordReader<TetherData, NullWritable> getRecordReader(InputSplit split, JobConf job, Reporter reporter) throws IOException
{    reporter.setStatus(split.toString());    return new TetherRecordReader(job, (FileSplit) split);}
a501ad03abb44fb6dbd951bf8558f74022b81cbb3fbc2a794bc682f3dacf24b9
getExecutable
public static URI getExecutable(JobConf job)
{    try {        return new URI(job.get("avro.tether.executable"));    } catch (URISyntaxException e) {        throw new RuntimeException(e);    }}
342bf2655a8ee1dde1d87021931b49968a169923848a4b42e9285953fa52223a
setExecutable
public static void setExecutable(JobConf job, File executable)
{    setExecutable(job, executable, new ArrayList<>(), false);}
98e6d593acfb511c64047456d87e1c51c46a4efd01106b0395ec0237a98f1c10
setExecutable
public static void setExecutable(JobConf job, File executable, List<String> args, boolean cached)
{    job.set(TETHER_EXEC, executable.toString());    if (args != null) {        StringBuilder sb = new StringBuilder();        for (String a : args) {            sb.append(a);            sb.append('\n');        }        job.set(TETHER_EXEC_ARGS, sb.toString());    }    job.set(TETHER_EXEC_CACHED, (Boolean.valueOf(cached)).toString());}
f8f33c5195b57a88aeadf5451d5b69d08d9d8065a8d978c4ee57fdf1ee2ab42c
getProtocol
public static TetheredProcess.Protocol getProtocol(JobConf job)
{    if (job.get(TetherJob.TETHER_PROTOCOL) == null) {        return TetheredProcess.Protocol.NONE;    } else if (job.get(TetherJob.TETHER_PROTOCOL).equals("http")) {        return TetheredProcess.Protocol.HTTP;    } else if (job.get(TetherJob.TETHER_PROTOCOL).equals("sasl")) {        return TetheredProcess.Protocol.SASL;    } else {        throw new RuntimeException("Unknown value for protocol: " + job.get(TetherJob.TETHER_PROTOCOL));    }}
fbdad8fb595503e6349fd01f8cde744586c664e7c238e16309ddf8920fe8a7e0
runJob
public static RunningJob runJob(JobConf job) throws IOException
{    setupTetherJob(job);    return JobClient.runJob(job);}
24a31b699211a0ac1e48d923acf13f17166eb694f0d124f7e6e1e99396d18903
submitJob
public static RunningJob submitJob(JobConf conf) throws IOException
{    setupTetherJob(conf);    return new JobClient(conf).submitJob(conf);}
a1c7ff01cc0cb6e84a5185e1b16cce0b11bdad396f95acdf75ef27cb7c079f4f
setProtocol
public static void setProtocol(JobConf job, String proto) throws IOException
{    proto = proto.trim().toLowerCase();    if (!(proto.equals("http") || proto.equals("sasl"))) {        throw new IOException("protocol must be 'http' or 'sasl'");    }    job.set(TETHER_PROTOCOL, proto);}
173448538bc4ab466f5419a9d5e41ff65e00691fffb34dc7ae44b79b57a08281
setupTetherJob
private static void setupTetherJob(JobConf job) throws IOException
{    job.setMapRunnerClass(TetherMapRunner.class);    job.setPartitionerClass(TetherPartitioner.class);    job.setReducerClass(TetherReducer.class);    job.setInputFormat(TetherInputFormat.class);    job.setOutputFormat(TetherOutputFormat.class);    job.setOutputKeyClass(TetherData.class);    job.setOutputKeyComparatorClass(TetherKeyComparator.class);    job.setMapOutputValueClass(NullWritable.class);        job.setMapOutputKeyClass(TetherData.class);        if (job.getStrings(TETHER_PROTOCOL) == null) {        job.set(TETHER_PROTOCOL, "sasl");    }        Collection<String> serializations = job.getStringCollection("io.serializations");    if (!serializations.contains(TetherKeySerialization.class.getName())) {        serializations.add(TetherKeySerialization.class.getName());        job.setStrings("io.serializations", serializations.toArray(new String[0]));    }        if (job.getBoolean(TETHER_EXEC_CACHED, false)) {        DistributedCache.addCacheFile(getExecutable(job), job);    }}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    super.setConf(conf);    if (conf != null)        schema = AvroJob.getMapOutputSchema(conf);}
8cd74526bc7e7f20597a504e1ed768d1c3a048c7a382f95e889101f52fd94ec3
compare
public int compare(byte[] b1, int s1, int l1, byte[] b2, int s2, int l2)
{    int diff = BinaryData.compare(b1, BinaryData.skipLong(b1, s1), l1, b2, BinaryData.skipLong(b2, s2), l2, schema);    return diff == 0 ? -1 : diff;}
20d0b286daf5dcd1001bb3ecd476356068774685e4f008c1b57da526f512ad2d
compare
public int compare(TetherData x, TetherData y)
{    ByteBuffer b1 = x.buffer(), b2 = y.buffer();    int diff = BinaryData.compare(b1.array(), b1.position(), b2.array(), b2.position(), schema);    return diff == 0 ? -1 : diff;}
d4a9a2025868f52f4f027b79964e10f636bb7daee456976aadc01e2089aa003c
accept
public boolean accept(Class<?> c)
{    return TetherData.class.isAssignableFrom(c);}
b324de9341113cc2a9096acba8475698709d4269fbc24dc037b5eb39a5b8e611
getDeserializer
public Deserializer<TetherData> getDeserializer(Class<TetherData> c)
{    return new TetherDataDeserializer();}
d95d451c844607e347c0a78cf76729e81cfa227199cb713026ab5a96d3d1fcc5
open
public void open(InputStream in)
{    this.decoder = FACTORY.directBinaryDecoder(in, decoder);}
d1d066966e4967b179cb552aa686d4313f96a4b9871d824486107ef8e3bfc088
deserialize
public TetherData deserialize(TetherData datum) throws IOException
{    if (datum == null)        datum = new TetherData();    datum.buffer(decoder.readBytes(datum.buffer()));    return datum;}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    decoder.inputStream().close();}
e793703672be3533f4d1e825a0401a9f701b93150f9f026784829f249c416f13
getSerializer
public Serializer<TetherData> getSerializer(Class<TetherData> c)
{    return new TetherDataSerializer();}
5c7765297ee616456cf8e2746b1d314f4095bca1cd70e443a84f2a9a87309902
open
public void open(OutputStream out)
{    this.out = out;    this.encoder = EncoderFactory.get().directBinaryEncoder(out, encoder);}
8ef4492aaa4ec08275f932f579ba9cce1c84e891c29ae9c65de72dd126459428
serialize
public void serialize(TetherData datum) throws IOException
{    encoder.writeBytes(datum.buffer());        encoder.flush();}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    encoder.flush();    out.close();}
826e0097aae3ab29fbd42337efb5b1f3fc6505609821bc6b5020f129d1f3f721
configure
public void configure(JobConf job)
{    this.job = job;}
ab4f949f6d71c14d4e3d92b1e4aa02531d90040ab660738ff57c516309d9d5a1
run
public void run(RecordReader<TetherData, NullWritable> recordReader, OutputCollector<TetherData, NullWritable> collector, Reporter reporter) throws IOException
{    try {                process = new TetheredProcess(job, collector, reporter);                LOG.info("send configure to subprocess for map task");        process.inputClient.configure(TaskType.MAP, job.get(AvroJob.INPUT_SCHEMA), AvroJob.getMapOutputSchema(job).toString());        LOG.info("send partitions to subprocess for map task");        process.inputClient.partitions(job.getNumReduceTasks());                Counter inputRecordCounter = reporter.getCounter("org.apache.hadoop.mapred.Task$Counter", "MAP_INPUT_RECORDS");        TetherData data = new TetherData();        while (recordReader.next(data, NullWritable.get())) {            process.inputClient.input(data.buffer(), data.count());            inputRecordCounter.increment(data.count() - 1);            if (process.outputService.isFinished())                break;        }        LOG.info("send complete to subprocess for map task");        process.inputClient.complete();                if (process.outputService.waitForFinish())            throw new IOException("Task failed: " + process.outputService.error());    } catch (Throwable t) {                LOG.warn("Task failed", t);        process.inputClient.abort();        throw new IOException("Task failed: " + t, t);    } finally {                if (process != null)            process.close();    }}
71681897224d0bd0d1a488c7f1568cb6bf1552dd985c21e778561f6cd07ba006
setDeflateLevel
public static void setDeflateLevel(JobConf job, int level)
{    FileOutputFormat.setCompressOutput(job, true);    job.setInt(AvroOutputFormat.DEFLATE_LEVEL_KEY, level);}
78c7ba14fa46fd54b0a0c89d5d7977d3cc6720d0e620f53c49fc3f0a293f4600
getRecordWriter
public RecordWriter<TetherData, NullWritable> getRecordWriter(FileSystem ignore, JobConf job, String name, Progressable prog) throws IOException
{    Schema schema = AvroJob.getOutputSchema(job);    final DataFileWriter writer = new DataFileWriter(new GenericDatumWriter());    if (FileOutputFormat.getCompressOutput(job)) {        int level = job.getInt(AvroOutputFormat.DEFLATE_LEVEL_KEY, CodecFactory.DEFAULT_DEFLATE_LEVEL);        writer.setCodec(CodecFactory.deflateCodec(level));    }    Path path = FileOutputFormat.getTaskOutputPath(job, name + AvroOutputFormat.EXT);    writer.create(schema, path.getFileSystem(job).create(path));    return new RecordWriter<TetherData, NullWritable>() {        @Override        public void write(TetherData datum, NullWritable ignore) throws IOException {            writer.appendEncoded(datum.buffer());        }        @Override        public void close(Reporter reporter) throws IOException {            writer.close();        }    };}
34c5f09ca88ec9c74ac29e7aa982776a35e36491e47f2149f3ec05c78c2627b0
write
public void write(TetherData datum, NullWritable ignore) throws IOException
{    writer.appendEncoded(datum.buffer());}
d217b17bf131ccc7d63327b9a21715cc03224e14acdccb70a58b2ad62544d0f8
close
public void close(Reporter reporter) throws IOException
{    writer.close();}
de75cdbba08cabaa70472b14aeb675a2ec12c7cc9b59b12529e52cb49be09947
configure
public synchronized void configure(int inputPort)
{    LOG.info("got input port from child: inputport=" + inputPort);    this.inputPort = inputPort;    notify();}
c674b1886c3b3a6f66cfc5017376c5576643c0cb9e39d47fa55b6cac79b1aa3d
inputPort
public synchronized int inputPort() throws Exception
{    if (inputPort == 0) {        LOG.info("waiting for input port from child");        wait(TIMEOUT);    }    if (inputPort == 0) {        LOG.error("Parent process timed out waiting for subprocess to send input port. Check the job log files for more info.");        throw new Exception("Parent process timed out waiting for subprocess to send input port");    }    return inputPort;}
a98bc6a4ae4fc0ec677ab6b594d64f17425693cfda6a2bde3e20bb714153b79a
output
public void output(ByteBuffer datum)
{    try {        collector.collect(new TetherData(datum), NullWritable.get());    } catch (Throwable e) {        LOG.warn("Error: " + e, e);        synchronized (this) {            error = e.toString();        }    }}
c84b84db6bb1249c439b8f23e21a0636112e4b2127aa6be889ed7b4b17207909
outputPartitioned
public void outputPartitioned(int partition, ByteBuffer datum)
{    TetherPartitioner.setNextPartition(partition);    output(datum);}
a97ab70307c920cc8fe203c4c9a678bcbfde9cecb93ebcb8f39f7dba969bce2c
status
public void status(String message)
{    reporter.setStatus(message.toString());}
4b2c4743fcfc7d151c1b729357241fe5f1dab26ffb7b4c29f052dfff8f98aabc
count
public void count(String group, String name, long amount)
{    reporter.getCounter(group.toString(), name.toString()).increment(amount);}
8cae32502962daed631765d2efa9ff033cb0db0b07aa439e9a79e7f444e044e7
fail
public synchronized void fail(String message)
{    LOG.warn("Failing: " + message);    error = message;    notify();}
a4fdae130be96be9d0caa3e1a178f74086d464109d138860b29a92db4e4fb93c
complete
public synchronized void complete()
{    LOG.info("got task complete");    complete = true;    notify();}
7a54154124a1e9623b174cc3edb1cb2a95a89bdeeaf10ba4bdb1a65ff1e6305e
isFinished
public synchronized boolean isFinished()
{    return complete || (error != null);}
455d625b27311e4cd0f86a8c0cb8a36cec308ad8ee309f385e2ca4fa1a74b0c4
error
public String error()
{    return error;}
d7ae31cdb4fd43326ce55d410d2254466621a1e1f19ad556b129a916d77c27e4
waitForFinish
public synchronized boolean waitForFinish() throws InterruptedException
{    while (!isFinished()) wait();    return error != null;}
826e0097aae3ab29fbd42337efb5b1f3fc6505609821bc6b5020f129d1f3f721
configure
public void configure(JobConf job)
{    schema = AvroJob.getMapOutputSchema(job);}
0285fa3b3a800ef27b684a49c2bbea4f8f5c20a7e5b7756da8ffed9993d469c6
setNextPartition
 static void setNextPartition(int newValue)
{    CACHE.set(newValue);}
7b8bcda79009513977b18eee7e8843cdf9d61a8140ee11e99578a524df4e96b6
getPartition
public int getPartition(TetherData key, NullWritable value, int numPartitions)
{    Integer result = CACHE.get();    if (    result != null)        return result;    ByteBuffer b = key.buffer();    int p = b.position();    int hashCode = BinaryData.hashCode(b.array(), p, b.limit() - p, schema);    if (hashCode < 0)        hashCode = -hashCode;    return hashCode % numPartitions;}
b74ae948bba816a824396f5fcd959e744592a67ff01eb79c422acb487a04550a
getSchema
public Schema getSchema()
{    return reader.getSchema();}
26195a2efd777e07f4da09fc87185988e2f02d060ff1f69dbd65623b551cbb9b
createKey
public TetherData createKey()
{    return new TetherData();}
bb893145c84686d5b66c614a366a7233624450939702ad466536347c434aeb3f
createValue
public NullWritable createValue()
{    return NullWritable.get();}
520298d1af5c1caeddcd7a8fd348a36dc8da704e2d619ee566bb07a231d995bb
next
public boolean next(TetherData data, NullWritable ignore) throws IOException
{    if (!reader.hasNext() || reader.pastSync(end))        return false;    data.buffer(reader.nextBlock());    data.count((int) reader.getBlockCount());    return true;}
46dc59cbf7e4d6aafe0869ef2726ed2c5c897b673d9e37f94ab9b0e962f65f7f
getProgress
public float getProgress() throws IOException
{    if (end == start) {        return 0.0f;    } else {        return Math.min(1.0f, (in.tell() - start) / (float) (end - start));    }}
5800a0f531c192e683ef74c0c5de6015daf6261d1f8e5c0ce6d8e043b01926c7
getPos
public long getPos() throws IOException
{    return in.tell();}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    reader.close();}
826e0097aae3ab29fbd42337efb5b1f3fc6505609821bc6b5020f129d1f3f721
configure
public void configure(JobConf job)
{    this.job = job;}
c7508ec590a6b4a1f13a8cb8e08b56e6b4e0f3b638b5274ed5f81d1a8727458a
reduce
public void reduce(TetherData datum, Iterator<NullWritable> ignore, OutputCollector<TetherData, NullWritable> collector, Reporter reporter) throws IOException
{    try {        if (process == null) {            process = new TetheredProcess(job, collector, reporter);            process.inputClient.configure(TaskType.REDUCE, AvroJob.getMapOutputSchema(job).toString(), AvroJob.getOutputSchema(job).toString());        }        process.inputClient.input(datum.buffer(), datum.count());    } catch (IOException e) {        error = true;        throw e;    } catch (Exception e) {        error = true;        throw new IOException(e);    }}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    if (process == null)        return;    try {        if (error)            process.inputClient.abort();        else            process.inputClient.complete();        process.outputService.waitForFinish();    } catch (InterruptedException e) {        throw new IOException(e);    } finally {        process.close();    }}
5ebb3ec6a1f1f4eff670a47d2d832a581c3faaa82d6d53b07bf45fc7cf31859c
setInputKeySchema
public static void setInputKeySchema(Job job, Schema schema)
{    job.getConfiguration().set(CONF_INPUT_KEY_SCHEMA, schema.toString());}
6edbe58403d64e1f2f1eba4715432077bcfc4974b17eb4cedac501d405b870fb
setInputValueSchema
public static void setInputValueSchema(Job job, Schema schema)
{    job.getConfiguration().set(CONF_INPUT_VALUE_SCHEMA, schema.toString());}
1be4d164b342179a2d239b744957bace5865feea73c0479e85f7eb7fd56349c0
setMapOutputKeySchema
public static void setMapOutputKeySchema(Job job, Schema schema)
{    job.setMapOutputKeyClass(AvroKey.class);    job.setGroupingComparatorClass(AvroKeyComparator.class);    job.setSortComparatorClass(AvroKeyComparator.class);    AvroSerialization.setKeyWriterSchema(job.getConfiguration(), schema);    AvroSerialization.setKeyReaderSchema(job.getConfiguration(), schema);    AvroSerialization.addToConfiguration(job.getConfiguration());}
7224397736bb66eda4d946f7f41f6d9403234890c9d9e8184c88c1619cfcced0
setMapOutputValueSchema
public static void setMapOutputValueSchema(Job job, Schema schema)
{    job.setMapOutputValueClass(AvroValue.class);    AvroSerialization.setValueWriterSchema(job.getConfiguration(), schema);    AvroSerialization.setValueReaderSchema(job.getConfiguration(), schema);    AvroSerialization.addToConfiguration(job.getConfiguration());}
36aac9523bfab69009d5988ce0c9d6983c3e6b3bb8857642132a4ea54b52785d
setOutputKeySchema
public static void setOutputKeySchema(Job job, Schema schema)
{    job.setOutputKeyClass(AvroKey.class);    job.getConfiguration().set(CONF_OUTPUT_KEY_SCHEMA, schema.toString());}
2a656e307176ab526968a15d66ef580d90932b5470e8bbcf83d4ee02744346c6
setOutputValueSchema
public static void setOutputValueSchema(Job job, Schema schema)
{    job.setOutputValueClass(AvroValue.class);    job.getConfiguration().set(CONF_OUTPUT_VALUE_SCHEMA, schema.toString());}
220414e4e344447b03c61301d5c571a466451b7020ac7f6067516f4b45218ef5
setDataModelClass
public static void setDataModelClass(Job job, Class<? extends GenericData> modelClass)
{    AvroSerialization.setDataModelClass(job.getConfiguration(), modelClass);}
4984c4f2a81b26b62274d87d280b3d4a06bab39350d95d0cc971aa31c6535d84
getInputKeySchema
public static Schema getInputKeySchema(Configuration conf)
{    String schemaString = conf.get(CONF_INPUT_KEY_SCHEMA);    return schemaString != null ? new Schema.Parser().parse(schemaString) : null;}
a9b1ad697b85a66a55ccbe4c339a1344899d56d7753f1918fa90609c04791998
getInputValueSchema
public static Schema getInputValueSchema(Configuration conf)
{    String schemaString = conf.get(CONF_INPUT_VALUE_SCHEMA);    return schemaString != null ? new Schema.Parser().parse(schemaString) : null;}
6956099135c09bdf40bcca2ef8e9a4ce148d406545094fe24304e89dba51146f
getMapOutputKeySchema
public static Schema getMapOutputKeySchema(Configuration conf)
{    return AvroSerialization.getKeyWriterSchema(conf);}
4265a77fb6238df92b16b3e45419c95cc52f1ee0dc1cb5b33f3f97fbbb2d95df
getMapOutputValueSchema
public static Schema getMapOutputValueSchema(Configuration conf)
{    return AvroSerialization.getValueWriterSchema(conf);}
d147dabae3155fc64102022a891fb7055b5eb9228579dcea78b1b5dc45e7a8a8
getOutputKeySchema
public static Schema getOutputKeySchema(Configuration conf)
{    String schemaString = conf.get(CONF_OUTPUT_KEY_SCHEMA);    return schemaString != null ? new Schema.Parser().parse(schemaString) : null;}
712894a820e4addf8666d4f0a658194b6793960552c560647956c8371ad11664
getOutputValueSchema
public static Schema getOutputValueSchema(Configuration conf)
{    String schemaString = conf.get(CONF_OUTPUT_VALUE_SCHEMA);    return schemaString != null ? new Schema.Parser().parse(schemaString) : null;}
541aa9b93520bda74dba3766c6929c0dfc626453f2346f8d47a22e1ddcdf6228
createRecordReader
public RecordReader<AvroKey<T>, NullWritable> createRecordReader(InputSplit split, TaskAttemptContext context) throws IOException, InterruptedException
{    Schema readerSchema = AvroJob.getInputKeySchema(context.getConfiguration());    if (null == readerSchema) {        LOG.warn("Reader schema was not set. Use AvroJob.setInputKeySchema() if desired.");        LOG.info("Using a reader schema equal to the writer schema.");    }    return new AvroKeyRecordReader<>(readerSchema);}
e70c278a502bc28abadebd9a4a9ae339b93276d3a7ba9692688bf47bcb6f018a
create
protected RecordWriter<AvroKey<T>, NullWritable> create(Schema writerSchema, GenericData dataModel, CodecFactory compressionCodec, OutputStream outputStream, int syncInterval) throws IOException
{    return new AvroKeyRecordWriter<>(writerSchema, dataModel, compressionCodec, outputStream, syncInterval);}
db9f9a98718d4ebab95652c46e1aa24205b858caea595d34e64779cf19c2a17d
getRecordWriter
public RecordWriter<AvroKey<T>, NullWritable> getRecordWriter(TaskAttemptContext context) throws IOException
{    Configuration conf = context.getConfiguration();        Schema writerSchema = AvroJob.getOutputKeySchema(conf);    boolean isMapOnly = context.getNumReduceTasks() == 0;    if (isMapOnly) {        Schema mapOutputSchema = AvroJob.getMapOutputKeySchema(conf);        if (mapOutputSchema != null) {            writerSchema = mapOutputSchema;        }    }    if (null == writerSchema) {        throw new IOException("AvroKeyOutputFormat requires an output schema. Use AvroJob.setOutputKeySchema().");    }    GenericData dataModel = AvroSerialization.createDataModel(conf);    OutputStream out = getAvroFileOutputStream(context);    try {        return mRecordWriterFactory.create(writerSchema, dataModel, getCompressionCodec(context), out, getSyncInterval(context));    } catch (IOException e) {        out.close();        throw e;    }}
ea3a7eba5daf72a5cdc712e0c558af9956bcee4d2482e651bd64ac1a2c167657
nextKeyValue
public boolean nextKeyValue() throws IOException, InterruptedException
{    boolean hasNext = super.nextKeyValue();    mCurrentRecord.datum(getCurrentRecord());    return hasNext;}
a0ee98a155f83fdb41db1532bc31b0131ec31ed732c0be5055ade67bddc9f0c8
getCurrentKey
public AvroKey<T> getCurrentKey() throws IOException, InterruptedException
{    return mCurrentRecord;}
516196d2df7c75a44f80933c3abeffe4318669adbeb88e3be576e1a026727564
getCurrentValue
public NullWritable getCurrentValue() throws IOException, InterruptedException
{    return NullWritable.get();}
cb864df6b02b7d84efdf7138ac5aa8ae9ccbd32c121fe27ac3883e53ddd3e509
write
public void write(AvroKey<T> record, NullWritable ignore) throws IOException
{    mAvroFileWriter.append(record.datum());}
118202e50c9711dbea3c9045d10f01c58e2fd2ce631f1eb50a35dad80b983835
close
public void close(TaskAttemptContext context) throws IOException
{    mAvroFileWriter.close();}
68700e282dedb2cc4a3744ccbce0c3ac94d8bd81bb44dbc5f75e7030ae6be445
sync
public long sync() throws IOException
{    return mAvroFileWriter.sync();}
db40e96216d3bad43ff76da9b1ff2d69ff85329f1c9a7fe3c28d25504dbaeb59
createRecordReader
public RecordReader<AvroKey<K>, AvroValue<V>> createRecordReader(InputSplit split, TaskAttemptContext context) throws IOException, InterruptedException
{    Schema keyReaderSchema = AvroJob.getInputKeySchema(context.getConfiguration());    if (null == keyReaderSchema) {        LOG.warn("Key reader schema was not set. Use AvroJob.setInputKeySchema() if desired.");        LOG.info("Using a key reader schema equal to the writer schema.");    }    Schema valueReaderSchema = AvroJob.getInputValueSchema(context.getConfiguration());    if (null == valueReaderSchema) {        LOG.warn("Value reader schema was not set. Use AvroJob.setInputValueSchema() if desired.");        LOG.info("Using a value reader schema equal to the writer schema.");    }    return new AvroKeyValueRecordReader<>(keyReaderSchema, valueReaderSchema);}
71e52a3f35921040057bea91c2d5a2f2bf13f5932dd4f984babc2d2dbeeb9064
getRecordWriter
public RecordWriter<K, V> getRecordWriter(TaskAttemptContext context) throws IOException
{    Configuration conf = context.getConfiguration();    AvroDatumConverterFactory converterFactory = new AvroDatumConverterFactory(conf);    AvroDatumConverter<K, ?> keyConverter = converterFactory.create((Class<K>) context.getOutputKeyClass());    AvroDatumConverter<V, ?> valueConverter = converterFactory.create((Class<V>) context.getOutputValueClass());    GenericData dataModel = AvroSerialization.createDataModel(conf);    OutputStream out = getAvroFileOutputStream(context);    try {        return new AvroKeyValueRecordWriter<>(keyConverter, valueConverter, dataModel, getCompressionCodec(context), out, getSyncInterval(context));    } catch (IOException e) {        out.close();        throw e;    }}
ea3a7eba5daf72a5cdc712e0c558af9956bcee4d2482e651bd64ac1a2c167657
nextKeyValue
public boolean nextKeyValue() throws IOException, InterruptedException
{    boolean hasNext = super.nextKeyValue();    if (hasNext) {        AvroKeyValue<K, V> avroKeyValue = new AvroKeyValue<>(getCurrentRecord());        mCurrentKey.datum(avroKeyValue.getKey());        mCurrentValue.datum(avroKeyValue.getValue());    } else {        mCurrentKey.datum(null);        mCurrentValue.datum(null);    }    return hasNext;}
b9308e912574dc4ed3683127cb63b67e361f4f51afeb39087e6b7db7ec03b81e
getCurrentKey
public AvroKey<K> getCurrentKey() throws IOException, InterruptedException
{    return mCurrentKey;}
3e9341d85bfe9bb0f6260fd7a744ccbf8249c5fc0a952a635c2b6d4a45d63697
getCurrentValue
public AvroValue<V> getCurrentValue() throws IOException, InterruptedException
{    return mCurrentValue;}
ed3c0ab53c4805f275920fe7ad5d6189de4ea944c88d3ed82ef2df2dd2523e14
getWriterSchema
public Schema getWriterSchema()
{    return mKeyValuePairSchema;}
44b3b7401a140e39e62134b31a2a6741d6ac4c1f92c94603b1986ce9900a2a21
write
public void write(K key, V value) throws IOException
{    mOutputRecord.setKey(mKeyConverter.convert(key));    mOutputRecord.setValue(mValueConverter.convert(value));    mAvroFileWriter.append(mOutputRecord.get());}
118202e50c9711dbea3c9045d10f01c58e2fd2ce631f1eb50a35dad80b983835
close
public void close(TaskAttemptContext context) throws IOException
{    mAvroFileWriter.close();}
68700e282dedb2cc4a3744ccbce0c3ac94d8bd81bb44dbc5f75e7030ae6be445
sync
public long sync() throws IOException
{    return mAvroFileWriter.sync();}
475ccce25bb06ed93161835e138832bde7f55dbcc9c569fa0573b1a0c337f9ff
checkTokenName
private static void checkTokenName(String namedOutput)
{    if (namedOutput == null || namedOutput.length() == 0) {        throw new IllegalArgumentException("Name cannot be NULL or empty");    }    for (char ch : namedOutput.toCharArray()) {        if ((ch >= 'A') && (ch <= 'Z')) {            continue;        }        if ((ch >= 'a') && (ch <= 'z')) {            continue;        }        if ((ch >= '0') && (ch <= '9')) {            continue;        }        throw new IllegalArgumentException("Name cannot have a '" + ch + "' char");    }}
b23dfb1c710a694bf908bcd0d8f2a0e760f77f203a01ca4768735ab24abb949b
checkBaseOutputPath
private static void checkBaseOutputPath(String outputPath)
{    if (outputPath.equals("part")) {        throw new IllegalArgumentException("output name cannot be 'part'");    }}
71bd9561c1aed08f453ef5f244d5ccba2551e54d7aa58f231c1b66c331145e55
checkNamedOutputName
private static void checkNamedOutputName(JobContext job, String namedOutput, boolean alreadyDefined)
{    checkTokenName(namedOutput);    checkBaseOutputPath(namedOutput);    List<String> definedChannels = getNamedOutputsList(job);    if (alreadyDefined && definedChannels.contains(namedOutput)) {        throw new IllegalArgumentException("Named output '" + namedOutput + "' already alreadyDefined");    } else if (!alreadyDefined && !definedChannels.contains(namedOutput)) {        throw new IllegalArgumentException("Named output '" + namedOutput + "' not defined");    }}
a594174bde904327a02ecb56fda35e8cbe4a43e13d10370813053b0cd5893b42
getNamedOutputsList
private static List<String> getNamedOutputsList(JobContext job)
{    List<String> names = new ArrayList<>();    StringTokenizer st = new StringTokenizer(job.getConfiguration().get(MULTIPLE_OUTPUTS, ""), " ");    while (st.hasMoreTokens()) {        names.add(st.nextToken());    }    return names;}
ea7e377da53b9927ecf537199b54916c1bb53e5342ea08a110ab7d1b5fbd78fe
getNamedOutputFormatClass
private static Class<? extends OutputFormat<?, ?>> getNamedOutputFormatClass(JobContext job, String namedOutput)
{    return (Class<? extends OutputFormat<?, ?>>) job.getConfiguration().getClass(MO_PREFIX + namedOutput + FORMAT, null, OutputFormat.class);}
b542248159b6a291294fb16268ea873dcd22444b0a95ff8406ae1356bf821960
addNamedOutput
public static void addNamedOutput(Job job, String namedOutput, Class<? extends OutputFormat> outputFormatClass, Schema keySchema)
{    addNamedOutput(job, namedOutput, outputFormatClass, keySchema, null);}
0d9ebda7cc822aaa32e55b9c51a1980abb78f1860d90dfbf0e5aee6b11363d64
addNamedOutput
public static void addNamedOutput(Job job, String namedOutput, Class<? extends OutputFormat> outputFormatClass, Schema keySchema, Schema valueSchema)
{    checkNamedOutputName(job, namedOutput, true);    Configuration conf = job.getConfiguration();    conf.set(MULTIPLE_OUTPUTS, conf.get(MULTIPLE_OUTPUTS, "") + " " + namedOutput);    conf.setClass(MO_PREFIX + namedOutput + FORMAT, outputFormatClass, OutputFormat.class);    conf.set(MO_PREFIX + namedOutput + ".keyschema", keySchema.toString());    if (valueSchema != null) {        conf.set(MO_PREFIX + namedOutput + ".valueschema", valueSchema.toString());    }}
49932a9f2609a7a06b276acb5ee5707c1aa4fb9537702c14a838cbcb3e039435
setCountersEnabled
public static void setCountersEnabled(Job job, boolean enabled)
{    job.getConfiguration().setBoolean(COUNTERS_ENABLED, enabled);}
f1c3f59f9c982eb520f4763ce00ca72a61a8d814c0058a33eec3e5373cceff53
getCountersEnabled
public static boolean getCountersEnabled(JobContext job)
{    return job.getConfiguration().getBoolean(COUNTERS_ENABLED, false);}
b76e32d50b7f52f1cd4c94768592b4994d81ab6f7deee0c97ee7931837339cd2
write
public void write(Object key, Object value) throws IOException, InterruptedException
{    context.getCounter(COUNTERS_GROUP, counterName).increment(1);    writer.write(key, value);}
b8b34e2eb30c67c8979d27754340818dab91e35c6af795f1b114e238b3f0efd0
close
public void close(TaskAttemptContext context) throws IOException, InterruptedException
{    writer.close(context);}
53499c5fb02fc6a36216ae30891d28d7a04ac3108a4aff1ef8fb62811680c010
write
public void write(String namedOutput, Object key) throws IOException, InterruptedException
{    write(namedOutput, key, NullWritable.get(), namedOutput);}
f5a63f6668b0df5c983754dc6a3fd41a0b3ad2d65cbd38abc776960bae0d4265
write
public void write(String namedOutput, Object key, Object value) throws IOException, InterruptedException
{    write(namedOutput, key, value, namedOutput);}
d2873e81c81d954ef383254bd4896c20314df6d2bd70075d8640bfdc0b407454
write
public void write(String namedOutput, Object key, Object value, String baseOutputPath) throws IOException, InterruptedException
{    checkNamedOutputName(context, namedOutput, false);    checkBaseOutputPath(baseOutputPath);    if (!namedOutputs.contains(namedOutput)) {        throw new IllegalArgumentException("Undefined named output '" + namedOutput + "'");    }    TaskAttemptContext taskContext = getContext(namedOutput);    getRecordWriter(taskContext, baseOutputPath).write(key, value);}
309bafeb2da4174fa15a4cace2291efb4ac8e374b46f7e5e95f6cb7e1df8542e
write
public void write(Object key, Object value, String baseOutputPath) throws IOException, InterruptedException
{    write(key, value, null, null, baseOutputPath);}
ecb5c66299a9af724c0afca1dff9e9adf60bbaabeaff9caa4b55a0488841245a
write
public void write(Object key, Object value, Schema keySchema, Schema valSchema, String baseOutputPath) throws IOException, InterruptedException
{    checkBaseOutputPath(baseOutputPath);    Job job = Job.getInstance(context.getConfiguration());    setSchema(job, keySchema, valSchema);    TaskAttemptContext taskContext = createTaskAttemptContext(job.getConfiguration(), context.getTaskAttemptID());    getRecordWriter(taskContext, baseOutputPath).write(key, value);}
96244e64682b5c891eec2dd60bf804d65391a38909a65ce4a6d9c5b192542bd6
sync
public long sync(String namedOutput, String baseOutputPath) throws IOException, InterruptedException
{    checkNamedOutputName(context, namedOutput, false);    checkBaseOutputPath(baseOutputPath);    if (!namedOutputs.contains(namedOutput)) {        throw new IllegalArgumentException("Undefined named output '" + namedOutput + "'");    }    TaskAttemptContext taskContext = getContext(namedOutput);    RecordWriter recordWriter = getRecordWriter(taskContext, baseOutputPath);    long position = -1;    if (recordWriter instanceof Syncable) {        Syncable syncableWriter = (Syncable) recordWriter;        position = syncableWriter.sync();    }    return position;}
e8284260ce668290b7d46f4be93b404cfc4ef63a8b04cf920fd084903541e5ac
getRecordWriter
private synchronized RecordWriter getRecordWriter(TaskAttemptContext taskContext, String baseFileName) throws IOException, InterruptedException
{        RecordWriter writer = recordWriters.get(baseFileName);        if (writer == null) {                        taskContext.getConfiguration().set("avro.mo.config.namedOutput", baseFileName);        try {            writer = ReflectionUtils.newInstance(taskContext.getOutputFormatClass(), taskContext.getConfiguration()).getRecordWriter(taskContext);        } catch (ClassNotFoundException e) {            throw new IOException(e);        }                if (countersEnabled) {            writer = new RecordWriterWithCounter(writer, baseFileName, context);        }                recordWriters.put(baseFileName, writer);    }    return writer;}
a19fe66c91ef950c33e33c07e445fb1de8194cdf68f4e7929d9a0ef0be41f16d
setSchema
private void setSchema(Job job, Schema keySchema, Schema valSchema)
{    boolean isMaponly = job.getNumReduceTasks() == 0;    if (keySchema != null) {        if (isMaponly)            AvroJob.setMapOutputKeySchema(job, keySchema);        else            AvroJob.setOutputKeySchema(job, keySchema);    }    if (valSchema != null) {        if (isMaponly)            AvroJob.setMapOutputValueSchema(job, valSchema);        else            AvroJob.setOutputValueSchema(job, valSchema);    }}
f76756912d2c63ace7859ead2bfd6dc18a8203b401e2af01a153096adc58be3c
getContext
private TaskAttemptContext getContext(String nameOutput) throws IOException
{    TaskAttemptContext taskContext = taskContexts.get(nameOutput);    if (taskContext != null) {        return taskContext;    }            Job job = new Job(context.getConfiguration());    job.setOutputFormatClass(getNamedOutputFormatClass(context, nameOutput));    Schema keySchema = null, valSchema = null;    if (job.getConfiguration().get(MO_PREFIX + nameOutput + ".keyschema", null) != null)        keySchema = Schema.parse(job.getConfiguration().get(MO_PREFIX + nameOutput + ".keyschema"));    if (job.getConfiguration().get(MO_PREFIX + nameOutput + ".valueschema", null) != null)        valSchema = Schema.parse(job.getConfiguration().get(MO_PREFIX + nameOutput + ".valueschema"));    setSchema(job, keySchema, valSchema);    taskContext = createTaskAttemptContext(job.getConfiguration(), context.getTaskAttemptID());    taskContexts.put(nameOutput, taskContext);    return taskContext;}
eda3fad93eb58ea32c600d22fad1a3420299c0a131cfb40ddb93efbde2179217
createTaskAttemptContext
private TaskAttemptContext createTaskAttemptContext(Configuration conf, TaskAttemptID taskId)
{        try {        Class<?> c = getTaskAttemptContextClass();        Constructor<?> cons = c.getConstructor(Configuration.class, TaskAttemptID.class);        return (TaskAttemptContext) cons.newInstance(conf, taskId);    } catch (Exception e) {        throw new IllegalStateException(e);    }}
a9db4808f50550b31fe77632222b62d8fdd25fd134a353ec490824a96624164b
getTaskAttemptContextClass
private Class<?> getTaskAttemptContextClass()
{    try {        return Class.forName("org.apache.hadoop.mapreduce.task.TaskAttemptContextImpl");    } catch (Exception e) {        try {            return Class.forName("org.apache.hadoop.mapreduce.TaskAttemptContext");        } catch (Exception ex) {            throw new IllegalStateException(ex);        }    }}
9e818b59b77b5db0779404d46b38169add768940d01946f18308e6833d14b082
close
public void close() throws IOException, InterruptedException
{    for (RecordWriter writer : recordWriters.values()) {        writer.close(context);    }}
40e962ca3b57084a82eff9c8117a28b48a11e72aea0fc2709b36eb54166c6609
getCompressionCodec
protected static CodecFactory getCompressionCodec(TaskAttemptContext context)
{    if (FileOutputFormat.getCompressOutput(context)) {                int deflateLevel = context.getConfiguration().getInt(org.apache.avro.mapred.AvroOutputFormat.DEFLATE_LEVEL_KEY, CodecFactory.DEFAULT_DEFLATE_LEVEL);        int xzLevel = context.getConfiguration().getInt(org.apache.avro.mapred.AvroOutputFormat.XZ_LEVEL_KEY, CodecFactory.DEFAULT_XZ_LEVEL);        String outputCodec = context.getConfiguration().get(AvroJob.CONF_OUTPUT_CODEC);        if (outputCodec == null) {            String compressionCodec = context.getConfiguration().get("mapred.output.compression.codec");            String avroCodecName = HadoopCodecFactory.getAvroCodecName(compressionCodec);            if (avroCodecName != null) {                context.getConfiguration().set(AvroJob.CONF_OUTPUT_CODEC, avroCodecName);                return HadoopCodecFactory.fromHadoopString(compressionCodec);            } else {                return CodecFactory.deflateCodec(deflateLevel);            }        } else if (DataFileConstants.DEFLATE_CODEC.equals(outputCodec)) {            return CodecFactory.deflateCodec(deflateLevel);        } else if (DataFileConstants.XZ_CODEC.equals(outputCodec)) {            return CodecFactory.xzCodec(xzLevel);        } else {            return CodecFactory.fromString(outputCodec);        }    }        return CodecFactory.nullCodec();}
d05955ce987812a8ed9f4c0e5a7c31c8686f1464e042782d5310171109178c5e
getAvroFileOutputStream
protected OutputStream getAvroFileOutputStream(TaskAttemptContext context) throws IOException
{    Path path = new Path(((FileOutputCommitter) getOutputCommitter(context)).getWorkPath(), getUniqueFile(context, context.getConfiguration().get("avro.mo.config.namedOutput", "part"), org.apache.avro.mapred.AvroOutputFormat.EXT));    return path.getFileSystem(context.getConfiguration()).create(path);}
63fb695401bacbf021b505de2031f1854eb43c0288aa3589834e55e571b558f8
getSyncInterval
protected static int getSyncInterval(TaskAttemptContext context)
{    return context.getConfiguration().getInt(org.apache.avro.mapred.AvroOutputFormat.SYNC_INTERVAL_KEY, DataFileConstants.DEFAULT_SYNC_INTERVAL);}
31d67f0ebcfeca7fe0122ca3a067df23149a597f7062117725ccce7015a54168
initialize
public void initialize(InputSplit inputSplit, TaskAttemptContext context) throws IOException, InterruptedException
{    if (!(inputSplit instanceof FileSplit)) {        throw new IllegalArgumentException("Only compatible with FileSplits.");    }    FileSplit fileSplit = (FileSplit) inputSplit;        SeekableInput seekableFileInput = createSeekableInput(context.getConfiguration(), fileSplit.getPath());        Configuration conf = context.getConfiguration();    GenericData dataModel = AvroSerialization.createDataModel(conf);    DatumReader<T> datumReader = dataModel.createDatumReader(mReaderSchema);    mAvroFileReader = createAvroFileReader(seekableFileInput, datumReader);                                    mAvroFileReader.sync(fileSplit.getStart());            mStartPosition = mAvroFileReader.previousSync();                mEndPosition = fileSplit.getStart() + fileSplit.getLength();}
ea3a7eba5daf72a5cdc712e0c558af9956bcee4d2482e651bd64ac1a2c167657
nextKeyValue
public boolean nextKeyValue() throws IOException, InterruptedException
{    assert null != mAvroFileReader;    if (mAvroFileReader.hasNext() && !mAvroFileReader.pastSync(mEndPosition)) {        mCurrentRecord = mAvroFileReader.next(mCurrentRecord);        return true;    }    return false;}
e6a44445685ea2b0efb4761e11c07379596d7cd89a49901e52b03fbe83285805
getProgress
public float getProgress() throws IOException, InterruptedException
{    assert null != mAvroFileReader;    if (mEndPosition == mStartPosition) {                return 0.0f;    }    long bytesRead = mAvroFileReader.previousSync() - mStartPosition;    long bytesTotal = mEndPosition - mStartPosition;    LOG.debug("Progress: bytesRead=" + bytesRead + ", bytesTotal=" + bytesTotal);    return Math.min(1.0f, (float) bytesRead / (float) bytesTotal);}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    if (null != mAvroFileReader) {        try {            mAvroFileReader.close();        } finally {            mAvroFileReader = null;        }    }}
3ae54090b9a3cbb4546b1848751974d75b4bc1389962804f0f8b5437c328addc
getCurrentRecord
protected T getCurrentRecord()
{    return mCurrentRecord;}
dbb146daeba344873546f64ab7d207c698709f8de56f74a50bd2990029fc90c0
createSeekableInput
protected SeekableInput createSeekableInput(Configuration conf, Path path) throws IOException
{    return new FsInput(path, conf);}
dfb5a288f43e7297e4eaf6dc2b3e0147c2621444ecc12782132e5505e28760a4
createAvroFileReader
protected DataFileReader<T> createAvroFileReader(SeekableInput input, DatumReader<T> datumReader) throws IOException
{    return new DataFileReader<>(input, datumReader);}
3ac6ce6a1890b81508dac9d616d7e4ddd732b66debddd273b12eca35f7c1e4bb
createRecordReader
public RecordReader<K, V> createRecordReader(InputSplit inputSplit, TaskAttemptContext context) throws IOException
{    return new AvroSequenceFileRecordReader();}
9d0cf270b93b06f7b05e0b26685b605f12e030ebd482ce0d8a319c619269541a
initialize
public void initialize(InputSplit split, TaskAttemptContext context) throws IOException, InterruptedException
{    FileSplit fileSplit = (FileSplit) split;    Configuration conf = context.getConfiguration();    Path path = fileSplit.getPath();    FileSystem fs = path.getFileSystem(conf);        AvroSequenceFile.Reader.Options options = new AvroSequenceFile.Reader.Options().withFileSystem(fs).withInputPath(path).withConfiguration(conf);    Schema keySchema = AvroJob.getInputKeySchema(conf);    if (null != keySchema) {        options.withKeySchema(keySchema);    }    Schema valueSchema = AvroJob.getInputValueSchema(conf);    if (null != valueSchema) {        options.withValueSchema(valueSchema);    }    mReader = new AvroSequenceFile.Reader(options);    mEnd = fileSplit.getStart() + fileSplit.getLength();    if (fileSplit.getStart() > mReader.getPosition()) {                mReader.sync(fileSplit.getStart());    }    mStart = mReader.getPosition();    mHasMoreData = mStart < mEnd;}
ea3a7eba5daf72a5cdc712e0c558af9956bcee4d2482e651bd64ac1a2c167657
nextKeyValue
public boolean nextKeyValue() throws IOException, InterruptedException
{    if (!mHasMoreData) {        return false;    }    long pos = mReader.getPosition();    mCurrentKey = (K) mReader.next(mCurrentKey);    if (null == mCurrentKey || (pos >= mEnd && mReader.syncSeen())) {        mHasMoreData = false;        mCurrentKey = null;        mCurrentValue = null;    } else {        mCurrentValue = (V) mReader.getCurrentValue(mCurrentValue);    }    return mHasMoreData;}
b6f3f7c12f8efaa2d07aee08980b055c579680478ea3aa45c4089ea044a0920b
getCurrentKey
public K getCurrentKey()
{    return mCurrentKey;}
db22bda391bc491af2db79041ded0134faf7cd2e3edff3669ca917066095d900
getCurrentValue
public V getCurrentValue()
{    return mCurrentValue;}
46dc59cbf7e4d6aafe0869ef2726ed2c5c897b673d9e37f94ab9b0e962f65f7f
getProgress
public float getProgress() throws IOException
{    if (mEnd == mStart) {        return 0.0f;    } else {        return Math.min(1.0f, (mReader.getPosition() - mStart) / (float) (mEnd - mStart));    }}
9b54ee9eb50c9cbdd959f0273108f77f9dc460339fff2b1de4192c511db8fe67
close
public synchronized void close() throws IOException
{    mReader.close();}
4abda4fbd6e58b6465fc9caf122fdf7aa723d4dc866f557dcb11019f9f5aa493
getRecordWriter
public RecordWriter<K, V> getRecordWriter(TaskAttemptContext context) throws IOException, InterruptedException
{    Configuration conf = context.getConfiguration();        CompressionCodec codec = null;    CompressionType compressionType = CompressionType.NONE;    if (getCompressOutput(context)) {                compressionType = getOutputCompressionType(conf);                Class<?> codecClass = getOutputCompressorClass(context, DefaultCodec.class);        codec = (CompressionCodec) ReflectionUtils.newInstance(codecClass, conf);    }        Path outputFile = getDefaultWorkFile(context, "");    FileSystem fs = outputFile.getFileSystem(conf);        AvroSequenceFile.Writer.Options options = new AvroSequenceFile.Writer.Options().withFileSystem(fs).withConfiguration(conf).withOutputPath(outputFile).withKeyClass(context.getOutputKeyClass()).withValueClass(context.getOutputValueClass()).withProgressable(context).withCompressionType(compressionType).withCompressionCodec(codec);    Schema keySchema = AvroJob.getOutputKeySchema(conf);    if (null != keySchema) {        options.withKeySchema(keySchema);    }    Schema valueSchema = AvroJob.getOutputValueSchema(conf);    if (null != valueSchema) {        options.withValueSchema(valueSchema);    }    final SequenceFile.Writer out = AvroSequenceFile.createWriter(options);    return new RecordWriter<K, V>() {        @Override        public void write(K key, V value) throws IOException {            out.append(key, value);        }        @Override        public void close(TaskAttemptContext context) throws IOException {            out.close();        }    };}
44b3b7401a140e39e62134b31a2a6741d6ac4c1f92c94603b1986ce9900a2a21
write
public void write(K key, V value) throws IOException
{    out.append(key, value);}
118202e50c9711dbea3c9045d10f01c58e2fd2ce631f1eb50a35dad80b983835
close
public void close(TaskAttemptContext context) throws IOException
{    out.close();}
11f8b6181ed5655cddc6059d8ac18c0d25109e80c37e76a26ecb813c9e27dda5
setOutputCompressionType
public static void setOutputCompressionType(Job job, CompressionType compressionType)
{    setCompressOutput(job, true);    job.getConfiguration().set(FileOutputFormat.COMPRESS_TYPE, compressionType.name());}
0ff3cc763a4018a485e084d82a6b39f5ed4f79acc0ada85603dced5cc014764e
getOutputCompressionType
public static CompressionType getOutputCompressionType(Configuration conf)
{    String typeName = conf.get(FileOutputFormat.COMPRESS_TYPE);    if (typeName != null) {        return CompressionType.valueOf(typeName);    }    return SequenceFile.getDefaultCompressionType(conf);}
f86f0a07c467295dbb0e61e1d59a03270071bfd2f747afc04e89a6997b900834
createRecordReader
public RecordReader<AvroKey<K>, AvroValue<V>> createRecordReader(InputSplit inputSplit, TaskAttemptContext taskAttemptContext) throws IOException
{    return new CombineFileRecordReader((CombineFileSplit) inputSplit, taskAttemptContext, CombineAvroKeyValueFileInputFormat.AvroKeyValueFileRecordReaderWrapper.class);}
d604ae1004648b450fb104b099dd1f474e3615e6e6e7315fcb28a6475ceb9f88
testHadoopCodecFactoryDeflate
public void testHadoopCodecFactoryDeflate()
{    CodecFactory hadoopDeflateCodec = HadoopCodecFactory.fromHadoopString("org.apache.hadoop.io.compress.DeflateCodec");    CodecFactory avroDeflateCodec = CodecFactory.fromString("deflate");    assertTrue(hadoopDeflateCodec.getClass().equals(avroDeflateCodec.getClass()));}
3a98f4aadde75c91688519cd289bc5e45f26d339dfb20167aadf577e680ed061
testHadoopCodecFactorySnappy
public void testHadoopCodecFactorySnappy()
{    CodecFactory hadoopSnappyCodec = HadoopCodecFactory.fromHadoopString("org.apache.hadoop.io.compress.SnappyCodec");    CodecFactory avroSnappyCodec = CodecFactory.fromString("snappy");    assertTrue(hadoopSnappyCodec.getClass().equals(avroSnappyCodec.getClass()));}
dddf00f6e50a44f41782ca9c37c1118db940915e922d320acb585cb6b2259e47
testHadoopCodecFactoryBZip2
public void testHadoopCodecFactoryBZip2()
{    CodecFactory hadoopSnappyCodec = HadoopCodecFactory.fromHadoopString("org.apache.hadoop.io.compress.BZip2Codec");    CodecFactory avroSnappyCodec = CodecFactory.fromString("bzip2");    assertTrue(hadoopSnappyCodec.getClass().equals(avroSnappyCodec.getClass()));}
1de364c82897bad7e50cd78c82a9dfb47fb5cb9ed30d7c2b1c25edf94a8703e9
testHadoopCodecFactoryGZip
public void testHadoopCodecFactoryGZip()
{    CodecFactory hadoopSnappyCodec = HadoopCodecFactory.fromHadoopString("org.apache.hadoop.io.compress.GZipCodec");    CodecFactory avroSnappyCodec = CodecFactory.fromString("deflate");    assertTrue(hadoopSnappyCodec.getClass().equals(avroSnappyCodec.getClass()));}
adbf5d0134725b0a80b11e6b9bd1622606c8e31e62113f3939fff57407e29087
testHadoopCodecFactoryFail
public void testHadoopCodecFactoryFail()
{    CodecFactory hadoopSnappyCodec = HadoopCodecFactory.fromHadoopString("org.apache.hadoop.io.compress.FooCodec");    assertTrue(hadoopSnappyCodec == null);}
0cc5c5391bb2eb8bb6202e661dac12a6c6b8388400f02c7cd6f3eda7f5a4ea1e
testWriteOutOfSortedOrder
public void testWriteOutOfSortedOrder() throws IOException
{    LOG.debug("Writing some records to a SortedKeyValueFile...");    Configuration conf = new Configuration();    SortedKeyValueFile.Writer.Options options = new SortedKeyValueFile.Writer.Options().withKeySchema(Schema.create(Schema.Type.STRING)).withValueSchema(Schema.create(Schema.Type.STRING)).withConfiguration(conf).withPath(new Path(mTempDir.getRoot().getPath(), "myfile")).withIndexInterval(    2);    try (SortedKeyValueFile.Writer<CharSequence, CharSequence> writer = new SortedKeyValueFile.Writer<>(options)) {                Utf8 key = new Utf8();        writer.append(key.set("banana"), "Banana");                writer.append(key.set("apple"), "Apple");    }}
5cd1155bd4c74588faa69b1c69aa23fcf2b24895a4dda0cd70550b9a38af17e2
testNamedCodecs
public void testNamedCodecs() throws IOException
{    Configuration conf = new Configuration();    Path myfile = new Path(mTempDir.getRoot().getPath(), "myfile");    Schema key = Schema.create(Schema.Type.STRING);    Schema value = Schema.create(Schema.Type.STRING);    Schema recordSchema = AvroKeyValue.getSchema(key, value);    DatumReader<GenericRecord> datumReader = SpecificData.get().createDatumReader(recordSchema);    DataFileReader<GenericRecord> reader;    SortedKeyValueFile.Writer.Options options = new SortedKeyValueFile.Writer.Options().withKeySchema(key).withValueSchema(value).withConfiguration(conf).withPath(myfile);    SortedKeyValueFile.Writer<CharSequence, CharSequence> writer;    for (String codec : new String[] { "null", "deflate", "snappy", "bzip2" }) {        LOG.debug("Using " + codec + "codec for a SortedKeyValueFile...");        options.withCodec(codec);        writer = new SortedKeyValueFile.Writer<>(options);        writer.close();        reader = new DataFileReader<>(new FsInput(new Path(myfile, SortedKeyValueFile.DATA_FILENAME), conf), datumReader);        assertEquals(codec, reader.getMetaString("avro.codec"));        reader.close();    }}
f898fdf16360972be31fbe6a39cb37e4d2c20eb91d2f476f289a1502cc432da7
testDeflateClassCodec
public void testDeflateClassCodec() throws IOException
{    Configuration conf = new Configuration();    Path myfile = new Path(mTempDir.getRoot().getPath(), "myfile");    Schema key = Schema.create(Schema.Type.STRING);    Schema value = Schema.create(Schema.Type.STRING);    Schema recordSchema = AvroKeyValue.getSchema(key, value);    DatumReader<GenericRecord> datumReader = SpecificData.get().createDatumReader(recordSchema);    DataFileReader<GenericRecord> reader;    LOG.debug("Using CodecFactory.deflateCodec() for a SortedKeyValueFile...");    SortedKeyValueFile.Writer.Options options = new SortedKeyValueFile.Writer.Options().withKeySchema(key).withValueSchema(value).withConfiguration(conf).withPath(myfile).withCodec(CodecFactory.deflateCodec(9));    SortedKeyValueFile.Writer<CharSequence, CharSequence> writer = new SortedKeyValueFile.Writer<>(options);    writer.close();    reader = new DataFileReader<>(new FsInput(new Path(myfile, SortedKeyValueFile.DATA_FILENAME), conf), datumReader);    assertEquals("deflate", reader.getMetaString("avro.codec"));    reader.close();}
ba68c741d976294105d9c9eb6681f927b5b1e3f74b08a02deb32eeb3ea469cc7
testBadCodec
public void testBadCodec() throws IOException
{    LOG.debug("Using a bad codec for a SortedKeyValueFile...");    try {        SortedKeyValueFile.Writer.Options options = new SortedKeyValueFile.Writer.Options().withCodec("foobar");    } catch (AvroRuntimeException e) {        assertEquals("Unrecognized codec: foobar", e.getMessage());    }}
5c03e227bb8c71b0f605a8b0eaf457f1440876647cc67d7151c96833f6dfccff
testWriter
public void testWriter() throws IOException
{    LOG.debug("Writing some records to a SortedKeyValueFile...");    Configuration conf = new Configuration();    SortedKeyValueFile.Writer.Options options = new SortedKeyValueFile.Writer.Options().withKeySchema(Schema.create(Schema.Type.STRING)).withValueSchema(Schema.create(Schema.Type.STRING)).withConfiguration(conf).withPath(new Path(mTempDir.getRoot().getPath(), "myfile")).withIndexInterval(    2);    try (SortedKeyValueFile.Writer<CharSequence, CharSequence> writer = new SortedKeyValueFile.Writer<>(options)) {                writer.append("apple", "Apple");        writer.append("banana", "Banana");                writer.append("carrot", "Carrot");        writer.append("durian", "Durian");    }    LOG.debug("Checking the generated directory...");    File directory = new File(mTempDir.getRoot().getPath(), "myfile");    assertTrue(directory.exists());    LOG.debug("Checking the generated index file...");    File indexFile = new File(directory, SortedKeyValueFile.INDEX_FILENAME);    DatumReader<GenericRecord> indexReader = new GenericDatumReader<>(AvroKeyValue.getSchema(options.getKeySchema(), Schema.create(Schema.Type.LONG)));    List<AvroKeyValue<CharSequence, Long>> indexRecords = new ArrayList<>();    try (FileReader<GenericRecord> indexFileReader = DataFileReader.openReader(indexFile, indexReader)) {        for (GenericRecord indexRecord : indexFileReader) {            indexRecords.add(new AvroKeyValue<>(indexRecord));        }    }    assertEquals(2, indexRecords.size());    assertEquals("apple", indexRecords.get(0).getKey().toString());    LOG.debug("apple's position in the file: " + indexRecords.get(0).getValue());    assertEquals("carrot", indexRecords.get(1).getKey().toString());    LOG.debug("carrot's position in the file: " + indexRecords.get(1).getValue());    LOG.debug("Checking the generated data file...");    File dataFile = new File(directory, SortedKeyValueFile.DATA_FILENAME);    DatumReader<GenericRecord> dataReader = new GenericDatumReader<>(AvroKeyValue.getSchema(options.getKeySchema(), options.getValueSchema()));    try (DataFileReader<GenericRecord> dataFileReader = new DataFileReader<>(dataFile, dataReader)) {        dataFileReader.seek(indexRecords.get(0).getValue());        assertTrue(dataFileReader.hasNext());        AvroKeyValue<CharSequence, CharSequence> appleRecord = new AvroKeyValue<>(dataFileReader.next());        assertEquals("apple", appleRecord.getKey().toString());        assertEquals("Apple", appleRecord.getValue().toString());        dataFileReader.seek(indexRecords.get(1).getValue());        assertTrue(dataFileReader.hasNext());        AvroKeyValue<CharSequence, CharSequence> carrotRecord = new AvroKeyValue<>(dataFileReader.next());        assertEquals("carrot", carrotRecord.getKey().toString());        assertEquals("Carrot", carrotRecord.getValue().toString());        assertTrue(dataFileReader.hasNext());        AvroKeyValue<CharSequence, CharSequence> durianRecord = new AvroKeyValue<>(dataFileReader.next());        assertEquals("durian", durianRecord.getKey().toString());        assertEquals("Durian", durianRecord.getValue().toString());    }}
eb4cd88d7ae02d9e45ed7d86fd1ae5374467fbab30c265526ec6850b12e992fc
testReader
public void testReader() throws IOException
{    Configuration conf = new Configuration();    SortedKeyValueFile.Writer.Options writerOptions = new SortedKeyValueFile.Writer.Options().withKeySchema(Schema.create(Schema.Type.STRING)).withValueSchema(Schema.create(Schema.Type.STRING)).withConfiguration(conf).withPath(new Path(mTempDir.getRoot().getPath(), "myfile")).withIndexInterval(    2);    try (SortedKeyValueFile.Writer<CharSequence, CharSequence> writer = new SortedKeyValueFile.Writer<>(writerOptions)) {                writer.append("apple", "Apple");        writer.append("banana", "Banana");                writer.append("carrot", "Carrot");        writer.append("durian", "Durian");    }    LOG.debug("Reading the file back using a reader...");    SortedKeyValueFile.Reader.Options readerOptions = new SortedKeyValueFile.Reader.Options().withKeySchema(Schema.create(Schema.Type.STRING)).withValueSchema(Schema.create(Schema.Type.STRING)).withConfiguration(conf).withPath(new Path(mTempDir.getRoot().getPath(), "myfile"));    try (SortedKeyValueFile.Reader<CharSequence, CharSequence> reader = new SortedKeyValueFile.Reader<>(readerOptions)) {        assertEquals("Carrot", reader.get("carrot").toString());        assertEquals("Banana", reader.get("banana").toString());        assertNull(reader.get("a-vegetable"));        assertNull(reader.get("beet"));        assertNull(reader.get("zzz"));    }}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return s;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return s.hashCode();}
6b3ab298cb5d88dbb2c510c786f53e377489a40e2716e63c26a3e1691765f6c5
equals
public boolean equals(Object that)
{    return this.s.equals(that.toString());}
7362ecff340417b71db55dac1acac895c4dc2e96e8ea9c4834cea4c64594c23a
compareTo
public int compareTo(Stringy that)
{    return this.s.compareTo(that.s);}
8212d7af7d2ea0d716bf989f4f9f21be7f872d99694374301fc5531826094bce
testAlternateModel
public void testAlternateModel() throws Exception
{    LOG.debug("Writing some reflect records...");    ReflectData model = ReflectData.get();    Configuration conf = new Configuration();    SortedKeyValueFile.Writer.Options options = new SortedKeyValueFile.Writer.Options().withKeySchema(model.getSchema(Stringy.class)).withValueSchema(model.getSchema(Stringy.class)).withConfiguration(conf).withPath(new Path(mTempDir.getRoot().getPath(), "reflect")).withDataModel(model).withIndexInterval(2);    try (SortedKeyValueFile.Writer<Stringy, Stringy> writer = new SortedKeyValueFile.Writer<>(options)) {        writer.append(new Stringy("apple"), new Stringy("Apple"));        writer.append(new Stringy("banana"), new Stringy("Banana"));        writer.append(new Stringy("carrot"), new Stringy("Carrot"));        writer.append(new Stringy("durian"), new Stringy("Durian"));    }    LOG.debug("Reading the file back using a reader...");    SortedKeyValueFile.Reader.Options readerOptions = new SortedKeyValueFile.Reader.Options().withKeySchema(model.getSchema(Stringy.class)).withValueSchema(model.getSchema(Stringy.class)).withConfiguration(conf).withPath(new Path(mTempDir.getRoot().getPath(), "reflect")).withDataModel(model);    try (SortedKeyValueFile.Reader<Stringy, Stringy> reader = new SortedKeyValueFile.Reader<>(readerOptions)) {        assertEquals(new Stringy("Carrot"), reader.get(new Stringy("carrot")));        assertEquals(new Stringy("Banana"), reader.get(new Stringy("banana")));        assertNull(reader.get(new Stringy("a-vegetable")));        assertNull(reader.get(new Stringy("beet")));        assertNull(reader.get(new Stringy("zzz")));    }}
935d9dc08fe11323dcaaf5c6f96db76bb87fd0fc4b9fcc33e9eca9f620f5620c
setup
public void setup() throws IOException
{    mJob = Job.getInstance();    mFactory = new AvroDatumConverterFactory(mJob.getConfiguration());}
73831536bf01f012a371b965a2c41c0f668ffd33d2baf0f235e9e3accd1bfb73
testConvertAvroKey
public void testConvertAvroKey() throws IOException
{    AvroJob.setOutputKeySchema(mJob, Schema.create(Schema.Type.STRING));    AvroKey<CharSequence> avroKey = new AvroKey<>("foo");    @SuppressWarnings("unchecked")    AvroDatumConverter<AvroKey<CharSequence>, ?> converter = mFactory.create((Class<AvroKey<CharSequence>>) avroKey.getClass());    assertEquals("foo", converter.convert(avroKey).toString());}
4a47511dcafacb7ebe73eaaedcb15a3ee26f1c2e37b074ca433998efaa6b6436
testConvertAvroValue
public void testConvertAvroValue() throws IOException
{    AvroJob.setOutputValueSchema(mJob, Schema.create(Schema.Type.INT));    AvroValue<Integer> avroValue = new AvroValue<>(42);    @SuppressWarnings("unchecked")    AvroDatumConverter<AvroValue<Integer>, Integer> converter = mFactory.create((Class<AvroValue<Integer>>) avroValue.getClass());    assertEquals(42, converter.convert(avroValue).intValue());}
4128397b3f1565674884aa33d885edb3af2dcd53e4eaee2b476740c1bd2586bb
testConvertBooleanWritable
public void testConvertBooleanWritable()
{    AvroDatumConverter<BooleanWritable, Boolean> converter = mFactory.create(BooleanWritable.class);    assertEquals(true, converter.convert(new BooleanWritable(true)));}
6454bd82968c71f3ed5cd154b5911375a8e9f0bda237f64e2ee56bd8c5329ea9
testConvertBytesWritable
public void testConvertBytesWritable()
{    AvroDatumConverter<BytesWritable, ByteBuffer> converter = mFactory.create(BytesWritable.class);    ByteBuffer bytes = converter.convert(new BytesWritable(new byte[] { 1, 2, 3 }));    assertEquals(1, bytes.get(0));    assertEquals(2, bytes.get(1));    assertEquals(3, bytes.get(2));}
4e65553a73aa5e15e6889a3120d0be892118222d19599bc7f0e1e9110237a907
testConvertByteWritable
public void testConvertByteWritable()
{    AvroDatumConverter<ByteWritable, GenericFixed> converter = mFactory.create(ByteWritable.class);    assertEquals(42, converter.convert(new ByteWritable((byte) 42)).bytes()[0]);}
846ba7c35c897a72bd12befc3cd325fb46efe99f37f9cc7fa696c331dde69f4e
testConvertDoubleWritable
public void testConvertDoubleWritable()
{    AvroDatumConverter<DoubleWritable, Double> converter = mFactory.create(DoubleWritable.class);    assertEquals(2.0, converter.convert(new DoubleWritable(2.0)), 0.00001);}
f8217f287d4a23fac54a8640975d5a32a47b78918e5abc05c9b931e928b584aa
testConvertFloatWritable
public void testConvertFloatWritable()
{    AvroDatumConverter<FloatWritable, Float> converter = mFactory.create(FloatWritable.class);    assertEquals(2.2f, converter.convert(new FloatWritable(2.2f)), 0.00001);}
747f4f8b2205e4960a2e14d750661a989b6a96f8457afaf9a9697c8a6b0c32d6
testConvertIntWritable
public void testConvertIntWritable()
{    AvroDatumConverter<IntWritable, Integer> converter = mFactory.create(IntWritable.class);    assertEquals(2, converter.convert(new IntWritable(2)).intValue());}
fc642dd007d685ffd2e3755a249f67667d2a04c1f943e77fbb4aeaef7f2111e1
testConvertLongWritable
public void testConvertLongWritable()
{    AvroDatumConverter<LongWritable, Long> converter = mFactory.create(LongWritable.class);    assertEquals(123L, converter.convert(new LongWritable(123L)).longValue());}
17381b31724952d489ddbe3bb929aedd5110203d7354260011c2fbefec268c95
testConvertNullWritable
public void testConvertNullWritable()
{    AvroDatumConverter<NullWritable, Object> converter = mFactory.create(NullWritable.class);    assertNull(converter.convert(NullWritable.get()));}
0179897151bd349d39e5e9e1d6f886a080a590196657e9d205e7d188edbe2cbc
testConvertText
public void testConvertText()
{    AvroDatumConverter<Text, CharSequence> converter = mFactory.create(Text.class);    assertEquals("foo", converter.convert(new Text("foo")).toString());}
a0942ea29978fd5ea002d1f0c5bf3adde3c6076543883b3a944e6bfb67563652
testDeserialize
public void testDeserialize() throws IOException
{        Schema writerSchema = Schema.create(Schema.Type.STRING);    Schema readerSchema = Schema.create(Schema.Type.STRING);    ClassLoader classLoader = this.getClass().getClassLoader();    AvroKeyDeserializer<CharSequence> deserializer = new AvroKeyDeserializer<>(writerSchema, readerSchema, classLoader);        assertEquals(writerSchema, deserializer.getWriterSchema());    assertEquals(readerSchema, deserializer.getReaderSchema());        DatumWriter<CharSequence> datumWriter = new GenericDatumWriter<>(writerSchema);    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();    Encoder encoder = EncoderFactory.get().binaryEncoder(outputStream, null);    datumWriter.write("record1", encoder);    datumWriter.write("record2", encoder);    encoder.flush();        ByteArrayInputStream inputStream = new ByteArrayInputStream(outputStream.toByteArray());    deserializer.open(inputStream);    AvroWrapper<CharSequence> record = null;    record = deserializer.deserialize(record);    assertEquals("record1", record.datum().toString());    record = deserializer.deserialize(record);    assertEquals("record2", record.datum().toString());    deserializer.close();}
20b08990cb9f39ea91b6e3ba0fb4e2917998f0537eced023ac13b04c52881632
testReadAvro
public void testReadAvro() throws IOException
{    Path sequenceFilePath = new Path(new File(mTempDir.getRoot(), "output.seq").getPath());    writeSequenceFile(sequenceFilePath, AvroKey.class, AvroValue.class, Schema.create(Schema.Type.STRING), Schema.create(Schema.Type.INT), new AvroKey<CharSequence>("one"), new AvroValue<>(1), new AvroKey<CharSequence>("two"), new AvroValue<>(2));    Configuration conf = new Configuration();    FileSystem fs = FileSystem.get(conf);    AvroSequenceFile.Reader.Options options = new AvroSequenceFile.Reader.Options().withFileSystem(fs).withInputPath(sequenceFilePath).withKeySchema(Schema.create(Schema.Type.STRING)).withValueSchema(Schema.create(Schema.Type.INT)).withConfiguration(conf);    SequenceFile.Reader reader = new AvroSequenceFile.Reader(options);    AvroKey<CharSequence> key = new AvroKey<>();    AvroValue<Integer> value = new AvroValue<>();        key = (AvroKey<CharSequence>) reader.next(key);    assertNotNull(key);    assertEquals("one", key.datum().toString());    value = (AvroValue<Integer>) reader.getCurrentValue(value);    assertNotNull(value);    assertEquals(1, value.datum().intValue());        key = (AvroKey<CharSequence>) reader.next(key);    assertNotNull(key);    assertEquals("two", key.datum().toString());    value = (AvroValue<Integer>) reader.getCurrentValue(value);    assertNotNull(value);    assertEquals(2, value.datum().intValue());    assertNull("Should be no more records.", reader.next(key));}
7bd4db28a7325a194a21728d6bddf5b444b00d330860c66d461df9f34c39abf6
testReadAvroWithoutReaderSchemas
public void testReadAvroWithoutReaderSchemas() throws IOException
{    Path sequenceFilePath = new Path(new File(mTempDir.getRoot(), "output.seq").getPath());    writeSequenceFile(sequenceFilePath, AvroKey.class, AvroValue.class, Schema.create(Schema.Type.STRING), Schema.create(Schema.Type.INT), new AvroKey<CharSequence>("one"), new AvroValue<>(1), new AvroKey<CharSequence>("two"), new AvroValue<>(2));    Configuration conf = new Configuration();    FileSystem fs = FileSystem.get(conf);    AvroSequenceFile.Reader.Options options = new AvroSequenceFile.Reader.Options().withFileSystem(fs).withInputPath(sequenceFilePath).withConfiguration(conf);    SequenceFile.Reader reader = new AvroSequenceFile.Reader(options);    AvroKey<CharSequence> key = new AvroKey<>();    AvroValue<Integer> value = new AvroValue<>();        key = (AvroKey<CharSequence>) reader.next(key);    assertNotNull(key);    assertEquals("one", key.datum().toString());    value = (AvroValue<Integer>) reader.getCurrentValue(value);    assertNotNull(value);    assertEquals(1, value.datum().intValue());        key = (AvroKey<CharSequence>) reader.next(key);    assertNotNull(key);    assertEquals("two", key.datum().toString());    value = (AvroValue<Integer>) reader.getCurrentValue(value);    assertNotNull(value);    assertEquals(2, value.datum().intValue());    assertNull("Should be no more records.", reader.next(key));}
1d4df2f10b3cb0cd0f304f65d86e61b516183d930fe53f1e951f57f686073f03
testReadWritables
public void testReadWritables() throws IOException
{    Path sequenceFilePath = new Path(new File(mTempDir.getRoot(), "output.seq").getPath());    writeSequenceFile(sequenceFilePath, Text.class, IntWritable.class, null, null, new Text("one"), new IntWritable(1), new Text("two"), new IntWritable(2));    Configuration conf = new Configuration();    FileSystem fs = FileSystem.get(conf);    AvroSequenceFile.Reader.Options options = new AvroSequenceFile.Reader.Options().withFileSystem(fs).withInputPath(sequenceFilePath).withConfiguration(conf);    SequenceFile.Reader reader = new AvroSequenceFile.Reader(options);    Text key = new Text();    IntWritable value = new IntWritable();        assertTrue(reader.next(key));    assertEquals("one", key.toString());    reader.getCurrentValue(value);    assertNotNull(value);    assertEquals(1, value.get());        assertTrue(reader.next(key));    assertEquals("two", key.toString());    reader.getCurrentValue(value);    assertNotNull(value);    assertEquals(2, value.get());    assertFalse("Should be no more records.", reader.next(key));}
3b88bd11cac456a66d36ce876adba30493792cd500051e96288c3f22a776e473
writeSequenceFile
private void writeSequenceFile(Path file, Class<?> keyClass, Class<?> valueClass, Schema keySchema, Schema valueSchema, Object... records) throws IOException
{        if (0 != records.length % 2) {        throw new IllegalArgumentException("Expected a value for each key record.");    }        Configuration conf = new Configuration();    FileSystem fs = FileSystem.get(conf);    AvroSequenceFile.Writer.Options options = new AvroSequenceFile.Writer.Options().withFileSystem(fs).withConfiguration(conf).withOutputPath(file);    if (null != keySchema) {        options.withKeySchema(keySchema);    } else {        options.withKeyClass(keyClass);    }    if (null != valueSchema) {        options.withValueSchema(valueSchema);    } else {        options.withValueClass(valueClass);    }    SequenceFile.Writer writer = new AvroSequenceFile.Writer(options);        for (int i = 0; i < records.length; i += 2) {        writer.append(records[i], records[i + 1]);    }        writer.close();}
6355858536d6fa404d3c0991420b1307e0aed4e66eed25094f9376b27e9a59b1
testAccept
public void testAccept()
{    AvroSerialization<CharSequence> serialization = new AvroSerialization<>();    assertTrue(serialization.accept(AvroKey.class));    assertTrue(serialization.accept(AvroValue.class));    assertFalse(serialization.accept(AvroWrapper.class));    assertFalse(serialization.accept(String.class));}
a1cf941a1ec9897d517eb956be83c55ca8257039a595b397d317a86ab98986e8
testGetSerializerForKey
public void testGetSerializerForKey() throws IOException
{        Schema writerSchema = Schema.create(Schema.Type.STRING);    Job job = Job.getInstance();    AvroJob.setMapOutputKeySchema(job, writerSchema);        AvroSerialization serialization = ReflectionUtils.newInstance(AvroSerialization.class, job.getConfiguration());    @SuppressWarnings("unchecked")    Serializer<AvroWrapper> serializer = serialization.getSerializer(AvroKey.class);    assertTrue(serializer instanceof AvroSerializer);    AvroSerializer avroSerializer = (AvroSerializer) serializer;        assertEquals(writerSchema, avroSerializer.getWriterSchema());}
b1c6f1e2b429be266aa230e48dd347edc283592c7048f83e506efa21bb4357ea
testGetSerializerForValue
public void testGetSerializerForValue() throws IOException
{        Schema writerSchema = Schema.create(Schema.Type.STRING);    Job job = Job.getInstance();    AvroJob.setMapOutputValueSchema(job, writerSchema);        AvroSerialization serialization = ReflectionUtils.newInstance(AvroSerialization.class, job.getConfiguration());    @SuppressWarnings("unchecked")    Serializer<AvroWrapper> serializer = serialization.getSerializer(AvroValue.class);    assertTrue(serializer instanceof AvroSerializer);    AvroSerializer avroSerializer = (AvroSerializer) serializer;        assertEquals(writerSchema, avroSerializer.getWriterSchema());}
7a40a0f29006356b5033f00ade91b0005ee45011538b483e09b453b86b6ceb77
testGetDeserializerForKey
public void testGetDeserializerForKey() throws IOException
{        Schema readerSchema = Schema.create(Schema.Type.STRING);    Job job = Job.getInstance();    AvroJob.setMapOutputKeySchema(job, readerSchema);        AvroSerialization serialization = ReflectionUtils.newInstance(AvroSerialization.class, job.getConfiguration());    @SuppressWarnings("unchecked")    Deserializer<AvroWrapper> deserializer = serialization.getDeserializer(AvroKey.class);    assertTrue(deserializer instanceof AvroKeyDeserializer);    AvroKeyDeserializer avroDeserializer = (AvroKeyDeserializer) deserializer;        assertEquals(readerSchema, avroDeserializer.getReaderSchema());}
ead6b21a70afd3db75b8b7d831254f6d3aca13b53660a96780b4d57b074b7ba6
testGetDeserializerForValue
public void testGetDeserializerForValue() throws IOException
{        Schema readerSchema = Schema.create(Schema.Type.STRING);    Job job = Job.getInstance();    AvroJob.setMapOutputValueSchema(job, readerSchema);        AvroSerialization serialization = ReflectionUtils.newInstance(AvroSerialization.class, job.getConfiguration());    @SuppressWarnings("unchecked")    Deserializer<AvroWrapper> deserializer = serialization.getDeserializer(AvroValue.class);    assertTrue(deserializer instanceof AvroValueDeserializer);    AvroValueDeserializer avroDeserializer = (AvroValueDeserializer) deserializer;        assertEquals(readerSchema, avroDeserializer.getReaderSchema());}
09e0c89f41a134279b4f6cfcccd906135b9e452e214284818cd8907467a01634
testClassPath
public void testClassPath() throws Exception
{    Configuration conf = new Configuration();    ClassLoader loader = conf.getClass().getClassLoader();    AvroSerialization serialization = new AvroSerialization();    serialization.setConf(conf);    AvroDeserializer des = (AvroDeserializer) serialization.getDeserializer(AvroKey.class);    ReflectData data = (ReflectData) ((ReflectDatumReader) des.mAvroDatumReader).getData();    Assert.assertEquals(loader, data.getClassLoader());}
a41d94420827509443b54e4e62d7f7f592b42ca973b9f9c33de6bf1da21a079c
roundTrip
private O roundTrip(Schema schema, T data, Class<? extends GenericData> modelClass) throws IOException
{    Job job = Job.getInstance();    AvroJob.setMapOutputKeySchema(job, schema);    if (modelClass != null)        AvroJob.setDataModelClass(job, modelClass);    AvroSerialization serialization = ReflectionUtils.newInstance(AvroSerialization.class, job.getConfiguration());    Serializer<AvroKey<T>> serializer = serialization.getSerializer(AvroKey.class);    Deserializer<AvroKey<O>> deserializer = serialization.getDeserializer(AvroKey.class);    ByteArrayOutputStream baos = new ByteArrayOutputStream();    serializer.open(baos);    serializer.serialize(new AvroKey<>(data));    serializer.close();    ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());    deserializer.open(bais);    AvroKey<O> result = null;    result = deserializer.deserialize(result);    deserializer.close();    return result.datum();}
175ca2a6df96dc2306a34b227ceecd2fcb6d585f5455132898d34515f7fd6e2c
testRoundTrip
public void testRoundTrip() throws Exception
{    Schema schema = Schema.create(Schema.Type.STRING);    assertTrue(roundTrip(schema, "record", null) instanceof String);    assertTrue(roundTrip(schema, "record", GenericData.class) instanceof Utf8);}
37c6f1940d050b8c3cac4c3468fdf6cb7b9a90c60eff46ed2a50d005df58cfbc
testSerialize
public void testSerialize() throws IOException
{        Schema writerSchema = Schema.create(Schema.Type.STRING);    AvroSerializer<CharSequence> serializer = new AvroSerializer<>(writerSchema);        assertEquals(writerSchema, serializer.getWriterSchema());        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();    serializer.open(outputStream);    serializer.serialize(new AvroKey<>("record1"));    serializer.serialize(new AvroKey<>("record2"));    serializer.close();        ByteArrayInputStream inputStream = new ByteArrayInputStream(outputStream.toByteArray());    Schema readerSchema = Schema.create(Schema.Type.STRING);    DatumReader<CharSequence> datumReader = new GenericDatumReader<>(readerSchema);    Decoder decoder = DecoderFactory.get().binaryDecoder(inputStream, null);    CharSequence record = null;    record = datumReader.read(record, decoder);    assertEquals("record1", record.toString());    record = datumReader.read(record, decoder);    assertEquals("record2", record.toString());    inputStream.close();}
a0942ea29978fd5ea002d1f0c5bf3adde3c6076543883b3a944e6bfb67563652
testDeserialize
public void testDeserialize() throws IOException
{        Schema writerSchema = Schema.create(Schema.Type.STRING);    Schema readerSchema = Schema.create(Schema.Type.STRING);    ClassLoader classLoader = this.getClass().getClassLoader();    AvroValueDeserializer<CharSequence> deserializer = new AvroValueDeserializer<>(writerSchema, readerSchema, classLoader);        assertEquals(writerSchema, deserializer.getWriterSchema());    assertEquals(readerSchema, deserializer.getReaderSchema());        DatumWriter<CharSequence> datumWriter = new GenericDatumWriter<>(writerSchema);    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();    Encoder encoder = EncoderFactory.get().binaryEncoder(outputStream, null);    datumWriter.write("record1", encoder);    datumWriter.write("record2", encoder);    encoder.flush();        ByteArrayInputStream inputStream = new ByteArrayInputStream(outputStream.toByteArray());    deserializer.open(inputStream);    AvroWrapper<CharSequence> record = null;    record = deserializer.deserialize(record);    assertEquals("record1", record.datum().toString());    record = deserializer.deserialize(record);    assertEquals("record2", record.datum().toString());    deserializer.close();}
5ff0b8f7d2b080bcc6214fa5f91be74727145ea81cacb63a99c8d0f3106c089f
setup
public void setup()
{    mComparator = new AvroCharSequenceComparator<>();}
8ed1b3bf837546d47aa23e3065660bde2d02a7d70227c6b702cb2151356f1d25
testCompareString
public void testCompareString()
{    assertEquals(0, mComparator.compare("", ""));    assertThat(mComparator.compare("", "a"), lessThan(0));    assertThat(mComparator.compare("a", ""), greaterThan(0));    assertEquals(0, mComparator.compare("a", "a"));    assertThat(mComparator.compare("a", "b"), lessThan(0));    assertThat(mComparator.compare("b", "a"), greaterThan(0));    assertEquals(0, mComparator.compare("ab", "ab"));    assertThat(mComparator.compare("a", "aa"), lessThan(0));    assertThat(mComparator.compare("aa", "a"), greaterThan(0));    assertThat(mComparator.compare("abc", "abcdef"), lessThan(0));    assertThat(mComparator.compare("abcdef", "abc"), greaterThan(0));}
a3f99e3dff5f0fc8e2af4e9b2f3248c49db62463c34ee644d29a98ca4a443ab6
testCompareUtf8
public void testCompareUtf8()
{    assertEquals(0, mComparator.compare(new Utf8(""), new Utf8("")));    assertThat(mComparator.compare(new Utf8(""), new Utf8("a")), lessThan(0));    assertThat(mComparator.compare(new Utf8("a"), new Utf8("")), greaterThan(0));    assertEquals(0, mComparator.compare(new Utf8("a"), new Utf8("a")));    assertThat(mComparator.compare(new Utf8("a"), new Utf8("b")), lessThan(0));    assertThat(mComparator.compare(new Utf8("b"), new Utf8("a")), greaterThan(0));    assertEquals(0, mComparator.compare(new Utf8("ab"), new Utf8("ab")));    assertThat(mComparator.compare(new Utf8("a"), new Utf8("aa")), lessThan(0));    assertThat(mComparator.compare(new Utf8("aa"), new Utf8("a")), greaterThan(0));    assertThat(mComparator.compare(new Utf8("abc"), new Utf8("abcdef")), lessThan(0));    assertThat(mComparator.compare(new Utf8("abcdef"), new Utf8("abc")), greaterThan(0));}
54ff785db55914f7602c09a8dfdb0404468aa2499e7eeb49d15cd926f3b6e26e
testCompareUtf8ToString
public void testCompareUtf8ToString()
{    assertEquals(0, mComparator.compare(new Utf8(""), ""));    assertThat(mComparator.compare(new Utf8(""), "a"), lessThan(0));    assertThat(mComparator.compare(new Utf8("a"), ""), greaterThan(0));    assertEquals(0, mComparator.compare(new Utf8("a"), "a"));    assertThat(mComparator.compare(new Utf8("a"), "b"), lessThan(0));    assertThat(mComparator.compare(new Utf8("b"), "a"), greaterThan(0));    assertEquals(0, mComparator.compare(new Utf8("ab"), "ab"));    assertThat(mComparator.compare(new Utf8("a"), "aa"), lessThan(0));    assertThat(mComparator.compare(new Utf8("aa"), "a"), greaterThan(0));    assertThat(mComparator.compare(new Utf8("abc"), "abcdef"), lessThan(0));    assertThat(mComparator.compare(new Utf8("abcdef"), "abc"), greaterThan(0));}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    conf = new JobConf();    fs = FileSystem.getLocal(conf);    inputDir = new Path(DIR.getRoot().getPath());}
c6aaebb5a52567751db8dc8e1cb9dd4a4e582ef964a374b376c6a04f741802dc
tearDown
public void tearDown() throws Exception
{    fs.delete(inputDir, true);}
973ab4aa5b97cc841cf1f4f7184d29f2814ba83f9cfb8d2712c54273269f04b2
testIgnoreFilesWithoutExtension
public void testIgnoreFilesWithoutExtension() throws Exception
{    fs.mkdirs(inputDir);    Path avroFile = new Path(inputDir, "somefile.avro");    Path textFile = new Path(inputDir, "someotherfile.txt");    fs.create(avroFile).close();    fs.create(textFile).close();    FileInputFormat.setInputPaths(conf, inputDir);    AvroInputFormat inputFormat = new AvroInputFormat();    FileStatus[] statuses = inputFormat.listStatus(conf);    assertEquals(1, statuses.length);    assertEquals("somefile.avro", statuses[0].getPath().getName());    conf.setBoolean(AvroInputFormat.IGNORE_FILES_WITHOUT_EXTENSION_KEY, false);    statuses = inputFormat.listStatus(conf);    assertEquals(2, statuses.length);    Set<String> names = new HashSet<>();    names.add(statuses[0].getPath().getName());    names.add(statuses[1].getPath().getName());    assertTrue(names.contains("somefile.avro"));    assertTrue(names.contains("someotherfile.txt"));}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return id + "\t" + name;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return id + "\t" + balance;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return ((Integer) id).toString();}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return recType.toString();}
130cb36e953124d29c10b229b2a4b71ed15ea6317b13d47d06a9e8722fcabb2a
setId
 void setId(int id)
{    this.id = id;}
8fa9cd2bcbdd75ee4d9b952b9880e46d1eec94e2dc3da303881f651d2446ee4b
setName
 void setName(CharSequence name)
{    this.name = name;}
5ea30542acb63b1b6a7a546f7dfe0e46ccc2f977116f67f723db552481cafb5d
setBalance
 void setBalance(long balance)
{    this.balance = balance;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return id + "\t" + name + "\t" + balance;}
812fc1b285d67c832c6f6756fe1402c3ff590c2617eccc64dfd70adebeff9276
map
public void map(NamesRecord nameRecord, AvroCollector<Pair<KeyRecord, JoinableRecord>> collector, Reporter reporter) throws IOException
{    collector.collect(new Pair<>(new KeyRecord(nameRecord.id), new JoinableRecord(nameRecord.getClass().getName(), nameRecord.id, nameRecord.name, -1L)));}
4a88214951ef137af6e4bacc9af0c35d90987ba74ff88b784fdbc91d9c9df3dc
map
public void map(BalancesRecord balanceRecord, AvroCollector<Pair<KeyRecord, JoinableRecord>> collector, Reporter reporter) throws IOException
{    collector.collect(new Pair<>(new KeyRecord(balanceRecord.id), new JoinableRecord(balanceRecord.getClass().getName(), balanceRecord.id, "", balanceRecord.balance)));}
864b85a0c0c5a635bdb8bec01892c70ceb47f90fafb139d59b9f3ccad19c31fc
reduce
public void reduce(KeyRecord ID, Iterable<JoinableRecord> joinables, AvroCollector<CompleteRecord> collector, Reporter reporter) throws IOException
{    CompleteRecord rec = new CompleteRecord();    for (JoinableRecord joinable : joinables) {        rec.setId(joinable.id);        if (joinable.recType.toString().contains("NamesRecord")) {            rec.setName(joinable.name);        } else {            rec.setBalance(joinable.balance);        }    }    collector.collect(rec);}
496a9c32181bc4736f27d74828c12dc4fc5605369f1c04984c214a97d38f2167
testJob
public void testJob() throws Exception
{    JobConf job = new JobConf();    Path inputPath1 = new Path(INPUT_DIR_1.getRoot().getPath());    Path inputPath2 = new Path(INPUT_DIR_2.getRoot().getPath());    Path outputPath = new Path(OUTPUT_DIR.getRoot().getPath());    outputPath.getFileSystem(job).delete(outputPath, true);    writeNamesFiles(new File(inputPath1.toUri().getPath()));    writeBalancesFiles(new File(inputPath2.toUri().getPath()));    job.setJobName("multiple-inputs-join");    AvroMultipleInputs.addInputPath(job, inputPath1, NamesMapImpl.class, ReflectData.get().getSchema(NamesRecord.class));    AvroMultipleInputs.addInputPath(job, inputPath2, BalancesMapImpl.class, ReflectData.get().getSchema(BalancesRecord.class));    Schema keySchema = ReflectData.get().getSchema(KeyRecord.class);    Schema valueSchema = ReflectData.get().getSchema(JoinableRecord.class);    AvroJob.setMapOutputSchema(job, Pair.getPairSchema(keySchema, valueSchema));    AvroJob.setOutputSchema(job, ReflectData.get().getSchema(CompleteRecord.class));    AvroJob.setReducerClass(job, ReduceImpl.class);    job.setNumReduceTasks(1);    FileOutputFormat.setOutputPath(job, outputPath);    AvroJob.setReflect(job);    JobClient.runJob(job);    validateCompleteFile(new File(OUTPUT_DIR.getRoot(), "part-00000.avro"));}
5ff672c3f253ebba930fe5e196517f94e77c34f60f03e296b9914b144bd53691
writeNamesFiles
private void writeNamesFiles(File dir) throws IOException
{    DatumWriter<NamesRecord> writer = new ReflectDatumWriter<>();    File namesFile = new File(dir + "/names.avro");    try (DataFileWriter<NamesRecord> out = new DataFileWriter<>(writer)) {        out.create(ReflectData.get().getSchema(NamesRecord.class), namesFile);        for (int i = 0; i < 5; i++) {            out.append(new NamesRecord(i, "record" + i));        }    }}
a27d7d5f42fc8809eea796615784e9a407486c9c2d7724f2d2f02a140932bda9
writeBalancesFiles
private void writeBalancesFiles(File dir) throws IOException
{    DatumWriter<BalancesRecord> writer = new ReflectDatumWriter<>();    File namesFile = new File(dir + "/balances.avro");    try (DataFileWriter<BalancesRecord> out = new DataFileWriter<>(writer)) {        out.create(ReflectData.get().getSchema(BalancesRecord.class), namesFile);        for (int i = 0; i < 5; i++) {            out.append(new BalancesRecord(i, (long) i + 100));        }    }}
04f67e1a6c924615854401f4684dc345238555d7c0547ad71b0c61a83c364501
validateCompleteFile
private void validateCompleteFile(File file) throws Exception
{    DatumReader<CompleteRecord> reader = new ReflectDatumReader<>();    int numRecs = 0;    try (InputStream in = new BufferedInputStream(new FileInputStream(file))) {        try (DataFileStream<CompleteRecord> records = new DataFileStream<>(in, reader)) {            for (CompleteRecord rec : records) {                assertEquals(rec.id, numRecs);                assertEquals(rec.balance - 100, rec.id);                assertEquals(rec.name, "record" + rec.id);                numRecs++;            }        }    }    assertEquals(5, numRecs);}
785677cfbe90359b6dce9202287a467b84f33f3d271d21bc5043e63d07e1949f
configure
public void configure(JobConf Job)
{    this.amos = new AvroMultipleOutputs(Job);}
a5adba50a8f38754ea35f11bbb42ae8844c78d2e3f7886affca652feebb3caa4
map
public void map(Utf8 text, AvroCollector<Pair<Utf8, Long>> collector, Reporter reporter) throws IOException
{    StringTokenizer tokens = new StringTokenizer(text.toString());    while (tokens.hasMoreTokens()) {        String tok = tokens.nextToken();        collector.collect(new Pair<>(new Utf8(tok), 1L));        amos.getCollector("myavro2", reporter).collect(new Pair<Utf8, Long>(new Utf8(tok), 1L).toString());    }}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    amos.close();}
785677cfbe90359b6dce9202287a467b84f33f3d271d21bc5043e63d07e1949f
configure
public void configure(JobConf Job)
{    amos = new AvroMultipleOutputs(Job);}
9d0ca6f930b62727af05bf24bc37f7d0d1e37c2a83df3b596d6d2ff412f198e1
reduce
public void reduce(Utf8 word, Iterable<Long> counts, AvroCollector<Pair<Utf8, Long>> collector, Reporter reporter) throws IOException
{    long sum = 0;    for (long count : counts) sum += count;    Pair<Utf8, Long> outputvalue = new Pair<>(word, sum);    amos.getCollector("myavro", reporter).collect(outputvalue);    amos.collect("myavro1", reporter, outputvalue.toString());    amos.collect("myavro", reporter, new Pair<Utf8, Long>(new Utf8(""), 0L).getSchema(), outputvalue, "testavrofile");    amos.collect("myavro", reporter, Schema.create(Schema.Type.STRING), outputvalue.toString(), "testavrofile1");    collector.collect(new Pair<>(word, sum));}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    amos.close();}
3e79f00488eb1e51412af24aff162ecb29c178f612062ebc2a2ed74b5fa0ac77
runTestsInOrder
public void runTestsInOrder() throws Exception
{    String avroPath = OUTPUT_DIR.getRoot().getPath();    testJob(avroPath);    testProjection(avroPath);    testProjectionNewMethodsOne(avroPath);    testProjectionNewMethodsTwo(avroPath);    testProjection1(avroPath);    testJobNoreducer();    testProjectionNoreducer(avroPath);}
4ee70adae6c2919664c68c56df1ef849b386e7749f8392c1123d5b963c933d20
testJob
public void testJob(String pathOut) throws Exception
{    JobConf job = new JobConf();    String pathIn = INPUT_DIR.getRoot().getPath();    File fileIn = new File(pathIn, "lines.avro");    Path outputPath = new Path(pathOut);    outputPath.getFileSystem(job).delete(outputPath);    WordCountUtil.writeLinesFile(fileIn);    job.setJobName("AvroMultipleOutputs");    AvroJob.setInputSchema(job, Schema.create(Schema.Type.STRING));    AvroJob.setOutputSchema(job, new Pair<Utf8, Long>(new Utf8(""), 0L).getSchema());    AvroJob.setMapperClass(job, MapImpl.class);    AvroJob.setReducerClass(job, ReduceImpl.class);    FileInputFormat.setInputPaths(job, pathIn);    FileOutputFormat.setOutputPath(job, outputPath);    FileOutputFormat.setCompressOutput(job, false);    AvroMultipleOutputs.addNamedOutput(job, "myavro", AvroOutputFormat.class, new Pair<Utf8, Long>(new Utf8(""), 0L).getSchema());    AvroMultipleOutputs.addNamedOutput(job, "myavro1", AvroOutputFormat.class, Schema.create(Schema.Type.STRING));    AvroMultipleOutputs.addNamedOutput(job, "myavro2", AvroOutputFormat.class, Schema.create(Schema.Type.STRING));    WordCountUtil.setMeta(job);    JobClient.runJob(job);    WordCountUtil.validateCountsFile(new File(outputPath.toString(), "/part-00000.avro"));}
8457c962b1a75c95eed3c68322a1fe9252c70c7d31e9ad6997a8320306fd2382
testProjection
public void testProjection(String inputDirectory) throws Exception
{    JobConf job = new JobConf();    Integer defaultRank = -1;    String jsonSchema = "{\"type\":\"record\"," + "\"name\":\"org.apache.avro.mapred.Pair\"," + "\"fields\": [ " + "{\"name\":\"rank\", \"type\":\"int\", \"default\": -1}," + "{\"name\":\"value\", \"type\":\"long\"}" + "]}";    Schema readerSchema = Schema.parse(jsonSchema);    AvroJob.setInputSchema(job, readerSchema);    Path inputPath = new Path(inputDirectory + "/myavro-r-00000.avro");    FileStatus fileStatus = FileSystem.get(job).getFileStatus(inputPath);    FileSplit fileSplit = new FileSplit(inputPath, 0, fileStatus.getLen(), job);    AvroRecordReader<Pair<Integer, Long>> recordReader = new AvroRecordReader<>(job, fileSplit);    AvroWrapper<Pair<Integer, Long>> inputPair = new AvroWrapper<>(null);    NullWritable ignore = NullWritable.get();    long sumOfCounts = 0;    long numOfCounts = 0;    while (recordReader.next(inputPair, ignore)) {        Assert.assertEquals(inputPair.datum().get(0), defaultRank);        sumOfCounts += (Long) inputPair.datum().get(1);        numOfCounts++;    }    Assert.assertEquals(numOfCounts, WordCountUtil.COUNTS.size());    long actualSumOfCounts = 0;    for (Long count : WordCountUtil.COUNTS.values()) {        actualSumOfCounts += count;    }    Assert.assertEquals(sumOfCounts, actualSumOfCounts);}
d4ccf9b0c0784ab7457be056b9e4175bfc22ee589059db739666a0de14aa5c1a
testProjectionNewMethodsOne
public void testProjectionNewMethodsOne(String inputDirectory) throws Exception
{    JobConf job = new JobConf();    Integer defaultRank = -1;    String jsonSchema = "{\"type\":\"record\"," + "\"name\":\"org.apache.avro.mapred.Pair\"," + "\"fields\": [ " + "{\"name\":\"rank\", \"type\":\"int\", \"default\": -1}," + "{\"name\":\"value\", \"type\":\"long\"}" + "]}";    Schema readerSchema = Schema.parse(jsonSchema);    AvroJob.setInputSchema(job, readerSchema);    Path inputPath = new Path(inputDirectory + "/testavrofile-r-00000.avro");    FileStatus fileStatus = FileSystem.get(job).getFileStatus(inputPath);    FileSplit fileSplit = new FileSplit(inputPath, 0, fileStatus.getLen(), job);    AvroRecordReader<Pair<Integer, Long>> recordReader = new AvroRecordReader<>(job, fileSplit);    AvroWrapper<Pair<Integer, Long>> inputPair = new AvroWrapper<>(null);    NullWritable ignore = NullWritable.get();    long sumOfCounts = 0;    long numOfCounts = 0;    while (recordReader.next(inputPair, ignore)) {        Assert.assertEquals(inputPair.datum().get(0), defaultRank);        sumOfCounts += (Long) inputPair.datum().get(1);        numOfCounts++;    }    Assert.assertEquals(numOfCounts, WordCountUtil.COUNTS.size());    long actualSumOfCounts = 0;    for (Long count : WordCountUtil.COUNTS.values()) {        actualSumOfCounts += count;    }    Assert.assertEquals(sumOfCounts, actualSumOfCounts);}
f4a1dc5777c93249cccbd46470790fd49d3a746ed5ef593ba80945ddfb4872a4
testProjection1
public void testProjection1(String inputDirectory) throws Exception
{    JobConf job = new JobConf();    Schema readerSchema = Schema.create(Schema.Type.STRING);    AvroJob.setInputSchema(job, readerSchema);    Path inputPath = new Path(inputDirectory + "/myavro1-r-00000.avro");    FileStatus fileStatus = FileSystem.get(job).getFileStatus(inputPath);    FileSplit fileSplit = new FileSplit(inputPath, 0, fileStatus.getLen(), job);    AvroWrapper<Utf8> inputPair = new AvroWrapper<>(null);    NullWritable ignore = NullWritable.get();    AvroRecordReader<Utf8> recordReader = new AvroRecordReader<>(job, fileSplit);    long sumOfCounts = 0;    long numOfCounts = 0;    while (recordReader.next(inputPair, ignore)) {        sumOfCounts += Long.parseLong(inputPair.datum().toString().split(":")[2].replace("}", "").trim());        numOfCounts++;    }    Assert.assertEquals(numOfCounts, WordCountUtil.COUNTS.size());    long actualSumOfCounts = 0;    for (Long count : WordCountUtil.COUNTS.values()) {        actualSumOfCounts += count;    }    Assert.assertEquals(sumOfCounts, actualSumOfCounts);}
7db95be778ecd75eb41ffca38b79b90efbced21119031ae97f6e83ee80c88672
testProjectionNewMethodsTwo
public void testProjectionNewMethodsTwo(String inputDirectory) throws Exception
{    JobConf job = new JobConf();    Schema readerSchema = Schema.create(Schema.Type.STRING);    AvroJob.setInputSchema(job, readerSchema);    Path inputPath = new Path(inputDirectory + "/testavrofile1-r-00000.avro");    FileStatus fileStatus = FileSystem.get(job).getFileStatus(inputPath);    FileSplit fileSplit = new FileSplit(inputPath, 0, fileStatus.getLen(), job);    AvroWrapper<Utf8> inputPair = new AvroWrapper<>(null);    NullWritable ignore = NullWritable.get();    AvroRecordReader<Utf8> recordReader = new AvroRecordReader<>(job, fileSplit);    long sumOfCounts = 0;    long numOfCounts = 0;    while (recordReader.next(inputPair, ignore)) {        sumOfCounts += Long.parseLong(inputPair.datum().toString().split(":")[2].replace("}", "").trim());        numOfCounts++;    }    Assert.assertEquals(numOfCounts, WordCountUtil.COUNTS.size());    long actualSumOfCounts = 0;    for (Long count : WordCountUtil.COUNTS.values()) {        actualSumOfCounts += count;    }    Assert.assertEquals(sumOfCounts, actualSumOfCounts);}
4342ca8194ae0c3ccdda8cc41b8bdc2bbd44993e2e19fdbddd15626d3af2ab1d
testJobNoreducer
public void testJobNoreducer() throws Exception
{    JobConf job = new JobConf();    job.setNumReduceTasks(0);    Path outputPath = new Path(OUTPUT_DIR.getRoot().getPath());    outputPath.getFileSystem(job).delete(outputPath);    WordCountUtil.writeLinesFile(new File(INPUT_DIR.getRoot(), "lines.avro"));    job.setJobName("AvroMultipleOutputs_noreducer");    AvroJob.setInputSchema(job, Schema.create(Schema.Type.STRING));    AvroJob.setOutputSchema(job, new Pair<Utf8, Long>(new Utf8(""), 0L).getSchema());    AvroJob.setMapperClass(job, MapImpl.class);    FileInputFormat.setInputPaths(job, new Path(INPUT_DIR.getRoot().toString()));    FileOutputFormat.setOutputPath(job, outputPath);    FileOutputFormat.setCompressOutput(job, false);    AvroMultipleOutputs.addNamedOutput(job, "myavro2", AvroOutputFormat.class, Schema.create(Schema.Type.STRING));    JobClient.runJob(job);}
9c0017dcf275f9aad305142fb10bdf5b1ae2ec26c8724fa2e0e5bc487b1faa12
testProjectionNoreducer
public void testProjectionNoreducer(String inputDirectory) throws Exception
{    JobConf job = new JobConf();    long onel = 1;    Schema readerSchema = Schema.create(Schema.Type.STRING);    AvroJob.setInputSchema(job, readerSchema);    Path inputPath = new Path(inputDirectory + "/myavro2-m-00000.avro");    FileStatus fileStatus = FileSystem.get(job).getFileStatus(inputPath);    FileSplit fileSplit = new FileSplit(inputPath, 0, fileStatus.getLen(), (String[]) null);    AvroRecordReader<Utf8> recordReader = new AvroRecordReader<>(job, fileSplit);    AvroWrapper<Utf8> inputPair = new AvroWrapper<>(null);    NullWritable ignore = NullWritable.get();    while (recordReader.next(inputPair, ignore)) {        long testl = Long.parseLong(inputPair.datum().toString().split(":")[2].replace("}", "").trim());        Assert.assertEquals(onel, testl);    }}
893db8e65ef56191b86f8673effb0ca1371127967af7374c8e71345bbc5bda8c
testSetSyncInterval
public void testSetSyncInterval()
{    JobConf jobConf = new JobConf();    int newSyncInterval = 100000;    AvroOutputFormat.setSyncInterval(jobConf, newSyncInterval);    assertEquals(newSyncInterval, jobConf.getInt(AvroOutputFormat.SYNC_INTERVAL_KEY, -1));}
ba5fd7d5231c7ed6268141295dd5cc51e2ddc0b8a5df41a7a1e5f60dc54839c0
testNoCodec
public void testNoCodec()
{    JobConf job = new JobConf();    assertNull(AvroOutputFormat.getCodecFactory(job));    job = new JobConf();    job.set("mapred.output.compress", "false");    job.set("mapred.output.compression.codec", "org.apache.hadoop.io.compress.BZip2Codec");    assertNull(AvroOutputFormat.getCodecFactory(job));    job = new JobConf();    job.set("mapred.output.compress", "false");    job.set(AvroJob.OUTPUT_CODEC, "bzip2");    assertNull(AvroOutputFormat.getCodecFactory(job));}
90f5f0bf782d8780bb37cd85f230097acdf6d8591d2bad78a0e16a47e788f68f
testBZip2CodecUsingHadoopClass
public void testBZip2CodecUsingHadoopClass()
{    CodecFactory avroBZip2Codec = CodecFactory.fromString("bzip2");    JobConf job = new JobConf();    job.set("mapred.output.compress", "true");    job.set("mapred.output.compression.codec", "org.apache.hadoop.io.compress.BZip2Codec");    CodecFactory factory = AvroOutputFormat.getCodecFactory(job);    assertNotNull(factory);    assertEquals(factory.getClass(), avroBZip2Codec.getClass());}
893754009e80a12be35a2bec056c00a41c8993639470563f3460deaecaeaf43b
testBZip2CodecUsingAvroCodec
public void testBZip2CodecUsingAvroCodec()
{    CodecFactory avroBZip2Codec = CodecFactory.fromString("bzip2");    JobConf job = new JobConf();    job.set("mapred.output.compress", "true");    job.set(AvroJob.OUTPUT_CODEC, "bzip2");    CodecFactory factory = AvroOutputFormat.getCodecFactory(job);    assertNotNull(factory);    assertEquals(factory.getClass(), avroBZip2Codec.getClass());}
fa16c0255abb3d7666d40853a5c3f9e1a5860dda8159eefb545cd9e20c2dc6b2
testDeflateCodecUsingHadoopClass
public void testDeflateCodecUsingHadoopClass()
{    CodecFactory avroDeflateCodec = CodecFactory.fromString("deflate");    JobConf job = new JobConf();    job.set("mapred.output.compress", "true");    job.set("mapred.output.compression.codec", "org.apache.hadoop.io.compress.DeflateCodec");    CodecFactory factory = AvroOutputFormat.getCodecFactory(job);    assertNotNull(factory);    assertEquals(factory.getClass(), avroDeflateCodec.getClass());}
5996ce975d42335fad2c3697387b17f861d4c71d47d0d71ee4e907c6833164a3
testDeflateCodecUsingAvroCodec
public void testDeflateCodecUsingAvroCodec()
{    CodecFactory avroDeflateCodec = CodecFactory.fromString("deflate");    JobConf job = new JobConf();    job.set("mapred.output.compress", "true");    job.set(AvroJob.OUTPUT_CODEC, "deflate");    CodecFactory factory = AvroOutputFormat.getCodecFactory(job);    assertNotNull(factory);    assertEquals(factory.getClass(), avroDeflateCodec.getClass());}
48c207ca3a49b2d8ab0e96ed107223d383cf0bdaafb41c43208a5ec444f990a6
testSnappyCodecUsingHadoopClass
public void testSnappyCodecUsingHadoopClass()
{    CodecFactory avroSnappyCodec = CodecFactory.fromString("snappy");    JobConf job = new JobConf();    job.set("mapred.output.compress", "true");    job.set("mapred.output.compression.codec", "org.apache.hadoop.io.compress.SnappyCodec");    CodecFactory factory = AvroOutputFormat.getCodecFactory(job);    assertNotNull(factory);    assertEquals(factory.getClass(), avroSnappyCodec.getClass());}
c1454bd3efa0a1061b9898540a9235cec8467a84a7a459f2db97921ca50cb1d7
testSnappyCodecUsingAvroCodec
public void testSnappyCodecUsingAvroCodec()
{    CodecFactory avroSnappyCodec = CodecFactory.fromString("snappy");    JobConf job = new JobConf();    job.set("mapred.output.compress", "true");    job.set(AvroJob.OUTPUT_CODEC, "snappy");    CodecFactory factory = AvroOutputFormat.getCodecFactory(job);    assertNotNull(factory);    assertEquals(factory.getClass(), avroSnappyCodec.getClass());}
6e06ca72769d5c3031224c78137b575c61c11411d80bc86fd0080592d0fd647d
testGZipCodecUsingHadoopClass
public void testGZipCodecUsingHadoopClass()
{    CodecFactory avroDeflateCodec = CodecFactory.fromString("deflate");    JobConf job = new JobConf();    job.set("mapred.output.compress", "true");    job.set("mapred.output.compression.codec", "org.apache.hadoop.io.compress.GZipCodec");    CodecFactory factory = AvroOutputFormat.getCodecFactory(job);    assertNotNull(factory);    assertEquals(factory.getClass(), avroDeflateCodec.getClass());}
02d84c5483a4c0a9ee28c2e5821f9279be6839ee0bd6b9223e570c8160f28372
testAvroTextRecordWriter
public void testAvroTextRecordWriter() throws Exception
{    File file = new File(tmpFolder.getRoot().getPath(), "writer");    Schema schema = Schema.create(Schema.Type.BYTES);    DatumWriter<ByteBuffer> datumWriter = new GenericDatumWriter<>(schema);    DataFileWriter<ByteBuffer> fileWriter = new DataFileWriter<>(datumWriter);    fileWriter.create(schema, file);    RecordWriter<Object, Object> rw = new AvroTextOutputFormat<>().new AvroTextRecordWriter(fileWriter, "\t".getBytes(StandardCharsets.UTF_8));    rw.write(null, null);    rw.write(null, NullWritable.get());    rw.write(NullWritable.get(), null);    rw.write(NullWritable.get(), NullWritable.get());    rw.write("k1", null);    rw.write("k2", NullWritable.get());    rw.write(null, "v1");    rw.write(NullWritable.get(), "v2");    rw.write("k3", "v3");    rw.write(new Text("k4"), new Text("v4"));    rw.close(null);    DatumReader<ByteBuffer> reader = new GenericDatumReader<>();    DataFileReader<ByteBuffer> fileReader = new DataFileReader<>(file, reader);    assertEquals("k1", asString(fileReader.next()));    assertEquals("k2", asString(fileReader.next()));    assertEquals("v1", asString(fileReader.next()));    assertEquals("v2", asString(fileReader.next()));    assertEquals("k3\tv3", asString(fileReader.next()));    assertEquals("k4\tv4", asString(fileReader.next()));    assertFalse("End", fileReader.hasNext());}
c0808d7542c40fe94494d8ff832bc65bbde49d8fccd7bfc309a68eb32b4b9477
asString
private String asString(ByteBuffer buf)
{    byte[] b = new byte[buf.remaining()];    buf.get(b);    return new String(b, StandardCharsets.UTF_8);}
04db606c3b6af52244d6b2f374d3d5e6f3bc13bfa973158f4b7442eede6112ef
testSort
public void testSort() throws Exception
{    JobConf job = new JobConf();    String inputPath = INPUT_DIR.getRoot().getPath();    Path outputPath = new Path(OUTPUT_DIR.getRoot().getPath());    outputPath.getFileSystem(job).delete(outputPath, true);    WordCountUtil.writeLinesBytesFile(inputPath);    job.setInputFormat(AvroAsTextInputFormat.class);    job.setOutputFormat(AvroTextOutputFormat.class);    job.setOutputKeyClass(Text.class);    FileInputFormat.setInputPaths(job, new Path(inputPath));    FileOutputFormat.setOutputPath(job, outputPath);    JobClient.runJob(job);    WordCountUtil.validateSortedFile(outputPath.toString() + "/part-00000.avro");}
cd89046fb8911fa4a6595be8ff9a8156398ebfad5d0c95e20ca6a68135c4b5d2
testToString
public void testToString()
{    String datum = "my string";    AvroWrapper<CharSequence> wrapper = new AvroWrapper<>(datum);    assertEquals(datum, wrapper.toString());}
f6b2ffc9904e1a1accddcd1d7f1ebc78437449dd2b1f5d0fe9d20c5b13397f44
createSchema
private static Schema createSchema()
{    List<Field> fields = new ArrayList<>();    fields.add(new Field("Optional", createArraySchema(), "", new ArrayList<>()));    Schema recordSchema = Schema.createRecord("Container", "", "org.apache.avro.mapred", false);    recordSchema.setFields(fields);    return recordSchema;}
f9e582a8a3b8aeaaa1b1353c97d98a4ff9bbb1d243b79d779a59cac7f51c6355
createArraySchema
private static Schema createArraySchema()
{    List<Schema> schemas = new ArrayList<>();    for (int i = 0; i < 5; i++) {        schemas.add(createInnerSchema("optional_field_" + i));    }    Schema unionSchema = Schema.createUnion(schemas);    return Schema.createArray(unionSchema);}
e21c7d0dea6ea7dc086e23701981e7f1ce7766bb2d1ebb69e523500eae06914c
createInnerSchema
private static Schema createInnerSchema(String name)
{    Schema innerrecord = Schema.createRecord(name, "", "", false);    innerrecord.setFields(Collections.singletonList(new Field(name, Schema.create(Type.LONG), "", 0L)));    return innerrecord;}
935d9dc08fe11323dcaaf5c6f96db76bb87fd0fc4b9fcc33e9eca9f620f5620c
setup
public void setup() throws IOException
{        String dir = DIR.getRoot().getPath();    File infile = new File(dir + "/in");    RandomAccessFile file = new RandomAccessFile(infile, "rw");        file.writeChars("aa bb cc\ndd ee ff\n");    file.close();}
86bf9adf5a226b377ad867131f38b3fd1efa1bdae530a19bacaf8b61f395af56
map
public void map(LongWritable key, Text value, OutputCollector<AvroWrapper<Pair<Long, GenericData.Record>>, NullWritable> out, Reporter reporter) throws IOException
{    GenericData.Record optional_entry = new GenericData.Record(createInnerSchema("optional_field_1"));    optional_entry.put("optional_field_1", 0L);    GenericData.Array<GenericData.Record> array = new GenericData.Array<>(1, createArraySchema());    array.add(optional_entry);    GenericData.Record container = new GenericData.Record(createSchema());    container.put("Optional", array);    out.collect(new AvroWrapper<>(new Pair<>(key.get(), container)), NullWritable.get());}
496a9c32181bc4736f27d74828c12dc4fc5605369f1c04984c214a97d38f2167
testJob
public void testJob() throws Exception
{    JobConf job = new JobConf();    Path outputPath = new Path(DIR.getRoot().getPath() + "/out");    outputPath.getFileSystem(job).delete(outputPath);    job.setInputFormat(TextInputFormat.class);    FileInputFormat.setInputPaths(job, DIR.getRoot().getPath() + "/in");    job.setMapperClass(AvroTestConverter.class);    job.setNumReduceTasks(0);    FileOutputFormat.setOutputPath(job, outputPath);    System.out.println(createSchema());    AvroJob.setOutputSchema(job, Pair.getPairSchema(Schema.create(Schema.Type.LONG), createSchema()));    job.setOutputFormat(AvroOutputFormat.class);    JobClient.runJob(job);}
74c15e6019d115f7181c837a37106d17a9bd1aea9a0592fd9523cab4a32cc464
testCollectionFailure
public void testCollectionFailure() throws Exception
{    try {        new Pair("foo", new ArrayList());    } catch (AvroRuntimeException e) {        assertTrue(e.getMessage().startsWith("Cannot infer schema"));        return;    }    fail("Expected an AvroRuntimeException");}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return text;}
468e8988b09a508afee666b67538d010f5afb464a797a72c1e81a6adce8fca46
map
public void map(Text text, AvroCollector<Pair<Text, Count>> collector, Reporter reporter) throws IOException
{    StringTokenizer tokens = new StringTokenizer(text.toString());    while (tokens.hasMoreTokens()) collector.collect(new Pair<>(new Text(tokens.nextToken()), new Count(1L)));}
3abdf65db9ab49b9f9a5d40ed4f8e9cfd9f1b3030fb735a2d89a3693301bcee8
reduce
public void reduce(Text word, Iterable<Count> counts, AvroCollector<WordCount> collector, Reporter reporter) throws IOException
{    long sum = 0;    for (Count count : counts) sum += count.count;    collector.collect(new WordCount(word.text, sum));}
496a9c32181bc4736f27d74828c12dc4fc5605369f1c04984c214a97d38f2167
testJob
public void testJob() throws Exception
{    JobConf job = new JobConf();    String dir = "target/testReflectJob";    Path inputPath = new Path(dir + "/in");    Path outputPath = new Path(dir + "/out");    outputPath.getFileSystem(job).delete(outputPath);    inputPath.getFileSystem(job).delete(inputPath);    writeLinesFile(new File(dir + "/in"));    job.setJobName("reflect");    AvroJob.setInputSchema(job, ReflectData.get().getSchema(Text.class));    AvroJob.setMapOutputSchema(job, new Pair(new Text(""), new Count(0L)).getSchema());    AvroJob.setOutputSchema(job, ReflectData.get().getSchema(WordCount.class));    AvroJob.setMapperClass(job, MapImpl.class);        AvroJob.setReducerClass(job, ReduceImpl.class);    FileInputFormat.setInputPaths(job, inputPath);    FileOutputFormat.setOutputPath(job, outputPath);        AvroJob.setReflect(job);    JobClient.runJob(job);    validateCountsFile(new File(new File(dir, "out"), "part-00000.avro"));}
f59abc4509c6f17a1738bb0284ece7df869f20af441fb4c06ef220fd0301fe39
writeLinesFile
private void writeLinesFile(File dir) throws IOException
{    DatumWriter<Text> writer = new ReflectDatumWriter<>();    DataFileWriter<Text> out = new DataFileWriter<>(writer);    File linesFile = new File(dir + "/lines.avro");    dir.mkdirs();    out.create(ReflectData.get().getSchema(Text.class), linesFile);    for (String line : WordCountUtil.LINES) out.append(new Text(line));    out.close();}
c5cb6a4fab5c30f2634bc8ee1083ea415ffd9975019729a29cd4c8864f59bc61
validateCountsFile
private void validateCountsFile(File file) throws Exception
{    DatumReader<WordCount> reader = new ReflectDatumReader<>();    InputStream in = new BufferedInputStream(new FileInputStream(file));    DataFileStream<WordCount> counts = new DataFileStream<>(in, reader);    int numWords = 0;    for (WordCount wc : counts) {        assertEquals(wc.word, WordCountUtil.COUNTS.get(wc.word), (Long) wc.count);        numWords++;    }    in.close();    assertEquals(WordCountUtil.COUNTS.size(), numWords);}
db542ab731cb231c88c58df59ac0ba83f7682b2ab6115bc8ee822199c1a157d2
file
public static File file()
{    return new File(INPUT_DIR.getRoot().getPath(), "test.seq");}
f202793c6988707c9bebc50fd6e39c9604f84218fdb1c3bcce6a3379b8a70b22
testWriteSequenceFile
public static void testWriteSequenceFile() throws IOException
{    Configuration c = new Configuration();    URI uri = file().toURI();    try (SequenceFile.Writer writer = new SequenceFile.Writer(FileSystem.get(uri, c), c, new Path(uri.toString()), LongWritable.class, Text.class)) {        final LongWritable key = new LongWritable();        final Text val = new Text();        for (int i = 0; i < COUNT; ++i) {            key.set(i);            val.set(Integer.toString(i));            writer.append(key, val);        }    }}
1fcc22f8281b3e13d5e1091ef5f7adef662ff16ffc95f3717f0e020a1e84fad5
testReadSequenceFile
public void testReadSequenceFile() throws Exception
{    checkFile(new SequenceFileReader<>(file()));}
a33024ce550d73c1a8e482dc433924575e5fafef32c778c3276aac533d3846c6
checkFile
public void checkFile(FileReader<Pair<Long, CharSequence>> reader) throws Exception
{    long i = 0;    for (Pair<Long, CharSequence> p : reader) {        assertEquals((Long) i, p.key());        assertEquals(Long.toString(i), p.value().toString());        i++;    }    assertEquals(COUNT, i);    reader.close();}
30221be7079d7085d8cc3aa6c86fdd818e59a732585d0330a16e210953cb7276
testSequenceFileInputFormat
public void testSequenceFileInputFormat() throws Exception
{    JobConf job = new JobConf();    Path outputPath = new Path(OUTPUT_DIR.getRoot().getPath());    outputPath.getFileSystem(job).delete(outputPath, true);        AvroJob.setInputSequenceFile(job);    FileInputFormat.setInputPaths(job, file().toURI().toString());    AvroJob.setInputSchema(job, SCHEMA);                AvroJob.setOutputSchema(job, SCHEMA);    FileOutputFormat.setOutputPath(job, outputPath);    JobClient.runJob(job);    checkFile(new DataFileReader<>(new File(outputPath.toString() + "/part-00000.avro"), new SpecificDatumReader<>()));}
f2a338ee6403e00a076a287607247240c743ff34cc8d9169a8b438465a051e4c
map
public void map(LongWritable key, Text value, OutputCollector<AvroKey<Long>, AvroValue<Utf8>> out, Reporter reporter) throws IOException
{    out.collect(new AvroKey<>(key.get()), new AvroValue<>(new Utf8(value.toString())));}
26f095d086a42d05734e5f5d85567c09fb524dc2cbf6f98836135d97ad45d3af
testNonAvroMapper
public void testNonAvroMapper() throws Exception
{    JobConf job = new JobConf();    Path outputPath = new Path(OUTPUT_DIR.getRoot().getPath());    outputPath.getFileSystem(job).delete(outputPath, true);        job.setInputFormat(SequenceFileInputFormat.class);    FileInputFormat.setInputPaths(job, file().toURI().toString());        job.setMapperClass(NonAvroMapper.class);            FileOutputFormat.setOutputPath(job, outputPath);    AvroJob.setOutputSchema(job, SCHEMA);    JobClient.runJob(job);    checkFile(new DataFileReader<>(new File(outputPath.toString() + "/part-00000.avro"), new SpecificDatumReader<>()));}
565a021cded6560eb359c336d98caf2f654fd596edf4e4d94bf836e44b6c4fe3
map
public void map(LongWritable key, Text value, OutputCollector<AvroWrapper<Pair<Long, Utf8>>, NullWritable> out, Reporter reporter) throws IOException
{    out.collect(new AvroWrapper<>(new Pair<>(key.get(), new Utf8(value.toString()))), NullWritable.get());}
c738737b30caf3779a22ce70c9e8394810f07f7ff3124329736b9b81e73e8568
testNonAvroMapOnly
public void testNonAvroMapOnly() throws Exception
{    JobConf job = new JobConf();    Path outputPath = new Path(OUTPUT_DIR.getRoot().getPath());    outputPath.getFileSystem(job).delete(outputPath, true);        job.setInputFormat(SequenceFileInputFormat.class);    FileInputFormat.setInputPaths(job, file().toURI().toString());        job.setMapperClass(NonAvroOnlyMapper.class);            job.setNumReduceTasks(0);    FileOutputFormat.setOutputPath(job, outputPath);    AvroJob.setOutputSchema(job, SCHEMA);    JobClient.runJob(job);    checkFile(new DataFileReader<>(new File(outputPath.toString() + "/part-00000.avro"), new SpecificDatumReader<>()));}
af91b92addff3015c24e2c30b8e156294e90483a58162980cabcb88535340453
reduce
public void reduce(AvroKey<Long> key, Iterator<AvroValue<Utf8>> values, OutputCollector<LongWritable, Text> out, Reporter reporter) throws IOException
{    while (values.hasNext()) {        AvroValue<Utf8> value = values.next();        out.collect(new LongWritable(key.datum()), new Text(value.datum().toString()));    }}
ad794562fe8f8b2b166fc5b75177bd33ffcbbcf8f1bedfce2bdad7e979e55ded
testNonAvroReducer
public void testNonAvroReducer() throws Exception
{    JobConf job = new JobConf();    Path outputPath = new Path(OUTPUT_DIR.getRoot().getPath());    outputPath.getFileSystem(job).delete(outputPath, true);        AvroJob.setInputSequenceFile(job);    AvroJob.setInputSchema(job, SCHEMA);    FileInputFormat.setInputPaths(job, file().toURI().toString());            AvroJob.setMapOutputSchema(job, SCHEMA);    job.setReducerClass(NonAvroReducer.class);        job.setOutputFormat(SequenceFileOutputFormat.class);    FileOutputFormat.setOutputPath(job, outputPath);        JobClient.runJob(job);    checkFile(new SequenceFileReader<>(new File(outputPath.toString() + "/part-00000")));}
39e5ba029cc67f6f1d45c6d20f0df595ec16bc61da20d7680fcbbdae4fe7f95b
tearDown
public void tearDown()
{    mapCloseCalls.set(0);    mapConfigureCalls.set(0);    reducerCloseCalls.set(0);    reducerConfigureCalls.set(0);}
6daf274d78cbe3384c60d0533470d58b159518d50fc1ef10367ba226cec3e05b
testMapOnly
public void testMapOnly() throws Exception
{    JobConf job = new JobConf();    String inDir = System.getProperty("share.dir", "../../../share") + "/test/data";    Path input = new Path(inDir + "/weather.avro");    Path output = new Path("target/test/weather-ident");    output.getFileSystem(job).delete(output);    job.setJobName("identity map weather");    AvroJob.setInputSchema(job, Weather.SCHEMA$);    AvroJob.setOutputSchema(job, Weather.SCHEMA$);    FileInputFormat.setInputPaths(job, input);    FileOutputFormat.setOutputPath(job, output);    FileOutputFormat.setCompressOutput(job, true);        job.setNumReduceTasks(0);    JobClient.runJob(job);        DatumReader<Weather> reader = new SpecificDatumReader<>();    DataFileReader<Weather> check = new DataFileReader<>(new File(inDir + "/weather.avro"), reader);    DataFileReader<Weather> sorted = new DataFileReader<>(new File(output.toString() + "/part-00000.avro"), reader);    for (Weather w : sorted) assertEquals(check.next(), w);    check.close();    sorted.close();}
72bebdba1ccad59a0701c78f05b02ad20fae3b991360a306285dd5f40b3a24af
map
public void map(Weather w, AvroCollector<Pair<Weather, Void>> collector, Reporter reporter) throws IOException
{    collector.collect(new Pair<>(w, (Void) null));}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    mapCloseCalls.incrementAndGet();}
711139ba85089e8c83d383c716e53a6995c50f3b5bdb4f79367877d626bd4bd1
configure
public void configure(JobConf jobConf)
{    mapConfigureCalls.incrementAndGet();}
88add58adaf8cac138e85fa36a71de327c938bc5946f6d84f14f33547efafe7a
reduce
public void reduce(Weather w, Iterable<Void> ignore, AvroCollector<Weather> collector, Reporter reporter) throws IOException
{    collector.collect(w);}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    reducerCloseCalls.incrementAndGet();}
711139ba85089e8c83d383c716e53a6995c50f3b5bdb4f79367877d626bd4bd1
configure
public void configure(JobConf jobConf)
{    reducerConfigureCalls.incrementAndGet();}
04db606c3b6af52244d6b2f374d3d5e6f3bc13bfa973158f4b7442eede6112ef
testSort
public void testSort() throws Exception
{    JobConf job = new JobConf();    String inDir = "../../../share/test/data";    Path input = new Path(inDir + "/weather.avro");    Path output = new Path("target/test/weather-sort");    output.getFileSystem(job).delete(output);    job.setJobName("sort weather");    AvroJob.setInputSchema(job, Weather.SCHEMA$);    AvroJob.setMapOutputSchema(job, Pair.getPairSchema(Weather.SCHEMA$, Schema.create(Type.NULL)));    AvroJob.setOutputSchema(job, Weather.SCHEMA$);    AvroJob.setMapperClass(job, SortMapper.class);    AvroJob.setReducerClass(job, SortReducer.class);    FileInputFormat.setInputPaths(job, input);    FileOutputFormat.setOutputPath(job, output);    FileOutputFormat.setCompressOutput(job, true);    AvroJob.setOutputCodec(job, SNAPPY_CODEC);    JobClient.runJob(job);        DatumReader<Weather> reader = new SpecificDatumReader<>();    DataFileReader<Weather> check = new DataFileReader<>(new File(inDir + "/weather-sorted.avro"), reader);    DataFileReader<Weather> sorted = new DataFileReader<>(new File(output.toString() + "/part-00000.avro"), reader);    for (Weather w : sorted) assertEquals(check.next(), w);    check.close();    sorted.close();        assertEquals(1, mapCloseCalls.get());    assertEquals(1, reducerCloseCalls.get());    assertEquals(1, mapConfigureCalls.get());    assertEquals(1, reducerConfigureCalls.get());}
a5adba50a8f38754ea35f11bbb42ae8844c78d2e3f7886affca652feebb3caa4
map
public void map(Utf8 text, AvroCollector<Pair<Utf8, Long>> collector, Reporter reporter) throws IOException
{    StringTokenizer tokens = new StringTokenizer(text.toString());    while (tokens.hasMoreTokens()) collector.collect(new Pair<>(new Utf8(tokens.nextToken()), 1L));}
9d0ca6f930b62727af05bf24bc37f7d0d1e37c2a83df3b596d6d2ff412f198e1
reduce
public void reduce(Utf8 word, Iterable<Long> counts, AvroCollector<Pair<Utf8, Long>> collector, Reporter reporter) throws IOException
{    long sum = 0;    for (long count : counts) sum += count;    collector.collect(new Pair<>(word, sum));}
3e79f00488eb1e51412af24aff162ecb29c178f612062ebc2a2ed74b5fa0ac77
runTestsInOrder
public void runTestsInOrder() throws Exception
{    String pathOut = OUTPUT_DIR.getRoot().getPath();    testJob(pathOut);    testProjection(pathOut);}
4ee70adae6c2919664c68c56df1ef849b386e7749f8392c1123d5b963c933d20
testJob
public void testJob(String pathOut) throws Exception
{    JobConf job = new JobConf();    String pathIn = INPUT_DIR.getRoot().getPath();    WordCountUtil.writeLinesFile(pathIn + "/lines.avro");    Path outputPath = new Path(pathOut);    outputPath.getFileSystem(job).delete(outputPath);    job.setJobName("wordcount");    AvroJob.setInputSchema(job, Schema.create(Schema.Type.STRING));    AvroJob.setOutputSchema(job, new Pair<Utf8, Long>(new Utf8(""), 0L).getSchema());    AvroJob.setMapperClass(job, MapImpl.class);    AvroJob.setCombinerClass(job, ReduceImpl.class);    AvroJob.setReducerClass(job, ReduceImpl.class);    FileInputFormat.setInputPaths(job, new Path(pathIn));    FileOutputFormat.setOutputPath(job, new Path(pathOut));    FileOutputFormat.setCompressOutput(job, true);    WordCountUtil.setMeta(job);    JobClient.runJob(job);    WordCountUtil.validateCountsFile(new File(pathOut, "part-00000.avro"));}
d5b685603f3cf6f37fe47a233ade771dd05924afdb5c127cc9d52b29ec9ac01b
testProjection
public void testProjection(String inputPathString) throws Exception
{    JobConf job = new JobConf();    Integer defaultRank = -1;    String jsonSchema = "{\"type\":\"record\"," + "\"name\":\"org.apache.avro.mapred.Pair\"," + "\"fields\": [ " + "{\"name\":\"rank\", \"type\":\"int\", \"default\": -1}," + "{\"name\":\"value\", \"type\":\"long\"}" + "]}";    Schema readerSchema = Schema.parse(jsonSchema);    AvroJob.setInputSchema(job, readerSchema);    Path inputPath = new Path(inputPathString + "/part-00000.avro");    FileStatus fileStatus = FileSystem.get(job).getFileStatus(inputPath);    FileSplit fileSplit = new FileSplit(inputPath, 0, fileStatus.getLen(), job);    AvroRecordReader<Pair<Integer, Long>> recordReader = new AvroRecordReader<>(job, fileSplit);    AvroWrapper<Pair<Integer, Long>> inputPair = new AvroWrapper<>(null);    NullWritable ignore = NullWritable.get();    long sumOfCounts = 0;    long numOfCounts = 0;    while (recordReader.next(inputPair, ignore)) {        assertEquals(inputPair.datum().get(0), defaultRank);        sumOfCounts += (Long) inputPair.datum().get(1);        numOfCounts++;    }    assertEquals(numOfCounts, WordCountUtil.COUNTS.size());    long actualSumOfCounts = 0;    for (Long count : WordCountUtil.COUNTS.values()) {        actualSumOfCounts += count;    }    assertEquals(sumOfCounts, actualSumOfCounts);}
0e6244704e22f72183b01aa997191218022a213d446b8e18758979bc96601e83
_runjob
private void _runjob(String proto) throws Exception
{    String outputPathStr = OUTPUT_DIR.getRoot().getPath();    File inputPath = new File(INPUT_DIR.getRoot(), "lines.avro");    JobConf job = new JobConf();    Path outputPath = new Path(outputPathStr);    outputPath.getFileSystem(job).delete(outputPath, true);        WordCountUtil.writeLinesFile(inputPath);    File exec = new File(System.getProperty("java.home") + "/bin/java");        List<String> execargs = new ArrayList<>();    execargs.add("-classpath");    execargs.add(System.getProperty("java.class.path"));    execargs.add("org.apache.avro.mapred.tether.WordCountTask");    FileInputFormat.addInputPaths(job, inputPath.toString());    FileOutputFormat.setOutputPath(job, outputPath);    TetherJob.setExecutable(job, exec, execargs, false);    Schema outscheme = new Pair<Utf8, Long>(new Utf8(""), 0L).getSchema();    AvroJob.setInputSchema(job, Schema.create(Schema.Type.STRING));    job.set(AvroJob.OUTPUT_SCHEMA, outscheme.toString());    TetherJob.setProtocol(job, proto);    TetherJob.runJob(job);        DatumReader<Pair<Utf8, Long>> reader = new SpecificDatumReader<>();    InputStream cin = new BufferedInputStream(new FileInputStream(outputPath + "/part-00000.avro"));    DataFileStream<Pair<Utf8, Long>> counts = new DataFileStream<>(cin, reader);    int numWords = 0;    for (Pair<Utf8, Long> wc : counts) {        assertEquals(wc.key().toString(), WordCountUtil.COUNTS.get(wc.key().toString()), wc.value());        numWords++;    }    cin.close();    assertEquals(WordCountUtil.COUNTS.size(), numWords);}
496a9c32181bc4736f27d74828c12dc4fc5605369f1c04984c214a97d38f2167
testJob
public void testJob() throws Exception
{    _runjob("sasl");}
16cdd6fcf9b8f0f0d44c4252d6cb64f65d2650e47ef50c9f441849cfae3d1a3f
testhtp
public void testhtp() throws Exception
{    _runjob("http");}
d0b14d5897670de2b405eb6f37cad3ccf01e0f02d8276409e3e00fb177f72f80
data
public ByteBuffer data()
{    return ByteBuffer.wrap(buf, 0, count);}
4c04f0138ac14efdacc58ca6929d48074c77a1cec01ef91abe88858da0f2e827
collect
public void collect(T record) throws IOException
{    buffer.reset();    writer.write(record, encoder);    encoder.flush();    outputClient.output(buffer.data());}
762311902658d4b46cd3ce49115e5fc94ad7801cbaddc2f00fb3ccd5c169520e
collect
public void collect(T record, int partition) throws IOException
{    buffer.reset();    writer.write(record, encoder);    encoder.flush();    outputClient.outputPartitioned(partition, buffer.data());}
e89cd5277a330e88f8952155861baab137f4713792e4df1f110315ed2b2af7d8
open
 void open(int inputPort) throws IOException
{        String clientPortString = System.getenv("AVRO_TETHER_OUTPUT_PORT");    String protocol = System.getenv("AVRO_TETHER_PROTOCOL");    if (clientPortString == null)        throw new RuntimeException("AVRO_TETHER_OUTPUT_PORT env var is null");    int clientPort = Integer.parseInt(clientPortString);    if (protocol == null) {        throw new RuntimeException("AVRO_TETHER_PROTOCOL env var is null");    }    protocol = protocol.trim().toLowerCase();    TetheredProcess.Protocol proto;    if (protocol.equals("http")) {        proto = TetheredProcess.Protocol.HTTP;    } else if (protocol.equals("sasl")) {        proto = TetheredProcess.Protocol.SASL;    } else {        throw new RuntimeException("AVROT_TETHER_PROTOCOL=" + protocol + " but this protocol is unsupported");    }    switch(proto) {        case SASL:            this.clientTransceiver = new SaslSocketTransceiver(new InetSocketAddress(clientPort));            this.outputClient = SpecificRequestor.getClient(OutputProtocol.class, clientTransceiver);            break;        case HTTP:            this.clientTransceiver = new HttpTransceiver(new URL("http://127.0.0.1:" + clientPort));            this.outputClient = SpecificRequestor.getClient(OutputProtocol.class, clientTransceiver);            break;    }        outputClient.configure(inputPort);}
00987232d1e23e0eaf8cfe066d878314828d21849b1564135a413d42ec4a38c2
configure
 void configure(TaskType taskType, CharSequence inSchemaText, CharSequence outSchemaText)
{    this.taskType = taskType;    try {        Schema inSchema = new Schema.Parser().parse(inSchemaText.toString());        Schema outSchema = new Schema.Parser().parse(outSchemaText.toString());        switch(taskType) {            case MAP:                this.inReader = new SpecificDatumReader<>(inSchema);                this.midCollector = new Collector<>(outSchema);                break;            case REDUCE:                this.midReader = new SpecificDatumReader<>(inSchema);                this.outCollector = new Collector<>(outSchema);                break;        }    } catch (Throwable e) {        fail(e.toString());    }}
bb1c3a74d2cbc6f1863558d3823b5fca07bc458cbfc35227a1cbecfd47d08237
partitions
 void partitions(int partitions)
{    this.partitions = partitions;}
c538c7c505c1e78133e0d8459d667b0c8e8bd6f0e58115b3d01d627e8502b097
partitions
public int partitions()
{    return partitions;}
d10ba279ce4910bca550d0425c3e03b621bb7c32e9dbe690f246042f3300f27d
input
 void input(ByteBuffer data, long count)
{    try {        decoder = decoderFactory.binaryDecoder(data.array(), decoder);        for (long i = 0; i < count; i++) {            switch(taskType) {                case MAP:                    inRecord = inReader.read(inRecord, decoder);                    map(inRecord, midCollector);                    break;                case REDUCE:                    MID prev = midRecord;                    midRecord = midReader.read(midRecordSpare, decoder);                    if (prev != null && !midRecord.equals(prev))                        reduceFlush(prev, outCollector);                    reduce(midRecord, outCollector);                    midRecordSpare = prev;                    break;            }        }    } catch (Throwable e) {        LOG.warn("failing: " + e, e);        fail(e.toString());    }}
f280a18f676175b08434c2c92851866c39a6cc5fdc3c4a188b2e2ad7d567ac21
complete
 void complete()
{    if (taskType == TaskType.REDUCE && midRecord != null)        try {            reduceFlush(midRecord, outCollector);        } catch (Throwable e) {            LOG.warn("failing: " + e, e);            fail(e.toString());        }    LOG.info("TetherTask: Sending complete to parent process.");    outputClient.complete();    LOG.info("TetherTask: Done sending complete to parent process.");}
a97ab70307c920cc8fe203c4c9a678bcbfde9cecb93ebcb8f39f7dba969bce2c
status
public void status(String message)
{    outputClient.status(message);}
4b2c4743fcfc7d151c1b729357241fe5f1dab26ffb7b4c29f052dfff8f98aabc
count
public void count(String group, String name, long amount)
{    outputClient.count(group, name, amount);}
4e3c33d16b0b44f52cf533a2c210149926814f3a8dde2c533955a7e2b3af5e88
fail
public void fail(String message)
{    outputClient.fail(message);    close();}
c2864e5a4894768906844a2ddb5f229fc8d93aa73ebb06368e7b1ddbe43efd96
close
 void close()
{    LOG.info("Closing the transceiver");    if (clientTransceiver != null)        try {            clientTransceiver.close();        } catch (IOException e) {        }}
294018373deb5a36f0ca53027f4b1facdd5c0e4333b271388cfbbf81873ddf1d
configure
public void configure(TaskType taskType, String inSchema, String outSchema)
{    LOG.info("got configure");    task.configure(taskType, inSchema, outSchema);}
5eccd4b1278c247c10845f39889b9404bf40af35289cf82395d7e30469b1184e
input
public synchronized void input(ByteBuffer data, long count)
{    task.input(data, count);}
f547d07b7a7ee4bf5304ca95a4ea7c4bc3e0e802992b004a40fc0933fd84c59f
partitions
public void partitions(int partitions)
{    task.partitions(partitions);}
3e358ad1af3bc094e9ab9032d0b197aa5a53c6ad6f957f70b34e63afb16ed540
abort
public void abort()
{    LOG.info("got abort");    close();}
a4fdae130be96be9d0caa3e1a178f74086d464109d138860b29a92db4e4fb93c
complete
public synchronized void complete()
{    LOG.info("got input complete");    task.complete();}
297bf729764d09cd4f41f34d36692cfb5bb2f8beb881a5ceb1af47a65563da7a
join
public void join() throws InterruptedException
{    LOG.info("TetherTaskRunner: Start join.");    inputServer.join();    LOG.info("TetherTaskRunner: Finish join.");}
48d47d73a0edad28ffa0e449b7a84e717b5def7f34f981b6be6dbdaaf780fe61
close
private void close()
{    LOG.info("Closing the task");    task.close();    LOG.info("Finished closing the task.");    if (inputServer != null)        inputServer.close();}
db0fe7399cf499aa231524c9f703f4b2be46eb3fc06ab47cae8655b6838a749b
map
public void map(Utf8 text, Collector<Pair<Utf8, Long>> collector) throws IOException
{    StringTokenizer tokens = new StringTokenizer(text.toString());    while (tokens.hasMoreTokens()) collector.collect(new Pair<>(new Utf8(tokens.nextToken()), 1L));}
22b93b4a9c5386af7dc5954795c2c45753cddb1c6596d0476fec6edb0cf48ee0
reduce
public void reduce(Pair<Utf8, Long> wc, Collector<Pair<Utf8, Long>> c)
{    sum += wc.value();}
8f1f5062b561d5356fc8959d58b85488a474bfb180b657d2538cc8c14d5923a3
reduceFlush
public void reduceFlush(Pair<Utf8, Long> wc, Collector<Pair<Utf8, Long>> c) throws IOException
{    wc.value(sum);    c.collect(wc);    sum = 0;}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    new TetherTaskRunner(new WordCountTask()).join();    LOG.info("WordCountTask finished");}
6d43a5924593f3b7aab09c716a82431ac00919f732f9b4fc14fc0e196bafa39f
writeLinesFile
public static void writeLinesFile(String dir) throws IOException
{    writeLinesFile(new File(dir));}
50d162fc95a217b791f114134180b331f94d44b4d5d2f06e0b32a68bb462c99a
writeLinesFile
public static void writeLinesFile(File dir) throws IOException
{    DatumWriter<Utf8> writer = new GenericDatumWriter<>();    try (DataFileWriter<Utf8> out = new DataFileWriter<>(writer)) {        out.create(Schema.create(Schema.Type.STRING), dir);        for (String line : LINES) {            out.append(new Utf8(line));        }    }}
33c8d820447caa5e04ab43a9733848222465c0f32a3832d8f5d0d03ec3cf9b12
writeLinesBytesFile
public static void writeLinesBytesFile(String dir) throws IOException
{    writeLinesBytesFile(new File(dir));}
6350106614e268f23348019b6a9f4d2a1ca3d57e617a1d8d668a82e6c1dc2d31
writeLinesBytesFile
public static void writeLinesBytesFile(File dir) throws IOException
{    FileUtil.fullyDelete(dir);    File fileLines = new File(dir + "/lines.avro");    fileLines.getParentFile().mkdirs();    DatumWriter<ByteBuffer> writer = new GenericDatumWriter<>();    try (DataFileWriter<ByteBuffer> out = new DataFileWriter<>(writer)) {        out.create(Schema.create(Schema.Type.BYTES), fileLines);        for (String line : LINES) {            out.append(ByteBuffer.wrap(line.getBytes(StandardCharsets.UTF_8)));        }    }}
f0c7ebca5d979cca6b80a115a70a2e6b80f81e5c5a451b42bd4bcd3bd0cdc9cd
writeLinesTextFile
public static void writeLinesTextFile(File dir) throws IOException
{    FileUtil.fullyDelete(dir);    File fileLines = new File(dir, "lines.avro");    fileLines.getParentFile().mkdirs();    try (PrintStream out = new PrintStream(fileLines)) {        for (String line : LINES) {            out.println(line);        }    }}
9d305b7283c21e57b6064cf397859436dacf077bb15dd88d126761f278120219
validateCountsFile
public static void validateCountsFile(File file) throws Exception
{    int numWords = 0;    DatumReader<Pair<Utf8, Long>> reader = new SpecificDatumReader<>();    try (InputStream in = new BufferedInputStream(new FileInputStream(file))) {        try (DataFileStream<Pair<Utf8, Long>> counts = new DataFileStream<>(in, reader)) {            for (Pair<Utf8, Long> wc : counts) {                assertEquals(wc.key().toString(), COUNTS.get(wc.key().toString()), wc.value());                numWords++;            }            checkMeta(counts);        }    }    assertEquals(COUNTS.size(), numWords);}
11082028f897469c3ecb4d97ce768f174609585e6ece932163fe0b934250b26b
validateSortedFile
public static void validateSortedFile(String file) throws Exception
{    validateSortedFile(new File(file));}
87dea783e84fca433aa37fe4934025bcfaa5ec10800a984bf3657e4f226c7ea8
validateSortedFile
public static void validateSortedFile(File file) throws Exception
{    DatumReader<ByteBuffer> reader = new GenericDatumReader<>();    try (InputStream in = new BufferedInputStream(new FileInputStream(file))) {        try (DataFileStream<ByteBuffer> lines = new DataFileStream<>(in, reader)) {            List<String> sortedLines = new ArrayList<>(Arrays.asList(LINES));            Collections.sort(sortedLines);            for (String expectedLine : sortedLines) {                ByteBuffer buf = lines.next();                byte[] b = new byte[buf.remaining()];                buf.get(b);                assertEquals(expectedLine, new String(b, StandardCharsets.UTF_8).trim());            }            assertFalse(lines.hasNext());        }    }}
86d9303b759f9b19bb854230b4054137b9c17e9d0ecd2d02e8a497c0f45fe9bf
setMeta
public static void setMeta(JobConf job)
{    AvroJob.setOutputMeta(job, STRING_KEY, STRING_META_VALUE);    AvroJob.setOutputMeta(job, LONG_KEY, LONG_META_VALUE);    AvroJob.setOutputMeta(job, BYTES_KEY, BYTES_META_VALUE);}
cba47911ee48ebf237e995d6ca09087d3be8c6db1bc8b061d405c0f249fbdf93
checkMeta
public static void checkMeta(DataFileStream<?> in) throws Exception
{    assertEquals(STRING_META_VALUE, in.getMetaString(STRING_KEY));    assertEquals(LONG_META_VALUE, in.getMetaLong(LONG_KEY));    assertTrue(Arrays.equals(BYTES_META_VALUE, in.getMeta(BYTES_KEY)));}
6bd7a9e4937dda2aec2bc4c68733874ec3e5c1335f205399625e5d84772634aa
createFile
public static File createFile(File file, Schema schema, T... records) throws IOException
{    DatumWriter<T> datumWriter = new GenericDatumWriter<>(schema);    DataFileWriter<T> fileWriter = new DataFileWriter<>(datumWriter);    fileWriter.create(schema, file);    for (T record : records) {        fileWriter.append(record);    }    fileWriter.close();    return file;}
4a7dcc0a89cb633aa5a864e367729b2846ecedd11e7dbbdaff4e7895fd18abfd
testCreateRecordReader
public void testCreateRecordReader() throws IOException, InterruptedException
{        Job job = Job.getInstance();    AvroJob.setInputKeySchema(job, Schema.create(Schema.Type.STRING));    Configuration conf = job.getConfiguration();    FileSplit inputSplit = createMock(FileSplit.class);    TaskAttemptContext context = createMock(TaskAttemptContext.class);    expect(context.getConfiguration()).andReturn(conf).anyTimes();    replay(inputSplit);    replay(context);    AvroKeyInputFormat inputFormat = new AvroKeyInputFormat();    @SuppressWarnings("unchecked")    RecordReader<AvroKey<Object>, NullWritable> recordReader = inputFormat.createRecordReader(inputSplit, context);    assertNotNull(inputFormat);    recordReader.close();    verify(inputSplit);    verify(context);}
d7d7e43b4c0f669d20dc4523959e729145c01331a9bfdbf17f8ec626fd9e5c8e
testWithNullCodec
public void testWithNullCodec() throws IOException
{    Configuration conf = new Configuration();    conf.setInt(SYNC_INTERVAL_KEY, TEST_SYNC_INTERVAL);    testGetRecordWriter(conf, CodecFactory.nullCodec(), TEST_SYNC_INTERVAL);}
1cd287f8b8e1d12550093f2b94855d8cd935b2b6e3940dc708f62f67fe58e2e9
testWithDeflateCodec
public void testWithDeflateCodec() throws IOException
{    Configuration conf = new Configuration();    conf.setBoolean("mapred.output.compress", true);    conf.setInt(org.apache.avro.mapred.AvroOutputFormat.DEFLATE_LEVEL_KEY, 3);    testGetRecordWriter(conf, CodecFactory.deflateCodec(3), DataFileConstants.DEFAULT_SYNC_INTERVAL);}
cecb6f9ec285f4ba27135c84d44dae1da485b9a313d12c62d9360c8b50402f4a
testWithSnappyCode
public void testWithSnappyCode() throws IOException
{    Configuration conf = new Configuration();    conf.setBoolean("mapred.output.compress", true);    conf.set(AvroJob.CONF_OUTPUT_CODEC, DataFileConstants.SNAPPY_CODEC);    conf.setInt(SYNC_INTERVAL_KEY, TEST_SYNC_INTERVAL);    testGetRecordWriter(conf, CodecFactory.snappyCodec(), TEST_SYNC_INTERVAL);}
045c85518ffc32b6ed12431d1fb9b025ac627bdf521211555c36e1b9efa73fa4
testWithBZip2Code
public void testWithBZip2Code() throws IOException
{    Configuration conf = new Configuration();    conf.setBoolean("mapred.output.compress", true);    conf.set(AvroJob.CONF_OUTPUT_CODEC, DataFileConstants.BZIP2_CODEC);    testGetRecordWriter(conf, CodecFactory.bzip2Codec(), DataFileConstants.DEFAULT_SYNC_INTERVAL);}
7f7e3699c78e22278846148d382e64285089a47fde2ac9cfc3c7a5a66be23cc5
testWithZstandardCode
public void testWithZstandardCode() throws IOException
{    Configuration conf = new Configuration();    conf.setBoolean("mapred.output.compress", true);    conf.set(AvroJob.CONF_OUTPUT_CODEC, DataFileConstants.ZSTANDARD_CODEC);    testGetRecordWriter(conf, CodecFactory.zstandardCodec(3), DataFileConstants.DEFAULT_SYNC_INTERVAL);}
b89cb863ee893b90355aa4d936698aae37399fe89e3880a983573e047a7f0248
testWithDeflateCodeWithHadoopConfig
public void testWithDeflateCodeWithHadoopConfig() throws IOException
{    Configuration conf = new Configuration();    conf.setBoolean("mapred.output.compress", true);    conf.set("mapred.output.compression.codec", "org.apache.hadoop.io.compress.DeflateCodec");    conf.setInt(org.apache.avro.mapred.AvroOutputFormat.DEFLATE_LEVEL_KEY, -1);    conf.setInt(SYNC_INTERVAL_KEY, TEST_SYNC_INTERVAL);    testGetRecordWriter(conf, CodecFactory.deflateCodec(-1), TEST_SYNC_INTERVAL);}
3360e73589daff69af8f90779800614267f106de31a64c74dd0a1fc5fa99a27d
testWithSnappyCodeWithHadoopConfig
public void testWithSnappyCodeWithHadoopConfig() throws IOException
{    Configuration conf = new Configuration();    conf.setBoolean("mapred.output.compress", true);    conf.set("mapred.output.compression.codec", "org.apache.hadoop.io.compress.SnappyCodec");    testGetRecordWriter(conf, CodecFactory.snappyCodec(), DataFileConstants.DEFAULT_SYNC_INTERVAL);}
5bd9f0ef5ebd50fbbb8c0ee6978f176a9ff3b0656a680db6d5f84cb824028bf1
testWithBZip2CodeWithHadoopConfig
public void testWithBZip2CodeWithHadoopConfig() throws IOException
{    Configuration conf = new Configuration();    conf.setBoolean("mapred.output.compress", true);    conf.set("mapred.output.compression.codec", "org.apache.hadoop.io.compress.BZip2Codec");    conf.setInt(SYNC_INTERVAL_KEY, TEST_SYNC_INTERVAL);    testGetRecordWriter(conf, CodecFactory.bzip2Codec(), TEST_SYNC_INTERVAL);}
2a18d9d2d733d104e234c46f3b3f55c3fc54b8b1fdd9b3bb36101b0ef5b11819
testGetRecordWriter
private void testGetRecordWriter(Configuration conf, CodecFactory expectedCodec, int expectedSyncInterval) throws IOException
{        Job job = Job.getInstance(conf);    job.getConfiguration().set("mapred.output.dir", mTempDir.getRoot().getPath());    Schema writerSchema = Schema.create(Schema.Type.INT);    AvroJob.setOutputKeySchema(job, writerSchema);    TaskAttemptContext context = createMock(TaskAttemptContext.class);    expect(context.getConfiguration()).andReturn(job.getConfiguration()).anyTimes();    expect(context.getTaskAttemptID()).andReturn(TaskAttemptID.forName("attempt_200707121733_0001_m_000000_0")).anyTimes();    expect(context.getNumReduceTasks()).andReturn(1);        @SuppressWarnings("unchecked")    RecordWriter<AvroKey<Integer>, NullWritable> expectedRecordWriter = createMock(RecordWriter.class);    AvroKeyOutputFormat.RecordWriterFactory recordWriterFactory = createMock(AvroKeyOutputFormat.RecordWriterFactory.class);        Capture<CodecFactory> capturedCodecFactory = Capture.newInstance();    expect(    recordWriterFactory.create(    eq(writerSchema),     anyObject(GenericData.class),     capture(capturedCodecFactory),     anyObject(OutputStream.class), eq(expectedSyncInterval))).andReturn(expectedRecordWriter);    replay(context);    replay(expectedRecordWriter);    replay(recordWriterFactory);    AvroKeyOutputFormat<Integer> outputFormat = new AvroKeyOutputFormat<>(recordWriterFactory);    RecordWriter<AvroKey<Integer>, NullWritable> recordWriter = outputFormat.getRecordWriter(context);        assertTrue(capturedCodecFactory.hasCaptured());    assertEquals(expectedCodec.toString(), capturedCodecFactory.getValue().toString());    verify(context);    verify(expectedRecordWriter);    verify(recordWriterFactory);    assertNotNull(recordWriter);    assertTrue(expectedRecordWriter == recordWriter);}
f81cc30eae3ee389a95854d9ee62cb4feb54fd181d0f179bdc563a68f8874aef
testReadRecords
public void testReadRecords() throws IOException, InterruptedException
{                final SeekableInput avroFileInput = new SeekableFileInput(AvroFiles.createFile(new File(mTempDir.getRoot(), "myStringfile.avro"), Schema.create(Schema.Type.STRING), "first", "second"));        Schema readerSchema = Schema.create(Schema.Type.STRING);    RecordReader<AvroKey<CharSequence>, NullWritable> recordReader = new AvroKeyRecordReader<CharSequence>(readerSchema) {        @Override        protected SeekableInput createSeekableInput(Configuration conf, Path path) throws IOException {            return avroFileInput;        }    };        Configuration conf = new Configuration();        FileSplit inputSplit = createMock(FileSplit.class);    expect(inputSplit.getPath()).andReturn(new Path("/path/to/an/avro/file")).anyTimes();    expect(inputSplit.getStart()).andReturn(0L).anyTimes();    expect(inputSplit.getLength()).andReturn(avroFileInput.length()).anyTimes();        TaskAttemptContext context = createMock(TaskAttemptContext.class);    expect(context.getConfiguration()).andReturn(conf).anyTimes();        replay(inputSplit);    replay(context);    recordReader.initialize(inputSplit, context);    assertEquals("Progress should be zero before any records are read", 0.0f, recordReader.getProgress(), 0.0f);        AvroKey<CharSequence> key;    NullWritable value;        assertTrue("Expected at least one record", recordReader.nextKeyValue());    key = recordReader.getCurrentKey();    value = recordReader.getCurrentValue();    assertNotNull("First record had null key", key);    assertNotNull("First record had null value", value);    CharSequence firstString = key.datum();    assertEquals("first", firstString.toString());    assertTrue("getCurrentKey() returned different keys for the same record", key == recordReader.getCurrentKey());    assertTrue("getCurrentValue() returned different values for the same record", value == recordReader.getCurrentValue());        assertTrue("Expected to read a second record", recordReader.nextKeyValue());    key = recordReader.getCurrentKey();    value = recordReader.getCurrentValue();    assertNotNull("Second record had null key", key);    assertNotNull("Second record had null value", value);    CharSequence secondString = key.datum();    assertEquals("second", secondString.toString());    assertEquals("Progress should be complete (2 out of 2 records processed)", 1.0f, recordReader.getProgress(), 0.0f);        assertFalse("Expected only 2 records", recordReader.nextKeyValue());        recordReader.close();        verify(inputSplit);    verify(context);}
dbb146daeba344873546f64ab7d207c698709f8de56f74a50bd2990029fc90c0
createSeekableInput
protected SeekableInput createSeekableInput(Configuration conf, Path path) throws IOException
{    return avroFileInput;}
a0d21f2da4a70f218d0e18876357fddaa83563d59cf205a7eb7099c9803c11d4
testWrite
public void testWrite() throws IOException
{    Schema writerSchema = Schema.create(Schema.Type.INT);    GenericData dataModel = new ReflectData();    CodecFactory compressionCodec = CodecFactory.nullCodec();    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();    TaskAttemptContext context = createMock(TaskAttemptContext.class);    replay(context);        AvroKeyRecordWriter<Integer> recordWriter = new AvroKeyRecordWriter<>(writerSchema, dataModel, compressionCodec, outputStream);    recordWriter.write(new AvroKey<>(1), NullWritable.get());    recordWriter.write(new AvroKey<>(2), NullWritable.get());    recordWriter.close(context);    verify(context);        InputStream inputStream = new ByteArrayInputStream(outputStream.toByteArray());    Schema readerSchema = Schema.create(Schema.Type.INT);    DatumReader<Integer> datumReader = new SpecificDatumReader<>(readerSchema);    DataFileStream<Integer> dataFileReader = new DataFileStream<>(inputStream, datumReader);        assertTrue(dataFileReader.hasNext());    assertEquals(1, dataFileReader.next().intValue());        assertTrue(dataFileReader.hasNext());    assertEquals(2, dataFileReader.next().intValue());        assertFalse(dataFileReader.hasNext());    dataFileReader.close();}
116ad9d83b54a4e1a9fdc9c72e6527c4bfc39391204f7f402b74f4db12ac33db
testSycnableWrite
public void testSycnableWrite() throws IOException
{    Schema writerSchema = Schema.create(Schema.Type.INT);    GenericData dataModel = new ReflectData();    CodecFactory compressionCodec = CodecFactory.nullCodec();    FileOutputStream outputStream = new FileOutputStream(new File("target/temp.avro"));    TaskAttemptContext context = createMock(TaskAttemptContext.class);    replay(context);        AvroKeyRecordWriter<Integer> recordWriter = new AvroKeyRecordWriter<>(writerSchema, dataModel, compressionCodec, outputStream);    long positionOne = recordWriter.sync();    recordWriter.write(new AvroKey<>(1), NullWritable.get());    long positionTwo = recordWriter.sync();    recordWriter.write(new AvroKey<>(2), NullWritable.get());    recordWriter.close(context);    verify(context);        Configuration conf = new Configuration();    conf.set("fs.default.name", "file:///");    Path avroFile = new Path("target/temp.avro");    DataFileReader<GenericData.Record> dataFileReader = new DataFileReader<>(new FsInput(avroFile, conf), new SpecificDatumReader<>());    dataFileReader.seek(positionTwo);        assertTrue(dataFileReader.hasNext());    assertEquals(2, dataFileReader.next());    dataFileReader.seek(positionOne);        assertTrue(dataFileReader.hasNext());    assertEquals(1, dataFileReader.next());    dataFileReader.close();}
f81cc30eae3ee389a95854d9ee62cb4feb54fd181d0f179bdc563a68f8874aef
testReadRecords
public void testReadRecords() throws IOException, InterruptedException
{                Schema keyValueSchema = AvroKeyValue.getSchema(Schema.create(Schema.Type.STRING), Schema.create(Schema.Type.INT));    AvroKeyValue<CharSequence, Integer> firstInputRecord = new AvroKeyValue<>(new GenericData.Record(keyValueSchema));    firstInputRecord.setKey("first");    firstInputRecord.setValue(1);    AvroKeyValue<CharSequence, Integer> secondInputRecord = new AvroKeyValue<>(new GenericData.Record(keyValueSchema));    secondInputRecord.setKey("second");    secondInputRecord.setValue(2);    final SeekableInput avroFileInput = new SeekableFileInput(AvroFiles.createFile(new File(mTempDir.getRoot(), "myInputFile.avro"), keyValueSchema, firstInputRecord.get(), secondInputRecord.get()));        RecordReader<AvroKey<CharSequence>, AvroValue<Integer>> recordReader = new AvroKeyValueRecordReader<CharSequence, Integer>(Schema.create(Schema.Type.STRING), Schema.create(Schema.Type.INT)) {        @Override        protected SeekableInput createSeekableInput(Configuration conf, Path path) throws IOException {            return avroFileInput;        }    };        Configuration conf = new Configuration();        FileSplit inputSplit = createMock(FileSplit.class);    expect(inputSplit.getPath()).andReturn(new Path("/path/to/an/avro/file")).anyTimes();    expect(inputSplit.getStart()).andReturn(0L).anyTimes();    expect(inputSplit.getLength()).andReturn(avroFileInput.length()).anyTimes();        TaskAttemptContext context = createMock(TaskAttemptContext.class);    expect(context.getConfiguration()).andReturn(conf).anyTimes();        replay(inputSplit);    replay(context);    recordReader.initialize(inputSplit, context);    assertEquals("Progress should be zero before any records are read", 0.0f, recordReader.getProgress(), 0.0f);        AvroKey<CharSequence> key;    AvroValue<Integer> value;        assertTrue("Expected at least one record", recordReader.nextKeyValue());    key = recordReader.getCurrentKey();    value = recordReader.getCurrentValue();    assertNotNull("First record had null key", key);    assertNotNull("First record had null value", value);    assertEquals("first", key.datum().toString());    assertEquals(1, value.datum().intValue());    assertTrue("getCurrentKey() returned different keys for the same record", key == recordReader.getCurrentKey());    assertTrue("getCurrentValue() returned different values for the same record", value == recordReader.getCurrentValue());        assertTrue("Expected to read a second record", recordReader.nextKeyValue());    key = recordReader.getCurrentKey();    value = recordReader.getCurrentValue();    assertNotNull("Second record had null key", key);    assertNotNull("Second record had null value", value);    assertEquals("second", key.datum().toString());    assertEquals(2, value.datum().intValue());    assertEquals("Progress should be complete (2 out of 2 records processed)", 1.0f, recordReader.getProgress(), 0.0f);        assertFalse("Expected only 2 records", recordReader.nextKeyValue());        recordReader.close();        verify(inputSplit);    verify(context);}
dbb146daeba344873546f64ab7d207c698709f8de56f74a50bd2990029fc90c0
createSeekableInput
protected SeekableInput createSeekableInput(Configuration conf, Path path) throws IOException
{    return avroFileInput;}
63338cab8b0a18d9a604c5c730ffed29d13ec8b3832f5e34aa3af753426f4c8f
testWriteRecords
public void testWriteRecords() throws IOException
{    Job job = Job.getInstance();    AvroJob.setOutputValueSchema(job, TextStats.SCHEMA$);    TaskAttemptContext context = createMock(TaskAttemptContext.class);    replay(context);    AvroDatumConverterFactory factory = new AvroDatumConverterFactory(job.getConfiguration());    AvroDatumConverter<Text, ?> keyConverter = factory.create(Text.class);    AvroValue<TextStats> avroValue = new AvroValue<>(null);    @SuppressWarnings("unchecked")    AvroDatumConverter<AvroValue<TextStats>, ?> valueConverter = factory.create((Class<AvroValue<TextStats>>) avroValue.getClass());    CodecFactory compressionCodec = CodecFactory.nullCodec();    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();                AvroKeyValueRecordWriter<Text, AvroValue<TextStats>> writer = new AvroKeyValueRecordWriter<>(keyConverter, valueConverter, new ReflectData(), compressionCodec, outputStream);    TextStats appleStats = new TextStats();    appleStats.setName("apple");    writer.write(new Text("apple"), new AvroValue<>(appleStats));    TextStats bananaStats = new TextStats();    bananaStats.setName("banana");    writer.write(new Text("banana"), new AvroValue<>(bananaStats));    writer.close(context);    verify(context);    ByteArrayInputStream inputStream = new ByteArrayInputStream(outputStream.toByteArray());    Schema readerSchema = AvroKeyValue.getSchema(Schema.create(Schema.Type.STRING), TextStats.SCHEMA$);    DatumReader<GenericRecord> datumReader = new SpecificDatumReader<>(readerSchema);    DataFileStream<GenericRecord> avroFileReader = new DataFileStream<>(inputStream, datumReader);        assertTrue(avroFileReader.hasNext());    AvroKeyValue<CharSequence, TextStats> firstRecord = new AvroKeyValue<>(avroFileReader.next());    assertNotNull(firstRecord.get());    assertEquals("apple", firstRecord.getKey().toString());    assertEquals("apple", firstRecord.getValue().getName().toString());        assertTrue(avroFileReader.hasNext());    AvroKeyValue<CharSequence, TextStats> secondRecord = new AvroKeyValue<>(avroFileReader.next());    assertNotNull(secondRecord.get());    assertEquals("banana", secondRecord.getKey().toString());    assertEquals("banana", secondRecord.getValue().getName().toString());        assertFalse(avroFileReader.hasNext());    avroFileReader.close();}
dd8ebae7c13c7f9e76fd684e1b191b2cb76d6cb9ed2e6562604d85d84378132b
testUsingReflection
public void testUsingReflection() throws Exception
{    Job job = Job.getInstance();    Schema schema = ReflectData.get().getSchema(R1.class);    AvroJob.setOutputValueSchema(job, schema);    TaskAttemptContext context = createMock(TaskAttemptContext.class);    replay(context);    R1 record = new R1();    record.attribute = "test";    AvroValue<R1> avroValue = new AvroValue<>(record);    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();    AvroDatumConverterFactory factory = new AvroDatumConverterFactory(job.getConfiguration());    AvroDatumConverter<Text, ?> keyConverter = factory.create(Text.class);    @SuppressWarnings("unchecked")    AvroDatumConverter<AvroValue<R1>, R1> valueConverter = factory.create((Class<AvroValue<R1>>) avroValue.getClass());    AvroKeyValueRecordWriter<Text, AvroValue<R1>> writer = new AvroKeyValueRecordWriter<>(keyConverter, valueConverter, new ReflectData(), CodecFactory.nullCodec(), outputStream);    writer.write(new Text("reflectionData"), avroValue);    writer.close(context);    verify(context);    ByteArrayInputStream inputStream = new ByteArrayInputStream(outputStream.toByteArray());    Schema readerSchema = AvroKeyValue.getSchema(Schema.create(Schema.Type.STRING), schema);    DatumReader<GenericRecord> datumReader = new ReflectDatumReader<>(readerSchema);    DataFileStream<GenericRecord> avroFileReader = new DataFileStream<>(inputStream, datumReader);        assertTrue(avroFileReader.hasNext());        AvroKeyValue<CharSequence, R1> firstRecord = new AvroKeyValue<>(avroFileReader.next());    assertNotNull(firstRecord.get());    assertEquals("reflectionData", firstRecord.getKey().toString());    assertEquals(record.attribute, firstRecord.getValue().attribute);}
9f17981be011a290e125f54e75a6948217be0343824a0a04c90eb11a402f9e81
testSyncableWriteRecords
public void testSyncableWriteRecords() throws IOException
{    Job job = Job.getInstance();    AvroJob.setOutputValueSchema(job, TextStats.SCHEMA$);    TaskAttemptContext context = createMock(TaskAttemptContext.class);    replay(context);    AvroDatumConverterFactory factory = new AvroDatumConverterFactory(job.getConfiguration());    AvroDatumConverter<Text, ?> keyConverter = factory.create(Text.class);    AvroValue<TextStats> avroValue = new AvroValue<>(null);    @SuppressWarnings("unchecked")    AvroDatumConverter<AvroValue<TextStats>, ?> valueConverter = factory.create((Class<AvroValue<TextStats>>) avroValue.getClass());    CodecFactory compressionCodec = CodecFactory.nullCodec();    FileOutputStream outputStream = new FileOutputStream(new File("target/temp.avro"));            AvroKeyValueRecordWriter<Text, AvroValue<TextStats>> writer = new AvroKeyValueRecordWriter<>(keyConverter, valueConverter, new ReflectData(), compressionCodec, outputStream);    TextStats appleStats = new TextStats();    appleStats.setName("apple");    long pointOne = writer.sync();    writer.write(new Text("apple"), new AvroValue<>(appleStats));    TextStats bananaStats = new TextStats();    bananaStats.setName("banana");    long pointTwo = writer.sync();    writer.write(new Text("banana"), new AvroValue<>(bananaStats));    writer.close(context);    verify(context);    Configuration conf = new Configuration();    conf.set("fs.default.name", "file:///");    Path avroFile = new Path("target/temp.avro");    DataFileReader<GenericData.Record> avroFileReader = new DataFileReader<>(new FsInput(avroFile, conf), new SpecificDatumReader<>());    avroFileReader.seek(pointTwo);        assertTrue(avroFileReader.hasNext());    AvroKeyValue<CharSequence, TextStats> secondRecord = new AvroKeyValue<>(avroFileReader.next());    assertNotNull(secondRecord.get());    assertEquals("banana", secondRecord.getKey().toString());    assertEquals("banana", secondRecord.getValue().getName().toString());    avroFileReader.seek(pointOne);        assertTrue(avroFileReader.hasNext());    AvroKeyValue<CharSequence, TextStats> firstRecord = new AvroKeyValue<>(avroFileReader.next());    assertNotNull(firstRecord.get());    assertEquals("apple", firstRecord.getKey().toString());    assertEquals("apple", firstRecord.getValue().getName().toString());        avroFileReader.close();}
060f525386b455f09eb7716b87f0bfd887b14ef3f89a63fe017c0477d7dcaaaf
setup
protected void setup(Context context)
{    mOne = new IntWritable(1);}
02c6ac588df245b2563ecc6656b5c5c0d612553867015297e978b63275671c7b
map
protected void map(LongWritable fileByteOffset, Text line, Context context) throws IOException, InterruptedException
{    context.write(line, mOne);}
060f525386b455f09eb7716b87f0bfd887b14ef3f89a63fe017c0477d7dcaaaf
setup
protected void setup(Context context)
{    mCount = new IntWritable(0);    mText = new Text("");}
6fac811dc53ce6f84097c9a3385fd3f549e01d1bbb9bf2b4ab63d2637e5b4a63
map
protected void map(AvroKey<TextStats> record, NullWritable ignore, Context context) throws IOException, InterruptedException
{    mCount.set(record.datum().getCount());    mText.set(record.datum().getName().toString());    context.write(mText, mCount);}
060f525386b455f09eb7716b87f0bfd887b14ef3f89a63fe017c0477d7dcaaaf
setup
protected void setup(Context context)
{    mStats = new AvroKey<>(null);    amos = new AvroMultipleOutputs(context);}
9d54dc06a9565d7d1233bac49dcdcfb1f73b403637ee1157d7c122561c301171
reduce
protected void reduce(Text line, Iterable<IntWritable> counts, Context context) throws IOException, InterruptedException
{    GenericData.Record record = new GenericData.Record(STATS_SCHEMA);    GenericData.Record record2 = new GenericData.Record(STATS_SCHEMA_2);    int sum = 0;    for (IntWritable count : counts) {        sum += count.get();    }    record.put("name", new Utf8(line.toString()));    record.put("count", sum);    mStats.datum(record);    context.write(mStats, NullWritable.get());    amos.write("myavro", mStats, NullWritable.get());    record2.put("name1", new Utf8(line.toString()));    record2.put("count1", sum);    mStats.datum(record2);    amos.write(mStats, NullWritable.get(), STATS_SCHEMA_2, null, "testnewwrite2");    amos.write("myavro1", mStats);    amos.write(mStats, NullWritable.get(), STATS_SCHEMA, null, "testnewwrite");    amos.write(mStats, NullWritable.get(), "testwritenonschema");}
2e250b70eb1261a97967b8b894cf822fc9e7eb36891dbb77c6d16369f85de12a
cleanup
protected void cleanup(Context context) throws IOException, InterruptedException
{    amos.close();}
060f525386b455f09eb7716b87f0bfd887b14ef3f89a63fe017c0477d7dcaaaf
setup
protected void setup(Context context)
{    mStats = new AvroKey<>(null);    amos = new AvroMultipleOutputs(context);}
9d54dc06a9565d7d1233bac49dcdcfb1f73b403637ee1157d7c122561c301171
reduce
protected void reduce(Text line, Iterable<IntWritable> counts, Context context) throws IOException, InterruptedException
{    TextStats record = new TextStats();    record.setCount(0);    for (IntWritable count : counts) {        record.setCount(record.getCount() + count.get());    }    record.setName(line.toString());    mStats.datum(record);    context.write(mStats, NullWritable.get());    amos.write("myavro3", mStats, NullWritable.get());}
2e250b70eb1261a97967b8b894cf822fc9e7eb36891dbb77c6d16369f85de12a
cleanup
protected void cleanup(Context context) throws IOException, InterruptedException
{    amos.close();}
d58e2291f23d2568344c61fd177f0efadd0f566ceded8eadac288773a2d381ca
map
protected void map(AvroKey<TextStats> key, NullWritable value, Context context) throws IOException, InterruptedException
{    context.write(key, value);}
d5060adc2c9e2cbcba83575392815e3860b5213b3f67867fbca740ebfce96992
reduce
protected void reduce(AvroKey<TextStats> key, Iterable<NullWritable> ignore, Context context) throws IOException, InterruptedException
{    context.write(key, NullWritable.get());}
eb2119f9c6ae9d0d4514fa4f15dbb3bb12376c40a72dee6b27d470da9012e2f8
testAvroGenericOutput
public void testAvroGenericOutput() throws Exception
{    Job job = Job.getInstance();    FileInputFormat.setInputPaths(job, new Path(getClass().getResource("/org/apache/avro/mapreduce/mapreduce-test-input.txt").toURI().toString()));    job.setInputFormatClass(TextInputFormat.class);    job.setMapperClass(LineCountMapper.class);    job.setMapOutputKeyClass(Text.class);    job.setMapOutputValueClass(IntWritable.class);    job.setReducerClass(GenericStatsReducer.class);    AvroJob.setOutputKeySchema(job, STATS_SCHEMA);    AvroMultipleOutputs.addNamedOutput(job, "myavro", AvroKeyOutputFormat.class, STATS_SCHEMA, null);    AvroMultipleOutputs.addNamedOutput(job, "myavro1", AvroKeyOutputFormat.class, STATS_SCHEMA_2);    job.setOutputFormatClass(AvroKeyOutputFormat.class);    Path outputPath = new Path(DIR.getRoot().getPath() + "/testAvroGenericOutput");    outputPath.getFileSystem(job.getConfiguration()).delete(outputPath, true);    FileOutputFormat.setOutputPath(job, outputPath);    Assert.assertTrue(job.waitForCompletion(true));        FileSystem fileSystem = FileSystem.get(job.getConfiguration());    FileStatus[] outputFiles = fileSystem.globStatus(outputPath.suffix("/myavro-r-00000.avro"));    Assert.assertEquals(1, outputFiles.length);    Map<String, Integer> counts = new HashMap<>();    try (DataFileReader<GenericData.Record> reader = new DataFileReader<>(new FsInput(outputFiles[0].getPath(), job.getConfiguration()), new GenericDatumReader<>(STATS_SCHEMA))) {        for (GenericData.Record record : reader) {            counts.put(((Utf8) record.get("name")).toString(), (Integer) record.get("count"));        }    }    Assert.assertEquals(3, counts.get("apple").intValue());    Assert.assertEquals(2, counts.get("banana").intValue());    Assert.assertEquals(1, counts.get("carrot").intValue());    outputFiles = fileSystem.globStatus(outputPath.suffix("/myavro1-r-00000.avro"));    Assert.assertEquals(1, outputFiles.length);    counts.clear();    try (DataFileReader<GenericData.Record> reader = new DataFileReader<>(new FsInput(outputFiles[0].getPath(), job.getConfiguration()), new GenericDatumReader<>(STATS_SCHEMA_2))) {        for (GenericData.Record record : reader) {            counts.put(((Utf8) record.get("name1")).toString(), (Integer) record.get("count1"));        }    }    Assert.assertEquals(3, counts.get("apple").intValue());    Assert.assertEquals(2, counts.get("banana").intValue());    Assert.assertEquals(1, counts.get("carrot").intValue());    outputFiles = fileSystem.globStatus(outputPath.suffix("/testnewwrite-r-00000.avro"));    Assert.assertEquals(1, outputFiles.length);    counts.clear();    try (DataFileReader<GenericData.Record> reader = new DataFileReader<>(new FsInput(outputFiles[0].getPath(), job.getConfiguration()), new GenericDatumReader<>(STATS_SCHEMA))) {        for (GenericData.Record record : reader) {            counts.put(((Utf8) record.get("name")).toString(), (Integer) record.get("count"));        }    }    Assert.assertEquals(3, counts.get("apple").intValue());    Assert.assertEquals(2, counts.get("banana").intValue());    Assert.assertEquals(1, counts.get("carrot").intValue());    outputFiles = fileSystem.globStatus(outputPath.suffix("/testnewwrite2-r-00000.avro"));    Assert.assertEquals(1, outputFiles.length);    counts.clear();    try (DataFileReader<GenericData.Record> reader = new DataFileReader<>(new FsInput(outputFiles[0].getPath(), job.getConfiguration()), new GenericDatumReader<>(STATS_SCHEMA_2))) {        for (GenericData.Record record : reader) {            counts.put(((Utf8) record.get("name1")).toString(), (Integer) record.get("count1"));        }    }    Assert.assertEquals(3, counts.get("apple").intValue());    Assert.assertEquals(2, counts.get("banana").intValue());    Assert.assertEquals(1, counts.get("carrot").intValue());    outputFiles = fileSystem.globStatus(outputPath.suffix("/testwritenonschema-r-00000.avro"));    Assert.assertEquals(1, outputFiles.length);    counts.clear();    try (DataFileReader<GenericData.Record> reader = new DataFileReader<>(new FsInput(outputFiles[0].getPath(), job.getConfiguration()), new GenericDatumReader<>(STATS_SCHEMA))) {        for (GenericData.Record record : reader) {            counts.put(((Utf8) record.get("name")).toString(), (Integer) record.get("count"));        }    }    Assert.assertEquals(3, counts.get("apple").intValue());    Assert.assertEquals(2, counts.get("banana").intValue());    Assert.assertEquals(1, counts.get("carrot").intValue());}
518b2cae1a371834f86de67845aac0c3b4fdc046276cc3571bce46934493fcdb
testAvroSpecificOutput
public void testAvroSpecificOutput() throws Exception
{    Job job = Job.getInstance();    FileInputFormat.setInputPaths(job, new Path(getClass().getResource("/org/apache/avro/mapreduce/mapreduce-test-input.txt").toURI().toString()));    job.setInputFormatClass(TextInputFormat.class);    job.setMapperClass(LineCountMapper.class);    job.setMapOutputKeyClass(Text.class);    job.setMapOutputValueClass(IntWritable.class);    AvroMultipleOutputs.addNamedOutput(job, "myavro3", AvroKeyOutputFormat.class, TextStats.SCHEMA$, null);    job.setReducerClass(SpecificStatsReducer.class);    AvroJob.setOutputKeySchema(job, TextStats.SCHEMA$);    job.setOutputFormatClass(AvroKeyOutputFormat.class);    Path outputPath = new Path(DIR.getRoot().getPath() + "/testAvroSpecificOutput");    outputPath.getFileSystem(job.getConfiguration()).delete(outputPath, true);    FileOutputFormat.setOutputPath(job, outputPath);    Assert.assertTrue(job.waitForCompletion(true));    FileSystem fileSystem = FileSystem.get(job.getConfiguration());    FileStatus[] outputFiles = fileSystem.globStatus(outputPath.suffix("/myavro3-*"));    Assert.assertEquals(1, outputFiles.length);    Map<String, Integer> counts = new HashMap<>();    try (DataFileReader<TextStats> reader = new DataFileReader<>(new FsInput(outputFiles[0].getPath(), job.getConfiguration()), new SpecificDatumReader<>())) {        for (TextStats record : reader) {            counts.put(record.getName().toString(), record.getCount());        }    }    Assert.assertEquals(3, counts.get("apple").intValue());    Assert.assertEquals(2, counts.get("banana").intValue());    Assert.assertEquals(1, counts.get("carrot").intValue());}
aa30cfa9211430ed3b2d0cadb1bf132fa88d9c58956792d206f49b56d01615be
testAvroInput
public void testAvroInput() throws Exception
{    Job job = Job.getInstance();    FileInputFormat.setInputPaths(job, new Path(getClass().getResource("/org/apache/avro/mapreduce/mapreduce-test-input.avro").toURI().toString()));    job.setInputFormatClass(AvroKeyInputFormat.class);    AvroJob.setInputKeySchema(job, TextStats.SCHEMA$);    AvroMultipleOutputs.addNamedOutput(job, "myavro3", AvroKeyOutputFormat.class, TextStats.SCHEMA$, null);    job.setMapperClass(StatCountMapper.class);    job.setMapOutputKeyClass(Text.class);    job.setMapOutputValueClass(IntWritable.class);    job.setReducerClass(SpecificStatsReducer.class);    AvroJob.setOutputKeySchema(job, TextStats.SCHEMA$);    job.setOutputFormatClass(AvroKeyOutputFormat.class);    Path outputPath = new Path(DIR.getRoot().getPath() + "/testAvroInput");    FileOutputFormat.setOutputPath(job, outputPath);    Assert.assertTrue(job.waitForCompletion(true));        FileSystem fileSystem = FileSystem.get(job.getConfiguration());    FileStatus[] outputFiles = fileSystem.globStatus(outputPath.suffix("/myavro3-*"));    Assert.assertEquals(1, outputFiles.length);    Map<String, Integer> counts = new HashMap<>();    try (DataFileReader<TextStats> reader = new DataFileReader<>(new FsInput(outputFiles[0].getPath(), job.getConfiguration()), new SpecificDatumReader<>())) {        for (TextStats record : reader) {            counts.put(record.getName().toString(), record.getCount());        }    }    Assert.assertEquals(3, counts.get("apple").intValue());    Assert.assertEquals(2, counts.get("banana").intValue());    Assert.assertEquals(1, counts.get("carrot").intValue());}
51c81b22b111cee5fa7e5a00df886b5cc45830dfde064b7eef277da2e33c8525
testAvroMapOutput
public void testAvroMapOutput() throws Exception
{    Job job = Job.getInstance();    FileInputFormat.setInputPaths(job, new Path(getClass().getResource("/org/apache/avro/mapreduce/mapreduce-test-input.avro").toURI().toString()));    job.setInputFormatClass(AvroKeyInputFormat.class);    AvroJob.setInputKeySchema(job, TextStats.SCHEMA$);    job.setMapperClass(SortMapper.class);    AvroJob.setMapOutputKeySchema(job, TextStats.SCHEMA$);    job.setMapOutputValueClass(NullWritable.class);    job.setReducerClass(SortReducer.class);    AvroJob.setOutputKeySchema(job, TextStats.SCHEMA$);    job.setOutputFormatClass(AvroKeyOutputFormat.class);    Path outputPath = new Path(DIR.getRoot().getPath() + "/testAvroMapOutput");    FileOutputFormat.setOutputPath(job, outputPath);    Assert.assertTrue(job.waitForCompletion(true));        FileSystem fileSystem = FileSystem.get(job.getConfiguration());    FileStatus[] outputFiles = fileSystem.globStatus(outputPath.suffix("/part-*"));    Assert.assertEquals(1, outputFiles.length);    Map<String, Integer> counts = new HashMap<>();    try (DataFileReader<TextStats> reader = new DataFileReader<>(new FsInput(outputFiles[0].getPath(), job.getConfiguration()), new SpecificDatumReader<>())) {        for (TextStats record : reader) {            counts.put(record.getName().toString(), record.getCount());        }    }    Assert.assertEquals(3, counts.get("apple").intValue());    Assert.assertEquals(2, counts.get("banana").intValue());    Assert.assertEquals(1, counts.get("carrot").intValue());}
060f525386b455f09eb7716b87f0bfd887b14ef3f89a63fe017c0477d7dcaaaf
setup
protected void setup(Context context)
{    mOne = new IntWritable(1);}
02c6ac588df245b2563ecc6656b5c5c0d612553867015297e978b63275671c7b
map
protected void map(LongWritable fileByteOffset, Text line, Context context) throws IOException, InterruptedException
{    context.write(line, mOne);}
060f525386b455f09eb7716b87f0bfd887b14ef3f89a63fe017c0477d7dcaaaf
setup
protected void setup(Context context)
{    mCount = new IntWritable(0);    mText = new Text("");}
6fac811dc53ce6f84097c9a3385fd3f549e01d1bbb9bf2b4ab63d2637e5b4a63
map
protected void map(AvroKey<TextStats> record, NullWritable ignore, Context context) throws IOException, InterruptedException
{    mCount.set(record.datum().getCount());    mText.set(record.datum().getName().toString());    context.write(mText, mCount);}
060f525386b455f09eb7716b87f0bfd887b14ef3f89a63fe017c0477d7dcaaaf
setup
protected void setup(Context context)
{    mStats = new AvroKey<>(null);    amos = new AvroMultipleOutputs(context);}
9d54dc06a9565d7d1233bac49dcdcfb1f73b403637ee1157d7c122561c301171
reduce
protected void reduce(Text line, Iterable<IntWritable> counts, Context context) throws IOException, InterruptedException
{    GenericData.Record record = new GenericData.Record(STATS_SCHEMA);    GenericData.Record record2 = new GenericData.Record(STATS_SCHEMA_2);    int sum = 0;    for (IntWritable count : counts) {        sum += count.get();    }    record.put("name", new Utf8(line.toString()));    record.put("count", sum);    mStats.datum(record);    context.write(mStats, NullWritable.get());    amos.sync("myavro", "myavro");    amos.write("myavro", mStats, NullWritable.get());    record2.put("name1", new Utf8(line.toString()));    record2.put("count1", sum);    mStats.datum(record2);    amos.write(mStats, NullWritable.get(), STATS_SCHEMA_2, null, "testnewwrite2");    amos.sync("myavro1", "myavro1");    amos.write("myavro1", mStats);    amos.write(mStats, NullWritable.get(), STATS_SCHEMA, null, "testnewwrite");    amos.write(mStats, NullWritable.get(), "testwritenonschema");}
2e250b70eb1261a97967b8b894cf822fc9e7eb36891dbb77c6d16369f85de12a
cleanup
protected void cleanup(Context context) throws IOException, InterruptedException
{    amos.close();}
060f525386b455f09eb7716b87f0bfd887b14ef3f89a63fe017c0477d7dcaaaf
setup
protected void setup(Context context)
{    mStats = new AvroKey<>(null);    amos = new AvroMultipleOutputs(context);}
9d54dc06a9565d7d1233bac49dcdcfb1f73b403637ee1157d7c122561c301171
reduce
protected void reduce(Text line, Iterable<IntWritable> counts, Context context) throws IOException, InterruptedException
{    TextStats record = new TextStats();    record.setCount(0);    for (IntWritable count : counts) {        record.setCount(record.getCount() + count.get());    }    record.setName(line.toString());    mStats.datum(record);    context.write(mStats, NullWritable.get());    amos.sync("myavro3", "myavro3");    amos.write("myavro3", mStats, NullWritable.get());}
2e250b70eb1261a97967b8b894cf822fc9e7eb36891dbb77c6d16369f85de12a
cleanup
protected void cleanup(Context context) throws IOException, InterruptedException
{    amos.close();}
d58e2291f23d2568344c61fd177f0efadd0f566ceded8eadac288773a2d381ca
map
protected void map(AvroKey<TextStats> key, NullWritable value, Context context) throws IOException, InterruptedException
{    context.write(key, value);}
d5060adc2c9e2cbcba83575392815e3860b5213b3f67867fbca740ebfce96992
reduce
protected void reduce(AvroKey<TextStats> key, Iterable<NullWritable> ignore, Context context) throws IOException, InterruptedException
{    context.write(key, NullWritable.get());}
eb2119f9c6ae9d0d4514fa4f15dbb3bb12376c40a72dee6b27d470da9012e2f8
testAvroGenericOutput
public void testAvroGenericOutput() throws Exception
{    Job job = Job.getInstance();    FileInputFormat.setInputPaths(job, new Path(getClass().getResource("/org/apache/avro/mapreduce/mapreduce-test-input.txt").toURI().toString()));    job.setInputFormatClass(TextInputFormat.class);    job.setMapperClass(LineCountMapper.class);    job.setMapOutputKeyClass(Text.class);    job.setMapOutputValueClass(IntWritable.class);    job.setReducerClass(GenericStatsReducer.class);    AvroJob.setOutputKeySchema(job, STATS_SCHEMA);    AvroMultipleOutputs.addNamedOutput(job, "myavro", AvroKeyOutputFormat.class, STATS_SCHEMA, null);    AvroMultipleOutputs.addNamedOutput(job, "myavro1", AvroKeyOutputFormat.class, STATS_SCHEMA_2);    job.setOutputFormatClass(AvroKeyOutputFormat.class);    Path outputPath = new Path(tmpFolder.getRoot().getPath() + "/out");    outputPath.getFileSystem(job.getConfiguration()).delete(outputPath, true);    FileOutputFormat.setOutputPath(job, outputPath);    Assert.assertTrue(job.waitForCompletion(true));        FileSystem fileSystem = FileSystem.get(job.getConfiguration());    FileStatus[] outputFiles = fileSystem.globStatus(outputPath.suffix("/myavro-r-00000.avro"));    Assert.assertEquals(1, outputFiles.length);    DataFileReader<GenericData.Record> reader = new DataFileReader<>(new FsInput(outputFiles[0].getPath(), job.getConfiguration()), new GenericDatumReader<>(STATS_SCHEMA));    Map<String, Integer> counts = new HashMap<>();    for (GenericData.Record record : reader) {        counts.put(((Utf8) record.get("name")).toString(), (Integer) record.get("count"));    }    reader.close();    Assert.assertEquals(3, counts.get("apple").intValue());    Assert.assertEquals(2, counts.get("banana").intValue());    Assert.assertEquals(1, counts.get("carrot").intValue());    outputFiles = fileSystem.globStatus(outputPath.suffix("/myavro1-r-00000.avro"));    Assert.assertEquals(1, outputFiles.length);    reader = new DataFileReader<>(new FsInput(outputFiles[0].getPath(), job.getConfiguration()), new GenericDatumReader<>(STATS_SCHEMA_2));    counts = new HashMap<>();    for (GenericData.Record record : reader) {        counts.put(((Utf8) record.get("name1")).toString(), (Integer) record.get("count1"));    }    reader.close();    Assert.assertEquals(3, counts.get("apple").intValue());    Assert.assertEquals(2, counts.get("banana").intValue());    Assert.assertEquals(1, counts.get("carrot").intValue());    outputFiles = fileSystem.globStatus(outputPath.suffix("/testnewwrite-r-00000.avro"));    Assert.assertEquals(1, outputFiles.length);    reader = new DataFileReader<>(new FsInput(outputFiles[0].getPath(), job.getConfiguration()), new GenericDatumReader<>(STATS_SCHEMA));    counts = new HashMap<>();    for (GenericData.Record record : reader) {        counts.put(((Utf8) record.get("name")).toString(), (Integer) record.get("count"));    }    reader.close();    Assert.assertEquals(3, counts.get("apple").intValue());    Assert.assertEquals(2, counts.get("banana").intValue());    Assert.assertEquals(1, counts.get("carrot").intValue());    outputFiles = fileSystem.globStatus(outputPath.suffix("/testnewwrite2-r-00000.avro"));    Assert.assertEquals(1, outputFiles.length);    reader = new DataFileReader<>(new FsInput(outputFiles[0].getPath(), job.getConfiguration()), new GenericDatumReader<>(STATS_SCHEMA_2));    counts = new HashMap<>();    for (GenericData.Record record : reader) {        counts.put(((Utf8) record.get("name1")).toString(), (Integer) record.get("count1"));    }    reader.close();    Assert.assertEquals(3, counts.get("apple").intValue());    Assert.assertEquals(2, counts.get("banana").intValue());    Assert.assertEquals(1, counts.get("carrot").intValue());    outputFiles = fileSystem.globStatus(outputPath.suffix("/testwritenonschema-r-00000.avro"));    Assert.assertEquals(1, outputFiles.length);    reader = new DataFileReader<>(new FsInput(outputFiles[0].getPath(), job.getConfiguration()), new GenericDatumReader<>(STATS_SCHEMA));    counts = new HashMap<>();    for (GenericData.Record record : reader) {        counts.put(((Utf8) record.get("name")).toString(), (Integer) record.get("count"));    }    reader.close();    Assert.assertEquals(3, counts.get("apple").intValue());    Assert.assertEquals(2, counts.get("banana").intValue());    Assert.assertEquals(1, counts.get("carrot").intValue());}
518b2cae1a371834f86de67845aac0c3b4fdc046276cc3571bce46934493fcdb
testAvroSpecificOutput
public void testAvroSpecificOutput() throws Exception
{    Job job = Job.getInstance();    FileInputFormat.setInputPaths(job, new Path(getClass().getResource("/org/apache/avro/mapreduce/mapreduce-test-input.txt").toURI().toString()));    job.setInputFormatClass(TextInputFormat.class);    job.setMapperClass(LineCountMapper.class);    job.setMapOutputKeyClass(Text.class);    job.setMapOutputValueClass(IntWritable.class);    AvroMultipleOutputs.addNamedOutput(job, "myavro3", AvroKeyOutputFormat.class, TextStats.SCHEMA$, null);    job.setReducerClass(SpecificStatsReducer.class);    AvroJob.setOutputKeySchema(job, TextStats.SCHEMA$);    job.setOutputFormatClass(AvroKeyOutputFormat.class);    Path outputPath = new Path(tmpFolder.getRoot().getPath() + "/out-specific");    outputPath.getFileSystem(job.getConfiguration()).delete(outputPath, true);    FileOutputFormat.setOutputPath(job, outputPath);    Assert.assertTrue(job.waitForCompletion(true));    FileSystem fileSystem = FileSystem.get(job.getConfiguration());    FileStatus[] outputFiles = fileSystem.globStatus(outputPath.suffix("/myavro3-*"));    Assert.assertEquals(1, outputFiles.length);    DataFileReader<TextStats> reader = new DataFileReader<>(new FsInput(outputFiles[0].getPath(), job.getConfiguration()), new SpecificDatumReader<>());    Map<String, Integer> counts = new HashMap<>();    for (TextStats record : reader) {        counts.put(record.getName().toString(), record.getCount());    }    reader.close();    Assert.assertEquals(3, counts.get("apple").intValue());    Assert.assertEquals(2, counts.get("banana").intValue());    Assert.assertEquals(1, counts.get("carrot").intValue());}
aa30cfa9211430ed3b2d0cadb1bf132fa88d9c58956792d206f49b56d01615be
testAvroInput
public void testAvroInput() throws Exception
{    Job job = Job.getInstance();    FileInputFormat.setInputPaths(job, new Path(getClass().getResource("/org/apache/avro/mapreduce/mapreduce-test-input.avro").toURI().toString()));    job.setInputFormatClass(AvroKeyInputFormat.class);    AvroJob.setInputKeySchema(job, TextStats.SCHEMA$);    AvroMultipleOutputs.addNamedOutput(job, "myavro3", AvroKeyOutputFormat.class, TextStats.SCHEMA$, null);    job.setMapperClass(StatCountMapper.class);    job.setMapOutputKeyClass(Text.class);    job.setMapOutputValueClass(IntWritable.class);    job.setReducerClass(SpecificStatsReducer.class);    AvroJob.setOutputKeySchema(job, TextStats.SCHEMA$);    job.setOutputFormatClass(AvroKeyOutputFormat.class);    Path outputPath = new Path(tmpFolder.getRoot().getPath() + "/out-specific-input");    FileOutputFormat.setOutputPath(job, outputPath);    Assert.assertTrue(job.waitForCompletion(true));        FileSystem fileSystem = FileSystem.get(job.getConfiguration());    FileStatus[] outputFiles = fileSystem.globStatus(outputPath.suffix("/myavro3-*"));    Assert.assertEquals(1, outputFiles.length);    DataFileReader<TextStats> reader = new DataFileReader<>(new FsInput(outputFiles[0].getPath(), job.getConfiguration()), new SpecificDatumReader<>());    Map<String, Integer> counts = new HashMap<>();    for (TextStats record : reader) {        counts.put(record.getName().toString(), record.getCount());    }    reader.close();    Assert.assertEquals(3, counts.get("apple").intValue());    Assert.assertEquals(2, counts.get("banana").intValue());    Assert.assertEquals(1, counts.get("carrot").intValue());}
51c81b22b111cee5fa7e5a00df886b5cc45830dfde064b7eef277da2e33c8525
testAvroMapOutput
public void testAvroMapOutput() throws Exception
{    Job job = Job.getInstance();    FileInputFormat.setInputPaths(job, new Path(getClass().getResource("/org/apache/avro/mapreduce/mapreduce-test-input.avro").toURI().toString()));    job.setInputFormatClass(AvroKeyInputFormat.class);    AvroJob.setInputKeySchema(job, TextStats.SCHEMA$);    job.setMapperClass(SortMapper.class);    AvroJob.setMapOutputKeySchema(job, TextStats.SCHEMA$);    job.setMapOutputValueClass(NullWritable.class);    job.setReducerClass(SortReducer.class);    AvroJob.setOutputKeySchema(job, TextStats.SCHEMA$);    job.setOutputFormatClass(AvroKeyOutputFormat.class);    Path outputPath = new Path(tmpFolder.getRoot().getPath() + "/out-specific-input");    FileOutputFormat.setOutputPath(job, outputPath);    Assert.assertTrue(job.waitForCompletion(true));        FileSystem fileSystem = FileSystem.get(job.getConfiguration());    FileStatus[] outputFiles = fileSystem.globStatus(outputPath.suffix("/part-*"));    Assert.assertEquals(1, outputFiles.length);    DataFileReader<TextStats> reader = new DataFileReader<>(new FsInput(outputFiles[0].getPath(), job.getConfiguration()), new SpecificDatumReader<>());    Map<String, Integer> counts = new HashMap<>();    for (TextStats record : reader) {        counts.put(record.getName().toString(), record.getCount());    }    reader.close();    Assert.assertEquals(3, counts.get("apple").intValue());    Assert.assertEquals(2, counts.get("banana").intValue());    Assert.assertEquals(1, counts.get("carrot").intValue());}
b995757ea4e0998028fd50188b80a609ee824ce7c187bc11f3ab113617f8af5f
testReadRecords
public void testReadRecords() throws IOException, InterruptedException, ClassNotFoundException
{    Schema keyValueSchema = AvroKeyValue.getSchema(Schema.create(Schema.Type.INT), Schema.create(Schema.Type.STRING));    AvroKeyValue<Integer, CharSequence> record1 = new AvroKeyValue<>(new GenericData.Record(keyValueSchema));    record1.setKey(1);    record1.setValue("apple banana carrot");    AvroFiles.createFile(new File(mTempDir.getRoot(), "combineSplit00.avro"), keyValueSchema, record1.get());    AvroKeyValue<Integer, CharSequence> record2 = new AvroKeyValue<>(new GenericData.Record(keyValueSchema));    record2.setKey(2);    record2.setValue("apple banana");    AvroFiles.createFile(new File(mTempDir.getRoot(), "combineSplit01.avro"), keyValueSchema, record2.get());        Job job = Job.getInstance();    FileInputFormat.setInputPaths(job, new Path(mTempDir.getRoot().getAbsolutePath()));    job.setInputFormatClass(CombineAvroKeyValueFileInputFormat.class);    AvroJob.setInputKeySchema(job, Schema.create(Schema.Type.INT));    AvroJob.setInputValueSchema(job, Schema.create(Schema.Type.STRING));        AvroJob.setMapOutputKeySchema(job, Schema.create(Schema.Type.INT));    AvroJob.setMapOutputValueSchema(job, Schema.create(Schema.Type.STRING));        job.setNumReduceTasks(0);    job.setOutputKeyClass(AvroKey.class);    job.setOutputValueClass(AvroValue.class);        job.setOutputFormatClass(AvroKeyValueOutputFormat.class);    Path outputPath = new Path(mTempDir.getRoot().getPath(), "out");    FileOutputFormat.setOutputPath(job, outputPath);        assertTrue(job.waitForCompletion(true));        File avroFile = new File(outputPath.toString(), "part-m-00000.avro");    DatumReader<GenericRecord> datumReader = new SpecificDatumReader<>(AvroKeyValue.getSchema(Schema.create(Schema.Type.INT), Schema.create(Schema.Type.STRING)));    DataFileReader<GenericRecord> avroFileReader = new DataFileReader<>(avroFile, datumReader);    assertTrue(avroFileReader.hasNext());    while (avroFileReader.hasNext()) {        AvroKeyValue<Integer, CharSequence> mapRecord1 = new AvroKeyValue<>(avroFileReader.next());        assertNotNull(mapRecord1.get());        if (mapRecord1.getKey().intValue() == 1) {            assertEquals("apple banana carrot", mapRecord1.getValue().toString());        } else if (mapRecord1.getKey().intValue() == 2) {            assertEquals("apple banana", mapRecord1.getValue().toString());        } else {            fail("Unknown key " + mapRecord1.getKey().intValue());        }    }}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    conf = new Configuration();    conf.set("fs.default.name", "file:///");    file = new File(DIR.getRoot(), "file.txt");    try (PrintWriter out = new PrintWriter(new OutputStreamWriter(new FileOutputStream(file), StandardCharsets.UTF_8))) {        out.print(FILE_CONTENTS);    }    fsInput = new FsInput(new Path(file.getPath()), conf);}
c6aaebb5a52567751db8dc8e1cb9dd4a4e582ef964a374b376c6a04f741802dc
tearDown
public void tearDown() throws Exception
{    if (fsInput != null) {        fsInput.close();    }}
3d9d7e841ff8ba48e943e2374817d19aff70521c873cfa2ff9e9b91f6c0fe0bd
testConfigurationConstructor
public void testConfigurationConstructor() throws Exception
{    try (FsInput in = new FsInput(new Path(file.getPath()), conf)) {        int expectedByteCount = 1;        byte[] readBytes = new byte[expectedByteCount];        int actualByteCount = fsInput.read(readBytes, 0, expectedByteCount);        assertThat(actualByteCount, is(equalTo(expectedByteCount)));    }}
5f59432870cdecf2bde754957040a1c089315505878c530da9729098146b9d06
testFileSystemConstructor
public void testFileSystemConstructor() throws Exception
{    Path path = new Path(file.getPath());    FileSystem fs = path.getFileSystem(conf);    try (FsInput in = new FsInput(path, fs)) {        int expectedByteCount = 1;        byte[] readBytes = new byte[expectedByteCount];        int actualByteCount = fsInput.read(readBytes, 0, expectedByteCount);        assertThat(actualByteCount, is(equalTo(expectedByteCount)));    }}
1c1e2d96ae9b4c44d11477522fc1a3199fc72869b7fa1655cca99515b0a1d463
testLength
public void testLength() throws IOException
{    assertEquals(fsInput.length(), FILE_CONTENTS.length());}
5fd4a313e76b4c72b8f04da6d40c8f3f451749f179b8171720d0f7bb15574d8f
testRead
public void testRead() throws Exception
{    byte[] expectedBytes = FILE_CONTENTS.getBytes(StandardCharsets.UTF_8);    byte[] actualBytes = new byte[expectedBytes.length];    int actualByteCount = fsInput.read(actualBytes, 0, actualBytes.length);    assertThat(actualBytes, is(equalTo(expectedBytes)));    assertThat(actualByteCount, is(equalTo(expectedBytes.length)));}
31c4419b57ac3cf87780a0357c0fef7a070884feec87871a03f4098014eca9f8
testSeek
public void testSeek() throws Exception
{    int seekPos = FILE_CONTENTS.length() / 2;    byte[] fileContentBytes = FILE_CONTENTS.getBytes(StandardCharsets.UTF_8);    byte expectedByte = fileContentBytes[seekPos];    fsInput.seek(seekPos);    byte[] readBytes = new byte[1];    fsInput.read(readBytes, 0, 1);    byte actualByte = readBytes[0];    assertThat(actualByte, is(equalTo(expectedByte)));}
58fdb986085b44b07400fe9a0448b6ad5b31b6abd64661bb6f904b2d5a973a5b
testTell
public void testTell() throws Exception
{    long expectedTellPos = FILE_CONTENTS.length() / 2;    fsInput.seek(expectedTellPos);    long actualTellPos = fsInput.tell();    assertThat(actualTellPos, is(equalTo(expectedTellPos)));}
79ab1974de445240dc171b0269e9626e1581ae1fa7b56b5462aa85914eec123b
createInputFile
private File createInputFile() throws IOException
{    Schema keyValueSchema = AvroKeyValue.getSchema(Schema.create(Schema.Type.INT), Schema.create(Schema.Type.STRING));    AvroKeyValue<Integer, CharSequence> record1 = new AvroKeyValue<>(new GenericData.Record(keyValueSchema));    record1.setKey(1);    record1.setValue("apple banana carrot");    AvroKeyValue<Integer, CharSequence> record2 = new AvroKeyValue<>(new GenericData.Record(keyValueSchema));    record2.setKey(2);    record2.setValue("apple banana");    AvroKeyValue<Integer, CharSequence> record3 = new AvroKeyValue<>(new GenericData.Record(keyValueSchema));    record3.setKey(3);    record3.setValue("apple");    return AvroFiles.createFile(new File(mTempDir.getRoot(), "inputKeyValues.avro"), keyValueSchema, record1.get(), record2.get(), record3.get());}
21819dc24b9a51daf800ec631e69cb78ff03ba10869a5a4b9ba403ae028656b5
map
protected void map(AvroKey<Integer> docid, AvroValue<CharSequence> body, Context context) throws IOException, InterruptedException
{    for (String token : body.datum().toString().split(" ")) {        context.write(new Text(token), new IntWritable(docid.datum()));    }}
37f6d592593b84c8e9deb2be60d978a9929ad8c7690dda9f96be8568f2156bde
reduce
protected void reduce(Text token, Iterable<IntWritable> docids, Context context) throws IOException, InterruptedException
{    List<Integer> hitlist = new ArrayList<>();    for (IntWritable docid : docids) {        hitlist.add(docid.get());    }    context.write(token, new AvroValue<>(hitlist));}
d44b4060565f52ebf9a6288cc6b5cb8a597eb89740154578d1294bc3dd6cf81e
testKeyValueInput
public void testKeyValueInput() throws ClassNotFoundException, IOException, InterruptedException
{        File inputFile = createInputFile();        Job job = Job.getInstance();    FileInputFormat.setInputPaths(job, new Path(inputFile.getAbsolutePath()));    job.setInputFormatClass(AvroKeyValueInputFormat.class);    AvroJob.setInputKeySchema(job, Schema.create(Schema.Type.INT));    AvroJob.setInputValueSchema(job, Schema.create(Schema.Type.STRING));        job.setMapperClass(IndexMapper.class);    job.setMapOutputKeyClass(Text.class);    job.setMapOutputValueClass(IntWritable.class);        job.setReducerClass(IndexReducer.class);    job.setOutputKeyClass(Text.class);    job.setOutputValueClass(AvroValue.class);    AvroJob.setOutputValueSchema(job, Schema.createArray(Schema.create(Schema.Type.INT)));        job.setOutputFormatClass(AvroKeyValueOutputFormat.class);    Path outputPath = new Path(mTempDir.getRoot().getPath(), "out-index");    FileOutputFormat.setOutputPath(job, outputPath);        assertTrue(job.waitForCompletion(true));        File avroFile = new File(outputPath.toString(), "part-r-00000.avro");    DatumReader<GenericRecord> datumReader = new SpecificDatumReader<>(AvroKeyValue.getSchema(Schema.create(Schema.Type.STRING), Schema.createArray(Schema.create(Schema.Type.INT))));    DataFileReader<GenericRecord> avroFileReader = new DataFileReader<>(avroFile, datumReader);    assertTrue(avroFileReader.hasNext());    AvroKeyValue<CharSequence, List<Integer>> appleRecord = new AvroKeyValue<>(avroFileReader.next());    assertNotNull(appleRecord.get());    assertEquals("apple", appleRecord.getKey().toString());    List<Integer> appleDocs = appleRecord.getValue();    assertEquals(3, appleDocs.size());    assertTrue(appleDocs.contains(1));    assertTrue(appleDocs.contains(2));    assertTrue(appleDocs.contains(3));    assertTrue(avroFileReader.hasNext());    AvroKeyValue<CharSequence, List<Integer>> bananaRecord = new AvroKeyValue<>(avroFileReader.next());    assertNotNull(bananaRecord.get());    assertEquals("banana", bananaRecord.getKey().toString());    List<Integer> bananaDocs = bananaRecord.getValue();    assertEquals(2, bananaDocs.size());    assertTrue(bananaDocs.contains(1));    assertTrue(bananaDocs.contains(2));    assertTrue(avroFileReader.hasNext());    AvroKeyValue<CharSequence, List<Integer>> carrotRecord = new AvroKeyValue<>(avroFileReader.next());    assertEquals("carrot", carrotRecord.getKey().toString());    List<Integer> carrotDocs = carrotRecord.getValue();    assertEquals(1, carrotDocs.size());    assertTrue(carrotDocs.contains(1));    assertFalse(avroFileReader.hasNext());    avroFileReader.close();}
618ac4b195ef3aec01bd6a0116cb85cccc8cb298f7e032ab365552f29fbd7789
testKeyValueInputMapOnly
public void testKeyValueInputMapOnly() throws ClassNotFoundException, IOException, InterruptedException
{        File inputFile = createInputFile();        Job job = Job.getInstance();    FileInputFormat.setInputPaths(job, new Path(inputFile.getAbsolutePath()));    job.setInputFormatClass(AvroKeyValueInputFormat.class);    AvroJob.setInputKeySchema(job, Schema.create(Schema.Type.INT));    AvroJob.setInputValueSchema(job, Schema.create(Schema.Type.STRING));        AvroJob.setMapOutputKeySchema(job, Schema.create(Schema.Type.INT));    AvroJob.setMapOutputValueSchema(job, Schema.create(Schema.Type.STRING));        job.setNumReduceTasks(0);    job.setOutputKeyClass(AvroKey.class);    job.setOutputValueClass(AvroValue.class);        job.setOutputFormatClass(AvroKeyValueOutputFormat.class);    Path outputPath = new Path(mTempDir.getRoot().getPath(), "out-index");    FileOutputFormat.setOutputPath(job, outputPath);        assertTrue(job.waitForCompletion(true));        File avroFile = new File(outputPath.toString(), "part-m-00000.avro");    DatumReader<GenericRecord> datumReader = new SpecificDatumReader<>(AvroKeyValue.getSchema(Schema.create(Schema.Type.INT), Schema.create(Schema.Type.STRING)));    DataFileReader<GenericRecord> avroFileReader = new DataFileReader<>(avroFile, datumReader);    assertTrue(avroFileReader.hasNext());    AvroKeyValue<Integer, CharSequence> record1 = new AvroKeyValue<>(avroFileReader.next());    assertNotNull(record1.get());    assertEquals(1, record1.getKey().intValue());    assertEquals("apple banana carrot", record1.getValue().toString());    assertTrue(avroFileReader.hasNext());    AvroKeyValue<Integer, CharSequence> record2 = new AvroKeyValue<>(avroFileReader.next());    assertNotNull(record2.get());    assertEquals(2, record2.getKey().intValue());    assertEquals("apple banana", record2.getValue().toString());    assertTrue(avroFileReader.hasNext());    AvroKeyValue<Integer, CharSequence> record3 = new AvroKeyValue<>(avroFileReader.next());    assertNotNull(record3.get());    assertEquals(3, record3.getKey().intValue());    assertEquals("apple", record3.getValue().toString());    assertFalse(avroFileReader.hasNext());    avroFileReader.close();}
060f525386b455f09eb7716b87f0bfd887b14ef3f89a63fe017c0477d7dcaaaf
setup
protected void setup(Context context)
{    mOne = new IntWritable(1);}
02c6ac588df245b2563ecc6656b5c5c0d612553867015297e978b63275671c7b
map
protected void map(LongWritable fileByteOffset, Text line, Context context) throws IOException, InterruptedException
{    context.write(line, mOne);}
df78dd30eaeda1baea71cb0b284be8e83d52efcfd9eeb290771e4dde7f16af9a
reduce
protected void reduce(Text word, Iterable<IntWritable> counts, Context context) throws IOException, InterruptedException
{    int sum = 0;    for (IntWritable count : counts) {        sum += count.get();    }    context.write(word, new IntWritable(sum));}
b541ea8fdc4ddcecc6a55d35ab9da834daea68be186db81c38a893a5f21937bc
testKeyValueMapReduce
public void testKeyValueMapReduce() throws ClassNotFoundException, IOException, InterruptedException, URISyntaxException
{        Job job = Job.getInstance();    FileInputFormat.setInputPaths(job, new Path(getClass().getResource("/org/apache/avro/mapreduce/mapreduce-test-input.txt").toURI().toString()));    job.setInputFormatClass(TextInputFormat.class);    job.setMapperClass(LineCountMapper.class);    job.setMapOutputKeyClass(Text.class);    job.setMapOutputValueClass(IntWritable.class);    job.setReducerClass(IntSumReducer.class);    job.setOutputKeyClass(Text.class);    job.setOutputValueClass(IntWritable.class);    job.setOutputFormatClass(AvroKeyValueOutputFormat.class);    Path outputPath = new Path(mTempDir.getRoot().getPath() + "/out-wordcount");    FileOutputFormat.setOutputPath(job, outputPath);        assertTrue(job.waitForCompletion(true));            File avroFile = new File(outputPath.toString(), "part-r-00000.avro");    DatumReader<GenericRecord> datumReader = new SpecificDatumReader<>(AvroKeyValue.getSchema(Schema.create(Schema.Type.STRING), Schema.create(Schema.Type.INT)));    DataFileReader<GenericRecord> avroFileReader = new DataFileReader<>(avroFile, datumReader);    assertTrue(avroFileReader.hasNext());    AvroKeyValue<CharSequence, Integer> appleRecord = new AvroKeyValue<>(avroFileReader.next());    assertNotNull(appleRecord.get());    assertEquals("apple", appleRecord.getKey().toString());    assertEquals(3, appleRecord.getValue().intValue());    assertTrue(avroFileReader.hasNext());    AvroKeyValue<CharSequence, Integer> bananaRecord = new AvroKeyValue<>(avroFileReader.next());    assertNotNull(bananaRecord.get());    assertEquals("banana", bananaRecord.getKey().toString());    assertEquals(2, bananaRecord.getValue().intValue());    assertTrue(avroFileReader.hasNext());    AvroKeyValue<CharSequence, Integer> carrotRecord = new AvroKeyValue<>(avroFileReader.next());    assertEquals("carrot", carrotRecord.getKey().toString());    assertEquals(1, carrotRecord.getValue().intValue());    assertFalse(avroFileReader.hasNext());    avroFileReader.close();}
060f525386b455f09eb7716b87f0bfd887b14ef3f89a63fe017c0477d7dcaaaf
setup
protected void setup(Context context)
{    mOne = new IntWritable(1);}
02c6ac588df245b2563ecc6656b5c5c0d612553867015297e978b63275671c7b
map
protected void map(LongWritable fileByteOffset, Text line, Context context) throws IOException, InterruptedException
{    context.write(line, mOne);}
060f525386b455f09eb7716b87f0bfd887b14ef3f89a63fe017c0477d7dcaaaf
setup
protected void setup(Context context)
{    mCount = new IntWritable(0);    mText = new Text("");}
6fac811dc53ce6f84097c9a3385fd3f549e01d1bbb9bf2b4ab63d2637e5b4a63
map
protected void map(AvroKey<TextStats> record, NullWritable ignore, Context context) throws IOException, InterruptedException
{    mCount.set(record.datum().getCount());    mText.set(record.datum().getName().toString());    context.write(mText, mCount);}
060f525386b455f09eb7716b87f0bfd887b14ef3f89a63fe017c0477d7dcaaaf
setup
protected void setup(Context context)
{    mCount = new IntWritable(0);    mText = new Text("");}
55b52bd59c6a050767d248b9e8f346ea9e4bb6ac14792a96450a2243a2f683ab
map
protected void map(AvroKey<ReflectStats> record, NullWritable ignore, Context context) throws IOException, InterruptedException
{    mCount.set(record.datum().count);    mText.set(record.datum().name);    context.write(mText, mCount);}
98996146e4a880837d0bbc381597b57efca267f55c3a113d3a36021e82ae58c9
reduce
protected void reduce(Text key, Iterable<IntWritable> counts, Context context) throws IOException, InterruptedException
{    int sum = 0;    for (IntWritable count : counts) {        sum += count.get();    }    context.write(new AvroKey<>(key.toString()), new AvroValue<>(sum));}
060f525386b455f09eb7716b87f0bfd887b14ef3f89a63fe017c0477d7dcaaaf
setup
protected void setup(Context context)
{    mStats = new AvroKey<>(null);}
9d54dc06a9565d7d1233bac49dcdcfb1f73b403637ee1157d7c122561c301171
reduce
protected void reduce(Text line, Iterable<IntWritable> counts, Context context) throws IOException, InterruptedException
{    GenericData.Record record = new GenericData.Record(STATS_SCHEMA);    int sum = 0;    for (IntWritable count : counts) {        sum += count.get();    }    record.put("name", new Utf8(line.toString()));    record.put("count", sum);    mStats.datum(record);    context.write(mStats, NullWritable.get());}
060f525386b455f09eb7716b87f0bfd887b14ef3f89a63fe017c0477d7dcaaaf
setup
protected void setup(Context context)
{    mStats = new AvroKey<>(null);}
9d54dc06a9565d7d1233bac49dcdcfb1f73b403637ee1157d7c122561c301171
reduce
protected void reduce(Text line, Iterable<IntWritable> counts, Context context) throws IOException, InterruptedException
{    TextStats record = new TextStats();    record.setCount(0);    for (IntWritable count : counts) {        record.setCount(record.getCount() + count.get());    }    record.setName(line.toString());    mStats.datum(record);    context.write(mStats, NullWritable.get());}
060f525386b455f09eb7716b87f0bfd887b14ef3f89a63fe017c0477d7dcaaaf
setup
protected void setup(Context context)
{    mStats = new AvroKey<>(null);}
9d54dc06a9565d7d1233bac49dcdcfb1f73b403637ee1157d7c122561c301171
reduce
protected void reduce(Text line, Iterable<IntWritable> counts, Context context) throws IOException, InterruptedException
{    ReflectStats record = new ReflectStats();    record.count = 0;    for (IntWritable count : counts) {        record.count += count.get();    }    record.name = line.toString();    mStats.datum(record);    context.write(mStats, NullWritable.get());}
d58e2291f23d2568344c61fd177f0efadd0f566ceded8eadac288773a2d381ca
map
protected void map(AvroKey<TextStats> key, NullWritable value, Context context) throws IOException, InterruptedException
{    context.write(key, value);}
d5060adc2c9e2cbcba83575392815e3860b5213b3f67867fbca740ebfce96992
reduce
protected void reduce(AvroKey<TextStats> key, Iterable<NullWritable> ignore, Context context) throws IOException, InterruptedException
{    context.write(key, NullWritable.get());}
eb2119f9c6ae9d0d4514fa4f15dbb3bb12376c40a72dee6b27d470da9012e2f8
testAvroGenericOutput
public void testAvroGenericOutput() throws Exception
{    Job job = Job.getInstance();    FileInputFormat.setInputPaths(job, new Path(getClass().getResource("/org/apache/avro/mapreduce/mapreduce-test-input.txt").toURI().toString()));    job.setInputFormatClass(TextInputFormat.class);    job.setMapperClass(LineCountMapper.class);    job.setMapOutputKeyClass(Text.class);    job.setMapOutputValueClass(IntWritable.class);    job.setReducerClass(GenericStatsReducer.class);    AvroJob.setOutputKeySchema(job, STATS_SCHEMA);    job.setOutputFormatClass(AvroKeyOutputFormat.class);    Path outputPath = new Path(tmpFolder.getRoot().getPath() + "/out-generic");    FileOutputFormat.setOutputPath(job, outputPath);    Assert.assertTrue(job.waitForCompletion(true));        FileSystem fileSystem = FileSystem.get(job.getConfiguration());    FileStatus[] outputFiles = fileSystem.globStatus(outputPath.suffix("/part-*"));    Assert.assertEquals(1, outputFiles.length);    DataFileReader<GenericData.Record> reader = new DataFileReader<>(new FsInput(outputFiles[0].getPath(), job.getConfiguration()), new GenericDatumReader<>(STATS_SCHEMA));    Map<String, Integer> counts = new HashMap<>();    for (GenericData.Record record : reader) {        counts.put(((Utf8) record.get("name")).toString(), (Integer) record.get("count"));    }    reader.close();    Assert.assertEquals(3, counts.get("apple").intValue());    Assert.assertEquals(2, counts.get("banana").intValue());    Assert.assertEquals(1, counts.get("carrot").intValue());}
518b2cae1a371834f86de67845aac0c3b4fdc046276cc3571bce46934493fcdb
testAvroSpecificOutput
public void testAvroSpecificOutput() throws Exception
{    Job job = Job.getInstance();    FileInputFormat.setInputPaths(job, new Path(getClass().getResource("/org/apache/avro/mapreduce/mapreduce-test-input.txt").toURI().toString()));    job.setInputFormatClass(TextInputFormat.class);    job.setMapperClass(LineCountMapper.class);    job.setMapOutputKeyClass(Text.class);    job.setMapOutputValueClass(IntWritable.class);    job.setReducerClass(SpecificStatsReducer.class);    AvroJob.setOutputKeySchema(job, TextStats.SCHEMA$);    job.setOutputFormatClass(AvroKeyOutputFormat.class);    Path outputPath = new Path(tmpFolder.getRoot().getPath() + "/out-specific");    FileOutputFormat.setOutputPath(job, outputPath);    Assert.assertTrue(job.waitForCompletion(true));        FileSystem fileSystem = FileSystem.get(job.getConfiguration());    FileStatus[] outputFiles = fileSystem.globStatus(outputPath.suffix("/part-*"));    Assert.assertEquals(1, outputFiles.length);    DataFileReader<TextStats> reader = new DataFileReader<>(new FsInput(outputFiles[0].getPath(), job.getConfiguration()), new SpecificDatumReader<>());    Map<String, Integer> counts = new HashMap<>();    for (TextStats record : reader) {        counts.put(record.getName().toString(), record.getCount());    }    reader.close();    Assert.assertEquals(3, counts.get("apple").intValue());    Assert.assertEquals(2, counts.get("banana").intValue());    Assert.assertEquals(1, counts.get("carrot").intValue());}
bda6efb62b4277e801a69b24e6db46ce3499c78bba998a20ed3ae7251a4476be
testAvroReflectOutput
public void testAvroReflectOutput() throws Exception
{    Job job = Job.getInstance();    FileInputFormat.setInputPaths(job, new Path(getClass().getResource("/org/apache/avro/mapreduce/mapreduce-test-input.txt").toURI().toString()));    job.setInputFormatClass(TextInputFormat.class);    job.setMapperClass(LineCountMapper.class);    job.setMapOutputKeyClass(Text.class);    job.setMapOutputValueClass(IntWritable.class);    job.setReducerClass(ReflectStatsReducer.class);    AvroJob.setOutputKeySchema(job, REFLECT_STATS_SCHEMA);    job.setOutputFormatClass(AvroKeyOutputFormat.class);    Path outputPath = new Path(tmpFolder.getRoot().getPath() + "/out-reflect");    FileOutputFormat.setOutputPath(job, outputPath);    Assert.assertTrue(job.waitForCompletion(true));        FileSystem fileSystem = FileSystem.get(job.getConfiguration());    FileStatus[] outputFiles = fileSystem.globStatus(outputPath.suffix("/part-*"));    Assert.assertEquals(1, outputFiles.length);    DataFileReader<ReflectStats> reader = new DataFileReader<>(new FsInput(outputFiles[0].getPath(), job.getConfiguration()), new ReflectDatumReader<>());    Map<String, Integer> counts = new HashMap<>();    for (ReflectStats record : reader) {        counts.put(record.name, record.count);    }    reader.close();    Assert.assertEquals(3, counts.get("apple").intValue());    Assert.assertEquals(2, counts.get("banana").intValue());    Assert.assertEquals(1, counts.get("carrot").intValue());}
aa30cfa9211430ed3b2d0cadb1bf132fa88d9c58956792d206f49b56d01615be
testAvroInput
public void testAvroInput() throws Exception
{    Job job = Job.getInstance();    FileInputFormat.setInputPaths(job, new Path(getClass().getResource("/org/apache/avro/mapreduce/mapreduce-test-input.avro").toURI().toString()));    job.setInputFormatClass(AvroKeyInputFormat.class);    AvroJob.setInputKeySchema(job, TextStats.SCHEMA$);    job.setMapperClass(StatCountMapper.class);    job.setMapOutputKeyClass(Text.class);    job.setMapOutputValueClass(IntWritable.class);    job.setReducerClass(SpecificStatsReducer.class);    AvroJob.setOutputKeySchema(job, TextStats.SCHEMA$);    job.setOutputFormatClass(AvroKeyOutputFormat.class);    Path outputPath = new Path(tmpFolder.getRoot().getPath() + "/out-specific-input");    FileOutputFormat.setOutputPath(job, outputPath);    Assert.assertTrue(job.waitForCompletion(true));        FileSystem fileSystem = FileSystem.get(job.getConfiguration());    FileStatus[] outputFiles = fileSystem.globStatus(outputPath.suffix("/part-*"));    Assert.assertEquals(1, outputFiles.length);    DataFileReader<TextStats> reader = new DataFileReader<>(new FsInput(outputFiles[0].getPath(), job.getConfiguration()), new SpecificDatumReader<>());    Map<String, Integer> counts = new HashMap<>();    for (TextStats record : reader) {        counts.put(record.getName().toString(), record.getCount());    }    reader.close();    Assert.assertEquals(3, counts.get("apple").intValue());    Assert.assertEquals(2, counts.get("banana").intValue());    Assert.assertEquals(1, counts.get("carrot").intValue());}
7857806eb7234dd7609f78c1f5f5e6ecf2da0516d7a2803aeae9372bd0385391
testReflectInput
public void testReflectInput() throws Exception
{    Job job = Job.getInstance();    FileInputFormat.setInputPaths(job, new Path(getClass().getResource("/org/apache/avro/mapreduce/mapreduce-test-input.avro").toURI().toString()));    job.setInputFormatClass(AvroKeyInputFormat.class);    AvroJob.setInputKeySchema(job, REFLECT_STATS_SCHEMA);    job.setMapperClass(ReflectCountMapper.class);    job.setMapOutputKeyClass(Text.class);    job.setMapOutputValueClass(IntWritable.class);    job.setReducerClass(ReflectStatsReducer.class);    AvroJob.setOutputKeySchema(job, REFLECT_STATS_SCHEMA);    job.setOutputFormatClass(AvroKeyOutputFormat.class);    Path outputPath = new Path(tmpFolder.getRoot().getPath() + "/out-reflect-input");    FileOutputFormat.setOutputPath(job, outputPath);    Assert.assertTrue(job.waitForCompletion(true));        FileSystem fileSystem = FileSystem.get(job.getConfiguration());    FileStatus[] outputFiles = fileSystem.globStatus(outputPath.suffix("/part-*"));    Assert.assertEquals(1, outputFiles.length);    DataFileReader<ReflectStats> reader = new DataFileReader<>(new FsInput(outputFiles[0].getPath(), job.getConfiguration()), new ReflectDatumReader<>());    Map<String, Integer> counts = new HashMap<>();    for (ReflectStats record : reader) {        counts.put(record.name, record.count);    }    reader.close();    Assert.assertEquals(3, counts.get("apple").intValue());    Assert.assertEquals(2, counts.get("banana").intValue());    Assert.assertEquals(1, counts.get("carrot").intValue());}
51c81b22b111cee5fa7e5a00df886b5cc45830dfde064b7eef277da2e33c8525
testAvroMapOutput
public void testAvroMapOutput() throws Exception
{    Job job = Job.getInstance();    FileInputFormat.setInputPaths(job, new Path(getClass().getResource("/org/apache/avro/mapreduce/mapreduce-test-input.avro").toURI().toString()));    job.setInputFormatClass(AvroKeyInputFormat.class);    AvroJob.setInputKeySchema(job, TextStats.SCHEMA$);    job.setMapperClass(SortMapper.class);    AvroJob.setMapOutputKeySchema(job, TextStats.SCHEMA$);    job.setMapOutputValueClass(NullWritable.class);    job.setReducerClass(SortReducer.class);    AvroJob.setOutputKeySchema(job, TextStats.SCHEMA$);    job.setOutputFormatClass(AvroKeyOutputFormat.class);    Path outputPath = new Path(tmpFolder.getRoot().getPath() + "/out-specific-input");    FileOutputFormat.setOutputPath(job, outputPath);    Assert.assertTrue(job.waitForCompletion(true));        FileSystem fileSystem = FileSystem.get(job.getConfiguration());    FileStatus[] outputFiles = fileSystem.globStatus(outputPath.suffix("/part-*"));    Assert.assertEquals(1, outputFiles.length);    DataFileReader<TextStats> reader = new DataFileReader<>(new FsInput(outputFiles[0].getPath(), job.getConfiguration()), new SpecificDatumReader<>());    Map<String, Integer> counts = new HashMap<>();    for (TextStats record : reader) {        counts.put(record.getName().toString(), record.getCount());    }    reader.close();    Assert.assertEquals(3, counts.get("apple").intValue());    Assert.assertEquals(2, counts.get("banana").intValue());    Assert.assertEquals(1, counts.get("carrot").intValue());}
b0284dd9b87746f88a5a4e5ca62231c320943b5eecc2f4a7dd0a60c21c979c83
testAvroUsingTextFileOutput
public void testAvroUsingTextFileOutput() throws Exception
{    Job job = Job.getInstance();    FileInputFormat.setInputPaths(job, new Path(getClass().getResource("/org/apache/avro/mapreduce/mapreduce-test-input.txt").toURI().toString()));    job.setInputFormatClass(TextInputFormat.class);    job.setMapperClass(LineCountMapper.class);    job.setMapOutputKeyClass(Text.class);    job.setMapOutputValueClass(IntWritable.class);    job.setReducerClass(AvroSumReducer.class);    AvroJob.setOutputKeySchema(job, Schema.create(Schema.Type.STRING));    AvroJob.setOutputValueSchema(job, Schema.create(Schema.Type.INT));    job.setOutputFormatClass(TextOutputFormat.class);    Path outputPath = new Path(tmpFolder.getRoot().getPath() + "/out-text");    FileOutputFormat.setOutputPath(job, outputPath);    Assert.assertTrue(job.waitForCompletion(true));        FileSystem fileSystem = FileSystem.get(job.getConfiguration());    FileStatus[] outputFiles = fileSystem.globStatus(outputPath.suffix("/part-*"));    Assert.assertEquals(1, outputFiles.length);    Path filePath = outputFiles[0].getPath();    InputStream inputStream = filePath.getFileSystem(job.getConfiguration()).open(filePath);    Assert.assertNotNull(inputStream);    try (BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream))) {        Assert.assertTrue(reader.ready());        Assert.assertEquals("apple\t3", reader.readLine());        Assert.assertEquals("banana\t2", reader.readLine());        Assert.assertEquals("carrot\t1", reader.readLine());        Assert.assertFalse(reader.ready());    }}
9dfd01bdc27f4a0ac52783caa31f4d39c1e30f02aa0bad0c24e951b2137a8aee
execute
public void execute() throws MojoExecutionException
{    boolean hasSourceDir = null != sourceDirectory && sourceDirectory.isDirectory();    boolean hasImports = null != imports;    boolean hasTestDir = null != testSourceDirectory && testSourceDirectory.isDirectory();    if (!hasSourceDir && !hasTestDir) {        throw new MojoExecutionException("neither sourceDirectory: " + sourceDirectory + " or testSourceDirectory: " + testSourceDirectory + " are directories");    }    if (hasImports) {        for (String importedFile : imports) {            File file = new File(importedFile);            if (file.isDirectory()) {                String[] includedFiles = getIncludedFiles(file.getAbsolutePath(), excludes, getIncludes());                getLog().info("Importing Directory: " + file.getAbsolutePath());                getLog().debug("Importing Directory Files: " + Arrays.toString(includedFiles));                compileFiles(includedFiles, file, outputDirectory);            } else if (file.isFile()) {                getLog().info("Importing File: " + file.getAbsolutePath());                compileFiles(new String[] { file.getName() }, file.getParentFile(), outputDirectory);            }        }    }    if (hasSourceDir) {        String[] includedFiles = getIncludedFiles(sourceDirectory.getAbsolutePath(), excludes, getIncludes());        compileFiles(includedFiles, sourceDirectory, outputDirectory);    }    if (hasImports || hasSourceDir) {        project.addCompileSourceRoot(outputDirectory.getAbsolutePath());    }    if (hasTestDir) {        String[] includedFiles = getIncludedFiles(testSourceDirectory.getAbsolutePath(), testExcludes, getTestIncludes());        compileFiles(includedFiles, testSourceDirectory, testOutputDirectory);        project.addTestCompileSourceRoot(testOutputDirectory.getAbsolutePath());    }}
80b7e1b054f963449c529f4c8bd21d47b471de7c27974c448b6e1f902a80b6a4
getIncludedFiles
private String[] getIncludedFiles(String absPath, String[] excludes, String[] includes)
{    final FileSetManager fileSetManager = new FileSetManager();    final FileSet fs = new FileSet();    fs.setDirectory(absPath);    fs.setFollowSymlinks(false);        if (imports != null) {        String importExclude = null;        for (String importFile : this.imports) {            File file = new File(importFile);            if (file.isDirectory()) {                importExclude = file.getName() + "/**";            } else if (file.isFile()) {                importExclude = "**/" + file.getName();            }            fs.addExclude(importExclude);        }    }    for (String include : includes) {        fs.addInclude(include);    }    for (String exclude : excludes) {        fs.addExclude(exclude);    }    return fileSetManager.getIncludedFiles(fs);}
f0614c6e8921f940b1ba0c9b51ea3ca7ca8f7bfbab8acd7748c79dd297aa54fb
compileFiles
private void compileFiles(String[] files, File sourceDir, File outDir) throws MojoExecutionException
{    for (String filename : files) {        try {            doCompile(filename, sourceDir, outDir);        } catch (IOException e) {            throw new MojoExecutionException("Error compiling protocol file " + filename + " to " + outDir, e);        }    }}
b02e94e2017db1ce23027c81624e868889fadf77fcb7e8b65e04f504979d6737
getFieldVisibility
protected SpecificCompiler.FieldVisibility getFieldVisibility()
{    try {        String upper = String.valueOf(this.fieldVisibility).trim().toUpperCase();        return SpecificCompiler.FieldVisibility.valueOf(upper);    } catch (IllegalArgumentException e) {        return SpecificCompiler.FieldVisibility.PRIVATE;    }}
6f77e2edbd7113b5fd7dc47fba262f897b01dbce87f3120bf9275454afc9f21e
instantiateAdditionalVelocityTools
protected List<Object> instantiateAdditionalVelocityTools()
{    final List<Object> velocityTools = new ArrayList<>(velocityToolsClassesNames.length);    for (String velocityToolClassName : velocityToolsClassesNames) {        try {            Class klass = Class.forName(velocityToolClassName);            velocityTools.add(klass.newInstance());        } catch (Exception e) {            throw new RuntimeException(e);        }    }    return velocityTools;}
b92420be2b274f63b1aa737eeb0be35ccd27c5eae7c9becc29b6d9365530dfb2
createClassLoader
protected URLClassLoader createClassLoader() throws DependencyResolutionRequiredException, MalformedURLException
{    final List<URL> urls = appendElements(project.getRuntimeClasspathElements());    urls.addAll(appendElements(project.getTestClasspathElements()));    return new URLClassLoader(urls.toArray(new URL[0]), Thread.currentThread().getContextClassLoader());}
490262721082d75f0a2675edafdd67d2cf9be5b7ec40979391e220d3b156fa44
appendElements
private List<URL> appendElements(List runtimeClasspathElements) throws MalformedURLException
{    List<URL> runtimeUrls = new ArrayList<>();    if (runtimeClasspathElements != null) {        for (Object runtimeClasspathElement : runtimeClasspathElements) {            String element = (String) runtimeClasspathElement;            runtimeUrls.add(new File(element).toURI().toURL());        }    }    return runtimeUrls;}
031eae21beebb3ce8313a1dff63533d830910b27d3783b419510ae32d2fc8eb4
doCompile
protected void doCompile(String filename, File sourceDirectory, File outputDirectory) throws IOException
{    try {        @SuppressWarnings("rawtypes")        List runtimeClasspathElements = project.getRuntimeClasspathElements();        List<URL> runtimeUrls = new ArrayList<>();                        runtimeUrls.add(sourceDirectory.toURI().toURL());                if (runtimeClasspathElements != null && !runtimeClasspathElements.isEmpty()) {            for (Object runtimeClasspathElement : runtimeClasspathElements) {                String element = (String) runtimeClasspathElement;                runtimeUrls.add(new File(element).toURI().toURL());            }        }        URLClassLoader projPathLoader = new URLClassLoader(runtimeUrls.toArray(new URL[0]), Thread.currentThread().getContextClassLoader());        try (Idl parser = new Idl(new File(sourceDirectory, filename), projPathLoader)) {            Protocol p = parser.CompilationUnit();            String json = p.toString(true);            Protocol protocol = Protocol.parse(json);            final SpecificCompiler compiler = new SpecificCompiler(protocol);            compiler.setStringType(GenericData.StringType.valueOf(stringType));            compiler.setTemplateDir(templateDirectory);            compiler.setFieldVisibility(getFieldVisibility());            compiler.setCreateOptionalGetters(createOptionalGetters);            compiler.setGettersReturnOptional(gettersReturnOptional);            compiler.setCreateSetters(createSetters);            compiler.setAdditionalVelocityTools(instantiateAdditionalVelocityTools());            compiler.setEnableDecimalLogicalType(enableDecimalLogicalType);            for (String customConversion : customConversions) {                compiler.addCustomConversion(projPathLoader.loadClass(customConversion));            }            compiler.setOutputCharacterEncoding(project.getProperties().getProperty("project.build.sourceEncoding"));            compiler.compileToDestination(null, outputDirectory);        }    } catch (ParseException | ClassNotFoundException | DependencyResolutionRequiredException e) {        throw new IOException(e);    }}
359196038ff2ea61b238f2e01c456a9766e28d6edb38961ede368bea072f82fd
getIncludes
protected String[] getIncludes()
{    return includes;}
4f5e3c3a892b438d0a87fb550f0a1cc4d66c3b6cc0978522cb9cffbabf1f8448
getTestIncludes
protected String[] getTestIncludes()
{    return testIncludes;}
9dfd01bdc27f4a0ac52783caa31f4d39c1e30f02aa0bad0c24e951b2137a8aee
execute
public void execute() throws MojoExecutionException
{    classLoader = getClassLoader();    reflectData = getReflectData();    if (encoding == null) {        encoding = Charset.defaultCharset().name();        getLog().warn("Property project.build.sourceEncoding not set, using system default " + encoding);    }    for (File sourceDirectory : javaSourceDirectories) {        induceClasses(sourceDirectory);    }}
cbd0a93b7638bca982529cb64e45c1ccf3a7aa9ae93ade0ab47f59484fce968a
induceClasses
private void induceClasses(File sourceDirectory) throws MojoExecutionException
{    File[] files = sourceDirectory.listFiles();    if (files == null) {        throw new MojoExecutionException("Unable to list files from directory: " + sourceDirectory.getName());    }    for (File inputFile : files) {        if (inputFile.isDirectory()) {            induceClasses(inputFile);            continue;        }        String className = parseClassName(inputFile.getPath());        if (className == null) {                        continue;        }        Class<?> klass = loadClass(classLoader, className);        String fileName = getOutputFileName(klass);        File outputFile = new File(fileName);        outputFile.getParentFile().mkdirs();        try (PrintWriter writer = new PrintWriter(fileName, encoding)) {            if (klass.isInterface()) {                writer.println(reflectData.getProtocol(klass).toString(true));            } else {                writer.println(reflectData.getSchema(klass).toString(true));            }        } catch (AvroRuntimeException e) {            throw new MojoExecutionException("Failed to resolve schema or protocol for class " + klass.getCanonicalName(), e);        } catch (Exception e) {            throw new MojoExecutionException("Failed to write output file for class " + klass.getCanonicalName(), e);        }    }}
b21a2568da9024adf3975cf843488f9346d41e244fc303e3ce4648ba2b5f6e83
parseClassName
private String parseClassName(String fileName)
{    String indentifier = "java" + File.separator;    int index = fileName.lastIndexOf(indentifier);    String namespacedFileName = fileName.substring(index + indentifier.length());    if (!namespacedFileName.endsWith(".java")) {        return null;    }    return namespacedFileName.replace(File.separator, ".").replaceFirst("\\.java$", "");}
77e48bc3650ab28ecbea7750a3133aef0f87d897322de3cbb52ac798210e0ee9
getOutputFileName
private String getOutputFileName(Class klass)
{    String filename = avroOutputDirectory.getPath() + File.separator + klass.getName().replace(".", File.separator);    if (klass.isInterface()) {        return filename.concat(".avpr");    } else {        return filename.concat(".avsc");    }}
3c36c096e07de85849ca0f879c7e95e951559e29793e36fb252932d0f80b618f
getReflectData
private ReflectData getReflectData() throws MojoExecutionException
{    if (reflectDataImplementation == null) {        return allowNull ? ReflectData.AllowNull.get() : ReflectData.get();    }    try {        Constructor<? extends ReflectData> constructor = loadClass(classLoader, reflectDataImplementation).asSubclass(ReflectData.class).getConstructor();        constructor.setAccessible(true);        return constructor.newInstance();    } catch (Exception e) {        throw new MojoExecutionException(String.format("Could not load ReflectData custom implementation %s. Make sure that it has a no-args constructor", reflectDataImplementation), e);    }}
9f7719af612bac2306658fc25377f68de9a809d507c3074baf14e57a30a06025
loadClass
private Class<?> loadClass(ClassLoader classLoader, String className) throws MojoExecutionException
{    try {        return classLoader.loadClass(className);    } catch (ClassNotFoundException e) {        throw new MojoExecutionException("Failed to load class " + className, e);    }}
b82cf7716934f03191fa22797d56457604cff5a84859c5a3249657e64310fc05
getClassLoader
private ClassLoader getClassLoader() throws MojoExecutionException
{    ClassLoader classLoader;    try {        List<String> classpathElements = project.getRuntimeClasspathElements();        if (null == classpathElements) {            return Thread.currentThread().getContextClassLoader();        }        URL[] urls = new URL[classpathElements.size()];        for (int i = 0; i < classpathElements.size(); ++i) {            urls[i] = new File(classpathElements.get(i)).toURI().toURL();        }        classLoader = new URLClassLoader(urls, getClass().getClassLoader());    } catch (Exception e) {        throw new MojoExecutionException("Failed to obtain ClassLoader", e);    }    return classLoader;}
031eae21beebb3ce8313a1dff63533d830910b27d3783b419510ae32d2fc8eb4
doCompile
protected void doCompile(String filename, File sourceDirectory, File outputDirectory) throws IOException
{    final File src = new File(sourceDirectory, filename);    final Protocol protocol = Protocol.parse(src);    final SpecificCompiler compiler = new SpecificCompiler(protocol);    compiler.setTemplateDir(templateDirectory);    compiler.setStringType(StringType.valueOf(stringType));    compiler.setFieldVisibility(getFieldVisibility());    compiler.setCreateOptionalGetters(createOptionalGetters);    compiler.setGettersReturnOptional(gettersReturnOptional);    compiler.setCreateSetters(createSetters);    compiler.setAdditionalVelocityTools(instantiateAdditionalVelocityTools());    compiler.setEnableDecimalLogicalType(enableDecimalLogicalType);    final URLClassLoader classLoader;    try {        classLoader = createClassLoader();        for (String customConversion : customConversions) {            compiler.addCustomConversion(classLoader.loadClass(customConversion));        }    } catch (DependencyResolutionRequiredException | ClassNotFoundException e) {        throw new IOException(e);    }    compiler.setOutputCharacterEncoding(project.getProperties().getProperty("project.build.sourceEncoding"));    compiler.compileToDestination(src, outputDirectory);}
359196038ff2ea61b238f2e01c456a9766e28d6edb38961ede368bea072f82fd
getIncludes
protected String[] getIncludes()
{    return includes;}
4f5e3c3a892b438d0a87fb550f0a1cc4d66c3b6cc0978522cb9cffbabf1f8448
getTestIncludes
protected String[] getTestIncludes()
{    return testIncludes;}
031eae21beebb3ce8313a1dff63533d830910b27d3783b419510ae32d2fc8eb4
doCompile
protected void doCompile(String filename, File sourceDirectory, File outputDirectory) throws IOException
{    File src = new File(sourceDirectory, filename);    final Schema schema;        if (imports == null) {        schema = new Schema.Parser().parse(src);    } else {        schema = schemaParser.parse(src);    }    final SpecificCompiler compiler = new SpecificCompiler(schema);    compiler.setTemplateDir(templateDirectory);    compiler.setStringType(StringType.valueOf(stringType));    compiler.setFieldVisibility(getFieldVisibility());    compiler.setCreateOptionalGetters(createOptionalGetters);    compiler.setGettersReturnOptional(gettersReturnOptional);    compiler.setCreateSetters(createSetters);    compiler.setEnableDecimalLogicalType(enableDecimalLogicalType);    try {        final URLClassLoader classLoader = createClassLoader();        for (String customConversion : customConversions) {            compiler.addCustomConversion(classLoader.loadClass(customConversion));        }    } catch (ClassNotFoundException | DependencyResolutionRequiredException e) {        throw new IOException(e);    }    compiler.setOutputCharacterEncoding(project.getProperties().getProperty("project.build.sourceEncoding"));    compiler.setAdditionalVelocityTools(instantiateAdditionalVelocityTools());    compiler.compileToDestination(src, outputDirectory);}
359196038ff2ea61b238f2e01c456a9766e28d6edb38961ede368bea072f82fd
getIncludes
protected String[] getIncludes()
{    return includes;}
4f5e3c3a892b438d0a87fb550f0a1cc4d66c3b6cc0978522cb9cffbabf1f8448
getTestIncludes
protected String[] getTestIncludes()
{    return testIncludes;}
26a0331a24c03c828018e317812b10eb3777313f83cb980b39b64dc28c386bff
setUp
protected void setUp() throws Exception
{    super.setUp();}
68bbf6c94fbad4862990669ea582b65c28678087c2377b2c3fb0948d54293af4
tearDown
protected void tearDown() throws Exception
{    super.tearDown();}
7f7d20c1cc6529fa3340a71467396d5bed5c83ef6d62793ccf4e54447a3b8aed
assertFilesExist
 void assertFilesExist(File directory, Set<String> expectedFiles)
{    assertNotNull(directory);    assertTrue("Directory " + directory.toString() + " does not exists", directory.exists());    assertNotNull(expectedFiles);    assertTrue(expectedFiles.size() > 0);    final Set<String> filesInDirectory = new HashSet<>(Arrays.asList(directory.list()));    assertEquals(expectedFiles, filesInDirectory);}
c7cce9ba98098e34016bd3d2a7e59814521442b12a7412db0eecf939bae8c2af
testIdlProtocolMojo
public void testIdlProtocolMojo() throws Exception
{    final IDLProtocolMojo mojo = (IDLProtocolMojo) lookupMojo("idl-protocol", testPom);    assertNotNull(mojo);    mojo.execute();    final File outputDir = new File(getBasedir(), "target/test-harness/idl/test/");    final Set<String> generatedFiles = new HashSet<>(Arrays.asList("IdlPrivacy.java", "IdlTest.java", "IdlUser.java", "IdlUserWrapper.java", "IdlClasspathImportTest.java"));    assertFilesExist(outputDir, generatedFiles);    final String idlUserContent = FileUtils.fileRead(new File(outputDir, "IdlUser.java"));    assertTrue(idlUserContent.contains("java.time.Instant"));}
f651c8c493307829727c2dc71ff725b80ce937d5e76e71d6306d2ab0c09470ae
testSetCompilerVelocityAdditionalTools
public void testSetCompilerVelocityAdditionalTools() throws Exception
{    final IDLProtocolMojo mojo = (IDLProtocolMojo) lookupMojo("idl-protocol", injectingVelocityToolsTestPom);    assertNotNull(mojo);    mojo.execute();    final File outputDir = new File(getBasedir(), "target/test-harness/idl-inject/test");    final Set<String> generatedFiles = new HashSet<>(Arrays.asList("IdlPrivacy.java", "IdlTest.java", "IdlUser.java", "IdlUserWrapper.java", "IdlClasspathImportTest.java"));    assertFilesExist(outputDir, generatedFiles);    final String schemaUserContent = FileUtils.fileRead(new File(outputDir, "IdlUser.java"));    assertTrue(schemaUserContent.contains("It works!"));}
26a0331a24c03c828018e317812b10eb3777313f83cb980b39b64dc28c386bff
setUp
protected void setUp() throws Exception
{    String baseDir = getBasedir();    schemaPom = new File(baseDir, "src/test/resources/unit/schema/induce-pom.xml");    protocolPom = new File(baseDir, "src/test/resources/unit/protocol/induce-pom.xml");    super.setUp();}
68bbf6c94fbad4862990669ea582b65c28678087c2377b2c3fb0948d54293af4
tearDown
protected void tearDown() throws Exception
{    super.tearDown();}
6b4d3fea15bfd59928a286f787d7aed8242c3dc534f352a771ba6b4ebe05f06d
testInduceMojoExists
public void testInduceMojoExists() throws Exception
{    InduceMojo mojo = (InduceMojo) lookupMojo("induce", schemaPom);    assertNotNull(mojo);}
9e7671e9e08c11ce4d62de1e9eb2ce1edcfccbd4c5b7bcf39ca4a9f97a13f431
testInduceSchema
public void testInduceSchema() throws Exception
{    executeMojo(schemaPom);    File outputDir = new File(getBasedir(), "target/test-harness/schemas/org/apache/avro/entities");    assertTrue(outputDir.listFiles().length != 0);    File personSchemaFile = Arrays.stream(outputDir.listFiles()).filter(file -> file.getName().endsWith("Person.avsc")).findFirst().orElseThrow(AssertionError::new);    assertEquals(ReflectData.get().getSchema(Person.class), new Schema.Parser().parse(personSchemaFile));}
e799b7feb9027203424cde315dce747a93e690ea79bc4e087faed56171efa759
testInducedSchemasFileExtension
public void testInducedSchemasFileExtension() throws Exception
{    executeMojo(schemaPom);    File outputDir = new File(getBasedir(), "target/test-harness/schemas/org/apache/avro/entities");    for (File file : outputDir.listFiles()) {        assertTrue(file.getName().contains(".avsc"));    }}
2b5717040a51dac94043401063a5db3bee515a94a8a87e6f068135c2f40eab49
testInduceProtocol
public void testInduceProtocol() throws Exception
{    executeMojo(protocolPom);    File outputDir = new File(getBasedir(), "target/test-harness/protocol/org/apache/avro/protocols");    assertTrue(outputDir.listFiles().length != 0);    File remoteProtocolFile = Arrays.stream(outputDir.listFiles()).filter(file -> file.getName().endsWith("Remote.avpr")).findFirst().orElseThrow(AssertionError::new);    assertEquals(ReflectData.get().getProtocol(Remote.class), Protocol.parse(remoteProtocolFile));}
feb3751f42ddc48ea2e99238492c39d5886f09afe48663bb60c1f5ad0f0741e3
testInducedProtocolsFileExtension
public void testInducedProtocolsFileExtension() throws Exception
{    executeMojo(protocolPom);    File outputDir = new File(getBasedir(), "target/test-harness/protocol/org/apache/avro/protocols");    for (File file : outputDir.listFiles()) {        assertTrue(file.getName().contains(".avpr"));    }}
42e0187a5fc6599745682e4311282fa0d00dcb113dbfe76466ea7db6979f98d6
executeMojo
private void executeMojo(File pom) throws Exception
{    InduceMojo mojo = (InduceMojo) lookupMojo("induce", pom);    mojo.execute();}
6a07c4f5c26ab1cf6f63ce87863fea69c066ab9910a52b5a558a1cd9710c8a84
testProtocolMojo
public void testProtocolMojo() throws Exception
{    final ProtocolMojo mojo = (ProtocolMojo) lookupMojo("protocol", testPom);    assertNotNull(mojo);    mojo.execute();    final File outputDir = new File(getBasedir(), "target/test-harness/protocol/test");    final Set<String> generatedFiles = new HashSet<>(Arrays.asList("ProtocolPrivacy.java", "ProtocolTest.java", "ProtocolUser.java"));    assertFilesExist(outputDir, generatedFiles);    final String protocolUserContent = FileUtils.fileRead(new File(outputDir, "ProtocolUser.java"));    assertTrue("Got " + protocolUserContent + " instead", protocolUserContent.contains("java.time.Instant"));}
f651c8c493307829727c2dc71ff725b80ce937d5e76e71d6306d2ab0c09470ae
testSetCompilerVelocityAdditionalTools
public void testSetCompilerVelocityAdditionalTools() throws Exception
{    ProtocolMojo mojo = (ProtocolMojo) lookupMojo("protocol", injectingVelocityToolsTestPom);    assertNotNull(mojo);    mojo.execute();    File outputDir = new File(getBasedir(), "target/test-harness/protocol-inject/test");    final Set<String> generatedFiles = new HashSet<>(Arrays.asList("ProtocolPrivacy.java", "ProtocolTest.java", "ProtocolUser.java"));    assertFilesExist(outputDir, generatedFiles);    String schemaUserContent = FileUtils.fileRead(new File(outputDir, "ProtocolUser.java"));    assertTrue(schemaUserContent.contains("It works!"));}
0b405ec3a9a5df0914780a3b2efe4cf48e6f1e378fd3465ff337032432cb4466
testSchemaMojo
public void testSchemaMojo() throws Exception
{    final SchemaMojo mojo = (SchemaMojo) lookupMojo("schema", testPom);    assertNotNull(mojo);    mojo.execute();    final File outputDir = new File(getBasedir(), "target/test-harness/schema/test");    final Set<String> generatedFiles = new HashSet<>(Arrays.asList("PrivacyDirectImport.java", "PrivacyImport.java", "SchemaPrivacy.java", "SchemaUser.java"));    assertFilesExist(outputDir, generatedFiles);    final String schemaUserContent = FileUtils.fileRead(new File(outputDir, "SchemaUser.java"));    assertTrue(schemaUserContent.contains("java.time.Instant"));}
f651c8c493307829727c2dc71ff725b80ce937d5e76e71d6306d2ab0c09470ae
testSetCompilerVelocityAdditionalTools
public void testSetCompilerVelocityAdditionalTools() throws Exception
{    final SchemaMojo mojo = (SchemaMojo) lookupMojo("schema", injectingVelocityToolsTestPom);    assertNotNull(mojo);    mojo.execute();    final File outputDir = new File(getBasedir(), "target/test-harness/schema-inject/test");    final Set<String> generatedFiles = new HashSet<>(Arrays.asList("PrivacyDirectImport.java", "PrivacyImport.java", "SchemaPrivacy.java", "SchemaUser.java"));    assertFilesExist(outputDir, generatedFiles);    final String schemaUserContent = FileUtils.fileRead(new File(outputDir, "SchemaUser.java"));    assertTrue("Got " + schemaUserContent + " instead", schemaUserContent.contains("It works!"));}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    Options options = new Options();    options.addOption(Option.builder().argName("measurementIterations").longOpt("mi").hasArg().desc("The number of measure iterations").numberOfArgs(1).build());    options.addOption(Option.builder().argName("warmupIterations").longOpt("wi").hasArg().desc("The number of warmup iterations").numberOfArgs(1).build());    options.addOption(Option.builder().argName("bulkWarmup").longOpt("bw").desc("Flag to enabled bulk warmup").build());    options.addOption(Option.builder().argName("test").longOpt("test").hasArg().desc("The performance tests to run").build());    options.addOption(Option.builder().argName("help").longOpt("help").desc("Print the help menu").build());    final CommandLine cmd = new DefaultParser().parse(options, args);    if (cmd.hasOption("help")) {        final HelpFormatter formatter = new HelpFormatter();        final PrintWriter pw = new PrintWriter(System.out);        formatter.printUsage(pw, 80, "Perf", options);        pw.flush();        return;    }    String[] tests = cmd.getOptionValues("test");    if (tests == null || tests.length == 0) {        tests = new String[] { Perf.class.getPackage().getName() + ".*" };    }    final Integer measurementIterations = Integer.valueOf(cmd.getOptionValue("mi", "3"));    final Integer warmupIterations = Integer.valueOf(cmd.getOptionValue("wi", "3"));    final ChainedOptionsBuilder runOpt = new OptionsBuilder().mode(Mode.Throughput).timeout(TimeValue.seconds(60)).warmupIterations(warmupIterations).measurementIterations(measurementIterations).forks(1).threads(1).shouldDoGC(true);    if (cmd.hasOption("builkWarmup")) {        runOpt.warmupMode(WarmupMode.BULK);    }    for (final String test : tests) {        runOpt.include(test);    }    new Runner(runOpt.build()).run();}
bc4354ca01ab236c3cec38efc2412c89c3d70f433d3e30b78d8bcb667c687c18
encode
public void encode(final TestStateEncode state) throws Exception
{    final Encoder e = state.encoder;    final int items = state.getBatchSize() / 4;    e.writeArrayStart();    e.setItemCount(1);    e.startItem();    e.writeArrayStart();    e.setItemCount(items);    for (int i = 0; i < state.getBatchSize(); i += 4) {        e.startItem();        e.writeFloat(state.testData[i + 0]);        e.writeFloat(state.testData[i + 1]);        e.writeFloat(state.testData[i + 2]);        e.writeFloat(state.testData[i + 3]);    }    e.writeArrayEnd();    e.writeArrayEnd();}
3c1a379ee49f0b942d99caa9f39c4854c09a6725a185862e62d0bbb0b0cddc3b
decode
public float decode(final TestStateDecode state) throws Exception
{    final Decoder d = state.decoder;    float total = 0.0f;    d.readArrayStart();    for (long i = d.readArrayStart(); i != 0; i = d.arrayNext()) {        for (long j = 0; j < i; j++) {            total += d.readFloat();            total += d.readFloat();            total += d.readFloat();            total += d.readFloat();        }    }    d.arrayNext();    return total;}
1ca494ee3660d56a2bbe91018cb7d611c697df8b9133bb51d1ff482a95a852b4
doSetupTrial
public void doSetupTrial() throws Exception
{    this.encoder = super.newEncoder(false, getNullOutputStream());    this.testData = new float[getBatchSize()];    for (int i = 0; i < testData.length; i++) {        testData[i] = super.getRandom().nextFloat();    }}
18468f08d7a641120aaa17be317bdaefa1ba52389a2509cff459e16edccabe84
doSetupTrial
public void doSetupTrial() throws IOException
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    Encoder encoder = super.newEncoder(true, baos);    final int items = getBatchSize() / 4;    encoder.writeArrayStart();    encoder.setItemCount(1);    encoder.startItem();    encoder.writeArrayStart();    encoder.setItemCount(items);    for (int i = 0; i < getBatchSize(); i += 4) {        encoder.startItem();        encoder.writeFloat(super.getRandom().nextFloat());        encoder.writeFloat(super.getRandom().nextFloat());        encoder.writeFloat(super.getRandom().nextFloat());        encoder.writeFloat(super.getRandom().nextFloat());    }    encoder.writeArrayEnd();    encoder.writeArrayEnd();    this.testData = baos.toByteArray();}
773b72d34e2409988c4e6b4b91b97385f6d566ddabba16dd713e2891700d9130
doSetupInvocation
public void doSetupInvocation() throws Exception
{    this.decoder = super.newDecoder(this.testData);}
bc4354ca01ab236c3cec38efc2412c89c3d70f433d3e30b78d8bcb667c687c18
encode
public void encode(final TestStateEncode state) throws Exception
{    final Encoder e = state.encoder;    for (int i = 0; i < state.getBatchSize(); i += 4) {        e.writeBoolean(state.testData[i + 0]);        e.writeBoolean(state.testData[i + 1]);        e.writeBoolean(state.testData[i + 2]);        e.writeBoolean(state.testData[i + 3]);    }}
ef5b2155c9c3c383cb0090838424c303e227f680183dd2369b6f46d88a173a1d
decode
public boolean decode(final TestStateDecode state) throws Exception
{    final Decoder d = state.decoder;    boolean total = true;    for (int i = 0; i < state.getBatchSize(); i += 4) {        total ^= d.readBoolean();        total ^= d.readBoolean();        total ^= d.readBoolean();        total ^= d.readBoolean();    }    return total;}
1ca494ee3660d56a2bbe91018cb7d611c697df8b9133bb51d1ff482a95a852b4
doSetupTrial
public void doSetupTrial() throws Exception
{    this.encoder = super.newEncoder(false, getNullOutputStream());    this.testData = new boolean[getBatchSize()];    for (int i = 0; i < testData.length; i++) {        testData[i] = super.getRandom().nextBoolean();    }}
18468f08d7a641120aaa17be317bdaefa1ba52389a2509cff459e16edccabe84
doSetupTrial
public void doSetupTrial() throws IOException
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    Encoder encoder = super.newEncoder(true, baos);    for (int i = 0; i < getBatchSize(); i++) {        encoder.writeBoolean(super.getRandom().nextBoolean());    }    this.testData = baos.toByteArray();}
773b72d34e2409988c4e6b4b91b97385f6d566ddabba16dd713e2891700d9130
doSetupInvocation
public void doSetupInvocation() throws Exception
{    this.decoder = super.newDecoder(this.testData);}
bc4354ca01ab236c3cec38efc2412c89c3d70f433d3e30b78d8bcb667c687c18
encode
public void encode(final TestStateEncode state) throws Exception
{    final Encoder e = state.encoder;    for (int i = 0; i < state.getBatchSize(); i += 4) {        e.writeBytes(state.testData[i + 0]);        e.writeBytes(state.testData[i + 1]);        e.writeBytes(state.testData[i + 2]);        e.writeBytes(state.testData[i + 3]);    }}
77f73c02797e5973359b601d6f05dffe54609ed9f61035a1528e2eaa2e145ad7
decode
public ByteBuffer decode(final TestStateDecode state) throws Exception
{    final Decoder d = state.decoder;    for (int i = 0; i < state.getBatchSize(); i += 4) {        d.readBytes(state.bb);        d.readBytes(state.bb);        d.readBytes(state.bb);        d.readBytes(state.bb);    }    return state.bb;}
1ca494ee3660d56a2bbe91018cb7d611c697df8b9133bb51d1ff482a95a852b4
doSetupTrial
public void doSetupTrial() throws Exception
{    this.encoder = super.newEncoder(false, getNullOutputStream());    this.testData = new byte[getBatchSize()][];    for (int i = 0; i < testData.length; i++) {        final byte[] data = new byte[super.getRandom().nextInt(70)];        super.getRandom().nextBytes(data);        testData[i] = data;    }}
18468f08d7a641120aaa17be317bdaefa1ba52389a2509cff459e16edccabe84
doSetupTrial
public void doSetupTrial() throws IOException
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    Encoder encoder = super.newEncoder(true, baos);    for (int i = 0; i < getBatchSize(); i++) {        final byte[] data = new byte[super.getRandom().nextInt(70)];        super.getRandom().nextBytes(data);        encoder.writeBytes(data);    }    this.testData = baos.toByteArray();}
773b72d34e2409988c4e6b4b91b97385f6d566ddabba16dd713e2891700d9130
doSetupInvocation
public void doSetupInvocation() throws Exception
{    this.decoder = super.newDecoder(this.testData);}
bc4354ca01ab236c3cec38efc2412c89c3d70f433d3e30b78d8bcb667c687c18
encode
public void encode(final TestStateEncode state) throws Exception
{    final Encoder e = state.encoder;    for (int i = 0; i < state.getBatchSize(); i += 4) {        e.writeDouble(state.testData[i + 0]);        e.writeDouble(state.testData[i + 1]);        e.writeDouble(state.testData[i + 2]);        e.writeDouble(state.testData[i + 3]);    }}
c079fd7b15b7c49c80a3c6392e4a4ee217b7c6fdf2054e58eb16422d703da795
decode
public double decode(final TestStateDecode state) throws Exception
{    final Decoder d = state.decoder;    double total = 0;    for (int i = 0; i < state.getBatchSize(); i += 4) {        total += d.readDouble();        total += d.readDouble();        total += d.readDouble();        total += d.readDouble();    }    return total;}
1ca494ee3660d56a2bbe91018cb7d611c697df8b9133bb51d1ff482a95a852b4
doSetupTrial
public void doSetupTrial() throws Exception
{    this.encoder = super.newEncoder(false, getNullOutputStream());    this.testData = new double[getBatchSize()];    for (int i = 0; i < testData.length; i++) {        testData[i] = super.getRandom().nextDouble();    }}
18468f08d7a641120aaa17be317bdaefa1ba52389a2509cff459e16edccabe84
doSetupTrial
public void doSetupTrial() throws IOException
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    Encoder encoder = super.newEncoder(true, baos);    for (int i = 0; i < getBatchSize(); i++) {        encoder.writeDouble(super.getRandom().nextDouble());    }    this.testData = baos.toByteArray();}
773b72d34e2409988c4e6b4b91b97385f6d566ddabba16dd713e2891700d9130
doSetupInvocation
public void doSetupInvocation() throws Exception
{    this.decoder = super.newDecoder(this.testData);}
bc4354ca01ab236c3cec38efc2412c89c3d70f433d3e30b78d8bcb667c687c18
encode
public void encode(final TestStateEncode state) throws Exception
{    final Encoder e = state.encoder;    GenericDatumWriter<Object> writer = new GenericDatumWriter<>(state.schema);    for (int i = 0; i < state.getBatchSize(); i += 4) {        writer.write(state.testData[i + 0], e);        writer.write(state.testData[i + 1], e);        writer.write(state.testData[i + 2], e);        writer.write(state.testData[i + 3], e);    }}
373c42e543efdeeee0132a28bcb085fa2b1d28c1258305e987ddbb16c136eb83
decode
public void decode(final Blackhole blackHole, final TestStateDecode state) throws Exception
{    final Decoder d = state.decoder;    final GenericDatumReader<Object> reader = new GenericDatumReader<>(state.schema);    for (int i = 0; i < state.getBatchSize(); i++) {        final Object o = reader.read(null, d);        blackHole.consume(o);    }}
1ca494ee3660d56a2bbe91018cb7d611c697df8b9133bb51d1ff482a95a852b4
doSetupTrial
public void doSetupTrial() throws Exception
{    this.encoder = super.newEncoder(false, getNullOutputStream());    this.testData = new GenericRecord[getBatchSize()];    final Schema enumSchema = this.schema.getField("f").schema();    for (int i = 0; i < getBatchSize(); i++) {        final GenericRecord rec = new GenericData.Record(this.schema);        final int tag = super.getRandom().nextInt(2);        rec.put("f", GenericData.get().createEnum(enumSchema.getEnumSymbols().get(tag), enumSchema));        this.testData[i] = rec;    }}
cdd5424679d32f84df572be1e6d459b16657b6301ea760bb47e02e8cfb649b02
mkSchema
private String mkSchema(String subschema)
{    return ("{ \"type\": \"record\", \"name\": \"R\", \"fields\": [\n" + "{ \"name\": \"f\", \"type\": " + subschema + "}\n" + "] }");}
18468f08d7a641120aaa17be317bdaefa1ba52389a2509cff459e16edccabe84
doSetupTrial
public void doSetupTrial() throws IOException
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    Encoder encoder = super.newEncoder(true, baos);    final GenericDatumWriter<Object> writer = new GenericDatumWriter<>(this.schema);    final Schema enumSchema = this.schema.getField("f").schema();    for (int i = 0; i < getBatchSize(); i++) {        final GenericRecord rec = new GenericData.Record(this.schema);        final int tag = super.getRandom().nextInt(2);        rec.put("f", GenericData.get().createEnum(enumSchema.getEnumSymbols().get(tag), enumSchema));        writer.write(rec, encoder);    }    this.testData = baos.toByteArray();}
cdd5424679d32f84df572be1e6d459b16657b6301ea760bb47e02e8cfb649b02
mkSchema
private String mkSchema(String subschema)
{    return ("{ \"type\": \"record\", \"name\": \"R\", \"fields\": [\n" + "{ \"name\": \"f\", \"type\": " + subschema + "}\n" + "] }");}
773b72d34e2409988c4e6b4b91b97385f6d566ddabba16dd713e2891700d9130
doSetupInvocation
public void doSetupInvocation() throws Exception
{    this.decoder = super.newDecoder(this.testData);}
bc4354ca01ab236c3cec38efc2412c89c3d70f433d3e30b78d8bcb667c687c18
encode
public void encode(final TestStateEncode state) throws Exception
{    final Encoder e = state.encoder;    for (int i = 0; i < state.getBatchSize(); i += 4) {        e.writeFloat(state.testData[i + 0]);        e.writeFloat(state.testData[i + 1]);        e.writeFloat(state.testData[i + 2]);        e.writeFloat(state.testData[i + 3]);    }}
3c1a379ee49f0b942d99caa9f39c4854c09a6725a185862e62d0bbb0b0cddc3b
decode
public float decode(final TestStateDecode state) throws Exception
{    final Decoder d = state.decoder;    float total = 0.0f;    for (int i = 0; i < state.getBatchSize(); i += 4) {        total += d.readFloat();        total += d.readFloat();        total += d.readFloat();        total += d.readFloat();    }    return total;}
1ca494ee3660d56a2bbe91018cb7d611c697df8b9133bb51d1ff482a95a852b4
doSetupTrial
public void doSetupTrial() throws Exception
{    this.encoder = super.newEncoder(false, getNullOutputStream());    this.testData = new float[getBatchSize()];    for (int i = 0; i < testData.length; i++) {        testData[i] = super.getRandom().nextFloat();    }}
18468f08d7a641120aaa17be317bdaefa1ba52389a2509cff459e16edccabe84
doSetupTrial
public void doSetupTrial() throws IOException
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    Encoder encoder = super.newEncoder(true, baos);    for (int i = 0; i < getBatchSize(); i++) {        encoder.writeFloat(super.getRandom().nextFloat());    }    this.testData = baos.toByteArray();}
773b72d34e2409988c4e6b4b91b97385f6d566ddabba16dd713e2891700d9130
doSetupInvocation
public void doSetupInvocation() throws Exception
{    this.decoder = super.newDecoder(this.testData);}
bc4354ca01ab236c3cec38efc2412c89c3d70f433d3e30b78d8bcb667c687c18
encode
public void encode(final TestStateEncode state) throws Exception
{    final Encoder e = state.encoder;    for (int i = 0; i < state.getBatchSize(); i += 4) {        e.writeInt(state.testData[i + 0]);        e.writeInt(state.testData[i + 1]);        e.writeInt(state.testData[i + 2]);        e.writeInt(state.testData[i + 3]);    }}
e0df16f37db84f0d8b2ba7ab8c283c1ea25492612f328164a034e403453fbf68
decode
public int decode(final TestStateDecode state) throws Exception
{    final Decoder d = state.decoder;    int total = 0;    for (int i = 0; i < state.getBatchSize(); i += 4) {        total += d.readInt();        total += d.readInt();        total += d.readInt();        total += d.readInt();    }    return total;}
1ca494ee3660d56a2bbe91018cb7d611c697df8b9133bb51d1ff482a95a852b4
doSetupTrial
public void doSetupTrial() throws Exception
{    this.encoder = super.newEncoder(false, getNullOutputStream());    this.testData = new int[getBatchSize()];    for (int i = 0; i < testData.length; i += 4) {                testData[i + 0] = super.getRandom().nextInt(50);                testData[i + 1] = super.getRandom().nextInt(5000);                testData[i + 2] = super.getRandom().nextInt(500000);                testData[i + 3] = super.getRandom().nextInt(150000000);    }}
18468f08d7a641120aaa17be317bdaefa1ba52389a2509cff459e16edccabe84
doSetupTrial
public void doSetupTrial() throws IOException
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    Encoder encoder = super.newEncoder(true, baos);    for (int i = 0; i < getBatchSize(); i += 4) {                encoder.writeInt(super.getRandom().nextInt(50));                encoder.writeInt(super.getRandom().nextInt(5000));                encoder.writeInt(super.getRandom().nextInt(500000));                encoder.writeInt(super.getRandom().nextInt(150000000));    }    this.testData = baos.toByteArray();}
773b72d34e2409988c4e6b4b91b97385f6d566ddabba16dd713e2891700d9130
doSetupInvocation
public void doSetupInvocation() throws Exception
{    this.decoder = super.newDecoder(this.testData);}
bc4354ca01ab236c3cec38efc2412c89c3d70f433d3e30b78d8bcb667c687c18
encode
public void encode(final TestStateEncode state) throws Exception
{    final Encoder e = state.encoder;    for (int i = 0; i < state.getBatchSize(); i += 4) {        e.writeLong(state.testData[i + 0]);        e.writeLong(state.testData[i + 1]);        e.writeLong(state.testData[i + 2]);        e.writeLong(state.testData[i + 3]);    }}
60a4d25699aac2a54fc9009dc81499068c281b7c0d0d422e89a6c10972923194
decode
public long decode(final TestStateDecode state) throws Exception
{    final Decoder d = state.decoder;    long total = 0;    for (int i = 0; i < state.getBatchSize(); i += 4) {        total += d.readLong();        total += d.readLong();        total += d.readLong();        total += d.readLong();    }    return total;}
1ca494ee3660d56a2bbe91018cb7d611c697df8b9133bb51d1ff482a95a852b4
doSetupTrial
public void doSetupTrial() throws Exception
{    this.encoder = super.newEncoder(false, getNullOutputStream());    this.testData = new long[getBatchSize()];    for (int i = 0; i < testData.length; i += 4) {                testData[i + 0] = super.getRandom().nextLong() % 0x7FL;                testData[i + 1] = super.getRandom().nextLong() % 0x1FFFFFL;                testData[i + 2] = super.getRandom().nextLong() % 0x3FFFFFFFFL;                testData[i + 3] = super.getRandom().nextLong() % 0x1FFFFFFFFFFFFL;    }}
18468f08d7a641120aaa17be317bdaefa1ba52389a2509cff459e16edccabe84
doSetupTrial
public void doSetupTrial() throws IOException
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    Encoder encoder = super.newEncoder(true, baos);    for (int i = 0; i < getBatchSize(); i += 4) {                encoder.writeLong(super.getRandom().nextLong() % 0x7FL);                encoder.writeLong(super.getRandom().nextLong() % 0x1FFFFFL);                encoder.writeLong(super.getRandom().nextLong() % 0x3FFFFFFFFL);                encoder.writeLong(super.getRandom().nextLong() % 0x1FFFFFFFFFFFFL);    }    this.testData = baos.toByteArray();}
773b72d34e2409988c4e6b4b91b97385f6d566ddabba16dd713e2891700d9130
doSetupInvocation
public void doSetupInvocation() throws Exception
{    this.decoder = super.newDecoder(this.testData);}
bc4354ca01ab236c3cec38efc2412c89c3d70f433d3e30b78d8bcb667c687c18
encode
public void encode(final TestStateEncode state) throws Exception
{    final Encoder e = state.encoder;    final int items = state.getBatchSize() / 4;    e.writeMapStart();    e.setItemCount(items);    for (int i = 0; i < state.getBatchSize(); i += 4) {        e.startItem();        e.writeString(state.utf);        e.writeFloat(state.testData[i + 0]);        e.writeFloat(state.testData[i + 1]);        e.writeFloat(state.testData[i + 2]);        e.writeFloat(state.testData[i + 3]);    }    e.writeMapEnd();}
3c1a379ee49f0b942d99caa9f39c4854c09a6725a185862e62d0bbb0b0cddc3b
decode
public float decode(final TestStateDecode state) throws Exception
{    final Decoder d = state.decoder;    float result = 0.0f;    for (long i = d.readMapStart(); i != 0; i = d.mapNext()) {        for (long j = 0; j < i; j++) {            state.utf = d.readString(state.utf);            result += d.readFloat();            result += d.readFloat();            result += d.readFloat();            result += d.readFloat();        }    }    return result;}
1ca494ee3660d56a2bbe91018cb7d611c697df8b9133bb51d1ff482a95a852b4
doSetupTrial
public void doSetupTrial() throws Exception
{    this.encoder = super.newEncoder(false, getNullOutputStream());    this.testData = new float[getBatchSize()];    for (int i = 0; i < testData.length; i++) {        testData[i] = super.getRandom().nextFloat();    }}
18468f08d7a641120aaa17be317bdaefa1ba52389a2509cff459e16edccabe84
doSetupTrial
public void doSetupTrial() throws IOException
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    Encoder encoder = super.newEncoder(true, baos);    final int items = getBatchSize() / 4;    encoder.writeMapStart();    encoder.setItemCount(items);    for (int i = 0; i < getBatchSize(); i += 4) {        encoder.startItem();        encoder.writeString("This is a map key");        encoder.writeFloat(super.getRandom().nextFloat());        encoder.writeFloat(super.getRandom().nextFloat());        encoder.writeFloat(super.getRandom().nextFloat());        encoder.writeFloat(super.getRandom().nextFloat());    }    encoder.writeMapEnd();    this.testData = baos.toByteArray();}
773b72d34e2409988c4e6b4b91b97385f6d566ddabba16dd713e2891700d9130
doSetupInvocation
public void doSetupInvocation() throws Exception
{    this.decoder = super.newDecoder(this.testData);}
bc4354ca01ab236c3cec38efc2412c89c3d70f433d3e30b78d8bcb667c687c18
encode
public void encode(final TestStateEncode state) throws Exception
{    final Encoder e = state.encoder;    for (int i = 0; i < state.getBatchSize(); i += 4) {        e.writeLong(state.testData[i + 0]);        e.writeLong(state.testData[i + 1]);        e.writeLong(state.testData[i + 2]);        e.writeLong(state.testData[i + 3]);    }}
e0df16f37db84f0d8b2ba7ab8c283c1ea25492612f328164a034e403453fbf68
decode
public int decode(final TestStateDecode state) throws Exception
{    final Decoder d = state.decoder;    int total = 0;    for (int i = 0; i < state.getBatchSize(); i += 4) {        total += d.readLong();        total += d.readLong();        total += d.readLong();        total += d.readLong();    }    return total;}
1ca494ee3660d56a2bbe91018cb7d611c697df8b9133bb51d1ff482a95a852b4
doSetupTrial
public void doSetupTrial() throws Exception
{    this.encoder = super.newEncoder(false, getNullOutputStream());    this.testData = new int[getBatchSize()];    for (int i = 0; i < testData.length; i += 4) {                testData[i + 0] = super.getRandom().nextInt(50);                testData[i + 1] = super.getRandom().nextInt(5000);                testData[i + 2] = super.getRandom().nextInt(500000);                testData[i + 3] = super.getRandom().nextInt(150000000);    }}
18468f08d7a641120aaa17be317bdaefa1ba52389a2509cff459e16edccabe84
doSetupTrial
public void doSetupTrial() throws IOException
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    Encoder encoder = super.newEncoder(true, baos);    for (int i = 0; i < getBatchSize(); i += 4) {                encoder.writeInt(super.getRandom().nextInt(50));                encoder.writeInt(super.getRandom().nextInt(5000));                encoder.writeInt(super.getRandom().nextInt(500000));                encoder.writeInt(super.getRandom().nextInt(150000000));    }    this.testData = baos.toByteArray();}
773b72d34e2409988c4e6b4b91b97385f6d566ddabba16dd713e2891700d9130
doSetupInvocation
public void doSetupInvocation() throws Exception
{    this.decoder = super.newDecoder(this.testData);}
bc4354ca01ab236c3cec38efc2412c89c3d70f433d3e30b78d8bcb667c687c18
encode
public void encode(final TestStateEncode state) throws Exception
{    final Encoder e = state.encoder;    for (int i = 0; i < state.getBatchSize(); i += 4) {        e.writeString(state.testData[i + 0]);        e.writeString(state.testData[i + 1]);        e.writeString(state.testData[i + 2]);        e.writeString(state.testData[i + 3]);    }}
e0df16f37db84f0d8b2ba7ab8c283c1ea25492612f328164a034e403453fbf68
decode
public int decode(final TestStateDecode state) throws Exception
{    final Decoder d = state.decoder;    int result = 0;    for (int i = 0; i < state.getBatchSize(); i += 4) {        result += d.readString(state.utf).toString().length();        result += d.readString(state.utf).toString().length();        result += d.readString(state.utf).toString().length();        result += d.readString(state.utf).toString().length();    }    return result;}
1ca494ee3660d56a2bbe91018cb7d611c697df8b9133bb51d1ff482a95a852b4
doSetupTrial
public void doSetupTrial() throws Exception
{    this.encoder = super.newEncoder(false, getNullOutputStream());    this.testData = new String[getBatchSize()];    for (int i = 0; i < testData.length; i++) {        testData[i] = randomString();    }}
c1e2ef76dff0bf5fccae536f9bd43791a6d566b6563eff8d618d690458862bf8
randomString
private String randomString()
{    final char[] data = new char[super.getRandom().nextInt(70)];    for (int j = 0; j < data.length; j++) {        data[j] = (char) ('a' + super.getRandom().nextInt('z' - 'a'));    }    return new String(data);}
18468f08d7a641120aaa17be317bdaefa1ba52389a2509cff459e16edccabe84
doSetupTrial
public void doSetupTrial() throws IOException
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    Encoder encoder = super.newEncoder(true, baos);    for (int i = 0; i < getBatchSize(); i++) {        encoder.writeString(randomString());    }    this.testData = baos.toByteArray();}
c1e2ef76dff0bf5fccae536f9bd43791a6d566b6563eff8d618d690458862bf8
randomString
private String randomString()
{    final char[] data = new char[super.getRandom().nextInt(70)];    for (int j = 0; j < data.length; j++) {        data[j] = (char) ('a' + super.getRandom().nextInt('z' - 'a'));    }    return new String(data);}
773b72d34e2409988c4e6b4b91b97385f6d566ddabba16dd713e2891700d9130
doSetupInvocation
public void doSetupInvocation() throws Exception
{    this.decoder = super.newDecoder(this.testData);}
bc4354ca01ab236c3cec38efc2412c89c3d70f433d3e30b78d8bcb667c687c18
encode
public void encode(final TestStateEncode state) throws Exception
{    final Encoder e = state.encoder;    GenericDatumWriter<Object> writer = new GenericDatumWriter<>(state.schema);    for (int i = 0; i < state.getBatchSize(); i += 4) {        writer.write(state.testData[i + 0], e);        writer.write(state.testData[i + 1], e);        writer.write(state.testData[i + 2], e);        writer.write(state.testData[i + 3], e);    }}
373c42e543efdeeee0132a28bcb085fa2b1d28c1258305e987ddbb16c136eb83
decode
public void decode(final Blackhole blackHole, final TestStateDecode state) throws Exception
{    final Decoder d = state.decoder;    final GenericDatumReader<Object> reader = new GenericDatumReader<>(state.schema);    for (int i = 0; i < state.getBatchSize(); i++) {        final Object o = reader.read(null, d);        blackHole.consume(o);    }}
1ca494ee3660d56a2bbe91018cb7d611c697df8b9133bb51d1ff482a95a852b4
doSetupTrial
public void doSetupTrial() throws Exception
{    this.encoder = super.newEncoder(false, getNullOutputStream());    this.testData = new GenericRecord[getBatchSize()];    for (int i = 0; i < getBatchSize(); i++) {        final GenericRecord rec = new GenericData.Record(this.schema);        final int val = super.getRandom().nextInt(1000000);        final Integer v = (val < 750000 ? new Integer(val) : null);        rec.put("f", v);        this.testData[i] = rec;    }}
cdd5424679d32f84df572be1e6d459b16657b6301ea760bb47e02e8cfb649b02
mkSchema
private String mkSchema(String subschema)
{    return ("{ \"type\": \"record\", \"name\": \"R\", \"fields\": [\n" + "{ \"name\": \"f\", \"type\": " + subschema + "}\n" + "] }");}
18468f08d7a641120aaa17be317bdaefa1ba52389a2509cff459e16edccabe84
doSetupTrial
public void doSetupTrial() throws IOException
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    Encoder encoder = super.newEncoder(true, baos);    final GenericDatumWriter<Object> writer = new GenericDatumWriter<>(this.schema);    for (int i = 0; i < getBatchSize(); i++) {        final GenericRecord rec = new GenericData.Record(this.schema);        final int val = super.getRandom().nextInt(1000000);        final Integer v = (val < 750000 ? new Integer(val) : null);        rec.put("f", v);        writer.write(rec, encoder);    }    this.testData = baos.toByteArray();}
cdd5424679d32f84df572be1e6d459b16657b6301ea760bb47e02e8cfb649b02
mkSchema
private String mkSchema(String subschema)
{    return ("{ \"type\": \"record\", \"name\": \"R\", \"fields\": [\n" + "{ \"name\": \"f\", \"type\": " + subschema + "}\n" + "] }");}
773b72d34e2409988c4e6b4b91b97385f6d566ddabba16dd713e2891700d9130
doSetupInvocation
public void doSetupInvocation() throws Exception
{    this.decoder = super.newDecoder(this.testData);}
8a0e3f9d0059a53ed500415e4af0ff5787e07d5db23f3a6333f33e66492a9e1b
getBatchSize
public int getBatchSize()
{    return super.getBatchSize() / arraySize;}
484c007096335115088686be473ce9956419455105bf8c036283db2911d068e1
getArraySize
public int getArraySize()
{    return arraySize;}
dc4b25cfc9a82468adb249b830d9fc8bda7649efbc8b2a42978c1d7e13680cc4
getRandom
protected Random getRandom()
{    return this.random;}
805405e87b74667813f26a00fbcc6cfada3c60e43baacbec5ea733b79fbd916d
newDecoder
protected Decoder newDecoder(final byte[] buf)
{    this.reuseDecoder = DECODER_FACTORY.binaryDecoder(buf, this.reuseDecoder);    return this.reuseDecoder;}
82c25137ec1da75c0302f33facf122dd197af422913e1627ea809c7de2fad02d
newEncoder
protected Encoder newEncoder(boolean direct, OutputStream out) throws IOException
{    this.reuseEncoder = (direct ? ENCODER_FACTORY.directBinaryEncoder(out, this.reuseEncoder) : ENCODER_FACTORY.binaryEncoder(out, this.reuseEncoder));    return this.reuseEncoder;}
29f1bf26f7d6b2f78715f3faa5b567bc91a9e0db15c67d9d42d0092105047b99
newEncoder
protected Encoder newEncoder(int blockSize, OutputStream out) throws IOException
{    this.reuseBlockingEncoder = ENCODER_FACTORY.configureBlockSize(blockSize).blockingBinaryEncoder(out, this.reuseBlockingEncoder);    return this.reuseBlockingEncoder;}
8a0e3f9d0059a53ed500415e4af0ff5787e07d5db23f3a6333f33e66492a9e1b
getBatchSize
public int getBatchSize()
{    return this.batchSize;}
d7a8c3d9feef5b9ca7c29ca85362b7e94f7abf8482e5f36bc1b569b100e8e2c6
getNullOutputStream
protected OutputStream getNullOutputStream()
{    return NULL_OUTPUTSTREAM;}
28b71ced43af8c83f8eb799b762b9363eea3393c08bf12a29b90de2304757b0c
write
public void write(int b) throws IOException
{}
6426ce3b66c4d2446558d8b5b93fe8a019e350f1ed5c2b61732f1efce14f0e67
write
public void write(byte[] b, int off, int len) throws IOException
{}
9dc05e09d787e6afa8b5d2cf4cacaf1f65f348fcc597daca5502cd46ac6e898a
write
public void write(byte[] b) throws IOException
{}
bc4354ca01ab236c3cec38efc2412c89c3d70f433d3e30b78d8bcb667c687c18
encode
public void encode(final TestStateEncode state) throws Exception
{    final Encoder e = state.encoder;    final GenericDatumWriter<Object> writer = new GenericDatumWriter<>(state.schema);    for (final GenericRecord rec : state.testData) {        writer.write(rec, e);    }}
2be89c166713af0a5157fa5af5f70a6ef93c46fd3111aa2442f22fa5091dcbff
decode
public void decode(final Blackhole blackhole, final TestStateDecode state) throws Exception
{    final Decoder d = state.decoder;    final GenericDatumReader<Object> reader = new GenericDatumReader<>(state.schema);    for (int i = 0; i < state.getBatchSize(); i++) {        blackhole.consume(reader.read(null, d));    }}
1ca494ee3660d56a2bbe91018cb7d611c697df8b9133bb51d1ff482a95a852b4
doSetupTrial
public void doSetupTrial() throws Exception
{    this.encoder = super.newEncoder(false, getNullOutputStream());    this.testData = new GenericRecord[getBatchSize()];    final Random r = super.getRandom();    Schema doubleSchema = schema.getFields().get(0).schema();    for (int i = 0; i < testData.length; i++) {        GenericRecord rec = new GenericData.Record(schema);        GenericRecord inner;        inner = new GenericData.Record(doubleSchema);        inner.put(0, r.nextDouble());        rec.put(0, inner);        inner = new GenericData.Record(doubleSchema);        inner.put(0, r.nextDouble());        rec.put(1, inner);        inner = new GenericData.Record(doubleSchema);        inner.put(0, r.nextDouble());        rec.put(2, inner);        rec.put(3, r.nextInt());        rec.put(4, r.nextInt());        rec.put(5, r.nextInt());        testData[i] = rec;    }}
18468f08d7a641120aaa17be317bdaefa1ba52389a2509cff459e16edccabe84
doSetupTrial
public void doSetupTrial() throws IOException
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    Encoder encoder = super.newEncoder(true, baos);    final Random r = super.getRandom();    for (int i = 0; i < getBatchSize(); i++) {        encoder.writeDouble(r.nextDouble());        encoder.writeDouble(r.nextDouble());        encoder.writeDouble(r.nextDouble());        encoder.writeInt(r.nextInt());        encoder.writeInt(r.nextInt());        encoder.writeInt(r.nextInt());    }    this.testData = baos.toByteArray();}
773b72d34e2409988c4e6b4b91b97385f6d566ddabba16dd713e2891700d9130
doSetupInvocation
public void doSetupInvocation() throws Exception
{    this.decoder = DecoderFactory.get().validatingDecoder(schema, super.newDecoder(this.testData));}
bc4354ca01ab236c3cec38efc2412c89c3d70f433d3e30b78d8bcb667c687c18
encode
public void encode(final TestStateEncode state) throws Exception
{    final Encoder e = state.encoder;    for (final GenericRecord rec : state.testData) {        GenericRecord inner;        inner = (GenericRecord) rec.get(0);        e.writeDouble((Double) inner.get(0));        inner = (GenericRecord) rec.get(1);        e.writeDouble((Double) inner.get(0));        inner = (GenericRecord) rec.get(2);        e.writeDouble((Double) inner.get(0));        e.writeInt((Integer) rec.get(3));        e.writeInt((Integer) rec.get(4));        e.writeInt((Integer) rec.get(5));    }}
2be89c166713af0a5157fa5af5f70a6ef93c46fd3111aa2442f22fa5091dcbff
decode
public void decode(final Blackhole blackhole, final TestStateDecode state) throws Exception
{    final Decoder d = state.decoder;    Schema doubleSchema = state.schema.getFields().get(0).schema();    for (int i = 0; i < state.getBatchSize(); i++) {        GenericRecord rec = new GenericData.Record(state.schema);        GenericRecord inner;        inner = new GenericData.Record(doubleSchema);        inner.put(0, d.readDouble());        rec.put(0, inner);        inner = new GenericData.Record(doubleSchema);        inner.put(0, d.readDouble());        rec.put(1, inner);        inner = new GenericData.Record(doubleSchema);        inner.put(0, d.readDouble());        rec.put(2, inner);        rec.put(3, d.readInt());        rec.put(4, d.readInt());        rec.put(5, d.readInt());    }}
1ca494ee3660d56a2bbe91018cb7d611c697df8b9133bb51d1ff482a95a852b4
doSetupTrial
public void doSetupTrial() throws Exception
{    this.encoder = super.newEncoder(false, getNullOutputStream());    this.testData = new GenericRecord[getBatchSize()];    final Random r = super.getRandom();    Schema doubleSchema = schema.getFields().get(0).schema();    for (int i = 0; i < testData.length; i++) {        GenericRecord rec = new GenericData.Record(schema);        GenericRecord inner;        inner = new GenericData.Record(doubleSchema);        inner.put(0, r.nextDouble());        rec.put(0, inner);        inner = new GenericData.Record(doubleSchema);        inner.put(0, r.nextDouble());        rec.put(1, inner);        inner = new GenericData.Record(doubleSchema);        inner.put(0, r.nextDouble());        rec.put(2, inner);        rec.put(3, r.nextInt());        rec.put(4, r.nextInt());        rec.put(5, r.nextInt());        testData[i] = rec;    }}
18468f08d7a641120aaa17be317bdaefa1ba52389a2509cff459e16edccabe84
doSetupTrial
public void doSetupTrial() throws IOException
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    Encoder encoder = super.newEncoder(true, baos);    final Random r = super.getRandom();    for (int i = 0; i < getBatchSize(); i++) {        encoder.writeDouble(r.nextDouble());        encoder.writeDouble(r.nextDouble());        encoder.writeDouble(r.nextDouble());        encoder.writeInt(r.nextInt());        encoder.writeInt(r.nextInt());        encoder.writeInt(r.nextInt());    }    this.testData = baos.toByteArray();}
773b72d34e2409988c4e6b4b91b97385f6d566ddabba16dd713e2891700d9130
doSetupInvocation
public void doSetupInvocation() throws Exception
{    this.decoder = DecoderFactory.get().validatingDecoder(schema, super.newDecoder(this.testData));}
bc4354ca01ab236c3cec38efc2412c89c3d70f433d3e30b78d8bcb667c687c18
encode
public void encode(final TestStateEncode state) throws Exception
{    final Encoder e = state.encoder;    final GenericDatumWriter<Object> writer = new GenericDatumWriter<>(state.readerSchema);    for (final GenericRecord rec : state.testData) {        writer.write(rec, e);    }}
2be89c166713af0a5157fa5af5f70a6ef93c46fd3111aa2442f22fa5091dcbff
decode
public void decode(final Blackhole blackhole, final TestStateDecode state) throws Exception
{    final Decoder d = state.decoder;    final GenericDatumReader<Object> reader = new GenericDatumReader<>(state.readerSchema);    for (int i = 0; i < state.getBatchSize(); i++) {        blackhole.consume(reader.read(null, d));    }}
1ca494ee3660d56a2bbe91018cb7d611c697df8b9133bb51d1ff482a95a852b4
doSetupTrial
public void doSetupTrial() throws Exception
{    this.encoder = super.newEncoder(false, getNullOutputStream());    this.testData = new GenericRecord[getBatchSize()];    for (int i = 0; i < testData.length; i++) {        GenericRecord rec = new GenericData.Record(readerSchema);        rec.put(0, randomString(super.getRandom()));        rec.put(1, randomString(super.getRandom()));        rec.put(2, randomString(super.getRandom()));        testData[i] = rec;    }}
18468f08d7a641120aaa17be317bdaefa1ba52389a2509cff459e16edccabe84
doSetupTrial
public void doSetupTrial() throws IOException
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    Encoder encoder = super.newEncoder(true, baos);    for (int i = 0; i < getBatchSize(); i++) {        encoder.writeString(randomString(super.getRandom()));        encoder.writeString(randomString(super.getRandom()));        encoder.writeString(randomString(super.getRandom()));    }    this.testData = baos.toByteArray();}
773b72d34e2409988c4e6b4b91b97385f6d566ddabba16dd713e2891700d9130
doSetupInvocation
public void doSetupInvocation() throws Exception
{    this.decoder = DecoderFactory.get().validatingDecoder(readerSchema, super.newDecoder(this.testData));}
2b5161bc0aa88f89f87046a356c1fdd2782b4275a0cc9af61dc8fff12d5d0f8d
randomString
private static String randomString(Random r)
{    char[] data = new char[r.nextInt(70)];    for (int j = 0; j < data.length; j++) {        data[j] = (char) ('a' + r.nextInt('z' - 'a'));    }    return new String(data);}
bc4354ca01ab236c3cec38efc2412c89c3d70f433d3e30b78d8bcb667c687c18
encode
public void encode(final TestStateEncode state) throws Exception
{    final Encoder e = state.encoder;    final GenericDatumWriter<Object> writer = new GenericDatumWriter<>(state.schema);    for (final GenericRecord rec : state.testData) {        writer.write(rec, e);    }}
2be89c166713af0a5157fa5af5f70a6ef93c46fd3111aa2442f22fa5091dcbff
decode
public void decode(final Blackhole blackhole, final TestStateDecode state) throws Exception
{    final Decoder d = state.decoder;    final GenericDatumReader<Object> reader = new GenericDatumReader<>(state.schema);    for (int i = 0; i < state.getBatchSize(); i++) {        blackhole.consume(reader.read(null, d));    }}
1ca494ee3660d56a2bbe91018cb7d611c697df8b9133bb51d1ff482a95a852b4
doSetupTrial
public void doSetupTrial() throws Exception
{    this.encoder = super.newEncoder(false, getNullOutputStream());    this.testData = new GenericRecord[getBatchSize()];    final Random r = super.getRandom();    for (int i = 0; i < testData.length; i++) {        final GenericRecord rec = new GenericData.Record(schema);        rec.put(0, r.nextDouble());        rec.put(1, r.nextDouble());        rec.put(2, r.nextDouble());        rec.put(3, r.nextInt());        rec.put(4, r.nextInt());        rec.put(5, r.nextInt());        testData[i] = rec;    }}
18468f08d7a641120aaa17be317bdaefa1ba52389a2509cff459e16edccabe84
doSetupTrial
public void doSetupTrial() throws IOException
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    Encoder encoder = super.newEncoder(true, baos);    final Random r = super.getRandom();    for (int i = 0; i < getBatchSize(); i++) {        encoder.writeDouble(r.nextDouble());        encoder.writeDouble(r.nextDouble());        encoder.writeDouble(r.nextDouble());        encoder.writeInt(r.nextInt());        encoder.writeInt(r.nextInt());        encoder.writeInt(r.nextInt());    }    this.testData = baos.toByteArray();}
773b72d34e2409988c4e6b4b91b97385f6d566ddabba16dd713e2891700d9130
doSetupInvocation
public void doSetupInvocation() throws Exception
{    this.decoder = DecoderFactory.get().validatingDecoder(schema, super.newDecoder(this.testData));}
bc4354ca01ab236c3cec38efc2412c89c3d70f433d3e30b78d8bcb667c687c18
encode
public void encode(final TestStateEncode state) throws Exception
{    final Encoder e = state.encoder;    final GenericDatumWriter<Object> writer = new GenericDatumWriter<>(state.schema);    for (final GenericRecord rec : state.testData) {        writer.write(rec, e);    }}
2be89c166713af0a5157fa5af5f70a6ef93c46fd3111aa2442f22fa5091dcbff
decode
public void decode(final Blackhole blackhole, final TestStateDecode state) throws Exception
{    final Decoder d = state.decoder;    final GenericDatumReader<Object> reader = new GenericDatumReader<>(state.schema);    for (int i = 0; i < state.getBatchSize(); i++) {        blackhole.consume(reader.read(null, d));    }}
1ca494ee3660d56a2bbe91018cb7d611c697df8b9133bb51d1ff482a95a852b4
doSetupTrial
public void doSetupTrial() throws Exception
{    this.encoder = super.newEncoder(false, getNullOutputStream());    this.testData = new GenericRecord[getBatchSize()];    final Random r = super.getRandom();    for (int i = 0; i < testData.length; i++) {        final GenericRecord rec = new GenericData.Record(schema);        rec.put(0, r.nextDouble());        rec.put(1, r.nextDouble());        rec.put(2, r.nextDouble());        rec.put(3, r.nextInt());        rec.put(4, r.nextInt());        rec.put(5, r.nextInt());        rec.put(6, randomString(r));        rec.put(7, randomString(r));        testData[i] = rec;    }}
18468f08d7a641120aaa17be317bdaefa1ba52389a2509cff459e16edccabe84
doSetupTrial
public void doSetupTrial() throws IOException
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    Encoder encoder = super.newEncoder(true, baos);    final GenericDatumWriter<Object> writer = new GenericDatumWriter<>(this.schema);    final Random r = super.getRandom();    for (int i = 0; i < getBatchSize(); i++) {        final GenericRecord rec = new GenericData.Record(schema);        rec.put(0, r.nextDouble());        rec.put(1, r.nextDouble());        rec.put(2, r.nextDouble());        rec.put(3, r.nextInt());        rec.put(4, r.nextInt());        rec.put(5, r.nextInt());        rec.put(6, randomString(r));        rec.put(7, randomString(r));        writer.write(rec, encoder);    }    encoder.flush();    this.testData = baos.toByteArray();}
773b72d34e2409988c4e6b4b91b97385f6d566ddabba16dd713e2891700d9130
doSetupInvocation
public void doSetupInvocation() throws Exception
{    this.decoder = DecoderFactory.get().validatingDecoder(schema, super.newDecoder(this.testData));}
2b5161bc0aa88f89f87046a356c1fdd2782b4275a0cc9af61dc8fff12d5d0f8d
randomString
private static String randomString(Random r)
{    char[] data = new char[r.nextInt(70)];    for (int j = 0; j < data.length; j++) {        data[j] = (char) ('a' + r.nextInt('z' - 'a'));    }    return new String(data);}
2be89c166713af0a5157fa5af5f70a6ef93c46fd3111aa2442f22fa5091dcbff
decode
public void decode(final Blackhole blackhole, final TestStateDecode state) throws Exception
{    final Decoder d = state.decoder;    final GenericDatumReader<Object> reader = new GenericDatumReader<>(state.writerSchema, state.readerSchema);    for (int i = 0; i < state.getBatchSize(); i++) {        blackhole.consume(reader.read(null, d));    }}
18468f08d7a641120aaa17be317bdaefa1ba52389a2509cff459e16edccabe84
doSetupTrial
public void doSetupTrial() throws IOException
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    Encoder encoder = super.newEncoder(true, baos);    final GenericDatumWriter<Object> writer = new GenericDatumWriter<>(this.writerSchema);    final Random r = super.getRandom();    for (int i = 0; i < getBatchSize(); i++) {        final GenericRecord rec = new GenericData.Record(writerSchema);        rec.put(0, r.nextDouble());        rec.put(1, r.nextDouble());        rec.put(2, r.nextDouble());        rec.put(3, r.nextInt());        rec.put(4, r.nextInt());        rec.put(5, r.nextInt());        writer.write(rec, encoder);    }    encoder.flush();    this.testData = baos.toByteArray();}
773b72d34e2409988c4e6b4b91b97385f6d566ddabba16dd713e2891700d9130
doSetupInvocation
public void doSetupInvocation() throws Exception
{    this.decoder = super.newDecoder(this.testData);}
2be89c166713af0a5157fa5af5f70a6ef93c46fd3111aa2442f22fa5091dcbff
decode
public void decode(final Blackhole blackhole, final TestStateDecode state) throws Exception
{    final Decoder d = state.decoder;    final GenericDatumReader<Object> reader = new GenericDatumReader<>(state.writerSchema, state.readerSchema);    for (int i = 0; i < state.getBatchSize(); i++) {        blackhole.consume(reader.read(null, d));    }}
18468f08d7a641120aaa17be317bdaefa1ba52389a2509cff459e16edccabe84
doSetupTrial
public void doSetupTrial() throws IOException
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    Encoder encoder = super.newEncoder(true, baos);    final GenericDatumWriter<Object> writer = new GenericDatumWriter<>(this.writerSchema);    final Random r = super.getRandom();    for (int i = 0; i < getBatchSize(); i++) {        final GenericRecord rec = new GenericData.Record(writerSchema);        rec.put(0, r.nextDouble());        rec.put(1, r.nextDouble());        rec.put(2, r.nextDouble());        rec.put(3, r.nextInt());        rec.put(4, r.nextInt());        rec.put(5, r.nextInt());        writer.write(rec, encoder);    }    encoder.flush();    this.testData = baos.toByteArray();}
773b72d34e2409988c4e6b4b91b97385f6d566ddabba16dd713e2891700d9130
doSetupInvocation
public void doSetupInvocation() throws Exception
{    this.decoder = super.newDecoder(this.testData);}
00fcda6ba170fdda5f818021f4568bbdd6db10af100eed220f1811b955bb297e
decode
public void decode(final TestStateDecode state) throws Exception
{    final Decoder d = state.decoder;    for (int i = 0; i < state.getBatchSize(); i++) {        d.readDouble();        d.readDouble();        d.readDouble();        d.readInt();        d.readInt();        d.readInt();    }}
18468f08d7a641120aaa17be317bdaefa1ba52389a2509cff459e16edccabe84
doSetupTrial
public void doSetupTrial() throws IOException
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    Encoder encoder = super.newEncoder(true, baos);    for (int i = 0; i < getBatchSize(); i++) {        final BasicRecord r = new BasicRecord(super.getRandom());        encoder.writeDouble(r.f1);        encoder.writeDouble(r.f2);        encoder.writeDouble(r.f3);        encoder.writeInt(r.f4);        encoder.writeInt(r.f5);        encoder.writeInt(r.f6);    }    this.testData = baos.toByteArray();}
773b72d34e2409988c4e6b4b91b97385f6d566ddabba16dd713e2891700d9130
doSetupInvocation
public void doSetupInvocation() throws Exception
{    this.decoder = DecoderFactory.get().validatingDecoder(readerSchema, super.newDecoder(this.testData));}
00fcda6ba170fdda5f818021f4568bbdd6db10af100eed220f1811b955bb297e
decode
public void decode(final TestStateDecode state) throws Exception
{    final Decoder d = state.decoder;    ResolvingDecoder r = (ResolvingDecoder) d;    Utf8 utf = new Utf8();    Field[] ff = r.readFieldOrder();    for (int i = 0; i < state.getBatchSize(); i++) {        for (int j = 0; j < ff.length; j++) {            Field f = ff[j];            switch(f.pos()) {                case 0:                case 1:                case 2:                    r.readDouble();                    break;                case 3:                case 4:                case 5:                    r.readInt();                    break;                case 6:                case 7:                    r.readString(utf);                    break;            }        }    }}
18468f08d7a641120aaa17be317bdaefa1ba52389a2509cff459e16edccabe84
doSetupTrial
public void doSetupTrial() throws IOException
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    Encoder encoder = super.newEncoder(true, baos);    for (int i = 0; i < getBatchSize(); i++) {        final BasicRecord r = new BasicRecord(super.getRandom());        encoder.writeDouble(r.f1);        encoder.writeDouble(r.f2);        encoder.writeDouble(r.f3);        encoder.writeInt(r.f4);        encoder.writeInt(r.f5);        encoder.writeInt(r.f6);    }    this.testData = baos.toByteArray();}
773b72d34e2409988c4e6b4b91b97385f6d566ddabba16dd713e2891700d9130
doSetupInvocation
public void doSetupInvocation() throws Exception
{    this.decoder = DecoderFactory.get().resolvingDecoder(writerSchema, readerSchema, super.newDecoder(this.testData));}
00fcda6ba170fdda5f818021f4568bbdd6db10af100eed220f1811b955bb297e
decode
public void decode(final TestStateDecode state) throws Exception
{    final Decoder d = state.decoder;    ResolvingDecoder r = (ResolvingDecoder) d;    Field[] ff = r.readFieldOrder();    for (int i = 0; i < state.getBatchSize(); i++) {        for (int j = 0; j < ff.length; j++) {            Field f = ff[j];            switch(f.pos()) {                case 0:                case 1:                case 3:                    r.readDouble();                    break;                case 2:                case 4:                case 5:                    r.readInt();                    break;            }        }    }}
18468f08d7a641120aaa17be317bdaefa1ba52389a2509cff459e16edccabe84
doSetupTrial
public void doSetupTrial() throws IOException
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    Encoder encoder = super.newEncoder(true, baos);    for (int i = 0; i < getBatchSize(); i++) {        final BasicRecord r = new BasicRecord(super.getRandom());        encoder.writeDouble(r.f1);        encoder.writeDouble(r.f2);        encoder.writeDouble(r.f3);        encoder.writeInt(r.f4);        encoder.writeInt(r.f5);        encoder.writeInt(r.f6);    }    this.testData = baos.toByteArray();}
773b72d34e2409988c4e6b4b91b97385f6d566ddabba16dd713e2891700d9130
doSetupInvocation
public void doSetupInvocation() throws Exception
{    this.decoder = DecoderFactory.get().resolvingDecoder(writerSchema, readerSchema, super.newDecoder(this.testData));}
00fcda6ba170fdda5f818021f4568bbdd6db10af100eed220f1811b955bb297e
decode
public void decode(final TestStateDecode state) throws Exception
{    final Decoder d = state.decoder;    ResolvingDecoder r = (ResolvingDecoder) d;    Field[] ff = r.readFieldOrder();    for (int i = 0; i < state.getBatchSize(); i++) {        for (int j = 0; j < ff.length; j++) {            Field f = ff[j];            switch(f.pos()) {                case 0:                case 1:                case 2:                    r.readDouble();                    break;                case 3:                case 4:                case 5:                    r.readLong();                    break;            }        }    }}
18468f08d7a641120aaa17be317bdaefa1ba52389a2509cff459e16edccabe84
doSetupTrial
public void doSetupTrial() throws IOException
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    Encoder encoder = super.newEncoder(true, baos);    for (int i = 0; i < getBatchSize(); i++) {        final BasicRecord r = new BasicRecord(super.getRandom());        encoder.writeDouble(r.f1);        encoder.writeDouble(r.f2);        encoder.writeDouble(r.f3);        encoder.writeInt(r.f4);        encoder.writeInt(r.f5);        encoder.writeInt(r.f6);    }    this.testData = baos.toByteArray();}
773b72d34e2409988c4e6b4b91b97385f6d566ddabba16dd713e2891700d9130
doSetupInvocation
public void doSetupInvocation() throws Exception
{    this.decoder = DecoderFactory.get().resolvingDecoder(writerSchema, readerSchema, super.newDecoder(this.testData));}
00fcda6ba170fdda5f818021f4568bbdd6db10af100eed220f1811b955bb297e
decode
public void decode(final TestStateDecode state) throws Exception
{    final Decoder d = state.decoder;    for (int i = 0; i < state.getBatchSize(); i++) {                d.readDouble();        d.readDouble();        d.readDouble();        d.readInt();        d.readInt();        d.readInt();    }}
18468f08d7a641120aaa17be317bdaefa1ba52389a2509cff459e16edccabe84
doSetupTrial
public void doSetupTrial() throws IOException
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    Encoder encoder = super.newEncoder(true, baos);    for (int i = 0; i < getBatchSize(); i++) {        final BasicRecord r = new BasicRecord(super.getRandom());        encoder.writeDouble(r.f1);        encoder.writeDouble(r.f2);        encoder.writeDouble(r.f3);        encoder.writeInt(r.f4);        encoder.writeInt(r.f5);        encoder.writeInt(r.f6);    }    this.testData = baos.toByteArray();}
773b72d34e2409988c4e6b4b91b97385f6d566ddabba16dd713e2891700d9130
doSetupInvocation
public void doSetupInvocation() throws Exception
{    this.decoder = DecoderFactory.get().resolvingDecoder(writerSchema, readerSchema, super.newDecoder(this.testData));}
bc4354ca01ab236c3cec38efc2412c89c3d70f433d3e30b78d8bcb667c687c18
encode
public void encode(final TestStateEncode state) throws Exception
{    final Encoder e = state.encoder;    for (final BasicRecord r : state.testData) {        e.writeDouble(r.f1);        e.writeDouble(r.f2);        e.writeDouble(r.f3);        e.writeInt(r.f4);        e.writeInt(r.f5);        e.writeInt(r.f6);    }}
00fcda6ba170fdda5f818021f4568bbdd6db10af100eed220f1811b955bb297e
decode
public void decode(final TestStateDecode state) throws Exception
{    final Decoder d = state.decoder;    for (int i = 0; i < state.getBatchSize(); i++) {        d.readDouble();        d.readDouble();        d.readDouble();        d.readInt();        d.readInt();        d.readInt();    }}
1ca494ee3660d56a2bbe91018cb7d611c697df8b9133bb51d1ff482a95a852b4
doSetupTrial
public void doSetupTrial() throws Exception
{    this.encoder = super.newEncoder(false, getNullOutputStream());    this.testData = new BasicRecord[getBatchSize()];    for (int i = 0; i < testData.length; i++) {        testData[i] = new BasicRecord(super.getRandom());    }}
18468f08d7a641120aaa17be317bdaefa1ba52389a2509cff459e16edccabe84
doSetupTrial
public void doSetupTrial() throws IOException
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    Encoder encoder = super.newEncoder(true, baos);    for (int i = 0; i < getBatchSize(); i++) {        final BasicRecord r = new BasicRecord(super.getRandom());        encoder.writeDouble(r.f1);        encoder.writeDouble(r.f2);        encoder.writeDouble(r.f3);        encoder.writeInt(r.f4);        encoder.writeInt(r.f5);        encoder.writeInt(r.f6);    }    this.testData = baos.toByteArray();}
773b72d34e2409988c4e6b4b91b97385f6d566ddabba16dd713e2891700d9130
doSetupInvocation
public void doSetupInvocation() throws Exception
{    this.decoder = DecoderFactory.get().validatingDecoder(this.schema, super.newDecoder(this.testData));}
bc4354ca01ab236c3cec38efc2412c89c3d70f433d3e30b78d8bcb667c687c18
encode
public void encode(final TestStateEncode state) throws Exception
{    for (final BigRecord r : state.testData) {        state.datumWriter.write(r, state.encoder);    }}
2be89c166713af0a5157fa5af5f70a6ef93c46fd3111aa2442f22fa5091dcbff
decode
public void decode(final Blackhole blackhole, final TestStateDecode state) throws Exception
{    final Decoder d = state.decoder;    final ReflectDatumReader<BigRecord> datumReader = new ReflectDatumReader<>(state.schema);    for (int i = 0; i < state.getBatchSize(); i++) {        blackhole.consume(datumReader.read(null, d));    }}
1ca494ee3660d56a2bbe91018cb7d611c697df8b9133bb51d1ff482a95a852b4
doSetupTrial
public void doSetupTrial() throws Exception
{    this.encoder = super.newEncoder(false, getNullOutputStream());    this.datumWriter = new ReflectDatumWriter<>(schema);    this.testData = new BigRecord[getBatchSize()];    for (int i = 0; i < testData.length; i++) {        this.testData[i] = new BigRecord(super.getRandom());    }}
18468f08d7a641120aaa17be317bdaefa1ba52389a2509cff459e16edccabe84
doSetupTrial
public void doSetupTrial() throws IOException
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    Encoder encoder = super.newEncoder(true, baos);    ReflectDatumWriter<BigRecord> writer = new ReflectDatumWriter<>(schema);    for (int i = 0; i < getBatchSize(); i++) {        final BigRecord r = new BigRecord(super.getRandom());        writer.write(r, encoder);    }    this.testData = baos.toByteArray();}
773b72d34e2409988c4e6b4b91b97385f6d566ddabba16dd713e2891700d9130
doSetupInvocation
public void doSetupInvocation() throws Exception
{    this.decoder = DecoderFactory.get().validatingDecoder(schema, super.newDecoder(this.testData));}
bc4354ca01ab236c3cec38efc2412c89c3d70f433d3e30b78d8bcb667c687c18
encode
public void encode(final TestStateEncode state) throws Exception
{    for (final double[] r : state.testData) {        state.datumWriter.write(r, state.encoder);    }}
2be89c166713af0a5157fa5af5f70a6ef93c46fd3111aa2442f22fa5091dcbff
decode
public void decode(final Blackhole blackhole, final TestStateDecode state) throws Exception
{    final Decoder d = state.decoder;    final ReflectDatumReader<double[]> datumReader = new ReflectDatumReader<>(state.schema);    for (int i = 0; i < state.getBatchSize(); i++) {        blackhole.consume(datumReader.read(null, d));    }}
1ca494ee3660d56a2bbe91018cb7d611c697df8b9133bb51d1ff482a95a852b4
doSetupTrial
public void doSetupTrial() throws Exception
{    this.encoder = super.newEncoder(false, getNullOutputStream());    this.datumWriter = new ReflectDatumWriter<>(schema);    this.testData = new double[getBatchSize()][];    for (int i = 0; i < testData.length; i++) {        this.testData[i] = populateDoubleArray(getRandom(), getArraySize());    }}
18468f08d7a641120aaa17be317bdaefa1ba52389a2509cff459e16edccabe84
doSetupTrial
public void doSetupTrial() throws IOException
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    Encoder encoder = super.newEncoder(true, baos);    ReflectDatumWriter<double[]> writer = new ReflectDatumWriter<>(schema);    for (int i = 0; i < this.getBatchSize(); i++) {        final double[] r = populateDoubleArray(getRandom(), getArraySize());        writer.write(r, encoder);    }    this.testData = baos.toByteArray();}
773b72d34e2409988c4e6b4b91b97385f6d566ddabba16dd713e2891700d9130
doSetupInvocation
public void doSetupInvocation() throws Exception
{    this.decoder = DecoderFactory.get().validatingDecoder(schema, super.newDecoder(this.testData));}
59a1a1dac4c175dab7e1f5a5f9ed401786870108abd47fce9237a72efe183d41
populateDoubleArray
 static double[] populateDoubleArray(final Random r, final int size)
{    double[] result = new double[size];    for (int i = 0; i < result.length; i++) {        result[i] = r.nextDouble();    }    return result;}
bc4354ca01ab236c3cec38efc2412c89c3d70f433d3e30b78d8bcb667c687c18
encode
public void encode(final TestStateEncode state) throws Exception
{    for (final float[] r : state.testData) {        state.datumWriter.write(r, state.encoder);    }}
2be89c166713af0a5157fa5af5f70a6ef93c46fd3111aa2442f22fa5091dcbff
decode
public void decode(final Blackhole blackhole, final TestStateDecode state) throws Exception
{    final Decoder d = state.decoder;    final ReflectDatumReader<float[]> datumReader = new ReflectDatumReader<>(state.schema);    for (int i = 0; i < state.getBatchSize(); i++) {        blackhole.consume(datumReader.read(null, d));    }}
1ca494ee3660d56a2bbe91018cb7d611c697df8b9133bb51d1ff482a95a852b4
doSetupTrial
public void doSetupTrial() throws Exception
{    this.encoder = super.newEncoder(false, getNullOutputStream());    this.datumWriter = new ReflectDatumWriter<>(schema);    this.testData = new float[getBatchSize()][];    for (int i = 0; i < testData.length; i++) {        this.testData[i] = populateFloatArray(getRandom(), getArraySize());    }}
18468f08d7a641120aaa17be317bdaefa1ba52389a2509cff459e16edccabe84
doSetupTrial
public void doSetupTrial() throws IOException
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    Encoder encoder = super.newEncoder(true, baos);    ReflectDatumWriter<float[]> writer = new ReflectDatumWriter<>(schema);    for (int i = 0; i < getBatchSize(); i++) {        final float[] r = populateFloatArray(getRandom(), getArraySize());        writer.write(r, encoder);    }    this.testData = baos.toByteArray();}
773b72d34e2409988c4e6b4b91b97385f6d566ddabba16dd713e2891700d9130
doSetupInvocation
public void doSetupInvocation() throws Exception
{    this.decoder = DecoderFactory.get().validatingDecoder(schema, super.newDecoder(this.testData));}
973b93342868baf393f274c615ec4d5b0a73150e7ae75bfb090d32ebc90501eb
populateFloatArray
 static float[] populateFloatArray(final Random r, final int size)
{    float[] result = new float[size];    for (int i = 0; i < result.length; i++) {        result[i] = r.nextFloat();    }    return result;}
bc4354ca01ab236c3cec38efc2412c89c3d70f433d3e30b78d8bcb667c687c18
encode
public void encode(final TestStateEncode state) throws Exception
{    for (final int[] r : state.testData) {        state.datumWriter.write(r, state.encoder);    }}
2be89c166713af0a5157fa5af5f70a6ef93c46fd3111aa2442f22fa5091dcbff
decode
public void decode(final Blackhole blackhole, final TestStateDecode state) throws Exception
{    final Decoder d = state.decoder;    final ReflectDatumReader<int[]> datumReader = new ReflectDatumReader<>(state.schema);    for (int i = 0; i < state.getBatchSize(); i++) {        blackhole.consume(datumReader.read(null, d));    }}
1ca494ee3660d56a2bbe91018cb7d611c697df8b9133bb51d1ff482a95a852b4
doSetupTrial
public void doSetupTrial() throws Exception
{    this.encoder = super.newEncoder(false, getNullOutputStream());    this.datumWriter = new ReflectDatumWriter<>(schema);    this.testData = new int[getBatchSize()][];    for (int i = 0; i < testData.length; i++) {        this.testData[i] = populateDoubleArray(getRandom(), getArraySize());    }}
18468f08d7a641120aaa17be317bdaefa1ba52389a2509cff459e16edccabe84
doSetupTrial
public void doSetupTrial() throws IOException
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    Encoder encoder = super.newEncoder(true, baos);    ReflectDatumWriter<int[]> writer = new ReflectDatumWriter<>(schema);    for (int i = 0; i < getBatchSize(); i++) {        final int[] r = populateDoubleArray(getRandom(), getArraySize());        writer.write(r, encoder);    }    this.testData = baos.toByteArray();}
773b72d34e2409988c4e6b4b91b97385f6d566ddabba16dd713e2891700d9130
doSetupInvocation
public void doSetupInvocation() throws Exception
{    this.decoder = DecoderFactory.get().validatingDecoder(schema, super.newDecoder(this.testData));}
65f8276e76a25240ea82a306d7dc3fe3e03d0a8d01b43cc45b860bf2932c3255
populateDoubleArray
 static int[] populateDoubleArray(final Random r, final int size)
{    int[] result = new int[size];    for (int i = 0; i < result.length; i++) {        result[i] = r.nextInt();    }    return result;}
bc4354ca01ab236c3cec38efc2412c89c3d70f433d3e30b78d8bcb667c687c18
encode
public void encode(final TestStateEncode state) throws Exception
{    for (final float[] r : state.testData) {        state.datumWriter.write(r, state.encoder);    }}
2be89c166713af0a5157fa5af5f70a6ef93c46fd3111aa2442f22fa5091dcbff
decode
public void decode(final Blackhole blackhole, final TestStateDecode state) throws Exception
{    final Decoder d = state.decoder;    final ReflectDatumReader<float[]> datumReader = new ReflectDatumReader<>(state.schema);    for (int i = 0; i < state.getBatchSize(); i++) {        blackhole.consume(datumReader.read(null, d));    }}
1ca494ee3660d56a2bbe91018cb7d611c697df8b9133bb51d1ff482a95a852b4
doSetupTrial
public void doSetupTrial() throws Exception
{    this.encoder = super.newEncoder(254, getNullOutputStream());    this.datumWriter = new ReflectDatumWriter<>(schema);    this.testData = new float[getBatchSize()][];    for (int i = 0; i < testData.length; i++) {        this.testData[i] = populateFloatArray(getRandom(), getArraySize());    }}
18468f08d7a641120aaa17be317bdaefa1ba52389a2509cff459e16edccabe84
doSetupTrial
public void doSetupTrial() throws IOException
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    Encoder encoder = super.newEncoder(true, baos);    ReflectDatumWriter<float[]> writer = new ReflectDatumWriter<>(schema);    for (int i = 0; i < getBatchSize(); i++) {        final float[] r = populateFloatArray(getRandom(), getArraySize());        writer.write(r, encoder);    }    this.testData = baos.toByteArray();}
773b72d34e2409988c4e6b4b91b97385f6d566ddabba16dd713e2891700d9130
doSetupInvocation
public void doSetupInvocation() throws Exception
{    this.decoder = DecoderFactory.get().validatingDecoder(schema, super.newDecoder(this.testData));}
973b93342868baf393f274c615ec4d5b0a73150e7ae75bfb090d32ebc90501eb
populateFloatArray
 static float[] populateFloatArray(final Random r, final int size)
{    float[] result = new float[size];    for (int i = 0; i < result.length; i++) {        result[i] = r.nextFloat();    }    return result;}
bc4354ca01ab236c3cec38efc2412c89c3d70f433d3e30b78d8bcb667c687c18
encode
public void encode(final TestStateEncode state) throws Exception
{    for (final float[] r : state.testData) {        state.datumWriter.write(r, state.encoder);    }}
2be89c166713af0a5157fa5af5f70a6ef93c46fd3111aa2442f22fa5091dcbff
decode
public void decode(final Blackhole blackhole, final TestStateDecode state) throws Exception
{    final Decoder d = state.decoder;    final ReflectDatumReader<float[]> datumReader = new ReflectDatumReader<>(state.schema);    for (int i = 0; i < state.getBatchSize(); i++) {        blackhole.consume(datumReader.read(null, d));    }}
1ca494ee3660d56a2bbe91018cb7d611c697df8b9133bb51d1ff482a95a852b4
doSetupTrial
public void doSetupTrial() throws Exception
{    this.encoder = super.newEncoder(false, getNullOutputStream());    this.datumWriter = new ReflectDatumWriter<>(schema);    this.testData = new float[getBatchSize()][];    for (int i = 0; i < testData.length; i++) {        this.testData[i] = populateFloatArray(getRandom(), getArraySize());    }}
18468f08d7a641120aaa17be317bdaefa1ba52389a2509cff459e16edccabe84
doSetupTrial
public void doSetupTrial() throws IOException
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    Encoder encoder = super.newEncoder(true, baos);    ReflectDatumWriter<float[]> writer = new ReflectDatumWriter<>(schema);    for (int i = 0; i < getBatchSize(); i++) {        final float[] r = populateFloatArray(getRandom(), getArraySize());        writer.write(r, encoder);    }    this.testData = baos.toByteArray();}
773b72d34e2409988c4e6b4b91b97385f6d566ddabba16dd713e2891700d9130
doSetupInvocation
public void doSetupInvocation() throws Exception
{    this.decoder = DecoderFactory.get().validatingDecoder(schema, super.newDecoder(this.testData));}
973b93342868baf393f274c615ec4d5b0a73150e7ae75bfb090d32ebc90501eb
populateFloatArray
 static float[] populateFloatArray(final Random r, final int size)
{    float[] result = new float[size];    for (int i = 0; i < result.length; i++) {        result[i] = r.nextFloat();    }    return result;}
bc4354ca01ab236c3cec38efc2412c89c3d70f433d3e30b78d8bcb667c687c18
encode
public void encode(final TestStateEncode state) throws Exception
{    for (final long[] r : state.testData) {        state.datumWriter.write(r, state.encoder);    }}
2be89c166713af0a5157fa5af5f70a6ef93c46fd3111aa2442f22fa5091dcbff
decode
public void decode(final Blackhole blackhole, final TestStateDecode state) throws Exception
{    final Decoder d = state.decoder;    final ReflectDatumReader<long[]> datumReader = new ReflectDatumReader<>(state.schema);    for (int i = 0; i < state.getBatchSize(); i++) {        blackhole.consume(datumReader.read(null, d));    }}
1ca494ee3660d56a2bbe91018cb7d611c697df8b9133bb51d1ff482a95a852b4
doSetupTrial
public void doSetupTrial() throws Exception
{    this.encoder = super.newEncoder(false, getNullOutputStream());    this.datumWriter = new ReflectDatumWriter<>(schema);    this.testData = new long[getBatchSize()][];    for (int i = 0; i < testData.length; i++) {        this.testData[i] = populateDoubleArray(getRandom(), getArraySize());    }}
18468f08d7a641120aaa17be317bdaefa1ba52389a2509cff459e16edccabe84
doSetupTrial
public void doSetupTrial() throws IOException
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    Encoder encoder = super.newEncoder(true, baos);    ReflectDatumWriter<long[]> writer = new ReflectDatumWriter<>(schema);    for (int i = 0; i < getBatchSize(); i++) {        final long[] r = populateDoubleArray(getRandom(), getArraySize());        writer.write(r, encoder);    }    this.testData = baos.toByteArray();}
773b72d34e2409988c4e6b4b91b97385f6d566ddabba16dd713e2891700d9130
doSetupInvocation
public void doSetupInvocation() throws Exception
{    this.decoder = DecoderFactory.get().validatingDecoder(schema, super.newDecoder(this.testData));}
655aa75995cf1c34bd9964d9e681bb7d426509ef4af97f5db0e64a891c9fb043
populateDoubleArray
 static long[] populateDoubleArray(final Random r, final int size)
{    long[] result = new long[size];    for (int i = 0; i < result.length; i++) {        result[i] = r.nextLong();    }    return result;}
bc4354ca01ab236c3cec38efc2412c89c3d70f433d3e30b78d8bcb667c687c18
encode
public void encode(final TestStateEncode state) throws Exception
{    for (final NativeArrayWrapper r : state.testData) {        state.datumWriter.write(r, state.encoder);    }}
2be89c166713af0a5157fa5af5f70a6ef93c46fd3111aa2442f22fa5091dcbff
decode
public void decode(final Blackhole blackhole, final TestStateDecode state) throws Exception
{    final Decoder d = state.decoder;    final ReflectDatumReader<float[]> datumReader = new ReflectDatumReader<>(state.schema);    for (int i = 0; i < state.getBatchSize(); i++) {        blackhole.consume(datumReader.read(null, d));    }}
1ca494ee3660d56a2bbe91018cb7d611c697df8b9133bb51d1ff482a95a852b4
doSetupTrial
public void doSetupTrial() throws Exception
{    this.encoder = super.newEncoder(false, getNullOutputStream());    this.datumWriter = new ReflectDatumWriter<>(schema);    this.testData = new NativeArrayWrapper[getBatchSize()];    for (int i = 0; i < testData.length; i++) {        NativeArrayWrapper wrapper = new NativeArrayWrapper();        wrapper.value = populateFloatArray(getRandom(), getArraySize());        this.testData[i] = wrapper;    }}
18468f08d7a641120aaa17be317bdaefa1ba52389a2509cff459e16edccabe84
doSetupTrial
public void doSetupTrial() throws IOException
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    Encoder encoder = super.newEncoder(true, baos);    ReflectDatumWriter<float[]> writer = new ReflectDatumWriter<>(schema);    for (int i = 0; i < getBatchSize(); i++) {        final float[] r = populateFloatArray(getRandom(), getArraySize());        writer.write(r, encoder);    }    this.testData = baos.toByteArray();}
773b72d34e2409988c4e6b4b91b97385f6d566ddabba16dd713e2891700d9130
doSetupInvocation
public void doSetupInvocation() throws Exception
{    this.decoder = DecoderFactory.get().validatingDecoder(schema, super.newDecoder(this.testData));}
973b93342868baf393f274c615ec4d5b0a73150e7ae75bfb090d32ebc90501eb
populateFloatArray
 static float[] populateFloatArray(final Random r, final int size)
{    float[] result = new float[size];    for (int i = 0; i < result.length; i++) {        result[i] = r.nextFloat();    }    return result;}
bc4354ca01ab236c3cec38efc2412c89c3d70f433d3e30b78d8bcb667c687c18
encode
public void encode(final TestStateEncode state) throws Exception
{    for (final ObjectArrayWrapper r : state.testData) {        state.datumWriter.write(r, state.encoder);    }}
2be89c166713af0a5157fa5af5f70a6ef93c46fd3111aa2442f22fa5091dcbff
decode
public void decode(final Blackhole blackhole, final TestStateDecode state) throws Exception
{    final Decoder d = state.decoder;    final ReflectDatumReader<BasicRecord[]> datumReader = new ReflectDatumReader<>(state.schema);    for (int i = 0; i < state.getBatchSize(); i++) {        blackhole.consume(datumReader.read(null, d));    }}
1ca494ee3660d56a2bbe91018cb7d611c697df8b9133bb51d1ff482a95a852b4
doSetupTrial
public void doSetupTrial() throws Exception
{    this.encoder = super.newEncoder(false, getNullOutputStream());    this.datumWriter = new ReflectDatumWriter<>(schema);    this.testData = new ObjectArrayWrapper[getBatchSize()];    for (int i = 0; i < testData.length; i++) {        ObjectArrayWrapper wrapper = new ObjectArrayWrapper();        wrapper.value = populateRecordArray(getRandom(), getArraySize());        this.testData[i] = wrapper;    }}
18468f08d7a641120aaa17be317bdaefa1ba52389a2509cff459e16edccabe84
doSetupTrial
public void doSetupTrial() throws IOException
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    Encoder encoder = super.newEncoder(true, baos);    ReflectDatumWriter<BasicRecord[]> writer = new ReflectDatumWriter<>(schema);    for (int i = 0; i < getBatchSize(); i++) {        final BasicRecord[] r = populateRecordArray(getRandom(), getArraySize());        writer.write(r, encoder);    }    this.testData = baos.toByteArray();}
773b72d34e2409988c4e6b4b91b97385f6d566ddabba16dd713e2891700d9130
doSetupInvocation
public void doSetupInvocation() throws Exception
{    this.decoder = DecoderFactory.get().validatingDecoder(schema, super.newDecoder(this.testData));}
954abccc69ca78c4db0d810189885affb03dabacce37bc097b297a75328ced88
populateRecordArray
 static BasicRecord[] populateRecordArray(final Random r, final int size)
{    BasicRecord[] result = new BasicRecord[size];    for (int i = 0; i < result.length; i++) {        result[i] = new BasicRecord(r);    }    return result;}
bc4354ca01ab236c3cec38efc2412c89c3d70f433d3e30b78d8bcb667c687c18
encode
public void encode(final TestStateEncode state) throws Exception
{    for (final BasicRecord r : state.testData) {        state.datumWriter.write(r, state.encoder);    }}
2be89c166713af0a5157fa5af5f70a6ef93c46fd3111aa2442f22fa5091dcbff
decode
public void decode(final Blackhole blackhole, final TestStateDecode state) throws Exception
{    final Decoder d = state.decoder;    final ReflectDatumReader<BasicRecord> datumReader = new ReflectDatumReader<>(state.schema);    for (int i = 0; i < state.getBatchSize(); i++) {        blackhole.consume(datumReader.read(null, d));    }}
1ca494ee3660d56a2bbe91018cb7d611c697df8b9133bb51d1ff482a95a852b4
doSetupTrial
public void doSetupTrial() throws Exception
{    this.encoder = super.newEncoder(false, getNullOutputStream());    this.datumWriter = new ReflectDatumWriter<>(schema);    this.testData = new BasicRecord[getBatchSize()];    for (int i = 0; i < testData.length; i++) {        this.testData[i] = new BasicRecord(getRandom());    }}
18468f08d7a641120aaa17be317bdaefa1ba52389a2509cff459e16edccabe84
doSetupTrial
public void doSetupTrial() throws IOException
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    Encoder encoder = super.newEncoder(true, baos);    ReflectDatumWriter<BasicRecord> writer = new ReflectDatumWriter<>(schema);    for (int i = 0; i < getBatchSize(); i++) {        final BasicRecord r = new BasicRecord(getRandom());        writer.write(r, encoder);    }    this.testData = baos.toByteArray();}
773b72d34e2409988c4e6b4b91b97385f6d566ddabba16dd713e2891700d9130
doSetupInvocation
public void doSetupInvocation() throws Exception
{    this.decoder = DecoderFactory.get().validatingDecoder(schema, super.newDecoder(this.testData));}
5d30095fbf25e1e4266802af2730beda80d4b20c152b510ae837654572e0c87e
get
public static ProtobufData get()
{    return INSTANCE;}
7303aaf9e45ab4c8c624b0e6a5d7b5941d362a96397a811d275ccc7e47c2ece3
createDatumReader
public DatumReader createDatumReader(Schema schema)
{    return new ProtobufDatumReader(schema, schema, this);}
3d2aa170a9dc9e88ce5dff8d9760bdd18b4ddcbfb1066b36a9661ff0df2e90fb
createDatumWriter
public DatumWriter createDatumWriter(Schema schema)
{    return new ProtobufDatumWriter(schema, this);}
181fb7fd53cc01f4df6d5af8ddff368f62dbd3d1cfa7eadcb278d4bae9487ee8
setField
public void setField(Object r, String n, int pos, Object o)
{    setField(r, n, pos, o, getRecordState(r, getSchema(r.getClass())));}
4d76eaea35da71be42b1f31f4e3bc1e419984813236d6955180a85b42fd52df0
getField
public Object getField(Object r, String name, int pos)
{    return getField(r, name, pos, getRecordState(r, getSchema(r.getClass())));}
6c01fb0032020b3bdfcd87289a9fcc5725ed06c30ae8257140213460d55c772b
setField
protected void setField(Object r, String n, int pos, Object o, Object state)
{    Builder b = (Builder) r;    FieldDescriptor f = ((FieldDescriptor[]) state)[pos];    switch(f.getType()) {        case MESSAGE:            if (o == null) {                b.clearField(f);                break;            }        default:            b.setField(f, o);    }}
61e87990300aa265dffc2843e9002d5e5aea256de7f2e53dec5ca66ff32170a1
getField
protected Object getField(Object record, String name, int pos, Object state)
{    Message m = (Message) record;    FieldDescriptor f = ((FieldDescriptor[]) state)[pos];    switch(f.getType()) {        case MESSAGE:            if (!f.isRepeated() && !m.hasField(f))                return null;        default:            return m.getField(f);    }}
f8e24ffcdecbf98caab9d974a7bf9299c3d720b3712124716a6779e37440afec
getRecordState
protected Object getRecordState(Object r, Schema s)
{    Descriptor d = ((MessageOrBuilder) r).getDescriptorForType();    FieldDescriptor[] fields = fieldCache.get(d);    if (fields == null) {                fields = new FieldDescriptor[s.getFields().size()];        for (Field f : s.getFields()) fields[f.pos()] = d.findFieldByName(f.name());                fieldCache.put(d, fields);    }    return fields;}
1b134742de945abb4e613bd1016bdba9127aba26e8e578964be50af2bb864d19
isRecord
protected boolean isRecord(Object datum)
{    return datum instanceof Message;}
29054906d4af7be8dc8790cace3ee77ee70e4d288fe6c3430ecd85a8301c0864
newRecord
public Object newRecord(Object old, Schema schema)
{    try {        Class c = SpecificData.get().getClass(schema);        if (c == null)                        return newRecord(old, schema);        if (c.isInstance(old))                        return old;        return c.getMethod("newBuilder").invoke(null);    } catch (Exception e) {        throw new RuntimeException(e);    }}
544f1c34befadc3c9aa6e8a9976e5699018508396f3bbc8d42eb8027b3d830fb
isArray
protected boolean isArray(Object datum)
{    return datum instanceof List;}
c19f2258b56e6bb84785b44422325e6dd35d0cd9e9b7c47a7b0e85b56e643c83
isBytes
protected boolean isBytes(Object datum)
{    return datum instanceof ByteString;}
e0ccc1e06ae00a2a60c371353533514f62b4e4bb097a1e40a212a8240b20fe10
getRecordSchema
protected Schema getRecordSchema(Object record)
{    Descriptor descriptor = ((Message) record).getDescriptorForType();    Schema schema = schemaCache.get(descriptor);    if (schema == null) {        schema = getSchema(descriptor);        schemaCache.put(descriptor, schema);    }    return schema;}
9cace38460f2091e09c386fb4b7596a75ef198f9b283e60e3b0760d3937c3333
getSchema
public Schema getSchema(Class c)
{    Schema schema = schemaCache.get(c);    if (schema == null) {                try {            Object descriptor = c.getMethod("getDescriptor").invoke(null);            if (c.isEnum())                schema = getSchema((EnumDescriptor) descriptor);            else                schema = getSchema((Descriptor) descriptor);        } catch (Exception e) {            throw new RuntimeException(e);        }                schemaCache.put(c, schema);    }    return schema;}
1a9e992e1e75d702fea28fd4ba24307bc9262de6ddd5b6d6c06675e95f216c1c
getSchema
public Schema getSchema(Descriptor descriptor)
{    Map<Descriptor, Schema> seen = SEEN.get();    if (    seen.containsKey(descriptor))        return seen.get(descriptor);    boolean first = seen.isEmpty();    Conversion conversion = getConversionByDescriptor(descriptor);    if (conversion != null) {        Schema converted = conversion.getRecommendedSchema();        seen.put(descriptor, converted);        return converted;    }    try {        Schema result = Schema.createRecord(descriptor.getName(), null, getNamespace(descriptor.getFile(), descriptor.getContainingType()), false);        seen.put(descriptor, result);        List<Field> fields = new ArrayList<>();        for (FieldDescriptor f : descriptor.getFields()) fields.add(Accessor.createField(f.getName(), getSchema(f), null, getDefault(f)));        result.setFields(fields);        return result;    } finally {        if (first)            seen.clear();    }}
29530617bf734ecf82377d5bd1b0437129bbfd32e0cab5a8809d3ade26e47874
getNamespace
public String getNamespace(FileDescriptor fd, Descriptor containing)
{    FileOptions o = fd.getOptions();    String p = o.hasJavaPackage() ? o.getJavaPackage() : fd.getPackage();    String outer = "";    if (!o.getJavaMultipleFiles()) {        if (o.hasJavaOuterClassname()) {            outer = o.getJavaOuterClassname();        } else {            outer = new File(fd.getName()).getName();            outer = outer.substring(0, outer.lastIndexOf('.'));            outer = toCamelCase(outer);        }    }    StringBuilder inner = new StringBuilder();    while (containing != null) {        if (inner.length() == 0) {            inner.insert(0, containing.getName());        } else {            inner.insert(0, containing.getName() + "$");        }        containing = containing.getContainingType();    }    String d1 = (!outer.isEmpty() || inner.length() != 0 ? "." : "");    String d2 = (!outer.isEmpty() && inner.length() != 0 ? "$" : "");    return p + d1 + outer + d2 + inner;}
9078fdfbc535b4685ccd65717b6abe26aa07b32085c2cca0dd9ed2dcf512821b
toCamelCase
private static String toCamelCase(String s)
{    String[] parts = s.split("_");    StringBuilder camelCaseString = new StringBuilder();    for (String part : parts) {        camelCaseString.append(cap(part));    }    return camelCaseString.toString();}
3e51092c495b5a1e021580b91b4edf6ce8def158bfe3cdbb96e8ff3a19b1b982
cap
private static String cap(String s)
{    return s.substring(0, 1).toUpperCase() + s.substring(1).toLowerCase();}
619eb8b69ae457384d0a1b194295f20a330ed89773b19378e498ba11a9a277ce
getSchema
public Schema getSchema(FieldDescriptor f)
{    Schema s = getNonRepeatedSchema(f);    if (f.isRepeated())        s = Schema.createArray(s);    return s;}
c88490a63b15036bf801999d264dcd6dfc592d2d722b3ba1feeeb239ab4fa1c0
getNonRepeatedSchema
private Schema getNonRepeatedSchema(FieldDescriptor f)
{    Schema result;    switch(f.getType()) {        case BOOL:            return Schema.create(Schema.Type.BOOLEAN);        case FLOAT:            return Schema.create(Schema.Type.FLOAT);        case DOUBLE:            return Schema.create(Schema.Type.DOUBLE);        case STRING:            Schema s = Schema.create(Schema.Type.STRING);            GenericData.setStringType(s, GenericData.StringType.String);            return s;        case BYTES:            return Schema.create(Schema.Type.BYTES);        case INT32:        case UINT32:        case SINT32:        case FIXED32:        case SFIXED32:            return Schema.create(Schema.Type.INT);        case INT64:        case UINT64:        case SINT64:        case FIXED64:        case SFIXED64:            return Schema.create(Schema.Type.LONG);        case ENUM:            return getSchema(f.getEnumType());        case MESSAGE:            result = getSchema(f.getMessageType());            if (f.isOptional())                                result = Schema.createUnion(Arrays.asList(NULL, result));            return result;                case GROUP:        default:            throw new RuntimeException("Unexpected type: " + f.getType());    }}
05ef97e9f0f30256f51e84c6df7588267665c03f430b9da0c0aa81decc73fa71
getSchema
public Schema getSchema(EnumDescriptor d)
{    List<String> symbols = new ArrayList<>();    for (EnumValueDescriptor e : d.getValues()) {        symbols.add(e.getName());    }    return Schema.createEnum(d.getName(), null, getNamespace(d.getFile(), d.getContainingType()), symbols);}
6cc62db5ad6594d6312d13de2758d59d19f18a49062ac309ce8566ebcee5c35e
getDefault
private JsonNode getDefault(FieldDescriptor f)
{    if (    f.isRequired() || f.isRepeated())        return null;    if (f.hasDefaultValue()) {                Object value = f.getDefaultValue();        switch(f.getType()) {            case ENUM:                value = ((EnumValueDescriptor) value).getName();                break;        }        String json = toString(value);        try {            return MAPPER.readTree(FACTORY.createParser(json));        } catch (IOException e) {            throw new RuntimeException(e);        }    }    switch(    f.getType()) {        case BOOL:            return NODES.booleanNode(false);        case FLOAT:        case DOUBLE:        case INT32:        case UINT32:        case SINT32:        case FIXED32:        case SFIXED32:        case INT64:        case UINT64:        case SINT64:        case FIXED64:        case SFIXED64:            return NODES.numberNode(0);        case STRING:        case BYTES:            return NODES.textNode("");        case ENUM:            return NODES.textNode(f.getEnumType().getValues().get(0).getName());        case MESSAGE:            return NODES.nullNode();                case GROUP:        default:            throw new RuntimeException("Unexpected type: " + f.getType());    }}
11e52b06d3313971f3da6b32ebe9201a9e36d39dd6e9ac8177f033699e8e06d2
getConversionByDescriptor
private Conversion getConversionByDescriptor(Descriptor descriptor)
{    String namespace = getNamespace(descriptor.getFile(), descriptor.getContainingType());    String name = descriptor.getName();        String dot = namespace.endsWith("$") ? "" : ".";    try {        Class clazz = ClassUtils.forName(getClassLoader(), namespace + dot + name);        return getConversionByClass(clazz);    } catch (ClassNotFoundException e) {        return null;    }}
53d42b61ceafb918d7034fad0c71fbf84442dc73259eea122f38ea53fd89bc7e
readRecord
protected Object readRecord(Object old, Schema expected, ResolvingDecoder in) throws IOException
{    Message.Builder b = (Message.Builder) super.readRecord(old, expected, in);        return b.build();}
ba3551741c67b001580a4f329a6837cd872aeca67c8d5f82b3324af5f30f4676
createEnum
protected Object createEnum(String symbol, Schema schema)
{    try {        Class c = SpecificData.get().getClass(schema);        if (c == null)                        return super.createEnum(symbol, schema);        return ((ProtocolMessageEnum) Enum.valueOf(c, symbol)).getValueDescriptor();    } catch (Exception e) {        throw new RuntimeException(e);    }}
c6f75186ab2e2828fa9b15d13656669627d1a96b79c7406b70c69db615e78a04
readBytes
protected Object readBytes(Object old, Decoder in) throws IOException
{    return ByteString.copyFrom(((ByteBuffer) super.readBytes(old, in)).array());}
4991313986c666ab7d89ef913042220d7e658389c5ff820c0c2890814b8ef1ce
writeEnum
protected void writeEnum(Schema schema, Object datum, Encoder out) throws IOException
{    if (!(datum instanceof EnumValueDescriptor))                super.writeEnum(schema, datum, out);    else        out.writeEnum(schema.getEnumOrdinal(((EnumValueDescriptor) datum).getName()));}
7e2854bd80d8b97a030073ac1adfa38a98546f188df05d53b4035e30b0129a18
writeBytes
protected void writeBytes(Object datum, Encoder out) throws IOException
{    ByteString bytes = (ByteString) datum;    out.writeBytes(bytes.toByteArray(), 0, bytes.size());}
bb52504976b0f93df3826e061829e92f183f539f31096b61561a3c6f17604774
getConvertedType
public Class<Timestamp> getConvertedType()
{    return Timestamp.class;}
79c42293ac3a43d7598dc0ac8104dd9a114e436cd5a14a6241ebbe2b10b5f8ba
getLogicalTypeName
public String getLogicalTypeName()
{    return "timestamp-millis";}
60e910728a3ddb76669a5fc5bdf744149cd2231ea907237915d7e7f06ca8ece8
fromLong
public Timestamp fromLong(Long millisFromEpoch, Schema schema, LogicalType type) throws IllegalArgumentException
{    return ProtoConversions.fromLong(millisFromEpoch, TimestampPrecise.Millis);}
c02daff29970e1ada660c332e9bd25d0a0de81f66d66ee64019bcf56076ce2b1
toLong
public Long toLong(Timestamp value, Schema schema, LogicalType type)
{    return ProtoConversions.toLong(value, TimestampPrecise.Millis);}
44afca78eb2f944191717c831b23c212dab4c09d5ffc0c38e3839f3ca0d439cd
getRecommendedSchema
public Schema getRecommendedSchema()
{    return LogicalTypes.timestampMillis().addToSchema(Schema.create(Schema.Type.LONG));}
bb52504976b0f93df3826e061829e92f183f539f31096b61561a3c6f17604774
getConvertedType
public Class<Timestamp> getConvertedType()
{    return Timestamp.class;}
79c42293ac3a43d7598dc0ac8104dd9a114e436cd5a14a6241ebbe2b10b5f8ba
getLogicalTypeName
public String getLogicalTypeName()
{    return "timestamp-micros";}
041ec9786f31cb15dc43059afd67bf6acbd641ac6d96aff360fb2c3d63de8773
fromLong
public Timestamp fromLong(Long microsFromEpoch, Schema schema, LogicalType type) throws IllegalArgumentException
{    return ProtoConversions.fromLong(microsFromEpoch, TimestampPrecise.Micros);}
c02daff29970e1ada660c332e9bd25d0a0de81f66d66ee64019bcf56076ce2b1
toLong
public Long toLong(Timestamp value, Schema schema, LogicalType type)
{    return ProtoConversions.toLong(value, TimestampPrecise.Micros);}
44afca78eb2f944191717c831b23c212dab4c09d5ffc0c38e3839f3ca0d439cd
getRecommendedSchema
public Schema getRecommendedSchema()
{    return LogicalTypes.timestampMicros().addToSchema(Schema.create(Schema.Type.LONG));}
2084209a91e74c999500cec4f59125da92d49b432a44abca91659ac76f79d08d
toLong
private static long toLong(Timestamp value, TimestampPrecise precise)
{    long rv = 0L;    switch(precise) {        case Millis:            rv = value.getSeconds() * THOUSAND + value.getNanos() / MILLION;            break;        case Micros:            rv = value.getSeconds() * MILLION + value.getNanos() / THOUSAND;            break;    }    return rv;}
609441f94f4366ce887a0c0cb3a83d2f345019fbb5c94d61efb0e79095f4d4b0
fromLong
private static Timestamp fromLong(Long elapsedSinceEpoch, TimestampPrecise precise) throws IllegalArgumentException
{    long seconds = 0L;    int nanos = 0;    switch(precise) {        case Millis:            seconds = Math.floorDiv(elapsedSinceEpoch, THOUSAND);            nanos = (int) Math.floorMod(elapsedSinceEpoch, THOUSAND) * MILLION;            break;        case Micros:            seconds = Math.floorDiv(elapsedSinceEpoch, MILLION);            nanos = (int) Math.floorMod(elapsedSinceEpoch, MILLION) * THOUSAND;            break;    }    if (seconds < SECONDS_LOWERLIMIT || seconds > SECONDS_UPPERLIMIT) {        throw new IllegalArgumentException("given seconds is out of range");    }    if (nanos < NANOSECONDS_LOWERLIMIT || nanos > NANOSECONDS_UPPERLIMIT) {                throw new IllegalArgumentException("given nanos is out of range");    }    return Timestamp.newBuilder().setSeconds(seconds).setNanos(nanos).build();}
35f3ec879596849ae2c78c5ba39ee17b816937a06f86452b7ab8b2af2a96533b
getNumber
public final int getNumber()
{    return value;}
c6ae9145c5c28aef6bac2278ed0edd1ccc91b08615a2c2e43ceefb81fcee5065
valueOf
public static A valueOf(int value)
{    return forNumber(value);}
0dc36c0d9100ddff4d912867b5cf5c887107034fda6e18fc4fd1bb4e711698fa
forNumber
public static A forNumber(int value)
{    switch(value) {        case 1:            return X;        case 2:            return Y;        case 3:            return Z;        default:            return null;    }}
072d0ac999598703adce5e953dc73a309dc988919038e3d7876b259756658dfe
internalGetValueMap
public static com.google.protobuf.Internal.EnumLiteMap<A> internalGetValueMap()
{    return internalValueMap;}
2cc6b6af3ca5f62ee0295f1535d61950c673cb009a874bec76a6d9895bb6fb7f
findValueByNumber
public A findValueByNumber(int number)
{    return A.forNumber(number);}
369cb5b49c34ac1de71984da1ee6a33e3f379bcd8089b809c272768420d70b36
getValueDescriptor
public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor()
{    return getDescriptor().getValues().get(ordinal());}
135f17befa1c20386f8dd8256e8d90b6f3e8cec3374799ac7e99f05fb221f93d
getDescriptorForType
public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType()
{    return getDescriptor();}
94c5986db9187ae1728adb5adc6399ab98540d464821f94b52ab256a9f722e1c
getDescriptor
public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor()
{    return org.apache.avro.protobuf.multiplefiles.TestMultipleFiles.getDescriptor().getEnumTypes().get(0);}
7cf969c15493db77229281aaaa465acd4ae3ff2197fde8ed591ba95b38760eb6
valueOf
public static A valueOf(com.google.protobuf.Descriptors.EnumValueDescriptor desc)
{    if (desc.getType() != getDescriptor()) {        throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");    }    return VALUES[desc.getIndex()];}
afeb2882aee0a13dc444e9d430b86a6dc175c48ee917722e2d5ab50801b7ab38
getUnknownFields
public final com.google.protobuf.UnknownFieldSet getUnknownFields()
{    return this.unknownFields;}
e061a4269a7822f30b36dfe5c448257acd508bbe5bfe85e23841ca998b986e73
getDescriptor
public static final com.google.protobuf.Descriptors.Descriptor getDescriptor()
{    return org.apache.avro.protobuf.multiplefiles.TestMultipleFiles.internal_static_org_apache_avro_protobuf_multiplefiles_Foo_descriptor;}
09b927b3931a0c25b6621043bbd0a8b48cb113bfa27184d786c8e36653bca4dd
internalGetFieldAccessorTable
protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable internalGetFieldAccessorTable()
{    return org.apache.avro.protobuf.multiplefiles.TestMultipleFiles.internal_static_org_apache_avro_protobuf_multiplefiles_Foo_fieldAccessorTable.ensureFieldAccessorsInitialized(org.apache.avro.protobuf.multiplefiles.Foo.class, org.apache.avro.protobuf.multiplefiles.Foo.Builder.class);}
9a1647854ce456002dcb1c52139e88ef7a23a7d696936d56a15e6d4db0ccb184
hasInt32
public boolean hasInt32()
{    return ((bitField0_ & 0x00000001) == 0x00000001);}
636175cecf2b3f1c8415679f2f0b80d34ba9b63e238193298adf86af15007213
getInt32
public int getInt32()
{    return int32_;}
a2c53766842c579522e01699c16d28ea58a1b49581f61187921336e4ce63b648
hasInt64
public boolean hasInt64()
{    return ((bitField0_ & 0x00000002) == 0x00000002);}
57c8339ea9b07d9b3113d12c4eae4a8a74f2ebd9a6de36dd3cfa42c148f186ab
getInt64
public long getInt64()
{    return int64_;}
2e6ee41b2bb0d50e6b526adc77c21e06d72a1423b637a000776e01b5c2b60cfe
hasUint32
public boolean hasUint32()
{    return ((bitField0_ & 0x00000004) == 0x00000004);}
b7d2e4380f601c73ee0923b2fe9b521818c5ce75b743deec1d19ed294de77dd1
getUint32
public int getUint32()
{    return uint32_;}
00e677ff71597cdf7ae7ab5e024a2eb75ff3d284223f3c6045ed6dd53e8d0845
hasUint64
public boolean hasUint64()
{    return ((bitField0_ & 0x00000008) == 0x00000008);}
b4b058bcc167225140afd471f432372421b25319080692aa857ca736719bc92b
getUint64
public long getUint64()
{    return uint64_;}
2e93fdc6d6c8b20576cd9a0e9d1e183d33569ed069463a98ad5ec167a29d6e14
hasSint32
public boolean hasSint32()
{    return ((bitField0_ & 0x00000010) == 0x00000010);}
75b5ac5769aad1f59a8c73b0547c0c77fc4c170b9c72844230175c2a4ba06ad5
getSint32
public int getSint32()
{    return sint32_;}
31fdd75033679196631750b698981d6dcc9537d93c151d7cbcd4ca46de9d58aa
hasSint64
public boolean hasSint64()
{    return ((bitField0_ & 0x00000020) == 0x00000020);}
75d70e1b7a60651a143d6564f9b40443b64654c71ee48cc41a68029e8c436e18
getSint64
public long getSint64()
{    return sint64_;}
ad9c191d2d327991d4d5c3dea893bb9a901eb34f81ccfc40c50706ef79c1760a
hasFixed32
public boolean hasFixed32()
{    return ((bitField0_ & 0x00000040) == 0x00000040);}
98f6f07472f43870759b408f82612481ade75d1e14ccc2226cec24b686f55050
getFixed32
public int getFixed32()
{    return fixed32_;}
4a6662d0d6f52e9e2b217aaeb86a991de741e56d2eeb146d3d43652fe51a5326
hasFixed64
public boolean hasFixed64()
{    return ((bitField0_ & 0x00000080) == 0x00000080);}
8b9413171a22273aafb43565effc2135094288b4e3333b3afd1e37e629f68fb0
getFixed64
public long getFixed64()
{    return fixed64_;}
41a3547ab4b509363c785a59db522a034320a04eecd00bf28bcc5250c8636cd8
hasSfixed32
public boolean hasSfixed32()
{    return ((bitField0_ & 0x00000100) == 0x00000100);}
64daf2c2e759b26fa9445cc4f9caba82b1aa8040416bdf77dc86a976ef8ede0d
getSfixed32
public int getSfixed32()
{    return sfixed32_;}
45f1bf05257c7a952854e866f6a67f13b5c039f4e8c25738e069ed51eb6f63cf
hasSfixed64
public boolean hasSfixed64()
{    return ((bitField0_ & 0x00000200) == 0x00000200);}
20f25f0e34849b2bce430689f850be46b02bd3b74ea8c5a77b60c18c791e6a64
getSfixed64
public long getSfixed64()
{    return sfixed64_;}
0cb9fb07dff4d2bfa7ae4bf0843e71fa5fb3d03c06b07c7d2a717ec089d0767e
hasFloat
public boolean hasFloat()
{    return ((bitField0_ & 0x00000400) == 0x00000400);}
ee9a51dbf95b211d37a60138ffb4deb11942d61f5c9721afa1016727fb401415
getFloat
public float getFloat()
{    return float_;}
e28f40a1dd04174c7100c4112d5ed5b5772e98d43d41f2d671ff567e0f4c6ce5
hasDouble
public boolean hasDouble()
{    return ((bitField0_ & 0x00000800) == 0x00000800);}
95f35c6fbf999bf94e0a9c9c5fa482ed65318ab2572fb3b51e8c181fc2611e97
getDouble
public double getDouble()
{    return double_;}
586ca0c2bb6da45de72704084c6e31b535779b9f3166053de6d5c3114e808751
hasBool
public boolean hasBool()
{    return ((bitField0_ & 0x00001000) == 0x00001000);}
f5d970ff55271bea91b285c75a149e090505eb675c4e8194d9e1e500461f90e8
getBool
public boolean getBool()
{    return bool_;}
3f0c31e577682520c0fcca7daaaf896b908ba830b55ce04569418803a52cead8
hasString
public boolean hasString()
{    return ((bitField0_ & 0x00002000) == 0x00002000);}
7c4c17115810ae3f13bf8deca5f5267c8cb89c0f70fafecb78a67ebd65ae6b37
getString
public java.lang.String getString()
{    java.lang.Object ref = string_;    if (ref instanceof java.lang.String) {        return (java.lang.String) ref;    } else {        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;        java.lang.String s = bs.toStringUtf8();        if (bs.isValidUtf8()) {            string_ = s;        }        return s;    }}
404c2340dc76857ee9b3d6bb2a82a6697881da7fa911e1d8af649f5b71248a3a
getStringBytes
public com.google.protobuf.ByteString getStringBytes()
{    java.lang.Object ref = string_;    if (ref instanceof java.lang.String) {        com.google.protobuf.ByteString b = com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);        string_ = b;        return b;    } else {        return (com.google.protobuf.ByteString) ref;    }}
75a99db492c7f97c17d6844f9a82e00a4b1f11fd35d8ea25d7d55a21df04ad6a
hasBytes
public boolean hasBytes()
{    return ((bitField0_ & 0x00004000) == 0x00004000);}
d6cf6f44c45e7e724dce80e785110e2196522fe8c0a756ce8d5e75c119e561c5
getBytes
public com.google.protobuf.ByteString getBytes()
{    return bytes_;}
698a189fcb3c994fa12118569041c84a5d6176385eb353c702935c048c13d88b
hasEnum
public boolean hasEnum()
{    return ((bitField0_ & 0x00008000) == 0x00008000);}
9aff2bb5f0c612590f6b4d622aacce1b5cccf91cff821587982a1af995539a11
getEnum
public org.apache.avro.protobuf.multiplefiles.A getEnum()
{    org.apache.avro.protobuf.multiplefiles.A result = org.apache.avro.protobuf.multiplefiles.A.valueOf(enum_);    return result == null ? org.apache.avro.protobuf.multiplefiles.A.Z : result;}
0dbd424bbcce9aded3aad4770c8ffb4c32f758322b180e89d544aa54302c6728
getIntArrayList
public java.util.List<java.lang.Integer> getIntArrayList()
{    return intArray_;}
31b4697dd384dd0bd1bde310af3b62067c0a1ad32cc543d5063825eeb8bd56b3
getIntArrayCount
public int getIntArrayCount()
{    return intArray_.size();}
2e098f94a8cd1017c27e6f532faec1cc3c3f5529d9acf62fca5795b2889dd67a
getIntArray
public int getIntArray(int index)
{    return intArray_.get(index);}
c6456ed2383ccd59fd746b564e053b7f6ca2a4343bbdaca5d596e3f9a3e89f02
getFooArrayList
public java.util.List<org.apache.avro.protobuf.multiplefiles.Foo> getFooArrayList()
{    return fooArray_;}
6b433a5251a4fce25b1ce49190a7f475a7e888dd4f8db4c4ac154a73bfdef795
getFooArrayOrBuilderList
public java.util.List<? extends org.apache.avro.protobuf.multiplefiles.FooOrBuilder> getFooArrayOrBuilderList()
{    return fooArray_;}
fd2ac97f74deac4a599110fe63068fdd22b2fde4ae9928305d79d7d01629765c
getFooArrayCount
public int getFooArrayCount()
{    return fooArray_.size();}
57d90d3ca040e9eedf6245b46f994a8ce63fd37f82ffdb43229d6ee06cfda5d2
getFooArray
public org.apache.avro.protobuf.multiplefiles.Foo getFooArray(int index)
{    return fooArray_.get(index);}
427d982b1b134ac42b5ac669ea5d84eff2a2d4e3f10b9ea0d2ac57ec732e2928
getFooArrayOrBuilder
public org.apache.avro.protobuf.multiplefiles.FooOrBuilder getFooArrayOrBuilder(int index)
{    return fooArray_.get(index);}
c42ab857f9153e283b6244ba3e087a7865707647d9a44594657f27b58f47ec79
convert
public org.apache.avro.protobuf.multiplefiles.A convert(java.lang.Integer from)
{    org.apache.avro.protobuf.multiplefiles.A result = org.apache.avro.protobuf.multiplefiles.A.valueOf(from);    return result == null ? org.apache.avro.protobuf.multiplefiles.A.X : result;}
d4b23b07911a22d016081a2aa46fe029c93723f5dc6e06989594370080efbe73
getSymsList
public java.util.List<org.apache.avro.protobuf.multiplefiles.A> getSymsList()
{    return new com.google.protobuf.Internal.ListAdapter<java.lang.Integer, org.apache.avro.protobuf.multiplefiles.A>(syms_, syms_converter_);}
184c0551fc5d1c2cbff289a02240b91ff20c32be2e794e0f47a61014a4b8d156
getSymsCount
public int getSymsCount()
{    return syms_.size();}
40211f2c387f8455891659e5b276c6f20b6df3129e52b61444d8e68ef03a2bee
getSyms
public org.apache.avro.protobuf.multiplefiles.A getSyms(int index)
{    return syms_converter_.convert(syms_.get(index));}
10058f491b0a4a5c22162369389d3ed8276668e2d04db758b35d31010e7e4677
hasFoo
public boolean hasFoo()
{    return ((bitField0_ & 0x00010000) == 0x00010000);}
1c42cde0529cde40036707fb76752ff3cacdd9f1f873ec2a6f368f4c22f8f04a
getFoo
public org.apache.avro.protobuf.multiplefiles.Foo getFoo()
{    return foo_ == null ? org.apache.avro.protobuf.multiplefiles.Foo.getDefaultInstance() : foo_;}
855632a379855b3107f294117ed487982590ca87c6ea5bb9c30f480c59b10cb1
getFooOrBuilder
public org.apache.avro.protobuf.multiplefiles.FooOrBuilder getFooOrBuilder()
{    return foo_ == null ? org.apache.avro.protobuf.multiplefiles.Foo.getDefaultInstance() : foo_;}
bafb11dbca36e09bf79e4baa90c93a1bc1422a322f7ad686efa10ecb036831b5
hasTimestamp
public boolean hasTimestamp()
{    return ((bitField0_ & 0x00020000) == 0x00020000);}
c66f064664f32c706c67564ca4c770ad74baa2e4df0c3a6eccb1177407cc2c5e
getTimestamp
public com.google.protobuf.Timestamp getTimestamp()
{    return timestamp_ == null ? com.google.protobuf.Timestamp.getDefaultInstance() : timestamp_;}
1a895b7c2c7d5a9cb1b98abc55c3ddb581f84797f811e5056403cde4d040aebb
getTimestampOrBuilder
public com.google.protobuf.TimestampOrBuilder getTimestampOrBuilder()
{    return timestamp_ == null ? com.google.protobuf.Timestamp.getDefaultInstance() : timestamp_;}
dde7cd718eaa61cad29906454acf122daba6680a2db55e4787a359a08951b5e7
isInitialized
public final boolean isInitialized()
{    byte isInitialized = memoizedIsInitialized;    if (isInitialized == 1)        return true;    if (isInitialized == 0)        return false;    if (!hasInt32()) {        memoizedIsInitialized = 0;        return false;    }    for (int i = 0; i < getFooArrayCount(); i++) {        if (!getFooArray(i).isInitialized()) {            memoizedIsInitialized = 0;            return false;        }    }    if (hasFoo()) {        if (!getFoo().isInitialized()) {            memoizedIsInitialized = 0;            return false;        }    }    memoizedIsInitialized = 1;    return true;}
b78da5ac0d0f56440a60e0c8711e74775e8d0aafe7882e5346a5dcc6fa783f73
writeTo
public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException
{    if (((bitField0_ & 0x00000001) == 0x00000001)) {        output.writeInt32(1, int32_);    }    if (((bitField0_ & 0x00000002) == 0x00000002)) {        output.writeInt64(2, int64_);    }    if (((bitField0_ & 0x00000004) == 0x00000004)) {        output.writeUInt32(3, uint32_);    }    if (((bitField0_ & 0x00000008) == 0x00000008)) {        output.writeUInt64(4, uint64_);    }    if (((bitField0_ & 0x00000010) == 0x00000010)) {        output.writeSInt32(5, sint32_);    }    if (((bitField0_ & 0x00000020) == 0x00000020)) {        output.writeSInt64(6, sint64_);    }    if (((bitField0_ & 0x00000040) == 0x00000040)) {        output.writeFixed32(7, fixed32_);    }    if (((bitField0_ & 0x00000080) == 0x00000080)) {        output.writeFixed64(8, fixed64_);    }    if (((bitField0_ & 0x00000100) == 0x00000100)) {        output.writeSFixed32(9, sfixed32_);    }    if (((bitField0_ & 0x00000200) == 0x00000200)) {        output.writeSFixed64(10, sfixed64_);    }    if (((bitField0_ & 0x00000400) == 0x00000400)) {        output.writeFloat(11, float_);    }    if (((bitField0_ & 0x00000800) == 0x00000800)) {        output.writeDouble(12, double_);    }    if (((bitField0_ & 0x00001000) == 0x00001000)) {        output.writeBool(13, bool_);    }    if (((bitField0_ & 0x00002000) == 0x00002000)) {        com.google.protobuf.GeneratedMessageV3.writeString(output, 14, string_);    }    if (((bitField0_ & 0x00004000) == 0x00004000)) {        output.writeBytes(15, bytes_);    }    if (((bitField0_ & 0x00008000) == 0x00008000)) {        output.writeEnum(16, enum_);    }    for (int i = 0; i < intArray_.size(); i++) {        output.writeInt32(17, intArray_.get(i));    }    if (((bitField0_ & 0x00010000) == 0x00010000)) {        output.writeMessage(18, getFoo());    }    for (int i = 0; i < syms_.size(); i++) {        output.writeEnum(19, syms_.get(i));    }    for (int i = 0; i < fooArray_.size(); i++) {        output.writeMessage(20, fooArray_.get(i));    }    if (((bitField0_ & 0x00020000) == 0x00020000)) {        output.writeMessage(21, getTimestamp());    }    unknownFields.writeTo(output);}
2bd67191ad73644076f3a74f7b306983cf9bd449d2e535f9b7f802bd0492f9f1
getSerializedSize
public int getSerializedSize()
{    int size = memoizedSize;    if (size != -1)        return size;    size = 0;    if (((bitField0_ & 0x00000001) == 0x00000001)) {        size += com.google.protobuf.CodedOutputStream.computeInt32Size(1, int32_);    }    if (((bitField0_ & 0x00000002) == 0x00000002)) {        size += com.google.protobuf.CodedOutputStream.computeInt64Size(2, int64_);    }    if (((bitField0_ & 0x00000004) == 0x00000004)) {        size += com.google.protobuf.CodedOutputStream.computeUInt32Size(3, uint32_);    }    if (((bitField0_ & 0x00000008) == 0x00000008)) {        size += com.google.protobuf.CodedOutputStream.computeUInt64Size(4, uint64_);    }    if (((bitField0_ & 0x00000010) == 0x00000010)) {        size += com.google.protobuf.CodedOutputStream.computeSInt32Size(5, sint32_);    }    if (((bitField0_ & 0x00000020) == 0x00000020)) {        size += com.google.protobuf.CodedOutputStream.computeSInt64Size(6, sint64_);    }    if (((bitField0_ & 0x00000040) == 0x00000040)) {        size += com.google.protobuf.CodedOutputStream.computeFixed32Size(7, fixed32_);    }    if (((bitField0_ & 0x00000080) == 0x00000080)) {        size += com.google.protobuf.CodedOutputStream.computeFixed64Size(8, fixed64_);    }    if (((bitField0_ & 0x00000100) == 0x00000100)) {        size += com.google.protobuf.CodedOutputStream.computeSFixed32Size(9, sfixed32_);    }    if (((bitField0_ & 0x00000200) == 0x00000200)) {        size += com.google.protobuf.CodedOutputStream.computeSFixed64Size(10, sfixed64_);    }    if (((bitField0_ & 0x00000400) == 0x00000400)) {        size += com.google.protobuf.CodedOutputStream.computeFloatSize(11, float_);    }    if (((bitField0_ & 0x00000800) == 0x00000800)) {        size += com.google.protobuf.CodedOutputStream.computeDoubleSize(12, double_);    }    if (((bitField0_ & 0x00001000) == 0x00001000)) {        size += com.google.protobuf.CodedOutputStream.computeBoolSize(13, bool_);    }    if (((bitField0_ & 0x00002000) == 0x00002000)) {        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(14, string_);    }    if (((bitField0_ & 0x00004000) == 0x00004000)) {        size += com.google.protobuf.CodedOutputStream.computeBytesSize(15, bytes_);    }    if (((bitField0_ & 0x00008000) == 0x00008000)) {        size += com.google.protobuf.CodedOutputStream.computeEnumSize(16, enum_);    }    {        int dataSize = 0;        for (int i = 0; i < intArray_.size(); i++) {            dataSize += com.google.protobuf.CodedOutputStream.computeInt32SizeNoTag(intArray_.get(i));        }        size += dataSize;        size += 2 * getIntArrayList().size();    }    if (((bitField0_ & 0x00010000) == 0x00010000)) {        size += com.google.protobuf.CodedOutputStream.computeMessageSize(18, getFoo());    }    {        int dataSize = 0;        for (int i = 0; i < syms_.size(); i++) {            dataSize += com.google.protobuf.CodedOutputStream.computeEnumSizeNoTag(syms_.get(i));        }        size += dataSize;        size += 2 * syms_.size();    }    for (int i = 0; i < fooArray_.size(); i++) {        size += com.google.protobuf.CodedOutputStream.computeMessageSize(20, fooArray_.get(i));    }    if (((bitField0_ & 0x00020000) == 0x00020000)) {        size += com.google.protobuf.CodedOutputStream.computeMessageSize(21, getTimestamp());    }    size += unknownFields.getSerializedSize();    memoizedSize = size;    return size;}
c16419e263b56042dfd908ea4d6500d086628461f2faaccf6ad79f7d3aa82321
equals
public boolean equals(final java.lang.Object obj)
{    if (obj == this) {        return true;    }    if (!(obj instanceof org.apache.avro.protobuf.multiplefiles.Foo)) {        return super.equals(obj);    }    org.apache.avro.protobuf.multiplefiles.Foo other = (org.apache.avro.protobuf.multiplefiles.Foo) obj;    boolean result = true;    result = result && (hasInt32() == other.hasInt32());    if (hasInt32()) {        result = result && (getInt32() == other.getInt32());    }    result = result && (hasInt64() == other.hasInt64());    if (hasInt64()) {        result = result && (getInt64() == other.getInt64());    }    result = result && (hasUint32() == other.hasUint32());    if (hasUint32()) {        result = result && (getUint32() == other.getUint32());    }    result = result && (hasUint64() == other.hasUint64());    if (hasUint64()) {        result = result && (getUint64() == other.getUint64());    }    result = result && (hasSint32() == other.hasSint32());    if (hasSint32()) {        result = result && (getSint32() == other.getSint32());    }    result = result && (hasSint64() == other.hasSint64());    if (hasSint64()) {        result = result && (getSint64() == other.getSint64());    }    result = result && (hasFixed32() == other.hasFixed32());    if (hasFixed32()) {        result = result && (getFixed32() == other.getFixed32());    }    result = result && (hasFixed64() == other.hasFixed64());    if (hasFixed64()) {        result = result && (getFixed64() == other.getFixed64());    }    result = result && (hasSfixed32() == other.hasSfixed32());    if (hasSfixed32()) {        result = result && (getSfixed32() == other.getSfixed32());    }    result = result && (hasSfixed64() == other.hasSfixed64());    if (hasSfixed64()) {        result = result && (getSfixed64() == other.getSfixed64());    }    result = result && (hasFloat() == other.hasFloat());    if (hasFloat()) {        result = result && (java.lang.Float.floatToIntBits(getFloat()) == java.lang.Float.floatToIntBits(other.getFloat()));    }    result = result && (hasDouble() == other.hasDouble());    if (hasDouble()) {        result = result && (java.lang.Double.doubleToLongBits(getDouble()) == java.lang.Double.doubleToLongBits(other.getDouble()));    }    result = result && (hasBool() == other.hasBool());    if (hasBool()) {        result = result && (getBool() == other.getBool());    }    result = result && (hasString() == other.hasString());    if (hasString()) {        result = result && getString().equals(other.getString());    }    result = result && (hasBytes() == other.hasBytes());    if (hasBytes()) {        result = result && getBytes().equals(other.getBytes());    }    result = result && (hasEnum() == other.hasEnum());    if (hasEnum()) {        result = result && enum_ == other.enum_;    }    result = result && getIntArrayList().equals(other.getIntArrayList());    result = result && getFooArrayList().equals(other.getFooArrayList());    result = result && syms_.equals(other.syms_);    result = result && (hasFoo() == other.hasFoo());    if (hasFoo()) {        result = result && getFoo().equals(other.getFoo());    }    result = result && (hasTimestamp() == other.hasTimestamp());    if (hasTimestamp()) {        result = result && getTimestamp().equals(other.getTimestamp());    }    result = result && unknownFields.equals(other.unknownFields);    return result;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    if (memoizedHashCode != 0) {        return memoizedHashCode;    }    int hash = 41;    hash = (19 * hash) + getDescriptor().hashCode();    if (hasInt32()) {        hash = (37 * hash) + INT32_FIELD_NUMBER;        hash = (53 * hash) + getInt32();    }    if (hasInt64()) {        hash = (37 * hash) + INT64_FIELD_NUMBER;        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(getInt64());    }    if (hasUint32()) {        hash = (37 * hash) + UINT32_FIELD_NUMBER;        hash = (53 * hash) + getUint32();    }    if (hasUint64()) {        hash = (37 * hash) + UINT64_FIELD_NUMBER;        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(getUint64());    }    if (hasSint32()) {        hash = (37 * hash) + SINT32_FIELD_NUMBER;        hash = (53 * hash) + getSint32();    }    if (hasSint64()) {        hash = (37 * hash) + SINT64_FIELD_NUMBER;        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(getSint64());    }    if (hasFixed32()) {        hash = (37 * hash) + FIXED32_FIELD_NUMBER;        hash = (53 * hash) + getFixed32();    }    if (hasFixed64()) {        hash = (37 * hash) + FIXED64_FIELD_NUMBER;        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(getFixed64());    }    if (hasSfixed32()) {        hash = (37 * hash) + SFIXED32_FIELD_NUMBER;        hash = (53 * hash) + getSfixed32();    }    if (hasSfixed64()) {        hash = (37 * hash) + SFIXED64_FIELD_NUMBER;        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(getSfixed64());    }    if (hasFloat()) {        hash = (37 * hash) + FLOAT_FIELD_NUMBER;        hash = (53 * hash) + java.lang.Float.floatToIntBits(getFloat());    }    if (hasDouble()) {        hash = (37 * hash) + DOUBLE_FIELD_NUMBER;        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(java.lang.Double.doubleToLongBits(getDouble()));    }    if (hasBool()) {        hash = (37 * hash) + BOOL_FIELD_NUMBER;        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(getBool());    }    if (hasString()) {        hash = (37 * hash) + STRING_FIELD_NUMBER;        hash = (53 * hash) + getString().hashCode();    }    if (hasBytes()) {        hash = (37 * hash) + BYTES_FIELD_NUMBER;        hash = (53 * hash) + getBytes().hashCode();    }    if (hasEnum()) {        hash = (37 * hash) + ENUM_FIELD_NUMBER;        hash = (53 * hash) + enum_;    }    if (getIntArrayCount() > 0) {        hash = (37 * hash) + INTARRAY_FIELD_NUMBER;        hash = (53 * hash) + getIntArrayList().hashCode();    }    if (getFooArrayCount() > 0) {        hash = (37 * hash) + FOOARRAY_FIELD_NUMBER;        hash = (53 * hash) + getFooArrayList().hashCode();    }    if (getSymsCount() > 0) {        hash = (37 * hash) + SYMS_FIELD_NUMBER;        hash = (53 * hash) + syms_.hashCode();    }    if (hasFoo()) {        hash = (37 * hash) + FOO_FIELD_NUMBER;        hash = (53 * hash) + getFoo().hashCode();    }    if (hasTimestamp()) {        hash = (37 * hash) + TIMESTAMP_FIELD_NUMBER;        hash = (53 * hash) + getTimestamp().hashCode();    }    hash = (29 * hash) + unknownFields.hashCode();    memoizedHashCode = hash;    return hash;}
7e223f928c65f55e2a74bb5a8c830aab1c7e41b61077c4c74e7eda551c9ff328
parseFrom
public static org.apache.avro.protobuf.multiplefiles.Foo parseFrom(java.nio.ByteBuffer data) throws com.google.protobuf.InvalidProtocolBufferException
{    return PARSER.parseFrom(data);}
32c619dfb9168b34497dc6ae9a431af1435caa8db5c70d792870e3447ac2b73f
parseFrom
public static org.apache.avro.protobuf.multiplefiles.Foo parseFrom(java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException
{    return PARSER.parseFrom(data, extensionRegistry);}
ad0297ee571f4064107bf3a6e0caf26726a713021c9f5f04f3f73841bbecdc8d
parseFrom
public static org.apache.avro.protobuf.multiplefiles.Foo parseFrom(com.google.protobuf.ByteString data) throws com.google.protobuf.InvalidProtocolBufferException
{    return PARSER.parseFrom(data);}
9f7bd8370043ac0a2b7e5e311b737d56de12cc85b087321432e42bfb6d7d7910
parseFrom
public static org.apache.avro.protobuf.multiplefiles.Foo parseFrom(com.google.protobuf.ByteString data, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException
{    return PARSER.parseFrom(data, extensionRegistry);}
104428f52c5a77fe7037ac76aecb2152862db40ac5c6cea54677806bbf82b227
parseFrom
public static org.apache.avro.protobuf.multiplefiles.Foo parseFrom(byte[] data) throws com.google.protobuf.InvalidProtocolBufferException
{    return PARSER.parseFrom(data);}
43e3f01f09eb7ba53025be5a81cddc2e25d00284b7712412db38b958122877aa
parseFrom
public static org.apache.avro.protobuf.multiplefiles.Foo parseFrom(byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException
{    return PARSER.parseFrom(data, extensionRegistry);}
098d60c35e1237d9a609f61aa737a5d3882bde207441100e548a3849d2be66a7
parseFrom
public static org.apache.avro.protobuf.multiplefiles.Foo parseFrom(java.io.InputStream input) throws java.io.IOException
{    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);}
54713efb8df305ef98bf6eeda3a648655e46db605a062381769a32734c9c2700
parseFrom
public static org.apache.avro.protobuf.multiplefiles.Foo parseFrom(java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException
{    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input, extensionRegistry);}
9a8204005744564ad6396aee05d17394e17e11044ebe20745eaa33d5ff0eed2e
parseDelimitedFrom
public static org.apache.avro.protobuf.multiplefiles.Foo parseDelimitedFrom(java.io.InputStream input) throws java.io.IOException
{    return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);}
2a86b500b886157e74259f4d5dcf5e5a1c49c4b5144e3b76c131d2982ba9eb98
parseDelimitedFrom
public static org.apache.avro.protobuf.multiplefiles.Foo parseDelimitedFrom(java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException
{    return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input, extensionRegistry);}
646d8b721dc923b8b143099a16eb29a91c2ee66385ffd9aa99877beb1bd6e67c
parseFrom
public static org.apache.avro.protobuf.multiplefiles.Foo parseFrom(com.google.protobuf.CodedInputStream input) throws java.io.IOException
{    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);}
488c1c8f8c06d51cdc6748f6cc024c13fae8d09e1a05d813ebf40468e616c743
parseFrom
public static org.apache.avro.protobuf.multiplefiles.Foo parseFrom(com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException
{    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input, extensionRegistry);}
a2589243249ba32b92e98298a2511019cd74b21c911d510f075da5ff7e8b6399
newBuilderForType
public Builder newBuilderForType()
{    return newBuilder();}
e32f866eb7533a232fadc4ef42bb022716435f415dc4a0f7ed4fff845f45ead0
newBuilder
public static Builder newBuilder()
{    return DEFAULT_INSTANCE.toBuilder();}
6cb94d5aa2340285491073423f3e9319e3212848e514fe84b74848f7f17e1988
newBuilder
public static Builder newBuilder(org.apache.avro.protobuf.multiplefiles.Foo prototype)
{    return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);}
8f9c3ced03d87377003831ec6560ea40c4b718fc762fc1ca14b030b0ed8256d4
toBuilder
public Builder toBuilder()
{    return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);}
4b6decb5ce35d0ce069dd647bca27ca9f81ed66925e1b833a3512177697f2d3b
newBuilderForType
protected Builder newBuilderForType(com.google.protobuf.GeneratedMessageV3.BuilderParent parent)
{    Builder builder = new Builder(parent);    return builder;}
e061a4269a7822f30b36dfe5c448257acd508bbe5bfe85e23841ca998b986e73
getDescriptor
public static final com.google.protobuf.Descriptors.Descriptor getDescriptor()
{    return org.apache.avro.protobuf.multiplefiles.TestMultipleFiles.internal_static_org_apache_avro_protobuf_multiplefiles_Foo_descriptor;}
09b927b3931a0c25b6621043bbd0a8b48cb113bfa27184d786c8e36653bca4dd
internalGetFieldAccessorTable
protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable internalGetFieldAccessorTable()
{    return org.apache.avro.protobuf.multiplefiles.TestMultipleFiles.internal_static_org_apache_avro_protobuf_multiplefiles_Foo_fieldAccessorTable.ensureFieldAccessorsInitialized(org.apache.avro.protobuf.multiplefiles.Foo.class, org.apache.avro.protobuf.multiplefiles.Foo.Builder.class);}
7c751d7a2accff7e718ee1e6ea5d2457fe6e182e8c39098e52a8848f56cf2cfe
maybeForceBuilderInitialization
private void maybeForceBuilderInitialization()
{    if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {        getFooArrayFieldBuilder();        getFooFieldBuilder();        getTimestampFieldBuilder();    }}
7930c451f279d9927ff235e4ac064561e1505f9b7ae117d9f681b345534ff9e3
clear
public Builder clear()
{    super.clear();    int32_ = 0;    bitField0_ = (bitField0_ & ~0x00000001);    int64_ = 0L;    bitField0_ = (bitField0_ & ~0x00000002);    uint32_ = 0;    bitField0_ = (bitField0_ & ~0x00000004);    uint64_ = 0L;    bitField0_ = (bitField0_ & ~0x00000008);    sint32_ = 0;    bitField0_ = (bitField0_ & ~0x00000010);    sint64_ = 0L;    bitField0_ = (bitField0_ & ~0x00000020);    fixed32_ = 0;    bitField0_ = (bitField0_ & ~0x00000040);    fixed64_ = 0L;    bitField0_ = (bitField0_ & ~0x00000080);    sfixed32_ = 0;    bitField0_ = (bitField0_ & ~0x00000100);    sfixed64_ = 0L;    bitField0_ = (bitField0_ & ~0x00000200);    float_ = 0F;    bitField0_ = (bitField0_ & ~0x00000400);    double_ = 0D;    bitField0_ = (bitField0_ & ~0x00000800);    bool_ = false;    bitField0_ = (bitField0_ & ~0x00001000);    string_ = "";    bitField0_ = (bitField0_ & ~0x00002000);    bytes_ = com.google.protobuf.ByteString.EMPTY;    bitField0_ = (bitField0_ & ~0x00004000);    enum_ = 3;    bitField0_ = (bitField0_ & ~0x00008000);    intArray_ = java.util.Collections.emptyList();    bitField0_ = (bitField0_ & ~0x00010000);    if (fooArrayBuilder_ == null) {        fooArray_ = java.util.Collections.emptyList();        bitField0_ = (bitField0_ & ~0x00020000);    } else {        fooArrayBuilder_.clear();    }    syms_ = java.util.Collections.emptyList();    bitField0_ = (bitField0_ & ~0x00040000);    if (fooBuilder_ == null) {        foo_ = null;    } else {        fooBuilder_.clear();    }    bitField0_ = (bitField0_ & ~0x00080000);    if (timestampBuilder_ == null) {        timestamp_ = null;    } else {        timestampBuilder_.clear();    }    bitField0_ = (bitField0_ & ~0x00100000);    return this;}
5a2efdcbff6cd8f893a197208cee010e41df6afb0e928da5d7126d953902ee30
getDescriptorForType
public com.google.protobuf.Descriptors.Descriptor getDescriptorForType()
{    return org.apache.avro.protobuf.multiplefiles.TestMultipleFiles.internal_static_org_apache_avro_protobuf_multiplefiles_Foo_descriptor;}
8bf40c57edbb37e0ada51b597d6d88194e21ff37a244db673ca3a562a2e11a25
getDefaultInstanceForType
public org.apache.avro.protobuf.multiplefiles.Foo getDefaultInstanceForType()
{    return org.apache.avro.protobuf.multiplefiles.Foo.getDefaultInstance();}
3ad336be2504bd931a451283a770475b83af89e07a80514ec35292859ac009dc
build
public org.apache.avro.protobuf.multiplefiles.Foo build()
{    org.apache.avro.protobuf.multiplefiles.Foo result = buildPartial();    if (!result.isInitialized()) {        throw newUninitializedMessageException(result);    }    return result;}
df3d6ef1e915f0a5b0a3d68d83c391202b6f38061739c2e25832203394253ca7
buildPartial
public org.apache.avro.protobuf.multiplefiles.Foo buildPartial()
{    org.apache.avro.protobuf.multiplefiles.Foo result = new org.apache.avro.protobuf.multiplefiles.Foo(this);    int from_bitField0_ = bitField0_;    int to_bitField0_ = 0;    if (((from_bitField0_ & 0x00000001) == 0x00000001)) {        to_bitField0_ |= 0x00000001;    }    result.int32_ = int32_;    if (((from_bitField0_ & 0x00000002) == 0x00000002)) {        to_bitField0_ |= 0x00000002;    }    result.int64_ = int64_;    if (((from_bitField0_ & 0x00000004) == 0x00000004)) {        to_bitField0_ |= 0x00000004;    }    result.uint32_ = uint32_;    if (((from_bitField0_ & 0x00000008) == 0x00000008)) {        to_bitField0_ |= 0x00000008;    }    result.uint64_ = uint64_;    if (((from_bitField0_ & 0x00000010) == 0x00000010)) {        to_bitField0_ |= 0x00000010;    }    result.sint32_ = sint32_;    if (((from_bitField0_ & 0x00000020) == 0x00000020)) {        to_bitField0_ |= 0x00000020;    }    result.sint64_ = sint64_;    if (((from_bitField0_ & 0x00000040) == 0x00000040)) {        to_bitField0_ |= 0x00000040;    }    result.fixed32_ = fixed32_;    if (((from_bitField0_ & 0x00000080) == 0x00000080)) {        to_bitField0_ |= 0x00000080;    }    result.fixed64_ = fixed64_;    if (((from_bitField0_ & 0x00000100) == 0x00000100)) {        to_bitField0_ |= 0x00000100;    }    result.sfixed32_ = sfixed32_;    if (((from_bitField0_ & 0x00000200) == 0x00000200)) {        to_bitField0_ |= 0x00000200;    }    result.sfixed64_ = sfixed64_;    if (((from_bitField0_ & 0x00000400) == 0x00000400)) {        to_bitField0_ |= 0x00000400;    }    result.float_ = float_;    if (((from_bitField0_ & 0x00000800) == 0x00000800)) {        to_bitField0_ |= 0x00000800;    }    result.double_ = double_;    if (((from_bitField0_ & 0x00001000) == 0x00001000)) {        to_bitField0_ |= 0x00001000;    }    result.bool_ = bool_;    if (((from_bitField0_ & 0x00002000) == 0x00002000)) {        to_bitField0_ |= 0x00002000;    }    result.string_ = string_;    if (((from_bitField0_ & 0x00004000) == 0x00004000)) {        to_bitField0_ |= 0x00004000;    }    result.bytes_ = bytes_;    if (((from_bitField0_ & 0x00008000) == 0x00008000)) {        to_bitField0_ |= 0x00008000;    }    result.enum_ = enum_;    if (((bitField0_ & 0x00010000) == 0x00010000)) {        intArray_ = java.util.Collections.unmodifiableList(intArray_);        bitField0_ = (bitField0_ & ~0x00010000);    }    result.intArray_ = intArray_;    if (fooArrayBuilder_ == null) {        if (((bitField0_ & 0x00020000) == 0x00020000)) {            fooArray_ = java.util.Collections.unmodifiableList(fooArray_);            bitField0_ = (bitField0_ & ~0x00020000);        }        result.fooArray_ = fooArray_;    } else {        result.fooArray_ = fooArrayBuilder_.build();    }    if (((bitField0_ & 0x00040000) == 0x00040000)) {        syms_ = java.util.Collections.unmodifiableList(syms_);        bitField0_ = (bitField0_ & ~0x00040000);    }    result.syms_ = syms_;    if (((from_bitField0_ & 0x00080000) == 0x00080000)) {        to_bitField0_ |= 0x00010000;    }    if (fooBuilder_ == null) {        result.foo_ = foo_;    } else {        result.foo_ = fooBuilder_.build();    }    if (((from_bitField0_ & 0x00100000) == 0x00100000)) {        to_bitField0_ |= 0x00020000;    }    if (timestampBuilder_ == null) {        result.timestamp_ = timestamp_;    } else {        result.timestamp_ = timestampBuilder_.build();    }    result.bitField0_ = to_bitField0_;    onBuilt();    return result;}
845fff95a97cf125489126ddee47248563aa80a59ed327d7d1c7cb9d90dcec30
clone
public Builder clone()
{    return (Builder) super.clone();}
e5d5cf46f7f9733e8968952c90ced36c482b5ce6c76f55f96b63b7864c44e8a9
setField
public Builder setField(com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value)
{    return (Builder) super.setField(field, value);}
7230780e7bd47d3ff1bfbd582401f62ac660c4cabdffea3399b812f0ca274023
clearField
public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field)
{    return (Builder) super.clearField(field);}
eb613a9109dd1960f829dd2a97c885c2dcb2e9e5c7eb1830f545fa78ca5217bb
clearOneof
public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof)
{    return (Builder) super.clearOneof(oneof);}
8b65fa0ba0250c27a1784d122c7e82f6a56893f4925b947cc87918e388ed11da
setRepeatedField
public Builder setRepeatedField(com.google.protobuf.Descriptors.FieldDescriptor field, int index, java.lang.Object value)
{    return (Builder) super.setRepeatedField(field, index, value);}
4c493ce9e20cef0f6973f189f8fcec07c11f7ec7a802fb3afe6f948f64f9ea0e
addRepeatedField
public Builder addRepeatedField(com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value)
{    return (Builder) super.addRepeatedField(field, value);}
9c02b14012758934fbc876f583b7201b524cfd4dce350a6fd2cdeea1bb86b6f9
mergeFrom
public Builder mergeFrom(com.google.protobuf.Message other)
{    if (other instanceof org.apache.avro.protobuf.multiplefiles.Foo) {        return mergeFrom((org.apache.avro.protobuf.multiplefiles.Foo) other);    } else {        super.mergeFrom(other);        return this;    }}
2b46de5045a226779ce9212dd810f45782f798ce3eb1e9934f1053f23c4ecc0a
mergeFrom
public Builder mergeFrom(org.apache.avro.protobuf.multiplefiles.Foo other)
{    if (other == org.apache.avro.protobuf.multiplefiles.Foo.getDefaultInstance())        return this;    if (other.hasInt32()) {        setInt32(other.getInt32());    }    if (other.hasInt64()) {        setInt64(other.getInt64());    }    if (other.hasUint32()) {        setUint32(other.getUint32());    }    if (other.hasUint64()) {        setUint64(other.getUint64());    }    if (other.hasSint32()) {        setSint32(other.getSint32());    }    if (other.hasSint64()) {        setSint64(other.getSint64());    }    if (other.hasFixed32()) {        setFixed32(other.getFixed32());    }    if (other.hasFixed64()) {        setFixed64(other.getFixed64());    }    if (other.hasSfixed32()) {        setSfixed32(other.getSfixed32());    }    if (other.hasSfixed64()) {        setSfixed64(other.getSfixed64());    }    if (other.hasFloat()) {        setFloat(other.getFloat());    }    if (other.hasDouble()) {        setDouble(other.getDouble());    }    if (other.hasBool()) {        setBool(other.getBool());    }    if (other.hasString()) {        bitField0_ |= 0x00002000;        string_ = other.string_;        onChanged();    }    if (other.hasBytes()) {        setBytes(other.getBytes());    }    if (other.hasEnum()) {        setEnum(other.getEnum());    }    if (!other.intArray_.isEmpty()) {        if (intArray_.isEmpty()) {            intArray_ = other.intArray_;            bitField0_ = (bitField0_ & ~0x00010000);        } else {            ensureIntArrayIsMutable();            intArray_.addAll(other.intArray_);        }        onChanged();    }    if (fooArrayBuilder_ == null) {        if (!other.fooArray_.isEmpty()) {            if (fooArray_.isEmpty()) {                fooArray_ = other.fooArray_;                bitField0_ = (bitField0_ & ~0x00020000);            } else {                ensureFooArrayIsMutable();                fooArray_.addAll(other.fooArray_);            }            onChanged();        }    } else {        if (!other.fooArray_.isEmpty()) {            if (fooArrayBuilder_.isEmpty()) {                fooArrayBuilder_.dispose();                fooArrayBuilder_ = null;                fooArray_ = other.fooArray_;                bitField0_ = (bitField0_ & ~0x00020000);                fooArrayBuilder_ = com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ? getFooArrayFieldBuilder() : null;            } else {                fooArrayBuilder_.addAllMessages(other.fooArray_);            }        }    }    if (!other.syms_.isEmpty()) {        if (syms_.isEmpty()) {            syms_ = other.syms_;            bitField0_ = (bitField0_ & ~0x00040000);        } else {            ensureSymsIsMutable();            syms_.addAll(other.syms_);        }        onChanged();    }    if (other.hasFoo()) {        mergeFoo(other.getFoo());    }    if (other.hasTimestamp()) {        mergeTimestamp(other.getTimestamp());    }    this.mergeUnknownFields(other.unknownFields);    onChanged();    return this;}
dde7cd718eaa61cad29906454acf122daba6680a2db55e4787a359a08951b5e7
isInitialized
public final boolean isInitialized()
{    if (!hasInt32()) {        return false;    }    for (int i = 0; i < getFooArrayCount(); i++) {        if (!getFooArray(i).isInitialized()) {            return false;        }    }    if (hasFoo()) {        if (!getFoo().isInitialized()) {            return false;        }    }    return true;}
576f0ac95d3431feb1ba705ec8f537aa5e5a58300021599ce7c111ed9b61d887
mergeFrom
public Builder mergeFrom(com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException
{    org.apache.avro.protobuf.multiplefiles.Foo parsedMessage = null;    try {        parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);    } catch (com.google.protobuf.InvalidProtocolBufferException e) {        parsedMessage = (org.apache.avro.protobuf.multiplefiles.Foo) e.getUnfinishedMessage();        throw e.unwrapIOException();    } finally {        if (parsedMessage != null) {            mergeFrom(parsedMessage);        }    }    return this;}
9a1647854ce456002dcb1c52139e88ef7a23a7d696936d56a15e6d4db0ccb184
hasInt32
public boolean hasInt32()
{    return ((bitField0_ & 0x00000001) == 0x00000001);}
636175cecf2b3f1c8415679f2f0b80d34ba9b63e238193298adf86af15007213
getInt32
public int getInt32()
{    return int32_;}
81a0371eba959f1ecd32cb15307daad2105ca67c981f449dd2465e979f28d7f5
setInt32
public Builder setInt32(int value)
{    bitField0_ |= 0x00000001;    int32_ = value;    onChanged();    return this;}
56200605ac882ae350dfcbc32edfaa63b9e576467f9b22d2bde343c3d345f37b
clearInt32
public Builder clearInt32()
{    bitField0_ = (bitField0_ & ~0x00000001);    int32_ = 0;    onChanged();    return this;}
a2c53766842c579522e01699c16d28ea58a1b49581f61187921336e4ce63b648
hasInt64
public boolean hasInt64()
{    return ((bitField0_ & 0x00000002) == 0x00000002);}
57c8339ea9b07d9b3113d12c4eae4a8a74f2ebd9a6de36dd3cfa42c148f186ab
getInt64
public long getInt64()
{    return int64_;}
8eed8ee04a9e41b5cc2974c805c1c3395268d0e413f05faaa4b2546ac984142e
setInt64
public Builder setInt64(long value)
{    bitField0_ |= 0x00000002;    int64_ = value;    onChanged();    return this;}
d7cbe4f48db39e8ccd041592df84bcdf5cc65c50d090b5426c71d28a99f17129
clearInt64
public Builder clearInt64()
{    bitField0_ = (bitField0_ & ~0x00000002);    int64_ = 0L;    onChanged();    return this;}
2e6ee41b2bb0d50e6b526adc77c21e06d72a1423b637a000776e01b5c2b60cfe
hasUint32
public boolean hasUint32()
{    return ((bitField0_ & 0x00000004) == 0x00000004);}
b7d2e4380f601c73ee0923b2fe9b521818c5ce75b743deec1d19ed294de77dd1
getUint32
public int getUint32()
{    return uint32_;}
9b9c227c619dac7b875f2888f63953096e6c6dfa845cb1bcd7bc63dae2d73d70
setUint32
public Builder setUint32(int value)
{    bitField0_ |= 0x00000004;    uint32_ = value;    onChanged();    return this;}
4b90f40aa6b7efb812a99ff0484ce06a265d29c3b5eef6838eb4108ec953d9aa
clearUint32
public Builder clearUint32()
{    bitField0_ = (bitField0_ & ~0x00000004);    uint32_ = 0;    onChanged();    return this;}
00e677ff71597cdf7ae7ab5e024a2eb75ff3d284223f3c6045ed6dd53e8d0845
hasUint64
public boolean hasUint64()
{    return ((bitField0_ & 0x00000008) == 0x00000008);}
b4b058bcc167225140afd471f432372421b25319080692aa857ca736719bc92b
getUint64
public long getUint64()
{    return uint64_;}
0b9fe6e9e4f205faf9340264b9ffcd8e1693ed31106e622b27cd5e32375604d7
setUint64
public Builder setUint64(long value)
{    bitField0_ |= 0x00000008;    uint64_ = value;    onChanged();    return this;}
12975d8fa7519ad7270a7a744b24993e6f46f552721816145c7437c49037f105
clearUint64
public Builder clearUint64()
{    bitField0_ = (bitField0_ & ~0x00000008);    uint64_ = 0L;    onChanged();    return this;}
2e93fdc6d6c8b20576cd9a0e9d1e183d33569ed069463a98ad5ec167a29d6e14
hasSint32
public boolean hasSint32()
{    return ((bitField0_ & 0x00000010) == 0x00000010);}
75b5ac5769aad1f59a8c73b0547c0c77fc4c170b9c72844230175c2a4ba06ad5
getSint32
public int getSint32()
{    return sint32_;}
ab8018338a5f1892c17aebbaba1649ef95d18c3736984064933ddd33629ea4ee
setSint32
public Builder setSint32(int value)
{    bitField0_ |= 0x00000010;    sint32_ = value;    onChanged();    return this;}
4879a6d592bc9436e3dabe35c9117c97c1cb9ee56afceed068a9744dab9a5452
clearSint32
public Builder clearSint32()
{    bitField0_ = (bitField0_ & ~0x00000010);    sint32_ = 0;    onChanged();    return this;}
31fdd75033679196631750b698981d6dcc9537d93c151d7cbcd4ca46de9d58aa
hasSint64
public boolean hasSint64()
{    return ((bitField0_ & 0x00000020) == 0x00000020);}
75d70e1b7a60651a143d6564f9b40443b64654c71ee48cc41a68029e8c436e18
getSint64
public long getSint64()
{    return sint64_;}
facea82b59c06bf1c2e70535f1f3817dfb44cc5e96a0568f35685220cdcf644c
setSint64
public Builder setSint64(long value)
{    bitField0_ |= 0x00000020;    sint64_ = value;    onChanged();    return this;}
c1c1a8640694d59dc2a48010abcfcdc9947d1876a96791dfd44c658a90fd0878
clearSint64
public Builder clearSint64()
{    bitField0_ = (bitField0_ & ~0x00000020);    sint64_ = 0L;    onChanged();    return this;}
ad9c191d2d327991d4d5c3dea893bb9a901eb34f81ccfc40c50706ef79c1760a
hasFixed32
public boolean hasFixed32()
{    return ((bitField0_ & 0x00000040) == 0x00000040);}
98f6f07472f43870759b408f82612481ade75d1e14ccc2226cec24b686f55050
getFixed32
public int getFixed32()
{    return fixed32_;}
a1188d424119d82835418db265ce43ed3325de207f80da692087d2878e0cb183
setFixed32
public Builder setFixed32(int value)
{    bitField0_ |= 0x00000040;    fixed32_ = value;    onChanged();    return this;}
27bc19cb5785a4835c0e7f550535599d08c3c7b6ffe8f9b6f9e27228c40cce44
clearFixed32
public Builder clearFixed32()
{    bitField0_ = (bitField0_ & ~0x00000040);    fixed32_ = 0;    onChanged();    return this;}
4a6662d0d6f52e9e2b217aaeb86a991de741e56d2eeb146d3d43652fe51a5326
hasFixed64
public boolean hasFixed64()
{    return ((bitField0_ & 0x00000080) == 0x00000080);}
8b9413171a22273aafb43565effc2135094288b4e3333b3afd1e37e629f68fb0
getFixed64
public long getFixed64()
{    return fixed64_;}
d7cbeffb5bab7357bc2adfe1d5717f9386db73d7a92b1a23517bb00a6909eec1
setFixed64
public Builder setFixed64(long value)
{    bitField0_ |= 0x00000080;    fixed64_ = value;    onChanged();    return this;}
59138d31306c5a51cc7106458a758dd21eef639beb5a8b3be984e708f3d6355a
clearFixed64
public Builder clearFixed64()
{    bitField0_ = (bitField0_ & ~0x00000080);    fixed64_ = 0L;    onChanged();    return this;}
41a3547ab4b509363c785a59db522a034320a04eecd00bf28bcc5250c8636cd8
hasSfixed32
public boolean hasSfixed32()
{    return ((bitField0_ & 0x00000100) == 0x00000100);}
64daf2c2e759b26fa9445cc4f9caba82b1aa8040416bdf77dc86a976ef8ede0d
getSfixed32
public int getSfixed32()
{    return sfixed32_;}
d3c4b1daa2e69ca8b5447fc8774096fb219004bc57ed4d66b72fef810068b51c
setSfixed32
public Builder setSfixed32(int value)
{    bitField0_ |= 0x00000100;    sfixed32_ = value;    onChanged();    return this;}
453dfd5d4046ef4007c21067998c64e3fdb0022e31a264a08bc4309639de0279
clearSfixed32
public Builder clearSfixed32()
{    bitField0_ = (bitField0_ & ~0x00000100);    sfixed32_ = 0;    onChanged();    return this;}
45f1bf05257c7a952854e866f6a67f13b5c039f4e8c25738e069ed51eb6f63cf
hasSfixed64
public boolean hasSfixed64()
{    return ((bitField0_ & 0x00000200) == 0x00000200);}
20f25f0e34849b2bce430689f850be46b02bd3b74ea8c5a77b60c18c791e6a64
getSfixed64
public long getSfixed64()
{    return sfixed64_;}
61f714cda299c18e9a6c46c8c4148312448a277d4a872f45316e3f42adc59cac
setSfixed64
public Builder setSfixed64(long value)
{    bitField0_ |= 0x00000200;    sfixed64_ = value;    onChanged();    return this;}
17cfef9c8f2aae31136186277c09db367b1371341034548518d718317d9ee600
clearSfixed64
public Builder clearSfixed64()
{    bitField0_ = (bitField0_ & ~0x00000200);    sfixed64_ = 0L;    onChanged();    return this;}
0cb9fb07dff4d2bfa7ae4bf0843e71fa5fb3d03c06b07c7d2a717ec089d0767e
hasFloat
public boolean hasFloat()
{    return ((bitField0_ & 0x00000400) == 0x00000400);}
ee9a51dbf95b211d37a60138ffb4deb11942d61f5c9721afa1016727fb401415
getFloat
public float getFloat()
{    return float_;}
8b73e0228ee33fc38e9121d5e2b2177e662314e9638c2398f8f1b9b3de2dee6a
setFloat
public Builder setFloat(float value)
{    bitField0_ |= 0x00000400;    float_ = value;    onChanged();    return this;}
38d9c541e25c75f840a4f31457a3d98a878fc6c533d846e09d38a0d8d08802d7
clearFloat
public Builder clearFloat()
{    bitField0_ = (bitField0_ & ~0x00000400);    float_ = 0F;    onChanged();    return this;}
e28f40a1dd04174c7100c4112d5ed5b5772e98d43d41f2d671ff567e0f4c6ce5
hasDouble
public boolean hasDouble()
{    return ((bitField0_ & 0x00000800) == 0x00000800);}
95f35c6fbf999bf94e0a9c9c5fa482ed65318ab2572fb3b51e8c181fc2611e97
getDouble
public double getDouble()
{    return double_;}
3d668ab6408ef82ed76027849099060f25f30f99efb9ec1af6053caad88c7e16
setDouble
public Builder setDouble(double value)
{    bitField0_ |= 0x00000800;    double_ = value;    onChanged();    return this;}
d103bd983f690a8d518d2cace9de4d587b198c50ae08498dfd64bfdc10b2d7b9
clearDouble
public Builder clearDouble()
{    bitField0_ = (bitField0_ & ~0x00000800);    double_ = 0D;    onChanged();    return this;}
586ca0c2bb6da45de72704084c6e31b535779b9f3166053de6d5c3114e808751
hasBool
public boolean hasBool()
{    return ((bitField0_ & 0x00001000) == 0x00001000);}
f5d970ff55271bea91b285c75a149e090505eb675c4e8194d9e1e500461f90e8
getBool
public boolean getBool()
{    return bool_;}
e7aa78c3b4280641a1e8e4e7af85adaae7f0050998637ba3acc2f5ec4ef26044
setBool
public Builder setBool(boolean value)
{    bitField0_ |= 0x00001000;    bool_ = value;    onChanged();    return this;}
ca8d354815dd275a5c4fd9c8c006006e341beb3ebf998f97c0ad574333231f04
clearBool
public Builder clearBool()
{    bitField0_ = (bitField0_ & ~0x00001000);    bool_ = false;    onChanged();    return this;}
3f0c31e577682520c0fcca7daaaf896b908ba830b55ce04569418803a52cead8
hasString
public boolean hasString()
{    return ((bitField0_ & 0x00002000) == 0x00002000);}
7c4c17115810ae3f13bf8deca5f5267c8cb89c0f70fafecb78a67ebd65ae6b37
getString
public java.lang.String getString()
{    java.lang.Object ref = string_;    if (!(ref instanceof java.lang.String)) {        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;        java.lang.String s = bs.toStringUtf8();        if (bs.isValidUtf8()) {            string_ = s;        }        return s;    } else {        return (java.lang.String) ref;    }}
404c2340dc76857ee9b3d6bb2a82a6697881da7fa911e1d8af649f5b71248a3a
getStringBytes
public com.google.protobuf.ByteString getStringBytes()
{    java.lang.Object ref = string_;    if (ref instanceof String) {        com.google.protobuf.ByteString b = com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);        string_ = b;        return b;    } else {        return (com.google.protobuf.ByteString) ref;    }}
2ff4df9a7941fbd2b7640f32e30714e499206cde93d7dd3a51b702ee122f1da8
setString
public Builder setString(java.lang.String value)
{    if (value == null) {        throw new NullPointerException();    }    bitField0_ |= 0x00002000;    string_ = value;    onChanged();    return this;}
503c7445bfed06cdac3042eca742fb37d6b83a99d3baaadbe2eaeea1e97200d7
clearString
public Builder clearString()
{    bitField0_ = (bitField0_ & ~0x00002000);    string_ = getDefaultInstance().getString();    onChanged();    return this;}
24dfea53c0f7d39e2b616898458ae4a0d2195bb2b40bb355b9982d3549224623
setStringBytes
public Builder setStringBytes(com.google.protobuf.ByteString value)
{    if (value == null) {        throw new NullPointerException();    }    bitField0_ |= 0x00002000;    string_ = value;    onChanged();    return this;}
75a99db492c7f97c17d6844f9a82e00a4b1f11fd35d8ea25d7d55a21df04ad6a
hasBytes
public boolean hasBytes()
{    return ((bitField0_ & 0x00004000) == 0x00004000);}
d6cf6f44c45e7e724dce80e785110e2196522fe8c0a756ce8d5e75c119e561c5
getBytes
public com.google.protobuf.ByteString getBytes()
{    return bytes_;}
88eed676a0332210956dc7d6eb83802233e3b27eb4738fba09fbddbd029276a0
setBytes
public Builder setBytes(com.google.protobuf.ByteString value)
{    if (value == null) {        throw new NullPointerException();    }    bitField0_ |= 0x00004000;    bytes_ = value;    onChanged();    return this;}
a54f936ae686d9860ce0eb0ece5f75fc284228a1bed7e0bc25830206169c750b
clearBytes
public Builder clearBytes()
{    bitField0_ = (bitField0_ & ~0x00004000);    bytes_ = getDefaultInstance().getBytes();    onChanged();    return this;}
698a189fcb3c994fa12118569041c84a5d6176385eb353c702935c048c13d88b
hasEnum
public boolean hasEnum()
{    return ((bitField0_ & 0x00008000) == 0x00008000);}
9aff2bb5f0c612590f6b4d622aacce1b5cccf91cff821587982a1af995539a11
getEnum
public org.apache.avro.protobuf.multiplefiles.A getEnum()
{    org.apache.avro.protobuf.multiplefiles.A result = org.apache.avro.protobuf.multiplefiles.A.valueOf(enum_);    return result == null ? org.apache.avro.protobuf.multiplefiles.A.Z : result;}
b94b7345b595075096a889e463e3e8ea07ba6154d48f6272baac90fcbc56aeb4
setEnum
public Builder setEnum(org.apache.avro.protobuf.multiplefiles.A value)
{    if (value == null) {        throw new NullPointerException();    }    bitField0_ |= 0x00008000;    enum_ = value.getNumber();    onChanged();    return this;}
c525157ec8955cc2e0945126e42e2298c7c37ccf5375131361a90908a6f1f43d
clearEnum
public Builder clearEnum()
{    bitField0_ = (bitField0_ & ~0x00008000);    enum_ = 3;    onChanged();    return this;}
390283023049eb4d4b452ab416152e55eb7d57a5c96af183244e4fb45d8f1a83
ensureIntArrayIsMutable
private void ensureIntArrayIsMutable()
{    if (!((bitField0_ & 0x00010000) == 0x00010000)) {        intArray_ = new java.util.ArrayList<java.lang.Integer>(intArray_);        bitField0_ |= 0x00010000;    }}
0dbd424bbcce9aded3aad4770c8ffb4c32f758322b180e89d544aa54302c6728
getIntArrayList
public java.util.List<java.lang.Integer> getIntArrayList()
{    return java.util.Collections.unmodifiableList(intArray_);}
31b4697dd384dd0bd1bde310af3b62067c0a1ad32cc543d5063825eeb8bd56b3
getIntArrayCount
public int getIntArrayCount()
{    return intArray_.size();}
2e098f94a8cd1017c27e6f532faec1cc3c3f5529d9acf62fca5795b2889dd67a
getIntArray
public int getIntArray(int index)
{    return intArray_.get(index);}
6249e7d548a1302ad9afbb6d2537ef456e1c60bf1d14167ff7f0edafce388a17
setIntArray
public Builder setIntArray(int index, int value)
{    ensureIntArrayIsMutable();    intArray_.set(index, value);    onChanged();    return this;}
a35c81259e2605db9d967f4f9b9cad81895478a00d3840922f3837b89a294248
addIntArray
public Builder addIntArray(int value)
{    ensureIntArrayIsMutable();    intArray_.add(value);    onChanged();    return this;}
9b7bf02c1b239538eec8b27663b8c805b5244492ac65d601b1996e237840c6f5
addAllIntArray
public Builder addAllIntArray(java.lang.Iterable<? extends java.lang.Integer> values)
{    ensureIntArrayIsMutable();    com.google.protobuf.AbstractMessageLite.Builder.addAll(values, intArray_);    onChanged();    return this;}
254c5f68ef783db246155ff9a5672dc2500cbcdcd3a4316e985f1943fe79d6bc
clearIntArray
public Builder clearIntArray()
{    intArray_ = java.util.Collections.emptyList();    bitField0_ = (bitField0_ & ~0x00010000);    onChanged();    return this;}
5ee8e5ab40d600b7fdec08e36ee5a503cbfac187f12dd459945545210f8686e3
ensureFooArrayIsMutable
private void ensureFooArrayIsMutable()
{    if (!((bitField0_ & 0x00020000) == 0x00020000)) {        fooArray_ = new java.util.ArrayList<org.apache.avro.protobuf.multiplefiles.Foo>(fooArray_);        bitField0_ |= 0x00020000;    }}
c6456ed2383ccd59fd746b564e053b7f6ca2a4343bbdaca5d596e3f9a3e89f02
getFooArrayList
public java.util.List<org.apache.avro.protobuf.multiplefiles.Foo> getFooArrayList()
{    if (fooArrayBuilder_ == null) {        return java.util.Collections.unmodifiableList(fooArray_);    } else {        return fooArrayBuilder_.getMessageList();    }}
fd2ac97f74deac4a599110fe63068fdd22b2fde4ae9928305d79d7d01629765c
getFooArrayCount
public int getFooArrayCount()
{    if (fooArrayBuilder_ == null) {        return fooArray_.size();    } else {        return fooArrayBuilder_.getCount();    }}
57d90d3ca040e9eedf6245b46f994a8ce63fd37f82ffdb43229d6ee06cfda5d2
getFooArray
public org.apache.avro.protobuf.multiplefiles.Foo getFooArray(int index)
{    if (fooArrayBuilder_ == null) {        return fooArray_.get(index);    } else {        return fooArrayBuilder_.getMessage(index);    }}
ea8adce3e225461fca1a8cb1ba02f888ea8fba1d6b8e57549d2753dbce8e8357
setFooArray
public Builder setFooArray(int index, org.apache.avro.protobuf.multiplefiles.Foo value)
{    if (fooArrayBuilder_ == null) {        if (value == null) {            throw new NullPointerException();        }        ensureFooArrayIsMutable();        fooArray_.set(index, value);        onChanged();    } else {        fooArrayBuilder_.setMessage(index, value);    }    return this;}
bcb60a98f0ead4dd9d7697bf7b64fc78ad4e67c2294b0644c5de736dd4e26b7b
setFooArray
public Builder setFooArray(int index, org.apache.avro.protobuf.multiplefiles.Foo.Builder builderForValue)
{    if (fooArrayBuilder_ == null) {        ensureFooArrayIsMutable();        fooArray_.set(index, builderForValue.build());        onChanged();    } else {        fooArrayBuilder_.setMessage(index, builderForValue.build());    }    return this;}
b2f9e3a2b0df8dfc9a63c027d88e78fb67b49c99dd53056334a73dabc32facb6
addFooArray
public Builder addFooArray(org.apache.avro.protobuf.multiplefiles.Foo value)
{    if (fooArrayBuilder_ == null) {        if (value == null) {            throw new NullPointerException();        }        ensureFooArrayIsMutable();        fooArray_.add(value);        onChanged();    } else {        fooArrayBuilder_.addMessage(value);    }    return this;}
ad035570043124d3222df1d26fa0404cc0d697cbe0ceea05220aaa9bd89f1fb6
addFooArray
public Builder addFooArray(int index, org.apache.avro.protobuf.multiplefiles.Foo value)
{    if (fooArrayBuilder_ == null) {        if (value == null) {            throw new NullPointerException();        }        ensureFooArrayIsMutable();        fooArray_.add(index, value);        onChanged();    } else {        fooArrayBuilder_.addMessage(index, value);    }    return this;}
fb0c29d3a54cdf7e2fd8b37287cd5b69e10e5818e1c5195689ad24b59cba8768
addFooArray
public Builder addFooArray(org.apache.avro.protobuf.multiplefiles.Foo.Builder builderForValue)
{    if (fooArrayBuilder_ == null) {        ensureFooArrayIsMutable();        fooArray_.add(builderForValue.build());        onChanged();    } else {        fooArrayBuilder_.addMessage(builderForValue.build());    }    return this;}
45e558bbb7fcaa9b266a6822f86b9881134726e36a06f156f2516e86d20618b0
addFooArray
public Builder addFooArray(int index, org.apache.avro.protobuf.multiplefiles.Foo.Builder builderForValue)
{    if (fooArrayBuilder_ == null) {        ensureFooArrayIsMutable();        fooArray_.add(index, builderForValue.build());        onChanged();    } else {        fooArrayBuilder_.addMessage(index, builderForValue.build());    }    return this;}
eb132446f39e887f4d0106875ebcf8ddc0568dfaa9c3db815413fd8854966b7f
addAllFooArray
public Builder addAllFooArray(java.lang.Iterable<? extends org.apache.avro.protobuf.multiplefiles.Foo> values)
{    if (fooArrayBuilder_ == null) {        ensureFooArrayIsMutable();        com.google.protobuf.AbstractMessageLite.Builder.addAll(values, fooArray_);        onChanged();    } else {        fooArrayBuilder_.addAllMessages(values);    }    return this;}
8bf91b917867b7d5c9076c48559b33c4c9dd3b0cdf4a307d8f982c1090ed03c2
clearFooArray
public Builder clearFooArray()
{    if (fooArrayBuilder_ == null) {        fooArray_ = java.util.Collections.emptyList();        bitField0_ = (bitField0_ & ~0x00020000);        onChanged();    } else {        fooArrayBuilder_.clear();    }    return this;}
cfa5b40f118d0917714c4eb7f75820077e2a60507503c64b6779eb73e92bd8a7
removeFooArray
public Builder removeFooArray(int index)
{    if (fooArrayBuilder_ == null) {        ensureFooArrayIsMutable();        fooArray_.remove(index);        onChanged();    } else {        fooArrayBuilder_.remove(index);    }    return this;}
c59f040f94c9cd1246352cc222049a22f58312091ac1364ed730c0a744577cdd
getFooArrayBuilder
public org.apache.avro.protobuf.multiplefiles.Foo.Builder getFooArrayBuilder(int index)
{    return getFooArrayFieldBuilder().getBuilder(index);}
427d982b1b134ac42b5ac669ea5d84eff2a2d4e3f10b9ea0d2ac57ec732e2928
getFooArrayOrBuilder
public org.apache.avro.protobuf.multiplefiles.FooOrBuilder getFooArrayOrBuilder(int index)
{    if (fooArrayBuilder_ == null) {        return fooArray_.get(index);    } else {        return fooArrayBuilder_.getMessageOrBuilder(index);    }}
6b433a5251a4fce25b1ce49190a7f475a7e888dd4f8db4c4ac154a73bfdef795
getFooArrayOrBuilderList
public java.util.List<? extends org.apache.avro.protobuf.multiplefiles.FooOrBuilder> getFooArrayOrBuilderList()
{    if (fooArrayBuilder_ != null) {        return fooArrayBuilder_.getMessageOrBuilderList();    } else {        return java.util.Collections.unmodifiableList(fooArray_);    }}
22b28e68634ab8ce75d97510e0f4c7f8c0f19894a85e50180772e245d6a689df
addFooArrayBuilder
public org.apache.avro.protobuf.multiplefiles.Foo.Builder addFooArrayBuilder()
{    return getFooArrayFieldBuilder().addBuilder(org.apache.avro.protobuf.multiplefiles.Foo.getDefaultInstance());}
7fa6a53b7cce5a6b678e11b58eac7d2fa50058b33991decfd6d557b6348d0e2b
addFooArrayBuilder
public org.apache.avro.protobuf.multiplefiles.Foo.Builder addFooArrayBuilder(int index)
{    return getFooArrayFieldBuilder().addBuilder(index, org.apache.avro.protobuf.multiplefiles.Foo.getDefaultInstance());}
22ee47fe8a0626c88359df9cdeeb90c4c3edea3e2c951d04b466c7a31e9d95c5
getFooArrayBuilderList
public java.util.List<org.apache.avro.protobuf.multiplefiles.Foo.Builder> getFooArrayBuilderList()
{    return getFooArrayFieldBuilder().getBuilderList();}
2d006509b68827751d2f508b8e5ecaec7466b641b3fdf82b5c7f23a9001b06bc
getFooArrayFieldBuilder
private com.google.protobuf.RepeatedFieldBuilderV3<org.apache.avro.protobuf.multiplefiles.Foo, org.apache.avro.protobuf.multiplefiles.Foo.Builder, org.apache.avro.protobuf.multiplefiles.FooOrBuilder> getFooArrayFieldBuilder()
{    if (fooArrayBuilder_ == null) {        fooArrayBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<org.apache.avro.protobuf.multiplefiles.Foo, org.apache.avro.protobuf.multiplefiles.Foo.Builder, org.apache.avro.protobuf.multiplefiles.FooOrBuilder>(fooArray_, ((bitField0_ & 0x00020000) == 0x00020000), getParentForChildren(), isClean());        fooArray_ = null;    }    return fooArrayBuilder_;}
d552a07945f510005d12bd021ba3808b9b70a38d5130a7aaaacd3f06f40df266
ensureSymsIsMutable
private void ensureSymsIsMutable()
{    if (!((bitField0_ & 0x00040000) == 0x00040000)) {        syms_ = new java.util.ArrayList<java.lang.Integer>(syms_);        bitField0_ |= 0x00040000;    }}
d4b23b07911a22d016081a2aa46fe029c93723f5dc6e06989594370080efbe73
getSymsList
public java.util.List<org.apache.avro.protobuf.multiplefiles.A> getSymsList()
{    return new com.google.protobuf.Internal.ListAdapter<java.lang.Integer, org.apache.avro.protobuf.multiplefiles.A>(syms_, syms_converter_);}
184c0551fc5d1c2cbff289a02240b91ff20c32be2e794e0f47a61014a4b8d156
getSymsCount
public int getSymsCount()
{    return syms_.size();}
40211f2c387f8455891659e5b276c6f20b6df3129e52b61444d8e68ef03a2bee
getSyms
public org.apache.avro.protobuf.multiplefiles.A getSyms(int index)
{    return syms_converter_.convert(syms_.get(index));}
9afd1ef59e36bdf436427626f2c8ab6513734d93b63a2d427445b44616d21caa
setSyms
public Builder setSyms(int index, org.apache.avro.protobuf.multiplefiles.A value)
{    if (value == null) {        throw new NullPointerException();    }    ensureSymsIsMutable();    syms_.set(index, value.getNumber());    onChanged();    return this;}
869d832c7b39caaf99b0315dcc6cefee2f0e1a6f30dd5be16ffb33904e89365d
addSyms
public Builder addSyms(org.apache.avro.protobuf.multiplefiles.A value)
{    if (value == null) {        throw new NullPointerException();    }    ensureSymsIsMutable();    syms_.add(value.getNumber());    onChanged();    return this;}
3e73897e1225f82bfae5e38354bb1644ba30fb2cd1153b5d14704921fe59e365
addAllSyms
public Builder addAllSyms(java.lang.Iterable<? extends org.apache.avro.protobuf.multiplefiles.A> values)
{    ensureSymsIsMutable();    for (org.apache.avro.protobuf.multiplefiles.A value : values) {        syms_.add(value.getNumber());    }    onChanged();    return this;}
6e95a5be67fe5a5696be8b576419149af2bc6e790ab52b29cefb65a031819de9
clearSyms
public Builder clearSyms()
{    syms_ = java.util.Collections.emptyList();    bitField0_ = (bitField0_ & ~0x00040000);    onChanged();    return this;}
10058f491b0a4a5c22162369389d3ed8276668e2d04db758b35d31010e7e4677
hasFoo
public boolean hasFoo()
{    return ((bitField0_ & 0x00080000) == 0x00080000);}
1c42cde0529cde40036707fb76752ff3cacdd9f1f873ec2a6f368f4c22f8f04a
getFoo
public org.apache.avro.protobuf.multiplefiles.Foo getFoo()
{    if (fooBuilder_ == null) {        return foo_ == null ? org.apache.avro.protobuf.multiplefiles.Foo.getDefaultInstance() : foo_;    } else {        return fooBuilder_.getMessage();    }}
81fd2f0cfc6b5a0339e616a0947631f23078f122f74b05a5b6b27640b8287d51
setFoo
public Builder setFoo(org.apache.avro.protobuf.multiplefiles.Foo value)
{    if (fooBuilder_ == null) {        if (value == null) {            throw new NullPointerException();        }        foo_ = value;        onChanged();    } else {        fooBuilder_.setMessage(value);    }    bitField0_ |= 0x00080000;    return this;}
af1d9689d519114f8ea9cf8bdac5eb79019a7d76a6719ef2e2c7b2382a4feed5
setFoo
public Builder setFoo(org.apache.avro.protobuf.multiplefiles.Foo.Builder builderForValue)
{    if (fooBuilder_ == null) {        foo_ = builderForValue.build();        onChanged();    } else {        fooBuilder_.setMessage(builderForValue.build());    }    bitField0_ |= 0x00080000;    return this;}
a279173b85e6e777cfd1ef4075abc4f5725a8ba558167aaa81530a2e642e8b1e
mergeFoo
public Builder mergeFoo(org.apache.avro.protobuf.multiplefiles.Foo value)
{    if (fooBuilder_ == null) {        if (((bitField0_ & 0x00080000) == 0x00080000) && foo_ != null && foo_ != org.apache.avro.protobuf.multiplefiles.Foo.getDefaultInstance()) {            foo_ = org.apache.avro.protobuf.multiplefiles.Foo.newBuilder(foo_).mergeFrom(value).buildPartial();        } else {            foo_ = value;        }        onChanged();    } else {        fooBuilder_.mergeFrom(value);    }    bitField0_ |= 0x00080000;    return this;}
0f7dd4f625bb65449bbe2e1c488eb3c5e1aeb9d18a66edd0456b591f20723ac2
clearFoo
public Builder clearFoo()
{    if (fooBuilder_ == null) {        foo_ = null;        onChanged();    } else {        fooBuilder_.clear();    }    bitField0_ = (bitField0_ & ~0x00080000);    return this;}
b366a15fd2fecece9284e0d157417e0c44f725ff2a3ee1ac2089b295b8fe0e8e
getFooBuilder
public org.apache.avro.protobuf.multiplefiles.Foo.Builder getFooBuilder()
{    bitField0_ |= 0x00080000;    onChanged();    return getFooFieldBuilder().getBuilder();}
855632a379855b3107f294117ed487982590ca87c6ea5bb9c30f480c59b10cb1
getFooOrBuilder
public org.apache.avro.protobuf.multiplefiles.FooOrBuilder getFooOrBuilder()
{    if (fooBuilder_ != null) {        return fooBuilder_.getMessageOrBuilder();    } else {        return foo_ == null ? org.apache.avro.protobuf.multiplefiles.Foo.getDefaultInstance() : foo_;    }}
310ea03fbf5b955193cad13fddf59f0728e2e2420b94232f13e3a511f6e11c22
getFooFieldBuilder
private com.google.protobuf.SingleFieldBuilderV3<org.apache.avro.protobuf.multiplefiles.Foo, org.apache.avro.protobuf.multiplefiles.Foo.Builder, org.apache.avro.protobuf.multiplefiles.FooOrBuilder> getFooFieldBuilder()
{    if (fooBuilder_ == null) {        fooBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<org.apache.avro.protobuf.multiplefiles.Foo, org.apache.avro.protobuf.multiplefiles.Foo.Builder, org.apache.avro.protobuf.multiplefiles.FooOrBuilder>(getFoo(), getParentForChildren(), isClean());        foo_ = null;    }    return fooBuilder_;}
bafb11dbca36e09bf79e4baa90c93a1bc1422a322f7ad686efa10ecb036831b5
hasTimestamp
public boolean hasTimestamp()
{    return ((bitField0_ & 0x00100000) == 0x00100000);}
c66f064664f32c706c67564ca4c770ad74baa2e4df0c3a6eccb1177407cc2c5e
getTimestamp
public com.google.protobuf.Timestamp getTimestamp()
{    if (timestampBuilder_ == null) {        return timestamp_ == null ? com.google.protobuf.Timestamp.getDefaultInstance() : timestamp_;    } else {        return timestampBuilder_.getMessage();    }}
55a39ac3f0a927983a1c3888166d7528a4c9aa21e32fece7e8fff2c136c48178
setTimestamp
public Builder setTimestamp(com.google.protobuf.Timestamp value)
{    if (timestampBuilder_ == null) {        if (value == null) {            throw new NullPointerException();        }        timestamp_ = value;        onChanged();    } else {        timestampBuilder_.setMessage(value);    }    bitField0_ |= 0x00100000;    return this;}
e5066f7ba625cc4e4254f726ba7a91a8dedc2ae5e1802f433d1c6954a5b83d99
setTimestamp
public Builder setTimestamp(com.google.protobuf.Timestamp.Builder builderForValue)
{    if (timestampBuilder_ == null) {        timestamp_ = builderForValue.build();        onChanged();    } else {        timestampBuilder_.setMessage(builderForValue.build());    }    bitField0_ |= 0x00100000;    return this;}
ba1d95f2cd261e974784c52e4c028bdea11c6edfceb3355834e01e9d4f2cc909
mergeTimestamp
public Builder mergeTimestamp(com.google.protobuf.Timestamp value)
{    if (timestampBuilder_ == null) {        if (((bitField0_ & 0x00100000) == 0x00100000) && timestamp_ != null && timestamp_ != com.google.protobuf.Timestamp.getDefaultInstance()) {            timestamp_ = com.google.protobuf.Timestamp.newBuilder(timestamp_).mergeFrom(value).buildPartial();        } else {            timestamp_ = value;        }        onChanged();    } else {        timestampBuilder_.mergeFrom(value);    }    bitField0_ |= 0x00100000;    return this;}
ea6e39b94b17e7825f2c3e2bac3436f7c97b6b56562dbd771a5e799c372942be
clearTimestamp
public Builder clearTimestamp()
{    if (timestampBuilder_ == null) {        timestamp_ = null;        onChanged();    } else {        timestampBuilder_.clear();    }    bitField0_ = (bitField0_ & ~0x00100000);    return this;}
e1f1395458d6fb670f001c844aab49b357be1a902730cc855ecee5ba6b3b8b38
getTimestampBuilder
public com.google.protobuf.Timestamp.Builder getTimestampBuilder()
{    bitField0_ |= 0x00100000;    onChanged();    return getTimestampFieldBuilder().getBuilder();}
1a895b7c2c7d5a9cb1b98abc55c3ddb581f84797f811e5056403cde4d040aebb
getTimestampOrBuilder
public com.google.protobuf.TimestampOrBuilder getTimestampOrBuilder()
{    if (timestampBuilder_ != null) {        return timestampBuilder_.getMessageOrBuilder();    } else {        return timestamp_ == null ? com.google.protobuf.Timestamp.getDefaultInstance() : timestamp_;    }}
9f09eeb20bd3b040cce8ad189bc4a1c3382c9e3f370690a6142484d958da78e7
getTimestampFieldBuilder
private com.google.protobuf.SingleFieldBuilderV3<com.google.protobuf.Timestamp, com.google.protobuf.Timestamp.Builder, com.google.protobuf.TimestampOrBuilder> getTimestampFieldBuilder()
{    if (timestampBuilder_ == null) {        timestampBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<com.google.protobuf.Timestamp, com.google.protobuf.Timestamp.Builder, com.google.protobuf.TimestampOrBuilder>(getTimestamp(), getParentForChildren(), isClean());        timestamp_ = null;    }    return timestampBuilder_;}
c3f82e9354e0de24294e8d24ddd4cc78edfdbc227b0b6784774ae4f90f8803a5
setUnknownFields
public final Builder setUnknownFields(final com.google.protobuf.UnknownFieldSet unknownFields)
{    return super.setUnknownFields(unknownFields);}
112ef20f9bae5594feab16e3416756e8f3a1b669246aa50338f4c67470eebe6a
mergeUnknownFields
public final Builder mergeUnknownFields(final com.google.protobuf.UnknownFieldSet unknownFields)
{    return super.mergeUnknownFields(unknownFields);}
c38e5f9c00756fb03ef7da060e9c6757fc567a4815fdce72864f98e757cb46f4
getDefaultInstance
public static org.apache.avro.protobuf.multiplefiles.Foo getDefaultInstance()
{    return DEFAULT_INSTANCE;}
6ae5129ef376bf26e1ca0f026e637d2b3f43ce543a4e276e4a2bf88ebe148f77
parsePartialFrom
public Foo parsePartialFrom(com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException
{    return new Foo(input, extensionRegistry);}
af150e3fd63310ad66d4b545e86fb40dc752c777e3487b148de3aad7ce8dec3a
parser
public static com.google.protobuf.Parser<Foo> parser()
{    return PARSER;}
3de5fbe294e8f85075d1e9bbcc1a4f8de484abc69402a976fcb8e157c65cd13a
getParserForType
public com.google.protobuf.Parser<Foo> getParserForType()
{    return PARSER;}
8bf40c57edbb37e0ada51b597d6d88194e21ff37a244db673ca3a562a2e11a25
getDefaultInstanceForType
public org.apache.avro.protobuf.multiplefiles.Foo getDefaultInstanceForType()
{    return DEFAULT_INSTANCE;}
afeb2882aee0a13dc444e9d430b86a6dc175c48ee917722e2d5ab50801b7ab38
getUnknownFields
public final com.google.protobuf.UnknownFieldSet getUnknownFields()
{    return this.unknownFields;}
e061a4269a7822f30b36dfe5c448257acd508bbe5bfe85e23841ca998b986e73
getDescriptor
public static final com.google.protobuf.Descriptors.Descriptor getDescriptor()
{    return org.apache.avro.protobuf.multiplefiles.TestMultipleFiles.internal_static_org_apache_avro_protobuf_multiplefiles_M_descriptor;}
09b927b3931a0c25b6621043bbd0a8b48cb113bfa27184d786c8e36653bca4dd
internalGetFieldAccessorTable
protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable internalGetFieldAccessorTable()
{    return org.apache.avro.protobuf.multiplefiles.TestMultipleFiles.internal_static_org_apache_avro_protobuf_multiplefiles_M_fieldAccessorTable.ensureFieldAccessorsInitialized(org.apache.avro.protobuf.multiplefiles.M.class, org.apache.avro.protobuf.multiplefiles.M.Builder.class);}
35f3ec879596849ae2c78c5ba39ee17b816937a06f86452b7ab8b2af2a96533b
getNumber
public final int getNumber()
{    return value;}
a14813aeee6defb9d1eb71beab5550f9e0ab56b3ef1b6aa3941a952a24ef40aa
valueOf
public static N valueOf(int value)
{    return forNumber(value);}
1f56bfcac716967d2427a83c178f59f9e2847fd2146224e7208056fe0cbf7142
forNumber
public static N forNumber(int value)
{    switch(value) {        case 1:            return A;        default:            return null;    }}
aa8b41b95ab574070eb6c4f15f1a6269280b5ee7495cb95b45fd4d99f43ec8b5
internalGetValueMap
public static com.google.protobuf.Internal.EnumLiteMap<N> internalGetValueMap()
{    return internalValueMap;}
4fc75831c74a9fe8f0ebd5a4cf16fb3be4d7f9032e81f52e593c1b64023f4920
findValueByNumber
public N findValueByNumber(int number)
{    return N.forNumber(number);}
369cb5b49c34ac1de71984da1ee6a33e3f379bcd8089b809c272768420d70b36
getValueDescriptor
public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor()
{    return getDescriptor().getValues().get(ordinal());}
135f17befa1c20386f8dd8256e8d90b6f3e8cec3374799ac7e99f05fb221f93d
getDescriptorForType
public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType()
{    return getDescriptor();}
94c5986db9187ae1728adb5adc6399ab98540d464821f94b52ab256a9f722e1c
getDescriptor
public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor()
{    return org.apache.avro.protobuf.multiplefiles.M.getDescriptor().getEnumTypes().get(0);}
ee5f83cece49be136cbb6f9fe817c724f07e91787c903b17cea25576f675777d
valueOf
public static N valueOf(com.google.protobuf.Descriptors.EnumValueDescriptor desc)
{    if (desc.getType() != getDescriptor()) {        throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");    }    return VALUES[desc.getIndex()];}
dde7cd718eaa61cad29906454acf122daba6680a2db55e4787a359a08951b5e7
isInitialized
public final boolean isInitialized()
{    byte isInitialized = memoizedIsInitialized;    if (isInitialized == 1)        return true;    if (isInitialized == 0)        return false;    memoizedIsInitialized = 1;    return true;}
b78da5ac0d0f56440a60e0c8711e74775e8d0aafe7882e5346a5dcc6fa783f73
writeTo
public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException
{    unknownFields.writeTo(output);}
2bd67191ad73644076f3a74f7b306983cf9bd449d2e535f9b7f802bd0492f9f1
getSerializedSize
public int getSerializedSize()
{    int size = memoizedSize;    if (size != -1)        return size;    size = 0;    size += unknownFields.getSerializedSize();    memoizedSize = size;    return size;}
c16419e263b56042dfd908ea4d6500d086628461f2faaccf6ad79f7d3aa82321
equals
public boolean equals(final java.lang.Object obj)
{    if (obj == this) {        return true;    }    if (!(obj instanceof org.apache.avro.protobuf.multiplefiles.M)) {        return super.equals(obj);    }    org.apache.avro.protobuf.multiplefiles.M other = (org.apache.avro.protobuf.multiplefiles.M) obj;    boolean result = true;    result = result && unknownFields.equals(other.unknownFields);    return result;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    if (memoizedHashCode != 0) {        return memoizedHashCode;    }    int hash = 41;    hash = (19 * hash) + getDescriptor().hashCode();    hash = (29 * hash) + unknownFields.hashCode();    memoizedHashCode = hash;    return hash;}
a5625ab3231110e8428be97cf1c1ebb52d3f24e17f9bdc9ed51c2d56de83df1e
parseFrom
public static org.apache.avro.protobuf.multiplefiles.M parseFrom(java.nio.ByteBuffer data) throws com.google.protobuf.InvalidProtocolBufferException
{    return PARSER.parseFrom(data);}
9e98a43df0063684933f6310468cb4d2b42dcba00929400dbe076d75a4ef664d
parseFrom
public static org.apache.avro.protobuf.multiplefiles.M parseFrom(java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException
{    return PARSER.parseFrom(data, extensionRegistry);}
b408e8ed86134b8f53e20a40ce0b96874f6c7f8434da698c0f7d696d5ddc596e
parseFrom
public static org.apache.avro.protobuf.multiplefiles.M parseFrom(com.google.protobuf.ByteString data) throws com.google.protobuf.InvalidProtocolBufferException
{    return PARSER.parseFrom(data);}
7ab401e44819311c35d3e4c136e2826f11dd93544cf2fc8bb82cd08efc0fbe9c
parseFrom
public static org.apache.avro.protobuf.multiplefiles.M parseFrom(com.google.protobuf.ByteString data, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException
{    return PARSER.parseFrom(data, extensionRegistry);}
db4999c3f7eb01885004200f1751e35783610999c6e7c6633e985ec07c239e57
parseFrom
public static org.apache.avro.protobuf.multiplefiles.M parseFrom(byte[] data) throws com.google.protobuf.InvalidProtocolBufferException
{    return PARSER.parseFrom(data);}
ba0021ef061760f3e58897d9ac9d0cc68d22e15dd3d4cec827c527b4ced7dde7
parseFrom
public static org.apache.avro.protobuf.multiplefiles.M parseFrom(byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException
{    return PARSER.parseFrom(data, extensionRegistry);}
15da26ebc569e8b7c4ed044d84c892af3c5d911742c234d22bfeaa9adc5f960e
parseFrom
public static org.apache.avro.protobuf.multiplefiles.M parseFrom(java.io.InputStream input) throws java.io.IOException
{    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);}
f1d426e7e88c672544b1db8f30a5bdedc01aa1547abd812ec1190941782603a8
parseFrom
public static org.apache.avro.protobuf.multiplefiles.M parseFrom(java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException
{    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input, extensionRegistry);}
3d27747ab5b5a0a541f10500ed02093561d0a896bfb45247fbb8aa2e0af02582
parseDelimitedFrom
public static org.apache.avro.protobuf.multiplefiles.M parseDelimitedFrom(java.io.InputStream input) throws java.io.IOException
{    return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);}
8c8b4a898da783210e164daef216674b58cce77453b7155dc7327615e6e413ea
parseDelimitedFrom
public static org.apache.avro.protobuf.multiplefiles.M parseDelimitedFrom(java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException
{    return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input, extensionRegistry);}
b21c60435ef2b89ecd2d36a34bf04525d81c8adcd8dd5e35ab84bdc302487df3
parseFrom
public static org.apache.avro.protobuf.multiplefiles.M parseFrom(com.google.protobuf.CodedInputStream input) throws java.io.IOException
{    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);}
f3bdf104b4baf1b700895377c41d0d78d6983b41cb5aac828c0fa9a94778d9f7
parseFrom
public static org.apache.avro.protobuf.multiplefiles.M parseFrom(com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException
{    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input, extensionRegistry);}
a2589243249ba32b92e98298a2511019cd74b21c911d510f075da5ff7e8b6399
newBuilderForType
public Builder newBuilderForType()
{    return newBuilder();}
e32f866eb7533a232fadc4ef42bb022716435f415dc4a0f7ed4fff845f45ead0
newBuilder
public static Builder newBuilder()
{    return DEFAULT_INSTANCE.toBuilder();}
2111e54ec9ebe15972eef2de43887591c9616d2902e37a4a1feb9aaed1027d64
newBuilder
public static Builder newBuilder(org.apache.avro.protobuf.multiplefiles.M prototype)
{    return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);}
8f9c3ced03d87377003831ec6560ea40c4b718fc762fc1ca14b030b0ed8256d4
toBuilder
public Builder toBuilder()
{    return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);}
4b6decb5ce35d0ce069dd647bca27ca9f81ed66925e1b833a3512177697f2d3b
newBuilderForType
protected Builder newBuilderForType(com.google.protobuf.GeneratedMessageV3.BuilderParent parent)
{    Builder builder = new Builder(parent);    return builder;}
e061a4269a7822f30b36dfe5c448257acd508bbe5bfe85e23841ca998b986e73
getDescriptor
public static final com.google.protobuf.Descriptors.Descriptor getDescriptor()
{    return org.apache.avro.protobuf.multiplefiles.TestMultipleFiles.internal_static_org_apache_avro_protobuf_multiplefiles_M_descriptor;}
09b927b3931a0c25b6621043bbd0a8b48cb113bfa27184d786c8e36653bca4dd
internalGetFieldAccessorTable
protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable internalGetFieldAccessorTable()
{    return org.apache.avro.protobuf.multiplefiles.TestMultipleFiles.internal_static_org_apache_avro_protobuf_multiplefiles_M_fieldAccessorTable.ensureFieldAccessorsInitialized(org.apache.avro.protobuf.multiplefiles.M.class, org.apache.avro.protobuf.multiplefiles.M.Builder.class);}
7c751d7a2accff7e718ee1e6ea5d2457fe6e182e8c39098e52a8848f56cf2cfe
maybeForceBuilderInitialization
private void maybeForceBuilderInitialization()
{    if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {    }}
7930c451f279d9927ff235e4ac064561e1505f9b7ae117d9f681b345534ff9e3
clear
public Builder clear()
{    super.clear();    return this;}
5a2efdcbff6cd8f893a197208cee010e41df6afb0e928da5d7126d953902ee30
getDescriptorForType
public com.google.protobuf.Descriptors.Descriptor getDescriptorForType()
{    return org.apache.avro.protobuf.multiplefiles.TestMultipleFiles.internal_static_org_apache_avro_protobuf_multiplefiles_M_descriptor;}
302eda2172a3720e6d2c681b938858699431a047793807ff7fd731e73e330818
getDefaultInstanceForType
public org.apache.avro.protobuf.multiplefiles.M getDefaultInstanceForType()
{    return org.apache.avro.protobuf.multiplefiles.M.getDefaultInstance();}
42b7cf139718bc2ace9514dbc48ddcffdb0b00eb9748391c91be3eeb2686b3f6
build
public org.apache.avro.protobuf.multiplefiles.M build()
{    org.apache.avro.protobuf.multiplefiles.M result = buildPartial();    if (!result.isInitialized()) {        throw newUninitializedMessageException(result);    }    return result;}
a53ff04fa7f04f01c1dc0b7505f077e1f1a4c49ba476a963c56d668bd1198683
buildPartial
public org.apache.avro.protobuf.multiplefiles.M buildPartial()
{    org.apache.avro.protobuf.multiplefiles.M result = new org.apache.avro.protobuf.multiplefiles.M(this);    onBuilt();    return result;}
845fff95a97cf125489126ddee47248563aa80a59ed327d7d1c7cb9d90dcec30
clone
public Builder clone()
{    return (Builder) super.clone();}
e5d5cf46f7f9733e8968952c90ced36c482b5ce6c76f55f96b63b7864c44e8a9
setField
public Builder setField(com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value)
{    return (Builder) super.setField(field, value);}
7230780e7bd47d3ff1bfbd582401f62ac660c4cabdffea3399b812f0ca274023
clearField
public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field)
{    return (Builder) super.clearField(field);}
eb613a9109dd1960f829dd2a97c885c2dcb2e9e5c7eb1830f545fa78ca5217bb
clearOneof
public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof)
{    return (Builder) super.clearOneof(oneof);}
8b65fa0ba0250c27a1784d122c7e82f6a56893f4925b947cc87918e388ed11da
setRepeatedField
public Builder setRepeatedField(com.google.protobuf.Descriptors.FieldDescriptor field, int index, java.lang.Object value)
{    return (Builder) super.setRepeatedField(field, index, value);}
4c493ce9e20cef0f6973f189f8fcec07c11f7ec7a802fb3afe6f948f64f9ea0e
addRepeatedField
public Builder addRepeatedField(com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value)
{    return (Builder) super.addRepeatedField(field, value);}
9c02b14012758934fbc876f583b7201b524cfd4dce350a6fd2cdeea1bb86b6f9
mergeFrom
public Builder mergeFrom(com.google.protobuf.Message other)
{    if (other instanceof org.apache.avro.protobuf.multiplefiles.M) {        return mergeFrom((org.apache.avro.protobuf.multiplefiles.M) other);    } else {        super.mergeFrom(other);        return this;    }}
7221ece23af66319376d9025f1d8d53c93a9a23d5f4afd8aee7a0d9ee272ad6d
mergeFrom
public Builder mergeFrom(org.apache.avro.protobuf.multiplefiles.M other)
{    if (other == org.apache.avro.protobuf.multiplefiles.M.getDefaultInstance())        return this;    this.mergeUnknownFields(other.unknownFields);    onChanged();    return this;}
dde7cd718eaa61cad29906454acf122daba6680a2db55e4787a359a08951b5e7
isInitialized
public final boolean isInitialized()
{    return true;}
576f0ac95d3431feb1ba705ec8f537aa5e5a58300021599ce7c111ed9b61d887
mergeFrom
public Builder mergeFrom(com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException
{    org.apache.avro.protobuf.multiplefiles.M parsedMessage = null;    try {        parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);    } catch (com.google.protobuf.InvalidProtocolBufferException e) {        parsedMessage = (org.apache.avro.protobuf.multiplefiles.M) e.getUnfinishedMessage();        throw e.unwrapIOException();    } finally {        if (parsedMessage != null) {            mergeFrom(parsedMessage);        }    }    return this;}
c3f82e9354e0de24294e8d24ddd4cc78edfdbc227b0b6784774ae4f90f8803a5
setUnknownFields
public final Builder setUnknownFields(final com.google.protobuf.UnknownFieldSet unknownFields)
{    return super.setUnknownFields(unknownFields);}
112ef20f9bae5594feab16e3416756e8f3a1b669246aa50338f4c67470eebe6a
mergeUnknownFields
public final Builder mergeUnknownFields(final com.google.protobuf.UnknownFieldSet unknownFields)
{    return super.mergeUnknownFields(unknownFields);}
5de092b5f35d9b107b576afd8a624baca385b5921ea97f4f9a41bab63b119d0a
getDefaultInstance
public static org.apache.avro.protobuf.multiplefiles.M getDefaultInstance()
{    return DEFAULT_INSTANCE;}
74b175d23e817f668b41e939624c002679beaa5d2e0cfa4293bdfb2ccbdec4e4
parsePartialFrom
public M parsePartialFrom(com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException
{    return new M(input, extensionRegistry);}
f82a1ccc586d6d52baec0b1d7ab43e35ab4285a66bf4dde7d8c0039e2d455851
parser
public static com.google.protobuf.Parser<M> parser()
{    return PARSER;}
ceca005c582c6b2089a094243b24152b3f5e7a8e40effca65a0ff913203f0edc
getParserForType
public com.google.protobuf.Parser<M> getParserForType()
{    return PARSER;}
302eda2172a3720e6d2c681b938858699431a047793807ff7fd731e73e330818
getDefaultInstanceForType
public org.apache.avro.protobuf.multiplefiles.M getDefaultInstanceForType()
{    return DEFAULT_INSTANCE;}
f7d55b443745c3598876f16c6a9e4da61cfa3157fc8822f6c20c996f98d3a56d
registerAllExtensions
public static void registerAllExtensions(com.google.protobuf.ExtensionRegistryLite registry)
{}
199638b55b1fbb07d5c574aad10c10032254dd9ba4d60c3c1be16c0cf27b69a8
registerAllExtensions
public static void registerAllExtensions(com.google.protobuf.ExtensionRegistry registry)
{    registerAllExtensions((com.google.protobuf.ExtensionRegistryLite) registry);}
d89a873db80c2368d8f6325a1db7f8e1359f195eeddfadda2a0e8079d1cd56ae
getDescriptor
public static com.google.protobuf.Descriptors.FileDescriptor getDescriptor()
{    return descriptor;}
224c23efa88f76f75befbf7108a56fdc531065116f2bd0df86a70845fc339c65
assignDescriptors
public com.google.protobuf.ExtensionRegistry assignDescriptors(com.google.protobuf.Descriptors.FileDescriptor root)
{    descriptor = root;    return null;}
f7d55b443745c3598876f16c6a9e4da61cfa3157fc8822f6c20c996f98d3a56d
registerAllExtensions
public static void registerAllExtensions(com.google.protobuf.ExtensionRegistryLite registry)
{}
199638b55b1fbb07d5c574aad10c10032254dd9ba4d60c3c1be16c0cf27b69a8
registerAllExtensions
public static void registerAllExtensions(com.google.protobuf.ExtensionRegistry registry)
{    registerAllExtensions((com.google.protobuf.ExtensionRegistryLite) registry);}
35f3ec879596849ae2c78c5ba39ee17b816937a06f86452b7ab8b2af2a96533b
getNumber
public final int getNumber()
{    return value;}
c6ae9145c5c28aef6bac2278ed0edd1ccc91b08615a2c2e43ceefb81fcee5065
valueOf
public static A valueOf(int value)
{    return forNumber(value);}
0dc36c0d9100ddff4d912867b5cf5c887107034fda6e18fc4fd1bb4e711698fa
forNumber
public static A forNumber(int value)
{    switch(value) {        case 1:            return X;        case 2:            return Y;        case 3:            return Z;        default:            return null;    }}
072d0ac999598703adce5e953dc73a309dc988919038e3d7876b259756658dfe
internalGetValueMap
public static com.google.protobuf.Internal.EnumLiteMap<A> internalGetValueMap()
{    return internalValueMap;}
2cc6b6af3ca5f62ee0295f1535d61950c673cb009a874bec76a6d9895bb6fb7f
findValueByNumber
public A findValueByNumber(int number)
{    return A.forNumber(number);}
369cb5b49c34ac1de71984da1ee6a33e3f379bcd8089b809c272768420d70b36
getValueDescriptor
public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor()
{    return getDescriptor().getValues().get(ordinal());}
135f17befa1c20386f8dd8256e8d90b6f3e8cec3374799ac7e99f05fb221f93d
getDescriptorForType
public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType()
{    return getDescriptor();}
94c5986db9187ae1728adb5adc6399ab98540d464821f94b52ab256a9f722e1c
getDescriptor
public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor()
{    return org.apache.avro.protobuf.noopt.Test.getDescriptor().getEnumTypes().get(0);}
7cf969c15493db77229281aaaa465acd4ae3ff2197fde8ed591ba95b38760eb6
valueOf
public static A valueOf(com.google.protobuf.Descriptors.EnumValueDescriptor desc)
{    if (desc.getType() != getDescriptor()) {        throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");    }    return VALUES[desc.getIndex()];}
afeb2882aee0a13dc444e9d430b86a6dc175c48ee917722e2d5ab50801b7ab38
getUnknownFields
public final com.google.protobuf.UnknownFieldSet getUnknownFields()
{    return this.unknownFields;}
e061a4269a7822f30b36dfe5c448257acd508bbe5bfe85e23841ca998b986e73
getDescriptor
public static final com.google.protobuf.Descriptors.Descriptor getDescriptor()
{    return org.apache.avro.protobuf.noopt.Test.internal_static_org_apache_avro_protobuf_noopt_Foo_descriptor;}
09b927b3931a0c25b6621043bbd0a8b48cb113bfa27184d786c8e36653bca4dd
internalGetFieldAccessorTable
protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable internalGetFieldAccessorTable()
{    return org.apache.avro.protobuf.noopt.Test.internal_static_org_apache_avro_protobuf_noopt_Foo_fieldAccessorTable.ensureFieldAccessorsInitialized(org.apache.avro.protobuf.noopt.Test.Foo.class, org.apache.avro.protobuf.noopt.Test.Foo.Builder.class);}
9a1647854ce456002dcb1c52139e88ef7a23a7d696936d56a15e6d4db0ccb184
hasInt32
public boolean hasInt32()
{    return ((bitField0_ & 0x00000001) == 0x00000001);}
636175cecf2b3f1c8415679f2f0b80d34ba9b63e238193298adf86af15007213
getInt32
public int getInt32()
{    return int32_;}
a2c53766842c579522e01699c16d28ea58a1b49581f61187921336e4ce63b648
hasInt64
public boolean hasInt64()
{    return ((bitField0_ & 0x00000002) == 0x00000002);}
57c8339ea9b07d9b3113d12c4eae4a8a74f2ebd9a6de36dd3cfa42c148f186ab
getInt64
public long getInt64()
{    return int64_;}
2e6ee41b2bb0d50e6b526adc77c21e06d72a1423b637a000776e01b5c2b60cfe
hasUint32
public boolean hasUint32()
{    return ((bitField0_ & 0x00000004) == 0x00000004);}
b7d2e4380f601c73ee0923b2fe9b521818c5ce75b743deec1d19ed294de77dd1
getUint32
public int getUint32()
{    return uint32_;}
00e677ff71597cdf7ae7ab5e024a2eb75ff3d284223f3c6045ed6dd53e8d0845
hasUint64
public boolean hasUint64()
{    return ((bitField0_ & 0x00000008) == 0x00000008);}
b4b058bcc167225140afd471f432372421b25319080692aa857ca736719bc92b
getUint64
public long getUint64()
{    return uint64_;}
2e93fdc6d6c8b20576cd9a0e9d1e183d33569ed069463a98ad5ec167a29d6e14
hasSint32
public boolean hasSint32()
{    return ((bitField0_ & 0x00000010) == 0x00000010);}
75b5ac5769aad1f59a8c73b0547c0c77fc4c170b9c72844230175c2a4ba06ad5
getSint32
public int getSint32()
{    return sint32_;}
31fdd75033679196631750b698981d6dcc9537d93c151d7cbcd4ca46de9d58aa
hasSint64
public boolean hasSint64()
{    return ((bitField0_ & 0x00000020) == 0x00000020);}
75d70e1b7a60651a143d6564f9b40443b64654c71ee48cc41a68029e8c436e18
getSint64
public long getSint64()
{    return sint64_;}
ad9c191d2d327991d4d5c3dea893bb9a901eb34f81ccfc40c50706ef79c1760a
hasFixed32
public boolean hasFixed32()
{    return ((bitField0_ & 0x00000040) == 0x00000040);}
98f6f07472f43870759b408f82612481ade75d1e14ccc2226cec24b686f55050
getFixed32
public int getFixed32()
{    return fixed32_;}
4a6662d0d6f52e9e2b217aaeb86a991de741e56d2eeb146d3d43652fe51a5326
hasFixed64
public boolean hasFixed64()
{    return ((bitField0_ & 0x00000080) == 0x00000080);}
8b9413171a22273aafb43565effc2135094288b4e3333b3afd1e37e629f68fb0
getFixed64
public long getFixed64()
{    return fixed64_;}
41a3547ab4b509363c785a59db522a034320a04eecd00bf28bcc5250c8636cd8
hasSfixed32
public boolean hasSfixed32()
{    return ((bitField0_ & 0x00000100) == 0x00000100);}
64daf2c2e759b26fa9445cc4f9caba82b1aa8040416bdf77dc86a976ef8ede0d
getSfixed32
public int getSfixed32()
{    return sfixed32_;}
45f1bf05257c7a952854e866f6a67f13b5c039f4e8c25738e069ed51eb6f63cf
hasSfixed64
public boolean hasSfixed64()
{    return ((bitField0_ & 0x00000200) == 0x00000200);}
20f25f0e34849b2bce430689f850be46b02bd3b74ea8c5a77b60c18c791e6a64
getSfixed64
public long getSfixed64()
{    return sfixed64_;}
0cb9fb07dff4d2bfa7ae4bf0843e71fa5fb3d03c06b07c7d2a717ec089d0767e
hasFloat
public boolean hasFloat()
{    return ((bitField0_ & 0x00000400) == 0x00000400);}
ee9a51dbf95b211d37a60138ffb4deb11942d61f5c9721afa1016727fb401415
getFloat
public float getFloat()
{    return float_;}
e28f40a1dd04174c7100c4112d5ed5b5772e98d43d41f2d671ff567e0f4c6ce5
hasDouble
public boolean hasDouble()
{    return ((bitField0_ & 0x00000800) == 0x00000800);}
95f35c6fbf999bf94e0a9c9c5fa482ed65318ab2572fb3b51e8c181fc2611e97
getDouble
public double getDouble()
{    return double_;}
586ca0c2bb6da45de72704084c6e31b535779b9f3166053de6d5c3114e808751
hasBool
public boolean hasBool()
{    return ((bitField0_ & 0x00001000) == 0x00001000);}
f5d970ff55271bea91b285c75a149e090505eb675c4e8194d9e1e500461f90e8
getBool
public boolean getBool()
{    return bool_;}
3f0c31e577682520c0fcca7daaaf896b908ba830b55ce04569418803a52cead8
hasString
public boolean hasString()
{    return ((bitField0_ & 0x00002000) == 0x00002000);}
7c4c17115810ae3f13bf8deca5f5267c8cb89c0f70fafecb78a67ebd65ae6b37
getString
public java.lang.String getString()
{    java.lang.Object ref = string_;    if (ref instanceof java.lang.String) {        return (java.lang.String) ref;    } else {        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;        java.lang.String s = bs.toStringUtf8();        if (bs.isValidUtf8()) {            string_ = s;        }        return s;    }}
404c2340dc76857ee9b3d6bb2a82a6697881da7fa911e1d8af649f5b71248a3a
getStringBytes
public com.google.protobuf.ByteString getStringBytes()
{    java.lang.Object ref = string_;    if (ref instanceof java.lang.String) {        com.google.protobuf.ByteString b = com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);        string_ = b;        return b;    } else {        return (com.google.protobuf.ByteString) ref;    }}
75a99db492c7f97c17d6844f9a82e00a4b1f11fd35d8ea25d7d55a21df04ad6a
hasBytes
public boolean hasBytes()
{    return ((bitField0_ & 0x00004000) == 0x00004000);}
d6cf6f44c45e7e724dce80e785110e2196522fe8c0a756ce8d5e75c119e561c5
getBytes
public com.google.protobuf.ByteString getBytes()
{    return bytes_;}
698a189fcb3c994fa12118569041c84a5d6176385eb353c702935c048c13d88b
hasEnum
public boolean hasEnum()
{    return ((bitField0_ & 0x00008000) == 0x00008000);}
c14ce52769665c416d91d8ebd91edc675f85635f4853547b159498e112e1b6c7
getEnum
public org.apache.avro.protobuf.noopt.Test.A getEnum()
{    org.apache.avro.protobuf.noopt.Test.A result = org.apache.avro.protobuf.noopt.Test.A.valueOf(enum_);    return result == null ? org.apache.avro.protobuf.noopt.Test.A.Z : result;}
0dbd424bbcce9aded3aad4770c8ffb4c32f758322b180e89d544aa54302c6728
getIntArrayList
public java.util.List<java.lang.Integer> getIntArrayList()
{    return intArray_;}
31b4697dd384dd0bd1bde310af3b62067c0a1ad32cc543d5063825eeb8bd56b3
getIntArrayCount
public int getIntArrayCount()
{    return intArray_.size();}
2e098f94a8cd1017c27e6f532faec1cc3c3f5529d9acf62fca5795b2889dd67a
getIntArray
public int getIntArray(int index)
{    return intArray_.get(index);}
603fed82711117492afbd9b860cd9fc219c21b0578ddf67c11c599f2942224ec
getFooArrayList
public java.util.List<org.apache.avro.protobuf.noopt.Test.Foo> getFooArrayList()
{    return fooArray_;}
ec5283fcc56c5315b77665a2ff4cd521696b1b8c595e93575e02ba1698493914
getFooArrayOrBuilderList
public java.util.List<? extends org.apache.avro.protobuf.noopt.Test.FooOrBuilder> getFooArrayOrBuilderList()
{    return fooArray_;}
fd2ac97f74deac4a599110fe63068fdd22b2fde4ae9928305d79d7d01629765c
getFooArrayCount
public int getFooArrayCount()
{    return fooArray_.size();}
b7c76b6457d027d90ca93915f809637fb4f77a51824e17e3cdff921e146afbc6
getFooArray
public org.apache.avro.protobuf.noopt.Test.Foo getFooArray(int index)
{    return fooArray_.get(index);}
43847fc925329fdcabbe001cca247052b636d7b946f54dc6fa231c4d60411674
getFooArrayOrBuilder
public org.apache.avro.protobuf.noopt.Test.FooOrBuilder getFooArrayOrBuilder(int index)
{    return fooArray_.get(index);}
6b1d78429b2f0500c8ba1d3bd97c37d94e7954b719094b218a0a8ea3a8c4e765
convert
public org.apache.avro.protobuf.noopt.Test.A convert(java.lang.Integer from)
{    org.apache.avro.protobuf.noopt.Test.A result = org.apache.avro.protobuf.noopt.Test.A.valueOf(from);    return result == null ? org.apache.avro.protobuf.noopt.Test.A.X : result;}
3320cc00930a1aba8c0e0499908c073b993e7bc83eede54b2bdf94678bb4326a
getSymsList
public java.util.List<org.apache.avro.protobuf.noopt.Test.A> getSymsList()
{    return new com.google.protobuf.Internal.ListAdapter<java.lang.Integer, org.apache.avro.protobuf.noopt.Test.A>(syms_, syms_converter_);}
184c0551fc5d1c2cbff289a02240b91ff20c32be2e794e0f47a61014a4b8d156
getSymsCount
public int getSymsCount()
{    return syms_.size();}
3957a07951accfa2fd2ecc2c75c2072f8833d1bea79ad14514810e5211d0d5ff
getSyms
public org.apache.avro.protobuf.noopt.Test.A getSyms(int index)
{    return syms_converter_.convert(syms_.get(index));}
10058f491b0a4a5c22162369389d3ed8276668e2d04db758b35d31010e7e4677
hasFoo
public boolean hasFoo()
{    return ((bitField0_ & 0x00010000) == 0x00010000);}
66003ab0ca4e8aca5f3e69205233160711731f6209444bbfbf1b34070c589be7
getFoo
public org.apache.avro.protobuf.noopt.Test.Foo getFoo()
{    return foo_ == null ? org.apache.avro.protobuf.noopt.Test.Foo.getDefaultInstance() : foo_;}
3369f11fd202817f079bdd6ed96a9129b6cd6e67892de5636fbabe87961eb373
getFooOrBuilder
public org.apache.avro.protobuf.noopt.Test.FooOrBuilder getFooOrBuilder()
{    return foo_ == null ? org.apache.avro.protobuf.noopt.Test.Foo.getDefaultInstance() : foo_;}
bafb11dbca36e09bf79e4baa90c93a1bc1422a322f7ad686efa10ecb036831b5
hasTimestamp
public boolean hasTimestamp()
{    return ((bitField0_ & 0x00020000) == 0x00020000);}
c66f064664f32c706c67564ca4c770ad74baa2e4df0c3a6eccb1177407cc2c5e
getTimestamp
public com.google.protobuf.Timestamp getTimestamp()
{    return timestamp_ == null ? com.google.protobuf.Timestamp.getDefaultInstance() : timestamp_;}
1a895b7c2c7d5a9cb1b98abc55c3ddb581f84797f811e5056403cde4d040aebb
getTimestampOrBuilder
public com.google.protobuf.TimestampOrBuilder getTimestampOrBuilder()
{    return timestamp_ == null ? com.google.protobuf.Timestamp.getDefaultInstance() : timestamp_;}
dde7cd718eaa61cad29906454acf122daba6680a2db55e4787a359a08951b5e7
isInitialized
public final boolean isInitialized()
{    byte isInitialized = memoizedIsInitialized;    if (isInitialized == 1)        return true;    if (isInitialized == 0)        return false;    if (!hasInt32()) {        memoizedIsInitialized = 0;        return false;    }    for (int i = 0; i < getFooArrayCount(); i++) {        if (!getFooArray(i).isInitialized()) {            memoizedIsInitialized = 0;            return false;        }    }    if (hasFoo()) {        if (!getFoo().isInitialized()) {            memoizedIsInitialized = 0;            return false;        }    }    memoizedIsInitialized = 1;    return true;}
b78da5ac0d0f56440a60e0c8711e74775e8d0aafe7882e5346a5dcc6fa783f73
writeTo
public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException
{    if (((bitField0_ & 0x00000001) == 0x00000001)) {        output.writeInt32(1, int32_);    }    if (((bitField0_ & 0x00000002) == 0x00000002)) {        output.writeInt64(2, int64_);    }    if (((bitField0_ & 0x00000004) == 0x00000004)) {        output.writeUInt32(3, uint32_);    }    if (((bitField0_ & 0x00000008) == 0x00000008)) {        output.writeUInt64(4, uint64_);    }    if (((bitField0_ & 0x00000010) == 0x00000010)) {        output.writeSInt32(5, sint32_);    }    if (((bitField0_ & 0x00000020) == 0x00000020)) {        output.writeSInt64(6, sint64_);    }    if (((bitField0_ & 0x00000040) == 0x00000040)) {        output.writeFixed32(7, fixed32_);    }    if (((bitField0_ & 0x00000080) == 0x00000080)) {        output.writeFixed64(8, fixed64_);    }    if (((bitField0_ & 0x00000100) == 0x00000100)) {        output.writeSFixed32(9, sfixed32_);    }    if (((bitField0_ & 0x00000200) == 0x00000200)) {        output.writeSFixed64(10, sfixed64_);    }    if (((bitField0_ & 0x00000400) == 0x00000400)) {        output.writeFloat(11, float_);    }    if (((bitField0_ & 0x00000800) == 0x00000800)) {        output.writeDouble(12, double_);    }    if (((bitField0_ & 0x00001000) == 0x00001000)) {        output.writeBool(13, bool_);    }    if (((bitField0_ & 0x00002000) == 0x00002000)) {        com.google.protobuf.GeneratedMessageV3.writeString(output, 14, string_);    }    if (((bitField0_ & 0x00004000) == 0x00004000)) {        output.writeBytes(15, bytes_);    }    if (((bitField0_ & 0x00008000) == 0x00008000)) {        output.writeEnum(16, enum_);    }    for (int i = 0; i < intArray_.size(); i++) {        output.writeInt32(17, intArray_.get(i));    }    if (((bitField0_ & 0x00010000) == 0x00010000)) {        output.writeMessage(18, getFoo());    }    for (int i = 0; i < syms_.size(); i++) {        output.writeEnum(19, syms_.get(i));    }    for (int i = 0; i < fooArray_.size(); i++) {        output.writeMessage(20, fooArray_.get(i));    }    if (((bitField0_ & 0x00020000) == 0x00020000)) {        output.writeMessage(21, getTimestamp());    }    unknownFields.writeTo(output);}
2bd67191ad73644076f3a74f7b306983cf9bd449d2e535f9b7f802bd0492f9f1
getSerializedSize
public int getSerializedSize()
{    int size = memoizedSize;    if (size != -1)        return size;    size = 0;    if (((bitField0_ & 0x00000001) == 0x00000001)) {        size += com.google.protobuf.CodedOutputStream.computeInt32Size(1, int32_);    }    if (((bitField0_ & 0x00000002) == 0x00000002)) {        size += com.google.protobuf.CodedOutputStream.computeInt64Size(2, int64_);    }    if (((bitField0_ & 0x00000004) == 0x00000004)) {        size += com.google.protobuf.CodedOutputStream.computeUInt32Size(3, uint32_);    }    if (((bitField0_ & 0x00000008) == 0x00000008)) {        size += com.google.protobuf.CodedOutputStream.computeUInt64Size(4, uint64_);    }    if (((bitField0_ & 0x00000010) == 0x00000010)) {        size += com.google.protobuf.CodedOutputStream.computeSInt32Size(5, sint32_);    }    if (((bitField0_ & 0x00000020) == 0x00000020)) {        size += com.google.protobuf.CodedOutputStream.computeSInt64Size(6, sint64_);    }    if (((bitField0_ & 0x00000040) == 0x00000040)) {        size += com.google.protobuf.CodedOutputStream.computeFixed32Size(7, fixed32_);    }    if (((bitField0_ & 0x00000080) == 0x00000080)) {        size += com.google.protobuf.CodedOutputStream.computeFixed64Size(8, fixed64_);    }    if (((bitField0_ & 0x00000100) == 0x00000100)) {        size += com.google.protobuf.CodedOutputStream.computeSFixed32Size(9, sfixed32_);    }    if (((bitField0_ & 0x00000200) == 0x00000200)) {        size += com.google.protobuf.CodedOutputStream.computeSFixed64Size(10, sfixed64_);    }    if (((bitField0_ & 0x00000400) == 0x00000400)) {        size += com.google.protobuf.CodedOutputStream.computeFloatSize(11, float_);    }    if (((bitField0_ & 0x00000800) == 0x00000800)) {        size += com.google.protobuf.CodedOutputStream.computeDoubleSize(12, double_);    }    if (((bitField0_ & 0x00001000) == 0x00001000)) {        size += com.google.protobuf.CodedOutputStream.computeBoolSize(13, bool_);    }    if (((bitField0_ & 0x00002000) == 0x00002000)) {        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(14, string_);    }    if (((bitField0_ & 0x00004000) == 0x00004000)) {        size += com.google.protobuf.CodedOutputStream.computeBytesSize(15, bytes_);    }    if (((bitField0_ & 0x00008000) == 0x00008000)) {        size += com.google.protobuf.CodedOutputStream.computeEnumSize(16, enum_);    }    {        int dataSize = 0;        for (int i = 0; i < intArray_.size(); i++) {            dataSize += com.google.protobuf.CodedOutputStream.computeInt32SizeNoTag(intArray_.get(i));        }        size += dataSize;        size += 2 * getIntArrayList().size();    }    if (((bitField0_ & 0x00010000) == 0x00010000)) {        size += com.google.protobuf.CodedOutputStream.computeMessageSize(18, getFoo());    }    {        int dataSize = 0;        for (int i = 0; i < syms_.size(); i++) {            dataSize += com.google.protobuf.CodedOutputStream.computeEnumSizeNoTag(syms_.get(i));        }        size += dataSize;        size += 2 * syms_.size();    }    for (int i = 0; i < fooArray_.size(); i++) {        size += com.google.protobuf.CodedOutputStream.computeMessageSize(20, fooArray_.get(i));    }    if (((bitField0_ & 0x00020000) == 0x00020000)) {        size += com.google.protobuf.CodedOutputStream.computeMessageSize(21, getTimestamp());    }    size += unknownFields.getSerializedSize();    memoizedSize = size;    return size;}
c16419e263b56042dfd908ea4d6500d086628461f2faaccf6ad79f7d3aa82321
equals
public boolean equals(final java.lang.Object obj)
{    if (obj == this) {        return true;    }    if (!(obj instanceof org.apache.avro.protobuf.noopt.Test.Foo)) {        return super.equals(obj);    }    org.apache.avro.protobuf.noopt.Test.Foo other = (org.apache.avro.protobuf.noopt.Test.Foo) obj;    boolean result = true;    result = result && (hasInt32() == other.hasInt32());    if (hasInt32()) {        result = result && (getInt32() == other.getInt32());    }    result = result && (hasInt64() == other.hasInt64());    if (hasInt64()) {        result = result && (getInt64() == other.getInt64());    }    result = result && (hasUint32() == other.hasUint32());    if (hasUint32()) {        result = result && (getUint32() == other.getUint32());    }    result = result && (hasUint64() == other.hasUint64());    if (hasUint64()) {        result = result && (getUint64() == other.getUint64());    }    result = result && (hasSint32() == other.hasSint32());    if (hasSint32()) {        result = result && (getSint32() == other.getSint32());    }    result = result && (hasSint64() == other.hasSint64());    if (hasSint64()) {        result = result && (getSint64() == other.getSint64());    }    result = result && (hasFixed32() == other.hasFixed32());    if (hasFixed32()) {        result = result && (getFixed32() == other.getFixed32());    }    result = result && (hasFixed64() == other.hasFixed64());    if (hasFixed64()) {        result = result && (getFixed64() == other.getFixed64());    }    result = result && (hasSfixed32() == other.hasSfixed32());    if (hasSfixed32()) {        result = result && (getSfixed32() == other.getSfixed32());    }    result = result && (hasSfixed64() == other.hasSfixed64());    if (hasSfixed64()) {        result = result && (getSfixed64() == other.getSfixed64());    }    result = result && (hasFloat() == other.hasFloat());    if (hasFloat()) {        result = result && (java.lang.Float.floatToIntBits(getFloat()) == java.lang.Float.floatToIntBits(other.getFloat()));    }    result = result && (hasDouble() == other.hasDouble());    if (hasDouble()) {        result = result && (java.lang.Double.doubleToLongBits(getDouble()) == java.lang.Double.doubleToLongBits(other.getDouble()));    }    result = result && (hasBool() == other.hasBool());    if (hasBool()) {        result = result && (getBool() == other.getBool());    }    result = result && (hasString() == other.hasString());    if (hasString()) {        result = result && getString().equals(other.getString());    }    result = result && (hasBytes() == other.hasBytes());    if (hasBytes()) {        result = result && getBytes().equals(other.getBytes());    }    result = result && (hasEnum() == other.hasEnum());    if (hasEnum()) {        result = result && enum_ == other.enum_;    }    result = result && getIntArrayList().equals(other.getIntArrayList());    result = result && getFooArrayList().equals(other.getFooArrayList());    result = result && syms_.equals(other.syms_);    result = result && (hasFoo() == other.hasFoo());    if (hasFoo()) {        result = result && getFoo().equals(other.getFoo());    }    result = result && (hasTimestamp() == other.hasTimestamp());    if (hasTimestamp()) {        result = result && getTimestamp().equals(other.getTimestamp());    }    result = result && unknownFields.equals(other.unknownFields);    return result;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    if (memoizedHashCode != 0) {        return memoizedHashCode;    }    int hash = 41;    hash = (19 * hash) + getDescriptor().hashCode();    if (hasInt32()) {        hash = (37 * hash) + INT32_FIELD_NUMBER;        hash = (53 * hash) + getInt32();    }    if (hasInt64()) {        hash = (37 * hash) + INT64_FIELD_NUMBER;        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(getInt64());    }    if (hasUint32()) {        hash = (37 * hash) + UINT32_FIELD_NUMBER;        hash = (53 * hash) + getUint32();    }    if (hasUint64()) {        hash = (37 * hash) + UINT64_FIELD_NUMBER;        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(getUint64());    }    if (hasSint32()) {        hash = (37 * hash) + SINT32_FIELD_NUMBER;        hash = (53 * hash) + getSint32();    }    if (hasSint64()) {        hash = (37 * hash) + SINT64_FIELD_NUMBER;        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(getSint64());    }    if (hasFixed32()) {        hash = (37 * hash) + FIXED32_FIELD_NUMBER;        hash = (53 * hash) + getFixed32();    }    if (hasFixed64()) {        hash = (37 * hash) + FIXED64_FIELD_NUMBER;        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(getFixed64());    }    if (hasSfixed32()) {        hash = (37 * hash) + SFIXED32_FIELD_NUMBER;        hash = (53 * hash) + getSfixed32();    }    if (hasSfixed64()) {        hash = (37 * hash) + SFIXED64_FIELD_NUMBER;        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(getSfixed64());    }    if (hasFloat()) {        hash = (37 * hash) + FLOAT_FIELD_NUMBER;        hash = (53 * hash) + java.lang.Float.floatToIntBits(getFloat());    }    if (hasDouble()) {        hash = (37 * hash) + DOUBLE_FIELD_NUMBER;        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(java.lang.Double.doubleToLongBits(getDouble()));    }    if (hasBool()) {        hash = (37 * hash) + BOOL_FIELD_NUMBER;        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(getBool());    }    if (hasString()) {        hash = (37 * hash) + STRING_FIELD_NUMBER;        hash = (53 * hash) + getString().hashCode();    }    if (hasBytes()) {        hash = (37 * hash) + BYTES_FIELD_NUMBER;        hash = (53 * hash) + getBytes().hashCode();    }    if (hasEnum()) {        hash = (37 * hash) + ENUM_FIELD_NUMBER;        hash = (53 * hash) + enum_;    }    if (getIntArrayCount() > 0) {        hash = (37 * hash) + INTARRAY_FIELD_NUMBER;        hash = (53 * hash) + getIntArrayList().hashCode();    }    if (getFooArrayCount() > 0) {        hash = (37 * hash) + FOOARRAY_FIELD_NUMBER;        hash = (53 * hash) + getFooArrayList().hashCode();    }    if (getSymsCount() > 0) {        hash = (37 * hash) + SYMS_FIELD_NUMBER;        hash = (53 * hash) + syms_.hashCode();    }    if (hasFoo()) {        hash = (37 * hash) + FOO_FIELD_NUMBER;        hash = (53 * hash) + getFoo().hashCode();    }    if (hasTimestamp()) {        hash = (37 * hash) + TIMESTAMP_FIELD_NUMBER;        hash = (53 * hash) + getTimestamp().hashCode();    }    hash = (29 * hash) + unknownFields.hashCode();    memoizedHashCode = hash;    return hash;}
0dad6ee332184b4b02549506b655ba49bf5a41da6b79c18c3df331c2c083cf81
parseFrom
public static org.apache.avro.protobuf.noopt.Test.Foo parseFrom(java.nio.ByteBuffer data) throws com.google.protobuf.InvalidProtocolBufferException
{    return PARSER.parseFrom(data);}
dff22d454cf9dc8883661d141d67651b9977e2ddea2ea684da5f3c5a7c24b3f0
parseFrom
public static org.apache.avro.protobuf.noopt.Test.Foo parseFrom(java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException
{    return PARSER.parseFrom(data, extensionRegistry);}
8753cf7638abc778dd72422885dcae4d9cd3bf9149bc19ab34e75f25025db8c2
parseFrom
public static org.apache.avro.protobuf.noopt.Test.Foo parseFrom(com.google.protobuf.ByteString data) throws com.google.protobuf.InvalidProtocolBufferException
{    return PARSER.parseFrom(data);}
63b773ec229835c1103e85d42ba8f25a756fc41b525a031490743ec50996f149
parseFrom
public static org.apache.avro.protobuf.noopt.Test.Foo parseFrom(com.google.protobuf.ByteString data, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException
{    return PARSER.parseFrom(data, extensionRegistry);}
d3771a6b32280ecd517b09295cfad2dea2b893b6d412dba559127efe74766777
parseFrom
public static org.apache.avro.protobuf.noopt.Test.Foo parseFrom(byte[] data) throws com.google.protobuf.InvalidProtocolBufferException
{    return PARSER.parseFrom(data);}
8d6626701d39ea930e57798970c7e3ff7151f65439e4ceb894f01c2822127e85
parseFrom
public static org.apache.avro.protobuf.noopt.Test.Foo parseFrom(byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException
{    return PARSER.parseFrom(data, extensionRegistry);}
3addd73517a9fa21c5a609d5ce62ea776da4f38d1b1c5e86168c1f4e6998e879
parseFrom
public static org.apache.avro.protobuf.noopt.Test.Foo parseFrom(java.io.InputStream input) throws java.io.IOException
{    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);}
0201b32d74353804aa43dfff9932c8bf080d60a188768cd216721727644b31fd
parseFrom
public static org.apache.avro.protobuf.noopt.Test.Foo parseFrom(java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException
{    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input, extensionRegistry);}
f2aa66b27d8ea06fb99b06b02d089dbd76449f37ef9d5b8e29d16a6808e6b578
parseDelimitedFrom
public static org.apache.avro.protobuf.noopt.Test.Foo parseDelimitedFrom(java.io.InputStream input) throws java.io.IOException
{    return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);}
30b27880014e9a0c7529543e832e0d08cb219778b1037a26f6f53f89b111600a
parseDelimitedFrom
public static org.apache.avro.protobuf.noopt.Test.Foo parseDelimitedFrom(java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException
{    return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input, extensionRegistry);}
221788ace1e4381d28ba1c9b824ac0f0a811b0b247228ab8d6a4971c16437861
parseFrom
public static org.apache.avro.protobuf.noopt.Test.Foo parseFrom(com.google.protobuf.CodedInputStream input) throws java.io.IOException
{    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);}
8ade291e3f437b4bdb40312c41e6b66cbf7cb70785d608810655e8a329537236
parseFrom
public static org.apache.avro.protobuf.noopt.Test.Foo parseFrom(com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException
{    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input, extensionRegistry);}
a2589243249ba32b92e98298a2511019cd74b21c911d510f075da5ff7e8b6399
newBuilderForType
public Builder newBuilderForType()
{    return newBuilder();}
e32f866eb7533a232fadc4ef42bb022716435f415dc4a0f7ed4fff845f45ead0
newBuilder
public static Builder newBuilder()
{    return DEFAULT_INSTANCE.toBuilder();}
cbbc1e90d3db58a8f60ff5c870238e390465c1388c649a4c1627c52a0e2adb25
newBuilder
public static Builder newBuilder(org.apache.avro.protobuf.noopt.Test.Foo prototype)
{    return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);}
8f9c3ced03d87377003831ec6560ea40c4b718fc762fc1ca14b030b0ed8256d4
toBuilder
public Builder toBuilder()
{    return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);}
4b6decb5ce35d0ce069dd647bca27ca9f81ed66925e1b833a3512177697f2d3b
newBuilderForType
protected Builder newBuilderForType(com.google.protobuf.GeneratedMessageV3.BuilderParent parent)
{    Builder builder = new Builder(parent);    return builder;}
e061a4269a7822f30b36dfe5c448257acd508bbe5bfe85e23841ca998b986e73
getDescriptor
public static final com.google.protobuf.Descriptors.Descriptor getDescriptor()
{    return org.apache.avro.protobuf.noopt.Test.internal_static_org_apache_avro_protobuf_noopt_Foo_descriptor;}
09b927b3931a0c25b6621043bbd0a8b48cb113bfa27184d786c8e36653bca4dd
internalGetFieldAccessorTable
protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable internalGetFieldAccessorTable()
{    return org.apache.avro.protobuf.noopt.Test.internal_static_org_apache_avro_protobuf_noopt_Foo_fieldAccessorTable.ensureFieldAccessorsInitialized(org.apache.avro.protobuf.noopt.Test.Foo.class, org.apache.avro.protobuf.noopt.Test.Foo.Builder.class);}
7c751d7a2accff7e718ee1e6ea5d2457fe6e182e8c39098e52a8848f56cf2cfe
maybeForceBuilderInitialization
private void maybeForceBuilderInitialization()
{    if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {        getFooArrayFieldBuilder();        getFooFieldBuilder();        getTimestampFieldBuilder();    }}
7930c451f279d9927ff235e4ac064561e1505f9b7ae117d9f681b345534ff9e3
clear
public Builder clear()
{    super.clear();    int32_ = 0;    bitField0_ = (bitField0_ & ~0x00000001);    int64_ = 0L;    bitField0_ = (bitField0_ & ~0x00000002);    uint32_ = 0;    bitField0_ = (bitField0_ & ~0x00000004);    uint64_ = 0L;    bitField0_ = (bitField0_ & ~0x00000008);    sint32_ = 0;    bitField0_ = (bitField0_ & ~0x00000010);    sint64_ = 0L;    bitField0_ = (bitField0_ & ~0x00000020);    fixed32_ = 0;    bitField0_ = (bitField0_ & ~0x00000040);    fixed64_ = 0L;    bitField0_ = (bitField0_ & ~0x00000080);    sfixed32_ = 0;    bitField0_ = (bitField0_ & ~0x00000100);    sfixed64_ = 0L;    bitField0_ = (bitField0_ & ~0x00000200);    float_ = 0F;    bitField0_ = (bitField0_ & ~0x00000400);    double_ = 0D;    bitField0_ = (bitField0_ & ~0x00000800);    bool_ = false;    bitField0_ = (bitField0_ & ~0x00001000);    string_ = "";    bitField0_ = (bitField0_ & ~0x00002000);    bytes_ = com.google.protobuf.ByteString.EMPTY;    bitField0_ = (bitField0_ & ~0x00004000);    enum_ = 3;    bitField0_ = (bitField0_ & ~0x00008000);    intArray_ = java.util.Collections.emptyList();    bitField0_ = (bitField0_ & ~0x00010000);    if (fooArrayBuilder_ == null) {        fooArray_ = java.util.Collections.emptyList();        bitField0_ = (bitField0_ & ~0x00020000);    } else {        fooArrayBuilder_.clear();    }    syms_ = java.util.Collections.emptyList();    bitField0_ = (bitField0_ & ~0x00040000);    if (fooBuilder_ == null) {        foo_ = null;    } else {        fooBuilder_.clear();    }    bitField0_ = (bitField0_ & ~0x00080000);    if (timestampBuilder_ == null) {        timestamp_ = null;    } else {        timestampBuilder_.clear();    }    bitField0_ = (bitField0_ & ~0x00100000);    return this;}
5a2efdcbff6cd8f893a197208cee010e41df6afb0e928da5d7126d953902ee30
getDescriptorForType
public com.google.protobuf.Descriptors.Descriptor getDescriptorForType()
{    return org.apache.avro.protobuf.noopt.Test.internal_static_org_apache_avro_protobuf_noopt_Foo_descriptor;}
b564c6dffa8f9902790828348f4bfa25b018bebde084adfe5429c013568cfbbb
getDefaultInstanceForType
public org.apache.avro.protobuf.noopt.Test.Foo getDefaultInstanceForType()
{    return org.apache.avro.protobuf.noopt.Test.Foo.getDefaultInstance();}
16b9acaf63628aa373f01fa11bf7fc128f3dac72fdc35752ddb846c828c6ffa4
build
public org.apache.avro.protobuf.noopt.Test.Foo build()
{    org.apache.avro.protobuf.noopt.Test.Foo result = buildPartial();    if (!result.isInitialized()) {        throw newUninitializedMessageException(result);    }    return result;}
286eb44138655bbd1203168af2ca18d43058fc501f628b8bc1634a2c2a326bb7
buildPartial
public org.apache.avro.protobuf.noopt.Test.Foo buildPartial()
{    org.apache.avro.protobuf.noopt.Test.Foo result = new org.apache.avro.protobuf.noopt.Test.Foo(this);    int from_bitField0_ = bitField0_;    int to_bitField0_ = 0;    if (((from_bitField0_ & 0x00000001) == 0x00000001)) {        to_bitField0_ |= 0x00000001;    }    result.int32_ = int32_;    if (((from_bitField0_ & 0x00000002) == 0x00000002)) {        to_bitField0_ |= 0x00000002;    }    result.int64_ = int64_;    if (((from_bitField0_ & 0x00000004) == 0x00000004)) {        to_bitField0_ |= 0x00000004;    }    result.uint32_ = uint32_;    if (((from_bitField0_ & 0x00000008) == 0x00000008)) {        to_bitField0_ |= 0x00000008;    }    result.uint64_ = uint64_;    if (((from_bitField0_ & 0x00000010) == 0x00000010)) {        to_bitField0_ |= 0x00000010;    }    result.sint32_ = sint32_;    if (((from_bitField0_ & 0x00000020) == 0x00000020)) {        to_bitField0_ |= 0x00000020;    }    result.sint64_ = sint64_;    if (((from_bitField0_ & 0x00000040) == 0x00000040)) {        to_bitField0_ |= 0x00000040;    }    result.fixed32_ = fixed32_;    if (((from_bitField0_ & 0x00000080) == 0x00000080)) {        to_bitField0_ |= 0x00000080;    }    result.fixed64_ = fixed64_;    if (((from_bitField0_ & 0x00000100) == 0x00000100)) {        to_bitField0_ |= 0x00000100;    }    result.sfixed32_ = sfixed32_;    if (((from_bitField0_ & 0x00000200) == 0x00000200)) {        to_bitField0_ |= 0x00000200;    }    result.sfixed64_ = sfixed64_;    if (((from_bitField0_ & 0x00000400) == 0x00000400)) {        to_bitField0_ |= 0x00000400;    }    result.float_ = float_;    if (((from_bitField0_ & 0x00000800) == 0x00000800)) {        to_bitField0_ |= 0x00000800;    }    result.double_ = double_;    if (((from_bitField0_ & 0x00001000) == 0x00001000)) {        to_bitField0_ |= 0x00001000;    }    result.bool_ = bool_;    if (((from_bitField0_ & 0x00002000) == 0x00002000)) {        to_bitField0_ |= 0x00002000;    }    result.string_ = string_;    if (((from_bitField0_ & 0x00004000) == 0x00004000)) {        to_bitField0_ |= 0x00004000;    }    result.bytes_ = bytes_;    if (((from_bitField0_ & 0x00008000) == 0x00008000)) {        to_bitField0_ |= 0x00008000;    }    result.enum_ = enum_;    if (((bitField0_ & 0x00010000) == 0x00010000)) {        intArray_ = java.util.Collections.unmodifiableList(intArray_);        bitField0_ = (bitField0_ & ~0x00010000);    }    result.intArray_ = intArray_;    if (fooArrayBuilder_ == null) {        if (((bitField0_ & 0x00020000) == 0x00020000)) {            fooArray_ = java.util.Collections.unmodifiableList(fooArray_);            bitField0_ = (bitField0_ & ~0x00020000);        }        result.fooArray_ = fooArray_;    } else {        result.fooArray_ = fooArrayBuilder_.build();    }    if (((bitField0_ & 0x00040000) == 0x00040000)) {        syms_ = java.util.Collections.unmodifiableList(syms_);        bitField0_ = (bitField0_ & ~0x00040000);    }    result.syms_ = syms_;    if (((from_bitField0_ & 0x00080000) == 0x00080000)) {        to_bitField0_ |= 0x00010000;    }    if (fooBuilder_ == null) {        result.foo_ = foo_;    } else {        result.foo_ = fooBuilder_.build();    }    if (((from_bitField0_ & 0x00100000) == 0x00100000)) {        to_bitField0_ |= 0x00020000;    }    if (timestampBuilder_ == null) {        result.timestamp_ = timestamp_;    } else {        result.timestamp_ = timestampBuilder_.build();    }    result.bitField0_ = to_bitField0_;    onBuilt();    return result;}
845fff95a97cf125489126ddee47248563aa80a59ed327d7d1c7cb9d90dcec30
clone
public Builder clone()
{    return (Builder) super.clone();}
e5d5cf46f7f9733e8968952c90ced36c482b5ce6c76f55f96b63b7864c44e8a9
setField
public Builder setField(com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value)
{    return (Builder) super.setField(field, value);}
7230780e7bd47d3ff1bfbd582401f62ac660c4cabdffea3399b812f0ca274023
clearField
public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field)
{    return (Builder) super.clearField(field);}
eb613a9109dd1960f829dd2a97c885c2dcb2e9e5c7eb1830f545fa78ca5217bb
clearOneof
public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof)
{    return (Builder) super.clearOneof(oneof);}
8b65fa0ba0250c27a1784d122c7e82f6a56893f4925b947cc87918e388ed11da
setRepeatedField
public Builder setRepeatedField(com.google.protobuf.Descriptors.FieldDescriptor field, int index, java.lang.Object value)
{    return (Builder) super.setRepeatedField(field, index, value);}
4c493ce9e20cef0f6973f189f8fcec07c11f7ec7a802fb3afe6f948f64f9ea0e
addRepeatedField
public Builder addRepeatedField(com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value)
{    return (Builder) super.addRepeatedField(field, value);}
9c02b14012758934fbc876f583b7201b524cfd4dce350a6fd2cdeea1bb86b6f9
mergeFrom
public Builder mergeFrom(com.google.protobuf.Message other)
{    if (other instanceof org.apache.avro.protobuf.noopt.Test.Foo) {        return mergeFrom((org.apache.avro.protobuf.noopt.Test.Foo) other);    } else {        super.mergeFrom(other);        return this;    }}
c9d20020f6b54f9c174a2952024800369646fd933aae2ca14395c1e8b1d45cee
mergeFrom
public Builder mergeFrom(org.apache.avro.protobuf.noopt.Test.Foo other)
{    if (other == org.apache.avro.protobuf.noopt.Test.Foo.getDefaultInstance())        return this;    if (other.hasInt32()) {        setInt32(other.getInt32());    }    if (other.hasInt64()) {        setInt64(other.getInt64());    }    if (other.hasUint32()) {        setUint32(other.getUint32());    }    if (other.hasUint64()) {        setUint64(other.getUint64());    }    if (other.hasSint32()) {        setSint32(other.getSint32());    }    if (other.hasSint64()) {        setSint64(other.getSint64());    }    if (other.hasFixed32()) {        setFixed32(other.getFixed32());    }    if (other.hasFixed64()) {        setFixed64(other.getFixed64());    }    if (other.hasSfixed32()) {        setSfixed32(other.getSfixed32());    }    if (other.hasSfixed64()) {        setSfixed64(other.getSfixed64());    }    if (other.hasFloat()) {        setFloat(other.getFloat());    }    if (other.hasDouble()) {        setDouble(other.getDouble());    }    if (other.hasBool()) {        setBool(other.getBool());    }    if (other.hasString()) {        bitField0_ |= 0x00002000;        string_ = other.string_;        onChanged();    }    if (other.hasBytes()) {        setBytes(other.getBytes());    }    if (other.hasEnum()) {        setEnum(other.getEnum());    }    if (!other.intArray_.isEmpty()) {        if (intArray_.isEmpty()) {            intArray_ = other.intArray_;            bitField0_ = (bitField0_ & ~0x00010000);        } else {            ensureIntArrayIsMutable();            intArray_.addAll(other.intArray_);        }        onChanged();    }    if (fooArrayBuilder_ == null) {        if (!other.fooArray_.isEmpty()) {            if (fooArray_.isEmpty()) {                fooArray_ = other.fooArray_;                bitField0_ = (bitField0_ & ~0x00020000);            } else {                ensureFooArrayIsMutable();                fooArray_.addAll(other.fooArray_);            }            onChanged();        }    } else {        if (!other.fooArray_.isEmpty()) {            if (fooArrayBuilder_.isEmpty()) {                fooArrayBuilder_.dispose();                fooArrayBuilder_ = null;                fooArray_ = other.fooArray_;                bitField0_ = (bitField0_ & ~0x00020000);                fooArrayBuilder_ = com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ? getFooArrayFieldBuilder() : null;            } else {                fooArrayBuilder_.addAllMessages(other.fooArray_);            }        }    }    if (!other.syms_.isEmpty()) {        if (syms_.isEmpty()) {            syms_ = other.syms_;            bitField0_ = (bitField0_ & ~0x00040000);        } else {            ensureSymsIsMutable();            syms_.addAll(other.syms_);        }        onChanged();    }    if (other.hasFoo()) {        mergeFoo(other.getFoo());    }    if (other.hasTimestamp()) {        mergeTimestamp(other.getTimestamp());    }    this.mergeUnknownFields(other.unknownFields);    onChanged();    return this;}
dde7cd718eaa61cad29906454acf122daba6680a2db55e4787a359a08951b5e7
isInitialized
public final boolean isInitialized()
{    if (!hasInt32()) {        return false;    }    for (int i = 0; i < getFooArrayCount(); i++) {        if (!getFooArray(i).isInitialized()) {            return false;        }    }    if (hasFoo()) {        if (!getFoo().isInitialized()) {            return false;        }    }    return true;}
576f0ac95d3431feb1ba705ec8f537aa5e5a58300021599ce7c111ed9b61d887
mergeFrom
public Builder mergeFrom(com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException
{    org.apache.avro.protobuf.noopt.Test.Foo parsedMessage = null;    try {        parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);    } catch (com.google.protobuf.InvalidProtocolBufferException e) {        parsedMessage = (org.apache.avro.protobuf.noopt.Test.Foo) e.getUnfinishedMessage();        throw e.unwrapIOException();    } finally {        if (parsedMessage != null) {            mergeFrom(parsedMessage);        }    }    return this;}
9a1647854ce456002dcb1c52139e88ef7a23a7d696936d56a15e6d4db0ccb184
hasInt32
public boolean hasInt32()
{    return ((bitField0_ & 0x00000001) == 0x00000001);}
636175cecf2b3f1c8415679f2f0b80d34ba9b63e238193298adf86af15007213
getInt32
public int getInt32()
{    return int32_;}
81a0371eba959f1ecd32cb15307daad2105ca67c981f449dd2465e979f28d7f5
setInt32
public Builder setInt32(int value)
{    bitField0_ |= 0x00000001;    int32_ = value;    onChanged();    return this;}
56200605ac882ae350dfcbc32edfaa63b9e576467f9b22d2bde343c3d345f37b
clearInt32
public Builder clearInt32()
{    bitField0_ = (bitField0_ & ~0x00000001);    int32_ = 0;    onChanged();    return this;}
a2c53766842c579522e01699c16d28ea58a1b49581f61187921336e4ce63b648
hasInt64
public boolean hasInt64()
{    return ((bitField0_ & 0x00000002) == 0x00000002);}
57c8339ea9b07d9b3113d12c4eae4a8a74f2ebd9a6de36dd3cfa42c148f186ab
getInt64
public long getInt64()
{    return int64_;}
8eed8ee04a9e41b5cc2974c805c1c3395268d0e413f05faaa4b2546ac984142e
setInt64
public Builder setInt64(long value)
{    bitField0_ |= 0x00000002;    int64_ = value;    onChanged();    return this;}
d7cbe4f48db39e8ccd041592df84bcdf5cc65c50d090b5426c71d28a99f17129
clearInt64
public Builder clearInt64()
{    bitField0_ = (bitField0_ & ~0x00000002);    int64_ = 0L;    onChanged();    return this;}
2e6ee41b2bb0d50e6b526adc77c21e06d72a1423b637a000776e01b5c2b60cfe
hasUint32
public boolean hasUint32()
{    return ((bitField0_ & 0x00000004) == 0x00000004);}
b7d2e4380f601c73ee0923b2fe9b521818c5ce75b743deec1d19ed294de77dd1
getUint32
public int getUint32()
{    return uint32_;}
9b9c227c619dac7b875f2888f63953096e6c6dfa845cb1bcd7bc63dae2d73d70
setUint32
public Builder setUint32(int value)
{    bitField0_ |= 0x00000004;    uint32_ = value;    onChanged();    return this;}
4b90f40aa6b7efb812a99ff0484ce06a265d29c3b5eef6838eb4108ec953d9aa
clearUint32
public Builder clearUint32()
{    bitField0_ = (bitField0_ & ~0x00000004);    uint32_ = 0;    onChanged();    return this;}
00e677ff71597cdf7ae7ab5e024a2eb75ff3d284223f3c6045ed6dd53e8d0845
hasUint64
public boolean hasUint64()
{    return ((bitField0_ & 0x00000008) == 0x00000008);}
b4b058bcc167225140afd471f432372421b25319080692aa857ca736719bc92b
getUint64
public long getUint64()
{    return uint64_;}
0b9fe6e9e4f205faf9340264b9ffcd8e1693ed31106e622b27cd5e32375604d7
setUint64
public Builder setUint64(long value)
{    bitField0_ |= 0x00000008;    uint64_ = value;    onChanged();    return this;}
12975d8fa7519ad7270a7a744b24993e6f46f552721816145c7437c49037f105
clearUint64
public Builder clearUint64()
{    bitField0_ = (bitField0_ & ~0x00000008);    uint64_ = 0L;    onChanged();    return this;}
2e93fdc6d6c8b20576cd9a0e9d1e183d33569ed069463a98ad5ec167a29d6e14
hasSint32
public boolean hasSint32()
{    return ((bitField0_ & 0x00000010) == 0x00000010);}
75b5ac5769aad1f59a8c73b0547c0c77fc4c170b9c72844230175c2a4ba06ad5
getSint32
public int getSint32()
{    return sint32_;}
ab8018338a5f1892c17aebbaba1649ef95d18c3736984064933ddd33629ea4ee
setSint32
public Builder setSint32(int value)
{    bitField0_ |= 0x00000010;    sint32_ = value;    onChanged();    return this;}
4879a6d592bc9436e3dabe35c9117c97c1cb9ee56afceed068a9744dab9a5452
clearSint32
public Builder clearSint32()
{    bitField0_ = (bitField0_ & ~0x00000010);    sint32_ = 0;    onChanged();    return this;}
31fdd75033679196631750b698981d6dcc9537d93c151d7cbcd4ca46de9d58aa
hasSint64
public boolean hasSint64()
{    return ((bitField0_ & 0x00000020) == 0x00000020);}
75d70e1b7a60651a143d6564f9b40443b64654c71ee48cc41a68029e8c436e18
getSint64
public long getSint64()
{    return sint64_;}
facea82b59c06bf1c2e70535f1f3817dfb44cc5e96a0568f35685220cdcf644c
setSint64
public Builder setSint64(long value)
{    bitField0_ |= 0x00000020;    sint64_ = value;    onChanged();    return this;}
c1c1a8640694d59dc2a48010abcfcdc9947d1876a96791dfd44c658a90fd0878
clearSint64
public Builder clearSint64()
{    bitField0_ = (bitField0_ & ~0x00000020);    sint64_ = 0L;    onChanged();    return this;}
ad9c191d2d327991d4d5c3dea893bb9a901eb34f81ccfc40c50706ef79c1760a
hasFixed32
public boolean hasFixed32()
{    return ((bitField0_ & 0x00000040) == 0x00000040);}
98f6f07472f43870759b408f82612481ade75d1e14ccc2226cec24b686f55050
getFixed32
public int getFixed32()
{    return fixed32_;}
a1188d424119d82835418db265ce43ed3325de207f80da692087d2878e0cb183
setFixed32
public Builder setFixed32(int value)
{    bitField0_ |= 0x00000040;    fixed32_ = value;    onChanged();    return this;}
27bc19cb5785a4835c0e7f550535599d08c3c7b6ffe8f9b6f9e27228c40cce44
clearFixed32
public Builder clearFixed32()
{    bitField0_ = (bitField0_ & ~0x00000040);    fixed32_ = 0;    onChanged();    return this;}
4a6662d0d6f52e9e2b217aaeb86a991de741e56d2eeb146d3d43652fe51a5326
hasFixed64
public boolean hasFixed64()
{    return ((bitField0_ & 0x00000080) == 0x00000080);}
8b9413171a22273aafb43565effc2135094288b4e3333b3afd1e37e629f68fb0
getFixed64
public long getFixed64()
{    return fixed64_;}
d7cbeffb5bab7357bc2adfe1d5717f9386db73d7a92b1a23517bb00a6909eec1
setFixed64
public Builder setFixed64(long value)
{    bitField0_ |= 0x00000080;    fixed64_ = value;    onChanged();    return this;}
59138d31306c5a51cc7106458a758dd21eef639beb5a8b3be984e708f3d6355a
clearFixed64
public Builder clearFixed64()
{    bitField0_ = (bitField0_ & ~0x00000080);    fixed64_ = 0L;    onChanged();    return this;}
41a3547ab4b509363c785a59db522a034320a04eecd00bf28bcc5250c8636cd8
hasSfixed32
public boolean hasSfixed32()
{    return ((bitField0_ & 0x00000100) == 0x00000100);}
64daf2c2e759b26fa9445cc4f9caba82b1aa8040416bdf77dc86a976ef8ede0d
getSfixed32
public int getSfixed32()
{    return sfixed32_;}
d3c4b1daa2e69ca8b5447fc8774096fb219004bc57ed4d66b72fef810068b51c
setSfixed32
public Builder setSfixed32(int value)
{    bitField0_ |= 0x00000100;    sfixed32_ = value;    onChanged();    return this;}
453dfd5d4046ef4007c21067998c64e3fdb0022e31a264a08bc4309639de0279
clearSfixed32
public Builder clearSfixed32()
{    bitField0_ = (bitField0_ & ~0x00000100);    sfixed32_ = 0;    onChanged();    return this;}
45f1bf05257c7a952854e866f6a67f13b5c039f4e8c25738e069ed51eb6f63cf
hasSfixed64
public boolean hasSfixed64()
{    return ((bitField0_ & 0x00000200) == 0x00000200);}
20f25f0e34849b2bce430689f850be46b02bd3b74ea8c5a77b60c18c791e6a64
getSfixed64
public long getSfixed64()
{    return sfixed64_;}
61f714cda299c18e9a6c46c8c4148312448a277d4a872f45316e3f42adc59cac
setSfixed64
public Builder setSfixed64(long value)
{    bitField0_ |= 0x00000200;    sfixed64_ = value;    onChanged();    return this;}
17cfef9c8f2aae31136186277c09db367b1371341034548518d718317d9ee600
clearSfixed64
public Builder clearSfixed64()
{    bitField0_ = (bitField0_ & ~0x00000200);    sfixed64_ = 0L;    onChanged();    return this;}
0cb9fb07dff4d2bfa7ae4bf0843e71fa5fb3d03c06b07c7d2a717ec089d0767e
hasFloat
public boolean hasFloat()
{    return ((bitField0_ & 0x00000400) == 0x00000400);}
ee9a51dbf95b211d37a60138ffb4deb11942d61f5c9721afa1016727fb401415
getFloat
public float getFloat()
{    return float_;}
8b73e0228ee33fc38e9121d5e2b2177e662314e9638c2398f8f1b9b3de2dee6a
setFloat
public Builder setFloat(float value)
{    bitField0_ |= 0x00000400;    float_ = value;    onChanged();    return this;}
38d9c541e25c75f840a4f31457a3d98a878fc6c533d846e09d38a0d8d08802d7
clearFloat
public Builder clearFloat()
{    bitField0_ = (bitField0_ & ~0x00000400);    float_ = 0F;    onChanged();    return this;}
e28f40a1dd04174c7100c4112d5ed5b5772e98d43d41f2d671ff567e0f4c6ce5
hasDouble
public boolean hasDouble()
{    return ((bitField0_ & 0x00000800) == 0x00000800);}
95f35c6fbf999bf94e0a9c9c5fa482ed65318ab2572fb3b51e8c181fc2611e97
getDouble
public double getDouble()
{    return double_;}
3d668ab6408ef82ed76027849099060f25f30f99efb9ec1af6053caad88c7e16
setDouble
public Builder setDouble(double value)
{    bitField0_ |= 0x00000800;    double_ = value;    onChanged();    return this;}
d103bd983f690a8d518d2cace9de4d587b198c50ae08498dfd64bfdc10b2d7b9
clearDouble
public Builder clearDouble()
{    bitField0_ = (bitField0_ & ~0x00000800);    double_ = 0D;    onChanged();    return this;}
586ca0c2bb6da45de72704084c6e31b535779b9f3166053de6d5c3114e808751
hasBool
public boolean hasBool()
{    return ((bitField0_ & 0x00001000) == 0x00001000);}
f5d970ff55271bea91b285c75a149e090505eb675c4e8194d9e1e500461f90e8
getBool
public boolean getBool()
{    return bool_;}
e7aa78c3b4280641a1e8e4e7af85adaae7f0050998637ba3acc2f5ec4ef26044
setBool
public Builder setBool(boolean value)
{    bitField0_ |= 0x00001000;    bool_ = value;    onChanged();    return this;}
ca8d354815dd275a5c4fd9c8c006006e341beb3ebf998f97c0ad574333231f04
clearBool
public Builder clearBool()
{    bitField0_ = (bitField0_ & ~0x00001000);    bool_ = false;    onChanged();    return this;}
3f0c31e577682520c0fcca7daaaf896b908ba830b55ce04569418803a52cead8
hasString
public boolean hasString()
{    return ((bitField0_ & 0x00002000) == 0x00002000);}
7c4c17115810ae3f13bf8deca5f5267c8cb89c0f70fafecb78a67ebd65ae6b37
getString
public java.lang.String getString()
{    java.lang.Object ref = string_;    if (!(ref instanceof java.lang.String)) {        com.google.protobuf.ByteString bs = (com.google.protobuf.ByteString) ref;        java.lang.String s = bs.toStringUtf8();        if (bs.isValidUtf8()) {            string_ = s;        }        return s;    } else {        return (java.lang.String) ref;    }}
404c2340dc76857ee9b3d6bb2a82a6697881da7fa911e1d8af649f5b71248a3a
getStringBytes
public com.google.protobuf.ByteString getStringBytes()
{    java.lang.Object ref = string_;    if (ref instanceof String) {        com.google.protobuf.ByteString b = com.google.protobuf.ByteString.copyFromUtf8((java.lang.String) ref);        string_ = b;        return b;    } else {        return (com.google.protobuf.ByteString) ref;    }}
2ff4df9a7941fbd2b7640f32e30714e499206cde93d7dd3a51b702ee122f1da8
setString
public Builder setString(java.lang.String value)
{    if (value == null) {        throw new NullPointerException();    }    bitField0_ |= 0x00002000;    string_ = value;    onChanged();    return this;}
503c7445bfed06cdac3042eca742fb37d6b83a99d3baaadbe2eaeea1e97200d7
clearString
public Builder clearString()
{    bitField0_ = (bitField0_ & ~0x00002000);    string_ = getDefaultInstance().getString();    onChanged();    return this;}
24dfea53c0f7d39e2b616898458ae4a0d2195bb2b40bb355b9982d3549224623
setStringBytes
public Builder setStringBytes(com.google.protobuf.ByteString value)
{    if (value == null) {        throw new NullPointerException();    }    bitField0_ |= 0x00002000;    string_ = value;    onChanged();    return this;}
75a99db492c7f97c17d6844f9a82e00a4b1f11fd35d8ea25d7d55a21df04ad6a
hasBytes
public boolean hasBytes()
{    return ((bitField0_ & 0x00004000) == 0x00004000);}
d6cf6f44c45e7e724dce80e785110e2196522fe8c0a756ce8d5e75c119e561c5
getBytes
public com.google.protobuf.ByteString getBytes()
{    return bytes_;}
88eed676a0332210956dc7d6eb83802233e3b27eb4738fba09fbddbd029276a0
setBytes
public Builder setBytes(com.google.protobuf.ByteString value)
{    if (value == null) {        throw new NullPointerException();    }    bitField0_ |= 0x00004000;    bytes_ = value;    onChanged();    return this;}
a54f936ae686d9860ce0eb0ece5f75fc284228a1bed7e0bc25830206169c750b
clearBytes
public Builder clearBytes()
{    bitField0_ = (bitField0_ & ~0x00004000);    bytes_ = getDefaultInstance().getBytes();    onChanged();    return this;}
698a189fcb3c994fa12118569041c84a5d6176385eb353c702935c048c13d88b
hasEnum
public boolean hasEnum()
{    return ((bitField0_ & 0x00008000) == 0x00008000);}
c14ce52769665c416d91d8ebd91edc675f85635f4853547b159498e112e1b6c7
getEnum
public org.apache.avro.protobuf.noopt.Test.A getEnum()
{    org.apache.avro.protobuf.noopt.Test.A result = org.apache.avro.protobuf.noopt.Test.A.valueOf(enum_);    return result == null ? org.apache.avro.protobuf.noopt.Test.A.Z : result;}
54a755cb3df13e1009609e1e50ae665352483242ee32a9a42e8e912b61e089ab
setEnum
public Builder setEnum(org.apache.avro.protobuf.noopt.Test.A value)
{    if (value == null) {        throw new NullPointerException();    }    bitField0_ |= 0x00008000;    enum_ = value.getNumber();    onChanged();    return this;}
c525157ec8955cc2e0945126e42e2298c7c37ccf5375131361a90908a6f1f43d
clearEnum
public Builder clearEnum()
{    bitField0_ = (bitField0_ & ~0x00008000);    enum_ = 3;    onChanged();    return this;}
390283023049eb4d4b452ab416152e55eb7d57a5c96af183244e4fb45d8f1a83
ensureIntArrayIsMutable
private void ensureIntArrayIsMutable()
{    if (!((bitField0_ & 0x00010000) == 0x00010000)) {        intArray_ = new java.util.ArrayList<java.lang.Integer>(intArray_);        bitField0_ |= 0x00010000;    }}
0dbd424bbcce9aded3aad4770c8ffb4c32f758322b180e89d544aa54302c6728
getIntArrayList
public java.util.List<java.lang.Integer> getIntArrayList()
{    return java.util.Collections.unmodifiableList(intArray_);}
31b4697dd384dd0bd1bde310af3b62067c0a1ad32cc543d5063825eeb8bd56b3
getIntArrayCount
public int getIntArrayCount()
{    return intArray_.size();}
2e098f94a8cd1017c27e6f532faec1cc3c3f5529d9acf62fca5795b2889dd67a
getIntArray
public int getIntArray(int index)
{    return intArray_.get(index);}
6249e7d548a1302ad9afbb6d2537ef456e1c60bf1d14167ff7f0edafce388a17
setIntArray
public Builder setIntArray(int index, int value)
{    ensureIntArrayIsMutable();    intArray_.set(index, value);    onChanged();    return this;}
a35c81259e2605db9d967f4f9b9cad81895478a00d3840922f3837b89a294248
addIntArray
public Builder addIntArray(int value)
{    ensureIntArrayIsMutable();    intArray_.add(value);    onChanged();    return this;}
9b7bf02c1b239538eec8b27663b8c805b5244492ac65d601b1996e237840c6f5
addAllIntArray
public Builder addAllIntArray(java.lang.Iterable<? extends java.lang.Integer> values)
{    ensureIntArrayIsMutable();    com.google.protobuf.AbstractMessageLite.Builder.addAll(values, intArray_);    onChanged();    return this;}
254c5f68ef783db246155ff9a5672dc2500cbcdcd3a4316e985f1943fe79d6bc
clearIntArray
public Builder clearIntArray()
{    intArray_ = java.util.Collections.emptyList();    bitField0_ = (bitField0_ & ~0x00010000);    onChanged();    return this;}
5ee8e5ab40d600b7fdec08e36ee5a503cbfac187f12dd459945545210f8686e3
ensureFooArrayIsMutable
private void ensureFooArrayIsMutable()
{    if (!((bitField0_ & 0x00020000) == 0x00020000)) {        fooArray_ = new java.util.ArrayList<org.apache.avro.protobuf.noopt.Test.Foo>(fooArray_);        bitField0_ |= 0x00020000;    }}
603fed82711117492afbd9b860cd9fc219c21b0578ddf67c11c599f2942224ec
getFooArrayList
public java.util.List<org.apache.avro.protobuf.noopt.Test.Foo> getFooArrayList()
{    if (fooArrayBuilder_ == null) {        return java.util.Collections.unmodifiableList(fooArray_);    } else {        return fooArrayBuilder_.getMessageList();    }}
fd2ac97f74deac4a599110fe63068fdd22b2fde4ae9928305d79d7d01629765c
getFooArrayCount
public int getFooArrayCount()
{    if (fooArrayBuilder_ == null) {        return fooArray_.size();    } else {        return fooArrayBuilder_.getCount();    }}
b7c76b6457d027d90ca93915f809637fb4f77a51824e17e3cdff921e146afbc6
getFooArray
public org.apache.avro.protobuf.noopt.Test.Foo getFooArray(int index)
{    if (fooArrayBuilder_ == null) {        return fooArray_.get(index);    } else {        return fooArrayBuilder_.getMessage(index);    }}
026bbe536b41c269cb32531051eba28f223762fc287627a583ecd9c45557e51d
setFooArray
public Builder setFooArray(int index, org.apache.avro.protobuf.noopt.Test.Foo value)
{    if (fooArrayBuilder_ == null) {        if (value == null) {            throw new NullPointerException();        }        ensureFooArrayIsMutable();        fooArray_.set(index, value);        onChanged();    } else {        fooArrayBuilder_.setMessage(index, value);    }    return this;}
a9275c81e6579e1d4398f2222431fb78c5c9357550ad79e4d42221eda60e879b
setFooArray
public Builder setFooArray(int index, org.apache.avro.protobuf.noopt.Test.Foo.Builder builderForValue)
{    if (fooArrayBuilder_ == null) {        ensureFooArrayIsMutable();        fooArray_.set(index, builderForValue.build());        onChanged();    } else {        fooArrayBuilder_.setMessage(index, builderForValue.build());    }    return this;}
8f6d63d835c93ca72489ab2c768d2d336c3e8a72513509cce4c83f652b7013c4
addFooArray
public Builder addFooArray(org.apache.avro.protobuf.noopt.Test.Foo value)
{    if (fooArrayBuilder_ == null) {        if (value == null) {            throw new NullPointerException();        }        ensureFooArrayIsMutable();        fooArray_.add(value);        onChanged();    } else {        fooArrayBuilder_.addMessage(value);    }    return this;}
c11c03d3f2a961b40c7bb2b752081b8f4b3dca4b7fe82dff6a49a50f0dc20735
addFooArray
public Builder addFooArray(int index, org.apache.avro.protobuf.noopt.Test.Foo value)
{    if (fooArrayBuilder_ == null) {        if (value == null) {            throw new NullPointerException();        }        ensureFooArrayIsMutable();        fooArray_.add(index, value);        onChanged();    } else {        fooArrayBuilder_.addMessage(index, value);    }    return this;}
35583309f6cb10bde46be5315db0efb58ff656fe83029af5b7ea846861dcbc21
addFooArray
public Builder addFooArray(org.apache.avro.protobuf.noopt.Test.Foo.Builder builderForValue)
{    if (fooArrayBuilder_ == null) {        ensureFooArrayIsMutable();        fooArray_.add(builderForValue.build());        onChanged();    } else {        fooArrayBuilder_.addMessage(builderForValue.build());    }    return this;}
0a4eca47d782873f7ec346b1a8d541ef06f46ef743c57abea81a94e58c07795f
addFooArray
public Builder addFooArray(int index, org.apache.avro.protobuf.noopt.Test.Foo.Builder builderForValue)
{    if (fooArrayBuilder_ == null) {        ensureFooArrayIsMutable();        fooArray_.add(index, builderForValue.build());        onChanged();    } else {        fooArrayBuilder_.addMessage(index, builderForValue.build());    }    return this;}
48a871dc918722131fe6065e6a7c826d82e0def51bf0e18b05b59ae0da00ab7f
addAllFooArray
public Builder addAllFooArray(java.lang.Iterable<? extends org.apache.avro.protobuf.noopt.Test.Foo> values)
{    if (fooArrayBuilder_ == null) {        ensureFooArrayIsMutable();        com.google.protobuf.AbstractMessageLite.Builder.addAll(values, fooArray_);        onChanged();    } else {        fooArrayBuilder_.addAllMessages(values);    }    return this;}
8bf91b917867b7d5c9076c48559b33c4c9dd3b0cdf4a307d8f982c1090ed03c2
clearFooArray
public Builder clearFooArray()
{    if (fooArrayBuilder_ == null) {        fooArray_ = java.util.Collections.emptyList();        bitField0_ = (bitField0_ & ~0x00020000);        onChanged();    } else {        fooArrayBuilder_.clear();    }    return this;}
cfa5b40f118d0917714c4eb7f75820077e2a60507503c64b6779eb73e92bd8a7
removeFooArray
public Builder removeFooArray(int index)
{    if (fooArrayBuilder_ == null) {        ensureFooArrayIsMutable();        fooArray_.remove(index);        onChanged();    } else {        fooArrayBuilder_.remove(index);    }    return this;}
8bf95bba6daff9d6a42ebf59c143882e7f48ef9e9adc360698bb7d95e02f5bf6
getFooArrayBuilder
public org.apache.avro.protobuf.noopt.Test.Foo.Builder getFooArrayBuilder(int index)
{    return getFooArrayFieldBuilder().getBuilder(index);}
43847fc925329fdcabbe001cca247052b636d7b946f54dc6fa231c4d60411674
getFooArrayOrBuilder
public org.apache.avro.protobuf.noopt.Test.FooOrBuilder getFooArrayOrBuilder(int index)
{    if (fooArrayBuilder_ == null) {        return fooArray_.get(index);    } else {        return fooArrayBuilder_.getMessageOrBuilder(index);    }}
ec5283fcc56c5315b77665a2ff4cd521696b1b8c595e93575e02ba1698493914
getFooArrayOrBuilderList
public java.util.List<? extends org.apache.avro.protobuf.noopt.Test.FooOrBuilder> getFooArrayOrBuilderList()
{    if (fooArrayBuilder_ != null) {        return fooArrayBuilder_.getMessageOrBuilderList();    } else {        return java.util.Collections.unmodifiableList(fooArray_);    }}
009beacc4005a8a62112c7cccab3151e767b156a886357de6fbc5e1a48084269
addFooArrayBuilder
public org.apache.avro.protobuf.noopt.Test.Foo.Builder addFooArrayBuilder()
{    return getFooArrayFieldBuilder().addBuilder(org.apache.avro.protobuf.noopt.Test.Foo.getDefaultInstance());}
be3fffedcec1546ff7586bdfc1095aa2ee98fcdb1c2e24de600ca84a7277be14
addFooArrayBuilder
public org.apache.avro.protobuf.noopt.Test.Foo.Builder addFooArrayBuilder(int index)
{    return getFooArrayFieldBuilder().addBuilder(index, org.apache.avro.protobuf.noopt.Test.Foo.getDefaultInstance());}
c526a809e804e50b5fc3b4a33501639f64073eff2c35ec4e429aa5ee22c0b651
getFooArrayBuilderList
public java.util.List<org.apache.avro.protobuf.noopt.Test.Foo.Builder> getFooArrayBuilderList()
{    return getFooArrayFieldBuilder().getBuilderList();}
0d89be3bc987fb60a9dbee6bdde2806b41049cd158971ecaa31f5fa8d0a4dc94
getFooArrayFieldBuilder
private com.google.protobuf.RepeatedFieldBuilderV3<org.apache.avro.protobuf.noopt.Test.Foo, org.apache.avro.protobuf.noopt.Test.Foo.Builder, org.apache.avro.protobuf.noopt.Test.FooOrBuilder> getFooArrayFieldBuilder()
{    if (fooArrayBuilder_ == null) {        fooArrayBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<org.apache.avro.protobuf.noopt.Test.Foo, org.apache.avro.protobuf.noopt.Test.Foo.Builder, org.apache.avro.protobuf.noopt.Test.FooOrBuilder>(fooArray_, ((bitField0_ & 0x00020000) == 0x00020000), getParentForChildren(), isClean());        fooArray_ = null;    }    return fooArrayBuilder_;}
d552a07945f510005d12bd021ba3808b9b70a38d5130a7aaaacd3f06f40df266
ensureSymsIsMutable
private void ensureSymsIsMutable()
{    if (!((bitField0_ & 0x00040000) == 0x00040000)) {        syms_ = new java.util.ArrayList<java.lang.Integer>(syms_);        bitField0_ |= 0x00040000;    }}
3320cc00930a1aba8c0e0499908c073b993e7bc83eede54b2bdf94678bb4326a
getSymsList
public java.util.List<org.apache.avro.protobuf.noopt.Test.A> getSymsList()
{    return new com.google.protobuf.Internal.ListAdapter<java.lang.Integer, org.apache.avro.protobuf.noopt.Test.A>(syms_, syms_converter_);}
184c0551fc5d1c2cbff289a02240b91ff20c32be2e794e0f47a61014a4b8d156
getSymsCount
public int getSymsCount()
{    return syms_.size();}
3957a07951accfa2fd2ecc2c75c2072f8833d1bea79ad14514810e5211d0d5ff
getSyms
public org.apache.avro.protobuf.noopt.Test.A getSyms(int index)
{    return syms_converter_.convert(syms_.get(index));}
cf0db0e250784dd57ebc105ea1b7998a4fe08a8d1487379e37b9bfdb68bbc206
setSyms
public Builder setSyms(int index, org.apache.avro.protobuf.noopt.Test.A value)
{    if (value == null) {        throw new NullPointerException();    }    ensureSymsIsMutable();    syms_.set(index, value.getNumber());    onChanged();    return this;}
2d621c1d4b089d6df357c969eaf526782848c40391055a155da09bfe95331bf1
addSyms
public Builder addSyms(org.apache.avro.protobuf.noopt.Test.A value)
{    if (value == null) {        throw new NullPointerException();    }    ensureSymsIsMutable();    syms_.add(value.getNumber());    onChanged();    return this;}
8783a3d04265a046f8a99000f347462b09075b4723498145c606e8952a41cdd8
addAllSyms
public Builder addAllSyms(java.lang.Iterable<? extends org.apache.avro.protobuf.noopt.Test.A> values)
{    ensureSymsIsMutable();    for (org.apache.avro.protobuf.noopt.Test.A value : values) {        syms_.add(value.getNumber());    }    onChanged();    return this;}
6e95a5be67fe5a5696be8b576419149af2bc6e790ab52b29cefb65a031819de9
clearSyms
public Builder clearSyms()
{    syms_ = java.util.Collections.emptyList();    bitField0_ = (bitField0_ & ~0x00040000);    onChanged();    return this;}
10058f491b0a4a5c22162369389d3ed8276668e2d04db758b35d31010e7e4677
hasFoo
public boolean hasFoo()
{    return ((bitField0_ & 0x00080000) == 0x00080000);}
66003ab0ca4e8aca5f3e69205233160711731f6209444bbfbf1b34070c589be7
getFoo
public org.apache.avro.protobuf.noopt.Test.Foo getFoo()
{    if (fooBuilder_ == null) {        return foo_ == null ? org.apache.avro.protobuf.noopt.Test.Foo.getDefaultInstance() : foo_;    } else {        return fooBuilder_.getMessage();    }}
ba809a5244ae36d697e8cda96cde98dfbee6b0df059382dd14e490c090747942
setFoo
public Builder setFoo(org.apache.avro.protobuf.noopt.Test.Foo value)
{    if (fooBuilder_ == null) {        if (value == null) {            throw new NullPointerException();        }        foo_ = value;        onChanged();    } else {        fooBuilder_.setMessage(value);    }    bitField0_ |= 0x00080000;    return this;}
ee5d2a062fe296b58ba34f5b7c5d03f1c70d1327f309a06ee4971ad0869f4247
setFoo
public Builder setFoo(org.apache.avro.protobuf.noopt.Test.Foo.Builder builderForValue)
{    if (fooBuilder_ == null) {        foo_ = builderForValue.build();        onChanged();    } else {        fooBuilder_.setMessage(builderForValue.build());    }    bitField0_ |= 0x00080000;    return this;}
a96cfc69d67a7d7ee7237bfa54266e5d892a067f471e8701e898e5497ebf98b4
mergeFoo
public Builder mergeFoo(org.apache.avro.protobuf.noopt.Test.Foo value)
{    if (fooBuilder_ == null) {        if (((bitField0_ & 0x00080000) == 0x00080000) && foo_ != null && foo_ != org.apache.avro.protobuf.noopt.Test.Foo.getDefaultInstance()) {            foo_ = org.apache.avro.protobuf.noopt.Test.Foo.newBuilder(foo_).mergeFrom(value).buildPartial();        } else {            foo_ = value;        }        onChanged();    } else {        fooBuilder_.mergeFrom(value);    }    bitField0_ |= 0x00080000;    return this;}
0f7dd4f625bb65449bbe2e1c488eb3c5e1aeb9d18a66edd0456b591f20723ac2
clearFoo
public Builder clearFoo()
{    if (fooBuilder_ == null) {        foo_ = null;        onChanged();    } else {        fooBuilder_.clear();    }    bitField0_ = (bitField0_ & ~0x00080000);    return this;}
e9e93d2a45d81da9db6e140e5eca950be1811ebdadb06ea066d2fd396a252985
getFooBuilder
public org.apache.avro.protobuf.noopt.Test.Foo.Builder getFooBuilder()
{    bitField0_ |= 0x00080000;    onChanged();    return getFooFieldBuilder().getBuilder();}
3369f11fd202817f079bdd6ed96a9129b6cd6e67892de5636fbabe87961eb373
getFooOrBuilder
public org.apache.avro.protobuf.noopt.Test.FooOrBuilder getFooOrBuilder()
{    if (fooBuilder_ != null) {        return fooBuilder_.getMessageOrBuilder();    } else {        return foo_ == null ? org.apache.avro.protobuf.noopt.Test.Foo.getDefaultInstance() : foo_;    }}
c12ea8df8516125e89e185ab6dd0ba56961bc0b188043504e76bd9110b74a5b2
getFooFieldBuilder
private com.google.protobuf.SingleFieldBuilderV3<org.apache.avro.protobuf.noopt.Test.Foo, org.apache.avro.protobuf.noopt.Test.Foo.Builder, org.apache.avro.protobuf.noopt.Test.FooOrBuilder> getFooFieldBuilder()
{    if (fooBuilder_ == null) {        fooBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<org.apache.avro.protobuf.noopt.Test.Foo, org.apache.avro.protobuf.noopt.Test.Foo.Builder, org.apache.avro.protobuf.noopt.Test.FooOrBuilder>(getFoo(), getParentForChildren(), isClean());        foo_ = null;    }    return fooBuilder_;}
bafb11dbca36e09bf79e4baa90c93a1bc1422a322f7ad686efa10ecb036831b5
hasTimestamp
public boolean hasTimestamp()
{    return ((bitField0_ & 0x00100000) == 0x00100000);}
c66f064664f32c706c67564ca4c770ad74baa2e4df0c3a6eccb1177407cc2c5e
getTimestamp
public com.google.protobuf.Timestamp getTimestamp()
{    if (timestampBuilder_ == null) {        return timestamp_ == null ? com.google.protobuf.Timestamp.getDefaultInstance() : timestamp_;    } else {        return timestampBuilder_.getMessage();    }}
55a39ac3f0a927983a1c3888166d7528a4c9aa21e32fece7e8fff2c136c48178
setTimestamp
public Builder setTimestamp(com.google.protobuf.Timestamp value)
{    if (timestampBuilder_ == null) {        if (value == null) {            throw new NullPointerException();        }        timestamp_ = value;        onChanged();    } else {        timestampBuilder_.setMessage(value);    }    bitField0_ |= 0x00100000;    return this;}
e5066f7ba625cc4e4254f726ba7a91a8dedc2ae5e1802f433d1c6954a5b83d99
setTimestamp
public Builder setTimestamp(com.google.protobuf.Timestamp.Builder builderForValue)
{    if (timestampBuilder_ == null) {        timestamp_ = builderForValue.build();        onChanged();    } else {        timestampBuilder_.setMessage(builderForValue.build());    }    bitField0_ |= 0x00100000;    return this;}
ba1d95f2cd261e974784c52e4c028bdea11c6edfceb3355834e01e9d4f2cc909
mergeTimestamp
public Builder mergeTimestamp(com.google.protobuf.Timestamp value)
{    if (timestampBuilder_ == null) {        if (((bitField0_ & 0x00100000) == 0x00100000) && timestamp_ != null && timestamp_ != com.google.protobuf.Timestamp.getDefaultInstance()) {            timestamp_ = com.google.protobuf.Timestamp.newBuilder(timestamp_).mergeFrom(value).buildPartial();        } else {            timestamp_ = value;        }        onChanged();    } else {        timestampBuilder_.mergeFrom(value);    }    bitField0_ |= 0x00100000;    return this;}
ea6e39b94b17e7825f2c3e2bac3436f7c97b6b56562dbd771a5e799c372942be
clearTimestamp
public Builder clearTimestamp()
{    if (timestampBuilder_ == null) {        timestamp_ = null;        onChanged();    } else {        timestampBuilder_.clear();    }    bitField0_ = (bitField0_ & ~0x00100000);    return this;}
e1f1395458d6fb670f001c844aab49b357be1a902730cc855ecee5ba6b3b8b38
getTimestampBuilder
public com.google.protobuf.Timestamp.Builder getTimestampBuilder()
{    bitField0_ |= 0x00100000;    onChanged();    return getTimestampFieldBuilder().getBuilder();}
1a895b7c2c7d5a9cb1b98abc55c3ddb581f84797f811e5056403cde4d040aebb
getTimestampOrBuilder
public com.google.protobuf.TimestampOrBuilder getTimestampOrBuilder()
{    if (timestampBuilder_ != null) {        return timestampBuilder_.getMessageOrBuilder();    } else {        return timestamp_ == null ? com.google.protobuf.Timestamp.getDefaultInstance() : timestamp_;    }}
9f09eeb20bd3b040cce8ad189bc4a1c3382c9e3f370690a6142484d958da78e7
getTimestampFieldBuilder
private com.google.protobuf.SingleFieldBuilderV3<com.google.protobuf.Timestamp, com.google.protobuf.Timestamp.Builder, com.google.protobuf.TimestampOrBuilder> getTimestampFieldBuilder()
{    if (timestampBuilder_ == null) {        timestampBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<com.google.protobuf.Timestamp, com.google.protobuf.Timestamp.Builder, com.google.protobuf.TimestampOrBuilder>(getTimestamp(), getParentForChildren(), isClean());        timestamp_ = null;    }    return timestampBuilder_;}
c3f82e9354e0de24294e8d24ddd4cc78edfdbc227b0b6784774ae4f90f8803a5
setUnknownFields
public final Builder setUnknownFields(final com.google.protobuf.UnknownFieldSet unknownFields)
{    return super.setUnknownFields(unknownFields);}
112ef20f9bae5594feab16e3416756e8f3a1b669246aa50338f4c67470eebe6a
mergeUnknownFields
public final Builder mergeUnknownFields(final com.google.protobuf.UnknownFieldSet unknownFields)
{    return super.mergeUnknownFields(unknownFields);}
3b20443dcc145960063361ab4f2a513407dcefdc02b3ca2cf8d84433e63fc870
getDefaultInstance
public static org.apache.avro.protobuf.noopt.Test.Foo getDefaultInstance()
{    return DEFAULT_INSTANCE;}
6ae5129ef376bf26e1ca0f026e637d2b3f43ce543a4e276e4a2bf88ebe148f77
parsePartialFrom
public Foo parsePartialFrom(com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException
{    return new Foo(input, extensionRegistry);}
af150e3fd63310ad66d4b545e86fb40dc752c777e3487b148de3aad7ce8dec3a
parser
public static com.google.protobuf.Parser<Foo> parser()
{    return PARSER;}
3de5fbe294e8f85075d1e9bbcc1a4f8de484abc69402a976fcb8e157c65cd13a
getParserForType
public com.google.protobuf.Parser<Foo> getParserForType()
{    return PARSER;}
b564c6dffa8f9902790828348f4bfa25b018bebde084adfe5429c013568cfbbb
getDefaultInstanceForType
public org.apache.avro.protobuf.noopt.Test.Foo getDefaultInstanceForType()
{    return DEFAULT_INSTANCE;}
afeb2882aee0a13dc444e9d430b86a6dc175c48ee917722e2d5ab50801b7ab38
getUnknownFields
public final com.google.protobuf.UnknownFieldSet getUnknownFields()
{    return this.unknownFields;}
e061a4269a7822f30b36dfe5c448257acd508bbe5bfe85e23841ca998b986e73
getDescriptor
public static final com.google.protobuf.Descriptors.Descriptor getDescriptor()
{    return org.apache.avro.protobuf.noopt.Test.internal_static_org_apache_avro_protobuf_noopt_M_descriptor;}
09b927b3931a0c25b6621043bbd0a8b48cb113bfa27184d786c8e36653bca4dd
internalGetFieldAccessorTable
protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable internalGetFieldAccessorTable()
{    return org.apache.avro.protobuf.noopt.Test.internal_static_org_apache_avro_protobuf_noopt_M_fieldAccessorTable.ensureFieldAccessorsInitialized(org.apache.avro.protobuf.noopt.Test.M.class, org.apache.avro.protobuf.noopt.Test.M.Builder.class);}
35f3ec879596849ae2c78c5ba39ee17b816937a06f86452b7ab8b2af2a96533b
getNumber
public final int getNumber()
{    return value;}
a14813aeee6defb9d1eb71beab5550f9e0ab56b3ef1b6aa3941a952a24ef40aa
valueOf
public static N valueOf(int value)
{    return forNumber(value);}
1f56bfcac716967d2427a83c178f59f9e2847fd2146224e7208056fe0cbf7142
forNumber
public static N forNumber(int value)
{    switch(value) {        case 1:            return A;        default:            return null;    }}
aa8b41b95ab574070eb6c4f15f1a6269280b5ee7495cb95b45fd4d99f43ec8b5
internalGetValueMap
public static com.google.protobuf.Internal.EnumLiteMap<N> internalGetValueMap()
{    return internalValueMap;}
4fc75831c74a9fe8f0ebd5a4cf16fb3be4d7f9032e81f52e593c1b64023f4920
findValueByNumber
public N findValueByNumber(int number)
{    return N.forNumber(number);}
369cb5b49c34ac1de71984da1ee6a33e3f379bcd8089b809c272768420d70b36
getValueDescriptor
public final com.google.protobuf.Descriptors.EnumValueDescriptor getValueDescriptor()
{    return getDescriptor().getValues().get(ordinal());}
135f17befa1c20386f8dd8256e8d90b6f3e8cec3374799ac7e99f05fb221f93d
getDescriptorForType
public final com.google.protobuf.Descriptors.EnumDescriptor getDescriptorForType()
{    return getDescriptor();}
94c5986db9187ae1728adb5adc6399ab98540d464821f94b52ab256a9f722e1c
getDescriptor
public static final com.google.protobuf.Descriptors.EnumDescriptor getDescriptor()
{    return org.apache.avro.protobuf.noopt.Test.M.getDescriptor().getEnumTypes().get(0);}
ee5f83cece49be136cbb6f9fe817c724f07e91787c903b17cea25576f675777d
valueOf
public static N valueOf(com.google.protobuf.Descriptors.EnumValueDescriptor desc)
{    if (desc.getType() != getDescriptor()) {        throw new java.lang.IllegalArgumentException("EnumValueDescriptor is not for this type.");    }    return VALUES[desc.getIndex()];}
dde7cd718eaa61cad29906454acf122daba6680a2db55e4787a359a08951b5e7
isInitialized
public final boolean isInitialized()
{    byte isInitialized = memoizedIsInitialized;    if (isInitialized == 1)        return true;    if (isInitialized == 0)        return false;    memoizedIsInitialized = 1;    return true;}
b78da5ac0d0f56440a60e0c8711e74775e8d0aafe7882e5346a5dcc6fa783f73
writeTo
public void writeTo(com.google.protobuf.CodedOutputStream output) throws java.io.IOException
{    unknownFields.writeTo(output);}
2bd67191ad73644076f3a74f7b306983cf9bd449d2e535f9b7f802bd0492f9f1
getSerializedSize
public int getSerializedSize()
{    int size = memoizedSize;    if (size != -1)        return size;    size = 0;    size += unknownFields.getSerializedSize();    memoizedSize = size;    return size;}
c16419e263b56042dfd908ea4d6500d086628461f2faaccf6ad79f7d3aa82321
equals
public boolean equals(final java.lang.Object obj)
{    if (obj == this) {        return true;    }    if (!(obj instanceof org.apache.avro.protobuf.noopt.Test.M)) {        return super.equals(obj);    }    org.apache.avro.protobuf.noopt.Test.M other = (org.apache.avro.protobuf.noopt.Test.M) obj;    boolean result = true;    result = result && unknownFields.equals(other.unknownFields);    return result;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    if (memoizedHashCode != 0) {        return memoizedHashCode;    }    int hash = 41;    hash = (19 * hash) + getDescriptor().hashCode();    hash = (29 * hash) + unknownFields.hashCode();    memoizedHashCode = hash;    return hash;}
efc20edf72d547ffd94f2d0d285d1feab08a2cd682af10655cfdaa46412d433d
parseFrom
public static org.apache.avro.protobuf.noopt.Test.M parseFrom(java.nio.ByteBuffer data) throws com.google.protobuf.InvalidProtocolBufferException
{    return PARSER.parseFrom(data);}
9a0d25bff3cd4ad32310980885e60144235152274dd6b5cfeac403201e5a8807
parseFrom
public static org.apache.avro.protobuf.noopt.Test.M parseFrom(java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException
{    return PARSER.parseFrom(data, extensionRegistry);}
9c7d330fcbe6d03da0133a525ff8a1407f82bb51d317f878b8f34bbb6aa4b5a4
parseFrom
public static org.apache.avro.protobuf.noopt.Test.M parseFrom(com.google.protobuf.ByteString data) throws com.google.protobuf.InvalidProtocolBufferException
{    return PARSER.parseFrom(data);}
5cb4a69a37d40b489c4a5c0a08e3c4235932930c8344bdfbea636384682a22b7
parseFrom
public static org.apache.avro.protobuf.noopt.Test.M parseFrom(com.google.protobuf.ByteString data, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException
{    return PARSER.parseFrom(data, extensionRegistry);}
edd90ca2803ab4c97e31b312fd12fd283bfffaee78d427949076799e9e6721c5
parseFrom
public static org.apache.avro.protobuf.noopt.Test.M parseFrom(byte[] data) throws com.google.protobuf.InvalidProtocolBufferException
{    return PARSER.parseFrom(data);}
bcdbde59f5f776726ec05f4ad49f59f9b07fd51a78159cbd31067db3512a27f7
parseFrom
public static org.apache.avro.protobuf.noopt.Test.M parseFrom(byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException
{    return PARSER.parseFrom(data, extensionRegistry);}
db28cd695061421880fbdcce3d951ab9f582a869b4494443ffdb5b3c668e32fa
parseFrom
public static org.apache.avro.protobuf.noopt.Test.M parseFrom(java.io.InputStream input) throws java.io.IOException
{    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);}
49bbbd122bd0bec6281ca88c096641a9b7b349d6d8371828913a3c2e02841eaa
parseFrom
public static org.apache.avro.protobuf.noopt.Test.M parseFrom(java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException
{    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input, extensionRegistry);}
ee09cf32df47c052f345a9ad102b32aec31f09be8a214b04321d5c469c67eeb1
parseDelimitedFrom
public static org.apache.avro.protobuf.noopt.Test.M parseDelimitedFrom(java.io.InputStream input) throws java.io.IOException
{    return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input);}
27d3a889b3099e096a816598f57dbe932024e7e9c3b6c50c172b941114d88eab
parseDelimitedFrom
public static org.apache.avro.protobuf.noopt.Test.M parseDelimitedFrom(java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException
{    return com.google.protobuf.GeneratedMessageV3.parseDelimitedWithIOException(PARSER, input, extensionRegistry);}
cdb7d75edb81e510fab7629f380145f7a331f6a44b89ec18cc6853354f260644
parseFrom
public static org.apache.avro.protobuf.noopt.Test.M parseFrom(com.google.protobuf.CodedInputStream input) throws java.io.IOException
{    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input);}
7e4bdcdb01d6223241664aad105bd954bd6437c32f5cc7fc8c7c504df58e4792
parseFrom
public static org.apache.avro.protobuf.noopt.Test.M parseFrom(com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException
{    return com.google.protobuf.GeneratedMessageV3.parseWithIOException(PARSER, input, extensionRegistry);}
a2589243249ba32b92e98298a2511019cd74b21c911d510f075da5ff7e8b6399
newBuilderForType
public Builder newBuilderForType()
{    return newBuilder();}
e32f866eb7533a232fadc4ef42bb022716435f415dc4a0f7ed4fff845f45ead0
newBuilder
public static Builder newBuilder()
{    return DEFAULT_INSTANCE.toBuilder();}
c9bee53e3d0f3e3a47db6738b24c2e033f671615210ea1a780c3fada23258d86
newBuilder
public static Builder newBuilder(org.apache.avro.protobuf.noopt.Test.M prototype)
{    return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);}
8f9c3ced03d87377003831ec6560ea40c4b718fc762fc1ca14b030b0ed8256d4
toBuilder
public Builder toBuilder()
{    return this == DEFAULT_INSTANCE ? new Builder() : new Builder().mergeFrom(this);}
4b6decb5ce35d0ce069dd647bca27ca9f81ed66925e1b833a3512177697f2d3b
newBuilderForType
protected Builder newBuilderForType(com.google.protobuf.GeneratedMessageV3.BuilderParent parent)
{    Builder builder = new Builder(parent);    return builder;}
e061a4269a7822f30b36dfe5c448257acd508bbe5bfe85e23841ca998b986e73
getDescriptor
public static final com.google.protobuf.Descriptors.Descriptor getDescriptor()
{    return org.apache.avro.protobuf.noopt.Test.internal_static_org_apache_avro_protobuf_noopt_M_descriptor;}
09b927b3931a0c25b6621043bbd0a8b48cb113bfa27184d786c8e36653bca4dd
internalGetFieldAccessorTable
protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable internalGetFieldAccessorTable()
{    return org.apache.avro.protobuf.noopt.Test.internal_static_org_apache_avro_protobuf_noopt_M_fieldAccessorTable.ensureFieldAccessorsInitialized(org.apache.avro.protobuf.noopt.Test.M.class, org.apache.avro.protobuf.noopt.Test.M.Builder.class);}
7c751d7a2accff7e718ee1e6ea5d2457fe6e182e8c39098e52a8848f56cf2cfe
maybeForceBuilderInitialization
private void maybeForceBuilderInitialization()
{    if (com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders) {    }}
7930c451f279d9927ff235e4ac064561e1505f9b7ae117d9f681b345534ff9e3
clear
public Builder clear()
{    super.clear();    return this;}
5a2efdcbff6cd8f893a197208cee010e41df6afb0e928da5d7126d953902ee30
getDescriptorForType
public com.google.protobuf.Descriptors.Descriptor getDescriptorForType()
{    return org.apache.avro.protobuf.noopt.Test.internal_static_org_apache_avro_protobuf_noopt_M_descriptor;}
f83a3ffbcb022844a98acda764e7ba79ebee4f6169c4acc9404e81abff5153be
getDefaultInstanceForType
public org.apache.avro.protobuf.noopt.Test.M getDefaultInstanceForType()
{    return org.apache.avro.protobuf.noopt.Test.M.getDefaultInstance();}
d09aff2eae5a8e22d6e5467c69877eaeadc5759bcaea918e44bca1c5dcf35921
build
public org.apache.avro.protobuf.noopt.Test.M build()
{    org.apache.avro.protobuf.noopt.Test.M result = buildPartial();    if (!result.isInitialized()) {        throw newUninitializedMessageException(result);    }    return result;}
786cd0c477eab0193fb3d465b1da5f9510236652af8fc9ade1b352248b62b36e
buildPartial
public org.apache.avro.protobuf.noopt.Test.M buildPartial()
{    org.apache.avro.protobuf.noopt.Test.M result = new org.apache.avro.protobuf.noopt.Test.M(this);    onBuilt();    return result;}
845fff95a97cf125489126ddee47248563aa80a59ed327d7d1c7cb9d90dcec30
clone
public Builder clone()
{    return (Builder) super.clone();}
e5d5cf46f7f9733e8968952c90ced36c482b5ce6c76f55f96b63b7864c44e8a9
setField
public Builder setField(com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value)
{    return (Builder) super.setField(field, value);}
7230780e7bd47d3ff1bfbd582401f62ac660c4cabdffea3399b812f0ca274023
clearField
public Builder clearField(com.google.protobuf.Descriptors.FieldDescriptor field)
{    return (Builder) super.clearField(field);}
eb613a9109dd1960f829dd2a97c885c2dcb2e9e5c7eb1830f545fa78ca5217bb
clearOneof
public Builder clearOneof(com.google.protobuf.Descriptors.OneofDescriptor oneof)
{    return (Builder) super.clearOneof(oneof);}
8b65fa0ba0250c27a1784d122c7e82f6a56893f4925b947cc87918e388ed11da
setRepeatedField
public Builder setRepeatedField(com.google.protobuf.Descriptors.FieldDescriptor field, int index, java.lang.Object value)
{    return (Builder) super.setRepeatedField(field, index, value);}
4c493ce9e20cef0f6973f189f8fcec07c11f7ec7a802fb3afe6f948f64f9ea0e
addRepeatedField
public Builder addRepeatedField(com.google.protobuf.Descriptors.FieldDescriptor field, java.lang.Object value)
{    return (Builder) super.addRepeatedField(field, value);}
9c02b14012758934fbc876f583b7201b524cfd4dce350a6fd2cdeea1bb86b6f9
mergeFrom
public Builder mergeFrom(com.google.protobuf.Message other)
{    if (other instanceof org.apache.avro.protobuf.noopt.Test.M) {        return mergeFrom((org.apache.avro.protobuf.noopt.Test.M) other);    } else {        super.mergeFrom(other);        return this;    }}
6a2724324f2c068affcb463790a641d07bcd5648f3070cbab26feee1e9a325c0
mergeFrom
public Builder mergeFrom(org.apache.avro.protobuf.noopt.Test.M other)
{    if (other == org.apache.avro.protobuf.noopt.Test.M.getDefaultInstance())        return this;    this.mergeUnknownFields(other.unknownFields);    onChanged();    return this;}
dde7cd718eaa61cad29906454acf122daba6680a2db55e4787a359a08951b5e7
isInitialized
public final boolean isInitialized()
{    return true;}
576f0ac95d3431feb1ba705ec8f537aa5e5a58300021599ce7c111ed9b61d887
mergeFrom
public Builder mergeFrom(com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException
{    org.apache.avro.protobuf.noopt.Test.M parsedMessage = null;    try {        parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);    } catch (com.google.protobuf.InvalidProtocolBufferException e) {        parsedMessage = (org.apache.avro.protobuf.noopt.Test.M) e.getUnfinishedMessage();        throw e.unwrapIOException();    } finally {        if (parsedMessage != null) {            mergeFrom(parsedMessage);        }    }    return this;}
c3f82e9354e0de24294e8d24ddd4cc78edfdbc227b0b6784774ae4f90f8803a5
setUnknownFields
public final Builder setUnknownFields(final com.google.protobuf.UnknownFieldSet unknownFields)
{    return super.setUnknownFields(unknownFields);}
112ef20f9bae5594feab16e3416756e8f3a1b669246aa50338f4c67470eebe6a
mergeUnknownFields
public final Builder mergeUnknownFields(final com.google.protobuf.UnknownFieldSet unknownFields)
{    return super.mergeUnknownFields(unknownFields);}
f7395231f147fecea95cbcd750e74af56f71e63b585e7e38bfe48a32c8706c58
getDefaultInstance
public static org.apache.avro.protobuf.noopt.Test.M getDefaultInstance()
{    return DEFAULT_INSTANCE;}
74b175d23e817f668b41e939624c002679beaa5d2e0cfa4293bdfb2ccbdec4e4
parsePartialFrom
public M parsePartialFrom(com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException
{    return new M(input, extensionRegistry);}
f82a1ccc586d6d52baec0b1d7ab43e35ab4285a66bf4dde7d8c0039e2d455851
parser
public static com.google.protobuf.Parser<M> parser()
{    return PARSER;}
ceca005c582c6b2089a094243b24152b3f5e7a8e40effca65a0ff913203f0edc
getParserForType
public com.google.protobuf.Parser<M> getParserForType()
{    return PARSER;}
f83a3ffbcb022844a98acda764e7ba79ebee4f6169c4acc9404e81abff5153be
getDefaultInstanceForType
public org.apache.avro.protobuf.noopt.Test.M getDefaultInstanceForType()
{    return DEFAULT_INSTANCE;}
d89a873db80c2368d8f6325a1db7f8e1359f195eeddfadda2a0e8079d1cd56ae
getDescriptor
public static com.google.protobuf.Descriptors.FileDescriptor getDescriptor()
{    return descriptor;}
224c23efa88f76f75befbf7108a56fdc531065116f2bd0df86a70845fc339c65
assignDescriptors
public com.google.protobuf.ExtensionRegistry assignDescriptors(com.google.protobuf.Descriptors.FileDescriptor root)
{    descriptor = root;    return null;}
eae141e87d5167f641cc123fb29c8adc61d765c702f27972d5c68bc43e0600a8
testMessage
public void testMessage() throws Exception
{    System.out.println(ProtobufData.get().getSchema(Foo.class).toString(true));    Foo.Builder builder = Foo.newBuilder();    builder.setInt32(0);    builder.setInt64(2);    builder.setUint32(3);    builder.setUint64(4);    builder.setSint32(5);    builder.setSint64(6);    builder.setFixed32(7);    builder.setFixed64(8);    builder.setSfixed32(9);    builder.setSfixed64(10);    builder.setFloat(1.0F);    builder.setDouble(2.0);    builder.setBool(true);    builder.setString("foo");    builder.setBytes(ByteString.copyFromUtf8("bar"));    builder.setEnum(A.X);    builder.addIntArray(27);    builder.addSyms(A.Y);    Foo fooInner = builder.build();    Foo fooInArray = builder.build();    builder = Foo.newBuilder(fooInArray);    builder.addFooArray(fooInArray);    com.google.protobuf.Timestamp ts = com.google.protobuf.Timestamp.newBuilder().setSeconds(1L).setNanos(2).build();    builder.setTimestamp(ts);    builder = Foo.newBuilder(fooInner);    builder.setFoo(fooInner);    Foo foo = builder.build();    System.out.println(foo);    ByteArrayOutputStream bao = new ByteArrayOutputStream();    ProtobufDatumWriter<Foo> w = new ProtobufDatumWriter<>(Foo.class);    Encoder e = EncoderFactory.get().binaryEncoder(bao, null);    w.write(foo, e);    e.flush();    Object o = new ProtobufDatumReader<>(Foo.class).read(null, DecoderFactory.get().binaryDecoder(new ByteArrayInputStream(bao.toByteArray()), null));    assertEquals(foo, o);}
0a093586e4b543fd9c18e901c611b4332e505d68a5809aedc44d8e53e2444a43
testNestedEnum
public void testNestedEnum() throws Exception
{    Schema s = ProtobufData.get().getSchema(N.class);    assertEquals(N.class.getName(), SpecificData.get().getClass(s).getName());}
53f9dac7dce7a7b519e5283c7ddf64b11409214159b383b5d6cd0ee6eb772f90
testNestedClassNamespace
public void testNestedClassNamespace() throws Exception
{    Schema s = ProtobufData.get().getSchema(Foo.class);    assertEquals(org.apache.avro.protobuf.noopt.Test.class.getName(), s.getNamespace());}
2114d81e7f233560e3d53cc1137cbe0f3317b3eebbcd58a8225661436111fdb7
testClassNamespaceInMultipleFiles
public void testClassNamespaceInMultipleFiles() throws Exception
{    Schema fooSchema = ProtobufData.get().getSchema(org.apache.avro.protobuf.multiplefiles.Foo.class);    assertEquals(org.apache.avro.protobuf.multiplefiles.Foo.class.getPackage().getName(), fooSchema.getNamespace());    Schema nSchema = ProtobufData.get().getSchema(org.apache.avro.protobuf.multiplefiles.M.N.class);    assertEquals(org.apache.avro.protobuf.multiplefiles.M.class.getName(), nSchema.getNamespace());}
b55f2e6709896cbbcd344561c360b390c5d03895e7651ea856d6c35da8a9ca91
testGetNonRepeatedSchemaWithLogicalType
public void testGetNonRepeatedSchemaWithLogicalType() throws Exception
{    ProtoConversions.TimestampMillisConversion conversion = new ProtoConversions.TimestampMillisConversion();        ProtobufData instance1 = new ProtobufData();    Schema s1 = instance1.getSchema(com.google.protobuf.Timestamp.class);    assertNotEquals(conversion.getRecommendedSchema(), s1);        ProtobufData instance2 = new ProtobufData();    instance2.addLogicalTypeConversion(conversion);    Schema s2 = instance2.getSchema(com.google.protobuf.Timestamp.class);    assertEquals(conversion.getRecommendedSchema(), s2);}
9bd67a87eed70168f832099b3c979f50df99900ebb86244f8dab5e2ae909d4ba
createSchemas
public static void createSchemas()
{    TestProtoConversions.TIMESTAMP_MILLIS_SCHEMA = LogicalTypes.timestampMillis().addToSchema(Schema.create(Schema.Type.LONG));    TestProtoConversions.TIMESTAMP_MICROS_SCHEMA = LogicalTypes.timestampMicros().addToSchema(Schema.create(Schema.Type.LONG));}
be9c511344ef35e006bcdc18269d7d40d60db24d939caec0eced7c5e30f239fa
testTimestampMillisConversion
public void testTimestampMillisConversion() throws Exception
{    TimestampMillisConversion conversion = new TimestampMillisConversion();    Timestamp May_28_2015_21_46_53_221_ts = Timestamp.newBuilder().setSeconds(1432849613L).setNanos(221000000).build();    Timestamp Jan_2_1900_3_4_5_678_ts = Timestamp.newBuilder().setSeconds(-2208891355L).setNanos(678000000).build();    long instant = May_28_2015_21_46_53_221.getTimeInMillis();    Timestamp tsFromInstant = conversion.fromLong(instant, TIMESTAMP_MILLIS_SCHEMA, LogicalTypes.timestampMillis());    long roundTrip = conversion.toLong(tsFromInstant, TIMESTAMP_MILLIS_SCHEMA, LogicalTypes.timestampMillis());    Assert.assertEquals("Round-trip conversion should work", instant, roundTrip);    Assert.assertEquals("Known timestamp should be correct", May_28_2015_21_46_53_221_ts, conversion.fromLong(instant, TIMESTAMP_MILLIS_SCHEMA, LogicalTypes.timestampMillis()));    Assert.assertEquals("Known timestamp should be correct", instant, (long) conversion.toLong(May_28_2015_21_46_53_221_ts, TIMESTAMP_MILLIS_SCHEMA, LogicalTypes.timestampMillis()));    instant = Jan_2_1900_3_4_5_678.getTimeInMillis();    tsFromInstant = conversion.fromLong(instant, TIMESTAMP_MILLIS_SCHEMA, LogicalTypes.timestampMillis());    roundTrip = conversion.toLong(tsFromInstant, TIMESTAMP_MILLIS_SCHEMA, LogicalTypes.timestampMillis());    Assert.assertEquals("Round-trip conversion should work", instant, roundTrip);    Assert.assertEquals("Known timestamp should be correct", Jan_2_1900_3_4_5_678_ts, conversion.fromLong(instant, TIMESTAMP_MILLIS_SCHEMA, LogicalTypes.timestampMillis()));    Assert.assertEquals("Known timestamp should be correct", instant, (long) conversion.toLong(Jan_2_1900_3_4_5_678_ts, TIMESTAMP_MILLIS_SCHEMA, LogicalTypes.timestampMillis()));}
0492a7af1928c21a69111c162b78354124fe4abbe15aad816c56d6beb2d07d81
testTimestampMicrosConversion
public void testTimestampMicrosConversion()
{    TimestampMicrosConversion conversion = new TimestampMicrosConversion();    Timestamp May_28_2015_21_46_53_221_843_ts = Timestamp.newBuilder().setSeconds(1432849613L).setNanos(221843000).build();    Timestamp Jan_2_1900_3_4_5_678_901_ts = Timestamp.newBuilder().setSeconds(-2208891355L).setNanos(678901000).build();    long instant = May_28_2015_21_46_53_221.getTimeInMillis() * 1000 + 843;    Timestamp tsFromInstant = conversion.fromLong(instant, TIMESTAMP_MICROS_SCHEMA, LogicalTypes.timestampMicros());    long roundTrip = conversion.toLong(tsFromInstant, TIMESTAMP_MICROS_SCHEMA, LogicalTypes.timestampMicros());    Assert.assertEquals("Round-trip conversion should work", instant, roundTrip);    Assert.assertEquals("Known timestamp should be correct", May_28_2015_21_46_53_221_843_ts, conversion.fromLong(instant, TIMESTAMP_MICROS_SCHEMA, LogicalTypes.timestampMicros()));    Assert.assertEquals("Known timestamp should be correct", instant, (long) conversion.toLong(May_28_2015_21_46_53_221_843_ts, TIMESTAMP_MICROS_SCHEMA, LogicalTypes.timestampMicros()));    instant = Jan_2_1900_3_4_5_678.getTimeInMillis() * 1000 + 901;    tsFromInstant = conversion.fromLong(instant, TIMESTAMP_MICROS_SCHEMA, LogicalTypes.timestampMicros());    roundTrip = conversion.toLong(tsFromInstant, TIMESTAMP_MICROS_SCHEMA, LogicalTypes.timestampMicros());    Assert.assertEquals("Round-trip conversion should work", instant, roundTrip);    Assert.assertEquals("Known timestamp should be correct", Jan_2_1900_3_4_5_678_901_ts, conversion.fromLong(instant, TIMESTAMP_MICROS_SCHEMA, LogicalTypes.timestampMicros()));    Assert.assertEquals("Known timestamp should be correct", instant, (long) conversion.toLong(Jan_2_1900_3_4_5_678_901_ts, TIMESTAMP_MICROS_SCHEMA, LogicalTypes.timestampMicros()));}
4f3f6eb95cfc0c1fc8ca94b8984b584d6a3d3391a6a10677f8239ed9e897b242
testTimestampMillisConversionSecondsLowerLimit
public void testTimestampMillisConversionSecondsLowerLimit() throws Exception
{    TimestampMillisConversion conversion = new TimestampMillisConversion();    long exceeded = (ProtoConversions.SECONDS_LOWERLIMIT - 1) * 1000;    conversion.fromLong(exceeded, TIMESTAMP_MILLIS_SCHEMA, LogicalTypes.timestampMillis());}
a579b5843ce2ed9b1a10ee742fafd1875546fe3a6b0e081d8d1f3d1a5c2cb57d
testTimestampMillisConversionSecondsUpperLimit
public void testTimestampMillisConversionSecondsUpperLimit() throws Exception
{    TimestampMillisConversion conversion = new TimestampMillisConversion();    long exceeded = (ProtoConversions.SECONDS_UPPERLIMIT + 1) * 1000;    conversion.fromLong(exceeded, TIMESTAMP_MILLIS_SCHEMA, LogicalTypes.timestampMillis());}
dd6b913c1e43909902cbd64f1f54174b029bebebfb446723e3abd509d10284dc
testTimestampMicrosConversionSecondsLowerLimit
public void testTimestampMicrosConversionSecondsLowerLimit() throws Exception
{    TimestampMicrosConversion conversion = new TimestampMicrosConversion();    long exceeded = (ProtoConversions.SECONDS_LOWERLIMIT - 1) * 1000000;    conversion.fromLong(exceeded, TIMESTAMP_MICROS_SCHEMA, LogicalTypes.timestampMicros());}
36b185cdedddabe0cfd6faeb22421597c0ffb5f687c8511fc44237ce9adaf687
testTimestampMicrosConversionSecondsUpperLimit
public void testTimestampMicrosConversionSecondsUpperLimit() throws Exception
{    TimestampMicrosConversion conversion = new TimestampMicrosConversion();    long exceeded = (ProtoConversions.SECONDS_UPPERLIMIT + 1) * 1000000;    conversion.fromLong(exceeded, TIMESTAMP_MICROS_SCHEMA, LogicalTypes.timestampMicros());}
f4f3d8a8a313ab5627835341529679aba3137ed54175a1707d99f5886abcc53b
testDynamicSchemaWithDateTimeConversion
public void testDynamicSchemaWithDateTimeConversion() throws ClassNotFoundException
{    Schema schema = getReflectedSchemaByName("com.google.protobuf.Timestamp", new TimestampMillisConversion());    Assert.assertEquals("Reflected schema should be logicalType timestampMillis", TIMESTAMP_MILLIS_SCHEMA, schema);}
125091aa5c5efa0c1f40c447112e582ecf791e8349bd2bdd155525fc3fc6d5e6
testDynamicSchemaWithDateTimeMicrosConversion
public void testDynamicSchemaWithDateTimeMicrosConversion() throws ClassNotFoundException
{    Schema schema = getReflectedSchemaByName("com.google.protobuf.Timestamp", new TimestampMicrosConversion());    Assert.assertEquals("Reflected schema should be logicalType timestampMicros", TIMESTAMP_MICROS_SCHEMA, schema);}
ec3c7532b17505db41141225db05fffaa4720e34850d377be154f485c84d6993
getReflectedSchemaByName
private Schema getReflectedSchemaByName(String className, Conversion<?> conversion) throws ClassNotFoundException
{        Class<?> cls = Class.forName(className);        ReflectData model = new ReflectData();    model.addLogicalTypeConversion(conversion);    return model.getSchema(cls);}
4dc737bafd8df1ab8ca9d2db9ad51ee763809ee37a319c63ad3eb2270c2c4cea
get
public static ThriftData get()
{    return INSTANCE;}
7303aaf9e45ab4c8c624b0e6a5d7b5941d362a96397a811d275ccc7e47c2ece3
createDatumReader
public DatumReader createDatumReader(Schema schema)
{    return new ThriftDatumReader(schema, schema, this);}
3d2aa170a9dc9e88ce5dff8d9760bdd18b4ddcbfb1066b36a9661ff0df2e90fb
createDatumWriter
public DatumWriter createDatumWriter(Schema schema)
{    return new ThriftDatumWriter(schema, this);}
181fb7fd53cc01f4df6d5af8ddff368f62dbd3d1cfa7eadcb278d4bae9487ee8
setField
public void setField(Object r, String n, int pos, Object o)
{    setField(r, n, pos, o, getRecordState(r, getSchema(r.getClass())));}
4d76eaea35da71be42b1f31f4e3bc1e419984813236d6955180a85b42fd52df0
getField
public Object getField(Object r, String name, int pos)
{    return getField(r, name, pos, getRecordState(r, getSchema(r.getClass())));}
2b021d6226b9050f7562f050c1d8271b2cba24f1ed019f41fd95e79356ec15eb
setField
protected void setField(Object r, String n, int pos, Object v, Object state)
{    if (v == null && r instanceof TUnion)        return;    ((TBase) r).setFieldValue(((TFieldIdEnum[]) state)[pos], v);}
61e87990300aa265dffc2843e9002d5e5aea256de7f2e53dec5ca66ff32170a1
getField
protected Object getField(Object record, String name, int pos, Object state)
{    TFieldIdEnum f = ((TFieldIdEnum[]) state)[pos];    TBase struct = (TBase) record;    if (struct.isSet(f))        return struct.getFieldValue(f);    return null;}
f8e24ffcdecbf98caab9d974a7bf9299c3d720b3712124716a6779e37440afec
getRecordState
protected Object getRecordState(Object r, Schema s)
{    TFieldIdEnum[] fields = fieldCache.get(s);    if (fields == null) {                fields = new TFieldIdEnum[s.getFields().size()];        Class c = r.getClass();        for (TFieldIdEnum f : FieldMetaData.getStructMetaDataMap((Class<? extends TBase>) c).keySet()) fields[s.getField(f.getFieldName()).pos()] = f;                fieldCache.put(s, fields);    }    return fields;}
cdd96ec067b8dcb31118b105538f4c0303b1e6ac47ba1af2c8403a287d499a28
getSchemaName
protected String getSchemaName(Object datum)
{        if (datum instanceof Short)        return Schema.Type.INT.getName();        if (datum instanceof Byte)        return Schema.Type.INT.getName();    return super.getSchemaName(datum);}
1b134742de945abb4e613bd1016bdba9127aba26e8e578964be50af2bb864d19
isRecord
protected boolean isRecord(Object datum)
{    return datum instanceof TBase;}
2c6b4c3e5e1b5ae8caf706d48722ac1779ce6fdfd9deb370b38ef7d438742cb4
isEnum
protected boolean isEnum(Object datum)
{    return datum instanceof TEnum;}
efe31e9c514d611d8e133686ecb5d76ca6af03aed27c9a00582fe16e460a135b
getEnumSchema
protected Schema getEnumSchema(Object datum)
{    return getSchema(datum.getClass());}
c19f2258b56e6bb84785b44422325e6dd35d0cd9e9b7c47a7b0e85b56e643c83
isBytes
protected boolean isBytes(Object datum)
{    if (datum instanceof ByteBuffer)        return true;    if (datum == null)        return false;    Class c = datum.getClass();    return c.isArray() && c.getComponentType() == Byte.TYPE;}
29054906d4af7be8dc8790cace3ee77ee70e4d288fe6c3430ecd85a8301c0864
newRecord
public Object newRecord(Object old, Schema schema)
{    try {        Class c = ClassUtils.forName(SpecificData.getClassName(schema));        if (c == null)                        return newRecord(old, schema);        if (c.isInstance(old))                        return old;                return c.newInstance();    } catch (Exception e) {        throw new RuntimeException(e);    }}
e0ccc1e06ae00a2a60c371353533514f62b4e4bb097a1e40a212a8240b20fe10
getRecordSchema
protected Schema getRecordSchema(Object record)
{    return getSchema(record.getClass());}
9cace38460f2091e09c386fb4b7596a75ef198f9b283e60e3b0760d3937c3333
getSchema
public Schema getSchema(Class c)
{    Schema schema = schemaCache.get(c);    if (schema == null) {                try {            if (TEnum.class.isAssignableFrom(c)) {                                List<String> symbols = new ArrayList<>();                for (Enum e : ((Class<? extends Enum>) c).getEnumConstants()) symbols.add(e.name());                schema = Schema.createEnum(c.getName(), null, null, symbols);            } else if (TBase.class.isAssignableFrom(c)) {                                schema = Schema.createRecord(c.getName(), null, null, Throwable.class.isAssignableFrom(c));                List<Field> fields = new ArrayList<>();                for (FieldMetaData f : FieldMetaData.getStructMetaDataMap((Class<? extends TBase>) c).values()) {                    Schema s = getSchema(f.valueMetaData);                    if (f.requirementType == TFieldRequirementType.OPTIONAL && (s.getType() != Schema.Type.UNION))                        s = nullable(s);                    fields.add(new Field(f.fieldName, s, null, null));                }                schema.setFields(fields);            } else {                throw new RuntimeException("Not a Thrift-generated class: " + c);            }        } catch (Exception e) {            throw new RuntimeException(e);        }                schemaCache.put(c, schema);    }    return schema;}
f112cfd2eddeedf213cfa2a9df5401247ab43631255384d5ca18b19b80ad6876
getSchema
private Schema getSchema(FieldValueMetaData f)
{    switch(f.type) {        case TType.BOOL:            return Schema.create(Schema.Type.BOOLEAN);        case TType.BYTE:            Schema b = Schema.create(Schema.Type.INT);            b.addProp(THRIFT_PROP, "byte");            return b;        case TType.I16:            Schema s = Schema.create(Schema.Type.INT);            s.addProp(THRIFT_PROP, "short");            return s;        case TType.I32:            return Schema.create(Schema.Type.INT);        case TType.I64:            return Schema.create(Schema.Type.LONG);        case TType.DOUBLE:            return Schema.create(Schema.Type.DOUBLE);        case TType.ENUM:            EnumMetaData enumMeta = (EnumMetaData) f;            return nullable(getSchema(enumMeta.enumClass));        case TType.LIST:            ListMetaData listMeta = (ListMetaData) f;            return nullable(Schema.createArray(getSchema(listMeta.elemMetaData)));        case TType.MAP:            MapMetaData mapMeta = (MapMetaData) f;            if (mapMeta.keyMetaData.type != TType.STRING)                throw new AvroRuntimeException("Map keys must be strings: " + f);            Schema map = Schema.createMap(getSchema(mapMeta.valueMetaData));            GenericData.setStringType(map, GenericData.StringType.String);            return nullable(map);        case TType.SET:            SetMetaData setMeta = (SetMetaData) f;            Schema set = Schema.createArray(getSchema(setMeta.elemMetaData));            set.addProp(THRIFT_PROP, "set");            return nullable(set);        case TType.STRING:            if (f.isBinary())                return nullable(Schema.create(Schema.Type.BYTES));            Schema string = Schema.create(Schema.Type.STRING);            GenericData.setStringType(string, GenericData.StringType.String);            return nullable(string);        case TType.STRUCT:            StructMetaData structMeta = (StructMetaData) f;            Schema record = getSchema(structMeta.structClass);            return nullable(record);        case TType.VOID:            return NULL;        default:            throw new RuntimeException("Unexpected type in field: " + f);    }}
28cbab1d20fae897a1eafe33e9f833a0dc709103db3dcfd17400c778e244eda0
nullable
private Schema nullable(Schema schema)
{    return Schema.createUnion(Arrays.asList(NULL, schema));}
ba3551741c67b001580a4f329a6837cd872aeca67c8d5f82b3324af5f30f4676
createEnum
protected Object createEnum(String symbol, Schema schema)
{    try {        Class c = ClassUtils.forName(SpecificData.getClassName(schema));        if (c == null)                        return super.createEnum(symbol, schema);        return Enum.valueOf(c, symbol);    } catch (Exception e) {        throw new AvroRuntimeException(e);    }}
67b1c8a7ff11360f88bb92f0d5e2f6f26cccf0b1b230e10b6f00d1e0658c77b4
readInt
protected Object readInt(Object old, Schema s, Decoder in) throws IOException
{    String type = s.getProp(ThriftData.THRIFT_PROP);    int value = in.readInt();    if (type != null) {        if ("byte".equals(type))            return (byte) value;        if ("short".equals(type))            return (short) value;    }    return value;}
7b6478bb11455a8339c97fa72e2e0c6aceb763cfb0762f80b4dd1a5cab3a715e
newArray
protected Object newArray(Object old, int size, Schema schema)
{    if ("set".equals(schema.getProp(ThriftData.THRIFT_PROP))) {        if (old instanceof Set) {            ((Set) old).clear();            return old;        }        return new HashSet();    } else {        return super.newArray(old, size, schema);    }}
7e2854bd80d8b97a030073ac1adfa38a98546f188df05d53b4035e30b0129a18
writeBytes
protected void writeBytes(Object datum, Encoder out) throws IOException
{        out.writeBytes(ByteBuffer.wrap((byte[]) datum));}
7f820eeb69ca0b6ba212f7fa738d25f53ebc1bc5cfb29c2200e154ad62791a65
getValue
public int getValue()
{    return value;}
5ab8c45fc32b96e1ed4552ff2c176dbe843312004a3d4d8e0e51faa6063551b0
findByValue
public static E findByValue(int value)
{    switch(value) {        case 1:            return X;        case 2:            return Y;        case 3:            return Z;        default:            return null;    }}
92e9e6589c16b4fde1efd2a77a414bb3a621362cc64c5ef5a21381d0e5b55b5f
findByThriftId
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        case         1:            return MESSAGE;        default:            return null;    }}
950148827ecab1253536a12003b5b2c41c2778a566a9ed4cb2487de641d6bde4
findByThriftIdOrThrow
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
eb44b9fdf7e05046f232aa9f1f3bb9a0cf815a486270439682862994e0d2c224
findByName
public static _Fields findByName(String name)
{    return byName.get(name);}
7f8fa4ecb4119b59b8047c285ac8f8729a909f121d1d3386d19ebfc6c04ab5df
getThriftFieldId
public short getThriftFieldId()
{    return _thriftId;}
68f4afd0e3cff42097dd5b6508fea1f7952d6d93f52ded3c1deea7186fff780c
getFieldName
public String getFieldName()
{    return _fieldName;}
6e9c541516d87cb565ba051fa94880951983b9f59711e59b1fe89ac96ae638b5
deepCopy
public Error deepCopy()
{    return new Error(this);}
21ac40bb9a99614b6ac18fa4043acb6173fccff96066fdfab963dba597923aa8
clear
public void clear()
{    this.message = null;}
b46153cc21231cb60e014b6b3c49b437699575e4012681cb08026e5238c66751
getMessage
public String getMessage()
{    return this.message;}
2bcf6673d72f24a37567f86c2d21222c057668cc9dcc031caf2d074de4775d13
setMessage
public void setMessage(String message)
{    this.message = message;}
3739345b182f004d16ad6d5a5bb6ca50ad75e47590d0fa191466dbea38ca48ef
unsetMessage
public void unsetMessage()
{    this.message = null;}
2abbd2162bddea2dd5f08796a5e9338d1e6d989a27f4cb22d1124219455a02c0
isSetMessage
public boolean isSetMessage()
{    return this.message != null;}
44bb4defd7d0685f83cd4a2dc36e829813bcefd4ff54b4d18b6d8cdbb37b7d4d
setMessageIsSet
public void setMessageIsSet(boolean value)
{    if (!value) {        this.message = null;    }}
56898e9e8fffee777f79916bb0318d8a0a1794f171b373787ede8ccabb314f39
setFieldValue
public void setFieldValue(_Fields field, Object value)
{    switch(field) {        case MESSAGE:            if (value == null) {                unsetMessage();            } else {                setMessage((String) value);            }            break;    }}
464d81fc54c8c50a21a786b4dc4dd56822e73892271735c454cff15126bc2dfd
getFieldValue
public Object getFieldValue(_Fields field)
{    switch(field) {        case MESSAGE:            return getMessage();    }    throw new IllegalStateException();}
71ed64fc282e6b120c36448a4f95d0d8102f98c0455e5f84713743b2826d64c9
isSet
public boolean isSet(_Fields field)
{    if (field == null) {        throw new IllegalArgumentException();    }    switch(field) {        case MESSAGE:            return isSetMessage();    }    throw new IllegalStateException();}
6b3ab298cb5d88dbb2c510c786f53e377489a40e2716e63c26a3e1691765f6c5
equals
public boolean equals(Object that)
{    if (that == null)        return false;    if (that instanceof Error)        return this.equals((Error) that);    return false;}
a40b5aa426234d26ea58d43d89f8165dc1cbbdcae79d96dc35eee25b1da14e1c
equals
public boolean equals(Error that)
{    if (that == null)        return false;    boolean this_present_message = true && this.isSetMessage();    boolean that_present_message = true && that.isSetMessage();    if (this_present_message || that_present_message) {        if (!(this_present_message && that_present_message))            return false;        return this.message.equals(that.message);    }    return true;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return 0;}
d3998e3a8555941d18be30cd404267806e3ac9f7d39bbdf47d56052a3e23b328
compareTo
public int compareTo(Error other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    lastComparison = Boolean.compare(isSetMessage(), other.isSetMessage());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetMessage()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.message, other.message);        if (lastComparison != 0) {            return lastComparison;        }    }    return 0;}
8ce4cec748163fe422fba58a0ef1f5936a95d5ce0ec9e530aab7c5a59149b857
fieldForId
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
9c387dbc68e2929966a2f4d7377de396c1c24932dd7e709eba5cf9e1c90787af
read
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    schemes.get(iprot.getScheme()).getScheme().read(iprot, this);}
72f9005ef45238c38f6c8b9506f41c8599609ccde331e03c7044ee080e1472da
write
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    schemes.get(oprot.getScheme()).getScheme().write(oprot, this);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    StringBuilder sb = new StringBuilder("Error(");    boolean first = true;    sb.append("message:");    if (this.message == null) {        sb.append("null");    } else {        sb.append(this.message);    }    first = false;    sb.append(")");    return sb.toString();}
e9a9838299550df368382cb18b6693a9d80b274b5c7bc089afc33713eceefbe1
validate
public void validate() throws org.apache.thrift.TException
{}
784e52bd99c637d4fd80e90272ace2edbc622a5a5ac2a515ab45f6d177fc378a
writeObject
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
a2d949a3bc49af9f8b746197cee0585da9e196149570b4a376f3635b857a1744
readObject
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException
{    try {        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
a953bbb5e79132785a0fbe366b9830f3ad36dfb4204339562adc35c54c3219fe
getScheme
public ErrorStandardScheme getScheme()
{    return new ErrorStandardScheme();}
507a10620e8952e7188e8859f4bfe3388845800814e10a35e0f8e9b30a519808
read
public void read(org.apache.thrift.protocol.TProtocol iprot, Error struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            case             1:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.message = iprot.readString();                    struct.setMessageIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();    struct.validate();}
db20365d9a795866c105a00803b47b59e66bfad1bba0073899648b1cfc170da0
write
public void write(org.apache.thrift.protocol.TProtocol oprot, Error struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    if (struct.message != null) {        oprot.writeFieldBegin(MESSAGE_FIELD_DESC);        oprot.writeString(struct.message);        oprot.writeFieldEnd();    }    oprot.writeFieldStop();    oprot.writeStructEnd();}
540846823672d5825ccb42444c787ac7bc01aab54b177091260b19d18406ea75
getScheme
public ErrorTupleScheme getScheme()
{    return new ErrorTupleScheme();}
8e7e7616d38a2efd5c1d2208d3083beb065a0dcce9a2b691aa47993b00be4aa2
write
public void write(org.apache.thrift.protocol.TProtocol prot, Error struct) throws org.apache.thrift.TException
{    TTupleProtocol oprot = (TTupleProtocol) prot;    BitSet optionals = new BitSet();    if (struct.isSetMessage()) {        optionals.set(0);    }    oprot.writeBitSet(optionals, 1);    if (struct.isSetMessage()) {        oprot.writeString(struct.message);    }}
afe6ca5be199c7063cf3774a644b32a52d74e8fa6339d0ccc87180ecae5df1ee
read
public void read(org.apache.thrift.protocol.TProtocol prot, Error struct) throws org.apache.thrift.TException
{    TTupleProtocol iprot = (TTupleProtocol) prot;    BitSet incoming = iprot.readBitSet(1);    if (incoming.get(0)) {        struct.message = iprot.readString();        struct.setMessageIsSet(true);    }}
c51e5cb6ab84996a366ca4c36408fdbb38461fdcc74ad26ed70818820572aaea
getClient
public Client getClient(org.apache.thrift.protocol.TProtocol prot)
{    return new Client(prot);}
f9e94ad26495767f197f0f23bc1a6ce01f90f5c97eede94dcba020bf0dbb3a1f
getClient
public Client getClient(org.apache.thrift.protocol.TProtocol iprot, org.apache.thrift.protocol.TProtocol oprot)
{    return new Client(iprot, oprot);}
1321f67797605b788f435e28fdf1f274073cf13b3616686022b027d34cdb67cb
ping
public void ping() throws org.apache.thrift.TException
{    send_ping();    recv_ping();}
dbcb4b8b7a88c854d42baba1a178af0dedf912d12df194f9a82d89a6b985d98e
send_ping
public void send_ping() throws org.apache.thrift.TException
{    ping_args args = new ping_args();    sendBase("ping", args);}
71aa3caaa3b77556308261000ed9dcbc001d80624cf03e48a9bee28e22611387
recv_ping
public void recv_ping() throws org.apache.thrift.TException
{    ping_result result = new ping_result();    receiveBase(result, "ping");}
8d01d96b61368dda00759da9630202a3ac725688f2674e7031bb57d1868de15c
add
public int add(int num1, int num2) throws org.apache.thrift.TException
{    send_add(num1, num2);    return recv_add();}
3df7a420c5be4abd20b4249fdbaba9435f6664d6adacd4e3b2ea51b5bc59754b
send_add
public void send_add(int num1, int num2) throws org.apache.thrift.TException
{    add_args args = new add_args();    args.setNum1(num1);    args.setNum2(num2);    sendBase("add", args);}
733f5ec93e9a0122149bbc3e4ea8fe31369010abfc3d5cba2e9e51fbbc4cf9e7
recv_add
public int recv_add() throws org.apache.thrift.TException
{    add_result result = new add_result();    receiveBase(result, "add");    if (result.isSetSuccess()) {        return result.success;    }    throw new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.MISSING_RESULT, "add failed: unknown result");}
98282e485aea941550d5a7def4f03eff54bc2f84be6fdf804464bdee0fe40821
zip
public void zip() throws org.apache.thrift.TException
{    send_zip();}
97ba8a4688ff878d83261a56884f770db25cce0cf062ae0b976ff4e4eefed17e
send_zip
public void send_zip() throws org.apache.thrift.TException
{    zip_args args = new zip_args();    sendBase("zip", args);}
f3ce7d595d2009029c2fe49ca987d74d1a0cbb743047cd46460382cbee61e7ac
getAsyncClient
public AsyncClient getAsyncClient(org.apache.thrift.transport.TNonblockingTransport transport)
{    return new AsyncClient(protocolFactory, clientManager, transport);}
9a8066e761111cf1977b5fe1977c5d5001208a816abadb32f4c2884f8a2977f6
ping
public void ping(org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException
{    checkReady();    ping_call method_call = new ping_call(resultHandler, this, ___protocolFactory, ___transport);    this.___currentMethod = method_call;    ___manager.call(method_call);}
345dc223bb11c0c727744b96de56d5f0f1f3c374a491b829541ac5c66b1c1fe4
write_args
public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException
{    prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("ping", org.apache.thrift.protocol.TMessageType.CALL, 0));    ping_args args = new ping_args();    args.write(prot);    prot.writeMessageEnd();}
a332a08097563c0d25c10885f3ecb3b7ad549a1cd4caf41fb9374fc96927bb7b
getResult
public Object getResult() throws org.apache.thrift.TException
{    if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {        throw new IllegalStateException("Method call not finished!");    }    org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());    org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);    (new Client(prot)).recv_ping();    return null;}
1bdac21069b4b96c2238a89d55148a417da73a197fd6e7166c8e8fa7e1f8c54a
add
public void add(int num1, int num2, org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException
{    checkReady();    add_call method_call = new add_call(num1, num2, resultHandler, this, ___protocolFactory, ___transport);    this.___currentMethod = method_call;    ___manager.call(method_call);}
345dc223bb11c0c727744b96de56d5f0f1f3c374a491b829541ac5c66b1c1fe4
write_args
public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException
{    prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("add", org.apache.thrift.protocol.TMessageType.CALL, 0));    add_args args = new add_args();    args.setNum1(num1);    args.setNum2(num2);    args.write(prot);    prot.writeMessageEnd();}
a332a08097563c0d25c10885f3ecb3b7ad549a1cd4caf41fb9374fc96927bb7b
getResult
public Object getResult() throws org.apache.thrift.TException
{    if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {        throw new IllegalStateException("Method call not finished!");    }    org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());    org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);    return (new Client(prot)).recv_add();}
001f1a414c22f9b3b28c1ca9708de9afcc718a595ead1863c4c32682ff6b73d1
zip
public void zip(org.apache.thrift.async.AsyncMethodCallback resultHandler) throws org.apache.thrift.TException
{    checkReady();    zip_call method_call = new zip_call(resultHandler, this, ___protocolFactory, ___transport);    this.___currentMethod = method_call;    ___manager.call(method_call);}
345dc223bb11c0c727744b96de56d5f0f1f3c374a491b829541ac5c66b1c1fe4
write_args
public void write_args(org.apache.thrift.protocol.TProtocol prot) throws org.apache.thrift.TException
{    prot.writeMessageBegin(new org.apache.thrift.protocol.TMessage("zip", org.apache.thrift.protocol.TMessageType.CALL, 0));    zip_args args = new zip_args();    args.write(prot);    prot.writeMessageEnd();}
e45d15ff8cefff91228cf54a337160b0e2a7e5b1e32268c71171d85dc02ab0e3
getResult
public Object getResult()
{    if (getState() != org.apache.thrift.async.TAsyncMethodCall.State.RESPONSE_READ) {        throw new IllegalStateException("Method call not finished!");    }    org.apache.thrift.transport.TMemoryInputTransport memoryTransport = new org.apache.thrift.transport.TMemoryInputTransport(getFrameBuffer().array());    org.apache.thrift.protocol.TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);    return prot;}
738d78d4660b6e44339a7f3c7826f5d36a27f149eba243598f194475b7236304
getProcessMap
private static Map<String, org.apache.thrift.ProcessFunction<I, ? extends org.apache.thrift.TBase>> getProcessMap(Map<String, org.apache.thrift.ProcessFunction<I, ? extends org.apache.thrift.TBase>> processMap)
{    processMap.put("ping", new ping());    processMap.put("add", new add());    processMap.put("zip", new zip());    return processMap;}
6181fcf1cd92b34d86c8c7b0888e62b623be5c454c5ce73fe3ee2e0aafd64ae7
getEmptyArgsInstance
public ping_args getEmptyArgsInstance()
{    return new ping_args();}
bebf296c86daa8f23132c9bae180b870c6dd9b8ba06fba8cc6695c835567cc77
isOneway
protected boolean isOneway()
{    return false;}
153809ac54f93e6ec17bf0f5b17fb5f5348b03695840ba797d695ee0efad1748
getResult
public ping_result getResult(I iface, ping_args args) throws org.apache.thrift.TException
{    ping_result result = new ping_result();    iface.ping();    return result;}
015818a5b7ba4b301e9b74eeb4c6321f8cff6adb9f6f859fe14b24cdccc9ad38
getEmptyArgsInstance
public add_args getEmptyArgsInstance()
{    return new add_args();}
bebf296c86daa8f23132c9bae180b870c6dd9b8ba06fba8cc6695c835567cc77
isOneway
protected boolean isOneway()
{    return false;}
979005b6919a6d79bf565e45a12b4d39ee66a46367bc603d299b8a9486ebaa72
getResult
public add_result getResult(I iface, add_args args) throws org.apache.thrift.TException
{    add_result result = new add_result();    result.success = iface.add(args.num1, args.num2);    result.setSuccessIsSet(true);    return result;}
cdc4db8f983b47ca209908e7914dccb53d073a78ada26ab0195f9d20a1f0e8a2
getEmptyArgsInstance
public zip_args getEmptyArgsInstance()
{    return new zip_args();}
bebf296c86daa8f23132c9bae180b870c6dd9b8ba06fba8cc6695c835567cc77
isOneway
protected boolean isOneway()
{    return true;}
0669546e514558dbcbef6e0ee2196d6296efb7b6b31326a5bed8b940f159d567
getResult
public org.apache.thrift.TBase getResult(I iface, zip_args args) throws org.apache.thrift.TException
{    iface.zip();    return null;}
0409c31db10aa18694f957fa32b798fbeb64358a429f845b92d5de9db93dd0c4
getProcessMap
private static Map<String, org.apache.thrift.AsyncProcessFunction<I, ? extends org.apache.thrift.TBase, ?>> getProcessMap(Map<String, org.apache.thrift.AsyncProcessFunction<I, ? extends org.apache.thrift.TBase, ?>> processMap)
{    processMap.put("ping", new ping());    processMap.put("add", new add());    processMap.put("zip", new zip());    return processMap;}
6181fcf1cd92b34d86c8c7b0888e62b623be5c454c5ce73fe3ee2e0aafd64ae7
getEmptyArgsInstance
public ping_args getEmptyArgsInstance()
{    return new ping_args();}
88076e4fdbf9f6c1a1e24bcd58d13357e2cca43eda177e8d755dd362ce3cb1bc
getResultHandler
public AsyncMethodCallback<Void> getResultHandler(final AsyncFrameBuffer fb, final int seqid)
{    final org.apache.thrift.AsyncProcessFunction fcall = this;    return new AsyncMethodCallback<Void>() {        @Override        public void onComplete(Void o) {            ping_result result = new ping_result();            try {                fcall.sendResponse(fb, result, org.apache.thrift.protocol.TMessageType.REPLY, seqid);                return;            } catch (Exception e) {                LOGGER.error("Exception writing to internal frame buffer", e);            }            fb.close();        }        @Override        public void onError(Exception e) {            byte msgType = org.apache.thrift.protocol.TMessageType.REPLY;            org.apache.thrift.TBase msg;            ping_result result = new ping_result();            {                msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION;                msg = (org.apache.thrift.TBase) new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage());            }            try {                fcall.sendResponse(fb, msg, msgType, seqid);                return;            } catch (Exception ex) {                LOGGER.error("Exception writing to internal frame buffer", ex);            }            fb.close();        }    };}
cd5b8a19197cb3ccf1cd836a996592642fc7ac634c77d8dae64fa6b6d826d77c
onComplete
public void onComplete(Void o)
{    ping_result result = new ping_result();    try {        fcall.sendResponse(fb, result, org.apache.thrift.protocol.TMessageType.REPLY, seqid);        return;    } catch (Exception e) {        LOGGER.error("Exception writing to internal frame buffer", e);    }    fb.close();}
50d81b3017874db254d9688aef6f4422ecef15f2cd874858a2f0d6437f81587e
onError
public void onError(Exception e)
{    byte msgType = org.apache.thrift.protocol.TMessageType.REPLY;    org.apache.thrift.TBase msg;    ping_result result = new ping_result();    {        msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION;        msg = (org.apache.thrift.TBase) new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage());    }    try {        fcall.sendResponse(fb, msg, msgType, seqid);        return;    } catch (Exception ex) {        LOGGER.error("Exception writing to internal frame buffer", ex);    }    fb.close();}
bebf296c86daa8f23132c9bae180b870c6dd9b8ba06fba8cc6695c835567cc77
isOneway
protected boolean isOneway()
{    return false;}
c7091bbd5ed6a1c20a1040140b6e1992b741a0daf5b86177096f7b8f43600566
start
public void start(I iface, ping_args args, org.apache.thrift.async.AsyncMethodCallback<Void> resultHandler) throws TException
{    iface.ping(resultHandler);}
015818a5b7ba4b301e9b74eeb4c6321f8cff6adb9f6f859fe14b24cdccc9ad38
getEmptyArgsInstance
public add_args getEmptyArgsInstance()
{    return new add_args();}
19f3e0dd26439b355d284ca3e4bc87a39b156fa593c8cd717068c3dc7b2cdde7
getResultHandler
public AsyncMethodCallback<Integer> getResultHandler(final AsyncFrameBuffer fb, final int seqid)
{    final org.apache.thrift.AsyncProcessFunction fcall = this;    return new AsyncMethodCallback<Integer>() {        @Override        public void onComplete(Integer o) {            add_result result = new add_result();            result.success = o;            result.setSuccessIsSet(true);            try {                fcall.sendResponse(fb, result, org.apache.thrift.protocol.TMessageType.REPLY, seqid);                return;            } catch (Exception e) {                LOGGER.error("Exception writing to internal frame buffer", e);            }            fb.close();        }        @Override        public void onError(Exception e) {            byte msgType = org.apache.thrift.protocol.TMessageType.REPLY;            org.apache.thrift.TBase msg;            add_result result = new add_result();            {                msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION;                msg = (org.apache.thrift.TBase) new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage());            }            try {                fcall.sendResponse(fb, msg, msgType, seqid);                return;            } catch (Exception ex) {                LOGGER.error("Exception writing to internal frame buffer", ex);            }            fb.close();        }    };}
e3990511f6ffb74137074443ccb65336c5f5ae88c5d27da52e58d53060bde733
onComplete
public void onComplete(Integer o)
{    add_result result = new add_result();    result.success = o;    result.setSuccessIsSet(true);    try {        fcall.sendResponse(fb, result, org.apache.thrift.protocol.TMessageType.REPLY, seqid);        return;    } catch (Exception e) {        LOGGER.error("Exception writing to internal frame buffer", e);    }    fb.close();}
50d81b3017874db254d9688aef6f4422ecef15f2cd874858a2f0d6437f81587e
onError
public void onError(Exception e)
{    byte msgType = org.apache.thrift.protocol.TMessageType.REPLY;    org.apache.thrift.TBase msg;    add_result result = new add_result();    {        msgType = org.apache.thrift.protocol.TMessageType.EXCEPTION;        msg = (org.apache.thrift.TBase) new org.apache.thrift.TApplicationException(org.apache.thrift.TApplicationException.INTERNAL_ERROR, e.getMessage());    }    try {        fcall.sendResponse(fb, msg, msgType, seqid);        return;    } catch (Exception ex) {        LOGGER.error("Exception writing to internal frame buffer", ex);    }    fb.close();}
bebf296c86daa8f23132c9bae180b870c6dd9b8ba06fba8cc6695c835567cc77
isOneway
protected boolean isOneway()
{    return false;}
0204b27c43a63f52cd2facc6e559fb756616f3834f9f8e8def53864ad6f6eb41
start
public void start(I iface, add_args args, org.apache.thrift.async.AsyncMethodCallback<Integer> resultHandler) throws TException
{    iface.add(args.num1, args.num2, resultHandler);}
cdc4db8f983b47ca209908e7914dccb53d073a78ada26ab0195f9d20a1f0e8a2
getEmptyArgsInstance
public zip_args getEmptyArgsInstance()
{    return new zip_args();}
88076e4fdbf9f6c1a1e24bcd58d13357e2cca43eda177e8d755dd362ce3cb1bc
getResultHandler
public AsyncMethodCallback<Void> getResultHandler(final AsyncFrameBuffer fb, final int seqid)
{    final org.apache.thrift.AsyncProcessFunction fcall = this;    return new AsyncMethodCallback<Void>() {        @Override        public void onComplete(Void o) {        }        @Override        public void onError(Exception e) {        }    };}
cd5b8a19197cb3ccf1cd836a996592642fc7ac634c77d8dae64fa6b6d826d77c
onComplete
public void onComplete(Void o)
{}
50d81b3017874db254d9688aef6f4422ecef15f2cd874858a2f0d6437f81587e
onError
public void onError(Exception e)
{}
bebf296c86daa8f23132c9bae180b870c6dd9b8ba06fba8cc6695c835567cc77
isOneway
protected boolean isOneway()
{    return true;}
d0f49354000757697fe68c83b62b17f17c847b7c0278bc9c6c456fb673174875
start
public void start(I iface, zip_args args, org.apache.thrift.async.AsyncMethodCallback<Void> resultHandler) throws TException
{    iface.zip(resultHandler);}
92e9e6589c16b4fde1efd2a77a414bb3a621362cc64c5ef5a21381d0e5b55b5f
findByThriftId
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        default:            return null;    }}
950148827ecab1253536a12003b5b2c41c2778a566a9ed4cb2487de641d6bde4
findByThriftIdOrThrow
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
eb44b9fdf7e05046f232aa9f1f3bb9a0cf815a486270439682862994e0d2c224
findByName
public static _Fields findByName(String name)
{    return byName.get(name);}
7f8fa4ecb4119b59b8047c285ac8f8729a909f121d1d3386d19ebfc6c04ab5df
getThriftFieldId
public short getThriftFieldId()
{    return _thriftId;}
68f4afd0e3cff42097dd5b6508fea1f7952d6d93f52ded3c1deea7186fff780c
getFieldName
public String getFieldName()
{    return _fieldName;}
416c3b9f4add8e01c0ae599cd0467ee692970135eeb99e82272b9d485fd8c5f8
deepCopy
public ping_args deepCopy()
{    return new ping_args(this);}
21ac40bb9a99614b6ac18fa4043acb6173fccff96066fdfab963dba597923aa8
clear
public void clear()
{}
56898e9e8fffee777f79916bb0318d8a0a1794f171b373787ede8ccabb314f39
setFieldValue
public void setFieldValue(_Fields field, Object value)
{    switch(field) {    }}
464d81fc54c8c50a21a786b4dc4dd56822e73892271735c454cff15126bc2dfd
getFieldValue
public Object getFieldValue(_Fields field)
{    switch(field) {    }    throw new IllegalStateException();}
71ed64fc282e6b120c36448a4f95d0d8102f98c0455e5f84713743b2826d64c9
isSet
public boolean isSet(_Fields field)
{    if (field == null) {        throw new IllegalArgumentException();    }    switch(field) {    }    throw new IllegalStateException();}
6b3ab298cb5d88dbb2c510c786f53e377489a40e2716e63c26a3e1691765f6c5
equals
public boolean equals(Object that)
{    if (that == null)        return false;    if (that instanceof ping_args)        return this.equals((ping_args) that);    return false;}
619b05f12d46066b4daaf7d6ba178d427dcc7563d9cc1c2ae100330668abbbf0
equals
public boolean equals(ping_args that)
{    return that != null;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return 0;}
aefba68d92442f976218f152292fc520a2c7c6169a51b9fd1da74279433af040
compareTo
public int compareTo(ping_args other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    return 0;}
8ce4cec748163fe422fba58a0ef1f5936a95d5ce0ec9e530aab7c5a59149b857
fieldForId
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
9c387dbc68e2929966a2f4d7377de396c1c24932dd7e709eba5cf9e1c90787af
read
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    schemes.get(iprot.getScheme()).getScheme().read(iprot, this);}
72f9005ef45238c38f6c8b9506f41c8599609ccde331e03c7044ee080e1472da
write
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    schemes.get(oprot.getScheme()).getScheme().write(oprot, this);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    boolean first = true;    return "ping_args(" + ")";}
e9a9838299550df368382cb18b6693a9d80b274b5c7bc089afc33713eceefbe1
validate
public void validate() throws org.apache.thrift.TException
{}
784e52bd99c637d4fd80e90272ace2edbc622a5a5ac2a515ab45f6d177fc378a
writeObject
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
a2d949a3bc49af9f8b746197cee0585da9e196149570b4a376f3635b857a1744
readObject
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException
{    try {        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
d6cfa01c4bbc32cdb21364dd37c2a588a197c5ac8f2233b72c6db481020adf25
getScheme
public ping_argsStandardScheme getScheme()
{    return new ping_argsStandardScheme();}
c78f752baf0ad16be97e9c57ab2282588679b5fd3cb817bbc4d4ddaccbe662c4
read
public void read(org.apache.thrift.protocol.TProtocol iprot, ping_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();    struct.validate();}
ba94c3e2bac5626225e531e19fe1d18d81b230674073c1bc6cb359c6138eb5ef
write
public void write(org.apache.thrift.protocol.TProtocol oprot, ping_args struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    oprot.writeFieldStop();    oprot.writeStructEnd();}
306edcc86f205f14cc2c3cd20b7028cf45a5ebd4289a77a123b8de5f1eac34a9
getScheme
public ping_argsTupleScheme getScheme()
{    return new ping_argsTupleScheme();}
3798c570793dda3e84d9caec7b99ead55bc4fa4afdcd5517d24d58dec1bb52e0
write
public void write(org.apache.thrift.protocol.TProtocol prot, ping_args struct) throws org.apache.thrift.TException
{    TTupleProtocol oprot = (TTupleProtocol) prot;}
5955af8356e4b8803132d918f51e55b0d44b340d09776d29cd58dd49cdca63ab
read
public void read(org.apache.thrift.protocol.TProtocol prot, ping_args struct) throws org.apache.thrift.TException
{    TTupleProtocol iprot = (TTupleProtocol) prot;}
92e9e6589c16b4fde1efd2a77a414bb3a621362cc64c5ef5a21381d0e5b55b5f
findByThriftId
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        default:            return null;    }}
950148827ecab1253536a12003b5b2c41c2778a566a9ed4cb2487de641d6bde4
findByThriftIdOrThrow
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
eb44b9fdf7e05046f232aa9f1f3bb9a0cf815a486270439682862994e0d2c224
findByName
public static _Fields findByName(String name)
{    return byName.get(name);}
7f8fa4ecb4119b59b8047c285ac8f8729a909f121d1d3386d19ebfc6c04ab5df
getThriftFieldId
public short getThriftFieldId()
{    return _thriftId;}
68f4afd0e3cff42097dd5b6508fea1f7952d6d93f52ded3c1deea7186fff780c
getFieldName
public String getFieldName()
{    return _fieldName;}
26c0aac16c21eebd91175814b94125d837ac897209a2c3aa426b57ec492984bd
deepCopy
public ping_result deepCopy()
{    return new ping_result(this);}
21ac40bb9a99614b6ac18fa4043acb6173fccff96066fdfab963dba597923aa8
clear
public void clear()
{}
56898e9e8fffee777f79916bb0318d8a0a1794f171b373787ede8ccabb314f39
setFieldValue
public void setFieldValue(_Fields field, Object value)
{    switch(field) {    }}
464d81fc54c8c50a21a786b4dc4dd56822e73892271735c454cff15126bc2dfd
getFieldValue
public Object getFieldValue(_Fields field)
{    switch(field) {    }    throw new IllegalStateException();}
71ed64fc282e6b120c36448a4f95d0d8102f98c0455e5f84713743b2826d64c9
isSet
public boolean isSet(_Fields field)
{    if (field == null) {        throw new IllegalArgumentException();    }    switch(field) {    }    throw new IllegalStateException();}
6b3ab298cb5d88dbb2c510c786f53e377489a40e2716e63c26a3e1691765f6c5
equals
public boolean equals(Object that)
{    if (that == null)        return false;    if (that instanceof ping_result)        return this.equals((ping_result) that);    return false;}
34393f607b39ede7ba66881c576bd066f4a41b83d98e02fbff817e4118c04877
equals
public boolean equals(ping_result that)
{    return that != null;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return 0;}
6b85611eba4f160777b88eee6f48b12a879fd505dfed702c0494c96276b55d15
compareTo
public int compareTo(ping_result other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    return 0;}
8ce4cec748163fe422fba58a0ef1f5936a95d5ce0ec9e530aab7c5a59149b857
fieldForId
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
9c387dbc68e2929966a2f4d7377de396c1c24932dd7e709eba5cf9e1c90787af
read
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    schemes.get(iprot.getScheme()).getScheme().read(iprot, this);}
72f9005ef45238c38f6c8b9506f41c8599609ccde331e03c7044ee080e1472da
write
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    schemes.get(oprot.getScheme()).getScheme().write(oprot, this);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    boolean first = true;    return "ping_result(" + ")";}
e9a9838299550df368382cb18b6693a9d80b274b5c7bc089afc33713eceefbe1
validate
public void validate() throws org.apache.thrift.TException
{}
784e52bd99c637d4fd80e90272ace2edbc622a5a5ac2a515ab45f6d177fc378a
writeObject
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
a2d949a3bc49af9f8b746197cee0585da9e196149570b4a376f3635b857a1744
readObject
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException
{    try {        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
a2bbc34c2af292aee84e247c7675c367321c2e086f0f3160060818c2bb2222d6
getScheme
public ping_resultStandardScheme getScheme()
{    return new ping_resultStandardScheme();}
537157da8e4c5c171a71bd3dcd10b31fb9f742967b027d83e34aef2c2148e802
read
public void read(org.apache.thrift.protocol.TProtocol iprot, ping_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();    struct.validate();}
3d9add31f1e904fcaaad5c14f558b5e090e3f921d3f682bccbfe8a34b542744b
write
public void write(org.apache.thrift.protocol.TProtocol oprot, ping_result struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    oprot.writeFieldStop();    oprot.writeStructEnd();}
747d204fe89a3225c6bbecb10a7c65dc882066431b8ba7f83495430467a367a9
getScheme
public ping_resultTupleScheme getScheme()
{    return new ping_resultTupleScheme();}
12604a8cbaf06320c3ca3fa1a2b9662b212f37d1333fe49d9b956f977b2904bf
write
public void write(org.apache.thrift.protocol.TProtocol prot, ping_result struct) throws org.apache.thrift.TException
{    TTupleProtocol oprot = (TTupleProtocol) prot;}
551638ada34373fc747c72091b6436dbe33e4cf72b51cdf53833568d023d9270
read
public void read(org.apache.thrift.protocol.TProtocol prot, ping_result struct) throws org.apache.thrift.TException
{    TTupleProtocol iprot = (TTupleProtocol) prot;}
92e9e6589c16b4fde1efd2a77a414bb3a621362cc64c5ef5a21381d0e5b55b5f
findByThriftId
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        case         1:            return NUM1;        case         2:            return NUM2;        default:            return null;    }}
950148827ecab1253536a12003b5b2c41c2778a566a9ed4cb2487de641d6bde4
findByThriftIdOrThrow
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
eb44b9fdf7e05046f232aa9f1f3bb9a0cf815a486270439682862994e0d2c224
findByName
public static _Fields findByName(String name)
{    return byName.get(name);}
7f8fa4ecb4119b59b8047c285ac8f8729a909f121d1d3386d19ebfc6c04ab5df
getThriftFieldId
public short getThriftFieldId()
{    return _thriftId;}
68f4afd0e3cff42097dd5b6508fea1f7952d6d93f52ded3c1deea7186fff780c
getFieldName
public String getFieldName()
{    return _fieldName;}
7f82c8b25bb3d2842315773f47d0f6073dd7c763b938c0db217fa17e8b07b16e
deepCopy
public add_args deepCopy()
{    return new add_args(this);}
21ac40bb9a99614b6ac18fa4043acb6173fccff96066fdfab963dba597923aa8
clear
public void clear()
{    setNum1IsSet(false);    this.num1 = 0;    setNum2IsSet(false);    this.num2 = 0;}
c763fb1ce5048b1d7d20643eaef77858dd28d7fb8858ce2836955eac5cc0a795
getNum1
public int getNum1()
{    return this.num1;}
c386ede775128e85f6db3c23438d06472b447d650c78d71656126cf56302eb9b
setNum1
public void setNum1(int num1)
{    this.num1 = num1;    setNum1IsSet(true);}
60783b61e6176a55ebe7330d00c366217c719eec52d5126152e3e60a0d67ca6d
unsetNum1
public void unsetNum1()
{    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __NUM1_ISSET_ID);}
2d20b86c39f3b1f9e8c04a81340ff760e0e7a4d052e8a9238cd29cd0406aef9d
isSetNum1
public boolean isSetNum1()
{    return EncodingUtils.testBit(__isset_bitfield, __NUM1_ISSET_ID);}
29cad1fe4001a589fb11a7ed691ad6285609601b5eea17ad69583e5df875b309
setNum1IsSet
public void setNum1IsSet(boolean value)
{    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __NUM1_ISSET_ID, value);}
f3c223c8b10aa4b37b3ec8b9cbd63c1feab0a34637a0e28859ce0ec8aea3e930
getNum2
public int getNum2()
{    return this.num2;}
d8eed62b4a5b20fe275ee973276d866614d68d99c7216d3e1c7f024bcd878a0d
setNum2
public void setNum2(int num2)
{    this.num2 = num2;    setNum2IsSet(true);}
71187035d0dd82e763a245c4767f9b96cf8581bcf0b384154a08ab160988da80
unsetNum2
public void unsetNum2()
{    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __NUM2_ISSET_ID);}
48278215747b4762cc75925868de8ede23945a8b813c3f7679b87e90593759a8
isSetNum2
public boolean isSetNum2()
{    return EncodingUtils.testBit(__isset_bitfield, __NUM2_ISSET_ID);}
1a26f0e07f508943cae993ec0682453aac01412a855897fad021bdb852bc27a3
setNum2IsSet
public void setNum2IsSet(boolean value)
{    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __NUM2_ISSET_ID, value);}
56898e9e8fffee777f79916bb0318d8a0a1794f171b373787ede8ccabb314f39
setFieldValue
public void setFieldValue(_Fields field, Object value)
{    switch(field) {        case NUM1:            if (value == null) {                unsetNum1();            } else {                setNum1((Integer) value);            }            break;        case NUM2:            if (value == null) {                unsetNum2();            } else {                setNum2((Integer) value);            }            break;    }}
464d81fc54c8c50a21a786b4dc4dd56822e73892271735c454cff15126bc2dfd
getFieldValue
public Object getFieldValue(_Fields field)
{    switch(field) {        case NUM1:            return getNum1();        case NUM2:            return getNum2();    }    throw new IllegalStateException();}
71ed64fc282e6b120c36448a4f95d0d8102f98c0455e5f84713743b2826d64c9
isSet
public boolean isSet(_Fields field)
{    if (field == null) {        throw new IllegalArgumentException();    }    switch(field) {        case NUM1:            return isSetNum1();        case NUM2:            return isSetNum2();    }    throw new IllegalStateException();}
6b3ab298cb5d88dbb2c510c786f53e377489a40e2716e63c26a3e1691765f6c5
equals
public boolean equals(Object that)
{    if (that == null)        return false;    if (that instanceof add_args)        return this.equals((add_args) that);    return false;}
c3ad113f7f2b1558341ea773516a6021999566a0068d4423cb0c1338b6475461
equals
public boolean equals(add_args that)
{    if (that == null)        return false;    boolean this_present_num1 = true;    boolean that_present_num1 = true;    if (this_present_num1 || that_present_num1) {        if (!(this_present_num1 && that_present_num1))            return false;        if (this.num1 != that.num1)            return false;    }    boolean this_present_num2 = true;    boolean that_present_num2 = true;    if (this_present_num2 || that_present_num2) {        if (!(this_present_num2 && that_present_num2))            return false;        return this.num2 == that.num2;    }    return true;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return 0;}
2471bccf7ba505c70f810f8a3155e864a641435627b72ba9196cc7a28cffd67c
compareTo
public int compareTo(add_args other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    lastComparison = Boolean.compare(isSetNum1(), other.isSetNum1());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetNum1()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.num1, other.num1);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = Boolean.compare(isSetNum2(), other.isSetNum2());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetNum2()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.num2, other.num2);        if (lastComparison != 0) {            return lastComparison;        }    }    return 0;}
8ce4cec748163fe422fba58a0ef1f5936a95d5ce0ec9e530aab7c5a59149b857
fieldForId
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
9c387dbc68e2929966a2f4d7377de396c1c24932dd7e709eba5cf9e1c90787af
read
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    schemes.get(iprot.getScheme()).getScheme().read(iprot, this);}
72f9005ef45238c38f6c8b9506f41c8599609ccde331e03c7044ee080e1472da
write
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    schemes.get(oprot.getScheme()).getScheme().write(oprot, this);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    StringBuilder sb = new StringBuilder("add_args(");    boolean first = true;    sb.append("num1:");    sb.append(this.num1);    first = false;    if (!first)        sb.append(", ");    sb.append("num2:");    sb.append(this.num2);    first = false;    sb.append(")");    return sb.toString();}
e9a9838299550df368382cb18b6693a9d80b274b5c7bc089afc33713eceefbe1
validate
public void validate() throws org.apache.thrift.TException
{}
784e52bd99c637d4fd80e90272ace2edbc622a5a5ac2a515ab45f6d177fc378a
writeObject
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
a2d949a3bc49af9f8b746197cee0585da9e196149570b4a376f3635b857a1744
readObject
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException
{    try {                        __isset_bitfield = 0;        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
fc0d65007ac213716fe6414a88a03fa7d4edc528bbf19e15aae52554c5505766
getScheme
public add_argsStandardScheme getScheme()
{    return new add_argsStandardScheme();}
554cd424781a467c4c480f9c104ea2dba99ab8d6b991564f7d8371fe320e3414
read
public void read(org.apache.thrift.protocol.TProtocol iprot, add_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            case             1:                if (schemeField.type == org.apache.thrift.protocol.TType.I32) {                    struct.num1 = iprot.readI32();                    struct.setNum1IsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             2:                if (schemeField.type == org.apache.thrift.protocol.TType.I32) {                    struct.num2 = iprot.readI32();                    struct.setNum2IsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();    struct.validate();}
d8af3db47c7d5b8dbd51c482833e7537e2721df71e0311b6d5c1ace12437e824
write
public void write(org.apache.thrift.protocol.TProtocol oprot, add_args struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    oprot.writeFieldBegin(NUM1_FIELD_DESC);    oprot.writeI32(struct.num1);    oprot.writeFieldEnd();    oprot.writeFieldBegin(NUM2_FIELD_DESC);    oprot.writeI32(struct.num2);    oprot.writeFieldEnd();    oprot.writeFieldStop();    oprot.writeStructEnd();}
671c81441c74f7bfc47368000efaef7f47268d0f8c5b1192c7989a3a762d2962
getScheme
public add_argsTupleScheme getScheme()
{    return new add_argsTupleScheme();}
9237ad91fdccc3612d1a0ce2bb75359ef11e52d4b872f0477b1e2b75b0756e9f
write
public void write(org.apache.thrift.protocol.TProtocol prot, add_args struct) throws org.apache.thrift.TException
{    TTupleProtocol oprot = (TTupleProtocol) prot;    BitSet optionals = new BitSet();    if (struct.isSetNum1()) {        optionals.set(0);    }    if (struct.isSetNum2()) {        optionals.set(1);    }    oprot.writeBitSet(optionals, 2);    if (struct.isSetNum1()) {        oprot.writeI32(struct.num1);    }    if (struct.isSetNum2()) {        oprot.writeI32(struct.num2);    }}
0db3b08e5d8e5a07b75284d545ba2ab2e8564c81b5cb8b119184eaa6852c07fa
read
public void read(org.apache.thrift.protocol.TProtocol prot, add_args struct) throws org.apache.thrift.TException
{    TTupleProtocol iprot = (TTupleProtocol) prot;    BitSet incoming = iprot.readBitSet(2);    if (incoming.get(0)) {        struct.num1 = iprot.readI32();        struct.setNum1IsSet(true);    }    if (incoming.get(1)) {        struct.num2 = iprot.readI32();        struct.setNum2IsSet(true);    }}
92e9e6589c16b4fde1efd2a77a414bb3a621362cc64c5ef5a21381d0e5b55b5f
findByThriftId
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        case         0:            return SUCCESS;        default:            return null;    }}
950148827ecab1253536a12003b5b2c41c2778a566a9ed4cb2487de641d6bde4
findByThriftIdOrThrow
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
eb44b9fdf7e05046f232aa9f1f3bb9a0cf815a486270439682862994e0d2c224
findByName
public static _Fields findByName(String name)
{    return byName.get(name);}
7f8fa4ecb4119b59b8047c285ac8f8729a909f121d1d3386d19ebfc6c04ab5df
getThriftFieldId
public short getThriftFieldId()
{    return _thriftId;}
68f4afd0e3cff42097dd5b6508fea1f7952d6d93f52ded3c1deea7186fff780c
getFieldName
public String getFieldName()
{    return _fieldName;}
10e1176d5963652b0f27f61bdcc675f833529d990fd91c0e32a0e8ebc125da6f
deepCopy
public add_result deepCopy()
{    return new add_result(this);}
21ac40bb9a99614b6ac18fa4043acb6173fccff96066fdfab963dba597923aa8
clear
public void clear()
{    setSuccessIsSet(false);    this.success = 0;}
571c3a574648f8d58940993d32ed60917f527f06024c170af73ad4b8dace6dc4
getSuccess
public int getSuccess()
{    return this.success;}
1204f51acb82f23bc064eabeef92a729dc8b6e729fb114ecfee2548a76bd9ed6
setSuccess
public void setSuccess(int success)
{    this.success = success;    setSuccessIsSet(true);}
b11d50af86567118806a3c839311a4bbc691cc019f2b233dae1d90d66ba25d35
unsetSuccess
public void unsetSuccess()
{    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __SUCCESS_ISSET_ID);}
94737a429af3ca2ae08f628bc393ecee61310b6ae56ecb9e65d11a0d4edf2fb9
isSetSuccess
public boolean isSetSuccess()
{    return EncodingUtils.testBit(__isset_bitfield, __SUCCESS_ISSET_ID);}
ade9d0378b151827122f3a20ecdf75cbb0fad960c542ca429237092ddfa5078b
setSuccessIsSet
public void setSuccessIsSet(boolean value)
{    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __SUCCESS_ISSET_ID, value);}
56898e9e8fffee777f79916bb0318d8a0a1794f171b373787ede8ccabb314f39
setFieldValue
public void setFieldValue(_Fields field, Object value)
{    switch(field) {        case SUCCESS:            if (value == null) {                unsetSuccess();            } else {                setSuccess((Integer) value);            }            break;    }}
464d81fc54c8c50a21a786b4dc4dd56822e73892271735c454cff15126bc2dfd
getFieldValue
public Object getFieldValue(_Fields field)
{    switch(field) {        case SUCCESS:            return getSuccess();    }    throw new IllegalStateException();}
71ed64fc282e6b120c36448a4f95d0d8102f98c0455e5f84713743b2826d64c9
isSet
public boolean isSet(_Fields field)
{    if (field == null) {        throw new IllegalArgumentException();    }    switch(field) {        case SUCCESS:            return isSetSuccess();    }    throw new IllegalStateException();}
6b3ab298cb5d88dbb2c510c786f53e377489a40e2716e63c26a3e1691765f6c5
equals
public boolean equals(Object that)
{    if (that == null)        return false;    if (that instanceof add_result)        return this.equals((add_result) that);    return false;}
48a8272489aa43670f75464365395f96fe19f8e5658a13c87af605b6b6d288b5
equals
public boolean equals(add_result that)
{    if (that == null)        return false;    boolean this_present_success = true;    boolean that_present_success = true;    if (this_present_success || that_present_success) {        if (!(this_present_success && that_present_success))            return false;        return this.success == that.success;    }    return true;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return 0;}
d49c96fbaff0e7c01ee9174069e5e3b531c8cd03caa04b1961976b552d742994
compareTo
public int compareTo(add_result other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    lastComparison = Boolean.compare(isSetSuccess(), other.isSetSuccess());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetSuccess()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.success, other.success);        if (lastComparison != 0) {            return lastComparison;        }    }    return 0;}
8ce4cec748163fe422fba58a0ef1f5936a95d5ce0ec9e530aab7c5a59149b857
fieldForId
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
9c387dbc68e2929966a2f4d7377de396c1c24932dd7e709eba5cf9e1c90787af
read
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    schemes.get(iprot.getScheme()).getScheme().read(iprot, this);}
72f9005ef45238c38f6c8b9506f41c8599609ccde331e03c7044ee080e1472da
write
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    schemes.get(oprot.getScheme()).getScheme().write(oprot, this);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    StringBuilder sb = new StringBuilder("add_result(");    boolean first = true;    sb.append("success:");    sb.append(this.success);    first = false;    sb.append(")");    return sb.toString();}
e9a9838299550df368382cb18b6693a9d80b274b5c7bc089afc33713eceefbe1
validate
public void validate() throws org.apache.thrift.TException
{}
784e52bd99c637d4fd80e90272ace2edbc622a5a5ac2a515ab45f6d177fc378a
writeObject
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
a2d949a3bc49af9f8b746197cee0585da9e196149570b4a376f3635b857a1744
readObject
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException
{    try {                        __isset_bitfield = 0;        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
5de9f7b9f591eaa8d4be72e6cf4abe1baca684e37717a50a924dbf6a7df7e728
getScheme
public add_resultStandardScheme getScheme()
{    return new add_resultStandardScheme();}
96e6dd19da85eb9773d8ca27fc9308fbbb8ee8d38a0f13bf3f246e4cb7a04098
read
public void read(org.apache.thrift.protocol.TProtocol iprot, add_result struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            case             0:                if (schemeField.type == org.apache.thrift.protocol.TType.I32) {                    struct.success = iprot.readI32();                    struct.setSuccessIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();    struct.validate();}
e7d34739cb77dd9c73c6cb41402ceafe8a9cca5ab91998fad5043beb92cd142d
write
public void write(org.apache.thrift.protocol.TProtocol oprot, add_result struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    if (struct.isSetSuccess()) {        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);        oprot.writeI32(struct.success);        oprot.writeFieldEnd();    }    oprot.writeFieldStop();    oprot.writeStructEnd();}
191ee93ce4d21f4f511a3bb837166fedcefadca66beaebfb5d7ece0df9791579
getScheme
public add_resultTupleScheme getScheme()
{    return new add_resultTupleScheme();}
d8cc6327e339a7e8ae2fd5c126910503d400e3f46a134c7db40f9eca711687c9
write
public void write(org.apache.thrift.protocol.TProtocol prot, add_result struct) throws org.apache.thrift.TException
{    TTupleProtocol oprot = (TTupleProtocol) prot;    BitSet optionals = new BitSet();    if (struct.isSetSuccess()) {        optionals.set(0);    }    oprot.writeBitSet(optionals, 1);    if (struct.isSetSuccess()) {        oprot.writeI32(struct.success);    }}
6eea50c0684504c9a10f6baa06a9e68b080a7b7b8496d674ab96f0df810e61de
read
public void read(org.apache.thrift.protocol.TProtocol prot, add_result struct) throws org.apache.thrift.TException
{    TTupleProtocol iprot = (TTupleProtocol) prot;    BitSet incoming = iprot.readBitSet(1);    if (incoming.get(0)) {        struct.success = iprot.readI32();        struct.setSuccessIsSet(true);    }}
92e9e6589c16b4fde1efd2a77a414bb3a621362cc64c5ef5a21381d0e5b55b5f
findByThriftId
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        default:            return null;    }}
950148827ecab1253536a12003b5b2c41c2778a566a9ed4cb2487de641d6bde4
findByThriftIdOrThrow
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
eb44b9fdf7e05046f232aa9f1f3bb9a0cf815a486270439682862994e0d2c224
findByName
public static _Fields findByName(String name)
{    return byName.get(name);}
7f8fa4ecb4119b59b8047c285ac8f8729a909f121d1d3386d19ebfc6c04ab5df
getThriftFieldId
public short getThriftFieldId()
{    return _thriftId;}
68f4afd0e3cff42097dd5b6508fea1f7952d6d93f52ded3c1deea7186fff780c
getFieldName
public String getFieldName()
{    return _fieldName;}
576945e74341f44e3eef6e55636f6cacf5e8ee1d03e29f26632811157441f77c
deepCopy
public zip_args deepCopy()
{    return new zip_args(this);}
21ac40bb9a99614b6ac18fa4043acb6173fccff96066fdfab963dba597923aa8
clear
public void clear()
{}
56898e9e8fffee777f79916bb0318d8a0a1794f171b373787ede8ccabb314f39
setFieldValue
public void setFieldValue(_Fields field, Object value)
{    switch(field) {    }}
464d81fc54c8c50a21a786b4dc4dd56822e73892271735c454cff15126bc2dfd
getFieldValue
public Object getFieldValue(_Fields field)
{    switch(field) {    }    throw new IllegalStateException();}
71ed64fc282e6b120c36448a4f95d0d8102f98c0455e5f84713743b2826d64c9
isSet
public boolean isSet(_Fields field)
{    if (field == null) {        throw new IllegalArgumentException();    }    switch(field) {    }    throw new IllegalStateException();}
6b3ab298cb5d88dbb2c510c786f53e377489a40e2716e63c26a3e1691765f6c5
equals
public boolean equals(Object that)
{    if (that == null)        return false;    if (that instanceof zip_args)        return this.equals((zip_args) that);    return false;}
4b4ef8381d0b34cfee2934d9543110505c27fd15eefcf35b4e695a8070fde3c7
equals
public boolean equals(zip_args that)
{    return that != null;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return 0;}
dd7b48919c2d622165c7666408e39a36cd52247163a9c983702af898496667d9
compareTo
public int compareTo(zip_args other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    return 0;}
8ce4cec748163fe422fba58a0ef1f5936a95d5ce0ec9e530aab7c5a59149b857
fieldForId
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
9c387dbc68e2929966a2f4d7377de396c1c24932dd7e709eba5cf9e1c90787af
read
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    schemes.get(iprot.getScheme()).getScheme().read(iprot, this);}
72f9005ef45238c38f6c8b9506f41c8599609ccde331e03c7044ee080e1472da
write
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    schemes.get(oprot.getScheme()).getScheme().write(oprot, this);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    boolean first = true;    return "zip_args(" + ")";}
e9a9838299550df368382cb18b6693a9d80b274b5c7bc089afc33713eceefbe1
validate
public void validate() throws org.apache.thrift.TException
{}
784e52bd99c637d4fd80e90272ace2edbc622a5a5ac2a515ab45f6d177fc378a
writeObject
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
a2d949a3bc49af9f8b746197cee0585da9e196149570b4a376f3635b857a1744
readObject
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException
{    try {        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
7e83605cf145489bc957c5c135a617bad84b1b6bedb5600e8eaa183fe69cda9e
getScheme
public zip_argsStandardScheme getScheme()
{    return new zip_argsStandardScheme();}
abfaf5f3bb52ed7cb4128769774517d69beb1fffea942b1bebe8901d5b07e65b
read
public void read(org.apache.thrift.protocol.TProtocol iprot, zip_args struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();    struct.validate();}
49e4b42a0ca081f2e946fc74bfd29b14c678feb95e261d6a67796f2803872986
write
public void write(org.apache.thrift.protocol.TProtocol oprot, zip_args struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    oprot.writeFieldStop();    oprot.writeStructEnd();}
563064350919aa48e5b23386ad15875497fe362a29a7d0e6f829affe25fce665
getScheme
public zip_argsTupleScheme getScheme()
{    return new zip_argsTupleScheme();}
d2d3c3cd3050c4d663a2db62636fb0879732b3563c92347ea0760326a9e61bbb
write
public void write(org.apache.thrift.protocol.TProtocol prot, zip_args struct) throws org.apache.thrift.TException
{    TTupleProtocol oprot = (TTupleProtocol) prot;}
af29ab4e6a7a099b1b8911247cb42c9932eadbe5e0c5ce1423d0cba19bf3c4a3
read
public void read(org.apache.thrift.protocol.TProtocol prot, zip_args struct) throws org.apache.thrift.TException
{    TTupleProtocol iprot = (TTupleProtocol) prot;}
92e9e6589c16b4fde1efd2a77a414bb3a621362cc64c5ef5a21381d0e5b55b5f
findByThriftId
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        case         1:            return FOO;        case         2:            return BAR;        default:            return null;    }}
950148827ecab1253536a12003b5b2c41c2778a566a9ed4cb2487de641d6bde4
findByThriftIdOrThrow
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
eb44b9fdf7e05046f232aa9f1f3bb9a0cf815a486270439682862994e0d2c224
findByName
public static _Fields findByName(String name)
{    return byName.get(name);}
7f8fa4ecb4119b59b8047c285ac8f8729a909f121d1d3386d19ebfc6c04ab5df
getThriftFieldId
public short getThriftFieldId()
{    return _thriftId;}
68f4afd0e3cff42097dd5b6508fea1f7952d6d93f52ded3c1deea7186fff780c
getFieldName
public String getFieldName()
{    return _fieldName;}
85bb592413da88bd22b3b04d42a6a9d08e377b527c5b53e7250b2f4728ae1b25
deepCopy
public FooOrBar deepCopy()
{    return new FooOrBar(this);}
6df97da3160c77a19bbf1e34e76b4a280020ef714785b31287787eaef664e0d0
foo
public static FooOrBar foo(String value)
{    FooOrBar x = new FooOrBar();    x.setFoo(value);    return x;}
b4f1593387f08b650fcc96a1fd6919f954ccd8cac9e634cfa7ffc3ab62d418ac
bar
public static FooOrBar bar(String value)
{    FooOrBar x = new FooOrBar();    x.setBar(value);    return x;}
54c99ffd8efee4bf405fd70180d6112577b0e79a8bd8b9e4d42908df0bffb961
checkType
protected void checkType(_Fields setField, Object value) throws ClassCastException
{    switch(setField) {        case FOO:            if (value instanceof String) {                break;            }            throw new ClassCastException("Was expecting value of type String for field 'foo', but got " + value.getClass().getSimpleName());        case BAR:            if (value instanceof String) {                break;            }            throw new ClassCastException("Was expecting value of type String for field 'bar', but got " + value.getClass().getSimpleName());        default:            throw new IllegalArgumentException("Unknown field id " + setField);    }}
b6a4eb5ac7e8f83827eba4435e371a89b42ba71d6cfdd54c933a68c08f5647a7
standardSchemeReadValue
protected Object standardSchemeReadValue(org.apache.thrift.protocol.TProtocol iprot, org.apache.thrift.protocol.TField field) throws org.apache.thrift.TException
{    _Fields setField = _Fields.findByThriftId(field.id);    if (setField != null) {        switch(setField) {            case FOO:                if (field.type == FOO_FIELD_DESC.type) {                    String foo;                    foo = iprot.readString();                    return foo;                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);                    return null;                }            case BAR:                if (field.type == BAR_FIELD_DESC.type) {                    String bar;                    bar = iprot.readString();                    return bar;                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);                    return null;                }            default:                throw new IllegalStateException("setField wasn't null, but didn't match any of the case statements!");        }    } else {        org.apache.thrift.protocol.TProtocolUtil.skip(iprot, field.type);        return null;    }}
993d7016d4d1c7bf7d994dbd9c46e502d168c2c7254c1b70aae4d2aa2ab8fa92
standardSchemeWriteValue
protected void standardSchemeWriteValue(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    switch(setField_) {        case FOO:            String foo = (String) value_;            oprot.writeString(foo);            return;        case BAR:            String bar = (String) value_;            oprot.writeString(bar);            return;        default:            throw new IllegalStateException("Cannot write union with unknown field " + setField_);    }}
1d8444e60ff66b6332464a58de32fcef65bafbb8a850fc14c6ea141aeb8ffac5
tupleSchemeReadValue
protected Object tupleSchemeReadValue(org.apache.thrift.protocol.TProtocol iprot, short fieldID) throws org.apache.thrift.TException
{    _Fields setField = _Fields.findByThriftId(fieldID);    if (setField != null) {        switch(setField) {            case FOO:                String foo;                foo = iprot.readString();                return foo;            case BAR:                String bar;                bar = iprot.readString();                return bar;            default:                throw new IllegalStateException("setField wasn't null, but didn't match any of the case statements!");        }    } else {        throw new TProtocolException("Couldn't find a field with field id " + fieldID);    }}
8f30eaefd323509704e5b6a264b0dff575d85f77a939c3bf38411538ad4af781
tupleSchemeWriteValue
protected void tupleSchemeWriteValue(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    switch(setField_) {        case FOO:            String foo = (String) value_;            oprot.writeString(foo);            return;        case BAR:            String bar = (String) value_;            oprot.writeString(bar);            return;        default:            throw new IllegalStateException("Cannot write union with unknown field " + setField_);    }}
52bcfa24f9a397fb5c3cb907eaa84e91eeac5f6069ff45c5a127c647de46e68e
getFieldDesc
protected org.apache.thrift.protocol.TField getFieldDesc(_Fields setField)
{    switch(setField) {        case FOO:            return FOO_FIELD_DESC;        case BAR:            return BAR_FIELD_DESC;        default:            throw new IllegalArgumentException("Unknown field id " + setField);    }}
63295870c88391a0b09fd42b98c30bd84ca7daebc7b570fc2d57b180e31d0e8d
getStructDesc
protected org.apache.thrift.protocol.TStruct getStructDesc()
{    return STRUCT_DESC;}
0a60ca6d2a0ea0259bd69fcf8ec8a214bf0861440c16a5be4fa403f4c2f2682f
enumForId
protected _Fields enumForId(short id)
{    return _Fields.findByThriftIdOrThrow(id);}
8ce4cec748163fe422fba58a0ef1f5936a95d5ce0ec9e530aab7c5a59149b857
fieldForId
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
f38b850a46bafa1c1e92378050d7c88ea9330e49ff86ecfbb223e2dfea3e4b1e
getFoo
public String getFoo()
{    if (getSetField() == _Fields.FOO) {        return (String) getFieldValue();    } else {        throw new RuntimeException("Cannot get field 'foo' because union is currently set to " + getFieldDesc(getSetField()).name);    }}
22ed28c4fcd3f521f5e76f75eabc35ece45790648d42d23243335bdd2df753f0
setFoo
public void setFoo(String value)
{    if (value == null)        throw new NullPointerException();    setField_ = _Fields.FOO;    value_ = value;}
119edf826bd53c1cdf7cab82f097c8316b519aee0db688463bea3b2f8a030c46
getBar
public String getBar()
{    if (getSetField() == _Fields.BAR) {        return (String) getFieldValue();    } else {        throw new RuntimeException("Cannot get field 'bar' because union is currently set to " + getFieldDesc(getSetField()).name);    }}
616b9fe16630f3e290c281947d7f3aac3afee81d3cc2be929df272d975609df9
setBar
public void setBar(String value)
{    if (value == null)        throw new NullPointerException();    setField_ = _Fields.BAR;    value_ = value;}
eebdf83607a4525f69f5a1d8552c8e640b005f94da4a81cae94827dd41c14ac0
isSetFoo
public boolean isSetFoo()
{    return setField_ == _Fields.FOO;}
23574163ff5898acefe54dae144044bdf9ed0ee5c5fa5366287ab3d38aa61a85
isSetBar
public boolean isSetBar()
{    return setField_ == _Fields.BAR;}
74e378df448c6c3cd090d6daf881cfac8957dd555869ea4c13a46bdc6cdcf9a6
equals
public boolean equals(Object other)
{    if (other instanceof FooOrBar) {        return equals((FooOrBar) other);    } else {        return false;    }}
f2fd1af28d0fd381ae8c34397702b1411cab81189cbd8bea95bc43dccf4b4b08
equals
public boolean equals(FooOrBar other)
{    return other != null && getSetField() == other.getSetField() && getFieldValue().equals(other.getFieldValue());}
981ad1eecb012c58edf5be76b95f201bf173434d3e30d4c3cbb89bf8e2cf304f
compareTo
public int compareTo(FooOrBar other)
{    int lastComparison = org.apache.thrift.TBaseHelper.compareTo(getSetField(), other.getSetField());    if (lastComparison == 0) {        return org.apache.thrift.TBaseHelper.compareTo(getFieldValue(), other.getFieldValue());    }    return lastComparison;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return 0;}
784e52bd99c637d4fd80e90272ace2edbc622a5a5ac2a515ab45f6d177fc378a
writeObject
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
a2d949a3bc49af9f8b746197cee0585da9e196149570b4a376f3635b857a1744
readObject
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException
{    try {        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
92e9e6589c16b4fde1efd2a77a414bb3a621362cc64c5ef5a21381d0e5b55b5f
findByThriftId
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        case         1:            return X;        default:            return null;    }}
950148827ecab1253536a12003b5b2c41c2778a566a9ed4cb2487de641d6bde4
findByThriftIdOrThrow
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
eb44b9fdf7e05046f232aa9f1f3bb9a0cf815a486270439682862994e0d2c224
findByName
public static _Fields findByName(String name)
{    return byName.get(name);}
7f8fa4ecb4119b59b8047c285ac8f8729a909f121d1d3386d19ebfc6c04ab5df
getThriftFieldId
public short getThriftFieldId()
{    return _thriftId;}
68f4afd0e3cff42097dd5b6508fea1f7952d6d93f52ded3c1deea7186fff780c
getFieldName
public String getFieldName()
{    return _fieldName;}
9ff46e340969be1cb1c32b3a254269a84ea90bf0b6affd8d9a0274cc2054a8de
deepCopy
public Nested deepCopy()
{    return new Nested(this);}
21ac40bb9a99614b6ac18fa4043acb6173fccff96066fdfab963dba597923aa8
clear
public void clear()
{    setXIsSet(false);    this.x = 0;}
b82f546de57497ab3c3f444ea63cdc1d2ca339993b83368b8b32569234789be4
getX
public int getX()
{    return this.x;}
2738bdbefe5f74bbbf31d8bff4e01e36b9656d5fcd01d73b376e13111c26cfe5
setX
public void setX(int x)
{    this.x = x;    setXIsSet(true);}
6eb1995f90777e48ec435252cfa559e8349aa482e9d33ffe24e51d3a31991803
unsetX
public void unsetX()
{    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __X_ISSET_ID);}
c6f47edd3625fe9a37ae350a77ed0440fa0508f2d25a707d57e20322d6bde8e1
isSetX
public boolean isSetX()
{    return EncodingUtils.testBit(__isset_bitfield, __X_ISSET_ID);}
fd78a972aa1fde03bd14b9e407d1012cb05d2fb7ad919f7ab5d4a7ebc47ef46c
setXIsSet
public void setXIsSet(boolean value)
{    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __X_ISSET_ID, value);}
56898e9e8fffee777f79916bb0318d8a0a1794f171b373787ede8ccabb314f39
setFieldValue
public void setFieldValue(_Fields field, Object value)
{    switch(field) {        case X:            if (value == null) {                unsetX();            } else {                setX((Integer) value);            }            break;    }}
464d81fc54c8c50a21a786b4dc4dd56822e73892271735c454cff15126bc2dfd
getFieldValue
public Object getFieldValue(_Fields field)
{    switch(field) {        case X:            return getX();    }    throw new IllegalStateException();}
71ed64fc282e6b120c36448a4f95d0d8102f98c0455e5f84713743b2826d64c9
isSet
public boolean isSet(_Fields field)
{    if (field == null) {        throw new IllegalArgumentException();    }    switch(field) {        case X:            return isSetX();    }    throw new IllegalStateException();}
6b3ab298cb5d88dbb2c510c786f53e377489a40e2716e63c26a3e1691765f6c5
equals
public boolean equals(Object that)
{    if (that == null)        return false;    if (that instanceof Nested)        return this.equals((Nested) that);    return false;}
e3e4a7490bc0a947b4056c930a3ab7a57c85448f75b75dfa443536f4894bbfa9
equals
public boolean equals(Nested that)
{    if (that == null)        return false;    boolean this_present_x = true;    boolean that_present_x = true;    if (this_present_x || that_present_x) {        if (!(this_present_x && that_present_x))            return false;        return this.x == that.x;    }    return true;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return 0;}
50cca43956729e62fdf20543b1e56065aa1ef85abf89e40fedcd516b91b08d6a
compareTo
public int compareTo(Nested other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    lastComparison = Boolean.compare(isSetX(), other.isSetX());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetX()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.x, other.x);        if (lastComparison != 0) {            return lastComparison;        }    }    return 0;}
8ce4cec748163fe422fba58a0ef1f5936a95d5ce0ec9e530aab7c5a59149b857
fieldForId
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
9c387dbc68e2929966a2f4d7377de396c1c24932dd7e709eba5cf9e1c90787af
read
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    schemes.get(iprot.getScheme()).getScheme().read(iprot, this);}
72f9005ef45238c38f6c8b9506f41c8599609ccde331e03c7044ee080e1472da
write
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    schemes.get(oprot.getScheme()).getScheme().write(oprot, this);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    StringBuilder sb = new StringBuilder("Nested(");    boolean first = true;    sb.append("x:");    sb.append(this.x);    first = false;    sb.append(")");    return sb.toString();}
e9a9838299550df368382cb18b6693a9d80b274b5c7bc089afc33713eceefbe1
validate
public void validate() throws org.apache.thrift.TException
{}
784e52bd99c637d4fd80e90272ace2edbc622a5a5ac2a515ab45f6d177fc378a
writeObject
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
a2d949a3bc49af9f8b746197cee0585da9e196149570b4a376f3635b857a1744
readObject
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException
{    try {                        __isset_bitfield = 0;        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
1bf7efe2be491e8515f4d46f30fcc54cf33aecc0aa078327b5694ef991fe61d5
getScheme
public NestedStandardScheme getScheme()
{    return new NestedStandardScheme();}
fdf5080173a51b07572bc8b7d43344932f9de19a82646514eba9d2de98a7a53e
read
public void read(org.apache.thrift.protocol.TProtocol iprot, Nested struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            case             1:                if (schemeField.type == org.apache.thrift.protocol.TType.I32) {                    struct.x = iprot.readI32();                    struct.setXIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();    struct.validate();}
632512d3cacfd6778b77c5845ec1b04149e1683f6cdf19f41a044b505fc69420
write
public void write(org.apache.thrift.protocol.TProtocol oprot, Nested struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    oprot.writeFieldBegin(X_FIELD_DESC);    oprot.writeI32(struct.x);    oprot.writeFieldEnd();    oprot.writeFieldStop();    oprot.writeStructEnd();}
82867298ca2e603aea280d75ac4c8c669c77d5b1849aa5c3d5ad2808d3653a8b
getScheme
public NestedTupleScheme getScheme()
{    return new NestedTupleScheme();}
7bc60679632f8a33b9efcb4f414ea7f06b44b6a0bd17fe88e0158d08ebee7a00
write
public void write(org.apache.thrift.protocol.TProtocol prot, Nested struct) throws org.apache.thrift.TException
{    TTupleProtocol oprot = (TTupleProtocol) prot;    BitSet optionals = new BitSet();    if (struct.isSetX()) {        optionals.set(0);    }    oprot.writeBitSet(optionals, 1);    if (struct.isSetX()) {        oprot.writeI32(struct.x);    }}
f7ef64f6084a3eff294548c976f1268a4477441c337b6e60141be52800090a72
read
public void read(org.apache.thrift.protocol.TProtocol prot, Nested struct) throws org.apache.thrift.TException
{    TTupleProtocol iprot = (TTupleProtocol) prot;    BitSet incoming = iprot.readBitSet(1);    if (incoming.get(0)) {        struct.x = iprot.readI32();        struct.setXIsSet(true);    }}
92e9e6589c16b4fde1efd2a77a414bb3a621362cc64c5ef5a21381d0e5b55b5f
findByThriftId
public static _Fields findByThriftId(int fieldId)
{    switch(fieldId) {        case         1:            return BOOL_FIELD;        case         2:            return BYTE_FIELD;        case         16:            return BYTE_OPTIONAL_FIELD;        case         3:            return I16_FIELD;        case         15:            return I16_OPTIONAL_FIELD;        case         4:            return I32_FIELD;        case         5:            return I64_FIELD;        case         6:            return DOUBLE_FIELD;        case         7:            return STRING_FIELD;        case         8:            return BINARY_FIELD;        case         9:            return MAP_FIELD;        case         10:            return LIST_FIELD;        case         11:            return SET_FIELD;        case         12:            return ENUM_FIELD;        case         13:            return STRUCT_FIELD;        case         14:            return FOO_OR_BAR;        default:            return null;    }}
950148827ecab1253536a12003b5b2c41c2778a566a9ed4cb2487de641d6bde4
findByThriftIdOrThrow
public static _Fields findByThriftIdOrThrow(int fieldId)
{    _Fields fields = findByThriftId(fieldId);    if (fields == null)        throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");    return fields;}
eb44b9fdf7e05046f232aa9f1f3bb9a0cf815a486270439682862994e0d2c224
findByName
public static _Fields findByName(String name)
{    return byName.get(name);}
7f8fa4ecb4119b59b8047c285ac8f8729a909f121d1d3386d19ebfc6c04ab5df
getThriftFieldId
public short getThriftFieldId()
{    return _thriftId;}
68f4afd0e3cff42097dd5b6508fea1f7952d6d93f52ded3c1deea7186fff780c
getFieldName
public String getFieldName()
{    return _fieldName;}
f223b0858d2319476e03cacdf52a4e63499a013bd3be3b17c3f95f4647840912
deepCopy
public Test deepCopy()
{    return new Test(this);}
21ac40bb9a99614b6ac18fa4043acb6173fccff96066fdfab963dba597923aa8
clear
public void clear()
{    setBoolFieldIsSet(false);    this.boolField = false;    setByteFieldIsSet(false);    this.byteField = 0;    setByteOptionalFieldIsSet(false);    this.byteOptionalField = 0;    setI16FieldIsSet(false);    this.i16Field = 0;    setI16OptionalFieldIsSet(false);    this.i16OptionalField = 0;    setI32FieldIsSet(false);    this.i32Field = 0;    setI64FieldIsSet(false);    this.i64Field = 0;    setDoubleFieldIsSet(false);    this.doubleField = 0.0;    this.stringField = null;    this.binaryField = null;    this.mapField = null;    this.listField = null;    this.setField = null;    this.enumField = null;    this.structField = null;    this.fooOrBar = null;}
15ecbcde6bd22f0533004698418b657ac58a6eac69a7916d2bc2df4d9c7842d0
isBoolField
public boolean isBoolField()
{    return this.boolField;}
c3c8a539723414069f0f806e5770e6af00f203fba383369e331a1fe02a1d9e3c
setBoolField
public void setBoolField(boolean boolField)
{    this.boolField = boolField;    setBoolFieldIsSet(true);}
14fdbd61f9bf095d260d9f089c6657cbbab9e2be80f671a59af7ccfcb78e0635
unsetBoolField
public void unsetBoolField()
{    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __BOOLFIELD_ISSET_ID);}
cbf7b61d5fc988551cc66c1d2471aca6ebd4d0f96b93362507c87aec32231295
isSetBoolField
public boolean isSetBoolField()
{    return EncodingUtils.testBit(__isset_bitfield, __BOOLFIELD_ISSET_ID);}
60e2565261754b19ab10e6501bd9aff29007df47ee9e713672f3878500612b85
setBoolFieldIsSet
public void setBoolFieldIsSet(boolean value)
{    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __BOOLFIELD_ISSET_ID, value);}
c93fbe8743c4de5283f06e98674c40221ebdcd5c3d9e65b48fd5d8c1628d1b98
getByteField
public byte getByteField()
{    return this.byteField;}
74e097a0e60b6f67a98c0feb78988cd2441270a95a9cca0f39e29a17a080a2ae
setByteField
public void setByteField(byte byteField)
{    this.byteField = byteField;    setByteFieldIsSet(true);}
0716cf06b7d8f082ed62ea2a5a667ec0a705795598254189e05bd4a42d833050
unsetByteField
public void unsetByteField()
{    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __BYTEFIELD_ISSET_ID);}
96668db324ad3972f09174291d8415e069fa887e1fba7550dd2e14d9309042d0
isSetByteField
public boolean isSetByteField()
{    return EncodingUtils.testBit(__isset_bitfield, __BYTEFIELD_ISSET_ID);}
357caee3fad36b5c76dc2dd7239c877ed856175623a8729b34ae99892f49bb16
setByteFieldIsSet
public void setByteFieldIsSet(boolean value)
{    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __BYTEFIELD_ISSET_ID, value);}
fe6b9b53af66a980bf97644dcfed7c9c8c470ca903ef408162bf4ebe68a84bd8
getByteOptionalField
public byte getByteOptionalField()
{    return this.byteOptionalField;}
e82d48f57e36a0244e83347bf025fb35830035f5fe415b6d2877f933c52947f8
setByteOptionalField
public void setByteOptionalField(byte byteOptionalField)
{    this.byteOptionalField = byteOptionalField;    setByteOptionalFieldIsSet(true);}
1cb714dd3021d8bd2bfd663a74564d47042ae13cfc7174bee6a76fe25282ce43
unsetByteOptionalField
public void unsetByteOptionalField()
{    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __BYTEOPTIONALFIELD_ISSET_ID);}
805fa4e56924c6899d8f172fcafd844f00ac050c31ae27c526816b4faab8bea4
isSetByteOptionalField
public boolean isSetByteOptionalField()
{    return EncodingUtils.testBit(__isset_bitfield, __BYTEOPTIONALFIELD_ISSET_ID);}
78cc28113d9ed5994974166c22504e971d51f39042b6253da21731d559783e09
setByteOptionalFieldIsSet
public void setByteOptionalFieldIsSet(boolean value)
{    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __BYTEOPTIONALFIELD_ISSET_ID, value);}
54db7347f9659ac1acf42d0a9755bb3e8667fae43ad89aefd7c77f4379d67c0a
getI16Field
public short getI16Field()
{    return this.i16Field;}
88a64ec275a84cb86b7603541499b87e6777c7b5af607e8c051a8a28c487d9c8
setI16Field
public void setI16Field(short i16Field)
{    this.i16Field = i16Field;    setI16FieldIsSet(true);}
872dec70bb5c56533f62df19568ca428ba0c85f3672a94ee0e865479cb5a5db4
unsetI16Field
public void unsetI16Field()
{    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __I16FIELD_ISSET_ID);}
01024631695446229d499895afd78d6ac6e67bbf22f72a14c0e5da225fa801ba
isSetI16Field
public boolean isSetI16Field()
{    return EncodingUtils.testBit(__isset_bitfield, __I16FIELD_ISSET_ID);}
7fad34ae55d22e705b12d9dbf1709e372f8d8d15121d8b161f90e46291c4c3a4
setI16FieldIsSet
public void setI16FieldIsSet(boolean value)
{    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __I16FIELD_ISSET_ID, value);}
759dd867f3c83020868d39192960cd1359ca22b4a5dc9edc65e55fee389a80ae
getI16OptionalField
public short getI16OptionalField()
{    return this.i16OptionalField;}
d2142250326e44a9b1fefbeb4ac7b3ff8a13ae0129ca4b4c17a42a8a66a5f183
setI16OptionalField
public void setI16OptionalField(short i16OptionalField)
{    this.i16OptionalField = i16OptionalField;    setI16OptionalFieldIsSet(true);}
30dfe41c1114b0a06b4ed72fd3cdd5b127d55024015a79875789a45ef3b777b0
unsetI16OptionalField
public void unsetI16OptionalField()
{    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __I16OPTIONALFIELD_ISSET_ID);}
1c7d1f59423b0d33cf1859e91f5eb679f06df6ea102baec0c368d16846535abc
isSetI16OptionalField
public boolean isSetI16OptionalField()
{    return EncodingUtils.testBit(__isset_bitfield, __I16OPTIONALFIELD_ISSET_ID);}
e10e07ad5798290db8f9386479f9da0d3b9e846e8e7c2e3f75565563506e3323
setI16OptionalFieldIsSet
public void setI16OptionalFieldIsSet(boolean value)
{    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __I16OPTIONALFIELD_ISSET_ID, value);}
c9f067980c20fccb250088945462449c55a81091171a5b81771effc666520da2
getI32Field
public int getI32Field()
{    return this.i32Field;}
940dbb67a76af049db1a61a9c19988248c475e15c054232bd9b920164bd4afae
setI32Field
public void setI32Field(int i32Field)
{    this.i32Field = i32Field;    setI32FieldIsSet(true);}
56d4db7bafe940a5205746c10214e6b02cda5e0018b77d39b1ac9fed3051a205
unsetI32Field
public void unsetI32Field()
{    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __I32FIELD_ISSET_ID);}
7a4c24375233a53b35d7b9c1f9a4ec13c555d5f07ef097fc25b670b69b0b9037
isSetI32Field
public boolean isSetI32Field()
{    return EncodingUtils.testBit(__isset_bitfield, __I32FIELD_ISSET_ID);}
c9aa9be5e7c687ceaae07a2877b1929b3b9f8d0344b8797cb82d84ab9102a390
setI32FieldIsSet
public void setI32FieldIsSet(boolean value)
{    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __I32FIELD_ISSET_ID, value);}
49905be8a18c246e474392ad3819962b96148560d252994617c60f0c4fb51eff
getI64Field
public long getI64Field()
{    return this.i64Field;}
ee64d0f87edc357634fc3d981d05e939733547431829d310c78865a5e0557449
setI64Field
public void setI64Field(long i64Field)
{    this.i64Field = i64Field;    setI64FieldIsSet(true);}
ed59c5766db9322a7f824b73e218d9bbffc0a4a754abc42b62791b8ccb36909c
unsetI64Field
public void unsetI64Field()
{    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __I64FIELD_ISSET_ID);}
6434b7819a57d5d120a271d84d42b986eb5775bfa71d58c51d92a0a9b7bc4b71
isSetI64Field
public boolean isSetI64Field()
{    return EncodingUtils.testBit(__isset_bitfield, __I64FIELD_ISSET_ID);}
81d9fbfec61411c4f3115f229e18de023c24ab4d8d6a825120e49f4f26816e45
setI64FieldIsSet
public void setI64FieldIsSet(boolean value)
{    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __I64FIELD_ISSET_ID, value);}
76e0c6ac91024372d1688f2dac8862edcd575c7e5fd2ef7b16a467e66065818c
getDoubleField
public double getDoubleField()
{    return this.doubleField;}
e5774eb35207b44b431bf5aa89142682520642ef36436a26bc5d2de57f287f77
setDoubleField
public void setDoubleField(double doubleField)
{    this.doubleField = doubleField;    setDoubleFieldIsSet(true);}
1a3ec3ce98c7e24bafdea0f77ccc0e8c682895c100e3b7f6b4b60c5a1a2ce6ff
unsetDoubleField
public void unsetDoubleField()
{    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __DOUBLEFIELD_ISSET_ID);}
ebf258ea8618b1d66da8daf14002c50bb7134ab6217b64c6816ed89fb47b516a
isSetDoubleField
public boolean isSetDoubleField()
{    return EncodingUtils.testBit(__isset_bitfield, __DOUBLEFIELD_ISSET_ID);}
4c2cc0c3638775fb0f2bd7cc6867d1a1c09d48904c1ae2bc3a1c11500cb10e1e
setDoubleFieldIsSet
public void setDoubleFieldIsSet(boolean value)
{    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __DOUBLEFIELD_ISSET_ID, value);}
d19c117c7686cf27145f7e531914466c33cb3e8badc60c009b09f7f3e72990b6
getStringField
public String getStringField()
{    return this.stringField;}
fa03963c03b03a857287869d54f28a77b60b001eae1f71eaed6f05524dd8ca31
setStringField
public void setStringField(String stringField)
{    this.stringField = stringField;}
eb04d18dbb11bbe08f71bb53aa198e2fcbbcdb223e185a6d037d3b4509be6f79
unsetStringField
public void unsetStringField()
{    this.stringField = null;}
0fc21ffaaa84c580dfe615c8699997efd3aec4d839edca1ef1f0f665563c4112
isSetStringField
public boolean isSetStringField()
{    return this.stringField != null;}
f1d66eb00edb7e0174878aced2cd63de299498212d873fa09e2ba4b7c8d228be
setStringFieldIsSet
public void setStringFieldIsSet(boolean value)
{    if (!value) {        this.stringField = null;    }}
66e6ba194eb3df2e7fb58ef71cea6f212bee167cbda2fc0c05c720c0ce14092b
getBinaryField
public byte[] getBinaryField()
{    setBinaryField(org.apache.thrift.TBaseHelper.rightSize(binaryField));    return binaryField == null ? null : binaryField.array();}
866794cfca3dbf3426581706f73fee2ede64352a12a30e0b83f97fcd4b35e51f
bufferForBinaryField
public ByteBuffer bufferForBinaryField()
{    return binaryField;}
0a09a5ae27c6fa212e6cb7a1a6176af5a19e80e57b3151ebbe6f0bb4d6803627
setBinaryField
public void setBinaryField(byte[] binaryField)
{    setBinaryField(binaryField == null ? null : ByteBuffer.wrap(binaryField));}
e8af9b362e0d0445f546560e1e8028f0973403727f8129498ae7165c7c67bf6e
setBinaryField
public void setBinaryField(ByteBuffer binaryField)
{    this.binaryField = binaryField;}
d2aad2dd6e07c5f1bceed7880fe6077ec660cfc3132805f6e5e41b71ac5291f2
unsetBinaryField
public void unsetBinaryField()
{    this.binaryField = null;}
6c62c2964a4f4c8055427c0e47c8261914b12aa8fadb8af8b80584c647baf33b
isSetBinaryField
public boolean isSetBinaryField()
{    return this.binaryField != null;}
e612cbfad4e29234cc70ed2d05572b60e23560d92027f8c935860281a7c234db
setBinaryFieldIsSet
public void setBinaryFieldIsSet(boolean value)
{    if (!value) {        this.binaryField = null;    }}
480a69cd8e127dda0de9a9842de8654bb457d7a80fc24bfe1a1e1d1dce4ad89e
getMapFieldSize
public int getMapFieldSize()
{    return (this.mapField == null) ? 0 : this.mapField.size();}
b41b8eda1c2a1f894fe0ad9818cb87e670a531f12082b39b0095cdb38b78dd82
putToMapField
public void putToMapField(String key, int val)
{    if (this.mapField == null) {        this.mapField = new HashMap<>();    }    this.mapField.put(key, val);}
7e71a0ba35c623f49bccd15b15f918e90245d7f65bd13ad2a7f84f5221f074cc
getMapField
public Map<String, Integer> getMapField()
{    return this.mapField;}
3bb3acdaa20153441f67f3dd948bd49888358f9ba3415f356d29259f40f3d6de
setMapField
public void setMapField(Map<String, Integer> mapField)
{    this.mapField = mapField;}
0bf2db44c4aeb84d2dfe8cc9379a2c1ccd411b55409303d6da2c31f595e45031
unsetMapField
public void unsetMapField()
{    this.mapField = null;}
def7c33feb861a35a309d075edee62ad0225c1238c9c119b42e38f3c08110999
isSetMapField
public boolean isSetMapField()
{    return this.mapField != null;}
4ec3d07c7f520977744e60097730406cbe1457e0b7e16f0178804d37a067f3f5
setMapFieldIsSet
public void setMapFieldIsSet(boolean value)
{    if (!value) {        this.mapField = null;    }}
566a3bce434ec5ce452999ccb00e6d9d89049ba11ef69c46f03c1615a64d93d5
getListFieldSize
public int getListFieldSize()
{    return (this.listField == null) ? 0 : this.listField.size();}
b4e36bc6495c9016097563e60332c7c618bd517996c04c6a1173dc916e2ed0e2
getListFieldIterator
public java.util.Iterator<Integer> getListFieldIterator()
{    return (this.listField == null) ? null : this.listField.iterator();}
71b0c74fc669984498486c8557fb8d951e86e07426b3155a5a8bdcd0dc2422a8
addToListField
public void addToListField(int elem)
{    if (this.listField == null) {        this.listField = new ArrayList<>();    }    this.listField.add(elem);}
851404c59ee25aefe9f7569d37c004e8c303e0780e48817d84ccf1701a46becc
getListField
public List<Integer> getListField()
{    return this.listField;}
3170f9dd7f8b9f7a42e3198b409324eeec3187fd68f293e27c39b2b48e2f3bf9
setListField
public void setListField(List<Integer> listField)
{    this.listField = listField;}
380d3765367b4d31a5d0e7b3d0f5cee671827a2f01bbfa4e8cf677a5e9cba873
unsetListField
public void unsetListField()
{    this.listField = null;}
bfc4f6dc0a419ffc07c8635195423c37a6796bc9e133340128745a08a0430e70
isSetListField
public boolean isSetListField()
{    return this.listField != null;}
cc7fa7e61aea440ac4884f6c9aad2bce0ada6b6fcb58de9e7534d7922176c4f2
setListFieldIsSet
public void setListFieldIsSet(boolean value)
{    if (!value) {        this.listField = null;    }}
3c6445c5d09f7b4bc219b6ef7bf7379c6b09d260553240839600548902719202
getSetFieldSize
public int getSetFieldSize()
{    return (this.setField == null) ? 0 : this.setField.size();}
c3b5f30b50ece35220644a7f1b75076a2d66102f79914f3ed3406290934fb979
getSetFieldIterator
public java.util.Iterator<Integer> getSetFieldIterator()
{    return (this.setField == null) ? null : this.setField.iterator();}
30e862d43592bf916f476abf64267b8d3a8da508916eea0c6be34ba8560485c9
addToSetField
public void addToSetField(int elem)
{    if (this.setField == null) {        this.setField = new HashSet<>();    }    this.setField.add(elem);}
835b99e80c6db9fc6848190dc139861b94478494d3277de91dbc275f18bdda57
getSetField
public Set<Integer> getSetField()
{    return this.setField;}
724407314caefb276713d64c524c79e5af8baa0816deb9d83f75db78425a7e73
setSetField
public void setSetField(Set<Integer> setField)
{    this.setField = setField;}
3314904ef9cc44fc06df52b51a9d02aaac3f9dc9c7871fb91562dd1dca5106b6
unsetSetField
public void unsetSetField()
{    this.setField = null;}
bdb9d9118938af9d4011de15b334786b9b8c12c173488630afe755ca5eaf5564
isSetSetField
public boolean isSetSetField()
{    return this.setField != null;}
14f6fb42b7245e3d8d04d32217d9477120979d062ce2a5531e24c18f50f3ef01
setSetFieldIsSet
public void setSetFieldIsSet(boolean value)
{    if (!value) {        this.setField = null;    }}
5785d24ace19c7c29c006f0310660b65beaa964bbb8a3cc9b77cc1129747e1d2
getEnumField
public E getEnumField()
{    return this.enumField;}
4777f90d9b4abfabc4f8110dda557b0de8633ec558aa0b816f0ec70dd723b1c4
setEnumField
public void setEnumField(E enumField)
{    this.enumField = enumField;}
031f9cc975a7634d990ce5dacb7ec8ae0784fa832824088728f2276fc9abe97c
unsetEnumField
public void unsetEnumField()
{    this.enumField = null;}
deeec6ad909b4ff821ec91da79b749af031675acb997a57d60194ee57fde9e8c
isSetEnumField
public boolean isSetEnumField()
{    return this.enumField != null;}
4876107ebe671d60feac4285b8b51b3bf2a6eba4ec4b8c642166f6b2e86b9c4b
setEnumFieldIsSet
public void setEnumFieldIsSet(boolean value)
{    if (!value) {        this.enumField = null;    }}
960618e780de1553123290952f7574ecc18b1f8d7862d9ff407f75d2c056fe5d
getStructField
public Nested getStructField()
{    return this.structField;}
1fbc3cf8ffef653f62eebeeb807132a13971069860a358bad216a4b987ff9c14
setStructField
public void setStructField(Nested structField)
{    this.structField = structField;}
0c96680034b1e5abc93fc0c5e2cb9c2775346572c9a52cd8f9e37c5759d91d7c
unsetStructField
public void unsetStructField()
{    this.structField = null;}
260fe6d6c4ee5f238b2d1128279e5e70637bf1b4e4b512518fdf667e8e3678f4
isSetStructField
public boolean isSetStructField()
{    return this.structField != null;}
9302694fc83722c94c6d3b084d6b87aab6a91ee18ae32b6ef20b555184a5d420
setStructFieldIsSet
public void setStructFieldIsSet(boolean value)
{    if (!value) {        this.structField = null;    }}
6a3170c3f4a0bde5fa3c78252cc57ca96cecba19eaf7369a5813cc5cadff9c60
getFooOrBar
public FooOrBar getFooOrBar()
{    return this.fooOrBar;}
e121b9555731c0a4270cb2684d8f9d6a9d282441cd467658cda27cc8392ef850
setFooOrBar
public void setFooOrBar(FooOrBar fooOrBar)
{    this.fooOrBar = fooOrBar;}
33f1322a8aa63ce97bb2d831f6a64131872f31877ba289837120f29a04d7873c
unsetFooOrBar
public void unsetFooOrBar()
{    this.fooOrBar = null;}
a115f9ee17b65218cf32a983ad5a5582997798ab32b019667910f5c49775a958
isSetFooOrBar
public boolean isSetFooOrBar()
{    return this.fooOrBar != null;}
7e4f75a3c5e7ab3b9cc3ad71144da35f975947919d59af4e36edbbe147995909
setFooOrBarIsSet
public void setFooOrBarIsSet(boolean value)
{    if (!value) {        this.fooOrBar = null;    }}
56898e9e8fffee777f79916bb0318d8a0a1794f171b373787ede8ccabb314f39
setFieldValue
public void setFieldValue(_Fields field, Object value)
{    switch(field) {        case BOOL_FIELD:            if (value == null) {                unsetBoolField();            } else {                setBoolField((Boolean) value);            }            break;        case BYTE_FIELD:            if (value == null) {                unsetByteField();            } else {                setByteField((Byte) value);            }            break;        case BYTE_OPTIONAL_FIELD:            if (value == null) {                unsetByteOptionalField();            } else {                setByteOptionalField((Byte) value);            }            break;        case I16_FIELD:            if (value == null) {                unsetI16Field();            } else {                setI16Field((Short) value);            }            break;        case I16_OPTIONAL_FIELD:            if (value == null) {                unsetI16OptionalField();            } else {                setI16OptionalField((Short) value);            }            break;        case I32_FIELD:            if (value == null) {                unsetI32Field();            } else {                setI32Field((Integer) value);            }            break;        case I64_FIELD:            if (value == null) {                unsetI64Field();            } else {                setI64Field((Long) value);            }            break;        case DOUBLE_FIELD:            if (value == null) {                unsetDoubleField();            } else {                setDoubleField((Double) value);            }            break;        case STRING_FIELD:            if (value == null) {                unsetStringField();            } else {                setStringField((String) value);            }            break;        case BINARY_FIELD:            if (value == null) {                unsetBinaryField();            } else {                setBinaryField((ByteBuffer) value);            }            break;        case MAP_FIELD:            if (value == null) {                unsetMapField();            } else {                setMapField((Map<String, Integer>) value);            }            break;        case LIST_FIELD:            if (value == null) {                unsetListField();            } else {                setListField((List<Integer>) value);            }            break;        case SET_FIELD:            if (value == null) {                unsetSetField();            } else {                setSetField((Set<Integer>) value);            }            break;        case ENUM_FIELD:            if (value == null) {                unsetEnumField();            } else {                setEnumField((E) value);            }            break;        case STRUCT_FIELD:            if (value == null) {                unsetStructField();            } else {                setStructField((Nested) value);            }            break;        case FOO_OR_BAR:            if (value == null) {                unsetFooOrBar();            } else {                setFooOrBar((FooOrBar) value);            }            break;    }}
464d81fc54c8c50a21a786b4dc4dd56822e73892271735c454cff15126bc2dfd
getFieldValue
public Object getFieldValue(_Fields field)
{    switch(field) {        case BOOL_FIELD:            return isBoolField();        case BYTE_FIELD:            return getByteField();        case BYTE_OPTIONAL_FIELD:            return getByteOptionalField();        case I16_FIELD:            return getI16Field();        case I16_OPTIONAL_FIELD:            return getI16OptionalField();        case I32_FIELD:            return getI32Field();        case I64_FIELD:            return getI64Field();        case DOUBLE_FIELD:            return getDoubleField();        case STRING_FIELD:            return getStringField();        case BINARY_FIELD:            return getBinaryField();        case MAP_FIELD:            return getMapField();        case LIST_FIELD:            return getListField();        case SET_FIELD:            return getSetField();        case ENUM_FIELD:            return getEnumField();        case STRUCT_FIELD:            return getStructField();        case FOO_OR_BAR:            return getFooOrBar();    }    throw new IllegalStateException();}
71ed64fc282e6b120c36448a4f95d0d8102f98c0455e5f84713743b2826d64c9
isSet
public boolean isSet(_Fields field)
{    if (field == null) {        throw new IllegalArgumentException();    }    switch(field) {        case BOOL_FIELD:            return isSetBoolField();        case BYTE_FIELD:            return isSetByteField();        case BYTE_OPTIONAL_FIELD:            return isSetByteOptionalField();        case I16_FIELD:            return isSetI16Field();        case I16_OPTIONAL_FIELD:            return isSetI16OptionalField();        case I32_FIELD:            return isSetI32Field();        case I64_FIELD:            return isSetI64Field();        case DOUBLE_FIELD:            return isSetDoubleField();        case STRING_FIELD:            return isSetStringField();        case BINARY_FIELD:            return isSetBinaryField();        case MAP_FIELD:            return isSetMapField();        case LIST_FIELD:            return isSetListField();        case SET_FIELD:            return isSetSetField();        case ENUM_FIELD:            return isSetEnumField();        case STRUCT_FIELD:            return isSetStructField();        case FOO_OR_BAR:            return isSetFooOrBar();    }    throw new IllegalStateException();}
6b3ab298cb5d88dbb2c510c786f53e377489a40e2716e63c26a3e1691765f6c5
equals
public boolean equals(Object that)
{    if (that == null)        return false;    if (that instanceof Test)        return this.equals((Test) that);    return false;}
1360d0cd7d3c52dc9af24c16d8f1041e5690f10a948840e35100b56367bca07e
equals
public boolean equals(Test that)
{    if (that == null)        return false;    boolean this_present_boolField = true;    boolean that_present_boolField = true;    if (this_present_boolField || that_present_boolField) {        if (!(this_present_boolField && that_present_boolField))            return false;        if (this.boolField != that.boolField)            return false;    }    boolean this_present_byteField = true;    boolean that_present_byteField = true;    if (this_present_byteField || that_present_byteField) {        if (!(this_present_byteField && that_present_byteField))            return false;        if (this.byteField != that.byteField)            return false;    }    boolean this_present_byteOptionalField = true && this.isSetByteOptionalField();    boolean that_present_byteOptionalField = true && that.isSetByteOptionalField();    if (this_present_byteOptionalField || that_present_byteOptionalField) {        if (!(this_present_byteOptionalField && that_present_byteOptionalField))            return false;        if (this.byteOptionalField != that.byteOptionalField)            return false;    }    boolean this_present_i16Field = true;    boolean that_present_i16Field = true;    if (this_present_i16Field || that_present_i16Field) {        if (!(this_present_i16Field && that_present_i16Field))            return false;        if (this.i16Field != that.i16Field)            return false;    }    boolean this_present_i16OptionalField = true && this.isSetI16OptionalField();    boolean that_present_i16OptionalField = true && that.isSetI16OptionalField();    if (this_present_i16OptionalField || that_present_i16OptionalField) {        if (!(this_present_i16OptionalField && that_present_i16OptionalField))            return false;        if (this.i16OptionalField != that.i16OptionalField)            return false;    }    boolean this_present_i32Field = true && this.isSetI32Field();    boolean that_present_i32Field = true && that.isSetI32Field();    if (this_present_i32Field || that_present_i32Field) {        if (!(this_present_i32Field && that_present_i32Field))            return false;        if (this.i32Field != that.i32Field)            return false;    }    boolean this_present_i64Field = true;    boolean that_present_i64Field = true;    if (this_present_i64Field || that_present_i64Field) {        if (!(this_present_i64Field && that_present_i64Field))            return false;        if (this.i64Field != that.i64Field)            return false;    }    boolean this_present_doubleField = true;    boolean that_present_doubleField = true;    if (this_present_doubleField || that_present_doubleField) {        if (!(this_present_doubleField && that_present_doubleField))            return false;        if (this.doubleField != that.doubleField)            return false;    }    boolean this_present_stringField = true && this.isSetStringField();    boolean that_present_stringField = true && that.isSetStringField();    if (this_present_stringField || that_present_stringField) {        if (!(this_present_stringField && that_present_stringField))            return false;        if (!this.stringField.equals(that.stringField))            return false;    }    boolean this_present_binaryField = true && this.isSetBinaryField();    boolean that_present_binaryField = true && that.isSetBinaryField();    if (this_present_binaryField || that_present_binaryField) {        if (!(this_present_binaryField && that_present_binaryField))            return false;        if (!this.binaryField.equals(that.binaryField))            return false;    }    boolean this_present_mapField = true && this.isSetMapField();    boolean that_present_mapField = true && that.isSetMapField();    if (this_present_mapField || that_present_mapField) {        if (!(this_present_mapField && that_present_mapField))            return false;        if (!this.mapField.equals(that.mapField))            return false;    }    boolean this_present_listField = true && this.isSetListField();    boolean that_present_listField = true && that.isSetListField();    if (this_present_listField || that_present_listField) {        if (!(this_present_listField && that_present_listField))            return false;        if (!this.listField.equals(that.listField))            return false;    }    boolean this_present_setField = true && this.isSetSetField();    boolean that_present_setField = true && that.isSetSetField();    if (this_present_setField || that_present_setField) {        if (!(this_present_setField && that_present_setField))            return false;        if (!this.setField.equals(that.setField))            return false;    }    boolean this_present_enumField = true && this.isSetEnumField();    boolean that_present_enumField = true && that.isSetEnumField();    if (this_present_enumField || that_present_enumField) {        if (!(this_present_enumField && that_present_enumField))            return false;        if (!this.enumField.equals(that.enumField))            return false;    }    boolean this_present_structField = true && this.isSetStructField();    boolean that_present_structField = true && that.isSetStructField();    if (this_present_structField || that_present_structField) {        if (!(this_present_structField && that_present_structField))            return false;        if (!this.structField.equals(that.structField))            return false;    }    boolean this_present_fooOrBar = true && this.isSetFooOrBar();    boolean that_present_fooOrBar = true && that.isSetFooOrBar();    if (this_present_fooOrBar || that_present_fooOrBar) {        if (!(this_present_fooOrBar && that_present_fooOrBar))            return false;        return this.fooOrBar.equals(that.fooOrBar);    }    return true;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return 0;}
97ca28f4f5b298253ee52e13f4ccf35c32d4cbdb823a065bb03c83c5b1fb5846
compareTo
public int compareTo(Test other)
{    if (!getClass().equals(other.getClass())) {        return getClass().getName().compareTo(other.getClass().getName());    }    int lastComparison = 0;    lastComparison = Boolean.compare(isSetBoolField(), other.isSetBoolField());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetBoolField()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.boolField, other.boolField);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = Boolean.compare(isSetByteField(), other.isSetByteField());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetByteField()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.byteField, other.byteField);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = Boolean.compare(isSetByteOptionalField(), other.isSetByteOptionalField());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetByteOptionalField()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.byteOptionalField, other.byteOptionalField);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = Boolean.compare(isSetI16Field(), other.isSetI16Field());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetI16Field()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.i16Field, other.i16Field);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = Boolean.compare(isSetI16OptionalField(), other.isSetI16OptionalField());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetI16OptionalField()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.i16OptionalField, other.i16OptionalField);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = Boolean.compare(isSetI32Field(), other.isSetI32Field());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetI32Field()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.i32Field, other.i32Field);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = Boolean.compare(isSetI64Field(), other.isSetI64Field());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetI64Field()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.i64Field, other.i64Field);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = Boolean.compare(isSetDoubleField(), other.isSetDoubleField());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetDoubleField()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.doubleField, other.doubleField);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = Boolean.compare(isSetStringField(), other.isSetStringField());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetStringField()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.stringField, other.stringField);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = Boolean.compare(isSetBinaryField(), other.isSetBinaryField());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetBinaryField()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.binaryField, other.binaryField);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = Boolean.compare(isSetMapField(), other.isSetMapField());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetMapField()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.mapField, other.mapField);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = Boolean.compare(isSetListField(), other.isSetListField());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetListField()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.listField, other.listField);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = Boolean.compare(isSetSetField(), other.isSetSetField());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetSetField()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.setField, other.setField);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = Boolean.compare(isSetEnumField(), other.isSetEnumField());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetEnumField()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.enumField, other.enumField);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = Boolean.compare(isSetStructField(), other.isSetStructField());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetStructField()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.structField, other.structField);        if (lastComparison != 0) {            return lastComparison;        }    }    lastComparison = Boolean.compare(isSetFooOrBar(), other.isSetFooOrBar());    if (lastComparison != 0) {        return lastComparison;    }    if (isSetFooOrBar()) {        lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.fooOrBar, other.fooOrBar);        if (lastComparison != 0) {            return lastComparison;        }    }    return 0;}
8ce4cec748163fe422fba58a0ef1f5936a95d5ce0ec9e530aab7c5a59149b857
fieldForId
public _Fields fieldForId(int fieldId)
{    return _Fields.findByThriftId(fieldId);}
9c387dbc68e2929966a2f4d7377de396c1c24932dd7e709eba5cf9e1c90787af
read
public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException
{    schemes.get(iprot.getScheme()).getScheme().read(iprot, this);}
72f9005ef45238c38f6c8b9506f41c8599609ccde331e03c7044ee080e1472da
write
public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException
{    schemes.get(oprot.getScheme()).getScheme().write(oprot, this);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    StringBuilder sb = new StringBuilder("Test(");    boolean first = true;    sb.append("boolField:");    sb.append(this.boolField);    first = false;    if (!first)        sb.append(", ");    sb.append("byteField:");    sb.append(this.byteField);    first = false;    if (isSetByteOptionalField()) {        if (!first)            sb.append(", ");        sb.append("byteOptionalField:");        sb.append(this.byteOptionalField);        first = false;    }    if (!first)        sb.append(", ");    sb.append("i16Field:");    sb.append(this.i16Field);    first = false;    if (isSetI16OptionalField()) {        if (!first)            sb.append(", ");        sb.append("i16OptionalField:");        sb.append(this.i16OptionalField);        first = false;    }    if (isSetI32Field()) {        if (!first)            sb.append(", ");        sb.append("i32Field:");        sb.append(this.i32Field);        first = false;    }    if (!first)        sb.append(", ");    sb.append("i64Field:");    sb.append(this.i64Field);    first = false;    if (!first)        sb.append(", ");    sb.append("doubleField:");    sb.append(this.doubleField);    first = false;    if (!first)        sb.append(", ");    sb.append("stringField:");    if (this.stringField == null) {        sb.append("null");    } else {        sb.append(this.stringField);    }    first = false;    if (isSetBinaryField()) {        if (!first)            sb.append(", ");        sb.append("binaryField:");        if (this.binaryField == null) {            sb.append("null");        } else {            org.apache.thrift.TBaseHelper.toString(this.binaryField, sb);        }        first = false;    }    if (!first)        sb.append(", ");    sb.append("mapField:");    if (this.mapField == null) {        sb.append("null");    } else {        sb.append(this.mapField);    }    first = false;    if (!first)        sb.append(", ");    sb.append("listField:");    if (this.listField == null) {        sb.append("null");    } else {        sb.append(this.listField);    }    first = false;    if (!first)        sb.append(", ");    sb.append("setField:");    if (this.setField == null) {        sb.append("null");    } else {        sb.append(this.setField);    }    first = false;    if (!first)        sb.append(", ");    sb.append("enumField:");    if (this.enumField == null) {        sb.append("null");    } else {        sb.append(this.enumField);    }    first = false;    if (!first)        sb.append(", ");    sb.append("structField:");    if (this.structField == null) {        sb.append("null");    } else {        sb.append(this.structField);    }    first = false;    if (!first)        sb.append(", ");    sb.append("fooOrBar:");    if (this.fooOrBar == null) {        sb.append("null");    } else {        sb.append(this.fooOrBar);    }    first = false;    sb.append(")");    return sb.toString();}
e9a9838299550df368382cb18b6693a9d80b274b5c7bc089afc33713eceefbe1
validate
public void validate() throws org.apache.thrift.TException
{        if (structField != null) {        structField.validate();    }}
784e52bd99c637d4fd80e90272ace2edbc622a5a5ac2a515ab45f6d177fc378a
writeObject
private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException
{    try {        write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
a2d949a3bc49af9f8b746197cee0585da9e196149570b4a376f3635b857a1744
readObject
private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException
{    try {                        __isset_bitfield = 0;        read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));    } catch (org.apache.thrift.TException te) {        throw new java.io.IOException(te);    }}
8b92607b46a384861b307c243d48dc3986a1448380bdf553f160a0e174064cae
getScheme
public TestStandardScheme getScheme()
{    return new TestStandardScheme();}
5bf4de052ce16534e5b29afd924205555438fb3a0db89405c3e41e61d498a728
read
public void read(org.apache.thrift.protocol.TProtocol iprot, Test struct) throws org.apache.thrift.TException
{    org.apache.thrift.protocol.TField schemeField;    iprot.readStructBegin();    while (true) {        schemeField = iprot.readFieldBegin();        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) {            break;        }        switch(schemeField.id) {            case             1:                if (schemeField.type == org.apache.thrift.protocol.TType.BOOL) {                    struct.boolField = iprot.readBool();                    struct.setBoolFieldIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             2:                if (schemeField.type == org.apache.thrift.protocol.TType.BYTE) {                    struct.byteField = iprot.readByte();                    struct.setByteFieldIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             16:                if (schemeField.type == org.apache.thrift.protocol.TType.BYTE) {                    struct.byteOptionalField = iprot.readByte();                    struct.setByteOptionalFieldIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             3:                if (schemeField.type == org.apache.thrift.protocol.TType.I16) {                    struct.i16Field = iprot.readI16();                    struct.setI16FieldIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             15:                if (schemeField.type == org.apache.thrift.protocol.TType.I16) {                    struct.i16OptionalField = iprot.readI16();                    struct.setI16OptionalFieldIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             4:                if (schemeField.type == org.apache.thrift.protocol.TType.I32) {                    struct.i32Field = iprot.readI32();                    struct.setI32FieldIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             5:                if (schemeField.type == org.apache.thrift.protocol.TType.I64) {                    struct.i64Field = iprot.readI64();                    struct.setI64FieldIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             6:                if (schemeField.type == org.apache.thrift.protocol.TType.DOUBLE) {                    struct.doubleField = iprot.readDouble();                    struct.setDoubleFieldIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             7:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.stringField = iprot.readString();                    struct.setStringFieldIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             8:                if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {                    struct.binaryField = iprot.readBinary();                    struct.setBinaryFieldIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             9:                if (schemeField.type == org.apache.thrift.protocol.TType.MAP) {                    {                        org.apache.thrift.protocol.TMap _map0 = iprot.readMapBegin();                        struct.mapField = new HashMap<>(2 * _map0.size);                        for (int _i1 = 0; _i1 < _map0.size; ++_i1) {                            String _key2;                            int _val3;                            _key2 = iprot.readString();                            _val3 = iprot.readI32();                            struct.mapField.put(_key2, _val3);                        }                        iprot.readMapEnd();                    }                    struct.setMapFieldIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             10:                if (schemeField.type == org.apache.thrift.protocol.TType.LIST) {                    {                        org.apache.thrift.protocol.TList _list4 = iprot.readListBegin();                        struct.listField = new ArrayList<>(_list4.size);                        for (int _i5 = 0; _i5 < _list4.size; ++_i5) {                            int _elem6;                            _elem6 = iprot.readI32();                            struct.listField.add(_elem6);                        }                        iprot.readListEnd();                    }                    struct.setListFieldIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             11:                if (schemeField.type == org.apache.thrift.protocol.TType.SET) {                    {                        org.apache.thrift.protocol.TSet _set7 = iprot.readSetBegin();                        struct.setField = new HashSet<>(2 * _set7.size);                        for (int _i8 = 0; _i8 < _set7.size; ++_i8) {                            int _elem9;                            _elem9 = iprot.readI32();                            struct.setField.add(_elem9);                        }                        iprot.readSetEnd();                    }                    struct.setSetFieldIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             12:                if (schemeField.type == org.apache.thrift.protocol.TType.I32) {                    struct.enumField = E.findByValue(iprot.readI32());                    struct.setEnumFieldIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             13:                if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {                    struct.structField = new Nested();                    struct.structField.read(iprot);                    struct.setStructFieldIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            case             14:                if (schemeField.type == org.apache.thrift.protocol.TType.STRUCT) {                    struct.fooOrBar = new FooOrBar();                    struct.fooOrBar.read(iprot);                    struct.setFooOrBarIsSet(true);                } else {                    org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);                }                break;            default:                org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);        }        iprot.readFieldEnd();    }    iprot.readStructEnd();    struct.validate();}
8014d2ca86dc6966e3d38a0972c067935c8970620a41e4216f729703041ad3b6
write
public void write(org.apache.thrift.protocol.TProtocol oprot, Test struct) throws org.apache.thrift.TException
{    struct.validate();    oprot.writeStructBegin(STRUCT_DESC);    oprot.writeFieldBegin(BOOL_FIELD_FIELD_DESC);    oprot.writeBool(struct.boolField);    oprot.writeFieldEnd();    oprot.writeFieldBegin(BYTE_FIELD_FIELD_DESC);    oprot.writeByte(struct.byteField);    oprot.writeFieldEnd();    oprot.writeFieldBegin(I16_FIELD_FIELD_DESC);    oprot.writeI16(struct.i16Field);    oprot.writeFieldEnd();    if (struct.isSetI32Field()) {        oprot.writeFieldBegin(I32_FIELD_FIELD_DESC);        oprot.writeI32(struct.i32Field);        oprot.writeFieldEnd();    }    oprot.writeFieldBegin(I64_FIELD_FIELD_DESC);    oprot.writeI64(struct.i64Field);    oprot.writeFieldEnd();    oprot.writeFieldBegin(DOUBLE_FIELD_FIELD_DESC);    oprot.writeDouble(struct.doubleField);    oprot.writeFieldEnd();    if (struct.stringField != null) {        oprot.writeFieldBegin(STRING_FIELD_FIELD_DESC);        oprot.writeString(struct.stringField);        oprot.writeFieldEnd();    }    if (struct.binaryField != null) {        if (struct.isSetBinaryField()) {            oprot.writeFieldBegin(BINARY_FIELD_FIELD_DESC);            oprot.writeBinary(struct.binaryField);            oprot.writeFieldEnd();        }    }    if (struct.mapField != null) {        oprot.writeFieldBegin(MAP_FIELD_FIELD_DESC);        {            oprot.writeMapBegin(new org.apache.thrift.protocol.TMap(org.apache.thrift.protocol.TType.STRING, org.apache.thrift.protocol.TType.I32, struct.mapField.size()));            for (Map.Entry<String, Integer> _iter10 : struct.mapField.entrySet()) {                oprot.writeString(_iter10.getKey());                oprot.writeI32(_iter10.getValue());            }            oprot.writeMapEnd();        }        oprot.writeFieldEnd();    }    if (struct.listField != null) {        oprot.writeFieldBegin(LIST_FIELD_FIELD_DESC);        {            oprot.writeListBegin(new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.I32, struct.listField.size()));            for (int _iter11 : struct.listField) {                oprot.writeI32(_iter11);            }            oprot.writeListEnd();        }        oprot.writeFieldEnd();    }    if (struct.setField != null) {        oprot.writeFieldBegin(SET_FIELD_FIELD_DESC);        {            oprot.writeSetBegin(new org.apache.thrift.protocol.TSet(org.apache.thrift.protocol.TType.I32, struct.setField.size()));            for (int _iter12 : struct.setField) {                oprot.writeI32(_iter12);            }            oprot.writeSetEnd();        }        oprot.writeFieldEnd();    }    if (struct.enumField != null) {        oprot.writeFieldBegin(ENUM_FIELD_FIELD_DESC);        oprot.writeI32(struct.enumField.getValue());        oprot.writeFieldEnd();    }    if (struct.structField != null) {        oprot.writeFieldBegin(STRUCT_FIELD_FIELD_DESC);        struct.structField.write(oprot);        oprot.writeFieldEnd();    }    if (struct.fooOrBar != null) {        oprot.writeFieldBegin(FOO_OR_BAR_FIELD_DESC);        struct.fooOrBar.write(oprot);        oprot.writeFieldEnd();    }    if (struct.isSetI16OptionalField()) {        oprot.writeFieldBegin(I16_OPTIONAL_FIELD_FIELD_DESC);        oprot.writeI16(struct.i16OptionalField);        oprot.writeFieldEnd();    }    if (struct.isSetByteOptionalField()) {        oprot.writeFieldBegin(BYTE_OPTIONAL_FIELD_FIELD_DESC);        oprot.writeByte(struct.byteOptionalField);        oprot.writeFieldEnd();    }    oprot.writeFieldStop();    oprot.writeStructEnd();}
4dc514e65dfa07bcd26f63f6bd42b58f17dbc82f52cf39236f5de8839d3a3819
getScheme
public TestTupleScheme getScheme()
{    return new TestTupleScheme();}
e901deafc8d1332fe102da6414d54dd348fc3f5f5930e94f0349c90b6455c76d
write
public void write(org.apache.thrift.protocol.TProtocol prot, Test struct) throws org.apache.thrift.TException
{    TTupleProtocol oprot = (TTupleProtocol) prot;    BitSet optionals = new BitSet();    if (struct.isSetBoolField()) {        optionals.set(0);    }    if (struct.isSetByteField()) {        optionals.set(1);    }    if (struct.isSetByteOptionalField()) {        optionals.set(2);    }    if (struct.isSetI16Field()) {        optionals.set(3);    }    if (struct.isSetI16OptionalField()) {        optionals.set(4);    }    if (struct.isSetI32Field()) {        optionals.set(5);    }    if (struct.isSetI64Field()) {        optionals.set(6);    }    if (struct.isSetDoubleField()) {        optionals.set(7);    }    if (struct.isSetStringField()) {        optionals.set(8);    }    if (struct.isSetBinaryField()) {        optionals.set(9);    }    if (struct.isSetMapField()) {        optionals.set(10);    }    if (struct.isSetListField()) {        optionals.set(11);    }    if (struct.isSetSetField()) {        optionals.set(12);    }    if (struct.isSetEnumField()) {        optionals.set(13);    }    if (struct.isSetStructField()) {        optionals.set(14);    }    if (struct.isSetFooOrBar()) {        optionals.set(15);    }    oprot.writeBitSet(optionals, 16);    if (struct.isSetBoolField()) {        oprot.writeBool(struct.boolField);    }    if (struct.isSetByteField()) {        oprot.writeByte(struct.byteField);    }    if (struct.isSetByteOptionalField()) {        oprot.writeByte(struct.byteOptionalField);    }    if (struct.isSetI16Field()) {        oprot.writeI16(struct.i16Field);    }    if (struct.isSetI16OptionalField()) {        oprot.writeI16(struct.i16OptionalField);    }    if (struct.isSetI32Field()) {        oprot.writeI32(struct.i32Field);    }    if (struct.isSetI64Field()) {        oprot.writeI64(struct.i64Field);    }    if (struct.isSetDoubleField()) {        oprot.writeDouble(struct.doubleField);    }    if (struct.isSetStringField()) {        oprot.writeString(struct.stringField);    }    if (struct.isSetBinaryField()) {        oprot.writeBinary(struct.binaryField);    }    if (struct.isSetMapField()) {        {            oprot.writeI32(struct.mapField.size());            for (Map.Entry<String, Integer> _iter13 : struct.mapField.entrySet()) {                oprot.writeString(_iter13.getKey());                oprot.writeI32(_iter13.getValue());            }        }    }    if (struct.isSetListField()) {        {            oprot.writeI32(struct.listField.size());            for (int _iter14 : struct.listField) {                oprot.writeI32(_iter14);            }        }    }    if (struct.isSetSetField()) {        {            oprot.writeI32(struct.setField.size());            for (int _iter15 : struct.setField) {                oprot.writeI32(_iter15);            }        }    }    if (struct.isSetEnumField()) {        oprot.writeI32(struct.enumField.getValue());    }    if (struct.isSetStructField()) {        struct.structField.write(oprot);    }    if (struct.isSetFooOrBar()) {        struct.fooOrBar.write(oprot);    }}
f4dc76298e2bdbbc8282743933008bdde4ccc56c8a300a45f8019b480ec65232
read
public void read(org.apache.thrift.protocol.TProtocol prot, Test struct) throws org.apache.thrift.TException
{    TTupleProtocol iprot = (TTupleProtocol) prot;    BitSet incoming = iprot.readBitSet(16);    if (incoming.get(0)) {        struct.boolField = iprot.readBool();        struct.setBoolFieldIsSet(true);    }    if (incoming.get(1)) {        struct.byteField = iprot.readByte();        struct.setByteFieldIsSet(true);    }    if (incoming.get(2)) {        struct.byteOptionalField = iprot.readByte();        struct.setByteOptionalFieldIsSet(true);    }    if (incoming.get(3)) {        struct.i16Field = iprot.readI16();        struct.setI16FieldIsSet(true);    }    if (incoming.get(4)) {        struct.i16OptionalField = iprot.readI16();        struct.setI16OptionalFieldIsSet(true);    }    if (incoming.get(5)) {        struct.i32Field = iprot.readI32();        struct.setI32FieldIsSet(true);    }    if (incoming.get(6)) {        struct.i64Field = iprot.readI64();        struct.setI64FieldIsSet(true);    }    if (incoming.get(7)) {        struct.doubleField = iprot.readDouble();        struct.setDoubleFieldIsSet(true);    }    if (incoming.get(8)) {        struct.stringField = iprot.readString();        struct.setStringFieldIsSet(true);    }    if (incoming.get(9)) {        struct.binaryField = iprot.readBinary();        struct.setBinaryFieldIsSet(true);    }    if (incoming.get(10)) {        {            org.apache.thrift.protocol.TMap _map16 = new org.apache.thrift.protocol.TMap(org.apache.thrift.protocol.TType.STRING, org.apache.thrift.protocol.TType.I32, iprot.readI32());            struct.mapField = new HashMap<>(2 * _map16.size);            for (int _i17 = 0; _i17 < _map16.size; ++_i17) {                String _key18;                int _val19;                _key18 = iprot.readString();                _val19 = iprot.readI32();                struct.mapField.put(_key18, _val19);            }        }        struct.setMapFieldIsSet(true);    }    if (incoming.get(11)) {        {            org.apache.thrift.protocol.TList _list20 = new org.apache.thrift.protocol.TList(org.apache.thrift.protocol.TType.I32, iprot.readI32());            struct.listField = new ArrayList<>(_list20.size);            for (int _i21 = 0; _i21 < _list20.size; ++_i21) {                int _elem22;                _elem22 = iprot.readI32();                struct.listField.add(_elem22);            }        }        struct.setListFieldIsSet(true);    }    if (incoming.get(12)) {        {            org.apache.thrift.protocol.TSet _set23 = new org.apache.thrift.protocol.TSet(org.apache.thrift.protocol.TType.I32, iprot.readI32());            struct.setField = new HashSet<>(2 * _set23.size);            for (int _i24 = 0; _i24 < _set23.size; ++_i24) {                int _elem25;                _elem25 = iprot.readI32();                struct.setField.add(_elem25);            }        }        struct.setSetFieldIsSet(true);    }    if (incoming.get(13)) {        struct.enumField = E.findByValue(iprot.readI32());        struct.setEnumFieldIsSet(true);    }    if (incoming.get(14)) {        struct.structField = new Nested();        struct.structField.read(iprot);        struct.setStructFieldIsSet(true);    }    if (incoming.get(15)) {        struct.fooOrBar = new FooOrBar();        struct.fooOrBar.read(iprot);        struct.setFooOrBarIsSet(true);    }}
a2f56ac58e56505985a5d8a48232117c81b58f28d88363744f6d80f9586c2c52
testStruct
public void testStruct() throws Exception
{    System.out.println(ThriftData.get().getSchema(Test.class).toString(true));    Test test = new Test();    test.setBoolField(true);    test.setByteField((byte) 2);    test.setI16Field((short) 3);    test.setI16OptionalField((short) 14);    test.setI32Field(4);    test.setI64Field(5L);    test.setDoubleField(2.0);    test.setStringField("foo");    test.setBinaryField(ByteBuffer.wrap(new byte[] { 0, -1 }));    test.setMapField(Collections.singletonMap("x", 1));    test.setListField(Collections.singletonList(7));    test.setSetField(Collections.singleton(8));    test.setEnumField(E.X);    test.setStructField(new Nested(9));    test.setFooOrBar(FooOrBar.foo("x"));    System.out.println(test);    check(test);}
14a85e8ea969bb82e6c7e5f96686880ed15efb85a8ad403de66a593fbfb35c4a
testOptionals
public void testOptionals() throws Exception
{    Test test = new Test();    test.setBoolField(true);    test.setByteField((byte) 2);    test.setByteOptionalField((byte) 4);    test.setI16Field((short) 3);    test.setI16OptionalField((short) 15);    test.setI64Field(5L);    test.setDoubleField(2.0);    System.out.println(test);    check(test);}
02439371f01acadf04c2b9565c42a096673bf8aa8c5040469faa723957733f4f
check
private void check(Test test) throws Exception
{    ByteArrayOutputStream bao = new ByteArrayOutputStream();    ThriftDatumWriter<Test> w = new ThriftDatumWriter<>(Test.class);    Encoder e = EncoderFactory.get().binaryEncoder(bao, null);    w.write(test, e);    e.flush();    Object o = new ThriftDatumReader<>(Test.class).read(null, DecoderFactory.get().binaryDecoder(new ByteArrayInputStream(bao.toByteArray()), null));    assertEquals(test, o);}
d54ad0f80aeed89e9897bc75c15950f5cdd7597d8e692267ec3a4d192474a585
run
public int run(InputStream stdin, PrintStream out, PrintStream err, List<String> args) throws Exception
{    OptionParser optionParser = new OptionParser();    OptionSpec<Void> noPrettyOption = optionParser.accepts("no-pretty", "Turns off pretty printing.");    OptionSpec<String> schemaFileOption = optionParser.accepts("schema-file", "File containing schema, must not occur with inline schema.").withOptionalArg().ofType(String.class);    OptionSet optionSet = optionParser.parse(args.toArray(new String[0]));    Boolean noPretty = optionSet.has(noPrettyOption);    List<String> nargs = (List<String>) optionSet.nonOptionArguments();    String schemaFile = schemaFileOption.value(optionSet);    if (nargs.size() != (schemaFile == null ? 2 : 1)) {        err.println("fragtojson --no-pretty --schema-file <file> [inline-schema] input-file");        err.println("   converts Avro fragments to JSON.");        optionParser.printHelpOn(err);        err.println("   A dash '-' for input-file means stdin.");        return 1;    }    Schema schema;    String inputFile;    if (schemaFile == null) {        schema = new Schema.Parser().parse(nargs.get(0));        inputFile = nargs.get(1);    } else {        schema = Util.parseSchemaFromFS(schemaFile);        inputFile = nargs.get(0);    }    InputStream input = Util.fileOrStdin(inputFile, stdin);    try {        DatumReader<Object> reader = new GenericDatumReader<>(schema);        BinaryDecoder binaryDecoder = DecoderFactory.get().binaryDecoder(input, null);        DatumWriter<Object> writer = new GenericDatumWriter<>(schema);        JsonEncoder jsonEncoder = EncoderFactory.get().jsonEncoder(schema, out, !noPretty);        Object datum = null;        while (!binaryDecoder.isEnd()) {            datum = reader.read(datum, binaryDecoder);            writer.write(datum, jsonEncoder);            jsonEncoder.flush();        }        out.println();        out.flush();    } finally {        Util.close(input);    }    return 0;}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return "fragtojson";}
697b8c126f1dba9dc13e0aa8a508f6a069de73be37ecc29598629fdfebb0f39d
getShortDescription
public String getShortDescription()
{    return "Renders a binary-encoded Avro datum as JSON.";}
c8c1a14c5a067f2819ebddd0c61a45b8be5e4e207a9f0213a7a973bb25042c5f
run
public int run(InputStream in, PrintStream out, PrintStream err, List<String> args) throws Exception
{    OptionParser optParser = new OptionParser();    OptionSpec<Long> offsetOpt = optParser.accepts("offset", "offset for reading input").withRequiredArg().ofType(Long.class).defaultsTo(new Long(0));    OptionSpec<Long> limitOpt = optParser.accepts("limit", "maximum number of records in the outputfile").withRequiredArg().ofType(Long.class).defaultsTo(Long.MAX_VALUE);    OptionSpec<Double> fracOpt = optParser.accepts("samplerate", "rate at which records will be collected").withRequiredArg().ofType(Double.class).defaultsTo(new Double(1));    OptionSet opts = optParser.parse(args.toArray(new String[0]));    List<String> nargs = (List<String>) opts.nonOptionArguments();    if (nargs.size() < 2) {        printHelp(out);        return 0;    }    inFiles = Util.getFiles(nargs.subList(0, nargs.size() - 1));    System.out.println("List of input files:");    for (Path p : inFiles) {        System.out.println(p);    }    currentInput = -1;    nextInput();    OutputStream output = out;    String lastArg = nargs.get(nargs.size() - 1);    if (nargs.size() > 1 && !lastArg.equals("-")) {        output = Util.createFromFS(lastArg);    }    writer = new DataFileWriter<>(new GenericDatumWriter<>());    String codecName = reader.getMetaString(DataFileConstants.CODEC);    CodecFactory codec = (codecName == null) ? CodecFactory.fromString(DataFileConstants.NULL_CODEC) : CodecFactory.fromString(codecName);    writer.setCodec(codec);    for (String key : reader.getMetaKeys()) {        if (!DataFileWriter.isReservedMeta(key)) {            writer.setMeta(key, reader.getMeta(key));        }    }    writer.create(schema, output);    long offset = opts.valueOf(offsetOpt);    long limit = opts.valueOf(limitOpt);    double samplerate = opts.valueOf(fracOpt);    sampleCounter = 1;    totalCopied = 0;    reuse = null;    if (limit < 0) {        System.out.println("limit has to be non-negative");        this.printHelp(out);        return 1;    }    if (offset < 0) {        System.out.println("offset has to be non-negative");        this.printHelp(out);        return 1;    }    if (samplerate < 0 || samplerate > 1) {        System.out.println("samplerate has to be a number between 0 and 1");        this.printHelp(out);        return 1;    }    skip(offset);    writeRecords(limit, samplerate);    System.out.println(totalCopied + " records written.");    writer.flush();    writer.close();    Util.close(out);    return 0;}
89f58fc3865c87d15e76f894c7f6e5df98ce55f397576e1de7d1184c306e10a3
nextInput
private void nextInput() throws IOException
{    currentInput++;    Path path = inFiles.get(currentInput);    FSDataInputStream input = new FSDataInputStream(Util.openFromFS(path));    reader = new DataFileStream<>(input, new GenericDatumReader<>());    if (schema == null) {                schema = reader.getSchema();    } else if (!schema.equals(reader.getSchema())) {                throw new IOException("schemas dont match");    }}
0c15299149bc6e32bc2f4d63dfbc5ccfe61f8d380703258aa80a3de021520ea3
hasNextInput
private boolean hasNextInput()
{    return inFiles.size() > (currentInput + 1);}
7b930e497ab05bf33fcd333b80a23197b2d9edf0462b8426146ac649311c4a84
skip
private long skip(long skip) throws IOException
{    long skipped = 0;    while (0 < skip && reader.hasNext()) {        reader.next(reuse);        skip--;        skipped++;    }    if ((0 < skip) && hasNextInput()) {                nextInput();        skipped = skipped + skip(skip);    }    return skipped;}
4f734c0892d819652e0f1a2107469ce835359d0e6151787e5bee4c00f7625d97
writeRecords
private long writeRecords(long count, double samplerate) throws IOException
{    long written = 0;    while (written < count && reader.hasNext()) {        reuse = reader.next(reuse);        sampleCounter = sampleCounter + samplerate;        if (sampleCounter >= 1) {            writer.append(reuse);            written++;            sampleCounter--;        }    }    totalCopied = totalCopied + written;    if (written < count && hasNextInput()) {                nextInput();        written = written + writeRecords(count - written, samplerate);    }    return written;}
c4897b8eeaa9a4866926ffb4fc0e3a95832b424649e7feecde973ca2337b62c6
printHelp
private void printHelp(PrintStream out)
{    out.println("cat --offset <offset> --limit <limit> --samplerate <samplerate> [input-files...] output-file");    out.println();    out.println("extracts records from a list of input files into a new file.");    out.println("--offset      start of the extract");    out.println("--limit       maximum number of records in the output file.");    out.println("--samplerate  rate at which records will be collected");    out.println("A dash ('-') can be given to direct output to stdout");}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return "cat";}
697b8c126f1dba9dc13e0aa8a508f6a069de73be37ecc29598629fdfebb0f39d
getShortDescription
public String getShortDescription()
{    return "Extracts samples from files";}
c8c1a14c5a067f2819ebddd0c61a45b8be5e4e207a9f0213a7a973bb25042c5f
run
public int run(InputStream in, PrintStream out, PrintStream err, List<String> args) throws Exception
{    if (args.isEmpty()) {        printHelp(out);        return 0;    }    OutputStream output = out;    if (args.size() > 1) {        output = Util.fileOrStdout(args.get(args.size() - 1), out);        args = args.subList(0, args.size() - 1);    }    DataFileWriter<GenericRecord> writer = new DataFileWriter<>(new GenericDatumWriter<>());    Schema schema = null;    Map<String, byte[]> metadata = new TreeMap<>();    String inputCodec = null;    for (String inFile : expandsInputFiles(args)) {        InputStream input = Util.fileOrStdin(inFile, in);        DataFileStream<GenericRecord> reader = new DataFileStream<>(input, new GenericDatumReader<>());        if (schema == null) {                                    schema = reader.getSchema();            for (String key : reader.getMetaKeys()) {                if (!DataFileWriter.isReservedMeta(key)) {                    byte[] metadatum = reader.getMeta(key);                    metadata.put(key, metadatum);                    writer.setMeta(key, metadatum);                }            }            inputCodec = reader.getMetaString(DataFileConstants.CODEC);            if (inputCodec == null) {                inputCodec = DataFileConstants.NULL_CODEC;            }            writer.setCodec(CodecFactory.fromString(inputCodec));            writer.create(schema, output);        } else {                        if (!schema.equals(reader.getSchema())) {                err.println("input files have different schemas");                reader.close();                return 1;            }            for (String key : reader.getMetaKeys()) {                if (!DataFileWriter.isReservedMeta(key)) {                    byte[] metadatum = reader.getMeta(key);                    byte[] writersMetadatum = metadata.get(key);                    if (!Arrays.equals(metadatum, writersMetadatum)) {                        err.println("input files have different non-reserved metadata");                        reader.close();                        return 2;                    }                }            }            String thisCodec = reader.getMetaString(DataFileConstants.CODEC);            if (thisCodec == null) {                thisCodec = DataFileConstants.NULL_CODEC;            }            if (!inputCodec.equals(thisCodec)) {                err.println("input files have different codecs");                reader.close();                return 3;            }        }        writer.appendAllFrom(reader, /* recompress */        false);        reader.close();    }    writer.close();    return 0;}
d3d38bad8eb71576146f05fa3edaf74f97a31eabebcea83ad8740d98b765ba6f
expandsInputFiles
private static List<String> expandsInputFiles(List<String> args) throws IOException
{    List<String> files = new ArrayList<>();    for (String arg : args) {        if (arg.equals("-")) {            files.add(arg);        } else {            List<Path> paths = Util.getFiles(arg);            for (Path path : paths) {                files.add(path.toString());            }        }    }    return files;}
c4897b8eeaa9a4866926ffb4fc0e3a95832b424649e7feecde973ca2337b62c6
printHelp
private void printHelp(PrintStream out)
{    out.println("concat [input-file...] output-file");    out.println();    out.println("Concatenates one or more input files into a new output file");    out.println("by appending the input blocks without decoding them. The input");    out.println("files must have the same schema, metadata and codec. If they");    out.println("do not the tool will return the following error codes:");    out.println("  1 if the schemas don't match");    out.println("  2 if the metadata doesn't match");    out.println("  3 if the codecs don't match");    out.println("If no input files are given stdin will be used. The tool");    out.println("0 on success. A dash ('-') can be given as an input file");    out.println("to use stdin, and as an output file to use stdout. If a directory");    out.println("is given as an input-file all the files within this directory");    out.println("are used.");}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return "concat";}
697b8c126f1dba9dc13e0aa8a508f6a069de73be37ecc29598629fdfebb0f39d
getShortDescription
public String getShortDescription()
{    return "Concatenates avro files without re-compressing.";}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return "random";}
697b8c126f1dba9dc13e0aa8a508f6a069de73be37ecc29598629fdfebb0f39d
getShortDescription
public String getShortDescription()
{    return "Creates a file with randomly generated instances of a schema.";}
d54ad0f80aeed89e9897bc75c15950f5cdd7597d8e692267ec3a4d192474a585
run
public int run(InputStream stdin, PrintStream out, PrintStream err, List<String> args) throws Exception
{    OptionParser p = new OptionParser();    OptionSpec<Integer> count = p.accepts("count", "Record Count").withRequiredArg().ofType(Integer.class);    OptionSpec<String> codec = Util.compressionCodecOption(p);    OptionSpec<Integer> level = Util.compressionLevelOption(p);    OptionSpec<String> file = p.accepts("schema-file", "Schema File").withOptionalArg().ofType(String.class);    OptionSpec<String> inschema = p.accepts("schema", "Schema").withOptionalArg().ofType(String.class);    OptionSpec<Long> seedOpt = p.accepts("seed", "Seed for random").withOptionalArg().ofType(Long.class);    OptionSet opts = p.parse(args.toArray(new String[0]));    if (opts.nonOptionArguments().size() != 1) {        err.println("Usage: outFile (filename or '-' for stdout)");        p.printHelpOn(err);        return 1;    }    args = (List<String>) opts.nonOptionArguments();    String schemastr = inschema.value(opts);    String schemafile = file.value(opts);    Long seed = seedOpt.value(opts);    if (schemastr == null && schemafile == null) {        err.println("Need input schema (--schema-file) or (--schema)");        p.printHelpOn(err);        return 1;    }    Schema schema = (schemafile != null) ? Util.parseSchemaFromFS(schemafile) : new Schema.Parser().parse(schemastr);    DataFileWriter<Object> writer = new DataFileWriter<>(new GenericDatumWriter<>());    writer.setCodec(Util.codecFactory(opts, codec, level));    writer.create(schema, Util.fileOrStdout(args.get(0), out));    Integer countValue = count.value(opts);    if (countValue == null) {        err.println("Need count (--count)");        p.printHelpOn(err);        writer.close();        return 1;    }    RandomData rd = seed == null ? new RandomData(schema, countValue) : new RandomData(schema, countValue, seed);    for (Object datum : rd) writer.append(datum);    writer.close();    return 0;}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return "getmeta";}
697b8c126f1dba9dc13e0aa8a508f6a069de73be37ecc29598629fdfebb0f39d
getShortDescription
public String getShortDescription()
{    return "Prints out the metadata of an Avro data file.";}
d54ad0f80aeed89e9897bc75c15950f5cdd7597d8e692267ec3a4d192474a585
run
public int run(InputStream stdin, PrintStream out, PrintStream err, List<String> args) throws Exception
{    OptionParser p = new OptionParser();    OptionSpec<String> keyOption = p.accepts("key", "Metadata key").withOptionalArg().ofType(String.class);    OptionSet opts = p.parse(args.toArray(new String[0]));    String keyName = keyOption.value(opts);    List<String> nargs = (List<String>) opts.nonOptionArguments();    if (nargs.size() != 1) {        err.println("Expected 1 arg: input_file");        p.printHelpOn(err);        return 1;    }    FsInput in = Util.openSeekableFromFS(args.get(0));    DataFileReader<Void> reader = new DataFileReader<>(in, new GenericDatumReader<>());    if (keyName != null) {        byte[] value = reader.getMeta(keyName);        if (value != null) {            out.write(value, 0, value.length);            out.println();        }    } else {        List<String> keys = reader.getMetaKeys();        for (String key : keys) {            out.print(escapeKey(key));            out.print('\t');            byte[] value = reader.getMeta(key);            out.write(value, 0, value.length);            out.println();        }    }    return 0;}
5b469fd852042b590cd50de26e799554b1b9be7b19410a0052bf6e9c77bb46a6
escapeKey
 static String escapeKey(String key)
{        key = key.replace("\\", "\\\\");        key = key.replace("\t", "\\t");        key = key.replace("\n", "\\n");        key = key.replace("\r", "\\r");    return key;}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return "getschema";}
697b8c126f1dba9dc13e0aa8a508f6a069de73be37ecc29598629fdfebb0f39d
getShortDescription
public String getShortDescription()
{    return "Prints out schema of an Avro data file.";}
d54ad0f80aeed89e9897bc75c15950f5cdd7597d8e692267ec3a4d192474a585
run
public int run(InputStream stdin, PrintStream out, PrintStream err, List<String> args) throws Exception
{    if (args.size() != 1) {        err.println("Expected 1 argument: input_file");        return 1;    }    DataFileReader<Void> reader = new DataFileReader<>(Util.openSeekableFromFS(args.get(0)), new GenericDatumReader<>());    out.println(reader.getSchema().toString(true));    return 0;}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return "tojson";}
697b8c126f1dba9dc13e0aa8a508f6a069de73be37ecc29598629fdfebb0f39d
getShortDescription
public String getShortDescription()
{    return "Dumps an Avro data file as JSON, record per line or pretty.";}
d54ad0f80aeed89e9897bc75c15950f5cdd7597d8e692267ec3a4d192474a585
run
public int run(InputStream stdin, PrintStream out, PrintStream err, List<String> args) throws Exception
{    OptionParser optionParser = new OptionParser();    OptionSpec<Void> prettyOption = optionParser.accepts("pretty", "Turns on pretty printing.");    String headDesc = String.format("Converts the first X records (default is %d).", DEFAULT_HEAD_COUNT);    OptionSpec<String> headOption = optionParser.accepts("head", headDesc).withOptionalArg();    OptionSet optionSet = optionParser.parse(args.toArray(new String[0]));    Boolean pretty = optionSet.has(prettyOption);    List<String> nargs = new ArrayList<>((List<String>) optionSet.nonOptionArguments());    long headCount = getHeadCount(optionSet, headOption, nargs);    if (nargs.size() != 1) {        printHelp(err);        err.println();        optionParser.printHelpOn(err);        return 1;    }    BufferedInputStream inStream = Util.fileOrStdin(nargs.get(0), stdin);    GenericDatumReader<Object> reader = new GenericDatumReader<>();    try (DataFileStream<Object> streamReader = new DataFileStream<>(inStream, reader)) {        Schema schema = streamReader.getSchema();        DatumWriter<Object> writer = new GenericDatumWriter<>(schema);        JsonEncoder encoder = EncoderFactory.get().jsonEncoder(schema, out, pretty);        for (long recordCount = 0; streamReader.hasNext() && recordCount < headCount; recordCount++) {            Object datum = streamReader.next();            writer.write(datum, encoder);        }        encoder.flush();        out.println();        out.flush();    }    return 0;}
ec778ce93ef5f7ff382f66e1c26bda3e373782e6a950a8c5da61b7ff1f797ea0
getHeadCount
private static long getHeadCount(OptionSet optionSet, OptionSpec<String> headOption, List<String> nargs)
{    long headCount = Long.MAX_VALUE;    if (optionSet.has(headOption)) {        headCount = DEFAULT_HEAD_COUNT;        List<String> headValues = optionSet.valuesOf(headOption);        if (headValues.size() > 0) {                        try {                headCount = Long.parseLong(headValues.get(0));                if (headCount < 0)                    throw new AvroRuntimeException("--head count must not be negative");            } catch (NumberFormatException ex) {                nargs.addAll(headValues);            }        }    }    return headCount;}
964bce3781d063b1dd6b0f7c171b847877bf8450b38ab274d6b41f1e0e81ecc1
printHelp
private void printHelp(PrintStream ps)
{    ps.println("tojson [--pretty] [--head[=X]] input-file");    ps.println();    ps.println(getShortDescription());    ps.println("A dash ('-') can be given as an input file to use stdin");}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return "repair";}
697b8c126f1dba9dc13e0aa8a508f6a069de73be37ecc29598629fdfebb0f39d
getShortDescription
public String getShortDescription()
{    return "Recovers data from a corrupt Avro Data file";}
2c8513f63d2ab6cc1c4688eae941f9275d1bd02fe9150955f492028607423ec5
printInfo
private void printInfo(PrintStream output)
{    output.println("Insufficient arguments.  Arguments:  [-o option] " + "input_file output_file \n" + "   Where option is one of the following: \n" + "      " + ALL + " (default) recover as many records as possible.\n" + "      " + PRIOR + "         recover only records prior to the first instance" + " of corruption \n" + "      " + AFTER + "         recover only records after the first instance of" + " corruption.\n" + "      " + REPORT + "        print the corruption report only, reporting the\n" + "                    number of valid and corrupted blocks and records\n" + "   input_file is the file to read from.  output_file is the file to\n" + "   create and write recovered data to.  output_file is ignored if\n" + "   using the report option.");}
d54ad0f80aeed89e9897bc75c15950f5cdd7597d8e692267ec3a4d192474a585
run
public int run(InputStream stdin, PrintStream out, PrintStream err, List<String> args) throws Exception
{    if (args.size() < 2) {        printInfo(err);        return 1;    }    int index = 0;    String input = args.get(index);    String option = "all";    if ("-o".equals(input)) {        option = args.get(1);        index += 2;    }    if (!OPTIONS.contains(option) || (args.size() - index < 1)) {        printInfo(err);        return 1;    }    input = args.get(index++);    if (!REPORT.equals(option)) {        if (args.size() - index < 1) {            printInfo(err);            return 1;        }    }    if (ALL.equals(option)) {        return recoverAll(input, args.get(index), out, err);    } else if (PRIOR.equals(option)) {        return recoverPrior(input, args.get(index), out, err);    } else if (AFTER.equals(option)) {        return recoverAfter(input, args.get(index), out, err);    } else if (REPORT.equals(option)) {        return reportOnly(input, out, err);    } else {        return 1;    }}
dc759d2547d213c2925f570f8ee37270db889c750a09ac3ef85939f718abfe29
recover
private int recover(String input, String output, PrintStream out, PrintStream err, boolean recoverPrior, boolean recoverAfter) throws IOException
{    File infile = new File(input);    if (!infile.canRead()) {        err.println("cannot read file: " + input);        return 1;    }    out.println("Recovering file: " + input);    GenericDatumReader<Object> reader = new GenericDatumReader<>();    try (DataFileReader<Object> fileReader = new DataFileReader<>(infile, reader)) {        Schema schema = fileReader.getSchema();        String codecStr = fileReader.getMetaString(DataFileConstants.CODEC);        CodecFactory codecFactory = CodecFactory.fromString("" + codecStr);        List<String> metas = fileReader.getMetaKeys();        if (recoverPrior || recoverAfter) {            GenericDatumWriter<Object> writer = new GenericDatumWriter<>();            DataFileWriter<Object> fileWriter = new DataFileWriter<>(writer);            try {                File outfile = new File(output);                for (String key : metas) {                    if (!key.startsWith("avro.")) {                        byte[] val = fileReader.getMeta(key);                        fileWriter.setMeta(key, val);                    }                }                fileWriter.setCodec(codecFactory);                int result = innerRecover(fileReader, fileWriter, out, err, recoverPrior, recoverAfter, schema, outfile);                return result;            } catch (Exception e) {                e.printStackTrace(err);                return 1;            }        } else {            return innerRecover(fileReader, null, out, err, recoverPrior, recoverAfter, null, null);        }    }}
1d305bbd206118db80c449a82458c987c21faee200b1a7b32aebf2a9f1694535
innerRecover
private int innerRecover(DataFileReader<Object> fileReader, DataFileWriter<Object> fileWriter, PrintStream out, PrintStream err, boolean recoverPrior, boolean recoverAfter, Schema schema, File outfile)
{    int numBlocks = 0;    int numCorruptBlocks = 0;    int numRecords = 0;    int numCorruptRecords = 0;    int recordsWritten = 0;    long position = fileReader.previousSync();    long blockSize = 0;    long blockCount = 0;    boolean fileWritten = false;    try {        while (true) {            try {                if (!fileReader.hasNext()) {                    out.println("File Summary: ");                    out.println("  Number of blocks: " + numBlocks + " Number of corrupt blocks: " + numCorruptBlocks);                    out.println("  Number of records: " + numRecords + " Number of corrupt records: " + numCorruptRecords);                    if (recoverAfter || recoverPrior) {                        out.println("  Number of records written " + recordsWritten);                    }                    out.println();                    return 0;                }                position = fileReader.previousSync();                blockCount = fileReader.getBlockCount();                blockSize = fileReader.getBlockSize();                numRecords += blockCount;                long blockRemaining = blockCount;                numBlocks++;                boolean lastRecordWasBad = false;                long badRecordsInBlock = 0;                while (blockRemaining > 0) {                    try {                        Object datum = fileReader.next();                        if ((recoverPrior && numCorruptBlocks == 0) || (recoverAfter && numCorruptBlocks > 0)) {                            if (!fileWritten) {                                try {                                    fileWriter.create(schema, outfile);                                    fileWritten = true;                                } catch (Exception e) {                                    e.printStackTrace(err);                                    return 1;                                }                            }                            try {                                fileWriter.append(datum);                                recordsWritten++;                            } catch (Exception e) {                                e.printStackTrace(err);                                throw e;                            }                        }                        blockRemaining--;                        lastRecordWasBad = false;                    } catch (Exception e) {                        long pos = blockCount - blockRemaining;                        if (badRecordsInBlock == 0) {                                                        numCorruptBlocks++;                            err.println("Corrupt block: " + numBlocks + " Records in block: " + blockCount + " uncompressed block size: " + blockSize);                            err.println("Corrupt record at position: " + (pos));                        } else {                                                        err.println("Corrupt record at position: " + (pos));                            if (lastRecordWasBad) {                                                                err.println("Second consecutive bad record in block: " + numBlocks + ". Skipping remainder of block. ");                                numCorruptRecords += blockRemaining;                                badRecordsInBlock += blockRemaining;                                try {                                    fileReader.sync(position);                                } catch (Exception e2) {                                    err.println("failed to sync to sync marker, aborting");                                    e2.printStackTrace(err);                                    return 1;                                }                                break;                            }                        }                        blockRemaining--;                        lastRecordWasBad = true;                        numCorruptRecords++;                        badRecordsInBlock++;                    }                }                if (badRecordsInBlock != 0) {                    err.println("** Number of unrecoverable records in block: " + (badRecordsInBlock));                }                position = fileReader.previousSync();            } catch (Exception e) {                err.println("Failed to read block " + numBlocks + ". Unknown record " + "count in block.  Skipping. Reason: " + e.getMessage());                numCorruptBlocks++;                try {                    fileReader.sync(position);                } catch (Exception e2) {                    err.println("failed to sync to sync marker, aborting");                    e2.printStackTrace(err);                    return 1;                }            }        }    } finally {        if (fileWritten) {            try {                fileWriter.close();            } catch (Exception e) {                e.printStackTrace(err);                return 1;            }        }    }}
922bb99af2bcc018ac1e346086da6d29b63987b52055febbadc41aa49f9044e1
reportOnly
private int reportOnly(String input, PrintStream out, PrintStream err) throws IOException
{    return recover(input, null, out, err, false, false);}
fa09ae0487704569ac735130806af9881dfa0335f011aeed95f8dcd207d6c8cf
recoverAfter
private int recoverAfter(String input, String output, PrintStream out, PrintStream err) throws IOException
{    return recover(input, output, out, err, false, true);}
ebed66236f77106f64dbe28b46fbb2248681b6812f04fce87bc24962fb459f59
recoverPrior
private int recoverPrior(String input, String output, PrintStream out, PrintStream err) throws IOException
{    return recover(input, output, out, err, true, false);}
ac6914d795cbd6260b5a992b8ae5dbc43ed2936856c600987da9765da9897353
recoverAll
private int recoverAll(String input, String output, PrintStream out, PrintStream err) throws IOException
{    return recover(input, output, out, err, true, true);}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return "fromjson";}
697b8c126f1dba9dc13e0aa8a508f6a069de73be37ecc29598629fdfebb0f39d
getShortDescription
public String getShortDescription()
{    return "Reads JSON records and writes an Avro data file.";}
d54ad0f80aeed89e9897bc75c15950f5cdd7597d8e692267ec3a4d192474a585
run
public int run(InputStream stdin, PrintStream out, PrintStream err, List<String> args) throws Exception
{    OptionParser p = new OptionParser();    OptionSpec<String> codec = Util.compressionCodecOptionWithDefault(p, DataFileConstants.NULL_CODEC);    OptionSpec<Integer> level = Util.compressionLevelOption(p);    OptionSpec<String> file = p.accepts("schema-file", "Schema File").withOptionalArg().ofType(String.class);    OptionSpec<String> inschema = p.accepts("schema", "Schema").withOptionalArg().ofType(String.class);    OptionSet opts = p.parse(args.toArray(new String[0]));    List<String> nargs = (List<String>) opts.nonOptionArguments();    if (nargs.size() != 1) {        err.println("Expected 1 arg: input_file");        p.printHelpOn(err);        return 1;    }    String schemastr = inschema.value(opts);    String schemafile = file.value(opts);    if (schemastr == null && schemafile == null) {        err.println("Need an input schema file (--schema-file) or inline schema (--schema)");        p.printHelpOn(err);        return 1;    }    Schema schema = (schemafile != null) ? Util.parseSchemaFromFS(schemafile) : new Schema.Parser().parse(schemastr);    DatumReader<Object> reader = new GenericDatumReader<>(schema);    InputStream input = Util.fileOrStdin(nargs.get(0), stdin);    try {        DataInputStream din = new DataInputStream(input);        DataFileWriter<Object> writer = new DataFileWriter<>(new GenericDatumWriter<>());        writer.setCodec(Util.codecFactory(opts, codec, level, DataFileConstants.NULL_CODEC));        writer.create(schema, out);        Decoder decoder = DecoderFactory.get().jsonDecoder(schema, din);        Object datum;        while (true) {            try {                datum = reader.read(null, decoder);            } catch (EOFException e) {                break;            }            writer.append(datum);        }        writer.close();    } finally {        Util.close(input);    }    return 0;}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return "fromtext";}
697b8c126f1dba9dc13e0aa8a508f6a069de73be37ecc29598629fdfebb0f39d
getShortDescription
public String getShortDescription()
{    return "Imports a text file into an avro data file.";}
d54ad0f80aeed89e9897bc75c15950f5cdd7597d8e692267ec3a4d192474a585
run
public int run(InputStream stdin, PrintStream out, PrintStream err, List<String> args) throws Exception
{    OptionParser p = new OptionParser();    OptionSpec<Integer> level = Util.compressionLevelOption(p);    OptionSpec<String> codec = Util.compressionCodecOption(p);    OptionSet opts = p.parse(args.toArray(new String[0]));    List<String> nargs = (List<String>) opts.nonOptionArguments();    if (nargs.size() != 2) {        err.println("Expected 2 args: from_file to_file (local filenames," + " Hadoop URI's, or '-' for stdin/stdout");        p.printHelpOn(err);        return 1;    }    CodecFactory codecFactory = Util.codecFactory(opts, codec, level);    BufferedInputStream inStream = Util.fileOrStdin(nargs.get(0), stdin);    BufferedOutputStream outStream = Util.fileOrStdout(nargs.get(1), out);    DataFileWriter<ByteBuffer> writer = new DataFileWriter<>(new GenericDatumWriter<>());    writer.setCodec(codecFactory);    writer.create(new Schema.Parser().parse(TEXT_FILE_SCHEMA), outStream);    ByteBuffer line = ByteBuffer.allocate(128);    boolean returnSeen = false;    byte[] buf = new byte[8192];    for (int end = inStream.read(buf); end != -1; end = inStream.read(buf)) {        for (int i = 0; i < end; i++) {            int b = buf[i] & 0xFF;            if (b == '\n') {                                if (!returnSeen) {                    System.out.println("Writing line = " + line.position());                    line.flip();                    writer.append(line);                    line.clear();                } else {                    returnSeen = false;                }            } else if (b == '\r') {                                line.flip();                writer.append(line);                line.clear();                returnSeen = true;            } else {                if (line.position() == line.limit()) {                                        ByteBuffer tempLine = ByteBuffer.allocate(line.limit() * 2);                    line.flip();                    tempLine.put(line);                    line = tempLine;                }                line.put((byte) b);                returnSeen = false;            }        }    }    writer.close();    inStream.close();    return 0;}
c8c1a14c5a067f2819ebddd0c61a45b8be5e4e207a9f0213a7a973bb25042c5f
run
public int run(InputStream in, PrintStream out, PrintStream err, List<String> args) throws Exception
{    PrintStream parseOut = out;    if (args.size() > 2 || (args.size() == 1 && (args.get(0).equals("--help") || args.get(0).equals("-help")))) {        err.println("Usage: idl [in] [out]");        err.println();        err.println("If an output path is not specified, outputs to stdout.");        err.println("If no input or output is specified, takes input from");        err.println("stdin and outputs to stdin.");        err.println("The special path \"-\" may also be specified to refer to");        err.println("stdin and stdout.");        return -1;    }    Idl parser;    if (args.size() >= 1 && !"-".equals(args.get(0))) {        parser = new Idl(new File(args.get(0)));    } else {        parser = new Idl(in);    }    if (args.size() == 2 && !"-".equals(args.get(1))) {        parseOut = new PrintStream(new FileOutputStream(args.get(1)));    }    Protocol p = parser.CompilationUnit();    try {        parseOut.print(p.toString(true));    } finally {        if (        parseOut != out)            parseOut.close();    }    return 0;}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return "idl";}
697b8c126f1dba9dc13e0aa8a508f6a069de73be37ecc29598629fdfebb0f39d
getShortDescription
public String getShortDescription()
{    return "Generates a JSON schema from an Avro IDL file";}
c8c1a14c5a067f2819ebddd0c61a45b8be5e4e207a9f0213a7a973bb25042c5f
run
public int run(InputStream in, PrintStream out, PrintStream err, List<String> args) throws Exception
{    if (args.isEmpty() || args.size() > 2 || isRequestingHelp(args)) {        err.println("Usage: idl2schemata [idl] [outdir]");        err.println("");        err.println("If an output directory is not specified, " + "outputs to current directory.");        return -1;    }    boolean pretty = true;    Idl parser = new Idl(new File(args.get(0)));    File outputDirectory = getOutputDirectory(args);    for (Schema schema : parser.CompilationUnit().getTypes()) {        print(schema, outputDirectory, pretty);    }    parser.close();    return 0;}
4f7309e1fef4b833b47ab065bf0fc55f92c50b3d7c8174012dfc310266a54d33
isRequestingHelp
private boolean isRequestingHelp(List<String> args)
{    return args.size() == 1 && (args.get(0).equals("--help") || args.get(0).equals("-help"));}
5a94981116bf641af5b4909784044b3aeb2b57e33b3c918c3b1d9a158eb7c39d
getOutputDirectory
private File getOutputDirectory(List<String> args)
{    String dirname = (args.size() == 2) ? args.get(1) : "";    File outputDirectory = new File(dirname);    outputDirectory.mkdirs();    return outputDirectory;}
4dd4f49084a2ce6914d8a0d7c92c617241a7c6e0bdf77215cdf85f48c82a666c
print
private void print(Schema schema, File outputDirectory, boolean pretty) throws FileNotFoundException
{    String dirpath = outputDirectory.getAbsolutePath();    String filename = dirpath + "/" + schema.getName() + ".avsc";    FileOutputStream fileOutputStream = new FileOutputStream(filename);    PrintStream printStream = new PrintStream(fileOutputStream);    printStream.println(schema.toString(pretty));    printStream.close();}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return "idl2schemata";}
697b8c126f1dba9dc13e0aa8a508f6a069de73be37ecc29598629fdfebb0f39d
getShortDescription
public String getShortDescription()
{    return "Extract JSON schemata of the types from an Avro IDL file";}
c8c1a14c5a067f2819ebddd0c61a45b8be5e4e207a9f0213a7a973bb25042c5f
run
public int run(InputStream in, PrintStream out, PrintStream err, List<String> args) throws Exception
{    if (args.size() == 0 || args.size() > 2) {        System.err.println("Usage: [colon-delimited-classpath] classname");        return 1;    }    ClassLoader classLoader = Thread.currentThread().getContextClassLoader();    String className;    if (args.size() == 2) {        String classpaths = args.get(0);        className = args.get(1);        if (!classpaths.isEmpty()) {            String[] paths = args.get(0).split(":");            URL[] urls = new URL[paths.length];            for (int i = 0; i < paths.length; ++i) {                urls[i] = new File(paths[i]).toURI().toURL();            }            classLoader = URLClassLoader.newInstance(urls, classLoader);        }    } else {        className = args.get(0);    }    Class<?> klass = classLoader.loadClass(className);    if (klass.isInterface()) {        System.out.println(ReflectData.get().getProtocol(klass).toString(true));    } else {        System.out.println(ReflectData.get().getSchema(klass).toString(true));    }    return 0;}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return "induce";}
697b8c126f1dba9dc13e0aa8a508f6a069de73be37ecc29598629fdfebb0f39d
getShortDescription
public String getShortDescription()
{    return "Induce schema/protocol from Java class/interface via reflection.";}
d54ad0f80aeed89e9897bc75c15950f5cdd7597d8e692267ec3a4d192474a585
run
public int run(InputStream stdin, PrintStream out, PrintStream err, List<String> args) throws Exception
{    OptionParser optionParser = new OptionParser();    OptionSpec<String> schemaFileOption = optionParser.accepts("schema-file", "File containing schema, must not occur with inline schema.").withOptionalArg().ofType(String.class);    OptionSet optionSet = optionParser.parse(args.toArray(new String[0]));    List<String> nargs = (List<String>) optionSet.nonOptionArguments();    String schemaFile = schemaFileOption.value(optionSet);    if (nargs.size() != (schemaFile == null ? 2 : 1)) {        err.println("jsontofrag --schema-file <file> [inline-schema] input-file");        err.println("   converts JSON to Avro fragments.");        optionParser.printHelpOn(err);        err.println("   A dash '-' for input-file means stdin.");        return 1;    }    Schema schema;    String inputFile;    if (schemaFile == null) {        schema = new Schema.Parser().parse(nargs.get(0));        inputFile = nargs.get(1);    } else {        schema = Util.parseSchemaFromFS(schemaFile);        inputFile = nargs.get(0);    }    InputStream input = Util.fileOrStdin(inputFile, stdin);    try {        GenericDatumReader<Object> reader = new GenericDatumReader<>(schema);        JsonDecoder jsonDecoder = DecoderFactory.get().jsonDecoder(schema, input);        GenericDatumWriter<Object> writer = new GenericDatumWriter<>(schema);        Encoder e = EncoderFactory.get().binaryEncoder(out, null);        Object datum = null;        while (true) {            try {                datum = reader.read(datum, jsonDecoder);            } catch (EOFException eofException) {                break;            }            writer.write(datum, e);            e.flush();        }    } finally {        Util.close(input);    }    return 0;}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return "jsontofrag";}
697b8c126f1dba9dc13e0aa8a508f6a069de73be37ecc29598629fdfebb0f39d
getShortDescription
public String getShortDescription()
{    return "Renders a JSON-encoded Avro datum as binary.";}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    int rc = new Main().run(args);    System.exit(rc);}
82ee87b994f34535354f89046e2224927ebbf89dea9116c9561b3d42a9979e0d
run
private int run(String[] args) throws Exception
{    if (args.length != 0) {        Tool tool = tools.get(args[0]);        if (tool != null) {            return tool.run(System.in, System.out, System.err, Arrays.asList(args).subList(1, args.length));        }    }    System.err.print("Version ");    try (InputStream versionInput = Main.class.getClassLoader().getResourceAsStream("VERSION.txt")) {        printStream(versionInput);    }    System.err.print(" of ");    try (InputStream noticeInput = Main.class.getClassLoader().getResourceAsStream("META-INF/NOTICE")) {        printHead(noticeInput, 5);    }    System.err.println("----------------");    System.err.println("Available tools:");    for (Tool k : tools.values()) {        System.err.printf("%" + maxLen + "s  %s\n", k.getName(), k.getShortDescription());    }    return 1;}
6435740baa17b2e57b35055c843c254797edaafeb9b1aa54bce960c45dcd6c36
printStream
private static void printStream(InputStream in) throws Exception
{    byte[] buffer = new byte[1024];    for (int i = in.read(buffer); i != -1; i = in.read(buffer)) System.err.write(buffer, 0, i);}
053a22bfe44cc1b24fe89269a78887cb8ea3e111629a48ed060b807f3ddcba85
printHead
private static void printHead(InputStream in, int lines) throws Exception
{    BufferedReader r = new BufferedReader(new InputStreamReader(in));    for (int i = 0; i < lines; i++) {        String line = r.readLine();        if (line == null) {            break;        }        System.err.println(line);    }}
c8c1a14c5a067f2819ebddd0c61a45b8be5e4e207a9f0213a7a973bb25042c5f
run
public int run(InputStream in, PrintStream out, PrintStream err, List<String> args) throws Exception
{    OptionParser optParser = new OptionParser();    OptionSpec<String> codecOpt = Util.compressionCodecOptionWithDefault(optParser, DataFileConstants.NULL_CODEC);    OptionSpec<Integer> levelOpt = Util.compressionLevelOption(optParser);    OptionSet opts = optParser.parse(args.toArray(new String[0]));    List<String> nargs = (List<String>) opts.nonOptionArguments();    if (nargs.size() > 2) {        err.println("Expected at most an input file and output file.");        optParser.printHelpOn(err);        return 1;    }    InputStream input = in;    boolean inputNeedsClosing = false;    if (nargs.size() > 0 && !nargs.get(0).equals("-")) {        input = Util.openFromFS(nargs.get(0));        inputNeedsClosing = true;    }    OutputStream output = out;    boolean outputNeedsClosing = false;    if (nargs.size() > 1 && !nargs.get(1).equals("-")) {        output = Util.createFromFS(nargs.get(1));        outputNeedsClosing = true;    }    DataFileStream<GenericRecord> reader = new DataFileStream<>(input, new GenericDatumReader<>());    Schema schema = reader.getSchema();    DataFileWriter<GenericRecord> writer = new DataFileWriter<>(new GenericDatumWriter<>());        CodecFactory codec = Util.codecFactory(opts, codecOpt, levelOpt, DataFileConstants.NULL_CODEC);    writer.setCodec(codec);    for (String key : reader.getMetaKeys()) {        if (!DataFileWriter.isReservedMeta(key)) {            writer.setMeta(key, reader.getMeta(key));        }    }    writer.create(schema, output);    writer.appendAllFrom(reader, true);    writer.flush();    if (inputNeedsClosing) {        input.close();    }    if (outputNeedsClosing) {        output.close();    }    return 0;}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return "recodec";}
697b8c126f1dba9dc13e0aa8a508f6a069de73be37ecc29598629fdfebb0f39d
getShortDescription
public String getShortDescription()
{    return "Alters the codec of a data file.";}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return "rpcprotocol";}
697b8c126f1dba9dc13e0aa8a508f6a069de73be37ecc29598629fdfebb0f39d
getShortDescription
public String getShortDescription()
{    return "Output the protocol of a RPC service";}
c8c1a14c5a067f2819ebddd0c61a45b8be5e4e207a9f0213a7a973bb25042c5f
run
public int run(InputStream in, PrintStream out, PrintStream err, List<String> args) throws Exception
{    if (args.size() != 1) {        err.println("Usage: uri");        return 1;    }    URI uri = URI.create(args.get(0));    try (Transceiver transceiver = Ipc.createTransceiver(uri)) {                HandshakeRequest rq = HandshakeRequest.newBuilder().setClientHash(new MD5(new byte[16])).setServerHash(new MD5(new byte[16])).setClientProtocol(null).setMeta(new LinkedHashMap<>()).build();        DatumWriter<HandshakeRequest> handshakeWriter = new SpecificDatumWriter<>(HandshakeRequest.class);        ByteBufferOutputStream byteBufferOutputStream = new ByteBufferOutputStream();        BinaryEncoder encoder = EncoderFactory.get().binaryEncoder(byteBufferOutputStream, null);        handshakeWriter.write(rq, encoder);        encoder.flush();                List<ByteBuffer> response = transceiver.transceive(byteBufferOutputStream.getBufferList());                ByteBufferInputStream byteBufferInputStream = new ByteBufferInputStream(response);        DatumReader<HandshakeResponse> handshakeReader = new SpecificDatumReader<>(HandshakeResponse.class);        HandshakeResponse handshakeResponse = handshakeReader.read(null, DecoderFactory.get().binaryDecoder(byteBufferInputStream, null));        Protocol p = Protocol.parse(handshakeResponse.getServerProtocol());                out.println(p.toString(true));    }    return 0;}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return "rpcreceive";}
697b8c126f1dba9dc13e0aa8a508f6a069de73be37ecc29598629fdfebb0f39d
getShortDescription
public String getShortDescription()
{    return "Opens an RPC Server and listens for one message.";}
29d68ea2271f298d01258b511c540f1756974c3e264f466c06a5e849f796bce4
respond
public Object respond(Message message, Object request) throws AvroRemoteException
{    if (!message.equals(expectedMessage)) {        out.println(String.format("Expected message '%s' but received '%s'.", expectedMessage.getName(), message.getName()));        latch.countDown();        throw new IllegalArgumentException("Unexpected message.");    }    out.print(message.getName());    out.print("\t");    try {        JsonEncoder jsonEncoder = EncoderFactory.get().jsonEncoder(message.getRequest(), out);        GenericDatumWriter<Object> writer = new GenericDatumWriter<>(message.getRequest());        writer.write(request, jsonEncoder);        jsonEncoder.flush();        out.flush();    } catch (IOException e) {        throw new RuntimeException(e);    }    out.println();    new Thread(() -> {        try {            Thread.sleep(1000);        } catch (InterruptedException e) {        }        latch.countDown();    }).start();    return response;}
c8c1a14c5a067f2819ebddd0c61a45b8be5e4e207a9f0213a7a973bb25042c5f
run
public int run(InputStream in, PrintStream out, PrintStream err, List<String> args) throws Exception
{        int r = run1(in, out, err, args);    if (r != 0) {        return r;    }    return run2(err);}
df147c066fb40fdd43971be8f9897591878c0facd3e5cf873a7fabff4b793d43
run1
 int run1(InputStream in, PrintStream out, PrintStream err, List<String> args) throws Exception
{    OptionParser p = new OptionParser();    OptionSpec<String> file = p.accepts("file", "Data file containing response datum.").withRequiredArg().ofType(String.class);    OptionSpec<String> data = p.accepts("data", "JSON-encoded response datum.").withRequiredArg().ofType(String.class);    OptionSet opts = p.parse(args.toArray(new String[0]));    args = (List<String>) opts.nonOptionArguments();    if (args.size() != 3) {        err.println("Usage: uri protocol_file message_name (-data d | -file f)");        p.printHelpOn(err);        return 1;    }    URI uri = new URI(args.get(0));    Protocol protocol = Protocol.parse(new File(args.get(1)));    String messageName = args.get(2);    expectedMessage = protocol.getMessages().get(messageName);    if (expectedMessage == null) {        err.println(String.format("No message named '%s' found in protocol '%s'.", messageName, protocol));        return 1;    }    if (data.value(opts) != null) {        this.response = Util.jsonToGenericDatum(expectedMessage.getResponse(), data.value(opts));    } else if (file.value(opts) != null) {        this.response = Util.datumFromFile(expectedMessage.getResponse(), file.value(opts));    } else {        err.println("One of -data or -file must be specified.");        return 1;    }    this.out = out;    latch = new CountDownLatch(1);    server = Ipc.createServer(new SinkResponder(protocol), uri);    server.start();    out.println("Port: " + server.getPort());    return 0;}
64dd6bd4bd250a3353788a29cbfce6875ec5719b383fb68a3e915df3a792c587
run2
 int run2(PrintStream err) throws InterruptedException
{    latch.await();    err.println("Closing server.");    server.close();    return 0;}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return "rpcsend";}
697b8c126f1dba9dc13e0aa8a508f6a069de73be37ecc29598629fdfebb0f39d
getShortDescription
public String getShortDescription()
{    return "Sends a single RPC message.";}
c8c1a14c5a067f2819ebddd0c61a45b8be5e4e207a9f0213a7a973bb25042c5f
run
public int run(InputStream in, PrintStream out, PrintStream err, List<String> args) throws Exception
{    OptionParser p = new OptionParser();    OptionSpec<String> file = p.accepts("file", "Data file containing request parameters.").withRequiredArg().ofType(String.class);    OptionSpec<String> data = p.accepts("data", "JSON-encoded request parameters.").withRequiredArg().ofType(String.class);    OptionSet opts = p.parse(args.toArray(new String[0]));    args = (List<String>) opts.nonOptionArguments();    if (args.size() != 3) {        err.println("Usage: uri protocol_file message_name (-data d | -file f)");        p.printHelpOn(err);        return 1;    }    URI uri = new URI(args.get(0));    Protocol protocol = Protocol.parse(new File(args.get(1)));    String messageName = args.get(2);    Message message = protocol.getMessages().get(messageName);    if (message == null) {        err.println(String.format("No message named '%s' found in protocol '%s'.", messageName, protocol));        return 1;    }    Object datum;    if (data.value(opts) != null) {        datum = Util.jsonToGenericDatum(message.getRequest(), data.value(opts));    } else if (file.value(opts) != null) {        datum = Util.datumFromFile(message.getRequest(), file.value(opts));    } else {        err.println("One of -data or -file must be specified.");        return 1;    }    GenericRequestor client = new GenericRequestor(protocol, Ipc.createTransceiver(uri));    Object response = client.request(message.getName(), datum);    dumpJson(out, message.getResponse(), response);    return 0;}
1b1972e018100bfd534c61587cafe5cc4dcc733e93fd4e5eec7e5fdc9e099f42
dumpJson
private void dumpJson(PrintStream out, Schema schema, Object datum) throws IOException
{    DatumWriter<Object> writer = new GenericDatumWriter<>(schema);    JsonEncoder jsonEncoder = EncoderFactory.get().jsonEncoder(schema, out, true);    writer.write(datum, jsonEncoder);    jsonEncoder.flush();    out.println();    out.flush();}
c8c1a14c5a067f2819ebddd0c61a45b8be5e4e207a9f0213a7a973bb25042c5f
run
public int run(InputStream in, PrintStream out, PrintStream err, List<String> args) throws Exception
{    final OptionParser optParser = new OptionParser();    final OptionSpec<String> fingerprintOpt = optParser.accepts("fingerprint", "Fingerprint algorithm to use. Recommended Avro practice dictiates " + "that \"CRC-64-AVRO\" is used for 64-bit fingerprints, \"MD5\" is " + "used for 128-bit fingerprints, and \"SHA-256\" is used for 256-bit " + "fingerprints.").withRequiredArg().ofType(String.class).defaultsTo("CRC-64-AVRO");    final OptionSet opts = optParser.parse(args.toArray(new String[0]));    final Schema.Parser parser = new Schema.Parser();    final List<String> nargs = (List<String>) opts.nonOptionArguments();    if (nargs.size() < 1) {        printHelp(out, optParser);        return 0;    }    for (final String fileOrStdin : (List<String>) opts.nonOptionArguments()) {        final InputStream input = Util.fileOrStdin(fileOrStdin, in);        try {            final Schema schema = parser.parse(input);            final byte[] fingerprint = SchemaNormalization.parsingFingerprint(opts.valueOf(fingerprintOpt), schema);            out.format("%s %s%n", Util.encodeHex(fingerprint), fileOrStdin);        } finally {            Util.close(input);        }    }    return 0;}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return "fingerprint";}
697b8c126f1dba9dc13e0aa8a508f6a069de73be37ecc29598629fdfebb0f39d
getShortDescription
public String getShortDescription()
{    return "Returns the fingerprint for the schemas.";}
d091633ffc8f9346391aebfc562e2d6ff8bc94a9bda2747fa98df5224884fa88
printHelp
private void printHelp(PrintStream out, OptionParser optParser) throws IOException
{    out.println("fingerprint [--fingerprint <fingerprint>] input-file [inputfile [inputfile...]]");    out.println();    out.println("generates fingerprints based on Avro specification.");    optParser.printHelpOn(out);    out.println("A dash ('-') can be given to read a schema from stdin");}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return "canonical";}
697b8c126f1dba9dc13e0aa8a508f6a069de73be37ecc29598629fdfebb0f39d
getShortDescription
public String getShortDescription()
{    return "Converts an Avro Schema to its canonical form";}
d54ad0f80aeed89e9897bc75c15950f5cdd7597d8e692267ec3a4d192474a585
run
public int run(InputStream stdin, PrintStream out, PrintStream err, List<String> args) throws Exception
{    OptionParser p = new OptionParser();    OptionSet opts = p.parse(args.toArray(new String[0]));    if (opts.nonOptionArguments().size() != 2) {        err.println("Expected 2 args: infile outfile (filenames or '-' for stdin/stdout)");        p.printHelpOn(err);        return 1;    }    BufferedInputStream inStream = Util.fileOrStdin(args.get(0), stdin);    BufferedOutputStream outStream = Util.fileOrStdout(args.get(1), out);    Schema schema = new Schema.Parser().parse(inStream);    String canonicalForm = SchemaNormalization.toParsingForm(schema);    outStream.write(canonicalForm.getBytes(StandardCharsets.UTF_8));    Util.close(inStream);    Util.close(outStream);    return 0;}
c8c1a14c5a067f2819ebddd0c61a45b8be5e4e207a9f0213a7a973bb25042c5f
run
public int run(InputStream in, PrintStream out, PrintStream err, List<String> args) throws Exception
{    if (args.size() < 3) {        System.err.println("Usage: [-encoding <outputencoding>] [-string] [-bigDecimal] [-templateDir <templateDir>] (schema|protocol) input... outputdir");        System.err.println(" input - input files or directories");        System.err.println(" outputdir - directory to write generated java");        System.err.println(" -encoding <outputencoding> - set the encoding of " + "output file(s)");        System.err.println(" -string - use java.lang.String instead of Utf8");        System.err.println(" -bigDecimal - use java.math.BigDecimal for " + "decimal type instead of java.nio.ByteBuffer");        System.err.println(" -templateDir - directory with custom Velocity templates");        return 1;    }    StringType stringType = StringType.CharSequence;    boolean useLogicalDecimal = false;    Optional<String> encoding = Optional.empty();    Optional<String> templateDir = Optional.empty();    int arg = 0;    if ("-encoding".equals(args.get(arg))) {        arg++;        encoding = Optional.of(args.get(arg));        arg++;    }    if ("-string".equals(args.get(arg))) {        stringType = StringType.String;        arg++;    }    if ("-bigDecimal".equalsIgnoreCase(args.get(arg))) {        useLogicalDecimal = true;        arg++;    }    if ("-templateDir".equals(args.get(arg))) {        arg++;        templateDir = Optional.of(args.get(arg));        arg++;    }    String method = args.get(arg);    List<File> inputs = new ArrayList<>();    File output = new File(args.get(args.size() - 1));    for (int i = arg + 1; i < args.size() - 1; i++) {        inputs.add(new File(args.get(i)));    }    if ("schema".equals(method)) {        Schema.Parser parser = new Schema.Parser();        for (File src : determineInputs(inputs, SCHEMA_FILTER)) {            Schema schema = parser.parse(src);            final SpecificCompiler compiler = new SpecificCompiler(schema);            executeCompiler(compiler, encoding, stringType, useLogicalDecimal, templateDir, src, output);        }    } else if ("protocol".equals(method)) {        for (File src : determineInputs(inputs, PROTOCOL_FILTER)) {            Protocol protocol = Protocol.parse(src);            final SpecificCompiler compiler = new SpecificCompiler(protocol);            executeCompiler(compiler, encoding, stringType, useLogicalDecimal, templateDir, src, output);        }    } else {        System.err.println("Expected \"schema\" or \"protocol\".");        return 1;    }    return 0;}
11373cb81e2b963147681f663082fcd6ea51ca8e14f7d9e3c371e4d0d27f95ec
executeCompiler
private void executeCompiler(SpecificCompiler compiler, Optional<String> encoding, StringType stringType, boolean enableDecimalLogicalType, Optional<String> templateDir, File src, File output) throws IOException
{    compiler.setStringType(stringType);    templateDir.ifPresent(compiler::setTemplateDir);    compiler.setEnableDecimalLogicalType(enableDecimalLogicalType);    encoding.ifPresent(compiler::setOutputCharacterEncoding);    compiler.compileToDestination(src, output);}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return "compile";}
697b8c126f1dba9dc13e0aa8a508f6a069de73be37ecc29598629fdfebb0f39d
getShortDescription
public String getShortDescription()
{    return "Generates Java code for the given schema.";}
893e182995e8ee05cf6981db3238e213bc4213faf41e0c1ce68c676bb59c2e28
determineInputs
private static File[] determineInputs(List<File> inputs, FilenameFilter filter)
{        Set<File> fileSet = new LinkedHashSet<>();    for (File file : inputs) {                if (file.isDirectory()) {            File[] files = file.listFiles(filter);            Collections.addAll(fileSet, files != null ? files : new File[0]);        } else         {            fileSet.add(file);        }    }    if (fileSet.size() > 0) {        System.err.println("Input files to compile:");        for (File file : fileSet) {            System.err.println("  " + file);        }    } else {        System.err.println("No input files found.");    }    return fileSet.toArray(new File[0]);}
ca62bfdc0472b2de6468644412d9ad6b432937742edcb5ca65b1f23b694b5853
accept
public boolean accept(File dir, String name)
{    return name.endsWith(this.extension);}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return "tether";}
697b8c126f1dba9dc13e0aa8a508f6a069de73be37ecc29598629fdfebb0f39d
getShortDescription
public String getShortDescription()
{    return "Run a tethered mapreduce job.";}
de3733849f916d69a12bba13d9c7aebd9ea8b910941720b5ff0acc5ae9fa3411
run
public int run(InputStream ins, PrintStream outs, PrintStream err, List<String> args) throws Exception
{    String[] argarry = args.toArray(new String[0]);    Options opts = new Options();    Option helpopt = OptionBuilder.hasArg(false).withDescription("print this message").create("help");    Option inopt = OptionBuilder.hasArg().isRequired().withDescription("comma-separated input paths").create("in");    Option outopt = OptionBuilder.hasArg().isRequired().withDescription("The output path.").create("out");    Option pargs = OptionBuilder.hasArg().withDescription("A string containing the command line arguments to pass to the tethered process. String should be enclosed in quotes").create("exec_args");    Option popt = OptionBuilder.hasArg().isRequired().withDescription("executable program, usually in HDFS").create("program");    Option outscopt = OptionBuilder.withType(File.class).hasArg().isRequired().withDescription("schema file for output of reducer").create("outschema");    Option outscmapopt = OptionBuilder.withType(File.class).hasArg().withDescription("(optional) map output schema file,  if different from outschema").create("outschemamap");    Option redopt = OptionBuilder.withType(Integer.class).hasArg().withDescription("(optional) number of reducers").create("reduces");    Option cacheopt = OptionBuilder.withType(Boolean.class).hasArg().withDescription("(optional) boolean indicating whether or not the exectuable should be distributed via distributed cache").create("exec_cached");    Option protoopt = OptionBuilder.hasArg().withDescription("(optional) specifies the transport protocol 'http' or 'sasl'").create("protocol");    opts.addOption(redopt);    opts.addOption(outscopt);    opts.addOption(popt);    opts.addOption(pargs);    opts.addOption(inopt);    opts.addOption(outopt);    opts.addOption(helpopt);    opts.addOption(outscmapopt);    opts.addOption(cacheopt);    opts.addOption(protoopt);    CommandLineParser parser = new GnuParser();    String[] genargs = null;    CommandLine line = null;    HelpFormatter formatter = new HelpFormatter();    JobConf job = new JobConf();    try {        line = parser.parse(opts, argarry);        if (line.hasOption("help")) {            formatter.printHelp("tether", opts);            return 0;        }        genargs = line.getArgs();        FileInputFormat.addInputPaths(job, line.getOptionValue("in"));        FileOutputFormat.setOutputPath(job, new Path(line.getOptionValue("out")));        List<String> exargs = null;        Boolean cached = false;        if (line.hasOption("exec_args")) {            String[] splitargs = line.getOptionValue("exec_args").split(" ");            exargs = new ArrayList<>(Arrays.asList(splitargs));        }        if (line.hasOption("exec_cached")) {            cached = Boolean.parseBoolean(line.getOptionValue("exec_cached"));        }        TetherJob.setExecutable(job, new File(line.getOptionValue("program")), exargs, cached);        File outschema = (File) line.getParsedOptionValue("outschema");        job.set(AvroJob.OUTPUT_SCHEMA, Schema.parse(outschema).toString());        if (line.hasOption("outschemamap")) {            job.set(AvroJob.MAP_OUTPUT_SCHEMA, new Schema.Parser().parse((File) line.getParsedOptionValue("outschemamap")).toString());        }        if (line.hasOption("reduces")) {            job.setNumReduceTasks((Integer) line.getParsedOptionValue("reduces"));        }        if (line.hasOption("protocol")) {            TetherJob.setProtocol(job, line.getOptionValue("protocol"));        }    } catch (Exception exp) {        System.out.println("Unexpected exception: " + exp.getMessage());        formatter.printHelp("tether", opts);        return -1;    }    TetherJob.runJob(job);    return 0;}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return "totext";}
697b8c126f1dba9dc13e0aa8a508f6a069de73be37ecc29598629fdfebb0f39d
getShortDescription
public String getShortDescription()
{    return "Converts an Avro data file to a text file.";}
d54ad0f80aeed89e9897bc75c15950f5cdd7597d8e692267ec3a4d192474a585
run
public int run(InputStream stdin, PrintStream out, PrintStream err, List<String> args) throws Exception
{    OptionParser p = new OptionParser();    OptionSet opts = p.parse(args.toArray(new String[0]));    if (opts.nonOptionArguments().size() != 2) {        err.println("Expected 2 args: from_file to_file (filenames or '-' for stdin/stdout");        p.printHelpOn(err);        return 1;    }    BufferedInputStream inStream = Util.fileOrStdin(args.get(0), stdin);    BufferedOutputStream outStream = Util.fileOrStdout(args.get(1), out);    GenericDatumReader<Object> reader = new GenericDatumReader<>();    DataFileStream<Object> fileReader = new DataFileStream<>(inStream, reader);    if (!fileReader.getSchema().equals(new Schema.Parser().parse(TEXT_FILE_SCHEMA))) {        err.println("Avro file is not generic text schema");        p.printHelpOn(err);        fileReader.close();        return 1;    }    while (fileReader.hasNext()) {        ByteBuffer outBuff = (ByteBuffer) fileReader.next();        outStream.write(outBuff.array());        outStream.write(LINE_SEPARATOR);    }    fileReader.close();    Util.close(inStream);    Util.close(outStream);    return 0;}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return "totrevni";}
697b8c126f1dba9dc13e0aa8a508f6a069de73be37ecc29598629fdfebb0f39d
getShortDescription
public String getShortDescription()
{    return "Converts an Avro data file to a Trevni file.";}
d54ad0f80aeed89e9897bc75c15950f5cdd7597d8e692267ec3a4d192474a585
run
public int run(InputStream stdin, PrintStream out, PrintStream err, List<String> args) throws Exception
{    OptionParser p = new OptionParser();    OptionSpec<String> codec = p.accepts("codec", "Compression codec").withRequiredArg().defaultsTo("null").ofType(String.class);    OptionSet opts = p.parse(args.toArray(new String[0]));    if (opts.nonOptionArguments().size() != 2) {        err.println("Usage: inFile outFile (filenames or '-' for stdin/stdout)");        p.printHelpOn(err);        return 1;    }    args = (List<String>) opts.nonOptionArguments();    DataFileStream<Object> reader = new DataFileStream(Util.fileOrStdin(args.get(0), stdin), new GenericDatumReader<>());    OutputStream outs = Util.fileOrStdout(args.get(1), out);    AvroColumnWriter<Object> writer = new AvroColumnWriter<>(reader.getSchema(), new ColumnFileMetaData().setCodec(codec.value(opts)));    for (Object datum : reader) writer.write(datum);    writer.writeTo(outs);    outs.close();    reader.close();    return 0;}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return "trevni_random";}
697b8c126f1dba9dc13e0aa8a508f6a069de73be37ecc29598629fdfebb0f39d
getShortDescription
public String getShortDescription()
{    return "Create a Trevni file filled with random instances of a schema.";}
d54ad0f80aeed89e9897bc75c15950f5cdd7597d8e692267ec3a4d192474a585
run
public int run(InputStream stdin, PrintStream out, PrintStream err, List<String> args) throws Exception
{    if (args.size() != 3) {        err.println("Usage: schemaFile count outputFile");        return 1;    }    File schemaFile = new File(args.get(0));    int count = Integer.parseInt(args.get(1));    File outputFile = new File(args.get(2));    Schema schema = new Schema.Parser().parse(schemaFile);    AvroColumnWriter<Object> writer = new AvroColumnWriter<>(schema, new ColumnFileMetaData());    for (Object datum : new RandomData(schema, count)) writer.write(datum);    writer.writeTo(outputFile);    return 0;}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return "trevni_meta";}
697b8c126f1dba9dc13e0aa8a508f6a069de73be37ecc29598629fdfebb0f39d
getShortDescription
public String getShortDescription()
{    return "Dumps a Trevni file's metadata as JSON.";}
d54ad0f80aeed89e9897bc75c15950f5cdd7597d8e692267ec3a4d192474a585
run
public int run(InputStream stdin, PrintStream out, PrintStream err, List<String> args) throws Exception
{    String filename;    boolean pretty = false;    if (args.size() == 2 && "-pretty".equals(args.get(0))) {        pretty = true;        filename = args.get(1);    } else if (args.size() == 1) {        filename = args.get(0);    } else {        err.println("Usage: [-pretty] input");        return 1;    }    dump(TrevniUtil.input(filename), out, pretty);    return 0;}
d1019bec61fbfc3d03f637d7a6bab08c55d1cee4986fc3ede2c022f5f2c3f607
dump
public void dump(Input input, PrintStream out, boolean pretty) throws IOException
{    this.generator = FACTORY.createGenerator(out, JsonEncoding.UTF8);    if (pretty) {        generator.useDefaultPrettyPrinter();    } else {                MinimalPrettyPrinter pp = new MinimalPrettyPrinter();        pp.setRootValueSeparator(System.getProperty("line.separator"));        generator.setPrettyPrinter(pp);    }    ColumnFileReader reader = new ColumnFileReader(input);    generator.writeStartObject();    generator.writeNumberField("rowCount", reader.getRowCount());    generator.writeNumberField("columnCount", reader.getColumnCount());    generator.writeFieldName("metadata");    dump(reader.getMetaData());    generator.writeFieldName("columns");    generator.writeStartArray();    for (ColumnMetaData c : reader.getColumnMetaData()) dump(c);    generator.writeEndArray();    generator.writeEndObject();    generator.flush();    out.println();    reader.close();}
662bb269c911f6a128c61922465c4d45655b5f3201fc1338674a082264304cb4
dump
private void dump(MetaData<?> meta) throws IOException
{    generator.writeStartObject();    for (Map.Entry<String, byte[]> e : meta.entrySet()) generator.writeStringField(e.getKey(), new String(e.getValue(), StandardCharsets.ISO_8859_1));    generator.writeEndObject();}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return "trevni_tojson";}
697b8c126f1dba9dc13e0aa8a508f6a069de73be37ecc29598629fdfebb0f39d
getShortDescription
public String getShortDescription()
{    return "Dumps a Trevni file as JSON.";}
d54ad0f80aeed89e9897bc75c15950f5cdd7597d8e692267ec3a4d192474a585
run
public int run(InputStream stdin, PrintStream out, PrintStream err, List<String> args) throws Exception
{    String filename;    boolean pretty = false;    if (args.size() == 2 && "-pretty".equals(args.get(0))) {        pretty = true;        filename = args.get(1);    } else if (args.size() == 1) {        filename = args.get(0);    } else {        err.println("Usage: [-pretty] input");        return 1;    }    toJson(TrevniUtil.input(filename), out, pretty);    return 0;}
6eed8db00ce384b14ac37d3793e01836ac1cac3c8612fda634c5f393a08112bb
toJson
public void toJson(Input input, PrintStream out, boolean pretty) throws IOException
{    this.generator = FACTORY.createGenerator(out, JsonEncoding.UTF8);    if (pretty) {        generator.useDefaultPrettyPrinter();    } else {                MinimalPrettyPrinter pp = new MinimalPrettyPrinter();        pp.setRootValueSeparator(System.getProperty("line.separator"));        generator.setPrettyPrinter(pp);    }    ColumnFileReader reader = new ColumnFileReader(input);    int columnCount = (int) reader.getColumnCount();    this.values = new ColumnValues[columnCount];    this.shortNames = new String[columnCount];    for (int i = 0; i < columnCount; i++) {        values[i] = reader.getValues(i);        shortNames[i] = shortName(reader.getColumnMetaData(i));    }    List<ColumnMetaData> roots = reader.getRoots();    for (long row = 0; row < reader.getRowCount(); row++) {        for (ColumnValues v : values) v.startRow();        generator.writeStartObject();        for (ColumnMetaData root : roots) valueToJson(root);        generator.writeEndObject();    }    generator.flush();    out.println();    reader.close();}
aa93d0535411c2442967e12c64bba2c9084ea4a022df557d694f722b496861e9
valueToJson
private void valueToJson(ColumnMetaData column) throws IOException
{    generator.writeFieldName(shortNames[column.getNumber()]);    ColumnValues in = values[column.getNumber()];    if (!column.isArray()) {        primitiveToJson(column, in.nextValue());    } else {        generator.writeStartArray();        int length = in.nextLength();        for (int i = 0; i < length; i++) {            Object value = in.nextValue();            List<ColumnMetaData> children = column.getChildren();            if (children.size() == 0) {                primitiveToJson(column, value);            } else {                generator.writeStartObject();                if (value != null) {                    generator.writeFieldName("value$");                    primitiveToJson(column, value);                }                for (ColumnMetaData child : children) valueToJson(child);                generator.writeEndObject();            }        }        generator.writeEndArray();    }}
df870c2f497818f713286526ce65235ab0f06568c78d46f1b0080f8958827084
primitiveToJson
private void primitiveToJson(ColumnMetaData column, Object value) throws IOException
{    switch(column.getType()) {        case NULL:            generator.writeNull();            break;        case BOOLEAN:            generator.writeBoolean((Boolean) value);            break;        case INT:            generator.writeNumber((Integer) value);            break;        case LONG:            generator.writeNumber((Long) value);            break;        case FIXED32:            generator.writeNumber((Integer) value);            break;        case FIXED64:            generator.writeNumber((Long) value);            break;        case FLOAT:            generator.writeNumber((Float) value);            break;        case DOUBLE:            generator.writeNumber((Double) value);            break;        case STRING:            generator.writeString((String) value);            break;        case BYTES:            generator.writeBinary((byte[]) value);            break;        default:            throw new RuntimeException("Unknown value type: " + column.getType());    }}
33f54e77d482d24f78246a2de6c4786cb24d14a273a3986baf43e5ceddd799b4
shortName
private String shortName(ColumnMetaData column)
{    String name = column.getName();    ColumnMetaData parent = column.getParent();    if (parent != null && name.startsWith(parent.getName()))        name = name.substring(parent.getName().length());    if (!Character.isLetterOrDigit(name.charAt(0)))        name = name.substring(1);    return name;}
1a468b111e980e739c45bfd734aad2cfcb537e87be7eaaff3f494a55fb42f393
input
 static Input input(String filename) throws IOException
{    if (filename.startsWith("hdfs://")) {        return new HadoopInput(new Path(filename), new Configuration());    } else {        return new InputFile(new File(filename));    }}
a6db1cc177420b2261902af69de2986a902eafcc2e2d45ae251b70af2e1c8d07
input
 static InputStream input(String filename, InputStream stdin) throws IOException
{    if (filename.equals("-"))        return new BufferedInputStream(stdin);    else if (filename.startsWith("hdfs://")) {        FileSystem fs = FileSystem.get(URI.create(filename), new Configuration());        return new BufferedInputStream(fs.open(new Path(filename)));    } else {        return new BufferedInputStream(new FileInputStream(new File(filename)));    }}
bb9a282dfe047d020f482ecbccb1089844ed63664ad22cfc4afb0654f189c61f
output
 static OutputStream output(String filename, OutputStream stdout) throws IOException
{    if (filename.equals("-"))        return new BufferedOutputStream(stdout);    else if (filename.startsWith("hdfs://")) {        FileSystem fs = FileSystem.get(URI.create(filename), new Configuration());        return new BufferedOutputStream(fs.create(new Path(filename)));    } else {        return new BufferedOutputStream(new FileOutputStream(new File(filename)));    }}
bb4d89d93b82f67628163915252841dc1926244449fb3ee637bbc08a34332771
fileOrStdin
 static BufferedInputStream fileOrStdin(String filename, InputStream stdin) throws IOException
{    return new BufferedInputStream(filename.equals("-") ? stdin : openFromFS(filename));}
512d59a9df13ba2b6f4bdb31ccaf06b73d965e84a6f305e49057bf1233c4f9f2
fileOrStdout
 static BufferedOutputStream fileOrStdout(String filename, OutputStream stdout) throws IOException
{    return new BufferedOutputStream(filename.equals("-") ? stdout : createFromFS(filename));}
cc3d1296e02345cbbe5a76769e5793fcff074b938f80354ddb0e5efd4f7d333f
openFromFS
 static InputStream openFromFS(String filename) throws IOException
{    Path p = new Path(filename);    return p.getFileSystem(new Configuration()).open(p);}
f769138a9b3f698bbebc034fc772259aa363d6dac58c2d93e4062d5613908533
openFromFS
 static InputStream openFromFS(Path filename) throws IOException
{    return filename.getFileSystem(new Configuration()).open(filename);}
392a76026b0be082cdd336e77212e2f9477f7a678adff1b8e513cbfcc677c5ab
openSeekableFromFS
 static FsInput openSeekableFromFS(String filename) throws IOException
{    return new FsInput(new Path(filename), new Configuration());}
bef76cf3a4cd86cb221691c3fd42f98cf940453432a123160314c0798b14d7c6
createFromFS
 static OutputStream createFromFS(String filename) throws IOException
{    Path p = new Path(filename);    return new BufferedOutputStream(p.getFileSystem(new Configuration()).create(p));}
d33acef49728a63cc1b63ff4befb67aafa2478acde573b167b50c5a00d9734d9
close
 static void close(InputStream in)
{    if (!System.in.equals(in)) {        try {            in.close();        } catch (IOException e) {            System.err.println("could not close InputStream " + in.toString());        }    }}
61ac875871cf47998622f977bd091b86b8f44361d2fd28b27cccb3d36dfd9e33
close
 static void close(OutputStream out)
{    if (!System.out.equals(out)) {        try {            out.close();        } catch (IOException e) {            System.err.println("could not close OutputStream " + out.toString());        }    }}
1e01e642ee1bb1c0c2f32131722f332e5caecfd3c2e6b0dc6cea9e55f91d2b90
parseSchemaFromFS
 static Schema parseSchemaFromFS(String filename) throws IOException
{    InputStream stream = openFromFS(filename);    try {        return new Schema.Parser().parse(stream);    } finally {        close(stream);    }}
e66e28a86fb39bac820c48d19ebda1e3324b1ff682ac15b6c491a76dadea8686
getFiles
 static List<Path> getFiles(String fileOrDirName) throws IOException
{    List<Path> pathList = new ArrayList<>();    Path path = new Path(fileOrDirName);    FileSystem fs = path.getFileSystem(new Configuration());    if (fs.isFile(path)) {        pathList.add(path);    } else if (fs.isDirectory(path)) {        for (FileStatus status : fs.listStatus(path)) {            if (!status.isDirectory()) {                pathList.add(status.getPath());            }        }    } else {        FileStatus[] fileStatuses = fs.globStatus(path);        if (fileStatuses != null) {            for (FileStatus status : fileStatuses) {                pathList.add(status.getPath());            }        } else {            throw new FileNotFoundException(fileOrDirName);        }    }    Collections.sort(pathList);    return pathList;}
d1b9e245a04ea2a1827e37e8fa23cb824ed442e49433199e89fadd3e063d383d
getFiles
 static List<Path> getFiles(List<String> fileOrDirNames) throws IOException
{    ArrayList<Path> pathList = new ArrayList<>();    for (String name : fileOrDirNames) {        pathList.addAll(getFiles(name));    }    Collections.sort(pathList);    return pathList;}
2258546917e82c70a945c5dd1358745693fa1dd032a119567b4ed1b75b1e526c
jsonToGenericDatum
 static Object jsonToGenericDatum(Schema schema, String jsonData) throws IOException
{    GenericDatumReader<Object> reader = new GenericDatumReader<>(schema);    Object datum = reader.read(null, DecoderFactory.get().jsonDecoder(schema, jsonData));    return datum;}
721f2ce665c9dcd125832f57f8f6105e7eaa157ff6cd1dd24060c56d5161b87a
datumFromFile
 static Object datumFromFile(Schema schema, String file) throws IOException
{    try (DataFileReader<Object> in = new DataFileReader<>(new File(file), new GenericDatumReader<>(schema))) {        return in.next();    }}
2ce8b3530d0f65515d44ae1ad1515fd22cc5e0fa6ccf463cd25080fec9336005
compressionCodecOption
 static OptionSpec<String> compressionCodecOption(OptionParser optParser)
{    return optParser.accepts("codec", "Compression codec").withRequiredArg().ofType(String.class).defaultsTo(DEFLATE_CODEC);}
bb5424414bf8a1b2775f0bf292fdf4a7d5b7bfa4da915b382a4868d036f41e07
compressionCodecOptionWithDefault
 static OptionSpec<String> compressionCodecOptionWithDefault(OptionParser optParser, String s)
{    return optParser.accepts("codec", "Compression codec").withRequiredArg().ofType(String.class).defaultsTo(s);}
5a8488b520cda51ce9fa286e697ef838584cc6398c15d04112de82ed7c7ad372
compressionLevelOption
 static OptionSpec<Integer> compressionLevelOption(OptionParser optParser)
{    return optParser.accepts("level", "Compression level (only applies to deflate, xz, and zstandard)").withRequiredArg().ofType(Integer.class).defaultsTo(Deflater.DEFAULT_COMPRESSION);}
256191bc8cdf638030c0d29ff2e18d8af2866146600a8d809683b16d059a61ab
codecFactory
 static CodecFactory codecFactory(OptionSet opts, OptionSpec<String> codec, OptionSpec<Integer> level)
{    return codecFactory(opts, codec, level, DEFLATE_CODEC);}
bc9dd9355467e6d7643628b1b0fea2d8da469a0e8050e436d05bf59b2e4a0414
codecFactory
 static CodecFactory codecFactory(OptionSet opts, OptionSpec<String> codec, OptionSpec<Integer> level, String defaultCodec)
{    String codecName = opts.hasArgument(codec) ? codec.value(opts) : defaultCodec;    if (codecName.equals(DEFLATE_CODEC)) {        return CodecFactory.deflateCodec(level.value(opts));    } else if (codecName.equals(DataFileConstants.XZ_CODEC)) {        return CodecFactory.xzCodec(level.value(opts));    } else if (codecName.equals(DataFileConstants.ZSTANDARD_CODEC)) {        return CodecFactory.zstandardCodec(level.value(opts));    } else {        return CodecFactory.fromString(codec.value(opts));    }}
6e54cb3952e9269de5c203f0b5135e1198264caa4f166e6f0c461e7667222951
encodeHex
 static String encodeHex(final byte[] data)
{    final int l = data.length;    final char[] out = new char[l << 1];        for (int i = 0, j = 0; i < l; i++) {        out[j++] = DIGITS_LOWER[(0xF0 & data[i]) >>> 4];        out[j++] = DIGITS_LOWER[0x0F & data[i]];    }    return new String(out);}
64706bfcdc25a6308d11d702baacbf9dbac8176e7848be0e819da8d1859b6bdb
getClassSchema
public static org.apache.avro.Schema getClassSchema()
{    return SCHEMA$;}
145c013a8327b4816336d16a16d5cb42296ee71727f1f42118061bc89f221fa5
getEncoder
public static BinaryMessageEncoder<Player> getEncoder()
{    return ENCODER;}
4a0529a4ad5e7a0ee506bde25c365a727a76e51c50b9f058d83c47d0e9fece63
getDecoder
public static BinaryMessageDecoder<Player> getDecoder()
{    return DECODER;}
e4afbd8e4940cd14120eea14a95eecda193d0f9f9ba10df0ddd0fb01d395b6a9
createDecoder
public static BinaryMessageDecoder<Player> createDecoder(SchemaStore resolver)
{    return new BinaryMessageDecoder<Player>(MODEL$, SCHEMA$, resolver);}
473bffa2e264c9a7f493a4236175e1428e5d97836bf372b01eb5b1692afcd748
toByteBuffer
public java.nio.ByteBuffer toByteBuffer() throws java.io.IOException
{    return ENCODER.encode(this);}
09cdafaa9786329188b885113d14beaada23e9413f1ea3ea360679420fbd49f7
fromByteBuffer
public static Player fromByteBuffer(java.nio.ByteBuffer b) throws java.io.IOException
{    return DECODER.decode(b);}
6feb61aba3d894205e2329721d09e57258e340db02dc7dcd1f630fb34c61245b
getSpecificData
public org.apache.avro.specific.SpecificData getSpecificData()
{    return MODEL$;}
1fa124aa67dc73ccd01002de70d29d68ea9dacd5d97cf4663025da360e9c4749
getSchema
public org.apache.avro.Schema getSchema()
{    return SCHEMA$;}
233b384682c68bdb89ad70c35a2e59b7341b16a68e84517dc4f51d4ce5753ebf
get
public java.lang.Object get(int field$)
{    switch(field$) {        case 0:            return number;        case 1:            return first_name;        case 2:            return last_name;        case 3:            return position;        default:            throw new org.apache.avro.AvroRuntimeException("Bad index");    }}
f13ccb2ddd4dfda02b51ba2bf6b82a34d33026ae9bcb3de86f779f47722fb1ac
put
public void put(int field$, java.lang.Object value$)
{    switch(field$) {        case 0:            number = (java.lang.Integer) value$;            break;        case 1:            first_name = (java.lang.CharSequence) value$;            break;        case 2:            last_name = (java.lang.CharSequence) value$;            break;        case 3:            position = (java.util.List<avro.examples.baseball.Position>) value$;            break;        default:            throw new org.apache.avro.AvroRuntimeException("Bad index");    }}
1c13c8ecf23858866f0003ded43b76aae5d585b39d3b311bbbc0cda61980598d
getNumber
public int getNumber()
{    return number;}
378208bd87e9780ee8e8819e9d0aa06a07d0c741464334112647749805bf98b8
setNumber
public void setNumber(int value)
{    this.number = value;}
d575ea3f65e1eb86fd6d5f3864308fd0153881c5ca6c52a5ae823208df7299cd
getFirstName
public java.lang.CharSequence getFirstName()
{    return first_name;}
128f019e1afa1dafc66b8b53211c32a4d92486374bbbf9cf9d40c2b540c1ee8f
setFirstName
public void setFirstName(java.lang.CharSequence value)
{    this.first_name = value;}
3a7f0af4aa3743d291fb4a6fd59c1061063c72e94d6353e245a335e4f020cbaf
getLastName
public java.lang.CharSequence getLastName()
{    return last_name;}
ac6941ba4dd953bb2d9864a428da679f031dde5d8d2d50c3ede05b48f319e63b
setLastName
public void setLastName(java.lang.CharSequence value)
{    this.last_name = value;}
a47fea1db62a0d1dfe5b729765865791a51fb7cc4da1db64ac8270cfafd0fa73
getPosition
public java.util.List<avro.examples.baseball.Position> getPosition()
{    return position;}
f78baeaf2184e0683fde01ae660c38a48d553ae63e07a1d5ecb68f83f4001c1f
setPosition
public void setPosition(java.util.List<avro.examples.baseball.Position> value)
{    this.position = value;}
e9b60cc740f05d2e68ff7bdb651ab122b33dbfa7e03fcd54705193a4ca3ef900
newBuilder
public static avro.examples.baseball.Player.Builder newBuilder()
{    return new avro.examples.baseball.Player.Builder();}
16072e6cd6368c3b14f7146d7b9982be7a2d9684d9a678b57c6576868169659e
newBuilder
public static avro.examples.baseball.Player.Builder newBuilder(avro.examples.baseball.Player.Builder other)
{    if (other == null) {        return new avro.examples.baseball.Player.Builder();    } else {        return new avro.examples.baseball.Player.Builder(other);    }}
a63b78e45d85fd9513616033d19b8d180417edc4f8bbffd6d7e3a3f3f1bef412
newBuilder
public static avro.examples.baseball.Player.Builder newBuilder(avro.examples.baseball.Player other)
{    if (other == null) {        return new avro.examples.baseball.Player.Builder();    } else {        return new avro.examples.baseball.Player.Builder(other);    }}
1c13c8ecf23858866f0003ded43b76aae5d585b39d3b311bbbc0cda61980598d
getNumber
public int getNumber()
{    return number;}
7676802626697e8da316b75478fd2be7df3df6320ff58ac6a8253c17ec35616c
setNumber
public avro.examples.baseball.Player.Builder setNumber(int value)
{    validate(fields()[0], value);    this.number = value;    fieldSetFlags()[0] = true;    return this;}
55b2c9394a9a7646a8da0c41e0afd69b0c0b6fad8bc25b72919bf25be1ab7f8a
hasNumber
public boolean hasNumber()
{    return fieldSetFlags()[0];}
822980b7af29e1c4422d667e7dd36cd3f42c323e31b42ef6aa3980d072cc9eeb
clearNumber
public avro.examples.baseball.Player.Builder clearNumber()
{    fieldSetFlags()[0] = false;    return this;}
d575ea3f65e1eb86fd6d5f3864308fd0153881c5ca6c52a5ae823208df7299cd
getFirstName
public java.lang.CharSequence getFirstName()
{    return first_name;}
1e6fe32d306387191a3b87b1e0166bdb09d8be065d1210924de1447b49177bf4
setFirstName
public avro.examples.baseball.Player.Builder setFirstName(java.lang.CharSequence value)
{    validate(fields()[1], value);    this.first_name = value;    fieldSetFlags()[1] = true;    return this;}
cb5f8081cd803392e5e57b66cb8f2cdf00664178c3b47b99ec03e9af677e4c0f
hasFirstName
public boolean hasFirstName()
{    return fieldSetFlags()[1];}
9b61907b3bca0ddca6cbae4b13372be2d1e37310d57b19c254d638bf6a705c52
clearFirstName
public avro.examples.baseball.Player.Builder clearFirstName()
{    first_name = null;    fieldSetFlags()[1] = false;    return this;}
3a7f0af4aa3743d291fb4a6fd59c1061063c72e94d6353e245a335e4f020cbaf
getLastName
public java.lang.CharSequence getLastName()
{    return last_name;}
9a176fb5e8b4aafe3544e816c5a897bdeedc349f1da9674d744119499d3c82a6
setLastName
public avro.examples.baseball.Player.Builder setLastName(java.lang.CharSequence value)
{    validate(fields()[2], value);    this.last_name = value;    fieldSetFlags()[2] = true;    return this;}
ed7bcc621caa1a8020c3813bd190d6254af9d23e5ce95f90d459da09a06f90f9
hasLastName
public boolean hasLastName()
{    return fieldSetFlags()[2];}
f1e0d63b6d177184780d51847012e5b17e4bcb8ba22289f3c7e2f02fe70b2ed5
clearLastName
public avro.examples.baseball.Player.Builder clearLastName()
{    last_name = null;    fieldSetFlags()[2] = false;    return this;}
a47fea1db62a0d1dfe5b729765865791a51fb7cc4da1db64ac8270cfafd0fa73
getPosition
public java.util.List<avro.examples.baseball.Position> getPosition()
{    return position;}
556d4b254e4e4a2b6f42bbf0f1176216c155e0d751c5ab479da19b26f0e053c7
setPosition
public avro.examples.baseball.Player.Builder setPosition(java.util.List<avro.examples.baseball.Position> value)
{    validate(fields()[3], value);    this.position = value;    fieldSetFlags()[3] = true;    return this;}
3e26e46d8c1e0a5568f3277684f1f03efb6fc4368f4d5808fa63924e410b73e4
hasPosition
public boolean hasPosition()
{    return fieldSetFlags()[3];}
9ac5c9eb242406233279622dcdd8eb367f6b744ce51dbf6e4afecbf5bc3c829b
clearPosition
public avro.examples.baseball.Player.Builder clearPosition()
{    position = null;    fieldSetFlags()[3] = false;    return this;}
5099c32b1e78e6654329a9052ec77f1d6b34eb769ac535e70a31c3c89b5b7644
build
public Player build()
{    try {        Player record = new Player();        record.number = fieldSetFlags()[0] ? this.number : (java.lang.Integer) defaultValue(fields()[0]);        record.first_name = fieldSetFlags()[1] ? this.first_name : (java.lang.CharSequence) defaultValue(fields()[1]);        record.last_name = fieldSetFlags()[2] ? this.last_name : (java.lang.CharSequence) defaultValue(fields()[2]);        record.position = fieldSetFlags()[3] ? this.position : (java.util.List<avro.examples.baseball.Position>) defaultValue(fields()[3]);        return record;    } catch (org.apache.avro.AvroMissingFieldException e) {        throw e;    } catch (java.lang.Exception e) {        throw new org.apache.avro.AvroRuntimeException(e);    }}
6d36b57419a3667bad09c1fd5c626a8bbcaa3071bb613cccc8d36de3695f7d49
writeExternal
public void writeExternal(java.io.ObjectOutput out) throws java.io.IOException
{    WRITER$.write(this, SpecificData.getEncoder(out));}
d60b919d286c4bc0127bcfa26c40b7baeb61384a75f05a3630240b5b84af9aa8
readExternal
public void readExternal(java.io.ObjectInput in) throws java.io.IOException
{    READER$.read(this, SpecificData.getDecoder(in));}
f9766a02b20bb399ad69d92ada896e23691f38494421a4be07acaf852bb87f9c
hasCustomCoders
protected boolean hasCustomCoders()
{    return true;}
b1ec445fc75afdab4725c5fa7bf25fcf05f9122c94cb53ab3340ccf665bb7cb8
customEncode
public void customEncode(org.apache.avro.io.Encoder out) throws java.io.IOException
{    out.writeInt(this.number);    out.writeString(this.first_name);    out.writeString(this.last_name);    long size0 = this.position.size();    out.writeArrayStart();    out.setItemCount(size0);    long actualSize0 = 0;    for (avro.examples.baseball.Position e0 : this.position) {        actualSize0++;        out.startItem();        out.writeEnum(e0.ordinal());    }    out.writeArrayEnd();    if (actualSize0 != size0)        throw new java.util.ConcurrentModificationException("Array-size written was " + size0 + ", but element count was " + actualSize0 + ".");}
c5cbb3bb294bb052fc2d2ada9e8c84084ec5c525439f55eb1968c128f2ce912c
customDecode
public void customDecode(org.apache.avro.io.ResolvingDecoder in) throws java.io.IOException
{    org.apache.avro.Schema.Field[] fieldOrder = in.readFieldOrderIfDiff();    if (fieldOrder == null) {        this.number = in.readInt();        this.first_name = in.readString(this.first_name instanceof Utf8 ? (Utf8) this.first_name : null);        this.last_name = in.readString(this.last_name instanceof Utf8 ? (Utf8) this.last_name : null);        long size0 = in.readArrayStart();        java.util.List<avro.examples.baseball.Position> a0 = this.position;        if (a0 == null) {            a0 = new SpecificData.Array<avro.examples.baseball.Position>((int) size0, SCHEMA$.getField("position").schema());            this.position = a0;        } else            a0.clear();        SpecificData.Array<avro.examples.baseball.Position> ga0 = (a0 instanceof SpecificData.Array ? (SpecificData.Array<avro.examples.baseball.Position>) a0 : null);        for (; 0 < size0; size0 = in.arrayNext()) {            for (; size0 != 0; size0--) {                avro.examples.baseball.Position e0 = (ga0 != null ? ga0.peek() : null);                e0 = avro.examples.baseball.Position.values()[in.readEnum()];                a0.add(e0);            }        }    } else {        for (int i = 0; i < 4; i++) {            switch(fieldOrder[i].pos()) {                case 0:                    this.number = in.readInt();                    break;                case 1:                    this.first_name = in.readString(this.first_name instanceof Utf8 ? (Utf8) this.first_name : null);                    break;                case 2:                    this.last_name = in.readString(this.last_name instanceof Utf8 ? (Utf8) this.last_name : null);                    break;                case 3:                    long size0 = in.readArrayStart();                    java.util.List<avro.examples.baseball.Position> a0 = this.position;                    if (a0 == null) {                        a0 = new SpecificData.Array<avro.examples.baseball.Position>((int) size0, SCHEMA$.getField("position").schema());                        this.position = a0;                    } else                        a0.clear();                    SpecificData.Array<avro.examples.baseball.Position> ga0 = (a0 instanceof SpecificData.Array ? (SpecificData.Array<avro.examples.baseball.Position>) a0 : null);                    for (; 0 < size0; size0 = in.arrayNext()) {                        for (; size0 != 0; size0--) {                            avro.examples.baseball.Position e0 = (ga0 != null ? ga0.peek() : null);                            e0 = avro.examples.baseball.Position.values()[in.readEnum()];                            a0.add(e0);                        }                    }                    break;                default:                    throw new java.io.IOException("Corrupt ResolvingDecoder.");            }        }    }}
64706bfcdc25a6308d11d702baacbf9dbac8176e7848be0e819da8d1859b6bdb
getClassSchema
public static org.apache.avro.Schema getClassSchema()
{    return SCHEMA$;}
1fa124aa67dc73ccd01002de70d29d68ea9dacd5d97cf4663025da360e9c4749
getSchema
public org.apache.avro.Schema getSchema()
{    return SCHEMA$;}
64706bfcdc25a6308d11d702baacbf9dbac8176e7848be0e819da8d1859b6bdb
getClassSchema
public static org.apache.avro.Schema getClassSchema()
{    return SCHEMA$;}
68af50ba3d90751db153c25a39ff03c7c45d2b0c9ae6d976ba614ae370d4da30
getEncoder
public static BinaryMessageEncoder<FieldTest> getEncoder()
{    return ENCODER;}
cc27c721a5c44aeccac2d6754f3efa84ad897ff83bf43e53fff18595259ecead
getDecoder
public static BinaryMessageDecoder<FieldTest> getDecoder()
{    return DECODER;}
ec5bfd7cb65817e58b6da370456af533a3942860b909a123739f232c9835a679
createDecoder
public static BinaryMessageDecoder<FieldTest> createDecoder(SchemaStore resolver)
{    return new BinaryMessageDecoder<FieldTest>(MODEL$, SCHEMA$, resolver);}
473bffa2e264c9a7f493a4236175e1428e5d97836bf372b01eb5b1692afcd748
toByteBuffer
public java.nio.ByteBuffer toByteBuffer() throws java.io.IOException
{    return ENCODER.encode(this);}
67a028bd274ac31e225b74a34b4a3cb86b4f6d52d5e9db2624e523ff67c680bd
fromByteBuffer
public static FieldTest fromByteBuffer(java.nio.ByteBuffer b) throws java.io.IOException
{    return DECODER.decode(b);}
6feb61aba3d894205e2329721d09e57258e340db02dc7dcd1f630fb34c61245b
getSpecificData
public org.apache.avro.specific.SpecificData getSpecificData()
{    return MODEL$;}
1fa124aa67dc73ccd01002de70d29d68ea9dacd5d97cf4663025da360e9c4749
getSchema
public org.apache.avro.Schema getSchema()
{    return SCHEMA$;}
233b384682c68bdb89ad70c35a2e59b7341b16a68e84517dc4f51d4ce5753ebf
get
public java.lang.Object get(int field$)
{    switch(field$) {        case 0:            return number;        case 1:            return last_name;        case 2:            return timestamp;        case 3:            return timestampMicros;        case 4:            return timeMillis;        case 5:            return timeMicros;        default:            throw new org.apache.avro.AvroRuntimeException("Bad index");    }}
5d771c696600ecd230514c4bcb92450e7aeedfc92ab71e9837199a0477dd3382
getConversion
public org.apache.avro.Conversion<?> getConversion(int field)
{    return conversions[field];}
f13ccb2ddd4dfda02b51ba2bf6b82a34d33026ae9bcb3de86f779f47722fb1ac
put
public void put(int field$, java.lang.Object value$)
{    switch(field$) {        case 0:            number = (java.lang.Integer) value$;            break;        case 1:            last_name = (java.lang.String) value$;            break;        case 2:            timestamp = (java.time.Instant) value$;            break;        case 3:            timestampMicros = (java.time.Instant) value$;            break;        case 4:            timeMillis = (java.time.LocalTime) value$;            break;        case 5:            timeMicros = (java.time.LocalTime) value$;            break;        default:            throw new org.apache.avro.AvroRuntimeException("Bad index");    }}
1c13c8ecf23858866f0003ded43b76aae5d585b39d3b311bbbc0cda61980598d
getNumber
public int getNumber()
{    return number;}
378208bd87e9780ee8e8819e9d0aa06a07d0c741464334112647749805bf98b8
setNumber
public void setNumber(int value)
{    this.number = value;}
77747d4f3c35600b0a9e6c58f44eaec8dd188efb6cbabaa74891afed77714b24
getLastName
public java.lang.String getLastName()
{    return last_name;}
0a3f6f52999ca27bd6658b567dec46e850ce7d11f748bb933a5bb239bb3227d9
setLastName
public void setLastName(java.lang.String value)
{    this.last_name = value;}
91675e3a212ebc1902c7449bd54a99c71c487e90a14e4f841f3d688c0f902db7
getTimestamp
public java.time.Instant getTimestamp()
{    return timestamp;}
4e21d9177d60510ad3228db2e321bc271bc5bba867971e8834cb8e824656fec6
setTimestamp
public void setTimestamp(java.time.Instant value)
{    this.timestamp = value.truncatedTo(java.time.temporal.ChronoUnit.MILLIS);}
a09f07ca0f1954ecc1a68655603d48189b70a87d20abf3d66dfcf4583836177e
getTimestampMicros
public java.time.Instant getTimestampMicros()
{    return timestampMicros;}
db7cb33d821e1ea5be2cb8e205c92a0048867e9681cea6505de33f1b134a65ff
setTimestampMicros
public void setTimestampMicros(java.time.Instant value)
{    this.timestampMicros = value.truncatedTo(java.time.temporal.ChronoUnit.MICROS);}
0e82c6369d1395f4da7b4ff57b319f907c750626c4d4913513a4ea740fb91d50
getTimeMillis
public java.time.LocalTime getTimeMillis()
{    return timeMillis;}
47cbee3b15a0b8167a3868e630c377b4b50d521b34b15713213cba2e8c67372b
setTimeMillis
public void setTimeMillis(java.time.LocalTime value)
{    this.timeMillis = value.truncatedTo(java.time.temporal.ChronoUnit.MILLIS);}
c958bb196d8848642989df70b1943b57dfe610229d5c0ca4e4bb7e0dbcee162c
getTimeMicros
public java.time.LocalTime getTimeMicros()
{    return timeMicros;}
c0cef585887b0ab41fb2aab209f249a7e2de682412034d71265cda13ada1557d
setTimeMicros
public void setTimeMicros(java.time.LocalTime value)
{    this.timeMicros = value.truncatedTo(java.time.temporal.ChronoUnit.MICROS);}
ec4812aa4e4c98790067d16d2d97ae6cbe142621db6191d768e8860fc4e5ccaa
newBuilder
public static avro.examples.baseball.FieldTest.Builder newBuilder()
{    return new avro.examples.baseball.FieldTest.Builder();}
3f0b4e939bae35e72e7a8826ff56a2e0e8e4bb34f9e2b0be64905852db59b64c
newBuilder
public static avro.examples.baseball.FieldTest.Builder newBuilder(avro.examples.baseball.FieldTest.Builder other)
{    if (other == null) {        return new avro.examples.baseball.FieldTest.Builder();    } else {        return new avro.examples.baseball.FieldTest.Builder(other);    }}
f3fd2f01c06a7c2b916994682e2a3e4ff227a3cd14dc3c5a5333bd492256ec9b
newBuilder
public static avro.examples.baseball.FieldTest.Builder newBuilder(avro.examples.baseball.FieldTest other)
{    if (other == null) {        return new avro.examples.baseball.FieldTest.Builder();    } else {        return new avro.examples.baseball.FieldTest.Builder(other);    }}
1c13c8ecf23858866f0003ded43b76aae5d585b39d3b311bbbc0cda61980598d
getNumber
public int getNumber()
{    return number;}
ad09868d470c0bf96d49fbfff0be8136cd9056c35bc49af212240b597ca30192
setNumber
public avro.examples.baseball.FieldTest.Builder setNumber(int value)
{    validate(fields()[0], value);    this.number = value;    fieldSetFlags()[0] = true;    return this;}
55b2c9394a9a7646a8da0c41e0afd69b0c0b6fad8bc25b72919bf25be1ab7f8a
hasNumber
public boolean hasNumber()
{    return fieldSetFlags()[0];}
ec6c21d29e6f3191133cd4242ab00afe091b304f87ae55532102acbbe186b993
clearNumber
public avro.examples.baseball.FieldTest.Builder clearNumber()
{    fieldSetFlags()[0] = false;    return this;}
77747d4f3c35600b0a9e6c58f44eaec8dd188efb6cbabaa74891afed77714b24
getLastName
public java.lang.String getLastName()
{    return last_name;}
80d32bbaf72ffa881b9c5708afd7c91908004c504137021237163a0b7f823b93
setLastName
public avro.examples.baseball.FieldTest.Builder setLastName(java.lang.String value)
{    validate(fields()[1], value);    this.last_name = value;    fieldSetFlags()[1] = true;    return this;}
ed7bcc621caa1a8020c3813bd190d6254af9d23e5ce95f90d459da09a06f90f9
hasLastName
public boolean hasLastName()
{    return fieldSetFlags()[1];}
c52a6e6ff0520e8cedac3bea0812d193f5479a9b3d50c23ed8fdcd8b60311a11
clearLastName
public avro.examples.baseball.FieldTest.Builder clearLastName()
{    last_name = null;    fieldSetFlags()[1] = false;    return this;}
91675e3a212ebc1902c7449bd54a99c71c487e90a14e4f841f3d688c0f902db7
getTimestamp
public java.time.Instant getTimestamp()
{    return timestamp;}
caf78b5e8c7342fc6bc3a6dffea085ff6cefb73622eb397a32f0d3977a4c6d8f
setTimestamp
public avro.examples.baseball.FieldTest.Builder setTimestamp(java.time.Instant value)
{    validate(fields()[2], value);    this.timestamp = value.truncatedTo(java.time.temporal.ChronoUnit.MILLIS);    fieldSetFlags()[2] = true;    return this;}
bafb11dbca36e09bf79e4baa90c93a1bc1422a322f7ad686efa10ecb036831b5
hasTimestamp
public boolean hasTimestamp()
{    return fieldSetFlags()[2];}
eb8a79ae4ae927bb62a3f02052df5301ef23a955c6c32c5505df095ddc189381
clearTimestamp
public avro.examples.baseball.FieldTest.Builder clearTimestamp()
{    fieldSetFlags()[2] = false;    return this;}
a09f07ca0f1954ecc1a68655603d48189b70a87d20abf3d66dfcf4583836177e
getTimestampMicros
public java.time.Instant getTimestampMicros()
{    return timestampMicros;}
37c1f5320a9109cc42bb77a40a7f47f5d9b1be48a854bd33fb11a647f8d35723
setTimestampMicros
public avro.examples.baseball.FieldTest.Builder setTimestampMicros(java.time.Instant value)
{    validate(fields()[3], value);    this.timestampMicros = value.truncatedTo(java.time.temporal.ChronoUnit.MICROS);    fieldSetFlags()[3] = true;    return this;}
11ae7ddf848eddbd442402bf9872a1209a6ce9c722a28542cd75dd9368087d36
hasTimestampMicros
public boolean hasTimestampMicros()
{    return fieldSetFlags()[3];}
2ee0c14e07b05d829ee5bbb4f3e2178194fc097e164cf6f80a72c808ea54ab50
clearTimestampMicros
public avro.examples.baseball.FieldTest.Builder clearTimestampMicros()
{    fieldSetFlags()[3] = false;    return this;}
0e82c6369d1395f4da7b4ff57b319f907c750626c4d4913513a4ea740fb91d50
getTimeMillis
public java.time.LocalTime getTimeMillis()
{    return timeMillis;}
9862e67a2a21636f01771c83753fd1bbc6ea3c9efef5daefa940fa2e6f939e0c
setTimeMillis
public avro.examples.baseball.FieldTest.Builder setTimeMillis(java.time.LocalTime value)
{    validate(fields()[4], value);    this.timeMillis = value.truncatedTo(java.time.temporal.ChronoUnit.MILLIS);    fieldSetFlags()[4] = true;    return this;}
f99e568d3a3da9d4a0248c8ab06aa2eeacfa063b91cc7199d2ad4190bff8a5a4
hasTimeMillis
public boolean hasTimeMillis()
{    return fieldSetFlags()[4];}
8aac7fd925d1d1441960c50da1382a746d4bb64a956297cda786ce821ea8e667
clearTimeMillis
public avro.examples.baseball.FieldTest.Builder clearTimeMillis()
{    fieldSetFlags()[4] = false;    return this;}
c958bb196d8848642989df70b1943b57dfe610229d5c0ca4e4bb7e0dbcee162c
getTimeMicros
public java.time.LocalTime getTimeMicros()
{    return timeMicros;}
79fafe655025f171be2088858dc7ab26c52f066a82c5f9900806273821b269f0
setTimeMicros
public avro.examples.baseball.FieldTest.Builder setTimeMicros(java.time.LocalTime value)
{    validate(fields()[5], value);    this.timeMicros = value.truncatedTo(java.time.temporal.ChronoUnit.MICROS);    fieldSetFlags()[5] = true;    return this;}
fd23954af347d5d0a5b7066bd7ef02561c38e5dceaa7d8a6f44e752edecc32ea
hasTimeMicros
public boolean hasTimeMicros()
{    return fieldSetFlags()[5];}
297c276de4f03a05362bcf34e5c49300e6b6bd3457734dab1f6afe655e8a4e86
clearTimeMicros
public avro.examples.baseball.FieldTest.Builder clearTimeMicros()
{    fieldSetFlags()[5] = false;    return this;}
429cd454bb8f00d4d27109657dbd8982d0797f1454952ff318a719c7ae001af3
build
public FieldTest build()
{    try {        FieldTest record = new FieldTest();        record.number = fieldSetFlags()[0] ? this.number : (java.lang.Integer) defaultValue(fields()[0]);        record.last_name = fieldSetFlags()[1] ? this.last_name : (java.lang.String) defaultValue(fields()[1]);        record.timestamp = fieldSetFlags()[2] ? this.timestamp : (java.time.Instant) defaultValue(fields()[2]);        record.timestampMicros = fieldSetFlags()[3] ? this.timestampMicros : (java.time.Instant) defaultValue(fields()[3]);        record.timeMillis = fieldSetFlags()[4] ? this.timeMillis : (java.time.LocalTime) defaultValue(fields()[4]);        record.timeMicros = fieldSetFlags()[5] ? this.timeMicros : (java.time.LocalTime) defaultValue(fields()[5]);        return record;    } catch (org.apache.avro.AvroMissingFieldException e) {        throw e;    } catch (java.lang.Exception e) {        throw new org.apache.avro.AvroRuntimeException(e);    }}
6d36b57419a3667bad09c1fd5c626a8bbcaa3071bb613cccc8d36de3695f7d49
writeExternal
public void writeExternal(java.io.ObjectOutput out) throws java.io.IOException
{    WRITER$.write(this, SpecificData.getEncoder(out));}
d60b919d286c4bc0127bcfa26c40b7baeb61384a75f05a3630240b5b84af9aa8
readExternal
public void readExternal(java.io.ObjectInput in) throws java.io.IOException
{    READER$.read(this, SpecificData.getDecoder(in));}
64706bfcdc25a6308d11d702baacbf9dbac8176e7848be0e819da8d1859b6bdb
getClassSchema
public static org.apache.avro.Schema getClassSchema()
{    return SCHEMA$;}
145c013a8327b4816336d16a16d5cb42296ee71727f1f42118061bc89f221fa5
getEncoder
public static BinaryMessageEncoder<Player> getEncoder()
{    return ENCODER;}
4a0529a4ad5e7a0ee506bde25c365a727a76e51c50b9f058d83c47d0e9fece63
getDecoder
public static BinaryMessageDecoder<Player> getDecoder()
{    return DECODER;}
e4afbd8e4940cd14120eea14a95eecda193d0f9f9ba10df0ddd0fb01d395b6a9
createDecoder
public static BinaryMessageDecoder<Player> createDecoder(SchemaStore resolver)
{    return new BinaryMessageDecoder<Player>(MODEL$, SCHEMA$, resolver);}
473bffa2e264c9a7f493a4236175e1428e5d97836bf372b01eb5b1692afcd748
toByteBuffer
public java.nio.ByteBuffer toByteBuffer() throws java.io.IOException
{    return ENCODER.encode(this);}
09cdafaa9786329188b885113d14beaada23e9413f1ea3ea360679420fbd49f7
fromByteBuffer
public static Player fromByteBuffer(java.nio.ByteBuffer b) throws java.io.IOException
{    return DECODER.decode(b);}
6feb61aba3d894205e2329721d09e57258e340db02dc7dcd1f630fb34c61245b
getSpecificData
public org.apache.avro.specific.SpecificData getSpecificData()
{    return MODEL$;}
1fa124aa67dc73ccd01002de70d29d68ea9dacd5d97cf4663025da360e9c4749
getSchema
public org.apache.avro.Schema getSchema()
{    return SCHEMA$;}
233b384682c68bdb89ad70c35a2e59b7341b16a68e84517dc4f51d4ce5753ebf
get
public java.lang.Object get(int field$)
{    switch(field$) {        case 0:            return number;        case 1:            return first_name;        case 2:            return last_name;        case 3:            return position;        default:            throw new org.apache.avro.AvroRuntimeException("Bad index");    }}
f13ccb2ddd4dfda02b51ba2bf6b82a34d33026ae9bcb3de86f779f47722fb1ac
put
public void put(int field$, java.lang.Object value$)
{    switch(field$) {        case 0:            number = (java.lang.Integer) value$;            break;        case 1:            first_name = (java.lang.String) value$;            break;        case 2:            last_name = (java.lang.String) value$;            break;        case 3:            position = (java.util.List<avro.examples.baseball.Position>) value$;            break;        default:            throw new org.apache.avro.AvroRuntimeException("Bad index");    }}
1c13c8ecf23858866f0003ded43b76aae5d585b39d3b311bbbc0cda61980598d
getNumber
public int getNumber()
{    return number;}
378208bd87e9780ee8e8819e9d0aa06a07d0c741464334112647749805bf98b8
setNumber
public void setNumber(int value)
{    this.number = value;}
5308d187799f23ea405786de5f0e6e795b714aeabc14f754e9d71793a22f30bf
getFirstName
public java.lang.String getFirstName()
{    return first_name;}
096a711327ba30281a3a2a094827048bccd77a8c3c6050db84a5e69e6ea02ade
setFirstName
public void setFirstName(java.lang.String value)
{    this.first_name = value;}
77747d4f3c35600b0a9e6c58f44eaec8dd188efb6cbabaa74891afed77714b24
getLastName
public java.lang.String getLastName()
{    return last_name;}
0a3f6f52999ca27bd6658b567dec46e850ce7d11f748bb933a5bb239bb3227d9
setLastName
public void setLastName(java.lang.String value)
{    this.last_name = value;}
a47fea1db62a0d1dfe5b729765865791a51fb7cc4da1db64ac8270cfafd0fa73
getPosition
public java.util.List<avro.examples.baseball.Position> getPosition()
{    return position;}
f78baeaf2184e0683fde01ae660c38a48d553ae63e07a1d5ecb68f83f4001c1f
setPosition
public void setPosition(java.util.List<avro.examples.baseball.Position> value)
{    this.position = value;}
e9b60cc740f05d2e68ff7bdb651ab122b33dbfa7e03fcd54705193a4ca3ef900
newBuilder
public static avro.examples.baseball.Player.Builder newBuilder()
{    return new avro.examples.baseball.Player.Builder();}
16072e6cd6368c3b14f7146d7b9982be7a2d9684d9a678b57c6576868169659e
newBuilder
public static avro.examples.baseball.Player.Builder newBuilder(avro.examples.baseball.Player.Builder other)
{    if (other == null) {        return new avro.examples.baseball.Player.Builder();    } else {        return new avro.examples.baseball.Player.Builder(other);    }}
a63b78e45d85fd9513616033d19b8d180417edc4f8bbffd6d7e3a3f3f1bef412
newBuilder
public static avro.examples.baseball.Player.Builder newBuilder(avro.examples.baseball.Player other)
{    if (other == null) {        return new avro.examples.baseball.Player.Builder();    } else {        return new avro.examples.baseball.Player.Builder(other);    }}
1c13c8ecf23858866f0003ded43b76aae5d585b39d3b311bbbc0cda61980598d
getNumber
public int getNumber()
{    return number;}
7676802626697e8da316b75478fd2be7df3df6320ff58ac6a8253c17ec35616c
setNumber
public avro.examples.baseball.Player.Builder setNumber(int value)
{    validate(fields()[0], value);    this.number = value;    fieldSetFlags()[0] = true;    return this;}
55b2c9394a9a7646a8da0c41e0afd69b0c0b6fad8bc25b72919bf25be1ab7f8a
hasNumber
public boolean hasNumber()
{    return fieldSetFlags()[0];}
822980b7af29e1c4422d667e7dd36cd3f42c323e31b42ef6aa3980d072cc9eeb
clearNumber
public avro.examples.baseball.Player.Builder clearNumber()
{    fieldSetFlags()[0] = false;    return this;}
5308d187799f23ea405786de5f0e6e795b714aeabc14f754e9d71793a22f30bf
getFirstName
public java.lang.String getFirstName()
{    return first_name;}
b360126509fe72174e4fc86fe36a74229fa43a6ff0a7266cad84a8bd9d333c30
setFirstName
public avro.examples.baseball.Player.Builder setFirstName(java.lang.String value)
{    validate(fields()[1], value);    this.first_name = value;    fieldSetFlags()[1] = true;    return this;}
cb5f8081cd803392e5e57b66cb8f2cdf00664178c3b47b99ec03e9af677e4c0f
hasFirstName
public boolean hasFirstName()
{    return fieldSetFlags()[1];}
9b61907b3bca0ddca6cbae4b13372be2d1e37310d57b19c254d638bf6a705c52
clearFirstName
public avro.examples.baseball.Player.Builder clearFirstName()
{    first_name = null;    fieldSetFlags()[1] = false;    return this;}
77747d4f3c35600b0a9e6c58f44eaec8dd188efb6cbabaa74891afed77714b24
getLastName
public java.lang.String getLastName()
{    return last_name;}
71b669e5f410fbd9f66dbc3932b039b703b08efe899fbcacace88fdc3a0fb23b
setLastName
public avro.examples.baseball.Player.Builder setLastName(java.lang.String value)
{    validate(fields()[2], value);    this.last_name = value;    fieldSetFlags()[2] = true;    return this;}
ed7bcc621caa1a8020c3813bd190d6254af9d23e5ce95f90d459da09a06f90f9
hasLastName
public boolean hasLastName()
{    return fieldSetFlags()[2];}
f1e0d63b6d177184780d51847012e5b17e4bcb8ba22289f3c7e2f02fe70b2ed5
clearLastName
public avro.examples.baseball.Player.Builder clearLastName()
{    last_name = null;    fieldSetFlags()[2] = false;    return this;}
a47fea1db62a0d1dfe5b729765865791a51fb7cc4da1db64ac8270cfafd0fa73
getPosition
public java.util.List<avro.examples.baseball.Position> getPosition()
{    return position;}
556d4b254e4e4a2b6f42bbf0f1176216c155e0d751c5ab479da19b26f0e053c7
setPosition
public avro.examples.baseball.Player.Builder setPosition(java.util.List<avro.examples.baseball.Position> value)
{    validate(fields()[3], value);    this.position = value;    fieldSetFlags()[3] = true;    return this;}
3e26e46d8c1e0a5568f3277684f1f03efb6fc4368f4d5808fa63924e410b73e4
hasPosition
public boolean hasPosition()
{    return fieldSetFlags()[3];}
9ac5c9eb242406233279622dcdd8eb367f6b744ce51dbf6e4afecbf5bc3c829b
clearPosition
public avro.examples.baseball.Player.Builder clearPosition()
{    position = null;    fieldSetFlags()[3] = false;    return this;}
5099c32b1e78e6654329a9052ec77f1d6b34eb769ac535e70a31c3c89b5b7644
build
public Player build()
{    try {        Player record = new Player();        record.number = fieldSetFlags()[0] ? this.number : (java.lang.Integer) defaultValue(fields()[0]);        record.first_name = fieldSetFlags()[1] ? this.first_name : (java.lang.String) defaultValue(fields()[1]);        record.last_name = fieldSetFlags()[2] ? this.last_name : (java.lang.String) defaultValue(fields()[2]);        record.position = fieldSetFlags()[3] ? this.position : (java.util.List<avro.examples.baseball.Position>) defaultValue(fields()[3]);        return record;    } catch (org.apache.avro.AvroMissingFieldException e) {        throw e;    } catch (java.lang.Exception e) {        throw new org.apache.avro.AvroRuntimeException(e);    }}
6d36b57419a3667bad09c1fd5c626a8bbcaa3071bb613cccc8d36de3695f7d49
writeExternal
public void writeExternal(java.io.ObjectOutput out) throws java.io.IOException
{    WRITER$.write(this, SpecificData.getEncoder(out));}
d60b919d286c4bc0127bcfa26c40b7baeb61384a75f05a3630240b5b84af9aa8
readExternal
public void readExternal(java.io.ObjectInput in) throws java.io.IOException
{    READER$.read(this, SpecificData.getDecoder(in));}
f9766a02b20bb399ad69d92ada896e23691f38494421a4be07acaf852bb87f9c
hasCustomCoders
protected boolean hasCustomCoders()
{    return true;}
b1ec445fc75afdab4725c5fa7bf25fcf05f9122c94cb53ab3340ccf665bb7cb8
customEncode
public void customEncode(org.apache.avro.io.Encoder out) throws java.io.IOException
{    out.writeInt(this.number);    out.writeString(this.first_name);    out.writeString(this.last_name);    long size0 = this.position.size();    out.writeArrayStart();    out.setItemCount(size0);    long actualSize0 = 0;    for (avro.examples.baseball.Position e0 : this.position) {        actualSize0++;        out.startItem();        out.writeEnum(e0.ordinal());    }    out.writeArrayEnd();    if (actualSize0 != size0)        throw new java.util.ConcurrentModificationException("Array-size written was " + size0 + ", but element count was " + actualSize0 + ".");}
c5cbb3bb294bb052fc2d2ada9e8c84084ec5c525439f55eb1968c128f2ce912c
customDecode
public void customDecode(org.apache.avro.io.ResolvingDecoder in) throws java.io.IOException
{    org.apache.avro.Schema.Field[] fieldOrder = in.readFieldOrderIfDiff();    if (fieldOrder == null) {        this.number = in.readInt();        this.first_name = in.readString();        this.last_name = in.readString();        long size0 = in.readArrayStart();        java.util.List<avro.examples.baseball.Position> a0 = this.position;        if (a0 == null) {            a0 = new SpecificData.Array<avro.examples.baseball.Position>((int) size0, SCHEMA$.getField("position").schema());            this.position = a0;        } else            a0.clear();        SpecificData.Array<avro.examples.baseball.Position> ga0 = (a0 instanceof SpecificData.Array ? (SpecificData.Array<avro.examples.baseball.Position>) a0 : null);        for (; 0 < size0; size0 = in.arrayNext()) {            for (; size0 != 0; size0--) {                avro.examples.baseball.Position e0 = (ga0 != null ? ga0.peek() : null);                e0 = avro.examples.baseball.Position.values()[in.readEnum()];                a0.add(e0);            }        }    } else {        for (int i = 0; i < 4; i++) {            switch(fieldOrder[i].pos()) {                case 0:                    this.number = in.readInt();                    break;                case 1:                    this.first_name = in.readString();                    break;                case 2:                    this.last_name = in.readString();                    break;                case 3:                    long size0 = in.readArrayStart();                    java.util.List<avro.examples.baseball.Position> a0 = this.position;                    if (a0 == null) {                        a0 = new SpecificData.Array<avro.examples.baseball.Position>((int) size0, SCHEMA$.getField("position").schema());                        this.position = a0;                    } else                        a0.clear();                    SpecificData.Array<avro.examples.baseball.Position> ga0 = (a0 instanceof SpecificData.Array ? (SpecificData.Array<avro.examples.baseball.Position>) a0 : null);                    for (; 0 < size0; size0 = in.arrayNext()) {                        for (; size0 != 0; size0--) {                            avro.examples.baseball.Position e0 = (ga0 != null ? ga0.peek() : null);                            e0 = avro.examples.baseball.Position.values()[in.readEnum()];                            a0.add(e0);                        }                    }                    break;                default:                    throw new java.io.IOException("Corrupt ResolvingDecoder.");            }        }    }}
64706bfcdc25a6308d11d702baacbf9dbac8176e7848be0e819da8d1859b6bdb
getClassSchema
public static org.apache.avro.Schema getClassSchema()
{    return SCHEMA$;}
1fa124aa67dc73ccd01002de70d29d68ea9dacd5d97cf4663025da360e9c4749
getSchema
public org.apache.avro.Schema getSchema()
{    return SCHEMA$;}
64706bfcdc25a6308d11d702baacbf9dbac8176e7848be0e819da8d1859b6bdb
getClassSchema
public static org.apache.avro.Schema getClassSchema()
{    return SCHEMA$;}
1fa124aa67dc73ccd01002de70d29d68ea9dacd5d97cf4663025da360e9c4749
getSchema
public org.apache.avro.Schema getSchema()
{    return SCHEMA$;}
d895e96457f27617f4c858c7f7fe4d1965a5a162444b2ca7fc215b9d41f1a379
aDatum
private GenericRecord aDatum(Type ofType, int forRow)
{    GenericRecord record;    switch(ofType) {        case STRING:            record = new GenericData.Record(STRINGSCHEMA);            record.put("value", String.valueOf(forRow % 100));            return record;        case INT:            record = new GenericData.Record(INTSCHEMA);            record.put("value", forRow);            return record;        default:            throw new AssertionError("I can't generate data for this type");    }}
6a5df01bc6f62f8a4362ccaf38e52deadbd32851f6fd658fab19e3184144e56e
generateData
private File generateData(String file, Type type, Map<String, String> metadata, CodecFactory codec) throws Exception
{    File inputFile = new File(DIR.getRoot(), file);    inputFile.deleteOnExit();    Schema schema = null;    if (type.equals(Schema.Type.INT)) {        schema = INTSCHEMA;    }    if (type.equals(Schema.Type.STRING)) {        schema = STRINGSCHEMA;    }    DataFileWriter<Object> writer = new DataFileWriter<>(new GenericDatumWriter<>(schema));    for (Entry<String, String> metadatum : metadata.entrySet()) {        writer.setMeta(metadatum.getKey(), metadatum.getValue());    }    writer.setCodec(codec);    writer.create(schema, inputFile);    for (int i = 0; i < ROWS_IN_INPUT_FILES; i++) {        writer.append(aDatum(type, i));    }    writer.close();    return inputFile;}
3ac03a07990e6b21f2c8619ec4362c958c03aa181d53e344fe7a6793b499801a
getFirstIntDatum
private int getFirstIntDatum(File file) throws Exception
{    DataFileStream<GenericRecord> reader = new DataFileStream<>(new FileInputStream(file), new GenericDatumReader<>());    int result = (Integer) reader.next().get(0);    System.out.println(result);    reader.close();    return result;}
b3fc8af053a22b1a03fbda500f9ec9b8b0cd45782f441dcf37b43442339ee24c
numRowsInFile
private int numRowsInFile(File output) throws Exception
{    DataFileStream<GenericRecord> reader = new DataFileStream<>(new FileInputStream(output), new GenericDatumReader<>());    Iterator<GenericRecord> rows = reader.iterator();    int rowcount = 0;    while (rows.hasNext()) {        ++rowcount;        rows.next();    }    reader.close();    return rowcount;}
c49975a560b649cc760d2084500c8c29c2863e9e2aa985e6bb5d7e20425a2f4b
testCat
public void testCat() throws Exception
{    Map<String, String> metadata = new HashMap<>();    metadata.put("myMetaKey", "myMetaValue");    File input1 = generateData("input1.avro", Type.INT, metadata, DEFLATE);    File input2 = generateData("input2.avro", Type.INT, metadata, SNAPPY);    File input3 = generateData("input3.avro", Type.INT, metadata, DEFLATE);    File output = new File(DIR.getRoot(), name.getMethodName() + ".avro");    output.deleteOnExit();        List<String> args = asList(input1.getAbsolutePath(), input2.getAbsolutePath(), input3.getAbsolutePath(), "--offset", String.valueOf(OFFSET), "--limit", String.valueOf(LIMIT_WITHIN_INPUT_BOUNDS), "--samplerate", String.valueOf(SAMPLERATE), output.getAbsolutePath());    int returnCode = new CatTool().run(System.in, System.out, System.err, args);    assertEquals(0, returnCode);    assertEquals(LIMIT_WITHIN_INPUT_BOUNDS, numRowsInFile(output));        args = asList(input1.getParentFile().getAbsolutePath(), output.getAbsolutePath(), "--offset", String.valueOf(OFFSET), "--limit", String.valueOf(LIMIT_WITHIN_INPUT_BOUNDS));    returnCode = new CatTool().run(System.in, System.out, System.err, args);    assertEquals(0, returnCode);    assertEquals(LIMIT_WITHIN_INPUT_BOUNDS, numRowsInFile(output));        args = asList(new File(input1.getParentFile(), "/*").getAbsolutePath(), output.getAbsolutePath(), "--offset", String.valueOf(OFFSET), "--limit", String.valueOf(LIMIT_WITHIN_INPUT_BOUNDS));    returnCode = new CatTool().run(System.in, System.out, System.err, args);    assertEquals(0, returnCode);    assertEquals(LIMIT_WITHIN_INPUT_BOUNDS, numRowsInFile(output));}
c231e3fc8ee6da6c00e4a16466e2bbf2bcbedb73aad78d25e88fe5025cde960b
testLimitOutOfBounds
public void testLimitOutOfBounds() throws Exception
{    Map<String, String> metadata = new HashMap<>();    metadata.put("myMetaKey", "myMetaValue");    File input1 = generateData("input1.avro", Type.INT, metadata, DEFLATE);    File output = new File(DIR.getRoot(), name.getMethodName() + ".avro");    output.deleteOnExit();    List<String> args = asList(input1.getAbsolutePath(), "--offset=" + String.valueOf(OFFSET), "--limit=" + String.valueOf(LIMIT_OUT_OF_INPUT_BOUNDS), output.getAbsolutePath());    int returnCode = new CatTool().run(System.in, System.out, System.err, args);    assertEquals(0, returnCode);    assertEquals(ROWS_IN_INPUT_FILES - OFFSET, numRowsInFile(output));}
42844edbe2540e3558c9838cb26fc7b251373bf47f6a8c2bc6c888b3afad2348
testSamplerateAccuracy
public void testSamplerateAccuracy() throws Exception
{    Map<String, String> metadata = new HashMap<>();    metadata.put("myMetaKey", "myMetaValue");    File input1 = generateData("input1.avro", Type.INT, metadata, DEFLATE);    File output = new File(DIR.getRoot(), name.getMethodName() + ".avro");    output.deleteOnExit();    List<String> args = asList(input1.getAbsolutePath(), output.getAbsolutePath(), "--offset", String.valueOf(OFFSET), "--samplerate", String.valueOf(SAMPLERATE));    int returnCode = new CatTool().run(System.in, System.out, System.err, args);    assertEquals(0, returnCode);    assertTrue("Outputsize is not roughly (Inputsize - Offset) * samplerate", (ROWS_IN_INPUT_FILES - OFFSET) * SAMPLERATE - numRowsInFile(output) < 2);    assertTrue("", (ROWS_IN_INPUT_FILES - OFFSET) * SAMPLERATE - numRowsInFile(output) > -2);}
427791e6c4f9f0aab9c926fdd3893cfc53b5f90d9f60d71154acedc17bfbeb54
testOffSetAccuracy
public void testOffSetAccuracy() throws Exception
{    Map<String, String> metadata = new HashMap<>();    metadata.put("myMetaKey", "myMetaValue");    File input1 = generateData("input1.avro", Type.INT, metadata, DEFLATE);    File output = new File(DIR.getRoot(), name.getMethodName() + ".avro");    output.deleteOnExit();    List<String> args = asList(input1.getAbsolutePath(), "--offset", String.valueOf(OFFSET), "--limit", String.valueOf(LIMIT_WITHIN_INPUT_BOUNDS), "--samplerate", String.valueOf(SAMPLERATE), output.getAbsolutePath());    int returnCode = new CatTool().run(System.in, System.out, System.err, args);    assertEquals(0, returnCode);    assertEquals("output does not start at offset", OFFSET, getFirstIntDatum(output));}
9eec0e4747630a7eba5ee9cbcddb919967d30d28fe276feab6e17bf75c6d869d
testOffsetBiggerThanInput
public void testOffsetBiggerThanInput() throws Exception
{    Map<String, String> metadata = new HashMap<>();    metadata.put("myMetaKey", "myMetaValue");    File input1 = generateData("input1.avro", Type.INT, metadata, DEFLATE);    File output = new File(DIR.getRoot(), name.getMethodName() + ".avro");    output.deleteOnExit();    List<String> args = asList(input1.getAbsolutePath(), "--offset", String.valueOf(ROWS_IN_INPUT_FILES + 1), output.getAbsolutePath());    int returnCode = new CatTool().run(System.in, System.out, System.err, args);    assertEquals(0, returnCode);    assertEquals("output is not empty", 0, numRowsInFile(output));}
e5b3195d336337b4cedca217c5a51f9b10a3e88d7cfdab55baf8acb4f97fa178
testSamplerateSmallerThanInput
public void testSamplerateSmallerThanInput() throws Exception
{    Map<String, String> metadata = new HashMap<>();    metadata.put("myMetaKey", "myMetaValue");    File input1 = generateData("input1.avro", Type.INT, metadata, DEFLATE);    File output = new File(DIR.getRoot(), name.getMethodName() + ".avro");    output.deleteOnExit();    List<String> args = asList(input1.getAbsolutePath(), output.getAbsolutePath(), "--offset=" + Integer.toString(OFFSET), "--samplerate=" + Double.toString(SAMPLERATE_TOO_SMALL));    int returnCode = new CatTool().run(System.in, System.out, System.err, args);    assertEquals(0, returnCode);    assertEquals("output should only contain the record at offset", OFFSET, getFirstIntDatum(output));}
8a8d8f9f5f4fb4e882ebb50d138ffb428126c2eba1aaf27a88516384e3e61005
testDifferentSchemasFail
public void testDifferentSchemasFail() throws Exception
{    Map<String, String> metadata = new HashMap<>();    metadata.put("myMetaKey", "myMetaValue");    File input1 = generateData("input1.avro", Type.STRING, metadata, DEFLATE);    File input2 = generateData("input2.avro", Type.INT, metadata, DEFLATE);    File output = new File(DIR.getRoot(), name.getMethodName() + ".avro");    output.deleteOnExit();    List<String> args = asList(input1.getAbsolutePath(), input2.getAbsolutePath(), output.getAbsolutePath());    new CatTool().run(System.in, System.out, System.err, args);}
182411896c373e27d12e002bb026845b05552f204064c9a4ce59a541eda3ef7b
testHelpfulMessageWhenNoArgsGiven
public void testHelpfulMessageWhenNoArgsGiven() throws Exception
{    ByteArrayOutputStream buffer = new ByteArrayOutputStream(1024);    int returnCode;    try (PrintStream out = new PrintStream(buffer)) {        returnCode = new CatTool().run(System.in, out, System.err, Collections.emptyList());    }    assertEquals(0, returnCode);    assertTrue("should have lots of help", buffer.toString().trim().length() > 200);}
e5e71cdf3e540b07183f5c1e2b37aefbe8433bf8367b253c35f2984f2336e0ce
aDatum
private Object aDatum(Type ofType, int forRow)
{    switch(ofType) {        case STRING:            return String.valueOf(forRow % 100);        case INT:            return forRow;        default:            throw new AssertionError("I can't generate data for this type");    }}
6a5df01bc6f62f8a4362ccaf38e52deadbd32851f6fd658fab19e3184144e56e
generateData
private File generateData(String file, Type type, Map<String, String> metadata, CodecFactory codec) throws Exception
{    File inputFile = new File(INPUT_DIR.getRoot(), file);    Schema schema = Schema.create(type);    try (DataFileWriter<Object> writer = new DataFileWriter<>(new GenericDatumWriter<>(schema))) {        for (Entry<String, String> metadatum : metadata.entrySet()) {            writer.setMeta(metadatum.getKey(), metadatum.getValue());        }        writer.setCodec(codec);        writer.create(schema, inputFile);        for (int i = 0; i < ROWS_IN_INPUT_FILES; i++) {            writer.append(aDatum(type, i));        }    }    return inputFile;}
59be8019aac12b794d48557a7ecdbb7b68f3057576c54540315782b66d3e1599
getCodec
private CodecFactory getCodec(File output) throws Exception
{    try (DataFileStream<GenericRecord> reader = new DataFileStream<>(new FileInputStream(output), new GenericDatumReader<>())) {        String codec = reader.getMetaString(DataFileConstants.CODEC);        return codec == null ? CodecFactory.nullCodec() : CodecFactory.fromString(codec);    }}
b3fc8af053a22b1a03fbda500f9ec9b8b0cd45782f441dcf37b43442339ee24c
numRowsInFile
private int numRowsInFile(File output) throws Exception
{    int rowcount = 0;    try (DataFileStream<Utf8> reader = new DataFileStream<>(new FileInputStream(output), new GenericDatumReader<>())) {        for (Utf8 ignored : reader) {            ++rowcount;        }    }    return rowcount;}
f1a951ecfe183ae7ca8075489f6423580f4b5983ba086d265d58cf94195f1e4c
testDirConcat
public void testDirConcat() throws Exception
{    Map<String, String> metadata = new HashMap<>();    for (int i = 0; i < 3; i++) {        generateData(name.getMethodName() + "-" + i + ".avro", Type.STRING, metadata, DEFLATE);    }    File output = new File(OUTPUT_DIR.getRoot(), name.getMethodName() + ".avro");    List<String> args = asList(INPUT_DIR.getRoot().getAbsolutePath(), output.getAbsolutePath());    int returnCode = new ConcatTool().run(System.in, System.out, System.err, args);    assertEquals(0, returnCode);    assertEquals(ROWS_IN_INPUT_FILES * 3, numRowsInFile(output));}
d220ccba9297c3b9d3916c98562aa8a6b2426ffbc074567482342b2ee98b1dbc
testGlobPatternConcat
public void testGlobPatternConcat() throws Exception
{    Map<String, String> metadata = new HashMap<>();    for (int i = 0; i < 3; i++) {        generateData(name.getMethodName() + "-" + i + ".avro", Type.STRING, metadata, DEFLATE);    }    File output = new File(OUTPUT_DIR.getRoot(), name.getMethodName() + ".avro");    List<String> args = asList(new File(INPUT_DIR.getRoot(), "/*").getAbsolutePath(), output.getAbsolutePath());    int returnCode = new ConcatTool().run(System.in, System.out, System.err, args);    assertEquals(0, returnCode);    assertEquals(ROWS_IN_INPUT_FILES * 3, numRowsInFile(output));}
5e92d8b650b16456fe07e9a7ac224ca756e57f21441fe23e523c81a2ce771e31
testFileDoesNotExist
public void testFileDoesNotExist() throws Exception
{    File output = new File(INPUT_DIR.getRoot(), name.getMethodName() + ".avro");    List<String> args = asList(new File(INPUT_DIR.getRoot(), "/doNotExist").getAbsolutePath(), output.getAbsolutePath());    new ConcatTool().run(System.in, System.out, System.err, args);}
73b28994149ad5ccd99b375b48cc5418446e8321f109c413488b7030df007c91
testConcat
public void testConcat() throws Exception
{    Map<String, String> metadata = new HashMap<>();    metadata.put("myMetaKey", "myMetaValue");    File input1 = generateData(name.getMethodName() + "-1.avro", Type.STRING, metadata, DEFLATE);    File input2 = generateData(name.getMethodName() + "-2.avro", Type.STRING, metadata, DEFLATE);    File input3 = generateData(name.getMethodName() + "-3.avro", Type.STRING, metadata, DEFLATE);    File output = new File(OUTPUT_DIR.getRoot(), name.getMethodName() + ".avro");    List<String> args = asList(input1.getAbsolutePath(), input2.getAbsolutePath(), input3.getAbsolutePath(), output.getAbsolutePath());    int returnCode = new ConcatTool().run(System.in, System.out, System.err, args);    assertEquals(0, returnCode);    assertEquals(ROWS_IN_INPUT_FILES * 3, numRowsInFile(output));    assertEquals(getCodec(input1).getClass(), getCodec(output).getClass());}
8a8d8f9f5f4fb4e882ebb50d138ffb428126c2eba1aaf27a88516384e3e61005
testDifferentSchemasFail
public void testDifferentSchemasFail() throws Exception
{    Map<String, String> metadata = new HashMap<>();    metadata.put("myMetaKey", "myMetaValue");    File input1 = generateData(name.getMethodName() + "-1.avro", Type.STRING, metadata, DEFLATE);    File input2 = generateData(name.getMethodName() + "-2.avro", Type.INT, metadata, DEFLATE);    File output = new File(OUTPUT_DIR.getRoot(), name.getMethodName() + ".avro");    List<String> args = asList(input1.getAbsolutePath(), input2.getAbsolutePath(), output.getAbsolutePath());    int returnCode = new ConcatTool().run(System.in, System.out, System.err, args);    assertEquals(1, returnCode);}
b01e45da31c15649fa1f90d89def2f15b455e31cec707f0156b2eeea6c091adb
testDifferentMetadataFail
public void testDifferentMetadataFail() throws Exception
{    Map<String, String> metadata1 = new HashMap<>();    metadata1.put("myMetaKey", "myMetaValue");    Map<String, String> metadata2 = new HashMap<>();    metadata2.put("myOtherMetaKey", "myOtherMetaValue");    File input1 = generateData(name.getMethodName() + "-1.avro", Type.STRING, metadata1, DEFLATE);    File input2 = generateData(name.getMethodName() + "-2.avro", Type.STRING, metadata2, DEFLATE);    File output = new File(OUTPUT_DIR.getRoot(), name.getMethodName() + ".avro");    List<String> args = asList(input1.getAbsolutePath(), input2.getAbsolutePath(), output.getAbsolutePath());    int returnCode = new ConcatTool().run(System.in, System.out, System.err, args);    assertEquals(2, returnCode);}
8e2f2c4403ffc97997ee0e17a0d4f7d1357a8393ebc50037e00a213f5ba79e66
testDifferentCodecFail
public void testDifferentCodecFail() throws Exception
{    Map<String, String> metadata = new HashMap<>();    metadata.put("myMetaKey", "myMetaValue");    File input1 = generateData(name.getMethodName() + "-1.avro", Type.STRING, metadata, DEFLATE);    File input2 = generateData(name.getMethodName() + "-2.avro", Type.STRING, metadata, CodecFactory.nullCodec());    File output = new File(OUTPUT_DIR.getRoot(), name.getMethodName() + ".avro");    List<String> args = asList(input1.getAbsolutePath(), input2.getAbsolutePath(), output.getAbsolutePath());    int returnCode = new ConcatTool().run(System.in, System.out, System.err, args);    assertEquals(3, returnCode);}
182411896c373e27d12e002bb026845b05552f204064c9a4ce59a541eda3ef7b
testHelpfulMessageWhenNoArgsGiven
public void testHelpfulMessageWhenNoArgsGiven() throws Exception
{    int returnCode;    try (ByteArrayOutputStream buffer = new ByteArrayOutputStream(1024)) {        try (PrintStream out = new PrintStream(buffer)) {            returnCode = new ConcatTool().run(System.in, out, System.err, Collections.emptyList());        }        assertTrue("should have lots of help", buffer.toString().trim().length() > 200);    }    assertEquals(0, returnCode);}
a137d67cbf4a7af20aa93177e840bb9f03d5c275b44a5cc3e10dbc09459dad4d
before
public void before()
{    out = new ByteArrayOutputStream();    err = new ByteArrayOutputStream();}
7d598b4ee6c944c830382fa9016dc0a5cc29192a7d3dcfcf16706b330111b5e5
after
public void after() throws Exception
{    out.close();    err.close();}
821063c98f1aa5288d58e21be206fc52af9d013385663b27803cda0418f98d1e
run
private int run(List<String> args) throws Exception
{    PrintStream output = new PrintStream(out);    PrintStream saveOut = System.out;    PrintStream error = new PrintStream(err);    PrintStream saveErr = System.err;    try {        System.setOut(output);        System.setErr(error);        return new CreateRandomFileTool().run(null, output, error, args);    } finally {        System.setOut(saveOut);        System.setErr(saveErr);    }}
d485b288cb284f10c16d76506ad20d436cedae895f95ed55fb3c6aecbaca28fa
check
private void check(String... extraArgs) throws Exception
{    ArrayList<String> args = new ArrayList<>();    args.addAll(Arrays.asList(OUT_FILE.toString(), "--count", COUNT, "--schema-file", SCHEMA_FILE.toString(), "--seed", Long.toString(SEED)));    args.addAll(Arrays.asList(extraArgs));    run(args);    DataFileReader<Object> reader = new DataFileReader<>(OUT_FILE, new GenericDatumReader<>());    Iterator<Object> found = reader.iterator();    for (Object expected : new RandomData(schemaParser.parse(SCHEMA_FILE), Integer.parseInt(COUNT), SEED)) assertEquals(expected, found.next());    reader.close();}
3fc9cfbd1dd9bddd030d3912683caa65c951022434abb148e0bb91412765340b
checkMissingCount
private void checkMissingCount(String... extraArgs) throws Exception
{    ArrayList<String> args = new ArrayList<>();    args.addAll(Arrays.asList(OUT_FILE.toString(), "--schema-file", SCHEMA_FILE.toString(), "--seed", Long.toString(SEED)));    args.addAll(Arrays.asList(extraArgs));    run(args);    assertTrue(err.toString().contains("Need count (--count)"));}
7e6ef9a15f502c76aa39b9e99c40c2704757556d14668cef0634754950c971d9
testSimple
public void testSimple() throws Exception
{    check();}
9f51446f610a94b4041b13d2c1728c28799d69aa40af214b8354eade903fef2b
testCodec
public void testCodec() throws Exception
{    check("--codec", "snappy");}
939ce4d900698ada3c7b84b1841d37284bd209cda07864eb087e244891588c74
testMissingCountParameter
public void testMissingCountParameter() throws Exception
{    checkMissingCount();}
1407d38bbb98db02fb4f24a1ff02ed42293afe2b969f049841ffaa337a884960
testStdOut
public void testStdOut() throws Exception
{    TestUtil.resetRandomSeed();    run(Arrays.asList("-", "--count", COUNT, "--schema-file", SCHEMA_FILE.toString(), "--seed", Long.toString(SEED)));    byte[] file = out.toByteArray();    DataFileStream<Object> reader = new DataFileStream<>(new ByteArrayInputStream(file), new GenericDatumReader<>());    Iterator<Object> found = reader.iterator();    for (Object expected : new RandomData(schemaParser.parse(SCHEMA_FILE), Integer.parseInt(COUNT), SEED)) assertEquals(expected, found.next());    reader.close();}
eadaa30291adcf70d4129ffa432fe1d2a168d84f0d1cb6d28822479e83a9eb9e
testDefaultCodec
public void testDefaultCodec() throws Exception
{        run(Collections.emptyList());    assertTrue(err.toString().contains("Compression codec (default: deflate)"));}
76f51d4009a0eb9baf43e2c56163c2cc9031eb12a96857ab27ebb8eeebeb9942
writeCorruptFile
public static void writeCorruptFile() throws IOException
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    long pos;        try (DataFileWriter<Utf8> w = new DataFileWriter<>(new GenericDatumWriter<>(SCHEMA))) {        w.create(SCHEMA, baos);        w.append(new Utf8("apple"));        w.append(new Utf8("banana"));        w.append(new Utf8("celery"));        w.sync();        w.append(new Utf8("date"));        w.append(new Utf8("endive"));        w.append(new Utf8("fig"));        pos = w.sync();        w.append(new Utf8("guava"));        w.append(new Utf8("hazelnut"));    }    byte[] original = baos.toByteArray();        int corruptPosition = (int) pos - DataFileConstants.SYNC_SIZE;    int corruptedBytes = 3;    byte[] corrupted = new byte[original.length + corruptedBytes];    System.arraycopy(original, 0, corrupted, 0, corruptPosition);    System.arraycopy(original, corruptPosition, corrupted, corruptPosition + corruptedBytes, original.length - corruptPosition);    corruptBlockFile = new File(DIR.getRoot(), "corruptBlock.avro");    corruptBlockFile.deleteOnExit();    try (FileOutputStream out = new FileOutputStream(corruptBlockFile)) {        out.write(corrupted);    }            corruptPosition = (int) pos - DataFileConstants.SYNC_SIZE - (1 + "fig".length() + 1 + "endive".length());    corrupted = new byte[original.length];    System.arraycopy(original, 0, corrupted, 0, original.length);    BinaryData.encodeLong(-1, corrupted, corruptPosition);    corruptRecordFile = new File(DIR.getRoot(), "corruptRecord.avro");    corruptRecordFile.deleteOnExit();    try (FileOutputStream out = new FileOutputStream(corruptRecordFile)) {        out.write(corrupted);    }}
4adaefafec562702d887f5960a1408e5f9d1add92c42fab7cb857d701c42d2a2
setUp
public void setUp()
{    repairedFile = new File(DIR.getRoot(), "repaired.avro");}
dbc164938eae3782b552501a67d373c43508c83e40a3cd276dedb6c4e3e5ab71
run
private String run(Tool tool, String... args) throws Exception
{    return run(tool, null, args);}
e54a7a7dc90f5cc2ee4c5a757af58282dfad7a1f925deed409bb34e77d3e0a7f
run
private String run(Tool tool, InputStream stdin, String... args) throws Exception
{    ByteArrayOutputStream out = new ByteArrayOutputStream();    PrintStream stdout = new PrintStream(out);    tool.run(stdin, stdout, System.err, Arrays.asList(args));    return out.toString("UTF-8").replace("\r", "");}
5d7e28c3ba36811ee951663ffdc7df4f01c62dc55d1df4c72a3fc9b4d1773a6e
testReportCorruptBlock
public void testReportCorruptBlock() throws Exception
{    String output = run(new DataFileRepairTool(), "-o", "report", corruptBlockFile.getPath());    assertTrue(output, output.contains("Number of blocks: 2 Number of corrupt blocks: 1"));    assertTrue(output, output.contains("Number of records: 5 Number of corrupt records: 0"));}
554f198ca9930801ba786df9d0a1d5929ec75a42e360cd022e42aff8f1a5b13e
testReportCorruptRecord
public void testReportCorruptRecord() throws Exception
{    String output = run(new DataFileRepairTool(), "-o", "report", corruptRecordFile.getPath());    assertTrue(output, output.contains("Number of blocks: 3 Number of corrupt blocks: 1"));    assertTrue(output, output.contains("Number of records: 8 Number of corrupt records: 2"));}
9ffc8f34b7d580198773740b20a69896759567169cce2cb8786231ed8303d143
testRepairAllCorruptBlock
public void testRepairAllCorruptBlock() throws Exception
{    String output = run(new DataFileRepairTool(), "-o", "all", corruptBlockFile.getPath(), repairedFile.getPath());    assertTrue(output, output.contains("Number of blocks: 2 Number of corrupt blocks: 1"));    assertTrue(output, output.contains("Number of records: 5 Number of corrupt records: 0"));    checkFileContains(repairedFile, "apple", "banana", "celery", "guava", "hazelnut");}
e455903bd16ddc3a9779169157c86bdf6010254a09ef0d951c620fa8ce2c073e
testRepairAllCorruptRecord
public void testRepairAllCorruptRecord() throws Exception
{    String output = run(new DataFileRepairTool(), "-o", "all", corruptRecordFile.getPath(), repairedFile.getPath());    assertTrue(output, output.contains("Number of blocks: 3 Number of corrupt blocks: 1"));    assertTrue(output, output.contains("Number of records: 8 Number of corrupt records: 2"));    checkFileContains(repairedFile, "apple", "banana", "celery", "date", "guava", "hazelnut");}
c80c161343b887ac963f39607d54273c3df1d4f5975d0a48dba0205f1f3d7145
testRepairPriorCorruptBlock
public void testRepairPriorCorruptBlock() throws Exception
{    String output = run(new DataFileRepairTool(), "-o", "prior", corruptBlockFile.getPath(), repairedFile.getPath());    assertTrue(output, output.contains("Number of blocks: 2 Number of corrupt blocks: 1"));    assertTrue(output, output.contains("Number of records: 5 Number of corrupt records: 0"));    checkFileContains(repairedFile, "apple", "banana", "celery");}
74ffb0ac028f341021bc61bee22dab915281831c41509e7186e7e82023089704
testRepairPriorCorruptRecord
public void testRepairPriorCorruptRecord() throws Exception
{    String output = run(new DataFileRepairTool(), "-o", "prior", corruptRecordFile.getPath(), repairedFile.getPath());    assertTrue(output, output.contains("Number of blocks: 3 Number of corrupt blocks: 1"));    assertTrue(output, output.contains("Number of records: 8 Number of corrupt records: 2"));    checkFileContains(repairedFile, "apple", "banana", "celery", "date");}
2409f0b7c916255d652aa950ddc016b9b8478ae693b8caddbbc49810cd90db7f
testRepairAfterCorruptBlock
public void testRepairAfterCorruptBlock() throws Exception
{    String output = run(new DataFileRepairTool(), "-o", "after", corruptBlockFile.getPath(), repairedFile.getPath());    assertTrue(output, output.contains("Number of blocks: 2 Number of corrupt blocks: 1"));    assertTrue(output, output.contains("Number of records: 5 Number of corrupt records: 0"));    checkFileContains(repairedFile, "guava", "hazelnut");}
d049a005cae3dd3e0771453396141fe8510ae2f744330ba788ed5d4ed71fa14c
testRepairAfterCorruptRecord
public void testRepairAfterCorruptRecord() throws Exception
{    String output = run(new DataFileRepairTool(), "-o", "after", corruptRecordFile.getPath(), repairedFile.getPath());    assertTrue(output, output.contains("Number of blocks: 3 Number of corrupt blocks: 1"));    assertTrue(output, output.contains("Number of records: 8 Number of corrupt records: 2"));    checkFileContains(repairedFile, "guava", "hazelnut");}
192e2f0bb023fb4434ac0e1020e3b3dc5f8f62511ec488b8f2bcd5b1a158cd20
checkFileContains
private void checkFileContains(File repairedFile, String... lines) throws IOException
{    DataFileReader r = new DataFileReader<>(repairedFile, new GenericDatumReader<>(SCHEMA));    for (String line : lines) {        assertEquals(line, r.next().toString());    }    assertFalse(r.hasNext());}
83e7cbb9d32417856baae1f10c387ff4f10044894a6a7ff0087208dcb0a2fb16
writeSampleFile
public static void writeSampleFile() throws IOException
{    sampleFile = new File(DIR.getRoot(), TestDataFileTools.class.getName() + ".avro");    schema = Schema.create(Type.INT);    schemaFile = new File(DIR.getRoot(), "schema-temp.schema");    try (FileWriter fw = new FileWriter(schemaFile)) {        fw.append(schema.toString());    }    StringBuilder builder = new StringBuilder();    try (DataFileWriter<Object> writer = new DataFileWriter<>(new GenericDatumWriter<>(schema))) {        writer.setMeta(KEY_NEEDING_ESCAPES, "");        writer.create(schema, sampleFile);        for (int i = 0; i < COUNT; ++i) {            builder.append(Integer.toString(i));            builder.append("\n");            writer.append(i);        }    }    jsonData = builder.toString();}
dbc164938eae3782b552501a67d373c43508c83e40a3cd276dedb6c4e3e5ab71
run
private String run(Tool tool, String... args) throws Exception
{    return run(tool, null, args);}
e54a7a7dc90f5cc2ee4c5a757af58282dfad7a1f925deed409bb34e77d3e0a7f
run
private String run(Tool tool, InputStream stdin, String... args) throws Exception
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    PrintStream p = new PrintStream(baos);        tool.run(    stdin,     p,     null, Arrays.asList(args));    return baos.toString("UTF-8").replace("\r", "");}
5fd4a313e76b4c72b8f04da6d40c8f3f451749f179b8171720d0f7bb15574d8f
testRead
public void testRead() throws Exception
{    assertEquals(jsonData, run(new DataFileReadTool(), sampleFile.getPath()));}
b069449633d570dd12275ab25eb68fbf60fc388b2a57cd8d5ff3d3813df2087b
testReadStdin
public void testReadStdin() throws Exception
{    FileInputStream stdin = new FileInputStream(sampleFile);    assertEquals(jsonData, run(new DataFileReadTool(), stdin, "-"));}
a8e22fa65b2d5464c2d261f451d220d160057928d9edbc4eb02a2e763c63a51d
testReadToJsonPretty
public void testReadToJsonPretty() throws Exception
{    assertEquals(jsonData, run(new DataFileReadTool(), "--pretty", sampleFile.getPath()));}
a11b1f549059b415ce34598766797c832df1dc0b4319fd6d3590e2b210ecf786
testReadHeadDefaultCount
public void testReadHeadDefaultCount() throws Exception
{        String expectedJson = jsonData.substring(0, 20);    assertEquals(expectedJson, run(new DataFileReadTool(), "--head", sampleFile.getPath()));}
aa5241512fe1812eeb643aa0767fc7ff375170f40a31bff7143b3aa344a74096
testReadHeadEquals3Count
public void testReadHeadEquals3Count() throws Exception
{        String expectedJson = jsonData.substring(0, 6);    assertEquals(expectedJson, run(new DataFileReadTool(), "--head=3", sampleFile.getPath()));}
f6cb780bd656142f1cba67aac6dba644cc8f4dd1c3353db29a46880b3953b431
testReadHeadSpace5Count
public void testReadHeadSpace5Count() throws Exception
{        String expectedJson = jsonData.substring(0, 10);    assertEquals(expectedJson, run(new DataFileReadTool(), "--head", "5", sampleFile.getPath()));}
823fecda55e7f2cc885d67ad4e7844912457db409cf0e74e24e4080caad426c7
testReadHeadLongCount
public void testReadHeadLongCount() throws Exception
{    assertEquals(jsonData, run(new DataFileReadTool(), "--head=3000000000", sampleFile.getPath()));}
f8887e4a3de68a7b304edc56614878bb37332fa63b399861abd98510a8c39386
testReadHeadEqualsZeroCount
public void testReadHeadEqualsZeroCount() throws Exception
{    assertEquals("\n", run(new DataFileReadTool(), "--head=0", sampleFile.getPath()));}
1db0fd7cf677e25dd0087647f5f8375b7603d6235a0792274d9330541819e03e
testReadHeadNegativeCount
public void testReadHeadNegativeCount() throws Exception
{    assertEquals("\n", run(new DataFileReadTool(), "--head=-5", sampleFile.getPath()));}
d87170814076681eede39ee320db48adf666251eac79b05364ebaf0bda1ae828
testGetMeta
public void testGetMeta() throws Exception
{    String output = run(new DataFileGetMetaTool(), sampleFile.getPath());    assertTrue(output, output.contains("avro.schema\t" + schema.toString() + "\n"));    assertTrue(output, output.contains(ESCAPED_KEY + "\t\n"));}
a53a4abb0bb978285c2ad0d2d3c8c5f70b0e7c1e53cbbba92239d583bb984967
testGetMetaForSingleKey
public void testGetMetaForSingleKey() throws Exception
{    assertEquals(schema.toString() + "\n", run(new DataFileGetMetaTool(), sampleFile.getPath(), "--key", "avro.schema"));}
c225f43010a4591e8344bd32a888b717c319b53ff46b50ecfad4374c58cdc17f
testGetSchema
public void testGetSchema() throws Exception
{    assertEquals(schema.toString() + "\n", run(new DataFileGetSchemaTool(), sampleFile.getPath()));}
b6fbb8404e9439eff1bdcf629c98dd7a23d3f66a19efb23b36334b8c872bd08b
testWriteWithDeflate
public void testWriteWithDeflate() throws Exception
{    testWrite("deflate", Arrays.asList("--codec", "deflate"), "deflate");}
70719fa068547c628c50550d0f82e52fc806aa7ac04932f1f77606705fc3df9d
testWrite
public void testWrite() throws Exception
{    testWrite("plain", Collections.emptyList(), "null");}
29834d50045f14a308b2e16ea0c8db96ac39acfd6b1a5de7d30020d84eed5402
testWrite
public void testWrite(String name, List<String> extra, String expectedCodec) throws Exception
{    testWrite(name, extra, expectedCodec, "-schema", schema.toString());    testWrite(name, extra, expectedCodec, "-schema-file", schemaFile.toString());}
42a153dd78db80da52a9de93f1369143e1d88644372e98cf13bf2b81100b5090
testWrite
public void testWrite(String name, List<String> extra, String expectedCodec, String... extraArgs) throws Exception
{    File outFile = new File(DIR.getRoot(), TestDataFileTools.class + ".testWrite." + name + ".avro");    try (FileOutputStream fout = new FileOutputStream(outFile)) {        try (PrintStream out = new PrintStream(fout)) {            List<String> args = new ArrayList<>();            Collections.addAll(args, extraArgs);            args.add("-");            args.addAll(extra);                        new DataFileWriteTool().run(            new ByteArrayInputStream(jsonData.getBytes("UTF-8")),             new PrintStream(out),             null, args);        }    }        GenericDatumReader<Object> reader = new GenericDatumReader<>();    try (DataFileReader<Object> fileReader = new DataFileReader<>(outFile, reader)) {        int i = 0;        for (Object datum : fileReader) {            assertEquals(i, datum);            i++;        }        assertEquals(COUNT, i);        assertEquals(schema, fileReader.getSchema());        String codecStr = fileReader.getMetaString("avro.codec");        if (null == codecStr) {            codecStr = "null";        }        assertEquals(expectedCodec, codecStr);    }}
f4d671b24c6c27f5f3354336a29ee3a80ede230ee4955d7c6466e39923a05405
testFailureOnWritingPartialJSONValues
public void testFailureOnWritingPartialJSONValues() throws Exception
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    PrintStream out = new PrintStream(baos);        new DataFileWriteTool().run(    new ByteArrayInputStream("{".getBytes("UTF-8")),     new PrintStream(out),     null, Arrays.asList("-schema", "{ \"type\":\"record\", \"fields\":" + "[{\"name\":\"foo\", \"type\":\"string\"}], " + "\"name\":\"boring\" }", "-"));}
f2f2fd025a8297cb70f767b5a2b17be21085432baa054b059ceab58158e856ae
testWritingZeroJsonValues
public void testWritingZeroJsonValues() throws Exception
{    File outFile = writeToAvroFile("zerojsonvalues", schema.toString(), "");    assertEquals(0, countRecords(outFile));}
e77e9a153c5ea37eb80c1a0780a977b4d1d377a844df22403738a23c79cb4200
countRecords
private int countRecords(File outFile) throws IOException
{    GenericDatumReader<Object> reader = new GenericDatumReader<>();    try (DataFileReader<Object> fileReader = new DataFileReader<>(outFile, reader)) {        int i = 0;        for (@SuppressWarnings("unused") Object datum : fileReader) {            i++;        }        return i;    }}
556780fdf1629aaa0c84a813cff10d8c0413eaf16f676ab2f0cd3d124c3d500f
testDifferentSeparatorsBetweenJsonRecords
public void testDifferentSeparatorsBetweenJsonRecords() throws Exception
{    File outFile = writeToAvroFile("separators", "{ \"type\":\"array\", \"items\":\"int\" }", "[]    [] []\n[][3]     ");    assertEquals(5, countRecords(outFile));}
9cf68cde3a543c48409acf8d25aaceb7ef72144fccabd90eb3c5b135f1422660
writeToAvroFile
public File writeToAvroFile(String testName, String schema, String json) throws Exception
{    File outFile = new File(DIR.getRoot(), TestDataFileTools.class + "." + testName + ".avro");    try (FileOutputStream fout = new FileOutputStream(outFile)) {        try (PrintStream out = new PrintStream(fout)) {                        new DataFileWriteTool().run(            new ByteArrayInputStream(json.getBytes("UTF-8")),             new PrintStream(out),             null, Arrays.asList("-schema", schema, "-"));        }    }    return outFile;}
eadaa30291adcf70d4129ffa432fe1d2a168d84f0d1cb6d28822479e83a9eb9e
testDefaultCodec
public void testDefaultCodec() throws Exception
{        ByteArrayOutputStream baos = new ByteArrayOutputStream();    PrintStream err = new PrintStream(baos);    new DataFileWriteTool().run(new ByteArrayInputStream(jsonData.getBytes()), null, err, Collections.emptyList());    assertTrue(baos.toString().contains("Compression codec (default: null)"));}
7aec6af0d91f170581e35e2f86100a72b40b61dabb268b95dc8bc888096ac2a1
testSplitIdlIntoSchemata
public void testSplitIdlIntoSchemata() throws Exception
{    String idl = "src/test/idl/protocol.avdl";    String outdir = "target/test-split";    List<String> arglist = Arrays.asList(idl, outdir);    new IdlToSchemataTool().run(null, null, null, arglist);    String[] files = new File(outdir).list();    assertEquals(4, files.length);}
59ee7c4191a0f073568721fe75794209168d6996ee515571a470d86c44a41fc9
testBinaryToJson
public void testBinaryToJson() throws Exception
{    binaryToJson(AVRO, JSON, STRING_SCHEMA);}
567aa7608c9227a5740bbfa168422c491c0b2b67a0c8323e534e3811a979430f
testJsonToBinary
public void testJsonToBinary() throws Exception
{    jsonToBinary(JSON, AVRO, STRING_SCHEMA);}
39dbe7a816f0395a933fd4366b66c8859be385efac35ea30777fc4d8369fa7a8
testMultiBinaryToJson
public void testMultiBinaryToJson() throws Exception
{    binaryToJson(AVRO + AVRO + AVRO, JSON + JSON + JSON, STRING_SCHEMA);}
5cd30bc009db57baa269aaa080263db3780942441d51a7f0d68c1492710a81a6
testMultiJsonToBinary
public void testMultiJsonToBinary() throws Exception
{    jsonToBinary(JSON + JSON + JSON, AVRO + AVRO + AVRO, STRING_SCHEMA);}
cd1fa39c9fcb8d08598b47b21b9dd2f9c222eb3f0b3a1fe11eae79b5b45ca04e
testBinaryToNoPrettyJson
public void testBinaryToNoPrettyJson() throws Exception
{    binaryToJson(AVRO, JSON, "--no-pretty", STRING_SCHEMA);}
3a45732c7a1f8ac70ae164d7b151572018f1136c15cef23c52e411b49ab4272e
testMultiBinaryToNoPrettyJson
public void testMultiBinaryToNoPrettyJson() throws Exception
{    binaryToJson(AVRO + AVRO + AVRO, JSON + JSON + JSON, "--no-pretty", STRING_SCHEMA);}
d44a9780d56f03de1d07c9d9def58264c92184e6a630dd8afabd9d0a2caa1af6
testBinaryToJsonSchemaFile
public void testBinaryToJsonSchemaFile() throws Exception
{    binaryToJson(AVRO, JSON, "--schema-file", schemaFile(DIR.getRoot()));}
8c4d7558da2059b69e288fa71240e0109aa598150d36f2b6c9a02e3170812b71
testJsonToBinarySchemaFile
public void testJsonToBinarySchemaFile() throws Exception
{    jsonToBinary(JSON, AVRO, "--schema-file", schemaFile(DIR.getRoot()));}
231a521c3459ad1f7128d84432a9541f01896236d6c820788b086d46742d0910
binaryToJson
private void binaryToJson(String avro, String json, String... options) throws Exception
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    PrintStream p = new PrintStream(new BufferedOutputStream(baos));    List<String> args = new ArrayList<>(Arrays.asList(options));    args.add("-");        new BinaryFragmentToJsonTool().run(    new ByteArrayInputStream(avro.getBytes(StandardCharsets.UTF_8)),     p,     null, args);    System.out.println(baos.toString(UTF8).replace("\r", ""));    assertEquals(json, baos.toString(UTF8).replace("\r", ""));}
2f1b0e76f61f44801efc1d2e7e82221f0ff39836581553684f1142e3bc3c629d
jsonToBinary
private void jsonToBinary(String json, String avro, String... options) throws Exception
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    PrintStream p = new PrintStream(new BufferedOutputStream(baos));    List<String> args = new ArrayList<>(Arrays.asList(options));    args.add("-");        new JsonToBinaryFragmentTool().run(    new ByteArrayInputStream(json.getBytes(StandardCharsets.UTF_8)),     p,     null, args);    assertEquals(avro, baos.toString(UTF8));}
ffe05624a866d3d42cc3d431c82a0487398414262fc2c13427d84edbfb182b0b
schemaFile
private static String schemaFile(File dir) throws IOException
{    File schemaFile = new File(dir, "String.avsc");    try (FileWriter fw = new FileWriter(schemaFile)) {        fw.append(STRING_SCHEMA);    }    return schemaFile.toString();}
d5a590c53ca2ca14fef34901228085ce82e6a463061474dbbc27dbd470a130bd
testToolDescriptionLength
public void testToolDescriptionLength()
{    Main m = new Main();    for (Tool t : m.tools.values()) {                if (m.maxLen + 2 + t.getShortDescription().length() > 80) {            fail("Tool description too long: " + t.getName());        }    }}
6028010279ddcd25e8cd6ab3cbcdfb9896b1e9d3fab0000905df0a3c704e3e07
testToolNameLength
public void testToolNameLength()
{        final int MAX_NAME_LENGTH = 13;    Main m = new Main();    for (Tool t : m.tools.values()) {        if (t.getName().length() > MAX_NAME_LENGTH) {            fail("Tool name too long (" + t.getName().length() + "): " + t.getName() + ". Max length is: " + MAX_NAME_LENGTH);        }    }}
fa53f1cd9d67f0410fa4fc0f3ac97ef3d3b56d9e0572025b90aeb6b0a5074259
testRecodec
public void testRecodec() throws Exception
{    String metaKey = "myMetaKey";    String metaValue = "myMetaValue";    File inputFile = new File(DIR.getRoot(), "input.avro");    Schema schema = Schema.create(Type.STRING);    DataFileWriter<String> writer = new DataFileWriter<>(new GenericDatumWriter<String>(schema)).setMeta(metaKey, metaValue).create(schema, inputFile);        for (int i = 0; i < 100000; i++) {        writer.append("" + i % 100);    }    writer.close();    File defaultOutputFile = new File(DIR.getRoot(), "default-output.avro");    File nullOutputFile = new File(DIR.getRoot(), "null-output.avro");    File deflateDefaultOutputFile = new File(DIR.getRoot(), "deflate-default-output.avro");    File deflate1OutputFile = new File(DIR.getRoot(), "deflate-1-output.avro");    File deflate9OutputFile = new File(DIR.getRoot(), "deflate-9-output.avro");    new RecodecTool().run(new FileInputStream(inputFile), new PrintStream(defaultOutputFile), null, new ArrayList<>());    new RecodecTool().run(new FileInputStream(inputFile), new PrintStream(nullOutputFile), null, Collections.singletonList("--codec=null"));    new RecodecTool().run(new FileInputStream(inputFile), new PrintStream(deflateDefaultOutputFile), null, Collections.singletonList("--codec=deflate"));    new RecodecTool().run(new FileInputStream(inputFile), new PrintStream(deflate1OutputFile), null, asList("--codec=deflate", "--level=1"));    new RecodecTool().run(new FileInputStream(inputFile), new PrintStream(deflate9OutputFile), null, asList("--codec=deflate", "--level=9"));            Assert.assertEquals(metaValue, new DataFileReader<Void>(defaultOutputFile, new GenericDatumReader<>()).getMetaString(metaKey));        Assert.assertEquals(defaultOutputFile.length(), nullOutputFile.length());        assertLessThan(deflateDefaultOutputFile.length(), nullOutputFile.length());    assertLessThan(deflate1OutputFile.length(), nullOutputFile.length());    assertLessThan(deflate9OutputFile.length(), nullOutputFile.length());        assertLessThan(deflate9OutputFile.length(), deflate1OutputFile.length());}
120624ea1ec3816d1eacb397457575d21f41f1b868e100460922f36408341ede
assertLessThan
private static void assertLessThan(long less, long more)
{    if (less >= more) {        Assert.fail("Expected " + less + " to be less than " + more);    }}
530ee67749d6f2eff038a16df2c40b771781f68f89687d55f9dec83e341d4cb1
data
public static List<Object[]> data()
{    return Arrays.asList(new Object[] { "http" }, new Object[] { "avro" });}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    String protocolFile = System.getProperty("share.dir", "../../../share") + "/test/schemas/simple.avpr";    simpleProtocol = Protocol.parse(new File(protocolFile));        ByteArrayOutputStream baos1 = new ByteArrayOutputStream();    PrintStream p1 = new PrintStream(baos1);    receive = new RpcReceiveTool();    receive.run1(null, p1, System.err, Arrays.asList(uriScheme + "://0.0.0.0:0/", protocolFile, "hello", "-data", "\"Hello!\""));}
c6aaebb5a52567751db8dc8e1cb9dd4a4e582ef964a374b376c6a04f741802dc
tearDown
public void tearDown() throws Exception
{    if (receive != null)                receive.server.close();}
ab6d64f5d2b4d736208faf5ede5136c016ca064f9464cdc25a49fff97047bee9
testRpcProtocol
public void testRpcProtocol() throws Exception
{        ByteArrayOutputStream baos2 = new ByteArrayOutputStream();    PrintStream p2 = new PrintStream(baos2, true, "UTF-8");    RpcProtocolTool testObject = new RpcProtocolTool();    testObject.run(null, p2, System.err, Collections.singletonList(uriScheme + "://127.0.0.1:" + receive.server.getPort() + "/"));    p2.flush();    assertEquals("Expected the simple.avpr protocol to be echoed to standout", simpleProtocol, Protocol.parse(baos2.toString("UTF-8")));}
409837705d07f765fe5078ca2d6bd590bc343b17c98c33f668dd69c3bfd60de0
testServeAndSend
public void testServeAndSend() throws Exception
{    String protocolFile = System.getProperty("share.dir", "../../../share") + "/test/schemas/simple.avpr";    ByteArrayOutputStream baos1 = new ByteArrayOutputStream();    PrintStream p1 = new PrintStream(baos1);    RpcReceiveTool receive = new RpcReceiveTool();    receive.run1(null, p1, System.err, Arrays.asList("http://0.0.0.0:0/", protocolFile, "hello", "-data", "\"Hello!\""));    ByteArrayOutputStream baos2 = new ByteArrayOutputStream();    PrintStream p2 = new PrintStream(baos2);    RpcSendTool send = new RpcSendTool();    send.run(null, p2, System.err, Arrays.asList("http://127.0.0.1:" + receive.server.getPort() + "/", protocolFile, "hello", "-data", "{ \"greeting\": \"Hi!\" }"));    receive.run2(System.err);    assertTrue(baos1.toString("UTF-8").replace("\r", "").endsWith("hello\t{\"greeting\":\"Hi!\"}\n"));    assertEquals("\"Hello!\"\n", baos2.toString("UTF-8").replace("\r", ""));}
4adaefafec562702d887f5960a1408e5f9d1add92c42fab7cb857d701c42d2a2
setUp
public void setUp()
{    TEST_OUTPUT_DIR.delete();}
f5a03abe395e2f66119bc86304d01bf17dfa0ae37bdfd368ed98809b65f97f94
testCompileSchemaSingleFile
public void testCompileSchemaSingleFile() throws Exception
{    doCompile(new String[] { "-encoding", "UTF-8", "schema", TEST_INPUT_DIR.toString() + "/position.avsc", TEST_OUTPUT_DIR.getPath() });    assertFileMatch(TEST_EXPECTED_POSITION, TEST_OUTPUT_POSITION);}
0a5285487b82eded6053bcc9875e2b840b6c12ff3a2c05b640f5fd6685cda8af
testCompileSchemaTwoFiles
public void testCompileSchemaTwoFiles() throws Exception
{    doCompile(new String[] { "-encoding", "UTF-8", "schema", TEST_INPUT_DIR.toString() + "/position.avsc", TEST_INPUT_DIR.toString() + "/player.avsc", TEST_OUTPUT_DIR.getPath() });    assertFileMatch(TEST_EXPECTED_POSITION, TEST_OUTPUT_POSITION);    assertFileMatch(TEST_EXPECTED_PLAYER, TEST_OUTPUT_PLAYER);}
23aca5e823a95a7289f65fc49321e0e670c45bb372627642140fb3948265d600
testCompileSchemaFileAndDirectory
public void testCompileSchemaFileAndDirectory() throws Exception
{    doCompile(new String[] { "-encoding", "UTF-8", "schema", TEST_INPUT_DIR.toString() + "/position.avsc", TEST_INPUT_DIR.toString(), TEST_OUTPUT_DIR.getPath() });    assertFileMatch(TEST_EXPECTED_POSITION, TEST_OUTPUT_POSITION);    assertFileMatch(TEST_EXPECTED_PLAYER, TEST_OUTPUT_PLAYER);}
39aa7b9be0338e1d852cf050ca543746a38ad00023ad00d58eae42e8e966dbbd
testCompileSchemasUsingString
public void testCompileSchemasUsingString() throws Exception
{    doCompile(new String[] { "-encoding", "UTF-8", "-string", "schema", TEST_INPUT_DIR.toString() + "/position.avsc", TEST_INPUT_DIR.toString() + "/player.avsc", TEST_OUTPUT_STRING_DIR.getPath() });    assertFileMatch(TEST_EXPECTED_STRING_POSITION, TEST_OUTPUT_STRING_POSITION);    assertFileMatch(TEST_EXPECTED_STRING_PLAYER, TEST_OUTPUT_STRING_PLAYER);}
67af1d272f4666ebdfb57c35490d75f7603d33b33ad931e312a6f45becb0853c
testCompileSchemasWithVariousFieldTypes
public void testCompileSchemasWithVariousFieldTypes() throws Exception
{    doCompile(new String[] { "-encoding", "UTF-8", "-string", "schema", TEST_INPUT_DIR.toString() + "/fieldtest.avsc", TEST_INPUT_DIR.toString() + "/fieldtest.avsc", TEST_OUTPUT_STRING_DIR.getPath() });    assertFileMatch(TEST_EXPECTED_STRING_FIELDTEST, TEST_OUTPUT_STRING_FIELDTEST);}
d3ba9cb96fba2f7670598a0fc68a13fa68c51dd39f64b37a9b79a71486627fe8
doCompile
private void doCompile(String[] args) throws Exception
{    SpecificCompilerTool tool = new SpecificCompilerTool();    tool.run(null, null, null, Arrays.asList((args)));}
fa9635fb5f11242fcb66d269f5e7d6aae2edbdfdc3bb0d129e99ae2fe8d9f823
assertFileMatch
private static void assertFileMatch(File expected, File found) throws IOException
{    Assert.assertEquals("Found file: " + found + " does not match expected file: " + expected, readFile(expected), readFile(found));}
e46f38cfd7e99b0c2a9df79d2d390b61115780616de8b9b91108dfc11a615944
readFile
private static String readFile(File file) throws IOException
{    BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(file), "UTF-8"));    StringBuilder sb = new StringBuilder();    String line = null;    boolean first = true;    while ((line = reader.readLine()) != null) {        if (!first) {            sb.append("\n");            first = false;        }        sb.append(line);    }    return sb.toString();}
ced3637227837bc8935023b279f6d11e541ba2dd6bbaff26ba3afa81b2fd1240
test
public void test() throws Exception
{        Schema outscheme = new Pair<Utf8, Long>(new Utf8(""), 0L).getSchema();        File midscfile = new File(INPUT_DIR.getRoot().getPath(), "midschema.avpr");    try (FileWriter hf = new FileWriter(midscfile)) {        hf.write(outscheme.toString());    }    JobConf job = new JobConf();    String inputPathStr = INPUT_DIR.getRoot().getPath();    String outputPathStr = OUTPUT_DIR.getRoot().getPath();    Path outputPath = new Path(outputPathStr);    outputPath.getFileSystem(job).delete(outputPath, true);        WordCountUtil.writeLinesFile(inputPathStr + "/lines.avro");        String execargs = "-classpath " + System.getProperty("java.class.path");    execargs += " org.apache.avro.mapred.tether.WordCountTask";        java.util.List<String> runargs = new java.util.ArrayList<>();    runargs.addAll(java.util.Arrays.asList("--program", "java"));    runargs.addAll(asList("--exec_args", '"' + execargs + '"'));    runargs.addAll(asList("--exec_cached", "false"));    runargs.addAll(asList("--in", inputPathStr));    runargs.addAll(asList("--out", outputPath.toString()));    runargs.addAll(asList("--outschema", midscfile.toString()));    TetherTool tool = new TetherTool();    tool.run(null, null, System.err, runargs);            int numWords = 0;    DatumReader<Pair<Utf8, Long>> reader = new SpecificDatumReader<>();    try (InputStream cin = new BufferedInputStream(new FileInputStream(outputPathStr + "/part-00000.avro"))) {        DataFileStream<Pair<Utf8, Long>> counts = new DataFileStream<>(cin, reader);        for (Pair<Utf8, Long> wc : counts) {            assertEquals(wc.key().toString(), WordCountUtil.COUNTS.get(wc.key().toString()), wc.value());            numWords++;        }    }    assertEquals(WordCountUtil.COUNTS.size(), numWords);}
7e3bb767617afea7710eedd146c1d259ab9b0d178d4097f0c36cdfefd145d861
writeRandomFile
public static void writeRandomFile() throws IOException
{    schema = Schema.create(Type.BYTES);    lines = new ByteBuffer[COUNT];    linesFile = new File(DIR.getRoot(), "random.lines");    OutputStream out = new BufferedOutputStream(new FileOutputStream(linesFile));    Random rand = new Random();    for (int j = 0; j < COUNT; j++) {        byte[] line = new byte[rand.nextInt(512)];        System.out.println("Creating line = " + line.length);        for (int i = 0; i < line.length; i++) {            int b = rand.nextInt(256);            while (b == '\n' || b == '\r') b = rand.nextInt(256);            line[i] = (byte) b;        }        out.write(line);        out.write(LINE_SEP);        lines[j] = ByteBuffer.wrap(line);    }    out.close();}
1b8f3ab9df14a0b3136ca9452570fe6cdf75db56a393dd0e34f70c6326fe9d98
fromText
private void fromText(String name, String... args) throws Exception
{    File avroFile = new File(DIR.getRoot(), name + ".avro");    ArrayList<String> arglist = new ArrayList<>(Arrays.asList(args));    arglist.add(linesFile.toString());    arglist.add(avroFile.toString());    new FromTextTool().run(null, null, null, arglist);        DataFileReader<ByteBuffer> file = new DataFileReader<>(avroFile, new GenericDatumReader<>());    int i = 0;    for (ByteBuffer line : file) {        System.out.println("Reading line = " + line.remaining());        assertEquals(line, lines[i]);        i++;    }    assertEquals(COUNT, i);}
a0db4d838d02c7eeccea88e050935d76b56f54be2bfd75bc5dc1a9188ac25bac
testFromText
public void testFromText() throws Exception
{    fromText("null", "--codec", "null");    fromText("deflate", "--codec", "deflate");    fromText("snappy", "--codec", "snappy");}
942c0c8cd5db85c1ae1c9284c6cdf6a5ee68795a1b4ac91e824561c251e0b873
testToText
public static void testToText() throws Exception
{    toText("null");    toText("deflate");    toText("snappy");}
1e791b35ae06613849190bf8c40c99b4bb51871a8c08bc00e2641ddfbda37ea7
toText
private static void toText(String name) throws Exception
{    File avroFile = new File(DIR.getRoot(), name + ".avro");    File outFile = new File(DIR.getRoot(), name + ".lines");    ArrayList<String> arglist = new ArrayList<>();    arglist.add(avroFile.toString());    arglist.add(outFile.toString());    new ToTextTool().run(null, null, null, arglist);        try (InputStream orig = new BufferedInputStream(new FileInputStream(linesFile))) {        try (InputStream after = new BufferedInputStream(new FileInputStream(outFile))) {            int b;            while ((b = orig.read()) != -1) {                assertEquals(b, after.read());            }            assertEquals(-1, after.read());        }    }}
eadaa30291adcf70d4129ffa432fe1d2a168d84f0d1cb6d28822479e83a9eb9e
testDefaultCodec
public void testDefaultCodec() throws Exception
{        ByteArrayOutputStream baos = new ByteArrayOutputStream();    PrintStream err = new PrintStream(baos);    new FromTextTool().run(null, null, err, Collections.emptyList());    Assert.assertTrue(baos.toString().contains("Compression codec (default: deflate)"));}
d3f088756dd797cef5c3814780a0359c845cf005810ceb23aa8473ba5844a7a4
run
private String run(String... args) throws Exception
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    PrintStream p = new PrintStream(baos);    new ToTrevniTool().run(null, p, null, Arrays.asList(args));    return baos.toString("UTF-8").replace("\r", "");}
ced3637227837bc8935023b279f6d11e541ba2dd6bbaff26ba3afa81b2fd1240
test
public void test() throws Exception
{    Schema schema = new Schema.Parser().parse(SCHEMA_FILE);    DataFileWriter<Object> writer = new DataFileWriter<>(new GenericDatumWriter<>());    writer.create(schema, Util.createFromFS(AVRO_FILE.toString()));    for (Object datum : new RandomData(schema, COUNT, SEED)) writer.append(datum);    writer.close();    run(AVRO_FILE.toString(), TREVNI_FILE.toString());    AvroColumnReader<Object> reader = new AvroColumnReader<>(new AvroColumnReader.Params(TREVNI_FILE));    Iterator<Object> found = reader.iterator();    for (Object expected : new RandomData(schema, COUNT, SEED)) assertEquals(expected, found.next());    reader.close();}
9a2a83f99f6be0f5c977b5eec381b8489a64fed5c5001443c77afc3e768e2993
zstandardCompressionLevel
private void zstandardCompressionLevel(int level) throws Exception
{    OptionParser optParser = new OptionParser();    OptionSpec<String> codecOpt = Util.compressionCodecOption(optParser);    OptionSpec<Integer> levelOpt = Util.compressionLevelOption(optParser);    OptionSet opts = optParser.parse(new String[] { "--codec", "zstandard", "--level", String.valueOf(level) });    CodecFactory codecFactory = Util.codecFactory(opts, codecOpt, levelOpt);    Method createInstance = CodecFactory.class.getDeclaredMethod("createInstance");    createInstance.setAccessible(true);    Codec codec = (ZstandardCodec) createInstance.invoke(codecFactory);    Assert.assertEquals(String.format("zstandard[%d]", level), codec.toString());}
13d24bf3a3b6b63e6fe1e596cc37f38047a7f8ac7ba4978dcece1f67d2b25de3
testCodecFactoryZstandardCompressionLevel
public void testCodecFactoryZstandardCompressionLevel() throws Exception
{    zstandardCompressionLevel(1);    zstandardCompressionLevel(CodecFactory.DEFAULT_ZSTANDARD_LEVEL);}
9d2fe6111d3f8112a56c5e1deba239029428088f4c81a1a20a5165db2bcbdc9a
getColumns
public ColumnMetaData[] getColumns()
{    return columns.toArray(new ColumnMetaData[0]);}
48d46d5581a7296348a16294224e86d3048ec388a5a636eb696bee040eed82d2
getArrayWidths
public int[] getArrayWidths()
{    int[] result = new int[arrayWidths.size()];    int i = 0;    for (Integer width : arrayWidths) result[i++] = width;    return result;}
f7e9f1888b80ae2d301d44ab9bc38748309c934914ab0b7b433470967022139f
columnize
private void columnize(String path, Schema s, ColumnMetaData parent, boolean isArray)
{    if (isSimple(s)) {        if (path == null)            path = s.getFullName();        addColumn(path, simpleValueType(s), parent, isArray);        return;    }    if (    seen.containsKey(s))        throw new TrevniRuntimeException("Cannot shred recursive schemas: " + s);    seen.put(s, s);    switch(s.getType()) {        case MAP:            path = path == null ? ">" : path + ">";            int start = columns.size();            ColumnMetaData p = addColumn(path, ValueType.NULL, parent, true);            addColumn(p(path, "key", ""), ValueType.STRING, p, false);            columnize(p(path, "value", ""), s.getValueType(), p, false);                        arrayWidths.set(start, columns.size() - start);            break;        case RECORD:            for (            Field field :             s.getFields()) columnize(p(path, field.name(), "#"), field.schema(), parent, isArray);            break;        case ARRAY:            path = path == null ? "[]" : path + "[]";            addArrayColumn(path, s.getElementType(), parent);            break;        case UNION:            for (            Schema branch :             s.getTypes()) if (branch.getType() != Schema.Type.NULL)                addArrayColumn(p(path, branch, "/"), branch, parent);            break;        default:            throw new TrevniRuntimeException("Unknown schema: " + s);    }    seen.remove(s);}
b67e1fcc0c9a2393c7269622cf550c8a15d951198349365dd7ef4f74b77c6176
p
private String p(String parent, Schema child, String sep)
{    if (child.getType() == Schema.Type.UNION)        return parent;    return p(parent, child.getFullName(), sep);}
64ec64bc97bbcb353e63de3131415a4b7752fc5d231b66394ee73f2d1920a68e
p
private String p(String parent, String child, String sep)
{    return parent == null ? child : parent + sep + child;}
08ff40cf84fcab74e2c7bf0db8bcd0f006777f97bbdcc52e6df723446562d5fd
addColumn
private ColumnMetaData addColumn(String path, ValueType type, ColumnMetaData parent, boolean isArray)
{    ColumnMetaData column = new ColumnMetaData(path, type);    if (parent != null)        column.setParent(parent);    column.isArray(isArray);    columns.add(column);        arrayWidths.add(1);    return column;}
3cec053f096730aaf3660470999f29217220081f6207a3d9c2367648da1af140
addArrayColumn
private void addArrayColumn(String path, Schema element, ColumnMetaData parent)
{    if (path == null)        path = element.getFullName();    if (isSimple(element)) {                addColumn(path, simpleValueType(element), parent, true);        return;    }        int start = columns.size();    ColumnMetaData array = addColumn(path, ValueType.NULL, parent, true);    columnize(path, element, array, false);        arrayWidths.set(start, columns.size() - start);}
962357409b4ad27a4d8034d8275d5c3caeb533aea57f799e194214ce610abe4f
isSimple
 static boolean isSimple(Schema s)
{    switch(s.getType()) {        case NULL:        case BOOLEAN:        case INT:        case LONG:        case FLOAT:        case DOUBLE:        case BYTES:        case STRING:        case ENUM:        case FIXED:            return true;        default:            return false;    }}
8e75e078b648a9a2367763d7102c2311e89eb78ec16078ee62b10891b863e6cf
simpleValueType
private ValueType simpleValueType(Schema s)
{    switch(s.getType()) {        case NULL:            return ValueType.NULL;        case BOOLEAN:            return ValueType.BOOLEAN;        case INT:            return ValueType.INT;        case LONG:            return ValueType.LONG;        case FLOAT:            return ValueType.FLOAT;        case DOUBLE:            return ValueType.DOUBLE;        case BYTES:            return ValueType.BYTES;        case STRING:            return ValueType.STRING;        case ENUM:            return ValueType.INT;        case FIXED:            return ValueType.BYTES;        default:            throw new TrevniRuntimeException("Unknown schema: " + s);    }}
d27177fc31f9512f83b05789b02dcfeae85057421da88c9e811953a15312eafd
setSchema
public Params setSchema(Schema schema)
{    this.schema = schema;    return this;}
26a05467883b8ef8f54de9ee683f1639e5216443c7beb7f088971e10a87bbcaf
setModel
public Params setModel(GenericData model)
{    this.model = model;    return this;}
7d36b6179aef8c591cbcdd77b4321699bbaeef254f3e6a66590f90630b6cc21f
getFileSchema
public Schema getFileSchema()
{    return fileSchema;}
18aad0b1c4c6f8fda1401761c3a585f67b1fc96c03a36b0dbcf2dd622a12ae45
initialize
 void initialize() throws IOException
{        Map<String, Integer> fileColumnNumbers = new HashMap<>();    int i = 0;    for (ColumnMetaData c : new AvroColumnator(fileSchema).getColumns()) fileColumnNumbers.put(c.getName(), i++);        AvroColumnator readColumnator = new AvroColumnator(readSchema);    this.arrayWidths = readColumnator.getArrayWidths();    ColumnMetaData[] readColumns = readColumnator.getColumns();    this.values = new ColumnValues[readColumns.length];    int j = 0;    for (ColumnMetaData c : readColumns) {        Integer n = fileColumnNumbers.get(c.getName());        if (n != null)            values[j++] = reader.getValues(n);    }    findDefaults(readSchema, fileSchema);}
be99b841805540bd7880e7d00e68b1119dd4b14a1fcfd7cf7a324c9817db769f
findDefaults
private void findDefaults(Schema read, Schema write)
{    switch(read.getType()) {        case NULL:        case BOOLEAN:        case INT:        case LONG:        case FLOAT:        case DOUBLE:        case BYTES:        case STRING:        case ENUM:        case FIXED:            if (read.getType() != write.getType())                throw new TrevniRuntimeException("Type mismatch: " + read + " & " + write);            break;        case MAP:            findDefaults(read.getValueType(), write.getValueType());            break;        case ARRAY:            findDefaults(read.getElementType(), write.getElementType());            break;        case UNION:            for (Schema s : read.getTypes()) {                Integer index = write.getIndexNamed(s.getFullName());                if (index == null)                    throw new TrevniRuntimeException("No matching branch: " + s);                findDefaults(s, write.getTypes().get(index));            }            break;        case RECORD:            for (Field f : read.getFields()) {                Field g = write.getField(f.name());                if (g == null)                    setDefault(read, f);                else                    findDefaults(f.schema(), g.schema());            }            break;        default:            throw new TrevniRuntimeException("Unknown schema: " + read);    }}
08a0d5be008c7195ad58d5b50086a2d1d925468d5746684a6fb792b37eb970a5
setDefault
private void setDefault(Schema record, Field f)
{    String recordName = record.getFullName();    Map<String, Object> recordDefaults = defaults.computeIfAbsent(recordName, k -> new HashMap<>());    recordDefaults.put(f.name(), model.getDefaultValue(f));}
a031f950dbcd28fec27c8f208752c6708e5dc1766a501104b5206d52cec12976
iterator
public Iterator<D> iterator()
{    return this;}
d51e5f7450eca0a0f63da1a466189e262d053b84aa767ba3be5cea740af7251b
hasNext
public boolean hasNext()
{    return values[0].hasNext();}
a3384eda6088ab785128d7d88a9af55e07543a5e59774f8c7f30961ef025e4f5
getRowCount
public long getRowCount()
{    return reader.getRowCount();}
bcf3741d1e793bddf2847f47034bb3e589dc0cdc8a62c7d8a34bf22ea417a01e
next
public D next()
{    try {        for (ColumnValues value : values) if (value != null)            value.startRow();        this.column = 0;        return (D) read(readSchema);    } catch (IOException e) {        throw new TrevniRuntimeException(e);    }}
abf476804443d73c422decc1317f907104d4119851f013faedf790f352df1cf2
read
private Object read(Schema s) throws IOException
{    if (isSimple(s))        return nextValue(s, column++);    final int startColumn = column;    switch(s.getType()) {        case MAP:            int size = values[column].nextLength();            Map map = new HashMap(size);            for (int i = 0; i < size; i++) {                this.column = startColumn;                                values[column++].nextValue();                                String key = (String) values[column++].nextValue();                                map.put(key, read(s.getValueType()));            }            column = startColumn + arrayWidths[startColumn];            return map;        case RECORD:            Object record = model.newRecord(null, s);            Map<String, Object> rDefaults = defaults.get(s.getFullName());            for (Field f : s.getFields()) {                Object value = ((rDefaults != null) && rDefaults.containsKey(f.name())) ? model.deepCopy(f.schema(), rDefaults.get(f.name())) : read(f.schema());                model.setField(record, f.name(), f.pos(), value);            }            return record;        case ARRAY:            int length = values[column].nextLength();            List elements = new GenericData.Array(length, s);            for (int i = 0; i < length; i++) {                this.column = startColumn;                Object value = nextValue(s, column++);                if (!isSimple(s.getElementType()))                    value = read(s.getElementType());                elements.add(value);            }            column = startColumn + arrayWidths[startColumn];            return elements;        case UNION:            Object value = null;            for (Schema branch : s.getTypes()) {                if (branch.getType() == Schema.Type.NULL)                    continue;                if (values[column].nextLength() == 1) {                    value = nextValue(branch, column);                    column++;                    if (!isSimple(branch))                        value = read(branch);                } else {                    column += arrayWidths[column];                }            }            return value;        default:            throw new TrevniRuntimeException("Unknown schema: " + s);    }}
353e32253fc59db1b4984e3e042e777062453f10025d7d88994d5f3a3b9836c6
nextValue
private Object nextValue(Schema s, int column) throws IOException
{    Object v = values[column].nextValue();    switch(s.getType()) {        case ENUM:            return model.createEnum(s.getEnumSymbols().get((Integer) v), s);        case FIXED:            return model.createFixed(null, ((ByteBuffer) v).array(), s);    }    return v;}
eb35e4acc0ab2c89fd30970f01fba35488b3a4581b2af1986091209043508a3e
remove
public void remove()
{    throw new UnsupportedOperationException();}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    reader.close();}
4ede64ee24fd3c38c2371fa0a73712f8785794bf9c7db237043ed97b8841ebd6
sizeEstimate
public long sizeEstimate()
{    return writer.sizeEstimate();}
7dc6be4554c74a17fd17d70feb1dc3c6f61c5fa8dae9c84dbc82b8c7a8ae9a29
writeTo
public void writeTo(OutputStream out) throws IOException
{    writer.writeTo(out);}
3ce845d03de9f35f1f0120f732abb3a43951182384303f326935495de17f63b9
writeTo
public void writeTo(File file) throws IOException
{    writer.writeTo(file);}
5a956a353c1c0b403c7ea1c1ac4fa76bdd66f9eb947ccf69d84f6309fc86bbe4
write
public void write(D value) throws IOException
{    writer.startRow();    int count = write(value, schema, 0);    assert (count == writer.getColumnCount());    writer.endRow();}
0bda7148740cd25f0fa3fda741860a50cbc825dae1cf91122e597222931b3562
write
private int write(Object o, Schema s, int column) throws IOException
{    if (isSimple(s)) {        writeValue(o, s, column);        return column + 1;    }    switch(s.getType()) {        case MAP:            Map<?, ?> map = (Map) o;            writer.writeLength(map.size(), column);            for (Map.Entry e : map.entrySet()) {                writer.writeValue(null, column);                writer.writeValue(e.getKey(), column + 1);                int c = write(e.getValue(), s.getValueType(), column + 2);                assert (c == column + arrayWidths[column]);            }            return column + arrayWidths[column];        case RECORD:            for (Field f : s.getFields()) column = write(model.getField(o, f.name(), f.pos()), f.schema(), column);            return column;        case ARRAY:            Collection elements = (Collection) o;            writer.writeLength(elements.size(), column);            if (isSimple(s.getElementType())) {                                for (Object element : elements) writeValue(element, s.getElementType(), column);                return column + 1;            }            for (Object element : elements) {                writer.writeValue(null, column);                int c = write(element, s.getElementType(), column + 1);                assert (c == column + arrayWidths[column]);            }            return column + arrayWidths[column];        case UNION:            int b = model.resolveUnion(s, o);            int i = 0;            for (Schema branch : s.getTypes()) {                boolean selected = i++ == b;                if (branch.getType() == Schema.Type.NULL)                    continue;                if (!selected) {                    writer.writeLength(0, column);                    column += arrayWidths[column];                } else {                    writer.writeLength(1, column);                    if (isSimple(branch)) {                        writeValue(o, branch, column++);                    } else {                        writer.writeValue(null, column);                        column = write(o, branch, column + 1);                    }                }            }            return column;        default:            throw new TrevniRuntimeException("Unknown schema: " + s);    }}
4aad364817e6ae403eff66bf2c12eb27e36437dc863e898786a7d79e983d6b40
writeValue
private void writeValue(Object value, Schema s, int column) throws IOException
{    switch(s.getType()) {        case STRING:            if (            value instanceof Utf8)                value = value.toString();            break;        case ENUM:            if (value instanceof Enum)                value = ((Enum) value).ordinal();            else                value = s.getEnumOrdinal(value.toString());            break;        case FIXED:            value = ((GenericFixed) value).bytes();            break;    }    writer.writeValue(value, column);}
fa2abbe8c6c2657f3bd0ce74e7a157c222ca7452170fac5b0dedf8a2f38e81ee
isSplitable
protected boolean isSplitable(FileSystem fs, Path filename)
{    return false;}
5661a76f0bcc12fcf3dadab9dfa86940dbf494c03c97d219f02bb45245883e4b
listStatus
protected FileStatus[] listStatus(JobConf job) throws IOException
{    List<FileStatus> result = new ArrayList<>();    job.setBoolean("mapred.input.dir.recursive", true);    for (FileStatus file : super.listStatus(job)) if (file.getPath().getName().endsWith(AvroTrevniOutputFormat.EXT))        result.add(file);    return result.toArray(new FileStatus[0]);}
01a2d3251d31f8411c5cb95a00565f968b9c9c1ed2896f989d2b117f9e7177b0
getRecordReader
public RecordReader<AvroWrapper<T>, NullWritable> getRecordReader(InputSplit split, final JobConf job, Reporter reporter) throws IOException
{    final FileSplit file = (FileSplit) split;    reporter.setStatus(file.toString());    final AvroColumnReader.Params params = new AvroColumnReader.Params(new HadoopInput(file.getPath(), job));    params.setModel(ReflectData.get());    if (job.get(AvroJob.INPUT_SCHEMA) != null)        params.setSchema(AvroJob.getInputSchema(job));    return new RecordReader<AvroWrapper<T>, NullWritable>() {        private AvroColumnReader<T> reader = new AvroColumnReader<>(params);        private float rows = reader.getRowCount();        private long row;        @Override        public AvroWrapper<T> createKey() {            return new AvroWrapper<>(null);        }        @Override        public NullWritable createValue() {            return NullWritable.get();        }        @Override        public boolean next(AvroWrapper<T> wrapper, NullWritable ignore) throws IOException {            if (!reader.hasNext())                return false;            wrapper.datum(reader.next());            row++;            return true;        }        @Override        public float getProgress() throws IOException {            return row / rows;        }        @Override        public long getPos() throws IOException {            return row;        }        @Override        public void close() throws IOException {            reader.close();        }    };}
4a9f8c2f98279900835e618fd45086b675d0d88913f4d5b78f09934da53da06f
createKey
public AvroWrapper<T> createKey()
{    return new AvroWrapper<>(null);}
bb893145c84686d5b66c614a366a7233624450939702ad466536347c434aeb3f
createValue
public NullWritable createValue()
{    return NullWritable.get();}
1ad423ccee660df3ccf8bd087651bb0b2e79759133a5e3f8de8a38e3479da5b7
next
public boolean next(AvroWrapper<T> wrapper, NullWritable ignore) throws IOException
{    if (!reader.hasNext())        return false;    wrapper.datum(reader.next());    row++;    return true;}
46dc59cbf7e4d6aafe0869ef2726ed2c5c897b673d9e37f94ab9b0e962f65f7f
getProgress
public float getProgress() throws IOException
{    return row / rows;}
5800a0f531c192e683ef74c0c5de6015daf6261d1f8e5c0ce6d8e043b01926c7
getPos
public long getPos() throws IOException
{    return row;}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    reader.close();}
2d4761bee986016c647ce7228a38d8653f6816a5ba7df863e19d2b2c81f6a1fc
setMeta
public static void setMeta(JobConf job, String key, String value)
{    job.set(META_PREFIX + key, value);}
2b38daa276e04e7ce90fe9e71f13a604fdd8d824c4da779b4696b0720bea19f4
getRecordWriter
public RecordWriter<AvroWrapper<T>, NullWritable> getRecordWriter(FileSystem ignore, final JobConf job, final String name, Progressable prog) throws IOException
{    boolean isMapOnly = job.getNumReduceTasks() == 0;    final Schema schema = isMapOnly ? AvroJob.getMapOutputSchema(job) : AvroJob.getOutputSchema(job);    final ColumnFileMetaData meta = filterMetadata(job);    final Path dir = FileOutputFormat.getTaskOutputPath(job, name);    final FileSystem fs = dir.getFileSystem(job);    if (!fs.mkdirs(dir))        throw new IOException("Failed to create directory: " + dir);    final long blockSize = fs.getDefaultBlockSize(dir);    return new RecordWriter<AvroWrapper<T>, NullWritable>() {        private int part = 0;        private AvroColumnWriter<T> writer = new AvroColumnWriter<>(schema, meta, ReflectData.get());        private void flush() throws IOException {            try (OutputStream out = fs.create(new Path(dir, "part-" + (part++) + EXT))) {                writer.writeTo(out);            }            writer = new AvroColumnWriter<>(schema, meta, ReflectData.get());        }        @Override        public void write(AvroWrapper<T> wrapper, NullWritable ignore) throws IOException {            writer.write(wrapper.datum());            if (            writer.sizeEstimate() >= blockSize)                flush();        }        public void close(Reporter reporter) throws IOException {            flush();        }    };}
ce4f32a44b2916846ba15afad633d7d0462872f51a1dff5cc446cf538fdc2f9e
flush
private void flush() throws IOException
{    try (OutputStream out = fs.create(new Path(dir, "part-" + (part++) + EXT))) {        writer.writeTo(out);    }    writer = new AvroColumnWriter<>(schema, meta, ReflectData.get());}
00f58e341bbb31b14a13f0d372cb41dc9d440067f290cac22d7e3d4ff25ab8c5
write
public void write(AvroWrapper<T> wrapper, NullWritable ignore) throws IOException
{    writer.write(wrapper.datum());    if (    writer.sizeEstimate() >= blockSize)        flush();}
d217b17bf131ccc7d63327b9a21715cc03224e14acdccb70a58b2ad62544d0f8
close
public void close(Reporter reporter) throws IOException
{    flush();}
46cb8be27f7f4a443a42779044dc2dd9be65af5ef5f6e94573a37d4f972c52ab
filterMetadata
 static ColumnFileMetaData filterMetadata(final JobConf job)
{    final ColumnFileMetaData meta = new ColumnFileMetaData();    for (Map.Entry<String, String> e : job) if (e.getKey().startsWith(META_PREFIX))        meta.put(e.getKey().substring(META_PREFIX.length()), e.getValue().getBytes(StandardCharsets.UTF_8));    return meta;}
585528c061f4edf5b2b70ad857f58312659dac5be1809f2fc803a9ccaa2fb93e
length
public long length()
{    return len;}
c36024425e7455d17ce6a3d01b37b1a7a5f3c30be541aa62c3833d900e7f093e
read
public int read(long p, byte[] b, int s, int l) throws IOException
{    return stream.read(p, b, s, l);}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    stream.close();}
541aa9b93520bda74dba3766c6929c0dfc626453f2346f8d47a22e1ddcdf6228
createRecordReader
public RecordReader<AvroKey<T>, NullWritable> createRecordReader(InputSplit split, TaskAttemptContext context) throws IOException, InterruptedException
{    return new AvroTrevniKeyRecordReader<>();}
cddee7ecc8443e2218fcdd0c20d0289f69faeeea3474633d7ad9753d50f5be6c
getRecordWriter
public RecordWriter<AvroKey<T>, NullWritable> getRecordWriter(TaskAttemptContext context) throws IOException, InterruptedException
{    return new AvroTrevniKeyRecordWriter<>(context);}
a0ee98a155f83fdb41db1532bc31b0131ec31ed732c0be5055ade67bddc9f0c8
getCurrentKey
public AvroKey<T> getCurrentKey() throws IOException, InterruptedException
{    return mCurrentKey;}
516196d2df7c75a44f80933c3abeffe4318669adbeb88e3be576e1a026727564
getCurrentValue
public NullWritable getCurrentValue() throws IOException, InterruptedException
{    return NullWritable.get();}
ea3a7eba5daf72a5cdc712e0c558af9956bcee4d2482e651bd64ac1a2c167657
nextKeyValue
public boolean nextKeyValue() throws IOException, InterruptedException
{    boolean hasNext = super.nextKeyValue();    mCurrentKey.datum(getCurrentRecord());    return hasNext;}
f1166abb86f61f2bbfa1d7bac31c5028462e831bccf582cfdb62b77b0a0d2ce7
write
public void write(AvroKey<T> key, NullWritable value) throws IOException, InterruptedException
{    writer.write(key.datum());    if (    writer.sizeEstimate() >= blockSize)        flush();}
48c69fdb46ebd4d07ae137004ddb4df276000219a902fe123da60d318607ee7a
initSchema
protected Schema initSchema(TaskAttemptContext context)
{    boolean isMapOnly = context.getNumReduceTasks() == 0;    return isMapOnly ? AvroJob.getMapOutputKeySchema(context.getConfiguration()) : AvroJob.getOutputKeySchema(context.getConfiguration());}
db40e96216d3bad43ff76da9b1ff2d69ff85329f1c9a7fe3c28d25504dbaeb59
createRecordReader
public RecordReader<AvroKey<K>, AvroValue<V>> createRecordReader(InputSplit split, TaskAttemptContext context) throws IOException, InterruptedException
{    return new AvroTrevniKeyValueRecordReader<>();}
9fcc3420684ce96c7fbbefe240e1d2a11cbcedef0cf639965bfb53e89816c411
getRecordWriter
public RecordWriter<AvroKey<K>, AvroValue<V>> getRecordWriter(TaskAttemptContext context) throws IOException, InterruptedException
{    return new AvroTrevniKeyValueRecordWriter<>(context);}
b9308e912574dc4ed3683127cb63b67e361f4f51afeb39087e6b7db7ec03b81e
getCurrentKey
public AvroKey<K> getCurrentKey() throws IOException, InterruptedException
{    return mCurrentKey;}
3e9341d85bfe9bb0f6260fd7a744ccbf8249c5fc0a952a635c2b6d4a45d63697
getCurrentValue
public AvroValue<V> getCurrentValue() throws IOException, InterruptedException
{    return mCurrentValue;}
ea3a7eba5daf72a5cdc712e0c558af9956bcee4d2482e651bd64ac1a2c167657
nextKeyValue
public boolean nextKeyValue() throws IOException, InterruptedException
{    boolean hasNext = super.nextKeyValue();    AvroKeyValue<K, V> avroKeyValue = new AvroKeyValue<>(getCurrentRecord());    mCurrentKey.datum(avroKeyValue.getKey());    mCurrentValue.datum(avroKeyValue.getValue());    return hasNext;}
720acb63c512a62167d47df410b37ad96c4f2291f88a2c1f5a4177d96bfc961b
write
public void write(AvroKey<K> key, AvroValue<V> value) throws IOException, InterruptedException
{    keyValueRecord.setKey(key.datum());    keyValueRecord.setValue(value.datum());    writer.write(keyValueRecord.get());    if (    writer.sizeEstimate() >= blockSize)        flush();}
48c69fdb46ebd4d07ae137004ddb4df276000219a902fe123da60d318607ee7a
initSchema
protected Schema initSchema(TaskAttemptContext context)
{    AvroDatumConverterFactory converterFactory = new AvroDatumConverterFactory(context.getConfiguration());    keyConverter = converterFactory.create((Class<K>) context.getOutputKeyClass());    valueConverter = converterFactory.create((Class<V>) context.getOutputValueClass());        return AvroKeyValue.getSchema(keyConverter.getWriterSchema(), valueConverter.getWriterSchema());}
31d67f0ebcfeca7fe0122ca3a067df23149a597f7062117725ccce7015a54168
initialize
public void initialize(InputSplit inputSplit, TaskAttemptContext context) throws IOException, InterruptedException
{    final FileSplit file = (FileSplit) inputSplit;    context.setStatus(file.toString());    final AvroColumnReader.Params params = new AvroColumnReader.Params(new HadoopInput(file.getPath(), context.getConfiguration()));    params.setModel(ReflectData.get());    if (AvroJob.getInputKeySchema(context.getConfiguration()) != null) {        params.setSchema(AvroJob.getInputKeySchema(context.getConfiguration()));    }    reader = new AvroColumnReader<>(params);    rows = reader.getRowCount();}
ea3a7eba5daf72a5cdc712e0c558af9956bcee4d2482e651bd64ac1a2c167657
nextKeyValue
public boolean nextKeyValue() throws IOException, InterruptedException
{    if (!reader.hasNext())        return false;    mCurrentRecord = reader.next();    row++;    return true;}
3ae54090b9a3cbb4546b1848751974d75b4bc1389962804f0f8b5437c328addc
getCurrentRecord
protected T getCurrentRecord()
{    return mCurrentRecord;}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    reader.close();}
e6a44445685ea2b0efb4761e11c07379596d7cd89a49901e52b03fbe83285805
getProgress
public float getProgress() throws IOException, InterruptedException
{    return row / rows;}
c3e67ec76f1b008887f1caba645a2614900cde6e477acca1bc3ecc36bf357fcf
flush
public void flush() throws IOException
{    try (OutputStream out = fs.create(new Path(dirPath, "part-" + (part++) + EXT))) {        writer.writeTo(out);    }    writer = new AvroColumnWriter<>(schema, meta, ReflectData.get());}
f1a065889d38aafb529ac68ad971490678b504d5241708e978558fb6c8a1101f
close
public void close(TaskAttemptContext arg0) throws IOException, InterruptedException
{    flush();}
a1532aeba674e0adb9ccbb437c835777c7ccbdf5c6c07180aa9798d08bd96dad
filterMetadata
 static ColumnFileMetaData filterMetadata(final Configuration configuration)
{    final ColumnFileMetaData meta = new ColumnFileMetaData();    for (Entry<String, String> confEntry : configuration) {        if (confEntry.getKey().startsWith(META_PREFIX))            meta.put(confEntry.getKey().substring(META_PREFIX.length()), confEntry.getValue().getBytes(StandardCharsets.UTF_8));    }    return meta;}
060f525386b455f09eb7716b87f0bfd887b14ef3f89a63fe017c0477d7dcaaaf
setup
protected void setup(Context context)
{    mCount.set(1);}
9df1ee662b6c0a82e05617d535e783643f776451da7d427615702821cd45eb44
map
protected void map(AvroKey<String> key, NullWritable value, Context context) throws IOException, InterruptedException
{    try {        StringTokenizer tokens = new StringTokenizer(key.datum());        while (tokens.hasMoreTokens()) {            mText.set(tokens.nextToken());            context.write(mText, mCount);        }    } catch (Exception e) {        throw new RuntimeException(key + " " + key.datum(), e);    }}
7bba593422bb42c95fd3950160e161d067ab18a22007a6766dcfe65de904967d
reduce
protected void reduce(Text key, Iterable<LongWritable> values, Context context) throws IOException, InterruptedException
{    long sum = 0;    for (LongWritable value : values) {        sum += value.get();    }    resultKey.datum(key.toString());    resultValue.datum(sum);    context.write(resultKey, resultValue);}
2179657c3ac3c8d89447b4cd1a1e5ed28512a49d07055bdd026a4d789073692b
map
protected void map(AvroKey<String> key, AvroValue<Long> value, Context context) throws IOException, InterruptedException
{    total += value.datum();}
34f25fee836f84dba8e2fec7ada666b545e89321c7f57f05ca03cf629034d78d
testIOFormat
public void testIOFormat() throws Exception
{    checkOutputFormat();    checkInputFormat();}
9d5e6934a170cdbc4b548298972cd3e0ccc7ebcaa61775ba6c6f4be36f22c00d
checkOutputFormat
public void checkOutputFormat() throws Exception
{    Job job = Job.getInstance();    WordCountUtil wordCountUtil = new WordCountUtil("trevniMapReduceKeyValueTest", "part-r-00000");    wordCountUtil.writeLinesFile();    AvroJob.setInputKeySchema(job, STRING);    AvroJob.setOutputKeySchema(job, STRING);    AvroJob.setOutputValueSchema(job, LONG);    job.setMapperClass(WordCountMapper.class);    job.setReducerClass(WordCountReducer.class);    job.setMapOutputKeyClass(Text.class);    job.setMapOutputValueClass(LongWritable.class);    FileInputFormat.setInputPaths(job, new Path(wordCountUtil.getDir().toString() + "/in"));    FileOutputFormat.setOutputPath(job, new Path(wordCountUtil.getDir().toString() + "/out"));    FileOutputFormat.setCompressOutput(job, true);    job.setInputFormatClass(AvroKeyInputFormat.class);    job.setOutputFormatClass(AvroTrevniKeyValueOutputFormat.class);    job.waitForCompletion(true);    wordCountUtil.validateCountsFileGenericRecord();}
2d823503678facfd27406bd2980898e0c95d8f55f0f859a42a504a11c9d8ace8
checkInputFormat
public void checkInputFormat() throws Exception
{    Job job = Job.getInstance();    WordCountUtil wordCountUtil = new WordCountUtil("trevniMapReduceKeyValueTest");    job.setMapperClass(Counter.class);    FileInputFormat.setInputPaths(job, new Path(wordCountUtil.getDir().toString() + "/out/*"));    job.setInputFormatClass(AvroTrevniKeyValueInputFormat.class);    job.setNumReduceTasks(0);    job.setOutputFormatClass(NullOutputFormat.class);    total = 0;    job.waitForCompletion(true);    assertEquals(WordCountUtil.TOTAL, total);}
060f525386b455f09eb7716b87f0bfd887b14ef3f89a63fe017c0477d7dcaaaf
setup
protected void setup(Context context)
{    mCount.set(1);}
9df1ee662b6c0a82e05617d535e783643f776451da7d427615702821cd45eb44
map
protected void map(AvroKey<String> key, NullWritable value, Context context) throws IOException, InterruptedException
{    try {        StringTokenizer tokens = new StringTokenizer(key.datum());        while (tokens.hasMoreTokens()) {            mText.set(tokens.nextToken());            context.write(mText, mCount);        }    } catch (Exception e) {        throw new RuntimeException(key + " " + key.datum(), e);    }}
060f525386b455f09eb7716b87f0bfd887b14ef3f89a63fe017c0477d7dcaaaf
setup
protected void setup(Context context)
{    result = new AvroKey<>();    result.datum(new Record(Pair.getPairSchema(STRING, LONG)));}
7bba593422bb42c95fd3950160e161d067ab18a22007a6766dcfe65de904967d
reduce
protected void reduce(Text key, Iterable<LongWritable> values, Context context) throws IOException, InterruptedException
{    long count = 0;    for (LongWritable value : values) {        count += value.get();    }    result.datum().put("key", key.toString());    result.datum().put("value", count);    context.write(result, NullWritable.get());}
b74cb862d4965110ec9933d5d69f894977b5d8b67d6a7fd48db75d056610cea1
map
protected void map(AvroKey<GenericData.Record> key, NullWritable value, Context context) throws IOException, InterruptedException
{    total += (Long) key.datum().get("value");}
34f25fee836f84dba8e2fec7ada666b545e89321c7f57f05ca03cf629034d78d
testIOFormat
public void testIOFormat() throws Exception
{    checkOutputFormat();    checkInputFormat();}
9d5e6934a170cdbc4b548298972cd3e0ccc7ebcaa61775ba6c6f4be36f22c00d
checkOutputFormat
public void checkOutputFormat() throws Exception
{    Job job = Job.getInstance();    WordCountUtil wordCountUtil = new WordCountUtil("trevniMapReduceKeyTest", "part-r-00000");    wordCountUtil.writeLinesFile();    AvroJob.setInputKeySchema(job, STRING);    AvroJob.setOutputKeySchema(job, Pair.getPairSchema(STRING, LONG));    job.setMapperClass(WordCountMapper.class);    job.setReducerClass(WordCountReducer.class);    job.setMapOutputKeyClass(Text.class);    job.setMapOutputValueClass(LongWritable.class);    FileInputFormat.setInputPaths(job, new Path(wordCountUtil.getDir().toString() + "/in"));    FileOutputFormat.setOutputPath(job, new Path(wordCountUtil.getDir().toString() + "/out"));    FileOutputFormat.setCompressOutput(job, true);    job.setInputFormatClass(AvroKeyInputFormat.class);    job.setOutputFormatClass(AvroTrevniKeyOutputFormat.class);    job.waitForCompletion(true);    wordCountUtil.validateCountsFile();}
2d823503678facfd27406bd2980898e0c95d8f55f0f859a42a504a11c9d8ace8
checkInputFormat
public void checkInputFormat() throws Exception
{    Job job = Job.getInstance();    WordCountUtil wordCountUtil = new WordCountUtil("trevniMapReduceKeyTest");    job.setMapperClass(Counter.class);    Schema subSchema = new Schema.Parser().parse("{\"type\":\"record\"," + "\"name\":\"PairValue\"," + "\"fields\": [ " + "{\"name\":\"value\", \"type\":\"long\"}" + "]}");    AvroJob.setInputKeySchema(job, subSchema);    FileInputFormat.setInputPaths(job, new Path(wordCountUtil.getDir().toString() + "/out/*"));    job.setInputFormatClass(AvroTrevniKeyInputFormat.class);    job.setNumReduceTasks(0);    job.setOutputFormatClass(NullOutputFormat.class);    total = 0;    job.waitForCompletion(true);    assertEquals(WordCountUtil.TOTAL, total);}
6aedf396be020f50215b60059fe3a8067945490ac6e689a1957fba34756aee9c
testCases
public void testCases() throws Exception
{    for (File f : DIR.listFiles()) if (f.isDirectory() && !f.getName().startsWith("."))        runCase(f);}
2ecb551b69d7960137a13ab90be4be83d07a50b90117891d1762c406ea444ac1
runCase
private void runCase(File dir) throws Exception
{    Schema schema = new Schema.Parser().parse(new File(dir, "input.avsc"));    List<Object> data = fromJson(schema, new File(dir, "input.json"));        AvroColumnWriter<Object> writer = new AvroColumnWriter<>(schema, new ColumnFileMetaData());    for (Object datum : data) writer.write(datum);    writer.writeTo(FILE);        checkRead(schema, data);        for (File f : dir.listFiles()) if (f.isDirectory() && !f.getName().startsWith(".")) {        Schema s = new Schema.Parser().parse(new File(f, "sub.avsc"));        checkRead(s, fromJson(s, new File(f, "sub.json")));    }}
bb6bb2d228abd3cf40f23d85411949a5778fdf37ef119a40972c413af10c4426
checkRead
private void checkRead(Schema s, List<Object> data) throws Exception
{    try (AvroColumnReader<Object> reader = new AvroColumnReader<>(new AvroColumnReader.Params(FILE).setSchema(s))) {        for (Object datum : data) assertEquals(datum, reader.next());    }}
524b9b0878dac080fb69a86a88ae050a0de07ae2d6ec6e5310ddecd36418e041
fromJson
private List<Object> fromJson(Schema schema, File file) throws Exception
{    List<Object> data = new ArrayList<>();    try (InputStream in = new FileInputStream(file)) {        DatumReader reader = new GenericDatumReader(schema);        Decoder decoder = DecoderFactory.get().jsonDecoder(schema, in);        while (true) data.add(reader.read(null, decoder));    } catch (EOFException e) {    }    return data;}
4adaefafec562702d887f5960a1408e5f9d1add92c42fab7cb857d701c42d2a2
setUp
public void setUp()
{    writtenRecord = new GenericData.Record(writer);    writtenRecord.put("a", "record");    writtenRecord.put("b", 21);    innerRecord = new GenericData.Record(inner);    innerRecord.put("c11", 1);    innerRecord.put("c12", "hello");    evolvedRecord = new GenericData.Record(evolved);    evolvedRecord.put("a", "record");    evolvedRecord.put("b", 21);    evolvedRecord.put("c", innerRecord);}
11d3208528d0d56d1827508360f27cec042cc67b8c4143fc48872f979fd7b6c3
testTrevniEvolvedRead
public void testTrevniEvolvedRead() throws IOException
{    AvroColumnWriter<GenericRecord> acw = new AvroColumnWriter<>(writer, new ColumnFileMetaData());    acw.write(writtenRecord);    File serializedTrevni = File.createTempFile("trevni", null);    acw.writeTo(serializedTrevni);    AvroColumnReader.Params params = new Params(serializedTrevni);    params.setSchema(evolved);    AvroColumnReader<GenericRecord> acr = new AvroColumnReader<>(params);    GenericRecord readRecord = acr.next();    Assert.assertEquals(evolvedRecord, readRecord);    Assert.assertFalse(acr.hasNext());}
6ddc66f4f21766097907bda3d0f4b794fe5feefa69de854063860fde9aec85c8
testAvroEvolvedRead
public void testAvroEvolvedRead() throws IOException
{    File serializedAvro = File.createTempFile("avro", null);    DatumWriter<GenericRecord> dw = new GenericDatumWriter<>(writer);    DataFileWriter<GenericRecord> dfw = new DataFileWriter<>(dw);    dfw.create(writer, serializedAvro);    dfw.append(writtenRecord);    dfw.flush();    dfw.close();    GenericDatumReader<GenericRecord> reader = new GenericDatumReader<>(writer);    reader.setExpected(evolved);    DataFileReader<GenericRecord> dfr = new DataFileReader<>(serializedAvro, reader);    GenericRecord readRecord = dfr.next();    Assert.assertEquals(evolvedRecord, readRecord);    Assert.assertFalse(dfr.hasNext());}
5f0fd29791b05ffd904f93ea508d3af469bc8eec0008c483c070dbe9524443c6
testMetadataFiltering
public void testMetadataFiltering() throws Exception
{    JobConf job = new JobConf();    job.set(AvroTrevniOutputFormat.META_PREFIX + "test1", "1");    job.set(AvroTrevniOutputFormat.META_PREFIX + "test2", "2");    job.set("test3", "3");    job.set(AvroJob.TEXT_PREFIX + "test4", "4");    job.set(AvroTrevniOutputFormat.META_PREFIX + "test5", "5");    ColumnFileMetaData metadata = AvroTrevniOutputFormat.filterMetadata(job);    assertTrue(metadata.get("test1") != null);    assertTrue(new String(metadata.get("test1")).equals("1"));    assertTrue(metadata.get("test2") != null);    assertTrue(new String(metadata.get("test2")).equals("2"));    assertTrue(metadata.get("test5") != null);    assertTrue(new String(metadata.get("test5")).equals("5"));    assertTrue(metadata.get("test3") == null);    assertTrue(metadata.get("test4") == null);}
9dbc4a42aaaaf6fbdb3639f537d5f0e889eb4cf6ab2cbee4fe4c81bbdd87d5c1
testPrimitives
public void testPrimitives() throws Exception
{    check(Schema.create(Schema.Type.NULL), new ColumnMetaData("null", ValueType.NULL));    check(Schema.create(Schema.Type.BOOLEAN), new ColumnMetaData("boolean", ValueType.BOOLEAN));    check(Schema.create(Schema.Type.INT), new ColumnMetaData("int", ValueType.INT));    check(Schema.create(Schema.Type.LONG), new ColumnMetaData("long", ValueType.LONG));    check(Schema.create(Schema.Type.FLOAT), new ColumnMetaData("float", ValueType.FLOAT));    check(Schema.create(Schema.Type.DOUBLE), new ColumnMetaData("double", ValueType.DOUBLE));    check(Schema.create(Schema.Type.BYTES), new ColumnMetaData("bytes", ValueType.BYTES));    check(Schema.create(Schema.Type.STRING), new ColumnMetaData("string", ValueType.STRING));    check(Schema.createEnum("E", null, null, Arrays.asList("X", "Y", "Z")), new ColumnMetaData("E", ValueType.INT));    check(Schema.createFixed("F", null, null, 5), new ColumnMetaData("F", ValueType.BYTES));}
ec6a58dc55884c8ba16652b0251772fb76d1ae7ee8c76fc3446877569e438f83
testSimpleRecord
public void testSimpleRecord() throws Exception
{    check(new Schema.Parser().parse(SIMPLE_RECORD), new ColumnMetaData("x", ValueType.INT), new ColumnMetaData("y", ValueType.STRING));}
e9a4bfa80160af92d2cdbde825a089b4007452654360621274b9a19d19b1a194
testDefaultValue
public void testDefaultValue() throws Exception
{    String s = "{\"type\":\"record\",\"name\":\"R\",\"fields\":[" + SIMPLE_FIELDS + "," + "{\"name\":\"z\",\"type\":\"int\"," + "\"default\":1,\"" + RandomData.USE_DEFAULT + "\":true}" + "]}";    checkWrite(new Schema.Parser().parse(SIMPLE_RECORD));    checkRead(new Schema.Parser().parse(s));}
944bfa2965de50c799d5149a0367db3d19dbb820a3cebecd92e7ec674b2d6965
testNestedRecord
public void testNestedRecord() throws Exception
{    String s = "{\"type\":\"record\",\"name\":\"S\",\"fields\":[" + "{\"name\":\"x\",\"type\":\"int\"}," + "{\"name\":\"R\",\"type\":" + SIMPLE_RECORD + "}," + "{\"name\":\"y\",\"type\":\"string\"}" + "]}";    check(new Schema.Parser().parse(s), new ColumnMetaData("x", ValueType.INT), new ColumnMetaData("R#x", ValueType.INT), new ColumnMetaData("R#y", ValueType.STRING), new ColumnMetaData("y", ValueType.STRING));}
80eee36aee4cd6bdce1271cdb07cfce44f87c91fbbed6281b750a20b4eb69d44
testNamedRecord
public void testNamedRecord() throws Exception
{    String s = "{\"type\":\"record\",\"name\":\"S\",\"fields\":[" + "{\"name\":\"R1\",\"type\":" + SIMPLE_RECORD + "}," + "{\"name\":\"R2\",\"type\":\"R\"}" + "]}";    check(new Schema.Parser().parse(s), new ColumnMetaData("R1#x", ValueType.INT), new ColumnMetaData("R1#y", ValueType.STRING), new ColumnMetaData("R2#x", ValueType.INT), new ColumnMetaData("R2#y", ValueType.STRING));}
89cd26ad2071ab27e77ddf0fbd0197c4f33da63a9717f523e710de277dc74946
testSimpleArray
public void testSimpleArray() throws Exception
{    String s = "{\"type\":\"array\",\"items\":\"long\"}";    check(new Schema.Parser().parse(s), new ColumnMetaData("[]", ValueType.LONG).isArray(true));}
7749ea47bc1c162d12a2c024fc5b3f5a5ed16bb6c8cb8dfaf741cc6e5cc57239
testArray
public void testArray() throws Exception
{    ColumnMetaData p = new ColumnMetaData("[]", ValueType.NULL).isArray(true);    check(new Schema.Parser().parse(RECORD_ARRAY), p, new ColumnMetaData("[]#x", ValueType.INT).setParent(p), new ColumnMetaData("[]#y", ValueType.STRING).setParent(p));}
3ba6e7547729c8ab5fd065beac2629217160590b3c74f90abee9eb14e826503b
testSimpleUnion
public void testSimpleUnion() throws Exception
{    String s = "[\"int\",\"string\"]";    check(new Schema.Parser().parse(s), new ColumnMetaData("int", ValueType.INT).isArray(true), new ColumnMetaData("string", ValueType.STRING).isArray(true));}
bf87798bc81861371761ad8bbe46b96dd19fd41b0271e8962a600796d6f085e0
testSimpleOptional
public void testSimpleOptional() throws Exception
{    String s = "[\"null\",\"string\"]";    check(new Schema.Parser().parse(s), new ColumnMetaData("string", ValueType.STRING).isArray(true));}
885adce170ee8976432efbf14891fef8562a01c79e29888906018818c2983c1a
testUnion
public void testUnion() throws Exception
{    ColumnMetaData p = new ColumnMetaData("R", ValueType.NULL).isArray(true);    check(new Schema.Parser().parse(UNION), new ColumnMetaData("int", ValueType.INT).isArray(true), p, new ColumnMetaData("R#x", ValueType.INT).setParent(p), new ColumnMetaData("R#y", ValueType.STRING).setParent(p));}
2ad10d3f184319ec3093d903c09d08c32b921bea804394a70a25479fd915e8a0
testNestedArray
public void testNestedArray() throws Exception
{    String s = "{\"type\":\"record\",\"name\":\"S\",\"fields\":[" + "{\"name\":\"x\",\"type\":\"int\"}," + "{\"name\":\"A\",\"type\":" + RECORD_ARRAY + "}," + "{\"name\":\"y\",\"type\":\"string\"}" + "]}";    ColumnMetaData p = new ColumnMetaData("A[]", ValueType.NULL).isArray(true);    check(new Schema.Parser().parse(s), new ColumnMetaData("x", ValueType.INT), p, new ColumnMetaData("A[]#x", ValueType.INT).setParent(p), new ColumnMetaData("A[]#y", ValueType.STRING).setParent(p), new ColumnMetaData("y", ValueType.STRING));}
430c566e9a43a200f522440cd33951e550f9faaa79fe9a0af55c1d4395ecf1ad
testNestedUnion
public void testNestedUnion() throws Exception
{    String s = "{\"type\":\"record\",\"name\":\"S\",\"fields\":[" + "{\"name\":\"x\",\"type\":\"int\"}," + "{\"name\":\"u\",\"type\":" + UNION + "}," + "{\"name\":\"y\",\"type\":\"string\"}" + "]}";    ColumnMetaData p = new ColumnMetaData("u/R", ValueType.NULL).isArray(true);    check(new Schema.Parser().parse(s), new ColumnMetaData("x", ValueType.INT), new ColumnMetaData("u/int", ValueType.INT).isArray(true), p, new ColumnMetaData("u/R#x", ValueType.INT).setParent(p), new ColumnMetaData("u/R#y", ValueType.STRING).setParent(p), new ColumnMetaData("y", ValueType.STRING));}
f2c8bd79ac0a859f1a77405a25fa88157fa75e923576a262b0911acfc84b54c9
testUnionInArray
public void testUnionInArray() throws Exception
{    String s = "{\"type\":\"record\",\"name\":\"S\",\"fields\":[" + "{\"name\":\"a\",\"type\":{\"type\":\"array\",\"items\":" + UNION + "}}" + "]}";    ColumnMetaData p = new ColumnMetaData("a[]", ValueType.NULL).isArray(true);    ColumnMetaData r = new ColumnMetaData("a[]/R", ValueType.NULL).setParent(p).isArray(true);    check(new Schema.Parser().parse(s), p, new ColumnMetaData("a[]/int", ValueType.INT).setParent(p).isArray(true), r, new ColumnMetaData("a[]/R#x", ValueType.INT).setParent(r), new ColumnMetaData("a[]/R#y", ValueType.STRING).setParent(r));}
c039a0a630d3aef622c07ad700de4b9096eafc96070e769309f6d1296f598856
testArrayInUnion
public void testArrayInUnion() throws Exception
{    String s = "{\"type\":\"record\",\"name\":\"S\",\"fields\":[" + "{\"name\":\"a\",\"type\":[\"int\"," + RECORD_ARRAY + "]}]}";    ColumnMetaData q = new ColumnMetaData("a/array", ValueType.NULL).isArray(true);    ColumnMetaData r = new ColumnMetaData("a/array[]", ValueType.NULL).setParent(q).isArray(true);    check(new Schema.Parser().parse(s), new ColumnMetaData("a/int", ValueType.INT).isArray(true), q, r, new ColumnMetaData("a/array[]#x", ValueType.INT).setParent(r), new ColumnMetaData("a/array[]#y", ValueType.STRING).setParent(r));}
a40e21916eed6027a40dd0aa699b27a545bb67f460bac313d6a455ecacaf957e
testSimpleMap
public void testSimpleMap() throws Exception
{    String s = "{\"type\":\"map\",\"values\":\"long\"}";    ColumnMetaData p = new ColumnMetaData(">", ValueType.NULL).isArray(true);    check(new Schema.Parser().parse(s), p, new ColumnMetaData(">key", ValueType.STRING).setParent(p), new ColumnMetaData(">value", ValueType.LONG).setParent(p));}
7e3f62689a52f5cfc8f5889d1068814d43f1f4feaa85df375762f0f9cb0ab82c
testMap
public void testMap() throws Exception
{    String s = "{\"type\":\"map\",\"values\":" + SIMPLE_RECORD + "}";    ColumnMetaData p = new ColumnMetaData(">", ValueType.NULL).isArray(true);    check(new Schema.Parser().parse(s), p, new ColumnMetaData(">key", ValueType.STRING).setParent(p), new ColumnMetaData(">value#x", ValueType.INT).setParent(p), new ColumnMetaData(">value#y", ValueType.STRING).setParent(p));}
4cdcb3114775862a44ae8608324515ec2d1b43b035a2e8f24200f5063e0adfa5
check
private void check(Schema s, ColumnMetaData... expected) throws Exception
{    ColumnMetaData[] shredded = new AvroColumnator(s).getColumns();    assertEquals(expected.length, shredded.length);    for (int i = 0; i < expected.length; i++) assertEquals(expected[i].toString(), shredded[i].toString());    checkWrite(s);    checkRead(s);}
adf72d22bd4e6982dc52f614fd897b5484166d385e04885b53082c6e8bba6e3c
checkWrite
private void checkWrite(Schema schema) throws IOException
{    AvroColumnWriter<Object> writer = new AvroColumnWriter<>(schema, new ColumnFileMetaData());    int count = 0;    for (Object datum : new RandomData(schema, COUNT, SEED)) {                writer.write(datum);    }    writer.writeTo(FILE);}
5e5a021f42f8cc433b5aa5947cd461fbb7255512cd976bfa9503f40c3db1994b
checkRead
private void checkRead(Schema schema) throws IOException
{    AvroColumnReader<Object> reader = new AvroColumnReader<>(new AvroColumnReader.Params(FILE).setSchema(schema));    for (Object expected : new RandomData(schema, COUNT, SEED)) assertEquals(expected, reader.next());    reader.close();}
d5a09e0ddfccd28c5ec06320e90134f2b70f8c43ef071ae997fa4dabc6730d21
map
public void map(String text, AvroCollector<Pair<String, Long>> collector, Reporter reporter) throws IOException
{    StringTokenizer tokens = new StringTokenizer(text);    while (tokens.hasMoreTokens()) collector.collect(new Pair<>(tokens.nextToken(), 1L));}
a8178a1f65e9dfb54c4bd82b6bb043ef5597a4553534fea0a536554816f7de33
reduce
public void reduce(String word, Iterable<Long> counts, AvroCollector<Pair<String, Long>> collector, Reporter reporter) throws IOException
{    long sum = 0;    for (long count : counts) sum += count;    collector.collect(new Pair<>(word, sum));}
3e79f00488eb1e51412af24aff162ecb29c178f612062ebc2a2ed74b5fa0ac77
runTestsInOrder
public void runTestsInOrder() throws Exception
{    testOutputFormat();    testInputFormat();}
e6872cb34b5d3d9ebaee087c191047043c7164be70470e9675fcef271cd3e812
testOutputFormat
public void testOutputFormat() throws Exception
{    JobConf job = new JobConf();    WordCountUtil wordCountUtil = new WordCountUtil("trevniMapredTest");    wordCountUtil.writeLinesFile();    AvroJob.setInputSchema(job, STRING);    AvroJob.setOutputSchema(job, Pair.getPairSchema(STRING, LONG));    AvroJob.setMapperClass(job, MapImpl.class);    AvroJob.setCombinerClass(job, ReduceImpl.class);    AvroJob.setReducerClass(job, ReduceImpl.class);    FileInputFormat.setInputPaths(job, new Path(wordCountUtil.getDir().toString() + "/in"));    FileOutputFormat.setOutputPath(job, new Path(wordCountUtil.getDir().toString() + "/out"));    FileOutputFormat.setCompressOutput(job, true);    job.setOutputFormat(AvroTrevniOutputFormat.class);    JobClient.runJob(job);    wordCountUtil.validateCountsFile();}
1b5d4c50bee0f9718c32ca9b845ca4caaee2b4d5fc00f7f99041d2f1a1f6aeef
map
public void map(GenericRecord r, AvroCollector<Void> collector, Reporter reporter) throws IOException
{    total += (Long) r.get("value");}
9032b9412a2c162acd8518fbcc3a2148141d159b035d98477412f0f0075938f4
testInputFormat
public void testInputFormat() throws Exception
{    JobConf job = new JobConf();    WordCountUtil wordCountUtil = new WordCountUtil("trevniMapredTest");    Schema subSchema = new Schema.Parser().parse("{\"type\":\"record\"," + "\"name\":\"PairValue\"," + "\"fields\": [ " + "{\"name\":\"value\", \"type\":\"long\"}" + "]}");    AvroJob.setInputSchema(job, subSchema);    AvroJob.setMapperClass(job, Counter.class);    FileInputFormat.setInputPaths(job, new Path(wordCountUtil.getDir().toString() + "/out/*"));    job.setInputFormat(AvroTrevniInputFormat.class);        job.setNumReduceTasks(0);        job.setOutputFormat(NullOutputFormat.class);    total = 0;    JobClient.runJob(job);    assertEquals(WordCountUtil.TOTAL, total);}
6dc036c7ce00f1b73831142d99c73e5879a75a342c7693f5e0499bde7c59eabc
getDir
public File getDir()
{    return dir;}
dac180acdc0c2da0b6fd7cc082adc55f0ab38944771299f6fe6bfe5f75a668e7
writeLinesFile
public void writeLinesFile() throws IOException
{    FileUtil.fullyDelete(dir);    DatumWriter<String> writer = new GenericDatumWriter<>();    DataFileWriter<String> out = new DataFileWriter<>(writer);    linesFiles.getParentFile().mkdirs();    out.create(Schema.create(Schema.Type.STRING), linesFiles);    for (String line : LINES) out.append(line);    out.close();}
ff4359d2302b712e3976702d218aa8972948897bb409254aaaa25d24109e2ab0
validateCountsFile
public void validateCountsFile() throws Exception
{    AvroColumnReader<Pair<String, Long>> reader = new AvroColumnReader<>(new AvroColumnReader.Params(countFiles).setModel(SpecificData.get()));    int numWords = 0;    for (Pair<String, Long> wc : reader) {        assertEquals(wc.key(), COUNTS.get(wc.key()), wc.value());        numWords++;    }    reader.close();    assertEquals(COUNTS.size(), numWords);}
8f7b0342cd00540d9e8233d31ff27d77d8e58a13b55f0ab40b7cc565b92d5086
validateCountsFileGenericRecord
public void validateCountsFileGenericRecord() throws Exception
{    AvroColumnReader<GenericRecord> reader = new AvroColumnReader<>(new AvroColumnReader.Params(countFiles).setModel(SpecificData.get()));    int numWords = 0;    for (GenericRecord wc : reader) {        assertEquals((String) wc.get("key"), COUNTS.get(wc.get("key")), wc.get("value"));                numWords++;    }    reader.close();    assertEquals(COUNTS.size(), numWords);}
c9f1c6399b8eb7a718d5913f9d996c0b78086f6adf9ae6dcf4653a255512240a
writeLength
public void writeLength(int l) throws IOException
{    assert this.length == 0;    assert l >= 0;    this.length = l;    if (l == runValue) {                runLength++;        return;    }        flushRun();    if (l == 1 || l == 0) {                runLength = 1;        runValue = l;    } else {                getBuffer().writeLength(l);    }}
528f02df7bea91a968269f2890ae90cb6ebfe16d891810b8521fe77a7cae1bc3
writeValue
public void writeValue(Object value) throws IOException
{    assert length > 0;    if (getMeta().getType() != ValueType.NULL) {        flushRun();        getBuffer().writeValue(value, getMeta().getType());    }    length -= 1;}
0a6e883257a4ab3b86419402d7a3713d31b27234c712351ddaac0d1609284110
flushBuffer
 void flushBuffer() throws IOException
{    flushRun();    super.flushBuffer();}
e71d8148709539686d67aee5cd8338f696b7a680e8331bfade6d696c0192c11b
flushRun
private void flushRun() throws IOException
{    if (    runLength == 0)        return;    else if (    runLength == 1)        getBuffer().writeLength(runValue);    else                getBuffer().writeLength((3 - runValue) - (runLength << 1));        runLength = 0;    runValue = NONE;}
257abb2e059d042c11ae743434baf0bd65da180b038478c6dcd7a8cbda0ab022
writeTo
public void writeTo(OutputBuffer out) throws IOException
{    out.writeFixed32(rowCount);    out.writeFixed32(uncompressedSize);    out.writeFixed32(compressedSize);}
25505996acab72e65140496c08fff4841639af2527b9470acd223d3085b22e4a
read
public static BlockDescriptor read(InputBuffer in) throws IOException
{    BlockDescriptor result = new BlockDescriptor();    result.rowCount = in.readFixed32();    result.uncompressedSize = in.readFixed32();    result.compressedSize = in.readFixed32();    return result;}
75d94ca8befa5fcf59a5e4a5d8b17008007f2c079b8ffaf75b4eb9fee2aab510
compress
 ByteBuffer compress(ByteBuffer uncompressedData) throws IOException
{    ByteArrayOutputStream baos = getOutputBuffer(uncompressedData.remaining());    try (BZip2CompressorOutputStream outputStream = new BZip2CompressorOutputStream(baos)) {        outputStream.write(uncompressedData.array());    }    ByteBuffer result = ByteBuffer.wrap(baos.toByteArray());    return result;}
fbda78aec9570e439f9c86d46472d57c00e82ab40cb4050a01a98e461ec8a458
decompress
 ByteBuffer decompress(ByteBuffer compressedData) throws IOException
{    ByteArrayInputStream bais = new ByteArrayInputStream(compressedData.array());    try (BZip2CompressorInputStream inputStream = new BZip2CompressorInputStream(bais)) {        ByteArrayOutputStream baos = new ByteArrayOutputStream();        byte[] buffer = new byte[DEFAULT_BUFFER_SIZE];        int readCount = -1;        while ((readCount = inputStream.read(buffer, compressedData.position(), buffer.length)) > 0) {            baos.write(buffer, 0, readCount);        }        ByteBuffer result = ByteBuffer.wrap(baos.toByteArray());        return result;    }}
401b1ec2640fcf0263c4f04854301af09f7e01a9e464c8d29e1cf62288406fc5
getOutputBuffer
private ByteArrayOutputStream getOutputBuffer(int suggestedLength)
{    if (null == outputBuffer)        outputBuffer = new ByteArrayOutputStream(suggestedLength);    outputBuffer.reset();    return outputBuffer;}
734a51aae8fb78d006b72753b991a4872bf9aa7b1066cb9e4b8987771ba4ceb6
get
public static Checksum get(MetaData meta)
{    String name = meta.getChecksum();    if (name == null || "null".equals(name))        return new NullChecksum();    else if ("crc32".equals(name))        return new Crc32Checksum();    else        throw new TrevniRuntimeException("Unknown checksum: " + name);}
b74d99b86f3297c86a2f672f051394ce2264f839bf35667ed62fd1843036f891
get
public static Codec get(MetaData meta)
{    String name = meta.getCodec();    if (name == null || "null".equals(name))        return new NullCodec();    else if ("deflate".equals(name))        return new DeflateCodec();    else if ("snappy".equals(name))        return new SnappyCodec();    else if ("bzip2".equals(name))        return new BZip2Codec();    else        throw new TrevniRuntimeException("Unknown codec: " + name);}
54920231bd20f5a9482e652aa7717e978e82be212bf3ad171f3110804f98e076
findBlock
public int findBlock(long row)
{    int block = Arrays.binarySearch(firstRows, row);    if (block < 0)        block = -block - 2;    return block;}
ef19a885ca1edb6177822b45ec9c65ada4ea9b6502c6667dcd264778a3b1f307
findBlock
public int findBlock(T value)
{    int block = Arrays.binarySearch(firstValues, value);    if (block < 0)        block = -block - 2;    return block;}
9cae6e7ef4fc548bf6df46522444aed156e7f870eb7875d2f5ee4ffb369c5ea0
blockCount
public int blockCount()
{    return blocks.length;}
d27676e3384a3085f02e7e7172654ca1931e7883bd611a3815e9e4dae3c31b8c
lastRow
public long lastRow(int block)
{    if (blocks.length == 0 || block < 0)        return 0;    return firstRows[block] + blocks[block].rowCount;}
94332a94f1957990fe5fd133879ac990e248976c85673d362abdb8348b99d5a9
ensureBlocksRead
public void ensureBlocksRead() throws IOException
{    if (blocks != null)        return;        InputBuffer in = new InputBuffer(file, start);    int blockCount = in.readFixed32();    BlockDescriptor[] blocks = new BlockDescriptor[blockCount];    if (metaData.hasIndexValues())        firstValues = (T[]) new Comparable[blockCount];    for (int i = 0; i < blockCount; i++) {        blocks[i] = BlockDescriptor.read(in);        if (metaData.hasIndexValues())            firstValues[i] = in.readValue(metaData.getType());    }    dataStart = in.tell();        Checksum checksum = Checksum.get(metaData);    blockStarts = new long[blocks.length];    firstRows = new long[blocks.length];    long startPosition = dataStart;    long row = 0;    for (int i = 0; i < blockCount; i++) {        BlockDescriptor b = blocks[i];        blockStarts[i] = startPosition;        firstRows[i] = row;        startPosition += b.compressedSize + checksum.size();        row += b.rowCount;    }    this.blocks = blocks;}
994c380ec1979437ab3f12cdb1e66b4ebcbdac6bff8e7b87ff4d4d12dc991141
read
 static ColumnFileMetaData read(InputBuffer in) throws IOException
{    ColumnFileMetaData result = new ColumnFileMetaData();    MetaData.read(in, result);    return result;}
a3384eda6088ab785128d7d88a9af55e07543a5e59774f8c7f30961ef025e4f5
getRowCount
public long getRowCount()
{    return rowCount;}
f437efb11c93fd3a8e3b8c776cbc97383e3b6c5756988ed8968c2b7bdc4c6122
getColumnCount
public long getColumnCount()
{    return columnCount;}
bae1db279928f737db30c65b465f09fb662e4ff06dd4510f47af7fa2e75105c9
getMetaData
public ColumnFileMetaData getMetaData()
{    return metaData;}
e1fecf76e990d52ddf37bffd41c495a23f11cfdfe9616be649e3eee7275b7a64
getColumnMetaData
public ColumnMetaData[] getColumnMetaData()
{    ColumnMetaData[] result = new ColumnMetaData[columnCount];    for (int i = 0; i < columnCount; i++) result[i] = columns[i].metaData;    return result;}
44ecfdda0ac598681f48d88a329d56398c2607c4eb514235c9de1de44bd16abf
getRoots
public List<ColumnMetaData> getRoots()
{    List<ColumnMetaData> result = new ArrayList<>();    for (int i = 0; i < columnCount; i++) if (columns[i].metaData.getParent() == null)        result.add(columns[i].metaData);    return result;}
65615164235e99e7e4c40af1010f0d54faf8e4fe8fc540fd6aec29d51b8c881a
getColumnMetaData
public ColumnMetaData getColumnMetaData(int number)
{    return columns[number].metaData;}
a76b0c9b19599323a6e42eb9dbcd1f6cd71e7226578d5ebc226771054ad848af
getColumnMetaData
public ColumnMetaData getColumnMetaData(String name)
{    return getColumn(name).metaData;}
c540c4b49b25af2460c2b729c000ec9dc6e9a19c75a020d88f15eb520e70b50f
getColumn
private ColumnDescriptor<T> getColumn(String name)
{    ColumnDescriptor column = columnsByName.get(name);    if (column == null)        throw new TrevniRuntimeException("No column named: " + name);    return (ColumnDescriptor<T>) column;}
4e6702dee413704c20e7f45de515d949bffdcdf1304328bfabccdc0ba554ce96
readHeader
private void readHeader() throws IOException
{    InputBuffer in = new InputBuffer(file, 0);    readMagic(in);    this.rowCount = in.readFixed64();    this.columnCount = in.readFixed32();    this.metaData = ColumnFileMetaData.read(in);    this.columnsByName = new HashMap<>(columnCount);    columns = new ColumnDescriptor[columnCount];    readColumnMetaData(in);    readColumnStarts(in);}
6005f44ed8443aa3b969f247d5be7af249edf0da10896c04ed6aba2bafda1acd
readMagic
private void readMagic(InputBuffer in) throws IOException
{    byte[] magic = new byte[ColumnFileWriter.MAGIC.length];    try {        in.readFully(magic);    } catch (IOException e) {        throw new IOException("Not a data file.");    }    if (!(Arrays.equals(ColumnFileWriter.MAGIC, magic) || !Arrays.equals(ColumnFileWriter.MAGIC_1, magic) || !Arrays.equals(ColumnFileWriter.MAGIC_0, magic)))        throw new IOException("Not a data file.");}
889581df1140720ac40413e25f92eebc29825cb689703b4dfbd0a0c4263a60ae
readColumnMetaData
private void readColumnMetaData(InputBuffer in) throws IOException
{    for (int i = 0; i < columnCount; i++) {        ColumnMetaData meta = ColumnMetaData.read(in, this);        meta.setDefaults(this.metaData);        ColumnDescriptor column = new ColumnDescriptor(file, meta);        columns[i] = column;        meta.setNumber(i);        columnsByName.put(meta.getName(), column);    }}
07785a2e61afacc02ad1f201c9d17c71265c1144cc0ab215e9f2e9f57353e499
readColumnStarts
private void readColumnStarts(InputBuffer in) throws IOException
{    for (int i = 0; i < columnCount; i++) columns[i].start = in.readFixed64();}
a1fe58543cb6d24a21292e671ae472809668781fae5720ad5f7e8e6475dcd121
getValues
public ColumnValues<T> getValues(String columnName) throws IOException
{    return new ColumnValues<>(getColumn(columnName));}
e6e58209c3b665237b4ad38dac392746d0cbe231322a560f0a6f191942432509
getValues
public ColumnValues<T> getValues(int column) throws IOException
{    return new ColumnValues<>(columns[column]);}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    file.close();}
4c39d722a6911727c3a3a9742047b989d4fc8afec00eb3798de1a3cb32c2c282
checkColumns
private void checkColumns(ColumnMetaData[] columnMeta)
{    Set<String> seen = new HashSet<>();    for (ColumnMetaData c : columnMeta) {        String name = c.getName();        if (seen.contains(name))            throw new TrevniRuntimeException("Duplicate column name: " + name);        ColumnMetaData parent = c.getParent();        if (parent != null && !seen.contains(parent.getName()))            throw new TrevniRuntimeException("Parent must precede child: " + name);        seen.add(name);    }}
531e675a3c7b402cb09c48ccf9dbf06c59beb160d694a26e788b9cd5b9502a76
incrementSize
 void incrementSize(int n)
{    size += n;}
4ede64ee24fd3c38c2371fa0a73712f8785794bf9c7db237043ed97b8841ebd6
sizeEstimate
public long sizeEstimate()
{    return size;}
bae1db279928f737db30c65b465f09fb662e4ff06dd4510f47af7fa2e75105c9
getMetaData
public ColumnFileMetaData getMetaData()
{    return metaData;}
305de2434b7f8749db1ec2b083552c33f83dcb99a5b3cccf94787d24d5500a77
getColumnCount
public int getColumnCount()
{    return columnCount;}
3110bc00874cb2d960ff397f8b8dafe1925b88606bfac477abab1794af867f99
writeRow
public void writeRow(Object... row) throws IOException
{    startRow();    for (int column = 0; column < columnCount; column++) writeValue(row[column], column);    endRow();}
a61ea10dedfbd754c973058840284b477950ed4ae901bfda7ab62155361416ea
startRow
public void startRow() throws IOException
{    for (int column = 0; column < columnCount; column++) columns[column].startRow();}
808a5c0af16b14ffff8cfa039587503fde2750142ae9ad692c6d6e790799db88
writeLength
public void writeLength(int length, int column) throws IOException
{    columns[column].writeLength(length);}
2f068877d0cd4c7685ccda9de244ce8182e74d79601dc9fa115af99988724c38
writeValue
public void writeValue(Object value, int column) throws IOException
{    columns[column].writeValue(value);}
9a8dcabd59bb98a3cf365ff78e338297104c537940f2ee91d63891c49430943a
endRow
public void endRow() throws IOException
{    for (int column = 0; column < columnCount; column++) columns[column].endRow();    rowCount++;}
3ce845d03de9f35f1f0120f732abb3a43951182384303f326935495de17f63b9
writeTo
public void writeTo(File file) throws IOException
{    try (OutputStream out = new FileOutputStream(file)) {        writeTo(out);    }}
7dc6be4554c74a17fd17d70feb1dc3c6f61c5fa8dae9c84dbc82b8c7a8ae9a29
writeTo
public void writeTo(OutputStream out) throws IOException
{    writeHeader(out);    for (int column = 0; column < columnCount; column++) columns[column].writeTo(out);}
19564b7555f7bc2531e9bf88280240df8d9bef2386a353a52a45235da5c6f27a
writeHeader
private void writeHeader(OutputStream out) throws IOException
{    OutputBuffer header = new OutputBuffer();        header.write(MAGIC);        header.writeFixed64(rowCount);        header.writeFixed32(columnCount);        metaData.write(header);    for (ColumnOutputBuffer column : columns)     column.getMeta().write(header);    for (long start : computeStarts(header.size()))     header.writeFixed64(start);    header.writeTo(out);}
d7c043520e163b2e314c51576b9d63aea5900a3804920faf51a7107d14e2d941
computeStarts
private long[] computeStarts(long start) throws IOException
{    long[] result = new long[columnCount];        start += columnCount * 8;    for (int column = 0; column < columnCount; column++) {        result[column] = start;        start += columns[column].size();    }    return result;}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return name;}
6f684cd43e61dbbf600cb7410bc5d551aeff24c0b03e25e8e9f181739d6b8aea
getType
public ValueType getType()
{    return type;}
daf7829393d5513651e4086059e94710bb05774ae5d9f61408b71a908fffb338
getParent
public ColumnMetaData getParent()
{    return parent;}
970bb3bfb43392b409d802a8fc1ada1e519fed055d50d56f5c94f432bc485e48
getChildren
public List<ColumnMetaData> getChildren()
{    return children;}
e6e30cbf78f74be0b14f7aab496c1a4a6ff408dd9a1258e2ef9b917251b25b75
isArray
public boolean isArray()
{    return isArray;}
1c13c8ecf23858866f0003ded43b76aae5d585b39d3b311bbbc0cda61980598d
getNumber
public int getNumber()
{    return number;}
2367366498f90b664e696b7405bcbbbe60e97e97d7080417ddf94ef6f6444e69
setNumber
 void setNumber(int number)
{    this.number = number;}
ca9125f364e0735a9795e1ff3cc160f9d5127126b2206128e6ae6a579a3146bb
hasIndexValues
public ColumnMetaData hasIndexValues(boolean values)
{    if (isArray)        throw new TrevniRuntimeException("Array column cannot have index: " + this);    this.values = values;    return setReservedBoolean(VALUES_KEY, values);}
3a9092863ce37364e487991cbcf0dc7560702b267d9f281958eb64d07bc49e5e
setParent
public ColumnMetaData setParent(ColumnMetaData parent)
{    if (!parent.isArray())        throw new TrevniRuntimeException("Parent is not an array: " + parent);    if (values)        throw new TrevniRuntimeException("Array column cannot have index: " + this);    this.parent = parent;    parent.children.add(this);    return setReserved(PARENT_KEY, parent.getName());}
6ffc0def139da3fea4cbcc4235bff46b4fc13fed1ffe29cfd8a488a9d922f545
isArray
public ColumnMetaData isArray(boolean isArray)
{    if (values)        throw new TrevniRuntimeException("Array column cannot have index: " + this);    this.isArray = isArray;    return setReservedBoolean(ARRAY_KEY, isArray);}
3690d005da6165fa8c5a7fd3675c4d0d722c1eaafcd62fc76292ea1065411aad
hasIndexValues
public boolean hasIndexValues()
{    return getBoolean(VALUES_KEY);}
48be644adff5c4118277b6210c3a3a3e2b77fafefec60dcd15ac93767d48a8a6
read
 static ColumnMetaData read(InputBuffer in, ColumnFileReader file) throws IOException
{    ColumnMetaData result = new ColumnMetaData();    MetaData.read(in, result);    result.name = result.getString(NAME_KEY);    result.type = ValueType.forName(result.getString(TYPE_KEY));    result.values = result.getBoolean(VALUES_KEY);    result.isArray = result.getBoolean(ARRAY_KEY);    String parentName = result.getString(PARENT_KEY);    if (parentName != null)        result.setParent(file.getColumnMetaData(parentName));    return result;}
09a956939bd7c1e4bdb8e56bdc59d186d1eca23caa2578b7f3645a3116973021
getMeta
public ColumnMetaData getMeta()
{    return meta;}
e735f3a7d22dcad60c3a3e3ed17e3ed1774f30ef390bbb549ab0eb7360aacb87
getBuffer
public OutputBuffer getBuffer()
{    return buffer;}
a61ea10dedfbd754c973058840284b477950ed4ae901bfda7ab62155361416ea
startRow
public void startRow() throws IOException
{    if (buffer.isFull())        flushBuffer();}
5898681bb1c43b37a789a2428ef24b9bce0d21326c76bf0e50f188894fc7e749
writeLength
public void writeLength(int length) throws IOException
{    throw new TrevniRuntimeException("Not an array column: " + meta);}
528f02df7bea91a968269f2890ae90cb6ebfe16d891810b8521fe77a7cae1bc3
writeValue
public void writeValue(Object value) throws IOException
{    buffer.writeValue(value, meta.getType());    if (meta.hasIndexValues() && rowCount == 0)        firstValues.add(buffer.toByteArray());}
9a8dcabd59bb98a3cf365ff78e338297104c537940f2ee91d63891c49430943a
endRow
public void endRow() throws IOException
{    rowCount++;}
0a6e883257a4ab3b86419402d7a3713d31b27234c712351ddaac0d1609284110
flushBuffer
 void flushBuffer() throws IOException
{    if (rowCount == 0)        return;    ByteBuffer raw = buffer.asByteBuffer();    ByteBuffer c = codec.compress(raw);    blockDescriptors.add(new BlockDescriptor(rowCount, raw.remaining(), c.remaining()));    ByteBuffer data = ByteBuffer.allocate(c.remaining() + checksum.size());    data.put(c);    data.put(checksum.compute(raw));    blockData.add(data.array());    int sizeIncrement =     (4 * 3) + (    firstValues != null ? firstValues.get(firstValues.size() - 1).length : 0) +     data.position();    writer.incrementSize(sizeIncrement);    size += sizeIncrement;    buffer = new OutputBuffer();    rowCount = 0;}
89e0335520973d3c0da416736789cc447e615057aa21eac4334d8cf7cd1f2ff2
size
public long size() throws IOException
{    flushBuffer();    return size;}
7dc6be4554c74a17fd17d70feb1dc3c6f61c5fa8dae9c84dbc82b8c7a8ae9a29
writeTo
public void writeTo(OutputStream out) throws IOException
{    OutputBuffer header = new OutputBuffer();    header.writeFixed32(blockDescriptors.size());    for (int i = 0; i < blockDescriptors.size(); i++) {        blockDescriptors.get(i).writeTo(header);        if (meta.hasIndexValues())            header.write(firstValues.get(i));    }    header.writeTo(out);    for (byte[] data : blockData) out.write(data);}
e96d76a488fef4b20920f75c146f61b09272d2cfcdce7e2407ec6b57bbf55690
getRow
public long getRow()
{    return row;}
cd1bd0f4185b49ddf80896fa53346011f50bd4f5b49c44250b7445116c724801
seek
public void seek(long r) throws IOException
{    if (    r < row || r >= column.lastRow(block))                startBlock(column.findBlock(r));    while (r > row && hasNext()) {                values.skipValue(type);        row++;    }    previous = null;}
7ac27488bf8875d84d3c180fc43f25ce47fc02ead132ef2087a1ed49520aca6d
seek
public void seek(T v) throws IOException
{    if (!column.metaData.hasIndexValues())        throw new TrevniRuntimeException("Column does not have value index: " + column.metaData.getName());    if (    previous == null || previous.compareTo(v) > 0 || (block != column.blockCount() - 1 && column.firstValues[block + 1].compareTo(v) <= 0))                startBlock(column.findBlock(v));    while (hasNext()) {                long savedPosition = values.tell();        T savedPrevious = previous;        if (next().compareTo(v) >= 0) {            values.seek(savedPosition);            previous = savedPrevious;            row--;            return;        }    }}
c543a32061c989ace053328290cd3483130c485c6cd76a01612039c15a4afc7e
startBlock
private void startBlock(int block) throws IOException
{    this.block = block;    this.row = column.firstRows[block];    in.seek(column.blockStarts[block]);    int end = column.blocks[block].compressedSize;    byte[] raw = new byte[end + checksum.size()];    in.readFully(raw);    ByteBuffer data = codec.decompress(ByteBuffer.wrap(raw, 0, end));    if (!checksum.compute(data).equals(ByteBuffer.wrap(raw, end, checksum.size())))        throw new IOException("Checksums mismatch.");    values = new InputBuffer(new InputBytes(data));}
0e723677317a453b15c6986c072fc4977b27401eb64776817756eb62d12f659f
iterator
public Iterator iterator()
{    return this;}
d51e5f7450eca0a0f63da1a466189e262d053b84aa767ba3be5cea740af7251b
hasNext
public boolean hasNext()
{    return block < column.blockCount() - 1 || row < column.lastRow(block);}
0065325c0b6db8e2da52a39fd2e7ee6b3c2e4399e222206472be21a840aad14f
next
public T next()
{    if (column.metaData.isArray() || column.metaData.getParent() != null)        throw new TrevniRuntimeException("Column is array: " + column.metaData.getName());    try {        startRow();        return nextValue();    } catch (IOException e) {        throw new TrevniRuntimeException(e);    }}
a61ea10dedfbd754c973058840284b477950ed4ae901bfda7ab62155361416ea
startRow
public void startRow() throws IOException
{    if (row >= column.lastRow(block)) {        if (block >= column.blockCount())            throw new TrevniRuntimeException("Read past end of column.");        startBlock(block + 1);    }    row++;}
eaf6fa6eae8e8afd801f570cfee3cc6fb527ec48d3228d3ad6d3e8b3ccb15a0d
nextLength
public int nextLength() throws IOException
{    if (!column.metaData.isArray())        throw new TrevniRuntimeException("Column is not array: " + column.metaData.getName());    assert arrayLength == 0;    return arrayLength = values.readLength();}
7200fd0dc877aaa38cbd1eea055f003e319aaff0d2bf31fef0bbf460e05eb408
nextValue
public T nextValue() throws IOException
{    arrayLength--;    return previous = values.readValue(type);}
eb35e4acc0ab2c89fd30970f01fba35488b3a4581b2af1986091209043508a3e
remove
public void remove()
{    throw new UnsupportedOperationException();}
72ef1e59027007ffe0950edfd2670ad03bb65cd6463d5d1d282dfeb1750435b0
size
public int size()
{    return 4;}
2f05e39177a2afea0f680c90d941d77bd8f37268e986765d790fd6a57d3bfdf0
compute
public ByteBuffer compute(ByteBuffer data)
{    crc32.reset();    crc32.update(data.array(), data.position(), data.remaining());    ByteBuffer result = ByteBuffer.allocate(size());    result.putInt((int) crc32.getValue());    result.flip();    return result;}
696019e56ef2a89a3ddf5cea3d7609811e27f671756c7376a235c8eaefed4729
compress
 ByteBuffer compress(ByteBuffer data) throws IOException
{    ByteArrayOutputStream baos = getOutputBuffer(data.remaining());    writeAndClose(data, new DeflaterOutputStream(baos, getDeflater()));    return ByteBuffer.wrap(baos.toByteArray());}
250066c948a28cf2efb0dd44beb620b049c850efae06cea3e8f8873debde45c9
decompress
 ByteBuffer decompress(ByteBuffer data) throws IOException
{    ByteArrayOutputStream baos = getOutputBuffer(data.remaining());    writeAndClose(data, new InflaterOutputStream(baos, getInflater()));    return ByteBuffer.wrap(baos.toByteArray());}
54ffa2acded2bd62c5da8f7899863636a6f69403a187661e9baed904163fd863
writeAndClose
private void writeAndClose(ByteBuffer data, OutputStream out) throws IOException
{    out.write(data.array(), data.position(), data.remaining());    out.close();}
09b02b9fee25b62b33a95139a30e3e006b6567625690194e257770c53d0b2ef6
getInflater
private Inflater getInflater()
{    if (null == inflater)        inflater = new Inflater(true);    inflater.reset();    return inflater;}
6e3bbec9964dd46b0123dc955df183f251bd84ca10b84debc9d2e120c4de411e
getDeflater
private Deflater getDeflater()
{    if (null == deflater)        deflater = new Deflater(Deflater.DEFAULT_COMPRESSION, true);    deflater.reset();    return deflater;}
401b1ec2640fcf0263c4f04854301af09f7e01a9e464c8d29e1cf62288406fc5
getOutputBuffer
private ByteArrayOutputStream getOutputBuffer(int suggestedLength)
{    if (null == outputBuffer)        outputBuffer = new ByteArrayOutputStream(suggestedLength);    outputBuffer.reset();    return outputBuffer;}
62032bfd4a1c0bb1c932a4c527e1d71aebf93308af8494a3c9f3705168a09088
seek
public void seek(long position) throws IOException
{    runLength = 0;    if (position >= (offset - limit) && position <= offset) {                pos = (int) (limit - (offset - position));        return;    }    pos = 0;    limit = 0;    offset = position;}
a10404ada8f0ac4c8bb65aec979730d7859aedb403c2b420b86e5a135b648a4f
tell
public long tell()
{    return (offset - limit) + pos;}
585528c061f4edf5b2b70ad857f58312659dac5be1809f2fc803a9ccaa2fb93e
length
public long length()
{    return inLength;}
41c1ea936be51cc5efe7e1536af465415c7c6d1d813ad7b90d1ed2f5bbca591e
readValue
public T readValue(ValueType type) throws IOException
{    switch(type) {        case NULL:            return null;        case BOOLEAN:            return (T) Boolean.valueOf(readBoolean());        case INT:            return (T) Integer.valueOf(readInt());        case LONG:            return (T) Long.valueOf(readLong());        case FIXED32:            return (T) Integer.valueOf(readFixed32());        case FIXED64:            return (T) Long.valueOf(readFixed64());        case FLOAT:            return (T) Float.valueOf(readFloat());        case DOUBLE:            return (T) Double.valueOf(readDouble());        case STRING:            return (T) readString();        case BYTES:            return (T) readBytes(null);        default:            throw new TrevniRuntimeException("Unknown value type: " + type);    }}
424ae743ba7e88dcc346ba0a53613edaf3e209cc9928d81eb811f8b07af690d5
skipValue
public void skipValue(ValueType type) throws IOException
{    switch(type) {        case NULL:            break;        case BOOLEAN:            readBoolean();            break;        case INT:            readInt();            break;        case LONG:            readLong();            break;        case FIXED32:        case FLOAT:            skip(4);            break;        case FIXED64:        case DOUBLE:            skip(8);            break;        case STRING:        case BYTES:            skipBytes();            break;        default:            throw new TrevniRuntimeException("Unknown value type: " + type);    }}
fbc49599759f8cdcf441295a1ef45ca6ee3d99e9d996d9533ab06d2378b36f10
readBoolean
public boolean readBoolean() throws IOException
{    if (bitCount == 0)        read();    int bits = buf[pos - 1] & 0xff;    int bit = (bits >> bitCount) & 1;    bitCount++;    if (bitCount == 8)        bitCount = 0;    return bit == 0 ? false : true;}
3ac50b32ecc052bfbe20e47f0e4eec0a2df2da92f56b3dbf53260bea838c1462
readLength
public int readLength() throws IOException
{    bitCount = 0;    if (runLength > 0) {                runLength--;        return runValue;    }    int length = readInt();    if (    length >= 0)        return length;        runLength = (1 - length) >>> 1;    runValue = (length + 1) & 1;    return runValue;}
f236e7fb1e87c9b6c5be0f35fb6c4eb85b118d1b426358e70800a74f43350299
readInt
public int readInt() throws IOException
{    if ((limit - pos) < 5) {                int b = read();        int n = b & 0x7f;        for (int shift = 7; b > 0x7f; shift += 7) {            b = read();            n ^= (b & 0x7f) << shift;        }                return (n >>> 1) ^ -(n & 1);    }    int len = 1;    int b = buf[pos] & 0xff;    int n = b & 0x7f;    if (b > 0x7f) {        b = buf[pos + len++] & 0xff;        n ^= (b & 0x7f) << 7;        if (b > 0x7f) {            b = buf[pos + len++] & 0xff;            n ^= (b & 0x7f) << 14;            if (b > 0x7f) {                b = buf[pos + len++] & 0xff;                n ^= (b & 0x7f) << 21;                if (b > 0x7f) {                    b = buf[pos + len++] & 0xff;                    n ^= (b & 0x7f) << 28;                    if (b > 0x7f) {                        throw new IOException("Invalid int encoding");                    }                }            }        }    }    pos += len;    if (pos > limit)        throw new EOFException();        return (n >>> 1) ^ -(n & 1);}
b6042ee68b2b47bac163d020b1d36c009b0f5b2b9d1a110e94e722663331fdf1
readLong
public long readLong() throws IOException
{    if ((limit - pos) < 10) {                int b = read();        long n = b & 0x7f;        for (int shift = 7; b > 0x7f; shift += 7) {            b = read();            n ^= (b & 0x7fL) << shift;        }                return (n >>> 1) ^ -(n & 1);    }    int b = buf[pos++] & 0xff;    int n = b & 0x7f;    long l;    if (b > 0x7f) {        b = buf[pos++] & 0xff;        n ^= (b & 0x7f) << 7;        if (b > 0x7f) {            b = buf[pos++] & 0xff;            n ^= (b & 0x7f) << 14;            if (b > 0x7f) {                b = buf[pos++] & 0xff;                n ^= (b & 0x7f) << 21;                if (b > 0x7f) {                                                            l = innerLongDecode((long) n);                } else {                    l = n;                }            } else {                l = n;            }        } else {            l = n;        }    } else {        l = n;    }    if (pos > limit) {        throw new EOFException();    }        return (l >>> 1) ^ -(l & 1);}
015998b3253c88688ad5486d8019a59bfc22ec3e8a0066ca1ae7918ab650e948
innerLongDecode
private long innerLongDecode(long l) throws IOException
{    int len = 1;    int b = buf[pos] & 0xff;    l ^= (b & 0x7fL) << 28;    if (b > 0x7f) {        b = buf[pos + len++] & 0xff;        l ^= (b & 0x7fL) << 35;        if (b > 0x7f) {            b = buf[pos + len++] & 0xff;            l ^= (b & 0x7fL) << 42;            if (b > 0x7f) {                b = buf[pos + len++] & 0xff;                l ^= (b & 0x7fL) << 49;                if (b > 0x7f) {                    b = buf[pos + len++] & 0xff;                    l ^= (b & 0x7fL) << 56;                    if (b > 0x7f) {                        b = buf[pos + len++] & 0xff;                        l ^= (b & 0x7fL) << 63;                        if (b > 0x7f) {                            throw new IOException("Invalid long encoding");                        }                    }                }            }        }    }    pos += len;    return l;}
3a29df2e279a1aa87799d508d3c09fea77ff7a4a1d2b413b32851226858ddce4
readFloat
public float readFloat() throws IOException
{    return Float.intBitsToFloat(readFixed32());}
d80462f635413e95a981717baa8dbef21f16867ae5e2c1ed11d2312479e265a2
readFixed32
public int readFixed32() throws IOException
{    if (    (limit - pos) < 4)        return read() | (read() << 8) | (read() << 16) | (read() << 24);    int len = 1;    int n = (buf[pos] & 0xff) | ((buf[pos + len++] & 0xff) << 8) | ((buf[pos + len++] & 0xff) << 16) | ((buf[pos + len++] & 0xff) << 24);    if ((pos + 4) > limit)        throw new EOFException();    pos += 4;    return n;}
5c17280cb2bd5e36b11f2e528a4a0334e3401e73556b4cd475f437cbff7261e1
readDouble
public double readDouble() throws IOException
{    return Double.longBitsToDouble(readFixed64());}
99da9582b38f1e22a3ea91e56a6b88e8aa4c703d039aca5fcfdfd514e86e36a5
readFixed64
public long readFixed64() throws IOException
{    return (readFixed32() & 0xFFFFFFFFL) | (((long) readFixed32()) << 32);}
ef9970bf7628dc4396fc3849d6482ac8a961658c0482c2176ac2ba144c6112c6
readString
public String readString() throws IOException
{    int length = readInt();    if (length <= (limit - pos)) {                String result = utf8.decode(ByteBuffer.wrap(buf, pos, length)).toString();        pos += length;        return result;    }    byte[] bytes = new byte[length];    readFully(bytes, 0, length);    return utf8.decode(ByteBuffer.wrap(bytes, 0, length)).toString();}
18deb01316075e40db5b01e60cc60bfdbe41265f8acb9f7a6bcf428c6a8a25c1
readBytes
public byte[] readBytes() throws IOException
{    byte[] result = new byte[readInt()];    readFully(result);    return result;}
3f9351d2d96b71b9ade6333ab2de3b2fedb54eccbebc9ac546b7000019518e0f
readBytes
public ByteBuffer readBytes(ByteBuffer old) throws IOException
{    int length = readInt();    ByteBuffer result;    if (old != null && length <= old.capacity()) {        result = old;        result.clear();    } else {        result = ByteBuffer.allocate(length);    }    readFully(result.array(), result.position(), length);    result.limit(length);    return result;}
2b7cdc89689872436aab53b6467b336e2c628ced0f6e4bbfc31fb05f7b33fc9c
skipBytes
public void skipBytes() throws IOException
{    skip(readInt());}
90b9d6d41dd2d379317dbb61535d62113a91742b6470c56e313ef3cce4df5c30
skip
private void skip(long length) throws IOException
{    seek(tell() + length);}
00c6cb892813c6b89e072a7f09dccdece629f30849daab28245b06f3e679bf54
read
public int read() throws IOException
{    if (pos >= limit) {        limit = readInput(buf, 0, buf.length);        pos = 0;    }    return buf[pos++] & 0xFF;}
6393462ea979ef8532c28bb0edd9b6422e4a0d9ddd3547cc24589fe4a0d75955
readFully
public void readFully(byte[] bytes) throws IOException
{    readFully(bytes, 0, bytes.length);}
715c9d664f161880709dd932f02fb9e3cc1877d4eb29878dabf25a019b03537c
readFully
public void readFully(byte[] bytes, int start, int len) throws IOException
{    int buffered = limit - pos;    if (len > buffered) {                        System.arraycopy(buf, pos, bytes, start, buffered);        start += buffered;        len -= buffered;        pos += buffered;        if (len > buf.length) {                        do {                                int read = readInput(bytes, start, len);                len -= read;                start += read;            } while (len > 0);            return;        }                limit = readInput(buf, 0, buf.length);        pos = 0;    }        System.arraycopy(buf, pos, bytes, start, len);    pos += len;}
4025743e170a31aa24f87feb93b5c66446ce64de1dec69a75f7112f7215537fb
readInput
private int readInput(byte[] b, int start, int len) throws IOException
{    int read = in.read(offset, b, start, len);    if (read < 0)        throw new EOFException();    offset += read;    return read;}
6be07d6c52de04a91907264c1c435ebdd48a3b2cf48f2e117699a543fff56681
length
public long length() throws IOException
{    return this.count;}
b45f2680614ae401c855b86f662f24a44ddb2734f8418631a6187f238d237199
read
public synchronized int read(long pos, byte[] b, int start, int len) throws IOException
{    this.pos = (int) pos;    return read(b, start, len);}
7cf47f69ddbbf6af6deef760b8e111827128bc69497dc48ef3e0c32a16762b0d
getBuffer
 byte[] getBuffer()
{    return buf;}
6be07d6c52de04a91907264c1c435ebdd48a3b2cf48f2e117699a543fff56681
length
public long length() throws IOException
{    return channel.size();}
03548b5be0b202c056e7ac535fce053f51f8d81b6abab971786749fae7e407f5
read
public int read(long position, byte[] b, int start, int len) throws IOException
{    return channel.read(ByteBuffer.wrap(b, start, len), position);}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    channel.close();}
67b179b980f057bd6c93f3105d328f2934e8cbb000a86da718f0a5578b2f93ac
setDefaults
 void setDefaults(MetaData defaults)
{    this.defaults = defaults;}
a346cd6cfa43801346dbdcc6563501719bdc00d620b4a7174d54303bd27e504d
getCodec
public String getCodec()
{    return getString(CODEC_KEY);}
867e33d9a913d7584f93f3f3cf8f6c4d4985de0798c77746613c0652f857dd3d
setCodec
public T setCodec(String codec)
{    setReserved(CODEC_KEY, codec);    return (T) this;}
1e8c0d007a8161552c170c17e750c52668f37489983289f2762db69bd3cc617c
getChecksum
public String getChecksum()
{    return getString(CHECKSUM_KEY);}
4429676734fe4cdb03f772de860914f93ec9a911938291fa63a37523228f65e7
setChecksum
public T setChecksum(String checksum)
{    setReserved(CHECKSUM_KEY, checksum);    return (T) this;}
95011ca7e877e72f1ee94653f93a4d1e5400136e489fa807cc2773a2b3b24f0b
getString
public String getString(String key)
{    byte[] value = get(key);    if (value == null && defaults != null)        value = defaults.get(key);    if (value == null)        return null;    return new String(value, StandardCharsets.UTF_8);}
b4179b0511d9ed453a0eb323e82cc948315a858bbef34be933476228bcf93491
getLong
public long getLong(String key)
{    return Long.parseLong(getString(key));}
9184bdf1fb3843577cb65000cbb4f296363425f67e3b112ff43c85fa62e89f9f
getBoolean
public boolean getBoolean(String key)
{    return get(key) != null;}
be16a8444ed21c344b63f378c5d9c277b171aec31d0eaaeba838a1f0de6aaff1
set
public T set(String key, byte[] value)
{    if (isReserved(key)) {        throw new TrevniRuntimeException("Cannot set reserved key: " + key);    }    put(key, value);    return (T) this;}
dbefeb6eeed91b417d752c1d1d098b5b10bfebf5f842371bc56a9b8085b8326f
isReserved
public static boolean isReserved(String key)
{    return key.startsWith(RESERVED_KEY_PREFIX);}
b719a336bb9803dc0d0c85527d844a5ad7b7d8b98978da71bdeed65ef7a5e2fc
set
public T set(String key, String value)
{    return set(key, value.getBytes(StandardCharsets.UTF_8));}
3c974e309d21b1112978d6ac963ec2344dbe96b3c695aceae13eda13040f2e4b
setReserved
 T setReserved(String key, String value)
{    put(key, value.getBytes(StandardCharsets.UTF_8));    return (T) this;}
e096101318348b193172eee26545d165a4e708045cbddd9c362101dc7c8ef43a
setReservedBoolean
 T setReservedBoolean(String key, boolean value)
{    if (value)        setReserved(key, "");    else        remove(key);    return (T) this;}
f9ad6d5f0238d4f4941e037816937077fa6967722c2c0096210cf504641cf851
set
public T set(String key, long value)
{    return set(key, Long.toString(value));}
0695dc90f30a9ddd83dee27bdc0ef17cb74843652896c213415bf832bbc6586d
write
 void write(OutputBuffer out) throws IOException
{    out.writeInt(size());    for (Map.Entry<String, byte[]> e : entrySet()) {        out.writeString(e.getKey());        out.writeBytes(e.getValue());    }}
6d0fbcb4a6e910ca6f53ac2e8941d55b69a91c7c913b7257e8265e2dad39e9aa
read
 static void read(InputBuffer in, MetaData<?> metaData) throws IOException
{    int size = in.readInt();    for (int i = 0; i < size; i++) metaData.put(in.readString(), in.readBytes());}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    StringBuilder builder = new StringBuilder();    builder.append('{').append(' ');    for (Map.Entry<String, byte[]> e : entrySet()) {        builder.append(e.getKey());        builder.append('=');        builder.append(new String(e.getValue(), StandardCharsets.ISO_8859_1));        builder.append(' ');    }    builder.append('}');    return builder.toString();}
72ef1e59027007ffe0950edfd2670ad03bb65cd6463d5d1d282dfeb1750435b0
size
public int size()
{    return 0;}
2f05e39177a2afea0f680c90d941d77bd8f37268e986765d790fd6a57d3bfdf0
compute
public ByteBuffer compute(ByteBuffer data)
{    return ByteBuffer.allocate(0);}
c1cd1bb57201bae44d62b88e0c3ef1e288b41ac1fa616f0dc37ee63c7df9267e
compress
 ByteBuffer compress(ByteBuffer buffer) throws IOException
{    return buffer;}
250066c948a28cf2efb0dd44beb620b049c850efae06cea3e8f8873debde45c9
decompress
 ByteBuffer decompress(ByteBuffer data) throws IOException
{    return data;}
f9250f7e93eb3e332b3a283988590da4bb96eedcb77601ca789df57a5a3031fe
isFull
public boolean isFull()
{    return size() >= BLOCK_SIZE;}
3d6dce9daf5bed83730260ea5c3c83676f2bb9e868907844d8516a8f00004f42
asByteBuffer
public ByteBuffer asByteBuffer()
{    return ByteBuffer.wrap(buf, 0, count);}
9d75add77811c61f3ce4ca41168a84363b2503de1bab8b72ca6747d44fcc3f9c
writeValue
public void writeValue(Object value, ValueType type) throws IOException
{    switch(type) {        case NULL:            break;        case BOOLEAN:            writeBoolean((Boolean) value);            break;        case INT:            writeInt((Integer) value);            break;        case LONG:            writeLong((Long) value);            break;        case FIXED32:            writeFixed32((Integer) value);            break;        case FIXED64:            writeFixed64((Long) value);            break;        case FLOAT:            writeFloat((Float) value);            break;        case DOUBLE:            writeDouble((Double) value);            break;        case STRING:            writeString((String) value);            break;        case BYTES:            if (value instanceof ByteBuffer)                writeBytes((ByteBuffer) value);            else                writeBytes((byte[]) value);            break;        default:            throw new TrevniRuntimeException("Unknown value type: " + type);    }}
080e0449c1cd71976f88fcb3e82efafaa5fe26bd210a895c74f7ecb59dcbaa63
writeBoolean
public void writeBoolean(boolean value)
{    if (bitCount == 0) {                ensure(1);        count++;    }    if (value)        buf[count - 1] |= (byte) (1 << bitCount);    bitCount++;    if (bitCount == 8)        bitCount = 0;}
5898681bb1c43b37a789a2428ef24b9bce0d21326c76bf0e50f188894fc7e749
writeLength
public void writeLength(int length) throws IOException
{    bitCount = 0;    writeInt(length);}
96bc6a095954cfd9254d26f959f52e92cd7b9fee81a771dc57d7d1d251dd6db8
writeString
public void writeString(String string) throws IOException
{    byte[] bytes = string.getBytes(StandardCharsets.UTF_8);    writeInt(bytes.length);    write(bytes, 0, bytes.length);}
ac2c45d24139a4bb23e85180c6021c19f0549ba3fe6df783338039feb11224a3
writeBytes
public void writeBytes(ByteBuffer bytes)
{    int pos = bytes.position();    int start = bytes.arrayOffset() + pos;    int len = bytes.limit() - pos;    writeBytes(bytes.array(), start, len);}
e4b4bf5860c1cce7e1ef0f88d9d5268ba0ebd23ca2e83202ac6932979dcf9fb1
writeBytes
public void writeBytes(byte[] bytes)
{    writeBytes(bytes, 0, bytes.length);}
91fdf7f5dd02c22b1ac4922a95b628dc03b5f14ce63a75ee9964fc3303f968bb
writeBytes
public void writeBytes(byte[] bytes, int start, int len)
{    writeInt(len);    write(bytes, start, len);}
485832ef5d131a3779da1c259796c40decbe270ca77fd7c3bd67453210649270
writeFloat
public void writeFloat(float f) throws IOException
{    writeFixed32(Float.floatToRawIntBits(f));}
b0e7b254d45c2210c8fda5ed2caaef6ca76fec51fb5d6a536add22a8a39ae5e9
writeDouble
public void writeDouble(double d) throws IOException
{    writeFixed64(Double.doubleToRawLongBits(d));}
2dfe615950a33ee8a072f4fabb0ede3c76bfd732dce98a05569a51049e0ab618
writeFixed32
public void writeFixed32(int i) throws IOException
{    ensure(4);    buf[count] = (byte) ((i) & 0xFF);    buf[count + 1] = (byte) ((i >>> 8) & 0xFF);    buf[count + 2] = (byte) ((i >>> 16) & 0xFF);    buf[count + 3] = (byte) ((i >>> 24) & 0xFF);    count += 4;}
e16f1a446ea09da22d5bd93b4def574a4c8c6733c2bdfda8833fe495b9601975
writeFixed64
public void writeFixed64(long l) throws IOException
{    ensure(8);    int first = (int) (l & 0xFFFFFFFF);    int second = (int) ((l >>> 32) & 0xFFFFFFFF);    buf[count] = (byte) ((first) & 0xFF);    buf[count + 4] = (byte) ((second) & 0xFF);    buf[count + 5] = (byte) ((second >>> 8) & 0xFF);    buf[count + 1] = (byte) ((first >>> 8) & 0xFF);    buf[count + 2] = (byte) ((first >>> 16) & 0xFF);    buf[count + 6] = (byte) ((second >>> 16) & 0xFF);    buf[count + 7] = (byte) ((second >>> 24) & 0xFF);    buf[count + 3] = (byte) ((first >>> 24) & 0xFF);    count += 8;}
48c8d8e69eccdeff06e87b837d204c76f396b8a78d707365263c0bc1588c691b
writeInt
public void writeInt(int n)
{    ensure(5);        n = (n << 1) ^ (n >> 31);    if ((n & ~0x7F) != 0) {        buf[count++] = (byte) ((n | 0x80) & 0xFF);        n >>>= 7;        if (n > 0x7F) {            buf[count++] = (byte) ((n | 0x80) & 0xFF);            n >>>= 7;            if (n > 0x7F) {                buf[count++] = (byte) ((n | 0x80) & 0xFF);                n >>>= 7;                if (n > 0x7F) {                    buf[count++] = (byte) ((n | 0x80) & 0xFF);                    n >>>= 7;                }            }        }    }    buf[count++] = (byte) n;}
9d5f02c473bb90aaa95e11d7e93625ba8050b2ae1b4b94e45331333ecc81fb92
writeLong
public void writeLong(long n) throws IOException
{    ensure(10);        n = (n << 1) ^ (n >> 63);    if ((n & ~0x7FL) != 0) {        buf[count++] = (byte) ((n | 0x80) & 0xFF);        n >>>= 7;        if (n > 0x7F) {            buf[count++] = (byte) ((n | 0x80) & 0xFF);            n >>>= 7;            if (n > 0x7F) {                buf[count++] = (byte) ((n | 0x80) & 0xFF);                n >>>= 7;                if (n > 0x7F) {                    buf[count++] = (byte) ((n | 0x80) & 0xFF);                    n >>>= 7;                    if (n > 0x7F) {                        buf[count++] = (byte) ((n | 0x80) & 0xFF);                        n >>>= 7;                        if (n > 0x7F) {                            buf[count++] = (byte) ((n | 0x80) & 0xFF);                            n >>>= 7;                            if (n > 0x7F) {                                buf[count++] = (byte) ((n | 0x80) & 0xFF);                                n >>>= 7;                                if (n > 0x7F) {                                    buf[count++] = (byte) ((n | 0x80) & 0xFF);                                    n >>>= 7;                                    if (n > 0x7F) {                                        buf[count++] = (byte) ((n | 0x80) & 0xFF);                                        n >>>= 7;                                    }                                }                            }                        }                    }                }            }        }    }    buf[count++] = (byte) n;}
93d8dd98fe0d888833f806ed2ed787fd16bbfffe4e87e8cfc2be2f54a345b200
ensure
private void ensure(int n)
{    if (count + n > buf.length)        buf = Arrays.copyOf(buf, Math.max(buf.length << 1, count + n));}
a9edcd12e38870ecae898c5cbc72c6e29c38aa652ea2de830816424195aa9926
size
public static int size(Object value, ValueType type)
{    switch(type) {        case NULL:            return 0;        case INT:            return size((Integer) value);        case LONG:            return size((Long) value);        case FIXED32:        case FLOAT:            return 4;        case FIXED64:        case DOUBLE:            return 8;        case STRING:            return size((String) value);        case BYTES:            if (value instanceof ByteBuffer)                return size((ByteBuffer) value);            return size((byte[]) value);        default:            throw new TrevniRuntimeException("Unknown value type: " + type);    }}
973178b26e3a26a653921ea4192c953a5214e9b1cf721435c0d24647b4da3d58
size
public static int size(int n)
{        n = (n << 1) ^ (n >> 31);    if (n <= (1 << (7 * 1)) - 1)        return 1;    if (n <= (1 << (7 * 2)) - 1)        return 2;    if (n <= (1 << (7 * 3)) - 1)        return 3;    if (n <= (1 << (7 * 4)) - 1)        return 4;    return 5;}
72333303acd7f98db99d9b545ab4380bc11b018f60803b82a7b9a5612a02db14
size
public static int size(long n)
{        n = (n << 1) ^ (n >> 63);    if (n <= (1 << (7 * 1)) - 1)        return 1;    if (n <= (1 << (7 * 2)) - 1)        return 2;    if (n <= (1 << (7 * 3)) - 1)        return 3;    if (n <= (1 << (7 * 4)) - 1)        return 4;    if (n <= (1 << (7 * 5)) - 1)        return 5;    if (n <= (1 << (7 * 6)) - 1)        return 6;    if (n <= (1 << (7 * 7)) - 1)        return 7;    if (n <= (1 << (7 * 8)) - 1)        return 8;    if (n <= (1 << (7 * 9)) - 1)        return 9;    return 10;}
17d1cad1f1447900b43f45c5cc3c7bc30a10ee0be36b99354d37e65247998c16
size
public static int size(ByteBuffer bytes)
{    int length = bytes.remaining();    return size(length) + length;}
cc57ac5a228eb79ba8096e9ac7b01f5471cd46261bbf9f402e047e59b03a5769
size
public static int size(byte[] bytes)
{    int length = bytes.length;    return size(length) + length;}
109726234d6bd7d7787ff2efe08872da47fc4f1c941e5fb90e6122c6aad46c2d
size
public static int size(String string)
{    int length = utf8Length(string);    return size(length) + length;}
057a0f37f30d60de02bd963de2483b82bf03db08a95db471e373288b374385c9
utf8Length
private static int utf8Length(String string)
{    int stringLength = string.length();    int utf8Length = 0;    for (int i = 0; i < stringLength; i++) {        char c = string.charAt(i);                int p = c;        if (        Character.isHighSurrogate(c) && i != stringLength - 1 && Character.isLowSurrogate(string.charAt(i + 1))) {            p = string.codePointAt(i);            i++;        }        if (p <= 0x007F) {            utf8Length += 1;        } else if (p <= 0x07FF) {            utf8Length += 2;        } else if (p <= 0x0FFFF) {            utf8Length += 3;        } else if (p <= 0x01FFFFF) {            utf8Length += 4;        } else if (p <= 0x03FFFFFF) {            utf8Length += 5;        } else {            utf8Length += 6;        }    }    return utf8Length;}
978fbe2b42f0db7429a43d41d33d0de794c7e7096811dca1a8c8731a74d8926e
compress
 ByteBuffer compress(ByteBuffer in) throws IOException
{    ByteBuffer out = ByteBuffer.allocate(Snappy.maxCompressedLength(in.remaining()));    int size = Snappy.compress(in.array(), in.position(), in.remaining(), out.array(), 0);    out.limit(size);    return out;}
772e74baaa98022aeff9ed09e91b36856cffc195190fc58f758f1fcd2ff9b2f4
decompress
 ByteBuffer decompress(ByteBuffer in) throws IOException
{    ByteBuffer out = ByteBuffer.allocate(Snappy.uncompressedLength(in.array(), in.position(), in.remaining()));    int size = Snappy.uncompress(in.array(), in.position(), in.remaining(), out.array(), 0);    out.limit(size);    return out;}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return name;}
45e27cf29e20fb2bb92e4ff9f6bbda1720931e122ed475e346c6bbe7ed363e74
forName
public static ValueType forName(String name)
{    return valueOf(name.toUpperCase());}
30597474fcde8a79f16922aa8745264267a7907863a62dbefe1141ab4b6d3ea5
testBZip2CompressionAndDecompression
public void testBZip2CompressionAndDecompression() throws IOException
{    MetaData meta = new MetaData();    meta.setCodec("bzip2");    Codec codec = Codec.get(meta);        assertTrue(codec instanceof BZip2Codec);        final int inputByteSize = BZip2Codec.DEFAULT_BUFFER_SIZE * 3 + 42;    byte[] inputByteArray = new byte[inputByteSize];        for (int i = 0; i < inputByteSize; i++) {        inputByteArray[i] = (byte) (65 + i % 10);    }    ByteBuffer inputByteBuffer = ByteBuffer.wrap(inputByteArray);    ByteBuffer compressedBuffer = codec.compress(inputByteBuffer);        assertTrue(compressedBuffer.array().length > 0);        assertTrue(compressedBuffer.array().length < inputByteArray.length);    ByteBuffer decompressedBuffer = codec.decompress(compressedBuffer);        assertTrue(decompressedBuffer.array().length == inputByteArray.length);        byte[] outputByteArray = decompressedBuffer.array();    System.arraycopy(outputByteArray, 0, inputByteArray, 0, inputByteSize);}
88141cb8b147177c052bd9b541815ed496bfe9cd9b2be46a0cee0f2055007ea6
codecs
public static Collection<Object[]> codecs()
{    Object[][] data = new Object[][] { { "null", "null" }, { "snappy", "crc32" }, { "deflate", "crc32" } };    return Arrays.asList(data);}
43dd14172db634fe37f061adf42e3e616f882946ae88843dadea62e578b0fc9b
createFileMeta
private ColumnFileMetaData createFileMeta()
{    return new ColumnFileMetaData().setCodec(codec).setChecksum(checksum);}
eba263d6d43b4bf0c451fb0994633a5d479499e049282bf4454251e74320e56c
testEmptyFile
public void testEmptyFile() throws Exception
{    FILE.delete();    ColumnFileWriter out = new ColumnFileWriter(createFileMeta());    out.writeTo(FILE);    ColumnFileReader in = new ColumnFileReader(FILE);    Assert.assertEquals(0, in.getRowCount());    Assert.assertEquals(0, in.getColumnCount());    in.close();}
0dad44c0fb675935e87436de864e3a5ecd644d2639c79b1c97427a9c6aa5eb98
testEmptyColumn
public void testEmptyColumn() throws Exception
{    FILE.delete();    ColumnFileWriter out = new ColumnFileWriter(createFileMeta(), new ColumnMetaData("test", ValueType.INT));    out.writeTo(FILE);    ColumnFileReader in = new ColumnFileReader(FILE);    Assert.assertEquals(0, in.getRowCount());    Assert.assertEquals(1, in.getColumnCount());    ColumnValues<Integer> values = in.getValues("test");    for (int i : values) throw new Exception("no value should be found");    in.close();}
87a0509e3d751a09958c76736edf24b82cf4f34f36e6dbd8416cb8549672c294
testInts
public void testInts() throws Exception
{    FILE.delete();    ColumnFileWriter out = new ColumnFileWriter(createFileMeta(), new ColumnMetaData("test", ValueType.INT));    Random random = TestUtil.createRandom();    for (int i = 0; i < COUNT; i++) out.writeRow(TestUtil.randomLength(random));    out.writeTo(FILE);    random = TestUtil.createRandom();    ColumnFileReader in = new ColumnFileReader(FILE);    Assert.assertEquals(COUNT, in.getRowCount());    Assert.assertEquals(1, in.getColumnCount());    Iterator<Integer> i = in.getValues("test");    int count = 0;    while (i.hasNext()) {        Assert.assertEquals(TestUtil.randomLength(random), (int) i.next());        count++;    }    Assert.assertEquals(COUNT, count);}
210664bb3b8e624776d43a4553f388e56c67ba013adccea71de09a9f4b50be69
testLongs
public void testLongs() throws Exception
{    FILE.delete();    ColumnFileWriter out = new ColumnFileWriter(createFileMeta(), new ColumnMetaData("test", ValueType.LONG));    Random random = TestUtil.createRandom();    for (int i = 0; i < COUNT; i++) out.writeRow(random.nextLong());    out.writeTo(FILE);    random = TestUtil.createRandom();    ColumnFileReader in = new ColumnFileReader(FILE);    Assert.assertEquals(COUNT, in.getRowCount());    Assert.assertEquals(1, in.getColumnCount());    Iterator<Long> i = in.getValues("test");    int count = 0;    while (i.hasNext()) {        Assert.assertEquals(random.nextLong(), (long) i.next());        count++;    }    Assert.assertEquals(COUNT, count);}
37e02f1db2e414ea7f0c67dd56d408fb5fec1cc80a57622d72140d3686bc482c
testStrings
public void testStrings() throws Exception
{    FILE.delete();    ColumnFileWriter out = new ColumnFileWriter(createFileMeta(), new ColumnMetaData("test", ValueType.STRING));    Random random = TestUtil.createRandom();    for (int i = 0; i < COUNT; i++) out.writeRow(TestUtil.randomString(random));    out.writeTo(FILE);    random = TestUtil.createRandom();    ColumnFileReader in = new ColumnFileReader(FILE);    Assert.assertEquals(COUNT, in.getRowCount());    Assert.assertEquals(1, in.getColumnCount());    Iterator<String> i = in.getValues("test");    int count = 0;    while (i.hasNext()) {        Assert.assertEquals(TestUtil.randomString(random), i.next());        count++;    }    Assert.assertEquals(COUNT, count);}
7377d5f31587268f2e1d5b355873bbf11559d97654385f0b34fb7acc9f96c22a
testTwoColumn
public void testTwoColumn() throws Exception
{    FILE.delete();    ColumnFileWriter out = new ColumnFileWriter(createFileMeta(), new ColumnMetaData("a", ValueType.FIXED32), new ColumnMetaData("b", ValueType.STRING));    Random random = TestUtil.createRandom();    for (int i = 0; i < COUNT; i++) out.writeRow(random.nextInt(), TestUtil.randomString(random));    out.writeTo(FILE);    random = TestUtil.createRandom();    ColumnFileReader in = new ColumnFileReader(FILE);    Assert.assertEquals(COUNT, in.getRowCount());    Assert.assertEquals(2, in.getColumnCount());    Iterator<String> i = in.getValues("a");    Iterator<String> j = in.getValues("b");    int count = 0;    while (i.hasNext() && j.hasNext()) {        Assert.assertEquals(random.nextInt(), i.next());        Assert.assertEquals(TestUtil.randomString(random), j.next());        count++;    }    Assert.assertEquals(COUNT, count);}
3628d9162e56cc20d18eb9ce0f4da8580c855c3b40a7861ae876d25393105162
testSeekLongs
public void testSeekLongs() throws Exception
{    FILE.delete();    ColumnFileWriter out = new ColumnFileWriter(createFileMeta(), new ColumnMetaData("test", ValueType.LONG));    Random random = TestUtil.createRandom();    int seekCount = COUNT / 1024;    int[] seekRows = new int[seekCount];    Map<Integer, Integer> seekRowMap = new HashMap<>(seekCount);    while (seekRowMap.size() < seekCount) {        int row = random.nextInt(COUNT);        if (!seekRowMap.containsKey(row)) {            seekRows[seekRowMap.size()] = row;            seekRowMap.put(row, seekRowMap.size());        }    }    Long[] seekValues = new Long[seekCount];    for (int i = 0; i < COUNT; i++) {        long l = random.nextLong();        out.writeRow(l);        if (seekRowMap.containsKey(i))            seekValues[seekRowMap.get(i)] = l;    }    out.writeTo(FILE);    ColumnFileReader in = new ColumnFileReader(FILE);    ColumnValues<Long> v = in.getValues("test");    for (int i = 0; i < seekCount; i++) {        v.seek(seekRows[i]);        Assert.assertEquals(seekValues[i], v.next());    }}
d9d780c7dd0adff04da5bf43bf69d68a12234733fb34c6c1dcf6f5219e4ce0d6
testSeekStrings
public void testSeekStrings() throws Exception
{    FILE.delete();    ColumnFileWriter out = new ColumnFileWriter(createFileMeta(), new ColumnMetaData("test", ValueType.STRING).hasIndexValues(true));    Random random = TestUtil.createRandom();    int seekCount = COUNT / 1024;    Map<Integer, Integer> seekRowMap = new HashMap<>(seekCount);    while (seekRowMap.size() < seekCount) {        int row = random.nextInt(COUNT);        if (!seekRowMap.containsKey(row))            seekRowMap.put(row, seekRowMap.size());    }    String[] values = new String[COUNT];    for (int i = 0; i < COUNT; i++) values[i] = TestUtil.randomString(random);    Arrays.sort(values);    String[] seekValues = new String[seekCount];    for (int i = 0; i < COUNT; i++) {        out.writeRow(values[i]);        if (seekRowMap.containsKey(i))            seekValues[seekRowMap.get(i)] = values[i];    }    out.writeTo(FILE);    ColumnFileReader in = new ColumnFileReader(FILE);    ColumnValues<String> v = in.getValues("test");    for (int i = 0; i < seekCount; i++) {        v.seek(seekValues[i]);        Assert.assertEquals(seekValues[i], v.next());    }}
9d1ea4523e6e6ccbbfd80229813dfda153108035db2dcebd2e561a0a2a7d60ef
testRandomReads
public void testRandomReads() throws Exception
{    Random random = new Random(19820210);    int length = random.nextInt(SIZE) + 1;    byte[] data = new byte[length];    random.nextBytes(data);    Input in = new InputBytes(data);    for (int i = 0; i < COUNT; i++) {        int p = random.nextInt(length);        int l = Math.min(random.nextInt(SIZE / 10), length - p);        byte[] buffer = new byte[l];        in.read(p, buffer, 0, l);        Assert.assertArrayEquals(Arrays.copyOfRange(data, p, p + l), buffer);    }}
78a274d3e62b678bde84ffa04fce2257229222b9cdb81f0cda384c23968ba864
testEmpty
public void testEmpty() throws Exception
{    OutputBuffer out = new OutputBuffer();    ByteArrayOutputStream temp = new ByteArrayOutputStream();    InputBuffer in = new InputBuffer(new InputBytes(out.toByteArray()));    Assert.assertEquals(0, in.tell());    Assert.assertEquals(0, in.length());}
5de194d72189e96f533768a604debaffef004bf6cbca462f9e2bcc3c7fa9f8e4
testZero
public void testZero() throws Exception
{    Random random = TestUtil.createRandom();    OutputBuffer out = new OutputBuffer();    out.writeInt(0);    byte[] bytes = out.toByteArray();    Assert.assertEquals(1, bytes.length);    Assert.assertEquals(0, bytes[0]);    InputBuffer in = new InputBuffer(new InputBytes(out.toByteArray()));    Assert.assertEquals(0, in.readInt());}
1c4ead9765938332059d76104de2519bbd7b9057fd53ed73120e527efd881e7a
testBoolean
public void testBoolean() throws Exception
{    Random random = TestUtil.createRandom();    OutputBuffer out = new OutputBuffer();    for (int i = 0; i < COUNT; i++) out.writeValue(random.nextBoolean(), ValueType.BOOLEAN);    InputBuffer in = new InputBuffer(new InputBytes(out.toByteArray()));    random = TestUtil.createRandom();    for (int i = 0; i < COUNT; i++) Assert.assertEquals(random.nextBoolean(), in.readValue(ValueType.BOOLEAN));}
7d308bd607294c47e283d31de15a82aeaaad961e02fc7aca32909747cfcabcad
testInt
public void testInt() throws Exception
{    Random random = TestUtil.createRandom();    OutputBuffer out = new OutputBuffer();    for (int i = 0; i < COUNT; i++) out.writeInt(random.nextInt());    InputBuffer in = new InputBuffer(new InputBytes(out.toByteArray()));    random = TestUtil.createRandom();    for (int i = 0; i < COUNT; i++) Assert.assertEquals(random.nextInt(), in.readInt());}
610de3ad7cc1d54bdbc9a4fe9c41e2c012a37ae58dac4466b22979a25e1b08e7
testLong
public void testLong() throws Exception
{    Random random = TestUtil.createRandom();    OutputBuffer out = new OutputBuffer();    for (int i = 0; i < COUNT; i++) out.writeLong(random.nextLong());    InputBuffer in = new InputBuffer(new InputBytes(out.toByteArray()));    random = TestUtil.createRandom();    for (int i = 0; i < COUNT; i++) Assert.assertEquals(random.nextLong(), in.readLong());}
782eee0d6211d012f5f4019adab3bd051932a60a6e9bc7ab871d7689c5476643
testFixed32
public void testFixed32() throws Exception
{    Random random = TestUtil.createRandom();    OutputBuffer out = new OutputBuffer();    for (int i = 0; i < COUNT; i++) out.writeFixed32(random.nextInt());    InputBuffer in = new InputBuffer(new InputBytes(out.toByteArray()));    random = TestUtil.createRandom();    for (int i = 0; i < COUNT; i++) Assert.assertEquals(random.nextInt(), in.readFixed32());}
3a324b3de180b4915a649b18e3892a36bf8894af522849702f261ec5e162942d
testFixed64
public void testFixed64() throws Exception
{    Random random = TestUtil.createRandom();    OutputBuffer out = new OutputBuffer();    for (int i = 0; i < COUNT; i++) out.writeFixed64(random.nextLong());    InputBuffer in = new InputBuffer(new InputBytes(out.toByteArray()));    random = TestUtil.createRandom();    for (int i = 0; i < COUNT; i++) Assert.assertEquals(random.nextLong(), in.readFixed64());}
b7f222c157daee3f00a40a6f98b21c2806a0bfbf7a58e847930af5420b976276
testFloat
public void testFloat() throws Exception
{    Random random = TestUtil.createRandom();    OutputBuffer out = new OutputBuffer();    for (int i = 0; i < COUNT; i++) out.writeFloat(random.nextFloat());    InputBuffer in = new InputBuffer(new InputBytes(out.toByteArray()));    random = TestUtil.createRandom();    for (int i = 0; i < COUNT; i++) Assert.assertEquals(random.nextFloat(), in.readFloat(), 0);}
d1cc0c0b6a548d4db9fe52df21cce3b0c12faae6479bc1660611b03839fdb710
testDouble
public void testDouble() throws Exception
{    OutputBuffer out = new OutputBuffer();    for (int i = 0; i < COUNT; i++) out.writeDouble(Double.MIN_VALUE);    InputBuffer in = new InputBuffer(new InputBytes(out.toByteArray()));    for (int i = 0; i < COUNT; i++) Assert.assertEquals(Double.MIN_VALUE, in.readDouble(), 0);}
a4e6b9f25ced9157a314ef8ee378dda6c12353478243004ff437e919eacbc247
testBytes
public void testBytes() throws Exception
{    Random random = TestUtil.createRandom();    OutputBuffer out = new OutputBuffer();    for (int i = 0; i < COUNT; i++) out.writeBytes(TestUtil.randomBytes(random));    InputBuffer in = new InputBuffer(new InputBytes(out.toByteArray()));    random = TestUtil.createRandom();    for (int i = 0; i < COUNT; i++) Assert.assertEquals(TestUtil.randomBytes(random), in.readBytes(null));}
47091a22b52c1ea805d7739df5201a4e7327af110691372a168e229d498ce84a
testString
public void testString() throws Exception
{    Random random = TestUtil.createRandom();    OutputBuffer out = new OutputBuffer();    for (int i = 0; i < COUNT; i++) out.writeString(TestUtil.randomString(random));    InputBuffer in = new InputBuffer(new InputBytes(out.toByteArray()));    random = TestUtil.createRandom();    for (int i = 0; i < COUNT; i++) Assert.assertEquals(TestUtil.randomString(random), in.readString());}
77053e670606e99460b2b306e557c555a447060b8fa2fed02f6dd3d256964fd3
testSkipNull
public void testSkipNull() throws Exception
{    long sentinel = Long.MAX_VALUE;    OutputBuffer out = new OutputBuffer();    out.writeValue(null, ValueType.NULL);    out.writeLong(sentinel);    InputBuffer in = new InputBuffer(new InputBytes(out.toByteArray()));    in.skipValue(ValueType.NULL);    Assert.assertEquals(sentinel, in.readLong());}
bf2bb715ee2d0c9b65185489af222fefb25c6659472ca653bb937676386cebf8
testSkipBoolean
public void testSkipBoolean() throws Exception
{    long sentinel = Long.MAX_VALUE;    OutputBuffer out = new OutputBuffer();    out.writeValue(false, ValueType.BOOLEAN);    out.writeLong(sentinel);    InputBuffer in = new InputBuffer(new InputBytes(out.toByteArray()));    in.skipValue(ValueType.BOOLEAN);    Assert.assertEquals(sentinel, in.readLong());}
7feebe9fec8ad043d9b94a4855a620f57271d54bfbfd71434d1bfaa5bcc534e9
testSkipInt
public void testSkipInt() throws Exception
{    long sentinel = Long.MAX_VALUE;    OutputBuffer out = new OutputBuffer();    out.writeValue(Integer.MAX_VALUE, ValueType.INT);    out.writeLong(sentinel);    InputBuffer in = new InputBuffer(new InputBytes(out.toByteArray()));    in.skipValue(ValueType.INT);    Assert.assertEquals(sentinel, in.readLong());}
b31e92aa38367f6985ec295257990e25f20af5fb65800754f3c8b68e52d4b336
testSkipLong
public void testSkipLong() throws Exception
{    long sentinel = Long.MAX_VALUE;    OutputBuffer out = new OutputBuffer();    out.writeValue(Long.MAX_VALUE, ValueType.LONG);    out.writeLong(sentinel);    InputBuffer in = new InputBuffer(new InputBytes(out.toByteArray()));    in.skipValue(ValueType.LONG);    Assert.assertEquals(sentinel, in.readLong());}
d575121d52cf1cb5332556c8a56b3249b6a80402589f3167e1fb7c0309bc9de3
testSkipFixed32
public void testSkipFixed32() throws Exception
{    long sentinel = Long.MAX_VALUE;    OutputBuffer out = new OutputBuffer();    out.writeValue(Integer.MAX_VALUE, ValueType.FIXED32);    out.writeLong(sentinel);    InputBuffer in = new InputBuffer(new InputBytes(out.toByteArray()));    in.skipValue(ValueType.LONG);    Assert.assertEquals(sentinel, in.readLong());}
a780cf600dbcf09f18daa844674ca5706d489dfe10429ed311d580c979322f86
testSkipFixed64
public void testSkipFixed64() throws Exception
{    long sentinel = Long.MAX_VALUE;    OutputBuffer out = new OutputBuffer();    out.writeValue(Long.MAX_VALUE, ValueType.FIXED64);    out.writeLong(sentinel);    InputBuffer in = new InputBuffer(new InputBytes(out.toByteArray()));    in.skipValue(ValueType.LONG);    Assert.assertEquals(sentinel, in.readLong());}
bbe8eede5779b946975e0493543bd746cd5d404e5b47f2f70e347a8695bb65a0
testSkipFloat
public void testSkipFloat() throws Exception
{    long sentinel = Long.MAX_VALUE;    OutputBuffer out = new OutputBuffer();    out.writeValue(Float.MAX_VALUE, ValueType.FLOAT);    out.writeLong(sentinel);    InputBuffer in = new InputBuffer(new InputBytes(out.toByteArray()));    in.skipValue(ValueType.FLOAT);    Assert.assertEquals(sentinel, in.readLong());}
d9895748a8a6f974a56ee24125f725eced416611f7d5c5383e7c1a1ee3731cce
testSkipDouble
public void testSkipDouble() throws Exception
{    long sentinel = Long.MAX_VALUE;    OutputBuffer out = new OutputBuffer();    out.writeValue(Double.MAX_VALUE, ValueType.DOUBLE);    out.writeLong(sentinel);    InputBuffer in = new InputBuffer(new InputBytes(out.toByteArray()));    in.skipValue(ValueType.DOUBLE);    Assert.assertEquals(sentinel, in.readLong());}
f258a6c94473365c25047a4592679af67ed07c7a0a070e1c256ce2c03a01e7d3
testSkipString
public void testSkipString() throws Exception
{    long sentinel = Long.MAX_VALUE;    OutputBuffer out = new OutputBuffer();    out.writeValue("trevni", ValueType.STRING);    out.writeLong(sentinel);    InputBuffer in = new InputBuffer(new InputBytes(out.toByteArray()));    in.skipValue(ValueType.STRING);    Assert.assertEquals(sentinel, in.readLong());}
6d7bcec78e9e725cf0cd0d3f724d77ddb564d33f0ae466e490ab426c3779300a
testSkipBytes
public void testSkipBytes() throws Exception
{    long sentinel = Long.MAX_VALUE;    OutputBuffer out = new OutputBuffer();    out.writeValue("trevni".getBytes(UTF_8), ValueType.BYTES);    out.writeLong(sentinel);    InputBuffer in = new InputBuffer(new InputBytes(out.toByteArray()));    in.skipValue(ValueType.BYTES);    Assert.assertEquals(sentinel, in.readLong());}
e95d0fe4f74e1020ea2f91dc6aeb14d79ea52242aef06f38b09dba560cf1f575
testInitPos
public void testInitPos() throws Exception
{    long sentinel = Long.MAX_VALUE;    OutputBuffer out = new OutputBuffer();    out.writeValue(Integer.MAX_VALUE, ValueType.INT);    out.writeLong(sentinel);    InputBuffer in = new InputBuffer(new InputBytes(out.toByteArray()));    in.readInt();    long pos = in.tell();    in = new InputBuffer(new InputBytes(out.toByteArray()), pos);    Assert.assertEquals(sentinel, in.readLong());}
2c52d23beeb51e406701b09cf436bb73d395db95f40b662b8f320e217eac699e
getRandomSeed
public static long getRandomSeed()
{    if (!seedSet) {        String configured = System.getProperty("test.seed");        if (configured != null)            seed = Long.valueOf(configured);        else            seed = System.currentTimeMillis();        System.err.println("test.seed=" + seed);        seedSet = true;    }    return seed;}
7a7ddd3d6f8b929b482a72e00a2ddf21e1df393f019042105be2a188d15ef136
resetRandomSeed
public static void resetRandomSeed()
{    seedSet = false;}
fac85d297d51e7ed84a11b8f744a57ad9af5b88400fc04a434f6716f8b2d7ccb
createRandom
public static Random createRandom()
{    return new Random(getRandomSeed());}
afc563aaf2110efa0e1d50beef70317c227bfc9a98907be86f31f35050c7712d
randomBytes
public static ByteBuffer randomBytes(Random random)
{    byte[] bytes = new byte[randomLength(random)];    random.nextBytes(bytes);    return ByteBuffer.wrap(bytes);}
d0ec8dfe0103d3540f800e45a0264fc6a38cf50737a61b8bcb9b34382f921e36
randomString
public static String randomString(Random random)
{    int length = randomLength(random);    char[] chars = new char[length];    for (int i = 0; i < length; i++) chars[i] = (char) ('a' + random.nextInt('z' - 'a'));    return new String(chars);}
59bc28c50d58ead3e97bc1a208f353bd4240dca3425f82b9a365e47667370958
randomLength
public static int randomLength(Random random)
{    int n = random.nextInt();    if (n < 0)        n = -n;    return n & ((n & 0xF0000) != 0 ? 0xF : ((n & 0xFF0000) != 0 ? 0xFF : ((n & 0xFFF0000) != 0 ? 0xFFF : 0xFFFF)));}
1f101c2d2f1e3d5fdf72dd1abd8e7fc1386ab63b3966028f2a95b083c435d9ce
testRandomLength
public void testRandomLength()
{    long total = 0;    int count = 1024 * 1024;    int min = Short.MAX_VALUE;    int max = 0;    Random r = createRandom();    for (int i = 0; i < count; i++) {        int length = randomLength(r);        if (min > length)            min = length;        if (max < length)            max = length;        total += length;    }    Assert.assertEquals(0, min);    Assert.assertTrue(max > 1024 * 32);    float average = total / (float) count;    Assert.assertTrue(average > 16.0f);    Assert.assertTrue(average < 64.0f);}
