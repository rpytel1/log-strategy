28a6cc734a656efce64c5f178ec5a9e1e3b846893018a741cd8ac73e6e5143b2
value
public T value()
{    if (obj == null) {        obj = deserialize(buf);    }    return obj;}
20079678ca4cac93f9e360c47ccbfc651707e3ab83642f31ae8448600cc114b1
serialize
private byte[] serialize(Writable w)
{    ByteArrayOutputStream bos = new ByteArrayOutputStream();    try {        ObjectOutputStream oos = new ObjectOutputStream(bos);        w.write(oos);        oos.close();    } catch (IOException e) {        return null;    }    return bos.toByteArray();}
b7ff6931c5bccfe9a43a73bde447610e9a00d296750ffbd6935cd0ca4bf778f5
deserialize
private T deserialize(byte[] buf)
{    T ret = null;    try (ByteArrayInputStream bis = new ByteArrayInputStream(buf)) {        ObjectInputStream ois = new ObjectInputStream(bis);        if (isMatrix) {            MatrixWritable w = new MatrixWritable();            w.readFields(ois);            ret = (T) w.get();        } else {            VectorWritable w = new VectorWritable();            w.readFields(ois);            ret = (T) w.get();        }    } catch (IOException e) {        e.printStackTrace();    }    return ret;}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{}
aaedca2153de3f5940d59574a5355fb6f003746f09e8a8d2ce973928a67dee09
cow
private void cow()
{    if (cow != null) {        return;    }    if (chks[0].isSparse()) {        cow = new SparseMatrix(chks[0].len(), chks.length);    } else {        cow = new DenseMatrix(chks[0].len(), chks.length);    }    for (int c = 0; c < chks.length; c++) {        for (int r = 0; r < chks[0].len(); r++) {            cow.setQuick(r, c, chks[c].atd(r));        }    }}
df02a79083e2f58e41e19177e14e70a4ee2a0eee3d8146c0f991f904aee4048d
setQuick
public void setQuick(int row, int col, double val)
{    cow();    cow.setQuick(row, col, val);}
72a6ec1e526e58b268e672c3b156150f83a6c528bfdc76ccfd8744b1788e4910
like
public Matrix like(int nrow, int ncol)
{    if (chks[0].isSparse()) {        return new SparseMatrix(nrow, ncol);    } else {        return new DenseMatrix(nrow, ncol);    }}
8ea1ca8bbfed9d923bb33b6722a3491db09837bb6812b8b8778bf2422064e0ab
like
public Matrix like()
{    if (chks[0].isSparse()) {        return new SparseMatrix(rowSize(), columnSize());    } else {        return new DenseMatrix(rowSize(), columnSize());    }}
ba3e80f58f015604a6b976d21431d77128d54c663d2ca199840759bb25198970
getQuick
public double getQuick(int row, int col)
{    if (cow != null) {        return cow.getQuick(row, col);    } else {        return chks[col].atd(row);    }}
3a3f60c5b4285520f9a4b33b6c7c2c0a4abf256847a75352b77606ee60a906cd
assignRow
public Matrix assignRow(int row, Vector v)
{    cow();    cow.assignRow(row, v);    return cow;}
58426de715aea736aac061dc31957d2e5bd7ea6732ac416674930d43625f20c2
assignColumn
public Matrix assignColumn(int col, Vector v)
{    cow();    cow.assignColumn(col, v);    return cow;}
4f943db0f33d27c9f70c541ef27a217346904d47c0870b555f1140eebdc0f9b2
getFlavor
public MatrixFlavor getFlavor()
{    if (cow != null) {        return cow.getFlavor();    } else if (chks[0].isSparse()) {        return MatrixFlavor.SPARSELIKE;    } else {        return MatrixFlavor.DENSELIKE;    }}
2f8829c1d1f2eb1b2b7d47c18f24a11c3345149fcb9557cbada4e97b2bc35391
isSeqfile
public static boolean isSeqfile(String filename)
{    try {        Configuration conf = new Configuration();        Path path = new Path(filename);        FileSystem fs = FileSystem.get(URI.create(filename), conf);        FSDataInputStream fin = fs.open(path);        byte[] seq = new byte[3];        fin.read(seq);        fin.close();        return seq[0] == 'S' && seq[1] == 'E' && seq[2] == 'Q';    } catch (IOException e) {        return false;    }}
33b6be8bfb020d777728fc673cb4cb1c4a8adecc82f79ef055cbcf0efca8c3f6
drmFromFile
public static H2ODrm drmFromFile(String filename, int parMin)
{    try {        if (isSeqfile(filename)) {            return drmFromSeqfile(filename, parMin);        } else {            return new H2ODrm(FrameUtils.parseFrame(null, new File(filename)));        }    } catch (IOException e) {        return null;    }}
9b095a09fb71ecdb22e2822566164c240a985043929848824ff42f684fb1e8ea
drmFromSeqfile
public static H2ODrm drmFromSeqfile(String filename, int parMin)
{    long rows = 0;    int cols = 0;    Frame frame = null;    Vec labels = null;    SequenceFile.Reader reader = null;    try {        Configuration conf = new Configuration();        Path path = new Path(filename);        FileSystem fs = FileSystem.get(URI.create(filename), conf);        Vec.Writer[] writers;        Vec.Writer labelwriter = null;        boolean isIntKey = false, isLongKey = false, isStringKey = false;        reader = new SequenceFile.Reader(fs, path, conf);        if (reader.getValueClass() != VectorWritable.class) {            System.out.println("ValueClass in file " + filename + "must be VectorWritable, but found " + reader.getValueClassName());            return null;        }        Writable key = (Writable) ReflectionUtils.newInstance(reader.getKeyClass(), conf);        VectorWritable value = (VectorWritable) ReflectionUtils.newInstance(reader.getValueClass(), conf);        long start = reader.getPosition();        if (reader.getKeyClass() == Text.class) {            isStringKey = true;        } else if (reader.getKeyClass() == LongWritable.class) {            isLongKey = true;        } else {            isIntKey = true;        }        while (reader.next(key, value)) {            if (cols == 0) {                Vector v = value.get();                cols = Math.max(v.size(), cols);            }            if (isLongKey) {                rows = Math.max(((LongWritable) (key)).get() + 1, rows);            }            if (isIntKey) {                rows = Math.max(((IntWritable) (key)).get() + 1, rows);            }            if (isStringKey) {                rows++;            }        }        reader.seek(start);        frame = H2OHelper.emptyFrame(rows, cols, parMin, -1);        writers = new Vec.Writer[cols];        for (int i = 0; i < writers.length; i++) {            writers[i] = frame.vecs()[i].open();        }        if (reader.getKeyClass() == Text.class) {            labels = H2OHelper.makeEmptyStrVec(frame.anyVec());            labelwriter = labels.open();        }        long r = 0;        while (reader.next(key, value)) {            Vector v = value.get();            if (isLongKey) {                r = ((LongWritable) (key)).get();            }            if (isIntKey) {                r = ((IntWritable) (key)).get();            }            for (int c = 0; c < v.size(); c++) {                writers[c].set(r, v.getQuick(c));            }            if (labels != null) {                labelwriter.set(r, (key).toString());            }            if (isStringKey) {                r++;            }        }        Futures fus = new Futures();        for (Vec.Writer w : writers) {            w.close(fus);        }        if (labelwriter != null) {            labelwriter.close(fus);        }        fus.blockForPending();    } catch (java.io.IOException e) {        return null;    } finally {        IOUtils.closeStream(reader);    }    return new H2ODrm(frame, labels);}
f068686cf5bc9003406c11d1a146aa263a40203761153c8780e6d62949fa907a
drmToFile
public static void drmToFile(String filename, H2ODrm drm) throws java.io.IOException
{    Frame frame = drm.frame;    Vec labels = drm.keys;    Configuration conf = new Configuration();    Path path = new Path(filename);    FileSystem fs = FileSystem.get(URI.create(filename), conf);    SequenceFile.Writer writer;    boolean isSparse = H2OHelper.isSparse(frame);    ValueString vstr = new ValueString();    if (labels != null) {        writer = SequenceFile.createWriter(fs, conf, path, Text.class, VectorWritable.class);    } else {        writer = SequenceFile.createWriter(fs, conf, path, IntWritable.class, VectorWritable.class);    }    for (long r = 0; r < frame.anyVec().length(); r++) {        Vector v;        if (isSparse) {            v = new SequentialAccessSparseVector(frame.numCols());        } else {            v = new DenseVector(frame.numCols());        }        for (int c = 0; c < frame.numCols(); c++) {            v.setQuick(c, frame.vecs()[c].at(r));        }        if (labels != null) {            writer.append(new Text(labels.atStr(vstr, r).toString()), new VectorWritable(v));        } else {            writer.append(new IntWritable((int) r), new VectorWritable(v));        }    }    writer.close();}
14117b28a898490dc46dbc77566c5d0eca0e2a33ea84d1123806348ffffd74bd
isSparse
public static boolean isSparse(Frame frame)
{    long rows = frame.numRows();    long cols = frame.numCols();    /**     * MRTask to aggregate precalculated per-chunk sparse lengths     */    class MRTaskNZ extends MRTask<MRTaskNZ> {        long sparselen;        @Override        public void map(Chunk[] chks) {            for (Chunk chk : chks) {                sparselen += chk.sparseLen();            }        }        @Override        public void reduce(MRTaskNZ other) {            sparselen += other.sparselen;        }    }    long sparselen = new MRTaskNZ().doAll(frame).sparselen;    return (((rows * cols) / (sparselen + 1)) > 32);}
ddc3fccb977dc9927fe4feb37fef674297b12b518e9a43925fef8415b7e48592
map
public void map(Chunk[] chks)
{    for (Chunk chk : chks) {        sparselen += chk.sparseLen();    }}
635ef80a5af048790258e07880642455aa129055e1b3fd14a058e1df6ef03e5a
reduce
public void reduce(MRTaskNZ other)
{    sparselen += other.sparselen;}
6a5f92a4f562ae2fcb53bd299301746d42d4e5ae69f69acf572cd1ae824a08ec
matrixFromDrm
public static Matrix matrixFromDrm(H2ODrm drm)
{    Frame frame = drm.frame;    Vec labels = drm.keys;    Matrix m;    if (isSparse(frame)) {        m = new SparseMatrix((int) frame.numRows(), frame.numCols());    } else {        m = new DenseMatrix((int) frame.numRows(), frame.numCols());    }    int c = 0;        for (Vec v : frame.vecs()) {        for (int r = 0; r < frame.numRows(); r++) {            double d;            if (!v.isNA(r) && ((d = v.at(r)) != 0.0)) {                m.setQuick(r, c, d);            }        }        c++;    }        if (labels != null) {        Map<String, Integer> map = new HashMap<>();        ValueString vstr = new ValueString();        for (long i = 0; i < labels.length(); i++) {            map.put(labels.atStr(vstr, i).toString(), (int) i);        }        m.setRowLabelBindings(map);    }    return m;}
2480dca76b969934b98accd925a3004dcf1d5dddcb4f4db5e469b560d1a99ec0
colMeans
public static Vector colMeans(Frame frame)
{    double[] means = new double[frame.numCols()];    for (int i = 0; i < frame.numCols(); i++) {        means[i] = frame.vecs()[i].mean();    }    return new DenseVector(means);}
4d6505220b176ef4ad22b41faaa404e7af365790a19949906b4bcc3c57a6f5cb
colSums
public static Vector colSums(Frame frame)
{    /**     * MRTask to calculate sums of elements in all columns.     */    class MRTaskSum extends MRTask<MRTaskSum> {        public double[] sums;        @Override        public void map(Chunk[] chks) {            sums = new double[chks.length];            for (int c = 0; c < chks.length; c++) {                for (int r = 0; r < chks[c].len(); r++) {                    sums[c] += chks[c].atd(r);                }            }        }        @Override        public void reduce(MRTaskSum other) {            ArrayUtils.add(sums, other.sums);        }    }    return new DenseVector(new MRTaskSum().doAll(frame).sums);}
ddc3fccb977dc9927fe4feb37fef674297b12b518e9a43925fef8415b7e48592
map
public void map(Chunk[] chks)
{    sums = new double[chks.length];    for (int c = 0; c < chks.length; c++) {        for (int r = 0; r < chks[c].len(); r++) {            sums[c] += chks[c].atd(r);        }    }}
b91a8d0007b5eef245f46be33db23b963fb2d40c01c995988e4933d7267ee1f0
reduce
public void reduce(MRTaskSum other)
{    ArrayUtils.add(sums, other.sums);}
fa21226f1d77d1c7756a443ab32fd3e2c3b02bcf02f93a4dc3fc810e4c153252
sumSqr
public static double sumSqr(Frame frame)
{    /**     * MRTask to calculate sums of squares of all elements.     */    class MRTaskSumSqr extends MRTask<MRTaskSumSqr> {        public double sumSqr;        @Override        public void map(Chunk[] chks) {            for (Chunk chk : chks) {                for (int r = 0; r < chk.len(); r++) {                    sumSqr += (chk.atd(r) * chk.atd(r));                }            }        }        @Override        public void reduce(MRTaskSumSqr other) {            sumSqr += other.sumSqr;        }    }    return new MRTaskSumSqr().doAll(frame).sumSqr;}
ddc3fccb977dc9927fe4feb37fef674297b12b518e9a43925fef8415b7e48592
map
public void map(Chunk[] chks)
{    for (Chunk chk : chks) {        for (int r = 0; r < chk.len(); r++) {            sumSqr += (chk.atd(r) * chk.atd(r));        }    }}
1cad04b2749a600febaeffa4b52f5105bfd9558ba9906cc5b919d681181d4e01
reduce
public void reduce(MRTaskSumSqr other)
{    sumSqr += other.sumSqr;}
67dbee78e0bb24807eb69d005d7512244b0917cf12703bc8396355e908221e97
nonZeroCnt
public static Vector nonZeroCnt(Frame frame)
{    /**     * MRTask to count all non-zero elements.     */    class MRTaskNonZero extends MRTask<MRTaskNonZero> {        public double[] sums;        @Override        public void map(Chunk[] chks) {            sums = new double[chks.length];            for (int c = 0; c < chks.length; c++) {                for (int r = 0; r < chks[c].len(); r++) {                    if ((long) chks[c].atd(r) != 0) {                        sums[c]++;                    }                }            }        }        @Override        public void reduce(MRTaskNonZero other) {            ArrayUtils.add(sums, other.sums);        }    }    return new DenseVector(new MRTaskNonZero().doAll(frame).sums);}
ddc3fccb977dc9927fe4feb37fef674297b12b518e9a43925fef8415b7e48592
map
public void map(Chunk[] chks)
{    sums = new double[chks.length];    for (int c = 0; c < chks.length; c++) {        for (int r = 0; r < chks[c].len(); r++) {            if ((long) chks[c].atd(r) != 0) {                sums[c]++;            }        }    }}
bf1eb39875920bf9881d4afc8fb74a563d214591ac244f0313a944cf28468d4d
reduce
public void reduce(MRTaskNonZero other)
{    ArrayUtils.add(sums, other.sums);}
2febf0d65d9da2eaf85b7c43d4c9a6e28979712f6a7feb37f464362089109fe0
reverseMap
private static Map<Integer, String> reverseMap(Map<String, Integer> map)
{    if (map == null) {        return null;    }    Map<Integer, String> rmap = new HashMap<>();    for (Map.Entry<String, Integer> entry : map.entrySet()) {        rmap.put(entry.getValue(), entry.getKey());    }    return rmap;}
04d6dcf11afc7e759cf1e44405c7f3249849604a3c785f84cbe8eadb70a9f583
chunkSize
private static int chunkSize(long nrow, int minHint, int exactHint)
{    int chunkSz;    int partsHint = Math.max(minHint, exactHint);    if (partsHint < 1) {        /* XXX: calculate based on cloud size and # of cpu */        partsHint = 4;    }    chunkSz = (int) (((nrow - 1) / partsHint) + 1);    if (exactHint > 0) {        return chunkSz;    }    if (chunkSz > 1e6) {        chunkSz = (int) 1e6;    }    if (minHint > 0) {        return chunkSz;    }    if (chunkSz < 1e3) {        chunkSz = (int) 1e3;    }    return chunkSz;}
ea84e8e006d25abad81c2a0d5779d9ed6bfc362bb0024b0fb82294a054a5d1a1
drmFromMatrix
public static H2ODrm drmFromMatrix(Matrix m, int minHint, int exactHint)
{        Frame frame = emptyFrame(m.rowSize(), m.columnSize(), minHint, exactHint);    Vec labels = null;    Vec.Writer[] writers = new Vec.Writer[m.columnSize()];    Futures closer = new Futures();        for (int i = 0; i < writers.length; i++) {        writers[i] = frame.vecs()[i].open();    }    for (int r = 0; r < m.rowSize(); r++) {        for (int c = 0; c < m.columnSize(); c++) {            writers[c].set(r, m.getQuick(r, c));        }    }    for (int c = 0; c < m.columnSize(); c++) {        writers[c].close(closer);    }        Map<String, Integer> map = m.getRowLabelBindings();    if (map != null) {                labels = makeEmptyStrVec(frame.anyVec());        Vec.Writer writer = labels.open();        Map<Integer, String> rmap = reverseMap(map);        for (int r = 0; r < m.rowSize(); r++) {            writer.set(r, rmap.get(r));        }        writer.close(closer);    }    closer.blockForPending();    return new H2ODrm(frame, labels);}
4d7d5e35f98819e95c596a0c3068263d0b716094a67633ff312eaf7ab9c26f93
emptyFrame
public static Frame emptyFrame(long nrow, int ncol, int minHint, int exactHint)
{    Vec.VectorGroup vg = new Vec.VectorGroup();    return emptyFrame(nrow, ncol, minHint, exactHint, vg);}
bcc881236cd2f09715dec484501bfb2e3ecdd0ecff23e94f5f26d1ea31491c1b
emptyFrame
public static Frame emptyFrame(long nrow, int ncol, int minHint, int exactHint, Vec.VectorGroup vg)
{    int chunkSz = chunkSize(nrow, minHint, exactHint);        int nchunks = (int) ((nrow - 1) / chunkSz) + 1;    long[] espc = new long[nchunks + 1];    for (int i = 0; i < nchunks; i++) {        espc[i] = i * chunkSz;    }    espc[nchunks] = nrow;        Vec vtemplate = new Vec(vg.addVec(), espc);        Vec[] vecs = vtemplate.makeCons(ncol, 0, null, null);    return new Frame(vecs);}
03869f0b997c87b4490d300ef4af8c1231d688704710ac9fa36066352b941b3d
makeEmptyStrVec
public static Vec makeEmptyStrVec(final Vec template)
{    final int nChunks = template.nChunks();    Key<Vec> key = template.group().addVec();    final Vec emptystr = new Vec(key, template._espc, null, Vec.T_NUM);    new MRTask() {        @Override        protected void setupLocal() {            for (int i = 0; i < nChunks; i++) {                Key k = emptystr.chunkKey(i);                int chklen = vecChunkLen(template, i);                int[] stridx = new int[chklen];                byte[] b = new byte[1];                b[0] = 0;                for (int j = 0; j < chklen; j++) stridx[j] = -1;                if (k.home())                    DKV.put(k, new CStrChunk(1, b, chklen, stridx), _fs);            }            if (emptystr._key.home())                DKV.put(emptystr._key, emptystr, _fs);        }    }.doAllNodes();    return emptystr;}
3d4dc6084348804c62631c3d83affdc5611ddc040f5a499dce874259aae3dfc8
setupLocal
protected void setupLocal()
{    for (int i = 0; i < nChunks; i++) {        Key k = emptystr.chunkKey(i);        int chklen = vecChunkLen(template, i);        int[] stridx = new int[chklen];        byte[] b = new byte[1];        b[0] = 0;        for (int j = 0; j < chklen; j++) stridx[j] = -1;        if (k.home())            DKV.put(k, new CStrChunk(1, b, chklen, stridx), _fs);    }    if (emptystr._key.home())        DKV.put(emptystr._key, emptystr, _fs);}
3fe1acd1fff963f09ee7aaf3765dc64b20709a10f8cde794e42fad01288ecd07
vecChunkLen
public static int vecChunkLen(Vec template, int chunk)
{    return (int) (template._espc[chunk + 1] - template._espc[chunk]);}
96f96472b9fecd32d042a40488a8d1c8d031a638da3ab1873d5ed6347fefcb0e
emptyDrm
public static H2ODrm emptyDrm(long nrow, int ncol, int minHint, int exactHint)
{    return new H2ODrm(emptyFrame(nrow, ncol, minHint, exactHint));}
2500cd3850e5c2f7f77dc36c39d22c3507a79a29ac9d7cc87a0521e4db3f28a4
allreduceBlock
public static Matrix allreduceBlock(H2ODrm drmA, Object bmfn, Object rfn)
{    class MRTaskMR extends MRTask<MRTaskMR> {        H2OBCast<Matrix> bmf_out;        Serializable bmf;        Serializable rf;        public MRTaskMR(Object _bmf, Object _rf) {            bmf = (Serializable) _bmf;            rf = (Serializable) _rf;        }        @Override        public void map(Chunk[] chks) {            Function1 f = (Function1) bmf;            bmf_out = new H2OBCast((Matrix) f.apply(new scala.Tuple2(null, new H2OBlockMatrix(chks))));        }        @Override        public void reduce(MRTaskMR that) {            Function2 f = (Function2) rf;            bmf_out = new H2OBCast((Matrix) f.apply(this.bmf_out.value(), that.bmf_out.value()));        }    }    return new MRTaskMR(bmfn, rfn).doAll(drmA.frame).bmf_out.value();}
ddc3fccb977dc9927fe4feb37fef674297b12b518e9a43925fef8415b7e48592
map
public void map(Chunk[] chks)
{    Function1 f = (Function1) bmf;    bmf_out = new H2OBCast((Matrix) f.apply(new scala.Tuple2(null, new H2OBlockMatrix(chks))));}
3766065c246c2479a3d25f9b19dfde2d02f35265725e94a606e1a5f3a1b8fb7f
reduce
public void reduce(MRTaskMR that)
{    Function2 f = (Function2) rf;    bmf_out = new H2OBCast((Matrix) f.apply(this.bmf_out.value(), that.bmf_out.value()));}
24dbb41fa5435a5d7c48547b137d5065be9ed6aa23d2b0e59cccef0c7748b3b3
exec
public static H2ODrm exec(H2ODrm drmA, H2ODrm drmB)
{    Frame A = drmA.frame;    Vec keys = drmA.keys;    final Frame B = drmB.frame;    int ABt_cols = (int) B.numRows();                        Frame ABt = new MRTask() {        public void map(Chunk[] chks, NewChunk[] ncs) {            int chunkSize = chks[0].len();            Vec[] B_vecs = B.vecs();            for (int c = 0; c < ncs.length; c++) {                for (int r = 0; r < chunkSize; r++) {                    double v = 0;                    for (int i = 0; i < chks.length; i++) {                        v += (chks[i].atd(r) * B_vecs[i].at(c));                    }                    ncs[c].addNum(v);                }            }        }    }.doAll(ABt_cols, A).outputFrame(null, null);        return new H2ODrm(ABt, keys);}
a8a0f5989db2c0e4079a4eb1cd03669914f894e81474e09cd222ef4f3c3e4163
map
public void map(Chunk[] chks, NewChunk[] ncs)
{    int chunkSize = chks[0].len();    Vec[] B_vecs = B.vecs();    for (int c = 0; c < ncs.length; c++) {        for (int r = 0; r < chunkSize; r++) {            double v = 0;            for (int i = 0; i < chks.length; i++) {                v += (chks[i].atd(r) * B_vecs[i].at(c));            }            ncs[c].addNum(v);        }    }}
d4762f2195d1f4423baa20d8e4bb01dbbd63a102ba68e4882d0ffbce82d550ed
exec
public static H2ODrm exec(H2ODrm drmA, H2ODrm drmB, final String op)
{    final Frame A = drmA.frame;    final Frame B = drmB.frame;    Vec keys = drmA.keys;    int AewB_cols = A.numCols();                        Frame AewB = new MRTask() {        private double opfn(String op, double a, double b) {            if (a == 0.0 && b == 0.0) {                return 0.0;            }            if (op.equals("+")) {                return a + b;            } else if (op.equals("-")) {                return a - b;            } else if (op.equals("*")) {                return a * b;            } else if (op.equals("/")) {                return a / b;            }            return 0.0;        }        @Override        public void map(Chunk[] chks, NewChunk[] ncs) {            int chunkSize = chks[0].len();            Vec[] B_vecs = B.vecs();            long start = chks[0].start();            for (int c = 0; c < chks.length; c++) {                for (int r = 0; r < chunkSize; r++) {                    ncs[c].addNum(opfn(op, chks[c].atd(r), B_vecs[c].at(start + r)));                }            }        }    }.doAll(AewB_cols, A).outputFrame(null, null);        return new H2ODrm(AewB, keys);}
29963519ede111af181ca74419595431065056d0c0a671b36cde00e03d4d11ea
opfn
private double opfn(String op, double a, double b)
{    if (a == 0.0 && b == 0.0) {        return 0.0;    }    if (op.equals("+")) {        return a + b;    } else if (op.equals("-")) {        return a - b;    } else if (op.equals("*")) {        return a * b;    } else if (op.equals("/")) {        return a / b;    }    return 0.0;}
a8a0f5989db2c0e4079a4eb1cd03669914f894e81474e09cd222ef4f3c3e4163
map
public void map(Chunk[] chks, NewChunk[] ncs)
{    int chunkSize = chks[0].len();    Vec[] B_vecs = B.vecs();    long start = chks[0].start();    for (int c = 0; c < chks.length; c++) {        for (int r = 0; r < chunkSize; r++) {            ncs[c].addNum(opfn(op, chks[c].atd(r), B_vecs[c].at(start + r)));        }    }}
f2ee5f5faebd89f57f977e0608db0b6f79fe3dd74d305e944e1ea8d6f2fda7b3
exec
public static H2ODrm exec(H2ODrm drmA, final double s, final String op)
{    Frame A = drmA.frame;    Vec keys = drmA.keys;    int AewScalar_cols = A.numCols();            Frame AewScalar = new MRTask() {        private double opfn(String op, double a, double b) {            if (a == 0.0 && b == 0.0) {                return 0.0;            }            if (op.equals("+")) {                return a + b;            } else if (op.equals("-")) {                return a - b;            } else if (op.equals("*")) {                return a * b;            } else if (op.equals("/")) {                return a / b;            }            return 0.0;        }        public void map(Chunk[] chks, NewChunk[] ncs) {            int chunkSize = chks[0].len();            long start = chks[0].start();            for (int c = 0; c < chks.length; c++) {                for (int r = 0; r < chunkSize; r++) {                    ncs[c].addNum(opfn(op, chks[c].atd(r), s));                }            }        }    }.doAll(AewScalar_cols, A).outputFrame(null, null);        return new H2ODrm(AewScalar, keys);}
29963519ede111af181ca74419595431065056d0c0a671b36cde00e03d4d11ea
opfn
private double opfn(String op, double a, double b)
{    if (a == 0.0 && b == 0.0) {        return 0.0;    }    if (op.equals("+")) {        return a + b;    } else if (op.equals("-")) {        return a - b;    } else if (op.equals("*")) {        return a * b;    } else if (op.equals("/")) {        return a / b;    }    return 0.0;}
a8a0f5989db2c0e4079a4eb1cd03669914f894e81474e09cd222ef4f3c3e4163
map
public void map(Chunk[] chks, NewChunk[] ncs)
{    int chunkSize = chks[0].len();    long start = chks[0].start();    for (int c = 0; c < chks.length; c++) {        for (int r = 0; r < chunkSize; r++) {            ncs[c].addNum(opfn(op, chks[c].atd(r), s));        }    }}
86e9dc7b9eb58a78da8415d5d0b35aafa7ff8bc41e8c523c30f46f1a1373a742
exec
public static H2ODrm exec(H2ODrm drmA, Object f, final boolean evalZeros)
{    Frame A = drmA.frame;    Vec keys = drmA.keys;    final int ncol = A.numCols();    /**     * MRTask to execute fn on all elements.     */    class MRTaskAewUnary extends MRTask<MRTaskAewUnary> {        Serializable fn;        MRTaskAewUnary(Object _fn) {            fn = (Serializable) _fn;        }        public void map(Chunk[] chks, NewChunk[] ncs) {            for (int c = 0; c < chks.length; c++) {                Chunk chk = chks[c];                Function1 f = (Function1) fn;                int ChunkLen = chk.len();                if (!evalZeros && chk.isSparse()) {                    /* sparse and skip zeros */                    int prev_offset = -1;                    for (int r = chk.nextNZ(-1); r < ChunkLen; r = chk.nextNZ(prev_offset)) {                        if (r - prev_offset > 1)                            ncs[c].addZeros(r - prev_offset - 1);                        ncs[c].addNum((double) f.apply(chk.atd(r)));                        prev_offset = r;                    }                    if (ChunkLen - prev_offset > 1)                        ncs[c].addZeros(chk._len - prev_offset - 1);                } else {                    /* dense or non-skip zeros */                    for (int r = 0; r < ChunkLen; r++) {                        ncs[c].addNum((double) f.apply(chk.atd(r)));                    }                }            }        }    }    Frame fmap = new MRTaskAewUnary(f).doAll(ncol, A).outputFrame(null, null);    return new H2ODrm(fmap, keys);}
a8a0f5989db2c0e4079a4eb1cd03669914f894e81474e09cd222ef4f3c3e4163
map
public void map(Chunk[] chks, NewChunk[] ncs)
{    for (int c = 0; c < chks.length; c++) {        Chunk chk = chks[c];        Function1 f = (Function1) fn;        int ChunkLen = chk.len();        if (!evalZeros && chk.isSparse()) {            /* sparse and skip zeros */            int prev_offset = -1;            for (int r = chk.nextNZ(-1); r < ChunkLen; r = chk.nextNZ(prev_offset)) {                if (r - prev_offset > 1)                    ncs[c].addZeros(r - prev_offset - 1);                ncs[c].addNum((double) f.apply(chk.atd(r)));                prev_offset = r;            }            if (ChunkLen - prev_offset > 1)                ncs[c].addZeros(chk._len - prev_offset - 1);        } else {            /* dense or non-skip zeros */            for (int r = 0; r < ChunkLen; r++) {                ncs[c].addNum((double) f.apply(chk.atd(r)));            }        }    }}
20d48d68d1d1c31003fa7e01d8f84b2be013310d8d408ac86d2490cca39fcf06
exec
public static H2ODrm exec(H2ODrm drmA)
{    final Frame A = drmA.frame;            Frame At = H2OHelper.emptyFrame(A.numCols(), (int) A.numRows(), -1, -1);            new MRTask() {        public void map(Chunk[] chks) {            int chunkSize = chks[0].len();            long start = chks[0].start();            Vec[] A_vecs = A.vecs();            for (int c = 0; c < chks.length; c++) {                for (int r = 0; r < chunkSize; r++) {                    chks[c].set(r, A_vecs[(int) (start + r)].at(c));                }            }        }    }.doAll(At);        return new H2ODrm(At);}
ddc3fccb977dc9927fe4feb37fef674297b12b518e9a43925fef8415b7e48592
map
public void map(Chunk[] chks)
{    int chunkSize = chks[0].len();    long start = chks[0].start();    Vec[] A_vecs = A.vecs();    for (int c = 0; c < chks.length; c++) {        for (int r = 0; r < chunkSize; r++) {            chks[c].set(r, A_vecs[(int) (start + r)].at(c));        }    }}
20d48d68d1d1c31003fa7e01d8f84b2be013310d8d408ac86d2490cca39fcf06
exec
public static H2ODrm exec(H2ODrm drmA)
{    final Frame A = drmA.frame;        Frame AtA = H2OHelper.emptyFrame(A.numCols(), A.numCols(), -1, -1);                    new MRTask() {        public void map(Chunk[] chks) {            int chunkSize = chks[0].len();            long start = chks[0].start();            Vec[] A_vecs = A.vecs();            long A_rows = A.numRows();            for (int c = 0; c < chks.length; c++) {                for (int r = 0; r < chunkSize; r++) {                    double v = 0;                    for (long i = 0; i < A_rows; i++) {                        v += (A_vecs[(int) (start + r)].at(i) * A_vecs[c].at(i));                    }                    chks[c].set(r, v);                }            }        }    }.doAll(AtA);        return new H2ODrm(AtA);}
ddc3fccb977dc9927fe4feb37fef674297b12b518e9a43925fef8415b7e48592
map
public void map(Chunk[] chks)
{    int chunkSize = chks[0].len();    long start = chks[0].start();    Vec[] A_vecs = A.vecs();    long A_rows = A.numRows();    for (int c = 0; c < chks.length; c++) {        for (int r = 0; r < chunkSize; r++) {            double v = 0;            for (long i = 0; i < A_rows; i++) {                v += (A_vecs[(int) (start + r)].at(i) * A_vecs[c].at(i));            }            chks[c].set(r, v);        }    }}
24dbb41fa5435a5d7c48547b137d5065be9ed6aa23d2b0e59cccef0c7748b3b3
exec
public static H2ODrm exec(H2ODrm drmA, H2ODrm drmB)
{    final Frame A = drmA.frame;    final Frame B = drmB.frame;        Frame AtB = H2OHelper.emptyFrame(A.numCols(), B.numCols(), -1, -1);                    new MRTask() {        public void map(Chunk[] chks) {            int chunkSize = chks[0].len();            long start = chks[0].start();            long A_rows = A.numRows();            Vec[] A_vecs = A.vecs();            Vec[] B_vecs = B.vecs();            for (int c = 0; c < chks.length; c++) {                for (int r = 0; r < chunkSize; r++) {                    double v = 0;                    for (long i = 0; i < A_rows; i++) {                        v += (A_vecs[(int) (start + r)].at(i) * B_vecs[c].at(i));                    }                    chks[c].set(r, v);                }            }        }    }.doAll(AtB);        return new H2ODrm(AtB);}
ddc3fccb977dc9927fe4feb37fef674297b12b518e9a43925fef8415b7e48592
map
public void map(Chunk[] chks)
{    int chunkSize = chks[0].len();    long start = chks[0].start();    long A_rows = A.numRows();    Vec[] A_vecs = A.vecs();    Vec[] B_vecs = B.vecs();    for (int c = 0; c < chks.length; c++) {        for (int r = 0; r < chunkSize; r++) {            double v = 0;            for (long i = 0; i < A_rows; i++) {                v += (A_vecs[(int) (start + r)].at(i) * B_vecs[c].at(i));            }            chks[c].set(r, v);        }    }}
0ac524960804ff7fed40be42b137d11103edde37ce5197cb4c8fa43887969d3e
exec
public static H2ODrm exec(H2ODrm drmA, Vector x)
{    Frame A = drmA.frame;    final H2OBCast<Vector> bx = new H2OBCast<>(x);        class MRTaskAtx extends MRTask<MRTaskAtx> {        double[] atx;        public void map(Chunk[] chks) {            int chunkSize = chks[0].len();            Vector x = bx.value();            long start = chks[0].start();            atx = new double[chks.length];            for (int r = 0; r < chunkSize; r++) {                double d = x.getQuick((int) start + r);                for (int c = 0; c < chks.length; c++) {                    atx[c] += (chks[c].atd(r) * d);                }            }        }        public void reduce(MRTaskAtx other) {            ArrayUtils.add(atx, other.atx);        }    }                Vector v = new DenseVector(new MRTaskAtx().doAll(A).atx);    Matrix m = new DenseMatrix(A.numCols(), 1);    m.assignColumn(0, v);    return H2OHelper.drmFromMatrix(m, -1, -1);}
ddc3fccb977dc9927fe4feb37fef674297b12b518e9a43925fef8415b7e48592
map
public void map(Chunk[] chks)
{    int chunkSize = chks[0].len();    Vector x = bx.value();    long start = chks[0].start();    atx = new double[chks.length];    for (int r = 0; r < chunkSize; r++) {        double d = x.getQuick((int) start + r);        for (int c = 0; c < chks.length; c++) {            atx[c] += (chks[c].atd(r) * d);        }    }}
89c108ad77d6d8bb2fad887e9eb47350865491fc84545adb6046ad07dfbcfb42
reduce
public void reduce(MRTaskAtx other)
{    ArrayUtils.add(atx, other.atx);}
0ac524960804ff7fed40be42b137d11103edde37ce5197cb4c8fa43887969d3e
exec
public static H2ODrm exec(H2ODrm drmA, Vector x)
{    Frame A = drmA.frame;    Vec keys = drmA.keys;    final H2OBCast<Vector> bx = new H2OBCast<>(x);                    Frame Ax = new MRTask() {        public void map(Chunk[] chks, NewChunk nc) {            int chunkSize = chks[0].len();            Vector x = bx.value();            for (int r = 0; r < chunkSize; r++) {                double v = 0;                for (int c = 0; c < chks.length; c++) {                    v += (chks[c].atd(r) * x.getQuick(c));                }                nc.addNum(v);            }        }    }.doAll(1, A).outputFrame(null, null);        return new H2ODrm(Ax, keys);}
0a2f6a8073b2d195efb01539db8f708cb9c185a1790b9c097ad4190bb6a9029c
map
public void map(Chunk[] chks, NewChunk nc)
{    int chunkSize = chks[0].len();    Vector x = bx.value();    for (int r = 0; r < chunkSize; r++) {        double v = 0;        for (int c = 0; c < chks.length; c++) {            v += (chks[c].atd(r) * x.getQuick(c));        }        nc.addNum(v);    }}
24dbb41fa5435a5d7c48547b137d5065be9ed6aa23d2b0e59cccef0c7748b3b3
exec
public static H2ODrm exec(H2ODrm drmA, H2ODrm drmB)
{    Frame fra = drmA.frame;    Vec keysa = drmA.keys;    Frame frb = drmB.frame;    Vec keysb = drmB.keys;        if (fra.anyVec().group() == frb.anyVec().group()) {                return zip(fra, keysa, frb, keysb);    } else {                return join(fra, keysa, frb, keysb);    }}
8bac4cc4eba9fcca4b2ba5d3374b9ff021cbbdebdb4641f31ca1c71f04fdd89c
zip
private static H2ODrm zip(final Frame fra, final Vec keysa, final Frame frb, final Vec keysb)
{        Vec[] vecs = new Vec[fra.vecs().length + frb.vecs().length];    int d = 0;        for (Vec vfra : fra.vecs()) {        vecs[d++] = vfra;    }        for (Vec vfrb : frb.vecs()) {        vecs[d++] = vfrb;    }        Frame fr = new Frame(vecs);    /* Finally, inherit A's string labels into the result */    return new H2ODrm(fr, keysa);}
80249df0f7824662bb716ffd39ba5ab6519203be8c859a93704534abfc5d3aa5
join
private static H2ODrm join(final Frame fra, final Vec keysa, final Frame frb, final Vec keysb)
{        Vec[] bvecs = new Vec[frb.vecs().length];    for (int i = 0; i < bvecs.length; i++) {                bvecs[i] = fra.anyVec().makeZero();    }            new MRTask() {        public void map(Chunk[] chks) {            int chunkSize = chks[0].len();            long start = chks[0].start();            Vec[] vecs = frb.vecs();            for (int r = 0; r < chunkSize; r++) {                for (int c = 0; c < chks.length; c++) {                                        chks[c].set(r, vecs[c].at(start + r));                }            }        }    }.doAll(bvecs);        return zip(fra, keysa, new Frame(bvecs), null);}
ddc3fccb977dc9927fe4feb37fef674297b12b518e9a43925fef8415b7e48592
map
public void map(Chunk[] chks)
{    int chunkSize = chks[0].len();    long start = chks[0].start();    Vec[] vecs = frb.vecs();    for (int r = 0; r < chunkSize; r++) {        for (int c = 0; c < chks.length; c++) {                        chks[c].set(r, vecs[c].at(start + r));        }    }}
1ed43a40117049534c4b18ad1c94dbfc50b399fc9ea7ceb9c4707953b157e1ca
exec
public static H2ODrm exec(H2ODrm drmA, double scalar, boolean leftbind)
{    Frame fra = drmA.frame;    Vec newcol = fra.anyVec().makeCon(scalar);    Vec[] vecs = new Vec[fra.vecs().length + 1];    int d = 0;    if (leftbind)        vecs[d++] = newcol;    for (Vec vfra : fra.vecs()) vecs[d++] = vfra;    if (!leftbind)        vecs[d++] = newcol;    return new H2ODrm(new Frame(vecs), drmA.keys);}
a4ef7b6e258869cc5c7a0d964fa939eeab42941685f3264db14e69d5bdbe6ac2
exec
public static H2ODrm exec(H2ODrm drmA, int ncol, Object bmf, final boolean isRstr, final ClassTag<K> k, final ClassTag<R> r)
{    Frame A = drmA.frame;    Vec keys = drmA.keys;    /**     * MRTask to execute bmf on partitions. Partitions are     * made accessible to bmf in the form of H2OBlockMatrix.     */    class MRTaskBMF extends MRTask<MRTaskBMF> {        Serializable bmf;        Vec labels;        MRTaskBMF(Object _bmf, Vec _labels) {                                                                                                bmf = (Serializable) _bmf;            labels = _labels;        }        /**         * Create H2OBlockMatrix from the partition         */        private Matrix blockify(Chunk[] chks) {            return new H2OBlockMatrix(chks);        }        /**         * Ingest the output of bmf into the output partition         */        private void deblockify(Matrix out, NewChunk[] ncs) {                        for (int c = 0; c < out.columnSize(); c++) {                for (int r = 0; r < out.rowSize(); r++) {                    ncs[c].addNum(out.getQuick(r, c));                }            }        }                                                                                                                public void map(Chunk[] chks, NewChunk[] ncs) {            long start = chks[0].start();            NewChunk nclabel = isRstr ? ncs[ncs.length - 1] : null;            deblockify(MapBlockHelper.exec(bmf, blockify(chks), start, labels, nclabel, k, r), ncs);                }    }    int ncolRes = ncol + (isRstr ? 1 : 0);    Frame fmap = new MRTaskBMF(bmf, keys).doAll(ncolRes, A).outputFrame(null, null);    Vec vmap = null;    if (isRstr) {                                vmap = fmap.vecs()[ncol];        fmap = new Frame(Arrays.copyOfRange(fmap.vecs(), 0, ncol));    }    return new H2ODrm(fmap, vmap);}
74566355cf145576a48143463cb56e9ab2b6c5ad718a78913f35b9659cb33bf8
blockify
private Matrix blockify(Chunk[] chks)
{    return new H2OBlockMatrix(chks);}
90c3c95de2f3effb17749d2e9867b37a3ecd2bbde7a2fa8026b624988a6330ff
deblockify
private void deblockify(Matrix out, NewChunk[] ncs)
{        for (int c = 0; c < out.columnSize(); c++) {        for (int r = 0; r < out.rowSize(); r++) {            ncs[c].addNum(out.getQuick(r, c));        }    }}
a8a0f5989db2c0e4079a4eb1cd03669914f894e81474e09cd222ef4f3c3e4163
map
public void map(Chunk[] chks, NewChunk[] ncs)
{    long start = chks[0].start();    NewChunk nclabel = isRstr ? ncs[ncs.length - 1] : null;    deblockify(MapBlockHelper.exec(bmf, blockify(chks), start, labels, nclabel, k, r), ncs);}
8c71874b7a22f5a69d556c2bb37fb8350c98c79fc9406d2748e036701f65d6f4
exec
public static H2ODrm exec(H2ODrm drmA, int min, int exact)
{    final Frame frin = drmA.frame;    final Vec vin = drmA.keys;        Frame frout = H2OHelper.emptyFrame(frin.numRows(), frin.numCols(), min, exact);    Vec vout = null;    if (vin != null) {                                                                vout = new MRTask() {            public void map(Chunk[] chks, NewChunk nc) {                int chunkSize = chks[0].len();                Vec[] vins = frin.vecs();                long start = chks[0].start();                ValueString vstr = new ValueString();                for (int r = 0; r < chunkSize; r++) {                    for (int c = 0; c < chks.length; c++) {                        chks[c].set(r, vins[c].at(start + r));                    }                    nc.addStr(vin.atStr(vstr, start + r));                }            }        }.doAll(1, frout).outputFrame(null, null).anyVec();    } else {                        new MRTask() {            public void map(Chunk[] chks) {                int chunkSize = chks[0].len();                Vec[] vins = frin.vecs();                long start = chks[0].start();                for (int r = 0; r < chunkSize; r++) {                    for (int c = 0; c < chks.length; c++) {                        chks[c].set(r, vins[c].at(start + r));                    }                }            }        }.doAll(frout);    }    return new H2ODrm(frout, vout);}
0a2f6a8073b2d195efb01539db8f708cb9c185a1790b9c097ad4190bb6a9029c
map
public void map(Chunk[] chks, NewChunk nc)
{    int chunkSize = chks[0].len();    Vec[] vins = frin.vecs();    long start = chks[0].start();    ValueString vstr = new ValueString();    for (int r = 0; r < chunkSize; r++) {        for (int c = 0; c < chks.length; c++) {            chks[c].set(r, vins[c].at(start + r));        }        nc.addStr(vin.atStr(vstr, start + r));    }}
ddc3fccb977dc9927fe4feb37fef674297b12b518e9a43925fef8415b7e48592
map
public void map(Chunk[] chks)
{    int chunkSize = chks[0].len();    Vec[] vins = frin.vecs();    long start = chks[0].start();    for (int r = 0; r < chunkSize; r++) {        for (int c = 0; c < chks.length; c++) {            chks[c].set(r, vins[c].at(start + r));        }    }}
24dbb41fa5435a5d7c48547b137d5065be9ed6aa23d2b0e59cccef0c7748b3b3
exec
public static H2ODrm exec(H2ODrm drmA, H2ODrm drmB)
{    final Frame fra = drmA.frame;    final Vec keysa = drmA.keys;    final Frame frb = drmB.frame;    final Vec keysb = drmB.keys;                Frame frbind = H2OHelper.emptyFrame(fra.numRows() + frb.numRows(), fra.numCols(), -1, -1, fra.anyVec().group());    Vec keys = null;    MRTask task = new MRTask() {        public void map(Chunk[] chks, NewChunk nc) {            Vec[] A_vecs = fra.vecs();            Vec[] B_vecs = frb.vecs();            long A_rows = fra.numRows();            long B_rows = frb.numRows();            long start = chks[0].start();            int chunkSize = chks[0].len();            ValueString vstr = new ValueString();            for (int r = 0; r < chunkSize; r++) {                for (int c = 0; c < chks.length; c++) {                    if (r + start < A_rows) {                        chks[c].set(r, A_vecs[c].at(r + start));                        if (keysa != null) {                            nc.addStr(keysa.atStr(vstr, r + start));                        }                    } else {                        chks[c].set(r, B_vecs[c].at(r + start - A_rows));                        if (keysb != null) {                            nc.addStr(keysb.atStr(vstr, r + start - A_rows));                        }                    }                }            }        }    };    if (keysa == null) {        keys = task.doAll(1, frbind).outputFrame(null, null).anyVec();    } else {        task.doAll(frbind);    }    return new H2ODrm(frbind, keys);}
0a2f6a8073b2d195efb01539db8f708cb9c185a1790b9c097ad4190bb6a9029c
map
public void map(Chunk[] chks, NewChunk nc)
{    Vec[] A_vecs = fra.vecs();    Vec[] B_vecs = frb.vecs();    long A_rows = fra.numRows();    long B_rows = frb.numRows();    long start = chks[0].start();    int chunkSize = chks[0].len();    ValueString vstr = new ValueString();    for (int r = 0; r < chunkSize; r++) {        for (int c = 0; c < chks.length; c++) {            if (r + start < A_rows) {                chks[c].set(r, A_vecs[c].at(r + start));                if (keysa != null) {                    nc.addStr(keysa.atStr(vstr, r + start));                }            } else {                chks[c].set(r, B_vecs[c].at(r + start - A_rows));                if (keysb != null) {                    nc.addStr(keysb.atStr(vstr, r + start - A_rows));                }            }        }    }}
da280cb73d9dff1f6db4724f626b7408b107ef47f4ca045c887f3bb2ebccf6aa
exec
public static H2ODrm exec(H2ODrm drmA, final Range R)
{    Frame A = drmA.frame;    Vec keys = drmA.keys;            Frame Arr = new MRTask() {        public void map(Chunk[] chks, NewChunk[] ncs) {            int chunkSize = chks[0].len();            long chunkStart = chks[0].start();                        if (chunkStart > R.end() || (chunkStart + chunkSize) < R.start()) {                return;            }                        for (int r = 0; r < chunkSize; r++) {                if (!R.contains(chunkStart + r)) {                    continue;                }                for (int c = 0; c < chks.length; c++) {                    ncs[c].addNum(chks[c].atd(r));                }            }        }    }.doAll(A.numCols(), A).outputFrame(null, null);    Vec Vrr = (keys == null) ? null : new MRTask() {                        public void map(Chunk chk, NewChunk nc) {            int chunkSize = chk.len();            long chunkStart = chk.start();            ValueString vstr = new ValueString();            if (chunkStart > R.end() || (chunkStart + chunkSize) < R.start()) {                return;            }            for (int r = 0; r < chunkSize; r++) {                if (!R.contains(chunkStart + r)) {                    continue;                }                nc.addStr(chk.atStr(vstr, r));            }        }    }.doAll(1, keys).outputFrame(null, null).anyVec();    return new H2ODrm(Arr, Vrr);}
a8a0f5989db2c0e4079a4eb1cd03669914f894e81474e09cd222ef4f3c3e4163
map
public void map(Chunk[] chks, NewChunk[] ncs)
{    int chunkSize = chks[0].len();    long chunkStart = chks[0].start();        if (chunkStart > R.end() || (chunkStart + chunkSize) < R.start()) {        return;    }        for (int r = 0; r < chunkSize; r++) {        if (!R.contains(chunkStart + r)) {            continue;        }        for (int c = 0; c < chks.length; c++) {            ncs[c].addNum(chks[c].atd(r));        }    }}
86e02438f203125fbdef248e15c1daa2c596248670e9ac0bbd781558ad76eead
map
public void map(Chunk chk, NewChunk nc)
{    int chunkSize = chk.len();    long chunkStart = chk.start();    ValueString vstr = new ValueString();    if (chunkStart > R.end() || (chunkStart + chunkSize) < R.start()) {        return;    }    for (int r = 0; r < chunkSize; r++) {        if (!R.contains(chunkStart + r)) {            continue;        }        nc.addStr(chk.atStr(vstr, r));    }}
34f0759f670f625f7a130e8623e449d8b768034b0e941144d2c205ec0801d660
exec
public static H2ODrm exec(H2ODrm drmA, Matrix B)
{    Frame A = drmA.frame;    Vec keys = drmA.keys;    Frame AinCoreB = null;    if (B instanceof DiagonalMatrix) {        AinCoreB = execDiagonal(A, B.viewDiagonal());    } else {        AinCoreB = execCommon(A, B);    }    return new H2ODrm(AinCoreB, keys);}
6382216ee207d19f6c262431cb84563dcb0bb42a9d14b7e11a143d3efc27ec6d
execDiagonal
private static Frame execDiagonal(final Frame A, Vector d)
{    final H2OBCast<Vector> bd = new H2OBCast<>(d);    return new MRTask() {        public void map(Chunk[] chks, NewChunk[] ncs) {            Vector D = bd.value();            int chunkSize = chks[0].len();            for (int c = 0; c < ncs.length; c++) {                for (int r = 0; r < chunkSize; r++) {                    double v = (chks[c].atd(r) * D.getQuick(c));                    ncs[c].addNum(v);                }            }        }    }.doAll(d.size(), A).outputFrame(null, null);}
a8a0f5989db2c0e4079a4eb1cd03669914f894e81474e09cd222ef4f3c3e4163
map
public void map(Chunk[] chks, NewChunk[] ncs)
{    Vector D = bd.value();    int chunkSize = chks[0].len();    for (int c = 0; c < ncs.length; c++) {        for (int r = 0; r < chunkSize; r++) {            double v = (chks[c].atd(r) * D.getQuick(c));            ncs[c].addNum(v);        }    }}
495daa65de5dd30d76a1ff9a69fd645499e3ccf8b524e404df97fed1891f8203
execCommon
private static Frame execCommon(final Frame A, Matrix b)
{    final H2OBCast<Matrix> bb = new H2OBCast<>(b);    return new MRTask() {        public void map(Chunk[] chks, NewChunk[] ncs) {            Matrix B = bb.value();            int chunkSize = chks[0].len();            for (int c = 0; c < ncs.length; c++) {                for (int r = 0; r < chunkSize; r++) {                    double v = 0;                    for (int i = 0; i < chks.length; i++) {                        v += (chks[i].atd(r) * B.getQuick(i, c));                    }                    ncs[c].addNum(v);                }            }        }    }.doAll(b.columnSize(), A).outputFrame(null, null);}
a8a0f5989db2c0e4079a4eb1cd03669914f894e81474e09cd222ef4f3c3e4163
map
public void map(Chunk[] chks, NewChunk[] ncs)
{    Matrix B = bb.value();    int chunkSize = chks[0].len();    for (int c = 0; c < ncs.length; c++) {        for (int r = 0; r < chunkSize; r++) {            double v = 0;            for (int i = 0; i < chks.length; i++) {                v += (chks[i].atd(r) * B.getQuick(i, c));            }            ncs[c].addNum(v);        }    }}
32f4991447a52ce1c71832ba8c3e77423b73589b2a86a4cf6b791ecd334b4cbd
randIndex
protected int randIndex()
{    return BenchmarkRunner.randIndex();}
2c07152802fb79d67e62f7816dc9a2baf0cb232a77aa34caac07d8fbf1d181f3
randBool
protected boolean randBool()
{    return BenchmarkRunner.randBool();}
69c48b41e21d15f79d4cb5ae0d0dd6d907fc30bff3d3dc6b386a9d00aa8cec87
depends
protected boolean depends(Vector v)
{    return randIndex() < v.getNumNondefaultElements();}
32f4991447a52ce1c71832ba8c3e77423b73589b2a86a4cf6b791ecd334b4cbd
randIndex
protected int randIndex()
{    return BenchmarkRunner.randIndex();}
2c07152802fb79d67e62f7816dc9a2baf0cb232a77aa34caac07d8fbf1d181f3
randBool
protected boolean randBool()
{    return BenchmarkRunner.randBool();}
69c48b41e21d15f79d4cb5ae0d0dd6d907fc30bff3d3dc6b386a9d00aa8cec87
depends
protected boolean depends(Vector v)
{    return randIndex() < v.getNumNondefaultElements();}
8b3fc5c30928af9c3c2e4cf13986bf6a82c647ac6b68b8bce62633dad4d9572e
randIndex
private static int randIndex()
{    return R.nextInt(BUCKET_SIZE);}
1ff789b3c782d796e05d578482a51e5128e5b152a74214cef20f8b7aaba2d521
randBool
private static boolean randBool()
{    return R.nextBoolean();}
8aabccc8692bdc697385c02c3f8aef032d144b1b540a537cd6593d14e78daa2d
benchmark
public TimingStatistics benchmark(BenchmarkFn function)
{    TimingStatistics stats = new TimingStatistics();    boolean result = false;    while (true) {        int i = R.nextInt(BUCKET_SIZE);        TimingStatistics.Call call = stats.newCall(leadTimeUsec);        result = result ^ function.apply(i);        if (call.end(maxTimeUsec)) {            break;        }    }    return stats;}
9d5f2d905387f692232c30c28154ac43f2e78575568aa27419a116dcda704086
benchmarkD
public TimingStatistics benchmarkD(BenchmarkFnD function)
{    TimingStatistics stats = new TimingStatistics();    double result = 0;    while (true) {        int i = R.nextInt(BUCKET_SIZE);        TimingStatistics.Call call = stats.newCall(leadTimeUsec);        result += function.apply(i);        if (call.end(maxTimeUsec)) {            break;        }    }        System.err.println("Result = " + result);    return stats;}
7d5b408ffb9726aa9542505210a3eb5a3417b92112e024aaf8ed05d3a89f02ce
benchmark
public void benchmark()
{    mark.printStats(mark.getRunner().benchmark(new BenchmarkFn() {        @Override        public Boolean apply(Integer i) {            mark.vectors[0][mark.vIndex(i)] = mark.vectors[0][mark.vIndex(i)].clone();            return depends(mark.vectors[0][mark.vIndex(i)]);        }    }), CLONE, DENSE_VECTOR);    mark.printStats(mark.getRunner().benchmark(new BenchmarkFn() {        @Override        public Boolean apply(Integer i) {            mark.vectors[1][mark.vIndex(i)] = mark.vectors[1][mark.vIndex(i)].clone();            return depends(mark.vectors[1][mark.vIndex(i)]);        }    }), CLONE, RAND_SPARSE_VECTOR);    mark.printStats(mark.getRunner().benchmark(new BenchmarkFn() {        @Override        public Boolean apply(Integer i) {            mark.vectors[2][mark.vIndex(i)] = mark.vectors[2][mark.vIndex(i)].clone();            return depends(mark.vectors[2][mark.vIndex(i)]);        }    }), CLONE, SEQ_SPARSE_VECTOR);}
fe63787823b74d71a2969b408a8ef44d963d58081b3b21c67c90353c48517d9d
apply
public Boolean apply(Integer i)
{    mark.vectors[0][mark.vIndex(i)] = mark.vectors[0][mark.vIndex(i)].clone();    return depends(mark.vectors[0][mark.vIndex(i)]);}
fe63787823b74d71a2969b408a8ef44d963d58081b3b21c67c90353c48517d9d
apply
public Boolean apply(Integer i)
{    mark.vectors[1][mark.vIndex(i)] = mark.vectors[1][mark.vIndex(i)].clone();    return depends(mark.vectors[1][mark.vIndex(i)]);}
fe63787823b74d71a2969b408a8ef44d963d58081b3b21c67c90353c48517d9d
apply
public Boolean apply(Integer i)
{    mark.vectors[2][mark.vIndex(i)] = mark.vectors[2][mark.vIndex(i)].clone();    return depends(mark.vectors[2][mark.vIndex(i)]);}
feaaa7568f960489fde0cfbc5cad4bb8bb408c908111ee4585ba4a2d52ac7d0d
benchmark
public void benchmark(DistanceMeasure measure) throws IOException
{    SparseMatrix clusterDistances = new SparseMatrix(mark.numClusters, mark.numClusters);    for (int i = 0; i < mark.numClusters; i++) {        for (int j = 0; j < mark.numClusters; j++) {            double distance = Double.POSITIVE_INFINITY;            if (i != j) {                distance = measure.distance(mark.clusters[i], mark.clusters[j]);            }            clusterDistances.setQuick(i, j, distance);        }    }    long distanceCalculations = 0;    TimingStatistics stats = new TimingStatistics();    for (int l = 0; l < mark.loop; l++) {        TimingStatistics.Call call = stats.newCall(mark.leadTimeUsec);        for (int i = 0; i < mark.numVectors; i++) {            Vector vector = mark.vectors[1][mark.vIndex(i)];            double minDistance = Double.MAX_VALUE;            for (int k = 0; k < mark.numClusters; k++) {                double distance = measure.distance(vector, mark.clusters[k]);                distanceCalculations++;                if (distance < minDistance) {                    minDistance = distance;                }            }        }        if (call.end(mark.maxTimeUsec)) {            break;        }    }    mark.printStats(stats, measure.getClass().getName(), "Closest C w/o Elkan's trick", "distanceCalculations = " + distanceCalculations);    distanceCalculations = 0;    stats = new TimingStatistics();    Random rand = RandomUtils.getRandom();    for (int l = 0; l < mark.loop; l++) {        TimingStatistics.Call call = stats.newCall(mark.leadTimeUsec);        for (int i = 0; i < mark.numVectors; i++) {            Vector vector = mark.vectors[1][mark.vIndex(i)];            int closestCentroid = rand.nextInt(mark.numClusters);            double dist = measure.distance(vector, mark.clusters[closestCentroid]);            distanceCalculations++;            for (int k = 0; k < mark.numClusters; k++) {                if (closestCentroid != k) {                    double centroidDist = clusterDistances.getQuick(k, closestCentroid);                    if (centroidDist < 2 * dist) {                        dist = measure.distance(vector, mark.clusters[k]);                        closestCentroid = k;                        distanceCalculations++;                    }                }            }        }        if (call.end(mark.maxTimeUsec)) {            break;        }    }    mark.printStats(stats, measure.getClass().getName(), "Closest C w/ Elkan's trick", "distanceCalculations = " + distanceCalculations);}
bcb39731b4e3a52013246e0fb84fe69b2e3dc287d85ce2c477caff869a8989ea
benchmark
public void benchmark(final DistanceMeasure measure)
{    mark.printStats(mark.getRunner().benchmarkD(new BenchmarkFnD() {        @Override        public Double apply(Integer i) {            return measure.distance(mark.vectors[0][mark.vIndex(i)], mark.vectors[0][mark.vIndex(randIndex())]);        }    }), measure.getClass().getName(), DENSE_VECTOR);    mark.printStats(mark.getRunner().benchmarkD(new BenchmarkFnD() {        @Override        public Double apply(Integer i) {            return measure.distance(mark.vectors[1][mark.vIndex(i)], mark.vectors[1][mark.vIndex(randIndex())]);        }    }), measure.getClass().getName(), RAND_SPARSE_VECTOR);    mark.printStats(mark.getRunner().benchmarkD(new BenchmarkFnD() {        @Override        public Double apply(Integer i) {            return measure.distance(mark.vectors[2][mark.vIndex(i)], mark.vectors[2][mark.vIndex(randIndex())]);        }    }), measure.getClass().getName(), SEQ_SPARSE_VECTOR);    mark.printStats(mark.getRunner().benchmarkD(new BenchmarkFnD() {        @Override        public Double apply(Integer i) {            return measure.distance(mark.vectors[0][mark.vIndex(i)], mark.vectors[1][mark.vIndex(randIndex())]);        }    }), measure.getClass().getName(), DENSE_FN_RAND);    mark.printStats(mark.getRunner().benchmarkD(new BenchmarkFnD() {        @Override        public Double apply(Integer i) {            return measure.distance(mark.vectors[0][mark.vIndex(i)], mark.vectors[2][mark.vIndex(randIndex())]);        }    }), measure.getClass().getName(), DENSE_FN_SEQ);    mark.printStats(mark.getRunner().benchmarkD(new BenchmarkFnD() {        @Override        public Double apply(Integer i) {            return measure.distance(mark.vectors[1][mark.vIndex(i)], mark.vectors[0][mark.vIndex(randIndex())]);        }    }), measure.getClass().getName(), RAND_FN_DENSE);    mark.printStats(mark.getRunner().benchmarkD(new BenchmarkFnD() {        @Override        public Double apply(Integer i) {            return measure.distance(mark.vectors[1][mark.vIndex(i)], mark.vectors[2][mark.vIndex(randIndex())]);        }    }), measure.getClass().getName(), RAND_FN_SEQ);    mark.printStats(mark.getRunner().benchmarkD(new BenchmarkFnD() {        @Override        public Double apply(Integer i) {            return measure.distance(mark.vectors[2][mark.vIndex(i)], mark.vectors[0][mark.vIndex(randIndex())]);        }    }), measure.getClass().getName(), SEQ_FN_DENSE);    mark.printStats(mark.getRunner().benchmarkD(new BenchmarkFnD() {        @Override        public Double apply(Integer i) {            return measure.distance(mark.vectors[2][mark.vIndex(i)], mark.vectors[1][mark.vIndex(randIndex())]);        }    }), measure.getClass().getName(), SEQ_FN_RAND);}
75702f1afeaf05e8f9ece6d360b4407373f4211e3c55c86444d0e0e14504a5fd
apply
public Double apply(Integer i)
{    return measure.distance(mark.vectors[0][mark.vIndex(i)], mark.vectors[0][mark.vIndex(randIndex())]);}
75702f1afeaf05e8f9ece6d360b4407373f4211e3c55c86444d0e0e14504a5fd
apply
public Double apply(Integer i)
{    return measure.distance(mark.vectors[1][mark.vIndex(i)], mark.vectors[1][mark.vIndex(randIndex())]);}
75702f1afeaf05e8f9ece6d360b4407373f4211e3c55c86444d0e0e14504a5fd
apply
public Double apply(Integer i)
{    return measure.distance(mark.vectors[2][mark.vIndex(i)], mark.vectors[2][mark.vIndex(randIndex())]);}
75702f1afeaf05e8f9ece6d360b4407373f4211e3c55c86444d0e0e14504a5fd
apply
public Double apply(Integer i)
{    return measure.distance(mark.vectors[0][mark.vIndex(i)], mark.vectors[1][mark.vIndex(randIndex())]);}
75702f1afeaf05e8f9ece6d360b4407373f4211e3c55c86444d0e0e14504a5fd
apply
public Double apply(Integer i)
{    return measure.distance(mark.vectors[0][mark.vIndex(i)], mark.vectors[2][mark.vIndex(randIndex())]);}
75702f1afeaf05e8f9ece6d360b4407373f4211e3c55c86444d0e0e14504a5fd
apply
public Double apply(Integer i)
{    return measure.distance(mark.vectors[1][mark.vIndex(i)], mark.vectors[0][mark.vIndex(randIndex())]);}
75702f1afeaf05e8f9ece6d360b4407373f4211e3c55c86444d0e0e14504a5fd
apply
public Double apply(Integer i)
{    return measure.distance(mark.vectors[1][mark.vIndex(i)], mark.vectors[2][mark.vIndex(randIndex())]);}
75702f1afeaf05e8f9ece6d360b4407373f4211e3c55c86444d0e0e14504a5fd
apply
public Double apply(Integer i)
{    return measure.distance(mark.vectors[2][mark.vIndex(i)], mark.vectors[0][mark.vIndex(randIndex())]);}
75702f1afeaf05e8f9ece6d360b4407373f4211e3c55c86444d0e0e14504a5fd
apply
public Double apply(Integer i)
{    return measure.distance(mark.vectors[2][mark.vIndex(i)], mark.vectors[1][mark.vIndex(randIndex())]);}
7d5b408ffb9726aa9542505210a3eb5a3417b92112e024aaf8ed05d3a89f02ce
benchmark
public void benchmark()
{    benchmarkDot();    benchmarkNorm1();    benchmarkNorm2();    benchmarkLogNormalize();}
3aed9300e6ca8766c172c398764fb4c8e68255f3bf3daaf83edb65a0bffa4dbd
benchmarkLogNormalize
private void benchmarkLogNormalize()
{    mark.printStats(mark.getRunner().benchmark(new BenchmarkFn() {        @Override        public Boolean apply(Integer i) {            return depends(mark.vectors[0][mark.vIndex(i)].logNormalize());        }    }), LOG_NORMALIZE, DENSE_VECTOR);    mark.printStats(mark.getRunner().benchmark(new BenchmarkFn() {        @Override        public Boolean apply(Integer i) {            return depends(mark.vectors[1][mark.vIndex(i)].logNormalize());        }    }), LOG_NORMALIZE, RAND_SPARSE_VECTOR);    mark.printStats(mark.getRunner().benchmark(new BenchmarkFn() {        @Override        public Boolean apply(Integer i) {            return depends(mark.vectors[2][mark.vIndex(i)].logNormalize());        }    }), LOG_NORMALIZE, SEQ_SPARSE_VECTOR);}
fe63787823b74d71a2969b408a8ef44d963d58081b3b21c67c90353c48517d9d
apply
public Boolean apply(Integer i)
{    return depends(mark.vectors[0][mark.vIndex(i)].logNormalize());}
fe63787823b74d71a2969b408a8ef44d963d58081b3b21c67c90353c48517d9d
apply
public Boolean apply(Integer i)
{    return depends(mark.vectors[1][mark.vIndex(i)].logNormalize());}
fe63787823b74d71a2969b408a8ef44d963d58081b3b21c67c90353c48517d9d
apply
public Boolean apply(Integer i)
{    return depends(mark.vectors[2][mark.vIndex(i)].logNormalize());}
47c11094c0dab1d0a4f220d05e0f67fb7dce671a78c22b3c1d8a236576b2464c
benchmarkNorm1
private void benchmarkNorm1()
{    mark.printStats(mark.getRunner().benchmarkD(new BenchmarkFnD() {        @Override        public Double apply(Integer i) {            return mark.vectors[0][mark.vIndex(i)].norm(1);        }    }), NORM1, DENSE_VECTOR);    mark.printStats(mark.getRunner().benchmarkD(new BenchmarkFnD() {        @Override        public Double apply(Integer i) {            return mark.vectors[1][mark.vIndex(i)].norm(1);        }    }), NORM1, RAND_SPARSE_VECTOR);    mark.printStats(mark.getRunner().benchmarkD(new BenchmarkFnD() {        @Override        public Double apply(Integer i) {            return mark.vectors[2][mark.vIndex(i)].norm(1);        }    }), NORM1, SEQ_SPARSE_VECTOR);}
75702f1afeaf05e8f9ece6d360b4407373f4211e3c55c86444d0e0e14504a5fd
apply
public Double apply(Integer i)
{    return mark.vectors[0][mark.vIndex(i)].norm(1);}
75702f1afeaf05e8f9ece6d360b4407373f4211e3c55c86444d0e0e14504a5fd
apply
public Double apply(Integer i)
{    return mark.vectors[1][mark.vIndex(i)].norm(1);}
75702f1afeaf05e8f9ece6d360b4407373f4211e3c55c86444d0e0e14504a5fd
apply
public Double apply(Integer i)
{    return mark.vectors[2][mark.vIndex(i)].norm(1);}
465653f7b264f0c754160a326350d17947b12ef9f1b7006d43dc80e9acf0038d
benchmarkNorm2
private void benchmarkNorm2()
{    mark.printStats(mark.getRunner().benchmarkD(new BenchmarkFnD() {        @Override        public Double apply(Integer i) {            return mark.vectors[0][mark.vIndex(i)].norm(2);        }    }), NORM2, DENSE_VECTOR);    mark.printStats(mark.getRunner().benchmarkD(new BenchmarkFnD() {        @Override        public Double apply(Integer i) {            return mark.vectors[1][mark.vIndex(i)].norm(2);        }    }), NORM2, RAND_SPARSE_VECTOR);    mark.printStats(mark.getRunner().benchmarkD(new BenchmarkFnD() {        @Override        public Double apply(Integer i) {            return mark.vectors[2][mark.vIndex(i)].norm(2);        }    }), NORM2, SEQ_SPARSE_VECTOR);}
75702f1afeaf05e8f9ece6d360b4407373f4211e3c55c86444d0e0e14504a5fd
apply
public Double apply(Integer i)
{    return mark.vectors[0][mark.vIndex(i)].norm(2);}
75702f1afeaf05e8f9ece6d360b4407373f4211e3c55c86444d0e0e14504a5fd
apply
public Double apply(Integer i)
{    return mark.vectors[1][mark.vIndex(i)].norm(2);}
75702f1afeaf05e8f9ece6d360b4407373f4211e3c55c86444d0e0e14504a5fd
apply
public Double apply(Integer i)
{    return mark.vectors[2][mark.vIndex(i)].norm(2);}
49be51b8eddd92456b5bbfb5636803e1a4d263916dbe71021245fdce4f89c309
benchmarkDot
private void benchmarkDot()
{    mark.printStats(mark.getRunner().benchmarkD(new BenchmarkFnD() {        @Override        public Double apply(Integer i) {            return mark.vectors[0][mark.vIndex(i)].dot(mark.vectors[0][mark.vIndex(randIndex())]);        }    }), DOT_PRODUCT, DENSE_VECTOR);    mark.printStats(mark.getRunner().benchmarkD(new BenchmarkFnD() {        @Override        public Double apply(Integer i) {            return mark.vectors[1][mark.vIndex(i)].dot(mark.vectors[1][mark.vIndex(randIndex())]);        }    }), DOT_PRODUCT, RAND_SPARSE_VECTOR);    mark.printStats(mark.getRunner().benchmarkD(new BenchmarkFnD() {        @Override        public Double apply(Integer i) {            return mark.vectors[2][mark.vIndex(i)].dot(mark.vectors[2][mark.vIndex(randIndex())]);        }    }), DOT_PRODUCT, SEQ_SPARSE_VECTOR);    mark.printStats(mark.getRunner().benchmarkD(new BenchmarkFnD() {        @Override        public Double apply(Integer i) {            return mark.vectors[0][mark.vIndex(i)].dot(mark.vectors[1][mark.vIndex(randIndex())]);        }    }), DOT_PRODUCT, DENSE_FN_RAND);    mark.printStats(mark.getRunner().benchmarkD(new BenchmarkFnD() {        @Override        public Double apply(Integer i) {            return mark.vectors[0][mark.vIndex(i)].dot(mark.vectors[2][mark.vIndex(randIndex())]);        }    }), DOT_PRODUCT, DENSE_FN_SEQ);    mark.printStats(mark.getRunner().benchmarkD(new BenchmarkFnD() {        @Override        public Double apply(Integer i) {            return mark.vectors[1][mark.vIndex(i)].dot(mark.vectors[0][mark.vIndex(randIndex())]);        }    }), DOT_PRODUCT, RAND_FN_DENSE);    mark.printStats(mark.getRunner().benchmarkD(new BenchmarkFnD() {        @Override        public Double apply(Integer i) {            return mark.vectors[1][mark.vIndex(i)].dot(mark.vectors[2][mark.vIndex(randIndex())]);        }    }), DOT_PRODUCT, RAND_FN_SEQ);    mark.printStats(mark.getRunner().benchmarkD(new BenchmarkFnD() {        @Override        public Double apply(Integer i) {            return mark.vectors[2][mark.vIndex(i)].dot(mark.vectors[0][mark.vIndex(randIndex())]);        }    }), DOT_PRODUCT, SEQ_FN_DENSE);    mark.printStats(mark.getRunner().benchmarkD(new BenchmarkFnD() {        @Override        public Double apply(Integer i) {            return mark.vectors[2][mark.vIndex(i)].dot(mark.vectors[1][mark.vIndex(randIndex())]);        }    }), DOT_PRODUCT, SEQ_FN_RAND);}
75702f1afeaf05e8f9ece6d360b4407373f4211e3c55c86444d0e0e14504a5fd
apply
public Double apply(Integer i)
{    return mark.vectors[0][mark.vIndex(i)].dot(mark.vectors[0][mark.vIndex(randIndex())]);}
75702f1afeaf05e8f9ece6d360b4407373f4211e3c55c86444d0e0e14504a5fd
apply
public Double apply(Integer i)
{    return mark.vectors[1][mark.vIndex(i)].dot(mark.vectors[1][mark.vIndex(randIndex())]);}
75702f1afeaf05e8f9ece6d360b4407373f4211e3c55c86444d0e0e14504a5fd
apply
public Double apply(Integer i)
{    return mark.vectors[2][mark.vIndex(i)].dot(mark.vectors[2][mark.vIndex(randIndex())]);}
75702f1afeaf05e8f9ece6d360b4407373f4211e3c55c86444d0e0e14504a5fd
apply
public Double apply(Integer i)
{    return mark.vectors[0][mark.vIndex(i)].dot(mark.vectors[1][mark.vIndex(randIndex())]);}
75702f1afeaf05e8f9ece6d360b4407373f4211e3c55c86444d0e0e14504a5fd
apply
public Double apply(Integer i)
{    return mark.vectors[0][mark.vIndex(i)].dot(mark.vectors[2][mark.vIndex(randIndex())]);}
75702f1afeaf05e8f9ece6d360b4407373f4211e3c55c86444d0e0e14504a5fd
apply
public Double apply(Integer i)
{    return mark.vectors[1][mark.vIndex(i)].dot(mark.vectors[0][mark.vIndex(randIndex())]);}
75702f1afeaf05e8f9ece6d360b4407373f4211e3c55c86444d0e0e14504a5fd
apply
public Double apply(Integer i)
{    return mark.vectors[1][mark.vIndex(i)].dot(mark.vectors[2][mark.vIndex(randIndex())]);}
75702f1afeaf05e8f9ece6d360b4407373f4211e3c55c86444d0e0e14504a5fd
apply
public Double apply(Integer i)
{    return mark.vectors[2][mark.vIndex(i)].dot(mark.vectors[0][mark.vIndex(randIndex())]);}
75702f1afeaf05e8f9ece6d360b4407373f4211e3c55c86444d0e0e14504a5fd
apply
public Double apply(Integer i)
{    return mark.vectors[2][mark.vIndex(i)].dot(mark.vectors[1][mark.vIndex(randIndex())]);}
3116ea2053d9de960ec3753eb07f3d243c370662aa1f0175ad357057c9ce5a52
main
public static void main(String[] args)
{    VectorBenchmarks mark = new VectorBenchmarks(1000000, 100, 1000, 10, 1);    mark.createData();    new DotBenchmark(mark).benchmarkNorm2();    System.out.println(mark);}
7d5b408ffb9726aa9542505210a3eb5a3417b92112e024aaf8ed05d3a89f02ce
benchmark
public void benchmark()
{    mark.printStats(mark.getRunner().benchmark(new BenchmarkFn() {        @Override        public Boolean apply(Integer i) {            Vector v = mark.vectors[0][mark.vIndex(i)].minus(mark.vectors[0][mark.vIndex(randIndex())]);            return depends(v);        }    }), MINUS, DENSE_VECTOR);    mark.printStats(mark.getRunner().benchmark(new BenchmarkFn() {        @Override        public Boolean apply(Integer i) {            Vector v = mark.vectors[1][mark.vIndex(i)].minus(mark.vectors[1][mark.vIndex(randIndex())]);            return depends(v);        }    }), MINUS, RAND_SPARSE_VECTOR);    mark.printStats(mark.getRunner().benchmark(new BenchmarkFn() {        @Override        public Boolean apply(Integer i) {            Vector v = mark.vectors[2][mark.vIndex(i)].minus(mark.vectors[2][mark.vIndex(randIndex())]);            return depends(v);        }    }), MINUS, SEQ_SPARSE_VECTOR);    mark.printStats(mark.getRunner().benchmark(new BenchmarkFn() {        @Override        public Boolean apply(Integer i) {            Vector v = mark.vectors[0][mark.vIndex(i)].minus(mark.vectors[1][mark.vIndex(randIndex())]);            return depends(v);        }    }), MINUS, DENSE_FN_RAND);    mark.printStats(mark.getRunner().benchmark(new BenchmarkFn() {        @Override        public Boolean apply(Integer i) {            Vector v = mark.vectors[0][mark.vIndex(i)].minus(mark.vectors[2][mark.vIndex(randIndex())]);            return depends(v);        }    }), MINUS, DENSE_FN_SEQ);    mark.printStats(mark.getRunner().benchmark(new BenchmarkFn() {        @Override        public Boolean apply(Integer i) {            Vector v = mark.vectors[1][mark.vIndex(i)].minus(mark.vectors[0][mark.vIndex(randIndex())]);            return depends(v);        }    }), MINUS, RAND_FN_DENSE);    mark.printStats(mark.getRunner().benchmark(new BenchmarkFn() {        @Override        public Boolean apply(Integer i) {            Vector v = mark.vectors[1][mark.vIndex(i)].minus(mark.vectors[2][mark.vIndex(randIndex())]);            return depends(v);        }    }), MINUS, RAND_FN_SEQ);    mark.printStats(mark.getRunner().benchmark(new BenchmarkFn() {        @Override        public Boolean apply(Integer i) {            Vector v = mark.vectors[2][mark.vIndex(i)].minus(mark.vectors[0][mark.vIndex(randIndex())]);            return depends(v);        }    }), MINUS, SEQ_FN_DENSE);    mark.printStats(mark.getRunner().benchmark(new BenchmarkFn() {        @Override        public Boolean apply(Integer i) {            Vector v = mark.vectors[2][mark.vIndex(i)].minus(mark.vectors[1][mark.vIndex(randIndex())]);            return depends(v);        }    }), MINUS, SEQ_FN_RAND);}
fe63787823b74d71a2969b408a8ef44d963d58081b3b21c67c90353c48517d9d
apply
public Boolean apply(Integer i)
{    Vector v = mark.vectors[0][mark.vIndex(i)].minus(mark.vectors[0][mark.vIndex(randIndex())]);    return depends(v);}
fe63787823b74d71a2969b408a8ef44d963d58081b3b21c67c90353c48517d9d
apply
public Boolean apply(Integer i)
{    Vector v = mark.vectors[1][mark.vIndex(i)].minus(mark.vectors[1][mark.vIndex(randIndex())]);    return depends(v);}
fe63787823b74d71a2969b408a8ef44d963d58081b3b21c67c90353c48517d9d
apply
public Boolean apply(Integer i)
{    Vector v = mark.vectors[2][mark.vIndex(i)].minus(mark.vectors[2][mark.vIndex(randIndex())]);    return depends(v);}
fe63787823b74d71a2969b408a8ef44d963d58081b3b21c67c90353c48517d9d
apply
public Boolean apply(Integer i)
{    Vector v = mark.vectors[0][mark.vIndex(i)].minus(mark.vectors[1][mark.vIndex(randIndex())]);    return depends(v);}
fe63787823b74d71a2969b408a8ef44d963d58081b3b21c67c90353c48517d9d
apply
public Boolean apply(Integer i)
{    Vector v = mark.vectors[0][mark.vIndex(i)].minus(mark.vectors[2][mark.vIndex(randIndex())]);    return depends(v);}
fe63787823b74d71a2969b408a8ef44d963d58081b3b21c67c90353c48517d9d
apply
public Boolean apply(Integer i)
{    Vector v = mark.vectors[1][mark.vIndex(i)].minus(mark.vectors[0][mark.vIndex(randIndex())]);    return depends(v);}
fe63787823b74d71a2969b408a8ef44d963d58081b3b21c67c90353c48517d9d
apply
public Boolean apply(Integer i)
{    Vector v = mark.vectors[1][mark.vIndex(i)].minus(mark.vectors[2][mark.vIndex(randIndex())]);    return depends(v);}
fe63787823b74d71a2969b408a8ef44d963d58081b3b21c67c90353c48517d9d
apply
public Boolean apply(Integer i)
{    Vector v = mark.vectors[2][mark.vIndex(i)].minus(mark.vectors[0][mark.vIndex(randIndex())]);    return depends(v);}
fe63787823b74d71a2969b408a8ef44d963d58081b3b21c67c90353c48517d9d
apply
public Boolean apply(Integer i)
{    Vector v = mark.vectors[2][mark.vIndex(i)].minus(mark.vectors[1][mark.vIndex(randIndex())]);    return depends(v);}
7d5b408ffb9726aa9542505210a3eb5a3417b92112e024aaf8ed05d3a89f02ce
benchmark
public void benchmark()
{    mark.printStats(mark.getRunner().benchmark(new BenchmarkFn() {        @Override        public Boolean apply(Integer i) {            Vector v = mark.vectors[0][mark.vIndex(i)].plus(mark.vectors[0][mark.vIndex(randIndex())]);            return depends(v);        }    }), PLUS, DENSE_VECTOR);    mark.printStats(mark.getRunner().benchmark(new BenchmarkFn() {        @Override        public Boolean apply(Integer i) {            Vector v = mark.vectors[1][mark.vIndex(i)].plus(mark.vectors[1][mark.vIndex(randIndex())]);            return depends(v);        }    }), PLUS, RAND_SPARSE_VECTOR);    mark.printStats(mark.getRunner().benchmark(new BenchmarkFn() {        @Override        public Boolean apply(Integer i) {            Vector v = mark.vectors[2][mark.vIndex(i)].plus(mark.vectors[2][mark.vIndex(randIndex())]);            return depends(v);        }    }), PLUS, SEQ_SPARSE_VECTOR);    mark.printStats(mark.getRunner().benchmark(new BenchmarkFn() {        @Override        public Boolean apply(Integer i) {            Vector v = mark.vectors[0][mark.vIndex(i)].plus(mark.vectors[1][mark.vIndex(randIndex())]);            return depends(v);        }    }), PLUS, DENSE_FN_RAND);    mark.printStats(mark.getRunner().benchmark(new BenchmarkFn() {        @Override        public Boolean apply(Integer i) {            Vector v = mark.vectors[0][mark.vIndex(i)].plus(mark.vectors[2][mark.vIndex(randIndex())]);            return depends(v);        }    }), PLUS, DENSE_FN_SEQ);    mark.printStats(mark.getRunner().benchmark(new BenchmarkFn() {        @Override        public Boolean apply(Integer i) {            Vector v = mark.vectors[1][mark.vIndex(i)].plus(mark.vectors[0][mark.vIndex(randIndex())]);            return depends(v);        }    }), PLUS, RAND_FN_DENSE);    mark.printStats(mark.getRunner().benchmark(new BenchmarkFn() {        @Override        public Boolean apply(Integer i) {            Vector v = mark.vectors[1][mark.vIndex(i)].plus(mark.vectors[2][mark.vIndex(randIndex())]);            return depends(v);        }    }), PLUS, RAND_FN_SEQ);    mark.printStats(mark.getRunner().benchmark(new BenchmarkFn() {        @Override        public Boolean apply(Integer i) {            Vector v = mark.vectors[2][mark.vIndex(i)].plus(mark.vectors[0][mark.vIndex(randIndex())]);            return depends(v);        }    }), PLUS, SEQ_FN_DENSE);    mark.printStats(mark.getRunner().benchmark(new BenchmarkFn() {        @Override        public Boolean apply(Integer i) {            Vector v = mark.vectors[2][mark.vIndex(i)].plus(mark.vectors[1][mark.vIndex(randIndex())]);            return depends(v);        }    }), PLUS, SEQ_FN_RAND);}
fe63787823b74d71a2969b408a8ef44d963d58081b3b21c67c90353c48517d9d
apply
public Boolean apply(Integer i)
{    Vector v = mark.vectors[0][mark.vIndex(i)].plus(mark.vectors[0][mark.vIndex(randIndex())]);    return depends(v);}
fe63787823b74d71a2969b408a8ef44d963d58081b3b21c67c90353c48517d9d
apply
public Boolean apply(Integer i)
{    Vector v = mark.vectors[1][mark.vIndex(i)].plus(mark.vectors[1][mark.vIndex(randIndex())]);    return depends(v);}
fe63787823b74d71a2969b408a8ef44d963d58081b3b21c67c90353c48517d9d
apply
public Boolean apply(Integer i)
{    Vector v = mark.vectors[2][mark.vIndex(i)].plus(mark.vectors[2][mark.vIndex(randIndex())]);    return depends(v);}
fe63787823b74d71a2969b408a8ef44d963d58081b3b21c67c90353c48517d9d
apply
public Boolean apply(Integer i)
{    Vector v = mark.vectors[0][mark.vIndex(i)].plus(mark.vectors[1][mark.vIndex(randIndex())]);    return depends(v);}
fe63787823b74d71a2969b408a8ef44d963d58081b3b21c67c90353c48517d9d
apply
public Boolean apply(Integer i)
{    Vector v = mark.vectors[0][mark.vIndex(i)].plus(mark.vectors[2][mark.vIndex(randIndex())]);    return depends(v);}
fe63787823b74d71a2969b408a8ef44d963d58081b3b21c67c90353c48517d9d
apply
public Boolean apply(Integer i)
{    Vector v = mark.vectors[1][mark.vIndex(i)].plus(mark.vectors[0][mark.vIndex(randIndex())]);    return depends(v);}
fe63787823b74d71a2969b408a8ef44d963d58081b3b21c67c90353c48517d9d
apply
public Boolean apply(Integer i)
{    Vector v = mark.vectors[1][mark.vIndex(i)].plus(mark.vectors[2][mark.vIndex(randIndex())]);    return depends(v);}
fe63787823b74d71a2969b408a8ef44d963d58081b3b21c67c90353c48517d9d
apply
public Boolean apply(Integer i)
{    Vector v = mark.vectors[2][mark.vIndex(i)].plus(mark.vectors[0][mark.vIndex(randIndex())]);    return depends(v);}
fe63787823b74d71a2969b408a8ef44d963d58081b3b21c67c90353c48517d9d
apply
public Boolean apply(Integer i)
{    Vector v = mark.vectors[2][mark.vIndex(i)].plus(mark.vectors[1][mark.vIndex(randIndex())]);    return depends(v);}
1b12cd284c8e602fbc66b797a5d120a48e94a5e464be794371862fc82dd6cbf8
benchmark
public void benchmark() throws IOException
{    serializeBenchmark();    deserializeBenchmark();}
0c0759d5affbcfa807d3f30bee7050c0bf806a82aafd23b084874ae8357fe662
serializeBenchmark
public void serializeBenchmark() throws IOException
{    Configuration conf = new Configuration();    FileSystem fs = FileSystem.get(conf);    Writable one = new IntWritable(0);    VectorWritable vec = new VectorWritable();    TimingStatistics stats = new TimingStatistics();    try (SequenceFile.Writer writer = new SequenceFile.Writer(fs, conf, new Path("/tmp/dense-vector"), IntWritable.class, VectorWritable.class)) {        for (int i = 0; i < mark.loop; i++) {            TimingStatistics.Call call = stats.newCall(mark.leadTimeUsec);            vec.set(mark.vectors[0][mark.vIndex(i)]);            writer.append(one, vec);            if (call.end(mark.maxTimeUsec)) {                break;            }        }    }    mark.printStats(stats, SERIALIZE, DENSE_VECTOR);    stats = new TimingStatistics();    try (SequenceFile.Writer writer = new SequenceFile.Writer(fs, conf, new Path("/tmp/randsparse-vector"), IntWritable.class, VectorWritable.class)) {        for (int i = 0; i < mark.loop; i++) {            TimingStatistics.Call call = stats.newCall(mark.leadTimeUsec);            vec.set(mark.vectors[1][mark.vIndex(i)]);            writer.append(one, vec);            if (call.end(mark.maxTimeUsec)) {                break;            }        }    }    mark.printStats(stats, SERIALIZE, RAND_SPARSE_VECTOR);    stats = new TimingStatistics();    try (SequenceFile.Writer writer = new SequenceFile.Writer(fs, conf, new Path("/tmp/seqsparse-vector"), IntWritable.class, VectorWritable.class)) {        for (int i = 0; i < mark.loop; i++) {            TimingStatistics.Call call = stats.newCall(mark.leadTimeUsec);            vec.set(mark.vectors[2][mark.vIndex(i)]);            writer.append(one, vec);            if (call.end(mark.maxTimeUsec)) {                break;            }        }    }    mark.printStats(stats, SERIALIZE, SEQ_SPARSE_VECTOR);}
be30ef142b7e691c9a0b20b8acc353b337a48e9556fb4869485853afc3da48cd
deserializeBenchmark
public void deserializeBenchmark() throws IOException
{    doDeserializeBenchmark(DENSE_VECTOR, "/tmp/dense-vector");    doDeserializeBenchmark(RAND_SPARSE_VECTOR, "/tmp/randsparse-vector");    doDeserializeBenchmark(SEQ_SPARSE_VECTOR, "/tmp/seqsparse-vector");}
8aba6e0df30deef4d72658fdaec04b3c90526e4c857062e1827468a9c6717519
doDeserializeBenchmark
private void doDeserializeBenchmark(String name, String pathString) throws IOException
{    TimingStatistics stats = new TimingStatistics();    TimingStatistics.Call call = stats.newCall(mark.leadTimeUsec);    SequenceFileValueIterator<Writable> iterator = new SequenceFileValueIterator<>(new Path(pathString), true, new Configuration());    while (iterator.hasNext()) {        iterator.next();        call.end();        call = stats.newCall(mark.leadTimeUsec);    }    iterator.close();    mark.printStats(stats, DESERIALIZE, name);}
7d5b408ffb9726aa9542505210a3eb5a3417b92112e024aaf8ed05d3a89f02ce
benchmark
public void benchmark()
{    mark.printStats(mark.getRunner().benchmark(new BenchmarkFn() {        @Override        public Boolean apply(Integer i) {            Vector v = mark.vectors[0][mark.vIndex(i)].times(mark.vectors[0][mark.vIndex(randIndex())]);            return depends(v);        }    }), TIMES, DENSE_VECTOR);    mark.printStats(mark.getRunner().benchmark(new BenchmarkFn() {        @Override        public Boolean apply(Integer i) {            Vector v = mark.vectors[1][mark.vIndex(i)].times(mark.vectors[1][mark.vIndex(randIndex())]);            return depends(v);        }    }), TIMES, RAND_SPARSE_VECTOR);    mark.printStats(mark.getRunner().benchmark(new BenchmarkFn() {        @Override        public Boolean apply(Integer i) {            Vector v = mark.vectors[2][mark.vIndex(i)].times(mark.vectors[2][mark.vIndex(randIndex())]);            return depends(v);        }    }), TIMES, SEQ_SPARSE_VECTOR);    mark.printStats(mark.getRunner().benchmark(new BenchmarkFn() {        @Override        public Boolean apply(Integer i) {            Vector v = mark.vectors[0][mark.vIndex(i)].times(mark.vectors[1][mark.vIndex(randIndex())]);            return depends(v);        }    }), TIMES, DENSE_FN_RAND);    mark.printStats(mark.getRunner().benchmark(new BenchmarkFn() {        @Override        public Boolean apply(Integer i) {            Vector v = mark.vectors[0][mark.vIndex(i)].times(mark.vectors[2][mark.vIndex(randIndex())]);            return depends(v);        }    }), TIMES, DENSE_FN_SEQ);    mark.printStats(mark.getRunner().benchmark(new BenchmarkFn() {        @Override        public Boolean apply(Integer i) {            Vector v = mark.vectors[1][mark.vIndex(i)].times(mark.vectors[0][mark.vIndex(randIndex())]);            return depends(v);        }    }), TIMES, RAND_FN_DENSE);    mark.printStats(mark.getRunner().benchmark(new BenchmarkFn() {        @Override        public Boolean apply(Integer i) {            Vector v = mark.vectors[1][mark.vIndex(i)].times(mark.vectors[2][mark.vIndex(randIndex())]);            return depends(v);        }    }), TIMES, RAND_FN_SEQ);    mark.printStats(mark.getRunner().benchmark(new BenchmarkFn() {        @Override        public Boolean apply(Integer i) {            Vector v = mark.vectors[2][mark.vIndex(i)].times(mark.vectors[0][mark.vIndex(randIndex())]);            return depends(v);        }    }), TIMES, SEQ_FN_DENSE);    mark.printStats(mark.getRunner().benchmark(new BenchmarkFn() {        @Override        public Boolean apply(Integer i) {            Vector v = mark.vectors[2][mark.vIndex(i)].times(mark.vectors[1][mark.vIndex(randIndex())]);            return depends(v);        }    }), TIMES, SEQ_FN_RAND);}
fe63787823b74d71a2969b408a8ef44d963d58081b3b21c67c90353c48517d9d
apply
public Boolean apply(Integer i)
{    Vector v = mark.vectors[0][mark.vIndex(i)].times(mark.vectors[0][mark.vIndex(randIndex())]);    return depends(v);}
fe63787823b74d71a2969b408a8ef44d963d58081b3b21c67c90353c48517d9d
apply
public Boolean apply(Integer i)
{    Vector v = mark.vectors[1][mark.vIndex(i)].times(mark.vectors[1][mark.vIndex(randIndex())]);    return depends(v);}
fe63787823b74d71a2969b408a8ef44d963d58081b3b21c67c90353c48517d9d
apply
public Boolean apply(Integer i)
{    Vector v = mark.vectors[2][mark.vIndex(i)].times(mark.vectors[2][mark.vIndex(randIndex())]);    return depends(v);}
fe63787823b74d71a2969b408a8ef44d963d58081b3b21c67c90353c48517d9d
apply
public Boolean apply(Integer i)
{    Vector v = mark.vectors[0][mark.vIndex(i)].times(mark.vectors[1][mark.vIndex(randIndex())]);    return depends(v);}
fe63787823b74d71a2969b408a8ef44d963d58081b3b21c67c90353c48517d9d
apply
public Boolean apply(Integer i)
{    Vector v = mark.vectors[0][mark.vIndex(i)].times(mark.vectors[2][mark.vIndex(randIndex())]);    return depends(v);}
fe63787823b74d71a2969b408a8ef44d963d58081b3b21c67c90353c48517d9d
apply
public Boolean apply(Integer i)
{    Vector v = mark.vectors[1][mark.vIndex(i)].times(mark.vectors[0][mark.vIndex(randIndex())]);    return depends(v);}
fe63787823b74d71a2969b408a8ef44d963d58081b3b21c67c90353c48517d9d
apply
public Boolean apply(Integer i)
{    Vector v = mark.vectors[1][mark.vIndex(i)].times(mark.vectors[2][mark.vIndex(randIndex())]);    return depends(v);}
fe63787823b74d71a2969b408a8ef44d963d58081b3b21c67c90353c48517d9d
apply
public Boolean apply(Integer i)
{    Vector v = mark.vectors[2][mark.vIndex(i)].times(mark.vectors[0][mark.vIndex(randIndex())]);    return depends(v);}
fe63787823b74d71a2969b408a8ef44d963d58081b3b21c67c90353c48517d9d
apply
public Boolean apply(Integer i)
{    Vector v = mark.vectors[2][mark.vIndex(i)].times(mark.vectors[1][mark.vIndex(randIndex())]);    return depends(v);}
c2330abeb049d0f97e19ba8a5a31a88501a4fe3452bef36b6cf848efbeff0ac9
setUpVectors
private void setUpVectors(int cardinality, int numNonZeros, int numVectors)
{    for (int i = 0; i < numVectors; i++) {                Vector v = new SequentialAccessSparseVector(cardinality, numNonZeros);        BitSet featureSpace = new BitSet(cardinality);        int[] indexes = new int[numNonZeros];        double[] values = new double[numNonZeros];        int j = 0;        while (j < numNonZeros) {            double value = r.nextGaussian();            int index = r.nextInt(cardinality);            if (!featureSpace.get(index) && value != 0) {                featureSpace.set(index);                indexes[j] = index;                values[j++] = value;                v.set(index, value);            }        }        randomVectorIndices.add(indexes);        randomVectorValues.add(values);        randomVectors.add(v);    }}
cd738c76205467587e6f261bd86e52f8124a265a9d1d785d1ced06a8b0f4973e
printStats
 void printStats(TimingStatistics stats, String benchmarkName, String implName, String content)
{    printStats(stats, benchmarkName, implName, content, 1);}
5f9957d19f946049a6b6b7dcd310a5535def08ad556604061629247c4ff7bd1e
printStats
 void printStats(TimingStatistics stats, String benchmarkName, String implName)
{    printStats(stats, benchmarkName, implName, "", 1);}
52fbafa5f917ed532cfa6d4fbfeee794e7a3dfca78b1d4cbb14a2ca113f9e449
printStats
private void printStats(TimingStatistics stats, String benchmarkName, String implName, String content, int multiplier)
{    float speed = multiplier * stats.getNCalls() * (numNonZeros * 1000.0f * 12 / stats.getSumTime());    float opsPerSec = stats.getNCalls() * 1000000000.0f / stats.getSumTime();    log.info("{} {} \n{} {} \nOps    = {} Units/sec\nIOps   = {} MBytes/sec", benchmarkName, implName, content, stats.toString(), DF.format(opsPerSec), DF.format(speed));    if (!implType.containsKey(implName)) {        implType.put(implName, implType.size());    }    int implId = implType.get(implName);    if (!statsMap.containsKey(benchmarkName)) {        statsMap.put(benchmarkName, new ArrayList<String[]>());    }    List<String[]> implStats = statsMap.get(benchmarkName);    while (implStats.size() < implId + 1) {        implStats.add(EMPTY);    }    implStats.set(implId, TAB_NEWLINE_PATTERN.split(stats + "\tSpeed  = " + DF.format(opsPerSec) + " /sec\tRate   = " + DF.format(speed) + " MB/s"));}
a16645e145642d7c384f56ca4fe3d11bada44f40247bc1a3dc1e72fe4709b33d
createData
public void createData()
{    for (int i = 0; i < Math.max(numVectors, numClusters); ++i) {        vectors[0][vIndex(i)] = new DenseVector(randomVectors.get(vIndex(i)));        vectors[1][vIndex(i)] = new RandomAccessSparseVector(randomVectors.get(vIndex(i)));        vectors[2][vIndex(i)] = new SequentialAccessSparseVector(randomVectors.get(vIndex(i)));        if (numClusters > 0) {            clusters[cIndex(i)] = new RandomAccessSparseVector(randomVectors.get(vIndex(i)));        }    }}
711d9de7afdd657ec7679ef1b21c147aa7c834ab7aeaf16d48d6fe61abda304b
createBenchmark
public void createBenchmark()
{    printStats(runner.benchmark(new BenchmarkFn() {        @Override        public Boolean apply(Integer i) {            vectors[0][vIndex(i)] = new DenseVector(randomVectors.get(vIndex(i)));            return depends(vectors[0][vIndex(i)]);        }    }), CREATE_COPY, DENSE_VECTOR);    printStats(runner.benchmark(new BenchmarkFn() {        @Override        public Boolean apply(Integer i) {            vectors[1][vIndex(i)] = new RandomAccessSparseVector(randomVectors.get(vIndex(i)));            return depends(vectors[1][vIndex(i)]);        }    }), CREATE_COPY, RAND_SPARSE_VECTOR);    printStats(runner.benchmark(new BenchmarkFn() {        @Override        public Boolean apply(Integer i) {            vectors[2][vIndex(i)] = new SequentialAccessSparseVector(randomVectors.get(vIndex(i)));            return depends(vectors[2][vIndex(i)]);        }    }), CREATE_COPY, SEQ_SPARSE_VECTOR);    if (numClusters > 0) {        printStats(runner.benchmark(new BenchmarkFn() {            @Override            public Boolean apply(Integer i) {                clusters[cIndex(i)] = new RandomAccessSparseVector(randomVectors.get(vIndex(i)));                return depends(clusters[cIndex(i)]);            }        }), CREATE_COPY, CLUSTERS);    }}
fe63787823b74d71a2969b408a8ef44d963d58081b3b21c67c90353c48517d9d
apply
public Boolean apply(Integer i)
{    vectors[0][vIndex(i)] = new DenseVector(randomVectors.get(vIndex(i)));    return depends(vectors[0][vIndex(i)]);}
fe63787823b74d71a2969b408a8ef44d963d58081b3b21c67c90353c48517d9d
apply
public Boolean apply(Integer i)
{    vectors[1][vIndex(i)] = new RandomAccessSparseVector(randomVectors.get(vIndex(i)));    return depends(vectors[1][vIndex(i)]);}
fe63787823b74d71a2969b408a8ef44d963d58081b3b21c67c90353c48517d9d
apply
public Boolean apply(Integer i)
{    vectors[2][vIndex(i)] = new SequentialAccessSparseVector(randomVectors.get(vIndex(i)));    return depends(vectors[2][vIndex(i)]);}
fe63787823b74d71a2969b408a8ef44d963d58081b3b21c67c90353c48517d9d
apply
public Boolean apply(Integer i)
{    clusters[cIndex(i)] = new RandomAccessSparseVector(randomVectors.get(vIndex(i)));    return depends(clusters[cIndex(i)]);}
69918fd24c9abbd418670284377734f2b05c4f750ceee6e91b40295ccff0341b
buildVectorIncrementally
private boolean buildVectorIncrementally(TimingStatistics stats, int randomIndex, Vector v, boolean useSetQuick)
{    int[] indexes = randomVectorIndices.get(randomIndex);    double[] values = randomVectorValues.get(randomIndex);    List<Integer> randomOrder = new ArrayList<>();    for (int i = 0; i < indexes.length; i++) {        randomOrder.add(i);    }    Collections.shuffle(randomOrder);    int[] permutation = new int[randomOrder.size()];    for (int i = 0; i < randomOrder.size(); i++) {        permutation[i] = randomOrder.get(i);    }    TimingStatistics.Call call = stats.newCall(leadTimeUsec);    if (useSetQuick) {        for (int i : permutation) {            v.setQuick(indexes[i], values[i]);        }    } else {        for (int i : permutation) {            v.set(indexes[i], values[i]);        }    }    return call.end(maxTimeUsec);}
9988e21f8d74d79d5b77e39ca25d5ed651f0750482a3b8c856f4a2b425e8c3f5
incrementalCreateBenchmark
public void incrementalCreateBenchmark()
{    TimingStatistics stats = new TimingStatistics();    for (int i = 0; i < loop; i++) {        vectors[0][vIndex(i)] = new DenseVector(cardinality);        if (buildVectorIncrementally(stats, vIndex(i), vectors[0][vIndex(i)], false)) {            break;        }    }    printStats(stats, CREATE_INCREMENTALLY, DENSE_VECTOR);    stats = new TimingStatistics();    for (int i = 0; i < loop; i++) {        vectors[1][vIndex(i)] = new RandomAccessSparseVector(cardinality);        if (buildVectorIncrementally(stats, vIndex(i), vectors[1][vIndex(i)], false)) {            break;        }    }    printStats(stats, CREATE_INCREMENTALLY, RAND_SPARSE_VECTOR);    stats = new TimingStatistics();    for (int i = 0; i < loop; i++) {        vectors[2][vIndex(i)] = new SequentialAccessSparseVector(cardinality);        if (buildVectorIncrementally(stats, vIndex(i), vectors[2][vIndex(i)], false)) {            break;        }    }    printStats(stats, CREATE_INCREMENTALLY, SEQ_SPARSE_VECTOR);    if (numClusters > 0) {        stats = new TimingStatistics();        for (int i = 0; i < loop; i++) {            clusters[cIndex(i)] = new RandomAccessSparseVector(cardinality);            if (buildVectorIncrementally(stats, vIndex(i), clusters[cIndex(i)], false)) {                break;            }        }        printStats(stats, CREATE_INCREMENTALLY, CLUSTERS);    }}
fc56cfe9f0b3311ea037bcabe2c69d1726365b0cfde9f6b283c6a512f913ab7e
vIndex
public int vIndex(int i)
{    return i % numVectors;}
e69ec5c2a4cee6fe47b6fc4020f9a3e39752cad1b03d86d9629ab4cbf0dea60c
cIndex
public int cIndex(int i)
{    return i % numClusters;}
365a24fc75086b6a0e91f9b072bd58c9280846cc05f333f28ede18388f27ce89
main
public static void main(String[] args) throws IOException
{    DefaultOptionBuilder obuilder = new DefaultOptionBuilder();    ArgumentBuilder abuilder = new ArgumentBuilder();    GroupBuilder gbuilder = new GroupBuilder();    Option vectorSizeOpt = obuilder.withLongName("vectorSize").withRequired(false).withArgument(abuilder.withName("vs").withDefault(1000000).create()).withDescription("Cardinality of the vector. Default: 1000000").withShortName("vs").create();    Option numNonZeroOpt = obuilder.withLongName("numNonZero").withRequired(false).withArgument(abuilder.withName("nz").withDefault(1000).create()).withDescription("Size of the vector. Default: 1000").withShortName("nz").create();    Option numVectorsOpt = obuilder.withLongName("numVectors").withRequired(false).withArgument(abuilder.withName("nv").withDefault(25).create()).withDescription("Number of Vectors to create. Default: 25").withShortName("nv").create();    Option numClustersOpt = obuilder.withLongName("numClusters").withRequired(false).withArgument(abuilder.withName("nc").withDefault(0).create()).withDescription("Number of clusters to create. Set to non zero to run cluster benchmark. Default: 0").withShortName("nc").create();    Option numOpsOpt = obuilder.withLongName("numOps").withRequired(false).withArgument(abuilder.withName("numOps").withDefault(10).create()).withDescription("Number of operations to do per timer. " + "E.g In distance measure, the distance is calculated numOps times" + " and the total time is measured. Default: 10").withShortName("no").create();    Option helpOpt = DefaultOptionCreator.helpOption();    Group group = gbuilder.withName("Options").withOption(vectorSizeOpt).withOption(numNonZeroOpt).withOption(numVectorsOpt).withOption(numOpsOpt).withOption(numClustersOpt).withOption(helpOpt).create();    try {        Parser parser = new Parser();        parser.setGroup(group);        CommandLine cmdLine = parser.parse(args);        if (cmdLine.hasOption(helpOpt)) {            CommandLineUtil.printHelpWithGenericOptions(group);            return;        }        int cardinality = 1000000;        if (cmdLine.hasOption(vectorSizeOpt)) {            cardinality = Integer.parseInt((String) cmdLine.getValue(vectorSizeOpt));        }        int numClusters = 0;        if (cmdLine.hasOption(numClustersOpt)) {            numClusters = Integer.parseInt((String) cmdLine.getValue(numClustersOpt));        }        int numNonZero = 1000;        if (cmdLine.hasOption(numNonZeroOpt)) {            numNonZero = Integer.parseInt((String) cmdLine.getValue(numNonZeroOpt));        }        int numVectors = 25;        if (cmdLine.hasOption(numVectorsOpt)) {            numVectors = Integer.parseInt((String) cmdLine.getValue(numVectorsOpt));        }        int numOps = 10;        if (cmdLine.hasOption(numOpsOpt)) {            numOps = Integer.parseInt((String) cmdLine.getValue(numOpsOpt));        }        VectorBenchmarks mark = new VectorBenchmarks(cardinality, numNonZero, numVectors, numClusters, numOps);        runBenchmark(mark);                log.info("\n{}", mark.asCsvString());    } catch (OptionException e) {        CommandLineUtil.printHelp(group);    }}
b2d09e6d92d2940e60afc5c0424b95fe3a3ceca64181b7139bba3574953c05f3
runBenchmark
private static void runBenchmark(VectorBenchmarks mark) throws IOException
{        mark.createData();    mark.createBenchmark();    if (mark.cardinality < 200000) {                mark.incrementalCreateBenchmark();    }    new CloneBenchmark(mark).benchmark();    new DotBenchmark(mark).benchmark();    new PlusBenchmark(mark).benchmark();    new MinusBenchmark(mark).benchmark();    new TimesBenchmark(mark).benchmark();    new SerializationBenchmark(mark).benchmark();    DistanceBenchmark distanceBenchmark = new DistanceBenchmark(mark);    distanceBenchmark.benchmark(new CosineDistanceMeasure());    distanceBenchmark.benchmark(new SquaredEuclideanDistanceMeasure());    distanceBenchmark.benchmark(new EuclideanDistanceMeasure());    distanceBenchmark.benchmark(new ManhattanDistanceMeasure());    distanceBenchmark.benchmark(new TanimotoDistanceMeasure());    distanceBenchmark.benchmark(new ChebyshevDistanceMeasure());    distanceBenchmark.benchmark(new MinkowskiDistanceMeasure());    if (mark.numClusters > 0) {        ClosestCentroidBenchmark centroidBenchmark = new ClosestCentroidBenchmark(mark);        centroidBenchmark.benchmark(new CosineDistanceMeasure());        centroidBenchmark.benchmark(new SquaredEuclideanDistanceMeasure());        centroidBenchmark.benchmark(new EuclideanDistanceMeasure());        centroidBenchmark.benchmark(new ManhattanDistanceMeasure());        centroidBenchmark.benchmark(new TanimotoDistanceMeasure());        centroidBenchmark.benchmark(new ChebyshevDistanceMeasure());        centroidBenchmark.benchmark(new MinkowskiDistanceMeasure());    }}
32c4353457ac9320921da4e27be66bc94ff53dd8261fd4dcad028cc4f3ab9c0f
asCsvString
private String asCsvString()
{    List<String> keys = new ArrayList<>(statsMap.keySet());    Collections.sort(keys);    Map<Integer, String> implMap = new HashMap<>();    for (Entry<String, Integer> e : implType.entrySet()) {        implMap.put(e.getValue(), e.getKey());    }    StringBuilder sb = new StringBuilder(1000);    for (String benchmarkName : keys) {        int i = 0;        for (String[] stats : statsMap.get(benchmarkName)) {            if (stats.length < 8) {                continue;            }            sb.append(benchmarkName).append(',');            sb.append(implMap.get(i++)).append(',');            sb.append(stats[7].trim().split("=|/")[1].trim());            sb.append('\n');        }    }    sb.append('\n');    return sb.toString();}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    int pad = 24;    StringBuilder sb = new StringBuilder(1000);    sb.append(StringUtils.rightPad("BenchMarks", pad));    for (int i = 0; i < implType.size(); i++) {        for (Entry<String, Integer> e : implType.entrySet()) {            if (e.getValue() == i) {                sb.append(StringUtils.rightPad(e.getKey(), pad).substring(0, pad));                break;            }        }    }    sb.append('\n');    List<String> keys = new ArrayList<>(statsMap.keySet());    Collections.sort(keys);    for (String benchmarkName : keys) {        List<String[]> implTokenizedStats = statsMap.get(benchmarkName);        int maxStats = 0;        for (String[] stat : implTokenizedStats) {            maxStats = Math.max(maxStats, stat.length);        }        for (int i = 0; i < maxStats; i++) {            boolean printedName = false;            for (String[] stats : implTokenizedStats) {                if (i == 0 && !printedName) {                    sb.append(StringUtils.rightPad(benchmarkName, pad));                    printedName = true;                } else if (!printedName) {                    printedName = true;                    sb.append(StringUtils.rightPad("", pad));                }                if (stats.length > i) {                    sb.append(StringUtils.rightPad(stats[i], pad));                } else {                    sb.append(StringUtils.rightPad("", pad));                }            }            sb.append('\n');        }        sb.append('\n');    }    return sb.toString();}
c18bf90c7aa74abd80ca2b44901ba2038980fb36959a0996ecd2244b5dacf00a
getRunner
public BenchmarkRunner getRunner()
{    return runner;}
ae0b9234410c2731e2caaaed14f72d73f38265fbe74eaf3d462bf0f241266a01
getUserIDs
public LongPrimitiveIterator getUserIDs()
{    SliceQuery<Long, Long, ?> query = buildNoValueSliceQuery(USER_IDS_CF);    query.setKey(ID_ROW_KEY);    FastIDSet userIDs = new FastIDSet();    for (HColumn<Long, ?> userIDColumn : query.execute().get().getColumns()) {        userIDs.add(userIDColumn.getName());    }    return userIDs.iterator();}
a06f75f56917fd636b983b7cfb0dd8060e1eb667d990c2ab0e2a39d33d94541d
getPreferencesFromUser
public PreferenceArray getPreferencesFromUser(long userID) throws TasteException
{    return userCache.get(userID);}
ba6a53e86aa528831d7ca18f17bea6d3af21894eb8e11a57a1a779aa58bf6f42
getItemIDsFromUser
public FastIDSet getItemIDsFromUser(long userID) throws TasteException
{    return itemIDsFromUserCache.get(userID);}
78fb119f03da6df48a809e8dc94c215041880ef1551757ef4d2508fe192621b8
getItemIDs
public LongPrimitiveIterator getItemIDs()
{    SliceQuery<Long, Long, ?> query = buildNoValueSliceQuery(ITEM_IDS_CF);    query.setKey(ID_ROW_KEY);    FastIDSet itemIDs = new FastIDSet();    for (HColumn<Long, ?> itemIDColumn : query.execute().get().getColumns()) {        itemIDs.add(itemIDColumn.getName());    }    return itemIDs.iterator();}
be05dbd3948efc99ba2728f3fbfa2a5e8c9ebc9afdb1d8695cb8bf348212f432
getPreferencesForItem
public PreferenceArray getPreferencesForItem(long itemID) throws TasteException
{    return itemCache.get(itemID);}
1a572d4c3fdc09f032ade6ca0c6d949ff7c3712c216689a329bc5e88e30e2039
getPreferenceValue
public Float getPreferenceValue(long userID, long itemID)
{    ColumnQuery<Long, Long, Float> query = HFactory.createColumnQuery(keyspace, LongSerializer.get(), LongSerializer.get(), FloatSerializer.get());    query.setColumnFamily(USERS_CF);    query.setKey(userID);    query.setName(itemID);    HColumn<Long, Float> column = query.execute().get();    return column == null ? null : column.getValue();}
9f3ec86a47ef850f8726cbaf6ee38b67340d4cf62337e0468b729888f8a0cd9c
getPreferenceTime
public Long getPreferenceTime(long userID, long itemID)
{    ColumnQuery<Long, Long, ?> query = HFactory.createColumnQuery(keyspace, LongSerializer.get(), LongSerializer.get(), BytesArraySerializer.get());    query.setColumnFamily(USERS_CF);    query.setKey(userID);    query.setName(itemID);    HColumn<Long, ?> result = query.execute().get();    return result == null ? null : result.getClock();}
ca32314ab0b342e57598ab3e548f0dc7ccfe40dcab80bb42fe96111529c7fb2a
getNumItems
public int getNumItems()
{    Integer itemCount = itemCountCache.get();    if (itemCount == null) {        CountQuery<Long, Long> countQuery = HFactory.createCountQuery(keyspace, LongSerializer.get(), LongSerializer.get());        countQuery.setKey(ID_ROW_KEY);        countQuery.setColumnFamily(ITEM_IDS_CF);        countQuery.setRange(null, null, Integer.MAX_VALUE);        itemCount = countQuery.execute().get();        itemCountCache.set(itemCount);    }    return itemCount;}
8c2658ffed5040b43a4b2253eec7730bcf9b36ab3c497554d321de1d7183a69c
getNumUsers
public int getNumUsers()
{    Integer userCount = userCountCache.get();    if (userCount == null) {        CountQuery<Long, Long> countQuery = HFactory.createCountQuery(keyspace, LongSerializer.get(), LongSerializer.get());        countQuery.setKey(ID_ROW_KEY);        countQuery.setColumnFamily(USER_IDS_CF);        countQuery.setRange(null, null, Integer.MAX_VALUE);        userCount = countQuery.execute().get();        userCountCache.set(userCount);    }    return userCount;}
0ea40759843b60bfb2d618774fa6b7fede865d83651c9e9fe817822760d18483
getNumUsersWithPreferenceFor
public int getNumUsersWithPreferenceFor(long itemID) throws TasteException
{    /*    CountQuery<Long,Long> query = HFactory.createCountQuery(keyspace, LongSerializer.get(), LongSerializer.get());    query.setColumnFamily(ITEMS_CF);    query.setKey(itemID);    query.setRange(null, null, Integer.MAX_VALUE);    return query.execute().get();     */    return userIDsFromItemCache.get(itemID).size();}
6d019eca3996fc5fdfb1030e07ee927128888b79b32683dd1b2041baeaf53a4b
getNumUsersWithPreferenceFor
public int getNumUsersWithPreferenceFor(long itemID1, long itemID2) throws TasteException
{    FastIDSet userIDs1 = userIDsFromItemCache.get(itemID1);    FastIDSet userIDs2 = userIDsFromItemCache.get(itemID2);    return userIDs1.size() < userIDs2.size() ? userIDs2.intersectionSize(userIDs1) : userIDs1.intersectionSize(userIDs2);}
479384395af79d778425896c46ecace2f63d7b050dc41d329f4a049b680177bb
setPreference
public void setPreference(long userID, long itemID, float value)
{    if (Float.isNaN(value)) {        value = 1.0f;    }    long now = System.currentTimeMillis();    Mutator<Long> mutator = HFactory.createMutator(keyspace, LongSerializer.get());    HColumn<Long, Float> itemForUsers = new HColumnImpl<>(LongSerializer.get(), FloatSerializer.get());    itemForUsers.setName(itemID);    itemForUsers.setClock(now);    itemForUsers.setValue(value);    mutator.addInsertion(userID, USERS_CF, itemForUsers);    HColumn<Long, Float> userForItems = new HColumnImpl<>(LongSerializer.get(), FloatSerializer.get());    userForItems.setName(userID);    userForItems.setClock(now);    userForItems.setValue(value);    mutator.addInsertion(itemID, ITEMS_CF, userForItems);    HColumn<Long, byte[]> userIDs = new HColumnImpl<>(LongSerializer.get(), BytesArraySerializer.get());    userIDs.setName(userID);    userIDs.setClock(now);    userIDs.setValue(EMPTY);    mutator.addInsertion(ID_ROW_KEY, USER_IDS_CF, userIDs);    HColumn<Long, byte[]> itemIDs = new HColumnImpl<>(LongSerializer.get(), BytesArraySerializer.get());    itemIDs.setName(itemID);    itemIDs.setClock(now);    itemIDs.setValue(EMPTY);    mutator.addInsertion(ID_ROW_KEY, ITEM_IDS_CF, itemIDs);    mutator.execute();}
7c2a92c2965e7e4ad97dde62c44d10be870d3da3b51da08551dd332ef4630ce5
removePreference
public void removePreference(long userID, long itemID)
{    Mutator<Long> mutator = HFactory.createMutator(keyspace, LongSerializer.get());    mutator.addDeletion(userID, USERS_CF, itemID, LongSerializer.get());    mutator.addDeletion(itemID, ITEMS_CF, userID, LongSerializer.get());    mutator.execute();}
5fe6ef45f2c8e613067bc79bf61b3f21f1aac63aa04e14a47b4f8203cebb79f9
hasPreferenceValues
public boolean hasPreferenceValues()
{    return true;}
13925bef8afa2e6d068d08c72262016e42e3d5fe30ac04c85c78f8b0f99c4ceb
getMaxPreference
public float getMaxPreference()
{    return Float.NaN;}
886c9fcd0006e44aa20de41c56cd99e5659dc842b2fd94840da5c661f1bccb0a
getMinPreference
public float getMinPreference()
{    return Float.NaN;}
da77e35d28c590f4b271e5b2b7f639c465574b8f17a1ef2f1df63e0152c57e8b
refresh
public void refresh(Collection<Refreshable> alreadyRefreshed)
{    userCache.clear();    itemCache.clear();    userIDsFromItemCache.clear();    itemIDsFromUserCache.clear();    userCountCache.set(null);    itemCountCache.set(null);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "CassandraDataModel[" + keyspace + ']';}
5df6118bc0e745d8b18e0a6a99b2e3f2ddba8140cbeb1423ce2df50a9f140574
close
public void close()
{    HFactory.shutdownCluster(cluster);}
4731867d27257da55ebdee8e84c8a667decbce59ff21cd897f25dda04ce9808c
buildNoValueSliceQuery
private SliceQuery<Long, Long, byte[]> buildNoValueSliceQuery(String cf)
{    SliceQuery<Long, Long, byte[]> query = HFactory.createSliceQuery(keyspace, LongSerializer.get(), LongSerializer.get(), BytesArraySerializer.get());    query.setColumnFamily(cf);    query.setRange(null, null, false, Integer.MAX_VALUE);    return query;}
9bf1e5e0372eabff098fd5c3f2343336d913b3581d3aac60678b42e81e480b1b
buildValueSliceQuery
private SliceQuery<Long, Long, Float> buildValueSliceQuery(String cf)
{    SliceQuery<Long, Long, Float> query = HFactory.createSliceQuery(keyspace, LongSerializer.get(), LongSerializer.get(), FloatSerializer.get());    query.setColumnFamily(cf);    query.setRange(null, null, false, Integer.MAX_VALUE);    return query;}
d3ac31fb33814c50b6aaa51d039a37139b54c01e9de0387e2d336c5341cd4003
get
public HConsistencyLevel get(OperationType op)
{    return HConsistencyLevel.ONE;}
5c59adf5d4e686ade7399c3e89db1e396f4dca618b50d42a62a1cec9e2882230
get
public HConsistencyLevel get(OperationType op, String cfName)
{    return HConsistencyLevel.ONE;}
bc8f9c559e0d75d8a4a4a2f3573e6939540982c8ce66904cd804aba5bc0de351
get
public PreferenceArray get(Long userID) throws TasteException
{    SliceQuery<Long, Long, Float> query = buildValueSliceQuery(USERS_CF);    query.setKey(userID);    ColumnSlice<Long, Float> result = query.execute().get();    if (result == null) {        throw new NoSuchUserException(userID);    }    List<HColumn<Long, Float>> itemIDColumns = result.getColumns();    if (itemIDColumns.isEmpty()) {        throw new NoSuchUserException(userID);    }    int size = itemIDColumns.size();    PreferenceArray prefs = new GenericUserPreferenceArray(size);    prefs.setUserID(0, userID);    for (int i = 0; i < size; i++) {        HColumn<Long, Float> itemIDColumn = itemIDColumns.get(i);        prefs.setItemID(i, itemIDColumn.getName());        prefs.setValue(i, itemIDColumn.getValue());    }    return prefs;}
ccb91470dfc5597af8ed0ae6e4074b09ba3c1224ab252e351963fea38680050b
get
public PreferenceArray get(Long itemID) throws TasteException
{    SliceQuery<Long, Long, Float> query = buildValueSliceQuery(ITEMS_CF);    query.setKey(itemID);    ColumnSlice<Long, Float> result = query.execute().get();    if (result == null) {        throw new NoSuchItemException(itemID);    }    List<HColumn<Long, Float>> userIDColumns = result.getColumns();    if (userIDColumns.isEmpty()) {        throw new NoSuchItemException(itemID);    }    int size = userIDColumns.size();    PreferenceArray prefs = new GenericItemPreferenceArray(size);    prefs.setItemID(0, itemID);    for (int i = 0; i < size; i++) {        HColumn<Long, Float> userIDColumn = userIDColumns.get(i);        prefs.setUserID(i, userIDColumn.getName());        prefs.setValue(i, userIDColumn.getValue());    }    return prefs;}
94b43948610d697176a8f0d5e5387057cb0890485c848817c41677507310d8a4
get
public FastIDSet get(Long itemID) throws TasteException
{    SliceQuery<Long, Long, byte[]> query = buildNoValueSliceQuery(ITEMS_CF);    query.setKey(itemID);    ColumnSlice<Long, byte[]> result = query.execute().get();    if (result == null) {        throw new NoSuchItemException(itemID);    }    List<HColumn<Long, byte[]>> columns = result.getColumns();    FastIDSet userIDs = new FastIDSet(columns.size());    for (HColumn<Long, ?> userIDColumn : columns) {        userIDs.add(userIDColumn.getName());    }    return userIDs;}
76d5cf96c8d59c9ffecfdc30550abce36cd886c09efc51b08e1f5364aebcf07b
get
public FastIDSet get(Long userID) throws TasteException
{    SliceQuery<Long, Long, byte[]> query = buildNoValueSliceQuery(USERS_CF);    query.setKey(userID);    FastIDSet itemIDs = new FastIDSet();    ColumnSlice<Long, byte[]> result = query.execute().get();    if (result == null) {        throw new NoSuchUserException(userID);    }    List<HColumn<Long, byte[]>> columns = result.getColumns();    if (columns.isEmpty()) {        throw new NoSuchUserException(userID);    }    for (HColumn<Long, ?> itemIDColumn : columns) {        itemIDs.add(itemIDColumn.getName());    }    return itemIDs;}
770225888f964ef53b32e12d8a320dc86e3dce62de1f7598745904574096fd71
getTableName
public String getTableName()
{    return tableName;}
624ba573f356c8871ba29333d1f48ac0ba831e9d030bf1837da9c444bc9b4586
bootstrap
private void bootstrap(Configuration conf) throws IOException
{    HTableDescriptor tDesc = new HTableDescriptor(Bytes.toBytes(tableName));    tDesc.addFamily(new HColumnDescriptor(USERS_CF));    tDesc.addFamily(new HColumnDescriptor(ITEMS_CF));    try (HBaseAdmin admin = new HBaseAdmin(conf)) {        admin.createTable(tDesc);        log.info("Created table {}", tableName);    }}
5ca568dfca7324127560133c362a730979b6e78c4119b96e418d72408aebb06f
userToBytes
private static byte[] userToBytes(long userID)
{    ByteBuffer bb = ByteBuffer.allocate(9);        bb.put((byte) 0x75);    bb.putLong(userID);    return bb.array();}
4b5785ad766eb592243cf6d4f57d819d54059654f4ee49029122bc85de5628bd
itemToBytes
private static byte[] itemToBytes(long itemID)
{    ByteBuffer bb = ByteBuffer.allocate(9);        bb.put((byte) 0x69);    bb.putLong(itemID);    return bb.array();}
505bbaa074c6905528e9be3710a34203446a79c40233eb2d37cda5dea1e1d6ff
bytesToUserOrItemID
private static long bytesToUserOrItemID(byte[] ba)
{    ByteBuffer bb = ByteBuffer.wrap(ba);    return bb.getLong(1);}
ae0b9234410c2731e2caaaed14f72d73f38265fbe74eaf3d462bf0f241266a01
getUserIDs
public LongPrimitiveIterator getUserIDs()
{    return userIDs.iterator();}
a06f75f56917fd636b983b7cfb0dd8060e1eb667d990c2ab0e2a39d33d94541d
getPreferencesFromUser
public PreferenceArray getPreferencesFromUser(long userID) throws TasteException
{    Result result;    try {        HTableInterface table = pool.getTable(tableName);        Get get = new Get(userToBytes(userID));        get.addFamily(ITEMS_CF);        result = table.get(get);        table.close();    } catch (IOException e) {        throw new TasteException("Failed to retrieve user preferences from HBase", e);    }    if (result.isEmpty()) {        throw new NoSuchUserException(userID);    }    SortedMap<byte[], byte[]> families = result.getFamilyMap(ITEMS_CF);    PreferenceArray prefs = new GenericUserPreferenceArray(families.size());    prefs.setUserID(0, userID);    int i = 0;    for (Map.Entry<byte[], byte[]> entry : families.entrySet()) {        prefs.setItemID(i, Bytes.toLong(entry.getKey()));        prefs.setValue(i, Bytes.toFloat(entry.getValue()));        i++;    }    return prefs;}
ba6a53e86aa528831d7ca18f17bea6d3af21894eb8e11a57a1a779aa58bf6f42
getItemIDsFromUser
public FastIDSet getItemIDsFromUser(long userID) throws TasteException
{    Result result;    try {        HTableInterface table = pool.getTable(tableName);        Get get = new Get(userToBytes(userID));        get.addFamily(ITEMS_CF);        result = table.get(get);        table.close();    } catch (IOException e) {        throw new TasteException("Failed to retrieve item IDs from HBase", e);    }    if (result.isEmpty()) {        throw new NoSuchUserException(userID);    }    SortedMap<byte[], byte[]> families = result.getFamilyMap(ITEMS_CF);    FastIDSet ids = new FastIDSet(families.size());    for (byte[] family : families.keySet()) {        ids.add(Bytes.toLong(family));    }    return ids;}
78fb119f03da6df48a809e8dc94c215041880ef1551757ef4d2508fe192621b8
getItemIDs
public LongPrimitiveIterator getItemIDs()
{    return itemIDs.iterator();}
be05dbd3948efc99ba2728f3fbfa2a5e8c9ebc9afdb1d8695cb8bf348212f432
getPreferencesForItem
public PreferenceArray getPreferencesForItem(long itemID) throws TasteException
{    Result result;    try {        HTableInterface table = pool.getTable(tableName);        Get get = new Get(itemToBytes(itemID));        get.addFamily(USERS_CF);        result = table.get(get);        table.close();    } catch (IOException e) {        throw new TasteException("Failed to retrieve item preferences from HBase", e);    }    if (result.isEmpty()) {        throw new NoSuchItemException(itemID);    }    SortedMap<byte[], byte[]> families = result.getFamilyMap(USERS_CF);    PreferenceArray prefs = new GenericItemPreferenceArray(families.size());    prefs.setItemID(0, itemID);    int i = 0;    for (Map.Entry<byte[], byte[]> entry : families.entrySet()) {        prefs.setUserID(i, Bytes.toLong(entry.getKey()));        prefs.setValue(i, Bytes.toFloat(entry.getValue()));        i++;    }    return prefs;}
4a797ada65a2ab5d778b75e04ac2b1252411b11fa907fd98679888cf05ffb484
getPreferenceValue
public Float getPreferenceValue(long userID, long itemID) throws TasteException
{    Result result;    try {        HTableInterface table = pool.getTable(tableName);        Get get = new Get(userToBytes(userID));        get.addColumn(ITEMS_CF, Bytes.toBytes(itemID));        result = table.get(get);        table.close();    } catch (IOException e) {        throw new TasteException("Failed to retrieve user preferences from HBase", e);    }    if (result.isEmpty()) {        throw new NoSuchUserException(userID);    }    if (result.containsColumn(ITEMS_CF, Bytes.toBytes(itemID))) {        return Bytes.toFloat(result.getValue(ITEMS_CF, Bytes.toBytes(itemID)));    } else {        return null;    }}
0857731203f906c58b60e4e747203723db701723c05fe7896e7f325ffa539bdc
getPreferenceTime
public Long getPreferenceTime(long userID, long itemID) throws TasteException
{    Result result;    try {        HTableInterface table = pool.getTable(tableName);        Get get = new Get(userToBytes(userID));        get.addColumn(ITEMS_CF, Bytes.toBytes(itemID));        result = table.get(get);        table.close();    } catch (IOException e) {        throw new TasteException("Failed to retrieve user preferences from HBase", e);    }    if (result.isEmpty()) {        throw new NoSuchUserException(userID);    }    if (result.containsColumn(ITEMS_CF, Bytes.toBytes(itemID))) {        KeyValue kv = result.getColumnLatest(ITEMS_CF, Bytes.toBytes(itemID));        return kv.getTimestamp();    } else {        return null;    }}
ca32314ab0b342e57598ab3e548f0dc7ccfe40dcab80bb42fe96111529c7fb2a
getNumItems
public int getNumItems()
{    return itemIDs.size();}
8c2658ffed5040b43a4b2253eec7730bcf9b36ab3c497554d321de1d7183a69c
getNumUsers
public int getNumUsers()
{    return userIDs.size();}
0ea40759843b60bfb2d618774fa6b7fede865d83651c9e9fe817822760d18483
getNumUsersWithPreferenceFor
public int getNumUsersWithPreferenceFor(long itemID) throws TasteException
{    PreferenceArray prefs = getPreferencesForItem(itemID);    return prefs.length();}
6d019eca3996fc5fdfb1030e07ee927128888b79b32683dd1b2041baeaf53a4b
getNumUsersWithPreferenceFor
public int getNumUsersWithPreferenceFor(long itemID1, long itemID2) throws TasteException
{    Result[] results;    try {        HTableInterface table = pool.getTable(tableName);        List<Get> gets = new ArrayList<>(2);        gets.add(new Get(itemToBytes(itemID1)));        gets.add(new Get(itemToBytes(itemID2)));        gets.get(0).addFamily(USERS_CF);        gets.get(1).addFamily(USERS_CF);        results = table.get(gets);        table.close();    } catch (IOException e) {        throw new TasteException("Failed to retrieve item preferences from HBase", e);    }    if (results[0].isEmpty()) {        throw new NoSuchItemException(itemID1);    }    if (results[1].isEmpty()) {        throw new NoSuchItemException(itemID2);    }        Result result = results[0];    SortedMap<byte[], byte[]> families = result.getFamilyMap(USERS_CF);    FastIDSet idSet1 = new FastIDSet(families.size());    for (byte[] id : families.keySet()) {        idSet1.add(Bytes.toLong(id));    }        result = results[1];    families = result.getFamilyMap(USERS_CF);    FastIDSet idSet2 = new FastIDSet(families.size());    for (byte[] id : families.keySet()) {        idSet2.add(Bytes.toLong(id));    }    return idSet1.intersectionSize(idSet2);}
50d76af25ae801a2139a90c576940f9f9838c80f93853951415d27753efe6193
setPreference
public void setPreference(long userID, long itemID, float value) throws TasteException
{    try {        HTableInterface table = pool.getTable(tableName);        List<Put> puts = new ArrayList<>(2);        puts.add(new Put(userToBytes(userID)));        puts.add(new Put(itemToBytes(itemID)));        puts.get(0).add(ITEMS_CF, Bytes.toBytes(itemID), Bytes.toBytes(value));        puts.get(1).add(USERS_CF, Bytes.toBytes(userID), Bytes.toBytes(value));        table.put(puts);        table.close();    } catch (IOException e) {        throw new TasteException("Failed to store preference in HBase", e);    }}
b8fc0c1b44ecc54ed269a5d79a52cada03c7abb05284d3d33b03ade9d9a86320
removePreference
public void removePreference(long userID, long itemID) throws TasteException
{    try {        HTableInterface table = pool.getTable(tableName);        List<Delete> deletes = new ArrayList<>(2);        deletes.add(new Delete(userToBytes(userID)));        deletes.add(new Delete(itemToBytes(itemID)));        deletes.get(0).deleteColumns(ITEMS_CF, Bytes.toBytes(itemID));        deletes.get(1).deleteColumns(USERS_CF, Bytes.toBytes(userID));        table.delete(deletes);        table.close();    } catch (IOException e) {        throw new TasteException("Failed to remove preference from HBase", e);    }}
5fe6ef45f2c8e613067bc79bf61b3f21f1aac63aa04e14a47b4f8203cebb79f9
hasPreferenceValues
public boolean hasPreferenceValues()
{    return true;}
13925bef8afa2e6d068d08c72262016e42e3d5fe30ac04c85c78f8b0f99c4ceb
getMaxPreference
public float getMaxPreference()
{    throw new UnsupportedOperationException();}
886c9fcd0006e44aa20de41c56cd99e5659dc842b2fd94840da5c661f1bccb0a
getMinPreference
public float getMinPreference()
{    throw new UnsupportedOperationException();}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    pool.close();}
da77e35d28c590f4b271e5b2b7f639c465574b8f17a1ef2f1df63e0152c57e8b
refresh
public void refresh(Collection<Refreshable> alreadyRefreshed)
{    if (alreadyRefreshed == null || !alreadyRefreshed.contains(this)) {        try {            log.info("Refreshing item and user ID caches");            long t1 = System.currentTimeMillis();            refreshItemIDs();            refreshUserIDs();            long t2 = System.currentTimeMillis();            log.info("Finished refreshing caches in {} ms", t2 - t1);        } catch (IOException e) {            throw new IllegalStateException("Could not reload DataModel", e);        }    }}
13038ba0bdadb0290c3575028078d3c187001750eb07cb130a8e50e64b02716e
refreshItemIDs
private synchronized void refreshItemIDs() throws IOException
{        HTableInterface table = pool.getTable(tableName);    Scan scan = new Scan(new byte[] { 0x69 }, new byte[] { 0x70 });    scan.setFilter(new FilterList(FilterList.Operator.MUST_PASS_ALL, new KeyOnlyFilter(), new FirstKeyOnlyFilter()));    ResultScanner scanner = table.getScanner(scan);    Collection<Long> ids = new LinkedList<>();    for (Result result : scanner) {        ids.add(bytesToUserOrItemID(result.getRow()));    }    table.close();        FastIDSet itemIDs = new FastIDSet(ids.size());    for (long l : ids) {        itemIDs.add(l);    }        this.itemIDs = itemIDs;}
0d5ab28f2a5017a045ebbb21870360361a2a04eb233662e41e2af5eebbe3c362
refreshUserIDs
private synchronized void refreshUserIDs() throws IOException
{        HTableInterface table = pool.getTable(tableName);    Scan scan = new Scan(new byte[] { 0x75 }, new byte[] { 0x76 });    scan.setFilter(new FilterList(FilterList.Operator.MUST_PASS_ALL, new KeyOnlyFilter(), new FirstKeyOnlyFilter()));    ResultScanner scanner = table.getScanner(scan);    Collection<Long> ids = new LinkedList<>();    for (Result result : scanner) {        ids.add(bytesToUserOrItemID(result.getRow()));    }    table.close();        FastIDSet userIDs = new FastIDSet(ids.size());    for (long l : ids) {        userIDs.add(l);    }        this.userIDs = userIDs;}
8243fb3fd39f760068b76e3c745887922c77b98666d1f42593b9378edaef5967
buildPreference
protected Preference buildPreference(ResultSet rs) throws SQLException
{    return new BooleanPreference(getLongColumn(rs, 1), getLongColumn(rs, 2));}
a5a985099af57d10c76f7366f3073e0e95dd6e6e48a7906a053a4a3e9d43ad6e
getSetPreferenceSQL
 String getSetPreferenceSQL()
{    return setPreferenceSQL;}
50d76af25ae801a2139a90c576940f9f9838c80f93853951415d27753efe6193
setPreference
public void setPreference(long userID, long itemID, float value) throws TasteException
{    Preconditions.checkArgument(!Float.isNaN(value), "NaN value");    log.debug("Setting preference for user {}, item {}", userID, itemID);    Connection conn = null;    PreparedStatement stmt = null;    try {        conn = getDataSource().getConnection();        stmt = conn.prepareStatement(setPreferenceSQL);        setLongParameter(stmt, 1, userID);        setLongParameter(stmt, 2, itemID);        log.debug("Executing SQL update: {}", setPreferenceSQL);        stmt.executeUpdate();    } catch (SQLException sqle) {        log.warn("Exception while setting preference", sqle);        throw new TasteException(sqle);    } finally {        IOUtils.quietClose(null, stmt, conn);    }}
5fe6ef45f2c8e613067bc79bf61b3f21f1aac63aa04e14a47b4f8203cebb79f9
hasPreferenceValues
public boolean hasPreferenceValues()
{    return false;}
13925bef8afa2e6d068d08c72262016e42e3d5fe30ac04c85c78f8b0f99c4ceb
getMaxPreference
public float getMaxPreference()
{    return 1.0f;}
886c9fcd0006e44aa20de41c56cd99e5659dc842b2fd94840da5c661f1bccb0a
getMinPreference
public float getMinPreference()
{    return 1.0f;}
53f73bcfc7a87bd987f0354cd6c436354bf8bbd612fbc470f8b74187930720da
getDataSource
public DataSource getDataSource()
{    return dataSource;}
a11576453519378b11292bf31003937dfe26fe81df70e54165c05bc1c3dcd456
getPreferenceTable
public String getPreferenceTable()
{    return preferenceTable;}
4991b566cd279faa3d53a74671a89b861d011d805f21fd6384eb0c7ea7cef18c
getUserIDColumn
public String getUserIDColumn()
{    return userIDColumn;}
c2bd7ce40a3eb6197f16b89be056751a32ce5f64dd4e25eb41ca3605f20148c2
getItemIDColumn
public String getItemIDColumn()
{    return itemIDColumn;}
51da92778638f54bc618ca72d72599b123c3de3bd8356a1ba87ca24f2ae36597
getPreferenceColumn
public String getPreferenceColumn()
{    return preferenceColumn;}
a5a985099af57d10c76f7366f3073e0e95dd6e6e48a7906a053a4a3e9d43ad6e
getSetPreferenceSQL
 String getSetPreferenceSQL()
{    return setPreferenceSQL;}
108a89a094b3a39b3b20cbd581561d4dd8b642f065690760ae153d36d980dcf0
getUserIDs
public LongPrimitiveIterator getUserIDs() throws TasteException
{    log.debug("Retrieving all users...");    try {        return new ResultSetIDIterator(getUsersSQL);    } catch (SQLException sqle) {        throw new TasteException(sqle);    }}
a06f75f56917fd636b983b7cfb0dd8060e1eb667d990c2ab0e2a39d33d94541d
getPreferencesFromUser
public PreferenceArray getPreferencesFromUser(long userID) throws TasteException
{    log.debug("Retrieving user ID '{}'", userID);    Connection conn = null;    PreparedStatement stmt = null;    ResultSet rs = null;    try {        conn = dataSource.getConnection();        stmt = conn.prepareStatement(getUserSQL, ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);        stmt.setFetchDirection(ResultSet.FETCH_FORWARD);        stmt.setFetchSize(getFetchSize());        setLongParameter(stmt, 1, userID);        log.debug("Executing SQL query: {}", getUserSQL);        rs = stmt.executeQuery();        List<Preference> prefs = new ArrayList<>();        while (rs.next()) {            prefs.add(buildPreference(rs));        }        if (prefs.isEmpty()) {            throw new NoSuchUserException(userID);        }        return new GenericUserPreferenceArray(prefs);    } catch (SQLException sqle) {        log.warn("Exception while retrieving user", sqle);        throw new TasteException(sqle);    } finally {        IOUtils.quietClose(rs, stmt, conn);    }}
61e240d32406cac9e8ac81762ac7ac8f3592746e92f89d1819e5a64432f590f5
exportWithPrefs
public FastByIDMap<PreferenceArray> exportWithPrefs() throws TasteException
{    log.debug("Exporting all data");    Connection conn = null;    Statement stmt = null;    ResultSet rs = null;    FastByIDMap<PreferenceArray> result = new FastByIDMap<>();    try {        conn = dataSource.getConnection();        stmt = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);        stmt.setFetchDirection(ResultSet.FETCH_FORWARD);        stmt.setFetchSize(getFetchSize());        log.debug("Executing SQL query: {}", getAllUsersSQL);        rs = stmt.executeQuery(getAllUsersSQL);        Long currentUserID = null;        List<Preference> currentPrefs = new ArrayList<>();        while (rs.next()) {            long nextUserID = getLongColumn(rs, 1);            if (currentUserID != null && !currentUserID.equals(nextUserID) && !currentPrefs.isEmpty()) {                result.put(currentUserID, new GenericUserPreferenceArray(currentPrefs));                currentPrefs.clear();            }            currentPrefs.add(buildPreference(rs));            currentUserID = nextUserID;        }        if (!currentPrefs.isEmpty()) {            result.put(currentUserID, new GenericUserPreferenceArray(currentPrefs));        }        return result;    } catch (SQLException sqle) {        log.warn("Exception while exporting all data", sqle);        throw new TasteException(sqle);    } finally {        IOUtils.quietClose(rs, stmt, conn);    }}
6124c7fde8fb4ab3208f0c49a88a60d30c1286bec9f5025c4ef14dd820b0036a
exportWithIDsOnly
public FastByIDMap<FastIDSet> exportWithIDsOnly() throws TasteException
{    log.debug("Exporting all data");    Connection conn = null;    Statement stmt = null;    ResultSet rs = null;    FastByIDMap<FastIDSet> result = new FastByIDMap<>();    try {        conn = dataSource.getConnection();        stmt = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);        stmt.setFetchDirection(ResultSet.FETCH_FORWARD);        stmt.setFetchSize(getFetchSize());        log.debug("Executing SQL query: {}", getAllUsersSQL);        rs = stmt.executeQuery(getAllUsersSQL);        boolean currentUserIDSet = false;                long currentUserID = 0L;        FastIDSet currentItemIDs = new FastIDSet(2);        while (rs.next()) {            long nextUserID = getLongColumn(rs, 1);            if (currentUserIDSet && currentUserID != nextUserID && !currentItemIDs.isEmpty()) {                result.put(currentUserID, currentItemIDs);                currentItemIDs = new FastIDSet(2);            }            currentItemIDs.add(getLongColumn(rs, 2));            currentUserID = nextUserID;            currentUserIDSet = true;        }        if (!currentItemIDs.isEmpty()) {            result.put(currentUserID, currentItemIDs);        }        return result;    } catch (SQLException sqle) {        log.warn("Exception while exporting all data", sqle);        throw new TasteException(sqle);    } finally {        IOUtils.quietClose(rs, stmt, conn);    }}
ba6a53e86aa528831d7ca18f17bea6d3af21894eb8e11a57a1a779aa58bf6f42
getItemIDsFromUser
public FastIDSet getItemIDsFromUser(long userID) throws TasteException
{    log.debug("Retrieving items for user ID '{}'", userID);    Connection conn = null;    PreparedStatement stmt = null;    ResultSet rs = null;    try {        conn = dataSource.getConnection();        stmt = conn.prepareStatement(getUserSQL, ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);        stmt.setFetchDirection(ResultSet.FETCH_FORWARD);        stmt.setFetchSize(getFetchSize());        setLongParameter(stmt, 1, userID);        log.debug("Executing SQL query: {}", getUserSQL);        rs = stmt.executeQuery();        FastIDSet result = new FastIDSet();        while (rs.next()) {            result.add(getLongColumn(rs, 2));        }        if (result.isEmpty()) {            throw new NoSuchUserException(userID);        }        return result;    } catch (SQLException sqle) {        log.warn("Exception while retrieving item s", sqle);        throw new TasteException(sqle);    } finally {        IOUtils.quietClose(rs, stmt, conn);    }}
4a797ada65a2ab5d778b75e04ac2b1252411b11fa907fd98679888cf05ffb484
getPreferenceValue
public Float getPreferenceValue(long userID, long itemID) throws TasteException
{    log.debug("Retrieving preferences for item ID '{}'", itemID);    Connection conn = null;    PreparedStatement stmt = null;    ResultSet rs = null;    try {        conn = dataSource.getConnection();        stmt = conn.prepareStatement(getPreferenceSQL, ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);        stmt.setFetchDirection(ResultSet.FETCH_FORWARD);        stmt.setFetchSize(1);        setLongParameter(stmt, 1, userID);        setLongParameter(stmt, 2, itemID);        log.debug("Executing SQL query: {}", getPreferenceSQL);        rs = stmt.executeQuery();        if (rs.next()) {            return rs.getFloat(1);        } else {            return null;        }    } catch (SQLException sqle) {        log.warn("Exception while retrieving prefs for item", sqle);        throw new TasteException(sqle);    } finally {        IOUtils.quietClose(rs, stmt, conn);    }}
0857731203f906c58b60e4e747203723db701723c05fe7896e7f325ffa539bdc
getPreferenceTime
public Long getPreferenceTime(long userID, long itemID) throws TasteException
{    if (getPreferenceTimeSQL == null) {        return null;    }    log.debug("Retrieving preference time for item ID '{}'", itemID);    Connection conn = null;    PreparedStatement stmt = null;    ResultSet rs = null;    try {        conn = dataSource.getConnection();        stmt = conn.prepareStatement(getPreferenceTimeSQL, ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);        stmt.setFetchDirection(ResultSet.FETCH_FORWARD);        stmt.setFetchSize(1);        setLongParameter(stmt, 1, userID);        setLongParameter(stmt, 2, itemID);        log.debug("Executing SQL query: {}", getPreferenceTimeSQL);        rs = stmt.executeQuery();        if (rs.next()) {            return rs.getLong(1);        } else {            return null;        }    } catch (SQLException sqle) {        log.warn("Exception while retrieving time for item", sqle);        throw new TasteException(sqle);    } finally {        IOUtils.quietClose(rs, stmt, conn);    }}
c388e3d4c09037f02ac5953d664aae3d2714c879c41346267284f3f30ad0a533
getItemIDs
public LongPrimitiveIterator getItemIDs() throws TasteException
{    log.debug("Retrieving all items...");    try {        return new ResultSetIDIterator(getItemsSQL);    } catch (SQLException sqle) {        throw new TasteException(sqle);    }}
be05dbd3948efc99ba2728f3fbfa2a5e8c9ebc9afdb1d8695cb8bf348212f432
getPreferencesForItem
public PreferenceArray getPreferencesForItem(long itemID) throws TasteException
{    List<Preference> list = doGetPreferencesForItem(itemID);    if (list.isEmpty()) {        throw new NoSuchItemException(itemID);    }    return new GenericItemPreferenceArray(list);}
39a5f7faca6889c92290bb6c3b31b24e194b134d729d723b38c684cec692b605
doGetPreferencesForItem
protected List<Preference> doGetPreferencesForItem(long itemID) throws TasteException
{    log.debug("Retrieving preferences for item ID '{}'", itemID);    Connection conn = null;    PreparedStatement stmt = null;    ResultSet rs = null;    try {        conn = dataSource.getConnection();        stmt = conn.prepareStatement(getPrefsForItemSQL, ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);        stmt.setFetchDirection(ResultSet.FETCH_FORWARD);        stmt.setFetchSize(getFetchSize());        setLongParameter(stmt, 1, itemID);        log.debug("Executing SQL query: {}", getPrefsForItemSQL);        rs = stmt.executeQuery();        List<Preference> prefs = new ArrayList<>();        while (rs.next()) {            prefs.add(buildPreference(rs));        }        return prefs;    } catch (SQLException sqle) {        log.warn("Exception while retrieving prefs for item", sqle);        throw new TasteException(sqle);    } finally {        IOUtils.quietClose(rs, stmt, conn);    }}
0e5cfb4e0e4f9d1a7b8c16082ab928c9562f8fb336a58c94de25d6df00236f93
getNumItems
public int getNumItems() throws TasteException
{    if (cachedNumItems < 0) {        cachedNumItems = getNumThings("items", getNumItemsSQL);    }    return cachedNumItems;}
c52287e7598bb24d77044373ddfeaf97ff2c29583e729316fa8fb9bef78133a1
getNumUsers
public int getNumUsers() throws TasteException
{    if (cachedNumUsers < 0) {        cachedNumUsers = getNumThings("users", getNumUsersSQL);    }    return cachedNumUsers;}
0ea40759843b60bfb2d618774fa6b7fede865d83651c9e9fe817822760d18483
getNumUsersWithPreferenceFor
public int getNumUsersWithPreferenceFor(long itemID) throws TasteException
{    return itemPrefCounts.get(itemID);}
6d019eca3996fc5fdfb1030e07ee927128888b79b32683dd1b2041baeaf53a4b
getNumUsersWithPreferenceFor
public int getNumUsersWithPreferenceFor(long itemID1, long itemID2) throws TasteException
{    return getNumThings("user preferring items", getNumPreferenceForItemsSQL, itemID1, itemID2);}
30f349cc84610f2658a38540275a494063b476ac3e89bab263208e84771f457f
getNumThings
private int getNumThings(String name, String sql, long... args) throws TasteException
{    log.debug("Retrieving number of {} in model", name);    Connection conn = null;    PreparedStatement stmt = null;    ResultSet rs = null;    try {        conn = dataSource.getConnection();        stmt = conn.prepareStatement(sql, ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);        stmt.setFetchDirection(ResultSet.FETCH_FORWARD);        stmt.setFetchSize(getFetchSize());        if (args != null) {            for (int i = 1; i <= args.length; i++) {                setLongParameter(stmt, i, args[i - 1]);            }        }        log.debug("Executing SQL query: {}", sql);        rs = stmt.executeQuery();        rs.next();        return rs.getInt(1);    } catch (SQLException sqle) {        log.warn("Exception while retrieving number of {}", name, sqle);        throw new TasteException(sqle);    } finally {        IOUtils.quietClose(rs, stmt, conn);    }}
50d76af25ae801a2139a90c576940f9f9838c80f93853951415d27753efe6193
setPreference
public void setPreference(long userID, long itemID, float value) throws TasteException
{    Preconditions.checkArgument(!Float.isNaN(value), "NaN value");    log.debug("Setting preference for user {}, item {}", userID, itemID);    Connection conn = null;    PreparedStatement stmt = null;    try {        conn = dataSource.getConnection();        stmt = conn.prepareStatement(setPreferenceSQL);        setLongParameter(stmt, 1, userID);        setLongParameter(stmt, 2, itemID);        stmt.setDouble(3, value);        stmt.setDouble(4, value);        log.debug("Executing SQL update: {}", setPreferenceSQL);        stmt.executeUpdate();    } catch (SQLException sqle) {        log.warn("Exception while setting preference", sqle);        throw new TasteException(sqle);    } finally {        IOUtils.quietClose(null, stmt, conn);    }}
b8fc0c1b44ecc54ed269a5d79a52cada03c7abb05284d3d33b03ade9d9a86320
removePreference
public void removePreference(long userID, long itemID) throws TasteException
{    log.debug("Removing preference for user '{}', item '{}'", userID, itemID);    Connection conn = null;    PreparedStatement stmt = null;    try {        conn = dataSource.getConnection();        stmt = conn.prepareStatement(removePreferenceSQL);        setLongParameter(stmt, 1, userID);        setLongParameter(stmt, 2, itemID);        log.debug("Executing SQL update: {}", removePreferenceSQL);        stmt.executeUpdate();    } catch (SQLException sqle) {        log.warn("Exception while removing preference", sqle);        throw new TasteException(sqle);    } finally {        IOUtils.quietClose(null, stmt, conn);    }}
da77e35d28c590f4b271e5b2b7f639c465574b8f17a1ef2f1df63e0152c57e8b
refresh
public void refresh(Collection<Refreshable> alreadyRefreshed)
{    cachedNumUsers = -1;    cachedNumItems = -1;    minPreference = Float.NaN;    maxPreference = Float.NaN;    itemPrefCounts.clear();}
5fe6ef45f2c8e613067bc79bf61b3f21f1aac63aa04e14a47b4f8203cebb79f9
hasPreferenceValues
public boolean hasPreferenceValues()
{    return true;}
13925bef8afa2e6d068d08c72262016e42e3d5fe30ac04c85c78f8b0f99c4ceb
getMaxPreference
public float getMaxPreference()
{    if (Float.isNaN(maxPreference)) {        Connection conn = null;        PreparedStatement stmt = null;        ResultSet rs = null;        try {            conn = dataSource.getConnection();            stmt = conn.prepareStatement(getMaxPreferenceSQL);            log.debug("Executing SQL query: {}", getMaxPreferenceSQL);            rs = stmt.executeQuery();            rs.next();            maxPreference = rs.getFloat(1);        } catch (SQLException sqle) {            log.warn("Exception while removing preference", sqle);                } finally {            IOUtils.quietClose(rs, stmt, conn);        }    }    return maxPreference;}
886c9fcd0006e44aa20de41c56cd99e5659dc842b2fd94840da5c661f1bccb0a
getMinPreference
public float getMinPreference()
{    if (Float.isNaN(minPreference)) {        Connection conn = null;        PreparedStatement stmt = null;        ResultSet rs = null;        try {            conn = dataSource.getConnection();            stmt = conn.prepareStatement(getMinPreferenceSQL);            log.debug("Executing SQL query: {}", getMinPreferenceSQL);            rs = stmt.executeQuery();            rs.next();            minPreference = rs.getFloat(1);        } catch (SQLException sqle) {            log.warn("Exception while removing preference", sqle);                } finally {            IOUtils.quietClose(rs, stmt, conn);        }    }    return minPreference;}
8243fb3fd39f760068b76e3c745887922c77b98666d1f42593b9378edaef5967
buildPreference
protected Preference buildPreference(ResultSet rs) throws SQLException
{    return new GenericPreference(getLongColumn(rs, 1), getLongColumn(rs, 2), rs.getFloat(3));}
ca3bd790636f58281c95c544ad02fc8f0ed006a0961cf4732dfe8533a22df346
getLongColumn
protected long getLongColumn(ResultSet rs, int position) throws SQLException
{    return rs.getLong(position);}
8d37718623bfddfb8eb4f5a4bdfaebbd3834e22ae5be1e3377780e1ffe6a7206
setLongParameter
protected void setLongParameter(PreparedStatement stmt, int position, long value) throws SQLException
{    stmt.setLong(position, value);}
461c676e40607a689de59d4eda34e89eb6bbee66cea5937368d84c2aa83db6c2
parseElement
protected Long parseElement(ResultSet resultSet) throws SQLException
{    return getLongColumn(resultSet, 1);}
c07ff43a11a0fd30355c754b084700be1eadeb6e7293cc052804e1ca4dba70c9
nextLong
public long nextLong()
{    return next();}
cfc67e5714c799daa4f0cae0084231f7d3115d517eae691edd227e7f59489e21
peek
public long peek()
{        throw new UnsupportedOperationException();}
d09e243328dfa4c449d86aa58b92f0cb7e462cec9c115000a0161e70d3fd7436
get
public Integer get(Long key) throws TasteException
{    return getNumThings("user preferring item", getNumPreferenceForItemSQL, key);}
626b9411d5a7153c2f91298b8bbd86cb0c80217188e3fc679ede274da3b289fd
getConnection
public Connection getConnection() throws SQLException
{    return delegate.getConnection();}
4b318b609854d37da7c380dffb1c2e908c4777571bb6ef1e24186813214ccd18
getConnection
public Connection getConnection(String username, String password) throws SQLException
{    return delegate.getConnection(username, password);}
af64206ae058caa8f503d0b6d14b0d7f06807b013a1a5dd3a0ef7c82ac64036d
getLogWriter
public PrintWriter getLogWriter() throws SQLException
{    return delegate.getLogWriter();}
4bdcb0160458b652b4be3aeb01e69e6aca6c4cbf8955b5d2b989406f0ab40861
setLogWriter
public void setLogWriter(PrintWriter printWriter) throws SQLException
{    delegate.setLogWriter(printWriter);}
b76b4cfb10bc11dab8dd6e20491dcd58a8f413ca0bbf0faa5d94961bb633a460
setLoginTimeout
public void setLoginTimeout(int timeout) throws SQLException
{    delegate.setLoginTimeout(timeout);}
76d4a940f55282e4c2cb01ba59e1f665f271c486f009da4a849faffb764a9a5e
getLoginTimeout
public int getLoginTimeout() throws SQLException
{    return delegate.getLoginTimeout();}
737f630af06220f285ba1c8c4a55dc74ef9573ac47f563a14ddc398ed5b0f26d
unwrap
public T unwrap(Class<T> iface) throws SQLException
{    return delegate.unwrap(iface);}
048c7be9b613a50c794f7fcb7f8869002da3c38d2e37b557d5dac5cf74a5372d
isWrapperFor
public boolean isWrapperFor(Class<?> iface) throws SQLException
{    return delegate.isWrapperFor(iface);}
d3f9c24b037df6e9bb20eb2a450419f227737b297032f4f4e4e5e5c8e49d3035
getParentLogger
public Logger getParentLogger() throws SQLFeatureNotSupportedException
{    throw new SQLFeatureNotSupportedException();}
c1b75b4fd8236dea5ca8b593dd1b590b5620989586eb349eb812f5835a8f9598
createConnection
public Connection createConnection() throws SQLException
{    Connection connection = underlyingDataSource.getConnection();    connection.setTransactionIsolation(Connection.TRANSACTION_READ_UNCOMMITTED);    connection.setHoldability(ResultSet.CLOSE_CURSORS_AT_COMMIT);    return connection;}
a4d02dc082b74427ec7e5900185333525750b9e0139a0fd35484904c61d3d649
getPropertiesFromFile
private static Properties getPropertiesFromFile(File file) throws TasteException
{    try {        return getPropertiesFromStream(new FileInputStream(file));    } catch (FileNotFoundException fnfe) {        throw new TasteException(fnfe);    }}
997dffc999afc3ce0467aa2f63e65f92f86e07f18fd8d34f61b238f4407100ab
getPropertiesFromStream
private static Properties getPropertiesFromStream(InputStream is) throws TasteException
{    try {        try {            Properties props = new Properties();            props.load(is);            return props;        } finally {            Closeables.close(is, true);        }    } catch (IOException ioe) {        throw new TasteException(ioe);    }}
be4c32955e91bd020d7aa1f82c019a829836bb1335885ff8146552479e3e6970
getFetchSize
protected int getFetchSize()
{        return Integer.MIN_VALUE;}
be4c32955e91bd020d7aa1f82c019a829836bb1335885ff8146552479e3e6970
getFetchSize
protected int getFetchSize()
{        return Integer.MIN_VALUE;}
50d76af25ae801a2139a90c576940f9f9838c80f93853951415d27753efe6193
setPreference
public void setPreference(long userID, long itemID, float value) throws TasteException
{    Preconditions.checkArgument(!Float.isNaN(value), "NaN value");    log.debug("Setting preference for user {}, item {}", userID, itemID);    String setPreferenceSQL = getSetPreferenceSQL();    Connection conn = null;    PreparedStatement stmt = null;    try {        conn = getDataSource().getConnection();        stmt = conn.prepareStatement(setPreferenceSQL);        setLongParameter(stmt, 1, userID);        setLongParameter(stmt, 2, itemID);        log.debug("Executing SQL update: {}", setPreferenceSQL);        stmt.executeUpdate();    } catch (SQLException sqle) {        if (!POSTGRESQL_DUPLICATE_KEY_STATE.equals(sqle.getSQLState())) {            log.warn("Exception while setting preference", sqle);            throw new TasteException(sqle);        }    } finally {        IOUtils.quietClose(null, stmt, conn);    }}
50d76af25ae801a2139a90c576940f9f9838c80f93853951415d27753efe6193
setPreference
public void setPreference(long userID, long itemID, float value) throws TasteException
{    Preconditions.checkArgument(!Float.isNaN(value), "NaN value");    log.debug("Setting preference for user {}, item {}", userID, itemID);    String setPreferenceSQL = getSetPreferenceSQL();    Connection conn = null;    PreparedStatement stmt1 = null;    PreparedStatement stmt2 = null;    try {        conn = getDataSource().getConnection();        stmt1 = conn.prepareStatement(setPreferenceSQL);        setLongParameter(stmt1, 1, userID);        setLongParameter(stmt1, 2, itemID);        stmt1.setDouble(3, value);        log.debug("Executing SQL update: {}", setPreferenceSQL);        try {            stmt1.executeUpdate();        } catch (SQLException sqle) {            if (!POSTGRESQL_DUPLICATE_KEY_STATE.equals(sqle.getSQLState())) {                throw sqle;            }        }                stmt2 = conn.prepareStatement(getUpdatePreferenceSQL());        stmt2.setDouble(1, value);        setLongParameter(stmt2, 2, userID);        setLongParameter(stmt2, 3, itemID);        log.debug("Executing SQL update: {}", getUpdatePreferenceSQL());        stmt2.executeUpdate();    } catch (SQLException sqle) {        log.warn("Exception while setting preference", sqle);        throw new TasteException(sqle);    } finally {        IOUtils.quietClose(null, stmt1, null);        IOUtils.quietClose(null, stmt2, null);        IOUtils.quietClose(null, null, conn);    }}
129e071a5acdf44209957699325f269c391c2463b78b7efe09056606615ae94b
call
public Void call()
{    reload();        return null;}
da77e35d28c590f4b271e5b2b7f639c465574b8f17a1ef2f1df63e0152c57e8b
refresh
public void refresh(Collection<Refreshable> alreadyRefreshed)
{    refreshHelper.refresh(alreadyRefreshed);}
42f72cb96a87c95a4290cf6b5dae4502552fd53a5795405aba8812d4f1727187
reload
private void reload()
{    try {                log.info("Loading new JDBC delegate data...");        DataModel newDelegateInMemory = delegate.hasPreferenceValues() ? new GenericDataModel(delegate.exportWithPrefs()) : new GenericBooleanPrefDataModel(delegate.exportWithIDsOnly());                log.info("New data loaded.");        delegateInMemory = newDelegateInMemory;    } catch (TasteException te) {        log.warn("Error while reloading JDBC delegate data", te);        }}
fe5501790691770c6aefb3dea14ede47ed2ac444cbe7a85e4018be1f2ff0968d
getDelegate
public JDBCDataModel getDelegate()
{    return delegate;}
d4e54e5d6eede2e1c2d805d6e711b2c8a8ddf0b80675f863097c41d8741da9b1
getDelegateInMemory
public DataModel getDelegateInMemory()
{    return delegateInMemory;}
108a89a094b3a39b3b20cbd581561d4dd8b642f065690760ae153d36d980dcf0
getUserIDs
public LongPrimitiveIterator getUserIDs() throws TasteException
{    return delegateInMemory.getUserIDs();}
3b89f168fb315135d865dc0bec035ba8a12c991402c20cea988bcf0dfeb9c08d
getPreferencesFromUser
public PreferenceArray getPreferencesFromUser(long id) throws TasteException
{    return delegateInMemory.getPreferencesFromUser(id);}
42777dbf9200159cb9072f9c5ee7e8d7be13c2d1fc5af3252f15e3af1a5292a4
getItemIDsFromUser
public FastIDSet getItemIDsFromUser(long id) throws TasteException
{    return delegateInMemory.getItemIDsFromUser(id);}
4a797ada65a2ab5d778b75e04ac2b1252411b11fa907fd98679888cf05ffb484
getPreferenceValue
public Float getPreferenceValue(long userID, long itemID) throws TasteException
{    return delegateInMemory.getPreferenceValue(userID, itemID);}
0857731203f906c58b60e4e747203723db701723c05fe7896e7f325ffa539bdc
getPreferenceTime
public Long getPreferenceTime(long userID, long itemID) throws TasteException
{    return delegateInMemory.getPreferenceTime(userID, itemID);}
c388e3d4c09037f02ac5953d664aae3d2714c879c41346267284f3f30ad0a533
getItemIDs
public LongPrimitiveIterator getItemIDs() throws TasteException
{    return delegateInMemory.getItemIDs();}
be05dbd3948efc99ba2728f3fbfa2a5e8c9ebc9afdb1d8695cb8bf348212f432
getPreferencesForItem
public PreferenceArray getPreferencesForItem(long itemID) throws TasteException
{    return delegateInMemory.getPreferencesForItem(itemID);}
0e5cfb4e0e4f9d1a7b8c16082ab928c9562f8fb336a58c94de25d6df00236f93
getNumItems
public int getNumItems() throws TasteException
{    return delegateInMemory.getNumItems();}
c52287e7598bb24d77044373ddfeaf97ff2c29583e729316fa8fb9bef78133a1
getNumUsers
public int getNumUsers() throws TasteException
{    return delegateInMemory.getNumUsers();}
0ea40759843b60bfb2d618774fa6b7fede865d83651c9e9fe817822760d18483
getNumUsersWithPreferenceFor
public int getNumUsersWithPreferenceFor(long itemID) throws TasteException
{    return delegateInMemory.getNumUsersWithPreferenceFor(itemID);}
6d019eca3996fc5fdfb1030e07ee927128888b79b32683dd1b2041baeaf53a4b
getNumUsersWithPreferenceFor
public int getNumUsersWithPreferenceFor(long itemID1, long itemID2) throws TasteException
{    return delegateInMemory.getNumUsersWithPreferenceFor(itemID1, itemID2);}
50d76af25ae801a2139a90c576940f9f9838c80f93853951415d27753efe6193
setPreference
public void setPreference(long userID, long itemID, float value) throws TasteException
{    delegateInMemory.setPreference(userID, itemID, value);}
b8fc0c1b44ecc54ed269a5d79a52cada03c7abb05284d3d33b03ade9d9a86320
removePreference
public void removePreference(long userID, long itemID) throws TasteException
{    delegateInMemory.removePreference(userID, itemID);}
5fe6ef45f2c8e613067bc79bf61b3f21f1aac63aa04e14a47b4f8203cebb79f9
hasPreferenceValues
public boolean hasPreferenceValues()
{    return delegateInMemory.hasPreferenceValues();}
13925bef8afa2e6d068d08c72262016e42e3d5fe30ac04c85c78f8b0f99c4ceb
getMaxPreference
public float getMaxPreference()
{    return delegateInMemory.getMaxPreference();}
886c9fcd0006e44aa20de41c56cd99e5659dc842b2fd94840da5c661f1bccb0a
getMinPreference
public float getMinPreference()
{    return delegateInMemory.getMinPreference();}
836af81f282134aa48ccb27f7465718f4dcf5cd01b97861bcd4d3668e6014ffc
getVerifyPreferenceSQL
protected String getVerifyPreferenceSQL()
{    return verifyPreferenceSQL;}
50d76af25ae801a2139a90c576940f9f9838c80f93853951415d27753efe6193
setPreference
public void setPreference(long userID, long itemID, float value) throws TasteException
{    Preconditions.checkArgument(!Float.isNaN(value), "NaN value");    log.debug("Setting preference for user {}, item {}", userID, itemID);    String setPreferenceSQL = getSetPreferenceSQL();    Connection conn = null;    PreparedStatement stmt1 = null;    PreparedStatement stmt2 = null;    ResultSet rs = null;    try {        conn = getDataSource().getConnection();        stmt1 = conn.prepareStatement(verifyPreferenceSQL, ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);        setLongParameter(stmt1, 1, userID);        setLongParameter(stmt1, 2, itemID);        rs = stmt1.executeQuery();                if (!rs.first()) {            stmt2 = conn.prepareStatement(setPreferenceSQL);            setLongParameter(stmt2, 1, userID);            setLongParameter(stmt2, 2, itemID);            stmt2.setDouble(3, value);            log.debug("Executing SQL update: {}", setPreferenceSQL);            stmt2.executeUpdate();        }    } catch (SQLException sqle) {        log.warn("Exception while setting preference", sqle);        throw new TasteException(sqle);    } finally {        IOUtils.quietClose(rs);        IOUtils.quietClose(stmt1);        IOUtils.quietClose(stmt2);        IOUtils.quietClose(conn);    }}
b0440c93d8d81dcbc3321df30869345a084b02d1bf5c8c9fa964bdb69bee2624
getUpdatePreferenceSQL
protected String getUpdatePreferenceSQL()
{    return updatePreferenceSQL;}
836af81f282134aa48ccb27f7465718f4dcf5cd01b97861bcd4d3668e6014ffc
getVerifyPreferenceSQL
protected String getVerifyPreferenceSQL()
{    return verifyPreferenceSQL;}
50d76af25ae801a2139a90c576940f9f9838c80f93853951415d27753efe6193
setPreference
public void setPreference(long userID, long itemID, float value) throws TasteException
{    Preconditions.checkArgument(!Float.isNaN(value), "NaN value");    log.debug("Setting preference for user {}, item {}", userID, itemID);    String setPreferenceSQL = getSetPreferenceSQL();    Connection conn = null;    PreparedStatement stmt1 = null;    PreparedStatement stmt2 = null;    PreparedStatement stmt3 = null;    ResultSet rs = null;    try {        conn = getDataSource().getConnection();        stmt1 = conn.prepareStatement(verifyPreferenceSQL, ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);        setLongParameter(stmt1, 1, userID);        setLongParameter(stmt1, 2, itemID);        rs = stmt1.executeQuery();                if (rs.first()) {                        stmt2 = conn.prepareStatement(updatePreferenceSQL);            stmt2.setDouble(1, value);            setLongParameter(stmt2, 2, userID);            setLongParameter(stmt2, 3, itemID);            log.debug("Executing SQL update: {}", updatePreferenceSQL);            stmt2.executeUpdate();        } else {                        stmt3 = conn.prepareStatement(setPreferenceSQL);            setLongParameter(stmt3, 1, userID);            setLongParameter(stmt3, 2, itemID);            stmt3.setDouble(3, value);            log.debug("Executing SQL update: {}", setPreferenceSQL);            stmt3.executeUpdate();        }    } catch (SQLException sqle) {        log.warn("Exception while setting preference", sqle);        throw new TasteException(sqle);    } finally {        IOUtils.quietClose(rs);        IOUtils.quietClose(stmt1);        IOUtils.quietClose(stmt2);        IOUtils.quietClose(stmt3);        IOUtils.quietClose(conn);    }}
ad45b3adfa2bdb1a959a0d73693f3b95aaf30113853ca9bc12dcfddaa733e94c
refreshData
public void refreshData(String userID, Iterable<List<String>> items, boolean add) throws NoSuchUserException, NoSuchItemException
{    checkData(userID, items, add);    long id = Long.parseLong(fromIdToLong(userID, true));    for (List<String> item : items) {        item.set(0, fromIdToLong(item.get(0), false));    }    if (reloadLock.tryLock()) {        try {            if (add) {                delegate = addUserItem(id, items);            } else {                delegate = removeUserItem(id, items);            }        } finally {            reloadLock.unlock();        }    }}
da77e35d28c590f4b271e5b2b7f639c465574b8f17a1ef2f1df63e0152c57e8b
refresh
public void refresh(Collection<Refreshable> alreadyRefreshed)
{    BasicDBObject query = new BasicDBObject();    query.put("deleted_at", new BasicDBObject("$gt", mongoTimestamp));    DBCursor cursor = collection.find(query);    Date ts = new Date(0);    while (cursor.hasNext()) {        Map<String, Object> user = (Map<String, Object>) cursor.next().toMap();        String userID = getID(user.get(mongoUserID), true);        Collection<List<String>> items = new ArrayList<>();        List<String> item = new ArrayList<>();        item.add(getID(user.get(mongoItemID), false));        item.add(Float.toString(getPreference(user.get(mongoPreference))));        items.add(item);        try {            refreshData(userID, items, false);        } catch (NoSuchUserException e) {            log.warn("No such user ID: {}", userID);        } catch (NoSuchItemException e) {            log.warn("No such items: {}", items);        }        if (ts.compareTo(getDate(user.get("created_at"))) < 0) {            ts = getDate(user.get("created_at"));        }    }    query = new BasicDBObject();    query.put("created_at", new BasicDBObject("$gt", mongoTimestamp));    cursor = collection.find(query);    while (cursor.hasNext()) {        Map<String, Object> user = (Map<String, Object>) cursor.next().toMap();        if (!user.containsKey("deleted_at")) {            String userID = getID(user.get(mongoUserID), true);            Collection<List<String>> items = new ArrayList<>();            List<String> item = new ArrayList<>();            item.add(getID(user.get(mongoItemID), false));            item.add(Float.toString(getPreference(user.get(mongoPreference))));            items.add(item);            try {                refreshData(userID, items, true);            } catch (NoSuchUserException e) {                log.warn("No such user ID: {}", userID);            } catch (NoSuchItemException e) {                log.warn("No such items: {}", items);            }            if (ts.compareTo(getDate(user.get("created_at"))) < 0) {                ts = getDate(user.get("created_at"));            }        }    }    if (mongoTimestamp.compareTo(ts) < 0) {        mongoTimestamp = ts;    }}
e86c92f4a67c9fa5daddfd7f7a5f7052574e99faf36be3b17cab998747f66506
fromIdToLong
public String fromIdToLong(String id, boolean isUser)
{    DBObject objectIdLong = collectionMap.findOne(new BasicDBObject("element_id", id));    if (objectIdLong != null) {        Map<String, Object> idLong = (Map<String, Object>) objectIdLong.toMap();        Object value = idLong.get("long_value");        return value == null ? null : value.toString();    } else {        objectIdLong = new BasicDBObject();        String longValue = Long.toString(idCounter++);        objectIdLong.put("element_id", id);        objectIdLong.put("long_value", longValue);        collectionMap.insert(objectIdLong);        log.info("Adding Translation {}: {} long_value: {}", isUser ? "User ID" : "Item ID", id, longValue);        return longValue;    }}
31e0c20371a5e1bf42de842a4ce489dce83cf6f42b7b42fadfedfc8138f1f856
fromLongToId
public String fromLongToId(long id)
{    DBObject objectIdLong = collectionMap.findOne(new BasicDBObject("long_value", Long.toString(id)));    Map<String, Object> idLong = (Map<String, Object>) objectIdLong.toMap();    Object value = idLong.get("element_id");    return value == null ? null : value.toString();}
c611bacbe5adecc23a8e0674ea45f97b74781e17fd604e12c750ed51bf713faf
isIDInModel
public boolean isIDInModel(String ID)
{    DBObject objectIdLong = collectionMap.findOne(new BasicDBObject("element_id", ID));    return objectIdLong != null;}
afdd48cd8c9fab3cda348dc8e04bd36b748c4a4942acf573ece80d9ccd73af5d
mongoUpdateDate
public Date mongoUpdateDate()
{    return mongoTimestamp;}
1c901e5e60f039cdf459794661952b625e87c9401c833eb320cbae5c05bb5bdb
buildModel
private void buildModel() throws UnknownHostException
{    userIsObject = false;    itemIsObject = false;    idCounter = 0;    preferenceIsString = true;    Mongo mongoDDBB = new Mongo(mongoHost, mongoPort);    DB db = mongoDDBB.getDB(mongoDB);    mongoTimestamp = new Date(0);    FastByIDMap<Collection<Preference>> userIDPrefMap = new FastByIDMap<>();    if (!mongoAuth || db.authenticate(mongoUsername, mongoPassword.toCharArray())) {        collection = db.getCollection(mongoCollection);        collectionMap = db.getCollection(mongoMapCollection);        DBObject indexObj = new BasicDBObject();        indexObj.put("element_id", 1);        collectionMap.ensureIndex(indexObj);        indexObj = new BasicDBObject();        indexObj.put("long_value", 1);        collectionMap.ensureIndex(indexObj);        collectionMap.remove(new BasicDBObject());        DBCursor cursor = collection.find();        while (cursor.hasNext()) {            Map<String, Object> user = (Map<String, Object>) cursor.next().toMap();            if (!user.containsKey("deleted_at")) {                long userID = Long.parseLong(fromIdToLong(getID(user.get(mongoUserID), true), true));                long itemID = Long.parseLong(fromIdToLong(getID(user.get(mongoItemID), false), false));                float ratingValue = getPreference(user.get(mongoPreference));                Collection<Preference> userPrefs = userIDPrefMap.get(userID);                if (userPrefs == null) {                    userPrefs = new ArrayList<>(2);                    userIDPrefMap.put(userID, userPrefs);                }                userPrefs.add(new GenericPreference(userID, itemID, ratingValue));                if (user.containsKey("created_at") && mongoTimestamp.compareTo(getDate(user.get("created_at"))) < 0) {                    mongoTimestamp = getDate(user.get("created_at"));                }            }        }    }    delegate = new GenericDataModel(GenericDataModel.toDataMap(userIDPrefMap, true));}
130db9af59b69953392e321ff0bee2d915c6e92308b95c386620fbf96d49da52
removeMongoUserItem
private void removeMongoUserItem(String userID, String itemID)
{    String userId = fromLongToId(Long.parseLong(userID));    String itemId = fromLongToId(Long.parseLong(itemID));    if (isUserItemInDB(userId, itemId)) {        mongoTimestamp = new Date();        BasicDBObject query = new BasicDBObject();        query.put(mongoUserID, userIsObject ? new ObjectId(userId) : userId);        query.put(mongoItemID, itemIsObject ? new ObjectId(itemId) : itemId);        if (mongoFinalRemove) {            log.info(collection.remove(query).toString());        } else {            BasicDBObject update = new BasicDBObject();            update.put("$set", new BasicDBObject("deleted_at", mongoTimestamp));            log.info(collection.update(query, update).toString());        }        log.info("Removing userID: {} itemID: {}", userID, itemId);    }}
d340e9a62926eab6b0177a3ceabf99954c8ca5a5cbc67bdadfabbf0c99e22d88
addMongoUserItem
private void addMongoUserItem(String userID, String itemID, String preferenceValue)
{    String userId = fromLongToId(Long.parseLong(userID));    String itemId = fromLongToId(Long.parseLong(itemID));    if (!isUserItemInDB(userId, itemId)) {        mongoTimestamp = new Date();        BasicDBObject user = new BasicDBObject();        Object userIdObject = userIsObject ? new ObjectId(userId) : userId;        Object itemIdObject = itemIsObject ? new ObjectId(itemId) : itemId;        user.put(mongoUserID, userIdObject);        user.put(mongoItemID, itemIdObject);        user.put(mongoPreference, preferenceIsString ? preferenceValue : Double.parseDouble(preferenceValue));        user.put("created_at", mongoTimestamp);        collection.insert(user);        log.info("Adding userID: {} itemID: {} preferenceValue: {}", userID, itemID, preferenceValue);    }}
ddd3d8d7d83d100faaa1520c17fa2c5810992cf2a38525065888c01168f96cab
isUserItemInDB
private boolean isUserItemInDB(String userID, String itemID)
{    BasicDBObject query = new BasicDBObject();    Object userId = userIsObject ? new ObjectId(userID) : userID;    Object itemId = itemIsObject ? new ObjectId(itemID) : itemID;    query.put(mongoUserID, userId);    query.put(mongoItemID, itemId);    return collection.findOne(query) != null;}
db58d5d78f1dc6394865bbfb0383f3112664e29c9308dfd2c909c38f820fc710
removeUserItem
private DataModel removeUserItem(long userID, Iterable<List<String>> items)
{    FastByIDMap<PreferenceArray> rawData = ((GenericDataModel) delegate).getRawUserData();    for (List<String> item : items) {        PreferenceArray prefs = rawData.get(userID);        long itemID = Long.parseLong(item.get(0));        if (prefs != null) {            boolean exists = false;            int length = prefs.length();            for (int i = 0; i < length; i++) {                if (prefs.getItemID(i) == itemID) {                    exists = true;                    break;                }            }            if (exists) {                rawData.remove(userID);                if (length > 1) {                    PreferenceArray newPrefs = new GenericUserPreferenceArray(length - 1);                    for (int i = 0, j = 0; i < length; i++, j++) {                        if (prefs.getItemID(i) == itemID) {                            j--;                        } else {                            newPrefs.set(j, prefs.get(i));                        }                    }                    rawData.put(userID, newPrefs);                }                log.info("Removing userID: {} itemID: {}", userID, itemID);                if (mongoManage) {                    removeMongoUserItem(Long.toString(userID), Long.toString(itemID));                }            }        }    }    return new GenericDataModel(rawData);}
2016a820f198456d42838a80a0d45422c50bab80aaeb89e30b772cb25b6ad6c3
addUserItem
private DataModel addUserItem(long userID, Iterable<List<String>> items)
{    FastByIDMap<PreferenceArray> rawData = ((GenericDataModel) delegate).getRawUserData();    PreferenceArray prefs = rawData.get(userID);    for (List<String> item : items) {        long itemID = Long.parseLong(item.get(0));        float preferenceValue = Float.parseFloat(item.get(1));        boolean exists = false;        if (prefs != null) {            for (int i = 0; i < prefs.length(); i++) {                if (prefs.getItemID(i) == itemID) {                    exists = true;                    prefs.setValue(i, preferenceValue);                    break;                }            }        }        if (!exists) {            if (prefs == null) {                prefs = new GenericUserPreferenceArray(1);            } else {                PreferenceArray newPrefs = new GenericUserPreferenceArray(prefs.length() + 1);                for (int i = 0, j = 1; i < prefs.length(); i++, j++) {                    newPrefs.set(j, prefs.get(i));                }                prefs = newPrefs;            }            prefs.setUserID(0, userID);            prefs.setItemID(0, itemID);            prefs.setValue(0, preferenceValue);            log.info("Adding userID: {} itemID: {} preferenceValue: {}", userID, itemID, preferenceValue);            rawData.put(userID, prefs);            if (mongoManage) {                addMongoUserItem(Long.toString(userID), Long.toString(itemID), Float.toString(preferenceValue));            }        }    }    return new GenericDataModel(rawData);}
bc8f2d285397b7b1dcd9e0cb6900ac9e2f6e3cdb0244196897e97826088d0017
getDate
private Date getDate(Object date)
{    if (date.getClass().getName().contains("Date")) {        return (Date) date;    }    if (date.getClass().getName().contains("String")) {        try {            synchronized (dateFormat) {                return dateFormat.parse(date.toString());            }        } catch (ParseException ioe) {            log.warn("Error parsing timestamp", ioe);        }    }    return new Date(0);}
5f0cebef747e7223c00355678e9d035e3f51f450706bedc9a74a287ba5244bb1
getPreference
private float getPreference(Object value)
{    if (value != null) {        if (value.getClass().getName().contains("String")) {            preferenceIsString = true;            return Float.parseFloat(value.toString());        } else {            preferenceIsString = false;            return Double.valueOf(value.toString()).floatValue();        }    } else {        return 0.5f;    }}
ca63a4b344d569f2b72604bab81a684505ac06168e792917650c1c2580b38851
getID
private String getID(Object id, boolean isUser)
{    if (id.getClass().getName().contains("ObjectId")) {        if (isUser) {            userIsObject = true;        } else {            itemIsObject = true;        }        return ((ObjectId) id).toStringMongod();    } else {        return id.toString();    }}
1c7409f866d6524ffeb8e47edf8c969886405c05692584933d08f7f54e317c07
checkData
private void checkData(String userID, Iterable<List<String>> items, boolean add) throws NoSuchUserException, NoSuchItemException
{    Preconditions.checkNotNull(userID);    Preconditions.checkNotNull(items);    Preconditions.checkArgument(!userID.isEmpty(), "userID is empty");    for (List<String> item : items) {        Preconditions.checkNotNull(item.get(0));        Preconditions.checkArgument(!item.get(0).isEmpty(), "item is empty");    }    if (userIsObject && !ID_PATTERN.matcher(userID).matches()) {        throw new IllegalArgumentException();    }    for (List<String> item : items) {        if (itemIsObject && !ID_PATTERN.matcher(item.get(0)).matches()) {            throw new IllegalArgumentException();        }    }    if (!add && !isIDInModel(userID)) {        throw new NoSuchUserException();    }    for (List<String> item : items) {        if (!add && !isIDInModel(item.get(0))) {            throw new NoSuchItemException();        }    }}
64586214cb960c73d1c2548c08d4b240a1883ea533036d4084c46d7fd8c570f6
cleanupMappingCollection
public void cleanupMappingCollection()
{    collectionMap.drop();}
108a89a094b3a39b3b20cbd581561d4dd8b642f065690760ae153d36d980dcf0
getUserIDs
public LongPrimitiveIterator getUserIDs() throws TasteException
{    return delegate.getUserIDs();}
3b89f168fb315135d865dc0bec035ba8a12c991402c20cea988bcf0dfeb9c08d
getPreferencesFromUser
public PreferenceArray getPreferencesFromUser(long id) throws TasteException
{    return delegate.getPreferencesFromUser(id);}
ba6a53e86aa528831d7ca18f17bea6d3af21894eb8e11a57a1a779aa58bf6f42
getItemIDsFromUser
public FastIDSet getItemIDsFromUser(long userID) throws TasteException
{    return delegate.getItemIDsFromUser(userID);}
c388e3d4c09037f02ac5953d664aae3d2714c879c41346267284f3f30ad0a533
getItemIDs
public LongPrimitiveIterator getItemIDs() throws TasteException
{    return delegate.getItemIDs();}
be05dbd3948efc99ba2728f3fbfa2a5e8c9ebc9afdb1d8695cb8bf348212f432
getPreferencesForItem
public PreferenceArray getPreferencesForItem(long itemID) throws TasteException
{    return delegate.getPreferencesForItem(itemID);}
4a797ada65a2ab5d778b75e04ac2b1252411b11fa907fd98679888cf05ffb484
getPreferenceValue
public Float getPreferenceValue(long userID, long itemID) throws TasteException
{    return delegate.getPreferenceValue(userID, itemID);}
0857731203f906c58b60e4e747203723db701723c05fe7896e7f325ffa539bdc
getPreferenceTime
public Long getPreferenceTime(long userID, long itemID) throws TasteException
{    return delegate.getPreferenceTime(userID, itemID);}
0e5cfb4e0e4f9d1a7b8c16082ab928c9562f8fb336a58c94de25d6df00236f93
getNumItems
public int getNumItems() throws TasteException
{    return delegate.getNumItems();}
c52287e7598bb24d77044373ddfeaf97ff2c29583e729316fa8fb9bef78133a1
getNumUsers
public int getNumUsers() throws TasteException
{    return delegate.getNumUsers();}
0ea40759843b60bfb2d618774fa6b7fede865d83651c9e9fe817822760d18483
getNumUsersWithPreferenceFor
public int getNumUsersWithPreferenceFor(long itemID) throws TasteException
{    return delegate.getNumUsersWithPreferenceFor(itemID);}
6d019eca3996fc5fdfb1030e07ee927128888b79b32683dd1b2041baeaf53a4b
getNumUsersWithPreferenceFor
public int getNumUsersWithPreferenceFor(long itemID1, long itemID2) throws TasteException
{    return delegate.getNumUsersWithPreferenceFor(itemID1, itemID2);}
479384395af79d778425896c46ecace2f63d7b050dc41d329f4a049b680177bb
setPreference
public void setPreference(long userID, long itemID, float value)
{    throw new UnsupportedOperationException();}
7c2a92c2965e7e4ad97dde62c44d10be870d3da3b51da08551dd332ef4630ce5
removePreference
public void removePreference(long userID, long itemID)
{    throw new UnsupportedOperationException();}
5fe6ef45f2c8e613067bc79bf61b3f21f1aac63aa04e14a47b4f8203cebb79f9
hasPreferenceValues
public boolean hasPreferenceValues()
{    return delegate.hasPreferenceValues();}
13925bef8afa2e6d068d08c72262016e42e3d5fe30ac04c85c78f8b0f99c4ceb
getMaxPreference
public float getMaxPreference()
{    return delegate.getMaxPreference();}
886c9fcd0006e44aa20de41c56cd99e5659dc842b2fd94840da5c661f1bccb0a
getMinPreference
public float getMinPreference()
{    return delegate.getMinPreference();}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "MongoDBDataModel";}
4bd88ca141a3deec266891ce1f59a5b0cf28b3cd76314d24831443c2c964f4d5
itemSimilarity
public double itemSimilarity(long itemID1, long itemID2) throws TasteException
{    return delegate.itemSimilarity(itemID1, itemID2);}
3ce3330a48ace40db1c9361681134076e4b81fff6ebc87e5e2468a3d2fa8099b
itemSimilarities
public double[] itemSimilarities(long itemID1, long[] itemID2s) throws TasteException
{    return delegate.itemSimilarities(itemID1, itemID2s);}
49fc2640f75a17f0009c6939de1abac8ee80d2eb67d091d86defdf01278c77da
allSimilarItemIDs
public long[] allSimilarItemIDs(long itemID) throws TasteException
{    return delegate.allSimilarItemIDs(itemID);}
da77e35d28c590f4b271e5b2b7f639c465574b8f17a1ef2f1df63e0152c57e8b
refresh
public void refresh(Collection<Refreshable> alreadyRefreshed)
{    log.debug("Reloading...");    reload();}
10d7c03ff05328028908d407ee4c775675767e13b48e052e8327f609f01e3e8c
reload
protected void reload()
{    if (reloadLock.tryLock()) {        try {            delegate = new GenericItemSimilarity(new JDBCSimilaritiesIterable(dataSource, getAllItemSimilaritiesSQL));        } finally {            reloadLock.unlock();        }    }}
a826368617ee2cf32429e53040e2af19ff9270146b892a0d5f22d331c19eeed0
iterator
public Iterator<GenericItemSimilarity.ItemItemSimilarity> iterator()
{    try {        return new JDBCSimilaritiesIterator(dataSource, getAllItemSimilaritiesSQL);    } catch (SQLException sqle) {        throw new IllegalStateException(sqle);    }}
d8f87fab04c27534b07bed44472642515813dcedcd85b7846c380367189800ca
parseElement
protected GenericItemSimilarity.ItemItemSimilarity parseElement(ResultSet resultSet) throws SQLException
{    return new GenericItemSimilarity.ItemItemSimilarity(resultSet.getLong(1), resultSet.getLong(2), resultSet.getDouble(3));}
58d398bfcee2bae97599d7c910c8fb691aa6ec7e159b6cac592615da0f8c989b
getSimilarityTable
protected String getSimilarityTable()
{    return similarityTable;}
2f08dd686746c5a419d345750c5bc8eb47a58bda0e5ab6359fda7062d421964a
getItemAIDColumn
protected String getItemAIDColumn()
{    return itemAIDColumn;}
79eec8e15f0025a78083b4cf0a68c029423f3e2782d1400fed87e99f0ffffee8
getItemBIDColumn
protected String getItemBIDColumn()
{    return itemBIDColumn;}
8cc106b8d3563ce523744507762d1d6e1e4f0e54df2cf6a4b42b3a45cfdb8147
getSimilarityColumn
protected String getSimilarityColumn()
{    return similarityColumn;}
4bd88ca141a3deec266891ce1f59a5b0cf28b3cd76314d24831443c2c964f4d5
itemSimilarity
public double itemSimilarity(long itemID1, long itemID2) throws TasteException
{    if (itemID1 == itemID2) {        return 1.0;    }    Connection conn = null;    PreparedStatement stmt = null;    try {        conn = dataSource.getConnection();        stmt = conn.prepareStatement(getItemItemSimilaritySQL, ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);        stmt.setFetchDirection(ResultSet.FETCH_FORWARD);        stmt.setFetchSize(getFetchSize());        return doItemSimilarity(stmt, itemID1, itemID2);    } catch (SQLException sqle) {        log.warn("Exception while retrieving similarity", sqle);        throw new TasteException(sqle);    } finally {        IOUtils.quietClose(null, stmt, conn);    }}
3ce3330a48ace40db1c9361681134076e4b81fff6ebc87e5e2468a3d2fa8099b
itemSimilarities
public double[] itemSimilarities(long itemID1, long[] itemID2s) throws TasteException
{    double[] result = new double[itemID2s.length];    Connection conn = null;    PreparedStatement stmt = null;    try {        conn = dataSource.getConnection();        stmt = conn.prepareStatement(getItemItemSimilaritySQL, ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);        stmt.setFetchDirection(ResultSet.FETCH_FORWARD);        stmt.setFetchSize(getFetchSize());        for (int i = 0; i < itemID2s.length; i++) {            result[i] = doItemSimilarity(stmt, itemID1, itemID2s[i]);        }    } catch (SQLException sqle) {        log.warn("Exception while retrieving item similarities", sqle);        throw new TasteException(sqle);    } finally {        IOUtils.quietClose(null, stmt, conn);    }    return result;}
49fc2640f75a17f0009c6939de1abac8ee80d2eb67d091d86defdf01278c77da
allSimilarItemIDs
public long[] allSimilarItemIDs(long itemID) throws TasteException
{    FastIDSet allSimilarItemIDs = new FastIDSet();    Connection conn = null;    PreparedStatement stmt = null;    ResultSet rs = null;    try {        conn = dataSource.getConnection();        stmt = conn.prepareStatement(getAllSimilarItemIDsSQL, ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);        stmt.setFetchDirection(ResultSet.FETCH_FORWARD);        stmt.setFetchSize(getFetchSize());        stmt.setLong(1, itemID);        stmt.setLong(2, itemID);        rs = stmt.executeQuery();        while (rs.next()) {            allSimilarItemIDs.add(rs.getLong(1));            allSimilarItemIDs.add(rs.getLong(2));        }    } catch (SQLException sqle) {        log.warn("Exception while retrieving all similar itemIDs", sqle);        throw new TasteException(sqle);    } finally {        IOUtils.quietClose(rs, stmt, conn);    }    allSimilarItemIDs.remove(itemID);    return allSimilarItemIDs.toArray();}
da77e35d28c590f4b271e5b2b7f639c465574b8f17a1ef2f1df63e0152c57e8b
refresh
public void refresh(Collection<Refreshable> alreadyRefreshed)
{}
66648178ca08676be97036452b6ab489846375282e42fe06e20bbdd457d8abe9
doItemSimilarity
private double doItemSimilarity(PreparedStatement stmt, long itemID1, long itemID2) throws SQLException
{        if (itemID1 > itemID2) {        long temp = itemID1;        itemID1 = itemID2;        itemID2 = temp;    }    stmt.setLong(1, itemID1);    stmt.setLong(2, itemID2);    log.debug("Executing SQL query: {}", getItemItemSimilaritySQL);    ResultSet rs = null;    try {        rs = stmt.executeQuery();                return rs.next() ? rs.getDouble(1) : Double.NaN;    } finally {        IOUtils.quietClose(rs);    }}
be4c32955e91bd020d7aa1f82c019a829836bb1335885ff8146552479e3e6970
getFetchSize
protected int getFetchSize()
{        return Integer.MIN_VALUE;}
be4c32955e91bd020d7aa1f82c019a829836bb1335885ff8146552479e3e6970
getFetchSize
protected int getFetchSize()
{        return Integer.MIN_VALUE;}
0b7804d80b45b3af67abd9dbddbbcc05b1febfbddd8e6391917f89141b92840a
init
public void init(ServletConfig config) throws ServletException
{    super.init(config);    String recommenderClassName = config.getInitParameter("recommender-class");    if (recommenderClassName == null) {        throw new ServletException("Servlet init-param \"recommender-class\" is not defined");    }    RecommenderSingleton.initializeIfNeeded(recommenderClassName);    recommender = RecommenderSingleton.getInstance().getRecommender();}
45d6dc3f293fe3c36530045a1af736ee3e076621591b04fa5db150f0edc011ed
doGet
public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException
{    String userIDString = request.getParameter("userID");    if (userIDString == null) {        throw new ServletException("userID was not specified");    }    long userID = Long.parseLong(userIDString);    String howManyString = request.getParameter("howMany");    int howMany = howManyString == null ? DEFAULT_HOW_MANY : Integer.parseInt(howManyString);    boolean debug = Boolean.parseBoolean(request.getParameter("debug"));    String format = request.getParameter("format");    if (format == null) {        format = "text";    }    try {        List<RecommendedItem> items = recommender.recommend(userID, howMany);        if ("text".equals(format)) {            writePlainText(response, userID, debug, items);        } else if ("xml".equals(format)) {            writeXML(response, items);        } else if ("json".equals(format)) {            writeJSON(response, items);        } else {            throw new ServletException("Bad format parameter: " + format);        }    } catch (TasteException | IOException te) {        throw new ServletException(te);    }}
b543d52ffc67c78282c2b22586a3867060cc195a898245a954d189dcebb883e6
writeXML
private static void writeXML(HttpServletResponse response, Iterable<RecommendedItem> items) throws IOException
{    response.setContentType("application/xml");    response.setCharacterEncoding("UTF-8");    response.setHeader("Cache-Control", "no-cache");    PrintWriter writer = response.getWriter();    writer.print("<?xml version=\"1.0\" encoding=\"UTF-8\"?><recommendedItems>");    for (RecommendedItem recommendedItem : items) {        writer.print("<item><value>");        writer.print(recommendedItem.getValue());        writer.print("</value><id>");        writer.print(recommendedItem.getItemID());        writer.print("</id></item>");    }    writer.println("</recommendedItems>");}
e7312d94d747c2baa85e723fe0cfef50fb4e96b7a497a22c29548428f9cfe9a4
writeJSON
private static void writeJSON(HttpServletResponse response, Iterable<RecommendedItem> items) throws IOException
{    response.setContentType("application/json");    response.setCharacterEncoding("UTF-8");    response.setHeader("Cache-Control", "no-cache");    PrintWriter writer = response.getWriter();    writer.print("{\"recommendedItems\":{\"item\":[");    boolean first = true;    for (RecommendedItem recommendedItem : items) {        if (first) {            first = false;        } else {            writer.print(',');        }        writer.print("{\"value\":\"");        writer.print(recommendedItem.getValue());        writer.print("\",\"id\":\"");        writer.print(recommendedItem.getItemID());        writer.print("\"}");    }    writer.println("]}}");}
0e3f497a08f1c8fbd0736521d489d8b03b01d92dac8bbf47b3cadfaa26680a4c
writePlainText
private void writePlainText(HttpServletResponse response, long userID, boolean debug, Iterable<RecommendedItem> items) throws IOException, TasteException
{    response.setContentType("text/plain");    response.setCharacterEncoding("UTF-8");    response.setHeader("Cache-Control", "no-cache");    PrintWriter writer = response.getWriter();    if (debug) {        writeDebugRecommendations(userID, items, writer);    } else {        writeRecommendations(items, writer);    }}
818d92348a80c4be2fc003ffe7e487c87caf1b974a27c9cd77fdaee2c0079aa1
writeRecommendations
private static void writeRecommendations(Iterable<RecommendedItem> items, PrintWriter writer)
{    for (RecommendedItem recommendedItem : items) {        writer.print(recommendedItem.getValue());        writer.print('\t');        writer.println(recommendedItem.getItemID());    }}
e6407266569c170e2f0166756246eaf9e9d560081e4d8c77c19b9101edc6c48e
writeDebugRecommendations
private void writeDebugRecommendations(long userID, Iterable<RecommendedItem> items, PrintWriter writer) throws TasteException
{    DataModel dataModel = recommender.getDataModel();    writer.print("User:");    writer.println(userID);    writer.print("Recommender: ");    writer.println(recommender);    writer.println();    writer.print("Top ");    writer.print(NUM_TOP_PREFERENCES);    writer.println(" Preferences:");    PreferenceArray rawPrefs = dataModel.getPreferencesFromUser(userID);    int length = rawPrefs.length();    PreferenceArray sortedPrefs = rawPrefs.clone();    sortedPrefs.sortByValueReversed();        int max = Math.min(NUM_TOP_PREFERENCES, length);    for (int i = 0; i < max; i++) {        Preference pref = sortedPrefs.get(i);        writer.print(pref.getValue());        writer.print('\t');        writer.println(pref.getItemID());    }    writer.println();    writer.println("Recommendations:");    for (RecommendedItem recommendedItem : items) {        writer.print(recommendedItem.getValue());        writer.print('\t');        writer.println(recommendedItem.getItemID());    }}
1a36259b8a6f3c0bff51b371963eb1e9144e725e4fc9ce7aa4e2dd5a5555fd48
doPost
public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException
{    doGet(request, response);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "RecommenderServlet[recommender:" + recommender + ']';}
37bd78e48dd8f8fcfff7097848edd4e5fd684988178cfb945dae7f092bc06ff2
getInstance
public static synchronized RecommenderSingleton getInstance()
{    if (instance == null) {        throw new IllegalStateException("Not initialized");    }    return instance;}
e7408e226c3ac581a6c825da959c3790d67caa71ad59bcdf9934b9a908e9766a
initializeIfNeeded
public static synchronized void initializeIfNeeded(String recommenderClassName)
{    if (instance == null) {        instance = new RecommenderSingleton(recommenderClassName);    }}
1feaf6fc85591db6fc04cf7c2f1e5f2f987f06e1642125daa4e3070027e02206
getRecommender
public Recommender getRecommender()
{    return recommender;}
2dc6b0153d6772fcc089075e32bcd2d4f93daa3143e3a889d7821635b62ed9fe
recommend
public List<RecommendedItem> recommend(long userID, int howMany) throws TasteException
{    return delegate.recommend(userID, howMany);}
82cca6a764b4f51c39392acfde0a28aced7e68d46f3f48675d7e2aa136c3b334
recommend
public List<RecommendedItem> recommend(long userID, int howMany, IDRescorer rescorer) throws TasteException
{    return delegate.recommend(userID, howMany, rescorer);}
fe4075a1aad10eb52e9a33b25ff2a59f9af6b1541778182edc3aa82095b47ee2
estimatePreference
public float estimatePreference(long userID, long itemID) throws TasteException
{    return delegate.estimatePreference(userID, itemID);}
50d76af25ae801a2139a90c576940f9f9838c80f93853951415d27753efe6193
setPreference
public void setPreference(long userID, long itemID, float value) throws TasteException
{    delegate.setPreference(userID, itemID, value);}
b8fc0c1b44ecc54ed269a5d79a52cada03c7abb05284d3d33b03ade9d9a86320
removePreference
public void removePreference(long userID, long itemID) throws TasteException
{    delegate.removePreference(userID, itemID);}
9cc8860ae5e18fe9fdcc3faca0fad6e9d7eb4076efef8c2790ec7efad6fe6102
getDataModel
public DataModel getDataModel()
{    return delegate.getDataModel();}
da77e35d28c590f4b271e5b2b7f639c465574b8f17a1ef2f1df63e0152c57e8b
refresh
public void refresh(Collection<Refreshable> alreadyRefreshed)
{    delegate.refresh(alreadyRefreshed);}
9fe4f0217f4c270c0928dacf82bdf19dc640bd381d7feebb4ae76e6f0e1334ea
readResourceToTempFile
public static File readResourceToTempFile(String resourceName) throws IOException
{    String absoluteResource = resourceName.startsWith("/") ? resourceName : '/' + resourceName;    log.info("Loading resource {}", absoluteResource);    InputSupplier<? extends InputStream> inSupplier;    try {        URL resourceURL = Resources.getResource(RecommenderWrapper.class, absoluteResource);        inSupplier = Resources.newInputStreamSupplier(resourceURL);    } catch (IllegalArgumentException iae) {        File resourceFile = new File(resourceName);        log.info("Falling back to load file {}", resourceFile.getAbsolutePath());        inSupplier = Files.newInputStreamSupplier(resourceFile);    }    File tempFile = File.createTempFile("taste", null);    tempFile.deleteOnExit();    Files.copy(inSupplier, tempFile);    return tempFile;}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    ToolRunner.run(new ConfusionMatrixDumper(), args);}
d756081f6122b82915ed5d6542d8c0a46cde13d93e4e426add1fcd67fd99590a
run
public int run(String[] args) throws IOException
{    addInputOption();        addOption("output", "o", "Output path", null);    addOption(DefaultOptionCreator.overwriteOption().create());    addFlag("html", null, "Create complete HTML page");    addFlag("text", null, "Dump simple text");    Map<String, List<String>> parsedArgs = parseArguments(args);    if (parsedArgs == null) {        return -1;    }    Path inputPath = getInputPath();    String outputFile = hasOption("output") ? getOption("output") : null;    boolean text = parsedArgs.containsKey("--text");    boolean wrapHtml = parsedArgs.containsKey("--html");    PrintStream out = getPrintStream(outputFile);    if (text) {        exportText(inputPath, out);    } else {        exportTable(inputPath, out, wrapHtml);    }    out.flush();    if (out != System.out) {        out.close();    }    return 0;}
2ac027dc9d96062fbb9faa319b14539a84089e94c7f526b2d20a1075bcaa93ae
exportText
private static void exportText(Path inputPath, PrintStream out) throws IOException
{    MatrixWritable mw = new MatrixWritable();    Text key = new Text();    readSeqFile(inputPath, key, mw);    Matrix m = mw.get();    ConfusionMatrix cm = new ConfusionMatrix(m);    out.println(String.format("%-40s", "Label") + TAB_SEPARATOR + String.format("%-10s", "Total") + TAB_SEPARATOR + String.format("%-10s", "Correct") + TAB_SEPARATOR + String.format("%-6s", "%") + TAB_SEPARATOR);    out.println(String.format("%-70s", "-").replace(' ', '-'));    List<String> labels = stripDefault(cm);    for (String label : labels) {        int correct = cm.getCorrect(label);        double accuracy = cm.getAccuracy(label);        int count = getCount(cm, label);        out.println(String.format("%-40s", label) + TAB_SEPARATOR + String.format("%-10s", count) + TAB_SEPARATOR + String.format("%-10s", correct) + TAB_SEPARATOR + String.format("%-6s", (int) Math.round(accuracy)) + TAB_SEPARATOR);    }    out.println(String.format("%-70s", "-").replace(' ', '-'));    out.println(cm.toString());}
bdf976ce38d28c49e93f87b55e3899d292effaa05842f499fd2490a356bbd5fd
exportTable
private static void exportTable(Path inputPath, PrintStream out, boolean wrapHtml) throws IOException
{    MatrixWritable mw = new MatrixWritable();    Text key = new Text();    readSeqFile(inputPath, key, mw);    String fileName = inputPath.getName();    fileName = fileName.substring(fileName.lastIndexOf('/') + 1, fileName.length());    Matrix m = mw.get();    ConfusionMatrix cm = new ConfusionMatrix(m);    if (wrapHtml) {        printHeader(out, fileName);    }    out.println("<p/>");    printSummaryTable(cm, out);    out.println("<p/>");    printGrayTable(cm, out);    out.println("<p/>");    printCountsTable(cm, out);    out.println("<p/>");    printTextInBox(cm, out);    out.println("<p/>");    if (wrapHtml) {        printFooter(out);    }}
2dec2f7649d922046c99df51412444209f3c1c7d67a0d20386b9f6ccc5f5ae1b
stripDefault
private static List<String> stripDefault(ConfusionMatrix cm)
{    List<String> stripped = Lists.newArrayList(cm.getLabels().iterator());    String defaultLabel = cm.getDefaultLabel();    int unclassified = cm.getTotal(defaultLabel);    if (unclassified > 0) {        return stripped;    }    stripped.remove(defaultLabel);    return stripped;}
939a57c3cda8d99bf6f03d6da633b3540a020c7cbb088637510f76fa63e2053e
readSeqFile
private static void readSeqFile(Path path, Text key, MatrixWritable m) throws IOException
{    Configuration conf = new Configuration();    FileSystem fs = FileSystem.get(conf);    SequenceFile.Reader reader = new SequenceFile.Reader(fs, path, conf);    reader.next(key, m);}
c6b4f6fe18d35ca4631d038a2cddbe8129e672971f2898290a9a44515d9b4ef4
getPrintStream
private static PrintStream getPrintStream(String outputFilename) throws IOException
{    if (outputFilename != null) {        File outputFile = new File(outputFilename);        if (outputFile.exists()) {            outputFile.delete();        }        outputFile.createNewFile();        OutputStream os = new FileOutputStream(outputFile);        return new PrintStream(os, false, Charsets.UTF_8.displayName());    } else {        return System.out;    }}
6fe6a88f7f05b20521c48c920dbe4f69fc0b04a6b9ec1af245389f337dd34aa1
getLabelTotal
private static int getLabelTotal(ConfusionMatrix cm, String rowLabel)
{    Iterator<String> iter = cm.getLabels().iterator();    int count = 0;    while (iter.hasNext()) {        count += cm.getCount(rowLabel, iter.next());    }    return count;}
90974d7240c57a09bd511d8b5d2e2c1372cbebdcb5503b9b57e02178933f3fa0
printTextInBox
private static void printTextInBox(ConfusionMatrix cm, PrintStream out)
{    out.println("<div style='width:90%;overflow:scroll;'>");    out.println("<pre>");    out.println(cm.toString());    out.println("</pre>");    out.println("</div>");}
934347d9bfe4e8dbb7062a566e6489fffc2f542165faa9bbafc08078e4779625
printSummaryTable
public static void printSummaryTable(ConfusionMatrix cm, PrintStream out)
{    format("<table class='%s'>\n", out, CSS_TABLE);    format("<tr class='%s'>", out, CSS_LABEL);    out.println("<td>Label</td><td>Total</td><td>Correct</td><td>%</td>");    out.println("</tr>");    List<String> labels = stripDefault(cm);    for (String label : labels) {        printSummaryRow(cm, out, label);    }    out.println("</table>");}
7c6225e3891a52f290faebaff947e6537d5c712294b10b810b250f6918582cf0
printSummaryRow
private static void printSummaryRow(ConfusionMatrix cm, PrintStream out, String label)
{    format("<tr class='%s'>", out, CSS_CELL);    int correct = cm.getCorrect(label);    double accuracy = cm.getAccuracy(label);    int count = getCount(cm, label);    format("<td class='%s'>%s</td><td>%d</td><td>%d</td><td>%d</td>", out, CSS_CELL, label, count, correct, (int) Math.round(accuracy));    out.println("</tr>");}
cfcac1f4cfa300aa314db4661cff8ccde81e1d9af82461bf01990ea3dfbe6c30
getCount
private static int getCount(ConfusionMatrix cm, String label)
{    int count = 0;    for (String s : cm.getLabels()) {        count += cm.getCount(label, s);    }    return count;}
5d807d9b6eea7aa76b5cbb9e0c3ed5824f732b26ca1b52e90dba869db56d6bb9
printGrayTable
public static void printGrayTable(ConfusionMatrix cm, PrintStream out)
{    format("<table class='%s'>\n", out, CSS_TABLE);    printCountsHeader(cm, out, true);    printGrayRows(cm, out);    out.println("</table>");}
ba10f5f51534e7694491e6fb56175e30eab8680b282f86ebc2d9360b67dd39b3
printGrayRows
private static void printGrayRows(ConfusionMatrix cm, PrintStream out)
{    List<String> labels = stripDefault(cm);    for (String label : labels) {        printGrayRow(cm, out, labels, label);    }}
653a7962f12a63c0229293d3067420efe580631fdc79ce5336523d39cf24857d
printGrayRow
private static void printGrayRow(ConfusionMatrix cm, PrintStream out, Iterable<String> labels, String rowLabel)
{    format("<tr class='%s'>", out, CSS_LABEL);    format("<td>%s</td>", out, rowLabel);    int total = getLabelTotal(cm, rowLabel);    for (String columnLabel : labels) {        printGrayCell(cm, out, total, rowLabel, columnLabel);    }    out.println("</tr>");}
412acb9f401aa39368f8350b82641bbc1c0ed1df0a50269a8c48163ceb51a818
printGrayCell
private static void printGrayCell(ConfusionMatrix cm, PrintStream out, int total, String rowLabel, String columnLabel)
{    int count = cm.getCount(rowLabel, columnLabel);    if (count == 0) {        out.format("<td class='%s'/>", CSS_EMPTY);    } else {                int rating = (int) ((count / (double) total) * 4);        String css = CSS_GRAY_CELLS[rating];        format("<td class='%s' title='%s'>%s</td>", out, css, columnLabel, count);    }}
0a10de237d03b40c66ad259c60dd062b909df989c47ecfb78c53600a4f59b3c0
printCountsTable
public static void printCountsTable(ConfusionMatrix cm, PrintStream out)
{    format("<table class='%s'>\n", out, CSS_TABLE);    printCountsHeader(cm, out, false);    printCountsRows(cm, out);    out.println("</table>");}
1f4d5f73d62325a117136464278c17aa820b2ce3b251b46c25e95e5869a2109f
printCountsRows
private static void printCountsRows(ConfusionMatrix cm, PrintStream out)
{    List<String> labels = stripDefault(cm);    for (String label : labels) {        printCountsRow(cm, out, labels, label);    }}
f3f0b5345afcd1791ea7040151a81ba6c7204d21ecb708b2a12788c66a6dbdd1
printCountsRow
private static void printCountsRow(ConfusionMatrix cm, PrintStream out, Iterable<String> labels, String rowLabel)
{    out.println("<tr>");    format("<td class='%s'>%s</td>", out, CSS_LABEL, rowLabel);    for (String columnLabel : labels) {        printCountsCell(cm, out, rowLabel, columnLabel);    }    out.println("</tr>");}
9e93d74fa3141bdb06ccf2749b92c45435385a66bbe4d469b7a963959b157a63
printCountsCell
private static void printCountsCell(ConfusionMatrix cm, PrintStream out, String rowLabel, String columnLabel)
{    int count = cm.getCount(rowLabel, columnLabel);    String s = count == 0 ? "" : Integer.toString(count);    format("<td class='%s' title='%s'>%s</td>", out, CSS_CELL, columnLabel, s);}
44f70204496bdac8385def1ad928e12359f9ed48c9983d3e1db608eb4d417b7e
printCountsHeader
private static void printCountsHeader(ConfusionMatrix cm, PrintStream out, boolean vertical)
{    List<String> labels = stripDefault(cm);    int longest = getLongestHeader(labels);    if (vertical) {                out.format("<tr class='%s' style='height:%dem'><th>&nbsp;</th>%n", CSS_TALL_HEADER, longest / 2);        for (String label : labels) {            out.format("<th><div class='%s'>%s</div></th>", CSS_VERTICAL, label);        }        out.println("</tr>");    } else {                out.format("<tr class='%s'><td class='%s'></td>%n", CSS_TABLE, CSS_LABEL);        for (String label : labels) {            out.format("<td>%s</td>", label);        }        out.format("</tr>");    }}
e226ee5395512db83150b23ddc4b6117ac7ae5d1f1551779c640df376b5cf2ad
getLongestHeader
private static int getLongestHeader(Iterable<String> labels)
{    int max = 0;    for (String label : labels) {        max = Math.max(label.length(), max);    }    return max;}
25aa29788f648f67685e36b0a68959e32cde169e3b18413e6c9bc631ac5949d1
format
private static void format(String format, PrintStream out, Object... args)
{    String format2 = String.format(format, args);    out.println(format2);}
dd59a31d8e8a21b591e65e6d5ed594d37223373d1c2e37ba30e61e4f220dde3b
printHeader
public static void printHeader(PrintStream out, CharSequence title)
{    out.println(HEADER.replace("TITLE", title));}
6eb453e1f01028b2852417986c005a4454256631cd88d16399198ba32e7db7ef
printFooter
public static void printFooter(PrintStream out)
{    out.println(FOOTER);}
9c5fb286de73f8aa95ee6a83de42574b53a3fc89cafd31be7d794ec6d482e272
loadClusters
private static List<Cluster> loadClusters(Configuration conf, Path clustersIn)
{    List<Cluster> clusters = new ArrayList<>();    for (ClusterWritable clusterWritable : new SequenceFileDirValueIterable<ClusterWritable>(clustersIn, PathType.LIST, PathFilters.logsCRCFilter(), conf)) {        Cluster cluster = clusterWritable.getValue();        clusters.add(cluster);    }    return clusters;}
9b933a84d0c98ec3ed9888ea7a790f82f2816861b17990c83182a8f5f4d65945
computeStd
private void computeStd(int cI)
{    List<VectorWritable> repPts = representativePoints.get(cI);    GaussianAccumulator accumulator = new OnlineGaussianAccumulator();    for (VectorWritable vw : repPts) {        accumulator.observe(vw.get(), 1.0);    }    accumulator.compute();    double d = accumulator.getAverageStd();    stDevs.put(cI, d);}
901ebc9a2d11f45b1b65f6f59815842ccb77a4b1a4d28381d61ea4a87b335864
density
private double density(Vector uIJ, int cI, int cJ, double avgStd)
{    List<VectorWritable> repI = representativePoints.get(cI);    List<VectorWritable> repJ = representativePoints.get(cJ);    double sum = 0.0;        for (VectorWritable vwI : repI) {        if (uIJ != null && measure.distance(uIJ, vwI.get()) <= avgStd) {            sum++;        }    }    for (VectorWritable vwJ : repJ) {        if (uIJ != null && measure.distance(uIJ, vwJ.get()) <= avgStd) {            sum++;        }    }    int nI = repI.size();    int nJ = repJ.size();    return sum / (nI + nJ);}
d28205f3d04737d7592e90eb9bd5fce096fc159f043417a7634ebdc4923c8b10
getCDbw
public double getCDbw()
{    return intraClusterDensity() * separation();}
ba64ea1ef03976001e6acc6e5ea71cd58c1a7f613da10e49b815da0ea50ea859
intraClusterDensity
public double intraClusterDensity()
{    double avgDensity = 0;    int count = 0;    for (Element elem : intraClusterDensities().nonZeroes()) {        double value = elem.get();        if (!Double.isNaN(value)) {            avgDensity += value;            count++;        }    }    return avgDensity / count;}
fab73c703ff85cfc0f335761a4c1b3fe782ee114419301049c3aa3e3ff7ec019
interClusterDensities
public Map<Integer, Map<Integer, Double>> interClusterDensities()
{    if (interClusterDensities != null) {        return interClusterDensities;    }    interClusterDensities = new TreeMap<>();        for (int i = 0; i < clusters.size(); i++) {        int cI = clusters.get(i).getId();        Map<Integer, Double> map = new TreeMap<>();        interClusterDensities.put(cI, map);        for (int j = i + 1; j < clusters.size(); j++) {            int cJ = clusters.get(j).getId();                        double minDistance = minimumDistance(cI, cJ);                        Vector uIJ = midpointVector(cI, cJ);            double stdSum = stDevs.get(cI) + stDevs.get(cJ);            double density = density(uIJ, cI, cJ, stdSum / 2);            double interDensity = minDistance * density / stdSum;            map.put(cJ, interDensity);            if (log.isDebugEnabled()) {                log.debug("minDistance[{},{}]={}", cI, cJ, minDistance);                log.debug("interDensity[{},{}]={}", cI, cJ, density);                log.debug("density[{},{}]={}", cI, cJ, interDensity);            }        }    }    return interClusterDensities;}
ed9ec43417715d2a9e995f916bc2e048b27518c8c47b4917bd39fd9e074a6f70
separation
public double separation()
{    double minDistanceSum = 0;    Map<Integer, Map<Integer, Double>> distances = minimumDistances();    for (Map<Integer, Double> map : distances.values()) {        for (Double dist : map.values()) {            if (!Double.isInfinite(dist)) {                                minDistanceSum += dist * 2;            }        }    }    return minDistanceSum / (1.0 + interClusterDensity());}
5b53c6249314cd0583d5d9c10f1b436786ea974803fd58c9b44a391bbad2f13d
interClusterDensity
public double interClusterDensity()
{    if (interClusterDensity != null) {        return interClusterDensity;    }    double sum = 0.0;    int count = 0;    Map<Integer, Map<Integer, Double>> distances = interClusterDensities();    for (Map<Integer, Double> row : distances.values()) {        for (Double density : row.values()) {            if (!Double.isNaN(density)) {                sum += density;                count++;            }        }    }    log.debug("interClusterDensity={}", sum);    interClusterDensity = sum / count;    return interClusterDensity;}
26e37b1074268cb8a89cd548a91326c26d7689e92b3f90d7342a83a1c5cbc797
intraClusterDensities
public Vector intraClusterDensities()
{    Vector densities = new RandomAccessSparseVector(Integer.MAX_VALUE);        double stdev = 0.0;    for (Integer cI : representativePoints.keySet()) {        stdev += stDevs.get(cI);    }    int c = representativePoints.size();    stdev /= c;    for (Cluster cluster : clusters) {        Integer cI = cluster.getId();        List<VectorWritable> repPtsI = representativePoints.get(cI);        int r = repPtsI.size();        double sumJ = 0.0;                for (VectorWritable pt : repPtsI) {                        Vector repJ = pt.get();            double densityIJ = measure.distance(cluster.getCenter(), repJ) <= stdev ? 1.0 : 0.0;                        sumJ += densityIJ / stdev;        }        densities.set(cI, sumJ / r);    }    return densities;}
acc72e47b2c624870a9a9db7960f03c80e9f679a4ad775f1802449eb408b1f92
minimumDistances
private Map<Integer, Map<Integer, Double>> minimumDistances()
{    if (minimumDistances != null) {        return minimumDistances;    }    minimumDistances = new TreeMap<>();    closestRepPointIndices = new TreeMap<>();    for (int i = 0; i < clusters.size(); i++) {        Integer cI = clusters.get(i).getId();        Map<Integer, Double> map = new TreeMap<>();        Map<Integer, int[]> treeMap = new TreeMap<>();        closestRepPointIndices.put(cI, treeMap);        minimumDistances.put(cI, map);        List<VectorWritable> closRepI = representativePoints.get(cI);        for (int j = i + 1; j < clusters.size(); j++) {                        Integer cJ = clusters.get(j).getId();            List<VectorWritable> closRepJ = representativePoints.get(cJ);            double minDistance = Double.MAX_VALUE;            int[] midPointIndices = null;            for (int xI = 0; xI < closRepI.size(); xI++) {                VectorWritable aRepI = closRepI.get(xI);                for (int xJ = 0; xJ < closRepJ.size(); xJ++) {                    VectorWritable aRepJ = closRepJ.get(xJ);                    double distance = measure.distance(aRepI.get(), aRepJ.get());                    if (distance < minDistance) {                        minDistance = distance;                        midPointIndices = new int[] { xI, xJ };                    }                }            }            map.put(cJ, minDistance);            treeMap.put(cJ, midPointIndices);        }    }    return minimumDistances;}
bcf1bd1d4cfc1a1475f311462d08cae1060a86cca0e412a32311a649d6d62515
minimumDistance
private double minimumDistance(int cI, int cJ)
{    Map<Integer, Double> distances = minimumDistances().get(cI);    if (distances != null) {        return distances.get(cJ);    } else {        return minimumDistances().get(cJ).get(cI);    }}
65e76e6ccc20253505b7bead2349139438c1a732e3c9f23ccfeb1be9dc202c8b
midpointVector
private Vector midpointVector(int cI, int cJ)
{    Map<Integer, Double> distances = minimumDistances().get(cI);    if (distances != null) {        int[] ks = closestRepPointIndices.get(cI).get(cJ);        if (ks == null) {            return null;        }        return representativePoints.get(cI).get(ks[0]).get().plus(representativePoints.get(cJ).get(ks[1]).get()).divide(2);    } else {        int[] ks = closestRepPointIndices.get(cJ).get(cI);        if (ks == null) {            return null;        }        return representativePoints.get(cJ).get(ks[1]).get().plus(representativePoints.get(cI).get(ks[0]).get()).divide(2);    }}
59254bdeea196a04aa484d3df43ef533299171755dcc2d78c62b5db6ccf74e9c
main
public static void main(String[] args) throws IOException, InterruptedException, ClassNotFoundException
{    DefaultOptionBuilder obuilder = new DefaultOptionBuilder();    ArgumentBuilder abuilder = new ArgumentBuilder();    GroupBuilder gbuilder = new GroupBuilder();    Option inputOpt = DefaultOptionCreator.inputOption().withRequired(false).create();    Option outputOpt = DefaultOptionCreator.outputOption().withRequired(false).create();    Option vectorOpt = obuilder.withLongName("vector").withRequired(false).withArgument(abuilder.withName("v").withMinimum(1).withMaximum(1).create()).withDescription("The vector implementation to use.").withShortName("v").create();    Option helpOpt = DefaultOptionCreator.helpOption();    Group group = gbuilder.withName("Options").withOption(inputOpt).withOption(outputOpt).withOption(vectorOpt).withOption(helpOpt).create();    try {        Parser parser = new Parser();        parser.setGroup(group);        CommandLine cmdLine = parser.parse(args);        if (cmdLine.hasOption(helpOpt)) {            CommandLineUtil.printHelp(group);            return;        }        Path input = new Path(cmdLine.getValue(inputOpt, "testdata").toString());        Path output = new Path(cmdLine.getValue(outputOpt, "output").toString());        String vectorClassName = cmdLine.getValue(vectorOpt, "org.apache.mahout.math.RandomAccessSparseVector").toString();        runJob(input, output, vectorClassName);    } catch (OptionException e) {        log.error("Exception parsing command line: ", e);        CommandLineUtil.printHelp(group);    }}
988c0d9953983f0f5ed43db9913b97e66bc243fe4999aa21ef2c7c6d6e35eb51
runJob
public static void runJob(Path input, Path output, String vectorClassName) throws IOException, InterruptedException, ClassNotFoundException
{    Configuration conf = new Configuration();    conf.set("vector.implementation.class.name", vectorClassName);    Job job = new Job(conf, "Input Driver running over input: " + input);    job.setOutputKeyClass(Text.class);    job.setOutputValueClass(VectorWritable.class);    job.setOutputFormatClass(SequenceFileOutputFormat.class);    job.setMapperClass(InputMapper.class);    job.setNumReduceTasks(0);    job.setJarByClass(InputDriver.class);    FileInputFormat.addInputPath(job, input);    FileOutputFormat.setOutputPath(job, output);    boolean succeeded = job.waitForCompletion(true);    if (!succeeded) {        throw new IllegalStateException("Job failed!");    }}
4849b04b7855ec3988f4a1db5aeb3c052161faa889cd66a9a4f9dba28cc70851
map
protected void map(LongWritable key, Text values, Context context) throws IOException, InterruptedException
{    String[] numbers = SPACE.split(values.toString());        Collection<Double> doubles = new ArrayList<>();    for (String value : numbers) {        if (!value.isEmpty()) {            doubles.add(Double.valueOf(value));        }    }        if (!doubles.isEmpty()) {        try {            Vector result = (Vector) constructor.newInstance(doubles.size());            int index = 0;            for (Double d : doubles) {                result.set(index++, d);            }            VectorWritable vectorWritable = new VectorWritable(result);            context.write(new Text(String.valueOf(index)), vectorWritable);        } catch (InstantiationException | IllegalAccessException | InvocationTargetException e) {            throw new IllegalStateException(e);        }    }}
6b7dd49be7482fc8ee0fbe8bd0f24522f2a718c8c816a3d7b048fb4688eb6373
setup
protected void setup(Context context) throws IOException, InterruptedException
{    super.setup(context);    Configuration conf = context.getConfiguration();    String vectorImplClassName = conf.get("vector.implementation.class.name");    try {        Class<? extends Vector> outputClass = conf.getClassByName(vectorImplClassName).asSubclass(Vector.class);        constructor = outputClass.getConstructor(int.class);    } catch (NoSuchMethodException | ClassNotFoundException e) {        throw new IllegalStateException(e);    }}
9c5fb286de73f8aa95ee6a83de42574b53a3fc89cafd31be7d794ec6d482e272
loadClusters
private static List<Cluster> loadClusters(Configuration conf, Path clustersIn)
{    List<Cluster> clusters = new ArrayList<>();    for (ClusterWritable clusterWritable : new SequenceFileDirValueIterable<ClusterWritable>(clustersIn, PathType.LIST, PathFilters.logsCRCFilter(), conf)) {        Cluster cluster = clusterWritable.getValue();        clusters.add(cluster);    }    return clusters;}
5b53c6249314cd0583d5d9c10f1b436786ea974803fd58c9b44a391bbad2f13d
interClusterDensity
public double interClusterDensity()
{    double max = Double.NEGATIVE_INFINITY;    double min = Double.POSITIVE_INFINITY;    double sum = 0;    int count = 0;    Map<Integer, Vector> distances = interClusterDistances();    for (Vector row : distances.values()) {        for (Element element : row.nonZeroes()) {            double d = element.get();            min = Math.min(d, min);            max = Math.max(d, max);            sum += d;            count++;        }    }    double density = (sum / count - min) / (max - min);    log.info("Scaled Inter-Cluster Density = {}", density);    return density;}
85a52cbdc36448a23ddafa1256304201db4ff370a6e9c15cdaa002f20e279d6f
interClusterDistances
public Map<Integer, Vector> interClusterDistances()
{    Map<Integer, Vector> distances = new TreeMap<>();    for (int i = 0; i < clusters.size(); i++) {        Cluster clusterI = clusters.get(i);        RandomAccessSparseVector row = new RandomAccessSparseVector(Integer.MAX_VALUE);        distances.put(clusterI.getId(), row);        for (int j = i + 1; j < clusters.size(); j++) {            Cluster clusterJ = clusters.get(j);            double d = measure.distance(clusterI.getCenter(), clusterJ.getCenter());            row.set(clusterJ.getId(), d);        }    }    return distances;}
ba64ea1ef03976001e6acc6e5ea71cd58c1a7f613da10e49b815da0ea50ea859
intraClusterDensity
public double intraClusterDensity()
{    double avgDensity = 0;    int count = 0;    for (Element elem : intraClusterDensities().nonZeroes()) {        double value = elem.get();        if (!Double.isNaN(value)) {            avgDensity += value;            count++;        }    }    avgDensity = clusters.isEmpty() ? 0 : avgDensity / count;    log.info("Average Intra-Cluster Density = {}", avgDensity);    return avgDensity;}
26e37b1074268cb8a89cd548a91326c26d7689e92b3f90d7342a83a1c5cbc797
intraClusterDensities
public Vector intraClusterDensities()
{    Vector densities = new RandomAccessSparseVector(Integer.MAX_VALUE);    for (Cluster cluster : clusters) {        int count = 0;        double max = Double.NEGATIVE_INFINITY;        double min = Double.POSITIVE_INFINITY;        double sum = 0;        List<VectorWritable> repPoints = representativePoints.get(cluster.getId());        for (int i = 0; i < repPoints.size(); i++) {            for (int j = i + 1; j < repPoints.size(); j++) {                Vector v1 = repPoints.get(i).get();                Vector v2 = repPoints.get(j).get();                double d = measure.distance(v1, v2);                min = Math.min(d, min);                max = Math.max(d, max);                sum += d;                count++;            }        }        double density = (sum / count - min) / (max - min);        densities.set(cluster.getId(), density);        log.info("Intra-Cluster Density[{}] = {}", cluster.getId(), density);    }    return densities;}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    ToolRunner.run(new Configuration(), new RepresentativePointsDriver(), args);}
6d1544bc3ddc367589ed4dcd928f508d796b18dfad02d88cca972f09ebba3836
run
public int run(String[] args) throws ClassNotFoundException, IOException, InterruptedException
{    addInputOption();    addOutputOption();    addOption("clusteredPoints", "cp", "The path to the clustered points", true);    addOption(DefaultOptionCreator.distanceMeasureOption().create());    addOption(DefaultOptionCreator.maxIterationsOption().create());    addOption(DefaultOptionCreator.methodOption().create());    if (parseArguments(args) == null) {        return -1;    }    Path input = getInputPath();    Path output = getOutputPath();    String distanceMeasureClass = getOption(DefaultOptionCreator.DISTANCE_MEASURE_OPTION);    int maxIterations = Integer.parseInt(getOption(DefaultOptionCreator.MAX_ITERATIONS_OPTION));    boolean runSequential = getOption(DefaultOptionCreator.METHOD_OPTION).equalsIgnoreCase(DefaultOptionCreator.SEQUENTIAL_METHOD);    DistanceMeasure measure = ClassUtils.instantiateAs(distanceMeasureClass, DistanceMeasure.class);    Path clusteredPoints = new Path(getOption("clusteredPoints"));    run(getConf(), input, clusteredPoints, output, measure, maxIterations, runSequential);    return 0;}
d8825ec519c6258d9b3ea0acbd084831d2969217f90567729583a247efdde4d3
printRepresentativePoints
public static void printRepresentativePoints(Path output, int numIterations)
{    for (int i = 0; i <= numIterations; i++) {        Path out = new Path(output, "representativePoints-" + i);        System.out.println("Representative Points for iteration " + i);        Configuration conf = new Configuration();        for (Pair<IntWritable, VectorWritable> record : new SequenceFileDirIterable<IntWritable, VectorWritable>(out, PathType.LIST, PathFilters.logsCRCFilter(), null, true, conf)) {            System.out.println("\tC-" + record.getFirst().get() + ": " + AbstractCluster.formatVector(record.getSecond().get(), null));        }    }}
771fce7b7c6389c0641cd3dcf449991a1ad686b63bad1a7f41f1bdf99ea8d4ec
run
public static void run(Configuration conf, Path clustersIn, Path clusteredPointsIn, Path output, DistanceMeasure measure, int numIterations, boolean runSequential) throws IOException, InterruptedException, ClassNotFoundException
{    Path stateIn = new Path(output, "representativePoints-0");    writeInitialState(stateIn, clustersIn);    for (int iteration = 0; iteration < numIterations; iteration++) {        log.info("Representative Points Iteration {}", iteration);                Path stateOut = new Path(output, "representativePoints-" + (iteration + 1));        runIteration(conf, clusteredPointsIn, stateIn, stateOut, measure, runSequential);                stateIn = stateOut;    }    conf.set(STATE_IN_KEY, stateIn.toString());    conf.set(DISTANCE_MEASURE_KEY, measure.getClass().getName());}
4995d88be854933142b83516dd4f4ac302659cbe1e568758ec321236c496bf36
writeInitialState
private static void writeInitialState(Path output, Path clustersIn) throws IOException
{    Configuration conf = new Configuration();    FileSystem fs = FileSystem.get(output.toUri(), conf);    for (FileStatus dir : fs.globStatus(clustersIn)) {        Path inPath = dir.getPath();        for (FileStatus part : fs.listStatus(inPath, PathFilters.logsCRCFilter())) {            Path inPart = part.getPath();            Path path = new Path(output, inPart.getName());            try (SequenceFile.Writer writer = new SequenceFile.Writer(fs, conf, path, IntWritable.class, VectorWritable.class)) {                for (ClusterWritable clusterWritable : new SequenceFileValueIterable<ClusterWritable>(inPart, true, conf)) {                    Cluster cluster = clusterWritable.getValue();                    if (log.isDebugEnabled()) {                        log.debug("C-{}: {}", cluster.getId(), AbstractCluster.formatVector(cluster.getCenter(), null));                    }                    writer.append(new IntWritable(cluster.getId()), new VectorWritable(cluster.getCenter()));                }            }        }    }}
577996a80dd39f2f182a7cb621b478c9d8723ef131c91c4e1471fb392338a50f
runIteration
private static void runIteration(Configuration conf, Path clusteredPointsIn, Path stateIn, Path stateOut, DistanceMeasure measure, boolean runSequential) throws IOException, InterruptedException, ClassNotFoundException
{    if (runSequential) {        runIterationSeq(conf, clusteredPointsIn, stateIn, stateOut, measure);    } else {        runIterationMR(conf, clusteredPointsIn, stateIn, stateOut, measure);    }}
156569b126396c2e1825771716abf5db05f4007a7103e56ce18483fcb4ad8fa1
runIterationSeq
private static void runIterationSeq(Configuration conf, Path clusteredPointsIn, Path stateIn, Path stateOut, DistanceMeasure measure) throws IOException
{    Map<Integer, List<VectorWritable>> repPoints = RepresentativePointsMapper.getRepresentativePoints(conf, stateIn);    Map<Integer, WeightedVectorWritable> mostDistantPoints = new HashMap<>();    FileSystem fs = FileSystem.get(clusteredPointsIn.toUri(), conf);    for (Pair<IntWritable, WeightedVectorWritable> record : new SequenceFileDirIterable<IntWritable, WeightedVectorWritable>(clusteredPointsIn, PathType.LIST, PathFilters.logsCRCFilter(), null, true, conf)) {        RepresentativePointsMapper.mapPoint(record.getFirst(), record.getSecond(), measure, repPoints, mostDistantPoints);    }    int part = 0;    try (SequenceFile.Writer writer = new SequenceFile.Writer(fs, conf, new Path(stateOut, "part-m-" + part++), IntWritable.class, VectorWritable.class)) {        for (Entry<Integer, List<VectorWritable>> entry : repPoints.entrySet()) {            for (VectorWritable vw : entry.getValue()) {                writer.append(new IntWritable(entry.getKey()), vw);            }        }    }    try (SequenceFile.Writer writer = new SequenceFile.Writer(fs, conf, new Path(stateOut, "part-m-" + part++), IntWritable.class, VectorWritable.class)) {        for (Map.Entry<Integer, WeightedVectorWritable> entry : mostDistantPoints.entrySet()) {            writer.append(new IntWritable(entry.getKey()), new VectorWritable(entry.getValue().getVector()));        }    }}
07776d93add33f5ffccee60b56743f3dc8fafeeba1ae6901b0eb0dfcf7f4de4f
runIterationMR
private static void runIterationMR(Configuration conf, Path input, Path stateIn, Path stateOut, DistanceMeasure measure) throws IOException, InterruptedException, ClassNotFoundException
{    conf.set(STATE_IN_KEY, stateIn.toString());    conf.set(DISTANCE_MEASURE_KEY, measure.getClass().getName());    Job job = new Job(conf, "Representative Points Driver running over input: " + input);    job.setJarByClass(RepresentativePointsDriver.class);    job.setOutputKeyClass(IntWritable.class);    job.setOutputValueClass(VectorWritable.class);    job.setMapOutputKeyClass(IntWritable.class);    job.setMapOutputValueClass(WeightedVectorWritable.class);    FileInputFormat.setInputPaths(job, input);    FileOutputFormat.setOutputPath(job, stateOut);    job.setMapperClass(RepresentativePointsMapper.class);    job.setReducerClass(RepresentativePointsReducer.class);    job.setInputFormatClass(SequenceFileInputFormat.class);    job.setOutputFormatClass(SequenceFileOutputFormat.class);    boolean succeeded = job.waitForCompletion(true);    if (!succeeded) {        throw new IllegalStateException("Job failed!");    }}
2e250b70eb1261a97967b8b894cf822fc9e7eb36891dbb77c6d16369f85de12a
cleanup
protected void cleanup(Context context) throws IOException, InterruptedException
{    for (Map.Entry<Integer, WeightedVectorWritable> entry : mostDistantPoints.entrySet()) {        context.write(new IntWritable(entry.getKey()), entry.getValue());    }    super.cleanup(context);}
cdd6011680bf062a3d0b0a7d29d027a39baac7e5b9774be24a2c2ff1f9872f8c
map
protected void map(IntWritable clusterId, WeightedVectorWritable point, Context context) throws IOException, InterruptedException
{    mapPoint(clusterId, point, measure, representativePoints, mostDistantPoints);}
57b68fa9adbdd8b677393ec1b4f11c7ea5d08cde230c4bad21baaaed2d272d63
mapPoint
public static void mapPoint(IntWritable clusterId, WeightedVectorWritable point, DistanceMeasure measure, Map<Integer, List<VectorWritable>> representativePoints, Map<Integer, WeightedVectorWritable> mostDistantPoints)
{    int key = clusterId.get();    WeightedVectorWritable currentMDP = mostDistantPoints.get(key);    List<VectorWritable> repPoints = representativePoints.get(key);    double totalDistance = 0.0;    if (repPoints != null) {        for (VectorWritable refPoint : repPoints) {            totalDistance += measure.distance(refPoint.get(), point.getVector());        }    }    if (currentMDP == null || currentMDP.getWeight() < totalDistance) {        mostDistantPoints.put(key, new WeightedVectorWritable(totalDistance, point.getVector().clone()));    }}
6b7dd49be7482fc8ee0fbe8bd0f24522f2a718c8c816a3d7b048fb4688eb6373
setup
protected void setup(Context context) throws IOException, InterruptedException
{    super.setup(context);    Configuration conf = context.getConfiguration();    measure = ClassUtils.instantiateAs(conf.get(RepresentativePointsDriver.DISTANCE_MEASURE_KEY), DistanceMeasure.class);    representativePoints = getRepresentativePoints(conf);}
a7ee38186d781af8b13076062aaae7fe310eededcf5292e754dd4d900c8e349b
configure
public void configure(Map<Integer, List<VectorWritable>> referencePoints, DistanceMeasure measure)
{    this.representativePoints = referencePoints;    this.measure = measure;}
fe854c6c3c014e343c8d1e055e186e84a5bea150b6350dceaa7c9c6f689e947a
getRepresentativePoints
public static Map<Integer, List<VectorWritable>> getRepresentativePoints(Configuration conf)
{    String statePath = conf.get(RepresentativePointsDriver.STATE_IN_KEY);    return getRepresentativePoints(conf, new Path(statePath));}
e87651ff2c9926e2e57eb7c0634b46d1576c4a934ef8017a165e5b4ec20e4959
getRepresentativePoints
public static Map<Integer, List<VectorWritable>> getRepresentativePoints(Configuration conf, Path statePath)
{    Map<Integer, List<VectorWritable>> representativePoints = new HashMap<>();    for (Pair<IntWritable, VectorWritable> record : new SequenceFileDirIterable<IntWritable, VectorWritable>(statePath, PathType.LIST, PathFilters.logsCRCFilter(), conf)) {        int keyValue = record.getFirst().get();        List<VectorWritable> repPoints = representativePoints.get(keyValue);        if (repPoints == null) {            repPoints = new ArrayList<>();            representativePoints.put(keyValue, repPoints);        }        repPoints.add(record.getSecond());    }    return representativePoints;}
2e250b70eb1261a97967b8b894cf822fc9e7eb36891dbb77c6d16369f85de12a
cleanup
protected void cleanup(Context context) throws IOException, InterruptedException
{    for (Map.Entry<Integer, List<VectorWritable>> entry : representativePoints.entrySet()) {        IntWritable iw = new IntWritable(entry.getKey());        for (VectorWritable vw : entry.getValue()) {            context.write(iw, vw);        }    }    super.cleanup(context);}
b2c6a49980a4ce7b1de3b4b26145af441f2d2d0cd43a00f677458ed21c2970f6
reduce
protected void reduce(IntWritable key, Iterable<WeightedVectorWritable> values, Context context) throws IOException, InterruptedException
{        WeightedVectorWritable mdp = null;    for (WeightedVectorWritable dpw : values) {        if (mdp == null || mdp.getWeight() < dpw.getWeight()) {            mdp = new WeightedVectorWritable(dpw.getWeight(), dpw.getVector());        }    }    context.write(new IntWritable(key.get()), new VectorWritable(mdp.getVector()));}
6b7dd49be7482fc8ee0fbe8bd0f24522f2a718c8c816a3d7b048fb4688eb6373
setup
protected void setup(Context context) throws IOException, InterruptedException
{    super.setup(context);    Configuration conf = context.getConfiguration();    representativePoints = RepresentativePointsMapper.getRepresentativePoints(conf);}
8d094e022459737aa367225d03a73fb86019c7e7ddd85d2573f643e4348bed49
configure
public void configure(Map<Integer, List<VectorWritable>> representativePoints)
{    this.representativePoints = representativePoints;}
48b8e77422684661fb9eb4b4fec726f9b9c3e681f99efa13cef2fefe26aad873
ensureQueueSize
private static void ensureQueueSize(Collection<Queue<Pair<String, Double>>> queues, int k)
{    for (int i = queues.size(); i <= k; ++i) {        queues.add(new PriorityQueue<Pair<String, Double>>());    }}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    DefaultOptionBuilder obuilder = new DefaultOptionBuilder();    ArgumentBuilder abuilder = new ArgumentBuilder();    GroupBuilder gbuilder = new GroupBuilder();    Option inputOpt = DefaultOptionCreator.inputOption().create();    Option dictOpt = obuilder.withLongName("dict").withRequired(true).withArgument(abuilder.withName("dict").withMinimum(1).withMaximum(1).create()).withDescription("Dictionary to read in, in the same format as one created by " + "org.apache.mahout.utils.vectors.lucene.Driver").withShortName("d").create();    Option outOpt = DefaultOptionCreator.outputOption().create();    Option wordOpt = obuilder.withLongName("words").withRequired(false).withArgument(abuilder.withName("words").withMinimum(0).withMaximum(1).withDefault("20").create()).withDescription("Number of words to print").withShortName("w").create();    Option dictTypeOpt = obuilder.withLongName("dictionaryType").withRequired(false).withArgument(abuilder.withName("dictionaryType").withMinimum(1).withMaximum(1).create()).withDescription("The dictionary file type (text|sequencefile)").withShortName("dt").create();    Option helpOpt = obuilder.withLongName("help").withDescription("Print out help").withShortName("h").create();    Group group = gbuilder.withName("Options").withOption(dictOpt).withOption(outOpt).withOption(wordOpt).withOption(inputOpt).withOption(dictTypeOpt).create();    try {        Parser parser = new Parser();        parser.setGroup(group);        CommandLine cmdLine = parser.parse(args);        if (cmdLine.hasOption(helpOpt)) {            CommandLineUtil.printHelp(group);            return;        }        String input = cmdLine.getValue(inputOpt).toString();        String dictFile = cmdLine.getValue(dictOpt).toString();        int numWords = 20;        if (cmdLine.hasOption(wordOpt)) {            numWords = Integer.parseInt(cmdLine.getValue(wordOpt).toString());        }        Configuration config = new Configuration();        String dictionaryType = "text";        if (cmdLine.hasOption(dictTypeOpt)) {            dictionaryType = cmdLine.getValue(dictTypeOpt).toString();        }        List<String> wordList;        if ("text".equals(dictionaryType)) {            wordList = Arrays.asList(VectorHelper.loadTermDictionary(new File(dictFile)));        } else if ("sequencefile".equals(dictionaryType)) {            wordList = Arrays.asList(VectorHelper.loadTermDictionary(config, dictFile));        } else {            throw new IllegalArgumentException("Invalid dictionary format");        }        List<Queue<Pair<String, Double>>> topWords = topWordsForTopics(input, config, wordList, numWords);        File output = null;        if (cmdLine.hasOption(outOpt)) {            output = new File(cmdLine.getValue(outOpt).toString());            if (!output.exists() && !output.mkdirs()) {                throw new IOException("Could not create directory: " + output);            }        }        printTopWords(topWords, output);    } catch (OptionException e) {        CommandLineUtil.printHelp(group);        throw e;    }}
02132e138ac5819836e798f7be674239066b57549a27de52370974199f1ca9fc
maybeEnqueue
private static void maybeEnqueue(Queue<Pair<String, Double>> q, String word, double score, int numWordsToPrint)
{    if (q.size() >= numWordsToPrint && score > q.peek().getSecond()) {        q.poll();    }    if (q.size() < numWordsToPrint) {        q.add(new Pair<>(word, score));    }}
89b8df09d8b9f83c459ffb06d70a4b36eeb4ee9c86e96a20daafb74449b2c708
printTopWords
private static void printTopWords(List<Queue<Pair<String, Double>>> topWords, File outputDir) throws IOException
{    for (int i = 0; i < topWords.size(); ++i) {        Collection<Pair<String, Double>> topK = topWords.get(i);        Writer out = null;        boolean printingToSystemOut = false;        try {            if (outputDir != null) {                out = new OutputStreamWriter(new FileOutputStream(new File(outputDir, "topic_" + i)), Charsets.UTF_8);            } else {                out = new OutputStreamWriter(System.out, Charsets.UTF_8);                printingToSystemOut = true;                out.write("Topic " + i);                out.write('\n');                out.write("===========");                out.write('\n');            }            List<Pair<String, Double>> topKasList = new ArrayList<>(topK.size());            for (Pair<String, Double> wordWithScore : topK) {                topKasList.add(wordWithScore);            }            Collections.sort(topKasList, new Comparator<Pair<String, Double>>() {                @Override                public int compare(Pair<String, Double> pair1, Pair<String, Double> pair2) {                    return pair2.getSecond().compareTo(pair1.getSecond());                }            });            for (Pair<String, Double> wordWithScore : topKasList) {                out.write(wordWithScore.getFirst() + " [p(" + wordWithScore.getFirst() + "|topic_" + i + ") = " + wordWithScore.getSecond());                out.write('\n');            }        } finally {            if (!printingToSystemOut) {                Closeables.close(out, false);            } else {                out.flush();            }        }    }}
9f6797d61a8c283114ccd94fee3b85b8d94a9e9a45a1e3116e72c7cda2c3f24d
compare
public int compare(Pair<String, Double> pair1, Pair<String, Double> pair2)
{    return pair2.getSecond().compareTo(pair1.getSecond());}
bbe25fd638122502045473008daf97c0d345ee3443933f71ff1e702f4649e7f2
topWordsForTopics
private static List<Queue<Pair<String, Double>>> topWordsForTopics(String dir, Configuration job, List<String> wordList, int numWordsToPrint)
{    List<Queue<Pair<String, Double>>> queues = new ArrayList<>();    Map<Integer, Double> expSums = new HashMap<>();    for (Pair<IntPairWritable, DoubleWritable> record : new SequenceFileDirIterable<IntPairWritable, DoubleWritable>(new Path(dir, "part-*"), PathType.GLOB, null, null, true, job)) {        IntPairWritable key = record.getFirst();        int topic = key.getFirst();        int word = key.getSecond();        ensureQueueSize(queues, topic);        if (word >= 0 && topic >= 0) {            double score = record.getSecond().get();            if (expSums.get(topic) == null) {                expSums.put(topic, 0.0);            }            expSums.put(topic, expSums.get(topic) + Math.exp(score));            String realWord = wordList.get(word);            maybeEnqueue(queues.get(topic), realWord, score, numWordsToPrint);        }    }    for (int i = 0; i < queues.size(); i++) {        Queue<Pair<String, Double>> queue = queues.get(i);        Queue<Pair<String, Double>> newQueue = new PriorityQueue<>(queue.size());        double norm = expSums.get(i);        for (Pair<String, Double> pair : queue) {            newQueue.add(new Pair<>(pair.getFirst(), Math.exp(pair.getSecond()) / norm));        }        queues.set(i, newQueue);    }    return queues;}
d408e3a2b49cab4e5c69f47aa07f760b0e824e598346c57f62e91cedf287ba9b
createComponents
protected TokenStreamComponents createComponents(String fieldName)
{    Tokenizer tokenizer = new StandardTokenizer();    TokenStream result = new StandardFilter(tokenizer);    result = new LowerCaseFilter(result);    result = new ASCIIFoldingFilter(result);    result = new AlphaNumericMaxLengthFilter(result);    result = new StopFilter(result, STOP_SET);    result = new PorterStemFilter(result);    return new TokenStreamComponents(tokenizer, result);}
af21a90d2e571b32c0ae435a13cc1ea0f8bf4253cfbe37c35deb6174448f06c3
incrementToken
public final boolean incrementToken() throws IOException
{        while (input.incrementToken()) {        int length = termAtt.length();        if (length >= 2 && length <= 28) {            char[] buf = termAtt.buffer();            int at = 0;            for (int c = 0; c < length; c++) {                char ch = buf[c];                if (ch != '\'') {                    output[at++] = ch;                }            }            String term = new String(output, 0, at);            MATCHER.reset(term);            if (MATCHER.matches() && !term.startsWith("a0")) {                termAtt.setEmpty();                termAtt.append(term);                return true;            }        }    }    return false;}
ff759c525ff1cf43a3b1390eef9a261cbf7f7b80af679a3d33265a3517a9e9ee
createRecordReader
public RecordReader<IntWritable, BytesWritable> createRecordReader(InputSplit inputSplit, TaskAttemptContext taskAttemptContext) throws IOException
{    return new CombineFileRecordReader<>((CombineFileSplit) inputSplit, taskAttemptContext, WholeFileRecordReader.class);}
98ca607a981dc360fc5e3caa61b73ecf754ea43cf25fc929f665fda0adea5401
process
protected void process(FileStatus fst, Path current) throws IOException
{    FileSystem fs = getFs();    ChunkedWriter writer = getWriter();    if (fst.isDir()) {        String dirPath = getPrefix() + Path.SEPARATOR + current.getName() + Path.SEPARATOR + fst.getPath().getName();        fs.listStatus(fst.getPath(), new PrefixAdditionFilter(getConf(), dirPath, getOptions(), writer, getCharset(), fs));    } else {        try (InputStream in = fs.open(fst.getPath())) {            StringBuilder file = new StringBuilder();            for (String aFit : new FileLineIterable(in, getCharset(), false)) {                file.append(aFit).append('\n');            }            String name = current.getName().equals(fst.getPath().getName()) ? current.getName() : current.getName() + Path.SEPARATOR + fst.getPath().getName();            writer.write(getPrefix() + Path.SEPARATOR + name, file.toString());        }    }}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    ToolRunner.run(new SequenceFilesFromDirectory(), args);}
aacecb0f01750d985b78d806dc3c134f0da79efe2752957e0f93ecf5cbf9e492
run
public int run(String[] args) throws Exception
{    addOptions();    addOption(DefaultOptionCreator.methodOption().create());    addOption(DefaultOptionCreator.overwriteOption().create());    if (parseArguments(args) == null) {        return -1;    }    Map<String, String> options = parseOptions();    Path output = getOutputPath();    if (hasOption(DefaultOptionCreator.OVERWRITE_OPTION)) {        HadoopUtil.delete(getConf(), output);    }    if (getOption(DefaultOptionCreator.METHOD_OPTION, DefaultOptionCreator.MAPREDUCE_METHOD).equals(DefaultOptionCreator.SEQUENTIAL_METHOD)) {        runSequential(getConf(), getInputPath(), output, options);    } else {        runMapReduce(getInputPath(), output);    }    return 0;}
20dbe7978645d554398c896e57ea7e76f72a9e9ffb97165b6524af5d5d638798
runSequential
private int runSequential(Configuration conf, Path input, Path output, Map<String, String> options) throws IOException, InterruptedException, NoSuchMethodException
{        Charset charset = Charset.forName(getOption(CHARSET_OPTION[0]));    String keyPrefix = getOption(KEY_PREFIX_OPTION[0]);    FileSystem fs = FileSystem.get(input.toUri(), conf);    try (ChunkedWriter writer = new ChunkedWriter(conf, Integer.parseInt(options.get(CHUNK_SIZE_OPTION[0])), output)) {        SequenceFilesFromDirectoryFilter pathFilter;        String fileFilterClassName = options.get(FILE_FILTER_CLASS_OPTION[0]);        if (PrefixAdditionFilter.class.getName().equals(fileFilterClassName)) {            pathFilter = new PrefixAdditionFilter(conf, keyPrefix, options, writer, charset, fs);        } else {            pathFilter = ClassUtils.instantiateAs(fileFilterClassName, SequenceFilesFromDirectoryFilter.class, new Class[] { Configuration.class, String.class, Map.class, ChunkedWriter.class, Charset.class, FileSystem.class }, new Object[] { conf, keyPrefix, options, writer, charset, fs });        }        fs.listStatus(input, pathFilter);    }    return 0;}
5474392161b81aeb3744e2acc21a80a3264d408914df14513176b1aefca7d791
runMapReduce
private int runMapReduce(Path input, Path output) throws IOException, ClassNotFoundException, InterruptedException
{    int chunkSizeInMB = 64;    if (hasOption(CHUNK_SIZE_OPTION[0])) {        chunkSizeInMB = Integer.parseInt(getOption(CHUNK_SIZE_OPTION[0]));    }    String keyPrefix = null;    if (hasOption(KEY_PREFIX_OPTION[0])) {        keyPrefix = getOption(KEY_PREFIX_OPTION[0]);    }    String fileFilterClassName = null;    if (hasOption(FILE_FILTER_CLASS_OPTION[0])) {        fileFilterClassName = getOption(FILE_FILTER_CLASS_OPTION[0]);    }    PathFilter pathFilter = null;        if (!StringUtils.isBlank(fileFilterClassName) && !PrefixAdditionFilter.class.getName().equals(fileFilterClassName)) {        try {            pathFilter = (PathFilter) Class.forName(fileFilterClassName).newInstance();        } catch (InstantiationException | IllegalAccessException e) {            throw new IllegalStateException(e);        }    }        Job job = prepareJob(input, output, MultipleTextFileInputFormat.class, SequenceFilesFromDirectoryMapper.class, Text.class, Text.class, SequenceFileOutputFormat.class, "SequenceFilesFromDirectory");    Configuration jobConfig = job.getConfiguration();    jobConfig.set(KEY_PREFIX_OPTION[0], keyPrefix);    jobConfig.set(FILE_FILTER_CLASS_OPTION[0], fileFilterClassName);    FileSystem fs = FileSystem.get(jobConfig);    FileStatus fsFileStatus = fs.getFileStatus(input);    String inputDirList;    if (pathFilter != null) {        inputDirList = HadoopUtil.buildDirList(fs, fsFileStatus, pathFilter);    } else {        inputDirList = HadoopUtil.buildDirList(fs, fsFileStatus);    }    jobConfig.set(BASE_INPUT_PATH, input.toString());    long chunkSizeInBytes = chunkSizeInMB * 1024 * 1024;        jobConfig.set("mapreduce.job.max.split.locations", String.valueOf(MAX_JOB_SPLIT_LOCATIONS));    FileInputFormat.setInputPaths(job, inputDirList);        FileInputFormat.setMaxInputSplitSize(job, chunkSizeInBytes);    FileOutputFormat.setCompressOutput(job, true);    boolean succeeded = job.waitForCompletion(true);    if (!succeeded) {        return -1;    }    return 0;}
03a1341fe04bde4dbce03323a953b61cf6ee33b20d6c4449fc064ee5e5bf38a2
addOptions
protected void addOptions()
{    addInputOption();    addOutputOption();    addOption(DefaultOptionCreator.overwriteOption().create());    addOption(DefaultOptionCreator.methodOption().create());    addOption(CHUNK_SIZE_OPTION[0], CHUNK_SIZE_OPTION[1], "The chunkSize in MegaBytes. Defaults to 64", "64");    addOption(FILE_FILTER_CLASS_OPTION[0], FILE_FILTER_CLASS_OPTION[1], "The name of the class to use for file parsing. Default: " + PREFIX_ADDITION_FILTER, PREFIX_ADDITION_FILTER);    addOption(KEY_PREFIX_OPTION[0], KEY_PREFIX_OPTION[1], "The prefix to be prepended to the key", "");    addOption(CHARSET_OPTION[0], CHARSET_OPTION[1], "The name of the character encoding of the input files. Default to UTF-8", "UTF-8");}
3a101c60deae1d28b86b6e663484d22d60a9f3115c20d9ed5474d10b551c4e31
parseOptions
protected Map<String, String> parseOptions()
{    Map<String, String> options = new HashMap<>();    options.put(CHUNK_SIZE_OPTION[0], getOption(CHUNK_SIZE_OPTION[0]));    options.put(FILE_FILTER_CLASS_OPTION[0], getOption(FILE_FILTER_CLASS_OPTION[0]));    options.put(CHARSET_OPTION[0], getOption(CHARSET_OPTION[0]));    return options;}
588426dd45e008d6ca8adc31e98b028a5b14da1e65d4f872fe7aaaa1ff122bb0
getPrefix
protected final String getPrefix()
{    return prefix;}
70353f2b24ad60b9779a97d1e480e3a92ef8a0e0a61ac6b550a3af64305c8a0b
getWriter
protected final ChunkedWriter getWriter()
{    return writer;}
fbf383969b9c3461363b67da1ee5e51f159e01638ec64384644e9a70606d624e
getCharset
protected final Charset getCharset()
{    return charset;}
25e19477bb1a76172acce478ee6dcf290bb5fc20fab651d948e520f3c9e05d55
getFs
protected final FileSystem getFs()
{    return fs;}
08b954637a9bbcc3faaa14a1eb1a78577cc1707529baa459f7b039d16934fb25
getOptions
protected final Map<String, String> getOptions()
{    return options;}
3889a7d04555f444a1a7f7e4f30f78299e9f95c4a7fceddafaf207651bf9c53e
getConf
protected final Configuration getConf()
{    return conf;}
e272301f1f4dea6d6844bdf74717cddc12ef591deedf73ecb3caeef8568095a8
accept
public final boolean accept(Path current)
{    log.debug("CURRENT: {}", current.getName());    try {        for (FileStatus fst : fs.listStatus(current)) {            log.debug("CHILD: {}", fst.getPath().getName());            process(fst, current);        }    } catch (IOException ioe) {        throw new IllegalStateException(ioe);    }    return false;}
6b7dd49be7482fc8ee0fbe8bd0f24522f2a718c8c816a3d7b048fb4688eb6373
setup
protected void setup(Context context) throws IOException, InterruptedException
{    super.setup(context);    this.keyPrefix = context.getConfiguration().get(KEY_PREFIX_OPTION[0], "");}
9e57cdbc5f7220d176e42f9ac65a9c73aa9623c78b6b7a6765189e35854c4c60
map
public void map(IntWritable key, BytesWritable value, Context context) throws IOException, InterruptedException
{    Configuration configuration = context.getConfiguration();    Path filePath = ((CombineFileSplit) context.getInputSplit()).getPath(key.get());    String relativeFilePath = HadoopUtil.calcRelativeFilePath(configuration, filePath);    String filename = this.keyPrefix.length() > 0 ? this.keyPrefix + Path.SEPARATOR + relativeFilePath : Path.SEPARATOR + relativeFilePath;    fileValue.set(value.getBytes(), 0, value.getBytes().length);    context.write(new Text(filename), fileValue);}
b4d367edcb690a50179f6b1a1d5415360f9df9bafaf99981299e59892028ba35
createSequenceFiles
public void createSequenceFiles(MailOptions options) throws IOException
{    try (ChunkedWriter writer = new ChunkedWriter(getConf(), options.getChunkSize(), new Path(options.getOutputDir()))) {        MailProcessor processor = new MailProcessor(options, options.getPrefix(), writer);        if (options.getInput().isDirectory()) {            PrefixAdditionDirectoryWalker walker = new PrefixAdditionDirectoryWalker(processor, writer);            walker.walk(options.getInput());            log.info("Parsed {} messages from {}", walker.getMessageCount(), options.getInput().getAbsolutePath());        } else {            long start = System.currentTimeMillis();            long cnt = processor.parseMboxLineByLine(options.getInput());            long finish = System.currentTimeMillis();            log.info("Parsed {} messages from {} in time: {}", cnt, options.getInput().getAbsolutePath(), finish - start);        }    }}
e904d546367032ffe21bf3c44025cd37e41052f02dff4e31bca95c9f4c7b0316
walk
public void walk(File startDirectory) throws IOException
{    super.walk(startDirectory, null);}
dcc176667c396179700c5b0cc44f723abe8f9bbb0f4e1dd1d020e6526ce9fbf6
getMessageCount
public long getMessageCount()
{    return messageCounts.getFirst();}
c573a9bae8403af0ad4e1fbc68e586a17306accb1deeb781a998348318a6328f
handleDirectoryStart
protected void handleDirectoryStart(File current, int depth, Collection<Object> results) throws IOException
{    if (depth > 0) {        log.info("At {}", current.getAbsolutePath());        MailProcessor processor = processors.getFirst();        MailProcessor subDirProcessor = new MailProcessor(processor.getOptions(), processor.getPrefix() + File.separator + current.getName(), writer);        processors.push(subDirProcessor);        messageCounts.push(0L);    }}
f17d2be3d5eb0dc9e5ae071456c2d01d3484b0f9bdd7872c94577525c3ed00bd
filterDirectoryContents
protected File[] filterDirectoryContents(File directory, int depth, File[] files) throws IOException
{    Arrays.sort(files, FILE_COMPARATOR);    return files;}
f6ff7305dabf36bf117d1bac6e9c0d2204fcf56ddd5030599a229c92633c8f59
handleFile
protected void handleFile(File current, int depth, Collection<Object> results) throws IOException
{    MailProcessor processor = processors.getFirst();    long currentDirMessageCount = messageCounts.pop();    try {        currentDirMessageCount += processor.parseMboxLineByLine(current);    } catch (IOException e) {        throw new IllegalStateException("Error processing " + current, e);    }    messageCounts.push(currentDirMessageCount);}
6e92aa4487f837bbdb4f6154b78e27fbb6b90d2a83cee896a9cb6d5ce03ac59f
handleDirectoryEnd
protected void handleDirectoryEnd(File current, int depth, Collection<Object> results) throws IOException
{    if (depth > 0) {        final long currentDirMessageCount = messageCounts.pop();        log.info("Parsed {} messages from directory {}", currentDirMessageCount, current.getAbsolutePath());        processors.pop();                long parentDirMessageCount = messageCounts.pop();        parentDirMessageCount += currentDirMessageCount;        messageCounts.push(parentDirMessageCount);    }}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    ToolRunner.run(new Configuration(), new SequenceFilesFromMailArchives(), args);}
aacecb0f01750d985b78d806dc3c134f0da79efe2752957e0f93ecf5cbf9e492
run
public int run(String[] args) throws Exception
{    addInputOption();    addOutputOption();    addOption(DefaultOptionCreator.methodOption().create());    addOption(CHUNK_SIZE_OPTION[0], CHUNK_SIZE_OPTION[1], "The chunkSize in MegaBytes. Defaults to 64", "64");    addOption(KEY_PREFIX_OPTION[0], KEY_PREFIX_OPTION[1], "The prefix to be prepended to the key", "");    addOption(CHARSET_OPTION[0], CHARSET_OPTION[1], "The name of the character encoding of the input files. Default to UTF-8", "UTF-8");    addFlag(SUBJECT_OPTION[0], SUBJECT_OPTION[1], "Include the Mail subject as part of the text.  Default is false");    addFlag(TO_OPTION[0], TO_OPTION[1], "Include the to field in the text.  Default is false");    addFlag(FROM_OPTION[0], FROM_OPTION[1], "Include the from field in the text.  Default is false");    addFlag(REFERENCES_OPTION[0], REFERENCES_OPTION[1], "Include the references field in the text.  Default is false");    addFlag(BODY_OPTION[0], BODY_OPTION[1], "Include the body in the output.  Default is false");    addFlag(STRIP_QUOTED_OPTION[0], STRIP_QUOTED_OPTION[1], "Strip (remove) quoted email text in the body.  Default is false");    addOption(QUOTED_REGEX_OPTION[0], QUOTED_REGEX_OPTION[1], "Specify the regex that identifies quoted text.  " + "Default is to look for > or | at the beginning of the line.");    addOption(SEPARATOR_OPTION[0], SEPARATOR_OPTION[1], "The separator to use between metadata items (to, from, etc.).  Default is \\n", "\n");    addOption(BODY_SEPARATOR_OPTION[0], BODY_SEPARATOR_OPTION[1], "The separator to use between lines in the body.  Default is \\n.  " + "Useful to change if you wish to have the message be on one line", "\n");    addOption(DefaultOptionCreator.helpOption());    Map<String, List<String>> parsedArgs = parseArguments(args);    if (parsedArgs == null) {        return -1;    }    File input = getInputFile();    String outputDir = getOutputPath().toString();    int chunkSize = 64;    if (hasOption(CHUNK_SIZE_OPTION[0])) {        chunkSize = Integer.parseInt(getOption(CHUNK_SIZE_OPTION[0]));    }    String prefix = "";    if (hasOption(KEY_PREFIX_OPTION[0])) {        prefix = getOption(KEY_PREFIX_OPTION[0]);    }    Charset charset = Charset.forName(getOption(CHARSET_OPTION[0]));    MailOptions options = new MailOptions();    options.setInput(input);    options.setOutputDir(outputDir);    options.setPrefix(prefix);    options.setChunkSize(chunkSize);    options.setCharset(charset);    List<Pattern> patterns = new ArrayList<>(5);                Map<String, Integer> patternOrder = new HashMap<>();    int order = 0;    if (hasOption(FROM_OPTION[0])) {        patterns.add(MailProcessor.FROM_PREFIX);        patternOrder.put(MailOptions.FROM, order++);    }    if (hasOption(TO_OPTION[0])) {        patterns.add(MailProcessor.TO_PREFIX);        patternOrder.put(MailOptions.TO, order++);    }    if (hasOption(REFERENCES_OPTION[0])) {        patterns.add(MailProcessor.REFS_PREFIX);        patternOrder.put(MailOptions.REFS, order++);    }    if (hasOption(SUBJECT_OPTION[0])) {        patterns.add(MailProcessor.SUBJECT_PREFIX);        patternOrder.put(MailOptions.SUBJECT, order += 1);    }    options.setStripQuotedText(hasOption(STRIP_QUOTED_OPTION[0]));    options.setPatternsToMatch(patterns.toArray(new Pattern[patterns.size()]));    options.setPatternOrder(patternOrder);    options.setIncludeBody(hasOption(BODY_OPTION[0]));    if (hasOption(SEPARATOR_OPTION[0])) {        options.setSeparator(getOption(SEPARATOR_OPTION[0]));    } else {        options.setSeparator("\n");    }    if (hasOption(BODY_SEPARATOR_OPTION[0])) {        options.setBodySeparator(getOption(BODY_SEPARATOR_OPTION[0]));    }    if (hasOption(QUOTED_REGEX_OPTION[0])) {        options.setQuotedTextPattern(Pattern.compile(getOption(QUOTED_REGEX_OPTION[0])));    }    if (getOption(DefaultOptionCreator.METHOD_OPTION, DefaultOptionCreator.MAPREDUCE_METHOD).equals(DefaultOptionCreator.SEQUENTIAL_METHOD)) {        runSequential(options);    } else {        runMapReduce(getInputPath(), getOutputPath());    }    return 0;}
3feac6f39cb115345d94e86cff34008a98799ff87aa1ef7cf3c7324a83c23f5c
runSequential
private int runSequential(MailOptions options) throws IOException, InterruptedException, NoSuchMethodException
{    long start = System.currentTimeMillis();    createSequenceFiles(options);    long finish = System.currentTimeMillis();    log.info("Conversion took {}ms", finish - start);    return 0;}
cdaa6c07dd8e55550148821340fda193c255579b441b1ada950bcb4b409d92a5
runMapReduce
private int runMapReduce(Path input, Path output) throws IOException, InterruptedException, ClassNotFoundException
{    Job job = prepareJob(input, output, MultipleTextFileInputFormat.class, SequenceFilesFromMailArchivesMapper.class, Text.class, Text.class, SequenceFileOutputFormat.class, "SequentialFilesFromMailArchives");    Configuration jobConfig = job.getConfiguration();    if (hasOption(KEY_PREFIX_OPTION[0])) {        jobConfig.set(KEY_PREFIX_OPTION[1], getOption(KEY_PREFIX_OPTION[0]));    }    int chunkSize = 0;    if (hasOption(CHUNK_SIZE_OPTION[0])) {        chunkSize = Integer.parseInt(getOption(CHUNK_SIZE_OPTION[0]));        jobConfig.set(CHUNK_SIZE_OPTION[0], String.valueOf(chunkSize));    }    Charset charset;    if (hasOption(CHARSET_OPTION[0])) {        charset = Charset.forName(getOption(CHARSET_OPTION[0]));        jobConfig.set(CHARSET_OPTION[0], charset.displayName());    }    if (hasOption(FROM_OPTION[0])) {        jobConfig.set(FROM_OPTION[1], "true");    }    if (hasOption(TO_OPTION[0])) {        jobConfig.set(TO_OPTION[1], "true");    }    if (hasOption(REFERENCES_OPTION[0])) {        jobConfig.set(REFERENCES_OPTION[1], "true");    }    if (hasOption(SUBJECT_OPTION[0])) {        jobConfig.set(SUBJECT_OPTION[1], "true");    }    if (hasOption(QUOTED_REGEX_OPTION[0])) {        jobConfig.set(QUOTED_REGEX_OPTION[1], Pattern.compile(getOption(QUOTED_REGEX_OPTION[0])).toString());    }    if (hasOption(SEPARATOR_OPTION[0])) {        jobConfig.set(SEPARATOR_OPTION[1], getOption(SEPARATOR_OPTION[0]));    } else {        jobConfig.set(SEPARATOR_OPTION[1], "\n");    }    if (hasOption(BODY_OPTION[0])) {        jobConfig.set(BODY_OPTION[1], "true");    } else {        jobConfig.set(BODY_OPTION[1], "false");    }    if (hasOption(BODY_SEPARATOR_OPTION[0])) {        jobConfig.set(BODY_SEPARATOR_OPTION[1], getOption(BODY_SEPARATOR_OPTION[0]));    } else {        jobConfig.set(BODY_SEPARATOR_OPTION[1], "\n");    }    FileSystem fs = FileSystem.get(jobConfig);    FileStatus fsFileStatus = fs.getFileStatus(inputPath);    jobConfig.set(BASE_INPUT_PATH, inputPath.toString());    String inputDirList = HadoopUtil.buildDirList(fs, fsFileStatus);    FileInputFormat.setInputPaths(job, inputDirList);    long chunkSizeInBytes = chunkSize * 1024 * 1024;        FileInputFormat.setMaxInputSplitSize(job, chunkSizeInBytes);        jobConfig.set("mapreduce.job.max.split.locations", String.valueOf(MAX_JOB_SPLIT_LOCATIONS));    boolean succeeded = job.waitForCompletion(true);    if (!succeeded) {        return -1;    }    return 0;}
836c38c3943f50a8bf32ea6d0e16447349958d7c380d2a2e078085f5e58e6030
setup
public void setup(Context context) throws IOException, InterruptedException
{    Configuration configuration = context.getConfiguration();        this.options = new MailOptions();    options.setPrefix(configuration.get(KEY_PREFIX_OPTION[1], ""));    if (!configuration.get(CHUNK_SIZE_OPTION[0], "").equals("")) {        options.setChunkSize(configuration.getInt(CHUNK_SIZE_OPTION[0], 64));    }    if (!configuration.get(CHARSET_OPTION[0], "").equals("")) {        Charset charset = Charset.forName(configuration.get(CHARSET_OPTION[0], "UTF-8"));        options.setCharset(charset);    } else {        Charset charset = Charset.forName("UTF-8");        options.setCharset(charset);    }    List<Pattern> patterns = Lists.newArrayListWithCapacity(5);                        Map<String, Integer> patternOrder = Maps.newHashMap();    int order = 0;    if (!configuration.get(FROM_OPTION[1], "").equals("")) {        patterns.add(MailProcessor.FROM_PREFIX);        patternOrder.put(MailOptions.FROM, order++);    }    if (!configuration.get(TO_OPTION[1], "").equals("")) {        patterns.add(MailProcessor.TO_PREFIX);        patternOrder.put(MailOptions.TO, order++);    }    if (!configuration.get(REFERENCES_OPTION[1], "").equals("")) {        patterns.add(MailProcessor.REFS_PREFIX);        patternOrder.put(MailOptions.REFS, order++);    }    if (!configuration.get(SUBJECT_OPTION[1], "").equals("")) {        patterns.add(MailProcessor.SUBJECT_PREFIX);        patternOrder.put(MailOptions.SUBJECT, order += 1);    }    options.setStripQuotedText(configuration.getBoolean(STRIP_QUOTED_OPTION[1], false));    options.setPatternsToMatch(patterns.toArray(new Pattern[patterns.size()]));    options.setPatternOrder(patternOrder);    options.setIncludeBody(configuration.getBoolean(BODY_OPTION[1], false));    options.setSeparator("\n");    if (!configuration.get(SEPARATOR_OPTION[1], "").equals("")) {        options.setSeparator(configuration.get(SEPARATOR_OPTION[1], ""));    }    if (!configuration.get(BODY_SEPARATOR_OPTION[1], "").equals("")) {        options.setBodySeparator(configuration.get(BODY_SEPARATOR_OPTION[1], ""));    }    if (!configuration.get(QUOTED_REGEX_OPTION[1], "").equals("")) {        options.setQuotedTextPattern(Pattern.compile(configuration.get(QUOTED_REGEX_OPTION[1], "")));    }}
21699decb3ae2da54ac1751d34e7a8c615324c610f641d38c2cd86fd0f57a302
parseMailboxLineByLine
public long parseMailboxLineByLine(String filename, InputStream mailBoxInputStream, Context context) throws IOException, InterruptedException
{    long messageCount = 0;    try {        StringBuilder contents = new StringBuilder();        StringBuilder body = new StringBuilder();        Matcher messageIdMatcher = MESSAGE_ID_PREFIX.matcher("");        Matcher messageBoundaryMatcher = MESSAGE_START.matcher("");        String[] patternResults = new String[options.getPatternsToMatch().length];        Matcher[] matches = new Matcher[options.getPatternsToMatch().length];        for (int i = 0; i < matches.length; i++) {            matches[i] = options.getPatternsToMatch()[i].matcher("");        }        String messageId = null;        boolean inBody = false;        Pattern quotedTextPattern = options.getQuotedTextPattern();        for (String nextLine : new FileLineIterable(mailBoxInputStream, options.getCharset(), false, filename)) {            if (!options.isStripQuotedText() || !quotedTextPattern.matcher(nextLine).find()) {                for (int i = 0; i < matches.length; i++) {                    Matcher matcher = matches[i];                    matcher.reset(nextLine);                    if (matcher.matches()) {                        patternResults[i] = matcher.group(1);                    }                }                                if (messageId != null) {                                        messageBoundaryMatcher.reset(nextLine);                    if (messageBoundaryMatcher.matches()) {                                                String key = generateKey(filename, options.getPrefix(), messageId);                                                                        writeContent(options.getSeparator(), contents, body, patternResults);                        this.outKey.set(key);                        this.outValue.set(contents.toString());                        context.write(this.outKey, this.outValue);                                                contents.setLength(0);                        body.setLength(0);                        messageId = null;                        inBody = false;                    } else {                        if (inBody && options.isIncludeBody()) {                            if (!nextLine.isEmpty()) {                                body.append(nextLine).append(options.getBodySeparator());                            }                        } else {                                                                                    inBody = nextLine.isEmpty();                        }                    }                } else {                    if (nextLine.length() > 14) {                        messageIdMatcher.reset(nextLine);                        if (messageIdMatcher.matches()) {                            messageId = messageIdMatcher.group(1);                            ++messageCount;                        }                    }                }            }        }                if (messageId != null) {            String key = generateKey(filename, options.getPrefix(), messageId);            writeContent(options.getSeparator(), contents, body, patternResults);            this.outKey.set(key);            this.outValue.set(contents.toString());            context.write(this.outKey, this.outValue);                        contents.setLength(0);        }    } catch (FileNotFoundException ignored) {    }    return messageCount;}
f365074c8ea9ab1c04e7a52baf8841ed132d8ded88b077470d9fdb8a4ef362cb
generateKey
protected static String generateKey(String mboxFilename, String prefix, String messageId)
{    return Joiner.on(Path.SEPARATOR).join(Lists.newArrayList(prefix, mboxFilename, messageId).iterator());}
762edc020caac22c96146379313397a1ccaf0313c63a8f7bb3ea3d00d189d157
writeContent
private static void writeContent(String separator, StringBuilder contents, CharSequence body, String[] matches)
{    String matchesString = Joiner.on(separator).useForNull("").join(Arrays.asList(matches).iterator());    contents.append(matchesString).append(separator).append(body);}
9e57cdbc5f7220d176e42f9ac65a9c73aa9623c78b6b7a6765189e35854c4c60
map
public void map(IntWritable key, BytesWritable value, Context context) throws IOException, InterruptedException
{    Configuration configuration = context.getConfiguration();    Path filePath = ((CombineFileSplit) context.getInputSplit()).getPath(key.get());    String relativeFilePath = HadoopUtil.calcRelativeFilePath(configuration, filePath);    ByteArrayInputStream is = new ByteArrayInputStream(value.getBytes());    parseMailboxLineByLine(relativeFilePath, is, context);}
b31cb6a894acd9e406667b955507e22a99129892a3c5ceaddbedccc2f2a9db5b
run
public int run(String[] strings) throws Exception
{    Configuration originalConf = getConf();    Job job = prepareJob(new Path(originalConf.get("mapred.input.dir")), new Path(originalConf.get("mapred.output.dir")), SequenceFileInputFormat.class, SplitMap.class, Text.class, Text.class, Reducer.class, Text.class, Text.class, SequenceFileOutputFormat.class);    job.setNumReduceTasks(0);    boolean succeeded = job.waitForCompletion(true);    return succeeded ? 0 : -1;}
2505923d598227187ef110a092e3c1a7d9ab80cbf2f72084c78309a518120a25
map
protected void map(Text key, Text text, Context context) throws IOException, InterruptedException
{    Text outText = new Text();    int loc = 0;    while (loc >= 0 && loc < text.getLength()) {        int nextLoc = text.find("\n\n", loc + 1);        if (nextLoc > 0) {            outText.set(text.getBytes(), loc, nextLoc - loc);            context.write(key, outText);        }        loc = nextLoc;    }}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    ToolRunner.run(new TextParagraphSplittingJob(), args);}
f1ce24c8746716155888e00804cf8da4175edee3b2edb9e491b2c7b3f540ed9c
getCurrentKey
public IntWritable getCurrentKey()
{    return index;}
e99c52c1fd619589a5430f0e30462227c0567ba05a7c2f3e7f0c499befa28b86
getCurrentValue
public BytesWritable getCurrentValue()
{    return value;}
46dc59cbf7e4d6aafe0869ef2726ed2c5c897b673d9e37f94ab9b0e962f65f7f
getProgress
public float getProgress() throws IOException
{    return processed ? 1.0f : 0.0f;}
dd167304ae15a7a5d2c2016d1fb0b1735468d58eb0a5d71718d2140dcae23256
initialize
public void initialize(InputSplit inputSplit, TaskAttemptContext taskAttemptContext) throws IOException, InterruptedException
{    if (!StringUtils.isBlank(fileFilterClassName) && !PrefixAdditionFilter.class.getName().equals(fileFilterClassName)) {        try {            pathFilter = (PathFilter) Class.forName(fileFilterClassName).newInstance();        } catch (ClassNotFoundException | InstantiationException | IllegalAccessException e) {            throw new IllegalStateException(e);        }    }}
b69592fc9341edb7a43374eb2f7a0a47b61b976f5cd62be6b25e79df6ee9f6b6
nextKeyValue
public boolean nextKeyValue() throws IOException
{    if (!processed) {        byte[] contents = new byte[(int) fileSplit.getLength()];        Path file = fileSplit.getPath();        FileSystem fs = file.getFileSystem(this.configuration);        if (!fs.isFile(file)) {            return false;        }        FileStatus[] fileStatuses;        if (pathFilter != null) {            fileStatuses = fs.listStatus(file, pathFilter);        } else {            fileStatuses = fs.listStatus(file);        }        if (fileStatuses.length == 1) {            try (FSDataInputStream in = fs.open(fileStatuses[0].getPath())) {                IOUtils.readFully(in, contents, 0, contents.length);                value.setCapacity(contents.length);                value.set(contents, 0, contents.length);            }            processed = true;            return true;        }    }    return false;}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{}
d408e3a2b49cab4e5c69f47aa07f760b0e824e598346c57f62e91cedf287ba9b
createComponents
protected TokenStreamComponents createComponents(String fieldName)
{    Tokenizer tokenizer = new WikipediaTokenizer();    TokenStream result = new StandardFilter(tokenizer);    result = new LowerCaseFilter(result);    result = new StopFilter(result, getStopwordSet());    return new TokenStreamComponents(tokenizer, result);}
b81e514e3f24351a0df9133ceef866e50dade4f5359a9069d337e24c341276f5
main
public static void main(String[] args) throws IOException, InterruptedException
{    DefaultOptionBuilder obuilder = new DefaultOptionBuilder();    ArgumentBuilder abuilder = new ArgumentBuilder();    GroupBuilder gbuilder = new GroupBuilder();    Option dirInputPathOpt = DefaultOptionCreator.inputOption().create();    Option dirOutputPathOpt = DefaultOptionCreator.outputOption().create();    Option categoriesOpt = obuilder.withLongName("categories").withRequired(true).withArgument(abuilder.withName("categories").withMinimum(1).withMaximum(1).create()).withDescription("Location of the categories file.  One entry per line. " + "Will be used to make a string match in Wikipedia Category field").withShortName("c").create();    Option exactMatchOpt = obuilder.withLongName("exactMatch").withDescription("If set, then the category name must exactly match the " + "entry in the categories file. Default is false").withShortName("e").create();    Option analyzerOpt = obuilder.withLongName("analyzer").withRequired(false).withArgument(abuilder.withName("analyzer").withMinimum(1).withMaximum(1).create()).withDescription("The analyzer to use, must have a no argument constructor").withShortName("a").create();    Option helpOpt = DefaultOptionCreator.helpOption();    Group group = gbuilder.withName("Options").withOption(categoriesOpt).withOption(dirInputPathOpt).withOption(dirOutputPathOpt).withOption(exactMatchOpt).withOption(analyzerOpt).withOption(helpOpt).create();    Parser parser = new Parser();    parser.setGroup(group);    try {        CommandLine cmdLine = parser.parse(args);        if (cmdLine.hasOption(helpOpt)) {            CommandLineUtil.printHelp(group);            return;        }        String inputPath = (String) cmdLine.getValue(dirInputPathOpt);        String outputPath = (String) cmdLine.getValue(dirOutputPathOpt);        String catFile = (String) cmdLine.getValue(categoriesOpt);        Class<? extends Analyzer> analyzerClass = WikipediaAnalyzer.class;        if (cmdLine.hasOption(analyzerOpt)) {            String className = cmdLine.getValue(analyzerOpt).toString();            analyzerClass = Class.forName(className).asSubclass(Analyzer.class);                                    ClassUtils.instantiateAs(analyzerClass, Analyzer.class);        }        runJob(inputPath, outputPath, catFile, cmdLine.hasOption(exactMatchOpt), analyzerClass);    } catch (OptionException e) {        log.error("Exception", e);        CommandLineUtil.printHelp(group);    } catch (ClassNotFoundException e) {        log.error("Exception", e);        CommandLineUtil.printHelp(group);    }}
8dc6e10406aaea1d724c5e66c569db2890356aad98bb88b6e79c854c6ef6c8e9
runJob
public static void runJob(String input, String output, String catFile, boolean exactMatchOnly, Class<? extends Analyzer> analyzerClass) throws IOException, InterruptedException, ClassNotFoundException
{    Configuration conf = new Configuration();    conf.set("key.value.separator.in.input.line", " ");    conf.set("xmlinput.start", "<page>");    conf.set("xmlinput.end", "</page>");    conf.setBoolean("exact.match.only", exactMatchOnly);    conf.set("analyzer.class", analyzerClass.getName());    conf.set("io.serializations", "org.apache.hadoop.io.serializer.JavaSerialization," + "org.apache.hadoop.io.serializer.WritableSerialization");            Set<String> categories = new HashSet<>();    for (String line : new FileLineIterable(new File(catFile))) {        categories.add(line.trim().toLowerCase(Locale.ENGLISH));    }    Stringifier<Set<String>> setStringifier = new DefaultStringifier<>(conf, GenericsUtil.getClass(categories));    String categoriesStr = setStringifier.toString(categories);    conf.set("wikipedia.categories", categoriesStr);    Job job = new Job(conf);    log.info("Input: {} Out: {} Categories: {}", input, output, catFile);    job.setJarByClass(WikipediaDatasetCreatorDriver.class);    job.setOutputKeyClass(Text.class);    job.setOutputValueClass(Text.class);    job.setMapperClass(WikipediaDatasetCreatorMapper.class);        job.setInputFormatClass(XmlInputFormat.class);    job.setReducerClass(WikipediaDatasetCreatorReducer.class);    job.setOutputFormatClass(TextOutputFormat.class);    FileInputFormat.setInputPaths(job, new Path(input));    Path outPath = new Path(output);    FileOutputFormat.setOutputPath(job, outPath);    HadoopUtil.delete(conf, outPath);    boolean succeeded = job.waitForCompletion(true);    if (!succeeded) {        throw new IllegalStateException("Job failed!");    }}
364372c8c0a17a2c3987e3f0d31a4140befe124df0e3310d5d0fe71e39f33b0f
map
protected void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException
{    String document = value.toString();    document = StringEscapeUtils.unescapeHtml4(CLOSE_TEXT_TAG_PATTERN.matcher(OPEN_TEXT_TAG_PATTERN.matcher(document).replaceFirst("")).replaceAll(""));    String catMatch = findMatchingCategory(document);    if (!"Unknown".equals(catMatch)) {        StringBuilder contents = new StringBuilder(1000);        TokenStream stream = analyzer.tokenStream(catMatch, new StringReader(document));        CharTermAttribute termAtt = stream.addAttribute(CharTermAttribute.class);        stream.reset();        while (stream.incrementToken()) {            contents.append(termAtt.buffer(), 0, termAtt.length()).append(' ');        }        context.write(new Text(SPACE_NON_ALPHA_PATTERN.matcher(catMatch).replaceAll("_")), new Text(contents.toString()));        stream.end();        Closeables.close(stream, true);    }}
6b7dd49be7482fc8ee0fbe8bd0f24522f2a718c8c816a3d7b048fb4688eb6373
setup
protected void setup(Context context) throws IOException, InterruptedException
{    super.setup(context);    Configuration conf = context.getConfiguration();    if (inputCategories == null) {        Set<String> newCategories = new HashSet<>();        DefaultStringifier<Set<String>> setStringifier = new DefaultStringifier<>(conf, GenericsUtil.getClass(newCategories));        String categoriesStr = conf.get("wikipedia.categories", setStringifier.toString(newCategories));        Set<String> inputCategoriesSet = setStringifier.fromString(categoriesStr);        inputCategories = new ArrayList<>(inputCategoriesSet);        inputCategoryPatterns = new ArrayList<>(inputCategories.size());        for (String inputCategory : inputCategories) {            inputCategoryPatterns.add(Pattern.compile(".*\\b" + inputCategory + "\\b.*"));        }    }    exactMatchOnly = conf.getBoolean("exact.match.only", false);    if (analyzer == null) {        String analyzerStr = conf.get("analyzer.class", WikipediaAnalyzer.class.getName());        analyzer = ClassUtils.instantiateAs(analyzerStr, Analyzer.class);    }    log.info("Configure: Input Categories size: {} Exact Match: {} Analyzer: {}", inputCategories.size(), exactMatchOnly, analyzer.getClass().getName());}
efbb0cad48326f28ed9de18653eb5ae0b1ee3ca299e198def3412c62213caecd
findMatchingCategory
private String findMatchingCategory(String document)
{    int startIndex = 0;    int categoryIndex;    while ((categoryIndex = document.indexOf("[[Category:", startIndex)) != -1) {        categoryIndex += 11;        int endIndex = document.indexOf("]]", categoryIndex);        if (endIndex >= document.length() || endIndex < 0) {            break;        }        String category = document.substring(categoryIndex, endIndex).toLowerCase(Locale.ENGLISH).trim();                if (exactMatchOnly && inputCategories.contains(category)) {            return category;        }        if (!exactMatchOnly) {            for (int i = 0; i < inputCategories.size(); i++) {                String inputCategory = inputCategories.get(i);                Pattern inputCategoryPattern = inputCategoryPatterns.get(i);                if (inputCategoryPattern.matcher(category).matches()) {                                        return inputCategory;                }            }        }        startIndex = endIndex;    }    return "Unknown";}
bb6b14f43221693035f4f5f79d9e17e131ac14a5ab4095bd5fcbff2a940e2289
reduce
protected void reduce(Text key, Iterable<Text> values, Context context) throws IOException, InterruptedException
{        for (Text value : values) {        context.write(key, value);    }}
364372c8c0a17a2c3987e3f0d31a4140befe124df0e3310d5d0fe71e39f33b0f
map
protected void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException
{    String content = value.toString();    if (content.contains(REDIRECT)) {        return;    }    String document;    String title;    try {        document = getDocument(content);        title = getTitle(content);    } catch (RuntimeException e) {                return;    }    String catMatch = findMatchingCategory(document);    if (!all) {        if ("Unknown".equals(catMatch)) {            return;        }    }    document = StringEscapeUtils.unescapeHtml4(document);    if (removeLabels) {        document = removeCategoriesFromText(document);                if (document == null) {            return;        }    }        String category = "/" + catMatch.toLowerCase(Locale.ENGLISH) + "/" + SPACE_NON_ALPHA_PATTERN.matcher(title).replaceAll("_");    context.write(new Text(category), new Text(document));}
6b7dd49be7482fc8ee0fbe8bd0f24522f2a718c8c816a3d7b048fb4688eb6373
setup
protected void setup(Context context) throws IOException, InterruptedException
{    super.setup(context);    Configuration conf = context.getConfiguration();    Set<String> newCategories = new HashSet<>();    DefaultStringifier<Set<String>> setStringifier = new DefaultStringifier<>(conf, GenericsUtil.getClass(newCategories));    String categoriesStr = conf.get("wikipedia.categories");    inputCategories = setStringifier.fromString(categoriesStr);    exactMatchOnly = conf.getBoolean("exact.match.only", false);    all = conf.getBoolean("all.files", false);    removeLabels = conf.getBoolean("remove.labels", false);    log.info("Configure: Input Categories size: {} All: {} Exact Match: {} Remove Labels from Text: {}", inputCategories.size(), all, exactMatchOnly, removeLabels);}
b93645d5dee97216a31925333091ea225dcc01d874e8a10cbaaddf7eba8e0ce1
getDocument
private static String getDocument(String xml)
{    int start = xml.indexOf(START_DOC) + START_DOC.length();    int end = xml.indexOf(END_DOC, start);    return xml.substring(start, end);}
f9f2fa097ccfab70a35e4ca905072352aa0435ab978a801333ce3bd116928673
getTitle
private static String getTitle(CharSequence xml)
{    Matcher m = TITLE.matcher(xml);    return m.find() ? m.group(1) : "";}
efbb0cad48326f28ed9de18653eb5ae0b1ee3ca299e198def3412c62213caecd
findMatchingCategory
private String findMatchingCategory(String document)
{    int startIndex = 0;    int categoryIndex;    while ((categoryIndex = document.indexOf("[[Category:", startIndex)) != -1) {        categoryIndex += 11;        int endIndex = document.indexOf("]]", categoryIndex);        if (endIndex >= document.length() || endIndex < 0) {            break;        }        String category = document.substring(categoryIndex, endIndex).toLowerCase(Locale.ENGLISH).trim();        if (exactMatchOnly && inputCategories.contains(category)) {            return category.toLowerCase(Locale.ENGLISH);        }        if (!exactMatchOnly) {            for (String inputCategory : inputCategories) {                if (category.contains(inputCategory)) {                                        return inputCategory.toLowerCase(Locale.ENGLISH);                }            }        }        startIndex = endIndex;    }    return "Unknown";}
7b0adc0856eed25d308447a1bd9d3aafef560f39828a366ba5c451530db63744
removeCategoriesFromText
private String removeCategoriesFromText(String document)
{    int startIndex = 0;    int categoryIndex;    try {        while ((categoryIndex = document.indexOf("[[Category:", startIndex)) != -1) {            int endIndex = document.indexOf("]]", categoryIndex);            if (endIndex >= document.length() || endIndex < 0) {                break;            }            document = document.replace(document.substring(categoryIndex, endIndex + 2), "");            if (categoryIndex < document.length()) {                startIndex = categoryIndex;            } else {                break;            }        }    } catch (StringIndexOutOfBoundsException e) {        return null;    }    return document;}
365a24fc75086b6a0e91f9b072bd58c9280846cc05f333f28ede18388f27ce89
main
public static void main(String[] args) throws IOException
{    DefaultOptionBuilder obuilder = new DefaultOptionBuilder();    ArgumentBuilder abuilder = new ArgumentBuilder();    GroupBuilder gbuilder = new GroupBuilder();    Option dumpFileOpt = obuilder.withLongName("dumpFile").withRequired(true).withArgument(abuilder.withName("dumpFile").withMinimum(1).withMaximum(1).create()).withDescription("The path to the wikipedia dump file (.bz2 or uncompressed)").withShortName("d").create();    Option outputDirOpt = obuilder.withLongName("outputDir").withRequired(true).withArgument(abuilder.withName("outputDir").withMinimum(1).withMaximum(1).create()).withDescription("The output directory to place the splits in:\n" + "local files:\n\t/var/data/wikipedia-xml-chunks or\n\tfile:///var/data/wikipedia-xml-chunks\n" + "Hadoop DFS:\n\thdfs://wikipedia-xml-chunks\n" + "AWS S3 (blocks):\n\ts3://bucket-name/wikipedia-xml-chunks\n" + "AWS S3 (native files):\n\ts3n://bucket-name/wikipedia-xml-chunks\n").withShortName("o").create();    Option s3IdOpt = obuilder.withLongName("s3ID").withRequired(false).withArgument(abuilder.withName("s3Id").withMinimum(1).withMaximum(1).create()).withDescription("Amazon S3 ID key").withShortName("i").create();    Option s3SecretOpt = obuilder.withLongName("s3Secret").withRequired(false).withArgument(abuilder.withName("s3Secret").withMinimum(1).withMaximum(1).create()).withDescription("Amazon S3 secret key").withShortName("s").create();    Option chunkSizeOpt = obuilder.withLongName("chunkSize").withRequired(true).withArgument(abuilder.withName("chunkSize").withMinimum(1).withMaximum(1).create()).withDescription("The Size of the chunk, in megabytes").withShortName("c").create();    Option numChunksOpt = obuilder.withLongName("numChunks").withRequired(false).withArgument(abuilder.withName("numChunks").withMinimum(1).withMaximum(1).create()).withDescription("The maximum number of chunks to create.  If specified, program will only create a subset of the chunks").withShortName("n").create();    Group group = gbuilder.withName("Options").withOption(dumpFileOpt).withOption(outputDirOpt).withOption(chunkSizeOpt).withOption(numChunksOpt).withOption(s3IdOpt).withOption(s3SecretOpt).create();    Parser parser = new Parser();    parser.setGroup(group);    CommandLine cmdLine;    try {        cmdLine = parser.parse(args);    } catch (OptionException e) {        log.error("Error while parsing options", e);        CommandLineUtil.printHelp(group);        return;    }    Configuration conf = new Configuration();    String dumpFilePath = (String) cmdLine.getValue(dumpFileOpt);    String outputDirPath = (String) cmdLine.getValue(outputDirOpt);    if (cmdLine.hasOption(s3IdOpt)) {        String id = (String) cmdLine.getValue(s3IdOpt);        conf.set("fs.s3n.awsAccessKeyId", id);        conf.set("fs.s3.awsAccessKeyId", id);    }    if (cmdLine.hasOption(s3SecretOpt)) {        String secret = (String) cmdLine.getValue(s3SecretOpt);        conf.set("fs.s3n.awsSecretAccessKey", secret);        conf.set("fs.s3.awsSecretAccessKey", secret);    }        conf.set("fs.file.impl", "org.apache.hadoop.fs.RawLocalFileSystem");    FileSystem fs = FileSystem.get(URI.create(outputDirPath), conf);    int chunkSize = 1024 * 1024 * Integer.parseInt((String) cmdLine.getValue(chunkSizeOpt));    int numChunks = Integer.MAX_VALUE;    if (cmdLine.hasOption(numChunksOpt)) {        numChunks = Integer.parseInt((String) cmdLine.getValue(numChunksOpt));    }    String header = "<mediawiki xmlns=\"http://www.mediawiki.org/xml/export-0.3/\" " + "xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" " + "xsi:schemaLocation=\"http://www.mediawiki.org/xml/export-0.3/ " + "http://www.mediawiki.org/xml/export-0.3.xsd\" " + "version=\"0.3\" " + "xml:lang=\"en\">\n" + "  <siteinfo>\n" + "<sitename>Wikipedia</sitename>\n" + "    <base>http://en.wikipedia.org/wiki/Main_Page</base>\n" + "    <generator>MediaWiki 1.13alpha</generator>\n" + "    <case>first-letter</case>\n" + "    <namespaces>\n" + "      <namespace key=\"-2\">Media</namespace>\n" + "      <namespace key=\"-1\">Special</namespace>\n" + "      <namespace key=\"0\" />\n" + "      <namespace key=\"1\">Talk</namespace>\n" + "      <namespace key=\"2\">User</namespace>\n" + "      <namespace key=\"3\">User talk</namespace>\n" + "      <namespace key=\"4\">Wikipedia</namespace>\n" + "      <namespace key=\"5\">Wikipedia talk</namespace>\n" + "      <namespace key=\"6\">Image</namespace>\n" + "      <namespace key=\"7\">Image talk</namespace>\n" + "      <namespace key=\"8\">MediaWiki</namespace>\n" + "      <namespace key=\"9\">MediaWiki talk</namespace>\n" + "      <namespace key=\"10\">Template</namespace>\n" + "      <namespace key=\"11\">Template talk</namespace>\n" + "      <namespace key=\"12\">Help</namespace>\n" + "      <namespace key=\"13\">Help talk</namespace>\n" + "      <namespace key=\"14\">Category</namespace>\n" + "      <namespace key=\"15\">Category talk</namespace>\n" + "      <namespace key=\"100\">Portal</namespace>\n" + "      <namespace key=\"101\">Portal talk</namespace>\n" + "    </namespaces>\n" + "  </siteinfo>\n";    StringBuilder content = new StringBuilder();    content.append(header);    NumberFormat decimalFormatter = new DecimalFormat("0000");    File dumpFile = new File(dumpFilePath);        if (!dumpFile.exists()) {        log.error("Input file path {} doesn't exist", dumpFilePath);        return;    }    FileLineIterator it;    if (dumpFilePath.endsWith(".bz2")) {                CompressionCodec codec = new BZip2Codec();        it = new FileLineIterator(codec.createInputStream(new FileInputStream(dumpFile)));    } else {                it = new FileLineIterator(dumpFile);    }    int fileNumber = 0;    while (it.hasNext()) {        String thisLine = it.next();        if (thisLine.trim().startsWith("<page>")) {            boolean end = false;            while (!thisLine.trim().startsWith("</page>")) {                content.append(thisLine).append('\n');                if (it.hasNext()) {                    thisLine = it.next();                } else {                    end = true;                    break;                }            }            content.append(thisLine).append('\n');            if (content.length() > chunkSize || end) {                content.append("</mediawiki>");                fileNumber++;                String filename = outputDirPath + "/chunk-" + decimalFormatter.format(fileNumber) + ".xml";                try (BufferedWriter chunkWriter = new BufferedWriter(new OutputStreamWriter(fs.create(new Path(filename)), "UTF-8"))) {                    chunkWriter.write(content.toString(), 0, content.length());                }                if (fileNumber >= numChunks) {                    break;                }                content = new StringBuilder();                content.append(header);            }        }    }}
010e85f1b78319d13a7fcf35bd855ac1a9fd470d6304838ded5af95a2ff9274d
createRecordReader
public RecordReader<LongWritable, Text> createRecordReader(InputSplit split, TaskAttemptContext context)
{    try {        return new XmlRecordReader((FileSplit) split, context.getConfiguration());    } catch (IOException ioe) {        log.warn("Error while creating XmlRecordReader", ioe);        return null;    }}
41f7eae57624831c730e40ef581384e387914c3952d8f6bf254b3253f9f0a5c2
next
private boolean next(LongWritable key, Text value) throws IOException
{    if (fsin.getPos() < end && readUntilMatch(startTag, false)) {        try {            buffer.write(startTag);            if (readUntilMatch(endTag, true)) {                key.set(fsin.getPos());                value.set(buffer.getData(), 0, buffer.getLength());                return true;            }        } finally {            buffer.reset();        }    }    return false;}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    Closeables.close(fsin, true);}
46dc59cbf7e4d6aafe0869ef2726ed2c5c897b673d9e37f94ab9b0e962f65f7f
getProgress
public float getProgress() throws IOException
{    return (fsin.getPos() - start) / (float) (end - start);}
a074ac0fca06283041b68f195b44da7f08c6ec0267c3f11d5991720b420de5ac
readUntilMatch
private boolean readUntilMatch(byte[] match, boolean withinBlock) throws IOException
{    int i = 0;    while (true) {        int b = fsin.read();                if (b == -1) {            return false;        }                if (withinBlock) {            buffer.write(b);        }                if (b == match[i]) {            i++;            if (i >= match.length) {                return true;            }        } else {            i = 0;        }                if (!withinBlock && i == 0 && fsin.getPos() >= end) {            return false;        }    }}
f256c5e9d321134901fb8600508627335d6a026de71583ab0eb26e4a2635b78e
getCurrentKey
public LongWritable getCurrentKey() throws IOException, InterruptedException
{    return currentKey;}
f6d8d1abcefc4493619152f236f7a4d33a2247264a0982abe865a5737bed16bd
getCurrentValue
public Text getCurrentValue() throws IOException, InterruptedException
{    return currentValue;}
9d0cf270b93b06f7b05e0b26685b605f12e030ebd482ce0d8a319c619269541a
initialize
public void initialize(InputSplit split, TaskAttemptContext context) throws IOException, InterruptedException
{}
ea3a7eba5daf72a5cdc712e0c558af9956bcee4d2482e651bd64ac1a2c167657
nextKeyValue
public boolean nextKeyValue() throws IOException, InterruptedException
{    currentKey = new LongWritable();    currentValue = new Text();    return next(currentKey, currentValue);}
365a24fc75086b6a0e91f9b072bd58c9280846cc05f333f28ede18388f27ce89
main
public static void main(String[] args) throws IOException
{    DefaultOptionBuilder obuilder = new DefaultOptionBuilder();    ArgumentBuilder abuilder = new ArgumentBuilder();    GroupBuilder gbuilder = new GroupBuilder();    Option dirInputPathOpt = DefaultOptionCreator.inputOption().create();    Option dirOutputPathOpt = DefaultOptionCreator.outputOption().create();    Option categoriesOpt = obuilder.withLongName("categories").withArgument(abuilder.withName("categories").withMinimum(1).withMaximum(1).create()).withDescription("Location of the categories file.  One entry per line. " + "Will be used to make a string match in Wikipedia Category field").withShortName("c").create();    Option exactMatchOpt = obuilder.withLongName("exactMatch").withDescription("If set, then the category name must exactly match the " + "entry in the categories file. Default is false").withShortName("e").create();    Option allOpt = obuilder.withLongName("all").withDescription("If set, Select all files. Default is false").withShortName("all").create();    Option removeLabelOpt = obuilder.withLongName("removeLabels").withDescription("If set, remove [[Category:labels]] from document text after extracting label." + "Default is false").withShortName("rl").create();    Option helpOpt = DefaultOptionCreator.helpOption();    Group group = gbuilder.withName("Options").withOption(categoriesOpt).withOption(dirInputPathOpt).withOption(dirOutputPathOpt).withOption(exactMatchOpt).withOption(allOpt).withOption(helpOpt).withOption(removeLabelOpt).create();    Parser parser = new Parser();    parser.setGroup(group);    parser.setHelpOption(helpOpt);    try {        CommandLine cmdLine = parser.parse(args);        if (cmdLine.hasOption(helpOpt)) {            CommandLineUtil.printHelp(group);            return;        }        String inputPath = (String) cmdLine.getValue(dirInputPathOpt);        String outputPath = (String) cmdLine.getValue(dirOutputPathOpt);        String catFile = "";        if (cmdLine.hasOption(categoriesOpt)) {            catFile = (String) cmdLine.getValue(categoriesOpt);        }        boolean all = false;        if (cmdLine.hasOption(allOpt)) {            all = true;        }        boolean removeLabels = false;        if (cmdLine.hasOption(removeLabelOpt)) {            removeLabels = true;        }        runJob(inputPath, outputPath, catFile, cmdLine.hasOption(exactMatchOpt), all, removeLabels);    } catch (OptionException | InterruptedException | ClassNotFoundException e) {        log.error("Exception", e);        CommandLineUtil.printHelp(group);    }}
d95c51f85edba8cffa6dfe3d170005359ce622cefbd35c7ea5147d762bde3307
runJob
public static void runJob(String input, String output, String catFile, boolean exactMatchOnly, boolean all, boolean removeLabels) throws IOException, InterruptedException, ClassNotFoundException
{    Configuration conf = new Configuration();    conf.set("xmlinput.start", "<page>");    conf.set("xmlinput.end", "</page>");    conf.setBoolean("exact.match.only", exactMatchOnly);    conf.setBoolean("all.files", all);    conf.setBoolean("remove.labels", removeLabels);    conf.set("io.serializations", "org.apache.hadoop.io.serializer.JavaSerialization," + "org.apache.hadoop.io.serializer.WritableSerialization");    Set<String> categories = new HashSet<>();    if (!catFile.isEmpty()) {        for (String line : new FileLineIterable(new File(catFile))) {            categories.add(line.trim().toLowerCase(Locale.ENGLISH));        }    }    Stringifier<Set<String>> setStringifier = new DefaultStringifier<>(conf, GenericsUtil.getClass(categories));    String categoriesStr = setStringifier.toString(categories);    conf.set("wikipedia.categories", categoriesStr);    Job job = new Job(conf);    log.info("Input: {} Out: {} Categories: {} All Files: {}", input, output, catFile, all);    job.setOutputKeyClass(Text.class);    job.setOutputValueClass(Text.class);    FileInputFormat.setInputPaths(job, new Path(input));    Path outPath = new Path(output);    FileOutputFormat.setOutputPath(job, outPath);    job.setMapperClass(WikipediaMapper.class);    job.setInputFormatClass(XmlInputFormat.class);    job.setReducerClass(Reducer.class);    job.setOutputFormatClass(SequenceFileOutputFormat.class);    job.setJarByClass(WikipediaToSequenceFile.class);    /*     * conf.set("mapred.compress.map.output", "true"); conf.set("mapred.map.output.compression.type",     * "BLOCK"); conf.set("mapred.output.compress", "true"); conf.set("mapred.output.compression.type",     * "BLOCK"); conf.set("mapred.output.compression.codec", "org.apache.hadoop.io.compress.GzipCodec");     */    HadoopUtil.delete(conf, outPath);    boolean succeeded = job.waitForCompletion(true);    if (!succeeded) {        throw new IllegalStateException("Job failed!");    }}
028559132eab778aa300262c3faaa1a8238e0d9e027789e7f5bce91b68ab756e
scale
 static int scale(double value, double base)
{    double scale = value / base;        int i = 0;    while (i < BUMPS.length - 1 && BUMPS[i + 1] <= scale) {        i++;    }    return BUMPS[i];}
1df7037464d0043a6d4eb49ba0c7f7d77e7f63a84b777cb98fecd4232733c3f4
base
 static long base(double value)
{    return Math.max(1, (long) Math.pow(10, (int) Math.floor(Math.log10(value))));}
3f016d907d06b30ac0dd33eed6c917ae74246f488b2edb53fd507be1642ad11d
increment
public long increment()
{    long delta;    if (counter >= 10) {        long base = base(counter / 4.0);        int scale = scale(counter / 4.0, base);        delta = base * scale;    } else {        delta = 1;    }    counter += delta;    return counter;}
92767b42f60a36945099ae009f0199f47289a68c26fa2ed8553699470fff0d6b
getWriter
protected Writer getWriter()
{    return writer;}
c8cc8009513075b0a742827aa337c891aa8557d97d7804cd5aaf27b1e2753044
getClusterIdToPoints
protected Map<Integer, List<WeightedPropertyVectorWritable>> getClusterIdToPoints()
{    return clusterIdToPoints;}
c8632ffc6d0a43f90dae54a106a33c194d8ff40207e1110e3009363b1809d1dc
getTopFeatures
public static String getTopFeatures(Vector vector, String[] dictionary, int numTerms)
{    StringBuilder sb = new StringBuilder(100);    for (Pair<String, Double> item : getTopPairs(vector, dictionary, numTerms)) {        String term = item.getFirst();        sb.append("\n\t\t");        sb.append(StringUtils.rightPad(term, 40));        sb.append("=>");        sb.append(StringUtils.leftPad(item.getSecond().toString(), 20));    }    return sb.toString();}
08b2ee2a3bd91b54bd33a76c9664652097541de003cf41acfb799cb3972af0fe
getTopTerms
public static String getTopTerms(Vector vector, String[] dictionary, int numTerms)
{    StringBuilder sb = new StringBuilder(100);    for (Pair<String, Double> item : getTopPairs(vector, dictionary, numTerms)) {        String term = item.getFirst();        sb.append(term).append('_');    }    sb.deleteCharAt(sb.length() - 1);    return sb.toString();}
7dc756c6728bd9e3d61d55c85a5cccbb7e6bcf9e947cbb38fb48f9b764ddd3db
write
public long write(Iterable<ClusterWritable> iterable) throws IOException
{    return write(iterable, Long.MAX_VALUE);}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    writer.close();}
e65a7f303438486999aa71aeb24eac0fe08217d6b3773fd12e49fc287e6f967d
write
public long write(Iterable<ClusterWritable> iterable, long maxDocs) throws IOException
{    long result = 0;    Iterator<ClusterWritable> iterator = iterable.iterator();    while (result < maxDocs && iterator.hasNext()) {        write(iterator.next());        result++;    }    return result;}
be3f59c7ac32bdec985131b894aa7d11a23c3713f2912e5fb141ede0ca587325
getTopPairs
private static Collection<Pair<String, Double>> getTopPairs(Vector vector, String[] dictionary, int numTerms)
{    List<TermIndexWeight> vectorTerms = Lists.newArrayList();    for (Vector.Element elt : vector.nonZeroes()) {        vectorTerms.add(new TermIndexWeight(elt.index(), elt.get()));    }        Collections.sort(vectorTerms, new Comparator<TermIndexWeight>() {        @Override        public int compare(TermIndexWeight one, TermIndexWeight two) {            return Double.compare(two.weight, one.weight);        }    });    Collection<Pair<String, Double>> topTerms = Lists.newLinkedList();    for (int i = 0; i < vectorTerms.size() && i < numTerms; i++) {        int index = vectorTerms.get(i).index;        String dictTerm = dictionary[index];        if (dictTerm == null) {            log.error("Dictionary entry missing for {}", index);            continue;        }        topTerms.add(new Pair<>(dictTerm, vectorTerms.get(i).weight));    }    return topTerms;}
bbd7cd15f73555adb31c5773497700b851252e01130de01a09c729bd40071631
compare
public int compare(TermIndexWeight one, TermIndexWeight two)
{    return Double.compare(two.weight, one.weight);}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    new ClusterDumper().run(args);}
aacecb0f01750d985b78d806dc3c134f0da79efe2752957e0f93ecf5cbf9e492
run
public int run(String[] args) throws Exception
{    addInputOption();    addOutputOption();    addOption(OUTPUT_FORMAT_OPT, "of", "The optional output format for the results.  Options: TEXT, CSV, JSON or GRAPH_ML", "TEXT");    addOption(SUBSTRING_OPTION, "b", "The number of chars of the asFormatString() to print");    addOption(NUM_WORDS_OPTION, "n", "The number of top terms to print");    addOption(POINTS_DIR_OPTION, "p", "The directory containing points sequence files mapping input vectors to their cluster.  " + "If specified, then the program will output the points associated with a cluster");    addOption(SAMPLE_POINTS, "sp", "Specifies the maximum number of points to include _per_ cluster.  The default " + "is to include all points");    addOption(DICTIONARY_OPTION, "d", "The dictionary file");    addOption(DICTIONARY_TYPE_OPTION, "dt", "The dictionary file type (text|sequencefile)", "text");    addOption(buildOption(EVALUATE_CLUSTERS, "e", "Run ClusterEvaluator and CDbwEvaluator over the input.  " + "The output will be appended to the rest of the output at the end.", false, false, null));    addOption(DefaultOptionCreator.distanceMeasureOption().create());        if (parseArguments(args, false, true) == null) {        return -1;    }    seqFileDir = getInputPath();    if (hasOption(POINTS_DIR_OPTION)) {        pointsDir = new Path(getOption(POINTS_DIR_OPTION));    }    outputFile = getOutputFile();    if (hasOption(SUBSTRING_OPTION)) {        int sub = Integer.parseInt(getOption(SUBSTRING_OPTION));        if (sub >= 0) {            subString = sub;        }    }    termDictionary = getOption(DICTIONARY_OPTION);    dictionaryFormat = getOption(DICTIONARY_TYPE_OPTION);    if (hasOption(NUM_WORDS_OPTION)) {        numTopFeatures = Integer.parseInt(getOption(NUM_WORDS_OPTION));    }    if (hasOption(OUTPUT_FORMAT_OPT)) {        outputFormat = OUTPUT_FORMAT.valueOf(getOption(OUTPUT_FORMAT_OPT));    }    if (hasOption(SAMPLE_POINTS)) {        maxPointsPerCluster = Long.parseLong(getOption(SAMPLE_POINTS));    } else {        maxPointsPerCluster = Long.MAX_VALUE;    }    runEvaluation = hasOption(EVALUATE_CLUSTERS);    String distanceMeasureClass = getOption(DefaultOptionCreator.DISTANCE_MEASURE_OPTION);    measure = ClassUtils.instantiateAs(distanceMeasureClass, DistanceMeasure.class);    init();    printClusters(null);    return 0;}
fb8180dd4651080b7a323a44767eebb7b9ff946c17a89e4145f25cb6f131f09d
printClusters
public void printClusters(String[] dictionary) throws Exception
{    Configuration conf = new Configuration();    if (this.termDictionary != null) {        if ("text".equals(dictionaryFormat)) {            dictionary = VectorHelper.loadTermDictionary(new File(this.termDictionary));        } else if ("sequencefile".equals(dictionaryFormat)) {            dictionary = VectorHelper.loadTermDictionary(conf, this.termDictionary);        } else {            throw new IllegalArgumentException("Invalid dictionary format");        }    }    Writer writer;    boolean shouldClose;    if (this.outputFile == null) {        shouldClose = false;        writer = new OutputStreamWriter(System.out, Charsets.UTF_8);    } else {        shouldClose = true;        if (outputFile.getName().startsWith("s3n://")) {            Path p = outputPath;            FileSystem fs = FileSystem.get(p.toUri(), conf);            writer = new OutputStreamWriter(fs.create(p), Charsets.UTF_8);        } else {            Files.createParentDirs(outputFile);            writer = Files.newWriter(this.outputFile, Charsets.UTF_8);        }    }    ClusterWriter clusterWriter = createClusterWriter(writer, dictionary);    try {        long numWritten = clusterWriter.write(new SequenceFileDirValueIterable<ClusterWritable>(new Path(seqFileDir, "part-*"), PathType.GLOB, conf));        writer.flush();        if (runEvaluation) {            HadoopUtil.delete(conf, new Path("tmp/representative"));            int numIters = 5;            RepresentativePointsDriver.main(new String[] { "--input", seqFileDir.toString(), "--output", "tmp/representative", "--clusteredPoints", pointsDir.toString(), "--distanceMeasure", measure.getClass().getName(), "--maxIter", String.valueOf(numIters) });            conf.set(RepresentativePointsDriver.DISTANCE_MEASURE_KEY, measure.getClass().getName());            conf.set(RepresentativePointsDriver.STATE_IN_KEY, "tmp/representative/representativePoints-" + numIters);            ClusterEvaluator ce = new ClusterEvaluator(conf, seqFileDir);            writer.append("\n");            writer.append("Inter-Cluster Density: ").append(String.valueOf(ce.interClusterDensity())).append("\n");            writer.append("Intra-Cluster Density: ").append(String.valueOf(ce.intraClusterDensity())).append("\n");            CDbwEvaluator cdbw = new CDbwEvaluator(conf, seqFileDir);            writer.append("CDbw Inter-Cluster Density: ").append(String.valueOf(cdbw.interClusterDensity())).append("\n");            writer.append("CDbw Intra-Cluster Density: ").append(String.valueOf(cdbw.intraClusterDensity())).append("\n");            writer.append("CDbw Separation: ").append(String.valueOf(cdbw.separation())).append("\n");            writer.flush();        }        log.info("Wrote {} clusters", numWritten);    } finally {        if (shouldClose) {            Closeables.close(clusterWriter, false);        } else {            if (clusterWriter instanceof GraphMLClusterWriter) {                clusterWriter.close();            }        }    }}
7b6827d674509ff844c1863fdadeeebcf09d74bd6381a7d07726064dcc5b11c3
createClusterWriter
 ClusterWriter createClusterWriter(Writer writer, String[] dictionary) throws IOException
{    ClusterWriter result;    switch(outputFormat) {        case TEXT:            result = new ClusterDumperWriter(writer, clusterIdToPoints, measure, numTopFeatures, dictionary, subString);            break;        case CSV:            result = new CSVClusterWriter(writer, clusterIdToPoints, measure);            break;        case GRAPH_ML:            result = new GraphMLClusterWriter(writer, clusterIdToPoints, measure, numTopFeatures, dictionary, subString);            break;        case JSON:            result = new JsonClusterWriter(writer, clusterIdToPoints, measure, numTopFeatures, dictionary);            break;        default:            throw new IllegalStateException("Unknown outputformat: " + outputFormat);    }    return result;}
ebd5118f61dfe109c9cb75273de02d495a3aea07910ab4e1047c5dcdfecc5651
setOutputFormat
public void setOutputFormat(OUTPUT_FORMAT of)
{    outputFormat = of;}
d4ed25ac8ad321cf30617caf76c4576654e12017af8058c0917f5c720521f0ec
init
private void init()
{    if (this.pointsDir != null) {        Configuration conf = new Configuration();                clusterIdToPoints = readPoints(this.pointsDir, maxPointsPerCluster, conf);    } else {        clusterIdToPoints = Collections.emptyMap();    }}
96c6bc5ccbaef913a7a580a493806336344f9e4dd833509a2509059c8e2c020e
getSubString
public int getSubString()
{    return subString;}
2ffbf19b90b260380f4b172aa52114c468cf3adcb97de087dc10c0a86ec21c6d
setSubString
public void setSubString(int subString)
{    this.subString = subString;}
d2e32e5e617c9061f146f276350a295ae033b58d8fd8058150a0a822e2b1f40d
getClusterIdToPoints
public Map<Integer, List<WeightedPropertyVectorWritable>> getClusterIdToPoints()
{    return clusterIdToPoints;}
b096a58d73c93726b137358a4a7aa3f29cb543f70a4f2569b6e698c57709f996
getTermDictionary
public String getTermDictionary()
{    return termDictionary;}
e4f2c826ac823be140c447044f9172e03f3030a0fa40ce03871296ad96b6ff92
setTermDictionary
public void setTermDictionary(String termDictionary, String dictionaryType)
{    this.termDictionary = termDictionary;    this.dictionaryFormat = dictionaryType;}
1d2adda599ee8af2a7e3d6e832bd15cf4b2781ff4d5ac03a9acb596920863624
setNumTopFeatures
public void setNumTopFeatures(int num)
{    this.numTopFeatures = num;}
1e46b1d2e717c364110956ff6dff554504990157c3bb335774c6f1011bd8ab75
getNumTopFeatures
public int getNumTopFeatures()
{    return this.numTopFeatures;}
1a9178b11cbf3fac92b6de89d914b68ecd2623434c8d8b4d2a44d8602f7469dc
getMaxPointsPerCluster
public long getMaxPointsPerCluster()
{    return maxPointsPerCluster;}
5fe25988d0c94cef1c0cd056be0be35ebb5c5c84d524b6144ea0004c05e43418
setMaxPointsPerCluster
public void setMaxPointsPerCluster(long maxPointsPerCluster)
{    this.maxPointsPerCluster = maxPointsPerCluster;}
d3559ae5079c8cdaf7fe061516ae00c10c84c859c9f15066090e2e81c349dd1e
readPoints
public static Map<Integer, List<WeightedPropertyVectorWritable>> readPoints(Path pointsPathDir, long maxPointsPerCluster, Configuration conf)
{    Map<Integer, List<WeightedPropertyVectorWritable>> result = new TreeMap<>();    for (Pair<IntWritable, WeightedPropertyVectorWritable> record : new SequenceFileDirIterable<IntWritable, WeightedPropertyVectorWritable>(pointsPathDir, PathType.LIST, PathFilters.logsCRCFilter(), conf)) {                                int keyValue = record.getFirst().get();        List<WeightedPropertyVectorWritable> pointList = result.get(keyValue);        if (pointList == null) {            pointList = new ArrayList<>();            result.put(keyValue, pointList);        }        if (pointList.size() < maxPointsPerCluster) {            pointList.add(record.getSecond());        }    }    return result;}
08fa56984c97c9920f67675efa8f400ff9d3cc73e3302778536609bb53b481db
write
public void write(ClusterWritable clusterWritable) throws IOException
{    Cluster cluster = clusterWritable.getValue();    String fmtStr = cluster.asFormatString(dictionary);    Writer writer = getWriter();    if (subString > 0 && fmtStr.length() > subString) {        writer.write(':');        writer.write(fmtStr, 0, Math.min(subString, fmtStr.length()));    } else {        writer.write(fmtStr);    }    writer.write('\n');    if (dictionary != null) {        String topTerms = getTopFeatures(clusterWritable.getValue().getCenter(), dictionary, numTopFeatures);        writer.write("\tTop Terms: ");        writer.write(topTerms);        writer.write('\n');    }    Map<Integer, List<WeightedPropertyVectorWritable>> clusterIdToPoints = getClusterIdToPoints();    List<WeightedPropertyVectorWritable> points = clusterIdToPoints.get(clusterWritable.getValue().getId());    if (points != null) {        writer.write("\tWeight : [props - optional]:  Point:\n\t");        for (Iterator<WeightedPropertyVectorWritable> iterator = points.iterator(); iterator.hasNext(); ) {            WeightedPropertyVectorWritable point = iterator.next();            writer.write(String.valueOf(point.getWeight()));            Map<Text, Text> map = point.getProperties();                        writer.write(" : [");            if (map != null) {                for (Map.Entry<Text, Text> entry : map.entrySet()) {                    writer.write(entry.getKey().toString());                    writer.write("=");                    writer.write(entry.getValue().toString());                }            }            writer.write("]");            writer.write(": ");            writer.write(AbstractCluster.formatVector(point.getVector(), dictionary));            if (iterator.hasNext()) {                writer.write("\n\t");            }        }        writer.write('\n');    }}
08fa56984c97c9920f67675efa8f400ff9d3cc73e3302778536609bb53b481db
write
public void write(ClusterWritable clusterWritable) throws IOException
{    StringBuilder line = new StringBuilder();    Cluster cluster = clusterWritable.getValue();    line.append(cluster.getId());    List<WeightedPropertyVectorWritable> points = getClusterIdToPoints().get(cluster.getId());    if (points != null) {        for (WeightedPropertyVectorWritable point : points) {            Vector theVec = point.getVector();            line.append(',');            if (theVec instanceof NamedVector) {                line.append(((NamedVector) theVec).getName());            } else {                String vecStr = theVec.asFormatString();                                vecStr = VEC_PATTERN.matcher(vecStr).replaceAll("_");                line.append(vecStr);            }        }        getWriter().append(line).append("\n");    }}
670579b3bf0bff55095d2e3d9db3aee618cc06b9719c884cc361766c53439c95
init
private void init(Writer writer) throws IOException
{    writer.append("<?xml version=\"1.0\" encoding=\"UTF-8\"?>");    writer.append("<graphml xmlns=\"http://graphml.graphdrawing.org/xmlns\"\n" + "xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n" + "xsi:schemaLocation=\"http://graphml.graphdrawing.org/xmlns\n" + "http://graphml.graphdrawing.org/xmlns/1.0/graphml.xsd\">");        writer.append("<key attr.name=\"r\" attr.type=\"int\" for=\"node\" id=\"r\"/>\n" + "<key attr.name=\"g\" attr.type=\"int\" for=\"node\" id=\"g\"/>\n" + "<key attr.name=\"b\" attr.type=\"int\" for=\"node\" id=\"b\"/>" + "<key attr.name=\"size\" attr.type=\"int\" for=\"node\" id=\"size\"/>" + "<key attr.name=\"weight\" attr.type=\"float\" for=\"edge\" id=\"weight\"/>" + "<key attr.name=\"x\" attr.type=\"float\" for=\"node\" id=\"x\"/>" + "<key attr.name=\"y\" attr.type=\"float\" for=\"node\" id=\"y\"/>");    writer.append("<graph edgedefault=\"undirected\">");    lastClusterColor = new Color();    posStep = (int) (0.1 * clusterIdToPoints.size()) + 100;    random = RandomUtils.getRandom();}
08fa56984c97c9920f67675efa8f400ff9d3cc73e3302778536609bb53b481db
write
public void write(ClusterWritable clusterWritable) throws IOException
{    StringBuilder line = new StringBuilder();    Cluster cluster = clusterWritable.getValue();    Color rgb = getColor(cluster.getId());    String topTerms = "";    if (dictionary != null) {        topTerms = getTopTerms(cluster.getCenter(), dictionary, numTopFeatures);    }    String clusterLabel = String.valueOf(cluster.getId()) + '_' + topTerms;            float x = lastX + 1000;    float y = lastY;    if (x > (1000 + posStep)) {        y = lastY + 1000;        x = 0;    }    line.append(createNode(clusterLabel, rgb, x, y));    List<WeightedPropertyVectorWritable> points = clusterIdToPoints.get(cluster.getId());    if (points != null) {        for (WeightedVectorWritable point : points) {            Vector theVec = point.getVector();            double distance = 1;            if (measure != null) {                                distance = measure.distance(cluster.getCenter().getLengthSquared(), cluster.getCenter(), theVec) * 500;            }            String vecStr;                        int angle = random.nextInt(360);            double angleRads = Math.toRadians(angle);            float targetX = x + (float) (distance * Math.cos(angleRads));            float targetY = y + (float) (distance * Math.sin(angleRads));            if (theVec instanceof NamedVector) {                vecStr = ((NamedVector) theVec).getName();            } else {                vecStr = theVec.asFormatString();                                vecStr = VEC_PATTERN.matcher(vecStr).replaceAll("_");            }            if (subString > 0 && vecStr.length() > subString) {                vecStr = vecStr.substring(0, subString);            }            line.append(createNode(vecStr, rgb, targetX, targetY));            line.append(createEdge(clusterLabel, vecStr, distance));        }    }    lastClusterColor = rgb;    lastX = x;    lastY = y;    getWriter().append(line).append("\n");}
c039233fd2321f2943ec8a6ca109dd6b714e378582ffb8a7ca33d7a36ac64e19
getColor
private Color getColor(int clusterId)
{    Color result = colors.get(clusterId);    if (result == null) {        result = new Color();                int incR = 0;        int incG = 0;        int incB = 0;        if (lastClusterColor.r + 20 < 256 && lastClusterColor.g + 20 < 256 && lastClusterColor.b + 20 < 256) {            incR = 20;            incG = 0;            incB = 0;        } else if (lastClusterColor.r + 20 >= 256 && lastClusterColor.g + 20 < 256 && lastClusterColor.b + 20 < 256) {            incG = 20;            incB = 0;        } else if (lastClusterColor.r + 20 >= 256 && lastClusterColor.g + 20 >= 256 && lastClusterColor.b + 20 < 256) {            incB = 20;        } else {            incR += 3;            incG += 3;            incR += 3;        }        result.r = (lastClusterColor.r + incR) % 256;        result.g = (lastClusterColor.g + incG) % 256;        result.b = (lastClusterColor.b + incB) % 256;        colors.put(clusterId, result);    }    return result;}
25cf9e612c0a98918852eecaf74fbdc5603647a6b5f8cd140a6991b03e44f473
createEdge
private static String createEdge(String left, String right, double distance)
{    left = StringUtils.escapeXML(left);    right = StringUtils.escapeXML(right);    return "<edge id=\"" + left + '_' + right + "\" source=\"" + left + "\" target=\"" + right + "\">" + "<data key=\"weight\">" + distance + "</data></edge>";}
71ec7e41bb7b689d74ce56489bedd786a2f5f0085ff72477ba2e6e44e7bee157
createNode
private static String createNode(String s, Color rgb, float x, float y)
{    return "<node id=\"" + StringUtils.escapeXML(s) + "\"><data key=\"r\">" + rgb.r + "</data>" + "<data key=\"g\">" + rgb.g + "</data>" + "<data key=\"b\">" + rgb.b + "</data>" + "<data key=\"x\">" + x + "</data>" + "<data key=\"y\">" + y + "</data>" + "</node>";}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    getWriter().append("</graph>").append("</graphml>");    super.close();}
08fa56984c97c9920f67675efa8f400ff9d3cc73e3302778536609bb53b481db
write
public void write(ClusterWritable clusterWritable) throws IOException
{    Map<String, Object> res = new HashMap<>();        if (dictionary != null) {        List<Object> topTerms = getTopFeaturesList(clusterWritable.getValue().getCenter(), dictionary, numTopFeatures);        res.put("top_terms", topTerms);    } else {        res.put("top_terms", new ArrayList<>());    }        Cluster cluster = clusterWritable.getValue();    res.put("cluster_id", cluster.getId());    if (dictionary != null) {        Map<String, Object> fmtStr = cluster.asJson(dictionary);        res.put("cluster", fmtStr);                List<Object> points = getPoints(cluster, dictionary);        res.put("points", points);    } else {        res.put("cluster", new HashMap<>());        res.put("points", new ArrayList<>());    }        Writer writer = getWriter();    writer.write(jxn.writeValueAsString(res) + "\n");}
2f00efb36e1c930520121ebafc06664ae0f06e13bf8689fe3f0845c16a3c2945
getTopFeaturesList
public List<Object> getTopFeaturesList(Vector vector, String[] dictionary, int numTerms)
{    List<TermIndexWeight> vectorTerms = new ArrayList<>();    for (Vector.Element elt : vector.nonZeroes()) {        vectorTerms.add(new TermIndexWeight(elt.index(), elt.get()));    }        Collections.sort(vectorTerms, new Comparator<TermIndexWeight>() {        @Override        public int compare(TermIndexWeight one, TermIndexWeight two) {            return Double.compare(two.weight, one.weight);        }    });    List<Object> topTerms = new ArrayList<>();    for (int i = 0; i < vectorTerms.size() && i < numTerms; i++) {        int index = vectorTerms.get(i).index;        String dictTerm = dictionary[index];        if (dictTerm == null) {            log.error("Dictionary entry missing for {}", index);            continue;        }        Map<String, Object> term_entry = new HashMap<>();        term_entry.put(dictTerm, vectorTerms.get(i).weight);        topTerms.add(term_entry);    }    return topTerms;}
bbd7cd15f73555adb31c5773497700b851252e01130de01a09c729bd40071631
compare
public int compare(TermIndexWeight one, TermIndexWeight two)
{    return Double.compare(two.weight, one.weight);}
b9a33019dea795dad2a77f8451704e46e401d9fce7051d41ef084f653715909f
getPoints
public List<Object> getPoints(Cluster cluster, String[] dictionary)
{    List<Object> vectorObjs = new ArrayList<>();    List<WeightedPropertyVectorWritable> points = getClusterIdToPoints().get(cluster.getId());    if (points != null) {        for (WeightedPropertyVectorWritable point : points) {            Map<String, Object> entry = new HashMap<>();            Vector theVec = point.getVector();            if (theVec instanceof NamedVector) {                entry.put("vector_name", ((NamedVector) theVec).getName());            } else {                String vecStr = theVec.asFormatString();                                vecStr = VEC_PATTERN.matcher(vecStr).replaceAll("_");                entry.put("vector_name", vecStr);            }            entry.put("weight", String.valueOf(point.getWeight()));            try {                entry.put("point", AbstractCluster.formatVectorAsJson(point.getVector(), dictionary));            } catch (IOException e) {                log.error("IOException:  ", e);            }            vectorObjs.add(entry);        }    }    return vectorObjs;}
da62d3c44b2f6dcc5bfa5f8fd9e7c28a7ce1d2b9860b72d886d3d9a552f8f605
getInput
public File getInput()
{    return input;}
af0bdbddf296bd0695eff0e0e79d9de4e72b25fa655d4b008b82a38b3d294192
setInput
public void setInput(File input)
{    this.input = input;}
fb5778a6c9371883e9958802e95a22a048d210718c37b905284e17a58a506d2b
getOutputDir
public String getOutputDir()
{    return outputDir;}
3dca522f0f4d2d8a4a767bd9f8ffe3f27c1d5332842c99c2733cda83590901be
setOutputDir
public void setOutputDir(String outputDir)
{    this.outputDir = outputDir;}
a45881c16ab9e38f31484f692ce1411b032f19370daab3e4040c1c04d984146f
getPrefix
public String getPrefix()
{    return prefix;}
986b751eaf577940c854e67a49219dafac29f3db10077ee2bab489e564829806
setPrefix
public void setPrefix(String prefix)
{    this.prefix = prefix;}
1b927d59e5fcddd5f03ad493add134c227feb9fe6131797fde28c00d16429400
getChunkSize
public int getChunkSize()
{    return chunkSize;}
18c6833787441e9265ae4d54b27f90bc59ce976932e7f240c1c18a03f123873e
setChunkSize
public void setChunkSize(int chunkSize)
{    this.chunkSize = chunkSize;}
62fdd366fb32662880f70100b38033d757466e1309c6257954c6fc4c8656df36
getCharset
public Charset getCharset()
{    return charset;}
3696ac717996317a8eab4bdaa0165aa3fe5c8ae6154932d23ee3ea5c0a18969f
setCharset
public void setCharset(Charset charset)
{    this.charset = charset;}
95f09a76973b743060855f286c7ef3946c166fb7077ce04157a35a27838a1958
getSeparator
public String getSeparator()
{    return separator;}
d4f40e1d223bf386b864ffd8be9419514b39d3cd6dc04fa74c610edbf1a1a1a9
setSeparator
public void setSeparator(String separator)
{    this.separator = separator;}
6b61b0b7a07bb98b1a4a7f4ce750ed2aa7c006224a321228c38af02853599ad9
getBodySeparator
public String getBodySeparator()
{    return bodySeparator;}
69515f9b42e9d5deeca805fb06251e84693fc2ebeebdd9ed26f442663e39215e
setBodySeparator
public void setBodySeparator(String bodySeparator)
{    this.bodySeparator = bodySeparator;}
11f058bbbc328fc2ad03e1cf167924dc3d1317380d13f262f12fb2060713d4dc
isIncludeBody
public boolean isIncludeBody()
{    return includeBody;}
33292a9a917896b0c9dab49639862bdbc0763ad7028375eaea42ed6aee30ed6f
setIncludeBody
public void setIncludeBody(boolean includeBody)
{    this.includeBody = includeBody;}
6371fe763a556872557f1b2bfc5867cb31f5c97d4f2b78dbec58b0712171a56c
getPatternsToMatch
public Pattern[] getPatternsToMatch()
{    return patternsToMatch;}
4cb8ddbf8e73c3565678601fb59fbbc668e882795382769b292de124d9d03495
setPatternsToMatch
public void setPatternsToMatch(Pattern[] patternsToMatch)
{    this.patternsToMatch = patternsToMatch;}
c9973d3ed8c04e323bda3ee151fc971ff97097c3c6a582ae9c7e40e27d4a97a7
getPatternOrder
public Map<String, Integer> getPatternOrder()
{    return patternOrder;}
3c45c33522b59bce4b58e4347b439ad795f3d9381389eb8d5a78d8aad761e356
setPatternOrder
public void setPatternOrder(Map<String, Integer> patternOrder)
{    this.patternOrder = patternOrder;}
b8522f41697c5813e4ab179fcc7bfe1e3d9530fe84b9562eb7a36c58653bb778
isStripQuotedText
public boolean isStripQuotedText()
{    return stripQuotedText;}
72ce6eb05670d30e77c09d223938541c7dfe52db2770b04edf4c2ad138339e7b
setStripQuotedText
public void setStripQuotedText(boolean stripQuotedText)
{    this.stripQuotedText = stripQuotedText;}
edeceb0855e0bb8092dfc7ffd465211fd261bd0358e24a4b40ff9de8bb6ea062
getQuotedTextPattern
public Pattern getQuotedTextPattern()
{    return quotedTextPattern;}
0e3b336ce39d26bb78e8c356403f6eb10718ceb2458234c7c84f27c69d25be3f
setQuotedTextPattern
public void setQuotedTextPattern(Pattern quotedTextPattern)
{    this.quotedTextPattern = quotedTextPattern;}
e0d6010500bbf9e3032a6c019bcb891ded96ffa4bca7fff1e4cb1c900fcfdd14
parseMboxLineByLine
public long parseMboxLineByLine(File mboxFile) throws IOException
{    long messageCount = 0;    try {        StringBuilder contents = new StringBuilder();                StringBuilder body = new StringBuilder();        Matcher messageIdMatcher = MESSAGE_ID_PREFIX.matcher("");        Matcher messageBoundaryMatcher = MESSAGE_START.matcher("");        String[] patternResults = new String[options.getPatternsToMatch().length];        Matcher[] matchers = new Matcher[options.getPatternsToMatch().length];        for (int i = 0; i < matchers.length; i++) {            matchers[i] = options.getPatternsToMatch()[i].matcher("");        }        String messageId = null;        boolean inBody = false;        Pattern quotedTextPattern = options.getQuotedTextPattern();        for (String nextLine : new FileLineIterable(mboxFile, options.getCharset(), false)) {            if (options.isStripQuotedText() && quotedTextPattern.matcher(nextLine).find()) {                continue;            }            for (int i = 0; i < matchers.length; i++) {                Matcher matcher = matchers[i];                matcher.reset(nextLine);                if (matcher.matches()) {                    patternResults[i] = matcher.group(1);                }            }                        if (messageId != null) {                                messageBoundaryMatcher.reset(nextLine);                if (messageBoundaryMatcher.matches()) {                                        String key = generateKey(mboxFile, prefix, messageId);                                        writeContent(options.getSeparator(), contents, body, patternResults);                    writer.write(key, contents.toString());                                        contents.setLength(0);                    body.setLength(0);                    messageId = null;                    inBody = false;                } else {                    if (inBody && options.isIncludeBody()) {                        if (!nextLine.isEmpty()) {                            body.append(nextLine).append(options.getBodySeparator());                        }                    } else {                                                                        inBody = nextLine.isEmpty();                    }                }            } else {                if (nextLine.length() > 14) {                    messageIdMatcher.reset(nextLine);                    if (messageIdMatcher.matches()) {                        messageId = messageIdMatcher.group(1);                        ++messageCount;                    }                }            }        }                if (messageId != null) {            String key = generateKey(mboxFile, prefix, messageId);            writeContent(options.getSeparator(), contents, body, patternResults);            writer.write(key, contents.toString());                        contents.setLength(0);        }    } catch (FileNotFoundException e) {                log.warn("Unable to process non-existing file", e);    }        return messageCount;}
1cefb37316eb7254e894c46c43a071b94fba218c86b048f67a72720e72b26ae3
generateKey
protected static String generateKey(File mboxFile, String prefix, String messageId)
{    return prefix + File.separator + mboxFile.getName() + File.separator + messageId;}
a45881c16ab9e38f31484f692ce1411b032f19370daab3e4040c1c04d984146f
getPrefix
public String getPrefix()
{    return prefix;}
f01f189b06d6b2b812e27fe7c73502b516935d185c0beb8f2f7593b3f44e669a
getOptions
public MailOptions getOptions()
{    return options;}
762edc020caac22c96146379313397a1ccaf0313c63a8f7bb3ea3d00d189d157
writeContent
private static void writeContent(String separator, StringBuilder contents, CharSequence body, String[] matches)
{    for (String match : matches) {        if (match != null) {            contents.append(match).append(separator);        } else {            contents.append(separator);        }    }    contents.append('\n').append(body);}
c6e87fa285e3329a962705747117616ef19aa2abd799c88e945eaf917b2ef362
write
public void write(String key, String value) throws IOException
{    writer.write(key, value);}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    writer.close();}
250f58c4cb85a8c24bf51b38fa64faa91f32fa77e24f71a5fc289d93fceb2d40
getPath
private Path getPath(int chunkID)
{    return new Path(output, "chunk-" + chunkID);}
c6e87fa285e3329a962705747117616ef19aa2abd799c88e945eaf917b2ef362
write
public void write(String key, String value) throws IOException
{    if (currentChunkSize > maxChunkSizeInBytes) {        Closeables.close(writer, false);        currentChunkID++;        writer = new SequenceFile.Writer(fs, conf, getPath(currentChunkID), Text.class, Text.class);        currentChunkSize = 0;    }    Text keyT = new Text(key);    Text valueT = new Text(value);        currentChunkSize += keyT.getBytes().length + valueT.getBytes().length;    writer.append(keyT, valueT);}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    Closeables.close(writer, false);}
c6e87fa285e3329a962705747117616ef19aa2abd799c88e945eaf917b2ef362
write
public void write(String key, String value) throws IOException
{    writer.write(key + ' ' + value);}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    writer.close();}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    ToolRunner.run(new MatrixDumper(), args);}
aacecb0f01750d985b78d806dc3c134f0da79efe2752957e0f93ecf5cbf9e492
run
public int run(String[] args) throws Exception
{    addInputOption();        addOption("output", "o", "Output path", null);    Map<String, List<String>> parsedArgs = parseArguments(args);    if (parsedArgs == null) {        return -1;    }    String outputFile = hasOption("output") ? getOption("output") : null;    exportCSV(getInputPath(), outputFile, false);    return 0;}
960f90d4fe95802ed46b2be0eab58b42388f4ebf613580e02900e7a010d9fde0
exportCSV
private static void exportCSV(Path inputPath, String outputFile, boolean doLabels) throws IOException
{    SequenceFileValueIterator<MatrixWritable> it = new SequenceFileValueIterator<>(inputPath, true, new Configuration());    Matrix m = it.next().get();    it.close();    PrintStream ps = getPrintStream(outputFile);    String[] columnLabels = getLabels(m.numCols(), m.getColumnLabelBindings(), "col");    String[] rowLabels = getLabels(m.numRows(), m.getRowLabelBindings(), "row");    if (doLabels) {        ps.print("rowid,");        ps.print(columnLabels[0]);        for (int c = 1; c < m.numCols(); c++) {            ps.print(',' + columnLabels[c]);        }        ps.println();    }    for (int r = 0; r < m.numRows(); r++) {        if (doLabels) {            ps.print(rowLabels[0] + ',');        }        ps.print(Double.toString(m.getQuick(r, 0)));        for (int c = 1; c < m.numCols(); c++) {            ps.print(",");            ps.print(Double.toString(m.getQuick(r, c)));        }        ps.println();    }    if (ps != System.out) {        ps.close();    }}
c7d71545b09e1ff2af01b4372fa8ec43347fa54ab1e07273f1f7a38a2396a550
getPrintStream
private static PrintStream getPrintStream(String outputPath) throws IOException
{    if (outputPath == null) {        return System.out;    }    File outputFile = new File(outputPath);    if (outputFile.exists()) {        outputFile.delete();    }    outputFile.createNewFile();    OutputStream os = new FileOutputStream(outputFile);    return new PrintStream(os, false, Charsets.UTF_8.displayName());}
1126e9dd082e9acfad767aeb3da919c8455e9ec082edf89df7ed5e0dedbb061b
getLabels
private static String[] getLabels(int length, Map<String, Integer> labels, String start)
{    if (labels != null) {        return sortLabels(labels);    }    String[] sorted = new String[length];    for (int i = 1; i <= length; i++) {        sorted[i] = start + i;    }    return sorted;}
4a21386ef46e43e5e58ae3beec3246b8a435416e680513e0b591d3d1447ece5d
sortLabels
private static String[] sortLabels(Map<String, Integer> labels)
{    String[] sorted = new String[labels.size()];    for (Map.Entry<String, Integer> entry : labels.entrySet()) {        sorted[entry.getValue()] = entry.getKey();    }    return sorted;}
119a91e8d4ac8c948ea68b33a0bbf4d67809efa6f275305a78976a6e8f9141a0
incrementToken
public boolean incrementToken() throws IOException
{    while (input.incrementToken()) {        ByteBuffer bytes = encoder.encode(CharBuffer.wrap(termAtt.buffer(), 0, termAtt.length()));        key.set(bytes.array(), 1.0f);        boolean member = filter.membershipTest(key);        if ((keepMembers && member) || (!keepMembers && !member)) {            return true;        }    }    return false;}
0d30eab4d11ce61b6fcf859a36bee3c2753fc3ea3c2ff2d8bf04993becfd17a5
transformMatch
public String transformMatch(String match)
{    StringBuilder result = new StringBuilder();    try (TokenStream ts = analyzer.tokenStream(fieldName, new StringReader(match))) {        ts.addAttribute(CharTermAttribute.class);        ts.reset();        TokenStreamIterator iter = new TokenStreamIterator(ts);        while (iter.hasNext()) {            result.append(iter.next()).append(' ');        }        ts.end();    } catch (IOException e) {        throw new IllegalStateException(e);    }    return result.toString();}
f60d42db46050515e20416c0823e1d27cb2854842e1a01dc6fe420a77af80144
getAnalyzer
public Analyzer getAnalyzer()
{    return analyzer;}
717b6c6a15d53f7c9a82b536a500dec328e695333a025e42a39bfe3414d2e7a7
setAnalyzer
public void setAnalyzer(Analyzer analyzer)
{    this.analyzer = analyzer;}
0d30eab4d11ce61b6fcf859a36bee3c2753fc3ea3c2ff2d8bf04993becfd17a5
transformMatch
public String transformMatch(String match)
{    String result = match;    for (RegexTransformer transformer : chain) {        result = transformer.transformMatch(result);    }    return result;}
6f073fc3385809aab6781538e35181ecc5417dd0471b24f2dae89ddbce38c70c
getChain
public List<RegexTransformer> getChain()
{    return chain;}
e4baf49e256d1a3a7463bd42fe1eb991e98c6bd77491030da0efb8ddfcad5c2d
setChain
public void setChain(List<RegexTransformer> chain)
{    this.chain = chain;}
6d206f35cbfca85bf058a7339c651899f09de4637db36382af581cff215a8069
format
public String format(String toFormat)
{    return '\t' + WHITESPACE.matcher(toFormat).replaceAll("|");}
6d206f35cbfca85bf058a7339c651899f09de4637db36382af581cff215a8069
format
public String format(String toFormat)
{    return toFormat;}
0d30eab4d11ce61b6fcf859a36bee3c2753fc3ea3c2ff2d8bf04993becfd17a5
transformMatch
public String transformMatch(String match)
{    return match;}
aacecb0f01750d985b78d806dc3c134f0da79efe2752957e0f93ecf5cbf9e492
run
public int run(String[] args) throws Exception
{    addInputOption();    addOutputOption();    addOption(DefaultOptionCreator.overwriteOption().create());    addOption("regex", "regex", "The regular expression to use", true);    addOption("groupsToKeep", "g", "The number of the capturing groups to keep", false);    addOption("transformerClass", "t", "The optional class specifying the Regex Transformer", false);    addOption("formatterClass", "t", "The optional class specifying the Regex Formatter", false);    addOption(DefaultOptionCreator.analyzerOption().create());    if (parseArguments(args) == null) {        return -1;    }    Configuration conf = getConf();            conf.set(RegexMapper.REGEX, getOption("regex"));    String gtk = getOption("groupsToKeep");    if (gtk != null) {        conf.set(RegexMapper.GROUP_MATCHERS, gtk);    }    String trans = getOption("transformerClass");    if (trans != null) {        if ("url".equalsIgnoreCase(trans)) {            trans = URLDecodeTransformer.class.getName();        }        conf.set(RegexMapper.TRANSFORMER_CLASS, trans);    }    String formatter = getOption("formatterClass");    if (formatter != null) {        if ("fpg".equalsIgnoreCase(formatter)) {            formatter = FPGFormatter.class.getName();        }        conf.set(RegexMapper.FORMATTER_CLASS, formatter);    }    Path input = getInputPath();    Path output = getOutputPath();    if (hasOption(DefaultOptionCreator.OVERWRITE_OPTION)) {        HadoopUtil.delete(getConf(), output);    }    Class<? extends Analyzer> analyzerClass = getAnalyzerClassFromOption();    if (analyzerClass != null) {        conf.set(RegexMapper.ANALYZER_NAME, analyzerClass.getName());    }    Job job = prepareJob(input, output, TextInputFormat.class, RegexMapper.class, LongWritable.class, Text.class, TextOutputFormat.class);    boolean succeeded = job.waitForCompletion(true);    return succeeded ? 0 : -1;}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    ToolRunner.run(new RegexConverterDriver(), args);}
6b7dd49be7482fc8ee0fbe8bd0f24522f2a718c8c816a3d7b048fb4688eb6373
setup
protected void setup(Context context) throws IOException, InterruptedException
{    groupsToKeep = new ArrayList<>();    Configuration config = context.getConfiguration();    String regexStr = config.get(REGEX);    regex = Pattern.compile(regexStr);    String[] groups = config.getStrings(GROUP_MATCHERS);    if (groups != null) {        for (String group : groups) {            groupsToKeep.add(Integer.parseInt(group));        }    }    transformer = ClassUtils.instantiateAs(config.get(TRANSFORMER_CLASS, IdentityTransformer.class.getName()), RegexTransformer.class);    String analyzerName = config.get(ANALYZER_NAME);    if (analyzerName != null && transformer instanceof AnalyzerTransformer) {        Analyzer analyzer = ClassUtils.instantiateAs(analyzerName, Analyzer.class);        ((AnalyzerTransformer) transformer).setAnalyzer(analyzer);    }    formatter = ClassUtils.instantiateAs(config.get(FORMATTER_CLASS, IdentityFormatter.class.getName()), RegexFormatter.class);}
6afe1c7ed6261a7e08994f083f7a5c5e7a8f44fd729bc4ef753ea446f313713e
map
protected void map(LongWritable key, Text text, Context context) throws IOException, InterruptedException
{    String result = RegexUtils.extract(text.toString(), regex, groupsToKeep, " ", transformer);    if (!result.isEmpty()) {        String format = formatter.format(result);        context.write(key, new Text(format));    }}
2ef8c5eab3dcb75732e99a89724971b1655d35b2934f3e82b7a0c697d79f89ac
extract
public static String extract(CharSequence line, Pattern pattern, Collection<Integer> groupsToKeep, String separator, RegexTransformer transformer)
{    StringBuilder bldr = new StringBuilder();    extract(line, bldr, pattern, groupsToKeep, separator, transformer);    return bldr.toString();}
482b66b4fb6171ed678c4b0b992cc8639338b2b031518be19e9d77a6132d8d4c
extract
public static void extract(CharSequence line, StringBuilder outputBuffer, Pattern pattern, Collection<Integer> groupsToKeep, String separator, RegexTransformer transformer)
{    if (transformer == null) {        transformer = IDENTITY_TRANSFORMER;    }    Matcher matcher = pattern.matcher(line);    String match;    if (groupsToKeep.isEmpty()) {        while (matcher.find()) {            match = matcher.group();            if (match != null) {                outputBuffer.append(transformer.transformMatch(match)).append(separator);            }        }    } else {        while (matcher.find()) {            for (Integer groupNum : groupsToKeep) {                match = matcher.group(groupNum);                if (match != null) {                    outputBuffer.append(transformer.transformMatch(match)).append(separator);                }            }        }    }        if (outputBuffer.length() > 0) {        outputBuffer.setLength(outputBuffer.length() - separator.length());    }}
0d30eab4d11ce61b6fcf859a36bee3c2753fc3ea3c2ff2d8bf04993becfd17a5
transformMatch
public String transformMatch(String match)
{    try {        return URLDecoder.decode(match, enc);    } catch (UnsupportedEncodingException e) {        throw new IllegalStateException(e);    }}
aacecb0f01750d985b78d806dc3c134f0da79efe2752957e0f93ecf5cbf9e492
run
public int run(String[] args) throws Exception
{    addInputOption();    addOutputOption();    addOption("substring", "b", "The number of chars to print out per value", false);    addOption(buildOption("count", "c", "Report the count only", false, false, null));    addOption("numItems", "n", "Output at most <n> key value pairs", false);    addOption(buildOption("facets", "fa", "Output the counts per key.  Note, if there are a lot of unique keys, " + "this can take up a fair amount of memory", false, false, null));    addOption(buildOption("quiet", "q", "Print only file contents.", false, false, null));    if (parseArguments(args, false, true) == null) {        return -1;    }    Path[] pathArr;    Configuration conf = new Configuration();    Path input = getInputPath();    FileSystem fs = input.getFileSystem(conf);    if (fs.getFileStatus(input).isDir()) {        pathArr = FileUtil.stat2Paths(fs.listStatus(input, PathFilters.logsCRCFilter()));    } else {        pathArr = new Path[1];        pathArr[0] = input;    }    Writer writer;    boolean shouldClose;    if (hasOption("output")) {        shouldClose = true;        writer = Files.newWriter(new File(getOption("output")), Charsets.UTF_8);    } else {        shouldClose = false;        writer = new OutputStreamWriter(System.out, Charsets.UTF_8);    }    try {        for (Path path : pathArr) {            if (!hasOption("quiet")) {                writer.append("Input Path: ").append(String.valueOf(path)).append('\n');            }            int sub = Integer.MAX_VALUE;            if (hasOption("substring")) {                sub = Integer.parseInt(getOption("substring"));            }            boolean countOnly = hasOption("count");            SequenceFileIterator<?, ?> iterator = new SequenceFileIterator<>(path, true, conf);            if (!hasOption("quiet")) {                writer.append("Key class: ").append(iterator.getKeyClass().toString());                writer.append(" Value Class: ").append(iterator.getValueClass().toString()).append('\n');            }            OpenObjectIntHashMap<String> facets = null;            if (hasOption("facets")) {                facets = new OpenObjectIntHashMap<>();            }            long count = 0;            if (countOnly) {                while (iterator.hasNext()) {                    Pair<?, ?> record = iterator.next();                    String key = record.getFirst().toString();                    if (facets != null) {                                                facets.adjustOrPutValue(key, 1, 1);                    }                    count++;                }                writer.append("Count: ").append(String.valueOf(count)).append('\n');            } else {                long numItems = Long.MAX_VALUE;                if (hasOption("numItems")) {                    numItems = Long.parseLong(getOption("numItems"));                    if (!hasOption("quiet")) {                        writer.append("Max Items to dump: ").append(String.valueOf(numItems)).append("\n");                    }                }                while (iterator.hasNext() && count < numItems) {                    Pair<?, ?> record = iterator.next();                    String key = record.getFirst().toString();                    writer.append("Key: ").append(key);                    String str = record.getSecond().toString();                    writer.append(": Value: ").append(str.length() > sub ? str.substring(0, sub) : str);                    writer.write('\n');                    if (facets != null) {                                                facets.adjustOrPutValue(key, 1, 1);                    }                    count++;                }                if (!hasOption("quiet")) {                    writer.append("Count: ").append(String.valueOf(count)).append('\n');                }            }            if (facets != null) {                List<String> keyList = new ArrayList<>(facets.size());                IntArrayList valueList = new IntArrayList(facets.size());                facets.pairsSortedByKey(keyList, valueList);                writer.append("-----Facets---\n");                writer.append("Key\t\tCount\n");                int i = 0;                for (String key : keyList) {                    writer.append(key).append("\t\t").append(String.valueOf(valueList.get(i++))).append('\n');                }            }        }        writer.flush();    } finally {        if (shouldClose) {            Closeables.close(writer, false);        }    }    return 0;}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    new SequenceFileDumper().run(args);}
aacecb0f01750d985b78d806dc3c134f0da79efe2752957e0f93ecf5cbf9e492
run
public int run(String[] args) throws Exception
{    if (parseArgs(args)) {        splitDirectory();    }    return 0;}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    ToolRunner.run(new Configuration(), new SplitInput(), args);}
c15005564df0b3c68565ee327eea49afd079345db290e80b3d862ca2730586fe
parseArgs
private boolean parseArgs(String[] args) throws Exception
{    addInputOption();    addOption("trainingOutput", "tr", "The training data output directory", false);    addOption("testOutput", "te", "The test data output directory", false);    addOption("testSplitSize", "ss", "The number of documents held back as test data for each category", false);    addOption("testSplitPct", "sp", "The % of documents held back as test data for each category", false);    addOption("splitLocation", "sl", "Location for start of test data expressed as a percentage of the input file " + "size (0=start, 50=middle, 100=end", false);    addOption("randomSelectionSize", "rs", "The number of items to be randomly selected as test data ", false);    addOption("randomSelectionPct", "rp", "Percentage of items to be randomly selected as test data when using " + "mapreduce mode", false);    addOption("charset", "c", "The name of the character encoding of the input files (not needed if using " + "SequenceFiles)", false);    addOption(buildOption("sequenceFiles", "seq", "Set if the input files are sequence files.  Default is false", false, false, "false"));    addOption(DefaultOptionCreator.methodOption().create());    addOption(DefaultOptionCreator.overwriteOption().create());        addOption("keepPct", "k", "The percentage of total data to keep in map-reduce mode, the rest will be ignored.  " + "Default is 100%", false);    addOption("mapRedOutputDir", "mro", "Output directory for map reduce jobs", false);    if (parseArguments(args) == null) {        return false;    }    try {        inputDirectory = getInputPath();        useMapRed = getOption(DefaultOptionCreator.METHOD_OPTION).equalsIgnoreCase(DefaultOptionCreator.MAPREDUCE_METHOD);        if (useMapRed) {            if (!hasOption("randomSelectionPct")) {                throw new OptionException(getCLIOption("randomSelectionPct"), "must set randomSelectionPct when mapRed option is used");            }            if (!hasOption("mapRedOutputDir")) {                throw new OptionException(getCLIOption("mapRedOutputDir"), "mapRedOutputDir must be set when mapRed option is used");            }            mapRedOutputDirectory = new Path(getOption("mapRedOutputDir"));            if (hasOption("keepPct")) {                keepPct = Integer.parseInt(getOption("keepPct"));            }            if (hasOption(DefaultOptionCreator.OVERWRITE_OPTION)) {                HadoopUtil.delete(getConf(), mapRedOutputDirectory);            }        } else {            if (!hasOption("trainingOutput") || !hasOption("testOutput")) {                throw new OptionException(getCLIOption("trainingOutput"), "trainingOutput and testOutput must be set if mapRed option is not used");            }            if (!hasOption("testSplitSize") && !hasOption("testSplitPct") && !hasOption("randomSelectionPct") && !hasOption("randomSelectionSize")) {                throw new OptionException(getCLIOption("testSplitSize"), "must set one of test split size/percentage or randomSelectionSize/percentage");            }            trainingOutputDirectory = new Path(getOption("trainingOutput"));            testOutputDirectory = new Path(getOption("testOutput"));            FileSystem fs = trainingOutputDirectory.getFileSystem(getConf());            if (hasOption(DefaultOptionCreator.OVERWRITE_OPTION)) {                HadoopUtil.delete(fs.getConf(), trainingOutputDirectory);                HadoopUtil.delete(fs.getConf(), testOutputDirectory);            }            fs.mkdirs(trainingOutputDirectory);            fs.mkdirs(testOutputDirectory);        }        if (hasOption("charset")) {            charset = Charset.forName(getOption("charset"));        }        if (hasOption("testSplitSize") && hasOption("testSplitPct")) {            throw new OptionException(getCLIOption("testSplitPct"), "must have either split size or split percentage " + "option, not BOTH");        }        if (hasOption("testSplitSize")) {            setTestSplitSize(Integer.parseInt(getOption("testSplitSize")));        }        if (hasOption("testSplitPct")) {            setTestSplitPct(Integer.parseInt(getOption("testSplitPct")));        }        if (hasOption("splitLocation")) {            setSplitLocation(Integer.parseInt(getOption("splitLocation")));        }        if (hasOption("randomSelectionSize")) {            setTestRandomSelectionSize(Integer.parseInt(getOption("randomSelectionSize")));        }        if (hasOption("randomSelectionPct")) {            setTestRandomSelectionPct(Integer.parseInt(getOption("randomSelectionPct")));        }        useSequence = hasOption("sequenceFiles");    } catch (OptionException e) {        log.error("Command-line option Exception", e);        CommandLineUtil.printHelp(getGroup());        return false;    }    validate();    return true;}
4b45b844e7cbf40d5846cac67bfc02de4c83c5edd457cf177827b5f40e4cc093
splitDirectory
public void splitDirectory() throws IOException, ClassNotFoundException, InterruptedException
{    this.splitDirectory(inputDirectory);}
9a72ede438583cc9fd7cbd32ea10d6d403c1b53cc2675024be2105c48915234f
splitDirectory
public void splitDirectory(Path inputDir) throws IOException, ClassNotFoundException, InterruptedException
{    Configuration conf = getConf();    splitDirectory(conf, inputDir);}
377d0bb6ce5a505cee82e2f7c3f4e5a224b76c2b145a593822d3674450edd7e0
splitDirectory
public void splitDirectory(Configuration conf, Path inputDir) throws IOException, ClassNotFoundException, InterruptedException
{    FileSystem fs = inputDir.getFileSystem(conf);    if (fs.getFileStatus(inputDir) == null) {        throw new IOException(inputDir + " does not exist");    }    if (!fs.getFileStatus(inputDir).isDir()) {        throw new IOException(inputDir + " is not a directory");    }    if (useMapRed) {        SplitInputJob.run(conf, inputDir, mapRedOutputDirectory, keepPct, testRandomSelectionPct);    } else {                FileStatus[] fileStats = fs.listStatus(inputDir, PathFilters.logsCRCFilter());        for (FileStatus inputFile : fileStats) {            if (!inputFile.isDir()) {                splitFile(inputFile.getPath());            }        }    }}
32788a13a9b206d0d895d338a4475ab6795de44eac4a0390e9a2273f3cb48482
splitFile
public void splitFile(Path inputFile) throws IOException
{    Configuration conf = getConf();    FileSystem fs = inputFile.getFileSystem(conf);    if (fs.getFileStatus(inputFile) == null) {        throw new IOException(inputFile + " does not exist");    }    if (fs.getFileStatus(inputFile).isDir()) {        throw new IOException(inputFile + " is a directory");    }    validate();    Path testOutputFile = new Path(testOutputDirectory, inputFile.getName());    Path trainingOutputFile = new Path(trainingOutputDirectory, inputFile.getName());    int lineCount = countLines(fs, inputFile, charset);    log.info("{} has {} lines", inputFile.getName(), lineCount);    int testSplitStart = 0;        int testSplitSize = this.testSplitSize;    BitSet randomSel = null;    if (testRandomSelectionPct > 0 || testRandomSelectionSize > 0) {        testSplitSize = this.testRandomSelectionSize;        if (testRandomSelectionPct > 0) {            testSplitSize = Math.round(lineCount * testRandomSelectionPct / 100.0f);        }        log.info("{} test split size is {} based on random selection percentage {}", inputFile.getName(), testSplitSize, testRandomSelectionPct);        long[] ridx = new long[testSplitSize];        RandomSampler.sample(testSplitSize, lineCount - 1, testSplitSize, 0, ridx, 0, RandomUtils.getRandom());        randomSel = new BitSet(lineCount);        for (long idx : ridx) {            randomSel.set((int) idx + 1);        }    } else {        if (testSplitPct > 0) {                        testSplitSize = Math.round(lineCount * testSplitPct / 100.0f);            log.info("{} test split size is {} based on percentage {}", inputFile.getName(), testSplitSize, testSplitPct);        } else {            log.info("{} test split size is {}", inputFile.getName(), testSplitSize);        }        if (splitLocation > 0) {                        testSplitStart = Math.round(lineCount * splitLocation / 100.0f);            if (lineCount - testSplitStart < testSplitSize) {                                testSplitStart = lineCount - testSplitSize;            }            log.info("{} test split start is {} based on split location {}", inputFile.getName(), testSplitStart, splitLocation);        }        if (testSplitStart < 0) {            throw new IllegalArgumentException("test split size for " + inputFile + " is too large, it would produce an " + "empty training set from the initial set of " + lineCount + " examples");        } else if (lineCount - testSplitSize < testSplitSize) {            log.warn("Test set size for {} may be too large, {} is larger than the number of " + "lines remaining in the training set: {}", inputFile, testSplitSize, lineCount - testSplitSize);        }    }    int trainCount = 0;    int testCount = 0;    if (!useSequence) {        try (BufferedReader reader = new BufferedReader(new InputStreamReader(fs.open(inputFile), charset));            Writer trainingWriter = new OutputStreamWriter(fs.create(trainingOutputFile), charset);            Writer testWriter = new OutputStreamWriter(fs.create(testOutputFile), charset)) {            String line;            int pos = 0;            while ((line = reader.readLine()) != null) {                pos++;                Writer writer;                if (testRandomSelectionPct > 0) {                                        writer = randomSel.get(pos) ? testWriter : trainingWriter;                } else {                                        writer = pos > testSplitStart ? testWriter : trainingWriter;                }                if (writer == testWriter) {                    if (testCount >= testSplitSize) {                        writer = trainingWriter;                    } else {                        testCount++;                    }                }                if (writer == trainingWriter) {                    trainCount++;                }                writer.write(line);                writer.write('\n');            }        }    } else {        try (SequenceFileIterator<Writable, Writable> iterator = new SequenceFileIterator<>(inputFile, false, fs.getConf());            SequenceFile.Writer trainingWriter = SequenceFile.createWriter(fs, fs.getConf(), trainingOutputFile, iterator.getKeyClass(), iterator.getValueClass());            SequenceFile.Writer testWriter = SequenceFile.createWriter(fs, fs.getConf(), testOutputFile, iterator.getKeyClass(), iterator.getValueClass())) {            int pos = 0;            while (iterator.hasNext()) {                pos++;                SequenceFile.Writer writer;                if (testRandomSelectionPct > 0) {                                        writer = randomSel.get(pos) ? testWriter : trainingWriter;                } else {                                        writer = pos > testSplitStart ? testWriter : trainingWriter;                }                if (writer == testWriter) {                    if (testCount >= testSplitSize) {                        writer = trainingWriter;                    } else {                        testCount++;                    }                }                if (writer == trainingWriter) {                    trainCount++;                }                Pair<Writable, Writable> pair = iterator.next();                writer.append(pair.getFirst(), pair.getSecond());            }        }    }    log.info("file: {}, input: {} train: {}, test: {} starting at {}", inputFile.getName(), lineCount, trainCount, testCount, testSplitStart);        if (callback != null) {        callback.splitComplete(inputFile, lineCount, trainCount, testCount, testSplitStart);    }}
cdac16881acb8279da201799b687bcaf6808033e5ae130aa0bff5dff846f7adb
getTestSplitSize
public int getTestSplitSize()
{    return testSplitSize;}
873e191e49b670b13b7319dfc37edd0458fc5c566cf2519a30f0870a0307a18d
setTestSplitSize
public void setTestSplitSize(int testSplitSize)
{    this.testSplitSize = testSplitSize;}
4226c0d263f83f0434149c9fe982a608958a2475d04221ce0806cb9483ce4a9f
getTestSplitPct
public int getTestSplitPct()
{    return testSplitPct;}
d967b7ae6ed6728d95c31514025127be7c00e0296640dc42e192e7cde3bf6d8d
setTestSplitPct
public void setTestSplitPct(int testSplitPct)
{    this.testSplitPct = testSplitPct;}
8c651c9371c42028bba89c17936614a67fb5679709e9c28fa404f5d8bff7daa6
setKeepPct
public void setKeepPct(int keepPct)
{    this.keepPct = keepPct;}
9dfb91c22bbd6ce3ea1483e359ea8083986138bf371a2432b699bbe6e0214a94
setUseMapRed
public void setUseMapRed(boolean useMapRed)
{    this.useMapRed = useMapRed;}
bbd8769006e83bc2aa72275b150cc6894711187172bd85e9ff7d0712dff297c1
setMapRedOutputDirectory
public void setMapRedOutputDirectory(Path mapRedOutputDirectory)
{    this.mapRedOutputDirectory = mapRedOutputDirectory;}
6d3a6e37241c99b75bc267cc4ee021c4acf4d6f3546b036e5d10ab3ac14d0362
getSplitLocation
public int getSplitLocation()
{    return splitLocation;}
be50ac658d08c416d7a82d34ed7649f5a9904a6923a4e840d93fa7a64fc3befd
setSplitLocation
public void setSplitLocation(int splitLocation)
{    this.splitLocation = splitLocation;}
62fdd366fb32662880f70100b38033d757466e1309c6257954c6fc4c8656df36
getCharset
public Charset getCharset()
{    return charset;}
3696ac717996317a8eab4bdaa0165aa3fe5c8ae6154932d23ee3ea5c0a18969f
setCharset
public void setCharset(Charset charset)
{    this.charset = charset;}
adab849973fde92a2b9c44d58a3911a99bf4725fb6a814500987ad2ada7cc30b
getInputDirectory
public Path getInputDirectory()
{    return inputDirectory;}
b7a4b143a8391aa0685bf802fc6dc41b396d62062d056164d70134fa62f6bcdd
setInputDirectory
public void setInputDirectory(Path inputDir)
{    this.inputDirectory = inputDir;}
b7a0cd56119a4d54e841826e3a441e15b85b092e8260c4aa04b10eacb904be09
getTrainingOutputDirectory
public Path getTrainingOutputDirectory()
{    return trainingOutputDirectory;}
9ada684bf1cbaf5988acccd04e6c6645517fbcfb15b57407fbeeaefaba3487b3
setTrainingOutputDirectory
public void setTrainingOutputDirectory(Path trainingOutputDir)
{    this.trainingOutputDirectory = trainingOutputDir;}
332d619b061c4c045569ffb029b9d0076a87198d23dde3c797a2f4f278090b40
getTestOutputDirectory
public Path getTestOutputDirectory()
{    return testOutputDirectory;}
c6c02e7f9bce246dac47c21c51f1baf1cecd435f9a9f9036f1dd313ee7cb2ec5
setTestOutputDirectory
public void setTestOutputDirectory(Path testOutputDir)
{    this.testOutputDirectory = testOutputDir;}
e40579b5efc6370905c72d2e7dd9a230059c34620f4c63f5682f13a905af4d57
getCallback
public SplitCallback getCallback()
{    return callback;}
2e5c0e30c4f84f32365cbbbe0f2d744c1eb4ab8d886e6297c96726b43cafd02f
setCallback
public void setCallback(SplitCallback callback)
{    this.callback = callback;}
54049805d9a77ee750e1638a0d36174080f4b2a1465ebcfd40863de30aa857e3
getTestRandomSelectionSize
public int getTestRandomSelectionSize()
{    return testRandomSelectionSize;}
29bf43cfcd7f43354949bb2ab1372996814469db13ca4b70db055652aeb78b4c
setTestRandomSelectionSize
public void setTestRandomSelectionSize(int testRandomSelectionSize)
{    this.testRandomSelectionSize = testRandomSelectionSize;}
a15bdb6fa94edf53ef81d742b74eecdefb285c2479eb5191a3a22204f9758f15
getTestRandomSelectionPct
public int getTestRandomSelectionPct()
{    return testRandomSelectionPct;}
cf3a8d0dd615ee3316144e04437782cd9ee323b06514e65bb3cf703e6ddd64e8
setTestRandomSelectionPct
public void setTestRandomSelectionPct(int randomSelectionPct)
{    this.testRandomSelectionPct = randomSelectionPct;}
a89bcc4d6add47213810467cf97fe97b5b3e35cac8b8a7b6a328400227fb4a0d
validate
public void validate() throws IOException
{    Preconditions.checkArgument(testSplitSize >= 1 || testSplitSize == -1, "Invalid testSplitSize: " + testSplitSize + ". Must be: testSplitSize >= 1 or testSplitSize = -1");    Preconditions.checkArgument(splitLocation >= 0 && splitLocation <= 100 || splitLocation == -1, "Invalid splitLocation percentage: " + splitLocation + ". Must be: 0 <= splitLocation <= 100 or splitLocation = -1");    Preconditions.checkArgument(testSplitPct >= 0 && testSplitPct <= 100 || testSplitPct == -1, "Invalid testSplitPct percentage: " + testSplitPct + ". Must be: 0 <= testSplitPct <= 100 or testSplitPct = -1");    Preconditions.checkArgument(testRandomSelectionPct >= 0 && testRandomSelectionPct <= 100 || testRandomSelectionPct == -1, "Invalid testRandomSelectionPct percentage: " + testRandomSelectionPct + ". Must be: 0 <= testRandomSelectionPct <= 100 or testRandomSelectionPct = -1");    Preconditions.checkArgument(trainingOutputDirectory != null || useMapRed, "No training output directory was specified");    Preconditions.checkArgument(testOutputDirectory != null || useMapRed, "No test output directory was specified");        int count = 0;    if (testSplitSize > 0) {        count++;    }    if (testSplitPct > 0) {        count++;    }    if (testRandomSelectionSize > 0) {        count++;    }    if (testRandomSelectionPct > 0) {        count++;    }    Preconditions.checkArgument(count == 1, "Exactly one of testSplitSize, testSplitPct, testRandomSelectionSize, " + "testRandomSelectionPct should be set");    if (!useMapRed) {        Configuration conf = getConf();        FileSystem fs = trainingOutputDirectory.getFileSystem(conf);        FileStatus trainingOutputDirStatus = fs.getFileStatus(trainingOutputDirectory);        Preconditions.checkArgument(trainingOutputDirStatus != null && trainingOutputDirStatus.isDir(), "%s is not a directory", trainingOutputDirectory);        FileStatus testOutputDirStatus = fs.getFileStatus(testOutputDirectory);        Preconditions.checkArgument(testOutputDirStatus != null && testOutputDirStatus.isDir(), "%s is not a directory", testOutputDirectory);    }}
f8c470989bb6d1f430ac20d85c054278348f345996a86519a28e7983f8257c94
countLines
public static int countLines(FileSystem fs, Path inputFile, Charset charset) throws IOException
{    int lineCount = 0;    try (BufferedReader reader = new BufferedReader(new InputStreamReader(fs.open(inputFile), charset))) {        while (reader.readLine() != null) {            lineCount++;        }    }    return lineCount;}
6b450853d7f5c8028077a570e07563463b29d3c89dfeec16383de70f3468c919
run
public static void run(Configuration initialConf, Path inputPath, Path outputPath, int keepPct, float randomSelectionPercent) throws IOException, ClassNotFoundException, InterruptedException
{    int downsamplingFactor = (int) (100.0 / keepPct);    initialConf.setInt(DOWNSAMPLING_FACTOR, downsamplingFactor);    initialConf.setFloat(RANDOM_SELECTION_PCT, randomSelectionPercent);        FileSystem fs = FileSystem.get(initialConf);    SequenceFileDirIterator<? extends WritableComparable, Writable> iterator = new SequenceFileDirIterator<>(inputPath, PathType.LIST, PathFilters.partFilter(), null, false, fs.getConf());    Class<? extends WritableComparable> keyClass;    Class<? extends Writable> valueClass;    if (iterator.hasNext()) {        Pair<? extends WritableComparable, Writable> pair = iterator.next();        keyClass = pair.getFirst().getClass();        valueClass = pair.getSecond().getClass();    } else {        throw new IllegalStateException("Couldn't determine class of the input values");    }    Job job = new Job(new Configuration(initialConf));    MultipleOutputs.addNamedOutput(job, TRAINING_TAG, SequenceFileOutputFormat.class, keyClass, valueClass);    MultipleOutputs.addNamedOutput(job, TEST_TAG, SequenceFileOutputFormat.class, keyClass, valueClass);    job.setJarByClass(SplitInputJob.class);    FileInputFormat.addInputPath(job, inputPath);    FileOutputFormat.setOutputPath(job, outputPath);    job.setNumReduceTasks(1);    job.setInputFormatClass(SequenceFileInputFormat.class);    job.setOutputFormatClass(SequenceFileOutputFormat.class);    job.setMapperClass(SplitInputMapper.class);    job.setReducerClass(SplitInputReducer.class);    job.setSortComparatorClass(SplitInputComparator.class);    job.setOutputKeyClass(keyClass);    job.setOutputValueClass(valueClass);    job.submit();    boolean succeeded = job.waitForCompletion(true);    if (!succeeded) {        throw new IllegalStateException("Job failed!");    }}
9963c7438bc572ef8ec31d839296d4d65f271b97d0061c4d16969c29f9977a0d
setup
public void setup(Context ctx)
{    downsamplingFactor = ctx.getConfiguration().getInt(DOWNSAMPLING_FACTOR, 1);}
f1b79cd73081803aac4d597efe66cc1e35d6cdcd7d3d407951eb90b869e57624
run
public void run(Context context) throws IOException, InterruptedException
{    setup(context);    int i = 0;    while (context.nextKeyValue()) {        if (i % downsamplingFactor == 0) {            map(context.getCurrentKey(), context.getCurrentValue(), context);        }        i++;    }    cleanup(context);}
1891bba0da4650d75c53b62200830afcc061f047e78d74ce842c5f07c937883a
setup
protected void setup(Context ctx) throws IOException
{    randomSelectionPercent = ctx.getConfiguration().getFloat(RANDOM_SELECTION_PCT, 0);    multipleOutputs = new MultipleOutputs(ctx);}
cd4b4f23302314ec06bd7977c601c848be13fbb0f02a1298d802eb215fe87216
reduce
protected void reduce(WritableComparable<?> key, Iterable<Writable> values, Context context) throws IOException, InterruptedException
{    for (Writable value : values) {        if (rnd.nextInt(100) < randomSelectionPercent) {            multipleOutputs.write(TEST_TAG, key, value);        } else {            multipleOutputs.write(TRAINING_TAG, key, value);        }    }}
6eb71d88a3b41bba79e6ba007bed4c42b86442d75ca289e732618ffa5d34ea26
cleanup
protected void cleanup(Context context) throws IOException
{    try {        multipleOutputs.close();    } catch (InterruptedException e) {        throw new IOException(e);    }}
8cd74526bc7e7f20597a504e1ed768d1c3a048c7a382f95e889101f52fd94ec3
compare
public int compare(byte[] b1, int s1, int l1, byte[] b2, int s2, int l2)
{    if (rnd.nextBoolean()) {        return 1;    } else {        return -1;    }}
a4c187d76a1d98ac41bb24750226d783cc1a2dd76f36c2a2bccbc4fbf57a20f2
computeNext
protected Vector computeNext()
{    String line;    try {        while ((line = reader.readLine()) != null) {            line = line.trim();            if (!line.isEmpty() && !line.startsWith(ARFFModel.ARFF_COMMENT)) {                break;            }        }    } catch (IOException ioe) {        throw new IllegalStateException(ioe);    }    if (line == null) {        try {            Closeables.close(reader, true);        } catch (IOException e) {            throw new IllegalStateException(e);        }        return endOfData();    }    Vector result;    Matcher contents = DATA_PATTERN.matcher(line);    if (contents.find()) {        line = contents.group(1);        String[] splits = splitCSV(line);        result = new RandomAccessSparseVector(model.getLabelSize());        for (String split : splits) {            int idIndex = split.indexOf(' ');            int idx = Integer.parseInt(split.substring(0, idIndex).trim());            String data = split.substring(idIndex).trim();            if (!"?".equals(data)) {                result.setQuick(idx, model.getValue(data, idx));            }        }    } else {        result = new DenseVector(model.getLabelSize());        String[] splits = splitCSV(line);        for (int i = 0; i < splits.length; i++) {            String split = splits[i];            split = split.trim();            if (WORDS_WITHOUT_SPARSE.matcher(split).matches() && !"?".equals(split)) {                result.setQuick(i, model.getValue(split, i));            }        }    }    return result;}
bcdd71411e5bf5cbca78c61ccc6dd14bfb918e2f3897573a38fbee3f6db538ef
splitCSV
public static String[] splitCSV(String line)
{    StringBuilder sb = new StringBuilder(128);    List<String> tokens = new ArrayList<>();    char escapeChar = '\0';    for (int i = 0; i < line.length(); i++) {        char c = line.charAt(i);        if (c == '\\') {            i++;            sb.append(line.charAt(i));        } else if (c == '"' || c == '\'') {                        if (c == escapeChar) {                escapeChar = '\0';            } else if (escapeChar == '\0') {                escapeChar = c;            }            sb.append(c);        } else if (c == ',') {            if (escapeChar == '\0') {                tokens.add(sb.toString().trim());                                sb.setLength(0);            } else {                sb.append(c);            }        } else {            sb.append(c);        }    }    if (sb.length() > 0) {        tokens.add(sb.toString().trim());    }    return tokens.toArray(new String[tokens.size()]);}
7b811ddca05c858f14ff2d193624c2407852edc8cfd62cc1526440f71f1c8bdd
getIndicator
public String getIndicator()
{    return indicator;}
363c7774bfcd73b48dda118fa6d86d81cd5fba9264e9fdf2e33aa08714ace5b6
getLabel
public String getLabel(String line)
{    int idx = line.lastIndexOf(indicator);    return removeQuotes(line.substring(ARFFModel.ATTRIBUTE.length(), idx));}
336def0ef40168905a552e688a30b14f40a1edc7648e2d8a8f2cbfb30c2a4b31
removeQuotes
public static String removeQuotes(String str)
{    String cleaned = str;    if (cleaned != null) {        cleaned = cleaned.trim();        boolean isQuoted = cleaned.length() > 1 && (cleaned.startsWith("\"") && cleaned.endsWith("\"") || cleaned.startsWith("'") && cleaned.endsWith("'"));        if (isQuoted) {            cleaned = cleaned.substring(1, cleaned.length() - 1);        }    }    return cleaned;}
1b5226f5beec2d8e24f17077e3cf629752caa7dc7c1859a1b913ae4ab3c710ea
iterator
public Iterator<Vector> iterator()
{    return new ARFFIterator(buff, model);}
a99f6098a883a809223db1d5d95feadd1074db6a5ff7524c2c665f5764eeca3f
getModel
public ARFFModel getModel()
{    return model;}
365a24fc75086b6a0e91f9b072bd58c9280846cc05f333f28ede18388f27ce89
main
public static void main(String[] args) throws IOException
{    DefaultOptionBuilder obuilder = new DefaultOptionBuilder();    ArgumentBuilder abuilder = new ArgumentBuilder();    GroupBuilder gbuilder = new GroupBuilder();    Option inputOpt = obuilder.withLongName("input").withRequired(true).withArgument(abuilder.withName("input").withMinimum(1).withMaximum(1).create()).withDescription("The file or directory containing the ARFF files.  If it is a directory, all .arff files will be converted").withShortName("d").create();    Option outputOpt = obuilder.withLongName("output").withRequired(true).withArgument(abuilder.withName("output").withMinimum(1).withMaximum(1).create()).withDescription("The output directory.  Files will have the same name as the input, but with the extension .mvc").withShortName("o").create();    Option maxOpt = obuilder.withLongName("max").withRequired(false).withArgument(abuilder.withName("max").withMinimum(1).withMaximum(1).create()).withDescription("The maximum number of vectors to output.  If not specified, then it will loop over all docs").withShortName("m").create();    Option dictOutOpt = obuilder.withLongName("dictOut").withRequired(true).withArgument(abuilder.withName("dictOut").withMinimum(1).withMaximum(1).create()).withDescription("The file to output the label bindings").withShortName("t").create();    Option jsonDictonaryOpt = obuilder.withLongName("json-dictonary").withRequired(false).withDescription("Write dictonary in JSON format").withShortName("j").create();    Option delimiterOpt = obuilder.withLongName("delimiter").withRequired(false).withArgument(abuilder.withName("delimiter").withMinimum(1).withMaximum(1).create()).withDescription("The delimiter for outputing the dictionary").withShortName("l").create();    Option helpOpt = obuilder.withLongName("help").withDescription("Print out help").withShortName("h").create();    Group group = gbuilder.withName("Options").withOption(inputOpt).withOption(outputOpt).withOption(maxOpt).withOption(helpOpt).withOption(dictOutOpt).withOption(jsonDictonaryOpt).withOption(delimiterOpt).create();    try {        Parser parser = new Parser();        parser.setGroup(group);        CommandLine cmdLine = parser.parse(args);        if (cmdLine.hasOption(helpOpt)) {            CommandLineUtil.printHelp(group);            return;        }        if (cmdLine.hasOption(inputOpt)) {                        File input = new File(cmdLine.getValue(inputOpt).toString());            long maxDocs = Long.MAX_VALUE;            if (cmdLine.hasOption(maxOpt)) {                maxDocs = Long.parseLong(cmdLine.getValue(maxOpt).toString());            }            if (maxDocs < 0) {                throw new IllegalArgumentException("maxDocs must be >= 0");            }            String outDir = cmdLine.getValue(outputOpt).toString();            log.info("Output Dir: {}", outDir);            String delimiter = cmdLine.hasOption(delimiterOpt) ? cmdLine.getValue(delimiterOpt).toString() : "\t";            File dictOut = new File(cmdLine.getValue(dictOutOpt).toString());            boolean jsonDictonary = cmdLine.hasOption(jsonDictonaryOpt);            ARFFModel model = new MapBackedARFFModel();            if (input.exists() && input.isDirectory()) {                File[] files = input.listFiles(new FilenameFilter() {                    @Override                    public boolean accept(File file, String name) {                        return name.endsWith(".arff");                    }                });                for (File file : files) {                    writeFile(outDir, file, maxDocs, model, dictOut, delimiter, jsonDictonary);                }            } else {                writeFile(outDir, input, maxDocs, model, dictOut, delimiter, jsonDictonary);            }        }    } catch (OptionException e) {        log.error("Exception", e);        CommandLineUtil.printHelp(group);    }}
8763afe952aa8fdb26bd54c35272617fbf0387a0d6b841aea1173ce9e7021f98
accept
public boolean accept(File file, String name)
{    return name.endsWith(".arff");}
b8f959a260d1a1e626e82529feb95dfb127d10f4617014acd8a14be2fa66a06b
writeLabelBindings
protected static void writeLabelBindings(File dictOut, ARFFModel arffModel, String delimiter, boolean jsonDictonary) throws IOException
{    try (Writer writer = Files.newWriterSupplier(dictOut, Charsets.UTF_8, true).getOutput()) {        if (jsonDictonary) {            writeLabelBindingsJSON(writer, arffModel);        } else {            writeLabelBindings(writer, arffModel, delimiter);        }    }}
c55cc38d0328d1e469967401726e0acfd6cf6386e6a86c24b8a37b255bff3bd8
writeLabelBindingsJSON
protected static void writeLabelBindingsJSON(Writer writer, ARFFModel arffModel) throws IOException
{        List<Entry<String, Integer>> attributes = new ArrayList<>();    attributes.addAll(arffModel.getLabelBindings().entrySet());    Collections.sort(attributes, new Comparator<Map.Entry<String, Integer>>() {        @Override        public int compare(Entry<String, Integer> t, Entry<String, Integer> t1) {            return t.getValue().compareTo(t1.getValue());        }    });        List<Map<String, Object>> jsonObjects = new LinkedList<>();    for (int i = 0; i < attributes.size(); i++) {        Entry<String, Integer> modelRepresentation = attributes.get(i);        Map<String, Object> jsonRepresentation = new HashMap<>();        jsonObjects.add(jsonRepresentation);                jsonRepresentation.put("label", i < (attributes.size() - 1) ? String.valueOf(false) : String.valueOf(true));        String attribute = modelRepresentation.getKey();        jsonRepresentation.put("attribute", attribute);        Map<String, Integer> nominalValues = arffModel.getNominalMap().get(attribute);        if (nominalValues != null) {            String[] values = nominalValues.keySet().toArray(new String[1]);            jsonRepresentation.put("values", values);            jsonRepresentation.put("type", "categorical");        } else {            jsonRepresentation.put("type", "numerical");        }    }    writer.write(OBJECT_MAPPER.writeValueAsString(jsonObjects));}
ff378868606a2f3378e3c5ef31b3f5a6b4c1ff18d07c1bc1f8c5e7e5e84a1ca8
compare
public int compare(Entry<String, Integer> t, Entry<String, Integer> t1)
{    return t.getValue().compareTo(t1.getValue());}
d5a5f369b43ed9231b42de3f61521f71647ae0d1ae4f018761b88d12b2ffbc63
writeLabelBindings
protected static void writeLabelBindings(Writer writer, ARFFModel arffModel, String delimiter) throws IOException
{    Map<String, Integer> labels = arffModel.getLabelBindings();    writer.write("Label bindings for Relation " + arffModel.getRelation() + '\n');    for (Map.Entry<String, Integer> entry : labels.entrySet()) {        writer.write(entry.getKey());        writer.write(delimiter);        writer.write(String.valueOf(entry.getValue()));        writer.write('\n');    }    writer.write('\n');    writer.write("Values for nominal attributes\n");        Map<String, Map<String, Integer>> nominalMap = arffModel.getNominalMap();        writer.write(String.valueOf(nominalMap.size()) + "\n");    for (Entry<String, Map<String, Integer>> entry : nominalMap.entrySet()) {                writer.write(entry.getKey() + "\n");        Set<Entry<String, Integer>> attributeValues = entry.getValue().entrySet();                writer.write(attributeValues.size() + "\n");        for (Map.Entry<String, Integer> value : attributeValues) {                        writer.write(String.format("%s%s%s\n", value.getKey(), delimiter, value.getValue().toString()));        }    }}
b54232e64f38532097840db1aa9115e669deacacdb457f63238d1341ee28f730
writeFile
protected static void writeFile(String outDir, File file, long maxDocs, ARFFModel arffModel, File dictOut, String delimiter, boolean jsonDictonary) throws IOException
{    log.info("Converting File: {}", file);    ARFFModel model = new MapBackedARFFModel(arffModel.getWords(), arffModel.getWordCount() + 1, arffModel.getNominalMap());    Iterable<Vector> iteratable = new ARFFVectorIterable(file, model);    String outFile = outDir + '/' + file.getName() + ".mvc";    try (VectorWriter vectorWriter = getSeqFileWriter(outFile)) {        long numDocs = vectorWriter.write(iteratable, maxDocs);        writeLabelBindings(dictOut, model, delimiter, jsonDictonary);        log.info("Wrote: {} vectors", numDocs);    }}
1e09d65d06e429bce9ad7afb68b7a3aa5e33cd03072870566632dc714493d89d
getSeqFileWriter
private static VectorWriter getSeqFileWriter(String outFile) throws IOException
{    Path path = new Path(outFile);    Configuration conf = new Configuration();    FileSystem fs = FileSystem.get(conf);    SequenceFile.Writer seqWriter = SequenceFile.createWriter(fs, conf, path, LongWritable.class, VectorWritable.class);    return new SequenceFileVectorWriter(seqWriter);}
ec8adaf90c9013de61ebf9fc4c862520b67f6340350dcce5a09e077e37951e87
getRelation
public String getRelation()
{    return relation;}
d87b59a40bd48c11b8d50860b11412c3d2a06b74c94a2886c308255913a69e19
setRelation
public void setRelation(String relation)
{    this.relation = relation;}
9b4fbdf24e4b6c5aff69b44535a4bdc2372290ea8d6c6fdadcdacbb94813f77a
getValue
public double getValue(String data, int idx)
{    ARFFType type = typeMap.get(idx);    if (type == null) {        throw new IllegalArgumentException("Attribute type cannot be NULL, attribute index was: " + idx);    }    data = QUOTE_PATTERN.matcher(data).replaceAll("");    data = data.trim();    double result;    switch(type) {        case NUMERIC:        case INTEGER:        case REAL:            result = processNumeric(data);            break;        case DATE:            result = processDate(data, idx);            break;        case STRING:                        result = processString(data);            break;        case NOMINAL:            String label = idxLabel.get(idx);            result = processNominal(label, data);            break;        default:            throw new IllegalStateException("Unknown type: " + type);    }    return result;}
ea6d1847d2921f5d080dd0f7b37842e15976a94f48ccf91ba64cb5c2dcc9f43d
processNominal
protected double processNominal(String label, String data)
{    double result;    Map<String, Integer> classes = nominalMap.get(label);    if (classes != null) {        Integer ord = classes.get(ARFFType.removeQuotes(data));        if (ord != null) {            result = ord;        } else {            throw new IllegalStateException("Invalid nominal: " + data + " for label: " + label);        }    } else {        throw new IllegalArgumentException("Invalid nominal label: " + label + " Data: " + data);    }    return result;}
8e0457213cbba4c3cf621a60d1ced59b853a5b864a6af347913481940d5c1f01
processString
protected double processString(String data)
{    data = QUOTE_PATTERN.matcher(data).replaceAll("");        Long theLong = words.get(data);    if (theLong == null) {        theLong = wordCount++;        words.put(data, theLong);    }    return theLong;}
6fea4ec0446eee9c8d9918663e87c2b1f66747b2ef4801ad23c185cb3207be14
processNumeric
protected static double processNumeric(String data)
{    if (isNumeric(data)) {        return Double.parseDouble(data);    }    return Double.NaN;}
e05a13c1d9ef7f7080418d59135b01591e382e96e942524c047846bba0cb358d
isNumeric
public static boolean isNumeric(String str)
{    NumberFormat formatter = NumberFormat.getInstance();    ParsePosition parsePosition = new ParsePosition(0);    formatter.parse(str, parsePosition);    return str.length() == parsePosition.getIndex();}
ae877ae30e5bcf4c2104c3c6f255eabc64ab80d5c18688f85107916654b5ce77
processDate
protected double processDate(String data, int idx)
{    DateFormat format = dateMap.get(idx);    if (format == null) {        format = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss", Locale.ENGLISH);    }    double result;    try {        Date date = format.parse(data);                result = date.getTime();    } catch (ParseException e) {        throw new IllegalArgumentException(e);    }    return result;}
d577c0f2811143fac5e9307902f5a0aac1cc542a053dbf003b3a74e60f7f8937
getLabelBindings
public Map<String, Integer> getLabelBindings()
{    return Collections.unmodifiableMap(labelBindings);}
0b1426bca87a4a6bb3363018e22729cce18a0c8c11b02d133caaeaa9b11d19fa
getTypeMap
public Map<Integer, ARFFType> getTypeMap()
{    return Collections.unmodifiableMap(typeMap);}
75b015345604be23651a7add340fc8b3a05fbd2143799c2e0e65d4a3ef085680
getDateMap
public Map<Integer, DateFormat> getDateMap()
{    return Collections.unmodifiableMap(dateMap);}
025e600a4aaa525107c9b0eb349dc3abee607e9bea5a178bc5bab3d1967f3fbc
getNominalMap
public Map<String, Map<String, Integer>> getNominalMap()
{    return nominalMap;}
1be0affe08d8c5a939f2848a52503e9c0e45c8fc843070dec60f42ca13cfacd1
getWords
public Map<String, Long> getWords()
{    return words;}
137521d83b5ef6f7dec493fa1c011ad6ac2147f7570c12d893c9be9416aa6699
getNominalValue
public Integer getNominalValue(String label, String nominal)
{    return nominalMap.get(label).get(nominal);}
0ff14faa407b95a605bc9f9feda875d18ff90fe16b5b23589de23bfd6bc0a055
addNominal
public void addNominal(String label, String nominal, int idx)
{    Map<String, Integer> noms = nominalMap.get(label);    if (noms == null) {        noms = new HashMap<>();        nominalMap.put(label, noms);    }    noms.put(nominal, idx);}
c0b24736b31cd296adf92087399f6c575fd1316344a3d732459d104c327c6f1d
getDateFormat
public DateFormat getDateFormat(Integer idx)
{    return dateMap.get(idx);}
5087744edb8b28720fd7453250f49836c71b97d797ccff4b416b7ef135dc626f
addDateFormat
public void addDateFormat(Integer idx, DateFormat format)
{    dateMap.put(idx, format);}
0221a5c823ba0d00c3895282af3ae894faecc4795c4858d1425a543964d89d65
getLabelIndex
public Integer getLabelIndex(String label)
{    return labelBindings.get(label);}
c9e8e9c3e875eb57df9aed5a1fae464d4b127ebe082a81dbd3f1964424de18bb
addLabel
public void addLabel(String label, Integer idx)
{    labelBindings.put(label, idx);    idxLabel.put(idx, label);}
c86429a80bd4dc067b4a689a21c9534ee3a260bf45e802a51ca4fd43b04b4441
getARFFType
public ARFFType getARFFType(Integer idx)
{    return typeMap.get(idx);}
c6afab23e9b1c7f21390d8c4f3fe5f9587e4c0ada998ed25f46d9498d0d8533a
addType
public void addType(Integer idx, ARFFType type)
{    typeMap.put(idx, type);}
92455d7dc7488857f14cef72b7abc029b1ec1d69719a2a328aed19b8d45937b3
getWordCount
public long getWordCount()
{    return wordCount;}
2b57980071f8ff9436489d52a3f585a30a9f299867872318884214382afd04f2
getLabelSize
public int getLabelSize()
{    return labelBindings.size();}
a4c187d76a1d98ac41bb24750226d783cc1a2dd76f36c2a2bccbc4fbf57a20f2
computeNext
protected Vector computeNext()
{    String[] line;    try {        line = parser.getLine();    } catch (IOException e) {        throw new IllegalStateException(e);    }    if (line == null) {        return endOfData();    }    Vector result = new DenseVector(line.length);    for (int i = 0; i < line.length; i++) {        result.setQuick(i, Double.parseDouble(line[i]));    }    return result;}
64f21435ae1aa26bcd7603a24624bc6e553ab32999e8d9ad59bc090891d1f763
write
public void write(TermInfo ti) throws IOException
{    Iterator<TermEntry> entIter = ti.getAllEntries();    try {        writer.write(String.valueOf(ti.totalTerms(field)));        writer.write('\n');        writer.write("#term" + delimiter + "doc freq" + delimiter + "idx");        writer.write('\n');        while (entIter.hasNext()) {            TermEntry entry = entIter.next();            writer.write(entry.getTerm());            writer.write(delimiter);            writer.write(String.valueOf(entry.getDocFreq()));            writer.write(delimiter);            writer.write(String.valueOf(entry.getTermIdx()));            writer.write('\n');        }    } finally {        Closeables.close(writer, false);    }}
5df6118bc0e745d8b18e0a6a99b2e3f2ddba8140cbeb1423ce2df50a9f140574
close
public void close()
{}
7bcca8ccb3195abe8d33075fa0005b0f7d4cc39bd52b3b385172d29897341572
write
public long write(Iterable<Vector> iterable, long maxDocs) throws IOException
{    for (Vector point : iterable) {        if (recNum >= maxDocs) {            break;        }        if (point != null) {            writer.append(new LongWritable(recNum++), new VectorWritable(point));        }    }    return recNum;}
4e3fe8a1f854fd413772567f3449b3ada02d7dbbcadaded2f434863a1ece6d5b
write
public void write(Vector vector) throws IOException
{    writer.append(new LongWritable(recNum++), new VectorWritable(vector));}
cb317266ce9a71e1adf0372f73ac58c86484bca6229f0cdbc77ed8c37b884113
write
public long write(Iterable<Vector> iterable) throws IOException
{    return write(iterable, Long.MAX_VALUE);}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    Closeables.close(writer, false);}
e3a6fc1083468c3c760f5f9f525653778f4a65659f7403343559ef76ecee9389
getWriter
public SequenceFile.Writer getWriter()
{    return writer;}
92767b42f60a36945099ae009f0199f47289a68c26fa2ed8553699470fff0d6b
getWriter
protected Writer getWriter()
{    return writer;}
cb317266ce9a71e1adf0372f73ac58c86484bca6229f0cdbc77ed8c37b884113
write
public long write(Iterable<Vector> iterable) throws IOException
{    return write(iterable, Long.MAX_VALUE);}
7bcca8ccb3195abe8d33075fa0005b0f7d4cc39bd52b3b385172d29897341572
write
public long write(Iterable<Vector> iterable, long maxDocs) throws IOException
{    long result = 0;    for (Vector vector : iterable) {        if (result >= maxDocs) {            break;        }        write(vector);        result++;    }    return result;}
4e3fe8a1f854fd413772567f3449b3ada02d7dbbcadaded2f434863a1ece6d5b
write
public void write(Vector vector) throws IOException
{    writer.write(vector.asFormatString());    writer.write('\n');}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    Closeables.close(writer, false);}
a4c187d76a1d98ac41bb24750226d783cc1a2dd76f36c2a2bccbc4fbf57a20f2
computeNext
protected Vector computeNext()
{    try {        int doc;        Terms termFreqVector;        String name;        do {            doc = this.nextDocId;            nextDocId++;            if (doc >= indexReader.maxDoc()) {                return endOfData();            }            termFreqVector = indexReader.getTermVector(doc, field);            name = getVectorName(doc);            if (termFreqVector == null) {                numErrorDocs++;                if (numErrorDocs >= maxErrorDocs) {                    log.error("There are too many documents that do not have a term vector for {}", field);                    throw new IllegalStateException("There are too many documents that do not have a term vector for " + field);                }                if (numErrorDocs >= nextLogRecord) {                    if (skippedErrorMessages == 0) {                        log.warn("{} does not have a term vector for {}", name, field);                    } else {                        log.warn("{} documents do not have a term vector for {}", numErrorDocs, field);                    }                    nextLogRecord = bump.increment();                    skippedErrorMessages = 0;                } else {                    skippedErrorMessages++;                }            }        } while (termFreqVector == null);                TermsEnum te = termFreqVector.iterator();        BytesRef term;        TFDFMapper mapper = new TFDFMapper(indexReader.numDocs(), weight, this.terminfo);        mapper.setExpectations(field, termFreqVector.size());        while ((term = te.next()) != null) {            mapper.map(term, (int) te.totalTermFreq());        }        Vector result = mapper.getVector();        if (result == null) {                        return null;        }        if (normPower == LuceneIterable.NO_NORMALIZING) {            result = new NamedVector(result, name);        } else {            result = new NamedVector(result.normalize(normPower), name);        }        return result;    } catch (IOException ioe) {        throw new IllegalStateException(ioe);    }}
1735dbf3435ce399352587d250bcba7e1539e4c9007b2ac386439ed03fb6d4bf
totalTerms
public int totalTerms(String field)
{    return termEntries.size();}
42a3f06027a32cc821a586391e41cf93d7527be587e7d0de3a281290738f59cd
getTermEntry
public TermEntry getTermEntry(String field, String term)
{    if (!this.field.equals(field)) {        return null;    }    return termEntries.get(term);}
bcd9837011dc55f48b11e890ca96136e0f59ca71bb8d2d1bf00467b30f488548
getAllEntries
public Iterator<TermEntry> getAllEntries()
{    return termEntries.values().iterator();}
02703fe1d22dc619cec70695022ed750619da6249744c68ea87d5bdb4c32d8e6
getLabels
public void getLabels() throws IOException
{    try (Writer writer = (this.output == null) ? new OutputStreamWriter(System.out, Charsets.UTF_8) : Files.newWriter(new File(this.output), Charsets.UTF_8)) {        for (Map.Entry<Integer, List<WeightedPropertyVectorWritable>> integerListEntry : clusterIdToPoints.entrySet()) {            List<WeightedPropertyVectorWritable> wpvws = integerListEntry.getValue();            List<TermInfoClusterInOut> termInfos = getClusterLabels(integerListEntry.getKey(), wpvws);            if (termInfos != null) {                writer.write('\n');                writer.write("Top labels for Cluster ");                writer.write(String.valueOf(integerListEntry.getKey()));                writer.write(" containing ");                writer.write(String.valueOf(wpvws.size()));                writer.write(" vectors");                writer.write('\n');                writer.write("Term \t\t LLR \t\t In-ClusterDF \t\t Out-ClusterDF ");                writer.write('\n');                for (TermInfoClusterInOut termInfo : termInfos) {                    writer.write(termInfo.getTerm());                    writer.write("\t\t");                    writer.write(String.valueOf(termInfo.getLogLikelihoodRatio()));                    writer.write("\t\t");                    writer.write(String.valueOf(termInfo.getInClusterDF()));                    writer.write("\t\t");                    writer.write(String.valueOf(termInfo.getOutClusterDF()));                    writer.write('\n');                }            }        }    }}
fbe1b76eb27ed446fbe36277f91bf68f3cfb3abf463bd45558d3fc06b434cda3
getClusterLabels
protected List<TermInfoClusterInOut> getClusterLabels(Integer integer, Collection<WeightedPropertyVectorWritable> wpvws) throws IOException
{    if (wpvws.size() < minNumIds) {        log.info("Skipping small cluster {} with size: {}", integer, wpvws.size());        return null;    }    log.info("Processing Cluster {} with {} documents", integer, wpvws.size());    Directory dir = FSDirectory.open(Paths.get(this.indexDir));    IndexReader reader = DirectoryReader.open(dir);    log.info("# of documents in the index {}", reader.numDocs());    Collection<String> idSet = new HashSet<>();    for (WeightedPropertyVectorWritable wpvw : wpvws) {        Vector vector = wpvw.getVector();        if (vector instanceof NamedVector) {            idSet.add(((NamedVector) vector).getName());        }    }    int numDocs = reader.numDocs();    FixedBitSet clusterDocBitset = getClusterDocBitset(reader, idSet, this.idField);    log.info("Populating term infos from the index");    /**     * This code is as that of CachedTermInfo, with one major change, which is to get the document frequency.     *     * Since we have deleted the documents out of the cluster, the document frequency for a term should only     * include the in-cluster documents. The document frequency obtained from TermEnum reflects the frequency     * in the entire index. To get the in-cluster frequency, we need to query the index to get the term     * frequencies in each document. The number of results of this call will be the in-cluster document     * frequency.     */    Terms t = MultiFields.getTerms(reader, contentField);    TermsEnum te = t.iterator();    Map<String, TermEntry> termEntryMap = new LinkedHashMap<>();        Bits liveDocs = MultiFields.getLiveDocs(reader);    int count = 0;    BytesRef term;    while ((term = te.next()) != null) {        FixedBitSet termBitset = new FixedBitSet(reader.maxDoc());        PostingsEnum docsEnum = MultiFields.getTermDocsEnum(reader, contentField, term);        int docID;        while ((docID = docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {                        if (liveDocs != null && !liveDocs.get(docID)) {                                termBitset.set(docsEnum.docID());            }        }                        termBitset.and(clusterDocBitset);        int inclusterDF = (int) termBitset.cardinality();        TermEntry entry = new TermEntry(term.utf8ToString(), count++, inclusterDF);        termEntryMap.put(entry.getTerm(), entry);    }    List<TermInfoClusterInOut> clusteredTermInfo = new LinkedList<>();    int clusterSize = wpvws.size();    for (TermEntry termEntry : termEntryMap.values()) {        int corpusDF = reader.docFreq(new Term(this.contentField, termEntry.getTerm()));        int outDF = corpusDF - termEntry.getDocFreq();        int inDF = termEntry.getDocFreq();        double logLikelihoodRatio = scoreDocumentFrequencies(inDF, outDF, clusterSize, numDocs);        TermInfoClusterInOut termInfoCluster = new TermInfoClusterInOut(termEntry.getTerm(), inDF, outDF, logLikelihoodRatio);        clusteredTermInfo.add(termInfoCluster);    }    Collections.sort(clusteredTermInfo);        Closeables.close(reader, true);    termEntryMap.clear();    return clusteredTermInfo.subList(0, Math.min(clusteredTermInfo.size(), maxLabels));}
076863389351f2abd2c1178c7214387c9d1ce892c07aa34e50015ed6ba4a4f77
getClusterDocBitset
private static FixedBitSet getClusterDocBitset(IndexReader reader, Collection<String> idSet, String idField) throws IOException
{    int numDocs = reader.numDocs();    FixedBitSet bitset = new FixedBitSet(numDocs);    Set<String> idFieldSelector = null;    if (idField != null) {        idFieldSelector = new TreeSet<>();        idFieldSelector.add(idField);    }    for (int i = 0; i < numDocs; i++) {        String id;                if (idField == null) {            id = Integer.toString(i);        } else {            id = reader.document(i, idFieldSelector).get(idField);        }        if (idSet.contains(id)) {            bitset.set(i);        }    }    log.info("Created bitset for in-cluster documents : {}", bitset.cardinality());    return bitset;}
2af3425126b5939b404d14bdd04f0b57e857ea1920b6c7a7bad101a2cd2b1037
scoreDocumentFrequencies
private static double scoreDocumentFrequencies(long inDF, long outDF, long clusterSize, long corpusSize)
{    long k12 = clusterSize - inDF;    long k22 = corpusSize - clusterSize - outDF;    return LogLikelihood.logLikelihoodRatio(inDF, k12, outDF, k22);}
0e9f09bfbc69592cdcf1e4a4f7422e3bdf8da214bde4ee900090265ad28f30b7
getIdField
public String getIdField()
{    return idField;}
238002216d61818153ca0e4a754a809695d919c4328b6fb1b5989499d50fb729
setIdField
public void setIdField(String idField)
{    this.idField = idField;}
d50b6d29ac37cfa68ef4739158c0c2870add3c542392976cbe2f04d503807c32
getOutput
public String getOutput()
{    return output;}
95e36cb6bb6ac4fc99b69898fa2a49fa66f9dd35141a4f912950efb3d2fb84e9
setOutput
public void setOutput(String output)
{    this.output = output;}
3116ea2053d9de960ec3753eb07f3d243c370662aa1f0175ad357057c9ce5a52
main
public static void main(String[] args)
{    DefaultOptionBuilder obuilder = new DefaultOptionBuilder();    ArgumentBuilder abuilder = new ArgumentBuilder();    GroupBuilder gbuilder = new GroupBuilder();    Option indexOpt = obuilder.withLongName("dir").withRequired(true).withArgument(abuilder.withName("dir").withMinimum(1).withMaximum(1).create()).withDescription("The Lucene index directory").withShortName("d").create();    Option outputOpt = obuilder.withLongName("output").withRequired(false).withArgument(abuilder.withName("output").withMinimum(1).withMaximum(1).create()).withDescription("The output file. If not specified, the result is printed on console.").withShortName("o").create();    Option fieldOpt = obuilder.withLongName("field").withRequired(true).withArgument(abuilder.withName("field").withMinimum(1).withMaximum(1).create()).withDescription("The content field in the index").withShortName("f").create();    Option idFieldOpt = obuilder.withLongName("idField").withRequired(false).withArgument(abuilder.withName("idField").withMinimum(1).withMaximum(1).create()).withDescription("The field for the document ID in the index.  If null, then the Lucene internal doc " + "id is used which is prone to error if the underlying index changes").withShortName("i").create();    Option seqOpt = obuilder.withLongName("seqFileDir").withRequired(true).withArgument(abuilder.withName("seqFileDir").withMinimum(1).withMaximum(1).create()).withDescription("The directory containing Sequence Files for the Clusters").withShortName("s").create();    Option pointsOpt = obuilder.withLongName("pointsDir").withRequired(true).withArgument(abuilder.withName("pointsDir").withMinimum(1).withMaximum(1).create()).withDescription("The directory containing points sequence files mapping input vectors to their cluster.  ").withShortName("p").create();    Option minClusterSizeOpt = obuilder.withLongName("minClusterSize").withRequired(false).withArgument(abuilder.withName("minClusterSize").withMinimum(1).withMaximum(1).create()).withDescription("The minimum number of points required in a cluster to print the labels for").withShortName("m").create();    Option maxLabelsOpt = obuilder.withLongName("maxLabels").withRequired(false).withArgument(abuilder.withName("maxLabels").withMinimum(1).withMaximum(1).create()).withDescription("The maximum number of labels to print per cluster").withShortName("x").create();    Option helpOpt = DefaultOptionCreator.helpOption();    Group group = gbuilder.withName("Options").withOption(indexOpt).withOption(idFieldOpt).withOption(outputOpt).withOption(fieldOpt).withOption(seqOpt).withOption(pointsOpt).withOption(helpOpt).withOption(maxLabelsOpt).withOption(minClusterSizeOpt).create();    try {        Parser parser = new Parser();        parser.setGroup(group);        CommandLine cmdLine = parser.parse(args);        if (cmdLine.hasOption(helpOpt)) {            CommandLineUtil.printHelp(group);            return;        }        Path seqFileDir = new Path(cmdLine.getValue(seqOpt).toString());        Path pointsDir = new Path(cmdLine.getValue(pointsOpt).toString());        String indexDir = cmdLine.getValue(indexOpt).toString();        String contentField = cmdLine.getValue(fieldOpt).toString();        String idField = null;        if (cmdLine.hasOption(idFieldOpt)) {            idField = cmdLine.getValue(idFieldOpt).toString();        }        String output = null;        if (cmdLine.hasOption(outputOpt)) {            output = cmdLine.getValue(outputOpt).toString();        }        int maxLabels = DEFAULT_MAX_LABELS;        if (cmdLine.hasOption(maxLabelsOpt)) {            maxLabels = Integer.parseInt(cmdLine.getValue(maxLabelsOpt).toString());        }        int minSize = DEFAULT_MIN_IDS;        if (cmdLine.hasOption(minClusterSizeOpt)) {            minSize = Integer.parseInt(cmdLine.getValue(minClusterSizeOpt).toString());        }        ClusterLabels clusterLabel = new ClusterLabels(seqFileDir, pointsDir, indexDir, contentField, minSize, maxLabels);        if (idField != null) {            clusterLabel.setIdField(idField);        }        if (output != null) {            clusterLabel.setOutput(output);        }        clusterLabel.getLabels();    } catch (OptionException e) {        log.error("Exception", e);        CommandLineUtil.printHelp(group);    } catch (IOException e) {        log.error("Exception", e);    }}
765beea24a37a0993ca156287624daa0120899f5ffd415f1a12d7683d4e277a7
dumpVectors
public void dumpVectors() throws IOException
{    File file = new File(luceneDir);    Preconditions.checkArgument(file.isDirectory(), "Lucene directory: " + file.getAbsolutePath() + " does not exist or is not a directory");    Preconditions.checkArgument(maxDocs >= 0, "maxDocs must be >= 0");    Preconditions.checkArgument(minDf >= 1, "minDf must be >= 1");    Preconditions.checkArgument(maxDFPercent <= 99, "maxDFPercent must be <= 99");    Directory dir = FSDirectory.open(Paths.get(file.getAbsolutePath()));    IndexReader reader = DirectoryReader.open(dir);    Weight weight;    if ("tf".equalsIgnoreCase(weightType)) {        weight = new TF();    } else if ("tfidf".equalsIgnoreCase(weightType)) {        weight = new TFIDF();    } else {        throw new IllegalArgumentException("Weight type " + weightType + " is not supported");    }    TermInfo termInfo = new CachedTermInfo(reader, field, minDf, maxDFPercent);    LuceneIterable iterable;    if (norm == LuceneIterable.NO_NORMALIZING) {        iterable = new LuceneIterable(reader, idField, field, termInfo, weight, LuceneIterable.NO_NORMALIZING, maxPercentErrorDocs);    } else {        iterable = new LuceneIterable(reader, idField, field, termInfo, weight, norm, maxPercentErrorDocs);    }    log.info("Output File: {}", outFile);    try (VectorWriter vectorWriter = getSeqFileWriter(outFile)) {        long numDocs = vectorWriter.write(iterable, maxDocs);        log.info("Wrote: {} vectors", numDocs);    }    File dictOutFile = new File(dictOut);    log.info("Dictionary Output file: {}", dictOutFile);    Writer writer = Files.newWriter(dictOutFile, Charsets.UTF_8);    try (DelimitedTermInfoWriter tiWriter = new DelimitedTermInfoWriter(writer, delimiter, field)) {        tiWriter.write(termInfo);    }    if (!"".equals(seqDictOut)) {        log.info("SequenceFile Dictionary Output file: {}", seqDictOut);        Path path = new Path(seqDictOut);        Configuration conf = new Configuration();        FileSystem fs = FileSystem.get(conf);        try (SequenceFile.Writer seqWriter = SequenceFile.createWriter(fs, conf, path, Text.class, IntWritable.class)) {            Text term = new Text();            IntWritable termIndex = new IntWritable();            Iterator<TermEntry> termEntries = termInfo.getAllEntries();            while (termEntries.hasNext()) {                TermEntry termEntry = termEntries.next();                term.set(termEntry.getTerm());                termIndex.set(termEntry.getTermIdx());                seqWriter.append(term, termIndex);            }        }    }}
365a24fc75086b6a0e91f9b072bd58c9280846cc05f333f28ede18388f27ce89
main
public static void main(String[] args) throws IOException
{    DefaultOptionBuilder obuilder = new DefaultOptionBuilder();    ArgumentBuilder abuilder = new ArgumentBuilder();    GroupBuilder gbuilder = new GroupBuilder();    Option inputOpt = obuilder.withLongName("dir").withRequired(true).withArgument(abuilder.withName("dir").withMinimum(1).withMaximum(1).create()).withDescription("The Lucene directory").withShortName("d").create();    Option outputOpt = obuilder.withLongName("output").withRequired(true).withArgument(abuilder.withName("output").withMinimum(1).withMaximum(1).create()).withDescription("The output file").withShortName("o").create();    Option fieldOpt = obuilder.withLongName("field").withRequired(true).withArgument(abuilder.withName("field").withMinimum(1).withMaximum(1).create()).withDescription("The field in the index").withShortName("f").create();    Option idFieldOpt = obuilder.withLongName("idField").withRequired(false).withArgument(abuilder.withName("idField").withMinimum(1).withMaximum(1).create()).withDescription("The field in the index containing the index.  If null, then the Lucene internal doc " + "id is used which is prone to error if the underlying index changes").create();    Option dictOutOpt = obuilder.withLongName("dictOut").withRequired(true).withArgument(abuilder.withName("dictOut").withMinimum(1).withMaximum(1).create()).withDescription("The output of the dictionary").withShortName("t").create();    Option seqDictOutOpt = obuilder.withLongName("seqDictOut").withRequired(false).withArgument(abuilder.withName("seqDictOut").withMinimum(1).withMaximum(1).create()).withDescription("The output of the dictionary as sequence file").withShortName("st").create();    Option weightOpt = obuilder.withLongName("weight").withRequired(false).withArgument(abuilder.withName("weight").withMinimum(1).withMaximum(1).create()).withDescription("The kind of weight to use. Currently TF or TFIDF").withShortName("w").create();    Option delimiterOpt = obuilder.withLongName("delimiter").withRequired(false).withArgument(abuilder.withName("delimiter").withMinimum(1).withMaximum(1).create()).withDescription("The delimiter for outputting the dictionary").withShortName("l").create();    Option powerOpt = obuilder.withLongName("norm").withRequired(false).withArgument(abuilder.withName("norm").withMinimum(1).withMaximum(1).create()).withDescription("The norm to use, expressed as either a double or \"INF\" if you want to use the Infinite norm.  " + "Must be greater or equal to 0.  The default is not to normalize").withShortName("n").create();    Option maxOpt = obuilder.withLongName("max").withRequired(false).withArgument(abuilder.withName("max").withMinimum(1).withMaximum(1).create()).withDescription("The maximum number of vectors to output.  If not specified, then it will loop over all docs").withShortName("m").create();    Option minDFOpt = obuilder.withLongName("minDF").withRequired(false).withArgument(abuilder.withName("minDF").withMinimum(1).withMaximum(1).create()).withDescription("The minimum document frequency.  Default is 1").withShortName("md").create();    Option maxDFPercentOpt = obuilder.withLongName("maxDFPercent").withRequired(false).withArgument(abuilder.withName("maxDFPercent").withMinimum(1).withMaximum(1).create()).withDescription("The max percentage of docs for the DF.  Can be used to remove really high frequency terms." + "  Expressed as an integer between 0 and 100. Default is 99.").withShortName("x").create();    Option maxPercentErrorDocsOpt = obuilder.withLongName("maxPercentErrorDocs").withRequired(false).withArgument(abuilder.withName("maxPercentErrorDocs").withMinimum(1).withMaximum(1).create()).withDescription("The max percentage of docs that can have a null term vector. These are noise document and can occur if the " + "analyzer used strips out all terms in the target field. This percentage is expressed as a value " + "between 0 and 1. The default is 0.").withShortName("err").create();    Option helpOpt = obuilder.withLongName("help").withDescription("Print out help").withShortName("h").create();    Group group = gbuilder.withName("Options").withOption(inputOpt).withOption(idFieldOpt).withOption(outputOpt).withOption(delimiterOpt).withOption(helpOpt).withOption(fieldOpt).withOption(maxOpt).withOption(dictOutOpt).withOption(seqDictOutOpt).withOption(powerOpt).withOption(maxDFPercentOpt).withOption(weightOpt).withOption(minDFOpt).withOption(maxPercentErrorDocsOpt).create();    try {        Parser parser = new Parser();        parser.setGroup(group);        CommandLine cmdLine = parser.parse(args);        if (cmdLine.hasOption(helpOpt)) {            CommandLineUtil.printHelp(group);            return;        }        if (cmdLine.hasOption(inputOpt)) {                        Driver luceneDriver = new Driver();            luceneDriver.setLuceneDir(cmdLine.getValue(inputOpt).toString());            if (cmdLine.hasOption(maxOpt)) {                luceneDriver.setMaxDocs(Long.parseLong(cmdLine.getValue(maxOpt).toString()));            }            if (cmdLine.hasOption(weightOpt)) {                luceneDriver.setWeightType(cmdLine.getValue(weightOpt).toString());            }            luceneDriver.setField(cmdLine.getValue(fieldOpt).toString());            if (cmdLine.hasOption(minDFOpt)) {                luceneDriver.setMinDf(Integer.parseInt(cmdLine.getValue(minDFOpt).toString()));            }            if (cmdLine.hasOption(maxDFPercentOpt)) {                luceneDriver.setMaxDFPercent(Integer.parseInt(cmdLine.getValue(maxDFPercentOpt).toString()));            }            if (cmdLine.hasOption(powerOpt)) {                String power = cmdLine.getValue(powerOpt).toString();                if ("INF".equals(power)) {                    luceneDriver.setNorm(Double.POSITIVE_INFINITY);                } else {                    luceneDriver.setNorm(Double.parseDouble(power));                }            }            if (cmdLine.hasOption(idFieldOpt)) {                luceneDriver.setIdField(cmdLine.getValue(idFieldOpt).toString());            }            if (cmdLine.hasOption(maxPercentErrorDocsOpt)) {                luceneDriver.setMaxPercentErrorDocs(Double.parseDouble(cmdLine.getValue(maxPercentErrorDocsOpt).toString()));            }            luceneDriver.setOutFile(cmdLine.getValue(outputOpt).toString());            luceneDriver.setDelimiter(cmdLine.hasOption(delimiterOpt) ? cmdLine.getValue(delimiterOpt).toString() : "\t");            luceneDriver.setDictOut(cmdLine.getValue(dictOutOpt).toString());            if (cmdLine.hasOption(seqDictOutOpt)) {                luceneDriver.setSeqDictOut(cmdLine.getValue(seqDictOutOpt).toString());            }            luceneDriver.dumpVectors();        }    } catch (OptionException e) {        log.error("Exception", e);        CommandLineUtil.printHelp(group);    }}
1e09d65d06e429bce9ad7afb68b7a3aa5e33cd03072870566632dc714493d89d
getSeqFileWriter
private static VectorWriter getSeqFileWriter(String outFile) throws IOException
{    Path path = new Path(outFile);    Configuration conf = new Configuration();    FileSystem fs = FileSystem.get(conf);        SequenceFile.Writer seqWriter = SequenceFile.createWriter(fs, conf, path, LongWritable.class, VectorWritable.class);    return new SequenceFileVectorWriter(seqWriter);}
e0bc6002234b77efeaf5885e7b80ac2a949f53552ce43b85bb8ca75b63f0de14
setLuceneDir
public void setLuceneDir(String luceneDir)
{    this.luceneDir = luceneDir;}
a3c17dd40474926c02a22c4c0d9679c86fb002d0d3b7a5705a791ff8514b5c00
setMaxDocs
public void setMaxDocs(long maxDocs)
{    this.maxDocs = maxDocs;}
c175cda303540a7b34f406fe72db6abde79312ddcc0cb0d1d3a1338ffaeaf517
setWeightType
public void setWeightType(String weightType)
{    this.weightType = weightType;}
2f76bc644774691a019b6753f4d95226e10099cd9dd8e96efde6b8aabf040b93
setField
public void setField(String field)
{    this.field = field;}
70d5ca29988fbba44ea9e512f0f47eecaa5c33333e5cd41a67886c857174039a
setMinDf
public void setMinDf(int minDf)
{    this.minDf = minDf;}
bc69c3163fbe20e512079d465837697a2bcf6034196ddae0935b5a6c808a264d
setMaxDFPercent
public void setMaxDFPercent(int maxDFPercent)
{    this.maxDFPercent = maxDFPercent;}
cce302dee220048623357466b2a0f76076f7cd7276740751aed726f40240cb63
setNorm
public void setNorm(double norm)
{    this.norm = norm;}
238002216d61818153ca0e4a754a809695d919c4328b6fb1b5989499d50fb729
setIdField
public void setIdField(String idField)
{    this.idField = idField;}
e66bf176d57cfda2515fcc46b8e257d88b717f5358dcad5bc17574c599c2ddb3
setOutFile
public void setOutFile(String outFile)
{    this.outFile = outFile;}
af1e8aa824a05a6bc6a79b0ef06eacd2d0efe72b5fe7af8f3beae206505a9aed
setDelimiter
public void setDelimiter(String delimiter)
{    this.delimiter = delimiter;}
518d1cf085d843b02ead634115db7bd25aae22fcaed48255cfc92fdecc50ad4f
setDictOut
public void setDictOut(String dictOut)
{    this.dictOut = dictOut;}
4e9c33a17836cab5c33fd8c1d8c412eeef90e3476328ab1eec8724f261065a23
setSeqDictOut
public void setSeqDictOut(String seqDictOut)
{    this.seqDictOut = seqDictOut;}
cb1078854d118909af99dd68a89cc23d2362351c8e65bf74e592c32d310125e6
setMaxPercentErrorDocs
public void setMaxPercentErrorDocs(double maxPercentErrorDocs)
{    this.maxPercentErrorDocs = maxPercentErrorDocs;}
1b5226f5beec2d8e24f17077e3cf629752caa7dc7c1859a1b913ae4ab3c710ea
iterator
public Iterator<Vector> iterator()
{    return new LuceneIterator(indexReader, idField, field, terminfo, weight, normPower, maxPercentErrorDocs);}
a06ddbaaf37294e5985d491dc1eaebe45721dbcfaeb021faf240be638b48fd07
getVectorName
protected String getVectorName(int documentIndex) throws IOException
{    String name;    if (idField != null) {        name = indexReader.document(documentIndex, idFieldSelector).get(idField);    } else {        name = String.valueOf(documentIndex);    }    return name;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return term.hashCode() ^ inClusterDF ^ outClusterDF ^ RandomUtils.hashDouble(logLikelihoodRatio);}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (!(o instanceof TermInfoClusterInOut)) {        return false;    }    TermInfoClusterInOut other = (TermInfoClusterInOut) o;    return term.equals(other.getTerm()) && inClusterDF == other.getInClusterDF() && outClusterDF == other.getOutClusterDF() && logLikelihoodRatio == other.getLogLikelihoodRatio();}
dedde987114c85d5da35b8d9f072385c6e464089d4c4a53c5e884abe4b2908cd
compareTo
public int compareTo(TermInfoClusterInOut that)
{    int res = Double.compare(that.logLikelihoodRatio, logLikelihoodRatio);    if (res == 0) {        res = term.compareTo(that.term);    }    return res;}
55f1b70ebab26df1f9d9b115356b323db212e01835ede92baeaff590f887e937
getInClusterDiff
public int getInClusterDiff()
{    return this.inClusterDF - this.outClusterDF;}
bbcaf8ef294b209a6fb63af9f49277840ecd2bdbd9881522d07ce7fd01bcb82e
getTerm
 String getTerm()
{    return term;}
b0d189e2e53548571fb9481df38f9f4f211efa5ff6fb0a94fd895fe8ac512489
getInClusterDF
 int getInClusterDF()
{    return inClusterDF;}
266da151c9290c1f40e551dbb4ef47afc4fe717a0ead4b54c82d910680202f2b
getOutClusterDF
 int getOutClusterDF()
{    return outClusterDF;}
418360c4a1c52b5a406cbae7b52a1b36eac398f9cd5e116036254f055fd6df36
getLogLikelihoodRatio
 double getLogLikelihoodRatio()
{    return logLikelihoodRatio;}
4a8d5f5e0e52f999bf3ff32264f09eaa2b67dd92cba6aa32339ac0b2dc78a230
setExpectations
public void setExpectations(String field, long numTerms)
{    this.field = field;    vector = new RandomAccessSparseVector(termInfo.totalTerms(field));    this.numTerms = numTerms;}
647ee630dcf31ec2f2f239e6d06efc727aa25330b33c07048d4291b4eb35bb2f
map
public void map(BytesRef term, int frequency)
{    TermEntry entry = termInfo.getTermEntry(field, term.utf8ToString());    if (entry != null) {        vector.setQuick(entry.getTermIdx(), weight.calculate(frequency, entry.getDocFreq(), (int) numTerms, numDocs));    }}
79cbed8ec593faceb4946ba56ec5347061f2a2b271e2c36d7de0e1f0ae5aa0d3
getVector
public Vector getVector()
{    return this.vector;}
aacecb0f01750d985b78d806dc3c134f0da79efe2752957e0f93ecf5cbf9e492
run
public int run(String[] args) throws Exception
{    addInputOption();    addOutputOption();    Map<String, List<String>> parsedArgs = parseArguments(args);    if (parsedArgs == null) {        return -1;    }    Configuration conf = getConf();    FileSystem fs = FileSystem.get(conf);    Path outputPath = getOutputPath();    Path indexPath = new Path(outputPath, "docIndex");    Path matrixPath = new Path(outputPath, "matrix");    try (SequenceFile.Writer indexWriter = SequenceFile.createWriter(fs, conf, indexPath, IntWritable.class, Text.class);        SequenceFile.Writer matrixWriter = SequenceFile.createWriter(fs, conf, matrixPath, IntWritable.class, VectorWritable.class)) {        IntWritable docId = new IntWritable();        int i = 0;        int numCols = 0;        for (Pair<Text, VectorWritable> record : new SequenceFileDirIterable<Text, VectorWritable>(getInputPath(), PathType.LIST, PathFilters.logsCRCFilter(), null, true, conf)) {            VectorWritable value = record.getSecond();            docId.set(i);            indexWriter.append(docId, record.getFirst());            matrixWriter.append(docId, value);            i++;            numCols = value.get().size();        }        log.info("Wrote out matrix with {} rows and {} columns to {}", i, numCols, matrixPath);        return 0;    }}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    ToolRunner.run(new RowIdJob(), args);}
beea04c16420d19b4e55fdcb0f0d81378da51b387d489afc0a68269fbdadf1de
getTerm
public String getTerm()
{    return term;}
cead1ae3d0b308dac200c6b39314c941c8cf8e74f29644fe2ec717e618896092
getTermIdx
public int getTermIdx()
{    return termIdx;}
db81dad4840cc8cf83cb4a680850fd099e26f3b8705cf2c8ec5d50b7af0755bb
getDocFreq
public int getDocFreq()
{    return docFreq;}
aacecb0f01750d985b78d806dc3c134f0da79efe2752957e0f93ecf5cbf9e492
run
public int run(String[] args) throws Exception
{    /**     *     Option seqOpt = obuilder.withLongName("seqFile").withRequired(false).withArgument(     *     abuilder.withName("seqFile").withMinimum(1).withMaximum(1).create()).withDescription(     *     "The Sequence File containing the Vectors").withShortName("s").create();     *     Option dirOpt = obuilder.withLongName("seqDirectory").withRequired(false).withArgument(     *     abuilder.withName("seqDirectory").withMinimum(1).withMaximum(1).create())     *     .withDescription("The directory containing Sequence File of Vectors")     *     .withShortName("d").create();     */    addInputOption();    addOutputOption();    addOption("useKey", "u", "If the Key is a vector than dump that instead");    addOption("printKey", "p", "Print out the key as well, delimited by tab (or the value if useKey is true");    addOption("dictionary", "d", "The dictionary file.", false);    addOption("dictionaryType", "dt", "The dictionary file type (text|seqfile)", false);    addOption("csv", "c", "Output the Vector as CSV.  Otherwise it substitutes in the terms for vector cell entries");    addOption("namesAsComments", "n", "If using CSV output, optionally add a comment line for each NamedVector " + "(if the vector is one) printing out the name");    addOption("nameOnly", "N", "Use the name as the value for each NamedVector (skip other vectors)");    addOption("sortVectors", "sort", "Sort output key/value pairs of the vector entries in abs magnitude " + "descending order");    addOption("quiet", "q", "Print only file contents");    addOption("sizeOnly", "sz", "Dump only the size of the vector");    addOption("numItems", "ni", "Output at most <n> vecors", false);    addOption("vectorSize", "vs", "Truncate vectors to <vs> length when dumping (most useful when in" + " conjunction with -sort", false);    addOption(buildOption("filter", "fi", "Only dump out those vectors whose name matches the filter." + "  Multiple items may be specified by repeating the argument.", true, 1, Integer.MAX_VALUE, false, null));    if (parseArguments(args, false, true) == null) {        return -1;    }    Path[] pathArr;    Configuration conf = new Configuration();    FileSystem fs = FileSystem.get(conf);    Path input = getInputPath();    FileStatus fileStatus = fs.getFileStatus(input);    if (fileStatus.isDir()) {        pathArr = FileUtil.stat2Paths(fs.listStatus(input, PathFilters.logsCRCFilter()));    } else {        FileStatus[] inputPaths = fs.globStatus(input);        pathArr = new Path[inputPaths.length];        int i = 0;        for (FileStatus fstatus : inputPaths) {            pathArr[i++] = fstatus.getPath();        }    }    String dictionaryType = getOption("dictionaryType", "text");    boolean sortVectors = hasOption("sortVectors");    boolean quiet = hasOption("quiet");    if (!quiet) {        log.info("Sort? {}", sortVectors);    }    String[] dictionary = null;    if (hasOption("dictionary")) {        String dictFile = getOption("dictionary");        switch(dictionaryType) {            case "text":                dictionary = VectorHelper.loadTermDictionary(new File(dictFile));                break;            case "sequencefile":                dictionary = VectorHelper.loadTermDictionary(conf, dictFile);                break;            default:                                throw new IOException("Invalid dictionary type: " + dictionaryType);        }    }    Set<String> filters;    if (hasOption("filter")) {        filters = Sets.newHashSet(getOptions("filter"));    } else {        filters = null;    }    boolean useCSV = hasOption("csv");    boolean sizeOnly = hasOption("sizeOnly");    boolean nameOnly = hasOption("nameOnly");    boolean namesAsComments = hasOption("namesAsComments");    boolean transposeKeyValue = hasOption("vectorAsKey");    Writer writer;    boolean shouldClose;    File output = getOutputFile();    if (output != null) {        shouldClose = true;        log.info("Output file: {}", output);        Files.createParentDirs(output);        writer = Files.newWriter(output, Charsets.UTF_8);    } else {        shouldClose = false;        writer = new OutputStreamWriter(System.out, Charsets.UTF_8);    }    try {        boolean printKey = hasOption("printKey");        if (useCSV && dictionary != null) {            writer.write("#");            for (int j = 0; j < dictionary.length; j++) {                writer.write(dictionary[j]);                if (j < dictionary.length - 1) {                    writer.write(',');                }            }            writer.write('\n');        }        Long numItems = null;        if (hasOption("numItems")) {            numItems = Long.parseLong(getOption("numItems"));            if (quiet) {                writer.append("#Max Items to dump: ").append(String.valueOf(numItems)).append('\n');            }        }        int maxIndexesPerVector = hasOption("vectorSize") ? Integer.parseInt(getOption("vectorSize")) : Integer.MAX_VALUE;        long itemCount = 0;        int fileCount = 0;        for (Path path : pathArr) {            if (numItems != null && numItems <= itemCount) {                break;            }            if (quiet) {                log.info("Processing file '{}' ({}/{})", path, ++fileCount, pathArr.length);            }            SequenceFileIterable<Writable, Writable> iterable = new SequenceFileIterable<>(path, true, conf);            Iterator<Pair<Writable, Writable>> iterator = iterable.iterator();            long i = 0;            while (iterator.hasNext() && (numItems == null || itemCount < numItems)) {                Pair<Writable, Writable> record = iterator.next();                Writable keyWritable = record.getFirst();                Writable valueWritable = record.getSecond();                if (printKey) {                    Writable notTheVectorWritable = transposeKeyValue ? valueWritable : keyWritable;                    writer.write(notTheVectorWritable.toString());                    writer.write('\t');                }                Vector vector;                try {                    vector = ((VectorWritable) (transposeKeyValue ? keyWritable : valueWritable)).get();                } catch (ClassCastException e) {                    if ((transposeKeyValue ? keyWritable : valueWritable) instanceof WeightedPropertyVectorWritable) {                        vector = ((WeightedPropertyVectorWritable) (transposeKeyValue ? keyWritable : valueWritable)).getVector();                    } else {                        throw e;                    }                }                if (filters == null || !(vector instanceof NamedVector) || filters.contains(((NamedVector) vector).getName())) {                    if (sizeOnly) {                        if (vector instanceof NamedVector) {                            writer.write(((NamedVector) vector).getName());                            writer.write(":");                        } else {                            writer.write(String.valueOf(i++));                            writer.write(":");                        }                        writer.write(String.valueOf(vector.size()));                        writer.write('\n');                    } else if (nameOnly) {                        if (vector instanceof NamedVector) {                            writer.write(((NamedVector) vector).getName());                            writer.write('\n');                        }                    } else {                        String fmtStr;                        if (useCSV) {                            fmtStr = VectorHelper.vectorToCSVString(vector, namesAsComments);                        } else {                            fmtStr = VectorHelper.vectorToJson(vector, dictionary, maxIndexesPerVector, sortVectors);                        }                        writer.write(fmtStr);                        writer.write('\n');                    }                    itemCount++;                }            }        }        writer.flush();    } finally {        if (shouldClose) {            Closeables.close(writer, false);        }    }    return 0;}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    ToolRunner.run(new Configuration(), new VectorDumper(), args);}
b221fae7b0e123da488680665891ce502c64ae1f5625a81d82a15097148f11fd
vectorToCSVString
public static String vectorToCSVString(Vector vector, boolean namesAsComments) throws IOException
{    Appendable bldr = new StringBuilder(2048);    vectorToCSVString(vector, namesAsComments, bldr);    return bldr.toString();}
8e8f6a9a1e923be5b11620de76e43577d30c2b64c708ef7401819d8a3d0cd16a
buildJson
public static String buildJson(Iterable<Pair<String, Double>> iterable)
{    return buildJson(iterable, new StringBuilder(2048));}
d38e9d5651dac26519d4fd30d62df9b8179c86e6cfea58b914b0b739d2dd86ed
buildJson
public static String buildJson(Iterable<Pair<String, Double>> iterable, StringBuilder bldr)
{    bldr.append('{');    for (Pair<String, Double> p : iterable) {        bldr.append(p.getFirst());        bldr.append(':');        bldr.append(p.getSecond());        bldr.append(',');    }    if (bldr.length() > 1) {        bldr.setCharAt(bldr.length() - 1, '}');    }    return bldr.toString();}
6f5f68dec07814d5680daa1924ff756729542966349884ccc498b3b704e07a50
topEntries
public static List<Pair<Integer, Double>> topEntries(Vector vector, int maxEntries)
{        int sizeOfNonZeroElementsInVector = vector.getNumNonZeroElements();        if (sizeOfNonZeroElementsInVector < maxEntries) {        maxEntries = sizeOfNonZeroElementsInVector;    }    PriorityQueue<Pair<Integer, Double>> queue = new TDoublePQ<>(-1, maxEntries);    for (Element e : vector.nonZeroes()) {        queue.insertWithOverflow(Pair.of(e.index(), e.get()));    }    List<Pair<Integer, Double>> entries = new ArrayList<>();    Pair<Integer, Double> pair;    while ((pair = queue.pop()) != null) {        if (pair.getFirst() > -1) {            entries.add(pair);        }    }    Collections.sort(entries, new Comparator<Pair<Integer, Double>>() {        @Override        public int compare(Pair<Integer, Double> a, Pair<Integer, Double> b) {            return b.getSecond().compareTo(a.getSecond());        }    });    return entries;}
ebe9275770b8ace8bc7947fd76911f704e89cca7198bdc97f970d7c521800bfa
compare
public int compare(Pair<Integer, Double> a, Pair<Integer, Double> b)
{    return b.getSecond().compareTo(a.getSecond());}
8c9eee39e387188544246ba9b06929376eef354601c123a0777e8658eff02b2e
firstEntries
public static List<Pair<Integer, Double>> firstEntries(Vector vector, int maxEntries)
{    List<Pair<Integer, Double>> entries = new ArrayList<>();    Iterator<Vector.Element> it = vector.nonZeroes().iterator();    int i = 0;    while (it.hasNext() && i++ < maxEntries) {        Vector.Element e = it.next();        entries.add(Pair.of(e.index(), e.get()));    }    return entries;}
efcd916ec912e7df37e956733b88695c70bb3082454457fb99f4a5e77a6349d6
toWeightedTerms
public static List<Pair<String, Double>> toWeightedTerms(Collection<Pair<Integer, Double>> entries, final String[] dictionary)
{    if (dictionary != null) {        return new ArrayList<>(Collections2.transform(entries, new Function<Pair<Integer, Double>, Pair<String, Double>>() {            @Override            public Pair<String, Double> apply(Pair<Integer, Double> p) {                return Pair.of(dictionary[p.getFirst()], p.getSecond());            }        }));    } else {        return new ArrayList<>(Collections2.transform(entries, new Function<Pair<Integer, Double>, Pair<String, Double>>() {            @Override            public Pair<String, Double> apply(Pair<Integer, Double> p) {                return Pair.of(Integer.toString(p.getFirst()), p.getSecond());            }        }));    }}
5b45f8a8c4fecd9688fa66bacec4ecef5139789c32933201e56599961af879e6
apply
public Pair<String, Double> apply(Pair<Integer, Double> p)
{    return Pair.of(dictionary[p.getFirst()], p.getSecond());}
5b45f8a8c4fecd9688fa66bacec4ecef5139789c32933201e56599961af879e6
apply
public Pair<String, Double> apply(Pair<Integer, Double> p)
{    return Pair.of(Integer.toString(p.getFirst()), p.getSecond());}
2dcecc4f14f214f0a4fe30bef0acfa42453fbfd7ef56ff8712a62b06cd84e661
vectorToJson
public static String vectorToJson(Vector vector, String[] dictionary, int maxEntries, boolean sort)
{    return buildJson(toWeightedTerms(sort ? topEntries(vector, maxEntries) : firstEntries(vector, maxEntries), dictionary));}
929eddac60b51d7cdcf18efec1f1c908e1ef86ddd626bee3d2114eb87ca1ee42
vectorToCSVString
public static void vectorToCSVString(Vector vector, boolean namesAsComments, Appendable bldr) throws IOException
{    if (namesAsComments && vector instanceof NamedVector) {        bldr.append('#').append(((NamedVector) vector).getName()).append('\n');    }    Iterator<Vector.Element> iter = vector.all().iterator();    boolean first = true;    while (iter.hasNext()) {        if (first) {            first = false;        } else {            bldr.append(',');        }        Vector.Element elt = iter.next();        bldr.append(String.valueOf(elt.get()));    }    bldr.append('\n');}
9c8213b356196ec0021cb5c129fea0977edf4f2ac721d9ab933442673e3da434
loadTermDictionary
public static String[] loadTermDictionary(File dictFile) throws IOException
{    try (InputStream in = new FileInputStream(dictFile)) {        return loadTermDictionary(in);    }}
cfb7c3c342bdfdd6e2d3e5c1c1090fa19141d6d4d72e73b376d9c38a52202d85
loadTermDictionary
public static String[] loadTermDictionary(Configuration conf, String filePattern)
{    OpenObjectIntHashMap<String> dict = new OpenObjectIntHashMap<>();    int maxIndexValue = 0;    for (Pair<Text, IntWritable> record : new SequenceFileDirIterable<Text, IntWritable>(new Path(filePattern), PathType.GLOB, null, null, true, conf)) {        dict.put(record.getFirst().toString(), record.getSecond().get());        if (record.getSecond().get() > maxIndexValue) {            maxIndexValue = record.getSecond().get();        }    }        int maxDictionarySize = maxIndexValue + 1 > dict.size() ? maxIndexValue + 1 : dict.size();    String[] dictionary = new String[maxDictionarySize];    for (String feature : dict.keys()) {        dictionary[dict.get(feature)] = feature;    }    return dictionary;}
137821baba8209f1913277cdbcb165aa442c397508f071977159d7ac3ee74d7a
loadTermDictionary
private static String[] loadTermDictionary(InputStream is) throws IOException
{    FileLineIterator it = new FileLineIterator(is);    int numEntries = Integer.parseInt(it.next());    String[] result = new String[numEntries];    while (it.hasNext()) {        String line = it.next();        if (line.startsWith("#")) {            continue;        }        String[] tokens = TAB_PATTERN.split(line);        if (tokens.length < 3) {            continue;        }                int index = Integer.parseInt(tokens[2]);        result[index] = tokens[0];    }    return result;}
8162cb9eff2f0a69055fcd402de84d41019cc2d13a0cd8c803247300ef91f8df
lessThan
protected boolean lessThan(Pair<T, Double> a, Pair<T, Double> b)
{    return a.getSecond().compareTo(b.getSecond()) < 0;}
a3af4f688336185adab33fe2c85d1113d50aba0dc8d828070644a496f172eb9a
getSentinelObject
protected Pair<T, Double> getSentinelObject()
{    return Pair.of(sentinel, Double.NEGATIVE_INFINITY);}
2744e05b652c81a1e5d1156ec14cd9d3ad241acc9345cca4ab00cb2a8f50db73
testMemoryLoad
public void testMemoryLoad() throws Exception
{    DataSource dataSource = EasyMock.createMock(DataSource.class);    Connection connection = EasyMock.createMock(Connection.class);    PreparedStatement statement = EasyMock.createMock(PreparedStatement.class);    ResultSet resultSet = EasyMock.createMock(ResultSet.class);    EasyMock.expect(dataSource.getConnection()).andReturn(connection);    EasyMock.expect(connection.prepareStatement(MySQLJDBCInMemoryItemSimilarity.DEFAULT_GET_ALL_ITEMSIMILARITIES_SQL, ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY)).andReturn(statement);    statement.setFetchDirection(ResultSet.FETCH_FORWARD);    EasyMock.expect(statement.executeQuery()).andReturn(resultSet);    EasyMock.expect(resultSet.next()).andReturn(true);    EasyMock.expect(resultSet.getLong(1)).andReturn(1L);    EasyMock.expect(resultSet.getLong(2)).andReturn(2L);    EasyMock.expect(resultSet.getDouble(3)).andReturn(0.5);    EasyMock.expect(resultSet.next()).andReturn(true);    EasyMock.expect(resultSet.getLong(1)).andReturn(1L);    EasyMock.expect(resultSet.getLong(2)).andReturn(3L);    EasyMock.expect(resultSet.getDouble(3)).andReturn(0.4);    EasyMock.expect(resultSet.next()).andReturn(true);    EasyMock.expect(resultSet.getLong(1)).andReturn(3L);    EasyMock.expect(resultSet.getLong(2)).andReturn(4L);    EasyMock.expect(resultSet.getDouble(3)).andReturn(0.1);    EasyMock.expect(resultSet.next()).andReturn(false);    resultSet.close();    statement.close();    connection.close();    EasyMock.replay(dataSource, connection, statement, resultSet);    ItemSimilarity similarity = new MySQLJDBCInMemoryItemSimilarity(dataSource);    assertEquals(0.5, similarity.itemSimilarity(1L, 2L), EPSILON);    assertEquals(0.4, similarity.itemSimilarity(1L, 3L), EPSILON);    assertEquals(0.1, similarity.itemSimilarity(3L, 4L), EPSILON);    assertTrue(Double.isNaN(similarity.itemSimilarity(1L, 4L)));    EasyMock.verify(dataSource, connection, statement, resultSet);}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    super.setUp();    conf = getConfiguration();    fs = FileSystem.get(conf);    testdata = getTestTempDirPath("testdata");    output = getTestTempDirPath("output");        referenceData = TestKmeansClustering.getPointsWritable(REFERENCE);        generateSamples();}
b1f50c8b3656e5f6cd16f24a76f9462b9f0260d01a0c756f1bc242178d6e735f
initData
private void initData(double dC, double dP, DistanceMeasure measure)
{    clusters = new ArrayList<>();    clusters.add(new Canopy(new DenseVector(new double[] { -dC, -dC }), 1, measure));    clusters.add(new Canopy(new DenseVector(new double[] { -dC, dC }), 3, measure));    clusters.add(new Canopy(new DenseVector(new double[] { dC, dC }), 5, measure));    clusters.add(new Canopy(new DenseVector(new double[] { dC, -dC }), 7, measure));    representativePoints = new HashMap<>();    for (Cluster cluster : clusters) {        List<VectorWritable> points = new ArrayList<>();        representativePoints.put(cluster.getId(), points);        points.add(new VectorWritable(cluster.getCenter().clone()));        points.add(new VectorWritable(cluster.getCenter().plus(new DenseVector(new double[] { dP, dP }))));        points.add(new VectorWritable(cluster.getCenter().plus(new DenseVector(new double[] { dP, -dP }))));        points.add(new VectorWritable(cluster.getCenter().plus(new DenseVector(new double[] { -dP, -dP }))));        points.add(new VectorWritable(cluster.getCenter().plus(new DenseVector(new double[] { -dP, dP }))));    }}
42e198191af5245877c197f1f773d163fb657283acf03115b9249b65d7eb192a
generateSamples
private void generateSamples(int num, double mx, double my, double sd)
{    log.info("Generating {} samples m=[{}, {}] sd={}", num, mx, my, sd);    for (int i = 0; i < num; i++) {        sampleData.add(new VectorWritable(new DenseVector(new double[] { UncommonDistributions.rNorm(mx, sd), UncommonDistributions.rNorm(my, sd) })));    }}
93c486cf0bddfe35e5893ff1b8bceb0bb092731d1dbd6accf054b1ca7d6b181b
generateSamples
private void generateSamples()
{    generateSamples(500, 1, 1, 3);    generateSamples(300, 1, 0, 0.5);    generateSamples(300, 0, 2, 0.1);}
3e0a22bdde9c72f73b3b7666a6b41580e1fff11fe748b2a7827bce8bf7622261
testCDbw0
public void testCDbw0() throws IOException
{    ClusteringTestUtils.writePointsToFile(referenceData, getTestTempFilePath("testdata/file1"), fs, conf);    DistanceMeasure measure = new EuclideanDistanceMeasure();    initData(1, 0.25, measure);    CDbwEvaluator evaluator = new CDbwEvaluator(representativePoints, clusters, measure);    System.out.println("CDbw = " + evaluator.getCDbw());    System.out.println("Intra-cluster density = " + evaluator.intraClusterDensity());    System.out.println("Inter-cluster density = " + evaluator.interClusterDensity());    System.out.println("Separation = " + evaluator.separation());}
0875a5b669824410b7ed810d687e4097be544b6105a047721da90a80273aedf1
testCDbw1
public void testCDbw1() throws IOException
{    ClusteringTestUtils.writePointsToFile(referenceData, getTestTempFilePath("testdata/file1"), fs, conf);    DistanceMeasure measure = new EuclideanDistanceMeasure();    initData(1, 0.5, measure);    CDbwEvaluator evaluator = new CDbwEvaluator(representativePoints, clusters, measure);    System.out.println("CDbw = " + evaluator.getCDbw());    System.out.println("Intra-cluster density = " + evaluator.intraClusterDensity());    System.out.println("Inter-cluster density = " + evaluator.interClusterDensity());    System.out.println("Separation = " + evaluator.separation());}
80ad35ecd716c041fbfdb52281f0fe32ab971b69eff1b49d1bdc3e18e2e01646
testCDbw2
public void testCDbw2() throws IOException
{    ClusteringTestUtils.writePointsToFile(referenceData, getTestTempFilePath("testdata/file1"), fs, conf);    DistanceMeasure measure = new EuclideanDistanceMeasure();    initData(1, 0.75, measure);    CDbwEvaluator evaluator = new CDbwEvaluator(representativePoints, clusters, measure);    System.out.println("CDbw = " + evaluator.getCDbw());    System.out.println("Intra-cluster density = " + evaluator.intraClusterDensity());    System.out.println("Inter-cluster density = " + evaluator.interClusterDensity());    System.out.println("Separation = " + evaluator.separation());}
eff170cb061d7bfd9f7d0890b59345166c97248bdc3ea2e5cdd44009bd36a95e
testEmptyCluster
public void testEmptyCluster() throws IOException
{    ClusteringTestUtils.writePointsToFile(referenceData, getTestTempFilePath("testdata/file1"), fs, conf);    DistanceMeasure measure = new EuclideanDistanceMeasure();    initData(1, 0.25, measure);    Canopy cluster = new Canopy(new DenseVector(new double[] { 10, 10 }), 19, measure);    clusters.add(cluster);    List<VectorWritable> points = new ArrayList<>();    representativePoints.put(cluster.getId(), points);    CDbwEvaluator evaluator = new CDbwEvaluator(representativePoints, clusters, measure);    System.out.println("CDbw = " + evaluator.getCDbw());    System.out.println("Intra-cluster density = " + evaluator.intraClusterDensity());    System.out.println("Inter-cluster density = " + evaluator.interClusterDensity());    System.out.println("Separation = " + evaluator.separation());}
dc67274e0a00e5dc05918ec5b6a183eb1a744c6e5879c0f7376bc5a3d57a5b4b
testSingleValueCluster
public void testSingleValueCluster() throws IOException
{    ClusteringTestUtils.writePointsToFile(referenceData, getTestTempFilePath("testdata/file1"), fs, conf);    DistanceMeasure measure = new EuclideanDistanceMeasure();    initData(1, 0.25, measure);    Canopy cluster = new Canopy(new DenseVector(new double[] { 0, 0 }), 19, measure);    clusters.add(cluster);    List<VectorWritable> points = new ArrayList<>();    points.add(new VectorWritable(cluster.getCenter().plus(new DenseVector(new double[] { 1, 1 }))));    representativePoints.put(cluster.getId(), points);    CDbwEvaluator evaluator = new CDbwEvaluator(representativePoints, clusters, measure);    System.out.println("CDbw = " + evaluator.getCDbw());    System.out.println("Intra-cluster density = " + evaluator.intraClusterDensity());    System.out.println("Inter-cluster density = " + evaluator.interClusterDensity());    System.out.println("Separation = " + evaluator.separation());}
3fc992ab76f9bc77d79480b161bf36f61eacc67ffce65d8dbf7293a86cc01c6f
testAllSameValueCluster
public void testAllSameValueCluster() throws IOException
{    ClusteringTestUtils.writePointsToFile(referenceData, getTestTempFilePath("testdata/file1"), fs, conf);    DistanceMeasure measure = new EuclideanDistanceMeasure();    initData(1, 0.25, measure);    Canopy cluster = new Canopy(new DenseVector(new double[] { 0, 0 }), 19, measure);    clusters.add(cluster);    List<VectorWritable> points = new ArrayList<>();    points.add(new VectorWritable(cluster.getCenter()));    points.add(new VectorWritable(cluster.getCenter()));    points.add(new VectorWritable(cluster.getCenter()));    representativePoints.put(cluster.getId(), points);    CDbwEvaluator evaluator = new CDbwEvaluator(representativePoints, clusters, measure);    System.out.println("CDbw = " + evaluator.getCDbw());    System.out.println("Intra-cluster density = " + evaluator.intraClusterDensity());    System.out.println("Inter-cluster density = " + evaluator.interClusterDensity());    System.out.println("Separation = " + evaluator.separation());}
82383f24c41aa35c14b615e2eb82fadb8be1d17d4397221ac9eb6b60b785caaa
testAlmostSameValueCluster
public void testAlmostSameValueCluster() throws IOException
{    ClusteringTestUtils.writePointsToFile(referenceData, getTestTempFilePath("testdata/file1"), fs, conf);    DistanceMeasure measure = new EuclideanDistanceMeasure();    initData(1, 0.25, measure);    Canopy cluster = new Canopy(new DenseVector(new double[] { 0, 0 }), 19, measure);    clusters.add(cluster);    List<VectorWritable> points = new ArrayList<>();    Vector delta = new DenseVector(new double[] { 0, Double.MIN_NORMAL });    points.add(new VectorWritable(delta.clone()));    points.add(new VectorWritable(delta.clone()));    points.add(new VectorWritable(delta.clone()));    points.add(new VectorWritable(delta.clone()));    points.add(new VectorWritable(delta.clone()));    representativePoints.put(cluster.getId(), points);    CDbwEvaluator evaluator = new CDbwEvaluator(representativePoints, clusters, measure);    System.out.println("CDbw = " + evaluator.getCDbw());    System.out.println("Intra-cluster density = " + evaluator.intraClusterDensity());    System.out.println("Inter-cluster density = " + evaluator.interClusterDensity());    System.out.println("Separation = " + evaluator.separation());}
241f752e12cc420fc03d91f04d101af00ae69ad1c37a82c113f6b194114b726e
testCanopy
public void testCanopy() throws Exception
{    ClusteringTestUtils.writePointsToFile(sampleData, getTestTempFilePath("testdata/file1"), fs, conf);    DistanceMeasure measure = new EuclideanDistanceMeasure();    CanopyDriver.run(getConfiguration(), testdata, output, measure, 3.1, 2.1, true, 0.0, true);    int numIterations = 10;    Path clustersIn = new Path(output, "clusters-0-final");    RepresentativePointsDriver.run(conf, clustersIn, new Path(output, "clusteredPoints"), output, measure, numIterations, true);    CDbwEvaluator evaluator = new CDbwEvaluator(conf, clustersIn);            System.out.println("Canopy CDbw = " + evaluator.getCDbw());    System.out.println("Intra-cluster density = " + evaluator.intraClusterDensity());    System.out.println("Inter-cluster density = " + evaluator.interClusterDensity());    System.out.println("Separation = " + evaluator.separation());}
19704c0418601b8b1180fe21b1ffec2052ea95690fe13fb755510bba7cedf063
testKmeans
public void testKmeans() throws Exception
{    ClusteringTestUtils.writePointsToFile(sampleData, getTestTempFilePath("testdata/file1"), fs, conf);    DistanceMeasure measure = new EuclideanDistanceMeasure();        CanopyDriver.run(getConfiguration(), testdata, output, measure, 3.1, 2.1, false, 0.0, true);        Path kmeansOutput = new Path(output, "kmeans");    KMeansDriver.run(testdata, new Path(output, "clusters-0-final"), kmeansOutput, 0.001, 10, true, 0.0, true);    int numIterations = 10;    Path clustersIn = new Path(kmeansOutput, "clusters-10-final");    RepresentativePointsDriver.run(conf, clustersIn, new Path(kmeansOutput, "clusteredPoints"), kmeansOutput, measure, numIterations, true);    CDbwEvaluator evaluator = new CDbwEvaluator(conf, clustersIn);    RepresentativePointsDriver.printRepresentativePoints(kmeansOutput, numIterations);        System.out.println("K-Means CDbw = " + evaluator.getCDbw());    System.out.println("Intra-cluster density = " + evaluator.intraClusterDensity());    System.out.println("Inter-cluster density = " + evaluator.interClusterDensity());    System.out.println("Separation = " + evaluator.separation());}
53ebb8c58524ff3e50819b495a9c0194e252df8c426b4959e87c7f1ecf004e9d
testFuzzyKmeans
public void testFuzzyKmeans() throws Exception
{    ClusteringTestUtils.writePointsToFile(sampleData, getTestTempFilePath("testdata/file1"), fs, conf);    DistanceMeasure measure = new EuclideanDistanceMeasure();        CanopyDriver.run(getConfiguration(), testdata, output, measure, 3.1, 2.1, false, 0.0, true);    Path fuzzyKMeansOutput = new Path(output, "fuzzyk");        FuzzyKMeansDriver.run(testdata, new Path(output, "clusters-0-final"), fuzzyKMeansOutput, 0.001, 10, 2, true, true, 0, true);    int numIterations = 10;    Path clustersIn = new Path(fuzzyKMeansOutput, "clusters-4");    RepresentativePointsDriver.run(conf, clustersIn, new Path(fuzzyKMeansOutput, "clusteredPoints"), fuzzyKMeansOutput, measure, numIterations, true);    CDbwEvaluator evaluator = new CDbwEvaluator(conf, clustersIn);    RepresentativePointsDriver.printRepresentativePoints(fuzzyKMeansOutput, numIterations);        System.out.println("Fuzzy K-Means CDbw = " + evaluator.getCDbw());    System.out.println("Intra-cluster density = " + evaluator.intraClusterDensity());    System.out.println("Inter-cluster density = " + evaluator.interClusterDensity());    System.out.println("Separation = " + evaluator.separation());}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    super.setUp();    Configuration conf = getConfiguration();    FileSystem fs = FileSystem.get(conf);        getSampleData(DOCS);    ClusteringTestUtils.writePointsToFile(sampleData, true, getTestTempFilePath("testdata/file1"), fs, conf);}
54363937a94ba80a15c82147beb63d775c5f6c4813f96509dcdbe5e21f605429
getSampleData
private void getSampleData(String[] docs2) throws IOException
{    sampleData = new ArrayList<>();    RAMDirectory directory = new RAMDirectory();    try (IndexWriter writer = new IndexWriter(directory, new IndexWriterConfig(new StandardAnalyzer()))) {        for (int i = 0; i < docs2.length; i++) {            Document doc = new Document();            Field id = new StringField("id", "doc_" + i, Field.Store.YES);            doc.add(id);                        FieldType fieldType = new FieldType();            fieldType.setStored(false);            fieldType.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);            fieldType.setTokenized(true);            fieldType.setStoreTermVectors(true);            fieldType.setStoreTermVectorPositions(true);            fieldType.setStoreTermVectorOffsets(true);            fieldType.freeze();            Field text = new Field("content", docs2[i], fieldType);            doc.add(text);            writer.addDocument(doc);        }    }    IndexReader reader = DirectoryReader.open(directory);    Weight weight = new TFIDF();    TermInfo termInfo = new CachedTermInfo(reader, "content", 1, 100);    int numTerms = 0;    for (Iterator<TermEntry> it = termInfo.getAllEntries(); it.hasNext(); ) {        it.next();        numTerms++;    }    termDictionary = new String[numTerms];    int i = 0;    for (Iterator<TermEntry> it = termInfo.getAllEntries(); it.hasNext(); ) {        String term = it.next().getTerm();        termDictionary[i] = term;        System.out.println(i + " " + term);        i++;    }    Iterable<Vector> iterable = new LuceneIterable(reader, "id", "content", termInfo, weight);    i = 0;    for (Vector vector : iterable) {        assertNotNull(vector);        NamedVector namedVector;        if (vector instanceof NamedVector) {                        namedVector = new NamedVector(((NamedVector) vector).getDelegate(), "P(" + i + ')');        } else {            namedVector = new NamedVector(vector, "P(" + i + ')');        }        System.out.println(AbstractCluster.formatVector(namedVector, termDictionary));        sampleData.add(new VectorWritable(namedVector));        i++;    }}
faa04018deb73a70e174dad136a3352ad69ce0e00ab0efd3ecfa0ea6b2b13cc8
finalClusterPath
private static Path finalClusterPath(Configuration conf, Path output, int maxIterations) throws IOException
{    FileSystem fs = FileSystem.get(conf);    for (int i = maxIterations; i >= 0; i--) {        Path clusters = new Path(output, "clusters-" + i + "-final");        if (fs.exists(clusters)) {            return clusters;        }    }    return null;}
19704c0418601b8b1180fe21b1ffec2052ea95690fe13fb755510bba7cedf063
testKmeans
public void testKmeans() throws Exception
{    DistanceMeasure measure = new EuclideanDistanceMeasure();    Path input = getTestTempFilePath("input");    Path output = getTestTempDirPath("output");    Path initialPoints = new Path(output, Cluster.CLUSTERS_DIR + '0' + Cluster.FINAL_ITERATION_SUFFIX);    Configuration conf = getConfiguration();    FileSystem fs = FileSystem.get(conf);        ClusteringTestUtils.writePointsToFile(sampleData, input, fs, conf);        RandomSeedGenerator.buildRandom(conf, input, initialPoints, 8, measure, 1L);        Path kMeansOutput = new Path(output, "kmeans");    KMeansDriver.run(conf, getTestTempDirPath("testdata"), initialPoints, kMeansOutput, 0.001, 10, true, 0.0, false);        ClusterDumper clusterDumper = new ClusterDumper(finalClusterPath(conf, output, 10), new Path(kMeansOutput, "clusteredPoints"));    clusterDumper.printClusters(termDictionary);}
d9592d70140480737c3ce37faad4c90ba6b815b9d16794b39b792ca056373647
testJsonClusterDumper
public void testJsonClusterDumper() throws Exception
{    DistanceMeasure measure = new EuclideanDistanceMeasure();    Path input = getTestTempFilePath("input");    Path output = getTestTempDirPath("output");    Path initialPoints = new Path(output, Cluster.CLUSTERS_DIR + '0' + Cluster.FINAL_ITERATION_SUFFIX);    Configuration conf = getConfiguration();    FileSystem fs = FileSystem.get(conf);        ClusteringTestUtils.writePointsToFile(sampleData, input, fs, conf);        RandomSeedGenerator.buildRandom(conf, input, initialPoints, 8, measure, 1L);        Path kmeansOutput = new Path(output, "kmeans");    KMeansDriver.run(conf, getTestTempDirPath("testdata"), initialPoints, kmeansOutput, 0.001, 10, true, 0.0, false);        ClusterDumper clusterDumper = new ClusterDumper(finalClusterPath(conf, output, 10), new Path(kmeansOutput, "clusteredPoints"));    clusterDumper.setOutputFormat(ClusterDumper.OUTPUT_FORMAT.JSON);    clusterDumper.printClusters(termDictionary);}
53ebb8c58524ff3e50819b495a9c0194e252df8c426b4959e87c7f1ecf004e9d
testFuzzyKmeans
public void testFuzzyKmeans() throws Exception
{    DistanceMeasure measure = new EuclideanDistanceMeasure();    Path input = getTestTempFilePath("input");    Path output = getTestTempDirPath("output");    Path initialPoints = new Path(output, Cluster.CLUSTERS_DIR + '0' + Cluster.FINAL_ITERATION_SUFFIX);    Configuration conf = getConfiguration();    FileSystem fs = FileSystem.get(conf);        ClusteringTestUtils.writePointsToFile(sampleData, input, fs, conf);        RandomSeedGenerator.buildRandom(conf, input, initialPoints, 8, measure, 1L);        Path kMeansOutput = new Path(output, "kmeans");    FuzzyKMeansDriver.run(conf, getTestTempDirPath("testdata"), initialPoints, kMeansOutput, 0.001, 10, 1.1f, true, true, 0, true);        ClusterDumper clusterDumper = new ClusterDumper(finalClusterPath(conf, output, 10), new Path(kMeansOutput, "clusteredPoints"));    clusterDumper.printClusters(termDictionary);}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    super.setUp();    conf = getConfiguration();    fs = FileSystem.get(conf);    testdata = getTestTempDirPath("testdata");    output = getTestTempDirPath("output");        referenceData = TestKmeansClustering.getPointsWritable(REFERENCE);        generateSamples();}
42e198191af5245877c197f1f773d163fb657283acf03115b9249b65d7eb192a
generateSamples
private void generateSamples(int num, double mx, double my, double sd)
{    log.info("Generating {} samples m=[{}, {}] sd={}", num, mx, my, sd);    for (int i = 0; i < num; i++) {        sampleData.add(new VectorWritable(new DenseVector(new double[] { UncommonDistributions.rNorm(mx, sd), UncommonDistributions.rNorm(my, sd) })));    }}
93c486cf0bddfe35e5893ff1b8bceb0bb092731d1dbd6accf054b1ca7d6b181b
generateSamples
private void generateSamples()
{    generateSamples(500, 1, 1, 3);    generateSamples(300, 1, 0, 0.5);    generateSamples(300, 0, 2, 0.1);}
81f84dc0fb99a17542a13b007eac6abb828c63758757f82cb8fd7295961ee96c
printRepPoints
private void printRepPoints(int numIterations)
{    RepresentativePointsDriver.printRepresentativePoints(output, numIterations);}
b1f50c8b3656e5f6cd16f24a76f9462b9f0260d01a0c756f1bc242178d6e735f
initData
private void initData(double dC, double dP, DistanceMeasure measure)
{    clusters = Lists.newArrayList();    clusters.add(new Canopy(new DenseVector(new double[] { -dC, -dC }), 1, measure));    clusters.add(new Canopy(new DenseVector(new double[] { -dC, dC }), 3, measure));    clusters.add(new Canopy(new DenseVector(new double[] { dC, dC }), 5, measure));    clusters.add(new Canopy(new DenseVector(new double[] { dC, -dC }), 7, measure));    representativePoints = Maps.newHashMap();    for (Cluster cluster : clusters) {        List<VectorWritable> points = Lists.newArrayList();        representativePoints.put(cluster.getId(), points);        points.add(new VectorWritable(cluster.getCenter().clone()));        points.add(new VectorWritable(cluster.getCenter().plus(new DenseVector(new double[] { dP, dP }))));        points.add(new VectorWritable(cluster.getCenter().plus(new DenseVector(new double[] { dP, -dP }))));        points.add(new VectorWritable(cluster.getCenter().plus(new DenseVector(new double[] { -dP, -dP }))));        points.add(new VectorWritable(cluster.getCenter().plus(new DenseVector(new double[] { -dP, dP }))));    }}
9947d35615ce798ff7d1458da25348a934069f2e1b57586e7e10564325d19a0d
testRepresentativePoints
public void testRepresentativePoints() throws Exception
{    ClusteringTestUtils.writePointsToFile(referenceData, new Path(testdata, "file1"), fs, conf);    DistanceMeasure measure = new EuclideanDistanceMeasure();    Configuration conf = getConfiguration();        CanopyDriver.run(conf, testdata, output, measure, 3.1, 1.1, true, 0.0, true);    int numIterations = 2;    Path clustersIn = new Path(output, "clusters-0-final");    RepresentativePointsDriver.run(conf, clustersIn, new Path(output, "clusteredPoints"), output, measure, numIterations, false);    printRepPoints(numIterations);    ClusterEvaluator evaluatorMR = new ClusterEvaluator(conf, clustersIn);        HadoopUtil.delete(conf, output);    CanopyDriver.run(conf, testdata, output, measure, 3.1, 1.1, true, 0.0, true);    RepresentativePointsDriver.run(conf, clustersIn, new Path(output, "clusteredPoints"), output, measure, numIterations, true);    printRepPoints(numIterations);    ClusterEvaluator evaluatorSeq = new ClusterEvaluator(conf, clustersIn);        assertEquals("InterCluster Density", evaluatorMR.interClusterDensity(), evaluatorSeq.interClusterDensity(), EPSILON);    assertEquals("IntraCluster Density", evaluatorMR.intraClusterDensity(), evaluatorSeq.intraClusterDensity(), EPSILON);}
1c596dcc67912c6b32c465ea234b16932495feaeb1704ae27aed08fc75404cb5
testCluster0
public void testCluster0() throws IOException
{    ClusteringTestUtils.writePointsToFile(referenceData, new Path(testdata, "file1"), fs, conf);    DistanceMeasure measure = new EuclideanDistanceMeasure();    initData(1, 0.25, measure);    ClusterEvaluator evaluator = new ClusterEvaluator(representativePoints, clusters, measure);    assertEquals("inter cluster density", 0.33333333333333315, evaluator.interClusterDensity(), EPSILON);    assertEquals("intra cluster density", 0.3656854249492381, evaluator.intraClusterDensity(), EPSILON);}
d1e7c4b2c3088901974fe02492cdcf42e751e8a491ca2c55087fde7f00312b5a
testCluster1
public void testCluster1() throws IOException
{    ClusteringTestUtils.writePointsToFile(referenceData, new Path(testdata, "file1"), fs, conf);    DistanceMeasure measure = new EuclideanDistanceMeasure();    initData(1, 0.5, measure);    ClusterEvaluator evaluator = new ClusterEvaluator(representativePoints, clusters, measure);    assertEquals("inter cluster density", 0.33333333333333315, evaluator.interClusterDensity(), EPSILON);    assertEquals("intra cluster density", 0.3656854249492381, evaluator.intraClusterDensity(), EPSILON);}
6cea894f15143a71300b48bf076e5cfce402dc52684e72a2a3b0d040ea24d0b3
testCluster2
public void testCluster2() throws IOException
{    ClusteringTestUtils.writePointsToFile(referenceData, new Path(testdata, "file1"), fs, conf);    DistanceMeasure measure = new EuclideanDistanceMeasure();    initData(1, 0.75, measure);    ClusterEvaluator evaluator = new ClusterEvaluator(representativePoints, clusters, measure);    assertEquals("inter cluster density", 0.33333333333333315, evaluator.interClusterDensity(), EPSILON);    assertEquals("intra cluster density", 0.3656854249492381, evaluator.intraClusterDensity(), EPSILON);}
eff170cb061d7bfd9f7d0890b59345166c97248bdc3ea2e5cdd44009bd36a95e
testEmptyCluster
public void testEmptyCluster() throws IOException
{    ClusteringTestUtils.writePointsToFile(referenceData, new Path(testdata, "file1"), fs, conf);    DistanceMeasure measure = new EuclideanDistanceMeasure();    initData(1, 0.25, measure);    Canopy cluster = new Canopy(new DenseVector(new double[] { 10, 10 }), 19, measure);    clusters.add(cluster);    List<VectorWritable> points = Lists.newArrayList();    representativePoints.put(cluster.getId(), points);    ClusterEvaluator evaluator = new ClusterEvaluator(representativePoints, clusters, measure);    assertEquals("inter cluster density", 0.371534146934532, evaluator.interClusterDensity(), EPSILON);    assertEquals("intra cluster density", 0.3656854249492381, evaluator.intraClusterDensity(), EPSILON);}
dc67274e0a00e5dc05918ec5b6a183eb1a744c6e5879c0f7376bc5a3d57a5b4b
testSingleValueCluster
public void testSingleValueCluster() throws IOException
{    ClusteringTestUtils.writePointsToFile(referenceData, new Path(testdata, "file1"), fs, conf);    DistanceMeasure measure = new EuclideanDistanceMeasure();    initData(1, 0.25, measure);    Canopy cluster = new Canopy(new DenseVector(new double[] { 0, 0 }), 19, measure);    clusters.add(cluster);    List<VectorWritable> points = Lists.newArrayList();    points.add(new VectorWritable(cluster.getCenter().plus(new DenseVector(new double[] { 1, 1 }))));    representativePoints.put(cluster.getId(), points);    ClusterEvaluator evaluator = new ClusterEvaluator(representativePoints, clusters, measure);    assertEquals("inter cluster density", 0.3656854249492381, evaluator.interClusterDensity(), EPSILON);    assertEquals("intra cluster density", 0.3656854249492381, evaluator.intraClusterDensity(), EPSILON);}
3fc992ab76f9bc77d79480b161bf36f61eacc67ffce65d8dbf7293a86cc01c6f
testAllSameValueCluster
public void testAllSameValueCluster() throws IOException
{    ClusteringTestUtils.writePointsToFile(referenceData, new Path(testdata, "file1"), fs, conf);    DistanceMeasure measure = new EuclideanDistanceMeasure();    initData(1, 0.25, measure);    Canopy cluster = new Canopy(new DenseVector(new double[] { 0, 0 }), 19, measure);    clusters.add(cluster);    List<VectorWritable> points = Lists.newArrayList();    points.add(new VectorWritable(cluster.getCenter()));    points.add(new VectorWritable(cluster.getCenter()));    points.add(new VectorWritable(cluster.getCenter()));    representativePoints.put(cluster.getId(), points);    ClusterEvaluator evaluator = new ClusterEvaluator(representativePoints, clusters, measure);    assertEquals("inter cluster density", 0.3656854249492381, evaluator.interClusterDensity(), EPSILON);    assertEquals("intra cluster density", 0.3656854249492381, evaluator.intraClusterDensity(), EPSILON);}
241f752e12cc420fc03d91f04d101af00ae69ad1c37a82c113f6b194114b726e
testCanopy
public void testCanopy() throws Exception
{    ClusteringTestUtils.writePointsToFile(sampleData, new Path(testdata, "file1"), fs, conf);    DistanceMeasure measure = new EuclideanDistanceMeasure();    Configuration conf = getConfiguration();    CanopyDriver.run(conf, testdata, output, measure, 3.1, 1.1, true, 0.0, true);    int numIterations = 10;    Path clustersIn = new Path(output, "clusters-0-final");    RepresentativePointsDriver.run(conf, clustersIn, new Path(output, "clusteredPoints"), output, measure, numIterations, true);        ClusterEvaluator evaluator = new ClusterEvaluator(conf, clustersIn);        System.out.println("Intra-cluster density = " + evaluator.intraClusterDensity());    System.out.println("Inter-cluster density = " + evaluator.interClusterDensity());}
19704c0418601b8b1180fe21b1ffec2052ea95690fe13fb755510bba7cedf063
testKmeans
public void testKmeans() throws Exception
{    ClusteringTestUtils.writePointsToFile(sampleData, new Path(testdata, "file1"), fs, conf);    DistanceMeasure measure = new EuclideanDistanceMeasure();        Configuration conf = getConfiguration();    CanopyDriver.run(conf, testdata, output, measure, 3.1, 1.1, false, 0.0, true);        Path kmeansOutput = new Path(output, "kmeans");    KMeansDriver.run(testdata, new Path(output, "clusters-0-final"), kmeansOutput, 0.001, 10, true, 0.0, true);    int numIterations = 10;    Path clustersIn = new Path(kmeansOutput, "clusters-2");    RepresentativePointsDriver.run(conf, clustersIn, new Path(kmeansOutput, "clusteredPoints"), kmeansOutput, measure, numIterations, true);    RepresentativePointsDriver.printRepresentativePoints(kmeansOutput, numIterations);    ClusterEvaluator evaluator = new ClusterEvaluator(conf, clustersIn);        System.out.println("Intra-cluster density = " + evaluator.intraClusterDensity());    System.out.println("Inter-cluster density = " + evaluator.interClusterDensity());}
53ebb8c58524ff3e50819b495a9c0194e252df8c426b4959e87c7f1ecf004e9d
testFuzzyKmeans
public void testFuzzyKmeans() throws Exception
{    ClusteringTestUtils.writePointsToFile(sampleData, new Path(testdata, "file1"), fs, conf);    DistanceMeasure measure = new EuclideanDistanceMeasure();        Configuration conf = getConfiguration();    CanopyDriver.run(conf, testdata, output, measure, 3.1, 1.1, false, 0.0, true);    Path fuzzyKMeansOutput = new Path(output, "fuzzyk");        FuzzyKMeansDriver.run(testdata, new Path(output, "clusters-0-final"), fuzzyKMeansOutput, 0.001, 10, 2, true, true, 0, true);    int numIterations = 10;    Path clustersIn = new Path(fuzzyKMeansOutput, "clusters-4");    RepresentativePointsDriver.run(conf, clustersIn, new Path(fuzzyKMeansOutput, "clusteredPoints"), fuzzyKMeansOutput, measure, numIterations, true);    RepresentativePointsDriver.printRepresentativePoints(fuzzyKMeansOutput, numIterations);    ClusterEvaluator evaluator = new ClusterEvaluator(conf, clustersIn);        System.out.println("Intra-cluster density = " + evaluator.intraClusterDensity());    System.out.println("Inter-cluster density = " + evaluator.interClusterDensity());}
6e5c795a53af63776843191257346ff7d30a164b6e17057cdb46911f4eb210f8
getField1
public String getField1()
{    return field1;}
4ed488ffa6cff04c3f021535015c46c51ddb28b7e71da7820c69a130a7184088
getField2
public String getField2()
{    return field2;}
8d5c38472e30c073678885588d92cb7d3e0e5e112a9c9ae10f3c1b4ff10faec6
asLuceneDocument
public Document asLuceneDocument()
{    Document document = super.asLuceneDocument();    document.add(new TextField(FIELD1, this.field1, Field.Store.YES));    document.add(new TextField(FIELD2, this.field2, Field.Store.YES));    return document;}
8d5c38472e30c073678885588d92cb7d3e0e5e112a9c9ae10f3c1b4ff10faec6
asLuceneDocument
public Document asLuceneDocument()
{    Document document = new Document();    document.add(new StringField(ID_FIELD, getId(), Field.Store.YES));    document.add(new TextField(FIELD, getField(), Field.Store.YES));    document.add(new IntField(NUMERIC_FIELD, numericField, Field.Store.YES));    return document;}
bf30ff6a14a211a8d962ea07381e2b1ad244ef677d88baa9b24a4e7ee1ea1829
getNumericField
public int getNumericField()
{    return numericField;}
09e8f13a9a603d31d64bb498b77d15572483824d843d0e82a570643192f62186
getId
public String getId()
{    return id;}
4dcc7d0c4558908ab7129cb32315486269dd7db4a2cfa4394355f8b8a199c928
getField
public String getField()
{    return field;}
8d5c38472e30c073678885588d92cb7d3e0e5e112a9c9ae10f3c1b4ff10faec6
asLuceneDocument
public Document asLuceneDocument()
{    Document document = new Document();    Field idField = new StringField(ID_FIELD, getId(), Field.Store.YES);    Field field = new TextField(FIELD, getField(), Field.Store.YES);    document.add(idField);    document.add(field);    return document;}
8d5c38472e30c073678885588d92cb7d3e0e5e112a9c9ae10f3c1b4ff10faec6
asLuceneDocument
public Document asLuceneDocument()
{    Document document = super.asLuceneDocument();    document.add(new StringField(UNSTORED_FIELD, "", Field.Store.NO));    return document;}
c0a069a84874cb28b9bc483c9f82b8517b410e3d483d8700d5931a654863fa26
testAnalysis
public void testAnalysis() throws Exception
{    Analyzer analyzer = new MailArchivesClusteringAnalyzer();    String text = "A test message\n" + "atokenthatistoolongtobeusefulforclustertextanalysis\n" + "Mahout is a scalable, machine-learning LIBRARY\n" + "we've added some additional stopwords such as html, mailto, regards\t" + "apache_hadoop provides the foundation for scalability\n" + "www.nabble.com general-help@incubator.apache.org\n" + "public void int protected package";    Reader reader = new StringReader(text);            String[] expectedTokens = { "test", "mahout", "scalabl", "machin", "learn", "librari", "weve", "ad", "stopword", "apache_hadoop", "provid", "foundat", "scalabl" };    TokenStream tokenStream = analyzer.tokenStream("test", reader);    assertNotNull(tokenStream);    tokenStream.reset();    CharTermAttribute termAtt = tokenStream.addAttribute(CharTermAttribute.class);    int e = 0;    while (tokenStream.incrementToken() && e < expectedTokens.length) {        assertEquals(expectedTokens[e++], termAtt.toString());    }    assertEquals(e, expectedTokens.length);    tokenStream.end();    tokenStream.close();}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    super.setUp();    inputDir = getTestTempDir("mail-archives-in");        File subDir = new File(inputDir, "subdir");    subDir.mkdir();    File gzFile = new File(subDir, "mail-messages.gz");    try (GZIPOutputStream gzOut = new GZIPOutputStream(new FileOutputStream(gzFile))) {        gzOut.write(testMailMessages.getBytes("UTF-8"));        gzOut.finish();    }    File subDir2 = new File(subDir, "subsubdir");    subDir2.mkdir();    File gzFile2 = new File(subDir2, "mail-messages-2.gz");    try (GZIPOutputStream gzOut = new GZIPOutputStream(new FileOutputStream(gzFile2))) {        gzOut.write(testMailMessages.getBytes("UTF-8"));        gzOut.finish();    }}
83b1c53eed0865556fb92be510a86abfc630568ac51f1e184bca8e7c83c35582
testSequential
public void testSequential() throws Exception
{    File outputDir = this.getTestTempDir("mail-archives-out");    String[] args = { "--input", inputDir.getAbsolutePath(), "--output", outputDir.getAbsolutePath(), "--charset", "UTF-8", "--keyPrefix", "TEST", "--method", "sequential", "--body", "--subject", "--separator", "" };        SequenceFilesFromMailArchives.main(args);        File expectedChunkFile = new File(outputDir, "chunk-0");    String expectedChunkPath = expectedChunkFile.getAbsolutePath();    Assert.assertTrue("Expected chunk file " + expectedChunkPath + " not found!", expectedChunkFile.isFile());    Configuration conf = getConfiguration();    SequenceFileIterator<Text, Text> iterator = new SequenceFileIterator<>(new Path(expectedChunkPath), true, conf);    Assert.assertTrue("First key/value pair not found!", iterator.hasNext());    Pair<Text, Text> record = iterator.next();    File parentFile = new File(new File(new File("TEST"), "subdir"), "mail-messages.gz");    Assert.assertEquals(new File(parentFile, testVars[0][0]).toString(), record.getFirst().toString());    Assert.assertEquals(testVars[0][1] + testVars[0][2], record.getSecond().toString());    Assert.assertTrue("Second key/value pair not found!", iterator.hasNext());    record = iterator.next();    Assert.assertEquals(new File(parentFile, testVars[1][0]).toString(), record.getFirst().toString());    Assert.assertEquals(testVars[1][1] + testVars[1][2], record.getSecond().toString());    record = iterator.next();    File parentFileSubSubDir = new File(new File(new File(new File("TEST"), "subdir"), "subsubdir"), "mail-messages-2.gz");    Assert.assertEquals(new File(parentFileSubSubDir, testVars[0][0]).toString(), record.getFirst().toString());    Assert.assertEquals(testVars[0][1] + testVars[0][2], record.getSecond().toString());    Assert.assertTrue("Second key/value pair not found!", iterator.hasNext());    record = iterator.next();    Assert.assertEquals(new File(parentFileSubSubDir, testVars[1][0]).toString(), record.getFirst().toString());    Assert.assertEquals(testVars[1][1] + testVars[1][2], record.getSecond().toString());    Assert.assertFalse("Only two key/value pairs expected!", iterator.hasNext());}
f8c59304da1a4fd1ea52bcd9d2e39c3cc0111e56da7bf343b64f7372b549db9f
testMapReduce
public void testMapReduce() throws Exception
{    Path tmpDir = getTestTempDirPath();    Path mrOutputDir = new Path(tmpDir, "mail-archives-out-mr");    Configuration configuration = getConfiguration();    FileSystem fs = FileSystem.get(configuration);    File expectedInputFile = new File(inputDir.toString());    String[] args = { "-Dhadoop.tmp.dir=" + configuration.get("hadoop.tmp.dir"), "--input", expectedInputFile.getAbsolutePath(), "--output", mrOutputDir.toString(), "--charset", "UTF-8", "--keyPrefix", "TEST", "--method", "mapreduce", "--body", "--subject", "--separator", "" };        SequenceFilesFromMailArchives.main(args);        FileStatus[] fileStatuses = fs.listStatus(mrOutputDir.suffix("/part-m-00000"));        assertEquals(1, fileStatuses.length);    assertEquals("part-m-00000", fileStatuses[0].getPath().getName());    SequenceFileIterator<Text, Text> iterator = new SequenceFileIterator<>(mrOutputDir.suffix("/part-m-00000"), true, configuration);    Assert.assertTrue("First key/value pair not found!", iterator.hasNext());    Pair<Text, Text> record = iterator.next();    File parentFileSubSubDir = new File(new File(new File(new File("TEST"), "subdir"), "subsubdir"), "mail-messages-2.gz");    String expected = record.getFirst().toString();    if (SystemUtils.IS_OS_WINDOWS) {        expected = expected.replace("/", "\\");    }    Assert.assertEquals(new File(parentFileSubSubDir, testVars[0][0]).toString(), expected);    Assert.assertEquals(testVars[0][1] + testVars[0][2], record.getSecond().toString());    Assert.assertTrue("Second key/value pair not found!", iterator.hasNext());    record = iterator.next();    expected = record.getFirst().toString();    if (SystemUtils.IS_OS_WINDOWS) {        expected = expected.replace("/", "\\");    }    Assert.assertEquals(new File(parentFileSubSubDir, testVars[1][0]).toString(), expected);    Assert.assertEquals(testVars[1][1] + testVars[1][2], record.getSecond().toString());        File parentFile = new File(new File(new File("TEST"), "subdir"), "mail-messages.gz");    record = iterator.next();    expected = record.getFirst().toString();    if (SystemUtils.IS_OS_WINDOWS) {        expected = expected.replace("/", "\\");    }    Assert.assertEquals(new File(parentFile, testVars[0][0]).toString(), expected);    Assert.assertEquals(testVars[0][1] + testVars[0][2], record.getSecond().toString());    Assert.assertTrue("Second key/value pair not found!", iterator.hasNext());    record = iterator.next();    expected = record.getFirst().toString();    if (SystemUtils.IS_OS_WINDOWS) {        expected = expected.replace("/", "\\");    }    Assert.assertEquals(new File(parentFile, testVars[1][0]).toString(), expected);    Assert.assertEquals(testVars[1][1] + testVars[1][2], record.getSecond().toString());    Assert.assertFalse("Only four key/value pairs expected!", iterator.hasNext());}
50dec78a3246c66d1f1077fa5021604b0b396ea488918ec580feb329b787f269
accept
public boolean accept(Path path)
{    return path.getName().startsWith("t") || path.getName().startsWith("r") || path.getName().startsWith("f");}
6be7a1f7bb2495493f7b61afa6bb0cae1865a6cce8ab34bfc6db3db134feb66b
testSequenceFileFromDirectoryBasic
public void testSequenceFileFromDirectoryBasic() throws Exception
{        Configuration configuration = getConfiguration();    FileSystem fs = FileSystem.get(configuration);        Path tmpDir = this.getTestTempDirPath();    Path inputDir = new Path(tmpDir, "inputDir");    fs.mkdirs(inputDir);    Path outputDir = new Path(tmpDir, "outputDir");    Path outputDirRecursive = new Path(tmpDir, "outputDirRecursive");    Path inputDirRecursive = new Path(tmpDir, "inputDirRecur");    fs.mkdirs(inputDirRecursive);        createFilesFromArrays(configuration, inputDir, DATA1);    SequenceFilesFromDirectory.main(new String[] { "--input", inputDir.toString(), "--output", outputDir.toString(), "--chunkSize", "64", "--charset", Charsets.UTF_8.name(), "--keyPrefix", "UID", "--method", "sequential" });        checkChunkFiles(configuration, outputDir, DATA1, "UID");    createRecursiveDirFilesFromArrays(configuration, inputDirRecursive, DATA2);    FileStatus fstInputPath = fs.getFileStatus(inputDirRecursive);    String dirs = HadoopUtil.buildDirList(fs, fstInputPath);    System.out.println("\n\n ----- recursive dirs: " + dirs);    SequenceFilesFromDirectory.main(new String[] { "--input", inputDirRecursive.toString(), "--output", outputDirRecursive.toString(), "--chunkSize", "64", "--charset", Charsets.UTF_8.name(), "--keyPrefix", "UID", "--method", "sequential" });    checkRecursiveChunkFiles(configuration, outputDirRecursive, DATA2, "UID");}
2f6bac264f8b96dcb9611b60b132fcef2b0d4325bfb9c527a2c93fe0a9b05788
testSequenceFileFromDirectoryMapReduce
public void testSequenceFileFromDirectoryMapReduce() throws Exception
{    Configuration conf = getConfiguration();    FileSystem fs = FileSystem.get(conf);        Path tmpDir = this.getTestTempDirPath();    Path inputDir = new Path(tmpDir, "inputDir");    fs.mkdirs(inputDir);    Path inputDirRecur = new Path(tmpDir, "inputDirRecur");    fs.mkdirs(inputDirRecur);    Path mrOutputDir = new Path(tmpDir, "mrOutputDir");    Path mrOutputDirRecur = new Path(tmpDir, "mrOutputDirRecur");    createFilesFromArrays(conf, inputDir, DATA1);    SequenceFilesFromDirectory.main(new String[] { "-Dhadoop.tmp.dir=" + conf.get("hadoop.tmp.dir"), "--input", inputDir.toString(), "--output", mrOutputDir.toString(), "--chunkSize", "64", "--charset", Charsets.UTF_8.name(), "--method", "mapreduce", "--keyPrefix", "UID", "--fileFilterClass", "org.apache.mahout.text.TestPathFilter" });    checkMRResultFiles(conf, mrOutputDir, DATA1, "UID");    createRecursiveDirFilesFromArrays(conf, inputDirRecur, DATA2);    FileStatus fst_input_path = fs.getFileStatus(inputDirRecur);    String dirs = HadoopUtil.buildDirList(fs, fst_input_path);    logger.info("\n\n ---- recursive dirs: {}", dirs);    SequenceFilesFromDirectory.main(new String[] { "-Dhadoop.tmp.dir=" + conf.get("hadoop.tmp.dir"), "--input", inputDirRecur.toString(), "--output", mrOutputDirRecur.toString(), "--chunkSize", "64", "--charset", Charsets.UTF_8.name(), "--method", "mapreduce", "--keyPrefix", "UID", "--fileFilterClass", "org.apache.mahout.text.TestPathFilter" });    checkMRResultFilesRecursive(conf, mrOutputDirRecur, DATA2, "UID");}
dbbb1b69f570851ce94ea622f0e16461972f792274b32efc27b7c2bf5cc350fb
createFilesFromArrays
private static void createFilesFromArrays(Configuration conf, Path inputDir, String[][] data) throws IOException
{    FileSystem fs = FileSystem.get(conf);    for (String[] aData : data) {        try (OutputStreamWriter writer = new OutputStreamWriter(fs.create(new Path(inputDir, aData[0])), Charsets.UTF_8)) {            writer.write(aData[1]);        }    }}
69e2d90550e5009858fe839d102c5bfe3d311176d33f4456f5812acad87460f9
createRecursiveDirFilesFromArrays
private static void createRecursiveDirFilesFromArrays(Configuration configuration, Path inputDir, String[][] data) throws IOException
{    FileSystem fs = FileSystem.get(configuration);    logger.info("creativeRecursiveDirFilesFromArrays > based on: {}", inputDir.toString());    Path curPath;    String currentRecursiveDir = inputDir.toString();    for (String[] aData : data) {        currentRecursiveDir += "/" + aData[0];        File subDir = new File(currentRecursiveDir);        subDir.mkdir();        curPath = new Path(subDir.toString(), "file.txt");        logger.info("Created file: {}", curPath.toString());        try (OutputStreamWriter writer = new OutputStreamWriter(fs.create(curPath), Charsets.UTF_8)) {            writer.write(aData[1]);        }    }}
2f9d3045ffbfa5be3f0094e8eb8eac073d143f99476bbd081a9c26ce662d7d44
checkChunkFiles
private static void checkChunkFiles(Configuration configuration, Path outputDir, String[][] data, String prefix) throws IOException
{    FileSystem fs = FileSystem.get(configuration);        FileStatus[] fileStatuses = fs.listStatus(outputDir, PathFilters.logsCRCFilter());        assertEquals(1, fileStatuses.length);    assertEquals("chunk-0", fileStatuses[0].getPath().getName());    Map<String, String> fileToData = new HashMap<>();    for (String[] aData : data) {        fileToData.put(prefix + Path.SEPARATOR + aData[0], aData[1]);    }        try (SequenceFileIterator<Text, Text> iterator = new SequenceFileIterator<>(fileStatuses[0].getPath(), true, configuration)) {        while (iterator.hasNext()) {            Pair<Text, Text> record = iterator.next();            String retrievedData = fileToData.get(record.getFirst().toString().trim());            assertNotNull(retrievedData);            assertEquals(retrievedData, record.getSecond().toString().trim());        }    }}
18b80cca8d727dff7f56ae47d64770b1ec14f2f511f808c75b8a449c50c92513
checkRecursiveChunkFiles
private static void checkRecursiveChunkFiles(Configuration configuration, Path outputDir, String[][] data, String prefix) throws IOException
{    FileSystem fs = FileSystem.get(configuration);    System.out.println(" ----------- check_Recursive_ChunkFiles ------------");        FileStatus[] fileStatuses = fs.listStatus(outputDir, PathFilters.logsCRCFilter());        assertEquals(1, fileStatuses.length);    assertEquals("chunk-0", fileStatuses[0].getPath().getName());    Map<String, String> fileToData = new HashMap<>();    String currentPath = prefix;    for (String[] aData : data) {        currentPath += Path.SEPARATOR + aData[0];        fileToData.put(currentPath + Path.SEPARATOR + "file.txt", aData[1]);    }        try (SequenceFileIterator<Text, Text> iterator = new SequenceFileIterator<>(fileStatuses[0].getPath(), true, configuration)) {        while (iterator.hasNext()) {            Pair<Text, Text> record = iterator.next();            String retrievedData = fileToData.get(record.getFirst().toString().trim());            System.out.printf("%s >> %s\n", record.getFirst().toString().trim(), record.getSecond().toString().trim());            assertNotNull(retrievedData);            assertEquals(retrievedData, record.getSecond().toString().trim());            System.out.printf(">>> k: %s, v: %s\n", record.getFirst().toString(), record.getSecond().toString());        }    }}
fbc439151542d2d8f17f9c200f74d3c5a6d5a0c3bacc868aacff1e6f5975d766
checkMRResultFiles
private static void checkMRResultFiles(Configuration conf, Path outputDir, String[][] data, String prefix) throws IOException
{    FileSystem fs = FileSystem.get(conf);        FileStatus[] fileStatuses = fs.listStatus(outputDir.suffix("/part-m-00000"), PathFilters.logsCRCFilter());        assertEquals(1, fileStatuses.length);    assertEquals("part-m-00000", fileStatuses[0].getPath().getName());    Map<String, String> fileToData = new HashMap<>();    for (String[] aData : data) {        System.out.printf("map.put: %s %s\n", prefix + Path.SEPARATOR + aData[0], aData[1]);        fileToData.put(prefix + Path.SEPARATOR + aData[0], aData[1]);    }        try (SequenceFileIterator<Text, Text> iterator = new SequenceFileIterator<>(fileStatuses[0].getPath(), true, conf)) {        while (iterator.hasNext()) {            Pair<Text, Text> record = iterator.next();            String retrievedData = fileToData.get(record.getFirst().toString().trim());            System.out.printf("MR> %s >> %s\n", record.getFirst().toString().trim(), record.getSecond().toString().trim());            assertNotNull(retrievedData);            assertEquals(retrievedData, record.getSecond().toString().trim());        }    }}
ee71fdb1fd52078242e8786cd605005291e00d2b07f6435d8fecb63e560a832e
checkMRResultFilesRecursive
private static void checkMRResultFilesRecursive(Configuration configuration, Path outputDir, String[][] data, String prefix) throws IOException
{    FileSystem fs = FileSystem.get(configuration);        FileStatus[] fileStatuses = fs.listStatus(outputDir.suffix("/part-m-00000"), PathFilters.logsCRCFilter());        assertEquals(1, fileStatuses.length);    assertEquals("part-m-00000", fileStatuses[0].getPath().getName());    Map<String, String> fileToData = new HashMap<>();    String currentPath = prefix;    for (String[] aData : data) {        currentPath += Path.SEPARATOR + aData[0];        fileToData.put(currentPath + Path.SEPARATOR + "file.txt", aData[1]);    }        try (SequenceFileIterator<Text, Text> iterator = new SequenceFileIterator<>(fileStatuses[0].getPath(), true, configuration)) {        while (iterator.hasNext()) {            Pair<Text, Text> record = iterator.next();            System.out.printf("MR-Recur > Trying to check: %s\n", record.getFirst().toString().trim());            String retrievedData = fileToData.get(record.getFirst().toString().trim());            assertNotNull(retrievedData);            assertEquals(retrievedData, record.getSecond().toString().trim());        }    }}
b5184db37a0324a9810952bbb66163e4a3128d32be020e2c9c8d047812740391
testIncrement
public void testIncrement() throws Exception
{    Iterator<Integer> ref = Lists.newArrayList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 14, 16, 18, 20, 25, 30, 35, 40, 50, 60, 70, 80, 100, 120, 140, 160, 180, 200, 250, 300, 350, 400, 500, 600, 700, 800, 1000, 1200, 1400, 1600, 1800, 2000, 2500, 3000, 3500, 4000, 5000, 6000, 7000).iterator();    Bump125 b = new Bump125();    for (int i = 0; i < 50; i++) {        long x = b.increment();        assertEquals(ref.next().longValue(), x);    }}
8acf55463c6a1291ce788406d51ab309fbbeff778f6b5f2833b03fb993a887d1
testLabel
public void testLabel() throws Exception
{    StringWriter writer = new StringWriter();    MailOptions options = new MailOptions();    options.setSeparator(":::");    options.setCharset(Charsets.UTF_8);    options.setPatternsToMatch(new Pattern[] { MailProcessor.FROM_PREFIX, MailProcessor.SUBJECT_PREFIX, MailProcessor.TO_PREFIX });    options.setInput(new File(System.getProperty("user.dir")));    MailProcessor proc = new MailProcessor(options, "", writer);    URL url = MailProcessorTest.class.getClassLoader().getResource("test.mbox");    File file = new File(url.toURI());    long count = proc.parseMboxLineByLine(file);    assertEquals(7, count);}
851022a5d63a0b2b8121a34856c3d896a375cf1fda6f68593cdce529dfc6afed
testStripQuoted
public void testStripQuoted() throws Exception
{    StringWriter writer = new StringWriter();    MailOptions options = new MailOptions();    options.setSeparator(":::");    options.setCharset(Charsets.UTF_8);    options.setPatternsToMatch(new Pattern[] { MailProcessor.SUBJECT_PREFIX });    options.setInput(new File(System.getProperty("user.dir")));    options.setIncludeBody(true);    MailProcessor proc = new MailProcessor(options, "", writer);    URL url = MailProcessorTest.class.getClassLoader().getResource("test.mbox");    File file = new File(url.toURI());    long count = proc.parseMboxLineByLine(file);    assertEquals(7, count);    assertTrue(writer.getBuffer().toString().contains("> Cocoon Cron Block Configurable Clustering"));    writer = new StringWriter();    proc = new MailProcessor(options, "", writer);    options.setStripQuotedText(true);    count = proc.parseMboxLineByLine(file);    assertEquals(7, count);    assertFalse(writer.getBuffer().toString().contains("> Cocoon Cron Block Configurable Clustering"));}
c48abbc78f9bf5cc31d89af37cbb4303ff9720d57f8afa5337b774da84d15c46
testFilter
public void testFilter() throws IOException
{    Filter filter = getFilter(filterTokens);    Key k = new Key();    for (String s : filterTokens) {        setKey(k, s);        assertTrue("Key for string " + s + " should be filter member", filter.membershipTest(k));    }    for (String s : notFilterTokens) {        setKey(k, s);        assertFalse("Key for string " + s + " should not be filter member", filter.membershipTest(k));    }}
5280435223a4ff3241072da052ccccc2f71ae0d0a447b0055d84a2f2db7d36fe
testAnalyzer
public void testAnalyzer() throws IOException
{    Reader reader = new StringReader(input);    Analyzer analyzer = new WhitespaceAnalyzer();    TokenStream ts = analyzer.tokenStream(null, reader);    ts.reset();    validateTokens(allTokens, ts);    ts.end();    ts.close();}
b706c1c08160c50ec01e09045ad54715904d16dfbb08cb01da15f4bdda640feb
testNonKeepdAnalyzer
public void testNonKeepdAnalyzer() throws IOException
{    Reader reader = new StringReader(input);    Analyzer analyzer = new WhitespaceAnalyzer();    TokenStream ts = analyzer.tokenStream(null, reader);    ts.reset();    TokenStream f = new BloomTokenFilter(getFilter(filterTokens), false, /* toss matching tokens */    ts);    validateTokens(expectedNonKeepTokens, f);    ts.end();    ts.close();}
5681c9decc6ea820de567876c221e237e929b1a721297b21e47830936f29d1c5
testKeepAnalyzer
public void testKeepAnalyzer() throws IOException
{    Reader reader = new StringReader(input);    Analyzer analyzer = new WhitespaceAnalyzer();    TokenStream ts = analyzer.tokenStream(null, reader);    ts.reset();    TokenStream f = new BloomTokenFilter(getFilter(filterTokens), true, /* keep matching tokens */    ts);    validateTokens(expectedKeepTokens, f);    ts.end();    ts.close();}
f0b3b3c1c458077ffcaf064ce41201e20dde57130b50102191c883088697fb7e
testShingleFilteredAnalyzer
public void testShingleFilteredAnalyzer() throws IOException
{    Reader reader = new StringReader(input);    Analyzer analyzer = new WhitespaceAnalyzer();    TokenStream ts = analyzer.tokenStream(null, reader);    ts.reset();    ShingleFilter sf = new ShingleFilter(ts, 3);    TokenStream f = new BloomTokenFilter(getFilter(shingleKeepTokens), true, sf);    validateTokens(expectedShingleTokens, f);    ts.end();    ts.close();}
d91a3f527e885c57bdb83f3539c6f0595ca72c2f3cb5beec7c9558b949783838
setKey
private static void setKey(Key k, String s) throws IOException
{    ByteBuffer buffer = encoder.encode(CharBuffer.wrap(s.toCharArray()));    k.set(buffer.array(), 1.0);}
b458267c22f131205616bebd19308661d0c0433458aa9644f0d20f5f76437a07
validateTokens
private static void validateTokens(String[] expected, TokenStream ts) throws IOException
{    int pos = 0;    while (ts.incrementToken()) {        assertTrue("Analyzer produced too many tokens", pos <= expected.length);        CharTermAttribute termAttr = ts.getAttribute(CharTermAttribute.class);        assertEquals("Unexpected term", expected[pos++], termAttr.toString());    }    assertEquals("Analyzer produced too few terms", expected.length, pos);}
6d099cebe07f05ec693941321ebbe7160f2c0e3a1cfc1b32b1f819423dbc3d92
getFilter
private static Filter getFilter(String[] tokens) throws IOException
{    Filter filter = new BloomFilter(100, 50, Hash.JENKINS_HASH);    Key k = new Key();    for (String s : tokens) {        setKey(k, s);        filter.add(k);    }    return filter;}
008e62195312ea4b9888f394da4cb6f0b418f3853decffd0b53d7d169b1af964
testRegex
public void testRegex() throws Exception
{    RegexMapper mapper = new RegexMapper();    Configuration conf = getConfiguration();    conf.set(RegexMapper.REGEX, "(?<=(\\?|&)q=).*?(?=&|$)");    conf.set(RegexMapper.TRANSFORMER_CLASS, URLDecodeTransformer.class.getName());    DummyRecordWriter<LongWritable, Text> mapWriter = new DummyRecordWriter<>();    Mapper<LongWritable, Text, LongWritable, Text>.Context mapContext = DummyRecordWriter.build(mapper, conf, mapWriter);    mapper.setup(mapContext);    for (int i = 0; i < RegexUtilsTest.TEST_STRS.length; i++) {        String testStr = RegexUtilsTest.TEST_STRS[i];        LongWritable key = new LongWritable(i);        mapper.map(key, new Text(testStr), mapContext);        List<Text> value = mapWriter.getValue(key);        if (!RegexUtilsTest.GOLD[i].isEmpty()) {            assertEquals(1, value.size());            assertEquals(RegexUtilsTest.GOLD[i], value.get(0).toString());        }    }}
53870a3467923621e314f9989eed127a6cd5e23a4918a91026076b5fc821a77e
testGroups
public void testGroups() throws Exception
{    RegexMapper mapper = new RegexMapper();    Configuration conf = getConfiguration();    conf.set(RegexMapper.REGEX, "(\\d+)\\.(\\d+)\\.(\\d+)");    conf.set(RegexMapper.TRANSFORMER_CLASS, URLDecodeTransformer.class.getName());    conf.setStrings(RegexMapper.GROUP_MATCHERS, "1", "3");    DummyRecordWriter<LongWritable, Text> mapWriter = new DummyRecordWriter<>();    Mapper<LongWritable, Text, LongWritable, Text>.Context mapContext = DummyRecordWriter.build(mapper, conf, mapWriter);    mapper.setup(mapContext);    for (int i = 0; i < RegexUtilsTest.TEST_STRS.length; i++) {        String testStr = RegexUtilsTest.TEST_STRS[i];        LongWritable key = new LongWritable(i);        mapper.map(key, new Text(testStr), mapContext);        List<Text> value = mapWriter.getValue(key);        assertEquals(1, value.size());        assertEquals("127 0", value.get(0).toString());    }}
666fe4269d147130a026737eda74529d10baa2005cc5ef85dcd0eb0815b08e70
testFPGFormatter
public void testFPGFormatter() throws Exception
{    RegexMapper mapper = new RegexMapper();    Configuration conf = getConfiguration();    conf.set(RegexMapper.REGEX, "(?<=(\\?|&)q=).*?(?=&|$)");    conf.set(RegexMapper.TRANSFORMER_CLASS, URLDecodeTransformer.class.getName());    conf.set(RegexMapper.FORMATTER_CLASS, FPGFormatter.class.getName());    DummyRecordWriter<LongWritable, Text> mapWriter = new DummyRecordWriter<>();    Mapper<LongWritable, Text, LongWritable, Text>.Context mapContext = DummyRecordWriter.build(mapper, conf, mapWriter);    mapper.setup(mapContext);    RegexFormatter formatter = new FPGFormatter();    for (int i = 0; i < RegexUtilsTest.TEST_STRS.length; i++) {        String testStr = RegexUtilsTest.TEST_STRS[i];        LongWritable key = new LongWritable(i);        mapper.map(key, new Text(testStr), mapContext);        List<Text> value = mapWriter.getValue(key);        if (!RegexUtilsTest.GOLD[i].isEmpty()) {            assertEquals(1, value.size());            assertEquals(formatter.format(RegexUtilsTest.GOLD[i]), value.get(0).toString());        }    }}
d68e28d2ec2ec7bf4b6fca65b465918b8526959e3ad8e586b28e0a35a9a5d9d7
testExtract
public void testExtract() throws Exception
{    Pattern pattern = Pattern.compile("(?<=(\\?|&)q=).*?(?=&|$)");    String line = "127.0.0.1 -  -  [24/05/2010:01:19:22 +0000] \"GET /solr/select?q=import statement&start=1 HTTP/1.1\" 200 37571";    String res = RegexUtils.extract(line, pattern, Collections.<Integer>emptyList(), " ", RegexUtils.IDENTITY_TRANSFORMER);    assertEquals(res, "import statement", res);    for (int i = 0; i < TEST_STRS.length; i++) {        String testStr = TEST_STRS[i];        res = RegexUtils.extract(testStr, pattern, Collections.<Integer>emptyList(), " ", new URLDecodeTransformer());        assertEquals(GOLD[i], res);    }    pattern = Pattern.compile("((?<=(\\?|&)q=)(.*?)(?=(&|$))|(?<=((\\?|&)start=))(\\d+))");    res = RegexUtils.extract(line, pattern, Collections.<Integer>emptyList(), " ", RegexUtils.IDENTITY_TRANSFORMER);    assertEquals(res, "import statement 1", res);    pattern = Pattern.compile("(start=1) HTTP");    Collection<Integer> groupsToKeep = new ArrayList<>();    groupsToKeep.add(1);    res = RegexUtils.extract(line, pattern, groupsToKeep, " ", RegexUtils.IDENTITY_TRANSFORMER);    assertEquals(res, "start=1", res);}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    Configuration conf = getConfiguration();    fs = FileSystem.get(conf);    super.setUp();    countMap = new OpenObjectIntHashMap<>();    charset = Charsets.UTF_8;    tempSequenceDirectory = getTestTempFilePath("tmpsequence");    tempInputFile = getTestTempFilePath("bayesinputfile");    tempTrainingDirectory = getTestTempDirPath("bayestrain");    tempTestDirectory = getTestTempDirPath("bayestest");    tempMapRedOutputDirectory = new Path(getTestTempDirPath(), "mapRedOutput");    tempInputDirectory = getTestTempDirPath("bayesinputdir");    si = new SplitInput();    si.setTrainingOutputDirectory(tempTrainingDirectory);    si.setTestOutputDirectory(tempTestDirectory);    si.setInputDirectory(tempInputDirectory);}
8f8b7e50e6d0e2876f6fe84228152782a1f15793dfa183715147bf6561ed5dc8
writeMultipleInputFiles
private void writeMultipleInputFiles() throws IOException
{    Writer writer = null;    String currentLabel = null;    try {        for (String[] entry : ClassifierData.DATA) {            if (!entry[0].equals(currentLabel)) {                currentLabel = entry[0];                Closeables.close(writer, false);                writer = new BufferedWriter(new OutputStreamWriter(fs.create(new Path(tempInputDirectory, currentLabel)), Charsets.UTF_8));            }            countMap.adjustOrPutValue(currentLabel, 1, 1);            writer.write(currentLabel + '\t' + entry[1] + '\n');        }    } finally {        Closeables.close(writer, false);    }}
d86b4d42ef637d259d43054300b6bdff556c42de3c1a7eb97f9b2633c5f0f09f
writeSingleInputFile
private void writeSingleInputFile() throws IOException
{    Writer writer = new BufferedWriter(new OutputStreamWriter(fs.create(tempInputFile), Charsets.UTF_8));    try {        for (String[] entry : ClassifierData.DATA) {            writer.write(entry[0] + '\t' + entry[1] + '\n');        }    } finally {        Closeables.close(writer, true);    }}
209b4810db8d677a6bf775c335ce0c79d90f15fabddca5509e4acc9d163c3182
testSplitDirectory
public void testSplitDirectory() throws Exception
{    writeMultipleInputFiles();    final int testSplitSize = 1;    si.setTestSplitSize(testSplitSize);    si.setCallback(new SplitInput.SplitCallback() {        @Override        public void splitComplete(Path inputFile, int lineCount, int trainCount, int testCount, int testSplitStart) {            int trainingLines = countMap.get(inputFile.getName()) - testSplitSize;            assertSplit(fs, inputFile, charset, testSplitSize, trainingLines, tempTrainingDirectory, tempTestDirectory);        }    });    si.splitDirectory(tempInputDirectory);}
d83c056ce12fdc2a9d1c2822a8faf8488bee042c3055f63f82fe3413cc681f99
splitComplete
public void splitComplete(Path inputFile, int lineCount, int trainCount, int testCount, int testSplitStart)
{    int trainingLines = countMap.get(inputFile.getName()) - testSplitSize;    assertSplit(fs, inputFile, charset, testSplitSize, trainingLines, tempTrainingDirectory, tempTestDirectory);}
5f17a25e1ee394f5df84806c6f40359c66a6e7983f0e3928c3b4ea702afac31b
testSplitFile
public void testSplitFile() throws Exception
{    writeSingleInputFile();    si.setTestSplitSize(2);    si.setCallback(new TestCallback(2, 10));    si.splitFile(tempInputFile);}
bbd45da81b5d2c0edb10587020b18dff571600521d7aa0bdabd0547ee5434748
testSplitFileLocation
public void testSplitFileLocation() throws Exception
{    writeSingleInputFile();    si.setTestSplitSize(2);    si.setSplitLocation(50);    si.setCallback(new TestCallback(2, 10));    si.splitFile(tempInputFile);}
e6b0aa5cc8b04fb5d422b6f36cefdeb81f18dc5c5d3800c334bd5a70b5214ec2
testSplitFilePct
public void testSplitFilePct() throws Exception
{    writeSingleInputFile();    si.setTestSplitPct(25);    si.setCallback(new TestCallback(3, 9));    si.splitFile(tempInputFile);}
305ba625b5aafce034b5fb475c8d6e1276ffa229a4f90615f557ebf0c5da9841
testSplitFilePctLocation
public void testSplitFilePctLocation() throws Exception
{    writeSingleInputFile();    si.setTestSplitPct(25);    si.setSplitLocation(50);    si.setCallback(new TestCallback(3, 9));    si.splitFile(tempInputFile);}
5bc5e7421405eca570e5453c54e10101763e04e04d39ba97e3047ebade745053
testSplitFileRandomSelectionSize
public void testSplitFileRandomSelectionSize() throws Exception
{    writeSingleInputFile();    si.setTestRandomSelectionSize(5);    si.setCallback(new TestCallback(5, 7));    si.splitFile(tempInputFile);}
ada4c1e5dd0ad5e2b3339721dc526e0c641bef32998692e1e89aa8861ca8ac23
testSplitFileRandomSelectionPct
public void testSplitFileRandomSelectionPct() throws Exception
{    writeSingleInputFile();    si.setTestRandomSelectionPct(25);    si.setCallback(new TestCallback(3, 9));    si.splitFile(tempInputFile);}
52f119d5d452c1ab1573287b4d07e77436dcd0152199d315b6963aee5c0f1786
writeVectorSequenceFile
private void writeVectorSequenceFile(Path path, int testPoints) throws IOException
{    Path tempSequenceFile = new Path(path, "part-00000");    Configuration conf = getConfiguration();    IntWritable key = new IntWritable();    VectorWritable value = new VectorWritable();    try (SequenceFile.Writer writer = SequenceFile.createWriter(fs, conf, tempSequenceFile, IntWritable.class, VectorWritable.class)) {        for (int i = 0; i < testPoints; i++) {            key.set(i);            Vector v = new SequentialAccessSparseVector(4);            v.assign(i);            value.set(v);            writer.append(key, value);        }    }}
fe9fcff1c379a6015a5584e04a897b88baf478ff7617fd780656c20e0ecd8aee
writeTextSequenceFile
private void writeTextSequenceFile(Path path, int testPoints) throws IOException
{    Path tempSequenceFile = new Path(path, "part-00000");    Configuration conf = getConfiguration();    Text key = new Text();    Text value = new Text();    try (SequenceFile.Writer writer = SequenceFile.createWriter(fs, conf, tempSequenceFile, Text.class, Text.class)) {        for (int i = 0; i < testPoints; i++) {            key.set(Integer.toString(i));            value.set("Line " + i);            writer.append(key, value);        }    }}
fe63baa3be5545b4940eb87f1bddaefe947ae259ff66600162c41cd1d2c246d2
displaySequenceFile
private void displaySequenceFile(Path sequenceFilePath) throws IOException
{    for (Pair<?, ?> record : new SequenceFileIterable<>(sequenceFilePath, true, getConfiguration())) {        System.out.println(record.getFirst() + "\t" + record.getSecond());    }}
23aaa2523577c7473c7125938de95d468a4acd5a66305fdd4ba23e09814f3864
getNumberRecords
private int getNumberRecords(Path sequenceFilePath) throws IOException
{    int numberRecords = 0;    for (Object value : new SequenceFileValueIterable<>(sequenceFilePath, true, getConfiguration())) {        numberRecords++;    }    return numberRecords;}
9776c7a0b89b991017028a859d43b47eca19f07809571244c37364eda0af57b5
testSplitInputMapReduceText
public void testSplitInputMapReduceText() throws Exception
{    writeTextSequenceFile(tempSequenceDirectory, 1000);    testSplitInputMapReduce(1000);}
de5d358f4d6c381c2e5fc72e3c34757ea4155baa66380f84923f716e460959fc
testSplitInputMapReduceTextCli
public void testSplitInputMapReduceTextCli() throws Exception
{    writeTextSequenceFile(tempSequenceDirectory, 1000);    testSplitInputMapReduceCli(1000);}
86e356a5e77f750196717fd0ad4bf5ff13ef246c1e981fae1a44d04dd85672e3
testSplitInputMapReduceVector
public void testSplitInputMapReduceVector() throws Exception
{    writeVectorSequenceFile(tempSequenceDirectory, 1000);    testSplitInputMapReduce(1000);}
da728c93d43b2db7640275e9321ada40e6886aa77b59fa9a602304d2055aa505
testSplitInputMapReduceVectorCli
public void testSplitInputMapReduceVectorCli() throws Exception
{    writeVectorSequenceFile(tempSequenceDirectory, 1000);    testSplitInputMapReduceCli(1000);}
0e174668009680b5e1bb256085308b86e10658ef9e76bf24a5f79091c79f1bcf
testSplitInputMapReduceCli
private void testSplitInputMapReduceCli(int numPoints) throws Exception
{    int randomSelectionPct = 25;    int keepPct = 10;    String[] args = { "--method", "mapreduce", "--input", tempSequenceDirectory.toString(), "--mapRedOutputDir", tempMapRedOutputDirectory.toString(), "--randomSelectionPct", Integer.toString(randomSelectionPct), "--keepPct", Integer.toString(keepPct), "-ow" };    ToolRunner.run(getConfiguration(), new SplitInput(), args);    validateSplitInputMapReduce(numPoints, randomSelectionPct, keepPct);}
818241e09bbff2b4855e946f22654bc509f4ad23d97df993d61d508a8205aae6
testSplitInputMapReduce
private void testSplitInputMapReduce(int numPoints) throws Exception
{    int randomSelectionPct = 25;    si.setTestRandomSelectionPct(randomSelectionPct);    int keepPct = 10;    si.setKeepPct(keepPct);    si.setMapRedOutputDirectory(tempMapRedOutputDirectory);    si.setUseMapRed(true);    si.splitDirectory(getConfiguration(), tempSequenceDirectory);    validateSplitInputMapReduce(numPoints, randomSelectionPct, keepPct);}
1ac52e721179147d2084c1b671e72cc3213012c138c079054f352d03fc89f6ef
validateSplitInputMapReduce
private void validateSplitInputMapReduce(int numPoints, int randomSelectionPct, int keepPct) throws IOException
{    Path testPath = new Path(tempMapRedOutputDirectory, "test-r-00000");    Path trainingPath = new Path(tempMapRedOutputDirectory, "training-r-00000");    int numberTestRecords = getNumberRecords(testPath);    int numberTrainingRecords = getNumberRecords(trainingPath);    System.out.printf("Test data: %d records\n", numberTestRecords);    displaySequenceFile(testPath);    System.out.printf("Training data: %d records\n", numberTrainingRecords);    displaySequenceFile(trainingPath);    assertEquals((randomSelectionPct / 100.0) * (keepPct / 100.0) * numPoints, numberTestRecords, 2);    assertEquals((1 - randomSelectionPct / 100.0) * (keepPct / 100.0) * numPoints, numberTrainingRecords, 2);}
77d787d4ceab54272b1247c8f2604a4eef88bd35410d56126f55e8f735a8e2e3
testValidate
public void testValidate() throws Exception
{    SplitInput st = new SplitInput();    assertValidateException(st);    st.setTestSplitSize(100);    assertValidateException(st);    st.setTestOutputDirectory(tempTestDirectory);    assertValidateException(st);    st.setTrainingOutputDirectory(tempTrainingDirectory);    st.validate();    st.setTestSplitPct(50);    assertValidateException(st);    st = new SplitInput();    st.setTestRandomSelectionPct(50);    st.setTestOutputDirectory(tempTestDirectory);    st.setTrainingOutputDirectory(tempTrainingDirectory);    st.validate();    st.setTestSplitPct(50);    assertValidateException(st);    st = new SplitInput();    st.setTestRandomSelectionPct(50);    st.setTestOutputDirectory(tempTestDirectory);    st.setTrainingOutputDirectory(tempTrainingDirectory);    st.validate();    st.setTestSplitSize(100);    assertValidateException(st);}
d83c056ce12fdc2a9d1c2822a8faf8488bee042c3055f63f82fe3413cc681f99
splitComplete
public void splitComplete(Path inputFile, int lineCount, int trainCount, int testCount, int testSplitStart)
{    assertSplit(fs, tempInputFile, charset, testSplitSize, trainingLines, tempTrainingDirectory, tempTestDirectory);}
58bab12d9682d6b17c8b71f1b5ee412c4accb3140eaabc8afe790471f6d22398
assertValidateException
private static void assertValidateException(SplitInput st) throws IOException
{    try {        st.validate();        fail("Expected IllegalArgumentException");    } catch (IllegalArgumentException iae) {        }}
813cb3e5dd87124b1f0bff51544a5376d027466d793e03bc5d643f56edb2fa3c
assertSplit
private static void assertSplit(FileSystem fs, Path tempInputFile, Charset charset, int testSplitSize, int trainingLines, Path tempTrainingDirectory, Path tempTestDirectory)
{    try {        Path testFile = new Path(tempTestDirectory, tempInputFile.getName());                assertEquals("test line count", testSplitSize, SplitInput.countLines(fs, testFile, charset));        Path trainingFile = new Path(tempTrainingDirectory, tempInputFile.getName());                assertEquals("training line count", trainingLines, SplitInput.countLines(fs, trainingFile, charset));    } catch (IOException ioe) {        fail(ioe.toString());    }}
22c356e4864b19dcfc9196986aa58c33d0ad5b2d0f761d00c31031dcbfe35e77
removeQuotes
public void removeQuotes()
{    assertNull(ARFFType.removeQuotes(null));    assertEquals("", ARFFType.removeQuotes("\"\""));    assertEquals("", ARFFType.removeQuotes("''"));    assertEquals("", ARFFType.removeQuotes(""));    assertEquals("", ARFFType.removeQuotes("  "));    assertEquals("single", ARFFType.removeQuotes("'single'"));    assertEquals("double", ARFFType.removeQuotes("\"double\""));    assertEquals("trim", ARFFType.removeQuotes(" trim "));}
97f859374249930519bed4c7c695cdc7967bbd624222f619bf1154196da465e3
testValues
public void testValues() throws Exception
{    ARFFVectorIterable iterable = readModelFromResource("sample.arff");    assertEquals("Mahout", iterable.getModel().getRelation());    Map<String, Integer> bindings = iterable.getModel().getLabelBindings();    assertNotNull(bindings);    assertEquals(5, bindings.size());    Iterator<Vector> iter = iterable.iterator();    assertTrue(iter.hasNext());    Vector next = iter.next();    assertNotNull(next);    assertTrue("Wrong instanceof", next instanceof DenseVector);    assertEquals(1.0, next.get(0), EPSILON);    assertEquals(2.0, next.get(1), EPSILON);    assertTrue(iter.hasNext());    next = iter.next();    assertNotNull(next);    assertTrue("Wrong instanceof", next instanceof DenseVector);    assertEquals(2.0, next.get(0), EPSILON);    assertEquals(3.0, next.get(1), EPSILON);    assertTrue(iter.hasNext());    next = iter.next();    assertNotNull(next);    assertTrue("Wrong instanceof", next instanceof RandomAccessSparseVector);    assertEquals(5.0, next.get(0), EPSILON);    assertEquals(23.0, next.get(1), EPSILON);    assertFalse(iter.hasNext());}
d332315d86e53ee898ad23ec9c58896826ebd948aba9fb9a37d99443cb5734d4
testDense
public void testDense() throws Exception
{    Iterable<Vector> iterable = readModelFromResource("sample-dense.arff");    Vector firstVector = iterable.iterator().next();    assertEquals(1.0, firstVector.get(0), 0);    assertEquals(65.0, firstVector.get(1), 0);    assertEquals(1.0, firstVector.get(3), 0);    assertEquals(1.0, firstVector.get(4), 0);    int count = 0;    for (Vector vector : iterable) {        assertTrue("Vector is not dense", vector instanceof DenseVector);        count++;    }    assertEquals(5, count);}
6293b468e127a8888e39d3a9cbab51c55bd8213d9ea7dde7ee593689d1366085
testSparse
public void testSparse() throws Exception
{    Iterable<Vector> iterable = readModelFromResource("sample-sparse.arff");    Vector firstVector = iterable.iterator().next();    assertEquals(23.1, firstVector.get(1), 0);    assertEquals(3.23, firstVector.get(2), 0);    assertEquals(1.2, firstVector.get(3), 0);    int count = 0;    for (Vector vector : iterable) {        assertTrue("Vector is not dense", vector instanceof RandomAccessSparseVector);        count++;    }    assertEquals(9, count);}
219d8c3d266cfe541c91ebf76e6f5306fc408dbbf0c05fce998372f6c76ecc73
testNonNumeric
public void testNonNumeric() throws Exception
{    MapBackedARFFModel model = new MapBackedARFFModel();    ARFFVectorIterable iterable = getVectors("non-numeric-1.arff", model);    int count = 0;    for (Vector vector : iterable) {        assertTrue("Vector is not dense", vector instanceof RandomAccessSparseVector);        count++;    }    iterable = getVectors("non-numeric-1.arff", model);    Iterator<Vector> iter = iterable.iterator();    Vector firstVector = iter.next();    assertEquals(1.0, firstVector.get(2), 0);    assertEquals(10, count);    Map<String, Map<String, Integer>> nominalMap = iterable.getModel().getNominalMap();    assertNotNull(nominalMap);    assertEquals(1, nominalMap.size());    Map<String, Integer> noms = nominalMap.get("bar");    assertNotNull("nominals for bar are null", noms);    assertEquals(5, noms.size());    Map<Integer, ARFFType> integerARFFTypeMap = model.getTypeMap();    assertNotNull("Type map null", integerARFFTypeMap);    assertEquals(5, integerARFFTypeMap.size());    Map<String, Long> words = model.getWords();    assertNotNull("words null", words);    assertEquals(10, words.size());    Map<Integer, DateFormat> integerDateFormatMap = model.getDateMap();    assertNotNull("date format null", integerDateFormatMap);    assertEquals(1, integerDateFormatMap.size());}
ad8d25509e19897998e40cc561ac8ed4e207f4472034e6981196d394751ceec7
testDate
public void testDate() throws Exception
{    ARFFVectorIterable iterable = readModelFromResource("date.arff");    Iterator<Vector> iter = iterable.iterator();    Vector firstVector = iter.next();    DateFormat format = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss", Locale.ENGLISH);    Date date = format.parse("2001-07-04T12:08:56");    long result = date.getTime();    assertEquals(result, firstVector.get(1), 0);    format = new SimpleDateFormat("yyyy.MM.dd G 'at' HH:mm:ss z", Locale.ENGLISH);    date = format.parse("2001.07.04 AD at 12:08:56 PDT");    result = date.getTime();    assertEquals(result, firstVector.get(2), 0);    format = new SimpleDateFormat("EEE, MMM d, ''yy", Locale.ENGLISH);    date = format.parse("Wed, Jul 4, '01,4 0:08 PM, PDT");    result = date.getTime();    assertEquals(result, firstVector.get(3), 0);    format = new SimpleDateFormat("K:mm a, z", Locale.ENGLISH);    date = format.parse("0:08 PM, PDT");    result = date.getTime();    assertEquals(result, firstVector.get(4), 0);    format = new SimpleDateFormat("yyyyy.MMMMM.dd GGG hh:mm aaa", Locale.ENGLISH);    date = format.parse("02001.July.04 AD 12:08 PM");    result = date.getTime();    assertEquals(result, firstVector.get(5), 0);    format = new SimpleDateFormat("EEE, d MMM yyyy HH:mm:ss Z", Locale.ENGLISH);    date = format.parse("Wed, 4 Jul 2001 12:08:56 -0700");    result = date.getTime();    assertEquals(result, firstVector.get(6), 0);}
e4966a3464f04a0fbd17c0116cdaca14740c36e9377f18d011c2f9f22a6757e7
testMultipleNoms
public void testMultipleNoms() throws Exception
{    MapBackedARFFModel model = new MapBackedARFFModel();    ARFFVectorIterable iterable = getVectors("non-numeric-1.arff", model);    int count = 0;    for (Vector vector : iterable) {        assertTrue("Vector is not dense", vector instanceof RandomAccessSparseVector);        count++;    }    assertEquals(10, count);    Map<String, Map<String, Integer>> nominalMap = iterable.getModel().getNominalMap();    assertNotNull(nominalMap);    assertEquals(1, nominalMap.size());    Map<String, Integer> noms = nominalMap.get("bar");    assertNotNull("nominals for bar are null", noms);    assertEquals(5, noms.size());    Map<Integer, ARFFType> integerARFFTypeMap = model.getTypeMap();    assertNotNull("Type map null", integerARFFTypeMap);    assertEquals(5, integerARFFTypeMap.size());    Map<String, Long> words = model.getWords();    assertNotNull("words null", words);    assertEquals(10, words.size());    Map<Integer, DateFormat> integerDateFormatMap = model.getDateMap();    assertNotNull("date format null", integerDateFormatMap);    assertEquals(1, integerDateFormatMap.size());    iterable = getVectors("non-numeric-2.arff", model);    count = 0;    for (Vector vector : iterable) {        assertTrue("Vector is not dense", vector instanceof RandomAccessSparseVector);        count++;    }    nominalMap = model.getNominalMap();    assertNotNull(nominalMap);    assertEquals(2, nominalMap.size());    noms = nominalMap.get("test");    assertNotNull("nominals for bar are null", noms);    assertEquals(2, noms.size());}
808700f051e4557270ec7eb7548ff10270af860df0906eb01683931e1a224121
testNumerics
public void testNumerics() throws Exception
{    String arff = "@RELATION numerics\n" + "@ATTRIBUTE theNumeric NUMERIC\n" + "@ATTRIBUTE theInteger INTEGER\n" + "@ATTRIBUTE theReal REAL\n" + "@DATA\n" + "1.0,2,3.0";    ARFFModel model = new MapBackedARFFModel();    ARFFVectorIterable iterable = new ARFFVectorIterable(arff, model);    model = iterable.getModel();    assertNotNull(model);    assertEquals(3, model.getLabelSize());    assertEquals(ARFFType.NUMERIC, model.getARFFType(0));    assertEquals(ARFFType.INTEGER, model.getARFFType(1));    assertEquals(ARFFType.REAL, model.getARFFType(2));    Iterator<Vector> it = iterable.iterator();    Vector vector = it.next();    assertEquals(1.0, vector.get(0), EPSILON);    assertEquals(2.0, vector.get(1), EPSILON);    assertEquals(3.0, vector.get(2), EPSILON);}
c723f3ca22ee3d0b7c59df118b2cec5fe38ab3c8b60170a88e64244786f377a0
testQuotes
public void testQuotes() throws Exception
{        ARFFModel model = new MapBackedARFFModel();    ARFFVectorIterable iterable = getVectors("quoted-id.arff", model);    model = iterable.getModel();    assertNotNull(model);    assertEquals("quotes", model.getRelation());        assertEquals(4, model.getLabelSize());    assertEquals(ARFFType.NUMERIC, model.getARFFType(0));    assertEquals(ARFFType.INTEGER, model.getARFFType(1));    assertEquals(ARFFType.REAL, model.getARFFType(2));    assertEquals(ARFFType.NOMINAL, model.getARFFType(3));    Map<String, Integer> labelBindings = model.getLabelBindings();    assertTrue(labelBindings.keySet().contains("thenumeric"));    assertTrue(labelBindings.keySet().contains("theinteger"));    assertTrue(labelBindings.keySet().contains("thereal"));    assertTrue(labelBindings.keySet().contains("thenominal"));        Map<String, Integer> nominalMap = model.getNominalMap().get("thenominal");    assertNotNull(nominalMap);    assertEquals(3, nominalMap.size());    assertTrue(nominalMap.keySet().contains("double-quote"));    assertTrue(nominalMap.keySet().contains("single-quote"));    assertTrue(nominalMap.keySet().contains("no-quote"));        Iterator<Vector> it = iterable.iterator();    Vector vector = it.next();    assertEquals(nominalMap.get("no-quote"), vector.get(3), EPSILON);    assertEquals(nominalMap.get("single-quote"), it.next().get(3), EPSILON);    assertEquals(nominalMap.get("double-quote"), it.next().get(3), EPSILON);}
e5692d53ba96636370c87c5d6e02c10617c91aa8acdbecf97771cc81648a3669
getVectors
 static ARFFVectorIterable getVectors(String resourceName, ARFFModel model) throws IOException
{    String sample = Resources.toString(Resources.getResource(resourceName), Charsets.UTF_8);    return new ARFFVectorIterable(sample, model);}
e809428cf08eed916e6b19304cbf5344d2b178e04474f17d921c2645cb31c33f
readModelFromResource
private static ARFFVectorIterable readModelFromResource(String resourceName) throws IOException
{    ARFFModel model = new MapBackedARFFModel();    return getVectors(resourceName, model);}
21797354bf1544becf8514603020980605a6fb7ef979e12c1c6b88961be41ce2
dictionary
public void dictionary() throws IOException
{    ARFFModel model = new MapBackedARFFModel();    ARFFVectorIterableTest.getVectors("sample-dense.arff", model);    StringWriter writer = new StringWriter();    Driver.writeLabelBindings(writer, model, ",");    String expected1 = Resources.toString(Resources.getResource("expected-arff-dictionary.csv"), Charsets.UTF_8);    String expected2 = Resources.toString(Resources.getResource("expected-arff-dictionary-2.csv"), Charsets.UTF_8);    assertTrue(expected1.equals(writer.toString()) || expected2.equals(writer.toString()));}
31314f6407d2e2bf10c89af0381b3bc036df527ebce81bc815abc543746377c9
dictionaryJSON
public void dictionaryJSON() throws IOException
{    ARFFModel model = new MapBackedARFFModel();    ARFFVectorIterableTest.getVectors("sample-dense.arff", model);    StringWriter writer = new StringWriter();    Driver.writeLabelBindingsJSON(writer, model);    String expected1 = Resources.toString(Resources.getResource("expected-arff-schema.json"), Charsets.UTF_8);    String expected2 = Resources.toString(Resources.getResource("expected-arff-schema-2.json"), Charsets.UTF_8);    assertTrue(expected1.equals(writer.toString()) || expected2.equals(writer.toString()));}
cb1f03a9a731ffa6366b974a577d029780bca4cce1d46ff713984737af9ad55d
processNominal
public void processNominal()
{    String windy = "windy";    String breezy = "breezy";    ARFFModel model = new MapBackedARFFModel();    model.addNominal(windy, breezy, 77);    model.addNominal(windy, "strong", 23);    model.addNominal(windy, "nuking", 55);    Map<String, Map<String, Integer>> nominalMap = model.getNominalMap();    assertEquals(1, nominalMap.size());    Map<String, Integer> windyValues = nominalMap.get(windy);    assertEquals(77, windyValues.get(breezy).intValue());}
ddfa507244d2203fdd2581177d6ffc77bbb115808c080fb621ee72bb15b00c03
processBadNumeric
public void processBadNumeric()
{    ARFFModel model = new MapBackedARFFModel();    model.addLabel("b1shkt70694difsmmmdv0ikmoh", 77);    model.addType(77, ARFFType.REAL);    assertTrue(Double.isNaN(model.getValue("b1shkt70694difsmmmdv0ikmoh", 77)));}
4a61bcf764d504b6a74ebb6dc79b8954c3ba5431d4cf262ba70f427ccfa7443f
processGoodNumeric
public void processGoodNumeric()
{    ARFFModel model = new MapBackedARFFModel();    model.addLabel("1234", 77);    model.addType(77, ARFFType.INTEGER);    assertTrue(1234 == model.getValue("1234", 77));    model.addLabel("131.34", 78);    model.addType(78, ARFFType.REAL);    assertTrue(131.34 == model.getValue("131.34", 78));}
295df77a84157e6dcca29d8c4cfb199b19305089a6d8774842726ab41c5eb317
testCount
public void testCount() throws Exception
{    StringWriter sWriter = new StringWriter();    try (TextualVectorWriter writer = new TextualVectorWriter(sWriter) {        @Override        public void write(Vector vector) throws IOException {            String vecStr = VectorHelper.vectorToCSVString(vector, false);            getWriter().write(vecStr);        }    }) {        Iterable<Vector> iter = new RandomVectorIterable(50);        writer.write(iter);    }    Iterator<Vector> csvIter = new CSVVectorIterator(new StringReader(sWriter.getBuffer().toString()));    int count = 0;    while (csvIter.hasNext()) {        csvIter.next();        count++;    }    assertEquals(50, count);}
4e3fe8a1f854fd413772567f3449b3ada02d7dbbcadaded2f434863a1ece6d5b
write
public void write(Vector vector) throws IOException
{    String vecStr = VectorHelper.vectorToCSVString(vector, false);    getWriter().write(vecStr);}
40cc15f1ac57da1ea64958cd3c6fe6f9e67a0ecc3f3f233bc6b9527e35c7a23f
testSFVW
public void testSFVW() throws Exception
{    Path path = getTestTempFilePath("sfvw");    Configuration conf = getConfiguration();    FileSystem fs = FileSystem.get(conf);    SequenceFile.Writer seqWriter = new SequenceFile.Writer(fs, conf, path, LongWritable.class, VectorWritable.class);    try (SequenceFileVectorWriter writer = new SequenceFileVectorWriter(seqWriter)) {        writer.write(new RandomVectorIterable(50));    }    long count = HadoopUtil.countRecords(path, conf);    assertEquals(50, count);}
ea45026d8ce53cd194c588879ee0e136b99cefca3d77b95309590be1cdec89c6
testTextOutputSize
public void testTextOutputSize() throws Exception
{    StringWriter strWriter = new StringWriter();    try (VectorWriter writer = new TextualVectorWriter(strWriter)) {        Collection<Vector> vectors = new ArrayList<>();        vectors.add(new DenseVector(new double[] { 0.3, 1.5, 4.5 }));        vectors.add(new DenseVector(new double[] { 1.3, 1.5, 3.5 }));        writer.write(vectors);    }    String buffer = strWriter.toString();    assertNotNull(buffer);    assertFalse(buffer.isEmpty());}
41c4887fd0644c92bf90084dbf97a8963aaaf731d3995a7cdd1efd4d6bee1c68
before
public void before() throws IOException
{    directory = new RAMDirectory();    FieldType fieldType = new FieldType();    fieldType.setStored(false);    fieldType.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);    fieldType.setTokenized(true);    fieldType.setStoreTermVectors(false);    fieldType.setStoreTermVectorPositions(false);    fieldType.setStoreTermVectorOffsets(false);    fieldType.freeze();    directory = createTestIndex(fieldType, directory, 0);}
ced3637227837bc8935023b279f6d11e541ba2dd6bbaff26ba3afa81b2fd1240
test
public void test() throws Exception
{    IndexReader reader = DirectoryReader.open(directory);    CachedTermInfo cti = new CachedTermInfo(reader, "content", 0, 100);    assertEquals(3, cti.totalTerms("content"));    assertNotNull(cti.getTermEntry("content", "a"));    assertNull(cti.getTermEntry("content", "e"));        cti = new CachedTermInfo(reader, "content", 3, 100);    assertEquals(2, cti.totalTerms("content"));    assertNotNull(cti.getTermEntry("content", "a"));    assertNull(cti.getTermEntry("content", "c"));        cti = new CachedTermInfo(reader, "content", 0, 85);    assertEquals(2, cti.totalTerms("content"));    assertNotNull(cti.getTermEntry("content", "b"));    assertNotNull(cti.getTermEntry("content", "c"));    assertNull(cti.getTermEntry("content", "a"));}
14feabb2e9ea7dac3b664bf943563dae89b5d98c51d2a8adbf78607e275991b9
createTestIndex
 static RAMDirectory createTestIndex(FieldType fieldType, RAMDirectory directory, int startingId) throws IOException
{    IndexWriter writer = new IndexWriter(directory, new IndexWriterConfig(new WhitespaceAnalyzer()));    try {        for (int i = 0; i < DOCS.length; i++) {            Document doc = new Document();            Field id = new StringField("id", "doc_" + (i + startingId), Field.Store.YES);            doc.add(id);            Field text = new Field("content", DOCS[i], fieldType);            doc.add(text);            Field text2 = new Field("content2", DOCS2[i], fieldType);            doc.add(text2);            writer.addDocument(doc);        }    } finally {        Closeables.close(writer, false);    }    return directory;}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    super.setUp();    indexDir = getTestTempDir("intermediate");    indexDir.delete();    outputDir = getTestTempDir("output");    outputDir.delete();    conf = getConfiguration();}
5bddfa044a90a9aa43c73adc6ba19cdb5c887a4102063e32903fc51137eb7b46
asDocument
private Document asDocument(String line)
{    Document doc = new Document();    doc.add(new TextFieldWithTermVectors("text", line));    return doc;}
d36c684ecce831eb0cd5878137d2f3ea2d0680c5999255ae710034a4b64cbdd4
sequenceFileDictionary
public void sequenceFileDictionary() throws IOException
{    Directory index = new SimpleFSDirectory(Paths.get(indexDir.getAbsolutePath()));    Analyzer analyzer = new StandardAnalyzer();    IndexWriterConfig config = new IndexWriterConfig(analyzer);    config.setCommitOnClose(true);    final IndexWriter writer = new IndexWriter(index, config);    try {        writer.addDocument(asDocument("One Ring to rule them all"));        writer.addDocument(asDocument("One Ring to find them,"));        writer.addDocument(asDocument("One Ring to bring them all"));        writer.addDocument(asDocument("and in the darkness bind them"));    } finally {        writer.close();    }    File seqDict = new File(outputDir, "dict.seq");    Driver.main(new String[] { "--dir", indexDir.getAbsolutePath(), "--output", new File(outputDir, "out").getAbsolutePath(), "--field", "text", "--dictOut", new File(outputDir, "dict.txt").getAbsolutePath(), "--seqDictOut", seqDict.getAbsolutePath() });    SequenceFile.Reader reader = null;    Set<String> indexTerms = Sets.newHashSet();    try {        reader = new SequenceFile.Reader(FileSystem.getLocal(conf), new Path(seqDict.getAbsolutePath()), conf);        Text term = new Text();        IntWritable termIndex = new IntWritable();        while (reader.next(term, termIndex)) {            indexTerms.add(term.toString());        }    } finally {        Closeables.close(reader, true);    }    Set<String> expectedIndexTerms = Sets.newHashSet("all", "bind", "bring", "darkness", "find", "one", "ring", "rule");        assertEquals(expectedIndexTerms.size(), Sets.union(expectedIndexTerms, indexTerms).size());}
41c4887fd0644c92bf90084dbf97a8963aaaf731d3995a7cdd1efd4d6bee1c68
before
public void before() throws IOException
{    TYPE_NO_TERM_VECTORS.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);    TYPE_NO_TERM_VECTORS.setTokenized(true);    TYPE_NO_TERM_VECTORS.setStoreTermVectors(false);    TYPE_NO_TERM_VECTORS.setStoreTermVectorPositions(false);    TYPE_NO_TERM_VECTORS.setStoreTermVectorOffsets(false);    TYPE_NO_TERM_VECTORS.freeze();    TYPE_TERM_VECTORS.setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);    TYPE_TERM_VECTORS.setTokenized(true);    TYPE_TERM_VECTORS.setStored(true);    TYPE_TERM_VECTORS.setStoreTermVectors(true);    TYPE_TERM_VECTORS.setStoreTermVectorPositions(true);    TYPE_TERM_VECTORS.setStoreTermVectorOffsets(true);    TYPE_TERM_VECTORS.freeze();    directory = createTestIndex(TYPE_TERM_VECTORS);}
9aa2741667107f45ddaf04a5af4f3028663841ffb649aaf31fae7a063bcef45e
testIterable
public void testIterable() throws Exception
{    IndexReader reader = DirectoryReader.open(directory);    Weight weight = new TFIDF();    TermInfo termInfo = new CachedTermInfo(reader, "content", 1, 100);    LuceneIterable iterable = new LuceneIterable(reader, "id", "content", termInfo, weight);        for (Vector vector : iterable) {        assertNotNull(vector);        assertTrue("vector is not an instanceof " + NamedVector.class, vector instanceof NamedVector);        assertTrue("vector Size: " + vector.size() + " is not greater than: " + 0, vector.size() > 0);        assertTrue(((NamedVector) vector).getName().startsWith("doc_"));    }    iterable = new LuceneIterable(reader, "id", "content", termInfo, weight, 3);        for (Vector vector : iterable) {        assertNotNull(vector);        assertTrue("vector is not an instanceof " + NamedVector.class, vector instanceof NamedVector);        assertTrue("vector Size: " + vector.size() + " is not greater than: " + 0, vector.size() > 0);        assertTrue(((NamedVector) vector).getName().startsWith("doc_"));    }}
c78ac52c4a75de730068dc069d13c4a48e669c6391cf5034f30a87e086e67e9f
testIterableNoTermVectors
public void testIterableNoTermVectors() throws IOException
{    RAMDirectory directory = createTestIndex(TYPE_NO_TERM_VECTORS);    IndexReader reader = DirectoryReader.open(directory);    Weight weight = new TFIDF();    TermInfo termInfo = new CachedTermInfo(reader, "content", 1, 100);    LuceneIterable iterable = new LuceneIterable(reader, "id", "content", termInfo, weight);    Iterator<Vector> iterator = iterable.iterator();    Iterators.advance(iterator, 1);}
39d3bf8aa88af8f977ca4895fa77972416e61f3fe12a13ca00fe51dad6aba048
testIterableSomeNoiseTermVectors
public void testIterableSomeNoiseTermVectors() throws IOException
{        RAMDirectory directory = createTestIndex(TYPE_TERM_VECTORS, new RAMDirectory(), 0);        createTestIndex(TYPE_NO_TERM_VECTORS, directory, 5);    IndexReader reader = DirectoryReader.open(directory);    Weight weight = new TFIDF();    TermInfo termInfo = new CachedTermInfo(reader, "content", 1, 100);    boolean exceptionThrown;        LuceneIterable iterable = new LuceneIterable(reader, "id", "content", termInfo, weight);    try {        Iterables.skip(iterable, Iterables.size(iterable));        exceptionThrown = false;    } catch (IllegalStateException ise) {        exceptionThrown = true;    }    assertTrue(exceptionThrown);        iterable = new LuceneIterable(reader, "id", "content", termInfo, weight, -1, 1.0);    try {        Iterables.skip(iterable, Iterables.size(iterable));        exceptionThrown = false;    } catch (IllegalStateException ise) {        exceptionThrown = true;    }    assertFalse(exceptionThrown);        iterable = new LuceneIterable(reader, "id", "content", termInfo, weight, -1, 0.5);    Iterator<Vector> iterator = iterable.iterator();    Iterators.advance(iterator, 5);    try {        Iterators.advance(iterator, Iterators.size(iterator));        exceptionThrown = false;    } catch (IllegalStateException ise) {        exceptionThrown = true;    }    assertTrue(exceptionThrown);}
645961fe2853a86936028599c93a01f1b29e4bf00f9d3d9709a8c7014bba9594
createTestIndex
 static RAMDirectory createTestIndex(FieldType fieldType) throws IOException
{    return createTestIndex(fieldType, new RAMDirectory(), 0);}
14feabb2e9ea7dac3b664bf943563dae89b5d98c51d2a8adbf78607e275991b9
createTestIndex
 static RAMDirectory createTestIndex(FieldType fieldType, RAMDirectory directory, int startingId) throws IOException
{    try (IndexWriter writer = new IndexWriter(directory, new IndexWriterConfig(new StandardAnalyzer()))) {        for (int i = 0; i < DOCS.length; i++) {            Document doc = new Document();            Field id = new StringField("id", "doc_" + (i + startingId), Field.Store.YES);            doc.add(id);                        Field text = new Field("content", DOCS[i], fieldType);            doc.add(text);            Field text2 = new Field("content2", DOCS[i], fieldType);            doc.add(text2);            writer.addDocument(doc);        }    }    return directory;}
1b5226f5beec2d8e24f17077e3cf629752caa7dc7c1859a1b913ae4ab3c710ea
iterator
public Iterator<Vector> iterator()
{    return Iterators.transform(new CountingIterator(numItems), new Function<Integer, Vector>() {        private final Random random = RandomUtils.getRandom();        @Override        public Vector apply(Integer dummy) {            Vector result = type == VectorType.SPARSE ? new RandomAccessSparseVector(numItems) : new DenseVector(numItems);            result.assign(new DoubleFunction() {                @Override                public double apply(double ignored) {                    return random.nextDouble();                }            });            return result;        }    });}
baf650f443db741a9ef1773a2b7952a1d5ac481dc77832faebe343b9b7521467
apply
public Vector apply(Integer dummy)
{    Vector result = type == VectorType.SPARSE ? new RandomAccessSparseVector(numItems) : new DenseVector(numItems);    result.assign(new DoubleFunction() {        @Override        public double apply(double ignored) {            return random.nextDouble();        }    });    return result;}
73f7de2503a9846d1f6266eb564191fdf5a1d5aee4d70a9237dd665890253a9f
apply
public double apply(double ignored)
{    return random.nextDouble();}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    super.setUp();    conf = getConfiguration();    inputPathOne = getTestTempFilePath("documents/docs-one.file");    FileSystem fs = FileSystem.get(inputPathOne.toUri(), conf);    try (SequenceFile.Writer writer = new SequenceFile.Writer(fs, conf, inputPathOne, Text.class, IntWritable.class)) {        Random rd = RandomUtils.getRandom();        for (int i = 0; i < NUM_DOCS; i++) {                        writer.append(new Text("Document::ID::" + i), new IntWritable(NUM_DOCS + rd.nextInt(NUM_DOCS)));        }    }    inputPathTwo = getTestTempFilePath("documents/docs-two.file");    fs = FileSystem.get(inputPathTwo.toUri(), conf);    try (SequenceFile.Writer writer = new SequenceFile.Writer(fs, conf, inputPathTwo, Text.class, IntWritable.class)) {        Random rd = RandomUtils.getRandom();        for (int i = 0; i < NUM_DOCS; i++) {                        writer.append(new Text("Document::ID::" + i), new IntWritable(rd.nextInt(NUM_DOCS)));        }    }}
f5dec0d27dbbd556b6fd9da6452e6e32699d78fdefa2bba30d7eb20940875778
testJsonFormatting
public void testJsonFormatting() throws Exception
{    Vector v = new SequentialAccessSparseVector(10);    v.set(2, 3.1);    v.set(4, 1.0);    v.set(6, 8.1);    v.set(7, -100);    v.set(9, 12.2);    String UNUSED = "UNUSED";    String[] dictionary = { UNUSED, UNUSED, "two", UNUSED, "four", UNUSED, "six", "seven", UNUSED, "nine" };    assertEquals("sorted json form incorrect: ", "{nine:12.2,six:8.1,two:3.1}", VectorHelper.vectorToJson(v, dictionary, 3, true));    assertEquals("unsorted form incorrect: ", "{two:3.1,four:1.0}", VectorHelper.vectorToJson(v, dictionary, 2, false));    assertEquals("sorted json form incorrect: ", "{nine:12.2,six:8.1,two:3.1,four:1.0}", VectorHelper.vectorToJson(v, dictionary, 4, true));    assertEquals("sorted json form incorrect: ", "{nine:12.2,six:8.1,two:3.1,four:1.0,seven:-100.0}", VectorHelper.vectorToJson(v, dictionary, 5, true));    assertEquals("sorted json form incorrect: ", "{nine:12.2,six:8.1}", VectorHelper.vectorToJson(v, dictionary, 2, true));    assertEquals("unsorted form incorrect: ", "{two:3.1,four:1.0}", VectorHelper.vectorToJson(v, dictionary, 2, false));}
0f06579b2f865b27b376dbb9c036ded9e3ed7243b3dba6db548692a6ce4d4927
testTopEntries
public void testTopEntries() throws Exception
{    Vector v = new SequentialAccessSparseVector(10);    v.set(2, 3.1);    v.set(4, 1.0);    v.set(6, 8.1);    v.set(7, -100);    v.set(9, 12.2);    v.set(1, 0.0);    v.set(3, 0.0);    v.set(8, 2.7);        assertEquals(6, VectorHelper.topEntries(v, 6).size());        assertTrue(VectorHelper.topEntries(v, 9).size() < 9);        assertTrue(VectorHelper.topEntries(v, 5).size() < v.getNumNonZeroElements());}
d1e33192e407d039a4b999a6abf35415e7bbfececfebf1b48c5b8a5bf518f817
testTopEntriesWhenAllZeros
public void testTopEntriesWhenAllZeros() throws Exception
{    Vector v = new SequentialAccessSparseVector(10);    v.set(2, 0.0);    v.set(4, 0.0);    v.set(6, 0.0);    v.set(7, 0);    v.set(9, 0.0);    v.set(1, 0.0);    v.set(3, 0.0);    v.set(8, 0.0);    assertEquals(0, VectorHelper.topEntries(v, 6).size());}
4360fd2c4ea3c4dae68a82f6c0b3c52e5798284f7fec1141d49eab160c904678
testLoadTermDictionary
public void testLoadTermDictionary() throws Exception
{        VectorHelper.loadTermDictionary(conf, inputPathOne.toString());        VectorHelper.loadTermDictionary(conf, inputPathTwo.toString());}
63f307b875d858e97af59e849f3e8f5ef5879b1829a6c22e68f3f6e64d08670a
readFirstRow
 static Vector readFirstRow(Path dir, Configuration conf) throws IOException
{    Iterator<VectorWritable> iterator = new SequenceFileDirValueIterator<>(dir, PathType.LIST, PathFilters.partFilter(), null, true, conf);    return iterator.hasNext() ? iterator.next().get() : null;}
7707f3284b9ff5090fb8f5f758a530cc8919f0fbb9ae761df5bbf8cf5859d419
readMatrixByRowsFromDistributedCache
public static OpenIntObjectHashMap<Vector> readMatrixByRowsFromDistributedCache(int numEntities, Configuration conf) throws IOException
{    IntWritable rowIndex = new IntWritable();    VectorWritable row = new VectorWritable();    OpenIntObjectHashMap<Vector> featureMatrix = numEntities > 0 ? new OpenIntObjectHashMap<Vector>(numEntities) : new OpenIntObjectHashMap<Vector>();    Path[] cachedFiles = HadoopUtil.getCachedFiles(conf);    LocalFileSystem localFs = FileSystem.getLocal(conf);    for (Path cachedFile : cachedFiles) {        try (SequenceFile.Reader reader = new SequenceFile.Reader(localFs.getConf(), SequenceFile.Reader.file(cachedFile))) {            while (reader.next(rowIndex, row)) {                featureMatrix.put(rowIndex.get(), row.get());            }        }    }    Preconditions.checkState(!featureMatrix.isEmpty(), "Feature matrix is empty");    return featureMatrix;}
6f4f22c6a1e6065fcddb17c1ab2a646d0f1960268f654c87001cb1e2e727ec12
readMatrixByRows
public static OpenIntObjectHashMap<Vector> readMatrixByRows(Path dir, Configuration conf)
{    OpenIntObjectHashMap<Vector> matrix = new OpenIntObjectHashMap<>();    for (Pair<IntWritable, VectorWritable> pair : new SequenceFileDirIterable<IntWritable, VectorWritable>(dir, PathType.LIST, PathFilters.partFilter(), conf)) {        int rowIndex = pair.getFirst().get();        Vector row = pair.getSecond().get();        matrix.put(rowIndex, row);    }    return matrix;}
0acaf13b4c3e658c98f5765e5fd003002d94429faeb2b90d23f773d8dc5b61e6
solveExplicit
public static Vector solveExplicit(VectorWritable ratingsWritable, OpenIntObjectHashMap<Vector> uOrM, double lambda, int numFeatures)
{    Vector ratings = ratingsWritable.get();    List<Vector> featureVectors = new ArrayList<>(ratings.getNumNondefaultElements());    for (Vector.Element e : ratings.nonZeroes()) {        int index = e.index();        featureVectors.add(uOrM.get(index));    }    return AlternatingLeastSquaresSolver.solve(featureVectors, ratings, lambda, numFeatures);}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    ToolRunner.run(new DatasetSplitter(), args);}
aacecb0f01750d985b78d806dc3c134f0da79efe2752957e0f93ecf5cbf9e492
run
public int run(String[] args) throws Exception
{    addInputOption();    addOutputOption();    addOption("trainingPercentage", "t", "percentage of the data to use as training set (default: " + DEFAULT_TRAINING_PERCENTAGE + ')', String.valueOf(DEFAULT_TRAINING_PERCENTAGE));    addOption("probePercentage", "p", "percentage of the data to use as probe set (default: " + DEFAULT_PROBE_PERCENTAGE + ')', String.valueOf(DEFAULT_PROBE_PERCENTAGE));    Map<String, List<String>> parsedArgs = parseArguments(args);    if (parsedArgs == null) {        return -1;    }    double trainingPercentage = Double.parseDouble(getOption("trainingPercentage"));    double probePercentage = Double.parseDouble(getOption("probePercentage"));    String tempDir = getOption("tempDir");    Path markedPrefs = new Path(tempDir, "markedPreferences");    Path trainingSetPath = new Path(getOutputPath(), "trainingSet");    Path probeSetPath = new Path(getOutputPath(), "probeSet");    Job markPreferences = prepareJob(getInputPath(), markedPrefs, TextInputFormat.class, MarkPreferencesMapper.class, Text.class, Text.class, SequenceFileOutputFormat.class);    markPreferences.getConfiguration().set(TRAINING_PERCENTAGE, String.valueOf(trainingPercentage));    markPreferences.getConfiguration().set(PROBE_PERCENTAGE, String.valueOf(probePercentage));    boolean succeeded = markPreferences.waitForCompletion(true);    if (!succeeded) {        return -1;    }    Job createTrainingSet = prepareJob(markedPrefs, trainingSetPath, SequenceFileInputFormat.class, WritePrefsMapper.class, NullWritable.class, Text.class, TextOutputFormat.class);    createTrainingSet.getConfiguration().set(PART_TO_USE, INTO_TRAINING_SET.toString());    succeeded = createTrainingSet.waitForCompletion(true);    if (!succeeded) {        return -1;    }    Job createProbeSet = prepareJob(markedPrefs, probeSetPath, SequenceFileInputFormat.class, WritePrefsMapper.class, NullWritable.class, Text.class, TextOutputFormat.class);    createProbeSet.getConfiguration().set(PART_TO_USE, INTO_PROBE_SET.toString());    succeeded = createProbeSet.waitForCompletion(true);    if (!succeeded) {        return -1;    }    return 0;}
d3192444cabbcc9598d5706bfdcd1dfedd209d3688c3c575e42fd6b75ea83739
setup
protected void setup(Context ctx) throws IOException, InterruptedException
{    random = RandomUtils.getRandom();    trainingBound = Double.parseDouble(ctx.getConfiguration().get(TRAINING_PERCENTAGE));    probeBound = trainingBound + Double.parseDouble(ctx.getConfiguration().get(PROBE_PERCENTAGE));}
5646e222e00cecb0d010b0758a85d647fc735eb72297cfae132d995657bdff88
map
protected void map(LongWritable key, Text text, Context ctx) throws IOException, InterruptedException
{    double randomValue = random.nextDouble();    if (randomValue <= trainingBound) {        ctx.write(INTO_TRAINING_SET, text);    } else if (randomValue <= probeBound) {        ctx.write(INTO_PROBE_SET, text);    }}
d3192444cabbcc9598d5706bfdcd1dfedd209d3688c3c575e42fd6b75ea83739
setup
protected void setup(Context ctx) throws IOException, InterruptedException
{    partToUse = ctx.getConfiguration().get(PART_TO_USE);}
e0bfbd9b0117f6a585f4cc0337534b619241931af417647bd78103217f412a7e
map
protected void map(Text key, Text text, Context ctx) throws IOException, InterruptedException
{    if (partToUse.equals(key.toString())) {        ctx.write(NullWritable.get(), text);    }}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    ToolRunner.run(new FactorizationEvaluator(), args);}
aacecb0f01750d985b78d806dc3c134f0da79efe2752957e0f93ecf5cbf9e492
run
public int run(String[] args) throws Exception
{    addInputOption();    addOption("userFeatures", null, "path to the user feature matrix", true);    addOption("itemFeatures", null, "path to the item feature matrix", true);    addOption("usesLongIDs", null, "input contains long IDs that need to be translated");    addOutputOption();    Map<String, List<String>> parsedArgs = parseArguments(args);    if (parsedArgs == null) {        return -1;    }    Path errors = getTempPath("errors");    Job predictRatings = prepareJob(getInputPath(), errors, TextInputFormat.class, PredictRatingsMapper.class, DoubleWritable.class, NullWritable.class, SequenceFileOutputFormat.class);    Configuration conf = predictRatings.getConfiguration();    conf.set(USER_FEATURES_PATH, getOption("userFeatures"));    conf.set(ITEM_FEATURES_PATH, getOption("itemFeatures"));    boolean usesLongIDs = Boolean.parseBoolean(getOption("usesLongIDs"));    if (usesLongIDs) {        conf.set(ParallelALSFactorizationJob.USES_LONG_IDS, String.valueOf(true));    }    boolean succeeded = predictRatings.waitForCompletion(true);    if (!succeeded) {        return -1;    }    FileSystem fs = FileSystem.get(getOutputPath().toUri(), getConf());    FSDataOutputStream outputStream = fs.create(getOutputPath("rmse.txt"));    try (BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(outputStream, Charsets.UTF_8))) {        double rmse = computeRmse(errors);        writer.write(String.valueOf(rmse));    }    return 0;}
8e00f152ecab27c415d425ace632d9bea091a72c972b968e363a34f0e7eb44aa
computeRmse
private double computeRmse(Path errors)
{    RunningAverage average = new FullRunningAverage();    for (Pair<DoubleWritable, NullWritable> entry : new SequenceFileDirIterable<DoubleWritable, NullWritable>(errors, PathType.LIST, PathFilters.logsCRCFilter(), getConf())) {        DoubleWritable error = entry.getFirst();        average.addDatum(error.get() * error.get());    }    return Math.sqrt(average.getAverage());}
d3192444cabbcc9598d5706bfdcd1dfedd209d3688c3c575e42fd6b75ea83739
setup
protected void setup(Context ctx) throws IOException, InterruptedException
{    Configuration conf = ctx.getConfiguration();    Path pathToU = new Path(conf.get(USER_FEATURES_PATH));    Path pathToM = new Path(conf.get(ITEM_FEATURES_PATH));    U = ALS.readMatrixByRows(pathToU, conf);    M = ALS.readMatrixByRows(pathToM, conf);    usesLongIDs = conf.getBoolean(ParallelALSFactorizationJob.USES_LONG_IDS, false);}
f4cbc636705209b823640360f2dcba16b352874ad8900dfdd78280634ea8b8fa
map
protected void map(LongWritable key, Text value, Context ctx) throws IOException, InterruptedException
{    String[] tokens = TasteHadoopUtils.splitPrefTokens(value.toString());    int userID = TasteHadoopUtils.readID(tokens[TasteHadoopUtils.USER_ID_POS], usesLongIDs);    int itemID = TasteHadoopUtils.readID(tokens[TasteHadoopUtils.ITEM_ID_POS], usesLongIDs);    double rating = Double.parseDouble(tokens[2]);    if (U.containsKey(userID) && M.containsKey(itemID)) {        double estimate = U.get(userID).dot(M.get(itemID));        error.set(rating - estimate);        ctx.write(error, NullWritable.get());    }}
f0857f2051a8299c0c0f469c2f9082d5895477206f58cd339eb3e9a6410c9d49
run
public void run(Context ctx) throws IOException, InterruptedException
{    Class<Mapper<K1, V1, K2, V2>> mapperClass = MultithreadedSharingMapper.getMapperClass((JobContext) ctx);    Preconditions.checkNotNull(mapperClass, "Could not find Multithreaded Mapper class.");    Configuration conf = ctx.getConfiguration();        Mapper<K1, V1, K2, V2> mapper1 = ReflectionUtils.newInstance(mapperClass, conf);    SharingMapper<K1, V1, K2, V2, ?> mapper = null;    if (mapper1 instanceof SharingMapper) {        mapper = (SharingMapper<K1, V1, K2, V2, ?>) mapper1;    }    Preconditions.checkNotNull(mapper, "Could not instantiate SharingMapper. Class was: %s", mapper1.getClass().getName());        mapper.setupSharedInstance(ctx);        super.run(ctx);}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    ToolRunner.run(new ParallelALSFactorizationJob(), args);}
aacecb0f01750d985b78d806dc3c134f0da79efe2752957e0f93ecf5cbf9e492
run
public int run(String[] args) throws Exception
{    addInputOption();    addOutputOption();    addOption("lambda", null, "regularization parameter", true);    addOption("implicitFeedback", null, "data consists of implicit feedback?", String.valueOf(false));    addOption("alpha", null, "confidence parameter (only used on implicit feedback)", String.valueOf(40));    addOption("numFeatures", null, "dimension of the feature space", true);    addOption("numIterations", null, "number of iterations", true);    addOption("numThreadsPerSolver", null, "threads per solver mapper", String.valueOf(1));    addOption("usesLongIDs", null, "input contains long IDs that need to be translated");    Map<String, List<String>> parsedArgs = parseArguments(args);    if (parsedArgs == null) {        return -1;    }    numFeatures = Integer.parseInt(getOption("numFeatures"));    numIterations = Integer.parseInt(getOption("numIterations"));    lambda = Double.parseDouble(getOption("lambda"));    alpha = Double.parseDouble(getOption("alpha"));    implicitFeedback = Boolean.parseBoolean(getOption("implicitFeedback"));    numThreadsPerSolver = Integer.parseInt(getOption("numThreadsPerSolver"));    boolean usesLongIDs = Boolean.parseBoolean(getOption("usesLongIDs", String.valueOf(false)));    if (usesLongIDs) {        Job mapUsers = prepareJob(getInputPath(), getOutputPath("userIDIndex"), TextInputFormat.class, MapLongIDsMapper.class, VarIntWritable.class, VarLongWritable.class, IDMapReducer.class, VarIntWritable.class, VarLongWritable.class, SequenceFileOutputFormat.class);        mapUsers.getConfiguration().set(TOKEN_POS, String.valueOf(TasteHadoopUtils.USER_ID_POS));        mapUsers.waitForCompletion(true);        Job mapItems = prepareJob(getInputPath(), getOutputPath("itemIDIndex"), TextInputFormat.class, MapLongIDsMapper.class, VarIntWritable.class, VarLongWritable.class, IDMapReducer.class, VarIntWritable.class, VarLongWritable.class, SequenceFileOutputFormat.class);        mapItems.getConfiguration().set(TOKEN_POS, String.valueOf(TasteHadoopUtils.ITEM_ID_POS));        mapItems.waitForCompletion(true);    }    /* create A' */    Job itemRatings = prepareJob(getInputPath(), pathToItemRatings(), TextInputFormat.class, ItemRatingVectorsMapper.class, IntWritable.class, VectorWritable.class, VectorSumReducer.class, IntWritable.class, VectorWritable.class, SequenceFileOutputFormat.class);    itemRatings.setCombinerClass(VectorSumCombiner.class);    itemRatings.getConfiguration().set(USES_LONG_IDS, String.valueOf(usesLongIDs));    boolean succeeded = itemRatings.waitForCompletion(true);    if (!succeeded) {        return -1;    }    /* create A */    Job userRatings = prepareJob(pathToItemRatings(), pathToUserRatings(), TransposeMapper.class, IntWritable.class, VectorWritable.class, MergeUserVectorsReducer.class, IntWritable.class, VectorWritable.class);    userRatings.setCombinerClass(MergeVectorsCombiner.class);    succeeded = userRatings.waitForCompletion(true);    if (!succeeded) {        return -1;    }        Job averageItemRatings = prepareJob(pathToItemRatings(), getTempPath("averageRatings"), AverageRatingMapper.class, IntWritable.class, VectorWritable.class, MergeVectorsReducer.class, IntWritable.class, VectorWritable.class);    averageItemRatings.setCombinerClass(MergeVectorsCombiner.class);    succeeded = averageItemRatings.waitForCompletion(true);    if (!succeeded) {        return -1;    }    Vector averageRatings = ALS.readFirstRow(getTempPath("averageRatings"), getConf());    int numItems = averageRatings.getNumNondefaultElements();    int numUsers = (int) userRatings.getCounters().findCounter(Stats.NUM_USERS).getValue();    log.info("Found {} users and {} items", numUsers, numItems);    /* create an initial M */    initializeM(averageRatings);    for (int currentIteration = 0; currentIteration < numIterations; currentIteration++) {        /* broadcast M, read A row-wise, recompute U row-wise */        log.info("Recomputing U (iteration {}/{})", currentIteration, numIterations);        runSolver(pathToUserRatings(), pathToU(currentIteration), pathToM(currentIteration - 1), currentIteration, "U", numItems);        /* broadcast U, read A' row-wise, recompute M row-wise */        log.info("Recomputing M (iteration {}/{})", currentIteration, numIterations);        runSolver(pathToItemRatings(), pathToM(currentIteration), pathToU(currentIteration), currentIteration, "M", numUsers);    }    return 0;}
9b92935092dde27ce6f3f36865ef509868580706058b807ac1df54c39d76f020
initializeM
private void initializeM(Vector averageRatings) throws IOException
{    Random random = RandomUtils.getRandom();    FileSystem fs = FileSystem.get(pathToM(-1).toUri(), getConf());    try (SequenceFile.Writer writer = new SequenceFile.Writer(fs, getConf(), new Path(pathToM(-1), "part-m-00000"), IntWritable.class, VectorWritable.class)) {        IntWritable index = new IntWritable();        VectorWritable featureVector = new VectorWritable();        for (Vector.Element e : averageRatings.nonZeroes()) {            Vector row = new DenseVector(numFeatures);            row.setQuick(0, e.get());            for (int m = 1; m < numFeatures; m++) {                row.setQuick(m, random.nextDouble());            }            index.set(e.index());            featureVector.set(row);            writer.append(index, featureVector);        }    }}
6ba7549c190ba3934c737121a4e01d8239c111107d86e2d043f3abc620611696
reduce
protected void reduce(WritableComparable<?> key, Iterable<VectorWritable> values, Context ctx) throws IOException, InterruptedException
{    Vector sum = Vectors.sum(values.iterator());    result.set(new SequentialAccessSparseVector(sum));    ctx.write(key, result);}
444bda7c9ead0de7f0dc04399b92be991bd10d75dc2d52c0bdbaba5f088dc559
reduce
public void reduce(WritableComparable<?> key, Iterable<VectorWritable> vectors, Context ctx) throws IOException, InterruptedException
{    Vector merged = VectorWritable.merge(vectors.iterator()).get();    result.set(new SequentialAccessSparseVector(merged));    ctx.write(key, result);    ctx.getCounter(Stats.NUM_USERS).increment(1);}
d3192444cabbcc9598d5706bfdcd1dfedd209d3688c3c575e42fd6b75ea83739
setup
protected void setup(Context ctx) throws IOException, InterruptedException
{    usesLongIDs = ctx.getConfiguration().getBoolean(USES_LONG_IDS, false);}
a9a763bcd34a0f3f3061aee46a88f99a4090c9fb04ddc2174edc9e7ca192d485
map
protected void map(LongWritable offset, Text line, Context ctx) throws IOException, InterruptedException
{    String[] tokens = TasteHadoopUtils.splitPrefTokens(line.toString());    int userID = TasteHadoopUtils.readID(tokens[TasteHadoopUtils.USER_ID_POS], usesLongIDs);    int itemID = TasteHadoopUtils.readID(tokens[TasteHadoopUtils.ITEM_ID_POS], usesLongIDs);    float rating = Float.parseFloat(tokens[2]);    ratings.setQuick(userID, rating);    itemIDWritable.set(itemID);    ratingsWritable.set(ratings);    ctx.write(itemIDWritable, ratingsWritable);        ratings.setQuick(userID, 0.0d);}
1602c271b8dfabcb5cc3b57bb42a36129ca363bf5ed0e576e726a2d95e47ed5e
runSolver
private void runSolver(Path ratings, Path output, Path pathToUorM, int currentIteration, String matrixName, int numEntities) throws ClassNotFoundException, IOException, InterruptedException
{        SharingMapper.reset();    Class<? extends Mapper<IntWritable, VectorWritable, IntWritable, VectorWritable>> solverMapperClassInternal;    String name;    if (implicitFeedback) {        solverMapperClassInternal = SolveImplicitFeedbackMapper.class;        name = "Recompute " + matrixName + ", iteration (" + currentIteration + '/' + numIterations + "), " + '(' + numThreadsPerSolver + " threads, " + numFeatures + " features, implicit feedback)";    } else {        solverMapperClassInternal = SolveExplicitFeedbackMapper.class;        name = "Recompute " + matrixName + ", iteration (" + currentIteration + '/' + numIterations + "), " + '(' + numThreadsPerSolver + " threads, " + numFeatures + " features, explicit feedback)";    }    Job solverForUorI = prepareJob(ratings, output, SequenceFileInputFormat.class, MultithreadedSharingMapper.class, IntWritable.class, VectorWritable.class, SequenceFileOutputFormat.class, name);    Configuration solverConf = solverForUorI.getConfiguration();    solverConf.set(LAMBDA, String.valueOf(lambda));    solverConf.set(ALPHA, String.valueOf(alpha));    solverConf.setInt(NUM_FEATURES, numFeatures);    solverConf.set(NUM_ENTITIES, String.valueOf(numEntities));    FileSystem fs = FileSystem.get(pathToUorM.toUri(), solverConf);    FileStatus[] parts = fs.listStatus(pathToUorM, PathFilters.partFilter());    for (FileStatus part : parts) {        if (log.isDebugEnabled()) {            log.debug("Adding {} to distributed cache", part.getPath().toString());        }        DistributedCache.addCacheFile(part.getPath().toUri(), solverConf);    }    MultithreadedMapper.setMapperClass(solverForUorI, solverMapperClassInternal);    MultithreadedMapper.setNumberOfThreads(solverForUorI, numThreadsPerSolver);    boolean succeeded = solverForUorI.waitForCompletion(true);    if (!succeeded) {        throw new IllegalStateException("Job failed!");    }}
8fc5f64a22de122ebab3783eb08c9f0101bb7f937d9b5649bbbc7b2ca6d82100
map
protected void map(IntWritable r, VectorWritable v, Context ctx) throws IOException, InterruptedException
{    RunningAverage avg = new FullRunningAverage();    for (Vector.Element e : v.get().nonZeroes()) {        avg.addDatum(e.get());    }    featureVector.setQuick(r.get(), avg.getAverage());    featureVectorWritable.set(featureVector);    ctx.write(firstIndex, featureVectorWritable);        featureVector.setQuick(r.get(), 0.0d);}
d3192444cabbcc9598d5706bfdcd1dfedd209d3688c3c575e42fd6b75ea83739
setup
protected void setup(Context ctx) throws IOException, InterruptedException
{    tokenPos = ctx.getConfiguration().getInt(TOKEN_POS, -1);    Preconditions.checkState(tokenPos >= 0);}
25c419df496b37da3b704cb7d3657ad77420940369fe3f98a89672cff3f17a33
map
protected void map(LongWritable key, Text line, Context ctx) throws IOException, InterruptedException
{    String[] tokens = TasteHadoopUtils.splitPrefTokens(line.toString());    long id = Long.parseLong(tokens[tokenPos]);    index.set(TasteHadoopUtils.idToIndex(id));    idWritable.set(id);    ctx.write(index, idWritable);}
331b854896530e45355d0f8f85e0f518df5c54b9a25a459b8da910fe8abe0866
reduce
protected void reduce(VarIntWritable index, Iterable<VarLongWritable> ids, Context ctx) throws IOException, InterruptedException
{    ctx.write(index, ids.iterator().next());}
b04556ac195bbe3907ad91e81eef366a9d37a20cda5a792dd41252db28a8b525
pathToM
private Path pathToM(int iteration)
{    return iteration == numIterations - 1 ? getOutputPath("M") : getTempPath("M-" + iteration);}
05184c82ffc49937bfa9e54398d2970d76ca1e99ca94f9a76b1d26f50b42c79c
pathToU
private Path pathToU(int iteration)
{    return iteration == numIterations - 1 ? getOutputPath("U") : getTempPath("U-" + iteration);}
328472c1f4380d2d41604d42aa638d27057ab4aa09b632053253395cb63d7746
pathToItemRatings
private Path pathToItemRatings()
{    return getTempPath("itemRatings");}
c33cdfe79d948651d73c3dd6770f936e8df24ba342df750dc8d0678593bc52cd
pathToUserRatings
private Path pathToUserRatings()
{    return getOutputPath("userRatings");}
9e22c6920860b60c0a64f462dc5fb87b4e24c11c2c2759286b6df440dde2e8d8
createSharedInstance
 Pair<OpenIntObjectHashMap<Vector>, OpenIntObjectHashMap<Vector>> createSharedInstance(Context ctx)
{    Configuration conf = ctx.getConfiguration();    Path pathToU = new Path(conf.get(RecommenderJob.USER_FEATURES_PATH));    Path pathToM = new Path(conf.get(RecommenderJob.ITEM_FEATURES_PATH));    OpenIntObjectHashMap<Vector> U = ALS.readMatrixByRows(pathToU, conf);    OpenIntObjectHashMap<Vector> M = ALS.readMatrixByRows(pathToM, conf);    return new Pair<>(U, M);}
d3192444cabbcc9598d5706bfdcd1dfedd209d3688c3c575e42fd6b75ea83739
setup
protected void setup(Context ctx) throws IOException, InterruptedException
{    Configuration conf = ctx.getConfiguration();    recommendationsPerUser = conf.getInt(RecommenderJob.NUM_RECOMMENDATIONS, RecommenderJob.DEFAULT_NUM_RECOMMENDATIONS);    maxRating = Float.parseFloat(conf.get(RecommenderJob.MAX_RATING));    usesLongIDs = conf.getBoolean(ParallelALSFactorizationJob.USES_LONG_IDS, false);    if (usesLongIDs) {        userIDIndex = TasteHadoopUtils.readIDIndexMap(conf.get(RecommenderJob.USER_INDEX_PATH), conf);        itemIDIndex = TasteHadoopUtils.readIDIndexMap(conf.get(RecommenderJob.ITEM_INDEX_PATH), conf);    }}
ea263b431e83c5d1d12a9c35576128e2bbd9c2e25d3e37693b60198a0119f832
map
protected void map(IntWritable userIndexWritable, VectorWritable ratingsWritable, Context ctx) throws IOException, InterruptedException
{    Pair<OpenIntObjectHashMap<Vector>, OpenIntObjectHashMap<Vector>> uAndM = getSharedInstance();    OpenIntObjectHashMap<Vector> U = uAndM.getFirst();    OpenIntObjectHashMap<Vector> M = uAndM.getSecond();    Vector ratings = ratingsWritable.get();    int userIndex = userIndexWritable.get();    final OpenIntHashSet alreadyRatedItems = new OpenIntHashSet(ratings.getNumNondefaultElements());    for (Vector.Element e : ratings.nonZeroes()) {        alreadyRatedItems.add(e.index());    }    final TopItemsQueue topItemsQueue = new TopItemsQueue(recommendationsPerUser);    final Vector userFeatures = U.get(userIndex);    M.forEachPair(new IntObjectProcedure<Vector>() {        @Override        public boolean apply(int itemID, Vector itemFeatures) {            if (!alreadyRatedItems.contains(itemID)) {                double predictedRating = userFeatures.dot(itemFeatures);                MutableRecommendedItem top = topItemsQueue.top();                if (predictedRating > top.getValue()) {                    top.set(itemID, (float) predictedRating);                    topItemsQueue.updateTop();                }            }            return true;        }    });    List<RecommendedItem> recommendedItems = topItemsQueue.getTopItems();    if (!recommendedItems.isEmpty()) {                for (RecommendedItem topItem : recommendedItems) {            ((MutableRecommendedItem) topItem).capToMaxValue(maxRating);        }        if (usesLongIDs) {            long userID = userIDIndex.get(userIndex);            userIDWritable.set(userID);            for (RecommendedItem topItem : recommendedItems) {                                long itemID = itemIDIndex.get((int) topItem.getItemID());                ((MutableRecommendedItem) topItem).setItemID(itemID);            }        } else {            userIDWritable.set(userIndex);        }        recommendations.set(recommendedItems);        ctx.write(userIDWritable, recommendations);    }}
30b6d0e3b17f3a338de6d305444e33903aa6b880e1616731c7395a7040158358
apply
public boolean apply(int itemID, Vector itemFeatures)
{    if (!alreadyRatedItems.contains(itemID)) {        double predictedRating = userFeatures.dot(itemFeatures);        MutableRecommendedItem top = topItemsQueue.top();        if (predictedRating > top.getValue()) {            top.set(itemID, (float) predictedRating);            topItemsQueue.updateTop();        }    }    return true;}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    ToolRunner.run(new RecommenderJob(), args);}
aacecb0f01750d985b78d806dc3c134f0da79efe2752957e0f93ecf5cbf9e492
run
public int run(String[] args) throws Exception
{    addInputOption();    addOption("userFeatures", null, "path to the user feature matrix", true);    addOption("itemFeatures", null, "path to the item feature matrix", true);    addOption("numRecommendations", null, "number of recommendations per user", String.valueOf(DEFAULT_NUM_RECOMMENDATIONS));    addOption("maxRating", null, "maximum rating available", true);    addOption("numThreads", null, "threads per mapper", String.valueOf(1));    addOption("usesLongIDs", null, "input contains long IDs that need to be translated");    addOption("userIDIndex", null, "index for user long IDs (necessary if usesLongIDs is true)");    addOption("itemIDIndex", null, "index for user long IDs (necessary if usesLongIDs is true)");    addOutputOption();    Map<String, List<String>> parsedArgs = parseArguments(args);    if (parsedArgs == null) {        return -1;    }    Job prediction = prepareJob(getInputPath(), getOutputPath(), SequenceFileInputFormat.class, MultithreadedSharingMapper.class, IntWritable.class, RecommendedItemsWritable.class, TextOutputFormat.class);    Configuration conf = prediction.getConfiguration();    int numThreads = Integer.parseInt(getOption("numThreads"));    conf.setInt(NUM_RECOMMENDATIONS, Integer.parseInt(getOption("numRecommendations")));    conf.set(USER_FEATURES_PATH, getOption("userFeatures"));    conf.set(ITEM_FEATURES_PATH, getOption("itemFeatures"));    conf.set(MAX_RATING, getOption("maxRating"));    boolean usesLongIDs = Boolean.parseBoolean(getOption("usesLongIDs"));    if (usesLongIDs) {        conf.set(ParallelALSFactorizationJob.USES_LONG_IDS, String.valueOf(true));        conf.set(USER_INDEX_PATH, getOption("userIDIndex"));        conf.set(ITEM_INDEX_PATH, getOption("itemIDIndex"));    }    MultithreadedMapper.setMapperClass(prediction, PredictionMapper.class);    MultithreadedMapper.setNumberOfThreads(prediction, numThreads);    boolean succeeded = prediction.waitForCompletion(true);    if (!succeeded) {        return -1;    }    return 0;}
c6792e9697f2f6888e71dc580876ca24ecebd7e1165521c9b1f7b98615074fd9
setupSharedInstance
 final void setupSharedInstance(Context context) throws IOException
{    if (SHARED_INSTANCE == null) {        SHARED_INSTANCE = createSharedInstance(context);    }}
df7433791655e9ddf39bdc203c6d330d088f05b808c386eb73f5d5f30630cec7
getSharedInstance
 final S getSharedInstance()
{    return (S) SHARED_INSTANCE;}
0721563fc1469f2f98110c1dc32750a0d3ef08ebd6d8e3c65adea83da67d2ec5
reset
 static void reset()
{    SHARED_INSTANCE = null;}
1bbf3e0a22f1ff221f420c59e7a0a2906d8a35b61ea588a0b79bed62531cea23
createSharedInstance
 OpenIntObjectHashMap<Vector> createSharedInstance(Context ctx) throws IOException
{    Configuration conf = ctx.getConfiguration();    int numEntities = Integer.parseInt(conf.get(ParallelALSFactorizationJob.NUM_ENTITIES));    return ALS.readMatrixByRowsFromDistributedCache(numEntities, conf);}
0adfd36b09d9e43bad554542d75b9e8a87ab82752ccd229ac362327ccf0ff9fe
setup
protected void setup(Mapper.Context ctx) throws IOException, InterruptedException
{    lambda = Double.parseDouble(ctx.getConfiguration().get(ParallelALSFactorizationJob.LAMBDA));    numFeatures = ctx.getConfiguration().getInt(ParallelALSFactorizationJob.NUM_FEATURES, -1);    Preconditions.checkArgument(numFeatures > 0, "numFeatures must be greater then 0!");}
fa3a898431d1879d43fda37c9e37c0b18a407ab82081d3d5983acedc87e0012b
map
protected void map(IntWritable userOrItemID, VectorWritable ratingsWritable, Context ctx) throws IOException, InterruptedException
{    OpenIntObjectHashMap<Vector> uOrM = getSharedInstance();    uiOrmj.set(ALS.solveExplicit(ratingsWritable, uOrM, lambda, numFeatures));    ctx.write(userOrItemID, uiOrmj);}
61cec280200d5278b263e9b1bcf9d55cf1cd9b7aeec1efde91614e4929ca9fdb
createSharedInstance
 ImplicitFeedbackAlternatingLeastSquaresSolver createSharedInstance(Context ctx) throws IOException
{    Configuration conf = ctx.getConfiguration();    double lambda = Double.parseDouble(conf.get(ParallelALSFactorizationJob.LAMBDA));    double alpha = Double.parseDouble(conf.get(ParallelALSFactorizationJob.ALPHA));    int numFeatures = conf.getInt(ParallelALSFactorizationJob.NUM_FEATURES, -1);    int numEntities = Integer.parseInt(conf.get(ParallelALSFactorizationJob.NUM_ENTITIES));    Preconditions.checkArgument(numFeatures > 0, "numFeatures must be greater then 0!");    return new ImplicitFeedbackAlternatingLeastSquaresSolver(numFeatures, lambda, alpha, ALS.readMatrixByRowsFromDistributedCache(numEntities, conf), 1);}
fa3a898431d1879d43fda37c9e37c0b18a407ab82081d3d5983acedc87e0012b
map
protected void map(IntWritable userOrItemID, VectorWritable ratingsWritable, Context ctx) throws IOException, InterruptedException
{    ImplicitFeedbackAlternatingLeastSquaresSolver solver = getSharedInstance();    uiOrmj.set(solver.solve(ratingsWritable.get()));    ctx.write(userOrItemID, uiOrmj);}
32a73bc5cb3ca99c82cda02d1ebd1d46b29c39ca2aa07c1a04e4b81911e4d8c9
getAID
 long getAID()
{    return aID;}
d1e2d2afb85faccd7d0ac4b3df8a6bc0a51b51720b4483c460e5626ce9dde124
getBID
 long getBID()
{    return bID;}
a894510dd4db439ff8e17ae1059489dc3abc97178e5932ceed0c70c3af165401
write
public void write(DataOutput out) throws IOException
{    Varint.writeSignedVarLong(aID, out);    Varint.writeSignedVarLong(bID, out);}
5478cc5683f6dfd4515c383752d7c803555efc63d03fd84a03ba8dcd17eb4324
readFields
public void readFields(DataInput in) throws IOException
{    aID = Varint.readSignedVarLong(in);    bID = Varint.readSignedVarLong(in);}
36966f4c5e67bb8d738ffedce0baaa2ef002e0dbebc4e71871216dc840a42643
compareTo
public int compareTo(EntityEntityWritable that)
{    int aCompare = compare(aID, that.getAID());    return aCompare == 0 ? compare(bID, that.getBID()) : aCompare;}
caff4b0a3fc0b3084da6bbfda0c88210fb211335692e6cdb453f8eb01ccf67fe
compare
private static int compare(long a, long b)
{    return a < b ? -1 : a > b ? 1 : 0;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return Longs.hashCode(aID) + 31 * Longs.hashCode(bID);}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (o instanceof EntityEntityWritable) {        EntityEntityWritable that = (EntityEntityWritable) o;        return aID == that.getAID() && bID == that.getBID();    }    return false;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return aID + "\t" + bID;}
69eb68dbb2f233c862b441286dc31a7d453b600b1ada8564618c49f35996a84f
clone
public EntityEntityWritable clone()
{    return new EntityEntityWritable(aID, bID);}
01e8d5fc6a61bd72d2dcd80f151e75a2799e6dddf8203758504e383c2bfe4ddb
getID
public long getID()
{    return get();}
3dea5becbc055ac5d579cec4c90deb19dbcdc9813c62e6cb8bc74e267e6f6c1d
getPrefValue
public float getPrefValue()
{    return prefValue;}
a894510dd4db439ff8e17ae1059489dc3abc97178e5932ceed0c70c3af165401
write
public void write(DataOutput out) throws IOException
{    super.write(out);    out.writeFloat(prefValue);}
5478cc5683f6dfd4515c383752d7c803555efc63d03fd84a03ba8dcd17eb4324
readFields
public void readFields(DataInput in) throws IOException
{    super.readFields(in);    prefValue = in.readFloat();}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return super.hashCode() ^ RandomUtils.hashFloat(prefValue);}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (!(o instanceof EntityPrefWritable)) {        return false;    }    EntityPrefWritable other = (EntityPrefWritable) o;    return get() == other.get() && prefValue == other.getPrefValue();}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return get() + "\t" + prefValue;}
5e14188f4a993447f2759289a5ef9e7eed0a2e23b82652120b376557eea325e5
clone
public EntityPrefWritable clone()
{    return new EntityPrefWritable(get(), prefValue);}
2df1b8ad294009b4502fdb0c06ef4e938f803851b809004268b514aed369c800
setup
protected void setup(Context context) throws IOException
{    Configuration conf = context.getConfiguration();    recommendationsPerUser = conf.getInt(NUM_RECOMMENDATIONS, DEFAULT_NUM_RECOMMENDATIONS);    booleanData = conf.getBoolean(RecommenderJob.BOOLEAN_DATA, false);    indexItemIDMap = TasteHadoopUtils.readIDIndexMap(conf.get(ITEMID_INDEX_PATH), conf);    idReader = new IDReader(conf);    idReader.readIDs();    itemsToRecommendFor = idReader.getItemIds();}
c937c01e125c0bdf6aa254b84d7894d8732487db05471597755b374daa3ab5f1
reduce
protected void reduce(VarLongWritable userID, Iterable<PrefAndSimilarityColumnWritable> values, Context context) throws IOException, InterruptedException
{    if (booleanData) {        reduceBooleanData(userID, values, context);    } else {        reduceNonBooleanData(userID, values, context);    }}
16dd14cefa8beffe98303a1144bd7c566dfab19c7298d6ab9ddb03125cdf1e41
reduceBooleanData
private void reduceBooleanData(VarLongWritable userID, Iterable<PrefAndSimilarityColumnWritable> values, Context context) throws IOException, InterruptedException
{    /* having boolean data, each estimated preference can only be 1,     * however we can't use this to rank the recommended items,     * so we use the sum of similarities for that. */    Iterator<PrefAndSimilarityColumnWritable> columns = values.iterator();    Vector predictions = columns.next().getSimilarityColumn();    while (columns.hasNext()) {        predictions.assign(columns.next().getSimilarityColumn(), Functions.PLUS);    }    writeRecommendedItems(userID, predictions, context);}
2abe995863efff9737bd4f99669a25e766fbfe0ae5bdc0f02e5e1992f15854ae
reduceNonBooleanData
private void reduceNonBooleanData(VarLongWritable userID, Iterable<PrefAndSimilarityColumnWritable> values, Context context) throws IOException, InterruptedException
{    /* each entry here is the sum in the numerator of the prediction formula */    Vector numerators = null;    /* each entry here is the sum in the denominator of the prediction formula */    Vector denominators = null;    /* each entry here is the number of similar items used in the prediction formula */    Vector numberOfSimilarItemsUsed = new RandomAccessSparseVector(Integer.MAX_VALUE, 100);    for (PrefAndSimilarityColumnWritable prefAndSimilarityColumn : values) {        Vector simColumn = prefAndSimilarityColumn.getSimilarityColumn();        float prefValue = prefAndSimilarityColumn.getPrefValue();        /* count the number of items used for each prediction */        for (Element e : simColumn.nonZeroes()) {            int itemIDIndex = e.index();            numberOfSimilarItemsUsed.setQuick(itemIDIndex, numberOfSimilarItemsUsed.getQuick(itemIDIndex) + 1);        }        if (denominators == null) {            denominators = simColumn.clone();        } else {            denominators.assign(simColumn, Functions.PLUS_ABS);        }        if (numerators == null) {            numerators = simColumn.clone();            if (prefValue != BOOLEAN_PREF_VALUE) {                numerators.assign(Functions.MULT, prefValue);            }        } else {            if (prefValue != BOOLEAN_PREF_VALUE) {                simColumn.assign(Functions.MULT, prefValue);            }            numerators.assign(simColumn, Functions.PLUS);        }    }    if (numerators == null) {        return;    }    Vector recommendationVector = new RandomAccessSparseVector(Integer.MAX_VALUE, 100);    for (Element element : numerators.nonZeroes()) {        int itemIDIndex = element.index();        /* preference estimations must be based on at least 2 datapoints */        if (numberOfSimilarItemsUsed.getQuick(itemIDIndex) > 1) {            /* compute normalized prediction */            double prediction = element.get() / denominators.getQuick(itemIDIndex);            recommendationVector.setQuick(itemIDIndex, prediction);        }    }    writeRecommendedItems(userID, recommendationVector, context);}
9ba5f60c4a5fd5610ab2695093647b2e4d3795686fa048218c9441a16536b0b1
writeRecommendedItems
private void writeRecommendedItems(VarLongWritable userID, Vector recommendationVector, Context context) throws IOException, InterruptedException
{    TopItemsQueue topKItems = new TopItemsQueue(recommendationsPerUser);    FastIDSet itemsForUser = null;    if (idReader != null && idReader.isUserItemFilterSpecified()) {        itemsForUser = idReader.getItemsToRecommendForUser(userID.get());    }    for (Element element : recommendationVector.nonZeroes()) {        int index = element.index();        long itemID;        if (indexItemIDMap != null && !indexItemIDMap.isEmpty()) {            itemID = indexItemIDMap.get(index);        } else {                        itemID = index;        }        if (shouldIncludeItemIntoRecommendations(itemID, itemsToRecommendFor, itemsForUser)) {            float value = (float) element.get();            if (!Float.isNaN(value)) {                MutableRecommendedItem topItem = topKItems.top();                if (value > topItem.getValue()) {                    topItem.set(itemID, value);                    topKItems.updateTop();                }            }        }    }    List<RecommendedItem> topItems = topKItems.getTopItems();    if (!topItems.isEmpty()) {        recommendedItems.set(topItems);        context.write(userID, recommendedItems);    }}
4a129533153eb88c08c2133df4e579453a162b1ea0e2a30db0d66749d7a9dbe7
shouldIncludeItemIntoRecommendations
private boolean shouldIncludeItemIntoRecommendations(long itemID, FastIDSet allItemsToRecommendFor, FastIDSet itemsForUser)
{    if (allItemsToRecommendFor == null && itemsForUser == null) {        return true;    } else if (itemsForUser != null) {        return itemsForUser.contains(itemID);    } else {        return allItemsToRecommendFor.contains(itemID);    }}
277e6ebfeebe9f0759e63c7ca175b627cd60d871675ff90c4ae1467b29e9b443
readIDs
public void readIDs() throws IOException, IllegalStateException
{    if (isUserItemFileSpecified()) {        readUserItemFilterIfNeeded();    }    if (isUsersFileSpecified() || isUserItemFilterSpecified()) {        readUserIds();    }    if (isItemsFileSpecified() || isUserItemFilterSpecified()) {        readItemIds();    }}
8519327e650bffdd44850571cbb6ca9ecd22751062d286a14f7a0fdf42ddd82e
getItemsToRecommendForUser
public FastIDSet getItemsToRecommendForUser(Long userId)
{    if (isUserItemFilterSpecified() && userItemFilter.containsKey(userId)) {        return userItemFilter.get(userId);    } else {        return emptySet;    }}
afccdec0778995d169045fded6b2f8927560e9b71f6a7abe65d3e145e65d18eb
readUserIds
private void readUserIds() throws IOException, IllegalStateException
{    if (isUsersFileSpecified() && !isUserItemFileSpecified()) {        userIds = readIDList(usersFile);    } else if (isUserItemFileSpecified() && !isUsersFileSpecified()) {        readUserItemFilterIfNeeded();        userIds = extractAllUserIdsFromUserItemFilter(userItemFilter);    } else if (!isUsersFileSpecified()) {        throw new IllegalStateException("Neither usersFile nor userItemFile options are specified");    } else {        throw new IllegalStateException("usersFile and userItemFile options cannot be used simultaneously");    }}
7205e32face3c003122759e951c730f6772fa7d39f71324da422475529d7549f
readItemIds
private void readItemIds() throws IOException, IllegalStateException
{    if (isItemsFileSpecified() && !isUserItemFileSpecified()) {        itemIds = readIDList(itemsFile);    } else if (isUserItemFileSpecified() && !isItemsFileSpecified()) {        readUserItemFilterIfNeeded();        itemIds = extractAllItemIdsFromUserItemFilter(userItemFilter);    } else if (!isItemsFileSpecified()) {        throw new IllegalStateException("Neither itemsFile nor userItemFile options are specified");    } else {        throw new IllegalStateException("itemsFile and userItemFile options cannot be specified simultaneously");    }}
1e1bbce691654f34cb528d44aa43e749c0062a5b515421e77e6724a262ea9421
readUserItemFilterIfNeeded
private void readUserItemFilterIfNeeded() throws IOException
{    if (!isUserItemFilterSpecified() && isUserItemFileSpecified()) {        userItemFilter = readUserItemFilter(userItemFile);    }}
8d6372c9ef1380c18e6ddbf33310f197e35251b28816ee46676fe355659f0aa9
readUserItemFilter
private Map<Long, FastIDSet> readUserItemFilter(String pathString) throws IOException
{    Map<Long, FastIDSet> result = new HashMap<>();    try (InputStream in = openFile(pathString)) {        for (String line : new FileLineIterable(in)) {            try {                String[] tokens = SEPARATOR.split(line);                Long userId = Long.parseLong(tokens[0]);                Long itemId = Long.parseLong(tokens[1]);                addUserAndItemIdToUserItemFilter(result, userId, itemId);            } catch (NumberFormatException nfe) {                log.warn("userItemFile line ignored: {}", line);            }        }    }    return result;}
148c07b7779ba25a2a4b7b21822bb6cc8b05d4d87dd87ac237fccd95115ce569
addUserAndItemIdToUserItemFilter
 void addUserAndItemIdToUserItemFilter(Map<Long, FastIDSet> filter, Long userId, Long itemId)
{    FastIDSet itemIds;    if (filter.containsKey(userId)) {        itemIds = filter.get(userId);    } else {        itemIds = new FastIDSet();        filter.put(userId, itemIds);    }    itemIds.add(itemId);}
9daac7aefad62f2c5094241a7f76e80f35d9be180e64b988db28db4dac72cb50
extractAllUserIdsFromUserItemFilter
 static FastIDSet extractAllUserIdsFromUserItemFilter(Map<Long, FastIDSet> filter)
{    FastIDSet result = new FastIDSet();    for (Long userId : filter.keySet()) {        result.add(userId);    }    return result;}
413d8fb919315b8c0905686d8a75d91e87d4a2162420f9048c38421373f94f07
extractAllItemIdsFromUserItemFilter
private FastIDSet extractAllItemIdsFromUserItemFilter(Map<Long, FastIDSet> filter)
{    FastIDSet result = new FastIDSet();    for (FastIDSet itemIds : filter.values()) {        result.addAll(itemIds);    }    return result;}
a8b16a94b2ee4dedea57a5ad02991aa7de8af0b78859247e9d76a10f9d66d364
readIDList
private FastIDSet readIDList(String pathString) throws IOException
{    FastIDSet result = null;    if (pathString != null) {        result = new FastIDSet();        try (InputStream in = openFile(pathString)) {            for (String line : new FileLineIterable(in)) {                try {                    result.add(Long.parseLong(line));                } catch (NumberFormatException nfe) {                    log.warn("line ignored: {}", line);                }            }        }    }    return result;}
05e2f463eaae6027d76de5e7d861b621e7becfb734c0d4d1f19a26199a6dda2f
openFile
private InputStream openFile(String pathString) throws IOException
{    return HadoopUtil.openStream(new Path(pathString), conf);}
45f921c5d702cc8dc792f5fde506bf7d9dc30b69ee3af91cb90dcc015a85fd59
isUsersFileSpecified
public boolean isUsersFileSpecified()
{    return usersFile != null;}
cb9d730f38322e0be06f588979e87282ed35f90f7db99f8c2561edf0a01949a5
isItemsFileSpecified
public boolean isItemsFileSpecified()
{    return itemsFile != null;}
9ecc684888eb7877bdd82669d6b2550bca11f4a9e02d5460bd9ac97896e3e049
isUserItemFileSpecified
public boolean isUserItemFileSpecified()
{    return userItemFile != null;}
b2c6f675e785b9058f1ef472cef43fbbc1c1428d7f8086c6671fc9ef5524e9af
isUserItemFilterSpecified
public boolean isUserItemFilterSpecified()
{    return userItemFilter != null;}
51688b6844b207a62ad07b790a332e998732a192d5ead3154fd0e299c41bf4e1
getUserIds
public FastIDSet getUserIds()
{    return userIds;}
2fb327475410fbc7a2ed0b91af9affbdbfca0adbd9d366c72365fefa5c58c730
getItemIds
public FastIDSet getItemIds()
{    return itemIds;}
868e7fb69f53de7649b2f27c41dd6143bba0c4615c4c86f2f799cd99ab8ff5b9
reduce
protected void reduce(VarLongWritable itemID, Iterable<VarLongWritable> values, Context ctx) throws IOException, InterruptedException
{    int itemIDIndex = TasteHadoopUtils.idToIndex(itemID.get());    Vector vector = new RandomAccessSparseVector(Integer.MAX_VALUE, 1);    /* artificial NaN summand to exclude this item from the recommendations for all users specified in userIDs */    vector.set(itemIDIndex, Double.NaN);    List<Long> userIDs = new ArrayList<>();    List<Float> prefValues = new ArrayList<>();    for (VarLongWritable userID : values) {        userIDs.add(userID.get());        prefValues.add(1.0f);    }    itemIDIndexWritable.set(itemIDIndex);    vectorAndPrefs.set(vector, userIDs, prefValues);    ctx.write(itemIDIndexWritable, vectorAndPrefs);}
25c419df496b37da3b704cb7d3657ad77420940369fe3f98a89672cff3f17a33
map
protected void map(LongWritable key, Text line, Context ctx) throws IOException, InterruptedException
{    String[] tokens = SEPARATOR.split(line.toString());    long userID = Long.parseLong(tokens[0]);    long itemID = Long.parseLong(tokens[1]);    itemIDWritable.set(itemID);    userIDWritable.set(userID);    ctx.write(itemIDWritable, userIDWritable);}
060f525386b455f09eb7716b87f0bfd887b14ef3f89a63fe017c0477d7dcaaaf
setup
protected void setup(Context context)
{    Configuration jobConf = context.getConfiguration();    transpose = jobConf.getBoolean(ToEntityPrefsMapper.TRANSPOSE_USER_ITEM, false);}
364372c8c0a17a2c3987e3f0d31a4140befe124df0e3310d5d0fe71e39f33b0f
map
protected void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException
{    String[] tokens = TasteHadoopUtils.splitPrefTokens(value.toString());    long itemID = Long.parseLong(tokens[transpose ? 0 : 1]);    int index = TasteHadoopUtils.idToIndex(itemID);    indexWritable.set(index);    itemIDWritable.set(itemID);    context.write(indexWritable, itemIDWritable);}
eb8bea03f9bc792e05a3d9348e6afe44289f4d8912f502f9e2864c5c57c65745
reduce
protected void reduce(VarIntWritable index, Iterable<VarLongWritable> possibleItemIDs, Context context) throws IOException, InterruptedException
{    long minimumItemID = Long.MAX_VALUE;    for (VarLongWritable varLongWritable : possibleItemIDs) {        long itemID = varLongWritable.get();        if (itemID < minimumItemID) {            minimumItemID = itemID;        }    }    if (minimumItemID != Long.MAX_VALUE) {        minimumItemIDWritable.set(minimumItemID);        context.write(index, minimumItemIDWritable);    }}
8b5e374fd039681a0d72abf722069775d7fbb4984f158d44cf75d2cd08ef8471
map
protected void map(VarIntWritable key, VectorAndPrefsWritable vectorAndPrefsWritable, Context context) throws IOException, InterruptedException
{    Vector similarityMatrixColumn = vectorAndPrefsWritable.getVector();    List<Long> userIDs = vectorAndPrefsWritable.getUserIDs();    List<Float> prefValues = vectorAndPrefsWritable.getValues();    for (int i = 0; i < userIDs.size(); i++) {        long userID = userIDs.get(i);        float prefValue = prefValues.get(i);        if (!Float.isNaN(prefValue)) {            prefAndSimilarityColumn.set(prefValue, similarityMatrixColumn);            userIDWritable.set(userID);            context.write(userIDWritable, prefAndSimilarityColumn);        }    }}
57a000ea4f6dd7e8300d8ea54e33f3214c1457946782128950f65a01ca241af1
set
public void set(float prefValue, Vector similarityColumn)
{    this.prefValue = prefValue;    this.similarityColumn = similarityColumn;}
3dea5becbc055ac5d579cec4c90deb19dbcdc9813c62e6cb8bc74e267e6f6c1d
getPrefValue
public float getPrefValue()
{    return prefValue;}
daae4f524f15c96f6afe5ad566a4d325389b536d4389dabcbf75d5dfeffb0f71
getSimilarityColumn
public Vector getSimilarityColumn()
{    return similarityColumn;}
5478cc5683f6dfd4515c383752d7c803555efc63d03fd84a03ba8dcd17eb4324
readFields
public void readFields(DataInput in) throws IOException
{    prefValue = in.readFloat();    VectorWritable vw = new VectorWritable();    vw.readFields(in);    similarityColumn = vw.get();}
a894510dd4db439ff8e17ae1059489dc3abc97178e5932ceed0c70c3af165401
write
public void write(DataOutput out) throws IOException
{    out.writeFloat(prefValue);    VectorWritable vw = new VectorWritable(similarityColumn);    vw.setWritesLaxPrecision(true);    vw.write(out);}
4afeb0868b55bdd8e18a00a3cb43d83e0714378d1c4bb36f0936daefc060e2e8
equals
public boolean equals(Object obj)
{    if (obj instanceof PrefAndSimilarityColumnWritable) {        PrefAndSimilarityColumnWritable other = (PrefAndSimilarityColumnWritable) obj;        return prefValue == other.prefValue && similarityColumn.equals(other.similarityColumn);    }    return false;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return RandomUtils.hashFloat(prefValue) + 31 * similarityColumn.hashCode();}
aacecb0f01750d985b78d806dc3c134f0da79efe2752957e0f93ecf5cbf9e492
run
public int run(String[] args) throws Exception
{    addInputOption();    addOutputOption();    addOption("numRecommendations", "n", "Number of recommendations per user", String.valueOf(AggregateAndRecommendReducer.DEFAULT_NUM_RECOMMENDATIONS));    addOption("usersFile", null, "File of users to recommend for", null);    addOption("itemsFile", null, "File of items to recommend for", null);    addOption("filterFile", "f", "File containing comma-separated userID,itemID pairs. Used to exclude the item from " + "the recommendations for that user (optional)", null);    addOption("userItemFile", "uif", "File containing comma-separated userID,itemID pairs (optional). " + "Used to include only these items into recommendations. " + "Cannot be used together with usersFile or itemsFile", null);    addOption("booleanData", "b", "Treat input as without pref values", Boolean.FALSE.toString());    addOption("maxPrefsPerUser", "mxp", "Maximum number of preferences considered per user in final recommendation phase", String.valueOf(UserVectorSplitterMapper.DEFAULT_MAX_PREFS_PER_USER_CONSIDERED));    addOption("minPrefsPerUser", "mp", "ignore users with less preferences than this in the similarity computation " + "(default: " + DEFAULT_MIN_PREFS_PER_USER + ')', String.valueOf(DEFAULT_MIN_PREFS_PER_USER));    addOption("maxSimilaritiesPerItem", "m", "Maximum number of similarities considered per item ", String.valueOf(DEFAULT_MAX_SIMILARITIES_PER_ITEM));    addOption("maxPrefsInItemSimilarity", "mpiis", "max number of preferences to consider per user or item in the " + "item similarity computation phase, users or items with more preferences will be sampled down (default: " + DEFAULT_MAX_PREFS + ')', String.valueOf(DEFAULT_MAX_PREFS));    addOption("similarityClassname", "s", "Name of distributed similarity measures class to instantiate, " + "alternatively use one of the predefined similarities (" + VectorSimilarityMeasures.list() + ')', true);    addOption("threshold", "tr", "discard item pairs with a similarity value below this", false);    addOption("outputPathForSimilarityMatrix", "opfsm", "write the item similarity matrix to this path (optional)", false);    addOption("randomSeed", null, "use this seed for sampling", false);    addFlag("sequencefileOutput", null, "write the output into a SequenceFile instead of a text file");    Map<String, List<String>> parsedArgs = parseArguments(args);    if (parsedArgs == null) {        return -1;    }    Path outputPath = getOutputPath();    int numRecommendations = Integer.parseInt(getOption("numRecommendations"));    String usersFile = getOption("usersFile");    String itemsFile = getOption("itemsFile");    String filterFile = getOption("filterFile");    String userItemFile = getOption("userItemFile");    boolean booleanData = Boolean.valueOf(getOption("booleanData"));    int maxPrefsPerUser = Integer.parseInt(getOption("maxPrefsPerUser"));    int minPrefsPerUser = Integer.parseInt(getOption("minPrefsPerUser"));    int maxPrefsInItemSimilarity = Integer.parseInt(getOption("maxPrefsInItemSimilarity"));    int maxSimilaritiesPerItem = Integer.parseInt(getOption("maxSimilaritiesPerItem"));    String similarityClassname = getOption("similarityClassname");    double threshold = hasOption("threshold") ? Double.parseDouble(getOption("threshold")) : RowSimilarityJob.NO_THRESHOLD;    long randomSeed = hasOption("randomSeed") ? Long.parseLong(getOption("randomSeed")) : RowSimilarityJob.NO_FIXED_RANDOM_SEED;    Path prepPath = getTempPath(DEFAULT_PREPARE_PATH);    Path similarityMatrixPath = getTempPath("similarityMatrix");    Path explicitFilterPath = getTempPath("explicitFilterPath");    Path partialMultiplyPath = getTempPath("partialMultiply");    AtomicInteger currentPhase = new AtomicInteger();    int numberOfUsers = -1;    if (shouldRunNextPhase(parsedArgs, currentPhase)) {        ToolRunner.run(getConf(), new PreparePreferenceMatrixJob(), new String[] { "--input", getInputPath().toString(), "--output", prepPath.toString(), "--minPrefsPerUser", String.valueOf(minPrefsPerUser), "--booleanData", String.valueOf(booleanData), "--tempDir", getTempPath().toString() });        numberOfUsers = HadoopUtil.readInt(new Path(prepPath, PreparePreferenceMatrixJob.NUM_USERS), getConf());    }    if (shouldRunNextPhase(parsedArgs, currentPhase)) {        /* special behavior if phase 1 is skipped */        if (numberOfUsers == -1) {            numberOfUsers = (int) HadoopUtil.countRecords(new Path(prepPath, PreparePreferenceMatrixJob.USER_VECTORS), PathType.LIST, null, getConf());        }                ToolRunner.run(getConf(), new RowSimilarityJob(), new String[] { "--input", new Path(prepPath, PreparePreferenceMatrixJob.RATING_MATRIX).toString(), "--output", similarityMatrixPath.toString(), "--numberOfColumns", String.valueOf(numberOfUsers), "--similarityClassname", similarityClassname, "--maxObservationsPerRow", String.valueOf(maxPrefsInItemSimilarity), "--maxObservationsPerColumn", String.valueOf(maxPrefsInItemSimilarity), "--maxSimilaritiesPerRow", String.valueOf(maxSimilaritiesPerItem), "--excludeSelfSimilarity", String.valueOf(Boolean.TRUE), "--threshold", String.valueOf(threshold), "--randomSeed", String.valueOf(randomSeed), "--tempDir", getTempPath().toString() });                if (hasOption("outputPathForSimilarityMatrix")) {            Path outputPathForSimilarityMatrix = new Path(getOption("outputPathForSimilarityMatrix"));            Job outputSimilarityMatrix = prepareJob(similarityMatrixPath, outputPathForSimilarityMatrix, SequenceFileInputFormat.class, ItemSimilarityJob.MostSimilarItemPairsMapper.class, EntityEntityWritable.class, DoubleWritable.class, ItemSimilarityJob.MostSimilarItemPairsReducer.class, EntityEntityWritable.class, DoubleWritable.class, TextOutputFormat.class);            Configuration mostSimilarItemsConf = outputSimilarityMatrix.getConfiguration();            mostSimilarItemsConf.set(ItemSimilarityJob.ITEM_ID_INDEX_PATH_STR, new Path(prepPath, PreparePreferenceMatrixJob.ITEMID_INDEX).toString());            mostSimilarItemsConf.setInt(ItemSimilarityJob.MAX_SIMILARITIES_PER_ITEM, maxSimilaritiesPerItem);            outputSimilarityMatrix.waitForCompletion(true);        }    }        if (shouldRunNextPhase(parsedArgs, currentPhase)) {        Job partialMultiply = Job.getInstance(getConf(), "partialMultiply");        Configuration partialMultiplyConf = partialMultiply.getConfiguration();        MultipleInputs.addInputPath(partialMultiply, similarityMatrixPath, SequenceFileInputFormat.class, SimilarityMatrixRowWrapperMapper.class);        MultipleInputs.addInputPath(partialMultiply, new Path(prepPath, PreparePreferenceMatrixJob.USER_VECTORS), SequenceFileInputFormat.class, UserVectorSplitterMapper.class);        partialMultiply.setJarByClass(ToVectorAndPrefReducer.class);        partialMultiply.setMapOutputKeyClass(VarIntWritable.class);        partialMultiply.setMapOutputValueClass(VectorOrPrefWritable.class);        partialMultiply.setReducerClass(ToVectorAndPrefReducer.class);        partialMultiply.setOutputFormatClass(SequenceFileOutputFormat.class);        partialMultiply.setOutputKeyClass(VarIntWritable.class);        partialMultiply.setOutputValueClass(VectorAndPrefsWritable.class);        partialMultiplyConf.setBoolean("mapred.compress.map.output", true);        partialMultiplyConf.set("mapred.output.dir", partialMultiplyPath.toString());        if (usersFile != null) {            partialMultiplyConf.set(UserVectorSplitterMapper.USERS_FILE, usersFile);        }        if (userItemFile != null) {            partialMultiplyConf.set(IDReader.USER_ITEM_FILE, userItemFile);        }        partialMultiplyConf.setInt(UserVectorSplitterMapper.MAX_PREFS_PER_USER_CONSIDERED, maxPrefsPerUser);        boolean succeeded = partialMultiply.waitForCompletion(true);        if (!succeeded) {            return -1;        }    }    if (shouldRunNextPhase(parsedArgs, currentPhase)) {        /* convert the user/item pairs to filter if a filterfile has been specified */        if (filterFile != null) {            Job itemFiltering = prepareJob(new Path(filterFile), explicitFilterPath, TextInputFormat.class, ItemFilterMapper.class, VarLongWritable.class, VarLongWritable.class, ItemFilterAsVectorAndPrefsReducer.class, VarIntWritable.class, VectorAndPrefsWritable.class, SequenceFileOutputFormat.class);            boolean succeeded = itemFiltering.waitForCompletion(true);            if (!succeeded) {                return -1;            }        }        String aggregateAndRecommendInput = partialMultiplyPath.toString();        if (filterFile != null) {            aggregateAndRecommendInput += "," + explicitFilterPath;        }        Class<? extends OutputFormat> outputFormat = parsedArgs.containsKey("--sequencefileOutput") ? SequenceFileOutputFormat.class : TextOutputFormat.class;                Job aggregateAndRecommend = prepareJob(new Path(aggregateAndRecommendInput), outputPath, SequenceFileInputFormat.class, PartialMultiplyMapper.class, VarLongWritable.class, PrefAndSimilarityColumnWritable.class, AggregateAndRecommendReducer.class, VarLongWritable.class, RecommendedItemsWritable.class, outputFormat);        Configuration aggregateAndRecommendConf = aggregateAndRecommend.getConfiguration();        if (itemsFile != null) {            aggregateAndRecommendConf.set(AggregateAndRecommendReducer.ITEMS_FILE, itemsFile);        }        if (userItemFile != null) {            aggregateAndRecommendConf.set(IDReader.USER_ITEM_FILE, userItemFile);        }        if (filterFile != null) {            setS3SafeCombinedInputPath(aggregateAndRecommend, getTempPath(), partialMultiplyPath, explicitFilterPath);        }        setIOSort(aggregateAndRecommend);        aggregateAndRecommendConf.set(AggregateAndRecommendReducer.ITEMID_INDEX_PATH, new Path(prepPath, PreparePreferenceMatrixJob.ITEMID_INDEX).toString());        aggregateAndRecommendConf.setInt(AggregateAndRecommendReducer.NUM_RECOMMENDATIONS, numRecommendations);        aggregateAndRecommendConf.setBoolean(BOOLEAN_DATA, booleanData);        boolean succeeded = aggregateAndRecommend.waitForCompletion(true);        if (!succeeded) {            return -1;        }    }    return 0;}
82d5c85ed45d4ac042f35e48ae0d48a975ed7d0200a6c98c56b7e2dd426503c1
setIOSort
private static void setIOSort(JobContext job)
{    Configuration conf = job.getConfiguration();    conf.setInt("io.sort.factor", 100);        String javaOpts = conf.get("mapred.map.child.java.opts");    if (javaOpts == null) {                javaOpts = conf.get("mapred.child.java.opts");    }    int assumedHeapSize = 512;    if (javaOpts != null) {        Matcher m = Pattern.compile("-Xmx([0-9]+)([mMgG])").matcher(javaOpts);        if (m.find()) {            assumedHeapSize = Integer.parseInt(m.group(1));            String megabyteOrGigabyte = m.group(2);            if ("g".equalsIgnoreCase(megabyteOrGigabyte)) {                assumedHeapSize *= 1024;            }        }    }        conf.setInt("io.sort.mb", Math.min(assumedHeapSize / 2, 1024));            conf.setInt("mapred.task.timeout", 60 * 60 * 1000);}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    ToolRunner.run(new Configuration(), new RecommenderJob(), args);}
b32d53b76be17c259dec1fb28708d1dc8c56fdc392675bbdac5be7f2e9f09ab1
map
protected void map(IntWritable key, VectorWritable value, Context context) throws IOException, InterruptedException
{    Vector similarityMatrixRow = value.get();    /* remove self similarity */    similarityMatrixRow.set(key.get(), Double.NaN);    index.set(key.get());    vectorOrPref.set(similarityMatrixRow);    context.write(index, vectorOrPref);}
d3192444cabbcc9598d5706bfdcd1dfedd209d3688c3c575e42fd6b75ea83739
setup
protected void setup(Context ctx) throws IOException, InterruptedException
{    super.setup(ctx);    minPreferences = ctx.getConfiguration().getInt(MIN_PREFERENCES_PER_USER, 1);}
de44241f28f8f68abd56c982f654620ca937a4840b46bed4d019c7c9809ed2a8
reduce
protected void reduce(VarLongWritable userID, Iterable<VarLongWritable> itemPrefs, Context context) throws IOException, InterruptedException
{    Vector userVector = new RandomAccessSparseVector(Integer.MAX_VALUE, 100);    for (VarLongWritable itemPref : itemPrefs) {        int index = TasteHadoopUtils.idToIndex(itemPref.get());        float value = itemPref instanceof EntityPrefWritable ? ((EntityPrefWritable) itemPref).getPrefValue() : 1.0f;        userVector.set(index, value);    }    if (userVector.getNumNondefaultElements() >= minPreferences) {        userVectorWritable.set(userVector);        userVectorWritable.setWritesLaxPrecision(true);        context.getCounter(Counters.USERS).increment(1);        context.write(userID, userVectorWritable);    }}
495f2609f12d043cc8fe78815d09456b3f4fcca793b264256031bef049ef428c
reduce
protected void reduce(VarIntWritable key, Iterable<VectorOrPrefWritable> values, Context context) throws IOException, InterruptedException
{    List<Long> userIDs = new ArrayList<>();    List<Float> prefValues = new ArrayList<>();    Vector similarityMatrixColumn = null;    for (VectorOrPrefWritable value : values) {        if (value.getVector() == null) {                        userIDs.add(value.getUserID());            prefValues.add(value.getValue());        } else {                        if (similarityMatrixColumn != null) {                throw new IllegalStateException("Found two similarity-matrix columns for item index " + key.get());            }            similarityMatrixColumn = value.getVector();        }    }    if (similarityMatrixColumn == null) {        return;    }    vectorAndPrefs.set(similarityMatrixColumn, userIDs, prefValues);    context.write(key, vectorAndPrefs);}
2df1b8ad294009b4502fdb0c06ef4e938f803851b809004268b514aed369c800
setup
protected void setup(Context context) throws IOException
{    Configuration jobConf = context.getConfiguration();    maxPrefsPerUserConsidered = jobConf.getInt(MAX_PREFS_PER_USER_CONSIDERED, DEFAULT_MAX_PREFS_PER_USER_CONSIDERED);    IDReader idReader = new IDReader(jobConf);    idReader.readIDs();    usersToRecommendFor = idReader.getUserIds();}
dd5fece87f6543fdfd0b4ef828f60878763c7bedc2365dd16a291209a9bc1db8
map
protected void map(VarLongWritable key, VectorWritable value, Context context) throws IOException, InterruptedException
{    long userID = key.get();    log.info("UserID = {}", userID);    if (usersToRecommendFor != null && !usersToRecommendFor.contains(userID)) {        return;    }    Vector userVector = maybePruneUserVector(value.get());    for (Element e : userVector.nonZeroes()) {        itemIndexWritable.set(e.index());        vectorOrPref.set(userID, (float) e.get());        context.write(itemIndexWritable, vectorOrPref);    }}
c9e637a517c1d2ec3b5124285613d35af168deb1f313e4bc0f36b93fb62affd4
maybePruneUserVector
private Vector maybePruneUserVector(Vector userVector)
{    if (userVector.getNumNondefaultElements() <= maxPrefsPerUserConsidered) {        return userVector;    }    float smallestLargeValue = findSmallestLargeValue(userVector);        for (Element e : userVector.nonZeroes()) {        float absValue = Math.abs((float) e.get());        if (absValue < smallestLargeValue) {            e.set(Float.NaN);        }    }    return userVector;}
916176b08f99362002cb218bc4c0504e9a48d6bc235bc9d7b7b71e34cf86ab80
findSmallestLargeValue
private float findSmallestLargeValue(Vector userVector)
{    PriorityQueue<Float> topPrefValues = new PriorityQueue<Float>(maxPrefsPerUserConsidered) {        @Override        protected boolean lessThan(Float f1, Float f2) {            return f1 < f2;        }    };    for (Element e : userVector.nonZeroes()) {        float absValue = Math.abs((float) e.get());        topPrefValues.insertWithOverflow(absValue);    }    return topPrefValues.top();}
02bcd641df4dc1b1195f910fed2f44d6a5ac4d080c6e7784e078726cc26eacd2
lessThan
protected boolean lessThan(Float f1, Float f2)
{    return f1 < f2;}
e656023cca735d0b5fc865426ad4c3a2c8d8f62b6812a9fe33e2bd674558cb40
set
public void set(Vector vector, List<Long> userIDs, List<Float> values)
{    this.vector = vector;    this.userIDs = userIDs;    this.values = values;}
79cbed8ec593faceb4946ba56ec5347061f2a2b271e2c36d7de0e1f0ae5aa0d3
getVector
public Vector getVector()
{    return vector;}
4191835a418cbfdf21dbee29b8cf19ea604aba7ce196b278c80a7afa27e48d29
getUserIDs
public List<Long> getUserIDs()
{    return userIDs;}
bd695dac827536dfb0166f91219639fc713168f210f906aabd866a60ebf8d3e4
getValues
public List<Float> getValues()
{    return values;}
a894510dd4db439ff8e17ae1059489dc3abc97178e5932ceed0c70c3af165401
write
public void write(DataOutput out) throws IOException
{    VectorWritable vw = new VectorWritable(vector);    vw.setWritesLaxPrecision(true);    vw.write(out);    Varint.writeUnsignedVarInt(userIDs.size(), out);    for (int i = 0; i < userIDs.size(); i++) {        Varint.writeSignedVarLong(userIDs.get(i), out);        out.writeFloat(values.get(i));    }}
5478cc5683f6dfd4515c383752d7c803555efc63d03fd84a03ba8dcd17eb4324
readFields
public void readFields(DataInput in) throws IOException
{    VectorWritable writable = new VectorWritable();    writable.readFields(in);    vector = writable.get();    int size = Varint.readUnsignedVarInt(in);    userIDs = new ArrayList<>(size);    values = new ArrayList<>(size);    for (int i = 0; i < size; i++) {        userIDs.add(Varint.readSignedVarLong(in));        values.add(in.readFloat());    }}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return vector + "\t" + userIDs + '\t' + values;}
79cbed8ec593faceb4946ba56ec5347061f2a2b271e2c36d7de0e1f0ae5aa0d3
getVector
public Vector getVector()
{    return vector;}
f6291b447e197e279017739fa55cf012e1c9d4eed6fb9eb0dd5d639a28f5227d
getUserID
public long getUserID()
{    return userID;}
875eb4918e20f05856417a7a1eae0829852fb11067dcbf34f10f2a09bcacd7bb
getValue
public float getValue()
{    return value;}
acc78b0347a9b60851fe6e2281aeeb235f5e53237660434ab58b91834ed542db
set
 void set(Vector vector)
{    this.vector = vector;    this.userID = Long.MIN_VALUE;    this.value = Float.NaN;}
2e6e70d1cd6cbf7867e1399fd4dace477c3b7bb6e3254209504df04855f5cff8
set
public void set(long userID, float value)
{    this.vector = null;    this.userID = userID;    this.value = value;}
a894510dd4db439ff8e17ae1059489dc3abc97178e5932ceed0c70c3af165401
write
public void write(DataOutput out) throws IOException
{    if (vector == null) {        out.writeBoolean(false);        Varint.writeSignedVarLong(userID, out);        out.writeFloat(value);    } else {        out.writeBoolean(true);        VectorWritable vw = new VectorWritable(vector);        vw.setWritesLaxPrecision(true);        vw.write(out);    }}
5478cc5683f6dfd4515c383752d7c803555efc63d03fd84a03ba8dcd17eb4324
readFields
public void readFields(DataInput in) throws IOException
{    boolean hasVector = in.readBoolean();    if (hasVector) {        VectorWritable writable = new VectorWritable();        writable.readFields(in);        set(writable.get());    } else {        long theUserID = Varint.readSignedVarLong(in);        float theValue = in.readFloat();        set(theUserID, theValue);    }}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return vector == null ? userID + ":" + value : vector.toString();}
656666c3e1a83c6eb409c8bf7c3282b6209c6991806a5f70debc7368d69aec7d
getItemID
public long getItemID()
{    return itemID;}
875eb4918e20f05856417a7a1eae0829852fb11067dcbf34f10f2a09bcacd7bb
getValue
public float getValue()
{    return value;}
2aca5393b88423cf57c53e6245e899b092b76572998cbe8040bdafad30b2bfea
setItemID
public void setItemID(long itemID)
{    this.itemID = itemID;}
7c522267b7f5353dbbf573e88531df668abe11430e76e7d86178cd464d6c5bf5
set
public void set(long itemID, float value)
{    this.itemID = itemID;    this.value = value;}
b36b1b92afffd486e3bcd67122aa5368cf0ecec917de52be04f539d67c2491b7
capToMaxValue
public void capToMaxValue(float maxValue)
{    if (value > maxValue) {        value = maxValue;    }}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "MutableRecommendedItem[item:" + itemID + ", value:" + value + ']';}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return (int) itemID ^ RandomUtils.hashFloat(value);}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (!(o instanceof MutableRecommendedItem)) {        return false;    }    RecommendedItem other = (RecommendedItem) o;    return itemID == other.getItemID() && value == other.getValue();}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    ToolRunner.run(new PreparePreferenceMatrixJob(), args);}
aacecb0f01750d985b78d806dc3c134f0da79efe2752957e0f93ecf5cbf9e492
run
public int run(String[] args) throws Exception
{    addInputOption();    addOutputOption();    addOption("minPrefsPerUser", "mp", "ignore users with less preferences than this " + "(default: " + DEFAULT_MIN_PREFS_PER_USER + ')', String.valueOf(DEFAULT_MIN_PREFS_PER_USER));    addOption("booleanData", "b", "Treat input as without pref values", Boolean.FALSE.toString());    addOption("ratingShift", "rs", "shift ratings by this value", "0.0");    Map<String, List<String>> parsedArgs = parseArguments(args);    if (parsedArgs == null) {        return -1;    }    int minPrefsPerUser = Integer.parseInt(getOption("minPrefsPerUser"));    boolean booleanData = Boolean.valueOf(getOption("booleanData"));    float ratingShift = Float.parseFloat(getOption("ratingShift"));        Job itemIDIndex = prepareJob(getInputPath(), getOutputPath(ITEMID_INDEX), TextInputFormat.class, ItemIDIndexMapper.class, VarIntWritable.class, VarLongWritable.class, ItemIDIndexReducer.class, VarIntWritable.class, VarLongWritable.class, SequenceFileOutputFormat.class);    itemIDIndex.setCombinerClass(ItemIDIndexReducer.class);    boolean succeeded = itemIDIndex.waitForCompletion(true);    if (!succeeded) {        return -1;    }        Job toUserVectors = prepareJob(getInputPath(), getOutputPath(USER_VECTORS), TextInputFormat.class, ToItemPrefsMapper.class, VarLongWritable.class, booleanData ? VarLongWritable.class : EntityPrefWritable.class, ToUserVectorsReducer.class, VarLongWritable.class, VectorWritable.class, SequenceFileOutputFormat.class);    toUserVectors.getConfiguration().setBoolean(RecommenderJob.BOOLEAN_DATA, booleanData);    toUserVectors.getConfiguration().setInt(ToUserVectorsReducer.MIN_PREFERENCES_PER_USER, minPrefsPerUser);    toUserVectors.getConfiguration().set(ToEntityPrefsMapper.RATING_SHIFT, String.valueOf(ratingShift));    succeeded = toUserVectors.waitForCompletion(true);    if (!succeeded) {        return -1;    }        int numberOfUsers = (int) toUserVectors.getCounters().findCounter(ToUserVectorsReducer.Counters.USERS).getValue();    HadoopUtil.writeInt(numberOfUsers, getOutputPath(NUM_USERS), getConf());        Job toItemVectors = prepareJob(getOutputPath(USER_VECTORS), getOutputPath(RATING_MATRIX), ToItemVectorsMapper.class, IntWritable.class, VectorWritable.class, ToItemVectorsReducer.class, IntWritable.class, VectorWritable.class);    toItemVectors.setCombinerClass(ToItemVectorsReducer.class);    succeeded = toItemVectors.waitForCompletion(true);    if (!succeeded) {        return -1;    }    return 0;}
6def0f571009de80c172663a1705b0a5e4cc5a8585c24348333a1f7241b0ee8a
map
protected void map(VarLongWritable rowIndex, VectorWritable vectorWritable, Context ctx) throws IOException, InterruptedException
{    Vector userRatings = vectorWritable.get();    int column = TasteHadoopUtils.idToIndex(rowIndex.get());    itemVectorWritable.setWritesLaxPrecision(true);    Vector itemVector = new RandomAccessSparseVector(Integer.MAX_VALUE, 1);    for (Vector.Element elem : userRatings.nonZeroes()) {        itemID.set(elem.index());        itemVector.setQuick(column, elem.get());        itemVectorWritable.set(itemVector);        ctx.write(itemID, itemVectorWritable);                itemVector.setQuick(elem.index(), 0.0);    }}
d4a656954ac3d60d8b5fec75dd95e2cb100a90bfb24e5e48ce7350ab67b70bc8
reduce
protected void reduce(IntWritable row, Iterable<VectorWritable> vectors, Context ctx) throws IOException, InterruptedException
{    merged.setWritesLaxPrecision(true);    merged.set(VectorWritable.mergeToVector(vectors.iterator()));    ctx.write(row, merged);}
8aa1ac3b121ba13155defc780e9225a4d37a8308dc2e00c1320d36f383e4156f
getRecommendedItems
public List<RecommendedItem> getRecommendedItems()
{    return recommended;}
811ae9bc85b5db9673339286a9f483c27720ce7b24cd649ab6e7ff5835036189
set
public void set(List<RecommendedItem> recommended)
{    this.recommended = recommended;}
a894510dd4db439ff8e17ae1059489dc3abc97178e5932ceed0c70c3af165401
write
public void write(DataOutput out) throws IOException
{    out.writeInt(recommended.size());    for (RecommendedItem item : recommended) {        Varint.writeSignedVarLong(item.getItemID(), out);        out.writeFloat(item.getValue());    }}
5478cc5683f6dfd4515c383752d7c803555efc63d03fd84a03ba8dcd17eb4324
readFields
public void readFields(DataInput in) throws IOException
{    int size = in.readInt();    recommended = new ArrayList<>(size);    for (int i = 0; i < size; i++) {        long itemID = Varint.readSignedVarLong(in);        float value = in.readFloat();        RecommendedItem recommendedItem = new GenericRecommendedItem(itemID, value);        recommended.add(recommendedItem);    }}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    StringBuilder result = new StringBuilder(200);    result.append('[');    boolean first = true;    for (RecommendedItem item : recommended) {        if (first) {            first = false;        } else {            result.append(',');        }        result.append(String.valueOf(item.getItemID()));        result.append(':');        result.append(String.valueOf(item.getValue()));    }    result.append(']');    return result.toString();}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    ToolRunner.run(new ItemSimilarityJob(), args);}
aacecb0f01750d985b78d806dc3c134f0da79efe2752957e0f93ecf5cbf9e492
run
public int run(String[] args) throws Exception
{    addInputOption();    addOutputOption();    addOption("similarityClassname", "s", "Name of distributed similarity measures class to instantiate, " + "alternatively use one of the predefined similarities (" + VectorSimilarityMeasures.list() + ')');    addOption("maxSimilaritiesPerItem", "m", "try to cap the number of similar items per item to this number " + "(default: " + DEFAULT_MAX_SIMILAR_ITEMS_PER_ITEM + ')', String.valueOf(DEFAULT_MAX_SIMILAR_ITEMS_PER_ITEM));    addOption("maxPrefs", "mppu", "max number of preferences to consider per user or item, " + "users or items with more preferences will be sampled down (default: " + DEFAULT_MAX_PREFS + ')', String.valueOf(DEFAULT_MAX_PREFS));    addOption("minPrefsPerUser", "mp", "ignore users with less preferences than this " + "(default: " + DEFAULT_MIN_PREFS_PER_USER + ')', String.valueOf(DEFAULT_MIN_PREFS_PER_USER));    addOption("booleanData", "b", "Treat input as without pref values", String.valueOf(Boolean.FALSE));    addOption("threshold", "tr", "discard item pairs with a similarity value below this", false);    addOption("randomSeed", null, "use this seed for sampling", false);    Map<String, List<String>> parsedArgs = parseArguments(args);    if (parsedArgs == null) {        return -1;    }    String similarityClassName = getOption("similarityClassname");    int maxSimilarItemsPerItem = Integer.parseInt(getOption("maxSimilaritiesPerItem"));    int maxPrefs = Integer.parseInt(getOption("maxPrefs"));    int minPrefsPerUser = Integer.parseInt(getOption("minPrefsPerUser"));    boolean booleanData = Boolean.valueOf(getOption("booleanData"));    double threshold = hasOption("threshold") ? Double.parseDouble(getOption("threshold")) : RowSimilarityJob.NO_THRESHOLD;    long randomSeed = hasOption("randomSeed") ? Long.parseLong(getOption("randomSeed")) : RowSimilarityJob.NO_FIXED_RANDOM_SEED;    Path similarityMatrixPath = getTempPath("similarityMatrix");    Path prepPath = getTempPath("prepareRatingMatrix");    AtomicInteger currentPhase = new AtomicInteger();    if (shouldRunNextPhase(parsedArgs, currentPhase)) {        ToolRunner.run(getConf(), new PreparePreferenceMatrixJob(), new String[] { "--input", getInputPath().toString(), "--output", prepPath.toString(), "--minPrefsPerUser", String.valueOf(minPrefsPerUser), "--booleanData", String.valueOf(booleanData), "--tempDir", getTempPath().toString() });    }    if (shouldRunNextPhase(parsedArgs, currentPhase)) {        int numberOfUsers = HadoopUtil.readInt(new Path(prepPath, PreparePreferenceMatrixJob.NUM_USERS), getConf());        ToolRunner.run(getConf(), new RowSimilarityJob(), new String[] { "--input", new Path(prepPath, PreparePreferenceMatrixJob.RATING_MATRIX).toString(), "--output", similarityMatrixPath.toString(), "--numberOfColumns", String.valueOf(numberOfUsers), "--similarityClassname", similarityClassName, "--maxObservationsPerRow", String.valueOf(maxPrefs), "--maxObservationsPerColumn", String.valueOf(maxPrefs), "--maxSimilaritiesPerRow", String.valueOf(maxSimilarItemsPerItem), "--excludeSelfSimilarity", String.valueOf(Boolean.TRUE), "--threshold", String.valueOf(threshold), "--randomSeed", String.valueOf(randomSeed), "--tempDir", getTempPath().toString() });    }    if (shouldRunNextPhase(parsedArgs, currentPhase)) {        Job mostSimilarItems = prepareJob(similarityMatrixPath, getOutputPath(), SequenceFileInputFormat.class, MostSimilarItemPairsMapper.class, EntityEntityWritable.class, DoubleWritable.class, MostSimilarItemPairsReducer.class, EntityEntityWritable.class, DoubleWritable.class, TextOutputFormat.class);        Configuration mostSimilarItemsConf = mostSimilarItems.getConfiguration();        mostSimilarItemsConf.set(ITEM_ID_INDEX_PATH_STR, new Path(prepPath, PreparePreferenceMatrixJob.ITEMID_INDEX).toString());        mostSimilarItemsConf.setInt(MAX_SIMILARITIES_PER_ITEM, maxSimilarItemsPerItem);        boolean succeeded = mostSimilarItems.waitForCompletion(true);        if (!succeeded) {            return -1;        }    }    return 0;}
2cb3ae4fbc137ae1b3aee43abae5e0e67ddb725989248fb2c61a55c3a78a5f89
setup
protected void setup(Context ctx)
{    Configuration conf = ctx.getConfiguration();    maxSimilarItemsPerItem = conf.getInt(MAX_SIMILARITIES_PER_ITEM, -1);    indexItemIDMap = TasteHadoopUtils.readIDIndexMap(conf.get(ITEM_ID_INDEX_PATH_STR), conf);    Preconditions.checkArgument(maxSimilarItemsPerItem > 0, "maxSimilarItemsPerItem must be greater then 0!");}
c7c975c645831ad76db8d68aa8a18d3e1b3415c6ed9808dd2f6ad17f1aec2ae7
map
protected void map(IntWritable itemIDIndexWritable, VectorWritable similarityVector, Context ctx) throws IOException, InterruptedException
{    int itemIDIndex = itemIDIndexWritable.get();    TopSimilarItemsQueue topKMostSimilarItems = new TopSimilarItemsQueue(maxSimilarItemsPerItem);    for (Vector.Element element : similarityVector.get().nonZeroes()) {        SimilarItem top = topKMostSimilarItems.top();        double candidateSimilarity = element.get();        if (candidateSimilarity > top.getSimilarity()) {            top.set(indexItemIDMap.get(element.index()), candidateSimilarity);            topKMostSimilarItems.updateTop();        }    }    long itemID = indexItemIDMap.get(itemIDIndex);    for (SimilarItem similarItem : topKMostSimilarItems.getTopItems()) {        long otherItemID = similarItem.getItemID();        if (itemID < otherItemID) {            ctx.write(new EntityEntityWritable(itemID, otherItemID), new DoubleWritable(similarItem.getSimilarity()));        } else {            ctx.write(new EntityEntityWritable(otherItemID, itemID), new DoubleWritable(similarItem.getSimilarity()));        }    }}
595ea8b66ffe1bc8cec4f80d24cefa59c1c1d165bf8874cb238fcc9776f259f4
reduce
protected void reduce(EntityEntityWritable pair, Iterable<DoubleWritable> values, Context ctx) throws IOException, InterruptedException
{    ctx.write(pair, values.iterator().next());}
30b53da291199401da5ee24d65b70a530b811cb386e9f4666cc08babef69b8ae
getTopItems
public List<SimilarItem> getTopItems()
{    List<SimilarItem> items = new ArrayList<>(maxSize);    while (size() > 0) {        SimilarItem topItem = pop();                if (topItem.getItemID() != SENTINEL_ID) {            items.add(topItem);        }    }    Collections.reverse(items);    return items;}
0ef79e7face38e6928ac2c2ba988d57fcbebb32fca2aaf1f9e9def3db8b5620a
lessThan
protected boolean lessThan(SimilarItem one, SimilarItem two)
{    return one.getSimilarity() < two.getSimilarity();}
2fc2e3261b35cba7f14b411d99c5f7e845713fb47e92b37852ef1c8eb98e049c
getSentinelObject
protected SimilarItem getSentinelObject()
{    return new SimilarItem(SENTINEL_ID, Double.MIN_VALUE);}
6f9fa18a3216c3e9b0862304329788a62f1628fc5715a396d163708b131d2076
splitPrefTokens
public static String[] splitPrefTokens(CharSequence line)
{    return PREFERENCE_TOKEN_DELIMITER.split(line);}
e8306bb63dee79102bbe186cec4b23d2abbaff897ea78b683597c5340fd30a5e
idToIndex
public static int idToIndex(long id)
{    return 0x7FFFFFFF & Longs.hashCode(id) % 0x7FFFFFFE;}
737d0dbc3f729cea3127d7ba4e653d67c308eb42fe22845214d65daba57551d1
readID
public static int readID(String token, boolean usesLongIDs)
{    return usesLongIDs ? idToIndex(Long.parseLong(token)) : Integer.parseInt(token);}
e3fa0a70cd640a0a71b214d0465da7ecc2f5b09eaa904760c97256f439bfbcb6
readIDIndexMap
public static OpenIntLongHashMap readIDIndexMap(String idIndexPathStr, Configuration conf)
{    OpenIntLongHashMap indexIDMap = new OpenIntLongHashMap();    Path itemIDIndexPath = new Path(idIndexPathStr);    for (Pair<VarIntWritable, VarLongWritable> record : new SequenceFileDirIterable<VarIntWritable, VarLongWritable>(itemIDIndexPath, PathType.LIST, PathFilters.partFilter(), null, true, conf)) {        indexIDMap.put(record.getFirst().get(), record.getSecond().get());    }    return indexIDMap;}
060f525386b455f09eb7716b87f0bfd887b14ef3f89a63fe017c0477d7dcaaaf
setup
protected void setup(Context context)
{    Configuration jobConf = context.getConfiguration();    booleanData = jobConf.getBoolean(RecommenderJob.BOOLEAN_DATA, false);    transpose = jobConf.getBoolean(TRANSPOSE_USER_ITEM, false);    ratingShift = Float.parseFloat(jobConf.get(RATING_SHIFT, "0.0"));}
6052a40636191540c70243d95cc32851b5bbe24011a9d2a534dfcfdc078678a4
map
public void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException
{    String[] tokens = DELIMITER.split(value.toString());    long userID = Long.parseLong(tokens[0]);    long itemID = Long.parseLong(tokens[1]);    if (itemKey ^ transpose) {                                long temp = userID;        userID = itemID;        itemID = temp;    }    if (booleanData) {        context.write(new VarLongWritable(userID), new VarLongWritable(itemID));    } else {        float prefValue = tokens.length > 2 ? Float.parseFloat(tokens[2]) + ratingShift : 1.0f;        context.write(new VarLongWritable(userID), new EntityPrefWritable(itemID, prefValue));    }}
d4f20cf2c4728f9f0b8f89424e6041521084333cc2b228337fb5462884654798
getTopItems
public List<RecommendedItem> getTopItems()
{    List<RecommendedItem> recommendedItems = new ArrayList<>(maxSize);    while (size() > 0) {        MutableRecommendedItem topItem = pop();                if (topItem.getItemID() != SENTINEL_ID) {            recommendedItems.add(topItem);        }    }    Collections.reverse(recommendedItems);    return recommendedItems;}
2382d30c7eb306b6eaeba72f7d8c0a7eade238ba47a9f7661f168b89a77e7e62
lessThan
protected boolean lessThan(MutableRecommendedItem one, MutableRecommendedItem two)
{    return one.getValue() < two.getValue();}
af7ca9117cf3d58332e0dc7e5570bd40c07c7c7490b21c40690f4a06d8260e4e
getSentinelObject
protected MutableRecommendedItem getSentinelObject()
{    return new MutableRecommendedItem(SENTINEL_ID, Float.MIN_VALUE);}
86b258348f7f977965531ca2f7823b05d4055e96aa566bc903e3e36ab6142929
next
public Long next()
{    return nextLong();}
61fd9cb64df25845c4356c1c958d2a01ba6cea074a6b4a8ebb21a8059ba98f7b
get
 boolean get(int index)
{        return (bits[index >>> 6] & 1L << (index & 0x3F)) != 0L;}
6c98f9118bd928e443e92734f1cf30b46342245f0b3452eeb7bf6a2e57077299
set
 void set(int index)
{        bits[index >>> 6] |= 1L << (index & 0x3F);}
1e4051253943e5b28f2db45853e5fd06800110302a7772f702abd8189bf51303
clear
 void clear(int index)
{        bits[index >>> 6] &= ~(1L << (index & 0x3F));}
b2b9085b0cb0cbfb4ce6894d838a4146f65710cfe59a65d3d886128d75a50a11
clear
 void clear()
{    int length = bits.length;    for (int i = 0; i < length; i++) {        bits[i] = 0L;    }}
663458e6335f1a9b0639ad218f6d1a55ae9633850def64a4b8c658b9e4fd5345
clone
public BitSet clone()
{    return new BitSet(bits.clone());}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return Arrays.hashCode(bits);}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (!(o instanceof BitSet)) {        return false;    }    BitSet other = (BitSet) o;    return Arrays.equals(bits, other.bits);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    StringBuilder result = new StringBuilder(64 * bits.length);    for (long l : bits) {        for (int j = 0; j < 64; j++) {            result.append((l & 1L << j) == 0 ? '0' : '1');        }        result.append(' ');    }    return result.toString();}
8a3197106409ef9e3146274b3b6986a8aa7169475f50b58a5e88497c5a2b9a62
get
public V get(K key) throws TasteException
{    V value;    synchronized (cache) {        value = cache.get(key);    }    if (value == null) {        return getAndCacheValue(key);    }    return value == NULL ? null : value;}
e97b4381e57d51e1da5304e0fdbb1cfaf0d533cc14bbbc9f10287f4b3618d99c
remove
public void remove(K key)
{    synchronized (cache) {        cache.remove(key);    }}
a5f6a004e484c2c4ad7e8f467c525a4e96c46fb0c29b6021319f387ef295af73
removeKeysMatching
public void removeKeysMatching(MatchPredicate<K> predicate)
{    synchronized (cache) {        Iterator<K> it = cache.keySet().iterator();        while (it.hasNext()) {            K key = it.next();            if (predicate.matches(key)) {                it.remove();            }        }    }}
4a5e7e510cc569b41c5ef6ba7f8fad0a68d1f5b372fc992d77e1fe8694b62846
removeValueMatching
public void removeValueMatching(MatchPredicate<V> predicate)
{    synchronized (cache) {        Iterator<V> it = cache.values().iterator();        while (it.hasNext()) {            V value = it.next();            if (predicate.matches(value)) {                it.remove();            }        }    }}
21ac40bb9a99614b6ac18fa4043acb6173fccff96066fdfab963dba597923aa8
clear
public void clear()
{    synchronized (cache) {        cache.clear();    }}
3d491b0bc70c0bd480b915f3b540e4a65f7c5db7649af45cc6f9e592d5536f5e
getAndCacheValue
private V getAndCacheValue(K key) throws TasteException
{    V value = retriever.get(key);    if (value == null) {        value = (V) NULL;    }    synchronized (cache) {        cache.put(key, value);    }    return value;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "Cache[retriever:" + retriever + ']';}
9219a76b29a2587dca1168fa4964a5316c8d40d91ab1144e6c6e9fa885c7e565
find
private int find(long key)
{        int theHashCode = (int) key & 0x7FFFFFFF;    long[] keys = this.keys;    int hashSize = keys.length;    int jump = 1 + theHashCode % (hashSize - 2);    int index = theHashCode % hashSize;    long currentKey = keys[index];    while (currentKey != NULL && key != currentKey) {        index -= index < jump ? jump - hashSize : jump;        currentKey = keys[index];    }    return index;}
4123711c7afc65ad00f18959568da8b939d2688ec09b6839326eecf8afb0f266
findForAdd
private int findForAdd(long key)
{        int theHashCode = (int) key & 0x7FFFFFFF;    long[] keys = this.keys;    int hashSize = keys.length;    int jump = 1 + theHashCode % (hashSize - 2);    int index = theHashCode % hashSize;    long currentKey = keys[index];    while (currentKey != NULL && currentKey != REMOVED && key != currentKey) {        index -= index < jump ? jump - hashSize : jump;        currentKey = keys[index];    }    if (currentKey != REMOVED) {        return index;    }        int addIndex = index;    while (currentKey != NULL && key != currentKey) {        index -= index < jump ? jump - hashSize : jump;        currentKey = keys[index];    }    return key == currentKey ? index : addIndex;}
cff5deeb52429081198427235ff12fa86c85269ed8b1b36aee28cb6fbb9af8b3
get
public V get(long key)
{    if (key == NULL) {        return null;    }    int index = find(key);    if (countingAccesses) {        recentlyAccessed.set(index);    }    return values[index];}
72ef1e59027007ffe0950edfd2670ad03bb65cd6463d5d1d282dfeb1750435b0
size
public int size()
{    return numEntries;}
803915e853382ad445a6e2333fabb8beb8e4acd70e908a0d818400f7baac42af
isEmpty
public boolean isEmpty()
{    return numEntries == 0;}
7fca342fad70ebe6ad43032f2405e6be632ea3dc1e62a7c520ad55cef62bb9cf
containsKey
public boolean containsKey(long key)
{    return key != NULL && key != REMOVED && keys[find(key)] != NULL;}
c628f36c081e450f86a9e82a881e3e7747dea6b3d315f9d7efd8f5266497cb73
containsValue
public boolean containsValue(Object value)
{    if (value == null) {        return false;    }    for (V theValue : values) {        if (theValue != null && value.equals(theValue)) {            return true;        }    }    return false;}
abe88ecd1f8a506b08730986e329869779b7ff0cbd9229f898f1dc908c018f67
put
public V put(long key, V value)
{    Preconditions.checkArgument(key != NULL && key != REMOVED);    Preconditions.checkNotNull(value);        if (numSlotsUsed * loadFactor >= keys.length) {                if (numEntries * loadFactor >= numSlotsUsed) {            growAndRehash();        } else {                        rehash();        }    }        int index = findForAdd(key);    long keyIndex = keys[index];    if (keyIndex == key) {        V oldValue = values[index];        values[index] = value;        return oldValue;    }        if (countingAccesses && numEntries >= maxSize) {                clearStaleEntry(index);    }    keys[index] = key;    values[index] = value;    numEntries++;    if (keyIndex == NULL) {        numSlotsUsed++;    }    return null;}
de968f4fa8db69660ea2e44b776fee5154537f39b08fa9cad7493861435873a1
clearStaleEntry
private void clearStaleEntry(int index)
{    while (true) {        long currentKey;        do {            if (index == 0) {                index = keys.length - 1;            } else {                index--;            }            currentKey = keys[index];        } while (currentKey == NULL || currentKey == REMOVED);        if (recentlyAccessed.get(index)) {            recentlyAccessed.clear(index);        } else {            break;        }    }        keys[index] = REMOVED;    numEntries--;    values[index] = null;}
8a38678b1a1b48c66b3c2cb27c54c2e476efd2bbfeb1125ac91393e9c99a1d39
remove
public V remove(long key)
{    if (key == NULL || key == REMOVED) {        return null;    }    int index = find(key);    if (keys[index] == NULL) {        return null;    } else {        keys[index] = REMOVED;        numEntries--;        V oldValue = values[index];        values[index] = null;                return oldValue;    }}
21ac40bb9a99614b6ac18fa4043acb6173fccff96066fdfab963dba597923aa8
clear
public void clear()
{    numEntries = 0;    numSlotsUsed = 0;    Arrays.fill(keys, NULL);    Arrays.fill(values, null);    if (countingAccesses) {        recentlyAccessed.clear();    }}
3156d498f5a4781c2ae57ece21a40bc3285f6d0ad0439a99776e320d466c6e82
keySetIterator
public LongPrimitiveIterator keySetIterator()
{    return new KeyIterator();}
a24a8424b935faab4a959c7564a6a22a49fc6739fbc44656c6f0a580cf88d15e
entrySet
public Set<Map.Entry<Long, V>> entrySet()
{    return new EntrySet();}
86f8cd7f78364ea8a0d36935cf2e3d294cee8b3b9e21cfe6a555d22e54e37f60
values
public Collection<V> values()
{    return new ValueCollection();}
57e804681dffd49553e6f3f000cd2e0baff6247fe3a75bf4bf32d8a004b59230
rehash
public void rehash()
{    rehash(RandomUtils.nextTwinPrime((int) (loadFactor * numEntries)));}
b64f5d3f5419bfc86b4b90841233403428bd7ef56db5209c65efcdc14359fd06
growAndRehash
private void growAndRehash()
{    if (keys.length * loadFactor >= RandomUtils.MAX_INT_SMALLER_TWIN_PRIME) {        throw new IllegalStateException("Can't grow any more");    }    rehash(RandomUtils.nextTwinPrime((int) (loadFactor * keys.length)));}
2ee8a1ce53d5efee3f9daac9018ce1771e8ed4a038a0e175970ed5b7f1c6bf05
rehash
private void rehash(int newHashSize)
{    long[] oldKeys = keys;    V[] oldValues = values;    numEntries = 0;    numSlotsUsed = 0;    if (countingAccesses) {        recentlyAccessed = new BitSet(newHashSize);    }    keys = new long[newHashSize];    Arrays.fill(keys, NULL);    values = (V[]) new Object[newHashSize];    int length = oldKeys.length;    for (int i = 0; i < length; i++) {        long key = oldKeys[i];        if (key != NULL && key != REMOVED) {            put(key, oldValues[i]);        }    }}
b00b6f53e2584aec67bf6e0f5e7794418849464d46b4487ccd7dd9c9adb6f706
iteratorRemove
 void iteratorRemove(int lastNext)
{    if (lastNext >= values.length) {        throw new NoSuchElementException();    }    if (lastNext < 0) {        throw new IllegalStateException();    }    values[lastNext] = null;    keys[lastNext] = REMOVED;    numEntries--;}
a90bd084bdc60dfada772cfaa7a6c79f06ab643924565d899da07b94e3895e3a
clone
public FastByIDMap<V> clone()
{    FastByIDMap<V> clone;    try {        clone = (FastByIDMap<V>) super.clone();    } catch (CloneNotSupportedException cnse) {        throw new AssertionError();    }    clone.keys = keys.clone();    clone.values = values.clone();    clone.recentlyAccessed = countingAccesses ? new BitSet(keys.length) : null;    return clone;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    if (isEmpty()) {        return "{}";    }    StringBuilder result = new StringBuilder();    result.append('{');    for (int i = 0; i < keys.length; i++) {        long key = keys[i];        if (key != NULL && key != REMOVED) {            result.append(key).append('=').append(values[i]).append(',');        }    }    result.setCharAt(result.length() - 1, '}');    return result.toString();}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    int hash = 0;    long[] keys = this.keys;    int max = keys.length;    for (int i = 0; i < max; i++) {        long key = keys[i];        if (key != NULL && key != REMOVED) {            hash = 31 * hash + ((int) (key >> 32) ^ (int) key);            hash = 31 * hash + values[i].hashCode();        }    }    return hash;}
74e378df448c6c3cd090d6daf881cfac8957dd555869ea4c13a46bdc6cdcf9a6
equals
public boolean equals(Object other)
{    if (!(other instanceof FastByIDMap)) {        return false;    }    FastByIDMap<V> otherMap = (FastByIDMap<V>) other;    long[] otherKeys = otherMap.keys;    V[] otherValues = otherMap.values;    int length = keys.length;    int otherLength = otherKeys.length;    int max = Math.min(length, otherLength);    int i = 0;    while (i < max) {        long key = keys[i];        long otherKey = otherKeys[i];        if (key == NULL || key == REMOVED) {            if (otherKey != NULL && otherKey != REMOVED) {                return false;            }        } else {            if (key != otherKey || !values[i].equals(otherValues[i])) {                return false;            }        }        i++;    }    while (i < length) {        long key = keys[i];        if (key != NULL && key != REMOVED) {            return false;        }        i++;    }    while (i < otherLength) {        long key = otherKeys[i];        if (key != NULL && key != REMOVED) {            return false;        }        i++;    }    return true;}
d51e5f7450eca0a0f63da1a466189e262d053b84aa767ba3be5cea740af7251b
hasNext
public boolean hasNext()
{    goToNext();    return position < keys.length;}
c07ff43a11a0fd30355c754b084700be1eadeb6e7293cc052804e1ca4dba70c9
nextLong
public long nextLong()
{    goToNext();    lastNext = position;    if (position >= keys.length) {        throw new NoSuchElementException();    }    return keys[position++];}
cfc67e5714c799daa4f0cae0084231f7d3115d517eae691edd227e7f59489e21
peek
public long peek()
{    goToNext();    if (position >= keys.length) {        throw new NoSuchElementException();    }    return keys[position];}
0258e71d1745035026972d5993ab5683ea036797a6579f0cd4abb63c7675127f
goToNext
private void goToNext()
{    int length = values.length;    while (position < length && values[position] == null) {        position++;    }}
eb35e4acc0ab2c89fd30970f01fba35488b3a4581b2af1986091209043508a3e
remove
public void remove()
{    iteratorRemove(lastNext);}
83659b3f3c32cda5d1e381b9ad4b7db55d1ee8ecce3504ad3c9ad45a376b6f2e
skip
public void skip(int n)
{    position += n;}
72ef1e59027007ffe0950edfd2670ad03bb65cd6463d5d1d282dfeb1750435b0
size
public int size()
{    return FastByIDMap.this.size();}
803915e853382ad445a6e2333fabb8beb8e4acd70e908a0d818400f7baac42af
isEmpty
public boolean isEmpty()
{    return FastByIDMap.this.isEmpty();}
4da0ec02fabfc9d8d6db55f6b5aa73f917fe3ba7bce50e808cca9ac75625aec8
contains
public boolean contains(Object o)
{    return containsKey((Long) o);}
dc22283ae742470dc7e5864abd735fd9b7f57a4bcbc88b08bcb320a464b040f7
iterator
public Iterator<Map.Entry<Long, V>> iterator()
{    return new EntryIterator();}
aec49d48b85fb9793da41d6ac4d5c167d1e869119755b9b7a8628f76268914a4
add
public boolean add(Map.Entry<Long, V> t)
{    throw new UnsupportedOperationException();}
419b436ee630c006c73c2ce3e35dc2241b7dd30a231c66d85f12ec2d22e1463b
remove
public boolean remove(Object o)
{    throw new UnsupportedOperationException();}
1cc885dee06c392dbed80cfb2b4d69a44a14a2e2060c481a4bda6ef84e8acecb
addAll
public boolean addAll(Collection<? extends Map.Entry<Long, V>> ts)
{    throw new UnsupportedOperationException();}
e0fe985fbe9db4b6dccf6223814eb1abca73aa5d2ebe7df5ee2b557d5cb567f3
retainAll
public boolean retainAll(Collection<?> objects)
{    throw new UnsupportedOperationException();}
51b249546b6549fba39b988042e062bc34bae55ab2525f038f19d6bb98299c13
removeAll
public boolean removeAll(Collection<?> objects)
{    throw new UnsupportedOperationException();}
21ac40bb9a99614b6ac18fa4043acb6173fccff96066fdfab963dba597923aa8
clear
public void clear()
{    FastByIDMap.this.clear();}
3031951334517bac728a530f7f0ab26ddd6278d3255a5cb5f65a27b3311d5e74
getKey
public Long getKey()
{    return keys[index];}
5a159708665ed864d795a0702d525a75a1e0d877881ccd093ed97ed18e382934
getValue
public V getValue()
{    return values[index];}
d8401f424036b4f728f70be90e19de421f30843cb3cd58fa6f7257c274ce398d
setValue
public V setValue(V value)
{    Preconditions.checkArgument(value != null);    V oldValue = values[index];    values[index] = value;    return oldValue;}
d51e5f7450eca0a0f63da1a466189e262d053b84aa767ba3be5cea740af7251b
hasNext
public boolean hasNext()
{    goToNext();    return position < keys.length;}
5e677a1d0feed55e6fc1d9300c7568d89f5f474e1452da60e60eec19c8192a27
next
public Map.Entry<Long, V> next()
{    goToNext();    lastNext = position;    if (position >= keys.length) {        throw new NoSuchElementException();    }    return new MapEntry(position++);}
0258e71d1745035026972d5993ab5683ea036797a6579f0cd4abb63c7675127f
goToNext
private void goToNext()
{    int length = values.length;    while (position < length && values[position] == null) {        position++;    }}
eb35e4acc0ab2c89fd30970f01fba35488b3a4581b2af1986091209043508a3e
remove
public void remove()
{    iteratorRemove(lastNext);}
72ef1e59027007ffe0950edfd2670ad03bb65cd6463d5d1d282dfeb1750435b0
size
public int size()
{    return FastByIDMap.this.size();}
803915e853382ad445a6e2333fabb8beb8e4acd70e908a0d818400f7baac42af
isEmpty
public boolean isEmpty()
{    return FastByIDMap.this.isEmpty();}
4da0ec02fabfc9d8d6db55f6b5aa73f917fe3ba7bce50e808cca9ac75625aec8
contains
public boolean contains(Object o)
{    return containsValue(o);}
d40381ab6f038666ae133df9f475ec0ae3c2f19a5af68da0ebdc4aa1776ccba6
iterator
public Iterator<V> iterator()
{    return new ValueIterator();}
008b3805f1d926449c29b11f2c7419e055c65b27b44bfbd9b621544b31ab856c
add
public boolean add(V v)
{    throw new UnsupportedOperationException();}
419b436ee630c006c73c2ce3e35dc2241b7dd30a231c66d85f12ec2d22e1463b
remove
public boolean remove(Object o)
{    throw new UnsupportedOperationException();}
5c36f182e8a4916bf50bd7a013290539e2ca188564e42e70ab66c9ab95846b62
addAll
public boolean addAll(Collection<? extends V> vs)
{    throw new UnsupportedOperationException();}
51b249546b6549fba39b988042e062bc34bae55ab2525f038f19d6bb98299c13
removeAll
public boolean removeAll(Collection<?> objects)
{    throw new UnsupportedOperationException();}
e0fe985fbe9db4b6dccf6223814eb1abca73aa5d2ebe7df5ee2b557d5cb567f3
retainAll
public boolean retainAll(Collection<?> objects)
{    throw new UnsupportedOperationException();}
21ac40bb9a99614b6ac18fa4043acb6173fccff96066fdfab963dba597923aa8
clear
public void clear()
{    FastByIDMap.this.clear();}
d51e5f7450eca0a0f63da1a466189e262d053b84aa767ba3be5cea740af7251b
hasNext
public boolean hasNext()
{    goToNext();    return position < values.length;}
7b0548984c463aeccab5907670bd1d5e009140134aeeee67c4d5885e5a9e69b6
next
public V next()
{    goToNext();    lastNext = position;    if (position >= values.length) {        throw new NoSuchElementException();    }    return values[position++];}
0258e71d1745035026972d5993ab5683ea036797a6579f0cd4abb63c7675127f
goToNext
private void goToNext()
{    int length = values.length;    while (position < length && values[position] == null) {        position++;    }}
eb35e4acc0ab2c89fd30970f01fba35488b3a4581b2af1986091209043508a3e
remove
public void remove()
{    iteratorRemove(lastNext);}
9219a76b29a2587dca1168fa4964a5316c8d40d91ab1144e6c6e9fa885c7e565
find
private int find(long key)
{        int theHashCode = (int) key & 0x7FFFFFFF;    long[] keys = this.keys;    int hashSize = keys.length;    int jump = 1 + theHashCode % (hashSize - 2);    int index = theHashCode % hashSize;    long currentKey = keys[index];    while (currentKey != NULL && key != currentKey) {                index -= index < jump ? jump - hashSize : jump;        currentKey = keys[index];    }    return index;}
4123711c7afc65ad00f18959568da8b939d2688ec09b6839326eecf8afb0f266
findForAdd
private int findForAdd(long key)
{        int theHashCode = (int) key & 0x7FFFFFFF;    long[] keys = this.keys;    int hashSize = keys.length;    int jump = 1 + theHashCode % (hashSize - 2);    int index = theHashCode % hashSize;    long currentKey = keys[index];    while (currentKey != NULL && currentKey != REMOVED && key != currentKey) {        index -= index < jump ? jump - hashSize : jump;        currentKey = keys[index];    }    if (currentKey != REMOVED) {        return index;    }        int addIndex = index;    while (currentKey != NULL && key != currentKey) {        index -= index < jump ? jump - hashSize : jump;        currentKey = keys[index];    }    return key == currentKey ? index : addIndex;}
72ef1e59027007ffe0950edfd2670ad03bb65cd6463d5d1d282dfeb1750435b0
size
public int size()
{    return numEntries;}
803915e853382ad445a6e2333fabb8beb8e4acd70e908a0d818400f7baac42af
isEmpty
public boolean isEmpty()
{    return numEntries == 0;}
d501d6fee3d08b30e72707ee220ccb1ee10d3bd228015f7e1b166665b2635cdc
contains
public boolean contains(long key)
{    return key != NULL && key != REMOVED && keys[find(key)] != NULL;}
a4d96cb28a56098f264a7d728cbe3fb3c0228390511fe6814969feed2dc46f1e
add
public boolean add(long key)
{    Preconditions.checkArgument(key != NULL && key != REMOVED);        if (numSlotsUsed * loadFactor >= keys.length) {                if (numEntries * loadFactor >= numSlotsUsed) {            growAndRehash();        } else {                        rehash();        }    }        int index = findForAdd(key);    long keyIndex = keys[index];    if (keyIndex != key) {        keys[index] = key;        numEntries++;        if (keyIndex == NULL) {            numSlotsUsed++;        }        return true;    }    return false;}
310a780ee44dc1fc361fa9d19896f47e99d29cf8f0813b6e8139180ed7efd6e5
iterator
public LongPrimitiveIterator iterator()
{    return new KeyIterator();}
54152ab5ed467c75715e408d7ecaed657661757fe1dfb8bfaa287a074fde7281
toArray
public long[] toArray()
{    long[] result = new long[numEntries];    for (int i = 0, position = 0; i < result.length; i++) {        while (keys[position] == NULL || keys[position] == REMOVED) {            position++;        }        result[i] = keys[position++];    }    return result;}
819b10bac9d829baee798b9309666409630b29a35695c8ec3c6fd69945d7824d
remove
public boolean remove(long key)
{    if (key == NULL || key == REMOVED) {        return false;    }    int index = find(key);    if (keys[index] == NULL) {        return false;    } else {        keys[index] = REMOVED;        numEntries--;        return true;    }}
7be5eaabd7113ef16399dcaec84eb514182c7ca45a8eb38b22847b67ce773d25
addAll
public boolean addAll(long[] c)
{    boolean changed = false;    for (long k : c) {        if (add(k)) {            changed = true;        }    }    return changed;}
5b3ad80c214ffffc044d3cbf5af628cf3296ffe3caab63d2eff31658164dae1b
addAll
public boolean addAll(FastIDSet c)
{    boolean changed = false;    for (long k : c.keys) {        if (k != NULL && k != REMOVED && add(k)) {            changed = true;        }    }    return changed;}
a8d4bc411220d2386febac2b4dc07fadcc13409b2a4c48c329ea6efe557722e0
removeAll
public boolean removeAll(long[] c)
{    boolean changed = false;    for (long o : c) {        if (remove(o)) {            changed = true;        }    }    return changed;}
a890aeae62c396687702ec28dfe691ffd9707f1cfffaf5fb66807e9777178b49
removeAll
public boolean removeAll(FastIDSet c)
{    boolean changed = false;    for (long k : c.keys) {        if (k != NULL && k != REMOVED && remove(k)) {            changed = true;        }    }    return changed;}
c43b582428fbb11b3f9501e864ec985ebc1652870b56ed6c1a22b91f212d552e
retainAll
public boolean retainAll(FastIDSet c)
{    boolean changed = false;    for (int i = 0; i < keys.length; i++) {        long k = keys[i];        if (k != NULL && k != REMOVED && !c.contains(k)) {            keys[i] = REMOVED;            numEntries--;            changed = true;        }    }    return changed;}
21ac40bb9a99614b6ac18fa4043acb6173fccff96066fdfab963dba597923aa8
clear
public void clear()
{    numEntries = 0;    numSlotsUsed = 0;    Arrays.fill(keys, NULL);}
b64f5d3f5419bfc86b4b90841233403428bd7ef56db5209c65efcdc14359fd06
growAndRehash
private void growAndRehash()
{    if (keys.length * loadFactor >= RandomUtils.MAX_INT_SMALLER_TWIN_PRIME) {        throw new IllegalStateException("Can't grow any more");    }    rehash(RandomUtils.nextTwinPrime((int) (loadFactor * keys.length)));}
57e804681dffd49553e6f3f000cd2e0baff6247fe3a75bf4bf32d8a004b59230
rehash
public void rehash()
{    rehash(RandomUtils.nextTwinPrime((int) (loadFactor * numEntries)));}
2ee8a1ce53d5efee3f9daac9018ce1771e8ed4a038a0e175970ed5b7f1c6bf05
rehash
private void rehash(int newHashSize)
{    long[] oldKeys = keys;    numEntries = 0;    numSlotsUsed = 0;    keys = new long[newHashSize];    Arrays.fill(keys, NULL);    for (long key : oldKeys) {        if (key != NULL && key != REMOVED) {            add(key);        }    }}
ff07330f5be1ef0f1ae9aa1db6764a1b28ea95b6bb05bd3a8977f0c6300c93ce
intersectionSize
public int intersectionSize(FastIDSet other)
{    int count = 0;    for (long key : other.keys) {        if (key != NULL && key != REMOVED && keys[find(key)] != NULL) {            count++;        }    }    return count;}
588dc5c1ab4505df2aa03989951b038ce27ada9aee4634cfb53364830805ee0f
clone
public FastIDSet clone()
{    FastIDSet clone;    try {        clone = (FastIDSet) super.clone();    } catch (CloneNotSupportedException cnse) {        throw new AssertionError();    }    clone.keys = keys.clone();    return clone;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    int hash = 0;    long[] keys = this.keys;    for (long key : keys) {        if (key != NULL && key != REMOVED) {            hash = 31 * hash + ((int) (key >> 32) ^ (int) key);        }    }    return hash;}
74e378df448c6c3cd090d6daf881cfac8957dd555869ea4c13a46bdc6cdcf9a6
equals
public boolean equals(Object other)
{    if (!(other instanceof FastIDSet)) {        return false;    }    FastIDSet otherMap = (FastIDSet) other;    long[] otherKeys = otherMap.keys;    int length = keys.length;    int otherLength = otherKeys.length;    int max = Math.min(length, otherLength);    int i = 0;    while (i < max) {        long key = keys[i];        long otherKey = otherKeys[i];        if (key == NULL || key == REMOVED) {            if (otherKey != NULL && otherKey != REMOVED) {                return false;            }        } else {            if (key != otherKey) {                return false;            }        }        i++;    }    while (i < length) {        long key = keys[i];        if (key != NULL && key != REMOVED) {            return false;        }        i++;    }    while (i < otherLength) {        long key = otherKeys[i];        if (key != NULL && key != REMOVED) {            return false;        }        i++;    }    return true;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    if (isEmpty()) {        return "[]";    }    StringBuilder result = new StringBuilder();    result.append('[');    for (long key : keys) {        if (key != NULL && key != REMOVED) {            result.append(key).append(',');        }    }    result.setCharAt(result.length() - 1, ']');    return result.toString();}
d51e5f7450eca0a0f63da1a466189e262d053b84aa767ba3be5cea740af7251b
hasNext
public boolean hasNext()
{    goToNext();    return position < keys.length;}
c07ff43a11a0fd30355c754b084700be1eadeb6e7293cc052804e1ca4dba70c9
nextLong
public long nextLong()
{    goToNext();    lastNext = position;    if (position >= keys.length) {        throw new NoSuchElementException();    }    return keys[position++];}
cfc67e5714c799daa4f0cae0084231f7d3115d517eae691edd227e7f59489e21
peek
public long peek()
{    goToNext();    if (position >= keys.length) {        throw new NoSuchElementException();    }    return keys[position];}
0258e71d1745035026972d5993ab5683ea036797a6579f0cd4abb63c7675127f
goToNext
private void goToNext()
{    int length = keys.length;    while (position < length && (keys[position] == NULL || keys[position] == REMOVED)) {        position++;    }}
eb35e4acc0ab2c89fd30970f01fba35488b3a4581b2af1986091209043508a3e
remove
public void remove()
{    if (lastNext >= keys.length) {        throw new NoSuchElementException();    }    if (lastNext < 0) {        throw new IllegalStateException();    }    keys[lastNext] = REMOVED;    numEntries--;}
81b77b77a0f27e419250e9e30280a7e1b3774592a5a3c9021d1d96d5380ef894
iterator
public Iterator<Long> iterator()
{    return new KeyIterator();}
83659b3f3c32cda5d1e381b9ad4b7db55d1ee8ecce3504ad3c9ad45a376b6f2e
skip
public void skip(int n)
{    position += n;}
81cdd99f51476c55f622f3f6bd73fc5a4c28c9b9ac719409f381f183a15c77ec
find
private int find(Object key)
{        int theHashCode = key.hashCode() & 0x7FFFFFFF;    K[] keys = this.keys;    int hashSize = keys.length;    int jump = 1 + theHashCode % (hashSize - 2);    int index = theHashCode % hashSize;    K currentKey = keys[index];    while (currentKey != null && !key.equals(currentKey)) {        index -= index < jump ? jump - hashSize : jump;        currentKey = keys[index];    }    return index;}
62a052c04a66e4bca6d28721e55112f9d20fe1470321ca926c0750d0b34fe08c
findForAdd
private int findForAdd(Object key)
{        int theHashCode = key.hashCode() & 0x7FFFFFFF;    K[] keys = this.keys;    int hashSize = keys.length;    int jump = 1 + theHashCode % (hashSize - 2);    int index = theHashCode % hashSize;    K currentKey = keys[index];    while (currentKey != null && currentKey != REMOVED && key != currentKey) {        index -= index < jump ? jump - hashSize : jump;        currentKey = keys[index];    }    if (currentKey != REMOVED) {        return index;    }        int addIndex = index;    while (currentKey != null && key != currentKey) {        index -= index < jump ? jump - hashSize : jump;        currentKey = keys[index];    }    return key == currentKey ? index : addIndex;}
bff87e54075ba5d5421bf5ff5db42cbe90d6f2d40bf112005070d80ee9873381
get
public V get(Object key)
{    if (key == null) {        return null;    }    int index = find(key);    if (countingAccesses) {        recentlyAccessed.set(index);    }    return values[index];}
72ef1e59027007ffe0950edfd2670ad03bb65cd6463d5d1d282dfeb1750435b0
size
public int size()
{    return numEntries;}
803915e853382ad445a6e2333fabb8beb8e4acd70e908a0d818400f7baac42af
isEmpty
public boolean isEmpty()
{    return numEntries == 0;}
10251f6cf636f49b599299432df558beac5bc221e8b028def33778ce8ebe248a
containsKey
public boolean containsKey(Object key)
{    return key != null && keys[find(key)] != null;}
c628f36c081e450f86a9e82a881e3e7747dea6b3d315f9d7efd8f5266497cb73
containsValue
public boolean containsValue(Object value)
{    if (value == null) {        return false;    }    for (V theValue : values) {        if (theValue != null && value.equals(theValue)) {            return true;        }    }    return false;}
1872e986b4afc45b25826345adf05e6c986d61445f72dd373c75c28af725bf99
put
public V put(K key, V value)
{    Preconditions.checkNotNull(key);    Preconditions.checkNotNull(value);        if (numSlotsUsed * loadFactor >= keys.length) {                if (numEntries * loadFactor >= numSlotsUsed) {            growAndRehash();        } else {                        rehash();        }    }        int index = findForAdd(key);    if (keys[index] == key) {        V oldValue = values[index];        values[index] = value;        return oldValue;    }        if (countingAccesses && numEntries >= maxSize) {                clearStaleEntry(index);    }    keys[index] = key;    values[index] = value;    numEntries++;    numSlotsUsed++;    return null;}
de968f4fa8db69660ea2e44b776fee5154537f39b08fa9cad7493861435873a1
clearStaleEntry
private void clearStaleEntry(int index)
{    while (true) {        K currentKey;        do {            if (index == 0) {                index = keys.length - 1;            } else {                index--;            }            currentKey = keys[index];        } while (currentKey == null || currentKey == REMOVED);        if (recentlyAccessed.get(index)) {            recentlyAccessed.clear(index);        } else {            break;        }    }        ((Object[]) keys)[index] = REMOVED;    numEntries--;    values[index] = null;}
98a4c2b222b78c4d9fcbc1efb27a0a2f9e3932c2b7fea41024dfdfac332d912d
putAll
public void putAll(Map<? extends K, ? extends V> map)
{    for (Entry<? extends K, ? extends V> entry : map.entrySet()) {        put(entry.getKey(), entry.getValue());    }}
d3d9cbefed45d3eba7ffb31735e6c0cc3079bba6649ecef7eae69b6429c3717d
remove
public V remove(Object key)
{    if (key == null) {        return null;    }    int index = find(key);    if (keys[index] == null) {        return null;    } else {        ((Object[]) keys)[index] = REMOVED;        numEntries--;        V oldValue = values[index];        values[index] = null;                return oldValue;    }}
21ac40bb9a99614b6ac18fa4043acb6173fccff96066fdfab963dba597923aa8
clear
public void clear()
{    numEntries = 0;    numSlotsUsed = 0;    Arrays.fill(keys, null);    Arrays.fill(values, null);    if (countingAccesses) {        recentlyAccessed.clear();    }}
c619c5c247e00c82e132c731db2d7dd646000c405d071795fcbfcba581649b68
keySet
public Set<K> keySet()
{    return new KeySet();}
86f8cd7f78364ea8a0d36935cf2e3d294cee8b3b9e21cfe6a555d22e54e37f60
values
public Collection<V> values()
{    return new ValueCollection();}
9c94328d9a4d378818b4c875593b394a3c6d5d7df6fc4f23395a546861a4c1a3
entrySet
public Set<Entry<K, V>> entrySet()
{    return new EntrySet();}
57e804681dffd49553e6f3f000cd2e0baff6247fe3a75bf4bf32d8a004b59230
rehash
public void rehash()
{    rehash(RandomUtils.nextTwinPrime((int) (loadFactor * numEntries)));}
b64f5d3f5419bfc86b4b90841233403428bd7ef56db5209c65efcdc14359fd06
growAndRehash
private void growAndRehash()
{    if (keys.length * loadFactor >= RandomUtils.MAX_INT_SMALLER_TWIN_PRIME) {        throw new IllegalStateException("Can't grow any more");    }    rehash(RandomUtils.nextTwinPrime((int) (loadFactor * keys.length)));}
2ee8a1ce53d5efee3f9daac9018ce1771e8ed4a038a0e175970ed5b7f1c6bf05
rehash
private void rehash(int newHashSize)
{    K[] oldKeys = keys;    V[] oldValues = values;    numEntries = 0;    numSlotsUsed = 0;    if (countingAccesses) {        recentlyAccessed = new BitSet(newHashSize);    }    keys = (K[]) new Object[newHashSize];    values = (V[]) new Object[newHashSize];    int length = oldKeys.length;    for (int i = 0; i < length; i++) {        K key = oldKeys[i];        if (key != null && key != REMOVED) {            put(key, oldValues[i]);        }    }}
b00b6f53e2584aec67bf6e0f5e7794418849464d46b4487ccd7dd9c9adb6f706
iteratorRemove
 void iteratorRemove(int lastNext)
{    if (lastNext >= values.length) {        throw new NoSuchElementException();    }    if (lastNext < 0) {        throw new IllegalStateException();    }    values[lastNext] = null;    ((Object[]) keys)[lastNext] = REMOVED;    numEntries--;}
c8addd0303fbb5cc6e139424d314accce78f94ccaa7b18feef93816de96e95c5
clone
public FastMap<K, V> clone()
{    FastMap<K, V> clone;    try {        clone = (FastMap<K, V>) super.clone();    } catch (CloneNotSupportedException cnse) {        throw new AssertionError();    }    clone.keys = keys.clone();    clone.values = values.clone();    clone.recentlyAccessed = countingAccesses ? new BitSet(keys.length) : null;    return clone;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    int hash = 0;    K[] keys = this.keys;    int max = keys.length;    for (int i = 0; i < max; i++) {        K key = keys[i];        if (key != null && key != REMOVED) {            hash = 31 * hash + key.hashCode();            hash = 31 * hash + values[i].hashCode();        }    }    return hash;}
74e378df448c6c3cd090d6daf881cfac8957dd555869ea4c13a46bdc6cdcf9a6
equals
public boolean equals(Object other)
{    if (!(other instanceof FastMap)) {        return false;    }    FastMap<K, V> otherMap = (FastMap<K, V>) other;    K[] otherKeys = otherMap.keys;    V[] otherValues = otherMap.values;    int length = keys.length;    int otherLength = otherKeys.length;    int max = Math.min(length, otherLength);    int i = 0;    while (i < max) {        K key = keys[i];        K otherKey = otherKeys[i];        if (key == null || key == REMOVED) {            if (otherKey != null && otherKey != REMOVED) {                return false;            }        } else {            if (key != otherKey || !values[i].equals(otherValues[i])) {                return false;            }        }        i++;    }    while (i < length) {        K key = keys[i];        if (key != null && key != REMOVED) {            return false;        }        i++;    }    while (i < otherLength) {        K key = otherKeys[i];        if (key != null && key != REMOVED) {            return false;        }        i++;    }    return true;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    if (isEmpty()) {        return "{}";    }    StringBuilder result = new StringBuilder();    result.append('{');    for (int i = 0; i < keys.length; i++) {        K key = keys[i];        if (key != null && key != REMOVED) {            result.append(key).append('=').append(values[i]).append(',');        }    }    result.setCharAt(result.length() - 1, '}');    return result.toString();}
72ef1e59027007ffe0950edfd2670ad03bb65cd6463d5d1d282dfeb1750435b0
size
public int size()
{    return FastMap.this.size();}
803915e853382ad445a6e2333fabb8beb8e4acd70e908a0d818400f7baac42af
isEmpty
public boolean isEmpty()
{    return FastMap.this.isEmpty();}
4da0ec02fabfc9d8d6db55f6b5aa73f917fe3ba7bce50e808cca9ac75625aec8
contains
public boolean contains(Object o)
{    return containsKey(o);}
612b267905c5fbf33f5a040a02a8f076075fd6d463067fe1610045100d14ca48
iterator
public Iterator<Entry<K, V>> iterator()
{    return new EntryIterator();}
86029d531c35befd45de206b01ce1337146ecce2afa7e281824bf03aba4f5063
add
public boolean add(Entry<K, V> t)
{    throw new UnsupportedOperationException();}
419b436ee630c006c73c2ce3e35dc2241b7dd30a231c66d85f12ec2d22e1463b
remove
public boolean remove(Object o)
{    throw new UnsupportedOperationException();}
e2d42ef1020c5bf46a77f8bb8b0a89b4e4a475354784bdbaa81659d7047ca4a3
addAll
public boolean addAll(Collection<? extends Entry<K, V>> ts)
{    throw new UnsupportedOperationException();}
e0fe985fbe9db4b6dccf6223814eb1abca73aa5d2ebe7df5ee2b557d5cb567f3
retainAll
public boolean retainAll(Collection<?> objects)
{    throw new UnsupportedOperationException();}
51b249546b6549fba39b988042e062bc34bae55ab2525f038f19d6bb98299c13
removeAll
public boolean removeAll(Collection<?> objects)
{    throw new UnsupportedOperationException();}
21ac40bb9a99614b6ac18fa4043acb6173fccff96066fdfab963dba597923aa8
clear
public void clear()
{    FastMap.this.clear();}
408af2012690314114a03f0ca626970e41121b2f610127a0eacfc4e43e74dbfe
getKey
public K getKey()
{    return keys[index];}
5a159708665ed864d795a0702d525a75a1e0d877881ccd093ed97ed18e382934
getValue
public V getValue()
{    return values[index];}
d8401f424036b4f728f70be90e19de421f30843cb3cd58fa6f7257c274ce398d
setValue
public V setValue(V value)
{    Preconditions.checkArgument(value != null);    V oldValue = values[index];    values[index] = value;    return oldValue;}
d51e5f7450eca0a0f63da1a466189e262d053b84aa767ba3be5cea740af7251b
hasNext
public boolean hasNext()
{    goToNext();    return position < keys.length;}
94bfe3d8f1a3187ca0cbaba5bbfaf5cd2560518d803055dc183c8b7479f6c26b
next
public Entry<K, V> next()
{    goToNext();    lastNext = position;    if (position >= keys.length) {        throw new NoSuchElementException();    }    return new MapEntry(position++);}
0258e71d1745035026972d5993ab5683ea036797a6579f0cd4abb63c7675127f
goToNext
private void goToNext()
{    int length = values.length;    while (position < length && values[position] == null) {        position++;    }}
eb35e4acc0ab2c89fd30970f01fba35488b3a4581b2af1986091209043508a3e
remove
public void remove()
{    iteratorRemove(lastNext);}
72ef1e59027007ffe0950edfd2670ad03bb65cd6463d5d1d282dfeb1750435b0
size
public int size()
{    return FastMap.this.size();}
803915e853382ad445a6e2333fabb8beb8e4acd70e908a0d818400f7baac42af
isEmpty
public boolean isEmpty()
{    return FastMap.this.isEmpty();}
4da0ec02fabfc9d8d6db55f6b5aa73f917fe3ba7bce50e808cca9ac75625aec8
contains
public boolean contains(Object o)
{    return containsKey(o);}
8e1a4db9f90c6ab957ba32ce400b1d096c9f142623c6b9f0bad4b8e4faa2a1e5
iterator
public Iterator<K> iterator()
{    return new KeyIterator();}
7989cc1d1b9e1a6ffb03e8dacab5634a5032b4981590f12c6f816bd0407597be
add
public boolean add(K t)
{    throw new UnsupportedOperationException();}
419b436ee630c006c73c2ce3e35dc2241b7dd30a231c66d85f12ec2d22e1463b
remove
public boolean remove(Object o)
{    throw new UnsupportedOperationException();}
fa6b2abbfd738e864a4c6cb853010cd35efe4211dec2ada42d7f6d07602f9075
addAll
public boolean addAll(Collection<? extends K> ts)
{    throw new UnsupportedOperationException();}
e0fe985fbe9db4b6dccf6223814eb1abca73aa5d2ebe7df5ee2b557d5cb567f3
retainAll
public boolean retainAll(Collection<?> objects)
{    throw new UnsupportedOperationException();}
51b249546b6549fba39b988042e062bc34bae55ab2525f038f19d6bb98299c13
removeAll
public boolean removeAll(Collection<?> objects)
{    throw new UnsupportedOperationException();}
21ac40bb9a99614b6ac18fa4043acb6173fccff96066fdfab963dba597923aa8
clear
public void clear()
{    FastMap.this.clear();}
d51e5f7450eca0a0f63da1a466189e262d053b84aa767ba3be5cea740af7251b
hasNext
public boolean hasNext()
{    goToNext();    return position < keys.length;}
d851fa19c266c4c86ac8ccf2c32cbae5aa02538457cb96fb54bc2159f13ecbf9
next
public K next()
{    goToNext();    lastNext = position;    if (position >= keys.length) {        throw new NoSuchElementException();    }    return keys[position++];}
0258e71d1745035026972d5993ab5683ea036797a6579f0cd4abb63c7675127f
goToNext
private void goToNext()
{    int length = values.length;    while (position < length && values[position] == null) {        position++;    }}
eb35e4acc0ab2c89fd30970f01fba35488b3a4581b2af1986091209043508a3e
remove
public void remove()
{    iteratorRemove(lastNext);}
72ef1e59027007ffe0950edfd2670ad03bb65cd6463d5d1d282dfeb1750435b0
size
public int size()
{    return FastMap.this.size();}
803915e853382ad445a6e2333fabb8beb8e4acd70e908a0d818400f7baac42af
isEmpty
public boolean isEmpty()
{    return FastMap.this.isEmpty();}
4da0ec02fabfc9d8d6db55f6b5aa73f917fe3ba7bce50e808cca9ac75625aec8
contains
public boolean contains(Object o)
{    return containsValue(o);}
d40381ab6f038666ae133df9f475ec0ae3c2f19a5af68da0ebdc4aa1776ccba6
iterator
public Iterator<V> iterator()
{    return new ValueIterator();}
008b3805f1d926449c29b11f2c7419e055c65b27b44bfbd9b621544b31ab856c
add
public boolean add(V v)
{    throw new UnsupportedOperationException();}
419b436ee630c006c73c2ce3e35dc2241b7dd30a231c66d85f12ec2d22e1463b
remove
public boolean remove(Object o)
{    throw new UnsupportedOperationException();}
5c36f182e8a4916bf50bd7a013290539e2ca188564e42e70ab66c9ab95846b62
addAll
public boolean addAll(Collection<? extends V> vs)
{    throw new UnsupportedOperationException();}
51b249546b6549fba39b988042e062bc34bae55ab2525f038f19d6bb98299c13
removeAll
public boolean removeAll(Collection<?> objects)
{    throw new UnsupportedOperationException();}
e0fe985fbe9db4b6dccf6223814eb1abca73aa5d2ebe7df5ee2b557d5cb567f3
retainAll
public boolean retainAll(Collection<?> objects)
{    throw new UnsupportedOperationException();}
21ac40bb9a99614b6ac18fa4043acb6173fccff96066fdfab963dba597923aa8
clear
public void clear()
{    FastMap.this.clear();}
d51e5f7450eca0a0f63da1a466189e262d053b84aa767ba3be5cea740af7251b
hasNext
public boolean hasNext()
{    goToNext();    return position < values.length;}
7b0548984c463aeccab5907670bd1d5e009140134aeeee67c4d5885e5a9e69b6
next
public V next()
{    goToNext();    lastNext = position;    if (position >= values.length) {        throw new NoSuchElementException();    }    return values[position++];}
0258e71d1745035026972d5993ab5683ea036797a6579f0cd4abb63c7675127f
goToNext
private void goToNext()
{    int length = values.length;    while (position < length && values[position] == null) {        position++;    }}
eb35e4acc0ab2c89fd30970f01fba35488b3a4581b2af1986091209043508a3e
remove
public void remove()
{    iteratorRemove(lastNext);}
fc6c64c83026d54e84950a524e778394db86fbc18d119a61b3a676ece79461ea
addDatum
public synchronized void addDatum(double datum)
{    throw new UnsupportedOperationException();}
1d579aacb4eeee46ff020bc448b5acf955b64093d917b53b3ec08a4a3aa87f75
removeDatum
public synchronized void removeDatum(double datum)
{    throw new UnsupportedOperationException();}
e4072818afd5eeaf0b36b85463cf2a59a34211f3b55f04e3f347cfbd9ad0049d
changeDatum
public synchronized void changeDatum(double delta)
{    throw new UnsupportedOperationException();}
33a3bfe7f1d044bff872c5044b6d18cc46b0667805d0899043532c9a08c399da
getCount
public synchronized int getCount()
{    return count;}
e912da37ecb20c5a446350c7b6e8c0c4c0ba8402f4d3f24b34e6e80a7b494b9f
getAverage
public synchronized double getAverage()
{    return average;}
4077083716d43fae6c65d8a10c5de938090101d08f34eae21dbc91fecdba1805
inverse
public RunningAverage inverse()
{    return new InvertedRunningAverage(this);}
ced683865ec943e6fb0f59cfe94f9b041011464836da39fedb553752fdfb3495
toString
public synchronized String toString()
{    return String.valueOf(average);}
ffd87790f7cfad27f5c85d9024b808f6f21f9ce850b93b5dd3885f69ef50d802
inverse
public RunningAverageAndStdDev inverse()
{    return new InvertedRunningAverageAndStdDev(this);}
ced683865ec943e6fb0f59cfe94f9b041011464836da39fedb553752fdfb3495
toString
public synchronized String toString()
{    return super.toString() + ',' + stdDev;}
743c1595d1560eb10ef3bf27550cfd2afb079b14a43d27305eaf5d745fe634ce
getStandardDeviation
public double getStandardDeviation()
{    return stdDev;}
fc6c64c83026d54e84950a524e778394db86fbc18d119a61b3a676ece79461ea
addDatum
public synchronized void addDatum(double datum)
{    if (++count == 1) {        average = datum;    } else {        average = average * (count - 1) / count + datum / count;    }}
1d579aacb4eeee46ff020bc448b5acf955b64093d917b53b3ec08a4a3aa87f75
removeDatum
public synchronized void removeDatum(double datum)
{    if (count == 0) {        throw new IllegalStateException();    }    if (--count == 0) {        average = Double.NaN;    } else {        average = average * (count + 1) / count - datum / count;    }}
e4072818afd5eeaf0b36b85463cf2a59a34211f3b55f04e3f347cfbd9ad0049d
changeDatum
public synchronized void changeDatum(double delta)
{    if (count == 0) {        throw new IllegalStateException();    }    average += delta / count;}
33a3bfe7f1d044bff872c5044b6d18cc46b0667805d0899043532c9a08c399da
getCount
public synchronized int getCount()
{    return count;}
e912da37ecb20c5a446350c7b6e8c0c4c0ba8402f4d3f24b34e6e80a7b494b9f
getAverage
public synchronized double getAverage()
{    return average;}
4077083716d43fae6c65d8a10c5de938090101d08f34eae21dbc91fecdba1805
inverse
public RunningAverage inverse()
{    return new InvertedRunningAverage(this);}
ced683865ec943e6fb0f59cfe94f9b041011464836da39fedb553752fdfb3495
toString
public synchronized String toString()
{    return String.valueOf(average);}
ada4c2cef33e55904bda4f0b0988ef49748f8ab196a584d9ff4325d8f274b031
getMk
public double getMk()
{    return mk;}
ad34b648ab206e43f06fcc733975da8ffc2fbdbb1df8162f8523f846a4b4de13
getSk
public double getSk()
{    return sk;}
8fc8ebb584e31199b76dd32b5a12c9d0eeb6acc06c013260d0e327df42e5f5a4
getStandardDeviation
public synchronized double getStandardDeviation()
{    return stdDev;}
fc6c64c83026d54e84950a524e778394db86fbc18d119a61b3a676ece79461ea
addDatum
public synchronized void addDatum(double datum)
{    super.addDatum(datum);    int count = getCount();    if (count == 1) {        mk = datum;        sk = 0.0;    } else {        double oldmk = mk;        double diff = datum - oldmk;        mk += diff / count;        sk += diff * (datum - mk);    }    recomputeStdDev();}
1d579aacb4eeee46ff020bc448b5acf955b64093d917b53b3ec08a4a3aa87f75
removeDatum
public synchronized void removeDatum(double datum)
{    int oldCount = getCount();    super.removeDatum(datum);    double oldmk = mk;    mk = (oldCount * oldmk - datum) / (oldCount - 1);    sk -= (datum - mk) * (datum - oldmk);    recomputeStdDev();}
e2abb75bbde37d11f2672db66fa79492289a6e102b9a08fd0b3ebc0eb3b9c85d
changeDatum
public void changeDatum(double delta)
{    throw new UnsupportedOperationException();}
9b4c6be6d73cacc6ea31d8c210ab3b986487500cc6c4508eb322b3f7886922bb
recomputeStdDev
private synchronized void recomputeStdDev()
{    int count = getCount();    stdDev = count > 1 ? Math.sqrt(sk / (count - 1)) : Double.NaN;}
ffd87790f7cfad27f5c85d9024b808f6f21f9ce850b93b5dd3885f69ef50d802
inverse
public RunningAverageAndStdDev inverse()
{    return new InvertedRunningAverageAndStdDev(this);}
ced683865ec943e6fb0f59cfe94f9b041011464836da39fedb553752fdfb3495
toString
public synchronized String toString()
{    return String.valueOf(String.valueOf(getAverage()) + ',' + stdDev);}
1612b6e6275fd6743368805013c484856ebdb74272db96c4e5ea3d30edf5adda
addDatum
public void addDatum(double datum)
{    throw new UnsupportedOperationException();}
98e5f81ebf80d21f0c8e6aea8c8f353d6905bd2ac40e662f687a7ed0c9d6e6b5
removeDatum
public void removeDatum(double datum)
{    throw new UnsupportedOperationException();}
e2abb75bbde37d11f2672db66fa79492289a6e102b9a08fd0b3ebc0eb3b9c85d
changeDatum
public void changeDatum(double delta)
{    throw new UnsupportedOperationException();}
29fa59e92e8a9fa433fd7b38ebb21e8ece484149bc8e4a2726bba6f5dab39acf
getCount
public int getCount()
{    return delegate.getCount();}
ff8204e2e0c481f80c3d2f96530aad7bfd0c60d4466ede93db821d153ae8a77e
getAverage
public double getAverage()
{    return -delegate.getAverage();}
4077083716d43fae6c65d8a10c5de938090101d08f34eae21dbc91fecdba1805
inverse
public RunningAverage inverse()
{    return delegate;}
1612b6e6275fd6743368805013c484856ebdb74272db96c4e5ea3d30edf5adda
addDatum
public void addDatum(double datum)
{    throw new UnsupportedOperationException();}
98e5f81ebf80d21f0c8e6aea8c8f353d6905bd2ac40e662f687a7ed0c9d6e6b5
removeDatum
public void removeDatum(double datum)
{    throw new UnsupportedOperationException();}
e2abb75bbde37d11f2672db66fa79492289a6e102b9a08fd0b3ebc0eb3b9c85d
changeDatum
public void changeDatum(double delta)
{    throw new UnsupportedOperationException();}
29fa59e92e8a9fa433fd7b38ebb21e8ece484149bc8e4a2726bba6f5dab39acf
getCount
public int getCount()
{    return delegate.getCount();}
ff8204e2e0c481f80c3d2f96530aad7bfd0c60d4466ede93db821d153ae8a77e
getAverage
public double getAverage()
{    return -delegate.getAverage();}
743c1595d1560eb10ef3bf27550cfd2afb079b14a43d27305eaf5d745fe634ce
getStandardDeviation
public double getStandardDeviation()
{    return delegate.getStandardDeviation();}
ffd87790f7cfad27f5c85d9024b808f6f21f9ce850b93b5dd3885f69ef50d802
inverse
public RunningAverageAndStdDev inverse()
{    return delegate;}
d775396a08f8fecb3ed09e73bffa02c2856a1b5c3a6777c8f936da08b0284fc2
checkNotNullAndLog
protected static void checkNotNullAndLog(String argName, Object value)
{    Preconditions.checkArgument(value != null && !value.toString().isEmpty(), argName + " is null or empty");    log.debug("{}: {}", argName, value);}
273cbad6c2b01693a1cce5274f019c29b3c7b5e3373acbcc8cba27439ac76fcc
checkNotNullAndLog
protected static void checkNotNullAndLog(String argName, Object[] values)
{    Preconditions.checkArgument(values != null && values.length != 0, argName + " is null or zero-length");    for (Object value : values) {        checkNotNullAndLog(argName, value);    }}
4cc8af0f1db77a018f0c3306e61fb15d0c4f4a583ca1b881a3a96f5b6fedba1d
lookupDataSource
public static DataSource lookupDataSource(String dataSourceName) throws TasteException
{    Context context = null;    try {        context = new InitialContext();        return (DataSource) context.lookup("java:comp/env/" + dataSourceName);    } catch (NamingException ne) {        throw new TasteException(ne);    } finally {        if (context != null) {            try {                context.close();            } catch (NamingException ne) {                log.warn("Error while closing Context; continuing...", ne);            }        }    }}
be4c32955e91bd020d7aa1f82c019a829836bb1335885ff8146552479e3e6970
getFetchSize
protected int getFetchSize()
{    return DEFAULT_FETCH_SIZE;}
c4a327dfbe433229bc35f5526853381ad159284ec912c97c4e4a971d0b40e5ef
computeNext
protected ResultSet computeNext()
{    try {        if (resultSet.next()) {            return resultSet;        } else {            close();            return null;        }    } catch (SQLException sqle) {        close();        throw new IllegalStateException(sqle);    }}
bbedbcca2eca0c65a2bc370d49dd8b24c3e3ca9807552a4bc667406a3cccf222
skip
public void skip(int n) throws SQLException
{    try {        resultSet.relative(n);    } catch (SQLException sqle) {                int i = 0;        while (i < n && resultSet.next()) {            i++;        }    }}
5df6118bc0e745d8b18e0a6a99b2e3f2ddba8140cbeb1423ce2df50a9f140574
close
public void close()
{    IOUtils.quietClose(resultSet, statement, connection);    endOfData();}
2098f57e08a32859d08ac3c44fa8d2281d65bb9368f91bdd87d628cd22abdc64
apply
public T apply(ResultSet from)
{    try {        return parseElement(from);    } catch (SQLException sqle) {        throw new IllegalStateException(sqle);    }}
423fd4dee3cfe1ac7f5463036a794bf56e894523056fc6e6265d777aa7f88514
delegate
protected Iterator<T> delegate()
{    return delegate;}
83659b3f3c32cda5d1e381b9ad4b7db55d1ee8ecce3504ad3c9ad45a376b6f2e
skip
public void skip(int n)
{    if (n >= 1) {        try {            rowDelegate.skip(n);        } catch (SQLException sqle) {            throw new IllegalStateException(sqle);        }    }}
d51e5f7450eca0a0f63da1a466189e262d053b84aa767ba3be5cea740af7251b
hasNext
public boolean hasNext()
{    return position < max;}
86b258348f7f977965531ca2f7823b05d4055e96aa566bc903e3e36ab6142929
next
public Long next()
{    return nextLong();}
c07ff43a11a0fd30355c754b084700be1eadeb6e7293cc052804e1ca4dba70c9
nextLong
public long nextLong()
{    if (position >= array.length) {        throw new NoSuchElementException();    }    return array[position++];}
cfc67e5714c799daa4f0cae0084231f7d3115d517eae691edd227e7f59489e21
peek
public long peek()
{    if (position >= array.length) {        throw new NoSuchElementException();    }    return array[position];}
eb35e4acc0ab2c89fd30970f01fba35488b3a4581b2af1986091209043508a3e
remove
public void remove()
{    throw new UnsupportedOperationException();}
83659b3f3c32cda5d1e381b9ad4b7db55d1ee8ecce3504ad3c9ad45a376b6f2e
skip
public void skip(int n)
{    if (n > 0) {        position += n;    }}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "LongPrimitiveArrayIterator";}
7479793a8369ad147edf97c662e9ac5c302a92833610de522045be36dd563bcf
addDependency
public void addDependency(Refreshable refreshable)
{    if (refreshable != null) {        dependencies.add(refreshable);    }}
3d3c0b17cc80098e609b08218ca6eaf87e38cf05ecb00c2eb9d0b425da0bdd20
removeDependency
public void removeDependency(Refreshable refreshable)
{    if (refreshable != null) {        dependencies.remove(refreshable);    }}
da77e35d28c590f4b271e5b2b7f639c465574b8f17a1ef2f1df63e0152c57e8b
refresh
public void refresh(Collection<Refreshable> alreadyRefreshed)
{    if (refreshLock.tryLock()) {        try {            alreadyRefreshed = buildRefreshed(alreadyRefreshed);            for (Refreshable dependency : dependencies) {                maybeRefresh(alreadyRefreshed, dependency);            }            if (refreshRunnable != null) {                try {                    refreshRunnable.call();                } catch (Exception e) {                    log.warn("Unexpected exception while refreshing", e);                }            }        } finally {            refreshLock.unlock();        }    }}
78b3cb06b0afa3e316d7775045678a9ca2d99d66b0ac87de09178c8baa604909
buildRefreshed
public static Collection<Refreshable> buildRefreshed(Collection<Refreshable> currentAlreadyRefreshed)
{    return currentAlreadyRefreshed == null ? new HashSet<Refreshable>(3) : currentAlreadyRefreshed;}
c1a85dd25a6fb92f34236e94a3d61a3ba38a96c5ef9f353e5f5c193278477dc7
maybeRefresh
public static void maybeRefresh(Collection<Refreshable> alreadyRefreshed, Refreshable refreshable)
{    if (!alreadyRefreshed.contains(refreshable)) {        alreadyRefreshed.add(refreshable);        log.info("Added refreshable: {}", refreshable);        refreshable.refresh(alreadyRefreshed);        log.info("Refreshed: {}", alreadyRefreshed);    }}
d51e5f7450eca0a0f63da1a466189e262d053b84aa767ba3be5cea740af7251b
hasNext
public boolean hasNext()
{    return hasNext;}
c07ff43a11a0fd30355c754b084700be1eadeb6e7293cc052804e1ca4dba70c9
nextLong
public long nextLong()
{    if (hasNext) {        long result = next;        doNext();        return result;    }    throw new NoSuchElementException();}
cfc67e5714c799daa4f0cae0084231f7d3115d517eae691edd227e7f59489e21
peek
public long peek()
{    if (hasNext) {        return next;    }    throw new NoSuchElementException();}
35cf191913c52f62342140c3521d425f06adc224c9a8969e221da25c8806c142
doNext
private void doNext()
{    int toSkip = geometricDistribution.sample();    delegate.skip(toSkip);    if (delegate.hasNext()) {        next = delegate.next();    } else {        hasNext = false;    }}
eb35e4acc0ab2c89fd30970f01fba35488b3a4581b2af1986091209043508a3e
remove
public void remove()
{    throw new UnsupportedOperationException();}
83659b3f3c32cda5d1e381b9ad4b7db55d1ee8ecce3504ad3c9ad45a376b6f2e
skip
public void skip(int n)
{    int toSkip = 0;    for (int i = 0; i < n; i++) {        toSkip += geometricDistribution.sample();    }    delegate.skip(toSkip);    if (delegate.hasNext()) {        next = delegate.next();    } else {        hasNext = false;    }}
35dc3380a52a973207fa8b81dbc157e956897c3857b906c6e14c5461e621c0de
maybeWrapIterator
public static LongPrimitiveIterator maybeWrapIterator(LongPrimitiveIterator delegate, double samplingRate)
{    return samplingRate >= 1.0 ? delegate : new SamplingLongPrimitiveIterator(delegate, samplingRate);}
fc6c64c83026d54e84950a524e778394db86fbc18d119a61b3a676ece79461ea
addDatum
public synchronized void addDatum(double datum)
{    addDatum(datum, 1.0);}
94a51ad94872ab60c6b453268869d53277795f83cc402ca6ab25ef6b3bdf591e
addDatum
public synchronized void addDatum(double datum, double weight)
{    double oldTotalWeight = totalWeight;    totalWeight += weight;    if (oldTotalWeight <= 0.0) {        average = datum;    } else {        average = average * oldTotalWeight / totalWeight + datum * weight / totalWeight;    }}
1d579aacb4eeee46ff020bc448b5acf955b64093d917b53b3ec08a4a3aa87f75
removeDatum
public synchronized void removeDatum(double datum)
{    removeDatum(datum, 1.0);}
872f5a9659572298fb42ad25e1939be8e1b36fdf06018afbe63ac3a006c95f87
removeDatum
public synchronized void removeDatum(double datum, double weight)
{    double oldTotalWeight = totalWeight;    totalWeight -= weight;    if (totalWeight <= 0.0) {        average = Double.NaN;        totalWeight = 0.0;    } else {        average = average * oldTotalWeight / totalWeight - datum * weight / totalWeight;    }}
e4072818afd5eeaf0b36b85463cf2a59a34211f3b55f04e3f347cfbd9ad0049d
changeDatum
public synchronized void changeDatum(double delta)
{    changeDatum(delta, 1.0);}
4b62ea6d502ab2f01b5e7b94e94ba7e92533a6f5ce1a0f9b1bb1c24994eff73b
changeDatum
public synchronized void changeDatum(double delta, double weight)
{    Preconditions.checkArgument(weight <= totalWeight, "weight must be <= totalWeight");    average += delta * weight / totalWeight;}
6f466378c556109e2a4bc8a80ae8abe0ec4e7f61a5ad3f645b81249e6ac60a4f
getTotalWeight
public synchronized double getTotalWeight()
{    return totalWeight;}
33a3bfe7f1d044bff872c5044b6d18cc46b0667805d0899043532c9a08c399da
getCount
public synchronized int getCount()
{    return (int) totalWeight;}
e912da37ecb20c5a446350c7b6e8c0c4c0ba8402f4d3f24b34e6e80a7b494b9f
getAverage
public synchronized double getAverage()
{    return average;}
4077083716d43fae6c65d8a10c5de938090101d08f34eae21dbc91fecdba1805
inverse
public RunningAverage inverse()
{    return new InvertedRunningAverage(this);}
ced683865ec943e6fb0f59cfe94f9b041011464836da39fedb553752fdfb3495
toString
public synchronized String toString()
{    return String.valueOf(average);}
94a51ad94872ab60c6b453268869d53277795f83cc402ca6ab25ef6b3bdf591e
addDatum
public synchronized void addDatum(double datum, double weight)
{    super.addDatum(datum, weight);    totalSquaredWeight += weight * weight;    double weightedData = datum * weight;    totalWeightedData += weightedData;    totalWeightedSquaredData += weightedData * datum;}
872f5a9659572298fb42ad25e1939be8e1b36fdf06018afbe63ac3a006c95f87
removeDatum
public synchronized void removeDatum(double datum, double weight)
{    super.removeDatum(datum, weight);    totalSquaredWeight -= weight * weight;    if (totalSquaredWeight <= 0.0) {        totalSquaredWeight = 0.0;    }    double weightedData = datum * weight;    totalWeightedData -= weightedData;    if (totalWeightedData <= 0.0) {        totalWeightedData = 0.0;    }    totalWeightedSquaredData -= weightedData * datum;    if (totalWeightedSquaredData <= 0.0) {        totalWeightedSquaredData = 0.0;    }}
4b62ea6d502ab2f01b5e7b94e94ba7e92533a6f5ce1a0f9b1bb1c24994eff73b
changeDatum
public synchronized void changeDatum(double delta, double weight)
{    throw new UnsupportedOperationException();}
8fc8ebb584e31199b76dd32b5a12c9d0eeb6acc06c013260d0e327df42e5f5a4
getStandardDeviation
public synchronized double getStandardDeviation()
{    double totalWeight = getTotalWeight();    return Math.sqrt((totalWeightedSquaredData * totalWeight - totalWeightedData * totalWeightedData) / (totalWeight * totalWeight - totalSquaredWeight));}
ffd87790f7cfad27f5c85d9024b808f6f21f9ce850b93b5dd3885f69ef50d802
inverse
public RunningAverageAndStdDev inverse()
{    return new InvertedRunningAverageAndStdDev(this);}
ced683865ec943e6fb0f59cfe94f9b041011464836da39fedb553752fdfb3495
toString
public synchronized String toString()
{    return String.valueOf(String.valueOf(getAverage()) + ',' + getStandardDeviation());}
1a1dbb8b908b8583e8f8d282613f13a28a98ede696096dd7edc819e7eab94848
getMaxPreference
public final float getMaxPreference()
{    return maxPreference;}
ed6d6bad605c3a565c471647b4d07ed99947b759de5b270bd5bb7e669970721a
setMaxPreference
public final void setMaxPreference(float maxPreference)
{    this.maxPreference = maxPreference;}
52c1ac392cc092495e952d67185a7df084c0abfb8f339f2bb5bc43eaaa41313f
getMinPreference
public final float getMinPreference()
{    return minPreference;}
f9c70d0e50f6d4b65db691921ef999d8e96c4d5cc377aae5c42420bed49e9534
setMinPreference
public final void setMinPreference(float minPreference)
{    this.minPreference = minPreference;}
13fb9f21f36332ee06a990e85a6e4e25b9309aefb898a58fdaa793efcb15dc93
evaluate
public double evaluate(RecommenderBuilder recommenderBuilder, DataModelBuilder dataModelBuilder, DataModel dataModel, double trainingPercentage, double evaluationPercentage) throws TasteException
{    Preconditions.checkNotNull(recommenderBuilder);    Preconditions.checkNotNull(dataModel);    Preconditions.checkArgument(trainingPercentage >= 0.0 && trainingPercentage <= 1.0, "Invalid trainingPercentage: " + trainingPercentage + ". Must be: 0.0 <= trainingPercentage <= 1.0");    Preconditions.checkArgument(evaluationPercentage >= 0.0 && evaluationPercentage <= 1.0, "Invalid evaluationPercentage: " + evaluationPercentage + ". Must be: 0.0 <= evaluationPercentage <= 1.0");    log.info("Beginning evaluation using {} of {}", trainingPercentage, dataModel);    int numUsers = dataModel.getNumUsers();    FastByIDMap<PreferenceArray> trainingPrefs = new FastByIDMap<>(1 + (int) (evaluationPercentage * numUsers));    FastByIDMap<PreferenceArray> testPrefs = new FastByIDMap<>(1 + (int) (evaluationPercentage * numUsers));    LongPrimitiveIterator it = dataModel.getUserIDs();    while (it.hasNext()) {        long userID = it.nextLong();        if (random.nextDouble() < evaluationPercentage) {            splitOneUsersPrefs(trainingPercentage, trainingPrefs, testPrefs, userID, dataModel);        }    }    DataModel trainingModel = dataModelBuilder == null ? new GenericDataModel(trainingPrefs) : dataModelBuilder.buildDataModel(trainingPrefs);    Recommender recommender = recommenderBuilder.buildRecommender(trainingModel);    double result = getEvaluation(testPrefs, recommender);    log.info("Evaluation result: {}", result);    return result;}
6749269f93983426330fd3372299d606568d22eefcf295a7581be17dce77b7f8
splitOneUsersPrefs
private void splitOneUsersPrefs(double trainingPercentage, FastByIDMap<PreferenceArray> trainingPrefs, FastByIDMap<PreferenceArray> testPrefs, long userID, DataModel dataModel) throws TasteException
{    List<Preference> oneUserTrainingPrefs = null;    List<Preference> oneUserTestPrefs = null;    PreferenceArray prefs = dataModel.getPreferencesFromUser(userID);    int size = prefs.length();    for (int i = 0; i < size; i++) {        Preference newPref = new GenericPreference(userID, prefs.getItemID(i), prefs.getValue(i));        if (random.nextDouble() < trainingPercentage) {            if (oneUserTrainingPrefs == null) {                oneUserTrainingPrefs = new ArrayList<>(3);            }            oneUserTrainingPrefs.add(newPref);        } else {            if (oneUserTestPrefs == null) {                oneUserTestPrefs = new ArrayList<>(3);            }            oneUserTestPrefs.add(newPref);        }    }    if (oneUserTrainingPrefs != null) {        trainingPrefs.put(userID, new GenericUserPreferenceArray(oneUserTrainingPrefs));        if (oneUserTestPrefs != null) {            testPrefs.put(userID, new GenericUserPreferenceArray(oneUserTestPrefs));        }    }}
303895f9408aacc1bff8c2640d71808e59f78e7985d777477fe8ac691418d8ae
capEstimatedPreference
private float capEstimatedPreference(float estimate)
{    if (estimate > maxPreference) {        return maxPreference;    }    if (estimate < minPreference) {        return minPreference;    }    return estimate;}
e89044c5023da33b07fcbadfaa1cf0053a71f9eb88a6584459003c37dc479cbd
getEvaluation
private double getEvaluation(FastByIDMap<PreferenceArray> testPrefs, Recommender recommender) throws TasteException
{    reset();    Collection<Callable<Void>> estimateCallables = new ArrayList<>();    AtomicInteger noEstimateCounter = new AtomicInteger();    for (Map.Entry<Long, PreferenceArray> entry : testPrefs.entrySet()) {        estimateCallables.add(new PreferenceEstimateCallable(recommender, entry.getKey(), entry.getValue(), noEstimateCounter));    }    log.info("Beginning evaluation of {} users", estimateCallables.size());    RunningAverageAndStdDev timing = new FullRunningAverageAndStdDev();    execute(estimateCallables, noEstimateCounter, timing);    return computeFinalEvaluation();}
a03c388b6753276d46fa6ccc79eb1908d19c62422663ce4de2136717590986aa
execute
protected static void execute(Collection<Callable<Void>> callables, AtomicInteger noEstimateCounter, RunningAverageAndStdDev timing) throws TasteException
{    Collection<Callable<Void>> wrappedCallables = wrapWithStatsCallables(callables, noEstimateCounter, timing);    int numProcessors = Runtime.getRuntime().availableProcessors();    ExecutorService executor = Executors.newFixedThreadPool(numProcessors);    log.info("Starting timing of {} tasks in {} threads", wrappedCallables.size(), numProcessors);    try {        List<Future<Void>> futures = executor.invokeAll(wrappedCallables);                for (Future<Void> future : futures) {            future.get();        }    } catch (InterruptedException ie) {        throw new TasteException(ie);    } catch (ExecutionException ee) {        throw new TasteException(ee.getCause());    }    executor.shutdown();    try {        executor.awaitTermination(10, TimeUnit.SECONDS);    } catch (InterruptedException e) {        throw new TasteException(e.getCause());    }}
bd24c1f76b02bd55a94d952076a5486dc8b24ff1ab61c5dfbac73d16aa42e116
wrapWithStatsCallables
private static Collection<Callable<Void>> wrapWithStatsCallables(Iterable<Callable<Void>> callables, AtomicInteger noEstimateCounter, RunningAverageAndStdDev timing)
{    Collection<Callable<Void>> wrapped = new ArrayList<>();    int count = 0;    for (Callable<Void> callable : callables) {                boolean logStats = count++ % 1000 == 0;        wrapped.add(new StatsCallable(callable, logStats, timing, noEstimateCounter));    }    return wrapped;}
3ce52154f9ec1fad31af484fc477f2f59debc6f6700b85a99862326f96fc6db7
call
public Void call() throws TasteException
{    for (Preference realPref : prefs) {        float estimatedPreference = Float.NaN;        try {            estimatedPreference = recommender.estimatePreference(testUserID, realPref.getItemID());        } catch (NoSuchUserException nsue) {                                    log.info("User exists in test data but not training data: {}", testUserID);        } catch (NoSuchItemException nsie) {            log.info("Item exists in test data but not training data: {}", realPref.getItemID());        }        if (Float.isNaN(estimatedPreference)) {            noEstimateCounter.incrementAndGet();        } else {            estimatedPreference = capEstimatedPreference(estimatedPreference);            processOneEstimate(estimatedPreference, realPref);        }    }    return null;}
be1a56c7ae2c2f9ffcdc6b49e244b4eaac6ed33e21475a783841ddf769017dcd
reset
protected void reset()
{    average = new FullRunningAverage();}
564de17b779b836b599f961d80ca9e66835bffe24036e1c8ef3099ec239de317
processOneEstimate
protected void processOneEstimate(float estimatedPreference, Preference realPref)
{    average.addDatum(Math.abs(realPref.getValue() - estimatedPreference));}
7a6d373c44bb4c8d3eed87d9628fb1e8ddbf0bdbe9fd84e8e6044cf4f278f3bb
computeFinalEvaluation
protected double computeFinalEvaluation()
{    return average.getAverage();}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "AverageAbsoluteDifferenceRecommenderEvaluator";}
753aa07942d35dabcc38260f3bf6a6c9c2c0458d1b9ebfe1718d1b3ef2a4d962
evaluate
public IRStatistics evaluate(RecommenderBuilder recommenderBuilder, DataModelBuilder dataModelBuilder, DataModel dataModel, IDRescorer rescorer, int at, double relevanceThreshold, double evaluationPercentage) throws TasteException
{    Preconditions.checkArgument(recommenderBuilder != null, "recommenderBuilder is null");    Preconditions.checkArgument(dataModel != null, "dataModel is null");    Preconditions.checkArgument(at >= 1, "at must be at least 1");    Preconditions.checkArgument(evaluationPercentage > 0.0 && evaluationPercentage <= 1.0, "Invalid evaluationPercentage: " + evaluationPercentage + ". Must be: 0.0 < evaluationPercentage <= 1.0");    int numItems = dataModel.getNumItems();    RunningAverage precision = new FullRunningAverage();    RunningAverage recall = new FullRunningAverage();    RunningAverage fallOut = new FullRunningAverage();    RunningAverage nDCG = new FullRunningAverage();    int numUsersRecommendedFor = 0;    int numUsersWithRecommendations = 0;    LongPrimitiveIterator it = dataModel.getUserIDs();    while (it.hasNext()) {        long userID = it.nextLong();        if (random.nextDouble() >= evaluationPercentage) {                        continue;        }        long start = System.currentTimeMillis();        PreferenceArray prefs = dataModel.getPreferencesFromUser(userID);                double theRelevanceThreshold = Double.isNaN(relevanceThreshold) ? computeThreshold(prefs) : relevanceThreshold;        FastIDSet relevantItemIDs = dataSplitter.getRelevantItemsIDs(userID, at, theRelevanceThreshold, dataModel);        int numRelevantItems = relevantItemIDs.size();        if (numRelevantItems <= 0) {            continue;        }        FastByIDMap<PreferenceArray> trainingUsers = new FastByIDMap<>(dataModel.getNumUsers());        LongPrimitiveIterator it2 = dataModel.getUserIDs();        while (it2.hasNext()) {            dataSplitter.processOtherUser(userID, relevantItemIDs, trainingUsers, it2.nextLong(), dataModel);        }        DataModel trainingModel = dataModelBuilder == null ? new GenericDataModel(trainingUsers) : dataModelBuilder.buildDataModel(trainingUsers);        try {            trainingModel.getPreferencesFromUser(userID);        } catch (NoSuchUserException nsee) {                        continue;        }        int size = numRelevantItems + trainingModel.getItemIDsFromUser(userID).size();        if (size < 2 * at) {                        continue;        }        Recommender recommender = recommenderBuilder.buildRecommender(trainingModel);        int intersectionSize = 0;        List<RecommendedItem> recommendedItems = recommender.recommend(userID, at, rescorer);        for (RecommendedItem recommendedItem : recommendedItems) {            if (relevantItemIDs.contains(recommendedItem.getItemID())) {                intersectionSize++;            }        }        int numRecommendedItems = recommendedItems.size();                if (numRecommendedItems > 0) {            precision.addDatum((double) intersectionSize / (double) numRecommendedItems);        }                recall.addDatum((double) intersectionSize / (double) numRelevantItems);                if (numRelevantItems < size) {            fallOut.addDatum((double) (numRecommendedItems - intersectionSize) / (double) (numItems - numRelevantItems));        }                        double cumulativeGain = 0.0;        double idealizedGain = 0.0;        for (int i = 0; i < numRecommendedItems; i++) {            RecommendedItem item = recommendedItems.get(i);                        double discount = 1.0 / log2(i + 2.0);            if (relevantItemIDs.contains(item.getItemID())) {                cumulativeGain += discount;            }                        if (i < numRelevantItems) {                idealizedGain += discount;            }        }        if (idealizedGain > 0.0) {            nDCG.addDatum(cumulativeGain / idealizedGain);        }                numUsersRecommendedFor++;        if (numRecommendedItems > 0) {            numUsersWithRecommendations++;        }        long end = System.currentTimeMillis();        log.info("Evaluated with user {} in {}ms", userID, end - start);        log.info("Precision/recall/fall-out/nDCG/reach: {} / {} / {} / {} / {}", precision.getAverage(), recall.getAverage(), fallOut.getAverage(), nDCG.getAverage(), (double) numUsersWithRecommendations / (double) numUsersRecommendedFor);    }    return new IRStatisticsImpl(precision.getAverage(), recall.getAverage(), fallOut.getAverage(), nDCG.getAverage(), (double) numUsersWithRecommendations / (double) numUsersRecommendedFor);}
477e3517d9eee32e6d6495ddaaa8e51f4d9584339e21a3fa76aff2317311aa8b
computeThreshold
private static double computeThreshold(PreferenceArray prefs)
{    if (prefs.length() < 2) {                return Double.NEGATIVE_INFINITY;    }    RunningAverageAndStdDev stdDev = new FullRunningAverageAndStdDev();    int size = prefs.length();    for (int i = 0; i < size; i++) {        stdDev.addDatum(prefs.getValue(i));    }    return stdDev.getAverage() + stdDev.getStandardDeviation();}
83d7f7bc3f040b8fa5720d42a8ddf3deb30697f92b096bab7fa7a72475c73b7f
log2
private static double log2(double value)
{    return Math.log(value) / LOG2;}
0a84b6ec8aaa489db73f4bc26555552173a7ee15f073f36e9dff8c0915581353
getRelevantItemsIDs
public FastIDSet getRelevantItemsIDs(long userID, int at, double relevanceThreshold, DataModel dataModel) throws TasteException
{    PreferenceArray prefs = dataModel.getPreferencesFromUser(userID);    FastIDSet relevantItemIDs = new FastIDSet(at);    prefs.sortByValueReversed();    for (int i = 0; i < prefs.length() && relevantItemIDs.size() < at; i++) {        if (prefs.getValue(i) >= relevanceThreshold) {            relevantItemIDs.add(prefs.getItemID(i));        }    }    return relevantItemIDs;}
0480d79de701f9681b9594ca67bb2927b699790a4c10b36b5f86a4d4e3332714
processOtherUser
public void processOtherUser(long userID, FastIDSet relevantItemIDs, FastByIDMap<PreferenceArray> trainingUsers, long otherUserID, DataModel dataModel) throws TasteException
{    PreferenceArray prefs2Array = dataModel.getPreferencesFromUser(otherUserID);        if (userID == otherUserID) {                List<Preference> prefs2 = new ArrayList<>(prefs2Array.length());        for (Preference pref : prefs2Array) {            prefs2.add(pref);        }        for (Iterator<Preference> iterator = prefs2.iterator(); iterator.hasNext(); ) {            Preference pref = iterator.next();            if (relevantItemIDs.contains(pref.getItemID())) {                iterator.remove();            }        }        if (!prefs2.isEmpty()) {            trainingUsers.put(otherUserID, new GenericUserPreferenceArray(prefs2));        }    } else {                trainingUsers.put(otherUserID, prefs2Array);    }}
0b075a25c210a56510ea2b1ee7cc87baf6dcac5ff4e3513344f9214891c1448e
getPrecision
public double getPrecision()
{    return precision;}
3d9aca776fbb94cf746e24915e80cfe659bc3a9d342b016de644e1a918777759
getRecall
public double getRecall()
{    return recall;}
bf28756eb40cef3f92d4f5b81de956b172e1927323a0ae0a5f2005daef5381c3
getFallOut
public double getFallOut()
{    return fallOut;}
c206c8afc1cb3f1ed01b4a97b46c796c59997a4dc1749fa0a0d6741216826119
getF1Measure
public double getF1Measure()
{    return getFNMeasure(1.0);}
47b9d8798fff616b15d786a454db46ad0c77d3f64d866777b1142b9e65b382a9
getFNMeasure
public double getFNMeasure(double b)
{    double b2 = b * b;    double sum = b2 * precision + recall;    return sum == 0.0 ? Double.NaN : (1.0 + b2) * precision * recall / sum;}
7cc0e76c093fec10adfd7f0b442c33fc0666dd5442c42cc33a1dcaf79591581c
getNormalizedDiscountedCumulativeGain
public double getNormalizedDiscountedCumulativeGain()
{    return ndcg;}
59fb73c4095567ef228e6b6c88c62f16b93493e1dbab2c3ebf9592d97f9e4757
getReach
public double getReach()
{    return reach;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "IRStatisticsImpl[precision:" + precision + ",recall:" + recall + ",fallOut:" + fallOut + ",nDCG:" + ndcg + ",reach:" + reach + ']';}
d12537fee0d4fb03a2b54ca4cc2cb7aeeb6659af2e7d4f187baf67a1d3ca17d2
call
public Void call() throws Exception
{    recommender.recommend(userID, 10);    return null;}
eeedfd3940b630dc8dd245e89a6e8c3b8b22774f5d766c433d45daff401066b0
runLoad
public static LoadStatistics runLoad(Recommender recommender) throws TasteException
{    return runLoad(recommender, 10);}
2c5119219e9b271d0314d9070affd59d87b632a86d8f445ca5e2de304df20862
runLoad
public static LoadStatistics runLoad(Recommender recommender, int howMany) throws TasteException
{    DataModel dataModel = recommender.getDataModel();    int numUsers = dataModel.getNumUsers();    double sampleRate = 1000.0 / numUsers;    LongPrimitiveIterator userSampler = SamplingLongPrimitiveIterator.maybeWrapIterator(dataModel.getUserIDs(), sampleRate);        recommender.recommend(userSampler.next(), howMany);    Collection<Callable<Void>> callables = new ArrayList<>();    while (userSampler.hasNext()) {        callables.add(new LoadCallable(recommender, userSampler.next()));    }    AtomicInteger noEstimateCounter = new AtomicInteger();    RunningAverageAndStdDev timing = new FullRunningAverageAndStdDev();    AbstractDifferenceRecommenderEvaluator.execute(callables, noEstimateCounter, timing);    return new LoadStatistics(timing);}
9dee6835e698cc6c300f3f56647cef98fde249e0fdca641fda3296c91b1f768f
getTiming
public RunningAverage getTiming()
{    return timing;}
a87e83882a7628b1e517c99f75c355fdb3790d3c9b5ac824958445b2b3b30469
evaluate
public static void evaluate(Recommender recommender1, Recommender recommender2, int samples, RunningAverage tracker, String tag) throws TasteException
{    printHeader();    LongPrimitiveIterator users = recommender1.getDataModel().getUserIDs();    while (users.hasNext()) {        long userID = users.nextLong();        List<RecommendedItem> recs1 = recommender1.recommend(userID, samples);        List<RecommendedItem> recs2 = recommender2.recommend(userID, samples);        FastIDSet commonSet = new FastIDSet();        long maxItemID = setBits(commonSet, recs1, samples);        FastIDSet otherSet = new FastIDSet();        maxItemID = Math.max(maxItemID, setBits(otherSet, recs2, samples));        int max = mask(commonSet, otherSet, maxItemID);        max = Math.min(max, samples);        if (max < 2) {            continue;        }        Long[] items1 = getCommonItems(commonSet, recs1, max);        Long[] items2 = getCommonItems(commonSet, recs2, max);        double variance = scoreCommonSubset(tag, userID, samples, max, items1, items2);        tracker.addDatum(variance);    }}
29d9c9368e0b69b98e7f28bae1ac9824be6b3e1fc5ca0fd9fea84841bf10abad
evaluate
public static void evaluate(Recommender recommender, DataModel model, int samples, RunningAverage tracker, String tag) throws TasteException
{    printHeader();    LongPrimitiveIterator users = recommender.getDataModel().getUserIDs();    while (users.hasNext()) {        long userID = users.nextLong();        List<RecommendedItem> recs1 = recommender.recommend(userID, model.getNumItems());        PreferenceArray prefs2 = model.getPreferencesFromUser(userID);        prefs2.sortByValueReversed();        FastIDSet commonSet = new FastIDSet();        long maxItemID = setBits(commonSet, recs1, samples);        FastIDSet otherSet = new FastIDSet();        maxItemID = Math.max(maxItemID, setBits(otherSet, prefs2, samples));        int max = mask(commonSet, otherSet, maxItemID);        max = Math.min(max, samples);        if (max < 2) {            continue;        }        Long[] items1 = getCommonItems(commonSet, recs1, max);        Long[] items2 = getCommonItems(commonSet, prefs2, max);        double variance = scoreCommonSubset(tag, userID, samples, max, items1, items2);        tracker.addDatum(variance);    }}
ab62b05dc13c5b101e6183d3a8f908c472ef8ea56774aae8769ddb8c8f1d9fbc
evaluate
public static void evaluate(DataModel model1, DataModel model2, int samples, RunningAverage tracker, String tag) throws TasteException
{    printHeader();    LongPrimitiveIterator users = model1.getUserIDs();    while (users.hasNext()) {        long userID = users.nextLong();        PreferenceArray prefs1 = model1.getPreferencesFromUser(userID);        PreferenceArray prefs2 = model2.getPreferencesFromUser(userID);        prefs1.sortByValueReversed();        prefs2.sortByValueReversed();        FastIDSet commonSet = new FastIDSet();        long maxItemID = setBits(commonSet, prefs1, samples);        FastIDSet otherSet = new FastIDSet();        maxItemID = Math.max(maxItemID, setBits(otherSet, prefs2, samples));        int max = mask(commonSet, otherSet, maxItemID);        max = Math.min(max, samples);        if (max < 2) {            continue;        }        Long[] items1 = getCommonItems(commonSet, prefs1, max);        Long[] items2 = getCommonItems(commonSet, prefs2, max);        double variance = scoreCommonSubset(tag, userID, samples, max, items1, items2);        tracker.addDatum(variance);    }}
20ce9d72265361ac6741ad7432c6a54e577028e6aa32db9e9e2265b1450815b7
mask
private static int mask(FastIDSet commonSet, FastIDSet otherSet, long maxItemID)
{    int count = 0;    for (int i = 0; i <= maxItemID; i++) {        if (commonSet.contains(i)) {            if (otherSet.contains(i)) {                count++;            } else {                commonSet.remove(i);            }        }    }    return count;}
a5dc33d9b6ae4813c265fb5214eaa6148fe91d83cd5953b8b2702da55613f559
getCommonItems
private static Long[] getCommonItems(FastIDSet commonSet, Iterable<RecommendedItem> recs, int max)
{    Long[] commonItems = new Long[max];    int index = 0;    for (RecommendedItem rec : recs) {        Long item = rec.getItemID();        if (commonSet.contains(item)) {            commonItems[index++] = item;        }        if (index == max) {            break;        }    }    return commonItems;}
ac0ca62d9b2071f3a55576afb51f227860b93410d1e09b63eb9be6dcd475fd64
getCommonItems
private static Long[] getCommonItems(FastIDSet commonSet, PreferenceArray prefs1, int max)
{    Long[] commonItems = new Long[max];    int index = 0;    for (int i = 0; i < prefs1.length(); i++) {        Long item = prefs1.getItemID(i);        if (commonSet.contains(item)) {            commonItems[index++] = item;        }        if (index == max) {            break;        }    }    return commonItems;}
85e0c6d8fd6f8a5e3cfb80cdf4ff168205a01b17d840de44205733d3454751d3
setBits
private static long setBits(FastIDSet modelSet, List<RecommendedItem> items, int max)
{    long maxItem = -1;    for (int i = 0; i < items.size() && i < max; i++) {        long itemID = items.get(i).getItemID();        modelSet.add(itemID);        if (itemID > maxItem) {            maxItem = itemID;        }    }    return maxItem;}
ca89027a5ed95416918593ac194f0ba8e1b7996ee670aab6fd16978aafde8a78
setBits
private static long setBits(FastIDSet modelSet, PreferenceArray prefs, int max)
{    long maxItem = -1;    for (int i = 0; i < prefs.length() && i < max; i++) {        long itemID = prefs.getItemID(i);        modelSet.add(itemID);        if (itemID > maxItem) {            maxItem = itemID;        }    }    return maxItem;}
5b0a57ffe722ff5c3a24526d6c2084c15706c3679194e38962fb047c781b3005
printHeader
private static void printHeader()
{    log.info("tag,user,samples,common,hamming,bubble,rank,normal,score");}
e1fb8e63aa147fde65b057813ec17fd27262be0d7638fb1071aa009421c765d4
scoreCommonSubset
private static double scoreCommonSubset(String tag, long userID, int samples, int subset, Long[] itemsL, Long[] itemsR)
{    int[] vectorZ = new int[subset];    int[] vectorZabs = new int[subset];    long bubble = sort(itemsL, itemsR);    int hamming = slidingWindowHamming(itemsR, itemsL);    if (hamming > samples) {        throw new IllegalStateException();    }    getVectorZ(itemsR, itemsL, vectorZ, vectorZabs);    double normalW = normalWilcoxon(vectorZ, vectorZabs);    double meanRank = getMeanRank(vectorZabs);        double variance = Math.sqrt(meanRank);    log.info("{},{},{},{},{},{},{},{},{}", tag, userID, samples, subset, hamming, bubble, meanRank, normalW, variance);    return variance;}
032f4f77bac9eb8e00cc180a5abf0b5565cdf5e95dbb452c8d6e212d463e1cfb
slidingWindowHamming
private static int slidingWindowHamming(Long[] itemsR, Long[] itemsL)
{    int count = 0;    int samples = itemsR.length;    if (itemsR[0].equals(itemsL[0]) || itemsR[0].equals(itemsL[1])) {        count++;    }    for (int i = 1; i < samples - 1; i++) {        long itemID = itemsL[i];        if (itemsR[i] == itemID || itemsR[i - 1] == itemID || itemsR[i + 1] == itemID) {            count++;        }    }    if (itemsR[samples - 1].equals(itemsL[samples - 1]) || itemsR[samples - 1].equals(itemsL[samples - 2])) {        count++;    }    return count;}
8aa5a26358dbaab5eb6fb70aae8fed366c8bb13510f732e05ab7a1dc46efdb72
normalWilcoxon
 static double normalWilcoxon(int[] vectorZ, int[] vectorZabs)
{    int nitems = vectorZ.length;    double[] ranks = new double[nitems];    double[] ranksAbs = new double[nitems];    wilcoxonRanks(vectorZ, vectorZabs, ranks, ranksAbs);    return Math.min(getMeanWplus(ranks), getMeanWminus(ranks));}
237c74000518cbee667daccdae83187c6a2cd5fa7cc171e332d27f4870ae9d9d
getVectorZ
private static void getVectorZ(Long[] itemsR, Long[] itemsL, int[] vectorZ, int[] vectorZabs)
{    int nitems = itemsR.length;    int bottom = 0;    int top = nitems - 1;    for (int i = 0; i < nitems; i++) {        long itemID = itemsR[i];        for (int j = bottom; j <= top; j++) {            if (itemsL[j] == null) {                continue;            }            long test = itemsL[j];            if (itemID == test) {                vectorZ[i] = i - j;                vectorZabs[i] = Math.abs(i - j);                if (j == bottom) {                    bottom++;                } else if (j == top) {                    top--;                } else {                    itemsL[j] = null;                }                break;            }        }    }}
429b643c164a59848711df6dd82a2f122c188622421b48be8fdae03530cc2ed5
wilcoxonRanks
private static void wilcoxonRanks(int[] vectorZ, int[] vectorZabs, double[] ranks, double[] ranksAbs)
{    int nitems = vectorZ.length;    int[] sorted = vectorZabs.clone();    Arrays.sort(sorted);    int zeros = 0;    for (; zeros < nitems; zeros++) {        if (sorted[zeros] > 0) {            break;        }    }    for (int i = 0; i < nitems; i++) {        double rank = 0.0;        int count = 0;        int score = vectorZabs[i];        for (int j = 0; j < nitems; j++) {            if (score == sorted[j]) {                rank += j + 1 - zeros;                count++;            } else if (score < sorted[j]) {                break;            }        }        if (vectorZ[i] != 0) {                        ranks[i] = (rank / count) * (vectorZ[i] < 0 ? -1 : 1);            ranksAbs[i] = Math.abs(ranks[i]);        }    }}
4ab2d6982482ef9cf68eacf0b2203713a91c53e211b807d663b1bbebcfeb0f44
getMeanRank
private static double getMeanRank(int[] ranks)
{    int nitems = ranks.length;    double sum = 0.0;    for (int rank : ranks) {        sum += rank;    }    return sum / nitems;}
c092ac7e7c762ab25b2f49f86efc6a620edda472ecdcd41e01040cb6ab3a080c
getMeanWplus
private static double getMeanWplus(double[] ranks)
{    int nitems = ranks.length;    double sum = 0.0;    for (double rank : ranks) {        if (rank > 0) {            sum += rank;        }    }    return sum / nitems;}
222111763b3847b44a335250bb8d5fe5ca562842f55260609b1f18ab971a3bcf
getMeanWminus
private static double getMeanWminus(double[] ranks)
{    int nitems = ranks.length;    double sum = 0.0;    for (double rank : ranks) {        if (rank < 0) {            sum -= rank;        }    }    return sum / nitems;}
e4b07e2f3b8863d3fa5fce7dc19a7559109552db488a5746a8f0c5097cb7c8a4
sort
 static long sort(Long[] itemsL, Long[] itemsR)
{    int length = itemsL.length;    if (length < 2) {        return 0;    }    if (length == 2) {        return itemsL[0].longValue() == itemsR[0].longValue() ? 0 : 1;    }        long[] reference = new long[length];    long[] sortable = new long[length];    for (int i = 0; i < length; i++) {        reference[i] = itemsL[i];        sortable[i] = itemsR[i];    }    int sorted = 0;    long swaps = 0;    while (sorted < length - 1) {                while (length > 0 && reference[length - 1] == sortable[length - 1]) {            length--;        }        if (length == 0) {            break;        }        if (reference[sorted] == sortable[sorted]) {            sorted++;        } else {            for (int j = sorted; j < length - 1; j++) {                                int jump = 1;                if (reference[j] == sortable[j]) {                    while (j + jump < length && reference[j + jump] == sortable[j + jump]) {                        jump++;                    }                }                if (j + jump < length && !(reference[j] == sortable[j] && reference[j + jump] == sortable[j + jump])) {                    long tmp = sortable[j];                    sortable[j] = sortable[j + 1];                    sortable[j + 1] = tmp;                    swaps++;                }            }        }    }    return swaps;}
be1a56c7ae2c2f9ffcdc6b49e244b4eaac6ed33e21475a783841ddf769017dcd
reset
protected void reset()
{    average = new FullRunningAverage();}
564de17b779b836b599f961d80ca9e66835bffe24036e1c8ef3099ec239de317
processOneEstimate
protected void processOneEstimate(float estimatedPreference, Preference realPref)
{    double diff = realPref.getValue() - estimatedPreference;    average.addDatum(diff * diff);}
7a6d373c44bb4c8d3eed87d9628fb1e8ddbf0bdbe9fd84e8e6044cf4f278f3bb
computeFinalEvaluation
protected double computeFinalEvaluation()
{    return Math.sqrt(average.getAverage());}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "RMSRecommenderEvaluator";}
d12537fee0d4fb03a2b54ca4cc2cb7aeeb6659af2e7d4f187baf67a1d3ca17d2
call
public Void call() throws Exception
{    long start = System.currentTimeMillis();    delegate.call();    long end = System.currentTimeMillis();    timing.addDatum(end - start);    if (logStats) {        Runtime runtime = Runtime.getRuntime();        int average = (int) timing.getAverage();        log.info("Average time per recommendation: {}ms", average);        long totalMemory = runtime.totalMemory();        long memory = totalMemory - runtime.freeMemory();        log.info("Approximate memory used: {}MB / {}MB", memory / 1000000L, totalMemory / 1000000L);        log.info("Unable to recommend in {} cases", noEstimateCounter.get());    }    return null;}
13925bef8afa2e6d068d08c72262016e42e3d5fe30ac04c85c78f8b0f99c4ceb
getMaxPreference
public float getMaxPreference()
{    return maxPreference;}
29e53beacd3f401cb6a1cc0954bc08d76d9efd03b0019f84c6382cf9f4cecb10
setMaxPreference
protected void setMaxPreference(float maxPreference)
{    this.maxPreference = maxPreference;}
886c9fcd0006e44aa20de41c56cd99e5659dc842b2fd94840da5c661f1bccb0a
getMinPreference
public float getMinPreference()
{    return minPreference;}
ad2bf7200c28fe869f23fa077ebdd92b0eab8014e0caae3ed8720065f2c23a15
setMinPreference
protected void setMinPreference(float minPreference)
{    this.minPreference = minPreference;}
5647058642c89a2b18a8318c4ad40cdae3f512bc2029bc73af78d780b4931e1c
hash
protected final long hash(String value)
{    byte[] md5hash;    synchronized (md5Digest) {        md5hash = md5Digest.digest(value.getBytes(Charsets.UTF_8));        md5Digest.reset();    }    long hash = 0L;    for (int i = 0; i < 8; i++) {        hash = hash << 8 | md5hash[i] & 0x00000000000000FFL;    }    return hash;}
856acb666be7f1e614cb4a4bcc9f443781ea2bd0c57e6540f88908dc5a416f60
toLongID
public long toLongID(String stringID)
{    return hash(stringID);}
da77e35d28c590f4b271e5b2b7f639c465574b8f17a1ef2f1df63e0152c57e8b
refresh
public void refresh(Collection<Refreshable> alreadyRefreshed)
{}
4a028c166ea6f0493d6cd97d874d3750215e469289b181e27264791eae5f5b66
storeMapping
public final void storeMapping(long longID, String stringID) throws TasteException
{    Connection conn = null;    PreparedStatement stmt = null;    try {        conn = dataSource.getConnection();        stmt = conn.prepareStatement(storeMappingSQL);        stmt.setLong(1, longID);        stmt.setString(2, stringID);        stmt.executeUpdate();    } catch (SQLException sqle) {        throw new TasteException(sqle);    } finally {        IOUtils.quietClose(null, stmt, conn);    }}
e97933e60ba448e3b4b8b23b469dbad3e54787022b8481d43f07c2e7e59355bf
toStringID
public final String toStringID(long longID) throws TasteException
{    Connection conn = null;    PreparedStatement stmt = null;    ResultSet rs = null;    try {        conn = dataSource.getConnection();        stmt = conn.prepareStatement(getStringIDSQL, ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);        stmt.setFetchDirection(ResultSet.FETCH_FORWARD);        stmt.setFetchSize(1);        stmt.setLong(1, longID);        rs = stmt.executeQuery();        if (rs.next()) {            return rs.getString(1);        } else {            return null;        }    } catch (SQLException sqle) {        throw new TasteException(sqle);    } finally {        IOUtils.quietClose(rs, stmt, conn);    }}
a63c0799a5f27fe4c06f451402c2d7b6b039289de405d21178f34ce62df7add5
initialize
public void initialize(Iterable<String> stringIDs) throws TasteException
{    for (String stringID : stringIDs) {        storeMapping(toLongID(stringID), stringID);    }}
1d1ebdb99c526da23d9a06ed6c089d39abc457289b7aff9cbe5f58a377b283b2
length
public int length()
{    return ids.length;}
1466676badc459d75b4519e8418977e534b8541086db5c066b3452edeec1c2f9
get
public Preference get(int i)
{    return new PreferenceView(i);}
368e5519512976376b6b04e8218aa4d66b71c67ed6b26c23975f993ce77d38e2
set
public void set(int i, Preference pref)
{    id = pref.getItemID();    ids[i] = pref.getUserID();}
0ffb4eed09bcc129b36f0e2e4b2212eab0439f3abc3cd38cc98f0035f0397f28
getUserID
public long getUserID(int i)
{    return ids[i];}
6bb0d8e838c77f4a70a90a3e5cd97eb6fb385b2e6cb50b1ccc25c3963a30e695
setUserID
public void setUserID(int i, long userID)
{    ids[i] = userID;}
5a186538180ac1e47c6d0d5ff6db74eca8d34a4f865110b9b8aed3ee7f8be3cc
getItemID
public long getItemID(int i)
{    return id;}
6ac0df5eb6c901535e9bd0261b5cab5099adc231332153a1c1ea399fecc51b9d
setItemID
public void setItemID(int i, long itemID)
{    id = itemID;}
54a843b431ac7e6f36be07f1d1e47eafa5901821a87b3f882508159e9ee1c1c6
getIDs
public long[] getIDs()
{    return ids;}
fad752eb18ffea7f1dbf59412e26569cbe114ae5efff5a43de301dca4a3791da
getValue
public float getValue(int i)
{    return 1.0f;}
d2049c279705133416ffe7af822246d72d94b1e99f0ab3f5dc4c5d24f7dd9dbc
setValue
public void setValue(int i, float value)
{    throw new UnsupportedOperationException();}
a57bb2ae7c30b6e0e2f09e71b8c0db815e76ceef14698603162b1bf7469c33e6
sortByUser
public void sortByUser()
{    Arrays.sort(ids);}
6a5491706e8493e6c6f00c5e92d4a6d8ace4834d0f3740d344ee16d52fa35788
sortByItem
public void sortByItem()
{}
048d292b512e9212b9e70289eca1bb87d22601878d09992501cb933143fec1ab
sortByValue
public void sortByValue()
{}
e0b5443d0f881fcdbf7e925010c63b245490d0756141727a6ec6bf5cee688545
sortByValueReversed
public void sortByValueReversed()
{}
2eafb849f39af4dfa2b7676d8e4c51dc5781d8b14f79d1a22f91301df5196ae4
hasPrefWithUserID
public boolean hasPrefWithUserID(long userID)
{    for (long id : ids) {        if (userID == id) {            return true;        }    }    return false;}
aaac85cf768aa16aac7c3fd19dee90146fcc1536e3ea776cab5a42fbd920f94f
hasPrefWithItemID
public boolean hasPrefWithItemID(long itemID)
{    return id == itemID;}
d166f0a946876cee998e4db09d97fa981776f9ec26a39dbca356dd25e7d71d43
clone
public BooleanItemPreferenceArray clone()
{    return new BooleanItemPreferenceArray(ids.clone(), id);}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return (int) (id >> 32) ^ (int) id ^ Arrays.hashCode(ids);}
74e378df448c6c3cd090d6daf881cfac8957dd555869ea4c13a46bdc6cdcf9a6
equals
public boolean equals(Object other)
{    if (!(other instanceof BooleanItemPreferenceArray)) {        return false;    }    BooleanItemPreferenceArray otherArray = (BooleanItemPreferenceArray) other;    return id == otherArray.id && Arrays.equals(ids, otherArray.ids);}
84f3f0fbeb10d1940e53d3aea07ad6c6c7e0fb1eb59e8409a6054e3511f33aac
iterator
public Iterator<Preference> iterator()
{    return Iterators.transform(new CountingIterator(length()), new Function<Integer, Preference>() {        @Override        public Preference apply(Integer from) {            return new PreferenceView(from);        }    });}
68b64de371d9fbb52a6c9a862f211df02e27c8ed77eb0dee4908b64bdebf9957
apply
public Preference apply(Integer from)
{    return new PreferenceView(from);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    StringBuilder result = new StringBuilder(10 * ids.length);    result.append("BooleanItemPreferenceArray[itemID:");    result.append(id);    result.append(",{");    for (int i = 0; i < ids.length; i++) {        if (i > 0) {            result.append(',');        }        result.append(ids[i]);    }    result.append("}]");    return result.toString();}
f6291b447e197e279017739fa55cf012e1c9d4eed6fb9eb0dd5d639a28f5227d
getUserID
public long getUserID()
{    return BooleanItemPreferenceArray.this.getUserID(i);}
656666c3e1a83c6eb409c8bf7c3282b6209c6991806a5f70debc7368d69aec7d
getItemID
public long getItemID()
{    return BooleanItemPreferenceArray.this.getItemID(i);}
875eb4918e20f05856417a7a1eae0829852fb11067dcbf34f10f2a09bcacd7bb
getValue
public float getValue()
{    return 1.0f;}
5896e95811f7ac94f4c3a4e3945a78ab6985fcff4389fdaa89ff43765d6cfb72
setValue
public void setValue(float value)
{    throw new UnsupportedOperationException();}
f6291b447e197e279017739fa55cf012e1c9d4eed6fb9eb0dd5d639a28f5227d
getUserID
public long getUserID()
{    return userID;}
656666c3e1a83c6eb409c8bf7c3282b6209c6991806a5f70debc7368d69aec7d
getItemID
public long getItemID()
{    return itemID;}
875eb4918e20f05856417a7a1eae0829852fb11067dcbf34f10f2a09bcacd7bb
getValue
public float getValue()
{    return 1.0f;}
5896e95811f7ac94f4c3a4e3945a78ab6985fcff4389fdaa89ff43765d6cfb72
setValue
public void setValue(float value)
{    throw new UnsupportedOperationException();}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "BooleanPreference[userID: " + userID + ", itemID:" + itemID + ']';}
1d1ebdb99c526da23d9a06ed6c089d39abc457289b7aff9cbe5f58a377b283b2
length
public int length()
{    return ids.length;}
1466676badc459d75b4519e8418977e534b8541086db5c066b3452edeec1c2f9
get
public Preference get(int i)
{    return new PreferenceView(i);}
368e5519512976376b6b04e8218aa4d66b71c67ed6b26c23975f993ce77d38e2
set
public void set(int i, Preference pref)
{    id = pref.getUserID();    ids[i] = pref.getItemID();}
0ffb4eed09bcc129b36f0e2e4b2212eab0439f3abc3cd38cc98f0035f0397f28
getUserID
public long getUserID(int i)
{    return id;}
6bb0d8e838c77f4a70a90a3e5cd97eb6fb385b2e6cb50b1ccc25c3963a30e695
setUserID
public void setUserID(int i, long userID)
{    id = userID;}
5a186538180ac1e47c6d0d5ff6db74eca8d34a4f865110b9b8aed3ee7f8be3cc
getItemID
public long getItemID(int i)
{    return ids[i];}
6ac0df5eb6c901535e9bd0261b5cab5099adc231332153a1c1ea399fecc51b9d
setItemID
public void setItemID(int i, long itemID)
{    ids[i] = itemID;}
54a843b431ac7e6f36be07f1d1e47eafa5901821a87b3f882508159e9ee1c1c6
getIDs
public long[] getIDs()
{    return ids;}
fad752eb18ffea7f1dbf59412e26569cbe114ae5efff5a43de301dca4a3791da
getValue
public float getValue(int i)
{    return 1.0f;}
d2049c279705133416ffe7af822246d72d94b1e99f0ab3f5dc4c5d24f7dd9dbc
setValue
public void setValue(int i, float value)
{    throw new UnsupportedOperationException();}
a57bb2ae7c30b6e0e2f09e71b8c0db815e76ceef14698603162b1bf7469c33e6
sortByUser
public void sortByUser()
{}
6a5491706e8493e6c6f00c5e92d4a6d8ace4834d0f3740d344ee16d52fa35788
sortByItem
public void sortByItem()
{    Arrays.sort(ids);}
048d292b512e9212b9e70289eca1bb87d22601878d09992501cb933143fec1ab
sortByValue
public void sortByValue()
{}
e0b5443d0f881fcdbf7e925010c63b245490d0756141727a6ec6bf5cee688545
sortByValueReversed
public void sortByValueReversed()
{}
2eafb849f39af4dfa2b7676d8e4c51dc5781d8b14f79d1a22f91301df5196ae4
hasPrefWithUserID
public boolean hasPrefWithUserID(long userID)
{    return id == userID;}
aaac85cf768aa16aac7c3fd19dee90146fcc1536e3ea776cab5a42fbd920f94f
hasPrefWithItemID
public boolean hasPrefWithItemID(long itemID)
{    for (long id : ids) {        if (itemID == id) {            return true;        }    }    return false;}
91002b148e3cfdd8eb718b5448d892d6a6c1da39493b745ec460c136b0d25b98
clone
public BooleanUserPreferenceArray clone()
{    return new BooleanUserPreferenceArray(ids.clone(), id);}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return (int) (id >> 32) ^ (int) id ^ Arrays.hashCode(ids);}
74e378df448c6c3cd090d6daf881cfac8957dd555869ea4c13a46bdc6cdcf9a6
equals
public boolean equals(Object other)
{    if (!(other instanceof BooleanUserPreferenceArray)) {        return false;    }    BooleanUserPreferenceArray otherArray = (BooleanUserPreferenceArray) other;    return id == otherArray.id && Arrays.equals(ids, otherArray.ids);}
84f3f0fbeb10d1940e53d3aea07ad6c6c7e0fb1eb59e8409a6054e3511f33aac
iterator
public Iterator<Preference> iterator()
{    return Iterators.transform(new CountingIterator(length()), new Function<Integer, Preference>() {        @Override        public Preference apply(Integer from) {            return new PreferenceView(from);        }    });}
68b64de371d9fbb52a6c9a862f211df02e27c8ed77eb0dee4908b64bdebf9957
apply
public Preference apply(Integer from)
{    return new PreferenceView(from);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    StringBuilder result = new StringBuilder(10 * ids.length);    result.append("BooleanUserPreferenceArray[userID:");    result.append(id);    result.append(",{");    for (int i = 0; i < ids.length; i++) {        if (i > 0) {            result.append(',');        }        result.append(ids[i]);    }    result.append("}]");    return result.toString();}
f6291b447e197e279017739fa55cf012e1c9d4eed6fb9eb0dd5d639a28f5227d
getUserID
public long getUserID()
{    return BooleanUserPreferenceArray.this.getUserID(i);}
656666c3e1a83c6eb409c8bf7c3282b6209c6991806a5f70debc7368d69aec7d
getItemID
public long getItemID()
{    return BooleanUserPreferenceArray.this.getItemID(i);}
875eb4918e20f05856417a7a1eae0829852fb11067dcbf34f10f2a09bcacd7bb
getValue
public float getValue()
{    return 1.0f;}
5896e95811f7ac94f4c3a4e3945a78ab6985fcff4389fdaa89ff43765d6cfb72
setValue
public void setValue(float value)
{    throw new UnsupportedOperationException();}
97dafa154ff92ff584d5696d38c8bbe4278fc506ccd33c3a8a490611bf727b13
getDataFile
public File getDataFile()
{    return dataFile;}
10d7c03ff05328028908d407ee4c775675767e13b48e052e8327f609f01e3e8c
reload
protected void reload()
{    if (reloadLock.tryLock()) {        try {            delegate = buildModel();        } catch (IOException ioe) {            log.warn("Exception while reloading", ioe);        } finally {            reloadLock.unlock();        }    }}
6cd272f37cbc6f40176a4f5e91a93faae4c01ddcc7cfe3816654df6f9648a141
buildModel
protected DataModel buildModel() throws IOException
{    long newLastModified = dataFile.lastModified();    long newLastUpdateFileModified = readLastUpdateFileModified();    boolean loadFreshData = delegate == null || newLastModified > lastModified + minReloadIntervalMS;    long oldLastUpdateFileModifieid = lastUpdateFileModified;    lastModified = newLastModified;    lastUpdateFileModified = newLastUpdateFileModified;    FastByIDMap<FastByIDMap<Long>> timestamps = new FastByIDMap<>();    if (hasPrefValues) {        if (loadFreshData) {            FastByIDMap<Collection<Preference>> data = new FastByIDMap<>();            FileLineIterator iterator = new FileLineIterator(dataFile, false);            processFile(iterator, data, timestamps, false);            for (File updateFile : findUpdateFilesAfter(newLastModified)) {                processFile(new FileLineIterator(updateFile, false), data, timestamps, false);            }            return new GenericDataModel(GenericDataModel.toDataMap(data, true), timestamps);        } else {            FastByIDMap<PreferenceArray> rawData = ((GenericDataModel) delegate).getRawUserData();            for (File updateFile : findUpdateFilesAfter(Math.max(oldLastUpdateFileModifieid, newLastModified))) {                processFile(new FileLineIterator(updateFile, false), rawData, timestamps, true);            }            return new GenericDataModel(rawData, timestamps);        }    } else {        if (loadFreshData) {            FastByIDMap<FastIDSet> data = new FastByIDMap<>();            FileLineIterator iterator = new FileLineIterator(dataFile, false);            processFileWithoutID(iterator, data, timestamps);            for (File updateFile : findUpdateFilesAfter(newLastModified)) {                processFileWithoutID(new FileLineIterator(updateFile, false), data, timestamps);            }            return new GenericBooleanPrefDataModel(data, timestamps);        } else {            FastByIDMap<FastIDSet> rawData = ((GenericBooleanPrefDataModel) delegate).getRawUserData();            for (File updateFile : findUpdateFilesAfter(Math.max(oldLastUpdateFileModifieid, newLastModified))) {                processFileWithoutID(new FileLineIterator(updateFile, false), rawData, timestamps);            }            return new GenericBooleanPrefDataModel(rawData, timestamps);        }    }}
8449aa2798f0299d88db3090647559aee3b8336815ecc5d9d3a5a30b8f2c0110
findUpdateFilesAfter
private Iterable<File> findUpdateFilesAfter(long minimumLastModified)
{    String dataFileName = dataFile.getName();    int period = dataFileName.indexOf('.');    String startName = period < 0 ? dataFileName : dataFileName.substring(0, period);    File parentDir = dataFile.getParentFile();    Map<Long, File> modTimeToUpdateFile = new TreeMap<>();    FileFilter onlyFiles = new FileFilter() {        @Override        public boolean accept(File file) {            return !file.isDirectory();        }    };    for (File updateFile : parentDir.listFiles(onlyFiles)) {        String updateFileName = updateFile.getName();        if (updateFileName.startsWith(startName) && !updateFileName.equals(dataFileName) && updateFile.lastModified() >= minimumLastModified) {            modTimeToUpdateFile.put(updateFile.lastModified(), updateFile);        }    }    return modTimeToUpdateFile.values();}
975b5c3136fe2b3c1ff7856f034ee301dbadf35b9889ec6cf4172bb819cc343a
accept
public boolean accept(File file)
{    return !file.isDirectory();}
9a57c70f54b4608bc95d51888c145fadac7fc026ae95bd5d17185016f3846d68
readLastUpdateFileModified
private long readLastUpdateFileModified()
{    long mostRecentModification = Long.MIN_VALUE;    for (File updateFile : findUpdateFilesAfter(0L)) {        mostRecentModification = Math.max(mostRecentModification, updateFile.lastModified());    }    return mostRecentModification;}
fce41f422b5c04cf8286793870e4292533199bc6ad7094509e789e3f16848172
determineDelimiter
public static char determineDelimiter(String line)
{    for (char possibleDelimieter : DELIMIETERS) {        if (line.indexOf(possibleDelimieter) >= 0) {            return possibleDelimieter;        }    }    throw new IllegalArgumentException("Did not find a delimiter in first line");}
70878674f14aa8e45acf146989b28c359002b9c729ac2323402d0071363a7c6b
processFile
protected void processFile(FileLineIterator dataOrUpdateFileIterator, FastByIDMap<?> data, FastByIDMap<FastByIDMap<Long>> timestamps, boolean fromPriorData)
{    log.info("Reading file info...");    int count = 0;    while (dataOrUpdateFileIterator.hasNext()) {        String line = dataOrUpdateFileIterator.next();        if (!line.isEmpty()) {            processLine(line, data, timestamps, fromPriorData);            if (++count % 1000000 == 0) {                log.info("Processed {} lines", count);            }        }    }    log.info("Read lines: {}", count);}
874bedd6bf1d77dd1f745dff85e60ee15ea0b8b9960a6aadde2841490084192d
processLine
protected void processLine(String line, FastByIDMap<?> data, FastByIDMap<FastByIDMap<Long>> timestamps, boolean fromPriorData)
{        if (line.isEmpty() || line.charAt(0) == COMMENT_CHAR) {        return;    }    Iterator<String> tokens = delimiterPattern.split(line).iterator();    String userIDString = tokens.next();    String itemIDString = tokens.next();    String preferenceValueString = tokens.next();    boolean hasTimestamp = tokens.hasNext();    String timestampString = hasTimestamp ? tokens.next() : null;    long userID = readUserIDFromString(userIDString);    long itemID = readItemIDFromString(itemIDString);    if (transpose) {        long tmp = userID;        userID = itemID;        itemID = tmp;    }        Object maybePrefs = data.get(userID);    if (fromPriorData) {                PreferenceArray prefs = (PreferenceArray) maybePrefs;        if (!hasTimestamp && preferenceValueString.isEmpty()) {                        if (prefs != null) {                boolean exists = false;                int length = prefs.length();                for (int i = 0; i < length; i++) {                    if (prefs.getItemID(i) == itemID) {                        exists = true;                        break;                    }                }                if (exists) {                    if (length == 1) {                        data.remove(userID);                    } else {                        PreferenceArray newPrefs = new GenericUserPreferenceArray(length - 1);                        for (int i = 0, j = 0; i < length; i++, j++) {                            if (prefs.getItemID(i) == itemID) {                                j--;                            } else {                                newPrefs.set(j, prefs.get(i));                            }                        }                        ((FastByIDMap<PreferenceArray>) data).put(userID, newPrefs);                    }                }            }            removeTimestamp(userID, itemID, timestamps);        } else {            float preferenceValue = Float.parseFloat(preferenceValueString);            boolean exists = false;            if (prefs != null) {                for (int i = 0; i < prefs.length(); i++) {                    if (prefs.getItemID(i) == itemID) {                        exists = true;                        prefs.setValue(i, preferenceValue);                        break;                    }                }            }            if (!exists) {                if (prefs == null) {                    prefs = new GenericUserPreferenceArray(1);                } else {                    PreferenceArray newPrefs = new GenericUserPreferenceArray(prefs.length() + 1);                    for (int i = 0, j = 1; i < prefs.length(); i++, j++) {                        newPrefs.set(j, prefs.get(i));                    }                    prefs = newPrefs;                }                prefs.setUserID(0, userID);                prefs.setItemID(0, itemID);                prefs.setValue(0, preferenceValue);                ((FastByIDMap<PreferenceArray>) data).put(userID, prefs);            }        }        addTimestamp(userID, itemID, timestampString, timestamps);    } else {                Collection<Preference> prefs = (Collection<Preference>) maybePrefs;        if (!hasTimestamp && preferenceValueString.isEmpty()) {                        if (prefs != null) {                                Iterator<Preference> prefsIterator = prefs.iterator();                while (prefsIterator.hasNext()) {                    Preference pref = prefsIterator.next();                    if (pref.getItemID() == itemID) {                        prefsIterator.remove();                        break;                    }                }            }            removeTimestamp(userID, itemID, timestamps);        } else {            float preferenceValue = Float.parseFloat(preferenceValueString);            boolean exists = false;            if (prefs != null) {                for (Preference pref : prefs) {                    if (pref.getItemID() == itemID) {                        exists = true;                        pref.setValue(preferenceValue);                        break;                    }                }            }            if (!exists) {                if (prefs == null) {                    prefs = new ArrayList<>(2);                    ((FastByIDMap<Collection<Preference>>) data).put(userID, prefs);                }                prefs.add(new GenericPreference(userID, itemID, preferenceValue));            }            addTimestamp(userID, itemID, timestampString, timestamps);        }    }}
8036119387de053dd4a4a7eb05fcea526720832b684321a258c4087e7328d9f0
processFileWithoutID
protected void processFileWithoutID(FileLineIterator dataOrUpdateFileIterator, FastByIDMap<FastIDSet> data, FastByIDMap<FastByIDMap<Long>> timestamps)
{    log.info("Reading file info...");    int count = 0;    while (dataOrUpdateFileIterator.hasNext()) {        String line = dataOrUpdateFileIterator.next();        if (!line.isEmpty()) {            processLineWithoutID(line, data, timestamps);            if (++count % 100000 == 0) {                log.info("Processed {} lines", count);            }        }    }    log.info("Read lines: {}", count);}
b70b1e9523ce55fed42b90e5dc7ad41730c42f548f1563148eddf6b212e1f3d8
processLineWithoutID
protected void processLineWithoutID(String line, FastByIDMap<FastIDSet> data, FastByIDMap<FastByIDMap<Long>> timestamps)
{    if (line.isEmpty() || line.charAt(0) == COMMENT_CHAR) {        return;    }    Iterator<String> tokens = delimiterPattern.split(line).iterator();    String userIDString = tokens.next();    String itemIDString = tokens.next();    boolean hasPreference = tokens.hasNext();    String preferenceValueString = hasPreference ? tokens.next() : "";    boolean hasTimestamp = tokens.hasNext();    String timestampString = hasTimestamp ? tokens.next() : null;    long userID = readUserIDFromString(userIDString);    long itemID = readItemIDFromString(itemIDString);    if (transpose) {        long tmp = userID;        userID = itemID;        itemID = tmp;    }    if (hasPreference && !hasTimestamp && preferenceValueString.isEmpty()) {                FastIDSet itemIDs = data.get(userID);        if (itemIDs != null) {            itemIDs.remove(itemID);        }        removeTimestamp(userID, itemID, timestamps);    } else {        FastIDSet itemIDs = data.get(userID);        if (itemIDs == null) {            itemIDs = new FastIDSet(2);            data.put(userID, itemIDs);        }        itemIDs.add(itemID);        addTimestamp(userID, itemID, timestampString, timestamps);    }}
4c1b3a6e9b9f45ccbb9ae3813d04640d4e5e1fa3c9655a157db6eea73ddb7e9c
addTimestamp
private void addTimestamp(long userID, long itemID, String timestampString, FastByIDMap<FastByIDMap<Long>> timestamps)
{    if (timestampString != null) {        FastByIDMap<Long> itemTimestamps = timestamps.get(userID);        if (itemTimestamps == null) {            itemTimestamps = new FastByIDMap<>();            timestamps.put(userID, itemTimestamps);        }        long timestamp = readTimestampFromString(timestampString);        itemTimestamps.put(itemID, timestamp);    }}
19ccc1c18e984f77895a93e86784d817af3e98886f153abaa5b4fdfc4c3b8655
removeTimestamp
private static void removeTimestamp(long userID, long itemID, FastByIDMap<FastByIDMap<Long>> timestamps)
{    FastByIDMap<Long> itemTimestamps = timestamps.get(userID);    if (itemTimestamps != null) {        itemTimestamps.remove(itemID);    }}
8ff50f08951b9ae188ff13e1b8b06c03d80e4ca6752b2ad0852e7c6d9cdab6c4
readUserIDFromString
protected long readUserIDFromString(String value)
{    return Long.parseLong(value);}
b584047200d38097742b29825cf1b5e160ed1307fbf9ce1b107e63d61b6e56e8
readItemIDFromString
protected long readItemIDFromString(String value)
{    return Long.parseLong(value);}
e6d37c4e356867bcbe501741d0754faa53f7c3c44db27c12735c3ae4dc57d1c5
readTimestampFromString
protected long readTimestampFromString(String value)
{    return Long.parseLong(value);}
108a89a094b3a39b3b20cbd581561d4dd8b642f065690760ae153d36d980dcf0
getUserIDs
public LongPrimitiveIterator getUserIDs() throws TasteException
{    return delegate.getUserIDs();}
a06f75f56917fd636b983b7cfb0dd8060e1eb667d990c2ab0e2a39d33d94541d
getPreferencesFromUser
public PreferenceArray getPreferencesFromUser(long userID) throws TasteException
{    return delegate.getPreferencesFromUser(userID);}
ba6a53e86aa528831d7ca18f17bea6d3af21894eb8e11a57a1a779aa58bf6f42
getItemIDsFromUser
public FastIDSet getItemIDsFromUser(long userID) throws TasteException
{    return delegate.getItemIDsFromUser(userID);}
c388e3d4c09037f02ac5953d664aae3d2714c879c41346267284f3f30ad0a533
getItemIDs
public LongPrimitiveIterator getItemIDs() throws TasteException
{    return delegate.getItemIDs();}
be05dbd3948efc99ba2728f3fbfa2a5e8c9ebc9afdb1d8695cb8bf348212f432
getPreferencesForItem
public PreferenceArray getPreferencesForItem(long itemID) throws TasteException
{    return delegate.getPreferencesForItem(itemID);}
4a797ada65a2ab5d778b75e04ac2b1252411b11fa907fd98679888cf05ffb484
getPreferenceValue
public Float getPreferenceValue(long userID, long itemID) throws TasteException
{    return delegate.getPreferenceValue(userID, itemID);}
0857731203f906c58b60e4e747203723db701723c05fe7896e7f325ffa539bdc
getPreferenceTime
public Long getPreferenceTime(long userID, long itemID) throws TasteException
{    return delegate.getPreferenceTime(userID, itemID);}
0e5cfb4e0e4f9d1a7b8c16082ab928c9562f8fb336a58c94de25d6df00236f93
getNumItems
public int getNumItems() throws TasteException
{    return delegate.getNumItems();}
c52287e7598bb24d77044373ddfeaf97ff2c29583e729316fa8fb9bef78133a1
getNumUsers
public int getNumUsers() throws TasteException
{    return delegate.getNumUsers();}
0ea40759843b60bfb2d618774fa6b7fede865d83651c9e9fe817822760d18483
getNumUsersWithPreferenceFor
public int getNumUsersWithPreferenceFor(long itemID) throws TasteException
{    return delegate.getNumUsersWithPreferenceFor(itemID);}
6d019eca3996fc5fdfb1030e07ee927128888b79b32683dd1b2041baeaf53a4b
getNumUsersWithPreferenceFor
public int getNumUsersWithPreferenceFor(long itemID1, long itemID2) throws TasteException
{    return delegate.getNumUsersWithPreferenceFor(itemID1, itemID2);}
50d76af25ae801a2139a90c576940f9f9838c80f93853951415d27753efe6193
setPreference
public void setPreference(long userID, long itemID, float value) throws TasteException
{    delegate.setPreference(userID, itemID, value);}
b8fc0c1b44ecc54ed269a5d79a52cada03c7abb05284d3d33b03ade9d9a86320
removePreference
public void removePreference(long userID, long itemID) throws TasteException
{    delegate.removePreference(userID, itemID);}
da77e35d28c590f4b271e5b2b7f639c465574b8f17a1ef2f1df63e0152c57e8b
refresh
public void refresh(Collection<Refreshable> alreadyRefreshed)
{    if (dataFile.lastModified() > lastModified + minReloadIntervalMS || readLastUpdateFileModified() > lastUpdateFileModified + minReloadIntervalMS) {        log.debug("File has changed; reloading...");        reload();    }}
5fe6ef45f2c8e613067bc79bf61b3f21f1aac63aa04e14a47b4f8203cebb79f9
hasPreferenceValues
public boolean hasPreferenceValues()
{    return delegate.hasPreferenceValues();}
13925bef8afa2e6d068d08c72262016e42e3d5fe30ac04c85c78f8b0f99c4ceb
getMaxPreference
public float getMaxPreference()
{    return delegate.getMaxPreference();}
886c9fcd0006e44aa20de41c56cd99e5659dc842b2fd94840da5c661f1bccb0a
getMinPreference
public float getMinPreference()
{    return delegate.getMinPreference();}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "FileDataModel[dataFile:" + dataFile + ']';}
2b749255173a63c30b54840cd322c48a1c8ef3483eeaae1bccbadacd451c3148
toStringID
public String toStringID(long longID)
{    return longToString.get(longID);}
42f72cb96a87c95a4290cf6b5dae4502552fd53a5795405aba8812d4f1727187
reload
private void reload()
{    if (reloadLock.tryLock()) {        try {            longToString = buildMapping();        } catch (IOException ioe) {            throw new IllegalStateException(ioe);        } finally {            reloadLock.unlock();        }    }}
cfdc98916bc71ec8def6c1b03fbd1742258d3fd101b9122945a8d2ea775af687
buildMapping
private FastByIDMap<String> buildMapping() throws IOException
{    FastByIDMap<String> mapping = new FastByIDMap<>();    for (String line : new FileLineIterable(dataFile)) {        mapping.put(toLongID(line), line);    }    lastModified = dataFile.lastModified();    return mapping;}
da77e35d28c590f4b271e5b2b7f639c465574b8f17a1ef2f1df63e0152c57e8b
refresh
public void refresh(Collection<Refreshable> alreadyRefreshed)
{    if (dataFile.lastModified() > lastModified + minReloadIntervalMS) {        log.debug("File has changed; reloading...");        reload();    }}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "FileIDMigrator[dataFile:" + dataFile + ']';}
7e89e80e1b1e022927b603196abeb115d9de0d630fd3f12a05f34b6511831e75
toDataMap
public static FastByIDMap<FastIDSet> toDataMap(DataModel dataModel) throws TasteException
{    FastByIDMap<FastIDSet> data = new FastByIDMap<>(dataModel.getNumUsers());    LongPrimitiveIterator it = dataModel.getUserIDs();    while (it.hasNext()) {        long userID = it.nextLong();        data.put(userID, dataModel.getItemIDsFromUser(userID));    }    return data;}
ee63ef17597926ea4abd23e77c04a4aa4d9ba4653b15eeaaacbc4eb5b89dc970
toDataMap
public static FastByIDMap<FastIDSet> toDataMap(FastByIDMap<PreferenceArray> data)
{    for (Map.Entry<Long, Object> entry : ((FastByIDMap<Object>) (FastByIDMap<?>) data).entrySet()) {        PreferenceArray prefArray = (PreferenceArray) entry.getValue();        int size = prefArray.length();        FastIDSet itemIDs = new FastIDSet(size);        for (int i = 0; i < size; i++) {            itemIDs.add(prefArray.getItemID(i));        }        entry.setValue(itemIDs);    }    return (FastByIDMap<FastIDSet>) (FastByIDMap<?>) data;}
a0e45dbb337ebab097296a7364ecc5efe8e6d97c9e84828e44eb1f52c681809a
getRawUserData
public FastByIDMap<FastIDSet> getRawUserData()
{    return this.preferenceFromUsers;}
d2b7ea548ca76229549b9fa051f94cf8780855b5e06e4b44ea131790f360ff81
getRawItemData
public FastByIDMap<FastIDSet> getRawItemData()
{    return this.preferenceForItems;}
466684a2be502d3325eb27a6d175210ebbd1764bffad8a99ff9ef30d46d1c765
getUserIDs
public LongPrimitiveArrayIterator getUserIDs()
{    return new LongPrimitiveArrayIterator(userIDs);}
a57992496bf0547c0b6d42d3b79f5ade91eb12298be296d60be4ed9cc8fe9652
getPreferencesFromUser
public PreferenceArray getPreferencesFromUser(long userID) throws NoSuchUserException
{    FastIDSet itemIDs = preferenceFromUsers.get(userID);    if (itemIDs == null) {        throw new NoSuchUserException(userID);    }    PreferenceArray prefArray = new BooleanUserPreferenceArray(itemIDs.size());    int i = 0;    LongPrimitiveIterator it = itemIDs.iterator();    while (it.hasNext()) {        prefArray.setUserID(i, userID);        prefArray.setItemID(i, it.nextLong());        i++;    }    return prefArray;}
ba6a53e86aa528831d7ca18f17bea6d3af21894eb8e11a57a1a779aa58bf6f42
getItemIDsFromUser
public FastIDSet getItemIDsFromUser(long userID) throws TasteException
{    FastIDSet itemIDs = preferenceFromUsers.get(userID);    if (itemIDs == null) {        throw new NoSuchUserException(userID);    }    return itemIDs;}
b46cbdc78cf2125550a38bfcb78c599e9373bbeb405bd1ffc86ed7f2954b74ca
getItemIDs
public LongPrimitiveArrayIterator getItemIDs()
{    return new LongPrimitiveArrayIterator(itemIDs);}
71fb1da8e0ede316d1f1fb883700364293fe6d4ab616d9fd2511d34c96e5c2fc
getPreferencesForItem
public PreferenceArray getPreferencesForItem(long itemID) throws NoSuchItemException
{    FastIDSet userIDs = preferenceForItems.get(itemID);    if (userIDs == null) {        throw new NoSuchItemException(itemID);    }    PreferenceArray prefArray = new BooleanItemPreferenceArray(userIDs.size());    int i = 0;    LongPrimitiveIterator it = userIDs.iterator();    while (it.hasNext()) {        prefArray.setUserID(i, it.nextLong());        prefArray.setItemID(i, itemID);        i++;    }    return prefArray;}
5e84b3b21e75cba69369211fdca789f4b74ec505fad9b6123c1eb21e509b209d
getPreferenceValue
public Float getPreferenceValue(long userID, long itemID) throws NoSuchUserException
{    FastIDSet itemIDs = preferenceFromUsers.get(userID);    if (itemIDs == null) {        throw new NoSuchUserException(userID);    }    if (itemIDs.contains(itemID)) {        return 1.0f;    }    return null;}
0857731203f906c58b60e4e747203723db701723c05fe7896e7f325ffa539bdc
getPreferenceTime
public Long getPreferenceTime(long userID, long itemID) throws TasteException
{    if (timestamps == null) {        return null;    }    FastByIDMap<Long> itemTimestamps = timestamps.get(userID);    if (itemTimestamps == null) {        throw new NoSuchUserException(userID);    }    return itemTimestamps.get(itemID);}
ca32314ab0b342e57598ab3e548f0dc7ccfe40dcab80bb42fe96111529c7fb2a
getNumItems
public int getNumItems()
{    return itemIDs.length;}
8c2658ffed5040b43a4b2253eec7730bcf9b36ab3c497554d321de1d7183a69c
getNumUsers
public int getNumUsers()
{    return userIDs.length;}
b8237832ceeeb113ecd722aa0bf2c09b1d306209503a7f79e33d3669b691ffe1
getNumUsersWithPreferenceFor
public int getNumUsersWithPreferenceFor(long itemID)
{    FastIDSet userIDs1 = preferenceForItems.get(itemID);    return userIDs1 == null ? 0 : userIDs1.size();}
3bea6cf948d5caad04ad26faf74b2da6a560920f5a062e553916c79a5a311783
getNumUsersWithPreferenceFor
public int getNumUsersWithPreferenceFor(long itemID1, long itemID2)
{    FastIDSet userIDs1 = preferenceForItems.get(itemID1);    if (userIDs1 == null) {        return 0;    }    FastIDSet userIDs2 = preferenceForItems.get(itemID2);    if (userIDs2 == null) {        return 0;    }    return userIDs1.size() < userIDs2.size() ? userIDs2.intersectionSize(userIDs1) : userIDs1.intersectionSize(userIDs2);}
7c2a92c2965e7e4ad97dde62c44d10be870d3da3b51da08551dd332ef4630ce5
removePreference
public void removePreference(long userID, long itemID)
{    throw new UnsupportedOperationException();}
479384395af79d778425896c46ecace2f63d7b050dc41d329f4a049b680177bb
setPreference
public void setPreference(long userID, long itemID, float value)
{    throw new UnsupportedOperationException();}
da77e35d28c590f4b271e5b2b7f639c465574b8f17a1ef2f1df63e0152c57e8b
refresh
public void refresh(Collection<Refreshable> alreadyRefreshed)
{}
5fe6ef45f2c8e613067bc79bf61b3f21f1aac63aa04e14a47b4f8203cebb79f9
hasPreferenceValues
public boolean hasPreferenceValues()
{    return false;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    StringBuilder result = new StringBuilder(200);    result.append("GenericBooleanPrefDataModel[users:");    for (int i = 0; i < Math.min(3, userIDs.length); i++) {        if (i > 0) {            result.append(',');        }        result.append(userIDs[i]);    }    if (userIDs.length > 3) {        result.append("...");    }    result.append(']');    return result.toString();}
1da03d8927e7606c489e91619834c60100dd24aab856d0471e586314bd0bb2e8
toDataMap
public static FastByIDMap<PreferenceArray> toDataMap(FastByIDMap<Collection<Preference>> data, boolean byUser)
{    for (Map.Entry<Long, Object> entry : ((FastByIDMap<Object>) (FastByIDMap<?>) data).entrySet()) {        List<Preference> prefList = (List<Preference>) entry.getValue();        entry.setValue(byUser ? new GenericUserPreferenceArray(prefList) : new GenericItemPreferenceArray(prefList));    }    return (FastByIDMap<PreferenceArray>) (FastByIDMap<?>) data;}
d44b60e709a04cdebf1604baa3580cf01ca5d2e4bd10e553360703578789c135
toDataMap
public static FastByIDMap<PreferenceArray> toDataMap(DataModel dataModel) throws TasteException
{    FastByIDMap<PreferenceArray> data = new FastByIDMap<>(dataModel.getNumUsers());    LongPrimitiveIterator it = dataModel.getUserIDs();    while (it.hasNext()) {        long userID = it.nextLong();        data.put(userID, dataModel.getPreferencesFromUser(userID));    }    return data;}
5199f3b61e516fb9ceab688bacd4e973cab797661e6720d4f5559c21da7886e4
getRawUserData
public FastByIDMap<PreferenceArray> getRawUserData()
{    return this.preferenceFromUsers;}
78794662226f58f4167fef92a5cb6d60ff88b51b314a39c2bac2150b2ba1559b
getRawItemData
public FastByIDMap<PreferenceArray> getRawItemData()
{    return this.preferenceForItems;}
466684a2be502d3325eb27a6d175210ebbd1764bffad8a99ff9ef30d46d1c765
getUserIDs
public LongPrimitiveArrayIterator getUserIDs()
{    return new LongPrimitiveArrayIterator(userIDs);}
a57992496bf0547c0b6d42d3b79f5ade91eb12298be296d60be4ed9cc8fe9652
getPreferencesFromUser
public PreferenceArray getPreferencesFromUser(long userID) throws NoSuchUserException
{    PreferenceArray prefs = preferenceFromUsers.get(userID);    if (prefs == null) {        throw new NoSuchUserException(userID);    }    return prefs;}
ba6a53e86aa528831d7ca18f17bea6d3af21894eb8e11a57a1a779aa58bf6f42
getItemIDsFromUser
public FastIDSet getItemIDsFromUser(long userID) throws TasteException
{    PreferenceArray prefs = getPreferencesFromUser(userID);    int size = prefs.length();    FastIDSet result = new FastIDSet(size);    for (int i = 0; i < size; i++) {        result.add(prefs.getItemID(i));    }    return result;}
b46cbdc78cf2125550a38bfcb78c599e9373bbeb405bd1ffc86ed7f2954b74ca
getItemIDs
public LongPrimitiveArrayIterator getItemIDs()
{    return new LongPrimitiveArrayIterator(itemIDs);}
71fb1da8e0ede316d1f1fb883700364293fe6d4ab616d9fd2511d34c96e5c2fc
getPreferencesForItem
public PreferenceArray getPreferencesForItem(long itemID) throws NoSuchItemException
{    PreferenceArray prefs = preferenceForItems.get(itemID);    if (prefs == null) {        throw new NoSuchItemException(itemID);    }    return prefs;}
4a797ada65a2ab5d778b75e04ac2b1252411b11fa907fd98679888cf05ffb484
getPreferenceValue
public Float getPreferenceValue(long userID, long itemID) throws TasteException
{    PreferenceArray prefs = getPreferencesFromUser(userID);    int size = prefs.length();    for (int i = 0; i < size; i++) {        if (prefs.getItemID(i) == itemID) {            return prefs.getValue(i);        }    }    return null;}
0857731203f906c58b60e4e747203723db701723c05fe7896e7f325ffa539bdc
getPreferenceTime
public Long getPreferenceTime(long userID, long itemID) throws TasteException
{    if (timestamps == null) {        return null;    }    FastByIDMap<Long> itemTimestamps = timestamps.get(userID);    if (itemTimestamps == null) {        throw new NoSuchUserException(userID);    }    return itemTimestamps.get(itemID);}
ca32314ab0b342e57598ab3e548f0dc7ccfe40dcab80bb42fe96111529c7fb2a
getNumItems
public int getNumItems()
{    return itemIDs.length;}
8c2658ffed5040b43a4b2253eec7730bcf9b36ab3c497554d321de1d7183a69c
getNumUsers
public int getNumUsers()
{    return userIDs.length;}
b8237832ceeeb113ecd722aa0bf2c09b1d306209503a7f79e33d3669b691ffe1
getNumUsersWithPreferenceFor
public int getNumUsersWithPreferenceFor(long itemID)
{    PreferenceArray prefs1 = preferenceForItems.get(itemID);    return prefs1 == null ? 0 : prefs1.length();}
3bea6cf948d5caad04ad26faf74b2da6a560920f5a062e553916c79a5a311783
getNumUsersWithPreferenceFor
public int getNumUsersWithPreferenceFor(long itemID1, long itemID2)
{    PreferenceArray prefs1 = preferenceForItems.get(itemID1);    if (prefs1 == null) {        return 0;    }    PreferenceArray prefs2 = preferenceForItems.get(itemID2);    if (prefs2 == null) {        return 0;    }    int size1 = prefs1.length();    int size2 = prefs2.length();    int count = 0;    int i = 0;    int j = 0;    long userID1 = prefs1.getUserID(0);    long userID2 = prefs2.getUserID(0);    while (true) {        if (userID1 < userID2) {            if (++i == size1) {                break;            }            userID1 = prefs1.getUserID(i);        } else if (userID1 > userID2) {            if (++j == size2) {                break;            }            userID2 = prefs2.getUserID(j);        } else {            count++;            if (++i == size1 || ++j == size2) {                break;            }            userID1 = prefs1.getUserID(i);            userID2 = prefs2.getUserID(j);        }    }    return count;}
7c2a92c2965e7e4ad97dde62c44d10be870d3da3b51da08551dd332ef4630ce5
removePreference
public void removePreference(long userID, long itemID)
{    throw new UnsupportedOperationException();}
479384395af79d778425896c46ecace2f63d7b050dc41d329f4a049b680177bb
setPreference
public void setPreference(long userID, long itemID, float value)
{    throw new UnsupportedOperationException();}
da77e35d28c590f4b271e5b2b7f639c465574b8f17a1ef2f1df63e0152c57e8b
refresh
public void refresh(Collection<Refreshable> alreadyRefreshed)
{}
5fe6ef45f2c8e613067bc79bf61b3f21f1aac63aa04e14a47b4f8203cebb79f9
hasPreferenceValues
public boolean hasPreferenceValues()
{    return true;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    StringBuilder result = new StringBuilder(200);    result.append("GenericDataModel[users:");    for (int i = 0; i < Math.min(3, userIDs.length); i++) {        if (i > 0) {            result.append(',');        }        result.append(userIDs[i]);    }    if (userIDs.length > 3) {        result.append("...");    }    result.append(']');    return result.toString();}
1d1ebdb99c526da23d9a06ed6c089d39abc457289b7aff9cbe5f58a377b283b2
length
public int length()
{    return ids.length;}
1466676badc459d75b4519e8418977e534b8541086db5c066b3452edeec1c2f9
get
public Preference get(int i)
{    return new PreferenceView(i);}
368e5519512976376b6b04e8218aa4d66b71c67ed6b26c23975f993ce77d38e2
set
public void set(int i, Preference pref)
{    id = pref.getItemID();    ids[i] = pref.getUserID();    values[i] = pref.getValue();}
0ffb4eed09bcc129b36f0e2e4b2212eab0439f3abc3cd38cc98f0035f0397f28
getUserID
public long getUserID(int i)
{    return ids[i];}
6bb0d8e838c77f4a70a90a3e5cd97eb6fb385b2e6cb50b1ccc25c3963a30e695
setUserID
public void setUserID(int i, long userID)
{    ids[i] = userID;}
5a186538180ac1e47c6d0d5ff6db74eca8d34a4f865110b9b8aed3ee7f8be3cc
getItemID
public long getItemID(int i)
{    return id;}
6ac0df5eb6c901535e9bd0261b5cab5099adc231332153a1c1ea399fecc51b9d
setItemID
public void setItemID(int i, long itemID)
{    id = itemID;}
54a843b431ac7e6f36be07f1d1e47eafa5901821a87b3f882508159e9ee1c1c6
getIDs
public long[] getIDs()
{    return ids;}
fad752eb18ffea7f1dbf59412e26569cbe114ae5efff5a43de301dca4a3791da
getValue
public float getValue(int i)
{    return values[i];}
d2049c279705133416ffe7af822246d72d94b1e99f0ab3f5dc4c5d24f7dd9dbc
setValue
public void setValue(int i, float value)
{    values[i] = value;}
a57bb2ae7c30b6e0e2f09e71b8c0db815e76ceef14698603162b1bf7469c33e6
sortByUser
public void sortByUser()
{    lateralSort(USER);}
6a5491706e8493e6c6f00c5e92d4a6d8ace4834d0f3740d344ee16d52fa35788
sortByItem
public void sortByItem()
{}
048d292b512e9212b9e70289eca1bb87d22601878d09992501cb933143fec1ab
sortByValue
public void sortByValue()
{    lateralSort(VALUE);}
e0b5443d0f881fcdbf7e925010c63b245490d0756141727a6ec6bf5cee688545
sortByValueReversed
public void sortByValueReversed()
{    lateralSort(VALUE_REVERSED);}
2eafb849f39af4dfa2b7676d8e4c51dc5781d8b14f79d1a22f91301df5196ae4
hasPrefWithUserID
public boolean hasPrefWithUserID(long userID)
{    for (long id : ids) {        if (userID == id) {            return true;        }    }    return false;}
aaac85cf768aa16aac7c3fd19dee90146fcc1536e3ea776cab5a42fbd920f94f
hasPrefWithItemID
public boolean hasPrefWithItemID(long itemID)
{    return id == itemID;}
be20eb5b52671727a508bd657b109aad353f04077f8a958d740ceef5af2d0be5
lateralSort
private void lateralSort(int type)
{        int length = length();    int gap = length;    boolean swapped = false;    while (gap > 1 || swapped) {        if (gap > 1) {                        gap /= 1.247330950103979;        }        swapped = false;        int max = length - gap;        for (int i = 0; i < max; i++) {            int other = i + gap;            if (isLess(other, i, type)) {                swap(i, other);                swapped = true;            }        }    }}
237bf485c3f6d5ea60064ceb1089285aea8d35654692e0a4e19a4abbf23d924a
isLess
private boolean isLess(int i, int j, int type)
{    switch(type) {        case USER:            return ids[i] < ids[j];        case VALUE:            return values[i] < values[j];        case VALUE_REVERSED:            return values[i] > values[j];        default:            throw new IllegalStateException();    }}
d2be5e1fd8f759e8c512d601afc43bc170177da8c04e443352f5ddac8dfc4778
swap
private void swap(int i, int j)
{    long temp1 = ids[i];    float temp2 = values[i];    ids[i] = ids[j];    values[i] = values[j];    ids[j] = temp1;    values[j] = temp2;}
d37656f2072817489add7841623367f41cc8b842d5158e31574ec53e212472a7
clone
public GenericItemPreferenceArray clone()
{    return new GenericItemPreferenceArray(ids.clone(), id, values.clone());}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return (int) (id >> 32) ^ (int) id ^ Arrays.hashCode(ids) ^ Arrays.hashCode(values);}
74e378df448c6c3cd090d6daf881cfac8957dd555869ea4c13a46bdc6cdcf9a6
equals
public boolean equals(Object other)
{    if (!(other instanceof GenericItemPreferenceArray)) {        return false;    }    GenericItemPreferenceArray otherArray = (GenericItemPreferenceArray) other;    return id == otherArray.id && Arrays.equals(ids, otherArray.ids) && Arrays.equals(values, otherArray.values);}
84f3f0fbeb10d1940e53d3aea07ad6c6c7e0fb1eb59e8409a6054e3511f33aac
iterator
public Iterator<Preference> iterator()
{    return Iterators.transform(new CountingIterator(length()), new Function<Integer, Preference>() {        @Override        public Preference apply(Integer from) {            return new PreferenceView(from);        }    });}
68b64de371d9fbb52a6c9a862f211df02e27c8ed77eb0dee4908b64bdebf9957
apply
public Preference apply(Integer from)
{    return new PreferenceView(from);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    if (ids == null || ids.length == 0) {        return "GenericItemPreferenceArray[{}]";    }    StringBuilder result = new StringBuilder(20 * ids.length);    result.append("GenericItemPreferenceArray[itemID:");    result.append(id);    result.append(",{");    for (int i = 0; i < ids.length; i++) {        if (i > 0) {            result.append(',');        }        result.append(ids[i]);        result.append('=');        result.append(values[i]);    }    result.append("}]");    return result.toString();}
f6291b447e197e279017739fa55cf012e1c9d4eed6fb9eb0dd5d639a28f5227d
getUserID
public long getUserID()
{    return GenericItemPreferenceArray.this.getUserID(i);}
656666c3e1a83c6eb409c8bf7c3282b6209c6991806a5f70debc7368d69aec7d
getItemID
public long getItemID()
{    return GenericItemPreferenceArray.this.getItemID(i);}
875eb4918e20f05856417a7a1eae0829852fb11067dcbf34f10f2a09bcacd7bb
getValue
public float getValue()
{    return values[i];}
5896e95811f7ac94f4c3a4e3945a78ab6985fcff4389fdaa89ff43765d6cfb72
setValue
public void setValue(float value)
{    values[i] = value;}
f6291b447e197e279017739fa55cf012e1c9d4eed6fb9eb0dd5d639a28f5227d
getUserID
public long getUserID()
{    return userID;}
656666c3e1a83c6eb409c8bf7c3282b6209c6991806a5f70debc7368d69aec7d
getItemID
public long getItemID()
{    return itemID;}
875eb4918e20f05856417a7a1eae0829852fb11067dcbf34f10f2a09bcacd7bb
getValue
public float getValue()
{    return value;}
5896e95811f7ac94f4c3a4e3945a78ab6985fcff4389fdaa89ff43765d6cfb72
setValue
public void setValue(float value)
{    Preconditions.checkArgument(!Float.isNaN(value), "NaN value");    this.value = value;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "GenericPreference[userID: " + userID + ", itemID:" + itemID + ", value:" + value + ']';}
1d1ebdb99c526da23d9a06ed6c089d39abc457289b7aff9cbe5f58a377b283b2
length
public int length()
{    return ids.length;}
1466676badc459d75b4519e8418977e534b8541086db5c066b3452edeec1c2f9
get
public Preference get(int i)
{    return new PreferenceView(i);}
368e5519512976376b6b04e8218aa4d66b71c67ed6b26c23975f993ce77d38e2
set
public void set(int i, Preference pref)
{    id = pref.getUserID();    ids[i] = pref.getItemID();    values[i] = pref.getValue();}
0ffb4eed09bcc129b36f0e2e4b2212eab0439f3abc3cd38cc98f0035f0397f28
getUserID
public long getUserID(int i)
{    return id;}
6bb0d8e838c77f4a70a90a3e5cd97eb6fb385b2e6cb50b1ccc25c3963a30e695
setUserID
public void setUserID(int i, long userID)
{    id = userID;}
5a186538180ac1e47c6d0d5ff6db74eca8d34a4f865110b9b8aed3ee7f8be3cc
getItemID
public long getItemID(int i)
{    return ids[i];}
6ac0df5eb6c901535e9bd0261b5cab5099adc231332153a1c1ea399fecc51b9d
setItemID
public void setItemID(int i, long itemID)
{    ids[i] = itemID;}
54a843b431ac7e6f36be07f1d1e47eafa5901821a87b3f882508159e9ee1c1c6
getIDs
public long[] getIDs()
{    return ids;}
fad752eb18ffea7f1dbf59412e26569cbe114ae5efff5a43de301dca4a3791da
getValue
public float getValue(int i)
{    return values[i];}
d2049c279705133416ffe7af822246d72d94b1e99f0ab3f5dc4c5d24f7dd9dbc
setValue
public void setValue(int i, float value)
{    values[i] = value;}
a57bb2ae7c30b6e0e2f09e71b8c0db815e76ceef14698603162b1bf7469c33e6
sortByUser
public void sortByUser()
{}
6a5491706e8493e6c6f00c5e92d4a6d8ace4834d0f3740d344ee16d52fa35788
sortByItem
public void sortByItem()
{    lateralSort(ITEM);}
048d292b512e9212b9e70289eca1bb87d22601878d09992501cb933143fec1ab
sortByValue
public void sortByValue()
{    lateralSort(VALUE);}
e0b5443d0f881fcdbf7e925010c63b245490d0756141727a6ec6bf5cee688545
sortByValueReversed
public void sortByValueReversed()
{    lateralSort(VALUE_REVERSED);}
2eafb849f39af4dfa2b7676d8e4c51dc5781d8b14f79d1a22f91301df5196ae4
hasPrefWithUserID
public boolean hasPrefWithUserID(long userID)
{    return id == userID;}
aaac85cf768aa16aac7c3fd19dee90146fcc1536e3ea776cab5a42fbd920f94f
hasPrefWithItemID
public boolean hasPrefWithItemID(long itemID)
{    for (long id : ids) {        if (itemID == id) {            return true;        }    }    return false;}
be20eb5b52671727a508bd657b109aad353f04077f8a958d740ceef5af2d0be5
lateralSort
private void lateralSort(int type)
{        int length = length();    int gap = length;    boolean swapped = false;    while (gap > 1 || swapped) {        if (gap > 1) {                        gap /= 1.247330950103979;        }        swapped = false;        int max = length - gap;        for (int i = 0; i < max; i++) {            int other = i + gap;            if (isLess(other, i, type)) {                swap(i, other);                swapped = true;            }        }    }}
237bf485c3f6d5ea60064ceb1089285aea8d35654692e0a4e19a4abbf23d924a
isLess
private boolean isLess(int i, int j, int type)
{    switch(type) {        case ITEM:            return ids[i] < ids[j];        case VALUE:            return values[i] < values[j];        case VALUE_REVERSED:            return values[i] > values[j];        default:            throw new IllegalStateException();    }}
d2be5e1fd8f759e8c512d601afc43bc170177da8c04e443352f5ddac8dfc4778
swap
private void swap(int i, int j)
{    long temp1 = ids[i];    float temp2 = values[i];    ids[i] = ids[j];    values[i] = values[j];    ids[j] = temp1;    values[j] = temp2;}
e82224cafc1962e8cc716be784fda3417de114644a410973a38e69f045332163
clone
public GenericUserPreferenceArray clone()
{    return new GenericUserPreferenceArray(ids.clone(), id, values.clone());}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return (int) (id >> 32) ^ (int) id ^ Arrays.hashCode(ids) ^ Arrays.hashCode(values);}
74e378df448c6c3cd090d6daf881cfac8957dd555869ea4c13a46bdc6cdcf9a6
equals
public boolean equals(Object other)
{    if (!(other instanceof GenericUserPreferenceArray)) {        return false;    }    GenericUserPreferenceArray otherArray = (GenericUserPreferenceArray) other;    return id == otherArray.id && Arrays.equals(ids, otherArray.ids) && Arrays.equals(values, otherArray.values);}
84f3f0fbeb10d1940e53d3aea07ad6c6c7e0fb1eb59e8409a6054e3511f33aac
iterator
public Iterator<Preference> iterator()
{    return Iterators.transform(new CountingIterator(length()), new Function<Integer, Preference>() {        @Override        public Preference apply(Integer from) {            return new PreferenceView(from);        }    });}
68b64de371d9fbb52a6c9a862f211df02e27c8ed77eb0dee4908b64bdebf9957
apply
public Preference apply(Integer from)
{    return new PreferenceView(from);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    if (ids == null || ids.length == 0) {        return "GenericUserPreferenceArray[{}]";    }    StringBuilder result = new StringBuilder(20 * ids.length);    result.append("GenericUserPreferenceArray[userID:");    result.append(id);    result.append(",{");    for (int i = 0; i < ids.length; i++) {        if (i > 0) {            result.append(',');        }        result.append(ids[i]);        result.append('=');        result.append(values[i]);    }    result.append("}]");    return result.toString();}
f6291b447e197e279017739fa55cf012e1c9d4eed6fb9eb0dd5d639a28f5227d
getUserID
public long getUserID()
{    return GenericUserPreferenceArray.this.getUserID(i);}
656666c3e1a83c6eb409c8bf7c3282b6209c6991806a5f70debc7368d69aec7d
getItemID
public long getItemID()
{    return GenericUserPreferenceArray.this.getItemID(i);}
875eb4918e20f05856417a7a1eae0829852fb11067dcbf34f10f2a09bcacd7bb
getValue
public float getValue()
{    return values[i];}
5896e95811f7ac94f4c3a4e3945a78ab6985fcff4389fdaa89ff43765d6cfb72
setValue
public void setValue(float value)
{    values[i] = value;}
a972b1b74cedf07bc649dfd946fa99051b7120406d18ed7991cdb3197985f7bd
storeMapping
public void storeMapping(long longID, String stringID)
{    synchronized (longToString) {        longToString.put(longID, stringID);    }}
2b749255173a63c30b54840cd322c48a1c8ef3483eeaae1bccbadacd451c3148
toStringID
public String toStringID(long longID)
{    synchronized (longToString) {        return longToString.get(longID);    }}
f757622ba79a2c6ab7beab6ba7b84bdd182d69f23bc702bdc892ad38bce75cba
initialize
public void initialize(Iterable<String> stringIDs)
{    for (String stringID : stringIDs) {        storeMapping(toLongID(stringID), stringID);    }}
f1fafa540f50f1b5dff2f6850f19c2887265cb7ccbc1a72e941090aac7eee83d
initializeUsersPools
private void initializeUsersPools(int usersPoolSize)
{    usersPool = new ConcurrentLinkedQueue<>();    for (int i = 0; i < usersPoolSize; i++) {        usersPool.add(TEMP_USER_ID + i);    }}
659c89fa8dcf47d09fc87db373467d160692b3c017a031af9995fbd2b1897ec5
takeAvailableUser
public Long takeAvailableUser()
{    Long takenUserID = usersPool.poll();    if (takenUserID != null) {                tempPrefs.put(takenUserID, new GenericUserPreferenceArray(0));        return takenUserID;    }    return null;}
2efbf5f616f8b475ff66e8901320d04723826bc6eedf8f156c8de48b2bcbdff5
releaseUser
public boolean releaseUser(Long userID)
{    if (tempPrefs.containsKey(userID)) {        this.clearTempPrefs(userID);                usersPool.offer(userID);        return true;    }    return false;}
cd33ef4a30c2b0022ba5c1de54fd98787371aa4ba545779a74652d62fb261320
isAnonymousUser
private boolean isAnonymousUser(long userID)
{    return tempPrefs.containsKey(userID);}
1d3ffbf97accc13768a17fb7507d2648209cda12499d6a4c02ee4d72faab2423
setTempPrefs
public void setTempPrefs(PreferenceArray prefs, long anonymousUserID)
{    Preconditions.checkArgument(prefs != null && prefs.length() > 0, "prefs is null or empty");    this.tempPrefs.put(anonymousUserID, prefs);    FastIDSet userPrefItemIDs = new FastIDSet();    for (int i = 0; i < prefs.length(); i++) {        userPrefItemIDs.add(prefs.getItemID(i));    }    this.prefItemIDs.put(anonymousUserID, userPrefItemIDs);}
6200bbc0075dff56f643454d96b83bd4ef1be56a2662eaf9f4dda7e8a398c8fa
clearTempPrefs
public void clearTempPrefs(long anonymousUserID)
{    this.tempPrefs.remove(anonymousUserID);    this.prefItemIDs.remove(anonymousUserID);}
108a89a094b3a39b3b20cbd581561d4dd8b642f065690760ae153d36d980dcf0
getUserIDs
public LongPrimitiveIterator getUserIDs() throws TasteException
{        return getDelegate().getUserIDs();}
a06f75f56917fd636b983b7cfb0dd8060e1eb667d990c2ab0e2a39d33d94541d
getPreferencesFromUser
public PreferenceArray getPreferencesFromUser(long userID) throws TasteException
{    if (isAnonymousUser(userID)) {        return tempPrefs.get(userID);    }    return getDelegate().getPreferencesFromUser(userID);}
ba6a53e86aa528831d7ca18f17bea6d3af21894eb8e11a57a1a779aa58bf6f42
getItemIDsFromUser
public FastIDSet getItemIDsFromUser(long userID) throws TasteException
{    if (isAnonymousUser(userID)) {        return prefItemIDs.get(userID);    }    return getDelegate().getItemIDsFromUser(userID);}
be05dbd3948efc99ba2728f3fbfa2a5e8c9ebc9afdb1d8695cb8bf348212f432
getPreferencesForItem
public PreferenceArray getPreferencesForItem(long itemID) throws TasteException
{    if (tempPrefs.isEmpty()) {        return getDelegate().getPreferencesForItem(itemID);    }    PreferenceArray delegatePrefs = null;    try {        delegatePrefs = getDelegate().getPreferencesForItem(itemID);    } catch (NoSuchItemException nsie) {                if (log.isDebugEnabled()) {            log.debug("Item {} unknown", itemID);        }    }    List<Preference> anonymousPreferences = Lists.newArrayList();    for (Map.Entry<Long, PreferenceArray> prefsMap : tempPrefs.entrySet()) {        PreferenceArray singleUserTempPrefs = prefsMap.getValue();        for (int i = 0; i < singleUserTempPrefs.length(); i++) {            if (singleUserTempPrefs.getItemID(i) == itemID) {                anonymousPreferences.add(singleUserTempPrefs.get(i));            }        }    }    int delegateLength = delegatePrefs == null ? 0 : delegatePrefs.length();    int anonymousPrefsLength = anonymousPreferences.size();    int prefsCounter = 0;        PreferenceArray newPreferenceArray = new GenericItemPreferenceArray(delegateLength + anonymousPrefsLength);    for (int i = 0; i < delegateLength; i++) {        newPreferenceArray.set(prefsCounter++, delegatePrefs.get(i));    }    for (Preference anonymousPreference : anonymousPreferences) {        newPreferenceArray.set(prefsCounter++, anonymousPreference);    }    if (newPreferenceArray.length() == 0) {                throw new NoSuchItemException(itemID);    }    return newPreferenceArray;}
4a797ada65a2ab5d778b75e04ac2b1252411b11fa907fd98679888cf05ffb484
getPreferenceValue
public Float getPreferenceValue(long userID, long itemID) throws TasteException
{    if (isAnonymousUser(userID)) {        PreferenceArray singleUserTempPrefs = tempPrefs.get(userID);        for (int i = 0; i < singleUserTempPrefs.length(); i++) {            if (singleUserTempPrefs.getItemID(i) == itemID) {                return singleUserTempPrefs.getValue(i);            }        }        return null;    }    return getDelegate().getPreferenceValue(userID, itemID);}
0857731203f906c58b60e4e747203723db701723c05fe7896e7f325ffa539bdc
getPreferenceTime
public Long getPreferenceTime(long userID, long itemID) throws TasteException
{    if (isAnonymousUser(userID)) {                return null;    }    return getDelegate().getPreferenceTime(userID, itemID);}
c52287e7598bb24d77044373ddfeaf97ff2c29583e729316fa8fb9bef78133a1
getNumUsers
public int getNumUsers() throws TasteException
{        return getDelegate().getNumUsers();}
0ea40759843b60bfb2d618774fa6b7fede865d83651c9e9fe817822760d18483
getNumUsersWithPreferenceFor
public int getNumUsersWithPreferenceFor(long itemID) throws TasteException
{    if (tempPrefs.isEmpty()) {        return getDelegate().getNumUsersWithPreferenceFor(itemID);    }    int countAnonymousUsersWithPreferenceFor = 0;    for (Map.Entry<Long, PreferenceArray> singleUserTempPrefs : tempPrefs.entrySet()) {        for (int i = 0; i < singleUserTempPrefs.getValue().length(); i++) {            if (singleUserTempPrefs.getValue().getItemID(i) == itemID) {                countAnonymousUsersWithPreferenceFor++;                break;            }        }    }    return getDelegate().getNumUsersWithPreferenceFor(itemID) + countAnonymousUsersWithPreferenceFor;}
6d019eca3996fc5fdfb1030e07ee927128888b79b32683dd1b2041baeaf53a4b
getNumUsersWithPreferenceFor
public int getNumUsersWithPreferenceFor(long itemID1, long itemID2) throws TasteException
{    if (tempPrefs.isEmpty()) {        return getDelegate().getNumUsersWithPreferenceFor(itemID1, itemID2);    }    int countAnonymousUsersWithPreferenceFor = 0;    for (Map.Entry<Long, PreferenceArray> singleUserTempPrefs : tempPrefs.entrySet()) {        boolean found1 = false;        boolean found2 = false;        for (int i = 0; i < singleUserTempPrefs.getValue().length() && !(found1 && found2); i++) {            long itemID = singleUserTempPrefs.getValue().getItemID(i);            if (itemID == itemID1) {                found1 = true;            }            if (itemID == itemID2) {                found2 = true;            }        }        if (found1 && found2) {            countAnonymousUsersWithPreferenceFor++;        }    }    return getDelegate().getNumUsersWithPreferenceFor(itemID1, itemID2) + countAnonymousUsersWithPreferenceFor;}
50d76af25ae801a2139a90c576940f9f9838c80f93853951415d27753efe6193
setPreference
public void setPreference(long userID, long itemID, float value) throws TasteException
{    if (isAnonymousUser(userID)) {        throw new UnsupportedOperationException();    }    getDelegate().setPreference(userID, itemID, value);}
b8fc0c1b44ecc54ed269a5d79a52cada03c7abb05284d3d33b03ade9d9a86320
removePreference
public void removePreference(long userID, long itemID) throws TasteException
{    if (isAnonymousUser(userID)) {        throw new UnsupportedOperationException();    }    getDelegate().removePreference(userID, itemID);}
12109f30fe33d8997cb681317cdb537cc9ae875a1943f356258d11746aa8c198
getDelegate
protected DataModel getDelegate()
{    return delegate;}
bcefaa8788c27beb3b901b0c29446d65ef5928e3743927e6d9e82b6029dd2b63
setTempPrefs
public void setTempPrefs(PreferenceArray prefs)
{    Preconditions.checkArgument(prefs != null && prefs.length() > 0, "prefs is null or empty");    this.tempPrefs = prefs;    this.prefItemIDs.clear();    for (int i = 0; i < prefs.length(); i++) {        this.prefItemIDs.add(prefs.getItemID(i));    }}
4ed6c17832a01bd6321c4f8954194afe0e75f88f3f0ce76f3784c0f3e81ecd85
clearTempPrefs
public void clearTempPrefs()
{    tempPrefs = null;    prefItemIDs.clear();}
108a89a094b3a39b3b20cbd581561d4dd8b642f065690760ae153d36d980dcf0
getUserIDs
public LongPrimitiveIterator getUserIDs() throws TasteException
{    if (tempPrefs == null) {        return delegate.getUserIDs();    }    return new PlusAnonymousUserLongPrimitiveIterator(delegate.getUserIDs(), TEMP_USER_ID);}
a06f75f56917fd636b983b7cfb0dd8060e1eb667d990c2ab0e2a39d33d94541d
getPreferencesFromUser
public PreferenceArray getPreferencesFromUser(long userID) throws TasteException
{    if (userID == TEMP_USER_ID) {        if (tempPrefs == null) {            throw new NoSuchUserException(TEMP_USER_ID);        }        return tempPrefs;    }    return delegate.getPreferencesFromUser(userID);}
ba6a53e86aa528831d7ca18f17bea6d3af21894eb8e11a57a1a779aa58bf6f42
getItemIDsFromUser
public FastIDSet getItemIDsFromUser(long userID) throws TasteException
{    if (userID == TEMP_USER_ID) {        if (tempPrefs == null) {            throw new NoSuchUserException(TEMP_USER_ID);        }        return prefItemIDs;    }    return delegate.getItemIDsFromUser(userID);}
c388e3d4c09037f02ac5953d664aae3d2714c879c41346267284f3f30ad0a533
getItemIDs
public LongPrimitiveIterator getItemIDs() throws TasteException
{    return delegate.getItemIDs();}
be05dbd3948efc99ba2728f3fbfa2a5e8c9ebc9afdb1d8695cb8bf348212f432
getPreferencesForItem
public PreferenceArray getPreferencesForItem(long itemID) throws TasteException
{    if (tempPrefs == null) {        return delegate.getPreferencesForItem(itemID);    }    PreferenceArray delegatePrefs = null;    try {        delegatePrefs = delegate.getPreferencesForItem(itemID);    } catch (NoSuchItemException nsie) {                if (log.isDebugEnabled()) {            log.debug("Item {} unknown", itemID);        }    }    for (int i = 0; i < tempPrefs.length(); i++) {        if (tempPrefs.getItemID(i) == itemID) {            return cloneAndMergeInto(delegatePrefs, itemID, tempPrefs.getUserID(i), tempPrefs.getValue(i));        }    }    if (delegatePrefs == null) {                throw new NoSuchItemException(itemID);    }    return delegatePrefs;}
ea6f800567c3eca4445c52cf98d7fadf68ce29462331dfaa0e7ceb21ab48b6ca
cloneAndMergeInto
private static PreferenceArray cloneAndMergeInto(PreferenceArray delegatePrefs, long itemID, long newUserID, float value)
{    int length = delegatePrefs == null ? 0 : delegatePrefs.length();    int newLength = length + 1;    PreferenceArray newPreferenceArray = new GenericItemPreferenceArray(newLength);        newPreferenceArray.setItemID(0, itemID);    int positionToInsert = 0;    while (positionToInsert < length && newUserID > delegatePrefs.getUserID(positionToInsert)) {        positionToInsert++;    }    for (int i = 0; i < positionToInsert; i++) {        newPreferenceArray.setUserID(i, delegatePrefs.getUserID(i));        newPreferenceArray.setValue(i, delegatePrefs.getValue(i));    }    newPreferenceArray.setUserID(positionToInsert, newUserID);    newPreferenceArray.setValue(positionToInsert, value);    for (int i = positionToInsert + 1; i < newLength; i++) {        newPreferenceArray.setUserID(i, delegatePrefs.getUserID(i - 1));        newPreferenceArray.setValue(i, delegatePrefs.getValue(i - 1));    }    return newPreferenceArray;}
4a797ada65a2ab5d778b75e04ac2b1252411b11fa907fd98679888cf05ffb484
getPreferenceValue
public Float getPreferenceValue(long userID, long itemID) throws TasteException
{    if (userID == TEMP_USER_ID) {        if (tempPrefs == null) {            throw new NoSuchUserException(TEMP_USER_ID);        }        for (int i = 0; i < tempPrefs.length(); i++) {            if (tempPrefs.getItemID(i) == itemID) {                return tempPrefs.getValue(i);            }        }        return null;    }    return delegate.getPreferenceValue(userID, itemID);}
0857731203f906c58b60e4e747203723db701723c05fe7896e7f325ffa539bdc
getPreferenceTime
public Long getPreferenceTime(long userID, long itemID) throws TasteException
{    if (userID == TEMP_USER_ID) {        if (tempPrefs == null) {            throw new NoSuchUserException(TEMP_USER_ID);        }        return null;    }    return delegate.getPreferenceTime(userID, itemID);}
0e5cfb4e0e4f9d1a7b8c16082ab928c9562f8fb336a58c94de25d6df00236f93
getNumItems
public int getNumItems() throws TasteException
{    return delegate.getNumItems();}
c52287e7598bb24d77044373ddfeaf97ff2c29583e729316fa8fb9bef78133a1
getNumUsers
public int getNumUsers() throws TasteException
{    return delegate.getNumUsers() + (tempPrefs == null ? 0 : 1);}
0ea40759843b60bfb2d618774fa6b7fede865d83651c9e9fe817822760d18483
getNumUsersWithPreferenceFor
public int getNumUsersWithPreferenceFor(long itemID) throws TasteException
{    if (tempPrefs == null) {        return delegate.getNumUsersWithPreferenceFor(itemID);    }    boolean found = false;    for (int i = 0; i < tempPrefs.length(); i++) {        if (tempPrefs.getItemID(i) == itemID) {            found = true;            break;        }    }    return delegate.getNumUsersWithPreferenceFor(itemID) + (found ? 1 : 0);}
6d019eca3996fc5fdfb1030e07ee927128888b79b32683dd1b2041baeaf53a4b
getNumUsersWithPreferenceFor
public int getNumUsersWithPreferenceFor(long itemID1, long itemID2) throws TasteException
{    if (tempPrefs == null) {        return delegate.getNumUsersWithPreferenceFor(itemID1, itemID2);    }    boolean found1 = false;    boolean found2 = false;    for (int i = 0; i < tempPrefs.length() && !(found1 && found2); i++) {        long itemID = tempPrefs.getItemID(i);        if (itemID == itemID1) {            found1 = true;        }        if (itemID == itemID2) {            found2 = true;        }    }    return delegate.getNumUsersWithPreferenceFor(itemID1, itemID2) + (found1 && found2 ? 1 : 0);}
50d76af25ae801a2139a90c576940f9f9838c80f93853951415d27753efe6193
setPreference
public void setPreference(long userID, long itemID, float value) throws TasteException
{    if (userID == TEMP_USER_ID) {        if (tempPrefs == null) {            throw new NoSuchUserException(TEMP_USER_ID);        }        throw new UnsupportedOperationException();    }    delegate.setPreference(userID, itemID, value);}
b8fc0c1b44ecc54ed269a5d79a52cada03c7abb05284d3d33b03ade9d9a86320
removePreference
public void removePreference(long userID, long itemID) throws TasteException
{    if (userID == TEMP_USER_ID) {        if (tempPrefs == null) {            throw new NoSuchUserException(TEMP_USER_ID);        }        throw new UnsupportedOperationException();    }    delegate.removePreference(userID, itemID);}
da77e35d28c590f4b271e5b2b7f639c465574b8f17a1ef2f1df63e0152c57e8b
refresh
public void refresh(Collection<Refreshable> alreadyRefreshed)
{    delegate.refresh(alreadyRefreshed);}
5fe6ef45f2c8e613067bc79bf61b3f21f1aac63aa04e14a47b4f8203cebb79f9
hasPreferenceValues
public boolean hasPreferenceValues()
{    return delegate.hasPreferenceValues();}
13925bef8afa2e6d068d08c72262016e42e3d5fe30ac04c85c78f8b0f99c4ceb
getMaxPreference
public float getMaxPreference()
{    return delegate.getMaxPreference();}
886c9fcd0006e44aa20de41c56cd99e5659dc842b2fd94840da5c661f1bccb0a
getMinPreference
public float getMinPreference()
{    return delegate.getMinPreference();}
c07ff43a11a0fd30355c754b084700be1eadeb6e7293cc052804e1ca4dba70c9
nextLong
public long nextLong()
{    if (datumConsumed) {        return delegate.nextLong();    } else {        if (delegate.hasNext()) {            long delegateNext = delegate.peek();            if (extraDatum <= delegateNext) {                datumConsumed = true;                return extraDatum;            } else {                return delegate.next();            }        } else {            datumConsumed = true;            return extraDatum;        }    }}
cfc67e5714c799daa4f0cae0084231f7d3115d517eae691edd227e7f59489e21
peek
public long peek()
{    if (datumConsumed) {        return delegate.peek();    } else {        if (delegate.hasNext()) {            long delegateNext = delegate.peek();            if (extraDatum <= delegateNext) {                return extraDatum;            } else {                return delegateNext;            }        } else {            return extraDatum;        }    }}
d51e5f7450eca0a0f63da1a466189e262d053b84aa767ba3be5cea740af7251b
hasNext
public boolean hasNext()
{    return !datumConsumed || delegate.hasNext();}
eb35e4acc0ab2c89fd30970f01fba35488b3a4581b2af1986091209043508a3e
remove
public void remove()
{    throw new UnsupportedOperationException();}
83659b3f3c32cda5d1e381b9ad4b7db55d1ee8ecce3504ad3c9ad45a376b6f2e
skip
public void skip(int n)
{    for (int i = 0; i < n; i++) {        nextLong();    }}
47af1f4b341f2ee3ecdb02b15fb91a2bb372f5fe49a3e6f995f23633c9261523
getUserSimilarity
 final UserSimilarity getUserSimilarity()
{    return userSimilarity;}
4bf42da6f3803485a3495c540a32eebb8b0863df91c58eb7bd2ebc8f8181466c
getDataModel
 final DataModel getDataModel()
{    return dataModel;}
9a58ace636ef104218a42c7382041614c3b9dde823b66a4a6031f91b7b5a2daa
getSamplingRate
 final double getSamplingRate()
{    return samplingRate;}
20b8605591bd898434b8e6c49a1ee9b73e8cf20f0fb8085ad10160c16fe250a0
refresh
public final void refresh(Collection<Refreshable> alreadyRefreshed)
{    refreshHelper.refresh(alreadyRefreshed);}
84161ce25cb59f0f9209b2e54d4ede32b56796658f035efccb3acaec0f0688c2
getUserNeighborhood
public long[] getUserNeighborhood(long userID) throws TasteException
{    return neighborhoodCache.get(userID);}
da77e35d28c590f4b271e5b2b7f639c465574b8f17a1ef2f1df63e0152c57e8b
refresh
public void refresh(Collection<Refreshable> alreadyRefreshed)
{    neighborhoodCache.clear();    Collection<Refreshable> refreshed = RefreshHelper.buildRefreshed(alreadyRefreshed);    RefreshHelper.maybeRefresh(refreshed, neighborhood);}
a4c5801ce361a57a315016174d4a545f566910bccb94a6ac3ed5f75e81b9b004
get
public long[] get(Long key) throws TasteException
{    return neighborhood.getUserNeighborhood(key);}
84161ce25cb59f0f9209b2e54d4ede32b56796658f035efccb3acaec0f0688c2
getUserNeighborhood
public long[] getUserNeighborhood(long userID) throws TasteException
{    DataModel dataModel = getDataModel();    UserSimilarity userSimilarityImpl = getUserSimilarity();    TopItems.Estimator<Long> estimator = new Estimator(userSimilarityImpl, userID, minSimilarity);    LongPrimitiveIterator userIDs = SamplingLongPrimitiveIterator.maybeWrapIterator(dataModel.getUserIDs(), getSamplingRate());    return TopItems.getTopUsers(n, userIDs, null, estimator);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "NearestNUserNeighborhood";}
4fe4a1da903228fb0f97746b256395ca1f1886de0c9571068ebf04f498388c92
estimate
public double estimate(Long userID) throws TasteException
{    if (userID == theUserID) {        return Double.NaN;    }    double sim = userSimilarityImpl.userSimilarity(theUserID, userID);    return sim >= minSim ? sim : Double.NaN;}
84161ce25cb59f0f9209b2e54d4ede32b56796658f035efccb3acaec0f0688c2
getUserNeighborhood
public long[] getUserNeighborhood(long userID) throws TasteException
{    DataModel dataModel = getDataModel();    FastIDSet neighborhood = new FastIDSet();    LongPrimitiveIterator usersIterable = SamplingLongPrimitiveIterator.maybeWrapIterator(dataModel.getUserIDs(), getSamplingRate());    UserSimilarity userSimilarityImpl = getUserSimilarity();    while (usersIterable.hasNext()) {        long otherUserID = usersIterable.next();        if (userID != otherUserID) {            double theSimilarity = userSimilarityImpl.userSimilarity(userID, otherUserID);            if (!Double.isNaN(theSimilarity) && theSimilarity >= threshold) {                neighborhood.add(otherUserID);            }        }    }    return neighborhood.toArray();}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "ThresholdUserNeighborhood";}
9cc1b043d10e2a261320ddd7ce5bb464d880eb3e077bfda4d0c3bbc9caf0e371
doGetCandidateItems
protected FastIDSet doGetCandidateItems(long[] preferredItemIDs, DataModel dataModel) throws TasteException
{    return doGetCandidateItems(preferredItemIDs, dataModel, false);}
6c8d841ed0cf9d815f16599f5b024cdad8eacc3b35b547ac9a8c98f3cd73ed96
getCandidateItems
public FastIDSet getCandidateItems(long userID, PreferenceArray preferencesFromUser, DataModel dataModel, boolean includeKnownItems) throws TasteException
{    return doGetCandidateItems(preferencesFromUser.getIDs(), dataModel, includeKnownItems);}
333c909845a46c87e0ebd276798ddb1d787b87e9d6be447459f3087622d8549a
getCandidateItems
public FastIDSet getCandidateItems(long[] itemIDs, DataModel dataModel) throws TasteException
{    return doGetCandidateItems(itemIDs, dataModel, false);}
da77e35d28c590f4b271e5b2b7f639c465574b8f17a1ef2f1df63e0152c57e8b
refresh
public void refresh(Collection<Refreshable> alreadyRefreshed)
{}
65b761902cc44964ad22029137485d8a6484c9227bc643b9107e8c80a34086b5
getDefaultCandidateItemsStrategy
protected static CandidateItemsStrategy getDefaultCandidateItemsStrategy()
{    return new PreferredItemsNeighborhoodCandidateItemsStrategy();}
2dc6b0153d6772fcc089075e32bcd2d4f93daa3143e3a889d7821635b62ed9fe
recommend
public List<RecommendedItem> recommend(long userID, int howMany) throws TasteException
{    return recommend(userID, howMany, null, false);}
d15575e3c7219fa78f3f939060474f9f6e1b3d7a970e542069957a25a02fb5d4
recommend
public List<RecommendedItem> recommend(long userID, int howMany, boolean includeKnownItems) throws TasteException
{    return recommend(userID, howMany, null, includeKnownItems);}
82cca6a764b4f51c39392acfde0a28aced7e68d46f3f48675d7e2aa136c3b334
recommend
public List<RecommendedItem> recommend(long userID, int howMany, IDRescorer rescorer) throws TasteException
{    return recommend(userID, howMany, rescorer, false);}
50d76af25ae801a2139a90c576940f9f9838c80f93853951415d27753efe6193
setPreference
public void setPreference(long userID, long itemID, float value) throws TasteException
{    Preconditions.checkArgument(!Float.isNaN(value), "NaN value");    log.debug("Setting preference for user {}, item {}", userID, itemID);    dataModel.setPreference(userID, itemID, value);}
b8fc0c1b44ecc54ed269a5d79a52cada03c7abb05284d3d33b03ade9d9a86320
removePreference
public void removePreference(long userID, long itemID) throws TasteException
{    log.debug("Remove preference for user '{}', item '{}'", userID, itemID);    dataModel.removePreference(userID, itemID);}
9cc8860ae5e18fe9fdcc3faca0fad6e9d7eb4076efef8c2790ec7efad6fe6102
getDataModel
public DataModel getDataModel()
{    return dataModel;}
0ac5474b1512a52e38712bb32e7c370d98ec70f96f126666df5c76509bbb6701
getAllOtherItems
protected FastIDSet getAllOtherItems(long userID, PreferenceArray preferencesFromUser, boolean includeKnownItems) throws TasteException
{    return candidateItemsStrategy.getCandidateItems(userID, preferencesFromUser, dataModel, includeKnownItems);}
145086b47ca3bb3f97be6e053b2b5a109daa2687ec2ffb7525b41f608b5f8d6f
doGetCandidateItems
protected FastIDSet doGetCandidateItems(long[] preferredItemIDs, DataModel dataModel, boolean includeKnownItems) throws TasteException
{    FastIDSet candidateItemIDs = new FastIDSet();    for (long itemID : preferredItemIDs) {        candidateItemIDs.addAll(similarity.allSimilarItemIDs(itemID));    }    if (!includeKnownItems) {        candidateItemIDs.removeAll(preferredItemIDs);    }    return candidateItemIDs;}
145086b47ca3bb3f97be6e053b2b5a109daa2687ec2ffb7525b41f608b5f8d6f
doGetCandidateItems
protected FastIDSet doGetCandidateItems(long[] preferredItemIDs, DataModel dataModel, boolean includeKnownItems) throws TasteException
{    FastIDSet possibleItemIDs = new FastIDSet(dataModel.getNumItems());    LongPrimitiveIterator allItemIDs = dataModel.getItemIDs();    while (allItemIDs.hasNext()) {        possibleItemIDs.add(allItemIDs.nextLong());    }    if (!includeKnownItems) {        possibleItemIDs.removeAll(preferredItemIDs);    }    return possibleItemIDs;}
3faea1ef948cb369014ffb9129e05f315f71b1dee822396f8ef4366674c70179
compare
public int compare(RecommendedItem o1, RecommendedItem o2)
{    double rescored1;    double rescored2;    if (rescorer == null) {        rescored1 = o1.getValue();        rescored2 = o2.getValue();    } else {        rescored1 = rescorer.rescore(o1.getItemID(), o1.getValue());        rescored2 = rescorer.rescore(o2.getItemID(), o2.getValue());    }    if (rescored1 < rescored2) {        return 1;    } else if (rescored1 > rescored2) {        return -1;    } else {        return 0;    }}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "ByRescoreComparator[rescorer:" + rescorer + ']';}
17b8b0204586d999472343160a70f395c51d2e426f96a084cec6407aff774cf3
getInstance
public static Comparator<RecommendedItem> getInstance()
{    return INSTANCE;}
3faea1ef948cb369014ffb9129e05f315f71b1dee822396f8ef4366674c70179
compare
public int compare(RecommendedItem o1, RecommendedItem o2)
{    float value1 = o1.getValue();    float value2 = o2.getValue();    return value1 > value2 ? -1 : value1 < value2 ? 1 : 0;}
8ddbbc8cc2055115ac600cd3c188d8462671957754411c629518534bb9a3af36
call
public Object call()
{    clear();    return null;}
004e9017e020a7cfdb053102d8ec6925b3e149666936c3f296ada02c280e1005
setCurrentRescorer
private void setCurrentRescorer(IDRescorer rescorer)
{    if (rescorer == null) {        if (currentRescorer != null) {            currentRescorer = null;            clear();        }    } else {        if (!rescorer.equals(currentRescorer)) {            currentRescorer = rescorer;            clear();        }    }}
b1d3703ce725dbd91522de606353433cd4aa9854afe2b7c0b9298c422ef1c83d
setCurrentlyIncludeKnownItems
public void setCurrentlyIncludeKnownItems(boolean currentlyIncludeKnownItems)
{    this.currentlyIncludeKnownItems = currentlyIncludeKnownItems;}
2dc6b0153d6772fcc089075e32bcd2d4f93daa3143e3a889d7821635b62ed9fe
recommend
public List<RecommendedItem> recommend(long userID, int howMany) throws TasteException
{    return recommend(userID, howMany, null, false);}
d15575e3c7219fa78f3f939060474f9f6e1b3d7a970e542069957a25a02fb5d4
recommend
public List<RecommendedItem> recommend(long userID, int howMany, boolean includeKnownItems) throws TasteException
{    return recommend(userID, howMany, null, includeKnownItems);}
82cca6a764b4f51c39392acfde0a28aced7e68d46f3f48675d7e2aa136c3b334
recommend
public List<RecommendedItem> recommend(long userID, int howMany, IDRescorer rescorer) throws TasteException
{    return recommend(userID, howMany, rescorer, false);}
cae55eaeb500f9cfd9e012eff77e31d3bd1d8c4362d52fedefd3790d2b7900d6
recommend
public List<RecommendedItem> recommend(long userID, int howMany, IDRescorer rescorer, boolean includeKnownItems) throws TasteException
{    Preconditions.checkArgument(howMany >= 1, "howMany must be at least 1");    synchronized (maxHowMany) {        if (howMany > maxHowMany[0]) {            maxHowMany[0] = howMany;        }    }        if (userID == PlusAnonymousUserDataModel.TEMP_USER_ID) {        return recommendationsRetriever.get(PlusAnonymousUserDataModel.TEMP_USER_ID).getItems();    }    setCurrentRescorer(rescorer);    setCurrentlyIncludeKnownItems(includeKnownItems);    Recommendations recommendations = recommendationCache.get(userID);    if (recommendations.getItems().size() < howMany && !recommendations.isNoMoreRecommendableItems()) {        clear(userID);        recommendations = recommendationCache.get(userID);        if (recommendations.getItems().size() < howMany) {            recommendations.setNoMoreRecommendableItems(true);        }    }    List<RecommendedItem> recommendedItems = recommendations.getItems();    return recommendedItems.size() > howMany ? recommendedItems.subList(0, howMany) : recommendedItems;}
fe4075a1aad10eb52e9a33b25ff2a59f9af6b1541778182edc3aa82095b47ee2
estimatePreference
public float estimatePreference(long userID, long itemID) throws TasteException
{    return estimatedPrefCache.get(new LongPair(userID, itemID));}
50d76af25ae801a2139a90c576940f9f9838c80f93853951415d27753efe6193
setPreference
public void setPreference(long userID, long itemID, float value) throws TasteException
{    recommender.setPreference(userID, itemID, value);    clear(userID);}
b8fc0c1b44ecc54ed269a5d79a52cada03c7abb05284d3d33b03ade9d9a86320
removePreference
public void removePreference(long userID, long itemID) throws TasteException
{    recommender.removePreference(userID, itemID);    clear(userID);}
9cc8860ae5e18fe9fdcc3faca0fad6e9d7eb4076efef8c2790ec7efad6fe6102
getDataModel
public DataModel getDataModel()
{    return recommender.getDataModel();}
da77e35d28c590f4b271e5b2b7f639c465574b8f17a1ef2f1df63e0152c57e8b
refresh
public void refresh(Collection<Refreshable> alreadyRefreshed)
{    refreshHelper.refresh(alreadyRefreshed);}
65fe861f9f988588aee785064109079fac66d87df40ecac3b8114782f8ba8885
clear
public void clear(final long userID)
{    log.debug("Clearing recommendations for user ID '{}'", userID);    recommendationCache.remove(userID);    estimatedPrefCache.removeKeysMatching(new Cache.MatchPredicate<LongPair>() {        @Override        public boolean matches(LongPair userItemPair) {            return userItemPair.getFirst() == userID;        }    });}
0ae8a627258aeadc13dce8ac5c72ed5c30c9021e478e190022fec22f42ceec00
matches
public boolean matches(LongPair userItemPair)
{    return userItemPair.getFirst() == userID;}
21ac40bb9a99614b6ac18fa4043acb6173fccff96066fdfab963dba597923aa8
clear
public void clear()
{    log.debug("Clearing all recommendations...");    recommendationCache.clear();    estimatedPrefCache.clear();}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "CachingRecommender[recommender:" + recommender + ']';}
9c0871af109cb4d1dc2f6425e8cd2dca48d934af95d0e1d2b7f570d062ae247e
get
public Recommendations get(Long key) throws TasteException
{    log.debug("Retrieving new recommendations for user ID '{}'", key);    int howMany = maxHowMany[0];    IDRescorer rescorer = currentRescorer;    List<RecommendedItem> recommendations = rescorer == null ? recommender.recommend(key, howMany, null, currentlyIncludeKnownItems) : recommender.recommend(key, howMany, rescorer, currentlyIncludeKnownItems);    return new Recommendations(Collections.unmodifiableList(recommendations));}
434c5d4425f66166502598ad2133c8271709742612cf198ae1808fcd5bbabc11
get
public Float get(LongPair key) throws TasteException
{    long userID = key.getFirst();    long itemID = key.getSecond();    log.debug("Retrieving estimated preference for user ID '{}' and item ID '{}'", userID, itemID);    return recommender.estimatePreference(userID, itemID);}
5b11d9e46bf63975dd56315c8d42f3638046314f2d0c439f93d1636fab790a88
getItems
 List<RecommendedItem> getItems()
{    return items;}
92e48e09eed8a4efd9a4810294e14ed2187f35303ea75c9113fc9466ba240c15
isNoMoreRecommendableItems
 boolean isNoMoreRecommendableItems()
{    return noMoreRecommendableItems;}
3a8869ad80a74fe66574d3eeeb568c0806558745302c4aed90acf60c33d90eb8
setNoMoreRecommendableItems
 void setNoMoreRecommendableItems(boolean noMoreRecommendableItems)
{    this.noMoreRecommendableItems = noMoreRecommendableItems;}
b03e582bb1e5866fc4a025c5c50f9214104d3cc9cdf0dd886b8d5e8515ff3f30
capEstimate
public float capEstimate(float estimate)
{    if (estimate > max) {        estimate = max;    } else if (estimate < min) {        estimate = min;    }    return estimate;}
65a01418b37f64290d876e97f2465de6088e334dfe509b0482e1ba91fedd1e45
doEstimatePreference
protected float doEstimatePreference(long userID, PreferenceArray preferencesFromUser, long itemID) throws TasteException
{    double[] similarities = getSimilarity().itemSimilarities(itemID, preferencesFromUser.getIDs());    boolean foundAPref = false;    double totalSimilarity = 0.0;    for (double theSimilarity : similarities) {        if (!Double.isNaN(theSimilarity)) {            foundAPref = true;            totalSimilarity += theSimilarity;        }    }    return foundAPref ? (float) totalSimilarity : Float.NaN;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "GenericBooleanPrefItemBasedRecommender";}
fa86e89772157e55861b08008c33052e2746c80a0e9dbc87b3f12d6d19de6903
doEstimatePreference
protected float doEstimatePreference(long theUserID, long[] theNeighborhood, long itemID) throws TasteException
{    if (theNeighborhood.length == 0) {        return Float.NaN;    }    DataModel dataModel = getDataModel();    UserSimilarity similarity = getSimilarity();    float totalSimilarity = 0.0f;    boolean foundAPref = false;    for (long userID : theNeighborhood) {                if (userID != theUserID && dataModel.getPreferenceValue(userID, itemID) != null) {            foundAPref = true;            totalSimilarity += (float) similarity.userSimilarity(theUserID, userID);        }    }    return foundAPref ? totalSimilarity : Float.NaN;}
a25c1eab759286493177eec2560923a50e41ec0bf27466bcbe32fe7d8077469e
getAllOtherItems
protected FastIDSet getAllOtherItems(long[] theNeighborhood, long theUserID, boolean includeKnownItems) throws TasteException
{    DataModel dataModel = getDataModel();    FastIDSet possibleItemIDs = new FastIDSet();    for (long userID : theNeighborhood) {        possibleItemIDs.addAll(dataModel.getItemIDsFromUser(userID));    }    if (!includeKnownItems) {        possibleItemIDs.removeAll(dataModel.getItemIDsFromUser(theUserID));    }    return possibleItemIDs;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "GenericBooleanPrefUserBasedRecommender";}
129e071a5acdf44209957699325f269c391c2463b78b7efe09056606615ae94b
call
public Void call()
{    capper = buildCapper();    return null;}
d7e7913b67daf12724254f07ac873e87cb605232c67efa6e254c4f81821fd114
getDefaultMostSimilarItemsCandidateItemsStrategy
protected static MostSimilarItemsCandidateItemsStrategy getDefaultMostSimilarItemsCandidateItemsStrategy()
{    return new PreferredItemsNeighborhoodCandidateItemsStrategy();}
c116e90a1754721c06b0fcf332e04c9584cf3106b2c4f40b39e29994acfbca31
getSimilarity
public ItemSimilarity getSimilarity()
{    return similarity;}
cae55eaeb500f9cfd9e012eff77e31d3bd1d8c4362d52fedefd3790d2b7900d6
recommend
public List<RecommendedItem> recommend(long userID, int howMany, IDRescorer rescorer, boolean includeKnownItems) throws TasteException
{    Preconditions.checkArgument(howMany >= 1, "howMany must be at least 1");    log.debug("Recommending items for user ID '{}'", userID);    PreferenceArray preferencesFromUser = getDataModel().getPreferencesFromUser(userID);    if (preferencesFromUser.length() == 0) {        return Collections.emptyList();    }    FastIDSet possibleItemIDs = getAllOtherItems(userID, preferencesFromUser, includeKnownItems);    TopItems.Estimator<Long> estimator = new Estimator(userID, preferencesFromUser);    List<RecommendedItem> topItems = TopItems.getTopItems(howMany, possibleItemIDs.iterator(), rescorer, estimator);    log.debug("Recommendations are: {}", topItems);    return topItems;}
fe4075a1aad10eb52e9a33b25ff2a59f9af6b1541778182edc3aa82095b47ee2
estimatePreference
public float estimatePreference(long userID, long itemID) throws TasteException
{    PreferenceArray preferencesFromUser = getDataModel().getPreferencesFromUser(userID);    Float actualPref = getPreferenceForItem(preferencesFromUser, itemID);    if (actualPref != null) {        return actualPref;    }    return doEstimatePreference(userID, preferencesFromUser, itemID);}
7594336c0f3ea411f5063f01764dc988b58aacf4c0eb03bc22de9c5d7ee880f3
getPreferenceForItem
private static Float getPreferenceForItem(PreferenceArray preferencesFromUser, long itemID)
{    int size = preferencesFromUser.length();    for (int i = 0; i < size; i++) {        if (preferencesFromUser.getItemID(i) == itemID) {            return preferencesFromUser.getValue(i);        }    }    return null;}
1897397f2da9b86a9f685b722ccc351a953dda13bda54cc21e455419f4a20674
mostSimilarItems
public List<RecommendedItem> mostSimilarItems(long itemID, int howMany) throws TasteException
{    return mostSimilarItems(itemID, howMany, null);}
368291bc0773a2d7d0a8a73f5955c7a6cb76cf67fea5353573fda494f7faae08
mostSimilarItems
public List<RecommendedItem> mostSimilarItems(long itemID, int howMany, Rescorer<LongPair> rescorer) throws TasteException
{    TopItems.Estimator<Long> estimator = new MostSimilarEstimator(itemID, similarity, rescorer);    return doMostSimilarItems(new long[] { itemID }, howMany, estimator);}
d97008787f9092542ce4a7c21433006467e8b1923d3b31880a41dfe6c4eb92e3
mostSimilarItems
public List<RecommendedItem> mostSimilarItems(long[] itemIDs, int howMany) throws TasteException
{    TopItems.Estimator<Long> estimator = new MultiMostSimilarEstimator(itemIDs, similarity, null, EXCLUDE_ITEM_IF_NOT_SIMILAR_TO_ALL_BY_DEFAULT);    return doMostSimilarItems(itemIDs, howMany, estimator);}
4e482b7622c6ad7aaa8d58d2ea689c926d7dac6acbc5b746adadbe19e7446769
mostSimilarItems
public List<RecommendedItem> mostSimilarItems(long[] itemIDs, int howMany, Rescorer<LongPair> rescorer) throws TasteException
{    TopItems.Estimator<Long> estimator = new MultiMostSimilarEstimator(itemIDs, similarity, rescorer, EXCLUDE_ITEM_IF_NOT_SIMILAR_TO_ALL_BY_DEFAULT);    return doMostSimilarItems(itemIDs, howMany, estimator);}
9caac858827ee55d40341cce090dfea215e064a97d615b074df8ad43f622b07a
mostSimilarItems
public List<RecommendedItem> mostSimilarItems(long[] itemIDs, int howMany, boolean excludeItemIfNotSimilarToAll) throws TasteException
{    TopItems.Estimator<Long> estimator = new MultiMostSimilarEstimator(itemIDs, similarity, null, excludeItemIfNotSimilarToAll);    return doMostSimilarItems(itemIDs, howMany, estimator);}
de697099cfd3390324c90ec4a66df65629c2fae7bb02998daf2796120462e3a6
mostSimilarItems
public List<RecommendedItem> mostSimilarItems(long[] itemIDs, int howMany, Rescorer<LongPair> rescorer, boolean excludeItemIfNotSimilarToAll) throws TasteException
{    TopItems.Estimator<Long> estimator = new MultiMostSimilarEstimator(itemIDs, similarity, rescorer, excludeItemIfNotSimilarToAll);    return doMostSimilarItems(itemIDs, howMany, estimator);}
e33978455acf597c4ff777159f5c76da12e1183c7cd800c445b977976ec58566
recommendedBecause
public List<RecommendedItem> recommendedBecause(long userID, long itemID, int howMany) throws TasteException
{    Preconditions.checkArgument(howMany >= 1, "howMany must be at least 1");    DataModel model = getDataModel();    TopItems.Estimator<Long> estimator = new RecommendedBecauseEstimator(userID, itemID);    PreferenceArray prefs = model.getPreferencesFromUser(userID);    int size = prefs.length();    FastIDSet allUserItems = new FastIDSet(size);    for (int i = 0; i < size; i++) {        allUserItems.add(prefs.getItemID(i));    }    allUserItems.remove(itemID);    return TopItems.getTopItems(howMany, allUserItems.iterator(), null, estimator);}
c4580bb619d6edd0af3037286333c9e8bfaf26eccd781844f979930b0bc22b97
doMostSimilarItems
private List<RecommendedItem> doMostSimilarItems(long[] itemIDs, int howMany, TopItems.Estimator<Long> estimator) throws TasteException
{    FastIDSet possibleItemIDs = mostSimilarItemsCandidateItemsStrategy.getCandidateItems(itemIDs, getDataModel());    return TopItems.getTopItems(howMany, possibleItemIDs.iterator(), null, estimator);}
65a01418b37f64290d876e97f2465de6088e334dfe509b0482e1ba91fedd1e45
doEstimatePreference
protected float doEstimatePreference(long userID, PreferenceArray preferencesFromUser, long itemID) throws TasteException
{    double preference = 0.0;    double totalSimilarity = 0.0;    int count = 0;    double[] similarities = similarity.itemSimilarities(itemID, preferencesFromUser.getIDs());    for (int i = 0; i < similarities.length; i++) {        double theSimilarity = similarities[i];        if (!Double.isNaN(theSimilarity)) {                        preference += theSimilarity * preferencesFromUser.getValue(i);            totalSimilarity += theSimilarity;            count++;        }    }        if (count <= 1) {        return Float.NaN;    }    float estimate = (float) (preference / totalSimilarity);    if (capper != null) {        estimate = capper.capEstimate(estimate);    }    return estimate;}
da77e35d28c590f4b271e5b2b7f639c465574b8f17a1ef2f1df63e0152c57e8b
refresh
public void refresh(Collection<Refreshable> alreadyRefreshed)
{    refreshHelper.refresh(alreadyRefreshed);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "GenericItemBasedRecommender[similarity:" + similarity + ']';}
76d97e361d2bc7524980537a7d6303185ca9c90c61f68fd155e59bc8873a2c91
buildCapper
private EstimatedPreferenceCapper buildCapper()
{    DataModel dataModel = getDataModel();    if (Float.isNaN(dataModel.getMinPreference()) && Float.isNaN(dataModel.getMaxPreference())) {        return null;    } else {        return new EstimatedPreferenceCapper(dataModel);    }}
bd8b618f7a1dcbe655acf589cb5cc38ff260f28f181c287b3629af36a5a81437
estimate
public double estimate(Long itemID) throws TasteException
{    LongPair pair = new LongPair(toItemID, itemID);    if (rescorer != null && rescorer.isFiltered(pair)) {        return Double.NaN;    }    double originalEstimate = similarity.itemSimilarity(toItemID, itemID);    return rescorer == null ? originalEstimate : rescorer.rescore(pair, originalEstimate);}
bd8b618f7a1dcbe655acf589cb5cc38ff260f28f181c287b3629af36a5a81437
estimate
public double estimate(Long itemID) throws TasteException
{    return doEstimatePreference(userID, preferencesFromUser, itemID);}
bd8b618f7a1dcbe655acf589cb5cc38ff260f28f181c287b3629af36a5a81437
estimate
public double estimate(Long itemID) throws TasteException
{    RunningAverage average = new FullRunningAverage();    double[] similarities = similarity.itemSimilarities(itemID, toItemIDs);    for (int i = 0; i < toItemIDs.length; i++) {        long toItemID = toItemIDs[i];        LongPair pair = new LongPair(toItemID, itemID);        if (rescorer != null && rescorer.isFiltered(pair)) {            continue;        }        double estimate = similarities[i];        if (rescorer != null) {            estimate = rescorer.rescore(pair, estimate);        }        if (excludeItemIfNotSimilarToAll || !Double.isNaN(estimate)) {            average.addDatum(estimate);        }    }    double averageEstimate = average.getAverage();    return averageEstimate == 0 ? Double.NaN : averageEstimate;}
bd8b618f7a1dcbe655acf589cb5cc38ff260f28f181c287b3629af36a5a81437
estimate
public double estimate(Long itemID) throws TasteException
{    Float pref = getDataModel().getPreferenceValue(userID, itemID);    if (pref == null) {        return Float.NaN;    }    double similarityValue = similarity.itemSimilarity(recommendedItemID, itemID);    return (1.0 + similarityValue) * pref;}
656666c3e1a83c6eb409c8bf7c3282b6209c6991806a5f70debc7368d69aec7d
getItemID
public long getItemID()
{    return itemID;}
875eb4918e20f05856417a7a1eae0829852fb11067dcbf34f10f2a09bcacd7bb
getValue
public float getValue()
{    return value;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "RecommendedItem[item:" + itemID + ", value:" + value + ']';}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return (int) itemID ^ RandomUtils.hashFloat(value);}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (!(o instanceof GenericRecommendedItem)) {        return false;    }    RecommendedItem other = (RecommendedItem) o;    return itemID == other.getItemID() && value == other.getValue();}
129e071a5acdf44209957699325f269c391c2463b78b7efe09056606615ae94b
call
public Void call()
{    capper = buildCapper();    return null;}
d1baf37670071dd035bfc37fa3ba63a0964148d4c912c45a3800469a1fdcba0a
getSimilarity
public UserSimilarity getSimilarity()
{    return similarity;}
cae55eaeb500f9cfd9e012eff77e31d3bd1d8c4362d52fedefd3790d2b7900d6
recommend
public List<RecommendedItem> recommend(long userID, int howMany, IDRescorer rescorer, boolean includeKnownItems) throws TasteException
{    Preconditions.checkArgument(howMany >= 1, "howMany must be at least 1");    log.debug("Recommending items for user ID '{}'", userID);    long[] theNeighborhood = neighborhood.getUserNeighborhood(userID);    if (theNeighborhood.length == 0) {        return Collections.emptyList();    }    FastIDSet allItemIDs = getAllOtherItems(theNeighborhood, userID, includeKnownItems);    TopItems.Estimator<Long> estimator = new Estimator(userID, theNeighborhood);    List<RecommendedItem> topItems = TopItems.getTopItems(howMany, allItemIDs.iterator(), rescorer, estimator);    log.debug("Recommendations are: {}", topItems);    return topItems;}
fe4075a1aad10eb52e9a33b25ff2a59f9af6b1541778182edc3aa82095b47ee2
estimatePreference
public float estimatePreference(long userID, long itemID) throws TasteException
{    DataModel model = getDataModel();    Float actualPref = model.getPreferenceValue(userID, itemID);    if (actualPref != null) {        return actualPref;    }    long[] theNeighborhood = neighborhood.getUserNeighborhood(userID);    return doEstimatePreference(userID, theNeighborhood, itemID);}
1bc7b99e1f05eab0905fbf3068173de8cbe1df60288a60863a7ad4d6c74b2ba7
mostSimilarUserIDs
public long[] mostSimilarUserIDs(long userID, int howMany) throws TasteException
{    return mostSimilarUserIDs(userID, howMany, null);}
14b8ba33c13ce5cbd4d0919d264357c7fe7f2e03805c0cdd439db5f760629566
mostSimilarUserIDs
public long[] mostSimilarUserIDs(long userID, int howMany, Rescorer<LongPair> rescorer) throws TasteException
{    TopItems.Estimator<Long> estimator = new MostSimilarEstimator(userID, similarity, rescorer);    return doMostSimilarUsers(howMany, estimator);}
8e8b0a995f97f2569d61e3ddb733bdf1ce791ca1b5ce734f28193d123c02dffb
doMostSimilarUsers
private long[] doMostSimilarUsers(int howMany, TopItems.Estimator<Long> estimator) throws TasteException
{    DataModel model = getDataModel();    return TopItems.getTopUsers(howMany, model.getUserIDs(), null, estimator);}
fa86e89772157e55861b08008c33052e2746c80a0e9dbc87b3f12d6d19de6903
doEstimatePreference
protected float doEstimatePreference(long theUserID, long[] theNeighborhood, long itemID) throws TasteException
{    if (theNeighborhood.length == 0) {        return Float.NaN;    }    DataModel dataModel = getDataModel();    double preference = 0.0;    double totalSimilarity = 0.0;    int count = 0;    for (long userID : theNeighborhood) {        if (userID != theUserID) {                        Float pref = dataModel.getPreferenceValue(userID, itemID);            if (pref != null) {                double theSimilarity = similarity.userSimilarity(theUserID, userID);                if (!Double.isNaN(theSimilarity)) {                    preference += theSimilarity * pref;                    totalSimilarity += theSimilarity;                    count++;                }            }        }    }        if (count <= 1) {        return Float.NaN;    }    float estimate = (float) (preference / totalSimilarity);    if (capper != null) {        estimate = capper.capEstimate(estimate);    }    return estimate;}
a25c1eab759286493177eec2560923a50e41ec0bf27466bcbe32fe7d8077469e
getAllOtherItems
protected FastIDSet getAllOtherItems(long[] theNeighborhood, long theUserID, boolean includeKnownItems) throws TasteException
{    DataModel dataModel = getDataModel();    FastIDSet possibleItemIDs = new FastIDSet();    for (long userID : theNeighborhood) {        possibleItemIDs.addAll(dataModel.getItemIDsFromUser(userID));    }    if (!includeKnownItems) {        possibleItemIDs.removeAll(dataModel.getItemIDsFromUser(theUserID));    }    return possibleItemIDs;}
da77e35d28c590f4b271e5b2b7f639c465574b8f17a1ef2f1df63e0152c57e8b
refresh
public void refresh(Collection<Refreshable> alreadyRefreshed)
{    refreshHelper.refresh(alreadyRefreshed);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "GenericUserBasedRecommender[neighborhood:" + neighborhood + ']';}
76d97e361d2bc7524980537a7d6303185ca9c90c61f68fd155e59bc8873a2c91
buildCapper
private EstimatedPreferenceCapper buildCapper()
{    DataModel dataModel = getDataModel();    if (Float.isNaN(dataModel.getMinPreference()) && Float.isNaN(dataModel.getMaxPreference())) {        return null;    } else {        return new EstimatedPreferenceCapper(dataModel);    }}
4fe4a1da903228fb0f97746b256395ca1f1886de0c9571068ebf04f498388c92
estimate
public double estimate(Long userID) throws TasteException
{        if (userID == toUserID) {        return Double.NaN;    }    if (rescorer == null) {        return similarity.userSimilarity(toUserID, userID);    } else {        LongPair pair = new LongPair(toUserID, userID);        if (rescorer.isFiltered(pair)) {            return Double.NaN;        }        double originalEstimate = similarity.userSimilarity(toUserID, userID);        return rescorer.rescore(pair, originalEstimate);    }}
bd8b618f7a1dcbe655acf589cb5cc38ff260f28f181c287b3629af36a5a81437
estimate
public double estimate(Long itemID) throws TasteException
{    return doEstimatePreference(theUserID, theNeighborhood, itemID);}
d13adffe85ac1c9f2c0398e9ad6f9b9c9e9bdfcb01b3dd0e05ed2d554564383e
call
public Object call() throws TasteException
{    buildAverageDiffs();    return null;}
cae55eaeb500f9cfd9e012eff77e31d3bd1d8c4362d52fedefd3790d2b7900d6
recommend
public List<RecommendedItem> recommend(long userID, int howMany, IDRescorer rescorer, boolean includeKnownItems) throws TasteException
{    Preconditions.checkArgument(howMany >= 1, "howMany must be at least 1");    log.debug("Recommending items for user ID '{}'", userID);    PreferenceArray preferencesFromUser = getDataModel().getPreferencesFromUser(userID);    FastIDSet possibleItemIDs = getAllOtherItems(userID, preferencesFromUser, includeKnownItems);    TopItems.Estimator<Long> estimator = new Estimator();    List<RecommendedItem> topItems = TopItems.getTopItems(howMany, possibleItemIDs.iterator(), rescorer, estimator);    log.debug("Recommendations are: {}", topItems);    return topItems;}
fe4075a1aad10eb52e9a33b25ff2a59f9af6b1541778182edc3aa82095b47ee2
estimatePreference
public float estimatePreference(long userID, long itemID) throws TasteException
{    DataModel dataModel = getDataModel();    Float actualPref = dataModel.getPreferenceValue(userID, itemID);    if (actualPref != null) {        return actualPref;    }    return doEstimatePreference(itemID);}
9a34288aa8ae08dd0428a417c554f5c48be2eb80916d01aa998186eca5874b55
doEstimatePreference
private float doEstimatePreference(long itemID)
{    buildAveragesLock.readLock().lock();    try {        RunningAverage average = itemAverages.get(itemID);        return average == null ? Float.NaN : (float) average.getAverage();    } finally {        buildAveragesLock.readLock().unlock();    }}
1e979c66218d3b8636a6b83a20351d2ea22a0aff11671e0287bbbbbe73be71c6
buildAverageDiffs
private void buildAverageDiffs() throws TasteException
{    try {        buildAveragesLock.writeLock().lock();        DataModel dataModel = getDataModel();        LongPrimitiveIterator it = dataModel.getUserIDs();        while (it.hasNext()) {            PreferenceArray prefs = dataModel.getPreferencesFromUser(it.nextLong());            int size = prefs.length();            for (int i = 0; i < size; i++) {                long itemID = prefs.getItemID(i);                RunningAverage average = itemAverages.get(itemID);                if (average == null) {                    average = new FullRunningAverage();                    itemAverages.put(itemID, average);                }                average.addDatum(prefs.getValue(i));            }        }    } finally {        buildAveragesLock.writeLock().unlock();    }}
50d76af25ae801a2139a90c576940f9f9838c80f93853951415d27753efe6193
setPreference
public void setPreference(long userID, long itemID, float value) throws TasteException
{    DataModel dataModel = getDataModel();    double prefDelta;    try {        Float oldPref = dataModel.getPreferenceValue(userID, itemID);        prefDelta = oldPref == null ? value : value - oldPref;    } catch (NoSuchUserException nsee) {        prefDelta = value;    }    super.setPreference(userID, itemID, value);    try {        buildAveragesLock.writeLock().lock();        RunningAverage average = itemAverages.get(itemID);        if (average == null) {            RunningAverage newAverage = new FullRunningAverage();            newAverage.addDatum(prefDelta);            itemAverages.put(itemID, newAverage);        } else {            average.changeDatum(prefDelta);        }    } finally {        buildAveragesLock.writeLock().unlock();    }}
b8fc0c1b44ecc54ed269a5d79a52cada03c7abb05284d3d33b03ade9d9a86320
removePreference
public void removePreference(long userID, long itemID) throws TasteException
{    DataModel dataModel = getDataModel();    Float oldPref = dataModel.getPreferenceValue(userID, itemID);    super.removePreference(userID, itemID);    if (oldPref != null) {        try {            buildAveragesLock.writeLock().lock();            RunningAverage average = itemAverages.get(itemID);            if (average == null) {                throw new IllegalStateException("No preferences exist for item ID: " + itemID);            } else {                average.removeDatum(oldPref);            }        } finally {            buildAveragesLock.writeLock().unlock();        }    }}
da77e35d28c590f4b271e5b2b7f639c465574b8f17a1ef2f1df63e0152c57e8b
refresh
public void refresh(Collection<Refreshable> alreadyRefreshed)
{    refreshHelper.refresh(alreadyRefreshed);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "ItemAverageRecommender";}
466c7db378d68fa12e3eefe9dda64edebef34193763676ca95fa0af9eddfd462
estimate
public double estimate(Long itemID)
{    return doEstimatePreference(itemID);}
d13adffe85ac1c9f2c0398e9ad6f9b9c9e9bdfcb01b3dd0e05ed2d554564383e
call
public Object call() throws TasteException
{    buildAverageDiffs();    return null;}
cae55eaeb500f9cfd9e012eff77e31d3bd1d8c4362d52fedefd3790d2b7900d6
recommend
public List<RecommendedItem> recommend(long userID, int howMany, IDRescorer rescorer, boolean includeKnownItems) throws TasteException
{    Preconditions.checkArgument(howMany >= 1, "howMany must be at least 1");    log.debug("Recommending items for user ID '{}'", userID);    PreferenceArray preferencesFromUser = getDataModel().getPreferencesFromUser(userID);    FastIDSet possibleItemIDs = getAllOtherItems(userID, preferencesFromUser, includeKnownItems);    TopItems.Estimator<Long> estimator = new Estimator(userID);    List<RecommendedItem> topItems = TopItems.getTopItems(howMany, possibleItemIDs.iterator(), rescorer, estimator);    log.debug("Recommendations are: {}", topItems);    return topItems;}
fe4075a1aad10eb52e9a33b25ff2a59f9af6b1541778182edc3aa82095b47ee2
estimatePreference
public float estimatePreference(long userID, long itemID) throws TasteException
{    DataModel dataModel = getDataModel();    Float actualPref = dataModel.getPreferenceValue(userID, itemID);    if (actualPref != null) {        return actualPref;    }    return doEstimatePreference(userID, itemID);}
035ea91dcb11e49a2dc1ed9d3a53072aefc87b3d9461b6eb7ce4cfca3286627f
doEstimatePreference
private float doEstimatePreference(long userID, long itemID)
{    buildAveragesLock.readLock().lock();    try {        RunningAverage itemAverage = itemAverages.get(itemID);        if (itemAverage == null) {            return Float.NaN;        }        RunningAverage userAverage = userAverages.get(userID);        if (userAverage == null) {            return Float.NaN;        }        double userDiff = userAverage.getAverage() - overallAveragePrefValue.getAverage();        return (float) (itemAverage.getAverage() + userDiff);    } finally {        buildAveragesLock.readLock().unlock();    }}
1e979c66218d3b8636a6b83a20351d2ea22a0aff11671e0287bbbbbe73be71c6
buildAverageDiffs
private void buildAverageDiffs() throws TasteException
{    try {        buildAveragesLock.writeLock().lock();        DataModel dataModel = getDataModel();        LongPrimitiveIterator it = dataModel.getUserIDs();        while (it.hasNext()) {            long userID = it.nextLong();            PreferenceArray prefs = dataModel.getPreferencesFromUser(userID);            int size = prefs.length();            for (int i = 0; i < size; i++) {                long itemID = prefs.getItemID(i);                float value = prefs.getValue(i);                addDatumAndCreateIfNeeded(itemID, value, itemAverages);                addDatumAndCreateIfNeeded(userID, value, userAverages);                overallAveragePrefValue.addDatum(value);            }        }    } finally {        buildAveragesLock.writeLock().unlock();    }}
251143ee377771a709b84295c2a28a1b92498f5dc853f80754821f02dcb42558
addDatumAndCreateIfNeeded
private static void addDatumAndCreateIfNeeded(long itemID, float value, FastByIDMap<RunningAverage> averages)
{    RunningAverage itemAverage = averages.get(itemID);    if (itemAverage == null) {        itemAverage = new FullRunningAverage();        averages.put(itemID, itemAverage);    }    itemAverage.addDatum(value);}
50d76af25ae801a2139a90c576940f9f9838c80f93853951415d27753efe6193
setPreference
public void setPreference(long userID, long itemID, float value) throws TasteException
{    DataModel dataModel = getDataModel();    double prefDelta;    try {        Float oldPref = dataModel.getPreferenceValue(userID, itemID);        prefDelta = oldPref == null ? value : value - oldPref;    } catch (NoSuchUserException nsee) {        prefDelta = value;    }    super.setPreference(userID, itemID, value);    try {        buildAveragesLock.writeLock().lock();        RunningAverage itemAverage = itemAverages.get(itemID);        if (itemAverage == null) {            RunningAverage newItemAverage = new FullRunningAverage();            newItemAverage.addDatum(prefDelta);            itemAverages.put(itemID, newItemAverage);        } else {            itemAverage.changeDatum(prefDelta);        }        RunningAverage userAverage = userAverages.get(userID);        if (userAverage == null) {            RunningAverage newUserAveragae = new FullRunningAverage();            newUserAveragae.addDatum(prefDelta);            userAverages.put(userID, newUserAveragae);        } else {            userAverage.changeDatum(prefDelta);        }        overallAveragePrefValue.changeDatum(prefDelta);    } finally {        buildAveragesLock.writeLock().unlock();    }}
b8fc0c1b44ecc54ed269a5d79a52cada03c7abb05284d3d33b03ade9d9a86320
removePreference
public void removePreference(long userID, long itemID) throws TasteException
{    DataModel dataModel = getDataModel();    Float oldPref = dataModel.getPreferenceValue(userID, itemID);    super.removePreference(userID, itemID);    if (oldPref != null) {        try {            buildAveragesLock.writeLock().lock();            RunningAverage itemAverage = itemAverages.get(itemID);            if (itemAverage == null) {                throw new IllegalStateException("No preferences exist for item ID: " + itemID);            }            itemAverage.removeDatum(oldPref);            RunningAverage userAverage = userAverages.get(userID);            if (userAverage == null) {                throw new IllegalStateException("No preferences exist for user ID: " + userID);            }            userAverage.removeDatum(oldPref);            overallAveragePrefValue.removeDatum(oldPref);        } finally {            buildAveragesLock.writeLock().unlock();        }    }}
da77e35d28c590f4b271e5b2b7f639c465574b8f17a1ef2f1df63e0152c57e8b
refresh
public void refresh(Collection<Refreshable> alreadyRefreshed)
{    refreshHelper.refresh(alreadyRefreshed);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "ItemUserAverageRecommender";}
466c7db378d68fa12e3eefe9dda64edebef34193763676ca95fa0af9eddfd462
estimate
public double estimate(Long itemID)
{    return doEstimatePreference(userID, itemID);}
ab5b668aff56c4b19a896c9d2ef06d19c38706242d19fccfbf188d7b923c76a6
getItemInstance
public static IDRescorer getItemInstance()
{    return USER_OR_ITEM_INSTANCE;}
814d16b94c07b737d17330c7a1924922eb8754d55613967067c1f53e6f9daef0
getUserInstance
public static IDRescorer getUserInstance()
{    return USER_OR_ITEM_INSTANCE;}
b8c69d315caafdbb9ad65a63fe4e64dab8da3e36fc7d76e6d152afe14ad7110c
getItemItemPairInstance
public static Rescorer<LongPair> getItemItemPairInstance()
{    return ITEM_ITEM_PAIR_INSTANCE;}
137d55c260aeef6a86f9f9ccf3720311fa81464f015390dc12275fc71955ec8d
getUserUserPairInstance
public static Rescorer<LongPair> getUserUserPairInstance()
{    return USER_USER_PAIR_INSTANCE;}
8376b6a737ec31eaa88431d21e20e907f909a8b7e4c435594e69c915dfa93a37
rescore
public double rescore(T thing, double originalScore)
{    return originalScore;}
0e8f3eed7d9f8ff01276b27b9f8222d8765e6743d3c4852f2a007d280e7b3ffc
isFiltered
public boolean isFiltered(T thing)
{    return false;}
a593670dbd0edf1d425e0a59fdf20591c95fc80cb5c982755b09d98a955b6970
rescore
public double rescore(long id, double originalScore)
{    return originalScore;}
d63e9900eb91ae2e51801ba66c3c6f20548a2d5704278d88bdad6fa337b03b9f
isFiltered
public boolean isFiltered(long id)
{    return false;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "NullRescorer";}
145086b47ca3bb3f97be6e053b2b5a109daa2687ec2ffb7525b41f608b5f8d6f
doGetCandidateItems
protected FastIDSet doGetCandidateItems(long[] preferredItemIDs, DataModel dataModel, boolean includeKnownItems) throws TasteException
{    FastIDSet possibleItemsIDs = new FastIDSet();    for (long itemID : preferredItemIDs) {        PreferenceArray itemPreferences = dataModel.getPreferencesForItem(itemID);        int numUsersPreferringItem = itemPreferences.length();        for (int index = 0; index < numUsersPreferringItem; index++) {            possibleItemsIDs.addAll(dataModel.getItemIDsFromUser(itemPreferences.getUserID(index)));        }    }    if (!includeKnownItems) {        possibleItemsIDs.removeAll(preferredItemIDs);    }    return possibleItemsIDs;}
cae55eaeb500f9cfd9e012eff77e31d3bd1d8c4362d52fedefd3790d2b7900d6
recommend
public List<RecommendedItem> recommend(long userID, int howMany, IDRescorer rescorer, boolean includeKnownItems) throws TasteException
{    DataModel dataModel = getDataModel();    int numItems = dataModel.getNumItems();    List<RecommendedItem> result = new ArrayList<>(howMany);    while (result.size() < howMany) {        LongPrimitiveIterator it = dataModel.getItemIDs();        it.skip(random.nextInt(numItems));        long itemID = it.next();        if (includeKnownItems || dataModel.getPreferenceValue(userID, itemID) == null) {            result.add(new GenericRecommendedItem(itemID, randomPref()));        }    }    return result;}
60ef549812a1fd865a8154b697b50a14f49eb5fbb80973fa689101cc9ebd2032
estimatePreference
public float estimatePreference(long userID, long itemID)
{    return randomPref();}
34cb50c562f778e3bf0c0b6258a7a15aa2d38bce843275ba92bad14dc80a05ae
randomPref
private float randomPref()
{    return minPref + random.nextFloat() * (maxPref - minPref);}
da77e35d28c590f4b271e5b2b7f639c465574b8f17a1ef2f1df63e0152c57e8b
refresh
public void refresh(Collection<Refreshable> alreadyRefreshed)
{    getDataModel().refresh(alreadyRefreshed);}
0f71115806f2702c4da10ea69aaaec9ef9f2bbf1688d663732725648ffc287b8
computeMaxFrom
private static int computeMaxFrom(int factor, int numThings)
{    if (factor == NO_LIMIT_FACTOR) {        return MAX_LIMIT;    }    long max = (long) (factor * (1.0 + Math.log(numThings) / LOG2));    return max > MAX_LIMIT ? MAX_LIMIT : (int) max;}
145086b47ca3bb3f97be6e053b2b5a109daa2687ec2ffb7525b41f608b5f8d6f
doGetCandidateItems
protected FastIDSet doGetCandidateItems(long[] preferredItemIDs, DataModel dataModel, boolean includeKnownItems) throws TasteException
{    LongPrimitiveIterator preferredItemIDsIterator = new LongPrimitiveArrayIterator(preferredItemIDs);    if (preferredItemIDs.length > maxItems) {        double samplingRate = (double) maxItems / preferredItemIDs.length;                preferredItemIDsIterator = new SamplingLongPrimitiveIterator(preferredItemIDsIterator, samplingRate);    }    FastIDSet possibleItemsIDs = new FastIDSet();    while (preferredItemIDsIterator.hasNext()) {        long itemID = preferredItemIDsIterator.nextLong();        PreferenceArray prefs = dataModel.getPreferencesForItem(itemID);        int prefsLength = prefs.length();        if (prefsLength > maxUsersPerItem) {            Iterator<Preference> sampledPrefs = new FixedSizeSamplingIterator<>(maxUsersPerItem, prefs.iterator());            while (sampledPrefs.hasNext()) {                addSomeOf(possibleItemsIDs, dataModel.getItemIDsFromUser(sampledPrefs.next().getUserID()));            }        } else {            for (int i = 0; i < prefsLength; i++) {                addSomeOf(possibleItemsIDs, dataModel.getItemIDsFromUser(prefs.getUserID(i)));            }        }    }    if (!includeKnownItems) {        possibleItemsIDs.removeAll(preferredItemIDs);    }    return possibleItemsIDs;}
b0557edb01279dea6c85b480050a4e352177301ed57beb6e7b081df04605c8a3
addSomeOf
private void addSomeOf(FastIDSet possibleItemIDs, FastIDSet itemIDs)
{    if (itemIDs.size() > maxItemsPerUser) {        LongPrimitiveIterator it = new SamplingLongPrimitiveIterator(itemIDs.iterator(), (double) maxItemsPerUser / itemIDs.size());        while (it.hasNext()) {            possibleItemIDs.add(it.nextLong());        }    } else {        possibleItemIDs.addAll(itemIDs);    }}
3c689e0b3434582d6ca7dcc4520f1b6cf11b119cbe5c3fd3e97d847bdec8f9fb
getUserID
 long getUserID()
{    return userID;}
66fa6a01d33b3c0637c02cf4e4acfa7842ccd8b784ac26ff79c1c56fafed1e98
getSimilarity
 double getSimilarity()
{    return similarity;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return (int) userID ^ RandomUtils.hashDouble(similarity);}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (!(o instanceof SimilarUser)) {        return false;    }    SimilarUser other = (SimilarUser) o;    return userID == other.getUserID() && similarity == other.getSimilarity();}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "SimilarUser[user:" + userID + ", similarity:" + similarity + ']';}
ca3f446bd3d15590806ec54952703456c9eaeda73b6d1d3db997c8230fa964f5
compareTo
public int compareTo(SimilarUser other)
{    double otherSimilarity = other.getSimilarity();    if (similarity > otherSimilarity) {        return -1;    }    if (similarity < otherSimilarity) {        return 1;    }    long otherUserID = other.getUserID();    if (userID < otherUserID) {        return -1;    }    if (userID > otherUserID) {        return 1;    }    return 0;}
d13adffe85ac1c9f2c0398e9ad6f9b9c9e9bdfcb01b3dd0e05ed2d554564383e
call
public Object call() throws TasteException
{    buildMappings();    return null;}
2cf6fc01fe956ad37e57f270db0a264b73e797d0b55823468eba5c9a5354809e
buildMappings
private void buildMappings() throws TasteException
{    userIDMapping = createIDMapping(dataModel.getNumUsers(), dataModel.getUserIDs());    itemIDMapping = createIDMapping(dataModel.getNumItems(), dataModel.getItemIDs());}
f343a2de633ab6f8851357a43a69e8906e1ed0aec3c66655d0820f1a6e4e2a59
createFactorization
protected Factorization createFactorization(double[][] userFeatures, double[][] itemFeatures)
{    return new Factorization(userIDMapping, itemIDMapping, userFeatures, itemFeatures);}
dd8b3e14aa945809329217c428bf26888749751c98502a3d99e66a30e7e0b3a3
userIndex
protected Integer userIndex(long userID)
{    Integer userIndex = userIDMapping.get(userID);    if (userIndex == null) {        userIndex = userIDMapping.size();        userIDMapping.put(userID, userIndex);    }    return userIndex;}
f9699812a7529f57982c48addbffd853239107dee312b717de922f93f3bc549a
itemIndex
protected Integer itemIndex(long itemID)
{    Integer itemIndex = itemIDMapping.get(itemID);    if (itemIndex == null) {        itemIndex = itemIDMapping.size();        itemIDMapping.put(itemID, itemIndex);    }    return itemIndex;}
7911b1929aeb74bdb8351b3817e55d5133d6afa697987cf6c3bbbd54a0fb7b27
createIDMapping
private static FastByIDMap<Integer> createIDMapping(int size, LongPrimitiveIterator idIterator)
{    FastByIDMap<Integer> mapping = new FastByIDMap<>(size);    int index = 0;    while (idIterator.hasNext()) {        mapping.put(idIterator.nextLong(), index++);    }    return mapping;}
da77e35d28c590f4b271e5b2b7f639c465574b8f17a1ef2f1df63e0152c57e8b
refresh
public void refresh(Collection<Refreshable> alreadyRefreshed)
{    refreshHelper.refresh(alreadyRefreshed);}
c65ebe22e3a677d08d225def63f89163b34782894785e0186df61dc37e0478e6
getM
 double[][] getM()
{    return M;}
a21dc3f0fd6afe68ba6105094f13d53a118e80f69dacb4ed6a0efc75693cee03
getU
 double[][] getU()
{    return U;}
8d589f8fb27d8710f59e2419a9dd8b22777c15b356b44156b835421469b2cfda
getUserFeatureColumn
 Vector getUserFeatureColumn(int index)
{    return new DenseVector(U[index]);}
40f666d12a6d14b90670a38ecbba88ac7675644befb33be45beefc847b4441d8
getItemFeatureColumn
 Vector getItemFeatureColumn(int index)
{    return new DenseVector(M[index]);}
39f801c2b62027a2ce19a6ce05a54855875a9bb82bcf48ed7e71983e473cca97
setFeatureColumnInU
 void setFeatureColumnInU(int idIndex, Vector vector)
{    setFeatureColumn(U, idIndex, vector);}
fbf75d5b03df89a8ba080cc7382e7ca0f462ee1c0b68f47f722d75a1e1ffafde
setFeatureColumnInM
 void setFeatureColumnInM(int idIndex, Vector vector)
{    setFeatureColumn(M, idIndex, vector);}
aa3b7abfd9738772146dd63c6ada6f339f865f7be100fc66e2dfa4913ffc981e
setFeatureColumn
protected void setFeatureColumn(double[][] matrix, int idIndex, Vector vector)
{    for (int feature = 0; feature < numFeatures; feature++) {        matrix[idIndex][feature] = vector.get(feature);    }}
65155f348d78ef1ed112d8ff9d541c9c94e963da08cd4c030777f4dfe07d44dc
averateRating
protected double averateRating(long itemID) throws TasteException
{    PreferenceArray prefs = dataModel.getPreferencesForItem(itemID);    RunningAverage avg = new FullRunningAverage();    for (Preference pref : prefs) {        avg.addDatum(pref.getValue());    }    return avg.getAverage();}
8c12d0b02a28eeb877e3a2564a8fdc295b8e3c39fed1a4489a8f06bbc631d33c
factorize
public Factorization factorize() throws TasteException
{    log.info("starting to compute the factorization...");    final Features features = new Features(this);    /* feature maps necessary for solving for implicit feedback */    OpenIntObjectHashMap<Vector> userY = null;    OpenIntObjectHashMap<Vector> itemY = null;    if (usesImplicitFeedback) {        userY = userFeaturesMapping(dataModel.getUserIDs(), dataModel.getNumUsers(), features.getU());        itemY = itemFeaturesMapping(dataModel.getItemIDs(), dataModel.getNumItems(), features.getM());    }    for (int iteration = 0; iteration < numIterations; iteration++) {        log.info("iteration {}", iteration);        /* fix M - compute U */        ExecutorService queue = createQueue();        LongPrimitiveIterator userIDsIterator = dataModel.getUserIDs();        try {            final ImplicitFeedbackAlternatingLeastSquaresSolver implicitFeedbackSolver = usesImplicitFeedback ? new ImplicitFeedbackAlternatingLeastSquaresSolver(numFeatures, lambda, alpha, itemY, numTrainingThreads) : null;            while (userIDsIterator.hasNext()) {                final long userID = userIDsIterator.nextLong();                final LongPrimitiveIterator itemIDsFromUser = dataModel.getItemIDsFromUser(userID).iterator();                final PreferenceArray userPrefs = dataModel.getPreferencesFromUser(userID);                queue.execute(new Runnable() {                    @Override                    public void run() {                        List<Vector> featureVectors = new ArrayList<>();                        while (itemIDsFromUser.hasNext()) {                            long itemID = itemIDsFromUser.nextLong();                            featureVectors.add(features.getItemFeatureColumn(itemIndex(itemID)));                        }                        Vector userFeatures = usesImplicitFeedback ? implicitFeedbackSolver.solve(sparseUserRatingVector(userPrefs)) : AlternatingLeastSquaresSolver.solve(featureVectors, ratingVector(userPrefs), lambda, numFeatures);                        features.setFeatureColumnInU(userIndex(userID), userFeatures);                    }                });            }        } finally {            queue.shutdown();            try {                queue.awaitTermination(dataModel.getNumUsers(), TimeUnit.SECONDS);            } catch (InterruptedException e) {                log.warn("Error when computing user features", e);            }        }        /* fix U - compute M */        queue = createQueue();        LongPrimitiveIterator itemIDsIterator = dataModel.getItemIDs();        try {            final ImplicitFeedbackAlternatingLeastSquaresSolver implicitFeedbackSolver = usesImplicitFeedback ? new ImplicitFeedbackAlternatingLeastSquaresSolver(numFeatures, lambda, alpha, userY, numTrainingThreads) : null;            while (itemIDsIterator.hasNext()) {                final long itemID = itemIDsIterator.nextLong();                final PreferenceArray itemPrefs = dataModel.getPreferencesForItem(itemID);                queue.execute(new Runnable() {                    @Override                    public void run() {                        List<Vector> featureVectors = new ArrayList<>();                        for (Preference pref : itemPrefs) {                            long userID = pref.getUserID();                            featureVectors.add(features.getUserFeatureColumn(userIndex(userID)));                        }                        Vector itemFeatures = usesImplicitFeedback ? implicitFeedbackSolver.solve(sparseItemRatingVector(itemPrefs)) : AlternatingLeastSquaresSolver.solve(featureVectors, ratingVector(itemPrefs), lambda, numFeatures);                        features.setFeatureColumnInM(itemIndex(itemID), itemFeatures);                    }                });            }        } finally {            queue.shutdown();            try {                queue.awaitTermination(dataModel.getNumItems(), TimeUnit.SECONDS);            } catch (InterruptedException e) {                log.warn("Error when computing item features", e);            }        }    }    log.info("finished computation of the factorization...");    return createFactorization(features.getU(), features.getM());}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    List<Vector> featureVectors = new ArrayList<>();    while (itemIDsFromUser.hasNext()) {        long itemID = itemIDsFromUser.nextLong();        featureVectors.add(features.getItemFeatureColumn(itemIndex(itemID)));    }    Vector userFeatures = usesImplicitFeedback ? implicitFeedbackSolver.solve(sparseUserRatingVector(userPrefs)) : AlternatingLeastSquaresSolver.solve(featureVectors, ratingVector(userPrefs), lambda, numFeatures);    features.setFeatureColumnInU(userIndex(userID), userFeatures);}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    List<Vector> featureVectors = new ArrayList<>();    for (Preference pref : itemPrefs) {        long userID = pref.getUserID();        featureVectors.add(features.getUserFeatureColumn(userIndex(userID)));    }    Vector itemFeatures = usesImplicitFeedback ? implicitFeedbackSolver.solve(sparseItemRatingVector(itemPrefs)) : AlternatingLeastSquaresSolver.solve(featureVectors, ratingVector(itemPrefs), lambda, numFeatures);    features.setFeatureColumnInM(itemIndex(itemID), itemFeatures);}
27c99666b03955565d50791913d99d82e1f91ed51d6c700954c89a2bc71c6adb
createQueue
protected ExecutorService createQueue()
{    return Executors.newFixedThreadPool(numTrainingThreads);}
bd5036dd06f021dfb34be4fd1a0bbfff3abb224751598b4334b35798d7371e93
ratingVector
protected static Vector ratingVector(PreferenceArray prefs)
{    double[] ratings = new double[prefs.length()];    for (int n = 0; n < prefs.length(); n++) {        ratings[n] = prefs.get(n).getValue();    }    return new DenseVector(ratings, true);}
f4a24096fe50cd696a582b53f29a90aa7a77b8de4be6aee24fb26dbd65332ab5
itemFeaturesMapping
protected OpenIntObjectHashMap<Vector> itemFeaturesMapping(LongPrimitiveIterator itemIDs, int numItems, double[][] featureMatrix)
{    OpenIntObjectHashMap<Vector> mapping = new OpenIntObjectHashMap<>(numItems);    while (itemIDs.hasNext()) {        long itemID = itemIDs.next();        int itemIndex = itemIndex(itemID);        mapping.put(itemIndex, new DenseVector(featureMatrix[itemIndex(itemID)], true));    }    return mapping;}
77a7ef4c6ddf6ec5a77eeef8f6b7598ab7d2c2f90bf0e9718a16d2152db3b9b8
userFeaturesMapping
protected OpenIntObjectHashMap<Vector> userFeaturesMapping(LongPrimitiveIterator userIDs, int numUsers, double[][] featureMatrix)
{    OpenIntObjectHashMap<Vector> mapping = new OpenIntObjectHashMap<>(numUsers);    while (userIDs.hasNext()) {        long userID = userIDs.next();        int userIndex = userIndex(userID);        mapping.put(userIndex, new DenseVector(featureMatrix[userIndex(userID)], true));    }    return mapping;}
c14ceca365a1f8adc90b7b2e3cda354222e6c598af73ca4ff0a9179ccc12b5ef
sparseItemRatingVector
protected Vector sparseItemRatingVector(PreferenceArray prefs)
{    SequentialAccessSparseVector ratings = new SequentialAccessSparseVector(Integer.MAX_VALUE, prefs.length());    for (Preference preference : prefs) {        ratings.set(userIndex(preference.getUserID()), preference.getValue());    }    return ratings;}
711cfbc68634660de1bc5bff494ca182e56b0a74217bc523b9daa8c4bf0f177d
sparseUserRatingVector
protected Vector sparseUserRatingVector(PreferenceArray prefs)
{    SequentialAccessSparseVector ratings = new SequentialAccessSparseVector(Integer.MAX_VALUE, prefs.length());    for (Preference preference : prefs) {        ratings.set(itemIndex(preference.getItemID()), preference.getValue());    }    return ratings;}
649bd7ae35d52a9354d1e123c73efb74e37022500e251512b6bb7a7109d733f2
allUserFeatures
public double[][] allUserFeatures()
{    return userFeatures;}
5b2bd7829c70de94e11d9712d7b81c654486df68d0e94318ce455a1c4e990bc6
getUserFeatures
public double[] getUserFeatures(long userID) throws NoSuchUserException
{    Integer index = userIDMapping.get(userID);    if (index == null) {        throw new NoSuchUserException(userID);    }    return userFeatures[index];}
47c91612db7ddaf37799bf82617a29fb1e1420c8087890454bcd3d4702ae9dc8
allItemFeatures
public double[][] allItemFeatures()
{    return itemFeatures;}
cde04b192dfe810b09b1d1e3cadd83088f6fb8ac340b3166f94ba4017f8b6325
getItemFeatures
public double[] getItemFeatures(long itemID) throws NoSuchItemException
{    Integer index = itemIDMapping.get(itemID);    if (index == null) {        throw new NoSuchItemException(itemID);    }    return itemFeatures[index];}
696a1cc1fed51b463e412136fbb454cb3eb6283b7a6ee09949efb30ed4620305
userIndex
public int userIndex(long userID) throws NoSuchUserException
{    Integer index = userIDMapping.get(userID);    if (index == null) {        throw new NoSuchUserException(userID);    }    return index;}
773ad3407c6ad67642519b15b61a2f6533ebbf5c45bcf630c7d76d4135c4d219
getUserIDMappings
public Iterable<Map.Entry<Long, Integer>> getUserIDMappings()
{    return userIDMapping.entrySet();}
6b22a9e94023a7d62b6ea33bb00c5ae5222ffc7c7e30ac7480d27de1dfc29895
getUserIDMappingKeys
public LongPrimitiveIterator getUserIDMappingKeys()
{    return userIDMapping.keySetIterator();}
3b99543344fa9d4358f2ccaf00f682733db0521e478c181f38cef815e6e707be
itemIndex
public int itemIndex(long itemID) throws NoSuchItemException
{    Integer index = itemIDMapping.get(itemID);    if (index == null) {        throw new NoSuchItemException(itemID);    }    return index;}
1e0d743c9049c6c124de9d8eaed18e5f8d90df672e141235ff652174448ae2fd
getItemIDMappings
public Iterable<Map.Entry<Long, Integer>> getItemIDMappings()
{    return itemIDMapping.entrySet();}
e3cbd2dfe49f312ea51e070f612436ef33b58cf2f34704e0aed9a7aab3ec0ec4
getItemIDMappingKeys
public LongPrimitiveIterator getItemIDMappingKeys()
{    return itemIDMapping.keySetIterator();}
e5a3cd58a1672c77f7fc460a19f0294e3e9cfaa65394aec1fa2e316fe4065a33
numFeatures
public int numFeatures()
{    return userFeatures.length > 0 ? userFeatures[0].length : 0;}
8e062c730a4a25a407b12b8cef1c735f08ba7e3ed49d7b95ada5aabb32412520
numUsers
public int numUsers()
{    return userIDMapping.size();}
272e0197d41c5da0849218d2f769be1b08e092fa8bc928a93599b60b44b9862e
numItems
public int numItems()
{    return itemIDMapping.size();}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (o instanceof Factorization) {        Factorization other = (Factorization) o;        return userIDMapping.equals(other.userIDMapping) && itemIDMapping.equals(other.itemIDMapping) && Arrays.deepEquals(userFeatures, other.userFeatures) && Arrays.deepEquals(itemFeatures, other.itemFeatures);    }    return false;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    int hashCode = 31 * userIDMapping.hashCode() + itemIDMapping.hashCode();    hashCode = 31 * hashCode + Arrays.deepHashCode(userFeatures);    hashCode = 31 * hashCode + Arrays.deepHashCode(itemFeatures);    return hashCode;}
4ec8f461166d877f5f4771b642c53484c506d03ec503e5280a936f35c295d8ea
load
public Factorization load() throws IOException
{    if (!file.exists()) {        log.info("{} does not yet exist, no factorization found", file.getAbsolutePath());        return null;    }    try (DataInputStream in = new DataInputStream(new BufferedInputStream(new FileInputStream(file)))) {        log.info("Reading factorization from {}...", file.getAbsolutePath());        return readBinary(in);    }}
8d8dd588a95731f7713aa1c75d7c0fdd62c4bbd0482c4e09d767a6ab654278c4
maybePersist
public void maybePersist(Factorization factorization) throws IOException
{    try (DataOutputStream out = new DataOutputStream(new BufferedOutputStream(new FileOutputStream(file)))) {        log.info("Writing factorization to {}...", file.getAbsolutePath());        writeBinary(factorization, out);    }}
31d161c571ce0631e85102551e2b836ae7f143195406bf2d10ed5e905bea642b
writeBinary
protected static void writeBinary(Factorization factorization, DataOutput out) throws IOException
{    out.writeInt(factorization.numFeatures());    out.writeInt(factorization.numUsers());    out.writeInt(factorization.numItems());    for (Map.Entry<Long, Integer> mappingEntry : factorization.getUserIDMappings()) {        long userID = mappingEntry.getKey();        out.writeInt(mappingEntry.getValue());        out.writeLong(userID);        try {            double[] userFeatures = factorization.getUserFeatures(userID);            for (int feature = 0; feature < factorization.numFeatures(); feature++) {                out.writeDouble(userFeatures[feature]);            }        } catch (NoSuchUserException e) {            throw new IOException("Unable to persist factorization", e);        }    }    for (Map.Entry<Long, Integer> entry : factorization.getItemIDMappings()) {        long itemID = entry.getKey();        out.writeInt(entry.getValue());        out.writeLong(itemID);        try {            double[] itemFeatures = factorization.getItemFeatures(itemID);            for (int feature = 0; feature < factorization.numFeatures(); feature++) {                out.writeDouble(itemFeatures[feature]);            }        } catch (NoSuchItemException e) {            throw new IOException("Unable to persist factorization", e);        }    }}
c0d79521e2946d02a4b4804bd3aef9d052aaec0f1d9891aeb6df4400a9b7f3a7
readBinary
public static Factorization readBinary(DataInput in) throws IOException
{    int numFeatures = in.readInt();    int numUsers = in.readInt();    int numItems = in.readInt();    FastByIDMap<Integer> userIDMapping = new FastByIDMap<>(numUsers);    double[][] userFeatures = new double[numUsers][numFeatures];    for (int n = 0; n < numUsers; n++) {        int userIndex = in.readInt();        long userID = in.readLong();        userIDMapping.put(userID, userIndex);        for (int feature = 0; feature < numFeatures; feature++) {            userFeatures[userIndex][feature] = in.readDouble();        }    }    FastByIDMap<Integer> itemIDMapping = new FastByIDMap<>(numItems);    double[][] itemFeatures = new double[numItems][numFeatures];    for (int n = 0; n < numItems; n++) {        int itemIndex = in.readInt();        long itemID = in.readLong();        itemIDMapping.put(itemID, itemIndex);        for (int feature = 0; feature < numFeatures; feature++) {            itemFeatures[itemIndex][feature] = in.readDouble();        }    }    return new Factorization(userIDMapping, itemIDMapping, userFeatures, itemFeatures);}
4ec8f461166d877f5f4771b642c53484c506d03ec503e5280a936f35c295d8ea
load
public Factorization load() throws IOException
{    return null;}
8d8dd588a95731f7713aa1c75d7c0fdd62c4bbd0482c4e09d767a6ab654278c4
maybePersist
public void maybePersist(Factorization factorization) throws IOException
{}
514f7307da3832b12a09c9045f2f610fc842d72233e15f61e190a13804715844
countPreferences
private int countPreferences(DataModel dataModel) throws TasteException
{    int numPreferences = 0;    LongPrimitiveIterator userIDs = dataModel.getUserIDs();    while (userIDs.hasNext()) {        PreferenceArray preferencesFromUser = dataModel.getPreferencesFromUser(userIDs.nextLong());        numPreferences += preferencesFromUser.length();    }    return numPreferences;}
fd7a8612f05a99abce5322358415ec2c1885ee27675cfe8cb7a224bb1f1284e3
cachePreferences
private void cachePreferences(DataModel dataModel) throws TasteException
{    int numPreferences = countPreferences(dataModel);    preferences = new Preference[numPreferences];    LongPrimitiveIterator userIDs = dataModel.getUserIDs();    int index = 0;    while (userIDs.hasNext()) {        long userID = userIDs.nextLong();        PreferenceArray preferencesFromUser = dataModel.getPreferencesFromUser(userID);        for (Preference preference : preferencesFromUser) {            preferences[index++] = preference;        }    }}
c5b6e043e63ea2453661a25ef07bed644a6862256bed0c06ef033474ddf19612
shuffle
public final void shuffle()
{    unstagedPreferences = preferences.clone();    /* Durstenfeld shuffle */    for (int i = unstagedPreferences.length - 1; i > 0; i--) {        int rand = random.nextInt(i + 1);        swapCachedPreferences(i, rand);    }}
9c04d017c564cbffa80b7c6e1173cd209b1633f3770ade4b3224651c92c72540
swapCachedPreferences
private void swapCachedPreferences(int x, int y)
{    Preference p = unstagedPreferences[x];    unstagedPreferences[x] = unstagedPreferences[y];    unstagedPreferences[y] = p;}
68488bae364e4d9aad39ef8d3c1d7ee546c31f70337bf200285c4f378a16c1eb
stage
public final void stage()
{    preferences = unstagedPreferences;}
1466676badc459d75b4519e8418977e534b8541086db5c066b3452edeec1c2f9
get
public Preference get(int i)
{    return preferences[i];}
72ef1e59027007ffe0950edfd2670ad03bb65cd6463d5d1d282dfeb1750435b0
size
public int size()
{    return preferences.length;}
41f94ba750e9cbfce8df93f61c549a188f6dd6c26ceb0dc4dafa6bb40825bd71
initialize
protected void initialize() throws TasteException
{    RandomWrapper random = RandomUtils.getRandom();    userVectors = new double[dataModel.getNumUsers()][rank];    itemVectors = new double[dataModel.getNumItems()][rank];    double globalAverage = getAveragePreference();    for (int userIndex = 0; userIndex < userVectors.length; userIndex++) {        userVectors[userIndex][0] = globalAverage;                userVectors[userIndex][USER_BIAS_INDEX] = 0;                userVectors[userIndex][ITEM_BIAS_INDEX] = 1;        for (int feature = FEATURE_OFFSET; feature < rank; feature++) {            userVectors[userIndex][feature] = random.nextGaussian() * NOISE;        }    }    for (int itemIndex = 0; itemIndex < itemVectors.length; itemIndex++) {                itemVectors[itemIndex][0] = 1;                itemVectors[itemIndex][USER_BIAS_INDEX] = 1;                itemVectors[itemIndex][ITEM_BIAS_INDEX] = 0;        for (int feature = FEATURE_OFFSET; feature < rank; feature++) {            itemVectors[itemIndex][feature] = random.nextGaussian() * NOISE;        }    }}
c4631336ebb3726304bd0ad7be18ca636d9cc8f82c96f6f570c2f6a6b3344d27
getMu
private double getMu(int i)
{    return mu0 * Math.pow(decayFactor, i - 1) * Math.pow(i + stepOffset, forgettingExponent);}
8c12d0b02a28eeb877e3a2564a8fdc295b8e3c39fed1a4489a8f06bbc631d33c
factorize
public Factorization factorize() throws TasteException
{    initialize();    if (logger.isInfoEnabled()) {        logger.info("starting to compute the factorization...");    }    for (epoch = 1; epoch <= numEpochs; epoch++) {        shuffler.stage();        final double mu = getMu(epoch);        int subSize = shuffler.size() / numThreads + 1;        ExecutorService executor = Executors.newFixedThreadPool(numThreads);        try {            for (int t = 0; t < numThreads; t++) {                final int iStart = t * subSize;                final int iEnd = Math.min((t + 1) * subSize, shuffler.size());                executor.execute(new Runnable() {                    @Override                    public void run() {                        for (int i = iStart; i < iEnd; i++) {                            update(shuffler.get(i), mu);                        }                    }                });            }        } finally {            executor.shutdown();            shuffler.shuffle();            try {                boolean terminated = executor.awaitTermination(numEpochs * shuffler.size(), TimeUnit.MICROSECONDS);                if (!terminated) {                    logger.error("subtasks takes forever, return anyway");                }            } catch (InterruptedException e) {                throw new TasteException("waiting fof termination interrupted", e);            }        }    }    return createFactorization(userVectors, itemVectors);}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    for (int i = iStart; i < iEnd; i++) {        update(shuffler.get(i), mu);    }}
af26e16ff590d46358a87bbca0faae6cabe512c283c7612dfa5585ab0249e80e
getAveragePreference
 double getAveragePreference() throws TasteException
{    RunningAverage average = new FullRunningAverage();    LongPrimitiveIterator it = dataModel.getUserIDs();    while (it.hasNext()) {        for (Preference pref : dataModel.getPreferencesFromUser(it.nextLong())) {            average.addDatum(pref.getValue());        }    }    return average.getAverage();}
ddb4d0c5be5c6b12f6d019ae1e2e0dc5ddea038ddda7ac7ee7cd8cd94b83a6fb
update
protected void update(Preference preference, double mu)
{    int userIndex = userIndex(preference.getUserID());    int itemIndex = itemIndex(preference.getItemID());    double[] userVector = userVectors[userIndex];    double[] itemVector = itemVectors[itemIndex];    double prediction = dot(userVector, itemVector);    double err = preference.getValue() - prediction;        for (int k = FEATURE_OFFSET; k < rank; k++) {        double userFeature = userVector[k];        double itemFeature = itemVector[k];        userVector[k] += mu * (err * itemFeature - lambda * userFeature);        itemVector[k] += mu * (err * userFeature - lambda * itemFeature);    }        userVector[USER_BIAS_INDEX] += biasMuRatio * mu * (err - biasLambdaRatio * lambda * userVector[USER_BIAS_INDEX]);    itemVector[ITEM_BIAS_INDEX] += biasMuRatio * mu * (err - biasLambdaRatio * lambda * itemVector[ITEM_BIAS_INDEX]);}
e09792d3812bad8e248ef59c41cd17102897c62d126e1786dbb6c40a6236190f
dot
private double dot(double[] userVector, double[] itemVector)
{    double sum = 0;    for (int k = 0; k < rank; k++) {        sum += userVector[k] * itemVector[k];    }    return sum;}
32e7c1b51643b92d3fce548717634bfb1c77613469363c57d4c878e17a140ed2
prepareTraining
protected void prepareTraining() throws TasteException
{    RandomWrapper random = RandomUtils.getRandom();    userVectors = new double[dataModel.getNumUsers()][numFeatures];    itemVectors = new double[dataModel.getNumItems()][numFeatures];    double globalAverage = getAveragePreference();    for (int userIndex = 0; userIndex < userVectors.length; userIndex++) {        userVectors[userIndex][0] = globalAverage;                userVectors[userIndex][USER_BIAS_INDEX] = 0;                userVectors[userIndex][ITEM_BIAS_INDEX] = 1;        for (int feature = FEATURE_OFFSET; feature < numFeatures; feature++) {            userVectors[userIndex][feature] = random.nextGaussian() * randomNoise;        }    }    for (int itemIndex = 0; itemIndex < itemVectors.length; itemIndex++) {                itemVectors[itemIndex][0] = 1;                itemVectors[itemIndex][USER_BIAS_INDEX] = 1;                itemVectors[itemIndex][ITEM_BIAS_INDEX] = 0;        for (int feature = FEATURE_OFFSET; feature < numFeatures; feature++) {            itemVectors[itemIndex][feature] = random.nextGaussian() * randomNoise;        }    }    cachePreferences();    shufflePreferences();}
bd57ce070ff8ea8433949f6eb4f160f9d21d92d48eab1f4532aa60dad7d42918
countPreferences
private int countPreferences() throws TasteException
{    int numPreferences = 0;    LongPrimitiveIterator userIDs = dataModel.getUserIDs();    while (userIDs.hasNext()) {        PreferenceArray preferencesFromUser = dataModel.getPreferencesFromUser(userIDs.nextLong());        numPreferences += preferencesFromUser.length();    }    return numPreferences;}
b22cdc4ca723fedf37dbd33a5b28f812a9d83214a24d835d242ff01f6c549df7
cachePreferences
private void cachePreferences() throws TasteException
{    int numPreferences = countPreferences();    cachedUserIDs = new long[numPreferences];    cachedItemIDs = new long[numPreferences];    LongPrimitiveIterator userIDs = dataModel.getUserIDs();    int index = 0;    while (userIDs.hasNext()) {        long userID = userIDs.nextLong();        PreferenceArray preferencesFromUser = dataModel.getPreferencesFromUser(userID);        for (Preference preference : preferencesFromUser) {            cachedUserIDs[index] = userID;            cachedItemIDs[index] = preference.getItemID();            index++;        }    }}
71e467a976ae86917ed43c6480678c0f2b9be6be5f52147c92330e556277bbf8
shufflePreferences
protected void shufflePreferences()
{    RandomWrapper random = RandomUtils.getRandom();    /* Durstenfeld shuffle */    for (int currentPos = cachedUserIDs.length - 1; currentPos > 0; currentPos--) {        int swapPos = random.nextInt(currentPos + 1);        swapCachedPreferences(currentPos, swapPos);    }}
490462263f6ebc120630f50ebe3a5c7e9488ebc958d5be930a54c587b7e5e727
swapCachedPreferences
private void swapCachedPreferences(int posA, int posB)
{    long tmpUserIndex = cachedUserIDs[posA];    long tmpItemIndex = cachedItemIDs[posA];    cachedUserIDs[posA] = cachedUserIDs[posB];    cachedItemIDs[posA] = cachedItemIDs[posB];    cachedUserIDs[posB] = tmpUserIndex;    cachedItemIDs[posB] = tmpItemIndex;}
8c12d0b02a28eeb877e3a2564a8fdc295b8e3c39fed1a4489a8f06bbc631d33c
factorize
public Factorization factorize() throws TasteException
{    prepareTraining();    double currentLearningRate = learningRate;    for (int it = 0; it < numIterations; it++) {        for (int index = 0; index < cachedUserIDs.length; index++) {            long userId = cachedUserIDs[index];            long itemId = cachedItemIDs[index];            float rating = dataModel.getPreferenceValue(userId, itemId);            updateParameters(userId, itemId, rating, currentLearningRate);        }        currentLearningRate *= learningRateDecay;    }    return createFactorization(userVectors, itemVectors);}
af26e16ff590d46358a87bbca0faae6cabe512c283c7612dfa5585ab0249e80e
getAveragePreference
 double getAveragePreference() throws TasteException
{    RunningAverage average = new FullRunningAverage();    LongPrimitiveIterator it = dataModel.getUserIDs();    while (it.hasNext()) {        for (Preference pref : dataModel.getPreferencesFromUser(it.nextLong())) {            average.addDatum(pref.getValue());        }    }    return average.getAverage();}
316897dc0f11a24d7d199f9c8514226e112a4af9b4289084e37ffd38002652b1
updateParameters
protected void updateParameters(long userID, long itemID, float rating, double currentLearningRate)
{    int userIndex = userIndex(userID);    int itemIndex = itemIndex(itemID);    double[] userVector = userVectors[userIndex];    double[] itemVector = itemVectors[itemIndex];    double prediction = predictRating(userIndex, itemIndex);    double err = rating - prediction;        userVector[USER_BIAS_INDEX] += biasLearningRate * currentLearningRate * (err - biasReg * preventOverfitting * userVector[USER_BIAS_INDEX]);        itemVector[ITEM_BIAS_INDEX] += biasLearningRate * currentLearningRate * (err - biasReg * preventOverfitting * itemVector[ITEM_BIAS_INDEX]);        for (int feature = FEATURE_OFFSET; feature < numFeatures; feature++) {        double userFeature = userVector[feature];        double itemFeature = itemVector[feature];        double deltaUserFeature = err * itemFeature - preventOverfitting * userFeature;        userVector[feature] += currentLearningRate * deltaUserFeature;        double deltaItemFeature = err * userFeature - preventOverfitting * itemFeature;        itemVector[feature] += currentLearningRate * deltaItemFeature;    }}
f903d1013ec7cd9303d64cda5c49466c7d8a0d177744b148306ea01fff8408f4
predictRating
private double predictRating(int userID, int itemID)
{    double sum = 0;    for (int feature = 0; feature < numFeatures; feature++) {        sum += userVectors[userID][feature] * itemVectors[itemID][feature];    }    return sum;}
32e7c1b51643b92d3fce548717634bfb1c77613469363c57d4c878e17a140ed2
prepareTraining
protected void prepareTraining() throws TasteException
{    super.prepareTraining();    Random random = RandomUtils.getRandom();    p = new double[dataModel.getNumUsers()][numFeatures];    for (int i = 0; i < p.length; i++) {        for (int feature = 0; feature < FEATURE_OFFSET; feature++) {            p[i][feature] = 0;        }        for (int feature = FEATURE_OFFSET; feature < numFeatures; feature++) {            p[i][feature] = random.nextGaussian() * randomNoise;        }    }    y = new double[dataModel.getNumItems()][numFeatures];    for (int i = 0; i < y.length; i++) {        for (int feature = 0; feature < FEATURE_OFFSET; feature++) {            y[i][feature] = 0;        }        for (int feature = FEATURE_OFFSET; feature < numFeatures; feature++) {            y[i][feature] = random.nextGaussian() * randomNoise;        }    }    /* get internal item IDs which we will need several times */    itemsByUser = new HashMap<>();    LongPrimitiveIterator userIDs = dataModel.getUserIDs();    while (userIDs.hasNext()) {        long userId = userIDs.nextLong();        int userIndex = userIndex(userId);        FastIDSet itemIDsFromUser = dataModel.getItemIDsFromUser(userId);        List<Integer> itemIndexes = new ArrayList<>(itemIDsFromUser.size());        itemsByUser.put(userIndex, itemIndexes);        for (long itemID2 : itemIDsFromUser) {            int i2 = itemIndex(itemID2);            itemIndexes.add(i2);        }    }}
8c12d0b02a28eeb877e3a2564a8fdc295b8e3c39fed1a4489a8f06bbc631d33c
factorize
public Factorization factorize() throws TasteException
{    prepareTraining();    super.factorize();    for (int userIndex = 0; userIndex < userVectors.length; userIndex++) {        for (int itemIndex : itemsByUser.get(userIndex)) {            for (int feature = FEATURE_OFFSET; feature < numFeatures; feature++) {                userVectors[userIndex][feature] += y[itemIndex][feature];            }        }        double denominator = Math.sqrt(itemsByUser.get(userIndex).size());        for (int feature = 0; feature < userVectors[userIndex].length; feature++) {            userVectors[userIndex][feature] = (float) (userVectors[userIndex][feature] / denominator + p[userIndex][feature]);        }    }    return createFactorization(userVectors, itemVectors);}
316897dc0f11a24d7d199f9c8514226e112a4af9b4289084e37ffd38002652b1
updateParameters
protected void updateParameters(long userID, long itemID, float rating, double currentLearningRate)
{    int userIndex = userIndex(userID);    int itemIndex = itemIndex(itemID);    double[] userVector = p[userIndex];    double[] itemVector = itemVectors[itemIndex];    double[] pPlusY = new double[numFeatures];    for (int i2 : itemsByUser.get(userIndex)) {        for (int f = FEATURE_OFFSET; f < numFeatures; f++) {            pPlusY[f] += y[i2][f];        }    }    double denominator = Math.sqrt(itemsByUser.get(userIndex).size());    for (int feature = 0; feature < pPlusY.length; feature++) {        pPlusY[feature] = (float) (pPlusY[feature] / denominator + p[userIndex][feature]);    }    double prediction = predictRating(pPlusY, itemIndex);    double err = rating - prediction;    double normalized_error = err / denominator;        userVector[USER_BIAS_INDEX] += biasLearningRate * currentLearningRate * (err - biasReg * preventOverfitting * userVector[USER_BIAS_INDEX]);        itemVector[ITEM_BIAS_INDEX] += biasLearningRate * currentLearningRate * (err - biasReg * preventOverfitting * itemVector[ITEM_BIAS_INDEX]);        for (int feature = FEATURE_OFFSET; feature < numFeatures; feature++) {        double pF = userVector[feature];        double iF = itemVector[feature];        double deltaU = err * iF - preventOverfitting * pF;        userVector[feature] += currentLearningRate * deltaU;        double deltaI = err * pPlusY[feature] - preventOverfitting * iF;        itemVector[feature] += currentLearningRate * deltaI;        double commonUpdate = normalized_error * iF;        for (int itemIndex2 : itemsByUser.get(userIndex)) {            double deltaI2 = commonUpdate - preventOverfitting * y[itemIndex2][feature];            y[itemIndex2][feature] += learningRate * deltaI2;        }    }}
431b90df27231f9728df7d3c5636e391eb4d068ebea1574d9abffc50b74bda0a
predictRating
private double predictRating(double[] userVector, int itemID)
{    double sum = 0;    for (int feature = 0; feature < numFeatures; feature++) {        sum += userVector[feature] * itemVectors[itemID][feature];    }    return sum;}
8f7a16f1cf510906eec8437769b01496c738959d379edd1c2a9f7c3d376fcd1c
getCache
public double getCache()
{    return cache;}
e1b9cd39ec20030ce79ac89ec244f8d82c6cbce8db30bf85707941386286a4bb
setCache
public void setCache(double value)
{    Preconditions.checkArgument(!Double.isNaN(value), "NaN cache value");    this.cache = value;}
d13adffe85ac1c9f2c0398e9ad6f9b9c9e9bdfcb01b3dd0e05ed2d554564383e
call
public Object call() throws TasteException
{    train();    return null;}
a2836c06b936dd9bad8bb5964a710b4359a0810716fc95a549834371b813da2e
getDefaultPersistenceStrategy
 static PersistenceStrategy getDefaultPersistenceStrategy()
{    return new NoPersistenceStrategy();}
b358d85dbcfab2feb97524015fe46a27bcebb5c3b19f6d0526d2ca343effdc32
train
private void train() throws TasteException
{    factorization = factorizer.factorize();    try {        persistenceStrategy.maybePersist(factorization);    } catch (IOException e) {        throw new TasteException("Error persisting factorization", e);    }}
cae55eaeb500f9cfd9e012eff77e31d3bd1d8c4362d52fedefd3790d2b7900d6
recommend
public List<RecommendedItem> recommend(long userID, int howMany, IDRescorer rescorer, boolean includeKnownItems) throws TasteException
{    Preconditions.checkArgument(howMany >= 1, "howMany must be at least 1");    log.debug("Recommending items for user ID '{}'", userID);    PreferenceArray preferencesFromUser = getDataModel().getPreferencesFromUser(userID);    FastIDSet possibleItemIDs = getAllOtherItems(userID, preferencesFromUser, includeKnownItems);    List<RecommendedItem> topItems = TopItems.getTopItems(howMany, possibleItemIDs.iterator(), rescorer, new Estimator(userID));    log.debug("Recommendations are: {}", topItems);    return topItems;}
fe4075a1aad10eb52e9a33b25ff2a59f9af6b1541778182edc3aa82095b47ee2
estimatePreference
public float estimatePreference(long userID, long itemID) throws TasteException
{    double[] userFeatures = factorization.getUserFeatures(userID);    double[] itemFeatures = factorization.getItemFeatures(itemID);    double estimate = 0;    for (int feature = 0; feature < userFeatures.length; feature++) {        estimate += userFeatures[feature] * itemFeatures[feature];    }    return (float) estimate;}
bd8b618f7a1dcbe655acf589cb5cc38ff260f28f181c287b3629af36a5a81437
estimate
public double estimate(Long itemID) throws TasteException
{    return estimatePreference(theUserID, itemID);}
da77e35d28c590f4b271e5b2b7f639c465574b8f17a1ef2f1df63e0152c57e8b
refresh
public void refresh(Collection<Refreshable> alreadyRefreshed)
{    refreshHelper.refresh(alreadyRefreshed);}
c8090d2735a99a8eab051fff00419789d7e3ee105f8b636e1a325ab431a84d09
getTopItems
public static List<RecommendedItem> getTopItems(int howMany, LongPrimitiveIterator possibleItemIDs, IDRescorer rescorer, Estimator<Long> estimator) throws TasteException
{    Preconditions.checkArgument(possibleItemIDs != null, "possibleItemIDs is null");    Preconditions.checkArgument(estimator != null, "estimator is null");    Queue<RecommendedItem> topItems = new PriorityQueue<>(howMany + 1, Collections.reverseOrder(ByValueRecommendedItemComparator.getInstance()));    boolean full = false;    double lowestTopValue = Double.NEGATIVE_INFINITY;    while (possibleItemIDs.hasNext()) {        long itemID = possibleItemIDs.next();        if (rescorer == null || !rescorer.isFiltered(itemID)) {            double preference;            try {                preference = estimator.estimate(itemID);            } catch (NoSuchItemException nsie) {                continue;            }            double rescoredPref = rescorer == null ? preference : rescorer.rescore(itemID, preference);            if (!Double.isNaN(rescoredPref) && (!full || rescoredPref > lowestTopValue)) {                topItems.add(new GenericRecommendedItem(itemID, (float) rescoredPref));                if (full) {                    topItems.poll();                } else if (topItems.size() > howMany) {                    full = true;                    topItems.poll();                }                lowestTopValue = topItems.peek().getValue();            }        }    }    int size = topItems.size();    if (size == 0) {        return Collections.emptyList();    }    List<RecommendedItem> result = new ArrayList<>(size);    result.addAll(topItems);    Collections.sort(result, ByValueRecommendedItemComparator.getInstance());    return result;}
48820786208b34a5aff1b73104adcf0b268eab4e425c3eeb6439b5f00e2e49c6
getTopUsers
public static long[] getTopUsers(int howMany, LongPrimitiveIterator allUserIDs, IDRescorer rescorer, Estimator<Long> estimator) throws TasteException
{    Queue<SimilarUser> topUsers = new PriorityQueue<>(howMany + 1, Collections.reverseOrder());    boolean full = false;    double lowestTopValue = Double.NEGATIVE_INFINITY;    while (allUserIDs.hasNext()) {        long userID = allUserIDs.next();        if (rescorer != null && rescorer.isFiltered(userID)) {            continue;        }        double similarity;        try {            similarity = estimator.estimate(userID);        } catch (NoSuchUserException nsue) {            continue;        }        double rescoredSimilarity = rescorer == null ? similarity : rescorer.rescore(userID, similarity);        if (!Double.isNaN(rescoredSimilarity) && (!full || rescoredSimilarity > lowestTopValue)) {            topUsers.add(new SimilarUser(userID, rescoredSimilarity));            if (full) {                topUsers.poll();            } else if (topUsers.size() > howMany) {                full = true;                topUsers.poll();            }            lowestTopValue = topUsers.peek().getSimilarity();        }    }    int size = topUsers.size();    if (size == 0) {        return NO_IDS;    }    List<SimilarUser> sorted = new ArrayList<>(size);    sorted.addAll(topUsers);    Collections.sort(sorted);    long[] result = new long[size];    int i = 0;    for (SimilarUser similarUser : sorted) {        result[i++] = similarUser.getUserID();    }    return result;}
e968df3ba1f19cde257505de8c9fb46cb9ec9b7efb9dc91d598cf3a37e1c727e
getTopItemItemSimilarities
public static List<GenericItemSimilarity.ItemItemSimilarity> getTopItemItemSimilarities(int howMany, Iterator<GenericItemSimilarity.ItemItemSimilarity> allSimilarities)
{    Queue<GenericItemSimilarity.ItemItemSimilarity> topSimilarities = new PriorityQueue<>(howMany + 1, Collections.reverseOrder());    boolean full = false;    double lowestTopValue = Double.NEGATIVE_INFINITY;    while (allSimilarities.hasNext()) {        GenericItemSimilarity.ItemItemSimilarity similarity = allSimilarities.next();        double value = similarity.getValue();        if (!Double.isNaN(value) && (!full || value > lowestTopValue)) {            topSimilarities.add(similarity);            if (full) {                topSimilarities.poll();            } else if (topSimilarities.size() > howMany) {                full = true;                topSimilarities.poll();            }            lowestTopValue = topSimilarities.peek().getValue();        }    }    int size = topSimilarities.size();    if (size == 0) {        return Collections.emptyList();    }    List<GenericItemSimilarity.ItemItemSimilarity> result = new ArrayList<>(size);    result.addAll(topSimilarities);    Collections.sort(result);    return result;}
1237d75a3eb588bbbf00f0ef0415d831ec5d76fb875182020081f13455943380
getTopUserUserSimilarities
public static List<GenericUserSimilarity.UserUserSimilarity> getTopUserUserSimilarities(int howMany, Iterator<GenericUserSimilarity.UserUserSimilarity> allSimilarities)
{    Queue<GenericUserSimilarity.UserUserSimilarity> topSimilarities = new PriorityQueue<>(howMany + 1, Collections.reverseOrder());    boolean full = false;    double lowestTopValue = Double.NEGATIVE_INFINITY;    while (allSimilarities.hasNext()) {        GenericUserSimilarity.UserUserSimilarity similarity = allSimilarities.next();        double value = similarity.getValue();        if (!Double.isNaN(value) && (!full || value > lowestTopValue)) {            topSimilarities.add(similarity);            if (full) {                topSimilarities.poll();            } else if (topSimilarities.size() > howMany) {                full = true;                topSimilarities.poll();            }            lowestTopValue = topSimilarities.peek().getValue();        }    }    int size = topSimilarities.size();    if (size == 0) {        return Collections.emptyList();    }    List<GenericUserSimilarity.UserUserSimilarity> result = new ArrayList<>(size);    result.addAll(topSimilarities);    Collections.sort(result);    return result;}
1ef875a18b1e398af79de30162b22c8a96590e683e1ccfb022946c52928a5452
getDataModel
protected DataModel getDataModel()
{    return dataModel;}
49fc2640f75a17f0009c6939de1abac8ee80d2eb67d091d86defdf01278c77da
allSimilarItemIDs
public long[] allSimilarItemIDs(long itemID) throws TasteException
{    FastIDSet allSimilarItemIDs = new FastIDSet();    LongPrimitiveIterator allItemIDs = dataModel.getItemIDs();    while (allItemIDs.hasNext()) {        long possiblySimilarItemID = allItemIDs.nextLong();        if (!Double.isNaN(itemSimilarity(itemID, possiblySimilarItemID))) {            allSimilarItemIDs.add(possiblySimilarItemID);        }    }    return allSimilarItemIDs.toArray();}
da77e35d28c590f4b271e5b2b7f639c465574b8f17a1ef2f1df63e0152c57e8b
refresh
public void refresh(Collection<Refreshable> alreadyRefreshed)
{    refreshHelper.refresh(alreadyRefreshed);}
d13adffe85ac1c9f2c0398e9ad6f9b9c9e9bdfcb01b3dd0e05ed2d554564383e
call
public Object call() throws TasteException
{    cachedNumItems = dataModel.getNumItems();    cachedNumUsers = dataModel.getNumUsers();    return null;}
4c4b2549788e455dc7f713f2b03a856fa23887f9d4cbf5ae6d802bd04776d898
getPreferenceInferrer
 final PreferenceInferrer getPreferenceInferrer()
{    return inferrer;}
1dd2b4b1ed8b326c41a479d489da00a6a0a2fe5bae3d6b82c5b0b5b6d02f7d54
setPreferenceInferrer
public final void setPreferenceInferrer(PreferenceInferrer inferrer)
{    Preconditions.checkArgument(inferrer != null, "inferrer is null");    refreshHelper.addDependency(inferrer);    refreshHelper.removeDependency(this.inferrer);    this.inferrer = inferrer;}
173857b3ea5467c58a17ce91bc372a5504cce132aef83525583d3184d49c8ce0
isWeighted
 final boolean isWeighted()
{    return weighted;}
6f619af6b933f247b2381a943dbd9ec7e1ce76261259afaaba26f206ffa26a36
userSimilarity
public double userSimilarity(long userID1, long userID2) throws TasteException
{    DataModel dataModel = getDataModel();    PreferenceArray xPrefs = dataModel.getPreferencesFromUser(userID1);    PreferenceArray yPrefs = dataModel.getPreferencesFromUser(userID2);    int xLength = xPrefs.length();    int yLength = yPrefs.length();    if (xLength == 0 || yLength == 0) {        return Double.NaN;    }    long xIndex = xPrefs.getItemID(0);    long yIndex = yPrefs.getItemID(0);    int xPrefIndex = 0;    int yPrefIndex = 0;    double sumX = 0.0;    double sumX2 = 0.0;    double sumY = 0.0;    double sumY2 = 0.0;    double sumXY = 0.0;    double sumXYdiff2 = 0.0;    int count = 0;    boolean hasInferrer = inferrer != null;    while (true) {        int compare = xIndex < yIndex ? -1 : xIndex > yIndex ? 1 : 0;        if (hasInferrer || compare == 0) {            double x;            double y;            if (xIndex == yIndex) {                                x = xPrefs.getValue(xPrefIndex);                y = yPrefs.getValue(yPrefIndex);            } else {                                if (compare < 0) {                                        x = xPrefs.getValue(xPrefIndex);                    y = inferrer.inferPreference(userID2, xIndex);                } else {                                                            x = inferrer.inferPreference(userID1, yIndex);                    y = yPrefs.getValue(yPrefIndex);                }            }            sumXY += x * y;            sumX += x;            sumX2 += x * x;            sumY += y;            sumY2 += y * y;            double diff = x - y;            sumXYdiff2 += diff * diff;            count++;        }        if (compare <= 0) {            if (++xPrefIndex >= xLength) {                if (hasInferrer) {                                        if (yIndex == Long.MAX_VALUE) {                                                break;                    }                    xIndex = Long.MAX_VALUE;                } else {                    break;                }            } else {                xIndex = xPrefs.getItemID(xPrefIndex);            }        }        if (compare >= 0) {            if (++yPrefIndex >= yLength) {                if (hasInferrer) {                                        if (xIndex == Long.MAX_VALUE) {                                                break;                    }                    yIndex = Long.MAX_VALUE;                } else {                    break;                }            } else {                yIndex = yPrefs.getItemID(yPrefIndex);            }        }    }        double result;    if (centerData) {        double meanX = sumX / count;        double meanY = sumY / count;                double centeredSumXY = sumXY - meanY * sumX;                double centeredSumX2 = sumX2 - meanX * sumX;                double centeredSumY2 = sumY2 - meanY * sumY;        result = computeResult(count, centeredSumXY, centeredSumX2, centeredSumY2, sumXYdiff2);    } else {        result = computeResult(count, sumXY, sumX2, sumY2, sumXYdiff2);    }    if (!Double.isNaN(result)) {        result = normalizeWeightResult(result, count, cachedNumItems);    }    return result;}
a51e5b9d9005a01d8c06bbd1046dd70074d9c28bb9b751752aef944cc3d3a535
itemSimilarity
public final double itemSimilarity(long itemID1, long itemID2) throws TasteException
{    DataModel dataModel = getDataModel();    PreferenceArray xPrefs = dataModel.getPreferencesForItem(itemID1);    PreferenceArray yPrefs = dataModel.getPreferencesForItem(itemID2);    int xLength = xPrefs.length();    int yLength = yPrefs.length();    if (xLength == 0 || yLength == 0) {        return Double.NaN;    }    long xIndex = xPrefs.getUserID(0);    long yIndex = yPrefs.getUserID(0);    int xPrefIndex = 0;    int yPrefIndex = 0;    double sumX = 0.0;    double sumX2 = 0.0;    double sumY = 0.0;    double sumY2 = 0.0;    double sumXY = 0.0;    double sumXYdiff2 = 0.0;    int count = 0;    while (true) {        int compare = xIndex < yIndex ? -1 : xIndex > yIndex ? 1 : 0;        if (compare == 0) {                        double x = xPrefs.getValue(xPrefIndex);            double y = yPrefs.getValue(yPrefIndex);            sumXY += x * y;            sumX += x;            sumX2 += x * x;            sumY += y;            sumY2 += y * y;            double diff = x - y;            sumXYdiff2 += diff * diff;            count++;        }        if (compare <= 0) {            if (++xPrefIndex == xLength) {                break;            }            xIndex = xPrefs.getUserID(xPrefIndex);        }        if (compare >= 0) {            if (++yPrefIndex == yLength) {                break;            }            yIndex = yPrefs.getUserID(yPrefIndex);        }    }    double result;    if (centerData) {                double n = (double) count;        double meanX = sumX / n;        double meanY = sumY / n;                double centeredSumXY = sumXY - meanY * sumX;                double centeredSumX2 = sumX2 - meanX * sumX;                double centeredSumY2 = sumY2 - meanY * sumY;        result = computeResult(count, centeredSumXY, centeredSumX2, centeredSumY2, sumXYdiff2);    } else {        result = computeResult(count, sumXY, sumX2, sumY2, sumXYdiff2);    }    if (!Double.isNaN(result)) {        result = normalizeWeightResult(result, count, cachedNumUsers);    }    return result;}
3ce3330a48ace40db1c9361681134076e4b81fff6ebc87e5e2468a3d2fa8099b
itemSimilarities
public double[] itemSimilarities(long itemID1, long[] itemID2s) throws TasteException
{    int length = itemID2s.length;    double[] result = new double[length];    for (int i = 0; i < length; i++) {        result[i] = itemSimilarity(itemID1, itemID2s[i]);    }    return result;}
a91f5256918e3dde4a91cdc17d2d1824468d7e90bdafb2377db2cd7e75b1b7e3
normalizeWeightResult
 final double normalizeWeightResult(double result, int count, int num)
{    double normalizedResult = result;    if (weighted) {        double scaleFactor = 1.0 - (double) count / (double) (num + 1);        if (normalizedResult < 0.0) {            normalizedResult = -1.0 + scaleFactor * (1.0 + normalizedResult);        } else {            normalizedResult = 1.0 - scaleFactor * (1.0 - normalizedResult);        }    }        if (normalizedResult < -1.0) {        normalizedResult = -1.0;    } else if (normalizedResult > 1.0) {        normalizedResult = 1.0;    }    return normalizedResult;}
20b8605591bd898434b8e6c49a1ee9b73e8cf20f0fb8085ad10160c16fe250a0
refresh
public final void refresh(Collection<Refreshable> alreadyRefreshed)
{    super.refresh(alreadyRefreshed);    refreshHelper.refresh(alreadyRefreshed);}
30c5449c6b5eb9c7f0a380bfd47f034e2fb127c28cd09faea4b05291405320a0
toString
public final String toString()
{    return this.getClass().getSimpleName() + "[dataModel:" + getDataModel() + ",inferrer:" + inferrer + ']';}
23ce15013ac25b7ddfe41f400f8f39ff1401d4e82b58b3893cfd17019ca8a149
inferPreference
public float inferPreference(long userID, long itemID) throws TasteException
{    return averagePreferenceValue.get(userID);}
da77e35d28c590f4b271e5b2b7f639c465574b8f17a1ef2f1df63e0152c57e8b
refresh
public void refresh(Collection<Refreshable> alreadyRefreshed)
{    averagePreferenceValue.clear();}
16b63495798cf3857db2ec293c9058300902d2742bdc83bd334512f39bdd64f4
get
public Float get(Long key) throws TasteException
{    PreferenceArray prefs = dataModel.getPreferencesFromUser(key);    int size = prefs.length();    if (size == 0) {        return ZERO;    }    RunningAverage average = new FullRunningAverage();    for (int i = 0; i < size; i++) {        average.addDatum(prefs.getValue(i));    }    return (float) average.getAverage();}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "AveragingPreferenceInferrer";}
129e071a5acdf44209957699325f269c391c2463b78b7efe09056606615ae94b
call
public Void call()
{    similarityCache.clear();    return null;}
4bd88ca141a3deec266891ce1f59a5b0cf28b3cd76314d24831443c2c964f4d5
itemSimilarity
public double itemSimilarity(long itemID1, long itemID2) throws TasteException
{    LongPair key = itemID1 < itemID2 ? new LongPair(itemID1, itemID2) : new LongPair(itemID2, itemID1);    return similarityCache.get(key);}
3ce3330a48ace40db1c9361681134076e4b81fff6ebc87e5e2468a3d2fa8099b
itemSimilarities
public double[] itemSimilarities(long itemID1, long[] itemID2s) throws TasteException
{    int length = itemID2s.length;    double[] result = new double[length];    for (int i = 0; i < length; i++) {        result[i] = itemSimilarity(itemID1, itemID2s[i]);    }    return result;}
49fc2640f75a17f0009c6939de1abac8ee80d2eb67d091d86defdf01278c77da
allSimilarItemIDs
public long[] allSimilarItemIDs(long itemID) throws TasteException
{    return similarity.allSimilarItemIDs(itemID);}
da77e35d28c590f4b271e5b2b7f639c465574b8f17a1ef2f1df63e0152c57e8b
refresh
public void refresh(Collection<Refreshable> alreadyRefreshed)
{    refreshHelper.refresh(alreadyRefreshed);}
fe43eb6b694d8e3c843decfe52e7d94fec5262fb31c401baff0cdbdaea0534ab
clearCacheForItem
public void clearCacheForItem(long itemID)
{    similarityCache.removeKeysMatching(new LongPairMatchPredicate(itemID));}
d690366b1dae6f2b811a3fa603d9b1cbf60389f37b3f659f2ac8b8c0bf34dd8d
get
public Double get(LongPair key) throws TasteException
{    return similarity.itemSimilarity(key.getFirst(), key.getSecond());}
129e071a5acdf44209957699325f269c391c2463b78b7efe09056606615ae94b
call
public Void call()
{    similarityCache.clear();    return null;}
6f619af6b933f247b2381a943dbd9ec7e1ce76261259afaaba26f206ffa26a36
userSimilarity
public double userSimilarity(long userID1, long userID2) throws TasteException
{    LongPair key = userID1 < userID2 ? new LongPair(userID1, userID2) : new LongPair(userID2, userID1);    return similarityCache.get(key);}
2d8f33853a5d66d0af6cf47695c79967c65a305e7d58f8c40c1187abe20830c6
setPreferenceInferrer
public void setPreferenceInferrer(PreferenceInferrer inferrer)
{    similarityCache.clear();    similarity.setPreferenceInferrer(inferrer);}
56a7895ee69720553453fed8928b6bd6e9db86f01b41ebb6a44d188d1d8ab40d
clearCacheForUser
public void clearCacheForUser(long userID)
{    similarityCache.removeKeysMatching(new LongPairMatchPredicate(userID));}
da77e35d28c590f4b271e5b2b7f639c465574b8f17a1ef2f1df63e0152c57e8b
refresh
public void refresh(Collection<Refreshable> alreadyRefreshed)
{    refreshHelper.refresh(alreadyRefreshed);}
d690366b1dae6f2b811a3fa603d9b1cbf60389f37b3f659f2ac8b8c0bf34dd8d
get
public Double get(LongPair key) throws TasteException
{    return similarity.userSimilarity(key.getFirst(), key.getSecond());}
2d8f33853a5d66d0af6cf47695c79967c65a305e7d58f8c40c1187abe20830c6
setPreferenceInferrer
public void setPreferenceInferrer(PreferenceInferrer inferrer)
{    throw new UnsupportedOperationException();}
da77e35d28c590f4b271e5b2b7f639c465574b8f17a1ef2f1df63e0152c57e8b
refresh
public void refresh(Collection<Refreshable> alreadyRefreshed)
{    Collection<Refreshable> refreshed = RefreshHelper.buildRefreshed(alreadyRefreshed);    RefreshHelper.maybeRefresh(refreshed, getDataModel());}
4bd88ca141a3deec266891ce1f59a5b0cf28b3cd76314d24831443c2c964f4d5
itemSimilarity
public double itemSimilarity(long itemID1, long itemID2) throws TasteException
{    DataModel dataModel = getDataModel();    int preferring1 = dataModel.getNumUsersWithPreferenceFor(itemID1);    int preferring2 = dataModel.getNumUsersWithPreferenceFor(itemID2);    int intersection = dataModel.getNumUsersWithPreferenceFor(itemID1, itemID2);    return doSimilarity(preferring1, preferring2, intersection);}
3ce3330a48ace40db1c9361681134076e4b81fff6ebc87e5e2468a3d2fa8099b
itemSimilarities
public double[] itemSimilarities(long itemID1, long[] itemID2s) throws TasteException
{    DataModel dataModel = getDataModel();    int preferring1 = dataModel.getNumUsersWithPreferenceFor(itemID1);    double[] distance = new double[itemID2s.length];    for (int i = 0; i < itemID2s.length; ++i) {        int preferring2 = dataModel.getNumUsersWithPreferenceFor(itemID2s[i]);        int intersection = dataModel.getNumUsersWithPreferenceFor(itemID1, itemID2s[i]);        distance[i] = doSimilarity(preferring1, preferring2, intersection);    }    return distance;}
6f619af6b933f247b2381a943dbd9ec7e1ce76261259afaaba26f206ffa26a36
userSimilarity
public double userSimilarity(long userID1, long userID2) throws TasteException
{    DataModel dataModel = getDataModel();    FastIDSet prefs1 = dataModel.getItemIDsFromUser(userID1);    FastIDSet prefs2 = dataModel.getItemIDsFromUser(userID2);    int prefs1Size = prefs1.size();    int prefs2Size = prefs2.size();    int intersectionSize = prefs1Size < prefs2Size ? prefs2.intersectionSize(prefs1) : prefs1.intersectionSize(prefs2);    return doSimilarity(prefs1Size, prefs2Size, intersectionSize);}
06f334b69d0052d2e76dc6de3b70833d19f00a5ba769a24106ea935c3f208ef3
doSimilarity
private static double doSimilarity(int pref1, int pref2, int intersection)
{    int distance = pref1 + pref2 - 2 * intersection;    return 1.0 / (1.0 + distance);}
bf914958e02f6abeb218df2d103e44e2b45dccaeb2c8e6268a18af7478094a88
computeResult
 double computeResult(int n, double sumXY, double sumX2, double sumY2, double sumXYdiff2)
{    return 1.0 / (1.0 + Math.sqrt(sumXYdiff2) / Math.sqrt(n));}
a826368617ee2cf32429e53040e2af19ff9270146b892a0d5f22d331c19eeed0
iterator
public Iterator<GenericItemSimilarity.ItemItemSimilarity> iterator()
{    try {        return new FileItemItemSimilarityIterator(similaritiesFile);    } catch (IOException ioe) {        throw new IllegalStateException("Can't read " + similaritiesFile, ioe);    }}
18c7c43bb27ef9349f1f1d188d7e02a37437888e4e55f523e4bc1872e1f1d9b3
apply
public GenericItemSimilarity.ItemItemSimilarity apply(String from)
{    String[] tokens = SEPARATOR.split(from);    return new GenericItemSimilarity.ItemItemSimilarity(Long.parseLong(tokens[0]), Long.parseLong(tokens[1]), Double.parseDouble(tokens[2]));}
7a7b882f5e5f8b04ce0ac05827fdcfc2f30dcea497682299744362d37f5602b8
delegate
protected Iterator<GenericItemSimilarity.ItemItemSimilarity> delegate()
{    return delegate;}
3ce3330a48ace40db1c9361681134076e4b81fff6ebc87e5e2468a3d2fa8099b
itemSimilarities
public double[] itemSimilarities(long itemID1, long[] itemID2s) throws TasteException
{    return delegate.itemSimilarities(itemID1, itemID2s);}
49fc2640f75a17f0009c6939de1abac8ee80d2eb67d091d86defdf01278c77da
allSimilarItemIDs
public long[] allSimilarItemIDs(long itemID) throws TasteException
{    return delegate.allSimilarItemIDs(itemID);}
4bd88ca141a3deec266891ce1f59a5b0cf28b3cd76314d24831443c2c964f4d5
itemSimilarity
public double itemSimilarity(long itemID1, long itemID2) throws TasteException
{    return delegate.itemSimilarity(itemID1, itemID2);}
da77e35d28c590f4b271e5b2b7f639c465574b8f17a1ef2f1df63e0152c57e8b
refresh
public void refresh(Collection<Refreshable> alreadyRefreshed)
{    if (dataFile.lastModified() > lastModified + minReloadIntervalMS) {        log.debug("File has changed; reloading...");        reload();    }}
10d7c03ff05328028908d407ee4c775675767e13b48e052e8327f609f01e3e8c
reload
protected void reload()
{    if (reloadLock.tryLock()) {        try {            long newLastModified = dataFile.lastModified();            delegate = new GenericItemSimilarity(new FileItemItemSimilarityIterable(dataFile));            lastModified = newLastModified;        } finally {            reloadLock.unlock();        }    }}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "FileItemSimilarity[dataFile:" + dataFile + ']';}
4652e3099ab6b4096d9cfcbae1ee8ba06f1147f0046f90a7e3c497f31f0e16c6
initSimilarityMaps
private void initSimilarityMaps(Iterator<ItemItemSimilarity> similarities)
{    while (similarities.hasNext()) {        ItemItemSimilarity iic = similarities.next();        long similarityItemID1 = iic.getItemID1();        long similarityItemID2 = iic.getItemID2();        if (similarityItemID1 != similarityItemID2) {                        long itemID1;            long itemID2;            if (similarityItemID1 < similarityItemID2) {                itemID1 = similarityItemID1;                itemID2 = similarityItemID2;            } else {                itemID1 = similarityItemID2;                itemID2 = similarityItemID1;            }            FastByIDMap<Double> map = similarityMaps.get(itemID1);            if (map == null) {                map = new FastByIDMap<>();                similarityMaps.put(itemID1, map);            }            map.put(itemID2, iic.getValue());            doIndex(itemID1, itemID2);            doIndex(itemID2, itemID1);        }        }}
fb944e28b1107518fd8cb307dda41145171455fb1126ddf336b90d76b283e90f
doIndex
private void doIndex(long fromItemID, long toItemID)
{    FastIDSet similarItemIDs = similarItemIDsIndex.get(fromItemID);    if (similarItemIDs == null) {        similarItemIDs = new FastIDSet();        similarItemIDsIndex.put(fromItemID, similarItemIDs);    }    similarItemIDs.add(toItemID);}
50e6b7f96cf22dd8e2565708ad17537816c51b9936cd4736bafb36eedd8da9e6
itemSimilarity
public double itemSimilarity(long itemID1, long itemID2)
{    if (itemID1 == itemID2) {        return 1.0;    }    long firstID;    long secondID;    if (itemID1 < itemID2) {        firstID = itemID1;        secondID = itemID2;    } else {        firstID = itemID2;        secondID = itemID1;    }    FastByIDMap<Double> nextMap = similarityMaps.get(firstID);    if (nextMap == null) {        return Double.NaN;    }    Double similarity = nextMap.get(secondID);    return similarity == null ? Double.NaN : similarity;}
00d4cdca08b465288a485bb65a4128cfd1261b7f5ec59a0e050b082adf455897
itemSimilarities
public double[] itemSimilarities(long itemID1, long[] itemID2s)
{    int length = itemID2s.length;    double[] result = new double[length];    for (int i = 0; i < length; i++) {        result[i] = itemSimilarity(itemID1, itemID2s[i]);    }    return result;}
d5bcaad044f6702e70f7c2dee9d117cb33bc4b6e4e31fc0a00a6ffcfb2e5ca20
allSimilarItemIDs
public long[] allSimilarItemIDs(long itemID)
{    FastIDSet similarItemIDs = similarItemIDsIndex.get(itemID);    return similarItemIDs != null ? similarItemIDs.toArray() : NO_IDS;}
da77e35d28c590f4b271e5b2b7f639c465574b8f17a1ef2f1df63e0152c57e8b
refresh
public void refresh(Collection<Refreshable> alreadyRefreshed)
{}
02d2dd3a469b18514fc05782419da77793507cf776f5666c7691516cce284fb2
getItemID1
public long getItemID1()
{    return itemID1;}
a7753aab9695c5568be3c78ed1334e8fc2b5a10b95187ed5a2c5941d7c13f471
getItemID2
public long getItemID2()
{    return itemID2;}
baa2719ad2de5db523d278575928af9560575a9fbdd5a41694812df8ea43af94
getValue
public double getValue()
{    return value;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "ItemItemSimilarity[" + itemID1 + ',' + itemID2 + ':' + value + ']';}
9d60c1979d7d2613659e27f5bd7454bbedf05338442cd32339b1b381ecb62b72
compareTo
public int compareTo(ItemItemSimilarity other)
{    double otherValue = other.getValue();    return value > otherValue ? -1 : value < otherValue ? 1 : 0;}
74e378df448c6c3cd090d6daf881cfac8957dd555869ea4c13a46bdc6cdcf9a6
equals
public boolean equals(Object other)
{    if (!(other instanceof ItemItemSimilarity)) {        return false;    }    ItemItemSimilarity otherSimilarity = (ItemItemSimilarity) other;    return otherSimilarity.getItemID1() == itemID1 && otherSimilarity.getItemID2() == itemID2 && otherSimilarity.getValue() == value;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return (int) itemID1 ^ (int) itemID2 ^ RandomUtils.hashDouble(value);}
604450ba0500d49cdab3dd8cd4f3d850095e589ca72da06213c74d73d8146eea
computeNext
protected ItemItemSimilarity computeNext()
{    int size = itemIDs.length;    ItemItemSimilarity result = null;    while (result == null && i < size - 1) {        long itemID2 = itemIDs[j];        double similarity;        try {            similarity = otherSimilarity.itemSimilarity(itemID1, itemID2);        } catch (TasteException te) {                        throw new IllegalStateException(te);        }        if (!Double.isNaN(similarity)) {            result = new ItemItemSimilarity(itemID1, itemID2, similarity);        }        if (++j == size) {            itemID1 = itemIDs[++i];            j = i + 1;        }    }    if (result == null) {        return endOfData();    } else {        return result;    }}
ed59ae116504a508f2243632a5f1479ac1bf2bb96db902fcf8f63aa6445db215
longIteratorToList
 static long[] longIteratorToList(LongPrimitiveIterator iterator)
{    long[] result = new long[5];    int size = 0;    while (iterator.hasNext()) {        if (size == result.length) {            long[] newResult = new long[result.length << 1];            System.arraycopy(result, 0, newResult, 0, result.length);            result = newResult;        }        result[size++] = iterator.next();    }    if (size != result.length) {        long[] newResult = new long[size];        System.arraycopy(result, 0, newResult, 0, size);        result = newResult;    }    return result;}
284013be70194bf38b890664aceabda9516a6bde001c04dbc8e1846789580ae9
initSimilarityMaps
private void initSimilarityMaps(Iterator<UserUserSimilarity> similarities)
{    while (similarities.hasNext()) {        UserUserSimilarity uuc = similarities.next();        long similarityUser1 = uuc.getUserID1();        long similarityUser2 = uuc.getUserID2();        if (similarityUser1 != similarityUser2) {                        long user1;            long user2;            if (similarityUser1 < similarityUser2) {                user1 = similarityUser1;                user2 = similarityUser2;            } else {                user1 = similarityUser2;                user2 = similarityUser1;            }            FastByIDMap<Double> map = similarityMaps.get(user1);            if (map == null) {                map = new FastByIDMap<>();                similarityMaps.put(user1, map);            }            map.put(user2, uuc.getValue());        }        }}
ab8be7aca4e6c8ed3ce781c3ce64734b5fabc57b9a0fbf9b5d4c0245cdc50bb0
userSimilarity
public double userSimilarity(long userID1, long userID2)
{    if (userID1 == userID2) {        return 1.0;    }    long first;    long second;    if (userID1 < userID2) {        first = userID1;        second = userID2;    } else {        first = userID2;        second = userID1;    }    FastByIDMap<Double> nextMap = similarityMaps.get(first);    if (nextMap == null) {        return Double.NaN;    }    Double similarity = nextMap.get(second);    return similarity == null ? Double.NaN : similarity;}
2d8f33853a5d66d0af6cf47695c79967c65a305e7d58f8c40c1187abe20830c6
setPreferenceInferrer
public void setPreferenceInferrer(PreferenceInferrer inferrer)
{    throw new UnsupportedOperationException();}
da77e35d28c590f4b271e5b2b7f639c465574b8f17a1ef2f1df63e0152c57e8b
refresh
public void refresh(Collection<Refreshable> alreadyRefreshed)
{}
132fcf4b8db823d9aca03479fd95473c92f2892cc41eb3460bbfd12a4c7a0074
getUserID1
public long getUserID1()
{    return userID1;}
a767ff9e986e321faa13fac0cb31021ae4fc4bbc4d987a80b2f9132adf78268d
getUserID2
public long getUserID2()
{    return userID2;}
baa2719ad2de5db523d278575928af9560575a9fbdd5a41694812df8ea43af94
getValue
public double getValue()
{    return value;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "UserUserSimilarity[" + userID1 + ',' + userID2 + ':' + value + ']';}
841dc487e0db4798b923735af801ddc38ed234f4f6fd91ff956c425669cfe1a3
compareTo
public int compareTo(UserUserSimilarity other)
{    double otherValue = other.getValue();    return value > otherValue ? -1 : value < otherValue ? 1 : 0;}
74e378df448c6c3cd090d6daf881cfac8957dd555869ea4c13a46bdc6cdcf9a6
equals
public boolean equals(Object other)
{    if (!(other instanceof UserUserSimilarity)) {        return false;    }    UserUserSimilarity otherSimilarity = (UserUserSimilarity) other;    return otherSimilarity.getUserID1() == userID1 && otherSimilarity.getUserID2() == userID2 && otherSimilarity.getValue() == value;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return (int) userID1 ^ (int) userID2 ^ RandomUtils.hashDouble(value);}
1fcd96071b3b26d71fcb255429108ab60b952bebb15bd620576960cfdad956cd
computeNext
protected UserUserSimilarity computeNext()
{    int size = itemIDs.length;    while (i < size - 1) {        long itemID2 = itemIDs[j];        double similarity;        try {            similarity = otherSimilarity.userSimilarity(itemID1, itemID2);        } catch (TasteException te) {                        throw new IllegalStateException(te);        }        if (!Double.isNaN(similarity)) {            return new UserUserSimilarity(itemID1, itemID2, similarity);        }        if (++j == size) {            itemID1 = itemIDs[++i];            j = i + 1;        }    }    return endOfData();}
2d8f33853a5d66d0af6cf47695c79967c65a305e7d58f8c40c1187abe20830c6
setPreferenceInferrer
public void setPreferenceInferrer(PreferenceInferrer inferrer)
{    throw new UnsupportedOperationException();}
6f619af6b933f247b2381a943dbd9ec7e1ce76261259afaaba26f206ffa26a36
userSimilarity
public double userSimilarity(long userID1, long userID2) throws TasteException
{    DataModel dataModel = getDataModel();    FastIDSet prefs1 = dataModel.getItemIDsFromUser(userID1);    FastIDSet prefs2 = dataModel.getItemIDsFromUser(userID2);    long prefs1Size = prefs1.size();    long prefs2Size = prefs2.size();    long intersectionSize = prefs1Size < prefs2Size ? prefs2.intersectionSize(prefs1) : prefs1.intersectionSize(prefs2);    if (intersectionSize == 0) {        return Double.NaN;    }    long numItems = dataModel.getNumItems();    double logLikelihood = LogLikelihood.logLikelihoodRatio(intersectionSize, prefs2Size - intersectionSize, prefs1Size - intersectionSize, numItems - prefs1Size - prefs2Size + intersectionSize);    return 1.0 - 1.0 / (1.0 + logLikelihood);}
4bd88ca141a3deec266891ce1f59a5b0cf28b3cd76314d24831443c2c964f4d5
itemSimilarity
public double itemSimilarity(long itemID1, long itemID2) throws TasteException
{    DataModel dataModel = getDataModel();    long preferring1 = dataModel.getNumUsersWithPreferenceFor(itemID1);    long numUsers = dataModel.getNumUsers();    return doItemSimilarity(itemID1, itemID2, preferring1, numUsers);}
3ce3330a48ace40db1c9361681134076e4b81fff6ebc87e5e2468a3d2fa8099b
itemSimilarities
public double[] itemSimilarities(long itemID1, long[] itemID2s) throws TasteException
{    DataModel dataModel = getDataModel();    long preferring1 = dataModel.getNumUsersWithPreferenceFor(itemID1);    long numUsers = dataModel.getNumUsers();    int length = itemID2s.length;    double[] result = new double[length];    for (int i = 0; i < length; i++) {        result[i] = doItemSimilarity(itemID1, itemID2s[i], preferring1, numUsers);    }    return result;}
971a651b5761c88b8637139e95cc44e74b70f382dedc06d6e566fc64da622d88
doItemSimilarity
private double doItemSimilarity(long itemID1, long itemID2, long preferring1, long numUsers) throws TasteException
{    DataModel dataModel = getDataModel();    long preferring1and2 = dataModel.getNumUsersWithPreferenceFor(itemID1, itemID2);    if (preferring1and2 == 0) {        return Double.NaN;    }    long preferring2 = dataModel.getNumUsersWithPreferenceFor(itemID2);    double logLikelihood = LogLikelihood.logLikelihoodRatio(preferring1and2, preferring2 - preferring1and2, preferring1 - preferring1and2, numUsers - preferring1 - preferring2 + preferring1and2);    return 1.0 - 1.0 / (1.0 + logLikelihood);}
da77e35d28c590f4b271e5b2b7f639c465574b8f17a1ef2f1df63e0152c57e8b
refresh
public void refresh(Collection<Refreshable> alreadyRefreshed)
{    alreadyRefreshed = RefreshHelper.buildRefreshed(alreadyRefreshed);    RefreshHelper.maybeRefresh(alreadyRefreshed, getDataModel());}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "LogLikelihoodSimilarity[dataModel:" + getDataModel() + ']';}
1a2142d2974bb07bf174c222bf5654c8fc37c04c6314f6a660766f21774d44ad
matches
public boolean matches(LongPair pair)
{    return pair.getFirst() == id || pair.getSecond() == id;}
bf914958e02f6abeb218df2d103e44e2b45dccaeb2c8e6268a18af7478094a88
computeResult
 double computeResult(int n, double sumXY, double sumX2, double sumY2, double sumXYdiff2)
{    if (n == 0) {        return Double.NaN;    }            double denominator = Math.sqrt(sumX2) * Math.sqrt(sumY2);    if (denominator == 0.0) {                return Double.NaN;    }    return sumXY / denominator;}
37de7cfcc5e9e18ce4cfb27a937aa29721d1db10a35aa80d278d9181d1b52bda
open
public void open() throws IOException
{    writer = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(file), Charsets.UTF_8));}
5cdd7e0240bf96bc20f2fbd398bc8f7650cc55f92ed2f6624dce9dc6e68586c6
add
public void add(SimilarItems similarItems) throws IOException
{    String itemID = String.valueOf(similarItems.getItemID());    for (SimilarItem similarItem : similarItems.getSimilarItems()) {        writer.write(itemID);        writer.write(',');        writer.write(String.valueOf(similarItem.getItemID()));        writer.write(',');        writer.write(String.valueOf(similarItem.getSimilarity()));        writer.newLine();    }}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    Closeables.close(writer, false);}
dbbb9cc99c7f73b60cf66b3b0f5b9735cd3a3fe7ca11d437c8f55278f230db36
computeItemSimilarities
public int computeItemSimilarities(int degreeOfParallelism, int maxDurationInHours, SimilarItemsWriter writer) throws IOException
{    ExecutorService executorService = Executors.newFixedThreadPool(degreeOfParallelism + 1);    Output output = null;    try {        writer.open();        DataModel dataModel = getRecommender().getDataModel();        BlockingQueue<long[]> itemsIDsInBatches = queueItemIDsInBatches(dataModel, batchSize, degreeOfParallelism);        BlockingQueue<List<SimilarItems>> results = new LinkedBlockingQueue<>();        AtomicInteger numActiveWorkers = new AtomicInteger(degreeOfParallelism);        for (int n = 0; n < degreeOfParallelism; n++) {            executorService.execute(new SimilarItemsWorker(n, itemsIDsInBatches, results, numActiveWorkers));        }        output = new Output(results, writer, numActiveWorkers);        executorService.execute(output);    } catch (Exception e) {        throw new IOException(e);    } finally {        executorService.shutdown();        try {            boolean succeeded = executorService.awaitTermination(maxDurationInHours, TimeUnit.HOURS);            if (!succeeded) {                throw new RuntimeException("Unable to complete the computation in " + maxDurationInHours + " hours!");            }        } catch (InterruptedException e) {            throw new RuntimeException(e);        }        Closeables.close(writer, false);    }    return output.getNumSimilaritiesProcessed();}
7045362270672a32325e17743abbf5acfa990a3c0ab15041080b745f68ff80dc
queueItemIDsInBatches
private static BlockingQueue<long[]> queueItemIDsInBatches(DataModel dataModel, int batchSize, int degreeOfParallelism) throws TasteException
{    LongPrimitiveIterator itemIDs = dataModel.getItemIDs();    int numItems = dataModel.getNumItems();    BlockingQueue<long[]> itemIDBatches = new LinkedBlockingQueue<>((numItems / batchSize) + 1);    long[] batch = new long[batchSize];    int pos = 0;    while (itemIDs.hasNext()) {        batch[pos] = itemIDs.nextLong();        pos++;        if (pos == batchSize) {            itemIDBatches.add(batch.clone());            pos = 0;        }    }    if (pos > 0) {        long[] lastBatch = new long[pos];        System.arraycopy(batch, 0, lastBatch, 0, pos);        itemIDBatches.add(lastBatch);    }    if (itemIDBatches.size() < degreeOfParallelism) {        throw new IllegalStateException("Degree of parallelism [" + degreeOfParallelism + "] " + " is larger than number of batches [" + itemIDBatches.size() + "].");    }    log.info("Queued {} items in {} batches", numItems, itemIDBatches.size());    return itemIDBatches;}
50bacaff92b36443f2644dff10795ed29a35ec8dfc1edb38a661bde83158f2f0
getNumSimilaritiesProcessed
private int getNumSimilaritiesProcessed()
{    return numSimilaritiesProcessed;}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    while (numActiveWorkers.get() != 0 || !results.isEmpty()) {        try {            List<SimilarItems> similarItemsOfABatch = results.poll(10, TimeUnit.MILLISECONDS);            if (similarItemsOfABatch != null) {                for (SimilarItems similarItems : similarItemsOfABatch) {                    writer.add(similarItems);                    numSimilaritiesProcessed += similarItems.numSimilarItems();                }            }        } catch (Exception e) {            throw new RuntimeException(e);        }    }}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    int numBatchesProcessed = 0;    while (!itemIDBatches.isEmpty()) {        try {            long[] itemIDBatch = itemIDBatches.take();            List<SimilarItems> similarItemsOfBatch = new ArrayList<>(itemIDBatch.length);            for (long itemID : itemIDBatch) {                List<RecommendedItem> similarItems = getRecommender().mostSimilarItems(itemID, getSimilarItemsPerItem());                similarItemsOfBatch.add(new SimilarItems(itemID, similarItems));            }            results.offer(similarItemsOfBatch);            if (++numBatchesProcessed % 5 == 0) {                log.info("worker {} processed {} batches", number, numBatchesProcessed);            }        } catch (Exception e) {            throw new RuntimeException(e);        }    }    log.info("worker {} processed {} batches. done.", number, numBatchesProcessed);    numActiveWorkers.decrementAndGet();}
6f619af6b933f247b2381a943dbd9ec7e1ce76261259afaaba26f206ffa26a36
userSimilarity
public double userSimilarity(long userID1, long userID2) throws TasteException
{    PreferenceArray xPrefs = dataModel.getPreferencesFromUser(userID1);    PreferenceArray yPrefs = dataModel.getPreferencesFromUser(userID2);    int xLength = xPrefs.length();    int yLength = yPrefs.length();    if (xLength <= 1 || yLength <= 1) {        return Double.NaN;    }        xPrefs = xPrefs.clone();    yPrefs = yPrefs.clone();        xPrefs.sortByValue();    yPrefs.sortByValue();        float nextRank = 1.0f;    for (int i = 0; i < xLength; i++) {                if (yPrefs.hasPrefWithItemID(xPrefs.getItemID(i))) {            xPrefs.setValue(i, nextRank);            nextRank += 1.0f;        }        }    nextRank = 1.0f;    for (int i = 0; i < yLength; i++) {        if (xPrefs.hasPrefWithItemID(yPrefs.getItemID(i))) {            yPrefs.setValue(i, nextRank);            nextRank += 1.0f;        }    }    xPrefs.sortByItem();    yPrefs.sortByItem();    long xIndex = xPrefs.getItemID(0);    long yIndex = yPrefs.getItemID(0);    int xPrefIndex = 0;    int yPrefIndex = 0;    double sumXYRankDiff2 = 0.0;    int count = 0;    while (true) {        int compare = xIndex < yIndex ? -1 : xIndex > yIndex ? 1 : 0;        if (compare == 0) {            double diff = xPrefs.getValue(xPrefIndex) - yPrefs.getValue(yPrefIndex);            sumXYRankDiff2 += diff * diff;            count++;        }        if (compare <= 0) {            if (++xPrefIndex >= xLength) {                break;            }            xIndex = xPrefs.getItemID(xPrefIndex);        }        if (compare >= 0) {            if (++yPrefIndex >= yLength) {                break;            }            yIndex = yPrefs.getItemID(yPrefIndex);        }    }    if (count <= 1) {        return Double.NaN;    }        return 1.0 - 6.0 * sumXYRankDiff2 / (count * (count * count - 1));}
2d8f33853a5d66d0af6cf47695c79967c65a305e7d58f8c40c1187abe20830c6
setPreferenceInferrer
public void setPreferenceInferrer(PreferenceInferrer inferrer)
{    throw new UnsupportedOperationException();}
da77e35d28c590f4b271e5b2b7f639c465574b8f17a1ef2f1df63e0152c57e8b
refresh
public void refresh(Collection<Refreshable> alreadyRefreshed)
{    alreadyRefreshed = RefreshHelper.buildRefreshed(alreadyRefreshed);    RefreshHelper.maybeRefresh(alreadyRefreshed, dataModel);}
2d8f33853a5d66d0af6cf47695c79967c65a305e7d58f8c40c1187abe20830c6
setPreferenceInferrer
public void setPreferenceInferrer(PreferenceInferrer inferrer)
{    throw new UnsupportedOperationException();}
6f619af6b933f247b2381a943dbd9ec7e1ce76261259afaaba26f206ffa26a36
userSimilarity
public double userSimilarity(long userID1, long userID2) throws TasteException
{    DataModel dataModel = getDataModel();    FastIDSet xPrefs = dataModel.getItemIDsFromUser(userID1);    FastIDSet yPrefs = dataModel.getItemIDsFromUser(userID2);    int xPrefsSize = xPrefs.size();    int yPrefsSize = yPrefs.size();    if (xPrefsSize == 0 && yPrefsSize == 0) {        return Double.NaN;    }    if (xPrefsSize == 0 || yPrefsSize == 0) {        return 0.0;    }    int intersectionSize = xPrefsSize < yPrefsSize ? yPrefs.intersectionSize(xPrefs) : xPrefs.intersectionSize(yPrefs);    if (intersectionSize == 0) {        return Double.NaN;    }    int unionSize = xPrefsSize + yPrefsSize - intersectionSize;    return (double) intersectionSize / (double) unionSize;}
4bd88ca141a3deec266891ce1f59a5b0cf28b3cd76314d24831443c2c964f4d5
itemSimilarity
public double itemSimilarity(long itemID1, long itemID2) throws TasteException
{    int preferring1 = getDataModel().getNumUsersWithPreferenceFor(itemID1);    return doItemSimilarity(itemID1, itemID2, preferring1);}
3ce3330a48ace40db1c9361681134076e4b81fff6ebc87e5e2468a3d2fa8099b
itemSimilarities
public double[] itemSimilarities(long itemID1, long[] itemID2s) throws TasteException
{    int preferring1 = getDataModel().getNumUsersWithPreferenceFor(itemID1);    int length = itemID2s.length;    double[] result = new double[length];    for (int i = 0; i < length; i++) {        result[i] = doItemSimilarity(itemID1, itemID2s[i], preferring1);    }    return result;}
c75702f377c76f2fdcd36499a75440ea443781fba0485ecb060263d6f9fa8b6d
doItemSimilarity
private double doItemSimilarity(long itemID1, long itemID2, int preferring1) throws TasteException
{    DataModel dataModel = getDataModel();    int preferring1and2 = dataModel.getNumUsersWithPreferenceFor(itemID1, itemID2);    if (preferring1and2 == 0) {        return Double.NaN;    }    int preferring2 = dataModel.getNumUsersWithPreferenceFor(itemID2);    return (double) preferring1and2 / (double) (preferring1 + preferring2 - preferring1and2);}
da77e35d28c590f4b271e5b2b7f639c465574b8f17a1ef2f1df63e0152c57e8b
refresh
public void refresh(Collection<Refreshable> alreadyRefreshed)
{    alreadyRefreshed = RefreshHelper.buildRefreshed(alreadyRefreshed);    RefreshHelper.maybeRefresh(alreadyRefreshed, getDataModel());}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "TanimotoCoefficientSimilarity[dataModel:" + getDataModel() + ']';}
bf914958e02f6abeb218df2d103e44e2b45dccaeb2c8e6268a18af7478094a88
computeResult
 double computeResult(int n, double sumXY, double sumX2, double sumY2, double sumXYdiff2)
{    if (n == 0) {        return Double.NaN;    }    double denominator = Math.sqrt(sumX2) * Math.sqrt(sumY2);    if (denominator == 0.0) {                return Double.NaN;    }    return sumXY / denominator;}
7c9a9f725487bc88ed88c1cc9a60f23a04076e231f229c9f0c6968d0394adc4d
getRecommender
protected ItemBasedRecommender getRecommender()
{    return recommender;}
4a68f89ead2e789f8ee06661bbf52aca816fc584c346f210162d80e0c1dae9d0
getSimilarItemsPerItem
protected int getSimilarItemsPerItem()
{    return similarItemsPerItem;}
e343bd546eb818206d0f3e9ead4a73ca31047ef96d2af1ea584a9e4afa1f7ad4
compare
public int compare(SimilarItem s1, SimilarItem s2)
{    return Doubles.compare(s1.similarity, s2.similarity);}
86e8a25ff0c505fd2af704a789442de108e1cec5b7e4ebdab5a0a72054a38f9f
set
public void set(long itemID, double similarity)
{    this.itemID = itemID;    this.similarity = similarity;}
656666c3e1a83c6eb409c8bf7c3282b6209c6991806a5f70debc7368d69aec7d
getItemID
public long getItemID()
{    return itemID;}
85125ca95367238e18f67c468f2dd997489281b9ff77dc5c91908d220f01ca84
getSimilarity
public double getSimilarity()
{    return similarity;}
656666c3e1a83c6eb409c8bf7c3282b6209c6991806a5f70debc7368d69aec7d
getItemID
public long getItemID()
{    return itemID;}
bc21f82c7ba7f54be0c6556c4489702a7e46e57540ec73bcaf0f2df93fc16233
numSimilarItems
public int numSimilarItems()
{    return similarItemIDs.length;}
764e7066f7e30f775bce242ef90731911d5c0ccec63ec0605756019183b73e4f
getSimilarItems
public Iterable<SimilarItem> getSimilarItems()
{    return new Iterable<SimilarItem>() {        @Override        public Iterator<SimilarItem> iterator() {            return new SimilarItemsIterator();        }    };}
4ee68e8a3b5451ad61657ba9377d85834e88558c8e80f418bfa2d17e4f30737e
iterator
public Iterator<SimilarItem> iterator()
{    return new SimilarItemsIterator();}
d51e5f7450eca0a0f63da1a466189e262d053b84aa767ba3be5cea740af7251b
hasNext
public boolean hasNext()
{    return index < (similarItemIDs.length - 1);}
71651786823c08e62f656a528db95f3645b5046aa24dc0e4bbf2f6fc71165af7
next
public SimilarItem next()
{    if (!hasNext()) {        throw new NoSuchElementException();    }    index++;    return new SimilarItem(similarItemIDs[index], similarities[index]);}
65354fe521ebab327402026cb5e2de0c7f3771f83eebbc99edd01a983b8336cb
classifyNoLink
public Vector classifyNoLink(Vector features)
{    throw new UnsupportedOperationException(this.getClass().getName() + " doesn't support classification without a link");}
634ba8a7762025f6fd2633a8d9f18e14f77c51e925ed9d9d7ffac0fb2513a5e3
classifyFull
public Vector classifyFull(Vector instance)
{    return classifyFull(new DenseVector(numCategories()), instance);}
4b52fbcac7fd03252f0a0f881fa552eebb1b8203eb1b993f9bfaadea88578c01
classifyFull
public Vector classifyFull(Vector r, Vector instance)
{    r.viewPart(1, numCategories() - 1).assign(classify(instance));    r.setQuick(0, 1.0 - r.zSum());    return r;}
b90ac07d2f7c75ada7b3cd72c969e3f719ab799e0720082db4231c7f898fbc32
classify
public Matrix classify(Matrix data)
{    Matrix r = new DenseMatrix(data.numRows(), numCategories() - 1);    for (int row = 0; row < data.numRows(); row++) {        r.assignRow(row, classify(data.viewRow(row)));    }    return r;}
9971edeb45612cd422dea135ff639308f1a1f7c6a8a702fda6fc34a21d74b21d
classifyFull
public Matrix classifyFull(Matrix data)
{    Matrix r = new DenseMatrix(data.numRows(), numCategories());    for (int row = 0; row < data.numRows(); row++) {        classifyFull(r.viewRow(row), data.viewRow(row));    }    return r;}
65fff3cf7e5743dd8de1c0d9e88da8a492cb6d7cffd76c7bab3bf2d291ee6aab
classifyScalar
public Vector classifyScalar(Matrix data)
{    Preconditions.checkArgument(numCategories() == 2, "Can only call classifyScalar with two categories");    Vector r = new DenseVector(data.numRows());    for (int row = 0; row < data.numRows(); row++) {        r.set(row, classifyScalar(data.viewRow(row)));    }    return r;}
48b0d4a604ad675afd06c3a82a3cdff3b898e88fcf6de1cc4590716e39d26583
logLikelihood
public double logLikelihood(int actual, Vector data)
{    if (numCategories() == 2) {        double p = classifyScalar(data);        if (actual > 0) {            return Math.max(MIN_LOG_LIKELIHOOD, Math.log(p));        } else {            return Math.max(MIN_LOG_LIKELIHOOD, Math.log1p(-p));        }    } else {        Vector p = classify(data);        if (actual > 0) {            return Math.max(MIN_LOG_LIKELIHOOD, Math.log(p.get(actual - 1)));        } else {            return Math.max(MIN_LOG_LIKELIHOOD, Math.log1p(-p.zSum()));        }    }}
37e7a0d6bb88c6f4dec1c468ed8f96422fa5b4a75f99508565a3d05f6163ab8b
getLogLikelihood
public double getLogLikelihood()
{    return logLikelihood;}
e0ef79a23e9a1d267b6fe91df0334624b36ecd6731906351fcfd0a6c92f38b56
setLogLikelihood
public void setLogLikelihood(double logLikelihood)
{    this.logLikelihood = logLikelihood;}
8ac6a0833406172fd69a0460b36720515c63e0b09089d6069630d699c6f8dc18
getLabel
public String getLabel()
{    return label;}
ba944b3a50d7b874f1d93677d11a9f318013b8e552df8b53ec4f3fca9b3cf268
getScore
public double getScore()
{    return score;}
70dea45eb24fbaa9c22840d92b5dfacb133119c32a20d1b000e9ac2399d1b149
setLabel
public void setLabel(String label)
{    this.label = label;}
ac8205e68844f813939df97a2a8befb2d371a64bb2447349f448845b7193983b
setScore
public void setScore(double score)
{    this.score = score;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "ClassifierResult{" + "category='" + label + '\'' + ", score=" + score + '}';}
3a091ebc7fd10a4bd9a42e0e0427ae225289a1546e260728dbe08b3986d95e2c
getConfusionMatrix
public int[][] getConfusionMatrix()
{    return confusionMatrix;}
febac7efcc03be720471e60d58cafeba544799c5400b034510e956adb53276cd
getLabels
public Collection<String> getLabels()
{    return Collections.unmodifiableCollection(labelMap.keySet());}
a4bbd957c15df3f0b7e31d5162dbda4c768da116127d23b25da2c54f721fd7de
numLabels
private int numLabels()
{    return labelMap.size();}
61d43c1b3f27c4cb0ec7192004221d56b801ae7422f80bfb33e2c4c258e4e9f0
getAccuracy
public double getAccuracy(String label)
{    int labelId = labelMap.get(label);    int labelTotal = 0;    int correct = 0;    for (int i = 0; i < numLabels(); i++) {        labelTotal += confusionMatrix[labelId][i];        if (i == labelId) {            correct += confusionMatrix[labelId][i];        }    }    return 100.0 * correct / labelTotal;}
b5175cfd3e798e089bb2e855165c47aecb62c4b75fd07f49205b8782adfcb726
getAccuracy
public double getAccuracy()
{    int total = 0;    int correct = 0;    for (int i = 0; i < numLabels(); i++) {        for (int j = 0; j < numLabels(); j++) {            total += confusionMatrix[i][j];            if (i == j) {                correct += confusionMatrix[i][j];            }        }    }    return 100.0 * correct / total;}
438abc9ddde3dacf7bd5fc7e26dc0e91290d6e584fce321a7577f2ab2d747514
getActualNumberOfTestExamplesForClass
private int getActualNumberOfTestExamplesForClass(String label)
{    int labelId = labelMap.get(label);    int sum = 0;    for (int i = 0; i < numLabels(); i++) {        sum += confusionMatrix[labelId][i];    }    return sum;}
9b57403c53a0b64649d9f234ee7b5ab2d38a23decbcb8afc77908a258fa7ed6b
getPrecision
public double getPrecision(String label)
{    int labelId = labelMap.get(label);    int truePositives = confusionMatrix[labelId][labelId];    int falsePositives = 0;    for (int i = 0; i < numLabels(); i++) {        if (i == labelId) {            continue;        }        falsePositives += confusionMatrix[i][labelId];    }    if (truePositives + falsePositives == 0) {        return 0;    }    return ((double) truePositives) / (truePositives + falsePositives);}
21b49fa4eaf3a4e70c06b915ca250a05ea9077366f5d74b08508a3a923412916
getWeightedPrecision
public double getWeightedPrecision()
{    double[] precisions = new double[numLabels()];    double[] weights = new double[numLabels()];    int index = 0;    for (String label : labelMap.keySet()) {        precisions[index] = getPrecision(label);        weights[index] = getActualNumberOfTestExamplesForClass(label);        index++;    }    return new Mean().evaluate(precisions, weights);}
446379c53c0b9eb9aefc2761bfab4dad49b37629f439b326f2745e66470cc782
getRecall
public double getRecall(String label)
{    int labelId = labelMap.get(label);    int truePositives = confusionMatrix[labelId][labelId];    int falseNegatives = 0;    for (int i = 0; i < numLabels(); i++) {        if (i == labelId) {            continue;        }        falseNegatives += confusionMatrix[labelId][i];    }    if (truePositives + falseNegatives == 0) {        return 0;    }    return ((double) truePositives) / (truePositives + falseNegatives);}
f6f4871018c6adc861195f24153a955ba512020de9ff281ad171b3c0c6cc142a
getWeightedRecall
public double getWeightedRecall()
{    double[] recalls = new double[numLabels()];    double[] weights = new double[numLabels()];    int index = 0;    for (String label : labelMap.keySet()) {        recalls[index] = getRecall(label);        weights[index] = getActualNumberOfTestExamplesForClass(label);        index++;    }    return new Mean().evaluate(recalls, weights);}
0ac41daf5ff550af995bf34b1447302133527a35445bb0e1ac0a9ccd2b4872f8
getF1score
public double getF1score(String label)
{    double precision = getPrecision(label);    double recall = getRecall(label);    if (precision + recall == 0) {        return 0;    }    return 2 * precision * recall / (precision + recall);}
1bb72bd1f88e576755962ed4bf73df2049431692e70e25f01682e0f9205d8212
getWeightedF1score
public double getWeightedF1score()
{    double[] f1Scores = new double[numLabels()];    double[] weights = new double[numLabels()];    int index = 0;    for (String label : labelMap.keySet()) {        f1Scores[index] = getF1score(label);        weights[index] = getActualNumberOfTestExamplesForClass(label);        index++;    }    return new Mean().evaluate(f1Scores, weights);}
5ae204fe714e74bfe0ce68a7116d7df0fd46dff8474280d0d9775b96d7dd3b9b
getReliability
public double getReliability()
{    int count = 0;    double accuracy = 0;    for (String label : labelMap.keySet()) {        if (!label.equals(defaultLabel)) {            accuracy += getAccuracy(label);        }        count++;    }    return accuracy / count;}
1997dc183540cedb4fd94af0c940f011f9909645208f4dd5de786ebcb8d0765d
getKappa
public double getKappa()
{    double a = 0.0;    double b = 0.0;    for (int i = 0; i < confusionMatrix.length; i++) {        a += confusionMatrix[i][i];        double br = 0;        for (int j = 0; j < confusionMatrix.length; j++) {            br += confusionMatrix[i][j];        }        double bc = 0;        for (int[] vec : confusionMatrix) {            bc += vec[i];        }        b += br * bc;    }    return (samples * a - b) / (samples * samples - b);}
10d014f9c3e9a0390513f32c66626d9b4e5e13b0949c05e95bc3806bb4776073
getNormalizedStats
public RunningAverageAndStdDev getNormalizedStats()
{    RunningAverageAndStdDev summer = new FullRunningAverageAndStdDev();    for (int d = 0; d < confusionMatrix.length; d++) {        double total = 0;        for (int j = 0; j < confusionMatrix.length; j++) {            total += confusionMatrix[d][j];        }        summer.addDatum(confusionMatrix[d][d] / (total + 0.000001));    }    return summer;}
b6fd6812a639debd03297e43664783dcb678259b5144b64362a317a9b5db7d6e
getCorrect
public int getCorrect(String label)
{    int labelId = labelMap.get(label);    return confusionMatrix[labelId][labelId];}
cef91e5c2846a87fabd5e02d4abffa5c138861c695bc1be18cee6dc7523ee373
getTotal
public int getTotal(String label)
{    int labelId = labelMap.get(label);    int labelTotal = 0;    for (int i = 0; i < labelMap.size(); i++) {        labelTotal += confusionMatrix[labelId][i];    }    return labelTotal;}
6157a419765ea26a4c0f9269cf4f7a770eacba644a6860a5449ebf6bc778871a
addInstance
public void addInstance(String correctLabel, ClassifierResult classifiedResult)
{    samples++;    incrementCount(correctLabel, classifiedResult.getLabel());}
93e20158b02560987044fe263e50c289116f8da7ae7040ea7030a8418d5a4631
addInstance
public void addInstance(String correctLabel, String classifiedLabel)
{    samples++;    incrementCount(correctLabel, classifiedLabel);}
d3660033a1b0c246d0c0ae2dac4ccea799b184addb70e8a72de1ccd7e2baecb9
getCount
public int getCount(String correctLabel, String classifiedLabel)
{    if (!labelMap.containsKey(correctLabel)) {        LOG.warn("Label {} did not appear in the training examples", correctLabel);        return 0;    }    Preconditions.checkArgument(labelMap.containsKey(classifiedLabel), "Label not found: " + classifiedLabel);    int correctId = labelMap.get(correctLabel);    int classifiedId = labelMap.get(classifiedLabel);    return confusionMatrix[correctId][classifiedId];}
5d1a05c59bbb227dd961b80bafcdbab1b053680e1c543928f577e46be3896bda
putCount
public void putCount(String correctLabel, String classifiedLabel, int count)
{    if (!labelMap.containsKey(correctLabel)) {        LOG.warn("Label {} did not appear in the training examples", correctLabel);        return;    }    Preconditions.checkArgument(labelMap.containsKey(classifiedLabel), "Label not found: " + classifiedLabel);    int correctId = labelMap.get(correctLabel);    int classifiedId = labelMap.get(classifiedLabel);    if (confusionMatrix[correctId][classifiedId] == 0.0 && count != 0) {        samples++;    }    confusionMatrix[correctId][classifiedId] = count;}
42c568f2c2b7c4892d9177dc0206c4fd2b7d18673fe6f35689d5d9357e3fdb72
getDefaultLabel
public String getDefaultLabel()
{    return defaultLabel;}
551412b44b79bcbc967b332920d4cb8b4c5ac68798e15aa5ed3dac42d8cb673d
incrementCount
public void incrementCount(String correctLabel, String classifiedLabel, int count)
{    putCount(correctLabel, classifiedLabel, count + getCount(correctLabel, classifiedLabel));}
9115f1aa2cb12e7114a4208ab7ad1ac6ca081d2468c458181c01e758b9951dd7
incrementCount
public void incrementCount(String correctLabel, String classifiedLabel)
{    incrementCount(correctLabel, classifiedLabel, 1);}
d9a306c74cc9ae9d8b1722d993d598faa4294255d549c66c93e2fdb4cc0a78b7
merge
public ConfusionMatrix merge(ConfusionMatrix b)
{    Preconditions.checkArgument(labelMap.size() == b.getLabels().size(), "The label sizes do not match");    for (String correctLabel : this.labelMap.keySet()) {        for (String classifiedLabel : this.labelMap.keySet()) {            incrementCount(correctLabel, classifiedLabel, b.getCount(correctLabel, classifiedLabel));        }    }    return this;}
6e21a37b9d165de4ac79e7d1fc61f6b8f138d07afd9cba5f62b6fdceeb15b781
getMatrix
public Matrix getMatrix()
{    int length = confusionMatrix.length;    Matrix m = new DenseMatrix(length, length);    for (int r = 0; r < length; r++) {        for (int c = 0; c < length; c++) {            m.set(r, c, confusionMatrix[r][c]);        }    }    Map<String, Integer> labels = new HashMap<>();    for (Map.Entry<String, Integer> entry : labelMap.entrySet()) {        labels.put(entry.getKey(), entry.getValue());    }    m.setRowLabelBindings(labels);    m.setColumnLabelBindings(labels);    return m;}
2ccf8c03f7e6e81bbec65f5b967f9a0f2143395445d37c6a43aa3d0becce29a4
setMatrix
public void setMatrix(Matrix m)
{    int length = confusionMatrix.length;    if (m.numRows() != m.numCols()) {        throw new IllegalArgumentException("ConfusionMatrix: matrix(" + m.numRows() + ',' + m.numCols() + ") must be square");    }    for (int r = 0; r < length; r++) {        for (int c = 0; c < length; c++) {            confusionMatrix[r][c] = (int) Math.round(m.get(r, c));        }    }    Map<String, Integer> labels = m.getRowLabelBindings();    if (labels == null) {        labels = m.getColumnLabelBindings();    }    if (labels != null) {        String[] sorted = sortLabels(labels);        verifyLabels(length, sorted);        labelMap.clear();        for (int i = 0; i < length; i++) {            labelMap.put(sorted[i], i);        }    }}
4a21386ef46e43e5e58ae3beec3246b8a435416e680513e0b591d3d1447ece5d
sortLabels
private static String[] sortLabels(Map<String, Integer> labels)
{    String[] sorted = new String[labels.size()];    for (Map.Entry<String, Integer> entry : labels.entrySet()) {        sorted[entry.getValue()] = entry.getKey();    }    return sorted;}
921cc2c37c476656ccd8a730940545463e5208fbcf8b92bc4bd2ccecefc4870a
verifyLabels
private static void verifyLabels(int length, String[] sorted)
{    Preconditions.checkArgument(sorted.length == length, "One label, one row");    for (int i = 0; i < length; i++) {        if (sorted[i] == null) {            Preconditions.checkArgument(false, "One label, one row");        }    }}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    StringBuilder returnString = new StringBuilder(200);    returnString.append("=======================================================").append('\n');    returnString.append("Confusion Matrix\n");    returnString.append("-------------------------------------------------------").append('\n');    int unclassified = getTotal(defaultLabel);    for (Map.Entry<String, Integer> entry : this.labelMap.entrySet()) {        if (entry.getKey().equals(defaultLabel) && unclassified == 0) {            continue;        }        returnString.append(StringUtils.rightPad(getSmallLabel(entry.getValue()), 5)).append('\t');    }    returnString.append("<--Classified as").append('\n');    for (Map.Entry<String, Integer> entry : this.labelMap.entrySet()) {        if (entry.getKey().equals(defaultLabel) && unclassified == 0) {            continue;        }        String correctLabel = entry.getKey();        int labelTotal = 0;        for (String classifiedLabel : this.labelMap.keySet()) {            if (classifiedLabel.equals(defaultLabel) && unclassified == 0) {                continue;            }            returnString.append(StringUtils.rightPad(Integer.toString(getCount(correctLabel, classifiedLabel)), 5)).append('\t');            labelTotal += getCount(correctLabel, classifiedLabel);        }        returnString.append(" |  ").append(StringUtils.rightPad(String.valueOf(labelTotal), 6)).append('\t').append(StringUtils.rightPad(getSmallLabel(entry.getValue()), 5)).append(" = ").append(correctLabel).append('\n');    }    if (unclassified > 0) {        returnString.append("Default Category: ").append(defaultLabel).append(": ").append(unclassified).append('\n');    }    returnString.append('\n');    return returnString.toString();}
7433df81bf558f29435573499acbe3e08bc4233a561cccde02b5b14dec420992
getSmallLabel
 static String getSmallLabel(int i)
{    int val = i;    StringBuilder returnString = new StringBuilder();    do {        int n = val % 26;        returnString.insert(0, (char) ('a' + n));        val /= 26;    } while (val > 0);    return returnString.toString();}
8f02c67d1d0424c88e18a828e51f15f28e999bc1b3723f8da052456317af3063
build
public Node build(Random rng)
{    log.debug("Bagging...");    Arrays.fill(sampled, false);    Data bag = data.bagging(rng, sampled);    log.debug("Building...");    return treeBuilder.build(rng, bag);}
ccdf5fbc97110684efd03481def44adcbe7463f7fd41654c1e326a3479d57b3d
setM
public void setM(int m)
{    this.m = m;}
d61663345f5223ade55fbd38dedb72d8c650c02c8194b2688cb31073990dbfa0
setIgSplit
public void setIgSplit(IgSplit igSplit)
{    this.igSplit = igSplit;}
d8dbae9b4f7a30ac39a35c355965b082a7bdbcd2c428f8862a7446cce2c14e40
setComplemented
public void setComplemented(boolean complemented)
{    this.complemented = complemented;}
5f467152d9bb1b68fdf8aff2864070629b75a90eb315387257307f05cc8b4056
setMinSplitNum
public void setMinSplitNum(int minSplitNum)
{    this.minSplitNum = minSplitNum;}
9e7cfd068d9335ab0e022e7c507825934e84fd965ad48f1bfc66e74a13cb191e
setMinVarianceProportion
public void setMinVarianceProportion(double minVarianceProportion)
{    this.minVarianceProportion = minVarianceProportion;}
37e142b96449df64b0ad3dd35f4187ee47474e4523162b029a4681ec1d2e6a1b
build
public Node build(Random rng, Data data)
{    if (selected == null) {        selected = new boolean[data.getDataset().nbAttributes()];                selected[data.getDataset().getLabelId()] = true;    }    if (m == 0) {                double e = data.getDataset().nbAttributes() - 1;        if (data.getDataset().isNumerical(data.getDataset().getLabelId())) {                        m = (int) Math.ceil(e / 3.0);        } else {                        m = (int) Math.ceil(Math.sqrt(e));        }    }    if (data.isEmpty()) {        return new Leaf(Double.NaN);    }    double sum = 0.0;    if (data.getDataset().isNumerical(data.getDataset().getLabelId())) {                        double sumSquared = 0.0;        for (int i = 0; i < data.size(); i++) {            double label = data.getDataset().getLabel(data.get(i));            sum += label;            sumSquared += label * label;        }                double var = sumSquared - (sum * sum) / data.size();                if (Double.compare(minVariance, Double.NaN) == 0) {            minVariance = var / data.size() * minVarianceProportion;            log.debug("minVariance:{}", minVariance);        }                if ((var / data.size()) < minVariance) {            log.debug("variance({}) < minVariance({}) Leaf({})", var / data.size(), minVariance, sum / data.size());            return new Leaf(sum / data.size());        }    } else {                if (isIdentical(data)) {            return new Leaf(data.majorityLabel(rng));        }        if (data.identicalLabel()) {            return new Leaf(data.getDataset().getLabel(data.get(0)));        }    }        if (fullSet == null) {        fullSet = data;    }    int[] attributes = randomAttributes(rng, selected, m);    if (attributes == null || attributes.length == 0) {                double label;        if (data.getDataset().isNumerical(data.getDataset().getLabelId())) {                        label = sum / data.size();        } else {                        label = data.majorityLabel(rng);        }        log.warn("attribute which can be selected is not found Leaf({})", label);        return new Leaf(label);    }    if (igSplit == null) {        if (data.getDataset().isNumerical(data.getDataset().getLabelId())) {                        igSplit = new RegressionSplit();        } else {                        igSplit = new OptIgSplit();        }    }        Split best = null;    for (int attr : attributes) {        Split split = igSplit.computeSplit(data, attr);        if (best == null || best.getIg() < split.getIg()) {            best = split;        }    }        if (best.getIg() < EPSILON) {        double label;        if (data.getDataset().isNumerical(data.getDataset().getLabelId())) {            label = sum / data.size();        } else {            label = data.majorityLabel(rng);        }        log.debug("ig is near to zero Leaf({})", label);        return new Leaf(label);    }    log.debug("best split attr:{}, split:{}, ig:{}", best.getAttr(), best.getSplit(), best.getIg());    boolean alreadySelected = selected[best.getAttr()];    if (alreadySelected) {                log.warn("attribute {} already selected in a parent node", best.getAttr());    }    Node childNode;    if (data.getDataset().isNumerical(best.getAttr())) {        boolean[] temp = null;        Data loSubset = data.subset(Condition.lesser(best.getAttr(), best.getSplit()));        Data hiSubset = data.subset(Condition.greaterOrEquals(best.getAttr(), best.getSplit()));        if (loSubset.isEmpty() || hiSubset.isEmpty()) {                        selected[best.getAttr()] = true;        } else {                        temp = selected;            selected = cloneCategoricalAttributes(data.getDataset(), selected);        }                if (loSubset.size() < minSplitNum || hiSubset.size() < minSplitNum) {                        double label;            if (data.getDataset().isNumerical(data.getDataset().getLabelId())) {                label = sum / data.size();            } else {                label = data.majorityLabel(rng);            }            log.debug("branch is not split Leaf({})", label);            return new Leaf(label);        }        Node loChild = build(rng, loSubset);        Node hiChild = build(rng, hiSubset);                if (temp != null) {            selected = temp;        } else {            selected[best.getAttr()] = alreadySelected;        }        childNode = new NumericalNode(best.getAttr(), best.getSplit(), loChild, hiChild);    } else {                double[] values = data.values(best.getAttr());                Collection<Double> subsetValues = null;        if (complemented) {            subsetValues = new HashSet<>();            for (double value : values) {                subsetValues.add(value);            }            values = fullSet.values(best.getAttr());        }        int cnt = 0;        Data[] subsets = new Data[values.length];        for (int index = 0; index < values.length; index++) {            if (complemented && !subsetValues.contains(values[index])) {                continue;            }            subsets[index] = data.subset(Condition.equals(best.getAttr(), values[index]));            if (subsets[index].size() >= minSplitNum) {                cnt++;            }        }                if (cnt < 2) {                        double label;            if (data.getDataset().isNumerical(data.getDataset().getLabelId())) {                label = sum / data.size();            } else {                label = data.majorityLabel(rng);            }            log.debug("branch is not split Leaf({})", label);            return new Leaf(label);        }        selected[best.getAttr()] = true;        Node[] children = new Node[values.length];        for (int index = 0; index < values.length; index++) {            if (complemented && (subsetValues == null || !subsetValues.contains(values[index]))) {                                double label;                if (data.getDataset().isNumerical(data.getDataset().getLabelId())) {                    label = sum / data.size();                } else {                    label = data.majorityLabel(rng);                }                log.debug("complemented Leaf({})", label);                children[index] = new Leaf(label);                continue;            }            children[index] = build(rng, subsets[index]);        }        selected[best.getAttr()] = alreadySelected;        childNode = new CategoricalNode(best.getAttr(), values, children);    }    return childNode;}
23310d06133550ec1398388819fd92b6d95eed3f6a0e04be94218f7173324cd6
isIdentical
private boolean isIdentical(Data data)
{    if (data.isEmpty()) {        return true;    }    Instance instance = data.get(0);    for (int attr = 0; attr < selected.length; attr++) {        if (selected[attr]) {            continue;        }        for (int index = 1; index < data.size(); index++) {            if (data.get(index).get(attr) != instance.get(attr)) {                return false;            }        }    }    return true;}
ad4303642773b4710da96d65448be76421be83d38d2e5a208469cc81e9907eef
cloneCategoricalAttributes
private static boolean[] cloneCategoricalAttributes(Dataset dataset, boolean[] selected)
{    boolean[] cloned = new boolean[selected.length];    for (int i = 0; i < selected.length; i++) {        cloned[i] = !dataset.isNumerical(i) && selected[i];    }    cloned[dataset.getLabelId()] = true;    return cloned;}
39c6d5b81ddf6257bf47ee4e099843bd812ec6ac208ac992e955d47f22da86b0
randomAttributes
private static int[] randomAttributes(Random rng, boolean[] selected, int m)
{        int nbNonSelected = 0;    for (boolean sel : selected) {        if (!sel) {            nbNonSelected++;        }    }    if (nbNonSelected == 0) {        log.warn("All attributes are selected !");        return NO_ATTRIBUTES;    }    int[] result;    if (nbNonSelected <= m) {                result = new int[nbNonSelected];        int index = 0;        for (int attr = 0; attr < selected.length; attr++) {            if (!selected[attr]) {                result[index++] = attr;            }        }    } else {        result = new int[m];        for (int index = 0; index < m; index++) {                        int rind;            do {                rind = rng.nextInt(selected.length);            } while (selected[rind]);            result[index] = rind;                        selected[rind] = true;        }                for (int attr : result) {            selected[attr] = false;        }    }    return result;}
ccdf5fbc97110684efd03481def44adcbe7463f7fd41654c1e326a3479d57b3d
setM
public void setM(int m)
{    this.m = m;}
37e142b96449df64b0ad3dd35f4187ee47474e4523162b029a4681ec1d2e6a1b
build
public Node build(Random rng, Data data)
{    if (selected == null) {        selected = new boolean[data.getDataset().nbAttributes()];                selected[data.getDataset().getLabelId()] = true;    }    if (data.isEmpty()) {        return new Leaf(-1);    }    if (isIdentical(data)) {        return new Leaf(data.majorityLabel(rng));    }    if (data.identicalLabel()) {        return new Leaf(data.getDataset().getLabel(data.get(0)));    }    int[] attributes = randomAttributes(rng, selected, m);    if (attributes == null || attributes.length == 0) {                return new Leaf(data.majorityLabel(rng));    }        Split best = null;    for (int attr : attributes) {        Split split = igSplit.computeSplit(data, attr);        if (best == null || best.getIg() < split.getIg()) {            best = split;        }    }    boolean alreadySelected = selected[best.getAttr()];    if (alreadySelected) {                log.warn("attribute {} already selected in a parent node", best.getAttr());    }    Node childNode;    if (data.getDataset().isNumerical(best.getAttr())) {        boolean[] temp = null;        Data loSubset = data.subset(Condition.lesser(best.getAttr(), best.getSplit()));        Data hiSubset = data.subset(Condition.greaterOrEquals(best.getAttr(), best.getSplit()));        if (loSubset.isEmpty() || hiSubset.isEmpty()) {                        selected[best.getAttr()] = true;        } else {                        temp = selected;            selected = cloneCategoricalAttributes(data.getDataset(), selected);        }        Node loChild = build(rng, loSubset);        Node hiChild = build(rng, hiSubset);                if (temp != null) {            selected = temp;        } else {            selected[best.getAttr()] = alreadySelected;        }        childNode = new NumericalNode(best.getAttr(), best.getSplit(), loChild, hiChild);    } else {                selected[best.getAttr()] = true;        double[] values = data.values(best.getAttr());        Node[] children = new Node[values.length];        for (int index = 0; index < values.length; index++) {            Data subset = data.subset(Condition.equals(best.getAttr(), values[index]));            children[index] = build(rng, subset);        }        selected[best.getAttr()] = alreadySelected;        childNode = new CategoricalNode(best.getAttr(), values, children);    }    return childNode;}
23310d06133550ec1398388819fd92b6d95eed3f6a0e04be94218f7173324cd6
isIdentical
private boolean isIdentical(Data data)
{    if (data.isEmpty()) {        return true;    }    Instance instance = data.get(0);    for (int attr = 0; attr < selected.length; attr++) {        if (selected[attr]) {            continue;        }        for (int index = 1; index < data.size(); index++) {            if (data.get(index).get(attr) != instance.get(attr)) {                return false;            }        }    }    return true;}
ad4303642773b4710da96d65448be76421be83d38d2e5a208469cc81e9907eef
cloneCategoricalAttributes
private static boolean[] cloneCategoricalAttributes(Dataset dataset, boolean[] selected)
{    boolean[] cloned = new boolean[selected.length];    for (int i = 0; i < selected.length; i++) {        cloned[i] = !dataset.isNumerical(i) && selected[i];    }    return cloned;}
e89f614502812657fad5f7bcf1ea7f53432ee5823ce1d499a3fbe40f8579213f
randomAttributes
protected static int[] randomAttributes(Random rng, boolean[] selected, int m)
{        int nbNonSelected = 0;    for (boolean sel : selected) {        if (!sel) {            nbNonSelected++;        }    }    if (nbNonSelected == 0) {        log.warn("All attributes are selected !");        return NO_ATTRIBUTES;    }    int[] result;    if (nbNonSelected <= m) {                result = new int[nbNonSelected];        int index = 0;        for (int attr = 0; attr < selected.length; attr++) {            if (!selected[attr]) {                result[index++] = attr;            }        }    } else {        result = new int[m];        for (int index = 0; index < m; index++) {                        int rind;            do {                rind = rng.nextInt(selected.length);            } while (selected[rind]);            result[index] = rind;                        selected[rind] = true;        }                for (int attr : result) {            selected[attr] = false;        }    }    return result;}
51365672405da6d7a8c9fd2a8bd5147ffd2bc3b32881a4c78d80db3ba580da23
equals
public static Condition equals(int attr, double value)
{    return new Equals(attr, value);}
1897f4df364d5a66f41e5be23511fbdf950e79d2e974c36cba4898ee2af90ded
lesser
public static Condition lesser(int attr, double value)
{    return new Lesser(attr, value);}
1ef9e49aff5dea41f8dbdbf32a74ff1d3d84fdcd60a8c5535d10886699ff86aa
greaterOrEquals
public static Condition greaterOrEquals(int attr, double value)
{    return new GreaterOrEquals(attr, value);}
eddd6c5c88730e63052dcb1a4bc55e397826743c9dc61e3d2e52a133a5c3e83b
isTrueFor
public boolean isTrueFor(Instance instance)
{    return instance.get(attr) == value;}
61dcf9de9a6170d978e769fe0574192d4b011d3dc31a85ae506fa4cd7c5a70ce
isTrueFor
public boolean isTrueFor(Instance v)
{    return v.get(attr) >= value;}
eddd6c5c88730e63052dcb1a4bc55e397826743c9dc61e3d2e52a133a5c3e83b
isTrueFor
public boolean isTrueFor(Instance instance)
{    return instance.get(attr) < value;}
72ef1e59027007ffe0950edfd2670ad03bb65cd6463d5d1d282dfeb1750435b0
size
public int size()
{    return instances.size();}
803915e853382ad445a6e2333fabb8beb8e4acd70e908a0d818400f7baac42af
isEmpty
public boolean isEmpty()
{    return instances.isEmpty();}
29e328e55a061df5cbd7b28db5cb2fab35ad377f8338248c738003c57fb1abcb
contains
public boolean contains(Instance v)
{    return instances.contains(v);}
9525d653793136e044153ef2762178a20b46a10811e0ec2b1d5ac48b1e03f01c
get
public Instance get(int index)
{    return instances.get(index);}
649eb813acbcd31edea4606dad8c098e388ddd9d6ba78901b1befd4a6b433425
subset
public Data subset(Condition condition)
{    List<Instance> subset = new ArrayList<>();    for (Instance instance : instances) {        if (condition.isTrueFor(instance)) {            subset.add(instance);        }    }    return new Data(dataset, subset);}
c092d50214f02ef2a3968f76bf2a8b9b96b29b9bef40a04182b26ae14a997a85
bagging
public Data bagging(Random rng)
{    int datasize = size();    List<Instance> bag = new ArrayList<>(datasize);    for (int i = 0; i < datasize; i++) {        bag.add(instances.get(rng.nextInt(datasize)));    }    return new Data(dataset, bag);}
7bb740d641c2316e04c3930a96789008e51d1aa886f48975738a34d9d214c771
bagging
public Data bagging(Random rng, boolean[] sampled)
{    int datasize = size();    List<Instance> bag = new ArrayList<>(datasize);    for (int i = 0; i < datasize; i++) {        int index = rng.nextInt(datasize);        bag.add(instances.get(index));        sampled[index] = true;    }    return new Data(dataset, bag);}
a7787c713de5f5aa8b7be2966195bdb769521efd13ba5800eae2e91d8df46078
rsplit
public Data rsplit(Random rng, int subsize)
{    List<Instance> subset = new ArrayList<>(subsize);    for (int i = 0; i < subsize; i++) {        subset.add(instances.remove(rng.nextInt(instances.size())));    }    return new Data(dataset, subset);}
14d25604cdbf7f88eed49a0e1ba203cc7ed13b834a0f94b1bcc60e62328e7829
isIdentical
public boolean isIdentical()
{    if (isEmpty()) {        return true;    }    Instance instance = get(0);    for (int attr = 0; attr < dataset.nbAttributes(); attr++) {        for (int index = 1; index < size(); index++) {            if (get(index).get(attr) != instance.get(attr)) {                return false;            }        }    }    return true;}
be0bb9713a5e9cb617ac65520ae04adb28095e03b56509fb56744d2bff45ef5b
identicalLabel
public boolean identicalLabel()
{    if (isEmpty()) {        return true;    }    double label = dataset.getLabel(get(0));    for (int index = 1; index < size(); index++) {        if (dataset.getLabel(get(index)) != label) {            return false;        }    }    return true;}
7480d964ea0d1ae3d0036b037b9441ec29fbf797f451a69e78a79808f16ce546
values
public double[] values(int attr)
{    Collection<Double> result = new HashSet<>();    for (Instance instance : instances) {        result.add(instance.get(attr));    }    double[] values = new double[result.size()];    int index = 0;    for (Double value : result) {        values[index++] = value;    }    return values;}
fd6e44e8d1d70cd9042180536d0e39565e1b991e4076e655d41651db4b45d233
clone
public Data clone()
{    return new Data(dataset, new ArrayList<>(instances));}
4afeb0868b55bdd8e18a00a3cb43d83e0714378d1c4bb36f0936daefc060e2e8
equals
public boolean equals(Object obj)
{    if (this == obj) {        return true;    }    if (!(obj instanceof Data)) {        return false;    }    Data data = (Data) obj;    return instances.equals(data.instances) && dataset.equals(data.dataset);}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return instances.hashCode() + dataset.hashCode();}
e02d64828042cd672a5477d18371ebd61e4cc2f62b87fd72cb5c8c0e9f65a734
extractLabels
public double[] extractLabels()
{    double[] labels = new double[size()];    for (int index = 0; index < labels.length; index++) {        labels[index] = dataset.getLabel(get(index));    }    return labels;}
cdd6b468e5d70e11f9c8c160ccbc4e108d965c678b241c6c6b4f9c1d398cdf32
majorityLabel
public int majorityLabel(Random rng)
{        int[] counts = new int[dataset.nblabels()];    for (int index = 0; index < size(); index++) {        counts[(int) dataset.getLabel(get(index))]++;    }        return DataUtils.maxindex(rng, counts);}
c4b2f4fc19c59812295aece31f382367abfccc4eea4d8f1dd4437ec25ca75b20
countLabels
public void countLabels(int[] counts)
{    for (int index = 0; index < size(); index++) {        counts[(int) dataset.getLabel(get(index))]++;    }}
9a0e4b1a4c775f574a648f6e8eae8f9957e7e9f7f9f5b66cf107ddde5848105a
getDataset
public Dataset getDataset()
{    return dataset;}
6038eb3b2b42e3a123a955784072fc630a0ff568fe0202b4d52590a2574aa160
convert
public Instance convert(CharSequence string)
{        int nball = dataset.nbAttributes() + dataset.getIgnored().length;    String[] tokens = COMMA_SPACE.split(string);    Preconditions.checkArgument(tokens.length == nball, "Wrong number of attributes in the string: " + tokens.length + ". Must be " + nball);    int nbattrs = dataset.nbAttributes();    DenseVector vector = new DenseVector(nbattrs);    int aId = 0;    for (int attr = 0; attr < nball; attr++) {        if (!ArrayUtils.contains(dataset.getIgnored(), attr)) {            String token = tokens[attr].trim();            if ("?".equals(token)) {                                return null;            }            if (dataset.isNumerical(aId)) {                vector.set(aId++, Double.parseDouble(token));            } else {                                vector.set(aId, dataset.valueOf(aId, token));                aId++;            }        }    }    return new Instance(vector);}
be3febb95f6f702d2320a94098b228add11e60c3cb3fd7b298b9b41aa323a740
parseString
private static boolean parseString(Attribute[] attrs, Set<String>[] values, CharSequence string, boolean regression)
{    String[] tokens = SEPARATORS.split(string);    Preconditions.checkArgument(tokens.length == attrs.length, "Wrong number of attributes in the string: " + tokens.length + ". Must be: " + attrs.length);        for (int attr = 0; attr < attrs.length; attr++) {        if (!attrs[attr].isIgnored() && "?".equals(tokens[attr])) {                        return false;        }    }    for (int attr = 0; attr < attrs.length; attr++) {        if (!attrs[attr].isIgnored()) {            String token = tokens[attr];            if (attrs[attr].isCategorical() || (!regression && attrs[attr].isLabel())) {                                if (values[attr] == null) {                    values[attr] = new HashSet<>();                }                values[attr].add(token);            } else {                try {                    Double.parseDouble(token);                } catch (NumberFormatException e) {                    return false;                }            }        }    }    return true;}
9f613c09c8e83361ea4806713d4a346a8f7efab21d2b7b09a13deda6ca54d811
loadData
public static Data loadData(Dataset dataset, FileSystem fs, Path fpath) throws IOException
{    FSDataInputStream input = fs.open(fpath);    Scanner scanner = new Scanner(input, "UTF-8");    List<Instance> instances = new ArrayList<>();    DataConverter converter = new DataConverter(dataset);    while (scanner.hasNextLine()) {        String line = scanner.nextLine();        if (!line.isEmpty()) {            Instance instance = converter.convert(line);            if (instance != null) {                instances.add(instance);            } else {                                log.warn("{}: missing values", instances.size());            }        } else {            log.warn("{}: empty string", instances.size());        }    }    scanner.close();    return new Data(dataset, instances);}
d47d1417ff0564ca4b79b9ac1f200091132a30b5b627ac0ede01946d0fe82364
loadData
public static Data loadData(Dataset dataset, FileSystem fs, Path[] pathes) throws IOException
{    List<Instance> instances = new ArrayList<>();    for (Path path : pathes) {        Data loadedData = loadData(dataset, fs, path);        for (int index = 0; index <= loadedData.size(); index++) {            instances.add(loadedData.get(index));        }    }    return new Data(dataset, instances);}
b757a8731df02ef04eedd9e5ddcf32a2fccb785c489235f8a9522f821a0d7c74
loadData
public static Data loadData(Dataset dataset, String[] data)
{    List<Instance> instances = new ArrayList<>();    DataConverter converter = new DataConverter(dataset);    for (String line : data) {        if (!line.isEmpty()) {            Instance instance = converter.convert(line);            if (instance != null) {                instances.add(instance);            } else {                                log.warn("{}: missing values", instances.size());            }        } else {            log.warn("{}: empty string", instances.size());        }    }    return new Data(dataset, instances);}
1307618e27d202b1150be8fd7ead5d12fe575390453d4237787aa0b81b406024
generateDataset
public static Dataset generateDataset(CharSequence descriptor, boolean regression, FileSystem fs, Path path) throws DescriptorException, IOException
{    Attribute[] attrs = DescriptorUtils.parseDescriptor(descriptor);    FSDataInputStream input = fs.open(path);    Scanner scanner = new Scanner(input, "UTF-8");        @SuppressWarnings("unchecked")    Set<String>[] valsets = new Set[attrs.length];    int size = 0;    while (scanner.hasNextLine()) {        String line = scanner.nextLine();        if (!line.isEmpty()) {            if (parseString(attrs, valsets, line, regression)) {                size++;            }        }    }    scanner.close();    @SuppressWarnings("unchecked")    List<String>[] values = new List[attrs.length];    for (int i = 0; i < valsets.length; i++) {        if (valsets[i] != null) {            values[i] = Lists.newArrayList(valsets[i]);        }    }    return new Dataset(attrs, values, size, regression);}
0076b47234c4f972b3d0e91cce2cb92d783169326e4bcc6f43ea5062ea43b5f6
generateDataset
public static Dataset generateDataset(CharSequence descriptor, boolean regression, String[] data) throws DescriptorException
{    Attribute[] attrs = DescriptorUtils.parseDescriptor(descriptor);        @SuppressWarnings("unchecked")    Set<String>[] valsets = new Set[attrs.length];    int size = 0;    for (String aData : data) {        if (!aData.isEmpty()) {            if (parseString(attrs, valsets, aData, regression)) {                size++;            }        }    }    @SuppressWarnings("unchecked")    List<String>[] values = new List[attrs.length];    for (int i = 0; i < valsets.length; i++) {        if (valsets[i] != null) {            values[i] = Lists.newArrayList(valsets[i]);        }    }    return new Dataset(attrs, values, size, regression);}
be11011e00feb6c75999dc6478197403a60cbbaef4ac523a6cf44c686862c133
isNumerical
public boolean isNumerical()
{    return this == NUMERICAL;}
0a63382b0b977dd770d0bd4cfd717c96ccecec3a4ba9070d6ee7df5442526a7f
isCategorical
public boolean isCategorical()
{    return this == CATEGORICAL;}
405cb7b8a68ce724c84c14cc36c5d37d2944cdb27824cb3f563b5310ed7c42c2
isLabel
public boolean isLabel()
{    return this == LABEL;}
afc9421d26f1634aac5724a397382c064df41e64062e3a89bd63ebcda8cc1cbc
isIgnored
public boolean isIgnored()
{    return this == IGNORED;}
3643aa036eba77b98f5cbc6aba77440d47b0084f5354450e0459a317f7229047
fromString
private static Attribute fromString(String from)
{    Attribute toReturn = LABEL;    if (NUMERICAL.toString().equalsIgnoreCase(from)) {        toReturn = NUMERICAL;    } else if (CATEGORICAL.toString().equalsIgnoreCase(from)) {        toReturn = CATEGORICAL;    } else if (IGNORED.toString().equalsIgnoreCase(from)) {        toReturn = IGNORED;    }    return toReturn;}
75eef203af71e3d3a351a0a410eb1adb6d6dc02bb5d9f68d0f4e39bdc1d7d244
nbValues
public int nbValues(int attr)
{    return values[attr].length;}
b7f9f4273e44792388cebe40b6d0731f758ef4de300605e7612aead9c46dad37
labels
public String[] labels()
{    return Arrays.copyOf(values[labelId], nblabels());}
4b1a108846783c82397a55bc23926f97d7bfef441a40703ae3cfb4ae5a967cda
nblabels
public int nblabels()
{    return values[labelId].length;}
684ab038105898082aa2b8ed0afa89f10c7d65f21d5be6692ae5e6f2f3b4984a
getLabelId
public int getLabelId()
{    return labelId;}
e4033d08c23ac3d9c8e9001b39893cf89f4545e2a499c4b330a387e0ce2fb046
getLabel
public double getLabel(Instance instance)
{    return instance.get(getLabelId());}
cc426389d5466e6eacdb9cb449db39175a9a2ad0f84641a3c2236538b2782c33
getAttribute
public Attribute getAttribute(int attr)
{    return attributes[attr];}
278414bbc00cb4fa2d2010382f5b1273b52aee87a801195a4577055938547d51
labelCode
public int labelCode(String label)
{    return ArrayUtils.indexOf(values[labelId], label);}
7eaff06bf286fabea85460a03c17429ee3bf33577f4fdcaa3666c6d7f66f5ad6
getLabelString
public String getLabelString(double code)
{        if (Double.isNaN(code)) {        return "unknown";    }    return values[labelId][(int) code];}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "attributes=" + Arrays.toString(attributes);}
6077650aded646b84b15341258d25b6878d372e906fa47b3d0742de115b02929
valueOf
public int valueOf(int attr, String token)
{    Preconditions.checkArgument(!isNumerical(attr), "Only for CATEGORICAL attributes");    Preconditions.checkArgument(values != null, "Values not found (equals null)");    return ArrayUtils.indexOf(values[attr], token);}
900f788d31727638325cf3277c3fab16bc0bfb121baa4719f76f184b70e7386c
getIgnored
public int[] getIgnored()
{    return ignored;}
b034371fec7be40fe3bf66a19354f750c5b33c34e02f2790c69827c3c830eb8e
countAttributes
private static int countAttributes(Attribute[] attrs)
{    int nbattrs = 0;    for (Attribute attr : attrs) {        if (!attr.isIgnored()) {            nbattrs++;        }    }    return nbattrs;}
bbcdd4035cde55fc28eecccb9c89e596f9ff114eabca6a7baeb60d6fae55dd87
validateValues
private static void validateValues(Attribute[] attrs, List<String>[] values)
{    Preconditions.checkArgument(attrs.length == values.length, "attrs.length != values.length");    for (int attr = 0; attr < attrs.length; attr++) {        Preconditions.checkArgument(!attrs[attr].isCategorical() || values[attr] != null, "values not found for attribute " + attr);    }}
6586707ab79c33afc81dc53d368004bb7b75103048d575599f7c8c57c923b22d
nbAttributes
public int nbAttributes()
{    return attributes.length;}
2bdccb38f75884d457acfe974811ae39b51d1384e19ab7be4fe211f6285cb743
isNumerical
public boolean isNumerical(int attr)
{    return attributes[attr].isNumerical();}
4afeb0868b55bdd8e18a00a3cb43d83e0714378d1c4bb36f0936daefc060e2e8
equals
public boolean equals(Object obj)
{    if (this == obj) {        return true;    }    if (!(obj instanceof Dataset)) {        return false;    }    Dataset dataset = (Dataset) obj;    if (!Arrays.equals(attributes, dataset.attributes)) {        return false;    }    for (int attr = 0; attr < nbAttributes(); attr++) {        if (!Arrays.equals(values[attr], dataset.values[attr])) {            return false;        }    }    return labelId == dataset.labelId && nbInstances == dataset.nbInstances;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    int hashCode = labelId + 31 * nbInstances;    for (Attribute attr : attributes) {        hashCode = 31 * hashCode + attr.hashCode();    }    for (String[] valueRow : values) {        if (valueRow == null) {            continue;        }        for (String value : valueRow) {            hashCode = 31 * hashCode + value.hashCode();        }    }    return hashCode;}
1006cee906bbcd82294c40545d56db7d2cfb6129fc53fa07db461065091c9752
load
public static Dataset load(Configuration conf, Path path) throws IOException
{    FileSystem fs = path.getFileSystem(conf);    long bytesToRead = fs.getFileStatus(path).getLen();    byte[] buff = new byte[Long.valueOf(bytesToRead).intValue()];    FSDataInputStream input = fs.open(path);    try {        input.readFully(buff);    } finally {        Closeables.close(input, true);    }    String json = new String(buff, Charset.defaultCharset());    return fromJSON(json);}
94abe7c6bc71ae47746d713a70d792fba0d5c6565030c65f1292c4fe06398fc6
toJSON
public String toJSON()
{    List<Map<String, Object>> toWrite = new LinkedList<>();        int ignoredCount = 0;    for (int i = 0; i < attributes.length + ignored.length; i++) {        Map<String, Object> attribute;        int attributesIndex = i - ignoredCount;        if (ignoredCount < ignored.length && i == ignored[ignoredCount]) {                        attribute = getMap(Attribute.IGNORED, null, false);            ignoredCount++;        } else if (attributesIndex == labelId) {                        attribute = getMap(attributes[attributesIndex], values[attributesIndex], true);        } else {                        attribute = getMap(attributes[attributesIndex], values[attributesIndex], false);        }        toWrite.add(attribute);    }    try {        return OBJECT_MAPPER.writeValueAsString(toWrite);    } catch (Exception ex) {        throw new RuntimeException(ex);    }}
ec86e0ba04ed81cd73daeb0251761feb1f4de70bcddef9ea4911387908236c71
fromJSON
public static Dataset fromJSON(String json)
{    List<Map<String, Object>> fromJSON;    try {        fromJSON = OBJECT_MAPPER.readValue(json, new TypeReference<List<Map<String, Object>>>() {        });    } catch (Exception ex) {        throw new RuntimeException(ex);    }    List<Attribute> attributes = new LinkedList<>();    List<Integer> ignored = new LinkedList<>();    String[][] nominalValues = new String[fromJSON.size()][];    Dataset dataset = new Dataset();    for (int i = 0; i < fromJSON.size(); i++) {        Map<String, Object> attribute = fromJSON.get(i);        if (Attribute.fromString((String) attribute.get(TYPE)) == Attribute.IGNORED) {            ignored.add(i);        } else {            Attribute asAttribute = Attribute.fromString((String) attribute.get(TYPE));            attributes.add(asAttribute);            if ((Boolean) attribute.get(LABEL)) {                dataset.labelId = i - ignored.size();            }            if (attribute.get(VALUES) != null) {                List<String> get = (List<String>) attribute.get(VALUES);                String[] array = get.toArray(new String[get.size()]);                nominalValues[i - ignored.size()] = array;            }        }    }    dataset.attributes = attributes.toArray(new Attribute[attributes.size()]);    dataset.ignored = new int[ignored.size()];    dataset.values = nominalValues;    for (int i = 0; i < dataset.ignored.length; i++) {        dataset.ignored[i] = ignored.get(i);    }    return dataset;}
c08b510f45538aadbfe53d179055cb403417408454c1a12e916a61cd25163994
getMap
private Map<String, Object> getMap(Attribute type, String[] values, boolean isLabel)
{    Map<String, Object> attribute = new HashMap<>();    attribute.put(TYPE, type.toString().toLowerCase(Locale.getDefault()));    attribute.put(VALUES, values);    attribute.put(LABEL, isLabel);    return attribute;}
19347ac6fc0924767afdb3bf1c227ec22d299992efa34662a86cc682f3084f79
sum
public static int sum(int[] values)
{    int sum = 0;    for (int value : values) {        sum += value;    }    return sum;}
e496a9f82393b0fb03668fb7508021a2b8a7e4e0e9a8b35c022647b881e95f84
add
public static void add(int[] array1, int[] array2)
{    Preconditions.checkArgument(array1.length == array2.length, "array1.length != array2.length");    for (int index = 0; index < array1.length; index++) {        array1[index] += array2[index];    }}
1a5c38da4d976e28d2a19385fba79ca7a9c374ec562949826b70022b78596703
dec
public static void dec(int[] array1, int[] array2)
{    Preconditions.checkArgument(array1.length == array2.length, "array1.length != array2.length");    for (int index = 0; index < array1.length; index++) {        array1[index] -= array2[index];    }}
81277ffc806e19d3044712be3ff95192d6249a4886efdf24ac1f00635281d849
maxindex
public static int maxindex(Random rng, int[] values)
{    int max = 0;    List<Integer> maxindices = new ArrayList<>();    for (int index = 0; index < values.length; index++) {        if (values[index] > max) {            max = values[index];            maxindices.clear();            maxindices.add(index);        } else if (values[index] == max) {            maxindices.add(index);        }    }    return maxindices.size() > 1 ? maxindices.get(rng.nextInt(maxindices.size())) : maxindices.get(0);}
e3884a4001eefddeb33f9ea95552ff49297617d87bd8504089c02d83f38d226d
parseDescriptor
public static Attribute[] parseDescriptor(CharSequence descriptor) throws DescriptorException
{    List<Attribute> attributes = new ArrayList<>();    for (String token : SPACE.split(descriptor)) {        token = token.toUpperCase(Locale.ENGLISH);        if ("I".equals(token)) {            attributes.add(Attribute.IGNORED);        } else if ("N".equals(token)) {            attributes.add(Attribute.NUMERICAL);        } else if ("C".equals(token)) {            attributes.add(Attribute.CATEGORICAL);        } else if ("L".equals(token)) {            attributes.add(Attribute.LABEL);        } else {            throw new DescriptorException("Bad Token : " + token);        }    }    return attributes.toArray(new Attribute[attributes.size()]);}
ffa9b7e9a017f2cf8aea8ee7f25da895afe5a0b30759dc8d3f0bb14ddcaf8281
generateDescriptor
public static String generateDescriptor(CharSequence description) throws DescriptorException
{    return generateDescriptor(SPACE.split(description));}
f21419c4c9968b56340ed0f6109be15d4742ab269b44ac31990f54b8169c73d8
generateDescriptor
public static String generateDescriptor(Iterable<String> tokens) throws DescriptorException
{    StringBuilder descriptor = new StringBuilder();    int multiplicator = 0;    for (String token : tokens) {        try {                        int number = Integer.parseInt(token);            if (number <= 0) {                throw new DescriptorException("Multiplicator (" + number + ") must be > 0");            }            if (multiplicator > 0) {                throw new DescriptorException("A multiplicator cannot be followed by another multiplicator");            }            multiplicator = number;        } catch (NumberFormatException e) {                        if (multiplicator == 0) {                multiplicator = 1;            }            for (int index = 0; index < multiplicator; index++) {                descriptor.append(token).append(' ');            }            multiplicator = 0;        }    }    return descriptor.toString().trim();}
9f213e4a143454bd6f6fafb1c1293c69c2707c2477182f834f9b8e4a465adafe
get
public double get(int index)
{    return attrs.getQuick(index);}
40eb830e31d13276cef93d31667d9f8fe511a811948c5ebb2beb5e1bbd43f76e
set
public void set(int index, double value)
{    attrs.set(index, value);}
4afeb0868b55bdd8e18a00a3cb43d83e0714378d1c4bb36f0936daefc060e2e8
equals
public boolean equals(Object obj)
{    if (this == obj) {        return true;    }    if (!(obj instanceof Instance)) {        return false;    }    Instance instance = (Instance) obj;    return /*id == instance.id &&*/    attrs.equals(instance.attrs);}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return /*id +*/    attrs.hashCode();}
c6d6153ca6c9c449b229b977d0929664f221b5235411336ba92a1a59d6ee1efc
getTrees
 List<Node> getTrees()
{    return trees;}
0016b9fa317d8760e5735438086a9abac00744a08091c4afc960a708a19190f5
classify
public void classify(Data data, double[][] predictions)
{    Preconditions.checkArgument(data.size() == predictions.length, "predictions.length must be equal to data.size()");    if (data.isEmpty()) {                return;    }    int treeId = 0;    for (Node tree : trees) {        for (int index = 0; index < data.size(); index++) {            if (predictions[index] == null) {                predictions[index] = new double[trees.size()];            }            predictions[index][treeId] = tree.classify(data.get(index));        }        treeId++;    }}
6524e201c8fa41715fdfcc2c768db35f9818193ddc997c6f4c715317ad3bce61
classify
public double classify(Dataset dataset, Random rng, Instance instance)
{    if (dataset.isNumerical(dataset.getLabelId())) {        double sum = 0;        int cnt = 0;        for (Node tree : trees) {            double prediction = tree.classify(instance);            if (!Double.isNaN(prediction)) {                sum += prediction;                cnt++;            }        }        if (cnt > 0) {            return sum / cnt;        } else {            return Double.NaN;        }    } else {        int[] predictions = new int[dataset.nblabels()];        for (Node tree : trees) {            double prediction = tree.classify(instance);            if (!Double.isNaN(prediction)) {                predictions[(int) prediction]++;            }        }        if (DataUtils.sum(predictions) == 0) {                        return Double.NaN;        }        return DataUtils.maxindex(rng, predictions);    }}
504f98bd74f057bc497c424ecd26d6766fad81b2489ec0aafa5521a9b8929585
meanNbNodes
public long meanNbNodes()
{    long sum = 0;    for (Node tree : trees) {        sum += tree.nbNodes();    }    return sum / trees.size();}
3714f26f344dd74f219584979fea96e9dbf2fcaed8d91a1b4ba7a32b83aa8e50
nbNodes
public long nbNodes()
{    long sum = 0;    for (Node tree : trees) {        sum += tree.nbNodes();    }    return sum;}
8eef3539e0182a5c042a803dc2fff80d4e080796525244fadf81875ee63df07c
meanMaxDepth
public long meanMaxDepth()
{    long sum = 0;    for (Node tree : trees) {        sum += tree.maxDepth();    }    return sum / trees.size();}
4afeb0868b55bdd8e18a00a3cb43d83e0714378d1c4bb36f0936daefc060e2e8
equals
public boolean equals(Object obj)
{    if (this == obj) {        return true;    }    if (!(obj instanceof DecisionForest)) {        return false;    }    DecisionForest rf = (DecisionForest) obj;    return trees.size() == rf.getTrees().size() && trees.containsAll(rf.getTrees());}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return trees.hashCode();}
5493eeee7f85bd6fb70c717b366e2363863946d32d71ebd52274dfb03a86cae5
write
public void write(DataOutput dataOutput) throws IOException
{    dataOutput.writeInt(trees.size());    for (Node tree : trees) {        tree.write(dataOutput);    }}
c5821d086e99763a45e1e272070fb489eff057889b3aac47dfd41f118d6aecf6
readFields
public void readFields(DataInput dataInput) throws IOException
{    int size = dataInput.readInt();    for (int i = 0; i < size; i++) {        trees.add(Node.read(dataInput));    }}
75609b773675b52ff6058c379fa179d0a82322f38628908e464fd8335494257c
read
public static DecisionForest read(DataInput dataInput) throws IOException
{    DecisionForest forest = new DecisionForest();    forest.readFields(dataInput);    return forest;}
96866509ddb8d7b6c531313a919b9eb9e2ad60f0a309f2f1b2d5cf882570d1b2
load
public static DecisionForest load(Configuration conf, Path forestPath) throws IOException
{    FileSystem fs = forestPath.getFileSystem(conf);    Path[] files;    if (fs.getFileStatus(forestPath).isDir()) {        files = DFUtils.listOutputFiles(fs, forestPath);    } else {        files = new Path[] { forestPath };    }    DecisionForest forest = null;    for (Path path : files) {        try (FSDataInputStream dataInput = new FSDataInputStream(fs.open(path))) {            if (forest == null) {                forest = read(dataInput);            } else {                forest.readFields(dataInput);            }        }    }    return forest;}
d99ddd9ee20976e347b65b265054e4badcaf2b51399ee106402f4298b8c0ed75
writeArray
public static void writeArray(DataOutput out, Node[] array) throws IOException
{    out.writeInt(array.length);    for (Node w : array) {        w.write(out);    }}
5c78034c76641953547b774323c8c28424a14304be4d20d42e15867c62baa6b7
readNodeArray
public static Node[] readNodeArray(DataInput in) throws IOException
{    int length = in.readInt();    Node[] nodes = new Node[length];    for (int index = 0; index < length; index++) {        nodes[index] = Node.read(in);    }    return nodes;}
5c0204970e4bc2ee6e2387300fd62961380e867083fc8775d5ef1626f5cd7902
writeArray
public static void writeArray(DataOutput out, double[] array) throws IOException
{    out.writeInt(array.length);    for (double value : array) {        out.writeDouble(value);    }}
87463297e40a0c736202b598e3145109243cf810f258455902ef01c137e33789
readDoubleArray
public static double[] readDoubleArray(DataInput in) throws IOException
{    int length = in.readInt();    double[] array = new double[length];    for (int index = 0; index < length; index++) {        array[index] = in.readDouble();    }    return array;}
89b1e8fb840bbd9299a1e0de78d28971517b202671191c001b09db97825c67f1
writeArray
public static void writeArray(DataOutput out, int[] array) throws IOException
{    out.writeInt(array.length);    for (int value : array) {        out.writeInt(value);    }}
a4e4fb412d3bc6724eb6bdb8d3b1cdba1ed95970119a5c124311356715556f76
readIntArray
public static int[] readIntArray(DataInput in) throws IOException
{    int length = in.readInt();    int[] array = new int[length];    for (int index = 0; index < length; index++) {        array[index] = in.readInt();    }    return array;}
49eac6d8feb996b51ab2300c884540bec9df50b36aaafcacd7e2c140245ed63c
listOutputFiles
public static Path[] listOutputFiles(FileSystem fs, Path outputPath) throws IOException
{    List<Path> outputFiles = new ArrayList<>();    for (FileStatus s : fs.listStatus(outputPath, PathFilters.logsCRCFilter())) {        if (!s.isDir() && !s.getPath().getName().startsWith("_")) {            outputFiles.add(s.getPath());        }    }    if (outputFiles.isEmpty()) {        throw new IOException("No output found !");    }    return outputFiles.toArray(new Path[outputFiles.size()]);}
b38d68e47de2b5646a12768f4cb8950886af62767ef4aa175130949642e46b87
elapsedTime
public static String elapsedTime(long milli)
{    long seconds = milli / 1000;    milli %= 1000;    long minutes = seconds / 60;    seconds %= 60;    long hours = minutes / 60;    minutes %= 60;    return hours + "h " + minutes + "m " + seconds + "s " + milli;}
67dac12684396b7117cecde9dcc596f48fb219d79627297732df6e71750b0b23
storeWritable
public static void storeWritable(Configuration conf, Path path, Writable writable) throws IOException
{    FileSystem fs = path.getFileSystem(conf);    try (FSDataOutputStream out = fs.create(path)) {        writable.write(out);    }}
5fcd5d9d1f6db9b4e88f70886955180057afb2d33031986582b37cd6c7b0ae5f
storeString
public static void storeString(Configuration conf, Path path, String string) throws IOException
{    try (DataOutputStream out = path.getFileSystem(conf).create(path)) {        out.write(string.getBytes(Charset.defaultCharset()));    }}
d5c96edc19a9e8715d62be816f94fdf8261a5a61cd53397977b995da52eea2d3
errorRate
public static double errorRate(double[] labels, double[] predictions)
{    Preconditions.checkArgument(labels.length == predictions.length, "labels.length != predictions.length");        double nberrors = 0;        double datasize = 0;    for (int index = 0; index < labels.length; index++) {        if (predictions[index] == -1) {                        continue;        }        if (predictions[index] != labels[index]) {            nberrors++;        }        datasize++;    }    return nberrors / datasize;}
7fbacb528d6d07a35c42fb816c58455c6242150e1b87734b41b6a3a3bdfa1abf
getDataPath
protected Path getDataPath()
{    return dataPath;}
5b99512d6f9c2a232e76a23890ab858fae3883af67e187b5925124b6ac1a0df9
getNumMaps
public static int getNumMaps(Configuration conf)
{    return conf.getInt("mapred.map.tasks", -1);}
8585ac631423886fc1bc317ee5903eabd5762947def80274c68b1ecd6e8cd15e
isOutput
protected static boolean isOutput(Configuration conf)
{    return conf.getBoolean("debug.mahout.rf.output", true);}
6d7aa20983df7358537ccaefe01da5ab686006a8fb6928fea6dccce81707e904
getRandomSeed
public static Long getRandomSeed(Configuration conf)
{    String seed = conf.get("mahout.rf.random.seed");    if (seed == null) {        return null;    }    return Long.valueOf(seed);}
044c6fef8867eabb6cad70e8486d5fb45da95c26c3a0b6f8cda395e8f9d49494
setRandomSeed
private static void setRandomSeed(Configuration conf, long seed)
{    conf.setLong("mahout.rf.random.seed", seed);}
441034fd74679e332f648fcdf56b6e85f8fc73bf4c6cdb7137d83cbf77bda27b
getTreeBuilder
public static TreeBuilder getTreeBuilder(Configuration conf)
{    String string = conf.get("mahout.rf.treebuilder");    if (string == null) {        return null;    }    return StringUtils.fromString(string);}
9e78b0003ace48be2e27afe8f737def48449486b4b7467d7b5bd87f25f74e34c
setTreeBuilder
private static void setTreeBuilder(Configuration conf, TreeBuilder treeBuilder)
{    conf.set("mahout.rf.treebuilder", StringUtils.toString(treeBuilder));}
79c7ffc8e522eff6ac35a4aa82cb65973fc68106ab353af1106c73347feb094f
getNbTrees
public static int getNbTrees(Configuration conf)
{    return conf.getInt("mahout.rf.nbtrees", -1);}
30e6449ed292df09c1f53540966113ab0a0dfa6f0945f243e4b0f25cc79bfa31
setNbTrees
public static void setNbTrees(Configuration conf, int nbTrees)
{    Preconditions.checkArgument(nbTrees > 0, "nbTrees should be greater than 0");    conf.setInt("mahout.rf.nbtrees", nbTrees);}
07e3a21d0b08a35bef3caddec4f6d1f2014aed3ff642152a671c44d50f8b36cf
setOutputDirName
public void setOutputDirName(String name)
{    outputDirName = name;}
59cb38b42e7408f02e707470593baffc3a51fccfd3bf4bd87f2f88b551b58901
getOutputPath
protected Path getOutputPath(Configuration conf) throws IOException
{            FileSystem fs = FileSystem.get(conf);    return new Path(fs.getWorkingDirectory(), outputDirName);}
fd3bf66dea3f8e21c3adaf44aa3337343781992afceeea98aeefd867d2472b6f
getDistributedCacheFile
public static Path getDistributedCacheFile(Configuration conf, int index) throws IOException
{    Path[] files = HadoopUtil.getCachedFiles(conf);    if (files.length <= index) {        throw new IOException("path not found in the DistributedCache");    }    return files[index];}
9fdc0cc1c6c229cfeef37e98a0c8f2dceec99ee2565cdd9ca061a38c4b8397d7
loadDataset
public static Dataset loadDataset(Configuration conf) throws IOException
{    Path datasetPath = getDistributedCacheFile(conf, 0);    return Dataset.load(conf, datasetPath);}
2a1112f469e13379aee492a9f25208f786c288fdefa8f4d2e7edfb040c3e5328
runJob
protected boolean runJob(Job job) throws ClassNotFoundException, IOException, InterruptedException
{    return job.waitForCompletion(true);}
9075f0d9ae3166c939af5f74db51a9e93591e2615dc1f010a0a17e394815f801
build
public DecisionForest build(int nbTrees) throws IOException, ClassNotFoundException, InterruptedException
{        Path outputPath = getOutputPath(conf);    FileSystem fs = outputPath.getFileSystem(conf);        if (fs.exists(outputPath)) {        throw new IOException("Output path already exists : " + outputPath);    }    if (seed != null) {        setRandomSeed(conf, seed);    }    setNbTrees(conf, nbTrees);    setTreeBuilder(conf, treeBuilder);        DistributedCache.addCacheFile(datasetPath.toUri(), conf);    Job job = new Job(conf, "decision forest builder");    log.debug("Configuring the job...");    configureJob(job);    log.debug("Running the job...");    if (!runJob(job)) {        log.error("Job failed!");        return null;    }    if (isOutput(conf)) {        log.debug("Parsing the output...");        DecisionForest forest = parseOutput(job);        HadoopUtil.delete(conf, outputPath);        return forest;    }    return null;}
a95bf45416bc565dde5cb5bc8373dfbada61f2cefa2c900a82d53b773b0ffe9c
sortSplits
public static void sortSplits(InputSplit[] splits)
{    Arrays.sort(splits, new Comparator<InputSplit>() {        @Override        public int compare(InputSplit a, InputSplit b) {            try {                long left = a.getLength();                long right = b.getLength();                if (left == right) {                    return 0;                } else if (left < right) {                    return 1;                } else {                    return -1;                }            } catch (IOException ie) {                throw new IllegalStateException("Problem getting input split size", ie);            } catch (InterruptedException ie) {                throw new IllegalStateException("Problem getting input split size", ie);            }        }    });}
e18fac032d13e323e0eba2d5561bc3ca4c3f31708c228a46ee37426b23317489
compare
public int compare(InputSplit a, InputSplit b)
{    try {        long left = a.getLength();        long right = b.getLength();        if (left == right) {            return 0;        } else if (left < right) {            return 1;        } else {            return -1;        }    } catch (IOException ie) {        throw new IllegalStateException("Problem getting input split size", ie);    } catch (InterruptedException ie) {        throw new IllegalStateException("Problem getting input split size", ie);    }}
e228cfd1cc1e9a678971d1b8e5fd00fc9576adad2cdd50c9cc728c3bd6942b8e
getResults
public double[][] getResults()
{    return results;}
1c702d6b37ab67573fb62e7b76d38bb496153fda875d35177d7ca1b1bb577e43
configureJob
private void configureJob(Job job) throws IOException
{    job.setJarByClass(Classifier.class);    FileInputFormat.setInputPaths(job, inputPath);    FileOutputFormat.setOutputPath(job, mappersOutputPath);    job.setOutputKeyClass(DoubleWritable.class);    job.setOutputValueClass(Text.class);    job.setMapperClass(CMapper.class);        job.setNumReduceTasks(0);    job.setInputFormatClass(CTextInputFormat.class);    job.setOutputFormatClass(SequenceFileOutputFormat.class);}
759de92f3a12e50de5e4e0f6b2aaec3006627d7ab348a0b2cb651d39bd04bcc1
run
public void run() throws IOException, ClassNotFoundException, InterruptedException
{    FileSystem fs = FileSystem.get(conf);        if (fs.exists(outputPath)) {        throw new IOException("Output path already exists : " + outputPath);    }    log.info("Adding the dataset to the DistributedCache");        DistributedCache.addCacheFile(datasetPath.toUri(), conf);    log.info("Adding the decision forest to the DistributedCache");    DistributedCache.addCacheFile(forestPath.toUri(), conf);    Job job = new Job(conf, "decision forest classifier");    log.info("Configuring the job...");    configureJob(job);    log.info("Running the job...");    if (!job.waitForCompletion(true)) {        throw new IllegalStateException("Job failed!");    }    parseOutput(job);    HadoopUtil.delete(conf, mappersOutputPath);}
4b84fd269bd0b9d6f219c5037bab7afc42e3a86ef7d4d84c0f39cf3dbfba7995
parseOutput
private void parseOutput(JobContext job) throws IOException
{    Configuration conf = job.getConfiguration();    FileSystem fs = mappersOutputPath.getFileSystem(conf);    Path[] outfiles = DFUtils.listOutputFiles(fs, mappersOutputPath);        List<double[]> resList = new ArrayList<>();    for (Path path : outfiles) {        FSDataOutputStream ofile = null;        try {            for (Pair<DoubleWritable, Text> record : new SequenceFileIterable<DoubleWritable, Text>(path, true, conf)) {                double key = record.getFirst().get();                String value = record.getSecond().toString();                if (ofile == null) {                                        ofile = fs.create(new Path(outputPath, value).suffix(".out"));                } else {                                                            ofile.writeChars(value);                    ofile.writeChar('\n');                    resList.add(new double[] { key, Double.valueOf(value) });                }            }        } finally {            Closeables.close(ofile, false);        }    }    results = new double[resList.size()][2];    resList.toArray(results);}
503e2f66f0d919e7f1e622adf3de1efd84c2a77133c7bdadfcf7270bcbfc012a
isSplitable
protected boolean isSplitable(JobContext jobContext, Path path)
{    return false;}
6b7dd49be7482fc8ee0fbe8bd0f24522f2a718c8c816a3d7b048fb4688eb6373
setup
protected void setup(Context context) throws IOException, InterruptedException
{        super.setup(context);    Configuration conf = context.getConfiguration();    Path[] files = HadoopUtil.getCachedFiles(conf);    if (files.length < 2) {        throw new IOException("not enough paths in the DistributedCache");    }    dataset = Dataset.load(conf, files[0]);    converter = new DataConverter(dataset);    forest = DecisionForest.load(conf, files[1]);    if (forest == null) {        throw new InterruptedException("DecisionForest not found!");    }}
364372c8c0a17a2c3987e3f0d31a4140befe124df0e3310d5d0fe71e39f33b0f
map
protected void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException
{    if (first) {        FileSplit split = (FileSplit) context.getInputSplit();                Path path = split.getPath();        lvalue.set(path.getName());        lkey.set(key.get());        context.write(lkey, lvalue);        first = false;    }    String line = value.toString();    if (!line.isEmpty()) {        Instance instance = converter.convert(line);        double prediction = forest.classify(dataset, rng, instance);        lkey.set(dataset.getLabel(instance));        lvalue.set(Double.toString(prediction));        context.write(lkey, lvalue);    }}
d56b2f62326a440afa67afb43a256c998fd5189099fdd98cfc91e096fab9b8f8
configureJob
protected void configureJob(Job job) throws IOException
{    Configuration conf = job.getConfiguration();    job.setJarByClass(InMemBuilder.class);    FileOutputFormat.setOutputPath(job, getOutputPath(conf));        DistributedCache.addCacheFile(getDataPath().toUri(), conf);    job.setOutputKeyClass(IntWritable.class);    job.setOutputValueClass(MapredOutput.class);    job.setMapperClass(InMemMapper.class);        job.setNumReduceTasks(0);    job.setInputFormatClass(InMemInputFormat.class);    job.setOutputFormatClass(SequenceFileOutputFormat.class);}
7e5de035c4f75263b002af591ea02bd6fcd57f12b83b1e9cff49caa4b50493eb
parseOutput
protected DecisionForest parseOutput(Job job) throws IOException
{    Configuration conf = job.getConfiguration();    Map<Integer, MapredOutput> output = new HashMap<>();    Path outputPath = getOutputPath(conf);    FileSystem fs = outputPath.getFileSystem(conf);    Path[] outfiles = DFUtils.listOutputFiles(fs, outputPath);        for (Path path : outfiles) {        for (Pair<IntWritable, MapredOutput> record : new SequenceFileIterable<IntWritable, MapredOutput>(path, conf)) {            output.put(record.getFirst().get(), record.getSecond());        }    }    return processOutput(output);}
98c27efcf04bc0d2e7508cd173e725da2244642b44eb1f5162702780dfb038e3
processOutput
private static DecisionForest processOutput(Map<Integer, MapredOutput> output)
{    List<Node> trees = new ArrayList<>();    for (Map.Entry<Integer, MapredOutput> entry : output.entrySet()) {        MapredOutput value = entry.getValue();        trees.add(value.getTree());    }    return new DecisionForest(trees);}
699484d3435121b37d89ae68103334c9c9b0b0197782e83a9f65044ba3d2dcf7
isSingleSeed
private static boolean isSingleSeed(Configuration conf)
{    return conf.getBoolean("debug.mahout.rf.single.seed", false);}
140cad52df65c927fc0d5fe84178dac91e3001369cc4d4118d65d6a50c63beb3
createRecordReader
public RecordReader<IntWritable, NullWritable> createRecordReader(InputSplit split, TaskAttemptContext context) throws IOException, InterruptedException
{    Preconditions.checkArgument(split instanceof InMemInputSplit);    return new InMemRecordReader((InMemInputSplit) split);}
e1583d64742b1ba5f62cdad391c6e5811e7c1b8c0580b3471117cbb77fdbb849
getSplits
public List<InputSplit> getSplits(JobContext context) throws IOException, InterruptedException
{    Configuration conf = context.getConfiguration();    int numSplits = conf.getInt("mapred.map.tasks", -1);    return getSplits(conf, numSplits);}
f3cbb97aa7f195404c035e9d27c88b3558acad5ea58c953459fee4a8f7e4ae48
getSplits
public List<InputSplit> getSplits(Configuration conf, int numSplits)
{    int nbTrees = Builder.getNbTrees(conf);    int splitSize = nbTrees / numSplits;    seed = Builder.getRandomSeed(conf);    isSingleSeed = isSingleSeed(conf);    if (rng != null && seed != null) {        log.warn("getSplits() was called more than once and the 'seed' is set, " + "this can lead to no-repeatable behavior");    }    rng = seed == null || isSingleSeed ? null : RandomUtils.getRandom(seed);    int id = 0;    List<InputSplit> splits = new ArrayList<>(numSplits);    for (int index = 0; index < numSplits - 1; index++) {        splits.add(new InMemInputSplit(id, splitSize, nextSeed()));        id += splitSize;    }        splits.add(new InMemInputSplit(id, nbTrees - id, nextSeed()));    return splits;}
a93e6d1f473240ae1e62f84923df28918e30e6a350ca932587f3b00c5c3ab1d5
nextSeed
private Long nextSeed()
{    if (seed == null) {        return null;    } else if (isSingleSeed) {        return seed;    } else {        return rng.nextLong();    }}
46dc59cbf7e4d6aafe0869ef2726ed2c5c897b673d9e37f94ab9b0e962f65f7f
getProgress
public float getProgress() throws IOException
{    return pos == 0 ? 0.0f : (float) (pos - 1) / split.nbTrees;}
e77ad85d4e7c41ccb662edb808e8ef6947f58c112f3c53b813716078da2fbaee
getCurrentKey
public IntWritable getCurrentKey() throws IOException, InterruptedException
{    return key;}
516196d2df7c75a44f80933c3abeffe4318669adbeb88e3be576e1a026727564
getCurrentValue
public NullWritable getCurrentValue() throws IOException, InterruptedException
{    return value;}
03eaed9671b1d78a77e47fb4cb483571ba14dc48fd42db353ce63be0ff56f870
initialize
public void initialize(InputSplit arg0, TaskAttemptContext arg1) throws IOException, InterruptedException
{    key = new IntWritable();    value = NullWritable.get();}
ea3a7eba5daf72a5cdc712e0c558af9956bcee4d2482e651bd64ac1a2c167657
nextKeyValue
public boolean nextKeyValue() throws IOException, InterruptedException
{    if (pos < split.nbTrees) {        key.set(split.firstId + pos);        pos++;        return true;    } else {        return false;    }}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{}
db9cfb86446583f56857115899cf2127c47629834b1c45285fdbce5af597ec3d
getFirstId
public int getFirstId()
{    return firstId;}
e5a90cee8ada6855413c3ed234930be0a64cc11452d740e8b81d788ed01ff470
getNbTrees
public int getNbTrees()
{    return nbTrees;}
01bb9939a5975a25dba541cd2f7c4a606733a23d97bf3ad1f1b4ce7bba4b5744
getSeed
public Long getSeed()
{    return seed;}
9cd3ad9bf4a05b331833c639755ae4f81500bf1da82c30049ab97309a4bb3d9f
getLength
public long getLength() throws IOException
{    return nbTrees;}
09395a9599cab7bb2e1f34feff81cbbcfc81ea48b04f555c84abc6a47cf73117
getLocations
public String[] getLocations() throws IOException
{    return NO_LOCATIONS;}
4afeb0868b55bdd8e18a00a3cb43d83e0714378d1c4bb36f0936daefc060e2e8
equals
public boolean equals(Object obj)
{    if (this == obj) {        return true;    }    if (!(obj instanceof InMemInputSplit)) {        return false;    }    InMemInputSplit split = (InMemInputSplit) obj;    if (firstId != split.firstId || nbTrees != split.nbTrees) {        return false;    }    if (seed == null) {        return split.seed == null;    } else {        return seed.equals(split.seed);    }}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return firstId + nbTrees + (seed == null ? 0 : seed.intValue());}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return String.format(Locale.ENGLISH, "[firstId:%d, nbTrees:%d, seed:%d]", firstId, nbTrees, seed);}
5478cc5683f6dfd4515c383752d7c803555efc63d03fd84a03ba8dcd17eb4324
readFields
public void readFields(DataInput in) throws IOException
{    firstId = in.readInt();    nbTrees = in.readInt();    boolean isSeed = in.readBoolean();    seed = isSeed ? in.readLong() : null;}
a894510dd4db439ff8e17ae1059489dc3abc97178e5932ceed0c70c3af165401
write
public void write(DataOutput out) throws IOException
{    out.writeInt(firstId);    out.writeInt(nbTrees);    out.writeBoolean(seed != null);    if (seed != null) {        out.writeLong(seed);    }}
5dc0914bfc57129599ac6cd65c3ec83522e7b19a3a6d0ec6862c47764de6af0d
read
public static InMemInputSplit read(DataInput in) throws IOException
{    InMemInputSplit split = new InMemInputSplit();    split.readFields(in);    return split;}
e540a940e76d075657d822b73323caf5d4040193e2e234448bb590ac80ef0723
loadData
private static Data loadData(Configuration conf, Dataset dataset) throws IOException
{    Path dataPath = Builder.getDistributedCacheFile(conf, 1);    FileSystem fs = FileSystem.get(dataPath.toUri(), conf);    return DataLoader.loadData(dataset, fs, dataPath);}
6b7dd49be7482fc8ee0fbe8bd0f24522f2a718c8c816a3d7b048fb4688eb6373
setup
protected void setup(Context context) throws IOException, InterruptedException
{    super.setup(context);    Configuration conf = context.getConfiguration();    log.info("Loading the data...");    Data data = loadData(conf, getDataset());    log.info("Data loaded : {} instances", data.size());    bagging = new Bagging(getTreeBuilder(), data);}
516b82215ec69b732594124a98e93b54168c24ee2ab168d71eaff68b01b71039
map
protected void map(IntWritable key, NullWritable value, Context context) throws IOException, InterruptedException
{    map(key, context);}
4865b23ecb093c336fae991368bcf31e5116e7cf9804800de7dad5596de35652
map
 void map(IntWritable key, Context context) throws IOException, InterruptedException
{    initRandom((InMemInputSplit) context.getInputSplit());    log.debug("Building...");    Node tree = bagging.build(rng);    if (isOutput()) {        log.debug("Outputing...");        MapredOutput mrOut = new MapredOutput(tree);        context.write(key, mrOut);    }}
85886f5ea3de7341083d38774dc16320cc20058d5041c6bb1d1a2c9e56ce7946
initRandom
 void initRandom(InMemInputSplit split)
{    if (rng == null) {                Long seed = split.getSeed();        log.debug("Initialising rng with seed : {}", seed);        rng = seed == null ? RandomUtils.getRandom() : RandomUtils.getRandom(seed);    }}
87ac2ccf0de0c0111bdb98869af2d081736f3a911cf46c7add4fad88edc94e98
isOutput
protected boolean isOutput()
{    return !noOutput;}
4d155bbefc6a7c11d819dab2791b44babcf4d6f94ead1baead8bce45be8b0335
getTreeBuilder
protected TreeBuilder getTreeBuilder()
{    return treeBuilder;}
0bf760d393ecdafd94512eaf8a77ebcca26a5e422038d0a64165c25b4679d380
getDataset
protected Dataset getDataset()
{    return dataset;}
6b7dd49be7482fc8ee0fbe8bd0f24522f2a718c8c816a3d7b048fb4688eb6373
setup
protected void setup(Context context) throws IOException, InterruptedException
{    super.setup(context);    Configuration conf = context.getConfiguration();    configure(!Builder.isOutput(conf), Builder.getTreeBuilder(conf), Builder.loadDataset(conf));}
db5fbbabe475a7a11af88ddfa659cc0d5213e46183edac98788497995de3a7ac
configure
protected void configure(boolean noOutput, TreeBuilder treeBuilder, Dataset dataset)
{    Preconditions.checkArgument(treeBuilder != null, "TreeBuilder not found in the Job parameters");    this.noOutput = noOutput;    this.treeBuilder = treeBuilder;    this.dataset = dataset;}
aa74dd721d3cdcac782e6aa03fbcfd7859a87274cb230a3bed74c5faa259c934
getTree
public Node getTree()
{    return tree;}
de6b041e8692c6bfc1f6d5680b59cbf43b808fdada2526b9d0e9e9af9dda4e31
getPredictions
 int[] getPredictions()
{    return predictions;}
5478cc5683f6dfd4515c383752d7c803555efc63d03fd84a03ba8dcd17eb4324
readFields
public void readFields(DataInput in) throws IOException
{    boolean readTree = in.readBoolean();    if (readTree) {        tree = Node.read(in);    }    boolean readPredictions = in.readBoolean();    if (readPredictions) {        predictions = DFUtils.readIntArray(in);    }}
a894510dd4db439ff8e17ae1059489dc3abc97178e5932ceed0c70c3af165401
write
public void write(DataOutput out) throws IOException
{    out.writeBoolean(tree != null);    if (tree != null) {        tree.write(out);    }    out.writeBoolean(predictions != null);    if (predictions != null) {        DFUtils.writeArray(out, predictions);    }}
a21e4eedda47e338135dc9771192d1717a6fc9247a4db66445be47b17d29e14b
clone
public MapredOutput clone()
{    return new MapredOutput(tree, predictions);}
4afeb0868b55bdd8e18a00a3cb43d83e0714378d1c4bb36f0936daefc060e2e8
equals
public boolean equals(Object obj)
{    if (this == obj) {        return true;    }    if (!(obj instanceof MapredOutput)) {        return false;    }    MapredOutput mo = (MapredOutput) obj;    return ((tree == null && mo.getTree() == null) || (tree != null && tree.equals(mo.getTree()))) && Arrays.equals(predictions, mo.getPredictions());}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    int hashCode = tree == null ? 1 : tree.hashCode();    for (int prediction : predictions) {        hashCode = 31 * hashCode + prediction;    }    return hashCode;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "{" + tree + " | " + Arrays.toString(predictions) + '}';}
d56b2f62326a440afa67afb43a256c998fd5189099fdd98cfc91e096fab9b8f8
configureJob
protected void configureJob(Job job) throws IOException
{    Configuration conf = job.getConfiguration();    job.setJarByClass(PartialBuilder.class);    FileInputFormat.setInputPaths(job, getDataPath());    FileOutputFormat.setOutputPath(job, getOutputPath(conf));    job.setOutputKeyClass(TreeID.class);    job.setOutputValueClass(MapredOutput.class);    job.setMapperClass(Step1Mapper.class);        job.setNumReduceTasks(0);    job.setInputFormatClass(TextInputFormat.class);    job.setOutputFormatClass(SequenceFileOutputFormat.class);            TextInputFormat inputFormat = new TextInputFormat();    List<?> splits = inputFormat.getSplits(job);    if (splits == null || splits.isEmpty()) {        log.warn("Unable to compute number of splits?");    } else {        int numSplits = splits.size();        log.info("Setting mapred.map.tasks = {}", numSplits);        conf.setInt("mapred.map.tasks", numSplits);    }}
7e5de035c4f75263b002af591ea02bd6fcd57f12b83b1e9cff49caa4b50493eb
parseOutput
protected DecisionForest parseOutput(Job job) throws IOException
{    Configuration conf = job.getConfiguration();    int numTrees = Builder.getNbTrees(conf);    Path outputPath = getOutputPath(conf);    TreeID[] keys = new TreeID[numTrees];    Node[] trees = new Node[numTrees];    processOutput(job, outputPath, keys, trees);    return new DecisionForest(Arrays.asList(trees));}
93b4bc7ae8b322763a497b671a56b489b8be4c8584db8b929f403880527c6f6f
processOutput
protected static void processOutput(JobContext job, Path outputPath, TreeID[] keys, Node[] trees) throws IOException
{    Preconditions.checkArgument(keys == null && trees == null || keys != null && trees != null, "if keys is null, trees should also be null");    Preconditions.checkArgument(keys == null || keys.length == trees.length, "keys.length != trees.length");    Configuration conf = job.getConfiguration();    FileSystem fs = outputPath.getFileSystem(conf);    Path[] outfiles = DFUtils.listOutputFiles(fs, outputPath);        int index = 0;    for (Path path : outfiles) {        for (Pair<TreeID, MapredOutput> record : new SequenceFileIterable<TreeID, MapredOutput>(path, conf)) {            TreeID key = record.getFirst();            MapredOutput value = record.getSecond();            if (keys != null) {                keys[index] = key;            }            if (trees != null) {                trees[index] = value.getTree();            }            index++;        }    }        if (keys != null && index != keys.length) {        throw new IllegalStateException("Some key/values are missing from the output");    }}
6cc834e6ff946ad1224162ba4aeb9ea63a5ee002e937a9d1f0f20ae07979195e
getFirstTreeId
public int getFirstTreeId()
{    return firstTreeId;}
6b7dd49be7482fc8ee0fbe8bd0f24522f2a718c8c816a3d7b048fb4688eb6373
setup
protected void setup(Context context) throws IOException, InterruptedException
{    super.setup(context);    Configuration conf = context.getConfiguration();    configure(Builder.getRandomSeed(conf), conf.getInt("mapred.task.partition", -1), Builder.getNumMaps(conf), Builder.getNbTrees(conf));}
2d6af1f6f1a48dde164fadaf6ddb999fc7bb18083a0b9c76408de65016f43fa5
configure
protected void configure(Long seed, int partition, int numMapTasks, int numTrees)
{    converter = new DataConverter(getDataset());        log.debug("seed : {}", seed);    if (seed == null) {        rng = RandomUtils.getRandom();    } else {        rng = RandomUtils.getRandom(seed);    }        Preconditions.checkArgument(partition >= 0, "Wrong partition ID: " + partition + ". Partition must be >= 0!");    this.partition = partition;        nbTrees = nbTrees(numMapTasks, numTrees, partition);        firstTreeId = 0;    for (int p = 0; p < partition; p++) {        firstTreeId += nbTrees(numMapTasks, numTrees, p);    }    log.debug("partition : {}", partition);    log.debug("nbTrees : {}", nbTrees);    log.debug("firstTreeId : {}", firstTreeId);}
48356e8da182308c32f23b6b9f7bc4ed14084c5b0334f0d8f60576e2bc98091e
nbTrees
public static int nbTrees(int numMaps, int numTrees, int partition)
{    int treesPerMapper = numTrees / numMaps;    int remainder = numTrees - numMaps * treesPerMapper;    return treesPerMapper + (partition < remainder ? 1 : 0);}
364372c8c0a17a2c3987e3f0d31a4140befe124df0e3310d5d0fe71e39f33b0f
map
protected void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException
{    instances.add(converter.convert(value.toString()));}
2e250b70eb1261a97967b8b894cf822fc9e7eb36891dbb77c6d16369f85de12a
cleanup
protected void cleanup(Context context) throws IOException, InterruptedException
{        log.debug("partition: {} numInstances: {}", partition, instances.size());    Data data = new Data(getDataset(), instances);    Bagging bagging = new Bagging(getTreeBuilder(), data);    TreeID key = new TreeID();    log.debug("Building {} trees", nbTrees);    for (int treeId = 0; treeId < nbTrees; treeId++) {        log.debug("Building tree number : {}", treeId);        Node tree = bagging.build(rng);        key.set(partition, firstTreeId + treeId);        if (isOutput()) {            MapredOutput emOut = new MapredOutput(tree);            context.write(key, emOut);        }        context.progress();    }}
ab94153f05d6049bdfe7e0feefaad6d38cbf5209e9cc0d14863a6f5803b03c7c
set
public void set(int partition, int treeId)
{    set((long) partition * MAX_TREEID + treeId);}
a1bf64bbd3be1d456af88a609152e947ff3d2d5baa866825d97d3eff20e9a7b4
partition
public int partition()
{    return (int) (get() / MAX_TREEID);}
a9ed46350bbee72dc8e82ab00836bf1f6503db84fa984dc9e77355951e670eaa
treeId
public int treeId()
{    return (int) (get() % MAX_TREEID);}
5a61536ac193c02547ee5dcd256507f4a9f165bb2d11becb880db4d3f7e61e14
clone
public TreeID clone()
{    return new TreeID(partition(), treeId());}
7828b6c68433c292ac9973f3a7c7575e8c67235e6cdb48c198078d009a1ec634
classify
public double classify(Instance instance)
{    int index = ArrayUtils.indexOf(values, instance.get(attr));    if (index == -1) {                return Double.NaN;    }    return childs[index].classify(instance);}
40d96713cdb337091923827a9683f67c6d3155da309417738f346286905f49b4
maxDepth
public long maxDepth()
{    long max = 0;    for (Node child : childs) {        long depth = child.maxDepth();        if (depth > max) {            max = depth;        }    }    return 1 + max;}
3714f26f344dd74f219584979fea96e9dbf2fcaed8d91a1b4ba7a32b83aa8e50
nbNodes
public long nbNodes()
{    long nbNodes = 1;    for (Node child : childs) {        nbNodes += child.nbNodes();    }    return nbNodes;}
ea82da4329267437d83f0b028133a316b52cd6c74b0ee4298f65c34744e2c092
getType
protected Type getType()
{    return Type.CATEGORICAL;}
4afeb0868b55bdd8e18a00a3cb43d83e0714378d1c4bb36f0936daefc060e2e8
equals
public boolean equals(Object obj)
{    if (this == obj) {        return true;    }    if (!(obj instanceof CategoricalNode)) {        return false;    }    CategoricalNode node = (CategoricalNode) obj;    return attr == node.attr && Arrays.equals(values, node.values) && Arrays.equals(childs, node.childs);}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    int hashCode = attr;    for (double value : values) {        hashCode = 31 * hashCode + (int) Double.doubleToLongBits(value);    }    for (Node node : childs) {        hashCode = 31 * hashCode + node.hashCode();    }    return hashCode;}
562a479d6f11bd4d8d3b4600ea5b389c0b4dc7a315c35f38eb6c0a13505d13cf
getString
protected String getString()
{    StringBuilder buffer = new StringBuilder();    for (Node child : childs) {        buffer.append(child).append(',');    }    return buffer.toString();}
5478cc5683f6dfd4515c383752d7c803555efc63d03fd84a03ba8dcd17eb4324
readFields
public void readFields(DataInput in) throws IOException
{    attr = in.readInt();    values = DFUtils.readDoubleArray(in);    childs = DFUtils.readNodeArray(in);}
6d11fa6d3e313bbb213a80bf40f8a82669421cff09d505db4e4efc5a21202454
writeNode
protected void writeNode(DataOutput out) throws IOException
{    out.writeInt(attr);    DFUtils.writeArray(out, values);    DFUtils.writeArray(out, childs);}
7828b6c68433c292ac9973f3a7c7575e8c67235e6cdb48c198078d009a1ec634
classify
public double classify(Instance instance)
{    return label;}
40d96713cdb337091923827a9683f67c6d3155da309417738f346286905f49b4
maxDepth
public long maxDepth()
{    return 1;}
3714f26f344dd74f219584979fea96e9dbf2fcaed8d91a1b4ba7a32b83aa8e50
nbNodes
public long nbNodes()
{    return 1;}
ea82da4329267437d83f0b028133a316b52cd6c74b0ee4298f65c34744e2c092
getType
protected Type getType()
{    return Type.LEAF;}
4afeb0868b55bdd8e18a00a3cb43d83e0714378d1c4bb36f0936daefc060e2e8
equals
public boolean equals(Object obj)
{    if (this == obj) {        return true;    }    if (!(obj instanceof Leaf)) {        return false;    }    Leaf leaf = (Leaf) obj;    return Math.abs(label - leaf.label) < EPSILON;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    long bits = Double.doubleToLongBits(label);    return (int) (bits ^ (bits >>> 32));}
562a479d6f11bd4d8d3b4600ea5b389c0b4dc7a315c35f38eb6c0a13505d13cf
getString
protected String getString()
{    return "";}
5478cc5683f6dfd4515c383752d7c803555efc63d03fd84a03ba8dcd17eb4324
readFields
public void readFields(DataInput in) throws IOException
{    label = in.readDouble();}
6d11fa6d3e313bbb213a80bf40f8a82669421cff09d505db4e4efc5a21202454
writeNode
protected void writeNode(DataOutput out) throws IOException
{    out.writeDouble(label);}
15e7a32a0caaf5a6029bf202e53e4e893e0cc24c2336c5c61628b0af232b6c20
read
public static Node read(DataInput in) throws IOException
{    Type type = Type.values()[in.readInt()];    Node node;    switch(type) {        case LEAF:            node = new Leaf();            break;        case NUMERICAL:            node = new NumericalNode();            break;        case CATEGORICAL:            node = new CategoricalNode();            break;        default:            throw new IllegalStateException("This implementation is not currently supported");    }    node.readFields(in);    return node;}
30c5449c6b5eb9c7f0a380bfd47f034e2fb127c28cd09faea4b05291405320a0
toString
public final String toString()
{    return getType() + ":" + getString() + ';';}
6ce8f423999e48ee8ccc8ead0930648784c8032b66979cb68c99c4f899ae9ef8
write
public final void write(DataOutput out) throws IOException
{    out.writeInt(getType().ordinal());    writeNode(out);}
7828b6c68433c292ac9973f3a7c7575e8c67235e6cdb48c198078d009a1ec634
classify
public double classify(Instance instance)
{    if (instance.get(attr) < split) {        return loChild.classify(instance);    } else {        return hiChild.classify(instance);    }}
40d96713cdb337091923827a9683f67c6d3155da309417738f346286905f49b4
maxDepth
public long maxDepth()
{    return 1 + Math.max(loChild.maxDepth(), hiChild.maxDepth());}
3714f26f344dd74f219584979fea96e9dbf2fcaed8d91a1b4ba7a32b83aa8e50
nbNodes
public long nbNodes()
{    return 1 + loChild.nbNodes() + hiChild.nbNodes();}
ea82da4329267437d83f0b028133a316b52cd6c74b0ee4298f65c34744e2c092
getType
protected Type getType()
{    return Type.NUMERICAL;}
4afeb0868b55bdd8e18a00a3cb43d83e0714378d1c4bb36f0936daefc060e2e8
equals
public boolean equals(Object obj)
{    if (this == obj) {        return true;    }    if (!(obj instanceof NumericalNode)) {        return false;    }    NumericalNode node = (NumericalNode) obj;    return attr == node.attr && split == node.split && loChild.equals(node.loChild) && hiChild.equals(node.hiChild);}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return attr + (int) Double.doubleToLongBits(split) + loChild.hashCode() + hiChild.hashCode();}
562a479d6f11bd4d8d3b4600ea5b389c0b4dc7a315c35f38eb6c0a13505d13cf
getString
protected String getString()
{    return loChild.toString() + ',' + hiChild.toString();}
5478cc5683f6dfd4515c383752d7c803555efc63d03fd84a03ba8dcd17eb4324
readFields
public void readFields(DataInput in) throws IOException
{    attr = in.readInt();    split = in.readDouble();    loChild = Node.read(in);    hiChild = Node.read(in);}
6d11fa6d3e313bbb213a80bf40f8a82669421cff09d505db4e4efc5a21202454
writeNode
protected void writeNode(DataOutput out) throws IOException
{    out.writeInt(attr);    out.writeDouble(split);    loChild.write(out);    hiChild.write(out);}
07dc971338a7babcff73cedb45cd4e595180a11879e5276c422c84d38dfbeb7c
build
public DecisionForest build(int nbTrees)
{    List<Node> trees = new ArrayList<>();    for (int treeId = 0; treeId < nbTrees; treeId++) {        trees.add(bagging.build(rng));        logProgress(((float) treeId + 1) / nbTrees);    }    return new DecisionForest(trees);}
896f80a1dc7b5f9f4c98be936dd99fed8dbfe430bd91d2c3d7189919ff26c61c
logProgress
private static void logProgress(float progress)
{    int percent = (int) (progress * 100);    if (percent % 10 == 0) {        log.info("Building {}%", percent);    }}
d7d1ce00d89a55655e70f0c731f389c2e3d378efaf44f5874f9b4b6209c88d40
computeSplit
public Split computeSplit(Data data, int attr)
{    if (data.getDataset().isNumerical(attr)) {        double[] values = data.values(attr);        double bestIg = -1;        double bestSplit = 0.0;        for (double value : values) {            double ig = numericalIg(data, attr, value);            if (ig > bestIg) {                bestIg = ig;                bestSplit = value;            }        }        return new Split(attr, bestIg, bestSplit);    } else {        double ig = categoricalIg(data, attr);        return new Split(attr, ig);    }}
a1e9d457739dd97b56d8f130371a3dfd0a993b29d7106858fc0b4ae3f39ce22f
categoricalIg
 double categoricalIg(Data data, int attr)
{    double[] values = data.values(attr);        double hy = entropy(data);        double hyx = 0.0;    double invDataSize = 1.0 / data.size();    for (double value : values) {        Data subset = data.subset(Condition.equals(attr, value));        hyx += subset.size() * invDataSize * entropy(subset);    }    return hy - hyx;}
2267b605ee5b727efdae57408d340d00f1d2c9b793f78ce5c2c1f7fc326e96b2
numericalIg
 double numericalIg(Data data, int attr, double split)
{    double hy = entropy(data);    double invDataSize = 1.0 / data.size();        Data subset = data.subset(Condition.lesser(attr, split));    hy -= subset.size() * invDataSize * entropy(subset);        subset = data.subset(Condition.greaterOrEquals(attr, split));    hy -= subset.size() * invDataSize * entropy(subset);    return hy;}
bd15b0f846444e5c2e628ac63d7da9571c3ce77e17c84fa011b7e0a2853e8a36
entropy
protected double entropy(Data data)
{    double invDataSize = 1.0 / data.size();    if (counts == null) {        counts = new int[data.getDataset().nblabels()];    }    Arrays.fill(counts, 0);    data.countLabels(counts);    double entropy = 0.0;    for (int label = 0; label < data.getDataset().nblabels(); label++) {        int count = counts[label];        if (count == 0) {                        continue;        }        double p = count * invDataSize;        entropy += -p * Math.log(p) / LOG2;    }    return entropy;}
d7d1ce00d89a55655e70f0c731f389c2e3d378efaf44f5874f9b4b6209c88d40
computeSplit
public Split computeSplit(Data data, int attr)
{    if (data.getDataset().isNumerical(attr)) {        return numericalSplit(data, attr);    } else {        return categoricalSplit(data, attr);    }}
f287065c966565593b86b559ac8c59f1130d64e64ebaa39bfe492261e0bb3af3
categoricalSplit
private static Split categoricalSplit(Data data, int attr)
{    double[] values = data.values(attr).clone();    double[] splitPoints = chooseCategoricalSplitPoints(values);    int numLabels = data.getDataset().nblabels();    int[][] counts = new int[splitPoints.length][numLabels];    int[] countAll = new int[numLabels];    computeFrequencies(data, attr, splitPoints, counts, countAll);    int size = data.size();        double hy = entropy(countAll, size);        double hyx = 0.0;    double invDataSize = 1.0 / size;    for (int index = 0; index < splitPoints.length; index++) {        size = DataUtils.sum(counts[index]);        hyx += size * invDataSize * entropy(counts[index], size);    }    double ig = hy - hyx;    return new Split(attr, ig);}
d6600ac58c6d3d03ae90e8e0e8a59aab9f9b137c961764b663755c45d59f98da
computeFrequencies
 static void computeFrequencies(Data data, int attr, double[] splitPoints, int[][] counts, int[] countAll)
{    Dataset dataset = data.getDataset();    for (int index = 0; index < data.size(); index++) {        Instance instance = data.get(index);        int label = (int) dataset.getLabel(instance);        double value = instance.get(attr);        int split = 0;        while (split < splitPoints.length && value > splitPoints[split]) {            split++;        }        if (split < splitPoints.length) {            counts[split][label]++;        }                countAll[label]++;    }}
7778f5c376dc181261805fab5fca23554583dc9424fa0501621ea50f202e31bc
numericalSplit
 static Split numericalSplit(Data data, int attr)
{    double[] values = data.values(attr).clone();    Arrays.sort(values);    double[] splitPoints = chooseNumericSplitPoints(values);    int numLabels = data.getDataset().nblabels();    int[][] counts = new int[splitPoints.length][numLabels];    int[] countAll = new int[numLabels];    int[] countLess = new int[numLabels];    computeFrequencies(data, attr, splitPoints, counts, countAll);    int size = data.size();    double hy = entropy(countAll, size);    double invDataSize = 1.0 / size;    int best = -1;    double bestIg = -1.0;        for (int index = 0; index < splitPoints.length; index++) {        double ig = hy;        DataUtils.add(countLess, counts[index]);        DataUtils.dec(countAll, counts[index]);                size = DataUtils.sum(countLess);        ig -= size * invDataSize * entropy(countLess, size);                size = DataUtils.sum(countAll);        ig -= size * invDataSize * entropy(countAll, size);        if (ig > bestIg) {            bestIg = ig;            best = index;        }    }    if (best == -1) {        throw new IllegalStateException("no best split found !");    }    return new Split(attr, bestIg, splitPoints[best]);}
8cf700429acacadc97460c95c97eedbda9998164807c30580819ec027d9ac96d
chooseNumericSplitPoints
private static double[] chooseNumericSplitPoints(double[] values)
{    if (values.length <= 1) {        return values;    }    if (values.length <= MAX_NUMERIC_SPLITS + 1) {        double[] splitPoints = new double[values.length - 1];        for (int i = 1; i < values.length; i++) {            splitPoints[i - 1] = (values[i] + values[i - 1]) / 2.0;        }        return splitPoints;    }    Percentile distribution = new Percentile();    distribution.setData(values);    double[] percentiles = new double[MAX_NUMERIC_SPLITS];    for (int i = 0; i < percentiles.length; i++) {        double p = 100.0 * ((i + 1.0) / (MAX_NUMERIC_SPLITS + 1.0));        percentiles[i] = distribution.evaluate(p);    }    return percentiles;}
5dcbf2a02cf4fda66e32a0106f5e53ef9a6acf8b975482a3143c88c0bfc6ac3b
chooseCategoricalSplitPoints
private static double[] chooseCategoricalSplitPoints(double[] values)
{                Collection<Double> uniqueOrderedCategories = new TreeSet<>();    for (double v : values) {        uniqueOrderedCategories.add(v);    }    double[] uniqueValues = new double[uniqueOrderedCategories.size()];    Iterator<Double> it = uniqueOrderedCategories.iterator();    for (int i = 0; i < uniqueValues.length; i++) {        uniqueValues[i] = it.next();    }    return uniqueValues;}
fa932601e555d0f836dd5c3d8153a89881039edcd55eced40e72661db73b24fe
entropy
private static double entropy(int[] counts, int dataSize)
{    if (dataSize == 0) {        return 0.0;    }    double entropy = 0.0;    for (int count : counts) {        if (count > 0) {            double p = count / (double) dataSize;            entropy -= p * Math.log(p);        }    }    return entropy / LOG2;}
ee7a2fd44e967d3392e9956fa003b4933603a5076cc65ee09131ed8634dd3f39
compare
public int compare(Instance arg0, Instance arg1)
{    return Double.compare(arg0.get(attr), arg1.get(attr));}
d7d1ce00d89a55655e70f0c731f389c2e3d378efaf44f5874f9b4b6209c88d40
computeSplit
public Split computeSplit(Data data, int attr)
{    if (data.getDataset().isNumerical(attr)) {        return numericalSplit(data, attr);    } else {        return categoricalSplit(data, attr);    }}
f287065c966565593b86b559ac8c59f1130d64e64ebaa39bfe492261e0bb3af3
categoricalSplit
private static Split categoricalSplit(Data data, int attr)
{    FullRunningAverage[] ra = new FullRunningAverage[data.getDataset().nbValues(attr)];    double[] sk = new double[data.getDataset().nbValues(attr)];    for (int i = 0; i < ra.length; i++) {        ra[i] = new FullRunningAverage();    }    FullRunningAverage totalRa = new FullRunningAverage();    double totalSk = 0.0;    for (int i = 0; i < data.size(); i++) {                Instance instance = data.get(i);        int value = (int) instance.get(attr);        double xk = data.getDataset().getLabel(instance);        if (ra[value].getCount() == 0) {            ra[value].addDatum(xk);            sk[value] = 0.0;        } else {            double mk = ra[value].getAverage();            ra[value].addDatum(xk);            sk[value] += (xk - mk) * (xk - ra[value].getAverage());        }                if (i == 0) {            totalRa.addDatum(xk);            totalSk = 0.0;        } else {            double mk = totalRa.getAverage();            totalRa.addDatum(xk);            totalSk += (xk - mk) * (xk - totalRa.getAverage());        }    }        double ig = totalSk;    for (double aSk : sk) {        ig -= aSk;    }    return new Split(attr, ig);}
37f6ac45fc8e0cfd1cc4b1138e99bda29578ecbea614cdbcb7a4bf73d09231b6
numericalSplit
private static Split numericalSplit(Data data, int attr)
{    FullRunningAverage[] ra = new FullRunningAverage[2];    for (int i = 0; i < ra.length; i++) {        ra[i] = new FullRunningAverage();    }        Instance[] instances = new Instance[data.size()];    for (int i = 0; i < data.size(); i++) {        instances[i] = data.get(i);    }    Arrays.sort(instances, new InstanceComparator(attr));    double[] sk = new double[2];    for (Instance instance : instances) {        double xk = data.getDataset().getLabel(instance);        if (ra[1].getCount() == 0) {            ra[1].addDatum(xk);            sk[1] = 0.0;        } else {            double mk = ra[1].getAverage();            ra[1].addDatum(xk);            sk[1] += (xk - mk) * (xk - ra[1].getAverage());        }    }    double totalSk = sk[1];        double split = Double.NaN;    double preSplit = Double.NaN;    double bestVal = Double.MAX_VALUE;    double bestSk = 0.0;        for (Instance instance : instances) {        double xk = data.getDataset().getLabel(instance);        if (instance.get(attr) > preSplit) {            double curVal = sk[0] / ra[0].getCount() + sk[1] / ra[1].getCount();            if (curVal < bestVal) {                bestVal = curVal;                bestSk = sk[0] + sk[1];                split = (instance.get(attr) + preSplit) / 2.0;            }        }                if (ra[0].getCount() == 0) {            ra[0].addDatum(xk);            sk[0] = 0.0;        } else {            double mk = ra[0].getAverage();            ra[0].addDatum(xk);            sk[0] += (xk - mk) * (xk - ra[0].getAverage());        }        double mk = ra[1].getAverage();        ra[1].removeDatum(xk);        sk[1] -= (xk - mk) * (xk - ra[1].getAverage());        preSplit = instance.get(attr);    }        double ig = totalSk - bestSk;    return new Split(attr, ig, split);}
e7f1c234dace47b4a9ae9538dd2987a01ca4471add1a19ff41f74c843a04adb8
getAttr
public int getAttr()
{    return attr;}
88054cd5267eb48d91bfeb9d507caebe8324d7b8d1b7e652f48ed8af06166d12
getIg
public double getIg()
{    return ig;}
14e52d5423c40997d90e8ede1eac0bf2b66bd89f1e3a67842eef8f6dd310772e
getSplit
public double getSplit()
{    return split;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return String.format(Locale.ENGLISH, "attr: %d, ig: %f, split: %f", attr, ig, split);}
97c22a2eb047df511b163ab73e19399427b06d47b0249c17e40a0b427c673c15
main
public static int main(String[] args) throws Exception
{    return ToolRunner.run(new Describe(), args);}
aacecb0f01750d985b78d806dc3c134f0da79efe2752957e0f93ecf5cbf9e492
run
public int run(String[] args) throws Exception
{    DefaultOptionBuilder obuilder = new DefaultOptionBuilder();    ArgumentBuilder abuilder = new ArgumentBuilder();    GroupBuilder gbuilder = new GroupBuilder();    Option pathOpt = obuilder.withLongName("path").withShortName("p").withRequired(true).withArgument(abuilder.withName("path").withMinimum(1).withMaximum(1).create()).withDescription("Data path").create();    Option descriptorOpt = obuilder.withLongName("descriptor").withShortName("d").withRequired(true).withArgument(abuilder.withName("descriptor").withMinimum(1).create()).withDescription("data descriptor").create();    Option descPathOpt = obuilder.withLongName("file").withShortName("f").withRequired(true).withArgument(abuilder.withName("file").withMinimum(1).withMaximum(1).create()).withDescription("Path to generated descriptor file").create();    Option regOpt = obuilder.withLongName("regression").withDescription("Regression Problem").withShortName("r").create();    Option helpOpt = obuilder.withLongName("help").withDescription("Print out help").withShortName("h").create();    Group group = gbuilder.withName("Options").withOption(pathOpt).withOption(descPathOpt).withOption(descriptorOpt).withOption(regOpt).withOption(helpOpt).create();    try {        Parser parser = new Parser();        parser.setGroup(group);        CommandLine cmdLine = parser.parse(args);        if (cmdLine.hasOption(helpOpt)) {            CommandLineUtil.printHelp(group);            return -1;        }        String dataPath = cmdLine.getValue(pathOpt).toString();        String descPath = cmdLine.getValue(descPathOpt).toString();        List<String> descriptor = convert(cmdLine.getValues(descriptorOpt));        boolean regression = cmdLine.hasOption(regOpt);        log.debug("Data path : {}", dataPath);        log.debug("Descriptor path : {}", descPath);        log.debug("Descriptor : {}", descriptor);        log.debug("Regression : {}", regression);        runTool(dataPath, descriptor, descPath, regression);    } catch (OptionException e) {        log.warn(e.toString());        CommandLineUtil.printHelp(group);    }    return 0;}
6afebc813904b76a1ec1796aac9765dad4b9fcde5a4eb789679bb6e56844417a
runTool
private void runTool(String dataPath, Iterable<String> description, String filePath, boolean regression) throws DescriptorException, IOException
{    log.info("Generating the descriptor...");    String descriptor = DescriptorUtils.generateDescriptor(description);    Path fPath = validateOutput(filePath);    log.info("generating the dataset...");    Dataset dataset = generateDataset(descriptor, dataPath, regression);    log.info("storing the dataset description");    String json = dataset.toJSON();    DFUtils.storeString(conf, fPath, json);}
eb194916196fdf0b0168a346def57fb1ab5eb600c79f95cd7f1a9fe4240d090e
generateDataset
private Dataset generateDataset(String descriptor, String dataPath, boolean regression) throws IOException, DescriptorException
{    Path path = new Path(dataPath);    FileSystem fs = path.getFileSystem(conf);    return DataLoader.generateDataset(descriptor, regression, fs, path);}
7585b20eaa2a251db4469e7aa88f787ac0e9782ca0c01d04e4475153d996cd14
validateOutput
private Path validateOutput(String filePath) throws IOException
{    Path path = new Path(filePath);    FileSystem fs = path.getFileSystem(conf);    if (fs.exists(path)) {        throw new IllegalStateException("Descriptor's file already exists");    }    return path;}
0dea3a3fea79c2e8799da445dbb94b3cefd0717ffd84e7d90307a3be3e2f5d11
convert
private static List<String> convert(Collection<?> values)
{    List<String> list = new ArrayList<>(values.size());    for (Object value : values) {        list.add(value.toString());    }    return list;}
091ae8920ba2500c68ed3c0e76a8a5bc261fbb417c27d5e101a1a650b7988331
setConf
public void setConf(Configuration entries)
{    this.conf = entries;}
d221713f567be6c3a854157b6beb8a5fd5dd64b69c1ef157fb4bac811a41c3f7
getConf
public Configuration getConf()
{    return conf;}
1f6756e943d4884a89f75947731c858722ade6a5c82897c8a0cbbb4c6e10cc31
toString
public static String toString(DecisionForest forest, Dataset dataset, String[] attrNames)
{    List<Node> trees;    try {        Method getTrees = forest.getClass().getDeclaredMethod("getTrees");        getTrees.setAccessible(true);        trees = (List<Node>) getTrees.invoke(forest);    } catch (IllegalAccessException e) {        throw new IllegalStateException(e);    } catch (InvocationTargetException e) {        throw new IllegalStateException(e);    } catch (NoSuchMethodException e) {        throw new IllegalStateException(e);    }    int cnt = 1;    StringBuilder buff = new StringBuilder();    for (Node tree : trees) {        buff.append("Tree[").append(cnt).append("]:");        buff.append(TreeVisualizer.toString(tree, dataset, attrNames));        buff.append('\n');        cnt++;    }    return buff.toString();}
07b2c651fbddf8f55e34fdb8b11e988c9ea24f0f3dcc5a5038df9d613c869471
toString
public static String toString(String forestPath, String datasetPath, String[] attrNames) throws IOException
{    Configuration conf = new Configuration();    DecisionForest forest = DecisionForest.load(conf, new Path(forestPath));    Dataset dataset = Dataset.load(conf, new Path(datasetPath));    return toString(forest, dataset, attrNames);}
f13925e34b8eede58f7d5f374b566037f2ae4fb2cf9b7b46a09325d157bd8935
print
public static void print(String forestPath, String datasetPath, String[] attrNames) throws IOException
{    System.out.println(toString(forestPath, datasetPath, attrNames));}
3116ea2053d9de960ec3753eb07f3d243c370662aa1f0175ad357057c9ce5a52
main
public static void main(String[] args)
{    DefaultOptionBuilder obuilder = new DefaultOptionBuilder();    ArgumentBuilder abuilder = new ArgumentBuilder();    GroupBuilder gbuilder = new GroupBuilder();    Option datasetOpt = obuilder.withLongName("dataset").withShortName("ds").withRequired(true).withArgument(abuilder.withName("dataset").withMinimum(1).withMaximum(1).create()).withDescription("Dataset path").create();    Option modelOpt = obuilder.withLongName("model").withShortName("m").withRequired(true).withArgument(abuilder.withName("path").withMinimum(1).withMaximum(1).create()).withDescription("Path to the Decision Forest").create();    Option attrNamesOpt = obuilder.withLongName("names").withShortName("n").withRequired(false).withArgument(abuilder.withName("names").withMinimum(1).create()).withDescription("Optional, Attribute names").create();    Option helpOpt = obuilder.withLongName("help").withShortName("h").withDescription("Print out help").create();    Group group = gbuilder.withName("Options").withOption(datasetOpt).withOption(modelOpt).withOption(attrNamesOpt).withOption(helpOpt).create();    try {        Parser parser = new Parser();        parser.setGroup(group);        CommandLine cmdLine = parser.parse(args);        if (cmdLine.hasOption("help")) {            CommandLineUtil.printHelp(group);            return;        }        String datasetName = cmdLine.getValue(datasetOpt).toString();        String modelName = cmdLine.getValue(modelOpt).toString();        String[] attrNames = null;        if (cmdLine.hasOption(attrNamesOpt)) {            Collection<String> names = (Collection<String>) cmdLine.getValues(attrNamesOpt);            if (!names.isEmpty()) {                attrNames = new String[names.size()];                names.toArray(attrNames);            }        }        print(modelName, datasetName, attrNames);    } catch (Exception e) {        log.error("Exception", e);        CommandLineUtil.printHelp(group);    }}
00d5ae4b1153113dfc647dd3f3c1c73d74cd6860a3abe40d26f8f726a796763d
run
public int run(String[] args) throws IOException, ClassNotFoundException, InterruptedException
{    DefaultOptionBuilder obuilder = new DefaultOptionBuilder();    ArgumentBuilder abuilder = new ArgumentBuilder();    GroupBuilder gbuilder = new GroupBuilder();    Option dataOpt = obuilder.withLongName("data").withShortName("d").withRequired(true).withArgument(abuilder.withName("path").withMinimum(1).withMaximum(1).create()).withDescription("Data path").create();    Option datasetOpt = obuilder.withLongName("dataset").withShortName("ds").withRequired(true).withArgument(abuilder.withName("path").withMinimum(1).create()).withDescription("dataset path").create();    Option helpOpt = obuilder.withLongName("help").withDescription("Print out help").withShortName("h").create();    Group group = gbuilder.withName("Options").withOption(dataOpt).withOption(datasetOpt).withOption(helpOpt).create();    try {        Parser parser = new Parser();        parser.setGroup(group);        CommandLine cmdLine = parser.parse(args);        if (cmdLine.hasOption(helpOpt)) {            CommandLineUtil.printHelp(group);            return 0;        }        String dataPath = cmdLine.getValue(dataOpt).toString();        String datasetPath = cmdLine.getValue(datasetOpt).toString();        log.debug("Data path : {}", dataPath);        log.debug("Dataset path : {}", datasetPath);        runTool(dataPath, datasetPath);    } catch (OptionException e) {        log.warn(e.toString(), e);        CommandLineUtil.printHelp(group);    }    return 0;}
40e4784513d9467378534cde04337befb4c560340fff0f8a1448c2d22e1cb9d0
runTool
private void runTool(String data, String dataset) throws IOException, ClassNotFoundException, InterruptedException
{    FileSystem fs = FileSystem.get(getConf());    Path workingDir = fs.getWorkingDirectory();    Path dataPath = new Path(data);    Path datasetPath = new Path(dataset);    log.info("Computing the frequencies...");    FrequenciesJob job = new FrequenciesJob(new Path(workingDir, "output"), dataPath, datasetPath);    int[][] counts = job.run(getConf());        log.info("counts[partition][class]");    for (int[] count : counts) {        log.info(Arrays.toString(count));    }}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    ToolRunner.run(new Configuration(), new Frequencies(), args);}
1357aec2eab3dfcb687650dddc6d8899b77ed716053f2d86a67d5318128c1ca5
run
public int[][] run(Configuration conf) throws IOException, ClassNotFoundException, InterruptedException
{        FileSystem fs = outputPath.getFileSystem(conf);    if (fs.exists(outputPath)) {        throw new IOException("Output path already exists : " + outputPath);    }        URI[] files = { datasetPath.toUri() };    DistributedCache.setCacheFiles(files, conf);    Job job = new Job(conf);    job.setJarByClass(FrequenciesJob.class);    FileInputFormat.setInputPaths(job, dataPath);    FileOutputFormat.setOutputPath(job, outputPath);    job.setMapOutputKeyClass(LongWritable.class);    job.setMapOutputValueClass(IntWritable.class);    job.setOutputKeyClass(LongWritable.class);    job.setOutputValueClass(Frequencies.class);    job.setMapperClass(FrequenciesMapper.class);    job.setReducerClass(FrequenciesReducer.class);    job.setInputFormatClass(TextInputFormat.class);    job.setOutputFormatClass(SequenceFileOutputFormat.class);        boolean succeeded = job.waitForCompletion(true);    if (!succeeded) {        throw new IllegalStateException("Job failed!");    }    int[][] counts = parseOutput(job);    HadoopUtil.delete(conf, outputPath);    return counts;}
64ae8b7581dbdde061d0e68a7be861da92f135bfac87778dedc8b983391dce33
parseOutput
 int[][] parseOutput(JobContext job) throws IOException
{    Configuration conf = job.getConfiguration();    int numMaps = conf.getInt("mapred.map.tasks", -1);    log.info("mapred.map.tasks = {}", numMaps);    FileSystem fs = outputPath.getFileSystem(conf);    Path[] outfiles = DFUtils.listOutputFiles(fs, outputPath);    Frequencies[] values = new Frequencies[numMaps];        int index = 0;    for (Path path : outfiles) {        for (Frequencies value : new SequenceFileValueIterable<Frequencies>(path, conf)) {            values[index++] = value;        }    }    if (index < numMaps) {        throw new IllegalStateException("number of output Frequencies (" + index + ") is lesser than the number of mappers!");    }        Arrays.sort(values);    return Frequencies.extractCounts(values);}
6b7dd49be7482fc8ee0fbe8bd0f24522f2a718c8c816a3d7b048fb4688eb6373
setup
protected void setup(Context context) throws IOException, InterruptedException
{    Configuration conf = context.getConfiguration();    dataset = Builder.loadDataset(conf);    setup(dataset);}
ab0ae1826e71cd6675fbc4c91c46786764fed9d0969c4126cd0ced8f4195612b
setup
 void setup(Dataset dataset)
{    converter = new DataConverter(dataset);}
364372c8c0a17a2c3987e3f0d31a4140befe124df0e3310d5d0fe71e39f33b0f
map
protected void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException
{    if (firstId == null) {        firstId = new LongWritable(key.get());    }    Instance instance = converter.convert(value.toString());    context.write(firstId, new IntWritable((int) dataset.getLabel(instance)));}
6b7dd49be7482fc8ee0fbe8bd0f24522f2a718c8c816a3d7b048fb4688eb6373
setup
protected void setup(Context context) throws IOException, InterruptedException
{    Configuration conf = context.getConfiguration();    Dataset dataset = Builder.loadDataset(conf);    setup(dataset.nblabels());}
aff7f3ae8a1970dba15998696126ec49d203a2fedcf595db4f4e3785bb6ac898
setup
 void setup(int nblabels)
{    this.nblabels = nblabels;}
b809c04a441e0f52f113e83802b285ea50a9e9f1e96703a93fa60e115f34e874
reduce
protected void reduce(LongWritable key, Iterable<IntWritable> values, Context context) throws IOException, InterruptedException
{    int[] counts = new int[nblabels];    for (IntWritable value : values) {        counts[value.get()]++;    }    context.write(key, new Frequencies(key.get(), counts));}
5478cc5683f6dfd4515c383752d7c803555efc63d03fd84a03ba8dcd17eb4324
readFields
public void readFields(DataInput in) throws IOException
{    firstId = in.readLong();    counts = DFUtils.readIntArray(in);}
a894510dd4db439ff8e17ae1059489dc3abc97178e5932ceed0c70c3af165401
write
public void write(DataOutput out) throws IOException
{    out.writeLong(firstId);    DFUtils.writeArray(out, counts);}
74e378df448c6c3cd090d6daf881cfac8957dd555869ea4c13a46bdc6cdcf9a6
equals
public boolean equals(Object other)
{    return other instanceof Frequencies && firstId == ((Frequencies) other).firstId;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return (int) firstId;}
9f267525d4fa9e4dfeecad25ec29d7b096b618d48ab3bb306e6b48be4608e79d
clone
protected Frequencies clone()
{    return new Frequencies(firstId, counts);}
dd866ef5862ff87fffc9382ae2fd36b4df604b0f1549d095b0ca1b1aaad33a71
compareTo
public int compareTo(Frequencies obj)
{    if (firstId < obj.firstId) {        return -1;    } else if (firstId > obj.firstId) {        return 1;    } else {        return 0;    }}
a2c42e4899b9ff3e509da4440800edb047ef645b8ebeed9bb2179bc89d407711
extractCounts
public static int[][] extractCounts(Frequencies[] partitions)
{    int[][] counts = new int[partitions.length][];    for (int p = 0; p < partitions.length; p++) {        counts[p] = partitions[p].counts;    }    return counts;}
8d5cc0ba7d3be46a12aaeb01082eee349a6d809823e429102082f15ceb5ba50a
doubleToString
private static String doubleToString(double value)
{    DecimalFormat df = new DecimalFormat("0.##");    return df.format(value);}
7c000cf00642edca7a07a4e945beec1379ac47e05a9c7c73e0c7f6c28e53f7eb
toStringNode
private static String toStringNode(Node node, Dataset dataset, String[] attrNames, Map<String, Field> fields, int layer)
{    StringBuilder buff = new StringBuilder();    try {        if (node instanceof CategoricalNode) {            CategoricalNode cnode = (CategoricalNode) node;            int attr = (Integer) fields.get("CategoricalNode.attr").get(cnode);            double[] values = (double[]) fields.get("CategoricalNode.values").get(cnode);            Node[] childs = (Node[]) fields.get("CategoricalNode.childs").get(cnode);            String[][] attrValues = (String[][]) fields.get("Dataset.values").get(dataset);            for (int i = 0; i < attrValues[attr].length; i++) {                int index = ArrayUtils.indexOf(values, i);                if (index < 0) {                    continue;                }                buff.append('\n');                for (int j = 0; j < layer; j++) {                    buff.append("|   ");                }                buff.append(attrNames == null ? attr : attrNames[attr]).append(" = ").append(attrValues[attr][i]);                buff.append(toStringNode(childs[index], dataset, attrNames, fields, layer + 1));            }        } else if (node instanceof NumericalNode) {            NumericalNode nnode = (NumericalNode) node;            int attr = (Integer) fields.get("NumericalNode.attr").get(nnode);            double split = (Double) fields.get("NumericalNode.split").get(nnode);            Node loChild = (Node) fields.get("NumericalNode.loChild").get(nnode);            Node hiChild = (Node) fields.get("NumericalNode.hiChild").get(nnode);            buff.append('\n');            for (int j = 0; j < layer; j++) {                buff.append("|   ");            }            buff.append(attrNames == null ? attr : attrNames[attr]).append(" < ").append(doubleToString(split));            buff.append(toStringNode(loChild, dataset, attrNames, fields, layer + 1));            buff.append('\n');            for (int j = 0; j < layer; j++) {                buff.append("|   ");            }            buff.append(attrNames == null ? attr : attrNames[attr]).append(" >= ").append(doubleToString(split));            buff.append(toStringNode(hiChild, dataset, attrNames, fields, layer + 1));        } else if (node instanceof Leaf) {            Leaf leaf = (Leaf) node;            double label = (Double) fields.get("Leaf.label").get(leaf);            if (dataset.isNumerical(dataset.getLabelId())) {                buff.append(" : ").append(doubleToString(label));            } else {                buff.append(" : ").append(dataset.getLabelString(label));            }        }    } catch (IllegalAccessException iae) {        throw new IllegalStateException(iae);    }    return buff.toString();}
af560ec47ebc88802841742b8bffa41baa62a29b93b42b4c41264ec09a3cad0d
getReflectMap
private static Map<String, Field> getReflectMap()
{    Map<String, Field> fields = new HashMap<>();    try {        Field m = CategoricalNode.class.getDeclaredField("attr");        m.setAccessible(true);        fields.put("CategoricalNode.attr", m);        m = CategoricalNode.class.getDeclaredField("values");        m.setAccessible(true);        fields.put("CategoricalNode.values", m);        m = CategoricalNode.class.getDeclaredField("childs");        m.setAccessible(true);        fields.put("CategoricalNode.childs", m);        m = NumericalNode.class.getDeclaredField("attr");        m.setAccessible(true);        fields.put("NumericalNode.attr", m);        m = NumericalNode.class.getDeclaredField("split");        m.setAccessible(true);        fields.put("NumericalNode.split", m);        m = NumericalNode.class.getDeclaredField("loChild");        m.setAccessible(true);        fields.put("NumericalNode.loChild", m);        m = NumericalNode.class.getDeclaredField("hiChild");        m.setAccessible(true);        fields.put("NumericalNode.hiChild", m);        m = Leaf.class.getDeclaredField("label");        m.setAccessible(true);        fields.put("Leaf.label", m);        m = Dataset.class.getDeclaredField("values");        m.setAccessible(true);        fields.put("Dataset.values", m);    } catch (NoSuchFieldException nsfe) {        throw new IllegalStateException(nsfe);    }    return fields;}
abe824f06a4d49fa3abda720e1c3a722e4941bd0f5cc8249297241dad432d466
toString
public static String toString(Node tree, Dataset dataset, String[] attrNames)
{    return toStringNode(tree, dataset, attrNames, getReflectMap(), 0);}
1eecc1a1b9765b109514d595d1dce9af0366422ddc0381f82e57a6d34c45dfa9
print
public static void print(Node tree, Dataset dataset, String[] attrNames)
{    System.out.println(toString(tree, dataset, attrNames));}
577f42e4dedb7af8ed5e53399dcef7f02770deaeca7ca262b36b1f76ec75171c
toStringPredict
private static String toStringPredict(Node node, Instance instance, Dataset dataset, String[] attrNames, Map<String, Field> fields)
{    StringBuilder buff = new StringBuilder();    try {        if (node instanceof CategoricalNode) {            CategoricalNode cnode = (CategoricalNode) node;            int attr = (Integer) fields.get("CategoricalNode.attr").get(cnode);            double[] values = (double[]) fields.get("CategoricalNode.values").get(cnode);            Node[] childs = (Node[]) fields.get("CategoricalNode.childs").get(cnode);            String[][] attrValues = (String[][]) fields.get("Dataset.values").get(dataset);            int index = ArrayUtils.indexOf(values, instance.get(attr));            if (index >= 0) {                buff.append(attrNames == null ? attr : attrNames[attr]).append(" = ").append(attrValues[attr][(int) instance.get(attr)]);                buff.append(" -> ");                buff.append(toStringPredict(childs[index], instance, dataset, attrNames, fields));            }        } else if (node instanceof NumericalNode) {            NumericalNode nnode = (NumericalNode) node;            int attr = (Integer) fields.get("NumericalNode.attr").get(nnode);            double split = (Double) fields.get("NumericalNode.split").get(nnode);            Node loChild = (Node) fields.get("NumericalNode.loChild").get(nnode);            Node hiChild = (Node) fields.get("NumericalNode.hiChild").get(nnode);            if (instance.get(attr) < split) {                buff.append('(').append(attrNames == null ? attr : attrNames[attr]).append(" = ").append(doubleToString(instance.get(attr))).append(") < ").append(doubleToString(split));                buff.append(" -> ");                buff.append(toStringPredict(loChild, instance, dataset, attrNames, fields));            } else {                buff.append('(').append(attrNames == null ? attr : attrNames[attr]).append(" = ").append(doubleToString(instance.get(attr))).append(") >= ").append(doubleToString(split));                buff.append(" -> ");                buff.append(toStringPredict(hiChild, instance, dataset, attrNames, fields));            }        } else if (node instanceof Leaf) {            Leaf leaf = (Leaf) node;            double label = (Double) fields.get("Leaf.label").get(leaf);            if (dataset.isNumerical(dataset.getLabelId())) {                buff.append(doubleToString(label));            } else {                buff.append(dataset.getLabelString(label));            }        }    } catch (IllegalAccessException iae) {        throw new IllegalStateException(iae);    }    return buff.toString();}
e8317633aad3d0ac5da6986b151696f43b5ff44363276ea7a07284a8b8f94f83
predictTrace
public static String[] predictTrace(Node tree, Data data, String[] attrNames)
{    Map<String, Field> reflectMap = getReflectMap();    String[] prediction = new String[data.size()];    for (int i = 0; i < data.size(); i++) {        prediction[i] = toStringPredict(tree, data.get(i), data.getDataset(), attrNames, reflectMap);    }    return prediction;}
2ff143d57eff7a6db77d0944f12d63e8b2dca16a55f5eaf8d41b45b5ec256d92
predictTracePrint
public static void predictTracePrint(Node tree, Data data, String[] attrNames)
{    Map<String, Field> reflectMap = getReflectMap();    for (int i = 0; i < data.size(); i++) {        System.out.println(toStringPredict(tree, data.get(i), data.getDataset(), attrNames, reflectMap));    }}
365a24fc75086b6a0e91f9b072bd58c9280846cc05f333f28ede18388f27ce89
main
public static void main(String[] args) throws IOException
{    DefaultOptionBuilder obuilder = new DefaultOptionBuilder();    ArgumentBuilder abuilder = new ArgumentBuilder();    GroupBuilder gbuilder = new GroupBuilder();    Option dataOpt = obuilder.withLongName("data").withShortName("d").withRequired(true).withArgument(abuilder.withName("data").withMinimum(1).withMaximum(1).create()).withDescription("Data path").create();    Option datasetOpt = obuilder.withLongName("dataset").withShortName("ds").withRequired(true).withArgument(abuilder.withName("dataset").withMinimum(1).create()).withDescription("Dataset path").create();    Option outputOpt = obuilder.withLongName("output").withShortName("o").withRequired(true).withArgument(abuilder.withName("output").withMinimum(1).withMaximum(1).create()).withDescription("Path to generated files").create();    Option partitionsOpt = obuilder.withLongName("numpartitions").withShortName("p").withRequired(true).withArgument(abuilder.withName("numparts").withMinimum(1).withMinimum(1).create()).withDescription("Number of partitions to create").create();    Option helpOpt = obuilder.withLongName("help").withDescription("Print out help").withShortName("h").create();    Group group = gbuilder.withName("Options").withOption(dataOpt).withOption(outputOpt).withOption(datasetOpt).withOption(partitionsOpt).withOption(helpOpt).create();    try {        Parser parser = new Parser();        parser.setGroup(group);        CommandLine cmdLine = parser.parse(args);        if (cmdLine.hasOption(helpOpt)) {            CommandLineUtil.printHelp(group);            return;        }        String data = cmdLine.getValue(dataOpt).toString();        String dataset = cmdLine.getValue(datasetOpt).toString();        int numPartitions = Integer.parseInt(cmdLine.getValue(partitionsOpt).toString());        String output = cmdLine.getValue(outputOpt).toString();        runTool(data, dataset, output, numPartitions);    } catch (OptionException e) {        log.warn(e.toString(), e);        CommandLineUtil.printHelp(group);    }}
01ee92ec6ac19fe3668de4cc9f0ae96646cacb5e4bd9717ae50dacf5e2083b0f
runTool
private static void runTool(String dataStr, String datasetStr, String output, int numPartitions) throws IOException
{    Preconditions.checkArgument(numPartitions > 0, "numPartitions <= 0");        Path outputPath = new Path(output);    Configuration conf = new Configuration();    FileSystem fs = outputPath.getFileSystem(conf);    Preconditions.checkArgument(!fs.exists(outputPath), "Output path already exists");                                File tempFile = FileUtil.createLocalTempFile(new File(""), "df.tools.UDistrib", true);    Path partsPath = new Path(tempFile.toString());    FileSystem pfs = partsPath.getFileSystem(conf);    Path[] partPaths = new Path[numPartitions];    FSDataOutputStream[] files = new FSDataOutputStream[numPartitions];    for (int p = 0; p < numPartitions; p++) {        partPaths[p] = new Path(partsPath, String.format(Locale.ENGLISH, "part.%03d", p));        files[p] = pfs.create(partPaths[p]);    }    Path datasetPath = new Path(datasetStr);    Dataset dataset = Dataset.load(conf, datasetPath);        int[] currents = new int[dataset.nblabels()];        Random random = RandomUtils.getRandom();    for (int c = 0; c < currents.length; c++) {        currents[c] = random.nextInt(numPartitions);    }        Path dataPath = new Path(dataStr);    FileSystem ifs = dataPath.getFileSystem(conf);    FSDataInputStream input = ifs.open(dataPath);    Scanner scanner = new Scanner(input, "UTF-8");    DataConverter converter = new DataConverter(dataset);    int id = 0;    while (scanner.hasNextLine()) {        if (id % 1000 == 0) {            log.info("progress : {}", id);        }        String line = scanner.nextLine();        if (line.isEmpty()) {                        continue;        }                Instance instance = converter.convert(line);        int label = (int) dataset.getLabel(instance);        files[currents[label]].writeBytes(line);        files[currents[label]].writeChar('\n');                currents[label]++;        if (currents[label] == numPartitions) {            currents[label] = 0;        }    }        scanner.close();    for (FSDataOutputStream file : files) {        Closeables.close(file, false);    }        FileUtil.copyMerge(pfs, partsPath, fs, outputPath, true, conf, null);/*     * FSDataOutputStream joined = fs.create(new Path(outputPath, "uniform.data")); for (int p = 0; p <     * numPartitions; p++) {log.info("Joining part : {}", p); FSDataInputStream partStream =     * fs.open(partPaths[p]);     *      * IOUtils.copyBytes(partStream, joined, conf, false);     *      * partStream.close(); }     *      * joined.close();     *      * fs.delete(partsPath, true);     */}
3329657afc93074b5cdf4699dc1788f07c700682c4911c5eb5e8858402de193f
add
public void add(int trueValue, double score)
{    Preconditions.checkArgument(trueValue == 0 || trueValue == 1, "True value must be 0 or 1");    hasScore = true;    int predictedClass = score > threshold ? 1 : 0;    confusion.set(trueValue, predictedClass, confusion.get(trueValue, predictedClass) + 1);    samples++;    if (isProbabilityScore()) {        double limited = Math.max(1.0e-20, Math.min(score, 1 - 1.0e-20));        double v0 = entropy.get(trueValue, 0);        entropy.set(trueValue, 0, (Math.log1p(-limited) - v0) / samples + v0);        double v1 = entropy.get(trueValue, 1);        entropy.set(trueValue, 1, (Math.log(limited) - v1) / samples + v1);    }        DoubleArrayList buf = scores[trueValue];    if (buf.size() >= maxBufferSize) {                                                                                int index = rand.nextInt(samples);        if (index < buf.size()) {            buf.set(index, score);        }    } else {                                buf.add(score);    }}
ff8a6d34483ede7966d80e6d64a284e6fb684ec6ef1b4e97c42fe0604e81dabb
add
public void add(int trueValue, int predictedClass)
{    hasScore = false;    Preconditions.checkArgument(trueValue == 0 || trueValue == 1, "True value must be 0 or 1");    confusion.set(trueValue, predictedClass, confusion.get(trueValue, predictedClass) + 1);}
b7b9278dce78d03ffa978e3c2e0e40fd1430be1af8a105ca11d28be7d3a4d960
auc
public double auc()
{    Preconditions.checkArgument(hasScore, "Can't compute AUC for classifier without a score");    scores[0].sort();    scores[1].sort();    double n0 = scores[0].size();    double n1 = scores[1].size();    if (n0 == 0 || n1 == 0) {        return 0.5;    }        int i0 = 0;    int i1 = 0;    int rank = 1;    double rankSum = 0;    while (i0 < n0 && i1 < n1) {        double v0 = scores[0].get(i0);        double v1 = scores[1].get(i1);        if (v0 < v1) {            i0++;            rank++;        } else if (v1 < v0) {            i1++;            rankSum += rank;            rank++;        } else {                        double tieScore = v0;                        int k0 = 0;            while (i0 < n0 && scores[0].get(i0) == tieScore) {                k0++;                i0++;            }                        int k1 = 0;            while (i1 < n1 && scores[1].get(i1) == tieScore) {                k1++;                i1++;            }                                                rankSum += (rank + (k0 + k1 - 1) / 2.0) * k1;            rank += k0 + k1;        }    }    if (i1 < n1) {        rankSum += (rank + (n1 - i1 - 1) / 2.0) * (n1 - i1);        rank += (int) (n1 - i1);    }    return (rankSum / n1 - (n1 + 1) / 2) / n0;}
20ba0adb50e6541c820675b6a1733e27755c3a1cdd20a93b9f086aac42fca6ec
confusion
public Matrix confusion()
{    return confusion;}
cd32223cdea6b13f7a30faa6e5b5d98334f37225fd625942ee3644c73cd90b75
entropy
public Matrix entropy()
{    if (!hasScore) {                        double p = (0.5 + confusion.get(1, 1)) / (1 + confusion.get(0, 0) + confusion.get(1, 1));        entropy.set(0, 0, confusion.get(0, 0) * Math.log1p(-p));        entropy.set(0, 1, confusion.get(0, 1) * Math.log(p));        entropy.set(1, 0, confusion.get(1, 0) * Math.log1p(-p));        entropy.set(1, 1, confusion.get(1, 1) * Math.log(p));    }    return entropy;}
39fcbae6b3ce00234b59cb1bf7bf290a6ab61d68fea45bd17e9413b06dfe879d
setMaxBufferSize
public void setMaxBufferSize(int maxBufferSize)
{    this.maxBufferSize = maxBufferSize;}
7571ec81e6a0fb7fc527f42c7f9c993e9ab000269ea2b0e068de59e845c2e04e
isProbabilityScore
public boolean isProbabilityScore()
{    return probabilityScore;}
511bcdc9ed18a5096ccf8c0c5247e55ec8c8aedf92befd8b9c877d476053bd2a
setProbabilityScore
public void setProbabilityScore(boolean probabilityScore)
{    this.probabilityScore = probabilityScore;}
8ffdd1810264690ffbbf706277b49c39e9d253920d98bad9771ed2131dfd74f1
getModel
protected NaiveBayesModel getModel()
{    return model;}
27edf921f1e501825c0f303e820c934c39616d20058baa920a4b9477fa392659
getScoreForLabelInstance
protected double getScoreForLabelInstance(int label, Vector instance)
{    double result = 0.0;    for (Element e : instance.nonZeroes()) {        result += e.get() * getScoreForLabelFeature(label, e.index());    }    return result;}
0bdeb79fe74c02804b0b53b9a99db42b7e41e4a28e6e703c32648791e7032088
numCategories
public int numCategories()
{    return model.numLabels();}
634ba8a7762025f6fd2633a8d9f18e14f77c51e925ed9d9d7ffac0fb2513a5e3
classifyFull
public Vector classifyFull(Vector instance)
{    return classifyFull(model.createScoringVector(), instance);}
4b52fbcac7fd03252f0a0f881fa552eebb1b8203eb1b993f9bfaadea88578c01
classifyFull
public Vector classifyFull(Vector r, Vector instance)
{    for (int label = 0; label < model.numLabels(); label++) {        r.setQuick(label, getScoreForLabelInstance(label, instance));    }    return r;}
26ad6f4b0cd93ee65196cb117ed56b25c67c201f8283b12a24dbe4c622a5a362
classifyScalar
public double classifyScalar(Vector instance)
{    throw new UnsupportedOperationException("Not supported in Naive Bayes");}
a65d353603d9c6fa69fa946675f753b9e8fcbd94f8ccaeab6425adab7d1af7ba
classify
public Vector classify(Vector instance)
{    throw new UnsupportedOperationException("probabilites not supported in Naive Bayes");}
6e92db82916c24bdd07f4326a6f41917dd9d1576cf38e89d6b8a24829ff73407
readModelFromDir
public static NaiveBayesModel readModelFromDir(Path base, Configuration conf)
{    float alphaI = conf.getFloat(ThetaMapper.ALPHA_I, 1.0f);    boolean isComplementary = conf.getBoolean(NaiveBayesModel.COMPLEMENTARY_MODEL, true);        Vector scoresPerLabel = null;    Vector scoresPerFeature = null;    for (Pair<Text, VectorWritable> record : new SequenceFileDirIterable<Text, VectorWritable>(new Path(base, TrainNaiveBayesJob.WEIGHTS), PathType.LIST, PathFilters.partFilter(), conf)) {        String key = record.getFirst().toString();        VectorWritable value = record.getSecond();        if (key.equals(TrainNaiveBayesJob.WEIGHTS_PER_FEATURE)) {            scoresPerFeature = value.get();        } else if (key.equals(TrainNaiveBayesJob.WEIGHTS_PER_LABEL)) {            scoresPerLabel = value.get();        }    }    Preconditions.checkNotNull(scoresPerFeature);    Preconditions.checkNotNull(scoresPerLabel);    Matrix scoresPerLabelAndFeature = new SparseMatrix(scoresPerLabel.size(), scoresPerFeature.size());    for (Pair<IntWritable, VectorWritable> entry : new SequenceFileDirIterable<IntWritable, VectorWritable>(new Path(base, TrainNaiveBayesJob.SUMMED_OBSERVATIONS), PathType.LIST, PathFilters.partFilter(), conf)) {        scoresPerLabelAndFeature.assignRow(entry.getFirst().get(), entry.getSecond().get());    }        Vector perLabelThetaNormalizer = null;    if (isComplementary) {        perLabelThetaNormalizer = scoresPerLabel.like();        for (Pair<Text, VectorWritable> entry : new SequenceFileDirIterable<Text, VectorWritable>(new Path(base, TrainNaiveBayesJob.THETAS), PathType.LIST, PathFilters.partFilter(), conf)) {            if (entry.getFirst().toString().equals(TrainNaiveBayesJob.LABEL_THETA_NORMALIZER)) {                perLabelThetaNormalizer = entry.getSecond().get();            }        }        Preconditions.checkNotNull(perLabelThetaNormalizer);    }    return new NaiveBayesModel(scoresPerLabelAndFeature, scoresPerFeature, scoresPerLabel, perLabelThetaNormalizer, alphaI, isComplementary);}
d3cb7ac83f39fbdc8a94d18e11134822fdc1fa59fce5b92ac745a71454d80513
writeLabelIndex
public static int writeLabelIndex(Configuration conf, Iterable<String> labels, Path indexPath) throws IOException
{    FileSystem fs = FileSystem.get(indexPath.toUri(), conf);    int i = 0;    try (SequenceFile.Writer writer = SequenceFile.createWriter(fs.getConf(), SequenceFile.Writer.file(indexPath), SequenceFile.Writer.keyClass(Text.class), SequenceFile.Writer.valueClass(IntWritable.class))) {        for (String label : labels) {            writer.append(new Text(label), new IntWritable(i++));        }    }    return i;}
fa3e28bb2f799db40e3710a1d5bcf6b515a8e89842b18d96d825279cdae14f2f
writeLabelIndex
public static int writeLabelIndex(Configuration conf, Path indexPath, Iterable<Pair<Text, IntWritable>> labels) throws IOException
{    FileSystem fs = FileSystem.get(indexPath.toUri(), conf);    Collection<String> seen = new HashSet<>();    int i = 0;    try (SequenceFile.Writer writer = SequenceFile.createWriter(fs.getConf(), SequenceFile.Writer.file(indexPath), SequenceFile.Writer.keyClass(Text.class), SequenceFile.Writer.valueClass(IntWritable.class))) {        for (Object label : labels) {            String theLabel = SLASH.split(((Pair<?, ?>) label).getFirst().toString())[1];            if (!seen.contains(theLabel)) {                writer.append(new Text(theLabel), new IntWritable(i++));                seen.add(theLabel);            }        }    }    return i;}
f09546765ff0049b96c66a7bd3b0f842335f39376269297c92d1dffefdaf3f25
readLabelIndex
public static Map<Integer, String> readLabelIndex(Configuration conf, Path indexPath)
{    Map<Integer, String> labelMap = new HashMap<>();    for (Pair<Text, IntWritable> pair : new SequenceFileIterable<Text, IntWritable>(indexPath, true, conf)) {        labelMap.put(pair.getSecond().get(), pair.getFirst().toString());    }    return labelMap;}
1278115d120f5602aa597eac22c7f44aedba95f406db0b7dbe8ce63831304bc9
readIndexFromCache
public static OpenObjectIntHashMap<String> readIndexFromCache(Configuration conf) throws IOException
{    OpenObjectIntHashMap<String> index = new OpenObjectIntHashMap<>();    for (Pair<Writable, IntWritable> entry : new SequenceFileIterable<Writable, IntWritable>(HadoopUtil.getSingleCachedFile(conf), conf)) {        index.put(entry.getFirst().toString(), entry.getSecond().get());    }    return index;}
9c76a7c4121507f5ad04fe6429f5a5ac9c43ec7ad573ff797c72c5ab2d4ca526
readScoresFromCache
public static Map<String, Vector> readScoresFromCache(Configuration conf) throws IOException
{    Map<String, Vector> sumVectors = new HashMap<>();    for (Pair<Text, VectorWritable> entry : new SequenceFileDirIterable<Text, VectorWritable>(HadoopUtil.getSingleCachedFile(conf), PathType.LIST, PathFilters.partFilter(), conf)) {        sumVectors.put(entry.getFirst().toString(), entry.getSecond().get());    }    return sumVectors;}
901555b06c993cced75f90ca2e992e5171293811371f58a7cd049f084020e46c
getScoreForLabelFeature
public double getScoreForLabelFeature(int label, int feature)
{    NaiveBayesModel model = getModel();    double weight = computeWeight(model.featureWeight(feature), model.weight(label, feature), model.totalWeightSum(), model.labelWeight(label), model.alphaI(), model.numFeatures());        return weight / model.thetaNormalizer(label);}
dc9166c28a0dc82e04f300c029196b914450c5d46382a5a7cda2e88571f82e13
computeWeight
public static double computeWeight(double featureWeight, double featureLabelWeight, double totalWeight, double labelWeight, double alphaI, double numFeatures)
{    double numerator = featureWeight - featureLabelWeight + alphaI;    double denominator = totalWeight - labelWeight + alphaI * numFeatures;    return -Math.log(numerator / denominator);}
81ffaa6739ab4de1cf43ea9d4d4bd15d9426aca208fb3a9f3871a38a7b2707ed
labelWeight
public double labelWeight(int label)
{    return weightsPerLabel.getQuick(label);}
4144c6d6649dfe34872237e2b9854282a6dc0dfbbca713797f2e398fe970fd49
thetaNormalizer
public double thetaNormalizer(int label)
{    return perlabelThetaNormalizer.get(label);}
65b8c0f51f18a396f465df21ee2ae96cf0079ebcd78d563db7e3a0a7e5cfaf55
featureWeight
public double featureWeight(int feature)
{    return weightsPerFeature.getQuick(feature);}
b22e3405b6f6b167de9bc1bfbd8c005ef7fe7a5df9a45f6702ce12320dc68570
weight
public double weight(int label, int feature)
{    return weightsPerLabelAndFeature.getQuick(label, feature);}
cf920fdfc9fc9575106ea7d9cb7147d1d8d4d56ed50344f57af3dbe20a9550f0
alphaI
public float alphaI()
{    return alphaI;}
ee223df060595bbc2b79ef656253e247338d3fcfbcb64e9ef2b343127afaad87
numFeatures
public double numFeatures()
{    return numFeatures;}
5451f93d39bec4ba9db51c3836c45037b3e172ea6fd9c0f9e2fbe04b138212a0
totalWeightSum
public double totalWeightSum()
{    return totalWeightSum;}
7578f9063f1b5dfec203e512ebe18e06809159f4fb3fb7ed825ea93e209ecde7
numLabels
public int numLabels()
{    return weightsPerLabel.size();}
7429bc4e45e3804ee9a3c162d8529d4fa1db9107bef01da5badebf3d3f5876b7
createScoringVector
public Vector createScoringVector()
{    return weightsPerLabel.like();}
77cf30ff51a66f0d52fdee332e2bf9ba88dc242d32088572559eb532a02a20fb
isComplemtary
public boolean isComplemtary()
{    return isComplementary;}
7c17f1affc69e9cc8903e7813079fad8beb25cc6ac860a2a3f86ed41bdc3af36
materialize
public static NaiveBayesModel materialize(Path output, Configuration conf) throws IOException
{    FileSystem fs = output.getFileSystem(conf);    Vector weightsPerLabel;    Vector perLabelThetaNormalizer = null;    Vector weightsPerFeature;    Matrix weightsPerLabelAndFeature;    float alphaI;    boolean isComplementary;    try (FSDataInputStream in = fs.open(new Path(output, "naiveBayesModel.bin"))) {        alphaI = in.readFloat();        isComplementary = in.readBoolean();        weightsPerFeature = VectorWritable.readVector(in);        weightsPerLabel = new DenseVector(VectorWritable.readVector(in));        if (isComplementary) {            perLabelThetaNormalizer = new DenseVector(VectorWritable.readVector(in));        }        weightsPerLabelAndFeature = new SparseRowMatrix(weightsPerLabel.size(), weightsPerFeature.size());        for (int label = 0; label < weightsPerLabelAndFeature.numRows(); label++) {            weightsPerLabelAndFeature.assignRow(label, VectorWritable.readVector(in));        }    }    NaiveBayesModel model = new NaiveBayesModel(weightsPerLabelAndFeature, weightsPerFeature, weightsPerLabel, perLabelThetaNormalizer, alphaI, isComplementary);    model.validate();    return model;}
aa43e4a9512ecd2a1be9c63241f42daac648a9716900f37390e5be69c0ebfbbf
serialize
public void serialize(Path output, Configuration conf) throws IOException
{    FileSystem fs = output.getFileSystem(conf);    try (FSDataOutputStream out = fs.create(new Path(output, "naiveBayesModel.bin"))) {        out.writeFloat(alphaI);        out.writeBoolean(isComplementary);        VectorWritable.writeVector(out, weightsPerFeature);        VectorWritable.writeVector(out, weightsPerLabel);        if (isComplementary) {            VectorWritable.writeVector(out, perlabelThetaNormalizer);        }        for (int row = 0; row < weightsPerLabelAndFeature.numRows(); row++) {            VectorWritable.writeVector(out, weightsPerLabelAndFeature.viewRow(row));        }    }}
675257a90384295af5c28f92ff6b0f5f89faf18e57bcf5f69e929c19afc2b1cf
validate
public void validate()
{    Preconditions.checkState(alphaI > 0, "alphaI has to be greater than 0!");    Preconditions.checkArgument(numFeatures > 0, "the vocab count has to be greater than 0!");    Preconditions.checkArgument(totalWeightSum > 0, "the totalWeightSum has to be greater than 0!");    Preconditions.checkNotNull(weightsPerLabel, "the number of labels has to be defined!");    Preconditions.checkArgument(weightsPerLabel.getNumNondefaultElements() > 0, "the number of labels has to be greater than 0!");    Preconditions.checkNotNull(weightsPerFeature, "the feature sums have to be defined");    Preconditions.checkArgument(weightsPerFeature.getNumNondefaultElements() > 0, "the feature sums have to be greater than 0!");    if (isComplementary) {        Preconditions.checkArgument(perlabelThetaNormalizer != null, "the theta normalizers have to be defined");        Preconditions.checkArgument(perlabelThetaNormalizer.getNumNondefaultElements() > 0, "the number of theta normalizers has to be greater than 0!");        Preconditions.checkArgument(Math.signum(perlabelThetaNormalizer.minValue()) == Math.signum(perlabelThetaNormalizer.maxValue()), "Theta normalizers do not all have the same sign");        Preconditions.checkArgument(perlabelThetaNormalizer.getNumNonZeroElements() == perlabelThetaNormalizer.size(), "Theta normalizers can not have zero value.");    }}
901555b06c993cced75f90ca2e992e5171293811371f58a7cd049f084020e46c
getScoreForLabelFeature
public double getScoreForLabelFeature(int label, int feature)
{    NaiveBayesModel model = getModel();        return computeWeight(model.weight(label, feature), model.labelWeight(label), model.alphaI(), model.numFeatures());}
5753727f10ab09aea099655aa3f4c75bc9c7373654c914d3e848cb05576716fc
computeWeight
public static double computeWeight(double featureLabelWeight, double labelWeight, double alphaI, double numFeatures)
{    double numerator = featureLabelWeight + alphaI;    double denominator = labelWeight + alphaI * numFeatures;    return Math.log(numerator / denominator);}
6b7dd49be7482fc8ee0fbe8bd0f24522f2a718c8c816a3d7b048fb4688eb6373
setup
protected void setup(Context context) throws IOException, InterruptedException
{    super.setup(context);    Configuration conf = context.getConfiguration();    Path modelPath = HadoopUtil.getSingleCachedFile(conf);    NaiveBayesModel model = NaiveBayesModel.materialize(modelPath, conf);    boolean isComplementary = Boolean.parseBoolean(conf.get(TestNaiveBayesDriver.COMPLEMENTARY));        if (isComplementary) {        Preconditions.checkArgument((model.isComplemtary()), "Complementary mode in model is different than test mode");    }    if (isComplementary) {        classifier = new ComplementaryNaiveBayesClassifier(model);    } else {        classifier = new StandardNaiveBayesClassifier(model);    }}
4236665f6c26ee22dba2f64641830743d5ba7d52c85e8658fe305391820cff3d
map
protected void map(Text key, VectorWritable value, Context context) throws IOException, InterruptedException
{    Vector result = classifier.classifyFull(value.get());        context.write(new Text(SLASH.split(key.toString())[1]), new VectorWritable(result));}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    ToolRunner.run(new Configuration(), new TestNaiveBayesDriver(), args);}
aacecb0f01750d985b78d806dc3c134f0da79efe2752957e0f93ecf5cbf9e492
run
public int run(String[] args) throws Exception
{    addInputOption();    addOutputOption();    addOption(addOption(DefaultOptionCreator.overwriteOption().create()));    addOption("model", "m", "The path to the model built during training", true);    addOption(buildOption("testComplementary", "c", "test complementary?", false, false, String.valueOf(false)));    addOption(buildOption("runSequential", "seq", "run sequential?", false, false, String.valueOf(false)));    addOption("labelIndex", "l", "The path to the location of the label index", true);    Map<String, List<String>> parsedArgs = parseArguments(args);    if (parsedArgs == null) {        return -1;    }    if (hasOption(DefaultOptionCreator.OVERWRITE_OPTION)) {        HadoopUtil.delete(getConf(), getOutputPath());    }    boolean sequential = hasOption("runSequential");    boolean succeeded;    if (sequential) {        runSequential();    } else {        succeeded = runMapReduce();        if (!succeeded) {            return -1;        }    }        Map<Integer, String> labelMap = BayesUtils.readLabelIndex(getConf(), new Path(getOption("labelIndex")));        SequenceFileDirIterable<Text, VectorWritable> dirIterable = new SequenceFileDirIterable<>(getOutputPath(), PathType.LIST, PathFilters.partFilter(), getConf());    ResultAnalyzer analyzer = new ResultAnalyzer(labelMap.values(), "DEFAULT");    analyzeResults(labelMap, dirIterable, analyzer);    log.info("{} Results: {}", hasOption("testComplementary") ? "Complementary" : "Standard NB", analyzer);    return 0;}
682f39c2df5e53497342b0e66425c4e6fab52d4604121a5bfc2ea2551ff14667
runSequential
private void runSequential() throws IOException
{    boolean complementary = hasOption("testComplementary");    FileSystem fs = FileSystem.get(getConf());    NaiveBayesModel model = NaiveBayesModel.materialize(new Path(getOption("model")), getConf());        if (complementary) {        Preconditions.checkArgument((model.isComplemtary()), "Complementary mode in model is different from test mode");    }    AbstractNaiveBayesClassifier classifier;    if (complementary) {        classifier = new ComplementaryNaiveBayesClassifier(model);    } else {        classifier = new StandardNaiveBayesClassifier(model);    }    try (SequenceFile.Writer writer = SequenceFile.createWriter(fs, getConf(), new Path(getOutputPath(), "part-r-00000"), Text.class, VectorWritable.class)) {        SequenceFileDirIterable<Text, VectorWritable> dirIterable = new SequenceFileDirIterable<>(getInputPath(), PathType.LIST, PathFilters.partFilter(), getConf());                for (Pair<Text, VectorWritable> pair : dirIterable) {            writer.append(new Text(SLASH.split(pair.getFirst().toString())[1]), new VectorWritable(classifier.classifyFull(pair.getSecond().get())));        }    }}
0c945b527bfde9880c93e29744e310e6ab11ee9a924eb6c889e0fea0adb5765c
runMapReduce
private boolean runMapReduce() throws IOException, InterruptedException, ClassNotFoundException
{    Path model = new Path(getOption("model"));    HadoopUtil.cacheFiles(model, getConf());        Job testJob = prepareJob(getInputPath(), getOutputPath(), SequenceFileInputFormat.class, BayesTestMapper.class, Text.class, VectorWritable.class, SequenceFileOutputFormat.class);        boolean complementary = hasOption("testComplementary");    testJob.getConfiguration().set(COMPLEMENTARY, String.valueOf(complementary));    return testJob.waitForCompletion(true);}
ece25fdf4234b26d90deccb703645c5906bf3032c821f718c088846fe689ef7f
analyzeResults
private static void analyzeResults(Map<Integer, String> labelMap, SequenceFileDirIterable<Text, VectorWritable> dirIterable, ResultAnalyzer analyzer)
{    for (Pair<Text, VectorWritable> pair : dirIterable) {        int bestIdx = Integer.MIN_VALUE;        double bestScore = Long.MIN_VALUE;        for (Vector.Element element : pair.getSecond().get().all()) {            if (element.get() > bestScore) {                bestScore = element.get();                bestIdx = element.index();            }        }        if (bestIdx != Integer.MIN_VALUE) {            ClassifierResult classifierResult = new ClassifierResult(labelMap.get(bestIdx), bestScore);            analyzer.addInstance(pair.getFirst().toString(), classifierResult);        }    }}
db1c5b95030fef8fe5ebf36adf29a4ae798946d2f756cd5e9db6b8de375eb89d
train
public void train(int label, Vector perLabelWeight)
{    double labelWeight = labelWeight(label);        for (int i = 0; i < perLabelWeight.size(); i++) {        Vector.Element perLabelWeightElement = perLabelWeight.getElement(i);        updatePerLabelThetaNormalizer(label, ComplementaryNaiveBayesClassifier.computeWeight(featureWeight(perLabelWeightElement.index()), perLabelWeightElement.get(), totalWeightSum(), labelWeight, alphaI(), numFeatures()));    }}
301bd1aba660adc49df9e6d0b9ebf26419dc761362dba64b4d6934ef8d328bcd
alphaI
protected double alphaI()
{    return alphaI;}
ce85c610cd91208de68856eb03a4956c261408bfbc76ac1b54632a19e6ef5889
numFeatures
protected double numFeatures()
{    return numFeatures;}
4c9e65fbffe213bebc72902b493d04e663f5af65bce027c57cc041d7d6290c7e
labelWeight
protected double labelWeight(int label)
{    return weightsPerLabel.get(label);}
23de1f3f9919235bb434cad864ff90adfc0b66393f804384522e04587848e390
totalWeightSum
protected double totalWeightSum()
{    return totalWeightSum;}
498f2bb8726c687359015a76d1aa2e0ed5d8bacbe90e4ffeaec86e3053ee3bc3
featureWeight
protected double featureWeight(int feature)
{    return weightsPerFeature.get(feature);}
2269ed2f64811b4b052033ca16fac71c65e44d3174394e8c9293d193e48f80e1
updatePerLabelThetaNormalizer
protected void updatePerLabelThetaNormalizer(int label, double weight)
{    perLabelThetaNormalizer.set(label, perLabelThetaNormalizer.get(label) + Math.abs(weight));}
911ea683dd04c0ff4f5cd7cb3d10f4ebed214501e515c3765863d05090913e9b
retrievePerLabelThetaNormalizer
public Vector retrievePerLabelThetaNormalizer()
{    return perLabelThetaNormalizer.clone();}
d3192444cabbcc9598d5706bfdcd1dfedd209d3688c3c575e42fd6b75ea83739
setup
protected void setup(Context ctx) throws IOException, InterruptedException
{    super.setup(ctx);    labelIndex = BayesUtils.readIndexFromCache(ctx.getConfiguration());}
5f946e23846196313cee15582b5e9d66a747eae1162feded45b8b782f1882380
map
protected void map(Text labelText, VectorWritable instance, Context ctx) throws IOException, InterruptedException
{    String label = SLASH.split(labelText.toString())[1];    if (labelIndex.containsKey(label)) {        ctx.write(new IntWritable(labelIndex.get(label)), instance);    } else {        ctx.getCounter(Counter.SKIPPED_INSTANCES).increment(1);    }}
d3192444cabbcc9598d5706bfdcd1dfedd209d3688c3c575e42fd6b75ea83739
setup
protected void setup(Context ctx) throws IOException, InterruptedException
{    super.setup(ctx);    Configuration conf = ctx.getConfiguration();    float alphaI = conf.getFloat(ALPHA_I, 1.0f);    Map<String, Vector> scores = BayesUtils.readScoresFromCache(conf);    trainer = new ComplementaryThetaTrainer(scores.get(TrainNaiveBayesJob.WEIGHTS_PER_FEATURE), scores.get(TrainNaiveBayesJob.WEIGHTS_PER_LABEL), alphaI);}
b46904806e3228e1a1cf2521e931352b2b8523b470f11c5af983d26a2061880d
map
protected void map(IntWritable key, VectorWritable value, Context ctx) throws IOException, InterruptedException
{    trainer.train(key.get(), value.get());}
1e67e7cddbb210542b6d1a0c46225cb3c8845f7c014f884b63e2f939ee36f067
cleanup
protected void cleanup(Context ctx) throws IOException, InterruptedException
{    ctx.write(new Text(TrainNaiveBayesJob.LABEL_THETA_NORMALIZER), new VectorWritable(trainer.retrievePerLabelThetaNormalizer()));    super.cleanup(ctx);}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    ToolRunner.run(new Configuration(), new TrainNaiveBayesJob(), args);}
aacecb0f01750d985b78d806dc3c134f0da79efe2752957e0f93ecf5cbf9e492
run
public int run(String[] args) throws Exception
{    addInputOption();    addOutputOption();    addOption(ALPHA_I, "a", "smoothing parameter", String.valueOf(1.0f));    addOption(buildOption(TRAIN_COMPLEMENTARY, "c", "train complementary?", false, false, String.valueOf(false)));    addOption(LABEL_INDEX, "li", "The path to store the label index in", false);    addOption(DefaultOptionCreator.overwriteOption().create());    Map<String, List<String>> parsedArgs = parseArguments(args);    if (parsedArgs == null) {        return -1;    }    if (hasOption(DefaultOptionCreator.OVERWRITE_OPTION)) {        HadoopUtil.delete(getConf(), getOutputPath());        HadoopUtil.delete(getConf(), getTempPath());    }    Path labPath;    String labPathStr = getOption(LABEL_INDEX);    if (labPathStr != null) {        labPath = new Path(labPathStr);    } else {        labPath = getTempPath(LABEL_INDEX);    }    long labelSize = createLabelIndex(labPath);    float alphaI = Float.parseFloat(getOption(ALPHA_I));    boolean trainComplementary = hasOption(TRAIN_COMPLEMENTARY);    HadoopUtil.setSerializations(getConf());    HadoopUtil.cacheFiles(labPath, getConf());        Job indexInstances = prepareJob(getInputPath(), getTempPath(SUMMED_OBSERVATIONS), SequenceFileInputFormat.class, IndexInstancesMapper.class, IntWritable.class, VectorWritable.class, VectorSumReducer.class, IntWritable.class, VectorWritable.class, SequenceFileOutputFormat.class);    indexInstances.setCombinerClass(VectorSumReducer.class);    boolean succeeded = indexInstances.waitForCompletion(true);    if (!succeeded) {        return -1;    }        Job weightSummer = prepareJob(getTempPath(SUMMED_OBSERVATIONS), getTempPath(WEIGHTS), SequenceFileInputFormat.class, WeightsMapper.class, Text.class, VectorWritable.class, VectorSumReducer.class, Text.class, VectorWritable.class, SequenceFileOutputFormat.class);    weightSummer.getConfiguration().set(WeightsMapper.NUM_LABELS, String.valueOf(labelSize));    weightSummer.setCombinerClass(VectorSumReducer.class);    succeeded = weightSummer.waitForCompletion(true);    if (!succeeded) {        return -1;    }        HadoopUtil.cacheFiles(getTempPath(WEIGHTS), getConf());    if (trainComplementary) {                        Job thetaSummer = prepareJob(getTempPath(SUMMED_OBSERVATIONS), getTempPath(THETAS), SequenceFileInputFormat.class, ThetaMapper.class, Text.class, VectorWritable.class, VectorSumReducer.class, Text.class, VectorWritable.class, SequenceFileOutputFormat.class);        thetaSummer.setCombinerClass(VectorSumReducer.class);        thetaSummer.getConfiguration().setFloat(ThetaMapper.ALPHA_I, alphaI);        thetaSummer.getConfiguration().setBoolean(ThetaMapper.TRAIN_COMPLEMENTARY, trainComplementary);        succeeded = thetaSummer.waitForCompletion(true);        if (!succeeded) {            return -1;        }    }        HadoopUtil.cacheFiles(getTempPath(THETAS), getConf());        getConf().setFloat(ThetaMapper.ALPHA_I, alphaI);    getConf().setBoolean(NaiveBayesModel.COMPLEMENTARY_MODEL, trainComplementary);    NaiveBayesModel naiveBayesModel = BayesUtils.readModelFromDir(getTempPath(), getConf());    naiveBayesModel.validate();    naiveBayesModel.serialize(getOutputPath(), getConf());    return 0;}
de3b39b682e41ec0cf292763831982184382beb84f59eff9f35fb99026b91dd0
createLabelIndex
private long createLabelIndex(Path labPath) throws IOException
{    long labelSize = 0;    Iterable<Pair<Text, IntWritable>> iterable = new SequenceFileDirIterable<>(getInputPath(), PathType.LIST, PathFilters.logsCRCFilter(), getConf());    labelSize = BayesUtils.writeLabelIndex(getConf(), labPath, iterable);    return labelSize;}
d3192444cabbcc9598d5706bfdcd1dfedd209d3688c3c575e42fd6b75ea83739
setup
protected void setup(Context ctx) throws IOException, InterruptedException
{    super.setup(ctx);    int numLabels = Integer.parseInt(ctx.getConfiguration().get(NUM_LABELS));    Preconditions.checkArgument(numLabels > 0, "Wrong numLabels: " + numLabels + ". Must be > 0!");    weightsPerLabel = new DenseVector(numLabels);}
441262fb6f991d31df4a5ab4a988cbbe8419072b339352068c276a9efe3e982b
map
protected void map(IntWritable index, VectorWritable value, Context ctx) throws IOException, InterruptedException
{    Vector instance = value.get();    if (weightsPerFeature == null) {        weightsPerFeature = new RandomAccessSparseVector(instance.size(), instance.getNumNondefaultElements());    }    int label = index.get();    weightsPerFeature.assign(instance, Functions.PLUS);    weightsPerLabel.set(label, weightsPerLabel.get(label) + instance.zSum());}
1e67e7cddbb210542b6d1a0c46225cb3c8845f7c014f884b63e2f939ee36f067
cleanup
protected void cleanup(Context ctx) throws IOException, InterruptedException
{    if (weightsPerFeature != null) {        ctx.write(new Text(TrainNaiveBayesJob.WEIGHTS_PER_FEATURE), new VectorWritable(weightsPerFeature));        ctx.write(new Text(TrainNaiveBayesJob.WEIGHTS_PER_LABEL), new VectorWritable(weightsPerLabel));    }    super.cleanup(ctx);}
394243b534a6d9486fcdf8939112377b64592a290f8401128f292dd7c3d175f2
getActual
 double getActual()
{    return actual;}
e5a2c3a61728453fa4f98d0101ba617545e0510d72b729b1bb2ab8b0beca7a01
getResult
 double getResult()
{    return result;}
00c6202814c94092549d89e1b196be1c1aafc0799603539276585981425fbbd3
addInstance
public void addInstance(double actual, double result)
{    if (results == null) {        results = new ArrayList<>();    }    results.add(new Result(actual, result));}
e6a4b47412aeca63267ec7106c138d8a5352db7ef06bafc00814f862e5e992c5
setInstances
public void setInstances(double[][] results)
{    for (double[] res : results) {        addInstance(res[0], res[1]);    }}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    double sumActual = 0.0;    double sumActualSquared = 0.0;    double sumResult = 0.0;    double sumResultSquared = 0.0;    double sumActualResult = 0.0;    double sumAbsolute = 0.0;    double sumAbsoluteSquared = 0.0;    int predictable = 0;    int unpredictable = 0;    for (Result res : results) {        double actual = res.getActual();        double result = res.getResult();        if (Double.isNaN(result)) {            unpredictable++;        } else {            sumActual += actual;            sumActualSquared += actual * actual;            sumResult += result;            sumResultSquared += result * result;            sumActualResult += actual * result;            double absolute = Math.abs(actual - result);            sumAbsolute += absolute;            sumAbsoluteSquared += absolute * absolute;            predictable++;        }    }    StringBuilder returnString = new StringBuilder();    returnString.append("=======================================================\n");    returnString.append("Summary\n");    returnString.append("-------------------------------------------------------\n");    if (predictable > 0) {        double varActual = sumActualSquared - sumActual * sumActual / predictable;        double varResult = sumResultSquared - sumResult * sumResult / predictable;        double varCo = sumActualResult - sumActual * sumResult / predictable;        double correlation;        if (varActual * varResult <= 0) {            correlation = 0.0;        } else {            correlation = varCo / Math.sqrt(varActual * varResult);        }        Locale.setDefault(Locale.US);        NumberFormat decimalFormatter = new DecimalFormat("0.####");        returnString.append(StringUtils.rightPad("Correlation coefficient", 40)).append(": ").append(StringUtils.leftPad(decimalFormatter.format(correlation), 10)).append('\n');        returnString.append(StringUtils.rightPad("Mean absolute error", 40)).append(": ").append(StringUtils.leftPad(decimalFormatter.format(sumAbsolute / predictable), 10)).append('\n');        returnString.append(StringUtils.rightPad("Root mean squared error", 40)).append(": ").append(StringUtils.leftPad(decimalFormatter.format(Math.sqrt(sumAbsoluteSquared / predictable)), 10)).append('\n');    }    returnString.append(StringUtils.rightPad("Predictable Instances", 40)).append(": ").append(StringUtils.leftPad(Integer.toString(predictable), 10)).append('\n');    returnString.append(StringUtils.rightPad("Unpredictable Instances", 40)).append(": ").append(StringUtils.leftPad(Integer.toString(unpredictable), 10)).append('\n');    returnString.append(StringUtils.rightPad("Total Regressed Instances", 40)).append(": ").append(StringUtils.leftPad(Integer.toString(results.size()), 10)).append('\n');    returnString.append('\n');    return returnString.toString();}
a9b05a03909fdda1e484bf988d6afb37519def18ee50899fdf7ccd224300d702
getConfusionMatrix
public ConfusionMatrix getConfusionMatrix()
{    return this.confusionMatrix;}
dcdcff161af7353a175729575b1d44b5b4d634222ffdeac4519932e56a5f87d5
addInstance
public boolean addInstance(String correctLabel, ClassifierResult classifiedResult)
{    boolean result = correctLabel.equals(classifiedResult.getLabel());    if (result) {        correctlyClassified++;    } else {        incorrectlyClassified++;    }    confusionMatrix.addInstance(correctLabel, classifiedResult);    if (classifiedResult.getLogLikelihood() != Double.MAX_VALUE) {        summarizer.add(classifiedResult.getLogLikelihood());        hasLL = true;    }    return result;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    StringBuilder returnString = new StringBuilder();    returnString.append('\n');    returnString.append("=======================================================\n");    returnString.append("Summary\n");    returnString.append("-------------------------------------------------------\n");    int totalClassified = correctlyClassified + incorrectlyClassified;    double percentageCorrect = (double) 100 * correctlyClassified / totalClassified;    double percentageIncorrect = (double) 100 * incorrectlyClassified / totalClassified;    NumberFormat decimalFormatter = new DecimalFormat("0.####");    returnString.append(StringUtils.rightPad("Correctly Classified Instances", 40)).append(": ").append(StringUtils.leftPad(Integer.toString(correctlyClassified), 10)).append('\t').append(StringUtils.leftPad(decimalFormatter.format(percentageCorrect), 10)).append("%\n");    returnString.append(StringUtils.rightPad("Incorrectly Classified Instances", 40)).append(": ").append(StringUtils.leftPad(Integer.toString(incorrectlyClassified), 10)).append('\t').append(StringUtils.leftPad(decimalFormatter.format(percentageIncorrect), 10)).append("%\n");    returnString.append(StringUtils.rightPad("Total Classified Instances", 40)).append(": ").append(StringUtils.leftPad(Integer.toString(totalClassified), 10)).append('\n');    returnString.append('\n');    returnString.append(confusionMatrix);    returnString.append("=======================================================\n");    returnString.append("Statistics\n");    returnString.append("-------------------------------------------------------\n");    RunningAverageAndStdDev normStats = confusionMatrix.getNormalizedStats();    returnString.append(StringUtils.rightPad("Kappa", 40)).append(StringUtils.leftPad(decimalFormatter.format(confusionMatrix.getKappa()), 10)).append('\n');    returnString.append(StringUtils.rightPad("Accuracy", 40)).append(StringUtils.leftPad(decimalFormatter.format(confusionMatrix.getAccuracy()), 10)).append("%\n");    returnString.append(StringUtils.rightPad("Reliability", 40)).append(StringUtils.leftPad(decimalFormatter.format(normStats.getAverage() * 100.00000001), 10)).append("%\n");    returnString.append(StringUtils.rightPad("Reliability (standard deviation)", 40)).append(StringUtils.leftPad(decimalFormatter.format(normStats.getStandardDeviation()), 10)).append('\n');    returnString.append(StringUtils.rightPad("Weighted precision", 40)).append(StringUtils.leftPad(decimalFormatter.format(confusionMatrix.getWeightedPrecision()), 10)).append('\n');    returnString.append(StringUtils.rightPad("Weighted recall", 40)).append(StringUtils.leftPad(decimalFormatter.format(confusionMatrix.getWeightedRecall()), 10)).append('\n');    returnString.append(StringUtils.rightPad("Weighted F1 score", 40)).append(StringUtils.leftPad(decimalFormatter.format(confusionMatrix.getWeightedF1score()), 10)).append('\n');    if (hasLL) {        returnString.append(StringUtils.rightPad("Log-likelihood", 30)).append("mean      : ").append(StringUtils.leftPad(decimalFormatter.format(summarizer.getMean()), 10)).append('\n');        returnString.append(StringUtils.rightPad("", 30)).append(StringUtils.rightPad("25%-ile   : ", 10)).append(StringUtils.leftPad(decimalFormatter.format(summarizer.getQuartile(1)), 10)).append('\n');        returnString.append(StringUtils.rightPad("", 30)).append(StringUtils.rightPad("75%-ile   : ", 10)).append(StringUtils.leftPad(decimalFormatter.format(summarizer.getQuartile(3)), 10)).append('\n');    }    return returnString.toString();}
365a24fc75086b6a0e91f9b072bd58c9280846cc05f333f28ede18388f27ce89
main
public static void main(String[] args) throws IOException
{    DefaultOptionBuilder optionBuilder = new DefaultOptionBuilder();    ArgumentBuilder argumentBuilder = new ArgumentBuilder();    Option inputOption = DefaultOptionCreator.inputOption().create();    Option outputOption = DefaultOptionCreator.outputOption().create();    Option stateNumberOption = optionBuilder.withLongName("nrOfHiddenStates").withDescription("Number of hidden states").withShortName("nh").withArgument(argumentBuilder.withMaximum(1).withMinimum(1).withName("number").create()).withRequired(true).create();    Option observedStateNumberOption = optionBuilder.withLongName("nrOfObservedStates").withDescription("Number of observed states").withShortName("no").withArgument(argumentBuilder.withMaximum(1).withMinimum(1).withName("number").create()).withRequired(true).create();    Option epsilonOption = optionBuilder.withLongName("epsilon").withDescription("Convergence threshold").withShortName("e").withArgument(argumentBuilder.withMaximum(1).withMinimum(1).withName("number").create()).withRequired(true).create();    Option iterationsOption = optionBuilder.withLongName("max-iterations").withDescription("Maximum iterations number").withShortName("m").withArgument(argumentBuilder.withMaximum(1).withMinimum(1).withName("number").create()).withRequired(true).create();    Group optionGroup = new GroupBuilder().withOption(inputOption).withOption(outputOption).withOption(stateNumberOption).withOption(observedStateNumberOption).withOption(epsilonOption).withOption(iterationsOption).withName("Options").create();    try {        Parser parser = new Parser();        parser.setGroup(optionGroup);        CommandLine commandLine = parser.parse(args);        String input = (String) commandLine.getValue(inputOption);        String output = (String) commandLine.getValue(outputOption);        int nrOfHiddenStates = Integer.parseInt((String) commandLine.getValue(stateNumberOption));        int nrOfObservedStates = Integer.parseInt((String) commandLine.getValue(observedStateNumberOption));        double epsilon = Double.parseDouble((String) commandLine.getValue(epsilonOption));        int maxIterations = Integer.parseInt((String) commandLine.getValue(iterationsOption));                HmmModel model = new HmmModel(nrOfHiddenStates, nrOfObservedStates, new Date().getTime());        List<Integer> observations = new ArrayList<>();                try (Scanner scanner = new Scanner(new FileInputStream(input), "UTF-8")) {            while (scanner.hasNextInt()) {                observations.add(scanner.nextInt());            }        }        int[] observationsArray = new int[observations.size()];        for (int i = 0; i < observations.size(); ++i) {            observationsArray[i] = observations.get(i);        }                HmmModel trainedModel = HmmTrainer.trainBaumWelch(model, observationsArray, epsilon, maxIterations, true);                try (DataOutputStream stream = new DataOutputStream(new FileOutputStream(output))) {            LossyHmmSerializer.serialize(trainedModel, stream);        }                System.out.println("Initial probabilities: ");        for (int i = 0; i < trainedModel.getNrOfHiddenStates(); ++i) {            System.out.print(i + " ");        }        System.out.println();        for (int i = 0; i < trainedModel.getNrOfHiddenStates(); ++i) {            System.out.print(trainedModel.getInitialProbabilities().get(i) + " ");        }        System.out.println();        System.out.println("Transition matrix:");        System.out.print("  ");        for (int i = 0; i < trainedModel.getNrOfHiddenStates(); ++i) {            System.out.print(i + " ");        }        System.out.println();        for (int i = 0; i < trainedModel.getNrOfHiddenStates(); ++i) {            System.out.print(i + " ");            for (int j = 0; j < trainedModel.getNrOfHiddenStates(); ++j) {                System.out.print(trainedModel.getTransitionMatrix().get(i, j) + " ");            }            System.out.println();        }        System.out.println("Emission matrix: ");        System.out.print("  ");        for (int i = 0; i < trainedModel.getNrOfOutputStates(); ++i) {            System.out.print(i + " ");        }        System.out.println();        for (int i = 0; i < trainedModel.getNrOfHiddenStates(); ++i) {            System.out.print(i + " ");            for (int j = 0; j < trainedModel.getNrOfOutputStates(); ++j) {                System.out.print(trainedModel.getEmissionMatrix().get(i, j) + " ");            }            System.out.println();        }    } catch (OptionException e) {        CommandLineUtil.printHelp(optionGroup);    }}
592f33a81176d852c3f9def0558dbedda6c301bff169849e1468bc041fdc40f1
forwardAlgorithm
public static Matrix forwardAlgorithm(HmmModel model, int[] observations, boolean scaled)
{    Matrix alpha = new DenseMatrix(observations.length, model.getNrOfHiddenStates());    forwardAlgorithm(alpha, model, observations, scaled);    return alpha;}
18370300fcea7b6ce7321de287acebcf4a49cd157ee9a36be5dbf4708ddf6053
forwardAlgorithm
 static void forwardAlgorithm(Matrix alpha, HmmModel model, int[] observations, boolean scaled)
{        Vector ip = model.getInitialProbabilities();    Matrix b = model.getEmissionMatrix();    Matrix a = model.getTransitionMatrix();    if (scaled) {                for (int i = 0; i < model.getNrOfHiddenStates(); i++) {            alpha.setQuick(0, i, Math.log(ip.getQuick(i) * b.getQuick(i, observations[0])));        }                for (int t = 1; t < observations.length; t++) {            for (int i = 0; i < model.getNrOfHiddenStates(); i++) {                                double sum = Double.NEGATIVE_INFINITY;                for (int j = 0; j < model.getNrOfHiddenStates(); j++) {                    double tmp = alpha.getQuick(t - 1, j) + Math.log(a.getQuick(j, i));                    if (tmp > Double.NEGATIVE_INFINITY) {                                                sum = tmp + Math.log1p(Math.exp(sum - tmp));                    }                }                alpha.setQuick(t, i, sum + Math.log(b.getQuick(i, observations[t])));            }        }    } else {                for (int i = 0; i < model.getNrOfHiddenStates(); i++) {            alpha.setQuick(0, i, ip.getQuick(i) * b.getQuick(i, observations[0]));        }                for (int t = 1; t < observations.length; t++) {            for (int i = 0; i < model.getNrOfHiddenStates(); i++) {                double sum = 0.0;                for (int j = 0; j < model.getNrOfHiddenStates(); j++) {                    sum += alpha.getQuick(t - 1, j) * a.getQuick(j, i);                }                alpha.setQuick(t, i, sum * b.getQuick(i, observations[t]));            }        }    }}
4dac3ba7d4e8d5299ad4930345512a06b32b396941c8999a0332e537f805e767
backwardAlgorithm
public static Matrix backwardAlgorithm(HmmModel model, int[] observations, boolean scaled)
{        Matrix beta = new DenseMatrix(observations.length, model.getNrOfHiddenStates());        backwardAlgorithm(beta, model, observations, scaled);    return beta;}
081b5b31e6b94f4994527ca8d1e3c5bcba9d20ac19651c7ccc3c6bcbb7db6267
backwardAlgorithm
 static void backwardAlgorithm(Matrix beta, HmmModel model, int[] observations, boolean scaled)
{        Matrix b = model.getEmissionMatrix();    Matrix a = model.getTransitionMatrix();    if (scaled) {                for (int i = 0; i < model.getNrOfHiddenStates(); i++) {            beta.setQuick(observations.length - 1, i, 0);        }                for (int t = observations.length - 2; t >= 0; t--) {            for (int i = 0; i < model.getNrOfHiddenStates(); i++) {                                double sum = Double.NEGATIVE_INFINITY;                for (int j = 0; j < model.getNrOfHiddenStates(); j++) {                    double tmp = beta.getQuick(t + 1, j) + Math.log(a.getQuick(i, j)) + Math.log(b.getQuick(j, observations[t + 1]));                    if (tmp > Double.NEGATIVE_INFINITY) {                                                sum = tmp + Math.log1p(Math.exp(sum - tmp));                    }                }                beta.setQuick(t, i, sum);            }        }    } else {                for (int i = 0; i < model.getNrOfHiddenStates(); i++) {            beta.setQuick(observations.length - 1, i, 1);        }                for (int t = observations.length - 2; t >= 0; t--) {            for (int i = 0; i < model.getNrOfHiddenStates(); i++) {                double sum = 0;                for (int j = 0; j < model.getNrOfHiddenStates(); j++) {                    sum += beta.getQuick(t + 1, j) * a.getQuick(i, j) * b.getQuick(j, observations[t + 1]);                }                beta.setQuick(t, i, sum);            }        }    }}
2d0c125e50e10f7af89e060c2071e7e5aa75d13ee90336352fb2f62aaea4c414
viterbiAlgorithm
public static int[] viterbiAlgorithm(HmmModel model, int[] observations, boolean scaled)
{            double[][] delta = new double[observations.length][model.getNrOfHiddenStates()];            int[][] phi = new int[observations.length - 1][model.getNrOfHiddenStates()];        int[] sequence = new int[observations.length];    viterbiAlgorithm(sequence, delta, phi, model, observations, scaled);    return sequence;}
59ba02ba18ab703fbccc9559eacd4bca96c931c95eaa7403f55c91137eb4480e
viterbiAlgorithm
 static void viterbiAlgorithm(int[] sequence, double[][] delta, int[][] phi, HmmModel model, int[] observations, boolean scaled)
{        Vector ip = model.getInitialProbabilities();    Matrix b = model.getEmissionMatrix();    Matrix a = model.getTransitionMatrix();        if (scaled) {        for (int i = 0; i < model.getNrOfHiddenStates(); i++) {            delta[0][i] = Math.log(ip.getQuick(i) * b.getQuick(i, observations[0]));        }    } else {        for (int i = 0; i < model.getNrOfHiddenStates(); i++) {            delta[0][i] = ip.getQuick(i) * b.getQuick(i, observations[0]);        }    }        if (scaled) {        for (int t = 1; t < observations.length; t++) {                        for (int i = 0; i < model.getNrOfHiddenStates(); i++) {                                                                int maxState = 0;                double maxProb = delta[t - 1][0] + Math.log(a.getQuick(0, i));                for (int j = 1; j < model.getNrOfHiddenStates(); j++) {                    double prob = delta[t - 1][j] + Math.log(a.getQuick(j, i));                    if (prob > maxProb) {                        maxProb = prob;                        maxState = j;                    }                }                delta[t][i] = maxProb + Math.log(b.getQuick(i, observations[t]));                phi[t - 1][i] = maxState;            }        }    } else {        for (int t = 1; t < observations.length; t++) {                        for (int i = 0; i < model.getNrOfHiddenStates(); i++) {                                                                int maxState = 0;                double maxProb = delta[t - 1][0] * a.getQuick(0, i);                for (int j = 1; j < model.getNrOfHiddenStates(); j++) {                    double prob = delta[t - 1][j] * a.getQuick(j, i);                    if (prob > maxProb) {                        maxProb = prob;                        maxState = j;                    }                }                delta[t][i] = maxProb * b.getQuick(i, observations[t]);                phi[t - 1][i] = maxState;            }        }    }        double maxProb;    if (scaled) {        maxProb = Double.NEGATIVE_INFINITY;    } else {        maxProb = 0.0;    }    for (int i = 0; i < model.getNrOfHiddenStates(); i++) {        if (delta[observations.length - 1][i] > maxProb) {            maxProb = delta[observations.length - 1][i];            sequence[observations.length - 1] = i;        }    }        for (int t = observations.length - 2; t >= 0; t--) {        sequence[t] = phi[t][sequence[t + 1]];    }}
d5ef5e5b630e8ac552e57735f3911c44ffbceb3727095c5d57eb4c775240233d
predict
public static int[] predict(HmmModel model, int steps)
{    return predict(model, steps, RandomUtils.getRandom());}
b3ce9ebd4d0c1a5bed0a746cd006fb6b784d9da65635efa0332ae87d2108b067
predict
public static int[] predict(HmmModel model, int steps, long seed)
{    return predict(model, steps, RandomUtils.getRandom(seed));}
2d0e0e25be10b0e74fba12f80c4be64653a7f1336682841a2e3d99c9d44486a5
predict
private static int[] predict(HmmModel model, int steps, Random rand)
{        Vector cip = HmmUtils.getCumulativeInitialProbabilities(model);    Matrix ctm = HmmUtils.getCumulativeTransitionMatrix(model);    Matrix com = HmmUtils.getCumulativeOutputMatrix(model);        int[] result = new int[steps];        int hiddenState = 0;    double randnr = rand.nextDouble();    while (cip.get(hiddenState) < randnr) {        hiddenState++;    }        for (int step = 0; step < steps; ++step) {                randnr = rand.nextDouble();        int outputState = 0;        while (com.get(hiddenState, outputState) < randnr) {            outputState++;        }        result[step] = outputState;                randnr = rand.nextDouble();        int nextHiddenState = 0;        while (ctm.get(hiddenState, nextHiddenState) < randnr) {            nextHiddenState++;        }        hiddenState = nextHiddenState;    }    return result;}
9f1d4543964ad69c370232b7d664e6beb69a98daa2ef76ff32700cf17619203e
modelLikelihood
public static double modelLikelihood(HmmModel model, int[] outputSequence, boolean scaled)
{    return modelLikelihood(HmmAlgorithms.forwardAlgorithm(model, outputSequence, scaled), scaled);}
1db2e74aaf4ca96c6c5bf422628d4b21cd28ee437f665bb84c8e9d987a3fd0d5
modelLikelihood
public static double modelLikelihood(Matrix alpha, boolean scaled)
{    double likelihood = 0;    if (scaled) {        for (int i = 0; i < alpha.numCols(); ++i) {            likelihood += Math.exp(alpha.getQuick(alpha.numRows() - 1, i));        }    } else {        for (int i = 0; i < alpha.numCols(); ++i) {            likelihood += alpha.getQuick(alpha.numRows() - 1, i);        }    }    return likelihood;}
222508b3877cf12ca7ce220bfaa28097178daaa03236f5b47b4f3925b2240170
modelLikelihood
public static double modelLikelihood(HmmModel model, int[] outputSequence, Matrix beta, boolean scaled)
{    double likelihood = 0;        Matrix e = model.getEmissionMatrix();    Vector pi = model.getInitialProbabilities();    int firstOutput = outputSequence[0];    if (scaled) {        for (int i = 0; i < model.getNrOfHiddenStates(); ++i) {            likelihood += pi.getQuick(i) * Math.exp(beta.getQuick(0, i)) * e.getQuick(i, firstOutput);        }    } else {        for (int i = 0; i < model.getNrOfHiddenStates(); ++i) {            likelihood += pi.getQuick(i) * beta.getQuick(0, i) * e.getQuick(i, firstOutput);        }    }    return likelihood;}
17846e6c093cdb20a49e31a692ec97780dcb4fdc18f6fa828a9485189dc7fe93
decode
public static int[] decode(HmmModel model, int[] observations, boolean scaled)
{    return HmmAlgorithms.viterbiAlgorithm(model, observations, scaled);}
fb09d9ab94a3ea1341463a2dd449397df4af9ad59f9ab20528a827a57cb22e59
clone
public HmmModel clone()
{    HmmModel model = new HmmModel(transitionMatrix.clone(), emissionMatrix.clone(), initialProbabilities.clone());    if (hiddenStateNames != null) {        model.hiddenStateNames = HashBiMap.create(hiddenStateNames);    }    if (outputStateNames != null) {        model.outputStateNames = HashBiMap.create(outputStateNames);    }    return model;}
12da5507ee731440926796b38b49b929dbe041e0cf66ea4d8351b8dab7f5d662
assign
public void assign(HmmModel model)
{    this.nrOfHiddenStates = model.nrOfHiddenStates;    this.nrOfOutputStates = model.nrOfOutputStates;    this.hiddenStateNames = model.hiddenStateNames;    this.outputStateNames = model.outputStateNames;        this.initialProbabilities = model.initialProbabilities.clone();    this.emissionMatrix = model.emissionMatrix.clone();    this.transitionMatrix = model.transitionMatrix.clone();}
5255dfb955d75ae5e8ef84e36772702a808152ee381e99a68bc74443fa3f3108
initRandomParameters
private void initRandomParameters(long seed)
{    Random rand;        if (seed == 0) {        rand = RandomUtils.getRandom();    } else {        rand = RandomUtils.getRandom(seed);    }            double sum = 0;    for (int i = 0; i < nrOfHiddenStates; i++) {        double nextRand = rand.nextDouble();        initialProbabilities.set(i, nextRand);        sum += nextRand;    }        initialProbabilities = initialProbabilities.divide(sum);        double[] values = new double[nrOfHiddenStates];    for (int i = 0; i < nrOfHiddenStates; i++) {        sum = 0;        for (int j = 0; j < nrOfHiddenStates; j++) {            values[j] = rand.nextDouble();            sum += values[j];        }                for (int j = 0; j < nrOfHiddenStates; j++) {            values[j] /= sum;        }                transitionMatrix.set(i, values);    }        values = new double[nrOfOutputStates];    for (int i = 0; i < nrOfHiddenStates; i++) {        sum = 0;        for (int j = 0; j < nrOfOutputStates; j++) {            values[j] = rand.nextDouble();            sum += values[j];        }                for (int j = 0; j < nrOfOutputStates; j++) {            values[j] /= sum;        }                emissionMatrix.set(i, values);    }}
e5b200206b3b5c4dd496ce6037450babc854bc4aa2d3b310cfa9e8990807e1fd
getNrOfHiddenStates
public int getNrOfHiddenStates()
{    return nrOfHiddenStates;}
12434ca2761569a4d61d82994608b0fd0fe2f6c946b00ad714832d13a54b3dc5
getNrOfOutputStates
public int getNrOfOutputStates()
{    return nrOfOutputStates;}
c26dc3726f38318fc9f736bc63afb8c8b32fbd795f8cea51047ed63ce214ef53
getTransitionMatrix
public Matrix getTransitionMatrix()
{    return transitionMatrix;}
c9ba0ee10b7a1da29f9c79dd2055100e885ac4a2dd6d15ac9351a832462dbe4e
getEmissionMatrix
public Matrix getEmissionMatrix()
{    return emissionMatrix;}
651414fd0dd5f670fb4e1cbc59f6cdd9761cbec3182a8136e16db3f4b54db111
getInitialProbabilities
public Vector getInitialProbabilities()
{    return initialProbabilities;}
d229067aa6c67c21fee302ac31189e00295bfcfdb344f3ea96d501e9bc33f507
getHiddenStateNames
public Map<String, Integer> getHiddenStateNames()
{    return hiddenStateNames;}
f648af89a1358cb8502ab99a540c7a714b7bb9ae53f75740f8f407be24925a0b
registerHiddenStateNames
public void registerHiddenStateNames(String[] stateNames)
{    if (stateNames != null) {        hiddenStateNames = HashBiMap.create();        for (int i = 0; i < stateNames.length; ++i) {            hiddenStateNames.put(stateNames[i], i);        }    }}
8272d1797525fdf55c3cd69e3e29da4d9d618b019d69bde68bba9110bc8c5d20
registerHiddenStateNames
public void registerHiddenStateNames(Map<String, Integer> stateNames)
{    if (stateNames != null) {        hiddenStateNames = HashBiMap.create(stateNames);    }}
85d477b24c1212f43708f6330d98d3e98f17dd827c0061ab65f982c318810756
getHiddenStateName
public String getHiddenStateName(int id)
{    if (hiddenStateNames == null) {        return null;    }    return hiddenStateNames.inverse().get(id);}
32b35bfa11bbb59b774e75a7e3e80035194d9ff6e2dc8b44bdfa13d5fea14b47
getHiddenStateID
public int getHiddenStateID(String name)
{    if (hiddenStateNames == null) {        return -1;    }    Integer tmp = hiddenStateNames.get(name);    return tmp == null ? -1 : tmp;}
d359ab6262894fac9efc9c25df7048ac07eb14443ae628b6a77d748785a65260
getOutputStateNames
public Map<String, Integer> getOutputStateNames()
{    return outputStateNames;}
31b1a5bfade7e102d88f4dbe285f370583add7e843b364914b87d62d6c93b71c
registerOutputStateNames
public void registerOutputStateNames(String[] stateNames)
{    if (stateNames != null) {        outputStateNames = HashBiMap.create();        for (int i = 0; i < stateNames.length; ++i) {            outputStateNames.put(stateNames[i], i);        }    }}
d64632674f0ba2cfc3509d0e0208d14a8875a9369fa3d37b79c7dc6ce615c491
registerOutputStateNames
public void registerOutputStateNames(Map<String, Integer> stateNames)
{    if (stateNames != null) {        outputStateNames = HashBiMap.create(stateNames);    }}
b5dd56b6315ac5a84aba0f2b403b10fda593fc46be1e54bdbe9d296429393b09
getOutputStateName
public String getOutputStateName(int id)
{    if (outputStateNames == null) {        return null;    }    return outputStateNames.inverse().get(id);}
8d0652d0528b76eed2f5b2f0c3cdae68deabac5690b9304fab6fd8562c07a08e
getOutputStateID
public int getOutputStateID(String name)
{    if (outputStateNames == null) {        return -1;    }    Integer tmp = outputStateNames.get(name);    return tmp == null ? -1 : tmp;}
2908a0ed1fd4badb62a664b392963856b2395cc5dcac4a3117757b8efd81b0f4
trainSupervised
public static HmmModel trainSupervised(int nrOfHiddenStates, int nrOfOutputStates, int[] observedSequence, int[] hiddenSequence, double pseudoCount)
{        pseudoCount = pseudoCount == 0 ? Double.MIN_VALUE : pseudoCount;        DenseMatrix transitionMatrix = new DenseMatrix(nrOfHiddenStates, nrOfHiddenStates);    DenseMatrix emissionMatrix = new DenseMatrix(nrOfHiddenStates, nrOfOutputStates);            transitionMatrix.assign(pseudoCount);    emissionMatrix.assign(pseudoCount);            DenseVector initialProbabilities = new DenseVector(nrOfHiddenStates);    initialProbabilities.assign(1.0 / nrOfHiddenStates);        countTransitions(transitionMatrix, emissionMatrix, observedSequence, hiddenSequence);        for (int i = 0; i < nrOfHiddenStates; i++) {                double sum = 0;        for (int j = 0; j < nrOfHiddenStates; j++) {            sum += transitionMatrix.getQuick(i, j);        }                for (int j = 0; j < nrOfHiddenStates; j++) {            transitionMatrix.setQuick(i, j, transitionMatrix.getQuick(i, j) / sum);        }                sum = 0;        for (int j = 0; j < nrOfOutputStates; j++) {            sum += emissionMatrix.getQuick(i, j);        }                for (int j = 0; j < nrOfOutputStates; j++) {            emissionMatrix.setQuick(i, j, emissionMatrix.getQuick(i, j) / sum);        }    }        return new HmmModel(transitionMatrix, emissionMatrix, initialProbabilities);}
bba4586070dc58cd183574756febdf08d11af765e131d8118e2a32e52d2bd4ce
countTransitions
private static void countTransitions(Matrix transitionMatrix, Matrix emissionMatrix, int[] observedSequence, int[] hiddenSequence)
{    emissionMatrix.setQuick(hiddenSequence[0], observedSequence[0], emissionMatrix.getQuick(hiddenSequence[0], observedSequence[0]) + 1);    for (int i = 1; i < observedSequence.length; ++i) {        transitionMatrix.setQuick(hiddenSequence[i - 1], hiddenSequence[i], transitionMatrix.getQuick(hiddenSequence[i - 1], hiddenSequence[i]) + 1);        emissionMatrix.setQuick(hiddenSequence[i], observedSequence[i], emissionMatrix.getQuick(hiddenSequence[i], observedSequence[i]) + 1);    }}
e0e349c8ddb3b10d3068ea993bc6690055b7785bfb2ebfd8669e933233be3b57
trainSupervisedSequence
public static HmmModel trainSupervisedSequence(int nrOfHiddenStates, int nrOfOutputStates, Collection<int[]> hiddenSequences, Collection<int[]> observedSequences, double pseudoCount)
{        pseudoCount = pseudoCount == 0 ? Double.MIN_VALUE : pseudoCount;        DenseMatrix transitionMatrix = new DenseMatrix(nrOfHiddenStates, nrOfHiddenStates);    DenseMatrix emissionMatrix = new DenseMatrix(nrOfHiddenStates, nrOfOutputStates);    DenseVector initialProbabilities = new DenseVector(nrOfHiddenStates);        transitionMatrix.assign(pseudoCount);    emissionMatrix.assign(pseudoCount);    initialProbabilities.assign(pseudoCount);        Iterator<int[]> hiddenSequenceIt = hiddenSequences.iterator();    Iterator<int[]> observedSequenceIt = observedSequences.iterator();    while (hiddenSequenceIt.hasNext() && observedSequenceIt.hasNext()) {                int[] hiddenSequence = hiddenSequenceIt.next();        int[] observedSequence = observedSequenceIt.next();                initialProbabilities.setQuick(hiddenSequence[0], initialProbabilities.getQuick(hiddenSequence[0]) + 1);        countTransitions(transitionMatrix, emissionMatrix, observedSequence, hiddenSequence);    }            double isum = 0;    for (int i = 0; i < nrOfHiddenStates; i++) {        isum += initialProbabilities.getQuick(i);                double sum = 0;        for (int j = 0; j < nrOfHiddenStates; j++) {            sum += transitionMatrix.getQuick(i, j);        }                for (int j = 0; j < nrOfHiddenStates; j++) {            transitionMatrix.setQuick(i, j, transitionMatrix.getQuick(i, j) / sum);        }                sum = 0;        for (int j = 0; j < nrOfOutputStates; j++) {            sum += emissionMatrix.getQuick(i, j);        }                for (int j = 0; j < nrOfOutputStates; j++) {            emissionMatrix.setQuick(i, j, emissionMatrix.getQuick(i, j) / sum);        }    }        for (int i = 0; i < nrOfHiddenStates; ++i) {        initialProbabilities.setQuick(i, initialProbabilities.getQuick(i) / isum);    }        return new HmmModel(transitionMatrix, emissionMatrix, initialProbabilities);}
2f4ab75fa2f7fe76fb9e55f831ca562599a79d782c0cbfdf7f4ca2f0d31028c1
trainViterbi
public static HmmModel trainViterbi(HmmModel initialModel, int[] observedSequence, double pseudoCount, double epsilon, int maxIterations, boolean scaled)
{        pseudoCount = pseudoCount == 0 ? Double.MIN_VALUE : pseudoCount;        HmmModel lastIteration = initialModel.clone();    HmmModel iteration = initialModel.clone();        int[] viterbiPath = new int[observedSequence.length];    int[][] phi = new int[observedSequence.length - 1][initialModel.getNrOfHiddenStates()];    double[][] delta = new double[observedSequence.length][initialModel.getNrOfHiddenStates()];        for (int i = 0; i < maxIterations; ++i) {                HmmAlgorithms.viterbiAlgorithm(viterbiPath, delta, phi, lastIteration, observedSequence, scaled);                        Matrix emissionMatrix = iteration.getEmissionMatrix();        Matrix transitionMatrix = iteration.getTransitionMatrix();                emissionMatrix.assign(pseudoCount);        transitionMatrix.assign(pseudoCount);                countTransitions(transitionMatrix, emissionMatrix, observedSequence, viterbiPath);                for (int j = 0; j < iteration.getNrOfHiddenStates(); ++j) {            double sum = 0;                        for (int k = 0; k < iteration.getNrOfHiddenStates(); ++k) {                sum += transitionMatrix.getQuick(j, k);            }            for (int k = 0; k < iteration.getNrOfHiddenStates(); ++k) {                transitionMatrix.setQuick(j, k, transitionMatrix.getQuick(j, k) / sum);            }                        sum = 0;            for (int k = 0; k < iteration.getNrOfOutputStates(); ++k) {                sum += emissionMatrix.getQuick(j, k);            }            for (int k = 0; k < iteration.getNrOfOutputStates(); ++k) {                emissionMatrix.setQuick(j, k, emissionMatrix.getQuick(j, k) / sum);            }        }                if (checkConvergence(lastIteration, iteration, epsilon)) {            break;        }                lastIteration.assign(iteration);    }        return iteration;}
399132f9235d860f52cdaa295f2e972c4efec2830d4b6d79c9977aa580ba64d3
trainBaumWelch
public static HmmModel trainBaumWelch(HmmModel initialModel, int[] observedSequence, double epsilon, int maxIterations, boolean scaled)
{        HmmModel lastIteration = initialModel.clone();    HmmModel iteration = initialModel.clone();        int hiddenCount = initialModel.getNrOfHiddenStates();    int visibleCount = observedSequence.length;    Matrix alpha = new DenseMatrix(visibleCount, hiddenCount);    Matrix beta = new DenseMatrix(visibleCount, hiddenCount);        for (int it = 0; it < maxIterations; ++it) {                Vector initialProbabilities = iteration.getInitialProbabilities();        Matrix emissionMatrix = iteration.getEmissionMatrix();        Matrix transitionMatrix = iteration.getTransitionMatrix();                HmmAlgorithms.forwardAlgorithm(alpha, iteration, observedSequence, scaled);        HmmAlgorithms.backwardAlgorithm(beta, iteration, observedSequence, scaled);        if (scaled) {            logScaledBaumWelch(observedSequence, iteration, alpha, beta);        } else {            unscaledBaumWelch(observedSequence, iteration, alpha, beta);        }                        double isum = 0;        for (int j = 0; j < iteration.getNrOfHiddenStates(); ++j) {            double sum = 0;                        for (int k = 0; k < iteration.getNrOfHiddenStates(); ++k) {                sum += transitionMatrix.getQuick(j, k);            }            for (int k = 0; k < iteration.getNrOfHiddenStates(); ++k) {                transitionMatrix.setQuick(j, k, transitionMatrix.getQuick(j, k) / sum);            }                        sum = 0;            for (int k = 0; k < iteration.getNrOfOutputStates(); ++k) {                sum += emissionMatrix.getQuick(j, k);            }            for (int k = 0; k < iteration.getNrOfOutputStates(); ++k) {                emissionMatrix.setQuick(j, k, emissionMatrix.getQuick(j, k) / sum);            }                        isum += initialProbabilities.getQuick(j);        }                for (int i = 0; i < iteration.getNrOfHiddenStates(); ++i) {            initialProbabilities.setQuick(i, initialProbabilities.getQuick(i) / isum);        }                if (checkConvergence(lastIteration, iteration, epsilon)) {            break;        }                lastIteration.assign(iteration);    }        return iteration;}
006623b9de6bf7718ecc576323a3e9dcb1ba5f8b1c3c1e6c59206e280afeced7
unscaledBaumWelch
private static void unscaledBaumWelch(int[] observedSequence, HmmModel iteration, Matrix alpha, Matrix beta)
{    Vector initialProbabilities = iteration.getInitialProbabilities();    Matrix emissionMatrix = iteration.getEmissionMatrix();    Matrix transitionMatrix = iteration.getTransitionMatrix();    double modelLikelihood = HmmEvaluator.modelLikelihood(alpha, false);    for (int i = 0; i < iteration.getNrOfHiddenStates(); ++i) {        initialProbabilities.setQuick(i, alpha.getQuick(0, i) * beta.getQuick(0, i));    }        for (int i = 0; i < iteration.getNrOfHiddenStates(); ++i) {        for (int j = 0; j < iteration.getNrOfHiddenStates(); ++j) {            double temp = 0;            for (int t = 0; t < observedSequence.length - 1; ++t) {                temp += alpha.getQuick(t, i) * emissionMatrix.getQuick(j, observedSequence[t + 1]) * beta.getQuick(t + 1, j);            }            transitionMatrix.setQuick(i, j, transitionMatrix.getQuick(i, j) * temp / modelLikelihood);        }    }        for (int i = 0; i < iteration.getNrOfHiddenStates(); ++i) {        for (int j = 0; j < iteration.getNrOfOutputStates(); ++j) {            double temp = 0;            for (int t = 0; t < observedSequence.length; ++t) {                                if (observedSequence[t] == j) {                    temp += alpha.getQuick(t, i) * beta.getQuick(t, i);                }            }            emissionMatrix.setQuick(i, j, temp / modelLikelihood);        }    }}
461e7816a01e3ab20f1c70f56c6699cc14b7091ff51c27b4ec98d38723645569
logScaledBaumWelch
private static void logScaledBaumWelch(int[] observedSequence, HmmModel iteration, Matrix alpha, Matrix beta)
{    Vector initialProbabilities = iteration.getInitialProbabilities();    Matrix emissionMatrix = iteration.getEmissionMatrix();    Matrix transitionMatrix = iteration.getTransitionMatrix();    double modelLikelihood = HmmEvaluator.modelLikelihood(alpha, true);    for (int i = 0; i < iteration.getNrOfHiddenStates(); ++i) {        initialProbabilities.setQuick(i, Math.exp(alpha.getQuick(0, i) + beta.getQuick(0, i)));    }        for (int i = 0; i < iteration.getNrOfHiddenStates(); ++i) {        for (int j = 0; j < iteration.getNrOfHiddenStates(); ++j) {                        double sum = Double.NEGATIVE_INFINITY;            for (int t = 0; t < observedSequence.length - 1; ++t) {                double temp = alpha.getQuick(t, i) + Math.log(emissionMatrix.getQuick(j, observedSequence[t + 1])) + beta.getQuick(t + 1, j);                if (temp > Double.NEGATIVE_INFINITY) {                                        sum = temp + Math.log1p(Math.exp(sum - temp));                }            }            transitionMatrix.setQuick(i, j, transitionMatrix.getQuick(i, j) * Math.exp(sum - modelLikelihood));        }    }        for (int i = 0; i < iteration.getNrOfHiddenStates(); ++i) {        for (int j = 0; j < iteration.getNrOfOutputStates(); ++j) {                        double sum = Double.NEGATIVE_INFINITY;            for (int t = 0; t < observedSequence.length; ++t) {                                if (observedSequence[t] == j) {                    double temp = alpha.getQuick(t, i) + beta.getQuick(t, i);                    if (temp > Double.NEGATIVE_INFINITY) {                                                sum = temp + Math.log1p(Math.exp(sum - temp));                    }                }            }            emissionMatrix.setQuick(i, j, Math.exp(sum - modelLikelihood));        }    }}
03f63cd1be5c4648ad018910116e745939ce1c924847d6830b0bffebdfc57c57
checkConvergence
private static boolean checkConvergence(HmmModel oldModel, HmmModel newModel, double epsilon)
{        Matrix oldTransitionMatrix = oldModel.getTransitionMatrix();    Matrix newTransitionMatrix = newModel.getTransitionMatrix();    double diff = 0;    for (int i = 0; i < oldModel.getNrOfHiddenStates(); ++i) {        for (int j = 0; j < oldModel.getNrOfHiddenStates(); ++j) {            double tmp = oldTransitionMatrix.getQuick(i, j) - newTransitionMatrix.getQuick(i, j);            diff += tmp * tmp;        }    }    double norm = Math.sqrt(diff);    diff = 0;        Matrix oldEmissionMatrix = oldModel.getEmissionMatrix();    Matrix newEmissionMatrix = newModel.getEmissionMatrix();    for (int i = 0; i < oldModel.getNrOfHiddenStates(); i++) {        for (int j = 0; j < oldModel.getNrOfOutputStates(); j++) {            double tmp = oldEmissionMatrix.getQuick(i, j) - newEmissionMatrix.getQuick(i, j);            diff += tmp * tmp;        }    }    norm += Math.sqrt(diff);        return norm < epsilon;}
f6669da4e16223f8e8b685629b8d7e2c52c4eba4a063929537f4f32b2603de23
getCumulativeTransitionMatrix
public static Matrix getCumulativeTransitionMatrix(HmmModel model)
{        int hiddenStates = model.getNrOfHiddenStates();    Matrix transitionMatrix = model.getTransitionMatrix();        Matrix resultMatrix = new DenseMatrix(hiddenStates, hiddenStates);    for (int i = 0; i < hiddenStates; ++i) {        double sum = 0;        for (int j = 0; j < hiddenStates; ++j) {            sum += transitionMatrix.get(i, j);            resultMatrix.set(i, j, sum);        }        resultMatrix.set(i, hiddenStates - 1, 1.0);                        }    return resultMatrix;}
66dec01269abeecf73a84b6f46ee587345291526892b38c712a26aa8704cf80a
getCumulativeOutputMatrix
public static Matrix getCumulativeOutputMatrix(HmmModel model)
{        int hiddenStates = model.getNrOfHiddenStates();    int outputStates = model.getNrOfOutputStates();    Matrix outputMatrix = model.getEmissionMatrix();        Matrix resultMatrix = new DenseMatrix(hiddenStates, outputStates);    for (int i = 0; i < hiddenStates; ++i) {        double sum = 0;        for (int j = 0; j < outputStates; ++j) {            sum += outputMatrix.get(i, j);            resultMatrix.set(i, j, sum);        }        resultMatrix.set(i, outputStates - 1, 1.0);                    }    return resultMatrix;}
2a4d1052aa79cfcbec0d47178e7d5555ed7a3f9329a777c8dcd906161edd8626
getCumulativeInitialProbabilities
public static Vector getCumulativeInitialProbabilities(HmmModel model)
{        int hiddenStates = model.getNrOfHiddenStates();    Vector initialProbabilities = model.getInitialProbabilities();        Vector resultVector = new DenseVector(initialProbabilities.size());    double sum = 0;    for (int i = 0; i < hiddenStates; ++i) {        sum += initialProbabilities.get(i);        resultVector.set(i, sum);    }        resultVector.set(hiddenStates - 1, 1.0);        return resultVector;}
cb2db6a9c91f946a78fc1824384a9a26b41f7503c422bfaea299a98c607cfd22
validate
public static void validate(HmmModel model)
{    if (model == null) {                return;    }    /*     * The number of hidden states is positive.     */    Preconditions.checkArgument(model.getNrOfHiddenStates() > 0, "Error: The number of hidden states has to be greater than 0");    /*     * The number of output states is positive.     */    Preconditions.checkArgument(model.getNrOfOutputStates() > 0, "Error: The number of output states has to be greater than 0!");    /*     * The size of the vector of initial probabilities is equal to the number of     * the hidden states. Each initial probability is non-negative. The sum of     * initial probabilities is equal to 1.     */    Preconditions.checkArgument(model.getInitialProbabilities() != null && model.getInitialProbabilities().size() == model.getNrOfHiddenStates(), "Error: The vector of initial probabilities is not initialized!");    double sum = 0;    for (int i = 0; i < model.getInitialProbabilities().size(); i++) {        Preconditions.checkArgument(model.getInitialProbabilities().get(i) >= 0, "Error: Initial probability of state %d is negative", i);        sum += model.getInitialProbabilities().get(i);    }    Preconditions.checkArgument(Math.abs(sum - 1) <= 0.00001, "Error: Initial probabilities do not add up to 1");    /*     * The row size of the output matrix is equal to the number of the hidden     * states. The column size is equal to the number of output states. Each     * probability of the matrix is non-negative. The sum of each row is equal     * to 1.     */    Preconditions.checkNotNull(model.getEmissionMatrix(), "Error: The output state matrix is not initialized!");    Preconditions.checkArgument(model.getEmissionMatrix().numRows() == model.getNrOfHiddenStates() && model.getEmissionMatrix().numCols() == model.getNrOfOutputStates(), "Error: The output state matrix is not of the form nrOfHiddenStates x nrOfOutputStates");    for (int i = 0; i < model.getEmissionMatrix().numRows(); i++) {        sum = 0;        for (int j = 0; j < model.getEmissionMatrix().numCols(); j++) {            Preconditions.checkArgument(model.getEmissionMatrix().get(i, j) >= 0, "The output state probability from hidden state " + i + " to output state " + j + " is negative");            sum += model.getEmissionMatrix().get(i, j);        }        Preconditions.checkArgument(Math.abs(sum - 1) <= 0.00001, "Error: The output state probabilities for hidden state %d don't add up to 1", i);    }    /*     * The size of both dimension of the transition matrix is equal to the     * number of the hidden states. Each probability of the matrix is     * non-negative. The sum of each row in transition matrix is equal to 1.     */    Preconditions.checkArgument(model.getTransitionMatrix() != null, "Error: The hidden state matrix is not initialized!");    Preconditions.checkArgument(model.getTransitionMatrix().numRows() == model.getNrOfHiddenStates() && model.getTransitionMatrix().numCols() == model.getNrOfHiddenStates(), "Error: The output state matrix is not of the form nrOfHiddenStates x nrOfHiddenStates");    for (int i = 0; i < model.getTransitionMatrix().numRows(); i++) {        sum = 0;        for (int j = 0; j < model.getTransitionMatrix().numCols(); j++) {            Preconditions.checkArgument(model.getTransitionMatrix().get(i, j) >= 0, "Error: The transition probability from hidden state %d to hidden state %d is negative", i, j);            sum += model.getTransitionMatrix().get(i, j);        }        Preconditions.checkArgument(Math.abs(sum - 1) <= 0.00001, "Error: The transition probabilities for hidden state " + i + " don't add up to 1.");    }}
9158393f035367546d70b817446cc87c75330c3e467aa4799bd112a80cef459b
encodeStateSequence
public static int[] encodeStateSequence(HmmModel model, Collection<String> sequence, boolean observed, int defaultValue)
{    int[] encoded = new int[sequence.size()];    Iterator<String> seqIter = sequence.iterator();    for (int i = 0; i < sequence.size(); ++i) {        String nextState = seqIter.next();        int nextID;        if (observed) {            nextID = model.getOutputStateID(nextState);        } else {            nextID = model.getHiddenStateID(nextState);        }                encoded[i] = nextID < 0 ? defaultValue : nextID;    }    return encoded;}
947df022ef01e6f3510b8a7c583a40a5f99aff6f8a3c1c2d735be3495f11ce37
decodeStateSequence
public static List<String> decodeStateSequence(HmmModel model, int[] sequence, boolean observed, String defaultValue)
{    List<String> decoded = new ArrayList<>(sequence.length);    for (int position : sequence) {        String nextState;        if (observed) {            nextState = model.getOutputStateName(position);        } else {            nextState = model.getHiddenStateName(position);        }                decoded.add(nextState == null ? defaultValue : nextState);    }    return decoded;}
91022c05aa7eff7c245ea5fbe2668489c79be63ceac80f77d8733635833027ec
normalizeModel
public static void normalizeModel(HmmModel model)
{    Vector ip = model.getInitialProbabilities();    Matrix emission = model.getEmissionMatrix();    Matrix transition = model.getTransitionMatrix();        double isum = 0;    for (int i = 0; i < model.getNrOfHiddenStates(); ++i) {        isum += ip.getQuick(i);        double sum = 0;        for (int j = 0; j < model.getNrOfHiddenStates(); ++j) {            sum += transition.getQuick(i, j);        }        if (sum != 1.0) {            for (int j = 0; j < model.getNrOfHiddenStates(); ++j) {                transition.setQuick(i, j, transition.getQuick(i, j) / sum);            }        }        sum = 0;        for (int j = 0; j < model.getNrOfOutputStates(); ++j) {            sum += emission.getQuick(i, j);        }        if (sum != 1.0) {            for (int j = 0; j < model.getNrOfOutputStates(); ++j) {                emission.setQuick(i, j, emission.getQuick(i, j) / sum);            }        }    }    if (isum != 1.0) {        for (int i = 0; i < model.getNrOfHiddenStates(); ++i) {            ip.setQuick(i, ip.getQuick(i) / isum);        }    }}
3d93ffc4e474a9dd1c710335604dc32035c8067ea64780ec30ea519bce02e1de
truncateModel
public static HmmModel truncateModel(HmmModel model, double threshold)
{    Vector ip = model.getInitialProbabilities();    Matrix em = model.getEmissionMatrix();    Matrix tr = model.getTransitionMatrix();        RandomAccessSparseVector sparseIp = new RandomAccessSparseVector(model.getNrOfHiddenStates());    SparseMatrix sparseEm = new SparseMatrix(model.getNrOfHiddenStates(), model.getNrOfOutputStates());    SparseMatrix sparseTr = new SparseMatrix(model.getNrOfHiddenStates(), model.getNrOfHiddenStates());        for (int i = 0; i < model.getNrOfHiddenStates(); ++i) {        double value = ip.getQuick(i);        if (value > threshold) {            sparseIp.setQuick(i, value);        }        for (int j = 0; j < model.getNrOfHiddenStates(); ++j) {            value = tr.getQuick(i, j);            if (value > threshold) {                sparseTr.setQuick(i, j, value);            }        }        for (int j = 0; j < model.getNrOfOutputStates(); ++j) {            value = em.getQuick(i, j);            if (value > threshold) {                sparseEm.setQuick(i, j, value);            }        }    }        HmmModel sparseModel = new HmmModel(sparseTr, sparseEm, sparseIp);        normalizeModel(sparseModel);        sparseModel.registerHiddenStateNames(model.getHiddenStateNames());    sparseModel.registerOutputStateNames(model.getOutputStateNames());        return sparseModel;}
333791777f991a62222514ed3f55fdee0a79be9511ea411c0c48cc126f574021
serialize
 static void serialize(HmmModel model, DataOutput output) throws IOException
{    MatrixWritable matrix = new MatrixWritable(model.getEmissionMatrix());    matrix.write(output);    matrix.set(model.getTransitionMatrix());    matrix.write(output);    VectorWritable vector = new VectorWritable(model.getInitialProbabilities());    vector.write(output);}
f177d035ccf72848df9e40036db9a89ff1152483c649945e903ad1e6c12b0f04
deserialize
 static HmmModel deserialize(DataInput input) throws IOException
{    MatrixWritable matrix = new MatrixWritable();    matrix.readFields(input);    Matrix emissionMatrix = matrix.get();    matrix.readFields(input);    Matrix transitionMatrix = matrix.get();    VectorWritable vector = new VectorWritable();    vector.readFields(input);    Vector initialProbabilities = vector.get();    return new HmmModel(transitionMatrix, emissionMatrix, initialProbabilities);}
365a24fc75086b6a0e91f9b072bd58c9280846cc05f333f28ede18388f27ce89
main
public static void main(String[] args) throws IOException
{    DefaultOptionBuilder optionBuilder = new DefaultOptionBuilder();    ArgumentBuilder argumentBuilder = new ArgumentBuilder();    Option outputOption = optionBuilder.withLongName("output").withDescription("Output file with sequence of observed states").withShortName("o").withArgument(argumentBuilder.withMaximum(1).withMinimum(1).withName("path").create()).withRequired(false).create();    Option modelOption = optionBuilder.withLongName("model").withDescription("Path to serialized HMM model").withShortName("m").withArgument(argumentBuilder.withMaximum(1).withMinimum(1).withName("path").create()).withRequired(true).create();    Option lengthOption = optionBuilder.withLongName("length").withDescription("Length of generated sequence").withShortName("l").withArgument(argumentBuilder.withMaximum(1).withMinimum(1).withName("number").create()).withRequired(true).create();    Group optionGroup = new GroupBuilder().withOption(outputOption).withOption(modelOption).withOption(lengthOption).withName("Options").create();    try {        Parser parser = new Parser();        parser.setGroup(optionGroup);        CommandLine commandLine = parser.parse(args);        String output = (String) commandLine.getValue(outputOption);        String modelPath = (String) commandLine.getValue(modelOption);        int length = Integer.parseInt((String) commandLine.getValue(lengthOption));                HmmModel model;        try (DataInputStream modelStream = new DataInputStream(new FileInputStream(modelPath))) {            model = LossyHmmSerializer.deserialize(modelStream);        }                int[] observations = HmmEvaluator.predict(model, length, System.currentTimeMillis());                try (PrintWriter writer = new PrintWriter(new OutputStreamWriter(new FileOutputStream(output), Charsets.UTF_8), true)) {            for (int observation : observations) {                writer.print(observation);                writer.print(' ');            }        }    } catch (OptionException e) {        CommandLineUtil.printHelp(optionGroup);    }}
365a24fc75086b6a0e91f9b072bd58c9280846cc05f333f28ede18388f27ce89
main
public static void main(String[] args) throws IOException
{    DefaultOptionBuilder optionBuilder = new DefaultOptionBuilder();    ArgumentBuilder argumentBuilder = new ArgumentBuilder();    Option inputOption = DefaultOptionCreator.inputOption().create();    Option outputOption = DefaultOptionCreator.outputOption().create();    Option modelOption = optionBuilder.withLongName("model").withDescription("Path to serialized HMM model").withShortName("m").withArgument(argumentBuilder.withMaximum(1).withMinimum(1).withName("path").create()).withRequired(true).create();    Option likelihoodOption = optionBuilder.withLongName("likelihood").withDescription("Compute likelihood of observed sequence").withShortName("l").withRequired(false).create();    Group optionGroup = new GroupBuilder().withOption(inputOption).withOption(outputOption).withOption(modelOption).withOption(likelihoodOption).withName("Options").create();    try {        Parser parser = new Parser();        parser.setGroup(optionGroup);        CommandLine commandLine = parser.parse(args);        String input = (String) commandLine.getValue(inputOption);        String output = (String) commandLine.getValue(outputOption);        String modelPath = (String) commandLine.getValue(modelOption);        boolean computeLikelihood = commandLine.hasOption(likelihoodOption);                ;        HmmModel model;        try (DataInputStream modelStream = new DataInputStream(new FileInputStream(modelPath))) {            model = LossyHmmSerializer.deserialize(modelStream);        }                List<Integer> observations = new ArrayList<>();        try (Scanner scanner = new Scanner(new FileInputStream(input), "UTF-8")) {            while (scanner.hasNextInt()) {                observations.add(scanner.nextInt());            }        }        int[] observationsArray = new int[observations.size()];        for (int i = 0; i < observations.size(); ++i) {            observationsArray[i] = observations.get(i);        }                int[] hiddenStates = HmmEvaluator.decode(model, observationsArray, true);                try (PrintWriter writer = new PrintWriter(new OutputStreamWriter(new FileOutputStream(output), Charsets.UTF_8), true)) {            for (int hiddenState : hiddenStates) {                writer.print(hiddenState);                writer.print(' ');            }        }        if (computeLikelihood) {            System.out.println("Likelihood: " + HmmEvaluator.modelLikelihood(model, observationsArray, true));        }    } catch (OptionException e) {        CommandLineUtil.printHelp(optionGroup);    }}
16c578c7011e212992ccca63948a4ca0b18dcf22151e6066e71e699d21a9b913
lambda
public AbstractOnlineLogisticRegression lambda(double lambda)
{    this.lambda = lambda;    return this;}
08994b5ab9e6f060b10cda023279fcff79537419cacc250a59ebf61fc18a8496
link
public static Vector link(Vector v)
{    double max = v.maxValue();    if (max >= 40) {                        v.assign(Functions.minus(max)).assign(Functions.EXP);        return v.divide(v.norm(1));    } else {        v.assign(Functions.EXP);        return v.divide(1 + v.norm(1));    }}
dd04c416d8feebd2d4a390ee73bcfec5a263769c6e09db5913b4470348c503af
link
public static double link(double r)
{    if (r < 0.0) {        double s = Math.exp(r);        return s / (1.0 + s);    } else {        double s = Math.exp(-r);        return 1.0 / (1.0 + s);    }}
2db9aca8fa7eeaf8a8a3c2d7ec4cec1865a582b31266699ab89f98d6ec702fbe
classifyNoLink
public Vector classifyNoLink(Vector instance)
{        regularize(instance);    return beta.times(instance);}
662c8a37fa1973febaa9497288a58b4718cfb281a9998084059347a5121fee67
classifyScalarNoLink
public double classifyScalarNoLink(Vector instance)
{    return beta.viewRow(0).dot(instance);}
a65d353603d9c6fa69fa946675f753b9e8fcbd94f8ccaeab6425adab7d1af7ba
classify
public Vector classify(Vector instance)
{    return link(classifyNoLink(instance));}
26ad6f4b0cd93ee65196cb117ed56b25c67c201f8283b12a24dbe4c622a5a362
classifyScalar
public double classifyScalar(Vector instance)
{    Preconditions.checkArgument(numCategories() == 2, "Can only call classifyScalar with two categories");        regularize(instance);        return link(classifyScalarNoLink(instance));}
9d4edf7bd694e762788702e48c71d41d687d0473faa8bf5c051f3c74621df2dc
train
public void train(long trackingKey, String groupKey, int actual, Vector instance)
{    unseal();    double learningRate = currentLearningRate();        regularize(instance);        Vector gradient = this.gradient.apply(groupKey, actual, instance, this);    for (int i = 0; i < numCategories - 1; i++) {        double gradientBase = gradient.get(i);                for (Element updateLocation : instance.nonZeroes()) {            int j = updateLocation.index();            double newValue = beta.getQuick(i, j) + gradientBase * learningRate * perTermLearningRate(j) * instance.get(j);            beta.setQuick(i, j, newValue);        }    }        for (Element element : instance.nonZeroes()) {        int j = element.index();        updateSteps.setQuick(j, getStep());        updateCounts.incrementQuick(j, 1);    }    nextStep();}
4b559a17ddb4da56ecccbda13ac676e16b4711323497a0ebddd40395eef13b96
train
public void train(long trackingKey, int actual, Vector instance)
{    train(trackingKey, null, actual, instance);}
ecc6f64b0a839651cb9eb6f6925f645a77e15f44cd48611cfa9da8168f00ff18
train
public void train(int actual, Vector instance)
{    train(0, null, actual, instance);}
a8162a92a1a056e32d09313d58f69de1c809f2b4f08252883bf09fa6eabdc74e
regularize
public void regularize(Vector instance)
{    if (updateSteps == null || isSealed()) {        return;    }        double learningRate = currentLearningRate();        for (int i = 0; i < numCategories - 1; i++) {        for (Element updateLocation : instance.nonZeroes()) {            int j = updateLocation.index();            double missingUpdates = getStep() - updateSteps.get(j);            if (missingUpdates > 0) {                double rate = getLambda() * learningRate * perTermLearningRate(j);                double newValue = prior.age(beta.get(i, j), missingUpdates, rate);                beta.set(i, j, newValue);                updateSteps.set(j, getStep());            }        }    }}
35473afe26f1f578df4bd2ad27cb12a98ec7ee3c2265302a3700146d030b035a
setPrior
public void setPrior(PriorFunction prior)
{    this.prior = prior;}
e717ab27fb47fccb6dc33b06081a4021ffca87fb3bda7f14379a7be6310da2f6
setGradient
public void setGradient(Gradient gradient)
{    this.gradient = gradient;}
913a93724ce1124485df8d25baec07c55b83f55e1a2d6b257c84bacea829dcea
getPrior
public PriorFunction getPrior()
{    return prior;}
a98790bb538acf2101225a789cbf6e2657ed742942fc62b97fb0778967a2a8ff
getBeta
public Matrix getBeta()
{    close();    return beta;}
6bfeaf6985e466354fdd49ecf3ca611212f342f6856ff73f25bdfb8656b4aae6
setBeta
public void setBeta(int i, int j, double betaIJ)
{    beta.set(i, j, betaIJ);}
0bdeb79fe74c02804b0b53b9a99db42b7e41e4a28e6e703c32648791e7032088
numCategories
public int numCategories()
{    return numCategories;}
e5a3cd58a1672c77f7fc460a19f0294e3e9cfaa65394aec1fa2e316fe4065a33
numFeatures
public int numFeatures()
{    return beta.numCols();}
f106e2c7f9c824d32f6f7400c6bb6ef6acbfcf9eb0d8de72ba64d97e83466cbc
getLambda
public double getLambda()
{    return lambda;}
1155f7a7c8c942e53f5a5b594b7cb754c488a16c5eea10c49f4462cdbc1bcecf
getStep
public int getStep()
{    return step;}
1c5ef2fff754198ec6cc3a617905e8fb00e35bda8c8207176d6d40ac7d736005
nextStep
protected void nextStep()
{    step++;}
951bcafea8bc34a3b050f886e1b587f7ee84aab8dfa10133a302f457fea31dba
isSealed
public boolean isSealed()
{    return sealed;}
78bedc3e4d7043641f39ab0e8513927c7c387cda506b5cb8b297d7b022d3cf55
unseal
protected void unseal()
{    sealed = false;}
d93e62866fb3f265d4947c2831350fbac35b7dec6a46076c9e524137511dbb6c
regularizeAll
private void regularizeAll()
{    Vector all = new DenseVector(beta.numCols());    all.assign(1);    regularize(all);}
5df6118bc0e745d8b18e0a6a99b2e3f2ddba8140cbeb1423ce2df50a9f140574
close
public void close()
{    if (!sealed) {        step++;        regularizeAll();        sealed = true;    }}
69407a7fe48704df913c189eb96dc4594eaa0cf4ccda85e638ba3f39da88fe9e
copyFrom
public void copyFrom(AbstractOnlineLogisticRegression other)
{        Preconditions.checkArgument(numCategories == other.numCategories, "Can't copy unless number of target categories is the same");    beta.assign(other.beta);    step = other.step;    updateSteps.assign(other.updateSteps);    updateCounts.assign(other.updateCounts);}
4918b4274be08205d5497f20edf2ee39225b5393111844fce47eaa9ea393173a
validModel
public boolean validModel()
{    double k = beta.aggregate(Functions.PLUS, new DoubleFunction() {        @Override        public double apply(double v) {            return Double.isNaN(v) || Double.isInfinite(v) ? 1 : 0;        }    });    return k < 1;}
0b41a4c0ac574be18fedcf88e7465eddcb1f8f1a3ad9bbb36e6b37f373bd3830
apply
public double apply(double v)
{    return Double.isNaN(v) || Double.isInfinite(v) ? 1 : 0;}
ecc6f64b0a839651cb9eb6f6925f645a77e15f44cd48611cfa9da8168f00ff18
train
public void train(int actual, Vector instance)
{    train(record, null, actual, instance);}
4b559a17ddb4da56ecccbda13ac676e16b4711323497a0ebddd40395eef13b96
train
public void train(long trackingKey, int actual, Vector instance)
{    train(trackingKey, null, actual, instance);}
9d4edf7bd694e762788702e48c71d41d687d0473faa8bf5c051f3c74621df2dc
train
public void train(long trackingKey, String groupKey, int actual, Vector instance)
{    record++;    buffer.add(new TrainingExample(trackingKey, groupKey, actual, instance));        if (buffer.size() > bufferSize) {        trainWithBufferedExamples();    }}
de9b63ce18b80dd8b71df7f6b16cd16a58f093409877c487b6d9bc835ec04b68
trainWithBufferedExamples
private void trainWithBufferedExamples()
{    try {        this.best = ep.parallelDo(new EvolutionaryProcess.Function<Payload<CrossFoldLearner>>() {            @Override            public double apply(Payload<CrossFoldLearner> z, double[] params) {                Wrapper x = (Wrapper) z;                for (TrainingExample example : buffer) {                    x.train(example);                }                if (x.getLearner().validModel()) {                    if (x.getLearner().numCategories() == 2) {                        return x.wrapped.auc();                    } else {                        return x.wrapped.logLikelihood();                    }                } else {                    return Double.NaN;                }            }        });    } catch (InterruptedException e) {                log.warn("Ignoring exception", e);    } catch (ExecutionException e) {        throw new IllegalStateException(e.getCause());    }    buffer.clear();    if (record > cutoff) {        cutoff = nextStep(record);                ep.mutatePopulation(SURVIVORS);        if (freezeSurvivors) {                        for (State<Wrapper, CrossFoldLearner> state : ep.getPopulation().subList(0, SURVIVORS)) {                Wrapper.freeze(state);            }        }    }}
c25c4c56e59554d47765c05f55717578d1d64381c156a7ee16282cf1f53f35a3
apply
public double apply(Payload<CrossFoldLearner> z, double[] params)
{    Wrapper x = (Wrapper) z;    for (TrainingExample example : buffer) {        x.train(example);    }    if (x.getLearner().validModel()) {        if (x.getLearner().numCategories() == 2) {            return x.wrapped.auc();        } else {            return x.wrapped.logLikelihood();        }    } else {        return Double.NaN;    }}
7b89da893fd9cc496d97b0f53d269105fd1f2b112d078def2bfb5ca6a7674bec
nextStep
public int nextStep(int recordNumber)
{    int stepSize = stepSize(recordNumber, 2.6);    if (stepSize < minInterval) {        stepSize = minInterval;    }    if (stepSize > maxInterval) {        stepSize = maxInterval;    }    int newCutoff = stepSize * (recordNumber / stepSize + 1);    if (newCutoff < cutoff + currentStep) {        newCutoff = cutoff + currentStep;    } else {        this.currentStep = stepSize;    }    return newCutoff;}
88c2049247876c35957fb48cb7e908c9db0eb332cdba68db675437d81ff84317
stepSize
public static int stepSize(int recordNumber, double multiplier)
{    int[] bumps = { 1, 2, 5 };    double log = Math.floor(multiplier * Math.log10(recordNumber));    int bump = bumps[(int) log % bumps.length];    int scale = (int) Math.pow(10, Math.floor(log / bumps.length));    return bump * scale;}
5df6118bc0e745d8b18e0a6a99b2e3f2ddba8140cbeb1423ce2df50a9f140574
close
public void close()
{    trainWithBufferedExamples();    try {        ep.parallelDo(new EvolutionaryProcess.Function<Payload<CrossFoldLearner>>() {            @Override            public double apply(Payload<CrossFoldLearner> payload, double[] params) {                CrossFoldLearner learner = ((Wrapper) payload).getLearner();                learner.close();                return learner.logLikelihood();            }        });    } catch (InterruptedException e) {        log.warn("Ignoring exception", e);    } catch (ExecutionException e) {        throw new IllegalStateException(e);    } finally {        ep.close();    }}
5c06210ec4e6a238390c32fa2bbac0ddf667d9013881b643de3999c0283834e2
apply
public double apply(Payload<CrossFoldLearner> payload, double[] params)
{    CrossFoldLearner learner = ((Wrapper) payload).getLearner();    learner.close();    return learner.logLikelihood();}
9579b56c7644137bbda5c94915f31a005e8173fa7390d9a698381a96abbab494
setInterval
public void setInterval(int interval)
{    setInterval(interval, interval);}
024b784bd860b8937790830265bed9a32e1abfd1b4e3e7a3cd2016e20314ed5a
setInterval
public void setInterval(int minInterval, int maxInterval)
{    this.minInterval = Math.max(200, minInterval);    this.maxInterval = Math.max(200, maxInterval);    this.cutoff = minInterval * (record / minInterval + 1);    this.currentStep = minInterval;    bufferSize = Math.min(minInterval, bufferSize);}
c45d3a13bc3e9d6f7d78cd8ff8439099af2e4257fc23dcd2bb4a8cd0c2028337
setPoolSize
public final void setPoolSize(int poolSize)
{    this.poolSize = poolSize;    setupOptimizer(poolSize);}
ec8febfef1b6924b8bae754a6d6a581e2abee70302b9d6f512585cfc42907429
setThreadCount
public void setThreadCount(int threadCount)
{    this.threadCount = threadCount;    setupOptimizer(poolSize);}
5cd935a208713f9adff2e53e62da79b0b050388d136de2e20403d89a45e7b998
setAucEvaluator
public void setAucEvaluator(OnlineAuc auc)
{    seed.getPayload().setAucEvaluator(auc);    setupOptimizer(poolSize);}
5146e3420699d31ef7b4afda25f6704124d1d0527e1c93e6f537e210419dfbea
setupOptimizer
private void setupOptimizer(int poolSize)
{    ep = new EvolutionaryProcess<>(threadCount, poolSize, seed);}
e5a3cd58a1672c77f7fc460a19f0294e3e9cfaa65394aec1fa2e316fe4065a33
numFeatures
public int numFeatures()
{    return numFeatures;}
b7b9278dce78d03ffa978e3c2e0e40fd1430be1af8a105ca11d28be7d3a4d960
auc
public double auc()
{    if (best == null) {        return Double.NaN;    } else {        Wrapper payload = best.getPayload();        return payload.getLearner().auc();    }}
73bcac9f5ed5bb35229520fdf9dd1ef8d18d825adf8e1475bf9d63fad716fec2
getBest
public State<Wrapper, CrossFoldLearner> getBest()
{    return best;}
c8ee3994a92b4a99b0eaf4f89f72b4727e70dc88e92943a677bb7a24974164e6
setBest
public void setBest(State<Wrapper, CrossFoldLearner> best)
{    this.best = best;}
25ffba61a8b5a713bfc4bda75cb12cf549a4ffc36871699cfc782802bca87792
getRecord
public int getRecord()
{    return record;}
90741e5f491fba40c3faa7d87edefdc4e2b64c6efe8ca3ddac8aad707bd24dde
setRecord
public void setRecord(int record)
{    this.record = record;}
3b53a20314ce87e5f9cc54c4b048f40ab0f8e29ff0ab3cf4d9677568a82e0ffd
getMinInterval
public int getMinInterval()
{    return minInterval;}
9f7fab8762386f19dd8c0f5d4d73947acd03acad3a8bb210d9175b3210e91b73
getMaxInterval
public int getMaxInterval()
{    return maxInterval;}
172725178e9cd76ff76e10b3f1e587e346dc24d31cf8d743af5d2e24b4d0a973
getNumCategories
public int getNumCategories()
{    return seed.getPayload().getLearner().numCategories();}
913a93724ce1124485df8d25baec07c55b83f55e1a2d6b257c84bacea829dcea
getPrior
public PriorFunction getPrior()
{    return seed.getPayload().getLearner().getPrior();}
7270e624715a8f9bdf7f2b3b7e96a6464cf48406d80daaa17f0881a3a25d1622
setBuffer
public void setBuffer(List<TrainingExample> buffer)
{    this.buffer = buffer;}
3fdd08614ef27643d1e01a332008d48e9020235664ad299c27ace8e426316ab8
getBuffer
public List<TrainingExample> getBuffer()
{    return buffer;}
08934574ee1d17769c217f61e08ca25d40ce8eb0513d059c1e05856b6d1b986b
getEp
public EvolutionaryProcess<Wrapper, CrossFoldLearner> getEp()
{    return ep;}
dcd1a6fdbc73bf68645028f5cc48d669bac29a7785545b8e4adfeeed9b387a62
setEp
public void setEp(EvolutionaryProcess<Wrapper, CrossFoldLearner> ep)
{    this.ep = ep;}
bf67c9dabe142d5d06d22ae34bd5d800fed602d780cc3243f0682e0c701904e0
getSeed
public State<Wrapper, CrossFoldLearner> getSeed()
{    return seed;}
667d68cc4ee1950867dbfcffc64735909b4de1c5f6b9719a9a65c574b88ab504
setSeed
public void setSeed(State<Wrapper, CrossFoldLearner> seed)
{    this.seed = seed;}
4a142c3e7355f05c01931684dab7c3e5fbdf3a15cc9c0bfd751d8a0429c7a23e
getNumFeatures
public int getNumFeatures()
{    return numFeatures;}
29bd30669997e35f0c5b95b3b387cb4a5bc46397281328bc672aafd36db22150
setAveragingWindow
public void setAveragingWindow(int averagingWindow)
{    seed.getPayload().getLearner().setWindowSize(averagingWindow);    setupOptimizer(poolSize);}
689220e6a8b5683b9702b5ec6a6b0ccd14aca838a186cb76bddc258f71528e3f
setFreezeSurvivors
public void setFreezeSurvivors(boolean freezeSurvivors)
{    this.freezeSurvivors = freezeSurvivors;}
c716dfb48968b67f101ef67a88686878e78bf5a3ecc224aa89d50a8244b3ba31
copy
public Wrapper copy()
{    Wrapper r = new Wrapper();    r.wrapped = wrapped.copy();    return r;}
1ed1a8f5f6c2d9d765096fc3a9c1471dbecef8f9daa3fb1fe074481a6c9992b4
update
public void update(double[] params)
{    int i = 0;    wrapped.lambda(params[i++]);    wrapped.learningRate(params[i]);    wrapped.stepOffset(1);    wrapped.alpha(1);    wrapped.decayExponent(0);}
6e27cd9c341f01772b0a5f16217df0a63e84f5f65a223b1315d030b63887ecb6
freeze
public static void freeze(State<Wrapper, CrossFoldLearner> s)
{        double[] params = s.getParams();    params[1] -= 10;        s.setOmni(s.getOmni() / 20);    double[] step = s.getStep();    for (int i = 0; i < step.length; i++) {        step[i] /= 20;    }}
c21ab0d4ac871f63a5a6115bdeb734696b20a488af178849f4effc9e20f2d0c5
setMappings
public static void setMappings(State<Wrapper, CrossFoldLearner> x)
{    int i = 0;        x.setMap(i++, Mapping.logLimit(1.0e-8, 0.1));        x.setMap(i, Mapping.logLimit(1.0e-8, 1));}
fbf9e82a567ec18b327d2c2ca8d094947ef908785063cfc7fe0a7193ac2b10d4
train
public void train(TrainingExample example)
{    wrapped.train(example.getKey(), example.getGroupKey(), example.getActual(), example.getInstance());}
0f04acd48ca2d4bfdd6204799c57c2d4fe6d35240c6bdbd72fe13000fa544d5c
getLearner
public CrossFoldLearner getLearner()
{    return wrapped;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return String.format(Locale.ENGLISH, "auc=%.2f", wrapped.auc());}
5cd935a208713f9adff2e53e62da79b0b050388d136de2e20403d89a45e7b998
setAucEvaluator
public void setAucEvaluator(OnlineAuc auc)
{    wrapped.setAucEvaluator(auc);}
a894510dd4db439ff8e17ae1059489dc3abc97178e5932ceed0c70c3af165401
write
public void write(DataOutput out) throws IOException
{    wrapped.write(out);}
4529dacced0bb2cd63ef71d2039f49f0abb0523ab627a4bd0828ea7a38fadaf8
readFields
public void readFields(DataInput input) throws IOException
{    wrapped = new CrossFoldLearner();    wrapped.readFields(input);}
50f8ed3846a14d4f2fca008cad611c60628b1c04dec6eb5eef6a89ce2499fef8
getKey
public long getKey()
{    return key;}
cb30b88ac14304eff92be3d5d9cf76c0b4c3660e2bae51230b200868762a0028
getActual
public int getActual()
{    return actual;}
2ec57932728e5ebb2993d48439bde07fcc7dabc64c78365f4ec07200fdc1d7fb
getInstance
public Vector getInstance()
{    return instance;}
6b653a5b7322f12b3c8cbeb7110b2e255bed08a563f7c649b159691e6071ed61
getGroupKey
public String getGroupKey()
{    return groupKey;}
a894510dd4db439ff8e17ae1059489dc3abc97178e5932ceed0c70c3af165401
write
public void write(DataOutput out) throws IOException
{    out.writeLong(key);    if (groupKey != null) {        out.writeBoolean(true);        out.writeUTF(groupKey);    } else {        out.writeBoolean(false);    }    out.writeInt(actual);    VectorWritable.writeVector(out, instance, true);}
5478cc5683f6dfd4515c383752d7c803555efc63d03fd84a03ba8dcd17eb4324
readFields
public void readFields(DataInput in) throws IOException
{    key = in.readLong();    if (in.readBoolean()) {        groupKey = in.readUTF();    }    actual = in.readInt();    instance = VectorWritable.readVector(in);}
a894510dd4db439ff8e17ae1059489dc3abc97178e5932ceed0c70c3af165401
write
public void write(DataOutput out) throws IOException
{    out.writeInt(record);    out.writeInt(cutoff);    out.writeInt(minInterval);    out.writeInt(maxInterval);    out.writeInt(currentStep);    out.writeInt(bufferSize);    out.writeInt(buffer.size());    for (TrainingExample example : buffer) {        example.write(out);    }    ep.write(out);    best.write(out);    out.writeInt(threadCount);    out.writeInt(poolSize);    seed.write(out);    out.writeInt(numFeatures);    out.writeBoolean(freezeSurvivors);}
5478cc5683f6dfd4515c383752d7c803555efc63d03fd84a03ba8dcd17eb4324
readFields
public void readFields(DataInput in) throws IOException
{    record = in.readInt();    cutoff = in.readInt();    minInterval = in.readInt();    maxInterval = in.readInt();    currentStep = in.readInt();    bufferSize = in.readInt();    int n = in.readInt();    buffer = new ArrayList<>();    for (int i = 0; i < n; i++) {        TrainingExample example = new TrainingExample();        example.readFields(in);        buffer.add(example);    }    ep = new EvolutionaryProcess<>();    ep.readFields(in);    best = new State<>();    best.readFields(in);    threadCount = in.readInt();    poolSize = in.readInt();    seed = new State<>();    seed.readFields(in);    numFeatures = in.readInt();    freezeSurvivors = in.readBoolean();}
b957fe7a71ba7c31914bea12273807d3b1bec5f073030fc0f74fd8370de971bd
lambda
public CrossFoldLearner lambda(double v)
{    for (OnlineLogisticRegression model : models) {        model.lambda(v);    }    return this;}
bc76b38a1979c6e1d59a790b2183fbc35ee462fb6c4e744e58f6ef64da6d4cc7
learningRate
public CrossFoldLearner learningRate(double x)
{    for (OnlineLogisticRegression model : models) {        model.learningRate(x);    }    return this;}
5fb847132d927fe5728d18229715f84fda0087ee1d90f34e2b7181c9b6f4ee5b
stepOffset
public CrossFoldLearner stepOffset(int x)
{    for (OnlineLogisticRegression model : models) {        model.stepOffset(x);    }    return this;}
1055f18e843a6eeb83f6d9c84ada80ba9ea91091811d13cdd893220c6d7ff2ce
decayExponent
public CrossFoldLearner decayExponent(double x)
{    for (OnlineLogisticRegression model : models) {        model.decayExponent(x);    }    return this;}
4aff263cf4b43f32b1d5d6d58134a012d012873996658fc9ce16f44ba757361f
alpha
public CrossFoldLearner alpha(double alpha)
{    for (OnlineLogisticRegression model : models) {        model.alpha(alpha);    }    return this;}
ecc6f64b0a839651cb9eb6f6925f645a77e15f44cd48611cfa9da8168f00ff18
train
public void train(int actual, Vector instance)
{    train(record, null, actual, instance);}
4b559a17ddb4da56ecccbda13ac676e16b4711323497a0ebddd40395eef13b96
train
public void train(long trackingKey, int actual, Vector instance)
{    train(trackingKey, null, actual, instance);}
9d4edf7bd694e762788702e48c71d41d687d0473faa8bf5c051f3c74621df2dc
train
public void train(long trackingKey, String groupKey, int actual, Vector instance)
{    record++;    int k = 0;    for (OnlineLogisticRegression model : models) {        if (k == mod(trackingKey, models.size())) {            Vector v = model.classifyFull(instance);            double score = Math.max(v.get(actual), MIN_SCORE);            logLikelihood += (Math.log(score) - logLikelihood) / Math.min(record, windowSize);            int correct = v.maxValueIndex() == actual ? 1 : 0;            percentCorrect += (correct - percentCorrect) / Math.min(record, windowSize);            if (numCategories() == 2) {                auc.addSample(actual, groupKey, v.get(1));            }        } else {            model.train(trackingKey, groupKey, actual, instance);        }        k++;    }}
1bcb30cbd7912c81cb133675f2ede46cd479263a731bdbfc5266cd4906ecebaf
mod
private static long mod(long x, int y)
{    long r = x % y;    return r < 0 ? r + y : r;}
5df6118bc0e745d8b18e0a6a99b2e3f2ddba8140cbeb1423ce2df50a9f140574
close
public void close()
{    for (OnlineLogisticRegression m : models) {        m.close();    }}
9d4a67692ca4f5bcfd4320d20788e21a1eae3e1ff7a45d651f2d2dac7af1657f
resetLineCounter
public void resetLineCounter()
{    record = 0;}
4918b4274be08205d5497f20edf2ee39225b5393111844fce47eaa9ea393173a
validModel
public boolean validModel()
{    boolean r = true;    for (OnlineLogisticRegression model : models) {        r &= model.validModel();    }    return r;}
a65d353603d9c6fa69fa946675f753b9e8fcbd94f8ccaeab6425adab7d1af7ba
classify
public Vector classify(Vector instance)
{    Vector r = new DenseVector(numCategories() - 1);    DoubleDoubleFunction scale = Functions.plusMult(1.0 / models.size());    for (OnlineLogisticRegression model : models) {        r.assign(model.classify(instance), scale);    }    return r;}
2db9aca8fa7eeaf8a8a3c2d7ec4cec1865a582b31266699ab89f98d6ec702fbe
classifyNoLink
public Vector classifyNoLink(Vector instance)
{    Vector r = new DenseVector(numCategories() - 1);    DoubleDoubleFunction scale = Functions.plusMult(1.0 / models.size());    for (OnlineLogisticRegression model : models) {        r.assign(model.classifyNoLink(instance), scale);    }    return r;}
26ad6f4b0cd93ee65196cb117ed56b25c67c201f8283b12a24dbe4c622a5a362
classifyScalar
public double classifyScalar(Vector instance)
{    double r = 0;    int n = 0;    for (OnlineLogisticRegression model : models) {        n++;        r += model.classifyScalar(instance);    }    return r / n;}
0bdeb79fe74c02804b0b53b9a99db42b7e41e4a28e6e703c32648791e7032088
numCategories
public int numCategories()
{    return models.get(0).numCategories();}
b7b9278dce78d03ffa978e3c2e0e40fd1430be1af8a105ca11d28be7d3a4d960
auc
public double auc()
{    return auc.auc();}
134b6c105ee749ea432ea14b9c1a74343ce9ca389d049de36e22741bace6c973
logLikelihood
public double logLikelihood()
{    return logLikelihood;}
c20ffba8f4f378b0345f52a05fe2a809cd63c714e330fa86f4e2386f0b18b5b1
percentCorrect
public double percentCorrect()
{    return percentCorrect;}
898a7c9cf146c188d6b4ce8e8d0af0d292b28a792f88f4eef5aa8eb480c730bb
copy
public CrossFoldLearner copy()
{    CrossFoldLearner r = new CrossFoldLearner(models.size(), numCategories(), numFeatures, prior);    r.models.clear();    for (OnlineLogisticRegression model : models) {        model.close();        OnlineLogisticRegression newModel = new OnlineLogisticRegression(model.numCategories(), model.numFeatures(), model.prior);        newModel.copyFrom(model);        r.models.add(newModel);    }    return r;}
25ffba61a8b5a713bfc4bda75cb12cf549a4ffc36871699cfc782802bca87792
getRecord
public int getRecord()
{    return record;}
90741e5f491fba40c3faa7d87edefdc4e2b64c6efe8ca3ddac8aad707bd24dde
setRecord
public void setRecord(int record)
{    this.record = record;}
87778bac4a2bb52e38f19a2a47d0f60e35e16272b95cc257245229041bf548b7
getAucEvaluator
public OnlineAuc getAucEvaluator()
{    return auc;}
5cd935a208713f9adff2e53e62da79b0b050388d136de2e20403d89a45e7b998
setAucEvaluator
public void setAucEvaluator(OnlineAuc auc)
{    this.auc = auc;}
37e7a0d6bb88c6f4dec1c468ed8f96422fa5b4a75f99508565a3d05f6163ab8b
getLogLikelihood
public double getLogLikelihood()
{    return logLikelihood;}
e0ef79a23e9a1d267b6fe91df0334624b36ecd6731906351fcfd0a6c92f38b56
setLogLikelihood
public void setLogLikelihood(double logLikelihood)
{    this.logLikelihood = logLikelihood;}
fc22725289c90373a36f127759bdeca606134b64b2ee9e72befae13b0f328f7a
getModels
public List<OnlineLogisticRegression> getModels()
{    return models;}
044f4ea328e965b76a1011dd233b4f287c0b093c17c144c334d8c8d60ba2b252
addModel
public void addModel(OnlineLogisticRegression model)
{    models.add(model);}
e1882392d0b4f1cd71a8f45ebb4c732ed4af5699fb8c30cf6b995f6640d41d68
getParameters
public double[] getParameters()
{    return parameters;}
a755eb7b687beb86e9c4ef881d216e0f4749fbc6ae57dc3165ae228da4832258
setParameters
public void setParameters(double[] parameters)
{    this.parameters = parameters;}
4a142c3e7355f05c01931684dab7c3e5fbdf3a15cc9c0bfd751d8a0429c7a23e
getNumFeatures
public int getNumFeatures()
{    return numFeatures;}
cef8af688b04b2c9ff55509c96d46c697b282bb134fff7b0e98a02e8cd70a8e1
setNumFeatures
public void setNumFeatures(int numFeatures)
{    this.numFeatures = numFeatures;}
7ba386b15d58e7c9c8dc0e1c66d83ff8cfc28e3f8b9846704bc4cb54bdf8dddd
setWindowSize
public void setWindowSize(int windowSize)
{    this.windowSize = windowSize;    auc.setWindowSize(windowSize);}
913a93724ce1124485df8d25baec07c55b83f55e1a2d6b257c84bacea829dcea
getPrior
public PriorFunction getPrior()
{    return prior;}
35473afe26f1f578df4bd2ad27cb12a98ec7ee3c2265302a3700146d030b035a
setPrior
public void setPrior(PriorFunction prior)
{    this.prior = prior;}
a894510dd4db439ff8e17ae1059489dc3abc97178e5932ceed0c70c3af165401
write
public void write(DataOutput out) throws IOException
{    out.writeInt(record);    PolymorphicWritable.write(out, auc);    out.writeDouble(logLikelihood);    out.writeInt(models.size());    for (OnlineLogisticRegression model : models) {        model.write(out);    }    for (double x : parameters) {        out.writeDouble(x);    }    out.writeInt(numFeatures);    PolymorphicWritable.write(out, prior);    out.writeDouble(percentCorrect);    out.writeInt(windowSize);}
5478cc5683f6dfd4515c383752d7c803555efc63d03fd84a03ba8dcd17eb4324
readFields
public void readFields(DataInput in) throws IOException
{    record = in.readInt();    auc = PolymorphicWritable.read(in, OnlineAuc.class);    logLikelihood = in.readDouble();    int n = in.readInt();    for (int i = 0; i < n; i++) {        OnlineLogisticRegression olr = new OnlineLogisticRegression();        olr.readFields(in);        models.add(olr);    }    parameters = new double[4];    for (int i = 0; i < 4; i++) {        parameters[i] = in.readDouble();    }    numFeatures = in.readInt();    prior = PolymorphicWritable.read(in, PriorFunction.class);    percentCorrect = in.readDouble();    windowSize = in.readInt();}
219cf661e97e67ca1f41ab06ece357baf06e84a9bf1716fab7c03187c2511a08
parseCsvLine
private List<String> parseCsvLine(String line)
{    try {        return Arrays.asList(CSVUtils.parseLine(line));    } catch (IOException e) {        List<String> list = new ArrayList<>();        list.add(line);        return list;    }}
fd91b064059abe7587df046bcfd07fc8ae60cfd932d5d407e9f15ab27b035c3f
parseCsvLine
private List<String> parseCsvLine(CharSequence line)
{    return parseCsvLine(line.toString());}
6973d9a7b38809a25487371a130a57f71efd950cf80be6d6f2fef80b68633404
defineTargetCategories
public void defineTargetCategories(List<String> values)
{    Preconditions.checkArgument(values.size() <= maxTargetValue, "Must have less than or equal to " + maxTargetValue + " categories for target variable, but found " + values.size());    if (maxTargetValue == Integer.MAX_VALUE) {        maxTargetValue = values.size();    }    for (String value : values) {        targetDictionary.intern(value);    }}
69cc9c981aee307711759390056107c69b161cdbe567e5161e9f1ada369b853c
maxTargetValue
public CsvRecordFactory maxTargetValue(int max)
{    maxTargetValue = max;    return this;}
79cf3e14314b3cd8edaa992f4e4df2f24a6896b7cd0c640aa1ba31a5331e55f5
usesFirstLineAsSchema
public boolean usesFirstLineAsSchema()
{    return true;}
57546d7c00d046f7e846b4965e990f0fa3df4375d4726edcca0d60d785e56f7c
firstLine
public void firstLine(String line)
{        final Map<String, Integer> vars = new HashMap<>();    variableNames = parseCsvLine(line);    int column = 0;    for (String var : variableNames) {        vars.put(var, column++);    }        target = vars.get(targetName);        if (idName != null) {        id = vars.get(idName);    }        predictors = new ArrayList<>(Collections2.transform(typeMap.keySet(), new Function<String, Integer>() {        @Override        public Integer apply(String from) {            Integer r = vars.get(from);            Preconditions.checkArgument(r != null, "Can't find variable %s, only know about %s", from, vars);            return r;        }    }));    if (includeBiasTerm) {        predictors.add(-1);    }    Collections.sort(predictors);        predictorEncoders = new HashMap<>();    for (Integer predictor : predictors) {        String name;        Class<? extends FeatureVectorEncoder> c;        if (predictor == -1) {            name = INTERCEPT_TERM;            c = ConstantValueEncoder.class;        } else {            name = variableNames.get(predictor);            c = TYPE_DICTIONARY.get(typeMap.get(name));        }        try {            Preconditions.checkArgument(c != null, "Invalid type of variable %s,  wanted one of %s", typeMap.get(name), TYPE_DICTIONARY.keySet());            Constructor<? extends FeatureVectorEncoder> constructor = c.getConstructor(String.class);            Preconditions.checkArgument(constructor != null, "Can't find correct constructor for %s", typeMap.get(name));            FeatureVectorEncoder encoder = constructor.newInstance(name);            predictorEncoders.put(predictor, encoder);            encoder.setTraceDictionary(traceDictionary);        } catch (InstantiationException e) {            throw new IllegalStateException(CANNOT_CONSTRUCT_CONVERTER, e);        } catch (IllegalAccessException e) {            throw new IllegalStateException(CANNOT_CONSTRUCT_CONVERTER, e);        } catch (InvocationTargetException e) {            throw new IllegalStateException(CANNOT_CONSTRUCT_CONVERTER, e);        } catch (NoSuchMethodException e) {            throw new IllegalStateException(CANNOT_CONSTRUCT_CONVERTER, e);        }    }}
5eb14ea699ebf4f839e4139193210b76d631375c27989481bf40af52a21570b3
apply
public Integer apply(String from)
{    Integer r = vars.get(from);    Preconditions.checkArgument(r != null, "Can't find variable %s, only know about %s", from, vars);    return r;}
edcd381fee635c817322da4dac237659a2ead3c70500262a30a19cc31d4321b3
processLine
public int processLine(String line, Vector featureVector)
{    List<String> values = parseCsvLine(line);    int targetValue = targetDictionary.intern(values.get(target));    if (targetValue >= maxTargetValue) {        targetValue = maxTargetValue - 1;    }    for (Integer predictor : predictors) {        String value;        if (predictor >= 0) {            value = values.get(predictor);        } else {            value = null;        }        predictorEncoders.get(predictor).addToVector(value, featureVector);    }    return targetValue;}
2a8ccef5b7c722f8cea24a2ea7347cfa4cd201d87aaeaa9365a7945e68d94d7c
processLine
public int processLine(CharSequence line, Vector featureVector, boolean returnTarget)
{    List<String> values = parseCsvLine(line);    int targetValue = -1;    if (returnTarget) {        targetValue = targetDictionary.intern(values.get(target));        if (targetValue >= maxTargetValue) {            targetValue = maxTargetValue - 1;        }    }    for (Integer predictor : predictors) {        String value = predictor >= 0 ? values.get(predictor) : null;        predictorEncoders.get(predictor).addToVector(value, featureVector);    }    return targetValue;}
996a40e73ef04a48aa690b7bd1df13874f793272b915b49d4245857141055a45
getTargetString
public String getTargetString(CharSequence line)
{    List<String> values = parseCsvLine(line);    return values.get(target);}
ae27b3f5c859361e6f985f8082201ba56bf7dc48a91fa22e975423e08a89293d
getTargetLabel
public String getTargetLabel(int code)
{    for (String key : targetDictionary.values()) {        if (targetDictionary.intern(key) == code) {            return key;        }    }    return null;}
9a02d8ac28783abb4e9741591a3ddf04f0dee07db5b0ed6a5a62d5b5f11fae99
getIdString
public String getIdString(CharSequence line)
{    List<String> values = parseCsvLine(line);    return values.get(id);}
3427a5eb752a5a07eb379a534d2cbc1c904615a08beb5e3f317383709a256f4d
getPredictors
public Iterable<String> getPredictors()
{    return Lists.transform(predictors, new Function<Integer, String>() {        @Override        public String apply(Integer v) {            if (v >= 0) {                return variableNames.get(v);            } else {                return INTERCEPT_TERM;            }        }    });}
43e2438607a2c14701e7c8e09d05d6a5924496ea434e44151d34762585145966
apply
public String apply(Integer v)
{    if (v >= 0) {        return variableNames.get(v);    } else {        return INTERCEPT_TERM;    }}
e64d047b7bb1023c0bf76028c8ebd6c4434d33b4e6e45479276754878fc79443
getTraceDictionary
public Map<String, Set<Integer>> getTraceDictionary()
{    return traceDictionary;}
72201faabaf7b4d772e69a3bf5702d1f2469c23bd8c85b0b960f6a65774d17fc
includeBiasTerm
public CsvRecordFactory includeBiasTerm(boolean useBias)
{    includeBiasTerm = useBias;    return this;}
01069d17d3797fe03dab72646a466e643c4c3a57c024cb9129592baf2f3766e8
getTargetCategories
public List<String> getTargetCategories()
{    List<String> r = targetDictionary.values();    if (r.size() > maxTargetValue) {        r.subList(maxTargetValue, r.size()).clear();    }    return r;}
628a9d72c79d0d461ef90282017191e319b654262e299298c54d63e452e4cd24
getIdName
public String getIdName()
{    return idName;}
3801128e86a89d529b0790716dc527d4d2c4d3d598e85654dac8aa7716375c59
setIdName
public void setIdName(String idName)
{    this.idName = idName;}
6ffed33495fe6530bfcbd1f13179f2adfd9cede4a5a66dfcbd5a8d775e1b8467
apply
public final Vector apply(String groupKey, int actual, Vector instance, AbstractVectorClassifier classifier)
{        Vector v = classifier.classify(instance);    Vector r = v.like();    if (actual != 0) {        r.setQuick(actual - 1, 1);    }    r.assign(v, Functions.MINUS);    return r;}
3763ecad08062fbcd663c4705dfb27e2d779fe70418c49567789c58c60945bd0
age
public double age(double oldValue, double generations, double learningRate)
{    oldValue *= Math.pow(1 - alphaByLambda * learningRate, generations);    double newValue = oldValue - Math.signum(oldValue) * learningRate * generations;    if (newValue * oldValue < 0.0) {                return 0.0;    } else {        return newValue;    }}
d7aa90e3adb0c4f9ef0e5c0b9b1dda7f64c538148558f25af09a4a72dd53c718
logP
public double logP(double betaIJ)
{    return l1.logP(betaIJ) + alphaByLambda * l2.logP(betaIJ);}
a894510dd4db439ff8e17ae1059489dc3abc97178e5932ceed0c70c3af165401
write
public void write(DataOutput out) throws IOException
{    out.writeDouble(alphaByLambda);    l1.write(out);    l2.write(out);}
5478cc5683f6dfd4515c383752d7c803555efc63d03fd84a03ba8dcd17eb4324
readFields
public void readFields(DataInput in) throws IOException
{    alphaByLambda = in.readDouble();    l1 = new L1();    l1.readFields(in);    l2 = new L2();    l2.readFields(in);}
e62ae6d19112898130f909e9edc3ea87450534f1cc9db65b2680abe957f0b8da
initWeights
public void initWeights(Random gen)
{    double hiddenFanIn = 1.0 / Math.sqrt(numFeatures);    for (int i = 0; i < numHidden; i++) {        for (int j = 0; j < numFeatures; j++) {            double val = (2.0 * gen.nextDouble() - 1.0) * hiddenFanIn;            hiddenWeights[i].setQuick(j, val);        }    }    double outputFanIn = 1.0 / Math.sqrt(numHidden);    for (int i = 0; i < numOutput; i++) {        for (int j = 0; j < numHidden; j++) {            double val = (2.0 * gen.nextDouble() - 1.0) * outputFanIn;            outputWeights[i].setQuick(j, val);        }    }}
adad3ac8f5c5fd6f597f15fd1d1774cfb6030bb7f6489a04c62c76fea19988b2
learningRate
public GradientMachine learningRate(double learningRate)
{    this.learningRate = learningRate;    return this;}
ed74040964a8a6427730eb5a650f855f3d8de2980c96404ce407bdf44888fec6
regularization
public GradientMachine regularization(double regularization)
{    this.regularization = regularization;    return this;}
f2da4ebda1527e0255ebc5861bc9fb1aaff0aefb1e2f8872821df86bd4ea9f62
sparsity
public GradientMachine sparsity(double sparsity)
{    this.sparsity = sparsity;    return this;}
00465477252315825d1dd5018ef01cd6d115b7922f63c7e44a937c573046fef0
sparsityLearningRate
public GradientMachine sparsityLearningRate(double sparsityLearningRate)
{    this.sparsityLearningRate = sparsityLearningRate;    return this;}
688aa099df19e535afef3b4e7cb94637592ad5deaec5c111264b77a8acaf2265
copyFrom
public void copyFrom(GradientMachine other)
{    numFeatures = other.numFeatures;    numHidden = other.numHidden;    numOutput = other.numOutput;    learningRate = other.learningRate;    regularization = other.regularization;    sparsity = other.sparsity;    sparsityLearningRate = other.sparsityLearningRate;    hiddenWeights = new DenseVector[numHidden];    for (int i = 0; i < numHidden; i++) {        hiddenWeights[i] = other.hiddenWeights[i].clone();    }    hiddenBias = other.hiddenBias.clone();    outputWeights = new DenseVector[numOutput];    for (int i = 0; i < numOutput; i++) {        outputWeights[i] = other.outputWeights[i].clone();    }    outputBias = other.outputBias.clone();}
0bdeb79fe74c02804b0b53b9a99db42b7e41e4a28e6e703c32648791e7032088
numCategories
public int numCategories()
{    return numOutput;}
e5a3cd58a1672c77f7fc460a19f0294e3e9cfaa65394aec1fa2e316fe4065a33
numFeatures
public int numFeatures()
{    return numFeatures;}
2d96818cfed47f48022a5846467136ef4375b40f6e4dd707fab28a441a577764
numHidden
public int numHidden()
{    return numHidden;}
de77789a3dfc8976d19271837369b84c39572ab8481e9c6988ef77c43065c244
inputToHidden
public DenseVector inputToHidden(Vector input)
{    DenseVector activations = new DenseVector(numHidden);    for (int i = 0; i < numHidden; i++) {        activations.setQuick(i, hiddenWeights[i].dot(input));    }    activations.assign(hiddenBias, Functions.PLUS);    activations.assign(Functions.min(40.0)).assign(Functions.max(-40));    activations.assign(Functions.SIGMOID);    return activations;}
36651e51952edde5da80d35076c96c6d72cc3964ecef525a12eb1ca2789617d6
hiddenToOutput
public DenseVector hiddenToOutput(Vector hiddenActivation)
{    DenseVector activations = new DenseVector(numOutput);    for (int i = 0; i < numOutput; i++) {        activations.setQuick(i, outputWeights[i].dot(hiddenActivation));    }    activations.assign(outputBias, Functions.PLUS);    return activations;}
b6763608f4099eab9f44e1bafcc6cc11d6f048a8fae5ac31cf44a676bb8a2b9a
updateRanking
public void updateRanking(Vector hiddenActivation, Collection<Integer> goodLabels, int numTrials, Random gen)
{        if (goodLabels.size() >= numOutput) {        return;    }    for (Integer good : goodLabels) {        double goodScore = outputWeights[good].dot(hiddenActivation);        int highestBad = -1;        double highestBadScore = Double.NEGATIVE_INFINITY;        for (int i = 0; i < numTrials; i++) {            int bad = gen.nextInt(numOutput);            while (goodLabels.contains(bad)) {                bad = gen.nextInt(numOutput);            }            double badScore = outputWeights[bad].dot(hiddenActivation);            if (badScore > highestBadScore) {                highestBadScore = badScore;                highestBad = bad;            }        }        int bad = highestBad;        double loss = 1.0 - goodScore + highestBadScore;        if (loss < 0.0) {            continue;        }                                                        Vector gradGood = outputWeights[good].clone();        gradGood.assign(Functions.NEGATE);        Vector propHidden = gradGood.clone();        Vector gradBad = outputWeights[bad].clone();        propHidden.assign(gradBad, Functions.PLUS);        gradGood.assign(Functions.mult(-learningRate * (1.0 - regularization)));        outputWeights[good].assign(gradGood, Functions.PLUS);        gradBad.assign(Functions.mult(-learningRate * (1.0 + regularization)));        outputWeights[bad].assign(gradBad, Functions.PLUS);        outputBias.setQuick(good, outputBias.get(good) + learningRate);        outputBias.setQuick(bad, outputBias.get(bad) - learningRate);                Vector gradSig = hiddenActivation.clone();        gradSig.assign(Functions.SIGMOIDGRADIENT);                for (int i = 0; i < numHidden; i++) {            gradSig.setQuick(i, gradSig.get(i) * propHidden.get(i));        }        for (int i = 0; i < numHidden; i++) {            for (int j = 0; j < numFeatures; j++) {                double v = hiddenWeights[i].get(j);                v -= learningRate * (gradSig.get(i) + regularization * v);                hiddenWeights[i].setQuick(j, v);            }        }    }}
a65d353603d9c6fa69fa946675f753b9e8fcbd94f8ccaeab6425adab7d1af7ba
classify
public Vector classify(Vector instance)
{    Vector result = classifyNoLink(instance);        int max = result.maxValueIndex();    result.assign(0);    result.setQuick(max, 1.0);    return result.viewPart(1, result.size() - 1);}
2db9aca8fa7eeaf8a8a3c2d7ec4cec1865a582b31266699ab89f98d6ec702fbe
classifyNoLink
public Vector classifyNoLink(Vector instance)
{    DenseVector hidden = inputToHidden(instance);    return hiddenToOutput(hidden);}
26ad6f4b0cd93ee65196cb117ed56b25c67c201f8283b12a24dbe4c622a5a362
classifyScalar
public double classifyScalar(Vector instance)
{    Vector output = classifyNoLink(instance);    if (output.get(0) > output.get(1)) {        return 0;    }    return 1;}
f73a010cc5a2f10283b8aaa5424f36591a9b062e2f66276bb7ac6ebe0bba8fa7
copy
public GradientMachine copy()
{    close();    GradientMachine r = new GradientMachine(numFeatures(), numHidden(), numCategories());    r.copyFrom(this);    return r;}
a894510dd4db439ff8e17ae1059489dc3abc97178e5932ceed0c70c3af165401
write
public void write(DataOutput out) throws IOException
{    out.writeInt(WRITABLE_VERSION);    out.writeDouble(learningRate);    out.writeDouble(regularization);    out.writeDouble(sparsity);    out.writeDouble(sparsityLearningRate);    out.writeInt(numFeatures);    out.writeInt(numHidden);    out.writeInt(numOutput);    VectorWritable.writeVector(out, hiddenBias);    for (int i = 0; i < numHidden; i++) {        VectorWritable.writeVector(out, hiddenWeights[i]);    }    VectorWritable.writeVector(out, outputBias);    for (int i = 0; i < numOutput; i++) {        VectorWritable.writeVector(out, outputWeights[i]);    }}
5478cc5683f6dfd4515c383752d7c803555efc63d03fd84a03ba8dcd17eb4324
readFields
public void readFields(DataInput in) throws IOException
{    int version = in.readInt();    if (version == WRITABLE_VERSION) {        learningRate = in.readDouble();        regularization = in.readDouble();        sparsity = in.readDouble();        sparsityLearningRate = in.readDouble();        numFeatures = in.readInt();        numHidden = in.readInt();        numOutput = in.readInt();        hiddenWeights = new DenseVector[numHidden];        hiddenBias = VectorWritable.readVector(in);        for (int i = 0; i < numHidden; i++) {            hiddenWeights[i] = VectorWritable.readVector(in);        }        outputWeights = new DenseVector[numOutput];        outputBias = VectorWritable.readVector(in);        for (int i = 0; i < numOutput; i++) {            outputWeights[i] = VectorWritable.readVector(in);        }    } else {        throw new IOException("Incorrect object version, wanted " + WRITABLE_VERSION + " got " + version);    }}
5df6118bc0e745d8b18e0a6a99b2e3f2ddba8140cbeb1423ce2df50a9f140574
close
public void close()
{}
9d4edf7bd694e762788702e48c71d41d687d0473faa8bf5c051f3c74621df2dc
train
public void train(long trackingKey, String groupKey, int actual, Vector instance)
{    Vector hiddenActivation = inputToHidden(instance);    hiddenToOutput(hiddenActivation);    Collection<Integer> goodLabels = new HashSet<>();    goodLabels.add(actual);    updateRanking(hiddenActivation, goodLabels, 2, rnd);}
4b559a17ddb4da56ecccbda13ac676e16b4711323497a0ebddd40395eef13b96
train
public void train(long trackingKey, int actual, Vector instance)
{    train(trackingKey, null, actual, instance);}
ecc6f64b0a839651cb9eb6f6925f645a77e15f44cd48611cfa9da8168f00ff18
train
public void train(int actual, Vector instance)
{    train(0, null, actual, instance);}
3763ecad08062fbcd663c4705dfb27e2d779fe70418c49567789c58c60945bd0
age
public double age(double oldValue, double generations, double learningRate)
{    double newValue = oldValue - Math.signum(oldValue) * learningRate * generations;    if (newValue * oldValue < 0) {                return 0;    } else {        return newValue;    }}
d7aa90e3adb0c4f9ef0e5c0b9b1dda7f64c538148558f25af09a4a72dd53c718
logP
public double logP(double betaIJ)
{    return -Math.abs(betaIJ);}
a894510dd4db439ff8e17ae1059489dc3abc97178e5932ceed0c70c3af165401
write
public void write(DataOutput out) throws IOException
{}
c5821d086e99763a45e1e272070fb489eff057889b3aac47dfd41f118d6aecf6
readFields
public void readFields(DataInput dataInput) throws IOException
{}
3763ecad08062fbcd663c4705dfb27e2d779fe70418c49567789c58c60945bd0
age
public double age(double oldValue, double generations, double learningRate)
{    return oldValue * Math.pow(1.0 - learningRate / s2, generations);}
d7aa90e3adb0c4f9ef0e5c0b9b1dda7f64c538148558f25af09a4a72dd53c718
logP
public double logP(double betaIJ)
{    return -betaIJ * betaIJ / s2 / 2.0 - Math.log(s) - HALF_LOG_2PI;}
a894510dd4db439ff8e17ae1059489dc3abc97178e5932ceed0c70c3af165401
write
public void write(DataOutput out) throws IOException
{    out.writeDouble(s2);    out.writeDouble(s);}
5478cc5683f6dfd4515c383752d7c803555efc63d03fd84a03ba8dcd17eb4324
readFields
public void readFields(DataInput in) throws IOException
{    s2 = in.readDouble();    s = in.readDouble();}
44610c9a266f931f357088d1ed950fb63eaf1fb7dbd6a84f8433e1d24084faf7
apply
public Vector apply(String groupKey, int actual, Vector instance, AbstractVectorClassifier classifier)
{    if (random.nextDouble() < alpha) {                if (!hasZero || !hasOne) {            throw new IllegalStateException();        }        return rank.apply(groupKey, actual, instance, classifier);    } else {        hasZero |= actual == 0;        hasOne |= actual == 1;                rank.addToHistory(actual, instance);        return basic.apply(groupKey, actual, instance, classifier);    }}
c0d4988da3b1b329ba69091e94fb80c0193009b5d660b533e12c98ce11aac970
update
public void update(Vector features, Map<String, Set<Integer>> traceDictionary, AbstractVectorClassifier learner)
{        features.assign(0);    for (Map.Entry<String, Set<Integer>> entry : traceDictionary.entrySet()) {                String key = entry.getKey();        Set<Integer> value = entry.getValue();                if (!weightMap.containsKey(key)) {                        for (Integer where : value) {                features.set(where, 1);            }                        Vector v = learner.classifyNoLink(features);            weightMap.put(key, v);                        for (Integer where : value) {                features.set(where, 0);            }        }    }}
89f5e0722c92d42ad24c3dddcfd3fca52182f66d0c1d78cdd9c534d336c2be19
summary
public List<Weight> summary(int n)
{    Queue<Weight> pq = new PriorityQueue<>();    for (Map.Entry<String, Vector> entry : weightMap.entrySet()) {        pq.add(new Weight(entry.getKey(), entry.getValue()));        while (pq.size() > n) {            pq.poll();        }    }    List<Weight> r = new ArrayList<>(pq);    Collections.sort(r, Ordering.natural().reverse());    return r;}
cea3f76e7187ccde00aca64f81fa7d360a8754eb72688a0ea59010547c1447b1
compareTo
public int compareTo(Category o)
{    int r = Double.compare(Math.abs(weight), Math.abs(o.weight));    if (r == 0) {        if (o.index < index) {            return -1;        }        if (o.index > index) {            return 1;        }        return 0;    }    return r;}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (!(o instanceof Category)) {        return false;    }    Category other = (Category) o;    return index == other.index && weight == other.weight;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return RandomUtils.hashDouble(weight) ^ index;}
4b79d5b0beabf19cb35987e58bc4c0f9dfafd3a1eeaee8e78c3963e62b8943b3
compareTo
public int compareTo(Weight other)
{    int r = Double.compare(Math.abs(this.value), Math.abs(other.value));    if (r == 0) {        return feature.compareTo(other.feature);    }    return r;}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (!(o instanceof Weight)) {        return false;    }    Weight other = (Weight) o;    return feature.equals(other.feature) && value == other.value && maxIndex == other.maxIndex && categories.equals(other.categories);}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return feature.hashCode() ^ RandomUtils.hashDouble(value) ^ maxIndex ^ categories.hashCode();}
0668c61bc2a21662d506730c9624f8668617225e831222f1881a1a665934cc9c
getFeature
public String getFeature()
{    return feature;}
4fcdc31ef95f5a8da570a554b48977aa3dd343f3820426ae37586f4231b6e321
getWeight
public double getWeight()
{    return value;}
94e82b26755b7c6da3f728445e6a22559c489c6eeec886f6a994ddc0f3e2794b
getWeight
public double getWeight(int n)
{    return categories.get(n).weight;}
67663b91322965584793e13968f22d72d54e5bb0a2de029acdd703c657eb2410
getCategory
public double getCategory(int n)
{    return categories.get(n).index;}
cddd09e48ba21fefc2a828f35fcbca448acae3de256aab9b9ee5693c23a16af2
getMaxImpact
public int getMaxImpact()
{    return maxIndex;}
cac443e412c506022fd694c6bef33c77975c14362b9cf666cb9affc3c1e9a40c
writeBinary
public static void writeBinary(String path, CrossFoldLearner model) throws IOException
{    try (DataOutputStream out = new DataOutputStream(new FileOutputStream(path))) {        PolymorphicWritable.write(out, model);    }}
a0282b58da7b16fd59d43dc27042af0041b6b4fcbb15e3570122773d28ae4b27
writeBinary
public static void writeBinary(String path, OnlineLogisticRegression model) throws IOException
{    try (DataOutputStream out = new DataOutputStream(new FileOutputStream(path))) {        PolymorphicWritable.write(out, model);    }}
93fd1406618c749a03b92d468858ae1a68f5617a9352bccceb626f5e597dd08e
writeBinary
public static void writeBinary(String path, AdaptiveLogisticRegression model) throws IOException
{    try (DataOutputStream out = new DataOutputStream(new FileOutputStream(path))) {        PolymorphicWritable.write(out, model);    }}
1a189efb0545d1e6f37ab115069ea0cb0f1bf9684ec7f0c73a7e3dbe7998214c
readBinary
public static T readBinary(InputStream in, Class<T> clazz) throws IOException
{    DataInput dataIn = new DataInputStream(in);    try {        return PolymorphicWritable.read(dataIn, clazz);    } finally {        Closeables.close(in, false);    }}
3ee56486e2272295d195ff2a1390336520584363afb5c57d89e439f857a1e31c
alpha
public OnlineLogisticRegression alpha(double alpha)
{    this.decayFactor = alpha;    return this;}
d5f4c57202eda8ddcf39e4c28228a36e562322c30a4242173c144eaa72fbdff0
lambda
public OnlineLogisticRegression lambda(double lambda)
{        super.lambda(lambda);    return this;}
a40cd9d34cd5f6b8f704e73b88d9bddc4adb9bf2210eba06c991a6bb8585ccfd
learningRate
public OnlineLogisticRegression learningRate(double learningRate)
{    this.mu0 = learningRate;    return this;}
f96c4a3ef3dab5061771d626aa70034fe8d2fed7b01de689fab1b667b60f23b6
stepOffset
public OnlineLogisticRegression stepOffset(int stepOffset)
{    this.stepOffset = stepOffset;    return this;}
4129d80f6f6b66da7a5d67b96e61f2bd626548ffd4a2cf2d2418c770ffe03233
decayExponent
public OnlineLogisticRegression decayExponent(double decayExponent)
{    if (decayExponent > 0) {        decayExponent = -decayExponent;    }    this.forgettingExponent = decayExponent;    return this;}
4f09ba46465773443cecf66de2c13aef886dd2afb5be77ebb59abe97fdd1b08f
perTermLearningRate
public double perTermLearningRate(int j)
{    return Math.sqrt(perTermAnnealingOffset / updateCounts.get(j));}
cca9897dfdeab91fa9d6e01449817b8b937b066679d4e6a77d04dfa2acc046a3
currentLearningRate
public double currentLearningRate()
{    return mu0 * Math.pow(decayFactor, getStep()) * Math.pow(getStep() + stepOffset, forgettingExponent);}
be73278f707a301655a528acea62ff3cc6bce12556d650e5b23debe9d31e6daa
copyFrom
public void copyFrom(OnlineLogisticRegression other)
{    super.copyFrom(other);    mu0 = other.mu0;    decayFactor = other.decayFactor;    stepOffset = other.stepOffset;    forgettingExponent = other.forgettingExponent;    perTermAnnealingOffset = other.perTermAnnealingOffset;}
8677e6e2aed692e66e3579bd49e9b66e8cb8644a6bf4855ed343691bbfbc0e32
copy
public OnlineLogisticRegression copy()
{    close();    OnlineLogisticRegression r = new OnlineLogisticRegression(numCategories(), numFeatures(), prior);    r.copyFrom(this);    return r;}
a894510dd4db439ff8e17ae1059489dc3abc97178e5932ceed0c70c3af165401
write
public void write(DataOutput out) throws IOException
{    out.writeInt(WRITABLE_VERSION);    out.writeDouble(mu0);    out.writeDouble(getLambda());    out.writeDouble(decayFactor);    out.writeInt(stepOffset);    out.writeInt(step);    out.writeDouble(forgettingExponent);    out.writeInt(perTermAnnealingOffset);    out.writeInt(numCategories);    MatrixWritable.writeMatrix(out, beta);    PolymorphicWritable.write(out, prior);    VectorWritable.writeVector(out, updateCounts);    VectorWritable.writeVector(out, updateSteps);}
5478cc5683f6dfd4515c383752d7c803555efc63d03fd84a03ba8dcd17eb4324
readFields
public void readFields(DataInput in) throws IOException
{    int version = in.readInt();    if (version == WRITABLE_VERSION) {        mu0 = in.readDouble();        lambda(in.readDouble());        decayFactor = in.readDouble();        stepOffset = in.readInt();        step = in.readInt();        forgettingExponent = in.readDouble();        perTermAnnealingOffset = in.readInt();        numCategories = in.readInt();        beta = MatrixWritable.readMatrix(in);        prior = PolymorphicWritable.read(in, PriorFunction.class);        updateCounts = VectorWritable.readVector(in);        updateSteps = VectorWritable.readVector(in);    } else {        throw new IOException("Incorrect object version, wanted " + WRITABLE_VERSION + " got " + version);    }}
18f36af28b5225b5cc26d761e57c779d966730c9bd6e38f07d1f6253fb258864
learningRate
public PassiveAggressive learningRate(double learningRate)
{    this.learningRate = learningRate;    return this;}
be62944985e38047198686f50c71a3cb900329e4758d5b28d35d64770c39fbd4
copyFrom
public void copyFrom(PassiveAggressive other)
{    learningRate = other.learningRate;    numCategories = other.numCategories;    weights = other.weights;}
0bdeb79fe74c02804b0b53b9a99db42b7e41e4a28e6e703c32648791e7032088
numCategories
public int numCategories()
{    return numCategories;}
a65d353603d9c6fa69fa946675f753b9e8fcbd94f8ccaeab6425adab7d1af7ba
classify
public Vector classify(Vector instance)
{    Vector result = classifyNoLink(instance);        double max = result.maxValue();    result.assign(Functions.minus(max)).assign(Functions.EXP);    result = result.divide(result.norm(1));    return result.viewPart(1, result.size() - 1);}
2db9aca8fa7eeaf8a8a3c2d7ec4cec1865a582b31266699ab89f98d6ec702fbe
classifyNoLink
public Vector classifyNoLink(Vector instance)
{    Vector result = new DenseVector(weights.numRows());    result.assign(0);    for (int i = 0; i < weights.numRows(); i++) {        result.setQuick(i, weights.viewRow(i).dot(instance));    }    return result;}
26ad6f4b0cd93ee65196cb117ed56b25c67c201f8283b12a24dbe4c622a5a362
classifyScalar
public double classifyScalar(Vector instance)
{    double v1 = weights.viewRow(0).dot(instance);    double v2 = weights.viewRow(1).dot(instance);    v1 = Math.exp(v1);    v2 = Math.exp(v2);    return v2 / (v1 + v2);}
e5a3cd58a1672c77f7fc460a19f0294e3e9cfaa65394aec1fa2e316fe4065a33
numFeatures
public int numFeatures()
{    return weights.numCols();}
77e93012f79d26a121a967adaa5d2a4887bc63425af117563a527adc6ba28d90
copy
public PassiveAggressive copy()
{    close();    PassiveAggressive r = new PassiveAggressive(numCategories(), numFeatures());    r.copyFrom(this);    return r;}
a894510dd4db439ff8e17ae1059489dc3abc97178e5932ceed0c70c3af165401
write
public void write(DataOutput out) throws IOException
{    out.writeInt(WRITABLE_VERSION);    out.writeDouble(learningRate);    out.writeInt(numCategories);    MatrixWritable.writeMatrix(out, weights);}
5478cc5683f6dfd4515c383752d7c803555efc63d03fd84a03ba8dcd17eb4324
readFields
public void readFields(DataInput in) throws IOException
{    int version = in.readInt();    if (version == WRITABLE_VERSION) {        learningRate = in.readDouble();        numCategories = in.readInt();        weights = MatrixWritable.readMatrix(in);    } else {        throw new IOException("Incorrect object version, wanted " + WRITABLE_VERSION + " got " + version);    }}
5df6118bc0e745d8b18e0a6a99b2e3f2ddba8140cbeb1423ce2df50a9f140574
close
public void close()
{}
9d4edf7bd694e762788702e48c71d41d687d0473faa8bf5c051f3c74621df2dc
train
public void train(long trackingKey, String groupKey, int actual, Vector instance)
{    if (lossCount > 1000) {        log.info("Avg. Loss = {}", lossSum / lossCount);        lossCount = 0;        lossSum = 0;    }    Vector result = classifyNoLink(instance);    double myScore = result.get(actual);        int otherIndex = result.maxValueIndex();    double otherValue = result.get(otherIndex);    if (otherIndex == actual) {        result.setQuick(otherIndex, Double.NEGATIVE_INFINITY);        otherIndex = result.maxValueIndex();        otherValue = result.get(otherIndex);    }    double loss = 1.0 - myScore + otherValue;    lossCount += 1;    if (loss >= 0) {        lossSum += loss;        double tau = loss / (instance.dot(instance) + 0.5 / learningRate);        Vector delta = instance.clone();        delta.assign(Functions.mult(tau));        weights.viewRow(actual).assign(delta, Functions.PLUS);                delta.assign(Functions.mult(-1));        weights.viewRow(otherIndex).assign(delta, Functions.PLUS);        }}
4b559a17ddb4da56ecccbda13ac676e16b4711323497a0ebddd40395eef13b96
train
public void train(long trackingKey, int actual, Vector instance)
{    train(trackingKey, null, actual, instance);}
ecc6f64b0a839651cb9eb6f6925f645a77e15f44cd48611cfa9da8168f00ff18
train
public void train(int actual, Vector instance)
{    train(0, null, actual, instance);}
cfde0ea54eac7c7f4e44227273764a4c8b88758fbe6a467b75d250b5cf4710ab
write
public static void write(DataOutput dataOutput, T value) throws IOException
{    dataOutput.writeUTF(value.getClass().getName());    value.write(dataOutput);}
5823db29c69bfb382fc37200aec3cf402a072f43cf677318a66bcaaee5f7e431
read
public static T read(DataInput dataInput, Class<? extends T> clazz) throws IOException
{    String className = dataInput.readUTF();    T r = ClassUtils.instantiateAs(className, clazz);    r.readFields(dataInput);    return r;}
6ffed33495fe6530bfcbd1f13179f2adfd9cede4a5a66dfcbd5a8d775e1b8467
apply
public final Vector apply(String groupKey, int actual, Vector instance, AbstractVectorClassifier classifier)
{    addToHistory(actual, instance);        Deque<Vector> otherSide = history.get(1 - actual);    int n = otherSide.size();    Vector r = null;    for (Vector other : otherSide) {        Vector g = BASIC.apply(groupKey, actual, instance.minus(other), classifier);        if (r == null) {            r = g;        } else {            r.assign(g, Functions.plusMult(1.0 / n));        }    }    return r;}
201302d3d510df30642c2a4b018cd0451f64422f4d3f4b0f0bfffbe57118950f
addToHistory
public void addToHistory(int actual, Vector instance)
{    while (history.size() <= actual) {        history.add(new ArrayDeque<Vector>(window));    }        Deque<Vector> ourSide = history.get(actual);    ourSide.add(instance);    while (ourSide.size() >= window) {        ourSide.pollFirst();    }}
439b22a8a1635fecc253088368d5244399b52e5f92565be55e7e6b609fa4f0a5
getBaseGradient
public Gradient getBaseGradient()
{    return BASIC;}
3763ecad08062fbcd663c4705dfb27e2d779fe70418c49567789c58c60945bd0
age
public double age(double oldValue, double generations, double learningRate)
{    for (int i = 0; i < generations; i++) {        oldValue -= learningRate * oldValue * (df + 1.0) / (df + oldValue * oldValue);    }    return oldValue;}
d7aa90e3adb0c4f9ef0e5c0b9b1dda7f64c538148558f25af09a4a72dd53c718
logP
public double logP(double betaIJ)
{    return Gamma.logGamma((df + 1.0) / 2.0) - Math.log(df * Math.PI) - Gamma.logGamma(df / 2.0) - (df + 1.0) / 2.0 * Math.log1p(betaIJ * betaIJ);}
a894510dd4db439ff8e17ae1059489dc3abc97178e5932ceed0c70c3af165401
write
public void write(DataOutput out) throws IOException
{    out.writeDouble(df);}
5478cc5683f6dfd4515c383752d7c803555efc63d03fd84a03ba8dcd17eb4324
readFields
public void readFields(DataInput in) throws IOException
{    df = in.readDouble();}
3763ecad08062fbcd663c4705dfb27e2d779fe70418c49567789c58c60945bd0
age
public double age(double oldValue, double generations, double learningRate)
{    return oldValue;}
d7aa90e3adb0c4f9ef0e5c0b9b1dda7f64c538148558f25af09a4a72dd53c718
logP
public double logP(double betaIJ)
{    return 0;}
5493eeee7f85bd6fb70c717b366e2363863946d32d71ebd52274dfb03a86cae5
write
public void write(DataOutput dataOutput) throws IOException
{}
c5821d086e99763a45e1e272070fb489eff057889b3aac47dfd41f118d6aecf6
readFields
public void readFields(DataInput dataInput) throws IOException
{}
a894510dd4db439ff8e17ae1059489dc3abc97178e5932ceed0c70c3af165401
write
public void write(DataOutput out) throws IOException
{    out.writeInt(id);    out.writeLong(getNumObservations());    out.writeLong(getTotalObservations());    VectorWritable.writeVector(out, getCenter());    VectorWritable.writeVector(out, getRadius());    out.writeDouble(s0);    VectorWritable.writeVector(out, s1);    VectorWritable.writeVector(out, s2);}
5478cc5683f6dfd4515c383752d7c803555efc63d03fd84a03ba8dcd17eb4324
readFields
public void readFields(DataInput in) throws IOException
{    this.id = in.readInt();    this.setNumObservations(in.readLong());    this.setTotalObservations(in.readLong());    this.setCenter(VectorWritable.readVector(in));    this.setRadius(VectorWritable.readVector(in));    this.setS0(in.readDouble());    this.setS1(VectorWritable.readVector(in));    this.setS2(VectorWritable.readVector(in));}
80f20350a1168909a108171da475cb3d54a531b17708e3f7547288d058148699
configure
public void configure(Configuration job)
{}
a0a1e1740dfa61e3f51aef2d90597a3361d76f17552801f754e73a715f418b2c
getParameters
public Collection<Parameter<?>> getParameters()
{    return Collections.emptyList();}
7205b9fdd8de7b3ade6cb7bd7db44a76f1bb73df3db453299e8820273cdc140b
createParameters
public void createParameters(String prefix, Configuration jobConf)
{}
cea1c2c1f10d4b97004da212612fc3f2159fe44d7c7e24cd3c5e70653f0143a5
getId
public int getId()
{    return id;}
b21c6bbe8b7bf4f7c910e48655e7f994f7b2445440f33c5f468b7bf66d99e4cd
setId
protected void setId(int id)
{    this.id = id;}
82beb3ebb87531f6c09a228b47d1dbbefe5acbee67c073edb97c3e583e6bf4e8
getNumObservations
public long getNumObservations()
{    return numObservations;}
60ca74bd223ead6bb514742f0dd7d9795740502adcc3266e1d4c2110c17b71b5
setNumObservations
protected void setNumObservations(long l)
{    this.numObservations = l;}
2ff5a3f7eba66c09084e8515cfb5fa6f3b428112fc1976b9c86ce37a0c2ebcdc
getTotalObservations
public long getTotalObservations()
{    return totalObservations;}
19e135cb3b8a629257a1d2a940545cd5ba6debe526a462700cc15cf3f4eea07a
setTotalObservations
protected void setTotalObservations(long totalPoints)
{    this.totalObservations = totalPoints;}
d9186c892e616bc2ecadaf50c9ed11c6ecfd6555b60ebf14ca6f785c2bdf8050
getCenter
public Vector getCenter()
{    return center;}
026d6a1eb43fde240b6284fdac0b5c8bbcfd4ac8ce11f86ce992039fd680635b
setCenter
protected void setCenter(Vector center)
{    this.center = center;}
e3a6a02361fe9111079e0abaa98e58e573c5363b669753b67cd0e8c2fecaaea5
getRadius
public Vector getRadius()
{    return radius;}
874103f6c7c93d5a0e9dd8f0797d82eabf0c6ea26223acf1bfbeda7229212795
setRadius
protected void setRadius(Vector radius)
{    this.radius = radius;}
429674a1f12269b7554cdefb8a96de45ab8dfb83ce9b93df10d451d997241bc7
getS0
protected double getS0()
{    return s0;}
1ab96cb33883cf0c1948007bc8727ae23ef25d22d7378b7e58b5c501bab01932
setS0
protected void setS0(double s0)
{    this.s0 = s0;}
c7d80b7cd04e63c8dec849dca4f5d992f4b78dbfccde764bbf1327e95bd448b1
getS1
protected Vector getS1()
{    return s1;}
4cd0a2db88b2258d4336b93d791869d66070b6196a379f4fb511289110e65026
setS1
protected void setS1(Vector s1)
{    this.s1 = s1;}
f4ff1e62ea51f2188762f4452104fa7603a779c98649d7134051c64378d5cc43
getS2
protected Vector getS2()
{    return s2;}
1e6ae4b16cf0f77f2a9ccd7a878f56af0bca218c4fd50ae18f4ddf9d24ee7e34
setS2
protected void setS2(Vector s2)
{    this.s2 = s2;}
8be7c3daf7acbe3a93d3b597a90311c9a25ea97096a26c043257abd7700ef983
observe
public void observe(Model<VectorWritable> x)
{    AbstractCluster cl = (AbstractCluster) x;    setS0(getS0() + cl.getS0());    setS1(getS1().plus(cl.getS1()));    setS2(getS2().plus(cl.getS2()));}
3ca741b244d661245e9c3147a6233b82939e69b4aad5c5f86268c5b2a573d050
observe
public void observe(VectorWritable x)
{    observe(x.get());}
8b66772c8ab3de9cd33e744c4d85c703d73cc4013aca990a7828f61f8dac70a4
observe
public void observe(VectorWritable x, double weight)
{    observe(x.get(), weight);}
92fa48f8580859ec3c47cde408ed98f31dea064305b41eb8ec2afb21be927a03
observe
public void observe(Vector x, double weight)
{    if (weight == 1.0) {        observe(x);    } else {        setS0(getS0() + weight);        Vector weightedX = x.times(weight);        if (getS1() == null) {            setS1(weightedX);        } else {            getS1().assign(weightedX, Functions.PLUS);        }        Vector x2 = x.times(x).times(weight);        if (getS2() == null) {            setS2(x2);        } else {            getS2().assign(x2, Functions.PLUS);        }    }}
7ab6a8202e5d1a079ade8b7567959f36ebfcad570cb2cb2480cf426bc8827d1b
observe
public void observe(Vector x)
{    setS0(getS0() + 1);    if (getS1() == null) {        setS1(x.clone());    } else {        getS1().assign(x, Functions.PLUS);    }    Vector x2 = x.times(x);    if (getS2() == null) {        setS2(x2);    } else {        getS2().assign(x2, Functions.PLUS);    }}
1a0b718932893fece0ab0b667f65d599c7fe05111d46b8f486b1fea7b7c90709
computeParameters
public void computeParameters()
{    if (getS0() == 0) {        return;    }    setNumObservations((long) getS0());    setTotalObservations(getTotalObservations() + getNumObservations());    setCenter(getS1().divide(getS0()));        if (getS0() > 1) {        setRadius(getS2().times(getS0()).minus(getS1().times(getS1())).assign(new SquareRootFunction()).divide(getS0()));    }    setS0(0);    setS1(center.like());    setS2(center.like());}
0f1f9b94bf5643e8808706c3a51d8b83c57aa6ab170e60dae86b31386e0bc867
asFormatString
public String asFormatString(String[] bindings)
{    String fmtString = "";    try {        fmtString = jxn.writeValueAsString(asJson(bindings));    } catch (IOException e) {        log.error("Error writing JSON as String.", e);    }    return fmtString;}
6bfbc3e7d6b595e88efb759947826ecd1148f2e6817b1183837f62be645bf9df
asJson
public Map<String, Object> asJson(String[] bindings)
{    Map<String, Object> dict = new HashMap<>();    dict.put("identifier", getIdentifier());    dict.put("n", getNumObservations());    if (getCenter() != null) {        try {            dict.put("c", formatVectorAsJson(getCenter(), bindings));        } catch (IOException e) {            log.error("IOException:  ", e);        }    }    if (getRadius() != null) {        try {            dict.put("r", formatVectorAsJson(getRadius(), bindings));        } catch (IOException e) {            log.error("IOException:  ", e);        }    }    return dict;}
8056838a706acda9744a633d814fd26984dc1a0d407ad1ac88b05d3e91c8b18e
computeCentroid
public Vector computeCentroid()
{    return getS0() == 0 ? getCenter() : getS1().divide(getS0());}
08fba7cce456e0c11b10047d121b1dc77ed8250c81838dd8be91a9c446588cac
formatVector
public static String formatVector(Vector v, String[] bindings)
{    String fmtString = "";    try {        fmtString = jxn.writeValueAsString(formatVectorAsJson(v, bindings));    } catch (IOException e) {        log.error("Error writing JSON as String.", e);    }    return fmtString;}
b5c1fc364f117bce41c82fa5ba5e4d552826c976ff259609f825a656ee71d9b0
formatVectorAsJson
public static List<Object> formatVectorAsJson(Vector v, String[] bindings) throws IOException
{    boolean hasBindings = bindings != null;    boolean isSparse = v.getNumNonZeroElements() != v.size();        Vector provider = v.isSequentialAccess() ? v : new SequentialAccessSparseVector(v);    List<Object> terms = new LinkedList<>();    String term = "";    for (Element elem : provider.nonZeroes()) {        if (hasBindings && bindings.length >= elem.index() + 1 && bindings[elem.index()] != null) {            term = bindings[elem.index()];        } else if (hasBindings || isSparse) {            term = String.valueOf(elem.index());        }        Map<String, Object> term_entry = new HashMap<>();        double roundedWeight = (double) Math.round(elem.get() * 1000) / 1000;        if (hasBindings || isSparse) {            term_entry.put(term, roundedWeight);            terms.add(term_entry);        } else {            terms.add(roundedWeight);        }    }    return terms;}
83c4ad32365335fe928afb9dcdb6aea3fbd28b3282bb7e9b60b2eeea4073a9bf
isConverged
public boolean isConverged()
{        return false;}
ae284afe1ade5afe0242f68b99b1251c8ef4ebfb1ffd6eaa841c8d273ed0c131
asFormatString
public String asFormatString()
{    return "C" + this.getId() + ": " + this.computeCentroid().asFormatString();}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return getIdentifier() + ": " + getCenter().asFormatString();}
58bd96f144f5615a71b3c07015b2823c398f6cbeddbd1f5b812bce20ce6f7e56
getIdentifier
public String getIdentifier()
{    return "C-" + getId();}
f6dc8d64816406d3e689bca9d707be2eb3d67da370b6d26954b7edce04dc99a1
getT1
public double getT1()
{    return t1;}
d743ce67bf8f41740de875842a27357908b83360c5adb02d04575d1294e708c1
getT2
public double getT2()
{    return t2;}
62fbc82597152307e87f008022e6c16d4ba874f7e22457efd6c8e2a34c893dc0
getT3
public double getT3()
{    return t3;}
15ad8d8633931c091d93ad43b360b4b43cda29f8627da2c79dbf4a8ca1a4db67
getT4
public double getT4()
{    return t4;}
fd5404fbd49ae57fb7fb7b446fd6aa73e9deff4a69f715a069a210bd22ea1558
useT3T4
public void useT3T4()
{    t1 = t3;    t2 = t4;}
894f728d0070caf46ea61575e934100ceaf35fe73519db17fd0b7fc5774a9fb6
addPointToCanopies
public void addPointToCanopies(Vector point, Collection<Canopy> canopies)
{    boolean pointStronglyBound = false;    for (Canopy canopy : canopies) {        double dist = measure.distance(canopy.getCenter().getLengthSquared(), canopy.getCenter(), point);        if (dist < t1) {            if (log.isDebugEnabled()) {                log.debug("Added point: {} to canopy: {}", AbstractCluster.formatVector(point, null), canopy.getIdentifier());            }            canopy.observe(point);        }        pointStronglyBound = pointStronglyBound || dist < t2;    }    if (!pointStronglyBound) {        if (log.isDebugEnabled()) {            log.debug("Created new Canopy:{} at center:{}", nextCanopyId, AbstractCluster.formatVector(point, null));        }        canopies.add(new Canopy(point, nextCanopyId++, measure));    }}
93cfad8d5b6593d0b5b39681b8662a1cc0b64ee9c53665e8e997dd5256886409
canopyCovers
public boolean canopyCovers(Canopy canopy, Vector point)
{    return measure.distance(canopy.getCenter().getLengthSquared(), canopy.getCenter(), point) < t1;}
cf2ba1d11d153188346d3cf7677fc2b602eb84de20bfe5ba144e370660310e3d
createCanopies
public static List<Canopy> createCanopies(List<Vector> points, DistanceMeasure measure, double t1, double t2)
{    List<Canopy> canopies = Lists.newArrayList();    /**     * Reference Implementation: Given a distance metric, one can create     * canopies as follows: Start with a list of the data points in any     * order, and with two distance thresholds, T1 and T2, where T1 > T2.     * (These thresholds can be set by the user, or selected by     * cross-validation.) Pick a point on the list and measure its distance     * to all other points. Put all points that are within distance     * threshold T1 into a canopy. Remove from the list all points that are     * within distance threshold T2. Repeat until the list is empty.     */    int nextCanopyId = 0;    while (!points.isEmpty()) {        Iterator<Vector> ptIter = points.iterator();        Vector p1 = ptIter.next();        ptIter.remove();        Canopy canopy = new Canopy(p1, nextCanopyId++, measure);        canopies.add(canopy);        while (ptIter.hasNext()) {            Vector p2 = ptIter.next();            double dist = measure.distance(p1, p2);                        if (dist < t1) {                canopy.observe(p2);            }                        if (dist < t2) {                ptIter.remove();            }        }        for (Canopy c : canopies) {            c.computeParameters();        }    }    return canopies;}
8e1fa24044e62bf1cd80f220ad2b0d4f887ab2bf3e1bd2fbc0eff6b784f5ca69
getCenters
public static List<Vector> getCenters(Iterable<Canopy> canopies)
{    List<Vector> result = Lists.newArrayList();    for (Canopy canopy : canopies) {        result.add(canopy.getCenter());    }    return result;}
94db0195a15b0cef8350b026286116399294dcd22cdeb9ef8122b09c851fe0e7
updateCentroids
public static void updateCentroids(Iterable<Canopy> canopies)
{    for (Canopy canopy : canopies) {        canopy.computeParameters();    }}
1b9317ec2ae64cf5124e87d3302bfd4187e3b4d71c16f71415dd3011cf98e191
setT3
public void setT3(double t3)
{    this.t3 = t3;}
ea8fc6a1532d9c7e6cee19a5f1d6835e9a2a08897c68ae972a23b75192eb270f
setT4
public void setT4(double t4)
{    this.t4 = t4;}
610cf7ee068a273c9dbcd6a7666058a4851699ff9db6846725445172e6d6bc56
configureCanopyClusterer
public static CanopyClusterer configureCanopyClusterer(Configuration configuration)
{    double t1 = Double.parseDouble(configuration.get(T1_KEY));    double t2 = Double.parseDouble(configuration.get(T2_KEY));    DistanceMeasure measure = ClassUtils.instantiateAs(configuration.get(DISTANCE_MEASURE_KEY), DistanceMeasure.class);    measure.configure(configuration);    CanopyClusterer canopyClusterer = new CanopyClusterer(measure, t1, t2);    String d = configuration.get(T3_KEY);    if (d != null) {        canopyClusterer.setT3(Double.parseDouble(d));    }    d = configuration.get(T4_KEY);    if (d != null) {        canopyClusterer.setT4(Double.parseDouble(d));    }    return canopyClusterer;}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    ToolRunner.run(new Configuration(), new CanopyDriver(), args);}
aacecb0f01750d985b78d806dc3c134f0da79efe2752957e0f93ecf5cbf9e492
run
public int run(String[] args) throws Exception
{    addInputOption();    addOutputOption();    addOption(DefaultOptionCreator.distanceMeasureOption().create());    addOption(DefaultOptionCreator.t1Option().create());    addOption(DefaultOptionCreator.t2Option().create());    addOption(DefaultOptionCreator.t3Option().create());    addOption(DefaultOptionCreator.t4Option().create());    addOption(DefaultOptionCreator.clusterFilterOption().create());    addOption(DefaultOptionCreator.overwriteOption().create());    addOption(DefaultOptionCreator.clusteringOption().create());    addOption(DefaultOptionCreator.methodOption().create());    addOption(DefaultOptionCreator.outlierThresholdOption().create());    if (parseArguments(args) == null) {        return -1;    }    Path input = getInputPath();    Path output = getOutputPath();    Configuration conf = getConf();    if (hasOption(DefaultOptionCreator.OVERWRITE_OPTION)) {        HadoopUtil.delete(conf, output);    }    String measureClass = getOption(DefaultOptionCreator.DISTANCE_MEASURE_OPTION);    double t1 = Double.parseDouble(getOption(DefaultOptionCreator.T1_OPTION));    double t2 = Double.parseDouble(getOption(DefaultOptionCreator.T2_OPTION));    double t3 = t1;    if (hasOption(DefaultOptionCreator.T3_OPTION)) {        t3 = Double.parseDouble(getOption(DefaultOptionCreator.T3_OPTION));    }    double t4 = t2;    if (hasOption(DefaultOptionCreator.T4_OPTION)) {        t4 = Double.parseDouble(getOption(DefaultOptionCreator.T4_OPTION));    }    int clusterFilter = 0;    if (hasOption(DefaultOptionCreator.CLUSTER_FILTER_OPTION)) {        clusterFilter = Integer.parseInt(getOption(DefaultOptionCreator.CLUSTER_FILTER_OPTION));    }    boolean runClustering = hasOption(DefaultOptionCreator.CLUSTERING_OPTION);    boolean runSequential = getOption(DefaultOptionCreator.METHOD_OPTION).equalsIgnoreCase(DefaultOptionCreator.SEQUENTIAL_METHOD);    DistanceMeasure measure = ClassUtils.instantiateAs(measureClass, DistanceMeasure.class);    double clusterClassificationThreshold = 0.0;    if (hasOption(DefaultOptionCreator.OUTLIER_THRESHOLD)) {        clusterClassificationThreshold = Double.parseDouble(getOption(DefaultOptionCreator.OUTLIER_THRESHOLD));    }    run(conf, input, output, measure, t1, t2, t3, t4, clusterFilter, runClustering, clusterClassificationThreshold, runSequential);    return 0;}
88b135231c0105974b5c864b11acfc229590deae8fb17b1fbc3758e0bb353445
run
public static void run(Configuration conf, Path input, Path output, DistanceMeasure measure, double t1, double t2, double t3, double t4, int clusterFilter, boolean runClustering, double clusterClassificationThreshold, boolean runSequential) throws IOException, InterruptedException, ClassNotFoundException
{    Path clustersOut = buildClusters(conf, input, output, measure, t1, t2, t3, t4, clusterFilter, runSequential);    if (runClustering) {        clusterData(conf, input, clustersOut, output, clusterClassificationThreshold, runSequential);    }}
407613d7e3bec2b724ecb1a119483f7001199966babfaabe3d12e565e30b30d4
run
public static void run(Configuration conf, Path input, Path output, DistanceMeasure measure, double t1, double t2, boolean runClustering, double clusterClassificationThreshold, boolean runSequential) throws IOException, InterruptedException, ClassNotFoundException
{    run(conf, input, output, measure, t1, t2, t1, t2, 0, runClustering, clusterClassificationThreshold, runSequential);}
e9c9928991c0353191f01761dd0674614a6439af3a267a6f844d9382ace1859f
run
public static void run(Path input, Path output, DistanceMeasure measure, double t1, double t2, boolean runClustering, double clusterClassificationThreshold, boolean runSequential) throws IOException, InterruptedException, ClassNotFoundException
{    run(new Configuration(), input, output, measure, t1, t2, runClustering, clusterClassificationThreshold, runSequential);}
c3d936aa34599d66c7daa82b66f486bd48972337d54b67cdf14e73a6770850c4
buildClusters
public static Path buildClusters(Configuration conf, Path input, Path output, DistanceMeasure measure, double t1, double t2, int clusterFilter, boolean runSequential) throws IOException, InterruptedException, ClassNotFoundException
{    return buildClusters(conf, input, output, measure, t1, t2, t1, t2, clusterFilter, runSequential);}
3049c474d2875c68c245c2e57876e19cfe3d36750024fab4e965572d0bf92d94
buildClusters
public static Path buildClusters(Configuration conf, Path input, Path output, DistanceMeasure measure, double t1, double t2, double t3, double t4, int clusterFilter, boolean runSequential) throws IOException, InterruptedException, ClassNotFoundException
{    log.info("Build Clusters Input: {} Out: {} Measure: {} t1: {} t2: {}", input, output, measure, t1, t2);    if (runSequential) {        return buildClustersSeq(input, output, measure, t1, t2, clusterFilter);    } else {        return buildClustersMR(conf, input, output, measure, t1, t2, t3, t4, clusterFilter);    }}
86a2f5a7da64ec59ae8d5a109e5ac0ac7932829f72e1d18b4bc1bfe35e5c72cf
buildClustersSeq
private static Path buildClustersSeq(Path input, Path output, DistanceMeasure measure, double t1, double t2, int clusterFilter) throws IOException
{    CanopyClusterer clusterer = new CanopyClusterer(measure, t1, t2);    Collection<Canopy> canopies = Lists.newArrayList();    Configuration conf = new Configuration();    FileSystem fs = FileSystem.get(input.toUri(), conf);    for (VectorWritable vw : new SequenceFileDirValueIterable<VectorWritable>(input, PathType.LIST, PathFilters.logsCRCFilter(), conf)) {        clusterer.addPointToCanopies(vw.get(), canopies);    }    Path canopyOutputDir = new Path(output, Cluster.CLUSTERS_DIR + '0' + Cluster.FINAL_ITERATION_SUFFIX);    Path path = new Path(canopyOutputDir, "part-r-00000");    SequenceFile.Writer writer = new SequenceFile.Writer(fs, conf, path, Text.class, ClusterWritable.class);    try {        ClusterWritable clusterWritable = new ClusterWritable();        for (Canopy canopy : canopies) {            canopy.computeParameters();            if (log.isDebugEnabled()) {                log.debug("Writing Canopy:{} center:{} numPoints:{} radius:{}", canopy.getIdentifier(), AbstractCluster.formatVector(canopy.getCenter(), null), canopy.getNumObservations(), AbstractCluster.formatVector(canopy.getRadius(), null));            }            if (canopy.getNumObservations() > clusterFilter) {                clusterWritable.setValue(canopy);                writer.append(new Text(canopy.getIdentifier()), clusterWritable);            }        }    } finally {        Closeables.close(writer, false);    }    return canopyOutputDir;}
d2ac24b6b4d5f6f088cf9a623e065d55325ac894afa04449e79e2ed4dc192e71
buildClustersMR
private static Path buildClustersMR(Configuration conf, Path input, Path output, DistanceMeasure measure, double t1, double t2, double t3, double t4, int clusterFilter) throws IOException, InterruptedException, ClassNotFoundException
{    conf.set(CanopyConfigKeys.DISTANCE_MEASURE_KEY, measure.getClass().getName());    conf.set(CanopyConfigKeys.T1_KEY, String.valueOf(t1));    conf.set(CanopyConfigKeys.T2_KEY, String.valueOf(t2));    conf.set(CanopyConfigKeys.T3_KEY, String.valueOf(t3));    conf.set(CanopyConfigKeys.T4_KEY, String.valueOf(t4));    conf.set(CanopyConfigKeys.CF_KEY, String.valueOf(clusterFilter));    Job job = new Job(conf, "Canopy Driver running buildClusters over input: " + input);    job.setInputFormatClass(SequenceFileInputFormat.class);    job.setOutputFormatClass(SequenceFileOutputFormat.class);    job.setMapperClass(CanopyMapper.class);    job.setMapOutputKeyClass(Text.class);    job.setMapOutputValueClass(VectorWritable.class);    job.setReducerClass(CanopyReducer.class);    job.setOutputKeyClass(Text.class);    job.setOutputValueClass(ClusterWritable.class);    job.setNumReduceTasks(1);    job.setJarByClass(CanopyDriver.class);    FileInputFormat.addInputPath(job, input);    Path canopyOutputDir = new Path(output, Cluster.CLUSTERS_DIR + '0' + Cluster.FINAL_ITERATION_SUFFIX);    FileOutputFormat.setOutputPath(job, canopyOutputDir);    if (!job.waitForCompletion(true)) {        throw new InterruptedException("Canopy Job failed processing " + input);    }    return canopyOutputDir;}
4e77d014f6005ef3a86dd4763facd291015bd4ffed60d88c2df414baecc1d2a0
clusterData
private static void clusterData(Configuration conf, Path points, Path canopies, Path output, double clusterClassificationThreshold, boolean runSequential) throws IOException, InterruptedException, ClassNotFoundException
{    ClusterClassifier.writePolicy(new CanopyClusteringPolicy(), canopies);    ClusterClassificationDriver.run(conf, points, output, new Path(output, PathDirectory.CLUSTERED_POINTS_DIRECTORY), clusterClassificationThreshold, true, runSequential);}
b125895727153a1758a5a9ebfc6d928776a04a8584e4239f8dce6f37db942e09
map
protected void map(WritableComparable<?> key, VectorWritable point, Context context) throws IOException, InterruptedException
{    canopyClusterer.addPointToCanopies(point.get(), canopies);}
6b7dd49be7482fc8ee0fbe8bd0f24522f2a718c8c816a3d7b048fb4688eb6373
setup
protected void setup(Context context) throws IOException, InterruptedException
{    super.setup(context);    canopyClusterer = CanopyConfigKeys.configureCanopyClusterer(context.getConfiguration());    clusterFilter = Integer.parseInt(context.getConfiguration().get(CanopyConfigKeys.CF_KEY));}
2e250b70eb1261a97967b8b894cf822fc9e7eb36891dbb77c6d16369f85de12a
cleanup
protected void cleanup(Context context) throws IOException, InterruptedException
{    for (Canopy canopy : canopies) {        canopy.computeParameters();        if (canopy.getNumObservations() > clusterFilter) {            context.write(new Text("centroid"), new VectorWritable(canopy.getCenter()));        }    }    super.cleanup(context);}
ce9ad7056f3bcf178d5a538478533113120bda9f10cb551c2fe46afda2a54f7e
getCanopyClusterer
 CanopyClusterer getCanopyClusterer()
{    return canopyClusterer;}
d8f8a4d935af8674537cca287d49a8b78e257df39f8fe02b03ee52e10b0a78d3
reduce
protected void reduce(Text arg0, Iterable<VectorWritable> values, Context context) throws IOException, InterruptedException
{    for (VectorWritable value : values) {        Vector point = value.get();        canopyClusterer.addPointToCanopies(point, canopies);    }    for (Canopy canopy : canopies) {        canopy.computeParameters();        if (canopy.getNumObservations() > clusterFilter) {            ClusterWritable clusterWritable = new ClusterWritable();            clusterWritable.setValue(canopy);            context.write(new Text(canopy.getIdentifier()), clusterWritable);        }    }}
6b7dd49be7482fc8ee0fbe8bd0f24522f2a718c8c816a3d7b048fb4688eb6373
setup
protected void setup(Context context) throws IOException, InterruptedException
{    super.setup(context);    canopyClusterer = CanopyConfigKeys.configureCanopyClusterer(context.getConfiguration());    canopyClusterer.useT3T4();    clusterFilter = Integer.parseInt(context.getConfiguration().get(CanopyConfigKeys.CF_KEY));}
aacecb0f01750d985b78d806dc3c134f0da79efe2752957e0f93ecf5cbf9e492
run
public int run(String[] args) throws Exception
{    addInputOption();    addOutputOption();    addOption(DefaultOptionCreator.methodOption().create());    addOption(DefaultOptionCreator.clustersInOption().withDescription("The input centroids, as Vectors.  Must be a SequenceFile of Writable, Cluster/Canopy.").create());    if (parseArguments(args) == null) {        return -1;    }    Path input = getInputPath();    Path output = getOutputPath();    if (getConf() == null) {        setConf(new Configuration());    }    Path clustersIn = new Path(getOption(DefaultOptionCreator.CLUSTERS_IN_OPTION));    boolean runSequential = getOption(DefaultOptionCreator.METHOD_OPTION).equalsIgnoreCase(DefaultOptionCreator.SEQUENTIAL_METHOD);    double clusterClassificationThreshold = 0.0;    if (hasOption(DefaultOptionCreator.OUTLIER_THRESHOLD)) {        clusterClassificationThreshold = Double.parseDouble(getOption(DefaultOptionCreator.OUTLIER_THRESHOLD));    }    run(getConf(), input, clustersIn, output, clusterClassificationThreshold, true, runSequential);    return 0;}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    ToolRunner.run(new Configuration(), new ClusterClassificationDriver(), args);}
a5f1a0ad03a5b4d290a493505d87bee113a3a67af3c84153f2b6d9294a1fb6b7
run
public static void run(Configuration conf, Path input, Path clusteringOutputPath, Path output, Double clusterClassificationThreshold, boolean emitMostLikely, boolean runSequential) throws IOException, InterruptedException, ClassNotFoundException
{    if (runSequential) {        classifyClusterSeq(conf, input, clusteringOutputPath, output, clusterClassificationThreshold, emitMostLikely);    } else {        classifyClusterMR(conf, input, clusteringOutputPath, output, clusterClassificationThreshold, emitMostLikely);    }}
d6e37ecc9af40bb2fdb4d962a3e234c16fb9ccb0c60ba7ab9806ef309508ba63
classifyClusterSeq
private static void classifyClusterSeq(Configuration conf, Path input, Path clusters, Path output, Double clusterClassificationThreshold, boolean emitMostLikely) throws IOException
{    List<Cluster> clusterModels = populateClusterModels(clusters, conf);    ClusteringPolicy policy = ClusterClassifier.readPolicy(finalClustersPath(conf, clusters));    ClusterClassifier clusterClassifier = new ClusterClassifier(clusterModels, policy);    selectCluster(input, clusterModels, clusterClassifier, output, clusterClassificationThreshold, emitMostLikely);}
a0bfff5dc2ced7250a0e1bebfb40f61748fd8a40265f964b408b9154478bfff0
populateClusterModels
private static List<Cluster> populateClusterModels(Path clusterOutputPath, Configuration conf) throws IOException
{    List<Cluster> clusterModels = new ArrayList<>();    Path finalClustersPath = finalClustersPath(conf, clusterOutputPath);    Iterator<?> it = new SequenceFileDirValueIterator<>(finalClustersPath, PathType.LIST, PathFilters.partFilter(), null, false, conf);    while (it.hasNext()) {        ClusterWritable next = (ClusterWritable) it.next();        Cluster cluster = next.getValue();        cluster.configure(conf);        clusterModels.add(cluster);    }    return clusterModels;}
e2ac9a81013cf4ee900ef7706bfe6e97165ac22002f74046ca6468a9dbdf1fb5
finalClustersPath
private static Path finalClustersPath(Configuration conf, Path clusterOutputPath) throws IOException
{    FileSystem fileSystem = clusterOutputPath.getFileSystem(conf);    FileStatus[] clusterFiles = fileSystem.listStatus(clusterOutputPath, PathFilters.finalPartFilter());    return clusterFiles[0].getPath();}
48281fb95177a151bd9880c60a966cc6104ec88cf487d6b80ec319bc529f0e6a
selectCluster
private static void selectCluster(Path input, List<Cluster> clusterModels, ClusterClassifier clusterClassifier, Path output, Double clusterClassificationThreshold, boolean emitMostLikely) throws IOException
{    Configuration conf = new Configuration();    SequenceFile.Writer writer = new SequenceFile.Writer(input.getFileSystem(conf), conf, new Path(output, "part-m-" + 0), IntWritable.class, WeightedPropertyVectorWritable.class);    for (Pair<Writable, VectorWritable> vw : new SequenceFileDirIterable<Writable, VectorWritable>(input, PathType.LIST, PathFilters.logsCRCFilter(), conf)) {                        Class<? extends Writable> keyClass = vw.getFirst().getClass();        Vector vector = vw.getSecond().get();        if (!keyClass.equals(NamedVector.class)) {            if (keyClass.equals(Text.class)) {                vector = new NamedVector(vector, vw.getFirst().toString());            } else if (keyClass.equals(IntWritable.class)) {                vector = new NamedVector(vector, Integer.toString(((IntWritable) vw.getFirst()).get()));            }        }        Vector pdfPerCluster = clusterClassifier.classify(vector);        if (shouldClassify(pdfPerCluster, clusterClassificationThreshold)) {            classifyAndWrite(clusterModels, clusterClassificationThreshold, emitMostLikely, writer, new VectorWritable(vector), pdfPerCluster);        }    }    writer.close();}
bce5d97a11d6b2ce01a934c207066fea815774c11a7148e15031e3376e463c53
classifyAndWrite
private static void classifyAndWrite(List<Cluster> clusterModels, Double clusterClassificationThreshold, boolean emitMostLikely, SequenceFile.Writer writer, VectorWritable vw, Vector pdfPerCluster) throws IOException
{    Map<Text, Text> props = new HashMap<>();    if (emitMostLikely) {        int maxValueIndex = pdfPerCluster.maxValueIndex();        WeightedPropertyVectorWritable weightedPropertyVectorWritable = new WeightedPropertyVectorWritable(pdfPerCluster.maxValue(), vw.get(), props);        write(clusterModels, writer, weightedPropertyVectorWritable, maxValueIndex);    } else {        writeAllAboveThreshold(clusterModels, clusterClassificationThreshold, writer, vw, pdfPerCluster);    }}
7ec20396f4c94bf967e71afcad671a06dfa0490e09f40ae49a8bdfe54e19638a
writeAllAboveThreshold
private static void writeAllAboveThreshold(List<Cluster> clusterModels, Double clusterClassificationThreshold, SequenceFile.Writer writer, VectorWritable vw, Vector pdfPerCluster) throws IOException
{    Map<Text, Text> props = new HashMap<>();    for (Element pdf : pdfPerCluster.nonZeroes()) {        if (pdf.get() >= clusterClassificationThreshold) {            WeightedPropertyVectorWritable wvw = new WeightedPropertyVectorWritable(pdf.get(), vw.get(), props);            int clusterIndex = pdf.index();            write(clusterModels, writer, wvw, clusterIndex);        }    }}
4da0b53b4d2789c13a9b7ee38974bd0de6b58dff0d0ba00d758386ed120006fe
write
private static void write(List<Cluster> clusterModels, SequenceFile.Writer writer, WeightedPropertyVectorWritable weightedPropertyVectorWritable, int maxValueIndex) throws IOException
{    Cluster cluster = clusterModels.get(maxValueIndex);    DistanceMeasureCluster distanceMeasureCluster = (DistanceMeasureCluster) cluster;    DistanceMeasure distanceMeasure = distanceMeasureCluster.getMeasure();    double distance = distanceMeasure.distance(cluster.getCenter(), weightedPropertyVectorWritable.getVector());    weightedPropertyVectorWritable.getProperties().put(new Text("distance"), new Text(Double.toString(distance)));    writer.append(new IntWritable(cluster.getId()), weightedPropertyVectorWritable);}
58877d6120ee993db2bddda107241b9a130e9bc2fbffc61483671cea902b814a
shouldClassify
private static boolean shouldClassify(Vector pdfPerCluster, Double clusterClassificationThreshold)
{    return pdfPerCluster.maxValue() >= clusterClassificationThreshold;}
481d980129790d20c014b3c9bdb3e06c5b3a1e37993ed76df09d0cf300fd8d71
classifyClusterMR
private static void classifyClusterMR(Configuration conf, Path input, Path clustersIn, Path output, Double clusterClassificationThreshold, boolean emitMostLikely) throws IOException, InterruptedException, ClassNotFoundException
{    conf.setFloat(ClusterClassificationConfigKeys.OUTLIER_REMOVAL_THRESHOLD, clusterClassificationThreshold.floatValue());    conf.setBoolean(ClusterClassificationConfigKeys.EMIT_MOST_LIKELY, emitMostLikely);    conf.set(ClusterClassificationConfigKeys.CLUSTERS_IN, clustersIn.toUri().toString());    Job job = new Job(conf, "Cluster Classification Driver running over input: " + input);    job.setJarByClass(ClusterClassificationDriver.class);    job.setInputFormatClass(SequenceFileInputFormat.class);    job.setOutputFormatClass(SequenceFileOutputFormat.class);    job.setMapperClass(ClusterClassificationMapper.class);    job.setNumReduceTasks(0);    job.setOutputKeyClass(IntWritable.class);    job.setOutputValueClass(WeightedPropertyVectorWritable.class);    FileInputFormat.addInputPath(job, input);    FileOutputFormat.setOutputPath(job, output);    if (!job.waitForCompletion(true)) {        throw new InterruptedException("Cluster Classification Driver Job failed processing " + input);    }}
6ec9f0cf2032f75db88ed9e86ca73419e0eeb7b7996fad8904ad2b1112ea0bc0
run
public static void run(Configuration conf, Path input, Path clusteringOutputPath, Path output, double clusterClassificationThreshold, boolean emitMostLikely, boolean runSequential) throws IOException, InterruptedException, ClassNotFoundException
{    if (runSequential) {        classifyClusterSeq(conf, input, clusteringOutputPath, output, clusterClassificationThreshold, emitMostLikely);    } else {        classifyClusterMR(conf, input, clusteringOutputPath, output, clusterClassificationThreshold, emitMostLikely);    }}
6b7dd49be7482fc8ee0fbe8bd0f24522f2a718c8c816a3d7b048fb4688eb6373
setup
protected void setup(Context context) throws IOException, InterruptedException
{    super.setup(context);    Configuration conf = context.getConfiguration();    String clustersIn = conf.get(ClusterClassificationConfigKeys.CLUSTERS_IN);    threshold = conf.getFloat(ClusterClassificationConfigKeys.OUTLIER_REMOVAL_THRESHOLD, 0.0f);    emitMostLikely = conf.getBoolean(ClusterClassificationConfigKeys.EMIT_MOST_LIKELY, false);    clusterModels = new ArrayList<>();    if (clustersIn != null && !clustersIn.isEmpty()) {        Path clustersInPath = new Path(clustersIn);        clusterModels = populateClusterModels(clustersInPath, conf);        ClusteringPolicy policy = ClusterClassifier.readPolicy(finalClustersPath(clustersInPath));        clusterClassifier = new ClusterClassifier(clusterModels, policy);    }    clusterId = new IntWritable();}
72fd62c59760bf02f45681512133fae491184a16d5345aefc846ee708b56d60e
map
protected void map(WritableComparable<?> key, VectorWritable vw, Context context) throws IOException, InterruptedException
{    if (!clusterModels.isEmpty()) {                        Class<? extends Vector> vectorClass = vw.get().getClass();        Vector vector = vw.get();        if (!vectorClass.equals(NamedVector.class)) {            if (key.getClass().equals(Text.class)) {                vector = new NamedVector(vector, key.toString());            } else if (key.getClass().equals(IntWritable.class)) {                vector = new NamedVector(vector, Integer.toString(((IntWritable) key).get()));            }        }        Vector pdfPerCluster = clusterClassifier.classify(vector);        if (shouldClassify(pdfPerCluster)) {            if (emitMostLikely) {                int maxValueIndex = pdfPerCluster.maxValueIndex();                write(new VectorWritable(vector), context, maxValueIndex, 1.0);            } else {                writeAllAboveThreshold(new VectorWritable(vector), context, pdfPerCluster);            }        }    }}
2d6e82b9f5650b580b28d09957a24896348d4eb9f329467d8d20129310e37f35
writeAllAboveThreshold
private void writeAllAboveThreshold(VectorWritable vw, Context context, Vector pdfPerCluster) throws IOException, InterruptedException
{    for (Element pdf : pdfPerCluster.nonZeroes()) {        if (pdf.get() >= threshold) {            int clusterIndex = pdf.index();            write(vw, context, clusterIndex, pdf.get());        }    }}
90070324c67b9cc466bf4be629fd18d33a78ba80308ef1d82d975a667465cd54
write
private void write(VectorWritable vw, Context context, int clusterIndex, double weight) throws IOException, InterruptedException
{    Cluster cluster = clusterModels.get(clusterIndex);    clusterId.set(cluster.getId());    DistanceMeasureCluster distanceMeasureCluster = (DistanceMeasureCluster) cluster;    DistanceMeasure distanceMeasure = distanceMeasureCluster.getMeasure();    double distance = distanceMeasure.distance(cluster.getCenter(), vw.get());    Map<Text, Text> props = new HashMap<>();    props.put(new Text("distance"), new Text(Double.toString(distance)));    context.write(clusterId, new WeightedPropertyVectorWritable(weight, vw.get(), props));}
846e66b69fbb7382c70f842af122d7bddf87d16543a59889367b722669def032
populateClusterModels
public static List<Cluster> populateClusterModels(Path clusterOutputPath, Configuration conf) throws IOException
{    List<Cluster> clusters = new ArrayList<>();    FileSystem fileSystem = clusterOutputPath.getFileSystem(conf);    FileStatus[] clusterFiles = fileSystem.listStatus(clusterOutputPath, PathFilters.finalPartFilter());    Iterator<?> it = new SequenceFileDirValueIterator<>(clusterFiles[0].getPath(), PathType.LIST, PathFilters.partFilter(), null, false, conf);    while (it.hasNext()) {        ClusterWritable next = (ClusterWritable) it.next();        Cluster cluster = next.getValue();        cluster.configure(conf);        clusters.add(cluster);    }    return clusters;}
f270be56a4c7bbba47363a7eaa7e93a4df5307184b32e708d0b5879bc6bd8fac
shouldClassify
private boolean shouldClassify(Vector pdfPerCluster)
{    return pdfPerCluster.maxValue() >= threshold;}
f21aa5aa57cd9f14b9102f990de2aa372b844b0499f33809917e19e72c296653
finalClustersPath
private static Path finalClustersPath(Path clusterOutputPath) throws IOException
{    FileSystem fileSystem = clusterOutputPath.getFileSystem(new Configuration());    FileStatus[] clusterFiles = fileSystem.listStatus(clusterOutputPath, PathFilters.finalPartFilter());    return clusterFiles[0].getPath();}
a65d353603d9c6fa69fa946675f753b9e8fcbd94f8ccaeab6425adab7d1af7ba
classify
public Vector classify(Vector instance)
{    return policy.classify(instance, this);}
26ad6f4b0cd93ee65196cb117ed56b25c67c201f8283b12a24dbe4c622a5a362
classifyScalar
public double classifyScalar(Vector instance)
{    if (models.size() == 2) {        double pdf0 = models.get(0).pdf(new VectorWritable(instance));        double pdf1 = models.get(1).pdf(new VectorWritable(instance));        return pdf0 / (pdf0 + pdf1);    }    throw new IllegalStateException();}
0bdeb79fe74c02804b0b53b9a99db42b7e41e4a28e6e703c32648791e7032088
numCategories
public int numCategories()
{    return models.size();}
a894510dd4db439ff8e17ae1059489dc3abc97178e5932ceed0c70c3af165401
write
public void write(DataOutput out) throws IOException
{    out.writeInt(models.size());    out.writeUTF(modelClass);    new ClusteringPolicyWritable(policy).write(out);    for (Cluster cluster : models) {        cluster.write(out);    }}
5478cc5683f6dfd4515c383752d7c803555efc63d03fd84a03ba8dcd17eb4324
readFields
public void readFields(DataInput in) throws IOException
{    int size = in.readInt();    modelClass = in.readUTF();    models = new ArrayList<>();    ClusteringPolicyWritable clusteringPolicyWritable = new ClusteringPolicyWritable();    clusteringPolicyWritable.readFields(in);    policy = clusteringPolicyWritable.getValue();    for (int i = 0; i < size; i++) {        Cluster element = ClassUtils.instantiateAs(modelClass, Cluster.class);        element.readFields(in);        models.add(element);    }}
ecc6f64b0a839651cb9eb6f6925f645a77e15f44cd48611cfa9da8168f00ff18
train
public void train(int actual, Vector instance)
{    models.get(actual).observe(new VectorWritable(instance));}
5ee3a29f22545fbd33d418487f15a4dcee8cd9cd39ba1c6b0ed6885abe7a3f80
train
public void train(int actual, Vector data, double weight)
{    models.get(actual).observe(new VectorWritable(data), weight);}
9d4edf7bd694e762788702e48c71d41d687d0473faa8bf5c051f3c74621df2dc
train
public void train(long trackingKey, String groupKey, int actual, Vector instance)
{    models.get(actual).observe(new VectorWritable(instance));}
4b559a17ddb4da56ecccbda13ac676e16b4711323497a0ebddd40395eef13b96
train
public void train(long trackingKey, int actual, Vector instance)
{    models.get(actual).observe(new VectorWritable(instance));}
5df6118bc0e745d8b18e0a6a99b2e3f2ddba8140cbeb1423ce2df50a9f140574
close
public void close()
{    policy.close(this);}
8c92c2989b7e6098a731f10b907f8b3dd285ba1f9c0c9c7972fd460df471d207
getModels
public List<Cluster> getModels()
{    return models;}
442cfd439250f63b0266d162d9fb0b97fe512ced728ab0de02ea1ef27b79bf35
getPolicy
public ClusteringPolicy getPolicy()
{    return policy;}
ea6bb95502f21150c06fe996746852047703195c54965950a5ff4a4ad90544c2
writeToSeqFiles
public void writeToSeqFiles(Path path) throws IOException
{    writePolicy(policy, path);    Configuration config = new Configuration();    FileSystem fs = FileSystem.get(path.toUri(), config);    ClusterWritable cw = new ClusterWritable();    for (int i = 0; i < models.size(); i++) {        try (SequenceFile.Writer writer = new SequenceFile.Writer(fs, config, new Path(path, "part-" + String.format(Locale.ENGLISH, "%05d", i)), IntWritable.class, ClusterWritable.class)) {            Cluster cluster = models.get(i);            cw.setValue(cluster);            Writable key = new IntWritable(i);            writer.append(key, cw);        }    }}
fec6d90fb10f547c43a95537a6605eaac232c354682f16d6050d0009b4a2c33a
readFromSeqFiles
public void readFromSeqFiles(Configuration conf, Path path) throws IOException
{    Configuration config = new Configuration();    List<Cluster> clusters = new ArrayList<>();    for (ClusterWritable cw : new SequenceFileDirValueIterable<ClusterWritable>(path, PathType.LIST, PathFilters.logsCRCFilter(), config)) {        Cluster cluster = cw.getValue();        cluster.configure(conf);        clusters.add(cluster);    }    this.models = clusters;    modelClass = models.get(0).getClass().getName();    this.policy = readPolicy(path);}
71c9d802ea3feb3fc8c5471b655505439390118876067160f63cf9439247d6c5
readPolicy
public static ClusteringPolicy readPolicy(Path path) throws IOException
{    Path policyPath = new Path(path, POLICY_FILE_NAME);    Configuration config = new Configuration();    FileSystem fs = FileSystem.get(policyPath.toUri(), config);    SequenceFile.Reader reader = new SequenceFile.Reader(fs, policyPath, config);    Text key = new Text();    ClusteringPolicyWritable cpw = new ClusteringPolicyWritable();    reader.next(key, cpw);    Closeables.close(reader, true);    return cpw.getValue();}
e1825ff77c1e4261ef3fd7f9640b1cbbe37d270e3c5cde2ff62ef636d522c882
writePolicy
public static void writePolicy(ClusteringPolicy policy, Path path) throws IOException
{    Path policyPath = new Path(path, POLICY_FILE_NAME);    Configuration config = new Configuration();    FileSystem fs = FileSystem.get(policyPath.toUri(), config);    SequenceFile.Writer writer = new SequenceFile.Writer(fs, config, policyPath, Text.class, ClusteringPolicyWritable.class);    writer.append(new Text(), new ClusteringPolicyWritable(policy));    Closeables.close(writer, false);}
71d4d8d11cb6c808f5b857d0204cc5603233b45ee507657eb628707d9f79e953
getProperties
public Map<Text, Text> getProperties()
{    return properties;}
0ffcd428c1eb491944b482406fca49b07ca4d2fc5168ea554f82cacde090a18e
setProperties
public void setProperties(Map<Text, Text> properties)
{    this.properties = properties;}
5478cc5683f6dfd4515c383752d7c803555efc63d03fd84a03ba8dcd17eb4324
readFields
public void readFields(DataInput in) throws IOException
{    super.readFields(in);    int size = in.readInt();    if (size > 0) {        properties = new HashMap<>();        for (int i = 0; i < size; i++) {            Text key = new Text(in.readUTF());            Text val = new Text(in.readUTF());            properties.put(key, val);        }    }}
a894510dd4db439ff8e17ae1059489dc3abc97178e5932ceed0c70c3af165401
write
public void write(DataOutput out) throws IOException
{    super.write(out);    out.writeInt(properties != null ? properties.size() : 0);    if (properties != null) {        for (Map.Entry<Text, Text> entry : properties.entrySet()) {            out.writeUTF(entry.getKey().toString());            out.writeUTF(entry.getValue().toString());        }    }}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    Vector vector = getVector();    StringBuilder bldr = new StringBuilder("wt: ").append(getWeight()).append(' ');    if (properties != null && !properties.isEmpty()) {        for (Map.Entry<Text, Text> entry : properties.entrySet()) {            bldr.append(entry.getKey().toString()).append(": ").append(entry.getValue().toString()).append(' ');        }    }    bldr.append(" vec: ").append(vector == null ? "null" : AbstractCluster.formatVector(vector, null));    return bldr.toString();}
79cbed8ec593faceb4946ba56ec5347061f2a2b271e2c36d7de0e1f0ae5aa0d3
getVector
public Vector getVector()
{    return vectorWritable.get();}
a251703f52665cd8058a9b91a44363e6622b9ef4757e2f08bd7a821b15df3775
setVector
public void setVector(Vector vector)
{    vectorWritable.set(vector);}
4fcdc31ef95f5a8da570a554b48977aa3dd343f3820426ae37586f4231b6e321
getWeight
public double getWeight()
{    return weight;}
5478cc5683f6dfd4515c383752d7c803555efc63d03fd84a03ba8dcd17eb4324
readFields
public void readFields(DataInput in) throws IOException
{    vectorWritable.readFields(in);    weight = in.readDouble();}
a894510dd4db439ff8e17ae1059489dc3abc97178e5932ceed0c70c3af165401
write
public void write(DataOutput out) throws IOException
{    vectorWritable.write(out);    out.writeDouble(weight);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    Vector vector = vectorWritable.get();    return weight + ": " + (vector == null ? "null" : AbstractCluster.formatVector(vector, null));}
bdedb23d95789d1317a27f35dd7c3492d640a1e532760b868d530346a1a9ac99
summarizeClusterDistances
public static List<OnlineSummarizer> summarizeClusterDistances(Iterable<? extends Vector> datapoints, Iterable<? extends Vector> centroids, DistanceMeasure distanceMeasure)
{    UpdatableSearcher searcher = new ProjectionSearch(distanceMeasure, 3, 1);    searcher.addAll(centroids);    List<OnlineSummarizer> summarizers = new ArrayList<>();    if (searcher.size() == 0) {        return summarizers;    }    for (int i = 0; i < searcher.size(); ++i) {        summarizers.add(new OnlineSummarizer());    }    for (Vector v : datapoints) {        Centroid closest = (Centroid) searcher.search(v, 1).get(0).getValue();        OnlineSummarizer summarizer = summarizers.get(closest.getIndex());        summarizer.add(distanceMeasure.distance(v, closest));    }    return summarizers;}
b78be6e510daebfcc0b450d9f4535a9e4c981dd969d035fc059502d397e62100
totalClusterCost
public static double totalClusterCost(Iterable<? extends Vector> datapoints, Iterable<? extends Vector> centroids)
{    DistanceMeasure distanceMeasure = new EuclideanDistanceMeasure();    UpdatableSearcher searcher = new ProjectionSearch(distanceMeasure, 3, 1);    searcher.addAll(centroids);    return totalClusterCost(datapoints, searcher);}
285cc8c6edab7fc2e39ea659ba72dcd0bc2358248c52831a57baaa142c01601a
totalClusterCost
public static double totalClusterCost(Iterable<? extends Vector> datapoints, Searcher centroids)
{    double totalCost = 0;    for (Vector vector : datapoints) {        totalCost += centroids.searchFirst(vector, false).getWeight();    }    return totalCost;}
d525476f63b2e2e5c3da3807f97e96dac339afb5ce07c31f3e4fb3042ab6acfd
estimateDistanceCutoff
public static double estimateDistanceCutoff(List<? extends Vector> data, DistanceMeasure distanceMeasure)
{    BruteSearch searcher = new BruteSearch(distanceMeasure);    searcher.addAll(data);    double minDistance = Double.POSITIVE_INFINITY;    for (Vector vector : data) {        double closest = searcher.searchFirst(vector, true).getWeight();        if (minDistance > 0 && closest < minDistance) {            minDistance = closest;        }        searcher.add(vector);    }    return minDistance;}
a6dee63b90a3b79ea8d90761e4ab9778cca29d6667e7d146954de93cad6023a0
estimateDistanceCutoff
public static double estimateDistanceCutoff(Iterable<T> data, DistanceMeasure distanceMeasure, int sampleLimit)
{    return estimateDistanceCutoff(Lists.newArrayList(Iterables.limit(data, sampleLimit)), distanceMeasure);}
2c8a7b79cec6c470069f226a8fa1c0c31925bc15f7c4b97131bb4367e8aa1094
daviesBouldinIndex
public static double daviesBouldinIndex(List<? extends Vector> centroids, DistanceMeasure distanceMeasure, List<OnlineSummarizer> clusterDistanceSummaries)
{    Preconditions.checkArgument(centroids.size() == clusterDistanceSummaries.size(), "Number of centroids and cluster summaries differ.");    int n = centroids.size();    double totalDBIndex = 0;        for (int i = 0; i < n; ++i) {        double averageDistanceI = clusterDistanceSummaries.get(i).getMean();        double maxDBIndex = 0;        for (int j = 0; j < n; ++j) {            if (i != j) {                double dbIndex = (averageDistanceI + clusterDistanceSummaries.get(j).getMean()) / distanceMeasure.distance(centroids.get(i), centroids.get(j));                if (dbIndex > maxDBIndex) {                    maxDBIndex = dbIndex;                }            }        }        totalDBIndex += maxDBIndex;    }    return totalDBIndex / n;}
3d0f14114c7002247637e5befa68cbe7189ec61cf7d4224c376cf6f15d6d80fd
dunnIndex
public static double dunnIndex(List<? extends Vector> centroids, DistanceMeasure distanceMeasure, List<OnlineSummarizer> clusterDistanceSummaries)
{    Preconditions.checkArgument(centroids.size() == clusterDistanceSummaries.size(), "Number of centroids and cluster summaries differ.");    int n = centroids.size();                        double maxIntraClusterDistance = 0;    for (OnlineSummarizer summarizer : clusterDistanceSummaries) {        if (summarizer.getCount() > 0) {            double intraClusterDistance;            if (summarizer.getCount() == 1) {                intraClusterDistance = summarizer.getMean();            } else {                intraClusterDistance = summarizer.getMedian();            }            if (maxIntraClusterDistance < intraClusterDistance) {                maxIntraClusterDistance = intraClusterDistance;            }        }    }    double minDunnIndex = Double.POSITIVE_INFINITY;    for (int i = 0; i < n; ++i) {                for (int j = i + 1; j < n; ++j) {            double dunnIndex = distanceMeasure.distance(centroids.get(i), centroids.get(j));            if (minDunnIndex > dunnIndex) {                minDunnIndex = dunnIndex;            }        }    }    return minDunnIndex / maxIntraClusterDistance;}
06da83a705653ab01208bc3238374d7b6f49cf04161089899a459f9f95e907c2
choose2
public static double choose2(double n)
{    return n * (n - 1) / 2;}
a1b1f2266bd8ab796d1bf82590d0e6ae2bf39b09c346a525c38a583fb21e6d34
getConfusionMatrix
public static Matrix getConfusionMatrix(List<? extends Vector> rowCentroids, List<? extends Vector> columnCentroids, Iterable<? extends Vector> datapoints, DistanceMeasure distanceMeasure)
{    Searcher rowSearcher = new BruteSearch(distanceMeasure);    rowSearcher.addAll(rowCentroids);    Searcher columnSearcher = new BruteSearch(distanceMeasure);    columnSearcher.addAll(columnCentroids);    int numRows = rowCentroids.size();    int numCols = columnCentroids.size();    Matrix confusionMatrix = new DenseMatrix(numRows, numCols);    for (Vector vector : datapoints) {        WeightedThing<Vector> closestRowCentroid = rowSearcher.search(vector, 1).get(0);        WeightedThing<Vector> closestColumnCentroid = columnSearcher.search(vector, 1).get(0);        int row = ((Centroid) closestRowCentroid.getValue()).getIndex();        int column = ((Centroid) closestColumnCentroid.getValue()).getIndex();        double vectorWeight;        if (vector instanceof WeightedVector) {            vectorWeight = ((WeightedVector) vector).getWeight();        } else {            vectorWeight = 1;        }        confusionMatrix.set(row, column, confusionMatrix.get(row, column) + vectorWeight);    }    return confusionMatrix;}
fbffdb4a007ec4c060aee3ff742532b8895ada6edcbb24583cc8565726deedc7
getAdjustedRandIndex
public static double getAdjustedRandIndex(Matrix confusionMatrix)
{    int numRows = confusionMatrix.numRows();    int numCols = confusionMatrix.numCols();    double rowChoiceSum = 0;    double columnChoiceSum = 0;    double totalChoiceSum = 0;    double total = 0;    for (int i = 0; i < numRows; ++i) {        double rowSum = 0;        for (int j = 0; j < numCols; ++j) {            rowSum += confusionMatrix.get(i, j);            totalChoiceSum += choose2(confusionMatrix.get(i, j));        }        total += rowSum;        rowChoiceSum += choose2(rowSum);    }    for (int j = 0; j < numCols; ++j) {        double columnSum = 0;        for (int i = 0; i < numRows; ++i) {            columnSum += confusionMatrix.get(i, j);        }        columnChoiceSum += choose2(columnSum);    }    double rowColumnChoiceSumDivTotal = rowChoiceSum * columnChoiceSum / choose2(total);    return (totalChoiceSum - rowColumnChoiceSumDivTotal) / ((rowChoiceSum + columnChoiceSum) / 2 - rowColumnChoiceSumDivTotal);}
ac8c0daca08161aa192ad7408b79ce666ce43ad20fee5d8afd26814e40bbb407
totalWeight
public static double totalWeight(Iterable<? extends Vector> data)
{    double sum = 0;    for (Vector row : data) {        Preconditions.checkNotNull(row);        if (row instanceof WeightedVector) {            sum += ((WeightedVector) row).getWeight();        } else {            sum++;        }    }    return sum;}
fc8a2075d057c33764a29f43e9e7bc1fad03d7920cf3b34c4bbafbecf3d67734
computePi
public Vector computePi(Collection<SoftCluster> clusters, List<Double> clusterDistanceList)
{    Vector pi = new DenseVector(clusters.size());    for (int i = 0; i < clusters.size(); i++) {        double probWeight = computeProbWeight(clusterDistanceList.get(i), clusterDistanceList);        pi.set(i, probWeight);    }    return pi;}
2fb026b8bede48a2961c0af3649d36e20f6153b7e0346f8c9e6e1cd9b126fb49
computeProbWeight
public double computeProbWeight(double clusterDistance, Iterable<Double> clusterDistanceList)
{    if (clusterDistance == 0) {        clusterDistance = MINIMAL_VALUE;    }    double denom = 0.0;    for (double eachCDist : clusterDistanceList) {        if (eachCDist == 0.0) {            eachCDist = MINIMAL_VALUE;        }        denom += Math.pow(clusterDistance / eachCDist, 2.0 / (m - 1));    }    return 1.0 / denom;}
b9f799bec4019efd0d7d64cfc1cf7d80c91a42211e937f5c8f481b72b920d172
setM
public void setM(double m)
{    this.m = m;}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    ToolRunner.run(new Configuration(), new FuzzyKMeansDriver(), args);}
aacecb0f01750d985b78d806dc3c134f0da79efe2752957e0f93ecf5cbf9e492
run
public int run(String[] args) throws Exception
{    addInputOption();    addOutputOption();    addOption(DefaultOptionCreator.distanceMeasureOption().create());    addOption(DefaultOptionCreator.clustersInOption().withDescription("The input centroids, as Vectors.  Must be a SequenceFile of Writable, Cluster/Canopy.  " + "If k is also specified, then a random set of vectors will be selected" + " and written out to this path first").create());    addOption(DefaultOptionCreator.numClustersOption().withDescription("The k in k-Means.  If specified, then a random selection of k Vectors will be chosen" + " as the Centroid and written to the clusters input path.").create());    addOption(DefaultOptionCreator.convergenceOption().create());    addOption(DefaultOptionCreator.maxIterationsOption().create());    addOption(DefaultOptionCreator.overwriteOption().create());    addOption(M_OPTION, M_OPTION, "coefficient normalization factor, must be greater than 1", true);    addOption(DefaultOptionCreator.clusteringOption().create());    addOption(DefaultOptionCreator.emitMostLikelyOption().create());    addOption(DefaultOptionCreator.thresholdOption().create());    addOption(DefaultOptionCreator.methodOption().create());    addOption(DefaultOptionCreator.useSetRandomSeedOption().create());    if (parseArguments(args) == null) {        return -1;    }    Path input = getInputPath();    Path clusters = new Path(getOption(DefaultOptionCreator.CLUSTERS_IN_OPTION));    Path output = getOutputPath();    String measureClass = getOption(DefaultOptionCreator.DISTANCE_MEASURE_OPTION);    if (measureClass == null) {        measureClass = SquaredEuclideanDistanceMeasure.class.getName();    }    double convergenceDelta = Double.parseDouble(getOption(DefaultOptionCreator.CONVERGENCE_DELTA_OPTION));    float fuzziness = Float.parseFloat(getOption(M_OPTION));    int maxIterations = Integer.parseInt(getOption(DefaultOptionCreator.MAX_ITERATIONS_OPTION));    if (hasOption(DefaultOptionCreator.OVERWRITE_OPTION)) {        HadoopUtil.delete(getConf(), output);    }    boolean emitMostLikely = Boolean.parseBoolean(getOption(DefaultOptionCreator.EMIT_MOST_LIKELY_OPTION));    double threshold = Double.parseDouble(getOption(DefaultOptionCreator.THRESHOLD_OPTION));    DistanceMeasure measure = ClassUtils.instantiateAs(measureClass, DistanceMeasure.class);    if (hasOption(DefaultOptionCreator.NUM_CLUSTERS_OPTION)) {        int numClusters = Integer.parseInt(getOption(DefaultOptionCreator.NUM_CLUSTERS_OPTION));        Long seed = null;        if (hasOption(DefaultOptionCreator.RANDOM_SEED)) {            seed = Long.parseLong(getOption(DefaultOptionCreator.RANDOM_SEED));        }        clusters = RandomSeedGenerator.buildRandom(getConf(), input, clusters, numClusters, measure, seed);    }    boolean runClustering = hasOption(DefaultOptionCreator.CLUSTERING_OPTION);    boolean runSequential = getOption(DefaultOptionCreator.METHOD_OPTION).equalsIgnoreCase(DefaultOptionCreator.SEQUENTIAL_METHOD);    run(getConf(), input, clusters, output, convergenceDelta, maxIterations, fuzziness, runClustering, emitMostLikely, threshold, runSequential);    return 0;}
4da94ef0aeec07d799cb373aab026400cfad2c0867c2d88526bdc37146499ee7
run
public static void run(Path input, Path clustersIn, Path output, double convergenceDelta, int maxIterations, float m, boolean runClustering, boolean emitMostLikely, double threshold, boolean runSequential) throws IOException, ClassNotFoundException, InterruptedException
{    Configuration conf = new Configuration();    Path clustersOut = buildClusters(conf, input, clustersIn, output, convergenceDelta, maxIterations, m, runSequential);    if (runClustering) {        log.info("Clustering ");        clusterData(conf, input, clustersOut, output, convergenceDelta, m, emitMostLikely, threshold, runSequential);    }}
020b32d39d90c683315dda61c66794b731a2734f9c18641d70244b3d9aa0b525
run
public static void run(Configuration conf, Path input, Path clustersIn, Path output, double convergenceDelta, int maxIterations, float m, boolean runClustering, boolean emitMostLikely, double threshold, boolean runSequential) throws IOException, ClassNotFoundException, InterruptedException
{    Path clustersOut = buildClusters(conf, input, clustersIn, output, convergenceDelta, maxIterations, m, runSequential);    if (runClustering) {        log.info("Clustering");        clusterData(conf, input, clustersOut, output, convergenceDelta, m, emitMostLikely, threshold, runSequential);    }}
ab586a17e654fecfc9ef814fa5879c912109ef2a86b35742ba28e8e9fa5ad139
buildClusters
public static Path buildClusters(Configuration conf, Path input, Path clustersIn, Path output, double convergenceDelta, int maxIterations, float m, boolean runSequential) throws IOException, InterruptedException, ClassNotFoundException
{    List<Cluster> clusters = new ArrayList<>();    FuzzyKMeansUtil.configureWithClusterInfo(conf, clustersIn, clusters);    if (conf == null) {        conf = new Configuration();    }    if (clusters.isEmpty()) {        throw new IllegalStateException("No input clusters found in " + clustersIn + ". Check your -c argument.");    }    Path priorClustersPath = new Path(output, Cluster.INITIAL_CLUSTERS_DIR);    ClusteringPolicy policy = new FuzzyKMeansClusteringPolicy(m, convergenceDelta);    ClusterClassifier prior = new ClusterClassifier(clusters, policy);    prior.writeToSeqFiles(priorClustersPath);    if (runSequential) {        ClusterIterator.iterateSeq(conf, input, priorClustersPath, output, maxIterations);    } else {        ClusterIterator.iterateMR(conf, input, priorClustersPath, output, maxIterations);    }    return output;}
9fd16eadbbeb2bfc56d627dbdd6cf79796da23c615dd8bc319f7d03a563ce77f
clusterData
public static void clusterData(Configuration conf, Path input, Path clustersIn, Path output, double convergenceDelta, float m, boolean emitMostLikely, double threshold, boolean runSequential) throws IOException, ClassNotFoundException, InterruptedException
{    ClusterClassifier.writePolicy(new FuzzyKMeansClusteringPolicy(m, convergenceDelta), clustersIn);    ClusterClassificationDriver.run(conf, input, output, new Path(output, PathDirectory.CLUSTERED_POINTS_DIRECTORY), threshold, emitMostLikely, runSequential);}
fe2a2514e4556569c0cd119a76f5aa199e2dd0c0166c6779cbc25fd5a7265b1b
configureWithClusterInfo
public static void configureWithClusterInfo(Configuration conf, Path clusterPath, List<Cluster> clusters)
{    for (Writable value : new SequenceFileDirValueIterable<>(clusterPath, PathType.LIST, PathFilters.partFilter(), conf)) {        Class<? extends Writable> valueClass = value.getClass();        if (valueClass.equals(ClusterWritable.class)) {            ClusterWritable clusterWritable = (ClusterWritable) value;            value = clusterWritable.getValue();            valueClass = value.getClass();        }        if (valueClass.equals(Kluster.class)) {                        Kluster cluster = (Kluster) value;            clusters.add(new SoftCluster(cluster.getCenter(), cluster.getId(), cluster.getMeasure()));        } else if (valueClass.equals(SoftCluster.class)) {                        clusters.add((SoftCluster) value);        } else if (valueClass.equals(Canopy.class)) {                        Canopy canopy = (Canopy) value;            clusters.add(new SoftCluster(canopy.getCenter(), canopy.getId(), canopy.getMeasure()));        } else {            throw new IllegalStateException("Bad value class: " + valueClass);        }    }}
ae284afe1ade5afe0242f68b99b1251c8ef4ebfb1ffd6eaa841c8d273ed0c131
asFormatString
public String asFormatString()
{    return this.getIdentifier() + ": " + this.computeCentroid().asFormatString();}
58bd96f144f5615a71b3c07015b2823c398f6cbeddbd1f5b812bce20ce6f7e56
getIdentifier
public String getIdentifier()
{    return (isConverged() ? "SV-" : "SC-") + getId();}
9e0d0921d0eccc2ce07b293d9dfec516dc52f5098d5fed43ed0fe36a0f935958
pdf
public double pdf(VectorWritable vw)
{        throw new UnsupportedOperationException("SoftCluster pdf cannot be calculated out of context. See FuzzyKMeansClusterer");}
d20c2271df501df7b945ca3dabe735cfc18ae9839c2777711018cdd5dd28e5a6
select
public Vector select(Vector probabilities)
{    int maxValueIndex = probabilities.maxValueIndex();    Vector weights = new SequentialAccessSparseVector(probabilities.size());    weights.set(maxValueIndex, 1.0);    return weights;}
040047c28d584f741c4294c7b19f9842095c2e889ee9290e128362f55fd434c4
update
public void update(ClusterClassifier posterior)
{}
157389ba63644b054fbc698d2ff9ce9b2f957894b3605f955a706e9de4d371bf
classify
public Vector classify(Vector data, ClusterClassifier prior)
{    List<Cluster> models = prior.getModels();    int i = 0;    Vector pdfs = new DenseVector(models.size());    for (Cluster model : models) {        pdfs.set(i++, model.pdf(new VectorWritable(data)));    }    return pdfs.assign(new TimesFunction(), 1.0 / pdfs.zSum());}
15ce481099a2777d4a40356f363aeab1fdbe7053c64953f5b7e7ced854c986ae
close
public void close(ClusterClassifier posterior)
{    for (Cluster cluster : posterior.getModels()) {        cluster.computeParameters();    }}
d20c2271df501df7b945ca3dabe735cfc18ae9839c2777711018cdd5dd28e5a6
select
public Vector select(Vector probabilities)
{    int maxValueIndex = probabilities.maxValueIndex();    Vector weights = new SequentialAccessSparseVector(probabilities.size());    weights.set(maxValueIndex, 1.0);    return weights;}
a894510dd4db439ff8e17ae1059489dc3abc97178e5932ceed0c70c3af165401
write
public void write(DataOutput out) throws IOException
{    out.writeDouble(t1);    out.writeDouble(t2);}
5478cc5683f6dfd4515c383752d7c803555efc63d03fd84a03ba8dcd17eb4324
readFields
public void readFields(DataInput in) throws IOException
{    this.t1 = in.readDouble();    this.t2 = in.readDouble();}
6b7dd49be7482fc8ee0fbe8bd0f24522f2a718c8c816a3d7b048fb4688eb6373
setup
protected void setup(Context context) throws IOException, InterruptedException
{    Configuration conf = context.getConfiguration();    String priorClustersPath = conf.get(ClusterIterator.PRIOR_PATH_KEY);    classifier = new ClusterClassifier();    classifier.readFromSeqFiles(conf, new Path(priorClustersPath));    policy = classifier.getPolicy();    policy.update(classifier);    super.setup(context);}
fc1e428e426e46a32a92783347cd800582026b43336f9729a249480992d42a51
map
protected void map(WritableComparable<?> key, VectorWritable value, Context context) throws IOException, InterruptedException
{    Vector probabilities = classifier.classify(value.get());    Vector selections = policy.select(probabilities);    for (Element el : selections.nonZeroes()) {        classifier.train(el.index(), value.get(), el.get());    }}
2e250b70eb1261a97967b8b894cf822fc9e7eb36891dbb77c6d16369f85de12a
cleanup
protected void cleanup(Context context) throws IOException, InterruptedException
{    List<Cluster> clusters = classifier.getModels();    ClusterWritable cw = new ClusterWritable();    for (int index = 0; index < clusters.size(); index++) {        cw.setValue(clusters.get(index));        context.write(new IntWritable(index), cw);    }    super.cleanup(context);}
2e24f84e6f6e3f783804f5cb6660fde1873a8c65d7fb9cd9a56d9fdad8de0b54
reduce
protected void reduce(IntWritable key, Iterable<ClusterWritable> values, Context context) throws IOException, InterruptedException
{    Iterator<ClusterWritable> iter = values.iterator();        Cluster first = iter.next().getValue();    while (iter.hasNext()) {        Cluster cluster = iter.next().getValue();        first.observe(cluster);    }    List<Cluster> models = new ArrayList<>();    models.add(first);    classifier = new ClusterClassifier(models, policy);    classifier.close();    context.write(key, new ClusterWritable(first));}
6b7dd49be7482fc8ee0fbe8bd0f24522f2a718c8c816a3d7b048fb4688eb6373
setup
protected void setup(Context context) throws IOException, InterruptedException
{    Configuration conf = context.getConfiguration();    String priorClustersPath = conf.get(ClusterIterator.PRIOR_PATH_KEY);    classifier = new ClusterClassifier();    classifier.readFromSeqFiles(conf, new Path(priorClustersPath));    policy = classifier.getPolicy();    policy.update(classifier);    super.setup(context);}
cdee0a6306e4faa80ede5b676d1d0cdc74ce0042b85e0207f825046ee201763d
getValue
public ClusteringPolicy getValue()
{    return value;}
029a5b07006b0cf443be094119f13b9e0cad45901e1a950807d2e13240170432
setValue
public void setValue(ClusteringPolicy value)
{    this.value = value;}
a894510dd4db439ff8e17ae1059489dc3abc97178e5932ceed0c70c3af165401
write
public void write(DataOutput out) throws IOException
{    PolymorphicWritable.write(out, value);}
5478cc5683f6dfd4515c383752d7c803555efc63d03fd84a03ba8dcd17eb4324
readFields
public void readFields(DataInput in) throws IOException
{    value = PolymorphicWritable.read(in, ClusteringPolicy.class);}
e9bd0d8e9ef7a75c39fff21dc2b0ebcd7362e929fda72084e495d78287bc24c3
iterate
public static ClusterClassifier iterate(Iterable<Vector> data, ClusterClassifier classifier, int numIterations)
{    ClusteringPolicy policy = classifier.getPolicy();    for (int iteration = 1; iteration <= numIterations; iteration++) {        for (Vector vector : data) {                        policy.update(classifier);                        Vector probabilities = classifier.classify(vector);                        Vector weights = policy.select(probabilities);                        for (Vector.Element e : weights.nonZeroes()) {                int index = e.index();                classifier.train(index, vector, weights.get(index));            }        }                classifier.close();    }    return classifier;}
85610dfbc6d6ad424ce605d2c49be4bd92d1945ac66dfd1467db96c7e65a1876
iterateSeq
public static void iterateSeq(Configuration conf, Path inPath, Path priorPath, Path outPath, int numIterations) throws IOException
{    ClusterClassifier classifier = new ClusterClassifier();    classifier.readFromSeqFiles(conf, priorPath);    Path clustersOut = null;    int iteration = 1;    while (iteration <= numIterations) {        for (VectorWritable vw : new SequenceFileDirValueIterable<VectorWritable>(inPath, PathType.LIST, PathFilters.logsCRCFilter(), conf)) {            Vector vector = vw.get();                        Vector probabilities = classifier.classify(vector);                        Vector weights = classifier.getPolicy().select(probabilities);                        for (Vector.Element e : weights.nonZeroes()) {                int index = e.index();                classifier.train(index, vector, weights.get(index));            }        }                classifier.close();                classifier.getPolicy().update(classifier);                clustersOut = new Path(outPath, Cluster.CLUSTERS_DIR + iteration);        classifier.writeToSeqFiles(clustersOut);        FileSystem fs = FileSystem.get(outPath.toUri(), conf);        iteration++;        if (isConverged(clustersOut, conf, fs)) {            break;        }    }    Path finalClustersIn = new Path(outPath, Cluster.CLUSTERS_DIR + (iteration - 1) + Cluster.FINAL_ITERATION_SUFFIX);    FileSystem.get(clustersOut.toUri(), conf).rename(clustersOut, finalClustersIn);}
48836ded39c2d0e664c73b9bebe9d22adef684218946e8e376ad73bb0e071b05
iterateMR
public static void iterateMR(Configuration conf, Path inPath, Path priorPath, Path outPath, int numIterations) throws IOException, InterruptedException, ClassNotFoundException
{    ClusteringPolicy policy = ClusterClassifier.readPolicy(priorPath);    Path clustersOut = null;    int iteration = 1;    while (iteration <= numIterations) {        conf.set(PRIOR_PATH_KEY, priorPath.toString());        String jobName = "Cluster Iterator running iteration " + iteration + " over priorPath: " + priorPath;        Job job = new Job(conf, jobName);        job.setMapOutputKeyClass(IntWritable.class);        job.setMapOutputValueClass(ClusterWritable.class);        job.setOutputKeyClass(IntWritable.class);        job.setOutputValueClass(ClusterWritable.class);        job.setInputFormatClass(SequenceFileInputFormat.class);        job.setOutputFormatClass(SequenceFileOutputFormat.class);        job.setMapperClass(CIMapper.class);        job.setReducerClass(CIReducer.class);        FileInputFormat.addInputPath(job, inPath);        clustersOut = new Path(outPath, Cluster.CLUSTERS_DIR + iteration);        priorPath = clustersOut;        FileOutputFormat.setOutputPath(job, clustersOut);        job.setJarByClass(ClusterIterator.class);        if (!job.waitForCompletion(true)) {            throw new InterruptedException("Cluster Iteration " + iteration + " failed processing " + priorPath);        }        ClusterClassifier.writePolicy(policy, clustersOut);        FileSystem fs = FileSystem.get(outPath.toUri(), conf);        iteration++;        if (isConverged(clustersOut, conf, fs)) {            break;        }    }    Path finalClustersIn = new Path(outPath, Cluster.CLUSTERS_DIR + (iteration - 1) + Cluster.FINAL_ITERATION_SUFFIX);    FileSystem.get(clustersOut.toUri(), conf).rename(clustersOut, finalClustersIn);}
c7c2d6258825b2bc90c19cd3be028a172c58acae70a001d96652ba11b1b06c11
isConverged
private static boolean isConverged(Path filePath, Configuration conf, FileSystem fs) throws IOException
{    for (FileStatus part : fs.listStatus(filePath, PathFilters.partFilter())) {        SequenceFileValueIterator<ClusterWritable> iterator = new SequenceFileValueIterator<>(part.getPath(), true, conf);        while (iterator.hasNext()) {            ClusterWritable value = iterator.next();            if (!value.getValue().isConverged()) {                Closeables.close(iterator, true);                return false;            }        }    }    return true;}
c1ffa897b9e1ab6e1fd2a89da89c6ce1f68d0419c8b1381dde9bf85c96fa8ae0
getValue
public Cluster getValue()
{    return value;}
01d7a97ec19313c35612707381a0889ffe6c403fabcb05dccd8cc40489ebce84
setValue
public void setValue(Cluster value)
{    this.value = value;}
a894510dd4db439ff8e17ae1059489dc3abc97178e5932ceed0c70c3af165401
write
public void write(DataOutput out) throws IOException
{    PolymorphicWritable.write(out, value);}
5478cc5683f6dfd4515c383752d7c803555efc63d03fd84a03ba8dcd17eb4324
readFields
public void readFields(DataInput in) throws IOException
{    value = PolymorphicWritable.read(in, Cluster.class);}
80f20350a1168909a108171da475cb3d54a531b17708e3f7547288d058148699
configure
public void configure(Configuration job)
{    if (measure != null) {        measure.configure(job);    }}
5478cc5683f6dfd4515c383752d7c803555efc63d03fd84a03ba8dcd17eb4324
readFields
public void readFields(DataInput in) throws IOException
{    String dm = in.readUTF();    this.measure = ClassUtils.instantiateAs(dm, DistanceMeasure.class);    super.readFields(in);}
a894510dd4db439ff8e17ae1059489dc3abc97178e5932ceed0c70c3af165401
write
public void write(DataOutput out) throws IOException
{    out.writeUTF(measure.getClass().getName());    super.write(out);}
9e0d0921d0eccc2ce07b293d9dfec516dc52f5098d5fed43ed0fe36a0f935958
pdf
public double pdf(VectorWritable vw)
{    return 1 / (1 + measure.distance(vw.get(), getCenter()));}
fbc1d3895ca081c707bbb20699acee3f747a84d50b8cb3696c1927d718a663fb
sampleFromPosterior
public Model<VectorWritable> sampleFromPosterior()
{    return new DistanceMeasureCluster(getCenter(), getId(), measure);}
1151f4825930a854acf378b4a6715b2bfc0409e258a194e0926712606148eeb2
getMeasure
public DistanceMeasure getMeasure()
{    return measure;}
948935246279c309335383a5c0fde90b1145b5f21bc1c09a90f52c90c85dfc58
setMeasure
public void setMeasure(DistanceMeasure measure)
{    this.measure = measure;}
58bd96f144f5615a71b3c07015b2823c398f6cbeddbd1f5b812bce20ce6f7e56
getIdentifier
public String getIdentifier()
{    return "DMC:" + getId();}
d20c2271df501df7b945ca3dabe735cfc18ae9839c2777711018cdd5dd28e5a6
select
public Vector select(Vector probabilities)
{    return probabilities;}
157389ba63644b054fbc698d2ff9ce9b2f957894b3605f955a706e9de4d371bf
classify
public Vector classify(Vector data, ClusterClassifier prior)
{    Collection<SoftCluster> clusters = new ArrayList<>();    List<Double> distances = new ArrayList<>();    for (Cluster model : prior.getModels()) {        SoftCluster sc = (SoftCluster) model;        clusters.add(sc);        distances.add(sc.getMeasure().distance(data, sc.getCenter()));    }    FuzzyKMeansClusterer fuzzyKMeansClusterer = new FuzzyKMeansClusterer();    fuzzyKMeansClusterer.setM(m);    return fuzzyKMeansClusterer.computePi(clusters, distances);}
a894510dd4db439ff8e17ae1059489dc3abc97178e5932ceed0c70c3af165401
write
public void write(DataOutput out) throws IOException
{    out.writeDouble(m);    out.writeDouble(convergenceDelta);}
5478cc5683f6dfd4515c383752d7c803555efc63d03fd84a03ba8dcd17eb4324
readFields
public void readFields(DataInput in) throws IOException
{    this.m = in.readDouble();    this.convergenceDelta = in.readDouble();}
15ce481099a2777d4a40356f363aeab1fdbe7053c64953f5b7e7ced854c986ae
close
public void close(ClusterClassifier posterior)
{    for (Cluster cluster : posterior.getModels()) {        ((org.apache.mahout.clustering.kmeans.Kluster) cluster).calculateConvergence(convergenceDelta);        cluster.computeParameters();    }}
a894510dd4db439ff8e17ae1059489dc3abc97178e5932ceed0c70c3af165401
write
public void write(DataOutput out) throws IOException
{    out.writeDouble(convergenceDelta);}
5478cc5683f6dfd4515c383752d7c803555efc63d03fd84a03ba8dcd17eb4324
readFields
public void readFields(DataInput in) throws IOException
{    this.convergenceDelta = in.readDouble();}
15ce481099a2777d4a40356f363aeab1fdbe7053c64953f5b7e7ced854c986ae
close
public void close(ClusterClassifier posterior)
{    boolean allConverged = true;    for (Cluster cluster : posterior.getModels()) {        org.apache.mahout.clustering.kmeans.Kluster kluster = (org.apache.mahout.clustering.kmeans.Kluster) cluster;        boolean converged = kluster.calculateConvergence(convergenceDelta);        allConverged = allConverged && converged;        cluster.computeParameters();    }}
0395ccfef42540f06bedfc6a0d0baffd4033d1a0bd609223ffd687eaef0ec9cb
calculateDerivativeValue
public double calculateDerivativeValue(double distance, double h)
{    return distance < h ? 1.0 : 0.0;}
15f0791a509140d7edf66df3b219838a54449365e2a5dd55387ac37326b0129c
formatCluster
public static String formatCluster(Kluster cluster)
{    return cluster.getIdentifier() + ": " + cluster.computeCentroid().asFormatString();}
ae284afe1ade5afe0242f68b99b1251c8ef4ebfb1ffd6eaa841c8d273ed0c131
asFormatString
public String asFormatString()
{    return formatCluster(this);}
a894510dd4db439ff8e17ae1059489dc3abc97178e5932ceed0c70c3af165401
write
public void write(DataOutput out) throws IOException
{    super.write(out);    out.writeBoolean(converged);}
5478cc5683f6dfd4515c383752d7c803555efc63d03fd84a03ba8dcd17eb4324
readFields
public void readFields(DataInput in) throws IOException
{    super.readFields(in);    this.converged = in.readBoolean();}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return asFormatString(null);}
58bd96f144f5615a71b3c07015b2823c398f6cbeddbd1f5b812bce20ce6f7e56
getIdentifier
public String getIdentifier()
{    return (converged ? "VL-" : "CL-") + getId();}
d9a68605c77051a874cc6c717cfa5e8c00ba6357f1857270e685b0df55d9ad4c
computeConvergence
public boolean computeConvergence(DistanceMeasure measure, double convergenceDelta)
{    Vector centroid = computeCentroid();    converged = measure.distance(centroid.getLengthSquared(), centroid, getCenter()) <= convergenceDelta;    return converged;}
83c4ad32365335fe928afb9dcdb6aea3fbd28b3282bb7e9b60b2eeea4073a9bf
isConverged
public boolean isConverged()
{    return converged;}
df00f143c39c177de2eabf4b9e0eaaeae6e9a952b5c5dc1bd5a1e6d3ad99f7bb
setConverged
protected void setConverged(boolean converged)
{    this.converged = converged;}
475cbb76a518fc97aa3064d8404ebd63760fd01c99847aa273cc7a3149a31498
calculateConvergence
public boolean calculateConvergence(double convergenceDelta)
{    Vector centroid = computeCentroid();    converged = getMeasure().distance(centroid.getLengthSquared(), centroid, getCenter()) <= convergenceDelta;    return converged;}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    ToolRunner.run(new Configuration(), new KMeansDriver(), args);}
aacecb0f01750d985b78d806dc3c134f0da79efe2752957e0f93ecf5cbf9e492
run
public int run(String[] args) throws Exception
{    addInputOption();    addOutputOption();    addOption(DefaultOptionCreator.distanceMeasureOption().create());    addOption(DefaultOptionCreator.clustersInOption().withDescription("The input centroids, as Vectors.  Must be a SequenceFile of Writable, Cluster/Canopy.  " + "If k is also specified, then a random set of vectors will be selected" + " and written out to this path first").create());    addOption(DefaultOptionCreator.numClustersOption().withDescription("The k in k-Means.  If specified, then a random selection of k Vectors will be chosen" + " as the Centroid and written to the clusters input path.").create());    addOption(DefaultOptionCreator.useSetRandomSeedOption().create());    addOption(DefaultOptionCreator.convergenceOption().create());    addOption(DefaultOptionCreator.maxIterationsOption().create());    addOption(DefaultOptionCreator.overwriteOption().create());    addOption(DefaultOptionCreator.clusteringOption().create());    addOption(DefaultOptionCreator.methodOption().create());    addOption(DefaultOptionCreator.outlierThresholdOption().create());    if (parseArguments(args) == null) {        return -1;    }    Path input = getInputPath();    Path clusters = new Path(getOption(DefaultOptionCreator.CLUSTERS_IN_OPTION));    Path output = getOutputPath();    String measureClass = getOption(DefaultOptionCreator.DISTANCE_MEASURE_OPTION);    if (measureClass == null) {        measureClass = SquaredEuclideanDistanceMeasure.class.getName();    }    double convergenceDelta = Double.parseDouble(getOption(DefaultOptionCreator.CONVERGENCE_DELTA_OPTION));    int maxIterations = Integer.parseInt(getOption(DefaultOptionCreator.MAX_ITERATIONS_OPTION));    if (hasOption(DefaultOptionCreator.OVERWRITE_OPTION)) {        HadoopUtil.delete(getConf(), output);    }    DistanceMeasure measure = ClassUtils.instantiateAs(measureClass, DistanceMeasure.class);    if (hasOption(DefaultOptionCreator.NUM_CLUSTERS_OPTION)) {        int numClusters = Integer.parseInt(getOption(DefaultOptionCreator.NUM_CLUSTERS_OPTION));        Long seed = null;        if (hasOption(DefaultOptionCreator.RANDOM_SEED)) {            seed = Long.parseLong(getOption(DefaultOptionCreator.RANDOM_SEED));        }        clusters = RandomSeedGenerator.buildRandom(getConf(), input, clusters, numClusters, measure, seed);    }    boolean runClustering = hasOption(DefaultOptionCreator.CLUSTERING_OPTION);    boolean runSequential = getOption(DefaultOptionCreator.METHOD_OPTION).equalsIgnoreCase(DefaultOptionCreator.SEQUENTIAL_METHOD);    double clusterClassificationThreshold = 0.0;    if (hasOption(DefaultOptionCreator.OUTLIER_THRESHOLD)) {        clusterClassificationThreshold = Double.parseDouble(getOption(DefaultOptionCreator.OUTLIER_THRESHOLD));    }    run(getConf(), input, clusters, output, convergenceDelta, maxIterations, runClustering, clusterClassificationThreshold, runSequential);    return 0;}
cff017a774debe6fd5595609ef174e5f124c365601e19ff8614c5f39d3f82cf4
run
public static void run(Configuration conf, Path input, Path clustersIn, Path output, double convergenceDelta, int maxIterations, boolean runClustering, double clusterClassificationThreshold, boolean runSequential) throws IOException, InterruptedException, ClassNotFoundException
{        String delta = Double.toString(convergenceDelta);    if (log.isInfoEnabled()) {        log.info("Input: {} Clusters In: {} Out: {}", input, clustersIn, output);        log.info("convergence: {} max Iterations: {}", convergenceDelta, maxIterations);    }    Path clustersOut = buildClusters(conf, input, clustersIn, output, maxIterations, delta, runSequential);    if (runClustering) {        log.info("Clustering data");        clusterData(conf, input, clustersOut, output, clusterClassificationThreshold, runSequential);    }}
990095a2ed05379ab7524f63dc8839ff9e87ee6d78284a90d1cc855e1bc26a64
run
public static void run(Path input, Path clustersIn, Path output, double convergenceDelta, int maxIterations, boolean runClustering, double clusterClassificationThreshold, boolean runSequential) throws IOException, InterruptedException, ClassNotFoundException
{    run(new Configuration(), input, clustersIn, output, convergenceDelta, maxIterations, runClustering, clusterClassificationThreshold, runSequential);}
7689e410b0a6d1009277b587bef09f241d04591c50e0edd3396fdc18b3c4e2b1
buildClusters
public static Path buildClusters(Configuration conf, Path input, Path clustersIn, Path output, int maxIterations, String delta, boolean runSequential) throws IOException, InterruptedException, ClassNotFoundException
{    double convergenceDelta = Double.parseDouble(delta);    List<Cluster> clusters = new ArrayList<>();    KMeansUtil.configureWithClusterInfo(conf, clustersIn, clusters);    if (clusters.isEmpty()) {        throw new IllegalStateException("No input clusters found in " + clustersIn + ". Check your -c argument.");    }    Path priorClustersPath = new Path(output, Cluster.INITIAL_CLUSTERS_DIR);    ClusteringPolicy policy = new KMeansClusteringPolicy(convergenceDelta);    ClusterClassifier prior = new ClusterClassifier(clusters, policy);    prior.writeToSeqFiles(priorClustersPath);    if (runSequential) {        ClusterIterator.iterateSeq(conf, input, priorClustersPath, output, maxIterations);    } else {        ClusterIterator.iterateMR(conf, input, priorClustersPath, output, maxIterations);    }    return output;}
6ff929010217b02c84d66d371979b54df82060dad1152c54e19c1e4e33b374d1
clusterData
public static void clusterData(Configuration conf, Path input, Path clustersIn, Path output, double clusterClassificationThreshold, boolean runSequential) throws IOException, InterruptedException, ClassNotFoundException
{    if (log.isInfoEnabled()) {        log.info("Running Clustering");        log.info("Input: {} Clusters In: {} Out: {}", input, clustersIn, output);    }    ClusterClassifier.writePolicy(new KMeansClusteringPolicy(), clustersIn);    ClusterClassificationDriver.run(conf, input, output, new Path(output, PathDirectory.CLUSTERED_POINTS_DIRECTORY), clusterClassificationThreshold, true, runSequential);}
5f304ab16ab0e7dc36798c1adf93205645fd8b5cadb23cc7be4415efc280c7fa
configureWithClusterInfo
public static void configureWithClusterInfo(Configuration conf, Path clusterPath, Collection<Cluster> clusters)
{    for (Writable value : new SequenceFileDirValueIterable<>(clusterPath, PathType.LIST, PathFilters.partFilter(), conf)) {        Class<? extends Writable> valueClass = value.getClass();        if (valueClass.equals(ClusterWritable.class)) {            ClusterWritable clusterWritable = (ClusterWritable) value;            value = clusterWritable.getValue();            valueClass = value.getClass();        }        log.debug("Read 1 Cluster from {}", clusterPath);        if (valueClass.equals(Kluster.class)) {                        clusters.add((Kluster) value);        } else if (valueClass.equals(Canopy.class)) {                        Canopy canopy = (Canopy) value;            clusters.add(new Kluster(canopy.getCenter(), canopy.getId(), canopy.getMeasure()));        } else {            throw new IllegalStateException("Bad value class: " + valueClass);        }    }}
0743de795e3f65ced0bd01b9cc12617ec190ba41184bd8d641c419fc6bf6d83e
buildRandom
public static Path buildRandom(Configuration conf, Path input, Path output, int k, DistanceMeasure measure) throws IOException
{    return buildRandom(conf, input, output, k, measure, null);}
94f89da068f3cdc22a60a5a2668263dd270d22c9e73086e40d95bfe648f003ad
buildRandom
public static Path buildRandom(Configuration conf, Path input, Path output, int k, DistanceMeasure measure, Long seed) throws IOException
{    Preconditions.checkArgument(k > 0, "Must be: k > 0, but k = " + k);        FileSystem fs = FileSystem.get(output.toUri(), conf);    HadoopUtil.delete(conf, output);    Path outFile = new Path(output, "part-randomSeed");    boolean newFile = fs.createNewFile(outFile);    if (newFile) {        Path inputPathPattern;        if (fs.getFileStatus(input).isDir()) {            inputPathPattern = new Path(input, "*");        } else {            inputPathPattern = input;        }        FileStatus[] inputFiles = fs.globStatus(inputPathPattern, PathFilters.logsCRCFilter());        Random random = (seed != null) ? RandomUtils.getRandom(seed) : RandomUtils.getRandom();        List<Text> chosenTexts = new ArrayList<>(k);        List<ClusterWritable> chosenClusters = new ArrayList<>(k);        int nextClusterId = 0;        int index = 0;        for (FileStatus fileStatus : inputFiles) {            if (!fileStatus.isDir()) {                for (Pair<Writable, VectorWritable> record : new SequenceFileIterable<Writable, VectorWritable>(fileStatus.getPath(), true, conf)) {                    Writable key = record.getFirst();                    VectorWritable value = record.getSecond();                    Kluster newCluster = new Kluster(value.get(), nextClusterId++, measure);                    newCluster.observe(value.get(), 1);                    Text newText = new Text(key.toString());                    int currentSize = chosenTexts.size();                    if (currentSize < k) {                        chosenTexts.add(newText);                        ClusterWritable clusterWritable = new ClusterWritable();                        clusterWritable.setValue(newCluster);                        chosenClusters.add(clusterWritable);                    } else {                        int j = random.nextInt(index);                        if (j < k) {                            chosenTexts.set(j, newText);                            ClusterWritable clusterWritable = new ClusterWritable();                            clusterWritable.setValue(newCluster);                            chosenClusters.set(j, clusterWritable);                        }                    }                    index++;                }            }        }        try (SequenceFile.Writer writer = SequenceFile.createWriter(fs, conf, outFile, Text.class, ClusterWritable.class)) {            for (int i = 0; i < chosenTexts.size(); i++) {                writer.append(chosenTexts.get(i), chosenClusters.get(i));            }            log.info("Wrote {} Klusters to {}", k, outFile);        }    }    return outFile;}
1e7c2ed0db4166fbba51a7962489e4a65f4ca3820416c3e0332bb8e327277bbb
getModelTrainer
protected ModelTrainer getModelTrainer()
{    return modelTrainer;}
85b36ec96886bd5c6b2423a571bbfc7c0a9a8592c2a943783afa617957171d7d
getMaxIters
protected int getMaxIters()
{    return maxIters;}
5462ce363c34b11578a08e08fb022a58b23f456b909a8134e506dba39ab04aef
getNumTopics
protected int getNumTopics()
{    return numTopics;}
6b7dd49be7482fc8ee0fbe8bd0f24522f2a718c8c816a3d7b048fb4688eb6373
setup
protected void setup(Context context) throws IOException, InterruptedException
{    log.info("Retrieving configuration");    Configuration conf = context.getConfiguration();    float eta = conf.getFloat(CVB0Driver.TERM_TOPIC_SMOOTHING, Float.NaN);    float alpha = conf.getFloat(CVB0Driver.DOC_TOPIC_SMOOTHING, Float.NaN);    long seed = conf.getLong(CVB0Driver.RANDOM_SEED, 1234L);    numTopics = conf.getInt(CVB0Driver.NUM_TOPICS, -1);    int numTerms = conf.getInt(CVB0Driver.NUM_TERMS, -1);    int numUpdateThreads = conf.getInt(CVB0Driver.NUM_UPDATE_THREADS, 1);    int numTrainThreads = conf.getInt(CVB0Driver.NUM_TRAIN_THREADS, 4);    maxIters = conf.getInt(CVB0Driver.MAX_ITERATIONS_PER_DOC, 10);    float modelWeight = conf.getFloat(CVB0Driver.MODEL_WEIGHT, 1.0f);    log.info("Initializing read model");    Path[] modelPaths = CVB0Driver.getModelPaths(conf);    if (modelPaths != null && modelPaths.length > 0) {        readModel = new TopicModel(conf, eta, alpha, null, numUpdateThreads, modelWeight, modelPaths);    } else {        log.info("No model files found");        readModel = new TopicModel(numTopics, numTerms, eta, alpha, RandomUtils.getRandom(seed), null, numTrainThreads, modelWeight);    }    log.info("Initializing write model");    writeModel = modelWeight == 1 ? new TopicModel(numTopics, numTerms, eta, alpha, null, numUpdateThreads) : readModel;    log.info("Initializing model trainer");    modelTrainer = new ModelTrainer(readModel, writeModel, numTrainThreads, numTopics, numTerms);    modelTrainer.start();}
17b35ea368ddf8da73ca358f2c7eba2985636085422c958494a726196c5d0614
map
public void map(IntWritable docId, VectorWritable document, Context context) throws IOException, InterruptedException
{    /* where to get docTopics? */    Vector topicVector = new DenseVector(numTopics).assign(1.0 / numTopics);    modelTrainer.train(document.get(), topicVector, true, maxIters);}
2e250b70eb1261a97967b8b894cf822fc9e7eb36891dbb77c6d16369f85de12a
cleanup
protected void cleanup(Context context) throws IOException, InterruptedException
{    log.info("Stopping model trainer");    modelTrainer.stop();    log.info("Writing model");    TopicModel readFrom = modelTrainer.getReadModel();    for (MatrixSlice topic : readFrom) {        context.write(new IntWritable(topic.index()), new VectorWritable(topic.vector()));    }    readModel.stop();    writeModel.stop();}
6b7dd49be7482fc8ee0fbe8bd0f24522f2a718c8c816a3d7b048fb4688eb6373
setup
protected void setup(Context context) throws IOException, InterruptedException
{    MemoryUtil.startMemoryLogger(5000);    log.info("Retrieving configuration");    Configuration conf = context.getConfiguration();    float eta = conf.getFloat(CVB0Driver.TERM_TOPIC_SMOOTHING, Float.NaN);    float alpha = conf.getFloat(CVB0Driver.DOC_TOPIC_SMOOTHING, Float.NaN);    long seed = conf.getLong(CVB0Driver.RANDOM_SEED, 1234L);    random = RandomUtils.getRandom(seed);    numTopics = conf.getInt(CVB0Driver.NUM_TOPICS, -1);    int numTerms = conf.getInt(CVB0Driver.NUM_TERMS, -1);    int numUpdateThreads = conf.getInt(CVB0Driver.NUM_UPDATE_THREADS, 1);    int numTrainThreads = conf.getInt(CVB0Driver.NUM_TRAIN_THREADS, 4);    maxIters = conf.getInt(CVB0Driver.MAX_ITERATIONS_PER_DOC, 10);    float modelWeight = conf.getFloat(CVB0Driver.MODEL_WEIGHT, 1.0f);    testFraction = conf.getFloat(CVB0Driver.TEST_SET_FRACTION, 0.1f);    log.info("Initializing read model");    Path[] modelPaths = CVB0Driver.getModelPaths(conf);    if (modelPaths != null && modelPaths.length > 0) {        readModel = new TopicModel(conf, eta, alpha, null, numUpdateThreads, modelWeight, modelPaths);    } else {        log.info("No model files found");        readModel = new TopicModel(numTopics, numTerms, eta, alpha, RandomUtils.getRandom(seed), null, numTrainThreads, modelWeight);    }    log.info("Initializing model trainer");    modelTrainer = new ModelTrainer(readModel, null, numTrainThreads, numTopics, numTerms);    log.info("Initializing topic vector");    topicVector = new DenseVector(new double[numTopics]);}
2e250b70eb1261a97967b8b894cf822fc9e7eb36891dbb77c6d16369f85de12a
cleanup
protected void cleanup(Context context) throws IOException, InterruptedException
{    readModel.stop();    MemoryUtil.stopMemoryLogger();}
17b35ea368ddf8da73ca358f2c7eba2985636085422c958494a726196c5d0614
map
public void map(IntWritable docId, VectorWritable document, Context context) throws IOException, InterruptedException
{    if (testFraction < 1.0f && random.nextFloat() >= testFraction) {        return;    }    context.getCounter(Counters.SAMPLED_DOCUMENTS).increment(1);    outKey.set(document.get().norm(1));    outValue.set(modelTrainer.calculatePerplexity(document.get(), topicVector.assign(1.0 / numTopics), maxIters));    context.write(outKey, outValue);}
ccada495ea48cec6186e398716ab2a589552b347e4032b8e11e498b9d436ce02
map
public void map(IntWritable docId, VectorWritable doc, Context context) throws IOException, InterruptedException
{    int numTopics = getNumTopics();    Vector docTopics = new DenseVector(numTopics).assign(1.0 / numTopics);    Matrix docModel = new SparseRowMatrix(numTopics, doc.get().size());    int maxIters = getMaxIters();    ModelTrainer modelTrainer = getModelTrainer();    for (int i = 0; i < maxIters; i++) {        modelTrainer.getReadModel().trainDocTopicModel(doc.get(), docTopics, docModel);    }    topics.set(docTopics);    context.write(docId, topics);}
98fb80d26321ca83c58758df82aab07c12d11ddd4fac8d04499eef8aaff3314e
cleanup
protected void cleanup(Context context)
{    getModelTrainer().stop();}
aacecb0f01750d985b78d806dc3c134f0da79efe2752957e0f93ecf5cbf9e492
run
public int run(String[] args) throws Exception
{    addInputOption();    addOutputOption();    addOption(DefaultOptionCreator.maxIterationsOption().create());    addOption(DefaultOptionCreator.CONVERGENCE_DELTA_OPTION, "cd", "The convergence delta value", String.valueOf(DEFAULT_CONVERGENCE_DELTA));    addOption(DefaultOptionCreator.overwriteOption().create());    addOption(NUM_TOPICS, "k", "Number of topics to learn", true);    addOption(NUM_TERMS, "nt", "Vocabulary size", false);    addOption(DOC_TOPIC_SMOOTHING, "a", "Smoothing for document/topic distribution", String.valueOf(DEFAULT_DOC_TOPIC_SMOOTHING));    addOption(TERM_TOPIC_SMOOTHING, "e", "Smoothing for topic/term distribution", String.valueOf(DEFAULT_TERM_TOPIC_SMOOTHING));    addOption(DICTIONARY, "dict", "Path to term-dictionary file(s) (glob expression supported)", false);    addOption(DOC_TOPIC_OUTPUT, "dt", "Output path for the training doc/topic distribution", false);    addOption(MODEL_TEMP_DIR, "mt", "Path to intermediate model path (useful for restarting)", false);    addOption(ITERATION_BLOCK_SIZE, "block", "Number of iterations per perplexity check", String.valueOf(DEFAULT_ITERATION_BLOCK_SIZE));    addOption(RANDOM_SEED, "seed", "Random seed", false);    addOption(TEST_SET_FRACTION, "tf", "Fraction of data to hold out for testing", String.valueOf(DEFAULT_TEST_SET_FRACTION));    addOption(NUM_TRAIN_THREADS, "ntt", "number of threads per mapper to train with", String.valueOf(DEFAULT_NUM_TRAIN_THREADS));    addOption(NUM_UPDATE_THREADS, "nut", "number of threads per mapper to update the model with", String.valueOf(DEFAULT_NUM_UPDATE_THREADS));    addOption(MAX_ITERATIONS_PER_DOC, "mipd", "max number of iterations per doc for p(topic|doc) learning", String.valueOf(DEFAULT_MAX_ITERATIONS_PER_DOC));    addOption(NUM_REDUCE_TASKS, null, "number of reducers to use during model estimation", String.valueOf(DEFAULT_NUM_REDUCE_TASKS));    addOption(buildOption(BACKFILL_PERPLEXITY, null, "enable backfilling of missing perplexity values", false, false, null));    if (parseArguments(args) == null) {        return -1;    }    int numTopics = Integer.parseInt(getOption(NUM_TOPICS));    Path inputPath = getInputPath();    Path topicModelOutputPath = getOutputPath();    int maxIterations = Integer.parseInt(getOption(DefaultOptionCreator.MAX_ITERATIONS_OPTION));    int iterationBlockSize = Integer.parseInt(getOption(ITERATION_BLOCK_SIZE));    double convergenceDelta = Double.parseDouble(getOption(DefaultOptionCreator.CONVERGENCE_DELTA_OPTION));    double alpha = Double.parseDouble(getOption(DOC_TOPIC_SMOOTHING));    double eta = Double.parseDouble(getOption(TERM_TOPIC_SMOOTHING));    int numTrainThreads = Integer.parseInt(getOption(NUM_TRAIN_THREADS));    int numUpdateThreads = Integer.parseInt(getOption(NUM_UPDATE_THREADS));    int maxItersPerDoc = Integer.parseInt(getOption(MAX_ITERATIONS_PER_DOC));    Path dictionaryPath = hasOption(DICTIONARY) ? new Path(getOption(DICTIONARY)) : null;    int numTerms = hasOption(NUM_TERMS) ? Integer.parseInt(getOption(NUM_TERMS)) : getNumTerms(getConf(), dictionaryPath);    Path docTopicOutputPath = hasOption(DOC_TOPIC_OUTPUT) ? new Path(getOption(DOC_TOPIC_OUTPUT)) : null;    Path modelTempPath = hasOption(MODEL_TEMP_DIR) ? new Path(getOption(MODEL_TEMP_DIR)) : getTempPath("topicModelState");    long seed = hasOption(RANDOM_SEED) ? Long.parseLong(getOption(RANDOM_SEED)) : System.nanoTime() % 10000;    float testFraction = hasOption(TEST_SET_FRACTION) ? Float.parseFloat(getOption(TEST_SET_FRACTION)) : 0.0f;    int numReduceTasks = Integer.parseInt(getOption(NUM_REDUCE_TASKS));    boolean backfillPerplexity = hasOption(BACKFILL_PERPLEXITY);    return run(getConf(), inputPath, topicModelOutputPath, numTopics, numTerms, alpha, eta, maxIterations, iterationBlockSize, convergenceDelta, dictionaryPath, docTopicOutputPath, modelTempPath, seed, testFraction, numTrainThreads, numUpdateThreads, maxItersPerDoc, numReduceTasks, backfillPerplexity);}
691d78bfda0d9a3767d5228ec8449c273c2b71efa4abb4a0381e3bc5dc35d2f5
getNumTerms
private static int getNumTerms(Configuration conf, Path dictionaryPath) throws IOException
{    FileSystem fs = dictionaryPath.getFileSystem(conf);    Text key = new Text();    IntWritable value = new IntWritable();    int maxTermId = -1;    for (FileStatus stat : fs.globStatus(dictionaryPath)) {        SequenceFile.Reader reader = new SequenceFile.Reader(fs, stat.getPath(), conf);        while (reader.next(key, value)) {            maxTermId = Math.max(maxTermId, value.get());        }    }    return maxTermId + 1;}
6ffe4c6025ac43d25e7d637f4f17c5b8b6953ce387d25a18286c5019c86c7cbc
run
public int run(Configuration conf, Path inputPath, Path topicModelOutputPath, int numTopics, int numTerms, double alpha, double eta, int maxIterations, int iterationBlockSize, double convergenceDelta, Path dictionaryPath, Path docTopicOutputPath, Path topicModelStateTempPath, long randomSeed, float testFraction, int numTrainThreads, int numUpdateThreads, int maxItersPerDoc, int numReduceTasks, boolean backfillPerplexity) throws ClassNotFoundException, IOException, InterruptedException
{    setConf(conf);        Preconditions.checkArgument(testFraction >= 0.0 && testFraction <= 1.0, "Expected 'testFraction' value in range [0, 1] but found value '%s'", testFraction);    Preconditions.checkArgument(!backfillPerplexity || testFraction > 0.0, "Expected 'testFraction' value in range (0, 1] but found value '%s'", testFraction);    String infoString = "Will run Collapsed Variational Bayes (0th-derivative approximation) " + "learning for LDA on {} (numTerms: {}), finding {}-topics, with document/topic prior {}, " + "topic/term prior {}.  Maximum iterations to run will be {}, unless the change in " + "perplexity is less than {}.  Topic model output (p(term|topic) for each topic) will be " + "stored {}.  Random initialization seed is {}, holding out {} of the data for perplexity " + "check\n";    log.info(infoString, inputPath, numTerms, numTopics, alpha, eta, maxIterations, convergenceDelta, topicModelOutputPath, randomSeed, testFraction);    infoString = dictionaryPath == null ? "" : "Dictionary to be used located " + dictionaryPath.toString() + '\n';    infoString += docTopicOutputPath == null ? "" : "p(topic|docId) will be stored " + docTopicOutputPath.toString() + '\n';    log.info(infoString);    FileSystem fs = FileSystem.get(topicModelStateTempPath.toUri(), conf);    int iterationNumber = getCurrentIterationNumber(conf, topicModelStateTempPath, maxIterations);    log.info("Current iteration number: {}", iterationNumber);    conf.set(NUM_TOPICS, String.valueOf(numTopics));    conf.set(NUM_TERMS, String.valueOf(numTerms));    conf.set(DOC_TOPIC_SMOOTHING, String.valueOf(alpha));    conf.set(TERM_TOPIC_SMOOTHING, String.valueOf(eta));    conf.set(RANDOM_SEED, String.valueOf(randomSeed));    conf.set(NUM_TRAIN_THREADS, String.valueOf(numTrainThreads));    conf.set(NUM_UPDATE_THREADS, String.valueOf(numUpdateThreads));    conf.set(MAX_ITERATIONS_PER_DOC, String.valueOf(maxItersPerDoc));        conf.set(MODEL_WEIGHT, "1");    conf.set(TEST_SET_FRACTION, String.valueOf(testFraction));    List<Double> perplexities = new ArrayList<>();    for (int i = 1; i <= iterationNumber; i++) {                Path modelPath = modelPath(topicModelStateTempPath, i);                double perplexity = readPerplexity(conf, topicModelStateTempPath, i);        if (Double.isNaN(perplexity)) {            if (!(backfillPerplexity && i % iterationBlockSize == 0)) {                continue;            }            log.info("Backfilling perplexity at iteration {}", i);            if (!fs.exists(modelPath)) {                log.error("Model path '{}' does not exist; Skipping iteration {} perplexity calculation", modelPath.toString(), i);                continue;            }            perplexity = calculatePerplexity(conf, inputPath, modelPath, i);        }                perplexities.add(perplexity);        log.info("Perplexity at iteration {} = {}", i, perplexity);    }    long startTime = System.currentTimeMillis();    while (iterationNumber < maxIterations) {                if (convergenceDelta > 0.0) {            double delta = rateOfChange(perplexities);            if (delta < convergenceDelta) {                log.info("Convergence achieved at iteration {} with perplexity {} and delta {}", iterationNumber, perplexities.get(perplexities.size() - 1), delta);                break;            }        }                iterationNumber++;        log.info("About to run iteration {} of {}", iterationNumber, maxIterations);        Path modelInputPath = modelPath(topicModelStateTempPath, iterationNumber - 1);        Path modelOutputPath = modelPath(topicModelStateTempPath, iterationNumber);        runIteration(conf, inputPath, modelInputPath, modelOutputPath, iterationNumber, maxIterations, numReduceTasks);                if (testFraction > 0 && iterationNumber % iterationBlockSize == 0) {            perplexities.add(calculatePerplexity(conf, inputPath, modelOutputPath, iterationNumber));            log.info("Current perplexity = {}", perplexities.get(perplexities.size() - 1));            log.info("(p_{} - p_{}) / p_0 = {}; target = {}", iterationNumber, iterationNumber - iterationBlockSize, rateOfChange(perplexities), convergenceDelta);        }    }    log.info("Completed {} iterations in {} seconds", iterationNumber, (System.currentTimeMillis() - startTime) / 1000);    log.info("Perplexities: ({})", Joiner.on(", ").join(perplexities));        Path finalIterationData = modelPath(topicModelStateTempPath, iterationNumber);    Job topicModelOutputJob = topicModelOutputPath != null ? writeTopicModel(conf, finalIterationData, topicModelOutputPath) : null;    Job docInferenceJob = docTopicOutputPath != null ? writeDocTopicInference(conf, inputPath, finalIterationData, docTopicOutputPath) : null;    if (topicModelOutputJob != null && !topicModelOutputJob.waitForCompletion(true)) {        return -1;    }    if (docInferenceJob != null && !docInferenceJob.waitForCompletion(true)) {        return -1;    }    return 0;}
fd9691cf58d6cba39dbb4854fc2d888508a6162deb8d3352521c035a605a93a3
rateOfChange
private static double rateOfChange(List<Double> perplexities)
{    int sz = perplexities.size();    if (sz < 2) {        return Double.MAX_VALUE;    }    return Math.abs(perplexities.get(sz - 1) - perplexities.get(sz - 2)) / perplexities.get(0);}
380553f31ebb14e56f192372afb105eabf24950e308e7e38fd1de2925af92399
calculatePerplexity
private double calculatePerplexity(Configuration conf, Path corpusPath, Path modelPath, int iteration) throws IOException, ClassNotFoundException, InterruptedException
{    String jobName = "Calculating perplexity for " + modelPath;    log.info("About to run: {}", jobName);    Path outputPath = perplexityPath(modelPath.getParent(), iteration);    Job job = prepareJob(corpusPath, outputPath, CachingCVB0PerplexityMapper.class, DoubleWritable.class, DoubleWritable.class, DualDoubleSumReducer.class, DoubleWritable.class, DoubleWritable.class);    job.setJobName(jobName);    job.setCombinerClass(DualDoubleSumReducer.class);    job.setNumReduceTasks(1);    setModelPaths(job, modelPath);    HadoopUtil.delete(conf, outputPath);    if (!job.waitForCompletion(true)) {        throw new InterruptedException("Failed to calculate perplexity for: " + modelPath);    }    return readPerplexity(conf, modelPath.getParent(), iteration);}
f1b79cd73081803aac4d597efe66cc1e35d6cdcd7d3d407951eb90b869e57624
run
public void run(Context context) throws IOException, InterruptedException
{    double keySum = 0.0;    double valueSum = 0.0;    while (context.nextKey()) {        keySum += context.getCurrentKey().get();        for (DoubleWritable value : context.getValues()) {            valueSum += value.get();        }    }    outKey.set(keySum);    outValue.set(valueSum);    context.write(outKey, outValue);}
6bd460f9e2f1ed2da8db223850b9b13181adb3e95938dd3de6f99bb2dc2a4430
readPerplexity
public static double readPerplexity(Configuration conf, Path topicModelStateTemp, int iteration) throws IOException
{    Path perplexityPath = perplexityPath(topicModelStateTemp, iteration);    FileSystem fs = FileSystem.get(perplexityPath.toUri(), conf);    if (!fs.exists(perplexityPath)) {        log.warn("Perplexity path {} does not exist, returning NaN", perplexityPath);        return Double.NaN;    }    double perplexity = 0;    double modelWeight = 0;    long n = 0;    for (Pair<DoubleWritable, DoubleWritable> pair : new SequenceFileDirIterable<DoubleWritable, DoubleWritable>(perplexityPath, PathType.LIST, PathFilters.partFilter(), null, true, conf)) {        modelWeight += pair.getFirst().get();        perplexity += pair.getSecond().get();        n++;    }    log.info("Read {} entries with total perplexity {} and model weight {}", n, perplexity, modelWeight);    return perplexity / modelWeight;}
bfe7d6396ff0b36c2eea6f2ceb9829e6dcd6e4cafce80442dbbe0547716d4166
writeTopicModel
private Job writeTopicModel(Configuration conf, Path modelInput, Path output) throws IOException, InterruptedException, ClassNotFoundException
{    String jobName = String.format("Writing final topic/term distributions from %s to %s", modelInput, output);    log.info("About to run: {}", jobName);    Job job = prepareJob(modelInput, output, SequenceFileInputFormat.class, CVB0TopicTermVectorNormalizerMapper.class, IntWritable.class, VectorWritable.class, SequenceFileOutputFormat.class, jobName);    job.submit();    return job;}
1f2472c07392be36c5f39d052acfbd46051e5fdc7e5e9cab87f7435f703509b2
writeDocTopicInference
private Job writeDocTopicInference(Configuration conf, Path corpus, Path modelInput, Path output) throws IOException, ClassNotFoundException, InterruptedException
{    String jobName = String.format("Writing final document/topic inference from %s to %s", corpus, output);    log.info("About to run: {}", jobName);    Job job = prepareJob(corpus, output, SequenceFileInputFormat.class, CVB0DocInferenceMapper.class, IntWritable.class, VectorWritable.class, SequenceFileOutputFormat.class, jobName);    FileSystem fs = FileSystem.get(corpus.toUri(), conf);    if (modelInput != null && fs.exists(modelInput)) {        FileStatus[] statuses = fs.listStatus(modelInput, PathFilters.partFilter());        URI[] modelUris = new URI[statuses.length];        for (int i = 0; i < statuses.length; i++) {            modelUris[i] = statuses[i].getPath().toUri();        }        DistributedCache.setCacheFiles(modelUris, conf);        setModelPaths(job, modelInput);    }    job.submit();    return job;}
a46b079a9e10d8950bafe552cbbf804bc0f5a83a872434cdf7a1fdd0c3feab55
modelPath
public static Path modelPath(Path topicModelStateTempPath, int iterationNumber)
{    return new Path(topicModelStateTempPath, "model-" + iterationNumber);}
d29b410ba604e70a4415c19fc77f7a988d25e5295a07429125414fda78f7edad
perplexityPath
public static Path perplexityPath(Path topicModelStateTempPath, int iterationNumber)
{    return new Path(topicModelStateTempPath, "perplexity-" + iterationNumber);}
23940012cdc4e0372b7fda8962d1c8b822736e993a1e7a9ed675de180c5e1e94
getCurrentIterationNumber
private static int getCurrentIterationNumber(Configuration config, Path modelTempDir, int maxIterations) throws IOException
{    FileSystem fs = FileSystem.get(modelTempDir.toUri(), config);    int iterationNumber = 1;    Path iterationPath = modelPath(modelTempDir, iterationNumber);    while (fs.exists(iterationPath) && iterationNumber <= maxIterations) {        log.info("Found previous state: {}", iterationPath);        iterationNumber++;        iterationPath = modelPath(modelTempDir, iterationNumber);    }    return iterationNumber - 1;}
5741ebc0ef24ebcf7fcc6bd09deb66674dca65af99c41911418b9b2c5e45d12e
runIteration
public void runIteration(Configuration conf, Path corpusInput, Path modelInput, Path modelOutput, int iterationNumber, int maxIterations, int numReduceTasks) throws IOException, ClassNotFoundException, InterruptedException
{    String jobName = String.format("Iteration %d of %d, input path: %s", iterationNumber, maxIterations, modelInput);    log.info("About to run: {}", jobName);    Job job = prepareJob(corpusInput, modelOutput, CachingCVB0Mapper.class, IntWritable.class, VectorWritable.class, VectorSumReducer.class, IntWritable.class, VectorWritable.class);    job.setCombinerClass(VectorSumReducer.class);    job.setNumReduceTasks(numReduceTasks);    job.setJobName(jobName);    setModelPaths(job, modelInput);    HadoopUtil.delete(conf, modelOutput);    if (!job.waitForCompletion(true)) {        throw new InterruptedException(String.format("Failed to complete iteration %d stage 1", iterationNumber));    }}
c7a24230015766a2a648ae00c3e1150a2a79b679c2aa09b5159b911623724df1
setModelPaths
private static void setModelPaths(Job job, Path modelPath) throws IOException
{    Configuration conf = job.getConfiguration();    if (modelPath == null || !FileSystem.get(modelPath.toUri(), conf).exists(modelPath)) {        return;    }    FileStatus[] statuses = FileSystem.get(modelPath.toUri(), conf).listStatus(modelPath, PathFilters.partFilter());    Preconditions.checkState(statuses.length > 0, "No part files found in model path '%s'", modelPath.toString());    String[] modelPaths = new String[statuses.length];    for (int i = 0; i < statuses.length; i++) {        modelPaths[i] = statuses[i].getPath().toUri().toString();    }    conf.setStrings(MODEL_PATHS, modelPaths);}
b50f519efd74f89cd89ba3cb8585677a203747a09af62cf13f245215b0a007ad
getModelPaths
public static Path[] getModelPaths(Configuration conf)
{    String[] modelPathNames = conf.getStrings(MODEL_PATHS);    if (modelPathNames == null || modelPathNames.length == 0) {        return null;    }    Path[] modelPaths = new Path[modelPathNames.length];    for (int i = 0; i < modelPathNames.length; i++) {        modelPaths[i] = new Path(modelPathNames[i]);    }    return modelPaths;}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    ToolRunner.run(new Configuration(), new CVB0Driver(), args);}
b32d53b76be17c259dec1fb28708d1dc8c56fdc392675bbdac5be7f2e9f09ab1
map
protected void map(IntWritable key, VectorWritable value, Context context) throws IOException, InterruptedException
{    value.get().assign(Functions.div(value.get().norm(1.0)));    context.write(key, value);}
839b8ece04fcfb0053039b47f11b7bc35da253e9e1562b0f0a424bf03d98c2e9
setVerbose
public void setVerbose(boolean verbose)
{    this.verbose = verbose;}
f1395597c9fcef2574734064203736cca54b3bdd75246e7f74dc596a5d851b43
postInitCorpus
private void postInitCorpus()
{    totalCorpusWeight = 0;    int numNonZero = 0;    for (int i = 0; i < numDocuments; i++) {        Vector v = corpusWeights.viewRow(i);        double norm;        if (v != null && (norm = v.norm(1)) != 0) {            numNonZero += v.getNumNondefaultElements();            totalCorpusWeight += norm;        }    }    String s = "Initializing corpus with %d docs, %d terms, %d nonzero entries, total termWeight %f";    log.info(String.format(s, numDocuments, numTerms, numNonZero, totalCorpusWeight));}
cbc40803691d0993d98d18ad8d690db6a07332f55367939d973fac665bc7a111
initializeModel
private void initializeModel()
{    TopicModel topicModel = new TopicModel(numTopics, numTerms, eta, alpha, RandomUtils.getRandom(), terms, numUpdatingThreads, initialModelCorpusFraction == 0 ? 1 : initialModelCorpusFraction * totalCorpusWeight);    topicModel.setConf(getConf());    TopicModel updatedModel = initialModelCorpusFraction == 0 ? new TopicModel(numTopics, numTerms, eta, alpha, null, terms, numUpdatingThreads, 1) : topicModel;    updatedModel.setConf(getConf());    docTopicCounts = new DenseMatrix(numDocuments, numTopics);    docTopicCounts.assign(1.0 / numTopics);    modelTrainer = new ModelTrainer(topicModel, updatedModel, numTrainingThreads, numTopics, numTerms);}
6e395ddb7eedf63200d1601b15413cbd0d2f4ff246ef55eb8ed7153001748ac9
trainDocuments
public void trainDocuments()
{    trainDocuments(0);}
c19c5978c2c314f3427f965e4f253880957bbc422b591b5deef625b851263033
trainDocuments
public void trainDocuments(double testFraction)
{    long start = System.nanoTime();    modelTrainer.start();    for (int docId = 0; docId < corpusWeights.numRows(); docId++) {        if (testFraction == 0 || docId % (1 / testFraction) != 0) {                        Vector docTopics = new DenseVector(numTopics).assign(1.0 / numTopics);            modelTrainer.trainSync(corpusWeights.viewRow(docId), docTopics, true, 10);        }    }    modelTrainer.stop();    logTime("train documents", System.nanoTime() - start);}
8bc77760bfce8e76946f677f1e291b673b4be2a3e24254fe38a6b7200c098e3c
iterateUntilConvergence
public double iterateUntilConvergence(double minFractionalErrorChange, int maxIterations, int minIter)
{    return iterateUntilConvergence(minFractionalErrorChange, maxIterations, minIter, 0);}
d929015d61eb045ab7aa04fdcaaed2546b600c822229d9f63adb6aa887926d8b
iterateUntilConvergence
public double iterateUntilConvergence(double minFractionalErrorChange, int maxIterations, int minIter, double testFraction)
{    int iter = 0;    double oldPerplexity = 0;    while (iter < minIter) {        trainDocuments(testFraction);        if (verbose) {            log.info("model after: {}: {}", iter, modelTrainer.getReadModel());        }        log.info("iteration {} complete", iter);        oldPerplexity = modelTrainer.calculatePerplexity(corpusWeights, docTopicCounts, testFraction);        log.info("{} = perplexity", oldPerplexity);        iter++;    }    double newPerplexity = 0;    double fractionalChange = Double.MAX_VALUE;    while (iter < maxIterations && fractionalChange > minFractionalErrorChange) {        trainDocuments();        if (verbose) {            log.info("model after: {}: {}", iter, modelTrainer.getReadModel());        }        newPerplexity = modelTrainer.calculatePerplexity(corpusWeights, docTopicCounts, testFraction);        log.info("{} = perplexity", newPerplexity);        iter++;        fractionalChange = Math.abs(newPerplexity - oldPerplexity) / oldPerplexity;        log.info("{} = fractionalChange", fractionalChange);        oldPerplexity = newPerplexity;    }    if (iter < maxIterations) {        log.info(String.format("Converged! fractional error change: %f, error %f", fractionalChange, newPerplexity));    } else {        log.info(String.format("Reached max iteration count (%d), fractional error change: %f, error: %f", maxIterations, fractionalChange, newPerplexity));    }    return newPerplexity;}
3d446ab0ed7f31388856939563978cee1749ff720a0b126720243d5f3989e098
writeModel
public void writeModel(Path outputPath) throws IOException
{    modelTrainer.persist(outputPath);}
2713ff4526a7d8c3d651d1693a7d7d89ec303f03e6ea98bbdc19e149fc2c7eab
logTime
private static void logTime(String label, long nanos)
{    log.info("{} time: {}ms", label, nanos / 1.0e6);}
1427783963648426ad8398553017c3f0e6a2448b82b89996db9da023de75fbb7
main2
public static int main2(String[] args, Configuration conf) throws Exception
{    DefaultOptionBuilder obuilder = new DefaultOptionBuilder();    ArgumentBuilder abuilder = new ArgumentBuilder();    GroupBuilder gbuilder = new GroupBuilder();    Option helpOpt = DefaultOptionCreator.helpOption();    Option inputDirOpt = obuilder.withLongName("input").withRequired(true).withArgument(abuilder.withName("input").withMinimum(1).withMaximum(1).create()).withDescription("The Directory on HDFS containing the collapsed, properly formatted files having " + "one doc per line").withShortName("i").create();    Option dictOpt = obuilder.withLongName("dictionary").withRequired(false).withArgument(abuilder.withName("dictionary").withMinimum(1).withMaximum(1).create()).withDescription("The path to the term-dictionary format is ... ").withShortName("d").create();    Option dfsOpt = obuilder.withLongName("dfs").withRequired(false).withArgument(abuilder.withName("dfs").withMinimum(1).withMaximum(1).create()).withDescription("HDFS namenode URI").withShortName("dfs").create();    Option numTopicsOpt = obuilder.withLongName("numTopics").withRequired(true).withArgument(abuilder.withName("numTopics").withMinimum(1).withMaximum(1).create()).withDescription("Number of topics to learn").withShortName("top").create();    Option outputTopicFileOpt = obuilder.withLongName("topicOutputFile").withRequired(true).withArgument(abuilder.withName("topicOutputFile").withMinimum(1).withMaximum(1).create()).withDescription("File to write out p(term | topic)").withShortName("to").create();    Option outputDocFileOpt = obuilder.withLongName("docOutputFile").withRequired(true).withArgument(abuilder.withName("docOutputFile").withMinimum(1).withMaximum(1).create()).withDescription("File to write out p(topic | docid)").withShortName("do").create();    Option alphaOpt = obuilder.withLongName("alpha").withRequired(false).withArgument(abuilder.withName("alpha").withMinimum(1).withMaximum(1).withDefault("0.1").create()).withDescription("Smoothing parameter for p(topic | document) prior").withShortName("a").create();    Option etaOpt = obuilder.withLongName("eta").withRequired(false).withArgument(abuilder.withName("eta").withMinimum(1).withMaximum(1).withDefault("0.1").create()).withDescription("Smoothing parameter for p(term | topic)").withShortName("e").create();    Option maxIterOpt = obuilder.withLongName("maxIterations").withRequired(false).withArgument(abuilder.withName("maxIterations").withMinimum(1).withMaximum(1).withDefault("10").create()).withDescription("Maximum number of training passes").withShortName("m").create();    Option modelCorpusFractionOption = obuilder.withLongName("modelCorpusFraction").withRequired(false).withArgument(abuilder.withName("modelCorpusFraction").withMinimum(1).withMaximum(1).withDefault("0.0").create()).withShortName("mcf").withDescription("For online updates, initial value of |model|/|corpus|").create();    Option burnInOpt = obuilder.withLongName("burnInIterations").withRequired(false).withArgument(abuilder.withName("burnInIterations").withMinimum(1).withMaximum(1).withDefault("5").create()).withDescription("Minimum number of iterations").withShortName("b").create();    Option convergenceOpt = obuilder.withLongName("convergence").withRequired(false).withArgument(abuilder.withName("convergence").withMinimum(1).withMaximum(1).withDefault("0.0").create()).withDescription("Fractional rate of perplexity to consider convergence").withShortName("c").create();    Option reInferDocTopicsOpt = obuilder.withLongName("reInferDocTopics").withRequired(false).withArgument(abuilder.withName("reInferDocTopics").withMinimum(1).withMaximum(1).withDefault("no").create()).withDescription("re-infer p(topic | doc) : [no | randstart | continue]").withShortName("rdt").create();    Option numTrainThreadsOpt = obuilder.withLongName("numTrainThreads").withRequired(false).withArgument(abuilder.withName("numTrainThreads").withMinimum(1).withMaximum(1).withDefault("1").create()).withDescription("number of threads to train with").withShortName("ntt").create();    Option numUpdateThreadsOpt = obuilder.withLongName("numUpdateThreads").withRequired(false).withArgument(abuilder.withName("numUpdateThreads").withMinimum(1).withMaximum(1).withDefault("1").create()).withDescription("number of threads to update the model with").withShortName("nut").create();    Option verboseOpt = obuilder.withLongName("verbose").withRequired(false).withArgument(abuilder.withName("verbose").withMinimum(1).withMaximum(1).withDefault("false").create()).withDescription("print verbose information, like top-terms in each topic, during iteration").withShortName("v").create();    Group group = gbuilder.withName("Options").withOption(inputDirOpt).withOption(numTopicsOpt).withOption(alphaOpt).withOption(etaOpt).withOption(maxIterOpt).withOption(burnInOpt).withOption(convergenceOpt).withOption(dictOpt).withOption(reInferDocTopicsOpt).withOption(outputDocFileOpt).withOption(outputTopicFileOpt).withOption(dfsOpt).withOption(numTrainThreadsOpt).withOption(numUpdateThreadsOpt).withOption(modelCorpusFractionOption).withOption(verboseOpt).create();    try {        Parser parser = new Parser();        parser.setGroup(group);        parser.setHelpOption(helpOpt);        CommandLine cmdLine = parser.parse(args);        if (cmdLine.hasOption(helpOpt)) {            CommandLineUtil.printHelp(group);            return -1;        }        String inputDirString = (String) cmdLine.getValue(inputDirOpt);        String dictDirString = cmdLine.hasOption(dictOpt) ? (String) cmdLine.getValue(dictOpt) : null;        int numTopics = Integer.parseInt((String) cmdLine.getValue(numTopicsOpt));        double alpha = Double.parseDouble((String) cmdLine.getValue(alphaOpt));        double eta = Double.parseDouble((String) cmdLine.getValue(etaOpt));        int maxIterations = Integer.parseInt((String) cmdLine.getValue(maxIterOpt));        int burnInIterations = Integer.parseInt((String) cmdLine.getValue(burnInOpt));        double minFractionalErrorChange = Double.parseDouble((String) cmdLine.getValue(convergenceOpt));        int numTrainThreads = Integer.parseInt((String) cmdLine.getValue(numTrainThreadsOpt));        int numUpdateThreads = Integer.parseInt((String) cmdLine.getValue(numUpdateThreadsOpt));        String topicOutFile = (String) cmdLine.getValue(outputTopicFileOpt);        String docOutFile = (String) cmdLine.getValue(outputDocFileOpt);                boolean verbose = Boolean.parseBoolean((String) cmdLine.getValue(verboseOpt));        double modelCorpusFraction = Double.parseDouble((String) cmdLine.getValue(modelCorpusFractionOption));        long start = System.nanoTime();        if (conf.get("fs.default.name") == null) {            String dfsNameNode = (String) cmdLine.getValue(dfsOpt);            conf.set("fs.default.name", dfsNameNode);        }        String[] terms = loadDictionary(dictDirString, conf);        logTime("dictionary loading", System.nanoTime() - start);        start = System.nanoTime();        Matrix corpus = loadVectors(inputDirString, conf);        logTime("vector seqfile corpus loading", System.nanoTime() - start);        start = System.nanoTime();        InMemoryCollapsedVariationalBayes0 cvb0 = new InMemoryCollapsedVariationalBayes0(corpus, terms, numTopics, alpha, eta, numTrainThreads, numUpdateThreads, modelCorpusFraction);        logTime("cvb0 init", System.nanoTime() - start);        start = System.nanoTime();        cvb0.setVerbose(verbose);        cvb0.iterateUntilConvergence(minFractionalErrorChange, maxIterations, burnInIterations);        logTime("total training time", System.nanoTime() - start);        /*      if ("randstart".equalsIgnoreCase(reInferDocTopics)) {        cvb0.inferDocuments(0.0, 100, true);      } else if ("continue".equalsIgnoreCase(reInferDocTopics)) {        cvb0.inferDocuments(0.0, 100, false);      }       */        start = System.nanoTime();        cvb0.writeModel(new Path(topicOutFile));        DistributedRowMatrixWriter.write(new Path(docOutFile), conf, cvb0.docTopicCounts);        logTime("printTopics", System.nanoTime() - start);    } catch (OptionException e) {        log.error("Error while parsing options", e);        CommandLineUtil.printHelp(group);    }    return 0;}
39b2096844c468bf4e31ed03ee1e0b3f6f1572a21b32f8b4b4a64cc4d0c3c12d
loadDictionary
private static String[] loadDictionary(String dictionaryPath, Configuration conf)
{    if (dictionaryPath == null) {        return null;    }    Path dictionaryFile = new Path(dictionaryPath);    List<Pair<Integer, String>> termList = new ArrayList<>();    int maxTermId = 0;        for (Pair<Writable, IntWritable> record : new SequenceFileIterable<Writable, IntWritable>(dictionaryFile, true, conf)) {        termList.add(new Pair<>(record.getSecond().get(), record.getFirst().toString()));        maxTermId = Math.max(maxTermId, record.getSecond().get());    }    String[] terms = new String[maxTermId + 1];    for (Pair<Integer, String> pair : termList) {        terms[pair.getFirst()] = pair.getSecond();    }    return terms;}
d221713f567be6c3a854157b6beb8a5fd5dd64b69c1ef157fb4bac811a41c3f7
getConf
public Configuration getConf()
{    return super.getConf();}
df4251594b8c1e062e22d27286a582926ebfe1deb82ec6342e3b9efd750975d6
loadVectors
private static Matrix loadVectors(String vectorPathString, Configuration conf) throws IOException
{    Path vectorPath = new Path(vectorPathString);    FileSystem fs = vectorPath.getFileSystem(conf);    List<Path> subPaths = new ArrayList<>();    if (fs.isFile(vectorPath)) {        subPaths.add(vectorPath);    } else {        for (FileStatus fileStatus : fs.listStatus(vectorPath, PathFilters.logsCRCFilter())) {            subPaths.add(fileStatus.getPath());        }    }    List<Pair<Integer, Vector>> rowList = new ArrayList<>();    int numRows = Integer.MIN_VALUE;    int numCols = -1;    boolean sequentialAccess = false;    for (Path subPath : subPaths) {        for (Pair<IntWritable, VectorWritable> record : new SequenceFileIterable<IntWritable, VectorWritable>(subPath, true, conf)) {            int id = record.getFirst().get();            Vector vector = record.getSecond().get();            if (vector instanceof NamedVector) {                vector = ((NamedVector) vector).getDelegate();            }            if (numCols < 0) {                numCols = vector.size();                sequentialAccess = vector.isSequentialAccess();            }            rowList.add(Pair.of(id, vector));            numRows = Math.max(numRows, id);        }    }    numRows++;    Vector[] rowVectors = new Vector[numRows];    for (Pair<Integer, Vector> pair : rowList) {        rowVectors[pair.getFirst()] = pair.getSecond();    }    return new SparseRowMatrix(numRows, numCols, rowVectors, true, !sequentialAccess);}
b31cb6a894acd9e406667b955507e22a99129892a3c5ceaddbedccc2f2a9db5b
run
public int run(String[] strings) throws Exception
{    return main2(strings, getConf());}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    ToolRunner.run(new InMemoryCollapsedVariationalBayes0(), args);}
c0dae99c41ab1c49496c2ef3035d112e5f623b1d7e2ffd1a051bf93a151f0525
getReadModel
public TopicModel getReadModel()
{    return readModel;}
fe470100a468aa20bc462dab09f768d6e2ce225f184a550d87d7243e3d0f5667
start
public void start()
{    log.info("Starting training threadpool with {} threads", numTrainThreads);    workQueue = new ArrayBlockingQueue<>(numTrainThreads * 10);    threadPool = new ThreadPoolExecutor(numTrainThreads, numTrainThreads, 0, TimeUnit.SECONDS, workQueue);    threadPool.allowCoreThreadTimeOut(false);    threadPool.prestartAllCoreThreads();    writeModel.reset();}
6962553e0826f11f9d1832642eb339eaaba7e44085d3ce7b0cfeeac47e826146
train
public void train(VectorIterable matrix, VectorIterable docTopicCounts)
{    train(matrix, docTopicCounts, 1);}
9d9f34de73d50619d2a1baae448d7e5d2e89ce5ade1118a790b92eacfb5469df
calculatePerplexity
public double calculatePerplexity(VectorIterable matrix, VectorIterable docTopicCounts)
{    return calculatePerplexity(matrix, docTopicCounts, 0);}
29f8ca3ee7f83949a7ba44dc813aa20cbee104b8d5495ad8abf1502c84a64c26
calculatePerplexity
public double calculatePerplexity(VectorIterable matrix, VectorIterable docTopicCounts, double testFraction)
{    Iterator<MatrixSlice> docIterator = matrix.iterator();    Iterator<MatrixSlice> docTopicIterator = docTopicCounts.iterator();    double perplexity = 0;    double matrixNorm = 0;    while (docIterator.hasNext() && docTopicIterator.hasNext()) {        MatrixSlice docSlice = docIterator.next();        MatrixSlice topicSlice = docTopicIterator.next();        int docId = docSlice.index();        Vector document = docSlice.vector();        Vector topicDist = topicSlice.vector();        if (testFraction == 0 || docId % (1 / testFraction) == 0) {            trainSync(document, topicDist, false, 10);            perplexity += readModel.perplexity(document, topicDist);            matrixNorm += document.norm(1);        }    }    return perplexity / matrixNorm;}
b85d74672dfbdd01425c8b1633f2434958e1aef9766f21307c96881806222f9e
train
public void train(VectorIterable matrix, VectorIterable docTopicCounts, int numDocTopicIters)
{    start();    Iterator<MatrixSlice> docIterator = matrix.iterator();    Iterator<MatrixSlice> docTopicIterator = docTopicCounts.iterator();    long startTime = System.nanoTime();    int i = 0;    double[] times = new double[100];    Map<Vector, Vector> batch = new HashMap<>();    int numTokensInBatch = 0;    long batchStart = System.nanoTime();    while (docIterator.hasNext() && docTopicIterator.hasNext()) {        i++;        Vector document = docIterator.next().vector();        Vector topicDist = docTopicIterator.next().vector();        if (isReadWrite) {            if (batch.size() < numTrainThreads) {                batch.put(document, topicDist);                if (log.isDebugEnabled()) {                    numTokensInBatch += document.getNumNondefaultElements();                }            } else {                batchTrain(batch, true, numDocTopicIters);                long time = System.nanoTime();                log.debug("trained {} docs with {} tokens, start time {}, end time {}", numTrainThreads, numTokensInBatch, batchStart, time);                batchStart = time;                numTokensInBatch = 0;            }        } else {            long start = System.nanoTime();            train(document, topicDist, true, numDocTopicIters);            if (log.isDebugEnabled()) {                times[i % times.length] = (System.nanoTime() - start) / (1.0e6 * document.getNumNondefaultElements());                if (i % 100 == 0) {                    long time = System.nanoTime() - startTime;                    log.debug("trained {} documents in {}ms", i, time / 1.0e6);                    if (i % 500 == 0) {                        Arrays.sort(times);                        log.debug("training took median {}ms per token-instance", times[times.length / 2]);                    }                }            }        }    }    stop();}
7d070f3bb600bbb7eaa5364bd8b6df933744b39bc4f0749160151f5bf5d3994f
batchTrain
public void batchTrain(Map<Vector, Vector> batch, boolean update, int numDocTopicsIters)
{    while (true) {        try {            List<TrainerRunnable> runnables = new ArrayList<>();            for (Map.Entry<Vector, Vector> entry : batch.entrySet()) {                runnables.add(new TrainerRunnable(readModel, null, entry.getKey(), entry.getValue(), new SparseRowMatrix(numTopics, numTerms, true), numDocTopicsIters));            }            threadPool.invokeAll(runnables);            if (update) {                for (TrainerRunnable runnable : runnables) {                    writeModel.update(runnable.docTopicModel);                }            }            break;        } catch (InterruptedException e) {            log.warn("Interrupted during batch training, retrying!", e);        }    }}
91bfe7dc14dc174edf50a419056da94238312be638fb337d2a2d92a502b0043a
train
public void train(Vector document, Vector docTopicCounts, boolean update, int numDocTopicIters)
{    while (true) {        try {            workQueue.put(new TrainerRunnable(readModel, update ? writeModel : null, document, docTopicCounts, new SparseRowMatrix(numTopics, numTerms, true), numDocTopicIters));            return;        } catch (InterruptedException e) {            log.warn("Interrupted waiting to submit document to work queue: {}", document, e);        }    }}
cdba72df895cdb8393adda1f8db75548c4c508951ade5e23ba543b6bca96768b
trainSync
public void trainSync(Vector document, Vector docTopicCounts, boolean update, int numDocTopicIters)
{    new TrainerRunnable(readModel, update ? writeModel : null, document, docTopicCounts, new SparseRowMatrix(numTopics, numTerms, true), numDocTopicIters).run();}
38ccc2024abc4a9bab068d52186658142c4da219cd1fcdfe53f8ba28e7fe2096
calculatePerplexity
public double calculatePerplexity(Vector document, Vector docTopicCounts, int numDocTopicIters)
{    TrainerRunnable runner = new TrainerRunnable(readModel, null, document, docTopicCounts, new SparseRowMatrix(numTopics, numTerms, true), numDocTopicIters);    return runner.call();}
4e5c4125627f8fae3fcb8fa1c2fa25ff160d3eec452770c97bbb601a580fe141
stop
public void stop()
{    long startTime = System.nanoTime();    log.info("Initiating stopping of training threadpool");    try {        threadPool.shutdown();        if (!threadPool.awaitTermination(60, TimeUnit.SECONDS)) {            log.warn("Threadpool timed out on await termination - jobs still running!");        }        long newTime = System.nanoTime();        log.info("threadpool took: {}ms", (newTime - startTime) / 1.0e6);        startTime = newTime;        readModel.stop();        newTime = System.nanoTime();        log.info("readModel.stop() took {}ms", (newTime - startTime) / 1.0e6);        startTime = newTime;        writeModel.stop();        newTime = System.nanoTime();        log.info("writeModel.stop() took {}ms", (newTime - startTime) / 1.0e6);        TopicModel tmpModel = writeModel;        writeModel = readModel;        readModel = tmpModel;    } catch (InterruptedException e) {        log.error("Interrupted shutting down!", e);    }}
8a825543e8c21eed76171717c1dd7ed613aab5146b4bfe838c26747d49f6ac6b
persist
public void persist(Path outputPath) throws IOException
{    readModel.persist(outputPath, true);}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    for (int i = 0; i < numDocTopicIters; i++) {                readModel.trainDocTopicModel(document, docTopics, docTopicModel);    }    if (writeModel != null) {                                writeModel.update(docTopicModel);    }}
de8f0a3f43b72187ef1973d3ed754599002257f7520bf7663e1c26fb9658581f
call
public Double call()
{    run();    return readModel.perplexity(document, docTopics);}
d7f96df35399b3495c0bdd8322036fe3dba4c6bfedb4249975f8de976b809c85
getNumTerms
public int getNumTerms()
{    return numTerms;}
508f3ef98117b38829a1e567304a193375c6108c51dc75499a0e5afa48b496b4
getNumTopics
public int getNumTopics()
{    return numTopics;}
31483a48faafcce45c82e1a7f5875aceb59d137ecd31d4c0ab2045eb7653ec7b
viewRowSums
private static Vector viewRowSums(Matrix m)
{    Vector v = new DenseVector(m.numRows());    for (MatrixSlice slice : m) {        v.set(slice.index(), slice.vector().norm(1));    }    return v;}
8d047f8fec9dc9485f1b797eef3d8f27f5ee9478880d4ca181f7450c837fd487
initializeThreadPool
private synchronized void initializeThreadPool()
{    if (threadPool != null) {        threadPool.shutdown();        try {            threadPool.awaitTermination(100, TimeUnit.SECONDS);        } catch (InterruptedException e) {            log.error("Could not terminate all threads for TopicModel in time.", e);        }    }    threadPool = new ThreadPoolExecutor(numThreads, numThreads, 0, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(numThreads * 10));    threadPool.allowCoreThreadTimeOut(false);    updaters = new Updater[numThreads];    for (int i = 0; i < numThreads; i++) {        updaters[i] = new Updater();        threadPool.submit(updaters[i]);    }}
f6ef2fa077d5a93941114415a492e2f027101e2dbddb8573553e5ff86869aba2
topicTermCounts
 Matrix topicTermCounts()
{    return topicTermCounts;}
4e2991346111ce7b0ad21d3be20e5260c73af42a053d742339e6b45599b2c8dc
iterator
public Iterator<MatrixSlice> iterator()
{    return topicTermCounts.iterateAll();}
948ec5fa492ff53cb6c58eb76b802ac6ba2d8724394427fd790e2e96a2a956a4
topicSums
public Vector topicSums()
{    return topicSums;}
7d340a5a217fbe8efd4ca38265b175ddc8e71fefbc0284f1b1d1e22e5e408f0c
randomMatrix
private static Pair<Matrix, Vector> randomMatrix(int numTopics, int numTerms, Random random)
{    Matrix topicTermCounts = new DenseMatrix(numTopics, numTerms);    Vector topicSums = new DenseVector(numTopics);    if (random != null) {        for (int x = 0; x < numTopics; x++) {            for (int term = 0; term < numTerms; term++) {                topicTermCounts.viewRow(x).set(term, random.nextDouble());            }        }    }    for (int x = 0; x < numTopics; x++) {        topicSums.set(x, random == null ? 1.0 : topicTermCounts.viewRow(x).norm(1));    }    return Pair.of(topicTermCounts, topicSums);}
9cc0f1db344674183afa961b8a932f3025746e923b3f39fffcd05d89f848ab23
loadModel
public static Pair<Matrix, Vector> loadModel(Configuration conf, Path... modelPaths) throws IOException
{    int numTopics = -1;    int numTerms = -1;    List<Pair<Integer, Vector>> rows = new ArrayList<>();    for (Path modelPath : modelPaths) {        for (Pair<IntWritable, VectorWritable> row : new SequenceFileIterable<IntWritable, VectorWritable>(modelPath, true, conf)) {            rows.add(Pair.of(row.getFirst().get(), row.getSecond().get()));            numTopics = Math.max(numTopics, row.getFirst().get());            if (numTerms < 0) {                numTerms = row.getSecond().get().size();            }        }    }    if (rows.isEmpty()) {        throw new IOException(Arrays.toString(modelPaths) + " have no vectors in it");    }    numTopics++;    Matrix model = new DenseMatrix(numTopics, numTerms);    Vector topicSums = new DenseVector(numTopics);    for (Pair<Integer, Vector> pair : rows) {        model.viewRow(pair.getFirst()).assign(pair.getSecond());        topicSums.set(pair.getFirst(), pair.getSecond().norm(1));    }    return Pair.of(model, topicSums);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    StringBuilder buf = new StringBuilder();    for (int x = 0; x < numTopics; x++) {        String v = dictionary != null ? vectorToSortedString(topicTermCounts.viewRow(x).normalize(1), dictionary) : topicTermCounts.viewRow(x).asFormatString();        buf.append(v).append('\n');    }    return buf.toString();}
d4eada87793c21b9af3eed19c24c08e7a5ddcd72c1400f1d0f8c3b18853dcb7f
sampleTerm
public int sampleTerm(Vector topicDistribution)
{    return sampler.sample(topicTermCounts.viewRow(sampler.sample(topicDistribution)));}
65ca232b5418deb1980e929fa3fa7e80ca14c5a53b13595eb90f851b64bb92cb
sampleTerm
public int sampleTerm(int topic)
{    return sampler.sample(topicTermCounts.viewRow(topic));}
82d93c01a4aa8b564ec62dfb621083598a6a6b25ac4a6655d6e3db9476e48cd1
reset
public synchronized void reset()
{    for (int x = 0; x < numTopics; x++) {        topicTermCounts.assignRow(x, new SequentialAccessSparseVector(numTerms));    }    topicSums.assign(1.0);    if (threadPool.isTerminated()) {        initializeThreadPool();    }}
06e1ddba8663c90da407ac517f29ed70555cfe57b0332c9a96e7c696e0255364
stop
public synchronized void stop()
{    for (Updater updater : updaters) {        updater.shutdown();    }    threadPool.shutdown();    try {        if (!threadPool.awaitTermination(60, TimeUnit.SECONDS)) {            log.warn("Threadpool timed out on await termination - jobs still running!");        }    } catch (InterruptedException e) {        log.error("Interrupted shutting down!", e);    }}
86bf4abae695a444b0cdf07d16b4a1495e465389888ad6b24514306222f4ddf5
renormalize
public void renormalize()
{    for (int x = 0; x < numTopics; x++) {        topicTermCounts.assignRow(x, topicTermCounts.viewRow(x).normalize(1));        topicSums.assign(1.0);    }}
24cfb60de9f6b11fbf222be71b0019ea378dcecbb30963c570715c0a7922f33e
trainDocTopicModel
public void trainDocTopicModel(Vector original, Vector topics, Matrix docTopicModel)
{            pTopicGivenTerm(original, topics, docTopicModel);    normalizeByTopic(docTopicModel);        for (Element e : original.nonZeroes()) {        for (int x = 0; x < numTopics; x++) {            Vector docTopicModelRow = docTopicModel.viewRow(x);            docTopicModelRow.setQuick(e.index(), docTopicModelRow.getQuick(e.index()) * e.get());        }    }        topics.assign(0.0);    for (int x = 0; x < numTopics; x++) {        topics.set(x, docTopicModel.viewRow(x).norm(1));    }        topics.assign(Functions.mult(1 / topics.norm(1)));}
1865bf9ba5b0f54e720f688dd1b67fffac66f1e129d6fe14f3bc3a3cad6d8fd1
infer
public Vector infer(Vector original, Vector docTopics)
{    Vector pTerm = original.like();    for (Element e : original.nonZeroes()) {        int term = e.index();                double pA = 0;        for (int x = 0; x < numTopics; x++) {            pA += (topicTermCounts.viewRow(x).get(term) / topicSums.get(x)) * docTopics.get(x);        }        pTerm.set(term, pA);    }    return pTerm;}
ccc38769920c86209b0d9679113a5579fbfa0d97cb4e04014f9af4e60f7cbc59
update
public void update(Matrix docTopicCounts)
{    for (int x = 0; x < numTopics; x++) {        updaters[x % updaters.length].update(x, docTopicCounts.viewRow(x));    }}
ddef2ca025b3d95aa007fba51a504d57ed49c6f1015a6d968a5be12a12cfd6f1
updateTopic
public void updateTopic(int topic, Vector docTopicCounts)
{    topicTermCounts.viewRow(topic).assign(docTopicCounts, Functions.PLUS);    topicSums.set(topic, topicSums.get(topic) + docTopicCounts.norm(1));}
31e2df25f06077b2683828498e5305bce6274ccadf18c3dd9b2bc3424e02df07
update
public void update(int termId, Vector topicCounts)
{    for (int x = 0; x < numTopics; x++) {        Vector v = topicTermCounts.viewRow(x);        v.set(termId, v.get(termId) + topicCounts.get(x));    }    topicSums.assign(topicCounts, Functions.PLUS);}
ccbb0424b37d246d65788e5166f77a1a3aa5a2187a4fc6cac8c6f9e991b2a9cd
persist
public void persist(Path outputDir, boolean overwrite) throws IOException
{    FileSystem fs = outputDir.getFileSystem(conf);    if (overwrite) {                fs.delete(outputDir, true);    }    DistributedRowMatrixWriter.write(outputDir, conf, topicTermCounts);}
ea709f6ba67c0d1e57572fc94f5673fe3d05790ea6c5986b2c5f64dc14b7a897
pTopicGivenTerm
private void pTopicGivenTerm(Vector document, Vector docTopics, Matrix termTopicDist)
{        for (int x = 0; x < numTopics; x++) {                double topicWeight = docTopics == null ? 1.0 : docTopics.get(x);                Vector topicTermRow = topicTermCounts.viewRow(x);                double topicSum = topicSums.get(x);                Vector termTopicRow = termTopicDist.viewRow(x);                for (Element e : document.nonZeroes()) {            int termIndex = e.index();                        double termTopicLikelihood = (topicTermRow.get(termIndex) + eta) * (topicWeight + alpha) / (topicSum + eta * numTerms);            termTopicRow.set(termIndex, termTopicLikelihood);        }    }}
939a7773eabad3c698b2e9ea3bd345870e6e4ce62e3efdeaee130f2bf331cb89
perplexity
public double perplexity(Vector document, Vector docTopics)
{    double perplexity = 0;    double norm = docTopics.norm(1) + (docTopics.size() * alpha);    for (Element e : document.nonZeroes()) {        int term = e.index();        double prob = 0;        for (int x = 0; x < numTopics; x++) {            double d = (docTopics.get(x) + alpha) / norm;            double p = d * (topicTermCounts.viewRow(x).get(term) + eta) / (topicSums.get(x) + eta * numTerms);            prob += p;        }        perplexity += e.get() * Math.log(prob);    }    return -perplexity;}
61672c5d55b795053b8f30003ec91c81965d780a033418cac205d9e89fc3925f
normalizeByTopic
private void normalizeByTopic(Matrix perTopicSparseDistributions)
{        for (Element e : perTopicSparseDistributions.viewRow(0).nonZeroes()) {        int a = e.index();        double sum = 0;        for (int x = 0; x < numTopics; x++) {            sum += perTopicSparseDistributions.viewRow(x).get(a);        }        for (int x = 0; x < numTopics; x++) {            perTopicSparseDistributions.viewRow(x).set(a, perTopicSparseDistributions.viewRow(x).get(a) / sum);        }    }}
e2b3747b0b685a361f0734715511f76bb8afa1acc7d46b00ef75a2deba466c11
vectorToSortedString
public static String vectorToSortedString(Vector vector, String[] dictionary)
{    List<Pair<String, Double>> vectorValues = new ArrayList<>(vector.getNumNondefaultElements());    for (Element e : vector.nonZeroes()) {        vectorValues.add(Pair.of(dictionary != null ? dictionary[e.index()] : String.valueOf(e.index()), e.get()));    }    Collections.sort(vectorValues, new Comparator<Pair<String, Double>>() {        @Override        public int compare(Pair<String, Double> x, Pair<String, Double> y) {            return y.getSecond().compareTo(x.getSecond());        }    });    Iterator<Pair<String, Double>> listIt = vectorValues.iterator();    StringBuilder bldr = new StringBuilder(2048);    bldr.append('{');    int i = 0;    while (listIt.hasNext() && i < 25) {        i++;        Pair<String, Double> p = listIt.next();        bldr.append(p.getFirst());        bldr.append(':');        bldr.append(p.getSecond());        bldr.append(',');    }    if (bldr.length() > 1) {        bldr.setCharAt(bldr.length() - 1, '}');    }    return bldr.toString();}
af5339d4478728bbb2ad39403ef3e91e6cc3021d39626e7abcbb646cc2fd5141
compare
public int compare(Pair<String, Double> x, Pair<String, Double> y)
{    return y.getSecond().compareTo(x.getSecond());}
9c9813ec5150aa99c66b8c22257a531dd5cb8d663ffd85cbd6891bf6890819a8
setConf
public void setConf(Configuration configuration)
{    this.conf = configuration;}
d221713f567be6c3a854157b6beb8a5fd5dd64b69c1ef157fb4bac811a41c3f7
getConf
public Configuration getConf()
{    return conf;}
df491dc8b9ff7b029a14c1088c98b538ae923511d668b67ae742be7c636ab813
shutdown
public void shutdown()
{    try {        synchronized (this) {            while (!shutdownComplete) {                shutdown = true;                                wait(10000L);            }        }    } catch (InterruptedException e) {        log.warn("Interrupted waiting to shutdown() : ", e);    }}
7354762799129791899b9385a7a8917775d18777907b60292aa332819520a6d6
update
public boolean update(int topic, Vector v)
{    if (shutdown) {                throw new IllegalStateException("In SHUTDOWN state: cannot submit tasks");    }    while (true) {                try {                        queue.put(Pair.of(topic, v));                        return true;        } catch (InterruptedException e) {            log.warn("Interrupted trying to queue update:", e);        }    }}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    while (!shutdown) {        try {            Pair<Integer, Vector> pair = queue.poll(1, TimeUnit.SECONDS);            if (pair != null) {                updateTopic(pair.getFirst(), pair.getSecond());            }        } catch (InterruptedException e) {            log.warn("Interrupted waiting to poll for update", e);        }    }        for (Pair<Integer, Vector> pair : queue) {        updateTopic(pair.getFirst(), pair.getSecond());    }    synchronized (this) {        shutdownComplete = true;        notifyAll();    }}
adcf004c50bf2ad0f14651e4ca561d86091d314e01a9d6c70395b18551aeb5e3
getN
public double getN()
{    return sumWeight;}
c991e0c9978ab7829b1afdf3ec96873bc3ce193beb89a7d73742ec9924528cdc
getMean
public Vector getMean()
{    return mean;}
3e24cf5e8d4a11bdebf0aa79ecd1e35870ce9796e6ea9c45b256e2c1861d1ed5
getStd
public Vector getStd()
{    return variance.clone().assign(new SquareRootFunction());}
92fa48f8580859ec3c47cde408ed98f31dea064305b41eb8ec2afb21be927a03
observe
public void observe(Vector x, double weight)
{    double temp = weight + sumWeight;    Vector q;    if (mean == null) {        mean = x.like();        q = x.clone();    } else {        q = x.minus(mean);    }    Vector r = q.times(weight).divide(temp);    if (s == null) {        s = q.times(sumWeight).times(r);    } else {        s = s.plus(q.times(sumWeight).times(r));    }    mean = mean.plus(r);    sumWeight = temp;        variance = s.divide(sumWeight - 1);}
2db62fba68472dc535d97f6b8e2f469c8d21ebd47b03f353394baf504ffec7c0
compute
public void compute()
{}
a7e8a55cbfcd1cf09d54fa03d1d94e7deddc364e6177fd80b3b5590068f3456f
getAverageStd
public double getAverageStd()
{    if (sumWeight == 0.0) {        return 0.0;    } else {        Vector std = getStd();        return std.zSum() / std.size();    }}
f122a4b9f5301d8acad15695d1ee97320f0f8fde69e9eddcbf4984e9bbcd4d7e
getVariance
public Vector getVariance()
{    return variance;}
adcf004c50bf2ad0f14651e4ca561d86091d314e01a9d6c70395b18551aeb5e3
getN
public double getN()
{    return s0;}
c991e0c9978ab7829b1afdf3ec96873bc3ce193beb89a7d73742ec9924528cdc
getMean
public Vector getMean()
{    return mean;}
3e24cf5e8d4a11bdebf0aa79ecd1e35870ce9796e6ea9c45b256e2c1861d1ed5
getStd
public Vector getStd()
{    return std;}
a7e8a55cbfcd1cf09d54fa03d1d94e7deddc364e6177fd80b3b5590068f3456f
getAverageStd
public double getAverageStd()
{    if (s0 == 0.0) {        return 0.0;    } else {        return std.zSum() / std.size();    }}
f122a4b9f5301d8acad15695d1ee97320f0f8fde69e9eddcbf4984e9bbcd4d7e
getVariance
public Vector getVariance()
{    return std.times(std);}
92fa48f8580859ec3c47cde408ed98f31dea064305b41eb8ec2afb21be927a03
observe
public void observe(Vector x, double weight)
{    s0 += weight;    Vector weightedX = x.times(weight);    if (s1 == null) {        s1 = weightedX;    } else {        s1.assign(weightedX, Functions.PLUS);    }    Vector x2 = x.times(x).times(weight);    if (s2 == null) {        s2 = x2;    } else {        s2.assign(x2, Functions.PLUS);    }}
2db62fba68472dc535d97f6b8e2f469c8d21ebd47b03f353394baf504ffec7c0
compute
public void compute()
{    if (s0 != 0.0) {        mean = s1.divide(s0);        std = s2.times(s0).minus(s1.times(s1)).assign(new SquareRootFunction()).divide(s0);    }}
d86e952561aa9b5eff484699a5ec85fb4e0e009173f9cd085c5796a8ab6bfe19
runJob
public static void runJob(Path input, Path output, int rows, int cols) throws IOException, InterruptedException, ClassNotFoundException
{    Configuration conf = new Configuration();    HadoopUtil.delete(conf, output);    conf.setInt(Keys.AFFINITY_DIMENSIONS, rows);    Job job = new Job(conf, "AffinityMatrixInputJob: " + input + " -> M/R -> " + output);    job.setMapOutputKeyClass(IntWritable.class);    job.setMapOutputValueClass(DistributedRowMatrix.MatrixEntryWritable.class);    job.setOutputKeyClass(IntWritable.class);    job.setOutputValueClass(VectorWritable.class);    job.setOutputFormatClass(SequenceFileOutputFormat.class);    job.setMapperClass(AffinityMatrixInputMapper.class);    job.setReducerClass(AffinityMatrixInputReducer.class);    FileInputFormat.addInputPath(job, input);    FileOutputFormat.setOutputPath(job, output);    job.setJarByClass(AffinityMatrixInputJob.class);    boolean succeeded = job.waitForCompletion(true);    if (!succeeded) {        throw new IllegalStateException("Job failed!");    }}
5ab3ab0b803e0cdb4bf55a501b784d3a96173bbcea3fa7dff7ce9f7c9ed7b065
runJob
public static DistributedRowMatrix runJob(Path input, Path output, int dimensions) throws IOException, InterruptedException, ClassNotFoundException
{    Path seqFiles = new Path(output, "seqfiles-" + (System.nanoTime() & 0xFF));    runJob(input, seqFiles, dimensions, dimensions);    DistributedRowMatrix a = new DistributedRowMatrix(seqFiles, new Path(seqFiles, "seqtmp-" + (System.nanoTime() & 0xFF)), dimensions, dimensions);    a.setConf(new Configuration());    return a;}
364372c8c0a17a2c3987e3f0d31a4140befe124df0e3310d5d0fe71e39f33b0f
map
protected void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException
{    String[] elements = COMMA_PATTERN.split(value.toString());    log.debug("(DEBUG - MAP) Key[{}], Value[{}]", key.get(), value);        if (elements.length != 3) {        throw new IOException("Expected input of length 3, received " + elements.length + ". Please make sure you adhere to " + "the structure of (i,j,value) for representing a graph in text. " + "Input line was: '" + value + "'.");    }    if (elements[0].isEmpty() || elements[1].isEmpty() || elements[2].isEmpty()) {        throw new IOException("Found an element of 0 length. Please be sure you adhere to the structure of " + "(i,j,value) for  representing a graph in text.");    }                DistributedRowMatrix.MatrixEntryWritable toAdd = new DistributedRowMatrix.MatrixEntryWritable();    IntWritable row = new IntWritable(Integer.valueOf(elements[0]));        toAdd.setRow(-1);    toAdd.setCol(Integer.valueOf(elements[1]));    toAdd.setVal(Double.valueOf(elements[2]));    context.write(row, toAdd);}
78078371950fcc95e2208b26cc142f1c2b605c8ced5ed5e533afd7acd4f53e35
reduce
protected void reduce(IntWritable row, Iterable<DistributedRowMatrix.MatrixEntryWritable> values, Context context) throws IOException, InterruptedException
{    int size = context.getConfiguration().getInt(Keys.AFFINITY_DIMENSIONS, Integer.MAX_VALUE);    RandomAccessSparseVector out = new RandomAccessSparseVector(size, 100);    for (DistributedRowMatrix.MatrixEntryWritable element : values) {        out.setQuick(element.getCol(), element.getVal());        if (log.isDebugEnabled()) {            log.debug("(DEBUG - REDUCE) Row[{}], Column[{}], Value[{}]", row.get(), element.getCol(), element.getVal());        }    }    SequentialAccessSparseVector output = new SequentialAccessSparseVector(out);    context.write(row, new VectorWritable(output));}
2249fa0d20a076f3f710aeac071b3351d145a8cd53b0b2618380e4d994350d85
setKey
public void setKey(int k)
{    this.key = k;}
0c4ca37504282910080f62f5785d0f28a8c912117324f8aab9936861b6efc111
setValue
public void setValue(double v)
{    this.value = v;}
5478cc5683f6dfd4515c383752d7c803555efc63d03fd84a03ba8dcd17eb4324
readFields
public void readFields(DataInput in) throws IOException
{    this.key = in.readInt();    this.value = in.readDouble();}
a894510dd4db439ff8e17ae1059489dc3abc97178e5932ceed0c70c3af165401
write
public void write(DataOutput out) throws IOException
{    out.writeInt(key);    out.writeDouble(value);}
501c6794ceaffd49ff6c4290052f18502462ad908608400cf6ab91c01d005be4
getKey
public int getKey()
{    return key;}
baa2719ad2de5db523d278575928af9560575a9fbdd5a41694812df8ea43af94
getValue
public double getValue()
{    return value;}
1e0f86511c1850c8b6410aa54bc065cbd21b7b92b368375c8e15f94e709ec5ca
buildFromEigens
public static Path buildFromEigens(Configuration conf, Path input, Path output, int k, DistanceMeasure measure) throws IOException
{        FileSystem fs = FileSystem.get(output.toUri(), conf);    HadoopUtil.delete(conf, output);    Path outFile = new Path(output, "part-eigenSeed");    boolean newFile = fs.createNewFile(outFile);    if (newFile) {        Path inputPathPattern;        if (fs.getFileStatus(input).isDir()) {            inputPathPattern = new Path(input, "*");        } else {            inputPathPattern = input;        }        FileStatus[] inputFiles = fs.globStatus(inputPathPattern, PathFilters.logsCRCFilter());                Map<Integer, Double> maxEigens = new HashMap<>(k);                                                Map<Integer, Text> chosenTexts = new HashMap<>(k);        Map<Integer, ClusterWritable> chosenClusters = new HashMap<>(k);        for (FileStatus fileStatus : inputFiles) {            if (!fileStatus.isDir()) {                for (Pair<Writable, VectorWritable> record : new SequenceFileIterable<Writable, VectorWritable>(fileStatus.getPath(), true, conf)) {                    Writable key = record.getFirst();                    VectorWritable value = record.getSecond();                    for (Vector.Element e : value.get().nonZeroes()) {                        int index = e.index();                        double v = Math.abs(e.get());                        if (!maxEigens.containsKey(index) || v > maxEigens.get(index)) {                            maxEigens.put(index, v);                            Text newText = new Text(key.toString());                            chosenTexts.put(index, newText);                            Kluster newCluster = new Kluster(value.get(), index, measure);                            newCluster.observe(value.get(), 1);                            ClusterWritable clusterWritable = new ClusterWritable();                            clusterWritable.setValue(newCluster);                            chosenClusters.put(index, clusterWritable);                        }                    }                }            }        }        try (SequenceFile.Writer writer = SequenceFile.createWriter(fs, conf, outFile, Text.class, ClusterWritable.class)) {            for (Integer key : maxEigens.keySet()) {                writer.append(chosenTexts.get(key), chosenClusters.get(key));            }            log.info("EigenSeedGenerator:: Wrote {} Klusters to {}", chosenTexts.size(), outFile);        }    }    return outFile;}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    ToolRunner.run(new SpectralKMeansDriver(), args);}
2b6b99a7215ca59129895651046fd267809d6eed610a34e199e44f639e88e52d
run
public int run(String[] arg0) throws Exception
{    Configuration conf = getConf();    addInputOption();    addOutputOption();    addOption("dimensions", "d", "Square dimensions of affinity matrix", true);    addOption("clusters", "k", "Number of clusters and top eigenvectors", true);    addOption(DefaultOptionCreator.distanceMeasureOption().create());    addOption(DefaultOptionCreator.convergenceOption().create());    addOption(DefaultOptionCreator.maxIterationsOption().create());    addOption(DefaultOptionCreator.overwriteOption().create());    addFlag("usessvd", "ssvd", "Uses SSVD as the eigensolver. Default is the Lanczos solver.");    addOption("reduceTasks", "t", "Number of reducers for SSVD", String.valueOf(REDUCERS));    addOption("outerProdBlockHeight", "oh", "Block height of outer products for SSVD", String.valueOf(BLOCKHEIGHT));    addOption("oversampling", "p", "Oversampling parameter for SSVD", String.valueOf(OVERSAMPLING));    addOption("powerIter", "q", "Additional power iterations for SSVD", String.valueOf(POWERITERS));    Map<String, List<String>> parsedArgs = parseArguments(arg0);    if (parsedArgs == null) {        return 0;    }    Path input = getInputPath();    Path output = getOutputPath();    if (hasOption(DefaultOptionCreator.OVERWRITE_OPTION)) {        HadoopUtil.delete(conf, getTempPath());        HadoopUtil.delete(conf, getOutputPath());    }    int numDims = Integer.parseInt(getOption("dimensions"));    int clusters = Integer.parseInt(getOption("clusters"));    String measureClass = getOption(DefaultOptionCreator.DISTANCE_MEASURE_OPTION);    DistanceMeasure measure = ClassUtils.instantiateAs(measureClass, DistanceMeasure.class);    double convergenceDelta = Double.parseDouble(getOption(DefaultOptionCreator.CONVERGENCE_DELTA_OPTION));    int maxIterations = Integer.parseInt(getOption(DefaultOptionCreator.MAX_ITERATIONS_OPTION));    Path tempdir = new Path(getOption("tempDir"));    int reducers = Integer.parseInt(getOption("reduceTasks"));    int blockheight = Integer.parseInt(getOption("outerProdBlockHeight"));    int oversampling = Integer.parseInt(getOption("oversampling"));    int poweriters = Integer.parseInt(getOption("powerIter"));    run(conf, input, output, numDims, clusters, measure, convergenceDelta, maxIterations, tempdir, reducers, blockheight, oversampling, poweriters);    return 0;}
b85195d93369930b86e90db7210af500cd2999cbad8382484bb74bf1566a8f5d
run
public static void run(Configuration conf, Path input, Path output, int numDims, int clusters, DistanceMeasure measure, double convergenceDelta, int maxIterations, Path tempDir) throws IOException, InterruptedException, ClassNotFoundException
{    run(conf, input, output, numDims, clusters, measure, convergenceDelta, maxIterations, tempDir, REDUCERS, BLOCKHEIGHT, OVERSAMPLING, POWERITERS);}
6cda8c8963be3606fff2c2844ab88282cbe36716c0ae908926dd8645a3b8e484
run
public static void run(Configuration conf, Path input, Path output, int numDims, int clusters, DistanceMeasure measure, double convergenceDelta, int maxIterations, Path tempDir, int numReducers, int blockHeight, int oversampling, int poweriters) throws IOException, InterruptedException, ClassNotFoundException
{    HadoopUtil.delete(conf, tempDir);    Path outputCalc = new Path(tempDir, "calculations");    Path outputTmp = new Path(tempDir, "temporary");                Path affSeqFiles = new Path(outputCalc, "seqfile");    AffinityMatrixInputJob.runJob(input, affSeqFiles, numDims, numDims);        DistributedRowMatrix A = new DistributedRowMatrix(affSeqFiles, new Path(outputTmp, "afftmp"), numDims, numDims);    Configuration depConf = new Configuration(conf);    A.setConf(depConf);        Vector D = MatrixDiagonalizeJob.runJob(affSeqFiles, numDims);        DistributedRowMatrix L = VectorMatrixMultiplicationJob.runJob(affSeqFiles, D, new Path(outputCalc, "laplacian"), new Path(outputCalc, outputCalc));    L.setConf(depConf);    Path data;        Path[] LPath = new Path[1];    LPath[0] = L.getRowPath();    Path SSVDout = new Path(outputCalc, "SSVD");    SSVDSolver solveIt = new SSVDSolver(depConf, LPath, SSVDout, blockHeight, clusters, oversampling, numReducers);    solveIt.setComputeV(false);    solveIt.setComputeU(true);    solveIt.setOverwrite(true);    solveIt.setQ(poweriters);        solveIt.run();    data = new Path(solveIt.getUPath());            Path unitVectors = new Path(outputCalc, "unitvectors");    UnitVectorizerJob.runJob(data, unitVectors);    DistributedRowMatrix Wt = new DistributedRowMatrix(unitVectors, new Path(unitVectors, "tmp"), clusters, numDims);    Wt.setConf(depConf);    data = Wt.getRowPath();            Path initialclusters = EigenSeedGenerator.buildFromEigens(conf, data, new Path(output, Cluster.INITIAL_CLUSTERS_DIR), clusters, measure);        Path answer = new Path(output, "kmeans_out");    KMeansDriver.run(conf, data, initialclusters, answer, convergenceDelta, maxIterations, true, 0.0, false);        Path mappingPath = new Path(new Path(conf.get("hadoop.tmp.dir")), "generic_input_mapping");    List<String> mapping = new ArrayList<>();    FileSystem fs = FileSystem.get(mappingPath.toUri(), conf);    if (fs.exists(mappingPath)) {        SequenceFile.Reader reader = new SequenceFile.Reader(fs, mappingPath, conf);        Text mappingValue = new Text();        IntWritable mappingIndex = new IntWritable();        while (reader.next(mappingIndex, mappingValue)) {            String s = mappingValue.toString();            mapping.add(s);        }        HadoopUtil.delete(conf, mappingPath);    } else {        log.warn("generic input mapping file not found!");    }    Path clusteredPointsPath = new Path(answer, "clusteredPoints");    Path inputPath = new Path(clusteredPointsPath, "part-m-00000");    int id = 0;    for (Pair<IntWritable, WeightedVectorWritable> record : new SequenceFileIterable<IntWritable, WeightedVectorWritable>(inputPath, conf)) {        if (!mapping.isEmpty()) {            log.info("{}: {}", mapping.get(id++), record.getFirst().get());        } else {            log.info("{}: {}", id++, record.getFirst().get());        }    }}
3507bd58b94da35d307b1afb4919e09efe023e9a9a323604a4008a7fb3362891
runJob
public static Vector runJob(Path affInput, int dimensions) throws IOException, ClassNotFoundException, InterruptedException
{        Configuration conf = new Configuration();    Path diagOutput = new Path(affInput.getParent(), "diagonal");    HadoopUtil.delete(conf, diagOutput);    conf.setInt(Keys.AFFINITY_DIMENSIONS, dimensions);    Job job = new Job(conf, "MatrixDiagonalizeJob");    job.setInputFormatClass(SequenceFileInputFormat.class);    job.setMapOutputKeyClass(NullWritable.class);    job.setMapOutputValueClass(IntDoublePairWritable.class);    job.setOutputKeyClass(NullWritable.class);    job.setOutputValueClass(VectorWritable.class);    job.setOutputFormatClass(SequenceFileOutputFormat.class);    job.setMapperClass(MatrixDiagonalizeMapper.class);    job.setReducerClass(MatrixDiagonalizeReducer.class);    FileInputFormat.addInputPath(job, affInput);    FileOutputFormat.setOutputPath(job, diagOutput);    job.setJarByClass(MatrixDiagonalizeJob.class);    boolean succeeded = job.waitForCompletion(true);    if (!succeeded) {        throw new IllegalStateException("Job failed!");    }        return VectorCache.load(conf, new Path(diagOutput, "part-r-00000"));}
0cb6ca9d05a8380d8743bc273d9f03d33d78090b21f4dcb7e15dc10fae32ae3a
map
protected void map(IntWritable key, VectorWritable row, Context context) throws IOException, InterruptedException
{        IntDoublePairWritable store = new IntDoublePairWritable(key.get(), row.get().zSum());    context.write(NullWritable.get(), store);}
b18e025a71eb57b52a6167302c4f228323f3772477587caf92e3a39bb7d92f56
reduce
protected void reduce(NullWritable key, Iterable<IntDoublePairWritable> values, Context context) throws IOException, InterruptedException
{        Vector retval = new DenseVector(context.getConfiguration().getInt(Keys.AFFINITY_DIMENSIONS, Integer.MAX_VALUE));        for (IntDoublePairWritable e : values) {        retval.setQuick(e.getKey(), e.getValue());    }        context.write(key, new VectorWritable(retval));}
4f41c4072d4d78d7b886d9ee135e546965c167850be33f38bff46426aea93107
runJob
public static void runJob(Path input, Path output) throws IOException, InterruptedException, ClassNotFoundException
{    Configuration conf = new Configuration();    Job job = new Job(conf, "UnitVectorizerJob");    job.setInputFormatClass(SequenceFileInputFormat.class);    job.setOutputKeyClass(IntWritable.class);    job.setOutputValueClass(VectorWritable.class);    job.setOutputFormatClass(SequenceFileOutputFormat.class);    job.setMapperClass(UnitVectorizerMapper.class);    job.setNumReduceTasks(0);    FileInputFormat.addInputPath(job, input);    FileOutputFormat.setOutputPath(job, output);    job.setJarByClass(UnitVectorizerJob.class);    boolean succeeded = job.waitForCompletion(true);    if (!succeeded) {        throw new IllegalStateException("Job failed!");    }}
a09889ecd0cce0fc390ffedb126017a918536590057434ffeff683aee0a3d93c
map
protected void map(IntWritable row, VectorWritable vector, Context context) throws IOException, InterruptedException
{    context.write(row, new VectorWritable(vector.get().normalize(2)));}
933fda400bfe1e912f967abf92857815ace2670edf843a6ec0087616b7e591e0
save
public static void save(Writable key, Vector vector, Path output, Configuration conf, boolean overwritePath, boolean deleteOnExit) throws IOException
{    FileSystem fs = FileSystem.get(output.toUri(), conf);    output = fs.makeQualified(output);    if (overwritePath) {        HadoopUtil.delete(conf, output);    }        DistributedCache.setCacheFiles(new URI[] { output.toUri() }, conf);        try (SequenceFile.Writer writer = new SequenceFile.Writer(fs, conf, output, IntWritable.class, VectorWritable.class)) {        writer.append(key, new VectorWritable(vector));    }    if (deleteOnExit) {        fs.deleteOnExit(output);    }}
cadf852a508b566764ddc471af9a1f740d1eca6b992fe2d5a809762f77be4fec
save
public static void save(Writable key, Vector vector, Path output, Configuration conf) throws IOException
{    save(key, vector, output, conf, true, true);}
3e2a7ee2fe12c6307321d0a01cfcf8efdc4f0e366ba49f1937ae761a3b7fd5fd
load
public static Vector load(Configuration conf) throws IOException
{    Path[] files = HadoopUtil.getCachedFiles(conf);    if (files.length != 1) {        throw new IOException("Cannot read Frequency list from Distributed Cache (" + files.length + ')');    }    if (log.isInfoEnabled()) {        log.info("Files are: {}", Arrays.toString(files));    }    return load(conf, files[0]);}
f80d237dc2e15b5ff589d536610d5e45f7f4342be0f4c4f98a26285a8117dd29
load
public static Vector load(Configuration conf, Path input) throws IOException
{    log.info("Loading vector from: {}", input);    try (SequenceFileValueIterator<VectorWritable> iterator = new SequenceFileValueIterator<>(input, true, conf)) {        return iterator.next().get();    }}
83658f7481b58bf1c60bcecf5b5d4ec122cf5f59ba857d93045d236b7384ec66
runJob
public static DistributedRowMatrix runJob(Path markovPath, Vector diag, Path outputPath) throws IOException, ClassNotFoundException, InterruptedException
{    return runJob(markovPath, diag, outputPath, new Path(outputPath, "tmp"));}
bf23364471bc4a2f5fd91fe675de1eb132cf5db7bd9411741cedef2ae27542f6
runJob
public static DistributedRowMatrix runJob(Path markovPath, Vector diag, Path outputPath, Path tmpPath) throws IOException, ClassNotFoundException, InterruptedException
{        Configuration conf = new Configuration();    FileSystem fs = FileSystem.get(markovPath.toUri(), conf);    markovPath = fs.makeQualified(markovPath);    outputPath = fs.makeQualified(outputPath);    Path vectorOutputPath = new Path(outputPath.getParent(), "vector");    VectorCache.save(new IntWritable(Keys.DIAGONAL_CACHE_INDEX), diag, vectorOutputPath, conf);        Job job = new Job(conf, "VectorMatrixMultiplication");    job.setInputFormatClass(SequenceFileInputFormat.class);    job.setOutputKeyClass(IntWritable.class);    job.setOutputValueClass(VectorWritable.class);    job.setOutputFormatClass(SequenceFileOutputFormat.class);    job.setMapperClass(VectorMatrixMultiplicationMapper.class);    job.setNumReduceTasks(0);    FileInputFormat.addInputPath(job, markovPath);    FileOutputFormat.setOutputPath(job, outputPath);    job.setJarByClass(VectorMatrixMultiplicationJob.class);    boolean succeeded = job.waitForCompletion(true);    if (!succeeded) {        throw new IllegalStateException("Job failed!");    }        return new DistributedRowMatrix(outputPath, tmpPath, diag.size(), diag.size());}
6b7dd49be7482fc8ee0fbe8bd0f24522f2a718c8c816a3d7b048fb4688eb6373
setup
protected void setup(Context context) throws IOException, InterruptedException
{        super.setup(context);    Configuration config = context.getConfiguration();    diagonal = VectorCache.load(config);    if (diagonal == null) {        throw new IOException("No vector loaded from cache!");    }    if (!(diagonal instanceof DenseVector)) {        diagonal = new DenseVector(diagonal);    }}
b4d4b52fb13130385c4f76507b8b9198c95e7dab6f54377516fe79ff69298602
map
protected void map(IntWritable key, VectorWritable row, Context ctx) throws IOException, InterruptedException
{    for (Vector.Element e : row.get().all()) {        double dii = Functions.SQRT.apply(diagonal.get(key.get()));        double djj = Functions.SQRT.apply(diagonal.get(e.index()));        double mij = e.get();        e.set(dii * mij * djj);    }    ctx.write(key, row);}
ac2243e00e5d68e620de1e9c1b4261a262d3740c45cb4160b0a8c707062327a3
setup
 void setup(Vector diag)
{    this.diagonal = diag;}
d4eb3a86032c35b455a6e0ae131661d4d4dc525d2112aadf5a7761a33ea8e48e
getRow
public int getRow()
{    return i;}
367a28dc0f2563f857828258fb23b24c7a05f1aee470b862f378e382088ad168
setRow
public void setRow(int i)
{    this.i = i;}
6809fdfedea078db73c775e200cb13b2a7955503a118d27e39f4701b96e49c33
getCol
public int getCol()
{    return j;}
fa271e70b6afc263b96f2c62891180db91c5bc71d575d1ec27a13c267b37cc19
setCol
public void setCol(int j)
{    this.j = j;}
baa2719ad2de5db523d278575928af9560575a9fbdd5a41694812df8ea43af94
getValue
public double getValue()
{    return value;}
0c4ca37504282910080f62f5785d0f28a8c912117324f8aab9936861b6efc111
setValue
public void setValue(double v)
{    this.value = v;}
624f725337dde847c4a699397a02f1b5558c709c88374adb10e603d835f48c88
getType
public String getType()
{    return type;}
cd1a14ccbd86ff77624f766e3a15a05bf82a35dd5c787e84d9975a717daae3c4
setType
public void setType(String t)
{    this.type = t;}
1a413c4de67fd63171d0d49b950e39fd83f4da1c19a64c7b1821f5ad09f0bf40
readFields
public void readFields(DataInput arg0) throws IOException
{    this.i = arg0.readInt();    this.j = arg0.readInt();    this.value = arg0.readDouble();    this.type = arg0.readUTF();}
d5d1cfcfa87385432cd71bb2a89c71be2b897b4a9aa4297d2df773a42ba0a3da
write
public void write(DataOutput arg0) throws IOException
{    arg0.writeInt(i);    arg0.writeInt(j);    arg0.writeDouble(value);    arg0.writeUTF(type);}
d1e9116eb8277eb5a9b0dc816d6c77732f51f18d369a82c22814abd1ed0d5690
splitTrainTest
public Pair<List<? extends WeightedVector>, List<? extends WeightedVector>> splitTrainTest(List<? extends WeightedVector> datapoints)
{        if (testProbability == 0) {        return new Pair<List<? extends WeightedVector>, List<? extends WeightedVector>>(datapoints, new ArrayList<WeightedVector>());    }    int numTest = (int) (testProbability * datapoints.size());    Preconditions.checkArgument(numTest > 0 && numTest < datapoints.size(), "Must have nonzero number of training and test vectors. Asked for %.1f %% of %d vectors for test", testProbability * 100, datapoints.size());    Collections.shuffle(datapoints);    return new Pair<List<? extends WeightedVector>, List<? extends WeightedVector>>(datapoints.subList(numTest, datapoints.size()), datapoints.subList(0, numTest));}
1626abf0525fb83da327cd1b5a2b58ef699c8d387505750a50765afbd9b9c37f
cluster
public UpdatableSearcher cluster(List<? extends WeightedVector> datapoints)
{    Pair<List<? extends WeightedVector>, List<? extends WeightedVector>> trainTestSplit = splitTrainTest(datapoints);    List<Vector> bestCentroids = new ArrayList<>();    double cost = Double.POSITIVE_INFINITY;    double bestCost = Double.POSITIVE_INFINITY;    for (int i = 0; i < numRuns; ++i) {        centroids.clear();        if (kMeansPlusPlusInit) {                        initializeSeedsKMeansPlusPlus(trainTestSplit.getFirst());        } else {                        initializeSeedsRandomly(trainTestSplit.getFirst());        }                if (numRuns > 1) {                        iterativeAssignment(trainTestSplit.getFirst());                        cost = ClusteringUtils.totalClusterCost(splitTrainTest ? datapoints : trainTestSplit.getSecond(), centroids);            if (cost < bestCost) {                bestCost = cost;                bestCentroids.clear();                Iterables.addAll(bestCentroids, centroids);            }        } else {                        iterativeAssignment(datapoints);            return centroids;        }    }    if (bestCost == Double.POSITIVE_INFINITY) {        throw new RuntimeException("No valid clustering was found");    }    if (cost != bestCost) {        centroids.clear();        centroids.addAll(bestCentroids);    }    if (correctWeights) {        for (WeightedVector testDatapoint : trainTestSplit.getSecond()) {            WeightedVector closest = (WeightedVector) centroids.searchFirst(testDatapoint, false).getValue();            closest.setWeight(closest.getWeight() + testDatapoint.getWeight());        }    }    return centroids;}
f296ddd89b6bddde2ea5511771a8cf940371e2e3078be1eb556406dee97cc3d3
initializeSeedsRandomly
private void initializeSeedsRandomly(List<? extends WeightedVector> datapoints)
{    int numDatapoints = datapoints.size();    double totalWeight = 0;    for (WeightedVector datapoint : datapoints) {        totalWeight += datapoint.getWeight();    }    Multinomial<Integer> seedSelector = new Multinomial<>();    for (int i = 0; i < numDatapoints; ++i) {        seedSelector.add(i, datapoints.get(i).getWeight() / totalWeight);    }    for (int i = 0; i < numClusters; ++i) {        int sample = seedSelector.sample();        seedSelector.delete(sample);        Centroid centroid = new Centroid(datapoints.get(sample));        centroid.setIndex(i);        centroids.add(centroid);    }}
a6a10b279acf1148f279ea364f6473d963d4c07ced04379fb6d1f135548530c5
initializeSeedsKMeansPlusPlus
private void initializeSeedsKMeansPlusPlus(List<? extends WeightedVector> datapoints)
{    Preconditions.checkArgument(datapoints.size() > 1, "Must have at least two datapoints points to cluster " + "sensibly");    Preconditions.checkArgument(datapoints.size() >= numClusters, String.format("Must have more datapoints [%d] than clusters [%d]", datapoints.size(), numClusters));        Centroid center = new Centroid(datapoints.iterator().next());    for (WeightedVector row : Iterables.skip(datapoints, 1)) {        center.update(row);    }            double deltaX = 0;    DistanceMeasure distanceMeasure = centroids.getDistanceMeasure();    for (WeightedVector row : datapoints) {        deltaX += distanceMeasure.distance(row, center);    }                                                                    Multinomial<Integer> seedSelector = new Multinomial<>();    for (int i = 0; i < datapoints.size(); ++i) {        double selectionProbability = deltaX + datapoints.size() * distanceMeasure.distance(datapoints.get(i), center);        seedSelector.add(i, selectionProbability);    }    int selected = random.nextInt(datapoints.size());    Centroid c_1 = new Centroid(datapoints.get(selected).clone());    c_1.setIndex(0);        for (int i = 0; i < datapoints.size(); ++i) {        WeightedVector row = datapoints.get(i);        double w = distanceMeasure.distance(c_1, row) * 2 * Math.log(1 + row.getWeight());        seedSelector.set(i, w);    }                            centroids.add(c_1);    int clusterIndex = 1;    while (centroids.size() < numClusters) {                int seedIndex = seedSelector.sample();        Centroid nextSeed = new Centroid(datapoints.get(seedIndex));        nextSeed.setIndex(clusterIndex++);        centroids.add(nextSeed);                seedSelector.delete(seedIndex);                for (int currSeedIndex : seedSelector) {            WeightedVector curr = datapoints.get(currSeedIndex);            double newWeight = nextSeed.getWeight() * distanceMeasure.distance(nextSeed, curr);            if (newWeight < seedSelector.getWeight(currSeedIndex)) {                seedSelector.set(currSeedIndex, newWeight);            }        }    }}
94258962b6d49fb57d1e714014ad74f1b7a7b6b7a3d05d3fbb00f7d852a109cd
iterativeAssignment
private void iterativeAssignment(List<? extends WeightedVector> datapoints)
{    DistanceMeasure distanceMeasure = centroids.getDistanceMeasure();            List<Double> closestClusterDistances = new ArrayList<>(numClusters);                List<Integer> clusterAssignments = new ArrayList<>(Collections.nCopies(datapoints.size(), -1));    boolean changed = true;    for (int i = 0; changed && i < maxNumIterations; i++) {        changed = false;                                closestClusterDistances.clear();        for (Vector center : centroids) {                        Vector closestOtherCluster = centroids.searchFirst(center, true).getValue();            closestClusterDistances.add(distanceMeasure.distance(center, closestOtherCluster));        }                        List<Centroid> newCentroids = new ArrayList<>();        for (Vector centroid : centroids) {                        Centroid newCentroid = (Centroid) centroid.clone();            newCentroid.setWeight(0);            newCentroids.add(newCentroid);        }                for (int j = 0; j < datapoints.size(); ++j) {            WeightedVector datapoint = datapoints.get(j);                        WeightedThing<Vector> closestPair = centroids.searchFirst(datapoint, false);            int closestIndex = ((WeightedVector) closestPair.getValue()).getIndex();            double closestDistance = closestPair.getWeight();                        if (closestIndex != clusterAssignments.get(j)) {                changed = true;                clusterAssignments.set(j, closestIndex);            }                        if (closestDistance < trimFraction * closestClusterDistances.get(closestIndex)) {                newCentroids.get(closestIndex).update(datapoint);            }        }                centroids.clear();        centroids.addAll(newCentroids);    }    if (correctWeights) {        for (Vector v : centroids) {            ((Centroid) v).setWeight(0);        }        for (WeightedVector datapoint : datapoints) {            Centroid closestCentroid = (Centroid) centroids.searchFirst(datapoint, false).getValue();            closestCentroid.setWeight(closestCentroid.getWeight() + datapoint.getWeight());        }    }}
e9c768fb52228d6aa5b0945798f4033616cc8afa18e4393d04e4e70c2a5349bf
iterator
public Iterator<Centroid> iterator()
{    return Iterators.transform(centroids.iterator(), new Function<Vector, Centroid>() {        @Override        public Centroid apply(Vector input) {            Preconditions.checkArgument(input instanceof Centroid, "Non-centroid in centroids " + "searcher");                        return (Centroid) input;        }    });}
0bd6cb0c3346714044be009daaa5b1aff0997d5d287879bc85a6822c593121f9
apply
public Centroid apply(Vector input)
{    Preconditions.checkArgument(input instanceof Centroid, "Non-centroid in centroids " + "searcher");        return (Centroid) input;}
e9c768fb52228d6aa5b0945798f4033616cc8afa18e4393d04e4e70c2a5349bf
iterator
public Iterator<Centroid> iterator()
{    return Iterators.transform(centroids.iterator(), new Function<Vector, Centroid>() {        @Override        public Centroid apply(Vector input) {            return (Centroid) input;        }    });}
0bd6cb0c3346714044be009daaa5b1aff0997d5d287879bc85a6822c593121f9
apply
public Centroid apply(Vector input)
{    return (Centroid) input;}
367f109dc61f1962187f257b9e51b66eee2866dab874d729c8e0e55e8be047e3
cluster
public UpdatableSearcher cluster(Matrix data)
{    return cluster(Iterables.transform(data, new Function<MatrixSlice, Centroid>() {        @Override        public Centroid apply(MatrixSlice input) {                        return Centroid.create(input.index(), input.vector());        }    }));}
9232daca1a18b022875dca691196471b92a621a5c75fab103334ff008355ec2a
apply
public Centroid apply(MatrixSlice input)
{        return Centroid.create(input.index(), input.vector());}
a5dab99472bdf5a7df16088c386fcce7d8705d5d500585c34ec575bb6efac22b
cluster
public UpdatableSearcher cluster(Iterable<Centroid> datapoints)
{    return clusterInternal(datapoints, false);}
6c742b380073a74c023e48a91fd59681c22d28fcc1d678a7f8908b777210adeb
cluster
public UpdatableSearcher cluster(final Centroid datapoint)
{    return cluster(new Iterable<Centroid>() {        @Override        public Iterator<Centroid> iterator() {            return new Iterator<Centroid>() {                private boolean accessed = false;                @Override                public boolean hasNext() {                    return !accessed;                }                @Override                public Centroid next() {                    accessed = true;                    return datapoint;                }                @Override                public void remove() {                    throw new UnsupportedOperationException();                }            };        }    });}
e9c768fb52228d6aa5b0945798f4033616cc8afa18e4393d04e4e70c2a5349bf
iterator
public Iterator<Centroid> iterator()
{    return new Iterator<Centroid>() {        private boolean accessed = false;        @Override        public boolean hasNext() {            return !accessed;        }        @Override        public Centroid next() {            accessed = true;            return datapoint;        }        @Override        public void remove() {            throw new UnsupportedOperationException();        }    };}
d51e5f7450eca0a0f63da1a466189e262d053b84aa767ba3be5cea740af7251b
hasNext
public boolean hasNext()
{    return !accessed;}
63937d54fd4462a52d6b71c277df693ca8a5e457aa84b29dd89f8831ae94b06e
next
public Centroid next()
{    accessed = true;    return datapoint;}
eb35e4acc0ab2c89fd30970f01fba35488b3a4581b2af1986091209043508a3e
remove
public void remove()
{    throw new UnsupportedOperationException();}
00135c5cd18738e139ac21cc4ae083c84c451dace0d12c5bebe42ba2f3421415
getNumClusters
public int getNumClusters()
{    return centroids.size();}
2dc457b1bc1b2b443fc1821c9d569b091feaf1f5bc297e2a05cd742088a964fb
clusterInternal
private UpdatableSearcher clusterInternal(Iterable<Centroid> datapoints, boolean collapseClusters)
{    Iterator<Centroid> datapointsIterator = datapoints.iterator();    if (!datapointsIterator.hasNext()) {        return centroids;    }    int oldNumProcessedDataPoints = numProcessedDatapoints;        if (collapseClusters) {        centroids.clear();        numProcessedDatapoints = 0;    }    if (centroids.size() == 0) {                                centroids.add(datapointsIterator.next().clone());        ++numProcessedDatapoints;    }        while (datapointsIterator.hasNext()) {        Centroid row = datapointsIterator.next();                                WeightedThing<Vector> closestPair = centroids.searchFirst(row, false);                                                                double sample = random.nextDouble();        if (sample < row.getWeight() * closestPair.getWeight() / distanceCutoff) {                        centroids.add(row.clone());        } else {                                                            Centroid centroid = (Centroid) closestPair.getValue();                        if (!centroids.remove(centroid, Constants.EPSILON)) {                throw new RuntimeException("Unable to remove centroid");            }            centroid.update(row);            centroids.add(centroid);        }        ++numProcessedDatapoints;        if (!collapseClusters && centroids.size() > clusterOvershoot * numClusters) {            numClusters = (int) Math.max(numClusters, clusterLogFactor * Math.log(numProcessedDatapoints));            List<Centroid> shuffled = new ArrayList<>();            for (Vector vector : centroids) {                shuffled.add((Centroid) vector);            }            Collections.shuffle(shuffled);                                    clusterInternal(shuffled, true);            if (centroids.size() > numClusters) {                distanceCutoff *= beta;            }        }    }    if (collapseClusters) {        numProcessedDatapoints = oldNumProcessedDataPoints;    }    return centroids;}
b2a5fcdba50bb48d8ff751efb754b7e88d43b34b445be2b9ae4f22d3424eff17
reindexCentroids
public void reindexCentroids()
{    int numCentroids = 0;    for (Centroid centroid : this) {        centroid.setIndex(numCentroids++);    }}
cd15d9b3d4fb7a68b7964f29806ed9afad684a0c6249ca7742370a6eab6d3ebe
getDistanceCutoff
public double getDistanceCutoff()
{    return distanceCutoff;}
43b950ff3228609ba30fac7caf98df41f29ea0b636f7035d57801d3abc524b5f
setDistanceCutoff
public void setDistanceCutoff(double distanceCutoff)
{    this.distanceCutoff = distanceCutoff;}
43eb234438d3c4e97fe7a0cf611acc90afcfc253b20b6f3f9c873abeb8d864c1
getDistanceMeasure
public DistanceMeasure getDistanceMeasure()
{    return centroids.getDistanceMeasure();}
b82493ab17b4659f4ae0cef58af629d7c41dd0db604f34f4031072d790a9898e
getCentroid
public Centroid getCentroid()
{    return centroid;}
5493eeee7f85bd6fb70c717b366e2363863946d32d71ebd52274dfb03a86cae5
write
public void write(DataOutput dataOutput) throws IOException
{    dataOutput.writeInt(centroid.getIndex());    dataOutput.writeDouble(centroid.getWeight());    VectorWritable.writeVector(dataOutput, centroid.getVector());}
c5821d086e99763a45e1e272070fb489eff057889b3aac47dfd41f118d6aecf6
readFields
public void readFields(DataInput dataInput) throws IOException
{    if (centroid == null) {        centroid = read(dataInput);        return;    }    centroid.setIndex(dataInput.readInt());    centroid.setWeight(dataInput.readDouble());    centroid.assign(VectorWritable.readVector(dataInput));}
75efdce842b104bd5d41029d65ac53eeb4c63c12d49ea7601e5c2a233862e363
read
public static Centroid read(DataInput dataInput) throws IOException
{    int index = dataInput.readInt();    double weight = dataInput.readDouble();    Vector v = VectorWritable.readVector(dataInput);    return new Centroid(index, v, weight);}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (!(o instanceof CentroidWritable)) {        return false;    }    CentroidWritable writable = (CentroidWritable) o;    return centroid.equals(writable.centroid);}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return centroid.hashCode();}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return centroid.toString();}
aacecb0f01750d985b78d806dc3c134f0da79efe2752957e0f93ecf5cbf9e492
run
public int run(String[] args) throws Exception
{        addInputOption();    addOutputOption();    addOption(DefaultOptionCreator.overwriteOption().create());        addOption(DefaultOptionCreator.numClustersOption().withDescription("The k in k-Means. Approximately this many clusters will be generated.").create());                    addOption(ESTIMATED_NUM_MAP_CLUSTERS, "km", "The estimated number of clusters to use for the " + "Map phase of the job when running StreamingKMeans. This should be around k * log(n), " + "where k is the final number of clusters and n is the total number of data points to " + "cluster.", String.valueOf(1));    addOption(ESTIMATED_DISTANCE_CUTOFF, "e", "The initial estimated distance cutoff between two " + "points for forming new clusters. If no value is given, it's estimated from the data set", String.valueOf(INVALID_DISTANCE_CUTOFF));        addOption(MAX_NUM_ITERATIONS, "mi", "The maximum number of iterations to run for the " + "BallKMeans algorithm used by the reducer. If no value is given, defaults to 10.", String.valueOf(10));    addOption(TRIM_FRACTION, "tf", "The 'ball' aspect of ball k-means means that only the closest points " + "to the centroid will actually be used for updating. The fraction of the points to be used is those " + "points whose distance to the center is within trimFraction * distance to the closest other center. " + "If no value is given, defaults to 0.9.", String.valueOf(0.9));    addFlag(RANDOM_INIT, "ri", "Whether to use k-means++ initialization or random initialization " + "of the seed centroids. Essentially, k-means++ provides better clusters, but takes longer, whereas random " + "initialization takes less time, but produces worse clusters, and tends to fail more often and needs " + "multiple runs to compare to k-means++. If set, uses the random initialization.");    addFlag(IGNORE_WEIGHTS, "iw", "Whether to correct the weights of the centroids after the clustering is done. " + "The weights end up being wrong because of the trimFraction and possible train/test splits. In some cases, " + "especially in a pipeline, having an accurate count of the weights is useful. If set, ignores the final " + "weights");    addOption(TEST_PROBABILITY, "testp", "A double value between 0 and 1 that represents the percentage of " + "points to be used for 'testing' different clustering runs in the final BallKMeans " + "step. If no value is given, defaults to 0.1", String.valueOf(0.1));    addOption(NUM_BALLKMEANS_RUNS, "nbkm", "Number of BallKMeans runs to use at the end to try to cluster the " + "points. If no value is given, defaults to 4", String.valueOf(4));                        addOption(DefaultOptionCreator.distanceMeasureOption().create());            addOption(SEARCHER_CLASS_OPTION, "sc", "The type of searcher to be used when performing nearest " + "neighbor searches. Defaults to ProjectionSearch.", ProjectionSearch.class.getCanonicalName());        addOption(NUM_PROJECTIONS_OPTION, "np", "The number of projections considered in estimating the " + "distances between vectors. Only used when the distance measure requested is either " + "ProjectionSearch or FastProjectionSearch. If no value is given, defaults to 3.", String.valueOf(3));    addOption(SEARCH_SIZE_OPTION, "s", "In more efficient searches (non BruteSearch), " + "not all distances are calculated for determining the nearest neighbors. The number of " + "elements whose distances from the query vector is actually computer is proportional to " + "searchSize. If no value is given, defaults to 1.", String.valueOf(2));    addFlag(REDUCE_STREAMING_KMEANS, "rskm", "There might be too many intermediate clusters from the mapper " + "to fit into memory, so the reducer can run another pass of StreamingKMeans to collapse them down to a " + "fewer clusters");    addOption(DefaultOptionCreator.methodOption().create());    if (parseArguments(args) == null) {        return -1;    }    Path output = getOutputPath();    if (hasOption(DefaultOptionCreator.OVERWRITE_OPTION)) {        HadoopUtil.delete(getConf(), output);    }    configureOptionsForWorkers();    run(getConf(), getInputPath(), output);    return 0;}
3726bb7e553201e02738e2498fced98931562e50f261a33a1223a2d4890c69cc
configureOptionsForWorkers
private void configureOptionsForWorkers() throws ClassNotFoundException
{    log.info("Starting to configure options for workers");    String method = getOption(DefaultOptionCreator.METHOD_OPTION);    int numClusters = Integer.parseInt(getOption(DefaultOptionCreator.NUM_CLUSTERS_OPTION));        int estimatedNumMapClusters = Integer.parseInt(getOption(ESTIMATED_NUM_MAP_CLUSTERS));    float estimatedDistanceCutoff = Float.parseFloat(getOption(ESTIMATED_DISTANCE_CUTOFF));        int maxNumIterations = Integer.parseInt(getOption(MAX_NUM_ITERATIONS));    float trimFraction = Float.parseFloat(getOption(TRIM_FRACTION));    boolean randomInit = hasOption(RANDOM_INIT);    boolean ignoreWeights = hasOption(IGNORE_WEIGHTS);    float testProbability = Float.parseFloat(getOption(TEST_PROBABILITY));    int numBallKMeansRuns = Integer.parseInt(getOption(NUM_BALLKMEANS_RUNS));        String measureClass = getOption(DefaultOptionCreator.DISTANCE_MEASURE_OPTION);    String searcherClass = getOption(SEARCHER_CLASS_OPTION);                    boolean getSearchSize = false;    boolean getNumProjections = false;    if (!searcherClass.equals(BruteSearch.class.getName())) {        getSearchSize = true;        getNumProjections = true;    }        int searchSize = 0;    if (getSearchSize) {        searchSize = Integer.parseInt(getOption(SEARCH_SIZE_OPTION));    }                int numProjections = 0;    if (getNumProjections) {        numProjections = Integer.parseInt(getOption(NUM_PROJECTIONS_OPTION));    }    boolean reduceStreamingKMeans = hasOption(REDUCE_STREAMING_KMEANS);    configureOptionsForWorkers(getConf(), numClusters, /* StreamingKMeans */    estimatedNumMapClusters, estimatedDistanceCutoff, /* BallKMeans */    maxNumIterations, trimFraction, randomInit, ignoreWeights, testProbability, numBallKMeansRuns, /* Searcher */    measureClass, searcherClass, searchSize, numProjections, method, reduceStreamingKMeans);}
d57f3591341e2e8843d331fe29b00e7f236777f613ba487c3b38d008af0fd1ad
configureOptionsForWorkers
public static void configureOptionsForWorkers(Configuration conf, int numClusters, int estimatedNumMapClusters, float estimatedDistanceCutoff, int maxNumIterations, float trimFraction, boolean randomInit, boolean ignoreWeights, float testProbability, int numBallKMeansRuns, String measureClass, String searcherClass, int searchSize, int numProjections, String method, boolean reduceStreamingKMeans) throws ClassNotFoundException
{        Preconditions.checkArgument(numClusters > 0, "Invalid number of clusters requested: " + numClusters + ". Must be: numClusters > 0!");        Preconditions.checkArgument(estimatedNumMapClusters > numClusters, "Invalid number of estimated map " + "clusters; There must be more than the final number of clusters (k log n vs k)");    Preconditions.checkArgument(estimatedDistanceCutoff == INVALID_DISTANCE_CUTOFF || estimatedDistanceCutoff > 0, "estimatedDistanceCutoff must be equal to -1 or must be greater then 0!");        Preconditions.checkArgument(maxNumIterations > 0, "Must have at least one BallKMeans iteration");    Preconditions.checkArgument(trimFraction > 0, "trimFraction must be positive");    Preconditions.checkArgument(testProbability >= 0 && testProbability < 1, "test probability is not in the " + "interval [0, 1)");    Preconditions.checkArgument(numBallKMeansRuns > 0, "numBallKMeans cannot be negative");        if (!searcherClass.contains("Brute")) {                Preconditions.checkArgument(searchSize > 0, "Invalid searchSize. Must be positive.");        if (searcherClass.contains("Projection")) {            Preconditions.checkArgument(numProjections > 0, "Invalid numProjections. Must be positive");        }    }        conf.setInt(DefaultOptionCreator.NUM_CLUSTERS_OPTION, numClusters);    /* StreamingKMeans */    conf.setInt(ESTIMATED_NUM_MAP_CLUSTERS, estimatedNumMapClusters);    if (estimatedDistanceCutoff != INVALID_DISTANCE_CUTOFF) {        conf.setFloat(ESTIMATED_DISTANCE_CUTOFF, estimatedDistanceCutoff);    }    /* BallKMeans */    conf.setInt(MAX_NUM_ITERATIONS, maxNumIterations);    conf.setFloat(TRIM_FRACTION, trimFraction);    conf.setBoolean(RANDOM_INIT, randomInit);    conf.setBoolean(IGNORE_WEIGHTS, ignoreWeights);    conf.setFloat(TEST_PROBABILITY, testProbability);    conf.setInt(NUM_BALLKMEANS_RUNS, numBallKMeansRuns);    /* Searcher */        Class.forName(measureClass);    conf.set(DefaultOptionCreator.DISTANCE_MEASURE_OPTION, measureClass);        Class.forName(searcherClass);    conf.set(SEARCHER_CLASS_OPTION, searcherClass);    conf.setInt(SEARCH_SIZE_OPTION, searchSize);    conf.setInt(NUM_PROJECTIONS_OPTION, numProjections);    conf.set(DefaultOptionCreator.METHOD_OPTION, method);    conf.setBoolean(REDUCE_STREAMING_KMEANS, reduceStreamingKMeans);    log.info("Parameters are: [k] numClusters {}; " + "[SKM] estimatedNumMapClusters {}; estimatedDistanceCutoff {} " + "[BKM] maxNumIterations {}; trimFraction {}; randomInit {}; ignoreWeights {}; " + "testProbability {}; numBallKMeansRuns {}; " + "[S] measureClass {}; searcherClass {}; searcherSize {}; numProjections {}; " + "method {}; reduceStreamingKMeans {}", numClusters, estimatedNumMapClusters, estimatedDistanceCutoff, maxNumIterations, trimFraction, randomInit, ignoreWeights, testProbability, numBallKMeansRuns, measureClass, searcherClass, searchSize, numProjections, method, reduceStreamingKMeans);}
a5986f0cfcb23b2944075bba3932cd58b38f4c48f909018c8f8edae49860ccc5
run
public static int run(Configuration conf, Path input, Path output) throws IOException, InterruptedException, ClassNotFoundException, ExecutionException
{    log.info("Starting StreamingKMeans clustering for vectors in {}; results are output to {}", input.toString(), output.toString());    if (conf.get(DefaultOptionCreator.METHOD_OPTION, DefaultOptionCreator.MAPREDUCE_METHOD).equals(DefaultOptionCreator.SEQUENTIAL_METHOD)) {        return runSequentially(conf, input, output);    } else {        return runMapReduce(conf, input, output);    }}
afacb23ecc706e4151a2ec4352899bcdff8c7bed2e8e24a258dd362bf7ca558b
runSequentially
private static int runSequentially(Configuration conf, Path input, Path output) throws IOException, ExecutionException, InterruptedException
{    long start = System.currentTimeMillis();        ExecutorService pool = Executors.newCachedThreadPool();    List<Future<Iterable<Centroid>>> intermediateCentroidFutures = new ArrayList<>();    for (FileStatus status : HadoopUtil.listStatus(FileSystem.get(conf), input, PathFilters.logsCRCFilter())) {        intermediateCentroidFutures.add(pool.submit(new StreamingKMeansThread(status.getPath(), conf)));    }    log.info("Finished running Mappers");        List<Centroid> intermediateCentroids = new ArrayList<>();    for (Future<Iterable<Centroid>> futureIterable : intermediateCentroidFutures) {        for (Centroid centroid : futureIterable.get()) {            intermediateCentroids.add(centroid);        }    }    pool.shutdown();    pool.awaitTermination(Long.MAX_VALUE, TimeUnit.SECONDS);    log.info("Finished StreamingKMeans");    SequenceFile.Writer writer = SequenceFile.createWriter(FileSystem.get(conf), conf, new Path(output, "part-r-00000"), IntWritable.class, CentroidWritable.class);    int numCentroids = 0;        for (Vector finalVector : StreamingKMeansReducer.getBestCentroids(intermediateCentroids, conf)) {        Centroid finalCentroid = (Centroid) finalVector;        writer.append(new IntWritable(numCentroids++), new CentroidWritable(finalCentroid));    }    writer.close();    long end = System.currentTimeMillis();    log.info("Finished BallKMeans. Took {}.", (end - start) / 1000.0);    return 0;}
3bd39ddb1326056195b87a655d9bf18952180bafd8b578e3e41bfade609c317c
runMapReduce
public static int runMapReduce(Configuration conf, Path input, Path output) throws IOException, ClassNotFoundException, InterruptedException
{        Job job = HadoopUtil.prepareJob(input, output, SequenceFileInputFormat.class, StreamingKMeansMapper.class, IntWritable.class, CentroidWritable.class, StreamingKMeansReducer.class, IntWritable.class, CentroidWritable.class, SequenceFileOutputFormat.class, conf);    job.setJobName(HadoopUtil.getCustomJobName(StreamingKMeansDriver.class.getSimpleName(), job, StreamingKMeansMapper.class, StreamingKMeansReducer.class));            job.setNumReduceTasks(1);        job.setJarByClass(StreamingKMeansDriver.class);        long start = System.currentTimeMillis();    if (!job.waitForCompletion(true)) {        return -1;    }    long end = System.currentTimeMillis();    log.info("StreamingKMeans clustering complete. Results are in {}. Took {} ms", output.toString(), end - start);    return 0;}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    ToolRunner.run(new StreamingKMeansDriver(), args);}
5cea2a7c4e1f15509b5030e71609dca919138d48d1aebe9efc31435a268ea192
setup
public void setup(Context context)
{            Configuration conf = context.getConfiguration();    UpdatableSearcher searcher = StreamingKMeansUtilsMR.searcherFromConfiguration(conf);    int numClusters = conf.getInt(StreamingKMeansDriver.ESTIMATED_NUM_MAP_CLUSTERS, 1);    double estimatedDistanceCutoff = conf.getFloat(StreamingKMeansDriver.ESTIMATED_DISTANCE_CUTOFF, StreamingKMeansDriver.INVALID_DISTANCE_CUTOFF);    if (estimatedDistanceCutoff == StreamingKMeansDriver.INVALID_DISTANCE_CUTOFF) {        estimateDistanceCutoff = true;        estimatePoints = new ArrayList<>();    }        clusterer = new StreamingKMeans(searcher, numClusters, estimatedDistanceCutoff);}
953f37793bd5b123d12f12e3beb45bc34bb46e3915d4c2fe11971268f422e84d
clusterEstimatePoints
private void clusterEstimatePoints()
{    clusterer.setDistanceCutoff(ClusteringUtils.estimateDistanceCutoff(estimatePoints, clusterer.getDistanceMeasure()));    clusterer.cluster(estimatePoints);    estimateDistanceCutoff = false;}
58c1f4b41813897859a4dc6d70f279d4b98c2981acfa4680cb2d1a95390737a9
map
public void map(Writable key, VectorWritable point, Context context)
{    Centroid centroid = new Centroid(numPoints++, point.get(), 1);    if (estimateDistanceCutoff) {        if (numPoints < NUM_ESTIMATE_POINTS) {            estimatePoints.add(centroid);        } else if (numPoints == NUM_ESTIMATE_POINTS) {            clusterEstimatePoints();        }    } else {        clusterer.cluster(centroid);    }}
6a4f097a82d3a7057457740360a7d6c25ecd2ea478f6041870cf525d53e980d0
cleanup
public void cleanup(Context context) throws IOException, InterruptedException
{        if (estimateDistanceCutoff) {        clusterEstimatePoints();    }        clusterer.reindexCentroids();        for (Centroid centroid : clusterer) {        context.write(new IntWritable(0), new CentroidWritable(centroid));    }}
5cea2a7c4e1f15509b5030e71609dca919138d48d1aebe9efc31435a268ea192
setup
public void setup(Context context)
{            conf = context.getConfiguration();}
72426204271c8edf2f3ea965035797c7b3ecc54d40191633b79536b809c3164c
reduce
public void reduce(IntWritable key, Iterable<CentroidWritable> centroids, Context context) throws IOException, InterruptedException
{    List<Centroid> intermediateCentroids;        if (conf.getBoolean(StreamingKMeansDriver.REDUCE_STREAMING_KMEANS, false)) {        intermediateCentroids = Lists.newArrayList(new StreamingKMeansThread(Iterables.transform(centroids, new Function<CentroidWritable, Centroid>() {            @Override            public Centroid apply(CentroidWritable input) {                Preconditions.checkNotNull(input);                return input.getCentroid().clone();            }        }), conf).call());    } else {        intermediateCentroids = centroidWritablesToList(centroids);    }    int index = 0;    for (Vector centroid : getBestCentroids(intermediateCentroids, conf)) {        context.write(new IntWritable(index), new CentroidWritable((Centroid) centroid));        ++index;    }}
75172182fb3da3e5f50ed7424bea1bf34b06723644ff311c847fda12a88deddf
apply
public Centroid apply(CentroidWritable input)
{    Preconditions.checkNotNull(input);    return input.getCentroid().clone();}
994d5adcb823dfdab6e99316709a957f2ab7dd6e0f7891045c217004f89ac431
centroidWritablesToList
public static List<Centroid> centroidWritablesToList(Iterable<CentroidWritable> centroids)
{        return Lists.newArrayList(Iterables.transform(centroids, new Function<CentroidWritable, Centroid>() {        @Override        public Centroid apply(CentroidWritable input) {            Preconditions.checkNotNull(input);            return input.getCentroid().clone();        }    }));}
75172182fb3da3e5f50ed7424bea1bf34b06723644ff311c847fda12a88deddf
apply
public Centroid apply(CentroidWritable input)
{    Preconditions.checkNotNull(input);    return input.getCentroid().clone();}
9dc930c846408e06df9121d475792376d95f52d533bc44e24bbefd225a0c8a49
getBestCentroids
public static Iterable<Vector> getBestCentroids(List<Centroid> centroids, Configuration conf)
{    if (log.isInfoEnabled()) {        log.info("Number of Centroids: {}", centroids.size());    }    int numClusters = conf.getInt(DefaultOptionCreator.NUM_CLUSTERS_OPTION, 1);    int maxNumIterations = conf.getInt(StreamingKMeansDriver.MAX_NUM_ITERATIONS, 10);    float trimFraction = conf.getFloat(StreamingKMeansDriver.TRIM_FRACTION, 0.9f);    boolean kMeansPlusPlusInit = !conf.getBoolean(StreamingKMeansDriver.RANDOM_INIT, false);    boolean correctWeights = !conf.getBoolean(StreamingKMeansDriver.IGNORE_WEIGHTS, false);    float testProbability = conf.getFloat(StreamingKMeansDriver.TEST_PROBABILITY, 0.1f);    int numRuns = conf.getInt(StreamingKMeansDriver.NUM_BALLKMEANS_RUNS, 3);    BallKMeans ballKMeansCluster = new BallKMeans(StreamingKMeansUtilsMR.searcherFromConfiguration(conf), numClusters, maxNumIterations, trimFraction, kMeansPlusPlusInit, correctWeights, testProbability, numRuns);    return ballKMeansCluster.cluster(centroids);}
2e11aa00a5754fd3b6bf3845ba444b2bff332d0b010eb0e3fe7f1b81e4eb20db
call
public Iterable<Centroid> call()
{    UpdatableSearcher searcher = StreamingKMeansUtilsMR.searcherFromConfiguration(conf);    int numClusters = conf.getInt(StreamingKMeansDriver.ESTIMATED_NUM_MAP_CLUSTERS, 1);    double estimateDistanceCutoff = conf.getFloat(StreamingKMeansDriver.ESTIMATED_DISTANCE_CUTOFF, StreamingKMeansDriver.INVALID_DISTANCE_CUTOFF);    Iterator<Centroid> dataPointsIterator = dataPoints.iterator();    if (estimateDistanceCutoff == StreamingKMeansDriver.INVALID_DISTANCE_CUTOFF) {        List<Centroid> estimatePoints = new ArrayList<>(NUM_ESTIMATE_POINTS);        while (dataPointsIterator.hasNext() && estimatePoints.size() < NUM_ESTIMATE_POINTS) {            Centroid centroid = dataPointsIterator.next();            estimatePoints.add(centroid);        }        if (log.isInfoEnabled()) {            log.info("Estimated Points: {}", estimatePoints.size());        }        estimateDistanceCutoff = ClusteringUtils.estimateDistanceCutoff(estimatePoints, searcher.getDistanceMeasure());    }    StreamingKMeans streamingKMeans = new StreamingKMeans(searcher, numClusters, estimateDistanceCutoff);        if (!dataPointsIterator.hasNext()) {        dataPointsIterator = dataPoints.iterator();    }    while (dataPointsIterator.hasNext()) {        streamingKMeans.cluster(dataPointsIterator.next());    }    streamingKMeans.reindexCentroids();    return streamingKMeans;}
e6e02deed34d840307b9c25e19a7be1030543b63dc4b145138aaed1eecdb7062
searcherFromConfiguration
public static UpdatableSearcher searcherFromConfiguration(Configuration conf)
{    DistanceMeasure distanceMeasure;    String distanceMeasureClass = conf.get(DefaultOptionCreator.DISTANCE_MEASURE_OPTION);    try {        distanceMeasure = (DistanceMeasure) Class.forName(distanceMeasureClass).getConstructor().newInstance();    } catch (Exception e) {        throw new RuntimeException("Failed to instantiate distanceMeasure", e);    }    int numProjections = conf.getInt(StreamingKMeansDriver.NUM_PROJECTIONS_OPTION, 20);    int searchSize = conf.getInt(StreamingKMeansDriver.SEARCH_SIZE_OPTION, 10);    String searcherClass = conf.get(StreamingKMeansDriver.SEARCHER_CLASS_OPTION);    if (searcherClass.equals(BruteSearch.class.getName())) {        return ClassUtils.instantiateAs(searcherClass, UpdatableSearcher.class, new Class[] { DistanceMeasure.class }, new Object[] { distanceMeasure });    } else if (searcherClass.equals(FastProjectionSearch.class.getName()) || searcherClass.equals(ProjectionSearch.class.getName())) {        return ClassUtils.instantiateAs(searcherClass, UpdatableSearcher.class, new Class[] { DistanceMeasure.class, int.class, int.class }, new Object[] { distanceMeasure, numProjections, searchSize });    } else if (searcherClass.equals(LocalitySensitiveHashSearch.class.getName())) {        return ClassUtils.instantiateAs(searcherClass, LocalitySensitiveHashSearch.class, new Class[] { DistanceMeasure.class, int.class }, new Object[] { distanceMeasure, searchSize });    } else {        throw new IllegalStateException("Unknown class instantiation requested");    }}
1a6999c36d52afe117ce32dcee2939d1d2d1924a172fd73714070b0feed8dad5
getCentroidsFromVectorWritable
public static Iterable<Centroid> getCentroidsFromVectorWritable(Iterable<VectorWritable> inputIterable)
{    return Iterables.transform(inputIterable, new Function<VectorWritable, Centroid>() {        private int numVectors = 0;        @Override        public Centroid apply(VectorWritable input) {            Preconditions.checkNotNull(input);            return new Centroid(numVectors++, new RandomAccessSparseVector(input.get()), 1);        }    });}
e4dc4d55f946e9e8be2b5c8d1dc1a9a4d69633ad83d8069ddc7d7c4ca343b916
apply
public Centroid apply(VectorWritable input)
{    Preconditions.checkNotNull(input);    return new Centroid(numVectors++, new RandomAccessSparseVector(input.get()), 1);}
8a1e5c9542b60351cdc398d51d56772b4e56022440ee00b0007e378ecf8fa723
castVectorsToCentroids
public static Iterable<Centroid> castVectorsToCentroids(Iterable<Vector> input)
{    return Iterables.transform(input, new Function<Vector, Centroid>() {        private int numVectors = 0;        @Override        public Centroid apply(Vector input) {            Preconditions.checkNotNull(input);            if (input instanceof Centroid) {                return (Centroid) input;            } else {                return new Centroid(numVectors++, input, 1);            }        }    });}
0bd6cb0c3346714044be009daaa5b1aff0997d5d287879bc85a6822c593121f9
apply
public Centroid apply(Vector input)
{    Preconditions.checkNotNull(input);    if (input instanceof Centroid) {        return (Centroid) input;    } else {        return new Centroid(numVectors++, input, 1);    }}
5b0bb031a95f05d53be1f3619825dc4a4f513049e35facf27c03923daa25159b
writeCentroidsToSequenceFile
public static void writeCentroidsToSequenceFile(Iterable<Centroid> centroids, Path path, Configuration conf) throws IOException
{    try (SequenceFile.Writer writer = SequenceFile.createWriter(FileSystem.get(conf), conf, path, IntWritable.class, CentroidWritable.class)) {        int i = 0;        for (Centroid centroid : centroids) {            writer.append(new IntWritable(i++), new CentroidWritable(centroid));        }    }}
c49e2adc62c7f930b25bfa52a4372dc4ab45e452d152146a2d927786a37f64c3
writeVectorsToSequenceFile
public static void writeVectorsToSequenceFile(Iterable<? extends Vector> datapoints, Path path, Configuration conf) throws IOException
{    try (SequenceFile.Writer writer = SequenceFile.createWriter(FileSystem.get(conf), conf, path, IntWritable.class, VectorWritable.class)) {        int i = 0;        for (Vector vector : datapoints) {            writer.append(new IntWritable(i++), new VectorWritable(vector));        }    }}
cdca11d9864d98d48e01fb9b687493ebfa37933056f7a5138b114fbe0ab8b203
writeSplit
private void writeSplit(Iterator<Pair<Writable, Writable>> inputIterator, int numSplit, int numEntriesPerSplit) throws IOException
{    SequenceFile.Writer splitWriter = null;    for (int j = 0; j < numEntriesPerSplit; ++j) {        Pair<Writable, Writable> item = inputIterator.next();        if (splitWriter == null) {            splitWriter = SequenceFile.createWriter(fs, conf, new Path(outputFileBase + "-" + numSplit), item.getFirst().getClass(), item.getSecond().getClass());        }        splitWriter.append(item.getFirst(), item.getSecond());    }    if (splitWriter != null) {        splitWriter.close();    }}
8443822d9de84f4b94b40d245e008ed3e7a11696f05944c90eac900dd66337e0
run
private void run(PrintWriter printWriter) throws IOException
{    conf = new Configuration();    SequenceFileDirIterable<Writable, Writable> inputIterable = new SequenceFileDirIterable<>(new Path(inputFile), PathType.LIST, conf);    fs = FileSystem.get(conf);    int numEntries = Iterables.size(inputIterable);    int numEntriesPerSplit = numEntries / numSplits;    int numEntriesLastSplit = numEntriesPerSplit + numEntries - numEntriesPerSplit * numSplits;    Iterator<Pair<Writable, Writable>> inputIterator = inputIterable.iterator();    printWriter.printf("Writing %d splits\n", numSplits);    for (int i = 0; i < numSplits - 1; ++i) {        printWriter.printf("Writing split %d\n", i);        writeSplit(inputIterator, i, numEntriesPerSplit);    }    printWriter.printf("Writing split %d\n", numSplits - 1);    writeSplit(inputIterator, numSplits - 1, numEntriesLastSplit);}
4ae3834739effe006815832921463e2eafa5549c587498a65de0321385678ab2
parseArgs
private boolean parseArgs(String[] args)
{    DefaultOptionBuilder builder = new DefaultOptionBuilder();    Option help = builder.withLongName("help").withDescription("print this list").create();    ArgumentBuilder argumentBuilder = new ArgumentBuilder();    Option inputFileOption = builder.withLongName("input").withShortName("i").withRequired(true).withArgument(argumentBuilder.withName("input").withMaximum(1).create()).withDescription("what the base folder for sequence files is (they all must have the same key/value type").create();    Option outputFileOption = builder.withLongName("output").withShortName("o").withRequired(true).withArgument(argumentBuilder.withName("output").withMaximum(1).create()).withDescription("the base name of the file split that the files will be split it; the i'th split has the " + "suffix -i").create();    Option numSplitsOption = builder.withLongName("numSplits").withShortName("ns").withRequired(true).withArgument(argumentBuilder.withName("numSplits").withMaximum(1).create()).withDescription("how many splits to use for the given files").create();    Group normalArgs = new GroupBuilder().withOption(help).withOption(inputFileOption).withOption(outputFileOption).withOption(numSplitsOption).create();    Parser parser = new Parser();    parser.setHelpOption(help);    parser.setHelpTrigger("--help");    parser.setGroup(normalArgs);    parser.setHelpFormatter(new HelpFormatter(" ", "", " ", 130));    CommandLine cmdLine = parser.parseAndHelp(args);    if (cmdLine == null) {        return false;    }    inputFile = (String) cmdLine.getValue(inputFileOption);    outputFileBase = (String) cmdLine.getValue(outputFileOption);    numSplits = Integer.parseInt((String) cmdLine.getValue(numSplitsOption));    return true;}
365a24fc75086b6a0e91f9b072bd58c9280846cc05f333f28ede18388f27ce89
main
public static void main(String[] args) throws IOException
{    ResplitSequenceFiles runner = new ResplitSequenceFiles();    if (runner.parseArgs(args)) {        runner.run(new PrintWriter(new OutputStreamWriter(System.out, Charsets.UTF_8), true));    }}
a55605f867a94e74e527d2d2080609194bc3bf78689fa555022fb1f3bd23d40d
getTopLevelClusterPath
public static Path getTopLevelClusterPath(Path output)
{    return new Path(output + File.separator + TOP_LEVEL_CLUSTER_DIRECTORY);}
6ee6700cafcf88ef754e26fb019860253d598aabc867d739f8f92f207b934f0b
getClusterPostProcessorOutputDirectory
public static Path getClusterPostProcessorOutputDirectory(Path outputPathProvidedByUser)
{    return new Path(outputPathProvidedByUser + File.separator + POST_PROCESS_DIRECTORY);}
f2377a35b8dee6925873dfbeede4d4325dc5ee3bcfcc368d50a9b2e3ba25d18a
getClusterOutputClusteredPoints
public static Path getClusterOutputClusteredPoints(Path output)
{    return new Path(output + File.separator + CLUSTERED_POINTS_DIRECTORY + File.separator, "*");}
d518292443f79618dd8f7bb4f212b935e64f4926b8597ff941326a8d4c18d33c
getBottomLevelClusterPath
public static Path getBottomLevelClusterPath(Path output, String clusterId)
{    return new Path(output + File.separator + BOTTOM_LEVEL_CLUSTER_DIRECTORY + File.separator + clusterId);}
41d4b386bfe310a3766762eac36e15ddf3c2df5807fef7e51e6c22774ecf40be
getClusterPathForClusterId
public static Path getClusterPathForClusterId(Path clusterPostProcessorOutput, String clusterId)
{    return new Path(clusterPostProcessorOutput + File.separator + clusterId);}
893b83f7de97f17fc35eea779bc73b6badd9ec1ee63adf6146d3fca3a22148fb
getNumberOfClusters
public static int getNumberOfClusters(Path clusterOutputPath, Configuration conf) throws IOException
{    FileSystem fileSystem = clusterOutputPath.getFileSystem(conf);    FileStatus[] clusterFiles = fileSystem.listStatus(clusterOutputPath, PathFilters.finalPartFilter());    int numberOfClusters = 0;    Iterator<?> it = new SequenceFileDirValueIterator<>(clusterFiles[0].getPath(), PathType.LIST, PathFilters.partFilter(), null, true, conf);    while (it.hasNext()) {        it.next();        numberOfClusters++;    }    return numberOfClusters;}
44704f44ab1368ca080c86f02253ce8cd1ecf96f6906d096928c48e9f865b7a0
getClusterIDs
public static Map<Integer, Integer> getClusterIDs(Path clusterOutputPath, Configuration conf, boolean keyIsClusterId) throws IOException
{    Map<Integer, Integer> clusterIds = new HashMap<>();    FileSystem fileSystem = clusterOutputPath.getFileSystem(conf);    FileStatus[] clusterFiles = fileSystem.listStatus(clusterOutputPath, PathFilters.finalPartFilter());        Iterator<ClusterWritable> it = new SequenceFileDirValueIterator<>(clusterFiles[0].getPath(), PathType.LIST, PathFilters.partFilter(), null, true, conf);    int i = 0;    while (it.hasNext()) {        Integer key;        Integer value;        if (keyIsClusterId) {                        key = it.next().getValue().getId();            value = i;        } else {            key = i;            value = it.next().getValue().getId();        }        clusterIds.put(key, value);        i++;    }    return clusterIds;}
dc7ff1a414fab78da844da7bb23b2683dd93bc5b1732482542438afe704e881d
process
public void process() throws IOException
{    createPostProcessDirectory();    for (Pair<?, WeightedVectorWritable> record : new SequenceFileDirIterable<Writable, WeightedVectorWritable>(clusteredPoints, PathType.GLOB, PathFilters.partFilter(), null, false, conf)) {        String clusterId = record.getFirst().toString().trim();        putVectorInRespectiveCluster(clusterId, record.getSecond());    }    IOUtils.close(writersForClusters.values());    writersForClusters.clear();}
1119a2c94d31402ad4e25c624e3c3eb6fe891c40dcebf6875ca90ff0ae54fe0d
createPostProcessDirectory
private void createPostProcessDirectory() throws IOException
{    if (!fileSystem.exists(clusterPostProcessorOutput) && !fileSystem.mkdirs(clusterPostProcessorOutput)) {        throw new IOException("Error creating cluster post processor directory");    }}
698c244480f00c82bb620968663c2a25323479f2a77a1b605b765ee86614f5b0
putVectorInRespectiveCluster
private void putVectorInRespectiveCluster(String clusterId, WeightedVectorWritable point) throws IOException
{    Writer writer = findWriterForVector(clusterId);    postProcessedClusterDirectories.put(clusterId, PathDirectory.getClusterPathForClusterId(clusterPostProcessorOutput, clusterId));    writeVectorToCluster(writer, point);}
7c18673e4578d0d417d7239ea3157b9d2aa5603027631fb145da1ada30709479
findWriterForVector
private Writer findWriterForVector(String clusterId) throws IOException
{    Path clusterDirectory = PathDirectory.getClusterPathForClusterId(clusterPostProcessorOutput, clusterId);    Writer writer = writersForClusters.get(clusterId);    if (writer == null) {        Path pathToWrite = new Path(clusterDirectory, new Path("part-m-0"));        writer = new Writer(fileSystem, conf, pathToWrite, LongWritable.class, VectorWritable.class);        writersForClusters.put(clusterId, writer);    }    return writer;}
1a5ffec3b101a628dbe241117a6b0171fc02e086482e700a8a67deb1601deb08
writeVectorToCluster
private void writeVectorToCluster(Writer writer, WeightedVectorWritable point) throws IOException
{    writer.append(new LongWritable(uniqueVectorId++), new VectorWritable(point.getVector()));    writer.sync();}
0bf8649c882ed10015b3be8c943d65dcc77320029d29695780fd8baed3b50553
getPostProcessedClusterDirectories
public Map<String, Path> getPostProcessedClusterDirectories()
{    return postProcessedClusterDirectories;}
658aaa6ba600a9b6a2fba7efedc7e08715d92f9dc3f2955f98bb5278b5a7f0fd
setClusteredPoints
public void setClusteredPoints(Path clusteredPoints)
{    this.clusteredPoints = clusteredPoints;}
aacecb0f01750d985b78d806dc3c134f0da79efe2752957e0f93ecf5cbf9e492
run
public int run(String[] args) throws Exception
{    addInputOption();    addOutputOption();    addOption(DefaultOptionCreator.methodOption().create());    addOption(DefaultOptionCreator.overwriteOption().create());    if (parseArguments(args) == null) {        return -1;    }    Path input = getInputPath();    Path output = getOutputPath();    if (hasOption(DefaultOptionCreator.OVERWRITE_OPTION)) {        HadoopUtil.delete(getConf(), output);    }    boolean runSequential = getOption(DefaultOptionCreator.METHOD_OPTION).equalsIgnoreCase(DefaultOptionCreator.SEQUENTIAL_METHOD);    run(input, output, runSequential);    return 0;}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    ToolRunner.run(new Configuration(), new ClusterOutputPostProcessorDriver(), args);}
b059ffab642f85d971c61364169747ec405622f4b57a7fc53391c7e2eaf547f5
run
public static void run(Path input, Path output, boolean runSequential) throws IOException, InterruptedException, ClassNotFoundException
{    if (runSequential) {        postProcessSeq(input, output);    } else {        Configuration conf = new Configuration();        postProcessMR(conf, input, output);        movePartFilesToRespectiveDirectories(conf, output);    }}
22dc417fdfeba80af182f7752c006923c6c08fea5f3af33e2a53ca07c1789906
postProcessSeq
private static void postProcessSeq(Path input, Path output) throws IOException
{    ClusterOutputPostProcessor clusterOutputPostProcessor = new ClusterOutputPostProcessor(input, output, new Configuration());    clusterOutputPostProcessor.process();}
90e94f5fa36c32063d9cd7723180eda14ac2b4e171694f216122c038e06ae600
postProcessMR
private static void postProcessMR(Configuration conf, Path input, Path output) throws IOException, InterruptedException, ClassNotFoundException
{    System.out.println("WARNING: If you are running in Hadoop local mode, please use the --sequential option, " + "as the MapReduce option will not work properly");    int numberOfClusters = ClusterCountReader.getNumberOfClusters(input, conf);    conf.set("clusterOutputPath", input.toString());    Job job = new Job(conf, "ClusterOutputPostProcessor Driver running over input: " + input);    job.setInputFormatClass(SequenceFileInputFormat.class);    job.setOutputFormatClass(SequenceFileOutputFormat.class);    job.setMapperClass(ClusterOutputPostProcessorMapper.class);    job.setMapOutputKeyClass(IntWritable.class);    job.setMapOutputValueClass(VectorWritable.class);    job.setReducerClass(ClusterOutputPostProcessorReducer.class);    job.setOutputKeyClass(IntWritable.class);    job.setOutputValueClass(VectorWritable.class);    job.setNumReduceTasks(numberOfClusters);    job.setJarByClass(ClusterOutputPostProcessorDriver.class);    FileInputFormat.addInputPath(job, new Path(input, new Path("clusteredPoints")));    FileOutputFormat.setOutputPath(job, output);    if (!job.waitForCompletion(true)) {        throw new InterruptedException("ClusterOutputPostProcessor Job failed processing " + input);    }}
48126b5e20aa2bd5431b7cb21c8fd407355f0d49194be2cd6a54167cecd8d3db
movePartFilesToRespectiveDirectories
private static void movePartFilesToRespectiveDirectories(Configuration conf, Path output) throws IOException
{    FileSystem fileSystem = output.getFileSystem(conf);    for (FileStatus fileStatus : fileSystem.listStatus(output, PathFilters.partFilter())) {        SequenceFileIterator<Writable, Writable> it = new SequenceFileIterator<>(fileStatus.getPath(), true, conf);        if (it.hasNext()) {            renameFile(it.next().getFirst(), fileStatus, conf);        }        it.close();    }}
17bf100556e33d565533a4ae19a45253c2c708de348da55ca270ad42d0ea30cb
renameFile
private static void renameFile(Writable key, FileStatus fileStatus, Configuration conf) throws IOException
{    Path path = fileStatus.getPath();    FileSystem fileSystem = path.getFileSystem(conf);    Path subDir = new Path(key.toString());    Path renameTo = new Path(path.getParent(), subDir);    fileSystem.mkdirs(renameTo);    fileSystem.rename(path, renameTo);}
7ac440e0f2bb4f2fed53e09f23bdeaeaff1a192ec96fcaa7c398a032d211bc40
setup
public void setup(Context context) throws IOException
{    Configuration conf = context.getConfiguration();        Path clusterOutputPath = new Path(conf.get("clusterOutputPath"));        newClusterMappings = ClusterCountReader.getClusterIDs(clusterOutputPath, conf, true);    outputVector = new VectorWritable();}
a8a97d42808b2abbfb927ce2f6090a9bfee5c2d5b79c227ce26de2789aaa6f7e
map
public void map(IntWritable key, WeightedVectorWritable val, Context context) throws IOException, InterruptedException
{            outputVector.set(val.getVector());    context.write(new IntWritable(newClusterMappings.get(key.get())), outputVector);}
7ac440e0f2bb4f2fed53e09f23bdeaeaff1a192ec96fcaa7c398a032d211bc40
setup
public void setup(Context context) throws IOException
{    Configuration conf = context.getConfiguration();    Path clusterOutputPath = new Path(conf.get("clusterOutputPath"));        reverseClusterMappings = ClusterCountReader.getClusterIDs(clusterOutputPath, conf, false);}
38b6ae5125304195fb622a099206575124a7d89f5a88d49559ca1cba07fa926d
reduce
protected void reduce(IntWritable key, Iterable<VectorWritable> values, Context context) throws IOException, InterruptedException
{                IntWritable outKey = new IntWritable(reverseClusterMappings.get(key.get()));    System.out.println(outKey + " this: " + this);    for (VectorWritable value : values) {        context.write(outKey, value);    }}
fc66f7ce014ba3fc6b6ec353763620f27bc53508680312a8cbc073af91830715
rGamma
public static double rGamma(double k, double lambda)
{    boolean accept = false;    if (k >= 1.0) {                double b = k - Math.log(4.0);        double c = k + Math.sqrt(2.0 * k - 1.0);        double lam = Math.sqrt(2.0 * k - 1.0);        double cheng = 1.0 + Math.log(4.5);        double x;        do {            double u = RANDOM.nextDouble();            double v = RANDOM.nextDouble();            double y = 1.0 / lam * Math.log(v / (1.0 - v));            x = k * Math.exp(y);            double z = u * v * v;            double r = b + c * y - x;            if (r >= 4.5 * z - cheng || r >= Math.log(z)) {                accept = true;            }        } while (!accept);        return x / lambda;    } else {                double c = 1.0 / k;        double d = (1.0 - k) * Math.pow(k, k / (1.0 - k));        double x;        do {            double u = RANDOM.nextDouble();            double v = RANDOM.nextDouble();            double z = -Math.log(u);            double e = -Math.log(v);            x = Math.pow(z, c);            if (z + e >= d + x) {                accept = true;            }        } while (!accept);        return x / lambda;    }}
addd7c098967fb5ada5969f9c674ce59d3406b8c08bb67812a9954f36975f688
rBeta
public static double rBeta(double shape1, double shape2)
{    double gam1 = rGamma(shape1, 1.0);    double gam2 = rGamma(shape2, 1.0);    return gam1 / (gam1 + gam2);}
65027f65bceacb773cd399245543a6de66c4440d8d116b1dc3178e97d0881f69
rNorm
public static double rNorm(double mean, double sd)
{    RealDistribution dist = new NormalDistribution(RANDOM.getRandomGenerator(), mean, sd, NormalDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY);    return dist.sample();}
e56f730f04fdfea0227c1df8bc2235eaf1d278fb9625821e8f37fea4794ba8e3
rBinomial
public static int rBinomial(int n, double p)
{    if (p >= 1.0) {                return n;    }    double q = -Math.log1p(-p);    double sum = 0.0;    int x = 0;    while (sum <= q) {        double u = RANDOM.nextDouble();        double e = -Math.log(u);        sum += e / (n - x);        x++;    }    if (x == 0) {        return 0;    }    return x - 1;}
236618b7b551721a3b7a61cd1c4ca22ee71af41f686310bf0d9de2fd5034f105
getInputPath
protected Path getInputPath()
{    return inputPath;}
994b5f74709935e6efbf6b44c00ad4ff529604123f8ff12a8151222ff510149f
getOutputPath
protected Path getOutputPath()
{    return outputPath;}
f97650f7013ec030b736a94e6f802aca2444eef8c700a9deaad16b9e350f97de
getOutputPath
protected Path getOutputPath(String path)
{    return new Path(outputPath, path);}
1aa5f32c6888f0a71c20328afbc879b63bc0725877eed0282011c1eab159d7dc
getInputFile
protected File getInputFile()
{    return inputFile;}
e6310f98e27da652961c31ca1a1752ce49caa91c2245bc0eccfa75cfbe0610ff
getOutputFile
protected File getOutputFile()
{    return outputFile;}
9d6a4f0232aa6c5b31902b86b1714444026d37f0216654cb31cb8a76b0c07f7d
getTempPath
protected Path getTempPath()
{    return tempPath;}
c04aca68af288bdb7f0ea12af9da7066c57dbdbec12e0d6c9de77472ff0b261c
getTempPath
protected Path getTempPath(String directory)
{    return new Path(tempPath, directory);}
d221713f567be6c3a854157b6beb8a5fd5dd64b69c1ef157fb4bac811a41c3f7
getConf
public Configuration getConf()
{    Configuration result = super.getConf();    if (result == null) {        return new Configuration();    }    return result;}
aa1d01f5575d8889abae382155190debcb27a1488be70b4a4234c7d102d24ba5
addFlag
protected void addFlag(String name, String shortName, String description)
{    options.add(buildOption(name, shortName, description, false, false, null));}
e2a8c26a9f8ac629f311f979aacd1c647a846a124400588dc574ab9828a3ea2d
addOption
protected void addOption(String name, String shortName, String description)
{    options.add(buildOption(name, shortName, description, true, false, null));}
b90fed03ecebb70e5fc4bbe3ea2242e080346ef83befdb8ef1fbf4e4b9239644
addOption
protected void addOption(String name, String shortName, String description, boolean required)
{    options.add(buildOption(name, shortName, description, true, required, null));}
f7ac83e386b9f0844280d53989279393ba6aa38994714c2bb9f9bc63de624b65
addOption
protected void addOption(String name, String shortName, String description, String defaultValue)
{    options.add(buildOption(name, shortName, description, true, false, defaultValue));}
2627a10d5a05ee69cbe3558ca4f2bd955df0f36e6661e6b6603d6eab47e47163
addOption
protected Option addOption(Option option)
{    options.add(option);    return option;}
454270ccd3e0f372a30fadd1a4dacd5a23bfc48daec3b971eff624f3a749c63a
getGroup
protected Group getGroup()
{    return group;}
9e118c9fc43bfaa53bb71fad4070706a1b33369ece881b57d9f19f9a136e12b7
addInputOption
protected void addInputOption()
{    this.inputOption = addOption(DefaultOptionCreator.inputOption().create());}
83dbe91c0f019a79d605c809a300febafada140735500b682d1ce3a33e3fbbff
addOutputOption
protected void addOutputOption()
{    this.outputOption = addOption(DefaultOptionCreator.outputOption().create());}
2dd8be411775038490e7bd4bb96069f64e3f4880945b8237a564729283dcc1cb
buildOption
protected static Option buildOption(String name, String shortName, String description, boolean hasArg, boolean required, String defaultValue)
{    return buildOption(name, shortName, description, hasArg, 1, 1, required, defaultValue);}
78d047102e5012853803e043064e70808079d6194f323483998b2fb8943774d3
buildOption
protected static Option buildOption(String name, String shortName, String description, boolean hasArg, int min, int max, boolean required, String defaultValue)
{    DefaultOptionBuilder optBuilder = new DefaultOptionBuilder().withLongName(name).withDescription(description).withRequired(required);    if (shortName != null) {        optBuilder.withShortName(shortName);    }    if (hasArg) {        ArgumentBuilder argBuilder = new ArgumentBuilder().withName(name).withMinimum(min).withMaximum(max);        if (defaultValue != null) {            argBuilder = argBuilder.withDefault(defaultValue);        }        optBuilder.withArgument(argBuilder.create());    }    return optBuilder.create();}
f01090bb32310d861eb614c6eb144d4557765c7b8a2ec8ce8b15f8457548a850
getCLIOption
protected Option getCLIOption(String name)
{    for (Option option : options) {        if (option.getPreferredName().equals(name)) {            return option;        }    }    return null;}
cd8a497fe7832dd175fcba052095c1e349969485d1f53bbfb268ccc1664a1764
parseArguments
public Map<String, List<String>> parseArguments(String[] args) throws IOException
{    return parseArguments(args, false, false);}
28fb658389f83a65939e6cf54b4718cb1c4f15e418bae7f0bc001b5853f6ddd3
parseArguments
public Map<String, List<String>> parseArguments(String[] args, boolean inputOptional, boolean outputOptional) throws IOException
{    Option helpOpt = addOption(DefaultOptionCreator.helpOption());    addOption("tempDir", null, "Intermediate output directory", "temp");    addOption("startPhase", null, "First phase to run", "0");    addOption("endPhase", null, "Last phase to run", String.valueOf(Integer.MAX_VALUE));    GroupBuilder gBuilder = new GroupBuilder().withName("Job-Specific Options:");    for (Option opt : options) {        gBuilder = gBuilder.withOption(opt);    }    group = gBuilder.create();    CommandLine cmdLine;    try {        Parser parser = new Parser();        parser.setGroup(group);        parser.setHelpOption(helpOpt);        cmdLine = parser.parse(args);    } catch (OptionException e) {        log.error(e.getMessage());        CommandLineUtil.printHelpWithGenericOptions(group, e);        return null;    }    if (cmdLine.hasOption(helpOpt)) {        CommandLineUtil.printHelpWithGenericOptions(group);        return null;    }    try {        parseDirectories(cmdLine, inputOptional, outputOptional);    } catch (IllegalArgumentException e) {        log.error(e.getMessage());        CommandLineUtil.printHelpWithGenericOptions(group);        return null;    }    argMap = new TreeMap<>();    maybePut(argMap, cmdLine, this.options.toArray(new Option[this.options.size()]));    this.tempPath = new Path(getOption("tempDir"));    if (!hasOption("quiet")) {        log.info("Command line arguments: {}", argMap);    }    return argMap;}
23a2c1a5427d749d41d19e471bd38871e7f433d20df32b33fdb2fdea3d876d8d
keyFor
public static String keyFor(String optionName)
{    return "--" + optionName;}
5c39d770d454b19cf4993d9a6df5ca0b96fe4b41eed740f2d1faed18590d68c7
getOption
public String getOption(String optionName)
{    List<String> list = argMap.get(keyFor(optionName));    if (list != null && !list.isEmpty()) {        return list.get(0);    }    return null;}
db1a4bc9ac77182d369d8d083588690278884a357414c3034a4de7eeee133bf6
getOption
public String getOption(String optionName, String defaultVal)
{    String res = getOption(optionName);    if (res == null) {        res = defaultVal;    }    return res;}
038fdb733baed8aa5fcf4b05e96645ef1cb2214468ecd125dafb3210315c25db
getInt
public int getInt(String optionName)
{    return Integer.parseInt(getOption(optionName));}
e635ec9d4f640b10c5389b9d896c1f69384cb25be18fb4a4f6dd7daa0fa42439
getInt
public int getInt(String optionName, int defaultVal)
{    return Integer.parseInt(getOption(optionName, String.valueOf(defaultVal)));}
21ce9b6d861d75d7803555e3a7ab1dd638daaf2288ed720b0575c644f16ee5b2
getFloat
public float getFloat(String optionName)
{    return Float.parseFloat(getOption(optionName));}
8d6dc6e053d1c734536f5d88374b63248dfdc90b0b50332fab9a9c8132887b07
getFloat
public float getFloat(String optionName, float defaultVal)
{    return Float.parseFloat(getOption(optionName, String.valueOf(defaultVal)));}
b6099a4087f773d64bc37587bffd87f98673dfced51410a983ecf8f78e6aa864
getOptions
public List<String> getOptions(String optionName)
{    return argMap.get(keyFor(optionName));}
ccc60969906bf50e8e05b4812d48ad65839418b68087fca5b216dc60313ee585
hasOption
public boolean hasOption(String optionName)
{    return argMap.containsKey(keyFor(optionName));}
80c3c07102ef588973b3438706fe8bd4a16f235f67aeb13dfc5fd5b0818618d8
getDimensions
public int getDimensions(Path matrix) throws IOException
{    try (SequenceFile.Reader reader = new SequenceFile.Reader(FileSystem.get(getConf()), matrix, getConf())) {        Writable row = ClassUtils.instantiateAs(reader.getKeyClass().asSubclass(Writable.class), Writable.class);        Preconditions.checkArgument(reader.getValueClass().equals(VectorWritable.class), "value type of sequencefile must be a VectorWritable");        VectorWritable vectorWritable = new VectorWritable();        boolean hasAtLeastOneRow = reader.next(row, vectorWritable);        Preconditions.checkState(hasAtLeastOneRow, "matrix must have at least one row");        return vectorWritable.get().size();    }}
1042900fd388277f91eb29db06434839152ec9628340d100166934ef8f463914
parseDirectories
protected void parseDirectories(CommandLine cmdLine, boolean inputOptional, boolean outputOptional)
{    Configuration conf = getConf();    if (inputOption != null && cmdLine.hasOption(inputOption)) {        this.inputPath = new Path(cmdLine.getValue(inputOption).toString());        this.inputFile = new File(cmdLine.getValue(inputOption).toString());    }    if (inputPath == null && conf.get("mapred.input.dir") != null) {        this.inputPath = new Path(conf.get("mapred.input.dir"));    }    if (outputOption != null && cmdLine.hasOption(outputOption)) {        this.outputPath = new Path(cmdLine.getValue(outputOption).toString());        this.outputFile = new File(cmdLine.getValue(outputOption).toString());    }    if (outputPath == null && conf.get("mapred.output.dir") != null) {        this.outputPath = new Path(conf.get("mapred.output.dir"));    }    Preconditions.checkArgument(inputOptional || inputOption == null || inputPath != null, "No input specified or -Dmapred.input.dir must be provided to specify input directory");    Preconditions.checkArgument(outputOptional || outputOption == null || outputPath != null, "No output specified:  or -Dmapred.output.dir must be provided to specify output directory");}
6c3038f7f3f9c4a3528b9bea58ab098e65631a9d0467348874e26f9d524373c5
maybePut
protected static void maybePut(Map<String, List<String>> args, CommandLine cmdLine, Option... opt)
{    for (Option o : opt) {                if (cmdLine.hasOption(o) || cmdLine.getValue(o) != null || (cmdLine.getValues(o) != null && !cmdLine.getValues(o).isEmpty())) {                        List<?> vo = cmdLine.getValues(o);            if (vo != null && !vo.isEmpty()) {                List<String> vals = new ArrayList<>();                for (Object o1 : vo) {                    vals.add(o1.toString());                }                args.put(o.getPreferredName(), vals);            } else {                args.put(o.getPreferredName(), null);            }        }    }}
24a144beb4ea347e7be7081ed97484c0083ee2e1054e6b9c114d33f61988a9ec
getOption
public static String getOption(Map<String, List<String>> args, String optName)
{    List<String> res = args.get(optName);    if (res != null && !res.isEmpty()) {        return res.get(0);    }    return null;}
50b55b6095f2766538f19151d717515bde99bec027e28d369de3c2e80958a989
shouldRunNextPhase
protected static boolean shouldRunNextPhase(Map<String, List<String>> args, AtomicInteger currentPhase)
{    int phase = currentPhase.getAndIncrement();    String startPhase = getOption(args, "--startPhase");    String endPhase = getOption(args, "--endPhase");    boolean phaseSkipped = (startPhase != null && phase < Integer.parseInt(startPhase)) || (endPhase != null && phase > Integer.parseInt(endPhase));    if (phaseSkipped) {        log.info("Skipping phase {}", phase);    }    return !phaseSkipped;}
98ec1fc5e11b70e7be1957543c277a04249a9f82a7d0e6fb84c066baac3f832c
prepareJob
protected Job prepareJob(Path inputPath, Path outputPath, Class<? extends InputFormat> inputFormat, Class<? extends Mapper> mapper, Class<? extends Writable> mapperKey, Class<? extends Writable> mapperValue, Class<? extends OutputFormat> outputFormat) throws IOException
{    return prepareJob(inputPath, outputPath, inputFormat, mapper, mapperKey, mapperValue, outputFormat, null);}
cf34eb57824fb3d62400ff562e645e285964a1075584fa090f5ae5886b251a8e
prepareJob
protected Job prepareJob(Path inputPath, Path outputPath, Class<? extends InputFormat> inputFormat, Class<? extends Mapper> mapper, Class<? extends Writable> mapperKey, Class<? extends Writable> mapperValue, Class<? extends OutputFormat> outputFormat, String jobname) throws IOException
{    Job job = HadoopUtil.prepareJob(inputPath, outputPath, inputFormat, mapper, mapperKey, mapperValue, outputFormat, getConf());    String name = jobname != null ? jobname : HadoopUtil.getCustomJobName(getClass().getSimpleName(), job, mapper, Reducer.class);    job.setJobName(name);    return job;}
d66240aa02f468dc1052ca00567679281483b6dce758e598c50f42236d34dd1d
prepareJob
protected Job prepareJob(Path inputPath, Path outputPath, Class<? extends Mapper> mapper, Class<? extends Writable> mapperKey, Class<? extends Writable> mapperValue, Class<? extends Reducer> reducer, Class<? extends Writable> reducerKey, Class<? extends Writable> reducerValue) throws IOException
{    return prepareJob(inputPath, outputPath, SequenceFileInputFormat.class, mapper, mapperKey, mapperValue, reducer, reducerKey, reducerValue, SequenceFileOutputFormat.class);}
ea4d660a63474a8b5961c433168689dec3804b9933268632f370d00f0954a590
prepareJob
protected Job prepareJob(Path inputPath, Path outputPath, Class<? extends InputFormat> inputFormat, Class<? extends Mapper> mapper, Class<? extends Writable> mapperKey, Class<? extends Writable> mapperValue, Class<? extends Reducer> reducer, Class<? extends Writable> reducerKey, Class<? extends Writable> reducerValue, Class<? extends OutputFormat> outputFormat) throws IOException
{    Job job = HadoopUtil.prepareJob(inputPath, outputPath, inputFormat, mapper, mapperKey, mapperValue, reducer, reducerKey, reducerValue, outputFormat, getConf());    job.setJobName(HadoopUtil.getCustomJobName(getClass().getSimpleName(), job, mapper, Reducer.class));    return job;}
939a826b7dd9fedb2748c529a89cc212b3a8eb7fa2f0e8cb0fe66ebc1631541a
setS3SafeCombinedInputPath
public static void setS3SafeCombinedInputPath(Job job, Path referencePath, Path inputPathOne, Path inputPathTwo) throws IOException
{    FileSystem fs = FileSystem.get(referencePath.toUri(), job.getConfiguration());    FileInputFormat.setInputPaths(job, inputPathOne.makeQualified(fs), inputPathTwo.makeQualified(fs));}
a75a0fc1e95ccd8a5f8b2406d0c348d82abe0d5d22f9c1621eab58fd2c988165
getAnalyzerClassFromOption
protected Class<? extends Analyzer> getAnalyzerClassFromOption() throws ClassNotFoundException
{    Class<? extends Analyzer> analyzerClass = StandardAnalyzer.class;    if (hasOption(DefaultOptionCreator.ANALYZER_NAME_OPTION)) {        String className = getOption(DefaultOptionCreator.ANALYZER_NAME_OPTION);        analyzerClass = Class.forName(className).asSubclass(Analyzer.class);                                AnalyzerUtils.createAnalyzer(analyzerClass);    }    return analyzerClass;}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    super.setConf(conf);            String oozieActionConfXml = System.getProperty("oozie.action.conf.xml");    if (oozieActionConfXml != null && conf != null) {        conf.addResource(new Path("file:///", oozieActionConfXml));        log.info("Added Oozie action Configuration resource {} to the Hadoop Configuration", oozieActionConfXml);    }}
5a174026e2e72b50bd3a7f7247f5682488ffd431db929c23054975c751f9bbf3
instantiateAs
public static T instantiateAs(String classname, Class<T> asSubclassOfClass)
{    try {        return instantiateAs(Class.forName(classname).asSubclass(asSubclassOfClass), asSubclassOfClass);    } catch (ClassNotFoundException e) {        throw new IllegalStateException(e);    }}
3a2f6724d792af5362fd9d75116eed469cf089d6d509eaf8bba7a0a5209dca9c
instantiateAs
public static T instantiateAs(String classname, Class<T> asSubclassOfClass, Class<?>[] params, Object[] args)
{    try {        return instantiateAs(Class.forName(classname).asSubclass(asSubclassOfClass), asSubclassOfClass, params, args);    } catch (ClassNotFoundException e) {        throw new IllegalStateException(e);    }}
822e18b8d7e4d264e07b424c9d2f06c76880edc30b6daaf59b4236d32b5aa168
instantiateAs
public static T instantiateAs(Class<? extends T> clazz, Class<T> asSubclassOfClass, Class<?>[] params, Object[] args)
{    try {        return clazz.asSubclass(asSubclassOfClass).getConstructor(params).newInstance(args);    } catch (InstantiationException | IllegalAccessException | NoSuchMethodException | InvocationTargetException ie) {        throw new IllegalStateException(ie);    }}
5a0ced2e27a944b528ec613260ea3a5fa7e8df7d59bafa60b0a28c9d55583e97
instantiateAs
public static T instantiateAs(Class<? extends T> clazz, Class<T> asSubclassOfClass)
{    try {        return clazz.asSubclass(asSubclassOfClass).getConstructor().newInstance();    } catch (InstantiationException | IllegalAccessException | NoSuchMethodException | InvocationTargetException ie) {        throw new IllegalStateException(ie);    }}
592e06b4ab3beaac45c2f8fc58f27b147be55a13526583384e700beaf003c5a7
helpOption
public static Option helpOption()
{    return new DefaultOptionBuilder().withLongName("help").withDescription("Print out help").withShortName("h").create();}
ea211dc1e93af38a19ba919c0cedc2dc3fb99512bf117b249b529810b957c2cf
inputOption
public static DefaultOptionBuilder inputOption()
{    return new DefaultOptionBuilder().withLongName(INPUT_OPTION).withRequired(false).withShortName("i").withArgument(new ArgumentBuilder().withName(INPUT_OPTION).withMinimum(1).withMaximum(1).create()).withDescription("Path to job input directory.");}
8dea386add0ea622a802040a010de320705f63d8ad5f724aa3fbfd9df84f116a
clustersInOption
public static DefaultOptionBuilder clustersInOption()
{    return new DefaultOptionBuilder().withLongName(CLUSTERS_IN_OPTION).withRequired(true).withArgument(new ArgumentBuilder().withName(CLUSTERS_IN_OPTION).withMinimum(1).withMaximum(1).create()).withDescription("The path to the initial clusters directory. Must be a SequenceFile of some type of Cluster").withShortName("c");}
c2fac083ddb209354d0509ae6967039c825a4e85a8a4a9af406496c2a7a67800
outputOption
public static DefaultOptionBuilder outputOption()
{    return new DefaultOptionBuilder().withLongName(OUTPUT_OPTION).withRequired(false).withShortName("o").withArgument(new ArgumentBuilder().withName(OUTPUT_OPTION).withMinimum(1).withMaximum(1).create()).withDescription("The directory pathname for output.");}
b15c04339d6c72e0d28280ab5ca01ab9ed1872b2acfa3aa97b734f2dcc97b1ea
overwriteOption
public static DefaultOptionBuilder overwriteOption()
{    return new DefaultOptionBuilder().withLongName(OVERWRITE_OPTION).withRequired(false).withDescription("If present, overwrite the output directory before running job").withShortName("ow");}
6de34fb0895a14a06e72a4090f605864e6db904c18cd5e84ec4185daff417e9f
distanceMeasureOption
public static DefaultOptionBuilder distanceMeasureOption()
{    return new DefaultOptionBuilder().withLongName(DISTANCE_MEASURE_OPTION).withRequired(false).withShortName("dm").withArgument(new ArgumentBuilder().withName(DISTANCE_MEASURE_OPTION).withDefault(SquaredEuclideanDistanceMeasure.class.getName()).withMinimum(1).withMaximum(1).create()).withDescription("The classname of the DistanceMeasure. Default is SquaredEuclidean");}
1c37c1f1ce928903222f4a19e8449ffcb293ee81bee1a7fedaf05dc059cbb5f0
methodOption
public static DefaultOptionBuilder methodOption()
{    return new DefaultOptionBuilder().withLongName(METHOD_OPTION).withRequired(false).withShortName("xm").withArgument(new ArgumentBuilder().withName(METHOD_OPTION).withDefault(MAPREDUCE_METHOD).withMinimum(1).withMaximum(1).create()).withDescription("The execution method to use: sequential or mapreduce. Default is mapreduce");}
54590a4966d066c07ad036cde9f8a4ccd8e378856d904f00efdf5051080129f5
t1Option
public static DefaultOptionBuilder t1Option()
{    return new DefaultOptionBuilder().withLongName(T1_OPTION).withRequired(true).withArgument(new ArgumentBuilder().withName(T1_OPTION).withMinimum(1).withMaximum(1).create()).withDescription("T1 threshold value").withShortName(T1_OPTION);}
e0dee86067d5f524ab391a1529a81f9b8b452dd671a6101beb783303f81e5251
t2Option
public static DefaultOptionBuilder t2Option()
{    return new DefaultOptionBuilder().withLongName(T2_OPTION).withRequired(true).withArgument(new ArgumentBuilder().withName(T2_OPTION).withMinimum(1).withMaximum(1).create()).withDescription("T2 threshold value").withShortName(T2_OPTION);}
84dc258feeb1eb2193631c705045ca798383150566e7b3a51e19ce440a791ecd
t3Option
public static DefaultOptionBuilder t3Option()
{    return new DefaultOptionBuilder().withLongName(T3_OPTION).withRequired(false).withArgument(new ArgumentBuilder().withName(T3_OPTION).withMinimum(1).withMaximum(1).create()).withDescription("T3 (Reducer T1) threshold value").withShortName(T3_OPTION);}
5eb192bb2b57e0481f614fe1fccb697db3c0aeb2eefc63f5076ce5ad66f448ac
t4Option
public static DefaultOptionBuilder t4Option()
{    return new DefaultOptionBuilder().withLongName(T4_OPTION).withRequired(false).withArgument(new ArgumentBuilder().withName(T4_OPTION).withMinimum(1).withMaximum(1).create()).withDescription("T4 (Reducer T2) threshold value").withShortName(T4_OPTION);}
db0bb642efdde9ec58594ce5fda537d1ae47ebc439988d45d4406161a658825a
clusterFilterOption
public static DefaultOptionBuilder clusterFilterOption()
{    return new DefaultOptionBuilder().withLongName(CLUSTER_FILTER_OPTION).withShortName("cf").withRequired(false).withArgument(new ArgumentBuilder().withName(CLUSTER_FILTER_OPTION).withMinimum(1).withMaximum(1).create()).withDescription("Cluster filter suppresses small canopies from mapper").withShortName(CLUSTER_FILTER_OPTION);}
7572d09482543df6a43f7d30c336e7979ec95c8e251c8984f0d9c1a98cb39e95
maxIterationsOption
public static DefaultOptionBuilder maxIterationsOption()
{        return new DefaultOptionBuilder().withLongName(MAX_ITERATIONS_OPTION).withRequired(true).withShortName("x").withArgument(new ArgumentBuilder().withName(MAX_ITERATIONS_OPTION).withDefault("-1").withMinimum(1).withMaximum(1).create()).withDescription("The maximum number of iterations.");}
d7bb3f1865f951e403d59c55b0b5ea22b310422560ea4e79e0adde05a44cbb25
numClustersOption
public static DefaultOptionBuilder numClustersOption()
{    return new DefaultOptionBuilder().withLongName(NUM_CLUSTERS_OPTION).withRequired(false).withArgument(new ArgumentBuilder().withName("k").withMinimum(1).withMaximum(1).create()).withDescription("The number of clusters to create").withShortName("k");}
00e87514932e6f0078480d450c2167bd34c4588a05fc5c696ff02292c2711dcd
useSetRandomSeedOption
public static DefaultOptionBuilder useSetRandomSeedOption()
{    return new DefaultOptionBuilder().withLongName(RANDOM_SEED).withRequired(false).withArgument(new ArgumentBuilder().withName(RANDOM_SEED).create()).withDescription("Seed to initaize Random Number Generator with").withShortName("rs");}
e101bafdffe6fedc1b8fcb69ea1f85348884a0e8c2e4f49ae6d5d10118378d09
convergenceOption
public static DefaultOptionBuilder convergenceOption()
{    return new DefaultOptionBuilder().withLongName(CONVERGENCE_DELTA_OPTION).withRequired(false).withShortName("cd").withArgument(new ArgumentBuilder().withName(CONVERGENCE_DELTA_OPTION).withDefault("0.5").withMinimum(1).withMaximum(1).create()).withDescription("The convergence delta value. Default is 0.5");}
f524ecfc4bff4fae2d7edb92dd99c455f6ed3b1608c760a9268046a7bf892d6e
numReducersOption
public static DefaultOptionBuilder numReducersOption()
{    return new DefaultOptionBuilder().withLongName(MAX_REDUCERS_OPTION).withRequired(false).withShortName("r").withArgument(new ArgumentBuilder().withName(MAX_REDUCERS_OPTION).withDefault("2").withMinimum(1).withMaximum(1).create()).withDescription("The number of reduce tasks. Defaults to 2");}
05d813b20637b043def5b1a574703e0c59d4cc13c4265025e4ec860a58daa95f
clusteringOption
public static DefaultOptionBuilder clusteringOption()
{    return new DefaultOptionBuilder().withLongName(CLUSTERING_OPTION).withRequired(false).withDescription("If present, run clustering after the iterations have taken place").withShortName("cl");}
bda2960d0aad3d60f802da3514ad8d426d38636e8879c6773c72040015c9559a
analyzerOption
public static DefaultOptionBuilder analyzerOption()
{    return new DefaultOptionBuilder().withLongName(ANALYZER_NAME_OPTION).withRequired(false).withDescription("If present, the name of a Lucene analyzer class to use").withArgument(new ArgumentBuilder().withName(ANALYZER_NAME_OPTION).withDefault(StandardAnalyzer.class.getName()).withMinimum(1).withMaximum(1).create()).withShortName("an");}
fd141192f97e197c2597081306205824d70e81bae5ee1523cdbe39ae3d3d0115
emitMostLikelyOption
public static DefaultOptionBuilder emitMostLikelyOption()
{    return new DefaultOptionBuilder().withLongName(EMIT_MOST_LIKELY_OPTION).withRequired(false).withShortName("e").withArgument(new ArgumentBuilder().withName(EMIT_MOST_LIKELY_OPTION).withDefault("true").withMinimum(1).withMaximum(1).create()).withDescription("True if clustering should emit the most likely point only, " + "false for threshold clustering. Default is true");}
5c8934eca49e5a4743b55b5807e17df2b2918226b0e41eb4f4d2c595d535a0da
thresholdOption
public static DefaultOptionBuilder thresholdOption()
{    return new DefaultOptionBuilder().withLongName(THRESHOLD_OPTION).withRequired(false).withShortName("t").withArgument(new ArgumentBuilder().withName(THRESHOLD_OPTION).withDefault("0").withMinimum(1).withMaximum(1).create()).withDescription("The pdf threshold used for cluster determination. Default is 0");}
50bdb856babce602f38a7a30bf9180a80cec01f8d33b146934f31f5286c29d88
kernelProfileOption
public static DefaultOptionBuilder kernelProfileOption()
{    return new DefaultOptionBuilder().withLongName(KERNEL_PROFILE_OPTION).withRequired(false).withShortName("kp").withArgument(new ArgumentBuilder().withName(KERNEL_PROFILE_OPTION).withDefault(TriangularKernelProfile.class.getName()).withMinimum(1).withMaximum(1).create()).withDescription("The classname of the IKernelProfile. Default is TriangularKernelProfile");}
1a8ffffa70dd80f8ababae9ef29413d5c7b479c847f4f8d3bf23fdee8acba6a9
outlierThresholdOption
public static DefaultOptionBuilder outlierThresholdOption()
{    return new DefaultOptionBuilder().withLongName(OUTLIER_THRESHOLD).withRequired(false).withArgument(new ArgumentBuilder().withName(OUTLIER_THRESHOLD).withMinimum(1).withMaximum(1).create()).withDescription("Outlier threshold value").withShortName(OUTLIER_THRESHOLD);}
07b50559c1103628ad32462e209906197e3dc64d82f32c2a13e00ebb3d13a8e6
printHelp
public static void printHelp(Group group)
{    HelpFormatter formatter = new HelpFormatter();    formatter.setGroup(group);    formatter.print();}
95ad256119e556c0f0e1f078a1d3a27bab476a112e84951e95068fd1f148225e
printHelpWithGenericOptions
public static void printHelpWithGenericOptions(Group group) throws IOException
{    new GenericOptionsParser(new Configuration(), new org.apache.commons.cli.Options(), new String[0]);    PrintWriter pw = new PrintWriter(new OutputStreamWriter(System.out, Charsets.UTF_8), true);    HelpFormatter formatter = new HelpFormatter();    formatter.setGroup(group);    formatter.setPrintWriter(pw);    formatter.setFooter("Specify HDFS directories while running on hadoop; else specify local file system directories");    formatter.print();}
10d23119002bae84d834bc6ff87be538b5b63556aaea716ba6fa0159f75460cf
printHelpWithGenericOptions
public static void printHelpWithGenericOptions(Group group, OptionException oe) throws IOException
{    new GenericOptionsParser(new Configuration(), new org.apache.commons.cli.Options(), new String[0]);    PrintWriter pw = new PrintWriter(new OutputStreamWriter(System.out, Charsets.UTF_8), true);    HelpFormatter formatter = new HelpFormatter();    formatter.setGroup(group);    formatter.setPrintWriter(pw);    formatter.setException(oe);    formatter.print();}
80f20350a1168909a108171da475cb3d54a531b17708e3f7547288d058148699
configure
public void configure(Configuration job)
{}
a0a1e1740dfa61e3f51aef2d90597a3361d76f17552801f754e73a715f418b2c
getParameters
public Collection<Parameter<?>> getParameters()
{    return Collections.emptyList();}
7205b9fdd8de7b3ade6cb7bd7db44a76f1bb73df3db453299e8820273cdc140b
createParameters
public void createParameters(String prefix, Configuration jobConf)
{}
77e250c197c19cf12448bec6f4dfd3ba4b6a7e895f324625890957c6312929a1
distance
public double distance(Vector v1, Vector v2)
{    if (v1.size() != v2.size()) {        throw new CardinalityException(v1.size(), v2.size());    }    return v1.aggregate(v2, Functions.MAX_ABS, Functions.MINUS);}
b15c1a48745d1686a8de4201a1cc9a1bda9951b1707b71eb25ccd488c9fa10fc
distance
public double distance(double centroidLengthSquare, Vector centroid, Vector v)
{        return distance(centroid, v);}
80f20350a1168909a108171da475cb3d54a531b17708e3f7547288d058148699
configure
public void configure(Configuration job)
{}
a0a1e1740dfa61e3f51aef2d90597a3361d76f17552801f754e73a715f418b2c
getParameters
public Collection<Parameter<?>> getParameters()
{    return Collections.emptyList();}
7205b9fdd8de7b3ade6cb7bd7db44a76f1bb73df3db453299e8820273cdc140b
createParameters
public void createParameters(String prefix, Configuration jobConf)
{}
8f6ad115c260878d026884e21f046df8445a5fa68e1318ac96e4b0ea20d25177
distance
public static double distance(double[] p1, double[] p2)
{    double dotProduct = 0.0;    double lengthSquaredp1 = 0.0;    double lengthSquaredp2 = 0.0;    for (int i = 0; i < p1.length; i++) {        lengthSquaredp1 += p1[i] * p1[i];        lengthSquaredp2 += p2[i] * p2[i];        dotProduct += p1[i] * p2[i];    }    double denominator = Math.sqrt(lengthSquaredp1) * Math.sqrt(lengthSquaredp2);        if (denominator < dotProduct) {        denominator = dotProduct;    }        if (denominator == 0 && dotProduct == 0) {        return 0;    }    return 1.0 - dotProduct / denominator;}
77e250c197c19cf12448bec6f4dfd3ba4b6a7e895f324625890957c6312929a1
distance
public double distance(Vector v1, Vector v2)
{    if (v1.size() != v2.size()) {        throw new CardinalityException(v1.size(), v2.size());    }    double lengthSquaredv1 = v1.getLengthSquared();    double lengthSquaredv2 = v2.getLengthSquared();    double dotProduct = v2.dot(v1);    double denominator = Math.sqrt(lengthSquaredv1) * Math.sqrt(lengthSquaredv2);        if (denominator < dotProduct) {        denominator = dotProduct;    }        if (denominator == 0 && dotProduct == 0) {        return 0;    }    return 1.0 - dotProduct / denominator;}
b15c1a48745d1686a8de4201a1cc9a1bda9951b1707b71eb25ccd488c9fa10fc
distance
public double distance(double centroidLengthSquare, Vector centroid, Vector v)
{    double lengthSquaredv = v.getLengthSquared();    double dotProduct = v.dot(centroid);    double denominator = Math.sqrt(centroidLengthSquare) * Math.sqrt(lengthSquaredv);        if (denominator < dotProduct) {        denominator = dotProduct;    }        if (denominator == 0 && dotProduct == 0) {        return 0;    }    return 1.0 - dotProduct / denominator;}
77e250c197c19cf12448bec6f4dfd3ba4b6a7e895f324625890957c6312929a1
distance
public double distance(Vector v1, Vector v2)
{    return Math.sqrt(super.distance(v1, v2));}
b15c1a48745d1686a8de4201a1cc9a1bda9951b1707b71eb25ccd488c9fa10fc
distance
public double distance(double centroidLengthSquare, Vector centroid, Vector v)
{    return Math.sqrt(super.distance(centroidLengthSquare, centroid, v));}
b8280aa7c29098a08a0735a6877e811a2537eddeb6a8db97392f994e2411326b
configure
public void configure(Configuration jobConf)
{    if (parameters == null) {        ParameteredGeneralizations.configureParameters(this, jobConf);    }    try {        if (inverseCovarianceFile.get() != null) {            FileSystem fs = FileSystem.get(inverseCovarianceFile.get().toUri(), jobConf);            MatrixWritable inverseCovarianceMatrix = ClassUtils.instantiateAs((Class<? extends MatrixWritable>) matrixClass.get(), MatrixWritable.class);            if (!fs.exists(inverseCovarianceFile.get())) {                throw new FileNotFoundException(inverseCovarianceFile.get().toString());            }            try (DataInputStream in = fs.open(inverseCovarianceFile.get())) {                inverseCovarianceMatrix.readFields(in);            }            this.inverseCovarianceMatrix = inverseCovarianceMatrix.get();            Preconditions.checkArgument(this.inverseCovarianceMatrix != null, "inverseCovarianceMatrix not initialized");        }        if (meanVectorFile.get() != null) {            FileSystem fs = FileSystem.get(meanVectorFile.get().toUri(), jobConf);            VectorWritable meanVector = ClassUtils.instantiateAs((Class<? extends VectorWritable>) vectorClass.get(), VectorWritable.class);            if (!fs.exists(meanVectorFile.get())) {                throw new FileNotFoundException(meanVectorFile.get().toString());            }            try (DataInputStream in = fs.open(meanVectorFile.get())) {                meanVector.readFields(in);            }            this.meanVector = meanVector.get();            Preconditions.checkArgument(this.meanVector != null, "meanVector not initialized");        }    } catch (IOException e) {        throw new IllegalStateException(e);    }}
a0a1e1740dfa61e3f51aef2d90597a3361d76f17552801f754e73a715f418b2c
getParameters
public Collection<Parameter<?>> getParameters()
{    return parameters;}
7205b9fdd8de7b3ade6cb7bd7db44a76f1bb73df3db453299e8820273cdc140b
createParameters
public void createParameters(String prefix, Configuration jobConf)
{    parameters = new ArrayList<>();    inverseCovarianceFile = new PathParameter(prefix, "inverseCovarianceFile", jobConf, null, "Path on DFS to a file containing the inverse covariance matrix.");    parameters.add(inverseCovarianceFile);    matrixClass = new ClassParameter(prefix, "maxtrixClass", jobConf, DenseMatrix.class, "Class<Matix> file specified in parameter inverseCovarianceFile has been serialized with.");    parameters.add(matrixClass);    meanVectorFile = new PathParameter(prefix, "meanVectorFile", jobConf, null, "Path on DFS to a file containing the mean Vector.");    parameters.add(meanVectorFile);    vectorClass = new ClassParameter(prefix, "vectorClass", jobConf, DenseVector.class, "Class file specified in parameter meanVectorFile has been serialized with.");    parameters.add(vectorClass);}
332ae02671f0efc07518142db368f8693aed722c2765e85f2a16fe435e3a89ad
distance
public double distance(Vector v)
{    return Math.sqrt(v.minus(meanVector).dot(Algebra.mult(inverseCovarianceMatrix, v.minus(meanVector))));}
77e250c197c19cf12448bec6f4dfd3ba4b6a7e895f324625890957c6312929a1
distance
public double distance(Vector v1, Vector v2)
{    if (v1.size() != v2.size()) {        throw new CardinalityException(v1.size(), v2.size());    }    return Math.sqrt(v1.minus(v2).dot(Algebra.mult(inverseCovarianceMatrix, v1.minus(v2))));}
b15c1a48745d1686a8de4201a1cc9a1bda9951b1707b71eb25ccd488c9fa10fc
distance
public double distance(double centroidLengthSquare, Vector centroid, Vector v)
{        return distance(centroid, v);}
6a8ada94c39fd26040594cbe2743bf584d753249966ad985cb4d6486592a0aed
setInverseCovarianceMatrix
public void setInverseCovarianceMatrix(Matrix inverseCovarianceMatrix)
{    Preconditions.checkArgument(inverseCovarianceMatrix != null, "inverseCovarianceMatrix not initialized");    this.inverseCovarianceMatrix = inverseCovarianceMatrix;}
19774e0218d93e5f9e7b3b0ba7007b0393db2e9843b7676a8b3aa7a9652d39f7
setCovarianceMatrix
public void setCovarianceMatrix(Matrix m)
{    if (m.numRows() != m.numCols()) {        throw new CardinalityException(m.numRows(), m.numCols());    }                SingularValueDecomposition svd = new SingularValueDecomposition(m);    Matrix sInv = svd.getS();        for (int i = 0; i < sInv.numRows(); i++) {        double diagElem = sInv.get(i, i);        if (diagElem > 0.0) {            sInv.set(i, i, 1 / diagElem);        } else {            throw new IllegalStateException("Eigen Value equals to 0 found.");        }    }    inverseCovarianceMatrix = svd.getU().times(sInv.times(svd.getU().transpose()));    Preconditions.checkArgument(inverseCovarianceMatrix != null, "inverseCovarianceMatrix not initialized");}
2b424950d7c84e8c47f24006201a36ca0c165d1c428970d72bae6965dff7ae6b
getInverseCovarianceMatrix
public Matrix getInverseCovarianceMatrix()
{    return inverseCovarianceMatrix;}
8a372cce815cd05e5194dc9825e451a147ddc83d5b85a3c3175e54dac1b902f6
setMeanVector
public void setMeanVector(Vector meanVector)
{    Preconditions.checkArgument(meanVector != null, "meanVector not initialized");    this.meanVector = meanVector;}
c30b87ed251988781c7c6f55f0005b80448d61963b21e82c8862c931fd236d76
getMeanVector
public Vector getMeanVector()
{    return meanVector;}
8f6ad115c260878d026884e21f046df8445a5fa68e1318ac96e4b0ea20d25177
distance
public static double distance(double[] p1, double[] p2)
{    double result = 0.0;    for (int i = 0; i < p1.length; i++) {        result += Math.abs(p2[i] - p1[i]);    }    return result;}
80f20350a1168909a108171da475cb3d54a531b17708e3f7547288d058148699
configure
public void configure(Configuration job)
{}
a0a1e1740dfa61e3f51aef2d90597a3361d76f17552801f754e73a715f418b2c
getParameters
public Collection<Parameter<?>> getParameters()
{    return Collections.emptyList();}
7205b9fdd8de7b3ade6cb7bd7db44a76f1bb73df3db453299e8820273cdc140b
createParameters
public void createParameters(String prefix, Configuration jobConf)
{}
77e250c197c19cf12448bec6f4dfd3ba4b6a7e895f324625890957c6312929a1
distance
public double distance(Vector v1, Vector v2)
{    if (v1.size() != v2.size()) {        throw new CardinalityException(v1.size(), v2.size());    }    return v1.aggregate(v2, Functions.PLUS, Functions.MINUS_ABS);}
b15c1a48745d1686a8de4201a1cc9a1bda9951b1707b71eb25ccd488c9fa10fc
distance
public double distance(double centroidLengthSquare, Vector centroid, Vector v)
{        return distance(centroid, v);}
5853ff79edcfa9b39339e7f62ecc43792678f04267d89127fb2b84a89095d525
createParameters
public void createParameters(String prefix, Configuration conf)
{    parameters = new ArrayList<>();    Parameter<?> param = new DoubleParameter(prefix, "exponent", conf, EXPONENT, "Exponent for Fractional Lagrange distance");    parameters.add(param);}
a0a1e1740dfa61e3f51aef2d90597a3361d76f17552801f754e73a715f418b2c
getParameters
public Collection<Parameter<?>> getParameters()
{    return parameters;}
b8280aa7c29098a08a0735a6877e811a2537eddeb6a8db97392f994e2411326b
configure
public void configure(Configuration jobConf)
{    if (parameters == null) {        ParameteredGeneralizations.configureParameters(this, jobConf);    }}
5c35c19d20526e00c705a3158f13881802968f93e6e56540c54600be8ae62052
getExponent
public double getExponent()
{    return exponent;}
c2b934a19ce0e18fc0aa99e96f35ab4272bb402bbd3a88b8c43b8231b8c641be
setExponent
public void setExponent(double exponent)
{    this.exponent = exponent;}
77e250c197c19cf12448bec6f4dfd3ba4b6a7e895f324625890957c6312929a1
distance
public double distance(Vector v1, Vector v2)
{    return Math.pow(v1.aggregate(v2, Functions.PLUS, Functions.minusAbsPow(exponent)), 1.0 / exponent);}
b15c1a48745d1686a8de4201a1cc9a1bda9951b1707b71eb25ccd488c9fa10fc
distance
public double distance(double centroidLengthSquare, Vector centroid, Vector v)
{        return distance(centroid, v);}
80f20350a1168909a108171da475cb3d54a531b17708e3f7547288d058148699
configure
public void configure(Configuration job)
{}
a0a1e1740dfa61e3f51aef2d90597a3361d76f17552801f754e73a715f418b2c
getParameters
public Collection<Parameter<?>> getParameters()
{    return Collections.emptyList();}
7205b9fdd8de7b3ade6cb7bd7db44a76f1bb73df3db453299e8820273cdc140b
createParameters
public void createParameters(String prefix, Configuration jobConf)
{}
77e250c197c19cf12448bec6f4dfd3ba4b6a7e895f324625890957c6312929a1
distance
public double distance(Vector v1, Vector v2)
{    return v2.getDistanceSquared(v1);}
b15c1a48745d1686a8de4201a1cc9a1bda9951b1707b71eb25ccd488c9fa10fc
distance
public double distance(double centroidLengthSquare, Vector centroid, Vector v)
{    return centroidLengthSquare - 2 * v.dot(centroid) + v.getLengthSquared();}
24bc7708d5c3e0a1183432c997e91c8b48cbb7e1e1c3bf46535b4de284dfe85b
distance
public double distance(Vector a, Vector b)
{    double ab;    double denominator;    if (getWeights() != null) {        ab = a.times(b).aggregate(getWeights(), Functions.PLUS, Functions.MULT);        denominator = a.aggregate(getWeights(), Functions.PLUS, Functions.MULT_SQUARE_LEFT) + b.aggregate(getWeights(), Functions.PLUS, Functions.MULT_SQUARE_LEFT) - ab;    } else {                ab = b.dot(a);        denominator = a.getLengthSquared() + b.getLengthSquared() - ab;    }    if (denominator < ab) {                denominator = ab;    }    if (denominator > 0) {                return 1.0 - ab / denominator;    } else {        return 0.0;    }}
b15c1a48745d1686a8de4201a1cc9a1bda9951b1707b71eb25ccd488c9fa10fc
distance
public double distance(double centroidLengthSquare, Vector centroid, Vector v)
{        return distance(centroid, v);}
7205b9fdd8de7b3ade6cb7bd7db44a76f1bb73df3db453299e8820273cdc140b
createParameters
public void createParameters(String prefix, Configuration jobConf)
{    parameters = new ArrayList<>();    weightsFile = new PathParameter(prefix, "weightsFile", jobConf, null, "Path on DFS to a file containing the weights.");    parameters.add(weightsFile);    vectorClass = new ClassParameter(prefix, "vectorClass", jobConf, DenseVector.class, "Class<Vector> file specified in parameter weightsFile has been serialized with.");    parameters.add(vectorClass);}
a0a1e1740dfa61e3f51aef2d90597a3361d76f17552801f754e73a715f418b2c
getParameters
public Collection<Parameter<?>> getParameters()
{    return parameters;}
b8280aa7c29098a08a0735a6877e811a2537eddeb6a8db97392f994e2411326b
configure
public void configure(Configuration jobConf)
{    if (parameters == null) {        ParameteredGeneralizations.configureParameters(this, jobConf);    }    try {        if (weightsFile.get() != null) {            FileSystem fs = FileSystem.get(weightsFile.get().toUri(), jobConf);            VectorWritable weights = ClassUtils.instantiateAs((Class<? extends VectorWritable>) vectorClass.get(), VectorWritable.class);            if (!fs.exists(weightsFile.get())) {                throw new FileNotFoundException(weightsFile.get().toString());            }            try (DataInputStream in = fs.open(weightsFile.get())) {                weights.readFields(in);            }            this.weights = weights.get();        }    } catch (IOException e) {        throw new IllegalStateException(e);    }}
2f1ffca5b77b8215a384ba8d5cf5a3e20748ecbbd93c46097b5ae8102b845932
getWeights
public Vector getWeights()
{    return weights;}
0912274b34a613c6d826e921c68273f8307fcd699de13c684389f3457f43234d
setWeights
public void setWeights(Vector weights)
{    this.weights = weights;}
c772d2145c20c92f4cc470648c8809042ccf40efbac79dcfe3301cd29ff639a1
distance
public double distance(Vector p1, Vector p2)
{    double result = 0;    Vector res = p2.minus(p1);    Vector theWeights = getWeights();    if (theWeights == null) {        for (Element elt : res.nonZeroes()) {            result += elt.get() * elt.get();        }    } else {        for (Element elt : res.nonZeroes()) {            result += elt.get() * elt.get() * theWeights.get(elt.index());        }    }    return Math.sqrt(result);}
b15c1a48745d1686a8de4201a1cc9a1bda9951b1707b71eb25ccd488c9fa10fc
distance
public double distance(double centroidLengthSquare, Vector centroid, Vector v)
{        return distance(centroid, v);}
c772d2145c20c92f4cc470648c8809042ccf40efbac79dcfe3301cd29ff639a1
distance
public double distance(Vector p1, Vector p2)
{    double result = 0;    Vector res = p2.minus(p1);    if (getWeights() == null) {        for (Element elt : res.nonZeroes()) {            result += Math.abs(elt.get());        }    } else {        for (Element elt : res.nonZeroes()) {            result += Math.abs(elt.get() * getWeights().get(elt.index()));        }    }    return result;}
b15c1a48745d1686a8de4201a1cc9a1bda9951b1707b71eb25ccd488c9fa10fc
distance
public double distance(double centroidLengthSquare, Vector centroid, Vector v)
{        return distance(centroid, v);}
f4a78a9ad21200cb8bb3c284009c3648b165e7c2ce53c0870ca0126c4ae41aae
prepareJob
public static Job prepareJob(Path inputPath, Path outputPath, Class<? extends InputFormat> inputFormat, Class<? extends Mapper> mapper, Class<? extends Writable> mapperKey, Class<? extends Writable> mapperValue, Class<? extends OutputFormat> outputFormat, Configuration conf) throws IOException
{    Job job = new Job(new Configuration(conf));    Configuration jobConf = job.getConfiguration();    if (mapper.equals(Mapper.class)) {        throw new IllegalStateException("Can't figure out the user class jar file from mapper/reducer");    }    job.setJarByClass(mapper);    job.setInputFormatClass(inputFormat);    jobConf.set("mapred.input.dir", inputPath.toString());    job.setMapperClass(mapper);    job.setMapOutputKeyClass(mapperKey);    job.setMapOutputValueClass(mapperValue);    job.setOutputKeyClass(mapperKey);    job.setOutputValueClass(mapperValue);    jobConf.setBoolean("mapred.compress.map.output", true);    job.setNumReduceTasks(0);    job.setOutputFormatClass(outputFormat);    jobConf.set("mapred.output.dir", outputPath.toString());    return job;}
c3cfff60a093e0c01e6ea3e82b3e1885b476a81ce24ce25545d216b378718867
prepareJob
public static Job prepareJob(Path inputPath, Path outputPath, Class<? extends InputFormat> inputFormat, Class<? extends Mapper> mapper, Class<? extends Writable> mapperKey, Class<? extends Writable> mapperValue, Class<? extends Reducer> reducer, Class<? extends Writable> reducerKey, Class<? extends Writable> reducerValue, Class<? extends OutputFormat> outputFormat, Configuration conf) throws IOException
{    Job job = new Job(new Configuration(conf));    Configuration jobConf = job.getConfiguration();    if (reducer.equals(Reducer.class)) {        if (mapper.equals(Mapper.class)) {            throw new IllegalStateException("Can't figure out the user class jar file from mapper/reducer");        }        job.setJarByClass(mapper);    } else {        job.setJarByClass(reducer);    }    job.setInputFormatClass(inputFormat);    jobConf.set("mapred.input.dir", inputPath.toString());    job.setMapperClass(mapper);    if (mapperKey != null) {        job.setMapOutputKeyClass(mapperKey);    }    if (mapperValue != null) {        job.setMapOutputValueClass(mapperValue);    }    jobConf.setBoolean("mapred.compress.map.output", true);    job.setReducerClass(reducer);    job.setOutputKeyClass(reducerKey);    job.setOutputValueClass(reducerValue);    job.setOutputFormatClass(outputFormat);    jobConf.set("mapred.output.dir", outputPath.toString());    return job;}
fd742f5ac754acf6771fc858078a7dfc016d49287952683796aaf099cc4f0d2e
getCustomJobName
public static String getCustomJobName(String className, JobContext job, Class<? extends Mapper> mapper, Class<? extends Reducer> reducer)
{    StringBuilder name = new StringBuilder(100);    String customJobName = job.getJobName();    if (customJobName == null || customJobName.trim().isEmpty()) {        name.append(className);    } else {        name.append(customJobName);    }    name.append('-').append(mapper.getSimpleName());    name.append('-').append(reducer.getSimpleName());    return name.toString();}
f9b152d33c6d007ab10cc5dad67ee71daa74064a83509e5098d69dcacaef2c95
delete
public static void delete(Configuration conf, Iterable<Path> paths) throws IOException
{    if (conf == null) {        conf = new Configuration();    }    for (Path path : paths) {        FileSystem fs = path.getFileSystem(conf);        if (fs.exists(path)) {            log.info("Deleting {}", path);            fs.delete(path, true);        }    }}
f7918cb4c2b993202d9b86e3924a4631ccf9f1f421defca1d6f46d36ba5ea07f
delete
public static void delete(Configuration conf, Path... paths) throws IOException
{    delete(conf, Arrays.asList(paths));}
6e54c5a8703542b0df40c394d2cac9122ce3bb56d9e310116e041bed194e477f
countRecords
public static long countRecords(Path path, Configuration conf) throws IOException
{    long count = 0;    Iterator<?> iterator = new SequenceFileValueIterator<>(path, true, conf);    while (iterator.hasNext()) {        iterator.next();        count++;    }    return count;}
885ded06f7d2b925942df17ff59999a753e1bd4e477bcba236b8f6db205185d0
countRecords
public static long countRecords(Path path, PathType pt, PathFilter filter, Configuration conf) throws IOException
{    long count = 0;    Iterator<?> iterator = new SequenceFileDirValueIterator<>(path, pt, filter, null, true, conf);    while (iterator.hasNext()) {        iterator.next();        count++;    }    return count;}
1b2dba39106ea878151e7394f1031ec054778919f94b726e016f8791739c20a0
openStream
public static InputStream openStream(Path path, Configuration conf) throws IOException
{    FileSystem fs = FileSystem.get(path.toUri(), conf);    return fs.open(path.makeQualified(path.toUri(), path));}
d7b50f26a34492deec41bab05618704f7a6716ad29d93bb9421c9a3ebba06f64
getFileStatus
public static FileStatus[] getFileStatus(Path path, PathType pathType, PathFilter filter, Comparator<FileStatus> ordering, Configuration conf) throws IOException
{    FileStatus[] statuses;    FileSystem fs = path.getFileSystem(conf);    if (filter == null) {        statuses = pathType == PathType.GLOB ? fs.globStatus(path) : listStatus(fs, path);    } else {        statuses = pathType == PathType.GLOB ? fs.globStatus(path, filter) : listStatus(fs, path, filter);    }    if (ordering != null) {        Arrays.sort(statuses, ordering);    }    return statuses;}
a4a6af2c38f2837ff6bec9cda573dc100a0b71ccdfe3961aaac162c6eda52ded
listStatus
public static FileStatus[] listStatus(FileSystem fs, Path path) throws IOException
{    try {        return fs.listStatus(path);    } catch (FileNotFoundException e) {        return new FileStatus[0];    }}
76156a38280fc3b2f891c0d50082b056579e425c69e88345fb6d4855e0578044
listStatus
public static FileStatus[] listStatus(FileSystem fs, Path path, PathFilter filter) throws IOException
{    try {        return fs.listStatus(path, filter);    } catch (FileNotFoundException e) {        return new FileStatus[0];    }}
b9f592773514e2db65593dcdbcff6f959baa3e2d7a809caa33afe41aa9e1ed60
cacheFiles
public static void cacheFiles(Path fileToCache, Configuration conf)
{    DistributedCache.setCacheFiles(new URI[] { fileToCache.toUri() }, conf);}
d74f66362aa9710813340a1c929a41995df96db7c43f2083dd1251e15100b9db
getSingleCachedFile
public static Path getSingleCachedFile(Configuration conf) throws IOException
{    return getCachedFiles(conf)[0];}
ac2d05d50a9eb355c20fb82ca3b569ffa3914757cc851f45331b57111c10d925
getCachedFiles
public static Path[] getCachedFiles(Configuration conf) throws IOException
{    LocalFileSystem localFs = FileSystem.getLocal(conf);    Path[] cacheFiles = DistributedCache.getLocalCacheFiles(conf);    URI[] fallbackFiles = DistributedCache.getCacheFiles(conf);        if (cacheFiles == null) {        Preconditions.checkState(fallbackFiles != null, "Unable to find cached files!");        cacheFiles = new Path[fallbackFiles.length];        for (int n = 0; n < fallbackFiles.length; n++) {            cacheFiles[n] = new Path(fallbackFiles[n].getPath());        }    } else {        for (int n = 0; n < cacheFiles.length; n++) {            cacheFiles[n] = localFs.makeQualified(cacheFiles[n]);                        if (!localFs.exists(cacheFiles[n])) {                cacheFiles[n] = new Path(fallbackFiles[n].getPath());            }        }    }    Preconditions.checkState(cacheFiles.length > 0, "Unable to find cached files!");    return cacheFiles;}
de0b02422d91382214af97510b85e8ada447c0a762892b7ca43880701e200a48
setSerializations
public static void setSerializations(Configuration configuration)
{    configuration.set("io.serializations", "org.apache.hadoop.io.serializer.JavaSerialization," + "org.apache.hadoop.io.serializer.WritableSerialization");}
b2265266704c6941b5375a4146bc0e83c288eae7d5976dc11d45c7977e9d1c3b
writeInt
public static void writeInt(int value, Path path, Configuration configuration) throws IOException
{    FileSystem fs = FileSystem.get(path.toUri(), configuration);    try (FSDataOutputStream out = fs.create(path)) {        out.writeInt(value);    }}
3b86a9703b1b54f2231b118ad87d27edfaf1b232b2987c80239589dc6a5dd716
readInt
public static int readInt(Path path, Configuration configuration) throws IOException
{    FileSystem fs = FileSystem.get(path.toUri(), configuration);    try (FSDataInputStream in = fs.open(path)) {        return in.readInt();    }}
f1034d25836ec2490f0b32d629047acb36a350775d42c6cfc7a0490810d924a8
buildDirList
public static String buildDirList(FileSystem fs, FileStatus fileStatus) throws IOException
{    boolean containsFiles = false;    List<String> directoriesList = new ArrayList<>();    for (FileStatus childFileStatus : fs.listStatus(fileStatus.getPath())) {        if (childFileStatus.isDir()) {            String subDirectoryList = buildDirList(fs, childFileStatus);            directoriesList.add(subDirectoryList);        } else {            containsFiles = true;        }    }    if (containsFiles) {        directoriesList.add(fileStatus.getPath().toUri().getPath());    }    return Joiner.on(',').skipNulls().join(directoriesList.iterator());}
2b7404b448c7e98b1202245d1e086d35e0c8c7001d0a0dcfd2a58f0c65923cfa
buildDirList
public static String buildDirList(FileSystem fs, FileStatus fileStatus, PathFilter pathFilter) throws IOException
{    boolean containsFiles = false;    List<String> directoriesList = new ArrayList<>();    for (FileStatus childFileStatus : fs.listStatus(fileStatus.getPath(), pathFilter)) {        if (childFileStatus.isDir()) {            String subDirectoryList = buildDirList(fs, childFileStatus);            directoriesList.add(subDirectoryList);        } else {            containsFiles = true;        }    }    if (containsFiles) {        directoriesList.add(fileStatus.getPath().toUri().getPath());    }    return Joiner.on(',').skipNulls().join(directoriesList.iterator());}
efc82fd78f25bfae1a6024b59360afcfbe8c25fc25781857f0fa848d0423692d
calcRelativeFilePath
public static String calcRelativeFilePath(Configuration configuration, Path filePath) throws IOException
{    FileSystem fs = filePath.getFileSystem(configuration);    FileStatus fst = fs.getFileStatus(filePath);    String currentPath = fst.getPath().toString().replaceFirst("file:", "");    String basePath = configuration.get("baseinputpath");    if (!basePath.endsWith("/")) {        basePath += "/";    }    basePath = basePath.replaceFirst("file:", "");    String[] parts = currentPath.split(basePath);    if (parts.length == 2) {        return parts[1];    } else if (parts.length == 1) {        return parts[0];    }    return currentPath;}
ece50d8e45e79f2c9ff60c092231f9bdf935f212056373b9e8e94fed5875126a
findInCacheByPartOfFilename
public static Path findInCacheByPartOfFilename(String partOfFilename, URI[] localFiles)
{    for (URI distCacheFile : localFiles) {        log.info("trying find a file in distributed cache containing [{}] in its name", partOfFilename);        if (distCacheFile != null && distCacheFile.toString().contains(partOfFilename)) {            log.info("found file [{}] containing [{}]", distCacheFile.toString(), partOfFilename);            return new Path(distCacheFile.getPath());        }    }    return null;}
c26f503a38f66dbc668d37c5be5fb7d4fe8987a195b2165c7f320c5f76a99397
add
public boolean add(Integer entry)
{    return tuple.add(entry);}
6f45ab878b2294ad4ecbab85697168d6f13fb64fd96551daf45789419a679a25
integerAt
public Integer integerAt(int index)
{    return tuple.get(index);}
acaba395eb1cc1591c281d29596e7d6d5359c9dddd6c25ecf3d2bffbe223fc3b
replaceAt
public Integer replaceAt(int index, Integer newInteger)
{    return tuple.set(index, newInteger);}
8e0a496f9383d6b8aa47c014edad116d1f2fab90d628ebb5b64473234f51e1c6
getEntries
public List<Integer> getEntries()
{    return Collections.unmodifiableList(this.tuple);}
1d1ebdb99c526da23d9a06ed6c089d39abc457289b7aff9cbe5f58a377b283b2
length
public int length()
{    return this.tuple.size();}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return tuple.toString();}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return tuple.hashCode();}
4afeb0868b55bdd8e18a00a3cb43d83e0714378d1c4bb36f0936daefc060e2e8
equals
public boolean equals(Object obj)
{    if (this == obj) {        return true;    }    if (obj == null) {        return false;    }    if (getClass() != obj.getClass()) {        return false;    }    IntegerTuple other = (IntegerTuple) obj;    if (tuple == null) {        if (other.tuple != null) {            return false;        }    } else if (!tuple.equals(other.tuple)) {        return false;    }    return true;}
5478cc5683f6dfd4515c383752d7c803555efc63d03fd84a03ba8dcd17eb4324
readFields
public void readFields(DataInput in) throws IOException
{    int len = in.readInt();    tuple = Lists.newArrayListWithCapacity(len);    for (int i = 0; i < len; i++) {        int data = in.readInt();        tuple.add(data);    }}
a894510dd4db439ff8e17ae1059489dc3abc97178e5932ceed0c70c3af165401
write
public void write(DataOutput out) throws IOException
{    out.writeInt(tuple.size());    for (Integer entry : tuple) {        out.writeInt(entry);    }}
11a99815010330bb2e79d2a7794a7eef0e0d102caa364554181c2a7116e65f17
compareTo
public int compareTo(IntegerTuple otherTuple)
{    int thisLength = length();    int otherLength = otherTuple.length();    int min = Math.min(thisLength, otherLength);    for (int i = 0; i < min; i++) {        int ret = this.tuple.get(i).compareTo(otherTuple.integerAt(i));        if (ret == 0) {            continue;        }        return ret;    }    if (thisLength < otherLength) {        return -1;    } else if (thisLength > otherLength) {        return 1;    } else {        return 0;    }}
02120eae421fbbae8dd86cb5f28cd5bbc80d60ec47542f96640721b993792dc8
set
public void set(int x, int y)
{    putInt(x, b, 0);    putInt(y, b, INT_BYTE_LENGTH);}
4817e8b13225466cb6a859cf781664f9a707067f205e1d498be481692e47bb5b
setFirst
public void setFirst(int x)
{    putInt(x, b, 0);}
6393a44d3047dc32c1aab9a1e22b28f431dc3c8b7d6bcec2cef2016d00d0eef8
getFirst
public int getFirst()
{    return getInt(b, 0);}
df512f687df5df6ae26647e3451c2d93cc450c6278882ddda85b6f84e16de031
setSecond
public void setSecond(int y)
{    putInt(y, b, INT_BYTE_LENGTH);}
66759585025a6d04d5e532a8b7a109bb283d93fe1989db45bd6cb5edf0dd115c
getSecond
public int getSecond()
{    return getInt(b, INT_BYTE_LENGTH);}
5478cc5683f6dfd4515c383752d7c803555efc63d03fd84a03ba8dcd17eb4324
readFields
public void readFields(DataInput in) throws IOException
{    in.readFully(b);}
a894510dd4db439ff8e17ae1059489dc3abc97178e5932ceed0c70c3af165401
write
public void write(DataOutput out) throws IOException
{    out.write(b);}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return Arrays.hashCode(b);}
4afeb0868b55bdd8e18a00a3cb43d83e0714378d1c4bb36f0936daefc060e2e8
equals
public boolean equals(Object obj)
{    if (this == obj) {        return true;    }    if (!super.equals(obj)) {        return false;    }    if (!(obj instanceof IntPairWritable)) {        return false;    }    IntPairWritable other = (IntPairWritable) obj;    return Arrays.equals(b, other.b);}
8a9865c666857dd9ffd0701e47463d101e08d80524caed570cfdd3a3f929307b
compareTo
public int compareTo(BinaryComparable other)
{    return Comparator.doCompare(b, 0, ((IntPairWritable) other).b, 0);}
38a346dd3b669981824e4b3da3c5ad6417c63d84aae517cdaa4a223d2c21e809
clone
public Object clone()
{    return new IntPairWritable(this);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "(" + getFirst() + ", " + getSecond() + ')';}
c159a0fb57e2ba9a7fb373b47eabbc552079ef89a4a50bbca7903b879542d25a
getBytes
public byte[] getBytes()
{    return b;}
1e7a9ccf869d4ffcaafdb7996c8f1f820d6f2af9eb816b65ead1db5bcfc3f744
getLength
public int getLength()
{    return INT_PAIR_BYTE_LENGTH;}
755e7bfd375669e261cd3c281c975acaa86cac98c2b12d7ba5f807c3970beead
putInt
private static void putInt(int value, byte[] b, int offset)
{    for (int i = offset, j = 24; j >= 0; i++, j -= 8) {        b[i] = (byte) (value >> j);    }}
7d78106f9f06d124a3c788435dd2d0cafa7ec25d3718665d081e8754e314ce65
getInt
private static int getInt(byte[] b, int offset)
{    int value = 0;    for (int i = offset, j = 24; j >= 0; i++, j -= 8) {        value |= (b[i] & 0xFF) << j;    }    return value;}
8cd74526bc7e7f20597a504e1ed768d1c3a048c7a382f95e889101f52fd94ec3
compare
public int compare(byte[] b1, int s1, int l1, byte[] b2, int s2, int l2)
{    return doCompare(b1, s1, b2, s2);}
5c3909441bdbf2a4417afb6d49f155a52b73aece94adbd33398f00d810546d62
doCompare
 static int doCompare(byte[] b1, int s1, byte[] b2, int s2)
{    int compare1 = compareInts(b1, s1, b2, s2);    if (compare1 != 0) {        return compare1;    }    return compareInts(b1, s1 + INT_BYTE_LENGTH, b2, s2 + INT_BYTE_LENGTH);}
17b017281474c77610982a6c369dcfcce4d35606a31c430cb3515bfd2fed978e
compareInts
private static int compareInts(byte[] b1, int s1, byte[] b2, int s2)
{        int end1 = s1 + INT_BYTE_LENGTH;    for (int i = s1, j = s2; i < end1; i++, j++) {        int a = b1[i];        int b = b2[j];        if (i > s1) {            a &= 0xff;            b &= 0xff;        }        if (a != b) {            return a - b;        }    }    return 0;}
8cd74526bc7e7f20597a504e1ed768d1c3a048c7a382f95e889101f52fd94ec3
compare
public int compare(byte[] b1, int s1, int l1, byte[] b2, int s2, int l2)
{    int firstb1 = WritableComparator.readInt(b1, s1);    int firstb2 = WritableComparator.readInt(b2, s2);    if (firstb1 < firstb2) {        return -1;    } else if (firstb1 > firstb2) {        return 1;    } else {        return 0;    }}
364e26e3073e39bab4c99d28b2142fd070e086b7541d68a1ca46b17c51e26fdd
compare
public int compare(Object o1, Object o2)
{    int firstb1 = ((IntPairWritable) o1).getFirst();    int firstb2 = ((IntPairWritable) o2).getFirst();    if (firstb1 < firstb2) {        return -1;    }    if (firstb1 > firstb2) {        return 1;    }    return 0;}
9992952a80f7e6237a0897bd838f7d7f2ae8f922f336c1865555041875a95829
getFrequency
public double getFrequency()
{    return frequency;}
ceee72b339c3ef05451cec71af11d4a23751f32a85e7fb3bbbfbac40ea040496
getPair
public IntPairWritable getPair()
{    return pair;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return pair.hashCode() + RandomUtils.hashDouble(frequency);}
bb29750b7e6bf655af44b0da52fe00f1ebf9e289dc8b24b5693f30118fb1d7a7
equals
public boolean equals(Object right)
{    if (!(right instanceof Frequency)) {        return false;    }    Frequency that = (Frequency) right;    return pair.equals(that.pair) && frequency == that.frequency;}
b0b29e84abcad653e0800ee167a411d02324e9aba107644413eca06ae180f800
compareTo
public int compareTo(Frequency that)
{    if (frequency < that.frequency) {        return -1;    }    if (frequency > that.frequency) {        return 1;    }    return 0;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return pair + "\t" + frequency;}
d40d7171e45b4fe4d4530b5995640f8f40d01cc35b3fd73550c042353cf844eb
apply
public T apply(T from)
{    if (constructor == null) {        Class<T> elementClass = (Class<T>) from.getClass();        try {            constructor = elementClass.getConstructor(elementClass);        } catch (NoSuchMethodException e) {            throw new IllegalStateException(e);        }    }    try {        return constructor.newInstance(from);    } catch (InstantiationException | IllegalAccessException | InvocationTargetException e) {        throw new IllegalStateException(e);    }}
423fd4dee3cfe1ac7f5463036a794bf56e894523056fc6e6265d777aa7f88514
delegate
protected Iterator<T> delegate()
{    return delegate;}
1f4efd2f6d2d9ebe97837b0464438877b70e437c3a55c9aa41e220cd7f9c34e0
computeNext
protected Integer computeNext()
{    if (count < to) {        return count++;    } else {        return endOfData();    }}
37c103bb84952e055d3c90aa17374e9c534adb331cfa33135047f91399a5d006
iterator
public Iterator<String> iterator()
{    try {        return new FileLineIterator(is, encoding, skipFirstLine, this.origFilename);    } catch (IOException ioe) {        throw new IllegalStateException(ioe);    }}
8cd063a7a1ac69f8bf9333858afca546b8a13f08521a3daccf527143cda91a9f
getFileInputStream
 static InputStream getFileInputStream(File file) throws IOException
{    InputStream is = new FileInputStream(file);    String name = file.getName();    if ("gz".equalsIgnoreCase(Files.getFileExtension(name.toLowerCase()))) {        return new GZIPInputStream(is);    } else if ("zip".equalsIgnoreCase(Files.getFileExtension(name.toLowerCase()))) {        return new ZipInputStream(is);    } else {        return is;    }}
41200016f1ae32eb7b056ec21c2847f1372bca186580e8815c98990fd0278b90
computeNext
protected String computeNext()
{    String line;    try {        line = reader.readLine();    } catch (IOException ioe) {        try {            close();        } catch (IOException e) {            log.error(e.getMessage(), e);        }        throw new IllegalStateException(ioe);    }    return line == null ? endOfData() : line;}
83659b3f3c32cda5d1e381b9ad4b7db55d1ee8ecce3504ad3c9ad45a376b6f2e
skip
public void skip(int n)
{    try {        for (int i = 0; i < n; i++) {            if (reader.readLine() == null) {                break;            }        }    } catch (IOException ioe) {        try {            close();        } catch (IOException e) {            throw new IllegalStateException(e);        }    }}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    endOfData();    Closeables.close(reader, true);}
423fd4dee3cfe1ac7f5463036a794bf56e894523056fc6e6265d777aa7f88514
delegate
protected Iterator<T> delegate()
{    return delegate;}
f953961d64692f9b59701c434fe1f9537bac98f3f86c59d94e709afc4047563e
iterator
public Iterator<T> iterator()
{    return new SamplingIterator<>(delegate.iterator(), samplingRate);}
5e27d3b223fb9780ebac4083e93ba8ef1b987c41226f268731cfabb0bc9322f1
maybeWrapIterable
public static Iterable<T> maybeWrapIterable(Iterable<T> delegate, double samplingRate)
{    return samplingRate >= 1.0 ? delegate : new SamplingIterable<>(delegate, samplingRate);}
fcbd38ffc429e18428425214f03fd48c7497dba9932fb7efeb3f4f1b5e7362a2
computeNext
protected T computeNext()
{    int toSkip = geometricDistribution.sample();    if (delegate instanceof SkippingIterator<?>) {        SkippingIterator<? extends T> skippingDelegate = (SkippingIterator<? extends T>) delegate;        skippingDelegate.skip(toSkip);        if (skippingDelegate.hasNext()) {            return skippingDelegate.next();        }    } else {        for (int i = 0; i < toSkip && delegate.hasNext(); i++) {            delegate.next();        }        if (delegate.hasNext()) {            return delegate.next();        }    }    return endOfData();}
50dec78a3246c66d1f1077fa5021604b0b396ea488918ec580feb329b787f269
accept
public boolean accept(Path path)
{    String name = path.getName();    return name.startsWith("part-") && !name.endsWith(".crc");}
50dec78a3246c66d1f1077fa5021604b0b396ea488918ec580feb329b787f269
accept
public boolean accept(Path path)
{    String name = path.getName();    return name.startsWith("clusters-") && name.endsWith("-final");}
50dec78a3246c66d1f1077fa5021604b0b396ea488918ec580feb329b787f269
accept
public boolean accept(Path path)
{    String name = path.getName();    return !(name.endsWith(".crc") || name.startsWith(".") || name.startsWith("_"));}
324106df1339f3d9694f41a30ae9009353f5c0f2889109b9f812bc141368cabf
partFilter
public static PathFilter partFilter()
{    return PART_FILE_INSTANCE;}
1b62f15c6bfe8b4f576fa5eeec6b3c5a99c46c116ffc279512433a70efd80498
finalPartFilter
public static PathFilter finalPartFilter()
{    return CLUSTER_FINAL;}
5eeda0fdbdb3bfeb54b005118e028e41f09024831646c2693b74e13942518daf
logsCRCFilter
public static PathFilter logsCRCFilter()
{    return LOGS_CRC_INSTANCE;}
577ab0167978f2e3bc0d79f78e8bef546c1a14ba21fb581d1134adcbd6c1b152
iterator
public Iterator<Pair<K, V>> iterator()
{    try {        return new SequenceFileDirIterator<>(path, pathType, filter, ordering, reuseKeyValueInstances, conf);    } catch (IOException ioe) {        throw new IllegalStateException(path.toString(), ioe);    }}
c3aecd494175bf1816868fd1c2400edcaa53af09acdd78c66d7cb0c0f21020a9
init
private void init(FileStatus[] statuses, final boolean reuseKeyValueInstances, final Configuration conf)
{    /*     * prevent NPEs. Unfortunately, Hadoop would return null for list if nothing     * was qualified. In this case, which is a corner case, we should assume an     * empty iterator, not an NPE.     */    if (statuses == null) {        statuses = NO_STATUSES;    }    Iterator<FileStatus> fileStatusIterator = Iterators.forArray(statuses);    Iterator<Iterator<Pair<K, V>>> fsIterators = Iterators.transform(fileStatusIterator, new Function<FileStatus, Iterator<Pair<K, V>>>() {        @Override        public Iterator<Pair<K, V>> apply(FileStatus from) {            try {                SequenceFileIterator<K, V> iterator = new SequenceFileIterator<>(from.getPath(), reuseKeyValueInstances, conf);                iterators.add(iterator);                return iterator;            } catch (IOException ioe) {                throw new IllegalStateException(from.getPath().toString(), ioe);            }        }    });        Collections.reverse(iterators);    delegate = Iterators.concat(fsIterators);}
4f42350f818bbf7b86079bd0a964d674b74167f9892d61d9c5178cb35be3a046
apply
public Iterator<Pair<K, V>> apply(FileStatus from)
{    try {        SequenceFileIterator<K, V> iterator = new SequenceFileIterator<>(from.getPath(), reuseKeyValueInstances, conf);        iterators.add(iterator);        return iterator;    } catch (IOException ioe) {        throw new IllegalStateException(from.getPath().toString(), ioe);    }}
31be3fc54093160a2bc08eecf525c9738a9dd609fa2883ca9d494c4a48609cf5
delegate
protected Iterator<Pair<K, V>> delegate()
{    return delegate;}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    IOUtils.close(iterators);    iterators.clear();}
d40381ab6f038666ae133df9f475ec0ae3c2f19a5af68da0ebdc4aa1776ccba6
iterator
public Iterator<V> iterator()
{    try {        return new SequenceFileDirValueIterator<>(path, pathType, filter, ordering, reuseKeyValueInstances, conf);    } catch (IOException ioe) {        throw new IllegalStateException(path.toString(), ioe);    }}
209214c1507555bfa121c7526d24309e31b998831004840d5657d4782de84517
init
private void init(FileStatus[] statuses, Comparator<FileStatus> ordering, final boolean reuseKeyValueInstances, final Configuration conf) throws IOException
{    /*     * prevent NPEs. Unfortunately, Hadoop would return null for list if nothing     * was qualified. In this case, which is a corner case, we should assume an     * empty iterator, not an NPE.     */    if (statuses == null) {        statuses = NO_STATUSES;    }    if (ordering != null) {        Arrays.sort(statuses, ordering);    }    Iterator<FileStatus> fileStatusIterator = Iterators.forArray(statuses);    try {        Iterator<Iterator<V>> fsIterators = Iterators.transform(fileStatusIterator, new Function<FileStatus, Iterator<V>>() {            @Override            public Iterator<V> apply(FileStatus from) {                try {                    SequenceFileValueIterator<V> iterator = new SequenceFileValueIterator<>(from.getPath(), reuseKeyValueInstances, conf);                    iterators.add(iterator);                    return iterator;                } catch (IOException ioe) {                    throw new IllegalStateException(from.getPath().toString(), ioe);                }            }        });                Collections.reverse(iterators);        delegate = Iterators.concat(fsIterators);    } finally {        /*       * prevent file handle leaks in case one of handles fails to open. If some       * of the files fail to open, constructor will fail and close() will never       * be called. Thus, those handles that did open in constructor, would leak       * out, unless we specifically handle it here.       */        IOUtils.close(iterators);    }}
4d06a0224602ae83c9d9594c0194c13c01b9d7ede2d7a060f10d2cad015a77be
apply
public Iterator<V> apply(FileStatus from)
{    try {        SequenceFileValueIterator<V> iterator = new SequenceFileValueIterator<>(from.getPath(), reuseKeyValueInstances, conf);        iterators.add(iterator);        return iterator;    } catch (IOException ioe) {        throw new IllegalStateException(from.getPath().toString(), ioe);    }}
f26f9d378f30b6386fe8e35235691f750b724c8b63fbf851d149aed806416b80
delegate
protected Iterator<V> delegate()
{    return delegate;}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    IOUtils.close(iterators);}
577ab0167978f2e3bc0d79f78e8bef546c1a14ba21fb581d1134adcbd6c1b152
iterator
public Iterator<Pair<K, V>> iterator()
{    try {        return new SequenceFileIterator<>(path, reuseKeyValueInstances, conf);    } catch (IOException ioe) {        throw new IllegalStateException(path.toString(), ioe);    }}
b626fda93f6f4e76007aeb61b9219b5662b79e4e9b25a86c1520be7baf8e8257
getKeyClass
public Class<K> getKeyClass()
{    return keyClass;}
d9627e082bc264d77bf58c245bea5d054ffb1b652b653b4cd4c726eb59705882
getValueClass
public Class<V> getValueClass()
{    return valueClass;}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    key = null;    value = null;    Closeables.close(reader, true);    endOfData();}
45525eacb661b969fbe99cfb5cff286796469274f56feebfc0ba2d7243571f43
computeNext
protected Pair<K, V> computeNext()
{    if (!reuseKeyValueInstances || value == null) {        key = ReflectionUtils.newInstance(keyClass, conf);        if (!noValue) {            value = ReflectionUtils.newInstance(valueClass, conf);        }    }    try {        boolean available;        if (noValue) {            available = reader.next(key);        } else {            available = reader.next(key, value);        }        if (!available) {            close();            return null;        }        return new Pair<>(key, value);    } catch (IOException ioe) {        try {            close();        } catch (IOException e) {            log.error(e.getMessage(), e);        }        throw new IllegalStateException(ioe);    }}
d40381ab6f038666ae133df9f475ec0ae3c2f19a5af68da0ebdc4aa1776ccba6
iterator
public Iterator<V> iterator()
{    try {        return new SequenceFileValueIterator<>(path, reuseKeyValueInstances, conf);    } catch (IOException ioe) {        throw new IllegalStateException(path.toString(), ioe);    }}
d9627e082bc264d77bf58c245bea5d054ffb1b652b653b4cd4c726eb59705882
getValueClass
public Class<V> getValueClass()
{    return valueClass;}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    value = null;    Closeables.close(reader, true);    endOfData();}
69c7a90e4d14e00a6b10499c1bd15d6b5ae722fdf534a9da509974a5609268f5
computeNext
protected V computeNext()
{    if (!reuseKeyValueInstances || value == null) {        value = ReflectionUtils.newInstance(valueClass, conf);    }    try {        boolean available = reader.next(key, value);        if (!available) {            close();            return null;        }        return value;    } catch (IOException ioe) {        try {            close();        } catch (IOException e) {            log.error(e.getMessage(), e);        }        throw new IllegalStateException(ioe);    }}
8bb3e2b993b2a872be6cf4452fdf751da215f48e7694f43e97c7f5ff66fcd0eb
apply
public T apply(Pair<Integer, T> from)
{    return from.getSecond();}
423fd4dee3cfe1ac7f5463036a794bf56e894523056fc6e6265d777aa7f88514
delegate
protected Iterator<T> delegate()
{    return delegate;}
055f318abe00a136cb7b327d200f1e2d9992d25a9867ae802becd3fcf37bbbbc
apply
public Pair<List<String>, Long> apply(String from)
{    String[] items = splitter.split(from);    return new Pair<>(Arrays.asList(items), ONE);}
3b101023c6298b59cf42e0d4f5ea4d02748ec87a9f4dcb1935a657ee35771250
delegate
protected Iterator<Pair<List<String>, Long>> delegate()
{    return delegate;}
afb31ada9e7c05e716c91a33d581bd6b4d3e418ab0b63a28576619f41a083992
getFirst
public long getFirst()
{    return first;}
bc2e04e8f7745b856d0576b6380d983c63e9e62653b52d51ba61c65519a374dd
getSecond
public long getSecond()
{    return second;}
937265f33ec4808321629550a78ffb5f859e8ff5a18d516106ab7ffbaf7f8b71
swap
public LongPair swap()
{    return new LongPair(second, first);}
4afeb0868b55bdd8e18a00a3cb43d83e0714378d1c4bb36f0936daefc060e2e8
equals
public boolean equals(Object obj)
{    if (!(obj instanceof LongPair)) {        return false;    }    LongPair otherPair = (LongPair) obj;    return first == otherPair.getFirst() && second == otherPair.getSecond();}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    int firstHash = Longs.hashCode(first);        return (firstHash >>> 16 | firstHash << 16) ^ Longs.hashCode(second);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return '(' + String.valueOf(first) + ',' + second + ')';}
5e86552fd5bb5fa2c24705a0d6e43d62f340dfc1866248b0cc240f91f4d3196f
compareTo
public int compareTo(LongPair o)
{    if (first < o.getFirst()) {        return -1;    } else if (first > o.getFirst()) {        return 1;    } else {        return second < o.getSecond() ? -1 : second > o.getSecond() ? 1 : 0;    }}
afbd130a68077b08f92ca35bb0733119294e8533006a53104e2200cc338a5605
createAnalyzer
public static Analyzer createAnalyzer(String analyzerClassName) throws ClassNotFoundException
{    return createAnalyzer(analyzerClassName, Version.LUCENE_5_5_2);}
998c8873a747adc75db9f5e455581607fe72747567185a1197ee2b538cd1ccfd
createAnalyzer
public static Analyzer createAnalyzer(String analyzerClassName, Version version) throws ClassNotFoundException
{    Class<? extends Analyzer> analyzerClass = Class.forName(analyzerClassName).asSubclass(Analyzer.class);    return createAnalyzer(analyzerClass, version);}
06117363f9f9cde194a15a02580ec0afe69f2a2a51655231e7f7d3e48f98646c
createAnalyzer
public static Analyzer createAnalyzer(Class<? extends Analyzer> analyzerClass)
{    return createAnalyzer(analyzerClass, Version.LUCENE_5_5_2);}
03a06be24410ed84e833b49d118c57c8b7d7d1bd2fa2eff38d6ede8458363e2c
createAnalyzer
public static Analyzer createAnalyzer(Class<? extends Analyzer> analyzerClass, Version version)
{    try {        return ClassUtils.instantiateAs(analyzerClass, Analyzer.class, new Class<?>[] { Version.class }, new Object[] { version });    } catch (IllegalStateException e) {        return ClassUtils.instantiateAs(analyzerClass, Analyzer.class);    }}
4bcff98b47e359889d658503ef4a7fee5098fa3f9fbb50ceb6f0361c81e48570
incrementToken
public boolean incrementToken()
{    if (iterator.hasNext()) {        clearAttributes();        termAtt.append(iterator.next());        return true;    } else {        return false;    }}
41200016f1ae32eb7b056ec21c2847f1372bca186580e8815c98990fd0278b90
computeNext
protected String computeNext()
{    try {        if (tokenStream.incrementToken()) {            return tokenStream.getAttribute(CharTermAttribute.class).toString();        } else {            tokenStream.end();            tokenStream.close();            return endOfData();        }    } catch (IOException e) {        throw new IllegalStateException("IO error while tokenizing", e);    }}
444bda7c9ead0de7f0dc04399b92be991bd10d75dc2d52c0bdbaba5f088dc559
reduce
public void reduce(WritableComparable<?> key, Iterable<VectorWritable> vectors, Context ctx) throws IOException, InterruptedException
{    ctx.write(key, VectorWritable.merge(vectors.iterator()));}
444bda7c9ead0de7f0dc04399b92be991bd10d75dc2d52c0bdbaba5f088dc559
reduce
public void reduce(WritableComparable<?> key, Iterable<VectorWritable> vectors, Context ctx) throws IOException, InterruptedException
{    Vector merged = VectorWritable.merge(vectors.iterator()).get();    result.set(new SequentialAccessSparseVector(merged));    ctx.write(key, result);}
d3192444cabbcc9598d5706bfdcd1dfedd209d3688c3c575e42fd6b75ea83739
setup
protected void setup(Context ctx) throws IOException, InterruptedException
{    newNumCols = ctx.getConfiguration().getInt(NEW_NUM_COLS_PARAM, Integer.MAX_VALUE);}
8fc5f64a22de122ebab3783eb08c9f0101bb7f937d9b5649bbbc7b2ca6d82100
map
protected void map(IntWritable r, VectorWritable v, Context ctx) throws IOException, InterruptedException
{    int row = r.get();    for (Vector.Element e : v.get().nonZeroes()) {        RandomAccessSparseVector tmp = new RandomAccessSparseVector(newNumCols, 1);        tmp.setQuick(row, e.get());        r.set(e.index());        ctx.write(r, new VectorWritable(tmp));    }}
6ba7549c190ba3934c737121a4e01d8239c111107d86e2d043f3abc620611696
reduce
protected void reduce(WritableComparable<?> key, Iterable<VectorWritable> values, Context ctx) throws IOException, InterruptedException
{    result.set(Vectors.sum(values.iterator()));    ctx.write(key, result);}
6ba7549c190ba3934c737121a4e01d8239c111107d86e2d043f3abc620611696
reduce
protected void reduce(WritableComparable<?> key, Iterable<VectorWritable> values, Context ctx) throws IOException, InterruptedException
{    ctx.write(key, new VectorWritable(Vectors.sum(values.iterator())));}
2b9901eaaf1d5ed9398320f3b317314e443bec58fe29ec8bc1a07b17d1b3203e
logMemoryStatistics
public static void logMemoryStatistics()
{    Runtime runtime = Runtime.getRuntime();    long freeBytes = runtime.freeMemory();    long maxBytes = runtime.maxMemory();    long totalBytes = runtime.totalMemory();    long usedBytes = totalBytes - freeBytes;    log.info("Memory (bytes): {} used, {} heap, {} max", usedBytes, totalBytes, maxBytes);}
94f4e301b8c33d56e1d2263cdcecb28fe9c24bc5961ba9423aacb758438dce7c
startMemoryLogger
public static void startMemoryLogger(long rateInMillis)
{    stopMemoryLogger();    scheduler = Executors.newScheduledThreadPool(1, new ThreadFactory() {        private final ThreadFactory delegate = Executors.defaultThreadFactory();        @Override        public Thread newThread(Runnable r) {            Thread t = delegate.newThread(r);            t.setDaemon(true);            return t;        }    });    Runnable memoryLoogerRunnable = new Runnable() {        @Override        public void run() {            logMemoryStatistics();        }    };    scheduler.scheduleAtFixedRate(memoryLoogerRunnable, rateInMillis, rateInMillis, TimeUnit.MILLISECONDS);}
02166686c9ffef8abcca97b0bc3e38cb95c97860d78686958b46127a2ecadb18
newThread
public Thread newThread(Runnable r)
{    Thread t = delegate.newThread(r);    t.setDaemon(true);    return t;}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    logMemoryStatistics();}
14bbe611375eabfa6f6b51bdecf880b55b8d6530724745bd229a809fd7e1a71f
startMemoryLogger
public static void startMemoryLogger()
{    startMemoryLogger(1000);}
9241f18424ad54e34348b85c1a929952f07533226cce414dac98562e0cc96fef
stopMemoryLogger
public static void stopMemoryLogger()
{    if (scheduler != null) {        scheduler.shutdownNow();        scheduler = null;    }}
69c6d00c43b3a2804697792efdd5441d1570855fae95559c1cf5abcc28099863
generateNGrams
public Map<String, List<String>> generateNGrams()
{    Map<String, List<String>> returnDocument = Maps.newHashMap();    Iterator<String> tokenizer = SPACE_TAB.split(line).iterator();    List<String> tokens = Lists.newArrayList();    String labelName = tokenizer.next();    List<String> previousN1Grams = Lists.newArrayList();    while (tokenizer.hasNext()) {        String nextToken = tokenizer.next();        if (previousN1Grams.size() == gramSize) {            previousN1Grams.remove(0);        }        previousN1Grams.add(nextToken);        StringBuilder gramBuilder = new StringBuilder();        for (String gram : previousN1Grams) {            gramBuilder.append(gram);            String token = gramBuilder.toString();            tokens.add(token);            gramBuilder.append(' ');        }    }    returnDocument.put(labelName, tokens);    return returnDocument;}
0a6ff3acf20618c8ed52ce292e585a622e10796128d033dcd0f3cc087f88bdfa
generateNGramsWithoutLabel
public List<String> generateNGramsWithoutLabel()
{    List<String> tokens = Lists.newArrayList();    List<String> previousN1Grams = Lists.newArrayList();    for (String nextToken : SPACE_TAB.split(line)) {        if (previousN1Grams.size() == gramSize) {            previousN1Grams.remove(0);        }        previousN1Grams.add(nextToken);        StringBuilder gramBuilder = new StringBuilder();        for (String gram : previousN1Grams) {            gramBuilder.append(gram);            String token = gramBuilder.toString();            tokens.add(token);            gramBuilder.append(' ');        }    }    return tokens;}
c30de9669d8e0b1c7c8924fa3f8c311e0429030b262c6cd5dcdda937004ea278
getFirst
public A getFirst()
{    return first;}
3c30b3ee121d3c208d301eb997ad0e04616821748a981f2783b6bda7b2317814
getSecond
public B getSecond()
{    return second;}
d1282fba24daf97dc9feef09a9adf2823ae5ebea78226ba6a69e3dc9f6649b51
swap
public Pair<B, A> swap()
{    return new Pair<>(second, first);}
971609bd352e9daad9e9dbdffaa5a74af30dade496fccdefed3f9b976ef64987
of
public static Pair<A, B> of(A a, B b)
{    return new Pair<>(a, b);}
4afeb0868b55bdd8e18a00a3cb43d83e0714378d1c4bb36f0936daefc060e2e8
equals
public boolean equals(Object obj)
{    if (!(obj instanceof Pair<?, ?>)) {        return false;    }    Pair<?, ?> otherPair = (Pair<?, ?>) obj;    return isEqualOrNulls(first, otherPair.getFirst()) && isEqualOrNulls(second, otherPair.getSecond());}
a223bba6e8a3e180adbdf6f4e412bef9d92545898e4c0e703ebce6e31bcaae29
isEqualOrNulls
private static boolean isEqualOrNulls(Object obj1, Object obj2)
{    return obj1 == null ? obj2 == null : obj1.equals(obj2);}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    int firstHash = hashCodeNull(first);        return (firstHash >>> 16 | firstHash << 16) ^ hashCodeNull(second);}
d2251d246a66d24da804609796e97daa105f37e2307c01a2065c63ce60fc8571
hashCodeNull
private static int hashCodeNull(Object obj)
{    return obj == null ? 0 : obj.hashCode();}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return '(' + String.valueOf(first) + ',' + second + ')';}
0a64b29952b5729cfcd58b82bc562151e75bdd921ea73427dfebdc71f4cfcef1
compareTo
public int compareTo(Pair<A, B> other)
{    Comparable<A> thisFirst = (Comparable<A>) first;    A thatFirst = other.getFirst();    int compare = thisFirst.compareTo(thatFirst);    if (compare != 0) {        return compare;    }    Comparable<B> thisSecond = (Comparable<B>) second;    B thatSecond = other.getSecond();    return thisSecond.compareTo(thatSecond);}
b8280aa7c29098a08a0735a6877e811a2537eddeb6a8db97392f994e2411326b
configure
public void configure(Configuration jobConf)
{}
7205b9fdd8de7b3ade6cb7bd7db44a76f1bb73df3db453299e8820273cdc140b
createParameters
public void createParameters(String prefix, Configuration jobConf)
{}
64eb8a5c31d9e029c5517099af26e8748d848207cf7fd501f842390c21549ddb
getStringValue
public String getStringValue()
{    if (value == null) {        return null;    }    return value.toString();}
a0a1e1740dfa61e3f51aef2d90597a3361d76f17552801f754e73a715f418b2c
getParameters
public Collection<Parameter<?>> getParameters()
{    return Collections.emptyList();}
bfb3e3b005b22e062126853d5c0d98fad42ac9df7811d72a18328726111f4a05
prefix
public String prefix()
{    return prefix;}
381128365d1314b5f05c81a0d52df7ef30ba6dfba5aedbf9c56defe916311f78
name
public String name()
{    return name;}
4eb1f9018bb3cb6c725b00555fb50d2854d0ff3c6488aaad7be9a396731d0297
description
public String description()
{    return description;}
a4b3717c444a6630d2f0f4c1b1c9a99618ef2718106cc4e8615ecd69a9a9a923
type
public Class<T> type()
{    return type;}
b25df2d5a00901ab887df1d4a8c8e986cb4736ce98a1e1ba1d5bfc4bbca0444d
defaultValue
public String defaultValue()
{    return defaultValue;}
f92b71e18fa63d96cf2b628ad8520702b897423512edea5de9dd0e96f471f5ff
get
public T get()
{    return value;}
984e83302fdd917028da16e78bad5e097d72351179b4c62f14cec51c4fa3d564
set
public void set(T value)
{    this.value = value;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    if (value != null) {        return value.toString();    } else {        return super.toString();    }}
fe07cb5e05ce8ee538709e3da1632d6b3180c5408c96a101fdeda854d55b4cd6
setStringValue
public void setStringValue(String stringValue)
{    try {        set(Class.forName(stringValue));    } catch (ClassNotFoundException e) {        throw new IllegalStateException(e);    }}
64eb8a5c31d9e029c5517099af26e8748d848207cf7fd501f842390c21549ddb
getStringValue
public String getStringValue()
{    if (get() == null) {        return null;    }    return get().getName();}
fe07cb5e05ce8ee538709e3da1632d6b3180c5408c96a101fdeda854d55b4cd6
setStringValue
public void setStringValue(String stringValue)
{    set(Double.valueOf(stringValue));}
c842d26ab2c30c318fc588fd5a89aff7f1cce1e2c7c6da775397b99fa58aee6f
configureParameters
public static void configureParameters(Parametered parametered, Configuration jobConf)
{    configureParameters(parametered.getClass().getSimpleName() + '.', parametered, jobConf);}
60a7bb90548580462280b8bad55cd68ec7fc116af825e50768bbf9588f3a2109
configureParameters
public static void configureParameters(String prefix, Parametered parametered, Configuration jobConf)
{    parametered.createParameters(prefix, jobConf);    configureParametersRecursively(parametered, prefix, jobConf);}
3d60651c126bccb7b57c0dc3b97efff01046013b0aa84b33b8edaee620d9d088
configureParametersRecursively
private static void configureParametersRecursively(Parametered parametered, String prefix, Configuration jobConf)
{    for (Parameter<?> parameter : parametered.getParameters()) {        if (log.isDebugEnabled()) {            log.debug("Configuring {}{}", prefix, parameter.name());        }        String name = prefix + parameter.name() + '.';        parameter.createParameters(name, jobConf);        parameter.configure(jobConf);        if (!parameter.getParameters().isEmpty()) {            configureParametersRecursively(parameter, name, jobConf);        }    }}
1495d91987c39916bcde19a1d472d96591020491f727567ef8d8db0484b96c12
help
public static String help(Parametered parametered)
{    return new Help(parametered).toString();}
ffb6f66e4366e9ad30520c4de5f70a8d0a68e8787e4565be53cb32ad0ec7bb8e
conf
public static String conf(Parametered parametered)
{    return new Conf(parametered).toString();}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return sb.toString();}
df089addac4c58a3a932626da10144546556271f9fd143fb0f978c2aa5b93519
recurseCount
private void recurseCount(Parametered parametered)
{    for (Parameter<?> parameter : parametered.getParameters()) {        int parameterNameLength = parameter.name().length();        if (parameterNameLength > longestName) {            longestName = parameterNameLength;        }        recurseCount(parameter);        numChars += parameter.description().length();    }}
7c32732bac4d089af3837e3457cdd56c5b006d95f52e13642ed08e841047d1e6
recurseWrite
private void recurseWrite(Parametered parametered)
{    for (Parameter<?> parameter : parametered.getParameters()) {        sb.append(parameter.prefix());        sb.append(parameter.name());        int max = longestName - parameter.name().length() - parameter.prefix().length() + NAME_DESC_DISTANCE;        for (int i = 0; i < max; i++) {            sb.append(' ');        }        sb.append(parameter.description());        if (parameter.defaultValue() != null) {            sb.append(" (default value '");            sb.append(parameter.defaultValue());            sb.append("')");        }        sb.append('\n');        recurseWrite(parameter);    }}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return sb.toString();}
df089addac4c58a3a932626da10144546556271f9fd143fb0f978c2aa5b93519
recurseCount
private void recurseCount(Parametered parametered)
{    for (Parameter<?> parameter : parametered.getParameters()) {        int parameterNameLength = parameter.prefix().length() + parameter.name().length();        if (parameterNameLength > longestName) {            longestName = parameterNameLength;        }        numChars += parameterNameLength;                numChars += 5;        numChars += parameter.description().length();        if (parameter.getStringValue() != null) {            numChars += parameter.getStringValue().length();        }        recurseCount(parameter);    }}
7c32732bac4d089af3837e3457cdd56c5b006d95f52e13642ed08e841047d1e6
recurseWrite
private void recurseWrite(Parametered parametered)
{    for (Parameter<?> parameter : parametered.getParameters()) {        sb.append("# ");        sb.append(parameter.description());        sb.append('\n');        sb.append(parameter.prefix());        sb.append(parameter.name());        sb.append(" = ");        if (parameter.getStringValue() != null) {            sb.append(parameter.getStringValue());        }        sb.append('\n');        sb.append('\n');        recurseWrite(parameter);    }}
fe07cb5e05ce8ee538709e3da1632d6b3180c5408c96a101fdeda854d55b4cd6
setStringValue
public void setStringValue(String stringValue)
{    set(new Path(stringValue));}
ef420f3d2788eaa7bf4199234484a1b049dbf81bc399abed69685d87bfe6b6bf
get
public String get(String key)
{    return params.get(key);}
b7be133e07b8635aff2c0347bdbe3ffe76d00f4b5c1f12719afbc53fde6d113d
get
public String get(String key, String defaultValue)
{    String ret = params.get(key);    return ret == null ? defaultValue : ret;}
8251bed8a574b8fa3247b7af1140f59defedbe10f2dd855fc9b80498acc578a1
set
public void set(String key, String value)
{    params.put(key, value);}
d9327754c8cdcb5e83f79841d729a6bf5dd1a0b1f9d3fd594ef55be6ba1dd7e9
getInt
public int getInt(String key, int defaultValue)
{    String ret = params.get(key);    return ret == null ? defaultValue : Integer.parseInt(ret);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    Configuration conf = new Configuration();    conf.set("io.serializations", "org.apache.hadoop.io.serializer.JavaSerialization," + "org.apache.hadoop.io.serializer.WritableSerialization");    DefaultStringifier<Map<String, String>> mapStringifier = new DefaultStringifier<>(conf, GenericsUtil.getClass(params));    try {        return mapStringifier.toString(params);    } catch (IOException e) {        log.info("Encountered IOException while deserializing returning empty string", e);        return "";    }}
b3437cd3c994013f4f16192629aae39fae335587c167b4e295969d579afecb67
print
public String print()
{    return params.toString();}
40abe11117ebf0d2d1a89a60cb54e674010260a9566c0e948774648ecd56eca7
parseParams
public static Map<String, String> parseParams(String serializedString) throws IOException
{    Configuration conf = new Configuration();    conf.set("io.serializations", "org.apache.hadoop.io.serializer.JavaSerialization," + "org.apache.hadoop.io.serializer.WritableSerialization");    Map<String, String> params = Maps.newHashMap();    DefaultStringifier<Map<String, String>> mapStringifier = new DefaultStringifier<>(conf, GenericsUtil.getClass(params));    return mapStringifier.fromString(serializedString);}
a092b33617694eb77c37ae5928c0aa27a0d917c509bf8ffa77fc52c093fdcc98
add
public boolean add(String entry)
{    return tuple.add(entry);}
89abad43e57d90fcd90761e4505923b4dc0a4129cb7f02a848f2e0daed827e43
stringAt
public String stringAt(int index)
{    return tuple.get(index);}
9588f8adc2183e31e51e169fafcc0dad3869c5cf718048a73d354eac5b551db8
replaceAt
public String replaceAt(int index, String newString)
{    return tuple.set(index, newString);}
46e98816c24ef4578d0cd0c295df1095e4de13dd017526efa31d3cc976a850f1
getEntries
public List<String> getEntries()
{    return Collections.unmodifiableList(this.tuple);}
1d1ebdb99c526da23d9a06ed6c089d39abc457289b7aff9cbe5f58a377b283b2
length
public int length()
{    return this.tuple.size();}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return tuple.toString();}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return tuple.hashCode();}
4afeb0868b55bdd8e18a00a3cb43d83e0714378d1c4bb36f0936daefc060e2e8
equals
public boolean equals(Object obj)
{    if (this == obj) {        return true;    }    if (obj == null) {        return false;    }    if (getClass() != obj.getClass()) {        return false;    }    StringTuple other = (StringTuple) obj;    if (tuple == null) {        if (other.tuple != null) {            return false;        }    } else if (!tuple.equals(other.tuple)) {        return false;    }    return true;}
5478cc5683f6dfd4515c383752d7c803555efc63d03fd84a03ba8dcd17eb4324
readFields
public void readFields(DataInput in) throws IOException
{    int len = in.readInt();    tuple = Lists.newArrayListWithCapacity(len);    Text value = new Text();    for (int i = 0; i < len; i++) {        value.readFields(in);        tuple.add(value.toString());    }}
a894510dd4db439ff8e17ae1059489dc3abc97178e5932ceed0c70c3af165401
write
public void write(DataOutput out) throws IOException
{    out.writeInt(tuple.size());    Text value = new Text();    for (String entry : tuple) {        value.set(entry);        value.write(out);    }}
d7c8e09b8f9af3d19f08649d5303580a5067464ebc44492dce0a0c219f6a354d
compareTo
public int compareTo(StringTuple otherTuple)
{    int thisLength = length();    int otherLength = otherTuple.length();    int min = Math.min(thisLength, otherLength);    for (int i = 0; i < min; i++) {        int ret = this.tuple.get(i).compareTo(otherTuple.stringAt(i));        if (ret != 0) {            return ret;        }    }    if (thisLength < otherLength) {        return -1;    } else if (thisLength > otherLength) {        return 1;    } else {        return 0;    }}
e28fef07240de6af2160247562cc1745cefa21efc22637531296fd1abaf86528
toString
public static String toString(Object obj)
{    return NEWLINE_PATTERN.matcher(XSTREAM.toXML(obj)).replaceAll("");}
edaca956362aef1e7b7bb64a316fa962aac390c3a9e6edf50b74669af80b5c4c
fromString
public static T fromString(String str)
{    return (T) XSTREAM.fromXML(str);}
397576d4a03598a9a253eb47b186aa648a8d2805d87fc907eb53ab14607dceff
escapeXML
public static String escapeXML(CharSequence input)
{    return XMLRESERVED.matcher(input).replaceAll("_");}
c3f8ac9528b5604154e8fb160ea6edb3ab4af79e770b5e92e20f6c9bffe7fd87
getNCalls
public synchronized int getNCalls()
{    return nCalls;}
80a809e79ae05a5572a91894df32a030126ce1ae25a12af1956f8e2958b0e8b6
getMinTime
public synchronized long getMinTime()
{    return Math.max(0, minTime);}
d42637d5c26686f1e85a13aa875298336e7ac5110633cd40efb2764ded023e73
getMaxTime
public synchronized long getMaxTime()
{    return maxTime;}
ceabbebabfe4346cb6756f97969d6b090d95e82fc820809a204601323517b8ac
getSumTime
public synchronized long getSumTime()
{    return sumTime;}
6786b24acae8cde24d90eee056e416fec692466cdfdd387a7c58ca158ec724e1
getSumSquaredTime
public synchronized double getSumSquaredTime()
{    return sumSquaredTime;}
7dc4dac1de13cbafe0c8dbbe6e96aa888a8d96d1ae2f56ab0b88a6d387f3b4c4
getMeanTime
public synchronized long getMeanTime()
{    return nCalls == 0 ? 0 : sumTime / nCalls;}
5749a710fe730c4b8e966c83350a6cafbe673ebbfea06c262ca7d6e02ecb0eb5
getStdDevTime
public synchronized long getStdDevTime()
{    if (nCalls == 0) {        return 0;    }    double mean = getMeanTime();    double meanSquared = mean * mean;    double meanOfSquares = sumSquaredTime / nCalls;    double variance = meanOfSquares - meanSquared;    if (variance < 0) {                return 0;    }    return (long) Math.sqrt(variance);}
ced683865ec943e6fb0f59cfe94f9b041011464836da39fedb553752fdfb3495
toString
public synchronized String toString()
{    return '\n' + "nCalls = " + nCalls + ";\n" + "sum    = " + DF.format(sumTime / 1000000000.0) + "s;\n" + "min    = " + DF.format(minTime / 1000000.0) + "ms;\n" + "max    = " + DF.format(maxTime / 1000000.0) + "ms;\n" + "mean   = " + DF.format(getMeanTime() / 1000.0) + "us;\n" + "stdDev = " + DF.format(getStdDevTime() / 1000.0) + "us;";}
d84e5fc17fb4482697d4bcbc35ccc210454afa3c87436c1c9df72bfaf9c8f14c
newCall
public Call newCall(long leadTimeUsec)
{    if (leadSumTime > leadTimeUsec) {        return new Call();    } else {        return new LeadTimeCall();    }}
16e0c84fcb88bd5556c4b60cf73c33a4c484d7a5e8681877940916bda10eeafb
end
public void end()
{    long elapsed = System.nanoTime() - startTime;    synchronized (TimingStatistics.this) {        leadSumTime += elapsed;    }}
502df1f51779a8a19927774abd1b5669325de128f4d13fcab84eb24c123d298a
end
public boolean end(long sumMaxUsec)
{    end();    return false;}
16e0c84fcb88bd5556c4b60cf73c33a4c484d7a5e8681877940916bda10eeafb
end
public void end()
{    long elapsed = System.nanoTime() - startTime;    synchronized (TimingStatistics.this) {        nCalls++;        if (elapsed < minTime || nCalls == 1) {            minTime = elapsed;        }        if (elapsed > maxTime) {            maxTime = elapsed;        }        sumTime += elapsed;        sumSquaredTime += elapsed * elapsed;    }}
502df1f51779a8a19927774abd1b5669325de128f4d13fcab84eb24c123d298a
end
public boolean end(long sumMaxUsec)
{    end();    return sumMaxUsec < sumTime;}
7c638f624c534cd8f6e10367a9b6d260d248e779d9308ff96e0146561b63f115
main
public static void main(String[] args) throws Throwable
{    Properties mainClasses = loadProperties("driver.classes.props");    if (mainClasses == null) {        mainClasses = loadProperties("driver.classes.default.props");    }    if (mainClasses == null) {        throw new IOException("Can't load any properties file?");    }    boolean foundShortName = false;    ProgramDriver programDriver = new ProgramDriver();    for (Object key : mainClasses.keySet()) {        String keyString = (String) key;        if (args.length > 0 && shortName(mainClasses.getProperty(keyString)).equals(args[0])) {            foundShortName = true;        }        if (args.length > 0 && keyString.equalsIgnoreCase(args[0]) && isDeprecated(mainClasses, keyString)) {            log.error(desc(mainClasses.getProperty(keyString)));            return;        }        if (isDeprecated(mainClasses, keyString)) {            continue;        }        addClass(programDriver, keyString, mainClasses.getProperty(keyString));    }    if (args.length < 1 || args[0] == null || "-h".equals(args[0]) || "--help".equals(args[0])) {        programDriver.driver(args);        return;    }    String progName = args[0];    if (!foundShortName) {        addClass(programDriver, progName, progName);    }    shift(args);    Properties mainProps = loadProperties(progName + ".props");    if (mainProps == null) {        log.warn("No {}.props found on classpath, will use command-line arguments only", progName);        mainProps = new Properties();    }    Map<String, String[]> argMap = new HashMap<>();    int i = 0;    while (i < args.length && args[i] != null) {        List<String> argValues = new ArrayList<>();        String arg = args[i];        i++;        if (arg.startsWith("-D")) {                        String[] argSplit = arg.split("=");            arg = argSplit[0];            if (argSplit.length == 2) {                argValues.add(argSplit[1]);            }        } else {                        while (i < args.length && args[i] != null) {                if (args[i].startsWith("-")) {                    break;                }                argValues.add(args[i]);                i++;            }        }        argMap.put(arg, argValues.toArray(new String[argValues.size()]));    }        for (String key : mainProps.stringPropertyNames()) {        String[] argNamePair = key.split("\\|");        String shortArg = '-' + argNamePair[0].trim();        String longArg = argNamePair.length < 2 ? null : "--" + argNamePair[1].trim();        if (!argMap.containsKey(shortArg) && (longArg == null || !argMap.containsKey(longArg))) {            argMap.put(longArg, new String[] { mainProps.getProperty(key) });        }    }        List<String> argsList = new ArrayList<>();    argsList.add(progName);    for (Map.Entry<String, String[]> entry : argMap.entrySet()) {        String arg = entry.getKey();        if (arg.startsWith("-D")) {                        String[] argValues = entry.getValue();            if (argValues.length > 0 && !argValues[0].trim().isEmpty()) {                arg += '=' + argValues[0].trim();            }            argsList.add(1, arg);        } else {            argsList.add(arg);            for (String argValue : Arrays.asList(argMap.get(arg))) {                if (!argValue.isEmpty()) {                    argsList.add(argValue);                }            }        }    }    long start = System.currentTimeMillis();    programDriver.driver(argsList.toArray(new String[argsList.size()]));    if (log.isInfoEnabled()) {        log.info("Program took {} ms (Minutes: {})", System.currentTimeMillis() - start, (System.currentTimeMillis() - start) / 60000.0);    }}
596f60de667c46117f5818154a1367cfa6c948e603f103d64d3544b0ade35c50
isDeprecated
private static boolean isDeprecated(Properties mainClasses, String keyString)
{    return "deprecated".equalsIgnoreCase(shortName(mainClasses.getProperty(keyString)));}
e45e5d85bf5464f08b5c18503cce4888a1459920234a7c6ba317f3852a8afd66
loadProperties
private static Properties loadProperties(String resource) throws IOException
{    InputStream propsStream = Thread.currentThread().getContextClassLoader().getResourceAsStream(resource);    if (propsStream != null) {        try {            Properties properties = new Properties();            properties.load(propsStream);            return properties;        } finally {            Closeables.close(propsStream, true);        }    }    return null;}
d4d841f662746962188cff6c1b29a6da864afa0a585541b44dd265b23f939f00
shift
private static String[] shift(String[] args)
{    System.arraycopy(args, 1, args, 0, args.length - 1);    args[args.length - 1] = null;    return args;}
743667f7822ca23bcf36a6596f2b21d7333ab6464bbb694dc5620a428f6719a8
shortName
private static String shortName(String valueString)
{    return valueString.contains(":") ? valueString.substring(0, valueString.indexOf(':')).trim() : valueString;}
ea64534cc32c5d1711a5a9995ad5f788c633dcc4dc9b70892e30f6df1dbcfb29
desc
private static String desc(String valueString)
{    return valueString.contains(":") ? valueString.substring(valueString.indexOf(':')).trim() : valueString;}
de2de39327e0eaeaf2e3bcba035791222c5dad7cb764ae061942d212420af074
addClass
private static void addClass(ProgramDriver driver, String classString, String descString)
{    try {        Class<?> clazz = Class.forName(classString);        driver.addClass(shortName(descString), clazz, desc(descString));    } catch (Throwable t) {        log.warn("Unable to add class: {}", classString, t);    }}
f2be468d88466dfba4652980f513046d3ffc555856d647166c7be9c883abe7f3
initializePopulation
private void initializePopulation(int populationSize, State<T, U> seed)
{    population = Lists.newArrayList(seed);    for (int i = 0; i < populationSize; i++) {        population.add(seed.mutate());    }}
8d410a43e65561f741fee7ffa1f0ea9347a6e03b86f0795f0d65f1735a36a940
add
public void add(State<T, U> value)
{    population.add(value);}
ccd2d71c49fcee4c4cf6c44aca853925e3923394ec4ff5db31bf5f51ed9a9866
mutatePopulation
public void mutatePopulation(int survivors)
{        Collections.sort(population);        List<State<T, U>> parents = new ArrayList<>(population.subList(0, survivors));    population.subList(survivors, population.size()).clear();        int i = 0;    while (population.size() < populationSize) {        population.add(parents.get(i % survivors).mutate());        i++;    }}
abc7b137eecd830c4dc07c75db8eec75965ecc5654c1c5490306359da82ce07c
parallelDo
public State<T, U> parallelDo(final Function<Payload<U>> fn) throws InterruptedException, ExecutionException
{    Collection<Callable<State<T, U>>> tasks = new ArrayList<>();    for (final State<T, U> state : population) {        tasks.add(new Callable<State<T, U>>() {            @Override            public State<T, U> call() {                double v = fn.apply(state.getPayload(), state.getMappedParams());                state.setValue(v);                return state;            }        });    }    List<Future<State<T, U>>> r = pool.invokeAll(tasks);        double max = Double.NEGATIVE_INFINITY;    State<T, U> best = null;    for (Future<State<T, U>> future : r) {        State<T, U> s = future.get();        double value = s.getValue();        if (!Double.isNaN(value) && value >= max) {            max = value;            best = s;        }    }    if (best == null) {        best = r.get(0).get();    }    return best;}
a2c2c90df4f2f1b4439ac76062522933df1e5128c95133cc319475ff29d05f50
call
public State<T, U> call()
{    double v = fn.apply(state.getPayload(), state.getMappedParams());    state.setValue(v);    return state;}
ec8febfef1b6924b8bae754a6d6a581e2abee70302b9d6f512585cfc42907429
setThreadCount
public void setThreadCount(int threadCount)
{    this.threadCount = threadCount;    pool = Executors.newFixedThreadPool(threadCount);}
bac006956467504feb005046f28ada07004728c2e1144cbae7bf2806bb73eb59
getThreadCount
public int getThreadCount()
{    return threadCount;}
b1b01bf216306728f5ec4d313ccd508a5e1eaf1f13b84cc24209c1ba0d8f1476
getPopulationSize
public int getPopulationSize()
{    return populationSize;}
87dd8da57ffb4aad5485145977ea7acc7ece1e76c9f9ad66c032af291a9532c6
getPopulation
public List<State<T, U>> getPopulation()
{    return population;}
5df6118bc0e745d8b18e0a6a99b2e3f2ddba8140cbeb1423ce2df50a9f140574
close
public void close()
{    List<Runnable> remainingTasks = pool.shutdownNow();    try {        pool.awaitTermination(10, TimeUnit.SECONDS);    } catch (InterruptedException e) {        throw new IllegalStateException("Had to forcefully shut down " + remainingTasks.size() + " tasks");    }    if (!remainingTasks.isEmpty()) {        throw new IllegalStateException("Had to forcefully shut down " + remainingTasks.size() + " tasks");    }}
a894510dd4db439ff8e17ae1059489dc3abc97178e5932ceed0c70c3af165401
write
public void write(DataOutput out) throws IOException
{    out.writeInt(threadCount);    out.writeInt(population.size());    for (State<T, U> state : population) {        PolymorphicWritable.write(out, state);    }}
4529dacced0bb2cd63ef71d2039f49f0abb0523ab627a4bd0828ea7a38fadaf8
readFields
public void readFields(DataInput input) throws IOException
{    setThreadCount(input.readInt());    int n = input.readInt();    population = new ArrayList<>();    for (int i = 0; i < n; i++) {        State<T, U> state = (State<T, U>) PolymorphicWritable.read(input, State.class);        population.add(state);    }}
0b41a4c0ac574be18fedcf88e7465eddcb1f8f1a3ad9bbb36e6b37f373bd3830
apply
public double apply(double v)
{    return min + (max - min) * 1 / (1 + Math.exp(-v * scale));}
a894510dd4db439ff8e17ae1059489dc3abc97178e5932ceed0c70c3af165401
write
public void write(DataOutput out) throws IOException
{    out.writeDouble(min);    out.writeDouble(max);    out.writeDouble(scale);}
5478cc5683f6dfd4515c383752d7c803555efc63d03fd84a03ba8dcd17eb4324
readFields
public void readFields(DataInput in) throws IOException
{    min = in.readDouble();    max = in.readDouble();    scale = in.readDouble();}
0b41a4c0ac574be18fedcf88e7465eddcb1f8f1a3ad9bbb36e6b37f373bd3830
apply
public double apply(double v)
{    return Math.exp(wrapped.apply(v));}
5493eeee7f85bd6fb70c717b366e2363863946d32d71ebd52274dfb03a86cae5
write
public void write(DataOutput dataOutput) throws IOException
{    PolymorphicWritable.write(dataOutput, wrapped);}
5478cc5683f6dfd4515c383752d7c803555efc63d03fd84a03ba8dcd17eb4324
readFields
public void readFields(DataInput in) throws IOException
{    wrapped = PolymorphicWritable.read(in, Mapping.class);}
0b41a4c0ac574be18fedcf88e7465eddcb1f8f1a3ad9bbb36e6b37f373bd3830
apply
public double apply(double v)
{    return Math.exp(v * scale);}
a894510dd4db439ff8e17ae1059489dc3abc97178e5932ceed0c70c3af165401
write
public void write(DataOutput out) throws IOException
{    out.writeDouble(scale);}
5478cc5683f6dfd4515c383752d7c803555efc63d03fd84a03ba8dcd17eb4324
readFields
public void readFields(DataInput in) throws IOException
{    scale = in.readDouble();}
0b41a4c0ac574be18fedcf88e7465eddcb1f8f1a3ad9bbb36e6b37f373bd3830
apply
public double apply(double v)
{    return v;}
fdda3dd4719c24fd3bf0ec12c139c67fce44af9102aff6e64a498980013d0273
write
public void write(DataOutput dataOutput)
{}
6f75de95ae6a1e4b3b9117c4663acaa818fdfff49c9d509b008b7405d2292d28
readFields
public void readFields(DataInput dataInput)
{}
85a1ec7740fbb161640d4e9d31a65a6963d5da1142ecd104b55a3c2088ddfd36
softLimit
public static Mapping softLimit(double min, double max, double scale)
{    return new SoftLimit(min, max, scale);}
95a6bc8c44d62a2e4dd59bf36dcb0ec63d3b012f6f31cd246c7b2d0ff08c5c22
softLimit
public static Mapping softLimit(double min, double max)
{    return softLimit(min, max, 1);}
b7a128562ab5a51dffd912b07cdf0467e715efe7e36e3086e540d1a086c5515e
logLimit
public static Mapping logLimit(double low, double high)
{    Preconditions.checkArgument(low > 0, "Lower bound for log limit must be > 0 but was %f", low);    Preconditions.checkArgument(high > 0, "Upper bound for log limit must be > 0 but was %f", high);    return new LogLimit(low, high);}
ddf1aacf21291ed657d5221b05b1db76685a6277d219ba16caa59eabaa3986fe
exponential
public static Mapping exponential()
{    return exponential(1);}
8d89b201087737be655e9a68d6c981c9ce1cb25db89d989e5a856118d3d8844b
exponential
public static Mapping exponential(double scale)
{    return new Exponential(scale);}
9a0f66df52c7e5a052f99fda8eece583c1625f31b26a4ecbd81906d3d96a5163
identity
public static Mapping identity()
{    return new Identity();}
8eed21ae84f76d89b0a185bf5740a1a530bec9f097833052f55bfcdd4c112cc3
copy
public State<T, U> copy()
{    State<T, U> r = new State<>();    r.params = Arrays.copyOf(this.params, this.params.length);    r.omni = this.omni;    r.step = Arrays.copyOf(this.step, this.step.length);    r.maps = Arrays.copyOf(this.maps, this.maps.length);    if (this.payload != null) {        r.payload = (T) this.payload.copy();    }    r.gen = this.gen;    return r;}
d5351e7e9d23dba07240b885ddeb33d3b8b14ecdb6e27b310fa302fd2ba7c93b
mutate
public State<T, U> mutate()
{    double sum = 0;    for (double v : step) {        sum += v * v;    }    sum = Math.sqrt(sum);    double lambda = 1 + gen.nextGaussian();    State<T, U> r = this.copy();    double magnitude = 0.9 * omni + sum / 10;    r.omni = magnitude * -Math.log1p(-gen.nextDouble());    for (int i = 0; i < step.length; i++) {        r.step[i] = lambda * step[i] + r.omni * gen.nextGaussian();        r.params[i] += r.step[i];    }    if (this.payload != null) {        r.payload.update(r.getMappedParams());    }    return r;}
ebbba6ddc14bd1ade4fe119ceead356be59238ebc5382a2805fdb8c6cc9cee37
setMap
public void setMap(int i, Mapping m)
{    maps[i] = m;}
e7e99c0bfd334ab7a04cf1ad6ca4530b1a1ddcb67a6c344f5282eff426681972
get
public double get(int i)
{    Mapping m = maps[i];    return m == null ? params[i] : m.apply(params[i]);}
cea1c2c1f10d4b97004da212612fc3f2159fe44d7c7e24cd3c5e70653f0143a5
getId
public int getId()
{    return id;}
489536269dd2a8045d6cc184b0a76854d5c8504d1da7debd1ca2915cb1f8804d
getParams
public double[] getParams()
{    return params;}
7eb710e6f64453981b0f03f54c7c3a4918f22bbd2710d7b5dd948308e84982f9
getMaps
public Mapping[] getMaps()
{    return maps;}
c0b222b989418a773fa15fb68145ee0e91c60c5ffca14d37770307abd4af5c22
getMappedParams
public double[] getMappedParams()
{    double[] r = Arrays.copyOf(params, params.length);    for (int i = 0; i < params.length; i++) {        r[i] = get(i);    }    return r;}
9caf05401cfb48c1bb2ca441c2e658510d1b47ca521e6edfd55bdef33484ce79
getOmni
public double getOmni()
{    return omni;}
ccee592cdd22d4d6991e6320854fe41131aed25eb7da5b35e3394589e19380d4
getStep
public double[] getStep()
{    return step;}
51556ec87a6e3a239ccb0b3de9d1dff54c284250b0c7fdd45d032a2b636c753e
getPayload
public T getPayload()
{    return payload;}
baa2719ad2de5db523d278575928af9560575a9fbdd5a41694812df8ea43af94
getValue
public double getValue()
{    return value;}
328cf1a7950d4867d2b7f0d8d37a88f1f80a071c21b968cf6069e869f6193c8f
setOmni
public void setOmni(double omni)
{    this.omni = omni;}
7062c1bfe9919ab8c7f67a87a016d04f81ac6c31a31838d4009b2440a3dec97c
setId
public void setId(int id)
{    this.id = id;}
95bfab7425fe873ff0fa075915387948f8523715a89daf929b63dfda09af9524
setStep
public void setStep(double[] step)
{    this.step = step;}
369a92a155fd3f1d8d92f5e66bdb1eb9b7c71b30e3d6c791b7be0eb034436140
setMaps
public void setMaps(Mapping[] maps)
{    this.maps = maps;}
423ebb8652d274e084e21412a1483adaea098f5fc97858818ff602ba7a5b5c2a
setMaps
public void setMaps(Iterable<Mapping> maps)
{    Collection<Mapping> list = Lists.newArrayList(maps);    this.maps = list.toArray(new Mapping[list.size()]);}
0c4ca37504282910080f62f5785d0f28a8c912117324f8aab9936861b6efc111
setValue
public void setValue(double v)
{    value = v;}
007277185dc2a1cca4cfb764881f8863f2983b6f0b265ab0af23914f61778fa2
setPayload
public void setPayload(T payload)
{    this.payload = payload;}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (!(o instanceof State)) {        return false;    }    State<?, ?> other = (State<?, ?>) o;    return id == other.id && value == other.value;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return RandomUtils.hashDouble(value) ^ id;}
ff7bda4e57a76f15db031cd164f56d3193ac1fd4fe6f30d997eed712d1b09826
compareTo
public int compareTo(State<T, U> other)
{    int r = Double.compare(other.value, this.value);    if (r != 0) {        return r;    }    if (this.id < other.id) {        return -1;    }    if (this.id > other.id) {        return 1;    }    return 0;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    double sum = 0;    for (double v : step) {        sum += v * v;    }    return String.format(Locale.ENGLISH, "<S/%s %.3f %.3f>", payload, omni + Math.sqrt(sum), value);}
a894510dd4db439ff8e17ae1059489dc3abc97178e5932ceed0c70c3af165401
write
public void write(DataOutput out) throws IOException
{    out.writeInt(id);    out.writeInt(params.length);    for (double v : params) {        out.writeDouble(v);    }    for (Mapping map : maps) {        PolymorphicWritable.write(out, map);    }    out.writeDouble(omni);    for (double v : step) {        out.writeDouble(v);    }    out.writeDouble(value);    PolymorphicWritable.write(out, payload);}
4529dacced0bb2cd63ef71d2039f49f0abb0523ab627a4bd0828ea7a38fadaf8
readFields
public void readFields(DataInput input) throws IOException
{    id = input.readInt();    int n = input.readInt();    params = new double[n];    for (int i = 0; i < n; i++) {        params[i] = input.readDouble();    }    maps = new Mapping[n];    for (int i = 0; i < n; i++) {        maps[i] = PolymorphicWritable.read(input, Mapping.class);    }    omni = input.readDouble();    step = new double[n];    for (int i = 0; i < n; i++) {        step[i] = input.readDouble();    }    value = input.readDouble();    payload = (T) PolymorphicWritable.read(input, Payload.class);}
da2a6a1a3a33a43ee2d56a506d14bf8b44d3778a2f866d8eda92c91ff6eb866c
solve
public static Vector solve(Iterable<Vector> featureVectors, Vector ratingVector, double lambda, int numFeatures)
{    Preconditions.checkNotNull(featureVectors, "Feature Vectors cannot be null");    Preconditions.checkArgument(!Iterables.isEmpty(featureVectors));    Preconditions.checkNotNull(ratingVector, "Rating Vector cannot be null");    Preconditions.checkArgument(ratingVector.getNumNondefaultElements() > 0, "Rating Vector cannot be empty");    Preconditions.checkArgument(Iterables.size(featureVectors) == ratingVector.getNumNondefaultElements());    int nui = ratingVector.getNumNondefaultElements();    Matrix MiIi = createMiIi(featureVectors, numFeatures);    Matrix RiIiMaybeTransposed = createRiIiMaybeTransposed(ratingVector);    /* compute Ai = MiIi * t(MiIi) + lambda * nui * E */    Matrix Ai = miTimesMiTransposePlusLambdaTimesNuiTimesE(MiIi, lambda, nui);    /* compute Vi = MiIi * t(R(i,Ii)) */    Matrix Vi = MiIi.times(RiIiMaybeTransposed);    /* compute Ai * ui = Vi */    return solve(Ai, Vi);}
596a2864f721ea4fa313cbfdbaae46ed0a3aba4827cbdb185357e888b27d4e23
solve
private static Vector solve(Matrix Ai, Matrix Vi)
{    return new QRDecomposition(Ai).solve(Vi).viewColumn(0);}
b03dfde4ffd89b3f4f8655a0922bd69ec98030b8a42edb535cc6cb3e71779b60
addLambdaTimesNuiTimesE
 static Matrix addLambdaTimesNuiTimesE(Matrix matrix, double lambda, int nui)
{    Preconditions.checkArgument(matrix.numCols() == matrix.numRows(), "Must be a Square Matrix");    double lambdaTimesNui = lambda * nui;    int numCols = matrix.numCols();    for (int n = 0; n < numCols; n++) {        matrix.setQuick(n, n, matrix.getQuick(n, n) + lambdaTimesNui);    }    return matrix;}
b26d9e8582fcfa0bf1e36ee988565be0f0c0201f86e3c37a9703a81ec59e1256
miTimesMiTransposePlusLambdaTimesNuiTimesE
private static Matrix miTimesMiTransposePlusLambdaTimesNuiTimesE(Matrix MiIi, double lambda, int nui)
{    double lambdaTimesNui = lambda * nui;    int rows = MiIi.numRows();    double[][] result = new double[rows][rows];    for (int i = 0; i < rows; i++) {        for (int j = i; j < rows; j++) {            double dot = MiIi.viewRow(i).dot(MiIi.viewRow(j));            if (i != j) {                result[i][j] = dot;                result[j][i] = dot;            } else {                result[i][i] = dot + lambdaTimesNui;            }        }    }    return new DenseMatrix(result, true);}
877ec878437486426c3641d63f34661f90091706db862b0f2819bfd7d61df3c4
createMiIi
 static Matrix createMiIi(Iterable<Vector> featureVectors, int numFeatures)
{    double[][] MiIi = new double[numFeatures][Iterables.size(featureVectors)];    int n = 0;    for (Vector featureVector : featureVectors) {        for (int m = 0; m < numFeatures; m++) {            MiIi[m][n] = featureVector.getQuick(m);        }        n++;    }    return new DenseMatrix(MiIi, true);}
06193d23855b4d06caf24a4995bb7c13b76bc4daef59db5676ad2c073bebfc42
createRiIiMaybeTransposed
 static Matrix createRiIiMaybeTransposed(Vector ratingVector)
{    Preconditions.checkArgument(ratingVector.isSequentialAccess(), "Ratings should be iterable in Index or Sequential Order");    double[][] RiIiMaybeTransposed = new double[ratingVector.getNumNondefaultElements()][1];    int index = 0;    for (Vector.Element elem : ratingVector.nonZeroes()) {        RiIiMaybeTransposed[index++][0] = elem.get();    }    return new DenseMatrix(RiIiMaybeTransposed, true);}
498dd3cec8a94508584eaa30f27ab53559c0ae9f44eea116d55b47c5e674b64e
solve
public Vector solve(Vector ratings)
{    return solve(YtransposeY.plus(getYtransponseCuMinusIYPlusLambdaI(ratings)), getYtransponseCuPu(ratings));}
40c327a54c54bff2e9c2192d47776695dced2cc4e2a921977521a108aa68253c
solve
private static Vector solve(Matrix A, Matrix y)
{    return new QRDecomposition(A).solve(y).viewColumn(0);}
407d6587ec98cd1c9e602196e03b02a7d0d0dc0d181106e0fe22ced8e386974a
confidence
 double confidence(double rating)
{    return 1 + alpha * rating;}
30973ab21d3e2f74525ac6cc3410383cc98ad8aef2885942fe948369b81a114a
getYtransposeY
public Matrix getYtransposeY(final OpenIntObjectHashMap<Vector> Y)
{    ExecutorService queue = Executors.newFixedThreadPool(numTrainingThreads);    if (log.isInfoEnabled()) {        log.info("Starting the computation of Y'Y");    }    long startTime = System.nanoTime();    final IntArrayList indexes = Y.keys();    final int numIndexes = indexes.size();    final double[][] YtY = new double[numFeatures][numFeatures];        for (int i = 0; i < numFeatures; i++) {        for (int j = i; j < numFeatures; j++) {            final int ii = i;            final int jj = j;            queue.execute(new Runnable() {                @Override                public void run() {                    double dot = 0;                    for (int k = 0; k < numIndexes; k++) {                        Vector row = Y.get(indexes.getQuick(k));                        dot += row.getQuick(ii) * row.getQuick(jj);                    }                    YtY[ii][jj] = dot;                    if (ii != jj) {                        YtY[jj][ii] = dot;                    }                }            });        }    }    queue.shutdown();    try {        queue.awaitTermination(1, TimeUnit.DAYS);    } catch (InterruptedException e) {        log.error("Error during Y'Y queue shutdown", e);        throw new RuntimeException("Error during Y'Y queue shutdown");    }    if (log.isInfoEnabled()) {        log.info("Computed Y'Y in " + (System.nanoTime() - startTime) / 1000000.0 + " ms");    }    return new DenseMatrix(YtY, true);}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    double dot = 0;    for (int k = 0; k < numIndexes; k++) {        Vector row = Y.get(indexes.getQuick(k));        dot += row.getQuick(ii) * row.getQuick(jj);    }    YtY[ii][jj] = dot;    if (ii != jj) {        YtY[jj][ii] = dot;    }}
b7916f243b5edd193049e76e473a9ffeb7fbf878799f8985adacb22c5900300c
getYtransponseCuMinusIYPlusLambdaI
private Matrix getYtransponseCuMinusIYPlusLambdaI(Vector userRatings)
{    Preconditions.checkArgument(userRatings.isSequentialAccess(), "need sequential access to ratings!");    /* (Cu -I) Y */    OpenIntObjectHashMap<Vector> CuMinusIY = new OpenIntObjectHashMap<>(userRatings.getNumNondefaultElements());    for (Element e : userRatings.nonZeroes()) {        CuMinusIY.put(e.index(), Y.get(e.index()).times(confidence(e.get()) - 1));    }    Matrix YtransponseCuMinusIY = new DenseMatrix(numFeatures, numFeatures);    /* Y' (Cu -I) Y by outer products */    for (Element e : userRatings.nonZeroes()) {        for (Element feature : Y.get(e.index()).all()) {            Vector partial = CuMinusIY.get(e.index()).times(feature.get());            YtransponseCuMinusIY.viewRow(feature.index()).assign(partial, Functions.PLUS);        }    }    /* Y' (Cu - I) Y +  I  add lambda on the diagonal */    for (int feature = 0; feature < numFeatures; feature++) {        YtransponseCuMinusIY.setQuick(feature, feature, YtransponseCuMinusIY.getQuick(feature, feature) + lambda);    }    return YtransponseCuMinusIY;}
901e54a93199937889a093922db64a3e39e4a1595dc5ce12801d4756d891b66a
getYtransponseCuPu
private Matrix getYtransponseCuPu(Vector userRatings)
{    Preconditions.checkArgument(userRatings.isSequentialAccess(), "need sequential access to ratings!");    Vector YtransponseCuPu = new DenseVector(numFeatures);    for (Element e : userRatings.nonZeroes()) {        YtransponseCuPu.assign(Y.get(e.index()).times(confidence(e.get())), Functions.PLUS);    }    return columnVectorAsMatrix(YtransponseCuPu);}
2c644c566ebbc0740a4f5ed5a252d0aabd070e25bb69b4693573b82210d6f3be
columnVectorAsMatrix
private Matrix columnVectorAsMatrix(Vector v)
{    double[][] matrix = new double[numFeatures][1];    for (Element e : v.all()) {        matrix[e.index()][0] = e.get();    }    return new DenseMatrix(matrix, true);}
8a74e74838715a5ca525c7f36638cc1556efbab476ac10bef27168638a19436a
verify
public synchronized EigenStatus verify(VectorIterable corpus, Vector vector)
{    if (!finished && !started) {                status = new EigenStatus(-1, 0);        Vector vectorCopy = vector.clone();        threadPool.execute(new VerifierRunnable(corpus, vectorCopy));        started = true;    }    if (finished) {        finished = false;    }    return status;}
5df6118bc0e745d8b18e0a6a99b2e3f2ddba8140cbeb1423ce2df50a9f140574
close
public void close()
{    this.threadPool.shutdownNow();}
258f4f7da1eba58a9456a3e15cc58a69627076f1b3945143eb987c060116d93a
innerVerify
protected EigenStatus innerVerify(VectorIterable corpus, Vector vector)
{    return super.verify(corpus, vector);}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    EigenStatus status = innerVerify(corpus, vector);    synchronized (AsyncEigenVerifier.this) {        AsyncEigenVerifier.this.status = status;        finished = true;        started = false;    }}
28c9a2a9ce99ee7fdbe47a37d6eb72fc14e5511a49d2e6e5db51fccd1b0afa4d
getCosAngle
public double getCosAngle()
{    return cosAngle;}
4058e4532084f24dabc50038c1941965a39203c3d72df2d0e8ccf6d081089682
getEigenValue
public double getEigenValue()
{    return eigenValue;}
73bce2d804cbc17048bbbad5122def51173f11e83071d76426e4ece4bfb0ce76
inProgress
public boolean inProgress()
{    return inProgress;}
887e6644b62c52bb596d9515a5ba601472c2d82033568234acb4f938620bc404
setInProgress
 void setInProgress(boolean status)
{    inProgress = status;}
cc6a0c8135755644afa333b21e6f89ebb7d0f13c05937a07c5388320130ce157
solve
public TrainingState solve(Matrix corpus, int desiredRank)
{    int cols = corpus.numCols();    Matrix eigens = new DenseMatrix(desiredRank, cols);    List<Double> eigenValues = new ArrayList<>();    log.info("Finding {} singular vectors of matrix with {} rows, via Hebbian", desiredRank, corpus.numRows());    /*     * The corpusProjections matrix is a running cache of the residual projection of each corpus vector against all     * of the previously found singular vectors.  Without this, if multiple passes over the data is made (per     * singular vector), recalculating these projections eventually dominates the computational complexity of the     * solver.     */    Matrix corpusProjections = new DenseMatrix(corpus.numRows(), desiredRank);    TrainingState state = new TrainingState(eigens, corpusProjections);    for (int i = 0; i < desiredRank; i++) {        Vector currentEigen = new DenseVector(cols);        Vector previousEigen = null;        while (hasNotConverged(currentEigen, corpus, state)) {            int randomStartingIndex = getRandomStartingIndex(corpus, eigens);            Vector initialTrainingVector = corpus.viewRow(randomStartingIndex);            state.setTrainingIndex(randomStartingIndex);            updater.update(currentEigen, initialTrainingVector, state);            for (int corpusRow = 0; corpusRow < corpus.numRows(); corpusRow++) {                state.setTrainingIndex(corpusRow);                if (corpusRow != randomStartingIndex) {                    updater.update(currentEigen, corpus.viewRow(corpusRow), state);                }            }            state.setFirstPass(false);            if (DEBUG) {                if (previousEigen == null) {                    previousEigen = currentEigen.clone();                } else {                    double dot = currentEigen.dot(previousEigen);                    if (dot > 0.0) {                        dot /= currentEigen.norm(2) * previousEigen.norm(2);                    }                                }            }        }                double eigenValue = state.getStatusProgress().get(state.getStatusProgress().size() - 1).getEigenValue();                        currentEigen.assign(new TimesFunction(), 1 / currentEigen.norm(2));        eigens.assignRow(i, currentEigen);        eigenValues.add(eigenValue);        state.setCurrentEigenValues(eigenValues);        log.info("Found eigenvector {}, eigenvalue: {}", i, eigenValue);        /**         *  TODO: Persist intermediate output!         */        state.setFirstPass(true);        state.setNumEigensProcessed(state.getNumEigensProcessed() + 1);        state.setActivationDenominatorSquared(0);        state.setActivationNumerator(0);        state.getStatusProgress().clear();        numPasses = 0;    }    return state;}
091dd24a122e7d92db865f4f0abe3dd79e1c362ea7848b3f399f914e50f6d2ef
getRandomStartingIndex
private int getRandomStartingIndex(Matrix corpus, Matrix eigens)
{    int index;    Vector v;    do {        double r = rng.nextDouble();        index = (int) (r * corpus.numRows());        v = corpus.viewRow(index);    } while (v == null || v.norm(2) == 0 || v.getNumNondefaultElements() < 5);    return index;}
c1ae7fa04fc65a725bb404ef58ca6c6801786fbe90216f78c52e3cdd33708573
hasNotConverged
protected boolean hasNotConverged(Vector currentPseudoEigen, Matrix corpus, TrainingState state)
{    numPasses++;    if (state.isFirstPass()) {        log.info("First pass through the corpus, no need to check convergence...");        return true;    }    Matrix previousEigens = state.getCurrentEigens();    log.info("Have made {} passes through the corpus, checking convergence...", numPasses);    /*     * Step 1: orthogonalize currentPseudoEigen by subtracting off eigen(i) * helper.get(i)     * Step 2: zero-out the helper vector because it has already helped.     */    for (int i = 0; i < state.getNumEigensProcessed(); i++) {        Vector previousEigen = previousEigens.viewRow(i);        currentPseudoEigen.assign(previousEigen, new PlusMult(-state.getHelperVector().get(i)));        state.getHelperVector().set(i, 0);    }    if (currentPseudoEigen.norm(2) > 0) {        for (int i = 0; i < state.getNumEigensProcessed(); i++) {            Vector previousEigen = previousEigens.viewRow(i);            log.info("dot with previous: {}", previousEigen.dot(currentPseudoEigen) / currentPseudoEigen.norm(2));        }    }    /*     * Step 3: verify how eigen-like the prospective eigen is.  This is potentially asynchronous.     */    EigenStatus status = verify(corpus, currentPseudoEigen);    if (status.inProgress()) {        log.info("Verifier not finished, making another pass...");    } else {        log.info("Has 1 - cosAngle: {}, convergence target is: {}", 1.0 - status.getCosAngle(), convergenceTarget);        state.getStatusProgress().add(status);    }    return state.getStatusProgress().size() <= maxPassesPerEigen && 1.0 - status.getCosAngle() > convergenceTarget;}
a6fa688d0ae73cada96f255df643c3d6fce7a5db22166502a31f24c86216de12
verify
protected EigenStatus verify(Matrix corpus, Vector currentPseudoEigen)
{    return verifier.verify(corpus, currentPseudoEigen);}
3116ea2053d9de960ec3753eb07f3d243c370662aa1f0175ad357057c9ce5a52
main
public static void main(String[] args)
{    Properties props = new Properties();    String propertiesFile = args.length > 0 ? args[0] : "config/solver.properties";        String corpusDir = props.getProperty("solver.input.dir");    String outputDir = props.getProperty("solver.output.dir");    if (corpusDir == null || corpusDir.isEmpty() || outputDir == null || outputDir.isEmpty()) {        log.error("{} must contain values for solver.input.dir and solver.output.dir", propertiesFile);        return;    }        int rank = Integer.parseInt(props.getProperty("solver.output.desiredRank"));    double convergence = Double.parseDouble(props.getProperty("solver.convergence"));    int maxPasses = Integer.parseInt(props.getProperty("solver.maxPasses"));        HebbianUpdater updater = new HebbianUpdater();    SingularVectorVerifier verifier = new AsyncEigenVerifier();    HebbianSolver solver = new HebbianSolver(updater, verifier, convergence, maxPasses);    Matrix corpus = null;    /*    if (numThreads <= 1) {          } else {          }     */    long now = System.currentTimeMillis();    TrainingState finalState = solver.solve(corpus, rank);    long time = (System.currentTimeMillis() - now) / 1000;    log.info("Solved {} eigenVectors in {} seconds.  Persisted to {}", finalState.getCurrentEigens().rowSize(), time, outputDir);}
c2b74c5953c7ed4bf313290e3962599cc18bf8e8b6e0c37bd70bc086f0c8592f
update
public void update(Vector pseudoEigen, Vector trainingVector, TrainingState currentState)
{    double trainingVectorNorm = trainingVector.norm(2);    int numPreviousEigens = currentState.getNumEigensProcessed();    if (numPreviousEigens > 0 && currentState.isFirstPass()) {        updateTrainingProjectionsVector(currentState, trainingVector, numPreviousEigens - 1);    }    if (currentState.getActivationDenominatorSquared() == 0 || trainingVectorNorm == 0) {        if (currentState.getActivationDenominatorSquared() == 0) {            pseudoEigen.assign(trainingVector, new PlusMult(1));            currentState.setHelperVector(currentState.currentTrainingProjection().clone());            double helperNorm = currentState.getHelperVector().norm(2);            currentState.setActivationDenominatorSquared(trainingVectorNorm * trainingVectorNorm - helperNorm * helperNorm);        }        return;    }    currentState.setActivationNumerator(pseudoEigen.dot(trainingVector));    currentState.setActivationNumerator(currentState.getActivationNumerator() - currentState.getHelperVector().dot(currentState.currentTrainingProjection()));    double activation = currentState.getActivationNumerator() / Math.sqrt(currentState.getActivationDenominatorSquared());    currentState.setActivationDenominatorSquared(currentState.getActivationDenominatorSquared() + 2 * activation * currentState.getActivationNumerator() + activation * activation * (trainingVector.getLengthSquared() - currentState.currentTrainingProjection().getLengthSquared()));    if (numPreviousEigens > 0) {        currentState.getHelperVector().assign(currentState.currentTrainingProjection(), new PlusMult(activation));    }    pseudoEigen.assign(trainingVector, new PlusMult(activation));}
275f596f20040e40d29deb0847a62a1c20df524e4000f229af500c3ed686f985
updateTrainingProjectionsVector
private static void updateTrainingProjectionsVector(TrainingState state, Vector trainingVector, int previousEigenIndex)
{    Vector previousEigen = state.mostRecentEigen();    Vector currentTrainingVectorProjection = state.currentTrainingProjection();    double projection = previousEigen.dot(trainingVector);    currentTrainingVectorProjection.set(previousEigenIndex, projection);}
de6677c196a3bed71868457ed8d0e979e271ba07ca3c1f0a145d053170d51fa7
mostRecentEigen
public Vector mostRecentEigen()
{    return currentEigens.viewRow(numEigensProcessed - 1);}
b05c5269f37fb78943ca7a11ec4c99f0584f09dc177ac145d0d05bb28dcdcece
currentTrainingProjection
public Vector currentTrainingProjection()
{    if (trainingProjections.viewRow(trainingIndex) == null) {        trainingProjections.assignRow(trainingIndex, new DenseVector(currentEigens.numCols()));    }    return trainingProjections.viewRow(trainingIndex);}
adef8f63f498d6cce2b26f0781a31ff1a35288606d8552dcf760fb2e964ad495
getCurrentEigens
public Matrix getCurrentEigens()
{    return currentEigens;}
6e2c6440b39276e1fb62edf63cc4ff25f1b636f3e819a026bc710ca921220580
setCurrentEigens
public void setCurrentEigens(Matrix currentEigens)
{    this.currentEigens = currentEigens;}
b414bf67471d0b2142c3d38a5fe71ef55f1b920b028b64bcdcc909921d1d5eb2
getNumEigensProcessed
public int getNumEigensProcessed()
{    return numEigensProcessed;}
8011faf375104de51dee374741ad5fdee063baec153ff80f77cfb0add77b721b
setNumEigensProcessed
public void setNumEigensProcessed(int numEigensProcessed)
{    this.numEigensProcessed = numEigensProcessed;}
28add04a1a80b723cc28d6f4b30117fba52aee068ad8f7e3c05075a9de28deb6
getCurrentEigenValues
public List<Double> getCurrentEigenValues()
{    return currentEigenValues;}
6c816e083d2fd67ca62dec205b573128c3a87e17358f8731fc57770335304f73
setCurrentEigenValues
public void setCurrentEigenValues(List<Double> currentEigenValues)
{    this.currentEigenValues = currentEigenValues;}
ae115b6314197ed5edbf0a8f70a8c14d7deca95c02c58b064ea1be0e80928458
getTrainingProjections
public Matrix getTrainingProjections()
{    return trainingProjections;}
1cfc9cb4e6991041afea80d92b04597f6e9e9a0c151f7b007907cffed37c9035
setTrainingProjections
public void setTrainingProjections(Matrix trainingProjections)
{    this.trainingProjections = trainingProjections;}
0d4549f9152cfc6f2ad1436a50a90e5d3a3c1eb91c94a934b85b05e760b4853c
getTrainingIndex
public int getTrainingIndex()
{    return trainingIndex;}
ae3a8694129f57e2983935dc38d81af0f7556008beb9bfc2cf0d43ddae79f845
setTrainingIndex
public void setTrainingIndex(int trainingIndex)
{    this.trainingIndex = trainingIndex;}
7127b90fc0e20943e0036dad47f12431f06606e17f7732b9825b2ca8b489b4e8
getHelperVector
public Vector getHelperVector()
{    return helperVector;}
53bcf6882603d28cc7baec4afd6f382a76980bb3114de0a4e73cb2b3a6f825e9
setHelperVector
public void setHelperVector(Vector helperVector)
{    this.helperVector = helperVector;}
492bf91eb573b51b05054f05bfba7a04b5bb04755046907538c2eaaf2fb58ae1
isFirstPass
public boolean isFirstPass()
{    return firstPass;}
b4c7a92f609ba9331cf0b9d363b0671644e0137da1d85e01eddd564bfd54e070
setFirstPass
public void setFirstPass(boolean firstPass)
{    this.firstPass = firstPass;}
e29c676e3be505ffb2af00bf8ae4af3294e7b988e0cba1ed94ef3a97c660d8fe
getStatusProgress
public List<EigenStatus> getStatusProgress()
{    return statusProgress;}
7704cdbbd58270591f8666ae431f4e4a5621c81ae3ac32491fb7cb57dc769ff6
setStatusProgress
public void setStatusProgress(List<EigenStatus> statusProgress)
{    this.statusProgress = statusProgress;}
687bfaf20219d13bdc2e4f61edd27455d1691271fab38511dd7115ae77aff853
getActivationNumerator
public double getActivationNumerator()
{    return activationNumerator;}
807f357edb02272498459a0db08396774f9b184575ccebabe82eb6dacd95aec9
setActivationNumerator
public void setActivationNumerator(double activationNumerator)
{    this.activationNumerator = activationNumerator;}
9e6ec5fc6bf027d50ebdf6650759d886e6251e2c8b3409b14293f6c65824152c
getActivationDenominatorSquared
public double getActivationDenominatorSquared()
{    return activationDenominatorSquared;}
8b8373486a399add5f1dd6044a0dea32cf35f89d232f76dc700d8daf8baf0253
setActivationDenominatorSquared
public void setActivationDenominatorSquared(double activationDenominatorSquared)
{    this.activationDenominatorSquared = activationDenominatorSquared;}
685ca82cead33e56c75cad5ace5f3cba2e4e471d0dcc68359527832073e7cdd4
apply
public double apply(double arg1)
{    return arg1 * d;}
e774d13c8505547691f0c86ac017490bf71848a16d988f67f5bdc0d33ed24b52
solve
public void solve(LanczosState state, int desiredRank)
{    solve(state, desiredRank, false);}
63978d3e16b02e50c47ca772ba65d14c9364a9e58edca6af2492c184739be526
solve
public void solve(LanczosState state, int desiredRank, boolean isSymmetric)
{    VectorIterable corpus = state.getCorpus();    log.info("Finding {} singular vectors of matrix with {} rows, via Lanczos", desiredRank, corpus.numRows());    int i = state.getIterationNumber();    Vector currentVector = state.getBasisVector(i - 1);    Vector previousVector = state.getBasisVector(i - 2);    double beta = 0;    Matrix triDiag = state.getDiagonalMatrix();    while (i < desiredRank) {        startTime(TimingSection.ITERATE);        Vector nextVector = isSymmetric ? corpus.times(currentVector) : corpus.timesSquared(currentVector);        log.info("{} passes through the corpus so far...", i);        if (state.getScaleFactor() <= 0) {            state.setScaleFactor(calculateScaleFactor(nextVector));        }        nextVector.assign(new Scale(1.0 / state.getScaleFactor()));        if (previousVector != null) {            nextVector.assign(previousVector, new PlusMult(-beta));        }                double alpha = currentVector.dot(nextVector);        nextVector.assign(currentVector, new PlusMult(-alpha));        endTime(TimingSection.ITERATE);        startTime(TimingSection.ORTHOGANLIZE);        orthoganalizeAgainstAllButLast(nextVector, state);        endTime(TimingSection.ORTHOGANLIZE);                beta = nextVector.norm(2);        if (outOfRange(beta) || outOfRange(alpha)) {            log.warn("Lanczos parameters out of range: alpha = {}, beta = {}.  Bailing out early!", alpha, beta);            break;        }        nextVector.assign(new Scale(1 / beta));        state.setBasisVector(i, nextVector);        previousVector = currentVector;        currentVector = nextVector;                triDiag.set(i - 1, i - 1, alpha);        if (i < desiredRank - 1) {            triDiag.set(i - 1, i, beta);            triDiag.set(i, i - 1, beta);        }        state.setIterationNumber(++i);    }    startTime(TimingSection.TRIDIAG_DECOMP);    log.info("Lanczos iteration complete - now to diagonalize the tri-diagonal auxiliary matrix.");        EigenDecomposition decomp = new EigenDecomposition(triDiag);    Matrix eigenVects = decomp.getV();    Vector eigenVals = decomp.getRealEigenvalues();    endTime(TimingSection.TRIDIAG_DECOMP);    startTime(TimingSection.FINAL_EIGEN_CREATE);    for (int row = 0; row < i; row++) {        Vector realEigen = null;        Vector ejCol = eigenVects.viewColumn(row);        int size = Math.min(ejCol.size(), state.getBasisSize());        for (int j = 0; j < size; j++) {            double d = ejCol.get(j);            Vector rowJ = state.getBasisVector(j);            if (realEigen == null) {                realEigen = rowJ.like();            }            realEigen.assign(rowJ, new PlusMult(d));        }        Preconditions.checkState(realEigen != null);        assert realEigen != null;        realEigen = realEigen.normalize();        state.setRightSingularVector(row, realEigen);        double e = eigenVals.get(row) * state.getScaleFactor();        if (!isSymmetric) {            e = Math.sqrt(e);        }        log.info("Eigenvector {} found with eigenvalue {}", row, e);        state.setSingularValue(row, e);    }    log.info("LanczosSolver finished.");    endTime(TimingSection.FINAL_EIGEN_CREATE);}
fbd5dbf1caf62751726d5ad42d7358167bcb8a8aa5cba0bd78a1d06e663da0d6
calculateScaleFactor
protected static double calculateScaleFactor(Vector nextVector)
{    return nextVector.norm(2);}
f6a6c44e8d2b4288f5b4df176c8477048ef64dda4da2262b5d4c071092a087b1
outOfRange
private static boolean outOfRange(double d)
{    return Double.isNaN(d) || d > SAFE_MAX || -d > SAFE_MAX;}
e0e69d3630832aed94145bb978761e5c7202b20c860bf6a888996ae3a1a596c7
orthoganalizeAgainstAllButLast
protected static void orthoganalizeAgainstAllButLast(Vector nextVector, LanczosState state)
{    for (int i = 0; i < state.getIterationNumber(); i++) {        Vector basisVector = state.getBasisVector(i);        double alpha;        if (basisVector == null || (alpha = nextVector.dot(basisVector)) == 0.0) {            continue;        }        nextVector.assign(basisVector, new PlusMult(-alpha));    }}
d89b6f3e27350d2fefc7829267cbee3090ab071942c3d81f451b45691719ff50
startTime
private void startTime(TimingSection section)
{    startTimes.put(section, System.nanoTime());}
df184d9a1afdb6fdcd61f5b819c58e0bfb55d3726fa28d13ba2127975d716650
endTime
private void endTime(TimingSection section)
{    if (!times.containsKey(section)) {        times.put(section, 0L);    }    times.put(section, times.get(section) + System.nanoTime() - startTimes.get(section));}
ad531cb33947c09631b9a2a9e7032303c3757dbc0da56f109cde995efb9d4610
intitializeBasisAndSingularVectors
private void intitializeBasisAndSingularVectors()
{    basis = Maps.newHashMap();    singularVectors = Maps.newHashMap();}
4096580da85c9f429b058605f2b34f2f8aed78cfbd02ec8ea92a92808b3414d5
getDiagonalMatrix
public Matrix getDiagonalMatrix()
{    return diagonalMatrix;}
a03adedb3cc083439f3c249210ff02869c11240f6eb6330e6e74642fe65509f8
getIterationNumber
public int getIterationNumber()
{    return iterationNumber;}
3cb8de88aa6405d4ef4acdff9ea55680c324f8c38cb551d95a8403f0199cd85a
getScaleFactor
public double getScaleFactor()
{    return scaleFactor;}
31a4b5527ae519b2f891490c123cd403733bc58e716c8ac2c0d7f16de3401607
getCorpus
public VectorIterable getCorpus()
{    return corpus;}
9b41bb44506a1ff44d43054013c1a278ad27cd7a6583d4b84ff0c9de0a4f54bc
getRightSingularVector
public Vector getRightSingularVector(int i)
{    return singularVectors.get(i);}
06a0c86116e19a590614596a82d09ae430ffc6a946cfe459f0f0331353ef1bcb
getSingularValue
public Double getSingularValue(int i)
{    return singularValues.get(i);}
91a71fc878e336ad1a5878905eedc6f2a8366a09ecd3d7c6dc0a1e1f7646efd5
getBasisVector
public Vector getBasisVector(int i)
{    return basis.get(i);}
e8f528d7846acc92e12585770482109de1ef7ce37af4ec2815a70e652cd43892
getBasisSize
public int getBasisSize()
{    return basis.size();}
e5f204ebb84da08e5f241d2cc18de8e811f32c19d856ded2f6e8b6ab2b2be1b1
setBasisVector
public void setBasisVector(int i, Vector basisVector)
{    basis.put(i, basisVector);}
ff12505a55871ffc85485a7813203ea8b343949e9c418018faf5610248831d5d
setScaleFactor
public void setScaleFactor(double scale)
{    scaleFactor = scale;}
ec8f9523bdb76398e319dbdaaeae33aed7812de7010697d6d9ff332069c1060c
setIterationNumber
public void setIterationNumber(int i)
{    iterationNumber = i;}
7133338fb095a8c73f145a4fa88bc907f395c4f8346211612be1dd604df978fa
setRightSingularVector
public void setRightSingularVector(int i, Vector vector)
{    singularVectors.put(i, vector);}
43d68929d324c00a2eeb963961a3a4b0d17a148c689dedf284ec2edc9a83b6ef
setSingularValue
public void setSingularValue(int i, double value)
{    singularValues.put(i, value);}
222aed7084a98569fcc299251ec200d3e61ec8dbe8b5f21779aa61997fc7fb77
verify
public EigenStatus verify(VectorIterable corpus, Vector vector)
{    Vector resultantVector = corpus.timesSquared(vector);    double newNorm = resultantVector.norm(2);    double oldNorm = vector.norm(2);    double eigenValue;    double cosAngle;    if (newNorm > 0 && oldNorm > 0) {        eigenValue = newNorm / oldNorm;        cosAngle = resultantVector.dot(vector) / newNorm * oldNorm;    } else {        eigenValue = 1.0;        cosAngle = 0.0;    }    return new EigenStatus(eigenValue, cosAngle, false);}
5861c64f6665bfdb3e8d448cdf8632259ddb89bbd38964632814a555c94f0bae
write
public static void write(Path outputDir, Configuration conf, Iterable<MatrixSlice> matrix) throws IOException
{    FileSystem fs = outputDir.getFileSystem(conf);    SequenceFile.Writer writer = SequenceFile.createWriter(fs, conf, outputDir, IntWritable.class, VectorWritable.class);    IntWritable topic = new IntWritable();    VectorWritable vector = new VectorWritable();    for (MatrixSlice slice : matrix) {        topic.set(slice.index());        vector.set(slice.vector());        writer.append(topic, vector);    }    writer.close();}
74f6d133e9c75766c890d0cbfcfaad0e4be17f25ba97fcb4b417d54dd4d03888
getInitialVector
public static Vector getInitialVector(VectorIterable corpus)
{    Vector initialVector = new DenseVector(corpus.numCols());    initialVector.assign(1.0 / Math.sqrt(corpus.numCols()));    return initialVector;}
4c8d74642b0c1532e9f31e21a3004471fcaf886663d331dd02b45024e66205ed
runJob
public LanczosState runJob(Configuration originalConfig, LanczosState state, int desiredRank, boolean isSymmetric, String outputEigenVectorPathString) throws IOException
{    ((Configurable) state.getCorpus()).setConf(new Configuration(originalConfig));    setConf(originalConfig);    solve(state, desiredRank, isSymmetric);    serializeOutput(state, new Path(outputEigenVectorPathString));    return state;}
e572935806afc639c3564f4ac6c1a569ccb6b2634b6056dd42ff906c31d9e4c9
runJob
public LanczosState runJob(Configuration originalConfig, Path inputPath, Path outputTmpPath, int numRows, int numCols, boolean isSymmetric, int desiredRank, String outputEigenVectorPathString) throws IOException
{    DistributedRowMatrix matrix = new DistributedRowMatrix(inputPath, outputTmpPath, numRows, numCols);    matrix.setConf(new Configuration(originalConfig));    LanczosState state = new LanczosState(matrix, desiredRank, getInitialVector(matrix));    return runJob(originalConfig, state, desiredRank, isSymmetric, outputEigenVectorPathString);}
b31cb6a894acd9e406667b955507e22a99129892a3c5ceaddbedccc2f2a9db5b
run
public int run(String[] strings) throws Exception
{    Path inputPath = new Path(AbstractJob.getOption(parsedArgs, "--input"));    Path outputPath = new Path(AbstractJob.getOption(parsedArgs, "--output"));    Path outputTmpPath = new Path(AbstractJob.getOption(parsedArgs, "--tempDir"));    Path workingDirPath = AbstractJob.getOption(parsedArgs, "--workingDir") != null ? new Path(AbstractJob.getOption(parsedArgs, "--workingDir")) : null;    int numRows = Integer.parseInt(AbstractJob.getOption(parsedArgs, "--numRows"));    int numCols = Integer.parseInt(AbstractJob.getOption(parsedArgs, "--numCols"));    boolean isSymmetric = Boolean.parseBoolean(AbstractJob.getOption(parsedArgs, "--symmetric"));    int desiredRank = Integer.parseInt(AbstractJob.getOption(parsedArgs, "--rank"));    boolean cleansvd = Boolean.parseBoolean(AbstractJob.getOption(parsedArgs, "--cleansvd"));    if (cleansvd) {        double maxError = Double.parseDouble(AbstractJob.getOption(parsedArgs, "--maxError"));        double minEigenvalue = Double.parseDouble(AbstractJob.getOption(parsedArgs, "--minEigenvalue"));        boolean inMemory = Boolean.parseBoolean(AbstractJob.getOption(parsedArgs, "--inMemory"));        return run(inputPath, outputPath, outputTmpPath, workingDirPath, numRows, numCols, isSymmetric, desiredRank, maxError, minEigenvalue, inMemory);    }    return run(inputPath, outputPath, outputTmpPath, workingDirPath, numRows, numCols, isSymmetric, desiredRank);}
b911af6995cb37f1bc48cbd7250ab097c03a0b3c0fe768566771c735f5d2c211
run
public int run(Path inputPath, Path outputPath, Path outputTmpPath, Path workingDirPath, int numRows, int numCols, boolean isSymmetric, int desiredRank, double maxError, double minEigenvalue, boolean inMemory) throws Exception
{    int result = run(inputPath, outputPath, outputTmpPath, workingDirPath, numRows, numCols, isSymmetric, desiredRank);    if (result != 0) {        return result;    }    Path rawEigenVectorPath = new Path(outputPath, RAW_EIGENVECTORS);    return new EigenVerificationJob().run(inputPath, rawEigenVectorPath, outputPath, outputTmpPath, maxError, minEigenvalue, inMemory, getConf() != null ? new Configuration(getConf()) : new Configuration());}
d279611bb37ceed3d6bdb76e156497a72c83e49254f8359b74f9d97506c8adda
run
public int run(Path inputPath, Path outputPath, Path outputTmpPath, Path workingDirPath, int numRows, int numCols, boolean isSymmetric, int desiredRank) throws Exception
{    DistributedRowMatrix matrix = new DistributedRowMatrix(inputPath, outputTmpPath, numRows, numCols);    matrix.setConf(new Configuration(getConf() != null ? getConf() : new Configuration()));    LanczosState state;    if (workingDirPath == null) {        state = new LanczosState(matrix, desiredRank, getInitialVector(matrix));    } else {        HdfsBackedLanczosState hState = new HdfsBackedLanczosState(matrix, desiredRank, getInitialVector(matrix), workingDirPath);        hState.setConf(matrix.getConf());        state = hState;    }    solve(state, desiredRank, isSymmetric);    Path outputEigenVectorPath = new Path(outputPath, RAW_EIGENVECTORS);    serializeOutput(state, outputEigenVectorPath);    return 0;}
e990da6d63c360d7ac6937500a22ff93b383e02402186c21c96d06d9c698299c
serializeOutput
public void serializeOutput(LanczosState state, Path outputPath) throws IOException
{    int numEigenVectors = state.getIterationNumber();    log.info("Persisting {} eigenVectors and eigenValues to: {}", numEigenVectors, outputPath);    Configuration conf = getConf() != null ? getConf() : new Configuration();    FileSystem fs = FileSystem.get(outputPath.toUri(), conf);    SequenceFile.Writer seqWriter = new SequenceFile.Writer(fs, conf, outputPath, IntWritable.class, VectorWritable.class);    try {        IntWritable iw = new IntWritable();        for (int i = 0; i < numEigenVectors; i++) {                        NamedVector v = new NamedVector(state.getRightSingularVector(numEigenVectors - 1 - i), "eigenVector" + i + ", eigenvalue = " + state.getSingularValue(numEigenVectors - 1 - i));            Writable vw = new VectorWritable(v);            iw.set(i);            seqWriter.append(iw, vw);        }    } finally {        Closeables.close(seqWriter, false);    }}
9c9813ec5150aa99c66b8c22257a531dd5cb8d663ffd85cbd6891bf6890819a8
setConf
public void setConf(Configuration configuration)
{    conf = configuration;}
d221713f567be6c3a854157b6beb8a5fd5dd64b69c1ef157fb4bac811a41c3f7
getConf
public Configuration getConf()
{    return conf;}
318915396b7c279a8073c4d9f352bb6ea136d88af09ce89309ef12615780a81c
job
public DistributedLanczosSolverJob job()
{    return new DistributedLanczosSolverJob();}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    DistributedLanczosSolver.this.setConf(conf);}
d221713f567be6c3a854157b6beb8a5fd5dd64b69c1ef157fb4bac811a41c3f7
getConf
public Configuration getConf()
{    return DistributedLanczosSolver.this.getConf();}
aacecb0f01750d985b78d806dc3c134f0da79efe2752957e0f93ecf5cbf9e492
run
public int run(String[] args) throws Exception
{    addInputOption();    addOutputOption();    addOption("numRows", "nr", "Number of rows of the input matrix");    addOption("numCols", "nc", "Number of columns of the input matrix");    addOption("rank", "r", "Desired decomposition rank (note: only roughly 1/4 to 1/3 " + "of these will have the top portion of the spectrum)");    addOption("symmetric", "sym", "Is the input matrix square and symmetric?");    addOption("workingDir", "wd", "Working directory path to store Lanczos basis vectors " + "(to be used on restarts, and to avoid too much RAM usage)");        addOption("cleansvd", "cl", "Run the EigenVerificationJob to clean the eigenvectors after SVD", false);    addOption("maxError", "err", "Maximum acceptable error", "0.05");    addOption("minEigenvalue", "mev", "Minimum eigenvalue to keep the vector for", "0.0");    addOption("inMemory", "mem", "Buffer eigen matrix into memory (if you have enough!)", "false");    DistributedLanczosSolver.this.parsedArgs = parseArguments(args);    if (DistributedLanczosSolver.this.parsedArgs == null) {        return -1;    } else {        return DistributedLanczosSolver.this.run(args);    }}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    ToolRunner.run(new DistributedLanczosSolver().job(), args);}
4058e4532084f24dabc50038c1941965a39203c3d72df2d0e8ccf6d081089682
getEigenValue
public double getEigenValue()
{    return getEigenValue(getName());}
6453ab2bcc7e8980aa5e690bb59fde31917db91581a80f80db9a747f366cb9a2
getCosAngleError
public double getCosAngleError()
{    return getCosAngleError(getName());}
d4663f435afd6a88c00a18d16d8d8e2fe6c896dd995d5906395fd4ddbb8b7760
getIndex
public int getIndex()
{    return getIndex(getName());}
176c796f9daa656adf3113bec3a86830843a29de052da34a76c17e3194cb2968
getEigenValue
public static double getEigenValue(CharSequence name)
{    return parseMetaData(name)[1];}
13fcf0c51f9750b135d106a213c4d85f261b5f51560c689874c50fd0740b54a9
getCosAngleError
public static double getCosAngleError(CharSequence name)
{    return parseMetaData(name)[2];}
c968eed004b1537240fccfd66ea2d9f4b9ceb27c151a060cd0a11dd4fd51f82f
getIndex
public static int getIndex(CharSequence name)
{    return (int) parseMetaData(name)[0];}
fecc76bb7482b4f905b67e5ca736be3bb6a0f49c2006183abf9de6df17ecd6aa
parseMetaData
public static double[] parseMetaData(CharSequence name)
{    double[] m = new double[3];    String[] s = EQUAL_PATTERN.split(name);    m[0] = Double.parseDouble(PIPE_PATTERN.split(s[0])[1]);    m[1] = Double.parseDouble(PIPE_PATTERN.split(s[1])[1]);    m[2] = Double.parseDouble(s[2].substring(1));    return m;}
c352255c69febc827215d1b2b121a8bc44923b1633b0c1e6ebb82dcdde9aa0ee
parseMetaData
protected double[] parseMetaData()
{    return parseMetaData(getName());}
2e41b4b4b0b08ec5fed3cf39ffca5e04120e4cac702d0d2e0cb994d1149b9f2e
setEigensToVerify
public void setEigensToVerify(VectorIterable eigens)
{    eigensToVerify = eigens;}
aacecb0f01750d985b78d806dc3c134f0da79efe2752957e0f93ecf5cbf9e492
run
public int run(String[] args) throws Exception
{    Map<String, List<String>> argMap = handleArgs(args);    if (argMap == null) {        return -1;    }    if (argMap.isEmpty()) {        return 0;    }        runJob(getConf(), new Path(getOption("eigenInput")), new Path(getOption("corpusInput")), getOutputPath(), getOption("inMemory") != null, Double.parseDouble(getOption("maxError")),     Integer.parseInt(getOption("maxEigens")));    return 0;}
393d6f7565f00e468c44561d8d2552d1e3e1063f1e11a2750c53d532ffee163f
run
public int run(Path corpusInput, Path eigenInput, Path output, Path tempOut, double maxError, double minEigenValue, boolean inMemory, Configuration conf) throws IOException
{    this.outPath = output;    this.tmpOut = tempOut;    this.maxError = maxError;    this.minEigenValue = minEigenValue;    if (eigenInput != null && eigensToVerify == null) {        prepareEigens(conf, eigenInput, inMemory);    }    DistributedRowMatrix c = new DistributedRowMatrix(corpusInput, tempOut, 1, 1);    c.setConf(conf);    corpus = c;        eigenVerifier = new SimpleEigenVerifier();            Map<MatrixSlice, EigenStatus> eigenMetaData = verifyEigens();    List<Map.Entry<MatrixSlice, EigenStatus>> prunedEigenMeta = pruneEigens(eigenMetaData);    saveCleanEigens(new Configuration(), prunedEigenMeta);    return 0;}
207627335ac8851c526899d48f39ce322922890a3273f2f928c9c3f64bb3322a
handleArgs
private Map<String, List<String>> handleArgs(String[] args) throws IOException
{    addOutputOption();    addOption("eigenInput", "ei", "The Path for purported eigenVector input files (SequenceFile<WritableComparable,VectorWritable>.", null);    addOption("corpusInput", "ci", "The Path for corpus input files (SequenceFile<WritableComparable,VectorWritable>.");    addOption(DefaultOptionCreator.outputOption().create());    addOption(DefaultOptionCreator.helpOption());    addOption("inMemory", "mem", "Buffer eigen matrix into memory (if you have enough!)", "false");    addOption("maxError", "err", "Maximum acceptable error", "0.05");    addOption("minEigenvalue", "mev", "Minimum eigenvalue to keep the vector for", "0.0");    addOption("maxEigens", "max", "Maximum number of eigenvectors to keep (0 means all)", "0");    return parseArguments(args);}
6bd7cc43e57f86817c7f3239f9435366d8f447f0e7a0155fd8ebefc61e0ed205
saveCleanEigens
private void saveCleanEigens(Configuration conf, Collection<Map.Entry<MatrixSlice, EigenStatus>> prunedEigenMeta) throws IOException
{    Path path = new Path(outPath, CLEAN_EIGENVECTORS);    FileSystem fs = FileSystem.get(path.toUri(), conf);    SequenceFile.Writer seqWriter = new SequenceFile.Writer(fs, conf, path, IntWritable.class, VectorWritable.class);    try {        IntWritable iw = new IntWritable();        int numEigensWritten = 0;        int index = 0;        for (Map.Entry<MatrixSlice, EigenStatus> pruneSlice : prunedEigenMeta) {            MatrixSlice s = pruneSlice.getKey();            EigenStatus meta = pruneSlice.getValue();            EigenVector ev = new EigenVector(s.vector(), meta.getEigenValue(), Math.abs(1 - meta.getCosAngle()), s.index());                        Writable vw = new VectorWritable(ev);            iw.set(index++);            seqWriter.append(iw, vw);                                                numEigensWritten++;            if (numEigensWritten == maxEigensToKeep) {                log.info("{} of the {} total eigens have been written", maxEigensToKeep, prunedEigenMeta.size());                break;            }        }    } finally {        Closeables.close(seqWriter, false);    }    cleanedEigensPath = path;}
9cc005745cf7641527db47adff020fcc267cbe87c1685e39f302f48e4ede881a
pruneEigens
private List<Map.Entry<MatrixSlice, EigenStatus>> pruneEigens(Map<MatrixSlice, EigenStatus> eigenMetaData)
{    List<Map.Entry<MatrixSlice, EigenStatus>> prunedEigenMeta = Lists.newArrayList();    for (Map.Entry<MatrixSlice, EigenStatus> entry : eigenMetaData.entrySet()) {        if (Math.abs(1 - entry.getValue().getCosAngle()) < maxError && entry.getValue().getEigenValue() > minEigenValue) {            prunedEigenMeta.add(entry);        }    }    Collections.sort(prunedEigenMeta, new Comparator<Map.Entry<MatrixSlice, EigenStatus>>() {        @Override        public int compare(Map.Entry<MatrixSlice, EigenStatus> e1, Map.Entry<MatrixSlice, EigenStatus> e2) {                        Double eg1 = e1.getValue().getEigenValue();            Double eg2 = e2.getValue().getEigenValue();            return eg1.compareTo(eg2);        }    });        List<Map.Entry<MatrixSlice, EigenStatus>> selectedEigenMeta = Lists.newArrayList();    Map.Entry<MatrixSlice, EigenStatus> e1 = prunedEigenMeta.remove(0);    selectedEigenMeta.add(e1);    int selectedEigenMetaLength = selectedEigenMeta.size();    int prunedEigenMetaLength = prunedEigenMeta.size();    while (prunedEigenMetaLength > 0) {        double sum = Double.MAX_VALUE;        int index = 0;        for (int i = 0; i < prunedEigenMetaLength; i++) {            Map.Entry<MatrixSlice, EigenStatus> e = prunedEigenMeta.get(i);            double tmp = 0;            for (int j = 0; j < selectedEigenMetaLength; j++) {                Map.Entry<MatrixSlice, EigenStatus> ee = selectedEigenMeta.get(j);                tmp += ee.getKey().vector().times(e.getKey().vector()).norm(2);            }            if (tmp < sum) {                sum = tmp;                index = i;            }        }        Map.Entry<MatrixSlice, EigenStatus> e = prunedEigenMeta.remove(index);        selectedEigenMeta.add(e);        selectedEigenMetaLength++;        prunedEigenMetaLength--;    }    return selectedEigenMeta;}
8ed28ad6b40ce9fb6a4cd061a08b792ac0022be6b09892e8cb6d4fb7d874bcd1
compare
public int compare(Map.Entry<MatrixSlice, EigenStatus> e1, Map.Entry<MatrixSlice, EigenStatus> e2)
{        Double eg1 = e1.getValue().getEigenValue();    Double eg2 = e2.getValue().getEigenValue();    return eg1.compareTo(eg2);}
2f7f434693138852ceba76fdfce6175cee4b81acb48b37c1381d4d40100362aa
verifyEigens
private Map<MatrixSlice, EigenStatus> verifyEigens()
{    Map<MatrixSlice, EigenStatus> eigenMetaData = Maps.newHashMap();    for (MatrixSlice slice : eigensToVerify) {        EigenStatus status = eigenVerifier.verify(corpus, slice.vector());        eigenMetaData.put(slice, status);    }    return eigenMetaData;}
a7f6d0e04bdac47b8c46969e6875c4d02f761f6340b4e1f360ed7ef367f3b159
prepareEigens
private void prepareEigens(Configuration conf, Path eigenInput, boolean inMemory)
{    DistributedRowMatrix eigens = new DistributedRowMatrix(eigenInput, tmpOut, 1, 1);    eigens.setConf(conf);    if (inMemory) {        List<Vector> eigenVectors = Lists.newArrayList();        for (MatrixSlice slice : eigens) {            eigenVectors.add(slice.vector());        }        eigensToVerify = new SparseRowMatrix(eigenVectors.size(), eigenVectors.get(0).size(), eigenVectors.toArray(new Vector[eigenVectors.size()]), true, true);    } else {        eigensToVerify = eigens;    }}
ade12cfbc63cf625551fd837b188187120c73f8c77a92da17288be4261cec622
getCleanedEigensPath
public Path getCleanedEigensPath()
{    return cleanedEigensPath;}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    ToolRunner.run(new EigenVerificationJob(), args);}
3039bec23bc91ba1b6e3b971a3889d2b4a19485084ab6c543e734d0387371470
runJob
public void runJob(Configuration conf, Path eigenInput, Path corpusInput, Path output, boolean inMemory, double maxError, int maxEigens) throws IOException
{        outPath = output;    tmpOut = new Path(outPath, "tmp");    maxEigensToKeep = maxEigens;    this.maxError = maxError;    if (eigenInput != null && eigensToVerify == null) {        prepareEigens(new Configuration(conf), eigenInput, inMemory);    }    DistributedRowMatrix c = new DistributedRowMatrix(corpusInput, tmpOut, 1, 1);    c.setConf(new Configuration(conf));    corpus = c;    eigenVerifier = new SimpleEigenVerifier();    Map<MatrixSlice, EigenStatus> eigenMetaData = verifyEigens();    List<Map.Entry<MatrixSlice, EigenStatus>> prunedEigenMeta = pruneEigens(eigenMetaData);    saveCleanEigens(conf, prunedEigenMeta);}
9c9813ec5150aa99c66b8c22257a531dd5cb8d663ffd85cbd6891bf6890819a8
setConf
public void setConf(Configuration configuration)
{    conf = configuration;    try {        setupDirs();        updateHdfsState();    } catch (IOException e) {        log.error("Could not retrieve filesystem: {}", conf, e);    }}
d221713f567be6c3a854157b6beb8a5fd5dd64b69c1ef157fb4bac811a41c3f7
getConf
public Configuration getConf()
{    return conf;}
94ac4be414160108d980398ea30a2f2c3284fd8c441ae11745d9214b6f3ba712
setupDirs
private void setupDirs() throws IOException
{    fs = baseDir.getFileSystem(conf);    createDirIfNotExist(baseDir);    createDirIfNotExist(basisPath);    createDirIfNotExist(singularVectorPath);}
579942ae7e5b8292bcfeea5d194f80d86a9eb53785fadbb686286b6cb7da305b
createDirIfNotExist
private void createDirIfNotExist(Path path) throws IOException
{    if (!fs.exists(path) && !fs.mkdirs(path)) {        throw new IOException("Unable to create: " + path);    }}
ec8f9523bdb76398e319dbdaaeae33aed7812de7010697d6d9ff332069c1060c
setIterationNumber
public void setIterationNumber(int i)
{    super.setIterationNumber(i);    try {        updateHdfsState();    } catch (IOException e) {        log.error("Could not update HDFS state: ", e);    }}
fa2aedbd7278d5fec7107a1cde0399b7383cd7eb2c4731b502d7b7e30e3eaba6
updateHdfsState
protected void updateHdfsState() throws IOException
{    if (conf == null) {        return;    }    int numBasisVectorsOnDisk = 0;    Path nextBasisVectorPath = new Path(basisPath, BASIS_PREFIX + '_' + numBasisVectorsOnDisk);    while (fs.exists(nextBasisVectorPath)) {        nextBasisVectorPath = new Path(basisPath, BASIS_PREFIX + '_' + ++numBasisVectorsOnDisk);    }    Vector nextVector;    while (numBasisVectorsOnDisk < iterationNumber && (nextVector = getBasisVector(numBasisVectorsOnDisk)) != null) {        persistVector(nextBasisVectorPath, numBasisVectorsOnDisk, nextVector);        nextBasisVectorPath = new Path(basisPath, BASIS_PREFIX + '_' + ++numBasisVectorsOnDisk);    }    if (scaleFactor <= 0) {                scaleFactor = getScaleFactor();    }        diagonalMatrix = getDiagonalMatrix();    Vector norms = new DenseVector(diagonalMatrix.numCols() - 1);    Vector projections = new DenseVector(diagonalMatrix.numCols());    int i = 0;    while (i < diagonalMatrix.numCols() - 1) {        norms.set(i, diagonalMatrix.get(i, i + 1));        projections.set(i, diagonalMatrix.get(i, i));        i++;    }    projections.set(i, diagonalMatrix.get(i, i));    persistVector(new Path(baseDir, "projections"), 0, projections);    persistVector(new Path(baseDir, "norms"), 0, norms);    persistVector(new Path(baseDir, "scaleFactor"), 0, new DenseVector(new double[] { scaleFactor }));    for (Map.Entry<Integer, Vector> entry : singularVectors.entrySet()) {        persistVector(new Path(singularVectorPath, SINGULAR_PREFIX + '_' + entry.getKey()), entry.getKey(), entry.getValue());    }    super.setIterationNumber(numBasisVectorsOnDisk);}
6a86a1adf6210fa9b041efc4127d5a4c4e26ec0f69f9ad6bdb144591c18a4dd5
persistVector
protected void persistVector(Path p, int key, Vector vector) throws IOException
{    SequenceFile.Writer writer = null;    try {        if (fs.exists(p)) {            log.warn("{} exists, will overwrite", p);            fs.delete(p, true);        }        writer = new SequenceFile.Writer(fs, conf, p, IntWritable.class, VectorWritable.class);        writer.append(new IntWritable(key), new VectorWritable(vector));    } finally {        Closeables.close(writer, false);    }}
eab5a8f0007ee2f323cee2abf1cd5c5a57afbd2238fb8c6530ac925edab9fdea
fetchVector
protected Vector fetchVector(Path p, int keyIndex) throws IOException
{    if (!fs.exists(p)) {        return null;    }    SequenceFile.Reader reader = new SequenceFile.Reader(fs, p, conf);    IntWritable key = new IntWritable();    VectorWritable vw = new VectorWritable();    while (reader.next(key, vw)) {        if (key.get() == keyIndex) {            return vw.get();        }    }    return null;}
91a71fc878e336ad1a5878905eedc6f2a8366a09ecd3d7c6dc0a1e1f7646efd5
getBasisVector
public Vector getBasisVector(int i)
{    if (!basis.containsKey(i)) {        try {            Vector v = fetchVector(new Path(basisPath, BASIS_PREFIX + '_' + i), i);            basis.put(i, v);        } catch (IOException e) {            log.error("Could not load basis vector: {}", i, e);        }    }    return super.getBasisVector(i);}
9b41bb44506a1ff44d43054013c1a278ad27cd7a6583d4b84ff0c9de0a4f54bc
getRightSingularVector
public Vector getRightSingularVector(int i)
{    if (!singularVectors.containsKey(i)) {        try {            Vector v = fetchVector(new Path(singularVectorPath, BASIS_PREFIX + '_' + i), i);            singularVectors.put(i, v);        } catch (IOException e) {            log.error("Could not load singular vector: {}", i, e);        }    }    return super.getRightSingularVector(i);}
3cb8de88aa6405d4ef4acdff9ea55680c324f8c38cb551d95a8403f0199cd85a
getScaleFactor
public double getScaleFactor()
{    if (scaleFactor <= 0) {        try {            Vector v = fetchVector(new Path(baseDir, "scaleFactor"), 0);            if (v != null && v.size() > 0) {                scaleFactor = v.get(0);            }        } catch (IOException e) {            log.error("could not load scaleFactor:", e);        }    }    return scaleFactor;}
4096580da85c9f429b058605f2b34f2f8aed78cfbd02ec8ea92a92808b3414d5
getDiagonalMatrix
public Matrix getDiagonalMatrix()
{    if (diagonalMatrix == null) {        diagonalMatrix = new DenseMatrix(desiredRank, desiredRank);    }    if (diagonalMatrix.get(0, 1) <= 0) {        try {            Vector norms = fetchVector(new Path(baseDir, "norms"), 0);            Vector projections = fetchVector(new Path(baseDir, "projections"), 0);            if (norms != null && projections != null) {                int i = 0;                while (i < projections.size() - 1) {                    diagonalMatrix.set(i, i, projections.get(i));                    diagonalMatrix.set(i, i + 1, norms.get(i));                    diagonalMatrix.set(i + 1, i, norms.get(i));                    i++;                }                diagonalMatrix.set(i, i, projections.get(i));            }        } catch (IOException e) {            log.error("Could not load diagonal matrix of norms and projections: ", e);        }    }    return diagonalMatrix;}
d221713f567be6c3a854157b6beb8a5fd5dd64b69c1ef157fb4bac811a41c3f7
getConf
public Configuration getConf()
{    return conf;}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    this.conf = conf;    try {        FileSystem fs = FileSystem.get(inputPath.toUri(), conf);        rowPath = fs.makeQualified(inputPath);        outputTmpBasePath = fs.makeQualified(outputTmpPath);        keepTempFiles = conf.getBoolean(KEEP_TEMP_FILES, false);    } catch (IOException ioe) {        throw new IllegalStateException(ioe);    }}
a1ac0ff18abac3d4b9c01f37f4a6626081d0a65d97fcc0d2f6c77355cc6afde8
getRowPath
public Path getRowPath()
{    return rowPath;}
0eb5c8e43d910167ca2acffc050563a57320ed78656ba48b4a25d55c1ce3bf55
getOutputTempPath
public Path getOutputTempPath()
{    return outputTmpBasePath;}
8f2aebfedb59adfcbef5ecef7f068a2d170c2bd1e83306b465294e9f0b498bd4
setOutputTempPathString
public void setOutputTempPathString(String outPathString)
{    try {        outputTmpBasePath = FileSystem.get(conf).makeQualified(new Path(outPathString));    } catch (IOException ioe) {        log.warn("Unable to set outputBasePath to {}, leaving as {}", outPathString, outputTmpBasePath);    }}
99eb89100e81a1c9b6d2c2b9bacb794d4a9322c5692bbc72b555785bebf7a3d9
iterateNonEmpty
public Iterator<MatrixSlice> iterateNonEmpty()
{    return iterator();}
4f215be71dad866961124672ae15071a4e7a56933483dcadaee74820c5f0e03e
iterateAll
public Iterator<MatrixSlice> iterateAll()
{    try {        Path pathPattern = rowPath;        if (FileSystem.get(conf).getFileStatus(rowPath).isDir()) {            pathPattern = new Path(rowPath, "*");        }        return Iterators.transform(new SequenceFileDirIterator<IntWritable, VectorWritable>(pathPattern, PathType.GLOB, PathFilters.logsCRCFilter(), null, true, conf), new Function<Pair<IntWritable, VectorWritable>, MatrixSlice>() {            @Override            public MatrixSlice apply(Pair<IntWritable, VectorWritable> from) {                return new MatrixSlice(from.getSecond().get(), from.getFirst().get());            }        });    } catch (IOException ioe) {        throw new IllegalStateException(ioe);    }}
46e59b23e432f45068d4c686299e4a412885c872509882c9ed7abad146399cd9
apply
public MatrixSlice apply(Pair<IntWritable, VectorWritable> from)
{    return new MatrixSlice(from.getSecond().get(), from.getFirst().get());}
4f84a93591875e1cca8d9e5ad9481c6ce323c0c90a5b0b7da8751eb116523a29
numSlices
public int numSlices()
{    return numRows();}
3b35afb5959174898c07539693af05a525573b46f716ac385ab9f25f3d0f4d1a
numRows
public int numRows()
{    return numRows;}
2e7eae53900c6679869bde9f32aee0e32dd69ad8928f5c6f09f3776c3864db29
numCols
public int numCols()
{    return numCols;}
c2c8ffccca24983108bf68fe07cb180b3596838088a253b437a00e756fd45328
times
public DistributedRowMatrix times(DistributedRowMatrix other) throws IOException
{    return times(other, new Path(outputTmpBasePath.getParent(), "productWith-" + (System.nanoTime() & 0xFF)));}
4c5a6b9a6b98f108bf7eb0273a203edab799da22b936f93f03e51bca3d016337
times
public DistributedRowMatrix times(DistributedRowMatrix other, Path outPath) throws IOException
{    if (numRows != other.numRows()) {        throw new CardinalityException(numRows, other.numRows());    }    Configuration initialConf = getConf() == null ? new Configuration() : getConf();    Configuration conf = MatrixMultiplicationJob.createMatrixMultiplyJobConf(initialConf, rowPath, other.rowPath, outPath, other.numCols);    JobClient.runJob(new JobConf(conf));    DistributedRowMatrix out = new DistributedRowMatrix(outPath, outputTmpPath, numCols, other.numCols());    out.setConf(conf);    return out;}
a940877faf13c7f150c642a499276d5af983e217f02ce274aa15bc9e4562df1c
columnMeans
public Vector columnMeans() throws IOException
{    return columnMeans("SequentialAccessSparseVector");}
5690e62b047ab6e580480d4c2725465a89082b297adbdf1b45bf531e28f48940
columnMeans
public Vector columnMeans(String vectorClass) throws IOException
{    Path outputVectorTmpPath = new Path(outputTmpBasePath, new Path(Long.toString(System.nanoTime())));    Configuration initialConf = getConf() == null ? new Configuration() : getConf();    String vectorClassFull = "org.apache.mahout.math." + vectorClass;    Vector mean = MatrixColumnMeansJob.run(initialConf, rowPath, outputVectorTmpPath, vectorClassFull);    if (!keepTempFiles) {        FileSystem fs = outputVectorTmpPath.getFileSystem(conf);        fs.delete(outputVectorTmpPath, true);    }    return mean;}
ce3710b1c149c4d30eea12483f35b5a5eb679400a426c0dac021448aa1222e82
transpose
public DistributedRowMatrix transpose() throws IOException
{    Path outputPath = new Path(rowPath.getParent(), "transpose-" + (System.nanoTime() & 0xFF));    Configuration initialConf = getConf() == null ? new Configuration() : getConf();    Job transposeJob = TransposeJob.buildTransposeJob(initialConf, rowPath, outputPath, numRows);    try {        transposeJob.waitForCompletion(true);    } catch (Exception e) {        throw new IllegalStateException("transposition failed", e);    }    DistributedRowMatrix m = new DistributedRowMatrix(outputPath, outputTmpPath, numCols, numRows);    m.setConf(this.conf);    return m;}
722f1585f6df20bce925b4fe7f6f41c55e402b92a35f419be7f6af7c83938334
times
public Vector times(Vector v)
{    try {        Configuration initialConf = getConf() == null ? new Configuration() : getConf();        Path outputVectorTmpPath = new Path(outputTmpBasePath, new Path(Long.toString(System.nanoTime())));        Job job = TimesSquaredJob.createTimesJob(initialConf, v, numRows, rowPath, outputVectorTmpPath);        try {            job.waitForCompletion(true);        } catch (Exception e) {            throw new IllegalStateException("times failed", e);        }        Vector result = TimesSquaredJob.retrieveTimesSquaredOutputVector(outputVectorTmpPath, conf);        if (!keepTempFiles) {            FileSystem fs = outputVectorTmpPath.getFileSystem(conf);            fs.delete(outputVectorTmpPath, true);        }        return result;    } catch (IOException ioe) {        throw new IllegalStateException(ioe);    }}
1578c670303bd46bac5ba56bec209bcd3fae9a9f78d1eddd6d34bd10b9231108
timesSquared
public Vector timesSquared(Vector v)
{    try {        Configuration initialConf = getConf() == null ? new Configuration() : getConf();        Path outputVectorTmpPath = new Path(outputTmpBasePath, new Path(Long.toString(System.nanoTime())));        Job job = TimesSquaredJob.createTimesSquaredJob(initialConf, v, rowPath, outputVectorTmpPath);        try {            job.waitForCompletion(true);        } catch (Exception e) {            throw new IllegalStateException("timesSquared failed", e);        }        Vector result = TimesSquaredJob.retrieveTimesSquaredOutputVector(outputVectorTmpPath, conf);        if (!keepTempFiles) {            FileSystem fs = outputVectorTmpPath.getFileSystem(conf);            fs.delete(outputVectorTmpPath, true);        }        return result;    } catch (IOException ioe) {        throw new IllegalStateException(ioe);    }}
4e2991346111ce7b0ad21d3be20e5260c73af42a053d742339e6b45599b2c8dc
iterator
public Iterator<MatrixSlice> iterator()
{    return iterateAll();}
d4eb3a86032c35b455a6e0ae131661d4d4dc525d2112aadf5a7761a33ea8e48e
getRow
public int getRow()
{    return row;}
0f18b14210ae196e4f308931a968ad702601acd0d613ebdaff7d429934cd9086
setRow
public void setRow(int row)
{    this.row = row;}
6809fdfedea078db73c775e200cb13b2a7955503a118d27e39f4701b96e49c33
getCol
public int getCol()
{    return col;}
cb8aecda69fda788edbf5426a368a98a1492d0ad96dfc3e9db921e0b1a8b85e9
setCol
public void setCol(int col)
{    this.col = col;}
ac7ead0d82833c10b2e1b93cab4738d64688b5c9b2e2d741cfea672c81a2726d
getVal
public double getVal()
{    return val;}
835d9b059d00d66230ff289a5c3d7e448303c005dc612da6b339dabc5d641fdf
setVal
public void setVal(double val)
{    this.val = val;}
068ca407a1d959516f6c653d6cd89f2f72620784d3e8b074531048f1b0ad5f79
compareTo
public int compareTo(MatrixEntryWritable o)
{    if (row > o.row) {        return 1;    } else if (row < o.row) {        return -1;    } else {        if (col > o.col) {            return 1;        } else if (col < o.col) {            return -1;        } else {            return 0;        }    }}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (!(o instanceof MatrixEntryWritable)) {        return false;    }    MatrixEntryWritable other = (MatrixEntryWritable) o;    return row == other.row && col == other.col;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return row + 31 * col;}
a894510dd4db439ff8e17ae1059489dc3abc97178e5932ceed0c70c3af165401
write
public void write(DataOutput out) throws IOException
{    out.writeInt(row);    out.writeInt(col);    out.writeDouble(val);}
5478cc5683f6dfd4515c383752d7c803555efc63d03fd84a03ba8dcd17eb4324
readFields
public void readFields(DataInput in) throws IOException
{    row = in.readInt();    col = in.readInt();    val = in.readDouble();}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "(" + row + ',' + col + "):" + val;}
aad827c9293cca98dc2f6c749f4520c99caeb57bec5f77c78b27550e699dd883
run
public static Vector run(Configuration conf, Path inputPath, Path outputVectorTmpPath) throws IOException
{    return run(conf, inputPath, outputVectorTmpPath, null);}
74d860f79f1c9d8d847777fa9b696ed7e63acadecc6dc371f255ec84f5ae152a
run
public static Vector run(Configuration initialConf, Path inputPath, Path outputVectorTmpPath, String vectorClass) throws IOException
{    try {        initialConf.set(VECTOR_CLASS, vectorClass == null ? DenseVector.class.getName() : vectorClass);        Job job = new Job(initialConf, "MatrixColumnMeansJob");        job.setJarByClass(MatrixColumnMeansJob.class);        FileOutputFormat.setOutputPath(job, outputVectorTmpPath);        outputVectorTmpPath.getFileSystem(job.getConfiguration()).delete(outputVectorTmpPath, true);        job.setNumReduceTasks(1);        FileOutputFormat.setOutputPath(job, outputVectorTmpPath);        FileInputFormat.addInputPath(job, inputPath);        job.setInputFormatClass(SequenceFileInputFormat.class);        job.setOutputFormatClass(SequenceFileOutputFormat.class);        FileOutputFormat.setOutputPath(job, outputVectorTmpPath);        job.setMapperClass(MatrixColumnMeansMapper.class);        job.setReducerClass(MatrixColumnMeansReducer.class);        job.setMapOutputKeyClass(NullWritable.class);        job.setMapOutputValueClass(VectorWritable.class);        job.setOutputKeyClass(IntWritable.class);        job.setOutputValueClass(VectorWritable.class);        job.submit();        job.waitForCompletion(true);        Path tmpFile = new Path(outputVectorTmpPath, "part-r-00000");        SequenceFileValueIterator<VectorWritable> iterator = new SequenceFileValueIterator<>(tmpFile, true, initialConf);        try {            if (iterator.hasNext()) {                return iterator.next().get();            } else {                return (Vector) Class.forName(vectorClass).getConstructor(int.class).newInstance(0);            }        } finally {            Closeables.close(iterator, true);        }    } catch (IOException ioe) {        throw ioe;    } catch (Throwable thr) {        throw new IOException(thr);    }}
5cea2a7c4e1f15509b5030e71609dca919138d48d1aebe9efc31435a268ea192
setup
public void setup(Context context)
{    vectorClass = context.getConfiguration().get(VECTOR_CLASS);}
0a2723d588b8a8b92805921e3501b4ea90b433a3e6581489c7832ced30e050c6
map
public void map(Writable r, VectorWritable v, Context context) throws IOException
{    if (runningSum == null) {        /*           * If this is the first vector the mapper has seen, instantiate a new           * vector using the parameter VECTOR_CLASS           */        runningSum = ClassUtils.instantiateAs(vectorClass, Vector.class, new Class<?>[] { int.class }, new Object[] { v.get().size() + 1 });        runningSum.set(0, 1);        runningSum.viewPart(1, v.get().size()).assign(v.get());    } else {        runningSum.set(0, runningSum.get(0) + 1);        runningSum.viewPart(1, v.get().size()).assign(v.get(), Functions.PLUS);    }}
9ce414059ab35ecde3dd7116607daa715bcd302171d3e3652851fecd9a77ef9d
cleanup
public void cleanup(Context context) throws InterruptedException, IOException
{    if (runningSum != null) {        context.write(NullWritable.get(), new VectorWritable(runningSum));    }}
5cea2a7c4e1f15509b5030e71609dca919138d48d1aebe9efc31435a268ea192
setup
public void setup(Context context)
{    vectorClass = context.getConfiguration().get(VECTOR_CLASS);}
f653e7bdac02277f8b6027ae096799721d74a27510977cbbf44f672acb6e5037
reduce
public void reduce(NullWritable n, Iterable<VectorWritable> vectors, Context context) throws IOException, InterruptedException
{    /**     * Add together partial column-wise sums from mappers     */    for (VectorWritable v : vectors) {        if (outputVector == null) {            outputVector = v.get();        } else {            outputVector.assign(v.get(), Functions.PLUS);        }    }    /**     * Divide total column-wise sum by count of vectors, which corresponds to     * the number of rows in the DistributedRowMatrix     */    if (outputVector != null) {        outputVectorWritable.set(outputVector.viewPart(1, outputVector.size() - 1).divide(outputVector.get(0)));        context.write(ONE, outputVectorWritable);    } else {        Vector emptyVector = ClassUtils.instantiateAs(vectorClass, Vector.class, new Class<?>[] { int.class }, new Object[] { 0 });        context.write(ONE, new VectorWritable(emptyVector));    }}
60a166d0e40e3a806e53cf8d596ff9b1b058e4a345870ec0dc43fe9ec1fd7159
createMatrixMultiplyJobConf
public static Configuration createMatrixMultiplyJobConf(Path aPath, Path bPath, Path outPath, int outCardinality)
{    return createMatrixMultiplyJobConf(new Configuration(), aPath, bPath, outPath, outCardinality);}
0c27ba09de6f30a19721d187a6f4b6c4d3c735a0a5ca60bc2c03a48fc1f0ca33
createMatrixMultiplyJobConf
public static Configuration createMatrixMultiplyJobConf(Configuration initialConf, Path aPath, Path bPath, Path outPath, int outCardinality)
{    JobConf conf = new JobConf(initialConf, MatrixMultiplicationJob.class);    conf.setInputFormat(CompositeInputFormat.class);    conf.set("mapred.join.expr", CompositeInputFormat.compose("inner", SequenceFileInputFormat.class, aPath, bPath));    conf.setInt(OUT_CARD, outCardinality);    conf.setOutputFormat(SequenceFileOutputFormat.class);    FileOutputFormat.setOutputPath(conf, outPath);    conf.setMapperClass(MatrixMultiplyMapper.class);    conf.setCombinerClass(MatrixMultiplicationReducer.class);    conf.setReducerClass(MatrixMultiplicationReducer.class);    conf.setMapOutputKeyClass(IntWritable.class);    conf.setMapOutputValueClass(VectorWritable.class);    conf.setOutputKeyClass(IntWritable.class);    conf.setOutputValueClass(VectorWritable.class);    return conf;}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    ToolRunner.run(new MatrixMultiplicationJob(), args);}
b31cb6a894acd9e406667b955507e22a99129892a3c5ceaddbedccc2f2a9db5b
run
public int run(String[] strings) throws Exception
{    addOption("numRowsA", "nra", "Number of rows of the first input matrix", true);    addOption("numColsA", "nca", "Number of columns of the first input matrix", true);    addOption("numRowsB", "nrb", "Number of rows of the second input matrix", true);    addOption("numColsB", "ncb", "Number of columns of the second input matrix", true);    addOption("inputPathA", "ia", "Path to the first input matrix", true);    addOption("inputPathB", "ib", "Path to the second input matrix", true);    addOption("outputPath", "op", "Path to the output matrix", false);    Map<String, List<String>> argMap = parseArguments(strings);    if (argMap == null) {        return -1;    }    DistributedRowMatrix a = new DistributedRowMatrix(new Path(getOption("inputPathA")), new Path(getOption("tempDir")), Integer.parseInt(getOption("numRowsA")), Integer.parseInt(getOption("numColsA")));    DistributedRowMatrix b = new DistributedRowMatrix(new Path(getOption("inputPathB")), new Path(getOption("tempDir")), Integer.parseInt(getOption("numRowsB")), Integer.parseInt(getOption("numColsB")));    a.setConf(new Configuration(getConf()));    b.setConf(new Configuration(getConf()));    if (hasOption("outputPath")) {        a.times(b, new Path(getOption("outputPath")));    } else {        a.times(b);    }    return 0;}
168ba1f397fa7f98e4fd97e21643283e5d4241368ae53225b4df290815323453
configure
public void configure(JobConf conf)
{    outCardinality = conf.getInt(OUT_CARD, Integer.MAX_VALUE);}
aa36b98ccae428590835d9c8902a79bf6be562e247b567fddc9198e0d6e0fee9
map
public void map(IntWritable index, TupleWritable v, OutputCollector<IntWritable, VectorWritable> out, Reporter reporter) throws IOException
{    boolean firstIsOutFrag = ((VectorWritable) v.get(0)).get().size() == outCardinality;    Vector outFrag = firstIsOutFrag ? ((VectorWritable) v.get(0)).get() : ((VectorWritable) v.get(1)).get();    Vector multiplier = firstIsOutFrag ? ((VectorWritable) v.get(1)).get() : ((VectorWritable) v.get(0)).get();    VectorWritable outVector = new VectorWritable();    for (Vector.Element e : multiplier.nonZeroes()) {        row.set(e.index());        outVector.set(outFrag.times(e.get()));        out.collect(row, outVector);    }}
d1c2f2e37845aeb78a1cb558c118ea61d71a1193e0a6db36ee4e705eb1af2021
reduce
public void reduce(IntWritable rowNum, Iterator<VectorWritable> it, OutputCollector<IntWritable, VectorWritable> out, Reporter reporter) throws IOException
{    if (!it.hasNext()) {        return;    }    Vector accumulator = new RandomAccessSparseVector(it.next().get());    while (it.hasNext()) {        Vector row = it.next().get();        accumulator.assign(row, Functions.PLUS);    }    out.collect(rowNum, new VectorWritable(new SequentialAccessSparseVector(accumulator)));}
57aaa66562c072a52cdb212ffe430bf4b11091e04190136414333451e0db6801
similarity
public double similarity(double dots, double normA, double normB, int numberOfColumns)
{    return 1.0 / (1.0 + normA + normB - 2 * dots);}
57aaa66562c072a52cdb212ffe430bf4b11091e04190136414333451e0db6801
similarity
public double similarity(double dots, double normA, double normB, int numberOfColumns)
{    return dots;}
045a15c8dd4366855752a6ea1a1b58de03b742d95f2058d507f3816fe4e713dd
consider
public boolean consider(int numNonZeroEntriesA, int numNonZeroEntriesB, double maxValueA, double maxValueB, double threshold)
{    return numNonZeroEntriesA >= threshold && numNonZeroEntriesB >= threshold;}
b14f78be18b3691b8c095e7958e329e571b0c8f7c49a2ee4cc2e4ed2d668e0a5
normalize
public Vector normalize(Vector vector)
{    return vector.normalize();}
bdd3ccfb9a16a82b6943ac3f6d0c3e4af2901ef52f0dc69a3dd0e788887c3c62
norm
public double norm(Vector vector)
{    return VectorSimilarityMeasure.NO_NORM;}
d16a6cca77417b82f2c2672e778e3b5ea768740576e95b8253d76521c5d7a1ed
aggregate
public double aggregate(double valueA, double nonZeroValueB)
{    return valueA * nonZeroValueB;}
57aaa66562c072a52cdb212ffe430bf4b11091e04190136414333451e0db6801
similarity
public double similarity(double dots, double normA, double normB, int numberOfColumns)
{    return dots;}
045a15c8dd4366855752a6ea1a1b58de03b742d95f2058d507f3816fe4e713dd
consider
public boolean consider(int numNonZeroEntriesA, int numNonZeroEntriesB, double maxValueA, double maxValueB, double threshold)
{    return numNonZeroEntriesB >= threshold / maxValueA && numNonZeroEntriesA >= threshold / maxValueB;}
b14f78be18b3691b8c095e7958e329e571b0c8f7c49a2ee4cc2e4ed2d668e0a5
normalize
public Vector normalize(Vector vector)
{    return vector;}
bdd3ccfb9a16a82b6943ac3f6d0c3e4af2901ef52f0dc69a3dd0e788887c3c62
norm
public double norm(Vector vector)
{    return vector.norm(0);}
d16a6cca77417b82f2c2672e778e3b5ea768740576e95b8253d76521c5d7a1ed
aggregate
public double aggregate(double valueA, double nonZeroValueB)
{    return 1;}
045a15c8dd4366855752a6ea1a1b58de03b742d95f2058d507f3816fe4e713dd
consider
public boolean consider(int numNonZeroEntriesA, int numNonZeroEntriesB, double maxValueA, double maxValueB, double threshold)
{    return true;}
b14f78be18b3691b8c095e7958e329e571b0c8f7c49a2ee4cc2e4ed2d668e0a5
normalize
public Vector normalize(Vector vector)
{    return vector;}
bdd3ccfb9a16a82b6943ac3f6d0c3e4af2901ef52f0dc69a3dd0e788887c3c62
norm
public double norm(Vector vector)
{    double norm = 0;    for (Vector.Element e : vector.nonZeroes()) {        double value = e.get();        norm += value * value;    }    return norm;}
d16a6cca77417b82f2c2672e778e3b5ea768740576e95b8253d76521c5d7a1ed
aggregate
public double aggregate(double valueA, double nonZeroValueB)
{    return valueA * nonZeroValueB;}
57aaa66562c072a52cdb212ffe430bf4b11091e04190136414333451e0db6801
similarity
public double similarity(double dots, double normA, double normB, int numberOfColumns)
{            double euclideanDistance = Math.sqrt(Math.max(0.0, normA - 2 * dots + normB));    return 1.0 / (1.0 + euclideanDistance);}
045a15c8dd4366855752a6ea1a1b58de03b742d95f2058d507f3816fe4e713dd
consider
public boolean consider(int numNonZeroEntriesA, int numNonZeroEntriesB, double maxValueA, double maxValueB, double threshold)
{    return true;}
299d58d392803a4ccbcaf531b988b247ac8ad5759432232727c6d9c66c525cf0
similarity
public double similarity(double summedAggregations, double normA, double normB, int numberOfColumns)
{    double logLikelihood = LogLikelihood.logLikelihoodRatio((long) summedAggregations, (long) (normB - summedAggregations), (long) (normA - summedAggregations), (long) (numberOfColumns - normA - normB + summedAggregations));    return 1.0 - 1.0 / (1.0 + logLikelihood);}
b14f78be18b3691b8c095e7958e329e571b0c8f7c49a2ee4cc2e4ed2d668e0a5
normalize
public Vector normalize(Vector vector)
{    if (vector.getNumNondefaultElements() == 0) {        return vector;    }        double average = vector.norm(1) / vector.getNumNonZeroElements();    for (Vector.Element e : vector.nonZeroes()) {        e.set(e.get() - average);    }    return super.normalize(vector);}
57aaa66562c072a52cdb212ffe430bf4b11091e04190136414333451e0db6801
similarity
public double similarity(double dots, double normA, double normB, int numberOfColumns)
{        return dots / (normA + normB - dots);}
045a15c8dd4366855752a6ea1a1b58de03b742d95f2058d507f3816fe4e713dd
consider
public boolean consider(int numNonZeroEntriesA, int numNonZeroEntriesB, double maxValueA, double maxValueB, double threshold)
{    return numNonZeroEntriesA >= numNonZeroEntriesB * threshold && numNonZeroEntriesB >= numNonZeroEntriesA * threshold;}
3cccf4fcd8f943b806e42b727b8df0bf3ad0731f5f04267eff7425683dd12b78
getClassname
public String getClassname()
{    return implementingClass.getName();}
171cdbd519210f2d78921bf17eb7c12ea51969ac373440330f1dc259ac356ab1
list
public static String list()
{    return Arrays.toString(values());}
6f9021560b40d5f0ea4687dcfc9163f88e04e559e2fc0af5f9a1fed73b4e4c24
get
public double get()
{    return value;}
5dd366da2313537c415c3c2ab9ed1909d1250d894a032bd02373d113516571d0
index
public int index()
{    return index;}
bf7b7b2e083c7617d45cfbcae264174224fbc3ab6f0eeeae4dc50d4e3a2a584f
setIndex
public void setIndex(int index)
{    this.index = index;}
0ca3b3a320922927ea9a06f3def94b995d23a5eb7b95de57c7935a827c79759c
set
public void set(double value)
{    this.value = value;}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    ToolRunner.run(new RowSimilarityJob(), args);}
aacecb0f01750d985b78d806dc3c134f0da79efe2752957e0f93ecf5cbf9e492
run
public int run(String[] args) throws Exception
{    addInputOption();    addOutputOption();    addOption("numberOfColumns", "r", "Number of columns in the input matrix", false);    addOption("similarityClassname", "s", "Name of distributed similarity class to instantiate, alternatively use " + "one of the predefined similarities (" + VectorSimilarityMeasures.list() + ')');    addOption("maxSimilaritiesPerRow", "m", "Number of maximum similarities per row (default: " + DEFAULT_MAX_SIMILARITIES_PER_ROW + ')', String.valueOf(DEFAULT_MAX_SIMILARITIES_PER_ROW));    addOption("excludeSelfSimilarity", "ess", "compute similarity of rows to themselves?", String.valueOf(false));    addOption("threshold", "tr", "discard row pairs with a similarity value below this", false);    addOption("maxObservationsPerRow", null, "sample rows down to this number of entries", String.valueOf(DEFAULT_MAX_OBSERVATIONS_PER_ROW));    addOption("maxObservationsPerColumn", null, "sample columns down to this number of entries", String.valueOf(DEFAULT_MAX_OBSERVATIONS_PER_COLUMN));    addOption("randomSeed", null, "use this seed for sampling", false);    addOption(DefaultOptionCreator.overwriteOption().create());    Map<String, List<String>> parsedArgs = parseArguments(args);    if (parsedArgs == null) {        return -1;    }    int numberOfColumns;    if (hasOption("numberOfColumns")) {                numberOfColumns = Integer.parseInt(getOption("numberOfColumns"));    } else {                numberOfColumns = getDimensions(getInputPath());    }    String similarityClassnameArg = getOption("similarityClassname");    String similarityClassname;    try {        similarityClassname = VectorSimilarityMeasures.valueOf(similarityClassnameArg).getClassname();    } catch (IllegalArgumentException iae) {        similarityClassname = similarityClassnameArg;    }        if (hasOption(DefaultOptionCreator.OVERWRITE_OPTION)) {                HadoopUtil.delete(getConf(), getTempPath());                HadoopUtil.delete(getConf(), getOutputPath());    }    int maxSimilaritiesPerRow = Integer.parseInt(getOption("maxSimilaritiesPerRow"));    boolean excludeSelfSimilarity = Boolean.parseBoolean(getOption("excludeSelfSimilarity"));    double threshold = hasOption("threshold") ? Double.parseDouble(getOption("threshold")) : NO_THRESHOLD;    long randomSeed = hasOption("randomSeed") ? Long.parseLong(getOption("randomSeed")) : NO_FIXED_RANDOM_SEED;    int maxObservationsPerRow = Integer.parseInt(getOption("maxObservationsPerRow"));    int maxObservationsPerColumn = Integer.parseInt(getOption("maxObservationsPerColumn"));    Path weightsPath = getTempPath("weights");    Path normsPath = getTempPath("norms.bin");    Path numNonZeroEntriesPath = getTempPath("numNonZeroEntries.bin");    Path maxValuesPath = getTempPath("maxValues.bin");    Path pairwiseSimilarityPath = getTempPath("pairwiseSimilarity");    Path observationsPerColumnPath = getTempPath("observationsPerColumn.bin");    AtomicInteger currentPhase = new AtomicInteger();    Job countObservations = prepareJob(getInputPath(), getTempPath("notUsed"), CountObservationsMapper.class, NullWritable.class, VectorWritable.class, SumObservationsReducer.class, NullWritable.class, VectorWritable.class);    countObservations.setCombinerClass(VectorSumCombiner.class);    countObservations.getConfiguration().set(OBSERVATIONS_PER_COLUMN_PATH, observationsPerColumnPath.toString());    countObservations.setNumReduceTasks(1);    countObservations.waitForCompletion(true);    if (shouldRunNextPhase(parsedArgs, currentPhase)) {        Job normsAndTranspose = prepareJob(getInputPath(), weightsPath, VectorNormMapper.class, IntWritable.class, VectorWritable.class, MergeVectorsReducer.class, IntWritable.class, VectorWritable.class);        normsAndTranspose.setCombinerClass(MergeVectorsCombiner.class);        Configuration normsAndTransposeConf = normsAndTranspose.getConfiguration();        normsAndTransposeConf.set(THRESHOLD, String.valueOf(threshold));        normsAndTransposeConf.set(NORMS_PATH, normsPath.toString());        normsAndTransposeConf.set(NUM_NON_ZERO_ENTRIES_PATH, numNonZeroEntriesPath.toString());        normsAndTransposeConf.set(MAXVALUES_PATH, maxValuesPath.toString());        normsAndTransposeConf.set(SIMILARITY_CLASSNAME, similarityClassname);        normsAndTransposeConf.set(OBSERVATIONS_PER_COLUMN_PATH, observationsPerColumnPath.toString());        normsAndTransposeConf.set(MAX_OBSERVATIONS_PER_ROW, String.valueOf(maxObservationsPerRow));        normsAndTransposeConf.set(MAX_OBSERVATIONS_PER_COLUMN, String.valueOf(maxObservationsPerColumn));        normsAndTransposeConf.set(RANDOM_SEED, String.valueOf(randomSeed));        boolean succeeded = normsAndTranspose.waitForCompletion(true);        if (!succeeded) {            return -1;        }    }    if (shouldRunNextPhase(parsedArgs, currentPhase)) {        Job pairwiseSimilarity = prepareJob(weightsPath, pairwiseSimilarityPath, CooccurrencesMapper.class, IntWritable.class, VectorWritable.class, SimilarityReducer.class, IntWritable.class, VectorWritable.class);        pairwiseSimilarity.setCombinerClass(VectorSumReducer.class);        Configuration pairwiseConf = pairwiseSimilarity.getConfiguration();        pairwiseConf.set(THRESHOLD, String.valueOf(threshold));        pairwiseConf.set(NORMS_PATH, normsPath.toString());        pairwiseConf.set(NUM_NON_ZERO_ENTRIES_PATH, numNonZeroEntriesPath.toString());        pairwiseConf.set(MAXVALUES_PATH, maxValuesPath.toString());        pairwiseConf.set(SIMILARITY_CLASSNAME, similarityClassname);        pairwiseConf.setInt(NUMBER_OF_COLUMNS, numberOfColumns);        pairwiseConf.setBoolean(EXCLUDE_SELF_SIMILARITY, excludeSelfSimilarity);        boolean succeeded = pairwiseSimilarity.waitForCompletion(true);        if (!succeeded) {            return -1;        }    }    if (shouldRunNextPhase(parsedArgs, currentPhase)) {        Job asMatrix = prepareJob(pairwiseSimilarityPath, getOutputPath(), UnsymmetrifyMapper.class, IntWritable.class, VectorWritable.class, MergeToTopKSimilaritiesReducer.class, IntWritable.class, VectorWritable.class);        asMatrix.setCombinerClass(MergeToTopKSimilaritiesReducer.class);        asMatrix.getConfiguration().setInt(MAX_SIMILARITIES_PER_ROW, maxSimilaritiesPerRow);        boolean succeeded = asMatrix.waitForCompletion(true);        if (!succeeded) {            return -1;        }    }    return 0;}
450faa9853b7ed9c320177377ea3fbda429ec987899a8d9a49d1194d372fb753
map
protected void map(IntWritable rowIndex, VectorWritable rowVectorWritable, Context ctx) throws IOException, InterruptedException
{    Vector row = rowVectorWritable.get();    for (Vector.Element elem : row.nonZeroes()) {        columnCounts.setQuick(elem.index(), columnCounts.getQuick(elem.index()) + 1);    }}
1e67e7cddbb210542b6d1a0c46225cb3c8845f7c014f884b63e2f939ee36f067
cleanup
protected void cleanup(Context ctx) throws IOException, InterruptedException
{    ctx.write(NullWritable.get(), new VectorWritable(columnCounts));}
33821b1cfd35b5b598fbb15dd4779ed114b0801c509386b70be2ded930883472
reduce
protected void reduce(NullWritable nullWritable, Iterable<VectorWritable> partialVectors, Context ctx) throws IOException, InterruptedException
{    Vector counts = Vectors.sum(partialVectors.iterator());    Vectors.write(counts, new Path(ctx.getConfiguration().get(OBSERVATIONS_PER_COLUMN_PATH)), ctx.getConfiguration());}
d3192444cabbcc9598d5706bfdcd1dfedd209d3688c3c575e42fd6b75ea83739
setup
protected void setup(Context ctx) throws IOException, InterruptedException
{    Configuration conf = ctx.getConfiguration();    similarity = ClassUtils.instantiateAs(conf.get(SIMILARITY_CLASSNAME), VectorSimilarityMeasure.class);    norms = new RandomAccessSparseVector(Integer.MAX_VALUE);    nonZeroEntries = new RandomAccessSparseVector(Integer.MAX_VALUE);    maxValues = new RandomAccessSparseVector(Integer.MAX_VALUE);    threshold = Double.parseDouble(conf.get(THRESHOLD));    observationsPerColumn = Vectors.readAsIntMap(new Path(conf.get(OBSERVATIONS_PER_COLUMN_PATH)), conf);    maxObservationsPerRow = conf.getInt(MAX_OBSERVATIONS_PER_ROW, DEFAULT_MAX_OBSERVATIONS_PER_ROW);    maxObservationsPerColumn = conf.getInt(MAX_OBSERVATIONS_PER_COLUMN, DEFAULT_MAX_OBSERVATIONS_PER_COLUMN);    long seed = Long.parseLong(conf.get(RANDOM_SEED));    if (seed == NO_FIXED_RANDOM_SEED) {        random = RandomUtils.getRandom();    } else {        random = RandomUtils.getRandom(seed);    }}
ba673726d6f0972dbec656c10e87d3cfda3c1e4abb8347ed80b8a7abd179a297
sampleDown
private Vector sampleDown(Vector rowVector, Context ctx)
{    int observationsPerRow = rowVector.getNumNondefaultElements();    double rowSampleRate = (double) Math.min(maxObservationsPerRow, observationsPerRow) / (double) observationsPerRow;    Vector downsampledRow = rowVector.like();    long usedObservations = 0;    long neglectedObservations = 0;    for (Vector.Element elem : rowVector.nonZeroes()) {        int columnCount = observationsPerColumn.get(elem.index());        double columnSampleRate = (double) Math.min(maxObservationsPerColumn, columnCount) / (double) columnCount;        if (random.nextDouble() <= Math.min(rowSampleRate, columnSampleRate)) {            downsampledRow.setQuick(elem.index(), elem.get());            usedObservations++;        } else {            neglectedObservations++;        }    }    ctx.getCounter(Counters.USED_OBSERVATIONS).increment(usedObservations);    ctx.getCounter(Counters.NEGLECTED_OBSERVATIONS).increment(neglectedObservations);    return downsampledRow;}
3fd2a5797f666e575c1f983c949947aa4fd8d072456815014c666f21389396eb
map
protected void map(IntWritable row, VectorWritable vectorWritable, Context ctx) throws IOException, InterruptedException
{    Vector sampledRowVector = sampleDown(vectorWritable.get(), ctx);    Vector rowVector = similarity.normalize(sampledRowVector);    int numNonZeroEntries = 0;    double maxValue = Double.MIN_VALUE;    for (Vector.Element element : rowVector.nonZeroes()) {        RandomAccessSparseVector partialColumnVector = new RandomAccessSparseVector(Integer.MAX_VALUE);        partialColumnVector.setQuick(row.get(), element.get());        ctx.write(new IntWritable(element.index()), new VectorWritable(partialColumnVector));        numNonZeroEntries++;        if (maxValue < element.get()) {            maxValue = element.get();        }    }    if (threshold != NO_THRESHOLD) {        nonZeroEntries.setQuick(row.get(), numNonZeroEntries);        maxValues.setQuick(row.get(), maxValue);    }    norms.setQuick(row.get(), similarity.norm(rowVector));    ctx.getCounter(Counters.ROWS).increment(1);}
1e67e7cddbb210542b6d1a0c46225cb3c8845f7c014f884b63e2f939ee36f067
cleanup
protected void cleanup(Context ctx) throws IOException, InterruptedException
{    ctx.write(new IntWritable(NORM_VECTOR_MARKER), new VectorWritable(norms));    ctx.write(new IntWritable(NUM_NON_ZERO_ENTRIES_VECTOR_MARKER), new VectorWritable(nonZeroEntries));    ctx.write(new IntWritable(MAXVALUE_VECTOR_MARKER), new VectorWritable(maxValues));}
58c7f800a1b447036387bab3114fcdbdf16ddbb22a218da4b21a0445eded573e
reduce
protected void reduce(IntWritable row, Iterable<VectorWritable> partialVectors, Context ctx) throws IOException, InterruptedException
{    ctx.write(row, new VectorWritable(Vectors.merge(partialVectors)));}
d3192444cabbcc9598d5706bfdcd1dfedd209d3688c3c575e42fd6b75ea83739
setup
protected void setup(Context ctx) throws IOException, InterruptedException
{    normsPath = new Path(ctx.getConfiguration().get(NORMS_PATH));    numNonZeroEntriesPath = new Path(ctx.getConfiguration().get(NUM_NON_ZERO_ENTRIES_PATH));    maxValuesPath = new Path(ctx.getConfiguration().get(MAXVALUES_PATH));}
58c7f800a1b447036387bab3114fcdbdf16ddbb22a218da4b21a0445eded573e
reduce
protected void reduce(IntWritable row, Iterable<VectorWritable> partialVectors, Context ctx) throws IOException, InterruptedException
{    Vector partialVector = Vectors.merge(partialVectors);    if (row.get() == NORM_VECTOR_MARKER) {        Vectors.write(partialVector, normsPath, ctx.getConfiguration());    } else if (row.get() == MAXVALUE_VECTOR_MARKER) {        Vectors.write(partialVector, maxValuesPath, ctx.getConfiguration());    } else if (row.get() == NUM_NON_ZERO_ENTRIES_VECTOR_MARKER) {        Vectors.write(partialVector, numNonZeroEntriesPath, ctx.getConfiguration(), true);    } else {        ctx.write(row, new VectorWritable(partialVector));    }}
1d58b0fb6dd3bb4356c088e4f2b867825c2f5dcb845223c9c862d69fd0c8ea38
compare
public int compare(Vector.Element one, Vector.Element two)
{    return Ints.compare(one.index(), two.index());}
d3192444cabbcc9598d5706bfdcd1dfedd209d3688c3c575e42fd6b75ea83739
setup
protected void setup(Context ctx) throws IOException, InterruptedException
{    similarity = ClassUtils.instantiateAs(ctx.getConfiguration().get(SIMILARITY_CLASSNAME), VectorSimilarityMeasure.class);    numNonZeroEntries = Vectors.readAsIntMap(new Path(ctx.getConfiguration().get(NUM_NON_ZERO_ENTRIES_PATH)), ctx.getConfiguration());    maxValues = Vectors.read(new Path(ctx.getConfiguration().get(MAXVALUES_PATH)), ctx.getConfiguration());    threshold = Double.parseDouble(ctx.getConfiguration().get(THRESHOLD));}
f9e478ecb7b636ade77ac9529beecedf3d5cb225aca74f12011cdc20e4552c82
consider
private boolean consider(Vector.Element occurrenceA, Vector.Element occurrenceB)
{    int numNonZeroEntriesA = numNonZeroEntries.get(occurrenceA.index());    int numNonZeroEntriesB = numNonZeroEntries.get(occurrenceB.index());    double maxValueA = maxValues.get(occurrenceA.index());    double maxValueB = maxValues.get(occurrenceB.index());    return similarity.consider(numNonZeroEntriesA, numNonZeroEntriesB, maxValueA, maxValueB, threshold);}
0562486cb100ef37ae1e8e11b2bb1fa498e6940b7dc8856b3f4289bc8b22b2d3
map
protected void map(IntWritable column, VectorWritable occurrenceVector, Context ctx) throws IOException, InterruptedException
{    Vector.Element[] occurrences = Vectors.toArray(occurrenceVector);    Arrays.sort(occurrences, BY_INDEX);    int cooccurrences = 0;    int prunedCooccurrences = 0;    for (int n = 0; n < occurrences.length; n++) {        Vector.Element occurrenceA = occurrences[n];        Vector dots = new RandomAccessSparseVector(Integer.MAX_VALUE);        for (int m = n; m < occurrences.length; m++) {            Vector.Element occurrenceB = occurrences[m];            if (threshold == NO_THRESHOLD || consider(occurrenceA, occurrenceB)) {                dots.setQuick(occurrenceB.index(), similarity.aggregate(occurrenceA.get(), occurrenceB.get()));                cooccurrences++;            } else {                prunedCooccurrences++;            }        }        ctx.write(new IntWritable(occurrenceA.index()), new VectorWritable(dots));    }    ctx.getCounter(Counters.COOCCURRENCES).increment(cooccurrences);    ctx.getCounter(Counters.PRUNED_COOCCURRENCES).increment(prunedCooccurrences);}
d3192444cabbcc9598d5706bfdcd1dfedd209d3688c3c575e42fd6b75ea83739
setup
protected void setup(Context ctx) throws IOException, InterruptedException
{    similarity = ClassUtils.instantiateAs(ctx.getConfiguration().get(SIMILARITY_CLASSNAME), VectorSimilarityMeasure.class);    numberOfColumns = ctx.getConfiguration().getInt(NUMBER_OF_COLUMNS, -1);    Preconditions.checkArgument(numberOfColumns > 0, "Number of columns must be greater then 0! But numberOfColumns = " + numberOfColumns);    excludeSelfSimilarity = ctx.getConfiguration().getBoolean(EXCLUDE_SELF_SIMILARITY, false);    norms = Vectors.read(new Path(ctx.getConfiguration().get(NORMS_PATH)), ctx.getConfiguration());    treshold = Double.parseDouble(ctx.getConfiguration().get(THRESHOLD));}
e005752ff0d6c3be9b3543e767bfc6f4f104ee28985f09c92f3f9a201f79b2d7
reduce
protected void reduce(IntWritable row, Iterable<VectorWritable> partialDots, Context ctx) throws IOException, InterruptedException
{    Iterator<VectorWritable> partialDotsIterator = partialDots.iterator();    Vector dots = partialDotsIterator.next().get();    while (partialDotsIterator.hasNext()) {        Vector toAdd = partialDotsIterator.next().get();        for (Element nonZeroElement : toAdd.nonZeroes()) {            dots.setQuick(nonZeroElement.index(), dots.getQuick(nonZeroElement.index()) + nonZeroElement.get());        }    }    Vector similarities = dots.like();    double normA = norms.getQuick(row.get());    for (Element b : dots.nonZeroes()) {        double similarityValue = similarity.similarity(b.get(), normA, norms.getQuick(b.index()), numberOfColumns);        if (similarityValue >= treshold) {            similarities.set(b.index(), similarityValue);        }    }    if (excludeSelfSimilarity) {        similarities.setQuick(row.get(), 0);    }    ctx.write(row, new VectorWritable(similarities));}
0adfd36b09d9e43bad554542d75b9e8a87ab82752ccd229ac362327ccf0ff9fe
setup
protected void setup(Mapper.Context ctx) throws IOException, InterruptedException
{    maxSimilaritiesPerRow = ctx.getConfiguration().getInt(MAX_SIMILARITIES_PER_ROW, 0);    Preconditions.checkArgument(maxSimilaritiesPerRow > 0, "Maximum number of similarities per row must be greater then 0!");}
5978c5fb627bb062ffbeb501977131ddf013249f50a762dadc337f2c0ecaa8dc
map
protected void map(IntWritable row, VectorWritable similaritiesWritable, Context ctx) throws IOException, InterruptedException
{    Vector similarities = similaritiesWritable.get();        Vector transposedPartial = new RandomAccessSparseVector(similarities.size(), 1);    TopElementsQueue topKQueue = new TopElementsQueue(maxSimilaritiesPerRow);    for (Element nonZeroElement : similarities.nonZeroes()) {        MutableElement top = topKQueue.top();        double candidateValue = nonZeroElement.get();        if (candidateValue > top.get()) {            top.setIndex(nonZeroElement.index());            top.set(candidateValue);            topKQueue.updateTop();        }        transposedPartial.setQuick(row.get(), candidateValue);        ctx.write(new IntWritable(nonZeroElement.index()), new VectorWritable(transposedPartial));        transposedPartial.setQuick(row.get(), 0.0);    }    Vector topKSimilarities = new RandomAccessSparseVector(similarities.size(), maxSimilaritiesPerRow);    for (Vector.Element topKSimilarity : topKQueue.getTopElements()) {        topKSimilarities.setQuick(topKSimilarity.index(), topKSimilarity.get());    }    ctx.write(row, new VectorWritable(topKSimilarities));}
d3192444cabbcc9598d5706bfdcd1dfedd209d3688c3c575e42fd6b75ea83739
setup
protected void setup(Context ctx) throws IOException, InterruptedException
{    maxSimilaritiesPerRow = ctx.getConfiguration().getInt(MAX_SIMILARITIES_PER_ROW, 0);    Preconditions.checkArgument(maxSimilaritiesPerRow > 0, "Maximum number of similarities per row must be greater then 0!");}
a96490c9f2619e078e4a7e2ea5a7a0ff9765ef5104c89f9ca60080761e640bbf
reduce
protected void reduce(IntWritable row, Iterable<VectorWritable> partials, Context ctx) throws IOException, InterruptedException
{    Vector allSimilarities = Vectors.merge(partials);    Vector topKSimilarities = Vectors.topKElements(maxSimilaritiesPerRow, allSimilarities);    ctx.write(row, new VectorWritable(topKSimilarities));}
04c2740e4561bed8a7cca9ee5e3095bd2877c8c48a26737b2ddb7a6a6028f599
getTopElements
public List<MutableElement> getTopElements()
{    List<MutableElement> topElements = Lists.newArrayListWithCapacity(maxSize);    while (size() > 0) {        MutableElement top = pop();                if (top.index() != SENTINEL_INDEX) {            topElements.add(top);        }    }    Collections.reverse(topElements);    return topElements;}
1cdb87186a361da752ca406016958a017710827351446dd686482a6a8e4ff00a
getSentinelObject
protected MutableElement getSentinelObject()
{    return new MutableElement(SENTINEL_INDEX, Double.MIN_VALUE);}
7fca12303470692ee2f9cc23047f56fe950f7df1c7464b10e3b3482ceb13e800
lessThan
protected boolean lessThan(MutableElement e1, MutableElement e2)
{    return e1.get() < e2.get();}
6ba4fb63dc5635e1a2a69d4abb02fd6a5267819ec36fbd4dd12f0d693d8ff3b4
maybeSample
public static Vector maybeSample(Vector original, int sampleSize)
{    if (original.getNumNondefaultElements() <= sampleSize) {        return original;    }    Vector sample = new RandomAccessSparseVector(original.size(), sampleSize);    Iterator<Element> sampledElements = new FixedSizeSamplingIterator<>(sampleSize, original.nonZeroes().iterator());    while (sampledElements.hasNext()) {        Element elem = sampledElements.next();        sample.setQuick(elem.index(), elem.get());    }    return sample;}
26907bb6a9b831923c7d6eafc1994a57d2090091f4721e5892257793379e2a3c
topKElements
public static Vector topKElements(int k, Vector original)
{    if (original.getNumNondefaultElements() <= k) {        return original;    }    TopElementsQueue topKQueue = new TopElementsQueue(k);    for (Element nonZeroElement : original.nonZeroes()) {        MutableElement top = topKQueue.top();        double candidateValue = nonZeroElement.get();        if (candidateValue > top.get()) {            top.setIndex(nonZeroElement.index());            top.set(candidateValue);            topKQueue.updateTop();        }    }    Vector topKSimilarities = new RandomAccessSparseVector(original.size(), k);    for (Vector.Element topKSimilarity : topKQueue.getTopElements()) {        topKSimilarities.setQuick(topKSimilarity.index(), topKSimilarity.get());    }    return topKSimilarities;}
0d8034a769038a32cad75e8b747a4d968aada6b15cfdc6426c8602390c7bb3e7
merge
public static Vector merge(Iterable<VectorWritable> partialVectors)
{    Iterator<VectorWritable> vectors = partialVectors.iterator();    Vector accumulator = vectors.next().get();    while (vectors.hasNext()) {        VectorWritable v = vectors.next();        if (v != null) {            for (Element nonZeroElement : v.get().nonZeroes()) {                accumulator.setQuick(nonZeroElement.index(), nonZeroElement.get());            }        }    }    return accumulator;}
be058ea72dee387ffb8c912642a11fef23decea93307515de27818d117a91e86
sum
public static Vector sum(Iterator<VectorWritable> vectors)
{    Vector sum = vectors.next().get();    while (vectors.hasNext()) {        sum.assign(vectors.next().get(), Functions.PLUS);    }    return sum;}
6f9021560b40d5f0ea4687dcfc9163f88e04e559e2fc0af5f9a1fed73b4e4c24
get
public double get()
{    return value;}
5dd366da2313537c415c3c2ab9ed1909d1250d894a032bd02373d113516571d0
index
public int index()
{    return index;}
0ca3b3a320922927ea9a06f3def94b995d23a5eb7b95de57c7935a827c79759c
set
public void set(double value)
{    this.value = value;}
dc04e04cb93e4f64dd98b12a2895d25809f25ddb204e05973dee88ecd63ea9f5
toArray
public static Vector.Element[] toArray(VectorWritable vectorWritable)
{    Vector.Element[] elements = new Vector.Element[vectorWritable.get().getNumNondefaultElements()];    int k = 0;    for (Element nonZeroElement : vectorWritable.get().nonZeroes()) {        elements[k++] = new TemporaryElement(nonZeroElement.index(), nonZeroElement.get());    }    return elements;}
3d6a767088b4ebb6936765cf2bfef140d20e177a21e308395532a3fde6344850
write
public static void write(Vector vector, Path path, Configuration conf) throws IOException
{    write(vector, path, conf, false);}
7fd0b8ae1bed9c389515f66a71b2d7db164f9ce1313e8f5e419f3b6c96fbf1f8
write
public static void write(Vector vector, Path path, Configuration conf, boolean laxPrecision) throws IOException
{    FileSystem fs = FileSystem.get(path.toUri(), conf);    FSDataOutputStream out = fs.create(path);    try {        VectorWritable vectorWritable = new VectorWritable(vector);        vectorWritable.setWritesLaxPrecision(laxPrecision);        vectorWritable.write(out);    } finally {        Closeables.close(out, false);    }}
694a77ebc3ff199332359e5b106f24175f0902a9734d53fd119eb2639d073e91
readAsIntMap
public static OpenIntIntHashMap readAsIntMap(Path path, Configuration conf) throws IOException
{    FileSystem fs = FileSystem.get(path.toUri(), conf);    FSDataInputStream in = fs.open(path);    try {        return readAsIntMap(in);    } finally {        Closeables.close(in, true);    }}
dfa170d4bd3e3240e8d7b24e32e716d270c4c49991598f6e6cde2fdce584118d
readAsIntMap
private static OpenIntIntHashMap readAsIntMap(DataInput in) throws IOException
{    int flags = in.readByte();    Preconditions.checkArgument(flags >> VectorWritable.NUM_FLAGS == 0, "Unknown flags set: %d", Integer.toString(flags, 2));    boolean dense = (flags & VectorWritable.FLAG_DENSE) != 0;    boolean sequential = (flags & VectorWritable.FLAG_SEQUENTIAL) != 0;    boolean laxPrecision = (flags & VectorWritable.FLAG_LAX_PRECISION) != 0;    Preconditions.checkState(!dense && !sequential, "Only for reading sparse vectors!");    Varint.readUnsignedVarInt(in);    OpenIntIntHashMap values = new OpenIntIntHashMap();    int numNonDefaultElements = Varint.readUnsignedVarInt(in);    for (int i = 0; i < numNonDefaultElements; i++) {        int index = Varint.readUnsignedVarInt(in);        double value = laxPrecision ? in.readFloat() : in.readDouble();        values.put(index, (int) value);    }    return values;}
08b8f290f388cb000a3d70bbeb35afb4e13ba116709b7e8f419aac9549f40403
read
public static Vector read(Path path, Configuration conf) throws IOException
{    FileSystem fs = FileSystem.get(path.toUri(), conf);    FSDataInputStream in = fs.open(path);    try {        return VectorWritable.readVector(in);    } finally {        Closeables.close(in, true);    }}
a8369b603e4bc96e42c13ef4a3ee79aefb2a5a8de8888a9d79ea4aac2962462d
loadSeedVectors
public static List<NamedVector> loadSeedVectors(Configuration conf)
{    String seedPathStr = conf.get(VectorDistanceSimilarityJob.SEEDS_PATH_KEY);    if (seedPathStr == null || seedPathStr.isEmpty()) {        return Collections.emptyList();    }    List<NamedVector> seedVectors = Lists.newArrayList();    long item = 0;    for (Writable value : new SequenceFileDirValueIterable<>(new Path(seedPathStr), PathType.LIST, PathFilters.partFilter(), conf)) {        Class<? extends Writable> valueClass = value.getClass();        if (valueClass.equals(Kluster.class)) {                        Kluster cluster = (Kluster) value;            Vector vector = cluster.getCenter();            if (vector instanceof NamedVector) {                seedVectors.add((NamedVector) vector);            } else {                seedVectors.add(new NamedVector(vector, cluster.getIdentifier()));            }        } else if (valueClass.equals(Canopy.class)) {                        Canopy canopy = (Canopy) value;            Vector vector = canopy.getCenter();            if (vector instanceof NamedVector) {                seedVectors.add((NamedVector) vector);            } else {                seedVectors.add(new NamedVector(vector, canopy.getIdentifier()));            }        } else if (valueClass.equals(Vector.class)) {            Vector vector = (Vector) value;            if (vector instanceof NamedVector) {                seedVectors.add((NamedVector) vector);            } else {                seedVectors.add(new NamedVector(vector, seedPathStr + '.' + item++));            }        } else if (valueClass.equals(VectorWritable.class) || valueClass.isInstance(VectorWritable.class)) {            VectorWritable vw = (VectorWritable) value;            Vector vector = vw.get();            if (vector instanceof NamedVector) {                seedVectors.add((NamedVector) vector);            } else {                seedVectors.add(new NamedVector(vector, seedPathStr + '.' + item++));            }        } else {            throw new IllegalStateException("Bad value class: " + valueClass);        }    }    if (seedVectors.isEmpty()) {        throw new IllegalStateException("No seeds found. Check your path: " + seedPathStr);    }    log.info("Seed Vectors size: {}", seedVectors.size());    return seedVectors;}
fc1e428e426e46a32a92783347cd800582026b43336f9729a249480992d42a51
map
protected void map(WritableComparable<?> key, VectorWritable value, Context context) throws IOException, InterruptedException
{    String keyName;    Vector valVec = value.get();    if (valVec instanceof NamedVector) {        keyName = ((NamedVector) valVec).getName();    } else {        keyName = key.toString();    }    Vector outVec = new DenseVector(new double[seedVectors.size()]);    int i = 0;    for (NamedVector seedVector : seedVectors) {        outVec.setQuick(i++, measure.distance(seedVector, valVec));    }    context.write(new Text(keyName), new VectorWritable(outVec));}
6b7dd49be7482fc8ee0fbe8bd0f24522f2a718c8c816a3d7b048fb4688eb6373
setup
protected void setup(Context context) throws IOException, InterruptedException
{    super.setup(context);    Configuration conf = context.getConfiguration();    measure = ClassUtils.instantiateAs(conf.get(VectorDistanceSimilarityJob.DISTANCE_MEASURE_KEY), DistanceMeasure.class);    measure.configure(conf);    seedVectors = SeedVectorUtil.loadSeedVectors(conf);}
fc1e428e426e46a32a92783347cd800582026b43336f9729a249480992d42a51
map
protected void map(WritableComparable<?> key, VectorWritable value, Context context) throws IOException, InterruptedException
{    String keyName;    Vector valVec = value.get();    if (valVec instanceof NamedVector) {        keyName = ((NamedVector) valVec).getName();    } else {        keyName = key.toString();    }    for (NamedVector seedVector : seedVectors) {        double distance = measure.distance(seedVector, valVec);        if (!usesThreshold || distance <= maxDistance) {            StringTuple outKey = new StringTuple();            outKey.add(seedVector.getName());            outKey.add(keyName);            context.write(outKey, new DoubleWritable(distance));        }    }}
6b7dd49be7482fc8ee0fbe8bd0f24522f2a718c8c816a3d7b048fb4688eb6373
setup
protected void setup(Context context) throws IOException, InterruptedException
{    super.setup(context);    Configuration conf = context.getConfiguration();    String maxDistanceParam = conf.get(VectorDistanceSimilarityJob.MAX_DISTANCE);    if (maxDistanceParam != null) {        usesThreshold = true;        maxDistance = Double.parseDouble(maxDistanceParam);    }    measure = ClassUtils.instantiateAs(conf.get(VectorDistanceSimilarityJob.DISTANCE_MEASURE_KEY), DistanceMeasure.class);    measure.configure(conf);    seedVectors = SeedVectorUtil.loadSeedVectors(conf);}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    ToolRunner.run(new Configuration(), new VectorDistanceSimilarityJob(), args);}
aacecb0f01750d985b78d806dc3c134f0da79efe2752957e0f93ecf5cbf9e492
run
public int run(String[] args) throws Exception
{    addInputOption();    addOutputOption();    addOption(DefaultOptionCreator.distanceMeasureOption().create());    addOption(SEEDS, "s", "The set of vectors to compute distances against.  Must fit in memory on the mapper");    addOption(MAX_DISTANCE, "mx", "set an upper-bound on distance (double) such that any pair of vectors with a" + " distance greater than this value is ignored in the output. Ignored for non pairwise output!");    addOption(DefaultOptionCreator.overwriteOption().create());    addOption(OUT_TYPE_KEY, "ot", "[pw|v] -- Define the output style: pairwise, the default, (pw) or vector (v).  " + "Pairwise is a tuple of <seed, other, distance>, vector is <other, <Vector of size the number of seeds>>.", "pw");    if (parseArguments(args) == null) {        return -1;    }    Path input = getInputPath();    Path output = getOutputPath();    Path seeds = new Path(getOption(SEEDS));    String measureClass = getOption(DefaultOptionCreator.DISTANCE_MEASURE_OPTION);    if (measureClass == null) {        measureClass = SquaredEuclideanDistanceMeasure.class.getName();    }    if (hasOption(DefaultOptionCreator.OVERWRITE_OPTION)) {        HadoopUtil.delete(getConf(), output);    }    DistanceMeasure measure = ClassUtils.instantiateAs(measureClass, DistanceMeasure.class);    String outType = getOption(OUT_TYPE_KEY, "pw");    Double maxDistance = null;    if ("pw".equals(outType)) {        String maxDistanceArg = getOption(MAX_DISTANCE);        if (maxDistanceArg != null) {            maxDistance = Double.parseDouble(maxDistanceArg);            Preconditions.checkArgument(maxDistance > 0.0d, "value for " + MAX_DISTANCE + " must be greater than zero");        }    }    run(getConf(), input, seeds, output, measure, outType, maxDistance);    return 0;}
e95eaf685ebef0433c21c2798952590d5a7740cca5b75611a1fc0ba88fc64467
run
public static void run(Configuration conf, Path input, Path seeds, Path output, DistanceMeasure measure, String outType) throws IOException, ClassNotFoundException, InterruptedException
{    run(conf, input, seeds, output, measure, outType, null);}
6ef56fc10f8208af26b8c8faa7a2b66e71a7de3b502f4a52a64a6cfafdb415df
run
public static void run(Configuration conf, Path input, Path seeds, Path output, DistanceMeasure measure, String outType, Double maxDistance) throws IOException, ClassNotFoundException, InterruptedException
{    if (maxDistance != null) {        conf.set(MAX_DISTANCE, String.valueOf(maxDistance));    }    conf.set(DISTANCE_MEASURE_KEY, measure.getClass().getName());    conf.set(SEEDS_PATH_KEY, seeds.toString());    Job job = new Job(conf, "Vector Distance Similarity: seeds: " + seeds + " input: " + input);    job.setInputFormatClass(SequenceFileInputFormat.class);    job.setOutputFormatClass(SequenceFileOutputFormat.class);    if ("pw".equalsIgnoreCase(outType)) {        job.setMapOutputKeyClass(StringTuple.class);        job.setOutputKeyClass(StringTuple.class);        job.setMapOutputValueClass(DoubleWritable.class);        job.setOutputValueClass(DoubleWritable.class);        job.setMapperClass(VectorDistanceMapper.class);    } else if ("v".equalsIgnoreCase(outType)) {        job.setMapOutputKeyClass(Text.class);        job.setOutputKeyClass(Text.class);        job.setMapOutputValueClass(VectorWritable.class);        job.setOutputValueClass(VectorWritable.class);        job.setMapperClass(VectorDistanceInvertedMapper.class);    } else {        throw new IllegalArgumentException("Invalid outType specified: " + outType);    }    job.setNumReduceTasks(0);    FileInputFormat.addInputPath(job, input);    FileOutputFormat.setOutputPath(job, output);    job.setJarByClass(VectorDistanceSimilarityJob.class);    HadoopUtil.delete(conf, output);    if (!job.waitForCompletion(true)) {        throw new IllegalStateException("VectorDistance Similarity failed processing " + seeds);    }}
18d12c48b72a5a409e3bc90aa0508e5b8cf6c8fb873c8e7d6ac5a6f5b0e562f8
runJob
public Vector runJob(Path inputPath, Path tempPath, int numRows, int numCols, Vector b, Preconditioner preconditioner, int maxIterations, double maxError)
{    DistributedRowMatrix matrix = new DistributedRowMatrix(inputPath, tempPath, numRows, numCols);    matrix.setConf(conf);    return solve(matrix, b, preconditioner, maxIterations, maxError);}
d221713f567be6c3a854157b6beb8a5fd5dd64b69c1ef157fb4bac811a41c3f7
getConf
public Configuration getConf()
{    return conf;}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    this.conf = conf;}
b31cb6a894acd9e406667b955507e22a99129892a3c5ceaddbedccc2f2a9db5b
run
public int run(String[] strings) throws Exception
{    Path inputPath = new Path(AbstractJob.getOption(parsedArgs, "--input"));    Path outputPath = new Path(AbstractJob.getOption(parsedArgs, "--output"));    Path tempPath = new Path(AbstractJob.getOption(parsedArgs, "--tempDir"));    Path vectorPath = new Path(AbstractJob.getOption(parsedArgs, "--vector"));    int numRows = Integer.parseInt(AbstractJob.getOption(parsedArgs, "--numRows"));    int numCols = Integer.parseInt(AbstractJob.getOption(parsedArgs, "--numCols"));    int maxIterations = parsedArgs.containsKey("--maxIter") ? Integer.parseInt(AbstractJob.getOption(parsedArgs, "--maxIter")) : numCols + 2;    double maxError = parsedArgs.containsKey("--maxError") ? Double.parseDouble(AbstractJob.getOption(parsedArgs, "--maxError")) : ConjugateGradientSolver.DEFAULT_MAX_ERROR;    Vector b = loadInputVector(vectorPath);    Vector x = runJob(inputPath, tempPath, numRows, numCols, b, null, maxIterations, maxError);    saveOutputVector(outputPath, x);    tempPath.getFileSystem(conf).delete(tempPath, true);    return 0;}
a7c94987ebebc00735a46f757c525540871e6dfd0d7f1e68f772988270317961
job
public DistributedConjugateGradientSolverJob job()
{    return new DistributedConjugateGradientSolverJob();}
bc84358393cee7496b61ce889c346e3b8334120cd41bce62606c1c61c77046cd
loadInputVector
private Vector loadInputVector(Path path) throws IOException
{    FileSystem fs = path.getFileSystem(conf);    try (SequenceFile.Reader reader = new SequenceFile.Reader(fs, path, conf)) {        VectorWritable value = new VectorWritable();        if (!reader.next(new IntWritable(), value)) {            throw new IOException("Input vector file is empty.");        }        return value.get();    }}
dba67af87d10a6e1a32c89fdc4eb75e41854718755429aa85f4727893afddefd
saveOutputVector
private void saveOutputVector(Path path, Vector v) throws IOException
{    FileSystem fs = path.getFileSystem(conf);    try (SequenceFile.Writer writer = new SequenceFile.Writer(fs, conf, path, IntWritable.class, VectorWritable.class)) {        writer.append(new IntWritable(0), new VectorWritable(v));    }}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    DistributedConjugateGradientSolver.this.setConf(conf);}
d221713f567be6c3a854157b6beb8a5fd5dd64b69c1ef157fb4bac811a41c3f7
getConf
public Configuration getConf()
{    return DistributedConjugateGradientSolver.this.getConf();}
aacecb0f01750d985b78d806dc3c134f0da79efe2752957e0f93ecf5cbf9e492
run
public int run(String[] args) throws Exception
{    addInputOption();    addOutputOption();    addOption("numRows", "nr", "Number of rows in the input matrix", true);    addOption("numCols", "nc", "Number of columns in the input matrix", true);    addOption("vector", "b", "Vector to solve against", true);    addOption("lambda", "l", "Scalar in A + lambda * I [default = 0]", "0.0");    addOption("symmetric", "sym", "Is the input matrix square and symmetric?", "true");    addOption("maxIter", "x", "Maximum number of iterations to run");    addOption("maxError", "err", "Maximum residual error to allow before stopping");    DistributedConjugateGradientSolver.this.parsedArgs = parseArguments(args);    if (DistributedConjugateGradientSolver.this.parsedArgs == null) {        return -1;    } else {        Configuration conf = getConf();        if (conf == null) {            conf = new Configuration();        }        DistributedConjugateGradientSolver.this.setConf(conf);        return DistributedConjugateGradientSolver.this.run(args);    }}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    ToolRunner.run(new DistributedConjugateGradientSolver().job(), args);}
195241333111abf208aa93e090c2440a9b24a40efd5ed124668c62e0d09cef26
variance
public static double variance(Path input, Path output, Configuration baseConf) throws IOException, InterruptedException, ClassNotFoundException
{    VarianceTotals varianceTotals = computeVarianceTotals(input, output, baseConf);    return varianceTotals.computeVariance();}
167b2aa868e10d2a64484157e626b20d9fbffcf6d137b65d5ac3c391b7b923a7
varianceForGivenMean
public static double varianceForGivenMean(Path input, Path output, double mean, Configuration baseConf) throws IOException, InterruptedException, ClassNotFoundException
{    VarianceTotals varianceTotals = computeVarianceTotals(input, output, baseConf);    return varianceTotals.computeVarianceForGivenMean(mean);}
f5eb2acf8e49e59bdae3e33738afc6bb1bbebe8f6d1888515e9af35b189034bf
computeVarianceTotals
private static VarianceTotals computeVarianceTotals(Path input, Path output, Configuration baseConf) throws IOException, InterruptedException, ClassNotFoundException
{    Configuration conf = new Configuration(baseConf);    conf.set("io.serializations", "org.apache.hadoop.io.serializer.JavaSerialization," + "org.apache.hadoop.io.serializer.WritableSerialization");    Job job = HadoopUtil.prepareJob(input, output, SequenceFileInputFormat.class, StandardDeviationCalculatorMapper.class, IntWritable.class, DoubleWritable.class, StandardDeviationCalculatorReducer.class, IntWritable.class, DoubleWritable.class, SequenceFileOutputFormat.class, conf);    HadoopUtil.delete(conf, output);    job.setCombinerClass(StandardDeviationCalculatorReducer.class);    boolean succeeded = job.waitForCompletion(true);    if (!succeeded) {        throw new IllegalStateException("Job failed!");    }        Path filesPattern = new Path(output, "part-*");    double sumOfSquares = 0;    double sum = 0;    double totalCount = 0;    for (Pair<Writable, Writable> record : new SequenceFileDirIterable<>(filesPattern, PathType.GLOB, null, null, true, conf)) {        int key = ((IntWritable) record.getFirst()).get();        if (key == StandardDeviationCalculatorMapper.SUM_OF_SQUARES.get()) {            sumOfSquares += ((DoubleWritable) record.getSecond()).get();        } else if (key == StandardDeviationCalculatorMapper.TOTAL_COUNT.get()) {            totalCount += ((DoubleWritable) record.getSecond()).get();        } else if (key == StandardDeviationCalculatorMapper.SUM.get()) {            sum += ((DoubleWritable) record.getSecond()).get();        }    }    VarianceTotals varianceTotals = new VarianceTotals();    varianceTotals.setSum(sum);    varianceTotals.setSumOfSquares(sumOfSquares);    varianceTotals.setTotalCount(totalCount);    return varianceTotals;}
abed97087edea470c3b34de2f432088b7e9ec9b6cf718340ef83439cdd209984
stdDev
public static double stdDev(Path input, Path output, Configuration baseConf) throws IOException, InterruptedException, ClassNotFoundException
{    return Math.sqrt(variance(input, output, baseConf));}
b39f46996bca454bef110f9775022c3bdb0e094fd5cc96391dfe5bbee505fa3d
stdDevForGivenMean
public static double stdDevForGivenMean(Path input, Path output, double mean, Configuration baseConf) throws IOException, InterruptedException, ClassNotFoundException
{    return Math.sqrt(varianceForGivenMean(input, output, mean, baseConf));}
efb59d79fd421d485f3a65dba7304bc79f73382047505807e945c3ec5f51cae0
map
protected void map(IntWritable key, Writable value, Context context) throws IOException, InterruptedException
{    if (key.get() == -1) {        return;    }        double df = Double.NaN;    if (value instanceof LongWritable) {        df = ((LongWritable) value).get();    } else if (value instanceof DoubleWritable) {        df = ((DoubleWritable) value).get();    }    if (!Double.isNaN(df)) {                context.write(SUM_OF_SQUARES, new DoubleWritable(df * df));        context.write(SUM, new DoubleWritable(df));                context.write(TOTAL_COUNT, new DoubleWritable(1));    }}
11188d86114775a41a144b64d5ebf1a110f2f09114fe385cf3be70172156eb04
reduce
protected void reduce(IntWritable key, Iterable<DoubleWritable> values, Context context) throws IOException, InterruptedException
{    double sum = 0.0;    for (DoubleWritable value : values) {        sum += value.get();    }    context.write(key, new DoubleWritable(sum));}
c11fc73cb5dbafe7686939f081410ded2daadfe8cc57ed0442e1eb95c2c8b9ac
getSumOfSquares
public double getSumOfSquares()
{    return sumOfSquares;}
fbb54a8698d0c32ea0c3e0adf4bb5a15bdf78b27f8850049fd916e432cdbfbb6
setSumOfSquares
public void setSumOfSquares(double sumOfSquares)
{    this.sumOfSquares = sumOfSquares;}
76aecdcf1fe96b3855ea1da1fb092d6250a7458a5adc7a2e603648a48077cbce
getSum
public double getSum()
{    return sum;}
4d08b9337a9dd9f3c194861628249ef2917c96d360a240054c71f646eaba4a35
setSum
public void setSum(double sum)
{    this.sum = sum;}
a7f02629288ccfe2b62fc0c09b6bbc198e0c1c970789904bc354abc4074a8b3c
getTotalCount
public double getTotalCount()
{    return totalCount;}
19017d3327082d2748b2930929f85dcadb47fbb00ab4ac0bb20ae5e9e5a694b6
setTotalCount
public void setTotalCount(double totalCount)
{    this.totalCount = totalCount;}
a16e4709846842f67613e9e0cb8fd32248ef6a33a0899b8d9768c1b516b62a58
computeMean
public double computeMean()
{    return sum / totalCount;}
fcf3f2a8250f2123b60887aebadef5a50e865c70985bc1623a0a6ed8f542a108
computeVariance
public double computeVariance()
{    return ((totalCount * sumOfSquares) - (sum * sum)) / (totalCount * (totalCount - 1.0));}
24ebf54eb4740c1c8ad6ece1649f6ecae80119b1eea25e9abc46fb14c5d11c7f
computeVarianceForGivenMean
public double computeVarianceForGivenMean(double mean)
{    return (sumOfSquares - totalCount * mean * mean) / (totalCount - 1.0);}
575b0c06b39ecc623839b56d197693e61a03ae1e8e73b443d344b10d41445dec
map
protected void map(Writable key, VectorWritable value, Context context) throws IOException, InterruptedException
{    Vector vec = value.get();    int vecSize = vec.size();    if (aCols == null) {        aCols = new Vector[vecSize];    } else if (aCols.length < vecSize) {        aCols = Arrays.copyOf(aCols, vecSize);    }    if (vec.isDense()) {        for (int i = 0; i < vecSize; i++) {            extendAColIfNeeded(i, aRowCount + 1);            aCols[i].setQuick(aRowCount, vec.getQuick(i));        }    } else if (vec.size() > 0) {        for (Vector.Element vecEl : vec.nonZeroes()) {            int i = vecEl.index();            extendAColIfNeeded(i, aRowCount + 1);            aCols[i].setQuick(aRowCount, vecEl.get());        }    }    aRowCount++;}
08916f49a6aa8ae4aff09dc0db7aa392f89456b9ccc124c8928551f8a5b077bb
extendAColIfNeeded
private void extendAColIfNeeded(int col, int rowCount)
{    if (aCols[col] == null) {        aCols[col] = new SequentialAccessSparseVector(rowCount < blockHeight ? blockHeight : rowCount, 1);    } else if (aCols[col].size() < rowCount) {        Vector newVec = new SequentialAccessSparseVector(rowCount + blockHeight, aCols[col].getNumNondefaultElements() << 1);        newVec.viewPart(0, aCols[col].size()).assign(aCols[col]);        aCols[col] = newVec;    }}
2e250b70eb1261a97967b8b894cf822fc9e7eb36891dbb77c6d16369f85de12a
cleanup
protected void cleanup(Context context) throws IOException, InterruptedException
{    try {        yiCols = new double[kp][];        for (int i = 0; i < kp; i++) {            yiCols[i] = new double[Math.min(aRowCount, blockHeight)];        }        int numPasses = (aRowCount - 1) / blockHeight + 1;        String propBtPathStr = context.getConfiguration().get(PROP_BT_PATH);        Validate.notNull(propBtPathStr, "Bt input is not set");        Path btPath = new Path(propBtPathStr);        DenseBlockWritable dbw = new DenseBlockWritable();        /*         * so it turns out that it may be much more efficient to do a few         * independent passes over Bt accumulating the entire block in memory         * than pass huge amount of blocks out to combiner. so we aim of course         * to fit entire s x (k+p) dense block in memory where s is the number         * of A rows in this split. If A is much sparser than (k+p) avg # of         * elements per row then the block may exceed the split size. if this         * happens, and if the given blockHeight is not high enough to         * accomodate this (because of memory constraints), then we start         * splitting s into several passes. since computation is cpu-bound         * anyway, it should be o.k. for supersparse inputs. (as ok it can be         * that projection is thicker than the original anyway, why would one         * use that many k+p then).         */        int lastRowIndex = -1;        for (int pass = 0; pass < numPasses; pass++) {            if (distributedBt) {                btInput = new SequenceFileDirIterator<>(btLocalPath, true, localFsConfig);            } else {                btInput = new SequenceFileDirIterator<>(btPath, PathType.GLOB, null, null, true, context.getConfiguration());            }            closeables.addFirst(btInput);            Validate.isTrue(btInput.hasNext(), "Empty B' input!");            int aRowBegin = pass * blockHeight;            int bh = Math.min(blockHeight, aRowCount - aRowBegin);            /*           * check if we need to trim block allocation           */            if (pass > 0) {                if (bh == blockHeight) {                    for (int i = 0; i < kp; i++) {                        Arrays.fill(yiCols[i], 0.0);                    }                } else {                    for (int i = 0; i < kp; i++) {                        yiCols[i] = null;                    }                    for (int i = 0; i < kp; i++) {                        yiCols[i] = new double[bh];                    }                }            }            while (btInput.hasNext()) {                Pair<IntWritable, VectorWritable> btRec = btInput.next();                int btIndex = btRec.getFirst().get();                Vector btVec = btRec.getSecond().get();                Vector aCol;                if (btIndex > aCols.length || (aCol = aCols[btIndex]) == null || aCol.size() == 0) {                    /* 100% zero A column in the block, skip it as sparse */                    continue;                }                int j = -1;                for (Vector.Element aEl : aCol.nonZeroes()) {                    j = aEl.index();                    /*               * now we compute only swathes between aRowBegin..aRowBegin+bh               * exclusive. it seems like a deficiency but in fact i think it               * will balance itself out: either A is dense and then we               * shouldn't have more than one pass and therefore filter               * conditions will never kick in. Or, the only situation where we               * can't fit Y_i block in memory is when A input is much sparser               * than k+p per row. But if this is the case, then we'd be looking               * at very few elements without engaging them in any operations so               * even then it should be ok.               */                    if (j < aRowBegin) {                        continue;                    }                    if (j >= aRowBegin + bh) {                        break;                    }                    /*               * assume btVec is dense               */                    if (xi != null) {                        /*                 * MAHOUT-817: PCA correction for B'. I rewrite the whole                 * computation loop so i don't have to check if PCA correction                 * is needed at individual element level. It looks bulkier this                 * way but perhaps less wasteful on cpu.                 */                        for (int s = 0; s < kp; s++) {                                                        double xii = xi.size() > btIndex ? xi.get(btIndex) : 0.0;                            yiCols[s][j - aRowBegin] += aEl.get() * (btVec.getQuick(s) - xii * sq.get(s));                        }                    } else {                        /*                 * no PCA correction                 */                        for (int s = 0; s < kp; s++) {                            yiCols[s][j - aRowBegin] += aEl.get() * btVec.getQuick(s);                        }                    }                }                if (lastRowIndex < j) {                    lastRowIndex = j;                }            }            /*           * so now we have stuff in yi           */            dbw.setBlock(yiCols);            outKey.setTaskItemOrdinal(pass);            context.write(outKey, dbw);            closeables.remove(btInput);            btInput.close();        }    } finally {        IOUtils.close(closeables);    }}
6b7dd49be7482fc8ee0fbe8bd0f24522f2a718c8c816a3d7b048fb4688eb6373
setup
protected void setup(Context context) throws IOException, InterruptedException
{    Configuration conf = context.getConfiguration();    int k = Integer.parseInt(conf.get(QRFirstStep.PROP_K));    int p = Integer.parseInt(conf.get(QRFirstStep.PROP_P));    kp = k + p;    outKey = new SplitPartitionedWritable(context);    blockHeight = conf.getInt(BtJob.PROP_OUTER_PROD_BLOCK_HEIGHT, -1);    distributedBt = conf.get(PROP_BT_BROADCAST) != null;    if (distributedBt) {        btLocalPath = HadoopUtil.getCachedFiles(conf);        localFsConfig = new Configuration();        localFsConfig.set("fs.default.name", "file:///");    }    /*       * PCA -related corrections (MAHOUT-817)       */    String xiPathStr = conf.get(PROP_XI_PATH);    if (xiPathStr != null) {        xi = SSVDHelper.loadAndSumUpVectors(new Path(xiPathStr), conf);        sq = SSVDHelper.loadAndSumUpVectors(new Path(conf.get(PROP_SQ_PATH)), conf);    }}
6b7dd49be7482fc8ee0fbe8bd0f24522f2a718c8c816a3d7b048fb4688eb6373
setup
protected void setup(Context context) throws IOException, InterruptedException
{    Configuration conf = context.getConfiguration();    blockHeight = conf.getInt(BtJob.PROP_OUTER_PROD_BLOCK_HEIGHT, -1);    String sbPathStr = conf.get(PROP_SB_PATH);    /*       * PCA -related corrections (MAHOUT-817)       */    if (sbPathStr != null) {        sb = SSVDHelper.loadAndSumUpVectors(new Path(sbPathStr), conf);    }}
38c5db4ca4eb3001e4ed351af60e50ab120cff78aba55b01db56d0b65fafb9c4
setupBlock
protected void setupBlock(Context context, SplitPartitionedWritable spw) throws InterruptedException, IOException
{    IOUtils.close(closeables);    qhatCollector = createOutputCollector(QJob.OUTPUT_QHAT, spw, context, DenseBlockWritable.class);    rhatCollector = createOutputCollector(QJob.OUTPUT_RHAT, spw, context, VectorWritable.class);    qr = new QRFirstStep(context.getConfiguration(), qhatCollector, rhatCollector);    closeables.addFirst(qr);    lastTaskId = spw.getTaskId();}
2dbc3c18267b076bc5d488e62b27b95e6b64316f394114b8664d7708057cab87
reduce
protected void reduce(SplitPartitionedWritable key, Iterable<DenseBlockWritable> values, Context context) throws IOException, InterruptedException
{    if (key.getTaskId() != lastTaskId) {        setupBlock(context, key);    }    Iterator<DenseBlockWritable> iter = values.iterator();    DenseBlockWritable dbw = iter.next();    double[][] yiCols = dbw.getBlock();    if (iter.hasNext()) {        throw new IOException("Unexpected extra Y_i block in reducer input.");    }    long blockBase = key.getTaskItemOrdinal() * blockHeight;    int bh = yiCols[0].length;    if (yiRow == null) {        yiRow = new DenseVector(yiCols.length);    }    for (int k = 0; k < bh; k++) {        for (int j = 0; j < yiCols.length; j++) {            yiRow.setQuick(j, yiCols[j][k]);        }        key.setTaskItemOrdinal(blockBase + k);                if (sb != null) {            yiRow.assign(sb, Functions.MINUS);        }        qr.collect(key, yiRow);    }}
75605d815100162eba87e57102fd1fdd28f4c6ea7bdbc845932c45d4eb4dac8f
getSplitFilePath
private Path getSplitFilePath(String name, SplitPartitionedWritable spw, Context context) throws InterruptedException, IOException
{    String uniqueFileName = FileOutputFormat.getUniqueFile(context, name, "");    uniqueFileName = uniqueFileName.replaceFirst("-r-", "-m-");    uniqueFileName = uniqueFileName.replaceFirst("\\d+$", Matcher.quoteReplacement(NUMBER_FORMAT.format(spw.getTaskId())));    return new Path(FileOutputFormat.getWorkOutputPath(context), uniqueFileName);}
2aaeaf45ed91bbc0f535737c6a0567a5d3b6e8f20e90c6ae5d8255b39b4beb07
createOutputCollector
private OutputCollector<K, V> createOutputCollector(String name, final SplitPartitionedWritable spw, Context ctx, Class<V> valueClass) throws IOException, InterruptedException
{    Path outputPath = getSplitFilePath(name, spw, ctx);    final SequenceFile.Writer w = SequenceFile.createWriter(FileSystem.get(outputPath.toUri(), ctx.getConfiguration()), ctx.getConfiguration(), outputPath, SplitPartitionedWritable.class, valueClass);    closeables.addFirst(w);    return new OutputCollector<K, V>() {        @Override        public void collect(K key, V val) throws IOException {            w.append(spw, val);        }    };}
945742de58720be86381e50596818983ed042462fb77f6aacc358aabccc34329
collect
public void collect(K key, V val) throws IOException
{    w.append(spw, val);}
2e250b70eb1261a97967b8b894cf822fc9e7eb36891dbb77c6d16369f85de12a
cleanup
protected void cleanup(Context context) throws IOException, InterruptedException
{    IOUtils.close(closeables);}
7125f6f7bc9b2248e7593a9c3db34d3f490d08fbf448cf08d40fc078b8795cf2
run
public static void run(Configuration conf, Path[] inputAPaths, Path inputBtGlob, Path xiPath, Path sqPath, Path sbPath, Path outputPath, int aBlockRows, int minSplitSize, int k, int p, int outerProdBlockHeight, int numReduceTasks, boolean broadcastBInput) throws ClassNotFoundException, InterruptedException, IOException
{    JobConf oldApiJob = new JobConf(conf);    Job job = new Job(oldApiJob);    job.setJobName("ABt-job");    job.setJarByClass(ABtDenseOutJob.class);    job.setInputFormatClass(SequenceFileInputFormat.class);    FileInputFormat.setInputPaths(job, inputAPaths);    if (minSplitSize > 0) {        FileInputFormat.setMinInputSplitSize(job, minSplitSize);    }    FileOutputFormat.setOutputPath(job, outputPath);    SequenceFileOutputFormat.setOutputCompressionType(job, CompressionType.BLOCK);    job.setMapOutputKeyClass(SplitPartitionedWritable.class);    job.setMapOutputValueClass(DenseBlockWritable.class);    job.setOutputKeyClass(SplitPartitionedWritable.class);    job.setOutputValueClass(VectorWritable.class);    job.setMapperClass(ABtMapper.class);    job.setReducerClass(QRReducer.class);    job.getConfiguration().setInt(QJob.PROP_AROWBLOCK_SIZE, aBlockRows);    job.getConfiguration().setInt(BtJob.PROP_OUTER_PROD_BLOCK_HEIGHT, outerProdBlockHeight);    job.getConfiguration().setInt(QRFirstStep.PROP_K, k);    job.getConfiguration().setInt(QRFirstStep.PROP_P, p);    job.getConfiguration().set(PROP_BT_PATH, inputBtGlob.toString());    /*     * PCA-related options, MAHOUT-817     */    if (xiPath != null) {        job.getConfiguration().set(PROP_XI_PATH, xiPath.toString());        job.getConfiguration().set(PROP_SB_PATH, sbPath.toString());        job.getConfiguration().set(PROP_SQ_PATH, sqPath.toString());    }    job.setNumReduceTasks(numReduceTasks);        if (broadcastBInput) {        job.getConfiguration().set(PROP_BT_BROADCAST, "y");        FileSystem fs = FileSystem.get(inputBtGlob.toUri(), conf);        FileStatus[] fstats = fs.globStatus(inputBtGlob);        if (fstats != null) {            for (FileStatus fstat : fstats) {                /*           * new api is not enabled yet in our dependencies at this time, still           * using deprecated one           */                DistributedCache.addCacheFile(fstat.getPath().toUri(), job.getConfiguration());            }        }    }    job.submit();    job.waitForCompletion(false);    if (!job.isSuccessful()) {        throw new IOException("ABt job unsuccessful.");    }}
575b0c06b39ecc623839b56d197693e61a03ae1e8e73b443d344b10d41445dec
map
protected void map(Writable key, VectorWritable value, Context context) throws IOException, InterruptedException
{    Vector vec = value.get();    int vecSize = vec.size();    if (aCols == null) {        aCols = new Vector[vecSize];    } else if (aCols.length < vecSize) {        aCols = Arrays.copyOf(aCols, vecSize);    }    if (vec.isDense()) {        for (int i = 0; i < vecSize; i++) {            extendAColIfNeeded(i, aRowCount + 1);            aCols[i].setQuick(aRowCount, vec.getQuick(i));        }    } else {        for (Vector.Element vecEl : vec.nonZeroes()) {            int i = vecEl.index();            extendAColIfNeeded(i, aRowCount + 1);            aCols[i].setQuick(aRowCount, vecEl.get());        }    }    aRowCount++;}
08916f49a6aa8ae4aff09dc0db7aa392f89456b9ccc124c8928551f8a5b077bb
extendAColIfNeeded
private void extendAColIfNeeded(int col, int rowCount)
{    if (aCols[col] == null) {        aCols[col] = new SequentialAccessSparseVector(rowCount < 10000 ? 10000 : rowCount, 1);    } else if (aCols[col].size() < rowCount) {        Vector newVec = new SequentialAccessSparseVector(rowCount << 1, aCols[col].getNumNondefaultElements() << 1);        newVec.viewPart(0, aCols[col].size()).assign(aCols[col]);        aCols[col] = newVec;    }}
2e250b70eb1261a97967b8b894cf822fc9e7eb36891dbb77c6d16369f85de12a
cleanup
protected void cleanup(Context context) throws IOException, InterruptedException
{    try {                int lastRowIndex = -1;        while (btInput.hasNext()) {            Pair<IntWritable, VectorWritable> btRec = btInput.next();            int btIndex = btRec.getFirst().get();            Vector btVec = btRec.getSecond().get();            Vector aCol;            if (btIndex > aCols.length || (aCol = aCols[btIndex]) == null) {                continue;            }            int j = -1;            for (Vector.Element aEl : aCol.nonZeroes()) {                j = aEl.index();                                                                                yiCollector.collect((long) j, btVec.times(aEl.get()));            }            if (lastRowIndex < j) {                lastRowIndex = j;            }        }        aCols = null;                                        Vector yDummy = new SequentialAccessSparseVector(kp);                for (lastRowIndex += 1; lastRowIndex < aRowCount; lastRowIndex++) {                                    yiCollector.collect((long) lastRowIndex, yDummy);        }    } finally {        IOUtils.close(closeables);    }}
4216e7eb84a707de83620831dc1935bd620a5efc11fcf4174fd1efa57a099854
setup
protected void setup(final Context context) throws IOException, InterruptedException
{    int k = Integer.parseInt(context.getConfiguration().get(QRFirstStep.PROP_K));    int p = Integer.parseInt(context.getConfiguration().get(QRFirstStep.PROP_P));    kp = k + p;    outKey = new SplitPartitionedWritable(context);    String propBtPathStr = context.getConfiguration().get(PROP_BT_PATH);    Validate.notNull(propBtPathStr, "Bt input is not set");    Path btPath = new Path(propBtPathStr);    boolean distributedBt = context.getConfiguration().get(PROP_BT_BROADCAST) != null;    if (distributedBt) {        Path[] btFiles = HadoopUtil.getCachedFiles(context.getConfiguration());                        StringBuilder btLocalPath = new StringBuilder();        for (Path btFile : btFiles) {            if (btLocalPath.length() > 0) {                btLocalPath.append(Path.SEPARATOR_CHAR);            }            btLocalPath.append(btFile);        }        btInput = new SequenceFileDirIterator<>(new Path(btLocalPath.toString()), PathType.LIST, null, null, true, context.getConfiguration());    } else {        btInput = new SequenceFileDirIterator<>(btPath, PathType.GLOB, null, null, true, context.getConfiguration());    }        closeables.addFirst(btInput);    OutputCollector<LongWritable, SparseRowBlockWritable> yiBlockCollector = new OutputCollector<LongWritable, SparseRowBlockWritable>() {        @Override        public void collect(LongWritable blockKey, SparseRowBlockWritable block) throws IOException {            outKey.setTaskItemOrdinal((int) blockKey.get());            try {                context.write(outKey, block);            } catch (InterruptedException exc) {                throw new IOException("Interrupted", exc);            }        }    };    blockHeight = context.getConfiguration().getInt(BtJob.PROP_OUTER_PROD_BLOCK_HEIGHT, -1);    yiCollector = new SparseRowBlockAccumulator(blockHeight, yiBlockCollector);    closeables.addFirst(yiCollector);}
71b5d50b932c754b8c09b7d5577117e10742f58d738d1367e45324b6adb0a3ee
collect
public void collect(LongWritable blockKey, SparseRowBlockWritable block) throws IOException
{    outKey.setTaskItemOrdinal((int) blockKey.get());    try {        context.write(outKey, block);    } catch (InterruptedException exc) {        throw new IOException("Interrupted", exc);    }}
6b7dd49be7482fc8ee0fbe8bd0f24522f2a718c8c816a3d7b048fb4688eb6373
setup
protected void setup(Context context) throws IOException, InterruptedException
{    blockHeight = context.getConfiguration().getInt(BtJob.PROP_OUTER_PROD_BLOCK_HEIGHT, -1);}
38c5db4ca4eb3001e4ed351af60e50ab120cff78aba55b01db56d0b65fafb9c4
setupBlock
protected void setupBlock(Context context, SplitPartitionedWritable spw) throws InterruptedException, IOException
{    IOUtils.close(closeables);    qhatCollector = createOutputCollector(QJob.OUTPUT_QHAT, spw, context, DenseBlockWritable.class);    rhatCollector = createOutputCollector(QJob.OUTPUT_RHAT, spw, context, VectorWritable.class);    qr = new QRFirstStep(context.getConfiguration(), qhatCollector, rhatCollector);    closeables.addFirst(qr);    lastTaskId = spw.getTaskId();}
fc86ab8107e1477a713e0f33192248aec611b671782ca8bb7c3120a5358b27a5
reduce
protected void reduce(SplitPartitionedWritable key, Iterable<SparseRowBlockWritable> values, Context context) throws IOException, InterruptedException
{    accum.clear();    for (SparseRowBlockWritable bw : values) {        accum.plusBlock(bw);    }    if (key.getTaskId() != lastTaskId) {        setupBlock(context, key);    }    long blockBase = key.getTaskItemOrdinal() * blockHeight;    for (int k = 0; k < accum.getNumRows(); k++) {        Vector yiRow = accum.getRows()[k];        key.setTaskItemOrdinal(blockBase + accum.getRowIndices()[k]);        qr.collect(key, yiRow);    }}
75605d815100162eba87e57102fd1fdd28f4c6ea7bdbc845932c45d4eb4dac8f
getSplitFilePath
private Path getSplitFilePath(String name, SplitPartitionedWritable spw, Context context) throws InterruptedException, IOException
{    String uniqueFileName = FileOutputFormat.getUniqueFile(context, name, "");    uniqueFileName = uniqueFileName.replaceFirst("-r-", "-m-");    uniqueFileName = uniqueFileName.replaceFirst("\\d+$", Matcher.quoteReplacement(NUMBER_FORMAT.format(spw.getTaskId())));    return new Path(FileOutputFormat.getWorkOutputPath(context), uniqueFileName);}
2aaeaf45ed91bbc0f535737c6a0567a5d3b6e8f20e90c6ae5d8255b39b4beb07
createOutputCollector
private OutputCollector<K, V> createOutputCollector(String name, final SplitPartitionedWritable spw, Context ctx, Class<V> valueClass) throws IOException, InterruptedException
{    Path outputPath = getSplitFilePath(name, spw, ctx);    final SequenceFile.Writer w = SequenceFile.createWriter(FileSystem.get(outputPath.toUri(), ctx.getConfiguration()), ctx.getConfiguration(), outputPath, SplitPartitionedWritable.class, valueClass);    closeables.addFirst(w);    return new OutputCollector<K, V>() {        @Override        public void collect(K key, V val) throws IOException {            w.append(spw, val);        }    };}
945742de58720be86381e50596818983ed042462fb77f6aacc358aabccc34329
collect
public void collect(K key, V val) throws IOException
{    w.append(spw, val);}
2e250b70eb1261a97967b8b894cf822fc9e7eb36891dbb77c6d16369f85de12a
cleanup
protected void cleanup(Context context) throws IOException, InterruptedException
{    IOUtils.close(closeables);}
32cbd1fb0a9790f7d7284ad953fdaa5fbd129f508160963114abc79e14dd24cd
run
public static void run(Configuration conf, Path[] inputAPaths, Path inputBtGlob, Path outputPath, int aBlockRows, int minSplitSize, int k, int p, int outerProdBlockHeight, int numReduceTasks, boolean broadcastBInput) throws ClassNotFoundException, InterruptedException, IOException
{    JobConf oldApiJob = new JobConf(conf);                                                        Job job = new Job(oldApiJob);    job.setJobName("ABt-job");    job.setJarByClass(ABtJob.class);    job.setInputFormatClass(SequenceFileInputFormat.class);    FileInputFormat.setInputPaths(job, inputAPaths);    if (minSplitSize > 0) {        FileInputFormat.setMinInputSplitSize(job, minSplitSize);    }    FileOutputFormat.setOutputPath(job, outputPath);    SequenceFileOutputFormat.setOutputCompressionType(job, CompressionType.BLOCK);    job.setMapOutputKeyClass(SplitPartitionedWritable.class);    job.setMapOutputValueClass(SparseRowBlockWritable.class);    job.setOutputKeyClass(SplitPartitionedWritable.class);    job.setOutputValueClass(VectorWritable.class);    job.setMapperClass(ABtMapper.class);    job.setCombinerClass(BtJob.OuterProductCombiner.class);    job.setReducerClass(QRReducer.class);    job.getConfiguration().setInt(QJob.PROP_AROWBLOCK_SIZE, aBlockRows);    job.getConfiguration().setInt(BtJob.PROP_OUTER_PROD_BLOCK_HEIGHT, outerProdBlockHeight);    job.getConfiguration().setInt(QRFirstStep.PROP_K, k);    job.getConfiguration().setInt(QRFirstStep.PROP_P, p);    job.getConfiguration().set(PROP_BT_PATH, inputBtGlob.toString());            job.setNumReduceTasks(numReduceTasks);        if (broadcastBInput) {        job.getConfiguration().set(PROP_BT_BROADCAST, "y");        FileSystem fs = FileSystem.get(inputBtGlob.toUri(), conf);        FileStatus[] fstats = fs.globStatus(inputBtGlob);        if (fstats != null) {            for (FileStatus fstat : fstats) {                /*           * new api is not enabled yet in our dependencies at this time, still           * using deprecated one           */                DistributedCache.addCacheFile(fstat.getPath().toUri(), conf);            }        }    }    job.submit();    job.waitForCompletion(false);    if (!job.isSuccessful()) {        throw new IOException("ABt job unsuccessful.");    }}
575b0c06b39ecc623839b56d197693e61a03ae1e8e73b443d344b10d41445dec
map
protected void map(Writable key, VectorWritable value, Context context) throws IOException, InterruptedException
{    mapContext = context;        Vector aRow = value.get();    Vector qRow = qr.next();    int kp = qRow.size();        outputQRow(key, qRow, aRow);        if (computeSq) {        if (sqAccum == null) {            sqAccum = new DenseVector(kp);        }        sqAccum.assign(qRow, Functions.PLUS);    }    if (btRow == null) {        btRow = new DenseVector(kp);    }    if (!aRow.isDense()) {        for (Vector.Element el : aRow.nonZeroes()) {            double mul = el.get();            for (int j = 0; j < kp; j++) {                btRow.setQuick(j, mul * qRow.getQuick(j));            }            btCollector.collect((long) el.index(), btRow);        }    } else {        int n = aRow.size();        for (int i = 0; i < n; i++) {            double mul = aRow.getQuick(i);            for (int j = 0; j < kp; j++) {                btRow.setQuick(j, mul * qRow.getQuick(j));            }            btCollector.collect((long) i, btRow);        }    }}
6b7dd49be7482fc8ee0fbe8bd0f24522f2a718c8c816a3d7b048fb4688eb6373
setup
protected void setup(Context context) throws IOException, InterruptedException
{    super.setup(context);    Configuration conf = context.getConfiguration();    Path qJobPath = new Path(conf.get(PROP_QJOB_PATH));    /*       * actually this is kind of dangerous because this routine thinks we need       * to create file name for our current job and this will use -m- so it's       * just serendipity we are calling it from the mapper too as the QJob did.       */    Path qInputPath = new Path(qJobPath, FileOutputFormat.getUniqueFile(context, QJob.OUTPUT_QHAT, ""));    blockNum = context.getTaskAttemptID().getTaskID().getId();    SequenceFileValueIterator<DenseBlockWritable> qhatInput = new SequenceFileValueIterator<>(qInputPath, true, conf);    closeables.addFirst(qhatInput);    /*       * read all r files _in order of task ids_, i.e. partitions (aka group       * nums).       *       * Note: if broadcast option is used, this comes from distributed cache       * files rather than hdfs path.       */    SequenceFileDirValueIterator<VectorWritable> rhatInput;    boolean distributedRHat = conf.get(PROP_RHAT_BROADCAST) != null;    if (distributedRHat) {        Path[] rFiles = HadoopUtil.getCachedFiles(conf);        Validate.notNull(rFiles, "no RHat files in distributed cache job definition");                Configuration lconf = new Configuration();        lconf.set("fs.default.name", "file:///");        rhatInput = new SequenceFileDirValueIterator<>(rFiles, SSVDHelper.PARTITION_COMPARATOR, true, lconf);    } else {        Path rPath = new Path(qJobPath, QJob.OUTPUT_RHAT + "-*");        rhatInput = new SequenceFileDirValueIterator<>(rPath, PathType.GLOB, null, SSVDHelper.PARTITION_COMPARATOR, true, conf);    }    Validate.isTrue(rhatInput.hasNext(), "Empty R-hat input!");    closeables.addFirst(rhatInput);    outputs = new MultipleOutputs(new JobConf(conf));    closeables.addFirst(new IOUtils.MultipleOutputsCloseableAdapter(outputs));    qr = new QRLastStep(qhatInput, rhatInput, blockNum);    closeables.addFirst(qr);    /*       * it's so happens that current QRLastStep's implementation preloads R       * sequence into memory in the constructor so it's ok to close rhat input       * now.       */    if (!rhatInput.hasNext()) {        closeables.remove(rhatInput);        rhatInput.close();    }    OutputCollector<LongWritable, SparseRowBlockWritable> btBlockCollector = new OutputCollector<LongWritable, SparseRowBlockWritable>() {        @Override        public void collect(LongWritable blockKey, SparseRowBlockWritable block) throws IOException {            try {                mapContext.write(blockKey, block);            } catch (InterruptedException exc) {                throw new IOException("Interrupted.", exc);            }        }    };    btCollector = new SparseRowBlockAccumulator(conf.getInt(PROP_OUTER_PROD_BLOCK_HEIGHT, -1), btBlockCollector);    closeables.addFirst(btCollector);        computeSq = conf.get(PROP_XI_PATH) != null;        nv = conf.getBoolean(PROP_NV, false);}
71b5d50b932c754b8c09b7d5577117e10742f58d738d1367e45324b6adb0a3ee
collect
public void collect(LongWritable blockKey, SparseRowBlockWritable block) throws IOException
{    try {        mapContext.write(blockKey, block);    } catch (InterruptedException exc) {        throw new IOException("Interrupted.", exc);    }}
2e250b70eb1261a97967b8b894cf822fc9e7eb36891dbb77c6d16369f85de12a
cleanup
protected void cleanup(Context context) throws IOException, InterruptedException
{    try {        if (sqAccum != null) {            /*           * hack: we will output sq partial sums with index -1 for summation.           */            SparseRowBlockWritable sbrw = new SparseRowBlockWritable(1);            sbrw.plusRow(0, sqAccum);            LongWritable lw = new LongWritable(-1);            context.write(lw, sbrw);        }    } finally {        IOUtils.close(closeables);    }}
cee0e4ab4385eda192f7004b83b5c219ea4ebd842d45dd2c8d4d09de08f51152
outputQRow
private void outputQRow(Writable key, Vector qRow, Vector aRow) throws IOException
{    if (nv && (aRow instanceof NamedVector)) {        qRowValue.set(new NamedVector(qRow, ((NamedVector) aRow).getName()));    } else {        qRowValue.set(qRow);    }    outputs.getCollector(OUTPUT_Q, null).collect(key, qRowValue);}
6b7dd49be7482fc8ee0fbe8bd0f24522f2a718c8c816a3d7b048fb4688eb6373
setup
protected void setup(Context context) throws IOException, InterruptedException
{    blockHeight = context.getConfiguration().getInt(PROP_OUTER_PROD_BLOCK_HEIGHT, -1);}
2999273ade4931f26cc7bbc3021b2f1febedb96f6b07188fbcacd674e287f9f1
reduce
protected void reduce(Writable key, Iterable<SparseRowBlockWritable> values, Context context) throws IOException, InterruptedException
{    for (SparseRowBlockWritable bw : values) {        accum.plusBlock(bw);    }    context.write(key, accum);    accum.clear();}
2e250b70eb1261a97967b8b894cf822fc9e7eb36891dbb77c6d16369f85de12a
cleanup
protected void cleanup(Context context) throws IOException, InterruptedException
{    IOUtils.close(closeables);}
6b7dd49be7482fc8ee0fbe8bd0f24522f2a718c8c816a3d7b048fb4688eb6373
setup
protected void setup(Context context) throws IOException, InterruptedException
{    Configuration conf = context.getConfiguration();    blockHeight = conf.getInt(PROP_OUTER_PROD_BLOCK_HEIGHT, -1);    outputBBt = conf.getBoolean(PROP_OUPTUT_BBT_PRODUCTS, false);    if (outputBBt) {        int k = conf.getInt(QJob.PROP_K, -1);        int p = conf.getInt(QJob.PROP_P, -1);        Validate.isTrue(k > 0, "invalid k parameter");        Validate.isTrue(p >= 0, "invalid p parameter");        mBBt = new UpperTriangular(k + p);    }    String xiPathStr = conf.get(PROP_XI_PATH);    if (xiPathStr != null) {        xi = SSVDHelper.loadAndSumUpVectors(new Path(xiPathStr), conf);        if (xi == null) {            throw new IOException(String.format("unable to load mean path xi from %s.", xiPathStr));        }    }    if (outputBBt || xi != null) {        outputs = new MultipleOutputs(new JobConf(conf));        closeables.addFirst(new IOUtils.MultipleOutputsCloseableAdapter(outputs));    }}
290978c2baf5a9eafdd51868681ba62a2b23f37c7ce380aabeb465533967fde6
reduce
protected void reduce(LongWritable key, Iterable<SparseRowBlockWritable> values, Context context) throws IOException, InterruptedException
{    accum.clear();    for (SparseRowBlockWritable bw : values) {        accum.plusBlock(bw);    }        if (key.get() == -1L) {        Vector sq = accum.getRows()[0];        @SuppressWarnings("unchecked")        OutputCollector<IntWritable, VectorWritable> sqOut = outputs.getCollector(OUTPUT_SQ, null);        sqOut.collect(new IntWritable(0), new VectorWritable(sq));        return;    }    for (int k = 0; k < accum.getNumRows(); k++) {        Vector btRow = accum.getRows()[k];        btKey.set((int) (key.get() * blockHeight + accum.getRowIndices()[k]));        btValue.set(btRow);        context.write(btKey, btValue);        if (outputBBt) {            int kp = mBBt.numRows();                        for (int i = 0; i < kp; i++) {                double vi = btRow.get(i);                if (vi != 0.0) {                    for (int j = i; j < kp; j++) {                        double vj = btRow.get(j);                        if (vj != 0.0) {                            mBBt.setQuick(i, j, mBBt.getQuick(i, j) + vi * vj);                        }                    }                }            }        }                if (xi != null) {                        int btIndex = btKey.get();            double xii = xi.size() > btIndex ? xi.getQuick(btIndex) : 0.0;                        pmult.setMultiplicator(xii);            if (sbAccum == null) {                sbAccum = new DenseVector(btRow.size());            }            sbAccum.assign(btRow, pmult);        }    }}
2e250b70eb1261a97967b8b894cf822fc9e7eb36891dbb77c6d16369f85de12a
cleanup
protected void cleanup(Context context) throws IOException, InterruptedException
{        try {        if (outputBBt) {            @SuppressWarnings("unchecked")            OutputCollector<Writable, Writable> collector = outputs.getCollector(OUTPUT_BBT, null);            collector.collect(new IntWritable(), new VectorWritable(new DenseVector(mBBt.getData())));        }                if (sbAccum != null) {            @SuppressWarnings("unchecked")            OutputCollector<IntWritable, VectorWritable> collector = outputs.getCollector(OUTPUT_SB, null);            collector.collect(new IntWritable(), new VectorWritable(sbAccum));        }    } finally {        IOUtils.close(closeables);    }}
7e8cb0fe7eef0eb1852188655b337dd7ee1f3785a3727ea472ec2100bee4efa2
run
public static void run(Configuration conf, Path[] inputPathA, Path inputPathQJob, Path xiPath, Path outputPath, int minSplitSize, int k, int p, int btBlockHeight, int numReduceTasks, boolean broadcast, Class<? extends Writable> labelClass, boolean outputBBtProducts) throws ClassNotFoundException, InterruptedException, IOException
{    JobConf oldApiJob = new JobConf(conf);    MultipleOutputs.addNamedOutput(oldApiJob, OUTPUT_Q, org.apache.hadoop.mapred.SequenceFileOutputFormat.class, labelClass, VectorWritable.class);    if (outputBBtProducts) {        MultipleOutputs.addNamedOutput(oldApiJob, OUTPUT_BBT, org.apache.hadoop.mapred.SequenceFileOutputFormat.class, IntWritable.class, VectorWritable.class);        /*       * MAHOUT-1067: if we are asked to output BBT products then named vector       * names should be propagated to Q too so that UJob could pick them up       * from there.       */        oldApiJob.setBoolean(PROP_NV, true);    }    if (xiPath != null) {                MultipleOutputs.addNamedOutput(oldApiJob, OUTPUT_SQ, org.apache.hadoop.mapred.SequenceFileOutputFormat.class, IntWritable.class, VectorWritable.class);        MultipleOutputs.addNamedOutput(oldApiJob, OUTPUT_SB, org.apache.hadoop.mapred.SequenceFileOutputFormat.class, IntWritable.class, VectorWritable.class);    }    /*     * HACK: we use old api multiple outputs since they are not available in the     * new api of either 0.20.2 or 0.20.203 but wrap it into a new api job so we     * can use new api interfaces.     */    Job job = new Job(oldApiJob);    job.setJobName("Bt-job");    job.setJarByClass(BtJob.class);    job.setInputFormatClass(SequenceFileInputFormat.class);    job.setOutputFormatClass(SequenceFileOutputFormat.class);    FileInputFormat.setInputPaths(job, inputPathA);    if (minSplitSize > 0) {        FileInputFormat.setMinInputSplitSize(job, minSplitSize);    }    FileOutputFormat.setOutputPath(job, outputPath);        job.getConfiguration().set("mapreduce.output.basename", OUTPUT_BT);    FileOutputFormat.setOutputCompressorClass(job, DefaultCodec.class);    SequenceFileOutputFormat.setOutputCompressionType(job, CompressionType.BLOCK);    job.setMapOutputKeyClass(LongWritable.class);    job.setMapOutputValueClass(SparseRowBlockWritable.class);    job.setOutputKeyClass(IntWritable.class);    job.setOutputValueClass(VectorWritable.class);    job.setMapperClass(BtMapper.class);    job.setCombinerClass(OuterProductCombiner.class);    job.setReducerClass(OuterProductReducer.class);    job.getConfiguration().setInt(QJob.PROP_K, k);    job.getConfiguration().setInt(QJob.PROP_P, p);    job.getConfiguration().set(PROP_QJOB_PATH, inputPathQJob.toString());    job.getConfiguration().setBoolean(PROP_OUPTUT_BBT_PRODUCTS, outputBBtProducts);    job.getConfiguration().setInt(PROP_OUTER_PROD_BLOCK_HEIGHT, btBlockHeight);    job.setNumReduceTasks(numReduceTasks);    /*     * PCA-related options, MAHOUT-817     */    if (xiPath != null) {        job.getConfiguration().set(PROP_XI_PATH, xiPath.toString());    }    if (broadcast) {        job.getConfiguration().set(PROP_RHAT_BROADCAST, "y");        FileSystem fs = FileSystem.get(inputPathQJob.toUri(), conf);        FileStatus[] fstats = fs.globStatus(new Path(inputPathQJob, QJob.OUTPUT_RHAT + "-*"));        if (fstats != null) {            for (FileStatus fstat : fstats) {                /*           * new api is not enabled yet in our dependencies at this time, still           * using deprecated one           */                DistributedCache.addCacheFile(fstat.getPath().toUri(), job.getConfiguration());            }        }    }    job.submit();    job.waitForCompletion(false);    if (!job.isSuccessful()) {        throw new IOException("Bt job unsuccessful.");    }}
d0776091ebc41d97c356ae217f60ed6e9ca8bfb7563e84b3a6d5c77c741a16d4
setBlock
public void setBlock(double[][] block)
{    this.block = block;}
91d082791d2e58ce2f2f1a6505d73f453fadc3acae98f903836446566aa489c8
getBlock
public double[][] getBlock()
{    return block;}
5478cc5683f6dfd4515c383752d7c803555efc63d03fd84a03ba8dcd17eb4324
readFields
public void readFields(DataInput in) throws IOException
{    int m = in.readInt();    int n = in.readInt();    if (block == null) {        block = new double[m][0];    } else if (block.length != m) {        block = Arrays.copyOf(block, m);    }    for (int i = 0; i < m; i++) {        if (block[i] == null || block[i].length != n) {            block[i] = new double[n];        }        for (int j = 0; j < n; j++) {            block[i][j] = in.readDouble();        }    }}
a894510dd4db439ff8e17ae1059489dc3abc97178e5932ceed0c70c3af165401
write
public void write(DataOutput out) throws IOException
{    int m = block.length;    int n = block.length == 0 ? 0 : block[0].length;    out.writeInt(m);    out.writeInt(n);    for (double[] aBlock : block) {        for (int j = 0; j < n; j++) {            out.writeDouble(aBlock[j]);        }    }}
1a7b4a2d3001072b037d625fbd603f24082fad4d995e7354ef48188cd1906c22
getQuick
public double getQuick(int row, int column)
{    long hash = murmur64((long) row << Integer.SIZE | column, 8, seed);    return hash / UNIFORM_DIVISOR;}
0317f7038829a7fe374bedbb0a2234187370d080e4651cd650913d9158637606
computeYRow
public void computeYRow(Vector aRow, double[] yRow)
{        Arrays.fill(yRow, 0.0);    if (aRow.isDense()) {        int n = aRow.size();        for (int j = 0; j < n; j++) {            accumDots(j, aRow.getQuick(j), yRow);        }    } else {        for (Element el : aRow.nonZeroes()) {            accumDots(el.index(), el.get(), yRow);        }    }}
e45a5cef133f08d41cc1854f77710cc4666b3eb20bc76aa218b251b922b910b1
computeYRow
public void computeYRow(Vector aRow, Vector yRowOut)
{    yRowOut.assign(0.0);    if (aRow.isDense()) {        int n = aRow.size();        for (int j = 0; j < n; j++) {            accumDots(j, aRow.getQuick(j), yRowOut);        }    } else {        for (Element el : aRow.nonZeroes()) {            accumDots(el.index(), el.get(), yRowOut);        }    }}
99c6fce193bc3e8d47c1cdf5c495fbf36ab50ce8aa6f4336281421eba300bb4e
mutlithreadedTRightMultiply
public Vector mutlithreadedTRightMultiply(final Vector v)
{    int nThreads = Runtime.getRuntime().availableProcessors();    ExecutorService es = new ThreadPoolExecutor(nThreads, nThreads, 1, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(kp));    try {        List<Future<Double>> dotFutures = Lists.newArrayListWithCapacity(kp);        for (int i = 0; i < kp; i++) {            final int index = i;            Future<Double> dotFuture = es.submit(new Callable<Double>() {                @Override                public Double call() throws Exception {                    double result = 0.0;                    if (v.isDense()) {                        for (int k = 0; k < v.size(); k++) {                                                        result += getQuick(k, index) * v.getQuick(k);                        }                    } else {                        for (Element el : v.nonZeroes()) {                            int k = el.index();                            result += getQuick(k, index) * el.get();                        }                    }                    return result;                }            });            dotFutures.add(dotFuture);        }        try {            Vector res = new DenseVector(kp);            for (int i = 0; i < kp; i++) {                res.setQuick(i, dotFutures.get(i).get());            }            return res;        } catch (InterruptedException exc) {            throw new IllegalStateException("Interrupted", exc);        } catch (ExecutionException exc) {            if (exc.getCause() instanceof RuntimeException) {                throw (RuntimeException) exc.getCause();            } else {                throw new IllegalStateException(exc.getCause());            }        }    } finally {        es.shutdown();    }}
bd09e7e0452e16923042d8903f3c457335ddd6310a6c72b73455f1658c3bb0a5
call
public Double call() throws Exception
{    double result = 0.0;    if (v.isDense()) {        for (int k = 0; k < v.size(); k++) {                        result += getQuick(k, index) * v.getQuick(k);        }    } else {        for (Element el : v.nonZeroes()) {            int k = el.index();            result += getQuick(k, index) * el.get();        }    }    return result;}
21e87598ec2a963c63135bdc04645b4f79427c0204d1bf4e1c9d59165d8df208
accumDots
protected void accumDots(int aIndex, double aElement, double[] yRow)
{    for (int i = 0; i < kp; i++) {        yRow[i] += getQuick(aIndex, i) * aElement;    }}
0e3e282d6eab58fa7fd0cba0d77bbabc95b2d97e26917eca9b591b1c48458829
accumDots
protected void accumDots(int aIndex, double aElement, Vector yRow)
{    for (int i = 0; i < kp; i++) {        yRow.setQuick(i, yRow.getQuick(i) + getQuick(aIndex, i) * aElement);    }}
cf36b2fb1804ef8126d98a0a7dfa8803468582d31e428a17ba22aa6dec19250e
murmur64
public static long murmur64(long val, int len, long seed)
{        long m = 0xc6a4a7935bd1e995L;    long h = seed ^ len * m;    long k = val;    k *= m;    int r = 47;    k ^= k >>> r;    k *= m;    h ^= k;    h *= m;    h ^= h >>> r;    h *= m;    h ^= h >>> r;    return h;}
7d1d26ca072bb4b1e15a2d5eeb2a9ddb2c88350da8fc3868ae7efa5f5fffe89d
murmur64
public static long murmur64(byte[] val, int offset, int len, long seed)
{    long m = 0xc6a4a7935bd1e995L;    int r = 47;    long h = seed ^ (len * m);    int lt = len >>> 3;    for (int i = 0; i < lt; i++, offset += 8) {        long k = 0;        for (int j = 0; j < 8; j++) {            k <<= 8;            k |= val[offset + j] & 0xff;        }        k *= m;        k ^= k >>> r;        k *= m;        h ^= k;        h *= m;    }    if (offset < len) {        long k = 0;        while (offset < len) {            k <<= 8;            k |= val[offset] & 0xff;            offset++;        }        h ^= k;        h *= m;    }    h ^= h >>> r;    h *= m;    h ^= h >>> r;    return h;}
6b7dd49be7482fc8ee0fbe8bd0f24522f2a718c8c816a3d7b048fb4688eb6373
setup
protected void setup(Context context) throws IOException, InterruptedException
{    Configuration conf = context.getConfiguration();    int k = Integer.parseInt(conf.get(PROP_K));    int p = Integer.parseInt(conf.get(PROP_P));    kp = k + p;    long omegaSeed = Long.parseLong(conf.get(PROP_OMEGA_SEED));    omega = new Omega(omegaSeed, k + p);    String sbPathStr = conf.get(PROP_SB_PATH);    if (sbPathStr != null) {        sb = SSVDHelper.loadAndSumUpVectors(new Path(sbPathStr), conf);        if (sb == null)            throw new IOException(String.format("Unable to load s_omega from path %s.", sbPathStr));    }    outputs = new MultipleOutputs(new JobConf(conf));    closeables.addFirst(new Closeable() {        @Override        public void close() throws IOException {            outputs.close();        }    });    qHatKey = new SplitPartitionedWritable(context);    rHatKey = new SplitPartitionedWritable(context);    OutputCollector<Writable, DenseBlockWritable> qhatCollector = new OutputCollector<Writable, DenseBlockWritable>() {        @Override        @SuppressWarnings("unchecked")        public void collect(Writable nil, DenseBlockWritable dbw) throws IOException {            outputs.getCollector(OUTPUT_QHAT, null).collect(qHatKey, dbw);            qHatKey.incrementItemOrdinal();        }    };    OutputCollector<Writable, VectorWritable> rhatCollector = new OutputCollector<Writable, VectorWritable>() {        @Override        @SuppressWarnings("unchecked")        public void collect(Writable nil, VectorWritable rhat) throws IOException {            outputs.getCollector(OUTPUT_RHAT, null).collect(rHatKey, rhat);            rHatKey.incrementItemOrdinal();        }    };    qr = new QRFirstStep(conf, qhatCollector, rhatCollector);        closeables.addFirst(qr);    yRow = new DenseVector(kp);}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    outputs.close();}
e1cf96c12b432b4db3a73bc17160047c03a5c384ac28adbdbb0e87dea0f48a3e
collect
public void collect(Writable nil, DenseBlockWritable dbw) throws IOException
{    outputs.getCollector(OUTPUT_QHAT, null).collect(qHatKey, dbw);    qHatKey.incrementItemOrdinal();}
d0e2102b3c5acab04f60b9f9bb6bf2fa12b502a9e0b5a7f7e5ef7074930125f7
collect
public void collect(Writable nil, VectorWritable rhat) throws IOException
{    outputs.getCollector(OUTPUT_RHAT, null).collect(rHatKey, rhat);    rHatKey.incrementItemOrdinal();}
575b0c06b39ecc623839b56d197693e61a03ae1e8e73b443d344b10d41445dec
map
protected void map(Writable key, VectorWritable value, Context context) throws IOException, InterruptedException
{    omega.computeYRow(value.get(), yRow);    if (sb != null) {        yRow.assign(sb, Functions.MINUS);    }    qr.collect(key, yRow);}
2e250b70eb1261a97967b8b894cf822fc9e7eb36891dbb77c6d16369f85de12a
cleanup
protected void cleanup(Context context) throws IOException, InterruptedException
{    IOUtils.close(closeables);}
b60c49872a446c92df54f862e592b4f3cabbbbf0be065700adb01ffd531ced18
run
public static void run(Configuration conf, Path[] inputPaths, Path sbPath, Path outputPath, int aBlockRows, int minSplitSize, int k, int p, long seed, int numReduceTasks) throws ClassNotFoundException, InterruptedException, IOException
{    JobConf oldApiJob = new JobConf(conf);    MultipleOutputs.addNamedOutput(oldApiJob, OUTPUT_QHAT, org.apache.hadoop.mapred.SequenceFileOutputFormat.class, SplitPartitionedWritable.class, DenseBlockWritable.class);    MultipleOutputs.addNamedOutput(oldApiJob, OUTPUT_RHAT, org.apache.hadoop.mapred.SequenceFileOutputFormat.class, SplitPartitionedWritable.class, VectorWritable.class);    Job job = new Job(oldApiJob);    job.setJobName("Q-job");    job.setJarByClass(QJob.class);    job.setInputFormatClass(SequenceFileInputFormat.class);    FileInputFormat.setInputPaths(job, inputPaths);    if (minSplitSize > 0) {        FileInputFormat.setMinInputSplitSize(job, minSplitSize);    }    FileOutputFormat.setOutputPath(job, outputPath);    FileOutputFormat.setCompressOutput(job, true);    FileOutputFormat.setOutputCompressorClass(job, DefaultCodec.class);    SequenceFileOutputFormat.setOutputCompressionType(job, CompressionType.BLOCK);    job.setMapOutputKeyClass(SplitPartitionedWritable.class);    job.setMapOutputValueClass(VectorWritable.class);    job.setOutputKeyClass(SplitPartitionedWritable.class);    job.setOutputValueClass(VectorWritable.class);    job.setMapperClass(QMapper.class);    job.getConfiguration().setInt(PROP_AROWBLOCK_SIZE, aBlockRows);    job.getConfiguration().setLong(PROP_OMEGA_SEED, seed);    job.getConfiguration().setInt(PROP_K, k);    job.getConfiguration().setInt(PROP_P, p);    if (sbPath != null) {        job.getConfiguration().set(PROP_SB_PATH, sbPath.toString());    }    /*     * number of reduce tasks doesn't matter. we don't actually send anything to     * reducers.     */    job.setNumReduceTasks(0);    job.submit();    job.waitForCompletion(false);    if (!job.isSuccessful()) {        throw new IOException("Q job unsuccessful.");    }}
97d2d353f08aa5a1da8b18b0800b6e778df65f48d34726e5f17800df7e0d88e2
reset
public void reset()
{    cnt = 0;}
e27132ef552e95207eb34ebe13e1ade7a05d787dd438afbc5dc9e42120f601e7
solve
public void solve(Matrix a)
{    assert a.rowSize() == m;    assert a.columnSize() == n;    double[] aRow = new double[n];    for (int i = 0; i < m; i++) {        Vector aRowV = a.viewRow(i);        for (int j = 0; j < n; j++) {            aRow[j] = aRowV.getQuick(j);        }        appendRow(aRow);    }}
f9250f7e93eb3e332b3a283988590da4bb96eedcb77601ca789df57a5a3031fe
isFull
public boolean isFull()
{    return cnt == m;}
7667e2b19cfd5afb187f7893fb5496bb97b5b59b351916f55a7ca8f7fbe80b10
getM
public int getM()
{    return m;}
0540f186139eee60a0907084d9f1a814969075e2787f6596c30f2d6546736a04
getN
public int getN()
{    return n;}
5f959e9f31dc80ef3a9149d7468b9e35992d48b9f895b7a800d67e0899cc010c
getCnt
public int getCnt()
{    return cnt;}
98afff00eae9d9066986d8d28148240e457b49fd04cb365ae57ba8498b449275
adjust
public void adjust(int newM)
{    if (newM == m) {                return;    }    if (newM < n) {        throw new IllegalArgumentException("new m can't be less than n");    }    if (newM < cnt) {        throw new IllegalArgumentException("new m can't be less than rows accumulated");    }    vQtRow = new double[newM];        if (newM > m) {                for (int i = 0; i < n; i++) {            mQt[i] = Arrays.copyOf(mQt[i], newM);            System.arraycopy(mQt[i], 0, mQt[i], newM - m, m);            Arrays.fill(mQt[i], 0, newM - m, 0);        }    } else {                for (int i = 0; i < n; i++) {            mQt[i] = Arrays.copyOfRange(mQt[i], m - newM, m);        }    }    m = newM;}
5379ee7f91da9ecf577dbb527621b8fb7bf2c31fe36c5b6fcea1f3acbdf265b3
trim
public void trim()
{    adjust(cnt);}
75f7e4b386d520b6bbebfdeed74120116e77b0e4eff8bda7d77cbc15b4af0cf0
appendRow
public void appendRow(double[] aRow)
{    if (cnt >= m) {        throw new IllegalStateException("thin QR solver fed more rows than initialized for");    }    try {        /*       * moving pointers around is inefficient but for the sanity's sake i am       * keeping it this way so i don't have to guess how R-tilde index maps to       * actual block index       */        Arrays.fill(vQtRow, 0);        vQtRow[m - cnt - 1] = 1;        int height = cnt > n ? n : cnt;        System.arraycopy(aRow, 0, vARow, 0, n);        if (height > 0) {            givens(vARow[0], getRRow(0)[0], cs);            applyGivensInPlace(cs[0], cs[1], vARow, getRRow(0), 0, n);            applyGivensInPlace(cs[0], cs[1], vQtRow, getQtRow(0), 0, m);        }        for (int i = 1; i < height; i++) {            givens(getRRow(i - 1)[i], getRRow(i)[i], cs);            applyGivensInPlace(cs[0], cs[1], getRRow(i - 1), getRRow(i), i, n - i);            applyGivensInPlace(cs[0], cs[1], getQtRow(i - 1), getQtRow(i), 0, m);        }        /*       * push qt and r-tilde 1 row down       *        * just swap the references to reduce GC churning       */        pushQtDown();        double[] swap = getQtRow(0);        setQtRow(0, vQtRow);        vQtRow = swap;        pushRDown();        swap = getRRow(0);        setRRow(0, vARow);        vARow = swap;    } finally {        cnt++;    }}
a374f085651fc171a221d926f5d475011733cf3716afcb4225a7570a1d38c607
getQtRow
private double[] getQtRow(int row)
{    return mQt[(row += qtStartRow) >= n ? row - n : row];}
7c8a9caf898bb4f28e1d085ad6d5251beb2dec39c4ab23a36b778fe6835dff83
setQtRow
private void setQtRow(int row, double[] qtRow)
{    mQt[(row += qtStartRow) >= n ? row - n : row] = qtRow;}
4c2e5b6b6462c603262071db1c58f4d9f0a591964c42064c9ccba7c83780881b
pushQtDown
private void pushQtDown()
{    qtStartRow = qtStartRow == 0 ? n - 1 : qtStartRow - 1;}
19ee5194c78579bb16cd79da7bacfaed43d81b0b8dc3a6f1b1c9e6fae5601bf3
getRRow
private double[] getRRow(int row)
{    row += rStartRow;    return mR[row >= n ? row - n : row];}
01ce96b20578c52cb60a8e4acb9e587874d49dbeb3c0485cb0af51b2a88f934d
setRRow
private void setRRow(int row, double[] rrow)
{    mR[(row += rStartRow) >= n ? row - n : row] = rrow;}
684b008e8518fde07cd7e69adea387976961a9350537a731c2fbc1abac8b763f
pushRDown
private void pushRDown()
{    rStartRow = rStartRow == 0 ? n - 1 : rStartRow - 1;}
20ecae6ab66b66c8f8fad3bdfa7f20433bb8b010bbf30a26e5768daf6dcf0cd4
getRTilde
public UpperTriangular getRTilde()
{    UpperTriangular packedR = new UpperTriangular(n);    for (int i = 0; i < n; i++) {        packedR.assignNonZeroElementsInRow(i, getRRow(i));    }    return packedR;}
93c4c96b632d902c76e54e83f022a59c317449a31cd0717637202920b959ebac
getThinQtTilde
public double[][] getThinQtTilde()
{    if (qtStartRow != 0) {        /*       * rotate qt rows into place       *        * double[~500][], once per block, not a big deal.       */        double[][] qt = new double[n][];        System.arraycopy(mQt, qtStartRow, qt, 0, n - qtStartRow);        System.arraycopy(mQt, 0, qt, n - qtStartRow, qtStartRow);        return qt;    }    return mQt;}
8224b528cff12809581d2de7e145c8e346b881b7e3c9f468e0f319576e4315ae
applyGivensInPlace
public static void applyGivensInPlace(double c, double s, double[] row1, double[] row2, int offset, int len)
{    int n = offset + len;    for (int j = offset; j < n; j++) {        double tau1 = row1[j];        double tau2 = row2[j];        row1[j] = c * tau1 - s * tau2;        row2[j] = s * tau1 + c * tau2;    }}
45319e4fca87ec20b2285b094466232ed700ac07d34f1b4f2079c645167ee407
applyGivensInPlace
public static void applyGivensInPlace(double c, double s, Vector row1, Vector row2, int offset, int len)
{    int n = offset + len;    for (int j = offset; j < n; j++) {        double tau1 = row1.getQuick(j);        double tau2 = row2.getQuick(j);        row1.setQuick(j, c * tau1 - s * tau2);        row2.setQuick(j, s * tau1 + c * tau2);    }}
71e4eb62fc679975365e9dc422c1a2b3765b9ac5047eb020e9338f156b77d23f
applyGivensInPlace
public static void applyGivensInPlace(double c, double s, int i, int k, Matrix mx)
{    int n = mx.columnSize();    for (int j = 0; j < n; j++) {        double tau1 = mx.get(i, j);        double tau2 = mx.get(k, j);        mx.set(i, j, c * tau1 - s * tau2);        mx.set(k, j, s * tau1 + c * tau2);    }}
36b3e89122846cf575dd0442908e0263d097cb0b47cf9f5546eeb79b1d87bf95
fromRho
public static void fromRho(double rho, double[] csOut)
{    if (rho == 1) {        csOut[0] = 0;        csOut[1] = 1;        return;    }    if (Math.abs(rho) < 1) {        csOut[1] = 2 * rho;        csOut[0] = Math.sqrt(1 - csOut[1] * csOut[1]);        return;    }    csOut[0] = 2 / rho;    csOut[1] = Math.sqrt(1 - csOut[0] * csOut[0]);}
d8f41bf61f0f962719cbcd47cadd791445905f3383e54c76587ffa6c4e7aeea8
givens
public static void givens(double a, double b, double[] csOut)
{    if (b == 0) {        csOut[0] = 1;        csOut[1] = 0;        return;    }    if (Math.abs(b) > Math.abs(a)) {        double tau = -a / b;        csOut[1] = 1 / Math.sqrt(1 + tau * tau);        csOut[0] = csOut[1] * tau;    } else {        double tau = -b / a;        csOut[0] = 1 / Math.sqrt(1 + tau * tau);        csOut[1] = csOut[0] * tau;    }}
cf3f26d1cdde06869cdce1810e0af972b8c068406d285fd69102a52c9c1cadc2
toRho
public static double toRho(double c, double s)
{    if (c == 0) {        return 1;    }    if (Math.abs(s) < Math.abs(c)) {        return Math.signum(c) * s / 2;    } else {        return Math.signum(s) * 2 / c;    }}
586d836fe738995376c962c0e132ad6d41cc7b0938bca54929df86fd588e68fb
mergeR
public static void mergeR(UpperTriangular r1, UpperTriangular r2)
{    TriangularRowView r1Row = new TriangularRowView(r1);    TriangularRowView r2Row = new TriangularRowView(r2);    int kp = r1Row.size();    assert kp == r2Row.size();    double[] cs = new double[2];    for (int v = 0; v < kp; v++) {        for (int u = v; u < kp; u++) {            givens(r1Row.setViewedRow(u).get(u), r2Row.setViewedRow(u - v).get(u), cs);            applyGivensInPlace(cs[0], cs[1], r1Row, r2Row, u, kp - u);        }    }}
fb5b48342adc44e306bdb690a525812d779b8bcb9515788537c247d468ecadef
mergeR
public static void mergeR(double[][] r1, double[][] r2)
{    int kp = r1[0].length;    assert kp == r2[0].length;    double[] cs = new double[2];    for (int v = 0; v < kp; v++) {        for (int u = v; u < kp; u++) {            givens(r1[u][u], r2[u - v][u], cs);            applyGivensInPlace(cs[0], cs[1], r1[u], r2[u - v], u, kp - u);        }    }}
4c2f449ef336995183c58390c6666f3e2640edb6f2ddc2eef808e21631828a5b
mergeRonQ
public static void mergeRonQ(UpperTriangular r1, UpperTriangular r2, double[][] qt1, double[][] qt2)
{    TriangularRowView r1Row = new TriangularRowView(r1);    TriangularRowView r2Row = new TriangularRowView(r2);    int kp = r1Row.size();    assert kp == r2Row.size();    assert kp == qt1.length;    assert kp == qt2.length;    int r = qt1[0].length;    assert qt2[0].length == r;    double[] cs = new double[2];    for (int v = 0; v < kp; v++) {        for (int u = v; u < kp; u++) {            givens(r1Row.setViewedRow(u).get(u), r2Row.setViewedRow(u - v).get(u), cs);            applyGivensInPlace(cs[0], cs[1], r1Row, r2Row, u, kp - u);            applyGivensInPlace(cs[0], cs[1], qt1[u], qt2[u - v], 0, r);        }    }}
ce8f6ef0f09ac7c338c03369183967ba71bbb8c68d618764ac2d4105c1f99165
mergeRonQ
public static void mergeRonQ(double[][] r1, double[][] r2, double[][] qt1, double[][] qt2)
{    int kp = r1[0].length;    assert kp == r2[0].length;    assert kp == qt1.length;    assert kp == qt2.length;    int r = qt1[0].length;    assert qt2[0].length == r;    double[] cs = new double[2];    /*     * pairwise givens(a,b) so that a come off main diagonal in r1 and bs come     * off u-th upper subdiagonal in r2.     */    for (int v = 0; v < kp; v++) {        for (int u = v; u < kp; u++) {            givens(r1[u][u], r2[u - v][u], cs);            applyGivensInPlace(cs[0], cs[1], r1[u], r2[u - v], u, kp - u);            applyGivensInPlace(cs[0], cs[1], qt1[u], qt2[u - v], 0, r);        }    }}
2d86813e1b6575d3f111ce9fcd7de06846b5899006a45e506458dd968ec8694e
mergeQrUp
public static double[][] mergeQrUp(double[][] qt1, double[][] r1, double[][] r2)
{    int kp = qt1.length;    int r = qt1[0].length;    double[][] qTilde = new double[kp][];    for (int i = 0; i < kp; i++) {        qTilde[i] = new double[r];    }    mergeRonQ(r1, r2, qt1, qTilde);    return qt1;}
6da8a2e536f89ba164633736875cc037a5be94a63a3a60d123366f63a7ae45a3
mergeQrUp
public static double[][] mergeQrUp(double[][] qt1, UpperTriangular r1, UpperTriangular r2)
{    int kp = qt1.length;    int r = qt1[0].length;    double[][] qTilde = new double[kp][];    for (int i = 0; i < kp; i++) {        qTilde[i] = new double[r];    }    mergeRonQ(r1, r2, qt1, qTilde);    return qt1;}
28e24095e784ac44438eb187e0d09ea6027f7dcbc62a1724c8e5841fdce34d5d
mergeQrDown
public static double[][] mergeQrDown(double[][] r1, double[][] qt2, double[][] r2)
{    int kp = qt2.length;    int r = qt2[0].length;    double[][] qTilde = new double[kp][];    for (int i = 0; i < kp; i++) {        qTilde[i] = new double[r];    }    mergeRonQ(r1, r2, qTilde, qt2);    return qTilde;}
ddf9d352dab069e0bf39d0ae25760f3bada07401f295c483bf6f05cc1dc41948
mergeQrDown
public static double[][] mergeQrDown(UpperTriangular r1, double[][] qt2, UpperTriangular r2)
{    int kp = qt2.length;    int r = qt2[0].length;    double[][] qTilde = new double[kp][];    for (int i = 0; i < kp; i++) {        qTilde[i] = new double[r];    }    mergeRonQ(r1, r2, qTilde, qt2);    return qTilde;}
bc553f3eb8c33e4e963a7e78b8436448fd22e4dd036870c0c6857fd345aa3e46
computeQtHat
public static double[][] computeQtHat(double[][] qt, int i, Iterator<UpperTriangular> rIter)
{    UpperTriangular rTilde = rIter.next();    for (int j = 1; j < i; j++) {        mergeR(rTilde, rIter.next());    }    if (i > 0) {        qt = mergeQrDown(rTilde, qt, rIter.next());    }    while (rIter.hasNext()) {        qt = mergeQrUp(qt, rTilde, rIter.next());    }    return qt;}
81336a273440029c1a640cca951892173b3f72b068154045a46d7f23cdadafcd
isOrthonormal
public static boolean isOrthonormal(double[][] qt, boolean insufficientRank, double epsilon)
{    int n = qt.length;    int rank = 0;    for (int i = 0; i < n; i++) {        Vector ei = new DenseVector(qt[i], true);        double norm = ei.norm(2);        if (Math.abs(1.0 - norm) < epsilon) {            rank++;        } else if (Math.abs(norm) > epsilon) {                        return false;        }        for (int j = 0; j <= i; j++) {            Vector ej = new DenseVector(qt[j], true);            double dot = ei.dot(ej);            if (!(Math.abs((i == j && rank > j ? 1.0 : 0.0) - dot) < epsilon)) {                return false;            }        }    }    return insufficientRank ? rank < n : rank == n;}
165a7039f4be01e3c079a1dc34270ff7ff4163de39545bfeed484aa4e7ab9056
isOrthonormalBlocked
public static boolean isOrthonormalBlocked(Iterable<double[][]> qtHats, boolean insufficientRank, double epsilon)
{    int n = qtHats.iterator().next().length;    int rank = 0;    for (int i = 0; i < n; i++) {        List<Vector> ei = Lists.newArrayList();                for (double[][] qtHat : qtHats) {            ei.add(new DenseVector(qtHat[i], true));        }        double norm = 0;        for (Vector v : ei) {            norm += v.dot(v);        }        norm = Math.sqrt(norm);        if (Math.abs(1 - norm) < epsilon) {            rank++;        } else if (Math.abs(norm) > epsilon) {                        return false;        }        for (int j = 0; j <= i; j++) {            List<Vector> ej = Lists.newArrayList();            for (double[][] qtHat : qtHats) {                ej.add(new DenseVector(qtHat[j], true));            }                        double dot = 0;            for (int k = 0; k < ei.size(); k++) {                dot += ei.get(k).dot(ej.get(k));            }            if (!(Math.abs((i == j && rank > j ? 1 : 0) - dot) < epsilon)) {                return false;            }        }    }    return insufficientRank ? rank < n : rank == n;}
9225fa840e4a602062127ea87b249a12c671e0d7e33d6fe636b0118635d927a3
setViewedRow
 TriangularRowView setViewedRow(int row)
{    rowNum = row;    return this;}
383032e836ae8e377e669da8e774cd6f6410cb106bd66015b484c883dc1c467c
isDense
public boolean isDense()
{    return true;}
048fcadf359a37696af85547983c8e1a90a6c62d53a2f5c66ba6b94ae1c5b98c
isSequentialAccess
public boolean isSequentialAccess()
{    return false;}
ebaf88b6206d3b34b79e1287ba43a83a7321437a7f6da5136b43af17bd0a0476
iterator
public Iterator<Element> iterator()
{    throw new UnsupportedOperationException();}
0494c3c5bbf01f97ae3671ecd67c5586bc95bd0aa1907bd0e3ebdc94d70e1683
iterateNonZero
public Iterator<Element> iterateNonZero()
{    throw new UnsupportedOperationException();}
2263144cad9c9fdd2eecb03c9f0c31fc79e73b974408c87f743169e8bea1c8f3
getQuick
public double getQuick(int index)
{    return viewed.getQuick(rowNum, index);}
3f06e4bc1bde206fe6ac26b2e2c12970bc557eee7de0d8e8394b1f96568db34b
like
public Vector like()
{    throw new UnsupportedOperationException();}
de7fe3d006f2cc6fa563e7089bbae0e5300ec5b2f82e856c1118dd26a5798a5f
like
public Vector like(int cardinality)
{    throw new UnsupportedOperationException();}
d90a04e96781b1eebeec5aca2a7d384a466650ea31ec4abd55dff982b7d2e12d
setQuick
public void setQuick(int index, double value)
{    viewed.setQuick(rowNum, index, value);}
f6c83ebe319a78b7975eba92f536cfcf2e5e6786960fb07f54a0c99258711da5
getNumNondefaultElements
public int getNumNondefaultElements()
{    throw new UnsupportedOperationException();}
6b67fad6dd27aa2525cafe6cf3396d2225fbcdf57e5378ac7a3dee60e61f20e8
getLookupCost
public double getLookupCost()
{    return 1;}
c79b5203142f65c96c29c2652557bad0bda511dfe38011e3b2877dd681f7c9cf
getIteratorAdvanceCost
public double getIteratorAdvanceCost()
{    return 1;}
c5fbf138e094d3027905103c89bbab4aa48cd369c50dde054752fd31aa322767
isAddConstantTime
public boolean isAddConstantTime()
{    return true;}
37fb9fe439d885b1414cadbf317af0d473db53d1b4e62bbd04a4a2c490cb4e1b
matrixLike
public Matrix matrixLike(int rows, int columns)
{    throw new UnsupportedOperationException();}
0f2cea51f07acae4d2eb073f5151beaf6dba8920eaf21ed6212f67553909727d
mergeUpdates
public void mergeUpdates(OrderedIntDoubleMapping updates)
{    int[] indices = updates.getIndices();    double[] values = updates.getValues();    for (int i = 0; i < updates.getNumMappings(); ++i) {        viewed.setQuick(rowNum, indices[i], values[i]);    }}
ecbda5f7f7d05dfd429e3e32274e1c5c1e8c639046baeaee5b117daaef927a49
orthonormalizeColumns
public static void orthonormalizeColumns(Matrix mx)
{    int n = mx.numCols();    for (int c = 0; c < n; c++) {        Vector col = mx.viewColumn(c);        for (int c1 = 0; c1 < c; c1++) {            Vector viewC1 = mx.viewColumn(c1);            col.assign(col.minus(viewC1.times(viewC1.dot(col))));        }        final double norm2 = col.norm(2);        col.assign(new DoubleFunction() {            @Override            public double apply(double x) {                return x / norm2;            }        });    }}
289ca856ae087737aff3520959859058a3e642cf3f87b00a2d0d486b23b7b74a
apply
public double apply(double x)
{    return x / norm2;}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    cleanup();}
97178289e2983bec82b9a3e57ab6728992095921cfd566b7287197259ed70766
getKP
public int getKP()
{    return kp;}
cf0816c750cfb0edb8f6f805ae6a5f5c5ded5568a67d20de2e69a990fac0c825
flushSolver
private void flushSolver() throws IOException
{    UpperTriangular r = qSolver.getRTilde();    double[][] qt = qSolver.getThinQtTilde();    rSubseq.add(r);    value.setBlock(qt);    getTempQw().append(tempKey, value);    /*     * this probably should be a sparse row matrix, but compressor should get it     * for disk and in memory we want it dense anyway, sparse random     * implementations would be a mostly a memory management disaster consisting     * of rehashes and GC      */    value.setBlock(null);    qSolver.reset();}
51ea6d82942588bd6701b707fa4f38fe9fcc9255da550803f849634b9bd68a25
flushQBlocks
private void flushQBlocks() throws IOException
{    if (blockCnt == 1) {        /*       * only one block, no temp file, no second pass. should be the default       * mode for efficiency in most cases. Sure mapper should be able to load       * the entire split in memory -- and we don't require even that.       */        value.setBlock(qSolver.getThinQtTilde());        outputQHat(value);        outputR(new VectorWritable(new DenseVector(qSolver.getRTilde().getData(), true)));    } else {        secondPass();    }}
8e561db754879bab79c3e77eb9acfa0b58383be7495c31e6fd588ef65a8bd872
outputQHat
private void outputQHat(DenseBlockWritable value) throws IOException
{    qtHatOut.collect(NullWritable.get(), value);}
1c40f1bf03576818a070b7af7b236ef055ebf832bffa14b2b9eb00bfda52899a
outputR
private void outputR(VectorWritable value) throws IOException
{    rHatOut.collect(NullWritable.get(), value);}
ded29477085d760c44563f9756be84148e5e24cea9e5ff8ad9dbff77489bd479
secondPass
private void secondPass() throws IOException
{        qSolver = null;    FileSystem localFs = FileSystem.getLocal(jobConf);    SequenceFile.Reader tempQr = new SequenceFile.Reader(localFs, tempQPath, jobConf);    closeables.addFirst(tempQr);    int qCnt = 0;    while (tempQr.next(tempKey, value)) {        value.setBlock(GivensThinSolver.computeQtHat(value.getBlock(), qCnt, new CopyConstructorIterator<>(rSubseq.iterator())));        if (qCnt == 1) {            /*         * just merge r[0] <- r[1] so it doesn't have to repeat in subsequent         * computeQHat iterators         */            GivensThinSolver.mergeR(rSubseq.get(0), rSubseq.remove(1));        } else {            qCnt++;        }        outputQHat(value);    }    assert rSubseq.size() == 1;    outputR(new VectorWritable(new DenseVector(rSubseq.get(0).getData(), true)));}
fc31a3be139eecfb1f2153a0d35e5b9922735e916a74f7649c2efb9a2ccc6af9
map
protected void map(Vector incomingYRow) throws IOException
{    double[] yRow;    if (yLookahead.size() == kp) {        if (qSolver.isFull()) {            flushSolver();            blockCnt++;        }        yRow = yLookahead.remove(0);        qSolver.appendRow(yRow);    } else {        yRow = new double[kp];    }    if (incomingYRow.isDense()) {        for (int i = 0; i < kp; i++) {            yRow[i] = incomingYRow.get(i);        }    } else {        Arrays.fill(yRow, 0);        for (Element yEl : incomingYRow.nonZeroes()) {            yRow[yEl.index()] = yEl.get();        }    }    yLookahead.add(yRow);}
41afdfc42f84039e00f53230abe328563f3eb839c4fbee862ad85df599646b2d
setup
protected void setup()
{    int r = Integer.parseInt(jobConf.get(PROP_AROWBLOCK_SIZE));    int k = Integer.parseInt(jobConf.get(PROP_K));    int p = Integer.parseInt(jobConf.get(PROP_P));    kp = k + p;    yLookahead = Lists.newArrayListWithCapacity(kp);    qSolver = new GivensThinSolver(r, kp);    outputs = new MultipleOutputs(new JobConf(jobConf));    closeables.addFirst(new Closeable() {        @Override        public void close() throws IOException {            outputs.close();        }    });}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    outputs.close();}
74def269b26725f91e970c65d8d967c551e0a6985c21b9617868f60de6385895
cleanup
protected void cleanup() throws IOException
{    try {        if (qSolver == null && yLookahead.isEmpty()) {            return;        }        if (qSolver == null) {            qSolver = new GivensThinSolver(yLookahead.size(), kp);        }                qSolver.adjust(qSolver.getCnt() + yLookahead.size());        while (!yLookahead.isEmpty()) {            qSolver.appendRow(yLookahead.remove(0));        }        assert qSolver.isFull();        if (++blockCnt > 1) {            flushSolver();            assert tempQw != null;            closeables.remove(tempQw);            Closeables.close(tempQw, false);        }        flushQBlocks();    } finally {        IOUtils.close(closeables);    }}
2ee4c98d23b6c6f27f8311ccff7704f4ac2634c708b8a1cafcfaf3ce2fcdf436
getTempQw
private SequenceFile.Writer getTempQw() throws IOException
{    if (tempQw == null) {        /*       * temporary Q output hopefully will not exceed size of IO cache in which       * case it is only good since it is going to be managed by kernel, not       * java GC. And if IO cache is not good enough, then at least it is always       * sequential.       */        String taskTmpDir = System.getProperty("java.io.tmpdir");        FileSystem localFs = FileSystem.getLocal(jobConf);        Path parent = new Path(taskTmpDir);        Path sub = new Path(parent, "qw_" + System.currentTimeMillis());        tempQPath = new Path(sub, "q-temp.seq");        tempQw = SequenceFile.createWriter(localFs, jobConf, tempQPath, IntWritable.class, DenseBlockWritable.class, CompressionType.BLOCK);        closeables.addFirst(tempQw);        closeables.addFirst(new IOUtils.DeleteFileOnClose(new File(tempQPath.toString())));    }    return tempQw;}
bf5ff19092e7de67441e5c84cfe9cca38b9d25cd8954f1b47755734104aa3d1d
collect
public void collect(Writable key, Vector vw) throws IOException
{    map(vw);}
bae99c7b18c3526fca8b7712eb0c6443f5007c6e73a3dddff81abc1b18d23d59
loadNextQt
private boolean loadNextQt()
{    boolean more = qHatInput.hasNext();    if (!more) {        return false;    }    DenseBlockWritable v = qHatInput.next();    mQt = GivensThinSolver.computeQtHat(v.getBlock(), blockNum == 0 ? 0 : 1, new CopyConstructorIterator<>(mRs.iterator()));    r = mQt[0].length;    kp = mQt.length;    if (qRow == null) {        qRow = new DenseVector(kp);    }    return true;}
d51e5f7450eca0a0f63da1a466189e262d053b84aa767ba3be5cea740af7251b
hasNext
public boolean hasNext()
{    if (mQt != null && cnt == r) {        mQt = null;    }    boolean result = true;    if (mQt == null) {        result = loadNextQt();        cnt = 0;    }    return result;}
a9350b38dc95f8fba46654e36166d86df3596375de6ec61b2c67882f0fa3fbc8
next
public Vector next()
{    if (!hasNext()) {        throw new NoSuchElementException();    }    Validate.isTrue(hasNext(), "Q input overrun");    /*     * because Q blocks are initially stored in inverse order     */    int qRowIndex = r - cnt - 1;    for (int j = 0; j < kp; j++) {        qRow.setQuick(j, mQt[j][qRowIndex]);    }    cnt++;    return qRow;}
eb35e4acc0ab2c89fd30970f01fba35488b3a4581b2af1986091209043508a3e
remove
public void remove()
{    throw new UnsupportedOperationException();}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    mQt = null;    mRs.clear();}
d12e5fe526506b5857cec9b7b0aa4ac94b51335837768f8fbf927f2e672166c2
flushBlock
private void flushBlock() throws IOException
{    if (block == null || block.getNumRows() == 0) {        return;    }    blockKeyW.set(currentBlockNum);    delegate.collect(blockKeyW, block);    block.clear();}
3618a8446da1d203996a41d8a46c9874a18493d9cf3e9b62f5c70eee4a038134
collect
public void collect(Long rowIndex, Vector v) throws IOException
{    long blockKey = rowIndex / height;    if (blockKey != currentBlockNum) {        flushBlock();        if (block == null) {            block = new SparseRowBlockWritable(100);        }        currentBlockNum = blockKey;    }    block.plusRow((int) (rowIndex % height), v);}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    flushBlock();}
7817e7da78d7df90548b354e61f05fb34e551c5bed987a1c195197d99869faa1
getRowIndices
public int[] getRowIndices()
{    return rowIndices;}
73497f2b641b983be1ab235682da5e34e7a8deab3e47813ba0af2a7ab7b7cbc4
getRows
public Vector[] getRows()
{    return rows;}
5478cc5683f6dfd4515c383752d7c803555efc63d03fd84a03ba8dcd17eb4324
readFields
public void readFields(DataInput in) throws IOException
{    numRows = Varint.readUnsignedVarInt(in);    if (rows == null || rows.length < numRows) {        rows = new Vector[numRows];        rowIndices = new int[numRows];    }    VectorWritable vw = new VectorWritable();    for (int i = 0; i < numRows; i++) {        rowIndices[i] = Varint.readUnsignedVarInt(in);        vw.readFields(in);        rows[i] = vw.get().clone();    }}
a894510dd4db439ff8e17ae1059489dc3abc97178e5932ceed0c70c3af165401
write
public void write(DataOutput out) throws IOException
{    Varint.writeUnsignedVarInt(numRows, out);    VectorWritable vw = new VectorWritable();    for (int i = 0; i < numRows; i++) {        Varint.writeUnsignedVarInt(rowIndices[i], out);        vw.set(rows[i]);        vw.write(out);    }}
e57d125a86b5014da4b26e882b860fc3ecc8212984a9f45858bd1226145d61d6
plusRow
public void plusRow(int index, Vector row)
{    /*     * often accumulation goes in row-increasing order, so check for this to     * avoid binary search (another log Height multiplier).     */    int pos = numRows == 0 || rowIndices[numRows - 1] < index ? -numRows - 1 : Arrays.binarySearch(rowIndices, 0, numRows, index);    if (pos >= 0) {        rows[pos].assign(row, PlusMult.plusMult(1));    } else {        insertIntoPos(-pos - 1, index, row);    }}
b1c95865baa7e07f99657d557f6b38b931fd49d09a74a9529c47f0aa50355528
insertIntoPos
private void insertIntoPos(int pos, int rowIndex, Vector row)
{        if (numRows == rows.length) {        rows = Arrays.copyOf(rows, numRows + 1 << 1);        rowIndices = Arrays.copyOf(rowIndices, numRows + 1 << 1);    }        System.arraycopy(rows, pos, rows, pos + 1, numRows - pos);    System.arraycopy(rowIndices, pos, rowIndices, pos + 1, numRows - pos);        rowIndices[pos] = rowIndex;    rows[pos] = row.clone();    numRows++;}
26c3932394e60dd6b36cecd27b7bc1e66a29180d513b287f5b375d4208e8a5da
plusBlock
public void plusBlock(SparseRowBlockWritable bOther)
{    /*     * since we maintained row indices in a sorted order, we can run sort merge     * to expedite this operation     */    int i = 0;    int j = 0;    while (i < numRows && j < bOther.numRows) {        while (i < numRows && rowIndices[i] < bOther.rowIndices[j]) {            i++;        }        if (i < numRows) {            if (rowIndices[i] == bOther.rowIndices[j]) {                rows[i].assign(bOther.rows[j], PlusMult.plusMult(1));            } else {                                insertIntoPos(i, bOther.rowIndices[j], bOther.rows[j]);            }                        i++;            j++;        }    }    for (; j < bOther.numRows; j++) {        insertIntoPos(numRows, bOther.rowIndices[j], bOther.rows[j]);    }}
2503af578b2122cbc01087cf61d4b6bcb88fc4fa04ff61aad1075c281d5a9183
getNumRows
public int getNumRows()
{    return numRows;}
21ac40bb9a99614b6ac18fa4043acb6173fccff96066fdfab963dba597923aa8
clear
public void clear()
{    numRows = 0;    Arrays.fill(rows, null);}
fde4a1a94e8aa66a2c3c1b1bce58d6a4ecc90beaf5b2d59cfaf4627d4c34f6d0
getTaskId
public int getTaskId()
{    return taskId;}
fe94c3cefa7425af78d9585bfe87c5af43956d931c78a1f11fd6fd3093485177
getTaskItemOrdinal
public long getTaskItemOrdinal()
{    return taskItemOrdinal;}
2e8e86d82cb86ebb8abc67d0ada11cd92e3868e35785c90d255107cf3c41181c
incrementItemOrdinal
public void incrementItemOrdinal()
{    taskItemOrdinal++;}
c5d31ae4a95bdd206c8c0c28315c60a9145c3a35bd32b99ee3a8ee995db485ef
setTaskItemOrdinal
public void setTaskItemOrdinal(long taskItemOrdinal)
{    this.taskItemOrdinal = taskItemOrdinal;}
5478cc5683f6dfd4515c383752d7c803555efc63d03fd84a03ba8dcd17eb4324
readFields
public void readFields(DataInput in) throws IOException
{    taskId = Varint.readUnsignedVarInt(in);    taskItemOrdinal = Varint.readUnsignedVarLong(in);}
a894510dd4db439ff8e17ae1059489dc3abc97178e5932ceed0c70c3af165401
write
public void write(DataOutput out) throws IOException
{    Varint.writeUnsignedVarInt(taskId, out);    Varint.writeUnsignedVarLong(taskItemOrdinal, out);}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    int prime = 31;    int result = 1;    result = prime * result + taskId;    return result;}
4afeb0868b55bdd8e18a00a3cb43d83e0714378d1c4bb36f0936daefc060e2e8
equals
public boolean equals(Object obj)
{    if (this == obj) {        return true;    }    if (obj == null) {        return false;    }    if (getClass() != obj.getClass()) {        return false;    }    SplitPartitionedWritable other = (SplitPartitionedWritable) obj;    return taskId == other.taskId;}
55846ffa2de230b7eb967b88eab3d93bdc230ac529d86e42b1fbb9910afa5930
compareTo
public int compareTo(SplitPartitionedWritable o)
{    if (taskId < o.taskId) {        return -1;    }    if (taskId > o.taskId) {        return 1;    }    if (taskItemOrdinal < o.taskItemOrdinal) {        return -1;    }    if (taskItemOrdinal > o.taskItemOrdinal) {        return 1;    }    return 0;}
6df779dcc221b171f478d98267e610d39458359464b3a117aca2f7e217fb7c86
compare
public int compare(Object a, Object b)
{    SplitPartitionedWritable o1 = (SplitPartitionedWritable) a;    SplitPartitionedWritable o2 = (SplitPartitionedWritable) b;    if (o1.taskId < o2.taskId) {        return -1;    }    if (o1.taskId > o2.taskId) {        return 1;    }    return 0;}
aacecb0f01750d985b78d806dc3c134f0da79efe2752957e0f93ecf5cbf9e492
run
public int run(String[] args) throws Exception
{    addInputOption();    addOutputOption();    addOption("rank", "k", "decomposition rank", true);    addOption("oversampling", "p", "oversampling", String.valueOf(15));    addOption("blockHeight", "r", "Y block height (must be > (k+p))", String.valueOf(10000));    addOption("outerProdBlockHeight", "oh", "block height of outer products during multiplication, increase for sparse inputs", String.valueOf(30000));    addOption("abtBlockHeight", "abth", "block height of Y_i in ABtJob during AB' multiplication, increase for extremely sparse inputs", String.valueOf(200000));    addOption("minSplitSize", "s", "minimum split size", String.valueOf(-1));    addOption("computeU", "U", "compute U (true/false)", String.valueOf(true));    addOption("uHalfSigma", "uhs", "Compute U * Sigma^0.5", String.valueOf(false));    addOption("uSigma", "us", "Compute U * Sigma", String.valueOf(false));    addOption("computeV", "V", "compute V (true/false)", String.valueOf(true));    addOption("vHalfSigma", "vhs", "compute V * Sigma^0.5", String.valueOf(false));    addOption("reduceTasks", "t", "number of reduce tasks (where applicable)", true);    addOption("powerIter", "q", "number of additional power iterations (0..2 is good)", String.valueOf(0));    addOption("broadcast", "br", "whether use distributed cache to broadcast matrices wherever possible", String.valueOf(true));    addOption("pca", "pca", "run in pca mode: compute column-wise mean and subtract from input", String.valueOf(false));    addOption("pcaOffset", "xi", "path(glob) of external pca mean (optional, dont compute, use external mean");    addOption(DefaultOptionCreator.overwriteOption().create());    Map<String, List<String>> pargs = parseArguments(args);    if (pargs == null) {        return -1;    }    int k = Integer.parseInt(getOption("rank"));    int p = Integer.parseInt(getOption("oversampling"));    int r = Integer.parseInt(getOption("blockHeight"));    int h = Integer.parseInt(getOption("outerProdBlockHeight"));    int abh = Integer.parseInt(getOption("abtBlockHeight"));    int q = Integer.parseInt(getOption("powerIter"));    int minSplitSize = Integer.parseInt(getOption("minSplitSize"));    boolean computeU = Boolean.parseBoolean(getOption("computeU"));    boolean computeV = Boolean.parseBoolean(getOption("computeV"));    boolean cUHalfSigma = Boolean.parseBoolean(getOption("uHalfSigma"));    boolean cUSigma = Boolean.parseBoolean(getOption("uSigma"));    boolean cVHalfSigma = Boolean.parseBoolean(getOption("vHalfSigma"));    int reduceTasks = Integer.parseInt(getOption("reduceTasks"));    boolean broadcast = Boolean.parseBoolean(getOption("broadcast"));    String xiPathStr = getOption("pcaOffset");    Path xiPath = xiPathStr == null ? null : new Path(xiPathStr);    boolean pca = Boolean.parseBoolean(getOption("pca")) || xiPath != null;    boolean overwrite = hasOption(DefaultOptionCreator.OVERWRITE_OPTION);    Configuration conf = getConf();    if (conf == null) {        throw new IOException("No Hadoop configuration present");    }    Path[] inputPaths = { getInputPath() };    Path tempPath = getTempPath();    FileSystem fs = FileSystem.get(getTempPath().toUri(), conf);        if (overwrite) {                HadoopUtil.delete(getConf(), getOutputPath());                HadoopUtil.delete(getConf(), getTempPath());    }    fs.mkdirs(getOutputPath());        if (pca && xiPath == null) {        xiPath = new Path(tempPath, "xi");        if (overwrite) {            fs.delete(xiPath, true);        }        MatrixColumnMeansJob.run(conf, inputPaths[0], xiPath);    }    SSVDSolver solver = new SSVDSolver(conf, inputPaths, new Path(tempPath, "ssvd"), r, k, p, reduceTasks);    solver.setMinSplitSize(minSplitSize);    solver.setComputeU(computeU);    solver.setComputeV(computeV);    solver.setcUHalfSigma(cUHalfSigma);    solver.setcVHalfSigma(cVHalfSigma);    solver.setcUSigma(cUSigma);    solver.setOuterBlockHeight(h);    solver.setAbtBlockHeight(abh);    solver.setQ(q);    solver.setBroadcast(broadcast);    solver.setOverwrite(overwrite);    if (xiPath != null) {        solver.setPcaMeanPath(new Path(xiPath, "part-*"));    }    solver.run();    Vector svalues = solver.getSingularValues().viewPart(0, k);    SSVDHelper.saveVector(svalues, getOutputPath("sigma"), conf);    if (computeU && !fs.rename(new Path(solver.getUPath()), getOutputPath())) {        throw new IOException("Unable to move U results to the output path.");    }    if (cUHalfSigma && !fs.rename(new Path(solver.getuHalfSigmaPath()), getOutputPath())) {        throw new IOException("Unable to move U*Sigma^0.5 results to the output path.");    }    if (cUSigma && !fs.rename(new Path(solver.getuSigmaPath()), getOutputPath())) {        throw new IOException("Unable to move U*Sigma results to the output path.");    }    if (computeV && !fs.rename(new Path(solver.getVPath()), getOutputPath())) {        throw new IOException("Unable to move V results to the output path.");    }    if (cVHalfSigma && !fs.rename(new Path(solver.getvHalfSigmaPath()), getOutputPath())) {        throw new IOException("Unable to move V*Sigma^0.5 results to the output path.");    }        fs.deleteOnExit(getTempPath());    return 0;}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    ToolRunner.run(new SSVDCli(), args);}
44c237e211993440a4b68a9b743f93be1970ef800002d607a0b000739d1db1df
loadVector
 static Vector loadVector(Path glob, Configuration conf) throws IOException
{    SequenceFileDirValueIterator<VectorWritable> iter = new SequenceFileDirValueIterator<>(glob, PathType.GLOB, null, null, true, conf);    try {        if (!iter.hasNext()) {            throw new IOException("Empty input while reading vector");        }        VectorWritable vw = iter.next();        if (iter.hasNext()) {            throw new IOException("Unexpected data after the end of vector file");        }        return vw.get();    } finally {        Closeables.close(iter, true);    }}
0c31d593d219b3be909b94920d0e28d0a0cca49e0fb4ea833c2b9d39352dae36
saveVector
public static void saveVector(Vector v, Path vectorFilePath, Configuration conf) throws IOException
{    VectorWritable vw = new VectorWritable(v);    FileSystem fs = FileSystem.get(conf);    try (SequenceFile.Writer w = new SequenceFile.Writer(fs, conf, vectorFilePath, IntWritable.class, VectorWritable.class)) {        w.append(new IntWritable(), vw);    }/*       * this is a writer, no quiet close please. we must bail out on incomplete       * close.       */}
48fe16cf916a5a0207083ddcf881d786db66eaa17e841f1d870e9ea00fbc9105
sniffInputLabelType
 static Class<? extends Writable> sniffInputLabelType(Path[] inputPath, Configuration conf) throws IOException
{    FileSystem fs = FileSystem.get(conf);    for (Path p : inputPath) {        FileStatus[] fstats = fs.globStatus(p);        if (fstats == null || fstats.length == 0) {            continue;        }        FileStatus firstSeqFile;        if (fstats[0].isDir()) {            firstSeqFile = fs.listStatus(fstats[0].getPath(), PathFilters.logsCRCFilter())[0];        } else {            firstSeqFile = fstats[0];        }        SequenceFile.Reader r = null;        try {            r = new SequenceFile.Reader(fs, firstSeqFile.getPath(), conf);            return r.getKeyClass().asSubclass(Writable.class);        } finally {            Closeables.close(r, true);        }    }    throw new IOException("Unable to open input files to determine input label type.");}
c1f4d5fc9761488d11e5007053cc287cdcb8f435fa10e4ec655ec8ed47245737
compare
public int compare(FileStatus o1, FileStatus o2)
{    matcher.reset(o1.getPath().getName());    if (!matcher.matches()) {        throw new IllegalArgumentException("Unexpected file name, unable to deduce partition #:" + o1.getPath());    }    int p1 = Integer.parseInt(matcher.group(3));    matcher.reset(o2.getPath().getName());    if (!matcher.matches()) {        throw new IllegalArgumentException("Unexpected file name, unable to deduce partition #:" + o2.getPath());    }    int p2 = Integer.parseInt(matcher.group(3));    return p1 - p2;}
9c892640fa72c5d4edf7d6905ad0f21831f93af1e1ff0fe7f7bc624f9608867a
drmIterator
public static Iterator<Pair<Writable, Vector>> drmIterator(FileSystem fs, Path glob, Configuration conf, Deque<Closeable> closeables) throws IOException
{    SequenceFileDirIterator<Writable, VectorWritable> ret = new SequenceFileDirIterator<>(glob, PathType.GLOB, PathFilters.logsCRCFilter(), PARTITION_COMPARATOR, true, conf);    closeables.addFirst(ret);    return Iterators.transform(ret, new Function<Pair<Writable, VectorWritable>, Pair<Writable, Vector>>() {        @Override        public Pair<Writable, Vector> apply(Pair<Writable, VectorWritable> p) {            return new Pair(p.getFirst(), p.getSecond().get());        }    });}
04d4b6b89501bea338a84ec544db63dd4df1e77b489ca46c7055ee1da98810ab
apply
public Pair<Writable, Vector> apply(Pair<Writable, VectorWritable> p)
{    return new Pair(p.getFirst(), p.getSecond().get());}
90b3c59312239af0667013933fdd45503113b96fa3bf4d38547dc07c916edb6f
drmLoadAsDense
public static DenseMatrix drmLoadAsDense(FileSystem fs, Path glob, Configuration conf) throws IOException
{    Deque<Closeable> closeables = new ArrayDeque<>();    try {        List<double[]> denseData = new ArrayList<>();        for (Iterator<Pair<Writable, Vector>> iter = drmIterator(fs, glob, conf, closeables); iter.hasNext(); ) {            Pair<Writable, Vector> p = iter.next();            Vector v = p.getSecond();            double[] dd = new double[v.size()];            if (v.isDense()) {                for (int i = 0; i < v.size(); i++) {                    dd[i] = v.getQuick(i);                }            } else {                for (Vector.Element el : v.nonZeroes()) {                    dd[el.index()] = el.get();                }            }            denseData.add(dd);        }        if (denseData.size() == 0) {            return null;        } else {            return new DenseMatrix(denseData.toArray(new double[denseData.size()][]));        }    } finally {        IOUtils.close(closeables);    }}
226cba4565a9f4c550bd182d5d655e869214699c2f9ed0d9b75a6e931bb932de
loadAndSumUpperTriangularMatricesAsSymmetric
public static DenseSymmetricMatrix loadAndSumUpperTriangularMatricesAsSymmetric(Path glob, Configuration conf) throws IOException
{    Vector v = loadAndSumUpVectors(glob, conf);    return v == null ? null : new DenseSymmetricMatrix(v);}
838517d964ceb67fbd090ed9587d011efab5d34b5fc781422c0e7f13835e2f11
loadAndSumUpVectors
public static Vector loadAndSumUpVectors(Path glob, Configuration conf) throws IOException
{    SequenceFileDirValueIterator<VectorWritable> iter = new SequenceFileDirValueIterator<>(glob, PathType.GLOB, null, PARTITION_COMPARATOR, true, conf);    try {        Vector v = null;        while (iter.hasNext()) {            if (v == null) {                v = new DenseVector(iter.next().get());            } else {                v.assign(iter.next().get(), Functions.PLUS);            }        }        return v;    } finally {        Closeables.close(iter, true);    }}
0cd28956f2150d767f0ae1f092644d5afe618dc43a2e29c09fe97ec91fd9fed6
loadUpperTriangularMatrix
public static UpperTriangular loadUpperTriangularMatrix(Path glob, Configuration conf) throws IOException
{    try (SequenceFileDirValueIterator<VectorWritable> iter = new SequenceFileDirValueIterator<>(glob, PathType.GLOB, null, null, true, conf)) {        if (!iter.hasNext()) {            throw new IOException("No triangular matrices found");        }        Vector v = iter.next().get();        UpperTriangular result = new UpperTriangular(v);        if (iter.hasNext()) {            throw new IOException("Unexpected overrun in upper triangular matrix files");        }        return result;    }}
43184cd9c39aeb648587a2e4ba5cd3377bfab1d4d1db72c970d6658028ca466b
extractRawData
public static double[][] extractRawData(Matrix m)
{    int rows = m.numRows();    int cols = m.numCols();    double[][] result = new double[rows][];    for (int i = 0; i < rows; i++) {        result[i] = new double[cols];        for (int j = 0; j < cols; j++) {            result[i][j] = m.getQuick(i, j);        }    }    return result;}
9576bc117e96748cc278faeced587f99371bd1241454a486dbcdc6cdf1c7ab02
getQ
public int getQ()
{    return q;}
0fd5a8c444363ce67fc937c7f992f97cd43584cb5a224e7a908cba6289d70b3f
setQ
public void setQ(int q)
{    this.q = q;}
6b98d063c5b005bf98fbbddf49b7939f93325c7052957628ee364f0be18cbd1e
setComputeU
public void setComputeU(boolean val)
{    computeU = val;}
293b4f7c26e6571761fe5ab7f04aa62b3142ec2ae94559ccf50175f7b28ed7e2
setComputeV
public void setComputeV(boolean val)
{    computeV = val;}
bc9bc32865cd689c0523495ec8751a7bd6ac164eb38ce2cb8e7eff0076e36560
setcUHalfSigma
public void setcUHalfSigma(boolean cUHat)
{    this.cUHalfSigma = cUHat;}
f8b99a9057f81a7f1c0a50d82072c32334fea87c348edff83660aacb25419ac3
setcVHalfSigma
public void setcVHalfSigma(boolean cVHat)
{    this.cVHalfSigma = cVHat;}
8d387e64faa22f29e7f4ca5f527b8ab26cb7627cf298213ea5631ae0630c0ba6
setcUSigma
public void setcUSigma(boolean cUSigma)
{    this.cUSigma = cUSigma;}
28b8157daf8f85477a583d189311ea1b3f391b1743667198a48ecf951bf92750
setcVSigma
public void setcVSigma(boolean cVSigma)
{    this.cVSigma = cVSigma;}
917a36959a84a7e6308eb2586fdbf432008484f5430a486f283537c4089ab04c
setMinSplitSize
public void setMinSplitSize(int size)
{    minSplitSize = size;}
3131913d2613e4b13ec2750f2ace0db2870eb5320aab4251e97d8cc235a85cc8
getSingularValues
public Vector getSingularValues()
{    return svalues;}
9a4c89b50efde97889eaf9d1a256af0ac47e5753148f3cc26916412877fc71a1
getUPath
public String getUPath()
{    return uPath;}
05e20518e81229fb77ff915cd6c52ace996c256a5f23a95135bd4af3cbf013bd
getVPath
public String getVPath()
{    return vPath;}
2c712e8677db8a199c1e0cca33f73a1280ed9242e470ab6778e31c7be2b34820
getuSigmaPath
public String getuSigmaPath()
{    return uSigmaPath;}
8600ec722b7d8c9c8183f16b0c2991078052680a47d1b613c513c65e403e7706
getuHalfSigmaPath
public String getuHalfSigmaPath()
{    return uHalfSigmaPath;}
a822711a6932b49f21a9fadb7fff6f7381660f64f3380e82b49af2b864d44026
getvSigmaPath
public String getvSigmaPath()
{    return vSigmaPath;}
bd5e61ca387eeac10cf8782844cd9a0b47870f4383fd7ea74f78f76ce167f211
getvHalfSigmaPath
public String getvHalfSigmaPath()
{    return vHalfSigmaPath;}
ccebb3ae88e57825e08e09eee596f520e63aa37a3a3fb4c9436e39d0a85c7a9f
isOverwrite
public boolean isOverwrite()
{    return overwrite;}
720ef396d8a2a8fdf1fe38fdd434d30f585fe03e8ad26fa974a477928000014c
setOverwrite
public void setOverwrite(boolean overwrite)
{    this.overwrite = overwrite;}
4078634591f5f6708f6f39ff9023d2bd95ee34c89989710900f0b6275c20dcb2
getOuterBlockHeight
public int getOuterBlockHeight()
{    return outerBlockHeight;}
f6775e5aab2ef0e946e55c5994cc0b4f7367a3036b1a4c75a47cb2431c457c42
setOuterBlockHeight
public void setOuterBlockHeight(int outerBlockHeight)
{    this.outerBlockHeight = outerBlockHeight;}
9fdc6a9a7160dee8a02280227427149fbc5fb57a1d9fd95afc05f72d04b5d00c
getAbtBlockHeight
public int getAbtBlockHeight()
{    return abtBlockHeight;}
66c0598977750550c468ab1bad3b312277f4dacfd66bf056ce8d98b50a3370f0
setAbtBlockHeight
public void setAbtBlockHeight(int abtBlockHeight)
{    this.abtBlockHeight = abtBlockHeight;}
ad18c0b542e7b00e6aecaa9e5c479f08012f3fe949a63f13dea33ac1dda3fc15
isBroadcast
public boolean isBroadcast()
{    return broadcast;}
63b2ddaa3dc18efd76386a801636106c8a9d03c0a14eedd4e4aa25ab1b6938d3
setBroadcast
public void setBroadcast(boolean broadcast)
{    this.broadcast = broadcast;}
d3c1686b06c2513c8601710defa770a57db83327b5be3e4e60fa3ae5631622c8
getPcaMeanPath
public Path getPcaMeanPath()
{    return pcaMeanPath;}
bbb69a3b6bcbfb36359c5671757f3e157a4f421bbe1629787a1ca1fc38193eac
setPcaMeanPath
public void setPcaMeanPath(Path pcaMeanPath)
{    this.pcaMeanPath = pcaMeanPath;}
8991b1c2c3659d472e6765c9c025cc6fabf7b9f2569eea5fe3bb0480c0872add
getOmegaSeed
 long getOmegaSeed()
{    return omegaSeed;}
b5070baa161b082d18a140d391b48c0200529b621d1cbd19db35eebf7725cc85
run
public void run() throws IOException
{    Deque<Closeable> closeables = Lists.newLinkedList();    try {        Class<? extends Writable> labelType = SSVDHelper.sniffInputLabelType(inputPath, conf);        FileSystem fs = FileSystem.get(conf);        Path qPath = new Path(outputPath, "Q-job");        Path btPath = new Path(outputPath, "Bt-job");        Path uHatPath = new Path(outputPath, "UHat");        Path svPath = new Path(outputPath, "Sigma");        Path uPath = new Path(outputPath, "U");        Path uSigmaPath = new Path(outputPath, "USigma");        Path uHalfSigmaPath = new Path(outputPath, "UHalfSigma");        Path vPath = new Path(outputPath, "V");        Path vHalfSigmaPath = new Path(outputPath, "VHalfSigma");        Path vSigmaPath = new Path(outputPath, "VSigma");        Path pcaBasePath = new Path(outputPath, "pca");        if (overwrite) {            fs.delete(outputPath, true);        }        if (pcaMeanPath != null) {            fs.mkdirs(pcaBasePath);        }        Random rnd = RandomUtils.getRandom();        omegaSeed = rnd.nextLong();        Path sbPath = null;        double xisquaredlen = 0.0;        if (pcaMeanPath != null) {            /*         * combute s_b0 if pca offset present.         *          * Just in case, we treat xi path as a possible reduce or otherwise         * multiple task output that we assume we need to sum up partial         * components. If it is just one file, it will work too.         */            Vector xi = SSVDHelper.loadAndSumUpVectors(pcaMeanPath, conf);            if (xi == null) {                throw new IOException(String.format("unable to load mean path xi from %s.", pcaMeanPath.toString()));            }            xisquaredlen = xi.dot(xi);            Omega omega = new Omega(omegaSeed, k + p);            Vector s_b0 = omega.mutlithreadedTRightMultiply(xi);            SSVDHelper.saveVector(s_b0, sbPath = new Path(pcaBasePath, "somega.seq"), conf);        }        /*       * if we work with pca offset, we need to precompute s_bq0 aka s_omega for       * jobs to use.       */        QJob.run(conf, inputPath, sbPath, qPath, ablockRows, minSplitSize, k, p, omegaSeed, reduceTasks);        /*       * restrict number of reducers to a reasonable number so we don't have to       * run too many additions in the frontend when reconstructing BBt for the       * last B' and BB' computations. The user may not realize that and gives a       * bit too many (I would be happy i that were ever the case though).       */        BtJob.run(conf, inputPath, qPath, pcaMeanPath, btPath, minSplitSize, k, p, outerBlockHeight, q <= 0 ? Math.min(1000, reduceTasks) : reduceTasks, broadcast, labelType, q <= 0);        sbPath = new Path(btPath, BtJob.OUTPUT_SB + "-*");        Path sqPath = new Path(btPath, BtJob.OUTPUT_SQ + "-*");                for (int i = 0; i < q; i++) {            qPath = new Path(outputPath, String.format("ABt-job-%d", i + 1));            Path btPathGlob = new Path(btPath, BtJob.OUTPUT_BT + "-*");            ABtDenseOutJob.run(conf, inputPath, btPathGlob, pcaMeanPath, sqPath, sbPath, qPath, ablockRows, minSplitSize, k, p, abtBlockHeight, reduceTasks, broadcast);            btPath = new Path(outputPath, String.format("Bt-job-%d", i + 1));            BtJob.run(conf, inputPath, qPath, pcaMeanPath, btPath, minSplitSize, k, p, outerBlockHeight, i == q - 1 ? Math.min(1000, reduceTasks) : reduceTasks, broadcast, labelType, i == q - 1);            sbPath = new Path(btPath, BtJob.OUTPUT_SB + "-*");            sqPath = new Path(btPath, BtJob.OUTPUT_SQ + "-*");        }        DenseSymmetricMatrix bbt = SSVDHelper.loadAndSumUpperTriangularMatricesAsSymmetric(new Path(btPath, BtJob.OUTPUT_BBT + "-*"), conf);                assert bbt.columnSize() == k + p;        /*       * we currently use a 3rd party in-core eigensolver. So we need just a       * dense array representation for it.       */        Matrix bbtSquare = new DenseMatrix(k + p, k + p);        bbtSquare.assign(bbt);                if (pcaMeanPath != null) {            Vector sq = SSVDHelper.loadAndSumUpVectors(sqPath, conf);            Vector sb = SSVDHelper.loadAndSumUpVectors(sbPath, conf);            Matrix mC = sq.cross(sb);            bbtSquare.assign(mC, Functions.MINUS);            bbtSquare.assign(mC.transpose(), Functions.MINUS);            Matrix outerSq = sq.cross(sq);            outerSq.assign(Functions.mult(xisquaredlen));            bbtSquare.assign(outerSq, Functions.PLUS);        }        EigenDecomposition eigen = new EigenDecomposition(bbtSquare);        Matrix uHat = eigen.getV();        svalues = eigen.getRealEigenvalues().clone();        svalues.assign(Functions.SQRT);                fs.mkdirs(uHatPath);        DistributedRowMatrixWriter.write(uHatPath = new Path(uHatPath, "uhat.seq"), conf, uHat);                SSVDHelper.saveVector(svalues, svPath = new Path(svPath, "svalues.seq"), conf);        UJob ujob = null;        if (computeU) {            ujob = new UJob();            ujob.run(conf, new Path(btPath, BtJob.OUTPUT_Q + "-*"), uHatPath, svPath, uPath, k, reduceTasks, labelType, OutputScalingEnum.NOSCALING);                }        UJob uhsjob = null;        if (cUHalfSigma) {            uhsjob = new UJob();            uhsjob.run(conf, new Path(btPath, BtJob.OUTPUT_Q + "-*"), uHatPath, svPath, uHalfSigmaPath, k, reduceTasks, labelType, OutputScalingEnum.HALFSIGMA);        }        UJob usjob = null;        if (cUSigma) {            usjob = new UJob();            usjob.run(conf, new Path(btPath, BtJob.OUTPUT_Q + "-*"), uHatPath, svPath, uSigmaPath, k, reduceTasks, labelType, OutputScalingEnum.SIGMA);        }        VJob vjob = null;        if (computeV) {            vjob = new VJob();            vjob.run(conf, new Path(btPath, BtJob.OUTPUT_BT + "-*"), pcaMeanPath, sqPath, uHatPath, svPath, vPath, k, reduceTasks, OutputScalingEnum.NOSCALING);        }        VJob vhsjob = null;        if (cVHalfSigma) {            vhsjob = new VJob();            vhsjob.run(conf, new Path(btPath, BtJob.OUTPUT_BT + "-*"), pcaMeanPath, sqPath, uHatPath, svPath, vHalfSigmaPath, k, reduceTasks, OutputScalingEnum.HALFSIGMA);        }        VJob vsjob = null;        if (cVSigma) {            vsjob = new VJob();            vsjob.run(conf, new Path(btPath, BtJob.OUTPUT_BT + "-*"), pcaMeanPath, sqPath, uHatPath, svPath, vSigmaPath, k, reduceTasks, OutputScalingEnum.SIGMA);        }        if (ujob != null) {            ujob.waitForCompletion();            this.uPath = uPath.toString();        }        if (uhsjob != null) {            uhsjob.waitForCompletion();            this.uHalfSigmaPath = uHalfSigmaPath.toString();        }        if (usjob != null) {            usjob.waitForCompletion();            this.uSigmaPath = uSigmaPath.toString();        }        if (vjob != null) {            vjob.waitForCompletion();            this.vPath = vPath.toString();        }        if (vhsjob != null) {            vhsjob.waitForCompletion();            this.vHalfSigmaPath = vHalfSigmaPath.toString();        }        if (vsjob != null) {            vsjob.waitForCompletion();            this.vSigmaPath = vSigmaPath.toString();        }    } catch (InterruptedException exc) {        throw new IOException("Interrupted", exc);    } catch (ClassNotFoundException exc) {        throw new IOException(exc);    } finally {        IOUtils.close(closeables);    }}
2d0e187049c8c621304601a06fff3f7822743a281a97a52a28a73f0623503e33
run
public void run(Configuration conf, Path inputPathQ, Path inputUHatPath, Path sigmaPath, Path outputPath, int k, int numReduceTasks, Class<? extends Writable> labelClass, SSVDSolver.OutputScalingEnum outputScaling) throws ClassNotFoundException, InterruptedException, IOException
{    job = new Job(conf);    job.setJobName("U-job");    job.setJarByClass(UJob.class);    job.setInputFormatClass(SequenceFileInputFormat.class);    job.setOutputFormatClass(SequenceFileOutputFormat.class);    FileInputFormat.setInputPaths(job, inputPathQ);    FileOutputFormat.setOutputPath(job, outputPath);        job.getConfiguration().set("mapreduce.output.basename", OUTPUT_U);    FileOutputFormat.setCompressOutput(job, true);    FileOutputFormat.setOutputCompressorClass(job, DefaultCodec.class);    SequenceFileOutputFormat.setOutputCompressionType(job, CompressionType.BLOCK);    job.setMapperClass(UMapper.class);    job.setMapOutputKeyClass(IntWritable.class);    job.setMapOutputValueClass(VectorWritable.class);    job.setOutputKeyClass(labelClass);    job.setOutputValueClass(VectorWritable.class);    job.getConfiguration().set(PROP_UHAT_PATH, inputUHatPath.toString());    job.getConfiguration().set(PROP_SIGMA_PATH, sigmaPath.toString());    job.getConfiguration().set(PROP_OUTPUT_SCALING, outputScaling.name());    job.getConfiguration().setInt(PROP_K, k);    job.setNumReduceTasks(0);    job.submit();}
aed6de1ba0cc4e644f54708175608b8f7dee0752fda83d9936b54921dfc1d28a
waitForCompletion
public void waitForCompletion() throws IOException, ClassNotFoundException, InterruptedException
{    job.waitForCompletion(false);    if (!job.isSuccessful()) {        throw new IOException("U job unsuccessful.");    }}
575b0c06b39ecc623839b56d197693e61a03ae1e8e73b443d344b10d41445dec
map
protected void map(Writable key, VectorWritable value, Context context) throws IOException, InterruptedException
{    Vector qRow = value.get();    if (sValues != null) {        for (int i = 0; i < k; i++) {            uRow.setQuick(i, qRow.dot(uHat.viewColumn(i)) * sValues.getQuick(i));        }    } else {        for (int i = 0; i < k; i++) {            uRow.setQuick(i, qRow.dot(uHat.viewColumn(i)));        }    }    /*       * MAHOUT-1067: inherit A names too.       */    if (qRow instanceof NamedVector) {        uRowWritable.set(new NamedVector(uRow, ((NamedVector) qRow).getName()));    } else {        uRowWritable.set(uRow);    }        context.write(key, uRowWritable);}
6b7dd49be7482fc8ee0fbe8bd0f24522f2a718c8c816a3d7b048fb4688eb6373
setup
protected void setup(Context context) throws IOException, InterruptedException
{    super.setup(context);    Path uHatPath = new Path(context.getConfiguration().get(PROP_UHAT_PATH));    Path sigmaPath = new Path(context.getConfiguration().get(PROP_SIGMA_PATH));    FileSystem fs = FileSystem.get(uHatPath.toUri(), context.getConfiguration());    uHat = SSVDHelper.drmLoadAsDense(fs, uHatPath, context.getConfiguration());        kp = uHat.columnSize();    k = context.getConfiguration().getInt(PROP_K, kp);    uRow = new DenseVector(k);    uRowWritable = new VectorWritable(uRow);    SSVDSolver.OutputScalingEnum outputScaling = SSVDSolver.OutputScalingEnum.valueOf(context.getConfiguration().get(PROP_OUTPUT_SCALING));    switch(outputScaling) {        case SIGMA:            sValues = SSVDHelper.loadVector(sigmaPath, context.getConfiguration());            break;        case HALFSIGMA:            sValues = SSVDHelper.loadVector(sigmaPath, context.getConfiguration());            sValues.assign(Functions.SQRT);            break;        default:    }}
b32d53b76be17c259dec1fb28708d1dc8c56fdc392675bbdac5be7f2e9f09ab1
map
protected void map(IntWritable key, VectorWritable value, Context context) throws IOException, InterruptedException
{    Vector bCol = value.get();    /*       * MAHOUT-817: PCA correction for B': b_{col=i} -= s_q * xi_{i}       */    if (xi != null) {        /*         * code defensively against shortened xi which may be externally         * supplied         */        int btIndex = key.get();        double xii = xi.size() > btIndex ? xi.getQuick(btIndex) : 0.0;        plusMult.setMultiplicator(-xii);        bCol.assign(sq, plusMult);    }    for (int i = 0; i < k; i++) {        vRow.setQuick(i, bCol.dot(uHat.viewColumn(i)) / sValues.getQuick(i));    }    context.write(key, vRowWritable);}
6b7dd49be7482fc8ee0fbe8bd0f24522f2a718c8c816a3d7b048fb4688eb6373
setup
protected void setup(Context context) throws IOException, InterruptedException
{    super.setup(context);    Configuration conf = context.getConfiguration();    FileSystem fs = FileSystem.get(conf);    Path uHatPath = new Path(conf.get(PROP_UHAT_PATH));    Path sigmaPath = new Path(conf.get(PROP_SIGMA_PATH));    uHat = SSVDHelper.drmLoadAsDense(fs, uHatPath, conf);        kp = uHat.columnSize();    k = context.getConfiguration().getInt(PROP_K, kp);    vRow = new DenseVector(k);    vRowWritable = new VectorWritable(vRow);    sValues = SSVDHelper.loadVector(sigmaPath, conf);    SSVDSolver.OutputScalingEnum outputScaling = SSVDSolver.OutputScalingEnum.valueOf(context.getConfiguration().get(PROP_OUTPUT_SCALING));    switch(outputScaling) {        case SIGMA:            sValues.assign(1.0);            break;        case HALFSIGMA:            sValues = SSVDHelper.loadVector(sigmaPath, context.getConfiguration());            sValues.assign(Functions.SQRT);            break;        default:    }    /*       * PCA -related corrections (MAHOUT-817)       */    String xiPathStr = conf.get(PROP_XI_PATH);    if (xiPathStr != null) {        xi = SSVDHelper.loadAndSumUpVectors(new Path(xiPathStr), conf);        sq = SSVDHelper.loadAndSumUpVectors(new Path(conf.get(PROP_SQ_PATH)), conf);    }}
9890681c120db190b7fe9311f15c0f3113f67b3d6015772d58dfcc865b1e7b0a
run
public void run(Configuration conf, Path inputPathBt, Path xiPath, Path sqPath, Path inputUHatPath, Path inputSigmaPath, Path outputPath, int k, int numReduceTasks, SSVDSolver.OutputScalingEnum outputScaling) throws ClassNotFoundException, InterruptedException, IOException
{    job = new Job(conf);    job.setJobName("V-job");    job.setJarByClass(VJob.class);    job.setInputFormatClass(SequenceFileInputFormat.class);    job.setOutputFormatClass(SequenceFileOutputFormat.class);    FileInputFormat.setInputPaths(job, inputPathBt);    FileOutputFormat.setOutputPath(job, outputPath);        job.getConfiguration().set("mapreduce.output.basename", OUTPUT_V);    FileOutputFormat.setCompressOutput(job, true);    FileOutputFormat.setOutputCompressorClass(job, DefaultCodec.class);    SequenceFileOutputFormat.setOutputCompressionType(job, CompressionType.BLOCK);    job.setMapOutputKeyClass(IntWritable.class);    job.setMapOutputValueClass(VectorWritable.class);    job.setOutputKeyClass(IntWritable.class);    job.setOutputValueClass(VectorWritable.class);    job.setMapperClass(VMapper.class);    job.getConfiguration().set(PROP_UHAT_PATH, inputUHatPath.toString());    job.getConfiguration().set(PROP_SIGMA_PATH, inputSigmaPath.toString());    job.getConfiguration().set(PROP_OUTPUT_SCALING, outputScaling.name());    job.getConfiguration().setInt(PROP_K, k);    job.setNumReduceTasks(0);    /*     * PCA-related options, MAHOUT-817     */    if (xiPath != null) {        job.getConfiguration().set(PROP_XI_PATH, xiPath.toString());        job.getConfiguration().set(PROP_SQ_PATH, sqPath.toString());    }    job.submit();}
aed6de1ba0cc4e644f54708175608b8f7dee0752fda83d9936b54921dfc1d28a
waitForCompletion
public void waitForCompletion() throws IOException, ClassNotFoundException, InterruptedException
{    job.waitForCompletion(false);    if (!job.isSuccessful()) {        throw new IOException("V job unsuccessful.");    }}
6b7dd49be7482fc8ee0fbe8bd0f24522f2a718c8c816a3d7b048fb4688eb6373
setup
protected void setup(Context context) throws IOException, InterruptedException
{    int k = context.getConfiguration().getInt(PROP_K, -1);    int p = context.getConfiguration().getInt(PROP_P, -1);    Validate.isTrue(k > 0, "invalid k parameter");    Validate.isTrue(p > 0, "invalid p parameter");    kp = k + p;    long omegaSeed = Long.parseLong(context.getConfiguration().get(PROP_OMEGA_SEED));    omega = new Omega(omegaSeed, k + p);    mYtY = new UpperTriangular(kp);            yRow = new DenseVector(kp);}
575b0c06b39ecc623839b56d197693e61a03ae1e8e73b443d344b10d41445dec
map
protected void map(Writable key, VectorWritable value, Context context) throws IOException, InterruptedException
{    omega.computeYRow(value.get(), yRow);    if (yRow.isDense()) {        for (int i = 0; i < kp; i++) {            double yi;            if ((yi = yRow.getQuick(i)) == 0.0) {                                continue;            }            for (int j = i; j < kp; j++) {                double yj;                if ((yj = yRow.getQuick(j)) != 0.0) {                    mYtY.setQuick(i, j, mYtY.getQuick(i, j) + yi * yj);                }            }        }    } else {        /*         * the disadvantage of using sparse vector (aside from the fact that we         * are creating some short-lived references) here is that we obviously         * do two times more iterations then necessary if y row is pretty dense.         */        for (Vector.Element eli : yRow.nonZeroes()) {            int i = eli.index();            for (Vector.Element elj : yRow.nonZeroes()) {                int j = elj.index();                if (j < i) {                    continue;                }                mYtY.setQuick(i, j, mYtY.getQuick(i, j) + eli.get() * elj.get());            }        }    }}
2e250b70eb1261a97967b8b894cf822fc9e7eb36891dbb77c6d16369f85de12a
cleanup
protected void cleanup(Context context) throws IOException, InterruptedException
{    context.write(new IntWritable(context.getTaskAttemptID().getTaskID().getId()), new VectorWritable(new DenseVector(mYtY.getData())));}
6b7dd49be7482fc8ee0fbe8bd0f24522f2a718c8c816a3d7b048fb4688eb6373
setup
protected void setup(Context context) throws IOException, InterruptedException
{    int k = context.getConfiguration().getInt(PROP_K, -1);    int p = context.getConfiguration().getInt(PROP_P, -1);    Validate.isTrue(k > 0, "invalid k parameter");    Validate.isTrue(p > 0, "invalid p parameter");    accum.set(acc = new DenseVector(k + p));}
2e250b70eb1261a97967b8b894cf822fc9e7eb36891dbb77c6d16369f85de12a
cleanup
protected void cleanup(Context context) throws IOException, InterruptedException
{    context.write(new IntWritable(), accum);}
f1f82ca5afece6fe5498a5288d0450d35450cd7d56e4c0e920cb3e2ca55b5b00
reduce
protected void reduce(IntWritable key, Iterable<VectorWritable> values, Context arg2) throws IOException, InterruptedException
{    for (VectorWritable vw : values) {        acc.addAll(vw.get());    }}
48fb3181cf1974c608d05db9801b3a9e8298638d9ab519093d09fb3aa1efc058
run
public static void run(Configuration conf, Path[] inputPaths, Path outputPath, int k, int p, long seed) throws ClassNotFoundException, InterruptedException, IOException
{    Job job = new Job(conf);    job.setJobName("YtY-job");    job.setJarByClass(YtYJob.class);    job.setInputFormatClass(SequenceFileInputFormat.class);    FileInputFormat.setInputPaths(job, inputPaths);    FileOutputFormat.setOutputPath(job, outputPath);    SequenceFileOutputFormat.setOutputCompressionType(job, CompressionType.BLOCK);    job.setMapOutputKeyClass(IntWritable.class);    job.setMapOutputValueClass(VectorWritable.class);    job.setOutputKeyClass(IntWritable.class);    job.setOutputValueClass(VectorWritable.class);    job.setMapperClass(YtYMapper.class);    job.getConfiguration().setLong(PROP_OMEGA_SEED, seed);    job.getConfiguration().setInt(PROP_K, k);    job.getConfiguration().setInt(PROP_P, p);    /*     * we must reduce to just one matrix which means we need only one reducer.     * But it's ok since each mapper outputs only one vector (a packed     * UpperTriangular) so even if there're thousands of mappers, one reducer     * should cope just fine.     */    job.setNumReduceTasks(1);    job.submit();    job.waitForCompletion(false);    if (!job.isSuccessful()) {        throw new IOException("YtY job unsuccessful.");    }}
ab615085955124d7f843f4d5352840ccef184b2fa1d5f6ce4e7647b9a04fe767
createTimesSquaredJob
public static Job createTimesSquaredJob(Vector v, Path matrixInputPath, Path outputVectorPath) throws IOException
{    return createTimesSquaredJob(new Configuration(), v, matrixInputPath, outputVectorPath);}
8e82e5246ef383dba03c52933b1680d8d0b4fcce016b8dd18d04dbe31f6495b6
createTimesSquaredJob
public static Job createTimesSquaredJob(Configuration initialConf, Vector v, Path matrixInputPath, Path outputVectorPath) throws IOException
{    return createTimesSquaredJob(initialConf, v, matrixInputPath, outputVectorPath, TimesSquaredMapper.class, VectorSummingReducer.class);}
391a780c6f5101c1452af2275d030b31cbed71e6d15dfb6eaacbf55c682d2142
createTimesJob
public static Job createTimesJob(Vector v, int outDim, Path matrixInputPath, Path outputVectorPath) throws IOException
{    return createTimesJob(new Configuration(), v, outDim, matrixInputPath, outputVectorPath);}
5b2a722993ca5016f084c72b0784ed09e57cbe13e0b541c52a96e401895ca1bd
createTimesJob
public static Job createTimesJob(Configuration initialConf, Vector v, int outDim, Path matrixInputPath, Path outputVectorPath) throws IOException
{    return createTimesSquaredJob(initialConf, v, outDim, matrixInputPath, outputVectorPath, TimesMapper.class, VectorSummingReducer.class);}
18947f3b79606fe254d21d8e4d0579a8e948af50face278cbbf57748e084fb68
createTimesSquaredJob
public static Job createTimesSquaredJob(Vector v, Path matrixInputPath, Path outputVectorPathBase, Class<? extends TimesSquaredMapper> mapClass, Class<? extends VectorSummingReducer> redClass) throws IOException
{    return createTimesSquaredJob(new Configuration(), v, matrixInputPath, outputVectorPathBase, mapClass, redClass);}
7b834f667b79acd4a671d5bbcf8a1c05bd89eb567444ce069a6c441450c72114
createTimesSquaredJob
public static Job createTimesSquaredJob(Configuration initialConf, Vector v, Path matrixInputPath, Path outputVectorPathBase, Class<? extends TimesSquaredMapper> mapClass, Class<? extends VectorSummingReducer> redClass) throws IOException
{    return createTimesSquaredJob(initialConf, v, v.size(), matrixInputPath, outputVectorPathBase, mapClass, redClass);}
c5c2e288c554b5788ee07458f38063fa59030976dfd6058db00b267335f93e01
createTimesSquaredJob
public static Job createTimesSquaredJob(Vector v, int outputVectorDim, Path matrixInputPath, Path outputVectorPathBase, Class<? extends TimesSquaredMapper> mapClass, Class<? extends VectorSummingReducer> redClass) throws IOException
{    return createTimesSquaredJob(new Configuration(), v, outputVectorDim, matrixInputPath, outputVectorPathBase, mapClass, redClass);}
5aab13e884209b8bb24b11092a4621743139cd5946016c631ec3dc636ebeb0f3
createTimesSquaredJob
public static Job createTimesSquaredJob(Configuration initialConf, Vector v, int outputVectorDim, Path matrixInputPath, Path outputVectorPathBase, Class<? extends TimesSquaredMapper> mapClass, Class<? extends VectorSummingReducer> redClass) throws IOException
{    FileSystem fs = FileSystem.get(matrixInputPath.toUri(), initialConf);    matrixInputPath = fs.makeQualified(matrixInputPath);    outputVectorPathBase = fs.makeQualified(outputVectorPathBase);    long now = System.nanoTime();    Path inputVectorPath = new Path(outputVectorPathBase, INPUT_VECTOR + '/' + now);    SequenceFile.Writer inputVectorPathWriter = null;    try {        inputVectorPathWriter = new SequenceFile.Writer(fs, initialConf, inputVectorPath, NullWritable.class, VectorWritable.class);        inputVectorPathWriter.append(NullWritable.get(), new VectorWritable(v));    } finally {        Closeables.close(inputVectorPathWriter, false);    }    URI ivpURI = inputVectorPath.toUri();    DistributedCache.setCacheFiles(new URI[] { ivpURI }, initialConf);    Job job = HadoopUtil.prepareJob(matrixInputPath, new Path(outputVectorPathBase, OUTPUT_VECTOR_FILENAME), SequenceFileInputFormat.class, mapClass, NullWritable.class, VectorWritable.class, redClass, NullWritable.class, VectorWritable.class, SequenceFileOutputFormat.class, initialConf);    job.setCombinerClass(redClass);    job.setJobName("TimesSquaredJob: " + matrixInputPath);    Configuration conf = job.getConfiguration();    conf.set(INPUT_VECTOR, ivpURI.toString());    conf.setBoolean(IS_SPARSE_OUTPUT, !v.isDense());    conf.setInt(OUTPUT_VECTOR_DIMENSION, outputVectorDim);    return job;}
9d590529b76b786766bee68682e58a248393225fb7a879827016e70e68582509
retrieveTimesSquaredOutputVector
public static Vector retrieveTimesSquaredOutputVector(Path outputVectorTmpPath, Configuration conf) throws IOException
{    Path outputFile = new Path(outputVectorTmpPath, OUTPUT_VECTOR_FILENAME + "/part-r-00000");    SequenceFileValueIterator<VectorWritable> iterator = new SequenceFileValueIterator<>(outputFile, true, conf);    try {        return iterator.next().get();    } finally {        Closeables.close(iterator, true);    }}
0bd05ac2c380523ecf92ba895e115be954460975dfaf0af72b83eb02b0cd9893
getOutputVector
 Vector getOutputVector()
{    return outputVector;}
d3192444cabbcc9598d5706bfdcd1dfedd209d3688c3c575e42fd6b75ea83739
setup
protected void setup(Context ctx) throws IOException, InterruptedException
{    try {        Configuration conf = ctx.getConfiguration();        Path[] localFiles = DistributedCache.getLocalCacheFiles(conf);        Preconditions.checkArgument(localFiles != null && localFiles.length >= 1, "missing paths from the DistributedCache");        Path inputVectorPath = HadoopUtil.getSingleCachedFile(conf);        SequenceFileValueIterator<VectorWritable> iterator = new SequenceFileValueIterator<>(inputVectorPath, true, conf);        try {            inputVector = iterator.next().get();        } finally {            Closeables.close(iterator, true);        }        int outDim = conf.getInt(OUTPUT_VECTOR_DIMENSION, Integer.MAX_VALUE);        outputVector = conf.getBoolean(IS_SPARSE_OUTPUT, false) ? new RandomAccessSparseVector(outDim, 10) : new DenseVector(outDim);    } catch (IOException ioe) {        throw new IllegalStateException(ioe);    }}
bb2ae71fb9310d48b2957b255da5e4197ffcd753fddc0b589fb2309ed4596b80
map
protected void map(T key, VectorWritable v, Context context) throws IOException, InterruptedException
{    double d = scale(v);    if (d == 1.0) {        outputVector.assign(v.get(), Functions.PLUS);    } else if (d != 0.0) {        outputVector.assign(v.get(), Functions.plusMult(d));    }}
23c399b1a6020da86720a235595d8e572365805209e17902acbe39f621b76cf9
scale
protected double scale(VectorWritable v)
{    return v.get().dot(inputVector);}
1e67e7cddbb210542b6d1a0c46225cb3c8845f7c014f884b63e2f939ee36f067
cleanup
protected void cleanup(Context ctx) throws IOException, InterruptedException
{    ctx.write(NullWritable.get(), new VectorWritable(outputVector));}
ee05ec47ec14c1d749035ef01e89026095be7c10e30a5172875bd052a002e8c3
map
protected void map(IntWritable rowNum, VectorWritable v, Context context) throws IOException, InterruptedException
{    double d = scale(v);    if (d != 0.0) {        getOutputVector().setQuick(rowNum.get(), d);    }}
d3192444cabbcc9598d5706bfdcd1dfedd209d3688c3c575e42fd6b75ea83739
setup
protected void setup(Context ctx) throws IOException, InterruptedException
{    Configuration conf = ctx.getConfiguration();    int outputDimension = conf.getInt(OUTPUT_VECTOR_DIMENSION, Integer.MAX_VALUE);    outputVector = conf.getBoolean(IS_SPARSE_OUTPUT, false) ? new RandomAccessSparseVector(outputDimension, 10) : new DenseVector(outputDimension);}
a909761823668c0987713c9606754546b1588e3e8d6eda3272bd4cb248c80685
reduce
protected void reduce(NullWritable key, Iterable<VectorWritable> vectors, Context ctx) throws IOException, InterruptedException
{    for (VectorWritable v : vectors) {        if (v != null) {            outputVector.assign(v.get(), Functions.PLUS);        }    }    ctx.write(NullWritable.get(), new VectorWritable(outputVector));}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    ToolRunner.run(new TransposeJob(), args);}
b31cb6a894acd9e406667b955507e22a99129892a3c5ceaddbedccc2f2a9db5b
run
public int run(String[] strings) throws Exception
{    addInputOption();    addOption("numRows", "nr", "Number of rows of the input matrix");    addOption("numCols", "nc", "Number of columns of the input matrix");    Map<String, List<String>> parsedArgs = parseArguments(strings);    if (parsedArgs == null) {        return -1;    }    int numRows = Integer.parseInt(getOption("numRows"));    int numCols = Integer.parseInt(getOption("numCols"));    DistributedRowMatrix matrix = new DistributedRowMatrix(getInputPath(), getTempPath(), numRows, numCols);    matrix.setConf(new Configuration(getConf()));    matrix.transpose();    return 0;}
00139380e40c1569cbfac0286f2e0956ff1a5030296b0d52290c14b11c289f2c
buildTransposeJob
public static Job buildTransposeJob(Path matrixInputPath, Path matrixOutputPath, int numInputRows) throws IOException
{    return buildTransposeJob(new Configuration(), matrixInputPath, matrixOutputPath, numInputRows);}
06f9195c5e2d6edcc676a0d3a8b0b0e506d6f3aa94db41412217dcedf13c5cac
buildTransposeJob
public static Job buildTransposeJob(Configuration initialConf, Path matrixInputPath, Path matrixOutputPath, int numInputRows) throws IOException
{    Job job = HadoopUtil.prepareJob(matrixInputPath, matrixOutputPath, SequenceFileInputFormat.class, TransposeMapper.class, IntWritable.class, VectorWritable.class, MergeVectorsReducer.class, IntWritable.class, VectorWritable.class, SequenceFileOutputFormat.class, initialConf);    job.setCombinerClass(MergeVectorsCombiner.class);    job.getConfiguration().setInt(TransposeMapper.NEW_NUM_COLS_PARAM, numInputRows);    job.setJobName("TransposeJob: " + matrixInputPath);    return job;}
6d62829bfa826d89b62f8b82844527a27bf17afd229b1a5348ec0ac9e7f79ba8
write
public static void write(Path outputDir, Configuration conf, VectorIterable matrix) throws IOException
{    FileSystem fs = outputDir.getFileSystem(conf);    fs.delete(outputDir, true);    SequenceFile.Writer writer = SequenceFile.createWriter(fs, conf, outputDir, IntWritable.class, VectorWritable.class);    IntWritable topic = new IntWritable();    VectorWritable vector = new VectorWritable();    for (MatrixSlice slice : matrix) {        topic.set(slice.index());        vector.set(slice.vector());        writer.append(topic, vector);    }    writer.close();}
c0c37ca90cde3b4086fb7eb1cf3c315147d6d2b311ce7fed3c4d423af450808b
read
public static Matrix read(Configuration conf, Path... modelPaths) throws IOException
{    int numRows = -1;    int numCols = -1;    boolean sparse = false;    List<Pair<Integer, Vector>> rows = Lists.newArrayList();    for (Path modelPath : modelPaths) {        for (Pair<IntWritable, VectorWritable> row : new SequenceFileIterable<IntWritable, VectorWritable>(modelPath, true, conf)) {            rows.add(Pair.of(row.getFirst().get(), row.getSecond().get()));            numRows = Math.max(numRows, row.getFirst().get());            sparse = !row.getSecond().get().isDense();            if (numCols < 0) {                numCols = row.getSecond().get().size();            }        }    }    if (rows.isEmpty()) {        throw new IOException(Arrays.toString(modelPaths) + " have no vectors in it");    }    numRows++;    Vector[] arrayOfRows = new Vector[numRows];    for (Pair<Integer, Vector> pair : rows) {        arrayOfRows[pair.getFirst()] = pair.getSecond();    }    Matrix matrix;    if (sparse) {        matrix = new SparseRowMatrix(numRows, numCols, arrayOfRows);    } else {        matrix = new DenseMatrix(numRows, numCols);        for (int i = 0; i < numRows; i++) {            matrix.assignRow(i, arrayOfRows[i]);        }    }    return matrix;}
5d2b93de76218767021fc6a6022719d6c9cea06da3ac9f028fbeb1fed7f8ade2
readDictionary
public static OpenObjectIntHashMap<String> readDictionary(Configuration conf, Path... dictPath)
{    OpenObjectIntHashMap<String> dictionary = new OpenObjectIntHashMap<>();    for (Path dictionaryFile : dictPath) {        for (Pair<Writable, IntWritable> record : new SequenceFileIterable<Writable, IntWritable>(dictionaryFile, true, conf)) {            dictionary.put(record.getFirst().toString(), record.getSecond().get());        }    }    return dictionary;}
d913d6265a1c9c76b03051e2db979a0a676d8fe659cdb3f3c9a152ea516dece4
invertDictionary
public static String[] invertDictionary(OpenObjectIntHashMap<String> termIdMap)
{    int maxTermId = -1;    for (String term : termIdMap.keys()) {        maxTermId = Math.max(maxTermId, termIdMap.get(term));    }    maxTermId++;    String[] dictionary = new String[maxTermId];    for (String term : termIdMap.keys()) {        dictionary[termIdMap.get(term)] = term;    }    return dictionary;}
79cbed8ec593faceb4946ba56ec5347061f2a2b271e2c36d7de0e1f0ae5aa0d3
getVector
public Vector getVector()
{    return vectorWritable.get();}
a251703f52665cd8058a9b91a44363e6622b9ef4757e2f08bd7a821b15df3775
setVector
public void setVector(Vector vector)
{    vectorWritable.set(vector);}
ec6bd91b5ed5a75d3b2e0607af20c620fb2a6584b6329e1fa2b8ab71c011f3a2
setLabels
public void setLabels(int[] labels)
{    this.labels = labels;}
7ee9d16639293bf1d70bf842e0c4a562731fb9f4203899c10c5a2805986410d7
getLabels
public int[] getLabels()
{    return labels;}
5478cc5683f6dfd4515c383752d7c803555efc63d03fd84a03ba8dcd17eb4324
readFields
public void readFields(DataInput in) throws IOException
{    vectorWritable.readFields(in);    int labelSize = in.readInt();    labels = new int[labelSize];    for (int i = 0; i < labelSize; i++) {        labels[i] = in.readInt();    }}
a894510dd4db439ff8e17ae1059489dc3abc97178e5932ceed0c70c3af165401
write
public void write(DataOutput out) throws IOException
{    vectorWritable.write(out);    out.writeInt(labels.length);    for (int label : labels) {        out.writeInt(label);    }}
70ae9725e93cb524213824bd2eb7bc3bd8435c7d8560d41bcb4f6303b818e2a7
read
public static MultiLabelVectorWritable read(DataInput in) throws IOException
{    MultiLabelVectorWritable writable = new MultiLabelVectorWritable();    writable.readFields(in);    return writable;}
925536557319cdd275ad266cc4befb94aeb066dced95936adaa1691e5d026c27
write
public static void write(DataOutput out, SequentialAccessSparseVector ssv, int[] labels) throws IOException
{    new MultiLabelVectorWritable(ssv, labels).write(out);}
269141665c2e8ad04041fb7788d1e101c2f761e325991feb85486dd0a1043c8e
add
public void add(Vector vector)
{    referenceVectors.add(vector);}
72ef1e59027007ffe0950edfd2670ad03bb65cd6463d5d1d282dfeb1750435b0
size
public int size()
{    return referenceVectors.size();}
b8b6e183492b24bae3adc045cbd66b539436386bd3ef4cf30b7bc3652f8bd96f
search
public List<WeightedThing<Vector>> search(Vector query, int limit)
{    Preconditions.checkArgument(limit > 0, "limit must be greater then 0!");    limit = Math.min(limit, referenceVectors.size());            PriorityQueue<WeightedThing<Integer>> bestNeighbors = new PriorityQueue<>(limit, Ordering.natural().reverse());        List<WeightedThing<Vector>> results = Lists.newArrayListWithCapacity(limit);    int rowNumber = 0;    for (Vector row : referenceVectors) {        double distance = distanceMeasure.distance(query, row);                if (bestNeighbors.size() < limit || bestNeighbors.peek().getWeight() > distance) {            bestNeighbors.add(new WeightedThing<>(rowNumber, distance));            if (bestNeighbors.size() > limit) {                bestNeighbors.poll();            } else {                                                results.add(null);            }        }        ++rowNumber;    }    for (int i = limit - 1; i >= 0; --i) {        WeightedThing<Integer> neighbor = bestNeighbors.poll();        results.set(i, new WeightedThing<>(referenceVectors.get(neighbor.getValue()), neighbor.getWeight()));    }    return results;}
b4c07ea18703268448d169c9668744ba8750975ef6918b2c769f1df9b83bdbcb
searchFirst
public WeightedThing<Vector> searchFirst(Vector query, boolean differentThanQuery)
{    double bestDistance = Double.POSITIVE_INFINITY;    Vector bestVector = null;    for (Vector row : referenceVectors) {        double distance = distanceMeasure.distance(query, row);        if (distance < bestDistance && (!differentThanQuery || !row.equals(query))) {            bestDistance = distance;            bestVector = row;        }    }    return new WeightedThing<>(bestVector, bestDistance);}
411a1c8a2594c5028b77c8060d5d0bf72b1af90070a97537dc3c01db9160a0ef
search
public List<List<WeightedThing<Vector>>> search(Iterable<WeightedVector> queries, final int limit, int numThreads) throws InterruptedException
{    ExecutorService executor = Executors.newFixedThreadPool(numThreads);    List<Callable<Object>> tasks = Lists.newArrayList();    final List<List<WeightedThing<Vector>>> results = Lists.newArrayList();    int i = 0;    for (final Vector query : queries) {        results.add(null);        final int index = i++;        tasks.add(new Callable<Object>() {            @Override            public Object call() throws Exception {                results.set(index, BruteSearch.this.search(query, limit));                return null;            }        });    }    executor.invokeAll(tasks);    executor.shutdown();    return results;}
6b6696c98cde0a78a1cb538a0489ddeafee18fe4969bcb083df143138b9793be
call
public Object call() throws Exception
{    results.set(index, BruteSearch.this.search(query, limit));    return null;}
1b5226f5beec2d8e24f17077e3cf629752caa7dc7c1859a1b913ae4ab3c710ea
iterator
public Iterator<Vector> iterator()
{    return referenceVectors.iterator();}
c496a40390479581204897d3732319beb8335f82a0386926f7614b658eb3537e
remove
public boolean remove(Vector query, double epsilon)
{    int rowNumber = 0;    for (Vector row : referenceVectors) {        double distance = distanceMeasure.distance(query, row);        if (distance < epsilon) {            referenceVectors.remove(rowNumber);            return true;        }        rowNumber++;    }    return false;}
21ac40bb9a99614b6ac18fa4043acb6173fccff96066fdfab963dba597923aa8
clear
public void clear()
{    referenceVectors.clear();}
26d5d8d36c4b8e989514309498753c7f2915f59524058aa95b9c8c7f90e0d8af
initialize
private void initialize(int numDimensions)
{    if (initialized) {        return;    }    basisMatrix = RandomProjector.generateBasisNormal(numProjections, numDimensions);    initialized = true;}
269141665c2e8ad04041fb7788d1e101c2f761e325991feb85486dd0a1043c8e
add
public void add(Vector vector)
{    initialize(vector.size());    pendingAdditions.add(vector);}
72ef1e59027007ffe0950edfd2670ad03bb65cd6463d5d1d282dfeb1750435b0
size
public int size()
{    return pendingAdditions.size() + scalarProjections.get(0).size() - numPendingRemovals;}
b8b6e183492b24bae3adc045cbd66b539436386bd3ef4cf30b7bc3652f8bd96f
search
public List<WeightedThing<Vector>> search(Vector query, int limit)
{    reindex(false);    Set<Vector> candidates = Sets.newHashSet();    Vector projection = basisMatrix.times(query);    for (int i = 0; i < basisMatrix.numRows(); ++i) {        List<WeightedThing<Vector>> currProjections = scalarProjections.get(i);        int middle = Collections.binarySearch(currProjections, new WeightedThing<Vector>(projection.get(i)));        if (middle < 0) {            middle = -(middle + 1);        }        for (int j = Math.max(0, middle - searchSize); j < Math.min(currProjections.size(), middle + searchSize + 1); ++j) {            if (currProjections.get(j).getValue() == null) {                continue;            }            candidates.add(currProjections.get(j).getValue());        }    }    List<WeightedThing<Vector>> top = Lists.newArrayListWithCapacity(candidates.size() + pendingAdditions.size());    for (Vector candidate : Iterables.concat(candidates, pendingAdditions)) {        top.add(new WeightedThing<>(candidate, distanceMeasure.distance(candidate, query)));    }    Collections.sort(top);    return top.subList(0, Math.min(top.size(), limit));}
b4c07ea18703268448d169c9668744ba8750975ef6918b2c769f1df9b83bdbcb
searchFirst
public WeightedThing<Vector> searchFirst(Vector query, boolean differentThanQuery)
{    reindex(false);    double bestDistance = Double.POSITIVE_INFINITY;    Vector bestVector = null;    Vector projection = basisMatrix.times(query);    for (int i = 0; i < basisMatrix.numRows(); ++i) {        List<WeightedThing<Vector>> currProjections = scalarProjections.get(i);        int middle = Collections.binarySearch(currProjections, new WeightedThing<Vector>(projection.get(i)));        if (middle < 0) {            middle = -(middle + 1);        }        for (int j = Math.max(0, middle - searchSize); j < Math.min(currProjections.size(), middle + searchSize + 1); ++j) {            if (currProjections.get(j).getValue() == null) {                continue;            }            Vector vector = currProjections.get(j).getValue();            double distance = distanceMeasure.distance(vector, query);            if (distance < bestDistance && (!differentThanQuery || !vector.equals(query))) {                bestDistance = distance;                bestVector = vector;            }        }    }    for (Vector vector : pendingAdditions) {        double distance = distanceMeasure.distance(vector, query);        if (distance < bestDistance && (!differentThanQuery || !vector.equals(query))) {            bestDistance = distance;            bestVector = vector;        }    }    return new WeightedThing<>(bestVector, bestDistance);}
0715e3f3aca1de291912ab23e3dcf34215c671b2097cfb23a22b0e8f3ba885b7
remove
public boolean remove(Vector vector, double epsilon)
{    WeightedThing<Vector> closestPair = searchFirst(vector, false);    if (distanceMeasure.distance(closestPair.getValue(), vector) > epsilon) {        return false;    }    boolean isProjected = true;    Vector projection = basisMatrix.times(vector);    for (int i = 0; i < basisMatrix.numRows(); ++i) {        List<WeightedThing<Vector>> currProjections = scalarProjections.get(i);        WeightedThing<Vector> searchedThing = new WeightedThing<>(projection.get(i));        int middle = Collections.binarySearch(currProjections, searchedThing);        if (middle < 0) {            isProjected = false;            break;        }                        scalarProjections.get(i).set(middle, searchedThing);    }    if (isProjected) {        ++numPendingRemovals;        return true;    }    for (int i = 0; i < pendingAdditions.size(); ++i) {        if (pendingAdditions.get(i).equals(vector)) {            pendingAdditions.remove(i);            break;        }    }    return true;}
99b893742395144f87d853b80cc32e151f731403d62251913c01d13c8a422876
reindex
private void reindex(boolean force)
{    int numProjected = scalarProjections.get(0).size();    if (force || pendingAdditions.size() > ADDITION_THRESHOLD * numProjected || numPendingRemovals > REMOVAL_THRESHOLD * numProjected) {                                List<List<WeightedThing<Vector>>> scalarProjections = Lists.newArrayListWithCapacity(numProjections);        for (int i = 0; i < numProjections; ++i) {            if (i == 0) {                scalarProjections.add(Lists.newArrayList(this.scalarProjections.get(i)));            } else {                scalarProjections.add(this.scalarProjections.get(i));            }        }                for (Vector pending : pendingAdditions) {            Vector projection = basisMatrix.times(pending);            for (int i = 0; i < numProjections; ++i) {                scalarProjections.get(i).add(new WeightedThing<>(pending, projection.get(i)));            }        }        pendingAdditions.clear();                for (int i = 0; i < numProjections; ++i) {            List<WeightedThing<Vector>> currProjections = scalarProjections.get(i);            for (WeightedThing<Vector> v : currProjections) {                if (v.getValue() == null) {                    v.setWeight(Double.POSITIVE_INFINITY);                }            }            Collections.sort(currProjections);            for (int j = 0; j < numPendingRemovals; ++j) {                currProjections.remove(currProjections.size() - 1);            }        }        numPendingRemovals = 0;        this.scalarProjections = scalarProjections;    }}
21ac40bb9a99614b6ac18fa4043acb6173fccff96066fdfab963dba597923aa8
clear
public void clear()
{    pendingAdditions.clear();    for (int i = 0; i < numProjections; ++i) {        scalarProjections.get(i).clear();    }    numPendingRemovals = 0;}
1b5226f5beec2d8e24f17077e3cf629752caa7dc7c1859a1b913ae4ab3c710ea
iterator
public Iterator<Vector> iterator()
{    reindex(true);    return new AbstractIterator<Vector>() {        private final Iterator<WeightedThing<Vector>> data = scalarProjections.get(0).iterator();        @Override        protected Vector computeNext() {            do {                if (!data.hasNext()) {                    return endOfData();                }                WeightedThing<Vector> next = data.next();                if (next.getValue() != null) {                    return next.getValue();                }            } while (true);        }    };}
a4c187d76a1d98ac41bb24750226d783cc1a2dd76f36c2a2bccbc4fbf57a20f2
computeNext
protected Vector computeNext()
{    do {        if (!data.hasNext()) {            return endOfData();        }        WeightedThing<Vector> next = data.next();        if (next.getValue() != null) {            return next.getValue();        }    } while (true);}
a089f52f4f07fae94c52432730642038a3dc9eddf5f2085e5d8c2ddc5a427c57
computeHash64
public static long computeHash64(Vector vector, Matrix projection)
{    long hash = 0;    for (Element element : projection.times(vector).nonZeroes()) {        if (element.get() > 0) {            hash += 1L << element.index();        }    }    return hash;}
94e483bb188b41112f8f45f3dfc9ccf7b9174d3e63a02bfafa6bad3ce5aaa821
hash
public static HashedVector hash(WeightedVector v, Matrix projection)
{    return hash(v, projection, 0);}
459ee4cd356fd72eac2208ac8625241622e1ea2cdcbc6e13ae01fc167d947ed8
hash
public static HashedVector hash(WeightedVector v, Matrix projection, long mask)
{    return new HashedVector(v, projection, mask);}
964cd767ad9c5bd027a94fe5027d3856da5440888a0f777b78779e4588ddf745
hammingDistance
public int hammingDistance(long otherHash)
{    return Long.bitCount(hash ^ otherHash);}
734e526e8d0dd07f3e6cb6fa8beb390ddfbc701c25f1e7375001b5fb3402ce46
getHash
public long getHash()
{    return hash;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return String.format("index=%d, hash=%08x, v=%s", getIndex(), hash, getVector());}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (!(o instanceof HashedVector)) {        return o instanceof Vector && this.minus((Vector) o).norm(1) == 0;    }    HashedVector v = (HashedVector) o;    return v.hash == this.hash && this.minus(v).norm(1) == 0;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    int result = super.hashCode();    result = 31 * result + (int) (hash ^ (hash >>> 32));    return result;}
26d5d8d36c4b8e989514309498753c7f2915f59524058aa95b9c8c7f90e0d8af
initialize
private void initialize(int numDimensions)
{    if (initialized) {        return;    }    initialized = true;    projection = RandomProjector.generateBasisNormal(BITS, numDimensions);}
fb989dbc26eb14b53184af4a9fa604a3e32c6534ee1512d0cd1b89aa8920d778
searchInternal
private PriorityQueue<WeightedThing<Vector>> searchInternal(Vector query)
{    long queryHash = HashedVector.computeHash64(query, projection);        PriorityQueue<WeightedThing<Vector>> top = Searcher.getCandidateQueue(getSearchSize());                OnlineSummarizer[] distribution = new OnlineSummarizer[BITS + 1];    for (int i = 0; i < BITS + 1; i++) {        distribution[i] = new OnlineSummarizer();    }    distanceEvaluations = 0;            int[] hashCounts = new int[BITS + 1];            int hashLimit = BITS;    int limitCount = 0;    double distanceLimit = Double.POSITIVE_INFINITY;        for (HashedVector vector : trainingVectors) {                        int bitDot = vector.hammingDistance(queryHash);        if (bitDot <= hashLimit) {            distanceEvaluations++;            double distance = distanceMeasure.distance(query, vector);            distribution[bitDot].add(distance);            if (distance < distanceLimit) {                top.insertWithOverflow(new WeightedThing<Vector>(vector, distance));                if (top.size() == searchSize) {                    distanceLimit = top.top().getWeight();                }                hashCounts[bitDot]++;                limitCount++;                while (hashLimit > 0 && limitCount - hashCounts[hashLimit - 1] > searchSize) {                    hashLimit--;                    limitCount -= hashCounts[hashLimit];                }                if (hashLimitStrategy >= 0) {                    while (hashLimit < MAX_HASH_LIMIT && distribution[hashLimit].getCount() > MIN_DISTRIBUTION_COUNT && ((1 - hashLimitStrategy) * distribution[hashLimit].getQuartile(0) + hashLimitStrategy * distribution[hashLimit].getQuartile(1)) < distanceLimit) {                        limitCount += hashCounts[hashLimit];                        hashLimit++;                    }                }            }        }    }    return top;}
b8b6e183492b24bae3adc045cbd66b539436386bd3ef4cf30b7bc3652f8bd96f
search
public List<WeightedThing<Vector>> search(Vector query, int limit)
{    PriorityQueue<WeightedThing<Vector>> top = searchInternal(query);    List<WeightedThing<Vector>> results = Lists.newArrayListWithExpectedSize(top.size());    while (top.size() != 0) {        WeightedThing<Vector> wv = top.pop();        results.add(new WeightedThing<>(((HashedVector) wv.getValue()).getVector(), wv.getWeight()));    }    Collections.reverse(results);    if (limit < results.size()) {        results = results.subList(0, limit);    }    return results;}
b4c07ea18703268448d169c9668744ba8750975ef6918b2c769f1df9b83bdbcb
searchFirst
public WeightedThing<Vector> searchFirst(Vector query, boolean differentThanQuery)
{        PriorityQueue<WeightedThing<Vector>> top = searchInternal(query);        while (top.size() > 2) {        top.pop();    }        if (top.size() < 2) {        return removeHash(top.pop());    }        WeightedThing<Vector> secondBest = top.pop();    WeightedThing<Vector> best = top.pop();        if (differentThanQuery && best.getValue().equals(query)) {        best = secondBest;    }    return removeHash(best);}
8041e5c9ed0a6a784145a06d566c02e2637ebe260f42f6e88f0e98b7c0d789d6
removeHash
protected static WeightedThing<Vector> removeHash(WeightedThing<Vector> input)
{    return new WeightedThing<>(((HashedVector) input.getValue()).getVector(), input.getWeight());}
269141665c2e8ad04041fb7788d1e101c2f761e325991feb85486dd0a1043c8e
add
public void add(Vector vector)
{    initialize(vector.size());    trainingVectors.add(new HashedVector(vector, projection, HashedVector.INVALID_INDEX, BIT_MASK));}
72ef1e59027007ffe0950edfd2670ad03bb65cd6463d5d1d282dfeb1750435b0
size
public int size()
{    return trainingVectors.size();}
786c41b3e87db3472188c7d346b02d7a98ae8499804a7879fea3b5c23228c9e0
getSearchSize
public int getSearchSize()
{    return searchSize;}
5bdc9a887269fe52302953c85d29e1e240bcf7f7158dbeecbfb2610d1b1d88b8
setSearchSize
public void setSearchSize(int size)
{    searchSize = size;}
1ab209b967eb68a4495045596e7168286d36617b6a8caa2c42534f723b78c4d3
setRaiseHashLimitStrategy
public void setRaiseHashLimitStrategy(double strategy)
{    hashLimitStrategy = strategy;}
cf40371a08d4afd54f8f1a36035d5fdec45ad017ca9f7434f3e7271224eb4ca4
resetEvaluationCount
public int resetEvaluationCount()
{    int result = distanceEvaluations;    distanceEvaluations = 0;    return result;}
1b5226f5beec2d8e24f17077e3cf629752caa7dc7c1859a1b913ae4ab3c710ea
iterator
public Iterator<Vector> iterator()
{    return Iterators.transform(trainingVectors.iterator(), new Function<HashedVector, Vector>() {        @Override        public Vector apply(org.apache.mahout.math.neighborhood.HashedVector input) {            Preconditions.checkNotNull(input);                        return input.getVector();        }    });}
dd3454625e381516f4f0ee53559cd6af6bebd03d2d5ff682a674cb8c9d9ab41f
apply
public Vector apply(org.apache.mahout.math.neighborhood.HashedVector input)
{    Preconditions.checkNotNull(input);        return input.getVector();}
e3093652667e2f39cbd1379780f969a7e0df3c4b4f2b73fadcea19b03d897c80
remove
public boolean remove(Vector v, double epsilon)
{    return trainingVectors.remove(new HashedVector(v, projection, HashedVector.INVALID_INDEX, BIT_MASK));}
21ac40bb9a99614b6ac18fa4043acb6173fccff96066fdfab963dba597923aa8
clear
public void clear()
{    trainingVectors.clear();}
26d5d8d36c4b8e989514309498753c7f2915f59524058aa95b9c8c7f90e0d8af
initialize
private void initialize(int numDimensions)
{    if (initialized) {        return;    }    initialized = true;    basisMatrix = RandomProjector.generateBasisNormal(numProjections, numDimensions);    scalarProjections = Lists.newArrayList();    for (int i = 0; i < numProjections; ++i) {        scalarProjections.add(TreeMultiset.<WeightedThing<Vector>>create());    }}
269141665c2e8ad04041fb7788d1e101c2f761e325991feb85486dd0a1043c8e
add
public void add(Vector vector)
{    initialize(vector.size());    Vector projection = basisMatrix.times(vector);        int i = 0;    for (TreeMultiset<WeightedThing<Vector>> s : scalarProjections) {        s.add(new WeightedThing<>(vector, projection.get(i++)));    }    int numVectors = scalarProjections.get(0).size();    for (TreeMultiset<WeightedThing<Vector>> s : scalarProjections) {        Preconditions.checkArgument(s.size() == numVectors, "Number of vectors in projection sets " + "differ");        double firstWeight = s.firstEntry().getElement().getWeight();        for (WeightedThing<Vector> w : s) {            Preconditions.checkArgument(firstWeight <= w.getWeight(), "Weights not in non-decreasing " + "order");            firstWeight = w.getWeight();        }    }}
72ef1e59027007ffe0950edfd2670ad03bb65cd6463d5d1d282dfeb1750435b0
size
public int size()
{    if (scalarProjections == null) {        return 0;    }    return scalarProjections.get(0).size();}
b8b6e183492b24bae3adc045cbd66b539436386bd3ef4cf30b7bc3652f8bd96f
search
public List<WeightedThing<Vector>> search(Vector query, int limit)
{    Set<Vector> candidates = Sets.newHashSet();    Iterator<? extends Vector> projections = basisMatrix.iterator();    for (TreeMultiset<WeightedThing<Vector>> v : scalarProjections) {        Vector basisVector = projections.next();        WeightedThing<Vector> projectedQuery = new WeightedThing<>(query, query.dot(basisVector));        for (WeightedThing<Vector> candidate : Iterables.concat(Iterables.limit(v.tailMultiset(projectedQuery, BoundType.CLOSED), searchSize), Iterables.limit(v.headMultiset(projectedQuery, BoundType.OPEN).descendingMultiset(), searchSize))) {            candidates.add(candidate.getValue());        }    }            List<WeightedThing<Vector>> top = Lists.newArrayList();    for (Vector candidate : candidates) {        top.add(new WeightedThing<>(candidate, distanceMeasure.distance(query, candidate)));    }    Collections.sort(top);    return top.subList(0, Math.min(limit, top.size()));}
b4c07ea18703268448d169c9668744ba8750975ef6918b2c769f1df9b83bdbcb
searchFirst
public WeightedThing<Vector> searchFirst(Vector query, boolean differentThanQuery)
{    double bestDistance = Double.POSITIVE_INFINITY;    Vector bestVector = null;    Iterator<? extends Vector> projections = basisMatrix.iterator();    for (TreeMultiset<WeightedThing<Vector>> v : scalarProjections) {        Vector basisVector = projections.next();        WeightedThing<Vector> projectedQuery = new WeightedThing<>(query, query.dot(basisVector));        for (WeightedThing<Vector> candidate : Iterables.concat(Iterables.limit(v.tailMultiset(projectedQuery, BoundType.CLOSED), searchSize), Iterables.limit(v.headMultiset(projectedQuery, BoundType.OPEN).descendingMultiset(), searchSize))) {            double distance = distanceMeasure.distance(query, candidate.getValue());            if (distance < bestDistance && (!differentThanQuery || !candidate.getValue().equals(query))) {                bestDistance = distance;                bestVector = candidate.getValue();            }        }    }    return new WeightedThing<>(bestVector, bestDistance);}
1b5226f5beec2d8e24f17077e3cf629752caa7dc7c1859a1b913ae4ab3c710ea
iterator
public Iterator<Vector> iterator()
{    return new AbstractIterator<Vector>() {        private final Iterator<WeightedThing<Vector>> projected = scalarProjections.get(0).iterator();        @Override        protected Vector computeNext() {            if (!projected.hasNext()) {                return endOfData();            }            return projected.next().getValue();        }    };}
a4c187d76a1d98ac41bb24750226d783cc1a2dd76f36c2a2bccbc4fbf57a20f2
computeNext
protected Vector computeNext()
{    if (!projected.hasNext()) {        return endOfData();    }    return projected.next().getValue();}
0715e3f3aca1de291912ab23e3dcf34215c671b2097cfb23a22b0e8f3ba885b7
remove
public boolean remove(Vector vector, double epsilon)
{    WeightedThing<Vector> toRemove = searchFirst(vector, false);    if (toRemove.getWeight() < epsilon) {        Iterator<? extends Vector> basisVectors = basisMatrix.iterator();        for (TreeMultiset<WeightedThing<Vector>> projection : scalarProjections) {            if (!projection.remove(new WeightedThing<>(vector, vector.dot(basisVectors.next())))) {                throw new RuntimeException("Internal inconsistency in ProjectionSearch");            }        }        return true;    } else {        return false;    }}
21ac40bb9a99614b6ac18fa4043acb6173fccff96066fdfab963dba597923aa8
clear
public void clear()
{    if (scalarProjections == null) {        return;    }    for (TreeMultiset<WeightedThing<Vector>> set : scalarProjections) {        set.clear();    }}
43eb234438d3c4e97fe7a0cf611acc90afcfc253b20b6f3f9c873abeb8d864c1
getDistanceMeasure
public DistanceMeasure getDistanceMeasure()
{    return distanceMeasure;}
8fa4b7e6850db1d794e254498b26dd6d8a700bc781eef0add8d3402da148626a
search
public List<List<WeightedThing<Vector>>> search(Iterable<? extends Vector> queries, int limit)
{    List<List<WeightedThing<Vector>>> results = Lists.newArrayListWithExpectedSize(Iterables.size(queries));    for (Vector query : queries) {        results.add(search(query, limit));    }    return results;}
ca0bb6b184241767f20fb05c2a3f6b05ec06a4952c26f53feee33270daa0ecbe
searchFirst
public List<WeightedThing<Vector>> searchFirst(Iterable<? extends Vector> queries, boolean differentThanQuery)
{    List<WeightedThing<Vector>> results = Lists.newArrayListWithExpectedSize(Iterables.size(queries));    for (Vector query : queries) {        results.add(searchFirst(query, differentThanQuery));    }    return results;}
49e322f69f5fcff77831836f7b5ef2919be506769ad4bb8a1715a6be9d499b01
addAll
public void addAll(Iterable<? extends Vector> data)
{    for (Vector vector : data) {        add(vector);    }}
aea214897316cb349b229e7601aaa63dcb730131fc38228770db618ccb697709
addAllMatrixSlices
public void addAllMatrixSlices(Iterable<MatrixSlice> data)
{    for (MatrixSlice slice : data) {        add(slice.vector());    }}
a65451268dad91d349aa96c58d09e021e1d9c8cd19e4af7c8d9eb1c7546bba68
addAllMatrixSlicesAsWeightedVectors
public void addAllMatrixSlicesAsWeightedVectors(Iterable<MatrixSlice> data)
{    for (MatrixSlice slice : data) {        add(new WeightedVector(slice.vector(), 1, slice.index()));    }}
e3093652667e2f39cbd1379780f969a7e0df3c4b4f2b73fadcea19b03d897c80
remove
public boolean remove(Vector v, double epsilon)
{    throw new UnsupportedOperationException("Can't remove a vector from a " + this.getClass().getName());}
21ac40bb9a99614b6ac18fa4043acb6173fccff96066fdfab963dba597923aa8
clear
public void clear()
{    throw new UnsupportedOperationException("Can't remove vectors from a " + this.getClass().getName());}
174d9522153b4d0a02cafe1ed0ee1eed00aade62b26c92b1dcc7ee46b352d55d
getCandidateQueue
public static PriorityQueue<WeightedThing<Vector>> getCandidateQueue(int limit)
{    return new PriorityQueue<WeightedThing<Vector>>(limit) {        @Override        protected boolean lessThan(WeightedThing<Vector> a, WeightedThing<Vector> b) {            return a.getWeight() > b.getWeight();        }    };}
794eedf1693fcdacf6c447899284913baa40ac24a6c406ff84b801f20cf75335
lessThan
protected boolean lessThan(WeightedThing<Vector> a, WeightedThing<Vector> b)
{    return a.getWeight() > b.getWeight();}
73f7de2503a9846d1f6266eb564191fdf5a1d5aee4d70a9237dd665890253a9f
apply
public double apply(double ignored)
{    return sample();}
21ee60f1df9af3a99dbc80acdc46d04a3f7297ce7117bcfcaac787c5cd5c3629
sample
public Integer sample()
{    double u = rand.nextDouble() * (alpha + weight);    for (int j = 0; j < weights.size(); j++) {                if (u < weights.get(j) - discount) {            weights.set(j, weights.get(j) + 1);            weight++;            return j;        } else {            u -= weights.get(j) - discount;        }    }            weights.add(1);    weight++;    return weights.size() - 1;}
72ef1e59027007ffe0950edfd2670ad03bb65cd6463d5d1d282dfeb1750435b0
size
public int size()
{    return weights.size();}
e4f1a1fb9d49d84a01c8f523b13b2984e20b3d9032426ed0b94c11278333f756
count
public int count()
{    return (int) weight;}
3ba0214d42d2ddcfa56ce3e866349435eca9a661d92011837723e4b5a7182eab
count
public int count(int j)
{    Preconditions.checkArgument(j >= 0);    if (j < weights.size()) {        return (int) weights.get(j);    } else {        return 0;    }}
142d43131103233ffd28c7a14dad7b8d51552f47adf9b1883d29adf096a4e8fb
sample
public Double sample()
{    return sample(gen.nextDouble());}
06425a7bf7bc8c9b5856c2f4cd2be0bb5292825d22a968af1173aa932dfca777
sample
public double sample(double u)
{    if (exceedMinimum && u < x[0]) {                if (u == 0) {            u = 1.0e-16;        }        return y[0] + Math.log(u / x[0]) * x[0] * (y[1] - y[0]) / (x[1] - x[0]);    } else if (exceedMaximum && u > x[n - 1]) {        if (u == 1) {            u = 1 - 1.0e-16;        }                double dy = y[n - 1] - y[n - 2];        double dx = x[n - 1] - x[n - 2];        return y[n - 1] - Math.log((1 - u) / (1 - x[n - 1])) * (1 - x[n - 1]) * dy / dx;    } else {                for (int i = 1; i < n; i++) {            if (x[i] > u) {                double dy = y[i] - y[i - 1];                double dx = x[i] - x[i - 1];                return y[i - 1] + (u - x[i - 1]) * dy / dx;            }        }        throw new RuntimeException(String.format("Can't happen (%.3f is not in [%.3f,%.3f]", u, x[0], x[n - 1]));    }}
bab6c77b89b1c2e775934216f93bb42dd99d2e601fda94f0ec94eb8086c6cab7
createIntegerDocumentSampler
public static IndianBuffet<Integer> createIntegerDocumentSampler(double alpha)
{    return new IndianBuffet<>(alpha, new IdentityConverter());}
4266db29ba61bb19a1948f886a6b2f67ff7caa3f5b56a9487d2c8fb73884de57
createTextDocumentSampler
public static IndianBuffet<String> createTextDocumentSampler(double alpha)
{    return new IndianBuffet<>(alpha, new WordConverter());}
3ad3faa71ce1e193f507ff36bc8c7e11fa6de2bd2092f1f5b79ba43161e79555
sample
public List<T> sample()
{    List<T> r = Lists.newArrayList();    if (documents == 0) {        double n = new PoissonSampler(alpha).sample();        for (int i = 0; i < n; i++) {            r.add(converter.convert(i));            count.add(1);        }        documents++;    } else {        documents++;        int i = 0;        for (double cnt : count) {            if (gen.nextDouble() < cnt / documents) {                r.add(converter.convert(i));                count.set(i, count.get(i) + 1);            }            i++;        }        int newItems = new PoissonSampler(alpha / documents).sample().intValue();        for (int j = 0; j < newItems; j++) {            r.add(converter.convert(i + j));            count.add(1);        }    }    return r;}
44fcef2b2d62733d307dbef7fe3ebdf3b17b3b7e81dcca8bdc54a029d0bb6a5c
convert
public Integer convert(int i)
{    return i;}
b6722901fb58e741731a0bf14b7383f458c98bef8018c03bd4d7c4c89825f83e
convert
public String convert(int i)
{    return String.valueOf(i);}
cfb5c01b1c12c9cd62a4f3e45a9edfb5dbc4590402a68115432b7675c00ec2b0
processLine
public boolean processLine(String line)
{    Iterables.addAll(theWords, onSpace.split(line));    return true;}
310e3fd80944e36ddd53c6125b625bd179722182838aa97258a7fb52ca8f01df
getResult
public List<String> getResult()
{    return theWords;}
b6722901fb58e741731a0bf14b7383f458c98bef8018c03bd4d7c4c89825f83e
convert
public String convert(int i)
{    if (i < words.size()) {        return words.get(i);    } else {        return "w_" + i;    }}
c273cdec1301a12cc09984a7cb72cde7111d576fac81c45d28b33b144d180608
sample
public T sample()
{    if (gen.nextDouble() >= p) {        return delegate.sample();    } else {        return missingMarker;    }}
f1a29e7839188f6f687e9d8480b10b27cc8a88aa9ad9ba728d1f656febcefa82
add
public void add(T value, double w)
{    Preconditions.checkNotNull(value);    Preconditions.checkArgument(!items.containsKey(value));    int n = this.weight.size();    if (n == 1) {        weight.add(w);        values.add(value);        items.put(value, 1);    } else {                weight.add(weight.get(n / 2));        values.add(values.get(n / 2));        items.put(values.get(n / 2), n);        n++;                items.put(value, n);        this.weight.add(w);        values.add(value);                while (n > 1) {            n /= 2;            this.weight.set(n, this.weight.get(n) + w);        }    }}
87d50d81914668a942458bd44b060333106016c36eb93b5b65a4d102ec3c8c48
getWeight
public double getWeight(T value)
{    if (items.containsKey(value)) {        return weight.get(items.get(value));    } else {        return 0;    }}
b124141620b2746c7c87bbbaccdef44dc84f933e1d459342a1a4f46d79c5d71a
getProbability
public double getProbability(T value)
{    if (items.containsKey(value)) {        return weight.get(items.get(value)) / weight.get(1);    } else {        return 0;    }}
4fcdc31ef95f5a8da570a554b48977aa3dd343f3820426ae37586f4231b6e321
getWeight
public double getWeight()
{    if (weight.size() > 1) {        return weight.get(1);    } else {        return 0;    }}
c9e84f3f0085333210fa0fd97281975ade7bbcc4880f63afa7698b069d30417e
delete
public void delete(T value)
{    set(value, 0);}
c0bbace077f6b43ba3318e2b683799445b736e59cace0e6740821ef59740a574
set
public void set(T value, double newP)
{    Preconditions.checkArgument(items.containsKey(value));    int n = items.get(value);    if (newP <= 0) {                        items.remove(value);    }    double oldP = weight.get(n);    while (n > 0) {        weight.set(n, weight.get(n) - oldP + newP);        n /= 2;    }}
c273cdec1301a12cc09984a7cb72cde7111d576fac81c45d28b33b144d180608
sample
public T sample()
{    Preconditions.checkArgument(!weight.isEmpty());    return sample(rand.nextDouble());}
aea7d9f88963ca9131496ef18cc69f1d1f094095796bd2b0c33b2e24525d9b67
sample
public T sample(double u)
{    u *= weight.get(1);    int n = 1;    while (2 * n < weight.size()) {                double left = weight.get(2 * n);        if (u <= left) {            n = 2 * n;        } else {            u -= left;            n = 2 * n + 1;        }    }    return values.get(n);}
04dd93d5f937f6234fa0ce0d8b4b5aab0b298d1bb7fea80eb84b48c29d1a2834
getWeights
 List<Double> getWeights()
{    List<Double> r = Lists.newArrayList();    int i = Integer.highestOneBit(weight.size());    while (i < weight.size()) {        r.add(weight.get(i));        i++;    }    i /= 2;    while (i < Integer.highestOneBit(weight.size())) {        r.add(weight.get(i));        i++;    }    return r;}
f953961d64692f9b59701c434fe1f9537bac98f3f86c59d94e709afc4047563e
iterator
public Iterator<T> iterator()
{    return new AbstractIterator<T>() {        Iterator<T> valuesIterator = Iterables.skip(values, 1).iterator();        @Override        protected T computeNext() {            while (valuesIterator.hasNext()) {                T next = valuesIterator.next();                if (items.containsKey(next)) {                    return next;                }            }            return endOfData();        }    };}
fcbd38ffc429e18428425214f03fd48c7497dba9932fb7efeb3f4f1b5e7362a2
computeNext
protected T computeNext()
{    while (valuesIterator.hasNext()) {        T next = valuesIterator.next();        if (items.containsKey(next)) {            return next;        }    }    return endOfData();}
e544fbe45bf40059e333137f664ed57440302379c709e95c09d77613782eb6fc
sample
public Vector sample()
{    Vector v = new DenseVector(dimension).assign(new DoubleFunction() {        @Override        public double apply(double ignored) {            return gen.nextGaussian();        }    });    if (mean != null) {        if (scale != null) {            return scale.times(v).plus(mean);        } else {            return v.plus(mean);        }    } else {        if (scale != null) {            return scale.times(v);        } else {            return v;        }    }}
73f7de2503a9846d1f6266eb564191fdf5a1d5aee4d70a9237dd665890253a9f
apply
public double apply(double ignored)
{    return gen.nextGaussian();}
e3bd21f39c54cd37161a1e2c96e7e08ebe1eb364f3976f4e3d6a4518a9a6ea58
getScale
public Vector getScale()
{    return mean;}
142d43131103233ffd28c7a14dad7b8d51552f47adf9b1883d29adf096a4e8fb
sample
public Double sample()
{    return rand.nextGaussian() * sd + mean;}
142d43131103233ffd28c7a14dad7b8d51552f47adf9b1883d29adf096a4e8fb
sample
public Double sample()
{    return sample(gen.nextDouble());}
d21d151938de365e5a4475f9963cfef90bff9ed7dab0a77d2831fcb5fe5104a2
sample
 double sample(double u)
{    if (u < limit) {        List<WeightedThing<Integer>> steps = Lists.newArrayList();        limit = 1;        int i = 0;        while (u / 20 < limit) {            double pdf = pd.probability(i);            limit -= pdf;            steps.add(new WeightedThing<>(i, pdf));            i++;        }        steps.add(new WeightedThing<>(steps.size(), limit));        partial = new Multinomial<>(steps);    }    return partial.sample(u);}
7a67722b35b774f1119b275e6bec9db29c5a312179986c169cc3897566f13871
generateBasisNormal
public static Matrix generateBasisNormal(int projectedVectorSize, int vectorSize)
{    Matrix basisMatrix = new DenseMatrix(projectedVectorSize, vectorSize);    basisMatrix.assign(new Normal());    for (MatrixSlice row : basisMatrix) {        row.vector().assign(row.normalize());    }    return basisMatrix;}
32f82a355617da2b8c65f155af89ad26fe4c16403ea464d59e9b9d9b3d81097f
generateBasisPlusMinusOne
public static Matrix generateBasisPlusMinusOne(int projectedVectorSize, int vectorSize)
{    Matrix basisMatrix = new DenseMatrix(projectedVectorSize, vectorSize);    for (int i = 0; i < projectedVectorSize; ++i) {        for (int j = 0; j < vectorSize; ++j) {            basisMatrix.set(i, j, RandomUtils.nextInt(2) == 0 ? 1 : -1);        }    }    for (MatrixSlice row : basisMatrix) {        row.vector().assign(row.normalize());    }    return basisMatrix;}
9cf9de6fdc921ea152cb43b1fd5f39f2af2cae860bc775c96874b70df43e76aa
generateBasisZeroPlusMinusOne
public static Matrix generateBasisZeroPlusMinusOne(int projectedVectorSize, int vectorSize)
{    Matrix basisMatrix = new DenseMatrix(projectedVectorSize, vectorSize);    Multinomial<Double> choice = new Multinomial<>();    choice.add(0.0, 2 / 3.0);    choice.add(Math.sqrt(3.0), 1 / 6.0);    choice.add(-Math.sqrt(3.0), 1 / 6.0);    for (int i = 0; i < projectedVectorSize; ++i) {        for (int j = 0; j < vectorSize; ++j) {            basisMatrix.set(i, j, choice.sample());        }    }    for (MatrixSlice row : basisMatrix) {        row.vector().assign(row.normalize());    }    return basisMatrix;}
39761d7522919606f37869cf47d399939a4a4e7e93fcf18fd695a48b132e6aae
generateVectorBasis
public static List<Vector> generateVectorBasis(int projectedVectorSize, int vectorSize)
{    DoubleFunction random = new Normal();    List<Vector> basisVectors = Lists.newArrayList();    for (int i = 0; i < projectedVectorSize; ++i) {        Vector basisVector = new DenseVector(vectorSize);        basisVector.assign(random);        basisVector.normalize();        basisVectors.add(basisVector);    }    return basisVectors;}
5d1a642cd3f56327936f74c7e42620bdce9a2aa959d5c16e15c526e66eba684a
getValue
public T getValue()
{    return value;}
4fcdc31ef95f5a8da570a554b48977aa3dd343f3820426ae37586f4231b6e321
getWeight
public double getWeight()
{    return weight;}
573f45c20cfe1129d14c1e9631f9247aa24212ba8782b103cc757b5ef4303eb1
setWeight
public void setWeight(double weight)
{    this.weight = weight;}
4005211438c83e03d368def1eee0efa1f240a88bd0adc061d33c05621ae470e3
compareTo
public int compareTo(WeightedThing<T> other)
{    return Double.compare(this.weight, other.weight);}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (o instanceof WeightedThing) {        @SuppressWarnings("unchecked")        WeightedThing<T> other = (WeightedThing<T>) o;        return weight == other.weight && value.equals(other.value);    }    return false;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return 31 * RandomUtils.hashDouble(weight) + value.hashCode();}
3131913d2613e4b13ec2750f2ace0db2870eb5320aab4251e97d8cc235a85cc8
getSingularValues
public Vector getSingularValues()
{    return new DenseVector(svd.getSingularValues());}
b93c02d3200f74c6697e4881155aab7d7cc4f51c675f9516cb10337d05447b38
getU
public Matrix getU()
{        return cd1.solveRight(y).times(svd.getU());}
26cefa3b556cdac980c8fcb58bbf384dae8a5355cbaff131190aec58de3365e0
getV
public Matrix getV()
{        return cd2.solveRight(b.transpose()).times(svd.getV());}
227a30d413b313ebc60827fcd5a58997b5632e1ba2775c84cb5bd27836d60ade
computeV
public void computeV(File tmpDir, int ncols) throws IOException
{        for (int j = 0; j < ncols; j += columnsPerSlice) {        File bPath = bFile(tmpDir, j);        if (bPath.exists()) {            MatrixWritable m = new MatrixWritable();            try (DataInputStream in = new DataInputStream(new FileInputStream(bPath))) {                m.readFields(in);            }            m.set(l2.solveRight(m.get().transpose()).times(svd.getV()));            try (DataOutputStream out = new DataOutputStream(new FileOutputStream(new File(tmpDir, String.format("V-%s", bPath.getName().replaceAll(".*-", "")))))) {                m.write(out);            }        }    }}
d93e469671ad30c06609be98ed76a7077439a6d5e8cd8a4d59e4dd2f216a6ce4
computeU
public void computeU(Iterable<File> partsOfA, File tmpDir) throws IOException
{        for (File file : partsOfA) {        MatrixWritable m = new MatrixWritable();        m.readFields(new DataInputStream(new FileInputStream(file)));        Matrix aI = m.get();        Matrix y = aI.times(new RandomTrinaryMatrix(seed, aI.numCols(), dim, false));        Matrix uI = r2.solveRight(y).times(svd.getU());        m.set(uI);        try (DataOutputStream out = new DataOutputStream(new FileOutputStream(new File(tmpDir, String.format("U-%s", file.getName().replaceAll(".*-", "")))))) {            m.write(out);        }    }}
aa169aaa381c6b26118e5056fef301b50f42703e28e758409b5be2d1445dd772
addToSavedCopy
private static void addToSavedCopy(File file, Matrix matrix) throws IOException
{    MatrixWritable mw = new MatrixWritable();    if (file.exists()) {        try (DataInputStream in = new DataInputStream(new FileInputStream(file))) {            mw.readFields(in);        }        mw.get().assign(matrix, Functions.PLUS);    } else {        mw.set(matrix);    }    try (DataOutputStream out = new DataOutputStream(new FileOutputStream(file))) {        mw.write(out);    }}
30ad191435f4fc2c1481227a2b70c64f91bbdd1e74c19f3503161fa93b03ee71
bFile
private static File bFile(File tmpDir, int j)
{    return new File(tmpDir, String.format("B-%09d", j));}
3131913d2613e4b13ec2750f2ace0db2870eb5320aab4251e97d8cc235a85cc8
getSingularValues
public Vector getSingularValues()
{    return new DenseVector(svd.getSingularValues());}
ea41244409824db60081121fa236b1ddc57577516c4bddbc6fbda91561b1b24f
addSample
public double addSample(int category, String groupKey, double score)
{    return addSample(category, score);}
7f92926912d95386b8e44c033ee960afb4f8251c9587fedc2e0d6f4fb8ef4066
addSample
public double addSample(int category, double score)
{    int n = (int) samples.get(category);    if (n < HISTORY) {        scores.set(category, n, score);    } else {        switch(policy) {            case FIFO:                scores.set(category, n % HISTORY, score);                break;            case FAIR:                int j1 = random.nextInt(n + 1);                if (j1 < HISTORY) {                    scores.set(category, j1, score);                }                break;            case RANDOM:                int j2 = random.nextInt(HISTORY);                scores.set(category, j2, score);                break;            default:                throw new IllegalStateException("Unknown policy: " + policy);        }    }    samples.set(category, n + 1);    if (samples.minValue() >= 1) {                Vector row = scores.viewRow(1 - category);        double m = 0.0;        double count = 0.0;        for (Vector.Element element : row.all()) {            double v = element.get();            if (Double.isNaN(v)) {                continue;            }            count++;            if (score > v) {                m++;                                    } else if (score == v) {                m += 0.5;            }        }        averages.set(category, averages.get(category) + (m / count - averages.get(category)) / Math.min(windowSize, samples.get(category)));    }    return auc();}
b7b9278dce78d03ffa978e3c2e0e40fd1430be1af8a105ca11d28be7d3a4d960
auc
public double auc()
{        return (1 - averages.get(0) + averages.get(1)) / 2;}
fad0efa646766bc958364959a968c166a5314b78390f5b6f9f01363b1c8e26c9
value
public double value()
{    return auc();}
299fd5cd3dcd7f1ff4ad376d5caef60110af315c48a096239588990999d5ff6b
setPolicy
public void setPolicy(ReplacementPolicy policy)
{    this.policy = policy;}
7ba386b15d58e7c9c8dc0e1c66d83ff8cfc28e3f8b9846704bc4cb54bdf8dddd
setWindowSize
public void setWindowSize(int windowSize)
{    this.windowSize = windowSize;}
a894510dd4db439ff8e17ae1059489dc3abc97178e5932ceed0c70c3af165401
write
public void write(DataOutput out) throws IOException
{    out.writeInt(windowSize);    out.writeInt(policy.ordinal());    MatrixWritable.writeMatrix(out, scores);    VectorWritable.writeVector(out, averages);    VectorWritable.writeVector(out, samples);}
5478cc5683f6dfd4515c383752d7c803555efc63d03fd84a03ba8dcd17eb4324
readFields
public void readFields(DataInput in) throws IOException
{    windowSize = in.readInt();    policy = ReplacementPolicy.values()[in.readInt()];    scores = MatrixWritable.readMatrix(in);    averages = VectorWritable.readVector(in);    samples = VectorWritable.readVector(in);}
ea41244409824db60081121fa236b1ddc57577516c4bddbc6fbda91561b1b24f
addSample
public double addSample(int category, String groupKey, double score)
{    if (groupKey == null) {        addSample(category, score);    }    OnlineAuc group = map.get(groupKey);    if (group == null) {        group = new GlobalOnlineAuc();        if (policy != null) {            group.setPolicy(policy);        }        if (windowSize > 0) {            group.setWindowSize(windowSize);        }        map.put(groupKey, group);    }    return group.addSample(category, score);}
7f92926912d95386b8e44c033ee960afb4f8251c9587fedc2e0d6f4fb8ef4066
addSample
public double addSample(int category, double score)
{    throw new UnsupportedOperationException("Can't add to " + this.getClass() + " without group key");}
b7b9278dce78d03ffa978e3c2e0e40fd1430be1af8a105ca11d28be7d3a4d960
auc
public double auc()
{    double sum = 0;    for (OnlineAuc auc : map.values()) {        sum += auc.auc();    }    return sum / map.size();}
b67c821d9ed642562175c3c84c74d1a436de6eed13414e97974788c22fa7f24a
setPolicy
public void setPolicy(GlobalOnlineAuc.ReplacementPolicy policy)
{    this.policy = policy;    for (OnlineAuc auc : map.values()) {        auc.setPolicy(policy);    }}
7ba386b15d58e7c9c8dc0e1c66d83ff8cfc28e3f8b9846704bc4cb54bdf8dddd
setWindowSize
public void setWindowSize(int windowSize)
{    this.windowSize = windowSize;    for (OnlineAuc auc : map.values()) {        auc.setWindowSize(windowSize);    }}
a894510dd4db439ff8e17ae1059489dc3abc97178e5932ceed0c70c3af165401
write
public void write(DataOutput out) throws IOException
{    out.writeInt(map.size());    for (Map.Entry<String, OnlineAuc> entry : map.entrySet()) {        out.writeUTF(entry.getKey());        PolymorphicWritable.write(out, entry.getValue());    }    out.writeInt(policy.ordinal());    out.writeInt(windowSize);}
5478cc5683f6dfd4515c383752d7c803555efc63d03fd84a03ba8dcd17eb4324
readFields
public void readFields(DataInput in) throws IOException
{    int n = in.readInt();    map.clear();    for (int i = 0; i < n; i++) {        String key = in.readUTF();        map.put(key, PolymorphicWritable.read(in, OnlineAuc.class));    }    policy = GlobalOnlineAuc.ReplacementPolicy.values()[in.readInt()];    windowSize = in.readInt();}
0c280ca63f574cf9b9673ca6e0ee36789b58f284b6e96704f53e25359821ea3b
add
public void add(double sample)
{    n++;    double oldMean = mean;    mean += (sample - mean) / n;    double diff = (sample - mean) * (sample - oldMean);    variance += (diff - variance) / n;    quantiles.add(sample);}
29fa59e92e8a9fa433fd7b38ebb21e8ece484149bc8e4a2726bba6f5dab39acf
getCount
public int getCount()
{    return n;}
3c3b0743c9c3947412ad2dc7dde78a1c2165b6db5b7fe4acb40ef8ad53a7efcb
getMean
public double getMean()
{    return mean;}
1b13cc1539099e1040ca859cef5d0bcbb4804d9ec5680bed8a210dd9039e910f
getSD
public double getSD()
{    return Math.sqrt(variance);}
028aeafab053f5bceceab90c3393687fa7a23c1f765b70af7a1a78527c825869
getMin
public double getMin()
{    return getQuartile(0);}
344768211b8524396497604faa40c0faf07104b2ac1129fe45998a40221da827
getMax
public double getMax()
{    return getQuartile(4);}
86789897323fb7b5b89e15ec0d6ba12673fe740d23cd6a5059fa4808e6a22e90
getQuartile
public double getQuartile(int i)
{    return quantiles.quantile(0.25 * i);}
462609a478cd953e2614914e434ca2e83281563106a4c3dd787dce262f2a1d93
quantile
public double quantile(double q)
{    return quantiles.quantile(q);}
fefd78b8b37ef070ed152f0f1afab84bf09cf14cab679983a60cb6ae7bbd3ea7
getMedian
public double getMedian()
{    return getQuartile(2);}
5a91f67a916a68bd8d040d717ee045ee7b08efec4b4f1cd401c2472cd349a52c
sample
public int sample(Vector distribution)
{    return sample(samplerFor(distribution));}
8fc194cc692b390fa380f6d32d259fba25c98634ee013169a5f29eb4f02d8788
sample
public int sample()
{    Preconditions.checkNotNull(sampler, "Sampler must have been constructed with a distribution, or else sample(Vector) should be used to sample");    return sample(sampler);}
71cb39181052e5e071e5beb2c9529c1a7f34bdf2a7d97eee3b6e90be339f633d
samplerFor
private static double[] samplerFor(Vector vectorDistribution)
{    int size = vectorDistribution.size();    double[] partition = new double[size];    double norm = vectorDistribution.norm(1);    double sum = 0;    for (int i = 0; i < size; i++) {        sum += vectorDistribution.get(i) / norm;        partition[i] = sum;    }    return partition;}
d6af9eb4e7b5a0b834da22df73ff3285d73b2c37a5e28e3583cc4cca308e19a0
sample
private int sample(double[] sampler)
{    int index = Arrays.binarySearch(sampler, random.nextDouble());    return index < 0 ? -(index + 1) : index;}
41d85b6dc77211c2bd3df6ac08740820b0a166b5638638df14faed704175c91e
reduce
protected void reduce(GramKey key, Iterable<Gram> values, Context context) throws IOException, InterruptedException
{    int freq = 0;    Gram value = null;        for (Gram value1 : values) {        value = value1;        freq += value.getFrequency();    }    if (value != null) {        value.setFrequency(freq);        context.write(key, value);    }}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    ToolRunner.run(new CollocDriver(), args);}
aacecb0f01750d985b78d806dc3c134f0da79efe2752957e0f93ecf5cbf9e492
run
public int run(String[] args) throws Exception
{    addInputOption();    addOutputOption();    addOption(DefaultOptionCreator.numReducersOption().create());    addOption("maxNGramSize", "ng", "(Optional) The max size of ngrams to create (2 = bigrams, 3 = trigrams, etc) default: 2", String.valueOf(DEFAULT_MAX_NGRAM_SIZE));    addOption("minSupport", "s", "(Optional) Minimum Support. Default Value: " + CollocReducer.DEFAULT_MIN_SUPPORT, String.valueOf(CollocReducer.DEFAULT_MIN_SUPPORT));    addOption("minLLR", "ml", "(Optional)The minimum Log Likelihood Ratio(Float)  Default is " + LLRReducer.DEFAULT_MIN_LLR, String.valueOf(LLRReducer.DEFAULT_MIN_LLR));    addOption(DefaultOptionCreator.overwriteOption().create());    addOption("analyzerName", "a", "The class name of the analyzer to use for preprocessing", null);    addFlag("preprocess", "p", "If set, input is SequenceFile<Text,Text> where the value is the document, " + " which will be tokenized using the specified analyzer.");    addFlag("unigram", "u", "If set, unigrams will be emitted in the final output alongside collocations");    Map<String, List<String>> argMap = parseArguments(args);    if (argMap == null) {        return -1;    }    Path input = getInputPath();    Path output = getOutputPath();    int maxNGramSize = DEFAULT_MAX_NGRAM_SIZE;    if (hasOption("maxNGramSize")) {        try {            maxNGramSize = Integer.parseInt(getOption("maxNGramSize"));        } catch (NumberFormatException ex) {            log.warn("Could not parse ngram size option");        }    }    log.info("Maximum n-gram size is: {}", maxNGramSize);    if (hasOption(DefaultOptionCreator.OVERWRITE_OPTION)) {        HadoopUtil.delete(getConf(), output);    }    int minSupport = CollocReducer.DEFAULT_MIN_SUPPORT;    if (getOption("minSupport") != null) {        minSupport = Integer.parseInt(getOption("minSupport"));    }    log.info("Minimum Support value: {}", minSupport);    float minLLRValue = LLRReducer.DEFAULT_MIN_LLR;    if (getOption("minLLR") != null) {        minLLRValue = Float.parseFloat(getOption("minLLR"));    }    log.info("Minimum LLR value: {}", minLLRValue);    int reduceTasks = DEFAULT_PASS1_NUM_REDUCE_TASKS;    if (getOption("maxRed") != null) {        reduceTasks = Integer.parseInt(getOption("maxRed"));    }    log.info("Number of pass1 reduce tasks: {}", reduceTasks);    boolean emitUnigrams = argMap.containsKey("emitUnigrams");    if (argMap.containsKey("preprocess")) {        log.info("Input will be preprocessed");        Class<? extends Analyzer> analyzerClass = StandardAnalyzer.class;        if (getOption("analyzerName") != null) {            String className = getOption("analyzerName");            analyzerClass = Class.forName(className).asSubclass(Analyzer.class);                                    AnalyzerUtils.createAnalyzer(analyzerClass);        }        Path tokenizedPath = new Path(output, DocumentProcessor.TOKENIZED_DOCUMENT_OUTPUT_FOLDER);        DocumentProcessor.tokenizeDocuments(input, analyzerClass, tokenizedPath, getConf());        input = tokenizedPath;    } else {        log.info("Input will NOT be preprocessed");    }        long ngramCount = generateCollocations(input, output, getConf(), emitUnigrams, maxNGramSize, reduceTasks, minSupport);        computeNGramsPruneByLLR(output, getConf(), ngramCount, emitUnigrams, minLLRValue, reduceTasks);    return 0;}
69a057c3b7237130a74b726203157b26ddfeafc986eb044c289478c746569755
generateAllGrams
public static void generateAllGrams(Path input, Path output, Configuration baseConf, int maxNGramSize, int minSupport, float minLLRValue, int reduceTasks) throws IOException, InterruptedException, ClassNotFoundException
{        long ngramCount = generateCollocations(input, output, baseConf, true, maxNGramSize, reduceTasks, minSupport);        computeNGramsPruneByLLR(output, baseConf, ngramCount, true, minLLRValue, reduceTasks);}
17bf2f8d35047f5b7d0f1059061be4faec4d604ecc3d8cf0df179210c1aea43e
generateCollocations
private static long generateCollocations(Path input, Path output, Configuration baseConf, boolean emitUnigrams, int maxNGramSize, int reduceTasks, int minSupport) throws IOException, ClassNotFoundException, InterruptedException
{    Configuration con = new Configuration(baseConf);    con.setBoolean(EMIT_UNIGRAMS, emitUnigrams);    con.setInt(CollocMapper.MAX_SHINGLE_SIZE, maxNGramSize);    con.setInt(CollocReducer.MIN_SUPPORT, minSupport);    Job job = new Job(con);    job.setJobName(CollocDriver.class.getSimpleName() + ".generateCollocations:" + input);    job.setJarByClass(CollocDriver.class);    job.setMapOutputKeyClass(GramKey.class);    job.setMapOutputValueClass(Gram.class);    job.setPartitionerClass(GramKeyPartitioner.class);    job.setGroupingComparatorClass(GramKeyGroupComparator.class);    job.setOutputKeyClass(Gram.class);    job.setOutputValueClass(Gram.class);    job.setCombinerClass(CollocCombiner.class);    FileInputFormat.setInputPaths(job, input);    Path outputPath = new Path(output, SUBGRAM_OUTPUT_DIRECTORY);    FileOutputFormat.setOutputPath(job, outputPath);    job.setInputFormatClass(SequenceFileInputFormat.class);    job.setMapperClass(CollocMapper.class);    job.setOutputFormatClass(SequenceFileOutputFormat.class);    job.setReducerClass(CollocReducer.class);    job.setNumReduceTasks(reduceTasks);    boolean succeeded = job.waitForCompletion(true);    if (!succeeded) {        throw new IllegalStateException("Job failed!");    }    return job.getCounters().findCounter(CollocMapper.Count.NGRAM_TOTAL).getValue();}
2c03d4d4b227a32450e1441a37661a734daca621fbfb23b510bcb364cfaf8a29
computeNGramsPruneByLLR
private static void computeNGramsPruneByLLR(Path output, Configuration baseConf, long nGramTotal, boolean emitUnigrams, float minLLRValue, int reduceTasks) throws IOException, InterruptedException, ClassNotFoundException
{    Configuration conf = new Configuration(baseConf);    conf.setLong(LLRReducer.NGRAM_TOTAL, nGramTotal);    conf.setBoolean(EMIT_UNIGRAMS, emitUnigrams);    conf.setFloat(LLRReducer.MIN_LLR, minLLRValue);    Job job = new Job(conf);    job.setJobName(CollocDriver.class.getSimpleName() + ".computeNGrams: " + output);    job.setJarByClass(CollocDriver.class);    job.setMapOutputKeyClass(Gram.class);    job.setMapOutputValueClass(Gram.class);    job.setOutputKeyClass(Text.class);    job.setOutputValueClass(DoubleWritable.class);    FileInputFormat.setInputPaths(job, new Path(output, SUBGRAM_OUTPUT_DIRECTORY));    Path outPath = new Path(output, NGRAM_OUTPUT_DIRECTORY);    FileOutputFormat.setOutputPath(job, outPath);    job.setMapperClass(Mapper.class);    job.setInputFormatClass(SequenceFileInputFormat.class);    job.setOutputFormatClass(SequenceFileOutputFormat.class);    job.setReducerClass(LLRReducer.class);    job.setNumReduceTasks(reduceTasks);    boolean succeeded = job.waitForCompletion(true);    if (!succeeded) {        throw new IllegalStateException("Job failed!");    }}
1b8c227cdc1a90c24fff74040a0f3517b8216b837f0f046a957c5b9652902bbc
map
protected void map(Text key, StringTuple value, final Context context) throws IOException, InterruptedException
{    try (ShingleFilter sf = new ShingleFilter(new IteratorTokenStream(value.getEntries().iterator()), maxShingleSize)) {        sf.reset();                int count = 0;        OpenObjectIntHashMap<String> ngrams = new OpenObjectIntHashMap<>(value.getEntries().size() * (maxShingleSize - 1));        OpenObjectIntHashMap<String> unigrams = new OpenObjectIntHashMap<>(value.getEntries().size());        do {            String term = sf.getAttribute(CharTermAttribute.class).toString();            String type = sf.getAttribute(TypeAttribute.class).type();            if ("shingle".equals(type)) {                count++;                ngrams.adjustOrPutValue(term, 1, 1);            } else if (emitUnigrams && !term.isEmpty()) {                                unigrams.adjustOrPutValue(term, 1, 1);            }        } while (sf.incrementToken());        final GramKey gramKey = new GramKey();        ngrams.forEachPair(new ObjectIntProcedure<String>() {            @Override            public boolean apply(String term, int frequency) {                                                int i = term.lastIndexOf(' ');                if (i != -1) {                    try {                        Gram ngram = new Gram(term, frequency, Gram.Type.NGRAM);                        Gram head = new Gram(term.substring(0, i), frequency, Gram.Type.HEAD);                        Gram tail = new Gram(term.substring(i + 1), frequency, Gram.Type.TAIL);                        gramKey.set(head, EMPTY);                        context.write(gramKey, head);                        gramKey.set(head, ngram.getBytes());                        context.write(gramKey, ngram);                        gramKey.set(tail, EMPTY);                        context.write(gramKey, tail);                        gramKey.set(tail, ngram.getBytes());                        context.write(gramKey, ngram);                    } catch (IOException | InterruptedException e) {                        throw new IllegalStateException(e);                    }                }                return true;            }        });        unigrams.forEachPair(new ObjectIntProcedure<String>() {            @Override            public boolean apply(String term, int frequency) {                try {                    Gram unigram = new Gram(term, frequency, Gram.Type.UNIGRAM);                    gramKey.set(unigram, EMPTY);                    context.write(gramKey, unigram);                } catch (IOException | InterruptedException e) {                    throw new IllegalStateException(e);                }                return true;            }        });        context.getCounter(Count.NGRAM_TOTAL).increment(count);        sf.end();    }}
bfc090c76f7d9e8471f36f2cffa129d592dabcd6a9539ef8e403d4ea8706c2da
apply
public boolean apply(String term, int frequency)
{            int i = term.lastIndexOf(' ');    if (i != -1) {        try {            Gram ngram = new Gram(term, frequency, Gram.Type.NGRAM);            Gram head = new Gram(term.substring(0, i), frequency, Gram.Type.HEAD);            Gram tail = new Gram(term.substring(i + 1), frequency, Gram.Type.TAIL);            gramKey.set(head, EMPTY);            context.write(gramKey, head);            gramKey.set(head, ngram.getBytes());            context.write(gramKey, ngram);            gramKey.set(tail, EMPTY);            context.write(gramKey, tail);            gramKey.set(tail, ngram.getBytes());            context.write(gramKey, ngram);        } catch (IOException | InterruptedException e) {            throw new IllegalStateException(e);        }    }    return true;}
bfc090c76f7d9e8471f36f2cffa129d592dabcd6a9539ef8e403d4ea8706c2da
apply
public boolean apply(String term, int frequency)
{    try {        Gram unigram = new Gram(term, frequency, Gram.Type.UNIGRAM);        gramKey.set(unigram, EMPTY);        context.write(gramKey, unigram);    } catch (IOException | InterruptedException e) {        throw new IllegalStateException(e);    }    return true;}
6b7dd49be7482fc8ee0fbe8bd0f24522f2a718c8c816a3d7b048fb4688eb6373
setup
protected void setup(Context context) throws IOException, InterruptedException
{    super.setup(context);    Configuration conf = context.getConfiguration();    this.maxShingleSize = conf.getInt(MAX_SHINGLE_SIZE, DEFAULT_MAX_SHINGLE_SIZE);    this.emitUnigrams = conf.getBoolean(CollocDriver.EMIT_UNIGRAMS, CollocDriver.DEFAULT_EMIT_UNIGRAMS);    if (log.isInfoEnabled()) {        log.info("Max Ngram size is {}", this.maxShingleSize);        log.info("Emit Unitgrams is {}", emitUnigrams);    }}
41d85b6dc77211c2bd3df6ac08740820b0a166b5638638df14faed704175c91e
reduce
protected void reduce(GramKey key, Iterable<Gram> values, Context context) throws IOException, InterruptedException
{    Gram.Type keyType = key.getType();    if (keyType == Gram.Type.UNIGRAM) {                processUnigram(values.iterator(), context);    } else if (keyType == Gram.Type.HEAD || keyType == Gram.Type.TAIL) {                processSubgram(values.iterator(), context);    } else {        context.getCounter(Skipped.MALFORMED_TYPES).increment(1);    }}
6b7dd49be7482fc8ee0fbe8bd0f24522f2a718c8c816a3d7b048fb4688eb6373
setup
protected void setup(Context context) throws IOException, InterruptedException
{    super.setup(context);    Configuration conf = context.getConfiguration();    this.minSupport = conf.getInt(MIN_SUPPORT, DEFAULT_MIN_SUPPORT);    boolean emitUnigrams = conf.getBoolean(CollocDriver.EMIT_UNIGRAMS, CollocDriver.DEFAULT_EMIT_UNIGRAMS);    log.info("Min support is {}", minSupport);    log.info("Emit Unitgrams is {}", emitUnigrams);}
1ae917d08c71183527bd84250d99853ad0316f871889808db63c85285cdd3424
processUnigram
protected void processUnigram(Iterator<Gram> values, Context context) throws IOException, InterruptedException
{    int freq = 0;    Gram value = null;        while (values.hasNext()) {        value = values.next();        freq += value.getFrequency();    }    if (freq < minSupport) {        context.getCounter(Skipped.LESS_THAN_MIN_SUPPORT).increment(1);        return;    }    value.setFrequency(freq);    context.write(value, value);}
eee40fa5efc3a0b444d64bc4a2a03a9079736e7406072b858d42d12364dd5607
processSubgram
protected void processSubgram(Iterator<Gram> values, Context context) throws IOException, InterruptedException
{    Gram subgram = null;    Gram currentNgram = null;    while (values.hasNext()) {        Gram value = values.next();        if (value.getType() == Gram.Type.HEAD || value.getType() == Gram.Type.TAIL) {                        if (subgram == null) {                subgram = new Gram(value);            } else {                subgram.incrementFrequency(value.getFrequency());            }        } else if (!value.equals(currentNgram)) {                        if (currentNgram != null) {                if (currentNgram.getFrequency() < minSupport) {                    context.getCounter(Skipped.LESS_THAN_MIN_SUPPORT).increment(1);                } else {                    context.write(currentNgram, subgram);                }            }            currentNgram = new Gram(value);        } else {            currentNgram.incrementFrequency(value.getFrequency());        }    }        if (currentNgram != null) {        if (currentNgram.getFrequency() < minSupport) {            context.getCounter(Skipped.LESS_THAN_MIN_SUPPORT).increment(1);            return;        }        context.write(currentNgram, subgram);    }}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return String.valueOf(x);}
c159a0fb57e2ba9a7fb373b47eabbc552079ef89a4a50bbca7903b879542d25a
getBytes
public byte[] getBytes()
{    return bytes;}
1e7a9ccf869d4ffcaafdb7996c8f1f820d6f2af9eb816b65ead1db5bcfc3f744
getLength
public int getLength()
{    return length;}
b36c0cb78d388571653840506cba5d90e12b262c755658912fc2224c314bcbf6
getType
public Type getType()
{    return decodeType(bytes, 0);}
6f98cfba8fd1113c0670baa214bd66d71beaef8f7140e311bc823c3ff4e19591
getString
public String getString()
{    try {        return Text.decode(bytes, 1, length - 1);    } catch (CharacterCodingException e) {        throw new IllegalStateException("Should not have happened " + e);    }}
d118f52c3bfce33b7fd46b77a2feb2d0f59177aa642851f9494239964d69d75d
getFrequency
public int getFrequency()
{    return frequency;}
fccbe6f035a6e46e49743eafeada391b15a19747868f294b317a193e182eede3
setFrequency
public void setFrequency(int frequency)
{    this.frequency = frequency;}
b2750af3fc404dd6617c8e465263b7af6b70d317c1925fadc4e1195de04796a2
incrementFrequency
public void incrementFrequency(int i)
{    this.frequency += i;}
5478cc5683f6dfd4515c383752d7c803555efc63d03fd84a03ba8dcd17eb4324
readFields
public void readFields(DataInput in) throws IOException
{    int newLength = Varint.readUnsignedVarInt(in);    setCapacity(newLength, false);    in.readFully(bytes, 0, newLength);    int newFrequency = Varint.readUnsignedVarInt(in);    length = newLength;    frequency = newFrequency;}
a894510dd4db439ff8e17ae1059489dc3abc97178e5932ceed0c70c3af165401
write
public void write(DataOutput out) throws IOException
{    Varint.writeUnsignedVarInt(length, out);    out.write(bytes, 0, length);    Varint.writeUnsignedVarInt(frequency, out);}
99395a3cd69899c3e4532007f5eb265da8f0f1f2005733fa5fa73a37237756b0
setCapacity
private void setCapacity(int len, boolean keepData)
{        len++;    if (bytes == null || bytes.length < len) {        byte[] newBytes = new byte[len];        if (bytes != null && keepData) {            System.arraycopy(bytes, 0, newBytes, 0, length);        }        bytes = newBytes;    }}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return '\'' + getString() + "'[" + getType() + "]:" + frequency;}
46cc928319aa9a2620260d06de2b94d94f5156ea68140b1630a5cb2bd1fa7853
encodeType
public static void encodeType(Type type, byte[] buf, int offset)
{    switch(type) {        case HEAD:            buf[offset] = 0x1;            break;        case TAIL:            buf[offset] = 0x2;            break;        case UNIGRAM:            buf[offset] = 0x3;            break;        case NGRAM:            buf[offset] = 0x4;            break;        default:            throw new IllegalStateException("switch/case problem in encodeType");    }}
fc150b652ac6919e49bea4c624ffb7811bcea3f64f4078675de156a3621dce10
decodeType
public static Type decodeType(byte[] buf, int offset)
{    switch(buf[offset]) {        case 0x1:            return Type.HEAD;        case 0x2:            return Type.TAIL;        case 0x3:            return Type.UNIGRAM;        case 0x4:            return Type.NGRAM;        default:            throw new IllegalStateException("switch/case problem in decodeType");    }}
daeeb06069e53fe56a71d578545095f1c9dd092ce1275f9b687946ba439076a4
set
public void set(Gram gram, byte[] order)
{    primaryLength = gram.getLength();    length = primaryLength + order.length;    setCapacity(length, false);    System.arraycopy(gram.getBytes(), 0, bytes, 0, primaryLength);    if (order.length > 0) {        System.arraycopy(order, 0, bytes, primaryLength, order.length);    }}
c159a0fb57e2ba9a7fb373b47eabbc552079ef89a4a50bbca7903b879542d25a
getBytes
public byte[] getBytes()
{    return bytes;}
1e7a9ccf869d4ffcaafdb7996c8f1f820d6f2af9eb816b65ead1db5bcfc3f744
getLength
public int getLength()
{    return length;}
c8699c0be8f7e94c3df35559fb9c0584b1acff2fd0fb97a2866616e102494330
getPrimaryLength
public int getPrimaryLength()
{    return primaryLength;}
5478cc5683f6dfd4515c383752d7c803555efc63d03fd84a03ba8dcd17eb4324
readFields
public void readFields(DataInput in) throws IOException
{    int newLength = Varint.readUnsignedVarInt(in);    int newPrimaryLength = Varint.readUnsignedVarInt(in);    setCapacity(newLength, false);    in.readFully(bytes, 0, newLength);    length = newLength;    primaryLength = newPrimaryLength;}
a894510dd4db439ff8e17ae1059489dc3abc97178e5932ceed0c70c3af165401
write
public void write(DataOutput out) throws IOException
{    Varint.writeUnsignedVarInt(length, out);    Varint.writeUnsignedVarInt(primaryLength, out);    out.write(bytes, 0, length);}
99395a3cd69899c3e4532007f5eb265da8f0f1f2005733fa5fa73a37237756b0
setCapacity
private void setCapacity(int len, boolean keepData)
{    if (bytes == null || bytes.length < len) {        byte[] newBytes = new byte[len];        if (bytes != null && keepData) {            System.arraycopy(bytes, 0, newBytes, 0, length);        }        bytes = newBytes;    }}
b36c0cb78d388571653840506cba5d90e12b262c755658912fc2224c314bcbf6
getType
public Type getType()
{    return Gram.decodeType(bytes, 0);}
74dc98d93cd26172979c2ff6ceefd9dad2f1611d400eee17ca7442cf45cd3215
getPrimaryString
public String getPrimaryString()
{    try {        return Text.decode(bytes, 1, primaryLength - 1);    } catch (CharacterCodingException e) {        throw new IllegalStateException(e);    }}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return '\'' + getPrimaryString() + "'[" + getType() + ']';}
1487ad502ab31c307d33fb896d3e5baa03b686bf54cf28348227f1e662c6bbfc
compare
public int compare(WritableComparable a, WritableComparable b)
{    GramKey gka = (GramKey) a;    GramKey gkb = (GramKey) b;    return WritableComparator.compareBytes(gka.getBytes(), 0, gka.getPrimaryLength(), gkb.getBytes(), 0, gkb.getPrimaryLength());}
447aabffd7593a7d5e26de24a580427f5c277e33638b17495c8578e738c71686
getPartition
public int getPartition(GramKey key, Gram value, int numPartitions)
{    int hash = 1;    byte[] bytes = key.getBytes();    int length = key.getPrimaryLength();        for (int i = 1; i < length; i++) {        hash = (31 * hash) + bytes[i];    }    return (hash & Integer.MAX_VALUE) % numPartitions;}
46f804d00727353f27a63cddac3da595b3257c499282e2d439e54ab684ff79d4
reduce
protected void reduce(Gram ngram, Iterable<Gram> values, Context context) throws IOException, InterruptedException
{    int[] gramFreq = { -1, -1 };    if (ngram.getType() == Gram.Type.UNIGRAM && emitUnigrams) {        DoubleWritable dd = new DoubleWritable(ngram.getFrequency());        Text t = new Text(ngram.getString());        context.write(t, dd);        return;    }            String[] gram = new String[2];    for (Gram value : values) {        int pos = value.getType() == Gram.Type.HEAD ? 0 : 1;        if (gramFreq[pos] != -1) {            log.warn("Extra {} for {}, skipping", value.getType(), ngram);            if (value.getType() == Gram.Type.HEAD) {                context.getCounter(Skipped.EXTRA_HEAD).increment(1);            } else {                context.getCounter(Skipped.EXTRA_TAIL).increment(1);            }            return;        }        gram[pos] = value.getString();        gramFreq[pos] = value.getFrequency();    }    if (gramFreq[0] == -1) {        log.warn("Missing head for {}, skipping.", ngram);        context.getCounter(Skipped.MISSING_HEAD).increment(1);        return;    }    if (gramFreq[1] == -1) {        log.warn("Missing tail for {}, skipping", ngram);        context.getCounter(Skipped.MISSING_TAIL).increment(1);        return;    }    long k11 = ngram.getFrequency();    /* a&b */    long k12 = gramFreq[0] - ngram.getFrequency();    /* a&!b */    long k21 = gramFreq[1] - ngram.getFrequency();    /* !b&a */    long k22 = ngramTotal - (gramFreq[0] + gramFreq[1] - ngram.getFrequency());    /* !a&!b */    double llr;    try {        llr = ll.logLikelihoodRatio(k11, k12, k21, k22);    } catch (IllegalArgumentException ex) {        context.getCounter(Skipped.LLR_CALCULATION_ERROR).increment(1);        log.warn("Problem calculating LLR ratio for ngram {}, HEAD {}:{}, TAIL {}:{}, k11/k12/k21/k22: {}/{}/{}/{}", ngram, gram[0], gramFreq[0], gram[1], gramFreq[1], k11, k12, k21, k22, ex);        return;    }    if (llr < minLLRValue) {        context.getCounter(Skipped.LESS_THAN_MIN_LLR).increment(1);    } else {        context.write(new Text(ngram.getString()), new DoubleWritable(llr));    }}
6b7dd49be7482fc8ee0fbe8bd0f24522f2a718c8c816a3d7b048fb4688eb6373
setup
protected void setup(Context context) throws IOException, InterruptedException
{    super.setup(context);    Configuration conf = context.getConfiguration();    this.ngramTotal = conf.getLong(NGRAM_TOTAL, -1);    this.minLLRValue = conf.getFloat(MIN_LLR, DEFAULT_MIN_LLR);    this.emitUnigrams = conf.getBoolean(CollocDriver.EMIT_UNIGRAMS, CollocDriver.DEFAULT_EMIT_UNIGRAMS);    log.info("NGram Total: {}, Min LLR value: {}, Emit Unigrams: {}", ngramTotal, minLLRValue, emitUnigrams);    if (ngramTotal == -1) {        throw new IllegalStateException("No NGRAM_TOTAL available in job config");    }}
7a4d61c6559e2615379897c824cc5e4d52749e202f1568c776bf3ea84bb92c10
logLikelihoodRatio
public double logLikelihoodRatio(long k11, long k12, long k21, long k22)
{    return LogLikelihood.logLikelihoodRatio(k11, k12, k21, k22);}
8da2736c2ba03f6e4df6dc3f1ebd7cd30f5dafb255e9844b133d2cca0bb4ad26
mergePartialVectors
public static void mergePartialVectors(Iterable<Path> partialVectorPaths, Path output, Configuration baseConf, float normPower, boolean logNormalize, int dimension, boolean sequentialAccess, boolean namedVector, int numReducers) throws IOException, InterruptedException, ClassNotFoundException
{    Preconditions.checkArgument(normPower == NO_NORMALIZING || normPower >= 0, "If specified normPower must be nonnegative", normPower);    Preconditions.checkArgument(normPower == NO_NORMALIZING || (normPower > 1 && !Double.isInfinite(normPower)) || !logNormalize, "normPower must be > 1 and not infinite if log normalization is chosen", normPower);    Configuration conf = new Configuration(baseConf);        conf.set("io.serializations", "org.apache.hadoop.io.serializer.JavaSerialization," + "org.apache.hadoop.io.serializer.WritableSerialization");    conf.setBoolean(SEQUENTIAL_ACCESS, sequentialAccess);    conf.setBoolean(NAMED_VECTOR, namedVector);    conf.setInt(DIMENSION, dimension);    conf.setFloat(NORMALIZATION_POWER, normPower);    conf.setBoolean(LOG_NORMALIZE, logNormalize);    Job job = new Job(conf);    job.setJobName("PartialVectorMerger::MergePartialVectors");    job.setJarByClass(PartialVectorMerger.class);    job.setOutputKeyClass(Text.class);    job.setOutputValueClass(VectorWritable.class);    FileInputFormat.setInputPaths(job, getCommaSeparatedPaths(partialVectorPaths));    FileOutputFormat.setOutputPath(job, output);    job.setMapperClass(Mapper.class);    job.setInputFormatClass(SequenceFileInputFormat.class);    job.setReducerClass(PartialVectorMergeReducer.class);    job.setOutputFormatClass(SequenceFileOutputFormat.class);    job.setNumReduceTasks(numReducers);    HadoopUtil.delete(conf, output);    boolean succeeded = job.waitForCompletion(true);    if (!succeeded) {        throw new IllegalStateException("Job failed!");    }}
93c8d5b361135e5c25dbea2893000b2051cd4387648eac6264ca5ca32aeb4f0f
getCommaSeparatedPaths
private static String getCommaSeparatedPaths(Iterable<Path> paths)
{    StringBuilder commaSeparatedPaths = new StringBuilder(100);    String sep = "";    for (Path path : paths) {        commaSeparatedPaths.append(sep).append(path.toString());        sep = ",";    }    return commaSeparatedPaths.toString();}
6764e47dd5acdbc427c0bd09acf8234b951e191889854077cd642d6d88ebaf60
reduce
protected void reduce(WritableComparable<?> key, Iterable<VectorWritable> values, Context context) throws IOException, InterruptedException
{    Vector vector = new RandomAccessSparseVector(dimension, 10);    for (VectorWritable value : values) {        vector.assign(value.get(), Functions.PLUS);    }    if (normPower != PartialVectorMerger.NO_NORMALIZING) {        if (logNormalize) {            vector = vector.logNormalize(normPower);        } else {            vector = vector.normalize(normPower);        }    }    if (sequentialAccess) {        vector = new SequentialAccessSparseVector(vector);    }    if (namedVector) {        vector = new NamedVector(vector, key.toString());    }        if (vector.getNumNondefaultElements() > 0) {        VectorWritable vectorWritable = new VectorWritable(vector);        context.write(key, vectorWritable);    }}
6b7dd49be7482fc8ee0fbe8bd0f24522f2a718c8c816a3d7b048fb4688eb6373
setup
protected void setup(Context context) throws IOException, InterruptedException
{    super.setup(context);    Configuration conf = context.getConfiguration();    normPower = conf.getFloat(PartialVectorMerger.NORMALIZATION_POWER, PartialVectorMerger.NO_NORMALIZING);    dimension = conf.getInt(PartialVectorMerger.DIMENSION, Integer.MAX_VALUE);    sequentialAccess = conf.getBoolean(PartialVectorMerger.SEQUENTIAL_ACCESS, false);    namedVector = conf.getBoolean(PartialVectorMerger.NAMED_VECTOR, false);    logNormalize = conf.getBoolean(PartialVectorMerger.LOG_NORMALIZE, false);}
cb54725da841be5474588c9adbfcf57270a8d01b63652eda00df89c8574f97cd
createVectors
public void createVectors(Path input, Path output, VectorizerConfig config) throws IOException, ClassNotFoundException, InterruptedException
{    createTermFrequencyVectors(input, output, config.getTfDirName(), config.getConf(), config.getMinSupport(), config.getMaxNGramSize(), config.getMinLLRValue(), config.getNormPower(), config.isLogNormalize(), config.getNumReducers(), config.getChunkSizeInMegabytes(), config.isSequentialAccess(), config.isNamedVectors());}
06e4705e2f596562edbaa459ce120481b5f6d991ab70be7e5440dad8569ca56f
createTermFrequencyVectors
public static void createTermFrequencyVectors(Path input, Path output, String tfVectorsFolderName, Configuration baseConf, int minSupport, int maxNGramSize, float minLLRValue, float normPower, boolean logNormalize, int numReducers, int chunkSizeInMegabytes, boolean sequentialAccess, boolean namedVectors) throws IOException, InterruptedException, ClassNotFoundException
{    Preconditions.checkArgument(normPower == PartialVectorMerger.NO_NORMALIZING || normPower >= 0, "If specified normPower must be nonnegative", normPower);    Preconditions.checkArgument(normPower == PartialVectorMerger.NO_NORMALIZING || (normPower > 1 && !Double.isInfinite(normPower)) || !logNormalize, "normPower must be > 1 and not infinite if log normalization is chosen", normPower);    if (chunkSizeInMegabytes < MIN_CHUNKSIZE) {        chunkSizeInMegabytes = MIN_CHUNKSIZE;    } else if (chunkSizeInMegabytes > MAX_CHUNKSIZE) {                chunkSizeInMegabytes = MAX_CHUNKSIZE;    }    if (minSupport < 0) {        minSupport = DEFAULT_MIN_SUPPORT;    }    Path dictionaryJobPath = new Path(output, DICTIONARY_JOB_FOLDER);    log.info("Creating dictionary from {} and saving at {}", input, dictionaryJobPath);    int[] maxTermDimension = new int[1];    List<Path> dictionaryChunks;    if (maxNGramSize == 1) {        startWordCounting(input, dictionaryJobPath, baseConf, minSupport);        dictionaryChunks = createDictionaryChunks(dictionaryJobPath, output, baseConf, chunkSizeInMegabytes, maxTermDimension);    } else {        CollocDriver.generateAllGrams(input, dictionaryJobPath, baseConf, maxNGramSize, minSupport, minLLRValue, numReducers);        dictionaryChunks = createDictionaryChunks(new Path(new Path(output, DICTIONARY_JOB_FOLDER), CollocDriver.NGRAM_OUTPUT_DIRECTORY), output, baseConf, chunkSizeInMegabytes, maxTermDimension);    }    int partialVectorIndex = 0;    Collection<Path> partialVectorPaths = Lists.newArrayList();    for (Path dictionaryChunk : dictionaryChunks) {        Path partialVectorOutputPath = new Path(output, VECTOR_OUTPUT_FOLDER + partialVectorIndex++);        partialVectorPaths.add(partialVectorOutputPath);        makePartialVectors(input, baseConf, maxNGramSize, dictionaryChunk, partialVectorOutputPath, maxTermDimension[0], sequentialAccess, namedVectors, numReducers);    }    Configuration conf = new Configuration(baseConf);    Path outputDir = new Path(output, tfVectorsFolderName);    PartialVectorMerger.mergePartialVectors(partialVectorPaths, outputDir, conf, normPower, logNormalize, maxTermDimension[0], sequentialAccess, namedVectors, numReducers);    HadoopUtil.delete(conf, partialVectorPaths);}
cfd4e23c202cabe2e77042e2dbdf62265a6721685ef809cf8e9c59126e224a79
createDictionaryChunks
private static List<Path> createDictionaryChunks(Path wordCountPath, Path dictionaryPathBase, Configuration baseConf, int chunkSizeInMegabytes, int[] maxTermDimension) throws IOException
{    List<Path> chunkPaths = Lists.newArrayList();    Configuration conf = new Configuration(baseConf);    FileSystem fs = FileSystem.get(wordCountPath.toUri(), conf);    long chunkSizeLimit = chunkSizeInMegabytes * 1024L * 1024L;    int chunkIndex = 0;    Path chunkPath = new Path(dictionaryPathBase, DICTIONARY_FILE + chunkIndex);    chunkPaths.add(chunkPath);    SequenceFile.Writer dictWriter = new SequenceFile.Writer(fs, conf, chunkPath, Text.class, IntWritable.class);    try {        long currentChunkSize = 0;        Path filesPattern = new Path(wordCountPath, OUTPUT_FILES_PATTERN);        int i = 0;        for (Pair<Writable, Writable> record : new SequenceFileDirIterable<>(filesPattern, PathType.GLOB, null, null, true, conf)) {            if (currentChunkSize > chunkSizeLimit) {                Closeables.close(dictWriter, false);                chunkIndex++;                chunkPath = new Path(dictionaryPathBase, DICTIONARY_FILE + chunkIndex);                chunkPaths.add(chunkPath);                dictWriter = new SequenceFile.Writer(fs, conf, chunkPath, Text.class, IntWritable.class);                currentChunkSize = 0;            }            Writable key = record.getFirst();            int fieldSize = DICTIONARY_BYTE_OVERHEAD + key.toString().length() * 2 + Integer.SIZE / 8;            currentChunkSize += fieldSize;            dictWriter.append(key, new IntWritable(i++));        }        maxTermDimension[0] = i;    } finally {        Closeables.close(dictWriter, false);    }    return chunkPaths;}
2893e736d6c6a6689ec8ef2dab1f50fae8edbd2316c20cdb50751bec8a87d1e7
makePartialVectors
private static void makePartialVectors(Path input, Configuration baseConf, int maxNGramSize, Path dictionaryFilePath, Path output, int dimension, boolean sequentialAccess, boolean namedVectors, int numReducers) throws IOException, InterruptedException, ClassNotFoundException
{    Configuration conf = new Configuration(baseConf);        conf.set("io.serializations", "org.apache.hadoop.io.serializer.JavaSerialization," + "org.apache.hadoop.io.serializer.WritableSerialization");    conf.setInt(PartialVectorMerger.DIMENSION, dimension);    conf.setBoolean(PartialVectorMerger.SEQUENTIAL_ACCESS, sequentialAccess);    conf.setBoolean(PartialVectorMerger.NAMED_VECTOR, namedVectors);    conf.setInt(MAX_NGRAMS, maxNGramSize);    DistributedCache.addCacheFile(dictionaryFilePath.toUri(), conf);    Job job = new Job(conf);    job.setJobName("DictionaryVectorizer::MakePartialVectors: input-folder: " + input + ", dictionary-file: " + dictionaryFilePath);    job.setJarByClass(DictionaryVectorizer.class);    job.setMapOutputKeyClass(Text.class);    job.setMapOutputValueClass(StringTuple.class);    job.setOutputKeyClass(Text.class);    job.setOutputValueClass(VectorWritable.class);    FileInputFormat.setInputPaths(job, input);    FileOutputFormat.setOutputPath(job, output);    job.setMapperClass(Mapper.class);    job.setInputFormatClass(SequenceFileInputFormat.class);    job.setReducerClass(TFPartialVectorReducer.class);    job.setOutputFormatClass(SequenceFileOutputFormat.class);    job.setNumReduceTasks(numReducers);    HadoopUtil.delete(conf, output);    boolean succeeded = job.waitForCompletion(true);    if (!succeeded) {        throw new IllegalStateException("Job failed!");    }}
c295fc4e2468e3f7ccdb31e92b63b5f90caa56250ed1b1dd25f42e93276acf06
startWordCounting
private static void startWordCounting(Path input, Path output, Configuration baseConf, int minSupport) throws IOException, InterruptedException, ClassNotFoundException
{    Configuration conf = new Configuration(baseConf);        conf.set("io.serializations", "org.apache.hadoop.io.serializer.JavaSerialization," + "org.apache.hadoop.io.serializer.WritableSerialization");    conf.setInt(MIN_SUPPORT, minSupport);    Job job = new Job(conf);    job.setJobName("DictionaryVectorizer::WordCount: input-folder: " + input);    job.setJarByClass(DictionaryVectorizer.class);    job.setOutputKeyClass(Text.class);    job.setOutputValueClass(LongWritable.class);    FileInputFormat.setInputPaths(job, input);    FileOutputFormat.setOutputPath(job, output);    job.setMapperClass(TermCountMapper.class);    job.setInputFormatClass(SequenceFileInputFormat.class);    job.setCombinerClass(TermCountCombiner.class);    job.setReducerClass(TermCountReducer.class);    job.setOutputFormatClass(SequenceFileOutputFormat.class);    HadoopUtil.delete(conf, output);    boolean succeeded = job.waitForCompletion(true);    if (!succeeded) {        throw new IllegalStateException("Job failed!");    }}
aacecb0f01750d985b78d806dc3c134f0da79efe2752957e0f93ecf5cbf9e492
run
public int run(String[] args) throws Exception
{    addInputOption();    addOutputOption();    addOption("tfDirName", "tf", "The folder to store the TF calculations", "tfDirName");    addOption("minSupport", "s", "(Optional) Minimum Support. Default Value: 2", "2");    addOption("maxNGramSize", "ng", "(Optional) The maximum size of ngrams to create" + " (2 = bigrams, 3 = trigrams, etc) Default Value:1");    addOption("minLLR", "ml", "(Optional)The minimum Log Likelihood Ratio(Float)  Default is " + LLRReducer.DEFAULT_MIN_LLR);    addOption("norm", "n", "The norm to use, expressed as either a float or \"INF\" " + "if you want to use the Infinite norm.  " + "Must be greater or equal to 0.  The default is not to normalize");    addOption("logNormalize", "lnorm", "(Optional) Whether output vectors should be logNormalize. " + "If set true else false", "false");    addOption(DefaultOptionCreator.numReducersOption().create());    addOption("chunkSize", "chunk", "The chunkSize in MegaBytes. 100-10000 MB", "100");    addOption(DefaultOptionCreator.methodOption().create());    addOption("namedVector", "nv", "(Optional) Whether output vectors should be NamedVectors. " + "If set true else false", "false");    if (parseArguments(args) == null) {        return -1;    }    String tfDirName = getOption("tfDirName", "tfDir");    int minSupport = getInt("minSupport", 2);    int maxNGramSize = getInt("maxNGramSize", 1);    float minLLRValue = getFloat("minLLR", LLRReducer.DEFAULT_MIN_LLR);    float normPower = getFloat("norm", PartialVectorMerger.NO_NORMALIZING);    boolean logNormalize = hasOption("logNormalize");    int numReducers = getInt(DefaultOptionCreator.MAX_REDUCERS_OPTION);    int chunkSizeInMegs = getInt("chunkSize", 100);    boolean sequential = hasOption("sequential");    boolean namedVecs = hasOption("namedVectors");        createTermFrequencyVectors(getInputPath(), getOutputPath(), tfDirName, getConf(), minSupport, maxNGramSize, minLLRValue, normPower, logNormalize, numReducers, chunkSizeInMegs, sequential, namedVecs);    return 0;}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    ToolRunner.run(new DictionaryVectorizer(), args);}
968f41a6f11b26ed79ba77c2271e3152f4cd3a22a7a841beeb74b66dcb12263e
map
protected void map(Text key, Text value, Context context) throws IOException, InterruptedException
{    TokenStream stream = analyzer.tokenStream(key.toString(), new StringReader(value.toString()));    CharTermAttribute termAtt = stream.addAttribute(CharTermAttribute.class);    stream.reset();    StringTuple document = new StringTuple();    while (stream.incrementToken()) {        if (termAtt.length() > 0) {            document.add(new String(termAtt.buffer(), 0, termAtt.length()));        }    }    stream.end();    Closeables.close(stream, true);    context.write(key, document);}
6b7dd49be7482fc8ee0fbe8bd0f24522f2a718c8c816a3d7b048fb4688eb6373
setup
protected void setup(Context context) throws IOException, InterruptedException
{    super.setup(context);    String analyzerClassName = context.getConfiguration().get(DocumentProcessor.ANALYZER_CLASS, StandardAnalyzer.class.getName());    try {        analyzer = AnalyzerUtils.createAnalyzer(analyzerClassName);    } catch (ClassNotFoundException e) {        throw new IOException("Unable to create analyzer: " + analyzerClassName, e);    }}
19e3bac212d2de2490a40d44f3dee3a5efb3e017a4f6049587d7eaee1402bc29
tokenizeDocuments
public static void tokenizeDocuments(Path input, Class<? extends Analyzer> analyzerClass, Path output, Configuration baseConf) throws IOException, InterruptedException, ClassNotFoundException
{    Configuration conf = new Configuration(baseConf);        conf.set("io.serializations", "org.apache.hadoop.io.serializer.JavaSerialization," + "org.apache.hadoop.io.serializer.WritableSerialization");    conf.set(ANALYZER_CLASS, analyzerClass.getName());    Job job = new Job(conf);    job.setJobName("DocumentProcessor::DocumentTokenizer: input-folder: " + input);    job.setJarByClass(DocumentProcessor.class);    job.setOutputKeyClass(Text.class);    job.setOutputValueClass(StringTuple.class);    FileInputFormat.setInputPaths(job, input);    FileOutputFormat.setOutputPath(job, output);    job.setMapperClass(SequenceFileTokenizerMapper.class);    job.setInputFormatClass(SequenceFileInputFormat.class);    job.setNumReduceTasks(0);    job.setOutputFormatClass(SequenceFileOutputFormat.class);    HadoopUtil.delete(conf, output);    boolean succeeded = job.waitForCompletion(true);    if (!succeeded) {        throw new IllegalStateException("Job failed!");    }}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    ToolRunner.run(new Configuration(), new EncodedVectorsFromSequenceFiles(), args);}
aacecb0f01750d985b78d806dc3c134f0da79efe2752957e0f93ecf5cbf9e492
run
public int run(String[] args) throws Exception
{    addInputOption();    addOutputOption();    addOption(DefaultOptionCreator.analyzerOption().create());    addOption(buildOption("sequentialAccessVector", "seq", "(Optional) Whether output vectors should be SequentialAccessVectors. " + "If set true else false", false, false, null));    addOption(buildOption("namedVector", "nv", "Create named vectors using the key.  False by default", false, false, null));    addOption("cardinality", "c", "The cardinality to use for creating the vectors.  Default is 5000", "5000");    addOption("encoderFieldName", "en", "The name of the encoder to be passed to the FeatureVectorEncoder constructor. Default is text. " + "Note this is not the class name of a FeatureValueEncoder, but is instead the construction " + "argument.", "text");    addOption("encoderClass", "ec", "The class name of the encoder to be used. Default is " + LuceneTextValueEncoder.class.getName(), LuceneTextValueEncoder.class.getName());    addOption(DefaultOptionCreator.overwriteOption().create());    if (parseArguments(args) == null) {        return -1;    }    Path input = getInputPath();    Path output = getOutputPath();    if (hasOption(DefaultOptionCreator.OVERWRITE_OPTION)) {        HadoopUtil.delete(getConf(), output);    }    Class<? extends Analyzer> analyzerClass = getAnalyzerClassFromOption();    Configuration conf = getConf();    boolean sequentialAccessOutput = hasOption("sequentialAccessVector");    boolean namedVectors = hasOption("namedVector");    int cardinality = 5000;    if (hasOption("cardinality")) {        cardinality = Integer.parseInt(getOption("cardinality"));    }    String encoderName = "text";    if (hasOption("encoderFieldName")) {        encoderName = getOption("encoderFieldName");    }    String encoderClass = LuceneTextValueEncoder.class.getName();    if (hasOption("encoderClass")) {        encoderClass = getOption("encoderClass");        ClassUtils.instantiateAs(encoderClass, FeatureVectorEncoder.class, new Class[] { String.class },         new Object[] { encoderName });    }    SimpleTextEncodingVectorizer vectorizer = new SimpleTextEncodingVectorizer();    VectorizerConfig config = new VectorizerConfig(conf, analyzerClass.getName(), encoderClass, encoderName, sequentialAccessOutput, namedVectors, cardinality);    vectorizer.createVectors(input, output, config);    return 0;}
f59137ef6d75b45f58b596ccb049f79d5930ea4438c359346600a1075281c2ab
addToVector
public void addToVector(String originalForm, double weight, Vector data)
{    dictionary.add(originalForm);    super.addToVector(originalForm, weight, data);}
ecacfd22d0f2dde9e2b2a055817c06a5311e4b9ee3f06c3dcee9ce3677956418
getWeight
protected double getWeight(byte[] originalForm, double w)
{    return w * weight(originalForm);}
0370f0b6782501e90f3433e41ce5be0e6761c5897e1b887cea53a50e3e670751
weight
protected double weight(byte[] originalForm)
{                double thisWord = dictionary.count(new String(originalForm, Charsets.UTF_8)) + 0.5;    double allWords = dictionary.size() + dictionary.elementSet().size() * 0.5 + 0.5;    return -Math.log(thisWord / allWords);}
deba04f4277764ecaed408aba8da53347a2421514082cbc9994ecb761ed2060e
getDictionary
public Multiset<String> getDictionary()
{    return dictionary;}
7f1023f60d8b8410cfccc07c16eb271c40d004a94d022f566b11d75f6cac59d8
initCaches
private void initCaches()
{    this.caches = new OpenIntIntHashMap[getProbes()];    for (int probe = 0; probe < getProbes(); probe++) {        caches[probe] = new OpenIntIntHashMap();    }}
78e3a049dd98d7bdab0549c860daac1e4832078afaf1eb817bcf0c9b772fc4f2
getCaches
 OpenIntIntHashMap[] getCaches()
{    return caches;}
0d0ea84baac534c015bf7fd15e165de6835b2cb060d40a6f9e4796e620a553e3
setProbes
public void setProbes(int probes)
{    super.setProbes(probes);    initCaches();}
dbf1f2c75937c4d76dbcc69fe5421973b3e851315be04d967e3a274d328bc2f6
hashForProbe
protected int hashForProbe(byte[] originalForm, int dataSize, String name, int probe)
{    Preconditions.checkArgument(dataSize == this.dataSize, "dataSize argument [" + dataSize + "] does not match expected dataSize [" + this.dataSize + ']');    int originalHashcode = Arrays.hashCode(originalForm);    if (caches[probe].containsKey(originalHashcode)) {        return caches[probe].get(originalHashcode);    }    int hash = super.hashForProbe(originalForm, dataSize, name, probe);    caches[probe].put(originalHashcode, hash);    return hash;}
7f1023f60d8b8410cfccc07c16eb271c40d004a94d022f566b11d75f6cac59d8
initCaches
private void initCaches()
{    caches = new OpenIntIntHashMap[getProbes()];    for (int probe = 0; probe < getProbes(); probe++) {        caches[probe] = new OpenIntIntHashMap();    }}
78e3a049dd98d7bdab0549c860daac1e4832078afaf1eb817bcf0c9b772fc4f2
getCaches
 OpenIntIntHashMap[] getCaches()
{    return caches;}
0d0ea84baac534c015bf7fd15e165de6835b2cb060d40a6f9e4796e620a553e3
setProbes
public void setProbes(int probes)
{    super.setProbes(probes);    initCaches();}
dbf1f2c75937c4d76dbcc69fe5421973b3e851315be04d967e3a274d328bc2f6
hashForProbe
protected int hashForProbe(byte[] originalForm, int dataSize, String name, int probe)
{    Preconditions.checkArgument(dataSize == this.dataSize, "dataSize argument [" + dataSize + "] does not match expected dataSize [" + this.dataSize + ']');    int originalHashcode = Arrays.hashCode(originalForm);    if (caches[probe].containsKey(originalHashcode)) {        return caches[probe].get(originalHashcode);    }    int hash = super.hashForProbe(originalForm, dataSize, name, probe);    caches[probe].put(originalHashcode, hash);    return hash;}
0d0ea84baac534c015bf7fd15e165de6835b2cb060d40a6f9e4796e620a553e3
setProbes
public void setProbes(int probes)
{    super.setProbes(probes);    cacheProbeLocations(getSeed());}
1eb868d59360e7cc0c393d94081b0c13f9912f1eaeb974dd9ceec8625c3b6eb6
cacheProbeLocations
private void cacheProbeLocations(int seed)
{    cachedProbes = new int[getProbes()];    for (int i = 0; i < getProbes(); i++) {                cachedProbes[i] = (int) MurmurHash.hash64A(bytesForString(getName()), seed + i);    }}
dbf1f2c75937c4d76dbcc69fe5421973b3e851315be04d967e3a274d328bc2f6
hashForProbe
protected int hashForProbe(byte[] originalForm, int dataSize, String name, int probe)
{    int h = cachedProbes[probe] % dataSize;    if (h < 0) {        h += dataSize;    }    return h;}
81d121b87c747c56f7dd90f4ad0d74201af7ea00ee72e2a2655f6613e3b2a012
addToVector
public void addToVector(byte[] originalForm, double weight, Vector data)
{    int probes = getProbes();    String name = getName();    for (int i = 0; i < probes; i++) {        int n = hashForProbe(originalForm, data.size(), name, i);        if (isTraceEnabled()) {            trace((String) null, n);        }        data.set(n, data.get(n) + getWeight(originalForm, weight));    }}
ecacfd22d0f2dde9e2b2a055817c06a5311e4b9ee3f06c3dcee9ce3677956418
getWeight
protected double getWeight(byte[] originalForm, double w)
{    return w;}
604500f2e3c2fe4134aa23a1104c632fe936c1f814a2b53b9c6698d1a1ee06ee
asString
public String asString(String originalForm)
{    return getName();}
af1dedd3944f498e0f3882cf043ebdae47ec9afb841baccf490fd0222dfdbf45
getSeed
protected int getSeed()
{    return 0;}
81d121b87c747c56f7dd90f4ad0d74201af7ea00ee72e2a2655f6613e3b2a012
addToVector
public void addToVector(byte[] originalForm, double weight, Vector data)
{    int probes = getProbes();    String name = getName();    for (int i = 0; i < probes; i++) {        int n = hashForProbe(originalForm, data.size(), name, i);        if (isTraceEnabled()) {            trace((String) null, n);        }        data.set(n, data.get(n) + getWeight(originalForm, weight));    }}
ecacfd22d0f2dde9e2b2a055817c06a5311e4b9ee3f06c3dcee9ce3677956418
getWeight
protected double getWeight(byte[] originalForm, double w)
{    if (originalForm == null) {        return w;    }    return w * Double.parseDouble(new String(originalForm, Charsets.UTF_8));}
604500f2e3c2fe4134aa23a1104c632fe936c1f814a2b53b9c6698d1a1ee06ee
asString
public String asString(String originalForm)
{    return getName() + ':' + originalForm;}
af1dedd3944f498e0f3882cf043ebdae47ec9afb841baccf490fd0222dfdbf45
getSeed
protected int getSeed()
{    return CONTINUOUS_VALUE_HASH_SEED;}
768b37668be648a9ddc09f742bcfe8a57bce732c2eb9a368c0270326117fb28e
intern
public int intern(String s)
{    if (!dict.containsKey(s)) {        dict.put(s, dict.size());    }    return dict.get(s);}
456cdef142ab212b3aedb5847ad35e3f24716e52d3c5dbe501798302542da515
values
public List<String> values()
{        return new ArrayList<>(dict.keySet());}
72ef1e59027007ffe0950edfd2670ad03bb65cd6463d5d1d282dfeb1750435b0
size
public int size()
{    return dict.size();}
f625c30ed993b0eaa3b027aaef777a123ac29953aebb9bc273705c26ca43949a
fromList
public static Dictionary fromList(Iterable<String> values)
{    Dictionary dict = new Dictionary();    for (String value : values) {        dict.intern(value);    }    return dict;}
1b1b920dc21a41bab96f617edcc4bb648d70951369a796806f363919973b01be
addToVector
public void addToVector(String originalForm, Vector data)
{    addToVector(originalForm, 1.0, data);}
92b122d7f79026f7abdec9f9f58008ce13db0cb8b6133df05f12699e095a5437
addToVector
public void addToVector(byte[] originalForm, Vector data)
{    addToVector(originalForm, 1.0, data);}
f59137ef6d75b45f58b596ccb049f79d5930ea4438c359346600a1075281c2ab
addToVector
public void addToVector(String originalForm, double weight, Vector data)
{    addToVector(bytesForString(originalForm), weight, data);}
b2537dc65aa05eff3c6e85eef9468395fdef368d3bb4d6754e599fc930fe1c74
hashesForProbe
protected Iterable<Integer> hashesForProbe(byte[] originalForm, int dataSize, String name, int probe)
{    return Collections.singletonList(hashForProbe(originalForm, dataSize, name, probe));}
ecacfd22d0f2dde9e2b2a055817c06a5311e4b9ee3f06c3dcee9ce3677956418
getWeight
protected double getWeight(byte[] originalForm, double w)
{    return 1.0;}
091bb94ccc2d2c7c6bada07419b7cd5ed00d319a575dad3186caa87f9d96cd53
hash
protected int hash(String term, int probe, int numFeatures)
{    long r = MurmurHash.hash64A(bytesForString(term), probe) % numFeatures;    if (r < 0) {        r += numFeatures;    }    return (int) r;}
1df588420cf00c7cb1c32a0ed5e519fa604615b5202c53e35e6fa09dee6b4b94
hash
protected static int hash(byte[] term, int probe, int numFeatures)
{    long r = MurmurHash.hash64A(term, probe) % numFeatures;    if (r < 0) {        r += numFeatures;    }    return (int) r;}
3939f9e06fd6a0a4e5ccf6d69d5f0d4c858f208ffc84545a25f82b35a7f4dbd9
hash
protected static int hash(String term1, String term2, int probe, int numFeatures)
{    long r = MurmurHash.hash64A(bytesForString(term1), probe);    r = MurmurHash.hash64A(bytesForString(term2), (int) r) % numFeatures;    if (r < 0) {        r += numFeatures;    }    return (int) r;}
098fd5c8da18a9f37cb944715565227c844f73bc3afc5145a7b2ed7781ecefa4
hash
protected int hash(byte[] term1, byte[] term2, int probe, int numFeatures)
{    long r = MurmurHash.hash64A(term1, probe);    r = MurmurHash.hash64A(term2, (int) r) % numFeatures;    if (r < 0) {        r += numFeatures;    }    return (int) r;}
0701ece4632e0eb69e904b3d56281c2cf73431678d97527356df0bd130cba171
hash
protected int hash(String term1, String term2, String term3, String term4, int probe, int numFeatures)
{    long r = MurmurHash.hash64A(bytesForString(term1), probe);    r = MurmurHash.hash64A(bytesForString(term2), (int) r) % numFeatures;    r = MurmurHash.hash64A(bytesForString(term3), (int) r) % numFeatures;    r = MurmurHash.hash64A(bytesForString(term4), (int) r) % numFeatures;    if (r < 0) {        r += numFeatures;    }    return (int) r;}
96766e38ab5a5c4c98b1e4696afdc53a43647e1d1694761c14d12ae7bdd1124e
getProbes
public int getProbes()
{    return probes;}
0d0ea84baac534c015bf7fd15e165de6835b2cb060d40a6f9e4796e620a553e3
setProbes
public void setProbes(int probes)
{    this.probes = probes;}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return name;}
6dd4df54619e736df1eadf7ca7dce05dc56743659884d194f980733799a83362
isTraceEnabled
protected boolean isTraceEnabled()
{    return traceDictionary != null;}
edf5bf6da5d5aacfb21803ccc70325d07022b6da22c877447c6b8f47a357ecd2
trace
protected void trace(String subName, int n)
{    if (traceDictionary != null) {        String key = name;        if (subName != null) {            key = name + '=' + subName;        }        Set<Integer> trace = traceDictionary.get(key);        if (trace == null) {            trace = Sets.newHashSet(n);            traceDictionary.put(key, trace);        } else {            trace.add(n);        }    }}
c4eb8950721d2b5b59952b68702e804206bbe89b068527e70832bbcbd4f68a63
trace
protected void trace(byte[] subName, int n)
{    trace(new String(subName, Charsets.UTF_8), n);}
1ef475e34c52a97c0f51b976d5294585a8aea03d72cd401bca5a70696472502e
setTraceDictionary
public void setTraceDictionary(Map<String, Set<Integer>> traceDictionary)
{    this.traceDictionary = traceDictionary;}
1070c0c464274d917df67c551cfede59123c6ab3c82287b8312617c1c2133ff3
bytesForString
protected static byte[] bytesForString(String x)
{    return x == null ? EMPTY_ARRAY : x.getBytes(Charsets.UTF_8);}
ea215918d41cb38e1a50e941144b3a16d526813f9b9152fdcbcebd18b67fec27
addToVector
public void addToVector(String originalForm, double w, Vector data)
{    throw new UnsupportedOperationException("addToVector is not supported for InteractionVectorEncoder");}
d83e3ad6f452b46f85f31a2375434c8ee2b8f4a6b1601284df4bb7ddc6fde5f4
addToVector
public void addToVector(byte[] originalForm, double w, Vector data)
{    throw new UnsupportedOperationException("addToVector is not supported for InteractionVectorEncoder");}
99670edcd09bea20ad09a674499d7ea76de037fd22c645f0b81b18521a142354
addInteractionToVector
public void addInteractionToVector(String original1, String original2, double weight, Vector data)
{    byte[] originalForm1 = bytesForString(original1);    byte[] originalForm2 = bytesForString(original2);    addInteractionToVector(originalForm1, originalForm2, weight, data);}
0bf44419eb3b4debaa04192d3b0a8b4d881ca6e3ea4394535d269ff77e6f5642
addInteractionToVector
public void addInteractionToVector(byte[] originalForm1, byte[] originalForm2, double weight, Vector data)
{    String name = getName();    double w = getWeight(originalForm1, originalForm2, weight);    for (int i = 0; i < probes(); i++) {        Iterable<Integer> jValues = secondEncoder.hashesForProbe(originalForm2, data.size(), name, i % secondEncoder.getProbes());        for (Integer k : firstEncoder.hashesForProbe(originalForm1, data.size(), name, i % firstEncoder.getProbes())) {            for (Integer j : jValues) {                int n = (k + j) % data.size();                if (isTraceEnabled()) {                    trace(String.format("%s:%s", new String(originalForm1, Charsets.UTF_8), new String(originalForm2, Charsets.UTF_8)), n);                }                data.set(n, data.get(n) + w);            }        }    }}
9bb17ae9f55bb9c2ba94166741cc0909dcfde740d99b27c7ac664ecac720d6f8
probes
private int probes()
{    return getProbes();}
76346ca25ed1a04ab74f1d4291462783b2be2e203d2d23dac46ba765eea7357e
getWeight
protected double getWeight(byte[] originalForm1, byte[] originalForm2, double w)
{    return firstEncoder.getWeight(originalForm1, 1.0) * secondEncoder.getWeight(originalForm2, 1.0) * w;}
604500f2e3c2fe4134aa23a1104c632fe936c1f814a2b53b9c6698d1a1ee06ee
asString
public String asString(String originalForm)
{    return String.format(Locale.ENGLISH, "%s:%s", getName(), originalForm);}
dbf1f2c75937c4d76dbcc69fe5421973b3e851315be04d967e3a274d328bc2f6
hashForProbe
protected int hashForProbe(byte[] originalForm, int dataSize, String name, int probe)
{    return hash(name, probe, dataSize);}
717b6c6a15d53f7c9a82b536a500dec328e695333a025e42a39bfe3414d2e7a7
setAnalyzer
public void setAnalyzer(Analyzer analyzer)
{    this.analyzer = analyzer;}
3c75a89afa048cd66e38c476c422ef107c92b81a4eae2ef278a7fc562b22b545
tokenize
protected Iterable<String> tokenize(CharSequence originalForm)
{    TokenStream ts = analyzer.tokenStream(getName(), new CharSequenceReader(originalForm));    ts.addAttribute(CharTermAttribute.class);    return new LuceneTokenIterable(ts, false);}
63721c99b6a88d1dc3720069102eedba9d659211edf859ce35059f778e8d58f1
read
public int read(char[] cbuf, int off, int len)
{    int toRead = Math.min(len, buf.remaining());    if (toRead > 0) {        buf.get(cbuf, off, toRead);        return toRead;    } else {        return -1;    }}
5df6118bc0e745d8b18e0a6a99b2e3f2ddba8140cbeb1423ce2df50a9f140574
close
public void close()
{}
37c103bb84952e055d3c90aa17374e9c534adb331cfa33135047f91399a5d006
iterator
public Iterator<String> iterator()
{    if (firstTime) {        firstTime = false;    } else {        try {            tokenStream.reset();        } catch (IOException e) {            throw new IllegalStateException("This token stream can't be reset");        }    }    return new TokenStreamIterator(tokenStream);}
dbf1f2c75937c4d76dbcc69fe5421973b3e851315be04d967e3a274d328bc2f6
hashForProbe
protected int hashForProbe(byte[] originalForm, int dataSize, String name, int probe)
{    return hash(nameBytes, originalForm, WORD_LIKE_VALUE_HASH_SEED + probe, dataSize);}
2cdf8624bbbf93461ddb996d588ed8b51aee802f52eb72d84e371e2dca864144
setDictionary
public void setDictionary(Map<String, Double> dictionary)
{    this.dictionary = dictionary;    setMissingValueWeight(Collections.min(dictionary.values()) / 2);}
22f58460618fae8d4fdf10b240f2588dd31a71de95623111aff87a7d4070dff3
setMissingValueWeight
public void setMissingValueWeight(double missingValueWeight)
{    this.missingValueWeight = missingValueWeight;}
0370f0b6782501e90f3433e41ce5be0e6761c5897e1b887cea53a50e3e670751
weight
protected double weight(byte[] originalForm)
{    double weight = missingValueWeight;    if (dictionary != null) {        String s = new String(originalForm, Charsets.UTF_8);        if (dictionary.containsKey(s)) {            weight = dictionary.get(s);        }    }    return weight;}
81d121b87c747c56f7dd90f4ad0d74201af7ea00ee72e2a2655f6613e3b2a012
addToVector
public void addToVector(byte[] originalForm, double weight, Vector data)
{    addText(originalForm);    flush(weight, data);}
0ffa0fb1d5fb1637a37e111776df939c2949c64d59b0711294c4972a3ffa99eb
addText
public void addText(byte[] originalForm)
{    addText(new String(originalForm, Charsets.UTF_8));}
51569bb96ad82a73bf84405831010afb8f79534a0534f6e663df3145c9211421
addText
public void addText(CharSequence text)
{    for (String word : tokenize(text)) {        counts.add(word);    }}
25067b215ff3863bf929e4fd6f13f2f78da7d9d9cfd78696f8852696a9b0b859
flush
public void flush(double weight, Vector data)
{    for (String word : counts.elementSet()) {                wordEncoder.addToVector(word, weight * Math.log1p(counts.count(word)) / LOG_2, data);    }    counts.clear();}
dbf1f2c75937c4d76dbcc69fe5421973b3e851315be04d967e3a274d328bc2f6
hashForProbe
protected int hashForProbe(byte[] originalForm, int dataSize, String name, int probe)
{    return 0;}
b2537dc65aa05eff3c6e85eef9468395fdef368d3bb4d6754e599fc930fe1c74
hashesForProbe
protected Iterable<Integer> hashesForProbe(byte[] originalForm, int dataSize, String name, int probe)
{    Collection<Integer> hashes = Lists.newArrayList();    for (String word : tokenize(new String(originalForm, Charsets.UTF_8))) {        hashes.add(hashForProbe(bytesForString(word), dataSize, name, probe));    }    return hashes;}
3c75a89afa048cd66e38c476c422ef107c92b81a4eae2ef278a7fc562b22b545
tokenize
protected Iterable<String> tokenize(CharSequence originalForm)
{    return ON_NON_WORD.split(originalForm);}
604500f2e3c2fe4134aa23a1104c632fe936c1f814a2b53b9c6698d1a1ee06ee
asString
public String asString(String originalForm)
{    StringBuilder r = new StringBuilder();    r.append('[');    for (String word : tokenize(originalForm)) {        if (r.length() > 1) {            r.append(", ");        }        r.append(wordEncoder.asString(word));    }    r.append(']');    return r.toString();}
b383b6edcaef92502ee8d228fa925ef31cb4c46cb1738a9a14ce133f1772e57c
setWordEncoder
public final void setWordEncoder(FeatureVectorEncoder wordEncoder)
{    this.wordEncoder = wordEncoder;}
d83e3ad6f452b46f85f31a2375434c8ee2b8f4a6b1601284df4bb7ddc6fde5f4
addToVector
public void addToVector(byte[] originalForm, double w, Vector data)
{    int probes = getProbes();    String name = getName();    double weight = getWeight(originalForm, w);    for (int i = 0; i < probes; i++) {        int n = hashForProbe(originalForm, data.size(), name, i);        if (isTraceEnabled()) {            trace(originalForm, n);        }        data.set(n, data.get(n) + weight);    }}
ecacfd22d0f2dde9e2b2a055817c06a5311e4b9ee3f06c3dcee9ce3677956418
getWeight
protected double getWeight(byte[] originalForm, double w)
{    return w * weight(originalForm);}
dbf1f2c75937c4d76dbcc69fe5421973b3e851315be04d967e3a274d328bc2f6
hashForProbe
protected int hashForProbe(byte[] originalForm, int dataSize, String name, int probe)
{    return hash(nameBytes, originalForm, WORD_LIKE_VALUE_HASH_SEED + probe, dataSize);}
604500f2e3c2fe4134aa23a1104c632fe936c1f814a2b53b9c6698d1a1ee06ee
asString
public String asString(String originalForm)
{    return String.format(Locale.ENGLISH, "%s:%s:%.4f", getName(), originalForm, weight(bytesForString(originalForm)));}
6b7dd49be7482fc8ee0fbe8bd0f24522f2a718c8c816a3d7b048fb4688eb6373
setup
protected void setup(Context context) throws IOException, InterruptedException
{    Configuration conf = context.getConfiguration();    sequentialVectors = conf.getBoolean(USE_SEQUENTIAL, false);    namedVectors = conf.getBoolean(USE_NAMED_VECTORS, false);    String analyzerName = conf.get(ANALYZER_NAME, StandardAnalyzer.class.getName());    Analyzer analyzer;    try {        analyzer = AnalyzerUtils.createAnalyzer(analyzerName);    } catch (ClassNotFoundException e) {                throw new IOException("Unable to create Analyzer for name: " + analyzerName, e);    }    String encoderName = conf.get(ENCODER_FIELD_NAME, "text");    cardinality = conf.getInt(CARDINALITY, 5000);    String encClass = conf.get(ENCODER_CLASS);    encoder = ClassUtils.instantiateAs(encClass, FeatureVectorEncoder.class, new Class[] { String.class }, new Object[] { encoderName });    if (encoder instanceof LuceneTextValueEncoder) {        ((LuceneTextValueEncoder) encoder).setAnalyzer(analyzer);    }}
968f41a6f11b26ed79ba77c2271e3152f4cd3a22a7a841beeb74b66dcb12263e
map
protected void map(Text key, Text value, Context context) throws IOException, InterruptedException
{    Vector vector;    if (sequentialVectors) {        vector = new SequentialAccessSparseVector(cardinality);    } else {        vector = new RandomAccessSparseVector(cardinality);    }    if (namedVectors) {        vector = new NamedVector(vector, key.toString());    }    encoder.addToVector(value.toString(), vector);    context.write(new Text(key.toString()), new VectorWritable(vector));}
86a4a5975165e4faf2b3671c31c2bb77a2abfa4e7ce45fcf610bf2fb56de40f4
pruneVectors
public static void pruneVectors(Path tfDir, Path prunedTFDir, Path prunedPartialTFDir, long maxDF, long minDF, Configuration baseConf, Pair<Long[], List<Path>> docFrequenciesFeatures, float normPower, boolean logNormalize, int numReducers) throws IOException, InterruptedException, ClassNotFoundException
{    int partialVectorIndex = 0;    List<Path> partialVectorPaths = new ArrayList<>();    for (Path path : docFrequenciesFeatures.getSecond()) {        Path partialVectorOutputPath = new Path(prunedPartialTFDir, "partial-" + partialVectorIndex++);        partialVectorPaths.add(partialVectorOutputPath);        pruneVectorsPartial(tfDir, partialVectorOutputPath, path, maxDF, minDF, baseConf);    }    mergePartialVectors(partialVectorPaths, prunedTFDir, baseConf, normPower, logNormalize, numReducers);    HadoopUtil.delete(new Configuration(baseConf), prunedPartialTFDir);}
afd7725611f99dbf3255c5df80641d8f32dd294178fe2f7fcc84e35f205e890b
pruneVectorsPartial
private static void pruneVectorsPartial(Path input, Path output, Path dictionaryFilePath, long maxDF, long minDF, Configuration baseConf) throws IOException, InterruptedException, ClassNotFoundException
{    Configuration conf = new Configuration(baseConf);            conf.set("io.serializations", "org.apache.hadoop.io.serializer.JavaSerialization," + "org.apache.hadoop.io.serializer.WritableSerialization");    conf.setLong(MAX_DF, maxDF);    conf.setLong(MIN_DF, minDF);    DistributedCache.addCacheFile(dictionaryFilePath.toUri(), conf);    Job job = HadoopUtil.prepareJob(input, output, SequenceFileInputFormat.class, Mapper.class, null, null, WordsPrunerReducer.class, Text.class, VectorWritable.class, SequenceFileOutputFormat.class, conf);    job.setJobName(": Prune Vectors: input-folder: " + input + ", dictionary-file: " + dictionaryFilePath.toString());    HadoopUtil.delete(conf, output);    boolean succeeded = job.waitForCompletion(true);    if (!succeeded) {        throw new IllegalStateException("Job failed!");    }}
6d7304ca48bba1269738e4f313877b6effda958dbcec5c3e7a685663d1896d9d
mergePartialVectors
public static void mergePartialVectors(Iterable<Path> partialVectorPaths, Path output, Configuration baseConf, float normPower, boolean logNormalize, int numReducers) throws IOException, InterruptedException, ClassNotFoundException
{    Configuration conf = new Configuration(baseConf);        conf.set("io.serializations", "org.apache.hadoop.io.serializer.JavaSerialization," + "org.apache.hadoop.io.serializer.WritableSerialization");    conf.setFloat(PartialVectorMerger.NORMALIZATION_POWER, normPower);    conf.setBoolean(PartialVectorMerger.LOG_NORMALIZE, logNormalize);    Job job = new Job(conf);    job.setJobName("PrunerPartialVectorMerger::MergePartialVectors");    job.setJarByClass(PartialVectorMerger.class);    job.setOutputKeyClass(Text.class);    job.setOutputValueClass(VectorWritable.class);    FileInputFormat.setInputPaths(job, getCommaSeparatedPaths(partialVectorPaths));    FileOutputFormat.setOutputPath(job, output);    job.setMapperClass(Mapper.class);    job.setInputFormatClass(SequenceFileInputFormat.class);    job.setReducerClass(PrunedPartialVectorMergeReducer.class);    job.setOutputFormatClass(SequenceFileOutputFormat.class);    job.setNumReduceTasks(numReducers);    HadoopUtil.delete(conf, output);    boolean succeeded = job.waitForCompletion(true);    if (!succeeded) {        throw new IllegalStateException("Job failed!");    }}
93c8d5b361135e5c25dbea2893000b2051cd4387648eac6264ca5ca32aeb4f0f
getCommaSeparatedPaths
private static String getCommaSeparatedPaths(Iterable<Path> paths)
{    StringBuilder commaSeparatedPaths = new StringBuilder(100);    String sep = "";    for (Path path : paths) {        commaSeparatedPaths.append(sep).append(path.toString());        sep = ",";    }    return commaSeparatedPaths.toString();}
6764e47dd5acdbc427c0bd09acf8234b951e191889854077cd642d6d88ebaf60
reduce
protected void reduce(WritableComparable<?> key, Iterable<VectorWritable> values, Context context) throws IOException, InterruptedException
{    Vector vector = null;    for (VectorWritable value : values) {        if (vector == null) {            vector = value.get().clone();            continue;        }                vector.assign(value.get(), Functions.PLUS);    }    if (vector != null && normPower != PartialVectorMerger.NO_NORMALIZING) {        vector = logNormalize ? vector.logNormalize(normPower) : vector.normalize(normPower);    }    VectorWritable vectorWritable = new VectorWritable(vector);    context.write(key, vectorWritable);}
6b7dd49be7482fc8ee0fbe8bd0f24522f2a718c8c816a3d7b048fb4688eb6373
setup
protected void setup(Context context) throws IOException, InterruptedException
{    super.setup(context);    Configuration conf = context.getConfiguration();    normPower = conf.getFloat(PartialVectorMerger.NORMALIZATION_POWER, PartialVectorMerger.NO_NORMALIZING);    logNormalize = conf.getBoolean(PartialVectorMerger.LOG_NORMALIZE, false);}
6764e47dd5acdbc427c0bd09acf8234b951e191889854077cd642d6d88ebaf60
reduce
protected void reduce(WritableComparable<?> key, Iterable<VectorWritable> values, Context context) throws IOException, InterruptedException
{    Iterator<VectorWritable> it = values.iterator();    if (!it.hasNext()) {        return;    }    Vector value = it.next().get();    Vector vector = value.clone();    if (maxDf != Long.MAX_VALUE || minDf > -1) {        for (Vector.Element e : value.nonZeroes()) {            if (!dictionary.containsKey(e.index())) {                vector.setQuick(e.index(), 0.0);                continue;            }            long df = dictionary.get(e.index());            if (df > maxDf || df < minDf) {                vector.setQuick(e.index(), 0.0);            }        }    }    VectorWritable vectorWritable = new VectorWritable(vector);    context.write(key, vectorWritable);}
6b7dd49be7482fc8ee0fbe8bd0f24522f2a718c8c816a3d7b048fb4688eb6373
setup
protected void setup(Context context) throws IOException, InterruptedException
{    super.setup(context);    Configuration conf = context.getConfiguration();        maxDf = conf.getLong(HighDFWordsPruner.MAX_DF, Long.MAX_VALUE);    minDf = conf.getLong(HighDFWordsPruner.MIN_DF, -1);    Path dictionaryFile = HadoopUtil.getSingleCachedFile(conf);        for (Pair<IntWritable, LongWritable> record : new SequenceFileIterable<IntWritable, LongWritable>(dictionaryFile, true, conf)) {        dictionary.put(record.getFirst().get(), record.getSecond().get());    }}
cb54725da841be5474588c9adbfcf57270a8d01b63652eda00df89c8574f97cd
createVectors
public void createVectors(Path input, Path output, VectorizerConfig config) throws IOException, ClassNotFoundException, InterruptedException
{        Job job = HadoopUtil.prepareJob(input, output, SequenceFileInputFormat.class, EncodingMapper.class, Text.class, VectorWritable.class, SequenceFileOutputFormat.class, config.getConf());    Configuration conf = job.getConfiguration();    conf.set(EncodingMapper.USE_SEQUENTIAL, String.valueOf(config.isSequentialAccess()));    conf.set(EncodingMapper.USE_NAMED_VECTORS, String.valueOf(config.isNamedVectors()));    conf.set(EncodingMapper.ANALYZER_NAME, config.getAnalyzerClassName());    conf.set(EncodingMapper.ENCODER_FIELD_NAME, config.getEncoderName());    conf.set(EncodingMapper.ENCODER_CLASS, config.getEncoderClass());    conf.set(EncodingMapper.CARDINALITY, String.valueOf(config.getCardinality()));    job.setNumReduceTasks(0);    boolean finished = job.waitForCompletion(true);    log.info("result of run: {}", finished);    if (!finished) {        throw new IllegalStateException("Job failed!");    }}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    ToolRunner.run(new SparseVectorsFromSequenceFiles(), args);}
aacecb0f01750d985b78d806dc3c134f0da79efe2752957e0f93ecf5cbf9e492
run
public int run(String[] args) throws Exception
{    DefaultOptionBuilder obuilder = new DefaultOptionBuilder();    ArgumentBuilder abuilder = new ArgumentBuilder();    GroupBuilder gbuilder = new GroupBuilder();    Option inputDirOpt = DefaultOptionCreator.inputOption().create();    Option outputDirOpt = DefaultOptionCreator.outputOption().create();    Option minSupportOpt = obuilder.withLongName("minSupport").withArgument(abuilder.withName("minSupport").withMinimum(1).withMaximum(1).create()).withDescription("(Optional) Minimum Support. Default Value: 2").withShortName("s").create();    Option analyzerNameOpt = obuilder.withLongName("analyzerName").withArgument(abuilder.withName("analyzerName").withMinimum(1).withMaximum(1).create()).withDescription("The class name of the analyzer").withShortName("a").create();    Option chunkSizeOpt = obuilder.withLongName("chunkSize").withArgument(abuilder.withName("chunkSize").withMinimum(1).withMaximum(1).create()).withDescription("The chunkSize in MegaBytes. Default Value: 100MB").withShortName("chunk").create();    Option weightOpt = obuilder.withLongName("weight").withRequired(false).withArgument(abuilder.withName("weight").withMinimum(1).withMaximum(1).create()).withDescription("The kind of weight to use. Currently TF or TFIDF. Default: TFIDF").withShortName("wt").create();    Option minDFOpt = obuilder.withLongName("minDF").withRequired(false).withArgument(abuilder.withName("minDF").withMinimum(1).withMaximum(1).create()).withDescription("The minimum document frequency.  Default is 1").withShortName("md").create();    Option maxDFPercentOpt = obuilder.withLongName("maxDFPercent").withRequired(false).withArgument(abuilder.withName("maxDFPercent").withMinimum(1).withMaximum(1).create()).withDescription("The max percentage of docs for the DF.  Can be used to remove really high frequency terms." + " Expressed as an integer between 0 and 100. Default is 99.  If maxDFSigma is also set, " + "it will override this value.").withShortName("x").create();    Option maxDFSigmaOpt = obuilder.withLongName("maxDFSigma").withRequired(false).withArgument(abuilder.withName("maxDFSigma").withMinimum(1).withMaximum(1).create()).withDescription("What portion of the tf (tf-idf) vectors to be used, expressed in times the standard deviation (sigma) " + "of the document frequencies of these vectors. Can be used to remove really high frequency terms." + " Expressed as a double value. Good value to be specified is 3.0. In case the value is less " + "than 0 no vectors will be filtered out. Default is -1.0.  Overrides maxDFPercent").withShortName("xs").create();    Option minLLROpt = obuilder.withLongName("minLLR").withRequired(false).withArgument(abuilder.withName("minLLR").withMinimum(1).withMaximum(1).create()).withDescription("(Optional)The minimum Log Likelihood Ratio(Float)  Default is " + LLRReducer.DEFAULT_MIN_LLR).withShortName("ml").create();    Option numReduceTasksOpt = obuilder.withLongName("numReducers").withArgument(abuilder.withName("numReducers").withMinimum(1).withMaximum(1).create()).withDescription("(Optional) Number of reduce tasks. Default Value: 1").withShortName("nr").create();    Option powerOpt = obuilder.withLongName("norm").withRequired(false).withArgument(abuilder.withName("norm").withMinimum(1).withMaximum(1).create()).withDescription("The norm to use, expressed as either a float or \"INF\" if you want to use the Infinite norm.  " + "Must be greater or equal to 0.  The default is not to normalize").withShortName("n").create();    Option logNormalizeOpt = obuilder.withLongName("logNormalize").withRequired(false).withDescription("(Optional) Whether output vectors should be logNormalize. If set true else false").withShortName("lnorm").create();    Option maxNGramSizeOpt = obuilder.withLongName("maxNGramSize").withRequired(false).withArgument(abuilder.withName("ngramSize").withMinimum(1).withMaximum(1).create()).withDescription("(Optional) The maximum size of ngrams to create" + " (2 = bigrams, 3 = trigrams, etc) Default Value:1").withShortName("ng").create();    Option sequentialAccessVectorOpt = obuilder.withLongName("sequentialAccessVector").withRequired(false).withDescription("(Optional) Whether output vectors should be SequentialAccessVectors. If set true else false").withShortName("seq").create();    Option namedVectorOpt = obuilder.withLongName("namedVector").withRequired(false).withDescription("(Optional) Whether output vectors should be NamedVectors. If set true else false").withShortName("nv").create();    Option overwriteOutput = obuilder.withLongName("overwrite").withRequired(false).withDescription("If set, overwrite the output directory").withShortName("ow").create();    Option helpOpt = obuilder.withLongName("help").withDescription("Print out help").withShortName("h").create();    Group group = gbuilder.withName("Options").withOption(minSupportOpt).withOption(analyzerNameOpt).withOption(chunkSizeOpt).withOption(outputDirOpt).withOption(inputDirOpt).withOption(minDFOpt).withOption(maxDFSigmaOpt).withOption(maxDFPercentOpt).withOption(weightOpt).withOption(powerOpt).withOption(minLLROpt).withOption(numReduceTasksOpt).withOption(maxNGramSizeOpt).withOption(overwriteOutput).withOption(helpOpt).withOption(sequentialAccessVectorOpt).withOption(namedVectorOpt).withOption(logNormalizeOpt).create();    try {        Parser parser = new Parser();        parser.setGroup(group);        parser.setHelpOption(helpOpt);        CommandLine cmdLine = parser.parse(args);        if (cmdLine.hasOption(helpOpt)) {            CommandLineUtil.printHelp(group);            return -1;        }        Path inputDir = new Path((String) cmdLine.getValue(inputDirOpt));        Path outputDir = new Path((String) cmdLine.getValue(outputDirOpt));        int chunkSize = 100;        if (cmdLine.hasOption(chunkSizeOpt)) {            chunkSize = Integer.parseInt((String) cmdLine.getValue(chunkSizeOpt));        }        int minSupport = 2;        if (cmdLine.hasOption(minSupportOpt)) {            String minSupportString = (String) cmdLine.getValue(minSupportOpt);            minSupport = Integer.parseInt(minSupportString);        }        int maxNGramSize = 1;        if (cmdLine.hasOption(maxNGramSizeOpt)) {            try {                maxNGramSize = Integer.parseInt(cmdLine.getValue(maxNGramSizeOpt).toString());            } catch (NumberFormatException ex) {                log.warn("Could not parse ngram size option");            }        }        log.info("Maximum n-gram size is: {}", maxNGramSize);        if (cmdLine.hasOption(overwriteOutput)) {            HadoopUtil.delete(getConf(), outputDir);        }        float minLLRValue = LLRReducer.DEFAULT_MIN_LLR;        if (cmdLine.hasOption(minLLROpt)) {            minLLRValue = Float.parseFloat(cmdLine.getValue(minLLROpt).toString());        }        log.info("Minimum LLR value: {}", minLLRValue);        int reduceTasks = 1;        if (cmdLine.hasOption(numReduceTasksOpt)) {            reduceTasks = Integer.parseInt(cmdLine.getValue(numReduceTasksOpt).toString());        }        log.info("Number of reduce tasks: {}", reduceTasks);        Class<? extends Analyzer> analyzerClass = StandardAnalyzer.class;        if (cmdLine.hasOption(analyzerNameOpt)) {            String className = cmdLine.getValue(analyzerNameOpt).toString();            analyzerClass = Class.forName(className).asSubclass(Analyzer.class);                                    AnalyzerUtils.createAnalyzer(analyzerClass);        }        boolean processIdf;        if (cmdLine.hasOption(weightOpt)) {            String wString = cmdLine.getValue(weightOpt).toString();            if ("tf".equalsIgnoreCase(wString)) {                processIdf = false;            } else if ("tfidf".equalsIgnoreCase(wString)) {                processIdf = true;            } else {                throw new OptionException(weightOpt);            }        } else {            processIdf = true;        }        int minDf = 1;        if (cmdLine.hasOption(minDFOpt)) {            minDf = Integer.parseInt(cmdLine.getValue(minDFOpt).toString());        }        int maxDFPercent = 99;        if (cmdLine.hasOption(maxDFPercentOpt)) {            maxDFPercent = Integer.parseInt(cmdLine.getValue(maxDFPercentOpt).toString());        }        double maxDFSigma = -1.0;        if (cmdLine.hasOption(maxDFSigmaOpt)) {            maxDFSigma = Double.parseDouble(cmdLine.getValue(maxDFSigmaOpt).toString());        }        float norm = PartialVectorMerger.NO_NORMALIZING;        if (cmdLine.hasOption(powerOpt)) {            String power = cmdLine.getValue(powerOpt).toString();            if ("INF".equals(power)) {                norm = Float.POSITIVE_INFINITY;            } else {                norm = Float.parseFloat(power);            }        }        boolean logNormalize = false;        if (cmdLine.hasOption(logNormalizeOpt)) {            logNormalize = true;        }        log.info("Tokenizing documents in {}", inputDir);        Configuration conf = getConf();        Path tokenizedPath = new Path(outputDir, DocumentProcessor.TOKENIZED_DOCUMENT_OUTPUT_FOLDER);                        DocumentProcessor.tokenizeDocuments(inputDir, analyzerClass, tokenizedPath, conf);        boolean sequentialAccessOutput = false;        if (cmdLine.hasOption(sequentialAccessVectorOpt)) {            sequentialAccessOutput = true;        }        boolean namedVectors = false;        if (cmdLine.hasOption(namedVectorOpt)) {            namedVectors = true;        }        boolean shouldPrune = maxDFSigma >= 0.0 || maxDFPercent > 0.00;        String tfDirName = shouldPrune ? DictionaryVectorizer.DOCUMENT_VECTOR_OUTPUT_FOLDER + "-toprune" : DictionaryVectorizer.DOCUMENT_VECTOR_OUTPUT_FOLDER;        log.info("Creating Term Frequency Vectors");        if (processIdf) {            DictionaryVectorizer.createTermFrequencyVectors(tokenizedPath, outputDir, tfDirName, conf, minSupport, maxNGramSize, minLLRValue, -1.0f, false, reduceTasks, chunkSize, sequentialAccessOutput, namedVectors);        } else {            DictionaryVectorizer.createTermFrequencyVectors(tokenizedPath, outputDir, tfDirName, conf, minSupport, maxNGramSize, minLLRValue, norm, logNormalize, reduceTasks, chunkSize, sequentialAccessOutput, namedVectors);        }        Pair<Long[], List<Path>> docFrequenciesFeatures = null;                if (shouldPrune || processIdf) {            log.info("Calculating IDF");            docFrequenciesFeatures = TFIDFConverter.calculateDF(new Path(outputDir, tfDirName), outputDir, conf, chunkSize);        }                long maxDF = maxDFPercent;        if (shouldPrune) {            long vectorCount = docFrequenciesFeatures.getFirst()[1];            if (maxDFSigma >= 0.0) {                Path dfDir = new Path(outputDir, TFIDFConverter.WORDCOUNT_OUTPUT_FOLDER);                Path stdCalcDir = new Path(outputDir, HighDFWordsPruner.STD_CALC_DIR);                                double stdDev = BasicStats.stdDevForGivenMean(dfDir, stdCalcDir, 0.0, conf);                maxDF = (int) (100.0 * maxDFSigma * stdDev / vectorCount);            }            long maxDFThreshold = (long) (vectorCount * (maxDF / 100.0f));                        Path tfDir = new Path(outputDir, tfDirName);            Path prunedTFDir = new Path(outputDir, DictionaryVectorizer.DOCUMENT_VECTOR_OUTPUT_FOLDER);            Path prunedPartialTFDir = new Path(outputDir, DictionaryVectorizer.DOCUMENT_VECTOR_OUTPUT_FOLDER + "-partial");            log.info("Pruning");            if (processIdf) {                HighDFWordsPruner.pruneVectors(tfDir, prunedTFDir, prunedPartialTFDir, maxDFThreshold, minDf, conf, docFrequenciesFeatures, -1.0f, false, reduceTasks);            } else {                HighDFWordsPruner.pruneVectors(tfDir, prunedTFDir, prunedPartialTFDir, maxDFThreshold, minDf, conf, docFrequenciesFeatures, norm, logNormalize, reduceTasks);            }            HadoopUtil.delete(new Configuration(conf), tfDir);        }        if (processIdf) {            TFIDFConverter.processTfIdf(new Path(outputDir, DictionaryVectorizer.DOCUMENT_VECTOR_OUTPUT_FOLDER), outputDir, conf, docFrequenciesFeatures, minDf, maxDF, norm, logNormalize, sequentialAccessOutput, namedVectors, reduceTasks);        }    } catch (OptionException e) {        log.error("Exception", e);        CommandLineUtil.printHelp(group);    }    return 0;}
7bba593422bb42c95fd3950160e161d067ab18a22007a6766dcfe65de904967d
reduce
protected void reduce(Text key, Iterable<LongWritable> values, Context context) throws IOException, InterruptedException
{    long sum = 0;    for (LongWritable value : values) {        sum += value.get();    }    context.write(key, new LongWritable(sum));}
1b8c227cdc1a90c24fff74040a0f3517b8216b837f0f046a957c5b9652902bbc
map
protected void map(Text key, StringTuple value, final Context context) throws IOException, InterruptedException
{    OpenObjectLongHashMap<String> wordCount = new OpenObjectLongHashMap<>();    for (String word : value.getEntries()) {        if (wordCount.containsKey(word)) {            wordCount.put(word, wordCount.get(word) + 1);        } else {            wordCount.put(word, 1);        }    }    wordCount.forEachPair(new ObjectLongProcedure<String>() {        @Override        public boolean apply(String first, long second) {            try {                context.write(new Text(first), new LongWritable(second));            } catch (IOException e) {                context.getCounter("Exception", "Output IO Exception").increment(1);            } catch (InterruptedException e) {                context.getCounter("Exception", "Interrupted Exception").increment(1);            }            return true;        }    });}
61c1a2c538e9dde048f5274cb031e5aa4ebe027a8373a8332d9cd210c559aeb2
apply
public boolean apply(String first, long second)
{    try {        context.write(new Text(first), new LongWritable(second));    } catch (IOException e) {        context.getCounter("Exception", "Output IO Exception").increment(1);    } catch (InterruptedException e) {        context.getCounter("Exception", "Interrupted Exception").increment(1);    }    return true;}
7bba593422bb42c95fd3950160e161d067ab18a22007a6766dcfe65de904967d
reduce
protected void reduce(Text key, Iterable<LongWritable> values, Context context) throws IOException, InterruptedException
{    long sum = 0;    for (LongWritable value : values) {        sum += value.get();    }    if (sum >= minSupport) {        context.write(key, new LongWritable(sum));    }}
6b7dd49be7482fc8ee0fbe8bd0f24522f2a718c8c816a3d7b048fb4688eb6373
setup
protected void setup(Context context) throws IOException, InterruptedException
{    super.setup(context);    minSupport = context.getConfiguration().getInt(DictionaryVectorizer.MIN_SUPPORT, DictionaryVectorizer.DEFAULT_MIN_SUPPORT);}
fc1e428e426e46a32a92783347cd800582026b43336f9729a249480992d42a51
map
protected void map(WritableComparable<?> key, VectorWritable value, Context context) throws IOException, InterruptedException
{    Vector vector = value.get();    for (Vector.Element e : vector.nonZeroes()) {        out.set(e.index());        context.write(out, ONE);    }    context.write(TOTAL_COUNT, ONE);}
ca428b91d7801e9669d0df3b596b5604a2adf0bfa05067b4c7765ac1089d5532
reduce
protected void reduce(IntWritable key, Iterable<LongWritable> values, Context context) throws IOException, InterruptedException
{    long sum = 0;    for (LongWritable value : values) {        sum += value.get();    }    context.write(key, new LongWritable(sum));}
f2c6e7501dd3df801173fdd7ee52d22bb0c4462b354650dc1c12645849aa3692
reduce
protected void reduce(Text key, Iterable<StringTuple> values, Context context) throws IOException, InterruptedException
{    Iterator<StringTuple> it = values.iterator();    if (!it.hasNext()) {        return;    }    List<String> value = Lists.newArrayList();    while (it.hasNext()) {        value.addAll(it.next().getEntries());    }        Vector vector = new RandomAccessSparseVector(dimension, value.size());    if (maxNGramSize >= 2) {        ShingleFilter sf = new ShingleFilter(new IteratorTokenStream(value.iterator()), maxNGramSize);        sf.reset();        try {            do {                String term = sf.getAttribute(CharTermAttribute.class).toString();                if (!term.isEmpty() && dictionary.containsKey(term)) {                                        int termId = dictionary.get(term);                    vector.setQuick(termId, vector.getQuick(termId) + 1);                }            } while (sf.incrementToken());            sf.end();        } finally {            Closeables.close(sf, true);        }    } else {        for (String term : value) {            if (!term.isEmpty() && dictionary.containsKey(term)) {                                int termId = dictionary.get(term);                vector.setQuick(termId, vector.getQuick(termId) + 1);            }        }    }    if (sequentialAccess) {        vector = new SequentialAccessSparseVector(vector);    }    if (namedVector) {        vector = new NamedVector(vector, key.toString());    }        if (vector.getNumNondefaultElements() > 0) {        VectorWritable vectorWritable = new VectorWritable(vector);        context.write(key, vectorWritable);    } else {        context.getCounter("TFPartialVectorReducer", "emptyVectorCount").increment(1);    }}
6b7dd49be7482fc8ee0fbe8bd0f24522f2a718c8c816a3d7b048fb4688eb6373
setup
protected void setup(Context context) throws IOException, InterruptedException
{    super.setup(context);    Configuration conf = context.getConfiguration();    dimension = conf.getInt(PartialVectorMerger.DIMENSION, Integer.MAX_VALUE);    sequentialAccess = conf.getBoolean(PartialVectorMerger.SEQUENTIAL_ACCESS, false);    namedVector = conf.getBoolean(PartialVectorMerger.NAMED_VECTOR, false);    maxNGramSize = conf.getInt(DictionaryVectorizer.MAX_NGRAMS, maxNGramSize);    URI[] localFiles = DistributedCache.getCacheFiles(conf);    Path dictionaryFile = HadoopUtil.findInCacheByPartOfFilename(DictionaryVectorizer.DICTIONARY_FILE, localFiles);        for (Pair<Writable, IntWritable> record : new SequenceFileIterable<Writable, IntWritable>(dictionaryFile, true, conf)) {        dictionary.put(record.getFirst().toString(), record.getSecond().get());    }}
5445adb3608468a82b52a8679c2b7f4e8558a1ce83caa4b15a206a92ef9f50d4
calculate
public double calculate(int tf, int df, int length, int numDocs)
{        return tf;}
d344511dd43d23e5cb331160fcd9b9b99c6014bb16c237b8d99b1a1a19a34a3e
processTfIdf
public static void processTfIdf(Path input, Path output, Configuration baseConf, Pair<Long[], List<Path>> datasetFeatures, int minDf, long maxDF, float normPower, boolean logNormalize, boolean sequentialAccessOutput, boolean namedVector, int numReducers) throws IOException, InterruptedException, ClassNotFoundException
{    Preconditions.checkArgument(normPower == PartialVectorMerger.NO_NORMALIZING || normPower >= 0, "If specified normPower must be nonnegative", normPower);    Preconditions.checkArgument(normPower == PartialVectorMerger.NO_NORMALIZING || (normPower > 1 && !Double.isInfinite(normPower)) || !logNormalize, "normPower must be > 1 and not infinite if log normalization is chosen", normPower);    int partialVectorIndex = 0;    List<Path> partialVectorPaths = Lists.newArrayList();    List<Path> dictionaryChunks = datasetFeatures.getSecond();    for (Path dictionaryChunk : dictionaryChunks) {        Path partialVectorOutputPath = new Path(output, VECTOR_OUTPUT_FOLDER + partialVectorIndex++);        partialVectorPaths.add(partialVectorOutputPath);        makePartialVectors(input, baseConf, datasetFeatures.getFirst()[0], datasetFeatures.getFirst()[1], minDf, maxDF, dictionaryChunk, partialVectorOutputPath, sequentialAccessOutput, namedVector);    }    Configuration conf = new Configuration(baseConf);    Path outputDir = new Path(output, DOCUMENT_VECTOR_OUTPUT_FOLDER);    PartialVectorMerger.mergePartialVectors(partialVectorPaths, outputDir, baseConf, normPower, logNormalize, datasetFeatures.getFirst()[0].intValue(), sequentialAccessOutput, namedVector, numReducers);    HadoopUtil.delete(conf, partialVectorPaths);}
e1b732a5d23680d0e2c64e425711f6b08aad6f543ab69ee4bf065f82e8b9befa
calculateDF
public static Pair<Long[], List<Path>> calculateDF(Path input, Path output, Configuration baseConf, int chunkSizeInMegabytes) throws IOException, InterruptedException, ClassNotFoundException
{    if (chunkSizeInMegabytes < MIN_CHUNKSIZE) {        chunkSizeInMegabytes = MIN_CHUNKSIZE;    } else if (chunkSizeInMegabytes > MAX_CHUNKSIZE) {                chunkSizeInMegabytes = MAX_CHUNKSIZE;    }    Path wordCountPath = new Path(output, WORDCOUNT_OUTPUT_FOLDER);    startDFCounting(input, wordCountPath, baseConf);    return createDictionaryChunks(wordCountPath, output, baseConf, chunkSizeInMegabytes);}
2a9646041259f351b7d953f7d017dc13c6747a14ce16784d51ce2b60f51acc31
createDictionaryChunks
private static Pair<Long[], List<Path>> createDictionaryChunks(Path featureCountPath, Path dictionaryPathBase, Configuration baseConf, int chunkSizeInMegabytes) throws IOException
{    List<Path> chunkPaths = Lists.newArrayList();    Configuration conf = new Configuration(baseConf);    FileSystem fs = FileSystem.get(featureCountPath.toUri(), conf);    long chunkSizeLimit = chunkSizeInMegabytes * 1024L * 1024L;    int chunkIndex = 0;    Path chunkPath = new Path(dictionaryPathBase, FREQUENCY_FILE + chunkIndex);    chunkPaths.add(chunkPath);    SequenceFile.Writer freqWriter = new SequenceFile.Writer(fs, conf, chunkPath, IntWritable.class, LongWritable.class);    try {        long currentChunkSize = 0;        long featureCount = 0;        long vectorCount = Long.MAX_VALUE;        Path filesPattern = new Path(featureCountPath, OUTPUT_FILES_PATTERN);        for (Pair<IntWritable, LongWritable> record : new SequenceFileDirIterable<IntWritable, LongWritable>(filesPattern, PathType.GLOB, null, null, true, conf)) {            if (currentChunkSize > chunkSizeLimit) {                Closeables.close(freqWriter, false);                chunkIndex++;                chunkPath = new Path(dictionaryPathBase, FREQUENCY_FILE + chunkIndex);                chunkPaths.add(chunkPath);                freqWriter = new SequenceFile.Writer(fs, conf, chunkPath, IntWritable.class, LongWritable.class);                currentChunkSize = 0;            }            int fieldSize = SEQUENCEFILE_BYTE_OVERHEAD + Integer.SIZE / 8 + Long.SIZE / 8;            currentChunkSize += fieldSize;            IntWritable key = record.getFirst();            LongWritable value = record.getSecond();            if (key.get() >= 0) {                freqWriter.append(key, value);            } else if (key.get() == -1) {                vectorCount = value.get();            }            featureCount = Math.max(key.get(), featureCount);        }        featureCount++;        Long[] counts = { featureCount, vectorCount };        return new Pair<>(counts, chunkPaths);    } finally {        Closeables.close(freqWriter, false);    }}
995cbfb341eed925e8855e1257a719fc508f80ed0679de0dbe40627c1a8194ee
makePartialVectors
private static void makePartialVectors(Path input, Configuration baseConf, Long featureCount, Long vectorCount, int minDf, long maxDF, Path dictionaryFilePath, Path output, boolean sequentialAccess, boolean namedVector) throws IOException, InterruptedException, ClassNotFoundException
{    Configuration conf = new Configuration(baseConf);        conf.set("io.serializations", "org.apache.hadoop.io.serializer.JavaSerialization," + "org.apache.hadoop.io.serializer.WritableSerialization");    conf.setLong(FEATURE_COUNT, featureCount);    conf.setLong(VECTOR_COUNT, vectorCount);    conf.setInt(MIN_DF, minDf);    conf.setLong(MAX_DF, maxDF);    conf.setBoolean(PartialVectorMerger.SEQUENTIAL_ACCESS, sequentialAccess);    conf.setBoolean(PartialVectorMerger.NAMED_VECTOR, namedVector);    DistributedCache.addCacheFile(dictionaryFilePath.toUri(), conf);    Job job = new Job(conf);    job.setJobName(": MakePartialVectors: input-folder: " + input + ", dictionary-file: " + dictionaryFilePath.toString());    job.setJarByClass(TFIDFConverter.class);    job.setOutputKeyClass(Text.class);    job.setOutputValueClass(VectorWritable.class);    FileInputFormat.setInputPaths(job, input);    FileOutputFormat.setOutputPath(job, output);    job.setMapperClass(Mapper.class);    job.setInputFormatClass(SequenceFileInputFormat.class);    job.setReducerClass(TFIDFPartialVectorReducer.class);    job.setOutputFormatClass(SequenceFileOutputFormat.class);    HadoopUtil.delete(conf, output);    boolean succeeded = job.waitForCompletion(true);    if (!succeeded) {        throw new IllegalStateException("Job failed!");    }}
61dde52822821a81c23f14cd226524c5a7a64d2f80169654bdee84dc93abcff7
startDFCounting
private static void startDFCounting(Path input, Path output, Configuration baseConf) throws IOException, InterruptedException, ClassNotFoundException
{    Configuration conf = new Configuration(baseConf);        conf.set("io.serializations", "org.apache.hadoop.io.serializer.JavaSerialization," + "org.apache.hadoop.io.serializer.WritableSerialization");    Job job = new Job(conf);    job.setJobName("VectorTfIdf Document Frequency Count running over input: " + input);    job.setJarByClass(TFIDFConverter.class);    job.setOutputKeyClass(IntWritable.class);    job.setOutputValueClass(LongWritable.class);    FileInputFormat.setInputPaths(job, input);    FileOutputFormat.setOutputPath(job, output);    job.setMapperClass(TermDocumentCountMapper.class);    job.setInputFormatClass(SequenceFileInputFormat.class);    job.setCombinerClass(TermDocumentCountReducer.class);    job.setReducerClass(TermDocumentCountReducer.class);    job.setOutputFormatClass(SequenceFileOutputFormat.class);    HadoopUtil.delete(conf, output);    boolean succeeded = job.waitForCompletion(true);    if (!succeeded) {        throw new IllegalStateException("Job failed!");    }}
6764e47dd5acdbc427c0bd09acf8234b951e191889854077cd642d6d88ebaf60
reduce
protected void reduce(WritableComparable<?> key, Iterable<VectorWritable> values, Context context) throws IOException, InterruptedException
{    Iterator<VectorWritable> it = values.iterator();    if (!it.hasNext()) {        return;    }    Vector value = it.next().get();    Vector vector = new RandomAccessSparseVector((int) featureCount, value.getNumNondefaultElements());    for (Vector.Element e : value.nonZeroes()) {        if (!dictionary.containsKey(e.index())) {            continue;        }        long df = dictionary.get(e.index());        if (maxDf > -1 && (100.0 * df) / vectorCount > maxDf) {            continue;        }        if (df < minDf) {            df = minDf;        }        vector.setQuick(e.index(), tfidf.calculate((int) e.get(), (int) df, (int) featureCount, (int) vectorCount));    }    if (sequentialAccess) {        vector = new SequentialAccessSparseVector(vector);    }    if (namedVector) {        vector = new NamedVector(vector, key.toString());    }    VectorWritable vectorWritable = new VectorWritable(vector);    context.write(key, vectorWritable);}
6b7dd49be7482fc8ee0fbe8bd0f24522f2a718c8c816a3d7b048fb4688eb6373
setup
protected void setup(Context context) throws IOException, InterruptedException
{    super.setup(context);    Configuration conf = context.getConfiguration();    vectorCount = conf.getLong(TFIDFConverter.VECTOR_COUNT, 1);    featureCount = conf.getLong(TFIDFConverter.FEATURE_COUNT, 1);    minDf = conf.getInt(TFIDFConverter.MIN_DF, 1);    maxDf = conf.getLong(TFIDFConverter.MAX_DF, -1);    sequentialAccess = conf.getBoolean(PartialVectorMerger.SEQUENTIAL_ACCESS, false);    namedVector = conf.getBoolean(PartialVectorMerger.NAMED_VECTOR, false);    URI[] localFiles = DistributedCache.getCacheFiles(conf);    Path dictionaryFile = HadoopUtil.findInCacheByPartOfFilename(TFIDFConverter.FREQUENCY_FILE, localFiles);        for (Pair<IntWritable, LongWritable> record : new SequenceFileIterable<IntWritable, LongWritable>(dictionaryFile, true, conf)) {        dictionary.put(record.getFirst().get(), record.getSecond().get());    }}
5445adb3608468a82b52a8679c2b7f4e8558a1ce83caa4b15a206a92ef9f50d4
calculate
public double calculate(int tf, int df, int length, int numDocs)
{        return sim.tf(tf) * sim.idf(df, numDocs);}
d221713f567be6c3a854157b6beb8a5fd5dd64b69c1ef157fb4bac811a41c3f7
getConf
public Configuration getConf()
{    return conf;}
b526ab24bee22af8cea578365758de337167f0dbd081cb0fd03e8eb0655110bc
setConf
public void setConf(Configuration conf)
{    this.conf = conf;}
834fe4ef4051790c1733227e602fa475a6a67ad2d15d481d6ed68be2a080a9cc
getAnalyzerClassName
public String getAnalyzerClassName()
{    return analyzerClassName;}
ef9dfdcca61266501867447233212cd7594e9a7e0facab912daa9699fbed88cc
setAnalyzerClassName
public void setAnalyzerClassName(String analyzerClassName)
{    this.analyzerClassName = analyzerClassName;}
8471bd5752e0f4073864ed0e3002dc1d24b8f14e6427631c40369944f255ad53
getEncoderName
public String getEncoderName()
{    return encoderName;}
ef51202234d7b6f383620694cbe5216aebf963aca07b949248f39a001d8ac601
setEncoderName
public void setEncoderName(String encoderName)
{    this.encoderName = encoderName;}
048fcadf359a37696af85547983c8e1a90a6c62d53a2f5c66ba6b94ae1c5b98c
isSequentialAccess
public boolean isSequentialAccess()
{    return sequentialAccess;}
cfb8a4108f2e417c3a818711096228f4ae865d65dbe9385db2ba066c21214db3
setSequentialAccess
public void setSequentialAccess(boolean sequentialAccess)
{    this.sequentialAccess = sequentialAccess;}
253c641051bc2aecca864f2e320ccb716e05c30b08b47d0f259bbadd408acf77
getTfDirName
public String getTfDirName()
{    return tfDirName;}
c0615e11be5f85c902b6e1c09369f0f03de55c3663866202c7da4fa214f547c8
setTfDirName
public void setTfDirName(String tfDirName)
{    this.tfDirName = tfDirName;}
96c541d04fc2e75b092b868c26bc775ae5d49c6e41b8a5c882fb028d532c2350
isNamedVectors
public boolean isNamedVectors()
{    return namedVectors;}
cf03994e39730bcd4b8ca368bd1bcbc574cc943c9b766c1ddd279daae4e773b6
setNamedVectors
public void setNamedVectors(boolean namedVectors)
{    this.namedVectors = namedVectors;}
e949804d6f9073c65f6407cb6c1b8a63e3fe291efdb6f1e492bf83ebfe05e294
getCardinality
public int getCardinality()
{    return cardinality;}
8f274e2e16e61a0e93055bbd050b4c81898041a64e9aef2aee9fe9101745ab81
setCardinality
public void setCardinality(int cardinality)
{    this.cardinality = cardinality;}
2dc72ab3b0b1e9204101f70185a20052090b3ec78ae93b491b9590af867702ea
getEncoderClass
public String getEncoderClass()
{    return encoderClass;}
4a160b8e9a4f249ed8cde462c21ae911b9c1bf8e9081b9bd96e05f2110f12073
setEncoderClass
public void setEncoderClass(String encoderClass)
{    this.encoderClass = encoderClass;}
c7c031ff63c16115de1a1871ce7735476beea2e9bb0e54c2fcf661d9594b68dd
getMinSupport
public int getMinSupport()
{    return minSupport;}
f28e37f18af32446bc0d12f6b872ded5bc692a8f0f92fe0de2246637172157ac
setMinSupport
public void setMinSupport(int minSupport)
{    this.minSupport = minSupport;}
f2d000c0acbd0a7fcbda6d62572bc1e3d5dff94f7150090fea8fab5659caf1e6
getMaxNGramSize
public int getMaxNGramSize()
{    return maxNGramSize;}
6ab0f89d0455851548cdea64b4e57a287fa50ccd6970a7d8dc8afd2857b4e489
setMaxNGramSize
public void setMaxNGramSize(int maxNGramSize)
{    this.maxNGramSize = maxNGramSize;}
925560d1e66fa03fcbbb4eacd57004ecb2ce9ef7189211bc87fe4fed94e94686
getMinLLRValue
public float getMinLLRValue()
{    return minLLRValue;}
9f56e366d35dd276661834609357d9faa1c9fb7929c05dbb5a5459b99ce0aa78
setMinLLRValue
public void setMinLLRValue(float minLLRValue)
{    this.minLLRValue = minLLRValue;}
22160a17f203f3fe88f670deea9fdbfd936cc558d25673eb9ce2a93bdec1d12c
getNormPower
public float getNormPower()
{    return normPower;}
315cce8f6ea2e9c294cb62f496bde758301e30a23bb93bbef28fe0202f5c809c
setNormPower
public void setNormPower(float normPower)
{    this.normPower = normPower;}
eed66e72cafe2fc6d1e956900ff511c95e0bf96fa86fe2ef24e6fd0f1ad7691c
isLogNormalize
public boolean isLogNormalize()
{    return logNormalize;}
9ac31019e93ec6b272b7a36fc6bda73fcccabf902cb126f3dbb6d65bf65ade61
setLogNormalize
public void setLogNormalize(boolean logNormalize)
{    this.logNormalize = logNormalize;}
95de937ec43e987f4ceab3a5e29ac871a4c5aa99c68297020d03f5c820119161
getNumReducers
public int getNumReducers()
{    return numReducers;}
f10ee0e3f0a3d85c420cbe15736aa954085446d2a3b5b626fad47d257b74612f
setNumReducers
public void setNumReducers(int numReducers)
{    this.numReducers = numReducers;}
ffed5a68f9059c50e43ab2cda53ec5af112a28c2f0c99f8d5e45414ac604d11e
getChunkSizeInMegabytes
public int getChunkSizeInMegabytes()
{    return chunkSizeInMegabytes;}
8dac5b89b1939f0edb78d8dcfa9eb731947f3cbe8d97985fb6f22ab628a9db00
setChunkSizeInMegabytes
public void setChunkSizeInMegabytes(int chunkSizeInMegabytes)
{    this.chunkSizeInMegabytes = chunkSizeInMegabytes;}
3d1b9de5e61851f28489cb5470f705335237dc5034fa7c90fe79a1060de1906d
version
public static String version()
{    return Version.class.getPackage().getImplementationVersion();}
d464091abccdb4b266db24281bb997a86f639f3e06f1990f3ce17d98f6bac8a2
versionFromResource
public static String versionFromResource() throws IOException
{    return Resources.toString(Resources.getResource("version"), Charsets.UTF_8);}
365a24fc75086b6a0e91f9b072bd58c9280846cc05f333f28ede18388f27ce89
main
public static void main(String[] args) throws IOException
{    System.out.println(version() + ' ' + versionFromResource());}
cfc28358254f472bc0579aece562a1dd87d51008c0951d74a7d7b4f1b254563a
testTasteException
public void testTasteException()
{        TasteException te1 = new TasteException();    TasteException te2 = new TasteException(te1);    TasteException te3 = new TasteException(te2.toString(), te2);    TasteException te4 = new TasteException(te3.toString());    te4.printStackTrace(new PrintStream(new ByteArrayOutputStream()));    te4.printStackTrace(new PrintWriter(new OutputStreamWriter(new ByteArrayOutputStream())));}
0a64457a62daabc2d4ed1fec8237ebb4ef7d6b96df8d322f050dc14da3baea79
testNSUException
public void testNSUException()
{        TasteException te1 = new NoSuchUserException();    TasteException te4 = new NoSuchUserException(te1.toString());    te4.printStackTrace(new PrintStream(new ByteArrayOutputStream()));    te4.printStackTrace(new PrintWriter(new OutputStreamWriter(new ByteArrayOutputStream())));}
85f8b959c4026c910a3b7253eade21d78b9f33080e177bca84879053097c7915
testNSIException
public void testNSIException()
{        TasteException te1 = new NoSuchItemException();    TasteException te4 = new NoSuchItemException(te1.toString());    te4.printStackTrace(new PrintStream(new ByteArrayOutputStream()));    te4.printStackTrace(new PrintWriter(new OutputStreamWriter(new ByteArrayOutputStream())));}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    super.setUp();    inputFile = getTestTempFile("prefs.txt");    intermediateDir = getTestTempDir("intermediate");    intermediateDir.delete();    outputDir = getTestTempDir("output");    outputDir.delete();    tmpDir = getTestTempDir("tmp");    conf = getConfiguration();        SharingMapper.reset();}
fe715513768ac69336a5450565d254e828a245199646fc50b57581bc65fdf734
completeJobToyExample
public void completeJobToyExample() throws Exception
{    explicitExample(1);}
054e11c17e6656faea529855637f44098264a94133ce7c14742919703f450c9d
completeJobToyExampleMultithreaded
public void completeJobToyExampleMultithreaded() throws Exception
{    explicitExample(2);}
afa9584a34502f23f5c2578cf53dd6850aa40a647215a66db2cd45cd01e92c1d
explicitExample
private void explicitExample(int numThreads) throws Exception
{    Double na = Double.NaN;    Matrix preferences = new SparseRowMatrix(4, 4, new Vector[] { new DenseVector(new double[] { 5.0, 5.0, 2.0, na }), new DenseVector(new double[] { 2.0, na, 3.0, 5.0 }), new DenseVector(new double[] { na, 5.0, na, 3.0 }), new DenseVector(new double[] { 3.0, na, na, 5.0 }) });    writeLines(inputFile, preferencesAsText(preferences));    ParallelALSFactorizationJob alsFactorization = new ParallelALSFactorizationJob();    alsFactorization.setConf(conf);    int numFeatures = 3;    int numIterations = 5;    double lambda = 0.065;    alsFactorization.run(new String[] { "--input", inputFile.getAbsolutePath(), "--output", outputDir.getAbsolutePath(), "--tempDir", tmpDir.getAbsolutePath(), "--lambda", String.valueOf(lambda), "--numFeatures", String.valueOf(numFeatures), "--numIterations", String.valueOf(numIterations), "--numThreadsPerSolver", String.valueOf(numThreads) });    Matrix u = MathHelper.readMatrix(conf, new Path(outputDir.getAbsolutePath(), "U/part-m-00000"), preferences.numRows(), numFeatures);    Matrix m = MathHelper.readMatrix(conf, new Path(outputDir.getAbsolutePath(), "M/part-m-00000"), preferences.numCols(), numFeatures);    StringBuilder info = new StringBuilder();    info.append("\nA - users x items\n\n");    info.append(MathHelper.nice(preferences));    info.append("\nU - users x features\n\n");    info.append(MathHelper.nice(u));    info.append("\nM - items x features\n\n");    info.append(MathHelper.nice(m));    Matrix Ak = u.times(m.transpose());    info.append("\nAk - users x items\n\n");    info.append(MathHelper.nice(Ak));    info.append('\n');    log.info(info.toString());    RunningAverage avg = new FullRunningAverage();    for (MatrixSlice slice : preferences) {        for (Element e : slice.nonZeroes()) {            if (!Double.isNaN(e.get())) {                double pref = e.get();                double estimate = u.viewRow(slice.index()).dot(m.viewRow(e.index()));                double err = pref - estimate;                avg.addDatum(err * err);                log.info("Comparing preference of user [{}] towards item [{}], was [{}] estimate is [{}]", slice.index(), e.index(), pref, estimate);            }        }    }    double rmse = Math.sqrt(avg.getAverage());    log.info("RMSE: {}", rmse);    assertTrue(rmse < 0.2);}
c7ff8ca2f11d3e988b9b68e8bfd693d0496e367d6e8fbe4614a4961faef40492
completeJobImplicitToyExample
public void completeJobImplicitToyExample() throws Exception
{    implicitExample(1);}
a7c2337fd977109843dfd522fd2c982bb4b6c2af8f850cd5157ea3f51375071e
completeJobImplicitToyExampleMultithreaded
public void completeJobImplicitToyExampleMultithreaded() throws Exception
{    implicitExample(2);}
94b0239adf9ddb2b15fa9b2f92b9405c0cb59ba7492dfb1377504881e5f9eefc
implicitExample
public void implicitExample(int numThreads) throws Exception
{    Matrix observations = new SparseRowMatrix(4, 4, new Vector[] { new DenseVector(new double[] { 5.0, 5.0, 2.0, 0 }), new DenseVector(new double[] { 2.0, 0, 3.0, 5.0 }), new DenseVector(new double[] { 0, 5.0, 0, 3.0 }), new DenseVector(new double[] { 3.0, 0, 0, 5.0 }) });    Matrix preferences = new SparseRowMatrix(4, 4, new Vector[] { new DenseVector(new double[] { 1.0, 1.0, 1.0, 0 }), new DenseVector(new double[] { 1.0, 0, 1.0, 1.0 }), new DenseVector(new double[] { 0, 1.0, 0, 1.0 }), new DenseVector(new double[] { 1.0, 0, 0, 1.0 }) });    writeLines(inputFile, preferencesAsText(observations));    ParallelALSFactorizationJob alsFactorization = new ParallelALSFactorizationJob();    alsFactorization.setConf(conf);    int numFeatures = 3;    int numIterations = 5;    double lambda = 0.065;    double alpha = 20;    alsFactorization.run(new String[] { "--input", inputFile.getAbsolutePath(), "--output", outputDir.getAbsolutePath(), "--tempDir", tmpDir.getAbsolutePath(), "--lambda", String.valueOf(lambda), "--implicitFeedback", String.valueOf(true), "--alpha", String.valueOf(alpha), "--numFeatures", String.valueOf(numFeatures), "--numIterations", String.valueOf(numIterations), "--numThreadsPerSolver", String.valueOf(numThreads) });    Matrix u = MathHelper.readMatrix(conf, new Path(outputDir.getAbsolutePath(), "U/part-m-00000"), observations.numRows(), numFeatures);    Matrix m = MathHelper.readMatrix(conf, new Path(outputDir.getAbsolutePath(), "M/part-m-00000"), observations.numCols(), numFeatures);    StringBuilder info = new StringBuilder();    info.append("\nObservations - users x items\n");    info.append(MathHelper.nice(observations));    info.append("\nA - users x items\n\n");    info.append(MathHelper.nice(preferences));    info.append("\nU - users x features\n\n");    info.append(MathHelper.nice(u));    info.append("\nM - items x features\n\n");    info.append(MathHelper.nice(m));    Matrix Ak = u.times(m.transpose());    info.append("\nAk - users x items\n\n");    info.append(MathHelper.nice(Ak));    info.append('\n');    log.info(info.toString());    RunningAverage avg = new FullRunningAverage();    for (MatrixSlice slice : preferences) {        for (Element e : slice.nonZeroes()) {            if (!Double.isNaN(e.get())) {                double pref = e.get();                double estimate = u.viewRow(slice.index()).dot(m.viewRow(e.index()));                double confidence = 1 + alpha * observations.getQuick(slice.index(), e.index());                double err = confidence * (pref - estimate) * (pref - estimate);                avg.addDatum(err);                log.info("Comparing preference of user [{}] towards item [{}], was [{}] with confidence [{}] " + "estimate is [{}]", slice.index(), e.index(), pref, confidence, estimate);            }        }    }    double rmse = Math.sqrt(avg.getAverage());    log.info("RMSE: {}", rmse);    assertTrue(rmse < 0.4);}
b8dc05b929aa05f13db55fcdef346a208ae5a5b56d23e46518035359558c10e1
exampleWithIDMapping
public void exampleWithIDMapping() throws Exception
{    String[] preferencesWithLongIDs = { "5568227754922264005,-4758971626494767444,5.0", "5568227754922264005,3688396615879561990,5.0", "5568227754922264005,4594226737871995304,2.0", "550945997885173934,-4758971626494767444,2.0", "550945997885173934,4594226737871995304,3.0", "550945997885173934,706816485922781596,5.0", "2448095297482319463,3688396615879561990,5.0", "2448095297482319463,706816485922781596,3.0", "6839920411763636962,-4758971626494767444,3.0", "6839920411763636962,706816485922781596,5.0" };    writeLines(inputFile, preferencesWithLongIDs);    ParallelALSFactorizationJob alsFactorization = new ParallelALSFactorizationJob();    alsFactorization.setConf(conf);    int numFeatures = 3;    int numIterations = 5;    double lambda = 0.065;    alsFactorization.run(new String[] { "--input", inputFile.getAbsolutePath(), "--output", outputDir.getAbsolutePath(), "--tempDir", tmpDir.getAbsolutePath(), "--lambda", String.valueOf(lambda), "--numFeatures", String.valueOf(numFeatures), "--numIterations", String.valueOf(numIterations), "--numThreadsPerSolver", String.valueOf(1), "--usesLongIDs", String.valueOf(true) });    OpenIntLongHashMap userIDIndex = TasteHadoopUtils.readIDIndexMap(outputDir.getAbsolutePath() + "/userIDIndex/part-r-00000", conf);    assertEquals(4, userIDIndex.size());    OpenIntLongHashMap itemIDIndex = TasteHadoopUtils.readIDIndexMap(outputDir.getAbsolutePath() + "/itemIDIndex/part-r-00000", conf);    assertEquals(4, itemIDIndex.size());    OpenIntObjectHashMap<Vector> u = MathHelper.readMatrixRows(conf, new Path(outputDir.getAbsolutePath(), "U/part-m-00000"));    OpenIntObjectHashMap<Vector> m = MathHelper.readMatrixRows(conf, new Path(outputDir.getAbsolutePath(), "M/part-m-00000"));    assertEquals(4, u.size());    assertEquals(4, m.size());    RunningAverage avg = new FullRunningAverage();    for (String line : preferencesWithLongIDs) {        String[] tokens = TasteHadoopUtils.splitPrefTokens(line);        long userID = Long.parseLong(tokens[TasteHadoopUtils.USER_ID_POS]);        long itemID = Long.parseLong(tokens[TasteHadoopUtils.ITEM_ID_POS]);        double rating = Double.parseDouble(tokens[2]);        Vector userFeatures = u.get(TasteHadoopUtils.idToIndex(userID));        Vector itemFeatures = m.get(TasteHadoopUtils.idToIndex(itemID));        double estimate = userFeatures.dot(itemFeatures);        double err = rating - estimate;        avg.addDatum(err * err);    }    double rmse = Math.sqrt(avg.getAverage());    log.info("RMSE: {}", rmse);    assertTrue(rmse < 0.2);}
364a0f234da16438bfd6cdea45f9280f4e5d2c9d50548783438052dfa60da6d9
preferencesAsText
protected static String preferencesAsText(Matrix preferences)
{    StringBuilder prefsAsText = new StringBuilder();    String separator = "";    for (MatrixSlice slice : preferences) {        for (Element e : slice.nonZeroes()) {            if (!Double.isNaN(e.get())) {                prefsAsText.append(separator).append(slice.index()).append(',').append(e.index()).append(',').append(e.get());                separator = "\n";            }        }    }    System.out.println(prefsAsText.toString());    return prefsAsText.toString();}
9550f20c498392fdb57364774020351f910beff6c99115f9b78de7aa3cfd21f6
recommenderJobWithIDMapping
public void recommenderJobWithIDMapping() throws Exception
{    String[] preferencesWithLongIDs = { "5568227754922264005,-4758971626494767444,5.0", "5568227754922264005,3688396615879561990,5.0", "5568227754922264005,4594226737871995304,2.0", "550945997885173934,-4758971626494767444,2.0", "550945997885173934,4594226737871995304,3.0", "550945997885173934,706816485922781596,5.0", "2448095297482319463,3688396615879561990,5.0", "2448095297482319463,706816485922781596,3.0", "6839920411763636962,-4758971626494767444,3.0", "6839920411763636962,706816485922781596,5.0" };    writeLines(inputFile, preferencesWithLongIDs);    ParallelALSFactorizationJob alsFactorization = new ParallelALSFactorizationJob();    alsFactorization.setConf(conf);    int numFeatures = 3;    int numIterations = 5;    double lambda = 0.065;    Configuration conf = getConfiguration();    int success = ToolRunner.run(alsFactorization, new String[] { "-Dhadoop.tmp.dir=" + conf.get("hadoop.tmp.dir"), "--input", inputFile.getAbsolutePath(), "--output", intermediateDir.getAbsolutePath(), "--tempDir", tmpDir.getAbsolutePath(), "--lambda", String.valueOf(lambda), "--numFeatures", String.valueOf(numFeatures), "--numIterations", String.valueOf(numIterations), "--numThreadsPerSolver", String.valueOf(1), "--usesLongIDs", String.valueOf(true) });    assertEquals(0, success);        SharingMapper.reset();    RecommenderJob recommender = new RecommenderJob();    success = ToolRunner.run(recommender, new String[] { "-Dhadoop.tmp.dir=" + conf.get("hadoop.tmp.dir"), "--input", intermediateDir.getAbsolutePath() + "/userRatings/", "--userFeatures", intermediateDir.getAbsolutePath() + "/U/", "--itemFeatures", intermediateDir.getAbsolutePath() + "/M/", "--numRecommendations", String.valueOf(2), "--maxRating", String.valueOf(5.0), "--numThreads", String.valueOf(2), "--usesLongIDs", String.valueOf(true), "--userIDIndex", intermediateDir.getAbsolutePath() + "/userIDIndex/", "--itemIDIndex", intermediateDir.getAbsolutePath() + "/itemIDIndex/", "--output", outputDir.getAbsolutePath() });    assertEquals(0, success);}
391d128cb9d55115f3449e188915180831abe5650ebd1172c061e6c354158399
testUserItemFilter
public void testUserItemFilter() throws Exception
{    Configuration conf = getConfiguration();    IDReader idReader = new IDReader(conf);    Map<Long, FastIDSet> userItemFilter = new HashMap<>();    long user1 = 1;    long user2 = 2;    idReader.addUserAndItemIdToUserItemFilter(userItemFilter, user1, 100L);    idReader.addUserAndItemIdToUserItemFilter(userItemFilter, user1, 200L);    idReader.addUserAndItemIdToUserItemFilter(userItemFilter, user2, 300L);    FastIDSet userIds = IDReader.extractAllUserIdsFromUserItemFilter(userItemFilter);    assertEquals(2, userIds.size());    assertTrue(userIds.contains(user1));    assertTrue(userIds.contains(user1));    setField(idReader, USER_ITEM_FILTER_FIELD, userItemFilter);    FastIDSet itemsForUser1 = idReader.getItemsToRecommendForUser(user1);    assertEquals(2, itemsForUser1.size());    assertTrue(itemsForUser1.contains(100L));    assertTrue(itemsForUser1.contains(200L));    FastIDSet itemsForUser2 = idReader.getItemsToRecommendForUser(user2);    assertEquals(1, itemsForUser2.size());    assertTrue(itemsForUser2.contains(300L));    FastIDSet itemsForNonExistingUser = idReader.getItemsToRecommendForUser(3L);    assertTrue(itemsForNonExistingUser.isEmpty());}
8910e7267bcbe396074b3bf3f6d89c6108ea4e49966d1918d9f0f23ca5fb5bf5
testItemIDIndexMapper
public void testItemIDIndexMapper() throws Exception
{    Mapper<LongWritable, Text, VarIntWritable, VarLongWritable>.Context context = EasyMock.createMock(Mapper.Context.class);    context.write(new VarIntWritable(TasteHadoopUtils.idToIndex(789L)), new VarLongWritable(789L));    EasyMock.replay(context);    new ItemIDIndexMapper().map(new LongWritable(123L), new Text("456,789,5.0"), context);    EasyMock.verify(context);}
a06e54b927def0d9955d58a48b620452993b74653e07c4d1f91bd20194ae6d68
testItemIDIndexReducer
public void testItemIDIndexReducer() throws Exception
{    Reducer<VarIntWritable, VarLongWritable, VarIntWritable, VarLongWritable>.Context context = EasyMock.createMock(Reducer.Context.class);    context.write(new VarIntWritable(123), new VarLongWritable(45L));    EasyMock.replay(context);    new ItemIDIndexReducer().reduce(new VarIntWritable(123), Arrays.asList(new VarLongWritable(67L), new VarLongWritable(89L), new VarLongWritable(45L)), context);    EasyMock.verify(context);}
56d02effcbfb1a64febd2cda7e98949f7e219f03d093365c1d579af14a895153
testToItemPrefsMapper
public void testToItemPrefsMapper() throws Exception
{    Mapper<LongWritable, Text, VarLongWritable, VarLongWritable>.Context context = EasyMock.createMock(Mapper.Context.class);    context.write(new VarLongWritable(12L), new EntityPrefWritable(34L, 1.0f));    context.write(new VarLongWritable(56L), new EntityPrefWritable(78L, 2.0f));    EasyMock.replay(context);    ToItemPrefsMapper mapper = new ToItemPrefsMapper();    mapper.map(new LongWritable(123L), new Text("12,34,1"), context);    mapper.map(new LongWritable(456L), new Text("56,78,2"), context);    EasyMock.verify(context);}
bee3cea9fefb9968e4f966e66909a9590d9c07a66bcbc79dc31e5d01c0de4c73
testToItemPrefsMapperBooleanData
public void testToItemPrefsMapperBooleanData() throws Exception
{    Mapper<LongWritable, Text, VarLongWritable, VarLongWritable>.Context context = EasyMock.createMock(Mapper.Context.class);    context.write(new VarLongWritable(12L), new VarLongWritable(34L));    context.write(new VarLongWritable(56L), new VarLongWritable(78L));    EasyMock.replay(context);    ToItemPrefsMapper mapper = new ToItemPrefsMapper();    setField(mapper, "booleanData", true);    mapper.map(new LongWritable(123L), new Text("12,34"), context);    mapper.map(new LongWritable(456L), new Text("56,78"), context);    EasyMock.verify(context);}
8bc3572c0a6d5eebf9cef2ba3e86910908dcb4bf1a0faa0755eef1ff09487a4c
testToUserVectorReducer
public void testToUserVectorReducer() throws Exception
{    Reducer<VarLongWritable, VarLongWritable, VarLongWritable, VectorWritable>.Context context = EasyMock.createMock(Reducer.Context.class);    Counter userCounters = EasyMock.createMock(Counter.class);    EasyMock.expect(context.getCounter(ToUserVectorsReducer.Counters.USERS)).andReturn(userCounters);    userCounters.increment(1);    context.write(EasyMock.eq(new VarLongWritable(12L)), MathHelper.vectorMatches(MathHelper.elem(TasteHadoopUtils.idToIndex(34L), 1.0), MathHelper.elem(TasteHadoopUtils.idToIndex(56L), 2.0)));    EasyMock.replay(context, userCounters);    Collection<VarLongWritable> varLongWritables = Lists.newLinkedList();    varLongWritables.add(new EntityPrefWritable(34L, 1.0f));    varLongWritables.add(new EntityPrefWritable(56L, 2.0f));    new ToUserVectorsReducer().reduce(new VarLongWritable(12L), varLongWritables, context);    EasyMock.verify(context, userCounters);}
3378a7747f9b6b7ceea6f165476d07edbdf8d07e335c9920753bb5f744eaef2b
testToUserVectorReducerWithBooleanData
public void testToUserVectorReducerWithBooleanData() throws Exception
{    Reducer<VarLongWritable, VarLongWritable, VarLongWritable, VectorWritable>.Context context = EasyMock.createMock(Reducer.Context.class);    Counter userCounters = EasyMock.createMock(Counter.class);    EasyMock.expect(context.getCounter(ToUserVectorsReducer.Counters.USERS)).andReturn(userCounters);    userCounters.increment(1);    context.write(EasyMock.eq(new VarLongWritable(12L)), MathHelper.vectorMatches(MathHelper.elem(TasteHadoopUtils.idToIndex(34L), 1.0), MathHelper.elem(TasteHadoopUtils.idToIndex(56L), 1.0)));    EasyMock.replay(context, userCounters);    new ToUserVectorsReducer().reduce(new VarLongWritable(12L), Arrays.asList(new VarLongWritable(34L), new VarLongWritable(56L)), context);    EasyMock.verify(context, userCounters);}
3eae9ebce4d635b56d97b445b955a75d177b25a02b252b5c747f59cb865ad727
testSimilarityMatrixRowWrapperMapper
public void testSimilarityMatrixRowWrapperMapper() throws Exception
{    Mapper<IntWritable, VectorWritable, VarIntWritable, VectorOrPrefWritable>.Context context = EasyMock.createMock(Mapper.Context.class);    context.write(EasyMock.eq(new VarIntWritable(12)), vectorOfVectorOrPrefWritableMatches(MathHelper.elem(34, 0.5), MathHelper.elem(56, 0.7)));    EasyMock.replay(context);    RandomAccessSparseVector vector = new RandomAccessSparseVector(Integer.MAX_VALUE, 100);    vector.set(12, 1.0);    vector.set(34, 0.5);    vector.set(56, 0.7);    new SimilarityMatrixRowWrapperMapper().map(new IntWritable(12), new VectorWritable(vector), context);    EasyMock.verify(context);}
62c786fead74b5ad05c7994aa8237df4592afb94146e53d6196e90d8c5ad8bc7
vectorOfVectorOrPrefWritableMatches
private static VectorOrPrefWritable vectorOfVectorOrPrefWritableMatches(final Vector.Element... elements)
{    EasyMock.reportMatcher(new IArgumentMatcher() {        @Override        public boolean matches(Object argument) {            if (argument instanceof VectorOrPrefWritable) {                Vector v = ((VectorOrPrefWritable) argument).getVector();                return MathHelper.consistsOf(v, elements);            }            return false;        }        @Override        public void appendTo(StringBuffer buffer) {        }    });    return null;}
eafe89971eb7ac8d02727bc7a7f2e145a8ad354e94e997283d3ac3af52c92355
matches
public boolean matches(Object argument)
{    if (argument instanceof VectorOrPrefWritable) {        Vector v = ((VectorOrPrefWritable) argument).getVector();        return MathHelper.consistsOf(v, elements);    }    return false;}
a9d4d655b19b70cdbe9824cc420ee83364e526a200478fba70afd680009cc19e
appendTo
public void appendTo(StringBuffer buffer)
{}
87267ac98281d2f5088b3e5e8bf5ab8eef18796bc23c32f6e53848287968e42e
testUserVectorSplitterMapper
public void testUserVectorSplitterMapper() throws Exception
{    Mapper<VarLongWritable, VectorWritable, VarIntWritable, VectorOrPrefWritable>.Context context = EasyMock.createMock(Mapper.Context.class);    context.write(EasyMock.eq(new VarIntWritable(34)), prefOfVectorOrPrefWritableMatches(123L, 0.5f));    context.write(EasyMock.eq(new VarIntWritable(56)), prefOfVectorOrPrefWritableMatches(123L, 0.7f));    EasyMock.replay(context);    UserVectorSplitterMapper mapper = new UserVectorSplitterMapper();    setField(mapper, "maxPrefsPerUserConsidered", 10);    RandomAccessSparseVector vector = new RandomAccessSparseVector(Integer.MAX_VALUE, 100);    vector.set(34, 0.5);    vector.set(56, 0.7);    mapper.map(new VarLongWritable(123L), new VectorWritable(vector), context);    EasyMock.verify(context);}
bbdae2a6c85d010f6cb00eb24c5e3b5411ef705cb7a0b86ed1612b3d7f9bb3e4
prefOfVectorOrPrefWritableMatches
private static VectorOrPrefWritable prefOfVectorOrPrefWritableMatches(final long userID, final float prefValue)
{    EasyMock.reportMatcher(new IArgumentMatcher() {        @Override        public boolean matches(Object argument) {            if (argument instanceof VectorOrPrefWritable) {                VectorOrPrefWritable pref = (VectorOrPrefWritable) argument;                return pref.getUserID() == userID && pref.getValue() == prefValue;            }            return false;        }        @Override        public void appendTo(StringBuffer buffer) {        }    });    return null;}
eafe89971eb7ac8d02727bc7a7f2e145a8ad354e94e997283d3ac3af52c92355
matches
public boolean matches(Object argument)
{    if (argument instanceof VectorOrPrefWritable) {        VectorOrPrefWritable pref = (VectorOrPrefWritable) argument;        return pref.getUserID() == userID && pref.getValue() == prefValue;    }    return false;}
a9d4d655b19b70cdbe9824cc420ee83364e526a200478fba70afd680009cc19e
appendTo
public void appendTo(StringBuffer buffer)
{}
339e180cc1d01793aae99734b4609109efe5ef9cbc0c73cf57a5ac2febc49ed8
testUserVectorSplitterMapperUserExclusion
public void testUserVectorSplitterMapperUserExclusion() throws Exception
{    Mapper<VarLongWritable, VectorWritable, VarIntWritable, VectorOrPrefWritable>.Context context = EasyMock.createMock(Mapper.Context.class);    context.write(EasyMock.eq(new VarIntWritable(34)), prefOfVectorOrPrefWritableMatches(123L, 0.5f));    context.write(EasyMock.eq(new VarIntWritable(56)), prefOfVectorOrPrefWritableMatches(123L, 0.7f));    EasyMock.replay(context);    FastIDSet usersToRecommendFor = new FastIDSet();    usersToRecommendFor.add(123L);    UserVectorSplitterMapper mapper = new UserVectorSplitterMapper();    setField(mapper, "maxPrefsPerUserConsidered", 10);    setField(mapper, "usersToRecommendFor", usersToRecommendFor);    RandomAccessSparseVector vector = new RandomAccessSparseVector(Integer.MAX_VALUE, 100);    vector.set(34, 0.5);    vector.set(56, 0.7);    mapper.map(new VarLongWritable(123L), new VectorWritable(vector), context);    mapper.map(new VarLongWritable(456L), new VectorWritable(vector), context);    EasyMock.verify(context);}
220511c65cdf64ae687d1496443b2a5af0288e25a662f16e7fce0384df5ab2f5
testUserVectorSplitterMapperOnlySomePrefsConsidered
public void testUserVectorSplitterMapperOnlySomePrefsConsidered() throws Exception
{    Mapper<VarLongWritable, VectorWritable, VarIntWritable, VectorOrPrefWritable>.Context context = EasyMock.createMock(Mapper.Context.class);    context.write(EasyMock.eq(new VarIntWritable(34)), prefOfVectorOrPrefWritableMatchesNaN(123L));    context.write(EasyMock.eq(new VarIntWritable(56)), prefOfVectorOrPrefWritableMatches(123L, 0.7f));    EasyMock.replay(context);    UserVectorSplitterMapper mapper = new UserVectorSplitterMapper();    setField(mapper, "maxPrefsPerUserConsidered", 1);    RandomAccessSparseVector vector = new RandomAccessSparseVector(Integer.MAX_VALUE, 100);    vector.set(34, 0.5);    vector.set(56, 0.7);    mapper.map(new VarLongWritable(123L), new VectorWritable(vector), context);    EasyMock.verify(context);}
5e9e0922c6cda21615b0ff326e8ba9b9dea83354172499e449b7fab5385f1cb6
prefOfVectorOrPrefWritableMatchesNaN
private static VectorOrPrefWritable prefOfVectorOrPrefWritableMatchesNaN(final long userID)
{    EasyMock.reportMatcher(new IArgumentMatcher() {        @Override        public boolean matches(Object argument) {            if (argument instanceof VectorOrPrefWritable) {                VectorOrPrefWritable pref = (VectorOrPrefWritable) argument;                return pref.getUserID() == userID && Float.isNaN(pref.getValue());            }            return false;        }        @Override        public void appendTo(StringBuffer buffer) {        }    });    return null;}
eafe89971eb7ac8d02727bc7a7f2e145a8ad354e94e997283d3ac3af52c92355
matches
public boolean matches(Object argument)
{    if (argument instanceof VectorOrPrefWritable) {        VectorOrPrefWritable pref = (VectorOrPrefWritable) argument;        return pref.getUserID() == userID && Float.isNaN(pref.getValue());    }    return false;}
a9d4d655b19b70cdbe9824cc420ee83364e526a200478fba70afd680009cc19e
appendTo
public void appendTo(StringBuffer buffer)
{}
b0a36696f11f10a038e3ddbc8268ac5160cc3596902d6cd6b2361952094cff3b
testToVectorAndPrefReducer
public void testToVectorAndPrefReducer() throws Exception
{    Reducer<VarIntWritable, VectorOrPrefWritable, VarIntWritable, VectorAndPrefsWritable>.Context context = EasyMock.createMock(Reducer.Context.class);    context.write(EasyMock.eq(new VarIntWritable(1)), vectorAndPrefsWritableMatches(Arrays.asList(123L, 456L), Arrays.asList(1.0f, 2.0f), MathHelper.elem(3, 0.5), MathHelper.elem(7, 0.8)));    EasyMock.replay(context);    Vector similarityColumn = new RandomAccessSparseVector(Integer.MAX_VALUE, 100);    similarityColumn.set(3, 0.5);    similarityColumn.set(7, 0.8);    VectorOrPrefWritable itemPref1 = new VectorOrPrefWritable(123L, 1.0f);    VectorOrPrefWritable itemPref2 = new VectorOrPrefWritable(456L, 2.0f);    VectorOrPrefWritable similarities = new VectorOrPrefWritable(similarityColumn);    new ToVectorAndPrefReducer().reduce(new VarIntWritable(1), Arrays.asList(itemPref1, itemPref2, similarities), context);    EasyMock.verify(context);}
1e1eeea60938fab4240db1f30c573c229d32d531557d3e58e2f5bbe0d02250f5
vectorAndPrefsWritableMatches
private static VectorAndPrefsWritable vectorAndPrefsWritableMatches(final List<Long> userIDs, final List<Float> prefValues, final Vector.Element... elements)
{    EasyMock.reportMatcher(new IArgumentMatcher() {        @Override        public boolean matches(Object argument) {            if (argument instanceof VectorAndPrefsWritable) {                VectorAndPrefsWritable vectorAndPrefs = (VectorAndPrefsWritable) argument;                if (!vectorAndPrefs.getUserIDs().equals(userIDs)) {                    return false;                }                if (!vectorAndPrefs.getValues().equals(prefValues)) {                    return false;                }                return MathHelper.consistsOf(vectorAndPrefs.getVector(), elements);            }            return false;        }        @Override        public void appendTo(StringBuffer buffer) {        }    });    return null;}
eafe89971eb7ac8d02727bc7a7f2e145a8ad354e94e997283d3ac3af52c92355
matches
public boolean matches(Object argument)
{    if (argument instanceof VectorAndPrefsWritable) {        VectorAndPrefsWritable vectorAndPrefs = (VectorAndPrefsWritable) argument;        if (!vectorAndPrefs.getUserIDs().equals(userIDs)) {            return false;        }        if (!vectorAndPrefs.getValues().equals(prefValues)) {            return false;        }        return MathHelper.consistsOf(vectorAndPrefs.getVector(), elements);    }    return false;}
a9d4d655b19b70cdbe9824cc420ee83364e526a200478fba70afd680009cc19e
appendTo
public void appendTo(StringBuffer buffer)
{}
14690597d7111c5a0d9536b0f86ea9e24a4ecf7093d4d7b813020a7c4a9bcad5
testToVectorAndPrefReducerExceptionOn2Vectors
public void testToVectorAndPrefReducerExceptionOn2Vectors() throws Exception
{    Reducer<VarIntWritable, VectorOrPrefWritable, VarIntWritable, VectorAndPrefsWritable>.Context context = EasyMock.createMock(Reducer.Context.class);    EasyMock.replay(context);    Vector similarityColumn1 = new RandomAccessSparseVector(Integer.MAX_VALUE, 100);    Vector similarityColumn2 = new RandomAccessSparseVector(Integer.MAX_VALUE, 100);    VectorOrPrefWritable similarities1 = new VectorOrPrefWritable(similarityColumn1);    VectorOrPrefWritable similarities2 = new VectorOrPrefWritable(similarityColumn2);    try {        new ToVectorAndPrefReducer().reduce(new VarIntWritable(1), Arrays.asList(similarities1, similarities2), context);        fail();    } catch (IllegalStateException e) {        }    EasyMock.verify(context);}
045aed75d7f69343cc954391b373f594458a0f035908ffad5390e6c9a752a6d7
testItemFilterMapper
public void testItemFilterMapper() throws Exception
{    Mapper<LongWritable, Text, VarLongWritable, VarLongWritable>.Context context = EasyMock.createMock(Mapper.Context.class);    context.write(new VarLongWritable(34L), new VarLongWritable(12L));    context.write(new VarLongWritable(78L), new VarLongWritable(56L));    EasyMock.replay(context);    ItemFilterMapper mapper = new ItemFilterMapper();    mapper.map(null, new Text("12,34"), context);    mapper.map(null, new Text("56,78"), context);    EasyMock.verify(context);}
34158d06b390654e47f7e78d480bb22766c1cf52b522c326039870e37feca958
testItemFilterAsVectorAndPrefsReducer
public void testItemFilterAsVectorAndPrefsReducer() throws Exception
{    Reducer<VarLongWritable, VarLongWritable, VarIntWritable, VectorAndPrefsWritable>.Context context = EasyMock.createMock(Reducer.Context.class);    int itemIDIndex = TasteHadoopUtils.idToIndex(123L);    context.write(EasyMock.eq(new VarIntWritable(itemIDIndex)), vectorAndPrefsForFilteringMatches(123L, 456L, 789L));    EasyMock.replay(context);    new ItemFilterAsVectorAndPrefsReducer().reduce(new VarLongWritable(123L), Arrays.asList(new VarLongWritable(456L), new VarLongWritable(789L)), context);    EasyMock.verify(context);}
f41422be4648a2d32ca3fca7b21addb7439d72a8d8ed6cf3bb3cb66203a58d5e
vectorAndPrefsForFilteringMatches
 static VectorAndPrefsWritable vectorAndPrefsForFilteringMatches(final long itemID, final long... userIDs)
{    EasyMock.reportMatcher(new IArgumentMatcher() {        @Override        public boolean matches(Object argument) {            if (argument instanceof VectorAndPrefsWritable) {                VectorAndPrefsWritable vectorAndPrefs = (VectorAndPrefsWritable) argument;                Vector vector = vectorAndPrefs.getVector();                if (vector.getNumNondefaultElements() != 1) {                    return false;                }                if (!Double.isNaN(vector.get(TasteHadoopUtils.idToIndex(itemID)))) {                    return false;                }                if (userIDs.length != vectorAndPrefs.getUserIDs().size()) {                    return false;                }                for (long userID : userIDs) {                    if (!vectorAndPrefs.getUserIDs().contains(userID)) {                        return false;                    }                }                return true;            }            return false;        }        @Override        public void appendTo(StringBuffer buffer) {        }    });    return null;}
eafe89971eb7ac8d02727bc7a7f2e145a8ad354e94e997283d3ac3af52c92355
matches
public boolean matches(Object argument)
{    if (argument instanceof VectorAndPrefsWritable) {        VectorAndPrefsWritable vectorAndPrefs = (VectorAndPrefsWritable) argument;        Vector vector = vectorAndPrefs.getVector();        if (vector.getNumNondefaultElements() != 1) {            return false;        }        if (!Double.isNaN(vector.get(TasteHadoopUtils.idToIndex(itemID)))) {            return false;        }        if (userIDs.length != vectorAndPrefs.getUserIDs().size()) {            return false;        }        for (long userID : userIDs) {            if (!vectorAndPrefs.getUserIDs().contains(userID)) {                return false;            }        }        return true;    }    return false;}
a9d4d655b19b70cdbe9824cc420ee83364e526a200478fba70afd680009cc19e
appendTo
public void appendTo(StringBuffer buffer)
{}
7fa202afc3633d1709fa513f30735102cbc2484c8c0aa9a25b66eab57d0e8e3a
testPartialMultiplyMapper
public void testPartialMultiplyMapper() throws Exception
{    Vector similarityColumn = new RandomAccessSparseVector(Integer.MAX_VALUE, 100);    similarityColumn.set(3, 0.5);    similarityColumn.set(7, 0.8);    Mapper<VarIntWritable, VectorAndPrefsWritable, VarLongWritable, PrefAndSimilarityColumnWritable>.Context context = EasyMock.createMock(Mapper.Context.class);    PrefAndSimilarityColumnWritable one = new PrefAndSimilarityColumnWritable();    PrefAndSimilarityColumnWritable two = new PrefAndSimilarityColumnWritable();    one.set(1.0f, similarityColumn);    two.set(3.0f, similarityColumn);    context.write(EasyMock.eq(new VarLongWritable(123L)), EasyMock.eq(one));    context.write(EasyMock.eq(new VarLongWritable(456L)), EasyMock.eq(two));    EasyMock.replay(context);    VectorAndPrefsWritable vectorAndPrefs = new VectorAndPrefsWritable(similarityColumn, Arrays.asList(123L, 456L), Arrays.asList(1.0f, 3.0f));    new PartialMultiplyMapper().map(new VarIntWritable(1), vectorAndPrefs, context);    EasyMock.verify(context);}
f6c9b546ae38d2050b1e7dde43f015fd8c960091070e6a1aa7689f45a0a91b06
testAggregateAndRecommendReducer
public void testAggregateAndRecommendReducer() throws Exception
{    Reducer<VarLongWritable, PrefAndSimilarityColumnWritable, VarLongWritable, RecommendedItemsWritable>.Context context = EasyMock.createMock(Reducer.Context.class);    context.write(EasyMock.eq(new VarLongWritable(123L)), recommendationsMatch(new MutableRecommendedItem(1L, 2.8f), new MutableRecommendedItem(2L, 2.0f)));    EasyMock.replay(context);    RandomAccessSparseVector similarityColumnOne = new RandomAccessSparseVector(Integer.MAX_VALUE, 100);    similarityColumnOne.set(1, 0.1);    similarityColumnOne.set(2, 0.5);    RandomAccessSparseVector similarityColumnTwo = new RandomAccessSparseVector(Integer.MAX_VALUE, 100);    similarityColumnTwo.set(1, 0.9);    similarityColumnTwo.set(2, 0.5);    List<PrefAndSimilarityColumnWritable> values = Arrays.asList(new PrefAndSimilarityColumnWritable(1.0f, similarityColumnOne), new PrefAndSimilarityColumnWritable(3.0f, similarityColumnTwo));    OpenIntLongHashMap indexItemIDMap = new OpenIntLongHashMap();    indexItemIDMap.put(1, 1L);    indexItemIDMap.put(2, 2L);    AggregateAndRecommendReducer reducer = new AggregateAndRecommendReducer();    setField(reducer, "indexItemIDMap", indexItemIDMap);    setField(reducer, "recommendationsPerUser", 3);    reducer.reduce(new VarLongWritable(123L), values, context);    EasyMock.verify(context);}
dc5ed0439d042e8469a90bae513fc017c1251c4ff95428171aa902d01cef8761
testAggregateAndRecommendReducerExcludeRecommendationsBasedOnOneItem
public void testAggregateAndRecommendReducerExcludeRecommendationsBasedOnOneItem() throws Exception
{    Reducer<VarLongWritable, PrefAndSimilarityColumnWritable, VarLongWritable, RecommendedItemsWritable>.Context context = EasyMock.createMock(Reducer.Context.class);    context.write(EasyMock.eq(new VarLongWritable(123L)), recommendationsMatch(new MutableRecommendedItem(1L, 2.8f)));    EasyMock.replay(context);    RandomAccessSparseVector similarityColumnOne = new RandomAccessSparseVector(Integer.MAX_VALUE, 100);    similarityColumnOne.set(1, 0.1);    RandomAccessSparseVector similarityColumnTwo = new RandomAccessSparseVector(Integer.MAX_VALUE, 100);    similarityColumnTwo.set(1, 0.9);    similarityColumnTwo.set(2, 0.5);    List<PrefAndSimilarityColumnWritable> values = Arrays.asList(new PrefAndSimilarityColumnWritable(1.0f, similarityColumnOne), new PrefAndSimilarityColumnWritable(3.0f, similarityColumnTwo));    OpenIntLongHashMap indexItemIDMap = new OpenIntLongHashMap();    indexItemIDMap.put(1, 1L);    indexItemIDMap.put(2, 2L);    AggregateAndRecommendReducer reducer = new AggregateAndRecommendReducer();    setField(reducer, "indexItemIDMap", indexItemIDMap);    setField(reducer, "recommendationsPerUser", 3);    reducer.reduce(new VarLongWritable(123L), values, context);    EasyMock.verify(context);}
ff97d8914172eca9b45ad7b69e40274e4095566dc2e86e0064812614e177a478
testAggregateAndRecommendReducerLimitNumberOfRecommendations
public void testAggregateAndRecommendReducerLimitNumberOfRecommendations() throws Exception
{    Reducer<VarLongWritable, PrefAndSimilarityColumnWritable, VarLongWritable, RecommendedItemsWritable>.Context context = EasyMock.createMock(Reducer.Context.class);    context.write(EasyMock.eq(new VarLongWritable(123L)), recommendationsMatch(new MutableRecommendedItem(1L, 2.8f)));    EasyMock.replay(context);    RandomAccessSparseVector similarityColumnOne = new RandomAccessSparseVector(Integer.MAX_VALUE, 100);    similarityColumnOne.set(1, 0.1);    similarityColumnOne.set(2, 0.5);    RandomAccessSparseVector similarityColumnTwo = new RandomAccessSparseVector(Integer.MAX_VALUE, 100);    similarityColumnTwo.set(1, 0.9);    similarityColumnTwo.set(2, 0.5);    List<PrefAndSimilarityColumnWritable> values = Arrays.asList(new PrefAndSimilarityColumnWritable(1.0f, similarityColumnOne), new PrefAndSimilarityColumnWritable(3.0f, similarityColumnTwo));    OpenIntLongHashMap indexItemIDMap = new OpenIntLongHashMap();    indexItemIDMap.put(1, 1L);    indexItemIDMap.put(2, 2L);    AggregateAndRecommendReducer reducer = new AggregateAndRecommendReducer();    setField(reducer, "indexItemIDMap", indexItemIDMap);    setField(reducer, "recommendationsPerUser", 1);    reducer.reduce(new VarLongWritable(123L), values, context);    EasyMock.verify(context);}
082d9fd71a86d828ee08b98dc28392512a46aef3f07ce63af555061416c332d9
recommendationsMatch
 static RecommendedItemsWritable recommendationsMatch(final RecommendedItem... items)
{    EasyMock.reportMatcher(new IArgumentMatcher() {        @Override        public boolean matches(Object argument) {            if (argument instanceof RecommendedItemsWritable) {                RecommendedItemsWritable recommendedItemsWritable = (RecommendedItemsWritable) argument;                List<RecommendedItem> expectedItems = Arrays.asList(items);                return expectedItems.equals(recommendedItemsWritable.getRecommendedItems());            }            return false;        }        @Override        public void appendTo(StringBuffer buffer) {        }    });    return null;}
eafe89971eb7ac8d02727bc7a7f2e145a8ad354e94e997283d3ac3af52c92355
matches
public boolean matches(Object argument)
{    if (argument instanceof RecommendedItemsWritable) {        RecommendedItemsWritable recommendedItemsWritable = (RecommendedItemsWritable) argument;        List<RecommendedItem> expectedItems = Arrays.asList(items);        return expectedItems.equals(recommendedItemsWritable.getRecommendedItems());    }    return false;}
a9d4d655b19b70cdbe9824cc420ee83364e526a200478fba70afd680009cc19e
appendTo
public void appendTo(StringBuffer buffer)
{}
84e149d2d106e205f4bab384007b6a4d8366412a8038040918fdf66f78d57f71
testCompleteJob
public void testCompleteJob() throws Exception
{    File inputFile = getTestTempFile("prefs.txt");    File outputDir = getTestTempDir("output");    outputDir.delete();    File similaritiesOutputDir = getTestTempDir("outputSimilarities");    similaritiesOutputDir.delete();    File tmpDir = getTestTempDir("tmp");    writeLines(inputFile, "1,1,5", "1,2,5", "1,3,2", "2,1,2", "2,3,3", "2,4,5", "3,2,5", "3,4,3", "4,1,3", "4,4,5");    RecommenderJob recommenderJob = new RecommenderJob();    Configuration conf = getConfiguration();    conf.set("mapred.input.dir", inputFile.getAbsolutePath());    conf.set("mapred.output.dir", outputDir.getAbsolutePath());    conf.setBoolean("mapred.output.compress", false);    recommenderJob.setConf(conf);    recommenderJob.run(new String[] { "--tempDir", tmpDir.getAbsolutePath(), "--similarityClassname", TanimotoCoefficientSimilarity.class.getName(), "--numRecommendations", "4", "--outputPathForSimilarityMatrix", similaritiesOutputDir.getAbsolutePath() });    Map<Long, List<RecommendedItem>> recommendations = readRecommendations(new File(outputDir, "part-r-00000"));    assertEquals(4, recommendations.size());    for (Entry<Long, List<RecommendedItem>> entry : recommendations.entrySet()) {        long userID = entry.getKey();        List<RecommendedItem> items = entry.getValue();        assertNotNull(items);        RecommendedItem item1 = items.get(0);        if (userID == 1L) {            assertEquals(1, items.size());            assertEquals(4L, item1.getItemID());            assertEquals(4.3, item1.getValue(), 0.05);        }        if (userID == 2L) {            assertEquals(1, items.size());            assertEquals(2L, item1.getItemID());            assertEquals(3.3, item1.getValue(), 0.05);        }        if (userID == 3L) {            assertEquals(2, items.size());            assertEquals(3L, item1.getItemID());            assertEquals(4.1, item1.getValue(), 0.05);            RecommendedItem item2 = items.get(1);            assertEquals(1L, item2.getItemID());            assertEquals(3.7, item2.getValue(), 0.05);        }        if (userID == 4L) {            assertEquals(2, items.size());            assertEquals(2L, item1.getItemID());            assertEquals(4.0, item1.getValue(), 0.05);            RecommendedItem item2 = items.get(1);            assertEquals(3L, item2.getItemID());            assertEquals(3.5, item2.getValue(), 0.05);        }    }    Map<Pair<Long, Long>, Double> similarities = readSimilarities(new File(similaritiesOutputDir, "part-r-00000"));    assertEquals(6, similarities.size());    assertEquals(0.25, similarities.get(new Pair<>(1L, 2L)), EPSILON);    assertEquals(0.6666666666666666, similarities.get(new Pair<>(1L, 3L)), EPSILON);    assertEquals(0.5, similarities.get(new Pair<>(1L, 4L)), EPSILON);    assertEquals(0.3333333333333333, similarities.get(new Pair<>(2L, 3L)), EPSILON);    assertEquals(0.25, similarities.get(new Pair<>(2L, 4L)), EPSILON);    assertEquals(0.25, similarities.get(new Pair<>(3L, 4L)), EPSILON);}
2026ab0ef76f66bf5e099f590a97f31b2950c4e2345295b223759b1e706b34b5
testCompleteJobBoolean
public void testCompleteJobBoolean() throws Exception
{    File inputFile = getTestTempFile("prefs.txt");    File outputDir = getTestTempDir("output");    outputDir.delete();    File tmpDir = getTestTempDir("tmp");    File usersFile = getTestTempFile("users.txt");    writeLines(usersFile, "3");    writeLines(inputFile, "1,1", "1,2", "1,3", "2,1", "2,3", "2,4", "3,2", "3,4", "4,1", "4,4");    RecommenderJob recommenderJob = new RecommenderJob();    Configuration conf = getConfiguration();    conf.set("mapred.input.dir", inputFile.getAbsolutePath());    conf.set("mapred.output.dir", outputDir.getAbsolutePath());    conf.setBoolean("mapred.output.compress", false);    recommenderJob.setConf(conf);    recommenderJob.run(new String[] { "--tempDir", tmpDir.getAbsolutePath(), "--similarityClassname", CooccurrenceCountSimilarity.class.getName(), "--booleanData", "true", "--usersFile", usersFile.getAbsolutePath() });    Map<Long, List<RecommendedItem>> recommendations = readRecommendations(new File(outputDir, "part-r-00000"));    List<RecommendedItem> recommendedToCow = recommendations.get(3L);    assertEquals(2, recommendedToCow.size());    RecommendedItem item1 = recommendedToCow.get(0);    RecommendedItem item2 = recommendedToCow.get(1);    assertEquals(1L, item1.getItemID());    assertEquals(3L, item2.getItemID());    /* predicted pref must be the sum of similarities:    *    item1: coocc(burger, hotdog) + coocc(burger, icecream) = 3     *    item2: coocc(berries, hotdog) + coocc(berries, icecream) = 2 */    assertEquals(3, item1.getValue(), 0.05);    assertEquals(2, item2.getValue(), 0.05);}
7053578326fe0d2d25c2807d2f70924671097c21a9768acc163335d3a2e79d51
testCompleteJobWithFiltering
public void testCompleteJobWithFiltering() throws Exception
{    File inputFile = getTestTempFile("prefs.txt");    File userFile = getTestTempFile("users.txt");    File filterFile = getTestTempFile("filter.txt");    File outputDir = getTestTempDir("output");    outputDir.delete();    File tmpDir = getTestTempDir("tmp");    writeLines(inputFile, "1,1,5", "1,2,5", "1,3,2", "2,1,2", "2,3,3", "2,4,5", "3,2,5", "3,4,3", "4,1,3", "4,4,5");    /* only compute recommendations for the donkey */    writeLines(userFile, "4");    /* do not recommend the hotdog for the donkey */    writeLines(filterFile, "4,2");    RecommenderJob recommenderJob = new RecommenderJob();    Configuration conf = getConfiguration();    conf.set("mapred.input.dir", inputFile.getAbsolutePath());    conf.set("mapred.output.dir", outputDir.getAbsolutePath());    conf.setBoolean("mapred.output.compress", false);    recommenderJob.setConf(conf);    recommenderJob.run(new String[] { "--tempDir", tmpDir.getAbsolutePath(), "--similarityClassname", TanimotoCoefficientSimilarity.class.getName(), "--numRecommendations", "1", "--usersFile", userFile.getAbsolutePath(), "--filterFile", filterFile.getAbsolutePath() });    Map<Long, List<RecommendedItem>> recommendations = readRecommendations(new File(outputDir, "part-r-00000"));    assertEquals(1, recommendations.size());    assertTrue(recommendations.containsKey(4L));    assertEquals(1, recommendations.get(4L).size());    /* berries should have been recommended to the donkey */    RecommendedItem recommendedItem = recommendations.get(4L).get(0);    assertEquals(3L, recommendedItem.getItemID());    assertEquals(3.5, recommendedItem.getValue(), 0.05);}
7d8aefdf5bf48c0620a26da18cdfb4725c0eb277b1d726715fbe96a43e4ae38b
readSimilarities
 static Map<Pair<Long, Long>, Double> readSimilarities(File file) throws IOException
{    Map<Pair<Long, Long>, Double> similarities = Maps.newHashMap();    for (String line : new FileLineIterable(file)) {        String[] parts = line.split("\t");        similarities.put(new Pair<>(Long.parseLong(parts[0]), Long.parseLong(parts[1])), Double.parseDouble(parts[2]));    }    return similarities;}
f5f287df481315c779d12f8eebc0f2e44cbff9009a0c5e20a8a9c613e7c06d3c
readRecommendations
 static Map<Long, List<RecommendedItem>> readRecommendations(File file) throws IOException
{    Map<Long, List<RecommendedItem>> recommendations = Maps.newHashMap();    for (String line : new FileLineIterable(file)) {        String[] keyValue = line.split("\t");        long userID = Long.parseLong(keyValue[0]);        String[] tokens = keyValue[1].replaceAll("\\[", "").replaceAll("\\]", "").split(",");        List<RecommendedItem> items = Lists.newLinkedList();        for (String token : tokens) {            String[] itemTokens = token.split(":");            long itemID = Long.parseLong(itemTokens[0]);            float value = Float.parseFloat(itemTokens[1]);            items.add(new GenericRecommendedItem(itemID, value));        }        recommendations.put(userID, items);    }    return recommendations;}
29c85bcb0916145301df621a579e5df799801d03dd99dc3752997678920ddac2
testToUsersReducerMinPreferencesUserIgnored
public void testToUsersReducerMinPreferencesUserIgnored() throws Exception
{    Reducer<VarLongWritable, VarLongWritable, VarLongWritable, VectorWritable>.Context context = EasyMock.createMock(Reducer.Context.class);    ToUserVectorsReducer reducer = new ToUserVectorsReducer();    setField(reducer, "minPreferences", 2);    EasyMock.replay(context);    reducer.reduce(new VarLongWritable(123), Collections.singletonList(new VarLongWritable(456)), context);    EasyMock.verify(context);}
808b36ae02bc5c893e80a128e0215f55787f5defd8f4c0ca5147069cf90a0351
testToUsersReducerMinPreferencesUserPasses
public void testToUsersReducerMinPreferencesUserPasses() throws Exception
{    Reducer<VarLongWritable, VarLongWritable, VarLongWritable, VectorWritable>.Context context = EasyMock.createMock(Reducer.Context.class);    Counter userCounters = EasyMock.createMock(Counter.class);    ToUserVectorsReducer reducer = new ToUserVectorsReducer();    setField(reducer, "minPreferences", 2);    EasyMock.expect(context.getCounter(ToUserVectorsReducer.Counters.USERS)).andReturn(userCounters);    userCounters.increment(1);    context.write(EasyMock.eq(new VarLongWritable(123)), MathHelper.vectorMatches(MathHelper.elem(TasteHadoopUtils.idToIndex(456L), 1.0), MathHelper.elem(TasteHadoopUtils.idToIndex(789L), 1.0)));    EasyMock.replay(context, userCounters);    reducer.reduce(new VarLongWritable(123), Arrays.asList(new VarLongWritable(456), new VarLongWritable(789)), context);    EasyMock.verify(context, userCounters);}
ad785c432a41157d23de7e4c7a1d723eb92533861e9458154c6e6bd46d9f0ad5
testMostSimilarItemsPairsMapper
public void testMostSimilarItemsPairsMapper() throws Exception
{    OpenIntLongHashMap indexItemIDMap = new OpenIntLongHashMap();    indexItemIDMap.put(12, 12L);    indexItemIDMap.put(34, 34L);    indexItemIDMap.put(56, 56L);    Mapper<IntWritable, VectorWritable, EntityEntityWritable, DoubleWritable>.Context context = EasyMock.createMock(Mapper.Context.class);    context.write(new EntityEntityWritable(34L, 56L), new DoubleWritable(0.9));    EasyMock.replay(context);    Vector vector = new RandomAccessSparseVector(Integer.MAX_VALUE);    vector.set(12, 0.2);    vector.set(56, 0.9);    ItemSimilarityJob.MostSimilarItemPairsMapper mapper = new ItemSimilarityJob.MostSimilarItemPairsMapper();    setField(mapper, "indexItemIDMap", indexItemIDMap);    setField(mapper, "maxSimilarItemsPerItem", 1);    mapper.map(new IntWritable(34), new VectorWritable(vector), context);    EasyMock.verify(context);}
9a994b0846e4d0cfa4ea89293b6bbb7af49c30b495fcaa1964e52bbe1836d305
testMostSimilarItemPairsReducer
public void testMostSimilarItemPairsReducer() throws Exception
{    Reducer<EntityEntityWritable, DoubleWritable, EntityEntityWritable, DoubleWritable>.Context context = EasyMock.createMock(Reducer.Context.class);    context.write(new EntityEntityWritable(123L, 456L), new DoubleWritable(0.5));    EasyMock.replay(context);    new ItemSimilarityJob.MostSimilarItemPairsReducer().reduce(new EntityEntityWritable(123L, 456L), Arrays.asList(new DoubleWritable(0.5), new DoubleWritable(0.5)), context);    EasyMock.verify(context);}
84e149d2d106e205f4bab384007b6a4d8366412a8038040918fdf66f78d57f71
testCompleteJob
public void testCompleteJob() throws Exception
{    File inputFile = getTestTempFile("prefs.txt");    File outputDir = getTestTempDir("output");    outputDir.delete();    File tmpDir = getTestTempDir("tmp");    writeLines(inputFile, "2,1,1", "1,2,1", "3,4,1", "1,3,2", "2,3,1");    ItemSimilarityJob similarityJob = new ItemSimilarityJob();    Configuration conf = getConfiguration();    conf.set("mapred.input.dir", inputFile.getAbsolutePath());    conf.set("mapred.output.dir", outputDir.getAbsolutePath());    conf.setBoolean("mapred.output.compress", false);    similarityJob.setConf(conf);    similarityJob.run(new String[] { "--tempDir", tmpDir.getAbsolutePath(), "--similarityClassname", CosineSimilarity.class.getName() });    File outPart = outputDir.listFiles(new FilenameFilter() {        @Override        public boolean accept(File dir, String name) {            return name.startsWith("part-");        }    })[0];    BufferedReader reader = Files.newReader(outPart, Charsets.UTF_8);    String line;    int currentLine = 1;    while ((line = reader.readLine()) != null) {        String[] tokens = TAB.split(line);        long itemAID = Long.parseLong(tokens[0]);        long itemBID = Long.parseLong(tokens[1]);        double similarity = Double.parseDouble(tokens[2]);        if (currentLine == 1) {            assertEquals(1L, itemAID);            assertEquals(3L, itemBID);            assertEquals(0.45, similarity, 0.01);        }        if (currentLine == 2) {            assertEquals(2L, itemAID);            assertEquals(3L, itemBID);            assertEquals(0.89, similarity, 0.01);        }        currentLine++;    }    int linesWritten = currentLine - 1;    assertEquals(2, linesWritten);}
ca62bfdc0472b2de6468644412d9ad6b432937742edcb5ca65b1f23b694b5853
accept
public boolean accept(File dir, String name)
{    return name.startsWith("part-");}
48118a023a67fa21c197cd2b9a583997a6d9942f45159aa42e2a055a097df3c3
testMaxSimilaritiesPerItem
public void testMaxSimilaritiesPerItem() throws Exception
{    File inputFile = getTestTempFile("prefsForMaxSimilarities.txt");    File outputDir = getTestTempDir("output");    outputDir.delete();    File tmpDir = getTestTempDir("tmp");    writeLines(inputFile, "1,1,1", "1,3,1", "2,2,1", "2,3,1", "3,1,1", "3,2,1", "4,1,1", "4,2,1", "4,3,1", "5,2,1", "6,1,1", "6,2,1");    ItemSimilarityJob similarityJob = new ItemSimilarityJob();    Configuration conf = getConfiguration();    conf.set("mapred.input.dir", inputFile.getAbsolutePath());    conf.set("mapred.output.dir", outputDir.getAbsolutePath());    conf.setBoolean("mapred.output.compress", false);    similarityJob.setConf(conf);    similarityJob.run(new String[] { "--tempDir", tmpDir.getAbsolutePath(), "--similarityClassname", TanimotoCoefficientSimilarity.class.getName(), "--maxSimilaritiesPerItem", "1" });    File outPart = outputDir.listFiles(new FilenameFilter() {        @Override        public boolean accept(File dir, String name) {            return name.startsWith("part-");        }    })[0];    BufferedReader reader = Files.newReader(outPart, Charsets.UTF_8);    String line;    int currentLine = 1;    while ((line = reader.readLine()) != null) {        String[] tokens = TAB.split(line);        long itemAID = Long.parseLong(tokens[0]);        long itemBID = Long.parseLong(tokens[1]);        double similarity = Double.parseDouble(tokens[2]);        if (currentLine == 1) {            assertEquals(1L, itemAID);            assertEquals(2L, itemBID);            assertEquals(0.5, similarity, 0.0001);        }        if (currentLine == 2) {            assertEquals(1L, itemAID);            assertEquals(3L, itemBID);            assertEquals(0.4, similarity, 0.0001);        }        currentLine++;    }    int linesWritten = currentLine - 1;    assertEquals(2, linesWritten);}
ca62bfdc0472b2de6468644412d9ad6b432937742edcb5ca65b1f23b694b5853
accept
public boolean accept(File dir, String name)
{    return name.startsWith("part-");}
eb3625dd8928da51aa2146630d2cb8fd0b11d0081acae2ffc41042dd8547497c
testWithinRange
public void testWithinRange()
{    assertTrue(TasteHadoopUtils.idToIndex(0) >= 0);    assertTrue(TasteHadoopUtils.idToIndex(0) < Integer.MAX_VALUE);    assertTrue(TasteHadoopUtils.idToIndex(1) >= 0);    assertTrue(TasteHadoopUtils.idToIndex(1) < Integer.MAX_VALUE);    assertTrue(TasteHadoopUtils.idToIndex(Long.MAX_VALUE) >= 0);    assertTrue(TasteHadoopUtils.idToIndex(Long.MAX_VALUE) < Integer.MAX_VALUE);    assertTrue(TasteHadoopUtils.idToIndex(Integer.MAX_VALUE) >= 0);    assertTrue(TasteHadoopUtils.idToIndex(Integer.MAX_VALUE) < Integer.MAX_VALUE);}
ff93da10bd60dc43e61df38c515c6642bce96729c93f5c488a57dd65207de29d
topK
public void topK()
{    float[] ratings = { 0.5f, 0.6f, 0.7f, 2.0f, 0.0f };    List<RecommendedItem> topItems = findTop(ratings, 2);    assertEquals(2, topItems.size());    assertEquals(3L, topItems.get(0).getItemID());    assertEquals(2.0f, topItems.get(0).getValue(), MahoutTestCase.EPSILON);    assertEquals(2L, topItems.get(1).getItemID());    assertEquals(0.7f, topItems.get(1).getValue(), MahoutTestCase.EPSILON);}
945ea3f0142d50d5d03475c0722162d9be2ad5639360caf00c3f388cdcc31f1a
topKInputSmallerThanK
public void topKInputSmallerThanK()
{    float[] ratings = { 0.7f, 2.0f };    List<RecommendedItem> topItems = findTop(ratings, 3);    assertEquals(2, topItems.size());    assertEquals(1L, topItems.get(0).getItemID());    assertEquals(2.0f, topItems.get(0).getValue(), MahoutTestCase.EPSILON);    assertEquals(0L, topItems.get(1).getItemID());    assertEquals(0.7f, topItems.get(1).getValue(), MahoutTestCase.EPSILON);}
f4a1630fc78f9b49f3075cee8de3d4c0f6378be56e18cd0036ee466f349414ea
findTop
private static List<RecommendedItem> findTop(float[] ratings, int k)
{    TopItemsQueue queue = new TopItemsQueue(k);    for (int item = 0; item < ratings.length; item++) {        MutableRecommendedItem top = queue.top();        if (ratings[item] > top.getValue()) {            top.set(item, ratings[item]);            queue.updateTop();        }    }    return queue.getTopItems();}
2417ed0a986d902851335a527fcd3730cccac0eb65f5a18e489750a2519dd385
testGetSet
public void testGetSet()
{    BitSet bitSet = new BitSet(NUM_BITS);    for (int i = 0; i < NUM_BITS; i++) {        assertFalse(bitSet.get(i));    }    bitSet.set(0);    bitSet.set(NUM_BITS - 1);    assertTrue(bitSet.get(0));    assertTrue(bitSet.get(NUM_BITS - 1));}
7cf04f8dbf13ae403496773053dfaf214fda00f0534d57a6525ffed48821f520
testBounds1
public void testBounds1()
{    BitSet bitSet = new BitSet(NUM_BITS);    bitSet.set(1000);}
4551030ebfe39b646b17a71f1a0ff2b756ca02fe546fb0e04338240f99bc2d2d
testBounds2
public void testBounds2()
{    BitSet bitSet = new BitSet(NUM_BITS);    bitSet.set(-1);}
3deceb959d5bccbc206b56a7d66d87a97414b3f736f3985705b56a10bf6f42a7
testClear
public void testClear()
{    BitSet bitSet = new BitSet(NUM_BITS);    for (int i = 0; i < NUM_BITS; i++) {        bitSet.set(i);    }    for (int i = 0; i < NUM_BITS; i++) {        assertTrue(bitSet.get(i));    }    bitSet.clear();    for (int i = 0; i < NUM_BITS; i++) {        assertFalse(bitSet.get(i));    }}
96c2a1fe93d778b1d5e6b1e73fdf173e59b3a9a00d81960d19645fbb20713b7f
testClone
public void testClone()
{    BitSet bitSet = new BitSet(NUM_BITS);    bitSet.set(NUM_BITS - 1);    bitSet = bitSet.clone();    assertTrue(bitSet.get(NUM_BITS - 1));}
d9dea61ecca126bb2779eee45fb9344f0b28e483321b556963f13863088d5e46
testLotsOfGets
public void testLotsOfGets() throws TasteException
{    Retriever<Object, Object> retriever = new IdentityRetriever();    Cache<Object, Object> cache = new Cache<>(retriever, 1000);    for (int i = 0; i < 1000000; i++) {        assertEquals(i, cache.get(i));    }}
ed1178f214a848480289e222546606d980b0c1fadec00ab0a9198ac4bbec994f
testMixedUsage
public void testMixedUsage() throws TasteException
{    Random random = RandomUtils.getRandom();    Retriever<Object, Object> retriever = new IdentityRetriever();    Cache<Object, Object> cache = new Cache<>(retriever, 1000);    for (int i = 0; i < 1000000; i++) {        double r = random.nextDouble();        if (r < 0.01) {            cache.clear();        } else if (r < 0.1) {            cache.remove(r - 100);        } else {            assertEquals(i, cache.get(i));        }    }}
aafd7421e38130198532fd108849e657b4543a16c0f6109542081a652fff3539
get
public Object get(Object key) throws TasteException
{    return key;}
8ede699c73f8ae847dd65f16026b10e9bf2fcd38a77cbdb34e6e3002164f7f99
testPutAndGet
public void testPutAndGet()
{    FastByIDMap<Long> map = new FastByIDMap<>();    assertNull(map.get(500000L));    map.put(500000L, 2L);    assertEquals(2L, (long) map.get(500000L));}
1fb42763547253cf7ffda7bc5ce98fdf5b96f7ca09e3b84b3ad86b00938441dc
testRemove
public void testRemove()
{    FastByIDMap<Long> map = new FastByIDMap<>();    map.put(500000L, 2L);    map.remove(500000L);    assertEquals(0, map.size());    assertTrue(map.isEmpty());    assertNull(map.get(500000L));}
3deceb959d5bccbc206b56a7d66d87a97414b3f736f3985705b56a10bf6f42a7
testClear
public void testClear()
{    FastByIDMap<Long> map = new FastByIDMap<>();    map.put(500000L, 2L);    map.clear();    assertEquals(0, map.size());    assertTrue(map.isEmpty());    assertNull(map.get(500000L));}
df4a8c8728da0940562e2f65033dc83c9b700738a9c5d2cf3f54790b92a0dd58
testSizeEmpty
public void testSizeEmpty()
{    FastByIDMap<Long> map = new FastByIDMap<>();    assertEquals(0, map.size());    assertTrue(map.isEmpty());    map.put(500000L, 2L);    assertEquals(1, map.size());    assertFalse(map.isEmpty());    map.remove(500000L);    assertEquals(0, map.size());    assertTrue(map.isEmpty());}
20dca437609259dae56179515bfdf74b7660d55fbe1edebe9678de269e6eb2fa
testContains
public void testContains()
{    FastByIDMap<String> map = buildTestFastMap();    assertTrue(map.containsKey(500000L));    assertTrue(map.containsKey(47L));    assertTrue(map.containsKey(2L));    assertTrue(map.containsValue("alpha"));    assertTrue(map.containsValue("bang"));    assertTrue(map.containsValue("beta"));    assertFalse(map.containsKey(999));    assertFalse(map.containsValue("something"));}
eff3199c1a80e919f1837a4ed1d834312324a46cc94bd2825cf89d4bc2bde9de
testRehash
public void testRehash()
{    FastByIDMap<String> map = buildTestFastMap();    map.remove(500000L);    map.rehash();    assertNull(map.get(500000L));    assertEquals("bang", map.get(47L));}
69653bb6db174c7afb1ec8e557f72fe8161b3cb1344138a9e489b27a59db836c
testGrow
public void testGrow()
{    FastByIDMap<String> map = new FastByIDMap<>(1, 1);    map.put(500000L, "alpha");    map.put(47L, "bang");    assertNull(map.get(500000L));    assertEquals("bang", map.get(47L));}
e3d7bcb3901f9e8aedc865d9ca7abdd2d168cb86a60d9a589db9b548e52ce68b
testVersusHashMap
public void testVersusHashMap()
{    FastByIDMap<String> actual = new FastByIDMap<>();    Map<Long, String> expected = new HashMap<>(1000000);    Random r = RandomUtils.getRandom();    for (int i = 0; i < 1000000; i++) {        double d = r.nextDouble();        Long key = (long) r.nextInt(100);        if (d < 0.4) {            assertEquals(expected.get(key), actual.get(key));        } else {            if (d < 0.7) {                assertEquals(expected.put(key, "bang"), actual.put(key, "bang"));            } else {                assertEquals(expected.remove(key), actual.remove(key));            }            assertEquals(expected.size(), actual.size());            assertEquals(expected.isEmpty(), actual.isEmpty());        }    }}
3bf3512fcac5bbd972aef924f61ae208b4f6d41fbfdfec26d27a473c8e5af507
testMaxSize
public void testMaxSize()
{    FastByIDMap<String> map = new FastByIDMap<>();    map.put(4, "bang");    assertEquals(1, map.size());    map.put(47L, "bang");    assertEquals(2, map.size());    assertNull(map.get(500000L));    map.put(47L, "buzz");    assertEquals(2, map.size());    assertEquals("buzz", map.get(47L));}
f4b7ebb37c6db1dec197d897d630c6be0a6e8434ba18682c6b5524d8360a3998
buildTestFastMap
private static FastByIDMap<String> buildTestFastMap()
{    FastByIDMap<String> map = new FastByIDMap<>();    map.put(500000L, "alpha");    map.put(47L, "bang");    map.put(2L, "beta");    return map;}
96fc9f152a62e1016ec85608221de3a9190f94e0b03356e8eb845f82d2a96283
testContainsAndAdd
public void testContainsAndAdd()
{    FastIDSet set = new FastIDSet();    assertFalse(set.contains(1));    set.add(1);    assertTrue(set.contains(1));}
1fb42763547253cf7ffda7bc5ce98fdf5b96f7ca09e3b84b3ad86b00938441dc
testRemove
public void testRemove()
{    FastIDSet set = new FastIDSet();    set.add(1);    set.remove(1);    assertEquals(0, set.size());    assertTrue(set.isEmpty());    assertFalse(set.contains(1));}
3deceb959d5bccbc206b56a7d66d87a97414b3f736f3985705b56a10bf6f42a7
testClear
public void testClear()
{    FastIDSet set = new FastIDSet();    set.add(1);    set.clear();    assertEquals(0, set.size());    assertTrue(set.isEmpty());    assertFalse(set.contains(1));}
df4a8c8728da0940562e2f65033dc83c9b700738a9c5d2cf3f54790b92a0dd58
testSizeEmpty
public void testSizeEmpty()
{    FastIDSet set = new FastIDSet();    assertEquals(0, set.size());    assertTrue(set.isEmpty());    set.add(1);    assertEquals(1, set.size());    assertFalse(set.isEmpty());    set.remove(1);    assertEquals(0, set.size());    assertTrue(set.isEmpty());}
20dca437609259dae56179515bfdf74b7660d55fbe1edebe9678de269e6eb2fa
testContains
public void testContains()
{    FastIDSet set = buildTestFastSet();    assertTrue(set.contains(1));    assertTrue(set.contains(2));    assertTrue(set.contains(3));    assertFalse(set.contains(4));}
c6a82e4fb99799f428e15863ec87d21482373cd08b3610ab77c87e0b4883e50c
testReservedValues
public void testReservedValues()
{    FastIDSet set = new FastIDSet();    try {        set.add(Long.MIN_VALUE);        fail("Should have thrown IllegalArgumentException");    } catch (IllegalArgumentException iae) {        }    assertFalse(set.contains(Long.MIN_VALUE));    try {        set.add(Long.MAX_VALUE);        fail("Should have thrown IllegalArgumentException");    } catch (IllegalArgumentException iae) {        }    assertFalse(set.contains(Long.MAX_VALUE));}
eff3199c1a80e919f1837a4ed1d834312324a46cc94bd2825cf89d4bc2bde9de
testRehash
public void testRehash()
{    FastIDSet set = buildTestFastSet();    set.remove(1);    set.rehash();    assertFalse(set.contains(1));}
69653bb6db174c7afb1ec8e557f72fe8161b3cb1344138a9e489b27a59db836c
testGrow
public void testGrow()
{    FastIDSet set = new FastIDSet(1);    set.add(1);    set.add(2);    assertTrue(set.contains(1));    assertTrue(set.contains(2));}
67da42917796fb34c2430d36639acd5bccfa9735379b7ead28fbb27a007e4b32
testIterator
public void testIterator()
{    FastIDSet set = buildTestFastSet();    Collection<Long> expected = Sets.newHashSetWithExpectedSize(3);    expected.add(1L);    expected.add(2L);    expected.add(3L);    LongPrimitiveIterator it = set.iterator();    while (it.hasNext()) {        expected.remove(it.nextLong());    }    assertTrue(expected.isEmpty());}
353a21ee95112b2cc356b20ec55d6176a99de77ff56161c978aa69b4aeb8bc88
testVersusHashSet
public void testVersusHashSet()
{    FastIDSet actual = new FastIDSet(1);    Collection<Integer> expected = Sets.newHashSetWithExpectedSize(1000000);    Random r = RandomUtils.getRandom();    for (int i = 0; i < 1000000; i++) {        double d = r.nextDouble();        Integer key = r.nextInt(100);        if (d < 0.4) {            assertEquals(expected.contains(key), actual.contains(key));        } else {            if (d < 0.7) {                assertEquals(expected.add(key), actual.add(key));            } else {                assertEquals(expected.remove(key), actual.remove(key));            }            assertEquals(expected.size(), actual.size());            assertEquals(expected.isEmpty(), actual.isEmpty());        }    }}
8b1958ac0d820c3b62aca231825ac182722c4adb0e3cabd5622fc2e6f32fdd78
buildTestFastSet
private static FastIDSet buildTestFastSet()
{    FastIDSet set = new FastIDSet();    set.add(1);    set.add(2);    set.add(3);    return set;}
8ede699c73f8ae847dd65f16026b10e9bf2fcd38a77cbdb34e6e3002164f7f99
testPutAndGet
public void testPutAndGet()
{    Map<String, String> map = new FastMap<>();    assertNull(map.get("foo"));    map.put("foo", "bar");    assertEquals("bar", map.get("foo"));}
1fb42763547253cf7ffda7bc5ce98fdf5b96f7ca09e3b84b3ad86b00938441dc
testRemove
public void testRemove()
{    Map<String, String> map = new FastMap<>();    map.put("foo", "bar");    map.remove("foo");    assertEquals(0, map.size());    assertTrue(map.isEmpty());    assertNull(map.get("foo"));}
3deceb959d5bccbc206b56a7d66d87a97414b3f736f3985705b56a10bf6f42a7
testClear
public void testClear()
{    Map<String, String> map = new FastMap<>();    map.put("foo", "bar");    map.clear();    assertEquals(0, map.size());    assertTrue(map.isEmpty());    assertNull(map.get("foo"));}
df4a8c8728da0940562e2f65033dc83c9b700738a9c5d2cf3f54790b92a0dd58
testSizeEmpty
public void testSizeEmpty()
{    Map<String, String> map = new FastMap<>();    assertEquals(0, map.size());    assertTrue(map.isEmpty());    map.put("foo", "bar");    assertEquals(1, map.size());    assertFalse(map.isEmpty());    map.remove("foo");    assertEquals(0, map.size());    assertTrue(map.isEmpty());}
20dca437609259dae56179515bfdf74b7660d55fbe1edebe9678de269e6eb2fa
testContains
public void testContains()
{    FastMap<String, String> map = buildTestFastMap();    assertTrue(map.containsKey("foo"));    assertTrue(map.containsKey("baz"));    assertTrue(map.containsKey("alpha"));    assertTrue(map.containsValue("bar"));    assertTrue(map.containsValue("bang"));    assertTrue(map.containsValue("beta"));    assertFalse(map.containsKey("something"));    assertFalse(map.containsValue("something"));}
974d802d835f879e93a2acb6c1f343619dca71743b8f4388bbe5cfce31a60102
testNull1
public void testNull1()
{    Map<String, String> map = new FastMap<>();    assertNull(map.get(null));    map.put(null, "bar");}
a2eba5ef32f73a52133ef81f91f0ab6556f2f420643b7ed0476e7fd60c168082
testNull2
public void testNull2()
{    Map<String, String> map = new FastMap<>();    map.put("foo", null);}
eff3199c1a80e919f1837a4ed1d834312324a46cc94bd2825cf89d4bc2bde9de
testRehash
public void testRehash()
{    FastMap<String, String> map = buildTestFastMap();    map.remove("foo");    map.rehash();    assertNull(map.get("foo"));    assertEquals("bang", map.get("baz"));}
69653bb6db174c7afb1ec8e557f72fe8161b3cb1344138a9e489b27a59db836c
testGrow
public void testGrow()
{    Map<String, String> map = new FastMap<>(1, FastMap.NO_MAX_SIZE);    map.put("foo", "bar");    map.put("baz", "bang");    assertEquals("bar", map.get("foo"));    assertEquals("bang", map.get("baz"));}
0525d255ee5fc13d229ac64b23b42c19e29e32510f311a56126e5298934760c9
testKeySet
public void testKeySet()
{    FastMap<String, String> map = buildTestFastMap();    Collection<String> expected = Sets.newHashSetWithExpectedSize(3);    expected.add("foo");    expected.add("baz");    expected.add("alpha");    Set<String> actual = map.keySet();    assertTrue(expected.containsAll(actual));    assertTrue(actual.containsAll(expected));    Iterator<String> it = actual.iterator();    while (it.hasNext()) {        String value = it.next();        if (!"baz".equals(value)) {            it.remove();        }    }    assertTrue(map.containsKey("baz"));    assertFalse(map.containsKey("foo"));    assertFalse(map.containsKey("alpha"));}
3f5ece75eb7b59fe0748408c1200fb1e591f804de9dcc7d9e33265c5a96b4897
testValues
public void testValues()
{    FastMap<String, String> map = buildTestFastMap();    Collection<String> expected = Sets.newHashSetWithExpectedSize(3);    expected.add("bar");    expected.add("bang");    expected.add("beta");    Collection<String> actual = map.values();    assertTrue(expected.containsAll(actual));    assertTrue(actual.containsAll(expected));    Iterator<String> it = actual.iterator();    while (it.hasNext()) {        String value = it.next();        if (!"bang".equals(value)) {            it.remove();        }    }    assertTrue(map.containsValue("bang"));    assertFalse(map.containsValue("bar"));    assertFalse(map.containsValue("beta"));}
30bd2b4ccbea32a28035ed6930ed59565e20d16e5429c29ab5074c69faf5722d
testEntrySet
public void testEntrySet()
{    FastMap<String, String> map = buildTestFastMap();    Set<Map.Entry<String, String>> actual = map.entrySet();    Collection<String> expectedKeys = Sets.newHashSetWithExpectedSize(3);    expectedKeys.add("foo");    expectedKeys.add("baz");    expectedKeys.add("alpha");    Collection<String> expectedValues = Sets.newHashSetWithExpectedSize(3);    expectedValues.add("bar");    expectedValues.add("bang");    expectedValues.add("beta");    assertEquals(3, actual.size());    for (Map.Entry<String, String> entry : actual) {        expectedKeys.remove(entry.getKey());        expectedValues.remove(entry.getValue());    }    assertEquals(0, expectedKeys.size());    assertEquals(0, expectedValues.size());}
e3d7bcb3901f9e8aedc865d9ca7abdd2d168cb86a60d9a589db9b548e52ce68b
testVersusHashMap
public void testVersusHashMap()
{    Map<Integer, String> actual = new FastMap<>(1, 1000000);    Map<Integer, String> expected = Maps.newHashMapWithExpectedSize(1000000);    Random r = RandomUtils.getRandom();    for (int i = 0; i < 1000000; i++) {        double d = r.nextDouble();        Integer key = r.nextInt(100);        if (d < 0.4) {            assertEquals(expected.get(key), actual.get(key));        } else {            if (d < 0.7) {                assertEquals(expected.put(key, "foo"), actual.put(key, "foo"));            } else {                assertEquals(expected.remove(key), actual.remove(key));            }            assertEquals(expected.size(), actual.size());            assertEquals(expected.isEmpty(), actual.isEmpty());        }    }}
3bf3512fcac5bbd972aef924f61ae208b4f6d41fbfdfec26d27a473c8e5af507
testMaxSize
public void testMaxSize()
{    Map<String, String> map = new FastMap<>(1, 1);    map.put("foo", "bar");    assertEquals(1, map.size());    map.put("baz", "bang");    assertEquals(1, map.size());    assertNull(map.get("foo"));    map.put("baz", "buzz");    assertEquals(1, map.size());    assertEquals("buzz", map.get("baz"));}
8f165cd2f887b7bb804f52baf3ff94fe777fff97b685d5fb568674062ee6b37d
buildTestFastMap
private static FastMap<String, String> buildTestFastMap()
{    FastMap<String, String> map = new FastMap<>();    map.put("foo", "bar");    map.put("baz", "bang");    map.put("alpha", "beta");    return map;}
291a38bf0617c147862fc084cbc82fd965ca5a08486114e141ccb538dfee1a08
testAverage
public void testAverage()
{    RunningAverage avg = new FullRunningAverage();    RunningAverage inverted = new InvertedRunningAverage(avg);    assertEquals(0, inverted.getCount());    avg.addDatum(1.0);    assertEquals(1, inverted.getCount());    assertEquals(-1.0, inverted.getAverage(), EPSILON);    avg.addDatum(2.0);    assertEquals(2, inverted.getCount());    assertEquals(-1.5, inverted.getAverage(), EPSILON);}
104ec2f2ba15624059c5773be384582f0eda1956cfbe604506d1c03260717aa3
testUnsupported1
public void testUnsupported1()
{    RunningAverage inverted = new InvertedRunningAverage(new FullRunningAverage());    inverted.addDatum(1.0);}
105b36ecaa9971dbf026e099fa07d22857e0ab1831c11a91da052fddb1196d7c
testUnsupported2
public void testUnsupported2()
{    RunningAverage inverted = new InvertedRunningAverage(new FullRunningAverage());    inverted.changeDatum(1.0);}
c5eb959f17fc322a9f7e8b85a94b380d8848c0f5fe3518463628dc3ad20115f7
testUnsupported3
public void testUnsupported3()
{    RunningAverage inverted = new InvertedRunningAverage(new FullRunningAverage());    inverted.removeDatum(1.0);}
f389c5cf73a53e982b51ef15ac8173b1fe36a6717ddfbcd24d3d3decf42826a1
testAverageAndStdDev
public void testAverageAndStdDev()
{    RunningAverageAndStdDev avg = new FullRunningAverageAndStdDev();    RunningAverageAndStdDev inverted = new InvertedRunningAverageAndStdDev(avg);    assertEquals(0, inverted.getCount());    avg.addDatum(1.0);    assertEquals(1, inverted.getCount());    assertEquals(-1.0, inverted.getAverage(), EPSILON);    avg.addDatum(2.0);    assertEquals(2, inverted.getCount());    assertEquals(-1.5, inverted.getAverage(), EPSILON);    assertEquals(Math.sqrt(2.0) / 2.0, inverted.getStandardDeviation(), EPSILON);}
5426845f4642c8d5f8fe6287b61faf569e1d6b37cc4d4daec8be6ea2aebebad7
testAndStdDevUnsupported1
public void testAndStdDevUnsupported1()
{    RunningAverage inverted = new InvertedRunningAverageAndStdDev(new FullRunningAverageAndStdDev());    inverted.addDatum(1.0);}
bad76edd4c5c81008f4b89f29ae9f853a994631fe85c79d89fc2546c088bfc83
testAndStdDevUnsupported2
public void testAndStdDevUnsupported2()
{    RunningAverage inverted = new InvertedRunningAverageAndStdDev(new FullRunningAverageAndStdDev());    inverted.changeDatum(1.0);}
1660b9c549fcc19c93398855eca6591a35a43a72454ab9990f975e88218207d6
testAndStdDevUnsupported3
public void testAndStdDevUnsupported3()
{    RunningAverage inverted = new InvertedRunningAverageAndStdDev(new FullRunningAverageAndStdDev());    inverted.removeDatum(1.0);}
5fb023989f358309e0153542e4406268eac42b6134fb82013b1199e120b658ae
testEmpty
public void testEmpty()
{    LongPrimitiveIterator it = new LongPrimitiveArrayIterator(new long[0]);    assertFalse(it.hasNext());    it.next();}
a39449d8cc265128da5f82de822ea234280c9f3383506fceee8a0edbfa306e91
testNext
public void testNext()
{    LongPrimitiveIterator it = new LongPrimitiveArrayIterator(new long[] { 3, 2, 1 });    assertTrue(it.hasNext());    assertEquals(3, (long) it.next());    assertTrue(it.hasNext());    assertEquals(2, it.nextLong());    assertTrue(it.hasNext());    assertEquals(1, (long) it.next());    assertFalse(it.hasNext());    it.nextLong();}
44d8552591286148350836508af1518b0b83f65b3dccd051ae86176f78049fd5
testPeekSkip
public void testPeekSkip()
{    LongPrimitiveIterator it = new LongPrimitiveArrayIterator(new long[] { 3, 2, 1 });    assertEquals(3, it.peek());    it.skip(2);    assertEquals(1, it.nextLong());    assertFalse(it.hasNext());}
da77e35d28c590f4b271e5b2b7f639c465574b8f17a1ef2f1df63e0152c57e8b
refresh
public void refresh(Collection<Refreshable> alreadyRefreshed)
{    call();}
8ddbbc8cc2055115ac600cd3c188d8462671957754411c629518534bb9a3af36
call
public Object call()
{    callCount++;    return null;}
5f939014017adc74d4027028d37dd6011393da4b474766a2637d316b4c154b96
getCallCount
 int getCallCount()
{    return callCount;}
b057101d36593a3ad4665c81fa4668c82fed002f38c08c238805f1aa212109a0
testCallable
public void testCallable()
{    MockRefreshable mock = new MockRefreshable();    Refreshable helper = new RefreshHelper(mock);    helper.refresh(null);    assertEquals(1, mock.getCallCount());}
9970546c7cb9c00733262ea8c80818761a4005fed33dd8235dabf0fa188cf8ad
testNoCallable
public void testNoCallable()
{    Refreshable helper = new RefreshHelper(null);    helper.refresh(null);}
10a564e7589e8ff0bdfb06ef7897d4f3aba11ee36ca49303382b875c87d88fad
testDependencies
public void testDependencies()
{    RefreshHelper helper = new RefreshHelper(null);    MockRefreshable mock1 = new MockRefreshable();    MockRefreshable mock2 = new MockRefreshable();    helper.addDependency(mock1);    helper.addDependency(mock2);    helper.refresh(null);    assertEquals(1, mock1.getCallCount());    assertEquals(1, mock2.getCallCount());}
4484cebae21658065e13e7282dada05851e48959d585d3f3c309fc610f1ba7ff
testAlreadyRefreshed
public void testAlreadyRefreshed()
{    RefreshHelper helper = new RefreshHelper(null);    MockRefreshable mock1 = new MockRefreshable();    MockRefreshable mock2 = new MockRefreshable();    helper.addDependency(mock1);    helper.addDependency(mock2);    Collection<Refreshable> alreadyRefreshed = Sets.newHashSetWithExpectedSize(1);    alreadyRefreshed.add(mock1);    helper.refresh(alreadyRefreshed);    assertEquals(0, mock1.getCallCount());    assertEquals(1, mock2.getCallCount());}
3e2655831a903d2c06417b4409591682875c5abd8765a429bb780b51c7cb9dd7
testFull
public void testFull()
{    RunningAverageAndStdDev average = new FullRunningAverageAndStdDev();    assertEquals(0, average.getCount());    assertTrue(Double.isNaN(average.getAverage()));    assertTrue(Double.isNaN(average.getStandardDeviation()));    average.addDatum(6.0);    assertEquals(1, average.getCount());    assertEquals(6.0, average.getAverage(), EPSILON);    assertTrue(Double.isNaN(average.getStandardDeviation()));    average.addDatum(6.0);    assertEquals(2, average.getCount());    assertEquals(6.0, average.getAverage(), EPSILON);    assertEquals(0.0, average.getStandardDeviation(), EPSILON);    average.removeDatum(6.0);    assertEquals(1, average.getCount());    assertEquals(6.0, average.getAverage(), EPSILON);    assertTrue(Double.isNaN(average.getStandardDeviation()));    average.addDatum(-4.0);    assertEquals(2, average.getCount());    assertEquals(1.0, average.getAverage(), EPSILON);    assertEquals(5.0 * 1.4142135623730951, average.getStandardDeviation(), EPSILON);    average.removeDatum(4.0);    assertEquals(1, average.getCount());    assertEquals(-2.0, average.getAverage(), EPSILON);    assertTrue(Double.isNaN(average.getStandardDeviation()));}
76b7fa78a61f3cdb7bf52097e8987e5c2a6ca934ff05291021e429bf7f1b5ddc
testFullBig
public void testFullBig()
{    RunningAverageAndStdDev average = new FullRunningAverageAndStdDev();    Random r = RandomUtils.getRandom();    for (int i = 0; i < 100000; i++) {        average.addDatum(r.nextDouble() * 1000.0);    }    assertEquals(500.0, average.getAverage(), SMALL_EPSILON);    assertEquals(1000.0 / Math.sqrt(12.0), average.getStandardDeviation(), SMALL_EPSILON);}
56c29b255f29accf32522e935c8db180d083ecfec113cafa8c1a47e2c28175b6
testStddev
public void testStddev()
{    RunningAverageAndStdDev runningAverage = new FullRunningAverageAndStdDev();    assertEquals(0, runningAverage.getCount());    assertTrue(Double.isNaN(runningAverage.getAverage()));    runningAverage.addDatum(1.0);    assertEquals(1, runningAverage.getCount());    assertEquals(1.0, runningAverage.getAverage(), EPSILON);    assertTrue(Double.isNaN(runningAverage.getStandardDeviation()));    runningAverage.addDatum(1.0);    assertEquals(2, runningAverage.getCount());    assertEquals(1.0, runningAverage.getAverage(), EPSILON);    assertEquals(0.0, runningAverage.getStandardDeviation(), EPSILON);    runningAverage.addDatum(7.0);    assertEquals(3, runningAverage.getCount());    assertEquals(3.0, runningAverage.getAverage(), EPSILON);    assertEquals(3.464101552963257, runningAverage.getStandardDeviation(), EPSILON);    runningAverage.addDatum(5.0);    assertEquals(4, runningAverage.getCount());    assertEquals(3.5, runningAverage.getAverage(), EPSILON);    assertEquals(3.0, runningAverage.getStandardDeviation(), EPSILON);}
3e2655831a903d2c06417b4409591682875c5abd8765a429bb780b51c7cb9dd7
testFull
public void testFull()
{    RunningAverage runningAverage = new FullRunningAverage();    assertEquals(0, runningAverage.getCount());    assertTrue(Double.isNaN(runningAverage.getAverage()));    runningAverage.addDatum(1.0);    assertEquals(1, runningAverage.getCount());    assertEquals(1.0, runningAverage.getAverage(), EPSILON);    runningAverage.addDatum(1.0);    assertEquals(2, runningAverage.getCount());    assertEquals(1.0, runningAverage.getAverage(), EPSILON);    runningAverage.addDatum(4.0);    assertEquals(3, runningAverage.getCount());    assertEquals(2.0, runningAverage.getAverage(), EPSILON);    runningAverage.addDatum(-4.0);    assertEquals(4, runningAverage.getCount());    assertEquals(0.5, runningAverage.getAverage(), EPSILON);    runningAverage.removeDatum(-4.0);    assertEquals(3, runningAverage.getCount());    assertEquals(2.0, runningAverage.getAverage(), EPSILON);    runningAverage.removeDatum(4.0);    assertEquals(2, runningAverage.getCount());    assertEquals(1.0, runningAverage.getAverage(), EPSILON);    runningAverage.changeDatum(0.0);    assertEquals(2, runningAverage.getCount());    assertEquals(1.0, runningAverage.getAverage(), EPSILON);    runningAverage.changeDatum(2.0);    assertEquals(2, runningAverage.getCount());    assertEquals(2.0, runningAverage.getAverage(), EPSILON);}
f4e25c790c24f40084fc6f744bb5e7ded2e247f9e27df5d20cafcc7f21fed081
testCopyConstructor
public void testCopyConstructor()
{    RunningAverage runningAverage = new FullRunningAverage();    runningAverage.addDatum(1.0);    runningAverage.addDatum(1.0);    assertEquals(2, runningAverage.getCount());    assertEquals(1.0, runningAverage.getAverage(), EPSILON);    RunningAverage copy = new FullRunningAverage(runningAverage.getCount(), runningAverage.getAverage());    assertEquals(2, copy.getCount());    assertEquals(1.0, copy.getAverage(), EPSILON);}
c0b43e4bbd49947d1e0f2acc71003b7620165e7c51dccffac8d93976d74ee5fe
testEmptyCase
public void testEmptyCase()
{    assertFalse(new SamplingLongPrimitiveIterator(countingIterator(0), 0.9999).hasNext());    assertFalse(new SamplingLongPrimitiveIterator(countingIterator(0), 1).hasNext());}
281fa7ddb9d85d09f3f700b8ee9e4861f74ea9c842607767ac1e6985af1fcecf
testSmallInput
public void testSmallInput()
{    SamplingLongPrimitiveIterator t = new SamplingLongPrimitiveIterator(countingIterator(1), 0.9999);    assertTrue(t.hasNext());    assertEquals(0L, t.nextLong());    assertFalse(t.hasNext());}
fb9867dc3ff068e3fc1d871414a02ac17fd3ed1a13db896e3c8db8646134d226
testBadRate1
public void testBadRate1()
{    new SamplingLongPrimitiveIterator(countingIterator(1), 0.0);}
c0c06e4608bce4e03f97e675f1528969ca15136f054446f13380e47d4d10e923
testBadRate2
public void testBadRate2()
{    new SamplingLongPrimitiveIterator(countingIterator(1), 1.1);}
cd38b10dfcef3a82d3c9e000dc62328c1944be29dc654165fe58b8a58a5b92e3
testExactSizeMatch
public void testExactSizeMatch()
{    SamplingLongPrimitiveIterator t = new SamplingLongPrimitiveIterator(countingIterator(10), 1);    for (int i = 0; i < 10; i++) {        assertTrue(t.hasNext());        assertEquals(i, t.next().intValue());    }    assertFalse(t.hasNext());}
fdf58bcb2471bab34b46d9867640f189488b11b6566a33e9095726462280d64e
testSample
public void testSample()
{    double p = 0.1;    int n = 1000;    double sd = Math.sqrt(n * p * (1.0 - p));    for (int i = 0; i < 1000; i++) {        SamplingLongPrimitiveIterator t = new SamplingLongPrimitiveIterator(countingIterator(n), p);        int k = 0;        while (t.hasNext()) {            long v = t.nextLong();            k++;            assertTrue(v >= 0L);            assertTrue(v < 1000L);        }                assertTrue(k >= 100 - 5 * sd);        assertTrue(k <= 100 + 5 * sd);    }}
b08193fbc2f220b67832aa9a1976978e8f9e8d2784c054061198e1b5026592ee
countingIterator
private static LongPrimitiveArrayIterator countingIterator(int to)
{    long[] data = new long[to];    for (int i = 0; i < to; i++) {        data[i] = i;    }    return new LongPrimitiveArrayIterator(data);}
d12d3e95180a3b23bb71b5d5bdbed1f722b8bfff3a98a9cbe76405f1cd01fd88
testWeighted
public void testWeighted()
{    WeightedRunningAverage runningAverage = new WeightedRunningAverage();    assertEquals(0, runningAverage.getCount());    assertTrue(Double.isNaN(runningAverage.getAverage()));    runningAverage.addDatum(1.0, 2.0);    assertEquals(1.0, runningAverage.getAverage(), EPSILON);    runningAverage.addDatum(1.0);    assertEquals(1.0, runningAverage.getAverage(), EPSILON);    runningAverage.addDatum(8.0, 0.5);    assertEquals(2.0, runningAverage.getAverage(), EPSILON);    runningAverage.addDatum(-4.0);    assertEquals(2.0 / 3.0, runningAverage.getAverage(), EPSILON);    runningAverage.removeDatum(-4.0);    assertEquals(2.0, runningAverage.getAverage(), EPSILON);    runningAverage.removeDatum(2.0, 2.0);    assertEquals(2.0, runningAverage.getAverage(), EPSILON);    runningAverage.changeDatum(0.0);    assertEquals(2.0, runningAverage.getAverage(), EPSILON);    runningAverage.changeDatum(4.0, 0.5);    assertEquals(5.0 / 1.5, runningAverage.getAverage(), EPSILON);}
b6e5764b8d829775436b9cfa05054c3a9e537d711581b7ded04c4ed8760ef0f2
testWeightedAndStdDev
public void testWeightedAndStdDev()
{    WeightedRunningAverageAndStdDev runningAverage = new WeightedRunningAverageAndStdDev();    assertEquals(0, runningAverage.getCount());    assertTrue(Double.isNaN(runningAverage.getAverage()));    assertTrue(Double.isNaN(runningAverage.getStandardDeviation()));    runningAverage.addDatum(1.0);    assertEquals(1.0, runningAverage.getAverage(), EPSILON);    assertTrue(Double.isNaN(runningAverage.getStandardDeviation()));    runningAverage.addDatum(1.0, 2.0);    assertEquals(1.0, runningAverage.getAverage(), EPSILON);    assertEquals(0.0, runningAverage.getStandardDeviation(), EPSILON);    runningAverage.addDatum(8.0, 0.5);    assertEquals(2.0, runningAverage.getAverage(), EPSILON);    assertEquals(Math.sqrt(10.5), runningAverage.getStandardDeviation(), EPSILON);    runningAverage.addDatum(-4.0);    assertEquals(2.0 / 3.0, runningAverage.getAverage(), EPSILON);    assertEquals(Math.sqrt(15.75), runningAverage.getStandardDeviation(), EPSILON);    runningAverage.removeDatum(-4.0);    assertEquals(2.0, runningAverage.getAverage(), EPSILON);    assertEquals(Math.sqrt(10.5), runningAverage.getStandardDeviation(), EPSILON);    runningAverage.removeDatum(2.0, 2.0);    assertEquals(2.0, runningAverage.getAverage(), EPSILON);    assertEquals(Math.sqrt(31.5), runningAverage.getStandardDeviation(), EPSILON);}
1c4ead9765938332059d76104de2519bbd7b9057fd53ed73120e527efd881e7a
testBoolean
public void testBoolean() throws Exception
{    DataModel model = getBooleanDataModel();    RecommenderBuilder builder = new RecommenderBuilder() {        @Override        public Recommender buildRecommender(DataModel dataModel) {            return new GenericBooleanPrefItemBasedRecommender(dataModel, new LogLikelihoodSimilarity(dataModel));        }    };    DataModelBuilder dataModelBuilder = new DataModelBuilder() {        @Override        public DataModel buildDataModel(FastByIDMap<PreferenceArray> trainingData) {            return new GenericBooleanPrefDataModel(GenericBooleanPrefDataModel.toDataMap(trainingData));        }    };    RecommenderIRStatsEvaluator evaluator = new GenericRecommenderIRStatsEvaluator();    IRStatistics stats = evaluator.evaluate(builder, dataModelBuilder, model, null, 1, GenericRecommenderIRStatsEvaluator.CHOOSE_THRESHOLD, 1.0);    assertNotNull(stats);    assertEquals(0.666666666, stats.getPrecision(), EPSILON);    assertEquals(0.666666666, stats.getRecall(), EPSILON);    assertEquals(0.666666666, stats.getF1Measure(), EPSILON);    assertEquals(0.666666666, stats.getFNMeasure(2.0), EPSILON);    assertEquals(0.666666666, stats.getNormalizedDiscountedCumulativeGain(), EPSILON);}
acfafe620d61d0eab4fdafe16bd8bf09da93e7b6fe8c92943eabb94b959dad2d
buildRecommender
public Recommender buildRecommender(DataModel dataModel)
{    return new GenericBooleanPrefItemBasedRecommender(dataModel, new LogLikelihoodSimilarity(dataModel));}
fda6d188eb5cee5c4aa189da9fe29fb85c875748f6acc1239599435c5206468b
buildDataModel
public DataModel buildDataModel(FastByIDMap<PreferenceArray> trainingData)
{    return new GenericBooleanPrefDataModel(GenericBooleanPrefDataModel.toDataMap(trainingData));}
a43f78850cfb3b027b102c2ddcd50277da7be40b3b0795f3b6eab64e5de1bf18
testIRStats
public void testIRStats()
{    IRStatistics stats = new IRStatisticsImpl(0.3, 0.1, 0.2, 0.05, 0.15);    assertEquals(0.3, stats.getPrecision(), EPSILON);    assertEquals(0.1, stats.getRecall(), EPSILON);    assertEquals(0.15, stats.getF1Measure(), EPSILON);    assertEquals(0.11538461538462, stats.getFNMeasure(2.0), EPSILON);    assertEquals(0.05, stats.getNormalizedDiscountedCumulativeGain(), EPSILON);}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    DataModel model = new FileDataModel(new File(args[0]));    int howMany = 10;    if (args.length > 1) {        howMany = Integer.parseInt(args[1]);    }    System.out.println("Run Items");    ItemSimilarity similarity = new EuclideanDistanceSimilarity(model);        Recommender recommender = new GenericItemBasedRecommender(model, similarity);    for (int i = 0; i < LOOPS; i++) {        LoadStatistics loadStats = LoadEvaluator.runLoad(recommender, howMany);        System.out.println(loadStats);    }    System.out.println("Run Users");    UserSimilarity userSim = new EuclideanDistanceSimilarity(model);    UserNeighborhood neighborhood = new NearestNUserNeighborhood(10, userSim, model);    recommender = new GenericUserBasedRecommender(model, neighborhood, userSim);    for (int i = 0; i < LOOPS; i++) {        LoadStatistics loadStats = LoadEvaluator.runLoad(recommender, howMany);        System.out.println(loadStats);    }}
41a773bdcf6b6d9fbbe9daa8e7282a0e4f3dd4f1938b4ffa49c46db05752244f
testUserID
public void testUserID()
{    PreferenceArray prefs = new BooleanItemPreferenceArray(3);    assertEquals(3, prefs.length());    prefs.setItemID(0, 1L);    assertEquals(1L, prefs.getItemID(0));    assertEquals(1L, prefs.getItemID(1));    assertEquals(1L, prefs.getItemID(2));}
e72c625146287e3acc2a64a7f4b4a4916dec1437b0005cf52d7997b3d1a69149
testItemID
public void testItemID()
{    PreferenceArray prefs = new BooleanItemPreferenceArray(3);    assertEquals(3, prefs.length());    prefs.setUserID(0, 1L);    prefs.setUserID(1, 2L);    prefs.setUserID(2, 3L);    assertEquals(1L, prefs.getUserID(0));    assertEquals(2L, prefs.getUserID(1));    assertEquals(3L, prefs.getUserID(2));}
3b43cf3b653be5d6dbfc18e387f781e0a3812b27ccb4b581a1ee1b78136137a7
testSetValue
public void testSetValue()
{    PreferenceArray prefs = new BooleanItemPreferenceArray(3);    assertEquals(3, prefs.length());    assertEquals(1.0f, prefs.getValue(2), EPSILON);    prefs.setValue(0, 1.0f);}
8a1bfa612fe1ba032869f48859a80a4efeac20b2cd8b764d0ca10ba43e03a189
testHasPref
public void testHasPref()
{    PreferenceArray prefs = new BooleanItemPreferenceArray(3);    prefs.set(0, new GenericPreference(1L, 3L, 5.0f));    assertTrue(prefs.hasPrefWithItemID(3L));    assertTrue(prefs.hasPrefWithUserID(1L));    assertFalse(prefs.hasPrefWithItemID(2L));    assertFalse(prefs.hasPrefWithUserID(2L));}
2c433a6a6f8ae8a06cc925c65387f357a2d4ec7f9789713a4e90e51b4fd29d96
testSort
public void testSort()
{    PreferenceArray prefs = new BooleanItemPreferenceArray(3);    prefs.set(0, new GenericPreference(3L, 1L, 5.0f));    prefs.set(1, new GenericPreference(1L, 1L, 5.0f));    prefs.set(2, new GenericPreference(2L, 1L, 5.0f));    prefs.sortByUser();    assertEquals(1L, prefs.getUserID(0));    assertEquals(2L, prefs.getUserID(1));    assertEquals(3L, prefs.getUserID(2));}
96c2a1fe93d778b1d5e6b1e73fdf173e59b3a9a00d81960d19645fbb20713b7f
testClone
public void testClone()
{    BooleanItemPreferenceArray prefs = new BooleanItemPreferenceArray(3);    prefs.set(0, new BooleanPreference(3L, 1L));    prefs.set(1, new BooleanPreference(1L, 1L));    prefs.set(2, new BooleanPreference(2L, 1L));    prefs = prefs.clone();    assertEquals(3L, prefs.getUserID(0));    assertEquals(1L, prefs.getItemID(1));}
41a773bdcf6b6d9fbbe9daa8e7282a0e4f3dd4f1938b4ffa49c46db05752244f
testUserID
public void testUserID()
{    PreferenceArray prefs = new BooleanUserPreferenceArray(3);    assertEquals(3, prefs.length());    prefs.setUserID(0, 1L);    assertEquals(1L, prefs.getUserID(0));    assertEquals(1L, prefs.getUserID(1));    assertEquals(1L, prefs.getUserID(2));}
e72c625146287e3acc2a64a7f4b4a4916dec1437b0005cf52d7997b3d1a69149
testItemID
public void testItemID()
{    PreferenceArray prefs = new BooleanUserPreferenceArray(3);    assertEquals(3, prefs.length());    prefs.setItemID(0, 1L);    prefs.setItemID(1, 2L);    prefs.setItemID(2, 3L);    assertEquals(1L, prefs.getItemID(0));    assertEquals(2L, prefs.getItemID(1));    assertEquals(3L, prefs.getItemID(2));}
3b43cf3b653be5d6dbfc18e387f781e0a3812b27ccb4b581a1ee1b78136137a7
testSetValue
public void testSetValue()
{    PreferenceArray prefs = new BooleanUserPreferenceArray(3);    assertEquals(1.0f, prefs.getValue(2), EPSILON);    assertEquals(3, prefs.length());    prefs.setValue(0, 1.0f);}
8a1bfa612fe1ba032869f48859a80a4efeac20b2cd8b764d0ca10ba43e03a189
testHasPref
public void testHasPref()
{    PreferenceArray prefs = new BooleanUserPreferenceArray(3);    prefs.set(0, new GenericPreference(1L, 3L, 5.0f));    assertTrue(prefs.hasPrefWithItemID(3L));    assertTrue(prefs.hasPrefWithUserID(1L));    assertFalse(prefs.hasPrefWithItemID(2L));    assertFalse(prefs.hasPrefWithUserID(2L));}
2c433a6a6f8ae8a06cc925c65387f357a2d4ec7f9789713a4e90e51b4fd29d96
testSort
public void testSort()
{    PreferenceArray prefs = new BooleanUserPreferenceArray(3);    prefs.set(0, new BooleanPreference(1L, 3L));    prefs.set(1, new BooleanPreference(1L, 1L));    prefs.set(2, new BooleanPreference(1L, 2L));    prefs.sortByItem();    assertEquals(1L, prefs.getItemID(0));    assertEquals(2L, prefs.getItemID(1));    assertEquals(3L, prefs.getItemID(2));}
96c2a1fe93d778b1d5e6b1e73fdf173e59b3a9a00d81960d19645fbb20713b7f
testClone
public void testClone()
{    BooleanUserPreferenceArray prefs = new BooleanUserPreferenceArray(3);    prefs.set(0, new BooleanPreference(1L, 3L));    prefs.set(1, new BooleanPreference(1L, 1L));    prefs.set(2, new BooleanPreference(1L, 2L));    prefs = prefs.clone();    assertEquals(3L, prefs.getItemID(0));    assertEquals(1L, prefs.getUserID(1));}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    super.setUp();    testFile = getTestTempFile("test.txt");    writeLines(testFile, DATA);    model = new FileDataModel(testFile);}
0d476adb1d29f1916433fdbad7abe96946e2fde13907018953b15424e705a6ee
testReadRegexSplittedFile
public void testReadRegexSplittedFile() throws Exception
{    File testFile = getTestTempFile("testRegex.txt");    writeLines(testFile, DATA_SPLITTED_WITH_TWO_SPACES);    FileDataModel model = new FileDataModel(testFile, "\\s+");    assertEquals(model.getItemIDsFromUser(123).size(), 3);    assertEquals(model.getItemIDsFromUser(456).size(), 4);}
af84b15725f90fa688463386cdecc847543395a2f76a63a7a468d2dacfb48eb2
testFile
public void testFile() throws Exception
{    UserSimilarity userSimilarity = new PearsonCorrelationSimilarity(model);    UserNeighborhood neighborhood = new NearestNUserNeighborhood(3, userSimilarity, model);    Recommender recommender = new GenericUserBasedRecommender(model, neighborhood, userSimilarity);    assertEquals(1, recommender.recommend(123, 3).size());    assertEquals(0, recommender.recommend(234, 3).size());    assertEquals(1, recommender.recommend(345, 3).size());        model.refresh(null);}
cedc51f61958cca20ecaaddc4d648a4cb370e09ebf8ed74300b734a968589c62
testTranspose
public void testTranspose() throws Exception
{    FileDataModel tModel = new FileDataModel(testFile, true, FileDataModel.DEFAULT_MIN_RELOAD_INTERVAL_MS);    PreferenceArray userPrefs = tModel.getPreferencesFromUser(456);    assertNotNull("user prefs are null and it shouldn't be", userPrefs);    PreferenceArray pref = tModel.getPreferencesForItem(123);    assertNotNull("pref is null and it shouldn't be", pref);    assertEquals("pref Size: " + pref.length() + " is not: " + 3, 3, pref.length());}
68b8a697b5b79c5a0366726df07612f41c92921248e03b4750419e7d4aaebf31
testGetItems
public void testGetItems() throws Exception
{    LongPrimitiveIterator it = model.getItemIDs();    assertNotNull(it);    assertTrue(it.hasNext());    assertEquals(123, it.nextLong());    assertTrue(it.hasNext());    assertEquals(234, it.nextLong());    assertTrue(it.hasNext());    assertEquals(456, it.nextLong());    assertTrue(it.hasNext());    assertEquals(654, it.nextLong());    assertTrue(it.hasNext());    assertEquals(789, it.nextLong());    assertTrue(it.hasNext());    assertEquals(999, it.nextLong());    assertFalse(it.hasNext());    it.next();}
d62febba01c360d9f6e2624fc4a72888135b4262fbf1f3fd8b84ecd3d17314fc
testPreferencesForItem
public void testPreferencesForItem() throws Exception
{    PreferenceArray prefs = model.getPreferencesForItem(456);    assertNotNull(prefs);    Preference pref1 = prefs.get(0);    assertEquals(123, pref1.getUserID());    assertEquals(456, pref1.getItemID());    Preference pref2 = prefs.get(1);    assertEquals(456, pref2.getUserID());    assertEquals(456, pref2.getItemID());    assertEquals(2, prefs.length());}
d35ea1010c5d13b4cd4db07d1b5be4674114212fe44a5bc9586380454b98ef58
testGetNumUsers
public void testGetNumUsers() throws Exception
{    assertEquals(4, model.getNumUsers());}
60da1ea639175fa9431c6964a6cf7c5bce39a8f506baffe7f05537752321feb0
testNumUsersPreferring
public void testNumUsersPreferring() throws Exception
{    assertEquals(2, model.getNumUsersWithPreferenceFor(456));    assertEquals(0, model.getNumUsersWithPreferenceFor(111));    assertEquals(0, model.getNumUsersWithPreferenceFor(111, 456));    assertEquals(2, model.getNumUsersWithPreferenceFor(123, 234));}
2025195ee587b144107874b35d504e98dbc762cefc47d85ea96833a73244c4c1
testRefresh
public void testRefresh() throws Exception
{    final MutableBoolean initialized = new MutableBoolean(false);    Runnable initializer = new Runnable() {        @Override        public void run() {            try {                model.getNumUsers();                initialized.setValue(true);            } catch (TasteException te) {                        }        }    };    new Thread(initializer).start();        Thread.sleep(1000L);        model.getNumUsers();    assertTrue(initialized.booleanValue());    assertEquals(4, model.getNumUsers());}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    try {        model.getNumUsers();        initialized.setValue(true);    } catch (TasteException te) {        }}
c1861b183ddf1bbdc1e0c03c6c3787102340f35be1558a642d4e612ef4ee8fb5
testExplicitRefreshAfterCompleteFileUpdate
public void testExplicitRefreshAfterCompleteFileUpdate() throws Exception
{    File file = getTestTempFile("refresh");    writeLines(file, "123,456,3.0");    /* create a FileDataModel that always reloads when the underlying file has changed */    FileDataModel dataModel = new FileDataModel(file, false, 0L);    assertEquals(3.0f, dataModel.getPreferenceValue(123L, 456L), EPSILON);    /* change the underlying file,     * we have to wait at least a second to see the change in the file's lastModified timestamp */    Thread.sleep(2000L);    writeLines(file, "123,456,5.0");    dataModel.refresh(null);    assertEquals(5.0f, dataModel.getPreferenceValue(123L, 456L), EPSILON);}
cd89046fb8911fa4a6595be8ff9a8156398ebfad5d0c95e20ca6a68135c4b5d2
testToString
public void testToString()
{    assertFalse(model.toString().isEmpty());}
eba263d6d43b4bf0c451fb0994633a5d479499e049282bf4454251e74320e56c
testEmptyFile
public void testEmptyFile() throws Exception
{    File file = getTestTempFile("empty");        writeLines(file);    new FileDataModel(file);}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    super.setUp();    testFile = getTestTempFile("test.txt");    writeLines(testFile, STRING_IDS);}
8550302c341de6296d8cd43f8e8a802f245d022778b37dbba991149a13e2592d
testLoadFromFile
public void testLoadFromFile() throws Exception
{    IDMigrator migrator = new FileIDMigrator(testFile);    long dogAsLong = migrator.toLongID("dog");    long cowAsLong = migrator.toLongID("cow");    long donkeyAsLong = migrator.toLongID("donkey");    assertEquals("dog", migrator.toStringID(dogAsLong));    assertEquals("cow", migrator.toStringID(cowAsLong));    assertNull(migrator.toStringID(donkeyAsLong));}
8d3d795a709f62db7628763a160dbe84994730c74de5276d1ffeea162df04548
testNoRefreshAfterFileUpdate
public void testNoRefreshAfterFileUpdate() throws Exception
{    IDMigrator migrator = new FileIDMigrator(testFile, 0L);    /* call a method to make sure the original file is loaded */    long dogAsLong = migrator.toLongID("dog");    migrator.toStringID(dogAsLong);    /* change the underlying file,     * we have to wait at least a second to see the change in the file's lastModified timestamp */    Thread.sleep(2000L);    writeLines(testFile, UPDATED_STRING_IDS);    /* we shouldn't see any changes in the data as we have not yet refreshed */    long cowAsLong = migrator.toLongID("cow");    long donkeyAsLong = migrator.toLongID("donkey");    assertEquals("dog", migrator.toStringID(dogAsLong));    assertEquals("cow", migrator.toStringID(cowAsLong));    assertNull(migrator.toStringID(donkeyAsLong));}
4aa7c6c51074f5f190a2e45e22dbe0bc2d5413680c28f765525223dedcad3094
testRefreshAfterFileUpdate
public void testRefreshAfterFileUpdate() throws Exception
{    IDMigrator migrator = new FileIDMigrator(testFile, 0L);    /* call a method to make sure the original file is loaded */    long dogAsLong = migrator.toLongID("dog");    migrator.toStringID(dogAsLong);    /* change the underlying file,     * we have to wait at least a second to see the change in the file's lastModified timestamp */    Thread.sleep(2000L);    writeLines(testFile, UPDATED_STRING_IDS);    migrator.refresh(null);    long cowAsLong = migrator.toLongID("cow");    long donkeyAsLong = migrator.toLongID("donkey");    assertEquals("dog", migrator.toStringID(dogAsLong));    assertEquals("cow", migrator.toStringID(cowAsLong));    assertEquals("donkey", migrator.toStringID(donkeyAsLong));}
201ceaeec1d6c505857a11e3f4b3b5be8dba93fda85e1105434de73759a3825a
testSerialization
public void testSerialization() throws Exception
{    GenericDataModel model = (GenericDataModel) getDataModel();    ByteArrayOutputStream baos = new ByteArrayOutputStream();    ObjectOutputStream out = new ObjectOutputStream(baos);    out.writeObject(model);    ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());    ObjectInputStream in = new ObjectInputStream(bais);    GenericDataModel newModel = (GenericDataModel) in.readObject();    assertEquals(model.getNumItems(), newModel.getNumItems());    assertEquals(model.getNumUsers(), newModel.getNumUsers());    assertEquals(model.getPreferencesFromUser(1L), newModel.getPreferencesFromUser(1L));    assertEquals(model.getPreferencesForItem(1L), newModel.getPreferencesForItem(1L));    assertEquals(model.getRawUserData(), newModel.getRawUserData());}
41a773bdcf6b6d9fbbe9daa8e7282a0e4f3dd4f1938b4ffa49c46db05752244f
testUserID
public void testUserID()
{    PreferenceArray prefs = new GenericItemPreferenceArray(3);    assertEquals(3, prefs.length());    prefs.setItemID(0, 1L);    assertEquals(1L, prefs.getItemID(0));    assertEquals(1L, prefs.getItemID(1));    assertEquals(1L, prefs.getItemID(2));}
e72c625146287e3acc2a64a7f4b4a4916dec1437b0005cf52d7997b3d1a69149
testItemID
public void testItemID()
{    PreferenceArray prefs = new GenericItemPreferenceArray(3);    assertEquals(3, prefs.length());    prefs.setUserID(0, 1L);    prefs.setUserID(1, 2L);    prefs.setUserID(2, 3L);    assertEquals(1L, prefs.getUserID(0));    assertEquals(2L, prefs.getUserID(1));    assertEquals(3L, prefs.getUserID(2));}
3b43cf3b653be5d6dbfc18e387f781e0a3812b27ccb4b581a1ee1b78136137a7
testSetValue
public void testSetValue()
{    PreferenceArray prefs = new GenericItemPreferenceArray(3);    assertEquals(3, prefs.length());    prefs.setValue(0, 1.0f);    prefs.setValue(1, 2.0f);    prefs.setValue(2, 3.0f);    assertEquals(1.0f, prefs.getValue(0), EPSILON);    assertEquals(2.0f, prefs.getValue(1), EPSILON);    assertEquals(3.0f, prefs.getValue(2), EPSILON);}
8a1bfa612fe1ba032869f48859a80a4efeac20b2cd8b764d0ca10ba43e03a189
testHasPref
public void testHasPref()
{    PreferenceArray prefs = new GenericItemPreferenceArray(3);    prefs.set(0, new GenericPreference(1L, 3L, 5.0f));    assertTrue(prefs.hasPrefWithItemID(3L));    assertTrue(prefs.hasPrefWithUserID(1L));    assertFalse(prefs.hasPrefWithItemID(2L));    assertFalse(prefs.hasPrefWithUserID(2L));}
2c433a6a6f8ae8a06cc925c65387f357a2d4ec7f9789713a4e90e51b4fd29d96
testSort
public void testSort()
{    PreferenceArray prefs = new GenericItemPreferenceArray(3);    prefs.set(0, new GenericPreference(3L, 1L, 5.0f));    prefs.set(1, new GenericPreference(1L, 1L, 5.0f));    prefs.set(2, new GenericPreference(2L, 1L, 5.0f));    prefs.sortByUser();    assertEquals(1L, prefs.getUserID(0));    assertEquals(2L, prefs.getUserID(1));    assertEquals(3L, prefs.getUserID(2));}
c93214cdcd9ccc761dc7f9ecdbdf6c96e53f3ebbd3a1f63b2ab6cb920fea7d94
testSortValue
public void testSortValue()
{    PreferenceArray prefs = new GenericItemPreferenceArray(3);    prefs.set(0, new GenericPreference(3L, 1L, 5.0f));    prefs.set(1, new GenericPreference(1L, 1L, 4.0f));    prefs.set(2, new GenericPreference(2L, 1L, 3.0f));    prefs.sortByValue();    assertEquals(2L, prefs.getUserID(0));    assertEquals(1L, prefs.getUserID(1));    assertEquals(3L, prefs.getUserID(2));    prefs.sortByValueReversed();    assertEquals(3L, prefs.getUserID(0));    assertEquals(1L, prefs.getUserID(1));    assertEquals(2L, prefs.getUserID(2));}
96c2a1fe93d778b1d5e6b1e73fdf173e59b3a9a00d81960d19645fbb20713b7f
testClone
public void testClone()
{    GenericItemPreferenceArray prefs = new GenericItemPreferenceArray(3);    prefs.set(0, new GenericPreference(3L, 1L, 5.0f));    prefs.set(1, new GenericPreference(1L, 1L, 4.0f));    prefs.set(2, new GenericPreference(2L, 1L, 3.0f));    prefs = prefs.clone();    assertEquals(3L, prefs.getUserID(0));    assertEquals(1L, prefs.getItemID(1));    assertEquals(3.0f, prefs.getValue(2), EPSILON);}
41a773bdcf6b6d9fbbe9daa8e7282a0e4f3dd4f1938b4ffa49c46db05752244f
testUserID
public void testUserID()
{    PreferenceArray prefs = new GenericUserPreferenceArray(3);    assertEquals(3, prefs.length());    prefs.setUserID(0, 1L);    assertEquals(1L, prefs.getUserID(0));    assertEquals(1L, prefs.getUserID(1));    assertEquals(1L, prefs.getUserID(2));}
e72c625146287e3acc2a64a7f4b4a4916dec1437b0005cf52d7997b3d1a69149
testItemID
public void testItemID()
{    PreferenceArray prefs = new GenericUserPreferenceArray(3);    assertEquals(3, prefs.length());    prefs.setItemID(0, 1L);    prefs.setItemID(1, 2L);    prefs.setItemID(2, 3L);    assertEquals(1L, prefs.getItemID(0));    assertEquals(2L, prefs.getItemID(1));    assertEquals(3L, prefs.getItemID(2));}
3b43cf3b653be5d6dbfc18e387f781e0a3812b27ccb4b581a1ee1b78136137a7
testSetValue
public void testSetValue()
{    PreferenceArray prefs = new GenericUserPreferenceArray(3);    assertEquals(3, prefs.length());    prefs.setValue(0, 1.0f);    prefs.setValue(1, 2.0f);    prefs.setValue(2, 3.0f);    assertEquals(1.0f, prefs.getValue(0), EPSILON);    assertEquals(2.0f, prefs.getValue(1), EPSILON);    assertEquals(3.0f, prefs.getValue(2), EPSILON);}
8a1bfa612fe1ba032869f48859a80a4efeac20b2cd8b764d0ca10ba43e03a189
testHasPref
public void testHasPref()
{    PreferenceArray prefs = new GenericUserPreferenceArray(3);    prefs.set(0, new GenericPreference(1L, 3L, 5.0f));    assertTrue(prefs.hasPrefWithItemID(3L));    assertTrue(prefs.hasPrefWithUserID(1L));    assertFalse(prefs.hasPrefWithItemID(2L));    assertFalse(prefs.hasPrefWithUserID(2L));}
2c433a6a6f8ae8a06cc925c65387f357a2d4ec7f9789713a4e90e51b4fd29d96
testSort
public void testSort()
{    PreferenceArray prefs = new GenericUserPreferenceArray(3);    prefs.set(0, new GenericPreference(1L, 3L, 5.0f));    prefs.set(1, new GenericPreference(1L, 1L, 5.0f));    prefs.set(2, new GenericPreference(1L, 2L, 5.0f));    prefs.sortByItem();    assertEquals(1L, prefs.getItemID(0));    assertEquals(2L, prefs.getItemID(1));    assertEquals(3L, prefs.getItemID(2));}
c93214cdcd9ccc761dc7f9ecdbdf6c96e53f3ebbd3a1f63b2ab6cb920fea7d94
testSortValue
public void testSortValue()
{    PreferenceArray prefs = new GenericUserPreferenceArray(3);    prefs.set(0, new GenericPreference(1L, 3L, 5.0f));    prefs.set(1, new GenericPreference(1L, 1L, 4.0f));    prefs.set(2, new GenericPreference(1L, 2L, 3.0f));    prefs.sortByValue();    assertEquals(2L, prefs.getItemID(0));    assertEquals(1L, prefs.getItemID(1));    assertEquals(3L, prefs.getItemID(2));    prefs.sortByValueReversed();    assertEquals(3L, prefs.getItemID(0));    assertEquals(1L, prefs.getItemID(1));    assertEquals(2L, prefs.getItemID(2));}
96c2a1fe93d778b1d5e6b1e73fdf173e59b3a9a00d81960d19645fbb20713b7f
testClone
public void testClone()
{    GenericUserPreferenceArray prefs = new GenericUserPreferenceArray(3);    prefs.set(0, new GenericPreference(1L, 3L, 5.0f));    prefs.set(1, new GenericPreference(1L, 1L, 4.0f));    prefs.set(2, new GenericPreference(1L, 2L, 3.0f));    prefs = prefs.clone();    assertEquals(3L, prefs.getItemID(0));    assertEquals(1L, prefs.getUserID(1));    assertEquals(3.0f, prefs.getValue(2), EPSILON);}
6c9b0924dccdb14ef1cc471fa4457a14b9f9bee0a479e663008a879761334bcd
testToLong
public void testToLong()
{    IDMigrator migrator = new MemoryIDMigrator();    long id = migrator.toLongID(DUMMY_STRING);    assertEquals(DUMMY_ID, id);}
ed8e07836d7e1a986dd8bd8463eb39568dedbd8c49e294b9e2200a1114144c9a
testStore
public void testStore() throws Exception
{    UpdatableIDMigrator migrator = new MemoryIDMigrator();    long id = migrator.toLongID(DUMMY_STRING);    assertNull(migrator.toStringID(id));    migrator.storeMapping(id, DUMMY_STRING);    assertEquals(DUMMY_STRING, migrator.toStringID(id));}
53c5456e621314fad87f2e3f27a48fd0274c58d7f01038b968463708bfa73138
testInitialize
public void testInitialize() throws Exception
{    UpdatableIDMigrator migrator = new MemoryIDMigrator();    long id = migrator.toLongID(DUMMY_STRING);    assertNull(migrator.toStringID(id));    migrator.initialize(Collections.singleton(DUMMY_STRING));    assertEquals(DUMMY_STRING, migrator.toStringID(id));}
9a30f299521969c1d4439eacd082d91365624b20a39b413482c3e1956daca6d8
getTestableWithoutDelegateData
private static PlusAnonymousConcurrentUserDataModel getTestableWithoutDelegateData(int maxConcurrentUsers)
{    FastByIDMap<PreferenceArray> delegatePreferences = new FastByIDMap<>();    return new PlusAnonymousConcurrentUserDataModel(new GenericDataModel(delegatePreferences), maxConcurrentUsers);}
c77ead405a316e156a24be7e63c77ab72b7b1ed95c8f43adb1de165352f3ab9c
getTestableWithDelegateData
private static PlusAnonymousConcurrentUserDataModel getTestableWithDelegateData(int maxConcurrentUsers, FastByIDMap<PreferenceArray> delegatePreferences)
{    return new PlusAnonymousConcurrentUserDataModel(new GenericDataModel(delegatePreferences), maxConcurrentUsers);}
465db80e8811facad6f83c2d6d2250b3ea55b40179901a32664ed82a41d49e02
testTakeFirstAvailableUser
public void testTakeFirstAvailableUser()
{    PlusAnonymousConcurrentUserDataModel instance = getTestableWithoutDelegateData(10);    Long expResult = PlusAnonymousUserDataModel.TEMP_USER_ID;    Long result = instance.takeAvailableUser();    assertEquals(expResult, result);}
d5c5cb0c261ef05879a187c8607de8820ecd271b174b74bc73c08ae50824a104
testTakeNextAvailableUser
public void testTakeNextAvailableUser()
{    PlusAnonymousConcurrentUserDataModel instance = getTestableWithoutDelegateData(10);        instance.takeAvailableUser();    Long result = instance.takeAvailableUser();    Long expResult = PlusAnonymousUserDataModel.TEMP_USER_ID + 1;    assertEquals(expResult, result);}
2afeb57725150bbaf5a4550058a7b3706b302c5c073c671b1f7d6a8d1b482090
testTakeUnavailableUser
public void testTakeUnavailableUser()
{    PlusAnonymousConcurrentUserDataModel instance = getTestableWithoutDelegateData(1);        instance.takeAvailableUser();        assertNull(instance.takeAvailableUser());}
f588f5b174552c83b05697a8325d2c8d5726c11c8cf29476b0571eec35db52c9
testReleaseValidUser
public void testReleaseValidUser()
{    PlusAnonymousConcurrentUserDataModel instance = getTestableWithoutDelegateData(10);    Long takenUserID = instance.takeAvailableUser();    assertTrue(instance.releaseUser(takenUserID));}
77567d594c7b335d2464b37f2b10d974c12207c6f969739224b0e1d158425f6c
testReleaseInvalidUser
public void testReleaseInvalidUser()
{    PlusAnonymousConcurrentUserDataModel instance = getTestableWithoutDelegateData(10);    assertFalse(instance.releaseUser(Long.MAX_VALUE));}
eb8558bfbacd0e278b05c6560bcad6effb571f33cbf7a6a2673be1d50e21e5d6
testReleasePreviouslyReleasedUser
public void testReleasePreviouslyReleasedUser()
{    PlusAnonymousConcurrentUserDataModel instance = getTestableWithoutDelegateData(10);    Long takenUserID = instance.takeAvailableUser();    assertTrue(instance.releaseUser(takenUserID));    assertFalse(instance.releaseUser(takenUserID));}
d88b41de40a26df1b02252b35bc0e22b6a9200fb1f6008116985a953e21e7272
testSetAndGetTempPreferences
public void testSetAndGetTempPreferences() throws TasteException
{    PlusAnonymousConcurrentUserDataModel instance = getTestableWithoutDelegateData(10);    Long anonymousUserID = instance.takeAvailableUser();    PreferenceArray tempPrefs = new GenericUserPreferenceArray(1);    tempPrefs.setUserID(0, anonymousUserID);    tempPrefs.setItemID(0, 1);    instance.setTempPrefs(tempPrefs, anonymousUserID);    assertEquals(tempPrefs, instance.getPreferencesFromUser(anonymousUserID));    instance.releaseUser(anonymousUserID);}
2b5d0baa14685bcb9a512656333a7256ddf0f3f20df582257b878a634b32a963
testSetMultipleTempPreferences
public void testSetMultipleTempPreferences() throws TasteException
{    PlusAnonymousConcurrentUserDataModel instance = getTestableWithoutDelegateData(10);    Long anonymousUserID1 = instance.takeAvailableUser();    Long anonymousUserID2 = instance.takeAvailableUser();    PreferenceArray tempPrefs1 = new GenericUserPreferenceArray(1);    tempPrefs1.setUserID(0, anonymousUserID1);    tempPrefs1.setItemID(0, 1);    PreferenceArray tempPrefs2 = new GenericUserPreferenceArray(2);    tempPrefs2.setUserID(0, anonymousUserID2);    tempPrefs2.setItemID(0, 2);    tempPrefs2.setUserID(1, anonymousUserID2);    tempPrefs2.setItemID(1, 3);    instance.setTempPrefs(tempPrefs1, anonymousUserID1);    instance.setTempPrefs(tempPrefs2, anonymousUserID2);    assertEquals(tempPrefs1, instance.getPreferencesFromUser(anonymousUserID1));    assertEquals(tempPrefs2, instance.getPreferencesFromUser(anonymousUserID2));}
3584e08023379a3690e640fac512e4dece29b2e9366eb0b45ed7e5f0aaae20d8
testGetNumUsersWithDelegateUsersOnly
public void testGetNumUsersWithDelegateUsersOnly() throws TasteException
{    PreferenceArray prefs = new GenericUserPreferenceArray(1);    long sampleUserID = 1;    prefs.setUserID(0, sampleUserID);    long sampleItemID = 11;    prefs.setItemID(0, sampleItemID);    FastByIDMap<PreferenceArray> delegatePreferences = new FastByIDMap<>();    delegatePreferences.put(sampleUserID, prefs);    PlusAnonymousConcurrentUserDataModel instance = getTestableWithDelegateData(10, delegatePreferences);    assertEquals(1, instance.getNumUsers());}
f23b3d373993f30470ef743ee506b081f35a24eb83ea7c538a9be903d4c27729
testGetNumAnonymousUsers
public void testGetNumAnonymousUsers() throws TasteException
{    PlusAnonymousConcurrentUserDataModel instance = getTestableWithoutDelegateData(10);    Long anonymousUserID1 = instance.takeAvailableUser();    PreferenceArray tempPrefs1 = new GenericUserPreferenceArray(1);    tempPrefs1.setUserID(0, anonymousUserID1);    tempPrefs1.setItemID(0, 1);    instance.setTempPrefs(tempPrefs1, anonymousUserID1);        assertEquals(0, instance.getNumUsers());}
46b75b8161bbb6e0193e4ce9efde19638f4fae645828bfd5eb591d4eb5724dc6
testGetPreferenceValue
public void testGetPreferenceValue() throws TasteException
{    PlusAnonymousConcurrentUserDataModel instance = getTestableWithoutDelegateData(10);    Long anonymousUserID = instance.takeAvailableUser();    PreferenceArray tempPrefs = new GenericUserPreferenceArray(1);    tempPrefs.setUserID(0, anonymousUserID);    long sampleItemID = 1;    tempPrefs.setItemID(0, sampleItemID);    tempPrefs.setValue(0, Float.MAX_VALUE);    instance.setTempPrefs(tempPrefs, anonymousUserID);    assertEquals(Float.MAX_VALUE, instance.getPreferenceValue(anonymousUserID, sampleItemID), EPSILON);}
9340532a350d9ee0e0798e9b39fc512ecaa8d6b85f064dead80ea6dea79f9c49
testGetPreferencesForNonAnonymousUser
public void testGetPreferencesForNonAnonymousUser() throws TasteException
{    PreferenceArray prefs = new GenericUserPreferenceArray(1);    long sampleUserID = 1;    prefs.setUserID(0, sampleUserID);    long sampleItemID = 11;    prefs.setItemID(0, sampleItemID);    FastByIDMap<PreferenceArray> delegatePreferences = new FastByIDMap<>();    delegatePreferences.put(sampleUserID, prefs);    PlusAnonymousConcurrentUserDataModel instance = getTestableWithDelegateData(10, delegatePreferences);    assertEquals(prefs, instance.getPreferencesFromUser(sampleUserID));}
28c216477fd9656925ac589a5b280796e38250fa02de9b977be3e6e53170593c
testGetPreferencesForNonExistingUser
public void testGetPreferencesForNonExistingUser() throws TasteException
{    PlusAnonymousConcurrentUserDataModel instance = getTestableWithoutDelegateData(10);        instance.getPreferencesFromUser(1);}
16d6e0472b95ba7542530bf632d3c38802df130385575b945afaadc085e3119a
testGetUserIDs
public void testGetUserIDs() throws TasteException
{    PreferenceArray prefs = new GenericUserPreferenceArray(1);    long sampleUserID = 1;    prefs.setUserID(0, sampleUserID);    long sampleItemID = 11;    prefs.setItemID(0, sampleItemID);    FastByIDMap<PreferenceArray> delegatePreferences = new FastByIDMap<>();    delegatePreferences.put(sampleUserID, prefs);    PlusAnonymousConcurrentUserDataModel instance = getTestableWithDelegateData(10, delegatePreferences);    Long anonymousUserID = instance.takeAvailableUser();    PreferenceArray tempPrefs = new GenericUserPreferenceArray(1);    tempPrefs.setUserID(0, anonymousUserID);    tempPrefs.setItemID(0, 22);    instance.setTempPrefs(tempPrefs, anonymousUserID);    Iterator<Long> userIDs = instance.getUserIDs();    assertSame(sampleUserID, userIDs.next());    assertFalse(userIDs.hasNext());}
c321fc69fa6427b854ebd459ec733ea60f0b5d056af85b41d1381ed05ac26526
testGetPreferencesForItem
public void testGetPreferencesForItem() throws TasteException
{    PreferenceArray prefs = new GenericUserPreferenceArray(2);    long sampleUserID = 4;    prefs.setUserID(0, sampleUserID);    long sampleItemID = 11;    prefs.setItemID(0, sampleItemID);    prefs.setUserID(1, sampleUserID);    long sampleItemID2 = 22;    prefs.setItemID(1, sampleItemID2);    FastByIDMap<PreferenceArray> delegatePreferences = new FastByIDMap<>();    delegatePreferences.put(sampleUserID, prefs);    PlusAnonymousConcurrentUserDataModel instance = getTestableWithDelegateData(10, delegatePreferences);    Long anonymousUserID = instance.takeAvailableUser();    PreferenceArray tempPrefs = new GenericUserPreferenceArray(2);    tempPrefs.setUserID(0, anonymousUserID);    tempPrefs.setItemID(0, sampleItemID);    tempPrefs.setUserID(1, anonymousUserID);    long sampleItemID3 = 33;    tempPrefs.setItemID(1, sampleItemID3);    instance.setTempPrefs(tempPrefs, anonymousUserID);    assertEquals(sampleUserID, instance.getPreferencesForItem(sampleItemID).get(0).getUserID());    assertEquals(2, instance.getPreferencesForItem(sampleItemID).length());    assertEquals(1, instance.getPreferencesForItem(sampleItemID2).length());    assertEquals(1, instance.getPreferencesForItem(sampleItemID3).length());    assertEquals(2, instance.getNumUsersWithPreferenceFor(sampleItemID));    assertEquals(1, instance.getNumUsersWithPreferenceFor(sampleItemID, sampleItemID2));    assertEquals(1, instance.getNumUsersWithPreferenceFor(sampleItemID, sampleItemID3));}
6f619af6b933f247b2381a943dbd9ec7e1ce76261259afaaba26f206ffa26a36
userSimilarity
public double userSimilarity(long userID1, long userID2) throws TasteException
{    DataModel dataModel = getDataModel();    return 1.0 / (1.0 + Math.abs(dataModel.getPreferencesFromUser(userID1).get(0).getValue() - dataModel.getPreferencesFromUser(userID2).get(0).getValue()));}
50e6b7f96cf22dd8e2565708ad17537816c51b9936cd4736bafb36eedd8da9e6
itemSimilarity
public double itemSimilarity(long itemID1, long itemID2)
{        return 1.0 / (1.0 + Math.abs(itemID1 - itemID2));}
00d4cdca08b465288a485bb65a4128cfd1261b7f5ec59a0e050b082adf455897
itemSimilarities
public double[] itemSimilarities(long itemID1, long[] itemID2s)
{    int length = itemID2s.length;    double[] result = new double[length];    for (int i = 0; i < length; i++) {        result[i] = itemSimilarity(itemID1, itemID2s[i]);    }    return result;}
2d8f33853a5d66d0af6cf47695c79967c65a305e7d58f8c40c1187abe20830c6
setPreferenceInferrer
public void setPreferenceInferrer(PreferenceInferrer inferrer)
{    throw new UnsupportedOperationException();}
da77e35d28c590f4b271e5b2b7f639c465574b8f17a1ef2f1df63e0152c57e8b
refresh
public void refresh(Collection<Refreshable> alreadyRefreshed)
{}
7380f968ded7c88f5034eae737b7578a280188a625bdc316b9129faca3bbe2f0
testNeighborhood
public void testNeighborhood() throws Exception
{    DataModel dataModel = getDataModel();    long[] neighborhood = new NearestNUserNeighborhood(1, new DummySimilarity(dataModel), dataModel).getUserNeighborhood(1);    assertNotNull(neighborhood);    assertEquals(1, neighborhood.length);    assertTrue(arrayContains(neighborhood, 2));    long[] neighborhood2 = new NearestNUserNeighborhood(2, new DummySimilarity(dataModel), dataModel).getUserNeighborhood(2);    assertNotNull(neighborhood2);    assertEquals(2, neighborhood2.length);    assertTrue(arrayContains(neighborhood2, 1));    assertTrue(arrayContains(neighborhood2, 3));    long[] neighborhood3 = new NearestNUserNeighborhood(4, new DummySimilarity(dataModel), dataModel).getUserNeighborhood(4);    assertNotNull(neighborhood3);    assertEquals(3, neighborhood3.length);    assertTrue(arrayContains(neighborhood3, 1));    assertTrue(arrayContains(neighborhood3, 2));    assertTrue(arrayContains(neighborhood3, 3));}
7380f968ded7c88f5034eae737b7578a280188a625bdc316b9129faca3bbe2f0
testNeighborhood
public void testNeighborhood() throws Exception
{    DataModel dataModel = getDataModel();    long[] neighborhood = new ThresholdUserNeighborhood(1.0, new DummySimilarity(dataModel), dataModel).getUserNeighborhood(1);    assertNotNull(neighborhood);    assertEquals(0, neighborhood.length);    long[] neighborhood2 = new ThresholdUserNeighborhood(0.8, new DummySimilarity(dataModel), dataModel).getUserNeighborhood(1);    assertNotNull(neighborhood2);    assertEquals(1, neighborhood2.length);    assertTrue(arrayContains(neighborhood2, 2));    long[] neighborhood3 = new ThresholdUserNeighborhood(0.6, new DummySimilarity(dataModel), dataModel).getUserNeighborhood(2);    assertNotNull(neighborhood3);    assertEquals(3, neighborhood3.length);    assertTrue(arrayContains(neighborhood3, 1));    assertTrue(arrayContains(neighborhood3, 3));    assertTrue(arrayContains(neighborhood3, 4));}
8347cda17c9c0f26c6605fe11e1deb134aa6a6314276f6915561ba61da5c5936
testStrategy
public void testStrategy() throws TasteException
{    FastIDSet allItemIDs = new FastIDSet();    allItemIDs.addAll(new long[] { 1L, 2L, 3L });    FastIDSet preferredItemIDs = new FastIDSet(1);    preferredItemIDs.add(2L);    DataModel dataModel = EasyMock.createMock(DataModel.class);    EasyMock.expect(dataModel.getNumItems()).andReturn(3);    EasyMock.expect(dataModel.getItemIDs()).andReturn(allItemIDs.iterator());    PreferenceArray prefArrayOfUser123 = new GenericUserPreferenceArray(Collections.singletonList(new GenericPreference(123L, 2L, 1.0f)));    CandidateItemsStrategy strategy = new AllUnknownItemsCandidateItemsStrategy();    EasyMock.replay(dataModel);    FastIDSet candidateItems = strategy.getCandidateItems(123L, prefArrayOfUser123, dataModel, false);    assertEquals(2, candidateItems.size());    assertTrue(candidateItems.contains(1L));    assertTrue(candidateItems.contains(3L));    EasyMock.verify(dataModel);}
f59647db375b6257eec6a1361739eda559801f71b23eb15d0682e922d2c49b4a
testRecommender
public void testRecommender() throws Exception
{    MutableInt recommendCount = new MutableInt();    Recommender mockRecommender = new MockRecommender(recommendCount);    Recommender cachingRecommender = new CachingRecommender(mockRecommender);    cachingRecommender.recommend(1, 1);    assertEquals(1, recommendCount.intValue());    cachingRecommender.recommend(2, 1);    assertEquals(2, recommendCount.intValue());    cachingRecommender.recommend(1, 1);    assertEquals(2, recommendCount.intValue());    cachingRecommender.recommend(2, 1);    assertEquals(2, recommendCount.intValue());    cachingRecommender.refresh(null);    cachingRecommender.recommend(1, 1);    assertEquals(3, recommendCount.intValue());    cachingRecommender.recommend(2, 1);    assertEquals(4, recommendCount.intValue());    cachingRecommender.recommend(3, 1);    assertEquals(5, recommendCount.intValue());        IDRescorer rescorer = NullRescorer.getItemInstance();    cachingRecommender.refresh(null);    cachingRecommender.recommend(1, 1, rescorer);    assertEquals(6, recommendCount.intValue());    cachingRecommender.recommend(2, 1, rescorer);    assertEquals(7, recommendCount.intValue());    cachingRecommender.recommend(1, 1, rescorer);    assertEquals(7, recommendCount.intValue());    cachingRecommender.recommend(2, 1, rescorer);    assertEquals(7, recommendCount.intValue());        cachingRecommender.recommend(1, 1, null);    assertEquals(8, recommendCount.intValue());    cachingRecommender.recommend(2, 1, null);    assertEquals(9, recommendCount.intValue());    cachingRecommender.refresh(null);    cachingRecommender.estimatePreference(1, 1);    assertEquals(10, recommendCount.intValue());    cachingRecommender.estimatePreference(1, 2);    assertEquals(11, recommendCount.intValue());    cachingRecommender.estimatePreference(1, 2);    assertEquals(11, recommendCount.intValue());}
f59647db375b6257eec6a1361739eda559801f71b23eb15d0682e922d2c49b4a
testRecommender
public void testRecommender() throws Exception
{    Recommender recommender = buildRecommender();    List<RecommendedItem> recommended = recommender.recommend(1, 1);    assertNotNull(recommended);    assertEquals(1, recommended.size());    RecommendedItem firstRecommended = recommended.get(0);    assertEquals(2, firstRecommended.getItemID());    assertEquals(0.1f, firstRecommended.getValue(), EPSILON);    recommender.refresh(null);    recommended = recommender.recommend(1, 1);    firstRecommended = recommended.get(0);    assertEquals(2, firstRecommended.getItemID());    assertEquals(0.1f, firstRecommended.getValue(), EPSILON);}
030790b9a0881722d06781d9580716c11ba0192f98d10e4a8811d47f0e7da015
testHowMany
public void testHowMany() throws Exception
{    DataModel dataModel = getDataModel(new long[] { 1, 2, 3, 4, 5 }, new Double[][] { { 0.1, 0.2 }, { 0.2, 0.3, 0.3, 0.6 }, { 0.4, 0.4, 0.5, 0.9 }, { 0.1, 0.4, 0.5, 0.8, 0.9, 1.0 }, { 0.2, 0.3, 0.6, 0.7, 0.1, 0.2 } });    Collection<GenericItemSimilarity.ItemItemSimilarity> similarities = Lists.newArrayList();    for (int i = 0; i < 6; i++) {        for (int j = i + 1; j < 6; j++) {            similarities.add(new GenericItemSimilarity.ItemItemSimilarity(i, j, 1.0 / (1.0 + i + j)));        }    }    ItemSimilarity similarity = new GenericItemSimilarity(similarities);    Recommender recommender = new GenericItemBasedRecommender(dataModel, similarity);    List<RecommendedItem> fewRecommended = recommender.recommend(1, 2);    List<RecommendedItem> moreRecommended = recommender.recommend(1, 4);    for (int i = 0; i < fewRecommended.size(); i++) {        assertEquals(fewRecommended.get(i).getItemID(), moreRecommended.get(i).getItemID());    }    recommender.refresh(null);    for (int i = 0; i < fewRecommended.size(); i++) {        assertEquals(fewRecommended.get(i).getItemID(), moreRecommended.get(i).getItemID());    }}
296b944336523cbbac2dfa5327391cbdda672c3f678fac51406bc3f8be80ff93
testRescorer
public void testRescorer() throws Exception
{    DataModel dataModel = getDataModel(new long[] { 1, 2, 3 }, new Double[][] { { 0.1, 0.2 }, { 0.2, 0.3, 0.3, 0.6 }, { 0.4, 0.4, 0.5, 0.9 } });    Collection<GenericItemSimilarity.ItemItemSimilarity> similarities = Lists.newArrayList();    similarities.add(new GenericItemSimilarity.ItemItemSimilarity(0, 1, 1.0));    similarities.add(new GenericItemSimilarity.ItemItemSimilarity(0, 2, 0.5));    similarities.add(new GenericItemSimilarity.ItemItemSimilarity(0, 3, 0.2));    similarities.add(new GenericItemSimilarity.ItemItemSimilarity(1, 2, 0.7));    similarities.add(new GenericItemSimilarity.ItemItemSimilarity(1, 3, 0.5));    similarities.add(new GenericItemSimilarity.ItemItemSimilarity(2, 3, 0.9));    ItemSimilarity similarity = new GenericItemSimilarity(similarities);    Recommender recommender = new GenericItemBasedRecommender(dataModel, similarity);    List<RecommendedItem> originalRecommended = recommender.recommend(1, 2);    List<RecommendedItem> rescoredRecommended = recommender.recommend(1, 2, new ReversingRescorer<Long>());    assertNotNull(originalRecommended);    assertNotNull(rescoredRecommended);    assertEquals(2, originalRecommended.size());    assertEquals(2, rescoredRecommended.size());    assertEquals(originalRecommended.get(0).getItemID(), rescoredRecommended.get(1).getItemID());    assertEquals(originalRecommended.get(1).getItemID(), rescoredRecommended.get(0).getItemID());}
d4c888d3f719d919fb4a5f262090aa86f7969b7c273241636f799be5ed92d2b5
testIncludeKnownItems
public void testIncludeKnownItems() throws Exception
{    DataModel dataModel = getDataModel(new long[] { 1, 2, 3 }, new Double[][] { { 0.1, 0.2 }, { 0.2, 0.3, 0.3, 0.6 }, { 0.4, 0.4, 0.5, 0.9 } });    Collection<GenericItemSimilarity.ItemItemSimilarity> similarities = Lists.newArrayList();    similarities.add(new GenericItemSimilarity.ItemItemSimilarity(0, 1, 0.8));    similarities.add(new GenericItemSimilarity.ItemItemSimilarity(0, 2, 0.5));    similarities.add(new GenericItemSimilarity.ItemItemSimilarity(0, 3, 0.2));    similarities.add(new GenericItemSimilarity.ItemItemSimilarity(1, 2, 0.7));    similarities.add(new GenericItemSimilarity.ItemItemSimilarity(1, 3, 0.5));    similarities.add(new GenericItemSimilarity.ItemItemSimilarity(2, 3, 0.9));    ItemSimilarity similarity = new GenericItemSimilarity(similarities);    Recommender recommender = new GenericItemBasedRecommender(dataModel, similarity);    List<RecommendedItem> originalRecommended = recommender.recommend(1, 4, null, true);    List<RecommendedItem> rescoredRecommended = recommender.recommend(1, 4, new ReversingRescorer<Long>(), true);    assertNotNull(originalRecommended);    assertNotNull(rescoredRecommended);    assertEquals(4, originalRecommended.size());    assertEquals(4, rescoredRecommended.size());    assertEquals(originalRecommended.get(0).getItemID(), rescoredRecommended.get(3).getItemID());    assertEquals(originalRecommended.get(3).getItemID(), rescoredRecommended.get(0).getItemID());}
df964c8d91f35f44ee8878053bf3358027bd810e43119f4d164936b066d4b9cc
testEstimatePref
public void testEstimatePref() throws Exception
{    Recommender recommender = buildRecommender();    assertEquals(0.1f, recommender.estimatePreference(1, 2), EPSILON);}
e200d1aa7562e7583cb1e80cc78125f8b978a084272e06ff75177592ff975c85
testBestRating
public void testBestRating() throws Exception
{    Recommender recommender = buildRecommender();    List<RecommendedItem> recommended = recommender.recommend(1, 1);    assertNotNull(recommended);    assertEquals(1, recommended.size());    RecommendedItem firstRecommended = recommended.get(0);        assertEquals(2, firstRecommended.getItemID());    assertEquals(0.1f, firstRecommended.getValue(), EPSILON);}
37fbbb11ea3f26026a08b697d158e2650e8f24e5d193a09d9bb84d1e743d9ba1
testMostSimilar
public void testMostSimilar() throws Exception
{    ItemBasedRecommender recommender = buildRecommender();    List<RecommendedItem> similar = recommender.mostSimilarItems(0, 2);    assertNotNull(similar);    assertEquals(2, similar.size());    RecommendedItem first = similar.get(0);    RecommendedItem second = similar.get(1);    assertEquals(1, first.getItemID());    assertEquals(1.0f, first.getValue(), EPSILON);    assertEquals(2, second.getItemID());    assertEquals(0.5f, second.getValue(), EPSILON);}
f937297d3c59529288abb682c1eb11c3ec8016791c31630baa7d873e71844903
testMostSimilarToMultiple
public void testMostSimilarToMultiple() throws Exception
{    ItemBasedRecommender recommender = buildRecommender2();    List<RecommendedItem> similar = recommender.mostSimilarItems(new long[] { 0, 1 }, 2);    assertNotNull(similar);    assertEquals(2, similar.size());    RecommendedItem first = similar.get(0);    RecommendedItem second = similar.get(1);    assertEquals(2, first.getItemID());    assertEquals(0.85f, first.getValue(), EPSILON);    assertEquals(3, second.getItemID());    assertEquals(-0.3f, second.getValue(), EPSILON);}
116a81a579d9545985b8eb954c99dba1e18e409848c98bfff4b8c6668c430f25
testMostSimilarToMultipleExcludeIfNotSimilarToAll
public void testMostSimilarToMultipleExcludeIfNotSimilarToAll() throws Exception
{    ItemBasedRecommender recommender = buildRecommender2();    List<RecommendedItem> similar = recommender.mostSimilarItems(new long[] { 3, 4 }, 2);    assertNotNull(similar);    assertEquals(1, similar.size());    RecommendedItem first = similar.get(0);    assertEquals(0, first.getItemID());    assertEquals(0.2f, first.getValue(), EPSILON);}
adeeed44495def3ba17515cae2b698cf928aca83ccb8148f2968e7f6315659d5
testMostSimilarToMultipleDontExcludeIfNotSimilarToAll
public void testMostSimilarToMultipleDontExcludeIfNotSimilarToAll() throws Exception
{    ItemBasedRecommender recommender = buildRecommender2();    List<RecommendedItem> similar = recommender.mostSimilarItems(new long[] { 1, 2, 4 }, 10, false);    assertNotNull(similar);    assertEquals(2, similar.size());    RecommendedItem first = similar.get(0);    RecommendedItem second = similar.get(1);    assertEquals(0, first.getItemID());    assertEquals(0.933333333f, first.getValue(), EPSILON);    assertEquals(3, second.getItemID());    assertEquals(-0.2f, second.getValue(), EPSILON);}
5587ccdc8d0d84d49f77a8d563ec47b1693dfdd613e665450db67681043d2887
testRecommendedBecause
public void testRecommendedBecause() throws Exception
{    ItemBasedRecommender recommender = buildRecommender2();    List<RecommendedItem> recommendedBecause = recommender.recommendedBecause(1, 4, 3);    assertNotNull(recommendedBecause);    assertEquals(3, recommendedBecause.size());    RecommendedItem first = recommendedBecause.get(0);    RecommendedItem second = recommendedBecause.get(1);    RecommendedItem third = recommendedBecause.get(2);    assertEquals(2, first.getItemID());    assertEquals(0.99f, first.getValue(), EPSILON);    assertEquals(3, second.getItemID());    assertEquals(0.4f, second.getValue(), EPSILON);    assertEquals(0, third.getItemID());    assertEquals(0.2f, third.getValue(), EPSILON);}
7cc7c1db5e1a61693bd2735f18fe83d49dbd7248c3a112f79d4fe84d7bf532f4
buildRecommender
private static ItemBasedRecommender buildRecommender()
{    DataModel dataModel = getDataModel();    Collection<GenericItemSimilarity.ItemItemSimilarity> similarities = Lists.newArrayList();    similarities.add(new GenericItemSimilarity.ItemItemSimilarity(0, 1, 1.0));    similarities.add(new GenericItemSimilarity.ItemItemSimilarity(0, 2, 0.5));    similarities.add(new GenericItemSimilarity.ItemItemSimilarity(1, 2, 0.0));    ItemSimilarity similarity = new GenericItemSimilarity(similarities);    return new GenericItemBasedRecommender(dataModel, similarity);}
d2b2820b56e3ac0b5477f9828ebc24234f7af3642317b6e9b26fa65fcd038ec9
buildRecommender2
private static ItemBasedRecommender buildRecommender2()
{    DataModel dataModel = getDataModel(new long[] { 1, 2, 3, 4 }, new Double[][] { { 0.1, 0.3, 0.9, 0.8 }, { 0.2, 0.3, 0.3, 0.4 }, { 0.4, 0.3, 0.5, 0.1, 0.1 }, { 0.7, 0.3, 0.8, 0.5, 0.6 } });    Collection<GenericItemSimilarity.ItemItemSimilarity> similarities = Lists.newArrayList();    similarities.add(new GenericItemSimilarity.ItemItemSimilarity(0, 1, 1.0));    similarities.add(new GenericItemSimilarity.ItemItemSimilarity(0, 2, 0.8));    similarities.add(new GenericItemSimilarity.ItemItemSimilarity(0, 3, -0.6));    similarities.add(new GenericItemSimilarity.ItemItemSimilarity(0, 4, 1.0));    similarities.add(new GenericItemSimilarity.ItemItemSimilarity(1, 2, 0.9));    similarities.add(new GenericItemSimilarity.ItemItemSimilarity(1, 3, 0.0));    similarities.add(new GenericItemSimilarity.ItemItemSimilarity(1, 1, 1.0));    similarities.add(new GenericItemSimilarity.ItemItemSimilarity(2, 3, -0.1));    similarities.add(new GenericItemSimilarity.ItemItemSimilarity(2, 4, 0.1));    similarities.add(new GenericItemSimilarity.ItemItemSimilarity(3, 4, -0.5));    ItemSimilarity similarity = new GenericItemSimilarity(similarities);    return new GenericItemBasedRecommender(dataModel, similarity);}
86d695ec45170d5a8b26f69c2833952cb81f13495c3cc761121f7fa5ef59d30e
preferencesFetchedOnlyOnce
public void preferencesFetchedOnlyOnce() throws Exception
{    DataModel dataModel = EasyMock.createMock(DataModel.class);    ItemSimilarity itemSimilarity = EasyMock.createMock(ItemSimilarity.class);    CandidateItemsStrategy candidateItemsStrategy = EasyMock.createMock(CandidateItemsStrategy.class);    MostSimilarItemsCandidateItemsStrategy mostSimilarItemsCandidateItemsStrategy = EasyMock.createMock(MostSimilarItemsCandidateItemsStrategy.class);    PreferenceArray preferencesFromUser = new GenericUserPreferenceArray(Arrays.asList(new GenericPreference(1L, 1L, 5.0f), new GenericPreference(1L, 2L, 4.0f)));    EasyMock.expect(dataModel.getMinPreference()).andReturn(Float.NaN);    EasyMock.expect(dataModel.getMaxPreference()).andReturn(Float.NaN);    EasyMock.expect(dataModel.getPreferencesFromUser(1L)).andReturn(preferencesFromUser);    EasyMock.expect(candidateItemsStrategy.getCandidateItems(1L, preferencesFromUser, dataModel, false)).andReturn(new FastIDSet(new long[] { 3L, 4L }));    EasyMock.expect(itemSimilarity.itemSimilarities(3L, preferencesFromUser.getIDs())).andReturn(new double[] { 0.5, 0.3 });    EasyMock.expect(itemSimilarity.itemSimilarities(4L, preferencesFromUser.getIDs())).andReturn(new double[] { 0.4, 0.1 });    EasyMock.replay(dataModel, itemSimilarity, candidateItemsStrategy, mostSimilarItemsCandidateItemsStrategy);    Recommender recommender = new GenericItemBasedRecommender(dataModel, itemSimilarity, candidateItemsStrategy, mostSimilarItemsCandidateItemsStrategy);    recommender.recommend(1L, 3);    EasyMock.verify(dataModel, itemSimilarity, candidateItemsStrategy, mostSimilarItemsCandidateItemsStrategy);}
f59647db375b6257eec6a1361739eda559801f71b23eb15d0682e922d2c49b4a
testRecommender
public void testRecommender() throws Exception
{    Recommender recommender = buildRecommender();    List<RecommendedItem> recommended = recommender.recommend(1, 1);    assertNotNull(recommended);    assertEquals(1, recommended.size());    RecommendedItem firstRecommended = recommended.get(0);    assertEquals(2, firstRecommended.getItemID());    assertEquals(0.1f, firstRecommended.getValue(), EPSILON);    recommender.refresh(null);    assertEquals(2, firstRecommended.getItemID());    assertEquals(0.1f, firstRecommended.getValue(), EPSILON);}
030790b9a0881722d06781d9580716c11ba0192f98d10e4a8811d47f0e7da015
testHowMany
public void testHowMany() throws Exception
{    DataModel dataModel = getDataModel(new long[] { 1, 2, 3, 4, 5 }, new Double[][] { { 0.1, 0.2 }, { 0.2, 0.3, 0.3, 0.6 }, { 0.4, 0.4, 0.5, 0.9 }, { 0.1, 0.4, 0.5, 0.8, 0.9, 1.0 }, { 0.2, 0.3, 0.6, 0.7, 0.1, 0.2 } });    UserSimilarity similarity = new PearsonCorrelationSimilarity(dataModel);    UserNeighborhood neighborhood = new NearestNUserNeighborhood(2, similarity, dataModel);    Recommender recommender = new GenericUserBasedRecommender(dataModel, neighborhood, similarity);    List<RecommendedItem> fewRecommended = recommender.recommend(1, 2);    List<RecommendedItem> moreRecommended = recommender.recommend(1, 4);    for (int i = 0; i < fewRecommended.size(); i++) {        assertEquals(fewRecommended.get(i).getItemID(), moreRecommended.get(i).getItemID());    }    recommender.refresh(null);    for (int i = 0; i < fewRecommended.size(); i++) {        assertEquals(fewRecommended.get(i).getItemID(), moreRecommended.get(i).getItemID());    }}
296b944336523cbbac2dfa5327391cbdda672c3f678fac51406bc3f8be80ff93
testRescorer
public void testRescorer() throws Exception
{    DataModel dataModel = getDataModel(new long[] { 1, 2, 3 }, new Double[][] { { 0.1, 0.2 }, { 0.2, 0.3, 0.3, 0.6 }, { 0.4, 0.5, 0.5, 0.9 } });    UserSimilarity similarity = new PearsonCorrelationSimilarity(dataModel);    UserNeighborhood neighborhood = new NearestNUserNeighborhood(2, similarity, dataModel);    Recommender recommender = new GenericUserBasedRecommender(dataModel, neighborhood, similarity);    List<RecommendedItem> originalRecommended = recommender.recommend(1, 2);    List<RecommendedItem> rescoredRecommended = recommender.recommend(1, 2, new ReversingRescorer<Long>());    assertNotNull(originalRecommended);    assertNotNull(rescoredRecommended);    assertEquals(2, originalRecommended.size());    assertEquals(2, rescoredRecommended.size());    assertEquals(originalRecommended.get(0).getItemID(), rescoredRecommended.get(1).getItemID());    assertEquals(originalRecommended.get(1).getItemID(), rescoredRecommended.get(0).getItemID());}
d4c888d3f719d919fb4a5f262090aa86f7969b7c273241636f799be5ed92d2b5
testIncludeKnownItems
public void testIncludeKnownItems() throws Exception
{    DataModel dataModel = getDataModel(new long[] { 1, 2, 3 }, new Double[][] { { 0.1, 0.2 }, { 0.2, 0.3, 0.3, 0.6 }, { 0.4, 0.5, 0.5, 0.9 } });    UserSimilarity similarity = new PearsonCorrelationSimilarity(dataModel);    UserNeighborhood neighborhood = new NearestNUserNeighborhood(2, similarity, dataModel);    Recommender recommender = new GenericUserBasedRecommender(dataModel, neighborhood, similarity);    List<RecommendedItem> originalRecommended = recommender.recommend(1, 4, null, true);    List<RecommendedItem> rescoredRecommended = recommender.recommend(1, 4, new ReversingRescorer<Long>(), true);    assertNotNull(originalRecommended);    assertNotNull(rescoredRecommended);    assertEquals(4, originalRecommended.size());    assertEquals(4, rescoredRecommended.size());    assertEquals(originalRecommended.get(0).getItemID(), rescoredRecommended.get(3).getItemID());    assertEquals(originalRecommended.get(3).getItemID(), rescoredRecommended.get(0).getItemID());}
df964c8d91f35f44ee8878053bf3358027bd810e43119f4d164936b066d4b9cc
testEstimatePref
public void testEstimatePref() throws Exception
{    Recommender recommender = buildRecommender();    assertEquals(0.1f, recommender.estimatePreference(1, 2), EPSILON);}
e200d1aa7562e7583cb1e80cc78125f8b978a084272e06ff75177592ff975c85
testBestRating
public void testBestRating() throws Exception
{    Recommender recommender = buildRecommender();    List<RecommendedItem> recommended = recommender.recommend(1, 1);    assertNotNull(recommended);    assertEquals(1, recommended.size());    RecommendedItem firstRecommended = recommended.get(0);        assertEquals(2, firstRecommended.getItemID());    assertEquals(0.1f, firstRecommended.getValue(), EPSILON);}
37fbbb11ea3f26026a08b697d158e2650e8f24e5d193a09d9bb84d1e743d9ba1
testMostSimilar
public void testMostSimilar() throws Exception
{    UserBasedRecommender recommender = buildRecommender();    long[] similar = recommender.mostSimilarUserIDs(1, 2);    assertNotNull(similar);    assertEquals(2, similar.length);    assertEquals(2, similar[0]);    assertEquals(3, similar[1]);}
3537284b25d664193b439616b2a3155883b7610c31b52ce436038057709b8cdf
testIsolatedUser
public void testIsolatedUser() throws Exception
{    DataModel dataModel = getDataModel(new long[] { 1, 2, 3, 4 }, new Double[][] { { 0.1, 0.2 }, { 0.2, 0.3, 0.3, 0.6 }, { 0.4, 0.4, 0.5, 0.9 }, { null, null, null, null, 1.0 } });    UserSimilarity similarity = new PearsonCorrelationSimilarity(dataModel);    UserNeighborhood neighborhood = new NearestNUserNeighborhood(3, similarity, dataModel);    UserBasedRecommender recommender = new GenericUserBasedRecommender(dataModel, neighborhood, similarity);    long[] mostSimilar = recommender.mostSimilarUserIDs(4, 3);    assertNotNull(mostSimilar);    assertEquals(0, mostSimilar.length);}
502ae03a251299161a02fdf6e7c0a597bf58f52fb7227f1bae9a234ab80a7638
buildRecommender
private static UserBasedRecommender buildRecommender() throws TasteException
{    DataModel dataModel = getDataModel();    UserSimilarity similarity = new PearsonCorrelationSimilarity(dataModel);    UserNeighborhood neighborhood = new NearestNUserNeighborhood(2, similarity, dataModel);    return new GenericUserBasedRecommender(dataModel, neighborhood, similarity);}
f59647db375b6257eec6a1361739eda559801f71b23eb15d0682e922d2c49b4a
testRecommender
public void testRecommender() throws Exception
{    Recommender recommender = new ItemAverageRecommender(getDataModel());    List<RecommendedItem> recommended = recommender.recommend(1, 1);    assertNotNull(recommended);    assertEquals(1, recommended.size());    RecommendedItem firstRecommended = recommended.get(0);    assertEquals(2, firstRecommended.getItemID());    assertEquals(0.53333336f, firstRecommended.getValue(), EPSILON);    recommender.refresh(null);    assertEquals(2, firstRecommended.getItemID());    assertEquals(0.53333336f, firstRecommended.getValue(), EPSILON);}
f59647db375b6257eec6a1361739eda559801f71b23eb15d0682e922d2c49b4a
testRecommender
public void testRecommender() throws Exception
{    Recommender recommender = new ItemUserAverageRecommender(getDataModel());    List<RecommendedItem> recommended = recommender.recommend(1, 1);    assertNotNull(recommended);    assertEquals(1, recommended.size());    RecommendedItem firstRecommended = recommended.get(0);    assertEquals(2, firstRecommended.getItemID());    assertEquals(0.35151517f, firstRecommended.getValue(), EPSILON);    recommender.refresh(null);    assertEquals(2, firstRecommended.getItemID());    assertEquals(0.35151517f, firstRecommended.getValue(), EPSILON);}
e1409df53a0ab2920489bc46aed33f3eb225b3538968a3c3af1ea3ae5aa9dad7
recommend
public List<RecommendedItem> recommend(long userID, int howMany)
{    recommendCount.increment();    return Collections.<RecommendedItem>singletonList(new GenericRecommendedItem(1, 1.0f));}
3ce334a91ae401070dd1d27675ff3da4500fec3d13b72f6281517b9f4e9268c7
recommend
public List<RecommendedItem> recommend(long userID, int howMany, boolean includeKnownItems)
{    return recommend(userID, howMany);}
8368a452ae6c75c26ae4859d0d3996cf16d51ac0a6be35e9a029cd55dffbdf54
recommend
public List<RecommendedItem> recommend(long userID, int howMany, IDRescorer rescorer)
{    return recommend(userID, howMany);}
b4ab824222f1e2358c39738432880e5cf30f59c1bc80f654e691e4516caf633d
recommend
public List<RecommendedItem> recommend(long userID, int howMany, IDRescorer rescorer, boolean includeKnownItems)
{    return recommend(userID, howMany);}
60ef549812a1fd865a8154b697b50a14f49eb5fbb80973fa689101cc9ebd2032
estimatePreference
public float estimatePreference(long userID, long itemID)
{    recommendCount.increment();    return 0.0f;}
479384395af79d778425896c46ecace2f63d7b050dc41d329f4a049b680177bb
setPreference
public void setPreference(long userID, long itemID, float value)
{}
7c2a92c2965e7e4ad97dde62c44d10be870d3da3b51da08551dd332ef4630ce5
removePreference
public void removePreference(long userID, long itemID)
{}
9cc8860ae5e18fe9fdcc3faca0fad6e9d7eb4076efef8c2790ec7efad6fe6102
getDataModel
public DataModel getDataModel()
{    return TasteTestCase.getDataModel(new long[] { 1, 2, 3 }, new Double[][] { { 1.0 }, { 2.0 }, { 3.0 } });}
da77e35d28c590f4b271e5b2b7f639c465574b8f17a1ef2f1df63e0152c57e8b
refresh
public void refresh(Collection<Refreshable> alreadyRefreshed)
{}
7d734a404f8f18aa225ef96ebc06c2a0bd0b1e18da4ce3e6f3cdff1ea1bc42b7
testItemRescorer
public void testItemRescorer() throws Exception
{    IDRescorer rescorer = NullRescorer.getItemInstance();    assertNotNull(rescorer);    assertEquals(1.0, rescorer.rescore(1L, 1.0), EPSILON);    assertEquals(1.0, rescorer.rescore(0L, 1.0), EPSILON);    assertEquals(0.0, rescorer.rescore(1L, 0.0), EPSILON);    assertTrue(Double.isNaN(rescorer.rescore(1L, Double.NaN)));}
b47ab7f73ad5ccf58edd3868273e00622ce7cc71db932a7f3418db11507885f0
testUserRescorer
public void testUserRescorer() throws Exception
{    IDRescorer rescorer = NullRescorer.getUserInstance();    assertNotNull(rescorer);    assertEquals(1.0, rescorer.rescore(1L, 1.0), EPSILON);    assertEquals(1.0, rescorer.rescore(0L, 1.0), EPSILON);    assertEquals(0.0, rescorer.rescore(1L, 0.0), EPSILON);    assertTrue(Double.isNaN(rescorer.rescore(1L, Double.NaN)));}
8347cda17c9c0f26c6605fe11e1deb134aa6a6314276f6915561ba61da5c5936
testStrategy
public void testStrategy() throws TasteException
{    FastIDSet itemIDsFromUser123 = new FastIDSet();    itemIDsFromUser123.add(1L);    FastIDSet itemIDsFromUser456 = new FastIDSet();    itemIDsFromUser456.add(1L);    itemIDsFromUser456.add(2L);    List<Preference> prefs = Lists.newArrayList();    prefs.add(new GenericPreference(123L, 1L, 1.0f));    prefs.add(new GenericPreference(456L, 1L, 1.0f));    PreferenceArray preferencesForItem1 = new GenericItemPreferenceArray(prefs);    DataModel dataModel = EasyMock.createMock(DataModel.class);    EasyMock.expect(dataModel.getPreferencesForItem(1L)).andReturn(preferencesForItem1);    EasyMock.expect(dataModel.getItemIDsFromUser(123L)).andReturn(itemIDsFromUser123);    EasyMock.expect(dataModel.getItemIDsFromUser(456L)).andReturn(itemIDsFromUser456);    PreferenceArray prefArrayOfUser123 = new GenericUserPreferenceArray(Collections.singletonList(new GenericPreference(123L, 1L, 1.0f)));    CandidateItemsStrategy strategy = new PreferredItemsNeighborhoodCandidateItemsStrategy();    EasyMock.replay(dataModel);    FastIDSet candidateItems = strategy.getCandidateItems(123L, prefArrayOfUser123, dataModel, false);    assertEquals(1, candidateItems.size());    assertTrue(candidateItems.contains(2L));    EasyMock.verify(dataModel);}
f59647db375b6257eec6a1361739eda559801f71b23eb15d0682e922d2c49b4a
testRecommender
public void testRecommender() throws Exception
{    Recommender recommender = new RandomRecommender(getDataModel());    List<RecommendedItem> recommended = recommender.recommend(1, 1);    assertNotNull(recommended);    assertEquals(1, recommended.size());    RecommendedItem firstRecommended = recommended.get(0);    assertEquals(2, firstRecommended.getItemID());    recommender.refresh(null);    assertEquals(2, firstRecommended.getItemID());}
8376b6a737ec31eaa88431d21e20e907f909a8b7e4c435594e69c915dfa93a37
rescore
public double rescore(T thing, double originalScore)
{    return -originalScore;}
0e8f3eed7d9f8ff01276b27b9f8222d8765e6743d3c4852f2a007d280e7b3ffc
isFiltered
public boolean isFiltered(T thing)
{    return false;}
5c7fab1ac6b5716525cd2277447886de9ed5777d505e8225121854d8068716b2
rescore
public double rescore(long ID, double originalScore)
{    return -originalScore;}
a7f3f28f2a701b53aa877c5bbfc565126bb026b697b5475a8be1adf6d115c8b4
isFiltered
public boolean isFiltered(long ID)
{    return false;}
8347cda17c9c0f26c6605fe11e1deb134aa6a6314276f6915561ba61da5c5936
testStrategy
public void testStrategy() throws TasteException
{    List<Preference> prefsOfUser123 = Lists.newArrayList();    prefsOfUser123.add(new GenericPreference(123L, 1L, 1.0f));    List<Preference> prefsOfUser456 = Lists.newArrayList();    prefsOfUser456.add(new GenericPreference(456L, 1L, 1.0f));    prefsOfUser456.add(new GenericPreference(456L, 2L, 1.0f));    List<Preference> prefsOfUser789 = Lists.newArrayList();    prefsOfUser789.add(new GenericPreference(789L, 1L, 0.5f));    prefsOfUser789.add(new GenericPreference(789L, 3L, 1.0f));    PreferenceArray prefArrayOfUser123 = new GenericUserPreferenceArray(prefsOfUser123);    FastByIDMap<PreferenceArray> userData = new FastByIDMap<>();    userData.put(123L, prefArrayOfUser123);    userData.put(456L, new GenericUserPreferenceArray(prefsOfUser456));    userData.put(789L, new GenericUserPreferenceArray(prefsOfUser789));    DataModel dataModel = new GenericDataModel(userData);    CandidateItemsStrategy strategy = new SamplingCandidateItemsStrategy(1, 1, 1, dataModel.getNumUsers(), dataModel.getNumItems());    FastIDSet candidateItems = strategy.getCandidateItems(123L, prefArrayOfUser123, dataModel, false);    /* result can be either item2 or item3 or empty */    assertTrue(candidateItems.size() <= 1);    assertFalse(candidateItems.contains(1L));}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    super.setUp();    FastByIDMap<PreferenceArray> userData = new FastByIDMap<>();    userData.put(1L, new GenericUserPreferenceArray(Arrays.asList(new GenericPreference(1L, 1L, 5.0f), new GenericPreference(1L, 2L, 5.0f), new GenericPreference(1L, 3L, 2.0f))));    userData.put(2L, new GenericUserPreferenceArray(Arrays.asList(new GenericPreference(2L, 1L, 2.0f), new GenericPreference(2L, 3L, 3.0f), new GenericPreference(2L, 4L, 5.0f))));    userData.put(3L, new GenericUserPreferenceArray(Arrays.asList(new GenericPreference(3L, 2L, 5.0f), new GenericPreference(3L, 4L, 3.0f))));    userData.put(4L, new GenericUserPreferenceArray(Arrays.asList(new GenericPreference(4L, 1L, 3.0f), new GenericPreference(4L, 4L, 5.0f))));    dataModel = new GenericDataModel(userData);    factorizer = new ALSWRFactorizer(dataModel, 3, 0.065, 10);}
44acb81f2d22c6d7cd13c8f7f60bbe77673292a1812c8a18fd32c404ee2d97a4
setFeatureColumn
public void setFeatureColumn() throws Exception
{    ALSWRFactorizer.Features features = new ALSWRFactorizer.Features(factorizer);    Vector vector = new DenseVector(new double[] { 0.5, 2.0, 1.5 });    int index = 1;    features.setFeatureColumnInM(index, vector);    double[][] matrix = features.getM();    assertEquals(vector.get(0), matrix[index][0], EPSILON);    assertEquals(vector.get(1), matrix[index][1], EPSILON);    assertEquals(vector.get(2), matrix[index][2], EPSILON);}
48943e85fd2cf813b0bb1faac2ba29b8d855fae28cf2c73e1d7a746a3b0f0010
ratingVector
public void ratingVector() throws Exception
{    PreferenceArray prefs = dataModel.getPreferencesFromUser(1);    Vector ratingVector = ALSWRFactorizer.ratingVector(prefs);    assertEquals(prefs.length(), ratingVector.getNumNondefaultElements());    assertEquals(prefs.get(0).getValue(), ratingVector.get(0), EPSILON);    assertEquals(prefs.get(1).getValue(), ratingVector.get(1), EPSILON);    assertEquals(prefs.get(2).getValue(), ratingVector.get(2), EPSILON);}
d701819ec6da114833008caf786f0ff1e1f86063f5b984256f801c6bf0cf2a3c
averageRating
public void averageRating() throws Exception
{    ALSWRFactorizer.Features features = new ALSWRFactorizer.Features(factorizer);    assertEquals(2.5, features.averateRating(3L), EPSILON);}
52dc871a339306a8aa717ff209a9f777b006008650e09b8ad45e39bcf7cd815d
initializeM
public void initializeM() throws Exception
{    ALSWRFactorizer.Features features = new ALSWRFactorizer.Features(factorizer);    double[][] M = features.getM();    assertEquals(3.333333333, M[0][0], EPSILON);    assertEquals(5, M[1][0], EPSILON);    assertEquals(2.5, M[2][0], EPSILON);    assertEquals(4.333333333, M[3][0], EPSILON);    for (int itemIndex = 0; itemIndex < dataModel.getNumItems(); itemIndex++) {        for (int feature = 1; feature < 3; feature++) {            assertTrue(M[itemIndex][feature] >= 0);            assertTrue(M[itemIndex][feature] <= 0.1);        }    }}
b0d5a70c0db77adc1ec87a496c78ae1bc9000446ca4d96dc02532cb37ae13056
toyExample
public void toyExample() throws Exception
{    SVDRecommender svdRecommender = new SVDRecommender(dataModel, factorizer);    /* a hold out test would be better, but this is just a toy example so we only check that the    * factorization is close to the original matrix */    RunningAverage avg = new FullRunningAverage();    LongPrimitiveIterator userIDs = dataModel.getUserIDs();    while (userIDs.hasNext()) {        long userID = userIDs.nextLong();        for (Preference pref : dataModel.getPreferencesFromUser(userID)) {            double rating = pref.getValue();            double estimate = svdRecommender.estimatePreference(userID, pref.getItemID());            double err = rating - estimate;            avg.addDatum(err * err);        }    }    double rmse = Math.sqrt(avg.getAverage());    assertTrue(rmse < 0.2);}
1c115ccd80551d88617fff547df159fb2173611b921b4cba224bafe1115e9f4a
toyExampleImplicit
public void toyExampleImplicit() throws Exception
{    Matrix observations = new SparseRowMatrix(4, 4, new Vector[] { new DenseVector(new double[] { 5.0, 5.0, 2.0, 0 }), new DenseVector(new double[] { 2.0, 0, 3.0, 5.0 }), new DenseVector(new double[] { 0, 5.0, 0, 3.0 }), new DenseVector(new double[] { 3.0, 0, 0, 5.0 }) });    Matrix preferences = new SparseRowMatrix(4, 4, new Vector[] { new DenseVector(new double[] { 1.0, 1.0, 1.0, 0 }), new DenseVector(new double[] { 1.0, 0, 1.0, 1.0 }), new DenseVector(new double[] { 0, 1.0, 0, 1.0 }), new DenseVector(new double[] { 1.0, 0, 0, 1.0 }) });    double alpha = 20;    ALSWRFactorizer factorizer = new ALSWRFactorizer(dataModel, 3, 0.065, 5, true, alpha);    SVDRecommender svdRecommender = new SVDRecommender(dataModel, factorizer);    RunningAverage avg = new FullRunningAverage();    Iterator<MatrixSlice> sliceIterator = preferences.iterateAll();    while (sliceIterator.hasNext()) {        MatrixSlice slice = sliceIterator.next();        for (Vector.Element e : slice.vector().all()) {            long userID = slice.index() + 1;            long itemID = e.index() + 1;            if (!Double.isNaN(e.get())) {                double pref = e.get();                double estimate = svdRecommender.estimatePreference(userID, itemID);                double confidence = 1 + alpha * observations.getQuick(slice.index(), e.index());                double err = confidence * (pref - estimate) * (pref - estimate);                avg.addDatum(err);                log.info("Comparing preference of user [{}] towards item [{}], was [{}] with confidence [{}] " + "estimate is [{}]", slice.index(), e.index(), pref, confidence, estimate);            }        }    }    double rmse = Math.sqrt(avg.getAverage());    log.info("RMSE: {}", rmse);    assertTrue(rmse < 0.4);}
1876c73bfb32bcb962b2e8dde92918e1dc00ed5fc04d8b00687be1ffc3c82b61
persistAndLoad
public void persistAndLoad() throws Exception
{    FastByIDMap<Integer> userIDMapping = new FastByIDMap<>();    FastByIDMap<Integer> itemIDMapping = new FastByIDMap<>();    userIDMapping.put(123, 0);    userIDMapping.put(456, 1);    itemIDMapping.put(12, 0);    itemIDMapping.put(34, 1);    double[][] userFeatures = { { 0.1, 0.2, 0.3 }, { 0.4, 0.5, 0.6 } };    double[][] itemFeatures = { { 0.7, 0.8, 0.9 }, { 1.0, 1.1, 1.2 } };    Factorization original = new Factorization(userIDMapping, itemIDMapping, userFeatures, itemFeatures);    File storage = getTestTempFile("storage.bin");    PersistenceStrategy persistenceStrategy = new FilePersistenceStrategy(storage);    assertNull(persistenceStrategy.load());    persistenceStrategy.maybePersist(original);    Factorization clone = persistenceStrategy.load();    assertEquals(original, clone);}
df6eb33665b7c3aa96e9600dbe61fdd9b12eb2e715676398ca328737ce8854db
randomMatrix
private Matrix randomMatrix(int numRows, int numColumns, double range)
{    double[][] data = new double[numRows][numColumns];    for (int i = 0; i < numRows; i++) {        for (int j = 0; j < numColumns; j++) {            double sqrtUniform = random.nextDouble();            data[i][j] = sqrtUniform * range;        }    }    return new DenseMatrix(data);}
b07dd28220c2f6901b829fded501311fd33477b5e2819c2ae92efbad3c8755d2
normalize
private void normalize(Matrix source, final double range)
{    final double max = source.aggregateColumns(new VectorFunction() {        @Override        public double apply(Vector column) {            return column.maxValue();        }    }).maxValue();    final double min = source.aggregateColumns(new VectorFunction() {        @Override        public double apply(Vector column) {            return column.minValue();        }    }).minValue();    source.assign(new DoubleFunction() {        @Override        public double apply(double value) {            return (value - min) * range / (max - min);        }    });}
d44807f40be9989f4b4b147ef4221da6e1d95e5f1da0858331b622f6f86573ba
apply
public double apply(Vector column)
{    return column.maxValue();}
d44807f40be9989f4b4b147ef4221da6e1d95e5f1da0858331b622f6f86573ba
apply
public double apply(Vector column)
{    return column.minValue();}
0fa4f70d2cbb35a15ebfda56407ad35745145e39a65bfe242c8abe3607095d6c
apply
public double apply(double value)
{    return (value - min) * range / (max - min);}
d8141c8424b21c28a3e1b03da4f24689eab7fa5eecc89ce7b9559869424f518f
setUpSyntheticData
public void setUpSyntheticData() throws Exception
{    int numUsers = 2000;    int numItems = 1000;    double sparsity = 0.5;    this.rank = 20;    this.lambda = 0.000000001;    this.numIterations = 100;    Matrix users = randomMatrix(numUsers, rank, 1);    Matrix items = randomMatrix(rank, numItems, 1);    Matrix ratings = users.times(items);    normalize(ratings, 5);    FastByIDMap<PreferenceArray> userData = new FastByIDMap<>();    for (int userIndex = 0; userIndex < numUsers; userIndex++) {        List<Preference> row = Lists.newArrayList();        for (int itemIndex = 0; itemIndex < numItems; itemIndex++) {            if (random.nextDouble() <= sparsity) {                row.add(new GenericPreference(userIndex, itemIndex, (float) ratings.get(userIndex, itemIndex)));            }        }        userData.put(userIndex, new GenericUserPreferenceArray(row));    }    dataModel = new GenericDataModel(userData);}
ecf6ccb390f6d1e907eb3cd7de7e3d3149479f342dcf3ff8accff329f2764670
setUpToyData
public void setUpToyData() throws Exception
{    this.rank = 3;    this.lambda = 0.01;    this.numIterations = 1000;    FastByIDMap<PreferenceArray> userData = new FastByIDMap<>();    userData.put(1L, new GenericUserPreferenceArray(Arrays.asList(new GenericPreference(1L, 1L, 5.0f), new GenericPreference(1L, 2L, 5.0f), new GenericPreference(1L, 3L, 2.0f))));    userData.put(2L, new GenericUserPreferenceArray(Arrays.asList(new GenericPreference(2L, 1L, 2.0f), new GenericPreference(2L, 3L, 3.0f), new GenericPreference(2L, 4L, 5.0f))));    userData.put(3L, new GenericUserPreferenceArray(Arrays.asList(new GenericPreference(3L, 2L, 5.0f), new GenericPreference(3L, 4L, 3.0f))));    userData.put(4L, new GenericUserPreferenceArray(Arrays.asList(new GenericPreference(4L, 1L, 3.0f), new GenericPreference(4L, 4L, 5.0f))));    dataModel = new GenericDataModel(userData);}
429b4d1487579a882e599a76a2b98547777c6fc029edb861cb25b1b8d59aacda
testPreferenceShufflerWithSyntheticData
public void testPreferenceShufflerWithSyntheticData() throws Exception
{    setUpSyntheticData();    ParallelSGDFactorizer.PreferenceShuffler shuffler = new PreferenceShuffler(dataModel);    shuffler.shuffle();    shuffler.stage();    FastByIDMap<FastByIDMap<Boolean>> checked = new FastByIDMap<>();    for (int i = 0; i < shuffler.size(); i++) {        Preference pref = shuffler.get(i);        float value = dataModel.getPreferenceValue(pref.getUserID(), pref.getItemID());        assertEquals(pref.getValue(), value, 0.0);        if (!checked.containsKey(pref.getUserID())) {            checked.put(pref.getUserID(), new FastByIDMap<Boolean>());        }        assertNull(checked.get(pref.getUserID()).get(pref.getItemID()));        checked.get(pref.getUserID()).put(pref.getItemID(), true);    }    LongPrimitiveIterator userIDs = dataModel.getUserIDs();    int index = 0;    while (userIDs.hasNext()) {        long userID = userIDs.nextLong();        PreferenceArray preferencesFromUser = dataModel.getPreferencesFromUser(userID);        for (Preference preference : preferencesFromUser) {            assertTrue(checked.get(preference.getUserID()).get(preference.getItemID()));            index++;        }    }    assertEquals(index, shuffler.size());}
eb7ab24a4fdbba978fc678ea321e073b3c612ed67df3d6768331300f0418b218
testFactorizerWithToyData
public void testFactorizerWithToyData() throws Exception
{    setUpToyData();    long start = System.currentTimeMillis();    factorizer = new ParallelSGDFactorizer(dataModel, rank, lambda, numIterations, 0.01, 1, 0, 0);    Factorization factorization = factorizer.factorize();    long duration = System.currentTimeMillis() - start;    /* a hold out test would be better, but this is just a toy example so we only check that the     * factorization is close to the original matrix */    RunningAverage avg = new FullRunningAverage();    LongPrimitiveIterator userIDs = dataModel.getUserIDs();    LongPrimitiveIterator itemIDs;    while (userIDs.hasNext()) {        long userID = userIDs.nextLong();        for (Preference pref : dataModel.getPreferencesFromUser(userID)) {            double rating = pref.getValue();            Vector userVector = new DenseVector(factorization.getUserFeatures(userID));            Vector itemVector = new DenseVector(factorization.getItemFeatures(pref.getItemID()));            double estimate = userVector.dot(itemVector);            double err = rating - estimate;            avg.addDatum(err * err);        }    }    double sum = 0.0;    userIDs = dataModel.getUserIDs();    while (userIDs.hasNext()) {        long userID = userIDs.nextLong();        Vector userVector = new DenseVector(factorization.getUserFeatures(userID));        double regularization = userVector.dot(userVector);        sum += regularization;    }    itemIDs = dataModel.getItemIDs();    while (itemIDs.hasNext()) {        long itemID = itemIDs.nextLong();        Vector itemVector = new DenseVector(factorization.getUserFeatures(itemID));        double regularization = itemVector.dot(itemVector);        sum += regularization;    }    double rmse = Math.sqrt(avg.getAverage());    double loss = avg.getAverage() / 2 + lambda / 2 * sum;    logger.info("RMSE: " + rmse + ";\tLoss: " + loss + ";\tTime Used: " + duration);    assertTrue(rmse < 0.2);}
0f1a4a4f5ef73ce0c502c63584504c3cb80c439d368cc732a51d503a10d1df73
testRecommenderWithToyData
public void testRecommenderWithToyData() throws Exception
{    setUpToyData();    factorizer = new ParallelSGDFactorizer(dataModel, rank, lambda, numIterations, 0.01, 1, 0, 0);    svdRecommender = new SVDRecommender(dataModel, factorizer);    /* a hold out test would be better, but this is just a toy example so we only check that the     * factorization is close to the original matrix */    RunningAverage avg = new FullRunningAverage();    LongPrimitiveIterator userIDs = dataModel.getUserIDs();    while (userIDs.hasNext()) {        long userID = userIDs.nextLong();        for (Preference pref : dataModel.getPreferencesFromUser(userID)) {            double rating = pref.getValue();            double estimate = svdRecommender.estimatePreference(userID, pref.getItemID());            double err = rating - estimate;            avg.addDatum(err * err);        }    }    double rmse = Math.sqrt(avg.getAverage());    logger.info("rmse: " + rmse);    assertTrue(rmse < 0.2);}
8a657acb33de2e8799ff5c968ec6d55c2ea41ab5bc622c2bd25a918cfc846d6c
testFactorizerWithWithSyntheticData
public void testFactorizerWithWithSyntheticData() throws Exception
{    setUpSyntheticData();    long start = System.currentTimeMillis();    factorizer = new ParallelSGDFactorizer(dataModel, rank, lambda, numIterations, 0.01, 1, 0, 0);    Factorization factorization = factorizer.factorize();    long duration = System.currentTimeMillis() - start;    /* a hold out test would be better, but this is just a toy example so we only check that the     * factorization is close to the original matrix */    RunningAverage avg = new FullRunningAverage();    LongPrimitiveIterator userIDs = dataModel.getUserIDs();    LongPrimitiveIterator itemIDs;    while (userIDs.hasNext()) {        long userID = userIDs.nextLong();        for (Preference pref : dataModel.getPreferencesFromUser(userID)) {            double rating = pref.getValue();            Vector userVector = new DenseVector(factorization.getUserFeatures(userID));            Vector itemVector = new DenseVector(factorization.getItemFeatures(pref.getItemID()));            double estimate = userVector.dot(itemVector);            double err = rating - estimate;            avg.addDatum(err * err);        }    }    double sum = 0.0;    userIDs = dataModel.getUserIDs();    while (userIDs.hasNext()) {        long userID = userIDs.nextLong();        Vector userVector = new DenseVector(factorization.getUserFeatures(userID));        double regularization = userVector.dot(userVector);        sum += regularization;    }    itemIDs = dataModel.getItemIDs();    while (itemIDs.hasNext()) {        long itemID = itemIDs.nextLong();        Vector itemVector = new DenseVector(factorization.getUserFeatures(itemID));        double regularization = itemVector.dot(itemVector);        sum += regularization;    }    double rmse = Math.sqrt(avg.getAverage());    double loss = avg.getAverage() / 2 + lambda / 2 * sum;    logger.info("RMSE: " + rmse + ";\tLoss: " + loss + ";\tTime Used: " + duration + "ms");    assertTrue(rmse < 0.2);}
16faf7b709886c12853e2fdbe2fda63e1d25a11b32293fe4db45c6aa2d4c49f6
testRecommenderWithSyntheticData
public void testRecommenderWithSyntheticData() throws Exception
{    setUpSyntheticData();    factorizer = new ParallelSGDFactorizer(dataModel, rank, lambda, numIterations, 0.01, 1, 0, 0);    svdRecommender = new SVDRecommender(dataModel, factorizer);    /* a hold out test would be better, but this is just a toy example so we only check that the     * factorization is close to the original matrix */    RunningAverage avg = new FullRunningAverage();    LongPrimitiveIterator userIDs = dataModel.getUserIDs();    while (userIDs.hasNext()) {        long userID = userIDs.nextLong();        for (Preference pref : dataModel.getPreferencesFromUser(userID)) {            double rating = pref.getValue();            double estimate = svdRecommender.estimatePreference(userID, pref.getItemID());            double err = rating - estimate;            avg.addDatum(err * err);        }    }    double rmse = Math.sqrt(avg.getAverage());    logger.info("rmse: " + rmse);    assertTrue(rmse < 0.2);}
6048c332959126eaedcedd5b9c954694108dd8e5f3a4ee0871e82d1efcf043c6
estimatePreference
public void estimatePreference() throws Exception
{    DataModel dataModel = EasyMock.createMock(DataModel.class);    Factorizer factorizer = EasyMock.createMock(Factorizer.class);    Factorization factorization = EasyMock.createMock(Factorization.class);    EasyMock.expect(factorizer.factorize()).andReturn(factorization);    EasyMock.expect(factorization.getUserFeatures(1L)).andReturn(new double[] { 0.4, 2 });    EasyMock.expect(factorization.getItemFeatures(5L)).andReturn(new double[] { 1, 0.3 });    EasyMock.replay(dataModel, factorizer, factorization);    SVDRecommender svdRecommender = new SVDRecommender(dataModel, factorizer);    float estimate = svdRecommender.estimatePreference(1L, 5L);    assertEquals(1, estimate, EPSILON);    EasyMock.verify(dataModel, factorizer, factorization);}
4b7e1e3bcec6ff5f125e63199552f218ff3f89252bd9f996bf58874dc21cf019
recommend
public void recommend() throws Exception
{    DataModel dataModel = EasyMock.createMock(DataModel.class);    PreferenceArray preferencesFromUser = EasyMock.createMock(PreferenceArray.class);    CandidateItemsStrategy candidateItemsStrategy = EasyMock.createMock(CandidateItemsStrategy.class);    Factorizer factorizer = EasyMock.createMock(Factorizer.class);    Factorization factorization = EasyMock.createMock(Factorization.class);    FastIDSet candidateItems = new FastIDSet();    candidateItems.add(5L);    candidateItems.add(3L);    EasyMock.expect(factorizer.factorize()).andReturn(factorization);    EasyMock.expect(dataModel.getPreferencesFromUser(1L)).andReturn(preferencesFromUser);    EasyMock.expect(candidateItemsStrategy.getCandidateItems(1L, preferencesFromUser, dataModel, false)).andReturn(candidateItems);    EasyMock.expect(factorization.getUserFeatures(1L)).andReturn(new double[] { 0.4, 2 });    EasyMock.expect(factorization.getItemFeatures(5L)).andReturn(new double[] { 1, 0.3 });    EasyMock.expect(factorization.getUserFeatures(1L)).andReturn(new double[] { 0.4, 2 });    EasyMock.expect(factorization.getItemFeatures(3L)).andReturn(new double[] { 2, 0.6 });    EasyMock.replay(dataModel, candidateItemsStrategy, factorizer, factorization);    SVDRecommender svdRecommender = new SVDRecommender(dataModel, factorizer, candidateItemsStrategy);    List<RecommendedItem> recommendedItems = svdRecommender.recommend(1L, 5);    assertEquals(2, recommendedItems.size());    assertEquals(3L, recommendedItems.get(0).getItemID());    assertEquals(2.0f, recommendedItems.get(0).getValue(), EPSILON);    assertEquals(5L, recommendedItems.get(1).getItemID());    assertEquals(1.0f, recommendedItems.get(1).getValue(), EPSILON);    EasyMock.verify(dataModel, candidateItemsStrategy, factorizer, factorization);}
689522e62c5a7dea53520a906dc9ef1ce7c683580a970145898346f05a8378de
testTopItems
public void testTopItems() throws Exception
{    long[] ids = new long[100];    for (int i = 0; i < 100; i++) {        ids[i] = i;    }    LongPrimitiveIterator possibleItemIds = new LongPrimitiveArrayIterator(ids);    TopItems.Estimator<Long> estimator = new TopItems.Estimator<Long>() {        @Override        public double estimate(Long thing) {            return thing;        }    };    List<RecommendedItem> topItems = TopItems.getTopItems(10, possibleItemIds, null, estimator);    int gold = 99;    for (RecommendedItem topItem : topItems) {        assertEquals(gold, topItem.getItemID());        assertEquals(gold--, topItem.getValue(), 0.01);    }}
2b8399a52708d06f2804cc3fa7ac4e0beb137e46bbc81c26d776d52a81b78119
estimate
public double estimate(Long thing)
{    return thing;}
88c76a49e6ab9cdb24f8735cb6d695e182921a5cd6f886fa66526e888cf125b9
testTopItemsRandom
public void testTopItemsRandom() throws Exception
{    long[] ids = new long[100];    for (int i = 0; i < 100; i++) {        ids[i] = i;    }    LongPrimitiveIterator possibleItemIds = new LongPrimitiveArrayIterator(ids);    final Random random = RandomUtils.getRandom();    TopItems.Estimator<Long> estimator = new TopItems.Estimator<Long>() {        @Override        public double estimate(Long thing) {            return random.nextDouble();        }    };    List<RecommendedItem> topItems = TopItems.getTopItems(10, possibleItemIds, null, estimator);    assertEquals(10, topItems.size());    double last = 2.0;    for (RecommendedItem topItem : topItems) {        assertTrue(topItem.getValue() <= last);        last = topItem.getItemID();    }}
2b8399a52708d06f2804cc3fa7ac4e0beb137e46bbc81c26d776d52a81b78119
estimate
public double estimate(Long thing)
{    return random.nextDouble();}
17a82a452ab1c21c3d45a89f3b3f036d93898ea6c4cce34f5aee37f305dcc327
testTopUsers
public void testTopUsers() throws Exception
{    long[] ids = new long[100];    for (int i = 0; i < 100; i++) {        ids[i] = i;    }    LongPrimitiveIterator possibleItemIds = new LongPrimitiveArrayIterator(ids);    TopItems.Estimator<Long> estimator = new TopItems.Estimator<Long>() {        @Override        public double estimate(Long thing) {            return thing;        }    };    long[] topItems = TopItems.getTopUsers(10, possibleItemIds, null, estimator);    int gold = 99;    for (long topItem : topItems) {        assertEquals(gold--, topItem);    }}
2b8399a52708d06f2804cc3fa7ac4e0beb137e46bbc81c26d776d52a81b78119
estimate
public double estimate(Long thing)
{    return thing;}
521fdd17dbe836660eacedf220bc70e54a8a8d209631ad8efcc2c4afc381aef4
testTopItemItem
public void testTopItemItem() throws Exception
{    List<GenericItemSimilarity.ItemItemSimilarity> sims = Lists.newArrayList();    for (int i = 0; i < 99; i++) {        sims.add(new GenericItemSimilarity.ItemItemSimilarity(i, i + 1, i / 99.0));    }    List<GenericItemSimilarity.ItemItemSimilarity> res = TopItems.getTopItemItemSimilarities(10, sims.iterator());    int gold = 99;    for (GenericItemSimilarity.ItemItemSimilarity re : res) {                assertEquals(gold--, re.getItemID2());    }}
83d287dab240273d94ed209dc90772f5ea02d4776f86d7c51815fc34b37b73dd
testTopItemItemAlt
public void testTopItemItemAlt() throws Exception
{    List<GenericItemSimilarity.ItemItemSimilarity> sims = Lists.newArrayList();    for (int i = 0; i < 99; i++) {        sims.add(new GenericItemSimilarity.ItemItemSimilarity(i, i + 1, 1 - (i / 99.0)));    }    List<GenericItemSimilarity.ItemItemSimilarity> res = TopItems.getTopItemItemSimilarities(10, sims.iterator());    int gold = 0;    for (GenericItemSimilarity.ItemItemSimilarity re : res) {                assertEquals(gold++, re.getItemID1());    }}
ec337ebced35cbc8432e99bb64b8159b07890ad8063831d5b74c797f2bb454dd
testTopUserUser
public void testTopUserUser() throws Exception
{    List<GenericUserSimilarity.UserUserSimilarity> sims = Lists.newArrayList();    for (int i = 0; i < 99; i++) {        sims.add(new GenericUserSimilarity.UserUserSimilarity(i, i + 1, i / 99.0));    }    List<GenericUserSimilarity.UserUserSimilarity> res = TopItems.getTopUserUserSimilarities(10, sims.iterator());    int gold = 99;    for (GenericUserSimilarity.UserUserSimilarity re : res) {                assertEquals(gold--, re.getUserID2());    }}
013d3ed0257cc86a37d101554d3f070e4b9963cbbcfac1583c9458371f5f34c8
testTopUserUserAlt
public void testTopUserUserAlt() throws Exception
{    List<GenericUserSimilarity.UserUserSimilarity> sims = Lists.newArrayList();    for (int i = 0; i < 99; i++) {        sims.add(new GenericUserSimilarity.UserUserSimilarity(i, i + 1, 1 - (i / 99.0)));    }    List<GenericUserSimilarity.UserUserSimilarity> res = TopItems.getTopUserUserSimilarities(10, sims.iterator());    int gold = 0;    for (GenericUserSimilarity.UserUserSimilarity re : res) {                assertEquals(gold++, re.getUserID1());    }}
35d3e58aa572dfdb7285aaede058d567768b12198717db9bf1ba89d72dcb7bab
testInferrer
public void testInferrer() throws TasteException
{    DataModel model = getDataModel(new long[] { 1 }, new Double[][] { { 3.0, -2.0, 5.0 } });    PreferenceInferrer inferrer = new AveragingPreferenceInferrer(model);    double inferred = inferrer.inferPreference(1, 3);    assertEquals(2.0, inferred, EPSILON);}
730b2679f9ca63b9779a2defc484d69e899d92e1f67e9e75a871351b35327c5d
testFullCorrelation1
public void testFullCorrelation1() throws Exception
{    DataModel dataModel = getDataModel(new long[] { 1, 2 }, new Double[][] { { 3.0, -2.0 }, { 3.0, -2.0 } });    double correlation = new EuclideanDistanceSimilarity(dataModel).userSimilarity(1, 2);    assertCorrelationEquals(1.0, correlation);}
56d072401e9a5024ec54f44e399df262a502d59ef8f34c17b888391d467b39e5
testFullCorrelation1Weighted
public void testFullCorrelation1Weighted() throws Exception
{    DataModel dataModel = getDataModel(new long[] { 1, 2 }, new Double[][] { { 3.0, -2.0 }, { 3.0, -2.0 } });    double correlation = new EuclideanDistanceSimilarity(dataModel, Weighting.WEIGHTED).userSimilarity(1, 2);    assertCorrelationEquals(1.0, correlation);}
deee697d64e562be19ba52a93b9ddb1d0176b27524cea541ce49db8e2b2b0a7b
testFullCorrelation2
public void testFullCorrelation2() throws Exception
{    DataModel dataModel = getDataModel(new long[] { 1, 2 }, new Double[][] { { 3.0, 3.0 }, { 3.0, 3.0 } });    double correlation = new EuclideanDistanceSimilarity(dataModel).userSimilarity(1, 2);    assertEquals(1.0, correlation, EPSILON);}
38e633989a63026efd525a20e9075fae48b69526f22fea4dee605a5dd589eef2
testNoCorrelation1
public void testNoCorrelation1() throws Exception
{    DataModel dataModel = getDataModel(new long[] { 1, 2 }, new Double[][] { { 3.0, -2.0 }, { -3.0, 2.0 } });    double correlation = new EuclideanDistanceSimilarity(dataModel).userSimilarity(1, 2);    assertCorrelationEquals(0.1639607805437114, correlation);}
2b2c2b6291f7af86bc1c35466d274e629970efbf727408a19bb0ad3aa411c253
testNoCorrelation1Weighted
public void testNoCorrelation1Weighted() throws Exception
{    DataModel dataModel = getDataModel(new long[] { 1, 2 }, new Double[][] { { 3.0, -2.0 }, { -3.0, 2.0 } });    double correlation = new EuclideanDistanceSimilarity(dataModel, Weighting.WEIGHTED).userSimilarity(1, 2);    assertCorrelationEquals(0.7213202601812372, correlation);}
165bd850ae0d736fd009ec55764e777b1d4675495e67382605fb30ffe4f7d56a
testNoCorrelation2
public void testNoCorrelation2() throws Exception
{    DataModel dataModel = getDataModel(new long[] { 1, 2 }, new Double[][] { { null, 1.0, null }, { null, null, 1.0 } });    double correlation = new EuclideanDistanceSimilarity(dataModel).userSimilarity(1, 2);    assertTrue(Double.isNaN(correlation));}
0bdf6065929124a0db1886b4d30dd9f1d34fa1aba3f37bcddd516ea02c8b0112
testNoCorrelation3
public void testNoCorrelation3() throws Exception
{    DataModel dataModel = getDataModel(new long[] { 1, 2 }, new Double[][] { { 90.0, 80.0, 70.0 }, { 70.0, 80.0, 90.0 } });    double correlation = new EuclideanDistanceSimilarity(dataModel).userSimilarity(1, 2);    assertCorrelationEquals(0.05770363219029305, correlation);}
7e6ef9a15f502c76aa39b9e99c40c2704757556d14668cef0634754950c971d9
testSimple
public void testSimple() throws Exception
{    DataModel dataModel = getDataModel(new long[] { 1, 2 }, new Double[][] { { 1.0, 2.0, 3.0 }, { 2.0, 5.0, 6.0 } });    double correlation = new EuclideanDistanceSimilarity(dataModel).userSimilarity(1, 2);    assertCorrelationEquals(0.2843646522044218, correlation);}
224a555ed3946da21a947c3a88adeb442bd4dc06a1e7bb5921589d4b063ffb09
testSimpleWeighted
public void testSimpleWeighted() throws Exception
{    DataModel dataModel = getDataModel(new long[] { 1, 2 }, new Double[][] { { 1.0, 2.0, 3.0 }, { 2.0, 5.0, 6.0 } });    double correlation = new EuclideanDistanceSimilarity(dataModel, Weighting.WEIGHTED).userSimilarity(1, 2);    assertCorrelationEquals(0.8210911630511055, correlation);}
f26bbb6f7fc8280ee30f39a455b974eeb9244e659288ca811cff17d44a55a352
testFullItemCorrelation1
public void testFullItemCorrelation1() throws Exception
{    DataModel dataModel = getDataModel(new long[] { 1, 2 }, new Double[][] { { 3.0, 3.0 }, { -2.0, -2.0 } });    double correlation = new EuclideanDistanceSimilarity(dataModel).itemSimilarity(0, 1);    assertCorrelationEquals(1.0, correlation);}
7d65e11ccc9623c24819a778da4daef8645b755d1928df10c1a06f2ffea2b149
testFullItemCorrelation2
public void testFullItemCorrelation2() throws Exception
{    DataModel dataModel = getDataModel(new long[] { 1, 2 }, new Double[][] { { 3.0, 3.0 }, { 3.0, 3.0 } });    double correlation = new EuclideanDistanceSimilarity(dataModel).itemSimilarity(0, 1);    assertEquals(1.0, correlation, EPSILON);}
b6f4491b6b27ed2e639b27c2605390a8e43a6df371e430cc145fbf63c2430b4f
testNoItemCorrelation1
public void testNoItemCorrelation1() throws Exception
{    DataModel dataModel = getDataModel(new long[] { 1, 2 }, new Double[][] { { 3.0, -3.0 }, { -2.0, 2.0 } });    double correlation = new EuclideanDistanceSimilarity(dataModel).itemSimilarity(0, 1);    assertCorrelationEquals(0.1639607805437114, correlation);}
2d2098ef4d1f2f4fa3897ba8e0e979eea00a3282386b4c897bec588b0de21aec
testNoItemCorrelation2
public void testNoItemCorrelation2() throws Exception
{    DataModel dataModel = getDataModel(new long[] { 1, 2 }, new Double[][] { { null, 1.0, null }, { null, null, 1.0 } });    double correlation = new EuclideanDistanceSimilarity(dataModel).itemSimilarity(1, 2);    assertTrue(Double.isNaN(correlation));}
aa3f0ccea1e73ff479f15a95d5b12c2a2d51102323f6bf3b52a39ae80a5dceab
testNoItemCorrelation3
public void testNoItemCorrelation3() throws Exception
{    DataModel dataModel = getDataModel(new long[] { 1, 2, 3 }, new Double[][] { { 90.0, 70.0 }, { 80.0, 80.0 }, { 70.0, 90.0 } });    double correlation = new EuclideanDistanceSimilarity(dataModel).itemSimilarity(0, 1);    assertCorrelationEquals(0.05770363219029305, correlation);}
674b844753b79264eb9bfdeabcd3a000110d79d8180c12b5a5d3fe03e4dad6b6
testSimpleItem
public void testSimpleItem() throws Exception
{    DataModel dataModel = getDataModel(new long[] { 1, 2, 3 }, new Double[][] { { 1.0, 2.0 }, { 2.0, 5.0 }, { 3.0, 6.0 } });    double correlation = new EuclideanDistanceSimilarity(dataModel).itemSimilarity(0, 1);    assertCorrelationEquals(0.2843646522044218, correlation);}
7eb04cb7806861bd77e5c67794def2498185eb50a1c5f54fffa400d7f7f6cc73
testSimpleItemWeighted
public void testSimpleItemWeighted() throws Exception
{    DataModel dataModel = getDataModel(new long[] { 1, 2, 3 }, new Double[][] { { 1.0, 2.0 }, { 2.0, 5.0 }, { 3.0, 6.0 } });    ItemSimilarity itemSimilarity = new EuclideanDistanceSimilarity(dataModel, Weighting.WEIGHTED);    double correlation = itemSimilarity.itemSimilarity(0, 1);    assertCorrelationEquals(0.8210911630511055, correlation);}
7cca15cf11cc7d8383740a80fe071c452c9d03830040540043d5112d4d719ccc
testRefresh
public void testRefresh() throws TasteException
{        new EuclideanDistanceSimilarity(getDataModel()).refresh(null);}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    super.setUp();    testFile = getTestTempFile("test.txt");    writeLines(testFile, data);}
8550302c341de6296d8cd43f8e8a802f245d022778b37dbba991149a13e2592d
testLoadFromFile
public void testLoadFromFile() throws Exception
{    ItemSimilarity similarity = new FileItemSimilarity(testFile);    assertEquals(0.125, similarity.itemSimilarity(1L, 5L), EPSILON);    assertEquals(0.125, similarity.itemSimilarity(5L, 1L), EPSILON);    assertEquals(0.5, similarity.itemSimilarity(1L, 7L), EPSILON);    assertEquals(0.5, similarity.itemSimilarity(7L, 1L), EPSILON);    assertTrue(Double.isNaN(similarity.itemSimilarity(7L, 8L)));    double[] valuesForOne = similarity.itemSimilarities(1L, new long[] { 5L, 7L });    assertNotNull(valuesForOne);    assertEquals(2, valuesForOne.length);    assertEquals(0.125, valuesForOne[0], EPSILON);    assertEquals(0.5, valuesForOne[1], EPSILON);}
8d3d795a709f62db7628763a160dbe84994730c74de5276d1ffeea162df04548
testNoRefreshAfterFileUpdate
public void testNoRefreshAfterFileUpdate() throws Exception
{    ItemSimilarity similarity = new FileItemSimilarity(testFile, 0L);    /* call a method to make sure the original file is loaded*/    similarity.itemSimilarity(1L, 5L);    /* change the underlying file,     * we have to wait at least a second to see the change in the file's lastModified timestamp */    Thread.sleep(2000L);    writeLines(testFile, changedData);    /* we shouldn't see any changes in the data as we have not yet refreshed */    assertEquals(0.5, similarity.itemSimilarity(1L, 7L), EPSILON);    assertEquals(0.5, similarity.itemSimilarity(7L, 1L), EPSILON);    assertTrue(Double.isNaN(similarity.itemSimilarity(7L, 8L)));}
4aa7c6c51074f5f190a2e45e22dbe0bc2d5413680c28f765525223dedcad3094
testRefreshAfterFileUpdate
public void testRefreshAfterFileUpdate() throws Exception
{    ItemSimilarity similarity = new FileItemSimilarity(testFile, 0L);    /* call a method to make sure the original file is loaded */    similarity.itemSimilarity(1L, 5L);    /* change the underlying file,     * we have to wait at least a second to see the change in the file's lastModified timestamp */    Thread.sleep(2000L);    writeLines(testFile, changedData);    similarity.refresh(null);    /* we should now see the changes in the data */    assertEquals(0.9, similarity.itemSimilarity(1L, 7L), EPSILON);    assertEquals(0.9, similarity.itemSimilarity(7L, 1L), EPSILON);    assertEquals(0.125, similarity.itemSimilarity(1L, 5L), EPSILON);    assertEquals(0.125, similarity.itemSimilarity(5L, 1L), EPSILON);    assertFalse(Double.isNaN(similarity.itemSimilarity(7L, 8L)));    assertEquals(0.112, similarity.itemSimilarity(7L, 8L), EPSILON);    assertEquals(0.112, similarity.itemSimilarity(8L, 7L), EPSILON);}
fbb2717f19848bbb41e8e09ab3a12c7ec0793577b1ca8063498a825d899e0f48
testFileNotFoundExceptionForNonExistingFile
public void testFileNotFoundExceptionForNonExistingFile() throws Exception
{    new FileItemSimilarity(new File("xKsdfksdfsdf"));}
11b90446c1a50490807f393697feb5ef13d73067b1d9a1c889d2a8504b22da6d
testFileItemItemSimilarityIterable
public void testFileItemItemSimilarityIterable() throws Exception
{    Iterable<ItemItemSimilarity> similarityIterable = new FileItemItemSimilarityIterable(testFile);    GenericItemSimilarity similarity = new GenericItemSimilarity(similarityIterable);    assertEquals(0.125, similarity.itemSimilarity(1L, 5L), EPSILON);    assertEquals(0.125, similarity.itemSimilarity(5L, 1L), EPSILON);    assertEquals(0.5, similarity.itemSimilarity(1L, 7L), EPSILON);    assertEquals(0.5, similarity.itemSimilarity(7L, 1L), EPSILON);    assertTrue(Double.isNaN(similarity.itemSimilarity(7L, 8L)));    double[] valuesForOne = similarity.itemSimilarities(1L, new long[] { 5L, 7L });    assertNotNull(valuesForOne);    assertEquals(2, valuesForOne.length);    assertEquals(0.125, valuesForOne[0], EPSILON);    assertEquals(0.5, valuesForOne[1], EPSILON);}
9ce29bebb95bf3e8b03294543675e5033c98b9b179a1f35a5c439716fe21fcf5
testToString
public void testToString() throws Exception
{    ItemSimilarity similarity = new FileItemSimilarity(testFile);    assertTrue(!similarity.toString().isEmpty());}
55a7f99ea12a874ee6b4e42c2e184f3b174a1b226664a015fd13d18771b5f34d
testSimple
public void testSimple()
{    List<GenericItemSimilarity.ItemItemSimilarity> similarities = Lists.newArrayList();    similarities.add(new GenericItemSimilarity.ItemItemSimilarity(1, 2, 0.5));    similarities.add(new GenericItemSimilarity.ItemItemSimilarity(2, 1, 0.6));    similarities.add(new GenericItemSimilarity.ItemItemSimilarity(1, 1, 0.5));    similarities.add(new GenericItemSimilarity.ItemItemSimilarity(1, 3, 0.3));    GenericItemSimilarity itemCorrelation = new GenericItemSimilarity(similarities);    assertEquals(1.0, itemCorrelation.itemSimilarity(1, 1), EPSILON);    assertEquals(0.6, itemCorrelation.itemSimilarity(1, 2), EPSILON);    assertEquals(0.6, itemCorrelation.itemSimilarity(2, 1), EPSILON);    assertEquals(0.3, itemCorrelation.itemSimilarity(1, 3), EPSILON);    assertTrue(Double.isNaN(itemCorrelation.itemSimilarity(3, 4)));}
7a8a64f17a76248dac81153c3fdda078bc0e4d8638530f31b3c5198ff675323e
testFromCorrelation
public void testFromCorrelation() throws Exception
{    DataModel dataModel = getDataModel(new long[] { 1, 2, 3 }, new Double[][] { { 1.0, 2.0 }, { 2.0, 5.0 }, { 3.0, 6.0 } });    ItemSimilarity otherSimilarity = new PearsonCorrelationSimilarity(dataModel);    ItemSimilarity itemSimilarity = new GenericItemSimilarity(otherSimilarity, dataModel);    assertCorrelationEquals(1.0, itemSimilarity.itemSimilarity(0, 0));    assertCorrelationEquals(0.960768922830523, itemSimilarity.itemSimilarity(0, 1));}
e4562c2151031f91b66e401dc2193801298b20a727520034d0ade1c607059f9f
testAllSimilaritiesWithoutIndex
public void testAllSimilaritiesWithoutIndex() throws TasteException
{    List<GenericItemSimilarity.ItemItemSimilarity> itemItemSimilarities = Arrays.asList(new GenericItemSimilarity.ItemItemSimilarity(1L, 2L, 0.2), new GenericItemSimilarity.ItemItemSimilarity(1L, 3L, 0.2), new GenericItemSimilarity.ItemItemSimilarity(2L, 1L, 0.2), new GenericItemSimilarity.ItemItemSimilarity(3L, 5L, 0.2), new GenericItemSimilarity.ItemItemSimilarity(3L, 4L, 0.2));    ItemSimilarity similarity = new GenericItemSimilarity(itemItemSimilarities);    assertTrue(containsExactly(similarity.allSimilarItemIDs(1L), 2L, 3L));    assertTrue(containsExactly(similarity.allSimilarItemIDs(2L), 1L));    assertTrue(containsExactly(similarity.allSimilarItemIDs(3L), 1L, 5L, 4L));    assertTrue(containsExactly(similarity.allSimilarItemIDs(4L), 3L));    assertTrue(containsExactly(similarity.allSimilarItemIDs(5L), 3L));}
4480d42f76965411bc61eb3138cff581c29bce5ee95e383152ade9e75b40a735
testAllSimilaritiesWithIndex
public void testAllSimilaritiesWithIndex() throws TasteException
{    List<GenericItemSimilarity.ItemItemSimilarity> itemItemSimilarities = Arrays.asList(new GenericItemSimilarity.ItemItemSimilarity(1L, 2L, 0.2), new GenericItemSimilarity.ItemItemSimilarity(1L, 3L, 0.2), new GenericItemSimilarity.ItemItemSimilarity(2L, 1L, 0.2), new GenericItemSimilarity.ItemItemSimilarity(3L, 5L, 0.2), new GenericItemSimilarity.ItemItemSimilarity(3L, 4L, 0.2));    ItemSimilarity similarity = new GenericItemSimilarity(itemItemSimilarities);    assertTrue(containsExactly(similarity.allSimilarItemIDs(1L), 2L, 3L));    assertTrue(containsExactly(similarity.allSimilarItemIDs(2L), 1L));    assertTrue(containsExactly(similarity.allSimilarItemIDs(3L), 1L, 5L, 4L));    assertTrue(containsExactly(similarity.allSimilarItemIDs(4L), 3L));    assertTrue(containsExactly(similarity.allSimilarItemIDs(5L), 3L));}
513cbe1e8948e2ff74706f8b2a52c31d2eb5d4d260911b6af114460de9c1198b
containsExactly
private static boolean containsExactly(long[] allIDs, long... shouldContainID)
{    return new FastIDSet(allIDs).intersectionSize(new FastIDSet(shouldContainID)) == shouldContainID.length;}
1c054e1bc539b4740528a3c9c55ef09d28fd4f8a8f40f871ed1508974137c0f7
testCorrelation
public void testCorrelation() throws Exception
{    DataModel dataModel = getDataModel(new long[] { 1, 2, 3, 4, 5 }, new Double[][] { { 1.0, 1.0 }, { 1.0, null, 1.0 }, { null, null, 1.0, 1.0, 1.0 }, { 1.0, 1.0, 1.0, 1.0, 1.0 }, { null, 1.0, 1.0, 1.0, 1.0 } });    LogLikelihoodSimilarity similarity = new LogLikelihoodSimilarity(dataModel);    assertCorrelationEquals(0.12160727029227925, similarity.itemSimilarity(1, 0));    assertCorrelationEquals(0.12160727029227925, similarity.itemSimilarity(0, 1));    assertCorrelationEquals(0.5423213660693732, similarity.itemSimilarity(1, 2));    assertCorrelationEquals(0.5423213660693732, similarity.itemSimilarity(2, 1));    assertCorrelationEquals(0.6905400104897509, similarity.itemSimilarity(2, 3));    assertCorrelationEquals(0.6905400104897509, similarity.itemSimilarity(3, 2));    assertCorrelationEquals(0.8706358464330881, similarity.itemSimilarity(3, 4));    assertCorrelationEquals(0.8706358464330881, similarity.itemSimilarity(4, 3));}
26a03a826b22fecb2662854e68965fefda44c4bcac39f7ea746d8b7250df87d9
testNoSimilarity
public void testNoSimilarity() throws Exception
{    DataModel dataModel = getDataModel(new long[] { 1, 2, 3, 4 }, new Double[][] { { 1.0, null, 1.0, 1.0 }, { 1.0, null, 1.0, 1.0 }, { null, 1.0, 1.0, 1.0 }, { null, 1.0, 1.0, 1.0 } });    LogLikelihoodSimilarity similarity = new LogLikelihoodSimilarity(dataModel);    assertCorrelationEquals(Double.NaN, similarity.itemSimilarity(1, 0));    assertCorrelationEquals(Double.NaN, similarity.itemSimilarity(0, 1));    assertCorrelationEquals(0.0, similarity.itemSimilarity(2, 3));    assertCorrelationEquals(0.0, similarity.itemSimilarity(3, 2));}
6300a0dfd588632d273c0a534e1dd26f4ad77ed3a0aaafabd8b9a78e75d0c8af
testRefresh
public void testRefresh()
{        new LogLikelihoodSimilarity(getDataModel()).refresh(null);}
730b2679f9ca63b9779a2defc484d69e899d92e1f67e9e75a871351b35327c5d
testFullCorrelation1
public void testFullCorrelation1() throws Exception
{    DataModel dataModel = getDataModel(new long[] { 1, 2 }, new Double[][] { { 3.0, -2.0 }, { 3.0, -2.0 } });    double correlation = new PearsonCorrelationSimilarity(dataModel).userSimilarity(1, 2);    assertCorrelationEquals(1.0, correlation);}
56d072401e9a5024ec54f44e399df262a502d59ef8f34c17b888391d467b39e5
testFullCorrelation1Weighted
public void testFullCorrelation1Weighted() throws Exception
{    DataModel dataModel = getDataModel(new long[] { 1, 2 }, new Double[][] { { 3.0, -2.0 }, { 3.0, -2.0 } });    double correlation = new PearsonCorrelationSimilarity(dataModel, Weighting.WEIGHTED).userSimilarity(1, 2);    assertCorrelationEquals(1.0, correlation);}
deee697d64e562be19ba52a93b9ddb1d0176b27524cea541ce49db8e2b2b0a7b
testFullCorrelation2
public void testFullCorrelation2() throws Exception
{    DataModel dataModel = getDataModel(new long[] { 1, 2 }, new Double[][] { { 3.0, 3.0 }, { 3.0, 3.0 } });    double correlation = new PearsonCorrelationSimilarity(dataModel).userSimilarity(1, 2);        assertTrue(Double.isNaN(correlation));}
38e633989a63026efd525a20e9075fae48b69526f22fea4dee605a5dd589eef2
testNoCorrelation1
public void testNoCorrelation1() throws Exception
{    DataModel dataModel = getDataModel(new long[] { 1, 2 }, new Double[][] { { 3.0, -2.0 }, { -3.0, 2.0 } });    double correlation = new PearsonCorrelationSimilarity(dataModel).userSimilarity(1, 2);    assertCorrelationEquals(-1.0, correlation);}
2b2c2b6291f7af86bc1c35466d274e629970efbf727408a19bb0ad3aa411c253
testNoCorrelation1Weighted
public void testNoCorrelation1Weighted() throws Exception
{    DataModel dataModel = getDataModel(new long[] { 1, 2 }, new Double[][] { { 3.0, -2.0 }, { -3.0, 2.0 } });    double correlation = new PearsonCorrelationSimilarity(dataModel, Weighting.WEIGHTED).userSimilarity(1, 2);    assertCorrelationEquals(-1.0, correlation);}
165bd850ae0d736fd009ec55764e777b1d4675495e67382605fb30ffe4f7d56a
testNoCorrelation2
public void testNoCorrelation2() throws Exception
{    DataModel dataModel = getDataModel(new long[] { 1, 2 }, new Double[][] { { null, 1.0, null }, { null, null, 1.0 } });    double correlation = new PearsonCorrelationSimilarity(dataModel).userSimilarity(1, 2);    assertTrue(Double.isNaN(correlation));}
0bdf6065929124a0db1886b4d30dd9f1d34fa1aba3f37bcddd516ea02c8b0112
testNoCorrelation3
public void testNoCorrelation3() throws Exception
{    DataModel dataModel = getDataModel(new long[] { 1, 2 }, new Double[][] { { 90.0, 80.0, 70.0 }, { 70.0, 80.0, 90.0 } });    double correlation = new PearsonCorrelationSimilarity(dataModel).userSimilarity(1, 2);    assertCorrelationEquals(-1.0, correlation);}
7e6ef9a15f502c76aa39b9e99c40c2704757556d14668cef0634754950c971d9
testSimple
public void testSimple() throws Exception
{    DataModel dataModel = getDataModel(new long[] { 1, 2 }, new Double[][] { { 1.0, 2.0, 3.0 }, { 2.0, 5.0, 6.0 } });    double correlation = new PearsonCorrelationSimilarity(dataModel).userSimilarity(1, 2);    assertCorrelationEquals(0.9607689228305227, correlation);}
224a555ed3946da21a947c3a88adeb442bd4dc06a1e7bb5921589d4b063ffb09
testSimpleWeighted
public void testSimpleWeighted() throws Exception
{    DataModel dataModel = getDataModel(new long[] { 1, 2 }, new Double[][] { { 1.0, 2.0, 3.0 }, { 2.0, 5.0, 6.0 } });    double correlation = new PearsonCorrelationSimilarity(dataModel, Weighting.WEIGHTED).userSimilarity(1, 2);    assertCorrelationEquals(0.9901922307076306, correlation);}
f26bbb6f7fc8280ee30f39a455b974eeb9244e659288ca811cff17d44a55a352
testFullItemCorrelation1
public void testFullItemCorrelation1() throws Exception
{    DataModel dataModel = getDataModel(new long[] { 1, 2 }, new Double[][] { { 3.0, 3.0 }, { -2.0, -2.0 } });    double correlation = new PearsonCorrelationSimilarity(dataModel).itemSimilarity(0, 1);    assertCorrelationEquals(1.0, correlation);}
7d65e11ccc9623c24819a778da4daef8645b755d1928df10c1a06f2ffea2b149
testFullItemCorrelation2
public void testFullItemCorrelation2() throws Exception
{    DataModel dataModel = getDataModel(new long[] { 1, 2 }, new Double[][] { { 3.0, 3.0 }, { 3.0, 3.0 } });    double correlation = new PearsonCorrelationSimilarity(dataModel).itemSimilarity(0, 1);        assertTrue(Double.isNaN(correlation));}
b6f4491b6b27ed2e639b27c2605390a8e43a6df371e430cc145fbf63c2430b4f
testNoItemCorrelation1
public void testNoItemCorrelation1() throws Exception
{    DataModel dataModel = getDataModel(new long[] { 1, 2 }, new Double[][] { { 3.0, -3.0 }, { 2.0, -2.0 } });    double correlation = new PearsonCorrelationSimilarity(dataModel).itemSimilarity(0, 1);    assertCorrelationEquals(-1.0, correlation);}
2d2098ef4d1f2f4fa3897ba8e0e979eea00a3282386b4c897bec588b0de21aec
testNoItemCorrelation2
public void testNoItemCorrelation2() throws Exception
{    DataModel dataModel = getDataModel(new long[] { 1, 2 }, new Double[][] { { null, 1.0, null }, { null, null, 1.0 } });    double correlation = new PearsonCorrelationSimilarity(dataModel).itemSimilarity(1, 2);    assertTrue(Double.isNaN(correlation));}
aa3f0ccea1e73ff479f15a95d5b12c2a2d51102323f6bf3b52a39ae80a5dceab
testNoItemCorrelation3
public void testNoItemCorrelation3() throws Exception
{    DataModel dataModel = getDataModel(new long[] { 1, 2, 3 }, new Double[][] { { 90.0, 70.0 }, { 80.0, 80.0 }, { 70.0, 90.0 } });    double correlation = new PearsonCorrelationSimilarity(dataModel).itemSimilarity(0, 1);    assertCorrelationEquals(-1.0, correlation);}
674b844753b79264eb9bfdeabcd3a000110d79d8180c12b5a5d3fe03e4dad6b6
testSimpleItem
public void testSimpleItem() throws Exception
{    DataModel dataModel = getDataModel(new long[] { 1, 2, 3 }, new Double[][] { { 1.0, 2.0 }, { 2.0, 5.0 }, { 3.0, 6.0 } });    double correlation = new PearsonCorrelationSimilarity(dataModel).itemSimilarity(0, 1);    assertCorrelationEquals(0.9607689228305227, correlation);}
7eb04cb7806861bd77e5c67794def2498185eb50a1c5f54fffa400d7f7f6cc73
testSimpleItemWeighted
public void testSimpleItemWeighted() throws Exception
{    DataModel dataModel = getDataModel(new long[] { 1, 2, 3 }, new Double[][] { { 1.0, 2.0 }, { 2.0, 5.0 }, { 3.0, 6.0 } });    ItemSimilarity itemSimilarity = new PearsonCorrelationSimilarity(dataModel, Weighting.WEIGHTED);    double correlation = itemSimilarity.itemSimilarity(0, 1);    assertCorrelationEquals(0.9901922307076306, correlation);}
2025195ee587b144107874b35d504e98dbc762cefc47d85ea96833a73244c4c1
testRefresh
public void testRefresh() throws Exception
{        new PearsonCorrelationSimilarity(getDataModel()).refresh(null);}
a93e92c4c60a030531f993e4667d4273ed1ad49798d535fce2712ef057aafdd4
testInferrer
public void testInferrer() throws Exception
{    DataModel dataModel = getDataModel(new long[] { 1, 2 }, new Double[][] { { null, 1.0, 2.0, null, null, 6.0 }, { 1.0, 8.0, null, 3.0, 4.0, null } });    UserSimilarity similarity = new PearsonCorrelationSimilarity(dataModel);    similarity.setPreferenceInferrer(new PreferenceInferrer() {        @Override        public float inferPreference(long userID, long itemID) {            return 1.0f;        }        @Override        public void refresh(Collection<Refreshable> alreadyRefreshed) {        }    });    assertEquals(-0.435285750066007, similarity.userSimilarity(1L, 2L), EPSILON);}
104df676cfc6085fa6a9c50927e7a24e7c797df63a680d1434234931f87b068c
inferPreference
public float inferPreference(long userID, long itemID)
{    return 1.0f;}
da77e35d28c590f4b271e5b2b7f639c465574b8f17a1ef2f1df63e0152c57e8b
refresh
public void refresh(Collection<Refreshable> alreadyRefreshed)
{}
f327a2b21c63d879f59716342af313f54ccdf3e52bc330f8f5364af090bc117d
lessItemsThanBatchSize
public void lessItemsThanBatchSize() throws Exception
{    FastByIDMap<PreferenceArray> userData = new FastByIDMap<>();    userData.put(1, new GenericUserPreferenceArray(Arrays.asList(new GenericPreference(1, 1, 1), new GenericPreference(1, 2, 1), new GenericPreference(1, 3, 1))));    userData.put(2, new GenericUserPreferenceArray(Arrays.asList(new GenericPreference(2, 1, 1), new GenericPreference(2, 2, 1), new GenericPreference(2, 4, 1))));    DataModel dataModel = new GenericDataModel(userData);    ItemBasedRecommender recommender = new GenericItemBasedRecommender(dataModel, new TanimotoCoefficientSimilarity(dataModel));    BatchItemSimilarities batchSimilarities = new MultithreadedBatchItemSimilarities(recommender, 10);    batchSimilarities.computeItemSimilarities(1, 1, mock(SimilarItemsWriter.class));}
0b5042cf3dd7b2f29e65f99a4bc032486489e57321209717777d8017d26e0b00
higherDegreeOfParallelismThanBatches
public void higherDegreeOfParallelismThanBatches() throws Exception
{    FastByIDMap<PreferenceArray> userData = new FastByIDMap<>();    userData.put(1, new GenericUserPreferenceArray(Arrays.asList(new GenericPreference(1, 1, 1), new GenericPreference(1, 2, 1), new GenericPreference(1, 3, 1))));    userData.put(2, new GenericUserPreferenceArray(Arrays.asList(new GenericPreference(2, 1, 1), new GenericPreference(2, 2, 1), new GenericPreference(2, 4, 1))));    DataModel dataModel = new GenericDataModel(userData);    ItemBasedRecommender recommender = new GenericItemBasedRecommender(dataModel, new TanimotoCoefficientSimilarity(dataModel));    BatchItemSimilarities batchSimilarities = new MultithreadedBatchItemSimilarities(recommender, 10);        batchSimilarities.computeItemSimilarities(2, 1, mock(SimilarItemsWriter.class));    fail();}
7651fbef537739bf17487ca64a3e60d787bf5d7462c784d1b0576ca1be4301e8
testCorrectNumberOfOutputSimilarities
public void testCorrectNumberOfOutputSimilarities() throws Exception
{    FastByIDMap<PreferenceArray> userData = new FastByIDMap<>();    userData.put(1, new GenericUserPreferenceArray(Arrays.asList(new GenericPreference(1, 1, 1), new GenericPreference(1, 2, 1), new GenericPreference(1, 3, 1))));    userData.put(2, new GenericUserPreferenceArray(Arrays.asList(new GenericPreference(2, 1, 1), new GenericPreference(2, 2, 1), new GenericPreference(2, 4, 1))));    DataModel dataModel = new GenericDataModel(userData);    ItemBasedRecommender recommender = new GenericItemBasedRecommender(dataModel, new TanimotoCoefficientSimilarity(dataModel));    BatchItemSimilarities batchSimilarities = new MultithreadedBatchItemSimilarities(recommender, 10, 2);    int numOutputSimilarities = batchSimilarities.computeItemSimilarities(2, 1, mock(SimilarItemsWriter.class));    assertEquals(numOutputSimilarities, 10);}
6844595133cdec732df17c7aaaf09e53247a8545a7e49932e1c0c1b89dd46f56
assertCorrelationEquals
 static void assertCorrelationEquals(double expected, double actual)
{    if (Double.isNaN(expected)) {        assertTrue("Correlation is not NaN", Double.isNaN(actual));    } else {        assertTrue("Correlation is NaN", !Double.isNaN(actual));        assertTrue("Correlation > 1.0", actual <= 1.0);        assertTrue("Correlation < -1.0", actual >= -1.0);        assertEquals(expected, actual, EPSILON);    }}
730b2679f9ca63b9779a2defc484d69e899d92e1f67e9e75a871351b35327c5d
testFullCorrelation1
public void testFullCorrelation1() throws Exception
{    DataModel dataModel = getDataModel(new long[] { 1, 2 }, new Double[][] { { 1.0, 2.0, 3.0 }, { 1.0, 2.0, 3.0 } });    double correlation = new SpearmanCorrelationSimilarity(dataModel).userSimilarity(1, 2);    assertCorrelationEquals(1.0, correlation);}
deee697d64e562be19ba52a93b9ddb1d0176b27524cea541ce49db8e2b2b0a7b
testFullCorrelation2
public void testFullCorrelation2() throws Exception
{    DataModel dataModel = getDataModel(new long[] { 1, 2 }, new Double[][] { { 1.0, 2.0, 3.0 }, { 4.0, 5.0, 6.0 } });    double correlation = new SpearmanCorrelationSimilarity(dataModel).userSimilarity(1, 2);    assertCorrelationEquals(1.0, correlation);}
2f14cd7d20158ea4a6558f5c0199d10860b3910e9e95c2a6a381681eec719a35
testAnticorrelation
public void testAnticorrelation() throws Exception
{    DataModel dataModel = getDataModel(new long[] { 1, 2 }, new Double[][] { { 1.0, 2.0, 3.0 }, { 3.0, 2.0, 1.0 } });    double correlation = new SpearmanCorrelationSimilarity(dataModel).userSimilarity(1, 2);    assertCorrelationEquals(-1.0, correlation);}
7e6ef9a15f502c76aa39b9e99c40c2704757556d14668cef0634754950c971d9
testSimple
public void testSimple() throws Exception
{    DataModel dataModel = getDataModel(new long[] { 1, 2 }, new Double[][] { { 1.0, 2.0, 3.0 }, { 2.0, 3.0, 1.0 } });    double correlation = new SpearmanCorrelationSimilarity(dataModel).userSimilarity(1, 2);    assertCorrelationEquals(-0.5, correlation);}
6300a0dfd588632d273c0a534e1dd26f4ad77ed3a0aaafabd8b9a78e75d0c8af
testRefresh
public void testRefresh()
{        new SpearmanCorrelationSimilarity(getDataModel()).refresh(null);}
49c70b60534f1d9afcb812db43ec176aa5876fcf142f5e840a873eb06e70b790
testNoCorrelation
public void testNoCorrelation() throws Exception
{    DataModel dataModel = getDataModel(new long[] { 1, 2 }, new Double[][] { { null, 2.0, 3.0 }, { 1.0 } });    double correlation = new TanimotoCoefficientSimilarity(dataModel).userSimilarity(1, 2);    assertCorrelationEquals(Double.NaN, correlation);}
730b2679f9ca63b9779a2defc484d69e899d92e1f67e9e75a871351b35327c5d
testFullCorrelation1
public void testFullCorrelation1() throws Exception
{    DataModel dataModel = getDataModel(new long[] { 1, 2 }, new Double[][] { { 1.0 }, { 1.0 } });    double correlation = new TanimotoCoefficientSimilarity(dataModel).userSimilarity(1, 2);    assertCorrelationEquals(1.0, correlation);}
deee697d64e562be19ba52a93b9ddb1d0176b27524cea541ce49db8e2b2b0a7b
testFullCorrelation2
public void testFullCorrelation2() throws Exception
{    DataModel dataModel = getDataModel(new long[] { 1, 2 }, new Double[][] { { 1.0, 2.0, 3.0 }, { 1.0 } });    double correlation = new TanimotoCoefficientSimilarity(dataModel).userSimilarity(1, 2);    assertCorrelationEquals(0.3333333333333333, correlation);}
5e147d7afca25a251fb6cb94df58b0e2c435cfe7820ef91b82400c1bb6f4401d
testCorrelation1
public void testCorrelation1() throws Exception
{    DataModel dataModel = getDataModel(new long[] { 1, 2 }, new Double[][] { { null, 2.0, 3.0 }, { 1.0, 1.0 } });    double correlation = new TanimotoCoefficientSimilarity(dataModel).userSimilarity(1, 2);    assertEquals(0.3333333333333333, correlation, EPSILON);}
290cca69f2daa14d12f9c4035e4003645b4225d26f5014078f1559415940ba5d
testCorrelation2
public void testCorrelation2() throws Exception
{    DataModel dataModel = getDataModel(new long[] { 1, 2 }, new Double[][] { { null, 2.0, 3.0, 1.0 }, { 1.0, 1.0, null, 0.0 } });    double correlation = new TanimotoCoefficientSimilarity(dataModel).userSimilarity(1, 2);    assertEquals(0.5, correlation, EPSILON);}
6300a0dfd588632d273c0a534e1dd26f4ad77ed3a0aaafabd8b9a78e75d0c8af
testRefresh
public void testRefresh()
{        new TanimotoCoefficientSimilarity(getDataModel()).refresh(null);}
dee866cbfe0e7d2e2118a10470fcf7441599a7090ec4e1566c3a476773cba55f
testReturnNaNDoubleWhenNoSimilaritiesForTwoItems
public void testReturnNaNDoubleWhenNoSimilaritiesForTwoItems() throws Exception
{    DataModel dataModel = getDataModel(new long[] { 1, 2 }, new Double[][] { { null, null, 3.0 }, { 1.0, 1.0, null } });    Double similarity = new TanimotoCoefficientSimilarity(dataModel).itemSimilarity(1, 2);    assertEquals(Double.NaN, similarity, EPSILON);}
cff9ba4b687c116f2448448a8cd185c97dff3e1eeca4b5f76a7042f5f2a4e40f
testItemsSimilarities
public void testItemsSimilarities() throws Exception
{    DataModel dataModel = getDataModel(new long[] { 1, 2 }, new Double[][] { { 2.0, null, 2.0 }, { 1.0, 1.0, 1.0 } });    TanimotoCoefficientSimilarity tCS = new TanimotoCoefficientSimilarity(dataModel);    assertEquals(0.5, tCS.itemSimilarity(0, 1), EPSILON);    assertEquals(1, tCS.itemSimilarity(0, 2), EPSILON);    double[] similarities = tCS.itemSimilarities(0, new long[] { 1, 2 });    assertEquals(0.5, similarities[0], EPSILON);    assertEquals(1, similarities[1], EPSILON);}
ee76be2178269b8641905fb6575cfb61528b6608417db4876c90d9699c0a7248
getDataModel
public static DataModel getDataModel(long[] userIDs, Double[][] prefValues)
{    FastByIDMap<PreferenceArray> result = new FastByIDMap<>();    for (int i = 0; i < userIDs.length; i++) {        List<Preference> prefsList = Lists.newArrayList();        for (int j = 0; j < prefValues[i].length; j++) {            if (prefValues[i][j] != null) {                prefsList.add(new GenericPreference(userIDs[i], j, prefValues[i][j].floatValue()));            }        }        if (!prefsList.isEmpty()) {            result.put(userIDs[i], new GenericUserPreferenceArray(prefsList));        }    }    return new GenericDataModel(result);}
5d4381dd224e7f7a7ebb33cd75b5474988605025538a2e90c628632a9da8855b
getBooleanDataModel
public static DataModel getBooleanDataModel(long[] userIDs, boolean[][] prefs)
{    FastByIDMap<FastIDSet> result = new FastByIDMap<>();    for (int i = 0; i < userIDs.length; i++) {        FastIDSet prefsSet = new FastIDSet();        for (int j = 0; j < prefs[i].length; j++) {            if (prefs[i][j]) {                prefsSet.add(j);            }        }        if (!prefsSet.isEmpty()) {            result.put(userIDs[i], prefsSet);        }    }    return new GenericBooleanPrefDataModel(result);}
8be56d413476863badcf771922f536caf8c498cccb6597750221b15a4786d9e6
getDataModel
protected static DataModel getDataModel()
{    return getDataModel(new long[] { 1, 2, 3, 4 }, new Double[][] { { 0.1, 0.3 }, { 0.2, 0.3, 0.3 }, { 0.4, 0.3, 0.5 }, { 0.7, 0.3, 0.8 } });}
44bfe1090af31b326d5c04c20dd21bb18ec1c1db5c69ea650eebcac08e85c085
getBooleanDataModel
protected static DataModel getBooleanDataModel()
{    return getBooleanDataModel(new long[] { 1, 2, 3, 4 }, new boolean[][] { { false, true, false }, { false, true, true, false }, { true, false, false, true }, { true, false, true, true } });}
d8cd11d1be5a65cd003a7941991ac2c87c11ad601b09e93ed07ba4882bb14c25
arrayContains
protected static boolean arrayContains(long[] array, long value)
{    for (long l : array) {        if (l == value) {            return true;        }    }    return false;}
67da42917796fb34c2430d36639acd5bccfa9735379b7ead28fbb27a007e4b32
testIterator
public void testIterator()
{    List<RecommendedItem> recommendedItems = new ArrayList<>();    for (long itemId = 2; itemId < 10; itemId++) {        recommendedItems.add(new GenericRecommendedItem(itemId, itemId));    }    SimilarItems similarItems = new SimilarItems(1, recommendedItems);    assertThat(similarItems.getSimilarItems(), Matchers.<SimilarItem>iterableWithSize(recommendedItems.size()));    int byHandIndex = 0;    for (SimilarItem simItem : similarItems.getSimilarItems()) {        RecommendedItem recItem = recommendedItems.get(byHandIndex++);        assertEquals(simItem.getItemID(), recItem.getItemID());        assertEquals(simItem.getSimilarity(), recItem.getValue(), EPSILON);    }}
4bced1bc9ea8c4e7619cc71e0839bd449934eb20d9832c037211976e39689630
testBuild
public void testBuild()
{    ConfusionMatrix confusionMatrix = fillConfusionMatrix(VALUES, LABELS, DEFAULT_LABEL);    checkValues(confusionMatrix);    checkAccuracy(confusionMatrix);}
8715f7a114fb526c6f730d478182cfabc27823a1ca7e9816402fc03e01b1371a
testGetMatrix
public void testGetMatrix()
{    ConfusionMatrix confusionMatrix = fillConfusionMatrix(VALUES, LABELS, DEFAULT_LABEL);    Matrix m = confusionMatrix.getMatrix();    Map<String, Integer> rowLabels = m.getRowLabelBindings();    assertEquals(confusionMatrix.getLabels().size(), m.numCols());    assertTrue(rowLabels.keySet().contains(LABELS[0]));    assertTrue(rowLabels.keySet().contains(LABELS[1]));    assertTrue(rowLabels.keySet().contains(DEFAULT_LABEL));    assertEquals(2, confusionMatrix.getCorrect(LABELS[0]));    assertEquals(20, confusionMatrix.getCorrect(LABELS[1]));    assertEquals(0, confusionMatrix.getCorrect(DEFAULT_LABEL));}
9ec214b9881dac6a728d509a4a645a740e1e3047c40c4c91d14848890b8eb07d
testPrecisionRecallAndF1ScoreAsScikitLearn
public void testPrecisionRecallAndF1ScoreAsScikitLearn()
{    Collection<String> labelList = Arrays.asList("0", "1", "2");    ConfusionMatrix confusionMatrix = new ConfusionMatrix(labelList, "DEFAULT");    confusionMatrix.putCount("0", "0", 2);    confusionMatrix.putCount("1", "0", 1);    confusionMatrix.putCount("1", "2", 1);    confusionMatrix.putCount("2", "1", 2);    double delta = 0.001;    assertEquals(0.222, confusionMatrix.getWeightedPrecision(), delta);    assertEquals(0.333, confusionMatrix.getWeightedRecall(), delta);    assertEquals(0.266, confusionMatrix.getWeightedF1score(), delta);}
2d258283a687e4ff834a64e2422bbbadd347fb5b3a4750ddd117a1d1b2589042
checkValues
private static void checkValues(ConfusionMatrix cm)
{    int[][] counts = cm.getConfusionMatrix();    cm.toString();    assertEquals(counts.length, counts[0].length);    assertEquals(3, counts.length);    assertEquals(VALUES[0][0], counts[0][0]);    assertEquals(VALUES[0][1], counts[0][1]);    assertEquals(VALUES[1][0], counts[1][0]);    assertEquals(VALUES[1][1], counts[1][1]);        assertTrue(Arrays.equals(new int[3], counts[2]));    assertEquals(OTHER[0], counts[0][2]);    assertEquals(OTHER[1], counts[1][2]);    assertEquals(3, cm.getLabels().size());    assertTrue(cm.getLabels().contains(LABELS[0]));    assertTrue(cm.getLabels().contains(LABELS[1]));    assertTrue(cm.getLabels().contains(DEFAULT_LABEL));}
841c271787e131217a19ad51a1fd2e1aa4b77f0b4107b1afebb6c7160a8b3adb
checkAccuracy
private static void checkAccuracy(ConfusionMatrix cm)
{    Collection<String> labelstrs = cm.getLabels();    assertEquals(3, labelstrs.size());    assertEquals(25.0, cm.getAccuracy("Label1"), EPSILON);    assertEquals(55.5555555, cm.getAccuracy("Label2"), EPSILON);    assertTrue(Double.isNaN(cm.getAccuracy("other")));}
713db7d0bc1e99427fec56c58e3b01e74e5765c3a32ffd83479c36686150981c
fillConfusionMatrix
private static ConfusionMatrix fillConfusionMatrix(int[][] values, String[] labels, String defaultLabel)
{    Collection<String> labelList = Lists.newArrayList();    labelList.add(labels[0]);    labelList.add(labels[1]);    ConfusionMatrix confusionMatrix = new ConfusionMatrix(labelList, defaultLabel);    confusionMatrix.putCount("Label1", "Label1", values[0][0]);    confusionMatrix.putCount("Label1", "Label2", values[0][1]);    confusionMatrix.putCount("Label2", "Label1", values[1][0]);    confusionMatrix.putCount("Label2", "Label2", values[1][1]);    confusionMatrix.putCount("Label1", DEFAULT_LABEL, OTHER[0]);    confusionMatrix.putCount("Label2", DEFAULT_LABEL, OTHER[1]);    return confusionMatrix;}
182f354d3a593ec872f7a856b775355ff5ad21c871009267768f380625e3a853
testRandomAttributes
public void testRandomAttributes() throws Exception
{    Random rng = RandomUtils.getRandom();    int nbAttributes = rng.nextInt(100) + 1;    boolean[] selected = new boolean[nbAttributes];    for (int nloop = 0; nloop < 100; nloop++) {        Arrays.fill(selected, false);                int nbSelected = rng.nextInt(nbAttributes - 1);        for (int index = 0; index < nbSelected; index++) {            int attr;            do {                attr = rng.nextInt(nbAttributes);            } while (selected[attr]);            selected[attr] = true;        }        int m = rng.nextInt(nbAttributes);        Method randomAttributes = DecisionTreeBuilder.class.getDeclaredMethod("randomAttributes", Random.class, boolean[].class, int.class);        randomAttributes.setAccessible(true);        int[] attrs = (int[]) randomAttributes.invoke(null, rng, selected, m);        assertNotNull(attrs);        assertEquals(Math.min(m, nbAttributes - nbSelected), attrs.length);        for (int attr : attrs) {                        assertFalse("an attribute has already been selected", selected[attr]);                        assertTrue(attr >= 0);            assertTrue(attr < nbAttributes);                        assertEquals(ArrayUtils.indexOf(attrs, attr), ArrayUtils.lastIndexOf(attrs, attr));        }    }}
182f354d3a593ec872f7a856b775355ff5ad21c871009267768f380625e3a853
testRandomAttributes
public void testRandomAttributes() throws Exception
{    Random rng = RandomUtils.getRandom();    int nbAttributes = rng.nextInt(100) + 1;    boolean[] selected = new boolean[nbAttributes];    for (int nloop = 0; nloop < 100; nloop++) {        Arrays.fill(selected, false);                int nbSelected = rng.nextInt(nbAttributes - 1);        for (int index = 0; index < nbSelected; index++) {            int attr;            do {                attr = rng.nextInt(nbAttributes);            } while (selected[attr]);            selected[attr] = true;        }        int m = rng.nextInt(nbAttributes);        int[] attrs = DefaultTreeBuilder.randomAttributes(rng, selected, m);        assertNotNull(attrs);        assertEquals(Math.min(m, nbAttributes - nbSelected), attrs.length);        for (int attr : attrs) {                        assertFalse("an attribute has already been selected", selected[attr]);                        assertTrue(attr >= 0);            assertTrue(attr < nbAttributes);                        assertEquals(ArrayUtils.indexOf(attrs, attr), ArrayUtils.lastIndexOf(attrs, attr));        }    }}
6854c8696aacea15c0b36498fc1f6501a7bad0a46f21f4c8108b32bf653bd4e4
testBuild
public void testBuild() throws Exception
{    Random rng = RandomUtils.getRandom();    String[] source = Utils.double2String(dData);    String descriptor = "N N N N N N N N L";    Dataset dataset = DataLoader.generateDataset(descriptor, false, source);    Data data = DataLoader.loadData(dataset, source);    TreeBuilder builder = new DecisionTreeBuilder();    builder.build(rng, data);        dataset = DataLoader.generateDataset(descriptor, true, source);    data = DataLoader.loadData(dataset, source);    builder = new DecisionTreeBuilder();    builder.build(rng, data);}
beab2e234e539530338bb77d414a5bb9fde72a0636efebb35c342d38a766779c
testConvert
public void testConvert() throws Exception
{    Random rng = RandomUtils.getRandom();    String descriptor = Utils.randomDescriptor(rng, ATTRIBUTE_COUNT);    double[][] source = Utils.randomDoubles(rng, descriptor, false, INSTANCE_COUNT);    String[] sData = Utils.double2String(source);    Dataset dataset = DataLoader.generateDataset(descriptor, false, sData);    Data data = DataLoader.loadData(dataset, sData);    DataConverter converter = new DataConverter(dataset);    for (int index = 0; index < data.size(); index++) {        assertEquals(data.get(index), converter.convert(sData[index]));    }        source = Utils.randomDoubles(rng, descriptor, true, INSTANCE_COUNT);    sData = Utils.double2String(source);    dataset = DataLoader.generateDataset(descriptor, true, sData);    data = DataLoader.loadData(dataset, sData);    converter = new DataConverter(dataset);    for (int index = 0; index < data.size(); index++) {        assertEquals(data.get(index), converter.convert(sData[index]));    }}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    super.setUp();    rng = RandomUtils.getRandom();}
9b0520f464485644b1f170a4d6af338762beaf57ae59bead530633569a93d565
testLoadDataWithDescriptor
public void testLoadDataWithDescriptor() throws Exception
{    int nbAttributes = 10;    int datasize = 100;        String descriptor = Utils.randomDescriptor(rng, nbAttributes);    Attribute[] attrs = DescriptorUtils.parseDescriptor(descriptor);        double[][] data = Utils.randomDoubles(rng, descriptor, false, datasize);    Collection<Integer> missings = Lists.newArrayList();    String[] sData = prepareData(data, attrs, missings);    Dataset dataset = DataLoader.generateDataset(descriptor, false, sData);    Data loaded = DataLoader.loadData(dataset, sData);    testLoadedData(data, attrs, missings, loaded);    testLoadedDataset(data, attrs, missings, loaded);        data = Utils.randomDoubles(rng, descriptor, true, datasize);    missings = Lists.newArrayList();    sData = prepareData(data, attrs, missings);    dataset = DataLoader.generateDataset(descriptor, true, sData);    loaded = DataLoader.loadData(dataset, sData);    testLoadedData(data, attrs, missings, loaded);    testLoadedDataset(data, attrs, missings, loaded);}
d72c9fb0c2a9c94dfa7fe02f8a09643f34bd436bcc9183d5c769b0a125dd51f2
testGenerateDataset
public void testGenerateDataset() throws Exception
{    int nbAttributes = 10;    int datasize = 100;        String descriptor = Utils.randomDescriptor(rng, nbAttributes);    Attribute[] attrs = DescriptorUtils.parseDescriptor(descriptor);        double[][] data = Utils.randomDoubles(rng, descriptor, false, datasize);    Collection<Integer> missings = Lists.newArrayList();    String[] sData = prepareData(data, attrs, missings);    Dataset expected = DataLoader.generateDataset(descriptor, false, sData);    Dataset dataset = DataLoader.generateDataset(descriptor, false, sData);    assertEquals(expected, dataset);        data = Utils.randomDoubles(rng, descriptor, true, datasize);    missings = Lists.newArrayList();    sData = prepareData(data, attrs, missings);    expected = DataLoader.generateDataset(descriptor, true, sData);    dataset = DataLoader.generateDataset(descriptor, true, sData);    assertEquals(expected, dataset);}
84a37463ac9675ea218e707ae8a3e8d00f1ef7dc83c6324afaa4dd9b7a80cf12
prepareData
private String[] prepareData(double[][] data, Attribute[] attrs, Collection<Integer> missings)
{    int nbAttributes = attrs.length;    String[] sData = new String[data.length];    for (int index = 0; index < data.length; index++) {        int missingAttr;        if (rng.nextDouble() < 0.0) {                        missings.add(index);                        do {                missingAttr = rng.nextInt(nbAttributes);            } while (attrs[missingAttr].isIgnored());        } else {            missingAttr = -1;        }        StringBuilder builder = new StringBuilder();        for (int attr = 0; attr < nbAttributes; attr++) {            if (attr == missingAttr) {                                builder.append('?').append(',');            } else {                builder.append(data[index][attr]).append(',');            }        }        sData[index] = builder.toString();    }    return sData;}
f2ef56e88e9751671c52e44c325236be0ca3a462f40dedc5773e435e78478aab
testLoadedData
 static void testLoadedData(double[][] data, Attribute[] attrs, Collection<Integer> missings, Data loaded)
{    int nbAttributes = attrs.length;        assertEquals("number of instance", data.length - missings.size(), loaded.size());        int lind = 0;    for (int index = 0; index < data.length; index++) {        if (missings.contains(index)) {            continue;        }                double[] vector = data[index];        Instance instance = loaded.get(lind);        int aId = 0;        for (int attr = 0; attr < nbAttributes; attr++) {            if (attrs[attr].isIgnored()) {                continue;            }            if (attrs[attr].isNumerical()) {                assertEquals(vector[attr], instance.get(aId), EPSILON);                aId++;            } else if (attrs[attr].isCategorical()) {                checkCategorical(data, missings, loaded, attr, aId, vector[attr], instance.get(aId));                aId++;            } else if (attrs[attr].isLabel()) {                if (loaded.getDataset().isNumerical(aId)) {                    assertEquals(vector[attr], instance.get(aId), EPSILON);                } else {                    checkCategorical(data, missings, loaded, attr, aId, vector[attr], instance.get(aId));                }                aId++;            }        }        lind++;    }}
6ca72fabbea728ad1aa60b6c0deaa66f0824e895e071bcb5fb91f6cd9fdc3947
testLoadedDataset
 static void testLoadedDataset(double[][] data, Attribute[] attrs, Collection<Integer> missings, Data loaded)
{    int nbAttributes = attrs.length;    int iId = 0;    for (int index = 0; index < data.length; index++) {        if (missings.contains(index)) {            continue;        }        Instance instance = loaded.get(iId++);        int aId = 0;        for (int attr = 0; attr < nbAttributes; attr++) {            if (attrs[attr].isIgnored()) {                continue;            }            if (attrs[attr].isLabel()) {                if (!loaded.getDataset().isNumerical(aId)) {                    double nValue = instance.get(aId);                    String oValue = Double.toString(data[index][attr]);                    assertEquals(loaded.getDataset().valueOf(aId, oValue), nValue, EPSILON);                }            } else {                assertEquals(attrs[attr].isNumerical(), loaded.getDataset().isNumerical(aId));                if (attrs[attr].isCategorical()) {                    double nValue = instance.get(aId);                    String oValue = Double.toString(data[index][attr]);                    assertEquals(loaded.getDataset().valueOf(aId, oValue), nValue, EPSILON);                }            }            aId++;        }    }}
adb7ea8bcbb3b943ef7ddbf49d9c1658eeae223f9151b9faa36d00a763d8aa05
testLoadDataFromFile
public void testLoadDataFromFile() throws Exception
{    int nbAttributes = 10;    int datasize = 100;        String descriptor = Utils.randomDescriptor(rng, nbAttributes);    Attribute[] attrs = DescriptorUtils.parseDescriptor(descriptor);        double[][] source = Utils.randomDoubles(rng, descriptor, false, datasize);    Collection<Integer> missings = Lists.newArrayList();    String[] sData = prepareData(source, attrs, missings);    Dataset dataset = DataLoader.generateDataset(descriptor, false, sData);    Path dataPath = Utils.writeDataToTestFile(sData);    FileSystem fs = dataPath.getFileSystem(getConfiguration());    Data loaded = DataLoader.loadData(dataset, fs, dataPath);    testLoadedData(source, attrs, missings, loaded);        source = Utils.randomDoubles(rng, descriptor, true, datasize);    missings = Lists.newArrayList();    sData = prepareData(source, attrs, missings);    dataset = DataLoader.generateDataset(descriptor, true, sData);    dataPath = Utils.writeDataToTestFile(sData);    fs = dataPath.getFileSystem(getConfiguration());    loaded = DataLoader.loadData(dataset, fs, dataPath);    testLoadedData(source, attrs, missings, loaded);}
f036397730b493b3f90588b5b4599e040e5b5a9a395d886b9d81efcf3c4809f2
testGenerateDatasetFromFile
public void testGenerateDatasetFromFile() throws Exception
{    int nbAttributes = 10;    int datasize = 100;        String descriptor = Utils.randomDescriptor(rng, nbAttributes);    Attribute[] attrs = DescriptorUtils.parseDescriptor(descriptor);        double[][] source = Utils.randomDoubles(rng, descriptor, false, datasize);    Collection<Integer> missings = Lists.newArrayList();    String[] sData = prepareData(source, attrs, missings);    Dataset expected = DataLoader.generateDataset(descriptor, false, sData);    Path path = Utils.writeDataToTestFile(sData);    FileSystem fs = path.getFileSystem(getConfiguration());    Dataset dataset = DataLoader.generateDataset(descriptor, false, fs, path);    assertEquals(expected, dataset);        source = Utils.randomDoubles(rng, descriptor, false, datasize);    missings = Lists.newArrayList();    sData = prepareData(source, attrs, missings);    expected = DataLoader.generateDataset(descriptor, false, sData);    path = Utils.writeDataToTestFile(sData);    fs = path.getFileSystem(getConfiguration());    dataset = DataLoader.generateDataset(descriptor, false, fs, path);    assertEquals(expected, dataset);}
270e5452aa4867da7e2ed58d9a2b2cac0c6f9c5a018648dcd0aa9ab55a42ac56
checkCategorical
 static void checkCategorical(double[][] source, Collection<Integer> missings, Data loaded, int attr, int aId, double oValue, double nValue)
{    int lind = 0;    for (int index = 0; index < source.length; index++) {        if (missings.contains(index)) {            continue;        }        if (source[index][attr] == oValue) {            assertEquals(nValue, loaded.get(lind).get(aId), EPSILON);        } else {            assertFalse(nValue == loaded.get(lind).get(aId));        }        lind++;    }}
91540b93cfa5d5d77f0418ff4ff31623bced16225736cdff8f17b48c800cee48
jsonEncoding
public void jsonEncoding() throws DescriptorException
{    Dataset to = DataLoader.generateDataset("N C I L", true, new String[] { "1 foo 2 3", "4 bar 5 6" });            assertEquals(3, to.nbAttributes());    assertEquals(1, to.getIgnored().length);    assertEquals(2, to.getIgnored()[0]);    assertEquals(2, to.getLabelId());    assertTrue(to.isNumerical(0));        Dataset fromJson = Dataset.fromJSON(to.toJSON());    assertEquals(3, fromJson.nbAttributes());    assertEquals(1, fromJson.getIgnored().length);    assertEquals(2, fromJson.getIgnored()[0]);    assertTrue(fromJson.isNumerical(0));        assertNotEquals(fromJson.valueOf(1, "bar"), fromJson.valueOf(1, "foo"));}
7b678b7c9645b2d69eac12403155945ac0d8704379063818c0be7a275f717bf1
jsonEncodingIgnoreFeatures
public void jsonEncodingIgnoreFeatures() throws DescriptorException
{    ;    Dataset to = DataLoader.generateDataset("N C I L", false, new String[] { "1 foo 2 Red", "4 bar 5 Blue" });            assertEquals(3, to.nbAttributes());    assertEquals(1, to.getIgnored().length);    assertEquals(2, to.getIgnored()[0]);    assertEquals(2, to.getLabelId());    assertTrue(to.isNumerical(0));    assertNotEquals(to.valueOf(1, "bar"), to.valueOf(1, "foo"));    assertNotEquals(to.valueOf(2, "Red"), to.valueOf(2, "Blue"));        Dataset fromJson = Dataset.fromJSON(to.toJSON());    assertEquals(3, fromJson.nbAttributes());    assertEquals(1, fromJson.getIgnored().length);    assertEquals(2, fromJson.getIgnored()[0]);    assertTrue(fromJson.isNumerical(0));        assertNotEquals(fromJson.valueOf(1, "bar"), fromJson.valueOf(1, "foo"));    assertNotEquals(fromJson.valueOf(2, "Red"), fromJson.valueOf(2, "Blue"));}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    super.setUp();    rng = RandomUtils.getRandom();    classifierData = Utils.randomData(rng, ATTRIBUTE_COUNT, false, DATA_SIZE);    regressionData = Utils.randomData(rng, ATTRIBUTE_COUNT, true, DATA_SIZE);}
9b406f50dbb2350ff132dff185bc4f0044d4a2d0d61d6471474a02baaa4b8720
testSubset
public void testSubset()
{    int n = 10;    for (int nloop = 0; nloop < n; nloop++) {        int attr = rng.nextInt(classifierData.getDataset().nbAttributes());        double[] values = classifierData.values(attr);        double value = values[rng.nextInt(values.length)];        Data eSubset = classifierData.subset(Condition.equals(attr, value));        Data lSubset = classifierData.subset(Condition.lesser(attr, value));        Data gSubset = classifierData.subset(Condition.greaterOrEquals(attr, value));        for (int index = 0; index < DATA_SIZE; index++) {            Instance instance = classifierData.get(index);            if (instance.get(attr) < value) {                assertTrue(lSubset.contains(instance));                assertFalse(eSubset.contains(instance));                assertFalse(gSubset.contains(instance));            } else if (instance.get(attr) == value) {                assertFalse(lSubset.contains(instance));                assertTrue(eSubset.contains(instance));                assertTrue(gSubset.contains(instance));            } else {                assertFalse(lSubset.contains(instance));                assertFalse(eSubset.contains(instance));                assertTrue(gSubset.contains(instance));            }        }                attr = rng.nextInt(regressionData.getDataset().nbAttributes());        values = regressionData.values(attr);        value = values[rng.nextInt(values.length)];        eSubset = regressionData.subset(Condition.equals(attr, value));        lSubset = regressionData.subset(Condition.lesser(attr, value));        gSubset = regressionData.subset(Condition.greaterOrEquals(attr, value));        for (int index = 0; index < DATA_SIZE; index++) {            Instance instance = regressionData.get(index);            if (instance.get(attr) < value) {                assertTrue(lSubset.contains(instance));                assertFalse(eSubset.contains(instance));                assertFalse(gSubset.contains(instance));            } else if (instance.get(attr) == value) {                assertFalse(lSubset.contains(instance));                assertTrue(eSubset.contains(instance));                assertTrue(gSubset.contains(instance));            } else {                assertFalse(lSubset.contains(instance));                assertFalse(eSubset.contains(instance));                assertTrue(gSubset.contains(instance));            }        }    }}
97f859374249930519bed4c7c695cdc7967bbd624222f619bf1154196da465e3
testValues
public void testValues() throws Exception
{    for (int attr = 0; attr < classifierData.getDataset().nbAttributes(); attr++) {        double[] values = classifierData.values(attr);                for (int index = 0; index < DATA_SIZE; index++) {            assertEquals(1, count(values, classifierData.get(index).get(attr)));        }    }    for (int attr = 0; attr < regressionData.getDataset().nbAttributes(); attr++) {        double[] values = regressionData.values(attr);                for (int index = 0; index < DATA_SIZE; index++) {            assertEquals(1, count(values, regressionData.get(index).get(attr)));        }    }}
33021d55980f47b03c143fed89445e4378a3176de5f3e1306ef4a5214a6fb80b
count
private static int count(double[] values, double value)
{    int count = 0;    for (double v : values) {        if (v == value) {            count++;        }    }    return count;}
b85011d36f724dcb32605902fe3295d23dd004b947dabf3aaccc97b2d1cddc7b
testIdenticalTrue
public void testIdenticalTrue() throws Exception
{        Dataset dataset = Utils.randomData(rng, ATTRIBUTE_COUNT, false, 1).getDataset();        Data empty = new Data(dataset);    assertTrue(empty.isIdentical());        Data identical = Utils.randomData(rng, ATTRIBUTE_COUNT, false, DATA_SIZE);    Instance model = identical.get(0);    for (int index = 1; index < DATA_SIZE; index++) {        for (int attr = 0; attr < identical.getDataset().nbAttributes(); attr++) {            identical.get(index).set(attr, model.get(attr));        }    }    assertTrue(identical.isIdentical());}
52e8fa83b62950e6cc1428923848349bf85aa6a0ad3860a649e6d0cf0b142728
testIdenticalFalse
public void testIdenticalFalse() throws Exception
{    int n = 10;    for (int nloop = 0; nloop < n; nloop++) {        Data data = Utils.randomData(rng, ATTRIBUTE_COUNT, false, DATA_SIZE);                int index = rng.nextInt(DATA_SIZE);        Instance instance = data.get(index);                int attr = rng.nextInt(data.getDataset().nbAttributes());        instance.set(attr, instance.get(attr) + 1);        assertFalse(data.isIdentical());    }}
6aa8ebbfa6fd199ff533ce4c16110c985e2333128a046dc210fa923c3b96f84b
testIdenticalLabelTrue
public void testIdenticalLabelTrue() throws Exception
{        Dataset dataset = Utils.randomData(rng, ATTRIBUTE_COUNT, false, 1).getDataset();        Data empty = new Data(dataset);    assertTrue(empty.identicalLabel());        String descriptor = Utils.randomDescriptor(rng, ATTRIBUTE_COUNT);    double[][] source = Utils.randomDoublesWithSameLabel(rng, descriptor, false, DATA_SIZE, rng.nextInt());    String[] sData = Utils.double2String(source);    dataset = DataLoader.generateDataset(descriptor, false, sData);    Data data = DataLoader.loadData(dataset, sData);    assertTrue(data.identicalLabel());}
c6e34a4ff34fafc93b5c4332bf06b849b9dfae1beefe902002b39adcc4238623
testIdenticalLabelFalse
public void testIdenticalLabelFalse() throws Exception
{    int n = 10;    for (int nloop = 0; nloop < n; nloop++) {        String descriptor = Utils.randomDescriptor(rng, ATTRIBUTE_COUNT);        int label = Utils.findLabel(descriptor);        double[][] source = Utils.randomDoublesWithSameLabel(rng, descriptor, false, DATA_SIZE, rng.nextInt());                int index = rng.nextInt(DATA_SIZE);        source[index][label]++;        String[] sData = Utils.double2String(source);        Dataset dataset = DataLoader.generateDataset(descriptor, false, sData);        Data data = DataLoader.loadData(dataset, sData);        assertFalse(data.identicalLabel());    }}
ed139afe546d3bcfa596844cd0f77c2a6574e59991fce1998818e8e2fd4cd828
testBagging
public void testBagging()
{    Data bag = classifierData.bagging(rng);        assertEquals(classifierData.size(), bag.size());        boolean found = false;    for (int index = 0; index < classifierData.size() && !found; index++) {        found = !bag.contains(classifierData.get(index));    }    assertTrue("some instances from data should not be in the bag", found);        bag = regressionData.bagging(rng);        assertEquals(regressionData.size(), bag.size());        found = false;    for (int index = 0; index < regressionData.size() && !found; index++) {        found = !bag.contains(regressionData.get(index));    }    assertTrue("some instances from data should not be in the bag", found);}
a02c6430a5af1355a693fee8826e369b9c43ad28ed99bfd356d79aff63013539
testRsplit
public void testRsplit()
{        Data source = classifierData.clone();    Data subset = source.rsplit(rng, 0);    assertTrue("subset should be empty", subset.isEmpty());    assertEquals("source.size is incorrect", DATA_SIZE, source.size());        source = classifierData.clone();    subset = source.rsplit(rng, DATA_SIZE);    assertEquals("subset.size is incorrect", DATA_SIZE, subset.size());    assertTrue("source should be empty", source.isEmpty());        int subsize = rng.nextInt(DATA_SIZE);    source = classifierData.clone();    subset = source.rsplit(rng, subsize);    assertEquals("subset.size is incorrect", subsize, subset.size());    assertEquals("source.size is incorrect", DATA_SIZE - subsize, source.size());            source = regressionData.clone();    subset = source.rsplit(rng, 0);    assertTrue("subset should be empty", subset.isEmpty());    assertEquals("source.size is incorrect", DATA_SIZE, source.size());        source = regressionData.clone();    subset = source.rsplit(rng, DATA_SIZE);    assertEquals("subset.size is incorrect", DATA_SIZE, subset.size());    assertTrue("source should be empty", source.isEmpty());        subsize = rng.nextInt(DATA_SIZE);    source = regressionData.clone();    subset = source.rsplit(rng, subsize);    assertEquals("subset.size is incorrect", subsize, subset.size());    assertEquals("source.size is incorrect", DATA_SIZE - subsize, source.size());}
ce6a256964b693cedda241d1f349cdc8341df37d7d234460511009e0cb952bbb
testCountLabel
public void testCountLabel() throws Exception
{    Dataset dataset = classifierData.getDataset();    int[] counts = new int[dataset.nblabels()];    int n = 10;    for (int nloop = 0; nloop < n; nloop++) {        Arrays.fill(counts, 0);        classifierData.countLabels(counts);        for (int index = 0; index < classifierData.size(); index++) {            counts[(int) dataset.getLabel(classifierData.get(index))]--;        }        for (int label = 0; label < classifierData.getDataset().nblabels(); label++) {            assertEquals("Wrong label 'equals' count", 0, counts[0]);        }    }}
f533d3796daf81647a76abf6310c492ad066fd92ff0792d2fcd24b9c507c190f
testMajorityLabel
public void testMajorityLabel() throws Exception
{        String descriptor = Utils.randomDescriptor(rng, ATTRIBUTE_COUNT);    int label = Utils.findLabel(descriptor);    int label1 = rng.nextInt();    double[][] source = Utils.randomDoublesWithSameLabel(rng, descriptor, false, 100, label1);    String[] sData = Utils.double2String(source);    Dataset dataset = DataLoader.generateDataset(descriptor, false, sData);    Data data = DataLoader.loadData(dataset, sData);    int code1 = dataset.labelCode(Double.toString(label1));    assertEquals(code1, data.majorityLabel(rng));        int label2 = label1 + 1;    int nblabel2 = 51;    while (nblabel2 > 0) {        double[] vector = source[rng.nextInt(100)];        if (vector[label] != label2) {            vector[label] = label2;            nblabel2--;        }    }    sData = Utils.double2String(source);    dataset = DataLoader.generateDataset(descriptor, false, sData);    data = DataLoader.loadData(dataset, sData);    int code2 = dataset.labelCode(Double.toString(label2));        assertEquals(code2, data.majorityLabel(rng));        do {        double[] vector = source[rng.nextInt(100)];        if (vector[label] == label2) {            vector[label] = label1;            break;        }    } while (true);    sData = Utils.double2String(source);    data = DataLoader.loadData(dataset, sData);    code1 = dataset.labelCode(Double.toString(label1));    code2 = dataset.labelCode(Double.toString(label2));        boolean found1 = false;    boolean found2 = false;    for (int index = 0; index < 10 && (!found1 || !found2); index++) {        int major = data.majorityLabel(rng);        if (major == code1) {            found1 = true;        }        if (major == code2) {            found2 = true;        }    }    assertTrue(found1 && found2);}
534701863d320b3d1988dc08ee8d06b51bdb4f452f72599042bfd38f1724112d
testParseDescriptor
public void testParseDescriptor() throws Exception
{    int n = 10;    int maxnbAttributes = 100;    Random rng = RandomUtils.getRandom();    for (int nloop = 0; nloop < n; nloop++) {        int nbAttributes = rng.nextInt(maxnbAttributes) + 1;        char[] tokens = Utils.randomTokens(rng, nbAttributes);        Attribute[] attrs = DescriptorUtils.parseDescriptor(Utils.generateDescriptor(tokens));                assertEquals("attributes size", nbAttributes, attrs.length);        for (int attr = 0; attr < nbAttributes; attr++) {            switch(tokens[attr]) {                case 'I':                    assertTrue(attrs[attr].isIgnored());                    break;                case 'N':                    assertTrue(attrs[attr].isNumerical());                    break;                case 'C':                    assertTrue(attrs[attr].isCategorical());                    break;                case 'L':                    assertTrue(attrs[attr].isLabel());                    break;            }        }    }}
0ad274b09380467b6decf3620e7fe1295b2a5344d5942fdb475d82281a0bc403
testGenerateDescription
public void testGenerateDescription() throws Exception
{    validate("", "");    validate("I L C C N N N C", "I L C C N N N C");    validate("I L C C N N N C", "I L 2 C 3 N C");    validate("I L C C N N N C", " I L  2 C 3 N C ");    try {        validate("", "I L 2 2 C 2 N C");        fail("2 consecutive multiplicators");    } catch (DescriptorException e) {    }    try {        validate("", "I L 2 C -2 N C");        fail("negative multiplicator");    } catch (DescriptorException e) {    }}
4fedb2a93559432eff7dfa1420c6c636221f147e8aa0c16088536b779b307ea6
validate
private static void validate(String descriptor, CharSequence description) throws DescriptorException
{    assertEquals(descriptor, DescriptorUtils.generateDescriptor(description));}
3769a2036ad47a5e6a817abb6ae72577d702247d3aa5aa8345228b61f7d54fca
randomTokens
public static char[] randomTokens(Random rng, int nbTokens)
{    char[] result = new char[nbTokens];    for (int token = 0; token < nbTokens; token++) {        double rand = rng.nextDouble();        if (rand < 0.1) {                        result[token] = 'I';        } else if (rand >= 0.5) {            result[token] = 'C';        } else {                        result[token] = 'N';        }        }        result[rng.nextInt(nbTokens)] = 'L';    return result;}
731efde5cced2e8e4c234de73218d75d2684b732dd4c7b8eb4c232b27a27626f
generateDescriptor
public static String generateDescriptor(char[] tokens)
{    StringBuilder builder = new StringBuilder();    for (char token : tokens) {        builder.append(token).append(' ');    }    return builder.toString();}
b96add4a177b53e7270f053acefab752b47f4e8c764a9fc909e2382acddb7d35
randomDescriptor
public static String randomDescriptor(Random rng, int nbAttributes)
{    return generateDescriptor(randomTokens(rng, nbAttributes));}
957bf6b071b02b3bc7467fd4a97d14389bf5bfdf68d0e93dce1ff40520c597c3
randomDoubles
public static double[][] randomDoubles(Random rng, CharSequence descriptor, boolean regression, int number) throws DescriptorException
{    Attribute[] attrs = DescriptorUtils.parseDescriptor(descriptor);    double[][] data = new double[number][];    for (int index = 0; index < number; index++) {        data[index] = randomVector(rng, attrs, regression);    }    return data;}
c64043de573c557170fefb4a7c8fc63092e0900b57219116eaa73181c04b54b6
randomData
public static Data randomData(Random rng, int nbAttributes, boolean regression, int size) throws DescriptorException
{    String descriptor = randomDescriptor(rng, nbAttributes);    double[][] source = randomDoubles(rng, descriptor, regression, size);    String[] sData = double2String(source);    Dataset dataset = DataLoader.generateDataset(descriptor, regression, sData);    return DataLoader.loadData(dataset, sData);}
0656235d97e4a73896a9a1ff1fedd7ecc49235f03a632b6b81c4f8a74d970959
randomVector
private static double[] randomVector(Random rng, Attribute[] attrs, boolean regression)
{    double[] vector = new double[attrs.length];    for (int attr = 0; attr < attrs.length; attr++) {        if (attrs[attr].isIgnored()) {            vector[attr] = Double.NaN;        } else if (attrs[attr].isNumerical()) {            vector[attr] = rng.nextDouble();        } else if (attrs[attr].isCategorical()) {            vector[attr] = rng.nextInt(CATEGORICAL_RANGE);        } else {                        if (regression) {                vector[attr] = rng.nextDouble();            } else {                vector[attr] = rng.nextInt(CATEGORICAL_RANGE);            }        }    }    return vector;}
54909053d10bd7ad8d1d8dd6cbf0ea555a1c39c7406089aa874de1b15cac9dab
double2String
private static String double2String(double[] v)
{    StringBuilder builder = new StringBuilder();    for (double aV : v) {        builder.append(aV).append(',');    }    return builder.toString();}
378088be756f28c3a8a900584a9012925b946f70fac16c1f49fa368bf11fa4ad
double2String
public static String[] double2String(double[][] source)
{    String[] output = new String[source.length];    for (int index = 0; index < source.length; index++) {        output[index] = double2String(source[index]);    }    return output;}
fd50ff629bc62a4eff88831dce776a23b2d5efb6f6508c863800090a7ef0e22c
randomDoublesWithSameLabel
public static double[][] randomDoublesWithSameLabel(Random rng, CharSequence descriptor, boolean regression, int number, int value) throws DescriptorException
{    int label = findLabel(descriptor);    double[][] source = randomDoubles(rng, descriptor, regression, number);    for (int index = 0; index < number; index++) {        source[index][label] = value;    }    return source;}
a8f5dfe03ecae26e8db91ede98d18b3c50cc79845acc49dd58682efffbf8c5c9
findLabel
public static int findLabel(CharSequence descriptor) throws DescriptorException
{    Attribute[] attrs = DescriptorUtils.parseDescriptor(descriptor);    return ArrayUtils.indexOf(attrs, Attribute.LABEL);}
b835d04962b1273bb50dbaac502db7dd81de6bda7b2cd74f3f16f1a220ea98d0
writeDataToFile
private static void writeDataToFile(String[] sData, Path path) throws IOException
{    BufferedWriter output = null;    try {        output = Files.newWriter(new File(path.toString()), Charsets.UTF_8);        for (String line : sData) {            output.write(line);            output.write('\n');        }    } finally {        Closeables.close(output, false);    }}
c3612ed4ee3bcc74c5ee59c654d0c2be3df808ec000435a65b04e8b9a7529960
writeDataToTestFile
public static Path writeDataToTestFile(String[] sData) throws IOException
{    Path testData = new Path("testdata/Data");    MahoutTestCase ca = new MahoutTestCase();    FileSystem fs = testData.getFileSystem(ca.getConfiguration());    if (!fs.exists(testData)) {        fs.mkdirs(testData);    }    Path path = new Path(testData, "DataLoaderTest.data");    writeDataToFile(sData, path);    return path;}
132730c5c6d5ed0180523cba82c076afc551b28b9452f8384483424fa65162a7
splitData
public static String[][] splitData(String[] sData, int numMaps)
{    int nbInstances = sData.length;    int partitionSize = nbInstances / numMaps;    String[][] splits = new String[numMaps][];    for (int partition = 0; partition < numMaps; partition++) {        int from = partition * partitionSize;        int to = partition == (numMaps - 1) ? nbInstances : (partition + 1) * partitionSize;        splits[partition] = Arrays.copyOfRange(sData, from, to);    }    return splits;}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    super.setUp();    rng = RandomUtils.getRandom();}
9eeeeebbd0db4e5d3daf80339e1c6adc2e5a77d538d37aeba056361901668b7f
generateTrainingDataA
private static Data[] generateTrainingDataA() throws DescriptorException
{        Dataset dataset = DataLoader.generateDataset("C N N C L", false, TRAIN_DATA);        Data data = DataLoader.loadData(dataset, TRAIN_DATA);    @SuppressWarnings("unchecked")    List<Instance>[] instances = new List[3];    for (int i = 0; i < instances.length; i++) {        instances[i] = Lists.newArrayList();    }    for (int i = 0; i < data.size(); i++) {        if (data.get(i).get(0) == 0.0d) {            instances[0].add(data.get(i));        } else {            instances[1].add(data.get(i));        }    }    Data[] datas = new Data[instances.length];    for (int i = 0; i < datas.length; i++) {        datas[i] = new Data(dataset, instances[i]);    }    return datas;}
63a3af101545a0b43605942167448a87fc0a9383eb85a0d7576fccafaa8f4f0a
generateTrainingDataB
private static Data[] generateTrainingDataB() throws DescriptorException
{        String[] trainData = new String[20];    for (int i = 0; i < trainData.length; i++) {        if (i % 3 == 0) {            trainData[i] = "A," + (40 - i) + ',' + (i + 20);        } else if (i % 3 == 1) {            trainData[i] = "B," + (i + 20) + ',' + (40 - i);        } else {            trainData[i] = "C," + (i + 20) + ',' + (i + 20);        }    }        Dataset dataset = DataLoader.generateDataset("C N L", true, trainData);    Data[] datas = new Data[3];    datas[0] = DataLoader.loadData(dataset, trainData);        trainData = new String[20];    for (int i = 0; i < trainData.length; i++) {        if (i % 2 == 0) {            trainData[i] = "A," + (50 - i) + ',' + (i + 10);        } else {            trainData[i] = "B," + (i + 10) + ',' + (50 - i);        }    }    datas[1] = DataLoader.loadData(dataset, trainData);        trainData = new String[10];    for (int i = 0; i < trainData.length; i++) {        trainData[i] = "A," + (40 - i) + ',' + (i + 20);    }    datas[2] = DataLoader.loadData(dataset, trainData);    return datas;}
2f46c451fc448cec64dd20724ee90bd08fe7fd9eaf78d3a432e6b953b82bec7b
buildForest
private DecisionForest buildForest(Data[] datas)
{    List<Node> trees = Lists.newArrayList();    for (Data data : datas) {                DecisionTreeBuilder builder = new DecisionTreeBuilder();        builder.setM(data.getDataset().nbAttributes() - 1);        builder.setMinSplitNum(0);        builder.setComplemented(false);        trees.add(builder.build(rng, data));    }    return new DecisionForest(trees);}
083141b8bccea9b02967dea761ba4f017c13a3cf5bc32f654a772981f37b876d
testClassify
public void testClassify() throws DescriptorException
{        Data[] datas = generateTrainingDataA();        DecisionForest forest = buildForest(datas);        Dataset dataset = datas[0].getDataset();    Data testData = DataLoader.loadData(dataset, TEST_DATA);    double noValue = dataset.valueOf(4, "no");    double yesValue = dataset.valueOf(4, "yes");    assertEquals(noValue, forest.classify(testData.getDataset(), rng, testData.get(0)), EPSILON);            assertEquals(noValue, forest.classify(testData.getDataset(), rng, testData.get(2)), EPSILON);}
4daaedb71ca3859dfbb9884323920095029fb05dd573046d6d93c15932ab720d
testClassifyData
public void testClassifyData() throws DescriptorException
{        Data[] datas = generateTrainingDataA();        DecisionForest forest = buildForest(datas);        Dataset dataset = datas[0].getDataset();    Data testData = DataLoader.loadData(dataset, TEST_DATA);    double[][] predictions = new double[testData.size()][];    forest.classify(testData, predictions);    double noValue = dataset.valueOf(4, "no");    double yesValue = dataset.valueOf(4, "yes");    assertArrayEquals(new double[][] { { noValue, Double.NaN, Double.NaN }, { noValue, yesValue, Double.NaN }, { noValue, noValue, Double.NaN } }, predictions);}
d0e60675ad80e6f7c852ad9a74fa8ead26cd2e521240ec68158c767beacad746
testRegression
public void testRegression() throws DescriptorException
{    Data[] datas = generateTrainingDataB();    DecisionForest[] forests = new DecisionForest[datas.length];    for (int i = 0; i < datas.length; i++) {        Data[] subDatas = new Data[datas.length - 1];        int k = 0;        for (int j = 0; j < datas.length; j++) {            if (j != i) {                subDatas[k] = datas[j];                k++;            }        }        forests[i] = buildForest(subDatas);    }    double[][] predictions = new double[datas[0].size()][];    forests[0].classify(datas[0], predictions);    assertArrayEquals(new double[] { 20.0, 20.0 }, predictions[0], EPSILON);    assertArrayEquals(new double[] { 39.0, 29.0 }, predictions[1], EPSILON);    assertArrayEquals(new double[] { Double.NaN, 29.0 }, predictions[2], EPSILON);    assertArrayEquals(new double[] { Double.NaN, 23.0 }, predictions[17], EPSILON);    predictions = new double[datas[1].size()][];    forests[1].classify(datas[1], predictions);    assertArrayEquals(new double[] { 30.0, 29.0 }, predictions[19], EPSILON);    predictions = new double[datas[2].size()][];    forests[2].classify(datas[2], predictions);    assertArrayEquals(new double[] { 29.0, 28.0 }, predictions[9], EPSILON);    assertEquals(20.0, forests[0].classify(datas[0].getDataset(), rng, datas[0].get(0)), EPSILON);    assertEquals(34.0, forests[0].classify(datas[0].getDataset(), rng, datas[0].get(1)), EPSILON);    assertEquals(29.0, forests[0].classify(datas[0].getDataset(), rng, datas[0].get(2)), EPSILON);}
b0c850a3dfbadbc2c6aa83e0bcbe44a787144b5452e83d7d2ea2ca35cb1b46c4
testSplits
public void testSplits() throws Exception
{    int n = 1;    int maxNumSplits = 100;    int maxNbTrees = 1000;    Random rng = RandomUtils.getRandom();    for (int nloop = 0; nloop < n; nloop++) {        int numSplits = rng.nextInt(maxNumSplits) + 1;        int nbTrees = rng.nextInt(maxNbTrees) + 1;        Configuration conf = getConfiguration();        Builder.setNbTrees(conf, nbTrees);        InMemInputFormat inputFormat = new InMemInputFormat();        List<InputSplit> splits = inputFormat.getSplits(conf, numSplits);        assertEquals(numSplits, splits.size());        int nbTreesPerSplit = nbTrees / numSplits;        int totalTrees = 0;        int expectedId = 0;        for (int index = 0; index < numSplits; index++) {            assertTrue(splits.get(index) instanceof InMemInputSplit);            InMemInputSplit split = (InMemInputSplit) splits.get(index);            assertEquals(expectedId, split.getFirstId());            if (index < numSplits - 1) {                assertEquals(nbTreesPerSplit, split.getNbTrees());            } else {                assertEquals(nbTrees - totalTrees, split.getNbTrees());            }            totalTrees += split.getNbTrees();            expectedId += split.getNbTrees();        }    }}
2ce99c6c08623af856d0d4f1cb60a7ae9dd27d8904d2e9a5dd4f30f0ad190b8b
testRecordReader
public void testRecordReader() throws Exception
{    int n = 1;    int maxNumSplits = 100;    int maxNbTrees = 1000;    Random rng = RandomUtils.getRandom();    for (int nloop = 0; nloop < n; nloop++) {        int numSplits = rng.nextInt(maxNumSplits) + 1;        int nbTrees = rng.nextInt(maxNbTrees) + 1;        Configuration conf = getConfiguration();        Builder.setNbTrees(conf, nbTrees);        InMemInputFormat inputFormat = new InMemInputFormat();        List<InputSplit> splits = inputFormat.getSplits(conf, numSplits);        for (int index = 0; index < numSplits; index++) {            InMemInputSplit split = (InMemInputSplit) splits.get(index);            InMemRecordReader reader = new InMemRecordReader(split);            reader.initialize(split, null);            for (int tree = 0; tree < split.getNbTrees(); tree++) {                                assertEquals(tree < split.getNbTrees(), reader.nextKeyValue());                assertEquals(split.getFirstId() + tree, reader.getCurrentKey().get());            }        }    }}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    super.setUp();    rng = RandomUtils.getRandom();    byteOutStream = new ByteArrayOutputStream();    out = new DataOutputStream(byteOutStream);}
b760e783ced6d893c14245aa0647446f3eeb86c234d9ba85669ea1a19703381f
testWritable
public void testWritable() throws Exception
{    InMemInputSplit split = new InMemInputSplit(rng.nextInt(), rng.nextInt(1000), rng.nextLong());    split.write(out);    assertEquals(split, readSplit());}
0b2f91eb786b8d80a9b2a67633c78d407d5df0f4d13c8bfa84aa91c2df6d10e9
testNullSeed
public void testNullSeed() throws Exception
{    InMemInputSplit split = new InMemInputSplit(rng.nextInt(), rng.nextInt(1000), null);    split.write(out);    assertEquals(split, readSplit());}
393cba2562b9e21d2757a4231bc0cd9a59692a7d347264a83d117c60455bd9de
readSplit
private InMemInputSplit readSplit() throws IOException
{    ByteArrayInputStream byteInStream = new ByteArrayInputStream(byteOutStream.toByteArray());    DataInput in = new DataInputStream(byteInStream);    return InMemInputSplit.read(in);}
db911377003941c20754f05842d0ef88d6e18087a643cd74ef5878ea062ae5c8
testProcessOutput
public void testProcessOutput() throws Exception
{    Configuration conf = getConfiguration();    conf.setInt("mapred.map.tasks", NUM_MAPS);    Random rng = RandomUtils.getRandom();        TreeID[] keys = new TreeID[NUM_TREES];    MapredOutput[] values = new MapredOutput[NUM_TREES];    int[] firstIds = new int[NUM_MAPS];    randomKeyValues(rng, keys, values, firstIds);        Path base = getTestTempDirPath("testdata");    FileSystem fs = base.getFileSystem(conf);    Path outputFile = new Path(base, "PartialBuilderTest.seq");    Writer writer = SequenceFile.createWriter(fs, conf, outputFile, TreeID.class, MapredOutput.class);    try {        for (int index = 0; index < NUM_TREES; index++) {            writer.append(keys[index], values[index]);        }    } finally {        Closeables.close(writer, false);    }        TreeID[] newKeys = new TreeID[NUM_TREES];    Node[] newTrees = new Node[NUM_TREES];    PartialBuilder.processOutput(new Job(conf), base, newKeys, newTrees);        for (int tree = 0; tree < NUM_TREES; tree++) {        assertEquals(values[tree].getTree(), newTrees[tree]);    }    assertTrue("keys not equal", Arrays.deepEquals(keys, newKeys));}
57e3af1eefb27d515cf2edbe0364107956803b91525a594280f1ed19f7057951
testConfigure
public void testConfigure()
{    TreeBuilder treeBuilder = new DefaultTreeBuilder();    Path dataPath = new Path("notUsedDataPath");    Path datasetPath = new Path("notUsedDatasetPath");    Long seed = 5L;    new PartialBuilderChecker(treeBuilder, dataPath, datasetPath, seed);}
bcf14ff55936f98dcc7da236d44fcc18d4b3f3ffcfdb8a9a1349f2555503f595
randomKeyValues
private static void randomKeyValues(Random rng, TreeID[] keys, MapredOutput[] values, int[] firstIds)
{    int index = 0;    int firstId = 0;    Collection<Integer> partitions = Lists.newArrayList();    for (int p = 0; p < NUM_MAPS; p++) {                int partition;        do {            partition = rng.nextInt(NUM_MAPS);        } while (partitions.contains(partition));        partitions.add(partition);        int nbTrees = Step1Mapper.nbTrees(NUM_MAPS, NUM_TREES, partition);        for (int treeId = 0; treeId < nbTrees; treeId++) {            Node tree = new Leaf(rng.nextInt(100));            keys[index] = new TreeID(partition, treeId);            values[index] = new MapredOutput(tree, nextIntArray(rng, NUM_INSTANCES));            index++;        }        firstIds[p] = firstId;        firstId += NUM_INSTANCES;    }}
22ed9e3c490fdfc4a63b97d38a124e4d82375b25b23aff6260a14318799c8663
nextIntArray
private static int[] nextIntArray(Random rng, int size)
{    int[] array = new int[size];    for (int index = 0; index < size; index++) {        array[index] = rng.nextInt(101) - 1;    }    return array;}
83f9760fdaa4d3a360bf5a3f3b88378c0b502022a314f27ec048c5aa353e37cf
runJob
protected boolean runJob(Job job) throws IOException
{        Configuration conf = job.getConfiguration();    assertEquals(seed, getRandomSeed(conf));            assertEquals(1, conf.getInt("mapred.map.tasks", -1));    assertEquals(NUM_TREES, getNbTrees(conf));    assertFalse(isOutput(conf));    assertEquals(treeBuilder, getTreeBuilder(conf));    assertEquals(datasetPath, getDistributedCacheFile(conf, 0));    return true;}
729f34b5fcaaf905ea2af592899da4da4dbd230518fc6d3f8ed9ba560c675b25
setExpected
public void setExpected(Data data)
{    expected = data;}
37e142b96449df64b0ad3dd35f4187ee47474e4523162b029a4681ec1d2e6a1b
build
public Node build(Random rng, Data data)
{    for (int index = 0; index < data.size(); index++) {        assertTrue(expected.contains(data.get(index)));    }    return new Leaf(Double.NaN);}
8c9154dc105538a7fa35a7b42606bf2699ba1910743c7e938abd9c9e87ca1f7d
setValue
public void setValue(final TreeID value)
{    super.setValue(value.clone());}
34843d3a362eff731c54639ba8d37a92b02e90ac924399a3cd662067283747fe
testMapper
public void testMapper() throws Exception
{    Random rng = RandomUtils.getRandom();        String descriptor = Utils.randomDescriptor(rng, NUM_ATTRIBUTES);    double[][] source = Utils.randomDoubles(rng, descriptor, false, NUM_INSTANCES);    String[] sData = Utils.double2String(source);    Dataset dataset = DataLoader.generateDataset(descriptor, false, sData);    String[][] splits = Utils.splitData(sData, NUM_MAPPERS);    MockTreeBuilder treeBuilder = new MockTreeBuilder();    LongWritable key = new LongWritable();    Text value = new Text();    int treeIndex = 0;    for (int partition = 0; partition < NUM_MAPPERS; partition++) {        String[] split = splits[partition];        treeBuilder.setExpected(DataLoader.loadData(dataset, split));                int mapNbTrees = Step1Mapper.nbTrees(NUM_MAPPERS, NUM_TREES, partition);        Mapper.Context context = EasyMock.createNiceMock(Mapper.Context.class);        Capture<TreeID> capturedKeys = new TreeIDCapture();        context.write(EasyMock.capture(capturedKeys), EasyMock.anyObject());        EasyMock.expectLastCall().anyTimes();        EasyMock.replay(context);        MockStep1Mapper mapper = new MockStep1Mapper(treeBuilder, dataset, null, partition, NUM_MAPPERS, NUM_TREES);                assertEquals(treeIndex, mapper.getFirstTreeId());        for (int index = 0; index < split.length; index++) {            key.set(index);            value.set(split[index]);            mapper.map(key, value, context);        }        mapper.cleanup(context);        EasyMock.verify(context);                assertEquals(mapNbTrees, capturedKeys.getValues().size());                for (TreeID k : capturedKeys.getValues()) {            assertEquals(partition, k.partition());            assertEquals(treeIndex, k.treeId());            treeIndex++;        }    }}
b13a5f6e6cc1cb8feeb0dfc233530f425be8bfd6fa8effb9dcd356636979f761
testTreeID
public void testTreeID()
{    Random rng = RandomUtils.getRandom();    for (int nloop = 0; nloop < 1000000; nloop++) {        int partition = Math.abs(rng.nextInt());        int treeId = rng.nextInt(TreeID.MAX_TREEID);        TreeID t1 = new TreeID(partition, treeId);        assertEquals(partition, t1.partition());        assertEquals(treeId, t1.treeId());        TreeID t2 = new TreeID();        t2.set(partition, treeId);        assertEquals(partition, t2.partition());        assertEquals(treeId, t2.treeId());    }}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    super.setUp();    rng = RandomUtils.getRandom();    byteOutStream = new ByteArrayOutputStream();    out = new DataOutputStream(byteOutStream);}
01758c2e6466a6e3c08fa70bf6f5dbdb5bfbdde2280968d70e52c6420b2fbe8c
testReadTree
public void testReadTree() throws Exception
{    Node node1 = new CategoricalNode(rng.nextInt(), new double[] { rng.nextDouble(), rng.nextDouble() }, new Node[] { new Leaf(rng.nextDouble()), new Leaf(rng.nextDouble()) });    Node node2 = new NumericalNode(rng.nextInt(), rng.nextDouble(), new Leaf(rng.nextDouble()), new Leaf(rng.nextDouble()));    Node root = new CategoricalNode(rng.nextInt(), new double[] { rng.nextDouble(), rng.nextDouble(), rng.nextDouble() }, new Node[] { node1, node2, new Leaf(rng.nextDouble()) });        root.write(out);        assertEquals(root, readNode());}
3b87240895b67e1a6a298de5ee443ee1d04975c85f6cae0e12ddd38188edfb9d
readNode
 Node readNode() throws IOException
{    ByteArrayInputStream byteInStream = new ByteArrayInputStream(byteOutStream.toByteArray());    DataInput in = new DataInputStream(byteInStream);    return Node.read(in);}
faef6c5fc7ad2f74153b05ccfb8e6ac12499c3bf3f5b15af0da6cedeb650c93f
testReadLeaf
public void testReadLeaf() throws Exception
{    Node leaf = new Leaf(rng.nextDouble());    leaf.write(out);    assertEquals(leaf, readNode());}
c1beef5b19f3cc531f69df0f01c30584e71f08b35cdcd0dcf22ec580bdc72ca6
testParseNumerical
public void testParseNumerical() throws Exception
{    Node node = new NumericalNode(rng.nextInt(), rng.nextDouble(), new Leaf(rng.nextInt()), new Leaf(rng.nextDouble()));    node.write(out);    assertEquals(node, readNode());}
5f37e92ddfd91d37ba239b2f77ea614591cc8fd9dfe66a31a172a7bede4867f8
testCategoricalNode
public void testCategoricalNode() throws Exception
{    Node node = new CategoricalNode(rng.nextInt(), new double[] { rng.nextDouble(), rng.nextDouble(), rng.nextDouble() }, new Node[] { new Leaf(rng.nextDouble()), new Leaf(rng.nextDouble()), new Leaf(rng.nextDouble()) });    node.write(out);    assertEquals(node, readNode());}
b61e4a510ecc32363072248af4f881013ae13dc88209cd38fbaf337225e5c8df
testEntropy
public void testEntropy() throws Exception
{    Random rng = RandomUtils.getRandom();    String descriptor = Utils.randomDescriptor(rng, NUM_ATTRIBUTES);    int label = Utils.findLabel(descriptor);        double[][] temp = Utils.randomDoublesWithSameLabel(rng, descriptor, false, 100, 0);    String[] sData = Utils.double2String(temp);    Dataset dataset = DataLoader.generateDataset(descriptor, false, sData);    Data data = DataLoader.loadData(dataset, sData);    DefaultIgSplit iG = new DefaultIgSplit();    double expected = 0.0 - 1.0 * Math.log(1.0) / Math.log(2.0);    assertEquals(expected, iG.entropy(data), EPSILON);        for (int index = 0; index < 50; index++) {        temp[index][label] = 1.0;    }    sData = Utils.double2String(temp);    dataset = DataLoader.generateDataset(descriptor, false, sData);    data = DataLoader.loadData(dataset, sData);    iG = new DefaultIgSplit();    expected = 2.0 * -0.5 * Math.log(0.5) / Math.log(2.0);    assertEquals(expected, iG.entropy(data), EPSILON);        for (int index = 0; index < 15; index++) {        temp[index][label] = 2.0;    }    sData = Utils.double2String(temp);    dataset = DataLoader.generateDataset(descriptor, false, sData);    data = DataLoader.loadData(dataset, sData);    iG = new DefaultIgSplit();    expected = -0.15 * Math.log(0.15) / Math.log(2.0) - 0.35 * Math.log(0.35) / Math.log(2.0) - 0.5 * Math.log(0.5) / Math.log(2.0);    assertEquals(expected, iG.entropy(data), EPSILON);}
f78031cf774f96b2ee37f1a0aa77a8d3c5734314cf02f5ff4aba669cd1f09ea7
generateTrainingData
private static Data[] generateTrainingData() throws DescriptorException
{        String[] trainData = new String[20];    for (int i = 0; i < trainData.length; i++) {        if (i % 3 == 0) {            trainData[i] = "A," + (40 - i) + ',' + (i + 20);        } else if (i % 3 == 1) {            trainData[i] = "B," + (i + 20) + ',' + (40 - i);        } else {            trainData[i] = "C," + (i + 20) + ',' + (i + 20);        }    }        Dataset dataset = DataLoader.generateDataset("C N L", true, trainData);    Data[] datas = new Data[3];    datas[0] = DataLoader.loadData(dataset, trainData);        trainData = new String[20];    for (int i = 0; i < trainData.length; i++) {        if (i % 2 == 0) {            trainData[i] = "A," + (50 - i) + ',' + (i + 10);        } else {            trainData[i] = "B," + (i + 10) + ',' + (50 - i);        }    }    datas[1] = DataLoader.loadData(dataset, trainData);        trainData = new String[10];    for (int i = 0; i < trainData.length; i++) {        trainData[i] = "A," + (40 - i) + ',' + (i + 20);    }    datas[2] = DataLoader.loadData(dataset, trainData);    return datas;}
31748072468aefffcdab457f184ccce5a315dc8c864797afa2a8668511846fd4
testComputeSplit
public void testComputeSplit() throws DescriptorException
{    Data[] datas = generateTrainingData();    RegressionSplit igSplit = new RegressionSplit();    Split split = igSplit.computeSplit(datas[0], 1);    assertEquals(180.0, split.getIg(), EPSILON);    assertEquals(38.0, split.getSplit(), EPSILON);    split = igSplit.computeSplit(datas[0].subset(Condition.lesser(1, 38.0)), 1);    assertEquals(76.5, split.getIg(), EPSILON);    assertEquals(21.5, split.getSplit(), EPSILON);    split = igSplit.computeSplit(datas[1], 0);    assertEquals(2205.0, split.getIg(), EPSILON);    assertEquals(Double.NaN, split.getSplit(), EPSILON);    split = igSplit.computeSplit(datas[1].subset(Condition.equals(0, 0.0)), 1);    assertEquals(250.0, split.getIg(), EPSILON);    assertEquals(41.0, split.getSplit(), EPSILON);}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    super.setUp();    randomNumberGenerator = RandomUtils.getRandom(1);    Dataset dataset = DataLoader.generateDataset("C N N C L", false, TRAIN_DATA);    trainingData = DataLoader.loadData(dataset, TRAIN_DATA);    testData = DataLoader.loadData(dataset, TEST_DATA);}
fc444ddad02de4c9885cf765935eeae2dff859ead7b33f5b4424bf0ab9faedc7
testTreeVisualize
public void testTreeVisualize() throws Exception
{        DecisionTreeBuilder builder = new DecisionTreeBuilder();    builder.setM(trainingData.getDataset().nbAttributes() - 1);    Node tree = builder.build(randomNumberGenerator, trainingData);    String visualization = TreeVisualizer.toString(tree, trainingData.getDataset(), ATTRIBUTE_NAMES);    assertTrue((String.format("\n" + "outlook = rainy\n" + "|   windy = FALSE : yes\n" + "|   windy = TRUE : no\n" + "outlook = sunny\n" + "|   humidity < 77%s5 : yes\n" + "|   humidity >= 77%s5 : no\n" + "outlook = overcast : yes", DECIMAL_SEPARATOR, DECIMAL_SEPARATOR)).equals(visualization) || (String.format("\n" + "outlook = rainy\n" + "|   windy = TRUE : no\n" + "|   windy = FALSE : yes\n" + "outlook = overcast : yes\n" + "outlook = sunny\n" + "|   humidity < 77%s5 : yes\n" + "|   humidity >= 77%s5 : no", DECIMAL_SEPARATOR, DECIMAL_SEPARATOR)).equals(visualization));}
bc96a9703abc5868a2ef081e114b0399b7d3c07c726323f8f280000de84206b0
testPredictTrace
public void testPredictTrace() throws Exception
{        DecisionTreeBuilder builder = new DecisionTreeBuilder();    builder.setM(trainingData.getDataset().nbAttributes() - 1);    Node tree = builder.build(randomNumberGenerator, trainingData);    String[] prediction = TreeVisualizer.predictTrace(tree, testData, ATTRIBUTE_NAMES);    Assert.assertArrayEquals(new String[] { "outlook = rainy -> windy = TRUE -> no", "outlook = overcast -> yes", String.format("outlook = sunny -> (humidity = 90) >= 77%s5 -> no", DECIMAL_SEPARATOR) }, prediction);}
2598d941a2310dabcb1d84a3fbd3edca89907704d7a42016fa68c19fb9ce5ea5
testForestVisualize
public void testForestVisualize() throws Exception
{        NumericalNode root = new NumericalNode(2, 90, new Leaf(0), new CategoricalNode(0, new double[] { 0, 1, 2 }, new Node[] { new NumericalNode(1, 71, new Leaf(0), new Leaf(1)), new Leaf(1), new Leaf(0) }));    List<Node> trees = new ArrayList<>();    trees.add(root);        DecisionForest forest = new DecisionForest(trees);    String visualization = ForestVisualizer.toString(forest, trainingData.getDataset(), null);    assertTrue(("Tree[1]:\n2 < 90 : yes\n2 >= 90\n" + "|   0 = rainy\n" + "|   |   1 < 71 : yes\n" + "|   |   1 >= 71 : no\n" + "|   0 = sunny : no\n" + "|   0 = overcast : yes\n").equals(visualization) || ("Tree[1]:\n" + "2 < 90 : no\n" + "2 >= 90\n" + "|   0 = rainy\n" + "|   |   1 < 71 : no\n" + "|   |   1 >= 71 : yes\n" + "|   0 = overcast : yes\n" + "|   0 = sunny : no\n").equals(visualization));    visualization = ForestVisualizer.toString(forest, trainingData.getDataset(), ATTRIBUTE_NAMES);    assertTrue(("Tree[1]:\n" + "humidity < 90 : yes\n" + "humidity >= 90\n" + "|   outlook = rainy\n" + "|   |   temperature < 71 : yes\n" + "|   |   temperature >= 71 : no\n" + "|   outlook = sunny : no\n" + "|   outlook = overcast : yes\n").equals(visualization) || ("Tree[1]:\n" + "humidity < 90 : no\n" + "humidity >= 90\n" + "|   outlook = rainy\n" + "|   |   temperature < 71 : no\n" + "|   |   temperature >= 71 : yes\n" + "|   outlook = overcast : yes\n" + "|   outlook = sunny : no\n").equals(visualization));}
e86a0f154c1daa6dceae1e39a1140fbe78580ba188982a5c385ab4978353accc
testLeafless
public void testLeafless() throws Exception
{    List<Instance> instances = new ArrayList<>();    for (int i = 0; i < trainingData.size(); i++) {        if (trainingData.get(i).get(0) != 0.0d) {            instances.add(trainingData.get(i));        }    }    Data lessData = new Data(trainingData.getDataset(), instances);        DecisionTreeBuilder builder = new DecisionTreeBuilder();    builder.setM(trainingData.getDataset().nbAttributes() - 1);    builder.setMinSplitNum(0);    builder.setComplemented(false);    Node tree = builder.build(randomNumberGenerator, lessData);    String visualization = TreeVisualizer.toString(tree, trainingData.getDataset(), ATTRIBUTE_NAMES);    assertTrue((String.format("\noutlook = sunny\n" + "|   humidity < 77%s5 : yes\n" + "|   humidity >= 77%s5 : no\n" + "outlook = overcast : yes", DECIMAL_SEPARATOR, DECIMAL_SEPARATOR)).equals(visualization) || (String.format("\noutlook = overcast : yes\n" + "outlook = sunny\n" + "|   humidity < 77%s5 : yes\n" + "|   humidity >= 77%s5 : no", DECIMAL_SEPARATOR, DECIMAL_SEPARATOR)).equals(visualization));}
78a274d3e62b678bde84ffa04fce2257229222b9cdb81f0cda384c23968ba864
testEmpty
public void testEmpty() throws Exception
{    Data emptyData = new Data(trainingData.getDataset());        DecisionTreeBuilder builder = new DecisionTreeBuilder();    Node tree = builder.build(randomNumberGenerator, emptyData);    assertEquals(" : unknown", TreeVisualizer.toString(tree, trainingData.getDataset(), ATTRIBUTE_NAMES));}
ab73136823fb003f82207b765b12f0f001e60ae46c88899ad1d5589d4865a4b3
testAuc
public void testAuc()
{    Auc auc = new Auc();    Random gen = RandomUtils.getRandom();    auc.setProbabilityScore(false);    for (int i = 0; i < 100000; i++) {        auc.add(0, gen.nextGaussian());        auc.add(1, gen.nextGaussian() + 1);    }    assertEquals(0.76, auc.auc(), 0.01);}
0a7cadf5865eb21d2fcbabb211de23b6275fe30d1a6c0a224500dd24a5a40c0b
testTies
public void testTies()
{    Auc auc = new Auc();    Random gen = RandomUtils.getRandom();    auc.setProbabilityScore(false);    for (int i = 0; i < 100000; i++) {        auc.add(0, gen.nextGaussian());        auc.add(1, gen.nextGaussian() + 1);    }        auc.add(0, 5.0);    auc.add(0, 5.0);    auc.add(0, 5.0);    auc.add(0, 5.0);    auc.add(1, 5.0);    auc.add(1, 5.0);    auc.add(1, 5.0);    assertEquals(0.76, auc.auc(), 0.05);}
5902b8a202d82b325224a6ef3e8271e7d4ebf49e0411feb3d29cd8d963338138
testEntropy
public void testEntropy()
{    Auc auc = new Auc();    Random gen = RandomUtils.getRandom();    Normal n0 = new Normal(-1, 1, gen);    Normal n1 = new Normal(1, 1, gen);    for (int i = 0; i < 100000; i++) {        double score = n0.nextDouble();        double p = n1.pdf(score) / (n0.pdf(score) + n1.pdf(score));        auc.add(0, p);        score = n1.nextDouble();        p = n1.pdf(score) / (n0.pdf(score) + n1.pdf(score));        auc.add(1, p);    }    Matrix m = auc.entropy();    assertEquals(-0.35, m.get(0, 0), 0.02);    assertEquals(-2.36, m.get(0, 1), 0.02);    assertEquals(-2.36, m.get(1, 0), 0.02);    assertEquals(-0.35, m.get(1, 1), 0.02);}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    super.setUp();    NaiveBayesModel model = createComplementaryNaiveBayesModel();    classifier = new ComplementaryNaiveBayesClassifier(model);}
7295ec7bbd6edca1e856bcb19fd763adae0432fdb0f4177804f728f1b143222b
testNaiveBayes
public void testNaiveBayes() throws Exception
{    assertEquals(4, classifier.numCategories());    assertEquals(0, maxIndex(classifier.classifyFull(new DenseVector(new double[] { 1.0, 0.0, 0.0, 0.0 }))));    assertEquals(1, maxIndex(classifier.classifyFull(new DenseVector(new double[] { 0.0, 1.0, 0.0, 0.0 }))));    assertEquals(2, maxIndex(classifier.classifyFull(new DenseVector(new double[] { 0.0, 0.0, 1.0, 0.0 }))));    assertEquals(3, maxIndex(classifier.classifyFull(new DenseVector(new double[] { 0.0, 0.0, 0.0, 1.0 }))));}
c5e9470f3b7e4ab4abf0c97de989a8be66ddd82edd2f2c85c0b75e14b0db661a
testRandomModelGeneration
public void testRandomModelGeneration()
{        NaiveBayesModel standardModel = getStandardModel();        standardModel.validate();        NaiveBayesModel complementaryModel = getComplementaryModel();    complementaryModel.validate();}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    super.setUp();    conf = getConfiguration();    inputFile = getTestTempFile("trainingInstances.seq");    outputDir = getTestTempDir("output");    outputDir.delete();    tempDir = getTestTempDir("tmp");    SequenceFile.Writer writer = new SequenceFile.Writer(FileSystem.get(conf), conf, new Path(inputFile.getAbsolutePath()), Text.class, VectorWritable.class);    try {        writer.append(LABEL_STOLEN, trainingInstance(COLOR_RED, TYPE_SPORTS, ORIGIN_DOMESTIC));        writer.append(LABEL_NOT_STOLEN, trainingInstance(COLOR_RED, TYPE_SPORTS, ORIGIN_DOMESTIC));        writer.append(LABEL_STOLEN, trainingInstance(COLOR_RED, TYPE_SPORTS, ORIGIN_DOMESTIC));        writer.append(LABEL_NOT_STOLEN, trainingInstance(COLOR_YELLOW, TYPE_SPORTS, ORIGIN_DOMESTIC));        writer.append(LABEL_STOLEN, trainingInstance(COLOR_YELLOW, TYPE_SPORTS, ORIGIN_IMPORTED));        writer.append(LABEL_NOT_STOLEN, trainingInstance(COLOR_YELLOW, TYPE_SUV, ORIGIN_IMPORTED));        writer.append(LABEL_STOLEN, trainingInstance(COLOR_YELLOW, TYPE_SUV, ORIGIN_IMPORTED));        writer.append(LABEL_NOT_STOLEN, trainingInstance(COLOR_YELLOW, TYPE_SUV, ORIGIN_DOMESTIC));        writer.append(LABEL_NOT_STOLEN, trainingInstance(COLOR_RED, TYPE_SUV, ORIGIN_IMPORTED));        writer.append(LABEL_STOLEN, trainingInstance(COLOR_RED, TYPE_SPORTS, ORIGIN_IMPORTED));    } finally {        Closeables.close(writer, false);    }}
920942d4248b18d6f470bdd55e39ff19f8650d3ddcf94bd404f61eb8ccfbf8df
toyData
public void toyData() throws Exception
{    TrainNaiveBayesJob trainNaiveBayes = new TrainNaiveBayesJob();    trainNaiveBayes.setConf(conf);    trainNaiveBayes.run(new String[] { "--input", inputFile.getAbsolutePath(), "--output", outputDir.getAbsolutePath(), "--tempDir", tempDir.getAbsolutePath() });    NaiveBayesModel naiveBayesModel = NaiveBayesModel.materialize(new Path(outputDir.getAbsolutePath()), conf);    AbstractVectorClassifier classifier = new StandardNaiveBayesClassifier(naiveBayesModel);    assertEquals(2, classifier.numCategories());    Vector prediction = classifier.classifyFull(trainingInstance(COLOR_RED, TYPE_SUV, ORIGIN_DOMESTIC).get());        assertTrue(prediction.get(0) < prediction.get(1));}
6f72dc901f108a09c3e869bd23f7caca11334aa1e72c015544896c7fbc3bb54b
toyDataComplementary
public void toyDataComplementary() throws Exception
{    TrainNaiveBayesJob trainNaiveBayes = new TrainNaiveBayesJob();    trainNaiveBayes.setConf(conf);    trainNaiveBayes.run(new String[] { "--input", inputFile.getAbsolutePath(), "--output", outputDir.getAbsolutePath(), "--trainComplementary", "--tempDir", tempDir.getAbsolutePath() });    NaiveBayesModel naiveBayesModel = NaiveBayesModel.materialize(new Path(outputDir.getAbsolutePath()), conf);    AbstractVectorClassifier classifier = new ComplementaryNaiveBayesClassifier(naiveBayesModel);    assertEquals(2, classifier.numCategories());    Vector prediction = classifier.classifyFull(trainingInstance(COLOR_RED, TYPE_SUV, ORIGIN_DOMESTIC).get());        assertTrue(prediction.get(0) < prediction.get(1));}
197d23304ecddd83b6599fb1345493ba71a6b798f59b8551cea0cae2de9df985
trainingInstance
 static VectorWritable trainingInstance(Vector.Element... elems)
{    DenseVector trainingInstance = new DenseVector(6);    for (Vector.Element elem : elems) {        trainingInstance.set(elem.index(), elem.get());    }    return new VectorWritable(trainingInstance);}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    super.setUp();    standardModel = createStandardNaiveBayesModel();    standardModel.validate();    complementaryModel = createComplementaryNaiveBayesModel();    complementaryModel.validate();}
a8b8f8da2add4cb73710df031fd0475bdcbc0e64cdbdece219f14177dc2333b6
getStandardModel
protected NaiveBayesModel getStandardModel()
{    return standardModel;}
b122c17feef1b22a2ff389d84640db4a55858f51fb35fbc6643a53509eab77da
getComplementaryModel
protected NaiveBayesModel getComplementaryModel()
{    return complementaryModel;}
0dfc03653140bc0f1224bcb836f015194e2f55a73b959a9772801db44a2a2dd9
complementaryNaiveBayesThetaWeight
protected static double complementaryNaiveBayesThetaWeight(int label, Matrix weightMatrix, Vector labelSum, Vector featureSum)
{    double weight = 0.0;    double alpha = 1.0;    for (int i = 0; i < featureSum.size(); i++) {        double score = weightMatrix.get(i, label);        double lSum = labelSum.get(label);        double fSum = featureSum.get(i);        double totalSum = featureSum.zSum();        double numerator = fSum - score + alpha;        double denominator = totalSum - lSum + featureSum.size();        weight += Math.abs(Math.log(numerator / denominator));    }    return weight;}
a7baae5cdba958b81032b4bd30cbbefbadd287fcb94b1c10cf1d08bb45c69bff
naiveBayesThetaWeight
protected static double naiveBayesThetaWeight(int label, Matrix weightMatrix, Vector labelSum, Vector featureSum)
{    double weight = 0.0;    double alpha = 1.0;    for (int feature = 0; feature < featureSum.size(); feature++) {        double score = weightMatrix.get(feature, label);        double lSum = labelSum.get(label);        double numerator = score + alpha;        double denominator = lSum + featureSum.size();        weight += Math.abs(Math.log(numerator / denominator));    }    return weight;}
8221675835ab1cd32d31968f8e44cec9131ba1d3ae61c605833740f10a1045e0
createStandardNaiveBayesModel
protected static NaiveBayesModel createStandardNaiveBayesModel()
{    double[][] matrix = { { 0.7, 0.1, 0.1, 0.3 }, { 0.4, 0.4, 0.1, 0.1 }, { 0.1, 0.0, 0.8, 0.1 }, { 0.1, 0.1, 0.1, 0.7 } };    double[] labelSumArray = { 1.2, 1.0, 1.0, 1.0 };    double[] featureSumArray = { 1.3, 0.6, 1.1, 1.2 };    DenseMatrix weightMatrix = new DenseMatrix(matrix);    DenseVector labelSum = new DenseVector(labelSumArray);    DenseVector featureSum = new DenseVector(featureSumArray);        return new NaiveBayesModel(weightMatrix, featureSum, labelSum, null, 1.0f, false);}
33c5cccb5eb73d9e90c4b8bc5e2426b59ebf373c20d1223fe2d967490831e6de
createComplementaryNaiveBayesModel
protected static NaiveBayesModel createComplementaryNaiveBayesModel()
{    double[][] matrix = { { 0.7, 0.1, 0.1, 0.3 }, { 0.4, 0.4, 0.1, 0.1 }, { 0.1, 0.0, 0.8, 0.1 }, { 0.1, 0.1, 0.1, 0.7 } };    double[] labelSumArray = { 1.2, 1.0, 1.0, 1.0 };    double[] featureSumArray = { 1.3, 0.6, 1.1, 1.2 };    DenseMatrix weightMatrix = new DenseMatrix(matrix);    DenseVector labelSum = new DenseVector(labelSumArray);    DenseVector featureSum = new DenseVector(featureSumArray);    double[] thetaNormalizerSum = { complementaryNaiveBayesThetaWeight(0, weightMatrix, labelSum, featureSum), complementaryNaiveBayesThetaWeight(1, weightMatrix, labelSum, featureSum), complementaryNaiveBayesThetaWeight(2, weightMatrix, labelSum, featureSum), complementaryNaiveBayesThetaWeight(3, weightMatrix, labelSum, featureSum) };        return new NaiveBayesModel(weightMatrix, featureSum, labelSum, new DenseVector(thetaNormalizerSum), 1.0f, true);}
3c7cd461bb306cc965c6c309e8e0b6c0750c8db2d89a63940d7106d4d089364f
maxIndex
protected static int maxIndex(Vector instance)
{    int maxIndex = -1;    double maxScore = Integer.MIN_VALUE;    for (Element label : instance.all()) {        if (label.get() >= maxScore) {            maxIndex = label.index();            maxScore = label.get();        }    }    return maxIndex;}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    super.setUp();    NaiveBayesModel model = createStandardNaiveBayesModel();    classifier = new StandardNaiveBayesClassifier(model);}
7295ec7bbd6edca1e856bcb19fd763adae0432fdb0f4177804f728f1b143222b
testNaiveBayes
public void testNaiveBayes() throws Exception
{    assertEquals(4, classifier.numCategories());    assertEquals(0, maxIndex(classifier.classifyFull(new DenseVector(new double[] { 1.0, 0.0, 0.0, 0.0 }))));    assertEquals(1, maxIndex(classifier.classifyFull(new DenseVector(new double[] { 0.0, 1.0, 0.0, 0.0 }))));    assertEquals(2, maxIndex(classifier.classifyFull(new DenseVector(new double[] { 0.0, 0.0, 1.0, 0.0 }))));    assertEquals(3, maxIndex(classifier.classifyFull(new DenseVector(new double[] { 0.0, 0.0, 0.0, 1.0 }))));}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    super.setUp();    ctx = EasyMock.createMock(Mapper.Context.class);    instance = new VectorWritable(new DenseVector(new double[] { 1, 0, 1, 1, 0 }));    labelIndex = new OpenObjectIntHashMap<>();    labelIndex.put("bird", 0);    labelIndex.put("cat", 1);}
e69aacf1a95c8735e5911cb1af25b23adc0bad0cc0aeff5e8f51136e03263e9c
index
public void index() throws Exception
{    ctx.write(new IntWritable(0), instance);    EasyMock.replay(ctx);    IndexInstancesMapper indexInstances = new IndexInstancesMapper();    setField(indexInstances, "labelIndex", labelIndex);    indexInstances.map(new Text("/bird/"), instance, ctx);    EasyMock.verify(ctx);}
2675517f2d57681d12726b0010d5a52bc8844192cc2eccb07b8e5b6dbdc2d0e7
skip
public void skip() throws Exception
{    Counter skippedInstances = EasyMock.createMock(Counter.class);    EasyMock.expect(ctx.getCounter(IndexInstancesMapper.Counter.SKIPPED_INSTANCES)).andReturn(skippedInstances);    skippedInstances.increment(1);    EasyMock.replay(ctx, skippedInstances);    IndexInstancesMapper indexInstances = new IndexInstancesMapper();    setField(indexInstances, "labelIndex", labelIndex);    indexInstances.map(new Text("/fish/"), instance, ctx);    EasyMock.verify(ctx, skippedInstances);}
33e7eeecc4c23981e69186256e3a8bf876ba0e31126f6888f4889f7e9ae84f02
standard
public void standard() throws Exception
{    Mapper.Context ctx = EasyMock.createMock(Mapper.Context.class);    ComplementaryThetaTrainer trainer = EasyMock.createMock(ComplementaryThetaTrainer.class);    Vector instance1 = new DenseVector(new double[] { 1, 2, 3 });    Vector instance2 = new DenseVector(new double[] { 4, 5, 6 });    Vector perLabelThetaNormalizer = new DenseVector(new double[] { 7, 8 });    ThetaMapper thetaMapper = new ThetaMapper();    setField(thetaMapper, "trainer", trainer);    trainer.train(0, instance1);    trainer.train(1, instance2);    EasyMock.expect(trainer.retrievePerLabelThetaNormalizer()).andReturn(perLabelThetaNormalizer);    ctx.write(new Text(TrainNaiveBayesJob.LABEL_THETA_NORMALIZER), new VectorWritable(perLabelThetaNormalizer));    EasyMock.replay(ctx, trainer);    thetaMapper.map(new IntWritable(0), new VectorWritable(instance1), ctx);    thetaMapper.map(new IntWritable(1), new VectorWritable(instance2), ctx);    thetaMapper.cleanup(ctx);    EasyMock.verify(ctx, trainer);}
e241619dc5d4b4e0bb75a5627dcc05f005ec65ae72c7a12ff08399ffa1f3e37b
scores
public void scores() throws Exception
{    Mapper.Context ctx = EasyMock.createMock(Mapper.Context.class);    Vector instance1 = new DenseVector(new double[] { 1, 0, 0.5, 0.5, 0 });    Vector instance2 = new DenseVector(new double[] { 0, 0.5, 0, 0, 0 });    Vector instance3 = new DenseVector(new double[] { 1, 0.5, 1, 1.5, 1 });    Vector weightsPerLabel = new DenseVector(new double[] { 0, 0 });    ctx.write(new Text(TrainNaiveBayesJob.WEIGHTS_PER_FEATURE), new VectorWritable(new DenseVector(new double[] { 2, 1, 1.5, 2, 1 })));    ctx.write(new Text(TrainNaiveBayesJob.WEIGHTS_PER_LABEL), new VectorWritable(new DenseVector(new double[] { 2.5, 5 })));    EasyMock.replay(ctx);    WeightsMapper weights = new WeightsMapper();    setField(weights, "weightsPerLabel", weightsPerLabel);    weights.map(new IntWritable(0), new VectorWritable(instance1), ctx);    weights.map(new IntWritable(0), new VectorWritable(instance2), ctx);    weights.map(new IntWritable(1), new VectorWritable(instance3), ctx);    weights.cleanup(ctx);    EasyMock.verify(ctx);}
edfc99b7b0b3dae54ed09940474ed3ca0ff99fd36610129a2451bf5b10ee4dd2
parseAnalysis
private static double[] parseAnalysis(CharSequence analysis)
{    double[] results = new double[3];    Matcher m = p1.matcher(analysis);    if (m.find()) {        results[0] = Double.parseDouble(m.group(1));    } else {        return null;    }    m = p2.matcher(analysis);    if (m.find()) {        results[1] = Double.parseDouble(m.group(1));    } else {        return null;    }    m = p3.matcher(analysis);    if (m.find()) {        results[2] = Double.parseDouble(m.group(1));    } else {        return null;    }    return results;}
311d5981d56595d07d62e24e72e5abfe1ed4bb6de706b1845310d5784cf78ee5
parseAnalysisCount
private static int[] parseAnalysisCount(CharSequence analysis)
{    int[] results = new int[3];    Matcher m = p4.matcher(analysis);    if (m.find()) {        results[0] = Integer.parseInt(m.group(1));    }    m = p5.matcher(analysis);    if (m.find()) {        results[1] = Integer.parseInt(m.group(1));    }    m = p6.matcher(analysis);    if (m.find()) {        results[2] = Integer.parseInt(m.group(1));    }    return results;}
0dc9b89016a06963f757011428b648b0894104f804ad8a3ea237d47ac6575fee
testAnalyze
public void testAnalyze()
{    double[][] results = new double[10][2];    for (int i = 0; i < results.length; i++) {        results[i][0] = i;        results[i][1] = i + 1;    }    RegressionResultAnalyzer analyzer = new RegressionResultAnalyzer();    analyzer.setInstances(results);    String analysis = analyzer.toString();    assertArrayEquals(new double[] { 1.0, 1.0, 1.0 }, parseAnalysis(analysis), 0);    for (int i = 0; i < results.length; i++) {        results[i][1] = Math.sqrt(i);    }    analyzer = new RegressionResultAnalyzer();    analyzer.setInstances(results);    analysis = analyzer.toString();    assertArrayEquals(new double[] { 0.9573, 2.5694, 3.2848 }, parseAnalysis(analysis), 0);    for (int i = 0; i < results.length; i++) {        results[i][0] = results.length - i;    }    analyzer = new RegressionResultAnalyzer();    analyzer.setInstances(results);    analysis = analyzer.toString();    assertArrayEquals(new double[] { -0.9573, 4.1351, 5.1573 }, parseAnalysis(analysis), 0);}
ce6b13228d421d7594203e21be79bf848ad38ca0014cf914f9a5bdbae3cf42d2
testUnpredictable
public void testUnpredictable()
{    double[][] results = new double[10][2];    for (int i = 0; i < results.length; i++) {        results[i][0] = i;        results[i][1] = Double.NaN;    }    RegressionResultAnalyzer analyzer = new RegressionResultAnalyzer();    analyzer.setInstances(results);    String analysis = analyzer.toString();    assertNull(parseAnalysis(analysis));    assertArrayEquals(new int[] { 0, 10, 10 }, parseAnalysisCount(analysis));    for (int i = 0; i < results.length - 3; i++) {        results[i][1] = Math.sqrt(i);    }    analyzer = new RegressionResultAnalyzer();    analyzer.setInstances(results);    analysis = analyzer.toString();    assertArrayEquals(new double[] { 0.9552, 1.4526, 1.9345 }, parseAnalysis(analysis), 0);    assertArrayEquals(new int[] { 7, 3, 10 }, parseAnalysisCount(analysis));}
b7d2dc4713a86999ba18565c0a45c56dbdec2ca4b7f6766a880f2d9e3151a3f2
testForwardAlgorithm
public void testForwardAlgorithm()
{        double[][] alphaExpectedA = { { 0.02, 0.0392, 0.002438, 0.00035456, 0.0011554672, 7.158497e-04, 4.614927e-05 }, { 0.01, 0.0054, 0.001824, 0.00069486, 0.0007586904, 2.514137e-04, 1.721505e-05 }, { 0.32, 0.0262, 0.002542, 0.00038026, 0.0001360234, 3.002345e-05, 9.659608e-05 }, { 0.03, 0.0000, 0.013428, 0.00951084, 0.0000000000, 0.000000e+00, 2.428986e-05 } };        Matrix alpha = HmmAlgorithms.forwardAlgorithm(getModel(), getSequence(), false);        assertNotNull(alpha);    assertEquals(4, alpha.numCols());    assertEquals(7, alpha.numRows());        for (int i = 0; i < 4; ++i) {        for (int j = 0; j < 7; ++j) {            assertEquals(alphaExpectedA[i][j], alpha.get(j, i), EPSILON);        }    }}
68fbe1564f89b49ae85a4d691e075b2838f1de0665e3c2a38de95591877ff8d9
testLogScaledForwardAlgorithm
public void testLogScaledForwardAlgorithm()
{        double[][] alphaExpectedA = { { 0.02, 0.0392, 0.002438, 0.00035456, 0.0011554672, 7.158497e-04, 4.614927e-05 }, { 0.01, 0.0054, 0.001824, 0.00069486, 0.0007586904, 2.514137e-04, 1.721505e-05 }, { 0.32, 0.0262, 0.002542, 0.00038026, 0.0001360234, 3.002345e-05, 9.659608e-05 }, { 0.03, 0.0000, 0.013428, 0.00951084, 0.0000000000, 0.000000e+00, 2.428986e-05 } };        Matrix alpha = HmmAlgorithms.forwardAlgorithm(getModel(), getSequence(), true);        assertNotNull(alpha);    assertEquals(4, alpha.numCols());    assertEquals(7, alpha.numRows());        for (int i = 0; i < 4; ++i) {        for (int j = 0; j < 7; ++j) {            assertEquals(Math.log(alphaExpectedA[i][j]), alpha.get(j, i), EPSILON);        }    }}
2b8bfbf19881885a13336e0c96e7692d5c029e8aabdd3548d730370ea5fdf338
testBackwardAlgorithm
public void testBackwardAlgorithm()
{        double[][] betaExpectedA = { { 0.0015730559, 0.003543656, 0.00738264, 0.040692, 0.0848, 0.17, 1 }, { 0.0017191865, 0.002386795, 0.00923652, 0.052232, 0.1018, 0.17, 1 }, { 0.0003825772, 0.001238558, 0.00259464, 0.012096, 0.0664, 0.66, 1 }, { 0.0004390858, 0.007076994, 0.01063512, 0.013556, 0.0304, 0.17, 1 } };        Matrix beta = HmmAlgorithms.backwardAlgorithm(getModel(), getSequence(), false);        assertNotNull(beta);    assertEquals(4, beta.numCols());    assertEquals(7, beta.numRows());        for (int i = 0; i < 4; ++i) {        for (int j = 0; j < 7; ++j) {            assertEquals(betaExpectedA[i][j], beta.get(j, i), EPSILON);        }    }}
b3c1f336f9e30846fcc81711faed61225d9f1eaad32fe9bd34901ae62444e901
testLogScaledBackwardAlgorithm
public void testLogScaledBackwardAlgorithm()
{        double[][] betaExpectedA = { { 0.0015730559, 0.003543656, 0.00738264, 0.040692, 0.0848, 0.17, 1 }, { 0.0017191865, 0.002386795, 0.00923652, 0.052232, 0.1018, 0.17, 1 }, { 0.0003825772, 0.001238558, 0.00259464, 0.012096, 0.0664, 0.66, 1 }, { 0.0004390858, 0.007076994, 0.01063512, 0.013556, 0.0304, 0.17, 1 } };        Matrix beta = HmmAlgorithms.backwardAlgorithm(getModel(), getSequence(), true);        assertNotNull(beta);    assertEquals(4, beta.numCols());    assertEquals(7, beta.numRows());        for (int i = 0; i < 4; ++i) {        for (int j = 0; j < 7; ++j) {            assertEquals(Math.log(betaExpectedA[i][j]), beta.get(j, i), EPSILON);        }    }}
c0abf0424669b287b20230d654f82d5031cc7f3ca863052475d356fe57405545
testViterbiAlgorithm
public void testViterbiAlgorithm()
{        int[] expected = { 2, 0, 3, 3, 0, 0, 2 };        int[] computed = HmmAlgorithms.viterbiAlgorithm(getModel(), getSequence(), false);        assertNotNull(computed);    assertEquals(computed.length, getSequence().length);        for (int i = 0; i < getSequence().length; ++i) {        assertEquals(expected[i], computed[i]);    }}
8aa60bad553c015ed27841f04bfdacaa74e3ec685c565a51715dac57b7cd4579
testLogScaledViterbiAlgorithm
public void testLogScaledViterbiAlgorithm()
{        int[] expected = { 2, 0, 3, 3, 0, 0, 2 };        int[] computed = HmmAlgorithms.viterbiAlgorithm(getModel(), getSequence(), true);        assertNotNull(computed);    assertEquals(computed.length, getSequence().length);        for (int i = 0; i < getSequence().length; ++i) {        assertEquals(expected[i], computed[i]);    }}
1d391d6d03f445fb4475080156dde9362fc98b757ea1846acf344c344dd52e05
testModelLikelihood
public void testModelLikelihood()
{        Matrix alpha = HmmAlgorithms.forwardAlgorithm(getModel(), getSequence(), false);    Matrix beta = HmmAlgorithms.backwardAlgorithm(getModel(), getSequence(), false);        double forwardLikelihood = HmmEvaluator.modelLikelihood(alpha, false);    double backwardLikelihood = HmmEvaluator.modelLikelihood(getModel(), getSequence(), beta, false);    assertEquals(forwardLikelihood, backwardLikelihood, EPSILON);        assertEquals(1.8425e-4, forwardLikelihood, EPSILON);}
c7cf03db67b47b50cb525c3e645bd2195175aa13cb82d193a0309c0ec2777275
testScaledModelLikelihood
public void testScaledModelLikelihood()
{        Matrix alpha = HmmAlgorithms.forwardAlgorithm(getModel(), getSequence(), true);    Matrix beta = HmmAlgorithms.backwardAlgorithm(getModel(), getSequence(), true);        double forwardLikelihood = HmmEvaluator.modelLikelihood(alpha, true);    double backwardLikelihood = HmmEvaluator.modelLikelihood(getModel(), getSequence(), beta, true);    assertEquals(forwardLikelihood, backwardLikelihood, EPSILON);        assertEquals(1.8425e-4, forwardLikelihood, EPSILON);}
c5e9470f3b7e4ab4abf0c97de989a8be66ddd82edd2f2c85c0b75e14b0db661a
testRandomModelGeneration
public void testRandomModelGeneration()
{        HmmModel model = new HmmModel(10, 20);        HmmUtils.validate(model);}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    super.setUp();        String[] hiddenNames = { "H0", "H1", "H2", "H3" };    String[] outputNames = { "O0", "O1", "O2" };        double[][] transitionP = { { 0.5, 0.1, 0.1, 0.3 }, { 0.4, 0.4, 0.1, 0.1 }, { 0.1, 0.0, 0.8, 0.1 }, { 0.1, 0.1, 0.1, 0.7 } };        double[][] emissionP = { { 0.8, 0.1, 0.1 }, { 0.6, 0.1, 0.3 }, { 0.1, 0.8, 0.1 }, { 0.0, 0.1, 0.9 } };        double[] initialP = { 0.2, 0.1, 0.4, 0.3 };        model = new HmmModel(new DenseMatrix(transitionP), new DenseMatrix(emissionP), new DenseVector(initialP));    model.registerHiddenStateNames(hiddenNames);    model.registerOutputStateNames(outputNames);        HmmUtils.validate(model);}
620f31a00a9ae0b64d0324b98df4c71da1ddc99119de8da5bcddf1afad9bb7ef
getModel
protected HmmModel getModel()
{    return model;}
6c98882734fa430c3d4be266c04cd3e7595c13f8def42e63f0aeead6a91d3b9f
getSequence
protected int[] getSequence()
{    return sequence;}
e6337ffdaac4ee15c7462d7aa845c17dfea02087f91a8aa8b6c5439832b5a775
testViterbiTraining
public void testViterbiTraining()
{            double[][] transitionE = { { 0.3125, 0.0625, 0.3125, 0.3125 }, { 0.25, 0.25, 0.25, 0.25 }, { 0.5, 0.071429, 0.357143, 0.071429 }, { 0.5, 0.1, 0.1, 0.3 } };        double[][] emissionE = { { 0.882353, 0.058824, 0.058824 }, { 0.333333, 0.333333, 0.3333333 }, { 0.076923, 0.846154, 0.076923 }, { 0.111111, 0.111111, 0.777778 } };        int[] observed = { 1, 0, 2, 2, 0, 0, 1, 1, 1, 0, 2, 0, 1, 0, 0 };    HmmModel trained = HmmTrainer.trainViterbi(getModel(), observed, 0.5, 0.1, 10, false);        Matrix emissionMatrix = trained.getEmissionMatrix();    Matrix transitionMatrix = trained.getTransitionMatrix();    for (int i = 0; i < trained.getNrOfHiddenStates(); ++i) {        for (int j = 0; j < trained.getNrOfHiddenStates(); ++j) {            assertEquals(transitionMatrix.getQuick(i, j), transitionE[i][j], EPSILON);        }        for (int j = 0; j < trained.getNrOfOutputStates(); ++j) {            assertEquals(emissionMatrix.getQuick(i, j), emissionE[i][j], EPSILON);        }    }}
f9328678804cece915239fcbd9bd6ffaa9c65b701b6f7dedf298c19b2443afc9
testScaledViterbiTraining
public void testScaledViterbiTraining()
{            double[][] transitionE = { { 0.3125, 0.0625, 0.3125, 0.3125 }, { 0.25, 0.25, 0.25, 0.25 }, { 0.5, 0.071429, 0.357143, 0.071429 }, { 0.5, 0.1, 0.1, 0.3 } };        double[][] emissionE = { { 0.882353, 0.058824, 0.058824 }, { 0.333333, 0.333333, 0.3333333 }, { 0.076923, 0.846154, 0.076923 }, { 0.111111, 0.111111, 0.777778 } };        int[] observed = { 1, 0, 2, 2, 0, 0, 1, 1, 1, 0, 2, 0, 1, 0, 0 };    HmmModel trained = HmmTrainer.trainViterbi(getModel(), observed, 0.5, 0.1, 10, true);        Matrix emissionMatrix = trained.getEmissionMatrix();    Matrix transitionMatrix = trained.getTransitionMatrix();    for (int i = 0; i < trained.getNrOfHiddenStates(); ++i) {        for (int j = 0; j < trained.getNrOfHiddenStates(); ++j) {            assertEquals(transitionMatrix.getQuick(i, j), transitionE[i][j], EPSILON);        }        for (int j = 0; j < trained.getNrOfOutputStates(); ++j) {            assertEquals(emissionMatrix.getQuick(i, j), emissionE[i][j], EPSILON);        }    }}
c8566437acc8025edfbdf16c0c5cf3193d6fdd182944c4a8e697a4419fe9d2a7
testBaumWelchTraining
public void testBaumWelchTraining()
{        int[] observed = { 1, 0, 2, 2, 0, 0, 1, 1, 1, 0, 2, 0, 1, 0, 0 };        double[] initialExpected = { 0, 0, 1.0, 0 };    double[][] transitionExpected = { { 0.2319, 0.0993, 0.0005, 0.6683 }, { 0.0001, 0.3345, 0.6654, 0 }, { 0.5975, 0, 0.4025, 0 }, { 0.0024, 0.6657, 0, 0.3319 } };    double[][] emissionExpected = { { 0.9995, 0.0004, 0.0001 }, { 0.9943, 0.0036, 0.0021 }, { 0.0059, 0.9941, 0 }, { 0, 0, 1 } };    HmmModel trained = HmmTrainer.trainBaumWelch(getModel(), observed, 0.1, 10, false);    Vector initialProbabilities = trained.getInitialProbabilities();    Matrix emissionMatrix = trained.getEmissionMatrix();    Matrix transitionMatrix = trained.getTransitionMatrix();    for (int i = 0; i < trained.getNrOfHiddenStates(); ++i) {        assertEquals(initialProbabilities.get(i), initialExpected[i], 0.0001);        for (int j = 0; j < trained.getNrOfHiddenStates(); ++j) {            assertEquals(transitionMatrix.getQuick(i, j), transitionExpected[i][j], 0.0001);        }        for (int j = 0; j < trained.getNrOfOutputStates(); ++j) {            assertEquals(emissionMatrix.getQuick(i, j), emissionExpected[i][j], 0.0001);        }    }}
883794193391de63954e1c94ca5ae7a9f9817548610d8c95ecfbf7dd369daac4
testScaledBaumWelchTraining
public void testScaledBaumWelchTraining()
{        int[] observed = { 1, 0, 2, 2, 0, 0, 1, 1, 1, 0, 2, 0, 1, 0, 0 };        double[] initialExpected = { 0, 0, 1.0, 0 };    double[][] transitionExpected = { { 0.2319, 0.0993, 0.0005, 0.6683 }, { 0.0001, 0.3345, 0.6654, 0 }, { 0.5975, 0, 0.4025, 0 }, { 0.0024, 0.6657, 0, 0.3319 } };    double[][] emissionExpected = { { 0.9995, 0.0004, 0.0001 }, { 0.9943, 0.0036, 0.0021 }, { 0.0059, 0.9941, 0 }, { 0, 0, 1 } };    HmmModel trained = HmmTrainer.trainBaumWelch(getModel(), observed, 0.1, 10, true);    Vector initialProbabilities = trained.getInitialProbabilities();    Matrix emissionMatrix = trained.getEmissionMatrix();    Matrix transitionMatrix = trained.getTransitionMatrix();    for (int i = 0; i < trained.getNrOfHiddenStates(); ++i) {        assertEquals(initialProbabilities.get(i), initialExpected[i], 0.0001);        for (int j = 0; j < trained.getNrOfHiddenStates(); ++j) {            assertEquals(transitionMatrix.getQuick(i, j), transitionExpected[i][j], 0.0001);        }        for (int j = 0; j < trained.getNrOfOutputStates(); ++j) {            assertEquals(emissionMatrix.getQuick(i, j), emissionExpected[i][j], 0.0001);        }    }}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    super.setUp();    legal22 = new DenseMatrix(new double[][] { { 0.5, 0.5 }, { 0.3, 0.7 } });    legal23 = new DenseMatrix(new double[][] { { 0.2, 0.2, 0.6 }, { 0.3, 0.3, 0.4 } });    legal33 = new DenseMatrix(new double[][] { { 0.1, 0.1, 0.8 }, { 0.1, 0.2, 0.7 }, { 0.2, 0.3, 0.5 } });    legal2 = new DenseVector(new double[] { 0.4, 0.6 });    illegal22 = new DenseMatrix(new double[][] { { 1, 2 }, { 3, 4 } });}
a63ba714333d45849f5eb0d656a6d93c42b9f0959a53a086b7c75ed620ed2739
testValidatorLegal
public void testValidatorLegal()
{    HmmUtils.validate(new HmmModel(legal22, legal23, legal2));}
3f8ffff15039ff4086a72c08800dcc050c0f6ddcc850bf77be7d2a21a5d75bb5
testValidatorDimensionError
public void testValidatorDimensionError()
{    try {        HmmUtils.validate(new HmmModel(legal33, legal23, legal2));    } catch (IllegalArgumentException e) {                return;    }    fail();}
eca62e32bdc3e35a06418df63773f8dc0418d0cf44f745a5d0574c7c04b0de79
testValidatorIllegelMatrixError
public void testValidatorIllegelMatrixError()
{    try {        HmmUtils.validate(new HmmModel(illegal22, legal23, legal2));    } catch (IllegalArgumentException e) {                return;    }    fail();}
8375322a1cd55409b71424bbfe6f97df6ee0dbc6b7e749877f462007568cab05
testEncodeStateSequence
public void testEncodeStateSequence()
{    String[] hiddenSequence = { "H1", "H2", "H0", "H3", "H4" };    String[] outputSequence = { "O1", "O2", "O4", "O0" };        int[] hiddenSequenceEnc = HmmUtils.encodeStateSequence(getModel(), Arrays.asList(hiddenSequence), false, -1);    int[] outputSequenceEnc = HmmUtils.encodeStateSequence(getModel(), Arrays.asList(outputSequence), true, -1);        int[] hiddenSequenceExp = { 1, 2, 0, 3, -1 };    int[] outputSequenceExp = { 1, 2, -1, 0 };        for (int i = 0; i < hiddenSequenceEnc.length; ++i) {        assertEquals(hiddenSequenceExp[i], hiddenSequenceEnc[i]);    }    for (int i = 0; i < outputSequenceEnc.length; ++i) {        assertEquals(outputSequenceExp[i], outputSequenceEnc[i]);    }}
1aff7f85490ce4fe0aa19cd89200da8e42a41d51c32a8c24bcf7b16fe788a896
testDecodeStateSequence
public void testDecodeStateSequence()
{    int[] hiddenSequence = { 1, 2, 0, 3, 10 };    int[] outputSequence = { 1, 2, 10, 0 };        List<String> hiddenSequenceDec = HmmUtils.decodeStateSequence(getModel(), hiddenSequence, false, "unknown");    List<String> outputSequenceDec = HmmUtils.decodeStateSequence(getModel(), outputSequence, true, "unknown");        String[] hiddenSequenceExp = { "H1", "H2", "H0", "H3", "unknown" };    String[] outputSequenceExp = { "O1", "O2", "unknown", "O0" };        for (int i = 0; i < hiddenSequenceExp.length; ++i) {        assertEquals(hiddenSequenceExp[i], hiddenSequenceDec.get(i));    }    for (int i = 0; i < outputSequenceExp.length; ++i) {        assertEquals(outputSequenceExp[i], outputSequenceDec.get(i));    }}
618d323060ef626be4f44a1c050318b5f670e4e4cc2820f6ef560de0f0c9fd47
testNormalizeModel
public void testNormalizeModel()
{    DenseVector ip = new DenseVector(new double[] { 10, 20 });    DenseMatrix tr = new DenseMatrix(new double[][] { { 10, 10 }, { 20, 25 } });    DenseMatrix em = new DenseMatrix(new double[][] { { 5, 7 }, { 10, 15 } });    HmmModel model = new HmmModel(tr, em, ip);    HmmUtils.normalizeModel(model);        HmmUtils.validate(model);}
9c40c6bfd4d9b0273556265772ead7a18e9cbcb5371fddbccc591e8da198d191
testTruncateModel
public void testTruncateModel()
{    DenseVector ip = new DenseVector(new double[] { 0.0001, 0.0001, 0.9998 });    DenseMatrix tr = new DenseMatrix(new double[][] { { 0.9998, 0.0001, 0.0001 }, { 0.0001, 0.9998, 0.0001 }, { 0.0001, 0.0001, 0.9998 } });    DenseMatrix em = new DenseMatrix(new double[][] { { 0.9998, 0.0001, 0.0001 }, { 0.0001, 0.9998, 0.0001 }, { 0.0001, 0.0001, 0.9998 } });    HmmModel model = new HmmModel(tr, em, ip);        HmmModel sparseModel = HmmUtils.truncateModel(model, 0.01);        HmmUtils.validate(sparseModel);        Vector sparse_ip = sparseModel.getInitialProbabilities();    Matrix sparse_tr = sparseModel.getTransitionMatrix();    Matrix sparse_em = sparseModel.getEmissionMatrix();    for (int i = 0; i < sparseModel.getNrOfHiddenStates(); ++i) {        assertEquals(i == 2 ? 1.0 : 0.0, sparse_ip.getQuick(i), EPSILON);        for (int j = 0; j < sparseModel.getNrOfHiddenStates(); ++j) {            if (i == j) {                assertEquals(1.0, sparse_tr.getQuick(i, j), EPSILON);                assertEquals(1.0, sparse_em.getQuick(i, j), EPSILON);            } else {                assertEquals(0.0, sparse_tr.getQuick(i, j), EPSILON);                assertEquals(0.0, sparse_em.getQuick(i, j), EPSILON);            }        }    }}
68c12ed792e0f4fe5813937719ac3e351cff75aed378615cf24c815c06d3ec27
testTrain
public void testTrain()
{    Random gen = RandomUtils.getRandom();    Exponential exp = new Exponential(0.5, gen);    Vector beta = new DenseVector(200);    for (Vector.Element element : beta.all()) {        int sign = 1;        if (gen.nextDouble() < 0.5) {            sign = -1;        }        element.set(sign * exp.nextDouble());    }    AdaptiveLogisticRegression.Wrapper cl = new AdaptiveLogisticRegression.Wrapper(2, 200, new L1());    cl.update(new double[] { 1.0e-5, 1 });    for (int i = 0; i < 10000; i++) {        AdaptiveLogisticRegression.TrainingExample r = getExample(i, gen, beta);        cl.train(r);        if (i % 1000 == 0) {            System.out.printf("%10d %10.3f\n", i, cl.getLearner().auc());        }    }    assertEquals(1, cl.getLearner().auc(), 0.1);    AdaptiveLogisticRegression adaptiveLogisticRegression = new AdaptiveLogisticRegression(2, 200, new L1());    adaptiveLogisticRegression.setInterval(1000);    for (int i = 0; i < 20000; i++) {        AdaptiveLogisticRegression.TrainingExample r = getExample(i, gen, beta);        adaptiveLogisticRegression.train(r.getKey(), r.getActual(), r.getInstance());        if (i % 1000 == 0 && adaptiveLogisticRegression.getBest() != null) {            System.out.printf("%10d %10.4f %10.8f %.3f\n", i, adaptiveLogisticRegression.auc(), Math.log10(adaptiveLogisticRegression.getBest().getMappedParams()[0]), adaptiveLogisticRegression.getBest().getMappedParams()[1]);        }    }    assertEquals(1, adaptiveLogisticRegression.auc(), 0.1);    adaptiveLogisticRegression.close();}
edfd0b356b9c81959e8d3f84dd502ded09fdb41da914e07b0fe1d5c2d33f5855
getExample
private static AdaptiveLogisticRegression.TrainingExample getExample(int i, Random gen, Vector beta)
{    Vector data = new DenseVector(200);    for (Vector.Element element : data.all()) {        element.set(gen.nextDouble() < 0.3 ? 1 : 0);    }    double p = 1 / (1 + Math.exp(1.5 - data.dot(beta)));    int target = 0;    if (gen.nextDouble() < p) {        target = 1;    }    return new AdaptiveLogisticRegression.TrainingExample(i, null, target, data);}
17c6dcb293f5db60088c05e4d804ee4c6e9fe6ca95edf85c8f1ce0eaa28aa2e4
copyLearnsAsExpected
public void copyLearnsAsExpected()
{    Random gen = RandomUtils.getRandom();    Exponential exp = new Exponential(0.5, gen);    Vector beta = new DenseVector(200);    for (Vector.Element element : beta.all()) {        int sign = 1;        if (gen.nextDouble() < 0.5) {            sign = -1;        }        element.set(sign * exp.nextDouble());    }        AdaptiveLogisticRegression.Wrapper w = new AdaptiveLogisticRegression.Wrapper(2, 200, new L1());    for (int i = 0; i < 3000; i++) {        AdaptiveLogisticRegression.TrainingExample r = getExample(i, gen, beta);        w.train(r);        if (i % 1000 == 0) {            System.out.printf("%10d %.3f\n", i, w.getLearner().auc());        }    }    System.out.printf("%10d %.3f\n", 3000, w.getLearner().auc());    double auc1 = w.getLearner().auc();        AdaptiveLogisticRegression.Wrapper w2 = w.copy();    for (int i = 0; i < 5000; i++) {        if (i % 1000 == 0) {            if (i == 0) {                assertEquals("Should have started with no data", 0.5, w2.getLearner().auc(), 0.0001);            }            if (i == 1000) {                double auc2 = w2.getLearner().auc();                assertTrue("Should have had head-start", Math.abs(auc2 - 0.5) > 0.1);                assertTrue("AUC should improve quickly on copy", auc1 < auc2);            }            System.out.printf("%10d %.3f\n", i, w2.getLearner().auc());        }        AdaptiveLogisticRegression.TrainingExample r = getExample(i, gen, beta);        w2.train(r);    }    assertEquals("Original should not change after copy is updated", auc1, w.getLearner().auc(), 1.0e-5);        assertTrue("AUC should improve significantly on copy", auc1 < w2.getLearner().auc() - 0.05);        assertEquals(auc1, w.getLearner().auc(), 0);}
747993bbea93319b8c69bcd075ac24a77331459a31bb3b7d0f5ff966defab54d
stepSize
public void stepSize()
{    assertEquals(500, AdaptiveLogisticRegression.stepSize(15000, 2));    assertEquals(2000, AdaptiveLogisticRegression.stepSize(15000, 2.6));    assertEquals(5000, AdaptiveLogisticRegression.stepSize(24000, 2.6));    assertEquals(10000, AdaptiveLogisticRegression.stepSize(15000, 3));}
4c3b86c17eabdaf99ad860cbed732a75cebf257d94dae55b66a85dd99e95ac6d
constantStep
public void constantStep()
{    AdaptiveLogisticRegression lr = new AdaptiveLogisticRegression(2, 1000, new L1());    lr.setInterval(5000);    assertEquals(20000, lr.nextStep(15000));    assertEquals(20000, lr.nextStep(15001));    assertEquals(20000, lr.nextStep(16500));    assertEquals(20000, lr.nextStep(19999));    lr.close();}
20d3108b1d5b9686d6f4abf572ee0e7b1e6c98f0961d3d0f9ca3a0914f3e59b5
growingStep
public void growingStep()
{    AdaptiveLogisticRegression lr = new AdaptiveLogisticRegression(2, 1000, new L1());    lr.setInterval(2000, 10000);        for (int i = 2000; i < 20000; i += 2000) {        assertEquals(i + 2000, lr.nextStep(i));    }        for (int i = 20000; i < 50000; i += 5000) {        assertEquals(i + 5000, lr.nextStep(i));    }        for (int i = 50000; i < 500000; i += 10000) {        assertEquals(i + 10000, lr.nextStep(i));    }    lr.close();}
e19c1870143cc7c9baa2bae2c27657b5f4c865beb2b3d1039e63f1b83e3e9e47
testAddToVector
public void testAddToVector()
{    RecordFactory csv = new CsvRecordFactory("y", ImmutableMap.of("x1", "n", "x2", "w", "x3", "t"));    csv.firstLine("z,x1,y,x2,x3,q");    csv.maxTargetValue(2);    Vector v = new DenseVector(2000);    int t = csv.processLine("ignore,3.1,yes,tiger, \"this is text\",ignore", v);    assertEquals(0, t);        assertEquals(9.0, v.norm(0), 0);        assertEquals(3.1, v.maxValue(), 0);    v.set(v.maxValueIndex(), 0);    assertEquals(8.0, v.norm(0), 0);    assertEquals(8.0, v.norm(1), 0);    assertEquals(1.0, v.maxValue(), 0);    v.assign(0);    t = csv.processLine("ignore,5.3,no,line, \"and more text and more\",ignore", v);    assertEquals(1, t);        assertEquals(9.0, v.norm(0), 0);        assertEquals(5.3, v.maxValue(), 0);    v.set(v.maxValueIndex(), 0);    assertEquals(8.0, v.norm(0), 0);    assertEquals(10.339850002884626, v.norm(1), 1.0e-6);    assertEquals(1.5849625007211563, v.maxValue(), 1.0e-6);    v.assign(0);    t = csv.processLine("ignore,5.3,invalid,line, \"and more text and more\",ignore", v);    assertEquals(1, t);        assertEquals(9.0, v.norm(0), 0);        assertEquals(5.3, v.maxValue(), 0);    v.set(v.maxValueIndex(), 0);    assertEquals(8.0, v.norm(0), 0);    assertEquals(10.339850002884626, v.norm(1), 1.0e-6);    assertEquals(1.5849625007211563, v.maxValue(), 1.0e-6);}
b46231c1506bc4583804f0ebbf592c94ef2d62a8422bcebe8b1b458cb530da45
testDictionaryOrder
public void testDictionaryOrder()
{    Dictionary dict = new Dictionary();    dict.intern("a");    dict.intern("d");    dict.intern("c");    dict.intern("b");    dict.intern("qrz");    assertEquals("[a, d, c, b, qrz]", dict.values().toString());    Dictionary dict2 = Dictionary.fromList(dict.values());    assertEquals("[a, d, c, b, qrz]", dict2.values().toString());}
a3f573f5c74136b950c490348cd85cec93efd7c687569beea2fbe52c7312da7a
testGradientmachine
public void testGradientmachine() throws IOException
{    Vector target = readStandardData();    GradientMachine grad = new GradientMachine(8, 4, 2).learningRate(0.1).regularization(0.01);    Random gen = RandomUtils.getRandom();    grad.initWeights(gen);    train(getInput(), target, grad);        test(getInput(), target, grad, 1.0, 1);}
bcb891b8b9ed86e865673ee95b9c00c9fdcab7eefa996f01e2679cae5e2a04b1
roundTrip
private static T roundTrip(T m, Class<T> clazz) throws IOException
{    ByteArrayOutputStream buf = new ByteArrayOutputStream(1000);    DataOutputStream dos = new DataOutputStream(buf);    try {        PolymorphicWritable.write(dos, m);    } finally {        Closeables.close(dos, false);    }    return PolymorphicWritable.read(new DataInputStream(new ByteArrayInputStream(buf.toByteArray())), clazz);}
d0f3adebabf373af4cae468516a6d15948e2cc917aa03645596be02cb0f7e32e
onlineAucRoundtrip
public void onlineAucRoundtrip() throws IOException
{    RandomUtils.useTestSeed();    OnlineAuc auc1 = new GlobalOnlineAuc();    Random gen = RandomUtils.getRandom();    for (int i = 0; i < 10000; i++) {        auc1.addSample(0, gen.nextGaussian());        auc1.addSample(1, gen.nextGaussian() + 1);    }    assertEquals(0.76, auc1.auc(), 0.01);    OnlineAuc auc3 = roundTrip(auc1, OnlineAuc.class);    assertEquals(auc1.auc(), auc3.auc(), 0);    for (int i = 0; i < 1000; i++) {        auc1.addSample(0, gen.nextGaussian());        auc1.addSample(1, gen.nextGaussian() + 1);        auc3.addSample(0, gen.nextGaussian());        auc3.addSample(1, gen.nextGaussian() + 1);    }    assertEquals(auc1.auc(), auc3.auc(), 0.01);}
2712aba7e6054591eb7f23dc2fec18f0a22fe9740800316de7423c5991822f02
onlineLogisticRegressionRoundTrip
public void onlineLogisticRegressionRoundTrip() throws IOException
{    OnlineLogisticRegression olr = new OnlineLogisticRegression(2, 5, new L1());    train(olr, 100);    OnlineLogisticRegression olr3 = roundTrip(olr, OnlineLogisticRegression.class);    assertEquals(0, olr.getBeta().minus(olr3.getBeta()).aggregate(Functions.MAX, Functions.IDENTITY), 1.0e-6);    train(olr, 100);    train(olr3, 100);    assertEquals(0, olr.getBeta().minus(olr3.getBeta()).aggregate(Functions.MAX, Functions.IDENTITY), 1.0e-6);    olr.close();    olr3.close();}
9654f904807c4c542ec3a40b7aaf73ef57f4a92d933375dc2c1efd2e875f6329
crossFoldLearnerRoundTrip
public void crossFoldLearnerRoundTrip() throws IOException
{    CrossFoldLearner learner = new CrossFoldLearner(5, 2, 5, new L1());    train(learner, 100);    CrossFoldLearner olr3 = roundTrip(learner, CrossFoldLearner.class);    double auc1 = learner.auc();    assertTrue(auc1 > 0.85);    assertEquals(auc1, learner.auc(), 1.0e-6);    assertEquals(auc1, olr3.auc(), 1.0e-6);    train(learner, 100);    train(learner, 100);    train(olr3, 100);    assertEquals(learner.auc(), learner.auc(), 0.02);    assertEquals(learner.auc(), olr3.auc(), 0.02);    double auc2 = learner.auc();    assertTrue(auc2 > auc1);    learner.close();    olr3.close();}
35688ea3bac4061bedb14c030b0012037fda34beceb36881837060109cfc7a78
adaptiveLogisticRegressionRoundTrip
public void adaptiveLogisticRegressionRoundTrip() throws IOException
{    AdaptiveLogisticRegression learner = new AdaptiveLogisticRegression(2, 5, new L1());    learner.setInterval(200);    train(learner, 400);    AdaptiveLogisticRegression olr3 = roundTrip(learner, AdaptiveLogisticRegression.class);    double auc1 = learner.auc();    assertTrue(auc1 > 0.85);    assertEquals(auc1, learner.auc(), 1.0e-6);    assertEquals(auc1, olr3.auc(), 1.0e-6);    train(learner, 1000);    train(learner, 1000);    train(olr3, 1000);    assertEquals(learner.auc(), learner.auc(), 0.005);    assertEquals(learner.auc(), olr3.auc(), 0.005);    double auc2 = learner.auc();    assertTrue(String.format("%.3f > %.3f", auc2, auc1), auc2 > auc1);    learner.close();    olr3.close();}
d748a3463b1953d59c1f86158638a2f08147d2635f0ad50a848218a782663b13
train
private static void train(OnlineLearner olr, int n)
{    Vector beta = new DenseVector(new double[] { 1, -1, 0, 0.5, -0.5 });    Random gen = RandomUtils.getRandom();    for (int i = 0; i < n; i++) {        Vector x = randomVector(gen, 5);        int target = gen.nextDouble() < beta.dot(x) ? 1 : 0;        olr.train(target, x);    }}
4ebb90f7b59b2ce87644a0ae634a7b15aec5d8290e6d2f07a1be4387bc5f1b40
randomVector
private static Vector randomVector(final Random gen, int n)
{    Vector x = new DenseVector(n);    x.assign(new DoubleFunction() {        @Override        public double apply(double v) {            return gen.nextGaussian();        }    });    return x;}
0b41a4c0ac574be18fedcf88e7465eddcb1f8f1a3ad9bbb36e6b37f373bd3830
apply
public double apply(double v)
{    return gen.nextGaussian();}
3b683b4c16e6f67d2d7fb8bc41c86738c30f0dc60ceff62cac910bd1ff869c6d
getInput
 Matrix getInput()
{    return input;}
b77242abae1fc0bde22e4aac9dc3c403da0a711dbdfd8eb5ffbc34aa7e3bdf47
readStandardData
 Vector readStandardData() throws IOException
{                input = readCsv("sgd.csv");        Vector target = new DenseVector(60);    target.assign(0);    target.viewPart(30, 30).assign(1);    return target;}
240e605f6f06e7fa8e320d6182eefbee3cf9bd391571154ac33e45451d4c5485
train
 static void train(Matrix input, Vector target, OnlineLearner lr)
{    RandomUtils.useTestSeed();    Random gen = RandomUtils.getRandom();        for (int row : permute(gen, 60)) {        lr.train((int) target.get(row), input.viewRow(row));    }    lr.close();}
2eaf6fe35646d5601e9ada1f20c01e5fc3df88fe0aa413b6af22166b3e079b3c
test
 static void test(Matrix input, Vector target, AbstractVectorClassifier lr, double expected_mean_error, double expected_absolute_error)
{        Matrix tmp = lr.classify(input);        double meanAbsoluteError = tmp.viewColumn(0).minus(target).aggregate(Functions.PLUS, Functions.ABS) / 60;        double maxAbsoluteError = tmp.viewColumn(0).minus(target).aggregate(Functions.MAX, Functions.ABS);    System.out.printf("mAE = %.4f, maxAE = %.4f\n", meanAbsoluteError, maxAbsoluteError);    assertEquals(0, meanAbsoluteError, expected_mean_error);    assertEquals(0, maxAbsoluteError, expected_absolute_error);        Vector v = lr.classifyScalar(input);    assertEquals(0, v.minus(tmp.viewColumn(0)).norm(1), 1.0e-5);    v = lr.classifyFull(input).viewColumn(1);    assertEquals(0, v.minus(tmp.viewColumn(0)).norm(1), 1.0e-4);}
069e0f061c733da4d8395bfee175ee7d82ad3fdec280a351f927d1e61be70a83
permute
 static int[] permute(Random gen, int max)
{    int[] permutation = new int[max];    permutation[0] = 0;    for (int i = 1; i < max; i++) {        int n = gen.nextInt(i + 1);        if (n == i) {            permutation[i] = i;        } else {            permutation[i] = permutation[n];            permutation[n] = i;        }    }    return permutation;}
6d1f3113804db7b1f99c2946d5b6edd5a0bb8712e7a857adb13361587701e732
readCsv
 static Matrix readCsv(String resourceName) throws IOException
{    Splitter onCommas = Splitter.on(',').trimResults(CharMatcher.anyOf(" \""));    Readable isr = new InputStreamReader(Resources.getResource(resourceName).openStream(), Charsets.UTF_8);    List<String> data = CharStreams.readLines(isr);    String first = data.get(0);    data = data.subList(1, data.size());    List<String> values = Lists.newArrayList(onCommas.split(first));    Matrix r = new DenseMatrix(data.size(), values.size());    int column = 0;    Map<String, Integer> labels = Maps.newHashMap();    for (String value : values) {        labels.put(value, column);        column++;    }    r.setColumnLabelBindings(labels);    int row = 0;    for (String line : data) {        column = 0;        values = Lists.newArrayList(onCommas.split(line));        for (String value : values) {            r.set(row, column, Double.parseDouble(value));            column++;        }        row++;    }    return r;}
b69d387645c8004fdd244bf78daa4a7e1fc1b55ec3ecdf9cd73c82df56c209d9
crossValidation
public void crossValidation() throws IOException
{    Vector target = readStandardData();    CrossFoldLearner lr = new CrossFoldLearner(5, 2, 8, new L1()).lambda(1 * 1.0e-3).learningRate(50);    train(getInput(), target, lr);    System.out.printf("%.2f %.5f\n", lr.auc(), lr.logLikelihood());    test(getInput(), target, lr, 0.05, 0.3);}
d8ffd385cbd86645f7bc9b26eb66df3e24cf8dd0a4578e449cd87c7682a01ba7
crossValidatedAuc
public void crossValidatedAuc() throws IOException
{    RandomUtils.useTestSeed();    Random gen = RandomUtils.getRandom();    Matrix data = readCsv("cancer.csv");    CrossFoldLearner lr = new CrossFoldLearner(5, 2, 10, new L1()).stepOffset(10).decayExponent(0.7).lambda(1 * 1.0e-3).learningRate(5);    int k = 0;    int[] ordering = permute(gen, data.numRows());    for (int epoch = 0; epoch < 100; epoch++) {        for (int row : ordering) {            lr.train(row, (int) data.get(row, 9), data.viewRow(row));            System.out.printf("%d,%d,%.3f\n", epoch, k++, lr.auc());        }        assertEquals(1, lr.auc(), 0.2);    }    assertEquals(1, lr.auc(), 0.1);}
0cc894a12d334c8a52fd9aa3fd8780697328a24cdc5cbc6bede974c67444d633
testClassify
public void testClassify()
{    OnlineLogisticRegression lr = new OnlineLogisticRegression(3, 2, new L2(1));        lr.setBeta(0, 0, -1);    lr.setBeta(1, 0, -2);        Vector v = lr.classify(new DenseVector(new double[] { 0, 0 }));    assertEquals(1 / 3.0, v.get(0), 1.0e-8);    assertEquals(1 / 3.0, v.get(1), 1.0e-8);    v = lr.classifyFull(new DenseVector(new double[] { 0, 0 }));    assertEquals(1.0, v.zSum(), 1.0e-8);    assertEquals(1 / 3.0, v.get(0), 1.0e-8);    assertEquals(1 / 3.0, v.get(1), 1.0e-8);    assertEquals(1 / 3.0, v.get(2), 1.0e-8);        v = lr.classify(new DenseVector(new double[] { 0, 1 }));    assertEquals(1 / 3.0, v.get(0), 1.0e-3);    assertEquals(1 / 3.0, v.get(1), 1.0e-3);    v = lr.classifyFull(new DenseVector(new double[] { 0, 1 }));    assertEquals(1.0, v.zSum(), 1.0e-8);    assertEquals(1 / 3.0, v.get(0), 1.0e-3);    assertEquals(1 / 3.0, v.get(1), 1.0e-3);    assertEquals(1 / 3.0, v.get(2), 1.0e-3);        v = lr.classify(new DenseVector(new double[] { 1, 0 }));    assertEquals(Math.exp(-1) / (1 + Math.exp(-1) + Math.exp(-2)), v.get(0), 1.0e-8);    assertEquals(Math.exp(-2) / (1 + Math.exp(-1) + Math.exp(-2)), v.get(1), 1.0e-8);    v = lr.classifyFull(new DenseVector(new double[] { 1, 0 }));    assertEquals(1.0, v.zSum(), 1.0e-8);    assertEquals(1 / (1 + Math.exp(-1) + Math.exp(-2)), v.get(0), 1.0e-8);    assertEquals(Math.exp(-1) / (1 + Math.exp(-1) + Math.exp(-2)), v.get(1), 1.0e-8);    assertEquals(Math.exp(-2) / (1 + Math.exp(-1) + Math.exp(-2)), v.get(2), 1.0e-8);    lr.setBeta(0, 1, 1);    v = lr.classifyFull(new DenseVector(new double[] { 1, 1 }));    assertEquals(1.0, v.zSum(), 1.0e-8);    assertEquals(Math.exp(0) / (1 + Math.exp(0) + Math.exp(-2)), v.get(1), 1.0e-3);    assertEquals(Math.exp(-2) / (1 + Math.exp(0) + Math.exp(-2)), v.get(2), 1.0e-3);    assertEquals(1 / (1 + Math.exp(0) + Math.exp(-2)), v.get(0), 1.0e-3);    lr.setBeta(1, 1, 3);    v = lr.classifyFull(new DenseVector(new double[] { 1, 1 }));    assertEquals(1.0, v.zSum(), 1.0e-8);    assertEquals(Math.exp(0) / (1 + Math.exp(0) + Math.exp(1)), v.get(1), 1.0e-8);    assertEquals(Math.exp(1) / (1 + Math.exp(0) + Math.exp(1)), v.get(2), 1.0e-8);    assertEquals(1 / (1 + Math.exp(0) + Math.exp(1)), v.get(0), 1.0e-8);}
e2d0cf30f5aa60f951ac62249b00a0f32d57dcceb72fa7cd068ae6735b4f3c30
iris
public void iris() throws IOException
{                                                                            RandomUtils.useTestSeed();    Splitter onComma = Splitter.on(",");        List<String> raw = Resources.readLines(Resources.getResource("iris.csv"), Charsets.UTF_8);        List<Vector> data = Lists.newArrayList();        List<Integer> target = Lists.newArrayList();        Dictionary dict = new Dictionary();        List<Integer> order = Lists.newArrayList();    for (String line : raw.subList(1, raw.size())) {                order.add(order.size());                Vector v = new DenseVector(5);        v.set(0, 1);        int i = 1;        Iterable<String> values = onComma.split(line);        for (String value : Iterables.limit(values, 4)) {            v.set(i++, Double.parseDouble(value));        }        data.add(v);                target.add(dict.intern(Iterables.get(values, 4)));    }            Random random = RandomUtils.getRandom();    Collections.shuffle(order, random);        List<Integer> train = order.subList(0, 100);    List<Integer> test = order.subList(100, 150);    logger.warn("Training set = {}", train);    logger.warn("Test set = {}", test);        int[] correct = new int[test.size() + 1];    for (int run = 0; run < 200; run++) {        OnlineLogisticRegression lr = new OnlineLogisticRegression(3, 5, new L2(1));                for (int pass = 0; pass < 30; pass++) {            Collections.shuffle(train, random);            for (int k : train) {                lr.train(target.get(k), data.get(k));            }        }                int x = 0;        int[] count = new int[3];        for (Integer k : test) {            int r = lr.classifyFull(data.get(k)).maxValueIndex();            count[r]++;            x += r == target.get(k) ? 1 : 0;        }        correct[x]++;    }        for (int i = 0; i < Math.floor(0.95 * test.size()); i++) {        assertEquals(String.format("%d trials had unacceptable accuracy of only %.0f%%: ", correct[i], 100.0 * i / test.size()), 0, correct[i]);    }        assertEquals(String.format("%d trials had unrealistic accuracy of 100%%", correct[test.size() - 1]), 0, correct[test.size()]);}
80be959149bb4cf7b68db8b1ea22ba3f31c6807383df9b22fae7d1b06ed481b3
testTrain
public void testTrain() throws Exception
{    Vector target = readStandardData();                        OnlineLogisticRegression lr = new OnlineLogisticRegression(2, 8, new L1()).lambda(1 * 1.0e-3).learningRate(50);    train(getInput(), target, lr);    test(getInput(), target, lr, 0.05, 0.3);}
71239e0e84b624cb33a10cf4378bdefc2d53d9e5610837b4360e05bdec0a562f
testSerializationAndDeSerialization
public void testSerializationAndDeSerialization() throws Exception
{    OnlineLogisticRegression lr = new OnlineLogisticRegression(2, 8, new L1()).lambda(1 * 1.0e-3).stepOffset(11).alpha(0.01).learningRate(50).decayExponent(-0.02);    lr.close();    byte[] output;    try (ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();        DataOutputStream dataOutputStream = new DataOutputStream(byteArrayOutputStream)) {        PolymorphicWritable.write(dataOutputStream, lr);        output = byteArrayOutputStream.toByteArray();    }    OnlineLogisticRegression read;    try (ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(output);        DataInputStream dataInputStream = new DataInputStream(byteArrayInputStream)) {        read = PolymorphicWritable.read(dataInputStream, OnlineLogisticRegression.class);    }        Assert.assertEquals((1.0e-3), read.getLambda(), 1.0e-7);            Field stepOffset = lr.getClass().getDeclaredField("stepOffset");    stepOffset.setAccessible(true);    int stepOffsetVal = (Integer) stepOffset.get(lr);    Assert.assertEquals(11, stepOffsetVal);        Field decayFactor = lr.getClass().getDeclaredField("decayFactor");    decayFactor.setAccessible(true);    double decayFactorVal = (Double) decayFactor.get(lr);    Assert.assertEquals(0.01, decayFactorVal, 1.0e-7);        Field mu0 = lr.getClass().getDeclaredField("mu0");    mu0.setAccessible(true);    double mu0Val = (Double) mu0.get(lr);    Assert.assertEquals(50, mu0Val, 1.0e-7);        Field forgettingExponent = lr.getClass().getDeclaredField("forgettingExponent");    forgettingExponent.setAccessible(true);    double forgettingExponentVal = (Double) forgettingExponent.get(lr);    Assert.assertEquals(-0.02, forgettingExponentVal, 1.0e-7);}
1be2780ecf27ab7b60104eff91449b45ec2f9b0e694cd8773dfee0e127021986
testPassiveAggressive
public void testPassiveAggressive() throws IOException
{    Vector target = readStandardData();    PassiveAggressive pa = new PassiveAggressive(2, 8).learningRate(0.1);    train(getInput(), target, pa);    test(getInput(), target, pa, 0.11, 0.31);}
bab5728cb51c52a7fbcdad9faa004cefadeb2691069c31ec4938e0be081f4bc2
getPointsWritable
private static List<VectorWritable> getPointsWritable()
{    List<VectorWritable> points = Lists.newArrayList();    for (double[] fr : RAW) {        Vector vec = new RandomAccessSparseVector(fr.length);        vec.assign(fr);        points.add(new VectorWritable(vec));    }    return points;}
d1d0fd2e839d7b377c4b9624143cd721352540c6520fe6d067bf510bcdc33334
getPoints
private static List<Vector> getPoints()
{    List<Vector> points = Lists.newArrayList();    for (double[] fr : RAW) {        Vector vec = new RandomAccessSparseVector(fr.length);        vec.assign(fr);        points.add(vec);    }    return points;}
23d33632b6127f1b85f6c4d86a21910e452d672ed8aadb49ada69f16154e6c84
printCanopies
private static void printCanopies(Iterable<Canopy> canopies)
{    for (Canopy canopy : canopies) {        System.out.println(canopy.asFormatString(null));    }}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    super.setUp();    fs = FileSystem.get(getConfiguration());    referenceManhattan = CanopyClusterer.createCanopies(getPoints(), manhattanDistanceMeasure, 3.1, 2.1);    manhattanCentroids = CanopyClusterer.getCenters(referenceManhattan);    referenceEuclidean = CanopyClusterer.createCanopies(getPoints(), euclideanDistanceMeasure, 3.1, 2.1);    euclideanCentroids = CanopyClusterer.getCenters(referenceEuclidean);}
69eb3e4eb3ea41d99264c03fe6e093752d45466862e6a4a1d208bf79dbdc9e3e
testReferenceManhattan
public void testReferenceManhattan() throws Exception
{        printCanopies(referenceManhattan);    assertEquals("number of canopies", 3, referenceManhattan.size());    for (int canopyIx = 0; canopyIx < referenceManhattan.size(); canopyIx++) {        Canopy testCanopy = referenceManhattan.get(canopyIx);        int[] expectedNumPoints = { 4, 4, 3 };        double[][] expectedCentroids = { { 1.5, 1.5 }, { 4.0, 4.0 }, { 4.666666666666667, 4.6666666666666667 } };        assertEquals("canopy points " + canopyIx, testCanopy.getNumObservations(), expectedNumPoints[canopyIx]);        double[] refCentroid = expectedCentroids[canopyIx];        Vector testCentroid = testCanopy.computeCentroid();        for (int pointIx = 0; pointIx < refCentroid.length; pointIx++) {            assertEquals("canopy centroid " + canopyIx + '[' + pointIx + ']', refCentroid[pointIx], testCentroid.get(pointIx), EPSILON);        }    }}
1de6349c6e4869ed915e4a962791b5eb2d52fddae8b10f42e4f815c2a3db6ade
testReferenceEuclidean
public void testReferenceEuclidean() throws Exception
{        printCanopies(referenceEuclidean);    assertEquals("number of canopies", 3, referenceEuclidean.size());    int[] expectedNumPoints = { 5, 5, 3 };    double[][] expectedCentroids = { { 1.8, 1.8 }, { 4.2, 4.2 }, { 4.666666666666667, 4.666666666666667 } };    for (int canopyIx = 0; canopyIx < referenceEuclidean.size(); canopyIx++) {        Canopy testCanopy = referenceEuclidean.get(canopyIx);        assertEquals("canopy points " + canopyIx, testCanopy.getNumObservations(), expectedNumPoints[canopyIx]);        double[] refCentroid = expectedCentroids[canopyIx];        Vector testCentroid = testCanopy.computeCentroid();        for (int pointIx = 0; pointIx < refCentroid.length; pointIx++) {            assertEquals("canopy centroid " + canopyIx + '[' + pointIx + ']', refCentroid[pointIx], testCentroid.get(pointIx), EPSILON);        }    }}
46de5e9e3f734719e6a6b28d2202b3ca19739da1e8e3bcd4e120ebd3a01fdcec
testCanopyMapperManhattan
public void testCanopyMapperManhattan() throws Exception
{    CanopyMapper mapper = new CanopyMapper();    Configuration conf = getConfiguration();    conf.set(CanopyConfigKeys.DISTANCE_MEASURE_KEY, manhattanDistanceMeasure.getClass().getName());    conf.set(CanopyConfigKeys.T1_KEY, String.valueOf(3.1));    conf.set(CanopyConfigKeys.T2_KEY, String.valueOf(2.1));    conf.set(CanopyConfigKeys.CF_KEY, "0");    DummyRecordWriter<Text, VectorWritable> writer = new DummyRecordWriter<>();    Mapper<WritableComparable<?>, VectorWritable, Text, VectorWritable>.Context context = DummyRecordWriter.build(mapper, conf, writer);    mapper.setup(context);    List<VectorWritable> points = getPointsWritable();        for (VectorWritable point : points) {        mapper.map(new Text(), point, context);    }    mapper.cleanup(context);    assertEquals("Number of map results", 1, writer.getData().size());        List<VectorWritable> data = writer.getValue(new Text("centroid"));    assertEquals("Number of centroids", 3, data.size());    for (int i = 0; i < data.size(); i++) {        assertEquals("Centroid error", manhattanCentroids.get(i).asFormatString(), data.get(i).get().asFormatString());    }}
4e8250b80807dbfcf68045d42c2447cffeb03539028a636682bff50dd856f7a8
testCanopyMapperEuclidean
public void testCanopyMapperEuclidean() throws Exception
{    CanopyMapper mapper = new CanopyMapper();    Configuration conf = getConfiguration();    conf.set(CanopyConfigKeys.DISTANCE_MEASURE_KEY, euclideanDistanceMeasure.getClass().getName());    conf.set(CanopyConfigKeys.T1_KEY, String.valueOf(3.1));    conf.set(CanopyConfigKeys.T2_KEY, String.valueOf(2.1));    conf.set(CanopyConfigKeys.CF_KEY, "0");    DummyRecordWriter<Text, VectorWritable> writer = new DummyRecordWriter<>();    Mapper<WritableComparable<?>, VectorWritable, Text, VectorWritable>.Context context = DummyRecordWriter.build(mapper, conf, writer);    mapper.setup(context);    List<VectorWritable> points = getPointsWritable();        for (VectorWritable point : points) {        mapper.map(new Text(), point, context);    }    mapper.cleanup(context);    assertEquals("Number of map results", 1, writer.getData().size());        List<VectorWritable> data = writer.getValue(new Text("centroid"));    assertEquals("Number of centroids", 3, data.size());    for (int i = 0; i < data.size(); i++) {        assertEquals("Centroid error", euclideanCentroids.get(i).asFormatString(), data.get(i).get().asFormatString());    }}
8ec4b076a5dca9bbb6741960e61361deaaeabc2517501ff18b7da5c2539ab3cf
testCanopyReducerManhattan
public void testCanopyReducerManhattan() throws Exception
{    CanopyReducer reducer = new CanopyReducer();    Configuration conf = getConfiguration();    conf.set(CanopyConfigKeys.DISTANCE_MEASURE_KEY, "org.apache.mahout.common.distance.ManhattanDistanceMeasure");    conf.set(CanopyConfigKeys.T1_KEY, String.valueOf(3.1));    conf.set(CanopyConfigKeys.T2_KEY, String.valueOf(2.1));    conf.set(CanopyConfigKeys.CF_KEY, "0");    DummyRecordWriter<Text, ClusterWritable> writer = new DummyRecordWriter<>();    Reducer<Text, VectorWritable, Text, ClusterWritable>.Context context = DummyRecordWriter.build(reducer, conf, writer, Text.class, VectorWritable.class);    reducer.setup(context);    List<VectorWritable> points = getPointsWritable();    reducer.reduce(new Text("centroid"), points, context);    Iterable<Text> keys = writer.getKeysInInsertionOrder();    assertEquals("Number of centroids", 3, Iterables.size(keys));    int i = 0;    for (Text key : keys) {        List<ClusterWritable> data = writer.getValue(key);        ClusterWritable clusterWritable = data.get(0);        Canopy canopy = (Canopy) clusterWritable.getValue();        assertEquals(manhattanCentroids.get(i).asFormatString() + " is not equal to " + canopy.computeCentroid().asFormatString(), manhattanCentroids.get(i), canopy.computeCentroid());        i++;    }}
1472654d0a8f144a5990513ebf327d94d0b1a86b9edeeb5c0e0660cfd11596e5
testCanopyReducerEuclidean
public void testCanopyReducerEuclidean() throws Exception
{    CanopyReducer reducer = new CanopyReducer();    Configuration conf = getConfiguration();    conf.set(CanopyConfigKeys.DISTANCE_MEASURE_KEY, "org.apache.mahout.common.distance.EuclideanDistanceMeasure");    conf.set(CanopyConfigKeys.T1_KEY, String.valueOf(3.1));    conf.set(CanopyConfigKeys.T2_KEY, String.valueOf(2.1));    conf.set(CanopyConfigKeys.CF_KEY, "0");    DummyRecordWriter<Text, ClusterWritable> writer = new DummyRecordWriter<>();    Reducer<Text, VectorWritable, Text, ClusterWritable>.Context context = DummyRecordWriter.build(reducer, conf, writer, Text.class, VectorWritable.class);    reducer.setup(context);    List<VectorWritable> points = getPointsWritable();    reducer.reduce(new Text("centroid"), points, context);    Iterable<Text> keys = writer.getKeysInInsertionOrder();    assertEquals("Number of centroids", 3, Iterables.size(keys));    int i = 0;    for (Text key : keys) {        List<ClusterWritable> data = writer.getValue(key);        ClusterWritable clusterWritable = data.get(0);        Canopy canopy = (Canopy) clusterWritable.getValue();        assertEquals(euclideanCentroids.get(i).asFormatString() + " is not equal to " + canopy.computeCentroid().asFormatString(), euclideanCentroids.get(i), canopy.computeCentroid());        i++;    }}
359f9e02c261e0c3594fcf3eb8f343b228465a960ec4f2b06f8afa37296e401a
testCanopyGenManhattanMR
public void testCanopyGenManhattanMR() throws Exception
{    List<VectorWritable> points = getPointsWritable();    Configuration config = getConfiguration();    ClusteringTestUtils.writePointsToFile(points, getTestTempFilePath("testdata/file1"), fs, config);    ClusteringTestUtils.writePointsToFile(points, getTestTempFilePath("testdata/file2"), fs, config);        Path output = getTestTempDirPath("output");    CanopyDriver.run(config, getTestTempDirPath("testdata"), output, manhattanDistanceMeasure, 3.1, 2.1, false, 0.0, false);        Path path = new Path(output, "clusters-0-final/part-r-00000");    FileSystem fs = FileSystem.get(path.toUri(), config);    SequenceFile.Reader reader = new SequenceFile.Reader(fs, path, config);    try {        Writable key = new Text();        ClusterWritable clusterWritable = new ClusterWritable();        assertTrue("more to come", reader.next(key, clusterWritable));        assertEquals("1st key", "C-0", key.toString());        List<Pair<Double, Double>> refCenters = Lists.newArrayList();        refCenters.add(new Pair<>(1.5, 1.5));        refCenters.add(new Pair<>(4.333333333333334, 4.333333333333334));        Pair<Double, Double> c = new Pair<>(clusterWritable.getValue().getCenter().get(0), clusterWritable.getValue().getCenter().get(1));        assertTrue("center " + c + " not found", findAndRemove(c, refCenters, EPSILON));        assertTrue("more to come", reader.next(key, clusterWritable));        assertEquals("2nd key", "C-1", key.toString());        c = new Pair<>(clusterWritable.getValue().getCenter().get(0), clusterWritable.getValue().getCenter().get(1));        assertTrue("center " + c + " not found", findAndRemove(c, refCenters, EPSILON));        assertFalse("more to come", reader.next(key, clusterWritable));    } finally {        Closeables.close(reader, true);    }}
074f07c88ae2be5602024e0053238641c5ac10e2cb65df2354cb7f9d638318b5
findAndRemove
 static boolean findAndRemove(Pair<Double, Double> target, Collection<Pair<Double, Double>> list, double epsilon)
{    for (Pair<Double, Double> curr : list) {        if ((Math.abs(target.getFirst() - curr.getFirst()) < epsilon) && (Math.abs(target.getSecond() - curr.getSecond()) < epsilon)) {            list.remove(curr);            return true;        }    }    return false;}
0ef631a473abd87fe1448066ba039230af840a21218b09ac5cbea7a90d75db68
testCanopyGenEuclideanMR
public void testCanopyGenEuclideanMR() throws Exception
{    List<VectorWritable> points = getPointsWritable();    Configuration config = getConfiguration();    ClusteringTestUtils.writePointsToFile(points, getTestTempFilePath("testdata/file1"), fs, config);    ClusteringTestUtils.writePointsToFile(points, getTestTempFilePath("testdata/file2"), fs, config);        Path output = getTestTempDirPath("output");    CanopyDriver.run(config, getTestTempDirPath("testdata"), output, euclideanDistanceMeasure, 3.1, 2.1, false, 0.0, false);        Path path = new Path(output, "clusters-0-final/part-r-00000");    FileSystem fs = FileSystem.get(path.toUri(), config);    SequenceFile.Reader reader = new SequenceFile.Reader(fs, path, config);    try {        Writable key = new Text();        ClusterWritable clusterWritable = new ClusterWritable();        assertTrue("more to come", reader.next(key, clusterWritable));        assertEquals("1st key", "C-0", key.toString());        List<Pair<Double, Double>> refCenters = Lists.newArrayList();        refCenters.add(new Pair<>(1.8, 1.8));        refCenters.add(new Pair<>(4.433333333333334, 4.433333333333334));        Pair<Double, Double> c = new Pair<>(clusterWritable.getValue().getCenter().get(0), clusterWritable.getValue().getCenter().get(1));        assertTrue("center " + c + " not found", findAndRemove(c, refCenters, EPSILON));        assertTrue("more to come", reader.next(key, clusterWritable));        assertEquals("2nd key", "C-1", key.toString());        c = new Pair<>(clusterWritable.getValue().getCenter().get(0), clusterWritable.getValue().getCenter().get(1));        assertTrue("center " + c + " not found", findAndRemove(c, refCenters, EPSILON));        assertFalse("more to come", reader.next(key, clusterWritable));    } finally {        Closeables.close(reader, true);    }}
5a6c06923de82f345fcaca69474d10787486fc0753789c061a04fa60d7cf729d
testClusteringManhattanSeq
public void testClusteringManhattanSeq() throws Exception
{    List<VectorWritable> points = getPointsWritable();    Configuration config = getConfiguration();    ClusteringTestUtils.writePointsToFile(points, getTestTempFilePath("testdata/file1"), fs, config);        Path output = getTestTempDirPath("output");    CanopyDriver.run(config, getTestTempDirPath("testdata"), output, manhattanDistanceMeasure, 3.1, 2.1, true, 0.0, true);        Path path = new Path(output, "clusters-0-final/part-r-00000");    int ix = 0;    for (ClusterWritable clusterWritable : new SequenceFileValueIterable<ClusterWritable>(path, true, config)) {        assertEquals("Center [" + ix + ']', manhattanCentroids.get(ix), clusterWritable.getValue().getCenter());        ix++;    }    path = new Path(output, "clusteredPoints/part-m-0");    long count = HadoopUtil.countRecords(path, config);    assertEquals("number of points", points.size(), count);}
54f6387c991d6dd312e362a654990d6520d02e7cda337d3b309257009d5b89be
testClusteringEuclideanSeq
public void testClusteringEuclideanSeq() throws Exception
{    List<VectorWritable> points = getPointsWritable();    Configuration config = getConfiguration();    ClusteringTestUtils.writePointsToFile(points, getTestTempFilePath("testdata/file1"), fs, config);        Path output = getTestTempDirPath("output");    String[] args = { optKey(DefaultOptionCreator.INPUT_OPTION), getTestTempDirPath("testdata").toString(), optKey(DefaultOptionCreator.OUTPUT_OPTION), output.toString(), optKey(DefaultOptionCreator.DISTANCE_MEASURE_OPTION), EuclideanDistanceMeasure.class.getName(), optKey(DefaultOptionCreator.T1_OPTION), "3.1", optKey(DefaultOptionCreator.T2_OPTION), "2.1", optKey(DefaultOptionCreator.CLUSTERING_OPTION), optKey(DefaultOptionCreator.OVERWRITE_OPTION), optKey(DefaultOptionCreator.METHOD_OPTION), DefaultOptionCreator.SEQUENTIAL_METHOD };    ToolRunner.run(config, new CanopyDriver(), args);        Path path = new Path(output, "clusters-0-final/part-r-00000");    int ix = 0;    for (ClusterWritable clusterWritable : new SequenceFileValueIterable<ClusterWritable>(path, true, config)) {        assertEquals("Center [" + ix + ']', euclideanCentroids.get(ix), clusterWritable.getValue().getCenter());        ix++;    }    path = new Path(output, "clusteredPoints/part-m-0");    long count = HadoopUtil.countRecords(path, config);    assertEquals("number of points", points.size(), count);}
a09f309946da1dbc278f7028d78071c2325f3a2408eebe6decf62315203b3b83
testClusteringEuclideanWithOutlierRemovalSeq
public void testClusteringEuclideanWithOutlierRemovalSeq() throws Exception
{    List<VectorWritable> points = getPointsWritable();    Configuration config = getConfiguration();    ClusteringTestUtils.writePointsToFile(points, getTestTempFilePath("testdata/file1"), fs, config);        Path output = getTestTempDirPath("output");    String[] args = { optKey(DefaultOptionCreator.INPUT_OPTION), getTestTempDirPath("testdata").toString(), optKey(DefaultOptionCreator.OUTPUT_OPTION), output.toString(), optKey(DefaultOptionCreator.DISTANCE_MEASURE_OPTION), EuclideanDistanceMeasure.class.getName(), optKey(DefaultOptionCreator.T1_OPTION), "3.1", optKey(DefaultOptionCreator.T2_OPTION), "2.1", optKey(DefaultOptionCreator.OUTLIER_THRESHOLD), "0.5", optKey(DefaultOptionCreator.CLUSTERING_OPTION), optKey(DefaultOptionCreator.OVERWRITE_OPTION), optKey(DefaultOptionCreator.METHOD_OPTION), DefaultOptionCreator.SEQUENTIAL_METHOD };    ToolRunner.run(config, new CanopyDriver(), args);        Path path = new Path(output, "clusters-0-final/part-r-00000");    int ix = 0;    for (ClusterWritable clusterWritable : new SequenceFileValueIterable<ClusterWritable>(path, true, config)) {        assertEquals("Center [" + ix + ']', euclideanCentroids.get(ix), clusterWritable.getValue().getCenter());        ix++;    }    path = new Path(output, "clusteredPoints/part-m-0");    long count = HadoopUtil.countRecords(path, config);    int expectedPointsHavingPDFGreaterThanThreshold = 6;    assertEquals("number of points", expectedPointsHavingPDFGreaterThanThreshold, count);}
198fd025955307070adf8e8099841ef7f91864fa77f1c9e7d037913679f3cac0
testClusteringManhattanMR
public void testClusteringManhattanMR() throws Exception
{    List<VectorWritable> points = getPointsWritable();    Configuration conf = getConfiguration();    ClusteringTestUtils.writePointsToFile(points, true, getTestTempFilePath("testdata/file1"), fs, conf);    ClusteringTestUtils.writePointsToFile(points, true, getTestTempFilePath("testdata/file2"), fs, conf);        Path output = getTestTempDirPath("output");    CanopyDriver.run(conf, getTestTempDirPath("testdata"), output, manhattanDistanceMeasure, 3.1, 2.1, true, 0.0, false);    Path path = new Path(output, "clusteredPoints/part-m-00000");    long count = HadoopUtil.countRecords(path, conf);    assertEquals("number of points", points.size(), count);}
437b1a099c0d97ac266da32b9fdfb12eff8feba431f914d5935fb63d1ea89a92
testClusteringEuclideanMR
public void testClusteringEuclideanMR() throws Exception
{    List<VectorWritable> points = getPointsWritable();    Configuration conf = getConfiguration();    ClusteringTestUtils.writePointsToFile(points, true, getTestTempFilePath("testdata/file1"), fs, conf);    ClusteringTestUtils.writePointsToFile(points, true, getTestTempFilePath("testdata/file2"), fs, conf);        Path output = getTestTempDirPath("output");    String[] args = { optKey(DefaultOptionCreator.INPUT_OPTION), getTestTempDirPath("testdata").toString(), optKey(DefaultOptionCreator.OUTPUT_OPTION), output.toString(), optKey(DefaultOptionCreator.DISTANCE_MEASURE_OPTION), EuclideanDistanceMeasure.class.getName(), optKey(DefaultOptionCreator.T1_OPTION), "3.1", optKey(DefaultOptionCreator.T2_OPTION), "2.1", optKey(DefaultOptionCreator.CLUSTERING_OPTION), optKey(DefaultOptionCreator.OVERWRITE_OPTION) };    ToolRunner.run(getConfiguration(), new CanopyDriver(), args);    Path path = new Path(output, "clusteredPoints/part-m-00000");    long count = HadoopUtil.countRecords(path, conf);    assertEquals("number of points", points.size(), count);}
06983237821306abeeda7036c8e7b1626a26d9abb1b404bffef0a25b4252b269
testClusteringEuclideanWithOutlierRemovalMR
public void testClusteringEuclideanWithOutlierRemovalMR() throws Exception
{    List<VectorWritable> points = getPointsWritable();    Configuration conf = getConfiguration();    ClusteringTestUtils.writePointsToFile(points, true, getTestTempFilePath("testdata/file1"), fs, conf);    ClusteringTestUtils.writePointsToFile(points, true, getTestTempFilePath("testdata/file2"), fs, conf);        Path output = getTestTempDirPath("output");    String[] args = { optKey(DefaultOptionCreator.INPUT_OPTION), getTestTempDirPath("testdata").toString(), optKey(DefaultOptionCreator.OUTPUT_OPTION), output.toString(), optKey(DefaultOptionCreator.DISTANCE_MEASURE_OPTION), EuclideanDistanceMeasure.class.getName(), optKey(DefaultOptionCreator.T1_OPTION), "3.1", optKey(DefaultOptionCreator.T2_OPTION), "2.1", optKey(DefaultOptionCreator.OUTLIER_THRESHOLD), "0.7", optKey(DefaultOptionCreator.CLUSTERING_OPTION), optKey(DefaultOptionCreator.OVERWRITE_OPTION) };    ToolRunner.run(getConfiguration(), new CanopyDriver(), args);    Path path = new Path(output, "clusteredPoints/part-m-00000");    long count = HadoopUtil.countRecords(path, conf);    int expectedPointsAfterOutlierRemoval = 8;    assertEquals("number of points", expectedPointsAfterOutlierRemoval, count);}
43dea94fde6345f4aebc6c74e2bceae6adb85682da096d4ddbdb12d6b3ada491
testCanopyReducerT3T4Configuration
public void testCanopyReducerT3T4Configuration() throws Exception
{    CanopyReducer reducer = new CanopyReducer();    Configuration conf = getConfiguration();    conf.set(CanopyConfigKeys.DISTANCE_MEASURE_KEY, "org.apache.mahout.common.distance.ManhattanDistanceMeasure");    conf.set(CanopyConfigKeys.T1_KEY, String.valueOf(3.1));    conf.set(CanopyConfigKeys.T2_KEY, String.valueOf(2.1));    conf.set(CanopyConfigKeys.T3_KEY, String.valueOf(1.1));    conf.set(CanopyConfigKeys.T4_KEY, String.valueOf(0.1));    conf.set(CanopyConfigKeys.CF_KEY, "0");    DummyRecordWriter<Text, ClusterWritable> writer = new DummyRecordWriter<>();    Reducer<Text, VectorWritable, Text, ClusterWritable>.Context context = DummyRecordWriter.build(reducer, conf, writer, Text.class, VectorWritable.class);    reducer.setup(context);    assertEquals(1.1, reducer.getCanopyClusterer().getT1(), EPSILON);    assertEquals(0.1, reducer.getCanopyClusterer().getT2(), EPSILON);}
b143b7be5ea63cab131df3a5380d4dc4c7e783141603061726a9ecf66fff9a93
testCanopyMapperClusterFilter
public void testCanopyMapperClusterFilter() throws Exception
{    CanopyMapper mapper = new CanopyMapper();    Configuration conf = getConfiguration();    conf.set(CanopyConfigKeys.DISTANCE_MEASURE_KEY, manhattanDistanceMeasure.getClass().getName());    conf.set(CanopyConfigKeys.T1_KEY, String.valueOf(3.1));    conf.set(CanopyConfigKeys.T2_KEY, String.valueOf(2.1));    conf.set(CanopyConfigKeys.CF_KEY, "3");    DummyRecordWriter<Text, VectorWritable> writer = new DummyRecordWriter<>();    Mapper<WritableComparable<?>, VectorWritable, Text, VectorWritable>.Context context = DummyRecordWriter.build(mapper, conf, writer);    mapper.setup(context);    List<VectorWritable> points = getPointsWritable();        for (VectorWritable point : points) {        mapper.map(new Text(), point, context);    }    mapper.cleanup(context);    assertEquals("Number of map results", 1, writer.getData().size());        List<VectorWritable> data = writer.getValue(new Text("centroid"));    assertEquals("Number of centroids", 2, data.size());}
9ecc8d9cfb487de86c5cf228e9ca079f9c24faa5de84510e9a4cec823cbe0d71
testCanopyReducerClusterFilter
public void testCanopyReducerClusterFilter() throws Exception
{    CanopyReducer reducer = new CanopyReducer();    Configuration conf = getConfiguration();    conf.set(CanopyConfigKeys.DISTANCE_MEASURE_KEY, "org.apache.mahout.common.distance.ManhattanDistanceMeasure");    conf.set(CanopyConfigKeys.T1_KEY, String.valueOf(3.1));    conf.set(CanopyConfigKeys.T2_KEY, String.valueOf(2.1));    conf.set(CanopyConfigKeys.CF_KEY, "3");    DummyRecordWriter<Text, ClusterWritable> writer = new DummyRecordWriter<>();    Reducer<Text, VectorWritable, Text, ClusterWritable>.Context context = DummyRecordWriter.build(reducer, conf, writer, Text.class, VectorWritable.class);    reducer.setup(context);    List<VectorWritable> points = getPointsWritable();    reducer.reduce(new Text("centroid"), points, context);    Set<Text> keys = writer.getKeys();    assertEquals("Number of centroids", 2, keys.size());}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    super.setUp();    Configuration conf = getConfiguration();    fs = FileSystem.get(conf);    firstCluster = Lists.newArrayList();    secondCluster = Lists.newArrayList();    thirdCluster = Lists.newArrayList();}
e3562711d8a9018f0912abf9d48c718794d70ebffbfaec82bebd277132fbea95
getPointsWritable
private static List<VectorWritable> getPointsWritable(double[][] raw)
{    List<VectorWritable> points = Lists.newArrayList();    for (double[] fr : raw) {        Vector vec = new RandomAccessSparseVector(fr.length);        vec.assign(fr);        points.add(new VectorWritable(vec));    }    return points;}
a4fcc029e66bc1322b538110e7e275949b877582e16abcc9c0be21c5e1268762
testVectorClassificationWithOutlierRemovalMR
public void testVectorClassificationWithOutlierRemovalMR() throws Exception
{    List<VectorWritable> points = getPointsWritable(REFERENCE);    pointsPath = getTestTempDirPath("points");    clusteringOutputPath = getTestTempDirPath("output");    classifiedOutputPath = getTestTempDirPath("classifiedClusters");    HadoopUtil.delete(conf, classifiedOutputPath);    conf = getConfiguration();    ClusteringTestUtils.writePointsToFile(points, true, new Path(pointsPath, "file1"), fs, conf);    runClustering(pointsPath, conf, false);    runClassificationWithOutlierRemoval(false);    collectVectorsForAssertion();    assertVectorsWithOutlierRemoval();}
709fc955c1b3ec6117ae23f3dd9e351b19174a71ecd742099eb7d867246e77b3
testVectorClassificationWithoutOutlierRemoval
public void testVectorClassificationWithoutOutlierRemoval() throws Exception
{    List<VectorWritable> points = getPointsWritable(REFERENCE);    pointsPath = getTestTempDirPath("points");    clusteringOutputPath = getTestTempDirPath("output");    classifiedOutputPath = getTestTempDirPath("classify");    conf = getConfiguration();    ClusteringTestUtils.writePointsToFile(points, new Path(pointsPath, "file1"), fs, conf);    runClustering(pointsPath, conf, true);    runClassificationWithoutOutlierRemoval();    collectVectorsForAssertion();    assertVectorsWithoutOutlierRemoval();}
b98cc6662cd6528f36693ada74dc853b743143cd63f876642bd63efe61e5aa0d
testVectorClassificationWithOutlierRemoval
public void testVectorClassificationWithOutlierRemoval() throws Exception
{    List<VectorWritable> points = getPointsWritable(REFERENCE);    pointsPath = getTestTempDirPath("points");    clusteringOutputPath = getTestTempDirPath("output");    classifiedOutputPath = getTestTempDirPath("classify");    conf = getConfiguration();    ClusteringTestUtils.writePointsToFile(points, new Path(pointsPath, "file1"), fs, conf);    runClustering(pointsPath, conf, true);    runClassificationWithOutlierRemoval(true);    collectVectorsForAssertion();    assertVectorsWithOutlierRemoval();}
8e026bf9879211824a4dc04f79f63c1114d1e15dbd4ff2ad748660cd473047b8
runClustering
private void runClustering(Path pointsPath, Configuration conf, Boolean runSequential) throws IOException, InterruptedException, ClassNotFoundException
{    CanopyDriver.run(conf, pointsPath, clusteringOutputPath, new ManhattanDistanceMeasure(), 3.1, 2.1, false, 0.0, runSequential);    Path finalClustersPath = new Path(clusteringOutputPath, "clusters-0-final");    ClusterClassifier.writePolicy(new CanopyClusteringPolicy(), finalClustersPath);}
d6ff392f321e0b0beda1c0d3f816d777c58a6129baf34b8048c5c23c143ad9c1
runClassificationWithoutOutlierRemoval
private void runClassificationWithoutOutlierRemoval() throws IOException, InterruptedException, ClassNotFoundException
{    ClusterClassificationDriver.run(getConfiguration(), pointsPath, clusteringOutputPath, classifiedOutputPath, 0.0, true, true);}
3a7b46515a2cf9bc27a7a0be8ca96edd4152ee89f8f2adc6a5ab32fc656509b7
runClassificationWithOutlierRemoval
private void runClassificationWithOutlierRemoval(boolean runSequential) throws IOException, InterruptedException, ClassNotFoundException
{    ClusterClassificationDriver.run(getConfiguration(), pointsPath, clusteringOutputPath, classifiedOutputPath, 0.73, true, runSequential);}
adafa03bb8a768107b594186b68cf4382e04f7cf4e37ca8a62aa7eafb8b284a3
collectVectorsForAssertion
private void collectVectorsForAssertion() throws IOException
{    Path[] partFilePaths = FileUtil.stat2Paths(fs.globStatus(classifiedOutputPath));    FileStatus[] listStatus = fs.listStatus(partFilePaths, PathFilters.partFilter());    for (FileStatus partFile : listStatus) {        SequenceFile.Reader classifiedVectors = new SequenceFile.Reader(fs, partFile.getPath(), conf);        Writable clusterIdAsKey = new IntWritable();        WeightedPropertyVectorWritable point = new WeightedPropertyVectorWritable();        while (classifiedVectors.next(clusterIdAsKey, point)) {            collectVector(clusterIdAsKey.toString(), point.getVector());        }    }}
0f4bcf90da77e6f795e90cfa6931725edc3de7003141992cecf2c9cc5d248068
collectVector
private void collectVector(String clusterId, Vector vector)
{    if ("0".equals(clusterId)) {        firstCluster.add(vector);    } else if ("1".equals(clusterId)) {        secondCluster.add(vector);    } else if ("2".equals(clusterId)) {        thirdCluster.add(vector);    }}
2045e04c5e1989cdba2cee9c4730a176aab56bcfbab309fa4aa1bc8acf0d3f98
assertVectorsWithOutlierRemoval
private void assertVectorsWithOutlierRemoval()
{    checkClustersWithOutlierRemoval();}
e8ffbf6e0ee82e2bd00d36618a2b54bedaed67bea229e96336f51ef6a5d2acfd
assertVectorsWithoutOutlierRemoval
private void assertVectorsWithoutOutlierRemoval()
{    assertFirstClusterWithoutOutlierRemoval();    assertSecondClusterWithoutOutlierRemoval();    assertThirdClusterWithoutOutlierRemoval();}
848fad3a258b9d3157c61e15781757150cafb125a6b230ea5cf22c7b0dfb8f9d
assertThirdClusterWithoutOutlierRemoval
private void assertThirdClusterWithoutOutlierRemoval()
{    Assert.assertEquals(2, thirdCluster.size());    for (Vector vector : thirdCluster) {        Assert.assertTrue(ArrayUtils.contains(new String[] { "{0:9.0,1:9.0}", "{0:8.0,1:8.0}" }, vector.asFormatString()));    }}
b9dbb5e1dcfca99f0fd8c5dcd8528e8a0fe4abeccc4f05926b1270e7baf88912
assertSecondClusterWithoutOutlierRemoval
private void assertSecondClusterWithoutOutlierRemoval()
{    Assert.assertEquals(4, secondCluster.size());    for (Vector vector : secondCluster) {        Assert.assertTrue(ArrayUtils.contains(new String[] { "{0:4.0,1:4.0}", "{0:5.0,1:4.0}", "{0:4.0,1:5.0}", "{0:5.0,1:5.0}" }, vector.asFormatString()));    }}
221a01e9830563581094bfa9df0a3abde2a84c931fd621a10d313eeb48909590
assertFirstClusterWithoutOutlierRemoval
private void assertFirstClusterWithoutOutlierRemoval()
{    Assert.assertEquals(3, firstCluster.size());    for (Vector vector : firstCluster) {        Assert.assertTrue(ArrayUtils.contains(new String[] { "{0:1.0,1:1.0}", "{0:2.0,1:1.0}", "{0:1.0,1:2.0}" }, vector.asFormatString()));    }}
0d7c9c18d94f4f97c8c367a27a525d50cb7a491a1ddb0d686197e0860f339913
checkClustersWithOutlierRemoval
private void checkClustersWithOutlierRemoval()
{    Set<String> reference = Sets.newHashSet("{0:9.0,1:9.0}", "{0:1.0,1:1.0}");    List<List<Vector>> clusters = Lists.newArrayList();    clusters.add(firstCluster);    clusters.add(secondCluster);    clusters.add(thirdCluster);    int singletonCnt = 0;    int emptyCnt = 0;    for (List<Vector> vList : clusters) {        if (vList.isEmpty()) {            emptyCnt++;        } else {            singletonCnt++;            assertEquals("expecting only singleton clusters; got size=" + vList.size(), 1, vList.size());            if (vList.get(0).getClass().equals(NamedVector.class)) {                Assert.assertTrue("not expecting cluster:" + ((NamedVector) vList.get(0)).getDelegate().asFormatString(), reference.contains(((NamedVector) vList.get(0)).getDelegate().asFormatString()));                reference.remove(((NamedVector) vList.get(0)).getDelegate().asFormatString());            } else if (vList.get(0).getClass().equals(RandomAccessSparseVector.class)) {                Assert.assertTrue("not expecting cluster:" + vList.get(0).asFormatString(), reference.contains(vList.get(0).asFormatString()));                reference.remove(vList.get(0).asFormatString());            }        }    }    Assert.assertEquals("Different number of empty clusters than expected!", 1, emptyCnt);    Assert.assertEquals("Different number of singletons than expected!", 2, singletonCnt);    Assert.assertEquals("Didn't match all reference clusters!", 0, reference.size());}
a80c1ff2f542e5f6f1efc7e9ba84dd45c8feb6779c5047ef4ea8d3e7e42642fe
writePointsToFile
public static void writePointsToFile(Iterable<VectorWritable> points, Path path, FileSystem fs, Configuration conf) throws IOException
{    writePointsToFile(points, false, path, fs, conf);}
7251077fc5c76847d0ef1ccb0a0db6fabac7fb110d2bed706a5aee6faa637173
writePointsToFile
public static void writePointsToFile(Iterable<VectorWritable> points, boolean intWritable, Path path, FileSystem fs, Configuration conf) throws IOException
{    SequenceFile.Writer writer = new SequenceFile.Writer(fs, conf, path, intWritable ? IntWritable.class : LongWritable.class, VectorWritable.class);    try {        int recNum = 0;        for (VectorWritable point : points) {            writer.append(intWritable ? new IntWritable(recNum++) : new LongWritable(recNum++), point);        }    } finally {        Closeables.close(writer, false);    }}
1e43c9c4da8c2c34253c23cacb15d036eae569d92c9d2f48b502e8e3f506fdeb
sampledCorpus
public static Matrix sampledCorpus(Matrix matrix, Random random, int numDocs, int numSamples, int numTopicsPerDoc)
{    Matrix corpus = new SparseRowMatrix(numDocs, matrix.numCols());    LDASampler modelSampler = new LDASampler(matrix, random);    Vector topicVector = new DenseVector(matrix.numRows());    for (int i = 0; i < numTopicsPerDoc; i++) {        int topic = random.nextInt(topicVector.size());        topicVector.set(topic, topicVector.get(topic) + 1);    }    for (int docId = 0; docId < numDocs; docId++) {        for (int sample : modelSampler.sample(topicVector, numSamples)) {            corpus.set(docId, sample, corpus.get(docId, sample) + 1);        }    }    return corpus;}
4c4f4a90c390ce4668abc3c84a57e40104a314607938413a9875707ec50f8f42
randomStructuredModel
public static Matrix randomStructuredModel(int numTopics, int numTerms)
{    return randomStructuredModel(numTopics, numTerms, new DoubleFunction() {        @Override        public double apply(double d) {            return 1.0 / (1 + Math.abs(d));        }    });}
b08179a3f5c2b720d80b2ce63af886043f6aa9a1d64d61bb968a9cfd8d315c52
apply
public double apply(double d)
{    return 1.0 / (1 + Math.abs(d));}
42a4ae24b451a8d29f5c7b3c3b63f508683cd0e87d18c0d1b98db0537ad5847c
randomStructuredModel
public static Matrix randomStructuredModel(int numTopics, int numTerms, DoubleFunction decay)
{    Matrix model = new DenseMatrix(numTopics, numTerms);    int width = numTerms / numTopics;    for (int topic = 0; topic < numTopics; topic++) {        int topicCentroid = width * (1 + topic);        for (int i = 0; i < numTerms; i++) {            int distance = Math.abs(topicCentroid - i);            if (distance > numTerms / 2) {                distance = numTerms - distance;            }            double v = decay.apply(distance);            model.set(topic, i, v);        }    }    return model;}
27788abf491c99ef549f340a4a7605efa9a104c2e56df45e7d9e9e1ad5173a0d
sample
public int[] sample(Vector topicDistribution, int numSamples)
{    Preconditions.checkNotNull(topicDistribution);    Preconditions.checkArgument(numSamples > 0, "numSamples must be positive");    Preconditions.checkArgument(topicDistribution.size() == samplers.length, "topicDistribution must have same cardinality as the sampling model");    int[] samples = new int[numSamples];    Sampler topicSampler = new Sampler(random, topicDistribution);    for (int i = 0; i < numSamples; i++) {        samples[i] = samplers[topicSampler.sample()].sample();    }    return samples;}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    super.setUp();    Configuration conf = getConfiguration();    fs = FileSystem.get(conf);}
45b301bdb82e2f23e4ab9e44d28220d7c1a44f66709da0e6bb8dab4fbffb5178
tweakValue
private static Vector tweakValue(Vector point)
{    return point.plus(0.1);}
79301ef42f67923503b3a7014cc7942f4011f8a58c56e181bb891da440117e9d
testFuzzyKMeansSeqJob
public void testFuzzyKMeansSeqJob() throws Exception
{    List<VectorWritable> points = TestKmeansClustering.getPointsWritable(TestKmeansClustering.REFERENCE);    Path pointsPath = getTestTempDirPath("points");    Path clustersPath = getTestTempDirPath("clusters");    Configuration conf = getConfiguration();    ClusteringTestUtils.writePointsToFile(points, new Path(pointsPath, "file1"), fs, conf);    for (int k = 0; k < points.size(); k++) {        System.out.println("testKFuzzyKMeansMRJob k= " + k);                SequenceFile.Writer writer = new SequenceFile.Writer(fs, conf, new Path(clustersPath, "part-00000"), Text.class, SoftCluster.class);        try {            for (int i = 0; i < k + 1; i++) {                Vector vec = tweakValue(points.get(i).get());                SoftCluster cluster = new SoftCluster(vec, i, measure);                /* add the center so the centroid will be correct upon output */                cluster.observe(cluster.getCenter(), 1);                                writer.append(new Text(cluster.getIdentifier()), cluster);            }        } finally {            Closeables.close(writer, false);        }                Path output = getTestTempDirPath("output" + k);        /*      FuzzyKMeansDriver.runJob(pointsPath,                                     clustersPath,                                     output,                                     EuclideanDistanceMeasure.class.getName(),                                     0.001,                                     2,                                     k + 1,                                     2,                                     false,                                     true,                                     0);      */        String[] args = { optKey(DefaultOptionCreator.INPUT_OPTION), pointsPath.toString(), optKey(DefaultOptionCreator.CLUSTERS_IN_OPTION), clustersPath.toString(), optKey(DefaultOptionCreator.OUTPUT_OPTION), output.toString(), optKey(DefaultOptionCreator.DISTANCE_MEASURE_OPTION), EuclideanDistanceMeasure.class.getName(), optKey(DefaultOptionCreator.CONVERGENCE_DELTA_OPTION), "0.001", optKey(DefaultOptionCreator.MAX_ITERATIONS_OPTION), "2", optKey(FuzzyKMeansDriver.M_OPTION), "2.0", optKey(DefaultOptionCreator.CLUSTERING_OPTION), optKey(DefaultOptionCreator.EMIT_MOST_LIKELY_OPTION), optKey(DefaultOptionCreator.OVERWRITE_OPTION), optKey(DefaultOptionCreator.METHOD_OPTION), DefaultOptionCreator.SEQUENTIAL_METHOD };        FuzzyKMeansDriver.main(args);        long count = HadoopUtil.countRecords(new Path(output, "clusteredPoints/part-m-0"), conf);        assertTrue(count > 0);    }}
dd29a5c128e0011b3eb93c12c680fe0f5c66fb378db17daa072ae91ef41b5a97
testFuzzyKMeansMRJob
public void testFuzzyKMeansMRJob() throws Exception
{    List<VectorWritable> points = TestKmeansClustering.getPointsWritable(TestKmeansClustering.REFERENCE);    Path pointsPath = getTestTempDirPath("points");    Path clustersPath = getTestTempDirPath("clusters");    Configuration conf = getConfiguration();    ClusteringTestUtils.writePointsToFile(points, new Path(pointsPath, "file1"), fs, conf);    for (int k = 0; k < points.size(); k++) {        System.out.println("testKFuzzyKMeansMRJob k= " + k);                SequenceFile.Writer writer = new SequenceFile.Writer(fs, conf, new Path(clustersPath, "part-00000"), Text.class, SoftCluster.class);        try {            for (int i = 0; i < k + 1; i++) {                Vector vec = tweakValue(points.get(i).get());                SoftCluster cluster = new SoftCluster(vec, i, measure);                /* add the center so the centroid will be correct upon output */                cluster.observe(cluster.getCenter(), 1);                                writer.append(new Text(cluster.getIdentifier()), cluster);            }        } finally {            Closeables.close(writer, false);        }                Path output = getTestTempDirPath("output" + k);        /*      FuzzyKMeansDriver.runJob(pointsPath,                                     clustersPath,                                     output,                                     EuclideanDistanceMeasure.class.getName(),                                     0.001,                                     2,                                     k + 1,                                     2,                                     false,                                     true,                                     0);      */        String[] args = { optKey(DefaultOptionCreator.INPUT_OPTION), pointsPath.toString(), optKey(DefaultOptionCreator.CLUSTERS_IN_OPTION), clustersPath.toString(), optKey(DefaultOptionCreator.OUTPUT_OPTION), output.toString(), optKey(DefaultOptionCreator.DISTANCE_MEASURE_OPTION), EuclideanDistanceMeasure.class.getName(), optKey(DefaultOptionCreator.CONVERGENCE_DELTA_OPTION), "0.001", optKey(DefaultOptionCreator.MAX_ITERATIONS_OPTION), "2", optKey(FuzzyKMeansDriver.M_OPTION), "2.0", optKey(DefaultOptionCreator.CLUSTERING_OPTION), optKey(DefaultOptionCreator.EMIT_MOST_LIKELY_OPTION), optKey(DefaultOptionCreator.OVERWRITE_OPTION) };        ToolRunner.run(getConfiguration(), new FuzzyKMeansDriver(), args);        long count = HadoopUtil.countRecords(new Path(output, "clusteredPoints/part-m-00000"), conf);        assertTrue(count > 0);    }}
ce3ea127329bba9938a9c737c1ac9e457510e611559616826cd2f08be34f363d
newDMClassifier
private static ClusterClassifier newDMClassifier()
{    List<Cluster> models = Lists.newArrayList();    DistanceMeasure measure = new ManhattanDistanceMeasure();    models.add(new DistanceMeasureCluster(new DenseVector(2).assign(1), 0, measure));    models.add(new DistanceMeasureCluster(new DenseVector(2), 1, measure));    models.add(new DistanceMeasureCluster(new DenseVector(2).assign(-1), 2, measure));    return new ClusterClassifier(models, new KMeansClusteringPolicy());}
6b3b4803ce1dae627773579104b9de6e6f45535dc208b3f28a6b61e4dcb0d8e8
newKlusterClassifier
private static ClusterClassifier newKlusterClassifier()
{    List<Cluster> models = Lists.newArrayList();    DistanceMeasure measure = new ManhattanDistanceMeasure();    models.add(new org.apache.mahout.clustering.kmeans.Kluster(new DenseVector(2).assign(1), 0, measure));    models.add(new org.apache.mahout.clustering.kmeans.Kluster(new DenseVector(2), 1, measure));    models.add(new org.apache.mahout.clustering.kmeans.Kluster(new DenseVector(2).assign(-1), 2, measure));    return new ClusterClassifier(models, new KMeansClusteringPolicy());}
099b1e0b87354fda04e6b0d2723598e548b752fd542aaf6ed95a2d66292a0252
newCosineKlusterClassifier
private static ClusterClassifier newCosineKlusterClassifier()
{    List<Cluster> models = Lists.newArrayList();    DistanceMeasure measure = new CosineDistanceMeasure();    models.add(new org.apache.mahout.clustering.kmeans.Kluster(new DenseVector(2).assign(1), 0, measure));    models.add(new org.apache.mahout.clustering.kmeans.Kluster(new DenseVector(2), 1, measure));    models.add(new org.apache.mahout.clustering.kmeans.Kluster(new DenseVector(2).assign(-1), 2, measure));    return new ClusterClassifier(models, new KMeansClusteringPolicy());}
87288d86544c65dc4edcf881749a192b6a89d64d0a0e7ba34ac8b960a0576407
newSoftClusterClassifier
private static ClusterClassifier newSoftClusterClassifier()
{    List<Cluster> models = Lists.newArrayList();    DistanceMeasure measure = new ManhattanDistanceMeasure();    models.add(new SoftCluster(new DenseVector(2).assign(1), 0, measure));    models.add(new SoftCluster(new DenseVector(2), 1, measure));    models.add(new SoftCluster(new DenseVector(2).assign(-1), 2, measure));    return new ClusterClassifier(models, new FuzzyKMeansClusteringPolicy());}
f893ba5d790d5db490d65e623398acce096d2012247d494fca6bb8b962b367e0
writeAndRead
private ClusterClassifier writeAndRead(ClusterClassifier classifier) throws IOException
{    Path path = new Path(getTestTempDirPath(), "output");    classifier.writeToSeqFiles(path);    ClusterClassifier newClassifier = new ClusterClassifier();    newClassifier.readFromSeqFiles(getConfiguration(), path);    return newClassifier;}
5c796a5c49b8d5247743c90352359898f891cecf1fc71f7be0d2163725490ac3
testDMClusterClassification
public void testDMClusterClassification()
{    ClusterClassifier classifier = newDMClassifier();    Vector pdf = classifier.classify(new DenseVector(2));    assertEquals("[0,0]", "[0.2,0.6,0.2]", AbstractCluster.formatVector(pdf, null));    pdf = classifier.classify(new DenseVector(2).assign(2));    assertEquals("[2,2]", "[0.493,0.296,0.211]", AbstractCluster.formatVector(pdf, null));}
a7300f9bd818a4be4db5481987e671bef28008afd8f75989176178bb724760e2
testClusterClassification
public void testClusterClassification()
{    ClusterClassifier classifier = newKlusterClassifier();    Vector pdf = classifier.classify(new DenseVector(2));    assertEquals("[0,0]", "[0.2,0.6,0.2]", AbstractCluster.formatVector(pdf, null));    pdf = classifier.classify(new DenseVector(2).assign(2));    assertEquals("[2,2]", "[0.493,0.296,0.211]", AbstractCluster.formatVector(pdf, null));}
c548dfd308028d13634d9a119af78e996c40ee6c18ca79592475bde4e5491134
testSoftClusterClassification
public void testSoftClusterClassification()
{    ClusterClassifier classifier = newSoftClusterClassifier();    Vector pdf = classifier.classify(new DenseVector(2));    assertEquals("[0,0]", "[0.0,1.0,0.0]", AbstractCluster.formatVector(pdf, null));    pdf = classifier.classify(new DenseVector(2).assign(2));    assertEquals("[2,2]", "[0.735,0.184,0.082]", AbstractCluster.formatVector(pdf, null));}
0b2d09153904d74b2bc7a7b31b11c43cee23c0909ad80a15c817ff54cf507f03
testDMClassifierSerialization
public void testDMClassifierSerialization() throws Exception
{    ClusterClassifier classifier = newDMClassifier();    ClusterClassifier classifierOut = writeAndRead(classifier);    assertEquals(classifier.getModels().size(), classifierOut.getModels().size());    assertEquals(classifier.getModels().get(0).getClass().getName(), classifierOut.getModels().get(0).getClass().getName());}
e1b270963c363fd3707ffaa8e3d24ea5676e06e8536ae4b23850283a99852210
testClusterClassifierSerialization
public void testClusterClassifierSerialization() throws Exception
{    ClusterClassifier classifier = newKlusterClassifier();    ClusterClassifier classifierOut = writeAndRead(classifier);    assertEquals(classifier.getModels().size(), classifierOut.getModels().size());    assertEquals(classifier.getModels().get(0).getClass().getName(), classifierOut.getModels().get(0).getClass().getName());}
a6f24e0ccd7bc6af02deb59709d72fd7af2093644391a508c2a9a5bdf5161795
testSoftClusterClassifierSerialization
public void testSoftClusterClassifierSerialization() throws Exception
{    ClusterClassifier classifier = newSoftClusterClassifier();    ClusterClassifier classifierOut = writeAndRead(classifier);    assertEquals(classifier.getModels().size(), classifierOut.getModels().size());    assertEquals(classifier.getModels().get(0).getClass().getName(), classifierOut.getModels().get(0).getClass().getName());}
a77d802c999014234675ebb6888d56d075f89b3b0946d273a3394ce7a4308641
testClusterIteratorKMeans
public void testClusterIteratorKMeans()
{    List<Vector> data = TestKmeansClustering.getPoints(TestKmeansClustering.REFERENCE);    ClusterClassifier prior = newKlusterClassifier();    ClusterClassifier posterior = ClusterIterator.iterate(data, prior, 5);    assertEquals(3, posterior.getModels().size());    for (Cluster cluster : posterior.getModels()) {        System.out.println(cluster.asFormatString(null));    }}
538fa8d5932190ffc7cf57cb4308bcf0f145a83053b482cafe130325d71e09c9
testClusterIteratorDirichlet
public void testClusterIteratorDirichlet()
{    List<Vector> data = TestKmeansClustering.getPoints(TestKmeansClustering.REFERENCE);    ClusterClassifier prior = newKlusterClassifier();    ClusterClassifier posterior = ClusterIterator.iterate(data, prior, 5);    assertEquals(3, posterior.getModels().size());    for (Cluster cluster : posterior.getModels()) {        System.out.println(cluster.asFormatString(null));    }}
3a74ad953f94361ecd80feebfdba94c249f8eba08e08b382d9b1b81d345d792f
testSeqFileClusterIteratorKMeans
public void testSeqFileClusterIteratorKMeans() throws IOException
{    Path pointsPath = getTestTempDirPath("points");    Path priorPath = getTestTempDirPath("prior");    Path outPath = getTestTempDirPath("output");    Configuration conf = getConfiguration();    FileSystem fs = FileSystem.get(pointsPath.toUri(), conf);    List<VectorWritable> points = TestKmeansClustering.getPointsWritable(TestKmeansClustering.REFERENCE);    ClusteringTestUtils.writePointsToFile(points, new Path(pointsPath, "file1"), fs, conf);    Path path = new Path(priorPath, "priorClassifier");    ClusterClassifier prior = newKlusterClassifier();    prior.writeToSeqFiles(path);    assertEquals(3, prior.getModels().size());    System.out.println("Prior");    for (Cluster cluster : prior.getModels()) {        System.out.println(cluster.asFormatString(null));    }    ClusterIterator.iterateSeq(conf, pointsPath, path, outPath, 5);    for (int i = 1; i <= 4; i++) {        System.out.println("Classifier-" + i);        ClusterClassifier posterior = new ClusterClassifier();        String name = i == 4 ? "clusters-4-final" : "clusters-" + i;        posterior.readFromSeqFiles(conf, new Path(outPath, name));        assertEquals(3, posterior.getModels().size());        for (Cluster cluster : posterior.getModels()) {            System.out.println(cluster.asFormatString(null));        }    }}
b98e0b5b6eb8b15981f4ae7d165d213dd2444596b00a11a89784a8ea57e5fb78
testMRFileClusterIteratorKMeans
public void testMRFileClusterIteratorKMeans() throws Exception
{    Path pointsPath = getTestTempDirPath("points");    Path priorPath = getTestTempDirPath("prior");    Path outPath = getTestTempDirPath("output");    Configuration conf = getConfiguration();    FileSystem fs = FileSystem.get(pointsPath.toUri(), conf);    List<VectorWritable> points = TestKmeansClustering.getPointsWritable(TestKmeansClustering.REFERENCE);    ClusteringTestUtils.writePointsToFile(points, new Path(pointsPath, "file1"), fs, conf);    Path path = new Path(priorPath, "priorClassifier");    ClusterClassifier prior = newKlusterClassifier();    prior.writeToSeqFiles(path);    ClusteringPolicy policy = new KMeansClusteringPolicy();    ClusterClassifier.writePolicy(policy, path);    assertEquals(3, prior.getModels().size());    System.out.println("Prior");    for (Cluster cluster : prior.getModels()) {        System.out.println(cluster.asFormatString(null));    }    ClusterIterator.iterateMR(conf, pointsPath, path, outPath, 5);    for (int i = 1; i <= 4; i++) {        System.out.println("Classifier-" + i);        ClusterClassifier posterior = new ClusterClassifier();        String name = i == 4 ? "clusters-4-final" : "clusters-" + i;        posterior.readFromSeqFiles(conf, new Path(outPath, name));        assertEquals(3, posterior.getModels().size());        for (Cluster cluster : posterior.getModels()) {            System.out.println(cluster.asFormatString(null));        }    }}
539c8254c5f8baf7468e09bf4294264de7a5950db02d563b600f37759ba045db
testCosineKlusterClassification
public void testCosineKlusterClassification()
{    ClusterClassifier classifier = newCosineKlusterClassifier();    Vector pdf = classifier.classify(new DenseVector(2));    assertEquals("[0,0]", "[0.333,0.333,0.333]", AbstractCluster.formatVector(pdf, null));    pdf = classifier.classify(new DenseVector(2).assign(2));    assertEquals("[2,2]", "[0.429,0.429,0.143]", AbstractCluster.formatVector(pdf, null));}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    super.setUp();    Configuration conf = getConfiguration();    fs = FileSystem.get(conf);}
0a28500ed96929b305e206e2747fe2cf0665393e55c9a75c52adcd563657336f
getPointsWritable
public static List<VectorWritable> getPointsWritable(double[][] raw)
{    List<VectorWritable> points = Lists.newArrayList();    for (double[] fr : raw) {        Vector vec = new RandomAccessSparseVector(fr.length);        vec.assign(fr);        points.add(new VectorWritable(vec));    }    return points;}
78ad5df2c1235504e4ea220a1d5cc23294f39dbe8a10278ea0981643f9652279
getPointsWritableDenseVector
public static List<VectorWritable> getPointsWritableDenseVector(double[][] raw)
{    List<VectorWritable> points = Lists.newArrayList();    for (double[] fr : raw) {        Vector vec = new DenseVector(fr.length);        vec.assign(fr);        points.add(new VectorWritable(vec));    }    return points;}
e6ff03e96ce673a3e2c0fcb4baf24d61802507bc3989a38d8c1379f58276f4d5
getPoints
public static List<Vector> getPoints(double[][] raw)
{    List<Vector> points = Lists.newArrayList();    for (double[] fr : raw) {        Vector vec = new SequentialAccessSparseVector(fr.length);        vec.assign(fr);        points.add(vec);    }    return points;}
43e0d021e0b005239aed74d99c5a38e75f16c408fc1a4fe64f307d170c0d6c96
testKMeansSeqJob
public void testKMeansSeqJob() throws Exception
{    DistanceMeasure measure = new EuclideanDistanceMeasure();    List<VectorWritable> points = getPointsWritable(REFERENCE);    Path pointsPath = getTestTempDirPath("points");    Path clustersPath = getTestTempDirPath("clusters");    Configuration conf = getConfiguration();    ClusteringTestUtils.writePointsToFile(points, true, new Path(pointsPath, "file1"), fs, conf);    ClusteringTestUtils.writePointsToFile(points, true, new Path(pointsPath, "file2"), fs, conf);    for (int k = 1; k < points.size(); k++) {        System.out.println("testKMeansMRJob k= " + k);                Path path = new Path(clustersPath, "part-00000");        FileSystem fs = FileSystem.get(path.toUri(), conf);        SequenceFile.Writer writer = new SequenceFile.Writer(fs, conf, path, Text.class, Kluster.class);        try {            for (int i = 0; i < k + 1; i++) {                Vector vec = points.get(i).get();                Kluster cluster = new Kluster(vec, i, measure);                                cluster.observe(cluster.getCenter(), 1);                writer.append(new Text(cluster.getIdentifier()), cluster);            }        } finally {            Closeables.close(writer, false);        }                Path outputPath = getTestTempDirPath("output" + k);        String[] args = { optKey(DefaultOptionCreator.INPUT_OPTION), pointsPath.toString(), optKey(DefaultOptionCreator.CLUSTERS_IN_OPTION), clustersPath.toString(), optKey(DefaultOptionCreator.OUTPUT_OPTION), outputPath.toString(), optKey(DefaultOptionCreator.DISTANCE_MEASURE_OPTION), EuclideanDistanceMeasure.class.getName(), optKey(DefaultOptionCreator.CONVERGENCE_DELTA_OPTION), "0.001", optKey(DefaultOptionCreator.MAX_ITERATIONS_OPTION), "2", optKey(DefaultOptionCreator.CLUSTERING_OPTION), optKey(DefaultOptionCreator.OVERWRITE_OPTION), optKey(DefaultOptionCreator.METHOD_OPTION), DefaultOptionCreator.SEQUENTIAL_METHOD };        ToolRunner.run(conf, new KMeansDriver(), args);                Path clusteredPointsPath = new Path(outputPath, "clusteredPoints");        int[] expect = EXPECTED_NUM_POINTS[k];        DummyOutputCollector<IntWritable, WeightedPropertyVectorWritable> collector = new DummyOutputCollector<>();                for (Pair<IntWritable, WeightedPropertyVectorWritable> record : new SequenceFileIterable<IntWritable, WeightedPropertyVectorWritable>(new Path(clusteredPointsPath, "part-m-0"), conf)) {            collector.collect(record.getFirst(), record.getSecond());        }        assertEquals("clusters[" + k + ']', expect.length, collector.getKeys().size());    }}
a189763c2c89605c640e3a956d6769a69a6029867e97ef367687bb9836de7ee4
testKMeansSeqJobDenseVector
public void testKMeansSeqJobDenseVector() throws Exception
{    DistanceMeasure measure = new EuclideanDistanceMeasure();    List<VectorWritable> points = getPointsWritableDenseVector(REFERENCE);    Path pointsPath = getTestTempDirPath("points");    Path clustersPath = getTestTempDirPath("clusters");    Configuration conf = getConfiguration();    ClusteringTestUtils.writePointsToFile(points, true, new Path(pointsPath, "file1"), fs, conf);    ClusteringTestUtils.writePointsToFile(points, true, new Path(pointsPath, "file2"), fs, conf);    for (int k = 1; k < points.size(); k++) {        System.out.println("testKMeansMRJob k= " + k);                Path path = new Path(clustersPath, "part-00000");        FileSystem fs = FileSystem.get(path.toUri(), conf);        SequenceFile.Writer writer = new SequenceFile.Writer(fs, conf, path, Text.class, Kluster.class);        try {            for (int i = 0; i < k + 1; i++) {                Vector vec = points.get(i).get();                Kluster cluster = new Kluster(vec, i, measure);                                cluster.observe(cluster.getCenter(), 1);                writer.append(new Text(cluster.getIdentifier()), cluster);            }        } finally {            Closeables.close(writer, false);        }                Path outputPath = getTestTempDirPath("output" + k);        String[] args = { optKey(DefaultOptionCreator.INPUT_OPTION), pointsPath.toString(), optKey(DefaultOptionCreator.CLUSTERS_IN_OPTION), clustersPath.toString(), optKey(DefaultOptionCreator.OUTPUT_OPTION), outputPath.toString(), optKey(DefaultOptionCreator.DISTANCE_MEASURE_OPTION), EuclideanDistanceMeasure.class.getName(), optKey(DefaultOptionCreator.CONVERGENCE_DELTA_OPTION), "0.001", optKey(DefaultOptionCreator.MAX_ITERATIONS_OPTION), "2", optKey(DefaultOptionCreator.CLUSTERING_OPTION), optKey(DefaultOptionCreator.OVERWRITE_OPTION), optKey(DefaultOptionCreator.METHOD_OPTION), DefaultOptionCreator.SEQUENTIAL_METHOD };        ToolRunner.run(conf, new KMeansDriver(), args);                Path clusteredPointsPath = new Path(outputPath, "clusteredPoints");        int[] expect = EXPECTED_NUM_POINTS[k];        DummyOutputCollector<IntWritable, WeightedPropertyVectorWritable> collector = new DummyOutputCollector<>();                for (Pair<IntWritable, WeightedPropertyVectorWritable> record : new SequenceFileIterable<IntWritable, WeightedPropertyVectorWritable>(new Path(clusteredPointsPath, "part-m-0"), conf)) {            collector.collect(record.getFirst(), record.getSecond());        }        assertEquals("clusters[" + k + ']', expect.length, collector.getKeys().size());    }}
604b9c65f3dae2e6c641dddd0caeabc6ec7bdc9302becd013c8f4eb9bf81044e
testKMeansMRJob
public void testKMeansMRJob() throws Exception
{    DistanceMeasure measure = new EuclideanDistanceMeasure();    List<VectorWritable> points = getPointsWritable(REFERENCE);    Path pointsPath = getTestTempDirPath("points");    Path clustersPath = getTestTempDirPath("clusters");    Configuration conf = getConfiguration();    ClusteringTestUtils.writePointsToFile(points, true, new Path(pointsPath, "file1"), fs, conf);    ClusteringTestUtils.writePointsToFile(points, true, new Path(pointsPath, "file2"), fs, conf);    for (int k = 1; k < points.size(); k += 3) {        System.out.println("testKMeansMRJob k= " + k);                Path path = new Path(clustersPath, "part-00000");        FileSystem fs = FileSystem.get(path.toUri(), conf);        SequenceFile.Writer writer = new SequenceFile.Writer(fs, conf, path, Text.class, Kluster.class);        try {            for (int i = 0; i < k + 1; i++) {                Vector vec = points.get(i).get();                Kluster cluster = new Kluster(vec, i, measure);                                cluster.observe(cluster.getCenter(), 1);                writer.append(new Text(cluster.getIdentifier()), cluster);            }        } finally {            Closeables.close(writer, false);        }                Path outputPath = getTestTempDirPath("output" + k);        String[] args = { optKey(DefaultOptionCreator.INPUT_OPTION), pointsPath.toString(), optKey(DefaultOptionCreator.CLUSTERS_IN_OPTION), clustersPath.toString(), optKey(DefaultOptionCreator.OUTPUT_OPTION), outputPath.toString(), optKey(DefaultOptionCreator.DISTANCE_MEASURE_OPTION), EuclideanDistanceMeasure.class.getName(), optKey(DefaultOptionCreator.CONVERGENCE_DELTA_OPTION), "0.001", optKey(DefaultOptionCreator.MAX_ITERATIONS_OPTION), "2", optKey(DefaultOptionCreator.CLUSTERING_OPTION), optKey(DefaultOptionCreator.OVERWRITE_OPTION) };        ToolRunner.run(getConfiguration(), new KMeansDriver(), args);                Path clusteredPointsPath = new Path(outputPath, "clusteredPoints");                int[] expect = EXPECTED_NUM_POINTS[k];        DummyOutputCollector<IntWritable, WeightedPropertyVectorWritable> collector = new DummyOutputCollector<>();                for (Pair<IntWritable, WeightedPropertyVectorWritable> record : new SequenceFileIterable<IntWritable, WeightedPropertyVectorWritable>(new Path(clusteredPointsPath, "part-m-00000"), conf)) {            collector.collect(record.getFirst(), record.getSecond());        }        assertEquals("clusters[" + k + ']', expect.length, collector.getKeys().size());    }}
8c90a06333247921b6c67612609a4bb56cb2a4f26343bd6ad33042b8c4cda0cb
testKMeansWithCanopyClusterInput
public void testKMeansWithCanopyClusterInput() throws Exception
{    List<VectorWritable> points = getPointsWritable(REFERENCE);    Path pointsPath = getTestTempDirPath("points");    Configuration conf = getConfiguration();    ClusteringTestUtils.writePointsToFile(points, true, new Path(pointsPath, "file1"), fs, conf);    ClusteringTestUtils.writePointsToFile(points, true, new Path(pointsPath, "file2"), fs, conf);    Path outputPath = getTestTempDirPath("output");        CanopyDriver.run(conf, pointsPath, outputPath, new ManhattanDistanceMeasure(), 3.1, 2.1, false, 0.0, false);    DummyOutputCollector<Text, ClusterWritable> collector1 = new DummyOutputCollector<>();    FileStatus[] outParts = FileSystem.get(conf).globStatus(new Path(outputPath, "clusters-0-final/*-0*"));    for (FileStatus outPartStat : outParts) {        for (Pair<Text, ClusterWritable> record : new SequenceFileIterable<Text, ClusterWritable>(outPartStat.getPath(), conf)) {            collector1.collect(record.getFirst(), record.getSecond());        }    }    boolean got15 = false;    boolean got43 = false;    int count = 0;    for (Text k : collector1.getKeys()) {        count++;        List<ClusterWritable> vl = collector1.getValue(k);        assertEquals("non-singleton centroid!", 1, vl.size());        ClusterWritable clusterWritable = vl.get(0);        Vector v = clusterWritable.getValue().getCenter();        assertEquals("cetriod vector is wrong length", 2, v.size());        if ((Math.abs(v.get(0) - 1.5) < EPSILON) && (Math.abs(v.get(1) - 1.5) < EPSILON) && !got15) {            got15 = true;        } else if ((Math.abs(v.get(0) - 4.333333333333334) < EPSILON) && (Math.abs(v.get(1) - 4.333333333333334) < EPSILON) && !got43) {            got43 = true;        } else {            fail("got unexpected center: " + v + " [" + v.getClass().toString() + ']');        }    }    assertEquals("got unexpected number of centers", 2, count);        Path kmeansOutput = new Path(outputPath, "kmeans");    KMeansDriver.run(getConfiguration(), pointsPath, new Path(outputPath, "clusters-0-final"), kmeansOutput, 0.001, 10, true, 0.0, false);        Path clusteredPointsPath = new Path(kmeansOutput, "clusteredPoints");    DummyOutputCollector<IntWritable, WeightedPropertyVectorWritable> collector = new DummyOutputCollector<>();        for (Pair<IntWritable, WeightedPropertyVectorWritable> record : new SequenceFileIterable<IntWritable, WeightedPropertyVectorWritable>(new Path(clusteredPointsPath, "part-m-00000"), conf)) {        collector.collect(record.getFirst(), record.getSecond());    }    for (IntWritable k : collector.getKeys()) {        List<WeightedPropertyVectorWritable> wpvList = collector.getValue(k);        assertTrue("empty cluster!", !wpvList.isEmpty());        if (wpvList.get(0).getVector().get(0) <= 2.0) {            for (WeightedPropertyVectorWritable wv : wpvList) {                Vector v = wv.getVector();                int idx = v.maxValueIndex();                assertTrue("bad cluster!", v.get(idx) <= 2.0);            }            assertEquals("Wrong size cluster", 4, wpvList.size());        } else {            for (WeightedPropertyVectorWritable wv : wpvList) {                Vector v = wv.getVector();                int idx = v.minValueIndex();                assertTrue("bad cluster!", v.get(idx) > 2.0);            }            assertEquals("Wrong size cluster", 5, wpvList.size());        }    }}
dc9d17a10c180108f239b2e6e6ae0118cd41e0d85170c9003380e53e3f4e905f
getPoints
private static List<VectorWritable> getPoints()
{    List<VectorWritable> points = Lists.newArrayList();    for (double[] fr : RAW) {        Vector vec = new RandomAccessSparseVector(fr.length);        vec.assign(fr);        points.add(new VectorWritable(vec));    }    return points;}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    super.setUp();    Configuration conf = getConfiguration();    fs = FileSystem.get(conf);}
d9a7448035079c6f2cfe6310fdf739f649da7f28c8e2b32085184ab9e85eca32
testRandomSeedGenerator
public void testRandomSeedGenerator() throws Exception
{    List<VectorWritable> points = getPoints();    Job job = new Job();    Configuration conf = job.getConfiguration();    job.setMapOutputValueClass(VectorWritable.class);    Path input = getTestTempFilePath("random-input");    Path output = getTestTempDirPath("random-output");    ClusteringTestUtils.writePointsToFile(points, input, fs, conf);    RandomSeedGenerator.buildRandom(conf, input, output, 4, new ManhattanDistanceMeasure());    int clusterCount = 0;    Collection<Integer> set = Sets.newHashSet();    for (ClusterWritable clusterWritable : new SequenceFileValueIterable<ClusterWritable>(new Path(output, "part-randomSeed"), true, conf)) {        clusterCount++;        Cluster cluster = clusterWritable.getValue();        int id = cluster.getId();                assertTrue(set.add(id));        Vector v = cluster.getCenter();                assertVectorEquals(RAW[id], v);    }        assertEquals(4, clusterCount);}
4043c219a834abd1cdaf298044385460ff15aa58b5c8a93d3705c7f9dded109e
testRandomSeedGeneratorSeeded
public void testRandomSeedGeneratorSeeded() throws Exception
{    List<VectorWritable> points = getPoints();    Job job = new Job();    Configuration conf = job.getConfiguration();    job.setMapOutputValueClass(VectorWritable.class);    Path input = getTestTempFilePath("random-input");    Path output = getTestTempDirPath("random-output");    ClusteringTestUtils.writePointsToFile(points, input, fs, conf);    RandomSeedGenerator.buildRandom(conf, input, output, 4, new ManhattanDistanceMeasure(), 1L);    int clusterCount = 0;    Collection<Integer> set = Sets.newHashSet();    for (ClusterWritable clusterWritable : new SequenceFileValueIterable<ClusterWritable>(new Path(output, "part-randomSeed"), true, conf)) {        clusterCount++;        Cluster cluster = clusterWritable.getValue();        int id = cluster.getId();                assertTrue(set.add(id));        Vector v = cluster.getCenter();                assertVectorEquals(RAW[id], v);    }        assertEquals(4, clusterCount);}
e346494fe9ba95ba60a85af56cf70c1bcf2f506a870613d1e6b2be6659dc7cd8
testBuildRandomSeededSameInitalClusters
public void testBuildRandomSeededSameInitalClusters() throws Exception
{    List<VectorWritable> points = getPoints();    Job job = new Job();    Configuration conf = job.getConfiguration();    job.setMapOutputValueClass(VectorWritable.class);    Path input = getTestTempFilePath("random-input");    Path output = getTestTempDirPath("random-output");    ClusteringTestUtils.writePointsToFile(points, input, fs, conf);    long randSeed = 1;    RandomSeedGenerator.buildRandom(conf, input, output, 4, new ManhattanDistanceMeasure(), randSeed);    int[] clusterIDSeq = new int[4];    /**     * run through all clusters once and set sequence of IDs     */    int clusterCount = 0;    for (ClusterWritable clusterWritable : new SequenceFileValueIterable<ClusterWritable>(new Path(output, "part-randomSeed"), true, conf)) {        Cluster cluster = clusterWritable.getValue();        clusterIDSeq[clusterCount] = cluster.getId();        clusterCount++;    }    /* Rebuild cluster and run through again making sure all IDs are in the same random sequence     * Needs a better test because in this case passes when seeded with 1 and 2  fails with 1, 3     * passes when set to two */    RandomSeedGenerator.buildRandom(conf, input, output, 4, new ManhattanDistanceMeasure(), randSeed);    clusterCount = 0;    for (ClusterWritable clusterWritable : new SequenceFileValueIterable<ClusterWritable>(new Path(output, "part-randomSeed"), true, conf)) {        Cluster cluster = clusterWritable.getValue();                assertEquals(clusterIDSeq[clusterCount], cluster.getId());        clusterCount++;    }}
05bb930645015985c6063126266a95907e10fc74d5122ee2b60339ff61cbc9f7
assertVectorEquals
private static void assertVectorEquals(double[] raw, Vector v)
{    assertEquals(raw.length, v.size());    for (int i = 0; i < raw.length; i++) {        assertEquals(raw[i], v.getQuick(i), EPSILON);    }}
c6336142653364dc323413380f9d2b207a8be89bfa3f93b5306a4b78a2c5bcb1
testInMemoryCVB0
public void testInMemoryCVB0() throws Exception
{    String[] terms = new String[26];    for (int i = 0; i < terms.length; i++) {        terms[i] = String.valueOf((char) (i + 'a'));    }    int numGeneratingTopics = 3;    int numTerms = 26;    Matrix matrix = ClusteringTestUtils.randomStructuredModel(numGeneratingTopics, numTerms, new DoubleFunction() {        @Override        public double apply(double d) {            return 1.0 / Math.pow(d + 1.0, 2);        }    });    int numDocs = 100;    int numSamples = 20;    int numTopicsPerDoc = 1;    Matrix sampledCorpus = ClusteringTestUtils.sampledCorpus(matrix, RandomUtils.getRandom(), numDocs, numSamples, numTopicsPerDoc);    List<Double> perplexities = Lists.newArrayList();    int numTrials = 1;    for (int numTestTopics = 1; numTestTopics < 2 * numGeneratingTopics; numTestTopics++) {        double[] perps = new double[numTrials];        for (int trial = 0; trial < numTrials; trial++) {            InMemoryCollapsedVariationalBayes0 cvb = new InMemoryCollapsedVariationalBayes0(sampledCorpus, terms, numTestTopics, ALPHA, ETA, 2, 1, 0);            cvb.setVerbose(true);            perps[trial] = cvb.iterateUntilConvergence(0, 5, 0, 0.2);            System.out.println(perps[trial]);        }        Arrays.sort(perps);        System.out.println(Arrays.toString(perps));        perplexities.add(perps[0]);    }    System.out.println(Joiner.on(",").join(perplexities));}
b08179a3f5c2b720d80b2ce63af886043f6aa9a1d64d61bb968a9cfd8d315c52
apply
public double apply(double d)
{    return 1.0 / Math.pow(d + 1.0, 2);}
1862164aef0f297aefbd6647fad8c5d920a785334e4d50ea2ade392a6f321c21
testRandomStructuredModelViaMR
public void testRandomStructuredModelViaMR() throws Exception
{    int numGeneratingTopics = 3;    int numTerms = 9;    Matrix matrix = ClusteringTestUtils.randomStructuredModel(numGeneratingTopics, numTerms, new DoubleFunction() {        @Override        public double apply(double d) {            return 1.0 / Math.pow(d + 1.0, 3);        }    });    int numDocs = 500;    int numSamples = 10;    int numTopicsPerDoc = 1;    Matrix sampledCorpus = ClusteringTestUtils.sampledCorpus(matrix, RandomUtils.getRandom(1234), numDocs, numSamples, numTopicsPerDoc);    Path sampleCorpusPath = getTestTempDirPath("corpus");    Configuration configuration = getConfiguration();    MatrixUtils.write(sampleCorpusPath, configuration, sampledCorpus);    int numIterations = 5;    List<Double> perplexities = Lists.newArrayList();    int startTopic = numGeneratingTopics - 1;    int numTestTopics = startTopic;    while (numTestTopics < numGeneratingTopics + 2) {        Path topicModelStateTempPath = getTestTempDirPath("topicTemp" + numTestTopics);        Configuration conf = getConfiguration();        CVB0Driver cvb0Driver = new CVB0Driver();        cvb0Driver.run(conf, sampleCorpusPath, null, numTestTopics, numTerms, ALPHA, ETA, numIterations, 1, 0, null, null, topicModelStateTempPath, 1234, 0.2f, 2, 1, 3, 1, false);        perplexities.add(lowestPerplexity(conf, topicModelStateTempPath));        numTestTopics++;    }    int bestTopic = -1;    double lowestPerplexity = Double.MAX_VALUE;    for (int t = 0; t < perplexities.size(); t++) {        if (perplexities.get(t) < lowestPerplexity) {            lowestPerplexity = perplexities.get(t);            bestTopic = t + startTopic;        }    }    assertEquals("The optimal number of topics is not that of the generating distribution", 4, bestTopic);    System.out.println("Perplexities: " + Joiner.on(", ").join(perplexities));}
b08179a3f5c2b720d80b2ce63af886043f6aa9a1d64d61bb968a9cfd8d315c52
apply
public double apply(double d)
{    return 1.0 / Math.pow(d + 1.0, 3);}
5ac43209a6affe8503ec91eea2f6ec2d65aba5d245f0334161d1d3c77033b29d
lowestPerplexity
private static double lowestPerplexity(Configuration conf, Path topicModelTemp) throws IOException
{    double lowest = Double.MAX_VALUE;    double current;    int iteration = 2;    while (!Double.isNaN(current = CVB0Driver.readPerplexity(conf, topicModelTemp, iteration))) {        lowest = Math.min(current, lowest);        iteration++;    }    return lowest;}
dc9d17a10c180108f239b2e6e6ae0118cd41e0d85170c9003380e53e3f4e905f
getPoints
private static List<VectorWritable> getPoints()
{    List<VectorWritable> points = Lists.newArrayList();    for (double[] fr : RAW) {        Vector vec = new RandomAccessSparseVector(fr.length);        vec.assign(fr);        points.add(new VectorWritable(vec));    }    return points;}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    super.setUp();    Configuration conf = getConfiguration();    fs = FileSystem.get(conf);}
36e0c052fce44bc607f76adb7fac4e41768e34b5e3ffd6a821be7d4818b06cca
testEigenSeedGenerator
public void testEigenSeedGenerator() throws Exception
{    List<VectorWritable> points = getPoints();    Job job = new Job();    Configuration conf = job.getConfiguration();    job.setMapOutputValueClass(VectorWritable.class);    Path input = getTestTempFilePath("eigen-input");    Path output = getTestTempDirPath("eigen-output");    ClusteringTestUtils.writePointsToFile(points, input, fs, conf);    EigenSeedGenerator.buildFromEigens(conf, input, output, 3, new ManhattanDistanceMeasure());    int clusterCount = 0;    Collection<Integer> set = new HashSet<>();    Vector[] v = new Vector[3];    for (ClusterWritable clusterWritable : new SequenceFileValueIterable<ClusterWritable>(new Path(output, "part-eigenSeed"), true, conf)) {        Cluster cluster = clusterWritable.getValue();        int id = cluster.getId();                assertTrue(set.add(id));        v[id] = cluster.getCenter();        clusterCount++;    }        assertEquals(3, clusterCount);        assertEquals(0, v[0].dot(v[1]), 1E-10);    assertEquals(0, v[1].dot(v[2]), 1E-10);    assertEquals(0, v[0].dot(v[2]), 1E-10);}
f7f9a4c91a973d88689d80e046ec7ba6965b137da349c141c294a36eef19c576
testAffinityMatrixInputMapper
public void testAffinityMatrixInputMapper() throws Exception
{    AffinityMatrixInputMapper mapper = new AffinityMatrixInputMapper();    Configuration conf = getConfiguration();    conf.setInt(Keys.AFFINITY_DIMENSIONS, RAW_DIMENSIONS);        DummyRecordWriter<IntWritable, MatrixEntryWritable> writer = new DummyRecordWriter<>();    Mapper<LongWritable, Text, IntWritable, MatrixEntryWritable>.Context context = DummyRecordWriter.build(mapper, conf, writer);        for (String s : RAW) {        mapper.map(new LongWritable(), new Text(s), context);    }        assertEquals("Number of map results", RAW_DIMENSIONS, writer.getData().size());    Set<IntWritable> keys = writer.getData().keySet();    for (IntWritable i : keys) {        List<MatrixEntryWritable> row = writer.getData().get(i);        assertEquals("Number of items in row", RAW_DIMENSIONS, row.size());    }}
5b8fcf4befafc7992399d8bea284080cd227651e474a224aa2eadcfce944f46b
testAffinitymatrixInputReducer
public void testAffinitymatrixInputReducer() throws Exception
{    AffinityMatrixInputMapper mapper = new AffinityMatrixInputMapper();    Configuration conf = getConfiguration();    conf.setInt(Keys.AFFINITY_DIMENSIONS, RAW_DIMENSIONS);        DummyRecordWriter<IntWritable, MatrixEntryWritable> mapWriter = new DummyRecordWriter<>();    Mapper<LongWritable, Text, IntWritable, MatrixEntryWritable>.Context mapContext = DummyRecordWriter.build(mapper, conf, mapWriter);        for (String s : RAW) {        mapper.map(new LongWritable(), new Text(s), mapContext);    }        Map<IntWritable, List<MatrixEntryWritable>> map = mapWriter.getData();        AffinityMatrixInputReducer reducer = new AffinityMatrixInputReducer();    DummyRecordWriter<IntWritable, VectorWritable> redWriter = new DummyRecordWriter<>();    Reducer<IntWritable, MatrixEntryWritable, IntWritable, VectorWritable>.Context redContext = DummyRecordWriter.build(reducer, conf, redWriter, IntWritable.class, MatrixEntryWritable.class);    for (IntWritable key : mapWriter.getKeys()) {        reducer.reduce(key, mapWriter.getValue(key), redContext);    }        assertEquals("Number of reduce results", RAW_DIMENSIONS, redWriter.getData().size());    for (IntWritable row : redWriter.getKeys()) {        List<VectorWritable> list = redWriter.getValue(row);        assertEquals("Should only be one vector", 1, list.size());                Vector v = list.get(0).get();        for (Vector.Element e : v.all()) {                        MatrixEntryWritable toCompare = new MatrixEntryWritable();            toCompare.setRow(-1);            toCompare.setCol(e.index());            toCompare.setVal(e.get());            assertTrue("This entry was correctly placed in its row", map.get(row).contains(toCompare));        }    }}
7e367a13af90b86d1c2b9881665bb7fa6ebfea540a616c8844a84fa9bd53902b
rowSum
private static double rowSum(double[] row)
{    double sum = 0;    for (double r : row) {        sum += r;    }    return sum;}
7be6a0ab5467f5e7ac82e3ce3333dd5d43e3f399204b454247947b2eaa3f519d
testMatrixDiagonalizeMapper
public void testMatrixDiagonalizeMapper() throws Exception
{    MatrixDiagonalizeMapper mapper = new MatrixDiagonalizeMapper();    Configuration conf = getConfiguration();    conf.setInt(Keys.AFFINITY_DIMENSIONS, RAW_DIMENSIONS);        DummyRecordWriter<NullWritable, IntDoublePairWritable> writer = new DummyRecordWriter<>();    Mapper<IntWritable, VectorWritable, NullWritable, IntDoublePairWritable>.Context context = DummyRecordWriter.build(mapper, conf, writer);        for (int i = 0; i < RAW_DIMENSIONS; i++) {        RandomAccessSparseVector toAdd = new RandomAccessSparseVector(RAW_DIMENSIONS);        toAdd.assign(RAW[i]);        mapper.map(new IntWritable(i), new VectorWritable(toAdd), context);    }        assertEquals("Number of map results", RAW_DIMENSIONS, writer.getValue(NullWritable.get()).size());}
d37fc41c2457c738a7eb7c13293f94a2ac7dd49f487d8e9d5ce8ba42dd250f9c
testMatrixDiagonalizeReducer
public void testMatrixDiagonalizeReducer() throws Exception
{    MatrixDiagonalizeMapper mapper = new MatrixDiagonalizeMapper();    Configuration conf = getConfiguration();    conf.setInt(Keys.AFFINITY_DIMENSIONS, RAW_DIMENSIONS);        DummyRecordWriter<NullWritable, IntDoublePairWritable> mapWriter = new DummyRecordWriter<>();    Mapper<IntWritable, VectorWritable, NullWritable, IntDoublePairWritable>.Context mapContext = DummyRecordWriter.build(mapper, conf, mapWriter);        for (int i = 0; i < RAW_DIMENSIONS; i++) {        RandomAccessSparseVector toAdd = new RandomAccessSparseVector(RAW_DIMENSIONS);        toAdd.assign(RAW[i]);        mapper.map(new IntWritable(i), new VectorWritable(toAdd), mapContext);    }        MatrixDiagonalizeReducer reducer = new MatrixDiagonalizeReducer();    DummyRecordWriter<NullWritable, VectorWritable> redWriter = new DummyRecordWriter<>();    Reducer<NullWritable, IntDoublePairWritable, NullWritable, VectorWritable>.Context redContext = DummyRecordWriter.build(reducer, conf, redWriter, NullWritable.class, IntDoublePairWritable.class);        reducer.reduce(NullWritable.get(), mapWriter.getValue(NullWritable.get()), redContext);        List<VectorWritable> list = redWriter.getValue(NullWritable.get());    assertEquals("Only a single resulting vector", 1, list.size());    Vector v = list.get(0).get();    for (int i = 0; i < v.size(); i++) {        assertEquals("Element sum is correct", rowSum(RAW[i]), v.get(i), 0.01);    }}
b043bef9e600a6e4b434e6cb7f134d08190f40d2ce27b9f7deda805fe2c3e223
testUnitVectorizerMapper
public void testUnitVectorizerMapper() throws Exception
{    UnitVectorizerMapper mapper = new UnitVectorizerMapper();    Configuration conf = getConfiguration();        DummyRecordWriter<IntWritable, VectorWritable> writer = new DummyRecordWriter<>();    Mapper<IntWritable, VectorWritable, IntWritable, VectorWritable>.Context context = DummyRecordWriter.build(mapper, conf, writer);        for (int i = 0; i < RAW.length; i++) {        Vector vector = new RandomAccessSparseVector(RAW[i].length);        vector.assign(RAW[i]);        mapper.map(new IntWritable(i), new VectorWritable(vector), context);    }        assertEquals("Number of map results", RAW.length, writer.getData().size());    for (int i = 0; i < RAW.length; i++) {        IntWritable key = new IntWritable(i);        List<VectorWritable> list = writer.getValue(key);        assertEquals("Only one element per row", 1, list.size());        Vector v = list.get(0).get();        assertTrue("Unit vector sum is 1 or differs by 0.0001", Math.abs(v.norm(2) - 1) < 0.000001);    }}
da05b7ec033c61c79c519631dc45e1f42dbe341aee6c1674e7f2ae05d7709bd3
testSave
public void testSave() throws Exception
{    Configuration conf = getConfiguration();    Writable key = new IntWritable(0);    Vector value = new DenseVector(VECTOR);    Path path = getTestTempDirPath("output");        VectorCache.save(key, value, path, conf, true, true);        SequenceFileValueIterator<VectorWritable> iterator = new SequenceFileValueIterator<>(path, true, conf);    try {        VectorWritable old = iterator.next();                assertEquals("Saved vector is identical to original", old.get(), value);    } finally {        Closeables.close(iterator, true);    }}
1377b88a53dbc34f338014730d3ff1233b6c47e9a5c6cf6d5ddfbd22210f02e6
testLoad
public void testLoad() throws Exception
{        Configuration conf = getConfiguration();    Writable key = new IntWritable(0);    Vector value = new DenseVector(VECTOR);    Path path = getTestTempDirPath("output");    FileSystem fs = FileSystem.get(path.toUri(), conf);        path = fs.makeQualified(path);    fs.deleteOnExit(path);    HadoopUtil.delete(conf, path);    SequenceFile.Writer writer = new SequenceFile.Writer(fs, conf, path, IntWritable.class, VectorWritable.class);    try {        writer.append(key, new VectorWritable(value));    } finally {        Closeables.close(writer, false);    }    DistributedCache.setCacheFiles(new URI[] { path.toUri() }, conf);        Vector result = VectorCache.load(conf);        assertNotNull("Vector is null", result);    assertEquals("Loaded vector is not identical to original", result, value);}
049782c18fbdd6792746a664b16dbfa70b182a95d81c55926e8a18c2ab90c21b
testAll
public void testAll() throws Exception
{    Configuration conf = getConfiguration();    Vector v = new DenseVector(VECTOR);    Path toSave = getTestTempDirPath("output");    Writable key = new IntWritable(0);        VectorCache.save(key, v, toSave, conf);        Vector v2 = VectorCache.load(conf);        assertNotNull("Vector is null", v2);    assertEquals("Vectors are not identical", v2, v);}
02574898c102b53e536bdc22e9bb0d2008da7323d876330a7ab83c5750daf88b
testVectorMatrixMultiplicationMapper
public void testVectorMatrixMultiplicationMapper() throws Exception
{    VectorMatrixMultiplicationMapper mapper = new VectorMatrixMultiplicationMapper();    Configuration conf = getConfiguration();        Vector toSave = new DenseVector(VECTOR);    DummyRecordWriter<IntWritable, VectorWritable> writer = new DummyRecordWriter<>();    Mapper<IntWritable, VectorWritable, IntWritable, VectorWritable>.Context context = DummyRecordWriter.build(mapper, conf, writer);    mapper.setup(toSave);        for (int i = 0; i < MATRIX.length; i++) {        Vector v = new RandomAccessSparseVector(MATRIX[i].length);        v.assign(MATRIX[i]);        mapper.map(new IntWritable(i), new VectorWritable(v), context);    }        assertEquals("Number of map results", MATRIX.length, writer.getData().size());    for (int i = 0; i < MATRIX.length; i++) {        List<VectorWritable> list = writer.getValue(new IntWritable(i));        assertEquals("Only one vector per key", 1, list.size());        Vector v = list.get(0).get();        for (int j = 0; j < MATRIX[i].length; j++) {            double total = Math.sqrt(VECTOR[i]) * Math.sqrt(VECTOR[j]) * MATRIX[i][j];            assertEquals("Product matrix elements", total, v.get(j), EPSILON);        }    }}
ca86f0db8b699367a1e071192b0ab724903096b25a11d522de42a85bae0700a9
setUp
public static void setUp()
{    RandomUtils.useTestSeed();    syntheticData = DataUtils.sampleMultiNormalHypercube(NUM_DIMENSIONS, NUM_DATA_POINTS, DISTRIBUTION_RADIUS);}
14da00f5579be2fe1bb3eb47fbd041fb112dfde2975d95ee109916d5bf57bbfe
testClusteringMultipleRuns
public void testClusteringMultipleRuns()
{    for (int i = 1; i <= 10; ++i) {        BallKMeans clusterer = new BallKMeans(new BruteSearch(new SquaredEuclideanDistanceMeasure()), 1 << NUM_DIMENSIONS, NUM_ITERATIONS, true, i);        clusterer.cluster(syntheticData.getFirst());        double costKMeansPlusPlus = ClusteringUtils.totalClusterCost(syntheticData.getFirst(), clusterer);        clusterer = new BallKMeans(new BruteSearch(new SquaredEuclideanDistanceMeasure()), 1 << NUM_DIMENSIONS, NUM_ITERATIONS, false, i);        clusterer.cluster(syntheticData.getFirst());        double costKMeansRandom = ClusteringUtils.totalClusterCost(syntheticData.getFirst(), clusterer);        System.out.printf("%d runs; kmeans++: %f; random: %f\n", i, costKMeansPlusPlus, costKMeansRandom);        assertTrue("kmeans++ cost should be less than random cost", costKMeansPlusPlus < costKMeansRandom);    }}
8bad3bb07c2a4426d8a6f10e5ee5e473ccd25cccc16b655c17eac0d298cc6c3e
testClustering
public void testClustering()
{    UpdatableSearcher searcher = new BruteSearch(new SquaredEuclideanDistanceMeasure());    BallKMeans clusterer = new BallKMeans(searcher, 1 << NUM_DIMENSIONS, NUM_ITERATIONS);    long startTime = System.currentTimeMillis();    Pair<List<Centroid>, List<Centroid>> data = syntheticData;    clusterer.cluster(data.getFirst());    long endTime = System.currentTimeMillis();    long hash = 0;    for (Centroid centroid : data.getFirst()) {        for (Vector.Element element : centroid.all()) {            hash = 31 * hash + 17 * element.index() + Double.toHexString(element.get()).hashCode();        }    }    System.out.printf("Hash = %08x\n", hash);    assertEquals("Total weight not preserved", totalWeight(syntheticData.getFirst()), totalWeight(clusterer), 1.0e-9);            OnlineSummarizer summarizer = new OnlineSummarizer();    for (Vector mean : syntheticData.getSecond()) {        WeightedThing<Vector> v = searcher.search(mean, 1).get(0);        summarizer.add(v.getWeight());    }    assertTrue(String.format("Median weight [%f] too large [>%f]", summarizer.getMedian(), DISTRIBUTION_RADIUS), summarizer.getMedian() < DISTRIBUTION_RADIUS);    double clusterTime = (endTime - startTime) / 1000.0;    System.out.printf("%s\n%.2f for clustering\n%.1f us per row\n\n", searcher.getClass().getName(), clusterTime, clusterTime / syntheticData.getFirst().size() * 1.0e6);        double[] cornerWeights = new double[1 << NUM_DIMENSIONS];    Searcher trueFinder = new BruteSearch(new EuclideanDistanceMeasure());    for (Vector trueCluster : syntheticData.getSecond()) {        trueFinder.add(trueCluster);    }    for (Centroid centroid : clusterer) {        WeightedThing<Vector> closest = trueFinder.search(centroid, 1).get(0);        cornerWeights[((Centroid) closest.getValue()).getIndex()] += centroid.getWeight();    }    int expectedNumPoints = NUM_DATA_POINTS / (1 << NUM_DIMENSIONS);    for (double v : cornerWeights) {        System.out.printf("%f ", v);    }    System.out.println();    for (double v : cornerWeights) {        assertEquals(expectedNumPoints, v, 0);    }}
753092114e5ba592f285785b43ecc145abe49d6218432e567fc8be32182d47d7
testInitialization
public void testInitialization()
{        List<? extends WeightedVector> data = cubishTestData(0.01);        BallKMeans r = new BallKMeans(new BruteSearch(new SquaredEuclideanDistanceMeasure()), 6, 20);    r.cluster(data);        Matrix x = new DenseMatrix(6, 5);    int row = 0;    for (Centroid c : r) {        x.viewRow(row).assign(c.viewPart(0, 5));        row++;    }        final Vector columnNorms = x.aggregateColumns(new VectorFunction() {        @Override        public double apply(Vector f) {                        return Math.abs(f.minValue()) + Math.abs(f.maxValue() - 6) + Math.abs(f.norm(1) - 6);        }    });        assertEquals(0, columnNorms.norm(1) / columnNorms.size(), 0.1);        SingularValueDecomposition svd = new SingularValueDecomposition(x);    Vector s = svd.getS().viewDiagonal().assign(Functions.div(6));    assertEquals(5, s.getLengthSquared(), 0.05);    assertEquals(5, s.norm(1), 0.05);}
2f1ede7b797f96a4a403e25d1e39ecd7ca1885dbe158c3d3f3d350411d89780e
apply
public double apply(Vector f)
{        return Math.abs(f.minValue()) + Math.abs(f.maxValue() - 6) + Math.abs(f.norm(1) - 6);}
11fc572775534b0394048c8852f8ac2eb972dea6d42287e6a30e06e9eba42c43
cubishTestData
private static List<? extends WeightedVector> cubishTestData(double radius)
{    List<WeightedVector> data = Lists.newArrayListWithCapacity(K1 + 5000);    int row = 0;    MultiNormal g = new MultiNormal(radius, new ConstantVector(0, 10));    for (int i = 0; i < K1; i++) {        data.add(new WeightedVector(g.sample(), 1, row++));    }    for (int i = 0; i < 5; i++) {        Vector m = new DenseVector(10);                m.set(i, 6);        MultiNormal gx = new MultiNormal(radius, m);        for (int j = 0; j < 1000; j++) {            data.add(new WeightedVector(gx.sample(), 1, row++));        }    }    return data;}
38a092e96e1af2bea943146ecfcd10c09bb0fbb1770f0fc41ab8e2c273bad3f7
sampleMultiNormalHypercube
public static Pair<List<Centroid>, List<Centroid>> sampleMultiNormalHypercube(int numDimensions, int numDatapoints, double distributionRadius)
{    int pow2N = 1 << numDimensions;                List<Centroid> mean = Lists.newArrayListWithCapacity(pow2N);    List<MultiNormal> rowSamplers = Lists.newArrayList();    for (int i = 0; i < pow2N; i++) {        Vector v = new DenseVector(numDimensions);                int pow2J = 1 << (numDimensions - 1);        for (int j = 0; j < numDimensions; ++j) {            v.set(j, 1.0 / pow2J * (i & pow2J));            pow2J >>= 1;        }        mean.add(new Centroid(i, v, 1));        rowSamplers.add(new MultiNormal(distributionRadius, v));    }        List<Centroid> data = Lists.newArrayListWithCapacity(numDatapoints);    for (int i = 0; i < numDatapoints; ++i) {        data.add(new Centroid(i, rowSamplers.get(i % pow2N).sample(), 1));    }    return new Pair<>(data, mean);}
6ae142ea08e461b551d138a49881e95b1ae61801b1e4d9c2bcd2d974a6f9a101
sampleMultiNormalHypercube
public static Pair<List<Centroid>, List<Centroid>> sampleMultiNormalHypercube(int numDimensions, int numDatapoints)
{    return sampleMultiNormalHypercube(numDimensions, numDatapoints, 0.01);}
4adaefafec562702d887f5960a1408e5f9d1add92c42fab7cb857d701c42d2a2
setUp
public void setUp()
{    RandomUtils.useTestSeed();    syntheticData = DataUtils.sampleMultiNormalHypercube(NUM_DIMENSIONS, NUM_DATA_POINTS);}
8a304ebf89920547bacb4c045f35593ea3f8d3bd441b08b25802cafb1de6b512
generateData
public static List<Object[]> generateData()
{    return Arrays.asList(new Object[][] { { new ProjectionSearch(new SquaredEuclideanDistanceMeasure(), NUM_PROJECTIONS, SEARCH_SIZE), true }, { new FastProjectionSearch(new SquaredEuclideanDistanceMeasure(), NUM_PROJECTIONS, SEARCH_SIZE), true }, { new ProjectionSearch(new SquaredEuclideanDistanceMeasure(), NUM_PROJECTIONS, SEARCH_SIZE), false }, { new FastProjectionSearch(new SquaredEuclideanDistanceMeasure(), NUM_PROJECTIONS, SEARCH_SIZE), false } });}
fe98abd838c80e07bdc842310d95450fbd3beb14e2c13e0c2412033e1f407052
testAverageDistanceCutoff
public void testAverageDistanceCutoff()
{    double avgDistanceCutoff = 0;    double avgNumClusters = 0;    int numTests = 1;    System.out.printf("Distance cutoff for %s\n", searcher.getClass().getName());    for (int i = 0; i < numTests; ++i) {        searcher.clear();        int numStreamingClusters = (int) Math.log(syntheticData.getFirst().size()) * (1 << NUM_DIMENSIONS);        double distanceCutoff = 1.0e-6;        double estimatedCutoff = ClusteringUtils.estimateDistanceCutoff(syntheticData.getFirst(), searcher.getDistanceMeasure(), 100);        System.out.printf("[%d] Generated synthetic data [magic] %f [estimate] %f\n", i, distanceCutoff, estimatedCutoff);        StreamingKMeans clusterer = new StreamingKMeans(searcher, numStreamingClusters, estimatedCutoff);        clusterer.cluster(syntheticData.getFirst());        avgDistanceCutoff += clusterer.getDistanceCutoff();        avgNumClusters += clusterer.getNumClusters();        System.out.printf("[%d] %f\n", i, clusterer.getDistanceCutoff());    }    avgDistanceCutoff /= numTests;    avgNumClusters /= numTests;    System.out.printf("Final: distanceCutoff: %f estNumClusters: %f\n", avgDistanceCutoff, avgNumClusters);}
8bad3bb07c2a4426d8a6f10e5ee5e473ccd25cccc16b655c17eac0d298cc6c3e
testClustering
public void testClustering()
{    searcher.clear();    int numStreamingClusters = (int) Math.log(syntheticData.getFirst().size()) * (1 << NUM_DIMENSIONS);    System.out.printf("k log n = %d\n", numStreamingClusters);    double estimatedCutoff = ClusteringUtils.estimateDistanceCutoff(syntheticData.getFirst(), searcher.getDistanceMeasure(), 100);    StreamingKMeans clusterer = new StreamingKMeans(searcher, numStreamingClusters, estimatedCutoff);    long startTime = System.currentTimeMillis();    if (allAtOnce) {        clusterer.cluster(syntheticData.getFirst());    } else {        for (Centroid datapoint : syntheticData.getFirst()) {            clusterer.cluster(datapoint);        }    }    long endTime = System.currentTimeMillis();    System.out.printf("%s %s\n", searcher.getClass().getName(), searcher.getDistanceMeasure().getClass().getName());    System.out.printf("Total number of clusters %d\n", clusterer.getNumClusters());    System.out.printf("Weights: %f %f\n", ClusteringUtils.totalWeight(syntheticData.getFirst()), ClusteringUtils.totalWeight(clusterer));    assertEquals("Total weight not preserved", ClusteringUtils.totalWeight(syntheticData.getFirst()), ClusteringUtils.totalWeight(clusterer), 1.0e-9);        double maxWeight = 0;    for (Vector mean : syntheticData.getSecond()) {        WeightedThing<Vector> v = searcher.search(mean, 1).get(0);        maxWeight = Math.max(v.getWeight(), maxWeight);    }    assertTrue("Maximum weight too large " + maxWeight, maxWeight < 0.05);    double clusterTime = (endTime - startTime) / 1000.0;    System.out.printf("%s\n%.2f for clustering\n%.1f us per row\n\n", searcher.getClass().getName(), clusterTime, clusterTime / syntheticData.getFirst().size() * 1.0e6);        double[] cornerWeights = new double[1 << NUM_DIMENSIONS];    Searcher trueFinder = new BruteSearch(new EuclideanDistanceMeasure());    for (Vector trueCluster : syntheticData.getSecond()) {        trueFinder.add(trueCluster);    }    for (Centroid centroid : clusterer) {        WeightedThing<Vector> closest = trueFinder.search(centroid, 1).get(0);        cornerWeights[((Centroid) closest.getValue()).getIndex()] += centroid.getWeight();    }    int expectedNumPoints = NUM_DATA_POINTS / (1 << NUM_DIMENSIONS);    for (double v : cornerWeights) {        System.out.printf("%f ", v);    }    System.out.println();    for (double v : cornerWeights) {        assertEquals(expectedNumPoints, v, 0);    }}
4adaefafec562702d887f5960a1408e5f9d1add92c42fab7cb857d701c42d2a2
setUp
public void setUp()
{    RandomUtils.useTestSeed();    syntheticData = DataUtils.sampleMultiNormalHypercube(NUM_DIMENSIONS, NUM_DATA_POINTS, 1.0e-4);}
5b7c95c9e7e5d50383737c141e3e44aaeb35a7730d0807774a07fb4aaa389661
configure
private void configure(Configuration configuration)
{    configuration.set(DefaultOptionCreator.DISTANCE_MEASURE_OPTION, distanceMeasureClassName);    configuration.setInt(StreamingKMeansDriver.SEARCH_SIZE_OPTION, SEARCH_SIZE);    configuration.setInt(StreamingKMeansDriver.NUM_PROJECTIONS_OPTION, NUM_PROJECTIONS);    configuration.set(StreamingKMeansDriver.SEARCHER_CLASS_OPTION, searcherClassName);    configuration.setInt(DefaultOptionCreator.NUM_CLUSTERS_OPTION, 1 << NUM_DIMENSIONS);    configuration.setInt(StreamingKMeansDriver.ESTIMATED_NUM_MAP_CLUSTERS, (1 << NUM_DIMENSIONS) * (int) Math.log(NUM_DATA_POINTS));    configuration.setFloat(StreamingKMeansDriver.ESTIMATED_DISTANCE_CUTOFF, (float) DISTANCE_CUTOFF);    configuration.setInt(StreamingKMeansDriver.MAX_NUM_ITERATIONS, MAX_NUM_ITERATIONS);        configuration.setBoolean(StreamingKMeansDriver.REDUCE_STREAMING_KMEANS, true);}
8a304ebf89920547bacb4c045f35593ea3f8d3bd441b08b25802cafb1de6b512
generateData
public static List<Object[]> generateData()
{    return Arrays.asList(new Object[][] { { ProjectionSearch.class.getName(), SquaredEuclideanDistanceMeasure.class.getName() }, { FastProjectionSearch.class.getName(), SquaredEuclideanDistanceMeasure.class.getName() }, { LocalitySensitiveHashSearch.class.getName(), SquaredEuclideanDistanceMeasure.class.getName() } });}
94664b42f78012025b58ba0880a51c302aee69e9fe8f7ac504a20f83b0a90993
testHypercubeMapper
public void testHypercubeMapper() throws IOException
{    MapDriver<Writable, VectorWritable, IntWritable, CentroidWritable> mapDriver = MapDriver.newMapDriver(new StreamingKMeansMapper());    configure(mapDriver.getConfiguration());    System.out.printf("%s mapper test\n", mapDriver.getConfiguration().get(StreamingKMeansDriver.SEARCHER_CLASS_OPTION));    for (Centroid datapoint : syntheticData.getFirst()) {        mapDriver.addInput(new IntWritable(0), new VectorWritable(datapoint));    }    List<org.apache.hadoop.mrunit.types.Pair<IntWritable, CentroidWritable>> results = mapDriver.run();    BruteSearch resultSearcher = new BruteSearch(new SquaredEuclideanDistanceMeasure());    for (org.apache.hadoop.mrunit.types.Pair<IntWritable, CentroidWritable> result : results) {        resultSearcher.add(result.getSecond().getCentroid());    }    System.out.printf("Clustered the data into %d clusters\n", results.size());    for (Vector mean : syntheticData.getSecond()) {        WeightedThing<Vector> closest = resultSearcher.search(mean, 1).get(0);        assertTrue("Weight " + closest.getWeight() + " not less than 0.5", closest.getWeight() < 0.5);    }}
1b5923a627a200dbafd2f937c692e1262efa94a571dab0a44afeee9eeafa5138
testMapperVsLocal
public void testMapperVsLocal() throws IOException
{        MapDriver<Writable, VectorWritable, IntWritable, CentroidWritable> mapDriver = MapDriver.newMapDriver(new StreamingKMeansMapper());    Configuration configuration = mapDriver.getConfiguration();    configure(configuration);    System.out.printf("%s mapper vs local test\n", mapDriver.getConfiguration().get(StreamingKMeansDriver.SEARCHER_CLASS_OPTION));    for (Centroid datapoint : syntheticData.getFirst()) {        mapDriver.addInput(new IntWritable(0), new VectorWritable(datapoint));    }    List<Centroid> mapperCentroids = Lists.newArrayList();    for (org.apache.hadoop.mrunit.types.Pair<IntWritable, CentroidWritable> pair : mapDriver.run()) {        mapperCentroids.add(pair.getSecond().getCentroid());    }        StreamingKMeans batchClusterer = new StreamingKMeans(StreamingKMeansUtilsMR.searcherFromConfiguration(configuration), mapDriver.getConfiguration().getInt("estimatedNumMapClusters", -1), DISTANCE_CUTOFF);    batchClusterer.cluster(syntheticData.getFirst());    List<Centroid> batchCentroids = Lists.newArrayList();    for (Vector v : batchClusterer) {        batchCentroids.add((Centroid) v);    }        StreamingKMeans perPointClusterer = new StreamingKMeans(StreamingKMeansUtilsMR.searcherFromConfiguration(configuration), (1 << NUM_DIMENSIONS) * (int) Math.log(NUM_DATA_POINTS), DISTANCE_CUTOFF);    for (Centroid datapoint : syntheticData.getFirst()) {        perPointClusterer.cluster(datapoint);    }    List<Centroid> perPointCentroids = Lists.newArrayList();    for (Vector v : perPointClusterer) {        perPointCentroids.add((Centroid) v);    }        double mapperCost = ClusteringUtils.totalClusterCost(syntheticData.getFirst(), mapperCentroids);    double localCost = ClusteringUtils.totalClusterCost(syntheticData.getFirst(), batchCentroids);    double perPointCost = ClusteringUtils.totalClusterCost(syntheticData.getFirst(), perPointCentroids);    System.out.printf("[Total cost] Mapper %f [%d] Local %f [%d] Perpoint local %f [%d];" + "[ratio m-vs-l %f] [ratio pp-vs-l %f]\n", mapperCost, mapperCentroids.size(), localCost, batchCentroids.size(), perPointCost, perPointCentroids.size(), mapperCost / localCost, perPointCost / localCost);            assertEquals("Mapper StreamingKMeans / Batch local StreamingKMeans total cost ratio too far from 1", 1.0, mapperCost / localCost, 0.8);    assertEquals("One by one local StreamingKMeans / Batch local StreamingKMeans total cost ratio too high", 1.0, perPointCost / localCost, 0.8);}
dde610847a13f0390a20009f8c7ab735ce530b22624c8bfd792098f4f4544890
testHypercubeReducer
public void testHypercubeReducer() throws IOException
{    ReduceDriver<IntWritable, CentroidWritable, IntWritable, CentroidWritable> reduceDriver = ReduceDriver.newReduceDriver(new StreamingKMeansReducer());    Configuration configuration = reduceDriver.getConfiguration();    configure(configuration);    System.out.printf("%s reducer test\n", configuration.get(StreamingKMeansDriver.SEARCHER_CLASS_OPTION));    StreamingKMeans clusterer = new StreamingKMeans(StreamingKMeansUtilsMR.searcherFromConfiguration(configuration), (1 << NUM_DIMENSIONS) * (int) Math.log(NUM_DATA_POINTS), DISTANCE_CUTOFF);    long start = System.currentTimeMillis();    clusterer.cluster(syntheticData.getFirst());    long end = System.currentTimeMillis();    System.out.printf("%f [s]\n", (end - start) / 1000.0);    List<CentroidWritable> reducerInputs = Lists.newArrayList();    int postMapperTotalWeight = 0;    for (Centroid intermediateCentroid : clusterer) {        reducerInputs.add(new CentroidWritable(intermediateCentroid));        postMapperTotalWeight += intermediateCentroid.getWeight();    }    reduceDriver.addInput(new IntWritable(0), reducerInputs);    List<org.apache.hadoop.mrunit.types.Pair<IntWritable, CentroidWritable>> results = reduceDriver.run();    testReducerResults(postMapperTotalWeight, results);}
2a7e2e386386d53f376947b11593bd1682f3a3fd409acfa8c6248fa6a3ea691a
testHypercubeMapReduce
public void testHypercubeMapReduce() throws IOException
{    MapReduceDriver<Writable, VectorWritable, IntWritable, CentroidWritable, IntWritable, CentroidWritable> mapReduceDriver = new MapReduceDriver<>(new StreamingKMeansMapper(), new StreamingKMeansReducer());    Configuration configuration = mapReduceDriver.getConfiguration();    configure(configuration);    System.out.printf("%s full test\n", configuration.get(StreamingKMeansDriver.SEARCHER_CLASS_OPTION));    for (Centroid datapoint : syntheticData.getFirst()) {        mapReduceDriver.addInput(new IntWritable(0), new VectorWritable(datapoint));    }    List<org.apache.hadoop.mrunit.types.Pair<IntWritable, CentroidWritable>> results = mapReduceDriver.run();    testReducerResults(syntheticData.getFirst().size(), results);}
313f2ac5f60fbaa6a53324f9fcca93f0138ba37ba6a090f22267073c94fb2922
testHypercubeMapReduceRunSequentially
public void testHypercubeMapReduceRunSequentially() throws Exception
{    Configuration configuration = getConfiguration();    configure(configuration);    configuration.set(DefaultOptionCreator.METHOD_OPTION, DefaultOptionCreator.SEQUENTIAL_METHOD);    Path inputPath = new Path("testInput");    Path outputPath = new Path("testOutput");    StreamingKMeansUtilsMR.writeVectorsToSequenceFile(syntheticData.getFirst(), inputPath, configuration);    StreamingKMeansDriver.run(configuration, inputPath, outputPath);    testReducerResults(syntheticData.getFirst().size(), Lists.newArrayList(Iterables.transform(new SequenceFileIterable<IntWritable, CentroidWritable>(outputPath, configuration), new Function<Pair<IntWritable, CentroidWritable>, org.apache.hadoop.mrunit.types.Pair<IntWritable, CentroidWritable>>() {        @Override        public org.apache.hadoop.mrunit.types.Pair<IntWritable, CentroidWritable> apply(org.apache.mahout.common.Pair<IntWritable, CentroidWritable> input) {            return new org.apache.hadoop.mrunit.types.Pair<>(input.getFirst(), input.getSecond());        }    })));}
1df94cead8ee1610fa310dbfd0be20f02e03db9bb52bc3f1bdd63467703760b9
apply
public org.apache.hadoop.mrunit.types.Pair<IntWritable, CentroidWritable> apply(org.apache.mahout.common.Pair<IntWritable, CentroidWritable> input)
{    return new org.apache.hadoop.mrunit.types.Pair<>(input.getFirst(), input.getSecond());}
e30ec8cd43273b1beaef978256e21a80acd2e184aa614a0d5601662fa59b9140
testReducerResults
private static void testReducerResults(int totalWeight, List<org.apache.hadoop.mrunit.types.Pair<IntWritable, CentroidWritable>> results)
{    int expectedNumClusters = 1 << NUM_DIMENSIONS;    double expectedWeight = (double) totalWeight / expectedNumClusters;    int numClusters = 0;    int numUnbalancedClusters = 0;    int totalReducerWeight = 0;    for (org.apache.hadoop.mrunit.types.Pair<IntWritable, CentroidWritable> result : results) {        if (result.getSecond().getCentroid().getWeight() != expectedWeight) {            System.out.printf("Unbalanced weight %f in centroid %d\n", result.getSecond().getCentroid().getWeight(), result.getSecond().getCentroid().getIndex());            ++numUnbalancedClusters;        }        assertEquals("Final centroid index is invalid", numClusters, result.getFirst().get());        totalReducerWeight += result.getSecond().getCentroid().getWeight();        ++numClusters;    }    System.out.printf("%d clusters are unbalanced\n", numUnbalancedClusters);    assertEquals("Invalid total weight", totalWeight, totalReducerWeight);    assertEquals("Invalid number of clusters", 1 << NUM_DIMENSIONS, numClusters);}
36479061d28d6ccadbde3a773dbc92cd527ca826f7fd772cb3f6f5991ef4be34
testSplitting
public void testSplitting() throws Exception
{    Path inputFile = new Path(getTestTempDirPath("input"), "test.seq");    Path output = getTestTempDirPath("output");    Configuration conf = new Configuration();    LocalFileSystem fs = FileSystem.getLocal(conf);    SequenceFile.Writer writer = null;    try {        writer = SequenceFile.createWriter(fs, conf, inputFile, IntWritable.class, IntWritable.class);        writer.append(new IntWritable(1), new IntWritable(1));        writer.append(new IntWritable(2), new IntWritable(2));        writer.append(new IntWritable(3), new IntWritable(3));        writer.append(new IntWritable(4), new IntWritable(4));        writer.append(new IntWritable(5), new IntWritable(5));        writer.append(new IntWritable(6), new IntWritable(6));        writer.append(new IntWritable(7), new IntWritable(7));        writer.append(new IntWritable(8), new IntWritable(8));    } finally {        Closeables.close(writer, false);    }    String splitPattern = "split";    int numSplits = 4;    ResplitSequenceFiles.main(new String[] { "--input", inputFile.toString(), "--output", output.toString() + "/" + splitPattern, "--numSplits", String.valueOf(numSplits) });    FileStatus[] statuses = HadoopUtil.getFileStatus(output, PathType.LIST, PathFilters.logsCRCFilter(), null, conf);    for (FileStatus status : statuses) {        String name = status.getPath().getName();        assertTrue(name.startsWith(splitPattern));        assertEquals(2, numEntries(status, conf));    }    assertEquals(numSplits, statuses.length);}
452ce062fb1550faec5d540b2e7a9b01f6676e95bfe291e3734e2c2a15afc94c
numEntries
private int numEntries(FileStatus status, Configuration conf)
{    return Iterables.size(new SequenceFileIterable(status.getPath(), conf));}
bc146f2f074f51a31c4badeeab552e4c085bf237fd3e9e7f30cc292669a56266
testClusterAsFormatString
public void testClusterAsFormatString()
{    double[] d = { 1.1, 2.2, 3.3 };    Vector m = new DenseVector(d);    Cluster cluster = new org.apache.mahout.clustering.kmeans.Kluster(m, 123, measure);    String formatString = cluster.asFormatString(null);    assertTrue(formatString.contains("\"r\":[]"));    assertTrue(formatString.contains("\"c\":[1.1,2.2,3.3]"));    assertTrue(formatString.contains("\"n\":0"));    assertTrue(formatString.contains("\"identifier\":\"CL-123\""));}
54f50a0ea31010c15adbaf7fa2094ed6abee685e08d48d1fb7daaaccb4615e14
testClusterAsFormatStringSparse
public void testClusterAsFormatStringSparse()
{    double[] d = { 1.1, 0.0, 3.3 };    Vector m = new SequentialAccessSparseVector(3);    m.assign(d);    Cluster cluster = new org.apache.mahout.clustering.kmeans.Kluster(m, 123, measure);    String formatString = cluster.asFormatString(null);    assertTrue(formatString.contains("\"r\":[]"));    assertTrue(formatString.contains("\"c\":[{\"0\":1.1},{\"2\":3.3}]"));    assertTrue(formatString.contains("\"n\":0"));    assertTrue(formatString.contains("\"identifier\":\"CL-123\""));}
ceb2388c4a6a940d5ec617edf2f599825f8c52d85015a78616d53854e84002b2
testClusterAsFormatStringWithBindings
public void testClusterAsFormatStringWithBindings()
{    double[] d = { 1.1, 2.2, 3.3 };    Vector m = new DenseVector(d);    Cluster cluster = new org.apache.mahout.clustering.kmeans.Kluster(m, 123, measure);    String[] bindings = { "fee", null, "foo" };    String formatString = cluster.asFormatString(bindings);    assertTrue(formatString.contains("\"r\":[]"));    assertTrue(formatString.contains("\"c\":[{\"fee\":1.1},{\"1\":2.2},{\"foo\":3.3}]"));    assertTrue(formatString.contains("\"n\":0"));    assertTrue(formatString.contains("\"identifier\":\"CL-123\""));}
a9e97991665f7cf1516897f3520e1e47177880635fc48ed8c0811996cc92689e
testClusterAsFormatStringSparseWithBindings
public void testClusterAsFormatStringSparseWithBindings()
{    double[] d = { 1.1, 0.0, 3.3 };    Vector m = new SequentialAccessSparseVector(3);    m.assign(d);    Cluster cluster = new org.apache.mahout.clustering.kmeans.Kluster(m, 123, measure);    String formatString = cluster.asFormatString(null);    assertTrue(formatString.contains("\"r\":[]"));    assertTrue(formatString.contains("\"c\":[{\"0\":1.1},{\"2\":3.3}]"));    assertTrue(formatString.contains("\"n\":0"));    assertTrue(formatString.contains("\"identifier\":\"CL-123\""));}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    super.setUp();    sampleData = Lists.newArrayList();    generateSamples();    sampleN = 0;    Vector sum = new DenseVector(2);    for (VectorWritable v : sampleData) {        sum.assign(v.get(), Functions.PLUS);        sampleN++;    }    sampleMean = sum.divide(sampleN);    Vector sampleVar = new DenseVector(2);    for (VectorWritable v : sampleData) {        Vector delta = v.get().minus(sampleMean);        sampleVar.assign(delta.times(delta), Functions.PLUS);    }    sampleVar = sampleVar.divide(sampleN - 1);    sampleStd = sampleVar.clone();    sampleStd.assign(new SquareRootFunction());    log.info("Observing {} samples m=[{}, {}] sd=[{}, {}]", sampleN, sampleMean.get(0), sampleMean.get(1), sampleStd.get(0), sampleStd.get(1));}
8d30dcb37a69fb43a90c8ad0f0f3ad3d4e7807c7cd291821c7c1d4ea29023c92
generate2dSamples
private void generate2dSamples(int num, double mx, double my, double sdx, double sdy)
{    log.info("Generating {} samples m=[{}, {}] sd=[{}, {}]", num, mx, my, sdx, sdy);    for (int i = 0; i < num; i++) {        sampleData.add(new VectorWritable(new DenseVector(new double[] { UncommonDistributions.rNorm(mx, sdx), UncommonDistributions.rNorm(my, sdy) })));    }}
93c486cf0bddfe35e5893ff1b8bceb0bb092731d1dbd6accf054b1ca7d6b181b
generateSamples
private void generateSamples()
{    generate2dSamples(50000, 1, 2, 3, 4);}
d44460c6543202dcedbd1e3b900a89679a005c606a42786ede1cbc15bf678598
testAccumulatorNoSamples
public void testAccumulatorNoSamples()
{    GaussianAccumulator accumulator0 = new RunningSumsGaussianAccumulator();    GaussianAccumulator accumulator1 = new OnlineGaussianAccumulator();    accumulator0.compute();    accumulator1.compute();    assertEquals("N", accumulator0.getN(), accumulator1.getN(), EPSILON);    assertEquals("Means", accumulator0.getMean(), accumulator1.getMean());    assertEquals("Avg Stds", accumulator0.getAverageStd(), accumulator1.getAverageStd(), EPSILON);}
2f6128177607a5a8901861dd6b2f6cbea2542396cf127da56368826f4551580f
testAccumulatorOneSample
public void testAccumulatorOneSample()
{    GaussianAccumulator accumulator0 = new RunningSumsGaussianAccumulator();    GaussianAccumulator accumulator1 = new OnlineGaussianAccumulator();    Vector sample = new DenseVector(2);    accumulator0.observe(sample, 1.0);    accumulator1.observe(sample, 1.0);    accumulator0.compute();    accumulator1.compute();    assertEquals("N", accumulator0.getN(), accumulator1.getN(), EPSILON);    assertEquals("Means", accumulator0.getMean(), accumulator1.getMean());    assertEquals("Avg Stds", accumulator0.getAverageStd(), accumulator1.getAverageStd(), EPSILON);}
0fbc5e6403e3dde051c1b85655a102a453765ee067aca091ce168c433e995be1
testOLAccumulatorResults
public void testOLAccumulatorResults()
{    GaussianAccumulator accumulator = new OnlineGaussianAccumulator();    for (VectorWritable vw : sampleData) {        accumulator.observe(vw.get(), 1.0);    }    accumulator.compute();    log.info("OL Observed {} samples m=[{}, {}] sd=[{}, {}]", accumulator.getN(), accumulator.getMean().get(0), accumulator.getMean().get(1), accumulator.getStd().get(0), accumulator.getStd().get(1));    assertEquals("OL N", sampleN, accumulator.getN(), EPSILON);    assertEquals("OL Mean", sampleMean.zSum(), accumulator.getMean().zSum(), EPSILON);    assertEquals("OL Std", sampleStd.zSum(), accumulator.getStd().zSum(), EPSILON);}
3c1dcf7e8a40c9b1139abb5128b7bac8bbfa462b80495514af653cfefc31d362
testRSAccumulatorResults
public void testRSAccumulatorResults()
{    GaussianAccumulator accumulator = new RunningSumsGaussianAccumulator();    for (VectorWritable vw : sampleData) {        accumulator.observe(vw.get(), 1.0);    }    accumulator.compute();    log.info("RS Observed {} samples m=[{}, {}] sd=[{}, {}]", (int) accumulator.getN(), accumulator.getMean().get(0), accumulator.getMean().get(1), accumulator.getStd().get(0), accumulator.getStd().get(1));    assertEquals("OL N", sampleN, accumulator.getN(), EPSILON);    assertEquals("OL Mean", sampleMean.zSum(), accumulator.getMean().zSum(), EPSILON);    assertEquals("OL Std", sampleStd.zSum(), accumulator.getStd().zSum(), 0.0001);}
e7dc9e91c3af3cbb9f1d90575de758a223f418de8bc4bcc7a9ebd112121e75ec
testAccumulatorWeightedResults
public void testAccumulatorWeightedResults()
{    GaussianAccumulator accumulator0 = new RunningSumsGaussianAccumulator();    GaussianAccumulator accumulator1 = new OnlineGaussianAccumulator();    for (VectorWritable vw : sampleData) {        accumulator0.observe(vw.get(), 0.5);        accumulator1.observe(vw.get(), 0.5);    }    accumulator0.compute();    accumulator1.compute();    assertEquals("N", accumulator0.getN(), accumulator1.getN(), EPSILON);    assertEquals("Means", accumulator0.getMean().zSum(), accumulator1.getMean().zSum(), EPSILON);    assertEquals("Stds", accumulator0.getStd().zSum(), accumulator1.getStd().zSum(), 0.001);    assertEquals("Variance", accumulator0.getVariance().zSum(), accumulator1.getVariance().zSum(), 0.01);}
64166deddab0a9145a6e6bf422c486f0096f3143712e981c124b95123702c47c
testAccumulatorWeightedResults2
public void testAccumulatorWeightedResults2()
{    GaussianAccumulator accumulator0 = new RunningSumsGaussianAccumulator();    GaussianAccumulator accumulator1 = new OnlineGaussianAccumulator();    for (VectorWritable vw : sampleData) {        accumulator0.observe(vw.get(), 1.5);        accumulator1.observe(vw.get(), 1.5);    }    accumulator0.compute();    accumulator1.compute();    assertEquals("N", accumulator0.getN(), accumulator1.getN(), EPSILON);    assertEquals("Means", accumulator0.getMean().zSum(), accumulator1.getMean().zSum(), EPSILON);    assertEquals("Stds", accumulator0.getStd().zSum(), accumulator1.getStd().zSum(), 0.001);    assertEquals("Variance", accumulator0.getVariance().zSum(), accumulator1.getVariance().zSum(), 0.01);}
79c1b50d722a0ed47b765edcd4db6a24ea7d56253c2edb1b24318edfa9f4861f
shouldReturnTopLevelClusterPath
public void shouldReturnTopLevelClusterPath()
{    Path expectedPath = new Path(output, PathDirectory.TOP_LEVEL_CLUSTER_DIRECTORY);    assertEquals(expectedPath, PathDirectory.getTopLevelClusterPath(output));}
f18838540c5aed719369da26a3af518e5ff4b681c9b7dd7cade0537d1811347d
shouldReturnClusterPostProcessorOutputDirectory
public void shouldReturnClusterPostProcessorOutputDirectory()
{    Path expectedPath = new Path(output, PathDirectory.POST_PROCESS_DIRECTORY);    assertEquals(expectedPath, PathDirectory.getClusterPostProcessorOutputDirectory(output));}
83aec944717639c0f9d7c48f15b32a450bffd19d1ee78ff052ab7b539c03b791
shouldReturnClusterOutputClusteredPoints
public void shouldReturnClusterOutputClusteredPoints()
{    Path expectedPath = new Path(output, PathDirectory.CLUSTERED_POINTS_DIRECTORY + File.separator + '*');    assertEquals(expectedPath, PathDirectory.getClusterOutputClusteredPoints(output));}
86baf2ba391871c0572fd97cddb2399650c82636923a101e4d682f51481dc071
shouldReturnBottomLevelClusterPath
public void shouldReturnBottomLevelClusterPath()
{    Path expectedPath = new Path(output + File.separator + PathDirectory.BOTTOM_LEVEL_CLUSTER_DIRECTORY + File.separator + '1');    assertEquals(expectedPath, PathDirectory.getBottomLevelClusterPath(output, "1"));}
1856a5b0ee058a1c5e5d3692dc1a1971d93b302f22165c0fc9177f9b61a1564f
shouldReturnClusterPathForClusterId
public void shouldReturnClusterPathForClusterId()
{    Path expectedPath = new Path(PathDirectory.getClusterPostProcessorOutputDirectory(output), new Path("1"));    assertEquals(expectedPath, PathDirectory.getClusterPathForClusterId(PathDirectory.getClusterPostProcessorOutputDirectory(output), "1"));}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    super.setUp();    Configuration conf = getConfiguration();    fs = FileSystem.get(conf);}
0a28500ed96929b305e206e2747fe2cf0665393e55c9a75c52adcd563657336f
getPointsWritable
public static List<VectorWritable> getPointsWritable(double[][] raw)
{    List<VectorWritable> points = Lists.newArrayList();    for (double[] fr : raw) {        Vector vec = new RandomAccessSparseVector(fr.length);        vec.assign(fr);        points.add(new VectorWritable(vec));    }    return points;}
866dbd74cb01501ac1c8eeebd0bde1f4e993bb20435d43b8d3ded6e558a63891
testGetNumberOfClusters
public void testGetNumberOfClusters() throws Exception
{    List<VectorWritable> points = getPointsWritable(REFERENCE);    Path pointsPath = getTestTempDirPath("points");    Configuration conf = getConfiguration();    ClusteringTestUtils.writePointsToFile(points, new Path(pointsPath, "file1"), fs, conf);    ClusteringTestUtils.writePointsToFile(points, new Path(pointsPath, "file2"), fs, conf);    outputPathForCanopy = getTestTempDirPath("canopy");    outputPathForKMeans = getTestTempDirPath("kmeans");    topLevelClustering(pointsPath, conf);    int numberOfClusters = ClusterCountReader.getNumberOfClusters(outputPathForKMeans, conf);    Assert.assertEquals(2, numberOfClusters);    verifyThatNumberOfClustersIsCorrect(conf, new Path(outputPathForKMeans, new Path("clusteredPoints")));}
98ffb57260d59c650bbbe6781df69080145e86dcf27bf78c2a8e617f5bee014a
topLevelClustering
private void topLevelClustering(Path pointsPath, Configuration conf) throws IOException, InterruptedException, ClassNotFoundException
{    DistanceMeasure measure = new ManhattanDistanceMeasure();    CanopyDriver.run(conf, pointsPath, outputPathForCanopy, measure, 4.0, 3.0, true, 0.0, true);    Path clustersIn = new Path(outputPathForCanopy, new Path(Cluster.CLUSTERS_DIR + '0' + Cluster.FINAL_ITERATION_SUFFIX));    KMeansDriver.run(conf, pointsPath, clustersIn, outputPathForKMeans, 1, 1, true, 0.0, true);}
2151861b1ef4a6eeecd913d1d75bfe2cbf0ff060d497875d99ceca0c9cbc5696
verifyThatNumberOfClustersIsCorrect
private static void verifyThatNumberOfClustersIsCorrect(Configuration conf, Path clusteredPointsPath)
{    DummyOutputCollector<IntWritable, WeightedVectorWritable> collector = new DummyOutputCollector<>();        for (Pair<IntWritable, WeightedVectorWritable> record : new SequenceFileIterable<IntWritable, WeightedVectorWritable>(new Path(clusteredPointsPath, "part-m-0"), conf)) {        collector.collect(record.getFirst(), record.getSecond());    }    int clusterSize = collector.getKeys().size();    assertEquals(2, clusterSize);}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    super.setUp();    Configuration conf = getConfiguration();    fs = FileSystem.get(conf);}
e3562711d8a9018f0912abf9d48c718794d70ebffbfaec82bebd277132fbea95
getPointsWritable
private static List<VectorWritable> getPointsWritable(double[][] raw)
{    List<VectorWritable> points = Lists.newArrayList();    for (double[] fr : raw) {        Vector vec = new RandomAccessSparseVector(fr.length);        vec.assign(fr);        points.add(new VectorWritable(vec));    }    return points;}
e0f1ee1ba513eb8736f459c51eb1280ffa3f1b901a9c4901fb5f44ebad01809c
testTopDownClustering
public void testTopDownClustering() throws Exception
{    List<VectorWritable> points = getPointsWritable(REFERENCE);    Path pointsPath = getTestTempDirPath("points");    conf = getConfiguration();    ClusteringTestUtils.writePointsToFile(points, new Path(pointsPath, "file1"), fs, conf);    ClusteringTestUtils.writePointsToFile(points, new Path(pointsPath, "file2"), fs, conf);    outputPath = getTestTempDirPath("output");    topLevelClustering(pointsPath, conf);    Map<String, Path> postProcessedClusterDirectories = ouputPostProcessing(conf);    assertPostProcessedOutput(postProcessedClusterDirectories);    bottomLevelClustering(postProcessedClusterDirectories);}
5bc95176d6253e1eee638ab63336b360e14a543b7f451f55192abce62755c9c8
assertTopLevelCluster
private void assertTopLevelCluster(Entry<String, Path> cluster)
{    String clusterId = cluster.getKey();    Path clusterPath = cluster.getValue();    try {        if ("0".equals(clusterId)) {            assertPointsInFirstTopLevelCluster(clusterPath);        } else if ("1".equals(clusterId)) {            assertPointsInSecondTopLevelCluster(clusterPath);        }    } catch (IOException e) {        Assert.fail("Exception occurred while asserting top level cluster.");    }}
a3e6c3e567add13ec2e6545ff81e8f0b5871e574626c8d06d201a426ddb1d47b
assertPointsInFirstTopLevelCluster
private void assertPointsInFirstTopLevelCluster(Path clusterPath) throws IOException
{    List<Vector> vectorsInCluster = getVectorsInCluster(clusterPath);    for (Vector vector : vectorsInCluster) {        Assert.assertTrue(ArrayUtils.contains(new String[] { "{0:1.0,1:1.0}", "{0:2.0,1:1.0}", "{0:1.0,1:2.0}" }, vector.asFormatString()));    }}
a8d21f9a58673b17206e8904224c7e054c1b763167373a60c5583946ba5d5210
assertPointsInSecondTopLevelCluster
private void assertPointsInSecondTopLevelCluster(Path clusterPath) throws IOException
{    List<Vector> vectorsInCluster = getVectorsInCluster(clusterPath);    for (Vector vector : vectorsInCluster) {        Assert.assertTrue(ArrayUtils.contains(new String[] { "{0:4.0,1:4.0}", "{0:5.0,1:4.0}", "{0:4.0,1:5.0}", "{0:5.0,1:5.0}" }, vector.asFormatString()));    }}
b58386eced7268ef29301c7d142a7b2510b118a0ac8c29521ffea64233f56863
getVectorsInCluster
private List<Vector> getVectorsInCluster(Path clusterPath) throws IOException
{    Path[] partFilePaths = FileUtil.stat2Paths(fs.globStatus(clusterPath));    FileStatus[] listStatus = fs.listStatus(partFilePaths);    List<Vector> vectors = Lists.newArrayList();    for (FileStatus partFile : listStatus) {        SequenceFile.Reader topLevelClusterReader = new SequenceFile.Reader(fs, partFile.getPath(), conf);        Writable clusterIdAsKey = new LongWritable();        VectorWritable point = new VectorWritable();        while (topLevelClusterReader.next(clusterIdAsKey, point)) {            vectors.add(point.get());        }    }    return vectors;}
41c291e1dad79ef91ea759ae51dafdd6656ae03161135cd2806ff5722178ca8e
bottomLevelClustering
private void bottomLevelClustering(Map<String, Path> postProcessedClusterDirectories) throws IOException, InterruptedException, ClassNotFoundException
{    for (Entry<String, Path> topLevelCluster : postProcessedClusterDirectories.entrySet()) {        String clusterId = topLevelCluster.getKey();        Path topLevelclusterPath = topLevelCluster.getValue();        Path bottomLevelCluster = PathDirectory.getBottomLevelClusterPath(outputPath, clusterId);        CanopyDriver.run(conf, topLevelclusterPath, bottomLevelCluster, new ManhattanDistanceMeasure(), 2.1, 2.0, true, 0.0, true);        assertBottomLevelCluster(bottomLevelCluster);    }}
ad92c5eb24847a09f19cbf045e0661d0d360dea5a547ec4904bde97ad4e82204
assertBottomLevelCluster
private void assertBottomLevelCluster(Path bottomLevelCluster)
{    Path clusteredPointsPath = new Path(bottomLevelCluster, "clusteredPoints");    DummyOutputCollector<IntWritable, WeightedVectorWritable> collector = new DummyOutputCollector<>();        for (Pair<IntWritable, WeightedVectorWritable> record : new SequenceFileIterable<IntWritable, WeightedVectorWritable>(new Path(clusteredPointsPath, "part-m-0"), conf)) {        collector.collect(record.getFirst(), record.getSecond());    }    int clusterSize = collector.getKeys().size();        assertTrue(clusterSize == 1 || clusterSize == 2);}
959d76df764c1753505f429ed6f05214b00f5182180eb5b647c22f66f2f28bb1
assertPostProcessedOutput
private void assertPostProcessedOutput(Map<String, Path> postProcessedClusterDirectories)
{    for (Entry<String, Path> cluster : postProcessedClusterDirectories.entrySet()) {        assertTopLevelCluster(cluster);    }}
b74fda8713349f28c583228571e148538d57d384e107bd9450835abc7aeb039a
ouputPostProcessing
private Map<String, Path> ouputPostProcessing(Configuration conf) throws IOException
{    ClusterOutputPostProcessor clusterOutputPostProcessor = new ClusterOutputPostProcessor(outputPath, outputPath, conf);    clusterOutputPostProcessor.process();    return clusterOutputPostProcessor.getPostProcessedClusterDirectories();}
98ffb57260d59c650bbbe6781df69080145e86dcf27bf78c2a8e617f5bee014a
topLevelClustering
private void topLevelClustering(Path pointsPath, Configuration conf) throws IOException, InterruptedException, ClassNotFoundException
{    CanopyDriver.run(conf, pointsPath, outputPath, new ManhattanDistanceMeasure(), 3.1, 2.1, true, 0.0, true);}
809f7516425b1c38e017193124aeb7a8b4a0920b572ca127fac64d7b38a01b3d
testFlag
public void testFlag() throws Exception
{    final Map<String, List<String>> testMap = Maps.newHashMap();    AbstractJobFactory fact = new AbstractJobFactory() {        @Override        public AbstractJob getJob() {            return new AbstractJob() {                @Override                public int run(String[] args) throws IOException {                    addFlag("testFlag", "t", "a simple test flag");                    Map<String, List<String>> argMap = parseArguments(args);                    testMap.clear();                    testMap.putAll(argMap);                    return 1;                }            };        }    };        ToolRunner.run(fact.getJob(), new String[0]);    assertFalse("test map for absent flag", testMap.containsKey("--testFlag"));    String[] withFlag = { "--testFlag" };    ToolRunner.run(fact.getJob(), withFlag);    assertTrue("test map for present flag", testMap.containsKey("--testFlag"));}
3154f3bad9e9b405ace99740daeb00432b61cc81e86288b44d2886b2f3124bf3
getJob
public AbstractJob getJob()
{    return new AbstractJob() {        @Override        public int run(String[] args) throws IOException {            addFlag("testFlag", "t", "a simple test flag");            Map<String, List<String>> argMap = parseArguments(args);            testMap.clear();            testMap.putAll(argMap);            return 1;        }    };}
d756081f6122b82915ed5d6542d8c0a46cde13d93e4e426add1fcd67fd99590a
run
public int run(String[] args) throws IOException
{    addFlag("testFlag", "t", "a simple test flag");    Map<String, List<String>> argMap = parseArguments(args);    testMap.clear();    testMap.putAll(argMap);    return 1;}
8d5a1c70a5a42dfccd954328a6fb267785f09d415e93df22f7b7e578bd4bf938
testOptions
public void testOptions() throws Exception
{    final Map<String, List<String>> testMap = Maps.newHashMap();    AbstractJobFactory fact = new AbstractJobFactory() {        @Override        public AbstractJob getJob() {            return new AbstractJob() {                @Override                public int run(String[] args) throws IOException {                    this.addOption(DefaultOptionCreator.overwriteOption().create());                    this.addOption("option", "o", "option");                    this.addOption("required", "r", "required", true);                    this.addOption("notRequired", "nr", "not required", false);                    this.addOption("hasDefault", "hd", "option w/ default", "defaultValue");                    Map<String, List<String>> argMap = parseArguments(args);                    if (argMap == null) {                        return -1;                    }                    testMap.clear();                    testMap.putAll(argMap);                    return 0;                }            };        }    };    int ret = ToolRunner.run(fact.getJob(), new String[0]);    assertEquals("-1 for missing required options", -1, ret);    ret = ToolRunner.run(fact.getJob(), new String[] { "--required", "requiredArg" });    assertEquals("0 for no missing required options", 0, ret);    assertEquals(Collections.singletonList("requiredArg"), testMap.get("--required"));    assertEquals(Collections.singletonList("defaultValue"), testMap.get("--hasDefault"));    assertNull(testMap.get("--option"));    assertNull(testMap.get("--notRequired"));    assertFalse(testMap.containsKey("--overwrite"));    ret = ToolRunner.run(fact.getJob(), new String[] { "--required", "requiredArg", "--unknownArg" });    assertEquals("-1 for including unknown options", -1, ret);    ret = ToolRunner.run(fact.getJob(), new String[] { "--required", "requiredArg", "--required", "requiredArg2" });    assertEquals("-1 for including duplicate options", -1, ret);    ret = ToolRunner.run(fact.getJob(), new String[] { "--required", "requiredArg", "--overwrite", "--hasDefault", "nonDefault", "--option", "optionValue", "--notRequired", "notRequired" });    assertEquals("0 for no missing required options", 0, ret);    assertEquals(Collections.singletonList("requiredArg"), testMap.get("--required"));    assertEquals(Collections.singletonList("nonDefault"), testMap.get("--hasDefault"));    assertEquals(Collections.singletonList("optionValue"), testMap.get("--option"));    assertEquals(Collections.singletonList("notRequired"), testMap.get("--notRequired"));    assertTrue(testMap.containsKey("--overwrite"));    ret = ToolRunner.run(fact.getJob(), new String[] { "-r", "requiredArg", "-ow", "-hd", "nonDefault", "-o", "optionValue", "-nr", "notRequired" });    assertEquals("0 for no missing required options", 0, ret);    assertEquals(Collections.singletonList("requiredArg"), testMap.get("--required"));    assertEquals(Collections.singletonList("nonDefault"), testMap.get("--hasDefault"));    assertEquals(Collections.singletonList("optionValue"), testMap.get("--option"));    assertEquals(Collections.singletonList("notRequired"), testMap.get("--notRequired"));    assertTrue(testMap.containsKey("--overwrite"));}
3154f3bad9e9b405ace99740daeb00432b61cc81e86288b44d2886b2f3124bf3
getJob
public AbstractJob getJob()
{    return new AbstractJob() {        @Override        public int run(String[] args) throws IOException {            this.addOption(DefaultOptionCreator.overwriteOption().create());            this.addOption("option", "o", "option");            this.addOption("required", "r", "required", true);            this.addOption("notRequired", "nr", "not required", false);            this.addOption("hasDefault", "hd", "option w/ default", "defaultValue");            Map<String, List<String>> argMap = parseArguments(args);            if (argMap == null) {                return -1;            }            testMap.clear();            testMap.putAll(argMap);            return 0;        }    };}
d756081f6122b82915ed5d6542d8c0a46cde13d93e4e426add1fcd67fd99590a
run
public int run(String[] args) throws IOException
{    this.addOption(DefaultOptionCreator.overwriteOption().create());    this.addOption("option", "o", "option");    this.addOption("required", "r", "required", true);    this.addOption("notRequired", "nr", "not required", false);    this.addOption("hasDefault", "hd", "option w/ default", "defaultValue");    Map<String, List<String>> argMap = parseArguments(args);    if (argMap == null) {        return -1;    }    testMap.clear();    testMap.putAll(argMap);    return 0;}
be221f12cc4327a80bfc4c05adb54f7e0a7dca113459fdb720f49e98f78cb772
testInputOutputPaths
public void testInputOutputPaths() throws Exception
{    AbstractJobFactory fact = new AbstractJobFactory() {        @Override        public AbstractJob getJob() {            return new AbstractJob() {                @Override                public int run(String[] args) throws IOException {                    addInputOption();                    addOutputOption();                                        Map<String, List<String>> argMap = parseArguments(args);                    if (argMap == null) {                        return -1;                    }                    Path inputPath = getInputPath();                    assertNotNull("getInputPath() returns non-null", inputPath);                    Path outputPath = getInputPath();                    assertNotNull("getOutputPath() returns non-null", outputPath);                    return 0;                }            };        }    };    int ret = ToolRunner.run(fact.getJob(), new String[0]);    assertEquals("-1 for missing input option", -1, ret);    String testInputPath = "testInputPath";    AbstractJob job = fact.getJob();    ret = ToolRunner.run(job, new String[] { "--input", testInputPath });    assertEquals("-1 for missing output option", -1, ret);    assertEquals("input path is correct", testInputPath, job.getInputPath().toString());    job = fact.getJob();    String testOutputPath = "testOutputPath";    ret = ToolRunner.run(job, new String[] { "--output", testOutputPath });    assertEquals("-1 for missing input option", -1, ret);    assertEquals("output path is correct", testOutputPath, job.getOutputPath().toString());    job = fact.getJob();    ret = ToolRunner.run(job, new String[] { "--input", testInputPath, "--output", testOutputPath });    assertEquals("0 for complete options", 0, ret);    assertEquals("input path is correct", testInputPath, job.getInputPath().toString());    assertEquals("output path is correct", testOutputPath, job.getOutputPath().toString());    job = fact.getJob();    ret = ToolRunner.run(job, new String[] { "--input", testInputPath, "--output", testOutputPath });    assertEquals("0 for complete options", 0, ret);    assertEquals("input path is correct", testInputPath, job.getInputPath().toString());    assertEquals("output path is correct", testOutputPath, job.getOutputPath().toString());    job = fact.getJob();    String testInputPropertyPath = "testInputPropertyPath";    String testOutputPropertyPath = "testOutputPropertyPath";    ret = ToolRunner.run(job, new String[] { "-Dmapred.input.dir=" + testInputPropertyPath, "-Dmapred.output.dir=" + testOutputPropertyPath });    assertEquals("0 for complete options", 0, ret);    assertEquals("input path from property is correct", testInputPropertyPath, job.getInputPath().toString());    assertEquals("output path from property is correct", testOutputPropertyPath, job.getOutputPath().toString());    job = fact.getJob();    ret = ToolRunner.run(job, new String[] { "-Dmapred.input.dir=" + testInputPropertyPath, "-Dmapred.output.dir=" + testOutputPropertyPath, "--input", testInputPath, "--output", testOutputPath });    assertEquals("0 for complete options", 0, ret);    assertEquals("input command-line option precedes property", testInputPath, job.getInputPath().toString());    assertEquals("output command-line option precedes property", testOutputPath, job.getOutputPath().toString());}
3154f3bad9e9b405ace99740daeb00432b61cc81e86288b44d2886b2f3124bf3
getJob
public AbstractJob getJob()
{    return new AbstractJob() {        @Override        public int run(String[] args) throws IOException {            addInputOption();            addOutputOption();                        Map<String, List<String>> argMap = parseArguments(args);            if (argMap == null) {                return -1;            }            Path inputPath = getInputPath();            assertNotNull("getInputPath() returns non-null", inputPath);            Path outputPath = getInputPath();            assertNotNull("getOutputPath() returns non-null", outputPath);            return 0;        }    };}
d756081f6122b82915ed5d6542d8c0a46cde13d93e4e426add1fcd67fd99590a
run
public int run(String[] args) throws IOException
{    addInputOption();    addOutputOption();        Map<String, List<String>> argMap = parseArguments(args);    if (argMap == null) {        return -1;    }    Path inputPath = getInputPath();    assertNotNull("getInputPath() returns non-null", inputPath);    Path outputPath = getInputPath();    assertNotNull("getOutputPath() returns non-null", outputPath);    return 0;}
3a33e5e31464ce05a8727671a0c30540d680b69795be4be0812087768160b57b
testMeasure
public void testMeasure()
{    DistanceMeasure distanceMeasure = new CosineDistanceMeasure();    Vector[] vectors = { new DenseVector(new double[] { 1, 0, 0, 0, 0, 0 }), new DenseVector(new double[] { 1, 1, 1, 0, 0, 0 }), new DenseVector(new double[] { 1, 1, 1, 1, 1, 1 }) };    double[][] distanceMatrix = new double[3][3];    for (int a = 0; a < 3; a++) {        for (int b = 0; b < 3; b++) {            distanceMatrix[a][b] = distanceMeasure.distance(vectors[a], vectors[b]);        }    }    assertEquals(0.0, distanceMatrix[0][0], EPSILON);    assertTrue(distanceMatrix[0][0] < distanceMatrix[0][1]);    assertTrue(distanceMatrix[0][1] < distanceMatrix[0][2]);    assertEquals(0.0, distanceMatrix[1][1], EPSILON);    assertTrue(distanceMatrix[1][0] > distanceMatrix[1][1]);    assertTrue(distanceMatrix[1][2] < distanceMatrix[1][0]);    assertEquals(0.0, distanceMatrix[2][2], EPSILON);    assertTrue(distanceMatrix[2][0] > distanceMatrix[2][1]);    assertTrue(distanceMatrix[2][1] > distanceMatrix[2][2]);        assertEquals(0, distanceMeasure.distance(new SequentialAccessSparseVector(1), new SequentialAccessSparseVector(1)), EPSILON);}
3a33e5e31464ce05a8727671a0c30540d680b69795be4be0812087768160b57b
testMeasure
public void testMeasure()
{    DistanceMeasure distanceMeasure = distanceMeasureFactory();    Vector[] vectors = { new DenseVector(new double[] { 1, 1, 1, 1, 1, 1 }), new DenseVector(new double[] { 2, 2, 2, 2, 2, 2 }), new DenseVector(new double[] { 6, 6, 6, 6, 6, 6 }), new DenseVector(new double[] { -1, -1, -1, -1, -1, -1 }) };    compare(distanceMeasure, vectors);    vectors = new Vector[4];    vectors[0] = new RandomAccessSparseVector(5);    vectors[0].setQuick(0, 1);    vectors[0].setQuick(3, 1);    vectors[0].setQuick(4, 1);    vectors[1] = new RandomAccessSparseVector(5);    vectors[1].setQuick(0, 2);    vectors[1].setQuick(3, 2);    vectors[1].setQuick(4, 2);    vectors[2] = new RandomAccessSparseVector(5);    vectors[2].setQuick(0, 6);    vectors[2].setQuick(3, 6);    vectors[2].setQuick(4, 6);    vectors[3] = new RandomAccessSparseVector(5);    compare(distanceMeasure, vectors);}
987580de83e24fd819185223379bd95f7ceb32cd07f5e05cb04ed31fcd1d9754
compare
private static void compare(DistanceMeasure distanceMeasure, Vector[] vectors)
{    double[][] distanceMatrix = new double[4][4];    for (int a = 0; a < 4; a++) {        for (int b = 0; b < 4; b++) {            distanceMatrix[a][b] = distanceMeasure.distance(vectors[a], vectors[b]);        }    }    assertEquals("Distance from first vector to itself is not zero", 0.0, distanceMatrix[0][0], EPSILON);    assertTrue(distanceMatrix[0][0] < distanceMatrix[0][1]);    assertTrue(distanceMatrix[0][1] < distanceMatrix[0][2]);    assertEquals("Distance from second vector to itself is not zero", 0.0, distanceMatrix[1][1], EPSILON);    assertTrue(distanceMatrix[1][0] > distanceMatrix[1][1]);    assertTrue(distanceMatrix[1][2] > distanceMatrix[1][0]);    assertEquals("Distance from third vector to itself is not zero", 0.0, distanceMatrix[2][2], EPSILON);    assertTrue(distanceMatrix[2][0] > distanceMatrix[2][1]);    assertTrue(distanceMatrix[2][1] > distanceMatrix[2][2]);    for (int a = 0; a < 4; a++) {        for (int b = 0; b < 4; b++) {            assertTrue("Distance between vectors less than zero: " + distanceMatrix[a][b] + " = " + distanceMeasure + ".distance(" + vectors[a].asFormatString() + ", " + vectors[b].asFormatString() + ')', distanceMatrix[a][b] >= 0);            if (vectors[a].plus(vectors[b]).norm(2) == 0 && vectors[a].norm(2) > 0) {                assertTrue("Distance from v to -v is equal to zero" + vectors[a].asFormatString() + " = -" + vectors[b].asFormatString(), distanceMatrix[a][b] > 0);            }        }    }}
6ab516d6a45d5a92befdeb2bde2638793d1e450bede63feb7893a854dcee883b
testMeasureWeighted
public void testMeasureWeighted()
{    WeightedDistanceMeasure distanceMeasure = distanceMeasureFactory();    Vector[] vectors = { new DenseVector(new double[] { 9, 9, 1 }), new DenseVector(new double[] { 1, 9, 9 }), new DenseVector(new double[] { 9, 1, 9 }) };    distanceMeasure.setWeights(new DenseVector(new double[] { 1, 1000, 1 }));    double[][] distanceMatrix = new double[3][3];    for (int a = 0; a < 3; a++) {        for (int b = 0; b < 3; b++) {            distanceMatrix[a][b] = distanceMeasure.distance(vectors[a], vectors[b]);        }    }    assertEquals(0.0, distanceMatrix[0][0], EPSILON);    assertTrue(distanceMatrix[0][1] < distanceMatrix[0][2]);}
3a33e5e31464ce05a8727671a0c30540d680b69795be4be0812087768160b57b
testMeasure
public void testMeasure()
{    DistanceMeasure chebyshevDistanceMeasure = new ChebyshevDistanceMeasure();    Vector[] vectors = { new DenseVector(new double[] { 1, 0, 0, 0, 0, 0 }), new DenseVector(new double[] { 1, 1, 1, 0, 0, 0 }), new DenseVector(new double[] { 1, 1, 1, 1, 1, 1 }) };    double[][] distances = { { 0.0, 1.0, 1.0 }, { 1.0, 0.0, 1.0 }, { 1.0, 1.0, 0.0 } };    double[][] chebyshevDistanceMatrix = new double[3][3];    for (int a = 0; a < 3; a++) {        for (int b = 0; b < 3; b++) {            chebyshevDistanceMatrix[a][b] = chebyshevDistanceMeasure.distance(vectors[a], vectors[b]);        }    }    for (int a = 0; a < 3; a++) {        for (int b = 0; b < 3; b++) {            assertEquals(distances[a][b], chebyshevDistanceMatrix[a][b], EPSILON);        }    }    assertEquals(0.0, chebyshevDistanceMatrix[0][0], EPSILON);}
b1bfd55e8dd387a389d7b504e5dbcdf8873559d9f480eb422aad0f6869cee380
distanceMeasureFactory
public DistanceMeasure distanceMeasureFactory()
{    return new EuclideanDistanceMeasure();}
3a33e5e31464ce05a8727671a0c30540d680b69795be4be0812087768160b57b
testMeasure
public void testMeasure()
{    double[][] invCovValues = { { 2.2, 0.4 }, { 0.4, 2.8 } };    double[] meanValues = { -2.3, -0.9 };    Matrix invCov = new DenseMatrix(invCovValues);    Vector meanVector = new DenseVector(meanValues);    MahalanobisDistanceMeasure distanceMeasure = new MahalanobisDistanceMeasure();    distanceMeasure.setInverseCovarianceMatrix(invCov);    distanceMeasure.setMeanVector(meanVector);    double[] v1 = { -1.9, -2.3 };    double[] v2 = { -2.9, -1.3 };    double dist = distanceMeasure.distance(new DenseVector(v1), new DenseVector(v2));    assertEquals(2.0493901531919194, dist, EPSILON);        distanceMeasure.setCovarianceMatrix(invCov);        Matrix identity = distanceMeasure.getInverseCovarianceMatrix().times(invCov);    assertEquals(1, identity.get(0, 0), EPSILON);    assertEquals(1, identity.get(1, 1), EPSILON);    assertEquals(0, identity.get(1, 0), EPSILON);    assertEquals(0, identity.get(0, 1), EPSILON);}
b1bfd55e8dd387a389d7b504e5dbcdf8873559d9f480eb422aad0f6869cee380
distanceMeasureFactory
public DistanceMeasure distanceMeasureFactory()
{    return new ManhattanDistanceMeasure();}
3a33e5e31464ce05a8727671a0c30540d680b69795be4be0812087768160b57b
testMeasure
public void testMeasure()
{    DistanceMeasure minkowskiDistanceMeasure = new MinkowskiDistanceMeasure(1.5);    DistanceMeasure manhattanDistanceMeasure = new ManhattanDistanceMeasure();    DistanceMeasure euclideanDistanceMeasure = new EuclideanDistanceMeasure();    Vector[] vectors = { new DenseVector(new double[] { 1, 0, 0, 0, 0, 0 }), new DenseVector(new double[] { 1, 1, 1, 0, 0, 0 }), new DenseVector(new double[] { 1, 1, 1, 1, 1, 1 }) };    double[][] minkowskiDistanceMatrix = new double[3][3];    double[][] manhattanDistanceMatrix = new double[3][3];    double[][] euclideanDistanceMatrix = new double[3][3];    for (int a = 0; a < 3; a++) {        for (int b = 0; b < 3; b++) {            minkowskiDistanceMatrix[a][b] = minkowskiDistanceMeasure.distance(vectors[a], vectors[b]);            manhattanDistanceMatrix[a][b] = manhattanDistanceMeasure.distance(vectors[a], vectors[b]);            euclideanDistanceMatrix[a][b] = euclideanDistanceMeasure.distance(vectors[a], vectors[b]);        }    }    for (int a = 0; a < 3; a++) {        for (int b = 0; b < 3; b++) {            assertTrue(minkowskiDistanceMatrix[a][b] <= manhattanDistanceMatrix[a][b]);            assertTrue(minkowskiDistanceMatrix[a][b] >= euclideanDistanceMatrix[a][b]);        }    }    assertEquals(0.0, minkowskiDistanceMatrix[0][0], EPSILON);    assertTrue(minkowskiDistanceMatrix[0][0] < minkowskiDistanceMatrix[0][1]);    assertTrue(minkowskiDistanceMatrix[0][1] < minkowskiDistanceMatrix[0][2]);}
22496be68e77da7e8cd6f7e68fe4a71a6e459cc992b651d1d78e38cca2b8ab1a
distanceMeasureFactory
public TanimotoDistanceMeasure distanceMeasureFactory()
{    return new TanimotoDistanceMeasure();}
34997e8a0b33fb28a0c1cecaef4218eb51aafef6ea2a9054749b4e5f6d05852f
distanceMeasureFactory
public WeightedDistanceMeasure distanceMeasureFactory()
{    return new WeightedEuclideanDistanceMeasure();}
572687b9840da414d5c9bc4afb61355b513d17eb2a0ee04696d41a677ce29bd2
distanceMeasureFactory
public WeightedManhattanDistanceMeasure distanceMeasureFactory()
{    return new WeightedManhattanDistanceMeasure();}
04592aeca638694882faba4219c5dc46f8e45c5cb051b01201c2854fbc075b2c
nonExistingFile
public void nonExistingFile()
{    Path path = HadoopUtil.findInCacheByPartOfFilename("no such file", DISTRIBUTED_CACHE_FILES);    assertNull(path);}
369c49cec148759101892475ded471dbb11fc2918b4bb373436bd29d9a820dce
existingFile
public void existingFile()
{    Path path = HadoopUtil.findInCacheByPartOfFilename("want_to_find", DISTRIBUTED_CACHE_FILES);    assertNotNull(path);    assertEquals(FILE_I_WANT_TO_FIND.getName(), path.getName());}
31433e59806bc853612b8de2f16aee2af918d2f6a1de1ac38ab30ebff6d6c79a
collect
public void collect(K key, V values)
{    List<V> points = data.get(key);    if (points == null) {        points = Lists.newArrayList();        data.put(key, points);    }    points.add(values);}
475eac8ee1f15fbd3212064b483c4996adf45e735f393874701c15f75472a8a0
getData
public Map<K, List<V>> getData()
{    return data;}
ac6b5c90556c7c0479484b8c3af2d33eaf339a615841930351f7a1ff235441e6
getValue
public List<V> getValue(K key)
{    return data.get(key);}
295b0cfc731da251bff58439916c01aa06d676b3725a6bb10efbfe48830861e6
getKeys
public Set<K> getKeys()
{    return data.keySet();}
d6943ade59c7137afc60c790d44c6e6db0dcec8a4ac5ab65e17a683fdee91a75
write
public void write(K key, V value)
{        try {        K keyToUse = key instanceof NullWritable ? key : (K) cloneWritable(key);        V valueToUse = (V) cloneWritable(value);        keysInInsertionOrder.add(keyToUse);        List<V> points = data.get(key);        if (points == null) {            points = Lists.newArrayList();            data.put(keyToUse, points);        }        points.add(valueToUse);    } catch (IOException e) {        throw new RuntimeException(e.getMessage(), e);    }}
e9d1f38d8bcfe71af5149ee25aecd12f1f2df74d5f9fcca8fb2ad9253e541203
cloneWritable
private Writable cloneWritable(Writable original) throws IOException
{    Writable clone;    try {        clone = original.getClass().asSubclass(Writable.class).newInstance();    } catch (Exception e) {        throw new RuntimeException("Unable to instantiate writable!", e);    }    ByteArrayOutputStream bytes = new ByteArrayOutputStream();    original.write(new DataOutputStream(bytes));    clone.readFields(new DataInputStream(new ByteArrayInputStream(bytes.toByteArray())));    return clone;}
4393d303d37588df3d198a786ac751a5cf427a69d958db071c2108873b7e4b0e
close
public void close(TaskAttemptContext context)
{}
475eac8ee1f15fbd3212064b483c4996adf45e735f393874701c15f75472a8a0
getData
public Map<K, List<V>> getData()
{    return data;}
ac6b5c90556c7c0479484b8c3af2d33eaf339a615841930351f7a1ff235441e6
getValue
public List<V> getValue(K key)
{    return data.get(key);}
295b0cfc731da251bff58439916c01aa06d676b3725a6bb10efbfe48830861e6
getKeys
public Set<K> getKeys()
{    return data.keySet();}
21ff8ddfcc4ba3a01248267de7d366398309f8e25f0e4fae980d3647769c0af6
getKeysInInsertionOrder
public Iterable<K> getKeysInInsertionOrder()
{    return keysInInsertionOrder;}
ba172560a25c1296c6b757219c473b83edb1e4a000b0f7b165a0f739bb1aa1d8
build
public static Mapper<K1, V1, K2, V2>.Context build(Mapper<K1, V1, K2, V2> mapper, Configuration configuration, RecordWriter<K2, V2> output)
{        try {        return buildNewMapperContext(configuration, output);    } catch (Exception | IncompatibleClassChangeError e) {        try {            return buildOldMapperContext(mapper, configuration, output);        } catch (Exception ex) {            throw new IllegalStateException(ex);        }    }}
472c4ad302eb4134cae5fb47136ed7e363c02c9c3450ff52d0f1be31ba6d9fee
build
public static Reducer<K1, V1, K2, V2>.Context build(Reducer<K1, V1, K2, V2> reducer, Configuration configuration, RecordWriter<K2, V2> output, Class<K1> keyClass, Class<V1> valueClass)
{        try {        return buildNewReducerContext(configuration, output, keyClass, valueClass);    } catch (Exception | IncompatibleClassChangeError e) {        try {            return buildOldReducerContext(reducer, configuration, output, keyClass, valueClass);        } catch (Exception ex) {            throw new IllegalStateException(ex);        }    }}
1d4b8b634f5ab585387cfc779b85f56982c264dd5af760eabec9c1e821b8d0d7
buildNewMapperContext
private static Mapper<K1, V1, K2, V2>.Context buildNewMapperContext(Configuration configuration, RecordWriter<K2, V2> output) throws Exception
{    Class<?> mapContextImplClass = Class.forName("org.apache.hadoop.mapreduce.task.MapContextImpl");    Constructor<?> cons = mapContextImplClass.getConstructors()[0];    Object mapContextImpl = cons.newInstance(configuration, new TaskAttemptID(), null, output, null, new DummyStatusReporter(), null);    Class<?> wrappedMapperClass = Class.forName("org.apache.hadoop.mapreduce.lib.map.WrappedMapper");    Object wrappedMapper = wrappedMapperClass.getConstructor().newInstance();    Method getMapContext = wrappedMapperClass.getMethod("getMapContext", MapContext.class);    return (Mapper.Context) getMapContext.invoke(wrappedMapper, mapContextImpl);}
36795b9d3aa898ae922c9482d4217b8f25bdff0fa0971e18ea892fd8ef1cf5f6
buildOldMapperContext
private static Mapper<K1, V1, K2, V2>.Context buildOldMapperContext(Mapper<K1, V1, K2, V2> mapper, Configuration configuration, RecordWriter<K2, V2> output) throws Exception
{    Constructor<?> cons = getNestedContextConstructor(mapper.getClass());        return (Mapper.Context) cons.newInstance(mapper, configuration, new TaskAttemptID(), null, output, null, new DummyStatusReporter(), null);}
89ccd0c49c60c3b2052ca14b022cdf2b312e0e9720d3a81318d052a8842c595b
buildNewReducerContext
private static Reducer<K1, V1, K2, V2>.Context buildNewReducerContext(Configuration configuration, RecordWriter<K2, V2> output, Class<K1> keyClass, Class<V1> valueClass) throws Exception
{    Class<?> reduceContextImplClass = Class.forName("org.apache.hadoop.mapreduce.task.ReduceContextImpl");    Constructor<?> cons = reduceContextImplClass.getConstructors()[0];    Object reduceContextImpl = cons.newInstance(configuration, new TaskAttemptID(), new MockIterator(), null, null, output, null, new DummyStatusReporter(), null, keyClass, valueClass);    Class<?> wrappedReducerClass = Class.forName("org.apache.hadoop.mapreduce.lib.reduce.WrappedReducer");    Object wrappedReducer = wrappedReducerClass.getConstructor().newInstance();    Method getReducerContext = wrappedReducerClass.getMethod("getReducerContext", ReduceContext.class);    return (Reducer.Context) getReducerContext.invoke(wrappedReducer, reduceContextImpl);}
93902b5484e5a830cacf79d68a85c33dc615ef4a2c61c57d2df5d5c950bb4ee9
buildOldReducerContext
private static Reducer<K1, V1, K2, V2>.Context buildOldReducerContext(Reducer<K1, V1, K2, V2> reducer, Configuration configuration, RecordWriter<K2, V2> output, Class<K1> keyClass, Class<V1> valueClass) throws Exception
{    Constructor<?> cons = getNestedContextConstructor(reducer.getClass());        return (Reducer.Context) cons.newInstance(reducer, configuration, new TaskAttemptID(), new MockIterator(), null, null, output, null, new DummyStatusReporter(), null, keyClass, valueClass);}
49d098e429cb51d45bb50fccb382c1660366762e8b67c0d6c0712b2a1f36083b
getNestedContextConstructor
private static Constructor<?> getNestedContextConstructor(Class<?> outerClass)
{    for (Class<?> nestedClass : outerClass.getClasses()) {        if ("Context".equals(nestedClass.getSimpleName())) {            return nestedClass.getConstructors()[0];        }    }    throw new IllegalStateException("Cannot find context class for " + outerClass);}
1828ebdadd57698187fca25559d1dbe36c810c379b946b3ab454fbc349512477
testWrite
public void testWrite()
{    DummyRecordWriter<IntWritable, VectorWritable> writer = new DummyRecordWriter<>();    IntWritable reusableIntWritable = new IntWritable();    VectorWritable reusableVectorWritable = new VectorWritable();    reusableIntWritable.set(0);    reusableVectorWritable.set(new DenseVector(new double[] { 1, 2, 3 }));    writer.write(reusableIntWritable, reusableVectorWritable);    reusableIntWritable.set(1);    reusableVectorWritable.set(new DenseVector(new double[] { 4, 5, 6 }));    writer.write(reusableIntWritable, reusableVectorWritable);    Assert.assertEquals("The writer must remember the two keys that is written to it", 2, writer.getKeys().size());}
13ea7735491a4ccdc68bd97ecd8f69b7ba08367dcb8ac9ec6c169a2ac0594d3c
newCounter
private static Counter newCounter()
{    try {                String c = "org.apache.hadoop.mapreduce.counters.GenericCounter";        return (Counter) EasyMock.createMockBuilder(Class.forName(c)).createMock();    } catch (ClassNotFoundException e) {                return EasyMock.createMockBuilder(Counter.class).createMock();    }}
71f364c052061b6be92d755b3dbc9a2150680fa29ef26211465e6be2d6d866d2
getCounter
public Counter getCounter(Enum<?> name)
{    if (!counters.containsKey(name)) {        counters.put(name, newCounter());    }    return counters.get(name);}
9524af0ea9a28eed6bab0e561ab34b0dedc9c2ef230a6813ea7a261a40a28bf0
getCounter
public Counter getCounter(String group, String name)
{    if (!counterGroups.containsKey(group + name)) {        counterGroups.put(group + name, newCounter());    }    return counterGroups.get(group + name);}
0aa07c49327a95be1224ed8083daf0f4a877dc6e09cdf3ba8a9c6246342a910f
progress
public void progress()
{}
14112bf6b9270f87a7493911b159bee33840ecb64bc23b42c23216a4b94be05e
setStatus
public void setStatus(String status)
{}
e060dbfd6a3be1c0dc88e28d6f6317d6dff52708f9487eee73f51b4c1b3e85d1
getProgress
public float getProgress()
{    return 0.0f;}
2417ed0a986d902851335a527fcd3730cccac0eb65f5a18e489750a2519dd385
testGetSet
public void testGetSet()
{    IntPairWritable n = new IntPairWritable();    assertEquals(0, n.getFirst());    assertEquals(0, n.getSecond());    n.setFirst(5);    n.setSecond(10);    assertEquals(5, n.getFirst());    assertEquals(10, n.getSecond());    n = new IntPairWritable(2, 4);    assertEquals(2, n.getFirst());    assertEquals(4, n.getSecond());}
b760e783ced6d893c14245aa0647446f3eeb86c234d9ba85669ea1a19703381f
testWritable
public void testWritable() throws Exception
{    IntPairWritable one = new IntPairWritable(1, 2);    IntPairWritable two = new IntPairWritable(3, 4);    assertEquals(1, one.getFirst());    assertEquals(2, one.getSecond());    assertEquals(3, two.getFirst());    assertEquals(4, two.getSecond());    ByteArrayOutputStream bout = new ByteArrayOutputStream();    DataOutput out = new DataOutputStream(bout);    two.write(out);    byte[] b = bout.toByteArray();    ByteArrayInputStream bin = new ByteArrayInputStream(b);    DataInput din = new DataInputStream(bin);    one.readFields(din);    assertEquals(two.getFirst(), one.getFirst());    assertEquals(two.getSecond(), one.getSecond());}
d173853d24cad25a273f398e0add10cbf8c7804ca64655097c5008fed557109d
testComparable
public void testComparable()
{    IntPairWritable[] input = { new IntPairWritable(2, 3), new IntPairWritable(2, 2), new IntPairWritable(1, 3), new IntPairWritable(1, 2), new IntPairWritable(2, 1), new IntPairWritable(2, 2), new IntPairWritable(1, -2), new IntPairWritable(1, -1), new IntPairWritable(-2, -2), new IntPairWritable(-2, -1), new IntPairWritable(-1, -1), new IntPairWritable(-1, -2), new IntPairWritable(Integer.MAX_VALUE, 1), new IntPairWritable(Integer.MAX_VALUE / 2, 1), new IntPairWritable(Integer.MIN_VALUE, 1), new IntPairWritable(Integer.MIN_VALUE / 2, 1) };    IntPairWritable[] sorted = new IntPairWritable[input.length];    System.arraycopy(input, 0, sorted, 0, input.length);    Arrays.sort(sorted);    int[] expected = { 14, 15, 8, 9, 11, 10, 6, 7, 3, 2, 4, 1, 5, 0, 13, 12 };    for (int i = 0; i < input.length; i++) {        assertSame(input[expected[i]], sorted[i]);    }}
c0b43e4bbd49947d1e0f2acc71003b7620165e7c51dccffac8d93976d74ee5fe
testEmptyCase
public void testEmptyCase()
{    assertFalse(new CountingIterator(0).hasNext());}
6de112c1784735ad37dadf0244c35271780b674f577b923dfac3faf6acf4ba93
testCount
public void testCount()
{    Iterator<Integer> it = new CountingIterator(3);    assertTrue(it.hasNext());    assertEquals(0, (int) it.next());    assertTrue(it.hasNext());    assertEquals(1, (int) it.next());    assertTrue(it.hasNext());    assertEquals(2, (int) it.next());    assertFalse(it.hasNext());}
c0b43e4bbd49947d1e0f2acc71003b7620165e7c51dccffac8d93976d74ee5fe
testEmptyCase
public void testEmptyCase()
{    assertFalse(createSampler(100, new CountingIterator(0)).hasNext());}
281fa7ddb9d85d09f3f700b8ee9e4861f74ea9c842607767ac1e6985af1fcecf
testSmallInput
public void testSmallInput()
{    Iterator<Integer> t = createSampler(10, new CountingIterator(1));    assertTrue(t.hasNext());    assertEquals(0, t.next().intValue());    assertFalse(t.hasNext());    t = createSampler(10, new CountingIterator(1));    assertTrue(t.hasNext());    assertEquals(0, t.next().intValue());    assertFalse(t.hasNext());}
66b2e8b5fa027286e0dcbf58dd69f4641b993c0cb8295ba5b046b35d643da5de
testAbsurdSize
public void testAbsurdSize()
{    Iterator<Integer> t = createSampler(0, new CountingIterator(2));    assertFalse(t.hasNext());}
cd38b10dfcef3a82d3c9e000dc62328c1944be29dc654165fe58b8a58a5b92e3
testExactSizeMatch
public void testExactSizeMatch()
{    Iterator<Integer> t = createSampler(10, new CountingIterator(10));    for (int i = 0; i < 10; i++) {        assertTrue(t.hasNext());        assertEquals(i, t.next().intValue());    }    assertFalse(t.hasNext());}
fdf58bcb2471bab34b46d9867640f189488b11b6566a33e9095726462280d64e
testSample
public void testSample()
{    Iterator<Integer> source = new CountingIterator(100);    Iterator<Integer> t = createSampler(15, source);        List<Integer> expectedValues = Arrays.asList(52, 28, 2, 60, 50, 32, 65, 79, 78, 9, 40, 33, 96, 25, 48);    if (isSorted()) {        Collections.sort(expectedValues);    }    Iterator<Integer> expected = expectedValues.iterator();    int last = Integer.MIN_VALUE;    for (int i = 0; i < 15; i++) {        assertTrue(t.hasNext());        int actual = t.next();        if (isSorted()) {            assertTrue(actual >= last);            last = actual;        } else {                        if (actual < 15) {                assertEquals(i, actual);            }        }        assertTrue(actual >= 0 && actual < 100);                assertEquals(expected.next().intValue(), actual);        assertFalse(source.hasNext());    }    assertFalse(t.hasNext());}
a715ad474b67d8a0309fab165b3e776c49ceff71337a206fc237ac008b9c3c8e
createSampler
protected Iterator<Integer> createSampler(int n, Iterator<Integer> source)
{    return new FixedSizeSamplingIterator<>(n, source);}
66db96b6f20e68217992633d873beb35fc55c689024a68344291da44a7301c87
isSorted
protected boolean isSorted()
{    return false;}
c0b43e4bbd49947d1e0f2acc71003b7620165e7c51dccffac8d93976d74ee5fe
testEmptyCase
public void testEmptyCase()
{    assertFalse(new SamplingIterator<>(new CountingIterator(0), 0.9999).hasNext());    assertFalse(new SamplingIterator<>(new CountingIterator(0), 1).hasNext());}
281fa7ddb9d85d09f3f700b8ee9e4861f74ea9c842607767ac1e6985af1fcecf
testSmallInput
public void testSmallInput()
{    Iterator<Integer> t = new SamplingIterator<>(new CountingIterator(1), 0.9999);    assertTrue(t.hasNext());    assertEquals(0, t.next().intValue());    assertFalse(t.hasNext());}
fb9867dc3ff068e3fc1d871414a02ac17fd3ed1a13db896e3c8db8646134d226
testBadRate1
public void testBadRate1()
{    new SamplingIterator<>(new CountingIterator(1), 0.0);}
c0c06e4608bce4e03f97e675f1528969ca15136f054446f13380e47d4d10e923
testBadRate2
public void testBadRate2()
{    new SamplingIterator<>(new CountingIterator(1), 1.1);}
cd38b10dfcef3a82d3c9e000dc62328c1944be29dc654165fe58b8a58a5b92e3
testExactSizeMatch
public void testExactSizeMatch()
{    Iterator<Integer> t = new SamplingIterator<>(new CountingIterator(10), 1);    for (int i = 0; i < 10; i++) {        assertTrue(t.hasNext());        assertEquals(i, t.next().intValue());    }    assertFalse(t.hasNext());}
fdf58bcb2471bab34b46d9867640f189488b11b6566a33e9095726462280d64e
testSample
public void testSample()
{    for (int i = 0; i < 1000; i++) {        Iterator<Integer> t = new SamplingIterator<>(new CountingIterator(1000), 0.1);        int k = 0;        while (t.hasNext()) {            int v = t.next();            k++;            assertTrue(v >= 0);            assertTrue(v < 1000);        }        double sd = Math.sqrt(0.9 * 0.1 * 1000);        assertTrue(k >= 100 - 4 * sd);        assertTrue(k <= 100 + 4 * sd);    }}
a715ad474b67d8a0309fab165b3e776c49ceff71337a206fc237ac008b9c3c8e
createSampler
protected Iterator<Integer> createSampler(int n, Iterator<Integer> source)
{    return new StableFixedSizeSamplingIterator<>(n, source);}
66db96b6f20e68217992633d873beb35fc55c689024a68344291da44a7301c87
isSorted
protected boolean isSorted()
{    return true;}
0fe10a39c61ef89b5a50d62847d328732ad784a38a28fad3a9e2230d1d15621a
createStandardAnalyzer
public void createStandardAnalyzer() throws Exception
{    assertNotNull(AnalyzerUtils.createAnalyzer(StandardAnalyzer.class.getName()));}
9986f82f30f788b8f701c9b249c5abacb56d10402419299a4944f7d30c648da0
createCJKAnalyzer
public void createCJKAnalyzer() throws Exception
{    assertNotNull(AnalyzerUtils.createAnalyzer(CJKAnalyzer.class.getName()));}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    super.setUp();    RandomUtils.useTestSeed();    testTempDirPath = null;    fs = null;}
c6aaebb5a52567751db8dc8e1cb9dd4a4e582ef964a374b376c6a04f741802dc
tearDown
public void tearDown() throws Exception
{    if (testTempDirPath != null) {        try {            fs.delete(testTempDirPath, true);        } catch (IOException e) {            throw new IllegalStateException("Test file not found");        }        testTempDirPath = null;        fs = null;    }    super.tearDown();}
da7f671aa8c2b01d1049c3bcb7ac5c57b4ebdb956347c6fd68cc14a7adf0a9a8
getConfiguration
public final Configuration getConfiguration() throws IOException
{    Configuration conf = new Configuration();    conf.set("hadoop.tmp.dir", getTestTempDir("hadoop" + Math.random()).getAbsolutePath());    return conf;}
0a9fc465441d722160d62cee73f3cff82a87343b20c523384b856eca2faf2c3b
getTestTempDirPath
protected final Path getTestTempDirPath() throws IOException
{    if (testTempDirPath == null) {        fs = FileSystem.get(getConfiguration());        long simpleRandomLong = (long) (Long.MAX_VALUE * Math.random());        testTempDirPath = fs.makeQualified(new Path("/tmp/mahout-" + getClass().getSimpleName() + '-' + simpleRandomLong));        if (!fs.mkdirs(testTempDirPath)) {            throw new IOException("Could not create " + testTempDirPath);        }        fs.deleteOnExit(testTempDirPath);    }    return testTempDirPath;}
1c4fa2f7b33be6e373a0706a06e5dc75d079aee325b466a18f184af5be79d239
getTestTempFilePath
protected final Path getTestTempFilePath(String name) throws IOException
{    return getTestTempFileOrDirPath(name, false);}
ba6e1f4d5b2562a6e3bc06ef5c40b6a4120e01e43bba5ee6fc0a5d8971071a1d
getTestTempDirPath
protected final Path getTestTempDirPath(String name) throws IOException
{    return getTestTempFileOrDirPath(name, true);}
a732b452b1c97dc48255ded298f4d9399ddc4627cbbda01513e252697c74f0a9
getTestTempFileOrDirPath
private Path getTestTempFileOrDirPath(String name, boolean dir) throws IOException
{    Path testTempDirPath = getTestTempDirPath();    Path tempFileOrDir = fs.makeQualified(new Path(testTempDirPath, name));    fs.deleteOnExit(tempFileOrDir);    if (dir && !fs.mkdirs(tempFileOrDir)) {        throw new IOException("Could not create " + tempFileOrDir);    }    return tempFileOrDir;}
416ae55fea8bba8e64a10adad0b651ae94e45443bb53741ce9eb96ab54b93d64
setField
protected static void setField(Object target, String fieldname, Object value) throws NoSuchFieldException, IllegalAccessException
{    Field field = findDeclaredField(target.getClass(), fieldname);    field.setAccessible(true);    field.set(target, value);}
2375ddd1c72731ee852e8739ba8ddcd0ed18c87442b48063c12f7bd6d4333f5a
findDeclaredField
private static Field findDeclaredField(Class<?> inClass, String fieldname) throws NoSuchFieldException
{    while (!Object.class.equals(inClass)) {        for (Field field : inClass.getDeclaredFields()) {            if (field.getName().equalsIgnoreCase(fieldname)) {                return field;            }        }        inClass = inClass.getSuperclass();    }    throw new NoSuchFieldException();}
efc7fab67b228a23d6f2946e0f788e90abb242422c86ab1026cf4b904c03cb43
optKey
protected static String optKey(String optionName)
{    return AbstractJob.keyFor(optionName);}
9e5952f9d70a54dbeae81be772fc264a3403a717f7cfe72ef0bf7dca30740ab9
writeLines
protected static void writeLines(File file, String... lines) throws IOException
{    Writer writer = new OutputStreamWriter(new FileOutputStream(file), Charsets.UTF_8);    try {        for (String line : lines) {            writer.write(line);            writer.write('\n');        }    } finally {        Closeables.close(writer, false);    }}
5df6118bc0e745d8b18e0a6a99b2e3f2ddba8140cbeb1423ce2df50a9f140574
close
public void close()
{}
77340e53a080a25c6846053a396fe9464904e74dadcbcd85192ae26fda8f659e
getKey
public DataInputBuffer getKey()
{    return null;}
2e53f73a47fdde6eb69cd57d19775b0102939437200847bc5cc8aa8a6c84463d
getProgress
public Progress getProgress()
{    return null;}
663299de12c4540c2ac819e3164b5abae3507459eeb956db97a75b6985e14fd3
getValue
public DataInputBuffer getValue()
{    return null;}
1e2b5704e7cfa0e720b3cbb80b8f6a1ef5a745120c4f0dd11e8fc4b87d3d2283
next
public boolean next()
{    return true;}
4afeb0868b55bdd8e18a00a3cb43d83e0714378d1c4bb36f0936daefc060e2e8
equals
public boolean equals(Object obj)
{    if (this == obj) {        return true;    }    if (!(obj instanceof DummyTest)) {        return false;    }    DummyTest dt = (DummyTest) obj;    return field == dt.field;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return field;}
55e936a379c14759ead581ae711e8f1d8b61400c68d7626449cb40aa542aa781
getField
public int getField()
{    return field;}
dbc997d69ff260951885bcbf23ab5cd768a367870bde9dbf94a687bd8afeb3f1
testStringConversion
public void testStringConversion() throws Exception
{    List<String> expected = Lists.newArrayList("A", "B", "C");    assertEquals(expected, StringUtils.fromString(StringUtils.toString(expected)));        DummyTest test = new DummyTest();    assertEquals(test, StringUtils.fromString(StringUtils.toString(test)));}
e7c2c9fd259bc4dded96939aadc0012d24aa6853fc6c9ad4495fcc5e09ab167f
testEscape
public void testEscape() throws Exception
{    String res = StringUtils.escapeXML("\",\',&,>,<");    assertEquals("_,_,_,_,_", res);}
159958f92cb16be60a82774162030b0a04130a05c4c8f1a39fa68b99ce4c25c2
testMain
public void testMain() throws Throwable
{    MahoutDriver.main(new String[] { "canopy", "help" });}
ebda6b27a2ee8e9cc14cc96fb4e9216f640922ecb5528b6c524a89a2f644d719
testConverges
public void testConverges() throws Exception
{    State<Foo, Double> s0 = new State<>(new double[5], 1);    s0.setPayload(new Foo());    EvolutionaryProcess<Foo, Double> ep = new EvolutionaryProcess<>(10, 100, s0);    State<Foo, Double> best = null;    for (int i = 0; i < 20; i++) {        best = ep.parallelDo(new EvolutionaryProcess.Function<Payload<Double>>() {            @Override            public double apply(Payload<Double> payload, double[] params) {                int i = 1;                double sum = 0;                for (double x : params) {                    sum += i * (x - i) * (x - i);                    i++;                }                return -sum;            }        });        ep.mutatePopulation(3);        System.out.printf("%10.3f %.3f\n", best.getValue(), best.getOmni());    }    ep.close();    assertNotNull(best);    assertEquals(0.0, best.getValue(), 0.02);}
001ee261cf093010e15a6d9835f96d6b8fb635dae094d1b43f5ab5dfb7c1550c
apply
public double apply(Payload<Double> payload, double[] params)
{    int i = 1;    double sum = 0;    for (double x : params) {        sum += i * (x - i) * (x - i);        i++;    }    return -sum;}
fe2e7d95b6d0ac5b474f98ac48979d3e55a084c2d8272d0e8d443a0dfb9710a6
copy
public Foo copy()
{    return this;}
1ed1a8f5f6c2d9d765096fc3a9c1471dbecef8f9daa3fb1fe074481a6c9992b4
update
public void update(double[] params)
{}
5493eeee7f85bd6fb70c717b366e2363863946d32d71ebd52274dfb03a86cae5
write
public void write(DataOutput dataOutput) throws IOException
{}
c5821d086e99763a45e1e272070fb489eff057889b3aac47dfd41f118d6aecf6
readFields
public void readFields(DataInput dataInput) throws IOException
{}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    super.setUp();    File symTestData = getTestTempDir("symTestData");    File asymTestData = getTestTempDir("asymTestData");    symCorpus = new TestDistributedRowMatrix().randomDistributedMatrix(100, 90, 80, 2, 10.0, true, symTestData.getAbsolutePath());    asymCorpus = new TestDistributedRowMatrix().randomDistributedMatrix(100, 90, 80, 2, 10.0, false, asymTestData.getAbsolutePath());}
579ddefaf6039bda36ebfbc35c3274f2e4c415092bf983a13e881f01b7e91b4c
suf
private static String suf(boolean symmetric)
{    return symmetric ? "_sym" : "_asym";}
6d7753f18593eb5a8464479ad3b0941691f810721a679d5e44510f1b99f11e30
getCorpus
private DistributedRowMatrix getCorpus(boolean symmetric)
{    return symmetric ? symCorpus : asymCorpus;}
70c48911ccd59dca8e3c28d7332911f66f9f9d29ec3546f1a398e4ea1b63ee60
doTestDistributedLanczosSolver
private LanczosState doTestDistributedLanczosSolver(boolean symmetric, int desiredRank, boolean hdfsBackedState) throws IOException
{    DistributedRowMatrix corpus = getCorpus(symmetric);    Configuration conf = getConfiguration();    corpus.setConf(conf);    DistributedLanczosSolver solver = new DistributedLanczosSolver();    Vector intitialVector = DistributedLanczosSolver.getInitialVector(corpus);    LanczosState state;    if (hdfsBackedState) {        HdfsBackedLanczosState hState = new HdfsBackedLanczosState(corpus, desiredRank, intitialVector, new Path(getTestTempDirPath(), "lanczosStateDir" + suf(symmetric) + counter));        hState.setConf(conf);        state = hState;    } else {        state = new LanczosState(corpus, desiredRank, intitialVector);    }    solver.solve(state, desiredRank, symmetric);    SolverTest.assertOrthonormal(state);    for (int i = 0; i < desiredRank / 2; i++) {        SolverTest.assertEigen(i, state.getRightSingularVector(i), corpus, 0.1, symmetric);    }    counter++;    return state;}
7ee86a9d28f19c1164d861406dacbce72e03649fd5081329e5b7ffb87c97d414
doTestResumeIteration
public void doTestResumeIteration(boolean symmetric) throws IOException
{    DistributedRowMatrix corpus = getCorpus(symmetric);    Configuration conf = getConfiguration();    corpus.setConf(conf);    DistributedLanczosSolver solver = new DistributedLanczosSolver();    int rank = 10;    Vector intitialVector = DistributedLanczosSolver.getInitialVector(corpus);    HdfsBackedLanczosState state = new HdfsBackedLanczosState(corpus, rank, intitialVector, new Path(getTestTempDirPath(), "lanczosStateDir" + suf(symmetric) + counter));    solver.solve(state, rank, symmetric);    rank *= 2;    state = new HdfsBackedLanczosState(corpus, rank, intitialVector, new Path(getTestTempDirPath(), "lanczosStateDir" + suf(symmetric) + counter));    solver = new DistributedLanczosSolver();    solver.solve(state, rank, symmetric);    LanczosState allAtOnceState = doTestDistributedLanczosSolver(symmetric, rank, false);    for (int i = 0; i < state.getIterationNumber(); i++) {        Vector v = state.getBasisVector(i).normalize();        Vector w = allAtOnceState.getBasisVector(i).normalize();        double diff = v.minus(w).norm(2);        assertTrue("basis " + i + " is too long: " + diff, diff < 0.1);    }    counter++;}
6c8dc00ffb7b4be794b72c77895c31064cc7f3a393c3a81c9a1bda5dced30938
testDistributedLanczosSolverCLI
public void testDistributedLanczosSolverCLI() throws Exception
{    Path testData = getTestTempDirPath("testdata");    DistributedRowMatrix corpus = new TestDistributedRowMatrix().randomDenseHierarchicalDistributedMatrix(10, 9, false, testData.toString());    corpus.setConf(getConfiguration());    Path output = getTestTempDirPath("output");    Path tmp = getTestTempDirPath("tmp");    Path workingDir = getTestTempDirPath("working");    String[] args = { "-i", new Path(testData, "distMatrix").toString(), "-o", output.toString(), "--tempDir", tmp.toString(), "--numRows", "10", "--numCols", "9", "--rank", "6", "--symmetric", "false", "--workingDir", workingDir.toString() };    ToolRunner.run(getConfiguration(), new DistributedLanczosSolver().new DistributedLanczosSolverJob(), args);    output = getTestTempDirPath("output2");    tmp = getTestTempDirPath("tmp2");    args = new String[] { "-i", new Path(testData, "distMatrix").toString(), "-o", output.toString(), "--tempDir", tmp.toString(), "--numRows", "10", "--numCols", "9", "--rank", "7", "--symmetric", "false", "--workingDir", workingDir.toString() };    ToolRunner.run(getConfiguration(), new DistributedLanczosSolver().new DistributedLanczosSolverJob(), args);    Path rawEigenvectors = new Path(output, DistributedLanczosSolver.RAW_EIGENVECTORS);    Matrix eigenVectors = new DenseMatrix(7, corpus.numCols());    Configuration conf = getConfiguration();    int i = 0;    for (VectorWritable value : new SequenceFileValueIterable<VectorWritable>(rawEigenvectors, conf)) {        Vector v = value.get();        eigenVectors.assignRow(i, v);        i++;    }    assertEquals("number of eigenvectors", 7, i);}
b608af250b4f3553f8a674f27186555fc665e4da12798aa6c60cc8a36add3b60
testDistributedLanczosSolverEVJCLI
public void testDistributedLanczosSolverEVJCLI() throws Exception
{    Path testData = getTestTempDirPath("testdata");    DistributedRowMatrix corpus = new TestDistributedRowMatrix().randomDenseHierarchicalDistributedMatrix(10, 9, false, testData.toString());    corpus.setConf(getConfiguration());    Path output = getTestTempDirPath("output");    Path tmp = getTestTempDirPath("tmp");    String[] args = { "-i", new Path(testData, "distMatrix").toString(), "-o", output.toString(), "--tempDir", tmp.toString(), "--numRows", "10", "--numCols", "9", "--rank", "6", "--symmetric", "false", "--cleansvd", "true" };    ToolRunner.run(getConfiguration(), new DistributedLanczosSolver().new DistributedLanczosSolverJob(), args);    Path cleanEigenvectors = new Path(output, EigenVerificationJob.CLEAN_EIGENVECTORS);    Matrix eigenVectors = new DenseMatrix(6, corpus.numCols());    Collection<Double> eigenvalues = Lists.newArrayList();    output = getTestTempDirPath("output2");    tmp = getTestTempDirPath("tmp2");    args = new String[] { "-i", new Path(testData, "distMatrix").toString(), "-o", output.toString(), "--tempDir", tmp.toString(), "--numRows", "10", "--numCols", "9", "--rank", "7", "--symmetric", "false", "--cleansvd", "true" };    ToolRunner.run(getConfiguration(), new DistributedLanczosSolver().new DistributedLanczosSolverJob(), args);    Path cleanEigenvectors2 = new Path(output, EigenVerificationJob.CLEAN_EIGENVECTORS);    Matrix eigenVectors2 = new DenseMatrix(7, corpus.numCols());    Configuration conf = getConfiguration();    Collection<Double> newEigenValues = Lists.newArrayList();    int i = 0;    for (VectorWritable value : new SequenceFileValueIterable<VectorWritable>(cleanEigenvectors, conf)) {        NamedVector v = (NamedVector) value.get();        eigenVectors.assignRow(i, v);        log.info(v.getName());        if (EigenVector.getCosAngleError(v.getName()) < 1.0e-3) {            eigenvalues.add(EigenVector.getEigenValue(v.getName()));        }        i++;    }    assertEquals("number of clean eigenvectors", 3, i);    i = 0;    for (VectorWritable value : new SequenceFileValueIterable<VectorWritable>(cleanEigenvectors2, conf)) {        NamedVector v = (NamedVector) value.get();        log.info(v.getName());        eigenVectors2.assignRow(i, v);        newEigenValues.add(EigenVector.getEigenValue(v.getName()));        i++;    }    Collection<Integer> oldEigensFound = Lists.newArrayList();    for (int row = 0; row < eigenVectors.numRows(); row++) {        Vector oldEigen = eigenVectors.viewRow(row);        if (oldEigen == null) {            break;        }        for (int newRow = 0; newRow < eigenVectors2.numRows(); newRow++) {            Vector newEigen = eigenVectors2.viewRow(newRow);            if (newEigen != null && oldEigen.dot(newEigen) > 0.9) {                oldEigensFound.add(row);                break;            }        }    }    assertEquals("the number of new eigenvectors", 5, i);    Collection<Double> oldEigenValuesNotFound = Lists.newArrayList();    for (double d : eigenvalues) {        boolean found = false;        for (double newD : newEigenValues) {            if (Math.abs((d - newD) / d) < 0.1) {                found = true;            }        }        if (!found) {            oldEigenValuesNotFound.add(d);        }    }    assertEquals("number of old eigenvalues not found: " + Arrays.toString(oldEigenValuesNotFound.toArray(new Double[oldEigenValuesNotFound.size()])), 0, oldEigenValuesNotFound.size());    assertEquals("did not find enough old eigenvectors", 3, oldEigensFound.size());}
cac5d3c06c9a14617be7a4f0dc521b77a48db677073b9d96e7f98bd954a986f8
elem
public static Vector.Element elem(int index, double value)
{    return new ElementToCheck(index, value);}
6f9021560b40d5f0ea4687dcfc9163f88e04e559e2fc0af5f9a1fed73b4e4c24
get
public double get()
{    return value;}
5dd366da2313537c415c3c2ab9ed1909d1250d894a032bd02373d113516571d0
index
public int index()
{    return index;}
0ca3b3a320922927ea9a06f3def94b995d23a5eb7b95de57c7935a827c79759c
set
public void set(double value)
{    this.value = value;}
664c7b9f63081ae3c3e947a5a1c2f10c52f2da8cd458b05969019d00d7c907a6
vectorMatches
public static VectorWritable vectorMatches(final Vector.Element... elements)
{    EasyMock.reportMatcher(new IArgumentMatcher() {        @Override        public boolean matches(Object argument) {            if (argument instanceof VectorWritable) {                Vector v = ((VectorWritable) argument).get();                return consistsOf(v, elements);            }            return false;        }        @Override        public void appendTo(StringBuffer buffer) {        }    });    return null;}
eafe89971eb7ac8d02727bc7a7f2e145a8ad354e94e997283d3ac3af52c92355
matches
public boolean matches(Object argument)
{    if (argument instanceof VectorWritable) {        Vector v = ((VectorWritable) argument).get();        return consistsOf(v, elements);    }    return false;}
a9d4d655b19b70cdbe9824cc420ee83364e526a200478fba70afd680009cc19e
appendTo
public void appendTo(StringBuffer buffer)
{}
f825809176390bd98eb6930109bc405688012801fdd267472ee492e29c3580e8
consistsOf
public static boolean consistsOf(Vector vector, Vector.Element... elements)
{    if (elements.length != numberOfNoNZeroNonNaNElements(vector)) {        return false;    }    for (Vector.Element element : elements) {        if (Math.abs(element.get() - vector.get(element.index())) > MahoutTestCase.EPSILON) {            return false;        }    }    return true;}
f2c49ebd854571daf32e23170f866f929b9830a639cbba252539521c6281fd6f
numberOfNoNZeroNonNaNElements
public static int numberOfNoNZeroNonNaNElements(Vector vector)
{    int elementsInVector = 0;    for (Element currentElement : vector.nonZeroes()) {        if (!Double.isNaN(currentElement.get())) {            elementsInVector++;        }    }    return elementsInVector;}
c7e6a8e19f2df12d64bb804ff1a639aad8856531776baaf5a94cc68545f8a12d
readMatrix
public static Matrix readMatrix(Configuration conf, Path path, int rows, int columns)
{    boolean readOneRow = false;    Matrix matrix = new DenseMatrix(rows, columns);    for (Pair<IntWritable, VectorWritable> record : new SequenceFileIterable<IntWritable, VectorWritable>(path, true, conf)) {        IntWritable key = record.getFirst();        VectorWritable value = record.getSecond();        readOneRow = true;        int row = key.get();        for (Element element : value.get().nonZeroes()) {            matrix.set(row, element.index(), element.get());        }    }    if (!readOneRow) {        throw new IllegalStateException("Not a single row read!");    }    return matrix;}
ccf881255464694fc7d3cc4727590bd56d46f53dca47c44cb8b706c1aca3279c
readMatrixRows
public static OpenIntObjectHashMap<Vector> readMatrixRows(Configuration conf, Path path)
{    boolean readOneRow = false;    OpenIntObjectHashMap<Vector> rows = new OpenIntObjectHashMap<>();    for (Pair<IntWritable, VectorWritable> record : new SequenceFileIterable<IntWritable, VectorWritable>(path, true, conf)) {        IntWritable key = record.getFirst();        readOneRow = true;        rows.put(key.get(), record.getSecond().get());    }    if (!readOneRow) {        throw new IllegalStateException("Not a single row read!");    }    return rows;}
698f0cf670fb8afd5c7424efcc3aaee0858d0267c1ceb21278bd01fd2537ef39
writeDistributedRowMatrix
public static void writeDistributedRowMatrix(double[][] entries, FileSystem fs, Configuration conf, Path path) throws IOException
{    SequenceFile.Writer writer = null;    try {        writer = new SequenceFile.Writer(fs, conf, path, IntWritable.class, VectorWritable.class);        for (int n = 0; n < entries.length; n++) {            Vector v = new RandomAccessSparseVector(entries[n].length);            for (int m = 0; m < entries[n].length; m++) {                v.setQuick(m, entries[n][m]);            }            writer.append(new IntWritable(n), new VectorWritable(v));        }    } finally {        Closeables.close(writer, false);    }}
439e486b397ff203f6cf66b3f7fd6f1dc63237563fa2c3719da0c547561a29b2
assertMatrixEquals
public static void assertMatrixEquals(Matrix expected, Matrix actual)
{    Assert.assertEquals(expected.numRows(), actual.numRows());    Assert.assertEquals(actual.numCols(), actual.numCols());    for (int row = 0; row < expected.numRows(); row++) {        for (int col = 0; col < expected.numCols(); col++) {            Assert.assertEquals("Non-matching values in [" + row + ',' + col + ']', expected.get(row, col), actual.get(row, col), MahoutTestCase.EPSILON);        }    }}
b11ef095fb5108ce39f486e62c6ec743260edf7da06fa4d25ba991cde9556980
nice
public static String nice(Vector v)
{    if (!v.isSequentialAccess()) {        v = new DenseVector(v);    }    DecimalFormat df = new DecimalFormat("0.00", DecimalFormatSymbols.getInstance(Locale.ENGLISH));    StringBuilder buffer = new StringBuilder("[");    String separator = "";    for (Vector.Element e : v.all()) {        buffer.append(separator);        if (Double.isNaN(e.get())) {            buffer.append("  -  ");        } else {            if (e.get() >= 0) {                buffer.append(' ');            }            buffer.append(df.format(e.get()));        }        separator = "\t";    }    buffer.append(" ]");    return buffer.toString();}
d3aadf6112c2c76604857d2741a327c21c3bcf70d6b120e1c7edd29be5521896
nice
public static String nice(Matrix matrix)
{    StringBuilder info = new StringBuilder();    for (int n = 0; n < matrix.numRows(); n++) {        info.append(nice(matrix.viewRow(n))).append('\n');    }    return info.toString();}
ab5d44de88c22801f972b8548e5be4589ef672f09b0354ed31b633e14e1f1a79
distributedSimilarity
 static double distributedSimilarity(double[] one, double[] two, Class<? extends VectorSimilarityMeasure> similarityMeasureClass)
{    double rand = computeSimilarity(one, two, similarityMeasureClass, new RandomAccessSparseVector(one.length));    double seq = computeSimilarity(one, two, similarityMeasureClass, new SequentialAccessSparseVector(one.length));    double dense = computeSimilarity(one, two, similarityMeasureClass, new DenseVector(one.length));    assertEquals(seq, rand, 1.0e-10);    assertEquals(seq, dense, 1.0e-10);    assertEquals(dense, rand, 1.0e-10);    return seq;}
6e6486a19f8358618dbdeab1b8c0585a39fdc7fcbad6829bf06f6ee0865512e8
computeSimilarity
private static double computeSimilarity(double[] one, double[] two, Class<? extends VectorSimilarityMeasure> similarityMeasureClass, Vector like)
{    VectorSimilarityMeasure similarityMeasure = ClassUtils.instantiateAs(similarityMeasureClass, VectorSimilarityMeasure.class);    Vector oneNormalized = similarityMeasure.normalize(asVector(one, like));    Vector twoNormalized = similarityMeasure.normalize(asVector(two, like));    double normOne = similarityMeasure.norm(oneNormalized);    double normTwo = similarityMeasure.norm(twoNormalized);    double dot = 0;    for (int n = 0; n < one.length; n++) {        if (oneNormalized.get(n) != 0 && twoNormalized.get(n) != 0) {            dot += similarityMeasure.aggregate(oneNormalized.get(n), twoNormalized.get(n));        }    }    return similarityMeasure.similarity(dot, normOne, normTwo, one.length);}
fa3e192a618f411f86202b1998bbbcbcc86d7801b0fe1fddbcb6cec91f65662b
asVector
 static Vector asVector(double[] values, Vector like)
{    Vector vector = like.like();    for (int dim = 0; dim < values.length; dim++) {        vector.set(dim, values[dim]);    }    return vector;}
ebee74ab1c7a1b3fd5b8dc8cd136dda5be2698fc0c4ffb6784fecaa69d8058d8
testCooccurrenceCountSimilarity
public void testCooccurrenceCountSimilarity()
{    double similarity = distributedSimilarity(new double[] { 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0 }, new double[] { 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1 }, CooccurrenceCountSimilarity.class);    assertEquals(5.0, similarity, 0);}
d27d6e4a632bbdc145d7a7551fbb74ac811f3080301d4e4994f4c4e842b6214f
testTanimotoCoefficientSimilarity
public void testTanimotoCoefficientSimilarity()
{    double similarity = distributedSimilarity(new double[] { 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0 }, new double[] { 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1 }, TanimotoCoefficientSimilarity.class);    assertEquals(0.454545455, similarity, EPSILON);}
bfa941187f55f0fc07896a0e302ae4c0c5c087344b79e4a29bd6b143df42ca9b
testCityblockSimilarity
public void testCityblockSimilarity()
{    double similarity = distributedSimilarity(new double[] { 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0 }, new double[] { 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1 }, CityBlockSimilarity.class);    assertEquals(0.142857143, similarity, EPSILON);}
0d84fe2d29249b19f4256cb76c8c5e4b330cb81330d8a0bbfe49f6baabbf895e
testLoglikelihoodSimilarity
public void testLoglikelihoodSimilarity()
{    double similarity = distributedSimilarity(new double[] { 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0 }, new double[] { 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1 }, LoglikelihoodSimilarity.class);    assertEquals(0.03320155369284261, similarity, EPSILON);}
86f20e426e6f417b8011d9cc66d9f74ac2ebb7fb0b66e53d8c0c824039a31783
testCosineSimilarity
public void testCosineSimilarity()
{    double similarity = distributedSimilarity(new double[] { 0, 2, 0, 0, 8, 3, 0, 6, 0, 1, 2, 2, 0 }, new double[] { 3, 0, 0, 0, 7, 0, 2, 2, 1, 3, 2, 1, 1 }, CosineSimilarity.class);    assertEquals(0.769846046, similarity, EPSILON);}
325283418ec55eb389b09533167c187957a772f5c97ed7dfd5df3f92f01b0a71
testPearsonCorrelationSimilarity
public void testPearsonCorrelationSimilarity()
{    double similarity = distributedSimilarity(new double[] { 0, 2, 0, 0, 8, 3, 0, 6, 0, 1, 1, 2, 1 }, new double[] { 3, 0, 0, 0, 7, 0, 2, 2, 1, 3, 2, 4, 3 }, PearsonCorrelationSimilarity.class);    assertEquals(0.5303300858899108, similarity, EPSILON);}
24060754d627148d505bbe993fc8c8337431f8119f4da40b9cec09ad179541e6
testEuclideanDistanceSimilarity
public void testEuclideanDistanceSimilarity()
{    double similarity = distributedSimilarity(new double[] { 0, 2, 0, 0, 8, 3, 0, 6, 0, 1, 1, 2, 1 }, new double[] { 3, 0, 0, 0, 7, 0, 2, 2, 1, 3, 2, 4, 4 }, EuclideanDistanceSimilarity.class);    assertEquals(0.11268865367232477, similarity, EPSILON);}
6de8b9dbfd45008b7d6de2b5a294c92f4749ba9a009c2d8ea10154538246eea5
toyIntegration
public void toyIntegration() throws Exception
{    File inputFile = getTestTempFile("rows");    File outputDir = getTestTempDir("output");    outputDir.delete();    File tmpDir = getTestTempDir("tmp");    Configuration conf = getConfiguration();    Path inputPath = new Path(inputFile.getAbsolutePath());    FileSystem fs = FileSystem.get(inputPath.toUri(), conf);    MathHelper.writeDistributedRowMatrix(new double[][] { new double[] { 1, 0, 1, 1, 0 }, new double[] { 0, 0, 1, 1, 0 }, new double[] { 0, 0, 0, 0, 1 } }, fs, conf, inputPath);    RowSimilarityJob rowSimilarityJob = new RowSimilarityJob();    rowSimilarityJob.setConf(conf);    rowSimilarityJob.run(new String[] { "--input", inputFile.getAbsolutePath(), "--output", outputDir.getAbsolutePath(), "--numberOfColumns", String.valueOf(5), "--similarityClassname", TanimotoCoefficientSimilarity.class.getName(), "--tempDir", tmpDir.getAbsolutePath() });    OpenIntIntHashMap observationsPerColumn = Vectors.readAsIntMap(new Path(tmpDir.getAbsolutePath(), "observationsPerColumn.bin"), conf);    assertEquals(4, observationsPerColumn.size());    assertEquals(1, observationsPerColumn.get(0));    assertEquals(2, observationsPerColumn.get(2));    assertEquals(2, observationsPerColumn.get(3));    assertEquals(1, observationsPerColumn.get(4));    Matrix similarityMatrix = MathHelper.readMatrix(conf, new Path(outputDir.getAbsolutePath(), "part-r-00000"), 3, 3);    assertNotNull(similarityMatrix);    assertEquals(3, similarityMatrix.numCols());    assertEquals(3, similarityMatrix.numRows());    assertEquals(1.0, similarityMatrix.get(0, 0), EPSILON);    assertEquals(1.0, similarityMatrix.get(1, 1), EPSILON);    assertEquals(1.0, similarityMatrix.get(2, 2), EPSILON);    assertEquals(0.0, similarityMatrix.get(2, 0), EPSILON);    assertEquals(0.0, similarityMatrix.get(2, 1), EPSILON);    assertEquals(0.0, similarityMatrix.get(0, 2), EPSILON);    assertEquals(0.0, similarityMatrix.get(1, 2), EPSILON);    assertEquals(0.666666, similarityMatrix.get(0, 1), EPSILON);    assertEquals(0.666666, similarityMatrix.get(1, 0), EPSILON);}
9b5984e70bdb3982e7141afb5cc328ea06bff1d27c5fb87d0acac2dcd4abe0fe
toyIntegrationMaxSimilaritiesPerRow
public void toyIntegrationMaxSimilaritiesPerRow() throws Exception
{    File inputFile = getTestTempFile("rows");    File outputDir = getTestTempDir("output");    outputDir.delete();    File tmpDir = getTestTempDir("tmp");    Configuration conf = getConfiguration();    Path inputPath = new Path(inputFile.getAbsolutePath());    FileSystem fs = FileSystem.get(inputPath.toUri(), conf);    MathHelper.writeDistributedRowMatrix(new double[][] { new double[] { 1, 0, 1, 1, 0, 1 }, new double[] { 0, 1, 1, 1, 1, 1 }, new double[] { 1, 1, 0, 1, 0, 0 } }, fs, conf, inputPath);    RowSimilarityJob rowSimilarityJob = new RowSimilarityJob();    rowSimilarityJob.setConf(conf);    rowSimilarityJob.run(new String[] { "--input", inputFile.getAbsolutePath(), "--output", outputDir.getAbsolutePath(), "--numberOfColumns", String.valueOf(6), "--similarityClassname", TanimotoCoefficientSimilarity.class.getName(), "--maxSimilaritiesPerRow", String.valueOf(1), "--excludeSelfSimilarity", String.valueOf(true), "--tempDir", tmpDir.getAbsolutePath() });    Matrix similarityMatrix = MathHelper.readMatrix(conf, new Path(outputDir.getAbsolutePath(), "part-r-00000"), 3, 3);    assertNotNull(similarityMatrix);    assertEquals(3, similarityMatrix.numCols());    assertEquals(3, similarityMatrix.numRows());    assertEquals(0.0, similarityMatrix.get(0, 0), EPSILON);    assertEquals(0.5, similarityMatrix.get(0, 1), EPSILON);    assertEquals(0.0, similarityMatrix.get(0, 2), EPSILON);    assertEquals(0.5, similarityMatrix.get(1, 0), EPSILON);    assertEquals(0.0, similarityMatrix.get(1, 1), EPSILON);    assertEquals(0.0, similarityMatrix.get(1, 2), EPSILON);    assertEquals(0.4, similarityMatrix.get(2, 0), EPSILON);    assertEquals(0.0, similarityMatrix.get(2, 1), EPSILON);    assertEquals(0.0, similarityMatrix.get(2, 2), EPSILON);}
50b063aca45c302bee35b898b3b1551f6ed2a225fd0738b22a0c5da71fe0d57e
toyIntegrationWithThreshold
public void toyIntegrationWithThreshold() throws Exception
{    File inputFile = getTestTempFile("rows");    File outputDir = getTestTempDir("output");    outputDir.delete();    File tmpDir = getTestTempDir("tmp");    Configuration conf = getConfiguration();    Path inputPath = new Path(inputFile.getAbsolutePath());    FileSystem fs = FileSystem.get(inputPath.toUri(), conf);    MathHelper.writeDistributedRowMatrix(new double[][] { new double[] { 1, 0, 1, 1, 0, 1 }, new double[] { 0, 1, 1, 1, 1, 1 }, new double[] { 1, 1, 0, 1, 0, 0 } }, fs, conf, inputPath);    RowSimilarityJob rowSimilarityJob = new RowSimilarityJob();    rowSimilarityJob.setConf(conf);    rowSimilarityJob.run(new String[] { "--input", inputFile.getAbsolutePath(), "--output", outputDir.getAbsolutePath(), "--numberOfColumns", String.valueOf(6), "--similarityClassname", TanimotoCoefficientSimilarity.class.getName(), "--excludeSelfSimilarity", String.valueOf(true), "--threshold", String.valueOf(0.5), "--tempDir", tmpDir.getAbsolutePath() });    Matrix similarityMatrix = MathHelper.readMatrix(conf, new Path(outputDir.getAbsolutePath(), "part-r-00000"), 3, 3);    assertNotNull(similarityMatrix);    assertEquals(3, similarityMatrix.numCols());    assertEquals(3, similarityMatrix.numRows());    assertEquals(0.0, similarityMatrix.get(0, 0), EPSILON);    assertEquals(0.5, similarityMatrix.get(0, 1), EPSILON);    assertEquals(0.0, similarityMatrix.get(0, 2), EPSILON);    assertEquals(0.5, similarityMatrix.get(1, 0), EPSILON);    assertEquals(0.0, similarityMatrix.get(1, 1), EPSILON);    assertEquals(0.0, similarityMatrix.get(1, 2), EPSILON);    assertEquals(0.0, similarityMatrix.get(2, 0), EPSILON);    assertEquals(0.0, similarityMatrix.get(2, 1), EPSILON);    assertEquals(0.0, similarityMatrix.get(2, 2), EPSILON);}
ee9e1295762cdeaca0be5824776367e6b894749633d0d3d2d57142f6ea84ed79
testVectorDimensions
public void testVectorDimensions() throws Exception
{    File inputFile = getTestTempFile("rows");    Configuration conf = getConfiguration();    Path inputPath = new Path(inputFile.getAbsolutePath());    FileSystem fs = FileSystem.get(inputPath.toUri(), conf);    MathHelper.writeDistributedRowMatrix(new double[][] { new double[] { 1, 0, 1, 1, 0, 1 }, new double[] { 0, 1, 1, 1, 1, 1 }, new double[] { 1, 1, 0, 1, 0, 0 } }, fs, conf, inputPath);    RowSimilarityJob rowSimilarityJob = new RowSimilarityJob();    rowSimilarityJob.setConf(conf);    int numberOfColumns = rowSimilarityJob.getDimensions(inputPath);    assertEquals(6, numberOfColumns);}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    super.setUp();    fs = FileSystem.get(getConfiguration());}
1c0e750b476ed26e95498b4cd3177ce61509f9b9258240038abf1526aca6ed2a
testVectorDistanceMapper
public void testVectorDistanceMapper() throws Exception
{    Mapper<WritableComparable<?>, VectorWritable, StringTuple, DoubleWritable>.Context context = EasyMock.createMock(Mapper.Context.class);    StringTuple tuple = new StringTuple();    tuple.add("foo");    tuple.add("123");    context.write(tuple, new DoubleWritable(Math.sqrt(2.0)));    tuple = new StringTuple();    tuple.add("foo2");    tuple.add("123");    context.write(tuple, new DoubleWritable(1));    EasyMock.replay(context);    Vector vector = new RandomAccessSparseVector(2);    vector.set(0, 2);    vector.set(1, 2);    VectorDistanceMapper mapper = new VectorDistanceMapper();    setField(mapper, "measure", new EuclideanDistanceMeasure());    Collection<NamedVector> seedVectors = Lists.newArrayList();    Vector seed1 = new RandomAccessSparseVector(2);    seed1.set(0, 1);    seed1.set(1, 1);    Vector seed2 = new RandomAccessSparseVector(2);    seed2.set(0, 2);    seed2.set(1, 1);    seedVectors.add(new NamedVector(seed1, "foo"));    seedVectors.add(new NamedVector(seed2, "foo2"));    setField(mapper, "seedVectors", seedVectors);    mapper.map(new IntWritable(123), new VectorWritable(vector), context);    EasyMock.verify(context);}
3366b3d7a3146adc0d84c4b0a4288c1ef5645fa56608017b59e587cca6c7fd18
testVectorDistanceInvertedMapper
public void testVectorDistanceInvertedMapper() throws Exception
{    Mapper<WritableComparable<?>, VectorWritable, Text, VectorWritable>.Context context = EasyMock.createMock(Mapper.Context.class);    Vector expectVec = new DenseVector(new double[] { Math.sqrt(2.0), 1.0 });    context.write(new Text("other"), new VectorWritable(expectVec));    EasyMock.replay(context);    Vector vector = new NamedVector(new RandomAccessSparseVector(2), "other");    vector.set(0, 2);    vector.set(1, 2);    VectorDistanceInvertedMapper mapper = new VectorDistanceInvertedMapper();    setField(mapper, "measure", new EuclideanDistanceMeasure());    Collection<NamedVector> seedVectors = Lists.newArrayList();    Vector seed1 = new RandomAccessSparseVector(2);    seed1.set(0, 1);    seed1.set(1, 1);    Vector seed2 = new RandomAccessSparseVector(2);    seed2.set(0, 2);    seed2.set(1, 1);    seedVectors.add(new NamedVector(seed1, "foo"));    seedVectors.add(new NamedVector(seed2, "foo2"));    setField(mapper, "seedVectors", seedVectors);    mapper.map(new IntWritable(123), new VectorWritable(vector), context);    EasyMock.verify(context);}
ae67a0d8c0d604d8bb308ed65bdc558b28037a3fac86878bd2b7f67210a99f60
testRun
public void testRun() throws Exception
{    Path input = getTestTempDirPath("input");    Path output = getTestTempDirPath("output");    Path seedsPath = getTestTempDirPath("seeds");    List<VectorWritable> points = getPointsWritable(REFERENCE);    List<VectorWritable> seeds = getPointsWritable(SEEDS);    Configuration conf = getConfiguration();    ClusteringTestUtils.writePointsToFile(points, true, new Path(input, "file1"), fs, conf);    ClusteringTestUtils.writePointsToFile(seeds, true, new Path(seedsPath, "part-seeds"), fs, conf);    String[] args = { optKey(DefaultOptionCreator.INPUT_OPTION), input.toString(), optKey(VectorDistanceSimilarityJob.SEEDS), seedsPath.toString(), optKey(DefaultOptionCreator.OUTPUT_OPTION), output.toString(), optKey(DefaultOptionCreator.DISTANCE_MEASURE_OPTION), EuclideanDistanceMeasure.class.getName() };    ToolRunner.run(getConfiguration(), new VectorDistanceSimilarityJob(), args);    int expectedOutputSize = SEEDS.length * REFERENCE.length;    int outputSize = Iterables.size(new SequenceFileIterable<StringTuple, DoubleWritable>(new Path(output, "part-m-00000"), conf));    assertEquals(expectedOutputSize, outputSize);}
66fe992b85c1b5b6a8a5771d4899c5825a7fd29dc41c9481dad31437276d8442
testMaxDistance
public void testMaxDistance() throws Exception
{    Path input = getTestTempDirPath("input");    Path output = getTestTempDirPath("output");    Path seedsPath = getTestTempDirPath("seeds");    List<VectorWritable> points = getPointsWritable(REFERENCE);    List<VectorWritable> seeds = getPointsWritable(SEEDS);    Configuration conf = getConfiguration();    ClusteringTestUtils.writePointsToFile(points, true, new Path(input, "file1"), fs, conf);    ClusteringTestUtils.writePointsToFile(seeds, true, new Path(seedsPath, "part-seeds"), fs, conf);    double maxDistance = 10;    String[] args = { optKey(DefaultOptionCreator.INPUT_OPTION), input.toString(), optKey(VectorDistanceSimilarityJob.SEEDS), seedsPath.toString(), optKey(DefaultOptionCreator.OUTPUT_OPTION), output.toString(), optKey(DefaultOptionCreator.DISTANCE_MEASURE_OPTION), EuclideanDistanceMeasure.class.getName(), optKey(VectorDistanceSimilarityJob.MAX_DISTANCE), String.valueOf(maxDistance) };    ToolRunner.run(getConfiguration(), new VectorDistanceSimilarityJob(), args);    int outputSize = 0;    for (Pair<StringTuple, DoubleWritable> record : new SequenceFileIterable<StringTuple, DoubleWritable>(new Path(output, "part-m-00000"), conf)) {        outputSize++;        assertTrue(record.getSecond().get() <= maxDistance);    }    assertEquals(14, outputSize);}
d458e478398ca75d8339aa15ad74bb34bac8efbacbced54f62b04c6ae9932cf1
testRunInverted
public void testRunInverted() throws Exception
{    Path input = getTestTempDirPath("input");    Path output = getTestTempDirPath("output");    Path seedsPath = getTestTempDirPath("seeds");    List<VectorWritable> points = getPointsWritable(REFERENCE);    List<VectorWritable> seeds = getPointsWritable(SEEDS);    Configuration conf = getConfiguration();    ClusteringTestUtils.writePointsToFile(points, true, new Path(input, "file1"), fs, conf);    ClusteringTestUtils.writePointsToFile(seeds, true, new Path(seedsPath, "part-seeds"), fs, conf);    String[] args = { optKey(DefaultOptionCreator.INPUT_OPTION), input.toString(), optKey(VectorDistanceSimilarityJob.SEEDS), seedsPath.toString(), optKey(DefaultOptionCreator.OUTPUT_OPTION), output.toString(), optKey(DefaultOptionCreator.DISTANCE_MEASURE_OPTION), EuclideanDistanceMeasure.class.getName(), optKey(VectorDistanceSimilarityJob.OUT_TYPE_KEY), "v" };    ToolRunner.run(getConfiguration(), new VectorDistanceSimilarityJob(), args);    DummyOutputCollector<Text, VectorWritable> collector = new DummyOutputCollector<>();    for (Pair<Text, VectorWritable> record : new SequenceFileIterable<Text, VectorWritable>(new Path(output, "part-m-00000"), conf)) {        collector.collect(record.getFirst(), record.getSecond());    }    assertEquals(REFERENCE.length, collector.getData().size());    for (Map.Entry<Text, List<VectorWritable>> entry : collector.getData().entrySet()) {        assertEquals(SEEDS.length, entry.getValue().iterator().next().get().size());    }}
e3562711d8a9018f0912abf9d48c718794d70ebffbfaec82bebd277132fbea95
getPointsWritable
private static List<VectorWritable> getPointsWritable(double[][] raw)
{    List<VectorWritable> points = Lists.newArrayList();    for (double[] fr : raw) {        Vector vec = new RandomAccessSparseVector(fr.length);        vec.assign(fr);        points.add(new VectorWritable(vec));    }    return points;}
247041e8b7ea6d9bc0ca6129c82c7717773aabb8e4b6997735494997b326dd49
randomVector
private static Vector randomVector(int size, double entryMean)
{    DenseVector v = new DenseVector(size);    Random r = RandomUtils.getRandom();    for (int i = 0; i < size; ++i) {        v.setQuick(i, r.nextGaussian() * entryMean);    }    return v;}
fa237eb181a858d1c64e5071d8930e27911634d52cee44670abdec8551721454
testSolver
public void testSolver() throws Exception
{    File testData = getTestTempDir("testdata");    DistributedRowMatrix matrix = new TestDistributedRowMatrix().randomDistributedMatrix(10, 10, 10, 10, 10.0, true, testData.getAbsolutePath());    matrix.setConf(getConfiguration());    Vector vector = randomVector(matrix.numCols(), 10.0);    DistributedConjugateGradientSolver solver = new DistributedConjugateGradientSolver();    Vector x = solver.solve(matrix, vector);    Vector solvedVector = matrix.times(x);    double distance = Math.sqrt(vector.getDistanceSquared(solvedVector));    assertEquals(0.0, distance, EPSILON);}
247041e8b7ea6d9bc0ca6129c82c7717773aabb8e4b6997735494997b326dd49
randomVector
private static Vector randomVector(int size, double entryMean)
{    Vector v = new DenseVector(size);    Random r = RandomUtils.getRandom();    for (int i = 0; i < size; ++i) {        v.setQuick(i, r.nextGaussian() * entryMean);    }    return v;}
ce2caabad432e8de5c7db550754c8e00e58578908b5ee4227b73154f03ffa256
saveVector
private static Path saveVector(Configuration conf, Path path, Vector v) throws IOException
{    FileSystem fs = path.getFileSystem(conf);    SequenceFile.Writer writer = new SequenceFile.Writer(fs, conf, path, IntWritable.class, VectorWritable.class);    try {        writer.append(new IntWritable(0), new VectorWritable(v));    } finally {        writer.close();    }    return path;}
7de8ed9e7424befa745f378316ba2480d17fda0499884752b9ec9eb8ec40281c
loadVector
private static Vector loadVector(Configuration conf, Path path) throws IOException
{    FileSystem fs = path.getFileSystem(conf);    SequenceFile.Reader reader = new SequenceFile.Reader(fs, path, conf);    Writable key = new IntWritable();    VectorWritable value = new VectorWritable();    try {        if (!reader.next(key, value)) {            throw new IOException("Input vector file is empty.");        }        return value.get();    } finally {        reader.close();    }}
fa237eb181a858d1c64e5071d8930e27911634d52cee44670abdec8551721454
testSolver
public void testSolver() throws Exception
{    Configuration conf = getConfiguration();    Path testData = getTestTempDirPath("testdata");    DistributedRowMatrix matrix = new TestDistributedRowMatrix().randomDistributedMatrix(10, 10, 10, 10, 10.0, true, testData.toString());    matrix.setConf(conf);    Path output = getTestTempFilePath("output");    Path vectorPath = getTestTempFilePath("vector");    Path tempPath = getTestTempDirPath("tmp");    Vector vector = randomVector(matrix.numCols(), 10.0);    saveVector(conf, vectorPath, vector);    String[] args = { "-i", matrix.getRowPath().toString(), "-o", output.toString(), "--tempDir", tempPath.toString(), "--vector", vectorPath.toString(), "--numRows", "10", "--numCols", "10", "--symmetric", "true" };    DistributedConjugateGradientSolver solver = new DistributedConjugateGradientSolver();    ToolRunner.run(getConfiguration(), solver.job(), args);    Vector x = loadVector(conf, output);    Vector solvedVector = matrix.times(x);    double distance = Math.sqrt(vector.getDistanceSquared(solvedVector));    assertEquals(0.0, distance, EPSILON);}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    super.setUp();    conf = getConfiguration();}
6b731d99075bf66d210ff9f1e11aab65a6843a539040513ce75e30fd9c6d4d90
testVar
public void testVar() throws Exception
{    Path input = getTestTempFilePath("stdDev/counts.file");    Path output = getTestTempFilePath("stdDev/output.file");    produceTestData(input);    double v = BasicStats.variance(input, output, conf);    assertEquals(2.44, v, 0.01);}
d1c407aeb28908ac5fd46a133f99392a467ae502fee0f83efa6e754b211dcd6d
testStdDev
public void testStdDev() throws Exception
{    Path input = getTestTempFilePath("stdDev/counts.file");    Path output = getTestTempFilePath("stdDev/output.file");    produceTestData(input);    double v = BasicStats.stdDev(input, output, conf);        assertEquals(1.56, v, 0.01);}
a24f77a449b429eab3ace0bccdc6c59277805ac7b71e216cfcaa6d6ad3f10ed3
testStdDevForGivenMean
public void testStdDevForGivenMean() throws Exception
{    Path input = getTestTempFilePath("stdDev/counts.file");    Path output = getTestTempFilePath("stdDev/output.file");    produceTestData(input);    double v = BasicStats.stdDevForGivenMean(input, output, 0.0D, conf);        assertEquals(10.65, v, 0.01);}
d6b8908df9098cb3aee7f97dfc016b90f5f5c67539a65509d28b608f43b67364
produceTestData
private void produceTestData(Path input) throws Exception
{    FileSystem fs = FileSystem.get(input.toUri(), conf);    SequenceFile.Writer writer = new SequenceFile.Writer(fs, conf, input, IntWritable.class, DoubleWritable.class);        /*Normal normal = new Normal(5, 3, random);    for (int i = 0; i < 10000; i++) {      writer.append(new IntWritable(i), new DoubleWritable((long)normal.nextDouble()));    }*/    int i = 0;    writer.append(new IntWritable(i++), new DoubleWritable(7));    writer.append(new IntWritable(i++), new DoubleWritable(9));    writer.append(new IntWritable(i++), new DoubleWritable(9));    writer.append(new IntWritable(i++), new DoubleWritable(10));    writer.append(new IntWritable(i++), new DoubleWritable(10));    writer.append(new IntWritable(i++), new DoubleWritable(10));    writer.append(new IntWritable(i++), new DoubleWritable(10));    writer.append(new IntWritable(i++), new DoubleWritable(11));    writer.append(new IntWritable(i++), new DoubleWritable(11));    writer.append(new IntWritable(i++), new DoubleWritable(13));    writer.close();}
720ceb6ab3219f60907176eef07250f8727f03ba7eb8e8423fe48167008eb8c7
testStdDev2
public void testStdDev2() throws Exception
{    Path input = getTestTempFilePath("stdDev/counts.file");    Path output = getTestTempFilePath("stdDev/output.file");    FileSystem fs = FileSystem.get(input.toUri(), conf);    SequenceFile.Writer writer = new SequenceFile.Writer(fs, conf, input, IntWritable.class, DoubleWritable.class);    Random random = RandomUtils.getRandom();    Normal normal = new Normal(5, 3, random);    for (int i = 0; i < 1000000; i++) {        writer.append(new IntWritable(i), new DoubleWritable((long) normal.nextInt()));    }    writer.close();    double v = BasicStats.stdDev(input, output, conf);    assertEquals(3, v, 0.02);}
2c4e34685d95a9301a4876d7c0deb64525ecad02daa64584256eafe07c463f2f
testOmegaTRightMultiply
public void testOmegaTRightMultiply()
{    final Random rnd = RandomUtils.getRandom();    final long seed = rnd.nextLong();    final int n = 2000;    final int kp = 100;    final Omega omega = new Omega(seed, kp);    final Matrix materializedOmega = new DenseMatrix(n, kp);    for (int i = 0; i < n; i++) for (int j = 0; j < kp; j++) materializedOmega.setQuick(i, j, omega.getQuick(i, j));    Vector xi = new DenseVector(n);    xi.assign(new DoubleFunction() {        @Override        public double apply(double x) {            return rnd.nextDouble() * 100;        }    });    Vector s_o = omega.mutlithreadedTRightMultiply(xi);    Matrix xiVector = new DenseMatrix(n, 1);    xiVector.assignColumn(0, xi);    Vector s_o_control = materializedOmega.transpose().times(xiVector).viewColumn(0);    assertEquals(0, s_o.minus(s_o_control).aggregate(Functions.PLUS, Functions.ABS), 1e-10);    System.out.printf("s_omega=\n%s\n", s_o);    System.out.printf("s_omega_control=\n%s\n", s_o_control);}
289ca856ae087737aff3520959859058a3e642cf3f87b00a2d0d486b23b7b74a
apply
public double apply(double x)
{    return rnd.nextDouble() * 100;}
e923669038fcda6b49bd88d8052bb1415e35c1e40cc1cd5aa79907ee500ee55d
runPCATest1
public void runPCATest1() throws IOException
{    runSSVDSolver(1);}
a19d858f2cc3f956821f9fcbeb6227e315205591fd1977e75596f6b5b0af73df
runPCATest0
public void runPCATest0() throws IOException
{    runSSVDSolver(0);}
38475181a74b654f6b58b3ef9c76caf30ecb881f263a2a402978ffd17a44d01c
runSSVDSolver
public void runSSVDSolver(int q) throws IOException
{    Configuration conf = new Configuration();    conf.set("mapred.job.tracker", "local");    conf.set("fs.default.name", "file:///");            Deque<Closeable> closeables = Lists.newLinkedList();    try {        Random rnd = RandomUtils.getRandom();        File tmpDir = getTestTempDir("svdtmp");        conf.set("hadoop.tmp.dir", tmpDir.getAbsolutePath());        Path aLocPath = new Path(getTestTempDirPath("svdtmp/A"), "A.seq");                SequenceFile.Writer w = SequenceFile.createWriter(FileSystem.getLocal(conf), conf, aLocPath, Text.class, VectorWritable.class, CompressionType.BLOCK, new DefaultCodec());        closeables.addFirst(w);        int n = 100;        int m = 2000;        double percent = 5;        VectorWritable vw = new VectorWritable();        Text rkey = new Text();        Vector xi = new DenseVector(n);        double muAmplitude = 50.0;        for (int i = 0; i < m; i++) {            Vector dv = new SequentialAccessSparseVector(n);            String rowname = "row-" + i;            NamedVector namedRow = new NamedVector(dv, rowname);            for (int j = 0; j < n * percent / 100; j++) {                dv.setQuick(rnd.nextInt(n), muAmplitude * (rnd.nextDouble() - 0.25));            }            rkey.set("row-i" + i);            vw.set(namedRow);            w.append(rkey, vw);            xi.assign(dv, Functions.PLUS);        }        closeables.remove(w);        Closeables.close(w, false);        xi.assign(Functions.mult(1.0 / m));        FileSystem fs = FileSystem.get(conf);        Path tempDirPath = getTestTempDirPath("svd-proc");        Path aPath = new Path(tempDirPath, "A/A.seq");        fs.copyFromLocalFile(aLocPath, aPath);        Path xiPath = new Path(tempDirPath, "xi/xi.seq");        SSVDHelper.saveVector(xi, xiPath, conf);        Path svdOutPath = new Path(tempDirPath, "SSVD-out");                fs.delete(svdOutPath, true);                System.out.println("Input prepared, starting solver...");        int ablockRows = 867;        int p = 60;        int k = 40;        SSVDSolver ssvd = new SSVDSolver(conf, new Path[] { aPath }, svdOutPath, ablockRows, k, p, 3);        ssvd.setOuterBlockHeight(500);        ssvd.setAbtBlockHeight(251);        ssvd.setPcaMeanPath(xiPath);        /*     * Removing V,U jobs from this test to reduce running time. i will keep them     * put in the dense test though.     *     * For PCA test, we also want to request U*Sigma output and check it for named     * vector propagation.     */        ssvd.setComputeU(false);        ssvd.setComputeV(false);        ssvd.setcUSigma(true);        ssvd.setOverwrite(true);        ssvd.setQ(q);        ssvd.setBroadcast(true);        ssvd.run();        Vector stochasticSValues = ssvd.getSingularValues();                Matrix a = SSVDHelper.drmLoadAsDense(fs, aPath, conf);        verifyInternals(svdOutPath, a, new Omega(ssvd.getOmegaSeed(), k + p), k + p, q);                for (int i = 0; i < m; i++) {            a.viewRow(i).assign(xi, Functions.MINUS);        }        SingularValueDecomposition svd2 = new SingularValueDecomposition(a);        Vector svalues2 = new DenseVector(svd2.getSingularValues());        System.out.println("--SSVD solver singular values:");        LocalSSVDSolverSparseSequentialTest.dumpSv(stochasticSValues);        System.out.println("--SVD solver singular values:");        LocalSSVDSolverSparseSequentialTest.dumpSv(svalues2);        for (int i = 0; i < k + p; i++) {            assertTrue(Math.abs(svalues2.getQuick(i) - stochasticSValues.getQuick(i)) <= s_epsilon);        }        DenseMatrix mQ = SSVDHelper.drmLoadAsDense(fs, new Path(svdOutPath, "Bt-job/" + BtJob.OUTPUT_Q + "-*"), conf);        SSVDCommonTest.assertOrthonormality(mQ, false, s_epsilon);                for (Iterator<Pair<Writable, Vector>> iter = SSVDHelper.drmIterator(fs, new Path(ssvd.getuSigmaPath() + "/*"), conf, closeables); iter.hasNext(); ) {            Pair<Writable, Vector> pair = iter.next();            Writable key = pair.getFirst();            Vector v = pair.getSecond();            assertTrue(v instanceof NamedVector);            assertTrue(key instanceof Text);        }    } finally {        IOUtils.close(closeables);    }}
d2c867a72bbeb2140f8b8c6a8133aef89a2b15e505e051036d4d8c04b88b3142
verifyInternals
private void verifyInternals(Path tempDir, Matrix a, Omega omega, int kp, int q)
{    int m = a.numRows();    int n = a.numCols();    Vector xi = a.aggregateColumns(new VectorFunction() {        @Override        public double apply(Vector v) {            return v.zSum() / v.size();        }    });        Matrix momega = new DenseMatrix(n, kp);    for (int i = 0; i < n; i++) for (int j = 0; j < kp; j++) momega.setQuick(i, j, omega.getQuick(i, j));    Vector s_o = omega.mutlithreadedTRightMultiply(xi);    System.out.printf("s_omega=\n%s\n", s_o);    Matrix y = a.times(momega);    for (int i = 0; i < n; i++) y.viewRow(i).assign(s_o, Functions.MINUS);    QRDecomposition qr = new QRDecomposition(y);    Matrix qm = qr.getQ();    Vector s_q = qm.aggregateColumns(new VectorFunction() {        @Override        public double apply(Vector v) {            return v.zSum();        }    });    System.out.printf("s_q=\n%s\n", s_q);    Matrix b = qm.transpose().times(a);    Vector s_b = b.times(xi);    System.out.printf("s_b=\n%s\n", s_b);}
34458c5c4d61eeeaeb2eaf91ebf4340feeee54c6c8bea0ed7d7a4c377baca8e5
apply
public double apply(Vector v)
{    return v.zSum() / v.size();}
34458c5c4d61eeeaeb2eaf91ebf4340feeee54c6c8bea0ed7d7a4c377baca8e5
apply
public double apply(Vector v)
{    return v.zSum();}
7503c464cb3db75e0ca6a49285ce6605825037884aaaba3b6cdab6ebb93da738
testSSVDSolverDense
public void testSSVDSolverDense() throws IOException
{    runSSVDSolver(0);}
5e216d2a96d5988c9ed8350f2323c61ac6ad64701995ee0a2f133d1504829db7
testSSVDSolverPowerIterations1
public void testSSVDSolverPowerIterations1() throws IOException
{    runSSVDSolver(1);}
38475181a74b654f6b58b3ef9c76caf30ecb881f263a2a402978ffd17a44d01c
runSSVDSolver
public void runSSVDSolver(int q) throws IOException
{    Configuration conf = getConfiguration();    conf.set("mapred.job.tracker", "local");    conf.set("fs.default.name", "file:///");            File tmpDir = getTestTempDir("svdtmp");    conf.set("hadoop.tmp.dir", tmpDir.getAbsolutePath());    Path aLocPath = new Path(getTestTempDirPath("svdtmp/A"), "A.seq");                                    int n = 100;    int m = 2000;    Vector singularValues = new DenseVector(new double[] { 10, 4, 1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1 });    SSVDTestsHelper.generateDenseInput(aLocPath, FileSystem.getLocal(conf), singularValues, m, n);    FileSystem fs = FileSystem.get(aLocPath.toUri(), conf);    Path tempDirPath = getTestTempDirPath("svd-proc");    Path aPath = new Path(tempDirPath, "A/A.seq");    fs.copyFromLocalFile(aLocPath, aPath);    Path svdOutPath = new Path(tempDirPath, "SSVD-out");        System.out.println("Input prepared, starting solver...");    int ablockRows = 867;    int p = 10;    int k = 3;    SSVDSolver ssvd = new SSVDSolver(conf, new Path[] { aPath }, svdOutPath, ablockRows, k, p, 3);    /*     * these are only tiny-test values to simulate high load cases, in reality     * one needs much bigger     */    ssvd.setOuterBlockHeight(500);    ssvd.setAbtBlockHeight(400);    ssvd.setOverwrite(true);    ssvd.setQ(q);    ssvd.setBroadcast(false);    ssvd.run();    Vector stochasticSValues = ssvd.getSingularValues();    System.out.println("--SSVD solver singular values:");    dumpSv(stochasticSValues);    for (int i = 0; i < k; i++) {        assertTrue(Math.abs((singularValues.getQuick(i) - stochasticSValues.getQuick(i)) / singularValues.getQuick(i)) <= s_precisionPct / 100);    }    DenseMatrix mQ = SSVDHelper.drmLoadAsDense(fs, new Path(svdOutPath, "Bt-job/" + BtJob.OUTPUT_Q + "-*"), conf);    SSVDCommonTest.assertOrthonormality(mQ, false, s_epsilon);    DenseMatrix u = SSVDHelper.drmLoadAsDense(fs, new Path(svdOutPath, "U/*"), conf);    SSVDCommonTest.assertOrthonormality(u, false, s_epsilon);    DenseMatrix v = SSVDHelper.drmLoadAsDense(fs, new Path(svdOutPath, "V/*"), conf);    SSVDCommonTest.assertOrthonormality(v, false, s_epsilon);}
0df2dc5ae366a72baf9922577973c2877c663a275bd4ddbc443f7ab5b527079b
dumpSv
 static void dumpSv(Vector s)
{    System.out.printf("svs: ");    for (Vector.Element el : s.all()) {        System.out.printf("%f  ", el.get());    }    System.out.println();}
5e216d2a96d5988c9ed8350f2323c61ac6ad64701995ee0a2f133d1504829db7
testSSVDSolverPowerIterations1
public void testSSVDSolverPowerIterations1() throws IOException
{    runSSVDSolver(1);}
38475181a74b654f6b58b3ef9c76caf30ecb881f263a2a402978ffd17a44d01c
runSSVDSolver
public void runSSVDSolver(int q) throws IOException
{    Configuration conf = getConfiguration();    conf.set("mapred.job.tracker", "local");    conf.set("fs.default.name", "file:///");            Deque<Closeable> closeables = Lists.newLinkedList();    ;    Random rnd = RandomUtils.getRandom();    File tmpDir = getTestTempDir("svdtmp");    conf.set("hadoop.tmp.dir", tmpDir.getAbsolutePath());    Path aLocPath = new Path(getTestTempDirPath("svdtmp/A"), "A.seq");        SequenceFile.Writer w = SequenceFile.createWriter(FileSystem.getLocal(conf), conf, aLocPath, IntWritable.class, VectorWritable.class, CompressionType.BLOCK, new DefaultCodec());    closeables.addFirst(w);    int n = 100;    int m = 2000;    double percent = 5;    VectorWritable vw = new VectorWritable();    IntWritable roww = new IntWritable();    double muAmplitude = 50.0;    for (int i = 0; i < m; i++) {        Vector dv = new SequentialAccessSparseVector(n);        for (int j = 0; j < n * percent / 100; j++) {            dv.setQuick(rnd.nextInt(n), muAmplitude * (rnd.nextDouble() - 0.5));        }        roww.set(i);        vw.set(dv);        w.append(roww, vw);    }    closeables.remove(w);    Closeables.close(w, false);    FileSystem fs = FileSystem.get(aLocPath.toUri(), conf);    Path tempDirPath = getTestTempDirPath("svd-proc");    Path aPath = new Path(tempDirPath, "A/A.seq");    fs.copyFromLocalFile(aLocPath, aPath);    Path svdOutPath = new Path(tempDirPath, "SSVD-out");        fs.delete(svdOutPath, true);        System.out.println("Input prepared, starting solver...");    int ablockRows = 867;    int p = 60;    int k = 40;    SSVDSolver ssvd = new SSVDSolver(conf, new Path[] { aPath }, svdOutPath, ablockRows, k, p, 3);    ssvd.setOuterBlockHeight(500);    ssvd.setAbtBlockHeight(251);    /*     * removing V,U jobs from this test to reduce running time. i will keep them     * put in the dense test though.     */    ssvd.setComputeU(false);    ssvd.setComputeV(false);    ssvd.setOverwrite(true);    ssvd.setQ(q);    ssvd.setBroadcast(true);    ssvd.run();    Vector stochasticSValues = ssvd.getSingularValues();    System.out.println("--SSVD solver singular values:");    dumpSv(stochasticSValues);    System.out.println("--Colt SVD solver singular values:");        DenseMatrix a = SSVDHelper.drmLoadAsDense(fs, aPath, conf);            SingularValueDecomposition svd2 = new SingularValueDecomposition(a);    Vector svalues2 = new DenseVector(svd2.getSingularValues());    dumpSv(svalues2);    for (int i = 0; i < k + p; i++) {        assertTrue(Math.abs(svalues2.getQuick(i) - stochasticSValues.getQuick(i)) <= s_epsilon);    }    DenseMatrix mQ = SSVDHelper.drmLoadAsDense(fs, new Path(svdOutPath, "Bt-job/" + BtJob.OUTPUT_Q + "-*"), conf);    SSVDCommonTest.assertOrthonormality(mQ, false, s_epsilon);    IOUtils.close(closeables);}
0df2dc5ae366a72baf9922577973c2877c663a275bd4ddbc443f7ab5b527079b
dumpSv
 static void dumpSv(Vector s)
{    System.out.printf("svs: ");    for (Vector.Element el : s.all()) {        System.out.printf("%f  ", el.get());    }    System.out.println();}
736af6a0dff18bd8f50c69009ca11cc087591743266c9e4492e196a04ac4d7d3
dump
 static void dump(double[][] matrix)
{    for (double[] aMatrix : matrix) {        for (double anAMatrix : aMatrix) {            System.out.printf("%f  ", anAMatrix);        }        System.out.println();    }}
c0b2e46480cb24434b59db1c4e389b9e518b6e894e1260470dbd70aa281e4035
testGivensQR
public void testGivensQR() throws Exception
{        Matrix m = new DenseMatrix(3, 3);    m.assign(new DoubleFunction() {        private final Random rnd = RandomUtils.getRandom();        @Override        public double apply(double arg0) {            return rnd.nextDouble() * SCALE;        }    });    m.setQuick(0, 0, 1);    m.setQuick(0, 1, 2);    m.setQuick(0, 2, 3);    m.setQuick(1, 0, 4);    m.setQuick(1, 1, 5);    m.setQuick(1, 2, 6);    m.setQuick(2, 0, 7);    m.setQuick(2, 1, 8);    m.setQuick(2, 2, 9);    GivensThinSolver qrSolver = new GivensThinSolver(m.rowSize(), m.columnSize());    qrSolver.solve(m);    Matrix qtm = new DenseMatrix(qrSolver.getThinQtTilde());    assertOrthonormality(qtm.transpose(), false, SVD_EPSILON);    Matrix aClone = new DenseMatrix(qrSolver.getThinQtTilde()).transpose().times(qrSolver.getRTilde());    System.out.println("aclone : " + aClone);}
6d250deb31b456879c36975a921002ebcab7c3f1a9c712425bebfa223a70ef21
apply
public double apply(double arg0)
{    return rnd.nextDouble() * SCALE;}
d711cdd13b0fea9c2f8f19c1f26f90b149b2726333b50e3c2f43b306199ee9f4
assertOrthonormality
public static void assertOrthonormality(Matrix mtx, boolean insufficientRank, double epsilon)
{    int n = mtx.columnSize();    int rank = 0;    for (int i = 0; i < n; i++) {        Vector ei = mtx.viewColumn(i);        double norm = ei.norm(2);        if (Math.abs(1 - norm) < epsilon) {            rank++;        } else {            assertTrue(Math.abs(norm) < epsilon);        }        for (int j = 0; j <= i; j++) {            Vector e_j = mtx.viewColumn(j);            double dot = ei.dot(e_j);            assertTrue(Math.abs((i == j && rank > j ? 1 : 0) - dot) < epsilon);        }    }    assertTrue((!insufficientRank && rank == n) || (insufficientRank && rank < n));}
9fca0f20bf1b1df24229c31c55e92ef3c789731d89880361e1ab1b961f62c82d
generateDenseInput
 static void generateDenseInput(Path outputPath, FileSystem dfs, Vector svalues, int m, int n) throws IOException
{    generateDenseInput(outputPath, dfs, svalues, m, n, 0);}
8c52b719d5702f337b64b94cddcfe167b475f4256be36a60922e6ca65fd12d35
generateDenseInput
 static void generateDenseInput(Path outputPath, FileSystem dfs, Vector svalues, int m, int n, int startRowKey) throws IOException
{    Random rnd = RandomUtils.getRandom();    int svCnt = svalues.size();    Matrix v = generateDenseOrthonormalRandom(n, svCnt, rnd);    Matrix u = generateDenseOrthonormalRandom(m, svCnt, rnd);        Matrix mx = m > n ? v : u;    for (int i = 0; i < svCnt; i++) {        mx.assignColumn(i, mx.viewColumn(i).times(svalues.getQuick(i)));    }    SequenceFile.Writer w = SequenceFile.createWriter(dfs, dfs.getConf(), outputPath, IntWritable.class, VectorWritable.class);    try {        Vector outV = new DenseVector(n);        Writable vw = new VectorWritable(outV);        IntWritable iw = new IntWritable();        for (int i = 0; i < m; i++) {            iw.set(startRowKey + i);            for (int j = 0; j < n; j++) {                outV.setQuick(j, u.viewRow(i).dot(v.viewRow(j)));            }            w.append(iw, vw);        }    } finally {        w.close();    }}
dae1ac877eb13735d64ad64ad1a0737d871ba2366b53877164833ae45b286588
generateDenseOrthonormalRandom
 static Matrix generateDenseOrthonormalRandom(int m, int n, Random rnd)
{    Matrix result = new DenseMatrix(m, n);    for (int j = 0; j < n; j++) {        for (int i = 0; i < m; i++) {            result.setQuick(i, j, rnd.nextDouble() - 0.5);        }    }    GramSchmidt.orthonormalizeColumns(result);    SSVDCommonTest.assertOrthonormality(result, false, 1.0e-10);    return result;}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{        MahoutTestCase ca = new MahoutTestCase();    Configuration conf = ca.getConfiguration();    FileSystem dfs = FileSystem.getLocal(conf);    Path outputDir = new Path("/tmp/DRM");    dfs.mkdirs(outputDir);                            /*     *  create 2Gb sparse 4.5 m x 4.5m input . (similar to wikipedia graph).     *       *  In order to get at 2Gb, we need to generate ~ 40 non-zero items per row average.     *        */    outputDir = new Path("/tmp/DRM-sparse");    Random rnd = RandomUtils.getRandom();    SequenceFile.Writer w = SequenceFile.createWriter(dfs, dfs.getConf(), new Path(outputDir, "sparse.seq"), IntWritable.class, VectorWritable.class);    try {        IntWritable iw = new IntWritable();        VectorWritable vw = new VectorWritable();        int avgNZero = 40;        int n = 4500000;        for (int i = 1; i < n; i++) {            Vector vector = new RandomAccessSparseVector(n);            double nz = Math.round(avgNZero * (rnd.nextGaussian() + 1));            if (nz < 0) {                nz = 0;            }            for (int j = 1; j < nz; j++) {                vector.set(rnd.nextInt(n), rnd.nextGaussian() * 25 + 3);            }            iw.set(i);            vw.set(vector);            w.append(iw, vw);        }    } finally {        w.close();    }}
12fca971b4fa742263e715cb6f7531666f784c39f55cca670333c331cc668499
assertEquals
private static void assertEquals(VectorIterable m, VectorIterable mtt, double errorTolerance)
{    Iterator<MatrixSlice> mIt = m.iterateAll();    Iterator<MatrixSlice> mttIt = mtt.iterateAll();    Map<Integer, Vector> mMap = Maps.newHashMap();    Map<Integer, Vector> mttMap = Maps.newHashMap();    while (mIt.hasNext() && mttIt.hasNext()) {        MatrixSlice ms = mIt.next();        mMap.put(ms.index(), ms.vector());        MatrixSlice mtts = mttIt.next();        mttMap.put(mtts.index(), mtts.vector());    }    for (Map.Entry<Integer, Vector> entry : mMap.entrySet()) {        Integer key = entry.getKey();        Vector value = entry.getValue();        if (value == null || mttMap.get(key) == null) {            assertTrue(value == null || value.norm(2) == 0);            assertTrue(mttMap.get(key) == null || mttMap.get(key).norm(2) == 0);        } else {            assertTrue(value.getDistanceSquared(mttMap.get(key)) < errorTolerance);        }    }}
cedc51f61958cca20ecaaddc4d648a4cb370e09ebf8ed74300b734a968589c62
testTranspose
public void testTranspose() throws Exception
{    DistributedRowMatrix m = randomDistributedMatrix(10, 9, 5, 4, 1.0, false);    m.setConf(getConfiguration());    DistributedRowMatrix mt = m.transpose();    mt.setConf(getConfiguration());    Path tmpPath = getTestTempDirPath();    m.setOutputTempPathString(tmpPath.toString());    Path tmpOutPath = new Path(tmpPath, "/tmpOutTranspose");    mt.setOutputTempPathString(tmpOutPath.toString());    HadoopUtil.delete(getConfiguration(), tmpOutPath);    DistributedRowMatrix mtt = mt.transpose();    assertEquals(m, mtt, EPSILON);}
f02c1108c4937f4cdd1e16ea768cb5b5a1893ed093ad9132d76818d5ad0dfe51
testMatrixColumnMeansJob
public void testMatrixColumnMeansJob() throws Exception
{    Matrix m = SolverTest.randomSequentialAccessSparseMatrix(100, 90, 50, 20, 1.0);    DistributedRowMatrix dm = randomDistributedMatrix(100, 90, 50, 20, 1.0, false);    dm.setConf(getConfiguration());    Vector expected = new DenseVector(50);    for (int i = 0; i < m.numRows(); i++) {        expected.assign(m.viewRow(i), Functions.PLUS);    }    expected.assign(Functions.DIV, m.numRows());    Vector actual = dm.columnMeans("DenseVector");    assertEquals(0.0, expected.getDistanceSquared(actual), EPSILON);}
7d80580007ce20554b91de25b47c4899170046a8ee4df7e65616ff9bb3bef619
testNullMatrixColumnMeansJob
public void testNullMatrixColumnMeansJob() throws Exception
{    Matrix m = SolverTest.randomSequentialAccessSparseMatrix(100, 90, 0, 0, 1.0);    DistributedRowMatrix dm = randomDistributedMatrix(100, 90, 0, 0, 1.0, false);    dm.setConf(getConfiguration());    Vector expected = new DenseVector(0);    for (int i = 0; i < m.numRows(); i++) {        expected.assign(m.viewRow(i), Functions.PLUS);    }    expected.assign(Functions.DIV, m.numRows());    Vector actual = dm.columnMeans();    assertEquals(0.0, expected.getDistanceSquared(actual), EPSILON);}
b0359f9e32edfa5c667cf469a68c7ae84ec45bf0b6609ed62fa24c415a99ce8e
testMatrixTimesVector
public void testMatrixTimesVector() throws Exception
{    Vector v = new RandomAccessSparseVector(50);    v.assign(1.0);    Matrix m = SolverTest.randomSequentialAccessSparseMatrix(100, 90, 50, 20, 1.0);    DistributedRowMatrix dm = randomDistributedMatrix(100, 90, 50, 20, 1.0, false);    dm.setConf(getConfiguration());    Vector expected = m.times(v);    Vector actual = dm.times(v);    assertEquals(0.0, expected.getDistanceSquared(actual), EPSILON);}
56b73f621e6bef8cdd4e4cc29ad8e239938ca0d5350d815d918219f4e72901e9
testMatrixTimesSquaredVector
public void testMatrixTimesSquaredVector() throws Exception
{    Vector v = new RandomAccessSparseVector(50);    v.assign(1.0);    Matrix m = SolverTest.randomSequentialAccessSparseMatrix(100, 90, 50, 20, 1.0);    DistributedRowMatrix dm = randomDistributedMatrix(100, 90, 50, 20, 1.0, false);    dm.setConf(getConfiguration());    Vector expected = m.timesSquared(v);    Vector actual = dm.timesSquared(v);    assertEquals(0.0, expected.getDistanceSquared(actual), 1.0e-9);}
899259797fa9daa75fc6475fc954f4e22f3f91db13653c536da623ef82db2bda
testMatrixTimesMatrix
public void testMatrixTimesMatrix() throws Exception
{    Matrix inputA = SolverTest.randomSequentialAccessSparseMatrix(20, 19, 15, 5, 10.0);    Matrix inputB = SolverTest.randomSequentialAccessSparseMatrix(20, 13, 25, 10, 5.0);    Matrix expected = inputA.transpose().times(inputB);    DistributedRowMatrix distA = randomDistributedMatrix(20, 19, 15, 5, 10.0, false, "distA");    distA.setConf(getConfiguration());    DistributedRowMatrix distB = randomDistributedMatrix(20, 13, 25, 10, 5.0, false, "distB");    distB.setConf(getConfiguration());    DistributedRowMatrix product = distA.times(distB);    assertEquals(expected, product, EPSILON);}
cda56d4cacf8b802887e87c888620d48c04b9dae0c71bbf493c4f53c3119546c
testMatrixMultiplactionJobConfBuilder
public void testMatrixMultiplactionJobConfBuilder() throws Exception
{    Configuration initialConf = createInitialConf();    Path baseTmpDirPath = getTestTempDirPath("testpaths");    Path aPath = new Path(baseTmpDirPath, "a");    Path bPath = new Path(baseTmpDirPath, "b");    Path outPath = new Path(baseTmpDirPath, "out");    Configuration mmJobConf = MatrixMultiplicationJob.createMatrixMultiplyJobConf(aPath, bPath, outPath, 10);    Configuration mmCustomJobConf = MatrixMultiplicationJob.createMatrixMultiplyJobConf(initialConf, aPath, bPath, outPath, 10);    assertNull(mmJobConf.get(TEST_PROPERTY_KEY));    assertEquals(TEST_PROPERTY_VALUE, mmCustomJobConf.get(TEST_PROPERTY_KEY));}
fa2e07fc9f50deeb1383c7b9c430e5329d6f411a6c630f39de7b6db112741525
testTransposeJobConfBuilder
public void testTransposeJobConfBuilder() throws Exception
{    Configuration initialConf = createInitialConf();    Path baseTmpDirPath = getTestTempDirPath("testpaths");    Path inputPath = new Path(baseTmpDirPath, "input");    Path outputPath = new Path(baseTmpDirPath, "output");    Configuration transposeJobConf = TransposeJob.buildTransposeJob(inputPath, outputPath, 10).getConfiguration();    Configuration transposeCustomJobConf = TransposeJob.buildTransposeJob(initialConf, inputPath, outputPath, 10).getConfiguration();    assertNull(transposeJobConf.get(TEST_PROPERTY_KEY));    assertEquals(TEST_PROPERTY_VALUE, transposeCustomJobConf.get(TEST_PROPERTY_KEY));}
3ed2c435c5e7d63bdc7ca05aa757002de8149f724296ffff9517b7f44e6d5b11
testTimesSquaredJobConfBuilders
public void testTimesSquaredJobConfBuilders() throws Exception
{    Configuration initialConf = createInitialConf();    Path baseTmpDirPath = getTestTempDirPath("testpaths");    Path inputPath = new Path(baseTmpDirPath, "input");    Path outputPath = new Path(baseTmpDirPath, "output");    Vector v = new RandomAccessSparseVector(50);    v.assign(1.0);    Job timesSquaredJob1 = TimesSquaredJob.createTimesSquaredJob(v, inputPath, outputPath);    Job customTimesSquaredJob1 = TimesSquaredJob.createTimesSquaredJob(initialConf, v, inputPath, outputPath);    assertNull(timesSquaredJob1.getConfiguration().get(TEST_PROPERTY_KEY));    assertEquals(TEST_PROPERTY_VALUE, customTimesSquaredJob1.getConfiguration().get(TEST_PROPERTY_KEY));    Job timesJob = TimesSquaredJob.createTimesJob(v, 50, inputPath, outputPath);    Job customTimesJob = TimesSquaredJob.createTimesJob(initialConf, v, 50, inputPath, outputPath);    assertNull(timesJob.getConfiguration().get(TEST_PROPERTY_KEY));    assertEquals(TEST_PROPERTY_VALUE, customTimesJob.getConfiguration().get(TEST_PROPERTY_KEY));    Job timesSquaredJob2 = TimesSquaredJob.createTimesSquaredJob(v, inputPath, outputPath, TimesSquaredJob.TimesSquaredMapper.class, TimesSquaredJob.VectorSummingReducer.class);    Job customTimesSquaredJob2 = TimesSquaredJob.createTimesSquaredJob(initialConf, v, inputPath, outputPath, TimesSquaredJob.TimesSquaredMapper.class, TimesSquaredJob.VectorSummingReducer.class);    assertNull(timesSquaredJob2.getConfiguration().get(TEST_PROPERTY_KEY));    assertEquals(TEST_PROPERTY_VALUE, customTimesSquaredJob2.getConfiguration().get(TEST_PROPERTY_KEY));    Job timesSquaredJob3 = TimesSquaredJob.createTimesSquaredJob(v, 50, inputPath, outputPath, TimesSquaredJob.TimesSquaredMapper.class, TimesSquaredJob.VectorSummingReducer.class);    Job customTimesSquaredJob3 = TimesSquaredJob.createTimesSquaredJob(initialConf, v, 50, inputPath, outputPath, TimesSquaredJob.TimesSquaredMapper.class, TimesSquaredJob.VectorSummingReducer.class);    assertNull(timesSquaredJob3.getConfiguration().get(TEST_PROPERTY_KEY));    assertEquals(TEST_PROPERTY_VALUE, customTimesSquaredJob3.getConfiguration().get(TEST_PROPERTY_KEY));}
655bfc7ccab4a0b3d83c2fcfd78c5d53fc78bcec0e5c21df6463f3598aefc637
testTimesVectorTempDirDeletion
public void testTimesVectorTempDirDeletion() throws Exception
{    Configuration conf = getConfiguration();    Vector v = new RandomAccessSparseVector(50);    v.assign(1.0);    DistributedRowMatrix dm = randomDistributedMatrix(100, 90, 50, 20, 1.0, false);    dm.setConf(conf);    Path outputPath = dm.getOutputTempPath();    FileSystem fs = outputPath.getFileSystem(conf);    deleteContentsOfPath(conf, outputPath);    assertEquals(0, HadoopUtil.listStatus(fs, outputPath).length);    Vector result1 = dm.times(v);    assertEquals(0, HadoopUtil.listStatus(fs, outputPath).length);    deleteContentsOfPath(conf, outputPath);    assertEquals(0, HadoopUtil.listStatus(fs, outputPath).length);    conf.setBoolean(DistributedRowMatrix.KEEP_TEMP_FILES, true);    dm.setConf(conf);    Vector result2 = dm.times(v);    FileStatus[] outputStatuses = fs.listStatus(outputPath);    assertEquals(1, outputStatuses.length);    Path outputTempPath = outputStatuses[0].getPath();    Path inputVectorPath = new Path(outputTempPath, TimesSquaredJob.INPUT_VECTOR);    Path outputVectorPath = new Path(outputTempPath, TimesSquaredJob.OUTPUT_VECTOR_FILENAME);    assertEquals(1, fs.listStatus(inputVectorPath, PathFilters.logsCRCFilter()).length);    assertEquals(1, fs.listStatus(outputVectorPath, PathFilters.logsCRCFilter()).length);    assertEquals(0.0, result1.getDistanceSquared(result2), EPSILON);}
c7588dc50614ddf883ec59f715dd62113496ee4e57311d824923fa447702b65b
testTimesSquaredVectorTempDirDeletion
public void testTimesSquaredVectorTempDirDeletion() throws Exception
{    Configuration conf = getConfiguration();    Vector v = new RandomAccessSparseVector(50);    v.assign(1.0);    DistributedRowMatrix dm = randomDistributedMatrix(100, 90, 50, 20, 1.0, false);    dm.setConf(getConfiguration());    Path outputPath = dm.getOutputTempPath();    FileSystem fs = outputPath.getFileSystem(conf);    deleteContentsOfPath(conf, outputPath);    assertEquals(0, HadoopUtil.listStatus(fs, outputPath).length);    Vector result1 = dm.timesSquared(v);    assertEquals(0, HadoopUtil.listStatus(fs, outputPath).length);    deleteContentsOfPath(conf, outputPath);    assertEquals(0, HadoopUtil.listStatus(fs, outputPath).length);    conf.setBoolean(DistributedRowMatrix.KEEP_TEMP_FILES, true);    dm.setConf(conf);    Vector result2 = dm.timesSquared(v);    FileStatus[] outputStatuses = fs.listStatus(outputPath);    assertEquals(1, outputStatuses.length);    Path outputTempPath = outputStatuses[0].getPath();    Path inputVectorPath = new Path(outputTempPath, TimesSquaredJob.INPUT_VECTOR);    Path outputVectorPath = new Path(outputTempPath, TimesSquaredJob.OUTPUT_VECTOR_FILENAME);    assertEquals(1, fs.listStatus(inputVectorPath, PathFilters.logsCRCFilter()).length);    assertEquals(1, fs.listStatus(outputVectorPath, PathFilters.logsCRCFilter()).length);    assertEquals(0.0, result1.getDistanceSquared(result2), EPSILON);}
3d91a2aea8ee3e3cf39e716ec74a5be7f16ce390d6b975577e1a9598f25052ed
createInitialConf
public Configuration createInitialConf() throws IOException
{    Configuration initialConf = getConfiguration();    initialConf.set(TEST_PROPERTY_KEY, TEST_PROPERTY_VALUE);    return initialConf;}
02b53d3ba1d7dba7223bdfba5c273ab4f5248fe2fad64aa4a3aec0d7239c49a7
deleteContentsOfPath
private static void deleteContentsOfPath(Configuration conf, Path path) throws Exception
{    FileSystem fs = path.getFileSystem(conf);    FileStatus[] statuses = HadoopUtil.listStatus(fs, path);    for (FileStatus status : statuses) {        fs.delete(status.getPath(), true);    }}
52f8182662bd53123044edb2e12db01c14096dc6333a61d223db6144dbe20a56
randomDistributedMatrix
public DistributedRowMatrix randomDistributedMatrix(int numRows, int nonNullRows, int numCols, int entriesPerRow, double entryMean, boolean isSymmetric) throws IOException
{    return randomDistributedMatrix(numRows, nonNullRows, numCols, entriesPerRow, entryMean, isSymmetric, "testdata");}
edf202250cd3a7eeaff16868abeefb3b792bcc4b159976d5de9aa52a707db2d1
randomDenseHierarchicalDistributedMatrix
public DistributedRowMatrix randomDenseHierarchicalDistributedMatrix(int numRows, int numCols, boolean isSymmetric, String baseTmpDirSuffix) throws IOException
{    Path baseTmpDirPath = getTestTempDirPath(baseTmpDirSuffix);    Matrix c = SolverTest.randomHierarchicalMatrix(numRows, numCols, isSymmetric);    return saveToFs(c, baseTmpDirPath);}
2e142986d6e3b7b6ff4a30c838bd39b0fb902f4c148ef7187c9b7550bdb618c8
randomDistributedMatrix
public DistributedRowMatrix randomDistributedMatrix(int numRows, int nonNullRows, int numCols, int entriesPerRow, double entryMean, boolean isSymmetric, String baseTmpDirSuffix) throws IOException
{    Path baseTmpDirPath = getTestTempDirPath(baseTmpDirSuffix);    Matrix c = SolverTest.randomSequentialAccessSparseMatrix(numRows, nonNullRows, numCols, entriesPerRow, entryMean);    if (isSymmetric) {        c = c.times(c.transpose());    }    return saveToFs(c, baseTmpDirPath);}
ec2fe9ecd4dba2607d77158d51a4dccea2fdc8b77f32ede83f54b0ee2d8bac03
saveToFs
private DistributedRowMatrix saveToFs(final Matrix m, Path baseTmpDirPath) throws IOException
{    Configuration conf = getConfiguration();    FileSystem fs = FileSystem.get(baseTmpDirPath.toUri(), conf);    ClusteringTestUtils.writePointsToFile(new Iterable<VectorWritable>() {        @Override        public Iterator<VectorWritable> iterator() {            return Iterators.transform(m.iterator(), new Function<MatrixSlice, VectorWritable>() {                @Override                public VectorWritable apply(MatrixSlice input) {                    return new VectorWritable(input.vector());                }            });        }    }, true, new Path(baseTmpDirPath, "distMatrix/part-00000"), fs, conf);    DistributedRowMatrix distMatrix = new DistributedRowMatrix(new Path(baseTmpDirPath, "distMatrix"), new Path(baseTmpDirPath, "tmpOut"), m.numRows(), m.numCols());    distMatrix.setConf(new Configuration(conf));    return distMatrix;}
12d915ce4b4b5600e73783dea6a7cab96d44b559eb5be6128074a8fed4636d35
iterator
public Iterator<VectorWritable> iterator()
{    return Iterators.transform(m.iterator(), new Function<MatrixSlice, VectorWritable>() {        @Override        public VectorWritable apply(MatrixSlice input) {            return new VectorWritable(input.vector());        }    });}
f5f77998208ef66b83b06fe460148c28a01c01cf10f93b6c26e530e45499569f
apply
public VectorWritable apply(MatrixSlice input)
{    return new VectorWritable(input.vector());}
a40ddaaa201af4d62464ab8dda833bee4f4191d18bd6f923fcc4f708d729baec
testSparseMatrixWritable
public void testSparseMatrixWritable() throws Exception
{    Matrix m = new SparseMatrix(5, 5);    m.set(1, 2, 3.0);    m.set(3, 4, 5.0);    Map<String, Integer> bindings = Maps.newHashMap();    bindings.put("A", 0);    bindings.put("B", 1);    bindings.put("C", 2);    bindings.put("D", 3);    bindings.put("default", 4);    m.setRowLabelBindings(bindings);    m.setColumnLabelBindings(bindings);    doTestMatrixWritableEquals(m);}
392655a575a6c048f8e475e1bae88cea4f59dc8e3fffae00990e61eaa0207187
testSparseRowMatrixWritable
public void testSparseRowMatrixWritable() throws Exception
{    Matrix m = new SparseRowMatrix(5, 5);    m.set(1, 2, 3.0);    m.set(3, 4, 5.0);    Map<String, Integer> bindings = Maps.newHashMap();    bindings.put("A", 0);    bindings.put("B", 1);    bindings.put("C", 2);    bindings.put("D", 3);    bindings.put("default", 4);    m.setRowLabelBindings(bindings);    m.setColumnLabelBindings(bindings);    doTestMatrixWritableEquals(m);}
d9c6dbb5db418cd35136eb5fb3bc49a73a6bc7210e7fbc987d6486dc5efa0b4e
testDenseMatrixWritable
public void testDenseMatrixWritable() throws Exception
{    Matrix m = new DenseMatrix(5, 5);    m.set(1, 2, 3.0);    m.set(3, 4, 5.0);    Map<String, Integer> bindings = Maps.newHashMap();    bindings.put("A", 0);    bindings.put("B", 1);    bindings.put("C", 2);    bindings.put("D", 3);    bindings.put("default", 4);    m.setRowLabelBindings(bindings);    m.setColumnLabelBindings(bindings);    doTestMatrixWritableEquals(m);}
ce97016fe656a157332edfb819ffa2067414587c2df3310e0ddf698cda109421
doTestMatrixWritableEquals
private static void doTestMatrixWritableEquals(Matrix m) throws IOException
{    Writable matrixWritable = new MatrixWritable(m);    MatrixWritable matrixWritable2 = new MatrixWritable();    writeAndRead(matrixWritable, matrixWritable2);    Matrix m2 = matrixWritable2.get();    compareMatrices(m, m2);    doCheckBindings(m2.getRowLabelBindings());    doCheckBindings(m2.getColumnLabelBindings());}
d02d33e517bbe3d6548c7116cb7ec646a56e5d78aae566dbfcb86d224e3d6d55
compareMatrices
private static void compareMatrices(Matrix m, Matrix m2)
{    assertEquals(m.numRows(), m2.numRows());    assertEquals(m.numCols(), m2.numCols());    for (int r = 0; r < m.numRows(); r++) {        for (int c = 0; c < m.numCols(); c++) {            assertEquals(m.get(r, c), m2.get(r, c), EPSILON);        }    }    Map<String, Integer> bindings = m.getRowLabelBindings();    Map<String, Integer> bindings2 = m2.getRowLabelBindings();    assertEquals(bindings == null, bindings2 == null);    if (bindings != null) {        assertEquals(bindings.size(), m.numRows());        assertEquals(bindings.size(), bindings2.size());        for (Map.Entry<String, Integer> entry : bindings.entrySet()) {            assertEquals(entry.getValue(), bindings2.get(entry.getKey()));        }    }    bindings = m.getColumnLabelBindings();    bindings2 = m2.getColumnLabelBindings();    assertEquals(bindings == null, bindings2 == null);    if (bindings != null) {        assertEquals(bindings.size(), bindings2.size());        for (Map.Entry<String, Integer> entry : bindings.entrySet()) {            assertEquals(entry.getValue(), bindings2.get(entry.getKey()));        }    }}
707df75e70143d1906828618d4c83c563708da0754347717eb1bf112e9bb7a82
doCheckBindings
private static void doCheckBindings(Map<String, Integer> labels)
{    assertTrue("Missing label", labels.keySet().contains("A"));    assertTrue("Missing label", labels.keySet().contains("B"));    assertTrue("Missing label", labels.keySet().contains("C"));    assertTrue("Missing label", labels.keySet().contains("D"));    assertTrue("Missing label", labels.keySet().contains("default"));}
7398260d6fb7f330d46c79cb7dc9233e292aff8cb49c8ca7f00a0cba5c22abcf
writeAndRead
private static void writeAndRead(Writable toWrite, Writable toRead) throws IOException
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    DataOutputStream dos = new DataOutputStream(baos);    try {        toWrite.write(dos);    } finally {        Closeables.close(dos, false);    }    ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());    DataInputStream dis = new DataInputStream(bais);    try {        toRead.readFields(dis);    } finally {        Closeables.close(dis, true);    }}
729896a5d66c8bfd8bfb919e1d2082ca301ce6c0bf6990548235b7e140248ffa
testNormal
public void testNormal()
{    Matrix testData = new DenseMatrix(100000, 10);    final Normal gen = new Normal();    testData.assign(gen);    final EuclideanDistanceMeasure distance = new EuclideanDistanceMeasure();    BruteSearch ref = new BruteSearch(distance);    ref.addAllMatrixSlicesAsWeightedVectors(testData);    LocalitySensitiveHashSearch cut = new LocalitySensitiveHashSearch(distance, 10);    cut.addAllMatrixSlicesAsWeightedVectors(testData);    cut.setSearchSize(200);    cut.resetEvaluationCount();    System.out.printf("speedup,q1,q2,q3\n");    for (int i = 0; i < 12; i++) {        double strategy = (i - 1.0) / 10.0;        cut.setRaiseHashLimitStrategy(strategy);        OnlineSummarizer t1 = evaluateStrategy(testData, ref, cut);        int evals = cut.resetEvaluationCount();        final double speedup = 10.0e6 / evals;        System.out.printf("%.1f,%.2f,%.2f,%.2f\n", speedup, t1.getQuartile(1), t1.getQuartile(2), t1.getQuartile(3));        assertTrue(t1.getQuartile(2) > 0.45);        assertTrue(speedup > 4 || t1.getQuartile(2) > 0.9);        assertTrue(speedup > 15 || t1.getQuartile(2) > 0.8);    }}
676dcadff360caecdef2a8717bdf9976b77e8769330e8b1779704446c4494bcd
evaluateStrategy
private static OnlineSummarizer evaluateStrategy(Matrix testData, BruteSearch ref, LocalitySensitiveHashSearch cut)
{    OnlineSummarizer t1 = new OnlineSummarizer();    for (int i = 0; i < 100; i++) {        final Vector q = testData.viewRow(i);        List<WeightedThing<Vector>> v1 = cut.search(q, 150);        BitSet b1 = new BitSet();        for (WeightedThing<Vector> v : v1) {            b1.set(((WeightedVector) v.getValue()).getIndex());        }        List<WeightedThing<Vector>> v2 = ref.search(q, 100);        BitSet b2 = new BitSet();        for (WeightedThing<Vector> v : v2) {            b2.set(((WeightedVector) v.getValue()).getIndex());        }        b1.and(b2);        t1.add(b1.cardinality());    }    return t1;}
e600b82a6d2f3b28576967c459a7067451a5b5a6caeaae311088ba2d5d4de0be
testDotCorrelation
public void testDotCorrelation()
{    final Normal gen = new Normal();    Matrix projection = new DenseMatrix(64, 10);    projection.assign(gen);    Vector query = new DenseVector(10);    query.assign(gen);    long qhash = HashedVector.computeHash64(query, projection);    int[] count = new int[65];    Vector v = new DenseVector(10);    for (int i = 0; i < 500000; i++) {        v.assign(gen);        long hash = HashedVector.computeHash64(v, projection);        final int bitDot = Long.bitCount(qhash ^ hash);        count[bitDot]++;        if (count[bitDot] < 200) {            System.out.printf("%d, %.3f\n", bitDot, v.dot(query) / Math.sqrt(v.getLengthSquared() * query.getLengthSquared()));        }    }    for (int i = 0; i < 65; ++i) {        System.out.printf("%d, %d\n", i, count[i]);    }}
e0dc218cbb4735a11b9dec9b2fd60e43bf86a2be1abb620530da31020b87e954
lumpyRandomData
public static Matrix lumpyRandomData(int numDataPoints, int numDimensions)
{    final Matrix data = new DenseMatrix(numDataPoints, numDimensions);    final LumpyData clusters = new LumpyData(numDimensions, 0.05, 10);    for (MatrixSlice row : data) {        row.vector().assign(clusters.sample());    }    return data;}
e544fbe45bf40059e333137f664ed57440302379c709e95c09d77613782eb6fc
sample
public Vector sample()
{    int id = cluster.sample();    if (id >= centroids.size()) {                centroids.add(new MultiNormal(radius, centers.sample()));    }    return centroids.get(id).sample();}
8a304ebf89920547bacb4c045f35593ea3f8d3bd441b08b25802cafb1de6b512
generateData
public static List<Object[]> generateData()
{    RandomUtils.useTestSeed();    Matrix dataPoints = LumpyData.lumpyRandomData(NUM_DATA_POINTS, NUM_DIMENSIONS);    Matrix queries = LumpyData.lumpyRandomData(NUM_QUERIES, NUM_DIMENSIONS);    DistanceMeasure distanceMeasure = new CosineDistanceMeasure();    Searcher bruteSearcher = new BruteSearch(distanceMeasure);    bruteSearcher.addAll(dataPoints);    Pair<List<List<WeightedThing<Vector>>>, Long> reference = getResultsAndRuntime(bruteSearcher, queries);    Pair<List<WeightedThing<Vector>>, Long> referenceSearchFirst = getResultsAndRuntimeSearchFirst(bruteSearcher, queries);    double bruteSearchAvgTime = reference.getSecond() / (queries.numRows() * 1.0);    System.out.printf("BruteSearch: avg_time(1 query) %f[s]\n", bruteSearchAvgTime);    return Arrays.asList(new Object[][] {     { new ProjectionSearch(distanceMeasure, 3, 10), dataPoints, queries, reference, referenceSearchFirst }, { new FastProjectionSearch(distanceMeasure, 3, 10), dataPoints, queries, reference, referenceSearchFirst },     { new ProjectionSearch(distanceMeasure, 5, 5), dataPoints, queries, reference, referenceSearchFirst }, { new FastProjectionSearch(distanceMeasure, 5, 5), dataPoints, queries, reference, referenceSearchFirst } });}
4adf98bd8e7f40373d47297808fc0ac39e6224f79ca09fba8a0f5e1f46c9bafe
testOverlapAndRuntimeSearchFirst
public void testOverlapAndRuntimeSearchFirst()
{    searcher.clear();    searcher.addAll(dataPoints);    Pair<List<WeightedThing<Vector>>, Long> results = getResultsAndRuntimeSearchFirst(searcher, queries);    int numFirstMatches = 0;    for (int i = 0; i < queries.numRows(); ++i) {        WeightedThing<Vector> referenceVector = referenceSearchFirst.getFirst().get(i);        WeightedThing<Vector> resultVector = results.getFirst().get(i);        if (referenceVector.getValue().equals(resultVector.getValue())) {            ++numFirstMatches;        }    }    double bruteSearchAvgTime = reference.getSecond() / (queries.numRows() * 1.0);    double searcherAvgTime = results.getSecond() / (queries.numRows() * 1.0);    System.out.printf("%s: first matches %d [%d]; avg_time(1 query) %f(s) [%f]\n", searcher.getClass().getName(), numFirstMatches, queries.numRows(), searcherAvgTime, bruteSearchAvgTime);    assertEquals("Closest vector returned doesn't match", queries.numRows(), numFirstMatches);    assertTrue("Searcher " + searcher.getClass().getName() + " slower than brute", bruteSearchAvgTime > searcherAvgTime);}
609257e5e2ede05de083eb61507fd6693929973b9abfd7db219d02a55dd7ebed
testOverlapAndRuntime
public void testOverlapAndRuntime()
{    searcher.clear();    searcher.addAll(dataPoints);    Pair<List<List<WeightedThing<Vector>>>, Long> results = getResultsAndRuntime(searcher, queries);    int numFirstMatches = 0;    int numMatches = 0;    StripWeight stripWeight = new StripWeight();    for (int i = 0; i < queries.numRows(); ++i) {        List<WeightedThing<Vector>> referenceVectors = reference.getFirst().get(i);        List<WeightedThing<Vector>> resultVectors = results.getFirst().get(i);        if (referenceVectors.get(0).getValue().equals(resultVectors.get(0).getValue())) {            ++numFirstMatches;        }        for (Vector v : Iterables.transform(referenceVectors, stripWeight)) {            for (Vector w : Iterables.transform(resultVectors, stripWeight)) {                if (v.equals(w)) {                    ++numMatches;                }            }        }    }    double bruteSearchAvgTime = reference.getSecond() / (queries.numRows() * 1.0);    double searcherAvgTime = results.getSecond() / (queries.numRows() * 1.0);    System.out.printf("%s: first matches %d [%d]; total matches %d [%d]; avg_time(1 query) %f(s) [%f]\n", searcher.getClass().getName(), numFirstMatches, queries.numRows(), numMatches, queries.numRows() * NUM_RESULTS, searcherAvgTime, bruteSearchAvgTime);    assertEquals("Closest vector returned doesn't match", queries.numRows(), numFirstMatches);    assertTrue("Searcher " + searcher.getClass().getName() + " slower than brute", bruteSearchAvgTime > searcherAvgTime);}
2334fc122ffaa39eeb9db2822aa0a3bf86665305c6e3239d460b7342c766c7b7
getResultsAndRuntime
public static Pair<List<List<WeightedThing<Vector>>>, Long> getResultsAndRuntime(Searcher searcher, Iterable<? extends Vector> queries)
{    long start = System.currentTimeMillis();    List<List<WeightedThing<Vector>>> results = searcher.search(queries, NUM_RESULTS);    long end = System.currentTimeMillis();    return new Pair<>(results, end - start);}
f1fa9c69d98f974ea137b7a689a2a509e053baa045ad1d7302274aea89ee73e5
getResultsAndRuntimeSearchFirst
public static Pair<List<WeightedThing<Vector>>, Long> getResultsAndRuntimeSearchFirst(Searcher searcher, Iterable<? extends Vector> queries)
{    long start = System.currentTimeMillis();    List<WeightedThing<Vector>> results = searcher.searchFirst(queries, false);    long end = System.currentTimeMillis();    return new Pair<>(results, end - start);}
41b9dd77eac5de5ed2678bf8d7ee52141a55c7ed5e1be1745bdb7dfc9bf800d0
apply
public Vector apply(WeightedThing<Vector> input)
{    Preconditions.checkArgument(input != null, "input is null");        return input.getValue();}
bbda7781224c158a30bd57a1c16fa22f4f6320734d9164947eca72fb27972db6
multiNormalRandomData
protected static Matrix multiNormalRandomData(int numDataPoints, int numDimensions)
{    Matrix data = new DenseMatrix(numDataPoints, numDimensions);    MultiNormal gen = new MultiNormal(20);    for (MatrixSlice slice : data) {        slice.vector().assign(gen.sample());    }    return data;}
8a304ebf89920547bacb4c045f35593ea3f8d3bd441b08b25802cafb1de6b512
generateData
public static List<Object[]> generateData()
{    RandomUtils.useTestSeed();    Matrix dataPoints = multiNormalRandomData(NUM_DATA_POINTS, NUM_DIMENSIONS);    return Arrays.asList(new Object[][] { { new ProjectionSearch(new EuclideanDistanceMeasure(), NUM_PROJECTIONS, SEARCH_SIZE), dataPoints }, { new FastProjectionSearch(new EuclideanDistanceMeasure(), NUM_PROJECTIONS, SEARCH_SIZE), dataPoints }, { new LocalitySensitiveHashSearch(new EuclideanDistanceMeasure(), SEARCH_SIZE), dataPoints } });}
83e950e2f58c90bea8bf1b9161abef1b75e611b977a0b471b2700475e629e1c9
testExactMatch
public void testExactMatch()
{    searcher.clear();    Iterable<MatrixSlice> data = dataPoints;    final Iterable<MatrixSlice> batch1 = Iterables.limit(data, 300);    List<MatrixSlice> queries = Lists.newArrayList(Iterables.limit(batch1, 100));        searcher.addAllMatrixSlices(batch1);    assertEquals(300, searcher.size());    Vector q = Iterables.get(data, 0).vector();    List<WeightedThing<Vector>> r = searcher.search(q, 2);    assertEquals(0, r.get(0).getValue().minus(q).norm(1), 1.0e-8);    final Iterable<MatrixSlice> batch2 = Iterables.limit(Iterables.skip(data, 300), 10);    searcher.addAllMatrixSlices(batch2);    assertEquals(310, searcher.size());    q = Iterables.get(data, 302).vector();    r = searcher.search(q, 2);    assertEquals(0, r.get(0).getValue().minus(q).norm(1), 1.0e-8);    searcher.addAllMatrixSlices(Iterables.skip(data, 310));    assertEquals(dataPoints.numRows(), searcher.size());    for (MatrixSlice query : queries) {        r = searcher.search(query.vector(), 2);        assertEquals("Distance has to be about zero", 0, r.get(0).getWeight(), 1.0e-6);        assertEquals("Answer must be substantially the same as query", 0, r.get(0).getValue().minus(query.vector()).norm(1), 1.0e-8);        assertTrue("Wrong answer must have non-zero distance", r.get(1).getWeight() > r.get(0).getWeight());    }}
362923068be0930792506a2f40738e4cd5080d3ec41f259f80f80152f1a3b11f
testNearMatch
public void testNearMatch()
{    searcher.clear();    List<MatrixSlice> queries = Lists.newArrayList(Iterables.limit(dataPoints, 100));    searcher.addAllMatrixSlicesAsWeightedVectors(dataPoints);    MultiNormal noise = new MultiNormal(0.01, new DenseVector(20));    for (MatrixSlice slice : queries) {        Vector query = slice.vector();        final Vector epsilon = noise.sample();        List<WeightedThing<Vector>> r = searcher.search(query, 2);        query = query.plus(epsilon);        assertEquals("Distance has to be small", epsilon.norm(2), r.get(0).getWeight(), 1.0e-1);        assertEquals("Answer must be substantially the same as query", epsilon.norm(2), r.get(0).getValue().minus(query).norm(2), 1.0e-1);        assertTrue("Wrong answer must be further away", r.get(1).getWeight() > r.get(0).getWeight());    }}
f8b9ecb9a0e4d0d0af8efa843d5719427ee53e6c527bf295328237809eda0143
testOrdering
public void testOrdering()
{    searcher.clear();    Matrix queries = new DenseMatrix(100, 20);    MultiNormal gen = new MultiNormal(20);    for (int i = 0; i < 100; i++) {        queries.viewRow(i).assign(gen.sample());    }    searcher.addAllMatrixSlices(dataPoints);    for (MatrixSlice query : queries) {        List<WeightedThing<Vector>> r = searcher.search(query.vector(), 200);        double x = 0;        for (WeightedThing<Vector> thing : r) {            assertTrue("Scores must be monotonic increasing", thing.getWeight() >= x);            x = thing.getWeight();        }    }}
034c6f4418aca2332f89439d78e320ff363fb340de7f026a5f4cc768854b7114
testRemoval
public void testRemoval()
{    searcher.clear();    searcher.addAllMatrixSlices(dataPoints);        if (searcher instanceof UpdatableSearcher) {        List<Vector> x = Lists.newArrayList(Iterables.limit(searcher, 2));        int size0 = searcher.size();        List<WeightedThing<Vector>> r0 = searcher.search(x.get(0), 2);        searcher.remove(x.get(0), 1.0e-7);        assertEquals(size0 - 1, searcher.size());        List<WeightedThing<Vector>> r = searcher.search(x.get(0), 1);        assertTrue("Vector should be gone", r.get(0).getWeight() > 0);        assertEquals("Previous second neighbor should be first", 0, r.get(0).getValue().minus(r0.get(1).getValue()).norm(1), 1.0e-8);        searcher.remove(x.get(1), 1.0e-7);        assertEquals(size0 - 2, searcher.size());        r = searcher.search(x.get(1), 1);        assertTrue("Vector should be gone", r.get(0).getWeight() > 0);                for (Vector v : searcher) {            assertTrue(x.get(0).minus(v).norm(1) > 1.0e-6);            assertTrue(x.get(1).minus(v).norm(1) > 1.0e-6);        }    } else {        try {            List<Vector> x = Lists.newArrayList(Iterables.limit(searcher, 2));            searcher.remove(x.get(0), 1.0e-7);            fail("Shouldn't be able to delete from " + searcher.getClass().getName());        } catch (UnsupportedOperationException e) {                }    }}
acc39e3f6b7a6765401addd4958544e599d691b17cff88cb69f014aba1e4ec60
testSearchFirst
public void testSearchFirst()
{    searcher.clear();    searcher.addAll(dataPoints);    for (Vector datapoint : dataPoints) {        WeightedThing<Vector> first = searcher.searchFirst(datapoint, false);        WeightedThing<Vector> second = searcher.searchFirst(datapoint, true);        List<WeightedThing<Vector>> firstTwo = searcher.search(datapoint, 2);        assertEquals("First isn't self", 0, first.getWeight(), 0);        assertEquals("First isn't self", datapoint, first.getValue());        assertEquals("First doesn't match", first, firstTwo.get(0));        assertEquals("Second doesn't match", second, firstTwo.get(1));    }}
8d55c982de7a2509220f79eb55e46382b3d3698762ce34ddc6b7c4144af2e2f1
testSearchLimiting
public void testSearchLimiting()
{    searcher.clear();    searcher.addAll(dataPoints);    for (Vector datapoint : dataPoints) {        List<WeightedThing<Vector>> firstTwo = searcher.search(datapoint, 2);        assertThat("Search limit isn't respected", firstTwo.size(), is(lessThanOrEqualTo(2)));    }}
1fb42763547253cf7ffda7bc5ce98fdf5b96f7ca09e3b84b3ad86b00938441dc
testRemove
public void testRemove()
{    searcher.clear();    for (int i = 0; i < dataPoints.rowSize(); ++i) {        Vector datapoint = dataPoints.viewRow(i);        searcher.add(datapoint);                if (i % 2 == 0) {            assertTrue("Failed to find self [search]", searcher.search(datapoint, 1).get(0).getWeight() < Constants.EPSILON);            assertTrue("Failed to find self [searchFirst]", searcher.searchFirst(datapoint, false).getWeight() < Constants.EPSILON);            assertTrue("Failed to remove self", searcher.remove(datapoint, Constants.EPSILON));        }    }}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    super.setUp();    tmpDir = getTestTempDir("matrix");}
74e70df2842928fa7d3142d1d8b08941c0178db1c9a8e0b061e8255c4c576614
testSingularValues
public void testSingularValues() throws IOException
{    Matrix A = lowRankMatrix(tmpDir, "A", 200, 970, 1020);    List<File> partsOfA = Arrays.asList(tmpDir.listFiles(new FilenameFilter() {        @Override        public boolean accept(File file, String fileName) {            return fileName.matches("A-.*");        }    }));        partsOfA = Lists.reverse(partsOfA);    SequentialOutOfCoreSvd s = new SequentialOutOfCoreSvd(partsOfA, tmpDir, 100, 210);    SequentialBigSvd svd = new SequentialBigSvd(A, 100);    Vector reference = new DenseVector(svd.getSingularValues()).viewPart(0, 6);    Vector actual = s.getSingularValues().viewPart(0, 6);    assertEquals(0, reference.minus(actual).maxValue(), 1.0e-9);    s.computeU(partsOfA, tmpDir);    Matrix u = readBlockMatrix(Arrays.asList(tmpDir.listFiles(new FilenameFilter() {        @Override        public boolean accept(File file, String fileName) {            return fileName.matches("U-.*");        }    })));    s.computeV(tmpDir, A.columnSize());    Matrix v = readBlockMatrix(Arrays.asList(tmpDir.listFiles(new FilenameFilter() {        @Override        public boolean accept(File file, String fileName) {            return fileName.matches("V-.*");        }    })));        assertEquals(0, A.minus(u.times(new DiagonalMatrix(s.getSingularValues())).times(v.transpose())).aggregate(Functions.PLUS, Functions.ABS), 1.0e-7);}
fb07c1cbd1265deb83c3f082dbab3c5aa43b9719e325670183e8af5f3046e775
accept
public boolean accept(File file, String fileName)
{    return fileName.matches("A-.*");}
fb07c1cbd1265deb83c3f082dbab3c5aa43b9719e325670183e8af5f3046e775
accept
public boolean accept(File file, String fileName)
{    return fileName.matches("U-.*");}
fb07c1cbd1265deb83c3f082dbab3c5aa43b9719e325670183e8af5f3046e775
accept
public boolean accept(File file, String fileName)
{    return fileName.matches("V-.*");}
2034d19cc620fb9bebf292b0946fb9c097de28bd90728ecff1334733817cb124
readBlockMatrix
private static Matrix readBlockMatrix(List<File> files) throws IOException
{        Collections.sort(files);        int nrows = -1;    int ncols = -1;    Matrix r = null;    MatrixWritable m = new MatrixWritable();    int row = 0;    for (File file : files) {        DataInputStream in = new DataInputStream(new FileInputStream(file));        m.readFields(in);        in.close();        if (nrows == -1) {                        nrows = m.get().rowSize() * files.size();            ncols = m.get().columnSize();            r = new DenseMatrix(nrows, ncols);        }        r.viewPart(row, m.get().rowSize(), 0, r.columnSize()).assign(m.get());        row += m.get().rowSize();    }        if (row != nrows && r != null) {                r = r.viewPart(0, row, 0, ncols);    }    return r;}
dc0def50a58070ce9f553b39d544d55b9af976120245501ea82d206336f5c0a9
testLeftVectors
public void testLeftVectors() throws IOException
{    Matrix A = lowRankMatrixInMemory(20, 20);    SequentialBigSvd s = new SequentialBigSvd(A, 6);    SingularValueDecomposition svd = new SingularValueDecomposition(A);        Matrix u1 = svd.getU().viewPart(0, 20, 0, 3).assign(Functions.ABS);    Matrix u2 = s.getU().viewPart(0, 20, 0, 3).assign(Functions.ABS);    assertEquals(u1, u2);}
a5e2923e6ec4c6f43089f32405dbe6006c2ae5c125db976a4543acbde3bd1fc5
lowRankMatrixInMemory
private static Matrix lowRankMatrixInMemory(int rows, int columns) throws IOException
{    return lowRankMatrix(null, null, 0, rows, columns);}
1deab674d6b17b8c07f5684aae2564bfab75587340c4253efcc115030243e0d7
assertEquals
private static void assertEquals(Matrix u1, Matrix u2)
{    assertEquals(0.0, u1.minus(u2).aggregate(Functions.MAX, Functions.ABS), 1.0e-10);}
fc00c64413fcbc8d7b64800bab6207555fb4c7d4a7ac02bc5cf33d103c2f52b6
testRightVectors
public void testRightVectors() throws IOException
{    Matrix A = lowRankMatrixInMemory(20, 20);    SequentialBigSvd s = new SequentialBigSvd(A, 6);    SingularValueDecomposition svd = new SingularValueDecomposition(A);    Matrix v1 = svd.getV().viewPart(0, 20, 0, 3).assign(Functions.ABS);    Matrix v2 = s.getV().viewPart(0, 20, 0, 3).assign(Functions.ABS);    assertEquals(v1, v2);}
7536a8623589ff416bd88d4eeb258d64ae56b40dcd7dfa3353f7e040f70e2d53
lowRankMatrix
private static Matrix lowRankMatrix(File tmpDir, String aBase, int rowsPerSlice, int rows, int columns) throws IOException
{    int rank = 10;    Matrix u = new RandomTrinaryMatrix(1, rows, rank, false);    Matrix d = new DenseMatrix(rank, rank);    d.set(0, 0, 5);    d.set(1, 1, 3);    d.set(2, 2, 1);    d.set(3, 3, 0.5);    Matrix v = new RandomTrinaryMatrix(2, columns, rank, false);    Matrix a = u.times(d).times(v.transpose());    if (tmpDir != null) {        for (int i = 0; i < a.rowSize(); i += rowsPerSlice) {            MatrixWritable m = new MatrixWritable(a.viewPart(i, Math.min(a.rowSize() - i, rowsPerSlice), 0, a.columnSize()));            DataOutputStream out = new DataOutputStream(new FileOutputStream(new File(tmpDir, String.format("%s-%09d", aBase, i))));            try {                m.write(out);            } finally {                out.close();            }        }    }    return a;}
6eb08308a6b1baecea46c516e15d44a32c82514bebf22cf41d2b989bc5932d48
testBinaryCase
public void testBinaryCase()
{    Random gen = RandomUtils.getRandom();    OnlineSummarizer[] stats = new OnlineSummarizer[4];    for (int i = 0; i < 4; i++) {        stats[i] = new OnlineSummarizer();    }    for (int i = 0; i < 100; i++) {        OnlineAuc a1 = new GlobalOnlineAuc();        a1.setPolicy(GlobalOnlineAuc.ReplacementPolicy.FAIR);        OnlineAuc a2 = new GlobalOnlineAuc();        a2.setPolicy(GlobalOnlineAuc.ReplacementPolicy.FIFO);        OnlineAuc a3 = new GlobalOnlineAuc();        a3.setPolicy(GlobalOnlineAuc.ReplacementPolicy.RANDOM);        Auc a4 = new Auc();        for (int j = 0; j < 10000; j++) {            double x = gen.nextGaussian();            a1.addSample(0, x);            a2.addSample(0, x);            a3.addSample(0, x);            a4.add(0, x);            x = gen.nextGaussian() + 1;            a1.addSample(1, x);            a2.addSample(1, x);            a3.addSample(1, x);            a4.add(1, x);        }        stats[0].add(a1.auc());        stats[1].add(a2.auc());        stats[2].add(a3.auc());        stats[3].add(a4.auc());    }    int i = 0;    for (GlobalOnlineAuc.ReplacementPolicy policy : new GlobalOnlineAuc.ReplacementPolicy[] { GlobalOnlineAuc.ReplacementPolicy.FAIR, GlobalOnlineAuc.ReplacementPolicy.FIFO, GlobalOnlineAuc.ReplacementPolicy.RANDOM, null }) {        OnlineSummarizer summary = stats[i++];        System.out.printf("%s,%.4f (min = %.4f, 25%%-ile=%.4f, 75%%-ile=%.4f, max=%.4f)\n", policy, summary.getMean(), summary.getQuartile(0), summary.getQuartile(1), summary.getQuartile(2), summary.getQuartile(3));    }        assertEquals(0.7603, stats[0].getMean(), 0.03);    assertEquals(0.7603, stats[0].getQuartile(1), 0.03);    assertEquals(0.7603, stats[0].getQuartile(3), 0.03);        assertEquals(0.7603, stats[1].getMean(), 0.001);    assertEquals(0.7603, stats[1].getQuartile(1), 0.006);    assertEquals(0.7603, stats[1].getQuartile(3), 0.006);        assertEquals(0.7603, stats[2].getMean(), 0.001);    assertEquals(0.7603, stats[2].getQuartile(1), 0.006);    assertEquals(0.7603, stats[2].getQuartile(1), 0.006);}
8c3e954197f6cf4fa32e6e6e2f911092402c3395a899101266c9aaba36011828
mustNotOmitGroup
public void mustNotOmitGroup()
{    OnlineAuc x = new GroupedOnlineAuc();    x.addSample(0, 3.14);}
474a4cd0d6ce50799d55eb3def07e47092c3a4dfa04fc9a3f1dabf432d8c870e
groupedAuc
public void groupedAuc()
{    Random gen = RandomUtils.getRandom();    OnlineAuc x = new GroupedOnlineAuc();    OnlineAuc y = new GlobalOnlineAuc();    for (int i = 0; i < 10000; i++) {        x.addSample(0, "a", gen.nextGaussian());        x.addSample(1, "a", gen.nextGaussian() + 1);        x.addSample(0, "b", gen.nextGaussian() + 10);        x.addSample(1, "b", gen.nextGaussian() + 11);        y.addSample(0, "a", gen.nextGaussian());        y.addSample(1, "a", gen.nextGaussian() + 1);        y.addSample(0, "b", gen.nextGaussian() + 10);        y.addSample(1, "b", gen.nextGaussian() + 11);    }    assertEquals(0.7603, x.auc(), 0.01);    assertEquals((0.7603 + 0.5) / 2, y.auc(), 0.02);}
5f466323d6e58b5276511a5d144eeb75042bff1437300cc9961e8359f112d0d4
testDiscreteSampler
public void testDiscreteSampler()
{    Vector distribution = new DenseVector(new double[] { 1, 0, 2, 3, 5, 0 });    Sampler sampler = new Sampler(RandomUtils.getRandom(), distribution);    Vector sampledDistribution = distribution.like();    int i = 0;    while (i < 100000) {        int index = sampler.sample();        sampledDistribution.set(index, sampledDistribution.get(index) + 1);        i++;    }    assertTrue("sampled distribution is far from the original", l1Dist(distribution, sampledDistribution) < 1.0e-2);}
4fdbc9deffe51c9086d14d6bd76e463801b25f18ed3e0ac9cdc40897d6fe8da2
l1Dist
private static double l1Dist(Vector v, Vector w)
{    return v.normalize(1.0).minus(w.normalize(1)).norm(1.0);}
de5a261e1e0a6c3499d2dacb6f0b497b0f4d5ba069341b9672b37c5d5f7d5c49
testUnsignedLong
public void testUnsignedLong() throws Exception
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    DataOutput out = new DataOutputStream(baos);    Varint.writeUnsignedVarLong(0L, out);    for (long i = 1L; i > 0L && i <= (1L << 62); i <<= 1) {        Varint.writeUnsignedVarLong(i - 1, out);        Varint.writeUnsignedVarLong(i, out);    }    Varint.writeUnsignedVarLong(Long.MAX_VALUE, out);    DataInput in = new DataInputStream(new ByteArrayInputStream(baos.toByteArray()));    assertEquals(0L, Varint.readUnsignedVarLong(in));    for (long i = 1L; i > 0L && i <= (1L << 62); i <<= 1) {        assertEquals(i - 1, Varint.readUnsignedVarLong(in));        assertEquals(i, Varint.readUnsignedVarLong(in));    }    assertEquals(Long.MAX_VALUE, Varint.readUnsignedVarLong(in));}
e4fb4f4a5160ab1381621e347a03aea9bb02c32933772ae0fadc45d05cac65ab
testSignedPositiveLong
public void testSignedPositiveLong() throws Exception
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    DataOutput out = new DataOutputStream(baos);    Varint.writeSignedVarLong(0L, out);    for (long i = 1L; i <= (1L << 61); i <<= 1) {        Varint.writeSignedVarLong(i - 1, out);        Varint.writeSignedVarLong(i, out);    }    Varint.writeSignedVarLong((1L << 62) - 1, out);    Varint.writeSignedVarLong((1L << 62), out);    Varint.writeSignedVarLong(Long.MAX_VALUE, out);    DataInput in = new DataInputStream(new ByteArrayInputStream(baos.toByteArray()));    assertEquals(0L, Varint.readSignedVarLong(in));    for (long i = 1L; i <= (1L << 61); i <<= 1) {        assertEquals(i - 1, Varint.readSignedVarLong(in));        assertEquals(i, Varint.readSignedVarLong(in));    }    assertEquals((1L << 62) - 1, Varint.readSignedVarLong(in));    assertEquals((1L << 62), Varint.readSignedVarLong(in));    assertEquals(Long.MAX_VALUE, Varint.readSignedVarLong(in));}
a2769ce83ecdeaf43cb42c6eca90bfdce3d763b6e95cb08056dd551c9fcc4aa9
testSignedNegativeLong
public void testSignedNegativeLong() throws Exception
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    DataOutput out = new DataOutputStream(baos);    for (long i = -1L; i >= -(1L << 62); i <<= 1) {        Varint.writeSignedVarLong(i, out);        Varint.writeSignedVarLong(i + 1, out);    }    Varint.writeSignedVarLong(Long.MIN_VALUE, out);    Varint.writeSignedVarLong(Long.MIN_VALUE + 1, out);    DataInput in = new DataInputStream(new ByteArrayInputStream(baos.toByteArray()));    for (long i = -1L; i >= -(1L << 62); i <<= 1) {        assertEquals(i, Varint.readSignedVarLong(in));        assertEquals(i + 1, Varint.readSignedVarLong(in));    }    assertEquals(Long.MIN_VALUE, Varint.readSignedVarLong(in));    assertEquals(Long.MIN_VALUE + 1, Varint.readSignedVarLong(in));}
3569d8c819ee2dc878202a712efaa2f1f7e6bab5859c069eb263fb1a06471a18
testUnsignedInt
public void testUnsignedInt() throws Exception
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    DataOutput out = new DataOutputStream(baos);    Varint.writeUnsignedVarInt(0, out);    for (int i = 1; i > 0 && i <= (1 << 30); i <<= 1) {        Varint.writeUnsignedVarLong(i - 1, out);        Varint.writeUnsignedVarLong(i, out);    }    Varint.writeUnsignedVarLong(Integer.MAX_VALUE, out);    DataInput in = new DataInputStream(new ByteArrayInputStream(baos.toByteArray()));    assertEquals(0, Varint.readUnsignedVarInt(in));    for (int i = 1; i > 0 && i <= (1 << 30); i <<= 1) {        assertEquals(i - 1, Varint.readUnsignedVarInt(in));        assertEquals(i, Varint.readUnsignedVarInt(in));    }    assertEquals(Integer.MAX_VALUE, Varint.readUnsignedVarInt(in));}
8bd0fcd1b10b2df9784c850f5db1980ba44990504edb334cf0c0c8a1a3786124
testSignedPositiveInt
public void testSignedPositiveInt() throws Exception
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    DataOutput out = new DataOutputStream(baos);    Varint.writeSignedVarInt(0, out);    for (int i = 1; i <= (1 << 29); i <<= 1) {        Varint.writeSignedVarLong(i - 1, out);        Varint.writeSignedVarLong(i, out);    }    Varint.writeSignedVarInt((1 << 30) - 1, out);    Varint.writeSignedVarInt((1 << 30), out);    Varint.writeSignedVarInt(Integer.MAX_VALUE, out);    DataInput in = new DataInputStream(new ByteArrayInputStream(baos.toByteArray()));    assertEquals(0, Varint.readSignedVarInt(in));    for (int i = 1; i <= (1 << 29); i <<= 1) {        assertEquals(i - 1, Varint.readSignedVarInt(in));        assertEquals(i, Varint.readSignedVarInt(in));    }    assertEquals((1L << 30) - 1, Varint.readSignedVarInt(in));    assertEquals((1L << 30), Varint.readSignedVarInt(in));    assertEquals(Integer.MAX_VALUE, Varint.readSignedVarInt(in));}
f5a16f0bef1de09c0e66683c868ea776187ce25533429e09222c2a2122eb9a66
testSignedNegativeInt
public void testSignedNegativeInt() throws Exception
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    DataOutput out = new DataOutputStream(baos);    for (int i = -1; i >= -(1 << 30); i <<= 1) {        Varint.writeSignedVarInt(i, out);        Varint.writeSignedVarInt(i + 1, out);    }    Varint.writeSignedVarInt(Integer.MIN_VALUE, out);    Varint.writeSignedVarInt(Integer.MIN_VALUE + 1, out);    DataInput in = new DataInputStream(new ByteArrayInputStream(baos.toByteArray()));    for (int i = -1; i >= -(1 << 30); i <<= 1) {        assertEquals(i, Varint.readSignedVarInt(in));        assertEquals(i + 1, Varint.readSignedVarInt(in));    }    assertEquals(Integer.MIN_VALUE, Varint.readSignedVarInt(in));    assertEquals(Integer.MIN_VALUE + 1, Varint.readSignedVarInt(in));}
31a85a0639786f5fa4f54eb6ddcde26b6019c671e327d98d382f16acf7983b8b
testUnsignedSize
public void testUnsignedSize() throws Exception
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    DataOutput out = new DataOutputStream(baos);    int expectedSize = 0;    for (int exponent = 0; exponent <= 62; exponent++) {        Varint.writeUnsignedVarLong(1L << exponent, out);        expectedSize += 1 + exponent / 7;        assertEquals(expectedSize, baos.size());    }}
037bcaa950a641523c2a555f2dc16e989bfe93fae7dc2b0ee8facc5cbc58eb4b
testSignedSize
public void testSignedSize() throws Exception
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    DataOutput out = new DataOutputStream(baos);    int expectedSize = 0;    for (int exponent = 0; exponent <= 61; exponent++) {        Varint.writeSignedVarLong(1L << exponent, out);        expectedSize += 1 + ((exponent + 1) / 7);        assertEquals(expectedSize, baos.size());    }    for (int exponent = 0; exponent <= 61; exponent++) {        Varint.writeSignedVarLong(-(1L << exponent) - 1, out);        expectedSize += 1 + ((exponent + 1) / 7);        assertEquals(expectedSize, baos.size());    }}
208cfb9a29623f2baf0c8da12ed591ee286fe6278baa33caf66bbc6ce26473a9
createRandom
public void createRandom(Vector v)
{    int size = randomInt(v.size() - 1);    for (int i = 0; i < size; ++i) {        v.set(randomInt(v.size() - 1), randomDouble());    }    int zeros = Math.max(2, size / 4);    for (Element e : v.nonZeroes()) {        if (e.index() % zeros == 0) {            e.set(0.0);        }    }}
a1367adfe853ddcd8f629eed1be7ef6766a47ad5901ba4c6124670667347e29c
testViewSequentialAccessSparseVectorWritable
public void testViewSequentialAccessSparseVectorWritable() throws Exception
{    Vector v = new SequentialAccessSparseVector(MAX_VECTOR_SIZE);    createRandom(v);    Vector view = new VectorView(v, 0, v.size());    doTestVectorWritableEquals(view);}
532803ff17c895aa70cdebda66de6714df4edcec4a128ec5ce6a71d53bdcd6f5
testSequentialAccessSparseVectorWritable
public void testSequentialAccessSparseVectorWritable() throws Exception
{    Vector v = new SequentialAccessSparseVector(MAX_VECTOR_SIZE);    createRandom(v);    doTestVectorWritableEquals(v);}
fe4d7b8d508a49013149f3698148f86131be3ccb55ad8848ce4940cb1f21b7a2
testRandomAccessSparseVectorWritable
public void testRandomAccessSparseVectorWritable() throws Exception
{    Vector v = new RandomAccessSparseVector(MAX_VECTOR_SIZE);    createRandom(v);    doTestVectorWritableEquals(v);}
9d6a96ce838d362620662f8981016caf374840899e498bb1ea475710c5036de3
testDenseVectorWritable
public void testDenseVectorWritable() throws Exception
{    Vector v = new DenseVector(MAX_VECTOR_SIZE);    createRandom(v);    doTestVectorWritableEquals(v);}
b9519a00fd346657be70609d4dd80d470d64226ccc65bb2dde3e4b528331e594
testNamedVectorWritable
public void testNamedVectorWritable() throws Exception
{    Vector v = new DenseVector(MAX_VECTOR_SIZE);    v = new NamedVector(v, "Victor");    createRandom(v);    doTestVectorWritableEquals(v);}
953903057f1e392962010a2b967c6c7d33b718d077b8280edd629338834e7440
doTestVectorWritableEquals
private static void doTestVectorWritableEquals(Vector v) throws IOException
{    Writable vectorWritable = new VectorWritable(v);    VectorWritable vectorWritable2 = new VectorWritable();    writeAndRead(vectorWritable, vectorWritable2);    Vector v2 = vectorWritable2.get();    if (v instanceof NamedVector) {        assertTrue(v2 instanceof NamedVector);        NamedVector nv = (NamedVector) v;        NamedVector nv2 = (NamedVector) v2;        assertEquals(nv.getName(), nv2.getName());        assertEquals("Victor", nv.getName());    }    assertEquals(v, v2);}
7398260d6fb7f330d46c79cb7dc9233e292aff8cb49c8ca7f00a0cba5c22abcf
writeAndRead
private static void writeAndRead(Writable toWrite, Writable toRead) throws IOException
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    DataOutputStream dos = new DataOutputStream(baos);    try {        toWrite.write(dos);    } finally {        Closeables.close(dos, false);    }    ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());    DataInputStream dis = new DataInputStream(bais);    try {        toRead.readFields(dis);    } finally {        Closeables.close(dos, true);    }}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    super.setUp();    counter = EasyMock.createMock(Counter.class);    context = EasyMock.createMock(Context.class);}
68d3978ab3f3a95f1c84276049e76716ce77d5f220c18dd90d945a0b43de719c
testCollectNgrams
public void testCollectNgrams() throws Exception
{    Text key = new Text();    key.set("dummy-key");    String[] input = { "the", "best", "of", "times", "the", "worst", "of", "times" };    StringTuple inputTuple = new StringTuple();    for (String i : input) {        inputTuple.add(i);    }    String[][] values = { { "h_the", "the best" }, { "t_best", "the best" }, { "h_of", "of times" }, { "t_times", "of times" }, { "h_best", "best of" }, { "t_of", "best of" }, { "h_the", "the worst" }, { "t_worst", "the worst" }, { "h_times", "times the" }, { "t_the", "times the" }, { "h_worst", "worst of" }, { "t_of", "worst of" } };        Configuration conf = getConfiguration();    conf.set(CollocMapper.MAX_SHINGLE_SIZE, "2");    EasyMock.expect(context.getConfiguration()).andReturn(conf);    for (String[] v : values) {        Type p = v[0].startsWith("h") ? Gram.Type.HEAD : Gram.Type.TAIL;        int frequency = 1;        if ("of times".equals(v[1])) {            frequency = 2;        }        Gram subgram = new Gram(v[0].substring(2), frequency, p);        Gram ngram = new Gram(v[1], frequency, Gram.Type.NGRAM);        GramKey subgramKey = new GramKey(subgram, new byte[0]);        GramKey subgramNgramKey = new GramKey(subgram, ngram.getBytes());        context.write(subgramKey, subgram);        context.write(subgramNgramKey, ngram);    }    EasyMock.expect(context.getCounter(CollocMapper.Count.NGRAM_TOTAL)).andReturn(counter);    counter.increment(7);    EasyMock.replay(context, counter);    CollocMapper c = new CollocMapper();    c.setup(context);    c.map(key, inputTuple, context);    EasyMock.verify(context);}
65a43bc7fba7d214203a9b47fcfeb20fc0f0875a2b94b91ec571f9d0b92ee679
testCollectNgramsWithUnigrams
public void testCollectNgramsWithUnigrams() throws Exception
{    Text key = new Text();    key.set("dummy-key");    String[] input = { "the", "best", "of", "times", "the", "worst", "of", "times" };    StringTuple inputTuple = new StringTuple();    for (String i : input) {        inputTuple.add(i);    }    String[][] values = { { "h_the", "the best" }, { "t_best", "the best" }, { "h_of", "of times" }, { "t_times", "of times" }, { "h_best", "best of" }, { "t_of", "best of" }, { "h_the", "the worst" }, { "t_worst", "the worst" }, { "h_times", "times the" }, { "t_the", "times the" }, { "h_worst", "worst of" }, { "t_of", "worst of" }, { "u_worst", "worst" }, { "u_of", "of" }, { "u_the", "the" }, { "u_best", "best" }, { "u_times", "times" } };        Configuration conf = getConfiguration();    conf.set(CollocMapper.MAX_SHINGLE_SIZE, "2");    conf.setBoolean(CollocDriver.EMIT_UNIGRAMS, true);    EasyMock.expect(context.getConfiguration()).andReturn(conf);    for (String[] v : values) {        Type p = v[0].startsWith("h") ? Gram.Type.HEAD : Gram.Type.TAIL;        p = v[0].startsWith("u") ? Gram.Type.UNIGRAM : p;        int frequency = 1;        if ("of times".equals(v[1]) || "of".equals(v[1]) || "times".equals(v[1]) || "the".equals(v[1])) {            frequency = 2;        }        if (p == Gram.Type.UNIGRAM) {            Gram unigram = new Gram(v[1], frequency, Gram.Type.UNIGRAM);            GramKey unigramKey = new GramKey(unigram, new byte[0]);            context.write(unigramKey, unigram);        } else {            Gram subgram = new Gram(v[0].substring(2), frequency, p);            Gram ngram = new Gram(v[1], frequency, Gram.Type.NGRAM);            GramKey subgramKey = new GramKey(subgram, new byte[0]);            GramKey subgramNgramKey = new GramKey(subgram, ngram.getBytes());            context.write(subgramKey, subgram);            context.write(subgramNgramKey, ngram);        }    }    EasyMock.expect(context.getCounter(CollocMapper.Count.NGRAM_TOTAL)).andReturn(counter);    counter.increment(7);    EasyMock.replay(context, counter);    CollocMapper c = new CollocMapper();    c.setup(context);    c.map(key, inputTuple, context);    EasyMock.verify(context);}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    super.setUp();    context = EasyMock.createMock(Context.class);}
011dec308a3e61e4f9e1df886b56833ee99b3a04eabe4f9ae2bd1b5a58e9ed5c
testReduce
public void testReduce() throws Exception
{                Gram[][] input = { { new Gram("the", Gram.Type.UNIGRAM), new Gram("the", Gram.Type.UNIGRAM), new Gram("the", Gram.Type.UNIGRAM) }, { new Gram("the", Gram.Type.HEAD), new Gram("the best", Gram.Type.NGRAM), new Gram("the worst", Gram.Type.NGRAM) }, { new Gram("of", Gram.Type.HEAD), new Gram("of times", Gram.Type.NGRAM), new Gram("of times", Gram.Type.NGRAM) }, { new Gram("times", Gram.Type.TAIL), new Gram("of times", Gram.Type.NGRAM), new Gram("of times", Gram.Type.NGRAM) } };        Gram[][] values = { { new Gram("the", 2, Gram.Type.UNIGRAM), new Gram("the", 2, Gram.Type.UNIGRAM) }, { new Gram("the best", 1, Gram.Type.NGRAM), new Gram("the", 2, Gram.Type.HEAD) }, { new Gram("the worst", 1, Gram.Type.NGRAM), new Gram("the", 2, Gram.Type.HEAD) }, { new Gram("of times", 2, Gram.Type.NGRAM), new Gram("of", 2, Gram.Type.HEAD) }, { new Gram("of times", 2, Gram.Type.NGRAM), new Gram("times", 2, Gram.Type.TAIL) } };        for (Gram[] v : values) {        context.write(v[0], v[1]);    }    EasyMock.replay(context);        CollocReducer c = new CollocReducer();    GramKey key = new GramKey();    byte[] empty = new byte[0];    for (Gram[] ii : input) {        key.set(ii[0], empty);        Collection<Gram> vv = Lists.newLinkedList();        vv.addAll(Arrays.asList(ii));        c.reduce(key, vv, context);    }    EasyMock.verify(context);}
51bea49d56e2e4117743f2887a3529fdffa845ed48e0e677b692648ec4992659
testComparator
public void testComparator()
{    byte[] foo = new byte[1];    foo[0] = 1;    byte[] empty = new byte[0];        GramKey a = new GramKey(new Gram("foo", 1, Gram.Type.HEAD), empty);        GramKey b = new GramKey(new Gram("foo", 1, Gram.Type.HEAD), foo);        GramKey c = new GramKey(new Gram("foo", 2, Gram.Type.HEAD), empty);        GramKey d = new GramKey(new Gram("foo", 1, Gram.Type.TAIL), empty);        GramKey e = new GramKey(new Gram("bar", 5, Gram.Type.HEAD), empty);    GramKeyGroupComparator cmp = new GramKeyGroupComparator();    assertEquals(0, cmp.compare(a, b));    assertEquals(0, cmp.compare(a, c));    assertTrue(cmp.compare(a, d) < 0);    assertTrue(cmp.compare(a, e) > 0);    assertTrue(cmp.compare(d, e) > 0);}
c1dd189687135a5f116ff2b3510ccacbec8afa7796a0dc4e337fa4559297bb7c
testPartition
public void testPartition()
{    byte[] foo = new byte[1];    foo[0] = 1;    foo[0] = 2;    byte[] empty = new byte[0];    GramKey a = new GramKey(new Gram("foo", 1, Gram.Type.HEAD), empty);    GramKey b = new GramKey(new Gram("foo", 1, Gram.Type.HEAD), foo);    byte[] bar = new byte[1];    GramKey c = new GramKey(new Gram("foo", 2, Gram.Type.HEAD), bar);    GramKey d = new GramKey(new Gram("foo", 1, Gram.Type.TAIL), empty);    GramKey e = new GramKey(new Gram("foo", 2, Gram.Type.TAIL), foo);    Partitioner<GramKey, Gram> p = new GramKeyPartitioner();    int numPartitions = 5;    int ap = p.getPartition(a, null, numPartitions);    int bp = p.getPartition(b, null, numPartitions);    int cp = p.getPartition(c, null, numPartitions);    int dp = p.getPartition(d, null, numPartitions);    int ep = p.getPartition(e, null, numPartitions);    assertEquals(ap, bp);    assertEquals(ap, cp);    assertEquals(dp, ep);}
f3848b1efc94aefc5672213f695aea3b8cfa3cc950a2e12d075d79d5d0143104
testGramKeySort
public void testGramKeySort()
{    byte[] foo = { 1 };            byte[] empty = new byte[0];    GramKey[] input = { new GramKey(new Gram("bar", 1, Gram.Type.UNIGRAM), empty), new GramKey(new Gram("bar", 1, Gram.Type.UNIGRAM), empty), new GramKey(new Gram("bar", 1, Gram.Type.UNIGRAM), foo), new GramKey(new Gram("bar", 8, Gram.Type.NGRAM), foo), new GramKey(new Gram("bar", 8, Gram.Type.NGRAM), empty), new GramKey(new Gram("foo", 2, Gram.Type.HEAD), foo), new GramKey(new Gram("foo", 3, Gram.Type.HEAD), empty), new GramKey(new Gram("foo", 4, Gram.Type.TAIL), foo), new GramKey(new Gram("foo", 5, Gram.Type.TAIL), foo), new GramKey(new Gram("bar", 6, Gram.Type.HEAD), foo), new GramKey(new Gram("bar", 7, Gram.Type.TAIL), empty) };    int[] expect = { 9, 6, 5, 10, 7, 8, 0, 1, 2, 4, 3 };    GramKey[] sorted = new GramKey[input.length];    System.arraycopy(input, 0, sorted, 0, input.length);    Arrays.sort(sorted);    for (int i = 0; i < input.length; i++) {        assertSame(input[expect[i]], sorted[i]);    }}
b760e783ced6d893c14245aa0647446f3eeb86c234d9ba85669ea1a19703381f
testWritable
public void testWritable() throws Exception
{    byte[] foo = new byte[0];    byte[] bar = { 2 };    GramKey one = new GramKey(new Gram("foo", 2, Gram.Type.HEAD), foo);    GramKey two = new GramKey(new Gram("foobar", 3, Gram.Type.UNIGRAM), bar);    assertEquals("foo", one.getPrimaryString());    assertEquals("foobar", two.getPrimaryString());    assertEquals(Gram.Type.UNIGRAM, two.getType());    ByteArrayOutputStream bout = new ByteArrayOutputStream();    DataOutputStream out = new DataOutputStream(bout);    try {        two.write(out);    } finally {        Closeables.close(out, false);    }    byte[] b = bout.toByteArray();    ByteArrayInputStream bin = new ByteArrayInputStream(b);    DataInputStream din = new DataInputStream(bin);    try {        one.readFields(din);    } finally {        Closeables.close(din, true);    }    assertTrue(Arrays.equals(two.getBytes(), one.getBytes()));    assertEquals(Gram.Type.UNIGRAM, one.getType());}
7a37558e6dc1463896de1b7e26920a7e995e4c83be15a48d194f6076c5c32198
testConstructorsGetters
public void testConstructorsGetters()
{    Gram one = new Gram("foo", 2, Gram.Type.HEAD);    assertEquals("foo", one.getString());    assertEquals(2, one.getFrequency());    assertEquals(Gram.Type.HEAD, one.getType());    Gram oneClone = new Gram(one);    assertEquals("foo", oneClone.getString());    assertEquals(2, oneClone.getFrequency());    assertEquals(Gram.Type.HEAD, oneClone.getType());    Gram two = new Gram("foo", 3, Gram.Type.TAIL);    assertEquals(Gram.Type.TAIL, two.getType());    Gram three = new Gram("foo", 4, Gram.Type.UNIGRAM);    assertEquals(Gram.Type.UNIGRAM, three.getType());    Gram four = new Gram("foo", 5, Gram.Type.NGRAM);    assertEquals(Gram.Type.NGRAM, four.getType());}
974d802d835f879e93a2acb6c1f343619dca71743b8f4388bbe5cfce31a60102
testNull1
public void testNull1()
{    new Gram(null, 4, Gram.Type.UNIGRAM);}
a2eba5ef32f73a52133ef81f91f0ab6556f2f420643b7ed0476e7fd60c168082
testNull2
public void testNull2()
{    new Gram("foo", 4, null);}
6a8b71994a7828ecd371092d7ebf11751d87a69ed65372862db4789c474a55f7
testEquality
public void testEquality()
{    Gram one = new Gram("foo", 2, Gram.Type.HEAD);    Gram two = new Gram("foo", 3, Gram.Type.HEAD);    assertEquals(one, two);    assertEquals(two, one);    Gram three = new Gram("foo", 4, Gram.Type.TAIL);    Gram four = new Gram("foo", Gram.Type.UNIGRAM);    assertTrue(!three.equals(two));    assertTrue(!four.equals(one));    assertTrue(!one.equals(four));    Gram five = new Gram("foo", 5, Gram.Type.UNIGRAM);    assertEquals(four, five);    Gram six = new Gram("foo", 6, Gram.Type.NGRAM);    Gram seven = new Gram("foo", 7, Gram.Type.NGRAM);    assertTrue(!five.equals(six));    assertEquals(six, seven);    Gram eight = new Gram("foobar", 4, Gram.Type.TAIL);    assertTrue(!eight.equals(four));    assertTrue(!eight.equals(three));    assertTrue(!eight.equals(two));    assertTrue(!eight.equals(one));}
619ae83af0cb7ade8e545efec2da62924791150fd98b3ae8cf0f4cf8f14c933e
testHashing
public void testHashing()
{    Gram[] input = { new Gram("foo", 2, Gram.Type.HEAD), new Gram("foo", 3, Gram.Type.HEAD), new Gram("foo", 4, Gram.Type.TAIL), new Gram("foo", 5, Gram.Type.TAIL), new Gram("bar", 6, Gram.Type.HEAD), new Gram("bar", 7, Gram.Type.TAIL), new Gram("bar", 8, Gram.Type.NGRAM), new Gram("bar", Gram.Type.UNIGRAM) };    HashMap<Gram, Gram> map = new HashMap<>();    for (Gram n : input) {        Gram val = map.get(n);        if (val != null) {            val.incrementFrequency(n.getFrequency());        } else {            map.put(n, n);        }    }        int[] freq = { 5, 3, 9, 5, 6, 7, 8, 1 };        boolean[] memb = { true, false, true, false, true, true, true, true };    for (int i = 0; i < input.length; i++) {        assertEquals(freq[i], input[i].getFrequency());        assertEquals(memb[i], input[i] == map.get(input[i]));    }}
b760e783ced6d893c14245aa0647446f3eeb86c234d9ba85669ea1a19703381f
testWritable
public void testWritable() throws Exception
{    Gram one = new Gram("foo", 2, Gram.Type.HEAD);    Gram two = new Gram("foobar", 3, Gram.Type.UNIGRAM);    assertEquals("foo", one.getString());    assertEquals(2, one.getFrequency());    assertEquals(Gram.Type.HEAD, one.getType());    assertEquals("foobar", two.getString());    assertEquals(3, two.getFrequency());    assertEquals(Gram.Type.UNIGRAM, two.getType());    ByteArrayOutputStream bout = new ByteArrayOutputStream();    DataOutput out = new DataOutputStream(bout);    two.write(out);    byte[] b = bout.toByteArray();    ByteArrayInputStream bin = new ByteArrayInputStream(b);    DataInput din = new DataInputStream(bin);    one.readFields(din);    assertEquals("foobar", one.getString());    assertEquals(3, one.getFrequency());    assertEquals(Gram.Type.UNIGRAM, one.getType());}
f324042294b06ef3704020b620f11414334ef46284c9e372bf2f4fb39cec901c
testSorting
public void testSorting()
{    Gram[] input = { new Gram("foo", 2, Gram.Type.HEAD), new Gram("foo", 3, Gram.Type.HEAD), new Gram("foo", 4, Gram.Type.TAIL), new Gram("foo", 5, Gram.Type.TAIL), new Gram("bar", 6, Gram.Type.HEAD), new Gram("bar", 7, Gram.Type.TAIL), new Gram("bar", 8, Gram.Type.NGRAM), new Gram("bar", Gram.Type.UNIGRAM) };    Gram[] sorted = new Gram[input.length];    int[] expectations = { 4, 0, 1, 5, 2, 3, 7, 6 };    System.arraycopy(input, 0, sorted, 0, input.length);    Arrays.sort(sorted);    for (int i = 0; i < sorted.length; i++) {        assertSame(input[expectations[i]], sorted[i]);    }}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    super.setUp();    context = EasyMock.createMock(Reducer.Context.class);    ll = EasyMock.createMock(LLCallback.class);    cl = new LLCallback() {        @Override        public double logLikelihoodRatio(long k11, long k12, long k21, long k22) {            log.info("k11:{} k12:{} k21:{} k22:{}", k11, k12, k21, k22);            return LogLikelihood.logLikelihoodRatio(k11, k12, k21, k22);        }    };}
7a4d61c6559e2615379897c824cc5e4d52749e202f1568c776bf3ea84bb92c10
logLikelihoodRatio
public double logLikelihoodRatio(long k11, long k12, long k21, long k22)
{    log.info("k11:{} k12:{} k21:{} k22:{}", k11, k12, k21, k22);    return LogLikelihood.logLikelihoodRatio(k11, k12, k21, k22);}
011dec308a3e61e4f9e1df886b56833ee99b3a04eabe4f9ae2bd1b5a58e9ed5c
testReduce
public void testReduce() throws Exception
{    LLRReducer reducer = new LLRReducer(ll);                Gram[][] input = { { new Gram("the best", 1, Gram.Type.NGRAM), new Gram("the", 2, Gram.Type.HEAD), new Gram("best", 1, Gram.Type.TAIL) }, { new Gram("best of", 1, Gram.Type.NGRAM), new Gram("best", 1, Gram.Type.HEAD), new Gram("of", 2, Gram.Type.TAIL) }, { new Gram("of times", 2, Gram.Type.NGRAM), new Gram("of", 2, Gram.Type.HEAD), new Gram("times", 2, Gram.Type.TAIL) }, { new Gram("times the", 1, Gram.Type.NGRAM), new Gram("times", 1, Gram.Type.HEAD), new Gram("the", 1, Gram.Type.TAIL) }, { new Gram("the worst", 1, Gram.Type.NGRAM), new Gram("the", 2, Gram.Type.HEAD), new Gram("worst", 1, Gram.Type.TAIL) }, { new Gram("worst of", 1, Gram.Type.NGRAM), new Gram("worst", 1, Gram.Type.HEAD), new Gram("of", 2, Gram.Type.TAIL) } };    int[][] expectations = {     { 1, 1, 0, 5 },     { 1, 0, 1, 5 },     { 2, 0, 0, 5 },     { 1, 0, 0, 6 },     { 1, 1, 0, 5 },     { 1, 0, 1, 5 } };    Configuration config = getConfiguration();    config.set(LLRReducer.NGRAM_TOTAL, "7");    EasyMock.expect(context.getConfiguration()).andReturn(config);    for (int i = 0; i < expectations.length; i++) {        int[] ee = expectations[i];        context.write(EasyMock.eq(new Text(input[i][0].getString())), (DoubleWritable) EasyMock.anyObject());        EasyMock.expect(ll.logLikelihoodRatio(ee[0], ee[1], ee[2], ee[3])).andDelegateTo(cl);    }    EasyMock.replay(context, ll);    reducer.setup(context);    for (Gram[] ii : input) {        Collection<Gram> vv = Lists.newLinkedList();        vv.addAll(Arrays.asList(ii).subList(1, ii.length));        reducer.reduce(ii[0], vv, context);    }    EasyMock.verify(ll);}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    super.setUp();    Configuration conf = getConfiguration();    inputPath = getTestTempFilePath("documents/docs.file");    FileSystem fs = FileSystem.get(inputPath.toUri(), conf);    SequenceFile.Writer writer = new SequenceFile.Writer(fs, conf, inputPath, Text.class, Text.class);    try {        RandomDocumentGenerator gen = new RandomDocumentGenerator();        for (int i = 0; i < NUM_DOCS; i++) {            writer.append(new Text("Document::ID::" + i), new Text(gen.getRandomDocument()));            writer.append(new Text("Document::ID::" + i), new Text(SECOND_TEXT_BLOCK_IDENTIFIER));        }    } finally {        Closeables.close(writer, false);    }}
851bde4c49d5e15a2d45eb4e3c22602549897b212d13796b392c2011f2dd31e5
testCreateTermFrequencyVectors
public void testCreateTermFrequencyVectors() throws Exception
{    runTest(false, false);}
8d4f3357a8b03f8fcc659f935220bbf0f2bf08ccd50c5efaea9cc282faddad33
testCreateTermFrequencyVectorsNam
public void testCreateTermFrequencyVectorsNam() throws Exception
{    runTest(false, true);}
39c377781f57e29852be692448256fa4a4c30b81a00c40a1583caac3ee843d1d
testCreateTermFrequencyVectorsSeq
public void testCreateTermFrequencyVectorsSeq() throws Exception
{    runTest(true, false);}
b3d295fe2806bca19dfc4bd724db9972d8095014ed77e27837e68c6f460fd4d7
testCreateTermFrequencyVectorsSeqNam
public void testCreateTermFrequencyVectorsSeqNam() throws Exception
{    runTest(true, true);}
aa82dfd47616e8ae54a49b9e01717c3cecaf7eb4411b4b25756ed1c2868d53e1
runTest
private void runTest(boolean sequential, boolean named) throws IOException, ClassNotFoundException, InterruptedException
{    Class<? extends Analyzer> analyzer = StandardAnalyzer.class;    Path tokenizedDocuments = getTestTempDirPath("output/tokenized-documents");    Path wordCount = getTestTempDirPath("output/wordcount");    Path tfVectors = new Path(wordCount, "tf-vectors");    Path tfidf = getTestTempDirPath("output/tfidf");    Path tfidfVectors = new Path(tfidf, "tfidf-vectors");    Configuration conf = getConfiguration();    DocumentProcessor.tokenizeDocuments(inputPath, analyzer, tokenizedDocuments, conf);    DictionaryVectorizer.createTermFrequencyVectors(tokenizedDocuments, wordCount, DictionaryVectorizer.DOCUMENT_VECTOR_OUTPUT_FOLDER, conf, 2, 1, 0.0f, -1.0f, true, 1, 100, sequential, named);    validateVectors(conf, NUM_DOCS, tfVectors, sequential, named);    Pair<Long[], List<Path>> docFrequenciesFeatures = TFIDFConverter.calculateDF(tfVectors, tfidf, conf, 100);    TFIDFConverter.processTfIdf(tfVectors, tfidf, conf, docFrequenciesFeatures, 1, -1, 2.0f, false, sequential, named, 1);    validateVectors(conf, NUM_DOCS, tfidfVectors, sequential, named);    Integer secondTextBlockIdentifierDimensionId = validateDictionary(wordCount, conf);    validateVectorContainingSecondTextBlock(conf, tfVectors, secondTextBlockIdentifierDimensionId);}
ce90b845f65911d92dc86d3ab3fa06acf583e7c145a1f294fd3116853826567e
validateVectors
public static void validateVectors(Configuration conf, int numDocs, Path vectorPath, boolean sequential, boolean named)
{    int count = 0;    for (VectorWritable value : new SequenceFileDirValueIterable<VectorWritable>(vectorPath, PathType.LIST, PathFilters.partFilter(), null, true, conf)) {        count++;        Vector v = value.get();        if (named) {            assertTrue("Expected NamedVector", v instanceof NamedVector);            v = ((NamedVector) v).getDelegate();        }        if (sequential) {            assertTrue("Expected SequentialAccessSparseVector", v instanceof SequentialAccessSparseVector);        } else {            assertTrue("Expected RandomAccessSparseVector", v instanceof RandomAccessSparseVector);        }    }    assertEquals("Expected " + numDocs + " documents", numDocs, count);}
bcc34ce7cd276a7ca17df7fb406700e78a00621ae0b3e4353dc20bc7c7516c08
validateDictionary
private Integer validateDictionary(Path dictionaryDirectoryPath, Configuration conf)
{    PathFilter dictionaryChunkPathFilter = new PathFilter() {        @Override        public boolean accept(Path path) {            String name = path.getName();            return name.startsWith("dictionary.file");        }    };    Map<String, Integer> dictionary = new HashMap<>();    for (Pair<Text, IntWritable> value : new SequenceFileDirIterable<Text, IntWritable>(dictionaryDirectoryPath, PathType.LIST, dictionaryChunkPathFilter, null, true, conf)) {        dictionary.put(value.getFirst().toString(), value.getSecond().get());    }    Integer secondTextBlockIdentifierDimensionId = dictionary.get(SECOND_TEXT_BLOCK_IDENTIFIER.toLowerCase());    assertNotNull("Token '" + SECOND_TEXT_BLOCK_IDENTIFIER + "' must be in dictionary ", secondTextBlockIdentifierDimensionId);    assertTrue("Dictionary must contain more than just 1 element!", dictionary.size() > 1);    return secondTextBlockIdentifierDimensionId;}
50dec78a3246c66d1f1077fa5021604b0b396ea488918ec580feb329b787f269
accept
public boolean accept(Path path)
{    String name = path.getName();    return name.startsWith("dictionary.file");}
4b06ff713b2f83318052658920a39f803794ed288046c17fec86a99e7c148b2d
validateVectorContainingSecondTextBlock
public static void validateVectorContainingSecondTextBlock(Configuration conf, Path vectorPath, int dimensionId)
{    for (VectorWritable value : new SequenceFileDirValueIterable<VectorWritable>(vectorPath, PathType.LIST, PathFilters.partFilter(), null, true, conf)) {        assertTrue("The vector must contain the second text block", value.get().get(dimensionId) > 0);    }}
bfc1e7e5c54c620f60e62498be1114b08fc20f9f2c4d80465fe6d2024415c585
testTokenizeDocuments
public void testTokenizeDocuments() throws Exception
{    Configuration configuration = getConfiguration();    Path input = new Path(getTestTempDirPath(), "inputDir");    Path output = new Path(getTestTempDirPath(), "outputDir");    FileSystem fs = FileSystem.get(input.toUri(), configuration);    String documentId1 = "123";    String documentId2 = "456";    SequenceFile.Writer writer = new SequenceFile.Writer(fs, configuration, input, Text.class, Text.class);    try {        String text1 = "A test for the document processor";        writer.append(new Text(documentId1), new Text(text1));        String text2 = "and another one";        writer.append(new Text(documentId2), new Text(text2));    } finally {        Closeables.close(writer, false);    }    DocumentProcessor.tokenizeDocuments(input, StandardAnalyzer.class, output, configuration);    FileStatus[] statuses = fs.listStatus(output, PathFilters.logsCRCFilter());    assertEquals(1, statuses.length);    Path filePath = statuses[0].getPath();    SequenceFile.Reader reader = new SequenceFile.Reader(fs, filePath, configuration);    Text key = ClassUtils.instantiateAs((Class<? extends Text>) reader.getKeyClass(), Text.class);    StringTuple value = ClassUtils.instantiateAs((Class<? extends StringTuple>) reader.getValueClass(), StringTuple.class);    reader.next(key, value);    assertEquals(documentId1, key.toString());    assertEquals(Arrays.asList("test", "document", "processor"), value.getEntries());    reader.next(key, value);    assertEquals(documentId2, key.toString());    assertEquals(Arrays.asList("another", "one"), value.getEntries());}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    super.setUp();    conf = getConfiguration();    inputPath = getTestTempFilePath("documents/docs.file");    FileSystem fs = FileSystem.get(inputPath.toUri(), conf);    SequenceFile.Writer writer = new SequenceFile.Writer(fs, conf, inputPath, Text.class, Text.class);    RandomDocumentGenerator gen = new RandomDocumentGenerator();    try {        for (int i = 0; i < NUM_DOCS; i++) {            writer.append(new Text("Document::ID::" + i), new Text(gen.getRandomDocument()));        }    } finally {        Closeables.close(writer, false);    }}
a66dfa0a0dc44c8498730b66bb882e7c65e66f27e31ffe53ff36181d8fbb6615
testCreate
public void testCreate() throws Exception
{    runTest(false, false);}
9936ed480f0ce0ce6117247da5fab3ca68975aa8446021fad1dc3fbee0933237
testCreateNamed
public void testCreateNamed() throws Exception
{    runTest(false, true);}
279f50e90408986cd28b09b0a5eff391f0ea2861a69f280bda01902193de7a35
testCreateSeq
public void testCreateSeq() throws Exception
{    runTest(true, false);}
1c2b0628d0bec6d2c6004c50b95b4f46c715c4d6ee2c7c89d28b27e1ff8d42c2
testCreateSeqNamed
public void testCreateSeqNamed() throws Exception
{    runTest(true, true);}
5bca51a382517af711b523419d5fd38c676cd88de2a1890fdb9e56fe55479be7
runTest
private void runTest(boolean sequential, boolean named) throws Exception
{    Path tmpPath = getTestTempDirPath();    Path outputPath = new Path(tmpPath, "output");    List<String> argList = Lists.newLinkedList();    ;    argList.add("-i");    argList.add(inputPath.toString());    argList.add("-o");    argList.add(outputPath.toString());    if (sequential) {        argList.add("-seq");    }    if (named) {        argList.add("-nv");    }    String[] args = argList.toArray(new String[argList.size()]);    ToolRunner.run(getConfiguration(), new EncodedVectorsFromSequenceFiles(), args);    SequenceFileDirIterator<Text, VectorWritable> iter = new SequenceFileDirIterator<>(outputPath, PathType.LIST, PathFilters.partFilter(), null, true, conf);    int seen = 0;    while (iter.hasNext()) {        Pair<Text, VectorWritable> next = iter.next();        if (sequential && !named) {            assertTrue(next.getSecond().get() instanceof SequentialAccessSparseVector);        } else if (named) {            assertTrue(next.getSecond().get() instanceof NamedVector);        }        seen++;    }    assertEquals("Missed some vectors", NUM_DOCS, seen);}
e5ebe865726c3afa3e7590cb67b7081f935155ff61188e1b2964a695a97d9e09
testCacheAreUsedStaticWord
public void testCacheAreUsedStaticWord()
{    CachingStaticWordValueEncoder encoder = new CachingStaticWordValueEncoder(NAME, CARDINALITY);    Vector v = new DenseVector(CARDINALITY);    encoder.addToVector(WORD, v);    assertFalse("testCacheAreUsedStaticWord: cache should have values", encoder.getCaches()[0].isEmpty());}
f9eeae62f32f64e24df0b387993fe470312035949d2f44875812f6032226866d
testCacheAreUsedContinuous
public void testCacheAreUsedContinuous()
{    CachingContinuousValueEncoder encoder = new CachingContinuousValueEncoder(NAME, CARDINALITY);    Vector v = new DenseVector(CARDINALITY);    encoder.addToVector(CONTINUOUSVAL, 1.0, v);    assertFalse("testCacheAreUsedContinuous: cache should have values", encoder.getCaches()[0].isEmpty());}
e19c1870143cc7c9baa2bae2c27657b5f4c865beb2b3d1039e63f1b83e3e9e47
testAddToVector
public void testAddToVector()
{    FeatureVectorEncoder enc = new ConstantValueEncoder("foo");    Vector v1 = new DenseVector(20);    enc.addToVector((byte[]) null, -123, v1);    assertEquals(-123, v1.minValue(), 0);    assertEquals(0, v1.maxValue(), 0);    assertEquals(123, v1.norm(1), 0);    v1 = new DenseVector(20);    enc.addToVector((byte[]) null, 123, v1);    assertEquals(123, v1.maxValue(), 0);    assertEquals(0, v1.minValue(), 0);    assertEquals(123, v1.norm(1), 0);    Vector v2 = new DenseVector(20);    enc.setProbes(2);    enc.addToVector((byte[]) null, 123, v2);    assertEquals(123, v2.maxValue(), 0);    assertEquals(2 * 123, v2.norm(1), 0);            v1 = v2.minus(v1);    assertEquals(123, v1.maxValue(), 0);    assertEquals(123, v1.norm(1), 0);    Vector v3 = new DenseVector(20);    enc.setProbes(2);    enc.addToVector((byte[]) null, 100, v3);    v1 = v2.minus(v3);    assertEquals(23, v1.maxValue(), 0);    assertEquals(2 * 23, v1.norm(1), 0);    enc.addToVector((byte[]) null, 7, v1);    assertEquals(30, v1.maxValue(), 0);    assertEquals(2 * 30, v1.norm(1), 0);    assertEquals(30, v1.get(9), 0);    assertEquals(30, v1.get(10), 0);}
fcc8c6c65cf3f3f089a6ef99650c259817492e44080f36acd4703da0f305e081
testAsString
public void testAsString()
{    FeatureVectorEncoder enc = new ConstantValueEncoder("foo");    assertEquals("foo", enc.asString("123"));}
e19c1870143cc7c9baa2bae2c27657b5f4c865beb2b3d1039e63f1b83e3e9e47
testAddToVector
public void testAddToVector()
{    FeatureVectorEncoder enc = new ContinuousValueEncoder("foo");    Vector v1 = new DenseVector(20);    enc.addToVector("-123", v1);    assertEquals(-123, v1.minValue(), 0);    assertEquals(0, v1.maxValue(), 0);    assertEquals(123, v1.norm(1), 0);    v1 = new DenseVector(20);    enc.addToVector("123", v1);    assertEquals(123, v1.maxValue(), 0);    assertEquals(0, v1.minValue(), 0);    assertEquals(123, v1.norm(1), 0);    Vector v2 = new DenseVector(20);    enc.setProbes(2);    enc.addToVector("123", v2);    assertEquals(123, v2.maxValue(), 0);    assertEquals(2 * 123, v2.norm(1), 0);            v1 = v2.minus(v1);    assertEquals(123, v1.maxValue(), 0);    assertEquals(123, v1.norm(1), 0);    Vector v3 = new DenseVector(20);    enc.setProbes(2);    enc.addToVector("100", v3);    v1 = v2.minus(v3);    assertEquals(23, v1.maxValue(), 0);    assertEquals(2 * 23, v1.norm(1), 0);    enc.addToVector("7", v1);    assertEquals(30, v1.maxValue(), 0);    assertEquals(2 * 30, v1.norm(1), 0);    assertEquals(30, v1.get(10), 0);    assertEquals(30, v1.get(18), 0);    v2 = new DenseVector(20);    v3 = new DenseVector(20);    enc.setProbes(6);    enc.addToVector("145", v2);    enc.addToVector((byte[]) null, 145, v3);    assertEquals(0, v2.minus(v3).norm(1), 0);    try {        enc.addToVector("foobar", v1);        fail("Should have noticed bad numeric format");    } catch (NumberFormatException e) {        assertEquals("For input string: \"foobar\"", e.getMessage());    }}
fcc8c6c65cf3f3f089a6ef99650c259817492e44080f36acd4703da0f305e081
testAsString
public void testAsString()
{    FeatureVectorEncoder enc = new ContinuousValueEncoder("foo");    assertEquals("foo:123", enc.asString("123"));}
e19c1870143cc7c9baa2bae2c27657b5f4c865beb2b3d1039e63f1b83e3e9e47
testAddToVector
public void testAddToVector()
{    WordValueEncoder wv = new StaticWordValueEncoder("word");    ContinuousValueEncoder cv = new ContinuousValueEncoder("cont");    InteractionValueEncoder enc = new InteractionValueEncoder("interactions", wv, cv);    Vector v1 = new DenseVector(200);    enc.addInteractionToVector("a", "1.0", 1.0, v1);    int k = enc.getProbes();        assertEquals((float) k, v1.norm(1), 0);    assertEquals(1.0, v1.maxValue(), 0);        enc.addInteractionToVector("a", "1.0", 1.0, v1);    assertEquals((float) k * 2, v1.norm(1), 0);    assertEquals(2.0, v1.maxValue(), 0);    Vector v2 = new DenseVector(20000);    enc.addInteractionToVector("a", "1.0", 1.0, v2);    wv.addToVector("a", v2);    cv.addToVector("1.0", v2);    k = enc.getProbes();        assertEquals((float) (k + wv.getProbes() + cv.getProbes()), v2.norm(1), 1.0e-3);}
d18f8bd4d74b89f0f5ef73f74435a87f9144751f6c296865ea2f022186e3eca6
testAddToVectorUsesProductOfWeights
public void testAddToVectorUsesProductOfWeights()
{    WordValueEncoder wv = new StaticWordValueEncoder("word");    ContinuousValueEncoder cv = new ContinuousValueEncoder("cont");    InteractionValueEncoder enc = new InteractionValueEncoder("interactions", wv, cv);    Vector v1 = new DenseVector(200);    enc.addInteractionToVector("a", "0.9", 0.5, v1);    int k = enc.getProbes();        assertEquals((float) k * 0.5 * 0.9, v1.norm(1), 0);    assertEquals(0.5 * 0.9, v1.maxValue(), 0);}
a10e30d0067e52aa11e6d5d2ee8bc9b410190aede141a30ff609ef63c97f1d85
testAddToVectorWithTextValueEncoder
public void testAddToVectorWithTextValueEncoder()
{    WordValueEncoder wv = new StaticWordValueEncoder("word");    TextValueEncoder tv = new TextValueEncoder("text");    InteractionValueEncoder enc = new InteractionValueEncoder("interactions", wv, tv);    Vector v1 = new DenseVector(200);    enc.addInteractionToVector("a", "some text here", 1.0, v1);    int k = enc.getProbes();        assertEquals((float) k * 3, v1.norm(1), 0);}
6d2a2164b41c870707e15f8cb64fa72a4585a56015bfc0591fb0b8c6dc1a92c2
testTraceDictionary
public void testTraceDictionary()
{    StaticWordValueEncoder encoder1 = new StaticWordValueEncoder("first");    StaticWordValueEncoder encoder2 = new StaticWordValueEncoder("second");    Map<String, Set<Integer>> traceDictionary = Maps.newHashMap();    InteractionValueEncoder interactions = new InteractionValueEncoder("interactions", encoder1, encoder2);    interactions.setProbes(1);    interactions.setTraceDictionary(traceDictionary);    Vector v = new DenseVector(10);    interactions.addInteractionToVector("a", "b", 1, v);    assertEquals(1, v.getNumNonZeroElements());    assertEquals(1, traceDictionary.size());    assertEquals("interactions=a:b", getFirst(traceDictionary.keySet(), null));}
e19c1870143cc7c9baa2bae2c27657b5f4c865beb2b3d1039e63f1b83e3e9e47
testAddToVector
public void testAddToVector()
{    TextValueEncoder enc = new TextValueEncoder("text");    Vector v1 = new DenseVector(200);    enc.addToVector("test1 and more", v1);    enc.flush(1, v1);        assertEquals(6.0, v1.norm(1), 0);    assertEquals(1.0, v1.maxValue(), 0);        StaticWordValueEncoder w = new StaticWordValueEncoder("text");    w.setDictionary(ImmutableMap.<String, Double>of("word1", 3.0, "word2", 1.5));    enc.setWordEncoder(w);        Vector v2 = new DenseVector(200);    enc.addToVector("test1 and more", v2);    enc.flush(1, v2);        Vector v3 = new DenseVector(200);    w.addToVector("test1", v3);    w.addToVector("and", v3);    w.addToVector("more", v3);    assertEquals(0, v3.minus(v2).norm(1), 0);        assertEquals(v3.zSum(), v3.dot(v1), 0);}
fcc8c6c65cf3f3f089a6ef99650c259817492e44080f36acd4703da0f305e081
testAsString
public void testAsString()
{    Locale.setDefault(Locale.ENGLISH);    FeatureVectorEncoder enc = new TextValueEncoder("text");    assertEquals("[text:test1:1.0000, text:and:1.0000, text:more:1.0000]", enc.asString("test1 and more"));}
04a97d0df482bf1aa2c98869ecde2d61dd04df9c7e87cf9b6270d15492495b1e
testLuceneEncoding
public void testLuceneEncoding() throws Exception
{    LuceneTextValueEncoder enc = new LuceneTextValueEncoder("text");    enc.setAnalyzer(new WhitespaceAnalyzer());    Vector v1 = new DenseVector(200);    enc.addToVector("test1 and more", v1);    enc.flush(1, v1);            assertEquals(6.0, v1.norm(1), 0);    assertEquals(1.0, v1.maxValue(), 0);    v1 = new DenseVector(200);    enc.addToVector("", v1);    enc.flush(1, v1);    assertEquals(0.0, v1.norm(1), 0);    assertEquals(0.0, v1.maxValue(), 0);    v1 = new DenseVector(200);    StringBuilder builder = new StringBuilder(5000);    for (int i = 0; i < 1000; i++) {                builder.append("token_").append(i).append(' ');    }    enc.addToVector(builder.toString(), v1);    enc.flush(1, v1);        assertEquals(2000.0, v1.norm(1), 0);    assertEquals(19.0, v1.maxValue(), 0);}
e19c1870143cc7c9baa2bae2c27657b5f4c865beb2b3d1039e63f1b83e3e9e47
testAddToVector
public void testAddToVector()
{    FeatureVectorEncoder enc = new StaticWordValueEncoder("word");    Vector v = new DenseVector(200);    enc.addToVector("word1", v);    enc.addToVector("word2", v);    Iterator<Vector.Element> i = v.nonZeroes().iterator();    Iterator<Integer> j = ImmutableList.of(7, 118, 119, 199).iterator();    while (i.hasNext()) {        Vector.Element element = i.next();        assertEquals(j.next().intValue(), element.index());        assertEquals(1, element.get(), 0);    }    assertFalse(j.hasNext());}
fcc8c6c65cf3f3f089a6ef99650c259817492e44080f36acd4703da0f305e081
testAsString
public void testAsString()
{    Locale.setDefault(Locale.ENGLISH);    FeatureVectorEncoder enc = new StaticWordValueEncoder("word");    assertEquals("word:w1:1.0000", enc.asString("w1"));}
86f75591e8242b0f91c7af3a95ac21c95f97259e168ae3ce17cc2638f968731c
testStaticWeights
public void testStaticWeights()
{    StaticWordValueEncoder enc = new StaticWordValueEncoder("word");    enc.setDictionary(ImmutableMap.<String, Double>of("word1", 3.0, "word2", 1.5));    Vector v = new DenseVector(200);    enc.addToVector("word1", v);    enc.addToVector("word2", v);    enc.addToVector("word3", v);    Iterator<Vector.Element> i = v.nonZeroes().iterator();    Iterator<Integer> j = ImmutableList.of(7, 101, 118, 119, 152, 199).iterator();    Iterator<Double> k = ImmutableList.of(3.0, 0.75, 1.5, 1.5, 0.75, 3.0).iterator();    while (i.hasNext()) {        Vector.Element element = i.next();        assertEquals(j.next().intValue(), element.index());    }    i = v.nonZeroes().iterator();    while (i.hasNext()) {        Vector.Element element = i.next();        assertEquals(String.format("checking v[%d]", element.index()), k.next(), element.get(), 0);    }    assertFalse(j.hasNext());}
a5f80ab0185ce16d692c9def000959a8a296c1664553ff50e6acc8e30df3c8e3
testDynamicWeights
public void testDynamicWeights()
{    FeatureVectorEncoder enc = new AdaptiveWordValueEncoder("word");    Vector v = new DenseVector(200);        enc.addToVector("word1", v);        enc.addToVector("word2", v);        enc.addToVector("word1", v);        enc.addToVector("word3", v);    Iterator<Vector.Element> i = v.nonZeroes().iterator();    Iterator<Integer> j = ImmutableList.of(7, 101, 118, 119, 152, 199).iterator();    Iterator<Double> k = ImmutableList.of(Math.log(2 / 1.5) + Math.log(4.5 / 2.5), Math.log(6 / 1.5), Math.log(3.5 / 1.5), Math.log(3.5 / 1.5), Math.log(6 / 1.5), Math.log(2 / 1.5) + Math.log(4.5 / 2.5)).iterator();    while (i.hasNext()) {        Vector.Element element = i.next();        assertEquals(j.next().intValue(), element.index());        assertEquals(k.next(), element.get(), 1.0e-6);    }    assertFalse(j.hasNext());}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    super.setUp();    conf = getConfiguration();    inputPath = getTestTempFilePath("documents/docs.file");    FileSystem fs = FileSystem.get(inputPath.toUri(), conf);    SequenceFile.Writer writer = new SequenceFile.Writer(fs, conf, inputPath, Text.class, Text.class);    RandomDocumentGenerator gen = new RandomDocumentGenerator();    for (int i = 0; i < NUM_DOCS; i++) {        writer.append(new Text("Document::ID::" + i), new Text(enhanceWithHighDFWords(gen.getRandomDocument())));    }    writer.close();}
83e7f48eaf17a575236900bcb8b1c79a8c8fec89affa9759d177fe4478fbd7b0
enhanceWithHighDFWords
private static String enhanceWithHighDFWords(String initialDoc)
{    StringBuilder sb = new StringBuilder(initialDoc);    for (String word : HIGH_DF_WORDS) {        sb.append(' ').append(word);    }    return sb.toString();}
dd029331ca5acc2eda44e5244e2878f465a840ae4b8cf84cbf4cb1d0054429eb
testHighDFWordsPreserving
public void testHighDFWordsPreserving() throws Exception
{    runTest(false);}
d378d7602fc7f0dd6564a17222649a08ceb50ce71a364800a8ddc98d329779a3
testHighDFWordsPruning
public void testHighDFWordsPruning() throws Exception
{    runTest(true);}
f6182e9392ab358964fee51c34d2203e33ab8bb8f3acc9e8d705f93ed4c88d5d
runTest
private void runTest(boolean prune) throws Exception
{    Path outputPath = getTestTempFilePath("output");    List<String> argList = Lists.newLinkedList();    argList.add("-i");    argList.add(inputPath.toString());    argList.add("-o");    argList.add(outputPath.toString());    if (prune) {        argList.add("-xs");                argList.add("3");    } else {        argList.add("--maxDFPercent");                argList.add("100");    }    argList.add("-seq");    argList.add("-nv");    String[] args = argList.toArray(new String[argList.size()]);    ToolRunner.run(conf, new SparseVectorsFromSequenceFiles(), args);    Path dictionary = new Path(outputPath, "dictionary.file-0");    Path tfVectors = new Path(outputPath, "tf-vectors");    Path tfidfVectors = new Path(outputPath, "tfidf-vectors");    int[] highDFWordsDictionaryIndices = getHighDFWordsDictionaryIndices(dictionary);    validateVectors(tfVectors, highDFWordsDictionaryIndices, prune);    validateVectors(tfidfVectors, highDFWordsDictionaryIndices, prune);}
87c0cbf77108d11631683e758585f9a12892ffe90d6a765d820cfbbf73cdb8ea
getHighDFWordsDictionaryIndices
private int[] getHighDFWordsDictionaryIndices(Path dictionaryPath)
{    int[] highDFWordsDictionaryIndices = new int[HIGH_DF_WORDS.length];    List<String> highDFWordsList = Arrays.asList(HIGH_DF_WORDS);    for (Pair<Text, IntWritable> record : new SequenceFileDirIterable<Text, IntWritable>(dictionaryPath, PathType.GLOB, null, null, true, conf)) {        int index = highDFWordsList.indexOf(record.getFirst().toString());        if (index > -1) {            highDFWordsDictionaryIndices[index] = record.getSecond().get();        }    }    return highDFWordsDictionaryIndices;}
f4e2cb204540b7ce3ec0ab4620995f24bd2e52c7e65881838816450197ca6bba
validateVectors
private void validateVectors(Path vectorPath, int[] highDFWordsDictionaryIndices, boolean prune) throws Exception
{    assertTrue("Path does not exist", vectorPath.getFileSystem(conf).exists(vectorPath));    for (VectorWritable value : new SequenceFileDirValueIterable<VectorWritable>(vectorPath, PathType.LIST, PathFilters.partFilter(), null, true, conf)) {        Vector v = ((NamedVector) value.get()).getDelegate();        for (int i = 0; i < highDFWordsDictionaryIndices.length; i++) {            if (prune) {                assertEquals("Found vector for which word '" + HIGH_DF_WORDS[i] + "' is not pruned", 0.0, v.get(highDFWordsDictionaryIndices[i]), 0.0);            } else {                assertTrue("Found vector for which word '" + HIGH_DF_WORDS[i] + "' is pruned, and shouldn't have been", v.get(highDFWordsDictionaryIndices[i]) != 0.0);            }        }    }}
df369cb579521297cb6b7b4fafc6561b4ff9fdb766299e53a4faa12bdd955eb9
getRandomDelimiter
private char getRandomDelimiter()
{    return DELIM.charAt(random.nextInt(DELIM.length()));}
1d7022c0054bad55fa514f3d5f1eb9d8369389a7b3e2d261486cbdfb31662577
getRandomDocument
public String getRandomDocument()
{    int length = (AVG_DOCUMENT_LENGTH >> 1) + random.nextInt(AVG_DOCUMENT_LENGTH);    StringBuilder sb = new StringBuilder(length * AVG_SENTENCE_LENGTH * AVG_WORD_LENGTH);    for (int i = 0; i < length; i++) {        sb.append(getRandomSentence());    }    return sb.toString();}
3bd3261d8950bf9b8e15e494c600dede93eccf75e77cb79f7128ece0fb5a7f7f
getRandomSentence
public String getRandomSentence()
{    int length = (AVG_SENTENCE_LENGTH >> 1) + random.nextInt(AVG_SENTENCE_LENGTH);    StringBuilder sb = new StringBuilder(length * AVG_WORD_LENGTH);    for (int i = 0; i < length; i++) {        sb.append(getRandomString()).append(' ');    }    sb.append(getRandomDelimiter());    return sb.toString();}
6b4cce718121a8f27d1822f3b78ea6b5fedb7698e08853063b1f2168e1a07168
getRandomString
public String getRandomString()
{    int length = (AVG_WORD_LENGTH >> 1) + random.nextInt(AVG_WORD_LENGTH);    StringBuilder sb = new StringBuilder(length);    for (int i = 0; i < length; i++) {        sb.append(CHARSET.charAt(random.nextInt(CHARSET.length())));    }    if (random.nextInt(10) == 0) {        sb.append(ERRORSET.charAt(random.nextInt(ERRORSET.length())));    }    return sb.toString();}
afb85a6f3035c8e1270f63933ca79debeb4091a4bba80098a8508c25d5d72b4a
setupDocs
private void setupDocs() throws IOException
{    conf = getConfiguration();    inputPath = getTestTempFilePath("documents/docs.file");    FileSystem fs = FileSystem.get(inputPath.toUri(), conf);    SequenceFile.Writer writer = new SequenceFile.Writer(fs, conf, inputPath, Text.class, Text.class);    RandomDocumentGenerator gen = new RandomDocumentGenerator();    try {        for (int i = 0; i < NUM_DOCS; i++) {            writer.append(new Text("Document::ID::" + i), new Text(gen.getRandomDocument()));        }    } finally {        Closeables.close(writer, false);    }}
851bde4c49d5e15a2d45eb4e3c22602549897b212d13796b392c2011f2dd31e5
testCreateTermFrequencyVectors
public void testCreateTermFrequencyVectors() throws Exception
{    setupDocs();    runTest(false, false, false, -1, NUM_DOCS);}
8d4f3357a8b03f8fcc659f935220bbf0f2bf08ccd50c5efaea9cc282faddad33
testCreateTermFrequencyVectorsNam
public void testCreateTermFrequencyVectorsNam() throws Exception
{    setupDocs();    runTest(false, false, true, -1, NUM_DOCS);}
39c377781f57e29852be692448256fa4a4c30b81a00c40a1583caac3ee843d1d
testCreateTermFrequencyVectorsSeq
public void testCreateTermFrequencyVectorsSeq() throws Exception
{    setupDocs();    runTest(false, true, false, -1, NUM_DOCS);}
b3d295fe2806bca19dfc4bd724db9972d8095014ed77e27837e68c6f460fd4d7
testCreateTermFrequencyVectorsSeqNam
public void testCreateTermFrequencyVectorsSeqNam() throws Exception
{    setupDocs();    runTest(false, true, true, -1, NUM_DOCS);}
7dc8cc118698d5e65209424a4aa9d1d476a7d31ed473d1794dffda23e8c5c664
testPruning
public void testPruning() throws Exception
{    conf = getConfiguration();    inputPath = getTestTempFilePath("documents/docs.file");    FileSystem fs = FileSystem.get(inputPath.toUri(), conf);    SequenceFile.Writer writer = new SequenceFile.Writer(fs, conf, inputPath, Text.class, Text.class);    String[] docs = { "a b c", "a a a a a b", "a a a a a c" };    try {        for (int i = 0; i < docs.length; i++) {            writer.append(new Text("Document::ID::" + i), new Text(docs[i]));        }    } finally {        Closeables.close(writer, false);    }    Path outPath = runTest(false, false, false, 2, docs.length);    Path tfidfVectors = new Path(outPath, "tfidf-vectors");    int count = 0;    Vector[] res = new Vector[docs.length];    for (VectorWritable value : new SequenceFileDirValueIterable<VectorWritable>(tfidfVectors, PathType.LIST, PathFilters.partFilter(), null, true, conf)) {        Vector v = value.get();        System.out.println(v);        assertEquals(2, v.size());        res[count] = v;        count++;    }    assertEquals(docs.length, count);        assertEquals(2, res[0].getNumNondefaultElements());    assertEquals(1, res[1].getNumNondefaultElements());    assertEquals(1, res[2].getNumNondefaultElements());}
d4c98d9a2f7fb9d32153c975dd585045711295898af9a263723c2f540b8d3584
testPruningTF
public void testPruningTF() throws Exception
{    conf = getConfiguration();    FileSystem fs = FileSystem.get(conf);    inputPath = getTestTempFilePath("documents/docs.file");    SequenceFile.Writer writer = new SequenceFile.Writer(fs, conf, inputPath, Text.class, Text.class);    String[] docs = { "a b c", "a a a a a b", "a a a a a c" };    try {        for (int i = 0; i < docs.length; i++) {            writer.append(new Text("Document::ID::" + i), new Text(docs[i]));        }    } finally {        Closeables.close(writer, false);    }    Path outPath = runTest(true, false, false, 2, docs.length);    Path tfVectors = new Path(outPath, "tf-vectors");    int count = 0;    Vector[] res = new Vector[docs.length];    for (VectorWritable value : new SequenceFileDirValueIterable<VectorWritable>(tfVectors, PathType.LIST, PathFilters.partFilter(), null, true, conf)) {        Vector v = value.get();        System.out.println(v);        assertEquals(2, v.size());        res[count] = v;        count++;    }    assertEquals(docs.length, count);        assertEquals(2, res[0].getNumNondefaultElements());    assertEquals(1, res[1].getNumNondefaultElements());    assertEquals(1, res[2].getNumNondefaultElements());}
25eed96c453dc599957af04d97017e9640392aa5ca8702f576ce01324be9e5dd
runTest
private Path runTest(boolean tfWeighting, boolean sequential, boolean named, double maxDFSigma, int numDocs) throws Exception
{    Path outputPath = getTestTempFilePath("output");    List<String> argList = Lists.newLinkedList();    argList.add("-i");    argList.add(inputPath.toString());    argList.add("-o");    argList.add(outputPath.toString());    if (sequential) {        argList.add("-seq");    }    if (named) {        argList.add("-nv");    }    if (maxDFSigma >= 0) {        argList.add("--maxDFSigma");        argList.add(String.valueOf(maxDFSigma));    }    if (tfWeighting) {        argList.add("--weight");        argList.add("tf");    }    String[] args = argList.toArray(new String[argList.size()]);    ToolRunner.run(getConfiguration(), new SparseVectorsFromSequenceFiles(), args);    Path tfVectors = new Path(outputPath, "tf-vectors");    Path tfidfVectors = new Path(outputPath, "tfidf-vectors");    DictionaryVectorizerTest.validateVectors(conf, numDocs, tfVectors, sequential, named);    if (!tfWeighting) {        DictionaryVectorizerTest.validateVectors(conf, numDocs, tfidfVectors, sequential, named);    }    return outputPath;}
2dc6b0153d6772fcc089075e32bcd2d4f93daa3143e3a889d7821635b62ed9fe
recommend
public List<RecommendedItem> recommend(long userID, int howMany) throws TasteException
{    return recommender.recommend(userID, howMany);}
d15575e3c7219fa78f3f939060474f9f6e1b3d7a970e542069957a25a02fb5d4
recommend
public List<RecommendedItem> recommend(long userID, int howMany, boolean includeKnownItems) throws TasteException
{    return recommend(userID, howMany, null, includeKnownItems);}
82cca6a764b4f51c39392acfde0a28aced7e68d46f3f48675d7e2aa136c3b334
recommend
public List<RecommendedItem> recommend(long userID, int howMany, IDRescorer rescorer) throws TasteException
{    return recommender.recommend(userID, howMany, rescorer, false);}
cae55eaeb500f9cfd9e012eff77e31d3bd1d8c4362d52fedefd3790d2b7900d6
recommend
public List<RecommendedItem> recommend(long userID, int howMany, IDRescorer rescorer, boolean includeKnownItems) throws TasteException
{    return recommender.recommend(userID, howMany, rescorer, includeKnownItems);}
fe4075a1aad10eb52e9a33b25ff2a59f9af6b1541778182edc3aa82095b47ee2
estimatePreference
public float estimatePreference(long userID, long itemID) throws TasteException
{    return recommender.estimatePreference(userID, itemID);}
50d76af25ae801a2139a90c576940f9f9838c80f93853951415d27753efe6193
setPreference
public void setPreference(long userID, long itemID, float value) throws TasteException
{    recommender.setPreference(userID, itemID, value);}
b8fc0c1b44ecc54ed269a5d79a52cada03c7abb05284d3d33b03ade9d9a86320
removePreference
public void removePreference(long userID, long itemID) throws TasteException
{    recommender.removePreference(userID, itemID);}
9cc8860ae5e18fe9fdcc3faca0fad6e9d7eb4076efef8c2790ec7efad6fe6102
getDataModel
public DataModel getDataModel()
{    return recommender.getDataModel();}
da77e35d28c590f4b271e5b2b7f639c465574b8f17a1ef2f1df63e0152c57e8b
refresh
public void refresh(Collection<Refreshable> alreadyRefreshed)
{    recommender.refresh(alreadyRefreshed);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "BookCrossingBooleanRecommender[recommender:" + recommender + ']';}
e26f26b33b5dca480753c13f0e28794c1c0e1f19cef251c09738dbac6d2732f6
buildRecommender
public Recommender buildRecommender(DataModel dataModel) throws TasteException
{    return new BookCrossingBooleanRecommender(dataModel);}
0584b9f509a70b0a9c6bbd7d0978d71bc1151265349ff2ed5ea0e19c359a0c24
main
public static void main(String... args) throws IOException, TasteException, OptionException
{    RecommenderIRStatsEvaluator evaluator = new GenericRecommenderIRStatsEvaluator();    File ratingsFile = TasteOptionParser.getRatings(args);    DataModel model = ratingsFile == null ? new BookCrossingDataModel(true) : new BookCrossingDataModel(ratingsFile, true);    IRStatistics evaluation = evaluator.evaluate(new BookCrossingBooleanRecommenderBuilder(), new BookCrossingDataModelBuilder(), model, null, 3, Double.NEGATIVE_INFINITY, 1.0);    log.info(String.valueOf(evaluation));}
b822409bfe118fe1d846e808661c994003ee2f231ce37b736bd4675ef36daff4
convertBCFile
private static File convertBCFile(File originalFile, boolean ignoreRatings) throws IOException
{    if (!originalFile.exists()) {        throw new FileNotFoundException(originalFile.toString());    }    File resultFile = new File(new File(System.getProperty("java.io.tmpdir")), "taste.bookcrossing.txt");    resultFile.delete();    Writer writer = null;    try {        writer = new OutputStreamWriter(new FileOutputStream(resultFile), Charsets.UTF_8);        for (String line : new FileLineIterable(originalFile, true)) {                        if (line.endsWith("\"0\"")) {                continue;            }                        String convertedLine = NON_DIGIT_SEMICOLON_PATTERN.matcher(line).replaceAll("").replace(';', ',');                        if (convertedLine.contains(",,")) {                continue;            }            if (ignoreRatings) {                                convertedLine = convertedLine.substring(0, convertedLine.lastIndexOf(','));            }            writer.write(convertedLine);            writer.write('\n');        }        writer.flush();    } catch (IOException ioe) {        resultFile.delete();        throw ioe;    } finally {        Closeables.close(writer, false);    }    return resultFile;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "BookCrossingDataModel";}
fda6d188eb5cee5c4aa189da9fe29fb85c875748f6acc1239599435c5206468b
buildDataModel
public DataModel buildDataModel(FastByIDMap<PreferenceArray> trainingData)
{    return new GenericBooleanPrefDataModel(GenericBooleanPrefDataModel.toDataMap(trainingData));}
2dc6b0153d6772fcc089075e32bcd2d4f93daa3143e3a889d7821635b62ed9fe
recommend
public List<RecommendedItem> recommend(long userID, int howMany) throws TasteException
{    return recommender.recommend(userID, howMany);}
d15575e3c7219fa78f3f939060474f9f6e1b3d7a970e542069957a25a02fb5d4
recommend
public List<RecommendedItem> recommend(long userID, int howMany, boolean includeKnownItems) throws TasteException
{    return recommend(userID, howMany, null, includeKnownItems);}
82cca6a764b4f51c39392acfde0a28aced7e68d46f3f48675d7e2aa136c3b334
recommend
public List<RecommendedItem> recommend(long userID, int howMany, IDRescorer rescorer) throws TasteException
{    return recommender.recommend(userID, howMany, rescorer, false);}
cae55eaeb500f9cfd9e012eff77e31d3bd1d8c4362d52fedefd3790d2b7900d6
recommend
public List<RecommendedItem> recommend(long userID, int howMany, IDRescorer rescorer, boolean includeKnownItems) throws TasteException
{    return recommender.recommend(userID, howMany, rescorer, false);}
fe4075a1aad10eb52e9a33b25ff2a59f9af6b1541778182edc3aa82095b47ee2
estimatePreference
public float estimatePreference(long userID, long itemID) throws TasteException
{    return recommender.estimatePreference(userID, itemID);}
50d76af25ae801a2139a90c576940f9f9838c80f93853951415d27753efe6193
setPreference
public void setPreference(long userID, long itemID, float value) throws TasteException
{    recommender.setPreference(userID, itemID, value);}
b8fc0c1b44ecc54ed269a5d79a52cada03c7abb05284d3d33b03ade9d9a86320
removePreference
public void removePreference(long userID, long itemID) throws TasteException
{    recommender.removePreference(userID, itemID);}
9cc8860ae5e18fe9fdcc3faca0fad6e9d7eb4076efef8c2790ec7efad6fe6102
getDataModel
public DataModel getDataModel()
{    return recommender.getDataModel();}
da77e35d28c590f4b271e5b2b7f639c465574b8f17a1ef2f1df63e0152c57e8b
refresh
public void refresh(Collection<Refreshable> alreadyRefreshed)
{    recommender.refresh(alreadyRefreshed);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "BookCrossingRecommender[recommender:" + recommender + ']';}
e26f26b33b5dca480753c13f0e28794c1c0e1f19cef251c09738dbac6d2732f6
buildRecommender
public Recommender buildRecommender(DataModel dataModel) throws TasteException
{    return new BookCrossingRecommender(dataModel);}
0584b9f509a70b0a9c6bbd7d0978d71bc1151265349ff2ed5ea0e19c359a0c24
main
public static void main(String... args) throws IOException, TasteException, OptionException
{    RecommenderEvaluator evaluator = new AverageAbsoluteDifferenceRecommenderEvaluator();    File ratingsFile = TasteOptionParser.getRatings(args);    DataModel model = ratingsFile == null ? new BookCrossingDataModel(false) : new BookCrossingDataModel(ratingsFile, false);    double evaluation = evaluator.evaluate(new BookCrossingRecommenderBuilder(), null, model, 0.9, 0.3);    log.info(String.valueOf(evaluation));}
4d69df7c4bf208f3987a8c55fbb0490c749090d622d4e7cdb51db9e5abf4420c
cleanUpEmailAddress
public static String cleanUpEmailAddress(CharSequence address)
{        return ADDRESS_CLEANUP.matcher(address).replaceAll("");}
882c95a394fb71995943bb5260968177870b864796c18deba6cb0f562c67af7a
loadDictionaries
public static void loadDictionaries(Configuration conf, String fromPrefix, OpenObjectIntHashMap<String> fromDictionary, String msgIdPrefix, OpenObjectIntHashMap<String> msgIdDictionary) throws IOException
{    Path[] localFiles = HadoopUtil.getCachedFiles(conf);    FileSystem fs = FileSystem.getLocal(conf);    for (Path dictionaryFile : localFiles) {                OpenObjectIntHashMap<String> dictionary = null;        if (dictionaryFile.getName().startsWith(fromPrefix)) {            dictionary = fromDictionary;        } else if (dictionaryFile.getName().startsWith(msgIdPrefix)) {            dictionary = msgIdDictionary;        }        if (dictionary != null) {            dictionaryFile = fs.makeQualified(dictionaryFile);            for (Pair<Writable, IntWritable> record : new SequenceFileIterable<Writable, IntWritable>(dictionaryFile, true, conf)) {                dictionary.put(record.getFirst().toString(), record.getSecond().get());            }        }    }}
cfbb817a5f15352d9a7e94fcfa317abd7261c45e45841e023dd358ff159aae60
parseReferences
public static String[] parseReferences(CharSequence rawRefs)
{    String[] splits;    if (rawRefs != null && rawRefs.length() > 0) {        splits = SPACE_OR_CLOSE_ANGLE.split(rawRefs);        for (int i = 0; i < splits.length; i++) {            splits[i] = ANGLE_BRACES.matcher(splits[i]).replaceAll("");        }    } else {        splits = EMPTY;    }    return splits;}
6b7dd49be7482fc8ee0fbe8bd0f24522f2a718c8c816a3d7b048fb4688eb6373
setup
protected void setup(Context context) throws IOException, InterruptedException
{    super.setup(context);    separator = context.getConfiguration().get(EmailUtility.SEPARATOR);}
968f41a6f11b26ed79ba77c2271e3152f4cd3a22a7a841beeb74b66dcb12263e
map
protected void map(Text key, Text value, Context context) throws IOException, InterruptedException
{        String valStr = value.toString();    int idx = valStr.indexOf(separator);    if (idx == -1) {        context.getCounter(EmailUtility.Counters.NO_FROM_ADDRESS).increment(1);    } else {        String full = valStr.substring(0, idx);                                full = EmailUtility.cleanUpEmailAddress(full);        if (EmailUtility.WHITESPACE.matcher(full).matches()) {            context.getCounter(EmailUtility.Counters.NO_FROM_ADDRESS).increment(1);        } else {            context.write(new Text(full), new VarIntWritable(1));        }    }}
dcc8827425fc8a9ddc5b635e6be1cc892c58ac1fac555c4d3588ef1d703eede3
reduce
protected void reduce(Text key, Iterable<VarIntWritable> values, Context context) throws IOException, InterruptedException
{    int sum = 0;    for (VarIntWritable value : values) {        sum += value.get();    }    context.write(new Text(key), new VarIntWritable(sum));}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    ToolRunner.run(new Configuration(), new MailToPrefsDriver(), args);}
aacecb0f01750d985b78d806dc3c134f0da79efe2752957e0f93ecf5cbf9e492
run
public int run(String[] args) throws Exception
{    addInputOption();    addOutputOption();    addOption(DefaultOptionCreator.overwriteOption().create());    addOption("chunkSize", "cs", "The size of chunks to write.  Default is 100 mb", "100");    addOption("separator", "sep", "The separator used in the input file to separate to, from, subject.  Default is \\n", "\n");    addOption("from", "f", "The position in the input text (value) where the from email is located, starting from " + "zero (0).", "0");    addOption("refs", "r", "The position in the input text (value) where the reference ids are located, " + "starting from zero (0).", "1");    addOption(buildOption("useCounts", "u", "If set, then use the number of times the user has interacted with a " + "thread as an indication of their preference.  Otherwise, use boolean preferences.", false, false, String.valueOf(true)));    Map<String, List<String>> parsedArgs = parseArguments(args);    Path input = getInputPath();    Path output = getOutputPath();    int chunkSize = Integer.parseInt(getOption("chunkSize"));    String separator = getOption("separator");    Configuration conf = getConf();    boolean useCounts = hasOption("useCounts");    AtomicInteger currentPhase = new AtomicInteger();    int[] msgDim = new int[1];        List<Path> msgIdChunks = null;    boolean overwrite = hasOption(DefaultOptionCreator.OVERWRITE_OPTION);        if (shouldRunNextPhase(parsedArgs, currentPhase)) {                        Path msgIdsPath = new Path(output, "msgIds");        if (overwrite) {            HadoopUtil.delete(conf, msgIdsPath);        }        log.info("Creating Msg Id Dictionary");        Job createMsgIdDictionary = prepareJob(input, msgIdsPath, SequenceFileInputFormat.class, MsgIdToDictionaryMapper.class, Text.class, VarIntWritable.class, MailToDictionaryReducer.class, Text.class, VarIntWritable.class, SequenceFileOutputFormat.class);        boolean succeeded = createMsgIdDictionary.waitForCompletion(true);        if (!succeeded) {            return -1;        }                msgIdChunks = createDictionaryChunks(msgIdsPath, output, "msgIds-dictionary-", createMsgIdDictionary.getConfiguration(), chunkSize, msgDim);    }        List<Path> fromChunks = null;    if (shouldRunNextPhase(parsedArgs, currentPhase)) {        Path fromIdsPath = new Path(output, "fromIds");        if (overwrite) {            HadoopUtil.delete(conf, fromIdsPath);        }        log.info("Creating From Id Dictionary");        Job createFromIdDictionary = prepareJob(input, fromIdsPath, SequenceFileInputFormat.class, FromEmailToDictionaryMapper.class, Text.class, VarIntWritable.class, MailToDictionaryReducer.class, Text.class, VarIntWritable.class, SequenceFileOutputFormat.class);        createFromIdDictionary.getConfiguration().set(EmailUtility.SEPARATOR, separator);        boolean succeeded = createFromIdDictionary.waitForCompletion(true);        if (!succeeded) {            return -1;        }                int[] fromDim = new int[1];        fromChunks = createDictionaryChunks(fromIdsPath, output, "fromIds-dictionary-", createFromIdDictionary.getConfiguration(), chunkSize, fromDim);    }        if (shouldRunNextPhase(parsedArgs, currentPhase) && fromChunks != null && msgIdChunks != null) {                                log.info("Creating recommendation matrix");        Path vecPath = new Path(output, "recInput");        if (overwrite) {            HadoopUtil.delete(conf, vecPath);        }                conf.set(EmailUtility.MSG_ID_DIMENSION, String.valueOf(msgDim[0]));        conf.set(EmailUtility.FROM_PREFIX, "fromIds-dictionary-");        conf.set(EmailUtility.MSG_IDS_PREFIX, "msgIds-dictionary-");        conf.set(EmailUtility.FROM_INDEX, getOption("from"));        conf.set(EmailUtility.REFS_INDEX, getOption("refs"));        conf.set(EmailUtility.SEPARATOR, separator);        conf.set(MailToRecReducer.USE_COUNTS_PREFERENCE, String.valueOf(useCounts));        int j = 0;        int i = 0;        for (Path fromChunk : fromChunks) {            for (Path idChunk : msgIdChunks) {                Path out = new Path(vecPath, "tmp-" + i + '-' + j);                DistributedCache.setCacheFiles(new URI[] { fromChunk.toUri(), idChunk.toUri() }, conf);                Job createRecMatrix = prepareJob(input, out, SequenceFileInputFormat.class, MailToRecMapper.class, Text.class, LongWritable.class, MailToRecReducer.class, Text.class, NullWritable.class, TextOutputFormat.class);                createRecMatrix.getConfiguration().set("mapred.output.compress", "false");                boolean succeeded = createRecMatrix.waitForCompletion(true);                if (!succeeded) {                    return -1;                }                                                                FileStatus[] fs = HadoopUtil.getFileStatus(new Path(out, "*"), PathType.GLOB, PathFilters.partFilter(), null, conf);                for (int k = 0; k < fs.length; k++) {                    FileStatus f = fs[k];                    Path outPath = new Path(vecPath, "chunk-" + i + '-' + j + '-' + k);                    FileUtil.copy(f.getPath().getFileSystem(conf), f.getPath(), outPath.getFileSystem(conf), outPath, true, overwrite, conf);                }                HadoopUtil.delete(conf, out);                j++;            }            i++;        }        /*Path mergePath = new Path(output, "vectors.dat");      if (overwrite) {        HadoopUtil.delete(conf, mergePath);      }      log.info("Merging together output vectors to vectors.dat in {}", output);*/            }    return 0;}
04ae383bfe8eaf55a9df9d2043d6682650ce171dac6b9ecfa2bfb37f0b67bc68
createDictionaryChunks
private static List<Path> createDictionaryChunks(Path inputPath, Path dictionaryPathBase, String name, Configuration baseConf, int chunkSizeInMegabytes, int[] maxTermDimension) throws IOException
{    List<Path> chunkPaths = new ArrayList<>();    Configuration conf = new Configuration(baseConf);    FileSystem fs = FileSystem.get(inputPath.toUri(), conf);    long chunkSizeLimit = chunkSizeInMegabytes * 1024L * 1024L;    int chunkIndex = 0;    Path chunkPath = new Path(dictionaryPathBase, name + chunkIndex);    chunkPaths.add(chunkPath);    SequenceFile.Writer dictWriter = new SequenceFile.Writer(fs, conf, chunkPath, Text.class, IntWritable.class);    try {        long currentChunkSize = 0;        Path filesPattern = new Path(inputPath, OUTPUT_FILES_PATTERN);                int i = 1;        for (Pair<Writable, Writable> record : new SequenceFileDirIterable<>(filesPattern, PathType.GLOB, null, null, true, conf)) {            if (currentChunkSize > chunkSizeLimit) {                Closeables.close(dictWriter, false);                chunkIndex++;                chunkPath = new Path(dictionaryPathBase, name + chunkIndex);                chunkPaths.add(chunkPath);                dictWriter = new SequenceFile.Writer(fs, conf, chunkPath, Text.class, IntWritable.class);                currentChunkSize = 0;            }            Writable key = record.getFirst();            int fieldSize = DICTIONARY_BYTE_OVERHEAD + key.toString().length() * 2 + Integer.SIZE / 8;            currentChunkSize += fieldSize;            dictWriter.append(key, new IntWritable(i++));        }        maxTermDimension[0] = i;    } finally {        Closeables.close(dictWriter, false);    }    return chunkPaths;}
6b7dd49be7482fc8ee0fbe8bd0f24522f2a718c8c816a3d7b048fb4688eb6373
setup
protected void setup(Context context) throws IOException, InterruptedException
{    super.setup(context);    Configuration conf = context.getConfiguration();    String fromPrefix = conf.get(EmailUtility.FROM_PREFIX);    String msgPrefix = conf.get(EmailUtility.MSG_IDS_PREFIX);    fromIdx = conf.getInt(EmailUtility.FROM_INDEX, 0);    refsIdx = conf.getInt(EmailUtility.REFS_INDEX, 1);    EmailUtility.loadDictionaries(conf, fromPrefix, fromDictionary, msgPrefix, msgIdDictionary);    log.info("From Dictionary size: {} Msg Id Dictionary size: {}", fromDictionary.size(), msgIdDictionary.size());    separator = context.getConfiguration().get(EmailUtility.SEPARATOR);}
968f41a6f11b26ed79ba77c2271e3152f4cd3a22a7a841beeb74b66dcb12263e
map
protected void map(Text key, Text value, Context context) throws IOException, InterruptedException
{    int msgIdKey = Integer.MIN_VALUE;    int fromKey = Integer.MIN_VALUE;    String valStr = value.toString();    String[] splits = StringUtils.splitByWholeSeparatorPreserveAllTokens(valStr, separator);    if (splits != null && splits.length > 0) {        if (splits.length > refsIdx) {            String from = EmailUtility.cleanUpEmailAddress(splits[fromIdx]);            fromKey = fromDictionary.get(from);        }                if (splits.length > refsIdx) {            String[] theRefs = EmailUtility.parseReferences(splits[refsIdx]);            if (theRefs != null && theRefs.length > 0) {                                msgIdKey = msgIdDictionary.get(theRefs[0]);                context.getCounter(Counters.REFERENCE).increment(1);            }        }    }        if (msgIdKey == Integer.MIN_VALUE) {                String keyStr = key.toString();        int idx = keyStr.lastIndexOf('/');        if (idx != -1) {            String msgId = keyStr.substring(idx + 1);            msgIdKey = msgIdDictionary.get(msgId);            context.getCounter(Counters.ORIGINAL).increment(1);        }    }    if (msgIdKey != Integer.MIN_VALUE && fromKey != Integer.MIN_VALUE) {        context.write(new Text(fromKey + "," + msgIdKey), new LongWritable(1));    }}
6b7dd49be7482fc8ee0fbe8bd0f24522f2a718c8c816a3d7b048fb4688eb6373
setup
protected void setup(Context context) throws IOException, InterruptedException
{    useCounts = context.getConfiguration().getBoolean(USE_COUNTS_PREFERENCE, true);}
7bba593422bb42c95fd3950160e161d067ab18a22007a6766dcfe65de904967d
reduce
protected void reduce(Text key, Iterable<LongWritable> values, Context context) throws IOException, InterruptedException
{    if (useCounts) {        long sum = 0;        for (LongWritable value : values) {            sum++;        }        context.write(new Text(key.toString() + ',' + sum), null);    } else {        context.write(new Text(key.toString()), null);    }}
968f41a6f11b26ed79ba77c2271e3152f4cd3a22a7a841beeb74b66dcb12263e
map
protected void map(Text key, Text value, Context context) throws IOException, InterruptedException
{        String keyStr = key.toString();        int idx = keyStr.lastIndexOf('@');    if (idx == -1) {        context.getCounter(EmailUtility.Counters.NO_MESSAGE_ID).increment(1);    } else {                idx = keyStr.lastIndexOf('/', idx);        String msgId = keyStr.substring(idx + 1);        if (EmailUtility.WHITESPACE.matcher(msgId).matches()) {            context.getCounter(EmailUtility.Counters.NO_MESSAGE_ID).increment(1);        } else {            context.write(new Text(msgId), new VarIntWritable(1));        }    }}
f246b7de7a2d4c0dada1306810013fdf8abdb56d75df66490b657c586c83ae8e
iterator
public Iterator<Pair<PreferenceArray, long[]>> iterator()
{    try {        return new DataFileIterator(dataFile);    } catch (IOException ioe) {        throw new IllegalStateException(ioe);    }}
5606d220893aeb4eac5f991b34dba3efb76e086ab0d92e0c2406410cf108fc0f
computeNext
protected Pair<PreferenceArray, long[]> computeNext()
{    if (!lineIterator.hasNext()) {        return endOfData();    }    String line = lineIterator.next();        String[] tokens = PIPE_PATTERN.split(line);    long userID = Long.parseLong(tokens[0]);    int ratingsLeftToRead = Integer.parseInt(tokens[1]);    int ratingsRead = 0;    PreferenceArray currentUserPrefs = new GenericUserPreferenceArray(ratingsLeftToRead);    long[] timestamps = new long[ratingsLeftToRead];    while (ratingsLeftToRead > 0) {        line = lineIterator.next();                                tokens = TAB_PATTERN.split(line);        boolean hasPref = tokens.length == 2 || tokens.length == 4;        boolean hasDate = tokens.length > 2;        long itemID = Long.parseLong(tokens[0]);        currentUserPrefs.setUserID(0, userID);        currentUserPrefs.setItemID(ratingsRead, itemID);        if (hasPref) {            float preference = Float.parseFloat(tokens[1]);            currentUserPrefs.setValue(ratingsRead, preference);        }        if (hasDate) {            long timestamp;            if (hasPref) {                timestamp = parseFakeTimestamp(tokens[2], tokens[3]);            } else {                timestamp = parseFakeTimestamp(tokens[1], tokens[2]);            }            timestamps[ratingsRead] = timestamp;        }        ratingsRead++;        ratingsLeftToRead--;    }    return new Pair<>(currentUserPrefs, timestamps);}
83659b3f3c32cda5d1e381b9ad4b7db55d1ee8ecce3504ad3c9ad45a376b6f2e
skip
public void skip(int n)
{    for (int i = 0; i < n; i++) {        if (lineIterator.hasNext()) {            String line = lineIterator.next();                        String[] tokens = PIPE_PATTERN.split(line);            int linesToSKip = Integer.parseInt(tokens[1]);            lineIterator.skip(linesToSKip);        } else {            break;        }    }}
5df6118bc0e745d8b18e0a6a99b2e3f2ddba8140cbeb1423ce2df50a9f140574
close
public void close()
{    endOfData();    try {        Closeables.close(lineIterator, true);    } catch (IOException e) {        log.error(e.getMessage(), e);    }}
1c934becf462da4f08d1f240f6d3dd6840e2c29b583e44612fbb82feeea1cdd8
parseFakeTimestamp
private static long parseFakeTimestamp(String dateString, CharSequence timeString)
{    int days = Integer.parseInt(dateString);    String[] timeTokens = COLON_PATTERN.split(timeString);    int hours = Integer.parseInt(timeTokens[0]);    int minutes = Integer.parseInt(timeTokens[1]);    int seconds = Integer.parseInt(timeTokens[2]);    return 86400L * days + 3600L + hours + 60L * minutes + seconds;}
97982e4bcbb9f376bb77531ffaf35a7c08949cccf7b09bb694fcef0217b3639f
getDataFileDirectory
public File getDataFileDirectory()
{    return dataFileDirectory;}
7cbf1f37901b16c073b44ec6defe1d5386a739d1a3a1261c88fbba1af5f60fe7
getTrainingFile
public static File getTrainingFile(File dataFileDirectory)
{    return getFile(dataFileDirectory, "trainIdx");}
78dcf3b1c0099ca3a35624e08e2af22ba57483c07303e1e7dcd23b4eb52cbfe9
getValidationFile
public static File getValidationFile(File dataFileDirectory)
{    return getFile(dataFileDirectory, "validationIdx");}
abc086d1afea3b944881fb2aefe165b5adf2c1f9f582d79a73ce305fe76fe213
getTestFile
public static File getTestFile(File dataFileDirectory)
{    return getFile(dataFileDirectory, "testIdx");}
8ec8e890c73264e3614e60f0b3a5b20a7ffcaf17dbdec3c3a283a1788bdcdc05
getTrackFile
public static File getTrackFile(File dataFileDirectory)
{    return getFile(dataFileDirectory, "trackData");}
4471d46826e1a1bb8ef2ea174363f86e736b8553ecc119ebad7ed7902e8054c3
getFile
private static File getFile(File dataFileDirectory, String prefix)
{        for (int set : new int[] { 1, 2 }) {                for (String firstLinesOrNot : new String[] { "", ".firstLines" }) {            for (String gzippedOrNot : new String[] { ".gz", "" }) {                File dataFile = new File(dataFileDirectory, prefix + set + firstLinesOrNot + ".txt" + gzippedOrNot);                if (dataFile.exists()) {                    return dataFile;                }            }        }    }    throw new IllegalArgumentException("Can't find " + prefix + " file in " + dataFileDirectory);}
108a89a094b3a39b3b20cbd581561d4dd8b642f065690760ae153d36d980dcf0
getUserIDs
public LongPrimitiveIterator getUserIDs() throws TasteException
{    return delegate.getUserIDs();}
a06f75f56917fd636b983b7cfb0dd8060e1eb667d990c2ab0e2a39d33d94541d
getPreferencesFromUser
public PreferenceArray getPreferencesFromUser(long userID) throws TasteException
{    return delegate.getPreferencesFromUser(userID);}
ba6a53e86aa528831d7ca18f17bea6d3af21894eb8e11a57a1a779aa58bf6f42
getItemIDsFromUser
public FastIDSet getItemIDsFromUser(long userID) throws TasteException
{    return delegate.getItemIDsFromUser(userID);}
c388e3d4c09037f02ac5953d664aae3d2714c879c41346267284f3f30ad0a533
getItemIDs
public LongPrimitiveIterator getItemIDs() throws TasteException
{    return delegate.getItemIDs();}
be05dbd3948efc99ba2728f3fbfa2a5e8c9ebc9afdb1d8695cb8bf348212f432
getPreferencesForItem
public PreferenceArray getPreferencesForItem(long itemID) throws TasteException
{    return delegate.getPreferencesForItem(itemID);}
4a797ada65a2ab5d778b75e04ac2b1252411b11fa907fd98679888cf05ffb484
getPreferenceValue
public Float getPreferenceValue(long userID, long itemID) throws TasteException
{    return delegate.getPreferenceValue(userID, itemID);}
0857731203f906c58b60e4e747203723db701723c05fe7896e7f325ffa539bdc
getPreferenceTime
public Long getPreferenceTime(long userID, long itemID) throws TasteException
{    return delegate.getPreferenceTime(userID, itemID);}
0e5cfb4e0e4f9d1a7b8c16082ab928c9562f8fb336a58c94de25d6df00236f93
getNumItems
public int getNumItems() throws TasteException
{    return delegate.getNumItems();}
c52287e7598bb24d77044373ddfeaf97ff2c29583e729316fa8fb9bef78133a1
getNumUsers
public int getNumUsers() throws TasteException
{    return delegate.getNumUsers();}
0ea40759843b60bfb2d618774fa6b7fede865d83651c9e9fe817822760d18483
getNumUsersWithPreferenceFor
public int getNumUsersWithPreferenceFor(long itemID) throws TasteException
{    return delegate.getNumUsersWithPreferenceFor(itemID);}
6d019eca3996fc5fdfb1030e07ee927128888b79b32683dd1b2041baeaf53a4b
getNumUsersWithPreferenceFor
public int getNumUsersWithPreferenceFor(long itemID1, long itemID2) throws TasteException
{    return delegate.getNumUsersWithPreferenceFor(itemID1, itemID2);}
50d76af25ae801a2139a90c576940f9f9838c80f93853951415d27753efe6193
setPreference
public void setPreference(long userID, long itemID, float value) throws TasteException
{    delegate.setPreference(userID, itemID, value);}
b8fc0c1b44ecc54ed269a5d79a52cada03c7abb05284d3d33b03ade9d9a86320
removePreference
public void removePreference(long userID, long itemID) throws TasteException
{    delegate.removePreference(userID, itemID);}
5fe6ef45f2c8e613067bc79bf61b3f21f1aac63aa04e14a47b4f8203cebb79f9
hasPreferenceValues
public boolean hasPreferenceValues()
{    return delegate.hasPreferenceValues();}
13925bef8afa2e6d068d08c72262016e42e3d5fe30ac04c85c78f8b0f99c4ceb
getMaxPreference
public float getMaxPreference()
{    return 100.0f;}
886c9fcd0006e44aa20de41c56cd99e5659dc842b2fd94840da5c661f1bccb0a
getMinPreference
public float getMinPreference()
{    return 0.0f;}
da77e35d28c590f4b271e5b2b7f639c465574b8f17a1ef2f1df63e0152c57e8b
refresh
public void refresh(Collection<Refreshable> alreadyRefreshed)
{}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    File inputFile = new File(args[0]);    File outputFile = new File(args[1]);    int columnsToOutput = 4;    if (args.length >= 3) {        columnsToOutput = Integer.parseInt(args[2]);    }    OutputStream outStream = new GZIPOutputStream(new FileOutputStream(outputFile));    try (Writer outWriter = new BufferedWriter(new OutputStreamWriter(outStream, Charsets.UTF_8))) {        for (Pair<PreferenceArray, long[]> user : new DataFileIterable(inputFile)) {            PreferenceArray prefs = user.getFirst();            long[] timestamps = user.getSecond();            for (int i = 0; i < prefs.length(); i++) {                outWriter.write(String.valueOf(prefs.getUserID(i)));                outWriter.write(',');                outWriter.write(String.valueOf(prefs.getItemID(i)));                if (columnsToOutput > 2) {                    outWriter.write(',');                    outWriter.write(String.valueOf(prefs.getValue(i)));                }                if (columnsToOutput > 3) {                    outWriter.write(',');                    outWriter.write(String.valueOf(timestamps[i]));                }                outWriter.write('\n');            }        }    }}
2ea2958dd2e4d29ce0b1f08e784ede42ba3335629fbb763bb78bd90afefe46e0
convert
public static byte convert(double estimate, long userID, long itemID)
{    if (Double.isNaN(estimate)) {        log.warn("Unable to compute estimate for user {}, item {}", userID, itemID);        return 0x7F;    } else {        int scaledEstimate = (int) (estimate * 2.55);        if (scaledEstimate > 255) {            scaledEstimate = 255;        } else if (scaledEstimate < 0) {            scaledEstimate = 0;        }        return (byte) scaledEstimate;    }}
ae0b9234410c2731e2caaaed14f72d73f38265fbe74eaf3d462bf0f241266a01
getUserIDs
public LongPrimitiveIterator getUserIDs()
{    return userIDs.iterator();}
78fb119f03da6df48a809e8dc94c215041880ef1551757ef4d2508fe192621b8
getItemIDs
public LongPrimitiveIterator getItemIDs()
{    return itemIDs.iterator();}
7e069958a04bfae6afcc268662b5eb4da8df7c0324020b2591dff37fac286e07
getPreferences
public Iterable<Preference> getPreferences()
{    return preferences;}
886c9fcd0006e44aa20de41c56cd99e5659dc842b2fd94840da5c661f1bccb0a
getMinPreference
public float getMinPreference()
{    return minPreference;}
13925bef8afa2e6d068d08c72262016e42e3d5fe30ac04c85c78f8b0f99c4ceb
getMaxPreference
public float getMaxPreference()
{    return maxPreference;}
8e062c730a4a25a407b12b8cef1c735f08ba7e3ed49d7b95ada5aabb32412520
numUsers
public int numUsers()
{    return userIDs.size();}
272e0197d41c5da0849218d2f769be1b08e092fa8bc928a93599b60b44b9862e
numItems
public int numItems()
{    return itemIDs.size();}
b8a55dd0f9d0c20fbea04b56c08ba200de1f37290b0772bcb27234586ba4825b
numPreferences
public int numPreferences()
{    return preferences.size();}
ae0b9234410c2731e2caaaed14f72d73f38265fbe74eaf3d462bf0f241266a01
getUserIDs
public LongPrimitiveIterator getUserIDs()
{    return new FixedSizeLongIterator(numUsers());}
78fb119f03da6df48a809e8dc94c215041880ef1551757ef4d2508fe192621b8
getItemIDs
public LongPrimitiveIterator getItemIDs()
{    return new FixedSizeLongIterator(numItems());}
7e069958a04bfae6afcc268662b5eb4da8df7c0324020b2591dff37fac286e07
getPreferences
public Iterable<Preference> getPreferences()
{    Iterable<Iterable<Preference>> prefIterators = Iterables.transform(new DataFileIterable(dataFile), new Function<Pair<PreferenceArray, long[]>, Iterable<Preference>>() {        @Override        public Iterable<Preference> apply(Pair<PreferenceArray, long[]> from) {            return from.getFirst();        }    });    return Iterables.concat(prefIterators);}
dd9a8e8a4a13f549ab626b9c0f1d49ab1e800c41396a771e27cf792df0b610c1
apply
public Iterable<Preference> apply(Pair<PreferenceArray, long[]> from)
{    return from.getFirst();}
886c9fcd0006e44aa20de41c56cd99e5659dc842b2fd94840da5c661f1bccb0a
getMinPreference
public float getMinPreference()
{    return 0;}
13925bef8afa2e6d068d08c72262016e42e3d5fe30ac04c85c78f8b0f99c4ceb
getMaxPreference
public float getMaxPreference()
{    return 100;}
8e062c730a4a25a407b12b8cef1c735f08ba7e3ed49d7b95ada5aabb32412520
numUsers
public int numUsers()
{    return 1000990;}
272e0197d41c5da0849218d2f769be1b08e092fa8bc928a93599b60b44b9862e
numItems
public int numItems()
{    return 624961;}
b8a55dd0f9d0c20fbea04b56c08ba200de1f37290b0772bcb27234586ba4825b
numPreferences
public int numPreferences()
{    return 252800275;}
c07ff43a11a0fd30355c754b084700be1eadeb6e7293cc052804e1ca4dba70c9
nextLong
public long nextLong()
{    return currentValue++;}
cfc67e5714c799daa4f0cae0084231f7d3115d517eae691edd227e7f59489e21
peek
public long peek()
{    return currentValue;}
83659b3f3c32cda5d1e381b9ad4b7db55d1ee8ecce3504ad3c9ad45a376b6f2e
skip
public void skip(int n)
{    currentValue += n;}
d51e5f7450eca0a0f63da1a466189e262d053b84aa767ba3be5cea740af7251b
hasNext
public boolean hasNext()
{    return currentValue < maximum;}
eb35e4acc0ab2c89fd30970f01fba35488b3a4581b2af1986091209043508a3e
remove
public void remove()
{    throw new UnsupportedOperationException();}
8c12d0b02a28eeb877e3a2564a8fdc295b8e3c39fed1a4489a8f06bbc631d33c
factorize
public Factorization factorize() throws TasteException
{    for (int feature = 0; feature < numFeatures; feature++) {        log.info("Shuffling preferences...");        shufflePreferences();        log.info("Starting training of feature {} ...", feature);        for (int currentIteration = 0; currentIteration < numIterations; currentIteration++) {            if (currentIteration == numIterations - 1) {                double rmse = trainingIterationWithRmse(feature);                log.info("Finished training feature {} with RMSE {}", feature, rmse);            } else {                trainingIteration(feature);            }        }        if (feature < numFeatures - 1) {            log.info("Updating cache...");            for (int index = 0; index < userIndexes.length; index++) {                cachedEstimates[index] = estimate(userIndexes[index], itemIndexes[index], feature, cachedEstimates[index], false);            }        }    }    log.info("Factorization done");    return new Factorization(userIDMapping, itemIDMapping, userFeatures, itemFeatures);}
2ec4a2c3dd824220ace4a79cd99957fbc624ea6e18576413662037fe03b3baa8
trainingIteration
private void trainingIteration(int feature)
{    for (int index = 0; index < userIndexes.length; index++) {        train(userIndexes[index], itemIndexes[index], feature, values[index], cachedEstimates[index]);    }}
5b907a01f1f86558bee40bee2e685e94870fcebfb1a6e1dd3f33b673b7be1aad
trainingIterationWithRmse
private double trainingIterationWithRmse(int feature)
{    double rmse = 0.0;    for (int index = 0; index < userIndexes.length; index++) {        double error = train(userIndexes[index], itemIndexes[index], feature, values[index], cachedEstimates[index]);        rmse += error * error;    }    return Math.sqrt(rmse / userIndexes.length);}
27a74097a2559d78a39cd0329e3e71579276613fca5eda8b45c1940e5ea91b56
estimate
private double estimate(int userIndex, int itemIndex, int feature, double cachedEstimate, boolean trailing)
{    double sum = cachedEstimate;    sum += userFeatures[userIndex][feature] * itemFeatures[itemIndex][feature];    if (trailing) {        sum += (numFeatures - feature - 1) * (defaultValue + interval) * (defaultValue + interval);        if (sum > maxPreference) {            sum = maxPreference;        } else if (sum < minPreference) {            sum = minPreference;        }    }    return sum;}
9101488be4e41609c2527c2f80b20898ab7c771caff95f13f77c3cade0579be6
train
public double train(int userIndex, int itemIndex, int feature, double original, double cachedEstimate)
{    double error = original - estimate(userIndex, itemIndex, feature, cachedEstimate, true);    double[] userVector = userFeatures[userIndex];    double[] itemVector = itemFeatures[itemIndex];    userVector[feature] += learningRate * (error * itemVector[feature] - preventOverfitting * userVector[feature]);    itemVector[feature] += learningRate * (error * userVector[feature] - preventOverfitting * itemVector[feature]);    return error;}
71e467a976ae86917ed43c6480678c0f2b9be6be5f52147c92330e556277bbf8
shufflePreferences
protected void shufflePreferences()
{    /* Durstenfeld shuffle */    for (int currentPos = userIndexes.length - 1; currentPos > 0; currentPos--) {        int swapPos = random.nextInt(currentPos + 1);        swapPreferences(currentPos, swapPos);    }}
66cfbd0f10895deb26a0d55e81c06977cbdedf8be6c5ea05c326ba630f32ccb8
swapPreferences
private void swapPreferences(int posA, int posB)
{    int tmpUserIndex = userIndexes[posA];    int tmpItemIndex = itemIndexes[posA];    float tmpValue = values[posA];    double tmpEstimate = cachedEstimates[posA];    userIndexes[posA] = userIndexes[posB];    itemIndexes[posA] = itemIndexes[posB];    values[posA] = values[posB];    cachedEstimates[posA] = cachedEstimates[posB];    userIndexes[posB] = tmpUserIndex;    itemIndexes[posB] = tmpItemIndex;    values[posB] = tmpValue;    cachedEstimates[posB] = tmpEstimate;}
da77e35d28c590f4b271e5b2b7f639c465574b8f17a1ef2f1df63e0152c57e8b
refresh
public void refresh(Collection<Refreshable> alreadyRefreshed)
{}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    if (args.length != 2) {        System.err.println("Necessary arguments: <kddDataFileDirectory> <resultFile>");        return;    }    File dataFileDirectory = new File(args[0]);    if (!dataFileDirectory.exists() || !dataFileDirectory.isDirectory()) {        throw new IllegalArgumentException("Bad data file directory: " + dataFileDirectory);    }    File resultFile = new File(args[1]);    /* the knobs to turn */    int numFeatures = 20;    int numIterations = 5;    double learningRate = 0.0001;    double preventOverfitting = 0.002;    double randomNoise = 0.0001;    KDDCupFactorizablePreferences factorizablePreferences = new KDDCupFactorizablePreferences(KDDCupDataModel.getTrainingFile(dataFileDirectory));    Factorizer sgdFactorizer = new ParallelArraysSGDFactorizer(factorizablePreferences, numFeatures, numIterations, learningRate, preventOverfitting, randomNoise);    Factorization factorization = sgdFactorizer.factorize();    log.info("Estimating validation preferences...");    int prefsProcessed = 0;    RunningAverage average = new FullRunningAverage();    for (Pair<PreferenceArray, long[]> validationPair : new DataFileIterable(KDDCupDataModel.getValidationFile(dataFileDirectory))) {        for (Preference validationPref : validationPair.getFirst()) {            double estimate = estimatePreference(factorization, validationPref.getUserID(), validationPref.getItemID(), factorizablePreferences.getMinPreference(), factorizablePreferences.getMaxPreference());            double error = validationPref.getValue() - estimate;            average.addDatum(error * error);            prefsProcessed++;            if (prefsProcessed % 100000 == 0) {                log.info("Computed {} estimations", prefsProcessed);            }        }    }    log.info("Computed {} estimations, done.", prefsProcessed);    double rmse = Math.sqrt(average.getAverage());    log.info("RMSE {}", rmse);    log.info("Estimating test preferences...");    OutputStream out = null;    try {        out = new BufferedOutputStream(new FileOutputStream(resultFile));        for (Pair<PreferenceArray, long[]> testPair : new DataFileIterable(KDDCupDataModel.getTestFile(dataFileDirectory))) {            for (Preference testPref : testPair.getFirst()) {                double estimate = estimatePreference(factorization, testPref.getUserID(), testPref.getItemID(), factorizablePreferences.getMinPreference(), factorizablePreferences.getMaxPreference());                byte result = EstimateConverter.convert(estimate, testPref.getUserID(), testPref.getItemID());                out.write(result);            }        }    } finally {        Closeables.close(out, false);    }    log.info("wrote estimates to {}, done.", resultFile.getAbsolutePath());}
b0d17007c507fab1d411a28a35c236b701f10e769b456ee63022e78898eb9583
estimatePreference
 static double estimatePreference(Factorization factorization, long userID, long itemID, float minPreference, float maxPreference) throws NoSuchUserException, NoSuchItemException
{    double[] userFeatures = factorization.getUserFeatures(userID);    double[] itemFeatures = factorization.getItemFeatures(itemID);    double estimate = 0;    for (int feature = 0; feature < userFeatures.length; feature++) {        estimate += userFeatures[feature] * itemFeatures[feature];    }    if (estimate < minPreference) {        estimate = minPreference;    } else if (estimate > maxPreference) {        estimate = maxPreference;    }    return estimate;}
e301eaba4fe07d736b556ce086808d3703acd9a925d51f1a967348e1bb941a64
call
public byte[] call() throws TasteException
{    long userID = userTest.get(0).getUserID();    byte[] result = new byte[userTest.length()];    for (int i = 0; i < userTest.length(); i++) {        long itemID = userTest.getItemID(i);        double estimate;        try {            estimate = recommender.estimatePreference(userID, itemID);        } catch (NoSuchItemException nsie) {                        log.warn("Unknown item {}; OK unless this is the real contest data", itemID);            continue;        }        result[i] = EstimateConverter.convert(estimate, userID, itemID);    }    if (COUNT.incrementAndGet() % 10000 == 0) {        log.info("Completed {} users", COUNT.get());    }    return result;}
2dc6b0153d6772fcc089075e32bcd2d4f93daa3143e3a889d7821635b62ed9fe
recommend
public List<RecommendedItem> recommend(long userID, int howMany) throws TasteException
{    return recommender.recommend(userID, howMany);}
d15575e3c7219fa78f3f939060474f9f6e1b3d7a970e542069957a25a02fb5d4
recommend
public List<RecommendedItem> recommend(long userID, int howMany, boolean includeKnownItems) throws TasteException
{    return recommend(userID, howMany, null, includeKnownItems);}
82cca6a764b4f51c39392acfde0a28aced7e68d46f3f48675d7e2aa136c3b334
recommend
public List<RecommendedItem> recommend(long userID, int howMany, IDRescorer rescorer) throws TasteException
{    return recommender.recommend(userID, howMany, rescorer, false);}
cae55eaeb500f9cfd9e012eff77e31d3bd1d8c4362d52fedefd3790d2b7900d6
recommend
public List<RecommendedItem> recommend(long userID, int howMany, IDRescorer rescorer, boolean includeKnownItems) throws TasteException
{    return recommender.recommend(userID, howMany, rescorer, includeKnownItems);}
fe4075a1aad10eb52e9a33b25ff2a59f9af6b1541778182edc3aa82095b47ee2
estimatePreference
public float estimatePreference(long userID, long itemID) throws TasteException
{    return recommender.estimatePreference(userID, itemID);}
50d76af25ae801a2139a90c576940f9f9838c80f93853951415d27753efe6193
setPreference
public void setPreference(long userID, long itemID, float value) throws TasteException
{    recommender.setPreference(userID, itemID, value);}
b8fc0c1b44ecc54ed269a5d79a52cada03c7abb05284d3d33b03ade9d9a86320
removePreference
public void removePreference(long userID, long itemID) throws TasteException
{    recommender.removePreference(userID, itemID);}
9cc8860ae5e18fe9fdcc3faca0fad6e9d7eb4076efef8c2790ec7efad6fe6102
getDataModel
public DataModel getDataModel()
{    return recommender.getDataModel();}
da77e35d28c590f4b271e5b2b7f639c465574b8f17a1ef2f1df63e0152c57e8b
refresh
public void refresh(Collection<Refreshable> alreadyRefreshed)
{    recommender.refresh(alreadyRefreshed);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "Track1Recommender[recommender:" + recommender + ']';}
e26f26b33b5dca480753c13f0e28794c1c0e1f19cef251c09738dbac6d2732f6
buildRecommender
public Recommender buildRecommender(DataModel dataModel) throws TasteException
{    return new Track1Recommender(dataModel);}
13fb9f21f36332ee06a990e85a6e4e25b9309aefb898a58fdaa793efcb15dc93
evaluate
public double evaluate(RecommenderBuilder recommenderBuilder, DataModelBuilder dataModelBuilder, DataModel dataModel, double trainingPercentage, double evaluationPercentage) throws TasteException
{    Recommender recommender = recommenderBuilder.buildRecommender(dataModel);    Collection<Callable<Void>> estimateCallables = Lists.newArrayList();    AtomicInteger noEstimateCounter = new AtomicInteger();    for (Pair<PreferenceArray, long[]> userData : new DataFileIterable(KDDCupDataModel.getValidationFile(dataFileDirectory))) {        PreferenceArray validationPrefs = userData.getFirst();        long userID = validationPrefs.get(0).getUserID();        estimateCallables.add(new PreferenceEstimateCallable(recommender, userID, validationPrefs, noEstimateCounter));    }    RunningAverageAndStdDev timing = new FullRunningAverageAndStdDev();    execute(estimateCallables, noEstimateCounter, timing);    double result = computeFinalEvaluation();    log.info("Evaluation result: {}", result);    return result;}
be1a56c7ae2c2f9ffcdc6b49e244b4eaac6ed33e21475a783841ddf769017dcd
reset
protected void reset()
{    average = new FullRunningAverage();}
564de17b779b836b599f961d80ca9e66835bffe24036e1c8ef3099ec239de317
processOneEstimate
protected void processOneEstimate(float estimatedPreference, Preference realPref)
{    double diff = realPref.getValue() - estimatedPreference;    average.addDatum(diff * diff);}
7a6d373c44bb4c8d3eed87d9628fb1e8ddbf0bdbe9fd84e8e6044cf4f278f3bb
computeFinalEvaluation
protected double computeFinalEvaluation()
{    return Math.sqrt(average.getAverage());}
0584b9f509a70b0a9c6bbd7d0978d71bc1151265349ff2ed5ea0e19c359a0c24
main
public static void main(String... args) throws IOException, TasteException, OptionException
{    File dataFileDirectory = TasteOptionParser.getRatings(args);    if (dataFileDirectory == null) {        throw new IllegalArgumentException("No data directory");    }    if (!dataFileDirectory.exists() || !dataFileDirectory.isDirectory()) {        throw new IllegalArgumentException("Bad data file directory: " + dataFileDirectory);    }    Track1RecommenderEvaluator evaluator = new Track1RecommenderEvaluator(dataFileDirectory);    DataModel model = new KDDCupDataModel(KDDCupDataModel.getTrainingFile(dataFileDirectory));    double evaluation = evaluator.evaluate(new Track1RecommenderBuilder(), null, model, Float.NaN, Float.NaN);    log.info(String.valueOf(evaluation));}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    File dataFileDirectory = new File(args[0]);    if (!dataFileDirectory.exists() || !dataFileDirectory.isDirectory()) {        throw new IllegalArgumentException("Bad data file directory: " + dataFileDirectory);    }    long start = System.currentTimeMillis();    KDDCupDataModel model = new KDDCupDataModel(KDDCupDataModel.getTrainingFile(dataFileDirectory));    Track1Recommender recommender = new Track1Recommender(model);    long end = System.currentTimeMillis();    log.info("Loaded model in {}s", (end - start) / 1000);    start = end;    Collection<Track1Callable> callables = new ArrayList<>();    for (Pair<PreferenceArray, long[]> tests : new DataFileIterable(KDDCupDataModel.getTestFile(dataFileDirectory))) {        PreferenceArray userTest = tests.getFirst();        callables.add(new Track1Callable(recommender, userTest));    }    int cores = Runtime.getRuntime().availableProcessors();    log.info("Running on {} cores", cores);    ExecutorService executor = Executors.newFixedThreadPool(cores);    List<Future<byte[]>> results = executor.invokeAll(callables);    executor.shutdown();    end = System.currentTimeMillis();    log.info("Ran recommendations in {}s", (end - start) / 1000);    start = end;    try (OutputStream out = new BufferedOutputStream(new FileOutputStream(new File(args[1])))) {        for (Future<byte[]> result : results) {            for (byte estimate : result.get()) {                out.write(estimate);            }        }    }    end = System.currentTimeMillis();    log.info("Wrote output in {}s", (end - start) / 1000);}
4bd88ca141a3deec266891ce1f59a5b0cf28b3cd76314d24831443c2c964f4d5
itemSimilarity
public double itemSimilarity(long itemID1, long itemID2) throws TasteException
{    return contentSimilarity.itemSimilarity(itemID1, itemID2) * cfSimilarity.itemSimilarity(itemID1, itemID2);}
3ce3330a48ace40db1c9361681134076e4b81fff6ebc87e5e2468a3d2fa8099b
itemSimilarities
public double[] itemSimilarities(long itemID1, long[] itemID2s) throws TasteException
{    double[] result = contentSimilarity.itemSimilarities(itemID1, itemID2s);    double[] multipliers = cfSimilarity.itemSimilarities(itemID1, itemID2s);    for (int i = 0; i < result.length; i++) {        result[i] *= multipliers[i];    }    return result;}
da77e35d28c590f4b271e5b2b7f639c465574b8f17a1ef2f1df63e0152c57e8b
refresh
public void refresh(Collection<Refreshable> alreadyRefreshed)
{    cfSimilarity.refresh(alreadyRefreshed);}
e355789d60919744490937161ea474817ce692de77263198004a947480efd140
call
public UserResult call() throws TasteException
{    int testSize = userTest.length();    if (testSize != 6) {        throw new IllegalArgumentException("Expecting 6 items for user but got " + userTest);    }    long userID = userTest.get(0).getUserID();    TreeMap<Double, Long> estimateToItemID = new TreeMap<>(Collections.reverseOrder());    for (int i = 0; i < testSize; i++) {        long itemID = userTest.getItemID(i);        double estimate;        try {            estimate = recommender.estimatePreference(userID, itemID);        } catch (NoSuchItemException nsie) {                        log.warn("Unknown item {}; OK unless this is the real contest data", itemID);            continue;        }        if (!Double.isNaN(estimate)) {            estimateToItemID.put(estimate, itemID);        }    }    Collection<Long> itemIDs = estimateToItemID.values();    List<Long> topThree = new ArrayList<>(itemIDs);    if (topThree.size() > 3) {        topThree = topThree.subList(0, 3);    } else if (topThree.size() < 3) {        log.warn("Unable to recommend three items for {}", userID);                Collection<Long> newItemIDs = new HashSet<>(3);        newItemIDs.addAll(itemIDs);        int i = 0;        while (i < testSize && newItemIDs.size() < 3) {            newItemIDs.add(userTest.getItemID(i));            i++;        }        topThree = new ArrayList<>(newItemIDs);    }    if (topThree.size() != 3) {        throw new IllegalStateException();    }    boolean[] result = new boolean[testSize];    for (int i = 0; i < testSize; i++) {        result[i] = topThree.contains(userTest.getItemID(i));    }    if (COUNT.incrementAndGet() % 1000 == 0) {        log.info("Completed {} users", COUNT.get());    }    return new UserResult(userID, result);}
2dc6b0153d6772fcc089075e32bcd2d4f93daa3143e3a889d7821635b62ed9fe
recommend
public List<RecommendedItem> recommend(long userID, int howMany) throws TasteException
{    return recommender.recommend(userID, howMany);}
d15575e3c7219fa78f3f939060474f9f6e1b3d7a970e542069957a25a02fb5d4
recommend
public List<RecommendedItem> recommend(long userID, int howMany, boolean includeKnownItems) throws TasteException
{    return recommend(userID, howMany, null, includeKnownItems);}
82cca6a764b4f51c39392acfde0a28aced7e68d46f3f48675d7e2aa136c3b334
recommend
public List<RecommendedItem> recommend(long userID, int howMany, IDRescorer rescorer) throws TasteException
{    return recommender.recommend(userID, howMany, rescorer, false);}
cae55eaeb500f9cfd9e012eff77e31d3bd1d8c4362d52fedefd3790d2b7900d6
recommend
public List<RecommendedItem> recommend(long userID, int howMany, IDRescorer rescorer, boolean includeKnownItems) throws TasteException
{    return recommender.recommend(userID, howMany, rescorer, includeKnownItems);}
fe4075a1aad10eb52e9a33b25ff2a59f9af6b1541778182edc3aa82095b47ee2
estimatePreference
public float estimatePreference(long userID, long itemID) throws TasteException
{    return recommender.estimatePreference(userID, itemID);}
50d76af25ae801a2139a90c576940f9f9838c80f93853951415d27753efe6193
setPreference
public void setPreference(long userID, long itemID, float value) throws TasteException
{    recommender.setPreference(userID, itemID, value);}
b8fc0c1b44ecc54ed269a5d79a52cada03c7abb05284d3d33b03ade9d9a86320
removePreference
public void removePreference(long userID, long itemID) throws TasteException
{    recommender.removePreference(userID, itemID);}
9cc8860ae5e18fe9fdcc3faca0fad6e9d7eb4076efef8c2790ec7efad6fe6102
getDataModel
public DataModel getDataModel()
{    return recommender.getDataModel();}
da77e35d28c590f4b271e5b2b7f639c465574b8f17a1ef2f1df63e0152c57e8b
refresh
public void refresh(Collection<Refreshable> alreadyRefreshed)
{    recommender.refresh(alreadyRefreshed);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "Track1Recommender[recommender:" + recommender + ']';}
e26f26b33b5dca480753c13f0e28794c1c0e1f19cef251c09738dbac6d2732f6
buildRecommender
public Recommender buildRecommender(DataModel dataModel) throws TasteException
{    return new Track2Recommender(dataModel, ((KDDCupDataModel) dataModel).getDataFileDirectory());}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    File dataFileDirectory = new File(args[0]);    if (!dataFileDirectory.exists() || !dataFileDirectory.isDirectory()) {        throw new IllegalArgumentException("Bad data file directory: " + dataFileDirectory);    }    long start = System.currentTimeMillis();    KDDCupDataModel model = new KDDCupDataModel(KDDCupDataModel.getTrainingFile(dataFileDirectory));    Track2Recommender recommender = new Track2Recommender(model, dataFileDirectory);    long end = System.currentTimeMillis();    log.info("Loaded model in {}s", (end - start) / 1000);    start = end;    Collection<Track2Callable> callables = new ArrayList<>();    for (Pair<PreferenceArray, long[]> tests : new DataFileIterable(KDDCupDataModel.getTestFile(dataFileDirectory))) {        PreferenceArray userTest = tests.getFirst();        callables.add(new Track2Callable(recommender, userTest));    }    int cores = Runtime.getRuntime().availableProcessors();    log.info("Running on {} cores", cores);    ExecutorService executor = Executors.newFixedThreadPool(cores);    List<Future<UserResult>> futures = executor.invokeAll(callables);    executor.shutdown();    end = System.currentTimeMillis();    log.info("Ran recommendations in {}s", (end - start) / 1000);    start = end;    try (OutputStream out = new BufferedOutputStream(new FileOutputStream(new File(args[1])))) {        long lastUserID = Long.MIN_VALUE;        for (Future<UserResult> future : futures) {            UserResult result = future.get();            long userID = result.getUserID();            if (userID <= lastUserID) {                throw new IllegalStateException();            }            lastUserID = userID;            out.write(result.getResultBytes());        }    }    end = System.currentTimeMillis();    log.info("Wrote output in {}s", (end - start) / 1000);}
1c5d20c5d54ee4cfb4640dd12e45de0e8541572c2e30d9b080cf5615d4d17bf3
parse
private static long parse(String value)
{    return NO_VALUE.equals(value) ? NO_VALUE_ID : Long.parseLong(value);}
e926f1c660542f17b508e16767d94fd5722ac3fb759e09b3ee26efacc49144be
getTrackID
public long getTrackID()
{    return trackID;}
abfc19d80c7043297194098e187a525df2df785bc1c07aa78474cf9ff2d50435
getAlbumID
public long getAlbumID()
{    return albumID;}
9dcbd33a6130dab2065895803930100ee275902ac299642157bb82c9f31e6168
getArtistID
public long getArtistID()
{    return artistID;}
75fea9ebbdf977669a4c7ef0559878538785f0d44846cc47b1f34a30ab9a676c
getGenreIDs
public FastIDSet getGenreIDs()
{    return genreIDs;}
50e6b7f96cf22dd8e2565708ad17537816c51b9936cd4736bafb36eedd8da9e6
itemSimilarity
public double itemSimilarity(long itemID1, long itemID2)
{    if (itemID1 == itemID2) {        return 1.0;    }    TrackData data1 = trackData.get(itemID1);    TrackData data2 = trackData.get(itemID2);    if (data1 == null || data2 == null) {        return 0.0;    }        if (data1.getAlbumID() != TrackData.NO_VALUE_ID && data1.getAlbumID() == data2.getAlbumID()) {        return 0.9;    }        if (data1.getArtistID() != TrackData.NO_VALUE_ID && data1.getArtistID() == data2.getArtistID()) {        return 0.7;    }        FastIDSet genres1 = data1.getGenreIDs();    FastIDSet genres2 = data2.getGenreIDs();    if (genres1 == null || genres2 == null) {        return 0.0;    }    int intersectionSize = genres1.intersectionSize(genres2);    if (intersectionSize == 0) {        return 0.0;    }    int unionSize = genres1.size() + genres2.size() - intersectionSize;    return intersectionSize / (4.0 * unionSize);}
00d4cdca08b465288a485bb65a4128cfd1261b7f5ec59a0e050b082adf455897
itemSimilarities
public double[] itemSimilarities(long itemID1, long[] itemID2s)
{    int length = itemID2s.length;    double[] result = new double[length];    for (int i = 0; i < length; i++) {        result[i] = itemSimilarity(itemID1, itemID2s[i]);    }    return result;}
d5bcaad044f6702e70f7c2dee9d117cb33bc4b6e4e31fc0a00a6ffcfb2e5ca20
allSimilarItemIDs
public long[] allSimilarItemIDs(long itemID)
{    FastIDSet allSimilarItemIDs = new FastIDSet();    LongPrimitiveIterator allItemIDs = trackData.keySetIterator();    while (allItemIDs.hasNext()) {        long possiblySimilarItemID = allItemIDs.nextLong();        if (!Double.isNaN(itemSimilarity(itemID, possiblySimilarItemID))) {            allSimilarItemIDs.add(possiblySimilarItemID);        }    }    return allSimilarItemIDs.toArray();}
da77e35d28c590f4b271e5b2b7f639c465574b8f17a1ef2f1df63e0152c57e8b
refresh
public void refresh(Collection<Refreshable> alreadyRefreshed)
{}
f6291b447e197e279017739fa55cf012e1c9d4eed6fb9eb0dd5d639a28f5227d
getUserID
public long getUserID()
{    return userID;}
bc85e7e1a1cd9396ca70e92aaab37fcb6902064423562d4fb291d6499fd8c3a2
getResultBytes
public byte[] getResultBytes()
{    return resultBytes;}
bd0edbc9a3d0385c8dd0ba423bf949835f7041862911cb395faa3e28ba85b5cb
getRatings
public static File getRatings(String[] args) throws OptionException
{    DefaultOptionBuilder obuilder = new DefaultOptionBuilder();    ArgumentBuilder abuilder = new ArgumentBuilder();    GroupBuilder gbuilder = new GroupBuilder();    Option inputOpt = obuilder.withLongName("input").withRequired(false).withShortName("i").withArgument(abuilder.withName("input").withMinimum(1).withMaximum(1).create()).withDescription("The Path for input data directory.").create();    Option helpOpt = DefaultOptionCreator.helpOption();    Group group = gbuilder.withName("Options").withOption(inputOpt).withOption(helpOpt).create();    Parser parser = new Parser();    parser.setGroup(group);    CommandLine cmdLine = parser.parse(args);    if (cmdLine.hasOption(helpOpt)) {        CommandLineUtil.printHelp(group);        return null;    }    return cmdLine.hasOption(inputOpt) ? new File(cmdLine.getValue(inputOpt).toString()) : null;}
365a24fc75086b6a0e91f9b072bd58c9280846cc05f333f28ede18388f27ce89
main
public static void main(String[] args) throws IOException
{    if (args.length != 4) {        System.err.println("Usage: NetflixDatasetConverter /path/to/training_set/ /path/to/qualifying.txt " + "/path/to/judging.txt /path/to/destination");        return;    }    String trainingDataDir = args[0];    String qualifyingTxt = args[1];    String judgingTxt = args[2];    Path outputPath = new Path(args[3]);    Configuration conf = new Configuration();    FileSystem fs = FileSystem.get(outputPath.toUri(), conf);    Preconditions.checkArgument(trainingDataDir != null, "Training Data location needs to be specified");    log.info("Creating training set at {}/trainingSet/ratings.tsv ...", outputPath);    try (BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(fs.create(new Path(outputPath, "trainingSet/ratings.tsv")), Charsets.UTF_8))) {        int ratingsProcessed = 0;        for (File movieRatings : new File(trainingDataDir).listFiles()) {            try (FileLineIterator lines = new FileLineIterator(movieRatings)) {                boolean firstLineRead = false;                String movieID = null;                while (lines.hasNext()) {                    String line = lines.next();                    if (firstLineRead) {                        String[] tokens = SEPARATOR.split(line);                        String userID = tokens[0];                        String rating = tokens[1];                        writer.write(userID + TAB + movieID + TAB + rating + NEWLINE);                        ratingsProcessed++;                        if (ratingsProcessed % 1000000 == 0) {                            log.info("{} ratings processed...", ratingsProcessed);                        }                    } else {                        movieID = line.replaceAll(MOVIE_DENOTER, "");                        firstLineRead = true;                    }                }            }        }        log.info("{} ratings processed. done.", ratingsProcessed);    }    log.info("Reading probes...");    List<Preference> probes = new ArrayList<>(2817131);    long currentMovieID = -1;    for (String line : new FileLineIterable(new File(qualifyingTxt))) {        if (line.contains(MOVIE_DENOTER)) {            currentMovieID = Long.parseLong(line.replaceAll(MOVIE_DENOTER, ""));        } else {            long userID = Long.parseLong(SEPARATOR.split(line)[0]);            probes.add(new GenericPreference(userID, currentMovieID, 0));        }    }    log.info("{} probes read...", probes.size());    log.info("Reading ratings, creating probe set at {}/probeSet/ratings.tsv ...", outputPath);    try (BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(fs.create(new Path(outputPath, "probeSet/ratings.tsv")), Charsets.UTF_8))) {        int ratingsProcessed = 0;        for (String line : new FileLineIterable(new File(judgingTxt))) {            if (line.contains(MOVIE_DENOTER)) {                currentMovieID = Long.parseLong(line.replaceAll(MOVIE_DENOTER, ""));            } else {                float rating = Float.parseFloat(SEPARATOR.split(line)[0]);                Preference pref = probes.get(ratingsProcessed);                Preconditions.checkState(pref.getItemID() == currentMovieID);                ratingsProcessed++;                writer.write(pref.getUserID() + TAB + pref.getItemID() + TAB + rating + NEWLINE);                if (ratingsProcessed % 1000000 == 0) {                    log.info("{} ratings processed...", ratingsProcessed);                }            }        }        log.info("{} ratings processed. done.", ratingsProcessed);    }}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    if (args.length != 1) {        System.err.println("Need path to ratings.dat of the movielens1M dataset as argument!");        System.exit(-1);    }    File resultFile = new File(System.getProperty("java.io.tmpdir"), "similarities.csv");    if (resultFile.exists()) {        resultFile.delete();    }    DataModel dataModel = new GroupLensDataModel(new File(args[0]));    ItemBasedRecommender recommender = new GenericItemBasedRecommender(dataModel, new LogLikelihoodSimilarity(dataModel));    BatchItemSimilarities batch = new MultithreadedBatchItemSimilarities(recommender, 5);    int numSimilarities = batch.computeItemSimilarities(Runtime.getRuntime().availableProcessors(), 1, new FileSimilarItemsWriter(resultFile));    System.out.println("Computed " + numSimilarities + " similarities for " + dataModel.getNumItems() + " items " + "and saved them to " + resultFile.getAbsolutePath());}
a71cd588a47363d2d521046827ce205fd94e7f63c5b078f037a086e52ffd3d6d
convertGLFile
private static File convertGLFile(File originalFile) throws IOException
{        File resultFile = new File(new File(System.getProperty("java.io.tmpdir")), "ratings.txt");    if (resultFile.exists()) {        resultFile.delete();    }    try (Writer writer = new OutputStreamWriter(new FileOutputStream(resultFile), Charsets.UTF_8)) {        for (String line : new FileLineIterable(originalFile, false)) {            int lastDelimiterStart = line.lastIndexOf(COLON_DELIMTER);            if (lastDelimiterStart < 0) {                throw new IOException("Unexpected input format on line: " + line);            }            String subLine = line.substring(0, lastDelimiterStart);            String convertedLine = COLON_DELIMITER_PATTERN.matcher(subLine).replaceAll(",");            writer.write(convertedLine);            writer.write('\n');        }    } catch (IOException ioe) {        resultFile.delete();        throw ioe;    }    return resultFile;}
9fe4f0217f4c270c0928dacf82bdf19dc640bd381d7feebb4ae76e6f0e1334ea
readResourceToTempFile
public static File readResourceToTempFile(String resourceName) throws IOException
{    InputSupplier<? extends InputStream> inSupplier;    try {        URL resourceURL = Resources.getResource(GroupLensDataModel.class, resourceName);        inSupplier = Resources.newInputStreamSupplier(resourceURL);    } catch (IllegalArgumentException iae) {        File resourceFile = new File("src/main/java" + resourceName);        inSupplier = Files.newInputStreamSupplier(resourceFile);    }    File tempFile = File.createTempFile("taste", null);    tempFile.deleteOnExit();    Files.copy(inSupplier, tempFile);    return tempFile;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return "GroupLensDataModel";}
6b7dd49be7482fc8ee0fbe8bd0f24522f2a718c8c816a3d7b048fb4688eb6373
setup
protected void setup(Context context) throws IOException, InterruptedException
{    useListName = Boolean.parseBoolean(context.getConfiguration().get(PrepEmailVectorsDriver.USE_LIST_NAME));}
fc1e428e426e46a32a92783347cd800582026b43336f9729a249480992d42a51
map
protected void map(WritableComparable<?> key, VectorWritable value, Context context) throws IOException, InterruptedException
{    String input = key.toString();        String[] splits = SLASH.split(input);        if (splits.length >= 3) {        StringBuilder bldr = new StringBuilder();        bldr.append(escape(splits[1]));        if (useListName) {            bldr.append('_').append(escape(splits[2]));        }        context.write(new Text(bldr.toString()), value);    }}
2bb2229b333189aae306b40d9347eadfd0dd62b78d478cf3d5a04ab8c50dd5e3
escape
private static String escape(CharSequence value)
{    return DASH_DOT.matcher(value).replaceAll("_").toLowerCase(Locale.ENGLISH);}
6b7dd49be7482fc8ee0fbe8bd0f24522f2a718c8c816a3d7b048fb4688eb6373
setup
protected void setup(Context context) throws IOException, InterruptedException
{    maxItemsPerLabel = Long.parseLong(context.getConfiguration().get(PrepEmailVectorsDriver.ITEMS_PER_CLASS));}
37fd80db0b16c9e89d6b4043835cc61bc7706b210595b841b4d8875b3fa16a2f
reduce
protected void reduce(Text key, Iterable<VectorWritable> values, Context context) throws IOException, InterruptedException
{        long i = 0;    Iterator<VectorWritable> iterator = values.iterator();    while (i < maxItemsPerLabel && iterator.hasNext()) {        context.write(key, iterator.next());        i++;    }}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    ToolRunner.run(new Configuration(), new PrepEmailVectorsDriver(), args);}
aacecb0f01750d985b78d806dc3c134f0da79efe2752957e0f93ecf5cbf9e492
run
public int run(String[] args) throws Exception
{    addInputOption();    addOutputOption();    addOption(DefaultOptionCreator.overwriteOption().create());    addOption("maxItemsPerLabel", "mipl", "The maximum number of items per label.  Can be useful for making the " + "training sets the same size", String.valueOf(100000));    addOption(buildOption("useListName", "ul", "Use the name of the list as part of the label.  If not set, then " + "just use the project name", false, false, "false"));    Map<String, List<String>> parsedArgs = parseArguments(args);    if (parsedArgs == null) {        return -1;    }    Path input = getInputPath();    Path output = getOutputPath();    if (hasOption(DefaultOptionCreator.OVERWRITE_OPTION)) {        HadoopUtil.delete(getConf(), output);    }    Job convertJob = prepareJob(input, output, SequenceFileInputFormat.class, PrepEmailMapper.class, Text.class, VectorWritable.class, PrepEmailReducer.class, Text.class, VectorWritable.class, SequenceFileOutputFormat.class);    convertJob.getConfiguration().set(ITEMS_PER_CLASS, getOption("maxItemsPerLabel"));    convertJob.getConfiguration().set(USE_LIST_NAME, String.valueOf(hasOption("useListName")));    boolean succeeded = convertJob.waitForCompletion(true);    return succeeded ? 0 : -1;}
07a87eb7a7fbc20325136cde5f968fab65d6cf7fe31d28f54c4ae34f5484c92d
getEncoder
public FeatureVectorEncoder getEncoder()
{    return encoder;}
1ba4f167a529126f756a837858e77e73d85deff69702b064c8b65944530de515
getBias
public FeatureVectorEncoder getBias()
{    return bias;}
84a65d1ef4f4975f3504220d6b7b0e0a57dabc36b0e99ded5305364698c4e6d5
getRandom
public Random getRandom()
{    return rand;}
9360f4dba5fbe58fcd0ed797bc63917a4bcddf5118787654ff5322d7918e7adf
encodeFeatureVector
public Vector encodeFeatureVector(File file, int actual, int leakType, Multiset<String> overallCounts) throws IOException
{    long date = (long) (1000 * (DATE_REFERENCE + actual * MONTH + 1 * WEEK * rand.nextDouble()));    Multiset<String> words = ConcurrentHashMultiset.create();    try (BufferedReader reader = Files.newReader(file, Charsets.UTF_8)) {        String line = reader.readLine();        Reader dateString = new StringReader(DATE_FORMATS[leakType % 3].format(new Date(date)));        countWords(analyzer, words, dateString, overallCounts);        while (line != null && !line.isEmpty()) {            boolean countHeader = (line.startsWith("From:") || line.startsWith("Subject:") || line.startsWith("Keywords:") || line.startsWith("Summary:")) && leakType < 6;            do {                Reader in = new StringReader(line);                if (countHeader) {                    countWords(analyzer, words, in, overallCounts);                }                line = reader.readLine();            } while (line != null && line.startsWith(" "));        }        if (leakType < 3) {            countWords(analyzer, words, reader, overallCounts);        }    }    Vector v = new RandomAccessSparseVector(FEATURES);    bias.addToVector("", 1, v);    for (String word : words.elementSet()) {        encoder.addToVector(word, Math.log1p(words.count(word)), v);    }    return v;}
9caadcc53ba7bad77f9a3a3c530590f4f39a53aa19de1aa8d50595eba921a702
countWords
public static void countWords(Analyzer analyzer, Collection<String> words, Reader in, Multiset<String> overallCounts) throws IOException
{    TokenStream ts = analyzer.tokenStream("text", in);    ts.addAttribute(CharTermAttribute.class);    ts.reset();    while (ts.incrementToken()) {        String s = ts.getAttribute(CharTermAttribute.class).toString();        words.add(s);    }    overallCounts.addAll(words);    ts.end();    Closeables.close(ts, true);}
0c9cde75d264bdef3dff9d11608db06393c707b8c40eb6d6ba5fe76e159c9da2
readFromURL
private static void readFromURL(String url, boolean assignIDs) throws IOException
{        hiddenSequences = new LinkedList<>();    observedSequences = new LinkedList<>();    readLines = 0;        List<Integer> observedSequence = new LinkedList<>();    List<Integer> hiddenSequence = new LinkedList<>();    for (String line : Resources.readLines(new URL(url), Charsets.UTF_8)) {        if (line.isEmpty()) {                        int[] observedSequenceArray = new int[observedSequence.size()];            int[] hiddenSequenceArray = new int[hiddenSequence.size()];            for (int i = 0; i < observedSequence.size(); ++i) {                observedSequenceArray[i] = observedSequence.get(i);                hiddenSequenceArray[i] = hiddenSequence.get(i);            }                        hiddenSequences.add(hiddenSequenceArray);            observedSequences.add(observedSequenceArray);                        observedSequence.clear();            hiddenSequence.clear();            continue;        }        readLines++;                String[] tags = SPACE.split(line);                if (assignIDs) {            if (!wordIDs.containsKey(tags[0])) {                wordIDs.put(tags[0], nextWordId++);            }            if (!tagIDs.containsKey(tags[1])) {                tagIDs.put(tags[1], nextTagId++);            }        }                Integer wordID = wordIDs.get(tags[0]);        Integer tagID = tagIDs.get(tags[1]);                if (wordID == null) {            observedSequence.add(0);        } else {            observedSequence.add(wordID);        }        if (tagID == null) {            hiddenSequence.add(0);        } else {            hiddenSequence.add(tagID);        }    }        if (!observedSequence.isEmpty()) {        int[] observedSequenceArray = new int[observedSequence.size()];        int[] hiddenSequenceArray = new int[hiddenSequence.size()];        for (int i = 0; i < observedSequence.size(); ++i) {            observedSequenceArray[i] = observedSequence.get(i);            hiddenSequenceArray[i] = hiddenSequence.get(i);        }                hiddenSequences.add(hiddenSequenceArray);        observedSequences.add(observedSequenceArray);    }}
383da519e3857acf9572a2976b02155e5f5f036abc53309912ae0d0ca206de32
trainModel
private static void trainModel(String trainingURL) throws IOException
{        tagIDs = new HashMap<>(44);        wordIDs = new HashMap<>(19122);        log.info("Reading and parsing training data file from URL: {}", trainingURL);    long start = System.currentTimeMillis();    readFromURL(trainingURL, true);    long end = System.currentTimeMillis();    double duration = (end - start) / 1000.0;    log.info("Parsing done in {} seconds!", duration);    log.info("Read {} lines containing {} sentences with a total of {} distinct words and {} distinct POS tags.", readLines, hiddenSequences.size(), nextWordId - 1, nextTagId - 1);    start = System.currentTimeMillis();    taggingModel = HmmTrainer.trainSupervisedSequence(nextTagId, nextWordId, hiddenSequences, observedSequences, 0.05);                Matrix emissions = taggingModel.getEmissionMatrix();    for (int i = 0; i < taggingModel.getNrOfHiddenStates(); ++i) {        emissions.setQuick(i, 0, 0.1 / taggingModel.getNrOfHiddenStates());    }    int nnptag = tagIDs.get("NNP");    emissions.setQuick(nnptag, 0, 1 / (double) taggingModel.getNrOfHiddenStates());        HmmUtils.normalizeModel(taggingModel);        taggingModel.registerHiddenStateNames(tagIDs);    taggingModel.registerOutputStateNames(wordIDs);    end = System.currentTimeMillis();    duration = (end - start) / 1000.0;    log.info("Trained HMM models in {} seconds!", duration);}
3186b10cf42132986ec495cd2a1277e4a3aa2481934456010c74ad5899359825
testModel
private static void testModel(String testingURL) throws IOException
{    log.info("Reading and parsing test data file from URL: {}", testingURL);    long start = System.currentTimeMillis();    readFromURL(testingURL, false);    long end = System.currentTimeMillis();    double duration = (end - start) / 1000.0;    log.info("Parsing done in {} seconds!", duration);    log.info("Read {} lines containing {} sentences.", readLines, hiddenSequences.size());    start = System.currentTimeMillis();    int errorCount = 0;    int totalCount = 0;    for (int i = 0; i < observedSequences.size(); ++i) {                int[] posEstimate = HmmEvaluator.decode(taggingModel, observedSequences.get(i), false);                int[] posExpected = hiddenSequences.get(i);        for (int j = 0; j < posExpected.length; ++j) {            totalCount++;            if (posEstimate[j] != posExpected[j]) {                errorCount++;            }        }    }    end = System.currentTimeMillis();    duration = (end - start) / 1000.0;    log.info("POS tagged test file in {} seconds!", duration);    double errorRate = (double) errorCount / totalCount;    log.info("Tagged the test file with an error rate of: {}", errorRate);}
56bc1adda7255571038faa836fec3e142c488cc5c0a9623a3094b87708d2e759
tagSentence
private static List<String> tagSentence(String sentence)
{            sentence = sentence.replaceAll("[,.!?:;\"]", " $0 ");    sentence = sentence.replaceAll("''", " '' ");        String[] tokens = SPACES.split(sentence);        int[] observedSequence = HmmUtils.encodeStateSequence(taggingModel, Arrays.asList(tokens), true, 0);        int[] hiddenSequence = HmmEvaluator.decode(taggingModel, observedSequence, false);        return HmmUtils.decodeStateSequence(taggingModel, hiddenSequence, false, null);}
365a24fc75086b6a0e91f9b072bd58c9280846cc05f333f28ede18388f27ce89
main
public static void main(String[] args) throws IOException
{        trainModel("http://www.jaist.ac.jp/~hieuxuan/flexcrfs/CoNLL2000-NP/train.txt");    testModel("http://www.jaist.ac.jp/~hieuxuan/flexcrfs/CoNLL2000-NP/test.txt");        String test = "McDonalds is a huge company with many employees .";    String[] testWords = SPACE.split(test);    List<String> posTags = tagSentence(test);    for (int i = 0; i < posTags.size(); ++i) {        log.info("{}[{}]", testWords[i], posTags.get(i));    }}
0e888ec5c1da2947947483e683cec167962e31f2819c135a88bae1989aeafb6a
createAdaptiveLogisticRegression
public AdaptiveLogisticRegression createAdaptiveLogisticRegression()
{    if (alr == null) {        alr = new AdaptiveLogisticRegression(getMaxTargetCategories(), getNumFeatures(), createPrior(prior, priorOption));        alr.setInterval(interval);        alr.setAveragingWindow(averageWindow);        alr.setThreadCount(threads);        alr.setAucEvaluator(createAUC(auc));    }    return alr;}
71b497bb02f073bc80a75a097e8e8685b1b36a506217e5684edd9112b396fc05
checkParameters
public void checkParameters()
{    if (prior != null) {        String priorUppercase = prior.toUpperCase(Locale.ENGLISH).trim();        if (("TP".equals(priorUppercase) || "EBP".equals(priorUppercase)) && Double.isNaN(priorOption)) {            throw new IllegalArgumentException("You must specify a double value for TPrior and ElasticBandPrior.");        }    }}
2104b99c338e9ffd7ecaac4e6fc1ad174f56086872ea679939480f9d3110d1a2
createPrior
private static PriorFunction createPrior(String cmd, double priorOption)
{    if (cmd == null) {        return null;    }    if ("L1".equals(cmd.toUpperCase(Locale.ENGLISH).trim())) {        return new L1();    }    if ("L2".equals(cmd.toUpperCase(Locale.ENGLISH).trim())) {        return new L2();    }    if ("UP".equals(cmd.toUpperCase(Locale.ENGLISH).trim())) {        return new UniformPrior();    }    if ("TP".equals(cmd.toUpperCase(Locale.ENGLISH).trim())) {        return new TPrior(priorOption);    }    if ("EBP".equals(cmd.toUpperCase(Locale.ENGLISH).trim())) {        return new ElasticBandPrior(priorOption);    }    return null;}
df9f6c0592fee1f1d115b0ffad22b0d854fba205476ba9cfadbb9bfc0e43f736
createAUC
private static OnlineAuc createAUC(String cmd)
{    if (cmd == null) {        return null;    }    if ("GLOBAL".equals(cmd.toUpperCase(Locale.ENGLISH).trim())) {        return new GlobalOnlineAuc();    }    if ("GROUPED".equals(cmd.toUpperCase(Locale.ENGLISH).trim())) {        return new GroupedOnlineAuc();    }    return null;}
de10475e403bf08a403b09b2316c4830f5ea3b9a0a89369656d07e8bce50d543
saveTo
public void saveTo(OutputStream out) throws IOException
{    if (alr != null) {        alr.close();    }    setTargetCategories(getCsvRecordFactory().getTargetCategories());    write(new DataOutputStream(out));}
a894510dd4db439ff8e17ae1059489dc3abc97178e5932ceed0c70c3af165401
write
public void write(DataOutput out) throws IOException
{    out.writeUTF(getTargetVariable());    out.writeInt(getTypeMap().size());    for (Map.Entry<String, String> entry : getTypeMap().entrySet()) {        out.writeUTF(entry.getKey());        out.writeUTF(entry.getValue());    }    out.writeInt(getNumFeatures());    out.writeInt(getMaxTargetCategories());    out.writeInt(getTargetCategories().size());    for (String category : getTargetCategories()) {        out.writeUTF(category);    }    out.writeInt(interval);    out.writeInt(averageWindow);    out.writeInt(threads);    out.writeUTF(prior);    out.writeDouble(priorOption);    out.writeUTF(auc);        alr.write(out);}
5478cc5683f6dfd4515c383752d7c803555efc63d03fd84a03ba8dcd17eb4324
readFields
public void readFields(DataInput in) throws IOException
{    setTargetVariable(in.readUTF());    int typeMapSize = in.readInt();    Map<String, String> typeMap = new HashMap<>(typeMapSize);    for (int i = 0; i < typeMapSize; i++) {        String key = in.readUTF();        String value = in.readUTF();        typeMap.put(key, value);    }    setTypeMap(typeMap);    setNumFeatures(in.readInt());    setMaxTargetCategories(in.readInt());    int targetCategoriesSize = in.readInt();    List<String> targetCategories = new ArrayList<>(targetCategoriesSize);    for (int i = 0; i < targetCategoriesSize; i++) {        targetCategories.add(in.readUTF());    }    setTargetCategories(targetCategories);    interval = in.readInt();    averageWindow = in.readInt();    threads = in.readInt();    prior = in.readUTF();    priorOption = in.readDouble();    auc = in.readUTF();    alr = new AdaptiveLogisticRegression();    alr.readFields(in);}
b8fe0be45ab3caa8eebcf72db36fa8210f236c21aa23288e0205463a5b41d946
loadFromStream
private static AdaptiveLogisticModelParameters loadFromStream(InputStream in) throws IOException
{    AdaptiveLogisticModelParameters result = new AdaptiveLogisticModelParameters();    result.readFields(new DataInputStream(in));    return result;}
6b46e9c4354c8147bb790fb0c0c0cb94235bd7eef19a7539be481aed9b432071
loadFromFile
public static AdaptiveLogisticModelParameters loadFromFile(File in) throws IOException
{    try (InputStream input = new FileInputStream(in)) {        return loadFromStream(input);    }}
543a2b749fc06bbd9b3ac2410865347d39bd84a0f940031ead5d259e4c50484f
getInterval
public int getInterval()
{    return interval;}
9579b56c7644137bbda5c94915f31a005e8173fa7390d9a698381a96abbab494
setInterval
public void setInterval(int interval)
{    this.interval = interval;}
ad52f64805a621cf7094e23d6c4bc900ba27820fb27d327b0f42d71a56889b96
getAverageWindow
public int getAverageWindow()
{    return averageWindow;}
1a9ae69f8c58293d80ab79bde41f96c260eee678b2525b563e8a33c2b205c056
setAverageWindow
public void setAverageWindow(int averageWindow)
{    this.averageWindow = averageWindow;}
bb37b044b1bd38215fa8940285c9dab02b3ad34f9c2758a525fed8616d823658
getThreads
public int getThreads()
{    return threads;}
0de19a6f0adebf9500d455fa31e4456e4913127c5e75d5de2b075dd367a150d2
setThreads
public void setThreads(int threads)
{    this.threads = threads;}
9998ac8a9484f27b1d7c143f08d41039fe2be5e7b418d0b21abbed20b5fd2bb2
getPrior
public String getPrior()
{    return prior;}
678ff0d8056ea73954c5762cfb77621a2ff2771916f572c396e0179b43e861b8
setPrior
public void setPrior(String prior)
{    this.prior = prior;}
ec6c8f87bf53c708ec616f3adf5f3e13c661b7b25644715c65e467470f6eb4e6
getAuc
public String getAuc()
{    return auc;}
f5d86542b38f4434278ca72d7ad8bacbdacc568dbe2f043f769ae65fef13757c
setAuc
public void setAuc(String auc)
{    this.auc = auc;}
bbcca45479f946271db9ac3da482bfdd06cf767d84362556b3b728d6e4b303ae
getPriorOption
public double getPriorOption()
{    return priorOption;}
26dd10194443990e3b23b959fd300df035319e0e942431ef60ab5f6d4e7189e3
setPriorOption
public void setPriorOption(double priorOption)
{    this.priorOption = priorOption;}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    List<TelephoneCall> calls = Lists.newArrayList(new TelephoneCallParser("bank-full.csv"));    double heldOutPercentage = 0.10;    for (int run = 0; run < 20; run++) {        Collections.shuffle(calls);        int cutoff = (int) (heldOutPercentage * calls.size());        List<TelephoneCall> test = calls.subList(0, cutoff);        List<TelephoneCall> train = calls.subList(cutoff, calls.size());        OnlineLogisticRegression lr = new OnlineLogisticRegression(NUM_CATEGORIES, TelephoneCall.FEATURES, new L1()).learningRate(1).alpha(1).lambda(0.000001).stepOffset(10000).decayExponent(0.2);        for (int pass = 0; pass < 20; pass++) {            for (TelephoneCall observation : train) {                lr.train(observation.getTarget(), observation.asVector());            }            if (pass % 5 == 0) {                Auc eval = new Auc(0.5);                for (TelephoneCall testCall : test) {                    eval.add(testCall.getTarget(), lr.classifyScalar(testCall.asVector()));                }                System.out.printf("%d, %.4f, %.4f\n", pass, lr.currentLearningRate(), eval.auc());            }        }    }}
58b4fa386fa4fd53d887951025e943023a399653cd6702d0b4e97429f67ebdab
asVector
public Vector asVector()
{    return vector;}
92377bb2eea35c1046e1e8df7eef4774f08d8b36b5f47c8c1f93307e3e54b761
getTarget
public int getTarget()
{    return fields.get("y").equals("no") ? 0 : 1;}
e95165eee0f0dbaed3e3f0bdeb033a8b79a03d2cb5aca22d039fbf674387f0c3
iterator
public Iterator<TelephoneCall> iterator()
{    try {        return new AbstractIterator<TelephoneCall>() {            BufferedReader input = new BufferedReader(new InputStreamReader(Resources.getResource(resourceName).openStream()));            Iterable<String> fieldNames = onSemi.split(input.readLine());            @Override            protected TelephoneCall computeNext() {                try {                    String line = input.readLine();                    if (line == null) {                        return endOfData();                    }                    return new TelephoneCall(fieldNames, onSemi.split(line));                } catch (IOException e) {                    throw new RuntimeException("Error reading data", e);                }            }        };    } catch (IOException e) {        throw new RuntimeException("Error reading data", e);    }}
395d87f182540b1e92fefb9b86fa015369e18646872cbe95c2752a8510aa48fe
computeNext
protected TelephoneCall computeNext()
{    try {        String line = input.readLine();        if (line == null) {            return endOfData();        }        return new TelephoneCall(fieldNames, onSemi.split(line));    } catch (IOException e) {        throw new RuntimeException("Error reading data", e);    }}
c2edeaf3630d7c8d1fbb36bcc5c69047e393ad1184030ee388f4e518fa1998ae
getCsvRecordFactory
public CsvRecordFactory getCsvRecordFactory()
{    if (csv == null) {        csv = new CsvRecordFactory(getTargetVariable(), getTypeMap()).maxTargetValue(getMaxTargetCategories()).includeBiasTerm(useBias());        if (targetCategories != null) {            csv.defineTargetCategories(targetCategories);        }    }    return csv;}
c93a49500a8579bf97ea8842eb7df39a546230c73a7774abeaff2c27161289ed
createRegression
public OnlineLogisticRegression createRegression()
{    if (lr == null) {        lr = new OnlineLogisticRegression(getMaxTargetCategories(), getNumFeatures(), new L1()).lambda(getLambda()).learningRate(getLearningRate()).alpha(1 - 1.0e-3);    }    return lr;}
de10475e403bf08a403b09b2316c4830f5ea3b9a0a89369656d07e8bce50d543
saveTo
public void saveTo(OutputStream out) throws IOException
{    Closeables.close(lr, false);    targetCategories = getCsvRecordFactory().getTargetCategories();    write(new DataOutputStream(out));}
2d1a8b37e0d3885e6a03e725406910b8c8860d088a04be5e805fa0766f725386
loadFrom
public static LogisticModelParameters loadFrom(InputStream in) throws IOException
{    LogisticModelParameters result = new LogisticModelParameters();    result.readFields(new DataInputStream(in));    return result;}
62e29bf7adac58f9e629deae8226f466bf2ca6120986dbea26bd727d6436b3f4
loadFrom
public static LogisticModelParameters loadFrom(File in) throws IOException
{    try (InputStream input = new FileInputStream(in)) {        return loadFrom(input);    }}
a894510dd4db439ff8e17ae1059489dc3abc97178e5932ceed0c70c3af165401
write
public void write(DataOutput out) throws IOException
{    out.writeUTF(targetVariable);    out.writeInt(typeMap.size());    for (Map.Entry<String, String> entry : typeMap.entrySet()) {        out.writeUTF(entry.getKey());        out.writeUTF(entry.getValue());    }    out.writeInt(numFeatures);    out.writeBoolean(useBias);    out.writeInt(maxTargetCategories);    if (targetCategories == null) {        out.writeInt(0);    } else {        out.writeInt(targetCategories.size());        for (String category : targetCategories) {            out.writeUTF(category);        }    }    out.writeDouble(lambda);    out.writeDouble(learningRate);        lr.write(out);}
5478cc5683f6dfd4515c383752d7c803555efc63d03fd84a03ba8dcd17eb4324
readFields
public void readFields(DataInput in) throws IOException
{    targetVariable = in.readUTF();    int typeMapSize = in.readInt();    typeMap = new HashMap<>(typeMapSize);    for (int i = 0; i < typeMapSize; i++) {        String key = in.readUTF();        String value = in.readUTF();        typeMap.put(key, value);    }    numFeatures = in.readInt();    useBias = in.readBoolean();    maxTargetCategories = in.readInt();    int targetCategoriesSize = in.readInt();    targetCategories = new ArrayList<>(targetCategoriesSize);    for (int i = 0; i < targetCategoriesSize; i++) {        targetCategories.add(in.readUTF());    }    lambda = in.readDouble();    learningRate = in.readDouble();    csv = null;    lr = new OnlineLogisticRegression();    lr.readFields(in);}
2257aecdaafef97d549820c374e2f2ddc51c95648026945307ce6c60547d79cd
setTypeMap
public void setTypeMap(Iterable<String> predictorList, List<String> typeList)
{    Preconditions.checkArgument(!typeList.isEmpty(), "Must have at least one type specifier");    typeMap = new HashMap<>();    Iterator<String> iTypes = typeList.iterator();    String lastType = null;    for (Object x : predictorList) {                if (iTypes.hasNext()) {            lastType = iTypes.next();        }        typeMap.put(x.toString(), lastType);    }}
bca450398bbf45f8932ba2692427c78689c3a3333503f6163b5ed105ce4ad7c3
setTargetVariable
public void setTargetVariable(String targetVariable)
{    this.targetVariable = targetVariable;}
3874911c88e3859da12cbcf48c083d50221b6ef92aaafcb29fbee23ed768c82a
setMaxTargetCategories
public void setMaxTargetCategories(int maxTargetCategories)
{    this.maxTargetCategories = maxTargetCategories;}
cef8af688b04b2c9ff55509c96d46c697b282bb134fff7b0e98a02e8cd70a8e1
setNumFeatures
public void setNumFeatures(int numFeatures)
{    this.numFeatures = numFeatures;}
eab6912038f59e2ec4eaba8b811617546d75586f5b1b096210b85435ea2ccaa5
setTargetCategories
public void setTargetCategories(List<String> targetCategories)
{    this.targetCategories = targetCategories;    maxTargetCategories = targetCategories.size();}
01069d17d3797fe03dab72646a466e643c4c3a57c024cb9129592baf2f3766e8
getTargetCategories
public List<String> getTargetCategories()
{    return this.targetCategories;}
fd0e218c04f329f5a803eeab120a0fa37c58d09fcde03ff03965298d28bc86a9
setUseBias
public void setUseBias(boolean useBias)
{    this.useBias = useBias;}
3718318fdc01a7e08f5dc702f2003a8e599510151c8a10c2ff1299eb39b8889d
useBias
public boolean useBias()
{    return useBias;}
26e508a0740540e75bdf1bbe897a06f2cb74862fd4399a86f94063af65e099ee
getTargetVariable
public String getTargetVariable()
{    return targetVariable;}
a33fc41cfcafb913cc8a0b9d310a68173c9ff2e0e6304d6f67bc885f289a351d
getTypeMap
public Map<String, String> getTypeMap()
{    return typeMap;}
8fb0bf5e5982daeb99276fc1bdb8579038ce73744a4aa17f9a2dbeb2375246e5
setTypeMap
public void setTypeMap(Map<String, String> map)
{    this.typeMap = map;}
4a142c3e7355f05c01931684dab7c3e5fbdf3a15cc9c0bfd751d8a0429c7a23e
getNumFeatures
public int getNumFeatures()
{    return numFeatures;}
f6b3df90d47fc17b8323d0ffb8196d787b9976f1376c0cce439b8e5a54cc7785
getMaxTargetCategories
public int getMaxTargetCategories()
{    return maxTargetCategories;}
f106e2c7f9c824d32f6f7400c6bb6ef6acbfcf9eb0d8de72ba64d97e83466cbc
getLambda
public double getLambda()
{    return lambda;}
d52ae0859a4fd8b52ab9bb983dde1232a2ae36d0635d161135349b4df14738f7
setLambda
public void setLambda(double lambda)
{    this.lambda = lambda;}
75822a7317e087d7da163d8206b353021a2f0adcde61bc1f3069374255347e25
getLearningRate
public double getLearningRate()
{    return learningRate;}
e527936e8d9bcbeb66d97436a7ccf917c2802222489bad4021e925eb1e431677
setLearningRate
public void setLearningRate(double learningRate)
{    this.learningRate = learningRate;}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    Preconditions.checkArgument(args.length == 1, "Must have a single argument that names a file or resource.");    try (BufferedReader in = TrainLogistic.open(args[0])) {        String line;        while ((line = in.readLine()) != null) {            System.out.println(line);        }    }}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    mainToOutput(args, new PrintWriter(new OutputStreamWriter(System.out, Charsets.UTF_8), true));}
225b3f68c2119fe5bd88f4db9e244ac633416af47013d1594cc08e5b67386f78
mainToOutput
 static void mainToOutput(String[] args, PrintWriter output) throws Exception
{    if (!parseArgs(args)) {        return;    }    AdaptiveLogisticModelParameters lmp = AdaptiveLogisticModelParameters.loadFromFile(new File(modelFile));    CsvRecordFactory csv = lmp.getCsvRecordFactory();    csv.setIdName(idColumn);    AdaptiveLogisticRegression lr = lmp.createAdaptiveLogisticRegression();    State<Wrapper, CrossFoldLearner> best = lr.getBest();    if (best == null) {        output.println("AdaptiveLogisticRegression has not be trained probably.");        return;    }    CrossFoldLearner learner = best.getPayload().getLearner();    BufferedReader in = TrainAdaptiveLogistic.open(inputFile);    int k = 0;    try (BufferedWriter out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(outputFile), Charsets.UTF_8))) {        out.write(idColumn + ",target,score");        out.newLine();        String line = in.readLine();        csv.firstLine(line);        line = in.readLine();        Map<String, Double> results = new HashMap<>();        while (line != null) {            Vector v = new SequentialAccessSparseVector(lmp.getNumFeatures());            csv.processLine(line, v, false);            Vector scores = learner.classifyFull(v);            results.clear();            if (maxScoreOnly) {                results.put(csv.getTargetLabel(scores.maxValueIndex()), scores.maxValue());            } else {                for (int i = 0; i < scores.size(); i++) {                    results.put(csv.getTargetLabel(i), scores.get(i));                }            }            for (Map.Entry<String, Double> entry : results.entrySet()) {                out.write(csv.getIdString(line) + ',' + entry.getKey() + ',' + entry.getValue());                out.newLine();            }            k++;            if (k % 100 == 0) {                output.println(k + " records processed");            }            line = in.readLine();        }        out.flush();    }    output.println(k + " records processed totally.");}
8a020e634c4458bb50320d2d26ebf2bd0acef21f18ae107ef2766325d626a374
parseArgs
private static boolean parseArgs(String[] args)
{    DefaultOptionBuilder builder = new DefaultOptionBuilder();    Option help = builder.withLongName("help").withDescription("print this list").create();    Option quiet = builder.withLongName("quiet").withDescription("be extra quiet").create();    ArgumentBuilder argumentBuilder = new ArgumentBuilder();    Option inputFileOption = builder.withLongName("input").withRequired(true).withArgument(argumentBuilder.withName("input").withMaximum(1).create()).withDescription("where to get training data").create();    Option modelFileOption = builder.withLongName("model").withRequired(true).withArgument(argumentBuilder.withName("model").withMaximum(1).create()).withDescription("where to get the trained model").create();    Option outputFileOption = builder.withLongName("output").withRequired(true).withDescription("the file path to output scores").withArgument(argumentBuilder.withName("output").withMaximum(1).create()).create();    Option idColumnOption = builder.withLongName("idcolumn").withRequired(true).withDescription("the name of the id column for each record").withArgument(argumentBuilder.withName("idcolumn").withMaximum(1).create()).create();    Option maxScoreOnlyOption = builder.withLongName("maxscoreonly").withDescription("only output the target label with max scores").create();    Group normalArgs = new GroupBuilder().withOption(help).withOption(quiet).withOption(inputFileOption).withOption(modelFileOption).withOption(outputFileOption).withOption(idColumnOption).withOption(maxScoreOnlyOption).create();    Parser parser = new Parser();    parser.setHelpOption(help);    parser.setHelpTrigger("--help");    parser.setGroup(normalArgs);    parser.setHelpFormatter(new HelpFormatter(" ", "", " ", 130));    CommandLine cmdLine = parser.parseAndHelp(args);    if (cmdLine == null) {        return false;    }    inputFile = getStringArgument(cmdLine, inputFileOption);    modelFile = getStringArgument(cmdLine, modelFileOption);    outputFile = getStringArgument(cmdLine, outputFileOption);    idColumn = getStringArgument(cmdLine, idColumnOption);    maxScoreOnly = getBooleanArgument(cmdLine, maxScoreOnlyOption);    return true;}
792f20be503d8a8e5eed90ab9907b8a68b4109900dab69d45b5fc947e2ff2896
getBooleanArgument
private static boolean getBooleanArgument(CommandLine cmdLine, Option option)
{    return cmdLine.hasOption(option);}
1d455240872d875d84c7b1a9ac3b872242b650abe60b25fe4c3807df40624c62
getStringArgument
private static String getStringArgument(CommandLine cmdLine, Option inputFile)
{    return (String) cmdLine.getValue(inputFile);}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    mainToOutput(args, new PrintWriter(new OutputStreamWriter(System.out, Charsets.UTF_8), true));}
225b3f68c2119fe5bd88f4db9e244ac633416af47013d1594cc08e5b67386f78
mainToOutput
 static void mainToOutput(String[] args, PrintWriter output) throws Exception
{    if (parseArgs(args)) {        if (!showAuc && !showConfusion && !showScores) {            showAuc = true;            showConfusion = true;        }        Auc collector = new Auc();        LogisticModelParameters lmp = LogisticModelParameters.loadFrom(new File(modelFile));        CsvRecordFactory csv = lmp.getCsvRecordFactory();        OnlineLogisticRegression lr = lmp.createRegression();        BufferedReader in = TrainLogistic.open(inputFile);        String line = in.readLine();        csv.firstLine(line);        line = in.readLine();        if (showScores) {            output.println("\"target\",\"model-output\",\"log-likelihood\"");        }        while (line != null) {            Vector v = new SequentialAccessSparseVector(lmp.getNumFeatures());            int target = csv.processLine(line, v);            double score = lr.classifyScalar(v);            if (showScores) {                output.printf(Locale.ENGLISH, "%d,%.3f,%.6f%n", target, score, lr.logLikelihood(target, v));            }            collector.add(target, score);            line = in.readLine();        }        if (showAuc) {            output.printf(Locale.ENGLISH, "AUC = %.2f%n", collector.auc());        }        if (showConfusion) {            Matrix m = collector.confusion();            output.printf(Locale.ENGLISH, "confusion: [[%.1f, %.1f], [%.1f, %.1f]]%n", m.get(0, 0), m.get(1, 0), m.get(0, 1), m.get(1, 1));            m = collector.entropy();            output.printf(Locale.ENGLISH, "entropy: [[%.1f, %.1f], [%.1f, %.1f]]%n", m.get(0, 0), m.get(1, 0), m.get(0, 1), m.get(1, 1));        }    }}
8a020e634c4458bb50320d2d26ebf2bd0acef21f18ae107ef2766325d626a374
parseArgs
private static boolean parseArgs(String[] args)
{    DefaultOptionBuilder builder = new DefaultOptionBuilder();    Option help = builder.withLongName("help").withDescription("print this list").create();    Option quiet = builder.withLongName("quiet").withDescription("be extra quiet").create();    Option auc = builder.withLongName("auc").withDescription("print AUC").create();    Option confusion = builder.withLongName("confusion").withDescription("print confusion matrix").create();    Option scores = builder.withLongName("scores").withDescription("print scores").create();    ArgumentBuilder argumentBuilder = new ArgumentBuilder();    Option inputFileOption = builder.withLongName("input").withRequired(true).withArgument(argumentBuilder.withName("input").withMaximum(1).create()).withDescription("where to get training data").create();    Option modelFileOption = builder.withLongName("model").withRequired(true).withArgument(argumentBuilder.withName("model").withMaximum(1).create()).withDescription("where to get a model").create();    Group normalArgs = new GroupBuilder().withOption(help).withOption(quiet).withOption(auc).withOption(scores).withOption(confusion).withOption(inputFileOption).withOption(modelFileOption).create();    Parser parser = new Parser();    parser.setHelpOption(help);    parser.setHelpTrigger("--help");    parser.setGroup(normalArgs);    parser.setHelpFormatter(new HelpFormatter(" ", "", " ", 130));    CommandLine cmdLine = parser.parseAndHelp(args);    if (cmdLine == null) {        return false;    }    inputFile = getStringArgument(cmdLine, inputFileOption);    modelFile = getStringArgument(cmdLine, modelFileOption);    showAuc = getBooleanArgument(cmdLine, auc);    showScores = getBooleanArgument(cmdLine, scores);    showConfusion = getBooleanArgument(cmdLine, confusion);    return true;}
792f20be503d8a8e5eed90ab9907b8a68b4109900dab69d45b5fc947e2ff2896
getBooleanArgument
private static boolean getBooleanArgument(CommandLine cmdLine, Option option)
{    return cmdLine.hasOption(option);}
1d455240872d875d84c7b1a9ac3b872242b650abe60b25fe4c3807df40624c62
getStringArgument
private static String getStringArgument(CommandLine cmdLine, Option inputFile)
{    return (String) cmdLine.getValue(inputFile);}
cfc7d5d924a0bb9a07199807b12a83c912544d344a5d9d109bbe3735bf692017
dissect
public static void dissect(int leakType, Dictionary dictionary, AdaptiveLogisticRegression learningAlgorithm, Iterable<File> files, Multiset<String> overallCounts) throws IOException
{    CrossFoldLearner model = learningAlgorithm.getBest().getPayload().getLearner();    model.close();    Map<String, Set<Integer>> traceDictionary = new TreeMap<>();    ModelDissector md = new ModelDissector();    NewsgroupHelper helper = new NewsgroupHelper();    helper.getEncoder().setTraceDictionary(traceDictionary);    helper.getBias().setTraceDictionary(traceDictionary);    for (File file : permute(files, helper.getRandom()).subList(0, 500)) {        String ng = file.getParentFile().getName();        int actual = dictionary.intern(ng);        traceDictionary.clear();        Vector v = helper.encodeFeatureVector(file, actual, leakType, overallCounts);        md.update(v, traceDictionary, model);    }    List<String> ngNames = new ArrayList<>(dictionary.values());    List<ModelDissector.Weight> weights = md.summary(100);    System.out.println("============");    System.out.println("Model Dissection");    for (ModelDissector.Weight w : weights) {        System.out.printf("%s\t%.1f\t%s\t%.1f\t%s\t%.1f\t%s%n", w.getFeature(), w.getWeight(), ngNames.get(w.getMaxImpact() + 1), w.getCategory(1), w.getWeight(1), w.getCategory(2), w.getWeight(2));    }}
27b55b079e7ccc0e1f79767572cf931b7f9c16212d8e9c19837ad79d0fdbbe93
permute
public static List<File> permute(Iterable<File> files, Random rand)
{    List<File> r = new ArrayList<>();    for (File file : files) {        int i = rand.nextInt(r.size() + 1);        if (i == r.size()) {            r.add(file);        } else {            r.add(r.get(i));            r.set(i, file);        }    }    return r;}
74f7c8c3497b93b258700148e38194b031ee015e0e575872d0efa1340db616d8
analyzeState
 static void analyzeState(SGDInfo info, int leakType, int k, State<AdaptiveLogisticRegression.Wrapper, CrossFoldLearner> best) throws IOException
{    int bump = info.getBumps()[(int) Math.floor(info.getStep()) % info.getBumps().length];    int scale = (int) Math.pow(10, Math.floor(info.getStep() / info.getBumps().length));    double maxBeta;    double nonZeros;    double positive;    double norm;    double lambda = 0;    double mu = 0;    if (best != null) {        CrossFoldLearner state = best.getPayload().getLearner();        info.setAverageCorrect(state.percentCorrect());        info.setAverageLL(state.logLikelihood());        OnlineLogisticRegression model = state.getModels().get(0);                model.close();        Matrix beta = model.getBeta();        maxBeta = beta.aggregate(Functions.MAX, Functions.ABS);        nonZeros = beta.aggregate(Functions.PLUS, new DoubleFunction() {            @Override            public double apply(double v) {                return Math.abs(v) > 1.0e-6 ? 1 : 0;            }        });        positive = beta.aggregate(Functions.PLUS, new DoubleFunction() {            @Override            public double apply(double v) {                return v > 0 ? 1 : 0;            }        });        norm = beta.aggregate(Functions.PLUS, Functions.ABS);        lambda = best.getMappedParams()[0];        mu = best.getMappedParams()[1];    } else {        maxBeta = 0;        nonZeros = 0;        positive = 0;        norm = 0;    }    if (k % (bump * scale) == 0) {        if (best != null) {            File modelFile = new File(System.getProperty("java.io.tmpdir"), "news-group-" + k + ".model");            ModelSerializer.writeBinary(modelFile.getAbsolutePath(), best.getPayload().getLearner().getModels().get(0));        }        info.setStep(info.getStep() + 0.25);        System.out.printf("%.2f\t%.2f\t%.2f\t%.2f\t%.8g\t%.8g\t", maxBeta, nonZeros, positive, norm, lambda, mu);        System.out.printf("%d\t%.3f\t%.2f\t%s%n", k, info.getAverageLL(), info.getAverageCorrect() * 100, LEAK_LABELS[leakType % 3]);    }}
0b41a4c0ac574be18fedcf88e7465eddcb1f8f1a3ad9bbb36e6b37f373bd3830
apply
public double apply(double v)
{    return Math.abs(v) > 1.0e-6 ? 1 : 0;}
0b41a4c0ac574be18fedcf88e7465eddcb1f8f1a3ad9bbb36e6b37f373bd3830
apply
public double apply(double v)
{    return v > 0 ? 1 : 0;}
3563e384d00b76dab95949cd4cef56cc11841b80e541dededb0589b0ecfbef55
getAverageLL
 double getAverageLL()
{    return averageLL;}
45fa4c4969cf091b63832c29b258613183e7bfc0db6e0b5ca1ff1b0ccd8351bd
setAverageLL
 void setAverageLL(double averageLL)
{    this.averageLL = averageLL;}
33a4047c27e8cf11a6809d10a8029a5d93f905a314c2178ae567a9b829891068
getAverageCorrect
 double getAverageCorrect()
{    return averageCorrect;}
edc4d173822cd1b819ee943e463d2e32d5a78ecbfa221f6e5bacfd66dc9cbf57
setAverageCorrect
 void setAverageCorrect(double averageCorrect)
{    this.averageCorrect = averageCorrect;}
ebbcf855983fc40ac3b9ca7930102ae30542fb140e668617423212d74d98f02d
getStep
 double getStep()
{    return step;}
2ef5ab58eba397c3f8464f31642f360a59a729335afbb32ad00243ee1024e9d1
setStep
 void setStep(double step)
{    this.step = step;}
2d68f6dadceb8acfbb69fdf1f7849f449dff332f74ec4ebf2581a53544ceac08
getBumps
 int[] getBumps()
{    return bumps;}
cae120aeba8fc7019384e838d80a390f1c4e3431e0465e40b2ad3d3156a4cbbd
setBumps
 void setBumps(int[] bumps)
{    this.bumps = bumps;}
365a24fc75086b6a0e91f9b072bd58c9280846cc05f333f28ede18388f27ce89
main
public static void main(String[] args) throws IOException
{    FeatureVectorEncoder[] encoder = new FeatureVectorEncoder[FIELDS];    for (int i = 0; i < FIELDS; i++) {        encoder[i] = new ConstantValueEncoder("v" + 1);    }    OnlineSummarizer[] s = new OnlineSummarizer[FIELDS];    for (int i = 0; i < FIELDS; i++) {        s[i] = new OnlineSummarizer();    }    long t0 = System.currentTimeMillis();    Vector v = new DenseVector(1000);    if ("--generate".equals(args[0])) {        try (PrintWriter out = new PrintWriter(new OutputStreamWriter(new FileOutputStream(new File(args[2])), Charsets.UTF_8))) {            int n = Integer.parseInt(args[1]);            for (int i = 0; i < n; i++) {                Line x = Line.generate();                out.println(x);            }        }    } else if ("--parse".equals(args[0])) {        try (BufferedReader in = Files.newReader(new File(args[1]), Charsets.UTF_8)) {            String line = in.readLine();            while (line != null) {                v.assign(0);                Line x = new Line(line);                for (int i = 0; i < FIELDS; i++) {                    s[i].add(x.getDouble(i));                    encoder[i].addToVector(x.get(i), v);                }                line = in.readLine();            }        }        String separator = "";        for (int i = 0; i < FIELDS; i++) {            System.out.printf("%s%.3f", separator, s[i].getMean());            separator = ",";        }    } else if ("--fast".equals(args[0])) {        try (FastLineReader in = new FastLineReader(new FileInputStream(args[1]))) {            FastLine line = in.read();            while (line != null) {                v.assign(0);                for (int i = 0; i < FIELDS; i++) {                    double z = line.getDouble(i);                    s[i].add(z);                    encoder[i].addToVector((byte[]) null, z, v);                }                line = in.read();            }        }        String separator = "";        for (int i = 0; i < FIELDS; i++) {            System.out.printf("%s%.3f", separator, s[i].getMean());            separator = ",";        }    }    System.out.printf("\nElapsed time = %.3f%n", (System.currentTimeMillis() - t0) / 1000.0);}
71934263f9f8ccb653b213b1aa4d035ccd69361f04c29645bc745933f83ab6c7
getDouble
public double getDouble(int field)
{    return Double.parseDouble(data.get(field));}
117f7142e37c3c1bff5bec7a70589f87ea5ec1d52090070e3f94ec36730e5424
generate
public static Line generate()
{    Line r = new Line();    for (int i = 0; i < FIELDS; i++) {        double mean = ((i + 1) * 257) % 50 + 1;        r.data.add(Integer.toString(randomValue(mean)));    }    return r;}
4c189a68adf8ba6028c8eb9775d5984708f872229049ae7d15fa95d6453e89f0
randomValue
private static int randomValue(double mean)
{    return (int) (-mean * Math.log1p(-RAND.nextDouble()));}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return WITH_COMMAS.join(data);}
6398d5607b78edeafdaa3eb156461770c9f3dffc897cbc897c501dd71f4d3aca
get
public String get(int field)
{    return data.get(field);}
239d595dbfb90106c7449c837d9c4b6e37cab3c18207b32ede58bbab2c6cc2ce
read
public static FastLine read(ByteBuffer buf)
{    FastLine r = new FastLine(buf);    r.start.add(buf.position());    int offset = buf.position();    while (offset < buf.limit()) {        int ch = buf.get();        offset = buf.position();        switch(ch) {            case '\n':                r.length.add(offset - r.start.get(r.length.size()) - 1);                return r;            case SEPARATOR_CHAR:                r.length.add(offset - r.start.get(r.length.size()) - 1);                r.start.add(offset);                break;            default:        }    }    throw new IllegalArgumentException("Not enough bytes in buffer");}
71934263f9f8ccb653b213b1aa4d035ccd69361f04c29645bc745933f83ab6c7
getDouble
public double getDouble(int field)
{    int offset = start.get(field);    int size = length.get(field);    switch(size) {        case 1:            return base.get(offset) - '0';        case 2:            return (base.get(offset) - '0') * 10 + base.get(offset + 1) - '0';        default:            double r = 0;            for (int i = 0; i < size; i++) {                r = 10 * r + base.get(offset + i) - '0';            }            return r;    }}
a8087d6ac4b94efcb9482456366f7a95b400428b87362c25c3a488c0ebfbaa41
read
public FastLine read() throws IOException
{    fillBuffer();    if (buf.remaining() > 0) {        return FastLine.read(buf);    } else {        return null;    }}
8f98e51c3a1c954624abcd11ff8593f716e62b944fb248e27829ce760f42066f
fillBuffer
private void fillBuffer() throws IOException
{    if (buf.remaining() < 10000) {        buf.compact();        int n = in.read(buf.array(), buf.position(), buf.remaining());        if (n == -1) {            buf.flip();        } else {            buf.limit(buf.position() + n);            buf.position(0);        }    }}
5df6118bc0e745d8b18e0a6a99b2e3f2ddba8140cbeb1423ce2df50a9f140574
close
public void close()
{    try {        Closeables.close(in, true);    } catch (IOException e) {        log.error(e.getMessage(), e);    }}
365a24fc75086b6a0e91f9b072bd58c9280846cc05f333f28ede18388f27ce89
main
public static void main(String[] args) throws IOException
{    TestASFEmail runner = new TestASFEmail();    if (runner.parseArgs(args)) {        runner.run(new PrintWriter(new OutputStreamWriter(System.out, Charsets.UTF_8), true));    }}
13e1b5fcd10f001ddffaff0d4583cd418f106b6db9423fdd109f2f0025e287bf
run
public void run(PrintWriter output) throws IOException
{    File base = new File(inputFile);        OnlineLogisticRegression classifier = ModelSerializer.readBinary(new FileInputStream(modelFile), OnlineLogisticRegression.class);    Dictionary asfDictionary = new Dictionary();    Configuration conf = new Configuration();    PathFilter testFilter = new PathFilter() {        @Override        public boolean accept(Path path) {            return path.getName().contains("test");        }    };    SequenceFileDirIterator<Text, VectorWritable> iter = new SequenceFileDirIterator<>(new Path(base.toString()), PathType.LIST, testFilter, null, true, conf);    long numItems = 0;    while (iter.hasNext()) {        Pair<Text, VectorWritable> next = iter.next();        asfDictionary.intern(next.getFirst().toString());        numItems++;    }    System.out.println(numItems + " test files");    ResultAnalyzer ra = new ResultAnalyzer(asfDictionary.values(), "DEFAULT");    iter = new SequenceFileDirIterator<>(new Path(base.toString()), PathType.LIST, testFilter, null, true, conf);    while (iter.hasNext()) {        Pair<Text, VectorWritable> next = iter.next();        String ng = next.getFirst().toString();        int actual = asfDictionary.intern(ng);        Vector result = classifier.classifyFull(next.getSecond().get());        int cat = result.maxValueIndex();        double score = result.maxValue();        double ll = classifier.logLikelihood(actual, next.getSecond().get());        ClassifierResult cr = new ClassifierResult(asfDictionary.values().get(cat), score, ll);        ra.addInstance(asfDictionary.values().get(actual), cr);    }    output.println(ra);}
50dec78a3246c66d1f1077fa5021604b0b396ea488918ec580feb329b787f269
accept
public boolean accept(Path path)
{    return path.getName().contains("test");}
845b195ea4fe9f992cecaf9c6988c74c5d0c5b6088c666130d06ba9c578ca164
parseArgs
 boolean parseArgs(String[] args)
{    DefaultOptionBuilder builder = new DefaultOptionBuilder();    Option help = builder.withLongName("help").withDescription("print this list").create();    ArgumentBuilder argumentBuilder = new ArgumentBuilder();    Option inputFileOption = builder.withLongName("input").withRequired(true).withArgument(argumentBuilder.withName("input").withMaximum(1).create()).withDescription("where to get training data").create();    Option modelFileOption = builder.withLongName("model").withRequired(true).withArgument(argumentBuilder.withName("model").withMaximum(1).create()).withDescription("where to get a model").create();    Group normalArgs = new GroupBuilder().withOption(help).withOption(inputFileOption).withOption(modelFileOption).create();    Parser parser = new Parser();    parser.setHelpOption(help);    parser.setHelpTrigger("--help");    parser.setGroup(normalArgs);    parser.setHelpFormatter(new HelpFormatter(" ", "", " ", 130));    CommandLine cmdLine = parser.parseAndHelp(args);    if (cmdLine == null) {        return false;    }    inputFile = (String) cmdLine.getValue(inputFileOption);    modelFile = (String) cmdLine.getValue(modelFileOption);    return true;}
365a24fc75086b6a0e91f9b072bd58c9280846cc05f333f28ede18388f27ce89
main
public static void main(String[] args) throws IOException
{    TestNewsGroups runner = new TestNewsGroups();    if (runner.parseArgs(args)) {        runner.run(new PrintWriter(new OutputStreamWriter(System.out, Charsets.UTF_8), true));    }}
13e1b5fcd10f001ddffaff0d4583cd418f106b6db9423fdd109f2f0025e287bf
run
public void run(PrintWriter output) throws IOException
{    File base = new File(inputFile);        OnlineLogisticRegression classifier = ModelSerializer.readBinary(new FileInputStream(modelFile), OnlineLogisticRegression.class);    Dictionary newsGroups = new Dictionary();    Multiset<String> overallCounts = HashMultiset.create();    List<File> files = new ArrayList<>();    for (File newsgroup : base.listFiles()) {        if (newsgroup.isDirectory()) {            newsGroups.intern(newsgroup.getName());            files.addAll(Arrays.asList(newsgroup.listFiles()));        }    }    System.out.println(files.size() + " test files");    ResultAnalyzer ra = new ResultAnalyzer(newsGroups.values(), "DEFAULT");    for (File file : files) {        String ng = file.getParentFile().getName();        int actual = newsGroups.intern(ng);        NewsgroupHelper helper = new NewsgroupHelper();                Vector input = helper.encodeFeatureVector(file, actual, 0, overallCounts);        Vector result = classifier.classifyFull(input);        int cat = result.maxValueIndex();        double score = result.maxValue();        double ll = classifier.logLikelihood(actual, input);        ClassifierResult cr = new ClassifierResult(newsGroups.values().get(cat), score, ll);        ra.addInstance(newsGroups.values().get(actual), cr);    }    output.println(ra);}
845b195ea4fe9f992cecaf9c6988c74c5d0c5b6088c666130d06ba9c578ca164
parseArgs
 boolean parseArgs(String[] args)
{    DefaultOptionBuilder builder = new DefaultOptionBuilder();    Option help = builder.withLongName("help").withDescription("print this list").create();    ArgumentBuilder argumentBuilder = new ArgumentBuilder();    Option inputFileOption = builder.withLongName("input").withRequired(true).withArgument(argumentBuilder.withName("input").withMaximum(1).create()).withDescription("where to get training data").create();    Option modelFileOption = builder.withLongName("model").withRequired(true).withArgument(argumentBuilder.withName("model").withMaximum(1).create()).withDescription("where to get a model").create();    Group normalArgs = new GroupBuilder().withOption(help).withOption(inputFileOption).withOption(modelFileOption).create();    Parser parser = new Parser();    parser.setHelpOption(help);    parser.setHelpTrigger("--help");    parser.setGroup(normalArgs);    parser.setHelpFormatter(new HelpFormatter(" ", "", " ", 130));    CommandLine cmdLine = parser.parseAndHelp(args);    if (cmdLine == null) {        return false;    }    inputFile = (String) cmdLine.getValue(inputFileOption);    modelFile = (String) cmdLine.getValue(modelFileOption);    return true;}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    mainToOutput(args, new PrintWriter(new OutputStreamWriter(System.out, Charsets.UTF_8), true));}
225b3f68c2119fe5bd88f4db9e244ac633416af47013d1594cc08e5b67386f78
mainToOutput
 static void mainToOutput(String[] args, PrintWriter output) throws Exception
{    if (parseArgs(args)) {        CsvRecordFactory csv = lmp.getCsvRecordFactory();        model = lmp.createAdaptiveLogisticRegression();        State<Wrapper, CrossFoldLearner> best;        CrossFoldLearner learner = null;        int k = 0;        for (int pass = 0; pass < passes; pass++) {            BufferedReader in = open(inputFile);                        csv.firstLine(in.readLine());            String line = in.readLine();            while (line != null) {                                Vector input = new RandomAccessSparseVector(lmp.getNumFeatures());                int targetValue = csv.processLine(line, input);                                model.train(targetValue, input);                k++;                if (showperf && (k % (skipperfnum + 1) == 0)) {                    best = model.getBest();                    if (best != null) {                        learner = best.getPayload().getLearner();                    }                    if (learner != null) {                        double averageCorrect = learner.percentCorrect();                        double averageLL = learner.logLikelihood();                        output.printf("%d\t%.3f\t%.2f%n", k, averageLL, averageCorrect * 100);                    } else {                        output.printf(Locale.ENGLISH, "%10d %2d %s%n", k, targetValue, "AdaptiveLogisticRegression has not found a good model ......");                    }                }                line = in.readLine();            }            in.close();        }        best = model.getBest();        if (best != null) {            learner = best.getPayload().getLearner();        }        if (learner == null) {            output.println("AdaptiveLogisticRegression has failed to train a model.");            return;        }        try (OutputStream modelOutput = new FileOutputStream(outputFile)) {            lmp.saveTo(modelOutput);        }        OnlineLogisticRegression lr = learner.getModels().get(0);        output.println(lmp.getNumFeatures());        output.println(lmp.getTargetVariable() + " ~ ");        String sep = "";        for (String v : csv.getTraceDictionary().keySet()) {            double weight = predictorWeight(lr, 0, csv, v);            if (weight != 0) {                output.printf(Locale.ENGLISH, "%s%.3f*%s", sep, weight, v);                sep = " + ";            }        }        output.printf("%n");        for (int row = 0; row < lr.getBeta().numRows(); row++) {            for (String key : csv.getTraceDictionary().keySet()) {                double weight = predictorWeight(lr, row, csv, key);                if (weight != 0) {                    output.printf(Locale.ENGLISH, "%20s %.5f%n", key, weight);                }            }            for (int column = 0; column < lr.getBeta().numCols(); column++) {                output.printf(Locale.ENGLISH, "%15.9f ", lr.getBeta().get(row, column));            }            output.println();        }    }}
692c99aeb4f908fbe36d2a61fdd92e6dd7816a68970cd63b16995f26e6fc3a3f
predictorWeight
private static double predictorWeight(OnlineLogisticRegression lr, int row, RecordFactory csv, String predictor)
{    double weight = 0;    for (Integer column : csv.getTraceDictionary().get(predictor)) {        weight += lr.getBeta().get(row, column);    }    return weight;}
8a020e634c4458bb50320d2d26ebf2bd0acef21f18ae107ef2766325d626a374
parseArgs
private static boolean parseArgs(String[] args)
{    DefaultOptionBuilder builder = new DefaultOptionBuilder();    Option help = builder.withLongName("help").withDescription("print this list").create();    Option quiet = builder.withLongName("quiet").withDescription("be extra quiet").create();    ArgumentBuilder argumentBuilder = new ArgumentBuilder();    Option showperf = builder.withLongName("showperf").withDescription("output performance measures during training").create();    Option inputFile = builder.withLongName("input").withRequired(true).withArgument(argumentBuilder.withName("input").withMaximum(1).create()).withDescription("where to get training data").create();    Option outputFile = builder.withLongName("output").withRequired(true).withArgument(argumentBuilder.withName("output").withMaximum(1).create()).withDescription("where to write the model content").create();    Option threads = builder.withLongName("threads").withArgument(argumentBuilder.withName("threads").withDefault("4").create()).withDescription("the number of threads AdaptiveLogisticRegression uses").create();    Option predictors = builder.withLongName("predictors").withRequired(true).withArgument(argumentBuilder.withName("predictors").create()).withDescription("a list of predictor variables").create();    Option types = builder.withLongName("types").withRequired(true).withArgument(argumentBuilder.withName("types").create()).withDescription("a list of predictor variable types (numeric, word, or text)").create();    Option target = builder.withLongName("target").withDescription("the name of the target variable").withRequired(true).withArgument(argumentBuilder.withName("target").withMaximum(1).create()).create();    Option targetCategories = builder.withLongName("categories").withDescription("the number of target categories to be considered").withRequired(true).withArgument(argumentBuilder.withName("categories").withMaximum(1).create()).create();    Option features = builder.withLongName("features").withDescription("the number of internal hashed features to use").withArgument(argumentBuilder.withName("numFeatures").withDefault("1000").withMaximum(1).create()).create();    Option passes = builder.withLongName("passes").withDescription("the number of times to pass over the input data").withArgument(argumentBuilder.withName("passes").withDefault("2").withMaximum(1).create()).create();    Option interval = builder.withLongName("interval").withArgument(argumentBuilder.withName("interval").withDefault("500").create()).withDescription("the interval property of AdaptiveLogisticRegression").create();    Option window = builder.withLongName("window").withArgument(argumentBuilder.withName("window").withDefault("800").create()).withDescription("the average propery of AdaptiveLogisticRegression").create();    Option skipperfnum = builder.withLongName("skipperfnum").withArgument(argumentBuilder.withName("skipperfnum").withDefault("99").create()).withDescription("show performance measures every (skipperfnum + 1) rows").create();    Option prior = builder.withLongName("prior").withArgument(argumentBuilder.withName("prior").withDefault("L1").create()).withDescription("the prior algorithm to use: L1, L2, ebp, tp, up").create();    Option priorOption = builder.withLongName("prioroption").withArgument(argumentBuilder.withName("prioroption").create()).withDescription("constructor parameter for ElasticBandPrior and TPrior").create();    Option auc = builder.withLongName("auc").withArgument(argumentBuilder.withName("auc").withDefault("global").create()).withDescription("the auc to use: global or grouped").create();    Group normalArgs = new GroupBuilder().withOption(help).withOption(quiet).withOption(inputFile).withOption(outputFile).withOption(target).withOption(targetCategories).withOption(predictors).withOption(types).withOption(passes).withOption(interval).withOption(window).withOption(threads).withOption(prior).withOption(features).withOption(showperf).withOption(skipperfnum).withOption(priorOption).withOption(auc).create();    Parser parser = new Parser();    parser.setHelpOption(help);    parser.setHelpTrigger("--help");    parser.setGroup(normalArgs);    parser.setHelpFormatter(new HelpFormatter(" ", "", " ", 130));    CommandLine cmdLine = parser.parseAndHelp(args);    if (cmdLine == null) {        return false;    }    TrainAdaptiveLogistic.inputFile = getStringArgument(cmdLine, inputFile);    TrainAdaptiveLogistic.outputFile = getStringArgument(cmdLine, outputFile);    List<String> typeList = new ArrayList<>();    for (Object x : cmdLine.getValues(types)) {        typeList.add(x.toString());    }    List<String> predictorList = new ArrayList<>();    for (Object x : cmdLine.getValues(predictors)) {        predictorList.add(x.toString());    }    lmp = new AdaptiveLogisticModelParameters();    lmp.setTargetVariable(getStringArgument(cmdLine, target));    lmp.setMaxTargetCategories(getIntegerArgument(cmdLine, targetCategories));    lmp.setNumFeatures(getIntegerArgument(cmdLine, features));    lmp.setInterval(getIntegerArgument(cmdLine, interval));    lmp.setAverageWindow(getIntegerArgument(cmdLine, window));    lmp.setThreads(getIntegerArgument(cmdLine, threads));    lmp.setAuc(getStringArgument(cmdLine, auc));    lmp.setPrior(getStringArgument(cmdLine, prior));    if (cmdLine.getValue(priorOption) != null) {        lmp.setPriorOption(getDoubleArgument(cmdLine, priorOption));    }    lmp.setTypeMap(predictorList, typeList);    TrainAdaptiveLogistic.showperf = getBooleanArgument(cmdLine, showperf);    TrainAdaptiveLogistic.skipperfnum = getIntegerArgument(cmdLine, skipperfnum);    TrainAdaptiveLogistic.passes = getIntegerArgument(cmdLine, passes);    lmp.checkParameters();    return true;}
1d455240872d875d84c7b1a9ac3b872242b650abe60b25fe4c3807df40624c62
getStringArgument
private static String getStringArgument(CommandLine cmdLine, Option inputFile)
{    return (String) cmdLine.getValue(inputFile);}
792f20be503d8a8e5eed90ab9907b8a68b4109900dab69d45b5fc947e2ff2896
getBooleanArgument
private static boolean getBooleanArgument(CommandLine cmdLine, Option option)
{    return cmdLine.hasOption(option);}
90d062afed435b3132fbf95733ca0856f53cc2c2ba5260942899c4ecea38c44b
getIntegerArgument
private static int getIntegerArgument(CommandLine cmdLine, Option features)
{    return Integer.parseInt((String) cmdLine.getValue(features));}
1e5747cfb5d04ba8e20f1ba3961c2ea3fb8a80561e44fd4bce4fa8d27e16ab97
getDoubleArgument
private static double getDoubleArgument(CommandLine cmdLine, Option op)
{    return Double.parseDouble((String) cmdLine.getValue(op));}
87faed5c2a59907f5e33416a1fca23b6a164a43e28d0e5f50d7387a89467d63f
getModel
public static AdaptiveLogisticRegression getModel()
{    return model;}
741e5226cf6137f49c536134c620b0196681f237c032566989ddb9ee3f3e3899
getParameters
public static LogisticModelParameters getParameters()
{    return lmp;}
4f1e3f630ad3be7fb4b32e95bb2b0ff3748b0c38cff74dc9dcd2bcfd89a94460
open
 static BufferedReader open(String inputFile) throws IOException
{    InputStream in;    try {        in = Resources.getResource(inputFile).openStream();    } catch (IllegalArgumentException e) {        in = new FileInputStream(new File(inputFile));    }    return new BufferedReader(new InputStreamReader(in, Charsets.UTF_8));}
aacecb0f01750d985b78d806dc3c134f0da79efe2752957e0f93ecf5cbf9e492
run
public int run(String[] args) throws Exception
{    addInputOption();    addOutputOption();    addOption("categories", "nc", "The number of categories to train on", true);    addOption("cardinality", "c", "The size of the vectors to use", "100000");    addOption("threads", "t", "The number of threads to use in the learner", "20");    addOption("poolSize", "p", "The number of CrossFoldLearners to use in the AdaptiveLogisticRegression. " + "Higher values require more memory.", "5");    if (parseArguments(args) == null) {        return -1;    }    File base = new File(getInputPath().toString());    Multiset<String> overallCounts = HashMultiset.create();    File output = new File(getOutputPath().toString());    output.mkdirs();    int numCats = Integer.parseInt(getOption("categories"));    int cardinality = Integer.parseInt(getOption("cardinality", "100000"));    int threadCount = Integer.parseInt(getOption("threads", "20"));    int poolSize = Integer.parseInt(getOption("poolSize", "5"));    Dictionary asfDictionary = new Dictionary();    AdaptiveLogisticRegression learningAlgorithm = new AdaptiveLogisticRegression(numCats, cardinality, new L1(), threadCount, poolSize);    learningAlgorithm.setInterval(800);    learningAlgorithm.setAveragingWindow(500);        Configuration conf = new Configuration();    PathFilter trainFilter = new PathFilter() {        @Override        public boolean accept(Path path) {            return path.getName().contains("training");        }    };    SequenceFileDirIterator<Text, VectorWritable> iter = new SequenceFileDirIterator<>(new Path(base.toString()), PathType.LIST, trainFilter, null, true, conf);    long numItems = 0;    while (iter.hasNext()) {        Pair<Text, VectorWritable> next = iter.next();        asfDictionary.intern(next.getFirst().toString());        numItems++;    }    System.out.println(numItems + " training files");    SGDInfo info = new SGDInfo();    iter = new SequenceFileDirIterator<>(new Path(base.toString()), PathType.LIST, trainFilter, null, true, conf);    int k = 0;    while (iter.hasNext()) {        Pair<Text, VectorWritable> next = iter.next();        String ng = next.getFirst().toString();        int actual = asfDictionary.intern(ng);                learningAlgorithm.train(actual, next.getSecond().get());        k++;        State<AdaptiveLogisticRegression.Wrapper, CrossFoldLearner> best = learningAlgorithm.getBest();        SGDHelper.analyzeState(info, 0, k, best);    }    learningAlgorithm.close();            System.out.println("exiting main, writing model to " + output);    ModelSerializer.writeBinary(output + "/asf.model", learningAlgorithm.getBest().getPayload().getLearner().getModels().get(0));    List<Integer> counts = new ArrayList<>();    System.out.println("Word counts");    for (String count : overallCounts.elementSet()) {        counts.add(overallCounts.count(count));    }    Collections.sort(counts, Ordering.natural().reverse());    k = 0;    for (Integer count : counts) {        System.out.println(k + "\t" + count);        k++;        if (k > 1000) {            break;        }    }    return 0;}
50dec78a3246c66d1f1077fa5021604b0b396ea488918ec580feb329b787f269
accept
public boolean accept(Path path)
{    return path.getName().contains("training");}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    TrainASFEmail trainer = new TrainASFEmail();    trainer.run(args);}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    mainToOutput(args, new PrintWriter(new OutputStreamWriter(System.out, Charsets.UTF_8), true));}
225b3f68c2119fe5bd88f4db9e244ac633416af47013d1594cc08e5b67386f78
mainToOutput
 static void mainToOutput(String[] args, PrintWriter output) throws Exception
{    if (parseArgs(args)) {        double logPEstimate = 0;        int samples = 0;        CsvRecordFactory csv = lmp.getCsvRecordFactory();        OnlineLogisticRegression lr = lmp.createRegression();        for (int pass = 0; pass < passes; pass++) {            try (BufferedReader in = open(inputFile)) {                                csv.firstLine(in.readLine());                String line = in.readLine();                while (line != null) {                                        Vector input = new RandomAccessSparseVector(lmp.getNumFeatures());                    int targetValue = csv.processLine(line, input);                                        double logP = lr.logLikelihood(targetValue, input);                    if (!Double.isInfinite(logP)) {                        if (samples < 20) {                            logPEstimate = (samples * logPEstimate + logP) / (samples + 1);                        } else {                            logPEstimate = 0.95 * logPEstimate + 0.05 * logP;                        }                        samples++;                    }                    double p = lr.classifyScalar(input);                    if (scores) {                        output.printf(Locale.ENGLISH, "%10d %2d %10.2f %2.4f %10.4f %10.4f%n", samples, targetValue, lr.currentLearningRate(), p, logP, logPEstimate);                    }                                        lr.train(targetValue, input);                    line = in.readLine();                }            }        }        try (OutputStream modelOutput = new FileOutputStream(outputFile)) {            lmp.saveTo(modelOutput);        }        output.println(lmp.getNumFeatures());        output.println(lmp.getTargetVariable() + " ~ ");        String sep = "";        for (String v : csv.getTraceDictionary().keySet()) {            double weight = predictorWeight(lr, 0, csv, v);            if (weight != 0) {                output.printf(Locale.ENGLISH, "%s%.3f*%s", sep, weight, v);                sep = " + ";            }        }        output.printf("%n");        model = lr;        for (int row = 0; row < lr.getBeta().numRows(); row++) {            for (String key : csv.getTraceDictionary().keySet()) {                double weight = predictorWeight(lr, row, csv, key);                if (weight != 0) {                    output.printf(Locale.ENGLISH, "%20s %.5f%n", key, weight);                }            }            for (int column = 0; column < lr.getBeta().numCols(); column++) {                output.printf(Locale.ENGLISH, "%15.9f ", lr.getBeta().get(row, column));            }            output.println();        }    }}
692c99aeb4f908fbe36d2a61fdd92e6dd7816a68970cd63b16995f26e6fc3a3f
predictorWeight
private static double predictorWeight(OnlineLogisticRegression lr, int row, RecordFactory csv, String predictor)
{    double weight = 0;    for (Integer column : csv.getTraceDictionary().get(predictor)) {        weight += lr.getBeta().get(row, column);    }    return weight;}
8a020e634c4458bb50320d2d26ebf2bd0acef21f18ae107ef2766325d626a374
parseArgs
private static boolean parseArgs(String[] args)
{    DefaultOptionBuilder builder = new DefaultOptionBuilder();    Option help = builder.withLongName("help").withDescription("print this list").create();    Option quiet = builder.withLongName("quiet").withDescription("be extra quiet").create();    Option scores = builder.withLongName("scores").withDescription("output score diagnostics during training").create();    ArgumentBuilder argumentBuilder = new ArgumentBuilder();    Option inputFile = builder.withLongName("input").withRequired(true).withArgument(argumentBuilder.withName("input").withMaximum(1).create()).withDescription("where to get training data").create();    Option outputFile = builder.withLongName("output").withRequired(true).withArgument(argumentBuilder.withName("output").withMaximum(1).create()).withDescription("where to get training data").create();    Option predictors = builder.withLongName("predictors").withRequired(true).withArgument(argumentBuilder.withName("p").create()).withDescription("a list of predictor variables").create();    Option types = builder.withLongName("types").withRequired(true).withArgument(argumentBuilder.withName("t").create()).withDescription("a list of predictor variable types (numeric, word, or text)").create();    Option target = builder.withLongName("target").withRequired(true).withArgument(argumentBuilder.withName("target").withMaximum(1).create()).withDescription("the name of the target variable").create();    Option features = builder.withLongName("features").withArgument(argumentBuilder.withName("numFeatures").withDefault("1000").withMaximum(1).create()).withDescription("the number of internal hashed features to use").create();    Option passes = builder.withLongName("passes").withArgument(argumentBuilder.withName("passes").withDefault("2").withMaximum(1).create()).withDescription("the number of times to pass over the input data").create();    Option lambda = builder.withLongName("lambda").withArgument(argumentBuilder.withName("lambda").withDefault("1e-4").withMaximum(1).create()).withDescription("the amount of coefficient decay to use").create();    Option rate = builder.withLongName("rate").withArgument(argumentBuilder.withName("learningRate").withDefault("1e-3").withMaximum(1).create()).withDescription("the learning rate").create();    Option noBias = builder.withLongName("noBias").withDescription("don't include a bias term").create();    Option targetCategories = builder.withLongName("categories").withRequired(true).withArgument(argumentBuilder.withName("number").withMaximum(1).create()).withDescription("the number of target categories to be considered").create();    Group normalArgs = new GroupBuilder().withOption(help).withOption(quiet).withOption(inputFile).withOption(outputFile).withOption(target).withOption(targetCategories).withOption(predictors).withOption(types).withOption(passes).withOption(lambda).withOption(rate).withOption(noBias).withOption(features).create();    Parser parser = new Parser();    parser.setHelpOption(help);    parser.setHelpTrigger("--help");    parser.setGroup(normalArgs);    parser.setHelpFormatter(new HelpFormatter(" ", "", " ", 130));    CommandLine cmdLine = parser.parseAndHelp(args);    if (cmdLine == null) {        return false;    }    TrainLogistic.inputFile = getStringArgument(cmdLine, inputFile);    TrainLogistic.outputFile = getStringArgument(cmdLine, outputFile);    List<String> typeList = new ArrayList<>();    for (Object x : cmdLine.getValues(types)) {        typeList.add(x.toString());    }    List<String> predictorList = new ArrayList<>();    for (Object x : cmdLine.getValues(predictors)) {        predictorList.add(x.toString());    }    lmp = new LogisticModelParameters();    lmp.setTargetVariable(getStringArgument(cmdLine, target));    lmp.setMaxTargetCategories(getIntegerArgument(cmdLine, targetCategories));    lmp.setNumFeatures(getIntegerArgument(cmdLine, features));    lmp.setUseBias(!getBooleanArgument(cmdLine, noBias));    lmp.setTypeMap(predictorList, typeList);    lmp.setLambda(getDoubleArgument(cmdLine, lambda));    lmp.setLearningRate(getDoubleArgument(cmdLine, rate));    TrainLogistic.scores = getBooleanArgument(cmdLine, scores);    TrainLogistic.passes = getIntegerArgument(cmdLine, passes);    return true;}
1d455240872d875d84c7b1a9ac3b872242b650abe60b25fe4c3807df40624c62
getStringArgument
private static String getStringArgument(CommandLine cmdLine, Option inputFile)
{    return (String) cmdLine.getValue(inputFile);}
792f20be503d8a8e5eed90ab9907b8a68b4109900dab69d45b5fc947e2ff2896
getBooleanArgument
private static boolean getBooleanArgument(CommandLine cmdLine, Option option)
{    return cmdLine.hasOption(option);}
90d062afed435b3132fbf95733ca0856f53cc2c2ba5260942899c4ecea38c44b
getIntegerArgument
private static int getIntegerArgument(CommandLine cmdLine, Option features)
{    return Integer.parseInt((String) cmdLine.getValue(features));}
1e5747cfb5d04ba8e20f1ba3961c2ea3fb8a80561e44fd4bce4fa8d27e16ab97
getDoubleArgument
private static double getDoubleArgument(CommandLine cmdLine, Option op)
{    return Double.parseDouble((String) cmdLine.getValue(op));}
a3bc015faf71c4c396248152e03f9c1badb5837c38684aa23faaa5e588e4afb8
getModel
public static OnlineLogisticRegression getModel()
{    return model;}
741e5226cf6137f49c536134c620b0196681f237c032566989ddb9ee3f3e3899
getParameters
public static LogisticModelParameters getParameters()
{    return lmp;}
4f1e3f630ad3be7fb4b32e95bb2b0ff3748b0c38cff74dc9dcd2bcfd89a94460
open
 static BufferedReader open(String inputFile) throws IOException
{    InputStream in;    try {        in = Resources.getResource(inputFile).openStream();    } catch (IllegalArgumentException e) {        in = new FileInputStream(new File(inputFile));    }    return new BufferedReader(new InputStreamReader(in, Charsets.UTF_8));}
365a24fc75086b6a0e91f9b072bd58c9280846cc05f333f28ede18388f27ce89
main
public static void main(String[] args) throws IOException
{    File base = new File(args[0]);    Multiset<String> overallCounts = HashMultiset.create();    int leakType = 0;    if (args.length > 1) {        leakType = Integer.parseInt(args[1]);    }    Dictionary newsGroups = new Dictionary();    NewsgroupHelper helper = new NewsgroupHelper();    helper.getEncoder().setProbes(2);    AdaptiveLogisticRegression learningAlgorithm = new AdaptiveLogisticRegression(20, NewsgroupHelper.FEATURES, new L1());    learningAlgorithm.setInterval(800);    learningAlgorithm.setAveragingWindow(500);    List<File> files = new ArrayList<>();    for (File newsgroup : base.listFiles()) {        if (newsgroup.isDirectory()) {            newsGroups.intern(newsgroup.getName());            files.addAll(Arrays.asList(newsgroup.listFiles()));        }    }    Collections.shuffle(files);    System.out.println(files.size() + " training files");    SGDInfo info = new SGDInfo();    int k = 0;    for (File file : files) {        String ng = file.getParentFile().getName();        int actual = newsGroups.intern(ng);        Vector v = helper.encodeFeatureVector(file, actual, leakType, overallCounts);        learningAlgorithm.train(actual, v);        k++;        State<AdaptiveLogisticRegression.Wrapper, CrossFoldLearner> best = learningAlgorithm.getBest();        SGDHelper.analyzeState(info, leakType, k, best);    }    learningAlgorithm.close();    SGDHelper.dissect(leakType, newsGroups, learningAlgorithm, files, overallCounts);    System.out.println("exiting main");    File modelFile = new File(System.getProperty("java.io.tmpdir"), "news-group.model");    ModelSerializer.writeBinary(modelFile.getAbsolutePath(), learningAlgorithm.getBest().getPayload().getLearner().getModels().get(0));    List<Integer> counts = new ArrayList<>();    System.out.println("Word counts");    for (String count : overallCounts.elementSet()) {        counts.add(overallCounts.count(count));    }    Collections.sort(counts, Ordering.natural().reverse());    k = 0;    for (Integer count : counts) {        System.out.println(k + "\t" + count);        k++;        if (k > 1000) {            break;        }    }}
365a24fc75086b6a0e91f9b072bd58c9280846cc05f333f28ede18388f27ce89
main
public static void main(String[] args) throws IOException
{    mainToOutput(args, new PrintWriter(new OutputStreamWriter(System.out, Charsets.UTF_8), true));}
136e5a78130c87eae13a57e072c641279084bc78a968c32853db505c0fc8c417
mainToOutput
 static void mainToOutput(String[] args, PrintWriter output) throws IOException
{    if (parseArgs(args)) {        if (!showAuc && !showConfusion && !showScores) {            showAuc = true;            showConfusion = true;        }        Auc collector = null;        AdaptiveLogisticModelParameters lmp = AdaptiveLogisticModelParameters.loadFromFile(new File(modelFile));        CsvRecordFactory csv = lmp.getCsvRecordFactory();        AdaptiveLogisticRegression lr = lmp.createAdaptiveLogisticRegression();        if (lmp.getTargetCategories().size() <= 2) {            collector = new Auc();        }        OnlineSummarizer slh = new OnlineSummarizer();        ConfusionMatrix cm = new ConfusionMatrix(lmp.getTargetCategories(), defaultCategory);        State<Wrapper, CrossFoldLearner> best = lr.getBest();        if (best == null) {            output.println("AdaptiveLogisticRegression has not be trained probably.");            return;        }        CrossFoldLearner learner = best.getPayload().getLearner();        BufferedReader in = TrainLogistic.open(inputFile);        String line = in.readLine();        csv.firstLine(line);        line = in.readLine();        if (showScores) {            output.println("\"target\", \"model-output\", \"log-likelihood\", \"average-likelihood\"");        }        while (line != null) {            Vector v = new SequentialAccessSparseVector(lmp.getNumFeatures());                        int target = csv.processLine(line, v);            double likelihood = learner.logLikelihood(target, v);            double score = learner.classifyFull(v).maxValue();            slh.add(likelihood);            cm.addInstance(csv.getTargetString(line), csv.getTargetLabel(target));            if (showScores) {                output.printf(Locale.ENGLISH, "%8d, %.12f, %.13f, %.13f%n", target, score, learner.logLikelihood(target, v), slh.getMean());            }            if (collector != null) {                collector.add(target, score);            }            line = in.readLine();        }        output.printf(Locale.ENGLISH, "\nLog-likelihood:");        output.printf(Locale.ENGLISH, "Min=%.2f, Max=%.2f, Mean=%.2f, Median=%.2f%n", slh.getMin(), slh.getMax(), slh.getMean(), slh.getMedian());        if (collector != null) {            output.printf(Locale.ENGLISH, "%nAUC = %.2f%n", collector.auc());        }        if (showConfusion) {            output.printf(Locale.ENGLISH, "%n%s%n%n", cm.toString());            if (collector != null) {                Matrix m = collector.entropy();                output.printf(Locale.ENGLISH, "Entropy Matrix: [[%.1f, %.1f], [%.1f, %.1f]]%n", m.get(0, 0), m.get(1, 0), m.get(0, 1), m.get(1, 1));            }        }    }}
8a020e634c4458bb50320d2d26ebf2bd0acef21f18ae107ef2766325d626a374
parseArgs
private static boolean parseArgs(String[] args)
{    DefaultOptionBuilder builder = new DefaultOptionBuilder();    Option help = builder.withLongName("help").withDescription("print this list").create();    Option quiet = builder.withLongName("quiet").withDescription("be extra quiet").create();    Option auc = builder.withLongName("auc").withDescription("print AUC").create();    Option confusion = builder.withLongName("confusion").withDescription("print confusion matrix").create();    Option scores = builder.withLongName("scores").withDescription("print scores").create();    ArgumentBuilder argumentBuilder = new ArgumentBuilder();    Option inputFileOption = builder.withLongName("input").withRequired(true).withArgument(argumentBuilder.withName("input").withMaximum(1).create()).withDescription("where to get validate data").create();    Option modelFileOption = builder.withLongName("model").withRequired(true).withArgument(argumentBuilder.withName("model").withMaximum(1).create()).withDescription("where to get the trained model").create();    Option defaultCagetoryOption = builder.withLongName("defaultCategory").withRequired(false).withArgument(argumentBuilder.withName("defaultCategory").withMaximum(1).withDefault("unknown").create()).withDescription("the default category value to use").create();    Group normalArgs = new GroupBuilder().withOption(help).withOption(quiet).withOption(auc).withOption(scores).withOption(confusion).withOption(inputFileOption).withOption(modelFileOption).withOption(defaultCagetoryOption).create();    Parser parser = new Parser();    parser.setHelpOption(help);    parser.setHelpTrigger("--help");    parser.setGroup(normalArgs);    parser.setHelpFormatter(new HelpFormatter(" ", "", " ", 130));    CommandLine cmdLine = parser.parseAndHelp(args);    if (cmdLine == null) {        return false;    }    inputFile = getStringArgument(cmdLine, inputFileOption);    modelFile = getStringArgument(cmdLine, modelFileOption);    defaultCategory = getStringArgument(cmdLine, defaultCagetoryOption);    showAuc = getBooleanArgument(cmdLine, auc);    showScores = getBooleanArgument(cmdLine, scores);    showConfusion = getBooleanArgument(cmdLine, confusion);    return true;}
792f20be503d8a8e5eed90ab9907b8a68b4109900dab69d45b5fc947e2ff2896
getBooleanArgument
private static boolean getBooleanArgument(CommandLine cmdLine, Option option)
{    return cmdLine.hasOption(option);}
1d455240872d875d84c7b1a9ac3b872242b650abe60b25fe4c3807df40624c62
getStringArgument
private static String getStringArgument(CommandLine cmdLine, Option inputFile)
{    return (String) cmdLine.getValue(inputFile);}
50dec78a3246c66d1f1077fa5021604b0b396ea488918ec580feb329b787f269
accept
public boolean accept(Path path)
{    String pathString = path.toString();    return pathString.contains("/clusters-");}
fe9bac4bb069e3120cb6864ff4cf9a4d902e2056a350ea42fe3116efdf28aeca
paint
public void paint(Graphics g)
{    plotSampleData((Graphics2D) g);    plotClusters((Graphics2D) g);}
35dd7accad0bedf0b5daefd1b62ccd407cc5236fbd45bb58448178d07ad979dc
plotClusters
protected static void plotClusters(Graphics2D g2)
{    int cx = CLUSTERS.size() - 1;    for (List<Cluster> clusters : CLUSTERS) {        for (Cluster cluster : clusters) {            if (isSignificant(cluster)) {                g2.setStroke(new BasicStroke(1));                g2.setColor(Color.BLUE);                double[] t1 = { T1, T1 };                plotEllipse(g2, cluster.getCenter(), new DenseVector(t1));                double[] t2 = { T2, T2 };                plotEllipse(g2, cluster.getCenter(), new DenseVector(t2));                g2.setColor(COLORS[Math.min(DisplayClustering.COLORS.length - 1, cx)]);                g2.setStroke(new BasicStroke(cx == 0 ? 3 : 1));                plotEllipse(g2, cluster.getCenter(), cluster.getRadius().times(3));            }        }        cx--;    }}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    Path samples = new Path("samples");    Path output = new Path("output");    Configuration conf = new Configuration();    HadoopUtil.delete(conf, samples);    HadoopUtil.delete(conf, output);    RandomUtils.useTestSeed();    generateSamples();    writeSampleData(samples);    CanopyDriver.buildClusters(conf, samples, output, new ManhattanDistanceMeasure(), T1, T2, 0, true);    loadClustersWritable(output);    new DisplayCanopy();}
46ffa8d56c2364376c7a2fb00ff1e97ead501825886406f582f8797ba07e934c
initialize
public void initialize()
{        res = Toolkit.getDefaultToolkit().getScreenResolution();        this.setSize(SIZE * res, SIZE * res);    this.setVisible(true);    this.setTitle("Asymmetric Sample Data");        this.addWindowListener(new WindowAdapter() {        @Override        public void windowClosing(WindowEvent e) {            System.exit(0);        }    });}
a0c922349febb150d28dd70c0f056255958f8cc0890df5d8a70725bd52f963d6
windowClosing
public void windowClosing(WindowEvent e)
{    System.exit(0);}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    RandomUtils.useTestSeed();    generateSamples();    new DisplayClustering();}
fe9bac4bb069e3120cb6864ff4cf9a4d902e2056a350ea42fe3116efdf28aeca
paint
public void paint(Graphics g)
{    Graphics2D g2 = (Graphics2D) g;    plotSampleData(g2);    plotSampleParameters(g2);    plotClusters(g2);}
35dd7accad0bedf0b5daefd1b62ccd407cc5236fbd45bb58448178d07ad979dc
plotClusters
protected static void plotClusters(Graphics2D g2)
{    int cx = CLUSTERS.size() - 1;    for (List<Cluster> clusters : CLUSTERS) {        g2.setStroke(new BasicStroke(cx == 0 ? 3 : 1));        g2.setColor(COLORS[Math.min(COLORS.length - 1, cx--)]);        for (Cluster cluster : clusters) {            plotEllipse(g2, cluster.getCenter(), cluster.getRadius().times(3));        }    }}
7c000afab511a90ac0dd3733240c4235df3808184c188d68c1ce225fe8a4570c
plotSampleParameters
protected static void plotSampleParameters(Graphics2D g2)
{    Vector v = new DenseVector(2);    Vector dv = new DenseVector(2);    g2.setColor(Color.RED);    for (Vector param : SAMPLE_PARAMS) {        v.set(0, param.get(0));        v.set(1, param.get(1));        dv.set(0, param.get(2) * 3);        dv.set(1, param.get(3) * 3);        plotEllipse(g2, v, dv);    }}
8de6005775210285b52ff5b26339631e251235cddcf42cfd0e93bd1989b41f6a
plotSampleData
protected static void plotSampleData(Graphics2D g2)
{    double sx = (double) res / DS;    g2.setTransform(AffineTransform.getScaleInstance(sx, sx));        g2.setColor(Color.BLACK);    Vector dv = new DenseVector(2).assign(SIZE / 2.0);    plotRectangle(g2, new DenseVector(2).assign(2), dv);    plotRectangle(g2, new DenseVector(2).assign(-2), dv);        g2.setColor(Color.DARK_GRAY);    dv.assign(0.03);    for (VectorWritable v : SAMPLE_DATA) {        plotRectangle(g2, v.get(), dv);    }}
6d24b7c2db3bf8a5aa66ef6aafb32a348d47ac2ebb87bc04cb9efa7580d0f6e5
plotClusteredSampleData
protected static void plotClusteredSampleData(Graphics2D g2, Path data)
{    double sx = (double) res / DS;    g2.setTransform(AffineTransform.getScaleInstance(sx, sx));    g2.setColor(Color.BLACK);    Vector dv = new DenseVector(2).assign(SIZE / 2.0);    plotRectangle(g2, new DenseVector(2).assign(2), dv);    plotRectangle(g2, new DenseVector(2).assign(-2), dv);        dv.assign(0.03);    Path clusteredPointsPath = new Path(data, "clusteredPoints");    Path inputPath = new Path(clusteredPointsPath, "part-m-00000");    Map<Integer, Color> colors = new HashMap<>();    int point = 0;    for (Pair<IntWritable, WeightedVectorWritable> record : new SequenceFileIterable<IntWritable, WeightedVectorWritable>(inputPath, new Configuration())) {        int clusterId = record.getFirst().get();        VectorWritable v = SAMPLE_DATA.get(point++);        Integer key = clusterId;        if (!colors.containsKey(key)) {            colors.put(key, COLORS[Math.min(COLORS.length - 1, colors.size())]);        }        plotClusteredRectangle(g2, v.get(), dv, colors.get(key));    }}
dde70db52c51373f4eb3eafe8a9d0ac8a654fd9396c778690cffdfcae8c09a91
plotClusteredRectangle
protected static void plotClusteredRectangle(Graphics2D g2, Vector v, Vector dv, Color color)
{    double[] flip = { 1, -1 };    Vector v2 = v.times(new DenseVector(flip));    v2 = v2.minus(dv.divide(2));    int h = SIZE / 2;    double x = v2.get(0) + h;    double y = v2.get(1) + h;    g2.setStroke(new BasicStroke(1));    g2.setColor(color);    g2.draw(new Rectangle2D.Double(x * DS, y * DS, dv.get(0) * DS, dv.get(1) * DS));}
45430448badceeb49c1ffe7f2a74472361bbe5954d83400ae3896037655ef499
plotRectangle
protected static void plotRectangle(Graphics2D g2, Vector v, Vector dv)
{    double[] flip = { 1, -1 };    Vector v2 = v.times(new DenseVector(flip));    v2 = v2.minus(dv.divide(2));    int h = SIZE / 2;    double x = v2.get(0) + h;    double y = v2.get(1) + h;    g2.draw(new Rectangle2D.Double(x * DS, y * DS, dv.get(0) * DS, dv.get(1) * DS));}
f5b69fbc7efb3befd780d45b3287541ce40f6907c1999a45f769e13315cf5f5e
plotEllipse
protected static void plotEllipse(Graphics2D g2, Vector v, Vector dv)
{    double[] flip = { 1, -1 };    Vector v2 = v.times(new DenseVector(flip));    v2 = v2.minus(dv.divide(2));    int h = SIZE / 2;    double x = v2.get(0) + h;    double y = v2.get(1) + h;    g2.draw(new Ellipse2D.Double(x * DS, y * DS, dv.get(0) * DS, dv.get(1) * DS));}
6c1b4502b02217077346ec495f099db9fb1bdca5d90b835a7dd7f8cbe1a2d29d
generateSamples
protected static void generateSamples()
{    generateSamples(500, 1, 1, 3);    generateSamples(300, 1, 0, 0.5);    generateSamples(300, 0, 2, 0.1);}
65adf940ced2453f903cb4be82a9e0ffcbb2e34cffee1c3e435200dbe416a45d
generate2dSamples
protected static void generate2dSamples()
{    generate2dSamples(500, 1, 1, 3, 1);    generate2dSamples(300, 1, 0, 0.5, 1);    generate2dSamples(300, 0, 2, 0.1, 0.5);}
0f0e307cf5a38059aa470993bb8dcff6701399f7eb5f4ddd1f2abcdb9185876c
generateSamples
protected static void generateSamples(int num, double mx, double my, double sd)
{    double[] params = { mx, my, sd, sd };    SAMPLE_PARAMS.add(new DenseVector(params));    log.info("Generating {} samples m=[{}, {}] sd={}", num, mx, my, sd);    for (int i = 0; i < num; i++) {        SAMPLE_DATA.add(new VectorWritable(new DenseVector(new double[] { UncommonDistributions.rNorm(mx, sd), UncommonDistributions.rNorm(my, sd) })));    }}
4b6f1f4b44770aaafc015890af010eb5bcbae0039b06e154d8f99a42b8fd0933
writeSampleData
protected static void writeSampleData(Path output) throws IOException
{    Configuration conf = new Configuration();    FileSystem fs = FileSystem.get(output.toUri(), conf);    try (SequenceFile.Writer writer = new SequenceFile.Writer(fs, conf, output, Text.class, VectorWritable.class)) {        int i = 0;        for (VectorWritable vw : SAMPLE_DATA) {            writer.append(new Text("sample_" + i++), vw);        }    }}
bbca5c2e0194397babb95b64c9521a561eb26c658c110df7c2f83cc349aa0af4
readClustersWritable
protected static List<Cluster> readClustersWritable(Path clustersIn)
{    List<Cluster> clusters = new ArrayList<>();    Configuration conf = new Configuration();    for (ClusterWritable value : new SequenceFileDirValueIterable<ClusterWritable>(clustersIn, PathType.LIST, PathFilters.logsCRCFilter(), conf)) {        Cluster cluster = value.getValue();        log.info("Reading Cluster:{} center:{} numPoints:{} radius:{}", cluster.getId(), AbstractCluster.formatVector(cluster.getCenter(), null), cluster.getNumObservations(), AbstractCluster.formatVector(cluster.getRadius(), null));        clusters.add(cluster);    }    return clusters;}
c2e28fc364b4907e87bdc42160c91059a95658db06477823808e1dceae80a018
loadClustersWritable
protected static void loadClustersWritable(Path output) throws IOException
{    Configuration conf = new Configuration();    FileSystem fs = FileSystem.get(output.toUri(), conf);    for (FileStatus s : fs.listStatus(output, new ClustersFilter())) {        List<Cluster> clusters = readClustersWritable(s.getPath());        CLUSTERS.add(clusters);    }}
aec6ce910c6fc4ee654607653c3a0ddff609286da5afbd5f55313ce34098e5df
generate2dSamples
protected static void generate2dSamples(int num, double mx, double my, double sdx, double sdy)
{    double[] params = { mx, my, sdx, sdy };    SAMPLE_PARAMS.add(new DenseVector(params));    log.info("Generating {} samples m=[{}, {}] sd=[{}, {}]", num, mx, my, sdx, sdy);    for (int i = 0; i < num; i++) {        SAMPLE_DATA.add(new VectorWritable(new DenseVector(new double[] { UncommonDistributions.rNorm(mx, sdx), UncommonDistributions.rNorm(my, sdy) })));    }}
eb4570826577a3d103d18e3fadf986247c01d3fa269689b260bb2eaf24b5b596
isSignificant
protected static boolean isSignificant(Cluster cluster)
{    return (double) cluster.getNumObservations() / SAMPLE_DATA.size() > significance;}
fe9bac4bb069e3120cb6864ff4cf9a4d902e2056a350ea42fe3116efdf28aeca
paint
public void paint(Graphics g)
{    plotSampleData((Graphics2D) g);    plotClusters((Graphics2D) g);}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    DistanceMeasure measure = new ManhattanDistanceMeasure();    Path samples = new Path("samples");    Path output = new Path("output");    Configuration conf = new Configuration();    HadoopUtil.delete(conf, output);    HadoopUtil.delete(conf, samples);    RandomUtils.useTestSeed();    DisplayClustering.generateSamples();    writeSampleData(samples);    boolean runClusterer = true;    int maxIterations = 10;    float threshold = 0.001F;    float m = 1.1F;    if (runClusterer) {        runSequentialFuzzyKClusterer(conf, samples, output, measure, maxIterations, m, threshold);    } else {        int numClusters = 3;        runSequentialFuzzyKClassifier(conf, samples, output, measure, numClusters, maxIterations, m, threshold);    }    new DisplayFuzzyKMeans();}
fe0a47438137ba1bedd58e23d7a7611473b33ddf1c3a520850c9f2ab72a5c6f8
runSequentialFuzzyKClassifier
private static void runSequentialFuzzyKClassifier(Configuration conf, Path samples, Path output, DistanceMeasure measure, int numClusters, int maxIterations, float m, double threshold) throws IOException
{    Collection<Vector> points = Lists.newArrayList();    for (int i = 0; i < numClusters; i++) {        points.add(SAMPLE_DATA.get(i).get());    }    List<Cluster> initialClusters = Lists.newArrayList();    int id = 0;    for (Vector point : points) {        initialClusters.add(new SoftCluster(point, id++, measure));    }    ClusterClassifier prior = new ClusterClassifier(initialClusters, new FuzzyKMeansClusteringPolicy(m, threshold));    Path priorPath = new Path(output, "classifier-0");    prior.writeToSeqFiles(priorPath);    ClusterIterator.iterateSeq(conf, samples, priorPath, output, maxIterations);    loadClustersWritable(output);}
2f3df7e132414f6b7736e26fc8a1e089ffa1b939f2598d28a98fe855de6dafe4
runSequentialFuzzyKClusterer
private static void runSequentialFuzzyKClusterer(Configuration conf, Path samples, Path output, DistanceMeasure measure, int maxIterations, float m, double threshold) throws IOException, ClassNotFoundException, InterruptedException
{    Path clustersIn = new Path(output, "random-seeds");    RandomSeedGenerator.buildRandom(conf, samples, clustersIn, 3, measure);    FuzzyKMeansDriver.run(samples, clustersIn, output, threshold, maxIterations, m, true, true, threshold, true);    loadClustersWritable(output);}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    DistanceMeasure measure = new ManhattanDistanceMeasure();    Path samples = new Path("samples");    Path output = new Path("output");    Configuration conf = new Configuration();    HadoopUtil.delete(conf, samples);    HadoopUtil.delete(conf, output);    RandomUtils.useTestSeed();    generateSamples();    writeSampleData(samples);    boolean runClusterer = true;    double convergenceDelta = 0.001;    int numClusters = 3;    int maxIterations = 10;    if (runClusterer) {        runSequentialKMeansClusterer(conf, samples, output, measure, numClusters, maxIterations, convergenceDelta);    } else {        runSequentialKMeansClassifier(conf, samples, output, measure, numClusters, maxIterations, convergenceDelta);    }    new DisplayKMeans();}
18d0a4d3fbc9338d0ec6f1c7a9a4d2f677054d8182b2e86d5b6cf9107493173f
runSequentialKMeansClassifier
private static void runSequentialKMeansClassifier(Configuration conf, Path samples, Path output, DistanceMeasure measure, int numClusters, int maxIterations, double convergenceDelta) throws IOException
{    Collection<Vector> points = Lists.newArrayList();    for (int i = 0; i < numClusters; i++) {        points.add(SAMPLE_DATA.get(i).get());    }    List<Cluster> initialClusters = Lists.newArrayList();    int id = 0;    for (Vector point : points) {        initialClusters.add(new org.apache.mahout.clustering.kmeans.Kluster(point, id++, measure));    }    ClusterClassifier prior = new ClusterClassifier(initialClusters, new KMeansClusteringPolicy(convergenceDelta));    Path priorPath = new Path(output, Cluster.INITIAL_CLUSTERS_DIR);    prior.writeToSeqFiles(priorPath);    ClusterIterator.iterateSeq(conf, samples, priorPath, output, maxIterations);    loadClustersWritable(output);}
eb6874320680c32a525a478d90bd0840932c12c2bd6e81fce509eac7f0c537e3
runSequentialKMeansClusterer
private static void runSequentialKMeansClusterer(Configuration conf, Path samples, Path output, DistanceMeasure measure, int numClusters, int maxIterations, double convergenceDelta) throws IOException, InterruptedException, ClassNotFoundException
{    Path clustersIn = new Path(output, "random-seeds");    RandomSeedGenerator.buildRandom(conf, samples, clustersIn, numClusters, measure);    KMeansDriver.run(samples, clustersIn, output, convergenceDelta, maxIterations, true, 0.0, true);    loadClustersWritable(output);}
fe9bac4bb069e3120cb6864ff4cf9a4d902e2056a350ea42fe3116efdf28aeca
paint
public void paint(Graphics g)
{    plotSampleData((Graphics2D) g);    plotClusters((Graphics2D) g);}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    DistanceMeasure measure = new ManhattanDistanceMeasure();    Path samples = new Path(SAMPLES);    Path output = new Path(OUTPUT);    Path tempDir = new Path(TEMP);    Configuration conf = new Configuration();    HadoopUtil.delete(conf, samples);    HadoopUtil.delete(conf, output);    RandomUtils.useTestSeed();    DisplayClustering.generateSamples();    writeSampleData(samples);    Path affinities = new Path(output, AFFINITIES);    FileSystem fs = FileSystem.get(output.toUri(), conf);    if (!fs.exists(output)) {        fs.mkdirs(output);    }    try (Writer writer = new BufferedWriter(new FileWriter(affinities.toString()))) {        for (int i = 0; i < SAMPLE_DATA.size(); i++) {            for (int j = 0; j < SAMPLE_DATA.size(); j++) {                writer.write(i + "," + j + ',' + measure.distance(SAMPLE_DATA.get(i).get(), SAMPLE_DATA.get(j).get()) + '\n');            }        }    }    int maxIter = 10;    double convergenceDelta = 0.001;    SpectralKMeansDriver.run(new Configuration(), affinities, output, SAMPLE_DATA.size(), 3, measure, convergenceDelta, maxIter, tempDir);    new DisplaySpectralKMeans();}
fe9bac4bb069e3120cb6864ff4cf9a4d902e2056a350ea42fe3116efdf28aeca
paint
public void paint(Graphics g)
{    plotClusteredSampleData((Graphics2D) g, new Path(new Path(OUTPUT), "kmeans_out"));}
abed1201b7ae8bfd81f86084579ca4f70cc9416a9069b44efe2140a164c569b3
printSummaries
public void printSummaries(List<OnlineSummarizer> summarizers, String type)
{    printSummaries(summarizers, type, fileOut);}
331e415b62b5f166c248cd335e5f0bac7f42d6b31572ce92600132f1f9ed1b54
printSummaries
public static void printSummaries(List<OnlineSummarizer> summarizers, String type, PrintWriter fileOut)
{    double maxDistance = 0;    for (int i = 0; i < summarizers.size(); ++i) {        OnlineSummarizer summarizer = summarizers.get(i);        if (summarizer.getCount() > 1) {            maxDistance = Math.max(maxDistance, summarizer.getMax());            System.out.printf("Average distance in cluster %d [%d]: %f\n", i, summarizer.getCount(), summarizer.getMean());                        if (fileOut != null) {                fileOut.printf("%d,%f,%f,%f,%f,%f,%f,%f,%d,%s\n", i, summarizer.getMean(), summarizer.getSD(), summarizer.getQuartile(0), summarizer.getQuartile(1), summarizer.getQuartile(2), summarizer.getQuartile(3), summarizer.getQuartile(4), summarizer.getCount(), type);            }        } else {            System.out.printf("Cluster %d is has %d data point. Need atleast 2 data points in a cluster for" + " OnlineSummarizer.\n", i, summarizer.getCount());        }    }    System.out.printf("Num clusters: %d; maxDistance: %f\n", summarizers.size(), maxDistance);}
d756081f6122b82915ed5d6542d8c0a46cde13d93e4e426add1fcd67fd99590a
run
public int run(String[] args) throws IOException
{    if (!parseArgs(args)) {        return -1;    }    Configuration conf = new Configuration();    try {        fileOut = new PrintWriter(new FileOutputStream(outputFile));        fileOut.printf("cluster,distance.mean,distance.sd,distance.q0,distance.q1,distance.q2,distance.q3," + "distance.q4,count,is.train\n");                List<Centroid> centroids;        List<Centroid> centroidsCompare = null;        if (mahoutKMeansFormat) {            SequenceFileDirValueIterable<ClusterWritable> clusterIterable = new SequenceFileDirValueIterable<>(new Path(centroidFile), PathType.GLOB, conf);            centroids = Lists.newArrayList(IOUtils.getCentroidsFromClusterWritableIterable(clusterIterable));        } else {            SequenceFileDirValueIterable<CentroidWritable> centroidIterable = new SequenceFileDirValueIterable<>(new Path(centroidFile), PathType.GLOB, conf);            centroids = Lists.newArrayList(IOUtils.getCentroidsFromCentroidWritableIterable(centroidIterable));        }        if (centroidCompareFile != null) {            if (mahoutKMeansFormatCompare) {                SequenceFileDirValueIterable<ClusterWritable> clusterCompareIterable = new SequenceFileDirValueIterable<>(new Path(centroidCompareFile), PathType.GLOB, conf);                centroidsCompare = Lists.newArrayList(IOUtils.getCentroidsFromClusterWritableIterable(clusterCompareIterable));            } else {                SequenceFileDirValueIterable<CentroidWritable> centroidCompareIterable = new SequenceFileDirValueIterable<>(new Path(centroidCompareFile), PathType.GLOB, conf);                centroidsCompare = Lists.newArrayList(IOUtils.getCentroidsFromCentroidWritableIterable(centroidCompareIterable));            }        }                SequenceFileDirValueIterable<VectorWritable> trainIterable = new SequenceFileDirValueIterable<>(new Path(trainFile), PathType.GLOB, conf);        Iterable<Vector> trainDatapoints = IOUtils.getVectorsFromVectorWritableIterable(trainIterable);        Iterable<Vector> datapoints = trainDatapoints;        printSummaries(ClusteringUtils.summarizeClusterDistances(trainDatapoints, centroids, new SquaredEuclideanDistanceMeasure()), "train");                if (testFile != null) {            SequenceFileDirValueIterable<VectorWritable> testIterable = new SequenceFileDirValueIterable<>(new Path(testFile), PathType.GLOB, conf);            Iterable<Vector> testDatapoints = IOUtils.getVectorsFromVectorWritableIterable(testIterable);            printSummaries(ClusteringUtils.summarizeClusterDistances(testDatapoints, centroids, new SquaredEuclideanDistanceMeasure()), "test");            datapoints = Iterables.concat(trainDatapoints, testDatapoints);        }                List<OnlineSummarizer> summaries = ClusteringUtils.summarizeClusterDistances(datapoints, centroids, distanceMeasure);        List<OnlineSummarizer> compareSummaries = null;        if (centroidsCompare != null) {            compareSummaries = ClusteringUtils.summarizeClusterDistances(datapoints, centroidsCompare, distanceMeasure);        }        System.out.printf("[Dunn Index] First: %f", ClusteringUtils.dunnIndex(centroids, distanceMeasure, summaries));        if (compareSummaries != null) {            System.out.printf(" Second: %f\n", ClusteringUtils.dunnIndex(centroidsCompare, distanceMeasure, compareSummaries));        } else {            System.out.printf("\n");        }        System.out.printf("[Davies-Bouldin Index] First: %f", ClusteringUtils.daviesBouldinIndex(centroids, distanceMeasure, summaries));        if (compareSummaries != null) {            System.out.printf(" Second: %f\n", ClusteringUtils.daviesBouldinIndex(centroidsCompare, distanceMeasure, compareSummaries));        } else {            System.out.printf("\n");        }    } catch (IOException e) {        System.out.println(e.getMessage());    } finally {        Closeables.close(fileOut, false);    }    return 0;}
4ae3834739effe006815832921463e2eafa5549c587498a65de0321385678ab2
parseArgs
private boolean parseArgs(String[] args)
{    DefaultOptionBuilder builder = new DefaultOptionBuilder();    Option help = builder.withLongName("help").withDescription("print this list").create();    ArgumentBuilder argumentBuilder = new ArgumentBuilder();    Option inputFileOption = builder.withLongName("input").withShortName("i").withRequired(true).withArgument(argumentBuilder.withName("input").withMaximum(1).create()).withDescription("where to get seq files with the vectors (training set)").create();    Option testInputFileOption = builder.withLongName("testInput").withShortName("itest").withArgument(argumentBuilder.withName("testInput").withMaximum(1).create()).withDescription("where to get seq files with the vectors (test set)").create();    Option centroidsFileOption = builder.withLongName("centroids").withShortName("c").withRequired(true).withArgument(argumentBuilder.withName("centroids").withMaximum(1).create()).withDescription("where to get seq files with the centroids (from Mahout KMeans or StreamingKMeansDriver)").create();    Option centroidsCompareFileOption = builder.withLongName("centroidsCompare").withShortName("cc").withRequired(false).withArgument(argumentBuilder.withName("centroidsCompare").withMaximum(1).create()).withDescription("where to get seq files with the second set of centroids (from Mahout KMeans or " + "StreamingKMeansDriver)").create();    Option outputFileOption = builder.withLongName("output").withShortName("o").withRequired(true).withArgument(argumentBuilder.withName("output").withMaximum(1).create()).withDescription("where to dump the CSV file with the results").create();    Option mahoutKMeansFormatOption = builder.withLongName("mahoutkmeansformat").withShortName("mkm").withDescription("if set, read files as (IntWritable, ClusterWritable) pairs").withArgument(argumentBuilder.withName("numpoints").withMaximum(1).create()).create();    Option mahoutKMeansCompareFormatOption = builder.withLongName("mahoutkmeansformatCompare").withShortName("mkmc").withDescription("if set, read files as (IntWritable, ClusterWritable) pairs").withArgument(argumentBuilder.withName("numpoints").withMaximum(1).create()).create();    Group normalArgs = new GroupBuilder().withOption(help).withOption(inputFileOption).withOption(testInputFileOption).withOption(outputFileOption).withOption(centroidsFileOption).withOption(centroidsCompareFileOption).withOption(mahoutKMeansFormatOption).withOption(mahoutKMeansCompareFormatOption).create();    Parser parser = new Parser();    parser.setHelpOption(help);    parser.setHelpTrigger("--help");    parser.setGroup(normalArgs);    parser.setHelpFormatter(new HelpFormatter(" ", "", " ", 150));    CommandLine cmdLine = parser.parseAndHelp(args);    if (cmdLine == null) {        return false;    }    trainFile = (String) cmdLine.getValue(inputFileOption);    if (cmdLine.hasOption(testInputFileOption)) {        testFile = (String) cmdLine.getValue(testInputFileOption);    }    centroidFile = (String) cmdLine.getValue(centroidsFileOption);    if (cmdLine.hasOption(centroidsCompareFileOption)) {        centroidCompareFile = (String) cmdLine.getValue(centroidsCompareFileOption);    }    outputFile = (String) cmdLine.getValue(outputFileOption);    if (cmdLine.hasOption(mahoutKMeansFormatOption)) {        mahoutKMeansFormat = true;    }    if (cmdLine.hasOption(mahoutKMeansCompareFormatOption)) {        mahoutKMeansFormatCompare = true;    }    return true;}
365a24fc75086b6a0e91f9b072bd58c9280846cc05f333f28ede18388f27ce89
main
public static void main(String[] args) throws IOException
{    new ClusterQualitySummarizer().run(args);}
4b95fde5cf3ffcf7887aec87b18300f1325b1b34b5dd3567e7194449b2196709
getCentroidsFromCentroidWritableIterable
public static Iterable<Centroid> getCentroidsFromCentroidWritableIterable(Iterable<CentroidWritable> dirIterable)
{    return Iterables.transform(dirIterable, new Function<CentroidWritable, Centroid>() {        @Override        public Centroid apply(CentroidWritable input) {            Preconditions.checkNotNull(input);            return input.getCentroid().clone();        }    });}
75172182fb3da3e5f50ed7424bea1bf34b06723644ff311c847fda12a88deddf
apply
public Centroid apply(CentroidWritable input)
{    Preconditions.checkNotNull(input);    return input.getCentroid().clone();}
409dabc5ebd900d1186467b78ab2a61d2c6a525c9370fa381a66313813b49e8e
getCentroidsFromClusterWritableIterable
public static Iterable<Centroid> getCentroidsFromClusterWritableIterable(Iterable<ClusterWritable> dirIterable)
{    return Iterables.transform(dirIterable, new Function<ClusterWritable, Centroid>() {        int numClusters = 0;        @Override        public Centroid apply(ClusterWritable input) {            Preconditions.checkNotNull(input);            return new Centroid(numClusters++, input.getValue().getCenter().clone(), input.getValue().getTotalObservations());        }    });}
17b5b7fce0c7f1d3f4b4f674e536524dc631f874e19a5a036fbffa07b7c41cb1
apply
public Centroid apply(ClusterWritable input)
{    Preconditions.checkNotNull(input);    return new Centroid(numClusters++, input.getValue().getCenter().clone(), input.getValue().getTotalObservations());}
a2c987f9c3d34b774edba79b37764bbf81dfb473f2ab879495d6f5287e1fa1e1
getVectorsFromVectorWritableIterable
public static Iterable<Vector> getVectorsFromVectorWritableIterable(Iterable<VectorWritable> dirIterable)
{    return Iterables.transform(dirIterable, new Function<VectorWritable, Vector>() {        @Override        public Vector apply(VectorWritable input) {            Preconditions.checkNotNull(input);            return input.get().clone();        }    });}
4b042b4aa34d43ae422b31d5a13c8ba76983ea0a79aabd85a93e7a7e769384e9
apply
public Vector apply(VectorWritable input)
{    Preconditions.checkNotNull(input);    return input.get().clone();}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    if (args.length > 0) {        log.info("Running with only user-supplied arguments");        ToolRunner.run(new Configuration(), new Job(), args);    } else {        log.info("Running with default arguments");        Path output = new Path("output");        HadoopUtil.delete(new Configuration(), output);        run(new Path("testdata"), output, new EuclideanDistanceMeasure(), 80, 55);    }}
9139d740c3d872efcd6888268072e36e5c6e387318b13d1c01cb5926cdc69467
run
private static void run(Path input, Path output, DistanceMeasure measure, double t1, double t2) throws Exception
{    Path directoryContainingConvertedInput = new Path(output, DIRECTORY_CONTAINING_CONVERTED_INPUT);    InputDriver.runJob(input, directoryContainingConvertedInput, "org.apache.mahout.math.RandomAccessSparseVector");    CanopyDriver.run(new Configuration(), directoryContainingConvertedInput, output, measure, t1, t2, true, 0.0, false);        ClusterDumper clusterDumper = new ClusterDumper(new Path(output, "clusters-0-final"), new Path(output, "clusteredPoints"));    clusterDumper.printClusters(null);}
aacecb0f01750d985b78d806dc3c134f0da79efe2752957e0f93ecf5cbf9e492
run
public int run(String[] args) throws Exception
{    addInputOption();    addOutputOption();    addOption(DefaultOptionCreator.distanceMeasureOption().create());    addOption(DefaultOptionCreator.t1Option().create());    addOption(DefaultOptionCreator.t2Option().create());    addOption(DefaultOptionCreator.overwriteOption().create());    Map<String, List<String>> argMap = parseArguments(args);    if (argMap == null) {        return -1;    }    Path input = getInputPath();    Path output = getOutputPath();    if (hasOption(DefaultOptionCreator.OVERWRITE_OPTION)) {        HadoopUtil.delete(new Configuration(), output);    }    String measureClass = getOption(DefaultOptionCreator.DISTANCE_MEASURE_OPTION);    double t1 = Double.parseDouble(getOption(DefaultOptionCreator.T1_OPTION));    double t2 = Double.parseDouble(getOption(DefaultOptionCreator.T2_OPTION));    DistanceMeasure measure = ClassUtils.instantiateAs(measureClass, DistanceMeasure.class);    run(input, output, measure, t1, t2);    return 0;}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    if (args.length > 0) {        log.info("Running with only user-supplied arguments");        ToolRunner.run(new Configuration(), new Job(), args);    } else {        log.info("Running with default arguments");        Path output = new Path("output");        Configuration conf = new Configuration();        HadoopUtil.delete(conf, output);        run(conf, new Path("testdata"), output, new EuclideanDistanceMeasure(), 80, 55, 10, 2.0f, 0.5);    }}
aacecb0f01750d985b78d806dc3c134f0da79efe2752957e0f93ecf5cbf9e492
run
public int run(String[] args) throws Exception
{    addInputOption();    addOutputOption();    addOption(DefaultOptionCreator.distanceMeasureOption().create());    addOption(DefaultOptionCreator.convergenceOption().create());    addOption(DefaultOptionCreator.maxIterationsOption().create());    addOption(DefaultOptionCreator.overwriteOption().create());    addOption(DefaultOptionCreator.t1Option().create());    addOption(DefaultOptionCreator.t2Option().create());    addOption(M_OPTION, M_OPTION, "coefficient normalization factor, must be greater than 1", true);    Map<String, List<String>> argMap = parseArguments(args);    if (argMap == null) {        return -1;    }    Path input = getInputPath();    Path output = getOutputPath();    String measureClass = getOption(DefaultOptionCreator.DISTANCE_MEASURE_OPTION);    if (measureClass == null) {        measureClass = SquaredEuclideanDistanceMeasure.class.getName();    }    double convergenceDelta = Double.parseDouble(getOption(DefaultOptionCreator.CONVERGENCE_DELTA_OPTION));    int maxIterations = Integer.parseInt(getOption(DefaultOptionCreator.MAX_ITERATIONS_OPTION));    float fuzziness = Float.parseFloat(getOption(M_OPTION));    addOption(new DefaultOptionBuilder().withLongName(M_OPTION).withRequired(true).withArgument(new ArgumentBuilder().withName(M_OPTION).withMinimum(1).withMaximum(1).create()).withDescription("coefficient normalization factor, must be greater than 1").withShortName(M_OPTION).create());    if (hasOption(DefaultOptionCreator.OVERWRITE_OPTION)) {        HadoopUtil.delete(getConf(), output);    }    DistanceMeasure measure = ClassUtils.instantiateAs(measureClass, DistanceMeasure.class);    double t1 = Double.parseDouble(getOption(DefaultOptionCreator.T1_OPTION));    double t2 = Double.parseDouble(getOption(DefaultOptionCreator.T2_OPTION));    run(getConf(), input, output, measure, t1, t2, maxIterations, fuzziness, convergenceDelta);    return 0;}
4e43338bf9263babd188936566ab01e141c56d894931d0dbe05b408821a3db6d
run
public static void run(Configuration conf, Path input, Path output, DistanceMeasure measure, double t1, double t2, int maxIterations, float fuzziness, double convergenceDelta) throws Exception
{    Path directoryContainingConvertedInput = new Path(output, DIRECTORY_CONTAINING_CONVERTED_INPUT);    log.info("Preparing Input");    InputDriver.runJob(input, directoryContainingConvertedInput, "org.apache.mahout.math.RandomAccessSparseVector");    log.info("Running Canopy to get initial clusters");    Path canopyOutput = new Path(output, "canopies");    CanopyDriver.run(new Configuration(), directoryContainingConvertedInput, canopyOutput, measure, t1, t2, false, 0.0, false);    log.info("Running FuzzyKMeans");    FuzzyKMeansDriver.run(directoryContainingConvertedInput, new Path(canopyOutput, "clusters-0-final"), output, convergenceDelta, maxIterations, fuzziness, true, true, 0.0, false);        ClusterDumper clusterDumper = new ClusterDumper(new Path(output, "clusters-*-final"), new Path(output, "clusteredPoints"));    clusterDumper.printClusters(null);}
b6047c2d62e0dd012f9e8fbf9c3b04878ae171af7f5ab52171412c0b606ca520
main
public static void main(String[] args) throws Exception
{    if (args.length > 0) {        log.info("Running with only user-supplied arguments");        ToolRunner.run(new Configuration(), new Job(), args);    } else {        log.info("Running with default arguments");        Path output = new Path("output");        Configuration conf = new Configuration();        HadoopUtil.delete(conf, output);        run(conf, new Path("testdata"), output, new EuclideanDistanceMeasure(), 6, 0.5, 10);    }}
aacecb0f01750d985b78d806dc3c134f0da79efe2752957e0f93ecf5cbf9e492
run
public int run(String[] args) throws Exception
{    addInputOption();    addOutputOption();    addOption(DefaultOptionCreator.distanceMeasureOption().create());    addOption(DefaultOptionCreator.numClustersOption().create());    addOption(DefaultOptionCreator.t1Option().create());    addOption(DefaultOptionCreator.t2Option().create());    addOption(DefaultOptionCreator.convergenceOption().create());    addOption(DefaultOptionCreator.maxIterationsOption().create());    addOption(DefaultOptionCreator.overwriteOption().create());    Map<String, List<String>> argMap = parseArguments(args);    if (argMap == null) {        return -1;    }    Path input = getInputPath();    Path output = getOutputPath();    String measureClass = getOption(DefaultOptionCreator.DISTANCE_MEASURE_OPTION);    if (measureClass == null) {        measureClass = SquaredEuclideanDistanceMeasure.class.getName();    }    double convergenceDelta = Double.parseDouble(getOption(DefaultOptionCreator.CONVERGENCE_DELTA_OPTION));    int maxIterations = Integer.parseInt(getOption(DefaultOptionCreator.MAX_ITERATIONS_OPTION));    if (hasOption(DefaultOptionCreator.OVERWRITE_OPTION)) {        HadoopUtil.delete(getConf(), output);    }    DistanceMeasure measure = ClassUtils.instantiateAs(measureClass, DistanceMeasure.class);    if (hasOption(DefaultOptionCreator.NUM_CLUSTERS_OPTION)) {        int k = Integer.parseInt(getOption(DefaultOptionCreator.NUM_CLUSTERS_OPTION));        run(getConf(), input, output, measure, k, convergenceDelta, maxIterations);    } else {        double t1 = Double.parseDouble(getOption(DefaultOptionCreator.T1_OPTION));        double t2 = Double.parseDouble(getOption(DefaultOptionCreator.T2_OPTION));        run(getConf(), input, output, measure, t1, t2, convergenceDelta, maxIterations);    }    return 0;}
d6976b17f844103afea1a40f5df6b4763a40491ffb8923c2d65c7678584a4596
run
public static void run(Configuration conf, Path input, Path output, DistanceMeasure measure, int k, double convergenceDelta, int maxIterations) throws Exception
{    Path directoryContainingConvertedInput = new Path(output, DIRECTORY_CONTAINING_CONVERTED_INPUT);    log.info("Preparing Input");    InputDriver.runJob(input, directoryContainingConvertedInput, "org.apache.mahout.math.RandomAccessSparseVector");    log.info("Running random seed to get initial clusters");    Path clusters = new Path(output, "random-seeds");    clusters = RandomSeedGenerator.buildRandom(conf, directoryContainingConvertedInput, clusters, k, measure);    log.info("Running KMeans with k = {}", k);    KMeansDriver.run(conf, directoryContainingConvertedInput, clusters, output, convergenceDelta, maxIterations, true, 0.0, false);        Path outGlob = new Path(output, "clusters-*-final");    Path clusteredPoints = new Path(output, "clusteredPoints");    log.info("Dumping out clusters from clusters: {} and clusteredPoints: {}", outGlob, clusteredPoints);    ClusterDumper clusterDumper = new ClusterDumper(outGlob, clusteredPoints);    clusterDumper.printClusters(null);}
acbf13f0d79fb89ddadde3e9b3f6da5d1d8b990301492e1e5f831d8acc676646
run
public static void run(Configuration conf, Path input, Path output, DistanceMeasure measure, double t1, double t2, double convergenceDelta, int maxIterations) throws Exception
{    Path directoryContainingConvertedInput = new Path(output, DIRECTORY_CONTAINING_CONVERTED_INPUT);    log.info("Preparing Input");    InputDriver.runJob(input, directoryContainingConvertedInput, "org.apache.mahout.math.RandomAccessSparseVector");    log.info("Running Canopy to get initial clusters");    Path canopyOutput = new Path(output, "canopies");    CanopyDriver.run(new Configuration(), directoryContainingConvertedInput, canopyOutput, measure, t1, t2, false, 0.0, false);    log.info("Running KMeans");    KMeansDriver.run(conf, directoryContainingConvertedInput, new Path(canopyOutput, Cluster.INITIAL_CLUSTERS_DIR + "-final"), output, convergenceDelta, maxIterations, true, 0.0, false);        ClusterDumper clusterDumper = new ClusterDumper(new Path(output, "clusters-*-final"), new Path(output, "clusteredPoints"));    clusterDumper.printClusters(null);}
f2c6e7501dd3df801173fdd7ee52d22bb0c4462b354650dc1c12645849aa3692
reduce
protected void reduce(Text key, Iterable<StringTuple> values, Context context) throws IOException, InterruptedException
{    Set<String> outputValues = new HashSet<>();    for (StringTuple value : values) {        outputValues.addAll(value.getEntries());    }    context.write(key, new StringTuple(outputValues));}
c7ad8ebe716f85dde7f201daf366137712de790cd7daff63300612cb8da97db6
startJob
public static void startJob(Parameters params) throws IOException, InterruptedException, ClassNotFoundException
{    Configuration conf = new Configuration();    conf.set("job.parameters", params.toString());    conf.set("mapred.compress.map.output", "true");    conf.set("mapred.output.compression.type", "BLOCK");    conf.set("mapred.map.output.compression.codec", "org.apache.hadoop.io.compress.GzipCodec");    conf.set("io.serializations", "org.apache.hadoop.io.serializer.JavaSerialization," + "org.apache.hadoop.io.serializer.WritableSerialization");    String input = params.get("input");    Job job = new Job(conf, "Generating dataset based from input" + input);    job.setJarByClass(KeyBasedStringTupleGrouper.class);    job.setMapOutputKeyClass(Text.class);    job.setMapOutputValueClass(StringTuple.class);    job.setOutputKeyClass(Text.class);    job.setOutputValueClass(Text.class);    FileInputFormat.addInputPath(job, new Path(input));    Path outPath = new Path(params.get("output"));    FileOutputFormat.setOutputPath(job, outPath);    HadoopUtil.delete(conf, outPath);    job.setInputFormatClass(TextInputFormat.class);    job.setMapperClass(KeyBasedStringTupleMapper.class);    job.setCombinerClass(KeyBasedStringTupleCombiner.class);    job.setReducerClass(KeyBasedStringTupleReducer.class);    job.setOutputFormatClass(TextOutputFormat.class);    boolean succeeded = job.waitForCompletion(true);    if (!succeeded) {        throw new IllegalStateException("Job failed!");    }}
364372c8c0a17a2c3987e3f0d31a4140befe124df0e3310d5d0fe71e39f33b0f
map
protected void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException
{    String[] fields = splitter.split(value.toString());    if (fields.length != 4) {        log.info("{} {}", fields.length, value.toString());        context.getCounter("Map", "ERROR").increment(1);        return;    }    Collection<String> oKey = new ArrayList<>();    for (int groupingField : groupingFields) {        oKey.add(fields[groupingField]);        context.setStatus(fields[groupingField]);    }    List<String> oValue = new ArrayList<>();    for (int selectedField : selectedFields) {        oValue.add(fields[selectedField]);    }    context.write(new Text(oKey.toString()), new StringTuple(oValue));}
6b7dd49be7482fc8ee0fbe8bd0f24522f2a718c8c816a3d7b048fb4688eb6373
setup
protected void setup(Context context) throws IOException, InterruptedException
{    super.setup(context);    Parameters params = new Parameters(context.getConfiguration().get("job.parameters", ""));    splitter = Pattern.compile(params.get("splitPattern", "[ \t]*\t[ \t]*"));    int selectedFieldCount = Integer.valueOf(params.get("selectedFieldCount", "0"));    selectedFields = new int[selectedFieldCount];    for (int i = 0; i < selectedFieldCount; i++) {        selectedFields[i] = Integer.valueOf(params.get("field" + i, "0"));    }    int groupingFieldCount = Integer.valueOf(params.get("groupingFieldCount", "0"));    groupingFields = new int[groupingFieldCount];    for (int i = 0; i < groupingFieldCount; i++) {        groupingFields[i] = Integer.valueOf(params.get("gfield" + i, "0"));    }}
f2c6e7501dd3df801173fdd7ee52d22bb0c4462b354650dc1c12645849aa3692
reduce
protected void reduce(Text key, Iterable<StringTuple> values, Context context) throws IOException, InterruptedException
{    Collection<String> items = new HashSet<>();    for (StringTuple value : values) {        for (String field : value.getEntries()) {            items.add(field);        }    }    if (items.size() > 1) {        int i = 0;        StringBuilder sb = new StringBuilder();        String sep = "";        for (String field : items) {            if (i % maxTransactionLength == 0) {                if (i != 0) {                    context.write(null, new Text(sb.toString()));                }                sb.replace(0, sb.length(), "");                sep = "";            }            sb.append(sep).append(field);            sep = "\t";            i++;        }        if (sb.length() > 0) {            context.write(null, new Text(sb.toString()));        }    }}
6b7dd49be7482fc8ee0fbe8bd0f24522f2a718c8c816a3d7b048fb4688eb6373
setup
protected void setup(Context context) throws IOException, InterruptedException
{    super.setup(context);    Parameters params = new Parameters(context.getConfiguration().get("job.parameters", ""));    maxTransactionLength = Integer.valueOf(params.get("maxTransactionLength", "100"));}
59254bdeea196a04aa484d3df43ef533299171755dcc2d78c62b5db6ccf74e9c
main
public static void main(String[] args) throws IOException, InterruptedException, ClassNotFoundException
{    DefaultOptionBuilder obuilder = new DefaultOptionBuilder();    ArgumentBuilder abuilder = new ArgumentBuilder();    GroupBuilder gbuilder = new GroupBuilder();    Option inputDirOpt = DefaultOptionCreator.inputOption().create();    Option outputOpt = DefaultOptionCreator.outputOption().create();    Option helpOpt = DefaultOptionCreator.helpOption();    Option recordSplitterOpt = obuilder.withLongName("splitterPattern").withArgument(abuilder.withName("splitterPattern").withMinimum(1).withMaximum(1).create()).withDescription("Regular Expression pattern used to split given line into fields." + " Default value splits comma or tab separated fields." + " Default Value: \"[ ,\\t]*\\t[ ,\\t]*\" ").withShortName("regex").create();    Option encodingOpt = obuilder.withLongName("encoding").withArgument(abuilder.withName("encoding").withMinimum(1).withMaximum(1).create()).withDescription("(Optional) The file encoding.  Default value: UTF-8").withShortName("e").create();    Group group = gbuilder.withName("Options").withOption(inputDirOpt).withOption(outputOpt).withOption(helpOpt).withOption(recordSplitterOpt).withOption(encodingOpt).create();    try {        Parser parser = new Parser();        parser.setGroup(group);        CommandLine cmdLine = parser.parse(args);        if (cmdLine.hasOption(helpOpt)) {            CommandLineUtil.printHelp(group);            return;        }        Parameters params = new Parameters();        if (cmdLine.hasOption(recordSplitterOpt)) {            params.set("splitPattern", (String) cmdLine.getValue(recordSplitterOpt));        }        String encoding = "UTF-8";        if (cmdLine.hasOption(encodingOpt)) {            encoding = (String) cmdLine.getValue(encodingOpt);        }        params.set("encoding", encoding);        String inputDir = (String) cmdLine.getValue(inputDirOpt);        String outputDir = (String) cmdLine.getValue(outputOpt);        params.set("input", inputDir);        params.set("output", outputDir);        params.set("groupingFieldCount", "2");        params.set("gfield0", "1");        params.set("gfield1", "2");        params.set("selectedFieldCount", "1");        params.set("field0", "3");        params.set("maxTransactionLength", "100");        KeyBasedStringTupleGrouper.startJob(params);    } catch (OptionException ex) {        CommandLineUtil.printHelp(group);    }}
f1eafba4bbf64cef3f30d9ed8feb723f429cf24cddf7bc296bc38804ea234821
serializationWithoutCsv
public void serializationWithoutCsv() throws IOException
{    LogisticModelParameters params = new LogisticModelParameters();    params.setTargetVariable("foo");    params.setTypeMap(Collections.<String, String>emptyMap());    params.setTargetCategories(Arrays.asList("foo", "bar"));    params.setNumFeatures(1);    params.createRegression();        params.saveTo(new ByteArrayOutputStream());}
dbdc9b7615d46599a47101a55b67bea44ca33b65f16835a6e514c6d6da78bd7b
testCategoryOrdering
public void testCategoryOrdering()
{    ModelDissector.Weight w = new ModelDissector.Weight("a", new DenseVector(new double[] { -2, -5, 5, 2, 4, 1, 0 }), 4);    assertEquals(1, w.getCategory(0), 0);    assertEquals(-5, w.getWeight(0), 0);    assertEquals(2, w.getCategory(1), 0);    assertEquals(5, w.getWeight(1), 0);    assertEquals(4, w.getCategory(2), 0);    assertEquals(4, w.getWeight(2), 0);    assertEquals(0, w.getCategory(3), 0);    assertEquals(-2, w.getWeight(3), 0);}
61ee92b635511c4b5e5770c7823746839fe65b0ed7774dfe62c12ba14757b8e8
example131
public void example131() throws Exception
{    String outputFile = getTestTempFile("model").getAbsolutePath();    StringWriter sw = new StringWriter();    PrintWriter pw = new PrintWriter(sw, true);    TrainLogistic.mainToOutput(new String[] { "--input", "donut.csv", "--output", outputFile, "--target", "color", "--categories", "2", "--predictors", "x", "y", "--types", "numeric", "--features", "20", "--passes", "100", "--rate", "50" }, pw);    String trainOut = sw.toString();    assertTrue(trainOut.contains("x -0.7"));    assertTrue(trainOut.contains("y -0.4"));    LogisticModelParameters lmp = TrainLogistic.getParameters();    assertEquals(1.0e-4, lmp.getLambda(), 1.0e-9);    assertEquals(20, lmp.getNumFeatures());    assertTrue(lmp.useBias());    assertEquals("color", lmp.getTargetVariable());    CsvRecordFactory csv = lmp.getCsvRecordFactory();    assertEquals("[1, 2]", new TreeSet<>(csv.getTargetCategories()).toString());    assertEquals("[Intercept Term, x, y]", Sets.newTreeSet(csv.getPredictors()).toString());        AbstractVectorClassifier model = TrainLogistic.getModel();    List<String> data = Resources.readLines(Resources.getResource("donut.csv"), Charsets.UTF_8);    Map<String, Double> expectedValues = ImmutableMap.of("x", -0.7, "y", -0.43, "Intercept Term", -0.15);    verifyModel(lmp, csv, data, model, expectedValues);        try (InputStream in = new FileInputStream(new File(outputFile))) {        LogisticModelParameters lmpOut = LogisticModelParameters.loadFrom(in);        CsvRecordFactory csvOut = lmpOut.getCsvRecordFactory();        csvOut.firstLine(data.get(0));        OnlineLogisticRegression lrOut = lmpOut.createRegression();        verifyModel(lmpOut, csvOut, data, lrOut, expectedValues);    }    sw = new StringWriter();    pw = new PrintWriter(sw, true);    RunLogistic.mainToOutput(new String[] { "--input", "donut.csv", "--model", outputFile, "--auc", "--confusion" }, pw);    trainOut = sw.toString();    assertTrue(trainOut.contains("AUC = 0.57"));    assertTrue(trainOut.contains("confusion: [[27.0, 13.0], [0.0, 0.0]]"));}
be9ab7b59bbe8cd9b4e5c6dae026a5717d18e2ddd8527b0fc19dfa4ecfa88701
example132
public void example132() throws Exception
{    String outputFile = getTestTempFile("model").getAbsolutePath();    StringWriter sw = new StringWriter();    PrintWriter pw = new PrintWriter(sw, true);    TrainLogistic.mainToOutput(new String[] { "--input", "donut.csv", "--output", outputFile, "--target", "color", "--categories", "2", "--predictors", "x", "y", "a", "b", "c", "--types", "numeric", "--features", "20", "--passes", "100", "--rate", "50" }, pw);    String trainOut = sw.toString();    assertTrue(trainOut.contains("a 0."));    assertTrue(trainOut.contains("b -1."));    assertTrue(trainOut.contains("c -25."));    sw = new StringWriter();    pw = new PrintWriter(sw, true);    RunLogistic.mainToOutput(new String[] { "--input", "donut.csv", "--model", outputFile, "--auc", "--confusion" }, pw);    trainOut = sw.toString();    assertTrue(trainOut.contains("AUC = 1.00"));    sw = new StringWriter();    pw = new PrintWriter(sw, true);    RunLogistic.mainToOutput(new String[] { "--input", "donut-test.csv", "--model", outputFile, "--auc", "--confusion" }, pw);    trainOut = sw.toString();    assertTrue(trainOut.contains("AUC = 0.9"));}
64eb098ffefa4197db9e390869e8f3d1ce9c793c234ee97deb06ea3aa0283644
verifyModel
private static void verifyModel(LogisticModelParameters lmp, RecordFactory csv, List<String> data, AbstractVectorClassifier model, Map<String, Double> expectedValues)
{    ModelDissector md = new ModelDissector();    for (String line : data.subList(1, data.size())) {        Vector v = new DenseVector(lmp.getNumFeatures());        csv.getTraceDictionary().clear();        csv.processLine(line, v);        md.update(v, csv.getTraceDictionary(), model);    }        List<ModelDissector.Weight> weights = md.summary(10);    Set<String> expected = Sets.newHashSet(expectedValues.keySet());    for (ModelDissector.Weight weight : weights) {        assertTrue(expected.remove(weight.getFeature()));        assertEquals(expectedValues.get(weight.getFeature()), weight.getWeight(), 0.1);    }    assertEquals(0, expected.size());}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    super.setUp();    configuration = getConfiguration();    output = getTestTempDirPath();}
977d626577d748e1d9bfd0ac77b0762d21eb007099320f9945e724ab56bcba20
testAcceptNotFinal
public void testAcceptNotFinal() throws Exception
{    Path path0 = new Path(output, "clusters-0");    Path path1 = new Path(output, "clusters-1");    path0.getFileSystem(configuration).createNewFile(path0);    path1.getFileSystem(configuration).createNewFile(path1);    PathFilter clustersFilter = new ClustersFilter();    assertTrue(clustersFilter.accept(path0));    assertTrue(clustersFilter.accept(path1));}
0aa0524f9579b0fe346734a42f582728d704b37fe6eab58a355aa48a24c3efbc
testAcceptFinalPath
public void testAcceptFinalPath() throws IOException
{    Path path0 = new Path(output, "clusters-0");    Path path1 = new Path(output, "clusters-1");    Path path2 = new Path(output, "clusters-2");    Path path3Final = new Path(output, "clusters-3-final");    path0.getFileSystem(configuration).createNewFile(path0);    path1.getFileSystem(configuration).createNewFile(path1);    path2.getFileSystem(configuration).createNewFile(path2);    path3Final.getFileSystem(configuration).createNewFile(path3Final);    PathFilter clustersFilter = new ClustersFilter();    assertTrue(clustersFilter.accept(path0));    assertTrue(clustersFilter.accept(path1));    assertTrue(clustersFilter.accept(path2));    assertTrue(clustersFilter.accept(path3Final));}
dd13da0c80c268fb15ee0053415c6c2b229679fa9dfd8739d023d7b30b50d319
binomial
public static double binomial(double n, long k)
{    if (k < 0) {        return 0;    }    if (k == 0) {        return 1;    }    if (k == 1) {        return n;    }        double a = n - k + 1;    double b = 1;    double binomial = 1;    for (long i = k; i-- > 0; ) {        binomial *= (a++) / (b++);    }    return binomial;}
41bb21f9f56996779aeef2f2d5104803f013836ee3d05d106847f60c93b3da50
binomial
public static double binomial(long n, long k)
{    if (k < 0) {        return 0;    }    if (k == 0 || k == n) {        return 1;    }    if (k == 1 || k == n - 1) {        return n;    }        if (n > k) {        int max = LONG_FACTORIALS.length + DOUBLE_FACTORIALS.length;        if (n < max) {                        double n_fac = factorial((int) n);            double k_fac = factorial((int) k);            double n_minus_k_fac = factorial((int) (n - k));            double nk = n_minus_k_fac * k_fac;            if (nk != Double.POSITIVE_INFINITY) {                                return n_fac / nk;            }        }        if (k > n / 2) {            k = n - k;        }        }        long a = n - k + 1;    long b = 1;    double binomial = 1;    for (long i = k; i-- > 0; ) {        binomial *= (double) a++ / (b++);    }    return binomial;}
002d80a111266e009167fe57be20c9b0eb5c1528e37fcdd36e122d9b71db88e3
ceil
public static long ceil(double value)
{    return Math.round(Math.ceil(value));}
3c49ec63a4c93ee94950e3977e832dff89604f904ae0f9d9f9147c3791356c8f
chbevl
public static double chbevl(double x, double[] coef, int N)
{    int p = 0;    double b0 = coef[p++];    double b1 = 0.0;    int i = N - 1;    double b2;    do {        b2 = b1;        b1 = b0;        b0 = x * b1 - b2 + coef[p++];    } while (--i > 0);    return 0.5 * (b0 - b2);}
d4189d9555ad9306cb3d90d7283949cbbcb43f21b01ef729870ca2fbb11fb02b
factorial
private static double factorial(int k)
{    if (k < 0) {        throw new IllegalArgumentException();    }    int length1 = LONG_FACTORIALS.length;    if (k < length1) {        return LONG_FACTORIALS[k];    }    int length2 = DOUBLE_FACTORIALS.length;    if (k < length1 + length2) {        return DOUBLE_FACTORIALS[k - length1];    } else {        return Double.POSITIVE_INFINITY;    }}
71ab0cc5854c4004e0da1d7639b89267bb8782b2e1d8d58138930022dc965435
floor
public static long floor(double value)
{    return Math.round(Math.floor(value));}
c8f94d2cb42be7979cd8a9b2bde9777b9c9233685bcd4ce80a8e4633416f4ebc
log
public static double log(double base, double value)
{    return Math.log(value) / Math.log(base);}
c19e50c9e03f15b980c74d44776a1e031374fa6bb6341019e9d43c3482e01e95
log10
public static double log10(double value)
{        return Math.log(value) * 0.43429448190325176;}
29ef7d9aefb06440c0cc44df875628bb8e882e26491eeac602d3451c17f5ae2a
log2
public static double log2(double value)
{        return Math.log(value) * 1.4426950408889634;}
9d14a4746c78c2b709e9a13620b26d1b041bf3df6cdffde93c7e33fe281ede55
logFactorial
public static double logFactorial(int k)
{    if (k >= 30) {        double r = 1.0 / k;        double rr = r * r;        double C7 = -5.95238095238095238e-04;        double C5 = 7.93650793650793651e-04;        double C3 = -2.77777777777777778e-03;        double C1 = 8.33333333333333333e-02;        double C0 = 9.18938533204672742e-01;        return (k + 0.5) * Math.log(k) - k + C0 + r * (C1 + rr * (C3 + rr * (C5 + rr * C7)));    } else {        return LOG_FACTORIALS[k];    }}
fd245bb43138e3d5e814d25a91a19bc8c2973f4daa8d9cff682b589eec3ec48a
longFactorial
public static long longFactorial(int k)
{    if (k < 0) {        throw new IllegalArgumentException("Negative k");    }    if (k < LONG_FACTORIALS.length) {        return LONG_FACTORIALS[k];    }    throw new IllegalArgumentException("Overflow");}
82743431524615865281e124d8aec2d86b6b3b1e24638c56645273f2118c44d5
stirlingCorrection
public static double stirlingCorrection(int k)
{    if (k > 30) {        double r = 1.0 / k;        double rr = r * r;                double C7 = -5.95238095238095238e-04;                double C5 = 7.93650793650793651e-04;                double C3 = -2.77777777777777778e-03;                double C1 = 8.33333333333333333e-02;        return r * (C1 + rr * (C3 + rr * (C5 + rr * C7)));    } else {        return STIRLING_CORRECTION[k];    }}
defd639e41224e2755f611e9e012caea910b64ac28f619874fd4a0bca0f9485b
useTestSeed
public static void useTestSeed()
{    testSeed = true;    synchronized (INSTANCES) {        for (RandomWrapper rng : INSTANCES.keySet()) {            rng.resetToTestSeed();        }    }}
0fc38752e99ffb79a212b10b55177f23747e9ab0a53c924e89bf4c43febb2ea3
getRandom
public static RandomWrapper getRandom()
{    RandomWrapper random = new RandomWrapper();    if (testSeed) {        random.resetToTestSeed();    }    INSTANCES.put(random, Boolean.TRUE);    return random;}
6ade01711286e39a819e2d5a512525e49ad16cfcbb17ab7c9cad97f50f61845d
getRandom
public static Random getRandom(long seed)
{    RandomWrapper random = new RandomWrapper(seed);    INSTANCES.put(random, Boolean.TRUE);    return random;}
3fa389194b7988892604bbec36686c304d18fadf283e45762cd8f8e3b28a150b
hashDouble
public static int hashDouble(double value)
{    return Longs.hashCode(Double.doubleToLongBits(value));}
e4f0467cc3a035b7f57f12dc3033eb2bd1f087bfb3cf5d668cd632599fe17152
hashFloat
public static int hashFloat(float value)
{    return Float.floatToIntBits(value);}
e8850a93d8c183181cd8e366743ddbaae7f7b5ec0847bd0c291ab4df03efbf62
nextTwinPrime
public static int nextTwinPrime(int n)
{    if (n > MAX_INT_SMALLER_TWIN_PRIME) {        throw new IllegalArgumentException();    }    if (n <= 3) {        return 5;    }    int next = Primes.nextPrime(n);    while (!Primes.isPrime(next + 2)) {        next = Primes.nextPrime(next + 4);    }    return next + 2;}
3ae633f9c1a8d21f3452d2d962d1e4d86a8a72ddf6280d745b8e0017426841ef
setSeed
public void setSeed(long seed)
{        if (random != null) {        random.setSeed(seed);    }}
0541833a0f1e544e4821b57ecfef5f9d0b18cddcd923e1f0810a602cab41d9f5
resetToTestSeed
 void resetToTestSeed()
{    setSeed(STANDARD_SEED);}
f49f5f35a2f97f48c7468e05b4952b49504315cc1cbb028336955cf39ad7d60f
getRandomGenerator
public RandomGenerator getRandomGenerator()
{    return random;}
aa1850f77ec9749956a5c072e2e1c8e7874ec5c0cee38f09c60642e7e0672f24
next
protected int next(int bits)
{        throw new UnsupportedOperationException();}
e8e888893c5a1e051350b711df7b393fa501dba6cef886f595022538b4f976f6
nextBytes
public void nextBytes(byte[] bytes)
{    random.nextBytes(bytes);}
fdad8c53e4cb93ac9606cf0b9361af34b8b3fd5bb4f6e88ad403d16c89019543
nextInt
public int nextInt()
{    return random.nextInt();}
ca8b4aa3b49c403b9d33b0aae94f29223a2a5883e5a49704269ded43dc34fe85
nextInt
public int nextInt(int n)
{    return random.nextInt(n);}
c07ff43a11a0fd30355c754b084700be1eadeb6e7293cc052804e1ca4dba70c9
nextLong
public long nextLong()
{    return random.nextLong();}
4b9c699eebc79255653a14d145ee50a9e723eb3d0304d0b2c097a3e97f401cdb
nextBoolean
public boolean nextBoolean()
{    return random.nextBoolean();}
d66b64f4fc9e91b8f6c608cd60c18659ef69861a38b507ab31f92b36caeda32d
nextFloat
public float nextFloat()
{    return random.nextFloat();}
d6d7ecac7880b96314133f7a8ed91d06073e9d6de2cb7ebd98123903ecca9b91
nextDouble
public double nextDouble()
{    return random.nextDouble();}
e9bf6ef62705b5de99d998d8f366c753cee406b4b9feca89b86ab58d0400fae4
nextGaussian
public double nextGaussian()
{    return random.nextGaussian();}
fced1a1d2ceb83a91b1d567b5d0beca0d2d5c9e0d49e31ab19b0ba709c59ea78
columnSize
public int columnSize()
{    return columns;}
74a095a07dad7124fd7b9f4f8c752edb4cdf837c408fe1b86e1f1005a20d23f8
rowSize
public int rowSize()
{    return rows;}
4e2991346111ce7b0ad21d3be20e5260c73af42a053d742339e6b45599b2c8dc
iterator
public Iterator<MatrixSlice> iterator()
{    return iterateAll();}
4f215be71dad866961124672ae15071a4e7a56933483dcadaee74820c5f0e03e
iterateAll
public Iterator<MatrixSlice> iterateAll()
{    return new AbstractIterator<MatrixSlice>() {        private int row;        @Override        protected MatrixSlice computeNext() {            if (row >= numRows()) {                return endOfData();            }            int i = row++;            return new MatrixSlice(viewRow(i), i);        }    };}
32f3173c937cfeaeed46d4345ac3b0b7af97c241c6c97b7de883cc81138d5b15
computeNext
protected MatrixSlice computeNext()
{    if (row >= numRows()) {        return endOfData();    }    int i = row++;    return new MatrixSlice(viewRow(i), i);}
99eb89100e81a1c9b6d2c2b9bacb794d4a9322c5692bbc72b555785bebf7a3d9
iterateNonEmpty
public Iterator<MatrixSlice> iterateNonEmpty()
{    return iterator();}
4f84a93591875e1cca8d9e5ad9481c6ce323c0c90a5b0b7da8751eb116523a29
numSlices
public int numSlices()
{    return numRows();}
0ac75a453d3b13fef0da76f439d342e5ffee92eea380935aabee1098a908b01e
get
public double get(String rowLabel, String columnLabel)
{    if (columnLabelBindings == null || rowLabelBindings == null) {        throw new IllegalStateException("Unbound label");    }    Integer row = rowLabelBindings.get(rowLabel);    Integer col = columnLabelBindings.get(columnLabel);    if (row == null || col == null) {        throw new IllegalStateException("Unbound label");    }    return get(row, col);}
0f756b0118227122f5c083d7705b4ff1087a457360952cb620a591f833f9fc5e
getColumnLabelBindings
public Map<String, Integer> getColumnLabelBindings()
{    return columnLabelBindings;}
48070f409ada2854f2c11dda6a2a3fbe887b481a1803f1ae3900f0c2616292e3
getRowLabelBindings
public Map<String, Integer> getRowLabelBindings()
{    return rowLabelBindings;}
0a981340969e581b7fd8a413031085bff82580f3824f21cae93d2205a579412e
set
public void set(String rowLabel, double[] rowData)
{    if (columnLabelBindings == null) {        throw new IllegalStateException("Unbound label");    }    Integer row = rowLabelBindings.get(rowLabel);    if (row == null) {        throw new IllegalStateException("Unbound label");    }    set(row, rowData);}
22d92e3a8f72d40cc7d3f8dc63ee45b2871a5048e3b9e07af2e8f3ba8b1fe84c
set
public void set(String rowLabel, int row, double[] rowData)
{    if (rowLabelBindings == null) {        rowLabelBindings = new HashMap<>();    }    rowLabelBindings.put(rowLabel, row);    set(row, rowData);}
f3559ad5e184445e172d8b3b10d8b75b624937856d61c164f74cec4e7d64c704
set
public void set(String rowLabel, String columnLabel, double value)
{    if (columnLabelBindings == null || rowLabelBindings == null) {        throw new IllegalStateException("Unbound label");    }    Integer row = rowLabelBindings.get(rowLabel);    Integer col = columnLabelBindings.get(columnLabel);    if (row == null || col == null) {        throw new IllegalStateException("Unbound label");    }    set(row, col, value);}
5f7678b96432f26f138efb7eb9455b467bbf60d97c4164ee20a9303a48bae7ae
set
public void set(String rowLabel, String columnLabel, int row, int column, double value)
{    if (rowLabelBindings == null) {        rowLabelBindings = new HashMap<>();    }    rowLabelBindings.put(rowLabel, row);    if (columnLabelBindings == null) {        columnLabelBindings = new HashMap<>();    }    columnLabelBindings.put(columnLabel, column);    set(row, column, value);}
8cd77d26dced9419a343ab2070b67710eb630811496243b994803954ca8b503d
setColumnLabelBindings
public void setColumnLabelBindings(Map<String, Integer> bindings)
{    columnLabelBindings = bindings;}
8d441022e01e1308632db350977f25311bf41ae540e3ac06a66331ed3ac9eba3
setRowLabelBindings
public void setRowLabelBindings(Map<String, Integer> bindings)
{    rowLabelBindings = bindings;}
3b35afb5959174898c07539693af05a525573b46f716ac385ab9f25f3d0f4d1a
numRows
public int numRows()
{    return rowSize();}
2e7eae53900c6679869bde9f32aee0e32dd69ad8928f5c6f09f3776c3864db29
numCols
public int numCols()
{    return columnSize();}
ae284afe1ade5afe0242f68b99b1251c8ef4ebfb1ffd6eaa841c8d273ed0c131
asFormatString
public String asFormatString()
{    return toString();}
13bb0e6afc607db9d98d3823768dff2d87db4d7d21d4701725b875d2cf5126d7
assign
public Matrix assign(double value)
{    int rows = rowSize();    int columns = columnSize();    for (int row = 0; row < rows; row++) {        for (int col = 0; col < columns; col++) {            setQuick(row, col, value);        }    }    return this;}
37eead7a2b5af001255ab211df2a9a2ca65115c94b3dfb9dde273b55e1c86869
assign
public Matrix assign(double[][] values)
{    int rows = rowSize();    if (rows != values.length) {        throw new CardinalityException(rows, values.length);    }    int columns = columnSize();    for (int row = 0; row < rows; row++) {        if (columns == values[row].length) {            for (int col = 0; col < columns; col++) {                setQuick(row, col, values[row][col]);            }        } else {            throw new CardinalityException(columns, values[row].length);        }    }    return this;}
bfca2cdd6e9adeabfb9ecc4ba7a9c7519e3c8ebe89127c7c86e17f01e99498c9
assign
public Matrix assign(Matrix other, DoubleDoubleFunction function)
{    int rows = rowSize();    if (rows != other.rowSize()) {        throw new CardinalityException(rows, other.rowSize());    }    int columns = columnSize();    if (columns != other.columnSize()) {        throw new CardinalityException(columns, other.columnSize());    }    for (int row = 0; row < rows; row++) {        for (int col = 0; col < columns; col++) {            setQuick(row, col, function.apply(getQuick(row, col), other.getQuick(row, col)));        }    }    return this;}
c7b9095d9e97b5f4ae589a3fc0ac516b522a88c1bb719d012e8be887efa0496c
assign
public Matrix assign(Matrix other)
{    int rows = rowSize();    if (rows != other.rowSize()) {        throw new CardinalityException(rows, other.rowSize());    }    int columns = columnSize();    if (columns != other.columnSize()) {        throw new CardinalityException(columns, other.columnSize());    }    for (int row = 0; row < rows; row++) {        for (int col = 0; col < columns; col++) {            setQuick(row, col, other.getQuick(row, col));        }    }    return this;}
fb257471a103992bc618808f4483eec3f1f57ea976b1467f18fa4fdb8e71ac9e
assign
public Matrix assign(DoubleFunction function)
{    int rows = rowSize();    int columns = columnSize();    for (int row = 0; row < rows; row++) {        for (int col = 0; col < columns; col++) {            setQuick(row, col, function.apply(getQuick(row, col)));        }    }    return this;}
f6ea03af39612e004e1f95f7ea1595b6978fa685272bbd33fb96104e0c17edf9
aggregateRows
public Vector aggregateRows(VectorFunction f)
{    Vector r = new DenseVector(numRows());    int n = numRows();    for (int row = 0; row < n; row++) {        r.set(row, f.apply(viewRow(row)));    }    return r;}
cc845ba0d004ee14775588b6cb695a9053ef1f384e5196e605687c0f7eeac020
viewRow
public Vector viewRow(int row)
{    return new MatrixVectorView(this, row, 0, 0, 1);}
d46193949587a2e9ca1ec7df8ed6534443c7731e6ae91f71f45b19ee95634c85
viewColumn
public Vector viewColumn(int column)
{    return new MatrixVectorView(this, 0, column, 1, 0);}
24b87aa3c85b3c0c423315f8f17533d541580f31a389beffa11ef46db109611f
viewDiagonal
public Vector viewDiagonal()
{    return new MatrixVectorView(this, 0, 0, 1, 1);}
d8a8db0705fc5f4f5287887328fbd5f5d0fc479720b958d2de8abb0118cc7403
aggregate
public double aggregate(final DoubleDoubleFunction combiner, final DoubleFunction mapper)
{    return aggregateRows(new VectorFunction() {        @Override        public double apply(Vector v) {            return v.aggregate(combiner, mapper);        }    }).aggregate(combiner, Functions.IDENTITY);}
34458c5c4d61eeeaeb2eaf91ebf4340feeee54c6c8bea0ed7d7a4c377baca8e5
apply
public double apply(Vector v)
{    return v.aggregate(combiner, mapper);}
479f92bb6803bff12b22a39b76893491bdba22a594b2e5d656f9e39ce0667536
aggregateColumns
public Vector aggregateColumns(VectorFunction f)
{    Vector r = new DenseVector(numCols());    for (int col = 0; col < numCols(); col++) {        r.set(col, f.apply(viewColumn(col)));    }    return r;}
652cd8ec2ed3475b7a0d9f427e5896f65f18ba7315a484b9310922eec82290a9
determinant
public double determinant()
{    int rows = rowSize();    int columns = columnSize();    if (rows != columns) {        throw new CardinalityException(rows, columns);    }    if (rows == 2) {        return getQuick(0, 0) * getQuick(1, 1) - getQuick(0, 1) * getQuick(1, 0);    } else {                        int sign = 1;        double ret = 0;        for (int i = 0; i < columns; i++) {            Matrix minor = new DenseMatrix(rows - 1, columns - 1);            for (int j = 1; j < rows; j++) {                boolean flag = false;                /* column offset flag */                for (int k = 0; k < columns; k++) {                    if (k == i) {                        flag = true;                        continue;                    }                    minor.set(j - 1, flag ? k - 1 : k, getQuick(j, k));                }            }            ret += getQuick(0, i) * sign * minor.determinant();            sign *= -1;        }        return ret;    }}
718d9e27b4314887356041933895f3ca7614086ebd95c67fc99404a51fab676b
clone
public Matrix clone()
{    AbstractMatrix clone;    try {        clone = (AbstractMatrix) super.clone();    } catch (CloneNotSupportedException cnse) {                throw new IllegalStateException(cnse);    }    if (rowLabelBindings != null) {        clone.rowLabelBindings = Maps.newHashMap(rowLabelBindings);    }    if (columnLabelBindings != null) {        clone.columnLabelBindings = Maps.newHashMap(columnLabelBindings);    }    return clone;}
34291bef7c169eb4fc9416b88f7f5f4293b301034ccde730d27a672ca6a7bb1c
divide
public Matrix divide(double x)
{    Matrix result = like();    for (int row = 0; row < rowSize(); row++) {        for (int col = 0; col < columnSize(); col++) {            result.setQuick(row, col, getQuick(row, col) / x);        }    }    return result;}
abe16e02380ed63ae0c77fc26bcd8f519fbf330f116a704b6ed2825c879e5f3a
get
public double get(int row, int column)
{    if (row < 0 || row >= rowSize()) {        throw new IndexException(row, rowSize());    }    if (column < 0 || column >= columnSize()) {        throw new IndexException(column, columnSize());    }    return getQuick(row, column);}
3e5c0796ba52462cf40124881ea1f9ff330f75929122753c6f7333b8502d1d1c
minus
public Matrix minus(Matrix other)
{    int rows = rowSize();    if (rows != other.rowSize()) {        throw new CardinalityException(rows, other.rowSize());    }    int columns = columnSize();    if (columns != other.columnSize()) {        throw new CardinalityException(columns, other.columnSize());    }    Matrix result = like();    for (int row = 0; row < rows; row++) {        for (int col = 0; col < columns; col++) {            result.setQuick(row, col, getQuick(row, col) - other.getQuick(row, col));        }    }    return result;}
53ca8cfa0bab4292438e375ae0435e802cfc75aae6570ab88f106bd612e54b16
plus
public Matrix plus(double x)
{    Matrix result = like();    int rows = rowSize();    int columns = columnSize();    for (int row = 0; row < rows; row++) {        for (int col = 0; col < columns; col++) {            result.setQuick(row, col, getQuick(row, col) + x);        }    }    return result;}
bfe00c87ec1085c7dc7bc71038523f1365a64ada9a2471b89413e1babe0360cd
plus
public Matrix plus(Matrix other)
{    int rows = rowSize();    if (rows != other.rowSize()) {        throw new CardinalityException(rows, other.rowSize());    }    int columns = columnSize();    if (columns != other.columnSize()) {        throw new CardinalityException(columns, other.columnSize());    }    Matrix result = like();    for (int row = 0; row < rows; row++) {        for (int col = 0; col < columns; col++) {            result.setQuick(row, col, getQuick(row, col) + other.getQuick(row, col));        }    }    return result;}
9efeb4e2fbc1838addbc8a78c30ab4b666aa0650329126fbae41720064e01237
set
public void set(int row, int column, double value)
{    if (row < 0 || row >= rowSize()) {        throw new IndexException(row, rowSize());    }    if (column < 0 || column >= columnSize()) {        throw new IndexException(column, columnSize());    }    setQuick(row, column, value);}
55955c9afeabb37a970cf9844c88d721017765273050fae9f660b94204b50281
set
public void set(int row, double[] data)
{    int columns = columnSize();    if (columns < data.length) {        throw new CardinalityException(columns, data.length);    }    int rows = rowSize();    if (row < 0 || row >= rows) {        throw new IndexException(row, rowSize());    }    for (int i = 0; i < columns; i++) {        setQuick(row, i, data[i]);    }}
352069ed82ea17ba5c56190ff5648e392f84c6e18fac4d967b8d404279485298
times
public Matrix times(double x)
{    Matrix result = like();    int rows = rowSize();    int columns = columnSize();    for (int row = 0; row < rows; row++) {        for (int col = 0; col < columns; col++) {            result.setQuick(row, col, getQuick(row, col) * x);        }    }    return result;}
07edaa38b63aaa02b484989af04fac05f162d5fe81194b8fb6dd87f9fade2833
times
public Matrix times(Matrix other)
{    int columns = columnSize();    if (columns != other.rowSize()) {        throw new CardinalityException(columns, other.rowSize());    }    int rows = rowSize();    int otherColumns = other.columnSize();    Matrix result = like(rows, otherColumns);    for (int row = 0; row < rows; row++) {        for (int col = 0; col < otherColumns; col++) {            double sum = 0.0;            for (int k = 0; k < columns; k++) {                sum += getQuick(row, k) * other.getQuick(k, col);            }            result.setQuick(row, col, sum);        }    }    return result;}
722f1585f6df20bce925b4fe7f6f41c55e402b92a35f419be7f6af7c83938334
times
public Vector times(Vector v)
{    int columns = columnSize();    if (columns != v.size()) {        throw new CardinalityException(columns, v.size());    }    int rows = rowSize();    Vector w = new DenseVector(rows);    for (int row = 0; row < rows; row++) {        w.setQuick(row, v.dot(viewRow(row)));    }    return w;}
1578c670303bd46bac5ba56bec209bcd3fae9a9f78d1eddd6d34bd10b9231108
timesSquared
public Vector timesSquared(Vector v)
{    int columns = columnSize();    if (columns != v.size()) {        throw new CardinalityException(columns, v.size());    }    int rows = rowSize();    Vector w = new DenseVector(columns);    for (int i = 0; i < rows; i++) {        Vector xi = viewRow(i);        double d = xi.dot(v);        if (d != 0.0) {            w.assign(xi, new PlusMult(d));        }    }    return w;}
f6617c43b6dd5f91010c233e3bcf9c6f78a0ecee830fcb10168e8aa0024d26a0
transpose
public Matrix transpose()
{    int rows = rowSize();    int columns = columnSize();    Matrix result = like(columns, rows);    for (int row = 0; row < rows; row++) {        for (int col = 0; col < columns; col++) {            result.setQuick(col, row, getQuick(row, col));        }    }    return result;}
2790911dfaf9008a5ec53f5440a28547fcc44ec2c01b5212aa6d5a8f618ae9f7
viewPart
public Matrix viewPart(int rowOffset, int rowsRequested, int columnOffset, int columnsRequested)
{    return viewPart(new int[] { rowOffset, columnOffset }, new int[] { rowsRequested, columnsRequested });}
242adb7156cbde039fd67ab8f5ed8c9c46c199c38c6f12d05d2dbaffd8178820
viewPart
public Matrix viewPart(int[] offset, int[] size)
{    if (offset[ROW] < 0) {        throw new IndexException(offset[ROW], 0);    }    if (offset[ROW] + size[ROW] > rowSize()) {        throw new IndexException(offset[ROW] + size[ROW], rowSize());    }    if (offset[COL] < 0) {        throw new IndexException(offset[COL], 0);    }    if (offset[COL] + size[COL] > columnSize()) {        throw new IndexException(offset[COL] + size[COL], columnSize());    }    return new MatrixView(this, offset, size);}
b95580f8663abb6debfc0eb1df4fa773879d99b496a6abea19638268659178f2
zSum
public double zSum()
{    double result = 0;    for (int row = 0; row < rowSize(); row++) {        for (int col = 0; col < columnSize(); col++) {            result += getQuick(row, col);        }    }    return result;}
7714b327d86a7bf6870ba63ac39d817cef2071cb1e37ee1443f8106d3de5443a
getNumNondefaultElements
public int[] getNumNondefaultElements()
{    return new int[] { rowSize(), columnSize() };}
884f06bfd74abf9fcac20d7d3e56bc5f671ec9a0f686c5a89f82c391ef5b3fce
clone
public Vector clone()
{    Vector v = new DenseVector(size());    v.assign(this, Functions.PLUS);    return v;}
383032e836ae8e377e669da8e774cd6f6410cb106bd66015b484c883dc1c467c
isDense
public boolean isDense()
{    return true;}
048fcadf359a37696af85547983c8e1a90a6c62d53a2f5c66ba6b94ae1c5b98c
isSequentialAccess
public boolean isSequentialAccess()
{    return true;}
39aa63eded95450eed8ae8438d97998d3316f664b548900552f7ffb6b0441d94
matrixLike
protected Matrix matrixLike(int rows, int columns)
{    return matrix.like(rows, columns);}
ebaf88b6206d3b34b79e1287ba43a83a7321437a7f6da5136b43af17bd0a0476
iterator
public Iterator<Element> iterator()
{    return new AbstractIterator<Element>() {        private int i;        @Override        protected Element computeNext() {            if (i >= size()) {                return endOfData();            }            return getElement(i++);        }    };}
805efeafbd5a8971b9858a258536df263d73a6d5b733043fdf392af2c4e52cbc
computeNext
protected Element computeNext()
{    if (i >= size()) {        return endOfData();    }    return getElement(i++);}
0494c3c5bbf01f97ae3671ecd67c5586bc95bd0aa1907bd0e3ebdc94d70e1683
iterateNonZero
public Iterator<Element> iterateNonZero()
{    return iterator();}
7caed9042b0906ca27d79fd0a6942db0c4acf90eb92520ee6956c6ce53ba1cd2
getElement
public Element getElement(final int i)
{    return new Element() {        @Override        public double get() {            return getQuick(i);        }        @Override        public int index() {            return i;        }        @Override        public void set(double value) {            setQuick(i, value);        }    };}
6f9021560b40d5f0ea4687dcfc9163f88e04e559e2fc0af5f9a1fed73b4e4c24
get
public double get()
{    return getQuick(i);}
5dd366da2313537c415c3c2ab9ed1909d1250d894a032bd02373d113516571d0
index
public int index()
{    return i;}
0ca3b3a320922927ea9a06f3def94b995d23a5eb7b95de57c7935a827c79759c
set
public void set(double value)
{    setQuick(i, value);}
0f2cea51f07acae4d2eb073f5151beaf6dba8920eaf21ed6212f67553909727d
mergeUpdates
public void mergeUpdates(OrderedIntDoubleMapping updates)
{    throw new UnsupportedOperationException("Cannot mutate TransposeViewVector");}
2263144cad9c9fdd2eecb03c9f0c31fc79e73b974408c87f743169e8bea1c8f3
getQuick
public double getQuick(int index)
{    Vector v = rowToColumn ? matrix.viewColumn(index) : matrix.viewRow(index);    return v == null ? 0.0 : v.getQuick(transposeOffset);}
d90a04e96781b1eebeec5aca2a7d384a466650ea31ec4abd55dff982b7d2e12d
setQuick
public void setQuick(int index, double value)
{    Vector v = rowToColumn ? matrix.viewColumn(index) : matrix.viewRow(index);    if (v == null) {        v = newVector(numCols);        if (rowToColumn) {            matrix.assignColumn(index, v);        } else {            matrix.assignRow(index, v);        }    }    v.setQuick(transposeOffset, value);}
56b43a26de096580533f1e7e4c04031291fce6dfae6cef79acbdefc67cf20188
newVector
protected Vector newVector(int cardinality)
{    return new DenseVector(cardinality);}
3f06e4bc1bde206fe6ac26b2e2c12970bc557eee7de0d8e8394b1f96568db34b
like
public Vector like()
{    return new DenseVector(size());}
de7fe3d006f2cc6fa563e7089bbae0e5300ec5b2f82e856c1118dd26a5798a5f
like
public Vector like(int cardinality)
{    return new DenseVector(cardinality);}
f6c83ebe319a78b7975eba92f536cfcf2e5e6786960fb07f54a0c99258711da5
getNumNondefaultElements
public int getNumNondefaultElements()
{    return size();}
6b67fad6dd27aa2525cafe6cf3396d2225fbcdf57e5378ac7a3dee60e61f20e8
getLookupCost
public double getLookupCost()
{    return (rowToColumn ? matrix.viewColumn(0) : matrix.viewRow(0)).getLookupCost();}
c79b5203142f65c96c29c2652557bad0bda511dfe38011e3b2877dd681f7c9cf
getIteratorAdvanceCost
public double getIteratorAdvanceCost()
{    return (rowToColumn ? matrix.viewColumn(0) : matrix.viewRow(0)).getIteratorAdvanceCost();}
c5fbf138e094d3027905103c89bbab4aa48cd369c50dde054752fd31aa322767
isAddConstantTime
public boolean isAddConstantTime()
{    return (rowToColumn ? matrix.viewColumn(0) : matrix.viewRow(0)).isAddConstantTime();}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    int row = 0;    int maxRowsToDisplay = 10;    int maxColsToDisplay = 20;    int colsToDisplay = maxColsToDisplay;    if (maxColsToDisplay > columnSize()) {        colsToDisplay = columnSize();    }    StringBuilder s = new StringBuilder("{\n");    Iterator<MatrixSlice> it = iterator();    while ((it.hasNext()) && (row < maxRowsToDisplay)) {        MatrixSlice next = it.next();        s.append(" ").append(next.index()).append(" =>\t").append(new VectorView(next.vector(), 0, colsToDisplay)).append('\n');        row++;    }    String returnString = s.toString();    if (maxColsToDisplay <= columnSize()) {        returnString = returnString.replace("}", " ... } ");    }    if (maxRowsToDisplay <= rowSize())        return returnString + ("... }");    else {        return returnString + ("}");    }}
4f943db0f33d27c9f70c541ef27a217346904d47c0870b555f1140eebdc0f9b2
getFlavor
public MatrixFlavor getFlavor()
{    throw new UnsupportedOperationException("Flavor support not implemented for this matrix.");}
925b6c0af2716d475d5e78f46e549c77e229efa113e150b00d5e1b6287de16eb
all
public Iterable<Element> all()
{    return new Iterable<Element>() {        @Override        public Iterator<Element> iterator() {            return AbstractVector.this.iterator();        }    };}
ebaf88b6206d3b34b79e1287ba43a83a7321437a7f6da5136b43af17bd0a0476
iterator
public Iterator<Element> iterator()
{    return AbstractVector.this.iterator();}
79761b2bde82a72af5456dc0789a0d7a6a00b985705b9fe5b7e2e4fc643ded15
nonZeroes
public Iterable<Element> nonZeroes()
{    return new Iterable<Element>() {        @Override        public Iterator<Element> iterator() {            return iterateNonZero();        }    };}
ebaf88b6206d3b34b79e1287ba43a83a7321437a7f6da5136b43af17bd0a0476
iterator
public Iterator<Element> iterator()
{    return iterateNonZero();}
ad91472a8eba4486be34525ff11666fd262da25724267fbaf658819d805a43bb
aggregate
public double aggregate(DoubleDoubleFunction aggregator, DoubleFunction map)
{    if (size == 0) {        return 0;    }        if (aggregator.isAssociativeAndCommutative() && aggregator.isLikeLeftMult() && size > getNumNondefaultElements() && !map.isDensifying()) {        return 0;    }    double result;    if (isSequentialAccess() || aggregator.isAssociativeAndCommutative()) {        Iterator<Element> iterator;                if (!map.isDensifying() && aggregator.isLikeRightPlus()) {            iterator = iterateNonZero();            if (!iterator.hasNext()) {                return 0;            }        } else {            iterator = iterator();        }        Element element = iterator.next();        result = map.apply(element.get());        while (iterator.hasNext()) {            element = iterator.next();            result = aggregator.apply(result, map.apply(element.get()));        }    } else {        result = map.apply(getQuick(0));        for (int i = 1; i < size; i++) {            result = aggregator.apply(result, map.apply(getQuick(i)));        }    }    return result;}
a85898b9f6be2e6a74d8c9cf590860cdcc7afe91571b28abda3f27dc495e0506
aggregate
public double aggregate(Vector other, DoubleDoubleFunction aggregator, DoubleDoubleFunction combiner)
{    Preconditions.checkArgument(size == other.size(), "Vector sizes differ");    if (size == 0) {        return 0;    }    return VectorBinaryAggregate.aggregateBest(this, other, aggregator, combiner);}
652b99eb4e9a262b74a7b3cfc036effdc8dda8563fcbe31fb8a2d36911ea55fc
viewPart
public Vector viewPart(int offset, int length)
{    if (offset < 0) {        throw new IndexException(offset, size);    }    if (offset + length > size) {        throw new IndexException(offset + length, size);    }    return new VectorView(this, offset, length);}
884f06bfd74abf9fcac20d7d3e56bc5f671ec9a0f686c5a89f82c391ef5b3fce
clone
public Vector clone()
{    try {        AbstractVector r = (AbstractVector) super.clone();        r.size = size;        r.lengthSquared = lengthSquared;        return r;    } catch (CloneNotSupportedException e) {        throw new IllegalStateException("Can't happen");    }}
49608444d34acf8c21b5de98b7ca587f30d3d8c2b2267746bea420e294082f35
divide
public Vector divide(double x)
{    if (x == 1.0) {        return clone();    }    Vector result = createOptimizedCopy();    for (Element element : result.nonZeroes()) {        element.set(element.get() / x);    }    return result;}
b0c6cf88ddad567458c3f9568e63bbd3ba3d401ed8f874e155db9189495e78d4
dot
public double dot(Vector x)
{    if (size != x.size()) {        throw new CardinalityException(size, x.size());    }    if (this == x) {        return getLengthSquared();    }    return aggregate(x, Functions.PLUS, Functions.MULT);}
754606c70c7faeb2876eb10111c4f1326ee2b93cb3ec4cc2a99af875df2d9493
dotSelf
protected double dotSelf()
{    return aggregate(Functions.PLUS, Functions.pow(2));}
9f213e4a143454bd6f6fafb1c1293c69c2707c2477182f834f9b8e4a465adafe
get
public double get(int index)
{    if (index < 0 || index >= size) {        throw new IndexException(index, size);    }    return getQuick(index);}
d82b144f248d736e85f2b7532a8b5190c1efdf491bff22194d6e776d9d004ac7
getElement
public Element getElement(int index)
{    return new LocalElement(index);}
522a2cb2764f9f34b1f533404314dd0113b5ed78a0de6d0783f3ec54609375cc
normalize
public Vector normalize()
{    return divide(Math.sqrt(getLengthSquared()));}
0978b7df23acea2fdc52d893200013252773356ec6e84a75d2a010439cffc48c
normalize
public Vector normalize(double power)
{    return divide(norm(power));}
b3d6d678da20f3a65cb98fc8bbdd89e832e2a722d929292197be4eb74ecd440c
logNormalize
public Vector logNormalize()
{    return logNormalize(2.0, Math.sqrt(getLengthSquared()));}
b72ab7b48aea139e8daf0d711f8fa7e0f2f41338b8750de918645cb98d0bad9c
logNormalize
public Vector logNormalize(double power)
{    return logNormalize(power, norm(power));}
1d7a8d1821c59227f680507d82101946b43c0483e33b6bc65ee24045b4589f0a
logNormalize
public Vector logNormalize(double power, double normLength)
{        if (Double.isInfinite(power) || power <= 1.0) {        throw new IllegalArgumentException("Power must be > 1 and < infinity");    } else {        double denominator = normLength * Math.log(power);        Vector result = createOptimizedCopy();        for (Element element : result.nonZeroes()) {            element.set(Math.log1p(element.get()) / denominator);        }        return result;    }}
cd58bf1d0ad8e4702d41c559a572b84f7b8d34cb58bfc0018689ffe97fe3cef8
norm
public double norm(double power)
{    if (power < 0.0) {        throw new IllegalArgumentException("Power must be >= 0");    }        if (Double.isInfinite(power)) {        return aggregate(Functions.MAX, Functions.ABS);    } else if (power == 2.0) {        return Math.sqrt(getLengthSquared());    } else if (power == 1.0) {        double result = 0.0;        Iterator<Element> iterator = this.iterateNonZero();        while (iterator.hasNext()) {            result += Math.abs(iterator.next().get());        }        return result;            } else if (power == 0.0) {        return getNumNonZeroElements();    } else {        return Math.pow(aggregate(Functions.PLUS, Functions.pow(power)), 1.0 / power);    }}
ad8e67cc94b6d67341e2eafa669a96e4de141addeda84e43821d24ae5aca2a5a
getLengthSquared
public double getLengthSquared()
{    if (lengthSquared >= 0.0) {        return lengthSquared;    }    return lengthSquared = dotSelf();}
4b2faf4e4fff196a9099ea61c4bdb51b2037b9b0a82cfff3cc4dd29f4641bf4b
invalidateCachedLength
public void invalidateCachedLength()
{    lengthSquared = -1;}
be10a2183b221888a79794f4bf64b6edc1a05fa621d8ec8d00a51d5d6a3d7311
getDistanceSquared
public double getDistanceSquared(Vector that)
{    if (size != that.size()) {        throw new CardinalityException(size, that.size());    }    double thisLength = getLengthSquared();    double thatLength = that.getLengthSquared();    double dot = dot(that);    double distanceEstimate = thisLength + thatLength - 2 * dot;    if (distanceEstimate > 1.0e-3 * (thisLength + thatLength)) {                return Math.max(distanceEstimate, 0);    } else {        return aggregate(that, Functions.PLUS, Functions.MINUS_SQUARED);    }}
673e2f18abb6a076f5f26e614aec950d2752388e647d9c268e8161b493f73a85
maxValue
public double maxValue()
{    if (size == 0) {        return Double.NEGATIVE_INFINITY;    }    return aggregate(Functions.MAX, Functions.IDENTITY);}
825d17834ad4d5540936ce10989cdc91141b79780ba970f5efa1f615e18f6920
maxValueIndex
public int maxValueIndex()
{    int result = -1;    double max = Double.NEGATIVE_INFINITY;    int nonZeroElements = 0;    Iterator<Element> iter = this.iterateNonZero();    while (iter.hasNext()) {        nonZeroElements++;        Element element = iter.next();        double tmp = element.get();        if (tmp > max) {            max = tmp;            result = element.index();        }    }        if (nonZeroElements < size && max < 0.0) {        for (Element element : all()) {            if (element.get() == 0.0) {                return element.index();            }        }    }    return result;}
e5c330b7bf4bcc42b747fb25502aa859f7e55feac55529444725ac7756c5b1da
minValue
public double minValue()
{    if (size == 0) {        return Double.POSITIVE_INFINITY;    }    return aggregate(Functions.MIN, Functions.IDENTITY);}
a58af97687735fad30d51302a64b5b3d3e939920191b08c27aa07d06a3744bf4
minValueIndex
public int minValueIndex()
{    int result = -1;    double min = Double.POSITIVE_INFINITY;    int nonZeroElements = 0;    Iterator<Element> iter = this.iterateNonZero();    while (iter.hasNext()) {        nonZeroElements++;        Element element = iter.next();        double tmp = element.get();        if (tmp < min) {            min = tmp;            result = element.index();        }    }        if (nonZeroElements < size && min > 0.0) {        for (Element element : all()) {            if (element.get() == 0.0) {                return element.index();            }        }    }    return result;}
9633b91a2f284f6d333a144ebf53a1813a31909260e076aa36ae8cd199af8df3
plus
public Vector plus(double x)
{    Vector result = createOptimizedCopy();    if (x == 0.0) {        return result;    }    return result.assign(Functions.plus(x));}
17d711a3d4954db6adfac8a15b4c06a4c6cf9bab0283311e95108d643e4535a3
plus
public Vector plus(Vector that)
{    if (size != that.size()) {        throw new CardinalityException(size, that.size());    }    return createOptimizedCopy().assign(that, Functions.PLUS);}
c23409779826dac95c386df54c347cdb3cbe5a36f4a561940c8c09fa1a085bcc
minus
public Vector minus(Vector that)
{    if (size != that.size()) {        throw new CardinalityException(size, that.size());    }    return createOptimizedCopy().assign(that, Functions.MINUS);}
40eb830e31d13276cef93d31667d9f8fe511a811948c5ebb2beb5e1bbd43f76e
set
public void set(int index, double value)
{    if (index < 0 || index >= size) {        throw new IndexException(index, size);    }    setQuick(index, value);}
c8a20d62d9c3255d60b3b80ebe6816bd042c01abf073d860c31aa2f68df390bf
incrementQuick
public void incrementQuick(int index, double increment)
{    setQuick(index, getQuick(index) + increment);}
8b96a7945012e7b138a0b76ff9af9b5fe4b135b2aaa1d15efa12f110aacd7076
times
public Vector times(double x)
{    if (x == 0.0) {        return like();    }    return createOptimizedCopy().assign(Functions.mult(x));}
7ee9fb0fa40acb3a34d5a0be54445ff662d333df0a26cf31da157bf82d75c4de
createOptimizedCopy
protected Vector createOptimizedCopy()
{    return createOptimizedCopy(this);}
b1c07cb9d0a15e293122d64d5a26d8759bf3d52aed263afb9aaaddb2438a8744
createOptimizedCopy
private static Vector createOptimizedCopy(Vector vector)
{    Vector result;    if (vector.isDense()) {        result = vector.like().assign(vector, Functions.SECOND_LEFT_ZERO);    } else {        result = vector.clone();    }    return result;}
4fb75b61dafac39063cafab3207fc2c8395ca64c361d93b8c08e2783be50140a
times
public Vector times(Vector that)
{    if (size != that.size()) {        throw new CardinalityException(size, that.size());    }    if (this.getNumNondefaultElements() <= that.getNumNondefaultElements()) {        return createOptimizedCopy(this).assign(that, Functions.MULT);    } else {        return createOptimizedCopy(that).assign(this, Functions.MULT);    }}
b95580f8663abb6debfc0eb1df4fa773879d99b496a6abea19638268659178f2
zSum
public double zSum()
{    return aggregate(Functions.PLUS, Functions.IDENTITY);}
8b7fcb91dbcc77620d88bd932afdf043420de45274bcf542432eb86706753faf
getNumNonZeroElements
public int getNumNonZeroElements()
{    int count = 0;    Iterator<Element> it = iterateNonZero();    while (it.hasNext()) {        if (it.next().get() != 0.0) {            count++;        }    }    return count;}
a1323639bf61f130500353a35c23f7a93de0f5d2d5c75d6189884271d6351d22
assign
public Vector assign(double value)
{    Iterator<Element> it;    if (value == 0.0) {                it = iterateNonZero();        while (it.hasNext()) {            it.next().set(value);        }    } else {        if (isSequentialAccess() && !isAddConstantTime()) {                                    it = iterator();            OrderedIntDoubleMapping updates = new OrderedIntDoubleMapping();            while (it.hasNext()) {                Element element = it.next();                if (element.get() == 0.0) {                    updates.set(element.index(), value);                } else {                    element.set(value);                }            }            mergeUpdates(updates);        } else {            for (int i = 0; i < size; ++i) {                setQuick(i, value);            }        }    }    invalidateCachedLength();    return this;}
3507480612ff5c131d2eae1dc23f7afa7c53aa2a301f5ae71cc32bdb4eb18281
assign
public Vector assign(double[] values)
{    if (size != values.length) {        throw new CardinalityException(size, values.length);    }    if (isSequentialAccess() && !isAddConstantTime()) {        OrderedIntDoubleMapping updates = new OrderedIntDoubleMapping();        Iterator<Element> it = iterator();        while (it.hasNext()) {            Element element = it.next();            int index = element.index();            if (element.get() == 0.0) {                updates.set(index, values[index]);            } else {                element.set(values[index]);            }        }        mergeUpdates(updates);    } else {        for (int i = 0; i < size; ++i) {            setQuick(i, values[i]);        }    }    invalidateCachedLength();    return this;}
c5a902d495966254e0a65f297ed31bc7d8e3264bd5d2bc6764e8e8ffdf600259
assign
public Vector assign(Vector other)
{    return assign(other, Functions.SECOND);}
5c653bdf24bc25b462b7a04a2c3eab8d086adba75ffafcc915a58a684eb5fec7
assign
public Vector assign(DoubleDoubleFunction f, double y)
{    Iterator<Element> iterator = f.apply(0, y) == 0 ? iterateNonZero() : iterator();    while (iterator.hasNext()) {        Element element = iterator.next();        element.set(f.apply(element.get(), y));    }    invalidateCachedLength();    return this;}
099eb625bc50c228127200641e4c99eca589038a757fc472ce56df6cc350c852
assign
public Vector assign(DoubleFunction f)
{    Iterator<Element> iterator = !f.isDensifying() ? iterateNonZero() : iterator();    while (iterator.hasNext()) {        Element element = iterator.next();        element.set(f.apply(element.get()));    }    invalidateCachedLength();    return this;}
cbdfe22e340c62843c4f162b0e6debb832eecdaf145c52a3ee7f3829b568b4cd
assign
public Vector assign(Vector other, DoubleDoubleFunction function)
{    if (size != other.size()) {        throw new CardinalityException(size, other.size());    }    VectorBinaryAssign.assignBest(this, other, function);    invalidateCachedLength();    return this;}
6dfe2cdb77cbc5b5b9a2b7aedc3d099d3410b7401613398216709750456c90d3
cross
public Matrix cross(Vector other)
{    Matrix result = matrixLike(size, other.size());    Iterator<Vector.Element> it = iterateNonZero();    while (it.hasNext()) {        Vector.Element e = it.next();        int row = e.index();        result.assignRow(row, other.times(getQuick(row)));    }    return result;}
54a01f4d9d7b6734d8ffa5bdf5060ecf7332144c997cd1247fc1cf5d7a79b399
size
public final int size()
{    return size;}
ae284afe1ade5afe0242f68b99b1251c8ef4ebfb1ffd6eaa841c8d273ed0c131
asFormatString
public String asFormatString()
{    return toString();}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    int result = size;    Iterator<Element> iter = iterateNonZero();    while (iter.hasNext()) {        Element ele = iter.next();        result += ele.index() * RandomUtils.hashDouble(ele.get());    }    return result;}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (this == o) {        return true;    }    if (!(o instanceof Vector)) {        return false;    }    Vector that = (Vector) o;    return size == that.size() && aggregate(that, Functions.PLUS, Functions.MINUS_ABS) == 0.0;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return toString(null);}
42f34efac852f19afcc05456054c71eb49966760962db1a03be4fd532b0e9774
toString
public String toString(String[] dictionary)
{    StringBuilder result = new StringBuilder();    result.append('{');    for (int index = 0; index < size; index++) {        double value = getQuick(index);        if (value != 0.0) {            result.append(dictionary != null && dictionary.length > index ? dictionary[index] : index);            result.append(':');            result.append(value);            result.append(',');        }    }    if (result.length() > 1) {        result.setCharAt(result.length() - 1, '}');    } else {        result.append('}');    }    return result.toString();}
465c1a3db36a8e216a5adb1c992f386f722ab8657b50deb9a31c8ab529331893
sparseVectorToString
public String sparseVectorToString()
{    Iterator<Element> it = iterateNonZero();    if (!it.hasNext()) {        return "{}";    } else {        StringBuilder result = new StringBuilder();        result.append('{');        while (it.hasNext()) {            Vector.Element e = it.next();            result.append(e.index());            result.append(':');            result.append(e.get());            result.append(',');        }        result.setCharAt(result.length() - 1, '}');        return result.toString();    }}
6f9021560b40d5f0ea4687dcfc9163f88e04e559e2fc0af5f9a1fed73b4e4c24
get
public double get()
{    return getQuick(index);}
5dd366da2313537c415c3c2ab9ed1909d1250d894a032bd02373d113516571d0
index
public int index()
{    return index;}
0ca3b3a320922927ea9a06f3def94b995d23a5eb7b95de57c7935a827c79759c
set
public void set(double value)
{    setQuick(index, value);}
429f55fa6fd41f104b68cc0271b1b8c3afd9a961679b7648e8dfb55eb6774bf6
mult
public static Vector mult(Matrix m, Vector v)
{    if (m.numRows() != v.size()) {        throw new CardinalityException(m.numRows(), v.size());    }        Vector result = new DenseVector(m.numRows());    for (int i = 0; i < m.numRows(); i++) {        result.set(i, m.viewRow(i).dot(v));    }    return result;}
8c48a08bcf2cbbfb34229c9dfde0258474e0acc0a68cdc75e9740bd89439c7c1
hypot
public static double hypot(double a, double b)
{    double r;    if (Math.abs(a) > Math.abs(b)) {        r = b / a;        r = Math.abs(a) * Math.sqrt(1 + r * r);    } else if (b != 0) {        r = a / b;        r = Math.abs(b) * Math.sqrt(1 + r * r);    } else {        r = 0.0;    }    return r;}
599e1d81a378ab7e2cdf0db015c550e64737aca3f7a1c42a19b9327737d6f9ee
getNorm
public static double getNorm(Matrix m)
{    double max = 0.0;    for (int i = 0; i < m.numRows(); i++) {        int sum = 0;        Vector cv = m.viewRow(i);        for (int j = 0; j < cv.size(); j++) {            sum += (int) Math.abs(cv.getQuick(j));        }        if (sum > max) {            max = sum;        }    }    return max;}
da2a6a1a3a33a43ee2d56a506d14bf8b44d3778a2f866d8eda92c91ff6eb866c
solve
public static Vector solve(Iterable<Vector> featureVectors, Vector ratingVector, double lambda, int numFeatures)
{    Preconditions.checkNotNull(featureVectors, "Feature Vectors cannot be null");    Preconditions.checkArgument(!Iterables.isEmpty(featureVectors));    Preconditions.checkNotNull(ratingVector, "Rating Vector cannot be null");    Preconditions.checkArgument(ratingVector.getNumNondefaultElements() > 0, "Rating Vector cannot be empty");    Preconditions.checkArgument(Iterables.size(featureVectors) == ratingVector.getNumNondefaultElements());    int nui = ratingVector.getNumNondefaultElements();    Matrix MiIi = createMiIi(featureVectors, numFeatures);    Matrix RiIiMaybeTransposed = createRiIiMaybeTransposed(ratingVector);    /* compute Ai = MiIi * t(MiIi) + lambda * nui * E */    Matrix Ai = miTimesMiTransposePlusLambdaTimesNuiTimesE(MiIi, lambda, nui);    /* compute Vi = MiIi * t(R(i,Ii)) */    Matrix Vi = MiIi.times(RiIiMaybeTransposed);    /* compute Ai * ui = Vi */    return solve(Ai, Vi);}
596a2864f721ea4fa313cbfdbaae46ed0a3aba4827cbdb185357e888b27d4e23
solve
private static Vector solve(Matrix Ai, Matrix Vi)
{    return new QRDecomposition(Ai).solve(Vi).viewColumn(0);}
b03dfde4ffd89b3f4f8655a0922bd69ec98030b8a42edb535cc6cb3e71779b60
addLambdaTimesNuiTimesE
 static Matrix addLambdaTimesNuiTimesE(Matrix matrix, double lambda, int nui)
{    Preconditions.checkArgument(matrix.numCols() == matrix.numRows(), "Must be a Square Matrix");    double lambdaTimesNui = lambda * nui;    int numCols = matrix.numCols();    for (int n = 0; n < numCols; n++) {        matrix.setQuick(n, n, matrix.getQuick(n, n) + lambdaTimesNui);    }    return matrix;}
b26d9e8582fcfa0bf1e36ee988565be0f0c0201f86e3c37a9703a81ec59e1256
miTimesMiTransposePlusLambdaTimesNuiTimesE
private static Matrix miTimesMiTransposePlusLambdaTimesNuiTimesE(Matrix MiIi, double lambda, int nui)
{    double lambdaTimesNui = lambda * nui;    int rows = MiIi.numRows();    double[][] result = new double[rows][rows];    for (int i = 0; i < rows; i++) {        for (int j = i; j < rows; j++) {            double dot = MiIi.viewRow(i).dot(MiIi.viewRow(j));            if (i != j) {                result[i][j] = dot;                result[j][i] = dot;            } else {                result[i][i] = dot + lambdaTimesNui;            }        }    }    return new DenseMatrix(result, true);}
877ec878437486426c3641d63f34661f90091706db862b0f2819bfd7d61df3c4
createMiIi
 static Matrix createMiIi(Iterable<Vector> featureVectors, int numFeatures)
{    double[][] MiIi = new double[numFeatures][Iterables.size(featureVectors)];    int n = 0;    for (Vector featureVector : featureVectors) {        for (int m = 0; m < numFeatures; m++) {            MiIi[m][n] = featureVector.getQuick(m);        }        n++;    }    return new DenseMatrix(MiIi, true);}
06193d23855b4d06caf24a4995bb7c13b76bc4daef59db5676ad2c073bebfc42
createRiIiMaybeTransposed
 static Matrix createRiIiMaybeTransposed(Vector ratingVector)
{    Preconditions.checkArgument(ratingVector.isSequentialAccess(), "Ratings should be iterable in Index or Sequential Order");    double[][] RiIiMaybeTransposed = new double[ratingVector.getNumNondefaultElements()][1];    int index = 0;    for (Vector.Element elem : ratingVector.nonZeroes()) {        RiIiMaybeTransposed[index++][0] = elem.get();    }    return new DenseMatrix(RiIiMaybeTransposed, true);}
498dd3cec8a94508584eaa30f27ab53559c0ae9f44eea116d55b47c5e674b64e
solve
public Vector solve(Vector ratings)
{    return solve(YtransposeY.plus(getYtransponseCuMinusIYPlusLambdaI(ratings)), getYtransponseCuPu(ratings));}
40c327a54c54bff2e9c2192d47776695dced2cc4e2a921977521a108aa68253c
solve
private static Vector solve(Matrix A, Matrix y)
{    return new QRDecomposition(A).solve(y).viewColumn(0);}
407d6587ec98cd1c9e602196e03b02a7d0d0dc0d181106e0fe22ced8e386974a
confidence
 double confidence(double rating)
{    return 1 + alpha * rating;}
30973ab21d3e2f74525ac6cc3410383cc98ad8aef2885942fe948369b81a114a
getYtransposeY
public Matrix getYtransposeY(final OpenIntObjectHashMap<Vector> Y)
{    ExecutorService queue = Executors.newFixedThreadPool(numTrainingThreads);    if (log.isInfoEnabled()) {        log.info("Starting the computation of Y'Y");    }    long startTime = System.nanoTime();    final IntArrayList indexes = Y.keys();    final int numIndexes = indexes.size();    final double[][] YtY = new double[numFeatures][numFeatures];        for (int i = 0; i < numFeatures; i++) {        for (int j = i; j < numFeatures; j++) {            final int ii = i;            final int jj = j;            queue.execute(new Runnable() {                @Override                public void run() {                    double dot = 0;                    for (int k = 0; k < numIndexes; k++) {                        Vector row = Y.get(indexes.getQuick(k));                        dot += row.getQuick(ii) * row.getQuick(jj);                    }                    YtY[ii][jj] = dot;                    if (ii != jj) {                        YtY[jj][ii] = dot;                    }                }            });        }    }    queue.shutdown();    try {        queue.awaitTermination(1, TimeUnit.DAYS);    } catch (InterruptedException e) {        log.error("Error during Y'Y queue shutdown", e);        throw new RuntimeException("Error during Y'Y queue shutdown");    }    if (log.isInfoEnabled()) {        log.info("Computed Y'Y in " + (System.nanoTime() - startTime) / 1000000.0 + " ms");    }    return new DenseMatrix(YtY, true);}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    double dot = 0;    for (int k = 0; k < numIndexes; k++) {        Vector row = Y.get(indexes.getQuick(k));        dot += row.getQuick(ii) * row.getQuick(jj);    }    YtY[ii][jj] = dot;    if (ii != jj) {        YtY[jj][ii] = dot;    }}
b7916f243b5edd193049e76e473a9ffeb7fbf878799f8985adacb22c5900300c
getYtransponseCuMinusIYPlusLambdaI
private Matrix getYtransponseCuMinusIYPlusLambdaI(Vector userRatings)
{    Preconditions.checkArgument(userRatings.isSequentialAccess(), "need sequential access to ratings!");    /* (Cu -I) Y */    OpenIntObjectHashMap<Vector> CuMinusIY = new OpenIntObjectHashMap<>(userRatings.getNumNondefaultElements());    for (Element e : userRatings.nonZeroes()) {        CuMinusIY.put(e.index(), Y.get(e.index()).times(confidence(e.get()) - 1));    }    Matrix YtransponseCuMinusIY = new DenseMatrix(numFeatures, numFeatures);    /* Y' (Cu -I) Y by outer products */    for (Element e : userRatings.nonZeroes()) {        for (Vector.Element feature : Y.get(e.index()).all()) {            Vector partial = CuMinusIY.get(e.index()).times(feature.get());            YtransponseCuMinusIY.viewRow(feature.index()).assign(partial, Functions.PLUS);        }    }    /* Y' (Cu - I) Y +  I  add lambda on the diagonal */    for (int feature = 0; feature < numFeatures; feature++) {        YtransponseCuMinusIY.setQuick(feature, feature, YtransponseCuMinusIY.getQuick(feature, feature) + lambda);    }    return YtransponseCuMinusIY;}
901e54a93199937889a093922db64a3e39e4a1595dc5ce12801d4756d891b66a
getYtransponseCuPu
private Matrix getYtransponseCuPu(Vector userRatings)
{    Preconditions.checkArgument(userRatings.isSequentialAccess(), "need sequential access to ratings!");    Vector YtransponseCuPu = new DenseVector(numFeatures);    for (Element e : userRatings.nonZeroes()) {        YtransponseCuPu.assign(Y.get(e.index()).times(confidence(e.get())), Functions.PLUS);    }    return columnVectorAsMatrix(YtransponseCuPu);}
2c644c566ebbc0740a4f5ed5a252d0aabd070e25bb69b4693573b82210d6f3be
columnVectorAsMatrix
private Matrix columnVectorAsMatrix(Vector v)
{    double[][] matrix = new double[numFeatures][1];    for (Vector.Element e : v.all()) {        matrix[e.index()][0] = e.get();    }    return new DenseMatrix(matrix, true);}
77f165d740d83324621c6bf76240b06a9992b82e9733b8a056bb6076dbfae6f9
ensureCapacity
public static byte[] ensureCapacity(byte[] array, int minCapacity)
{    int oldCapacity = array.length;    byte[] newArray;    if (minCapacity > oldCapacity) {        int newCapacity = (oldCapacity * 3) / 2 + 1;        if (newCapacity < minCapacity) {            newCapacity = minCapacity;        }        newArray = new byte[newCapacity];        System.arraycopy(array, 0, newArray, 0, oldCapacity);    } else {        newArray = array;    }    return newArray;}
a30f25a84e87cfccd5084b3219bdfae8bfdce2e105d07913fc8af23373be1cdf
ensureCapacity
public static char[] ensureCapacity(char[] array, int minCapacity)
{    int oldCapacity = array.length;    char[] newArray;    if (minCapacity > oldCapacity) {        int newCapacity = (oldCapacity * 3) / 2 + 1;        if (newCapacity < minCapacity) {            newCapacity = minCapacity;        }        newArray = new char[newCapacity];        System.arraycopy(array, 0, newArray, 0, oldCapacity);    } else {        newArray = array;    }    return newArray;}
f4470c6583eedb814eddf75505d8790f69e60e232b01b9cfda1fbb58d7e00bed
ensureCapacity
public static double[] ensureCapacity(double[] array, int minCapacity)
{    int oldCapacity = array.length;    double[] newArray;    if (minCapacity > oldCapacity) {        int newCapacity = (oldCapacity * 3) / 2 + 1;        if (newCapacity < minCapacity) {            newCapacity = minCapacity;        }        newArray = new double[newCapacity];                System.arraycopy(array, 0, newArray, 0, oldCapacity);    } else {        newArray = array;    }    return newArray;}
bbd239530ee2dcb273e94b9dc3648ea1fb308b3f70689e05ef9f6d68ad249445
ensureCapacity
public static float[] ensureCapacity(float[] array, int minCapacity)
{    int oldCapacity = array.length;    float[] newArray;    if (minCapacity > oldCapacity) {        int newCapacity = (oldCapacity * 3) / 2 + 1;        if (newCapacity < minCapacity) {            newCapacity = minCapacity;        }        newArray = new float[newCapacity];        System.arraycopy(array, 0, newArray, 0, oldCapacity);    } else {        newArray = array;    }    return newArray;}
777d6c2b5c544c522de3829160d02091ea2f07845b72d84f21c1443a025ebf2c
ensureCapacity
public static int[] ensureCapacity(int[] array, int minCapacity)
{    int oldCapacity = array.length;    int[] newArray;    if (minCapacity > oldCapacity) {        int newCapacity = (oldCapacity * 3) / 2 + 1;        if (newCapacity < minCapacity) {            newCapacity = minCapacity;        }        newArray = new int[newCapacity];        System.arraycopy(array, 0, newArray, 0, oldCapacity);    } else {        newArray = array;    }    return newArray;}
477f9cc83da7319dab89c52047a4291cb68767c31c5d687db6aa82788815c4b2
ensureCapacity
public static long[] ensureCapacity(long[] array, int minCapacity)
{    int oldCapacity = array.length;    long[] newArray;    if (minCapacity > oldCapacity) {        int newCapacity = (oldCapacity * 3) / 2 + 1;        if (newCapacity < minCapacity) {            newCapacity = minCapacity;        }        newArray = new long[newCapacity];        System.arraycopy(array, 0, newArray, 0, oldCapacity);    } else {        newArray = array;    }    return newArray;}
af32570afa22fb5b4adaf5328498affcfeeb0c3a96ef244fc953337c901ec77c
ensureCapacity
public static Object[] ensureCapacity(Object[] array, int minCapacity)
{    int oldCapacity = array.length;    Object[] newArray;    if (minCapacity > oldCapacity) {        int newCapacity = (oldCapacity * 3) / 2 + 1;        if (newCapacity < minCapacity) {            newCapacity = minCapacity;        }        newArray = new Object[newCapacity];        System.arraycopy(array, 0, newArray, 0, oldCapacity);    } else {        newArray = array;    }    return newArray;}
bd2c0a424102f8e0fa74bd508a8d1647d2da7debdabfaeeb2ee69172ded2e141
ensureCapacity
public static short[] ensureCapacity(short[] array, int minCapacity)
{    int oldCapacity = array.length;    short[] newArray;    if (minCapacity > oldCapacity) {        int newCapacity = (oldCapacity * 3) / 2 + 1;        if (newCapacity < minCapacity) {            newCapacity = minCapacity;        }        newArray = new short[newCapacity];        System.arraycopy(array, 0, newArray, 0, oldCapacity);    } else {        newArray = array;    }    return newArray;}
07cbede0ebc00e656f7ac259b4bb120653c8c5fed2892cbc629ff7015e14431f
ensureCapacity
public static boolean[] ensureCapacity(boolean[] array, int minCapacity)
{    int oldCapacity = array.length;    boolean[] newArray;    if (minCapacity > oldCapacity) {        int newCapacity = (oldCapacity * 3) / 2 + 1;        if (newCapacity < minCapacity) {            newCapacity = minCapacity;        }        newArray = new boolean[newCapacity];        System.arraycopy(array, 0, newArray, 0, oldCapacity);    } else {        newArray = array;    }    return newArray;}
5c846f30c9efb382dc1bf525777f842e658858fe5f9c78bdf82898e5e9abb8e9
toString
public static String toString(byte[] array)
{    StringBuilder buf = new StringBuilder();    buf.append('[');    int maxIndex = array.length - 1;    for (int i = 0; i <= maxIndex; i++) {        buf.append(array[i]);        if (i < maxIndex) {            buf.append(", ");        }    }    buf.append(']');    return buf.toString();}
d34bce30dbfc12b6abde8154316f786447064f7b1bd2e17fe4b691521742ce53
toString
public static String toString(char[] array)
{    StringBuilder buf = new StringBuilder();    buf.append('[');    int maxIndex = array.length - 1;    for (int i = 0; i <= maxIndex; i++) {        buf.append(array[i]);        if (i < maxIndex) {            buf.append(", ");        }    }    buf.append(']');    return buf.toString();}
74ac0c76e787d4fb641b0c8b47a7102ae68014f4e59c20aac9a8fb3c74f5c29d
toString
public static String toString(double[] array)
{    StringBuilder buf = new StringBuilder();    buf.append('[');    int maxIndex = array.length - 1;    for (int i = 0; i <= maxIndex; i++) {        buf.append(array[i]);        if (i < maxIndex) {            buf.append(", ");        }    }    buf.append(']');    return buf.toString();}
fd70b143764712014f8cbb4837a000b6b2052ed8da385e6e3054799ec3bfeace
toString
public static String toString(float[] array)
{    StringBuilder buf = new StringBuilder();    buf.append('[');    int maxIndex = array.length - 1;    for (int i = 0; i <= maxIndex; i++) {        buf.append(array[i]);        if (i < maxIndex) {            buf.append(", ");        }    }    buf.append(']');    return buf.toString();}
f31bfeec770c33c62d78ee45a937895fa11581c4deb44e1287d34c5523bd5754
toString
public static String toString(int[] array)
{    StringBuilder buf = new StringBuilder();    buf.append('[');    int maxIndex = array.length - 1;    for (int i = 0; i <= maxIndex; i++) {        buf.append(array[i]);        if (i < maxIndex) {            buf.append(", ");        }    }    buf.append(']');    return buf.toString();}
2f0c9695d20cf048dacf5348698108cb6bec6a2a0897bda4da7bb3dac0d3e407
toString
public static String toString(long[] array)
{    StringBuilder buf = new StringBuilder();    buf.append('[');    int maxIndex = array.length - 1;    for (int i = 0; i <= maxIndex; i++) {        buf.append(array[i]);        if (i < maxIndex) {            buf.append(", ");        }    }    buf.append(']');    return buf.toString();}
ab71be8bf534eb93730d4c8c88ec2d172153b0631e1fb66b55c4aef541693839
toString
public static String toString(Object[] array)
{    StringBuilder buf = new StringBuilder();    buf.append('[');    int maxIndex = array.length - 1;    for (int i = 0; i <= maxIndex; i++) {        buf.append(array[i]);        if (i < maxIndex) {            buf.append(", ");        }    }    buf.append(']');    return buf.toString();}
43ce46cb3474c4019ac4f4e1ecb914fd41633d6f872eda2e5b7eae73c071cd11
toString
public static String toString(short[] array)
{    StringBuilder buf = new StringBuilder();    buf.append('[');    int maxIndex = array.length - 1;    for (int i = 0; i <= maxIndex; i++) {        buf.append(array[i]);        if (i < maxIndex) {            buf.append(", ");        }    }    buf.append(']');    return buf.toString();}
dffd2a07bc52d715440d94e79416126c65743d193fd4026b920ca8be6ad8372e
toString
public static String toString(boolean[] array)
{    StringBuilder buf = new StringBuilder();    buf.append('[');    int maxIndex = array.length - 1;    for (int i = 0; i <= maxIndex; i++) {        buf.append(array[i]);        if (i < maxIndex) {            buf.append(", ");        }    }    buf.append(']');    return buf.toString();}
94c6683d1eea22559b484320cfe8a385cf5dcfcf251002b5a07164074decafb0
trimToCapacity
public static byte[] trimToCapacity(byte[] array, int maxCapacity)
{    if (array.length > maxCapacity) {        byte[] oldArray = array;        array = new byte[maxCapacity];        System.arraycopy(oldArray, 0, array, 0, maxCapacity);    }    return array;}
fe6a14d562a1253a4182627c35ebaf8cd39ad0f7d8b2db06a95fdd28de961100
trimToCapacity
public static char[] trimToCapacity(char[] array, int maxCapacity)
{    if (array.length > maxCapacity) {        char[] oldArray = array;        array = new char[maxCapacity];        System.arraycopy(oldArray, 0, array, 0, maxCapacity);    }    return array;}
d546f25564b1408d2fe17a62dd5e3a47b1d63d00d10dcb92e1aafc27fa66d7c2
trimToCapacity
public static double[] trimToCapacity(double[] array, int maxCapacity)
{    if (array.length > maxCapacity) {        double[] oldArray = array;        array = new double[maxCapacity];        System.arraycopy(oldArray, 0, array, 0, maxCapacity);    }    return array;}
61e3608aedba860f2c22f2ed3b4585597267a3735a5404b93c79082db0c30b5c
trimToCapacity
public static float[] trimToCapacity(float[] array, int maxCapacity)
{    if (array.length > maxCapacity) {        float[] oldArray = array;        array = new float[maxCapacity];        System.arraycopy(oldArray, 0, array, 0, maxCapacity);    }    return array;}
8aa35538f1afd8a428c15da56b3f21aec4589ee71458ab99fe084163ec0eb66f
trimToCapacity
public static int[] trimToCapacity(int[] array, int maxCapacity)
{    if (array.length > maxCapacity) {        int[] oldArray = array;        array = new int[maxCapacity];        System.arraycopy(oldArray, 0, array, 0, maxCapacity);    }    return array;}
94a709554f3f09a4516fb20a881388550e86aa98a050f94bb85460ad4b29a1e4
trimToCapacity
public static long[] trimToCapacity(long[] array, int maxCapacity)
{    if (array.length > maxCapacity) {        long[] oldArray = array;        array = new long[maxCapacity];        System.arraycopy(oldArray, 0, array, 0, maxCapacity);    }    return array;}
4d0b2a35a3cf2e20e74ddb14e0d2c04c711495cb03b9ae258cad928a4b04c832
trimToCapacity
public static Object[] trimToCapacity(Object[] array, int maxCapacity)
{    if (array.length > maxCapacity) {        Object[] oldArray = array;        array = new Object[maxCapacity];        System.arraycopy(oldArray, 0, array, 0, maxCapacity);    }    return array;}
7e185b2f133246fad855015faa36b9c49c4cc349073e0318e37d43f3a06332f2
trimToCapacity
public static short[] trimToCapacity(short[] array, int maxCapacity)
{    if (array.length > maxCapacity) {        short[] oldArray = array;        array = new short[maxCapacity];        System.arraycopy(oldArray, 0, array, 0, maxCapacity);    }    return array;}
5a2cc8703016ed4bdb3bebb600de3b26ae6783c7d33dc43cce032dd009ab6b47
trimToCapacity
public static boolean[] trimToCapacity(boolean[] array, int maxCapacity)
{    if (array.length > maxCapacity) {        boolean[] oldArray = array;        array = new boolean[maxCapacity];        System.arraycopy(oldArray, 0, array, 0, maxCapacity);    }    return array;}
4a4b5c02eb13ef7233a06c8e8dd8a570b1b2b55b81815aa7a75a4b0f16c2812f
copyOf
public static byte[] copyOf(byte[] src, int length)
{    byte[] result = new byte[length];    System.arraycopy(src, 0, result, 0, Math.min(length, src.length));    return result;}
ca63e7abe81ebffc0ac740a909cfb72030dbd81f593bc68344ca0e5ce9cb245f
copyOf
public static char[] copyOf(char[] src, int length)
{    char[] result = new char[length];    System.arraycopy(src, 0, result, 0, Math.min(length, src.length));    return result;}
0757f9c751311d06eff30f7c4285e23f6f9a9b93d931cf141e1983a9fa088fac
copyOf
public static short[] copyOf(short[] src, int length)
{    short[] result = new short[length];    System.arraycopy(src, 0, result, 0, Math.min(length, src.length));    return result;}
9ebe3336d72ca71253501e182a12c0f3a7cfe13a464e5b292838e02c16618811
copyOf
public static int[] copyOf(int[] src, int length)
{    int[] result = new int[length];    System.arraycopy(src, 0, result, 0, Math.min(length, src.length));    return result;}
2d5cafd48c7a8dbdb72eef5fde4e6f7e2f37e46ed0fd156753a5b9b1d8335245
copyOf
public static float[] copyOf(float[] src, int length)
{    float[] result = new float[length];    System.arraycopy(src, 0, result, 0, Math.min(length, src.length));    return result;}
46fc22abbb11685e3760ca290dd7d62e71567c7fdde6577cdf0035ebe8f29bed
copyOf
public static double[] copyOf(double[] src, int length)
{    double[] result = new double[length];    System.arraycopy(src, 0, result, 0, Math.min(length, src.length));    return result;}
1e9e36185ea5981eaeeeed81b83cedeb34ae9fc90d4abf37bc7b34609492c6d0
copyOf
public static long[] copyOf(long[] src, int length)
{    long[] result = new long[length];    System.arraycopy(src, 0, result, 0, Math.min(length, src.length));    return result;}
cdc46c030df372ba0a9af07d7c3ebe7564cc6891f6731a0d30055cd102e7aadf
binarySearchFromTo
public static int binarySearchFromTo(byte[] array, byte value, int from, int to)
{    int mid = -1;    while (from <= to) {        mid = (from + to) >>> 1;        if (value > array[mid]) {            from = mid + 1;        } else if (value == array[mid]) {            return mid;        } else {            to = mid - 1;        }    }    if (mid < 0) {        return -1;    }    return -mid - (value < array[mid] ? 1 : 2);}
e2d9c9c6b540e67982c0687e3f6b6e455ea658710c0a6f018cc9f4aa81ecb782
binarySearchFromTo
public static int binarySearchFromTo(char[] array, char value, int from, int to)
{    int mid = -1;    while (from <= to) {        mid = (from + to) >>> 1;        if (value > array[mid]) {            from = mid + 1;        } else if (value == array[mid]) {            return mid;        } else {            to = mid - 1;        }    }    if (mid < 0) {        return -1;    }    return -mid - (value < array[mid] ? 1 : 2);}
0e009b60ace10193a7de8e45ea77d9320198aba3fbe0bf0956013e16d86ee05e
binarySearchFromTo
public static int binarySearchFromTo(double[] array, double value, int from, int to)
{    long longBits = Double.doubleToLongBits(value);    int mid = -1;    while (from <= to) {        mid = (from + to) >>> 1;        if (lessThan(array[mid], value)) {            from = mid + 1;        } else if (longBits == Double.doubleToLongBits(array[mid])) {            return mid;        } else {            to = mid - 1;        }    }    if (mid < 0) {        return -1;    }    return -mid - (lessThan(value, array[mid]) ? 1 : 2);}
42cba9a23fc64a2e38b1f0d1454e1c80dc769e17dfbd375b3cb5eea64ce63ac2
binarySearchFromTo
public static int binarySearchFromTo(float[] array, float value, int from, int to)
{    int intBits = Float.floatToIntBits(value);    int mid = -1;    while (from <= to) {        mid = (from + to) >>> 1;        if (lessThan(array[mid], value)) {            from = mid + 1;        } else if (intBits == Float.floatToIntBits(array[mid])) {            return mid;        } else {            to = mid - 1;        }    }    if (mid < 0) {        return -1;    }    return -mid - (lessThan(value, array[mid]) ? 1 : 2);}
8086d975e68d148735a79f54f2cc14d38a6141e2b5cd4dfcef90531593483b83
binarySearchFromTo
public static int binarySearchFromTo(int[] array, int value, int from, int to)
{    int mid = -1;    while (from <= to) {        mid = (from + to) >>> 1;        if (value > array[mid]) {            from = mid + 1;        } else if (value == array[mid]) {            return mid;        } else {            to = mid - 1;        }    }    if (mid < 0) {        return -1;    }    return -mid - (value < array[mid] ? 1 : 2);}
d63f9f209527b13db7bbf51d375b4cd6c0cadce9e32b570e5515782b7e21aa3a
binarySearchFromTo
public static int binarySearchFromTo(long[] array, long value, int from, int to)
{    int mid = -1;    while (from <= to) {        mid = (from + to) >>> 1;        if (value > array[mid]) {            from = mid + 1;        } else if (value == array[mid]) {            return mid;        } else {            to = mid - 1;        }    }    if (mid < 0) {        return -1;    }    return -mid - (value < array[mid] ? 1 : 2);}
755f6b8b379ff74cecb173b9dec85b9c9f0b018736481d24865de054db6d99c2
binarySearchFromTo
public static int binarySearchFromTo(T[] array, T object, int from, int to)
{    if (array.length == 0) {        return -1;    }    int mid = 0;    int result = 0;    while (from <= to) {        mid = (from + to) >>> 1;        if ((result = array[mid].compareTo(object)) < 0) {            from = mid + 1;        } else if (result == 0) {            return mid;        } else {            to = mid - 1;        }    }    return -mid - (result >= 0 ? 1 : 2);}
d30c1abbb7eadd8c1e96056328b4894d013380ba5978c945115b0451d3c467b0
binarySearchFromTo
public static int binarySearchFromTo(T[] array, T object, int from, int to, Comparator<? super T> comparator)
{    int mid = 0;    int result = 0;    while (from <= to) {        mid = (from + to) >>> 1;        if ((result = comparator.compare(array[mid], object)) < 0) {            from = mid + 1;        } else if (result == 0) {            return mid;        } else {            to = mid - 1;        }    }    return -mid - (result >= 0 ? 1 : 2);}
e0afe89007431a738aba696555010981e15fff86153a80fcc61cf409017a4f25
binarySearchFromTo
public static int binarySearchFromTo(short[] array, short value, int from, int to)
{    int mid = -1;    while (from <= to) {        mid = (from + to) >>> 1;        if (value > array[mid]) {            from = mid + 1;        } else if (value == array[mid]) {            return mid;        } else {            to = mid - 1;        }    }    if (mid < 0) {        return -1;    }    return -mid - (value < array[mid] ? 1 : 2);}
7779c832e7ecdaeaaab2d099d726f9e61e260f15c0deafe9b18fb91193d15dbf
lessThan
private static boolean lessThan(double double1, double double2)
{        if (double1 < double2) {        return true;    }    if (double1 > double2) {        return false;    }    if (double1 == double2 && double1 != 0.0) {        return false;    }        if (Double.isNaN(double1)) {        return false;    }    if (Double.isNaN(double2)) {        return true;    }        long d1 = Double.doubleToRawLongBits(double1);    long d2 = Double.doubleToRawLongBits(double2);    return d1 < d2;}
0ccb504bcededdd1f85c6a132f76c6a41ab773d574b594164513debc3e66bc90
lessThan
private static boolean lessThan(float float1, float float2)
{        if (float1 < float2) {        return true;    }    if (float1 > float2) {        return false;    }    if (float1 == float2 && float1 != 0.0f) {        return false;    }        if (Float.isNaN(float1)) {        return false;    }    if (Float.isNaN(float2)) {        return true;    }        int f1 = Float.floatToRawIntBits(float1);    int f2 = Float.floatToRawIntBits(float2);    return f1 < f2;}
8668c6b652608a90cb48e8b184181bd5fdcc2097f6e76e690b4ebf1e7ae33e7e
create
public static Centroid create(int key, Vector initialValue)
{    if (initialValue instanceof WeightedVector) {        return new Centroid(key, new DenseVector(initialValue), ((WeightedVector) initialValue).getWeight());    } else {        return new Centroid(key, new DenseVector(initialValue), 1);    }}
93fb323bc1577a0600359ea0b659a440375a397fb0e25fa1d36bbb85f5e6a7bb
update
public void update(Vector v)
{    if (v instanceof Centroid) {        Centroid c = (Centroid) v;        update(c.delegate, c.getWeight());    } else {        update(v, 1);    }}
4d0b725a736d244ecf0f18da4c5d4f79c60b3188bea5f01fa73bc7e02c907540
update
public void update(Vector other, final double wy)
{    final double wx = getWeight();    delegate.assign(other, Functions.reweigh(wx, wy));    setWeight(wx + wy);}
a55def95be072d7811746ecb90c4e034303ff943e79f04405c64e3da6555a415
like
public Centroid like()
{    return new Centroid(getIndex(), getVector().like(), getWeight());}
501c6794ceaffd49ff6c4290052f18502462ad908608400cf6ab91c01d005be4
getKey
public int getKey()
{    return getIndex();}
375793bbb0603ca582331e9140603fd743c47999a96857ec3adffc5ea79104df
addWeight
public void addWeight(double newWeight)
{    setWeight(getWeight() + newWeight);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return String.format("key = %d, weight = %.2f, vector = %s", getIndex(), getWeight(), delegate);}
b7d8d902d5fb537e54d1619c1d9b5c624e3caafbf2c02080861ed8e34f69dff7
clone
public Centroid clone()
{    return new Centroid(this);}
7c723acaf6af99316f907775cf52644f55310059d58d7de614a7aed674924fc8
decomposeWithPivoting
private void decomposeWithPivoting(Matrix a)
{    int n = a.rowSize();    L.assign(a);        double uberMax = L.viewDiagonal().aggregate(Functions.MAX, Functions.ABS);    for (int k = 0; k < n; k++) {        double max = 0;        int pivot = k;        for (int j = k; j < n; j++) {            if (L.get(j, j) > max) {                max = L.get(j, j);                pivot = j;                if (uberMax < Math.abs(max)) {                    uberMax = Math.abs(max);                }            }        }        L.swap(k, pivot);        double akk = L.get(k, k);        double epsilon = 1.0e-10 * Math.max(uberMax, L.viewColumn(k).aggregate(Functions.MAX, Functions.ABS));        if (akk < -epsilon) {                        throw new IllegalArgumentException("Matrix is not positive semi-definite");        } else if (akk <= epsilon) {                        L.viewColumn(k).assign(0);            isPositiveDefinite = false;                } else {                        akk = Math.sqrt(Math.max(0, akk));            L.viewColumn(k).viewPart(k, n - k).assign(Functions.div(akk));            L.viewColumn(k).viewPart(0, k).assign(0);                        for (int j = k + 1; j < n; j++) {                Vector columnJ = L.viewColumn(j).viewPart(k, n - k);                Vector columnK = L.viewColumn(k).viewPart(k, n - k);                columnJ.assign(columnK, Functions.minusMult(columnK.get(j - k)));            }        }    }}
524e3b29d79f2d6708b3e1898057ad2050e8d51d75527e2185b3dbb4d3622f0e
decompose
private void decompose(Matrix a)
{    int n = a.rowSize();    L.assign(a);        for (int k = 0; k < n; k++) {        double akk = L.get(k, k);                L.viewColumn(k).viewPart(0, k).assign(0);        double epsilon = 1.0e-10 * L.viewColumn(k).aggregate(Functions.MAX, Functions.ABS);        if (akk <= epsilon) {                        L.viewColumn(k).viewPart(k, n - k).assign(0);            isPositiveDefinite = false;                } else {                        akk = Math.sqrt(Math.max(0, akk));            L.set(k, k, akk);            L.viewColumn(k).viewPart(k + 1, n - k - 1).assign(Functions.div(akk));                        for (int j = k + 1; j < n; j++) {                Vector columnJ = L.viewColumn(j).viewPart(j, n - j);                Vector columnK = L.viewColumn(k).viewPart(j, n - j);                columnJ.assign(columnK, Functions.minusMult(L.get(j, k)));            }        }    }}
864d3bc6b41305963656741823267abc644a3fb86b28e08f0db2853a683c28cf
isPositiveDefinite
public boolean isPositiveDefinite()
{    return isPositiveDefinite;}
126b7508084af636743f32b915d06b0686d756fc5766b1dcdb7677a55dc25738
getL
public Matrix getL()
{    return L.getBase();}
18c450ed68415b828ecf582e8a8390817e9ebfb2ba89e27a4baae78964f40694
getPermutedL
public PivotedMatrix getPermutedL()
{    return L;}
8de242b20bfb2febc317402d0f809217b7cad255b351a744e110e305fe30b4b2
getPivot
public int[] getPivot()
{    return L.getRowPivot();}
53411914e8c1b7c1dafc1d311db68174612f91d91181c44568f682fa8c81afa5
getInversePivot
public int[] getInversePivot()
{    return L.getInverseRowPivot();}
a934f50e3adb23f3f36e9ae6926a751bad1c82ce1d63104a03861288f8aede90
solveLeft
public Matrix solveLeft(Matrix z)
{    int n = L.columnSize();    int nx = z.columnSize();    Matrix X = new DenseMatrix(n, z.columnSize());    X.assign(z);        for (int internalK = 0; internalK < n; internalK++) {        int k = L.rowUnpivot(internalK);        for (int j = 0; j < nx; j++) {            for (int internalI = 0; internalI < internalK; internalI++) {                int i = L.rowUnpivot(internalI);                X.set(k, j, X.get(k, j) - X.get(i, j) * L.get(k, i));            }            if (L.get(k, k) != 0) {                X.set(k, j, X.get(k, j) / L.get(k, k));            } else {                X.set(k, j, 0);            }        }    }    return X;}
140eeef60cc8beb90b448ff8659b593038da0d6ea010e01cfa18958993ad8214
solveRight
public Matrix solveRight(Matrix z)
{    int n = z.columnSize();    int nx = z.rowSize();    Matrix x = new DenseMatrix(z.rowSize(), z.columnSize());    x.assign(z);        for (int internalK = 0; internalK < n; internalK++) {        int k = L.rowUnpivot(internalK);        for (int j = 0; j < nx; j++) {            for (int internalI = 0; internalI < k; internalI++) {                int i = L.rowUnpivot(internalI);                x.set(j, k, x.get(j, k) - x.get(j, i) * L.get(k, i));                if (Double.isInfinite(x.get(j, k)) || Double.isNaN(x.get(j, k))) {                    throw new IllegalStateException(String.format("Invalid value found at %d,%d (should not be possible)", j, k));                }            }            if (L.get(k, k) != 0) {                x.set(j, k, x.get(j, k) / L.get(k, k));            } else {                x.set(j, k, 0);            }            if (Double.isInfinite(x.get(j, k)) || Double.isNaN(x.get(j, k))) {                throw new IllegalStateException(String.format("Invalid value found at %d,%d (should not be possible)", j, k));            }        }    }    return x;}
39aa63eded95450eed8ae8438d97998d3316f664b548900552f7ffb6b0441d94
matrixLike
protected Matrix matrixLike(int rows, int columns)
{    return new DenseMatrix(rows, columns);}
0f2cea51f07acae4d2eb073f5151beaf6dba8920eaf21ed6212f67553909727d
mergeUpdates
public void mergeUpdates(OrderedIntDoubleMapping updates)
{    throw new UnsupportedOperationException("Cannot mutate a ConstantVector");}
383032e836ae8e377e669da8e774cd6f6410cb106bd66015b484c883dc1c467c
isDense
public boolean isDense()
{    return true;}
048fcadf359a37696af85547983c8e1a90a6c62d53a2f5c66ba6b94ae1c5b98c
isSequentialAccess
public boolean isSequentialAccess()
{    return true;}
ebaf88b6206d3b34b79e1287ba43a83a7321437a7f6da5136b43af17bd0a0476
iterator
public Iterator<Element> iterator()
{    return new AbstractIterator<Element>() {        private int i = 0;        private final int n = size();        @Override        protected Element computeNext() {            if (i < n) {                return new LocalElement(i++);            } else {                return endOfData();            }        }    };}
805efeafbd5a8971b9858a258536df263d73a6d5b733043fdf392af2c4e52cbc
computeNext
protected Element computeNext()
{    if (i < n) {        return new LocalElement(i++);    } else {        return endOfData();    }}
0494c3c5bbf01f97ae3671ecd67c5586bc95bd0aa1907bd0e3ebdc94d70e1683
iterateNonZero
public Iterator<Element> iterateNonZero()
{    return iterator();}
2263144cad9c9fdd2eecb03c9f0c31fc79e73b974408c87f743169e8bea1c8f3
getQuick
public double getQuick(int index)
{    return value;}
3f06e4bc1bde206fe6ac26b2e2c12970bc557eee7de0d8e8394b1f96568db34b
like
public Vector like()
{    return new DenseVector(size());}
de7fe3d006f2cc6fa563e7089bbae0e5300ec5b2f82e856c1118dd26a5798a5f
like
public Vector like(int cardinality)
{    return new DenseVector(cardinality);}
d90a04e96781b1eebeec5aca2a7d384a466650ea31ec4abd55dff982b7d2e12d
setQuick
public void setQuick(int index, double value)
{    throw new UnsupportedOperationException("Can't set a value in a constant matrix");}
f6c83ebe319a78b7975eba92f536cfcf2e5e6786960fb07f54a0c99258711da5
getNumNondefaultElements
public int getNumNondefaultElements()
{    return size();}
6b67fad6dd27aa2525cafe6cf3396d2225fbcdf57e5378ac7a3dee60e61f20e8
getLookupCost
public double getLookupCost()
{    return 1;}
c79b5203142f65c96c29c2652557bad0bda511dfe38011e3b2877dd681f7c9cf
getIteratorAdvanceCost
public double getIteratorAdvanceCost()
{    return 1;}
c5fbf138e094d3027905103c89bbab4aa48cd369c50dde054752fd31aa322767
isAddConstantTime
public boolean isAddConstantTime()
{    throw new UnsupportedOperationException("Cannot mutate a ConstantVector");}
8a74e74838715a5ca525c7f36638cc1556efbab476ac10bef27168638a19436a
verify
public synchronized EigenStatus verify(VectorIterable corpus, Vector vector)
{    if (!finished && !started) {                status = new EigenStatus(-1, 0);        Vector vectorCopy = vector.clone();        threadPool.execute(new VerifierRunnable(corpus, vectorCopy));        started = true;    }    if (finished) {        finished = false;    }    return status;}
5df6118bc0e745d8b18e0a6a99b2e3f2ddba8140cbeb1423ce2df50a9f140574
close
public void close()
{    this.threadPool.shutdownNow();}
258f4f7da1eba58a9456a3e15cc58a69627076f1b3945143eb987c060116d93a
innerVerify
protected EigenStatus innerVerify(VectorIterable corpus, Vector vector)
{    return super.verify(corpus, vector);}
4560d80c2474cc2770be19fbc06c60741920c59992e6b13524f8a5b688ec285a
run
public void run()
{    EigenStatus status = innerVerify(corpus, vector);    synchronized (AsyncEigenVerifier.this) {        AsyncEigenVerifier.this.status = status;        finished = true;        started = false;    }}
28c9a2a9ce99ee7fdbe47a37d6eb72fc14e5511a49d2e6e5db51fccd1b0afa4d
getCosAngle
public double getCosAngle()
{    return cosAngle;}
4058e4532084f24dabc50038c1941965a39203c3d72df2d0e8ccf6d081089682
getEigenValue
public double getEigenValue()
{    return eigenValue;}
73bce2d804cbc17048bbbad5122def51173f11e83071d76426e4ece4bfb0ce76
inProgress
public boolean inProgress()
{    return inProgress;}
887e6644b62c52bb596d9515a5ba601472c2d82033568234acb4f938620bc404
setInProgress
 void setInProgress(boolean status)
{    inProgress = status;}
cc6a0c8135755644afa333b21e6f89ebb7d0f13c05937a07c5388320130ce157
solve
public TrainingState solve(Matrix corpus, int desiredRank)
{    int cols = corpus.numCols();    Matrix eigens = new DenseMatrix(desiredRank, cols);    List<Double> eigenValues = new ArrayList<>();    log.info("Finding {} singular vectors of matrix with {} rows, via Hebbian", desiredRank, corpus.numRows());    /*     * The corpusProjections matrix is a running cache of the residual projection of each corpus vector against all     * of the previously found singular vectors.  Without this, if multiple passes over the data is made (per     * singular vector), recalculating these projections eventually dominates the computational complexity of the     * solver.     */    Matrix corpusProjections = new DenseMatrix(corpus.numRows(), desiredRank);    TrainingState state = new TrainingState(eigens, corpusProjections);    for (int i = 0; i < desiredRank; i++) {        Vector currentEigen = new DenseVector(cols);        Vector previousEigen = null;        while (hasNotConverged(currentEigen, corpus, state)) {            int randomStartingIndex = getRandomStartingIndex(corpus, eigens);            Vector initialTrainingVector = corpus.viewRow(randomStartingIndex);            state.setTrainingIndex(randomStartingIndex);            updater.update(currentEigen, initialTrainingVector, state);            for (int corpusRow = 0; corpusRow < corpus.numRows(); corpusRow++) {                state.setTrainingIndex(corpusRow);                if (corpusRow != randomStartingIndex) {                    updater.update(currentEigen, corpus.viewRow(corpusRow), state);                }            }            state.setFirstPass(false);            if (DEBUG) {                if (previousEigen == null) {                    previousEigen = currentEigen.clone();                } else {                    double dot = currentEigen.dot(previousEigen);                    if (dot > 0.0) {                        dot /= currentEigen.norm(2) * previousEigen.norm(2);                    }                                }            }        }                double eigenValue = state.getStatusProgress().get(state.getStatusProgress().size() - 1).getEigenValue();                        currentEigen.assign(new TimesFunction(), 1 / currentEigen.norm(2));        eigens.assignRow(i, currentEigen);        eigenValues.add(eigenValue);        state.setCurrentEigenValues(eigenValues);        log.info("Found eigenvector {}, eigenvalue: {}", i, eigenValue);        /**         *  TODO: Persist intermediate output!         */        state.setFirstPass(true);        state.setNumEigensProcessed(state.getNumEigensProcessed() + 1);        state.setActivationDenominatorSquared(0);        state.setActivationNumerator(0);        state.getStatusProgress().clear();        numPasses = 0;    }    return state;}
091dd24a122e7d92db865f4f0abe3dd79e1c362ea7848b3f399f914e50f6d2ef
getRandomStartingIndex
private int getRandomStartingIndex(Matrix corpus, Matrix eigens)
{    int index;    Vector v;    do {        double r = rng.nextDouble();        index = (int) (r * corpus.numRows());        v = corpus.viewRow(index);    } while (v == null || v.norm(2) == 0 || v.getNumNondefaultElements() < 5);    return index;}
c1ae7fa04fc65a725bb404ef58ca6c6801786fbe90216f78c52e3cdd33708573
hasNotConverged
protected boolean hasNotConverged(Vector currentPseudoEigen, Matrix corpus, TrainingState state)
{    numPasses++;    if (state.isFirstPass()) {        log.info("First pass through the corpus, no need to check convergence...");        return true;    }    Matrix previousEigens = state.getCurrentEigens();    log.info("Have made {} passes through the corpus, checking convergence...", numPasses);    /*     * Step 1: orthogonalize currentPseudoEigen by subtracting off eigen(i) * helper.get(i)     * Step 2: zero-out the helper vector because it has already helped.     */    for (int i = 0; i < state.getNumEigensProcessed(); i++) {        Vector previousEigen = previousEigens.viewRow(i);        currentPseudoEigen.assign(previousEigen, new PlusMult(-state.getHelperVector().get(i)));        state.getHelperVector().set(i, 0);    }    if (currentPseudoEigen.norm(2) > 0) {        for (int i = 0; i < state.getNumEigensProcessed(); i++) {            Vector previousEigen = previousEigens.viewRow(i);            log.info("dot with previous: {}", previousEigen.dot(currentPseudoEigen) / currentPseudoEigen.norm(2));        }    }    /*     * Step 3: verify how eigen-like the prospective eigen is.  This is potentially asynchronous.     */    EigenStatus status = verify(corpus, currentPseudoEigen);    if (status.inProgress()) {        log.info("Verifier not finished, making another pass...");    } else {        log.info("Has 1 - cosAngle: {}, convergence target is: {}", 1.0 - status.getCosAngle(), convergenceTarget);        state.getStatusProgress().add(status);    }    return state.getStatusProgress().size() <= maxPassesPerEigen && 1.0 - status.getCosAngle() > convergenceTarget;}
a6fa688d0ae73cada96f255df643c3d6fce7a5db22166502a31f24c86216de12
verify
protected EigenStatus verify(Matrix corpus, Vector currentPseudoEigen)
{    return verifier.verify(corpus, currentPseudoEigen);}
3116ea2053d9de960ec3753eb07f3d243c370662aa1f0175ad357057c9ce5a52
main
public static void main(String[] args)
{    Properties props = new Properties();    String propertiesFile = args.length > 0 ? args[0] : "config/solver.properties";        String corpusDir = props.getProperty("solver.input.dir");    String outputDir = props.getProperty("solver.output.dir");    if (corpusDir == null || corpusDir.isEmpty() || outputDir == null || outputDir.isEmpty()) {        log.error("{} must contain values for solver.input.dir and solver.output.dir", propertiesFile);        return;    }        int rank = Integer.parseInt(props.getProperty("solver.output.desiredRank"));    double convergence = Double.parseDouble(props.getProperty("solver.convergence"));    int maxPasses = Integer.parseInt(props.getProperty("solver.maxPasses"));        HebbianUpdater updater = new HebbianUpdater();    SingularVectorVerifier verifier = new AsyncEigenVerifier();    HebbianSolver solver = new HebbianSolver(updater, verifier, convergence, maxPasses);    Matrix corpus = null;    /*    if (numThreads <= 1) {          } else {          }     */    long now = System.currentTimeMillis();    TrainingState finalState = solver.solve(corpus, rank);    long time = (System.currentTimeMillis() - now) / 1000;    log.info("Solved {} eigenVectors in {} seconds.  Persisted to {}", finalState.getCurrentEigens().rowSize(), time, outputDir);}
c2b74c5953c7ed4bf313290e3962599cc18bf8e8b6e0c37bd70bc086f0c8592f
update
public void update(Vector pseudoEigen, Vector trainingVector, TrainingState currentState)
{    double trainingVectorNorm = trainingVector.norm(2);    int numPreviousEigens = currentState.getNumEigensProcessed();    if (numPreviousEigens > 0 && currentState.isFirstPass()) {        updateTrainingProjectionsVector(currentState, trainingVector, numPreviousEigens - 1);    }    if (currentState.getActivationDenominatorSquared() == 0 || trainingVectorNorm == 0) {        if (currentState.getActivationDenominatorSquared() == 0) {            pseudoEigen.assign(trainingVector, new PlusMult(1));            currentState.setHelperVector(currentState.currentTrainingProjection().clone());            double helperNorm = currentState.getHelperVector().norm(2);            currentState.setActivationDenominatorSquared(trainingVectorNorm * trainingVectorNorm - helperNorm * helperNorm);        }        return;    }    currentState.setActivationNumerator(pseudoEigen.dot(trainingVector));    currentState.setActivationNumerator(currentState.getActivationNumerator() - currentState.getHelperVector().dot(currentState.currentTrainingProjection()));    double activation = currentState.getActivationNumerator() / Math.sqrt(currentState.getActivationDenominatorSquared());    currentState.setActivationDenominatorSquared(currentState.getActivationDenominatorSquared() + 2 * activation * currentState.getActivationNumerator() + activation * activation * (trainingVector.getLengthSquared() - currentState.currentTrainingProjection().getLengthSquared()));    if (numPreviousEigens > 0) {        currentState.getHelperVector().assign(currentState.currentTrainingProjection(), new PlusMult(activation));    }    pseudoEigen.assign(trainingVector, new PlusMult(activation));}
275f596f20040e40d29deb0847a62a1c20df524e4000f229af500c3ed686f985
updateTrainingProjectionsVector
private static void updateTrainingProjectionsVector(TrainingState state, Vector trainingVector, int previousEigenIndex)
{    Vector previousEigen = state.mostRecentEigen();    Vector currentTrainingVectorProjection = state.currentTrainingProjection();    double projection = previousEigen.dot(trainingVector);    currentTrainingVectorProjection.set(previousEigenIndex, projection);}
de6677c196a3bed71868457ed8d0e979e271ba07ca3c1f0a145d053170d51fa7
mostRecentEigen
public Vector mostRecentEigen()
{    return currentEigens.viewRow(numEigensProcessed - 1);}
b05c5269f37fb78943ca7a11ec4c99f0584f09dc177ac145d0d05bb28dcdcece
currentTrainingProjection
public Vector currentTrainingProjection()
{    if (trainingProjections.viewRow(trainingIndex) == null) {        trainingProjections.assignRow(trainingIndex, new DenseVector(currentEigens.numCols()));    }    return trainingProjections.viewRow(trainingIndex);}
adef8f63f498d6cce2b26f0781a31ff1a35288606d8552dcf760fb2e964ad495
getCurrentEigens
public Matrix getCurrentEigens()
{    return currentEigens;}
6e2c6440b39276e1fb62edf63cc4ff25f1b636f3e819a026bc710ca921220580
setCurrentEigens
public void setCurrentEigens(Matrix currentEigens)
{    this.currentEigens = currentEigens;}
b414bf67471d0b2142c3d38a5fe71ef55f1b920b028b64bcdcc909921d1d5eb2
getNumEigensProcessed
public int getNumEigensProcessed()
{    return numEigensProcessed;}
8011faf375104de51dee374741ad5fdee063baec153ff80f77cfb0add77b721b
setNumEigensProcessed
public void setNumEigensProcessed(int numEigensProcessed)
{    this.numEigensProcessed = numEigensProcessed;}
28add04a1a80b723cc28d6f4b30117fba52aee068ad8f7e3c05075a9de28deb6
getCurrentEigenValues
public List<Double> getCurrentEigenValues()
{    return currentEigenValues;}
6c816e083d2fd67ca62dec205b573128c3a87e17358f8731fc57770335304f73
setCurrentEigenValues
public void setCurrentEigenValues(List<Double> currentEigenValues)
{    this.currentEigenValues = currentEigenValues;}
ae115b6314197ed5edbf0a8f70a8c14d7deca95c02c58b064ea1be0e80928458
getTrainingProjections
public Matrix getTrainingProjections()
{    return trainingProjections;}
1cfc9cb4e6991041afea80d92b04597f6e9e9a0c151f7b007907cffed37c9035
setTrainingProjections
public void setTrainingProjections(Matrix trainingProjections)
{    this.trainingProjections = trainingProjections;}
0d4549f9152cfc6f2ad1436a50a90e5d3a3c1eb91c94a934b85b05e760b4853c
getTrainingIndex
public int getTrainingIndex()
{    return trainingIndex;}
ae3a8694129f57e2983935dc38d81af0f7556008beb9bfc2cf0d43ddae79f845
setTrainingIndex
public void setTrainingIndex(int trainingIndex)
{    this.trainingIndex = trainingIndex;}
7127b90fc0e20943e0036dad47f12431f06606e17f7732b9825b2ca8b489b4e8
getHelperVector
public Vector getHelperVector()
{    return helperVector;}
53bcf6882603d28cc7baec4afd6f382a76980bb3114de0a4e73cb2b3a6f825e9
setHelperVector
public void setHelperVector(Vector helperVector)
{    this.helperVector = helperVector;}
492bf91eb573b51b05054f05bfba7a04b5bb04755046907538c2eaaf2fb58ae1
isFirstPass
public boolean isFirstPass()
{    return firstPass;}
b4c7a92f609ba9331cf0b9d363b0671644e0137da1d85e01eddd564bfd54e070
setFirstPass
public void setFirstPass(boolean firstPass)
{    this.firstPass = firstPass;}
e29c676e3be505ffb2af00bf8ae4af3294e7b988e0cba1ed94ef3a97c660d8fe
getStatusProgress
public List<EigenStatus> getStatusProgress()
{    return statusProgress;}
7704cdbbd58270591f8666ae431f4e4a5621c81ae3ac32491fb7cb57dc769ff6
setStatusProgress
public void setStatusProgress(List<EigenStatus> statusProgress)
{    this.statusProgress = statusProgress;}
687bfaf20219d13bdc2e4f61edd27455d1691271fab38511dd7115ae77aff853
getActivationNumerator
public double getActivationNumerator()
{    return activationNumerator;}
807f357edb02272498459a0db08396774f9b184575ccebabe82eb6dacd95aec9
setActivationNumerator
public void setActivationNumerator(double activationNumerator)
{    this.activationNumerator = activationNumerator;}
9e6ec5fc6bf027d50ebdf6650759d886e6251e2c8b3409b14293f6c65824152c
getActivationDenominatorSquared
public double getActivationDenominatorSquared()
{    return activationDenominatorSquared;}
8b8373486a399add5f1dd6044a0dea32cf35f89d232f76dc700d8daf8baf0253
setActivationDenominatorSquared
public void setActivationDenominatorSquared(double activationDenominatorSquared)
{    this.activationDenominatorSquared = activationDenominatorSquared;}
685ca82cead33e56c75cad5ace5f3cba2e4e471d0dcc68359527832073e7cdd4
apply
public double apply(double arg1)
{    return arg1 * d;}
e774d13c8505547691f0c86ac017490bf71848a16d988f67f5bdc0d33ed24b52
solve
public void solve(LanczosState state, int desiredRank)
{    solve(state, desiredRank, false);}
63978d3e16b02e50c47ca772ba65d14c9364a9e58edca6af2492c184739be526
solve
public void solve(LanczosState state, int desiredRank, boolean isSymmetric)
{    VectorIterable corpus = state.getCorpus();    log.info("Finding {} singular vectors of matrix with {} rows, via Lanczos", desiredRank, corpus.numRows());    int i = state.getIterationNumber();    Vector currentVector = state.getBasisVector(i - 1);    Vector previousVector = state.getBasisVector(i - 2);    double beta = 0;    Matrix triDiag = state.getDiagonalMatrix();    while (i < desiredRank) {        startTime(TimingSection.ITERATE);        Vector nextVector = isSymmetric ? corpus.times(currentVector) : corpus.timesSquared(currentVector);        log.info("{} passes through the corpus so far...", i);        if (state.getScaleFactor() <= 0) {            state.setScaleFactor(calculateScaleFactor(nextVector));        }        nextVector.assign(new Scale(1.0 / state.getScaleFactor()));        if (previousVector != null) {            nextVector.assign(previousVector, new PlusMult(-beta));        }                double alpha = currentVector.dot(nextVector);        nextVector.assign(currentVector, new PlusMult(-alpha));        endTime(TimingSection.ITERATE);        startTime(TimingSection.ORTHOGANLIZE);        orthoganalizeAgainstAllButLast(nextVector, state);        endTime(TimingSection.ORTHOGANLIZE);                beta = nextVector.norm(2);        if (outOfRange(beta) || outOfRange(alpha)) {            log.warn("Lanczos parameters out of range: alpha = {}, beta = {}.  Bailing out early!", alpha, beta);            break;        }        nextVector.assign(new Scale(1 / beta));        state.setBasisVector(i, nextVector);        previousVector = currentVector;        currentVector = nextVector;                triDiag.set(i - 1, i - 1, alpha);        if (i < desiredRank - 1) {            triDiag.set(i - 1, i, beta);            triDiag.set(i, i - 1, beta);        }        state.setIterationNumber(++i);    }    startTime(TimingSection.TRIDIAG_DECOMP);    log.info("Lanczos iteration complete - now to diagonalize the tri-diagonal auxiliary matrix.");        EigenDecomposition decomp = new EigenDecomposition(triDiag);    Matrix eigenVects = decomp.getV();    Vector eigenVals = decomp.getRealEigenvalues();    endTime(TimingSection.TRIDIAG_DECOMP);    startTime(TimingSection.FINAL_EIGEN_CREATE);    for (int row = 0; row < i; row++) {        Vector realEigen = null;        Vector ejCol = eigenVects.viewColumn(row);        int size = Math.min(ejCol.size(), state.getBasisSize());        for (int j = 0; j < size; j++) {            double d = ejCol.get(j);            Vector rowJ = state.getBasisVector(j);            if (realEigen == null) {                realEigen = rowJ.like();            }            realEigen.assign(rowJ, new PlusMult(d));        }        Preconditions.checkState(realEigen != null);        assert realEigen != null;        realEigen = realEigen.normalize();        state.setRightSingularVector(row, realEigen);        double e = eigenVals.get(row) * state.getScaleFactor();        if (!isSymmetric) {            e = Math.sqrt(e);        }        log.info("Eigenvector {} found with eigenvalue {}", row, e);        state.setSingularValue(row, e);    }    log.info("LanczosSolver finished.");    endTime(TimingSection.FINAL_EIGEN_CREATE);}
fbd5dbf1caf62751726d5ad42d7358167bcb8a8aa5cba0bd78a1d06e663da0d6
calculateScaleFactor
protected static double calculateScaleFactor(Vector nextVector)
{    return nextVector.norm(2);}
f6a6c44e8d2b4288f5b4df176c8477048ef64dda4da2262b5d4c071092a087b1
outOfRange
private static boolean outOfRange(double d)
{    return Double.isNaN(d) || d > SAFE_MAX || -d > SAFE_MAX;}
e0e69d3630832aed94145bb978761e5c7202b20c860bf6a888996ae3a1a596c7
orthoganalizeAgainstAllButLast
protected static void orthoganalizeAgainstAllButLast(Vector nextVector, LanczosState state)
{    for (int i = 0; i < state.getIterationNumber(); i++) {        Vector basisVector = state.getBasisVector(i);        double alpha;        if (basisVector == null || (alpha = nextVector.dot(basisVector)) == 0.0) {            continue;        }        nextVector.assign(basisVector, new PlusMult(-alpha));    }}
d89b6f3e27350d2fefc7829267cbee3090ab071942c3d81f451b45691719ff50
startTime
private void startTime(TimingSection section)
{    startTimes.put(section, System.nanoTime());}
df184d9a1afdb6fdcd61f5b819c58e0bfb55d3726fa28d13ba2127975d716650
endTime
private void endTime(TimingSection section)
{    if (!times.containsKey(section)) {        times.put(section, 0L);    }    times.put(section, times.get(section) + System.nanoTime() - startTimes.get(section));}
ad531cb33947c09631b9a2a9e7032303c3757dbc0da56f109cde995efb9d4610
intitializeBasisAndSingularVectors
private void intitializeBasisAndSingularVectors()
{    basis = Maps.newHashMap();    singularVectors = Maps.newHashMap();}
4096580da85c9f429b058605f2b34f2f8aed78cfbd02ec8ea92a92808b3414d5
getDiagonalMatrix
public Matrix getDiagonalMatrix()
{    return diagonalMatrix;}
a03adedb3cc083439f3c249210ff02869c11240f6eb6330e6e74642fe65509f8
getIterationNumber
public int getIterationNumber()
{    return iterationNumber;}
3cb8de88aa6405d4ef4acdff9ea55680c324f8c38cb551d95a8403f0199cd85a
getScaleFactor
public double getScaleFactor()
{    return scaleFactor;}
31a4b5527ae519b2f891490c123cd403733bc58e716c8ac2c0d7f16de3401607
getCorpus
public VectorIterable getCorpus()
{    return corpus;}
9b41bb44506a1ff44d43054013c1a278ad27cd7a6583d4b84ff0c9de0a4f54bc
getRightSingularVector
public Vector getRightSingularVector(int i)
{    return singularVectors.get(i);}
06a0c86116e19a590614596a82d09ae430ffc6a946cfe459f0f0331353ef1bcb
getSingularValue
public Double getSingularValue(int i)
{    return singularValues.get(i);}
91a71fc878e336ad1a5878905eedc6f2a8366a09ecd3d7c6dc0a1e1f7646efd5
getBasisVector
public Vector getBasisVector(int i)
{    return basis.get(i);}
e8f528d7846acc92e12585770482109de1ef7ce37af4ec2815a70e652cd43892
getBasisSize
public int getBasisSize()
{    return basis.size();}
e5f204ebb84da08e5f241d2cc18de8e811f32c19d856ded2f6e8b6ab2b2be1b1
setBasisVector
public void setBasisVector(int i, Vector basisVector)
{    basis.put(i, basisVector);}
ff12505a55871ffc85485a7813203ea8b343949e9c418018faf5610248831d5d
setScaleFactor
public void setScaleFactor(double scale)
{    scaleFactor = scale;}
ec8f9523bdb76398e319dbdaaeae33aed7812de7010697d6d9ff332069c1060c
setIterationNumber
public void setIterationNumber(int i)
{    iterationNumber = i;}
7133338fb095a8c73f145a4fa88bc907f395c4f8346211612be1dd604df978fa
setRightSingularVector
public void setRightSingularVector(int i, Vector vector)
{    singularVectors.put(i, vector);}
43d68929d324c00a2eeb963961a3a4b0d17a148c689dedf284ec2edc9a83b6ef
setSingularValue
public void setSingularValue(int i, double value)
{    singularValues.put(i, value);}
222aed7084a98569fcc299251ec200d3e61ec8dbe8b5f21779aa61997fc7fb77
verify
public EigenStatus verify(VectorIterable corpus, Vector vector)
{    Vector resultantVector = corpus.timesSquared(vector);    double newNorm = resultantVector.norm(2);    double oldNorm = vector.norm(2);    double eigenValue;    double cosAngle;    if (newNorm > 0 && oldNorm > 0) {        eigenValue = newNorm / oldNorm;        cosAngle = resultantVector.dot(vector) / newNorm * oldNorm;    } else {        eigenValue = 1.0;        cosAngle = 0.0;    }    return new EigenStatus(eigenValue, cosAngle, false);}
79cbed8ec593faceb4946ba56ec5347061f2a2b271e2c36d7de0e1f0ae5aa0d3
getVector
public Vector getVector()
{    return delegate;}
ad91472a8eba4486be34525ff11666fd262da25724267fbaf658819d805a43bb
aggregate
public double aggregate(DoubleDoubleFunction aggregator, DoubleFunction map)
{    return delegate.aggregate(aggregator, map);}
a85898b9f6be2e6a74d8c9cf590860cdcc7afe91571b28abda3f27dc495e0506
aggregate
public double aggregate(Vector other, DoubleDoubleFunction aggregator, DoubleDoubleFunction combiner)
{    return delegate.aggregate(other, aggregator, combiner);}
652b99eb4e9a262b74a7b3cfc036effdc8dda8563fcbe31fb8a2d36911ea55fc
viewPart
public Vector viewPart(int offset, int length)
{    return delegate.viewPart(offset, length);}
884f06bfd74abf9fcac20d7d3e56bc5f671ec9a0f686c5a89f82c391ef5b3fce
clone
public Vector clone()
{    DelegatingVector r;    try {        r = (DelegatingVector) super.clone();    } catch (CloneNotSupportedException e) {        throw new RuntimeException("Clone not supported for DelegatingVector, shouldn't be possible");    }        r.delegate = delegate.clone();    return r;}
925b6c0af2716d475d5e78f46e549c77e229efa113e150b00d5e1b6287de16eb
all
public Iterable<Element> all()
{    return delegate.all();}
79761b2bde82a72af5456dc0789a0d7a6a00b985705b9fe5b7e2e4fc643ded15
nonZeroes
public Iterable<Element> nonZeroes()
{    return delegate.nonZeroes();}
49608444d34acf8c21b5de98b7ca587f30d3d8c2b2267746bea420e294082f35
divide
public Vector divide(double x)
{    return delegate.divide(x);}
b0c6cf88ddad567458c3f9568e63bbd3ba3d401ed8f874e155db9189495e78d4
dot
public double dot(Vector x)
{    return delegate.dot(x);}
9f213e4a143454bd6f6fafb1c1293c69c2707c2477182f834f9b8e4a465adafe
get
public double get(int index)
{    return delegate.get(index);}
d82b144f248d736e85f2b7532a8b5190c1efdf491bff22194d6e776d9d004ac7
getElement
public Element getElement(int index)
{    return delegate.getElement(index);}
0f2cea51f07acae4d2eb073f5151beaf6dba8920eaf21ed6212f67553909727d
mergeUpdates
public void mergeUpdates(OrderedIntDoubleMapping updates)
{    delegate.mergeUpdates(updates);}
c23409779826dac95c386df54c347cdb3cbe5a36f4a561940c8c09fa1a085bcc
minus
public Vector minus(Vector that)
{    return delegate.minus(that);}
522a2cb2764f9f34b1f533404314dd0113b5ed78a0de6d0783f3ec54609375cc
normalize
public Vector normalize()
{    return delegate.normalize();}
0978b7df23acea2fdc52d893200013252773356ec6e84a75d2a010439cffc48c
normalize
public Vector normalize(double power)
{    return delegate.normalize(power);}
b3d6d678da20f3a65cb98fc8bbdd89e832e2a722d929292197be4eb74ecd440c
logNormalize
public Vector logNormalize()
{    return delegate.logNormalize();}
b72ab7b48aea139e8daf0d711f8fa7e0f2f41338b8750de918645cb98d0bad9c
logNormalize
public Vector logNormalize(double power)
{    return delegate.logNormalize(power);}
cd58bf1d0ad8e4702d41c559a572b84f7b8d34cb58bfc0018689ffe97fe3cef8
norm
public double norm(double power)
{    return delegate.norm(power);}
ad8e67cc94b6d67341e2eafa669a96e4de141addeda84e43821d24ae5aca2a5a
getLengthSquared
public double getLengthSquared()
{    return delegate.getLengthSquared();}
4b2faf4e4fff196a9099ea61c4bdb51b2037b9b0a82cfff3cc4dd29f4641bf4b
invalidateCachedLength
public void invalidateCachedLength()
{    if (delegate instanceof LengthCachingVector) {        ((LengthCachingVector) delegate).invalidateCachedLength();    }}
7375e752d4233bc7cb5a0df13e4653bd8767c60a41b29c64339fa5293a71d1ce
getDistanceSquared
public double getDistanceSquared(Vector v)
{    return delegate.getDistanceSquared(v);}
6b67fad6dd27aa2525cafe6cf3396d2225fbcdf57e5378ac7a3dee60e61f20e8
getLookupCost
public double getLookupCost()
{    return delegate.getLookupCost();}
c79b5203142f65c96c29c2652557bad0bda511dfe38011e3b2877dd681f7c9cf
getIteratorAdvanceCost
public double getIteratorAdvanceCost()
{    return delegate.getIteratorAdvanceCost();}
c5fbf138e094d3027905103c89bbab4aa48cd369c50dde054752fd31aa322767
isAddConstantTime
public boolean isAddConstantTime()
{    return delegate.isAddConstantTime();}
673e2f18abb6a076f5f26e614aec950d2752388e647d9c268e8161b493f73a85
maxValue
public double maxValue()
{    return delegate.maxValue();}
825d17834ad4d5540936ce10989cdc91141b79780ba970f5efa1f615e18f6920
maxValueIndex
public int maxValueIndex()
{    return delegate.maxValueIndex();}
e5c330b7bf4bcc42b747fb25502aa859f7e55feac55529444725ac7756c5b1da
minValue
public double minValue()
{    return delegate.minValue();}
a58af97687735fad30d51302a64b5b3d3e939920191b08c27aa07d06a3744bf4
minValueIndex
public int minValueIndex()
{    return delegate.minValueIndex();}
9633b91a2f284f6d333a144ebf53a1813a31909260e076aa36ae8cd199af8df3
plus
public Vector plus(double x)
{    return delegate.plus(x);}
f25fd64ca5a9af413d8151a8c5caf1e2ae36bf6433abfe831c00b37d4dd6669c
plus
public Vector plus(Vector x)
{    return delegate.plus(x);}
40eb830e31d13276cef93d31667d9f8fe511a811948c5ebb2beb5e1bbd43f76e
set
public void set(int index, double value)
{    delegate.set(index, value);}
8b96a7945012e7b138a0b76ff9af9b5fe4b135b2aaa1d15efa12f110aacd7076
times
public Vector times(double x)
{    return delegate.times(x);}
06d8b41367bc9c0e3e3b3087b2403f8832c5f1d5d0a71fa81f3833a36a4a3464
times
public Vector times(Vector x)
{    return delegate.times(x);}
b95580f8663abb6debfc0eb1df4fa773879d99b496a6abea19638268659178f2
zSum
public double zSum()
{    return delegate.zSum();}
a1323639bf61f130500353a35c23f7a93de0f5d2d5c75d6189884271d6351d22
assign
public Vector assign(double value)
{    delegate.assign(value);    return this;}
3507480612ff5c131d2eae1dc23f7afa7c53aa2a301f5ae71cc32bdb4eb18281
assign
public Vector assign(double[] values)
{    delegate.assign(values);    return this;}
c5a902d495966254e0a65f297ed31bc7d8e3264bd5d2bc6764e8e8ffdf600259
assign
public Vector assign(Vector other)
{    delegate.assign(other);    return this;}
5c653bdf24bc25b462b7a04a2c3eab8d086adba75ffafcc915a58a684eb5fec7
assign
public Vector assign(DoubleDoubleFunction f, double y)
{    delegate.assign(f, y);    return this;}
e75cdb4cb4b4a3e71d9d8ef8701b50ab8eefa217675ea9880dbd46255ae2c302
assign
public Vector assign(DoubleFunction function)
{    delegate.assign(function);    return this;}
cbdfe22e340c62843c4f162b0e6debb832eecdaf145c52a3ee7f3829b568b4cd
assign
public Vector assign(Vector other, DoubleDoubleFunction function)
{    delegate.assign(other, function);    return this;}
6dfe2cdb77cbc5b5b9a2b7aedc3d099d3410b7401613398216709750456c90d3
cross
public Matrix cross(Vector other)
{    return delegate.cross(other);}
72ef1e59027007ffe0950edfd2670ad03bb65cd6463d5d1d282dfeb1750435b0
size
public int size()
{    return delegate.size();}
ae284afe1ade5afe0242f68b99b1251c8ef4ebfb1ffd6eaa841c8d273ed0c131
asFormatString
public String asFormatString()
{    return delegate.asFormatString();}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return delegate.hashCode();}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    return delegate.equals(o);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return delegate.toString();}
383032e836ae8e377e669da8e774cd6f6410cb106bd66015b484c883dc1c467c
isDense
public boolean isDense()
{    return delegate.isDense();}
048fcadf359a37696af85547983c8e1a90a6c62d53a2f5c66ba6b94ae1c5b98c
isSequentialAccess
public boolean isSequentialAccess()
{    return delegate.isSequentialAccess();}
2263144cad9c9fdd2eecb03c9f0c31fc79e73b974408c87f743169e8bea1c8f3
getQuick
public double getQuick(int index)
{    return delegate.getQuick(index);}
3f06e4bc1bde206fe6ac26b2e2c12970bc557eee7de0d8e8394b1f96568db34b
like
public Vector like()
{    return new DelegatingVector(delegate.like());}
de7fe3d006f2cc6fa563e7089bbae0e5300ec5b2f82e856c1118dd26a5798a5f
like
public Vector like(int cardinality)
{    return new DelegatingVector(delegate.like(cardinality));}
d90a04e96781b1eebeec5aca2a7d384a466650ea31ec4abd55dff982b7d2e12d
setQuick
public void setQuick(int index, double value)
{    delegate.setQuick(index, value);}
c8a20d62d9c3255d60b3b80ebe6816bd042c01abf073d860c31aa2f68df390bf
incrementQuick
public void incrementQuick(int index, double increment)
{    delegate.incrementQuick(index, increment);}
f6c83ebe319a78b7975eba92f536cfcf2e5e6786960fb07f54a0c99258711da5
getNumNondefaultElements
public int getNumNondefaultElements()
{    return delegate.getNumNondefaultElements();}
8b7fcb91dbcc77620d88bd932afdf043420de45274bcf542432eb86706753faf
getNumNonZeroElements
public int getNumNonZeroElements()
{    return delegate.getNumNonZeroElements();}
035b379ff069515e5e78e5afd8aa79334038f324a66fbc68e374a558029742b2
getBackingStructure
public double[][] getBackingStructure()
{    return this.values;}
718d9e27b4314887356041933895f3ca7614086ebd95c67fc99404a51fab676b
clone
public Matrix clone()
{    DenseMatrix clone = (DenseMatrix) super.clone();    clone.values = new double[values.length][];    for (int i = 0; i < values.length; i++) {        clone.values[i] = values[i].clone();    }    return clone;}
1a7b4a2d3001072b037d625fbd603f24082fad4d995e7354ef48188cd1906c22
getQuick
public double getQuick(int row, int column)
{    return values[row][column];}
8ea1ca8bbfed9d923bb33b6722a3491db09837bb6812b8b8778bf2422064e0ab
like
public Matrix like()
{    return like(rowSize(), columnSize());}
f88fece6b0c6401785f452c13d8cce7ea1dc13011ee8686b08685d42b6f32638
like
public Matrix like(int rows, int columns)
{    return new DenseMatrix(rows, columns);}
c733fce42980b3396a3426c0cfb05355954939da4f722c3d81ab2555e6bd9282
setQuick
public void setQuick(int row, int column, double value)
{    values[row][column] = value;}
242adb7156cbde039fd67ab8f5ed8c9c46c199c38c6f12d05d2dbaffd8178820
viewPart
public Matrix viewPart(int[] offset, int[] size)
{    int rowOffset = offset[ROW];    int rowsRequested = size[ROW];    int columnOffset = offset[COL];    int columnsRequested = size[COL];    return viewPart(rowOffset, rowsRequested, columnOffset, columnsRequested);}
2790911dfaf9008a5ec53f5440a28547fcc44ec2c01b5212aa6d5a8f618ae9f7
viewPart
public Matrix viewPart(int rowOffset, int rowsRequested, int columnOffset, int columnsRequested)
{    if (rowOffset < 0) {        throw new IndexException(rowOffset, rowSize());    }    if (rowOffset + rowsRequested > rowSize()) {        throw new IndexException(rowOffset + rowsRequested, rowSize());    }    if (columnOffset < 0) {        throw new IndexException(columnOffset, columnSize());    }    if (columnOffset + columnsRequested > columnSize()) {        throw new IndexException(columnOffset + columnsRequested, columnSize());    }    return new MatrixView(this, new int[] { rowOffset, columnOffset }, new int[] { rowsRequested, columnsRequested });}
13bb0e6afc607db9d98d3823768dff2d87db4d7d21d4701725b875d2cf5126d7
assign
public Matrix assign(double value)
{    for (int row = 0; row < rowSize(); row++) {        Arrays.fill(values[row], value);    }    return this;}
1277e5b7cd15978e2dc10a2f4b1f99fe937854a374dcf5a371f3e159ee003fe2
assign
public Matrix assign(DenseMatrix matrix)
{        if (matrix.values[0].length != this.values[0].length || matrix.values.length != this.values.length) {        this.values = new double[matrix.values.length][matrix.values[0].length];    }        for (int i = 0; i < this.values.length; i++) {        System.arraycopy(matrix.values[i], 0, this.values[i], 0, this.values[0].length);    }    return this;}
2d445c7af662ad5641bd7c216b4e7684a9cdab361f239540c55a18b81c86443c
assignColumn
public Matrix assignColumn(int column, Vector other)
{    if (rowSize() != other.size()) {        throw new CardinalityException(rowSize(), other.size());    }    if (column < 0 || column >= columnSize()) {        throw new IndexException(column, columnSize());    }    for (int row = 0; row < rowSize(); row++) {        values[row][column] = other.getQuick(row);    }    return this;}
95687ef4453f7375a5854c6fa51b38f6963e77319dd3f4176496189e5fd67c55
assignRow
public Matrix assignRow(int row, Vector other)
{    if (columnSize() != other.size()) {        throw new CardinalityException(columnSize(), other.size());    }    if (row < 0 || row >= rowSize()) {        throw new IndexException(row, rowSize());    }    for (int col = 0; col < columnSize(); col++) {        values[row][col] = other.getQuick(col);    }    return this;}
cc845ba0d004ee14775588b6cb695a9053ef1f384e5196e605687c0f7eeac020
viewRow
public Vector viewRow(int row)
{    if (row < 0 || row >= rowSize()) {        throw new IndexException(row, rowSize());    }    return new DenseVector(values[row], true);}
4f943db0f33d27c9f70c541ef27a217346904d47c0870b555f1140eebdc0f9b2
getFlavor
public MatrixFlavor getFlavor()
{    return MatrixFlavor.DENSELIKE;}
1a7b4a2d3001072b037d625fbd603f24082fad4d995e7354ef48188cd1906c22
getQuick
public double getQuick(int row, int column)
{    if (column < row) {        int swap = row;        row = column;        column = swap;    }    return super.getQuick(row, column);}
c733fce42980b3396a3426c0cfb05355954939da4f722c3d81ab2555e6bd9282
setQuick
public void setQuick(int row, int column, double value)
{    if (column < row) {        int swap = row;        row = column;        column = swap;    }    super.setQuick(row, column, value);}
b0c6cf88ddad567458c3f9568e63bbd3ba3d401ed8f874e155db9189495e78d4
dot
public double dot(Vector x)
{    if (!x.isDense()) {        return super.dot(x);    } else {        int size = x.size();        if (values.length != size) {            throw new CardinalityException(values.length, size);        }        double sum = 0;        for (int n = 0; n < size; n++) {            sum += values[n] * x.getQuick(n);        }        return sum;    }}
39aa63eded95450eed8ae8438d97998d3316f664b548900552f7ffb6b0441d94
matrixLike
protected Matrix matrixLike(int rows, int columns)
{    return new DenseMatrix(rows, columns);}
f15092de7e065f760814e97bb1d3a3772476532aabdbb0faa3deb0ef966c2bfd
clone
public DenseVector clone()
{    return new DenseVector(values.clone());}
383032e836ae8e377e669da8e774cd6f6410cb106bd66015b484c883dc1c467c
isDense
public boolean isDense()
{    return true;}
048fcadf359a37696af85547983c8e1a90a6c62d53a2f5c66ba6b94ae1c5b98c
isSequentialAccess
public boolean isSequentialAccess()
{    return true;}
754606c70c7faeb2876eb10111c4f1326ee2b93cb3ec4cc2a99af875df2d9493
dotSelf
protected double dotSelf()
{    double result = 0.0;    int max = size();    for (int i = 0; i < max; i++) {        result += values[i] * values[i];    }    return result;}
2263144cad9c9fdd2eecb03c9f0c31fc79e73b974408c87f743169e8bea1c8f3
getQuick
public double getQuick(int index)
{    return values[index];}
fd322e57ccc9793e2c97e87b5341efa32df007eb4f8f1d61610be9347b287145
like
public DenseVector like()
{    return new DenseVector(size());}
de7fe3d006f2cc6fa563e7089bbae0e5300ec5b2f82e856c1118dd26a5798a5f
like
public Vector like(int cardinality)
{    return new DenseVector(cardinality);}
d90a04e96781b1eebeec5aca2a7d384a466650ea31ec4abd55dff982b7d2e12d
setQuick
public void setQuick(int index, double value)
{    invalidateCachedLength();    values[index] = value;}
c8a20d62d9c3255d60b3b80ebe6816bd042c01abf073d860c31aa2f68df390bf
incrementQuick
public void incrementQuick(int index, double increment)
{    invalidateCachedLength();    values[index] += increment;}
a1323639bf61f130500353a35c23f7a93de0f5d2d5c75d6189884271d6351d22
assign
public Vector assign(double value)
{    invalidateCachedLength();    Arrays.fill(values, value);    return this;}
f6c83ebe319a78b7975eba92f536cfcf2e5e6786960fb07f54a0c99258711da5
getNumNondefaultElements
public int getNumNondefaultElements()
{    return values.length;}
8b7fcb91dbcc77620d88bd932afdf043420de45274bcf542432eb86706753faf
getNumNonZeroElements
public int getNumNonZeroElements()
{    int numNonZeros = 0;    for (int index = 0; index < values.length; index++) {        if (values[index] != 0) {            numNonZeros++;        }    }    return numNonZeros;}
62dba0a9fa0b6c9e30921478cca3f7ce3cfb4a4a56213dd9f7948cf7f20c8b30
assign
public Vector assign(DenseVector vector)
{        if (vector.values.length != this.values.length) {        this.values = new double[vector.values.length];    }        System.arraycopy(vector.values, 0, this.values, 0, this.values.length);    return this;}
0f2cea51f07acae4d2eb073f5151beaf6dba8920eaf21ed6212f67553909727d
mergeUpdates
public void mergeUpdates(OrderedIntDoubleMapping updates)
{    int numUpdates = updates.getNumMappings();    int[] indices = updates.getIndices();    double[] values = updates.getValues();    for (int i = 0; i < numUpdates; ++i) {        this.values[indices[i]] = values[i];    }}
652b99eb4e9a262b74a7b3cfc036effdc8dda8563fcbe31fb8a2d36911ea55fc
viewPart
public Vector viewPart(int offset, int length)
{    if (offset < 0) {        throw new IndexException(offset, size());    }    if (offset + length > size()) {        throw new IndexException(offset + length, size());    }    return new DenseVectorView(this, offset, length);}
6b67fad6dd27aa2525cafe6cf3396d2225fbcdf57e5378ac7a3dee60e61f20e8
getLookupCost
public double getLookupCost()
{    return 1;}
c79b5203142f65c96c29c2652557bad0bda511dfe38011e3b2877dd681f7c9cf
getIteratorAdvanceCost
public double getIteratorAdvanceCost()
{    return 1;}
c5fbf138e094d3027905103c89bbab4aa48cd369c50dde054752fd31aa322767
isAddConstantTime
public boolean isAddConstantTime()
{    return true;}
0494c3c5bbf01f97ae3671ecd67c5586bc95bd0aa1907bd0e3ebdc94d70e1683
iterateNonZero
public Iterator<Element> iterateNonZero()
{    return new NonDefaultIterator();}
ebaf88b6206d3b34b79e1287ba43a83a7321437a7f6da5136b43af17bd0a0476
iterator
public Iterator<Element> iterator()
{    return new AllIterator();}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (o instanceof DenseVector) {                return Arrays.equals(values, ((DenseVector) o).values);    }    return super.equals(o);}
1824ec70befb4d934e04d0c83d3f36b186ab841b1c9cbb6607f4d85a405b1f9d
addAll
public void addAll(Vector v)
{    if (size() != v.size()) {        throw new CardinalityException(size(), v.size());    }    for (Element element : v.nonZeroes()) {        values[element.index()] += element.get();    }}
d51e5f7450eca0a0f63da1a466189e262d053b84aa767ba3be5cea740af7251b
hasNext
public boolean hasNext()
{    if (lookAheadIndex == index) {                lookAhead();    }        return lookAheadIndex < size();}
a71ddfeeb398b7f05e83d0bbfab60b3d1c5cb1efae556ec7b317781f793da1e1
lookAhead
private void lookAhead()
{    lookAheadIndex++;    while (lookAheadIndex < size() && values[lookAheadIndex] == 0.0) {        lookAheadIndex++;    }}
00dabe2a90975d31521e92d62eb76f2fcf9c0e9659c3684667d164334b5f370e
next
public Element next()
{    if (lookAheadIndex == index) {                lookAhead();    }    Preconditions.checkState(lookAheadIndex > index);    index = lookAheadIndex;    if (index >= size()) {                throw new NoSuchElementException();    }    element.index = index;    return element;}
eb35e4acc0ab2c89fd30970f01fba35488b3a4581b2af1986091209043508a3e
remove
public void remove()
{    throw new UnsupportedOperationException();}
d51e5f7450eca0a0f63da1a466189e262d053b84aa767ba3be5cea740af7251b
hasNext
public boolean hasNext()
{    return element.index + 1 < size();}
00dabe2a90975d31521e92d62eb76f2fcf9c0e9659c3684667d164334b5f370e
next
public Element next()
{    if (element.index + 1 >= size()) {                throw new NoSuchElementException();    }    element.index++;    return element;}
eb35e4acc0ab2c89fd30970f01fba35488b3a4581b2af1986091209043508a3e
remove
public void remove()
{    throw new UnsupportedOperationException();}
6f9021560b40d5f0ea4687dcfc9163f88e04e559e2fc0af5f9a1fed73b4e4c24
get
public double get()
{    return values[index];}
5dd366da2313537c415c3c2ab9ed1909d1250d894a032bd02373d113516571d0
index
public int index()
{    return index;}
0ca3b3a320922927ea9a06f3def94b995d23a5eb7b95de57c7935a827c79759c
set
public void set(double value)
{    invalidateCachedLength();    values[index] = value;}
b0c6cf88ddad567458c3f9568e63bbd3ba3d401ed8f874e155db9189495e78d4
dot
public double dot(Vector x)
{        if (x instanceof DenseVectorView) {        if (size() != x.size())            throw new IllegalArgumentException("Cardinality mismatch during dot(x,y).");        DenseVectorView xv = (DenseVectorView) x;        double[] thisValues = ((DenseVector) vector).values;        double[] thatValues = ((DenseVector) xv.vector).values;        int untilOffset = offset + size();        int i, j;        double sum = 0.0;                int until4 = offset + (size() & ~3);        for (i = offset, j = xv.offset; i < until4; i += 4, j += 4) {            sum += thisValues[i] * thatValues[j] + thisValues[i + 1] * thatValues[j + 1] + thisValues[i + 2] * thatValues[j + 2] + thisValues[i + 3] * thatValues[j + 3];        }                for (i = offset, j = xv.offset; i < untilOffset; ) {            sum += thisValues[i++] * thatValues[j++];        }        return sum;    } else if (x instanceof DenseVector) {        if (size() != x.size())            throw new IllegalArgumentException("Cardinality mismatch during dot(x,y).");        DenseVector xv = (DenseVector) x;        double[] thisValues = ((DenseVector) vector).values;        double[] thatValues = xv.values;        int untilOffset = offset + size();        int i, j;        double sum = 0.0;                int until4 = offset + (size() & ~3);        for (i = offset, j = 0; i < until4; i += 4, j += 4) {            sum += thisValues[i] * thatValues[j] + thisValues[i + 1] * thatValues[j + 1] + thisValues[i + 2] * thatValues[j + 2] + thisValues[i + 3] * thatValues[j + 3];        }                for (; i < untilOffset; ) {            sum += thisValues[i++] * thatValues[j++];        }        return sum;    } else {        return super.dot(x);    }}
652b99eb4e9a262b74a7b3cfc036effdc8dda8563fcbe31fb8a2d36911ea55fc
viewPart
public Vector viewPart(int offset, int length)
{    if (offset < 0) {        throw new IndexException(offset, size());    }    if (offset + length > size()) {        throw new IndexException(offset + length, size());    }    return new DenseVectorView(vector, offset + this.offset, length);}
47e1252ff61f13b3a973f37f929cf494b47c1bbb795c1b3450254eef7fdae7d9
identity
public static DiagonalMatrix identity(int size)
{    return new DiagonalMatrix(1, size);}
2d445c7af662ad5641bd7c216b4e7684a9cdab361f239540c55a18b81c86443c
assignColumn
public Matrix assignColumn(int column, Vector other)
{    throw new UnsupportedOperationException("Can't assign a column to a diagonal matrix");}
95687ef4453f7375a5854c6fa51b38f6963e77319dd3f4176496189e5fd67c55
assignRow
public Matrix assignRow(int row, Vector other)
{    throw new UnsupportedOperationException("Can't assign a row to a diagonal matrix");}
cc845ba0d004ee14775588b6cb695a9053ef1f384e5196e605687c0f7eeac020
viewRow
public Vector viewRow(int row)
{    return new SingleElementVector(row);}
ded778e2b6c79dc8341735761a4e2e443e5f6bbc800f12578b3eb5df4bc0a1f5
viewColumn
public Vector viewColumn(int row)
{    return new SingleElementVector(row);}
2263144cad9c9fdd2eecb03c9f0c31fc79e73b974408c87f743169e8bea1c8f3
getQuick
public double getQuick(int index)
{    if (index == this.index) {        return diagonal.get(index);    } else {        return 0;    }}
40eb830e31d13276cef93d31667d9f8fe511a811948c5ebb2beb5e1bbd43f76e
set
public void set(int index, double value)
{    if (index == this.index) {        diagonal.set(index, value);    } else {        throw new IllegalArgumentException("Can't set off-diagonal element of diagonal matrix");    }}
306642784ff1689a54dece91b85d40a461ffce07bb95b5de633388bfb6040660
iterateNonZero
protected Iterator<Element> iterateNonZero()
{    return new Iterator<Element>() {        boolean more = true;        @Override        public boolean hasNext() {            return more;        }        @Override        public Element next() {            if (more) {                more = false;                return new Element() {                    @Override                    public double get() {                        return diagonal.get(index);                    }                    @Override                    public int index() {                        return index;                    }                    @Override                    public void set(double value) {                        diagonal.set(index, value);                    }                };            } else {                throw new NoSuchElementException("Only one non-zero element in a row or column of a diagonal matrix");            }        }        @Override        public void remove() {            throw new UnsupportedOperationException("Can't remove from vector view");        }    };}
d51e5f7450eca0a0f63da1a466189e262d053b84aa767ba3be5cea740af7251b
hasNext
public boolean hasNext()
{    return more;}
00dabe2a90975d31521e92d62eb76f2fcf9c0e9659c3684667d164334b5f370e
next
public Element next()
{    if (more) {        more = false;        return new Element() {            @Override            public double get() {                return diagonal.get(index);            }            @Override            public int index() {                return index;            }            @Override            public void set(double value) {                diagonal.set(index, value);            }        };    } else {        throw new NoSuchElementException("Only one non-zero element in a row or column of a diagonal matrix");    }}
6f9021560b40d5f0ea4687dcfc9163f88e04e559e2fc0af5f9a1fed73b4e4c24
get
public double get()
{    return diagonal.get(index);}
5dd366da2313537c415c3c2ab9ed1909d1250d894a032bd02373d113516571d0
index
public int index()
{    return index;}
0ca3b3a320922927ea9a06f3def94b995d23a5eb7b95de57c7935a827c79759c
set
public void set(double value)
{    diagonal.set(index, value);}
eb35e4acc0ab2c89fd30970f01fba35488b3a4581b2af1986091209043508a3e
remove
public void remove()
{    throw new UnsupportedOperationException("Can't remove from vector view");}
b560538a44d09562a2ca56a7bfdbf8a2f453b7a2165735b82a5c0cfe6512675b
iterator
protected Iterator<Element> iterator()
{    return new Iterator<Element>() {        int i = 0;        Element r = new Element() {            @Override            public double get() {                if (i == index) {                    return diagonal.get(index);                } else {                    return 0;                }            }            @Override            public int index() {                return i;            }            @Override            public void set(double value) {                if (i == index) {                    diagonal.set(index, value);                } else {                    throw new IllegalArgumentException("Can't set any element but diagonal");                }            }        };        @Override        public boolean hasNext() {            return i < diagonal.size() - 1;        }        @Override        public Element next() {            if (i < SingleElementVector.this.size() - 1) {                i++;                return r;            } else {                throw new NoSuchElementException("Attempted to access passed last element of vector");            }        }        @Override        public void remove() {            throw new UnsupportedOperationException("Default operation");        }    };}
6f9021560b40d5f0ea4687dcfc9163f88e04e559e2fc0af5f9a1fed73b4e4c24
get
public double get()
{    if (i == index) {        return diagonal.get(index);    } else {        return 0;    }}
5dd366da2313537c415c3c2ab9ed1909d1250d894a032bd02373d113516571d0
index
public int index()
{    return i;}
0ca3b3a320922927ea9a06f3def94b995d23a5eb7b95de57c7935a827c79759c
set
public void set(double value)
{    if (i == index) {        diagonal.set(index, value);    } else {        throw new IllegalArgumentException("Can't set any element but diagonal");    }}
d51e5f7450eca0a0f63da1a466189e262d053b84aa767ba3be5cea740af7251b
hasNext
public boolean hasNext()
{    return i < diagonal.size() - 1;}
00dabe2a90975d31521e92d62eb76f2fcf9c0e9659c3684667d164334b5f370e
next
public Element next()
{    if (i < SingleElementVector.this.size() - 1) {        i++;        return r;    } else {        throw new NoSuchElementException("Attempted to access passed last element of vector");    }}
eb35e4acc0ab2c89fd30970f01fba35488b3a4581b2af1986091209043508a3e
remove
public void remove()
{    throw new UnsupportedOperationException("Default operation");}
39aa63eded95450eed8ae8438d97998d3316f664b548900552f7ffb6b0441d94
matrixLike
protected Matrix matrixLike(int rows, int columns)
{    return new DiagonalMatrix(rows, columns);}
383032e836ae8e377e669da8e774cd6f6410cb106bd66015b484c883dc1c467c
isDense
public boolean isDense()
{    return false;}
048fcadf359a37696af85547983c8e1a90a6c62d53a2f5c66ba6b94ae1c5b98c
isSequentialAccess
public boolean isSequentialAccess()
{    return true;}
0f2cea51f07acae4d2eb073f5151beaf6dba8920eaf21ed6212f67553909727d
mergeUpdates
public void mergeUpdates(OrderedIntDoubleMapping updates)
{    throw new UnsupportedOperationException("Default operation");}
3f06e4bc1bde206fe6ac26b2e2c12970bc557eee7de0d8e8394b1f96568db34b
like
public Vector like()
{    return new DenseVector(size());}
de7fe3d006f2cc6fa563e7089bbae0e5300ec5b2f82e856c1118dd26a5798a5f
like
public Vector like(int cardinality)
{    return new DenseVector(cardinality);}
d90a04e96781b1eebeec5aca2a7d384a466650ea31ec4abd55dff982b7d2e12d
setQuick
public void setQuick(int index, double value)
{    if (index == this.index) {        diagonal.set(this.index, value);    } else {        throw new IllegalArgumentException("Can't set off-diagonal element of DiagonalMatrix");    }}
f6c83ebe319a78b7975eba92f536cfcf2e5e6786960fb07f54a0c99258711da5
getNumNondefaultElements
public int getNumNondefaultElements()
{    return 1;}
6b67fad6dd27aa2525cafe6cf3396d2225fbcdf57e5378ac7a3dee60e61f20e8
getLookupCost
public double getLookupCost()
{    return 0;}
c79b5203142f65c96c29c2652557bad0bda511dfe38011e3b2877dd681f7c9cf
getIteratorAdvanceCost
public double getIteratorAdvanceCost()
{    return 1;}
c5fbf138e094d3027905103c89bbab4aa48cd369c50dde054752fd31aa322767
isAddConstantTime
public boolean isAddConstantTime()
{    return false;}
24b87aa3c85b3c0c423315f8f17533d541580f31a389beffa11ef46db109611f
viewDiagonal
public Vector viewDiagonal()
{    return this.diagonal;}
1a7b4a2d3001072b037d625fbd603f24082fad4d995e7354ef48188cd1906c22
getQuick
public double getQuick(int row, int column)
{    if (row == column) {        return diagonal.get(row);    } else {        return 0;    }}
8ea1ca8bbfed9d923bb33b6722a3491db09837bb6812b8b8778bf2422064e0ab
like
public Matrix like()
{    return new SparseRowMatrix(rowSize(), columnSize());}
f88fece6b0c6401785f452c13d8cce7ea1dc13011ee8686b08685d42b6f32638
like
public Matrix like(int rows, int columns)
{    return new SparseRowMatrix(rows, columns);}
c733fce42980b3396a3426c0cfb05355954939da4f722c3d81ab2555e6bd9282
setQuick
public void setQuick(int row, int column, double value)
{    if (row == column) {        diagonal.set(row, value);    } else {        throw new UnsupportedOperationException("Can't set off-diagonal element");    }}
7714b327d86a7bf6870ba63ac39d817cef2071cb1e37ee1443f8106d3de5443a
getNumNondefaultElements
public int[] getNumNondefaultElements()
{    throw new UnsupportedOperationException("Don't understand how to implement this");}
242adb7156cbde039fd67ab8f5ed8c9c46c199c38c6f12d05d2dbaffd8178820
viewPart
public Matrix viewPart(int[] offset, int[] size)
{    return new MatrixView(this, offset, size);}
07edaa38b63aaa02b484989af04fac05f162d5fe81194b8fb6dd87f9fade2833
times
public Matrix times(Matrix other)
{    return timesRight(other);}
50ec79ea3c4dc707d6ed782d54fc0cfcd6503414d270f19b312a178fb54e4db9
timesRight
public Matrix timesRight(Matrix that)
{    if (that.numRows() != diagonal.size()) {        throw new IllegalArgumentException("Incompatible number of rows in the right operand of matrix multiplication.");    }    Matrix m = that.like();    for (int row = 0; row < diagonal.size(); row++) {        m.assignRow(row, that.viewRow(row).times(diagonal.getQuick(row)));    }    return m;}
2057a8e2a1ad155e7015a4e8293d41a34f985ffcbebc3bfd92528c49b742c2f7
timesLeft
public Matrix timesLeft(Matrix that)
{    if (that.numCols() != diagonal.size()) {        throw new IllegalArgumentException("Incompatible number of rows in the left operand of matrix-matrix multiplication.");    }    Matrix m = that.like();    for (int col = 0; col < diagonal.size(); col++) {        m.assignColumn(col, that.viewColumn(col).times(diagonal.getQuick(col)));    }    return m;}
4f943db0f33d27c9f70c541ef27a217346904d47c0870b555f1140eebdc0f9b2
getFlavor
public MatrixFlavor getFlavor()
{    return MatrixFlavor.DIAGONALLIKE;}
367d5bd441f54c182da21f3b9056eb0bd0b6ded92dc76fa9664d47254c51b0c0
addData
private void addData(DoubleBuffer content)
{    this.content.add(content);}
5a04363c4c5c7de0ed80e41eafa6f76046fa0e741e2d252682e503939fb38c88
setData
public void setData(File f, boolean loadNow) throws IOException
{    Preconditions.checkArgument(f.length() == rows * columns * 8L, "File " + f + " is wrong length");    for (int i = 0; i < (rows + rowsPerBlock - 1) / rowsPerBlock; i++) {        long start = i * rowsPerBlock * columns * 8L;        long size = rowsPerBlock * columns * 8L;        MappedByteBuffer buf = new FileInputStream(f).getChannel().map(FileChannel.MapMode.READ_ONLY, start, Math.min(f.length() - start, size));        if (loadNow) {            buf.load();        }        addData(buf.asDoubleBuffer());    }}
51486d16c7d5406ddb6b5f6d19041207eebaa0863b98d2d79d5637c7ff988904
writeMatrix
public static void writeMatrix(File f, Matrix m) throws IOException
{    Preconditions.checkArgument(f.canWrite(), "Can't write to output file");    FileOutputStream fos = new FileOutputStream(f);    try {        ByteBuffer buf = ByteBuffer.allocate(m.columnSize() * 8);        for (MatrixSlice row : m) {            buf.clear();            for (Vector.Element element : row.vector().all()) {                buf.putDouble(element.get());            }            buf.flip();            fos.write(buf.array());        }    } finally {        fos.close();    }}
2d445c7af662ad5641bd7c216b4e7684a9cdab361f239540c55a18b81c86443c
assignColumn
public Matrix assignColumn(int column, Vector other)
{    throw new UnsupportedOperationException("Default operation");}
95687ef4453f7375a5854c6fa51b38f6963e77319dd3f4176496189e5fd67c55
assignRow
public Matrix assignRow(int row, Vector other)
{    throw new UnsupportedOperationException("Default operation");}
1a7b4a2d3001072b037d625fbd603f24082fad4d995e7354ef48188cd1906c22
getQuick
public double getQuick(int row, int column)
{    int block = row / rowsPerBlock;    return content.get(block).get((row % rowsPerBlock) * columns + column);}
8ea1ca8bbfed9d923bb33b6722a3491db09837bb6812b8b8778bf2422064e0ab
like
public Matrix like()
{    throw new UnsupportedOperationException("Default operation");}
f88fece6b0c6401785f452c13d8cce7ea1dc13011ee8686b08685d42b6f32638
like
public Matrix like(int rows, int columns)
{    return new DenseMatrix(rows, columns);}
c733fce42980b3396a3426c0cfb05355954939da4f722c3d81ab2555e6bd9282
setQuick
public void setQuick(int row, int column, double value)
{    throw new UnsupportedOperationException("Default operation");}
242adb7156cbde039fd67ab8f5ed8c9c46c199c38c6f12d05d2dbaffd8178820
viewPart
public Matrix viewPart(int[] offset, int[] size)
{    throw new UnsupportedOperationException("Default operation");}
f0fb6af329dbe4253b3cec22809510a330a145a78b041dee7093402707e196bc
setData
public void setData(File f) throws IOException
{    List<ByteBuffer> buffers = Lists.newArrayList();    FileChannel input = new FileInputStream(f).getChannel();    buffers.add(input.map(FileChannel.MapMode.READ_ONLY, 0, Math.min(Integer.MAX_VALUE, f.length())));    data.add(buffers.get(0).asIntBuffer());    Preconditions.checkArgument(buffers.get(0).getInt() == MAGIC_NUMBER_V0, "Wrong type of file");    int rows = buffers.get(0).getInt();    int cols = buffers.get(0).getInt();    Preconditions.checkArgument(rows == rowSize());    Preconditions.checkArgument(cols == columnSize());    rowOffset = new int[rows];    rowSize = new int[rows];    bufferIndex = new int[rows];    int offset = 12 + 4 * rows;    for (int i = 0; i < rows; i++) {        int size = buffers.get(0).getInt();        int buffer = 0;        while (buffer < buffers.size()) {            if (offset + size * 4 <= buffers.get(buffer).limit()) {                break;            } else {                offset -= buffers.get(buffer).capacity();            }        }        if (buffer == buffers.size()) {            buffers.add(input.map(FileChannel.MapMode.READ_ONLY, 0, Math.min(Integer.MAX_VALUE, f.length() - offset)));            data.add(buffers.get(buffer).asIntBuffer());        }        rowOffset[i] = offset / 4;        rowSize[i] = size;        bufferIndex[i] = buffer;                        offset += size * 4;    }}
51486d16c7d5406ddb6b5f6d19041207eebaa0863b98d2d79d5637c7ff988904
writeMatrix
public static void writeMatrix(File f, Matrix m) throws IOException
{    Preconditions.checkArgument(f.canWrite(), "Can't write to output file");    FileOutputStream fos = new FileOutputStream(f);        DataOutputStream out = new DataOutputStream(fos);    out.writeInt(MAGIC_NUMBER_V0);    out.writeInt(m.rowSize());    out.writeInt(m.columnSize());        for (MatrixSlice row : m) {        int nondefaultElements = row.vector().getNumNondefaultElements();        out.writeInt(nondefaultElements);    }        for (MatrixSlice row : m) {        List<Integer> columns = Lists.newArrayList(Iterables.transform(row.vector().nonZeroes(), new Function<Vector.Element, Integer>() {            @Override            public Integer apply(Vector.Element element) {                return element.index();            }        }));        Collections.sort(columns);        for (Integer column : columns) {            out.writeInt(column);        }    }    out.close();    fos.close();}
93c16777129da8b7e7e8175f70656d8c603c8f026b95c0bd52050fad501b1604
apply
public Integer apply(Vector.Element element)
{    return element.index();}
2d445c7af662ad5641bd7c216b4e7684a9cdab361f239540c55a18b81c86443c
assignColumn
public Matrix assignColumn(int column, Vector other)
{    throw new UnsupportedOperationException("Default operation");}
95687ef4453f7375a5854c6fa51b38f6963e77319dd3f4176496189e5fd67c55
assignRow
public Matrix assignRow(int row, Vector other)
{    throw new UnsupportedOperationException("Default operation");}
17c425c1ab89bc1b34471b96057d5bd40a9a88b1cc00663444d8c414b306a990
getQuick
public double getQuick(int rowIndex, int columnIndex)
{    IntBuffer tmp = data.get(bufferIndex[rowIndex]).asReadOnlyBuffer();    tmp.position(rowOffset[rowIndex]);    tmp.limit(rowSize[rowIndex]);    tmp = tmp.slice();    return searchForIndex(tmp, columnIndex);}
c40b4f582f3792ead8203d14841bec559ef670db2664499b896ebc99a82c5853
searchForIndex
private static double searchForIndex(IntBuffer row, int columnIndex)
{    int high = row.limit();    if (high == 0) {        return 0;    }    int low = 0;    while (high > low) {        int mid = (low + high) / 2;        if (row.get(mid) < columnIndex) {            low = mid + 1;        } else {            high = mid;        }    }    if (low >= row.limit()) {        return 0;    } else if (high == low && row.get(low) == columnIndex) {        return 1;    } else {        return 0;    }}
8ea1ca8bbfed9d923bb33b6722a3491db09837bb6812b8b8778bf2422064e0ab
like
public Matrix like()
{    throw new UnsupportedOperationException("Default operation");}
f88fece6b0c6401785f452c13d8cce7ea1dc13011ee8686b08685d42b6f32638
like
public Matrix like(int rows, int columns)
{    return new DenseMatrix(rows, columns);}
c733fce42980b3396a3426c0cfb05355954939da4f722c3d81ab2555e6bd9282
setQuick
public void setQuick(int row, int column, double value)
{    throw new UnsupportedOperationException("Default operation");}
242adb7156cbde039fd67ab8f5ed8c9c46c199c38c6f12d05d2dbaffd8178820
viewPart
public Matrix viewPart(int[] offset, int[] size)
{    throw new UnsupportedOperationException("Default operation");}
49d54b19859145aca1a672608cef7c4c1bd9e1659ec0bcdfc80f5cebcc258034
viewRow
public Vector viewRow(int rowIndex)
{    IntBuffer tmp = data.get(bufferIndex[rowIndex]).asReadOnlyBuffer();    tmp.position(rowOffset[rowIndex]);    tmp.limit(rowOffset[rowIndex] + rowSize[rowIndex]);    tmp = tmp.slice();    return new SparseBinaryVector(tmp, columnSize());}
39aa63eded95450eed8ae8438d97998d3316f664b548900552f7ffb6b0441d94
matrixLike
protected Matrix matrixLike(int rows, int columns)
{    throw new UnsupportedOperationException("Default operation");}
0f2cea51f07acae4d2eb073f5151beaf6dba8920eaf21ed6212f67553909727d
mergeUpdates
public void mergeUpdates(OrderedIntDoubleMapping updates)
{    throw new UnsupportedOperationException("Cannot mutate SparseBinaryVector");}
383032e836ae8e377e669da8e774cd6f6410cb106bd66015b484c883dc1c467c
isDense
public boolean isDense()
{    return false;}
048fcadf359a37696af85547983c8e1a90a6c62d53a2f5c66ba6b94ae1c5b98c
isSequentialAccess
public boolean isSequentialAccess()
{    return true;}
ebaf88b6206d3b34b79e1287ba43a83a7321437a7f6da5136b43af17bd0a0476
iterator
public Iterator<Element> iterator()
{    return new AbstractIterator<Element>() {        int i = 0;        @Override        protected Element computeNext() {            if (i < maxIndex) {                return new Element() {                    int index = i++;                    /**                     * @return the value of this vector element.                     */                    @Override                    public double get() {                        return getQuick(index);                    }                    /**                     * @return the index of this vector element.                     */                    @Override                    public int index() {                        return index;                    }                    /**                     * @param value Set the current element to value.                     */                    @Override                    public void set(double value) {                        throw new UnsupportedOperationException("Default operation");                    }                };            } else {                return endOfData();            }        }    };}
805efeafbd5a8971b9858a258536df263d73a6d5b733043fdf392af2c4e52cbc
computeNext
protected Element computeNext()
{    if (i < maxIndex) {        return new Element() {            int index = i++;            /**             * @return the value of this vector element.             */            @Override            public double get() {                return getQuick(index);            }            /**             * @return the index of this vector element.             */            @Override            public int index() {                return index;            }            /**             * @param value Set the current element to value.             */            @Override            public void set(double value) {                throw new UnsupportedOperationException("Default operation");            }        };    } else {        return endOfData();    }}
6f9021560b40d5f0ea4687dcfc9163f88e04e559e2fc0af5f9a1fed73b4e4c24
get
public double get()
{    return getQuick(index);}
5dd366da2313537c415c3c2ab9ed1909d1250d894a032bd02373d113516571d0
index
public int index()
{    return index;}
0ca3b3a320922927ea9a06f3def94b995d23a5eb7b95de57c7935a827c79759c
set
public void set(double value)
{    throw new UnsupportedOperationException("Default operation");}
0494c3c5bbf01f97ae3671ecd67c5586bc95bd0aa1907bd0e3ebdc94d70e1683
iterateNonZero
public Iterator<Element> iterateNonZero()
{    return new AbstractIterator<Element>() {        int i = 0;        @Override        protected Element computeNext() {            if (i < buffer.limit()) {                return new BinaryReadOnlyElement(buffer.get(i++));            } else {                return endOfData();            }        }    };}
805efeafbd5a8971b9858a258536df263d73a6d5b733043fdf392af2c4e52cbc
computeNext
protected Element computeNext()
{    if (i < buffer.limit()) {        return new BinaryReadOnlyElement(buffer.get(i++));    } else {        return endOfData();    }}
2263144cad9c9fdd2eecb03c9f0c31fc79e73b974408c87f743169e8bea1c8f3
getQuick
public double getQuick(int index)
{    return searchForIndex(buffer, index);}
3f06e4bc1bde206fe6ac26b2e2c12970bc557eee7de0d8e8394b1f96568db34b
like
public Vector like()
{    return new RandomAccessSparseVector(size());}
de7fe3d006f2cc6fa563e7089bbae0e5300ec5b2f82e856c1118dd26a5798a5f
like
public Vector like(int cardinality)
{    return new RandomAccessSparseVector(cardinality);}
7ee9fb0fa40acb3a34d5a0be54445ff662d333df0a26cf31da157bf82d75c4de
createOptimizedCopy
protected Vector createOptimizedCopy()
{    return new RandomAccessSparseVector(size()).assign(this);}
d90a04e96781b1eebeec5aca2a7d384a466650ea31ec4abd55dff982b7d2e12d
setQuick
public void setQuick(int index, double value)
{    throw new UnsupportedOperationException("Read-only view");}
c8a20d62d9c3255d60b3b80ebe6816bd042c01abf073d860c31aa2f68df390bf
incrementQuick
public void incrementQuick(int index, double increment)
{    throw new UnsupportedOperationException("Read-only view");}
f6c83ebe319a78b7975eba92f536cfcf2e5e6786960fb07f54a0c99258711da5
getNumNondefaultElements
public int getNumNondefaultElements()
{    return buffer.limit();}
6b67fad6dd27aa2525cafe6cf3396d2225fbcdf57e5378ac7a3dee60e61f20e8
getLookupCost
public double getLookupCost()
{    return 1;}
c79b5203142f65c96c29c2652557bad0bda511dfe38011e3b2877dd681f7c9cf
getIteratorAdvanceCost
public double getIteratorAdvanceCost()
{    return 1;}
c5fbf138e094d3027905103c89bbab4aa48cd369c50dde054752fd31aa322767
isAddConstantTime
public boolean isAddConstantTime()
{    throw new UnsupportedOperationException("Can't add binary value");}
6f9021560b40d5f0ea4687dcfc9163f88e04e559e2fc0af5f9a1fed73b4e4c24
get
public double get()
{    return 1;}
5dd366da2313537c415c3c2ab9ed1909d1250d894a032bd02373d113516571d0
index
public int index()
{    return index;}
0ca3b3a320922927ea9a06f3def94b995d23a5eb7b95de57c7935a827c79759c
set
public void set(double value)
{    throw new UnsupportedOperationException("Can't set binary value");}
e3071d82042033518c2f58ca4cb34bf4ea1a9aee1d22f2d857f0fc32b75070be
getBacking
public BackEnum getBacking()
{    return pBacking;}
c4bfc9c2448d43b2b2c55f7c5653a5013e068b32ee45f691e04b29caffe5c369
getStructure
public TraversingStructureEnum getStructure()
{    return pStructure;}
383032e836ae8e377e669da8e774cd6f6410cb106bd66015b484c883dc1c467c
isDense
public boolean isDense()
{    return pDense;}
a1ad6499e0c57ff44a878a8448bbfcce32d6707cd58f70604168d6389ebbf80d
isLikeRightPlus
public boolean isLikeRightPlus()
{    return false;}
362ebc0c9817637c79f9672f5db733a138c9486b10976a517e6fb74b01425a96
isLikeLeftMult
public boolean isLikeLeftMult()
{    return false;}
3c7e87c20a57090c5015732c28ff4ba1d3ad3d588fe9c451f36aadac2e416d11
isLikeRightMult
public boolean isLikeRightMult()
{    return false;}
16923cfdd4701f8553a994260ad4cee50dc46f1de65ddaec9243cb022c7fe2e7
isLikeMult
public boolean isLikeMult()
{    return isLikeLeftMult() && isLikeRightMult();}
cdd95de8ceb4c4ec4da87111cba55b6372bc588afb89d4c0d6b704643cfdabf0
isCommutative
public boolean isCommutative()
{    return false;}
104c739de29f8d1f9528bf70d1ca7c01fb3f4f7c8d35666e6761bf4bbd7c03c6
isAssociative
public boolean isAssociative()
{    return false;}
49e404f75809ffbc18d90f6b730213f2646a95b8c8f0fbcd5d34e00346877ee0
isAssociativeAndCommutative
public boolean isAssociativeAndCommutative()
{    return isAssociative() && isCommutative();}
a3b3316eff176cf1a48160d04cb439e744be08525e1e9ce8d26198710c2a3bcb
isDensifying
public boolean isDensifying()
{    return apply(0.0, 0.0) != 0.0;}
a3b3316eff176cf1a48160d04cb439e744be08525e1e9ce8d26198710c2a3bcb
isDensifying
public boolean isDensifying()
{    return Math.abs(apply(0.0)) != 0.0;}
0426958ab7f9d1bece37efafb3c82e5f88f7051a6b862ca3b99fe22cdbaa8deb
apply
public double apply(double a)
{    return Math.abs(a);}
0426958ab7f9d1bece37efafb3c82e5f88f7051a6b862ca3b99fe22cdbaa8deb
apply
public double apply(double a)
{    return Math.acos(a);}
0426958ab7f9d1bece37efafb3c82e5f88f7051a6b862ca3b99fe22cdbaa8deb
apply
public double apply(double a)
{    return Math.asin(a);}
0426958ab7f9d1bece37efafb3c82e5f88f7051a6b862ca3b99fe22cdbaa8deb
apply
public double apply(double a)
{    return Math.atan(a);}
0426958ab7f9d1bece37efafb3c82e5f88f7051a6b862ca3b99fe22cdbaa8deb
apply
public double apply(double a)
{    return Math.ceil(a);}
0426958ab7f9d1bece37efafb3c82e5f88f7051a6b862ca3b99fe22cdbaa8deb
apply
public double apply(double a)
{    return Math.cos(a);}
0426958ab7f9d1bece37efafb3c82e5f88f7051a6b862ca3b99fe22cdbaa8deb
apply
public double apply(double a)
{    return Math.exp(a);}
0426958ab7f9d1bece37efafb3c82e5f88f7051a6b862ca3b99fe22cdbaa8deb
apply
public double apply(double a)
{    return Math.floor(a);}
0426958ab7f9d1bece37efafb3c82e5f88f7051a6b862ca3b99fe22cdbaa8deb
apply
public double apply(double a)
{    return a;}
0426958ab7f9d1bece37efafb3c82e5f88f7051a6b862ca3b99fe22cdbaa8deb
apply
public double apply(double a)
{    return 1.0 / a;}
0426958ab7f9d1bece37efafb3c82e5f88f7051a6b862ca3b99fe22cdbaa8deb
apply
public double apply(double a)
{    return Math.log(a);}
0426958ab7f9d1bece37efafb3c82e5f88f7051a6b862ca3b99fe22cdbaa8deb
apply
public double apply(double a)
{    return Math.log(a) * 1.4426950408889634;}
0426958ab7f9d1bece37efafb3c82e5f88f7051a6b862ca3b99fe22cdbaa8deb
apply
public double apply(double a)
{    return -a;}
0426958ab7f9d1bece37efafb3c82e5f88f7051a6b862ca3b99fe22cdbaa8deb
apply
public double apply(double a)
{    return Math.rint(a);}
0426958ab7f9d1bece37efafb3c82e5f88f7051a6b862ca3b99fe22cdbaa8deb
apply
public double apply(double a)
{    return a < 0 ? -1 : a > 0 ? 1 : 0;}
0426958ab7f9d1bece37efafb3c82e5f88f7051a6b862ca3b99fe22cdbaa8deb
apply
public double apply(double a)
{    return Math.sin(a);}
0426958ab7f9d1bece37efafb3c82e5f88f7051a6b862ca3b99fe22cdbaa8deb
apply
public double apply(double a)
{    return Math.sqrt(a);}
0426958ab7f9d1bece37efafb3c82e5f88f7051a6b862ca3b99fe22cdbaa8deb
apply
public double apply(double a)
{    return a * a;}
0426958ab7f9d1bece37efafb3c82e5f88f7051a6b862ca3b99fe22cdbaa8deb
apply
public double apply(double a)
{    return 1.0 / (1.0 + Math.exp(-a));}
0426958ab7f9d1bece37efafb3c82e5f88f7051a6b862ca3b99fe22cdbaa8deb
apply
public double apply(double a)
{    return a * (1.0 - a);}
0426958ab7f9d1bece37efafb3c82e5f88f7051a6b862ca3b99fe22cdbaa8deb
apply
public double apply(double a)
{    return Math.tan(a);}
c78669e898ca91a9ec9891f1c6c596a955166abcd2f097eec3c17affd11f3c66
apply
public double apply(double a, double b)
{    return Math.atan2(a, b);}
c78669e898ca91a9ec9891f1c6c596a955166abcd2f097eec3c17affd11f3c66
apply
public double apply(double a, double b)
{    return a < b ? -1 : a > b ? 1 : 0;}
c78669e898ca91a9ec9891f1c6c596a955166abcd2f097eec3c17affd11f3c66
apply
public double apply(double a, double b)
{    return a / b;}
a1ad6499e0c57ff44a878a8448bbfcce32d6707cd58f70604168d6389ebbf80d
isLikeRightPlus
public boolean isLikeRightPlus()
{    return false;}
362ebc0c9817637c79f9672f5db733a138c9486b10976a517e6fb74b01425a96
isLikeLeftMult
public boolean isLikeLeftMult()
{    return false;}
3c7e87c20a57090c5015732c28ff4ba1d3ad3d588fe9c451f36aadac2e416d11
isLikeRightMult
public boolean isLikeRightMult()
{    return false;}
cdd95de8ceb4c4ec4da87111cba55b6372bc588afb89d4c0d6b704643cfdabf0
isCommutative
public boolean isCommutative()
{    return false;}
104c739de29f8d1f9528bf70d1ca7c01fb3f4f7c8d35666e6761bf4bbd7c03c6
isAssociative
public boolean isAssociative()
{    return false;}
c78669e898ca91a9ec9891f1c6c596a955166abcd2f097eec3c17affd11f3c66
apply
public double apply(double a, double b)
{    return a == b ? 1 : 0;}
cdd95de8ceb4c4ec4da87111cba55b6372bc588afb89d4c0d6b704643cfdabf0
isCommutative
public boolean isCommutative()
{    return true;}
c78669e898ca91a9ec9891f1c6c596a955166abcd2f097eec3c17affd11f3c66
apply
public double apply(double a, double b)
{    return a > b ? 1 : 0;}
c78669e898ca91a9ec9891f1c6c596a955166abcd2f097eec3c17affd11f3c66
apply
public double apply(double a, double b)
{    return Math.IEEEremainder(a, b);}
5b0e76c090c075ffd877082aaffbe81903c9e72f0b327b6c732c3957f1af106a
apply
public boolean apply(double a, double b)
{    return a == b;}
5b0e76c090c075ffd877082aaffbe81903c9e72f0b327b6c732c3957f1af106a
apply
public boolean apply(double a, double b)
{    return a < b;}
5b0e76c090c075ffd877082aaffbe81903c9e72f0b327b6c732c3957f1af106a
apply
public boolean apply(double a, double b)
{    return a > b;}
c78669e898ca91a9ec9891f1c6c596a955166abcd2f097eec3c17affd11f3c66
apply
public double apply(double a, double b)
{    return a < b ? 1 : 0;}
c78669e898ca91a9ec9891f1c6c596a955166abcd2f097eec3c17affd11f3c66
apply
public double apply(double a, double b)
{    return Math.log(a) / Math.log(b);}
c78669e898ca91a9ec9891f1c6c596a955166abcd2f097eec3c17affd11f3c66
apply
public double apply(double a, double b)
{    return Math.max(a, b);}
a1ad6499e0c57ff44a878a8448bbfcce32d6707cd58f70604168d6389ebbf80d
isLikeRightPlus
public boolean isLikeRightPlus()
{    return false;}
362ebc0c9817637c79f9672f5db733a138c9486b10976a517e6fb74b01425a96
isLikeLeftMult
public boolean isLikeLeftMult()
{    return false;}
3c7e87c20a57090c5015732c28ff4ba1d3ad3d588fe9c451f36aadac2e416d11
isLikeRightMult
public boolean isLikeRightMult()
{    return false;}
104c739de29f8d1f9528bf70d1ca7c01fb3f4f7c8d35666e6761bf4bbd7c03c6
isAssociative
public boolean isAssociative()
{    return true;}
cdd95de8ceb4c4ec4da87111cba55b6372bc588afb89d4c0d6b704643cfdabf0
isCommutative
public boolean isCommutative()
{    return true;}
c78669e898ca91a9ec9891f1c6c596a955166abcd2f097eec3c17affd11f3c66
apply
public double apply(double a, double b)
{    return Math.max(Math.abs(a), Math.abs(b));}
a1ad6499e0c57ff44a878a8448bbfcce32d6707cd58f70604168d6389ebbf80d
isLikeRightPlus
public boolean isLikeRightPlus()
{    return true;}
362ebc0c9817637c79f9672f5db733a138c9486b10976a517e6fb74b01425a96
isLikeLeftMult
public boolean isLikeLeftMult()
{    return false;}
3c7e87c20a57090c5015732c28ff4ba1d3ad3d588fe9c451f36aadac2e416d11
isLikeRightMult
public boolean isLikeRightMult()
{    return false;}
104c739de29f8d1f9528bf70d1ca7c01fb3f4f7c8d35666e6761bf4bbd7c03c6
isAssociative
public boolean isAssociative()
{    return true;}
cdd95de8ceb4c4ec4da87111cba55b6372bc588afb89d4c0d6b704643cfdabf0
isCommutative
public boolean isCommutative()
{    return true;}
c78669e898ca91a9ec9891f1c6c596a955166abcd2f097eec3c17affd11f3c66
apply
public double apply(double a, double b)
{    return Math.min(a, b);}
a1ad6499e0c57ff44a878a8448bbfcce32d6707cd58f70604168d6389ebbf80d
isLikeRightPlus
public boolean isLikeRightPlus()
{    return false;}
362ebc0c9817637c79f9672f5db733a138c9486b10976a517e6fb74b01425a96
isLikeLeftMult
public boolean isLikeLeftMult()
{    return false;}
3c7e87c20a57090c5015732c28ff4ba1d3ad3d588fe9c451f36aadac2e416d11
isLikeRightMult
public boolean isLikeRightMult()
{    return false;}
104c739de29f8d1f9528bf70d1ca7c01fb3f4f7c8d35666e6761bf4bbd7c03c6
isAssociative
public boolean isAssociative()
{    return true;}
cdd95de8ceb4c4ec4da87111cba55b6372bc588afb89d4c0d6b704643cfdabf0
isCommutative
public boolean isCommutative()
{    return true;}
dd57b1c2ae568f382da7388b79a15acd106539fea0bbe7635354ee8cd9bbb220
apply
public double apply(double x, double y)
{    return (x - y) * (x - y);}
a1ad6499e0c57ff44a878a8448bbfcce32d6707cd58f70604168d6389ebbf80d
isLikeRightPlus
public boolean isLikeRightPlus()
{    return false;}
362ebc0c9817637c79f9672f5db733a138c9486b10976a517e6fb74b01425a96
isLikeLeftMult
public boolean isLikeLeftMult()
{    return false;}
3c7e87c20a57090c5015732c28ff4ba1d3ad3d588fe9c451f36aadac2e416d11
isLikeRightMult
public boolean isLikeRightMult()
{    return false;}
cdd95de8ceb4c4ec4da87111cba55b6372bc588afb89d4c0d6b704643cfdabf0
isCommutative
public boolean isCommutative()
{    return true;}
104c739de29f8d1f9528bf70d1ca7c01fb3f4f7c8d35666e6761bf4bbd7c03c6
isAssociative
public boolean isAssociative()
{    return false;}
c78669e898ca91a9ec9891f1c6c596a955166abcd2f097eec3c17affd11f3c66
apply
public double apply(double a, double b)
{    return a % b;}
c78669e898ca91a9ec9891f1c6c596a955166abcd2f097eec3c17affd11f3c66
apply
public double apply(double a, double b)
{    return Math.abs(a) + Math.abs(b);}
a1ad6499e0c57ff44a878a8448bbfcce32d6707cd58f70604168d6389ebbf80d
isLikeRightPlus
public boolean isLikeRightPlus()
{    return false;}
362ebc0c9817637c79f9672f5db733a138c9486b10976a517e6fb74b01425a96
isLikeLeftMult
public boolean isLikeLeftMult()
{    return false;}
3c7e87c20a57090c5015732c28ff4ba1d3ad3d588fe9c451f36aadac2e416d11
isLikeRightMult
public boolean isLikeRightMult()
{    return false;}
104c739de29f8d1f9528bf70d1ca7c01fb3f4f7c8d35666e6761bf4bbd7c03c6
isAssociative
public boolean isAssociative()
{    return true;}
cdd95de8ceb4c4ec4da87111cba55b6372bc588afb89d4c0d6b704643cfdabf0
isCommutative
public boolean isCommutative()
{    return true;}
dd57b1c2ae568f382da7388b79a15acd106539fea0bbe7635354ee8cd9bbb220
apply
public double apply(double x, double y)
{    return Math.abs(x - y);}
a1ad6499e0c57ff44a878a8448bbfcce32d6707cd58f70604168d6389ebbf80d
isLikeRightPlus
public boolean isLikeRightPlus()
{    return false;}
362ebc0c9817637c79f9672f5db733a138c9486b10976a517e6fb74b01425a96
isLikeLeftMult
public boolean isLikeLeftMult()
{    return false;}
3c7e87c20a57090c5015732c28ff4ba1d3ad3d588fe9c451f36aadac2e416d11
isLikeRightMult
public boolean isLikeRightMult()
{    return false;}
cdd95de8ceb4c4ec4da87111cba55b6372bc588afb89d4c0d6b704643cfdabf0
isCommutative
public boolean isCommutative()
{    return true;}
104c739de29f8d1f9528bf70d1ca7c01fb3f4f7c8d35666e6761bf4bbd7c03c6
isAssociative
public boolean isAssociative()
{    return false;}
c78669e898ca91a9ec9891f1c6c596a955166abcd2f097eec3c17affd11f3c66
apply
public double apply(double a, double b)
{    return Math.pow(a, b);}
a1ad6499e0c57ff44a878a8448bbfcce32d6707cd58f70604168d6389ebbf80d
isLikeRightPlus
public boolean isLikeRightPlus()
{    return false;}
362ebc0c9817637c79f9672f5db733a138c9486b10976a517e6fb74b01425a96
isLikeLeftMult
public boolean isLikeLeftMult()
{    return false;}
3c7e87c20a57090c5015732c28ff4ba1d3ad3d588fe9c451f36aadac2e416d11
isLikeRightMult
public boolean isLikeRightMult()
{    return false;}
cdd95de8ceb4c4ec4da87111cba55b6372bc588afb89d4c0d6b704643cfdabf0
isCommutative
public boolean isCommutative()
{    return false;}
104c739de29f8d1f9528bf70d1ca7c01fb3f4f7c8d35666e6761bf4bbd7c03c6
isAssociative
public boolean isAssociative()
{    return false;}
dd57b1c2ae568f382da7388b79a15acd106539fea0bbe7635354ee8cd9bbb220
apply
public double apply(double x, double y)
{    return y;}
a1ad6499e0c57ff44a878a8448bbfcce32d6707cd58f70604168d6389ebbf80d
isLikeRightPlus
public boolean isLikeRightPlus()
{    return false;}
362ebc0c9817637c79f9672f5db733a138c9486b10976a517e6fb74b01425a96
isLikeLeftMult
public boolean isLikeLeftMult()
{    return false;}
3c7e87c20a57090c5015732c28ff4ba1d3ad3d588fe9c451f36aadac2e416d11
isLikeRightMult
public boolean isLikeRightMult()
{    return true;}
cdd95de8ceb4c4ec4da87111cba55b6372bc588afb89d4c0d6b704643cfdabf0
isCommutative
public boolean isCommutative()
{    return false;}
104c739de29f8d1f9528bf70d1ca7c01fb3f4f7c8d35666e6761bf4bbd7c03c6
isAssociative
public boolean isAssociative()
{    return true;}
dd57b1c2ae568f382da7388b79a15acd106539fea0bbe7635354ee8cd9bbb220
apply
public double apply(double x, double y)
{    Preconditions.checkArgument(x == 0, "This special version of SECOND needs x == 0");    return y;}
a1ad6499e0c57ff44a878a8448bbfcce32d6707cd58f70604168d6389ebbf80d
isLikeRightPlus
public boolean isLikeRightPlus()
{    return true;}
362ebc0c9817637c79f9672f5db733a138c9486b10976a517e6fb74b01425a96
isLikeLeftMult
public boolean isLikeLeftMult()
{    return false;}
3c7e87c20a57090c5015732c28ff4ba1d3ad3d588fe9c451f36aadac2e416d11
isLikeRightMult
public boolean isLikeRightMult()
{    return true;}
cdd95de8ceb4c4ec4da87111cba55b6372bc588afb89d4c0d6b704643cfdabf0
isCommutative
public boolean isCommutative()
{    return false;}
104c739de29f8d1f9528bf70d1ca7c01fb3f4f7c8d35666e6761bf4bbd7c03c6
isAssociative
public boolean isAssociative()
{    return true;}
dd57b1c2ae568f382da7388b79a15acd106539fea0bbe7635354ee8cd9bbb220
apply
public double apply(double x, double y)
{    return x * x * y;}
a1ad6499e0c57ff44a878a8448bbfcce32d6707cd58f70604168d6389ebbf80d
isLikeRightPlus
public boolean isLikeRightPlus()
{    return false;}
362ebc0c9817637c79f9672f5db733a138c9486b10976a517e6fb74b01425a96
isLikeLeftMult
public boolean isLikeLeftMult()
{    return true;}
3c7e87c20a57090c5015732c28ff4ba1d3ad3d588fe9c451f36aadac2e416d11
isLikeRightMult
public boolean isLikeRightMult()
{    return true;}
cdd95de8ceb4c4ec4da87111cba55b6372bc588afb89d4c0d6b704643cfdabf0
isCommutative
public boolean isCommutative()
{    return false;}
104c739de29f8d1f9528bf70d1ca7c01fb3f4f7c8d35666e6761bf4bbd7c03c6
isAssociative
public boolean isAssociative()
{    return false;}
dd57b1c2ae568f382da7388b79a15acd106539fea0bbe7635354ee8cd9bbb220
apply
public double apply(double x, double y)
{    return x * (y + 1);}
a1ad6499e0c57ff44a878a8448bbfcce32d6707cd58f70604168d6389ebbf80d
isLikeRightPlus
public boolean isLikeRightPlus()
{    return true;}
362ebc0c9817637c79f9672f5db733a138c9486b10976a517e6fb74b01425a96
isLikeLeftMult
public boolean isLikeLeftMult()
{    return true;}
3c7e87c20a57090c5015732c28ff4ba1d3ad3d588fe9c451f36aadac2e416d11
isLikeRightMult
public boolean isLikeRightMult()
{    return false;}
cdd95de8ceb4c4ec4da87111cba55b6372bc588afb89d4c0d6b704643cfdabf0
isCommutative
public boolean isCommutative()
{    return false;}
104c739de29f8d1f9528bf70d1ca7c01fb3f4f7c8d35666e6761bf4bbd7c03c6
isAssociative
public boolean isAssociative()
{    return false;}
8dd98defff7b7d589ce890ff4da71d98f08d4210e79c0c7e0fa6a93bbbbbb670
reweigh
public static DoubleDoubleFunction reweigh(final double wx, final double wy)
{    final double tw = wx + wy;    return new DoubleDoubleFunction() {        @Override        public double apply(double x, double y) {            return (wx * x + wy * y) / tw;        }        /**         * f(x, 0) = wx * x / tw = x iff wx = tw (practically, impossible, as tw = wx + wy and wy > 0)         * @return true iff f(x, 0) = x for any x         */        @Override        public boolean isLikeRightPlus() {            return wx == tw;        }        /**         * f(0, y) = wy * y / tw = 0 iff y = 0         * @return true iff f(0, y) = 0 for any y         */        @Override        public boolean isLikeLeftMult() {            return false;        }        /**         * f(x, 0) = wx * x / tw = 0 iff x = 0         * @return true iff f(x, 0) = 0 for any x         */        @Override        public boolean isLikeRightMult() {            return false;        }        /**         * wx * x + wy * y = wx * y + wy * x iff wx = wy         * @return true iff f(x, y) = f(y, x) for any x, y         */        @Override        public boolean isCommutative() {            return wx == wy;        }        /**         * @return true iff f(x, f(y, z)) = f(f(x, y), z) for any x, y, z         */        @Override        public boolean isAssociative() {            return false;        }    };}
dd57b1c2ae568f382da7388b79a15acd106539fea0bbe7635354ee8cd9bbb220
apply
public double apply(double x, double y)
{    return (wx * x + wy * y) / tw;}
a1ad6499e0c57ff44a878a8448bbfcce32d6707cd58f70604168d6389ebbf80d
isLikeRightPlus
public boolean isLikeRightPlus()
{    return wx == tw;}
362ebc0c9817637c79f9672f5db733a138c9486b10976a517e6fb74b01425a96
isLikeLeftMult
public boolean isLikeLeftMult()
{    return false;}
3c7e87c20a57090c5015732c28ff4ba1d3ad3d588fe9c451f36aadac2e416d11
isLikeRightMult
public boolean isLikeRightMult()
{    return false;}
cdd95de8ceb4c4ec4da87111cba55b6372bc588afb89d4c0d6b704643cfdabf0
isCommutative
public boolean isCommutative()
{    return wx == wy;}
104c739de29f8d1f9528bf70d1ca7c01fb3f4f7c8d35666e6761bf4bbd7c03c6
isAssociative
public boolean isAssociative()
{    return false;}
2410f1f8b13d1547dc55a86092872f00880d1a24b3c51946987249b76bce4aea
between
public static DoubleFunction between(final double from, final double to)
{    return new DoubleFunction() {        @Override        public double apply(double a) {            return from <= a && a <= to ? 1 : 0;        }    };}
0426958ab7f9d1bece37efafb3c82e5f88f7051a6b862ca3b99fe22cdbaa8deb
apply
public double apply(double a)
{    return from <= a && a <= to ? 1 : 0;}
b981cc7f4244cad158604e3338c5ccdb95f809c28269adf107ef5c7d7498a34e
bindArg1
public static DoubleFunction bindArg1(final DoubleDoubleFunction function, final double c)
{    return new DoubleFunction() {        @Override        public double apply(double var) {            return function.apply(c, var);        }    };}
0cc4519c8976304863826e1ab952e8a2ddb689bbc0ebf4122332c7bdb2f5efc4
apply
public double apply(double var)
{    return function.apply(c, var);}
e4ef4f16b52bad38238c0ac192943783f9f72cc114c5896ad01d594f43a8bde2
bindArg2
public static DoubleFunction bindArg2(final DoubleDoubleFunction function, final double c)
{    return new DoubleFunction() {        @Override        public double apply(double var) {            return function.apply(var, c);        }    };}
0cc4519c8976304863826e1ab952e8a2ddb689bbc0ebf4122332c7bdb2f5efc4
apply
public double apply(double var)
{    return function.apply(var, c);}
8f17184b0a5c1e133ccf07ac6baf0abec59ede3da6a15972b1a9aa4b8337ae0b
chain
public static DoubleDoubleFunction chain(final DoubleDoubleFunction f, final DoubleFunction g, final DoubleFunction h)
{    return new DoubleDoubleFunction() {        @Override        public double apply(double a, double b) {            return f.apply(g.apply(a), h.apply(b));        }        /**         * fx(c, 0) = f(g(x), h(0)) = f(g(x), 0) = g(x) = x if h(0) = 0 and f isLikeRightPlus and g(x) = x         * Impossible to check whether g(x) = x for any x, so we return false.         * @return true iff f(x, 0) = x for any x         */        @Override        public boolean isLikeRightPlus() {            return false;        }        /**         * fc(0, y) = f(g(0), h(y)) = f(0, h(y)) = 0 if g(0) = 0 and f isLikeLeftMult         * @return true iff f(0, y) = 0 for any y         */        @Override        public boolean isLikeLeftMult() {            return g.apply(0) == 0 && f.isLikeLeftMult();        }        /**         * fc(x, 0) = f(g(x), h(0)) = f(g(x), 0) = 0 if h(0) = 0 and f isLikeRightMult         * @return true iff f(x, 0) = 0 for any x         */        @Override        public boolean isLikeRightMult() {            return h.apply(0) == 0 && f.isLikeRightMult();        }        /**         * fc(x, y) = f(g(x), h(y)) = f(h(y), g(x))         * fc(y, x) = f(g(y), h(x)) = f(h(x), g(y))         * Either g(x) = g(y) for any x, y and h(x) = h(y) for any x, y or g = h and f isCommutative.         * Can only check if g = h (reference equality, assuming they're both the same static function in         * this file) and f isCommutative. There are however other scenarios when this might happen that are NOT         * covered by this definition.         * @return true iff f(x, y) = f(y, x) for any x, y         */        @Override        public boolean isCommutative() {            return g.equals(h) && f.isCommutative();        }        /**         * fc(x, fc(y, z)) = f(g(x), h(f(g(y), h(z))))         * fc(fc(x, y), z) = f(g(f(g(x), h(y))), h(z))         * Impossible to check.         * @return true iff f(x, f(y, z)) = f(f(x, y), z) for any x, y, z         */        @Override        public boolean isAssociative() {            return false;        }    };}
c78669e898ca91a9ec9891f1c6c596a955166abcd2f097eec3c17affd11f3c66
apply
public double apply(double a, double b)
{    return f.apply(g.apply(a), h.apply(b));}
a1ad6499e0c57ff44a878a8448bbfcce32d6707cd58f70604168d6389ebbf80d
isLikeRightPlus
public boolean isLikeRightPlus()
{    return false;}
362ebc0c9817637c79f9672f5db733a138c9486b10976a517e6fb74b01425a96
isLikeLeftMult
public boolean isLikeLeftMult()
{    return g.apply(0) == 0 && f.isLikeLeftMult();}
3c7e87c20a57090c5015732c28ff4ba1d3ad3d588fe9c451f36aadac2e416d11
isLikeRightMult
public boolean isLikeRightMult()
{    return h.apply(0) == 0 && f.isLikeRightMult();}
cdd95de8ceb4c4ec4da87111cba55b6372bc588afb89d4c0d6b704643cfdabf0
isCommutative
public boolean isCommutative()
{    return g.equals(h) && f.isCommutative();}
104c739de29f8d1f9528bf70d1ca7c01fb3f4f7c8d35666e6761bf4bbd7c03c6
isAssociative
public boolean isAssociative()
{    return false;}
1c2a7e951db1ed71aa40e26436993419bc7dad2eabfad95ea796863046d83e5b
chain
public static DoubleDoubleFunction chain(final DoubleFunction g, final DoubleDoubleFunction h)
{    return new DoubleDoubleFunction() {        @Override        public double apply(double a, double b) {            return g.apply(h.apply(a, b));        }        /**         * g(h(x, 0)) = g(x) = x for any x iff g(x) = x and h isLikeRightPlus         * Impossible to check.         * @return true iff f(x, 0) = x for any x         */        @Override        public boolean isLikeRightPlus() {            return false;        }        /**         * g(h(0, y)) = g(0) = 0 for any y iff g(0) = 0 and h isLikeLeftMult         * @return true iff f(0, y) = 0 for any y         */        @Override        public boolean isLikeLeftMult() {            return !g.isDensifying() && h.isLikeLeftMult();        }        /**         * g(h(x, 0)) = g(0) = 0 for any x iff g(0) = 0 and h isLikeRightMult         * @return true iff f(x, 0) = 0 for any x         */        @Override        public boolean isLikeRightMult() {            return !g.isDensifying() && h.isLikeRightMult();        }        /**         * fc(x, y) = g(h(x, y)) = g(h(y, x)) = fc(y, x) iff h isCommutative         * @return true iff f(x, y) = f(y, x) for any x, y         */        @Override        public boolean isCommutative() {            return h.isCommutative();        }        /**         * fc(x, fc(y, z)) = g(h(x, g(h(y, z)))         * fc(fc(x, y), z) = g(h(g(h(x, y)), z))         * Impossible to check.         * @return true iff f(x, f(y, z)) = f(f(x, y), z) for any x, y, z         */        @Override        public boolean isAssociative() {            return false;        }    };}
c78669e898ca91a9ec9891f1c6c596a955166abcd2f097eec3c17affd11f3c66
apply
public double apply(double a, double b)
{    return g.apply(h.apply(a, b));}
a1ad6499e0c57ff44a878a8448bbfcce32d6707cd58f70604168d6389ebbf80d
isLikeRightPlus
public boolean isLikeRightPlus()
{    return false;}
362ebc0c9817637c79f9672f5db733a138c9486b10976a517e6fb74b01425a96
isLikeLeftMult
public boolean isLikeLeftMult()
{    return !g.isDensifying() && h.isLikeLeftMult();}
3c7e87c20a57090c5015732c28ff4ba1d3ad3d588fe9c451f36aadac2e416d11
isLikeRightMult
public boolean isLikeRightMult()
{    return !g.isDensifying() && h.isLikeRightMult();}
cdd95de8ceb4c4ec4da87111cba55b6372bc588afb89d4c0d6b704643cfdabf0
isCommutative
public boolean isCommutative()
{    return h.isCommutative();}
104c739de29f8d1f9528bf70d1ca7c01fb3f4f7c8d35666e6761bf4bbd7c03c6
isAssociative
public boolean isAssociative()
{    return false;}
22f193739b5ccc29523e834676c382074c3775135101ee21682ee4cebdb04959
chain
public static DoubleFunction chain(final DoubleFunction g, final DoubleFunction h)
{    return new DoubleFunction() {        @Override        public double apply(double a) {            return g.apply(h.apply(a));        }    };}
0426958ab7f9d1bece37efafb3c82e5f88f7051a6b862ca3b99fe22cdbaa8deb
apply
public double apply(double a)
{    return g.apply(h.apply(a));}
b9c9b003cca7b64b42538d691769477408896ebb3036ae534cbb04cd305c7273
chain
public static IntIntFunction chain(final DoubleFunction g, final IntIntFunction h)
{    return new IntIntFunction() {        @Override        public double apply(int first, int second) {            return g.apply(h.apply(first, second));        }    };}
a97f178b457bb14a2d22443b1851744035fbd259aba9653f4f0ebfdbc6b5018d
apply
public double apply(int first, int second)
{    return g.apply(h.apply(first, second));}
dc24462c55549066d7cdb5f6e8152846afc49b4866028b2c4bdb42e7677f5b04
compare
public static DoubleFunction compare(final double b)
{    return new DoubleFunction() {        @Override        public double apply(double a) {            return a < b ? -1 : a > b ? 1 : 0;        }    };}
0426958ab7f9d1bece37efafb3c82e5f88f7051a6b862ca3b99fe22cdbaa8deb
apply
public double apply(double a)
{    return a < b ? -1 : a > b ? 1 : 0;}
0ecd4e1e113488b799afa3d48e1b18f67681bb6c8b21606ce51625e566ed8ef4
constant
public static DoubleFunction constant(final double c)
{    return new DoubleFunction() {        @Override        public double apply(double a) {            return c;        }    };}
0426958ab7f9d1bece37efafb3c82e5f88f7051a6b862ca3b99fe22cdbaa8deb
apply
public double apply(double a)
{    return c;}
f77566d7a88445547846acce32ce087bdef4b8d9df423ad52e5e26f0f8d118f6
div
public static DoubleFunction div(double b)
{    return mult(1 / b);}
baa5adbbac451df51d000c6d32bb3ad7e2bc9a4f3d548aa19ec87cc51bfae6d2
equals
public static DoubleFunction equals(final double b)
{    return new DoubleFunction() {        @Override        public double apply(double a) {            return a == b ? 1 : 0;        }    };}
0426958ab7f9d1bece37efafb3c82e5f88f7051a6b862ca3b99fe22cdbaa8deb
apply
public double apply(double a)
{    return a == b ? 1 : 0;}
9855123cad74b9234ba1964b8e9a1bd3e76911c504101c53f1927d4c0ace107c
notEqual
public static DoubleFunction notEqual(final double b)
{    return new DoubleFunction() {        @Override        public double apply(double a) {            return a != b ? 1 : 0;        }    };}
0426958ab7f9d1bece37efafb3c82e5f88f7051a6b862ca3b99fe22cdbaa8deb
apply
public double apply(double a)
{    return a != b ? 1 : 0;}
46b63a71d297c8426c663f5dbbf7ad59c1447aec334f515f4411cf436b38f4a6
greater
public static DoubleFunction greater(final double b)
{    return new DoubleFunction() {        @Override        public double apply(double a) {            return a > b ? 1 : 0;        }    };}
0426958ab7f9d1bece37efafb3c82e5f88f7051a6b862ca3b99fe22cdbaa8deb
apply
public double apply(double a)
{    return a > b ? 1 : 0;}
e3bbc41edfceda5c1977b36a7bb01c09e741cb1e2650465db51b8c6cd80e5500
mathIEEEremainder
public static DoubleFunction mathIEEEremainder(final double b)
{    return new DoubleFunction() {        @Override        public double apply(double a) {            return Math.IEEEremainder(a, b);        }    };}
0426958ab7f9d1bece37efafb3c82e5f88f7051a6b862ca3b99fe22cdbaa8deb
apply
public double apply(double a)
{    return Math.IEEEremainder(a, b);}
4991d185599a7ba4e304e256320a5dd307a5f3843a6dbeed397c292a4cbef433
isBetween
public static DoubleProcedure isBetween(final double from, final double to)
{    return new DoubleProcedure() {        @Override        public boolean apply(double a) {            return from <= a && a <= to;        }    };}
2e9727824b7f56ad7f6791e86994873f58d5926a8aadbccd362649e589fb67c7
apply
public boolean apply(double a)
{    return from <= a && a <= to;}
74a58a4246713a9df28cb84866324fde3340e11a783625462e9fd90810281bdb
isEqual
public static DoubleProcedure isEqual(final double b)
{    return new DoubleProcedure() {        @Override        public boolean apply(double a) {            return a == b;        }    };}
2e9727824b7f56ad7f6791e86994873f58d5926a8aadbccd362649e589fb67c7
apply
public boolean apply(double a)
{    return a == b;}
4812a1f594d7e7444655b2171bba9f24340883de5c0b9433ba6af071e50c19dd
isGreater
public static DoubleProcedure isGreater(final double b)
{    return new DoubleProcedure() {        @Override        public boolean apply(double a) {            return a > b;        }    };}
2e9727824b7f56ad7f6791e86994873f58d5926a8aadbccd362649e589fb67c7
apply
public boolean apply(double a)
{    return a > b;}
adc957f7460449c6430cecb1abb5449cf48f0331cb3c712674fa0580e2f43919
isLess
public static DoubleProcedure isLess(final double b)
{    return new DoubleProcedure() {        @Override        public boolean apply(double a) {            return a < b;        }    };}
2e9727824b7f56ad7f6791e86994873f58d5926a8aadbccd362649e589fb67c7
apply
public boolean apply(double a)
{    return a < b;}
e6185a315722afece2db252d7df7e5208777781c49648106f95763dab4b8e163
less
public static DoubleFunction less(final double b)
{    return new DoubleFunction() {        @Override        public double apply(double a) {            return a < b ? 1 : 0;        }    };}
0426958ab7f9d1bece37efafb3c82e5f88f7051a6b862ca3b99fe22cdbaa8deb
apply
public double apply(double a)
{    return a < b ? 1 : 0;}
d511794bd6a2b6fab12b465a3ae20804258ac466bf97815804c8e184e687678f
lg
public static DoubleFunction lg(final double b)
{    return new DoubleFunction() {                private final double logInv = 1 / Math.log(b);        @Override        public double apply(double a) {            return Math.log(a) * logInv;        }    };}
0426958ab7f9d1bece37efafb3c82e5f88f7051a6b862ca3b99fe22cdbaa8deb
apply
public double apply(double a)
{    return Math.log(a) * logInv;}
3be7ee076180a7891cf8ce79880032234d810b41dbf212882ab0ce7a5cd3da26
max
public static DoubleFunction max(final double b)
{    return new DoubleFunction() {        @Override        public double apply(double a) {            return Math.max(a, b);        }    };}
0426958ab7f9d1bece37efafb3c82e5f88f7051a6b862ca3b99fe22cdbaa8deb
apply
public double apply(double a)
{    return Math.max(a, b);}
0785b59ca5ccfa030f5d6b15c50167b0702663060a10d8da2c1576b5a09f071f
min
public static DoubleFunction min(final double b)
{    return new DoubleFunction() {        @Override        public double apply(double a) {            return Math.min(a, b);        }    };}
0426958ab7f9d1bece37efafb3c82e5f88f7051a6b862ca3b99fe22cdbaa8deb
apply
public double apply(double a)
{    return Math.min(a, b);}
e2067dddfe34572cef8d2c1b97112bac93b827598f4d958309a9b999aa229cbd
minus
public static DoubleFunction minus(double b)
{    return plus(-b);}
79782709200173783faba7aa16ce8abe2cb562f02c895a7991c3f8801d770917
minusMult
public static DoubleDoubleFunction minusMult(double constant)
{    return plusMult(-constant);}
fe940be2a0f9a6e1b8ac7f49c2d559ced16a53f905593bef40861c7cb47d7971
mod
public static DoubleFunction mod(final double b)
{    return new DoubleFunction() {        @Override        public double apply(double a) {            return a % b;        }    };}
0426958ab7f9d1bece37efafb3c82e5f88f7051a6b862ca3b99fe22cdbaa8deb
apply
public double apply(double a)
{    return a % b;}
f83fdf25c2daee47ab3dfc04888d2406218e70af0d5bc89a7016fc830ade25f1
mult
public static DoubleFunction mult(double b)
{    return new Mult(b);/*    return new DoubleFunction() {      public final double apply(double a) { return a * b; }    };    */}
ae6a3e33b08cf54b20b8061189e7610fbbd4ed71f47bca2f38e864e0488a3f7b
plus
public static DoubleFunction plus(final double b)
{    return new DoubleFunction() {        @Override        public double apply(double a) {            return a + b;        }    };}
0426958ab7f9d1bece37efafb3c82e5f88f7051a6b862ca3b99fe22cdbaa8deb
apply
public double apply(double a)
{    return a + b;}
b7ef8b65ede70d2ee9c5d2c4ba03d005cb003deecf7a075640ab573d39a0ce13
plusMult
public static DoubleDoubleFunction plusMult(double constant)
{    return new PlusMult(constant);}
47eacf941aa5214cd5cf8270698997f4a2d78aed49ea0993a68ca8cd9e8186b9
pow
public static DoubleFunction pow(final double b)
{    return new DoubleFunction() {        @Override        public double apply(double a) {            if (b == 2) {                return a * a;            } else {                return Math.pow(a, b);            }        }    };}
0426958ab7f9d1bece37efafb3c82e5f88f7051a6b862ca3b99fe22cdbaa8deb
apply
public double apply(double a)
{    if (b == 2) {        return a * a;    } else {        return Math.pow(a, b);    }}
d6cef161e50097f6e8213bb5509f7bc87ee09f45c415a84b142bf400e8ceeeaf
random
public static DoubleFunction random()
{    return new MersenneTwister(new Date());}
af422357a99af334de3f9277c309a4532b67d4853ffd5ce83f7bb81ca6f35f12
round
public static DoubleFunction round(final double precision)
{    return new DoubleFunction() {        @Override        public double apply(double a) {            return Math.rint(a / precision) * precision;        }    };}
0426958ab7f9d1bece37efafb3c82e5f88f7051a6b862ca3b99fe22cdbaa8deb
apply
public double apply(double a)
{    return Math.rint(a / precision) * precision;}
6a2e27add9a2a50890953c055a9d6b32178dec57b213c2f5880f324def9c707a
swapArgs
public static DoubleDoubleFunction swapArgs(final DoubleDoubleFunction function)
{    return new DoubleDoubleFunction() {        @Override        public double apply(double a, double b) {            return function.apply(b, a);        }    };}
c78669e898ca91a9ec9891f1c6c596a955166abcd2f097eec3c17affd11f3c66
apply
public double apply(double a, double b)
{    return function.apply(b, a);}
e38ecb8ff79e505ff568208eb266ce1b4da2cfb52e77db247e1a5725e5288a13
minusAbsPow
public static DoubleDoubleFunction minusAbsPow(final double exponent)
{    return new DoubleDoubleFunction() {        @Override        public double apply(double x, double y) {            return Math.pow(Math.abs(x - y), exponent);        }        /**         * |x - 0|^p = |x|^p != x unless x > 0 and p = 1         * @return true iff f(x, 0) = x for any x         */        @Override        public boolean isLikeRightPlus() {            return false;        }        /**         * |0 - y|^p = |y|^p         * @return true iff f(0, y) = 0 for any y         */        @Override        public boolean isLikeLeftMult() {            return false;        }        /**         * |x - 0|^p = |x|^p         * @return true iff f(x, 0) = 0 for any x         */        @Override        public boolean isLikeRightMult() {            return false;        }        /**         * |x - y|^p = |y - x|^p         * @return true iff f(x, y) = f(y, x) for any x, y         */        @Override        public boolean isCommutative() {            return true;        }        /**         * |x - |y - z|^p|^p != ||x - y|^p - z|^p         * @return true iff f(x, f(y, z)) = f(f(x, y), z) for any x, y, z         */        @Override        public boolean isAssociative() {            return false;        }    };}
dd57b1c2ae568f382da7388b79a15acd106539fea0bbe7635354ee8cd9bbb220
apply
public double apply(double x, double y)
{    return Math.pow(Math.abs(x - y), exponent);}
a1ad6499e0c57ff44a878a8448bbfcce32d6707cd58f70604168d6389ebbf80d
isLikeRightPlus
public boolean isLikeRightPlus()
{    return false;}
362ebc0c9817637c79f9672f5db733a138c9486b10976a517e6fb74b01425a96
isLikeLeftMult
public boolean isLikeLeftMult()
{    return false;}
3c7e87c20a57090c5015732c28ff4ba1d3ad3d588fe9c451f36aadac2e416d11
isLikeRightMult
public boolean isLikeRightMult()
{    return false;}
cdd95de8ceb4c4ec4da87111cba55b6372bc588afb89d4c0d6b704643cfdabf0
isCommutative
public boolean isCommutative()
{    return true;}
104c739de29f8d1f9528bf70d1ca7c01fb3f4f7c8d35666e6761bf4bbd7c03c6
isAssociative
public boolean isAssociative()
{    return false;}
0426958ab7f9d1bece37efafb3c82e5f88f7051a6b862ca3b99fe22cdbaa8deb
apply
public double apply(double a)
{    return a * multiplicator;}
e044e782a4b7dc7bc63510ce0416950ae708e8570d8031ff2e96e42c95ab9984
div
public static Mult div(double constant)
{    return mult(1 / constant);}
3199ccec75387de2fdef4471c2c98f27c10e900c88727e06dba8b1100a67ff39
mult
public static Mult mult(double constant)
{    return new Mult(constant);}
cd5fa5507f381086e6ae3e5340f7d815e477eaa2a082cfdd98b56c9e073f301e
getMultiplicator
public double getMultiplicator()
{    return multiplicator;}
1d5754e580095d49c82dda13e9340426eb7829205640af9088491f31ef6aa908
setMultiplicator
public void setMultiplicator(double multiplicator)
{    this.multiplicator = multiplicator;}
c78669e898ca91a9ec9891f1c6c596a955166abcd2f097eec3c17affd11f3c66
apply
public double apply(double a, double b)
{    return a + b * multiplicator;}
61bd3537117958fecf50cfbc7e7e293bc989710494be922eba5a9f970b385d7c
minusMult
public static PlusMult minusMult(double constant)
{    return new PlusMult(-constant);}
65bdb041bebc9ea5ec9bd4e08e78ebc55f31fb53a0f4c02d4fb0d7c5e7ff4d2d
plusMult
public static PlusMult plusMult(double constant)
{    return new PlusMult(constant);}
cd5fa5507f381086e6ae3e5340f7d815e477eaa2a082cfdd98b56c9e073f301e
getMultiplicator
public double getMultiplicator()
{    return multiplicator;}
a1ad6499e0c57ff44a878a8448bbfcce32d6707cd58f70604168d6389ebbf80d
isLikeRightPlus
public boolean isLikeRightPlus()
{    return true;}
362ebc0c9817637c79f9672f5db733a138c9486b10976a517e6fb74b01425a96
isLikeLeftMult
public boolean isLikeLeftMult()
{    return false;}
3c7e87c20a57090c5015732c28ff4ba1d3ad3d588fe9c451f36aadac2e416d11
isLikeRightMult
public boolean isLikeRightMult()
{    return false;}
cdd95de8ceb4c4ec4da87111cba55b6372bc588afb89d4c0d6b704643cfdabf0
isCommutative
public boolean isCommutative()
{    return Math.abs(multiplicator - 1.0) < Constants.EPSILON;}
104c739de29f8d1f9528bf70d1ca7c01fb3f4f7c8d35666e6761bf4bbd7c03c6
isAssociative
public boolean isAssociative()
{    return Math.abs(multiplicator - 0.0) < Constants.EPSILON || Math.abs(multiplicator - 1.0) < Constants.EPSILON;}
1d5754e580095d49c82dda13e9340426eb7829205640af9088491f31ef6aa908
setMultiplicator
public void setMultiplicator(double multiplicator)
{    this.multiplicator = multiplicator;}
685ca82cead33e56c75cad5ace5f3cba2e4e471d0dcc68359527832073e7cdd4
apply
public double apply(double arg1)
{    return Math.sqrt(arg1);}
dd57b1c2ae568f382da7388b79a15acd106539fea0bbe7635354ee8cd9bbb220
apply
public double apply(double x, double y)
{    return x * y;}
a1ad6499e0c57ff44a878a8448bbfcce32d6707cd58f70604168d6389ebbf80d
isLikeRightPlus
public boolean isLikeRightPlus()
{    return false;}
362ebc0c9817637c79f9672f5db733a138c9486b10976a517e6fb74b01425a96
isLikeLeftMult
public boolean isLikeLeftMult()
{    return true;}
3c7e87c20a57090c5015732c28ff4ba1d3ad3d588fe9c451f36aadac2e416d11
isLikeRightMult
public boolean isLikeRightMult()
{    return true;}
cdd95de8ceb4c4ec4da87111cba55b6372bc588afb89d4c0d6b704643cfdabf0
isCommutative
public boolean isCommutative()
{    return true;}
104c739de29f8d1f9528bf70d1ca7c01fb3f4f7c8d35666e6761bf4bbd7c03c6
isAssociative
public boolean isAssociative()
{    return true;}
2d445c7af662ad5641bd7c216b4e7684a9cdab361f239540c55a18b81c86443c
assignColumn
public Matrix assignColumn(int column, Vector other)
{    throw new UnsupportedOperationException("Assignment to a matrix not supported");}
95687ef4453f7375a5854c6fa51b38f6963e77319dd3f4176496189e5fd67c55
assignRow
public Matrix assignRow(int row, Vector other)
{    throw new UnsupportedOperationException("Assignment to a matrix view not supported");}
1a7b4a2d3001072b037d625fbd603f24082fad4d995e7354ef48188cd1906c22
getQuick
public double getQuick(int row, int column)
{    return gf.apply(row, column);}
8ea1ca8bbfed9d923bb33b6722a3491db09837bb6812b8b8778bf2422064e0ab
like
public Matrix like()
{    return like(rows, columns);}
f88fece6b0c6401785f452c13d8cce7ea1dc13011ee8686b08685d42b6f32638
like
public Matrix like(int rows, int columns)
{    if (denseLike)        return new DenseMatrix(rows, columns);    else        return new SparseMatrix(rows, columns);}
c733fce42980b3396a3426c0cfb05355954939da4f722c3d81ab2555e6bd9282
setQuick
public void setQuick(int row, int column, double value)
{    throw new UnsupportedOperationException("Assignment to a matrix view not supported");}
cc845ba0d004ee14775588b6cb695a9053ef1f384e5196e605687c0f7eeac020
viewRow
public Vector viewRow(int row)
{    return new MatrixVectorView(this, row, 0, 0, 1, denseLike);}
d46193949587a2e9ca1ec7df8ed6534443c7731e6ae91f71f45b19ee95634c85
viewColumn
public Vector viewColumn(int column)
{    return new MatrixVectorView(this, 0, column, 1, 0, denseLike);}
4f943db0f33d27c9f70c541ef27a217346904d47c0870b555f1140eebdc0f9b2
getFlavor
public MatrixFlavor getFlavor()
{    return flavor;}
41bb21f9f56996779aeef2f2d5104803f013836ee3d05d106847f60c93b3da50
binomial
public static double binomial(long n, long k)
{    if (k < 0) {        return 0;    }    if (k == 0 || k == n) {        return 1;    }    if (k == 1 || k == n - 1) {        return n;    }        if (n > k) {        int max = FACTORIAL_TABLE.length + LARGE_FACTORIAL_TABLE.length;        if (n < max) {                        double nFactorial = factorial((int) n);            double kFactorial = factorial((int) k);            double nMinusKFactorial = factorial((int) (n - k));            double nk = nMinusKFactorial * kFactorial;            if (nk != Double.POSITIVE_INFINITY) {                                return nFactorial / nk;            }        }        if (k > n / 2) {            k = n - k;        }        }        long a = n - k + 1;    long b = 1;    double binomial = 1;    for (long i = k; i-- > 0; ) {        binomial *= (double) a++ / b++;    }    return binomial;}
d4189d9555ad9306cb3d90d7283949cbbcb43f21b01ef729870ca2fbb11fb02b
factorial
private static double factorial(int k)
{    if (k < 0) {        throw new IllegalArgumentException();    }    int length1 = FACTORIAL_TABLE.length;    if (k < length1) {        return FACTORIAL_TABLE[k];    }    int length2 = LARGE_FACTORIAL_TABLE.length;    if (k < length1 + length2) {        return LARGE_FACTORIAL_TABLE[k - length1];    } else {        return Double.POSITIVE_INFINITY;    }}
9d14a4746c78c2b709e9a13620b26d1b041bf3df6cdffde93c7e33fe281ede55
logFactorial
public static double logFactorial(int k)
{    if (k >= 30) {        double r = 1.0 / k;        double rr = r * r;        double c7 = -5.95238095238095238e-04;        double c5 = 7.93650793650793651e-04;        double c3 = -2.77777777777777778e-03;        double c1 = 8.33333333333333333e-02;        double c0 = 9.18938533204672742e-01;        return (k + 0.5) * Math.log(k) - k + c0 + r * (c1 + rr * (c3 + rr * (c5 + rr * c7)));    } else {        return LOG_FACTORIAL_TABLE[k];    }}
20a94611619765c7f0a0bca74a374c1f23193f4e32c572022ff19984c5c5f8b3
p1evl
public static double p1evl(double x, double[] coef, int N)
{    double ans = x + coef[0];    for (int i = 1; i < N; i++) {        ans = ans * x + coef[i];    }    return ans;}
84789c9c424fd8e79e864e6b86218c8d5cc48bb0a6c975325942de8e5433c3da
polevl
public static double polevl(double x, double[] coef, int N)
{    double ans = coef[0];    for (int i = 1; i <= N; i++) {        ans = ans * x + coef[i];    }    return ans;}
3dcc8c47c265a7bd0a7e3c7efd62c9fec2dd64122f8be090428f6948c78b205c
cdf
public double cdf(double x)
{    throw new UnsupportedOperationException("Can't compute pdf for " + this.getClass().getName());}
7728cf4bfb25157e8608b24611aeb03002ffa33bcbcf9ea620afbb80ce7ca715
pdf
public double pdf(double x)
{    throw new UnsupportedOperationException("Can't compute pdf for " + this.getClass().getName());}
fdad8c53e4cb93ac9606cf0b9361af34b8b3fd5bb4f6e88ad403d16c89019543
nextInt
public int nextInt()
{    return (int) Math.round(nextDouble());}
d6d7ecac7880b96314133f7a8ed91d06073e9d6de2cb7ebd98123903ecca9b91
nextDouble
public double nextDouble()
{    return nextInt();}
afeceb974212726213ab7a768d52a4e4274f89738b529f65485ec0015a43fde5
getRandomGenerator
protected Random getRandomGenerator()
{    return randomGenerator;}
59844992110b11075121d603867eea3506076feea9074417cc7fda66b91b065f
randomDouble
protected double randomDouble()
{    return randomGenerator.nextDouble();}
9eb6706b8672c346d0955f7568f07db4aa7744dfb1602e89a9d2d6cd6111916b
apply
public double apply(double dummy)
{    return nextDouble();}
6af9c1825a152d42597aaae29fcc8cc99a25144e16ea02a5acfff8190ecf357c
apply
public int apply(int dummy)
{    return nextInt();}
0eda3c3e3816199879055c1aef2db0f5fed6052cdda599280a4b3c5ce9a3b037
setRandomGenerator
public void setRandomGenerator(Random randomGenerator)
{    this.randomGenerator = randomGenerator;}
5e394a5fcbbc55e47a8d4d21e2cec59c1a5b972a7df941c10fc62057210d5d92
nextBlock
 void nextBlock()
{    int y;    int kk;    for (kk = 0; kk < N - M; kk++) {        y = (mt[kk] & UPPER_MASK) | (mt[kk + 1] & LOWER_MASK);        mt[kk] = mt[kk + M] ^ (y >>> 1) ^ ((y & 0x1) == 0 ? MAG0 : MAG1);    }    for (; kk < N - 1; kk++) {        y = (mt[kk] & UPPER_MASK) | (mt[kk + 1] & LOWER_MASK);        mt[kk] = mt[kk + (M - N)] ^ (y >>> 1) ^ ((y & 0x1) == 0 ? MAG0 : MAG1);    }    y = (mt[N - 1] & UPPER_MASK) | (mt[0] & LOWER_MASK);    mt[N - 1] = mt[M - 1] ^ (y >>> 1) ^ ((y & 0x1) == 0 ? MAG0 : MAG1);    this.mti = 0;}
fdad8c53e4cb93ac9606cf0b9361af34b8b3fd5bb4f6e88ad403d16c89019543
nextInt
public int nextInt()
{    /* Each single bit including the sign bit will be random */    if (mti == N) {        nextBlock();    }        int y = mt[mti++];        y ^= y >>> 11;        y ^= (y << 7) & TEMPERING_MASK_B;        y ^= (y << 15) & TEMPERING_MASK_C;            y ^= y >>> 18;    return y;}
ae0547877a4b5cbf5d0c922c36c67ac263befa5df6759d433dcf45b7b7e206d5
setSeed
 void setSeed(int seed)
{    mt[0] = seed;    for (int i = 1; i < N; i++) {        mt[i] = 1812433253 * (mt[i - 1] ^ (mt[i - 1] >> 30)) + i;    /* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */    /* In the previous versions, MSBs of the seed affect   */    /* only MSBs of the array mt[].                        */    /* 2002/01/09 modified by Makoto Matsumoto             */        /* for >32 bit machines */    }        mti = N;}
c7e948b1b10d8eab2238c74caa82fb809790991cd624631684b33f465375d028
setReferenceSeed
 void setReferenceSeed(int seed)
{    for (int i = 0; i < N; i++) {        mt[i] = seed & 0xffff0000;        seed = 69069 * seed + 1;        mt[i] |= (seed & 0xffff0000) >>> 16;        seed = 69069 * seed + 1;    }        mti = N;}
9eb6706b8672c346d0955f7568f07db4aa7744dfb1602e89a9d2d6cd6111916b
apply
public double apply(double dummy)
{    return raw();}
6af9c1825a152d42597aaae29fcc8cc99a25144e16ea02a5acfff8190ecf357c
apply
public int apply(int dummy)
{    return nextInt();}
d6d7ecac7880b96314133f7a8ed91d06073e9d6de2cb7ebd98123903ecca9b91
nextDouble
public double nextDouble()
{    double nextDouble;    do {                        nextDouble = (nextLong() - -9.223372036854776E18) * 5.421010862427522E-20;    } while (    !(nextDouble > 0.0 && nextDouble < 1.0));        return nextDouble;/*      nextLong == Long.MAX_VALUE         --> 1.0      nextLong == Long.MIN_VALUE         --> 0.0      nextLong == Long.MAX_VALUE-1       --> 1.0      nextLong == Long.MAX_VALUE-100000L --> 0.9999999999999946      nextLong == Long.MIN_VALUE+1       --> 0.0      nextLong == Long.MIN_VALUE-100000L --> 0.9999999999999946      nextLong == 1L                     --> 0.5      nextLong == -1L                    --> 0.5      nextLong == 2L                     --> 0.5      nextLong == -2L                    --> 0.5      nextLong == 2L+100000L             --> 0.5000000000000054      nextLong == -2L-100000L            --> 0.49999999999999456    */}
d66b64f4fc9e91b8f6c608cd60c18659ef69861a38b507ab31f92b36caeda32d
nextFloat
public float nextFloat()
{        float nextFloat;    do {        nextFloat = (float) raw();    } while (nextFloat >= 1.0f);        return nextFloat;}
c07ff43a11a0fd30355c754b084700be1eadeb6e7293cc052804e1ca4dba70c9
nextLong
public long nextLong()
{        return ((nextInt() & 0xFFFFFFFFL) << 32) | (nextInt() & 0xFFFFFFFFL);}
401380801178818d6ef881ea8f578d18b5ef6a7666e336d42608b0760441f5e9
raw
public double raw()
{    int nextInt;    do {                        nextInt = nextInt();    } while (nextInt == 0);        return (nextInt & 0xFFFFFFFFL) * 2.3283064365386963E-10;/*      nextInt == Integer.MAX_VALUE   --> 0.49999999976716936      nextInt == Integer.MIN_VALUE   --> 0.5      nextInt == Integer.MAX_VALUE-1 --> 0.4999999995343387      nextInt == Integer.MIN_VALUE+1 --> 0.5000000002328306      nextInt == 1                   --> 2.3283064365386963E-10      nextInt == -1                  --> 0.9999999997671694      nextInt == 2                   --> 4.6566128730773926E-10      nextInt == -2                  --> 0.9999999995343387    */}
3dcc8c47c265a7bd0a7e3c7efd62c9fec2dd64122f8be090428f6948c78b205c
cdf
public double cdf(double x)
{    if (x <= 0.0) {        return 0.0;    }    return 1.0 - Math.exp(-x * lambda);}
d6d7ecac7880b96314133f7a8ed91d06073e9d6de2cb7ebd98123903ecca9b91
nextDouble
public double nextDouble()
{    return -Math.log1p(-randomDouble()) / lambda;}
7728cf4bfb25157e8608b24611aeb03002ffa33bcbcf9ea620afbb80ce7ca715
pdf
public double pdf(double x)
{    if (x < 0.0) {        return 0.0;    }    return lambda * Math.exp(-x * lambda);}
ad5148b9e11814e6b608d8ffc48fdbce30d200c18f8e7465054c42bb451f9c32
setState
public void setState(double lambda)
{    this.lambda = lambda;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return String.format(Locale.ENGLISH, "%s(%.4f)", this.getClass().getName(), lambda);}
3dcc8c47c265a7bd0a7e3c7efd62c9fec2dd64122f8be090428f6948c78b205c
cdf
public double cdf(double x)
{    return Probability.gamma(alpha, rate, x);}
d6d7ecac7880b96314133f7a8ed91d06073e9d6de2cb7ebd98123903ecca9b91
nextDouble
public double nextDouble()
{    return nextDouble(alpha, rate);}
8c3d2746a4d4455f2ec7b73eda47973ce119e45654196cbb1bd58d4ce2f5b5fa
nextDouble
public double nextDouble(double alpha, double rate)
{    if (alpha <= 0.0) {        throw new IllegalArgumentException();    }    if (rate <= 0.0) {        throw new IllegalArgumentException();    }    double gds;    double b = 0.0;    if (alpha < 1.0) {                        b = 1.0 + 0.36788794412 * alpha;        while (true) {            double p = b * randomDouble();            if (p <= 1.0) {                                gds = Math.exp(Math.log(p) / alpha);                if (Math.log(randomDouble()) <= -gds) {                    return gds / rate;                }            } else {                                gds = -Math.log((b - p) / alpha);                if (Math.log(randomDouble()) <= (alpha - 1.0) * Math.log(gds)) {                    return gds / rate;                }            }        }    } else {                double ss = 0.0;        double s = 0.0;        double d = 0.0;        if (alpha != -1.0) {                        ss = alpha - 0.5;            s = Math.sqrt(ss);            d = 5.656854249 - 12.0 * s;        }                double v12;        double v1;        do {            v1 = 2.0 * randomDouble() - 1.0;            double v2 = 2.0 * randomDouble() - 1.0;            v12 = v1 * v1 + v2 * v2;        } while (v12 > 1.0);        double t = v1 * Math.sqrt(-2.0 * Math.log(v12) / v12);        double x = s + 0.5 * t;        gds = x * x;        if (t >= 0.0) {            return gds / rate;        }                double u = randomDouble();        if (d * u <= t * t * t) {            return gds / rate;        }                double q0 = 0.0;        double si = 0.0;        double c = 0.0;        if (alpha != -1.0) {                        double r = 1.0 / alpha;            double q9 = 0.0001710320;            double q8 = -0.0004701849;            double q7 = 0.0006053049;            double q6 = 0.0003340332;            double q5 = -0.0003349403;            double q4 = 0.0015746717;            double q3 = 0.0079849875;            double q2 = 0.0208333723;            double q1 = 0.0416666664;            q0 = ((((((((q9 * r + q8) * r + q7) * r + q6) * r + q5) * r + q4) * r + q3) * r + q2) * r + q1) * r;            if (alpha > 3.686) {                if (alpha > 13.022) {                    b = 1.77;                    si = 0.75;                    c = 0.1515 / s;                } else {                    b = 1.654 + 0.0076 * ss;                    si = 1.68 / s + 0.275;                    c = 0.062 / s + 0.024;                }            } else {                b = 0.463 + s - 0.178 * ss;                si = 1.235;                c = 0.195 / s - 0.079 + 0.016 * s;            }        }        double v;        double q;        double a9 = 0.104089866;        double a8 = -0.112750886;        double a7 = 0.110368310;        double a6 = -0.124385581;        double a5 = 0.142873973;        double a4 = -0.166677482;        double a3 = 0.199999867;        double a2 = -0.249999949;        double a1 = 0.333333333;        if (x > 0.0) {                                    v = t / (s + s);            if (Math.abs(v) > 0.25) {                q = q0 - s * t + 0.25 * t * t + (ss + ss) * Math.log1p(v);            } else {                q = q0 + 0.5 * t * t * ((((((((a9 * v + a8) * v + a7) * v + a6) * v + a5) * v + a4) * v + a3) * v + a2) * v + a1) * v;            }                        if (Math.log1p(-u) <= q) {                return gds / rate;            }        }        double e7 = 0.000247453;        double e6 = 0.001353826;        double e5 = 0.008345522;        double e4 = 0.041664508;        double e3 = 0.166666848;        double e2 = 0.499999994;        double e1 = 1.000000000;        while (true) {                        double sign_u;            double e;            do {                e = -Math.log(randomDouble());                u = randomDouble();                u = u + u - 1.0;                sign_u = u > 0 ? 1.0 : -1.0;                t = b + e * si * sign_u;            } while (            t <= -0.71874483771719);                        v = t / (s + s);            if (Math.abs(v) > 0.25) {                q = q0 - s * t + 0.25 * t * t + (ss + ss) * Math.log1p(v);            } else {                q = q0 + 0.5 * t * t * ((((((((a9 * v + a8) * v + a7) * v + a6) * v + a5) * v + a4) * v + a3) * v + a2) * v + a1) * v;            }            if (q <= 0.0) {                continue;            }                        double w;            if (q > 0.5) {                w = Math.exp(q) - 1.0;            } else {                w = ((((((e7 * q + e6) * q + e5) * q + e4) * q + e3) * q + e2) * q + e1) * q;            }                        if (c * u * sign_u <= w * Math.exp(e - 0.5 * t * t)) {                x = s + 0.5 * t;                return x * x / rate;            }        }    }}
7728cf4bfb25157e8608b24611aeb03002ffa33bcbcf9ea620afbb80ce7ca715
pdf
public double pdf(double x)
{    if (x < 0) {        throw new IllegalArgumentException();    }    if (x == 0) {        if (alpha == 1.0) {            return rate;        } else if (alpha < 1) {            return Double.POSITIVE_INFINITY;        } else {            return 0;        }    }    if (alpha == 1.0) {        return rate * Math.exp(-x * rate);    }    return rate * Math.exp((alpha - 1.0) * Math.log(x * rate) - x * rate - logGamma(alpha));}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return this.getClass().getName() + '(' + rate + ',' + alpha + ')';}
e52512334b1c19b4bfc140b2535288b63a69867aa2a86be1ef61aeeda8f3bb9b
logGamma
public static double logGamma(double x)
{    if (x <= 0.0) /* || x > 1.3e19 */    {        return -999;    }    double z;    for (z = 1.0; x < 11.0; x++) {        z *= x;    }    double r = 1.0 / (x * x);    double c6 = -1.9175269175269175e-03;    double c5 = 8.4175084175084175e-04;    double c4 = -5.9523809523809524e-04;    double c3 = 7.9365079365079365e-04;    double c2 = -2.7777777777777777e-03;    double c1 = 8.3333333333333333e-02;    double g = c1 + r * (c2 + r * (c3 + r * (c4 + r * (c5 + r + c6))));    double c0 = 9.1893853320467274e-01;    g = (x - 0.5) * Math.log(x) - x + c0 + g / x;    if (z == 1.0) {        return g;    }    return g - Math.log(z);}
078d1cdff2e7ab3edd45e875ca8a400ea14797075af19017cb8b334dbc37699d
cdf
public double cdf(int k)
{    return Probability.negativeBinomial(k, r, p);}
39a60d20301dcff88290fdc2b1283512413608526835066f20cb6461161bb75a
pdf
public double pdf(int k)
{    return Arithmetic.binomial(k + r - 1, r - 1) * Math.pow(p, r) * Math.pow(1.0 - p, k);}
fdad8c53e4cb93ac9606cf0b9361af34b8b3fd5bb4f6e88ad403d16c89019543
nextInt
public int nextInt()
{    return nextInt(r, p);}
cad8aba4ca8110e340ecbd14f91f2e588ed600857da9b24832516603f5243910
nextInt
public int nextInt(int r, double p)
{    return this.poisson.nextInt(gamma.nextDouble(r, p / (1.0 - p)));}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return this.getClass().getName() + '(' + r + ',' + p + ')';}
3dcc8c47c265a7bd0a7e3c7efd62c9fec2dd64122f8be090428f6948c78b205c
cdf
public double cdf(double x)
{    return Probability.normal(mean, variance, x);}
7728cf4bfb25157e8608b24611aeb03002ffa33bcbcf9ea620afbb80ce7ca715
pdf
public double pdf(double x)
{    double diff = x - mean;    return normalizer * Math.exp(-(diff * diff) / (2.0 * variance));}
d6d7ecac7880b96314133f7a8ed91d06073e9d6de2cb7ebd98123903ecca9b91
nextDouble
public double nextDouble()
{        if (cacheFilled) {        cacheFilled = false;        return cache;    }    double x;    double y;    double r;    do {        x = 2.0 * randomDouble() - 1.0;        y = 2.0 * randomDouble() - 1.0;        r = x * x + y * y;    } while (r >= 1.0);    double z = Math.sqrt(-2.0 * Math.log(r) / r);    cache = this.mean + this.standardDeviation * x * z;    cacheFilled = true;    return this.mean + this.standardDeviation * y * z;}
2c4804f1d4ba5d573b93ce9b30c47f582bae568df0d1b127055017bb691d89aa
setRandomGenerator
public final void setRandomGenerator(Random randomGenerator)
{    super.setRandomGenerator(randomGenerator);    this.cacheFilled = false;}
f956406312d02b9c1e9bb13b7273fb0639f34292ca99076a7f7fe73f03cea6e4
setState
public final void setState(double mean, double standardDeviation)
{    if (mean != this.mean || standardDeviation != this.standardDeviation) {        this.mean = mean;        this.standardDeviation = standardDeviation;        this.variance = standardDeviation * standardDeviation;        this.cacheFilled = false;        this.normalizer = 1.0 / Math.sqrt(2.0 * Math.PI * variance);    }}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return String.format(Locale.ENGLISH, "%s(m=%f, sd=%f)", this.getClass().getName(), mean, standardDeviation);}
227d217446e3af0df85bff92dd4b6e6880c2f5b49664e584563c1b3a8ebe6d27
f
private static double f(int k, double lNu, double cPm)
{    return Math.exp(k * lNu - Arithmetic.logFactorial(k) - cPm);}
fdad8c53e4cb93ac9606cf0b9361af34b8b3fd5bb4f6e88ad403d16c89019543
nextInt
public int nextInt()
{    return nextInt(mean);}
035f840755643447782f6a470b5973eef1a07b7d3f84111cf8fcb8e4bec015d7
nextInt
public int nextInt(double theMean)
{    /**     * ***************************************************************     *                                                                 *     *  Poisson Distribution - Patchwork Rejection/Inversion           *     *                                                                 *     * *****************************************************************     *                                                                 *     *  For parameter  my < 10  Tabulated Inversion is applied.        *     *  For my >= 10  Patchwork Rejection is employed:                 *     *  The area below the histogram function f(x) is rearranged in    *     *  its body by certain point reflections. Within a large center   *     *  interval variates are sampled efficiently by rejection from    *     *  uniform hats. Rectangular immediate acceptance regions speed   *     *  up the generation. The remaining tails are covered by          *     *  exponential functions.                                         *     *                                                                 *     * ***************************************************************     */    Random gen = getRandomGenerator();                        int m;    if (theMean < SWITCH_MEAN) {                if (theMean != myOld) {            myOld = theMean;            llll = 0;            p = Math.exp(-theMean);            q = p;            p0 = p;                }        m = theMean > 1.0 ? (int) theMean : 1;        while (true) {            double u = gen.nextDouble();            int k = 0;            if (u <= p0) {                return k;            }            if (llll != 0) {                                int i = u > 0.458 ? Math.min(llll, m) : 1;                for (k = i; k <= llll; k++) {                    if (u <= pp[k]) {                        return k;                    }                }                if (llll == 35) {                    continue;                }            }            for (k = llll + 1; k <= 35; k++) {                                p *= theMean / k;                q += p;                pp[k] = q;                if (u <= q) {                    llll = k;                    return k;                }            }            llll = 35;        }        } else if (theMean < MEAN_MAX) {                                                m = (int) theMean;        if (theMean != myLast) {                        myLast = theMean;                        double Ds = Math.sqrt(theMean + 0.25);                                    k2 = (int) Math.ceil(theMean - 0.5 - Ds);            k4 = (int) (theMean - 0.5 + Ds);            k1 = k2 + k2 - m + 1;            k5 = k4 + k4 - m;                        dl = k2 - k1;            dr = k5 - k4;                        r1 = theMean / k1;            r2 = theMean / k2;            r4 = theMean / (k4 + 1);            r5 = theMean / (k5 + 1);                                    ll = Math.log(r1);                        lr = -Math.log(r5);                        lMy = Math.log(theMean);            cPm = m * lMy - Arithmetic.logFactorial(m);                        f2 = f(k2, lMy, cPm);            f4 = f(k4, lMy, cPm);            f1 = f(k1, lMy, cPm);            f5 = f(k5, lMy, cPm);                                                p1 = f2 * (dl + 1.0);                        p2 = f2 * dl + p1;                        p3 = f4 * (dr + 1.0) + p2;                        p4 = f4 * dr + p3;                        p5 = f1 / ll + p4;                        p6 = f5 / lr + p5;        }        while (true) {                                    double W;            double V;            double U;            int Y;            int X;            int Dk;            if ((U = gen.nextDouble() * p6) < p2) {                                if ((V = U - p1) < 0.0) {                    return k2 + (int) (U / f2);                }                                if ((W = V / dl) < f1) {                    return k1 + (int) (V / f1);                }                                                Dk = gen.nextInt((int) dl) + 1;                if (W <= f2 - Dk * (f2 - f2 / r2)) {                                        return k2 - Dk;                }                if ((V = f2 + f2 - W) < 1.0) {                                        Y = k2 + Dk;                    if (V <= f2 + Dk * (1.0 - f2) / (dl + 1.0)) {                                                return Y;                    }                    if (V <= f(Y, lMy, cPm)) {                        return Y;                    }                                }                X = k2 - Dk;            } else if (U < p4) {                                if ((V = U - p3) < 0.0) {                    return k4 - (int) ((U - p2) / f4);                }                                if ((W = V / dr) < f5) {                    return k5 - (int) (V / f5);                }                                                Dk = gen.nextInt((int) dr) + 1;                if (W <= f4 - Dk * (f4 - f4 * r4)) {                                        return k4 + Dk;                }                if ((V = f4 + f4 - W) < 1.0) {                                        Y = k4 - Dk;                    if (V <= f4 + Dk * (1.0 - f4) / dr) {                                                return Y;                    }                    if (V <= f(Y, lMy, cPm)) {                        return Y;                    }                                }                X = k4 + Dk;            } else {                W = gen.nextDouble();                if (U < p5) {                                        Dk = (int) (1.0 - Math.log(W) / ll);                    if ((X = k1 - Dk) < 0) {                        continue;                    }                                                            W *= (U - p4) * ll;                    if (W <= f1 - Dk * (f1 - f1 / r1)) {                        return X;                    }                                } else {                                        Dk = (int) (1.0 - Math.log(W) / lr);                                        X = k5 + Dk;                                        W *= (U - p5) * lr;                    if (W <= f5 - Dk * (f5 - f5 * r5)) {                        return X;                    }                                }            }                        if (Math.log(W) <= X * lMy - Arithmetic.logFactorial(X) - cPm) {                return X;            }        }    } else {                return (int) theMean;    }}
a9729f4ebf53ca833ec0603ba983456cd900b9519ab0751c04117a297b2aa827
rejectMethodD
private static void rejectMethodD(long n, long N, int count, long low, long[] values, int fromIndex, Random randomGenerator)
{    /*  This algorithm is applicable if a large percentage (90%..100%) of N shall be sampled.      In such cases it is more efficient than sampleMethodA() and sampleMethodD().        The idea is that it is more efficient to express      sample(n,N,count) in terms of reject(N-n,N,count)       and then invert the result.      For example, sampling 99% turns into sampling 1% plus inversion.      This algorithm is the same as method sampleMethodD(...) with the exception that sampled elements are rejected,      and not sampled elements included in the result set.    */        n = N - n;        long chosen = -1 + low;                double nreal = n;    double ninv = 1.0 / nreal;    double Nreal = N;    double Vprime = Math.exp(Math.log(randomGenerator.nextDouble()) * ninv);    long qu1 = -n + 1 + N;    double qu1real = -nreal + 1.0 + Nreal;        long S;    while (n > 1 && count > 0) {                double nmin1inv = 1.0 / (-1.0 + nreal);        double negSreal;        while (true) {            double X;            while (true) {                                X = Nreal * (-Vprime + 1.0);                S = (long) X;                if (S < qu1) {                    break;                }                Vprime = Math.exp(Math.log(randomGenerator.nextDouble()) * ninv);            }            double U = randomGenerator.nextDouble();            negSreal = -S;                        double y1 = Math.exp(Math.log(U * Nreal / qu1real) * nmin1inv);            Vprime = y1 * (-X / Nreal + 1.0) * qu1real / (negSreal + qu1real);            if (Vprime <= 1.0) {                break;            }                                    double top = -1.0 + Nreal;            long limit;            double bottom;            if (n - 1 > S) {                bottom = -nreal + Nreal;                limit = -S + N;            } else {                bottom = -1.0 + negSreal + Nreal;                limit = qu1;            }            double y2 = 1.0;            for (long t = N - 1; t >= limit; t--) {                y2 *= top / bottom;                top--;                bottom--;            }            if (Nreal / (-X + Nreal) >= y1 * Math.exp(Math.log(y2) * nmin1inv)) {                                Vprime = Math.exp(Math.log(randomGenerator.nextDouble()) * nmin1inv);                                break;            }            Vprime = Math.exp(Math.log(randomGenerator.nextDouble()) * ninv);        }                        int iter = count;        if (S < iter) {            iter = (int) S;        }        count -= iter;        while (--iter >= 0) {            values[fromIndex++] = ++chosen;        }        chosen++;        N -= S + 1;        Nreal = negSreal - 1.0 + Nreal;        n--;        nreal--;        ninv = nmin1inv;        qu1 = -S + qu1;        qu1real = negSreal + qu1real;        }    if (count > 0) {                        S = (long) (N * Vprime);                int iter = count;        if (S < iter) {            iter = (int) S;        }        count -= iter;        while (--iter >= 0) {            values[fromIndex++] = ++chosen;        }        chosen++;                while (--count >= 0) {            values[fromIndex++] = ++chosen;        }    }}
fc4db40e20fa1cc286cf1b1f4d4549b9f0c9a3cc22fcb4f065450f9c15bf8817
sample
public static void sample(long n, long N, int count, long low, long[] values, int fromIndex, Random randomGenerator)
{    if (n <= 0 || count <= 0) {        return;    }    if (count > n) {        throw new IllegalArgumentException("count must not be greater than n");    }    if (randomGenerator == null) {        randomGenerator = RandomUtils.getRandom();    }    if (count == N) {                long val = low;        int limit = fromIndex + count;        for (int i = fromIndex; i < limit; i++) {            values[i] = val++;        }        return;    }    if (n < N * 0.95) {                sampleMethodD(n, N, count, low, values, fromIndex, randomGenerator);    } else {                rejectMethodD(n, N, count, low, values, fromIndex, randomGenerator);    }}
6ad1740b42825e2d6f9200ed987c17881b2113dfc0b7bd927308cb67ae01fb5d
sampleMethodA
private static void sampleMethodA(long n, long N, int count, long low, long[] values, int fromIndex, Random randomGenerator)
{    long chosen = -1 + low;    double top = N - n;    double Nreal = N;    long S;    while (n >= 2 && count > 0) {        double V = randomGenerator.nextDouble();        S = 0;        double quot = top / Nreal;        while (quot > V) {            S++;            top--;            Nreal--;            quot *= top / Nreal;        }        chosen += S + 1;        values[fromIndex++] = chosen;        count--;        Nreal--;        n--;    }    if (count > 0) {                S = (long) (Math.round(Nreal) * randomGenerator.nextDouble());        chosen += S + 1;        values[fromIndex] = chosen;    }}
8972160e46941cd04d49f5d0a69dd298e780f23f0f462a45c7faaff547c42833
sampleMethodD
private static void sampleMethodD(long n, long N, int count, long low, long[] values, int fromIndex, Random randomGenerator)
{    long chosen = -1 + low;    double nreal = n;    double ninv = 1.0 / nreal;    double Nreal = N;    double vprime = Math.exp(Math.log(randomGenerator.nextDouble()) * ninv);    long qu1 = -n + 1 + N;    double qu1real = -nreal + 1.0 + Nreal;    long negalphainv = -13;            long threshold = -negalphainv * n;    long S;    while (n > 1 && count > 0 && threshold < N) {        double nmin1inv = 1.0 / (-1.0 + nreal);        double negSreal;        while (true) {            double X;            while (true) {                                X = Nreal * (-vprime + 1.0);                S = (long) X;                if (S < qu1) {                    break;                }                vprime = Math.exp(Math.log(randomGenerator.nextDouble()) * ninv);            }            double U = randomGenerator.nextDouble();            negSreal = -S;                        double y1 = Math.exp(Math.log(U * Nreal / qu1real) * nmin1inv);            vprime = y1 * (-X / Nreal + 1.0) * qu1real / (negSreal + qu1real);            if (vprime <= 1.0) {                break;            }                                    double top = -1.0 + Nreal;            long limit;            double bottom;            if (n - 1 > S) {                bottom = -nreal + Nreal;                limit = -S + N;            } else {                bottom = -1.0 + negSreal + Nreal;                limit = qu1;            }            double y2 = 1.0;            for (long t = N - 1; t >= limit; t--) {                y2 *= top / bottom;                top--;                bottom--;            }            if (Nreal / (-X + Nreal) >= y1 * Math.exp(Math.log(y2) * nmin1inv)) {                                vprime = Math.exp(Math.log(randomGenerator.nextDouble()) * nmin1inv);                                break;            }            vprime = Math.exp(Math.log(randomGenerator.nextDouble()) * ninv);        }                chosen += S + 1;        values[fromIndex++] = chosen;        /*            for (int iter=0; iter<S && count > 0; iter++) {        values[fromIndex++] = ++chosen;        count--;      }      chosen++;      */        count--;        N -= S + 1;        Nreal = negSreal - 1.0 + Nreal;        n--;        nreal--;        ninv = nmin1inv;        qu1 = -S + qu1;        qu1real = negSreal + qu1real;        threshold += negalphainv;    }    if (count > 0) {        if (n > 1) {                        sampleMethodA(n, N, count, chosen + 1, values, fromIndex, randomGenerator);        } else {                        S = (long) (N * vprime);            chosen += S + 1;            values[fromIndex++] = chosen;        }    }}
3dcc8c47c265a7bd0a7e3c7efd62c9fec2dd64122f8be090428f6948c78b205c
cdf
public double cdf(double x)
{    if (x <= min) {        return 0.0;    }    if (x >= max) {        return 1.0;    }    return (x - min) / (max - min);}
4b9c699eebc79255653a14d145ee50a9e723eb3d0304d0b2c097a3e97f401cdb
nextBoolean
public boolean nextBoolean()
{    return randomDouble() > 0.5;}
d6d7ecac7880b96314133f7a8ed91d06073e9d6de2cb7ebd98123903ecca9b91
nextDouble
public double nextDouble()
{    return min + (max - min) * randomDouble();}
639ac6e1c3b888da27d47d751abfc5338ab253205c5918c0c7562c36782eb88e
nextDoubleFromTo
public double nextDoubleFromTo(double from, double to)
{    return from + (to - from) * randomDouble();}
d6a864bd02577c022ee24193bf59e1eed41c1125c8ffee9ed206adf7cd779337
nextFloatFromTo
public float nextFloatFromTo(float from, float to)
{    return (float) nextDoubleFromTo(from, to);}
667af4159bd9ccae62df7bb0d8348b539c6ae6502ae8e5d269a81fa8a20960a0
nextIntFromTo
public int nextIntFromTo(int from, int to)
{    return (int) (from + (long) ((1L + to - from) * randomDouble()));}
76ec937a77c89125cf9a92091cacedb3282a13b6061efff6f573c91bee162877
nextLongFromTo
public long nextLongFromTo(long from, long to)
{        if (from >= 0 && to < Long.MAX_VALUE) {        return from + (long) nextDoubleFromTo(0.0, to - from + 1);    }            double diff = (double) to - (double) from + 1.0;    if (diff <= Long.MAX_VALUE) {        return from + (long) nextDoubleFromTo(0.0, diff);    }            long random;    if (from == Long.MIN_VALUE) {        if (to == Long.MAX_VALUE) {                        int i1 = nextIntFromTo(Integer.MIN_VALUE, Integer.MAX_VALUE);            int i2 = nextIntFromTo(Integer.MIN_VALUE, Integer.MAX_VALUE);            return ((i1 & 0xFFFFFFFFL) << 32) | (i2 & 0xFFFFFFFFL);        }        random = Math.round(nextDoubleFromTo(Long.MIN_VALUE, to + 1));        if (random > to) {            random = Long.MIN_VALUE;        }    } else {        random = Math.round(nextDoubleFromTo(from - 1, to));        if (random < from) {            random = to;        }    }    return random;}
7728cf4bfb25157e8608b24611aeb03002ffa33bcbcf9ea620afbb80ce7ca715
pdf
public double pdf(double x)
{    if (x <= min || x >= max) {        return 0.0;    }    return 1.0 / (max - min);}
686a615cb5b0703a958e966285df7bcb1795996649be909479cbc867ff5ca31f
setState
public void setState(double min, double max)
{    if (max < min) {        setState(max, min);        return;    }    this.min = min;    this.max = max;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return this.getClass().getName() + '(' + min + ',' + max + ')';}
8eb7b73629acc253404c476916fd9f0f6b43966c3df3e01bc966114482066ceb
beta
public static double beta(double alpha, double beta)
{    double y;    if (alpha < 40 && beta < 40) {        y = gamma(alpha + beta);        if (y == 0.0) {            return 1.0;        }        if (alpha > beta) {            y = gamma(alpha) / y;            y *= gamma(beta);        } else {            y = gamma(beta) / y;            y *= gamma(alpha);        }    } else {        y = Math.exp(logGamma(alpha) + logGamma(beta) - logGamma(alpha + beta));    }    return y;}
70019ef5ff26e0f5b71378dcb1bd73be1d78d711bc50e9cc688877159e24274b
gamma
public static double gamma(double x)
{    double[] pCoefficient = { 1.60119522476751861407E-4, 1.19135147006586384913E-3, 1.04213797561761569935E-2, 4.76367800457137231464E-2, 2.07448227648435975150E-1, 4.94214826801497100753E-1, 9.99999999999999996796E-1 };    double[] qCoefficient = { -2.31581873324120129819E-5, 5.39605580493303397842E-4, -4.45641913851797240494E-3, 1.18139785222060435552E-2, 3.58236398605498653373E-2, -2.34591795718243348568E-1, 7.14304917030273074085E-2, 1.00000000000000000320E0 };            double p;    double z;    double q = Math.abs(x);    if (q > 33.0) {        if (x < 0.0) {            p = Math.floor(q);            if (p == q) {                throw new ArithmeticException("gamma: overflow");            }                        z = q - p;            if (z > 0.5) {                p += 1.0;                z = q - p;            }            z = q * Math.sin(Math.PI * z);            if (z == 0.0) {                throw new ArithmeticException("gamma: overflow");            }            z = Math.abs(z);            z = Math.PI / (z * stirlingFormula(q));            return -z;        } else {            return stirlingFormula(x);        }    }    z = 1.0;    while (x >= 3.0) {        x -= 1.0;        z *= x;    }    while (x < 0.0) {        if (x == 0.0) {            throw new ArithmeticException("gamma: singular");        }        if (x > -1.0e-9) {            return z / ((1.0 + 0.5772156649015329 * x) * x);        }        z /= x;        x += 1.0;    }    while (x < 2.0) {        if (x == 0.0) {            throw new ArithmeticException("gamma: singular");        }        if (x < 1.0e-9) {            return z / ((1.0 + 0.5772156649015329 * x) * x);        }        z /= x;        x += 1.0;    }    if ((x == 2.0) || (x == 3.0)) {        return z;    }    x -= 2.0;    p = Polynomial.polevl(x, pCoefficient, 6);    q = Polynomial.polevl(x, qCoefficient, 7);    return z * p / q;}
e042d7e91f9fe0259a6bbe045ffafadbb3324ee6f64baefe48e34fb7a8f28751
incompleteBeta
public static double incompleteBeta(double alpha, double beta, double xx)
{    if (alpha <= 0.0) {        throw new ArithmeticException("incompleteBeta: Domain error! alpha must be > 0, but was " + alpha);    }    if (beta <= 0.0) {        throw new ArithmeticException("incompleteBeta: Domain error! beta must be > 0, but was " + beta);    }    if (xx <= 0.0) {        return 0.0;    }    if (xx >= 1.0) {        return 1.0;    }    double t;    if ((beta * xx) <= 1.0 && xx <= 0.95) {        t = powerSeries(alpha, beta, xx);        return t;    }    double w = 1.0 - xx;    /* Reverse a and b if x is greater than the mean. */    double xc;    double x;    double b;    double a;    boolean flag = false;    if (xx > (alpha / (alpha + beta))) {        flag = true;        a = beta;        b = alpha;        xc = xx;        x = w;    } else {        a = alpha;        b = beta;        xc = w;        x = xx;    }    if (flag && (b * x) <= 1.0 && x <= 0.95) {        t = powerSeries(a, b, x);        t = t <= Constants.MACHEP ? 1.0 - Constants.MACHEP : 1.0 - t;        return t;    }    /* Choose expansion for better convergence. */    double y = x * (a + b - 2.0) - (a - 1.0);    w = y < 0.0 ? incompleteBetaFraction1(a, b, x) : incompleteBetaFraction2(a, b, x) / xc;    /* Multiply w by the factor       a      b   _             _     _      x  (1-x)   | (a+b) / ( a | (a) | (b) ) .   */    y = a * Math.log(x);    t = b * Math.log(xc);    if ((a + b) < Constants.MAXGAM && Math.abs(y) < Constants.MAXLOG && Math.abs(t) < Constants.MAXLOG) {        t = Math.pow(xc, b);        t *= Math.pow(x, a);        t /= a;        t *= w;        t *= gamma(a + b) / (gamma(a) * gamma(b));        if (flag) {            t = t <= Constants.MACHEP ? 1.0 - Constants.MACHEP : 1.0 - t;        }        return t;    }    /* Resort to logarithms.  */    y += t + logGamma(a + b) - logGamma(a) - logGamma(b);    y += Math.log(w / a);    t = y < Constants.MINLOG ? 0.0 : Math.exp(y);    if (flag) {        t = t <= Constants.MACHEP ? 1.0 - Constants.MACHEP : 1.0 - t;    }    return t;}
39ae13b346446684e0d18a27d9acdebb40611634eab00484e926f5049a0179e2
incompleteBetaFraction1
 static double incompleteBetaFraction1(double a, double b, double x)
{    double k1 = a;    double k2 = a + b;    double k3 = a;    double k4 = a + 1.0;    double k5 = 1.0;    double k6 = b - 1.0;    double k7 = k4;    double k8 = a + 2.0;    double pkm2 = 0.0;    double qkm2 = 1.0;    double pkm1 = 1.0;    double qkm1 = 1.0;    double ans = 1.0;    double r = 1.0;    int n = 0;    double thresh = 3.0 * Constants.MACHEP;    do {        double xk = -(x * k1 * k2) / (k3 * k4);        double pk = pkm1 + pkm2 * xk;        double qk = qkm1 + qkm2 * xk;        pkm2 = pkm1;        pkm1 = pk;        qkm2 = qkm1;        qkm1 = qk;        xk = (x * k5 * k6) / (k7 * k8);        pk = pkm1 + pkm2 * xk;        qk = qkm1 + qkm2 * xk;        pkm2 = pkm1;        pkm1 = pk;        qkm2 = qkm1;        qkm1 = qk;        if (qk != 0) {            r = pk / qk;        }        double t;        if (r != 0) {            t = Math.abs((ans - r) / r);            ans = r;        } else {            t = 1.0;        }        if (t < thresh) {            return ans;        }        k1 += 1.0;        k2 += 1.0;        k3 += 2.0;        k4 += 2.0;        k5 += 1.0;        k6 -= 1.0;        k7 += 2.0;        k8 += 2.0;        if ((Math.abs(qk) + Math.abs(pk)) > Constants.BIG) {            pkm2 *= Constants.BIG_INVERSE;            pkm1 *= Constants.BIG_INVERSE;            qkm2 *= Constants.BIG_INVERSE;            qkm1 *= Constants.BIG_INVERSE;        }        if ((Math.abs(qk) < Constants.BIG_INVERSE) || (Math.abs(pk) < Constants.BIG_INVERSE)) {            pkm2 *= Constants.BIG;            pkm1 *= Constants.BIG;            qkm2 *= Constants.BIG;            qkm1 *= Constants.BIG;        }    } while (++n < 300);    return ans;}
a432f9562a8cd646e4f55e5fe21db05e98ac5006737bc9ba80574107453abfff
incompleteBetaFraction2
 static double incompleteBetaFraction2(double a, double b, double x)
{    double k1 = a;    double k2 = b - 1.0;    double k3 = a;    double k4 = a + 1.0;    double k5 = 1.0;    double k6 = a + b;    double k7 = a + 1.0;    double k8 = a + 2.0;    double pkm2 = 0.0;    double qkm2 = 1.0;    double pkm1 = 1.0;    double qkm1 = 1.0;    double z = x / (1.0 - x);    double ans = 1.0;    double r = 1.0;    int n = 0;    double thresh = 3.0 * Constants.MACHEP;    do {        double xk = -(z * k1 * k2) / (k3 * k4);        double pk = pkm1 + pkm2 * xk;        double qk = qkm1 + qkm2 * xk;        pkm2 = pkm1;        pkm1 = pk;        qkm2 = qkm1;        qkm1 = qk;        xk = (z * k5 * k6) / (k7 * k8);        pk = pkm1 + pkm2 * xk;        qk = qkm1 + qkm2 * xk;        pkm2 = pkm1;        pkm1 = pk;        qkm2 = qkm1;        qkm1 = qk;        if (qk != 0) {            r = pk / qk;        }        double t;        if (r != 0) {            t = Math.abs((ans - r) / r);            ans = r;        } else {            t = 1.0;        }        if (t < thresh) {            return ans;        }        k1 += 1.0;        k2 -= 1.0;        k3 += 2.0;        k4 += 2.0;        k5 += 1.0;        k6 += 1.0;        k7 += 2.0;        k8 += 2.0;        if ((Math.abs(qk) + Math.abs(pk)) > Constants.BIG) {            pkm2 *= Constants.BIG_INVERSE;            pkm1 *= Constants.BIG_INVERSE;            qkm2 *= Constants.BIG_INVERSE;            qkm1 *= Constants.BIG_INVERSE;        }        if ((Math.abs(qk) < Constants.BIG_INVERSE) || (Math.abs(pk) < Constants.BIG_INVERSE)) {            pkm2 *= Constants.BIG;            pkm1 *= Constants.BIG;            qkm2 *= Constants.BIG;            qkm1 *= Constants.BIG;        }    } while (++n < 300);    return ans;}
86338a8972d314343e53da5253109d0b95363e4b745bbfa2cb9694ba804e3c3a
incompleteGamma
public static double incompleteGamma(double alpha, double x)
{    if (x <= 0 || alpha <= 0) {        return 0.0;    }    if (x > 1.0 && x > alpha) {        return 1.0 - incompleteGammaComplement(alpha, x);    }    /* Compute  x**a * exp(-x) / gamma(a)  */    double ax = alpha * Math.log(x) - x - logGamma(alpha);    if (ax < -Constants.MAXLOG) {        return 0.0;    }    ax = Math.exp(ax);    /* power series */    double r = alpha;    double c = 1.0;    double ans = 1.0;    do {        r += 1.0;        c *= x / r;        ans += c;    } while (c / ans > Constants.MACHEP);    return ans * ax / alpha;}
f7965f38d73211766653dc0f2accfe5c4b4bd4ff74bd99c477347c00e28be724
incompleteGammaComplement
public static double incompleteGammaComplement(double alpha, double x)
{    if (x <= 0 || alpha <= 0) {        return 1.0;    }    if (x < 1.0 || x < alpha) {        return 1.0 - incompleteGamma(alpha, x);    }    double ax = alpha * Math.log(x) - x - logGamma(alpha);    if (ax < -Constants.MAXLOG) {        return 0.0;    }    ax = Math.exp(ax);    /* continued fraction */    double y = 1.0 - alpha;    double z = x + y + 1.0;    double c = 0.0;    double pkm2 = 1.0;    double qkm2 = x;    double pkm1 = x + 1.0;    double qkm1 = z * x;    double ans = pkm1 / qkm1;    double t;    do {        c += 1.0;        y += 1.0;        z += 2.0;        double yc = y * c;        double pk = pkm1 * z - pkm2 * yc;        double qk = qkm1 * z - qkm2 * yc;        if (qk != 0) {            double r = pk / qk;            t = Math.abs((ans - r) / r);            ans = r;        } else {            t = 1.0;        }        pkm2 = pkm1;        pkm1 = pk;        qkm2 = qkm1;        qkm1 = qk;        if (Math.abs(pk) > Constants.BIG) {            pkm2 *= Constants.BIG_INVERSE;            pkm1 *= Constants.BIG_INVERSE;            qkm2 *= Constants.BIG_INVERSE;            qkm1 *= Constants.BIG_INVERSE;        }    } while (t > Constants.MACHEP);    return ans * ax;}
e52512334b1c19b4bfc140b2535288b63a69867aa2a86be1ef61aeeda8f3bb9b
logGamma
public static double logGamma(double x)
{    double p;    double q;    double z;    double[] aCoefficient = { 8.11614167470508450300E-4, -5.95061904284301438324E-4, 7.93650340457716943945E-4, -2.77777777730099687205E-3, 8.33333333333331927722E-2 };    double[] bCoefficient = { -1.37825152569120859100E3, -3.88016315134637840924E4, -3.31612992738871184744E5, -1.16237097492762307383E6, -1.72173700820839662146E6, -8.53555664245765465627E5 };    double[] cCoefficient = { /* 1.00000000000000000000E0, */    -3.51815701436523470549E2, -1.70642106651881159223E4, -2.20528590553854454839E5, -1.13933444367982507207E6, -2.53252307177582951285E6, -2.01889141433532773231E6 };    if (x < -34.0) {        q = -x;        double w = logGamma(q);        p = Math.floor(q);        if (p == q) {            throw new ArithmeticException("lgam: Overflow");        }        z = q - p;        if (z > 0.5) {            p += 1.0;            z = p - q;        }        z = q * Math.sin(Math.PI * z);        if (z == 0.0) {            throw new ArithmeticException("lgamma: Overflow");        }        z = Constants.LOGPI - Math.log(z) - w;        return z;    }    if (x < 13.0) {        z = 1.0;        while (x >= 3.0) {            x -= 1.0;            z *= x;        }        while (x < 2.0) {            if (x == 0.0) {                throw new ArithmeticException("lgamma: Overflow");            }            z /= x;            x += 1.0;        }        if (z < 0.0) {            z = -z;        }        if (x == 2.0) {            return Math.log(z);        }        x -= 2.0;        p = x * Polynomial.polevl(x, bCoefficient, 5) / Polynomial.p1evl(x, cCoefficient, 6);        return Math.log(z) + p;    }    if (x > 2.556348e305) {        throw new ArithmeticException("lgamma: Overflow");    }    q = (x - 0.5) * Math.log(x) - x + 0.91893853320467274178;        if (x > 1.0e8) {        return q;    }    p = 1.0 / (x * x);    if (x >= 1000.0) {        q += ((7.9365079365079365079365e-4 * p - 2.7777777777777777777778e-3) * p + 0.0833333333333333333333) / x;    } else {        q += Polynomial.polevl(p, aCoefficient, 4) / x;    }    return q;}
e64f4462523ed35f45f1857ace4a56ad3a61a7ef720d50d06ba5374a47fa14fc
powerSeries
private static double powerSeries(double a, double b, double x)
{    double ai = 1.0 / a;    double u = (1.0 - b) * x;    double v = u / (a + 1.0);    double t1 = v;    double t = u;    double n = 2.0;    double s = 0.0;    double z = Constants.MACHEP * ai;    while (Math.abs(v) > z) {        u = (n - b) * x / n;        t *= u;        v = t / (a + n);        s += v;        n += 1.0;    }    s += t1;    s += ai;    u = a * Math.log(x);    if ((a + b) < Constants.MAXGAM && Math.abs(u) < Constants.MAXLOG) {        t = gamma(a + b) / (gamma(a) * gamma(b));        s *= t * Math.pow(x, a);    } else {        t = logGamma(a + b) - logGamma(a) - logGamma(b) + u + Math.log(s);        s = t < Constants.MINLOG ? 0.0 : Math.exp(t);    }    return s;}
0329e06d70d829f13d5d5e4feceed01f067f8bdaff8e225e179969c961b0c233
stirlingFormula
 static double stirlingFormula(double x)
{    double[] coefficients = { 7.87311395793093628397E-4, -2.29549961613378126380E-4, -2.68132617805781232825E-3, 3.47222221605458667310E-3, 8.33333333333482257126E-2 };    double w = 1.0 / x;    double y = Math.exp(x);    w = 1.0 + w * Polynomial.polevl(w, coefficients, 4);    if (x > MAXSTIR) {        /* Avoid overflow in Math.pow() */        double v = Math.pow(x, 0.5 * x - 0.25);        y = v * (v / y);    } else {        y = Math.pow(x, x - 0.5) / y;    }    y = Constants.SQTPI * y * w;    return y;}
ea48ced29cc3cc5ccb123aa01f54a1ede34188b0274eeff3332a79d56c7501dc
beta
public static double beta(double a, double b, double x)
{    return Gamma.incompleteBeta(a, b, x);}
b46a2ad977ec1ca26382b3c5af0de3437fee13735141287e13af6ebd74b11ae4
gamma
public static double gamma(double alpha, double beta, double x)
{    if (x < 0.0) {        return 0.0;    }    return Gamma.incompleteGamma(alpha, beta * x);}
3f103f7e0d342431d9490ab82d328315f08966221c7044244474994d7f98f1f5
negativeBinomial
public static double negativeBinomial(int k, int n, double p)
{    if (p < 0.0 || p > 1.0) {        throw new IllegalArgumentException();    }    if (k < 0) {        return 0.0;    }    return Gamma.incompleteBeta(n, k + 1, p);}
cf1868a06a0f87d81822312659c60b7862dbd42fbc51a362cf726ed993a0f035
normal
public static double normal(double a)
{    if (a < 0) {        return 1 - normal(-a);    }    double b0 = 0.2316419;    double b1 = 0.319381530;    double b2 = -0.356563782;    double b3 = 1.781477937;    double b4 = -1.821255978;    double b5 = 1.330274429;    double t = 1 / (1 + b0 * a);    return 1 - UNIT_NORMAL.pdf(a) * t * (b1 + t * (b2 + t * (b3 + t * (b4 + t * b5))));}
cc079da0b88d9494276d7904959697fbb033017be73ce9d59dee2b7abdfaa597
normal
public static double normal(double mean, double variance, double x)
{    return normal((x - mean) / Math.sqrt(variance));}
6ae68cefe9ab6e082b5d55316d2771481007f74e6bd0b1478394b6be632bd47e
poisson
public static double poisson(int k, double mean)
{    if (mean < 0) {        throw new IllegalArgumentException();    }    if (k < 0) {        return 0.0;    }    return Gamma.incompleteGammaComplement(k + 1, mean);}
803915e853382ad445a6e2333fabb8beb8e4acd70e908a0d818400f7baac42af
isEmpty
public boolean isEmpty()
{    return size() == 0;}
ac28d2fd7eaa1a2f7c8ca82ea678ab2f4d2447886b869d88cd9f3637a0f2f6ee
checkRange
protected static void checkRange(int index, int theSize)
{    if (index >= theSize || index < 0) {        throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + theSize);    }}
079d6acd2a2eabc77865de0d5e66a9ae6529a43b371d2dbc9d8fbc9134c82ac8
checkRangeFromTo
protected static void checkRangeFromTo(int from, int to, int theSize)
{    if (to == from - 1) {        return;    }    if (from < 0 || from > to || to >= theSize) {        throw new IndexOutOfBoundsException("from: " + from + ", to: " + to + ", size=" + theSize);    }}
21ac40bb9a99614b6ac18fa4043acb6173fccff96066fdfab963dba597923aa8
clear
public void clear()
{    removeFromTo(0, size() - 1);}
142399cf26737c1013b2c6bc47a3aea1b3d6a52adb8f136c6872a2374315a181
mergeSort
public final void mergeSort()
{    mergeSortFromTo(0, size() - 1);}
ce009c6eadfb4a08c5d4447133dedfffae9b8d3ee72c1e403dbd71330a70be5a
quickSort
public final void quickSort()
{    quickSortFromTo(0, size() - 1);}
53a4856efb72f89f1582facf9bc4bc079c5d84f39c93280cfcef2d56b3548f1b
remove
public void remove(int index)
{    removeFromTo(index, index);}
f7c2d4c24253a17c407d51cd312cbfe625fa5c1784c72df2e100dba532ec3ba1
setSize
public void setSize(int newSize)
{    if (newSize < 0) {        throw new IndexOutOfBoundsException("newSize:" + newSize);    }    int currentSize = size();    if (newSize != currentSize) {        if (newSize > currentSize) {            beforeInsertDummies(currentSize, newSize - currentSize);        } else if (newSize < currentSize) {            removeFromTo(newSize, currentSize - 1);        }    }}
a8945e5388ee967b5706991facc6b3b7be30470945a2ed57bb908602bd075bdc
sort
public final void sort()
{    sortFromTo(0, size() - 1);}
c4d0601260f028b2bec1b2aa930518eba8f375fe8d918dda9edbefc94e3d1860
sortFromTo
public void sortFromTo(int from, int to)
{    quickSortFromTo(from, to);}
577f4cd5f98829ce6ec558dccdb1c96abfae1c1a25d2ae1fc5091b3240da3a9f
trimToSize
public void trimToSize()
{}
740f5721d4da33e064597b661b3d9f198f43f4cf4a0e775319067e6f14ce36e7
addAllOf
public void addAllOf(Collection<T> collection)
{    this.beforeInsertAllOf(size(), collection);}
e0fa6de669a2a559c91e4d9a25a3df42a2e658368f3b16f18672c5df5b2b8f9d
beforeInsertAllOf
public void beforeInsertAllOf(int index, Collection<T> collection)
{    this.beforeInsertDummies(index, collection.size());    this.replaceFromWith(index, collection);}
17c9e8180eb841a3cecf1fdbcd5e07c8eb4796e5815a044038578c64d65b3a0c
add
public void add(T element)
{        if (size == elements.length) {        ensureCapacity(size + 1);    }    elements[size++] = element;}
5866adb286af8e0856d1e4725e8b2df09f494691ff09bb3f76d37046f1931b67
beforeInsert
public void beforeInsert(int index, T element)
{        if (size == index) {        add(element);        return;    }    if (index > size || index < 0) {        throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + size);    }    ensureCapacity(size + 1);    System.arraycopy(elements, index, elements, index + 1, size - index);    elements[index] = element;    size++;}
38a346dd3b669981824e4b3da3c5ad6417c63d84aae517cdaa4a223d2c21e809
clone
public Object clone()
{        return new ObjectArrayList<>((T[]) elements.clone());}
3267d936d72919187fa38adb207e7923e5b6212a4b17370168c87eb260b4493c
copy
public ObjectArrayList<T> copy()
{    return (ObjectArrayList<T>) clone();}
eac8224c2706b11786a5360d83cb8d98085d4d1e5324500b2504084c6b4e4865
elements
public Q[] elements()
{    return (Q[]) elements;}
bf41f746a2ba963100faa68513b3dd3758dbf9dd7f54bf7003dfd5c3ddbe959c
elements
public void elements(T[] elements)
{    this.elements = elements;    this.size = elements.length;}
be0b2467f7b5e58f8b28ca8784d0600afe40ba905bba892ecd9810a97065f8b7
ensureCapacity
public void ensureCapacity(int minCapacity)
{    elements = org.apache.mahout.math.Arrays.ensureCapacity(elements, minCapacity);}
4da4c9108caf01a69f9ca5c792c928a808e92a8f8fef8e45be859eacec50b679
equals
public boolean equals(Object otherObj)
{        if (!(otherObj instanceof ObjectArrayList)) {        return super.equals(otherObj);    }    if (this == otherObj) {        return true;    }    if (otherObj == null) {        return false;    }    ObjectArrayList<?> other = (ObjectArrayList<?>) otherObj;    if (size() != other.size()) {        return false;    }    Object[] theElements = elements();    Object[] otherElements = other.elements();    for (int i = size(); --i >= 0; ) {        if (theElements[i] != otherElements[i]) {            return false;        }    }    return true;}
61974437eb704617187045dc35bfd2a764857c083f63cac339eeec74ff1b60af
forEach
public boolean forEach(ObjectProcedure<T> procedure)
{    T[] theElements = (T[]) elements;    int theSize = size;    for (int i = 0; i < theSize; ) {        if (!procedure.apply(theElements[i++])) {            return false;        }    }    return true;}
fb7cc3fa89c6cf5565bb2f49f545c6d4fa154a18e341a22f06755b7044504a56
get
public T get(int index)
{        if (index >= size || index < 0) {        throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + size);    }    return (T) elements[index];}
c6872161dc867e4b4fe8618bde00d6482fe0969c387f547181077480190757b2
getQuick
public T getQuick(int index)
{    return (T) elements[index];}
85fdbb66fadc4ca0ef5c1bcbb406f7546f7cf37217b55d606dc82508d1d01171
indexOfFromTo
public int indexOfFromTo(T element, int from, int to)
{        if (size == 0) {        return -1;    }    checkRangeFromTo(from, to, size);    Object[] theElements = elements;    for (int i = from; i <= to; i++) {        if (element == theElements[i]) {            return i;        }        }        return -1;}
0cfa387deb46215c88e2298f1ac99c6c851cc368c4ced81230bafd0f40b77890
lastIndexOfFromTo
public int lastIndexOfFromTo(T element, int from, int to)
{        if (size == 0) {        return -1;    }    checkRangeFromTo(from, to, size);    Object[] theElements = elements;    for (int i = to; i >= from; i--) {        if (element == theElements[i]) {            return i;        }        }        return -1;}
b36869cbbb5a2bc483e1bdbedda1cc6a8d25bb2b93e8840a1338a53a27d4abbe
partFromTo
public AbstractObjectList<T> partFromTo(int from, int to)
{    if (size == 0) {        return new ObjectArrayList<>(0);    }    checkRangeFromTo(from, to, size);    Object[] part = new Object[to - from + 1];    System.arraycopy(elements, from, part, 0, to - from + 1);    return new ObjectArrayList<>((T[]) part);}
e9cd56aec1b5462fc8dd3242dac0377e66cb728e3d4dd814234d4428968b6ab3
reverse
public void reverse()
{        int limit = size / 2;    int j = size - 1;    Object[] theElements = elements;    for (int i = 0; i < limit; ) {                Object tmp = theElements[i];        theElements[i++] = theElements[j];        theElements[j--] = tmp;    }}
ddfe97a3705dde6480918c04cd82f616148172adb6fec4e1ca39e0be4fe6bb2e
set
public void set(int index, T element)
{        if (index >= size || index < 0) {        throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + size);    }    elements[index] = element;}
1637ae3d947dfcd50807c14de56e367d491ed98009c26f41ba58c2a3c835130a
setQuick
public void setQuick(int index, T element)
{    elements[index] = element;}
577f4cd5f98829ce6ec558dccdb1c96abfae1c1a25d2ae1fc5091b3240da3a9f
trimToSize
public void trimToSize()
{    elements = org.apache.mahout.math.Arrays.trimToCapacity(elements, size());}
81dac895c26d17efeac32f60dd50b1e7193b1ac69d1afcc43d9821137304504a
removeFromTo
public void removeFromTo(int fromIndex, int toIndex)
{    throw new UnsupportedOperationException();}
cb18c3aa17f9b6129efacb89d5cd6147cdf1d441e7d7ec7927d8eaec9490267b
replaceFromWith
public void replaceFromWith(int from, Collection<T> other)
{    throw new UnsupportedOperationException();}
b108221322352227a2453ecd6c2b31cb3233bcc24085b9b556ff6c192fbe7d5f
beforeInsertDummies
protected void beforeInsertDummies(int index, int length)
{    throw new UnsupportedOperationException();}
35e0a8f12b05999c587e682cd1da5d3ade5082ca1e332145ae72e4df12e26c30
mergeSortFromTo
public void mergeSortFromTo(int from, int to)
{    throw new UnsupportedOperationException();}
37d3c6ca1c099f53b7d0acd65aac5b545007b046917c87d254739ba0efd4a2c3
quickSortFromTo
public void quickSortFromTo(int from, int to)
{    throw new UnsupportedOperationException();}
72ef1e59027007ffe0950edfd2670ad03bb65cd6463d5d1d282dfeb1750435b0
size
public int size()
{    return size;}
be0b2467f7b5e58f8b28ca8784d0600afe40ba905bba892ecd9810a97065f8b7
ensureCapacity
public void ensureCapacity(int minCapacity)
{    elements = org.apache.mahout.math.Arrays.ensureCapacity(elements, minCapacity);}
57ab9392f24a46ec423cadcf7800be692f205618cec980cc32c845933fde9059
getQuick
protected long getQuick(int index)
{    return elements[index];}
fe98ca9d0cc45d4c51015b7d5df0f13333af05c3e1acaa205c3db2ebe0400f8c
setQuick
protected void setQuick(int index, long element)
{    elements[index] = element;}
577f4cd5f98829ce6ec558dccdb1c96abfae1c1a25d2ae1fc5091b3240da3a9f
trimToSize
public void trimToSize()
{    elements = org.apache.mahout.math.Arrays.trimToCapacity(elements, size());}
ea0115c88daa3661a0edfa9b3c1fba3cd0f123ddacb44e69b9aefe509b7191ce
hash
public static int hash(char value)
{    return value;}
f53938d8fc51b52859eb5994962fc476d60b72f1a59df1b52cec22603397d432
hash
public static int hash(double value)
{    long bits = Double.doubleToLongBits(value);    return (int) (bits ^ (bits >>> 32));}
48be5d6f5e962b56bd5ab63b9e294b29a09da6d3a98aa87a53575de4cea329d9
hash
public static int hash(float value)
{    return Float.floatToIntBits(value * 663608941.737f);}
f5a27902dc9ddfc92a9ac05d66f0a20ce125761081a3a4087bce86ab6539c0c0
hash
public static int hash(int value)
{    int h = value;    h ^= h >>> 16;    h *= 0x85ebca6b;    h ^= h >>> 13;    h *= 0xc2b2ae35;    h ^= h >>> 16;    return h;}
5d46733f6ff4b6c958132aabc6ff0609b9a7d6dd2aa42a11c8f05eab0f0a0242
hash
public static int hash(long value)
{    return (int) (value ^ (value >> 32));/*    value &= 0x7FFFFFFFFFFFFFFFL;     int hashCode = 0;    do hashCode = 31*hashCode + (int) (value%10);    while ((value /= 10) > 0);    return 28629151*hashCode;     */}
e7bec6566c55ebc386951b408066b4f86dde57f375218541047a4d3e12a65d19
hash
public static int hash(Object object)
{    return object == null ? 0 : object.hashCode();}
10be70a0532b0e1e7a5c04e74367db648ff1991d53dd5d977292b7c51c9c5499
hash
public static int hash(short value)
{    return value;}
dc6fac53fbc454a98c5d96ba4c9181bb07c2851d4440487730b86f35b4be96c1
hash
public static int hash(boolean value)
{    return value ? 1231 : 1237;}
21ac40bb9a99614b6ac18fa4043acb6173fccff96066fdfab963dba597923aa8
clear
public void clear()
{    Arrays.fill(this.state, FREE);    distinct = 0;        freeEntries = table.length;    trimToSize();}
38a346dd3b669981824e4b3da3c5ad6417c63d84aae517cdaa4a223d2c21e809
clone
public Object clone()
{    OpenHashMap<K, V> copy = (OpenHashMap<K, V>) super.clone();    copy.table = copy.table.clone();    copy.values = copy.values.clone();    copy.state = copy.state.clone();    return copy;}
10251f6cf636f49b599299432df558beac5bc221e8b028def33778ce8ebe248a
containsKey
public boolean containsKey(Object key)
{    return indexOfKey((K) key) >= 0;}
c628f36c081e450f86a9e82a881e3e7747dea6b3d315f9d7efd8f5266497cb73
containsValue
public boolean containsValue(Object value)
{    return indexOfValue((V) value) >= 0;}
be0b2467f7b5e58f8b28ca8784d0600afe40ba905bba892ecd9810a97065f8b7
ensureCapacity
public void ensureCapacity(int minCapacity)
{    if (table.length < minCapacity) {        int newCapacity = nextPrime(minCapacity);        rehash(newCapacity);    }}
f082f5d490bac2221b5c8bca0b7f47960b97f986d1ad8f685ba2de132347019e
forEachKey
public boolean forEachKey(ObjectProcedure<K> procedure)
{    for (int i = table.length; i-- > 0; ) {        if (state[i] == FULL && !procedure.apply((K) table[i])) {            return false;        }    }    return true;}
ddd5c7c36c3e4feb556e1d02eba5f979db3067da9610ec26e2cab412c6126e5d
forEachPair
public boolean forEachPair(ObjectObjectProcedure<K, V> procedure)
{    for (int i = table.length; i-- > 0; ) {        if (state[i] == FULL && !procedure.apply((K) table[i], (V) values[i])) {            return false;        }    }    return true;}
bff87e54075ba5d5421bf5ff5db42cbe90d6f2d40bf112005070d80ee9873381
get
public V get(Object key)
{    int i = indexOfKey((K) key);    if (i < 0) {        return null;    }        return (V) values[i];}
6c9dd3ea1f1645329a9deecda6cabc7b00ebc87e9b32fa1d1f2e6836142eb977
indexOfInsertion
protected int indexOfInsertion(K key)
{    Object[] tab = table;    byte[] stat = state;    int length = tab.length;    int hash = key.hashCode() & 0x7FFFFFFF;    int i = hash % length;        int decrement = hash % (length - 2);        if (decrement == 0) {        decrement = 1;    }        while (stat[i] == FULL && !equalsMindTheNull(key, tab[i])) {        i -= decrement;                if (i < 0) {            i += length;        }    }    if (stat[i] == REMOVED) {                                int j = i;        while (stat[i] != FREE && (stat[i] == REMOVED || tab[i] != key)) {            i -= decrement;                        if (i < 0) {                i += length;            }        }        if (stat[i] == FREE) {            i = j;        }    }    if (stat[i] == FULL) {                return -i - 1;    }        return i;}
e7529c417aba1a5f1aa5a88bf33ea0f2ab5d4cddb528680c65a94f6cacbcb35f
indexOfKey
protected int indexOfKey(K key)
{    Object[] tab = table;    byte[] stat = state;    int length = tab.length;    int hash = key.hashCode() & 0x7FFFFFFF;    int i = hash % length;        int decrement = hash % (length - 2);        if (decrement == 0) {        decrement = 1;    }        while (stat[i] != FREE && (stat[i] == REMOVED || !equalsMindTheNull(key, tab[i]))) {        i -= decrement;                if (i < 0) {            i += length;        }    }    if (stat[i] == FREE) {        return -1;    }        return i;}
522b6c7176408e4d471e8e50a85b3bb4ac5b12f86b054ca76a3524ebbc9f6651
indexOfValue
protected int indexOfValue(V value)
{    Object[] val = values;    byte[] stat = state;    for (int i = stat.length; --i >= 0; ) {        if (stat[i] == FULL && equalsMindTheNull(val[i], value)) {            return i;        }    }        return -1;}
640d833ea48579c519eba4d7a7e9b1670da149f430c4febefab62ee6fabe05f1
keys
public void keys(List<K> list)
{    list.clear();    Object[] tab = table;    byte[] stat = state;    for (int i = tab.length; i-- > 0; ) {        if (stat[i] == FULL) {            list.add((K) tab[i]);        }    }}
1872e986b4afc45b25826345adf05e6c986d61445f72dd373c75c28af725bf99
put
public V put(K key, V value)
{    int i = indexOfInsertion(key);    if (i < 0) {                i = -i - 1;        V previous = (V) this.values[i];        this.values[i] = value;        return previous;    }    if (this.distinct > this.highWaterMark) {        int newCapacity = chooseGrowCapacity(this.distinct + 1, this.minLoadFactor, this.maxLoadFactor);        rehash(newCapacity);        return put(key, value);    }    this.table[i] = key;    this.values[i] = value;    if (this.state[i] == FREE) {        this.freeEntries--;    }    this.state[i] = FULL;    this.distinct++;    if (this.freeEntries < 1) {                int newCapacity = chooseGrowCapacity(this.distinct + 1, this.minLoadFactor, this.maxLoadFactor);        rehash(newCapacity);    }    return null;}
3130a51aadf6d2e269883da01b916f779c74c7e49497879787945ad4bcb1b220
rehash
protected void rehash(int newCapacity)
{    int oldCapacity = table.length;        Object[] oldTable = table;    Object[] oldValues = values;    byte[] oldState = state;    Object[] newTable = new Object[newCapacity];    Object[] newValues = new Object[newCapacity];    byte[] newState = new byte[newCapacity];    this.lowWaterMark = chooseLowWaterMark(newCapacity, this.minLoadFactor);    this.highWaterMark = chooseHighWaterMark(newCapacity, this.maxLoadFactor);    this.table = newTable;    this.values = newValues;    this.state = newState;        this.freeEntries = newCapacity - this.distinct;    for (int i = oldCapacity; i-- > 0; ) {        if (oldState[i] == FULL) {            Object element = oldTable[i];            int index = indexOfInsertion((K) element);            newTable[index] = element;            newValues[index] = oldValues[i];            newState[index] = FULL;        }    }}
d3d9cbefed45d3eba7ffb31735e6c0cc3079bba6649ecef7eae69b6429c3717d
remove
public V remove(Object key)
{    int i = indexOfKey((K) key);    if (i < 0) {        return null;    }        V removed = (V) values[i];    this.state[i] = REMOVED;        this.distinct--;    if (this.distinct < this.lowWaterMark) {        int newCapacity = chooseShrinkCapacity(this.distinct, this.minLoadFactor, this.maxLoadFactor);        rehash(newCapacity);    }    return removed;}
e1955a0aa5ca13f5a4033d86ef28afd7506fc77f95cb9c9350ffe6ebb40519f7
setUp
protected void setUp(int initialCapacity, double minLoadFactor, double maxLoadFactor)
{    int capacity = initialCapacity;    super.setUp(capacity, minLoadFactor, maxLoadFactor);    capacity = nextPrime(capacity);    if (capacity == 0) {        capacity = 1;    }        this.table = new Object[capacity];    this.values = new Object[capacity];    this.state = new byte[capacity];        this.minLoadFactor = minLoadFactor;    if (capacity == PrimeFinder.LARGEST_PRIME) {        this.maxLoadFactor = 1.0;    } else {        this.maxLoadFactor = maxLoadFactor;    }    this.distinct = 0;        this.freeEntries = capacity;                    this.lowWaterMark = 0;    this.highWaterMark = chooseHighWaterMark(capacity, this.maxLoadFactor);}
577f4cd5f98829ce6ec558dccdb1c96abfae1c1a25d2ae1fc5091b3240da3a9f
trimToSize
public void trimToSize()
{            int newCapacity = nextPrime((int) (1 + 1.2 * size()));    if (table.length > newCapacity) {        rehash(newCapacity);    }}
dfe0e641cb95ab8e03d5d8e0402fb5461fdecc76135d6ed370108bd73f75fbc9
getInternalFactors
 void getInternalFactors(int[] capacity, double[] minLoadFactor, double[] maxLoadFactor)
{    capacity[0] = table.length;    minLoadFactor[0] = this.minLoadFactor;    maxLoadFactor[0] = this.maxLoadFactor;}
408af2012690314114a03f0ca626970e41121b2f610127a0eacfc4e43e74dbfe
getKey
public K getKey()
{    return key;}
5a159708665ed864d795a0702d525a75a1e0d877881ccd093ed97ed18e382934
getValue
public V getValue()
{    return value;}
d8401f424036b4f728f70be90e19de421f30843cb3cd58fa6f7257c274ce398d
setValue
public V setValue(V value)
{    throw new UnsupportedOperationException("Map.Entry.setValue not supported for OpenHashMap");}
91e691aff155cc7bb07c7eb0801726d1ccd4d3ea4d70bb670036cb3e5709de63
entrySet
public Set<java.util.Map.Entry<K, V>> entrySet()
{    final Set<Entry<K, V>> entries = new OpenHashSet<>();    forEachPair(new ObjectObjectProcedure<K, V>() {        @Override        public boolean apply(K key, V value) {            entries.add(new MapEntry(key, value));            return true;        }    });    return entries;}
dd25a778cb79b6c989ccbdaa6e084db6147bccbdd6fbf4376c47967fa64c29e5
apply
public boolean apply(K key, V value)
{    entries.add(new MapEntry(key, value));    return true;}
c619c5c247e00c82e132c731db2d7dd646000c405d071795fcbfcba581649b68
keySet
public Set<K> keySet()
{    final Set<K> keys = new OpenHashSet<>();    forEachKey(new ObjectProcedure<K>() {        @Override        public boolean apply(K element) {            keys.add(element);            return true;        }    });    return keys;}
729552fb91e5383a8b3cdd4c8453d75271902f4de56a2f57d72f610087f97538
apply
public boolean apply(K element)
{    keys.add(element);    return true;}
9cd08e1d9cc34dc735163c11e8d09464e64d86756c215e59fe5d0a8b9431f555
putAll
public void putAll(Map<? extends K, ? extends V> m)
{    for (Map.Entry<? extends K, ? extends V> e : m.entrySet()) {        put(e.getKey(), e.getValue());    }}
86f8cd7f78364ea8a0d36935cf2e3d294cee8b3b9e21cfe6a555d22e54e37f60
values
public Collection<V> values()
{    final List<V> valueList = new ArrayList<>();    forEachPair(new ObjectObjectProcedure<K, V>() {        @Override        public boolean apply(K key, V value) {            valueList.add(value);            return true;        }    });    return valueList;}
dd25a778cb79b6c989ccbdaa6e084db6147bccbdd6fbf4376c47967fa64c29e5
apply
public boolean apply(K key, V value)
{    valueList.add(value);    return true;}
4afeb0868b55bdd8e18a00a3cb43d83e0714378d1c4bb36f0936daefc060e2e8
equals
public boolean equals(Object obj)
{    if (!(obj instanceof OpenHashMap)) {        return false;    }    final OpenHashMap<K, V> o = (OpenHashMap<K, V>) obj;    if (o.size() != size()) {        return false;    }    final boolean[] equal = new boolean[1];    equal[0] = true;    forEachPair(new ObjectObjectProcedure<K, V>() {        @Override        public boolean apply(K key, V value) {            Object ov = o.get(key);            if (!value.equals(ov)) {                equal[0] = false;                return false;            }            return true;        }    });    return equal[0];}
dd25a778cb79b6c989ccbdaa6e084db6147bccbdd6fbf4376c47967fa64c29e5
apply
public boolean apply(K key, V value)
{    Object ov = o.get(key);    if (!value.equals(ov)) {        equal[0] = false;        return false;    }    return true;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    final StringBuilder sb = new StringBuilder();    sb.append('{');    forEachPair(new ObjectObjectProcedure<K, V>() {        @Override        public boolean apply(K key, V value) {            sb.append('[');            sb.append(key);            sb.append(" -> ");            sb.append(value);            sb.append("] ");            return true;        }    });    sb.append('}');    return sb.toString();}
dd25a778cb79b6c989ccbdaa6e084db6147bccbdd6fbf4376c47967fa64c29e5
apply
public boolean apply(K key, V value)
{    sb.append('[');    sb.append(key);    sb.append(" -> ");    sb.append(value);    sb.append("] ");    return true;}
03d0fba6302e01becbdb77921580aa7222030acc6eef9d365fde8fb47da9c727
nextPrime
public static int nextPrime(int desiredCapacity)
{    int i = java.util.Arrays.binarySearch(PRIME_CAPACITIES, desiredCapacity);    if (i < 0) {                        i = -i - 1;    }    return PRIME_CAPACITIES[i];}
c440ccc8a1072d2ac4191f7de943616043ee7ed02d297fac18acf844fbeeabd0
put
public boolean put(int key, int value)
{    /*       This is open addressing with double hashing, using "Brent's variation".       Brent's variation slows insertions a bit down (not much) but reduces probes (collisions) for successful searches,       in particular for large load factors.       (It does not improve unsuccessful searches.)       See D. Knuth, Searching and Sorting, 3rd ed., p.533-545       h1(key) = hash % M       h2(key) = decrement = Max(1, hash/M % M)       M is prime = capacity = table.length       probing positions are table[(h1-j*h2) % M] for j=0,1,...       (M and h2 could also be chosen differently, but h2 is required to be relative prime to M.)    */    int[] tab = table;    byte[] stat = state;    int length = tab.length;    int hash = HashFunctions.hash(key) & 0x7FFFFFFF;    int i = hash % length;    int decrement = (hash / length) % length;    if (decrement == 0) {        decrement = 1;    }                    int t = 0;        int p0 = i;    while (stat[i] == FULL && tab[i] != key) {        t++;        i -= decrement;                if (i < 0) {            i += length;        }    }    if (stat[i] == FULL) {                this.values[i] = value;        return false;    }    if (this.distinct > this.highWaterMark) {        int newCapacity = chooseGrowCapacity(this.distinct + 1, this.minLoadFactor, this.maxLoadFactor);        rehash(newCapacity);        return put(key, value);    }    /*    Brent's variation does a local reorganization to reduce probes. It essentially means:    We test whether it is possible to move the association we probed first (table[p0]) out of the way.    If this is possible, it will reduce probes for the key to be inserted, since it takes its place;    it gets hit earlier.    However, future probes for the key that we move out of the way will increase.    Thus we only move it out of the way, if we have a net gain, that is, if we save more probes than we loose.    For the first probe we safe more than we loose if the number of probes we needed was >=2 (t>=2).    If the first probe cannot be moved out of the way, we try the next probe (p1).    Now we safe more than we loose if t>=3.    We repeat this until we find that we cannot gain or that we can indeed move p(x) out of the way.    Note: Under the great majority of insertions t<=1, so the loop is entered very infrequently.    */    while (t > 1) {        int key0 = tab[p0];        hash = HashFunctions.hash(key0) & 0x7FFFFFFF;        decrement = (hash / length) % length;        if (decrement == 0) {            decrement = 1;        }                int pc = p0 - decrement;        if (pc < 0) {            pc += length;        }        if (stat[pc] != FREE) {                        p0 = pc;            t--;        } else {                        tab[pc] = key0;            stat[pc] = FULL;            values[pc] = values[p0];                        i = p0;                        t = 0;        }    }    this.table[i] = key;    this.values[i] = value;    if (this.state[i] == FREE) {        this.freeEntries--;    }    this.state[i] = FULL;    this.distinct++;    if (this.freeEntries < 1) {                int newCapacity = chooseGrowCapacity(this.distinct + 1, this.minLoadFactor, this.maxLoadFactor);        rehash(newCapacity);    }    return true;}
3130a51aadf6d2e269883da01b916f779c74c7e49497879787945ad4bcb1b220
rehash
protected void rehash(int newCapacity)
{    int oldCapacity = table.length;        int[] oldTable = table;    int[] oldValues = values;    byte[] oldState = state;    int[] newTable = new int[newCapacity];    int[] newValues = new int[newCapacity];    byte[] newState = new byte[newCapacity];    this.lowWaterMark = chooseLowWaterMark(newCapacity, this.minLoadFactor);    this.highWaterMark = chooseHighWaterMark(newCapacity, this.maxLoadFactor);    this.table = newTable;    this.values = newValues;    this.state = newState;        this.freeEntries = newCapacity - this.distinct;    int tmp = this.distinct;        this.distinct = Integer.MIN_VALUE;    for (int i = oldCapacity; i-- > 0; ) {        if (oldState[i] == FULL) {            put(oldTable[i], oldValues[i]);        /*        int element = oldTable[i];        int index = indexOfInsertion(element);        newTable[index]=element;        newValues[index]=oldValues[i];        newState[index]=FULL;        */        }    }    this.distinct = tmp;}
2f278e1b463fe5468b0b61d1a0734fa3ea84518a9380b5b15aa428b77465045f
functionalMatrixView
public static Matrix functionalMatrixView(final int rows, final int columns, final IntIntFunction gf, final boolean denseLike)
{    return new FunctionalMatrixView(rows, columns, gf, denseLike);}
7f778804a09a0415b2e2b4858705ccb20bc9bae33f9c78df6172e504dfeb533f
functionalMatrixView
public static Matrix functionalMatrixView(final int rows, final int columns, final IntIntFunction gf)
{    return new FunctionalMatrixView(rows, columns, gf);}
ffd8ab6736877c720d3089c7cae411f9d5735ded748d0eca8a8e69a7998fb637
transposedView
public static Matrix transposedView(final Matrix m)
{    Preconditions.checkArgument(!(m instanceof SparseColumnMatrix));    if (m instanceof TransposedMatrixView) {        return ((TransposedMatrixView) m).getDelegate();    } else {        return new TransposedMatrixView(m);    }}
e94b70e4165c0107c081980a5e0227c8551883dd54e3ceb70500ed32efe49314
gaussianView
public static Matrix gaussianView(final int rows, final int columns, long seed)
{    return functionalMatrixView(rows, columns, gaussianGenerator(seed), true);}
431a5db4648af61320253f82b7ffd56412d68c3bc64f3b94fbf297d1c48c06f6
symmetricUniformView
public static Matrix symmetricUniformView(final int rows, final int columns, int seed)
{    return functionalMatrixView(rows, columns, uniformSymmetricGenerator(seed), true);}
bac66d9ddced00aa943ead3e7a3c6f79064726b6b1b046a5366301f07f869422
uniformView
public static Matrix uniformView(final int rows, final int columns, int seed)
{    return functionalMatrixView(rows, columns, uniformGenerator(seed), true);}
7f6ff4481aa7b4183b4fd50db63e3c64a64f0112d6dff93103ca971f94e08c97
gaussianGenerator
public static IntIntFunction gaussianGenerator(final long seed)
{    final Random rnd = RandomUtils.getRandom(seed);    return new IntIntFunction() {        @Override        public double apply(int first, int second) {            rnd.setSeed(seed ^ (((long) first << 32) | (second & 0xffffffffL)));            return rnd.nextGaussian();        }    };}
a97f178b457bb14a2d22443b1851744035fbd259aba9653f4f0ebfdbc6b5018d
apply
public double apply(int first, int second)
{    rnd.setSeed(seed ^ (((long) first << 32) | (second & 0xffffffffL)));    return rnd.nextGaussian();}
bc52af284be7a6c8bb366c00bc7194d51c334fca1bcd408305b6ef2e1aaad47f
uniformSymmetricGenerator
public static IntIntFunction uniformSymmetricGenerator(final int seed)
{    return new IntIntFunction() {        private byte[] data = new byte[8];        @Override        public double apply(int row, int column) {            long d = ((long) row << Integer.SIZE) | (column & 0xffffffffL);            for (int i = 0; i < 8; i++, d >>>= 8) data[i] = (byte) d;            long hash = MurmurHash.hash64A(data, seed);            return hash / UNIFORM_DIVISOR;        }    };}
9e04926700b7816deb19729c0515c450bdedd8d356792b63c1101c7303154a64
apply
public double apply(int row, int column)
{    long d = ((long) row << Integer.SIZE) | (column & 0xffffffffL);    for (int i = 0; i < 8; i++, d >>>= 8) data[i] = (byte) d;    long hash = MurmurHash.hash64A(data, seed);    return hash / UNIFORM_DIVISOR;}
61cac746f5a28decce065b9af98d620df84fe3d794ebb1b958a84041c0f9d732
uniformGenerator
public static IntIntFunction uniformGenerator(final int seed)
{    return Functions.chain(new DoubleFunction() {        @Override        public double apply(double x) {            return (x + 1.0) / 2.0;        }    }, uniformSymmetricGenerator(seed));}
289ca856ae087737aff3520959859058a3e642cf3f87b00a2d0d486b23b7b74a
apply
public double apply(double x)
{    return (x + 1.0) / 2.0;}
02710a5df8a49a0c00fdfcc27ee1fc907daa9038c081e91bd38ca5d46d7181c2
vector
public Vector vector()
{    return getVector();}
5dd366da2313537c415c3c2ab9ed1909d1250d894a032bd02373d113516571d0
index
public int index()
{    return index;}
f23a71384c0a8688cdf608dee418a985a5ea2d81110eb35f8ad47738885dcac5
viewSize
private static int viewSize(Matrix matrix, int row, int column, int rowStride, int columnStride)
{    if (rowStride != 0 && columnStride != 0) {        int n1 = (matrix.numRows() - row) / rowStride;        int n2 = (matrix.numCols() - column) / columnStride;        return Math.min(n1, n2);    } else if (rowStride > 0) {        return (matrix.numRows() - row) / rowStride;    } else {        return (matrix.numCols() - column) / columnStride;    }}
383032e836ae8e377e669da8e774cd6f6410cb106bd66015b484c883dc1c467c
isDense
public boolean isDense()
{    return isDense;}
048fcadf359a37696af85547983c8e1a90a6c62d53a2f5c66ba6b94ae1c5b98c
isSequentialAccess
public boolean isSequentialAccess()
{    return true;}
ebaf88b6206d3b34b79e1287ba43a83a7321437a7f6da5136b43af17bd0a0476
iterator
public Iterator<Element> iterator()
{    final LocalElement r = new LocalElement(0);    return new Iterator<Element>() {        private int i;        @Override        public boolean hasNext() {            return i < size();        }        @Override        public Element next() {            if (i >= size()) {                throw new NoSuchElementException();            }            r.index = i++;            return r;        }        @Override        public void remove() {            throw new UnsupportedOperationException("Can't remove from a view");        }    };}
d51e5f7450eca0a0f63da1a466189e262d053b84aa767ba3be5cea740af7251b
hasNext
public boolean hasNext()
{    return i < size();}
00dabe2a90975d31521e92d62eb76f2fcf9c0e9659c3684667d164334b5f370e
next
public Element next()
{    if (i >= size()) {        throw new NoSuchElementException();    }    r.index = i++;    return r;}
eb35e4acc0ab2c89fd30970f01fba35488b3a4581b2af1986091209043508a3e
remove
public void remove()
{    throw new UnsupportedOperationException("Can't remove from a view");}
0494c3c5bbf01f97ae3671ecd67c5586bc95bd0aa1907bd0e3ebdc94d70e1683
iterateNonZero
public Iterator<Element> iterateNonZero()
{    return new Iterator<Element>() {        class NonZeroElement implements Element {            int index;            @Override            public double get() {                return getQuick(index);            }            @Override            public int index() {                return index;            }            @Override            public void set(double value) {                invalidateCachedLength();                setQuick(index, value);            }        }        private final NonZeroElement element = new NonZeroElement();        private int index = -1;        private int lookAheadIndex = -1;        @Override        public boolean hasNext() {            if (lookAheadIndex == index) {                                lookAhead();            }                        return lookAheadIndex < size();        }        private void lookAhead() {            lookAheadIndex++;            while (lookAheadIndex < size() && getQuick(lookAheadIndex) == 0.0) {                lookAheadIndex++;            }        }        @Override        public Element next() {            if (lookAheadIndex == index) {                                lookAhead();            }            index = lookAheadIndex;            if (index >= size()) {                                throw new NoSuchElementException();            }            element.index = index;            return element;        }        @Override        public void remove() {            throw new UnsupportedOperationException();        }    };}
6f9021560b40d5f0ea4687dcfc9163f88e04e559e2fc0af5f9a1fed73b4e4c24
get
public double get()
{    return getQuick(index);}
5dd366da2313537c415c3c2ab9ed1909d1250d894a032bd02373d113516571d0
index
public int index()
{    return index;}
0ca3b3a320922927ea9a06f3def94b995d23a5eb7b95de57c7935a827c79759c
set
public void set(double value)
{    invalidateCachedLength();    setQuick(index, value);}
d51e5f7450eca0a0f63da1a466189e262d053b84aa767ba3be5cea740af7251b
hasNext
public boolean hasNext()
{    if (lookAheadIndex == index) {                lookAhead();    }        return lookAheadIndex < size();}
a71ddfeeb398b7f05e83d0bbfab60b3d1c5cb1efae556ec7b317781f793da1e1
lookAhead
private void lookAhead()
{    lookAheadIndex++;    while (lookAheadIndex < size() && getQuick(lookAheadIndex) == 0.0) {        lookAheadIndex++;    }}
00dabe2a90975d31521e92d62eb76f2fcf9c0e9659c3684667d164334b5f370e
next
public Element next()
{    if (lookAheadIndex == index) {                lookAhead();    }    index = lookAheadIndex;    if (index >= size()) {                throw new NoSuchElementException();    }    element.index = index;    return element;}
eb35e4acc0ab2c89fd30970f01fba35488b3a4581b2af1986091209043508a3e
remove
public void remove()
{    throw new UnsupportedOperationException();}
2263144cad9c9fdd2eecb03c9f0c31fc79e73b974408c87f743169e8bea1c8f3
getQuick
public double getQuick(int index)
{    return matrix.getQuick(row + rowStride * index, column + columnStride * index);}
3f06e4bc1bde206fe6ac26b2e2c12970bc557eee7de0d8e8394b1f96568db34b
like
public Vector like()
{    return matrix.like(size(), 1).viewColumn(0);}
de7fe3d006f2cc6fa563e7089bbae0e5300ec5b2f82e856c1118dd26a5798a5f
like
public Vector like(int cardinality)
{    return matrix.like(cardinality, 1).viewColumn(0);}
d90a04e96781b1eebeec5aca2a7d384a466650ea31ec4abd55dff982b7d2e12d
setQuick
public void setQuick(int index, double value)
{    matrix.setQuick(row + rowStride * index, column + columnStride * index, value);}
f6c83ebe319a78b7975eba92f536cfcf2e5e6786960fb07f54a0c99258711da5
getNumNondefaultElements
public int getNumNondefaultElements()
{    return size();}
6b67fad6dd27aa2525cafe6cf3396d2225fbcdf57e5378ac7a3dee60e61f20e8
getLookupCost
public double getLookupCost()
{        return 1;}
c79b5203142f65c96c29c2652557bad0bda511dfe38011e3b2877dd681f7c9cf
getIteratorAdvanceCost
public double getIteratorAdvanceCost()
{        return 1;}
c5fbf138e094d3027905103c89bbab4aa48cd369c50dde054752fd31aa322767
isAddConstantTime
public boolean isAddConstantTime()
{        return true;}
39aa63eded95450eed8ae8438d97998d3316f664b548900552f7ffb6b0441d94
matrixLike
protected Matrix matrixLike(int rows, int columns)
{    return matrix.like(rows, columns);}
884f06bfd74abf9fcac20d7d3e56bc5f671ec9a0f686c5a89f82c391ef5b3fce
clone
public Vector clone()
{    MatrixVectorView r = (MatrixVectorView) super.clone();    r.matrix = matrix.clone();    r.row = row;    r.column = column;    r.rowStride = rowStride;    r.columnStride = columnStride;    return r;}
0f2cea51f07acae4d2eb073f5151beaf6dba8920eaf21ed6212f67553909727d
mergeUpdates
public void mergeUpdates(OrderedIntDoubleMapping updates)
{    int[] indices = updates.getIndices();    double[] values = updates.getValues();    for (int i = 0; i < updates.getNumMappings(); ++i) {        matrix.setQuick(row + rowStride * indices[i], column + columnStride * indices[i], values[i]);    }}
718d9e27b4314887356041933895f3ca7614086ebd95c67fc99404a51fab676b
clone
public Matrix clone()
{    MatrixView clone = (MatrixView) super.clone();    clone.matrix = matrix.clone();    clone.offset = offset.clone();    return clone;}
1a7b4a2d3001072b037d625fbd603f24082fad4d995e7354ef48188cd1906c22
getQuick
public double getQuick(int row, int column)
{    return matrix.getQuick(offset[ROW] + row, offset[COL] + column);}
8ea1ca8bbfed9d923bb33b6722a3491db09837bb6812b8b8778bf2422064e0ab
like
public Matrix like()
{    return matrix.like(rowSize(), columnSize());}
f88fece6b0c6401785f452c13d8cce7ea1dc13011ee8686b08685d42b6f32638
like
public Matrix like(int rows, int columns)
{    return matrix.like(rows, columns);}
c733fce42980b3396a3426c0cfb05355954939da4f722c3d81ab2555e6bd9282
setQuick
public void setQuick(int row, int column, double value)
{    matrix.setQuick(offset[ROW] + row, offset[COL] + column, value);}
7714b327d86a7bf6870ba63ac39d817cef2071cb1e37ee1443f8106d3de5443a
getNumNondefaultElements
public int[] getNumNondefaultElements()
{    return new int[] { rowSize(), columnSize() };}
242adb7156cbde039fd67ab8f5ed8c9c46c199c38c6f12d05d2dbaffd8178820
viewPart
public Matrix viewPart(int[] offset, int[] size)
{    if (offset[ROW] < 0) {        throw new IndexException(offset[ROW], 0);    }    if (offset[ROW] + size[ROW] > rowSize()) {        throw new IndexException(offset[ROW] + size[ROW], rowSize());    }    if (offset[COL] < 0) {        throw new IndexException(offset[COL], 0);    }    if (offset[COL] + size[COL] > columnSize()) {        throw new IndexException(offset[COL] + size[COL], columnSize());    }    int[] origin = this.offset.clone();    origin[ROW] += offset[ROW];    origin[COL] += offset[COL];    return new MatrixView(matrix, origin, size);}
2d445c7af662ad5641bd7c216b4e7684a9cdab361f239540c55a18b81c86443c
assignColumn
public Matrix assignColumn(int column, Vector other)
{    if (rowSize() != other.size()) {        throw new CardinalityException(rowSize(), other.size());    }    for (int row = 0; row < rowSize(); row++) {        matrix.setQuick(row + offset[ROW], column + offset[COL], other.getQuick(row));    }    return this;}
95687ef4453f7375a5854c6fa51b38f6963e77319dd3f4176496189e5fd67c55
assignRow
public Matrix assignRow(int row, Vector other)
{    if (columnSize() != other.size()) {        throw new CardinalityException(columnSize(), other.size());    }    for (int col = 0; col < columnSize(); col++) {        matrix.setQuick(row + offset[ROW], col + offset[COL], other.getQuick(col));    }    return this;}
d46193949587a2e9ca1ec7df8ed6534443c7731e6ae91f71f45b19ee95634c85
viewColumn
public Vector viewColumn(int column)
{    if (column < 0 || column >= columnSize()) {        throw new IndexException(column, columnSize());    }    return matrix.viewColumn(column + offset[COL]).viewPart(offset[ROW], rowSize());}
cc845ba0d004ee14775588b6cb695a9053ef1f384e5196e605687c0f7eeac020
viewRow
public Vector viewRow(int row)
{    if (row < 0 || row >= rowSize()) {        throw new IndexException(row, rowSize());    }    return matrix.viewRow(row + offset[ROW]).viewPart(offset[COL], columnSize());}
4f943db0f33d27c9f70c541ef27a217346904d47c0870b555f1140eebdc0f9b2
getFlavor
public MatrixFlavor getFlavor()
{    return matrix.getFlavor();}
ff2aed09f0a65e70fe35cdd9e0a749e3eab617481a9520851f3f255d0708589e
hash
public static int hash(int data, int seed)
{    return hash(ByteBuffer.wrap(Ints.toByteArray(data)), seed);}
9859a57a461a1f6c8e3bef913be4f2ebc2646d23c88b74bb5f01ad29978d051c
hash
public static int hash(byte[] data, int seed)
{    return hash(ByteBuffer.wrap(data), seed);}
a641613879313c05ad60e2faee2c4a0487f4ec07b42d3def8cb86f84a1b60ae4
hash
public static int hash(byte[] data, int offset, int length, int seed)
{    return hash(ByteBuffer.wrap(data, offset, length), seed);}
71fdad94708cf3882d6a9370c3472215ec54676348eb5875e05765ddd3cfcf96
hash
public static int hash(ByteBuffer buf, int seed)
{        ByteOrder byteOrder = buf.order();    buf.order(ByteOrder.LITTLE_ENDIAN);    int m = 0x5bd1e995;    int r = 24;    int h = seed ^ buf.remaining();    while (buf.remaining() >= 4) {        int k = buf.getInt();        k *= m;        k ^= k >>> r;        k *= m;        h *= m;        h ^= k;    }    if (buf.remaining() > 0) {        ByteBuffer finish = ByteBuffer.allocate(4).order(ByteOrder.LITTLE_ENDIAN);                        finish.put(buf).rewind();        h ^= finish.getInt();        h *= m;    }    h ^= h >>> 13;    h *= m;    h ^= h >>> 15;    buf.order(byteOrder);    return h;}
2c37b94afd4b024d552f22a3bd05e812fb7b059bdfaaf536a11b09eabb65c93f
hash64A
public static long hash64A(byte[] data, int seed)
{    return hash64A(ByteBuffer.wrap(data), seed);}
b347991729d965495f072647e66d77c98ed9cd2a392b761dcb10ada4c41e2ecd
hash64A
public static long hash64A(byte[] data, int offset, int length, int seed)
{    return hash64A(ByteBuffer.wrap(data, offset, length), seed);}
5a1e6a63b18410ae26daf4b5fe54315baa74c8a3aadf8cb01421f18fab00edec
hash64A
public static long hash64A(ByteBuffer buf, int seed)
{    ByteOrder byteOrder = buf.order();    buf.order(ByteOrder.LITTLE_ENDIAN);    long m = 0xc6a4a7935bd1e995L;    int r = 47;    long h = seed ^ (buf.remaining() * m);    while (buf.remaining() >= 8) {        long k = buf.getLong();        k *= m;        k ^= k >>> r;        k *= m;        h ^= k;        h *= m;    }    if (buf.remaining() > 0) {        ByteBuffer finish = ByteBuffer.allocate(8).order(ByteOrder.LITTLE_ENDIAN);                        finish.put(buf).rewind();        h ^= finish.getLong();        h *= m;    }    h ^= h >>> r;    h *= m;    h ^= h >>> r;    buf.order(byteOrder);    return h;}
78d01edd646ca1f06e9fca778fd4e6382551cc45b8c73f48a5dc5e060072e6c3
murmurhash3x8632
public static int murmurhash3x8632(byte[] data, int offset, int len, int seed)
{    int c1 = 0xcc9e2d51;    int c2 = 0x1b873593;    int h1 = seed;        int roundedEnd = offset + (len & 0xfffffffc);    for (int i = offset; i < roundedEnd; i += 4) {                int k1 = (data[i] & 0xff) | ((data[i + 1] & 0xff) << 8) | ((data[i + 2] & 0xff) << 16) | (data[i + 3] << 24);        k1 *= c1;                k1 = (k1 << 15) | (k1 >>> 17);        k1 *= c2;        h1 ^= k1;                h1 = (h1 << 13) | (h1 >>> 19);        h1 = h1 * 5 + 0xe6546b64;    }        int k1 = 0;    switch(len & 0x03) {        case 3:            k1 = (data[roundedEnd + 2] & 0xff) << 16;                case 2:            k1 |= (data[roundedEnd + 1] & 0xff) << 8;                case 1:            k1 |= data[roundedEnd] & 0xff;            k1 *= c1;                        k1 = (k1 << 15) | (k1 >>> 17);            k1 *= c2;            h1 ^= k1;        default:    }        h1 ^= len;        h1 ^= h1 >>> 16;    h1 *= 0x85ebca6b;    h1 ^= h1 >>> 13;    h1 *= 0xc2b2ae35;    h1 ^= h1 >>> 16;    return h1;}
239fbe3eb64d679cbac1161825b07d6a8436ead3c6c3d140d9caec2275827023
getName
public String getName()
{    return name;}
46b53b4d3b482a4871b996bec2987b2f24e224e31154dae901088ad743623a54
getDelegate
public Vector getDelegate()
{    return delegate;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return delegate.hashCode();}
74e378df448c6c3cd090d6daf881cfac8957dd555869ea4c13a46bdc6cdcf9a6
equals
public boolean equals(Object other)
{    return delegate.equals(other);}
c3b3c2e36757d73bbd5e0f2ff6789416c1ca7c6361dad4ede5b033278506028e
clone
public NamedVector clone()
{    return new NamedVector(delegate.clone(), name);}
925b6c0af2716d475d5e78f46e549c77e229efa113e150b00d5e1b6287de16eb
all
public Iterable<Element> all()
{    return delegate.all();}
79761b2bde82a72af5456dc0789a0d7a6a00b985705b9fe5b7e2e4fc643ded15
nonZeroes
public Iterable<Element> nonZeroes()
{    return delegate.nonZeroes();}
ae284afe1ade5afe0242f68b99b1251c8ef4ebfb1ffd6eaa841c8d273ed0c131
asFormatString
public String asFormatString()
{    return toString();}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    StringBuilder bldr = new StringBuilder();    bldr.append(name).append(':').append(delegate.toString());    return bldr.toString();}
a1323639bf61f130500353a35c23f7a93de0f5d2d5c75d6189884271d6351d22
assign
public Vector assign(double value)
{    return delegate.assign(value);}
3507480612ff5c131d2eae1dc23f7afa7c53aa2a301f5ae71cc32bdb4eb18281
assign
public Vector assign(double[] values)
{    return delegate.assign(values);}
c5a902d495966254e0a65f297ed31bc7d8e3264bd5d2bc6764e8e8ffdf600259
assign
public Vector assign(Vector other)
{    return delegate.assign(other);}
e75cdb4cb4b4a3e71d9d8ef8701b50ab8eefa217675ea9880dbd46255ae2c302
assign
public Vector assign(DoubleFunction function)
{    return delegate.assign(function);}
cbdfe22e340c62843c4f162b0e6debb832eecdaf145c52a3ee7f3829b568b4cd
assign
public Vector assign(Vector other, DoubleDoubleFunction function)
{    return delegate.assign(other, function);}
5c653bdf24bc25b462b7a04a2c3eab8d086adba75ffafcc915a58a684eb5fec7
assign
public Vector assign(DoubleDoubleFunction f, double y)
{    return delegate.assign(f, y);}
72ef1e59027007ffe0950edfd2670ad03bb65cd6463d5d1d282dfeb1750435b0
size
public int size()
{    return delegate.size();}
383032e836ae8e377e669da8e774cd6f6410cb106bd66015b484c883dc1c467c
isDense
public boolean isDense()
{    return delegate.isDense();}
048fcadf359a37696af85547983c8e1a90a6c62d53a2f5c66ba6b94ae1c5b98c
isSequentialAccess
public boolean isSequentialAccess()
{    return delegate.isSequentialAccess();}
d82b144f248d736e85f2b7532a8b5190c1efdf491bff22194d6e776d9d004ac7
getElement
public Element getElement(int index)
{    return delegate.getElement(index);}
0f2cea51f07acae4d2eb073f5151beaf6dba8920eaf21ed6212f67553909727d
mergeUpdates
public void mergeUpdates(OrderedIntDoubleMapping updates)
{    delegate.mergeUpdates(updates);}
49608444d34acf8c21b5de98b7ca587f30d3d8c2b2267746bea420e294082f35
divide
public Vector divide(double x)
{    return delegate.divide(x);}
b0c6cf88ddad567458c3f9568e63bbd3ba3d401ed8f874e155db9189495e78d4
dot
public double dot(Vector x)
{    return delegate.dot(x);}
9f213e4a143454bd6f6fafb1c1293c69c2707c2477182f834f9b8e4a465adafe
get
public double get(int index)
{    return delegate.get(index);}
2263144cad9c9fdd2eecb03c9f0c31fc79e73b974408c87f743169e8bea1c8f3
getQuick
public double getQuick(int index)
{    return delegate.getQuick(index);}
449fbb1a62735f81e634399801bde51d832547b4c9b0cb2b31d0d2959554cd9d
like
public NamedVector like()
{    return new NamedVector(delegate.like(), name);}
de7fe3d006f2cc6fa563e7089bbae0e5300ec5b2f82e856c1118dd26a5798a5f
like
public Vector like(int cardinality)
{    return new NamedVector(delegate.like(cardinality), name);}
2a2791d19804000a9facdafebf5e2200fedf64190123de900411bbea8b1c2309
minus
public Vector minus(Vector x)
{    return delegate.minus(x);}
522a2cb2764f9f34b1f533404314dd0113b5ed78a0de6d0783f3ec54609375cc
normalize
public Vector normalize()
{    return delegate.normalize();}
0978b7df23acea2fdc52d893200013252773356ec6e84a75d2a010439cffc48c
normalize
public Vector normalize(double power)
{    return delegate.normalize(power);}
b3d6d678da20f3a65cb98fc8bbdd89e832e2a722d929292197be4eb74ecd440c
logNormalize
public Vector logNormalize()
{    return delegate.logNormalize();}
b72ab7b48aea139e8daf0d711f8fa7e0f2f41338b8750de918645cb98d0bad9c
logNormalize
public Vector logNormalize(double power)
{    return delegate.logNormalize(power);}
cd58bf1d0ad8e4702d41c559a572b84f7b8d34cb58bfc0018689ffe97fe3cef8
norm
public double norm(double power)
{    return delegate.norm(power);}
673e2f18abb6a076f5f26e614aec950d2752388e647d9c268e8161b493f73a85
maxValue
public double maxValue()
{    return delegate.maxValue();}
825d17834ad4d5540936ce10989cdc91141b79780ba970f5efa1f615e18f6920
maxValueIndex
public int maxValueIndex()
{    return delegate.maxValueIndex();}
e5c330b7bf4bcc42b747fb25502aa859f7e55feac55529444725ac7756c5b1da
minValue
public double minValue()
{    return delegate.minValue();}
a58af97687735fad30d51302a64b5b3d3e939920191b08c27aa07d06a3744bf4
minValueIndex
public int minValueIndex()
{    return delegate.minValueIndex();}
9633b91a2f284f6d333a144ebf53a1813a31909260e076aa36ae8cd199af8df3
plus
public Vector plus(double x)
{    return delegate.plus(x);}
f25fd64ca5a9af413d8151a8c5caf1e2ae36bf6433abfe831c00b37d4dd6669c
plus
public Vector plus(Vector x)
{    return delegate.plus(x);}
40eb830e31d13276cef93d31667d9f8fe511a811948c5ebb2beb5e1bbd43f76e
set
public void set(int index, double value)
{    delegate.set(index, value);}
d90a04e96781b1eebeec5aca2a7d384a466650ea31ec4abd55dff982b7d2e12d
setQuick
public void setQuick(int index, double value)
{    delegate.setQuick(index, value);}
c8a20d62d9c3255d60b3b80ebe6816bd042c01abf073d860c31aa2f68df390bf
incrementQuick
public void incrementQuick(int index, double increment)
{    delegate.incrementQuick(index, increment);}
8b7fcb91dbcc77620d88bd932afdf043420de45274bcf542432eb86706753faf
getNumNonZeroElements
public int getNumNonZeroElements()
{    return delegate.getNumNonZeroElements();}
f6c83ebe319a78b7975eba92f536cfcf2e5e6786960fb07f54a0c99258711da5
getNumNondefaultElements
public int getNumNondefaultElements()
{    return delegate.getNumNondefaultElements();}
8b96a7945012e7b138a0b76ff9af9b5fe4b135b2aaa1d15efa12f110aacd7076
times
public Vector times(double x)
{    return delegate.times(x);}
06d8b41367bc9c0e3e3b3087b2403f8832c5f1d5d0a71fa81f3833a36a4a3464
times
public Vector times(Vector x)
{    return delegate.times(x);}
652b99eb4e9a262b74a7b3cfc036effdc8dda8563fcbe31fb8a2d36911ea55fc
viewPart
public Vector viewPart(int offset, int length)
{    return delegate.viewPart(offset, length);}
b95580f8663abb6debfc0eb1df4fa773879d99b496a6abea19638268659178f2
zSum
public double zSum()
{    return delegate.zSum();}
6dfe2cdb77cbc5b5b9a2b7aedc3d099d3410b7401613398216709750456c90d3
cross
public Matrix cross(Vector other)
{    return delegate.cross(other);}
ad91472a8eba4486be34525ff11666fd262da25724267fbaf658819d805a43bb
aggregate
public double aggregate(DoubleDoubleFunction aggregator, DoubleFunction map)
{    return delegate.aggregate(aggregator, map);}
a85898b9f6be2e6a74d8c9cf590860cdcc7afe91571b28abda3f27dc495e0506
aggregate
public double aggregate(Vector other, DoubleDoubleFunction aggregator, DoubleDoubleFunction combiner)
{    return delegate.aggregate(other, aggregator, combiner);}
ad8e67cc94b6d67341e2eafa669a96e4de141addeda84e43821d24ae5aca2a5a
getLengthSquared
public double getLengthSquared()
{    return delegate.getLengthSquared();}
7375e752d4233bc7cb5a0df13e4653bd8767c60a41b29c64339fa5293a71d1ce
getDistanceSquared
public double getDistanceSquared(Vector v)
{    return delegate.getDistanceSquared(v);}
6b67fad6dd27aa2525cafe6cf3396d2225fbcdf57e5378ac7a3dee60e61f20e8
getLookupCost
public double getLookupCost()
{    return delegate.getLookupCost();}
c79b5203142f65c96c29c2652557bad0bda511dfe38011e3b2877dd681f7c9cf
getIteratorAdvanceCost
public double getIteratorAdvanceCost()
{    return delegate.getIteratorAdvanceCost();}
c5fbf138e094d3027905103c89bbab4aa48cd369c50dde054752fd31aa322767
isAddConstantTime
public boolean isAddConstantTime()
{    return delegate.isAddConstantTime();}
379332581dd0ce5c3b49976a6c3dad0669fdb072c41298a5218585e4dd55255d
getQ
public Matrix getQ()
{    int columns = Math.min(originalColumns, originalRows);    Matrix q = qr.like(originalRows, columns);    for (int k = columns - 1; k >= 0; k--) {        Vector QRcolk = qr.viewColumn(k).viewPart(k, originalRows - k);        q.set(k, k, 1);        for (int j = k; j < columns; j++) {            if (qr.get(k, k) != 0) {                Vector Qcolj = q.viewColumn(j).viewPart(k, originalRows - k);                double s = -QRcolk.dot(Qcolj) / qr.get(k, k);                Qcolj.assign(QRcolk, Functions.plusMult(s));            }        }    }    return q;}
55edb2362f6565800427ef0199db555fc04e3ccbb3599c4575af0233b17aa95b
getR
public Matrix getR()
{    int rows = Math.min(originalRows, originalColumns);    Matrix r = qr.like(rows, originalColumns);    for (int i = 0; i < rows; i++) {        for (int j = 0; j < originalColumns; j++) {            if (i < j) {                r.setQuick(i, j, qr.getQuick(i, j));            } else if (i == j) {                r.setQuick(i, j, rDiag.getQuick(i));            } else {                r.setQuick(i, j, 0);            }        }    }    return r;}
c820225724641950b66509a156999ffdb3e7200ed5bda50d836ca88762ff8c9b
hasFullRank
public boolean hasFullRank()
{    for (int j = 0; j < originalColumns; j++) {        if (rDiag.getQuick(j) == 0) {            return false;        }    }    return true;}
19591a9869b2fec3ac2ac66ff9d2d02a1b298115b0c856cb80a0138bc3330357
solve
public Matrix solve(Matrix B)
{    if (B.numRows() != originalRows) {        throw new IllegalArgumentException("Matrix row dimensions must agree.");    }    int columns = B.numCols();    Matrix x = B.like(originalColumns, columns);                Matrix qt = getQ().transpose();    Matrix y = qt.times(B);    Matrix r = getR();    for (int k = Math.min(originalColumns, originalRows) - 1; k >= 0; k--) {                x.viewRow(k).assign(y.viewRow(k), Functions.plusMult(1 / r.get(k, k)));                Vector rColumn = r.viewColumn(k).viewPart(0, k);        for (int c = 0; c < columns; c++) {            y.viewColumn(c).viewPart(0, k).assign(rColumn, Functions.plusMult(-x.get(k, c)));        }    }    return x;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return String.format(Locale.ENGLISH, "QR(%d,%d,fullRank=%s)", originalColumns, originalRows, hasFullRank());}
d89eb311b6a5decec3f13299bbd76103cd48896cf401251200dbc25c18360629
getIndices
public int[] getIndices()
{    return indices;}
56d3484f011723625954620f02c0600f99b8323ba52b68dbdce6b52f231cbaa9
indexAt
public int indexAt(int offset)
{    return indices[offset];}
846e76202dc7e5e0904b05c4590260c440785ca893ae5b35ecb5864aab66f461
setIndexAt
public void setIndexAt(int offset, int index)
{    indices[offset] = index;}
c21c904106f6c3ace550e89c590cbc6db69c2132be17e53674bb15384b69813a
getValues
public double[] getValues()
{    return values;}
d582ce556381d6cea2305c54adc1e3929be6b7ac8c09287d69a5c8dc986be5c4
setValueAt
public void setValueAt(int offset, double value)
{    values[offset] = value;}
9b6f42828a521aa330d817ffb2baed1643d4abf2361569dd01ea48e98adc6e55
getNumMappings
public int getNumMappings()
{    return numMappings;}
2eb19808f1dc73b4ed016e1e778a83b644aa3276031e9d6c513ba3a53416f916
growTo
private void growTo(int newCapacity)
{    if (newCapacity > indices.length) {        int[] newIndices = new int[newCapacity];        System.arraycopy(indices, 0, newIndices, 0, numMappings);        indices = newIndices;        double[] newValues = new double[newCapacity];        System.arraycopy(values, 0, newValues, 0, numMappings);        values = newValues;    }}
1d2af26560de6965b3941d9530ba5162b1f67aadb916aab05e913c1654bf0c11
find
private int find(int index)
{    int low = 0;    int high = numMappings - 1;    while (low <= high) {        int mid = low + (high - low >>> 1);        int midVal = indices[mid];        if (midVal < index) {            low = mid + 1;        } else if (midVal > index) {            high = mid - 1;        } else {            return mid;        }    }    return -(low + 1);}
9f213e4a143454bd6f6fafb1c1293c69c2707c2477182f834f9b8e4a465adafe
get
public double get(int index)
{    int offset = find(index);    return offset >= 0 ? values[offset] : DEFAULT_VALUE;}
40eb830e31d13276cef93d31667d9f8fe511a811948c5ebb2beb5e1bbd43f76e
set
public void set(int index, double value)
{    if (numMappings == 0 || index > indices[numMappings - 1]) {        if (!noDefault || value != DEFAULT_VALUE) {            if (numMappings >= indices.length) {                growTo(Math.max((int) (1.2 * numMappings), numMappings + 1));            }            indices[numMappings] = index;            values[numMappings] = value;            ++numMappings;        }    } else {        int offset = find(index);        if (offset >= 0) {            insertOrUpdateValueIfPresent(offset, value);        } else {            insertValueIfNotDefault(index, offset, value);        }    }}
0009dfe9f9146b064316391105119dad567b2b8d95c6bd0f7135742648530acd
merge
public void merge(OrderedIntDoubleMapping updates)
{    int[] updateIndices = updates.getIndices();    double[] updateValues = updates.getValues();    int newNumMappings = numMappings + updates.getNumMappings();    int newCapacity = Math.max((int) (1.2 * newNumMappings), newNumMappings + 1);    int[] newIndices = new int[newCapacity];    double[] newValues = new double[newCapacity];    int k = 0;    int i = 0, j = 0;    for (; i < numMappings && j < updates.getNumMappings(); ++k) {        if (indices[i] < updateIndices[j]) {            newIndices[k] = indices[i];            newValues[k] = values[i];            ++i;        } else if (indices[i] > updateIndices[j]) {            newIndices[k] = updateIndices[j];            newValues[k] = updateValues[j];            ++j;        } else {            newIndices[k] = updateIndices[j];            newValues[k] = updateValues[j];            ++i;            ++j;        }    }    for (; i < numMappings; ++i, ++k) {        newIndices[k] = indices[i];        newValues[k] = values[i];    }    for (; j < updates.getNumMappings(); ++j, ++k) {        newIndices[k] = updateIndices[j];        newValues[k] = updateValues[j];    }    indices = newIndices;    values = newValues;    numMappings = k;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    int result = 0;    for (int i = 0; i < numMappings; i++) {        result = 31 * result + indices[i];        result = 31 * result + (int) Double.doubleToRawLongBits(values[i]);    }    return result;}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (o instanceof OrderedIntDoubleMapping) {        OrderedIntDoubleMapping other = (OrderedIntDoubleMapping) o;        if (numMappings == other.numMappings) {            for (int i = 0; i < numMappings; i++) {                if (indices[i] != other.indices[i] || values[i] != other.values[i]) {                    return false;                }            }            return true;        }    }    return false;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    StringBuilder result = new StringBuilder(10 * numMappings);    for (int i = 0; i < numMappings; i++) {        result.append('(');        result.append(indices[i]);        result.append(',');        result.append(values[i]);        result.append(')');    }    return result.toString();}
e6eba61ad752db82c4c041c170332d24018ff93aabba0eade4810072c82e9209
clone
public OrderedIntDoubleMapping clone()
{    return new OrderedIntDoubleMapping(indices.clone(), values.clone(), numMappings);}
d6ab43672bdbf7c7f4011193d0cbd7e3b83a019ea7172839e162a182b2b840ed
increment
public void increment(int index, double increment)
{    int offset = find(index);    if (offset >= 0) {        double newValue = values[offset] + increment;        insertOrUpdateValueIfPresent(offset, newValue);    } else {        insertValueIfNotDefault(index, offset, increment);    }}
abd5454794998b82ffa3ebdd224a500bfeede92be15d4a25f971708d1107a774
insertValueIfNotDefault
private void insertValueIfNotDefault(int index, int offset, double value)
{    if (!noDefault || value != DEFAULT_VALUE) {        if (numMappings >= indices.length) {            growTo(Math.max((int) (1.2 * numMappings), numMappings + 1));        }        int at = -offset - 1;        if (numMappings > at) {            for (int i = numMappings - 1, j = numMappings; i >= at; i--, j--) {                indices[j] = indices[i];                values[j] = values[i];            }        }        indices[at] = index;        values[at] = value;        numMappings++;    }}
83c141101aa9cdb25473ed61d3917f2a2605cb4c362bb7c7bb6078d09db95e7c
insertOrUpdateValueIfPresent
private void insertOrUpdateValueIfPresent(int offset, double newValue)
{    if (noDefault && newValue == DEFAULT_VALUE) {        for (int i = offset + 1, j = offset; i < numMappings; i++, j++) {            indices[j] = indices[i];            values[j] = values[i];        }        numMappings--;    } else {        values[offset] = newValue;    }}
0d3a28b0199272beb4989c419a0974525a0baa4a3aad5e8151f915b795df5d59
pairwiseInnerProducts
public static VectorIterable pairwiseInnerProducts(Iterable<MatrixSlice> basis)
{    DenseMatrix out = null;    for (MatrixSlice slice1 : basis) {        List<Double> dots = Lists.newArrayList();        for (MatrixSlice slice2 : basis) {            dots.add(slice1.vector().dot(slice2.vector()));        }        if (out == null) {            out = new DenseMatrix(dots.size(), dots.size());        }        for (int i = 0; i < dots.size(); i++) {            out.set(slice1.index(), i, dots.get(i));        }    }    return out;}
d89ec5179d6b61464ea692c18436e8acc38f6f6a81a980efa5809a8ba6e8fa5b
reversePivotPermutation
private static int[] reversePivotPermutation(int[] pivot)
{    int[] unpivot1 = new int[pivot.length];    for (int i = 0; i < pivot.length; i++) {        unpivot1[pivot[i]] = i;    }    return unpivot1;}
39aa63eded95450eed8ae8438d97998d3316f664b548900552f7ffb6b0441d94
matrixLike
protected Matrix matrixLike(int rows, int columns)
{    if (vector.isDense()) {        return new DenseMatrix(rows, columns);    } else {        return new SparseRowMatrix(rows, columns);    }}
0f2cea51f07acae4d2eb073f5151beaf6dba8920eaf21ed6212f67553909727d
mergeUpdates
public void mergeUpdates(OrderedIntDoubleMapping updates)
{    for (int i = 0; i < updates.getNumMappings(); ++i) {        updates.setIndexAt(i, pivot[updates.indexAt(i)]);    }    vector.mergeUpdates(updates);}
383032e836ae8e377e669da8e774cd6f6410cb106bd66015b484c883dc1c467c
isDense
public boolean isDense()
{    return vector.isDense();}
048fcadf359a37696af85547983c8e1a90a6c62d53a2f5c66ba6b94ae1c5b98c
isSequentialAccess
public boolean isSequentialAccess()
{    return false;}
ebaf88b6206d3b34b79e1287ba43a83a7321437a7f6da5136b43af17bd0a0476
iterator
public Iterator<Element> iterator()
{    return new AbstractIterator<Element>() {        private final Iterator<Element> i = vector.all().iterator();        @Override        protected Vector.Element computeNext() {            if (i.hasNext()) {                final Element x = i.next();                return new Element() {                    private final int index = unpivot[x.index()];                    @Override                    public double get() {                        return x.get();                    }                    @Override                    public int index() {                        return index;                    }                    @Override                    public void set(double value) {                        x.set(value);                    }                };            } else {                return endOfData();            }        }    };}
eea765ebf84313b00b49587755b1aecde7d53ab65f368b45de77508229a92c1e
computeNext
protected Vector.Element computeNext()
{    if (i.hasNext()) {        final Element x = i.next();        return new Element() {            private final int index = unpivot[x.index()];            @Override            public double get() {                return x.get();            }            @Override            public int index() {                return index;            }            @Override            public void set(double value) {                x.set(value);            }        };    } else {        return endOfData();    }}
6f9021560b40d5f0ea4687dcfc9163f88e04e559e2fc0af5f9a1fed73b4e4c24
get
public double get()
{    return x.get();}
5dd366da2313537c415c3c2ab9ed1909d1250d894a032bd02373d113516571d0
index
public int index()
{    return index;}
0ca3b3a320922927ea9a06f3def94b995d23a5eb7b95de57c7935a827c79759c
set
public void set(double value)
{    x.set(value);}
0494c3c5bbf01f97ae3671ecd67c5586bc95bd0aa1907bd0e3ebdc94d70e1683
iterateNonZero
public Iterator<Element> iterateNonZero()
{    return new AbstractIterator<Element>() {        private final Iterator<Element> i = vector.nonZeroes().iterator();        @Override        protected Vector.Element computeNext() {            if (i.hasNext()) {                final Element x = i.next();                return new Element() {                    private final int index = unpivot[x.index()];                    @Override                    public double get() {                        return x.get();                    }                    @Override                    public int index() {                        return index;                    }                    @Override                    public void set(double value) {                        x.set(value);                    }                };            } else {                return endOfData();            }        }    };}
eea765ebf84313b00b49587755b1aecde7d53ab65f368b45de77508229a92c1e
computeNext
protected Vector.Element computeNext()
{    if (i.hasNext()) {        final Element x = i.next();        return new Element() {            private final int index = unpivot[x.index()];            @Override            public double get() {                return x.get();            }            @Override            public int index() {                return index;            }            @Override            public void set(double value) {                x.set(value);            }        };    } else {        return endOfData();    }}
6f9021560b40d5f0ea4687dcfc9163f88e04e559e2fc0af5f9a1fed73b4e4c24
get
public double get()
{    return x.get();}
5dd366da2313537c415c3c2ab9ed1909d1250d894a032bd02373d113516571d0
index
public int index()
{    return index;}
0ca3b3a320922927ea9a06f3def94b995d23a5eb7b95de57c7935a827c79759c
set
public void set(double value)
{    x.set(value);}
2263144cad9c9fdd2eecb03c9f0c31fc79e73b974408c87f743169e8bea1c8f3
getQuick
public double getQuick(int index)
{    return vector.getQuick(pivot[index]);}
3f06e4bc1bde206fe6ac26b2e2c12970bc557eee7de0d8e8394b1f96568db34b
like
public Vector like()
{    return vector.like();}
de7fe3d006f2cc6fa563e7089bbae0e5300ec5b2f82e856c1118dd26a5798a5f
like
public Vector like(int cardinality)
{    return vector.like(cardinality);}
d90a04e96781b1eebeec5aca2a7d384a466650ea31ec4abd55dff982b7d2e12d
setQuick
public void setQuick(int index, double value)
{    vector.setQuick(pivot[index], value);}
f6c83ebe319a78b7975eba92f536cfcf2e5e6786960fb07f54a0c99258711da5
getNumNondefaultElements
public int getNumNondefaultElements()
{    return vector.getNumNondefaultElements();}
8b7fcb91dbcc77620d88bd932afdf043420de45274bcf542432eb86706753faf
getNumNonZeroElements
public int getNumNonZeroElements()
{        return vector.getNumNonZeroElements();}
6b67fad6dd27aa2525cafe6cf3396d2225fbcdf57e5378ac7a3dee60e61f20e8
getLookupCost
public double getLookupCost()
{    return vector.getLookupCost();}
c79b5203142f65c96c29c2652557bad0bda511dfe38011e3b2877dd681f7c9cf
getIteratorAdvanceCost
public double getIteratorAdvanceCost()
{    return vector.getIteratorAdvanceCost();}
c5fbf138e094d3027905103c89bbab4aa48cd369c50dde054752fd31aa322767
isAddConstantTime
public boolean isAddConstantTime()
{    return vector.isAddConstantTime();}
38a346dd3b669981824e4b3da3c5ad6417c63d84aae517cdaa4a223d2c21e809
clone
public Object clone()
{    try {        return super.clone();    } catch (CloneNotSupportedException exc) {                throw new InternalError();    }}
aab0a7e934ff9c5218c04dd0e769cd4c6bbd49825d265ec7ed6b85997e9022c4
swap
public void swap(int i, int j)
{    swapRows(i, j);    swapColumns(i, j);}
56561db7fbe952649f4486d93492688591ce83d7ec5ecb3bcd603e515c62926f
swapRows
public void swapRows(int i, int j)
{    swap(rowPivot, rowUnpivot, i, j);}
6f759708183796387ea9754b22568fff0fe019a686df02f05536ab673a4f9adb
swapColumns
public void swapColumns(int i, int j)
{    swap(columnPivot, columnUnpivot, i, j);}
a8dc243dd5f3a161b32ebecf592add2aa67ea4441a2996cc677481f9cf9373da
swap
private static void swap(int[] pivot, int[] unpivot, int i, int j)
{    Preconditions.checkPositionIndex(i, pivot.length);    Preconditions.checkPositionIndex(j, pivot.length);    if (i != j) {        int tmp = pivot[i];        pivot[i] = pivot[j];        pivot[j] = tmp;        unpivot[pivot[i]] = i;        unpivot[pivot[j]] = j;    }}
2d445c7af662ad5641bd7c216b4e7684a9cdab361f239540c55a18b81c86443c
assignColumn
public Matrix assignColumn(int column, Vector other)
{        return base.assignColumn(columnPivot[column], new PermutedVectorView(other, rowUnpivot, rowPivot));}
95687ef4453f7375a5854c6fa51b38f6963e77319dd3f4176496189e5fd67c55
assignRow
public Matrix assignRow(int row, Vector other)
{        return base.assignRow(rowPivot[row], new PermutedVectorView(other, columnUnpivot, columnPivot));}
d46193949587a2e9ca1ec7df8ed6534443c7731e6ae91f71f45b19ee95634c85
viewColumn
public Vector viewColumn(int column)
{    if (column < 0 || column >= columnSize()) {        throw new IndexException(column, columnSize());    }    return new PermutedVectorView(base.viewColumn(columnPivot[column]), rowPivot, rowUnpivot);}
cc845ba0d004ee14775588b6cb695a9053ef1f384e5196e605687c0f7eeac020
viewRow
public Vector viewRow(int row)
{    if (row < 0 || row >= rowSize()) {        throw new IndexException(row, rowSize());    }    return new PermutedVectorView(base.viewRow(rowPivot[row]), columnPivot, columnUnpivot);}
1a7b4a2d3001072b037d625fbd603f24082fad4d995e7354ef48188cd1906c22
getQuick
public double getQuick(int row, int column)
{    return base.getQuick(rowPivot[row], columnPivot[column]);}
8ea1ca8bbfed9d923bb33b6722a3491db09837bb6812b8b8778bf2422064e0ab
like
public Matrix like()
{    return new PivotedMatrix(base.like());}
718d9e27b4314887356041933895f3ca7614086ebd95c67fc99404a51fab676b
clone
public Matrix clone()
{    PivotedMatrix clone = (PivotedMatrix) super.clone();    base = base.clone();    rowPivot = rowPivot.clone();    rowUnpivot = rowUnpivot.clone();    columnPivot = columnPivot.clone();    columnUnpivot = columnUnpivot.clone();    return clone;}
f88fece6b0c6401785f452c13d8cce7ea1dc13011ee8686b08685d42b6f32638
like
public Matrix like(int rows, int columns)
{    return new PivotedMatrix(base.like(rows, columns));}
c733fce42980b3396a3426c0cfb05355954939da4f722c3d81ab2555e6bd9282
setQuick
public void setQuick(int row, int column, double value)
{    base.setQuick(rowPivot[row], columnPivot[column], value);}
7714b327d86a7bf6870ba63ac39d817cef2071cb1e37ee1443f8106d3de5443a
getNumNondefaultElements
public int[] getNumNondefaultElements()
{    return base.getNumNondefaultElements();}
242adb7156cbde039fd67ab8f5ed8c9c46c199c38c6f12d05d2dbaffd8178820
viewPart
public Matrix viewPart(int[] offset, int[] size)
{    return new MatrixView(this, offset, size);}
d0f3fc18d1301a4c4dfcbaa3e2949b4a00adbe137363888ab012199af0e524c5
rowUnpivot
public int rowUnpivot(int k)
{    return rowUnpivot[k];}
6bea3aeb7b12dbb2c061b3fa669dec044e4e4074fdbd799b5e3b13a875311efd
columnUnpivot
public int columnUnpivot(int k)
{    return columnUnpivot[k];}
663635b49c905b285ac5bfc04995efc30656cf26b7a4790865f16877967eed18
getRowPivot
public int[] getRowPivot()
{    return rowPivot;}
2c170dbe537adda8ae4d3be44f1c58c30c656c219bfd91b56154375c5dbeca20
getInverseRowPivot
public int[] getInverseRowPivot()
{    return rowUnpivot;}
ac55c3514148aaa66d58acbb3122374337972edfa96e9d415b78ee5b0589cf6a
getColumnPivot
public int[] getColumnPivot()
{    return columnPivot;}
41eda6ad53bae66b9aff2d6868693b775ba55f8ef41f1185617563727c388245
getInverseColumnPivot
public int[] getInverseColumnPivot()
{    return columnUnpivot;}
89b4a8a9cfee09af6719e7a469487d5712c9882910964f9a6363ac6fd81e9deb
getBase
public Matrix getBase()
{    return base;}
716f607e8629eecab363b12bb273035b919866134236f2f9dcfedbbb24f518b9
identityPivot
private static int[] identityPivot(int n)
{    int[] pivot = new int[n];    for (int i = 0; i < n; i++) {        pivot[i] = i;    }    return pivot;}
84601d6eec19a046345eed798e8af82bd18085256140110d28ea3b9d8679e1ad
invert
private static int[] invert(int[] pivot)
{    int[] x = new int[pivot.length];    for (int i = 0; i < pivot.length; i++) {        x[pivot[i]] = i;    }    return x;}
379332581dd0ce5c3b49976a6c3dad0669fdb072c41298a5218585e4dd55255d
getQ
public Matrix getQ()
{    return q;}
55edb2362f6565800427ef0199db555fc04e3ccbb3599c4575af0233b17aa95b
getR
public Matrix getR()
{    return r;}
c820225724641950b66509a156999ffdb3e7200ed5bda50d836ca88762ff8c9b
hasFullRank
public boolean hasFullRank()
{    return fullRank;}
19591a9869b2fec3ac2ac66ff9d2d02a1b298115b0c856cb80a0138bc3330357
solve
public Matrix solve(Matrix B)
{    if (B.numRows() != rows) {        throw new IllegalArgumentException("Matrix row dimensions must agree.");    }    int cols = B.numCols();    Matrix x = mType.like(columns, cols);                Matrix qt = getQ().transpose();    Matrix y = qt.times(B);    Matrix r = getR();    for (int k = Math.min(columns, rows) - 1; k >= 0; k--) {                x.viewRow(k).assign(y.viewRow(k), Functions.plusMult(1 / r.get(k, k)));                Vector rColumn = r.viewColumn(k).viewPart(0, k);        for (int c = 0; c < cols; c++) {            y.viewColumn(c).viewPart(0, k).assign(rColumn, Functions.plusMult(-x.get(k, c)));        }    }    return x;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return String.format(Locale.ENGLISH, "QR(%d x %d,fullRank=%s)", rows, columns, hasFullRank());}
73f7de2503a9846d1f6266eb564191fdf5a1d5aee4d70a9237dd665890253a9f
apply
public double apply(double ignored)
{    return sample();}
21ee60f1df9af3a99dbc80acdc46d04a3f7297ce7117bcfcaac787c5cd5c3629
sample
public Integer sample()
{    double u = rand.nextDouble() * (alpha + weight);    for (int j = 0; j < weights.size(); j++) {                if (u < weights.get(j) - discount) {            weights.set(j, weights.get(j) + 1);            weight++;            return j;        } else {            u -= weights.get(j) - discount;        }    }            weights.add(1);    weight++;    return weights.size() - 1;}
72ef1e59027007ffe0950edfd2670ad03bb65cd6463d5d1d282dfeb1750435b0
size
public int size()
{    return weights.size();}
e4f1a1fb9d49d84a01c8f523b13b2984e20b3d9032426ed0b94c11278333f756
count
public int count()
{    return (int) weight;}
3ba0214d42d2ddcfa56ce3e866349435eca9a661d92011837723e4b5a7182eab
count
public int count(int j)
{    Preconditions.checkArgument(j >= 0);    if (j < weights.size()) {        return (int) weights.get(j);    } else {        return 0;    }}
142d43131103233ffd28c7a14dad7b8d51552f47adf9b1883d29adf096a4e8fb
sample
public Double sample()
{    return sample(gen.nextDouble());}
06425a7bf7bc8c9b5856c2f4cd2be0bb5292825d22a968af1173aa932dfca777
sample
public double sample(double u)
{    if (exceedMinimum && u < x[0]) {                if (u == 0) {            u = 1.0e-16;        }        return y[0] + Math.log(u / x[0]) * x[0] * (y[1] - y[0]) / (x[1] - x[0]);    } else if (exceedMaximum && u > x[n - 1]) {        if (u == 1) {            u = 1 - 1.0e-16;        }                double dy = y[n - 1] - y[n - 2];        double dx = x[n - 1] - x[n - 2];        return y[n - 1] - Math.log((1 - u) / (1 - x[n - 1])) * (1 - x[n - 1]) * dy / dx;    } else {                for (int i = 1; i < n; i++) {            if (x[i] > u) {                double dy = y[i] - y[i - 1];                double dx = x[i] - x[i - 1];                return y[i - 1] + (u - x[i - 1]) * dy / dx;            }        }        throw new RuntimeException(String.format("Can't happen (%.3f is not in [%.3f,%.3f]", u, x[0], x[n - 1]));    }}
bab6c77b89b1c2e775934216f93bb42dd99d2e601fda94f0ec94eb8086c6cab7
createIntegerDocumentSampler
public static IndianBuffet<Integer> createIntegerDocumentSampler(double alpha)
{    return new IndianBuffet<>(alpha, new IdentityConverter());}
4266db29ba61bb19a1948f886a6b2f67ff7caa3f5b56a9487d2c8fb73884de57
createTextDocumentSampler
public static IndianBuffet<String> createTextDocumentSampler(double alpha)
{    return new IndianBuffet<>(alpha, new WordConverter());}
3ad3faa71ce1e193f507ff36bc8c7e11fa6de2bd2092f1f5b79ba43161e79555
sample
public List<T> sample()
{    List<T> r = Lists.newArrayList();    if (documents == 0) {        double n = new PoissonSampler(alpha).sample();        for (int i = 0; i < n; i++) {            r.add(converter.convert(i));            count.add(1);        }        documents++;    } else {        documents++;        int i = 0;        for (double cnt : count) {            if (gen.nextDouble() < cnt / documents) {                r.add(converter.convert(i));                count.set(i, count.get(i) + 1);            }            i++;        }        int newItems = new PoissonSampler(alpha / documents).sample().intValue();        for (int j = 0; j < newItems; j++) {            r.add(converter.convert(i + j));            count.add(1);        }    }    return r;}
44fcef2b2d62733d307dbef7fe3ebdf3b17b3b7e81dcca8bdc54a029d0bb6a5c
convert
public Integer convert(int i)
{    return i;}
b6722901fb58e741731a0bf14b7383f458c98bef8018c03bd4d7c4c89825f83e
convert
public String convert(int i)
{    return String.valueOf(i);}
cfb5c01b1c12c9cd62a4f3e45a9edfb5dbc4590402a68115432b7675c00ec2b0
processLine
public boolean processLine(String line)
{    Iterables.addAll(theWords, onSpace.split(line));    return true;}
310e3fd80944e36ddd53c6125b625bd179722182838aa97258a7fb52ca8f01df
getResult
public List<String> getResult()
{    return theWords;}
b6722901fb58e741731a0bf14b7383f458c98bef8018c03bd4d7c4c89825f83e
convert
public String convert(int i)
{    if (i < words.size()) {        return words.get(i);    } else {        return "w_" + i;    }}
c273cdec1301a12cc09984a7cb72cde7111d576fac81c45d28b33b144d180608
sample
public T sample()
{    if (gen.nextDouble() >= p) {        return delegate.sample();    } else {        return missingMarker;    }}
f1a29e7839188f6f687e9d8480b10b27cc8a88aa9ad9ba728d1f656febcefa82
add
public void add(T value, double w)
{    Preconditions.checkNotNull(value);    Preconditions.checkArgument(!items.containsKey(value));    int n = this.weight.size();    if (n == 1) {        weight.add(w);        values.add(value);        items.put(value, 1);    } else {                weight.add(weight.get(n / 2));        values.add(values.get(n / 2));        items.put(values.get(n / 2), n);        n++;                items.put(value, n);        this.weight.add(w);        values.add(value);                while (n > 1) {            n /= 2;            this.weight.set(n, this.weight.get(n) + w);        }    }}
87d50d81914668a942458bd44b060333106016c36eb93b5b65a4d102ec3c8c48
getWeight
public double getWeight(T value)
{    if (items.containsKey(value)) {        return weight.get(items.get(value));    } else {        return 0;    }}
b124141620b2746c7c87bbbaccdef44dc84f933e1d459342a1a4f46d79c5d71a
getProbability
public double getProbability(T value)
{    if (items.containsKey(value)) {        return weight.get(items.get(value)) / weight.get(1);    } else {        return 0;    }}
4fcdc31ef95f5a8da570a554b48977aa3dd343f3820426ae37586f4231b6e321
getWeight
public double getWeight()
{    if (weight.size() > 1) {        return weight.get(1);    } else {        return 0;    }}
c9e84f3f0085333210fa0fd97281975ade7bbcc4880f63afa7698b069d30417e
delete
public void delete(T value)
{    set(value, 0);}
c0bbace077f6b43ba3318e2b683799445b736e59cace0e6740821ef59740a574
set
public void set(T value, double newP)
{    Preconditions.checkArgument(items.containsKey(value));    int n = items.get(value);    if (newP <= 0) {                        items.remove(value);    }    double oldP = weight.get(n);    while (n > 0) {        weight.set(n, weight.get(n) - oldP + newP);        n /= 2;    }}
c273cdec1301a12cc09984a7cb72cde7111d576fac81c45d28b33b144d180608
sample
public T sample()
{    Preconditions.checkArgument(!weight.isEmpty());    return sample(rand.nextDouble());}
aea7d9f88963ca9131496ef18cc69f1d1f094095796bd2b0c33b2e24525d9b67
sample
public T sample(double u)
{    u *= weight.get(1);    int n = 1;    while (2 * n < weight.size()) {                double left = weight.get(2 * n);        if (u <= left) {            n = 2 * n;        } else {            u -= left;            n = 2 * n + 1;        }    }    return values.get(n);}
04dd93d5f937f6234fa0ce0d8b4b5aab0b298d1bb7fea80eb84b48c29d1a2834
getWeights
 List<Double> getWeights()
{    List<Double> r = Lists.newArrayList();    int i = Integer.highestOneBit(weight.size());    while (i < weight.size()) {        r.add(weight.get(i));        i++;    }    i /= 2;    while (i < Integer.highestOneBit(weight.size())) {        r.add(weight.get(i));        i++;    }    return r;}
f953961d64692f9b59701c434fe1f9537bac98f3f86c59d94e709afc4047563e
iterator
public Iterator<T> iterator()
{    return new AbstractIterator<T>() {        Iterator<T> valuesIterator = Iterables.skip(values, 1).iterator();        @Override        protected T computeNext() {            while (valuesIterator.hasNext()) {                T next = valuesIterator.next();                if (items.containsKey(next)) {                    return next;                }            }            return endOfData();        }    };}
fcbd38ffc429e18428425214f03fd48c7497dba9932fb7efeb3f4f1b5e7362a2
computeNext
protected T computeNext()
{    while (valuesIterator.hasNext()) {        T next = valuesIterator.next();        if (items.containsKey(next)) {            return next;        }    }    return endOfData();}
e544fbe45bf40059e333137f664ed57440302379c709e95c09d77613782eb6fc
sample
public Vector sample()
{    Vector v = new DenseVector(dimension).assign(new DoubleFunction() {        @Override        public double apply(double ignored) {            return gen.nextGaussian();        }    });    if (mean != null) {        if (scale != null) {            return scale.times(v).plus(mean);        } else {            return v.plus(mean);        }    } else {        if (scale != null) {            return scale.times(v);        } else {            return v;        }    }}
73f7de2503a9846d1f6266eb564191fdf5a1d5aee4d70a9237dd665890253a9f
apply
public double apply(double ignored)
{    return gen.nextGaussian();}
e3bd21f39c54cd37161a1e2c96e7e08ebe1eb364f3976f4e3d6a4518a9a6ea58
getScale
public Vector getScale()
{    return mean;}
142d43131103233ffd28c7a14dad7b8d51552f47adf9b1883d29adf096a4e8fb
sample
public Double sample()
{    return rand.nextGaussian() * sd + mean;}
142d43131103233ffd28c7a14dad7b8d51552f47adf9b1883d29adf096a4e8fb
sample
public Double sample()
{    return sample(gen.nextDouble());}
d21d151938de365e5a4475f9963cfef90bff9ed7dab0a77d2831fcb5fe5104a2
sample
 double sample(double u)
{    if (u < limit) {        List<WeightedThing<Integer>> steps = Lists.newArrayList();        limit = 1;        int i = 0;        while (u / 20 < limit) {            double pdf = pd.probability(i);            limit -= pdf;            steps.add(new WeightedThing<>(i, pdf));            i++;        }        steps.add(new WeightedThing<>(steps.size(), limit));        partial = new Multinomial<>(steps);    }    return partial.sample(u);}
5d1a642cd3f56327936f74c7e42620bdce9a2aa959d5c16e15c526e66eba684a
getValue
public T getValue()
{    return value;}
4fcdc31ef95f5a8da570a554b48977aa3dd343f3820426ae37586f4231b6e321
getWeight
public double getWeight()
{    return weight;}
573f45c20cfe1129d14c1e9631f9247aa24212ba8782b103cc757b5ef4303eb1
setWeight
public void setWeight(double weight)
{    this.weight = weight;}
4005211438c83e03d368def1eee0efa1f240a88bd0adc061d33c05621ae470e3
compareTo
public int compareTo(WeightedThing<T> other)
{    return Double.compare(this.weight, other.weight);}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (o instanceof WeightedThing) {        @SuppressWarnings("unchecked")        WeightedThing<T> other = (WeightedThing<T>) o;        return weight == other.weight && value.equals(other.value);    }    return false;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return 31 * RandomUtils.hashDouble(weight) + value.hashCode();}
39aa63eded95450eed8ae8438d97998d3316f664b548900552f7ffb6b0441d94
matrixLike
protected Matrix matrixLike(int rows, int columns)
{    return new SparseMatrix(rows, columns);}
3b374605855172e69225f9488de6d6d39d60c6ef9f1a7eaa9644c85f38f99fa7
clone
public RandomAccessSparseVector clone()
{    return new RandomAccessSparseVector(size(), values.clone());}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return sparseVectorToString();}
c5a902d495966254e0a65f297ed31bc7d8e3264bd5d2bc6764e8e8ffdf600259
assign
public Vector assign(Vector other)
{    if (size() != other.size()) {        throw new CardinalityException(size(), other.size());    }    values.clear();    for (Element e : other.nonZeroes()) {        setQuick(e.index(), e.get());    }    return this;}
0f2cea51f07acae4d2eb073f5151beaf6dba8920eaf21ed6212f67553909727d
mergeUpdates
public void mergeUpdates(OrderedIntDoubleMapping updates)
{    for (int i = 0; i < updates.getNumMappings(); ++i) {        values.put(updates.getIndices()[i], updates.getValues()[i]);    }}
383032e836ae8e377e669da8e774cd6f6410cb106bd66015b484c883dc1c467c
isDense
public boolean isDense()
{    return false;}
048fcadf359a37696af85547983c8e1a90a6c62d53a2f5c66ba6b94ae1c5b98c
isSequentialAccess
public boolean isSequentialAccess()
{    return false;}
2263144cad9c9fdd2eecb03c9f0c31fc79e73b974408c87f743169e8bea1c8f3
getQuick
public double getQuick(int index)
{    return values.get(index);}
d90a04e96781b1eebeec5aca2a7d384a466650ea31ec4abd55dff982b7d2e12d
setQuick
public void setQuick(int index, double value)
{    invalidateCachedLength();    if (value == 0.0) {        values.remove(index);    } else {        values.put(index, value);    }}
c8a20d62d9c3255d60b3b80ebe6816bd042c01abf073d860c31aa2f68df390bf
incrementQuick
public void incrementQuick(int index, double increment)
{    invalidateCachedLength();    values.addTo(index, increment);}
58208db102427fc6908516143acc02e87bdac4fd71df83ae289187962de94b9b
like
public RandomAccessSparseVector like()
{    return new RandomAccessSparseVector(size(), values.size());}
de7fe3d006f2cc6fa563e7089bbae0e5300ec5b2f82e856c1118dd26a5798a5f
like
public Vector like(int cardinality)
{    return new RandomAccessSparseVector(cardinality, values.size());}
f6c83ebe319a78b7975eba92f536cfcf2e5e6786960fb07f54a0c99258711da5
getNumNondefaultElements
public int getNumNondefaultElements()
{    return values.size();}
8b7fcb91dbcc77620d88bd932afdf043420de45274bcf542432eb86706753faf
getNumNonZeroElements
public int getNumNonZeroElements()
{    final DoubleIterator iterator = values.values().iterator();    int numNonZeros = 0;    for (int i = values.size(); i-- != 0; ) if (iterator.nextDouble() != 0)        numNonZeros++;    return numNonZeros;}
6b67fad6dd27aa2525cafe6cf3396d2225fbcdf57e5378ac7a3dee60e61f20e8
getLookupCost
public double getLookupCost()
{    return 1;}
c79b5203142f65c96c29c2652557bad0bda511dfe38011e3b2877dd681f7c9cf
getIteratorAdvanceCost
public double getIteratorAdvanceCost()
{    return 1 + (AbstractSet.DEFAULT_MAX_LOAD_FACTOR + AbstractSet.DEFAULT_MIN_LOAD_FACTOR) / 2;}
c5fbf138e094d3027905103c89bbab4aa48cd369c50dde054752fd31aa322767
isAddConstantTime
public boolean isAddConstantTime()
{    return true;}
d51e5f7450eca0a0f63da1a466189e262d053b84aa767ba3be5cea740af7251b
hasNext
public boolean hasNext()
{    return fastIterator.hasNext();}
00dabe2a90975d31521e92d62eb76f2fcf9c0e9659c3684667d164334b5f370e
next
public Element next()
{    if (!hasNext())        throw new NoSuchElementException();    element.entry = fastIterator.next();    return element;}
eb35e4acc0ab2c89fd30970f01fba35488b3a4581b2af1986091209043508a3e
remove
public void remove()
{    throw new UnsupportedOperationException();}
6f9021560b40d5f0ea4687dcfc9163f88e04e559e2fc0af5f9a1fed73b4e4c24
get
public double get()
{    return entry.getDoubleValue();}
5dd366da2313537c415c3c2ab9ed1909d1250d894a032bd02373d113516571d0
index
public int index()
{    return entry.getIntKey();}
0ca3b3a320922927ea9a06f3def94b995d23a5eb7b95de57c7935a827c79759c
set
public void set(double value)
{    invalidateCachedLength();    if (value == 0.0)        fastIterator.remove();    else        entry.setValue(value);}
0494c3c5bbf01f97ae3671ecd67c5586bc95bd0aa1907bd0e3ebdc94d70e1683
iterateNonZero
public Iterator<Element> iterateNonZero()
{    return new NonZeroIterator();}
ebaf88b6206d3b34b79e1287ba43a83a7321437a7f6da5136b43af17bd0a0476
iterator
public Iterator<Element> iterator()
{    return new AllIterator();}
6f9021560b40d5f0ea4687dcfc9163f88e04e559e2fc0af5f9a1fed73b4e4c24
get
public double get()
{    return value;}
5dd366da2313537c415c3c2ab9ed1909d1250d894a032bd02373d113516571d0
index
public int index()
{    return index;}
0ca3b3a320922927ea9a06f3def94b995d23a5eb7b95de57c7935a827c79759c
set
public void set(double value)
{    invalidateCachedLength();    if (value == 0.0)        values.remove(index);    else        values.put(index, value);}
d51e5f7450eca0a0f63da1a466189e262d053b84aa767ba3be5cea740af7251b
hasNext
public boolean hasNext()
{    return element.index + 1 < size();}
00dabe2a90975d31521e92d62eb76f2fcf9c0e9659c3684667d164334b5f370e
next
public Element next()
{    if (!hasNext()) {        throw new NoSuchElementException();    }    element.value = values.get(++element.index);    return element;}
eb35e4acc0ab2c89fd30970f01fba35488b3a4581b2af1986091209043508a3e
remove
public void remove()
{    throw new UnsupportedOperationException();}
2d445c7af662ad5641bd7c216b4e7684a9cdab361f239540c55a18b81c86443c
assignColumn
public Matrix assignColumn(int column, Vector other)
{    throw new UnsupportedOperationException("Can't assign to read-only matrix");}
95687ef4453f7375a5854c6fa51b38f6963e77319dd3f4176496189e5fd67c55
assignRow
public Matrix assignRow(int row, Vector other)
{    throw new UnsupportedOperationException("Can't assign to read-only matrix");}
1a7b4a2d3001072b037d625fbd603f24082fad4d995e7354ef48188cd1906c22
getQuick
public double getQuick(int row, int column)
{    if (highQuality) {        ByteBuffer buf = ByteBuffer.allocate(8);        buf.putInt(row);        buf.putInt(column);        buf.flip();        return (MurmurHash.hash64A(buf, seed) & (SCALE - 1)) / (double) SCALE;    } else {                return ((((row * PRIME1) + column * PRIME2 + row * column * PRIME3) & 8) * 0.25) - 1;    }}
8ea1ca8bbfed9d923bb33b6722a3491db09837bb6812b8b8778bf2422064e0ab
like
public Matrix like()
{    return new DenseMatrix(rowSize(), columnSize());}
f88fece6b0c6401785f452c13d8cce7ea1dc13011ee8686b08685d42b6f32638
like
public Matrix like(int rows, int columns)
{    return new DenseMatrix(rows, columns);}
c733fce42980b3396a3426c0cfb05355954939da4f722c3d81ab2555e6bd9282
setQuick
public void setQuick(int row, int column, double value)
{    throw new UnsupportedOperationException("Can't assign to read-only matrix");}
7714b327d86a7bf6870ba63ac39d817cef2071cb1e37ee1443f8106d3de5443a
getNumNondefaultElements
public int[] getNumNondefaultElements()
{    throw new UnsupportedOperationException("Can't assign to read-only matrix");}
242adb7156cbde039fd67ab8f5ed8c9c46c199c38c6f12d05d2dbaffd8178820
viewPart
public Matrix viewPart(int[] offset, int[] size)
{    return new MatrixView(this, offset, size);}
9fdf208084ca9f700129235b50422784454e73fbff704a072525e8c7e65dde45
copySortedRandomAccessSparseVector
private int copySortedRandomAccessSparseVector(Vector other)
{    int elementCount = other.getNumNondefaultElements();    OrderedElement[] sortableElements = new OrderedElement[elementCount];    int s = 0;    for (Element e : other.nonZeroes()) {        sortableElements[s++] = new OrderedElement(e.index(), e.get());    }    Arrays.sort(sortableElements);    for (int i = 0; i < sortableElements.length; i++) {        values.setIndexAt(i, sortableElements[i].index);        values.setValueAt(i, sortableElements[i].value);    }    values = new OrderedIntDoubleMapping(values.getIndices(), values.getValues(), elementCount);    return elementCount;}
39aa63eded95450eed8ae8438d97998d3316f664b548900552f7ffb6b0441d94
matrixLike
protected Matrix matrixLike(int rows, int columns)
{        return new SparseMatrix(rows, columns);}
7c992442d9da453901ed717162c255be7312691a3ab31dc6bd3770400d81ef2d
clone
public SequentialAccessSparseVector clone()
{    return new SequentialAccessSparseVector(size(), values.clone());}
0f2cea51f07acae4d2eb073f5151beaf6dba8920eaf21ed6212f67553909727d
mergeUpdates
public void mergeUpdates(OrderedIntDoubleMapping updates)
{    values.merge(updates);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return sparseVectorToString();}
383032e836ae8e377e669da8e774cd6f6410cb106bd66015b484c883dc1c467c
isDense
public boolean isDense()
{    return false;}
048fcadf359a37696af85547983c8e1a90a6c62d53a2f5c66ba6b94ae1c5b98c
isSequentialAccess
public boolean isSequentialAccess()
{    return true;}
2263144cad9c9fdd2eecb03c9f0c31fc79e73b974408c87f743169e8bea1c8f3
getQuick
public double getQuick(int index)
{    return values.get(index);}
d90a04e96781b1eebeec5aca2a7d384a466650ea31ec4abd55dff982b7d2e12d
setQuick
public void setQuick(int index, double value)
{    invalidateCachedLength();    values.set(index, value);}
c8a20d62d9c3255d60b3b80ebe6816bd042c01abf073d860c31aa2f68df390bf
incrementQuick
public void incrementQuick(int index, double increment)
{    invalidateCachedLength();    values.increment(index, increment);}
da54978de3da365db95c91e19798c7068104b1db01601512a5504b51a7bb83fa
like
public SequentialAccessSparseVector like()
{    return new SequentialAccessSparseVector(size(), values.getNumMappings());}
de7fe3d006f2cc6fa563e7089bbae0e5300ec5b2f82e856c1118dd26a5798a5f
like
public Vector like(int cardinality)
{    return new SequentialAccessSparseVector(cardinality);}
f6c83ebe319a78b7975eba92f536cfcf2e5e6786960fb07f54a0c99258711da5
getNumNondefaultElements
public int getNumNondefaultElements()
{    return values.getNumMappings();}
8b7fcb91dbcc77620d88bd932afdf043420de45274bcf542432eb86706753faf
getNumNonZeroElements
public int getNumNonZeroElements()
{    double[] elementValues = values.getValues();    int numMappedElements = values.getNumMappings();    int numNonZeros = 0;    for (int index = 0; index < numMappedElements; index++) {        if (elementValues[index] != 0) {            numNonZeros++;        }    }    return numNonZeros;}
6b67fad6dd27aa2525cafe6cf3396d2225fbcdf57e5378ac7a3dee60e61f20e8
getLookupCost
public double getLookupCost()
{    return Math.max(1, Math.round(Functions.LOG2.apply(getNumNondefaultElements())));}
c79b5203142f65c96c29c2652557bad0bda511dfe38011e3b2877dd681f7c9cf
getIteratorAdvanceCost
public double getIteratorAdvanceCost()
{    return 1;}
c5fbf138e094d3027905103c89bbab4aa48cd369c50dde054752fd31aa322767
isAddConstantTime
public boolean isAddConstantTime()
{    return false;}
0494c3c5bbf01f97ae3671ecd67c5586bc95bd0aa1907bd0e3ebdc94d70e1683
iterateNonZero
public Iterator<Element> iterateNonZero()
{        return new NonDefaultIterator();}
ebaf88b6206d3b34b79e1287ba43a83a7321437a7f6da5136b43af17bd0a0476
iterator
public Iterator<Element> iterator()
{    return new AllIterator();}
d51e5f7450eca0a0f63da1a466189e262d053b84aa767ba3be5cea740af7251b
hasNext
public boolean hasNext()
{    return element.getNextOffset() < values.getNumMappings();}
00dabe2a90975d31521e92d62eb76f2fcf9c0e9659c3684667d164334b5f370e
next
public Element next()
{    if (!hasNext()) {        throw new NoSuchElementException();    }    element.advanceOffset();    return element;}
eb35e4acc0ab2c89fd30970f01fba35488b3a4581b2af1986091209043508a3e
remove
public void remove()
{    throw new UnsupportedOperationException();}
d51e5f7450eca0a0f63da1a466189e262d053b84aa767ba3be5cea740af7251b
hasNext
public boolean hasNext()
{    return element.getNextIndex() < SequentialAccessSparseVector.this.size();}
00dabe2a90975d31521e92d62eb76f2fcf9c0e9659c3684667d164334b5f370e
next
public Element next()
{    if (!hasNext()) {        throw new NoSuchElementException();    }    element.advanceIndex();    return element;}
eb35e4acc0ab2c89fd30970f01fba35488b3a4581b2af1986091209043508a3e
remove
public void remove()
{    throw new UnsupportedOperationException();}
639ee1ffd66baefeefa525c18fb40c7fb00f96a26a116a17628be90a36f6f11a
advanceOffset
 void advanceOffset()
{    offset++;}
baad7d9327b0af08eb8f46a7b7c45ca9be3ee9970fee6334e49ee58e538b081c
getNextOffset
 int getNextOffset()
{    return offset + 1;}
6f9021560b40d5f0ea4687dcfc9163f88e04e559e2fc0af5f9a1fed73b4e4c24
get
public double get()
{    return values.getValues()[offset];}
5dd366da2313537c415c3c2ab9ed1909d1250d894a032bd02373d113516571d0
index
public int index()
{    return values.getIndices()[offset];}
0ca3b3a320922927ea9a06f3def94b995d23a5eb7b95de57c7935a827c79759c
set
public void set(double value)
{    invalidateCachedLength();    values.setValueAt(offset, value);}
d46bb4d5e3b63af420eccc84d3ca453c9a8ebc2bc2dc7e64009d089c98ce23d3
advanceIndex
 void advanceIndex()
{    index++;    if (nextOffset < values.getNumMappings() && index > values.getIndices()[nextOffset]) {        nextOffset++;    }}
939a2d62532cac5ba827702dddf857c4c3fb751dafe4fb4edab0bc33e7419b86
getNextIndex
 int getNextIndex()
{    return index + 1;}
6f9021560b40d5f0ea4687dcfc9163f88e04e559e2fc0af5f9a1fed73b4e4c24
get
public double get()
{    if (nextOffset < values.getNumMappings() && index == values.getIndices()[nextOffset]) {        return values.getValues()[nextOffset];    } else {        return OrderedIntDoubleMapping.DEFAULT_VALUE;    }}
5dd366da2313537c415c3c2ab9ed1909d1250d894a032bd02373d113516571d0
index
public int index()
{    return index;}
0ca3b3a320922927ea9a06f3def94b995d23a5eb7b95de57c7935a827c79759c
set
public void set(double value)
{    invalidateCachedLength();    if (nextOffset < values.getNumMappings() && index == values.indexAt(nextOffset)) {        values.setValueAt(nextOffset, value);    } else {                values.set(index, value);    }}
dbb93a7bc77fdc05f7209f5e42ea72a2e6aa001fd242582e4538962c346b4d56
compareTo
public int compareTo(OrderedElement that)
{        return this.index - that.index;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return index ^ Doubles.hashCode(value);}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    if (!(o instanceof OrderedElement)) {        return false;    }    OrderedElement other = (OrderedElement) o;    return index == other.index && value == other.value;}
3dacf455d0ce6e6670f72a006c0a258fbc3d49b0c2e9dc2458c8e214fda3ae5e
chooseGrowCapacity
protected int chooseGrowCapacity(int size, double minLoad, double maxLoad)
{    return nextPrime(Math.max(size + 1, (int) ((4 * size / (3 * minLoad + maxLoad)))));}
054ae88da52ed3f0c10b0e5ff8f524f12eaa6caa586be0483607efab7dce99c4
chooseHighWaterMark
protected int chooseHighWaterMark(int capacity, double maxLoad)
{        return Math.min(capacity - 2, (int) (capacity * maxLoad));}
9c5ca582e398e5c4a9a9d38fddb840ff7116e18b6c71a7bf80fe68086281da3d
chooseLowWaterMark
protected int chooseLowWaterMark(int capacity, double minLoad)
{    return (int) (capacity * minLoad);}
bd4049fd28a119824ecbe3ec2f3fdefa64cd4ba6c9c5709ed835f5846cf61145
chooseMeanCapacity
protected int chooseMeanCapacity(int size, double minLoad, double maxLoad)
{    return nextPrime(Math.max(size + 1, (int) ((2 * size / (minLoad + maxLoad)))));}
e3e2363b99d938431cd196853e64a8477fcd3e2f48aa52f3f86401177d0dda03
chooseShrinkCapacity
protected int chooseShrinkCapacity(int size, double minLoad, double maxLoad)
{    return nextPrime(Math.max(size + 1, (int) ((4 * size / (minLoad + 3 * maxLoad)))));}
be0b2467f7b5e58f8b28ca8784d0600afe40ba905bba892ecd9810a97065f8b7
ensureCapacity
public void ensureCapacity(int minCapacity)
{}
803915e853382ad445a6e2333fabb8beb8e4acd70e908a0d818400f7baac42af
isEmpty
public boolean isEmpty()
{    return distinct == 0;}
af80b17cef82b705955522da7c9537517e063469d2b68a37067ef0ea7b17009d
nextPrime
protected int nextPrime(int desiredCapacity)
{    return PrimeFinder.nextPrime(desiredCapacity);}
e1955a0aa5ca13f5a4033d86ef28afd7506fc77f95cb9c9350ffe6ebb40519f7
setUp
protected void setUp(int initialCapacity, double minLoadFactor, double maxLoadFactor)
{    if (initialCapacity < 0) {        throw new IllegalArgumentException("Initial Capacity must not be less than zero: " + initialCapacity);    }    if (minLoadFactor < 0.0 || minLoadFactor >= 1.0) {        throw new IllegalArgumentException("Illegal minLoadFactor: " + minLoadFactor);    }    if (maxLoadFactor <= 0.0 || maxLoadFactor >= 1.0) {        throw new IllegalArgumentException("Illegal maxLoadFactor: " + maxLoadFactor);    }    if (minLoadFactor >= maxLoadFactor) {        throw new IllegalArgumentException("Illegal minLoadFactor: " + minLoadFactor + " and maxLoadFactor: " + maxLoadFactor);    }}
72ef1e59027007ffe0950edfd2670ad03bb65cd6463d5d1d282dfeb1750435b0
size
public int size()
{    return distinct;}
577f4cd5f98829ce6ec558dccdb1c96abfae1c1a25d2ae1fc5091b3240da3a9f
trimToSize
public void trimToSize()
{}
a641de365fe7aa36b75aec01fc33901e104c0679d84429cdfb19408e3c725cc6
equalsMindTheNull
protected static boolean equalsMindTheNull(Object a, Object b)
{    if (a == null && b == null) {        return true;    }    if (a == null || b == null) {        return false;    }    return a.equals(b);}
933a2be4a057ce198380127010c6bb2a7e8e179932f12703b733c4072d0e9ca2
hash
public static int hash(byte x)
{    return x;}
9fd368e28da9aefc96807fcb56841999cbd6e4ed6e97c8138335b95d1ab24f63
hash
public static int hash(short x)
{    return x;}
121f03cc6eeaa745abd9c960c339d3ca0ffc112a85b5924c65c15fd753a33397
hash
public static int hash(char x)
{    return x;}
c2d09c181ca5727359387b78af7552d03e4a5bb805c9c646ef0634ac51f9c763
hash
public static int hash(int x)
{    return x;}
ce034f72353a8df4f1e5f716ee4fb4f1f25ab4ffa739ae8afbbf3ffa2fac6170
hash
public static int hash(float x)
{    return Float.floatToIntBits(x) >>> 3 + Float.floatToIntBits((float) (Math.PI * x));}
761d3f5e74f1dbfa7ac5f83fc25b45d3409630e698947e725de2506385705c9e
hash
public static int hash(double x)
{    return hash(17 * Double.doubleToLongBits(x));}
1c2008145d1cadbfe8bad95987de243b82fbf0e709d15b331d3aaac6fb13fa66
hash
public static int hash(long x)
{    return (int) ((x * 11) >>> 32 ^ x);}
21ac40bb9a99614b6ac18fa4043acb6173fccff96066fdfab963dba597923aa8
clear
public void clear()
{    Arrays.fill(this.state, 0, state.length - 1, FREE);    distinct = 0;        freeEntries = table.length;    trimToSize();}
38a346dd3b669981824e4b3da3c5ad6417c63d84aae517cdaa4a223d2c21e809
clone
public Object clone()
{    OpenHashSet<T> copy = (OpenHashSet<T>) super.clone();    copy.table = copy.table.clone();    copy.state = copy.state.clone();    return copy;}
b70a2cb963b8849d8711be55c99aae2933ffe0a7ac4b116bc69ff23407e60c01
contains
public boolean contains(Object key)
{    return indexOfKey((T) key) >= 0;}
be0b2467f7b5e58f8b28ca8784d0600afe40ba905bba892ecd9810a97065f8b7
ensureCapacity
public void ensureCapacity(int minCapacity)
{    if (table.length < minCapacity) {        int newCapacity = nextPrime(minCapacity);        rehash(newCapacity);    }}
a2754f7b3b74c087cc736acdb329db696c9454b65fa39fc7c12b8082b606920d
forEachKey
public boolean forEachKey(ObjectProcedure<T> procedure)
{    for (int i = table.length; i-- > 0; ) {        if (state[i] == FULL) {            if (!procedure.apply((T) table[i])) {                return false;            }        }    }    return true;}
28133cf40eb4822ea7073fbee10cb62df96909bdbb9a3fecf4379f7063b6624b
indexOfInsertion
protected int indexOfInsertion(T key)
{    Object[] tab = table;    byte[] stat = state;    int length = tab.length;    int hash = key.hashCode() & 0x7FFFFFFF;    int i = hash % length;        int decrement = hash % (length - 2);        if (decrement == 0) {        decrement = 1;    }        while (stat[i] == FULL && tab[i] != key) {        i -= decrement;                if (i < 0) {            i += length;        }    }    if (stat[i] == REMOVED) {                                int j = i;        while (stat[i] != FREE && (stat[i] == REMOVED || tab[i] != key)) {            i -= decrement;                        if (i < 0) {                i += length;            }        }        if (stat[i] == FREE) {            i = j;        }    }    if (stat[i] == FULL) {                return -i - 1;    }        return i;}
2f270bb33d6a11a63c0296e18717cb628e9b3bfa7ed9340f1bf71606a6db0ef1
indexOfKey
protected int indexOfKey(T key)
{    Object[] tab = table;    byte[] stat = state;    int length = tab.length;    int hash = key.hashCode() & 0x7FFFFFFF;    int i = hash % length;        int decrement = hash % (length - 2);        if (decrement == 0) {        decrement = 1;    }        while (stat[i] != FREE && (stat[i] == REMOVED || (!key.equals(tab[i])))) {        i -= decrement;                if (i < 0) {            i += length;        }    }    if (stat[i] == FREE) {        return -1;    }        return i;}
b98c8f36145d33cc8d25ff1fd2510404e10d1a95fe2c1d50ffdf2f90bed03247
keys
public void keys(List<T> list)
{    list.clear();    Object[] tab = table;    byte[] stat = state;    for (int i = tab.length; i-- > 0; ) {        if (stat[i] == FULL) {            list.add((T) tab[i]);        }    }}
0158263cc1308889422fbcb2f2063a6a15d28176138d710021ffcdca523b2b2c
add
public boolean add(Object key)
{    int i = indexOfInsertion((T) key);    if (i < 0) {                return false;    }    if (this.distinct > this.highWaterMark) {        int newCapacity = chooseGrowCapacity(this.distinct + 1, this.minLoadFactor, this.maxLoadFactor);        rehash(newCapacity);        return add(key);    }    this.table[i] = key;    if (this.state[i] == FREE) {        this.freeEntries--;    }    this.state[i] = FULL;    this.distinct++;    if (this.freeEntries < 1) {                int newCapacity = chooseGrowCapacity(this.distinct + 1, this.minLoadFactor, this.maxLoadFactor);        rehash(newCapacity);        return add(key);    }    return true;}
3130a51aadf6d2e269883da01b916f779c74c7e49497879787945ad4bcb1b220
rehash
protected void rehash(int newCapacity)
{    int oldCapacity = table.length;        Object[] oldTable = table;    byte[] oldState = state;    Object[] newTable = new Object[newCapacity];    byte[] newState = new byte[newCapacity];    this.lowWaterMark = chooseLowWaterMark(newCapacity, this.minLoadFactor);    this.highWaterMark = chooseHighWaterMark(newCapacity, this.maxLoadFactor);    this.table = newTable;    this.state = newState;        this.freeEntries = newCapacity - this.distinct;    for (int i = oldCapacity; i-- > 0; ) {        if (oldState[i] == FULL) {            Object element = oldTable[i];            int index = indexOfInsertion((T) element);            newTable[index] = element;            newState[index] = FULL;        }    }}
a7465183379973971683f97ebaf92192c0a2b9cdb145875609a8fdad889fd53e
remove
public boolean remove(Object key)
{    int i = indexOfKey((T) key);    if (i < 0) {        return false;    }        this.state[i] = REMOVED;    this.distinct--;    if (this.distinct < this.lowWaterMark) {        int newCapacity = chooseShrinkCapacity(this.distinct, this.minLoadFactor, this.maxLoadFactor);        rehash(newCapacity);    }    return true;}
d194cfbcb8b2c01f8637c656e44716c0db9d91bdff62b424d938faeb7995e5c9
setUp
protected final void setUp(int initialCapacity, double minLoadFactor, double maxLoadFactor)
{    int capacity = initialCapacity;    super.setUp(capacity, minLoadFactor, maxLoadFactor);    capacity = nextPrime(capacity);    if (capacity == 0) {        capacity = 1;    }        this.table = new Object[capacity];    this.state = new byte[capacity];        this.minLoadFactor = minLoadFactor;    if (capacity == PrimeFinder.LARGEST_PRIME) {        this.maxLoadFactor = 1.0;    } else {        this.maxLoadFactor = maxLoadFactor;    }    this.distinct = 0;        this.freeEntries = capacity;                    this.lowWaterMark = 0;    this.highWaterMark = chooseHighWaterMark(capacity, this.maxLoadFactor);}
577f4cd5f98829ce6ec558dccdb1c96abfae1c1a25d2ae1fc5091b3240da3a9f
trimToSize
public void trimToSize()
{            int newCapacity = nextPrime((int) (1 + 1.2 * size()));    if (table.length > newCapacity) {        rehash(newCapacity);    }}
dfe0e641cb95ab8e03d5d8e0402fb5461fdecc76135d6ed370108bd73f75fbc9
getInternalFactors
 void getInternalFactors(int[] capacity, double[] minLoadFactor, double[] maxLoadFactor)
{    capacity[0] = table.length;    minLoadFactor[0] = this.minLoadFactor;    maxLoadFactor[0] = this.maxLoadFactor;}
803915e853382ad445a6e2333fabb8beb8e4acd70e908a0d818400f7baac42af
isEmpty
public boolean isEmpty()
{    return size() == 0;}
4afeb0868b55bdd8e18a00a3cb43d83e0714378d1c4bb36f0936daefc060e2e8
equals
public boolean equals(Object obj)
{    if (obj == this) {        return true;    }    if (!(obj instanceof OpenHashSet)) {        return false;    }    final OpenHashSet<T> other = (OpenHashSet<T>) obj;    if (other.size() != size()) {        return false;    }    return forEachKey(new ObjectProcedure<T>() {        @Override        public boolean apply(T key) {            return other.contains(key);        }    });}
e02ed83a8f6b64128ddf634099c364e31f381bdec96c1274bd01fac58ed5aefa
apply
public boolean apply(T key)
{    return other.contains(key);}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    ByteBuffer buf = ByteBuffer.allocate(size());    for (int i = 0; i < table.length; i++) {        Object v = table[i];        if (state[i] == FULL) {            buf.putInt(v.hashCode());        }    }    return MurmurHash.hash(buf, this.getClass().getName().hashCode());}
f953961d64692f9b59701c434fe1f9537bac98f3f86c59d94e709afc4047563e
iterator
public Iterator<T> iterator()
{    List<T> keyList = new ArrayList<>();    keys(keyList);    return keyList.iterator();}
91fc4400c9ff6b0731166cd6de664ebb6461c928eba1cb982e4ae232c51cda71
toArray
public Object[] toArray()
{    List<T> keyList = new ArrayList<>();    keys(keyList);    return keyList.toArray();}
3cbdb473c274d3e862530be70634434d7fe4d4d6a811b2c3d8ae16860190e37b
addAll
public boolean addAll(Collection<? extends T> c)
{    boolean anyAdded = false;    for (T o : c) {        boolean added = add(o);        anyAdded |= added;    }    return anyAdded;}
fd464eef4f4e6205704a96d454e3289c2da4051347e8398533124338eb29f159
containsAll
public boolean containsAll(Collection<?> c)
{    for (Object o : c) {        if (!contains(o)) {            return false;        }    }    return true;}
ffff7401397d7a097478dc98b31fe0fa2424d40a29232401684bbb6dc7f20b7c
removeAll
public boolean removeAll(Collection<?> c)
{    boolean anyRemoved = false;    for (Object o : c) {        boolean removed = remove(o);        anyRemoved |= removed;    }    return anyRemoved;}
609acc2fd25fb3bb1f6a5af53227b6ccef0e2d5ba6c913c6d67ce78625568ff0
retainAll
public boolean retainAll(Collection<?> c)
{    final Collection<?> finalCollection = c;    final boolean[] modified = new boolean[1];    modified[0] = false;    forEachKey(new ObjectProcedure<T>() {        @Override        public boolean apply(T element) {            if (!finalCollection.contains(element)) {                remove(element);                modified[0] = true;            }            return true;        }    });    return modified[0];}
3b01010b884f2953f90de994acd177af6c04a77b9050e98ed8c2322cdebf1704
apply
public boolean apply(T element)
{    if (!finalCollection.contains(element)) {        remove(element);        modified[0] = true;    }    return true;}
1fc3e4a6e9961a2a298ba3a671fe0fc08839f493dadc055be630bf185c61b154
toArray
public T1[] toArray(T1[] a)
{    return keys().toArray(a);}
f75941478d07e887450ff513e107cd0ed8e344c3d0c17e2c02aa0be288bdbb0b
keys
public List<T> keys()
{    List<T> keys = new ArrayList<>();    keys(keys);    return keys;}
a35580dbfc415b1f3625357fed624473c88fa9bf307b27c5d76c2ff669c163bf
cond
public double cond()
{    return s[0] / s[Math.min(m, n) - 1];}
7e3e361fb969282a2253da5017c67431cb45a0b84433366b55b979b22970c017
getS
public Matrix getS()
{    double[][] s = new double[n][n];    for (int i = 0; i < n; i++) {        for (int j = 0; j < n; j++) {            s[i][j] = 0.0;        }        s[i][i] = this.s[i];    }    return new DenseMatrix(s);}
3da9ef970f8646860b6ab3a53258a7825c4704ad3274345468789d8928c7acb5
getSingularValues
public double[] getSingularValues()
{    return s;}
b93c02d3200f74c6697e4881155aab7d7cc4f51c675f9516cb10337d05447b38
getU
public Matrix getU()
{    if (transpositionNeeded) {                return new DenseMatrix(v);    } else {        int numCols = Math.min(m + 1, n);        Matrix r = new DenseMatrix(m, numCols);        for (int i = 0; i < m; i++) {            for (int j = 0; j < numCols; j++) {                r.set(i, j, u[i][j]);            }        }        return r;    }}
26cefa3b556cdac980c8fcb58bbf384dae8a5355cbaff131190aec58de3365e0
getV
public Matrix getV()
{    if (transpositionNeeded) {                int numCols = Math.min(m + 1, n);        Matrix r = new DenseMatrix(m, numCols);        for (int i = 0; i < m; i++) {            for (int j = 0; j < numCols; j++) {                r.set(i, j, u[i][j]);            }        }        return r;    } else {        return new DenseMatrix(v);    }}
2241ceee4a9f3c426c4edbef08ab09129574f3fc9fd91bb18b33b8f3e1a1255f
norm2
public double norm2()
{    return s[0];}
708faa75d7593a01d002730e179262aaa26913772fb458ae8aebdc9852ea23ea
rank
public int rank()
{    double eps = Math.pow(2.0, -52.0);    double tol = Math.max(m, n) * s[0] * eps;    int r = 0;    for (double value : s) {        if (value > tol) {            r++;        }    }    return r;}
91a3438ca265e110811e0578efd45d66befb93481a574de213a8fc1c6259c665
getCovariance
 Matrix getCovariance(double minSingularValue)
{    Matrix j = new DenseMatrix(s.length, s.length);    Matrix vMat = new DenseMatrix(this.v);    for (int i = 0; i < s.length; i++) {        j.set(i, i, s[i] >= minSingularValue ? 1 / (s[i] * s[i]) : 0.0);    }    return vMat.times(j).times(vMat.transpose());}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    StringBuilder buf = new StringBuilder();    buf.append("---------------------------------------------------------------------\n");    buf.append("SingularValueDecomposition(A) --> cond(A), rank(A), norm2(A), U, S, V\n");    buf.append("---------------------------------------------------------------------\n");    buf.append("cond = ");    String unknown = "Illegal operation or error: ";    try {        buf.append(String.valueOf(this.cond()));    } catch (IllegalArgumentException exc) {        buf.append(unknown).append(exc.getMessage());    }    buf.append("\nrank = ");    try {        buf.append(String.valueOf(this.rank()));    } catch (IllegalArgumentException exc) {        buf.append(unknown).append(exc.getMessage());    }    buf.append("\nnorm2 = ");    try {        buf.append(String.valueOf(this.norm2()));    } catch (IllegalArgumentException exc) {        buf.append(unknown).append(exc.getMessage());    }    buf.append("\n\nU = ");    try {        buf.append(String.valueOf(this.getU()));    } catch (IllegalArgumentException exc) {        buf.append(unknown).append(exc.getMessage());    }    buf.append("\n\nS = ");    try {        buf.append(String.valueOf(this.getS()));    } catch (IllegalArgumentException exc) {        buf.append(unknown).append(exc.getMessage());    }    buf.append("\n\nV = ");    try {        buf.append(String.valueOf(this.getV()));    } catch (IllegalArgumentException exc) {        buf.append(unknown).append(exc.getMessage());    }    return buf.toString();}
9805b83dd207a4277bee8a0c093023da872498b20ef8ee24490589bfb7298ab5
solve
public Vector solve(VectorIterable a, Vector b)
{    return solve(a, b, null, b.size() + 2, DEFAULT_MAX_ERROR);}
dfb05d11ff0f0071bf51883aaf141bd6b76a6e30aad2a09de8db408e468a4ab0
solve
public Vector solve(VectorIterable a, Vector b, Preconditioner precond)
{    return solve(a, b, precond, b.size() + 2, DEFAULT_MAX_ERROR);}
3b398953662a43cbef8f2f5bac38141e11cac94ab43b99808ba9bb75ca3b915d
solve
public Vector solve(VectorIterable a, Vector b, Preconditioner preconditioner, int maxIterations, double maxError)
{    if (a.numRows() != a.numCols()) {        throw new IllegalArgumentException("Matrix must be square, symmetric and positive definite.");    }    if (a.numCols() != b.size()) {        throw new CardinalityException(a.numCols(), b.size());    }    if (maxIterations <= 0) {        throw new IllegalArgumentException("Max iterations must be positive.");    }    if (maxError < 0.0) {        throw new IllegalArgumentException("Max error must be non-negative.");    }    Vector x = new DenseVector(b.size());    iterations = 0;    Vector residual = b.minus(a.times(x));    residualNormSquared = residual.dot(residual);    log.info("Conjugate gradient initial residual norm = {}", Math.sqrt(residualNormSquared));    double previousConditionedNormSqr = 0.0;    Vector updateDirection = null;    while (Math.sqrt(residualNormSquared) > maxError && iterations < maxIterations) {        Vector conditionedResidual;        double conditionedNormSqr;        if (preconditioner == null) {            conditionedResidual = residual;            conditionedNormSqr = residualNormSquared;        } else {            conditionedResidual = preconditioner.precondition(residual);            conditionedNormSqr = residual.dot(conditionedResidual);        }        ++iterations;        if (iterations == 1) {            updateDirection = new DenseVector(conditionedResidual);        } else {            double beta = conditionedNormSqr / previousConditionedNormSqr;                        updateDirection.assign(Functions.MULT, beta);            updateDirection.assign(conditionedResidual, Functions.PLUS);        }        Vector aTimesUpdate = a.times(updateDirection);        double alpha = conditionedNormSqr / updateDirection.dot(aTimesUpdate);                PLUS_MULT.setMultiplicator(alpha);        x.assign(updateDirection, PLUS_MULT);                PLUS_MULT.setMultiplicator(-alpha);        residual.assign(aTimesUpdate, PLUS_MULT);        previousConditionedNormSqr = conditionedNormSqr;        residualNormSquared = residual.dot(residual);        log.info("Conjugate gradient iteration {} residual norm = {}", iterations, Math.sqrt(residualNormSquared));    }    return x;}
c094dd2808b32821554c91c98d7ecc248df73b37096e6a8b942ce9f00e514198
getIterations
public int getIterations()
{    return iterations;}
03ac3cc817a67d2bd2870a81504903e87d6aebceef20c0fe76c60e15a1f1de14
getResidualNorm
public double getResidualNorm()
{    return Math.sqrt(residualNormSquared);}
26cefa3b556cdac980c8fcb58bbf384dae8a5355cbaff131190aec58de3365e0
getV
public Matrix getV()
{    return v.like().assign(v);}
00263375a3c17bca1c8554803c651a4cd1500311ef751911e209d1995d06ed9a
getRealEigenvalues
public Vector getRealEigenvalues()
{    return d;}
70698dce22fa168bfae15f71bb2b4790959cba413965133160b117d56c3df980
getImagEigenvalues
public Vector getImagEigenvalues()
{    return e;}
5c73120663114dd8e81b101880b7711ae9389c1ef105dba9ca51da3d52114d66
getD
public Matrix getD()
{    Matrix x = new DenseMatrix(n, n);    x.assign(0);    x.viewDiagonal().assign(d);    for (int i = 0; i < n; i++) {        double v = e.getQuick(i);        if (v > 0) {            x.setQuick(i, i + 1, v);        } else if (v < 0) {            x.setQuick(i, i - 1, v);        }    }    return x;}
3d35756db5c0baa46020b411e0e70d319272a08d1f89a535bd0a53eb93fcb224
tred2
private void tred2()
{                    d.assign(v.viewColumn(n - 1));    for (int i = n - 1; i > 0; i--) {                double scale = d.viewPart(0, i).norm(1);        double h = 0.0;        if (scale == 0.0) {            e.setQuick(i, d.getQuick(i - 1));            for (int j = 0; j < i; j++) {                d.setQuick(j, v.getQuick(i - 1, j));                v.setQuick(i, j, 0.0);                v.setQuick(j, i, 0.0);            }        } else {            for (int k = 0; k < i; k++) {                d.setQuick(k, d.getQuick(k) / scale);                h += d.getQuick(k) * d.getQuick(k);            }            double f = d.getQuick(i - 1);            double g = Math.sqrt(h);            if (f > 0) {                g = -g;            }            e.setQuick(i, scale * g);            h -= f * g;            d.setQuick(i - 1, f - g);            for (int j = 0; j < i; j++) {                e.setQuick(j, 0.0);            }            for (int j = 0; j < i; j++) {                f = d.getQuick(j);                v.setQuick(j, i, f);                g = e.getQuick(j) + v.getQuick(j, j) * f;                for (int k = j + 1; k <= i - 1; k++) {                    g += v.getQuick(k, j) * d.getQuick(k);                    e.setQuick(k, e.getQuick(k) + v.getQuick(k, j) * f);                }                e.setQuick(j, g);            }            f = 0.0;            for (int j = 0; j < i; j++) {                e.setQuick(j, e.getQuick(j) / h);                f += e.getQuick(j) * d.getQuick(j);            }            double hh = f / (h + h);            for (int j = 0; j < i; j++) {                e.setQuick(j, e.getQuick(j) - hh * d.getQuick(j));            }            for (int j = 0; j < i; j++) {                f = d.getQuick(j);                g = e.getQuick(j);                for (int k = j; k <= i - 1; k++) {                    v.setQuick(k, j, v.getQuick(k, j) - (f * e.getQuick(k) + g * d.getQuick(k)));                }                d.setQuick(j, v.getQuick(i - 1, j));                v.setQuick(i, j, 0.0);            }        }        d.setQuick(i, h);    }    for (int i = 0; i < n - 1; i++) {        v.setQuick(n - 1, i, v.getQuick(i, i));        v.setQuick(i, i, 1.0);        double h = d.getQuick(i + 1);        if (h != 0.0) {            for (int k = 0; k <= i; k++) {                d.setQuick(k, v.getQuick(k, i + 1) / h);            }            for (int j = 0; j <= i; j++) {                double g = 0.0;                for (int k = 0; k <= i; k++) {                    g += v.getQuick(k, i + 1) * v.getQuick(k, j);                }                for (int k = 0; k <= i; k++) {                    v.setQuick(k, j, v.getQuick(k, j) - g * d.getQuick(k));                }            }        }        for (int k = 0; k <= i; k++) {            v.setQuick(k, i + 1, 0.0);        }    }    d.assign(v.viewRow(n - 1));    v.viewRow(n - 1).assign(0);    v.setQuick(n - 1, n - 1, 1.0);    e.setQuick(0, 0.0);}
e82d11270189028e499d3323b79c4b5db97153a24785326a01c54985fb4e8995
tql2
private void tql2()
{                    e.viewPart(0, n - 1).assign(e.viewPart(1, n - 1));    e.setQuick(n - 1, 0.0);    double f = 0.0;    double tst1 = 0.0;    double eps = Math.pow(2.0, -52.0);    for (int l = 0; l < n; l++) {                tst1 = Math.max(tst1, Math.abs(d.getQuick(l)) + Math.abs(e.getQuick(l)));        int m = l;        while (m < n) {            if (Math.abs(e.getQuick(m)) <= eps * tst1) {                break;            }            m++;        }        if (m > l) {            do {                                double g = d.getQuick(l);                double p = (d.getQuick(l + 1) - g) / (2.0 * e.getQuick(l));                double r = Math.hypot(p, 1.0);                if (p < 0) {                    r = -r;                }                d.setQuick(l, e.getQuick(l) / (p + r));                d.setQuick(l + 1, e.getQuick(l) * (p + r));                double dl1 = d.getQuick(l + 1);                double h = g - d.getQuick(l);                for (int i = l + 2; i < n; i++) {                    d.setQuick(i, d.getQuick(i) - h);                }                f += h;                                p = d.getQuick(m);                double c = 1.0;                double c2 = c;                double c3 = c;                double el1 = e.getQuick(l + 1);                double s = 0.0;                double s2 = 0.0;                for (int i = m - 1; i >= l; i--) {                    c3 = c2;                    c2 = c;                    s2 = s;                    g = c * e.getQuick(i);                    h = c * p;                    r = Math.hypot(p, e.getQuick(i));                    e.setQuick(i + 1, s * r);                    s = e.getQuick(i) / r;                    c = p / r;                    p = c * d.getQuick(i) - s * g;                    d.setQuick(i + 1, h + s * (c * g + s * d.getQuick(i)));                    for (int k = 0; k < n; k++) {                        h = v.getQuick(k, i + 1);                        v.setQuick(k, i + 1, s * v.getQuick(k, i) + c * h);                        v.setQuick(k, i, c * v.getQuick(k, i) - s * h);                    }                }                p = -s * s2 * c3 * el1 * e.getQuick(l) / dl1;                e.setQuick(l, s * p);                d.setQuick(l, c * p);                        } while (Math.abs(e.getQuick(l)) > eps * tst1);        }        d.setQuick(l, d.getQuick(l) + f);        e.setQuick(l, 0.0);    }    for (int i = 0; i < n - 1; i++) {        int k = i;        double p = d.getQuick(i);        for (int j = i + 1; j < n; j++) {            if (d.getQuick(j) > p) {                k = j;                p = d.getQuick(j);            }        }        if (k != i) {            d.setQuick(k, d.getQuick(i));            d.setQuick(i, p);            for (int j = 0; j < n; j++) {                p = v.getQuick(j, i);                v.setQuick(j, i, v.getQuick(j, k));                v.setQuick(j, k, p);            }        }    }}
611f7d928616c7d251e84db54995eb86b96d60fca869896f16cb11538c701439
orthes
private Matrix orthes(Matrix x)
{        Vector ort = new DenseVector(n);    Matrix hessenBerg = new DenseMatrix(n, n).assign(x);                    int low = 0;    int high = n - 1;    for (int m = low + 1; m <= high - 1; m++) {                Vector hColumn = hessenBerg.viewColumn(m - 1).viewPart(m, high - m + 1);        double scale = hColumn.norm(1);        if (scale != 0.0) {                        ort.viewPart(m, high - m + 1).assign(hColumn, Functions.plusMult(1 / scale));            double h = ort.viewPart(m, high - m + 1).getLengthSquared();            double g = Math.sqrt(h);            if (ort.getQuick(m) > 0) {                g = -g;            }            h -= ort.getQuick(m) * g;            ort.setQuick(m, ort.getQuick(m) - g);                                    Vector ortPiece = ort.viewPart(m, high - m + 1);            for (int j = m; j < n; j++) {                double f = ortPiece.dot(hessenBerg.viewColumn(j).viewPart(m, high - m + 1)) / h;                hessenBerg.viewColumn(j).viewPart(m, high - m + 1).assign(ortPiece, Functions.plusMult(-f));            }            for (int i = 0; i <= high; i++) {                double f = ortPiece.dot(hessenBerg.viewRow(i).viewPart(m, high - m + 1)) / h;                hessenBerg.viewRow(i).viewPart(m, high - m + 1).assign(ortPiece, Functions.plusMult(-f));            }            ort.setQuick(m, scale * ort.getQuick(m));            hessenBerg.setQuick(m, m - 1, scale * g);        }    }        v.assign(0);    v.viewDiagonal().assign(1);    for (int m = high - 1; m >= low + 1; m--) {        if (hessenBerg.getQuick(m, m - 1) != 0.0) {            ort.viewPart(m + 1, high - m).assign(hessenBerg.viewColumn(m - 1).viewPart(m + 1, high - m));            for (int j = m; j <= high; j++) {                double g = ort.viewPart(m, high - m + 1).dot(v.viewColumn(j).viewPart(m, high - m + 1));                                g = g / ort.getQuick(m) / hessenBerg.getQuick(m, m - 1);                v.viewColumn(j).viewPart(m, high - m + 1).assign(ort.viewPart(m, high - m + 1), Functions.plusMult(g));            }        }    }    return hessenBerg;}
88004726cdf798fcdbee457a66a7b43bdf5862e48442b484dcb8e8d1d0d815a1
cdiv
private void cdiv(double xr, double xi, double yr, double yi)
{    double r;    double d;    if (Math.abs(yr) > Math.abs(yi)) {        r = yi / yr;        d = yr + r * yi;        cdivr = (xr + r * xi) / d;        cdivi = (xi - r * xr) / d;    } else {        r = yr / yi;        d = yi + r * yr;        cdivr = (r * xr + xi) / d;        cdivi = (r * xi - xr) / d;    }}
cc11fc1e49816c5e33af05f1cfd361531aca0c9648798d4cc9046e694fc81dd4
hqr2
private void hqr2(Matrix h)
{                        int nn = this.n;    int n = nn - 1;    int low = 0;    int high = nn - 1;    double eps = Math.pow(2.0, -52.0);    double exshift = 0.0;    double p = 0;    double q = 0;    double r = 0;    double s = 0;    double z = 0;    double w;    double x;    double y;        double norm = h.aggregate(Functions.PLUS, Functions.ABS);        int iter = 0;    while (n >= low) {                int l = n;        while (l > low) {            s = Math.abs(h.getQuick(l - 1, l - 1)) + Math.abs(h.getQuick(l, l));            if (s == 0.0) {                s = norm;            }            if (Math.abs(h.getQuick(l, l - 1)) < eps * s) {                break;            }            l--;        }        if (l == n) {                        h.setQuick(n, n, h.getQuick(n, n) + exshift);            d.setQuick(n, h.getQuick(n, n));            e.setQuick(n, 0.0);            n--;            iter = 0;        } else if (l == n - 1) {                        w = h.getQuick(n, n - 1) * h.getQuick(n - 1, n);            p = (h.getQuick(n - 1, n - 1) - h.getQuick(n, n)) / 2.0;            q = p * p + w;            z = Math.sqrt(Math.abs(q));            h.setQuick(n, n, h.getQuick(n, n) + exshift);            h.setQuick(n - 1, n - 1, h.getQuick(n - 1, n - 1) + exshift);            x = h.getQuick(n, n);                        if (q >= 0) {                if (p >= 0) {                    z = p + z;                } else {                    z = p - z;                }                d.setQuick(n - 1, x + z);                d.setQuick(n, d.getQuick(n - 1));                if (z != 0.0) {                    d.setQuick(n, x - w / z);                }                e.setQuick(n - 1, 0.0);                e.setQuick(n, 0.0);                x = h.getQuick(n, n - 1);                s = Math.abs(x) + Math.abs(z);                p = x / s;                q = z / s;                r = Math.sqrt(p * p + q * q);                p /= r;                q /= r;                for (int j = n - 1; j < nn; j++) {                    z = h.getQuick(n - 1, j);                    h.setQuick(n - 1, j, q * z + p * h.getQuick(n, j));                    h.setQuick(n, j, q * h.getQuick(n, j) - p * z);                }                for (int i = 0; i <= n; i++) {                    z = h.getQuick(i, n - 1);                    h.setQuick(i, n - 1, q * z + p * h.getQuick(i, n));                    h.setQuick(i, n, q * h.getQuick(i, n) - p * z);                }                for (int i = low; i <= high; i++) {                    z = v.getQuick(i, n - 1);                    v.setQuick(i, n - 1, q * z + p * v.getQuick(i, n));                    v.setQuick(i, n, q * v.getQuick(i, n) - p * z);                }                        } else {                d.setQuick(n - 1, x + p);                d.setQuick(n, x + p);                e.setQuick(n - 1, z);                e.setQuick(n, -z);            }            n -= 2;            iter = 0;                } else {                        x = h.getQuick(n, n);            y = 0.0;            w = 0.0;            if (l < n) {                y = h.getQuick(n - 1, n - 1);                w = h.getQuick(n, n - 1) * h.getQuick(n - 1, n);            }            if (iter == 10) {                exshift += x;                for (int i = low; i <= n; i++) {                    h.setQuick(i, i, x);                }                s = Math.abs(h.getQuick(n, n - 1)) + Math.abs(h.getQuick(n - 1, n - 2));                x = y = 0.75 * s;                w = -0.4375 * s * s;            }            if (iter == 30) {                s = (y - x) / 2.0;                s = s * s + w;                if (s > 0) {                    s = Math.sqrt(s);                    if (y < x) {                        s = -s;                    }                    s = x - w / ((y - x) / 2.0 + s);                    for (int i = low; i <= n; i++) {                        h.setQuick(i, i, h.getQuick(i, i) - s);                    }                    exshift += s;                    x = y = w = 0.964;                }            }                        iter++;                        int m = n - 2;            while (m >= l) {                z = h.getQuick(m, m);                r = x - z;                s = y - z;                p = (r * s - w) / h.getQuick(m + 1, m) + h.getQuick(m, m + 1);                q = h.getQuick(m + 1, m + 1) - z - r - s;                r = h.getQuick(m + 2, m + 1);                s = Math.abs(p) + Math.abs(q) + Math.abs(r);                p /= s;                q /= s;                r /= s;                if (m == l) {                    break;                }                double hmag = Math.abs(h.getQuick(m - 1, m - 1)) + Math.abs(h.getQuick(m + 1, m + 1));                double threshold = eps * Math.abs(p) * (Math.abs(z) + hmag);                if (Math.abs(h.getQuick(m, m - 1)) * (Math.abs(q) + Math.abs(r)) < threshold) {                    break;                }                m--;            }            for (int i = m + 2; i <= n; i++) {                h.setQuick(i, i - 2, 0.0);                if (i > m + 2) {                    h.setQuick(i, i - 3, 0.0);                }            }            for (int k = m; k <= n - 1; k++) {                boolean notlast = k != n - 1;                if (k != m) {                    p = h.getQuick(k, k - 1);                    q = h.getQuick(k + 1, k - 1);                    r = notlast ? h.getQuick(k + 2, k - 1) : 0.0;                    x = Math.abs(p) + Math.abs(q) + Math.abs(r);                    if (x != 0.0) {                        p /= x;                        q /= x;                        r /= x;                    }                }                if (x == 0.0) {                    break;                }                s = Math.sqrt(p * p + q * q + r * r);                if (p < 0) {                    s = -s;                }                if (s != 0) {                    if (k != m) {                        h.setQuick(k, k - 1, -s * x);                    } else if (l != m) {                        h.setQuick(k, k - 1, -h.getQuick(k, k - 1));                    }                    p += s;                    x = p / s;                    y = q / s;                    z = r / s;                    q /= p;                    r /= p;                    for (int j = k; j < nn; j++) {                        p = h.getQuick(k, j) + q * h.getQuick(k + 1, j);                        if (notlast) {                            p += r * h.getQuick(k + 2, j);                            h.setQuick(k + 2, j, h.getQuick(k + 2, j) - p * z);                        }                        h.setQuick(k, j, h.getQuick(k, j) - p * x);                        h.setQuick(k + 1, j, h.getQuick(k + 1, j) - p * y);                    }                    for (int i = 0; i <= Math.min(n, k + 3); i++) {                        p = x * h.getQuick(i, k) + y * h.getQuick(i, k + 1);                        if (notlast) {                            p += z * h.getQuick(i, k + 2);                            h.setQuick(i, k + 2, h.getQuick(i, k + 2) - p * r);                        }                        h.setQuick(i, k, h.getQuick(i, k) - p);                        h.setQuick(i, k + 1, h.getQuick(i, k + 1) - p * q);                    }                    for (int i = low; i <= high; i++) {                        p = x * v.getQuick(i, k) + y * v.getQuick(i, k + 1);                        if (notlast) {                            p += z * v.getQuick(i, k + 2);                            v.setQuick(i, k + 2, v.getQuick(i, k + 2) - p * r);                        }                        v.setQuick(i, k, v.getQuick(i, k) - p);                        v.setQuick(i, k + 1, v.getQuick(i, k + 1) - p * q);                    }                }                        }                }        }    if (norm == 0.0) {        return;    }    for (n = nn - 1; n >= 0; n--) {        p = d.getQuick(n);        q = e.getQuick(n);                double t;        if (q == 0) {            int l = n;            h.setQuick(n, n, 1.0);            for (int i = n - 1; i >= 0; i--) {                w = h.getQuick(i, i) - p;                r = 0.0;                for (int j = l; j <= n; j++) {                    r += h.getQuick(i, j) * h.getQuick(j, n);                }                if (e.getQuick(i) < 0.0) {                    z = w;                    s = r;                } else {                    l = i;                    if (e.getQuick(i) == 0.0) {                        if (w == 0.0) {                            h.setQuick(i, n, -r / (eps * norm));                        } else {                            h.setQuick(i, n, -r / w);                        }                                        } else {                        x = h.getQuick(i, i + 1);                        y = h.getQuick(i + 1, i);                        q = (d.getQuick(i) - p) * (d.getQuick(i) - p) + e.getQuick(i) * e.getQuick(i);                        t = (x * s - z * r) / q;                        h.setQuick(i, n, t);                        if (Math.abs(x) > Math.abs(z)) {                            h.setQuick(i + 1, n, (-r - w * t) / x);                        } else {                            h.setQuick(i + 1, n, (-s - y * t) / z);                        }                    }                                        t = Math.abs(h.getQuick(i, n));                    if (eps * t * t > 1) {                        for (int j = i; j <= n; j++) {                            h.setQuick(j, n, h.getQuick(j, n) / t);                        }                    }                }            }                } else if (q < 0) {            int l = n - 1;            if (Math.abs(h.getQuick(n, n - 1)) > Math.abs(h.getQuick(n - 1, n))) {                h.setQuick(n - 1, n - 1, q / h.getQuick(n, n - 1));                h.setQuick(n - 1, n, -(h.getQuick(n, n) - p) / h.getQuick(n, n - 1));            } else {                cdiv(0.0, -h.getQuick(n - 1, n), h.getQuick(n - 1, n - 1) - p, q);                h.setQuick(n - 1, n - 1, cdivr);                h.setQuick(n - 1, n, cdivi);            }            h.setQuick(n, n - 1, 0.0);            h.setQuick(n, n, 1.0);            for (int i = n - 2; i >= 0; i--) {                double ra = 0.0;                double sa = 0.0;                for (int j = l; j <= n; j++) {                    ra += h.getQuick(i, j) * h.getQuick(j, n - 1);                    sa += h.getQuick(i, j) * h.getQuick(j, n);                }                w = h.getQuick(i, i) - p;                if (e.getQuick(i) < 0.0) {                    z = w;                    r = ra;                    s = sa;                } else {                    l = i;                    if (e.getQuick(i) == 0) {                        cdiv(-ra, -sa, w, q);                        h.setQuick(i, n - 1, cdivr);                        h.setQuick(i, n, cdivi);                    } else {                                                x = h.getQuick(i, i + 1);                        y = h.getQuick(i + 1, i);                        double vr = (d.getQuick(i) - p) * (d.getQuick(i) - p) + e.getQuick(i) * e.getQuick(i) - q * q;                        double vi = (d.getQuick(i) - p) * 2.0 * q;                        if (vr == 0.0 && vi == 0.0) {                            double hmag = Math.abs(x) + Math.abs(y);                            vr = eps * norm * (Math.abs(w) + Math.abs(q) + hmag + Math.abs(z));                        }                        cdiv(x * r - z * ra + q * sa, x * s - z * sa - q * ra, vr, vi);                        h.setQuick(i, n - 1, cdivr);                        h.setQuick(i, n, cdivi);                        if (Math.abs(x) > (Math.abs(z) + Math.abs(q))) {                            h.setQuick(i + 1, n - 1, (-ra - w * h.getQuick(i, n - 1) + q * h.getQuick(i, n)) / x);                            h.setQuick(i + 1, n, (-sa - w * h.getQuick(i, n) - q * h.getQuick(i, n - 1)) / x);                        } else {                            cdiv(-r - y * h.getQuick(i, n - 1), -s - y * h.getQuick(i, n), z, q);                            h.setQuick(i + 1, n - 1, cdivr);                            h.setQuick(i + 1, n, cdivi);                        }                    }                                        t = Math.max(Math.abs(h.getQuick(i, n - 1)), Math.abs(h.getQuick(i, n)));                    if (eps * t * t > 1) {                        for (int j = i; j <= n; j++) {                            h.setQuick(j, n - 1, h.getQuick(j, n - 1) / t);                            h.setQuick(j, n, h.getQuick(j, n) / t);                        }                    }                }            }        }    }    for (int i = 0; i < nn; i++) {        if (i < low || i > high) {            for (int j = i; j < nn; j++) {                v.setQuick(i, j, h.getQuick(i, j));            }        }    }    for (int j = nn - 1; j >= low; j--) {        for (int i = low; i <= high; i++) {            z = 0.0;            for (int k = low; k <= Math.min(j, high); k++) {                z += v.getQuick(i, k) * h.getQuick(k, j);            }            v.setQuick(i, j, z);        }    }}
14fbde915bb070788d8ac312c60ef4697645291b312e12aba44198a14cdda793
isSymmetric
private static boolean isSymmetric(Matrix a)
{    /*    Symmetry flag.    */    int n = a.columnSize();    boolean isSymmetric = true;    for (int j = 0; (j < n) && isSymmetric; j++) {        for (int i = 0; (i < n) && isSymmetric; i++) {            isSymmetric = a.getQuick(i, j) == a.getQuick(j, i);        }    }    return isSymmetric;}
6d529a2a94608d9d0a6b70ff580a11f64ed2b71eb703f49089b4c5607f2ae302
precondition
public Vector precondition(Vector v)
{    return v.times(inverseDiagonal);}
bedb10fa86c22311367a307995c594009e23913240dd71d6682cf2a7d40678f7
getIterationCount
public int getIterationCount()
{    return iteration;}
03ac3cc817a67d2bd2870a81504903e87d6aebceef20c0fe76c60e15a1f1de14
getResidualNorm
public double getResidualNorm()
{    return residualNorm;}
22427a22d7e2139d009c26da4e2ffe7441aa7cc52f8f83b17756bb5b293024ec
getNormalEquationResidual
public double getNormalEquationResidual()
{    return normalEquationResidual;}
c21b59559cf27fea5c39852ef9cb19cb8cde6f98e247b818d27bf757fdb0f89e
getANorm
public double getANorm()
{    return normA;}
62d4de63811d31aed9992f1b4b46a5eb459c7858eceb15d5024fbf722410ce9c
getCondition
public double getCondition()
{    return condA;}
1ae6729d1fb3c8e671f24e8e88f03adbe5ba53be426138c16b808d301bc14704
getXNorm
public double getXNorm()
{    return xNorm;}
1c945edb55a5c621aca985430a44c67f32900b054f3bbdc7b7a8e9a9db836171
solve
public Vector solve(Matrix A, Vector b)
{    /*        % Initialize.        hdg1 = '   itn      x(1)       norm r    norm A''r';        hdg2 = ' compatible   LS      norm A   cond A';        pfreq  = 20;   % print frequency (for repeating the heading)        pcount = 0;    % print counter        % Determine dimensions m and n, and        % form the first vectors u and v.        % These satisfy  beta*u = b,  alpha*v = A'u.    */    log.debug("   itn         x(1)     norm r   norm A'r");    log.debug("   compatible   LS      norm A   cond A");    Matrix transposedA = A.transpose();    Vector u = b;    double beta = u.norm(2);    if (beta > 0) {        u = u.divide(beta);    }    Vector v = transposedA.times(u);    int m = A.numRows();    int n = A.numCols();    int minDim = Math.min(m, n);    if (iterationLimit == -1) {        iterationLimit = minDim;    }    if (log.isDebugEnabled()) {        log.debug("LSMR - Least-squares solution of  Ax = b, based on Matlab Version 1.02, 14 Apr 2010, " + "Mahout version {}", getClass().getPackage().getImplementationVersion());        log.debug(String.format("The matrix A has %d rows  and %d cols, lambda = %.4g, atol = %g, btol = %g", m, n, lambda, aTolerance, bTolerance));    }    double alpha = v.norm(2);    if (alpha > 0) {        v.assign(Functions.div(alpha));    }        localPointer = 0;                    localV = new Vector[Math.min(localSize, minDim)];    boolean localOrtho = false;    if (localSize > 0) {        localOrtho = true;        localV[0] = v;    }        iteration = 0;    double zetabar = alpha * beta;    double alphabar = alpha;    Vector h = v;    Vector hbar = zeros(n);    Vector x = zeros(n);        double betadd = beta;        double aNorm = alpha * alpha;        double normb = beta;    double ctol = 0;    if (conditionLimit > 0) {        ctol = 1 / conditionLimit;    }    residualNorm = beta;        normalEquationResidual = alpha * beta;    if (normalEquationResidual == 0) {        return x;    }    if (log.isDebugEnabled()) {        double test2 = alpha / beta;                log.debug("{} {}", iteration, x.get(0));        log.debug("{} {}", residualNorm, normalEquationResidual);        double test1 = 1;        log.debug("{} {}", test1, test2);    }                double rho = 1;    double rhobar = 1;    double cbar = 1;    double sbar = 0;    double betad = 0;    double rhodold = 1;    double tautildeold = 0;    double thetatilde = 0;    double zeta = 0;    double d = 0;    double maxrbar = 0;    double minrbar = 1.0e+100;    StopCode stop = StopCode.CONTINUE;    while (iteration <= iterationLimit && stop == StopCode.CONTINUE) {        iteration++;                                        u = A.times(v).minus(u.times(alpha));        beta = u.norm(2);        if (beta > 0) {            u.assign(Functions.div(beta));                        if (localOrtho) {                localVEnqueue(v);            }            v = transposedA.times(u).minus(v.times(beta));                        if (localOrtho) {                v = localVOrtho(v);            }            alpha = v.norm(2);            if (alpha > 0) {                v.assign(Functions.div(alpha));            }        }                        double alphahat = Math.hypot(alphabar, lambda);        double chat = alphabar / alphahat;        double shat = lambda / alphahat;                double rhoold = rho;        rho = Math.hypot(alphahat, beta);        double c = alphahat / rho;        double s = beta / rho;        double thetanew = s * alpha;        alphabar = c * alpha;                double rhobarold = rhobar;        double zetaold = zeta;        double thetabar = sbar * rho;        double rhotemp = cbar * rho;        rhobar = Math.hypot(cbar * rho, thetanew);        cbar = cbar * rho / rhobar;        sbar = thetanew / rhobar;        zeta = cbar * zetabar;        zetabar = -sbar * zetabar;                hbar = h.minus(hbar.times(thetabar * rho / (rhoold * rhobarold)));        x.assign(hbar.times(zeta / (rho * rhobar)), Functions.PLUS);        h = v.minus(h.times(thetanew / rho));                        double betaacute = chat * betadd;        double betacheck = -shat * betadd;                double betahat = c * betaacute;        betadd = -s * betaacute;                        double thetatildeold = thetatilde;        double rhotildeold = Math.hypot(rhodold, thetabar);        double ctildeold = rhodold / rhotildeold;        double stildeold = thetabar / rhotildeold;        thetatilde = stildeold * rhobar;        rhodold = ctildeold * rhobar;        betad = -stildeold * betad + ctildeold * betahat;                        tautildeold = (zetaold - thetatildeold * tautildeold) / rhotildeold;        double taud = (zeta - thetatilde * tautildeold) / rhodold;        d += betacheck * betacheck;        residualNorm = Math.sqrt(d + (betad - taud) * (betad - taud) + betadd * betadd);                aNorm += beta * beta;        normA = Math.sqrt(aNorm);        aNorm += alpha * alpha;                maxrbar = Math.max(maxrbar, rhobarold);        if (iteration > 1) {            minrbar = Math.min(minrbar, rhobarold);        }        condA = Math.max(maxrbar, rhotemp) / Math.min(minrbar, rhotemp);                        normalEquationResidual = Math.abs(zetabar);        xNorm = x.norm(2);                        double test1 = residualNorm / normb;        double test2 = normalEquationResidual / (normA * residualNorm);        double test3 = 1 / condA;        double t1 = test1 / (1 + normA * xNorm / normb);        double rtol = bTolerance + aTolerance * normA * xNorm / normb;        if (iteration > iterationLimit) {            stop = StopCode.ITERATION_LIMIT;        }        if (1 + test3 <= 1) {            stop = StopCode.CONDITION_MACHINE_TOLERANCE;        }        if (1 + test2 <= 1) {            stop = StopCode.LEAST_SQUARE_CONVERGED_MACHINE_TOLERANCE;        }        if (1 + t1 <= 1) {            stop = StopCode.CONVERGED_MACHINE_TOLERANCE;        }        if (test3 <= ctol) {            stop = StopCode.CONDITION;        }        if (test2 <= aTolerance) {            stop = StopCode.CONVERGED;        }        if (test1 <= rtol) {            stop = StopCode.TRIVIAL;        }                if (log.isDebugEnabled()) {            if ((n <= 40) || (iteration <= 10) || (iteration >= iterationLimit - 10) || ((iteration % 10) == 0) || (test3 <= 1.1 * ctol) || (test2 <= 1.1 * aTolerance) || (test1 <= 1.1 * rtol) || (stop != StopCode.CONTINUE)) {                statusDump(x, normA, condA, test1, test2);            }        }    }            log.debug("Finished: {}", stop.getMessage());    return x;/*    if show      fprintf('\n\nLSMR finished')      fprintf('\n%s', msg(istop+1,:))      fprintf('\nistop =%8g    normr =%8.1e'     , istop, normr )      fprintf('    normA =%8.1e    normAr =%8.1e', normA, normAr)      fprintf('\nitn   =%8g    condA =%8.1e'     , itn  , condA )      fprintf('    normx =%8.1e\n', normx)    end    */}
cafb6b52f58bb50f3fbfc4e86188529a1e952d9cf2aa5122a3434c2eaaac3266
statusDump
private void statusDump(Vector x, double normA, double condA, double test1, double test2)
{    log.debug("{} {}", residualNorm, normalEquationResidual);    log.debug("{} {}", iteration, x.get(0));    log.debug("{} {}", test1, test2);    log.debug("{} {}", normA, condA);}
c6d91b64d702601dd7fc138affc59a8099e21bcc5714ba53d7ed55b57a171a92
zeros
private static Vector zeros(int n)
{    return new DenseVector(n);}
2ea82ce7cc9ec983805b8a8438f75a6f7cfc12b12ddb5164b1c857bc3d2ed6d3
localVEnqueue
private void localVEnqueue(Vector v)
{    if (localV.length > 0) {        localV[localPointer] = v;        localPointer = (localPointer + 1) % localV.length;    }}
8ed4dfb2ba02ae888740ccd2d5b76e95aea7825f11d3ebb909682e1247e7384b
localVOrtho
private Vector localVOrtho(Vector v)
{    for (Vector old : localV) {        if (old != null) {            double x = v.dot(old);            v = v.minus(old.times(x));        }    }    return v;}
b46153cc21231cb60e014b6b3c49b437699575e4012681cb08026e5238c66751
getMessage
public String getMessage()
{    return message;}
109924eec2f80a64af18572f8d3fde76b3e6a2ca5ed964fd71e3d54aba68e027
setAtolerance
public void setAtolerance(double aTolerance)
{    this.aTolerance = aTolerance;}
7bffb6e94fabeb17614380297eefbfdbcf73a0884c4530285f10858dc6414db7
setBtolerance
public void setBtolerance(double bTolerance)
{    this.bTolerance = bTolerance;}
20915d4eb00e97373151fd6132b55cad00cdd9b369ef4222db2be8c369de6fd7
setConditionLimit
public void setConditionLimit(double conditionLimit)
{    this.conditionLimit = conditionLimit;}
65d735792d0ef3f56ae294087bba7dd4dbd802eba650115707b741ba74a174f5
setIterationLimit
public void setIterationLimit(int iterationLimit)
{    this.iterationLimit = iterationLimit;}
4bfb6eceb772b56819d6a46e792f15f8cd9c307bed1103e1d309d232b21bb748
setLocalSize
public void setLocalSize(int localSize)
{    this.localSize = localSize;}
f106e2c7f9c824d32f6f7400c6bb6ef6acbfcf9eb0d8de72ba64d97e83466cbc
getLambda
public double getLambda()
{    return lambda;}
f2617ee4cb3d821b66ea2a0aed0931c48f8bf0ee014268237764abb9fb645bb2
getAtolerance
public double getAtolerance()
{    return aTolerance;}
52ac117f969d95231a48254a143e9543f18a4d37f57351318a53aa8df3c8486a
getBtolerance
public double getBtolerance()
{    return bTolerance;}
bab91f38fc7cb29c663e5b3dd31293a35fa270aacc7861a9facde287ff47b360
med3
private static int med3(T[] array, int a, int b, int c, Comparator<T> comp)
{    T x = array[a];    T y = array[b];    T z = array[c];    int comparisonxy = comp.compare(x, y);    int comparisonxz = comp.compare(x, z);    int comparisonyz = comp.compare(y, z);    return comparisonxy < 0 ? (comparisonyz < 0 ? b : (comparisonxz < 0 ? c : a)) : (comparisonyz > 0 ? b : (comparisonxz > 0 ? c : a));}
a8b791e5da299b104885034ddae052936f5f3b89ddb3e74273b97710d4b6d812
med3
private static int med3(byte[] array, int a, int b, int c, ByteComparator comp)
{    byte x = array[a];    byte y = array[b];    byte z = array[c];    int comparisonxy = comp.compare(x, y);    int comparisonxz = comp.compare(x, z);    int comparisonyz = comp.compare(y, z);    return comparisonxy < 0 ? (comparisonyz < 0 ? b : (comparisonxz < 0 ? c : a)) : (comparisonyz > 0 ? b : (comparisonxz > 0 ? c : a));}
b91f0f3fa655936c3d3dd4c089138a66ac7b5710ba6b82f3a9aaf441c7001bbd
med3
private static int med3(char[] array, int a, int b, int c, CharComparator comp)
{    char x = array[a];    char y = array[b];    char z = array[c];    int comparisonxy = comp.compare(x, y);    int comparisonxz = comp.compare(x, z);    int comparisonyz = comp.compare(y, z);    return comparisonxy < 0 ? (comparisonyz < 0 ? b : (comparisonxz < 0 ? c : a)) : (comparisonyz > 0 ? b : (comparisonxz > 0 ? c : a));}
2048f71d7739299934041f0fbe95dc62884e73db884c601f9679f72849a209bc
med3
private static int med3(double[] array, int a, int b, int c, DoubleComparator comp)
{    double x = array[a];    double y = array[b];    double z = array[c];    int comparisonxy = comp.compare(x, y);    int comparisonxz = comp.compare(x, z);    int comparisonyz = comp.compare(y, z);    return comparisonxy < 0 ? (comparisonyz < 0 ? b : (comparisonxz < 0 ? c : a)) : (comparisonyz > 0 ? b : (comparisonxz > 0 ? c : a));}
06e322cb57962947ff47510092c446a920187a1e0ddcd560c57554a4632a7ead
med3
private static int med3(float[] array, int a, int b, int c, FloatComparator comp)
{    float x = array[a];    float y = array[b];    float z = array[c];    int comparisonxy = comp.compare(x, y);    int comparisonxz = comp.compare(x, z);    int comparisonyz = comp.compare(y, z);    return comparisonxy < 0 ? (comparisonyz < 0 ? b : (comparisonxz < 0 ? c : a)) : (comparisonyz > 0 ? b : (comparisonxz > 0 ? c : a));}
218544ac49ecb8196d5b5be740591a46c4f531599cc584ca9ec3b69e4b1ccce6
med3
private static int med3(int[] array, int a, int b, int c, IntComparator comp)
{    int x = array[a];    int y = array[b];    int z = array[c];    int comparisonxy = comp.compare(x, y);    int comparisonxz = comp.compare(x, z);    int comparisonyz = comp.compare(y, z);    return comparisonxy < 0 ? (comparisonyz < 0 ? b : (comparisonxz < 0 ? c : a)) : (comparisonyz > 0 ? b : (comparisonxz > 0 ? c : a));}
e4428db64647c6f223f048ec1337f1231682bbfce25b0d0959b78226ec8b2dd0
med3
private static int med3(int a, int b, int c, IntComparator comp)
{    int comparisonab = comp.compare(a, b);    int comparisonac = comp.compare(a, c);    int comparisonbc = comp.compare(b, c);    return comparisonab < 0 ? (comparisonbc < 0 ? b : (comparisonac < 0 ? c : a)) : (comparisonbc > 0 ? b : (comparisonac > 0 ? c : a));}
6236fb9e5b978434da681603eab7d97ca26dc9ae1b853790359428fd5b3c39c8
med3
private static int med3(long[] array, int a, int b, int c, LongComparator comp)
{    long x = array[a];    long y = array[b];    long z = array[c];    int comparisonxy = comp.compare(x, y);    int comparisonxz = comp.compare(x, z);    int comparisonyz = comp.compare(y, z);    return comparisonxy < 0 ? (comparisonyz < 0 ? b : (comparisonxz < 0 ? c : a)) : (comparisonyz > 0 ? b : (comparisonxz > 0 ? c : a));}
d0081e56eb5b46ea78244a5ec3a4d6506695bd62e0f6fc234cca8569100450d0
med3
private static int med3(short[] array, int a, int b, int c, ShortComparator comp)
{    short x = array[a];    short y = array[b];    short z = array[c];    int comparisonxy = comp.compare(x, y);    int comparisonxz = comp.compare(x, z);    int comparisonyz = comp.compare(y, z);    return comparisonxy < 0 ? (comparisonyz < 0 ? b : (comparisonxz < 0 ? c : a)) : (comparisonyz > 0 ? b : (comparisonxz > 0 ? c : a));}
56f8f81131fc996d9588f12317447b41f171ae71bf70b152f3430dda76e457c9
quickSort
public static void quickSort(byte[] array, int start, int end, ByteComparator comp)
{    Preconditions.checkNotNull(array);    checkBounds(array.length, start, end);    quickSort0(start, end, array, comp);}
50f558d47506e80036d5307c2ddf745e08902d3d632d35cd494ee05cf96b1f7b
checkBounds
private static void checkBounds(int arrLength, int start, int end)
{    if (start > end) {                throw new IllegalArgumentException("Start index " + start + " is greater than end index " + end);    }    if (start < 0) {        throw new ArrayIndexOutOfBoundsException("Array index out of range " + start);    }    if (end > arrLength) {        throw new ArrayIndexOutOfBoundsException("Array index out of range " + end);    }}
02bf92ed026ed59e0b76d0db1f2fd06c618bd0329127ebf2140730267d37792e
quickSort0
private static void quickSort0(int start, int end, byte[] array, ByteComparator comp)
{    byte temp;    int length = end - start;    if (length < 7) {        for (int i = start + 1; i < end; i++) {            for (int j = i; j > start && comp.compare(array[j - 1], array[j]) > 0; j--) {                temp = array[j];                array[j] = array[j - 1];                array[j - 1] = temp;            }        }        return;    }    int middle = (start + end) / 2;    if (length > 7) {        int bottom = start;        int top = end - 1;        if (length > 40) {            length /= 8;            bottom = med3(array, bottom, bottom + length, bottom + (2 * length), comp);            middle = med3(array, middle - length, middle, middle + length, comp);            top = med3(array, top - (2 * length), top - length, top, comp);        }        middle = med3(array, bottom, middle, top, comp);    }    byte partionValue = array[middle];    int a = start;    int b = a;    int c = end - 1;    int d = c;    while (true) {        int comparison;        while (b <= c && (comparison = comp.compare(array[b], partionValue)) <= 0) {            if (comparison == 0) {                temp = array[a];                array[a++] = array[b];                array[b] = temp;            }            b++;        }        while (c >= b && (comparison = comp.compare(array[c], partionValue)) >= 0) {            if (comparison == 0) {                temp = array[c];                array[c] = array[d];                array[d--] = temp;            }            c--;        }        if (b > c) {            break;        }        temp = array[b];        array[b++] = array[c];        array[c--] = temp;    }    length = a - start < b - a ? a - start : b - a;    int l = start;    int h = b - length;    while (length-- > 0) {        temp = array[l];        array[l++] = array[h];        array[h++] = temp;    }    length = d - c < end - 1 - d ? d - c : end - 1 - d;    l = b;    h = end - length;    while (length-- > 0) {        temp = array[l];        array[l++] = array[h];        array[h++] = temp;    }    if ((length = b - a) > 0) {        quickSort0(start, start + length, array, comp);    }    if ((length = d - c) > 0) {        quickSort0(end - length, end, array, comp);    }}
915b28c559d046dc034c312c69d11af2b3e5460f6fc540d20f8164fc85688488
quickSort
public static void quickSort(int start, int end, IntComparator comp, Swapper swap)
{    checkBounds(end + 1, start, end);    quickSort0(start, end, comp, swap);}
a3060d95a694ce53b17acb6ed22d2fcc0931823da52ad2410769b836d7c954fe
quickSort0
private static void quickSort0(int start, int end, IntComparator comp, Swapper swap)
{    int length = end - start;    if (length < 7) {        insertionSort(start, end, comp, swap);        return;    }    int middle = (start + end) / 2;    if (length > 7) {        int bottom = start;        int top = end - 1;        if (length > 40) {                        int skosh = length / 8;            bottom = med3(bottom, bottom + skosh, bottom + (2 * skosh), comp);            middle = med3(middle - skosh, middle, middle + skosh, comp);            top = med3(top - (2 * skosh), top - skosh, top, comp);        }        middle = med3(bottom, middle, top, comp);    }        int partitionIndex = middle;        int a = start;    int b = a;    int c = end - 1;    int d = c;    while (b <= c) {                        int comparison;        while (b <= c && (comparison = comp.compare(b, partitionIndex)) <= 0) {            if (comparison == 0) {                if (a == partitionIndex) {                    partitionIndex = b;                } else if (b == partitionIndex) {                    partitionIndex = a;                }                swap.swap(a, b);                a++;            }            b++;        }        while (c >= b && (comparison = comp.compare(c, partitionIndex)) >= 0) {            if (comparison == 0) {                if (c == partitionIndex) {                    partitionIndex = d;                } else if (d == partitionIndex) {                    partitionIndex = c;                }                swap.swap(c, d);                d--;            }            c--;        }        if (b <= c) {                        if (c == partitionIndex) {                partitionIndex = b;            } else if (b == partitionIndex) {                partitionIndex = d;            }            swap.swap(b, c);            b++;            c--;        }    }                            length = Math.min(a - start, b - a);    int l = start;    int h = b - length;    while (length-- > 0) {        swap.swap(l, h);        l++;        h++;    }        length = Math.min(d - c, end - 1 - d);    l = b;    h = end - length;    while (length-- > 0) {        swap.swap(l, h);        l++;        h++;    }        length = b - a;    if (length > 0) {        quickSort0(start, start + length, comp, swap);    }    length = d - c;    if (length > 0) {        quickSort0(end - length, end, comp, swap);    }}
dd9d51e46d359b6223a89191f2ecde8c9cdb70f2c11500fa382dbf096af42dcc
insertionSort
private static void insertionSort(int start, int end, IntComparator comp, Swapper swap)
{    for (int i = start + 1; i < end; i++) {        for (int j = i; j > start && comp.compare(j - 1, j) > 0; j--) {            swap.swap(j - 1, j);        }    }}
d728b2ac5fd21153b3801426862b281d89dcd26b9ad852af1f9eafa038aecd2d
quickSort
public static void quickSort(char[] array, int start, int end, CharComparator comp)
{    Preconditions.checkNotNull(array);    checkBounds(array.length, start, end);    quickSort0(start, end, array, comp);}
493496e475ea55730c6b2156805b3934760a4794ecbaee89f8255c0838e15766
quickSort0
private static void quickSort0(int start, int end, char[] array, CharComparator comp)
{    char temp;    int length = end - start;    if (length < 7) {        for (int i = start + 1; i < end; i++) {            for (int j = i; j > start && comp.compare(array[j - 1], array[j]) > 0; j--) {                temp = array[j];                array[j] = array[j - 1];                array[j - 1] = temp;            }        }        return;    }    int middle = (start + end) / 2;    if (length > 7) {        int bottom = start;        int top = end - 1;        if (length > 40) {            length /= 8;            bottom = med3(array, bottom, bottom + length, bottom + (2 * length), comp);            middle = med3(array, middle - length, middle, middle + length, comp);            top = med3(array, top - (2 * length), top - length, top, comp);        }        middle = med3(array, bottom, middle, top, comp);    }    char partionValue = array[middle];    int a = start;    int b = a;    int c = end - 1;    int d = c;    while (true) {        int comparison;        while (b <= c && (comparison = comp.compare(array[b], partionValue)) <= 0) {            if (comparison == 0) {                temp = array[a];                array[a++] = array[b];                array[b] = temp;            }            b++;        }        while (c >= b && (comparison = comp.compare(array[c], partionValue)) >= 0) {            if (comparison == 0) {                temp = array[c];                array[c] = array[d];                array[d--] = temp;            }            c--;        }        if (b > c) {            break;        }        temp = array[b];        array[b++] = array[c];        array[c--] = temp;    }    length = a - start < b - a ? a - start : b - a;    int l = start;    int h = b - length;    while (length-- > 0) {        temp = array[l];        array[l++] = array[h];        array[h++] = temp;    }    length = d - c < end - 1 - d ? d - c : end - 1 - d;    l = b;    h = end - length;    while (length-- > 0) {        temp = array[l];        array[l++] = array[h];        array[h++] = temp;    }    if ((length = b - a) > 0) {        quickSort0(start, start + length, array, comp);    }    if ((length = d - c) > 0) {        quickSort0(end - length, end, array, comp);    }}
81ffcca6ec54fb70f305e516b87480a50b6c6671513bfe58eaaf85026ff1e500
quickSort
public static void quickSort(double[] array, int start, int end, DoubleComparator comp)
{    Preconditions.checkNotNull(array);    checkBounds(array.length, start, end);    quickSort0(start, end, array, comp);}
900a27ac1d60770db603e80e7f2a56d136b98fd432477a112fa0d3e53d830382
quickSort0
private static void quickSort0(int start, int end, double[] array, DoubleComparator comp)
{    double temp;    int length = end - start;    if (length < 7) {        for (int i = start + 1; i < end; i++) {            for (int j = i; j > start && comp.compare(array[j], array[j - 1]) < 0; j--) {                temp = array[j];                array[j] = array[j - 1];                array[j - 1] = temp;            }        }        return;    }    int middle = (start + end) / 2;    if (length > 7) {        int bottom = start;        int top = end - 1;        if (length > 40) {            length /= 8;            bottom = med3(array, bottom, bottom + length, bottom + (2 * length), comp);            middle = med3(array, middle - length, middle, middle + length, comp);            top = med3(array, top - (2 * length), top - length, top, comp);        }        middle = med3(array, bottom, middle, top, comp);    }    double partionValue = array[middle];    int a = start;    int b = a;    int c = end - 1;    int d = c;    while (true) {        int comparison;        while (b <= c && (comparison = comp.compare(partionValue, array[b])) >= 0) {            if (comparison == 0) {                temp = array[a];                array[a++] = array[b];                array[b] = temp;            }            b++;        }        while (c >= b && (comparison = comp.compare(array[c], partionValue)) >= 0) {            if (comparison == 0) {                temp = array[c];                array[c] = array[d];                array[d--] = temp;            }            c--;        }        if (b > c) {            break;        }        temp = array[b];        array[b++] = array[c];        array[c--] = temp;    }    length = a - start < b - a ? a - start : b - a;    int l = start;    int h = b - length;    while (length-- > 0) {        temp = array[l];        array[l++] = array[h];        array[h++] = temp;    }    length = d - c < end - 1 - d ? d - c : end - 1 - d;    l = b;    h = end - length;    while (length-- > 0) {        temp = array[l];        array[l++] = array[h];        array[h++] = temp;    }    if ((length = b - a) > 0) {        quickSort0(start, start + length, array, comp);    }    if ((length = d - c) > 0) {        quickSort0(end - length, end, array, comp);    }}
49a9c9f56d54b1b734a4e61540fb3900d74f18f573c288b5d38c6f0123a7512b
quickSort
public static void quickSort(float[] array, int start, int end, FloatComparator comp)
{    Preconditions.checkNotNull(array);    checkBounds(array.length, start, end);    quickSort0(start, end, array, comp);}
b4dff57efae91faac4a6e8b38789106373eb7cc1f958f997afbd4965ceaeb56b
quickSort0
private static void quickSort0(int start, int end, float[] array, FloatComparator comp)
{    float temp;    int length = end - start;    if (length < 7) {        for (int i = start + 1; i < end; i++) {            for (int j = i; j > start && comp.compare(array[j], array[j - 1]) < 0; j--) {                temp = array[j];                array[j] = array[j - 1];                array[j - 1] = temp;            }        }        return;    }    int middle = (start + end) / 2;    if (length > 7) {        int bottom = start;        int top = end - 1;        if (length > 40) {            length /= 8;            bottom = med3(array, bottom, bottom + length, bottom + (2 * length), comp);            middle = med3(array, middle - length, middle, middle + length, comp);            top = med3(array, top - (2 * length), top - length, top, comp);        }        middle = med3(array, bottom, middle, top, comp);    }    float partionValue = array[middle];    int a = start;    int b = a;    int c = end - 1;    int d = c;    while (true) {        int comparison;        while (b <= c && (comparison = comp.compare(partionValue, array[b])) >= 0) {            if (comparison == 0) {                temp = array[a];                array[a++] = array[b];                array[b] = temp;            }            b++;        }        while (c >= b && (comparison = comp.compare(array[c], partionValue)) >= 0) {            if (comparison == 0) {                temp = array[c];                array[c] = array[d];                array[d--] = temp;            }            c--;        }        if (b > c) {            break;        }        temp = array[b];        array[b++] = array[c];        array[c--] = temp;    }    length = a - start < b - a ? a - start : b - a;    int l = start;    int h = b - length;    while (length-- > 0) {        temp = array[l];        array[l++] = array[h];        array[h++] = temp;    }    length = d - c < end - 1 - d ? d - c : end - 1 - d;    l = b;    h = end - length;    while (length-- > 0) {        temp = array[l];        array[l++] = array[h];        array[h++] = temp;    }    if ((length = b - a) > 0) {        quickSort0(start, start + length, array, comp);    }    if ((length = d - c) > 0) {        quickSort0(end - length, end, array, comp);    }}
b91af9c781644cf252466370dc52470c2ebd1be677cad737fe380b00af901a3d
quickSort
public static void quickSort(int[] array, int start, int end, IntComparator comp)
{    Preconditions.checkNotNull(array);    checkBounds(array.length, start, end);    quickSort0(start, end, array, comp);}
cb577ab1e5c8da390cce18b004e639b31bd7e10dd9dc20ccfeff26bdd5b1a90d
quickSort0
private static void quickSort0(int start, int end, int[] array, IntComparator comp)
{    int temp;    int length = end - start;    if (length < 7) {        for (int i = start + 1; i < end; i++) {            for (int j = i; j > start && comp.compare(array[j - 1], array[j]) > 0; j--) {                temp = array[j];                array[j] = array[j - 1];                array[j - 1] = temp;            }        }        return;    }    int middle = (start + end) / 2;    if (length > 7) {        int bottom = start;        int top = end - 1;        if (length > 40) {            length /= 8;            bottom = med3(array, bottom, bottom + length, bottom + (2 * length), comp);            middle = med3(array, middle - length, middle, middle + length, comp);            top = med3(array, top - (2 * length), top - length, top, comp);        }        middle = med3(array, bottom, middle, top, comp);    }    int partionValue = array[middle];    int a = start;    int b = a;    int c = end - 1;    int d = c;    while (true) {        int comparison;        while (b <= c && (comparison = comp.compare(array[b], partionValue)) <= 0) {            if (comparison == 0) {                temp = array[a];                array[a++] = array[b];                array[b] = temp;            }            b++;        }        while (c >= b && (comparison = comp.compare(array[c], partionValue)) >= 0) {            if (comparison == 0) {                temp = array[c];                array[c] = array[d];                array[d--] = temp;            }            c--;        }        if (b > c) {            break;        }        temp = array[b];        array[b++] = array[c];        array[c--] = temp;    }    length = a - start < b - a ? a - start : b - a;    int l = start;    int h = b - length;    while (length-- > 0) {        temp = array[l];        array[l++] = array[h];        array[h++] = temp;    }    length = d - c < end - 1 - d ? d - c : end - 1 - d;    l = b;    h = end - length;    while (length-- > 0) {        temp = array[l];        array[l++] = array[h];        array[h++] = temp;    }    if ((length = b - a) > 0) {        quickSort0(start, start + length, array, comp);    }    if ((length = d - c) > 0) {        quickSort0(end - length, end, array, comp);    }}
a57df1587e18738d4f448d984c291761138d58a0eb7a4716eac417ead311fe85
quickSort
public static void quickSort(long[] array, int start, int end, LongComparator comp)
{    Preconditions.checkNotNull(array);    checkBounds(array.length, start, end);    quickSort0(start, end, array, comp);}
8fa38a7105fe95f0bb166828f2d9a1f99e73001a1fd4cc21d9d2caa59d0c620f
quickSort0
private static void quickSort0(int start, int end, long[] array, LongComparator comp)
{    long temp;    int length = end - start;    if (length < 7) {        for (int i = start + 1; i < end; i++) {            for (int j = i; j > start && comp.compare(array[j - 1], array[j]) > 0; j--) {                temp = array[j];                array[j] = array[j - 1];                array[j - 1] = temp;            }        }        return;    }    int middle = (start + end) / 2;    if (length > 7) {        int bottom = start;        int top = end - 1;        if (length > 40) {            length /= 8;            bottom = med3(array, bottom, bottom + length, bottom + (2 * length), comp);            middle = med3(array, middle - length, middle, middle + length, comp);            top = med3(array, top - (2 * length), top - length, top, comp);        }        middle = med3(array, bottom, middle, top, comp);    }    long partionValue = array[middle];    int a = start;    int b = a;    int c = end - 1;    int d = c;    while (true) {        int comparison;        while (b <= c && (comparison = comp.compare(array[b], partionValue)) <= 0) {            if (comparison == 0) {                temp = array[a];                array[a++] = array[b];                array[b] = temp;            }            b++;        }        while (c >= b && (comparison = comp.compare(array[c], partionValue)) >= 0) {            if (comparison == 0) {                temp = array[c];                array[c] = array[d];                array[d--] = temp;            }            c--;        }        if (b > c) {            break;        }        temp = array[b];        array[b++] = array[c];        array[c--] = temp;    }    length = a - start < b - a ? a - start : b - a;    int l = start;    int h = b - length;    while (length-- > 0) {        temp = array[l];        array[l++] = array[h];        array[h++] = temp;    }    length = d - c < end - 1 - d ? d - c : end - 1 - d;    l = b;    h = end - length;    while (length-- > 0) {        temp = array[l];        array[l++] = array[h];        array[h++] = temp;    }    if ((length = b - a) > 0) {        quickSort0(start, start + length, array, comp);    }    if ((length = d - c) > 0) {        quickSort0(end - length, end, array, comp);    }}
68a1da21e226ffdaf6e505480cf769a75e51b37b51ab8ef2962ecacc6dfa2337
quickSort
public static void quickSort(T[] array, int start, int end, Comparator<T> comp)
{    Preconditions.checkNotNull(array);    checkBounds(array.length, start, end);    quickSort0(start, end, array, comp);}
38efdbac3ee0ad95a6874ca5a183498eb7b060d836d36b982c373252d084e602
compare
public int compare(T o1, T o2)
{    return o1.compareTo(o2);}
982d34ba93922c8a23b17275fce45c9f324c7804198f6f683a1622261b5b7383
quickSort
public static void quickSort(T[] array, int start, int end)
{    quickSort(array, start, end, new ComparableAdaptor<T>());}
8b57661446b34cb3b97019c746e9dc0ec51fa5bd70e94d16b8630926042379e8
quickSort0
private static void quickSort0(int start, int end, T[] array, Comparator<T> comp)
{    T temp;    int length = end - start;    if (length < 7) {        for (int i = start + 1; i < end; i++) {            for (int j = i; j > start && comp.compare(array[j - 1], array[j]) > 0; j--) {                temp = array[j];                array[j] = array[j - 1];                array[j - 1] = temp;            }        }        return;    }    int middle = (start + end) / 2;    if (length > 7) {        int bottom = start;        int top = end - 1;        if (length > 40) {            length /= 8;            bottom = med3(array, bottom, bottom + length, bottom + (2 * length), comp);            middle = med3(array, middle - length, middle, middle + length, comp);            top = med3(array, top - (2 * length), top - length, top, comp);        }        middle = med3(array, bottom, middle, top, comp);    }    T partionValue = array[middle];    int a = start;    int b = a;    int c = end - 1;    int d = c;    while (true) {        int comparison;        while (b <= c && (comparison = comp.compare(array[b], partionValue)) <= 0) {            if (comparison == 0) {                temp = array[a];                array[a++] = array[b];                array[b] = temp;            }            b++;        }        while (c >= b && (comparison = comp.compare(array[c], partionValue)) >= 0) {            if (comparison == 0) {                temp = array[c];                array[c] = array[d];                array[d--] = temp;            }            c--;        }        if (b > c) {            break;        }        temp = array[b];        array[b++] = array[c];        array[c--] = temp;    }    length = a - start < b - a ? a - start : b - a;    int l = start;    int h = b - length;    while (length-- > 0) {        temp = array[l];        array[l++] = array[h];        array[h++] = temp;    }    length = d - c < end - 1 - d ? d - c : end - 1 - d;    l = b;    h = end - length;    while (length-- > 0) {        temp = array[l];        array[l++] = array[h];        array[h++] = temp;    }    if ((length = b - a) > 0) {        quickSort0(start, start + length, array, comp);    }    if ((length = d - c) > 0) {        quickSort0(end - length, end, array, comp);    }}
009cf53a63d4f5e46e8e2a51db0fbacfebd8d1637908772e567a723e5d9c5be7
quickSort
public static void quickSort(short[] array, int start, int end, ShortComparator comp)
{    Preconditions.checkNotNull(array);    checkBounds(array.length, start, end);    quickSort0(start, end, array, comp);}
74f1ef00e0aebdcd11f2f60fe79e0b20c6af16bbf778dbb34963b12557c4374a
quickSort0
private static void quickSort0(int start, int end, short[] array, ShortComparator comp)
{    short temp;    int length = end - start;    if (length < 7) {        for (int i = start + 1; i < end; i++) {            for (int j = i; j > start && comp.compare(array[j - 1], array[j]) > 0; j--) {                temp = array[j];                array[j] = array[j - 1];                array[j - 1] = temp;            }        }        return;    }    int middle = (start + end) / 2;    if (length > 7) {        int bottom = start;        int top = end - 1;        if (length > 40) {            length /= 8;            bottom = med3(array, bottom, bottom + length, bottom + (2 * length), comp);            middle = med3(array, middle - length, middle, middle + length, comp);            top = med3(array, top - (2 * length), top - length, top, comp);        }        middle = med3(array, bottom, middle, top, comp);    }    short partionValue = array[middle];    int a = start;    int b = a;    int c = end - 1;    int d = c;    while (true) {        int comparison;        while (b <= c && (comparison = comp.compare(array[b], partionValue)) < 0) {            if (comparison == 0) {                temp = array[a];                array[a++] = array[b];                array[b] = temp;            }            b++;        }        while (c >= b && (comparison = comp.compare(array[c], partionValue)) > 0) {            if (comparison == 0) {                temp = array[c];                array[c] = array[d];                array[d--] = temp;            }            c--;        }        if (b > c) {            break;        }        temp = array[b];        array[b++] = array[c];        array[c--] = temp;    }    length = a - start < b - a ? a - start : b - a;    int l = start;    int h = b - length;    while (length-- > 0) {        temp = array[l];        array[l++] = array[h];        array[h++] = temp;    }    length = d - c < end - 1 - d ? d - c : end - 1 - d;    l = b;    h = end - length;    while (length-- > 0) {        temp = array[l];        array[l++] = array[h];        array[h++] = temp;    }    if ((length = b - a) > 0) {        quickSort0(start, start + length, array, comp);    }    if ((length = d - c) > 0) {        quickSort0(end - length, end, array, comp);    }}
d476a7e017d1050fbe8ec03a09097d6c386c0be9bdbd04f2b076035d336dc6f5
mergeSort
public static void mergeSort(T[] array, int start, int end, Comparator<T> comp)
{    checkBounds(array.length, start, end);    int length = end - start;    if (length <= 0) {        return;    }    T[] out = (T[]) new Object[array.length];    System.arraycopy(array, start, out, start, length);    mergeSort(out, array, start, end, comp);}
4fdb26c09270fe4ac9c33ea015708d7a275a7fe20817b19f17f46d9598cab64b
mergeSort
public static void mergeSort(T[] array, int start, int end)
{    mergeSort(array, start, end, new ComparableAdaptor<T>());}
b01b2a2917a027456f00be292ec9feae535c25b1b84d57863c65a3abefb41e4d
mergeSort
private static void mergeSort(T[] in, T[] out, int start, int end, Comparator<T> c)
{    int len = end - start;        if (len <= SIMPLE_LENGTH) {        for (int i = start + 1; i < end; i++) {            T current = out[i];            T prev = out[i - 1];            if (c.compare(prev, current) > 0) {                int j = i;                do {                    out[j--] = prev;                } while (j > start && (c.compare(prev = out[j - 1], current) > 0));                out[j] = current;            }        }        return;    }    int med = (end + start) >>> 1;    mergeSort(out, in, start, med, c);    mergeSort(out, in, med, end, c);        if (c.compare(in[med - 1], in[med]) <= 0) {        System.arraycopy(in, start, out, start, len);        return;    }    int r = med;    int i = start;        do {        T fromVal = in[start];        T rVal = in[r];        if (c.compare(fromVal, rVal) <= 0) {            int l_1 = find(in, rVal, -1, start + 1, med - 1, c);            int toCopy = l_1 - start + 1;            System.arraycopy(in, start, out, i, toCopy);            i += toCopy;            out[i++] = rVal;            r++;            start = l_1 + 1;        } else {            int r_1 = find(in, fromVal, 0, r + 1, end - 1, c);            int toCopy = r_1 - r + 1;            System.arraycopy(in, r, out, i, toCopy);            i += toCopy;            out[i++] = fromVal;            start++;            r = r_1 + 1;        }    } while ((end - r) > 0 && (med - start) > 0);        if ((end - r) <= 0) {        System.arraycopy(in, start, out, i, med - start);    } else {        System.arraycopy(in, r, out, i, end - r);    }}
7fea820b036e46d690fb20ffe98bcd2413ee0703d984682266539770a146e690
find
private static int find(T[] arr, T val, int bnd, int l, int r, Comparator<T> c)
{    int m = l;    int d = 1;    while (m <= r) {        if (c.compare(val, arr[m]) > bnd) {            l = m + 1;        } else {            r = m - 1;            break;        }        m += d;        d <<= 1;    }    while (l <= r) {        m = (l + r) >>> 1;        if (c.compare(val, arr[m]) > bnd) {            l = m + 1;        } else {            r = m - 1;        }    }    return l - 1;}
f1e8b7666cdebaa5122e4ef287673ad7d7cc3d1415c1fb375b406f1d5599dc9e
compare
public int compare(byte o1, byte o2)
{    return o1 - o2;}
3a7af05f770fb35abadcb2195dccf7ba3c47361182a07716542696a2f9830253
mergeSort
public static void mergeSort(byte[] array, int start, int end)
{    mergeSort(array, start, end, NATURAL_BYTE_COMPARISON);}
c23c5b392a0c7d364b4769daea455cd01a8cd8d10677a97c68963e496af71f0a
mergeSort
public static void mergeSort(byte[] array, int start, int end, ByteComparator comp)
{    checkBounds(array.length, start, end);    byte[] out = Arrays.copyOf(array, array.length);    mergeSort(out, array, start, end, comp);}
3b66c0c2ca09dc3860f82e84043dd163100f243459e0e05a542c3badc44ef234
mergeSort
private static void mergeSort(byte[] in, byte[] out, int start, int end, ByteComparator c)
{    int len = end - start;        if (len <= SIMPLE_LENGTH) {        for (int i = start + 1; i < end; i++) {            byte current = out[i];            byte prev = out[i - 1];            if (c.compare(prev, current) > 0) {                int j = i;                do {                    out[j--] = prev;                } while (j > start && (c.compare(prev = out[j - 1], current) > 0));                out[j] = current;            }        }        return;    }    int med = (end + start) >>> 1;    mergeSort(out, in, start, med, c);    mergeSort(out, in, med, end, c);        if (c.compare(in[med - 1], in[med]) <= 0) {        System.arraycopy(in, start, out, start, len);        return;    }    int r = med;    int i = start;        do {        byte fromVal = in[start];        byte rVal = in[r];        if (c.compare(fromVal, rVal) <= 0) {            int l_1 = find(in, rVal, -1, start + 1, med - 1, c);            int toCopy = l_1 - start + 1;            System.arraycopy(in, start, out, i, toCopy);            i += toCopy;            out[i++] = rVal;            r++;            start = l_1 + 1;        } else {            int r_1 = find(in, fromVal, 0, r + 1, end - 1, c);            int toCopy = r_1 - r + 1;            System.arraycopy(in, r, out, i, toCopy);            i += toCopy;            out[i++] = fromVal;            start++;            r = r_1 + 1;        }    } while ((end - r) > 0 && (med - start) > 0);        if ((end - r) <= 0) {        System.arraycopy(in, start, out, i, med - start);    } else {        System.arraycopy(in, r, out, i, end - r);    }}
9f321b3cf86212fec349ef08a5766341676d7457a203a89f41c5e72e0fc87ca7
find
private static int find(byte[] arr, byte val, int bnd, int l, int r, ByteComparator c)
{    int m = l;    int d = 1;    while (m <= r) {        if (c.compare(val, arr[m]) > bnd) {            l = m + 1;        } else {            r = m - 1;            break;        }        m += d;        d <<= 1;    }    while (l <= r) {        m = (l + r) >>> 1;        if (c.compare(val, arr[m]) > bnd) {            l = m + 1;        } else {            r = m - 1;        }    }    return l - 1;}
d9d05b331083693f74f7fc6bf4c0e0d10a68a4303ab7b5d9b6bdcf1665dcdf27
compare
public int compare(char o1, char o2)
{    return o1 - o2;}
22960d62c9141a716094c4cea0bfc0acfcd3499d24c12333f5fc64a1d030d2c8
mergeSort
public static void mergeSort(char[] array, int start, int end)
{    mergeSort(array, start, end, NATURAL_CHAR_COMPARISON);}
6187236c4def97121361e47621be4b185febed7aa7c4b9d7eba39e65a9a5acab
mergeSort
public static void mergeSort(char[] array, int start, int end, CharComparator comp)
{    checkBounds(array.length, start, end);    char[] out = Arrays.copyOf(array, array.length);    mergeSort(out, array, start, end, comp);}
c76b37bfa4d7c41883bab52558d35aa392049c9f40a294fea8f7c3833e2a0224
mergeSort
private static void mergeSort(char[] in, char[] out, int start, int end, CharComparator c)
{    int len = end - start;        if (len <= SIMPLE_LENGTH) {        for (int i = start + 1; i < end; i++) {            char current = out[i];            char prev = out[i - 1];            if (c.compare(prev, current) > 0) {                int j = i;                do {                    out[j--] = prev;                } while (j > start && (c.compare(prev = out[j - 1], current) > 0));                out[j] = current;            }        }        return;    }    int med = (end + start) >>> 1;    mergeSort(out, in, start, med, c);    mergeSort(out, in, med, end, c);        if (c.compare(in[med - 1], in[med]) <= 0) {        System.arraycopy(in, start, out, start, len);        return;    }    int r = med;    int i = start;        do {        char fromVal = in[start];        char rVal = in[r];        if (c.compare(fromVal, rVal) <= 0) {            int l_1 = find(in, rVal, -1, start + 1, med - 1, c);            int toCopy = l_1 - start + 1;            System.arraycopy(in, start, out, i, toCopy);            i += toCopy;            out[i++] = rVal;            r++;            start = l_1 + 1;        } else {            int r_1 = find(in, fromVal, 0, r + 1, end - 1, c);            int toCopy = r_1 - r + 1;            System.arraycopy(in, r, out, i, toCopy);            i += toCopy;            out[i++] = fromVal;            start++;            r = r_1 + 1;        }    } while ((end - r) > 0 && (med - start) > 0);        if ((end - r) <= 0) {        System.arraycopy(in, start, out, i, med - start);    } else {        System.arraycopy(in, r, out, i, end - r);    }}
20fe6647f2b53599bdbfa04bf5cf7544727db2af204876dda3e824103f8a8510
find
private static int find(char[] arr, char val, int bnd, int l, int r, CharComparator c)
{    int m = l;    int d = 1;    while (m <= r) {        if (c.compare(val, arr[m]) > bnd) {            l = m + 1;        } else {            r = m - 1;            break;        }        m += d;        d <<= 1;    }    while (l <= r) {        m = (l + r) >>> 1;        if (c.compare(val, arr[m]) > bnd) {            l = m + 1;        } else {            r = m - 1;        }    }    return l - 1;}
47981b9a345970ecc2ccebd0121fb2cbd2c0159bf6dfaeabb41790dee80776ab
compare
public int compare(short o1, short o2)
{    return o1 - o2;}
162ff5a833d0ac7562c4f3df60ca9131849a6cffdb5c073c2d8fb7e173c8ac11
mergeSort
public static void mergeSort(short[] array, int start, int end)
{    mergeSort(array, start, end, NATURAL_SHORT_COMPARISON);}
2e6f1ff1284fbd7680a52e3ba43cb57b45af27b0f99e02ff7328e04b9caee727
mergeSort
public static void mergeSort(short[] array, int start, int end, ShortComparator comp)
{    checkBounds(array.length, start, end);    short[] out = Arrays.copyOf(array, array.length);    mergeSort(out, array, start, end, comp);}
9755b50e43eccf86e93af58a8627aa0cada8b752f5790439a43874016b189d05
mergeSort
private static void mergeSort(short[] in, short[] out, int start, int end, ShortComparator c)
{    int len = end - start;        if (len <= SIMPLE_LENGTH) {        for (int i = start + 1; i < end; i++) {            short current = out[i];            short prev = out[i - 1];            if (c.compare(prev, current) > 0) {                int j = i;                do {                    out[j--] = prev;                } while (j > start && (c.compare(prev = out[j - 1], current) > 0));                out[j] = current;            }        }        return;    }    int med = (end + start) >>> 1;    mergeSort(out, in, start, med, c);    mergeSort(out, in, med, end, c);        if (c.compare(in[med - 1], in[med]) <= 0) {        System.arraycopy(in, start, out, start, len);        return;    }    int r = med;    int i = start;        do {        short fromVal = in[start];        short rVal = in[r];        if (c.compare(fromVal, rVal) <= 0) {            int l_1 = find(in, rVal, -1, start + 1, med - 1, c);            int toCopy = l_1 - start + 1;            System.arraycopy(in, start, out, i, toCopy);            i += toCopy;            out[i++] = rVal;            r++;            start = l_1 + 1;        } else {            int r_1 = find(in, fromVal, 0, r + 1, end - 1, c);            int toCopy = r_1 - r + 1;            System.arraycopy(in, r, out, i, toCopy);            i += toCopy;            out[i++] = fromVal;            start++;            r = r_1 + 1;        }    } while ((end - r) > 0 && (med - start) > 0);        if ((end - r) <= 0) {        System.arraycopy(in, start, out, i, med - start);    } else {        System.arraycopy(in, r, out, i, end - r);    }}
30ed9563815dd53c589371f059cab7bc40f915810c15fd038ffcc5d80974f541
find
private static int find(short[] arr, short val, int bnd, int l, int r, ShortComparator c)
{    int m = l;    int d = 1;    while (m <= r) {        if (c.compare(val, arr[m]) > bnd) {            l = m + 1;        } else {            r = m - 1;            break;        }        m += d;        d <<= 1;    }    while (l <= r) {        m = (l + r) >>> 1;        if (c.compare(val, arr[m]) > bnd) {            l = m + 1;        } else {            r = m - 1;        }    }    return l - 1;}
24b699a8b427d7c81f6c5f9014baed2ed295006529a8af0c49a2d39253100745
compare
public int compare(int o1, int o2)
{    return o1 < o2 ? -1 : o1 > o2 ? 1 : 0;}
ba167b3a09f6d40bf7536867700fac904075ef0234626686f75f21b7aef41433
mergeSort
public static void mergeSort(int[] array, int start, int end)
{    mergeSort(array, start, end, NATURAL_INT_COMPARISON);}
0a85e40b2bfd5080e128bbf00c38466ad9339c3d843d9873bd5d0bc4a1119eb0
mergeSort
public static void mergeSort(int[] array, int start, int end, IntComparator comp)
{    checkBounds(array.length, start, end);    int[] out = Arrays.copyOf(array, array.length);    mergeSort(out, array, start, end, comp);}
fa8e5f1ce8c0fce8e770d38ebfa72ed0375ecfd58f7f1c5e5e1648766bade9eb
mergeSort
private static void mergeSort(int[] in, int[] out, int start, int end, IntComparator c)
{    int len = end - start;        if (len <= SIMPLE_LENGTH) {        for (int i = start + 1; i < end; i++) {            int current = out[i];            int prev = out[i - 1];            if (c.compare(prev, current) > 0) {                int j = i;                do {                    out[j--] = prev;                } while (j > start && (c.compare(prev = out[j - 1], current) > 0));                out[j] = current;            }        }        return;    }    int med = (end + start) >>> 1;    mergeSort(out, in, start, med, c);    mergeSort(out, in, med, end, c);        if (c.compare(in[med - 1], in[med]) <= 0) {        System.arraycopy(in, start, out, start, len);        return;    }    int r = med;    int i = start;        do {        int fromVal = in[start];        int rVal = in[r];        if (c.compare(fromVal, rVal) <= 0) {            int l_1 = find(in, rVal, -1, start + 1, med - 1, c);            int toCopy = l_1 - start + 1;            System.arraycopy(in, start, out, i, toCopy);            i += toCopy;            out[i++] = rVal;            r++;            start = l_1 + 1;        } else {            int r_1 = find(in, fromVal, 0, r + 1, end - 1, c);            int toCopy = r_1 - r + 1;            System.arraycopy(in, r, out, i, toCopy);            i += toCopy;            out[i++] = fromVal;            start++;            r = r_1 + 1;        }    } while ((end - r) > 0 && (med - start) > 0);        if ((end - r) <= 0) {        System.arraycopy(in, start, out, i, med - start);    } else {        System.arraycopy(in, r, out, i, end - r);    }}
7ef41e264352d8ff3e1ea83f5907457427cc45e392689800eaf71518793c46ce
find
private static int find(int[] arr, int val, int bnd, int l, int r, IntComparator c)
{    int m = l;    int d = 1;    while (m <= r) {        if (c.compare(val, arr[m]) > bnd) {            l = m + 1;        } else {            r = m - 1;            break;        }        m += d;        d <<= 1;    }    while (l <= r) {        m = (l + r) >>> 1;        if (c.compare(val, arr[m]) > bnd) {            l = m + 1;        } else {            r = m - 1;        }    }    return l - 1;}
65906200621ed4a3e8f732e1950402f0e81e954cad04e3fcd27b33d53d7d988e
compare
public int compare(long o1, long o2)
{    return o1 < o2 ? -1 : o1 > o2 ? 1 : 0;}
dfd477fc5e76b6995106b3d28380082c5d9fd7fbc79d3ba219dd1b1630e40a92
mergeSort
public static void mergeSort(long[] array, int start, int end)
{    mergeSort(array, start, end, NATURAL_LONG_COMPARISON);}
9554d3d89d813895c5765f86cbf2079c67413f4d732b96aa6a24b59c49581458
mergeSort
public static void mergeSort(long[] array, int start, int end, LongComparator comp)
{    checkBounds(array.length, start, end);    long[] out = Arrays.copyOf(array, array.length);    mergeSort(out, array, start, end, comp);}
93b1cce0e05030d389c80b2b386c4a012a4fe4d01e4f960c13220d74d28687ce
mergeSort
private static void mergeSort(long[] in, long[] out, int start, int end, LongComparator c)
{    int len = end - start;        if (len <= SIMPLE_LENGTH) {        for (int i = start + 1; i < end; i++) {            long current = out[i];            long prev = out[i - 1];            if (c.compare(prev, current) > 0) {                int j = i;                do {                    out[j--] = prev;                } while (j > start && (c.compare(prev = out[j - 1], current) > 0));                out[j] = current;            }        }        return;    }    int med = (end + start) >>> 1;    mergeSort(out, in, start, med, c);    mergeSort(out, in, med, end, c);        if (c.compare(in[med - 1], in[med]) <= 0) {        System.arraycopy(in, start, out, start, len);        return;    }    int r = med;    int i = start;        do {        long fromVal = in[start];        long rVal = in[r];        if (c.compare(fromVal, rVal) <= 0) {            int l_1 = find(in, rVal, -1, start + 1, med - 1, c);            int toCopy = l_1 - start + 1;            System.arraycopy(in, start, out, i, toCopy);            i += toCopy;            out[i++] = rVal;            r++;            start = l_1 + 1;        } else {            int r_1 = find(in, fromVal, 0, r + 1, end - 1, c);            int toCopy = r_1 - r + 1;            System.arraycopy(in, r, out, i, toCopy);            i += toCopy;            out[i++] = fromVal;            start++;            r = r_1 + 1;        }    } while ((end - r) > 0 && (med - start) > 0);        if ((end - r) <= 0) {        System.arraycopy(in, start, out, i, med - start);    } else {        System.arraycopy(in, r, out, i, end - r);    }}
ffbab0cfd6edcb593f7a1acfc2a5c46358dce6fe4d07daf693b303dd937435e3
find
private static int find(long[] arr, long val, int bnd, int l, int r, LongComparator c)
{    int m = l;    int d = 1;    while (m <= r) {        if (c.compare(val, arr[m]) > bnd) {            l = m + 1;        } else {            r = m - 1;            break;        }        m += d;        d <<= 1;    }    while (l <= r) {        m = (l + r) >>> 1;        if (c.compare(val, arr[m]) > bnd) {            l = m + 1;        } else {            r = m - 1;        }    }    return l - 1;}
605e931f3709413679f5e80fef272846e1bdbee57044f7fa5de659c6c7ab1b02
compare
public int compare(float o1, float o2)
{    return Float.compare(o1, o2);}
63c57e6d9ae386dd5d9091d01e8e00b7996d6b8537e5d96881a1852294440038
mergeSort
public static void mergeSort(float[] array, int start, int end)
{    mergeSort(array, start, end, NATURAL_FLOAT_COMPARISON);}
4ffea491febc0daf09b10006c3e6db41c95575b470a0aee6da0a658b8ab53b66
mergeSort
public static void mergeSort(float[] array, int start, int end, FloatComparator comp)
{    checkBounds(array.length, start, end);    float[] out = Arrays.copyOf(array, array.length);    mergeSort(out, array, start, end, comp);}
e2155653fdcbdbc4f8a36d6963b32a404867d8ae332b102145b0be90f5734dde
mergeSort
private static void mergeSort(float[] in, float[] out, int start, int end, FloatComparator c)
{    int len = end - start;        if (len <= SIMPLE_LENGTH) {        for (int i = start + 1; i < end; i++) {            float current = out[i];            float prev = out[i - 1];            if (c.compare(prev, current) > 0) {                int j = i;                do {                    out[j--] = prev;                } while (j > start && (c.compare(prev = out[j - 1], current) > 0));                out[j] = current;            }        }        return;    }    int med = (end + start) >>> 1;    mergeSort(out, in, start, med, c);    mergeSort(out, in, med, end, c);        if (c.compare(in[med - 1], in[med]) <= 0) {        System.arraycopy(in, start, out, start, len);        return;    }    int r = med;    int i = start;        do {        float fromVal = in[start];        float rVal = in[r];        if (c.compare(fromVal, rVal) <= 0) {            int l_1 = find(in, rVal, -1, start + 1, med - 1, c);            int toCopy = l_1 - start + 1;            System.arraycopy(in, start, out, i, toCopy);            i += toCopy;            out[i++] = rVal;            r++;            start = l_1 + 1;        } else {            int r_1 = find(in, fromVal, 0, r + 1, end - 1, c);            int toCopy = r_1 - r + 1;            System.arraycopy(in, r, out, i, toCopy);            i += toCopy;            out[i++] = fromVal;            start++;            r = r_1 + 1;        }    } while ((end - r) > 0 && (med - start) > 0);        if ((end - r) <= 0) {        System.arraycopy(in, start, out, i, med - start);    } else {        System.arraycopy(in, r, out, i, end - r);    }}
13acff2ac27b77b4318e5abe6d1cd9fadf10d0dc80e8087e78a278d164034453
find
private static int find(float[] arr, float val, int bnd, int l, int r, FloatComparator c)
{    int m = l;    int d = 1;    while (m <= r) {        if (c.compare(val, arr[m]) > bnd) {            l = m + 1;        } else {            r = m - 1;            break;        }        m += d;        d <<= 1;    }    while (l <= r) {        m = (l + r) >>> 1;        if (c.compare(val, arr[m]) > bnd) {            l = m + 1;        } else {            r = m - 1;        }    }    return l - 1;}
a6947bf7baa8706647d0f806b687f8c6c68a80fb0b25357e9c9d9572a6b6f6fc
compare
public int compare(double o1, double o2)
{    return Double.compare(o1, o2);}
fb254498ce674b1b8083f3cc766fde1a4ecf06331a52931b7308338e7872329e
mergeSort
public static void mergeSort(double[] array, int start, int end)
{    mergeSort(array, start, end, NATURAL_DOUBLE_COMPARISON);}
e40401babcdccf97ec1ff92c48e0cf5c6fe9b58dd25678084c765a1288421a47
mergeSort
public static void mergeSort(double[] array, int start, int end, DoubleComparator comp)
{    checkBounds(array.length, start, end);    double[] out = Arrays.copyOf(array, array.length);    mergeSort(out, array, start, end, comp);}
84468c8feeef5ee7afd499906440181467dddb2b785a316c5e3c21e64541bcdf
mergeSort
private static void mergeSort(double[] in, double[] out, int start, int end, DoubleComparator c)
{    int len = end - start;        if (len <= SIMPLE_LENGTH) {        for (int i = start + 1; i < end; i++) {            double current = out[i];            double prev = out[i - 1];            if (c.compare(prev, current) > 0) {                int j = i;                do {                    out[j--] = prev;                } while (j > start && (c.compare(prev = out[j - 1], current) > 0));                out[j] = current;            }        }        return;    }    int med = (end + start) >>> 1;    mergeSort(out, in, start, med, c);    mergeSort(out, in, med, end, c);        if (c.compare(in[med - 1], in[med]) <= 0) {        System.arraycopy(in, start, out, start, len);        return;    }    int r = med;    int i = start;        do {        double fromVal = in[start];        double rVal = in[r];        if (c.compare(fromVal, rVal) <= 0) {            int l_1 = find(in, rVal, -1, start + 1, med - 1, c);            int toCopy = l_1 - start + 1;            System.arraycopy(in, start, out, i, toCopy);            i += toCopy;            out[i++] = rVal;            r++;            start = l_1 + 1;        } else {            int r_1 = find(in, fromVal, 0, r + 1, end - 1, c);            int toCopy = r_1 - r + 1;            System.arraycopy(in, r, out, i, toCopy);            i += toCopy;            out[i++] = fromVal;            start++;            r = r_1 + 1;        }    } while ((end - r) > 0 && (med - start) > 0);        if ((end - r) <= 0) {        System.arraycopy(in, start, out, i, med - start);    } else {        System.arraycopy(in, r, out, i, end - r);    }}
276bf5294ce76c6abdb10cd74cdf706392cb8201906819108dd39924b5097168
find
private static int find(double[] arr, double val, int bnd, int l, int r, DoubleComparator c)
{    int m = l;    int d = 1;    while (m <= r) {        if (c.compare(val, arr[m]) > bnd) {            l = m + 1;        } else {            r = m - 1;            break;        }        m += d;        d <<= 1;    }    while (l <= r) {        m = (l + r) >>> 1;        if (c.compare(val, arr[m]) > bnd) {            l = m + 1;        } else {            r = m - 1;        }    }    return l - 1;}
c4d0c25275a6ed797f03f76a84cf869d4cc709d884d545554eec79f8a8d478b1
inplaceMerge
 static void inplaceMerge(int first, int middle, int last, IntComparator comp, Swapper swapper)
{    if (first >= middle || middle >= last) {        return;    }    if (last - first == 2) {        if (comp.compare(middle, first) < 0) {            swapper.swap(first, middle);        }        return;    }    int firstCut;    int secondCut;    if (middle - first > last - middle) {        firstCut = first + (middle - first) / 2;        secondCut = lowerBound(middle, last, firstCut, comp);    } else {        secondCut = middle + (last - middle) / 2;        firstCut = upperBound(first, middle, secondCut, comp);    }                        int first2 = firstCut;    int middle2 = middle;    int last2 = secondCut;    if (middle2 != first2 && middle2 != last2) {        int first1 = first2;        int last1 = middle2;        while (first1 < --last1) {            swapper.swap(first1++, last1);        }        first1 = middle2;        last1 = last2;        while (first1 < --last1) {            swapper.swap(first1++, last1);        }        first1 = first2;        last1 = last2;        while (first1 < --last1) {            swapper.swap(first1++, last1);        }    }        middle = firstCut + (secondCut - middle);    inplaceMerge(first, firstCut, middle, comp, swapper);    inplaceMerge(middle, secondCut, last, comp, swapper);}
7608e8c68ba25a4460f7744c6caae07f23e861d540c1c2d1f2de2b1b1bea5dbc
lowerBound
 static int lowerBound(int first, int last, int x, IntComparator comp)
{    int len = last - first;    while (len > 0) {        int half = len / 2;        int middle = first + half;        if (comp.compare(middle, x) < 0) {            first = middle + 1;            len -= half + 1;        } else {            len = half;        }    }    return first;}
59a962d40d33d8febe70c3452bd628da7aab60b499dbdb1c104422a399fae98a
mergeSort
public static void mergeSort(int fromIndex, int toIndex, IntComparator c, Swapper swapper)
{    /*      We retain the same method signature as quickSort.      Given only a comparator and swapper we do not know how to copy and move elements from/to temporary arrays.      Hence, in contrast to the JDK mergesorts this is an "in-place" mergesort, i.e. does not allocate any temporary      arrays.      A non-inplace mergesort would perhaps be faster in most cases, but would require non-intuitive delegate objects...    */    int length = toIndex - fromIndex;        if (length < SMALL) {        for (int i = fromIndex; i < toIndex; i++) {            for (int j = i; j > fromIndex && (c.compare(j - 1, j) > 0); j--) {                swapper.swap(j, j - 1);            }        }        return;    }        int mid = (fromIndex + toIndex) / 2;    mergeSort(fromIndex, mid, c, swapper);    mergeSort(mid, toIndex, c, swapper);        if (c.compare(mid - 1, mid) <= 0) {        return;    }        inplaceMerge(fromIndex, mid, toIndex, c, swapper);}
92f75279675cb6d39769d4c07a55aa3273bc33513af87686fa798eafe70d69b2
upperBound
 static int upperBound(int first, int last, int x, IntComparator comp)
{    int len = last - first;    while (len > 0) {        int half = len / 2;        int middle = first + half;        if (comp.compare(x, middle) < 0) {            len = half;        } else {            first = middle + 1;            len -= half + 1;        }    }    return first;}
718d9e27b4314887356041933895f3ca7614086ebd95c67fc99404a51fab676b
clone
public Matrix clone()
{    SparseColumnMatrix clone = (SparseColumnMatrix) super.clone();    clone.columnVectors = new Vector[columnVectors.length];    for (int i = 0; i < columnVectors.length; i++) {        clone.columnVectors[i] = columnVectors[i].clone();    }    return clone;}
4f84a93591875e1cca8d9e5ad9481c6ce323c0c90a5b0b7da8751eb116523a29
numSlices
public int numSlices()
{    return numCols();}
1a7b4a2d3001072b037d625fbd603f24082fad4d995e7354ef48188cd1906c22
getQuick
public double getQuick(int row, int column)
{    return columnVectors[column] == null ? 0.0 : columnVectors[column].getQuick(row);}
8ea1ca8bbfed9d923bb33b6722a3491db09837bb6812b8b8778bf2422064e0ab
like
public Matrix like()
{    return new SparseColumnMatrix(rowSize(), columnSize());}
f88fece6b0c6401785f452c13d8cce7ea1dc13011ee8686b08685d42b6f32638
like
public Matrix like(int rows, int columns)
{    return new SparseColumnMatrix(rows, columns);}
c733fce42980b3396a3426c0cfb05355954939da4f722c3d81ab2555e6bd9282
setQuick
public void setQuick(int row, int column, double value)
{    if (columnVectors[column] == null) {        columnVectors[column] = new RandomAccessSparseVector(rowSize());    }    columnVectors[column].setQuick(row, value);}
7714b327d86a7bf6870ba63ac39d817cef2071cb1e37ee1443f8106d3de5443a
getNumNondefaultElements
public int[] getNumNondefaultElements()
{    int[] result = new int[2];    result[COL] = columnVectors.length;    for (int col = 0; col < columnSize(); col++) {        result[ROW] = Math.max(result[ROW], columnVectors[col].getNumNondefaultElements());    }    return result;}
242adb7156cbde039fd67ab8f5ed8c9c46c199c38c6f12d05d2dbaffd8178820
viewPart
public Matrix viewPart(int[] offset, int[] size)
{    if (offset[ROW] < 0) {        throw new IndexException(offset[ROW], columnVectors[COL].size());    }    if (offset[ROW] + size[ROW] > columnVectors[COL].size()) {        throw new IndexException(offset[ROW] + size[ROW], columnVectors[COL].size());    }    if (offset[COL] < 0) {        throw new IndexException(offset[COL], columnVectors.length);    }    if (offset[COL] + size[COL] > columnVectors.length) {        throw new IndexException(offset[COL] + size[COL], columnVectors.length);    }    return new MatrixView(this, offset, size);}
2d445c7af662ad5641bd7c216b4e7684a9cdab361f239540c55a18b81c86443c
assignColumn
public Matrix assignColumn(int column, Vector other)
{    if (rowSize() != other.size()) {        throw new CardinalityException(rowSize(), other.size());    }    if (column < 0 || column >= columnSize()) {        throw new IndexException(column, columnSize());    }    columnVectors[column].assign(other);    return this;}
95687ef4453f7375a5854c6fa51b38f6963e77319dd3f4176496189e5fd67c55
assignRow
public Matrix assignRow(int row, Vector other)
{    if (columnSize() != other.size()) {        throw new CardinalityException(columnSize(), other.size());    }    if (row < 0 || row >= rowSize()) {        throw new IndexException(row, rowSize());    }    for (int col = 0; col < columnSize(); col++) {        columnVectors[col].setQuick(row, other.getQuick(col));    }    return this;}
d46193949587a2e9ca1ec7df8ed6534443c7731e6ae91f71f45b19ee95634c85
viewColumn
public Vector viewColumn(int column)
{    if (column < 0 || column >= columnSize()) {        throw new IndexException(column, columnSize());    }    return columnVectors[column];}
f6617c43b6dd5f91010c233e3bcf9c6f78a0ecee830fcb10168e8aa0024d26a0
transpose
public Matrix transpose()
{    SparseRowMatrix srm = new SparseRowMatrix(columns, rows);    for (int i = 0; i < columns; i++) {        Vector col = columnVectors[i];        if (col.getNumNonZeroElements() > 0)                        srm.assignRow(i, col);    }    return srm;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    int row = 0;    int maxRowsToDisplay = 10;    int maxColsToDisplay = 20;    int colsToDisplay = maxColsToDisplay;    if (maxColsToDisplay > columnSize()) {        colsToDisplay = columnSize();    }    StringBuilder s = new StringBuilder("{\n");    for (MatrixSlice next : this.transpose()) {        if (row < maxRowsToDisplay) {            s.append(" ").append(next.index()).append(" =>\t").append(new VectorView(next.vector(), 0, colsToDisplay)).append('\n');            row++;        }    }    String returnString = s.toString();    if (maxColsToDisplay <= columnSize()) {        returnString = returnString.replace("}", " ... }");    }    if (maxRowsToDisplay <= rowSize()) {        return returnString + "... }";    } else {        return returnString + "}";    }}
718d9e27b4314887356041933895f3ca7614086ebd95c67fc99404a51fab676b
clone
public Matrix clone()
{    SparseMatrix clone = new SparseMatrix(numRows(), numCols());    for (MatrixSlice slice : this) {        clone.rowVectors.put(slice.index(), slice.clone());    }    return clone;}
4f84a93591875e1cca8d9e5ad9481c6ce323c0c90a5b0b7da8751eb116523a29
numSlices
public int numSlices()
{    return rowVectors.size();}
99eb89100e81a1c9b6d2c2b9bacb794d4a9322c5692bbc72b555785bebf7a3d9
iterateNonEmpty
public Iterator<MatrixSlice> iterateNonEmpty()
{    final int[] keys = rowVectors.keySet().toIntArray();    return new AbstractIterator<MatrixSlice>() {        private int slice;        @Override        protected MatrixSlice computeNext() {            if (slice >= rowVectors.size()) {                return endOfData();            }            int i = keys[slice];            Vector row = rowVectors.get(i);            slice++;            return new MatrixSlice(row, i);        }    };}
32f3173c937cfeaeed46d4345ac3b0b7af97c241c6c97b7de883cc81138d5b15
computeNext
protected MatrixSlice computeNext()
{    if (slice >= rowVectors.size()) {        return endOfData();    }    int i = keys[slice];    Vector row = rowVectors.get(i);    slice++;    return new MatrixSlice(row, i);}
1a7b4a2d3001072b037d625fbd603f24082fad4d995e7354ef48188cd1906c22
getQuick
public double getQuick(int row, int column)
{    Vector r = rowVectors.get(row);    return r == null ? 0.0 : r.getQuick(column);}
8ea1ca8bbfed9d923bb33b6722a3491db09837bb6812b8b8778bf2422064e0ab
like
public Matrix like()
{    return new SparseMatrix(rowSize(), columnSize());}
f88fece6b0c6401785f452c13d8cce7ea1dc13011ee8686b08685d42b6f32638
like
public Matrix like(int rows, int columns)
{    return new SparseMatrix(rows, columns);}
c733fce42980b3396a3426c0cfb05355954939da4f722c3d81ab2555e6bd9282
setQuick
public void setQuick(int row, int column, double value)
{    Vector r = rowVectors.get(row);    if (r == null) {        r = new RandomAccessSparseVector(columnSize());        rowVectors.put(row, r);    }    r.setQuick(column, value);}
7714b327d86a7bf6870ba63ac39d817cef2071cb1e37ee1443f8106d3de5443a
getNumNondefaultElements
public int[] getNumNondefaultElements()
{    int[] result = new int[2];    result[ROW] = rowVectors.size();    for (Vector row : rowVectors.values()) {        result[COL] = Math.max(result[COL], row.getNumNondefaultElements());    }    return result;}
242adb7156cbde039fd67ab8f5ed8c9c46c199c38c6f12d05d2dbaffd8178820
viewPart
public Matrix viewPart(int[] offset, int[] size)
{    if (offset[ROW] < 0) {        throw new IndexException(offset[ROW], rowSize());    }    if (offset[ROW] + size[ROW] > rowSize()) {        throw new IndexException(offset[ROW] + size[ROW], rowSize());    }    if (offset[COL] < 0) {        throw new IndexException(offset[COL], columnSize());    }    if (offset[COL] + size[COL] > columnSize()) {        throw new IndexException(offset[COL] + size[COL], columnSize());    }    return new MatrixView(this, offset, size);}
bfca2cdd6e9adeabfb9ecc4ba7a9c7519e3c8ebe89127c7c86e17f01e99498c9
assign
public Matrix assign(Matrix other, DoubleDoubleFunction function)
{        if (Functions.PLUS.equals(function) && other instanceof SparseMatrix) {        int rows = rowSize();        if (rows != other.rowSize()) {            throw new CardinalityException(rows, other.rowSize());        }        int columns = columnSize();        if (columns != other.columnSize()) {            throw new CardinalityException(columns, other.columnSize());        }        SparseMatrix otherSparse = (SparseMatrix) other;        for (ObjectIterator<Entry<Vector>> fastIterator = otherSparse.rowVectors.int2ObjectEntrySet().fastIterator(); fastIterator.hasNext(); ) {            final Entry<Vector> entry = fastIterator.next();            final int rowIndex = entry.getIntKey();            Vector row = rowVectors.get(rowIndex);            if (row == null) {                rowVectors.put(rowIndex, entry.getValue().clone());            } else {                row.assign(entry.getValue(), Functions.PLUS);            }        }        return this;    } else {        return super.assign(other, function);    }}
2d445c7af662ad5641bd7c216b4e7684a9cdab361f239540c55a18b81c86443c
assignColumn
public Matrix assignColumn(int column, Vector other)
{    if (rowSize() != other.size()) {        throw new CardinalityException(rowSize(), other.size());    }    if (column < 0 || column >= columnSize()) {        throw new IndexException(column, columnSize());    }    for (int row = 0; row < rowSize(); row++) {        double val = other.getQuick(row);        if (val != 0.0) {            Vector r = rowVectors.get(row);            if (r == null) {                r = new RandomAccessSparseVector(columnSize());                rowVectors.put(row, r);            }            r.setQuick(column, val);        }    }    return this;}
95687ef4453f7375a5854c6fa51b38f6963e77319dd3f4176496189e5fd67c55
assignRow
public Matrix assignRow(int row, Vector other)
{    if (columnSize() != other.size()) {        throw new CardinalityException(columnSize(), other.size());    }    if (row < 0 || row >= rowSize()) {        throw new IndexException(row, rowSize());    }    rowVectors.put(row, other);    return this;}
cc845ba0d004ee14775588b6cb695a9053ef1f384e5196e605687c0f7eeac020
viewRow
public Vector viewRow(int row)
{    if (row < 0 || row >= rowSize()) {        throw new IndexException(row, rowSize());    }    Vector res = rowVectors.get(row);    if (res == null) {        res = new RandomAccessSparseVector(columnSize());        rowVectors.put(row, res);    }    return res;}
6ee7ce6a8f79613615717eb6d9ca5cdf9a5cc8ab5a593babb0e9aa9d9c791264
nonZeroRowIndices
public IntArrayList nonZeroRowIndices()
{    return new IntArrayList(rowVectors.keySet().toIntArray());}
4f943db0f33d27c9f70c541ef27a217346904d47c0870b555f1140eebdc0f9b2
getFlavor
public MatrixFlavor getFlavor()
{    return MatrixFlavor.SPARSEROWLIKE;}
718d9e27b4314887356041933895f3ca7614086ebd95c67fc99404a51fab676b
clone
public Matrix clone()
{    SparseRowMatrix clone = (SparseRowMatrix) super.clone();    clone.rowVectors = new Vector[rowVectors.length];    for (int i = 0; i < rowVectors.length; i++) {        clone.rowVectors[i] = rowVectors[i].clone();    }    return clone;}
1a7b4a2d3001072b037d625fbd603f24082fad4d995e7354ef48188cd1906c22
getQuick
public double getQuick(int row, int column)
{    return rowVectors[row] == null ? 0.0 : rowVectors[row].getQuick(column);}
8ea1ca8bbfed9d923bb33b6722a3491db09837bb6812b8b8778bf2422064e0ab
like
public Matrix like()
{    return new SparseRowMatrix(rowSize(), columnSize(), randomAccessRows);}
f88fece6b0c6401785f452c13d8cce7ea1dc13011ee8686b08685d42b6f32638
like
public Matrix like(int rows, int columns)
{    return new SparseRowMatrix(rows, columns, randomAccessRows);}
c733fce42980b3396a3426c0cfb05355954939da4f722c3d81ab2555e6bd9282
setQuick
public void setQuick(int row, int column, double value)
{    rowVectors[row].setQuick(column, value);}
7714b327d86a7bf6870ba63ac39d817cef2071cb1e37ee1443f8106d3de5443a
getNumNondefaultElements
public int[] getNumNondefaultElements()
{    int[] result = new int[2];    result[ROW] = rowVectors.length;    for (int row = 0; row < rowSize(); row++) {        result[COL] = Math.max(result[COL], rowVectors[row].getNumNondefaultElements());    }    return result;}
242adb7156cbde039fd67ab8f5ed8c9c46c199c38c6f12d05d2dbaffd8178820
viewPart
public Matrix viewPart(int[] offset, int[] size)
{    if (offset[ROW] < 0) {        throw new IndexException(offset[ROW], rowVectors.length);    }    if (offset[ROW] + size[ROW] > rowVectors.length) {        throw new IndexException(offset[ROW] + size[ROW], rowVectors.length);    }    if (offset[COL] < 0) {        throw new IndexException(offset[COL], rowVectors[ROW].size());    }    if (offset[COL] + size[COL] > rowVectors[ROW].size()) {        throw new IndexException(offset[COL] + size[COL], rowVectors[ROW].size());    }    return new MatrixView(this, offset, size);}
bfca2cdd6e9adeabfb9ecc4ba7a9c7519e3c8ebe89127c7c86e17f01e99498c9
assign
public Matrix assign(Matrix other, DoubleDoubleFunction function)
{    int rows = rowSize();    if (rows != other.rowSize()) {        throw new CardinalityException(rows, other.rowSize());    }    int columns = columnSize();    if (columns != other.columnSize()) {        throw new CardinalityException(columns, other.columnSize());    }    for (int row = 0; row < rows; row++) {        try {            Iterator<Vector.Element> sparseRowIterator = ((SequentialAccessSparseVector) this.rowVectors[row]).iterateNonZero();            if (function.isLikeMult()) {                                while (sparseRowIterator.hasNext()) {                    Vector.Element element = sparseRowIterator.next();                    int col = element.index();                    setQuick(row, col, function.apply(element.get(), other.getQuick(row, col)));                }            } else {                for (int col = 0; col < columns; col++) {                    setQuick(row, col, function.apply(getQuick(row, col), other.getQuick(row, col)));                }            }        } catch (ClassCastException e) {                        log.warn("Error casting the row to SequentialAccessSparseVector, this should never happen because" + "SparseRomMatrix is always made of SequentialAccessSparseVectors. Proceeding with non-optimzed" + "implementation.");            for (int col = 0; col < columns; col++) {                setQuick(row, col, function.apply(getQuick(row, col), other.getQuick(row, col)));            }        }    }    return this;}
2d445c7af662ad5641bd7c216b4e7684a9cdab361f239540c55a18b81c86443c
assignColumn
public Matrix assignColumn(int column, Vector other)
{    if (rowSize() != other.size()) {        throw new CardinalityException(rowSize(), other.size());    }    if (column < 0 || column >= columnSize()) {        throw new IndexException(column, columnSize());    }    for (int row = 0; row < rowSize(); row++) {        rowVectors[row].setQuick(column, other.getQuick(row));    }    return this;}
95687ef4453f7375a5854c6fa51b38f6963e77319dd3f4176496189e5fd67c55
assignRow
public Matrix assignRow(int row, Vector other)
{    if (columnSize() != other.size()) {        throw new CardinalityException(columnSize(), other.size());    }    if (row < 0 || row >= rowSize()) {        throw new IndexException(row, rowSize());    }    rowVectors[row].assign(other);    return this;}
cc845ba0d004ee14775588b6cb695a9053ef1f384e5196e605687c0f7eeac020
viewRow
public Vector viewRow(int row)
{    if (row < 0 || row >= rowSize()) {        throw new IndexException(row, rowSize());    }    return rowVectors[row];}
f6617c43b6dd5f91010c233e3bcf9c6f78a0ecee830fcb10168e8aa0024d26a0
transpose
public Matrix transpose()
{    SparseColumnMatrix scm = new SparseColumnMatrix(columns, rows);    for (int i = 0; i < rows; i++) {        Vector row = rowVectors[i];        if (row.getNumNonZeroElements() > 0) {            scm.assignColumn(i, row);        }    }    return scm;}
07edaa38b63aaa02b484989af04fac05f162d5fe81194b8fb6dd87f9fade2833
times
public Matrix times(Matrix other)
{    if (columnSize() != other.rowSize()) {        throw new CardinalityException(columnSize(), other.rowSize());    }    if (other instanceof SparseRowMatrix) {        SparseRowMatrix y = (SparseRowMatrix) other;        SparseRowMatrix result = (SparseRowMatrix) like(rowSize(), other.columnSize());        for (int i = 0; i < rows; i++) {            Vector row = rowVectors[i];            for (Vector.Element element : row.nonZeroes()) {                result.rowVectors[i].assign(y.rowVectors[element.index()], Functions.plusMult(element.get()));            }        }        return result;    } else {        if (other.viewRow(0).isDense()) {                        Matrix result = other.like(rowSize(), other.columnSize());            for (int i = 0; i < rows; i++) {                Vector row = rowVectors[i];                Vector r = new DenseVector(other.columnSize());                for (Vector.Element element : row.nonZeroes()) {                    r.assign(other.viewRow(element.index()), Functions.plusMult(element.get()));                }                result.viewRow(i).assign(r);            }            return result;        } else {                        SparseRowMatrix result = (SparseRowMatrix) like(rowSize(), other.columnSize());            for (int i = 0; i < rows; i++) {                Vector row = rowVectors[i];                for (Vector.Element element : row.nonZeroes()) {                    result.rowVectors[i].assign(other.viewRow(element.index()), Functions.plusMult(element.get()));                }            }            return result;        }    }}
4f943db0f33d27c9f70c541ef27a217346904d47c0870b555f1140eebdc0f9b2
getFlavor
public MatrixFlavor getFlavor()
{    return MatrixFlavor.SPARSELIKE;}
3131913d2613e4b13ec2750f2ace0db2870eb5320aab4251e97d8cc235a85cc8
getSingularValues
public Vector getSingularValues()
{    return new DenseVector(svd.getSingularValues());}
b93c02d3200f74c6697e4881155aab7d7cc4f51c675f9516cb10337d05447b38
getU
public Matrix getU()
{        return cd1.solveRight(y).times(svd.getU());}
26cefa3b556cdac980c8fcb58bbf384dae8a5355cbaff131190aec58de3365e0
getV
public Matrix getV()
{        return cd2.solveRight(b.transpose()).times(svd.getV());}
ac6d83cce50f0a1834ebc0a886175a0a0f09cfaab90988f96ea2a9d1171bf7d4
entropy
public static double entropy(long... elements)
{    long sum = 0;    double result = 0.0;    for (long element : elements) {        Preconditions.checkArgument(element >= 0);        result += xLogX(element);        sum += element;    }    return xLogX(sum) - result;}
4d8fc251401f592829f5478563fb8ff1075125d0f6afae84768fc5357802aa8c
xLogX
private static double xLogX(long x)
{    return x == 0 ? 0.0 : x * Math.log(x);}
b1deffd14e62f0f7c50ac4f220642e8a21f66017c417cd0f6becc6c410b0c4fe
entropy
private static double entropy(long a, long b)
{    return xLogX(a + b) - xLogX(a) - xLogX(b);}
25e580fafcb05ae7a74c680e496063c788e7c5c7a0243ee2c7c5f4695ac5ce82
entropy
private static double entropy(long a, long b, long c, long d)
{    return xLogX(a + b + c + d) - xLogX(a) - xLogX(b) - xLogX(c) - xLogX(d);}
15ca4d405fd1eb7334a22cd19e73135f2c9b8d73bf128a228d02f5543a28c050
logLikelihoodRatio
public static double logLikelihoodRatio(long k11, long k12, long k21, long k22)
{    Preconditions.checkArgument(k11 >= 0 && k12 >= 0 && k21 >= 0 && k22 >= 0);        double rowEntropy = entropy(k11 + k12, k21 + k22);    double columnEntropy = entropy(k11 + k21, k12 + k22);    double matrixEntropy = entropy(k11, k12, k21, k22);    if (rowEntropy + columnEntropy < matrixEntropy) {                return 0.0;    }    return 2.0 * (rowEntropy + columnEntropy - matrixEntropy);}
745deccd79998f31bfb985ee5bb7c5ae733f7928a1f7299328f46dc4a88ae907
rootLogLikelihoodRatio
public static double rootLogLikelihoodRatio(long k11, long k12, long k21, long k22)
{    double llr = logLikelihoodRatio(k11, k12, k21, k22);    double sqrt = Math.sqrt(llr);    if ((double) k11 / (k11 + k12) < (double) k21 / (k21 + k22)) {        sqrt = -sqrt;    }    return sqrt;}
c9e4db0924d1243c239b19fff6e23ed2f8955a0e5cc6b99e9f25a213d5691007
compareFrequencies
public static List<ScoredItem<T>> compareFrequencies(Multiset<T> a, Multiset<T> b, int maxReturn, double threshold)
{    int totalA = a.size();    int totalB = b.size();    Ordering<ScoredItem<T>> byScoreAscending = new Ordering<ScoredItem<T>>() {        @Override        public int compare(ScoredItem<T> tScoredItem, ScoredItem<T> tScoredItem1) {            return Double.compare(tScoredItem.score, tScoredItem1.score);        }    };    Queue<ScoredItem<T>> best = new PriorityQueue<>(maxReturn + 1, byScoreAscending);    for (T t : a.elementSet()) {        compareAndAdd(a, b, maxReturn, threshold, totalA, totalB, best, t);    }        if (threshold < 0) {        for (T t : b.elementSet()) {                        if (a.count(t) == 0) {                compareAndAdd(a, b, maxReturn, threshold, totalA, totalB, best, t);            }        }    }    List<ScoredItem<T>> r = new ArrayList<>(best);    Collections.sort(r, byScoreAscending.reverse());    return r;}
995307a7b847c45f420d582e51666b5ca5027248f851847cf03e9648dcffe430
compare
public int compare(ScoredItem<T> tScoredItem, ScoredItem<T> tScoredItem1)
{    return Double.compare(tScoredItem.score, tScoredItem1.score);}
46e06657411bbdb7f92f1c86f8f9285777a265c6b7451f5bd24377c5685816b9
compareAndAdd
private static void compareAndAdd(Multiset<T> a, Multiset<T> b, int maxReturn, double threshold, int totalA, int totalB, Queue<ScoredItem<T>> best, T t)
{    int kA = a.count(t);    int kB = b.count(t);    double score = rootLogLikelihoodRatio(kA, totalA - kA, kB, totalB - kB);    if (score >= threshold) {        ScoredItem<T> x = new ScoredItem<>(t, score);        best.add(x);        while (best.size() > maxReturn) {            best.poll();        }    }}
ba944b3a50d7b874f1d93677d11a9f318013b8e552df8b53ec4f3fca9b3cf268
getScore
public double getScore()
{    return score;}
7b9a250b46ef2d9020ddc7136d782a1b2df924d3e159297f6fff83d502d2ab12
getItem
public T getItem()
{    return item;}
a5faf3aacb32b4084585a2b086a562dc4dfe7f97e6b36d572934409c95f9c270
add
public void add(double t, double x)
{    double pi = Math.exp(-(t - lastT) / alpha);    s = x + pi * s;    w = 1.0 + pi * w;    this.t = t - lastT + pi * this.t;    lastT = t;}
8e22cd2a71b4eb9e62dce07f985a60b2d5f3f63810d5c5ca271e7c945c4c1ef7
mean
public double mean()
{    return s / w;}
2cb12a2b7a9ad58bd61b4541db4315a86677b0771385c665c2c753e74b8267c7
meanRate
public double meanRate()
{    return s / t;}
0c280ca63f574cf9b9673ca6e0ee36789b58f284b6e96704f53e25359821ea3b
add
public void add(double sample)
{    n++;    double oldMean = mean;    mean += (sample - mean) / n;    double diff = (sample - mean) * (sample - oldMean);    variance += (diff - variance) / n;}
29fa59e92e8a9fa433fd7b38ebb21e8ece484149bc8e4a2726bba6f5dab39acf
getCount
public int getCount()
{    return n;}
3c3b0743c9c3947412ad2dc7dde78a1c2165b6db5b7fe4acb40ef8ad53a7efcb
getMean
public double getMean()
{    return mean;}
1b13cc1539099e1040ca859cef5d0bcbb4804d9ec5680bed8a210dd9039e910f
getSD
public double getSD()
{    return Math.sqrt(variance);}
2d445c7af662ad5641bd7c216b4e7684a9cdab361f239540c55a18b81c86443c
assignColumn
public Matrix assignColumn(int column, Vector other)
{    m.assignRow(column, other);    return this;}
95687ef4453f7375a5854c6fa51b38f6963e77319dd3f4176496189e5fd67c55
assignRow
public Matrix assignRow(int row, Vector other)
{    m.assignColumn(row, other);    return this;}
1a7b4a2d3001072b037d625fbd603f24082fad4d995e7354ef48188cd1906c22
getQuick
public double getQuick(int row, int column)
{    return m.getQuick(column, row);}
8ea1ca8bbfed9d923bb33b6722a3491db09837bb6812b8b8778bf2422064e0ab
like
public Matrix like()
{    return m.like(rows, columns);}
f88fece6b0c6401785f452c13d8cce7ea1dc13011ee8686b08685d42b6f32638
like
public Matrix like(int rows, int columns)
{    return m.like(rows, columns);}
c733fce42980b3396a3426c0cfb05355954939da4f722c3d81ab2555e6bd9282
setQuick
public void setQuick(int row, int column, double value)
{    m.setQuick(column, row, value);}
cc845ba0d004ee14775588b6cb695a9053ef1f384e5196e605687c0f7eeac020
viewRow
public Vector viewRow(int row)
{    return m.viewColumn(row);}
d46193949587a2e9ca1ec7df8ed6534443c7731e6ae91f71f45b19ee95634c85
viewColumn
public Vector viewColumn(int column)
{    return m.viewRow(column);}
13bb0e6afc607db9d98d3823768dff2d87db4d7d21d4701725b875d2cf5126d7
assign
public Matrix assign(double value)
{    return m.assign(value);}
bfca2cdd6e9adeabfb9ecc4ba7a9c7519e3c8ebe89127c7c86e17f01e99498c9
assign
public Matrix assign(Matrix other, DoubleDoubleFunction function)
{    if (other instanceof TransposedMatrixView) {        m.assign(((TransposedMatrixView) other).m, function);    } else {        m.assign(new TransposedMatrixView(other), function);    }    return this;}
c7b9095d9e97b5f4ae589a3fc0ac516b522a88c1bb719d012e8be887efa0496c
assign
public Matrix assign(Matrix other)
{    if (other instanceof TransposedMatrixView) {        return m.assign(((TransposedMatrixView) other).m);    } else {        return m.assign(new TransposedMatrixView(other));    }}
fb257471a103992bc618808f4483eec3f1f57ea976b1467f18fa4fdb8e71ac9e
assign
public Matrix assign(DoubleFunction function)
{    return m.assign(function);}
4f943db0f33d27c9f70c541ef27a217346904d47c0870b555f1140eebdc0f9b2
getFlavor
public MatrixFlavor getFlavor()
{    return flavor;}
e3071d82042033518c2f58ca4cb34bf4ea1a9aee1d22f2d857f0fc32b75070be
getBacking
public BackEnum getBacking()
{    return m.getFlavor().getBacking();}
c4bfc9c2448d43b2b2c55f7c5653a5013e068b32ee45f691e04b29caffe5c369
getStructure
public TraversingStructureEnum getStructure()
{    TraversingStructureEnum flavor = m.getFlavor().getStructure();    switch(flavor) {        case COLWISE:            return TraversingStructureEnum.ROWWISE;        case SPARSECOLWISE:            return TraversingStructureEnum.SPARSEROWWISE;        case ROWWISE:            return TraversingStructureEnum.COLWISE;        case SPARSEROWWISE:            return TraversingStructureEnum.SPARSECOLWISE;        default:            return flavor;    }}
383032e836ae8e377e669da8e774cd6f6410cb106bd66015b484c883dc1c467c
isDense
public boolean isDense()
{    return m.getFlavor().isDense();}
2cd12f02e02bd6aa8644e7a8b9777d66065b7e526bbd37fea4110e52cd12dd94
getDelegate
 Matrix getDelegate()
{    return m;}
eddd9c492bdb88f1b8a8ba6d088345b1dd2d864ec94976926f79bf72f14d247a
elementsToMatrixSize
private static int elementsToMatrixSize(int dataSize)
{    return (int) Math.round((-1 + Math.sqrt(1 + 8 * dataSize)) / 2);}
2d445c7af662ad5641bd7c216b4e7684a9cdab361f239540c55a18b81c86443c
assignColumn
public Matrix assignColumn(int column, Vector other)
{    if (columnSize() != other.size()) {        throw new IndexException(columnSize(), other.size());    }    if (other.viewPart(column + 1, other.size() - column - 1).norm(1) > 1.0e-14) {        throw new IllegalArgumentException("Cannot set lower portion of triangular matrix to non-zero");    }    for (Vector.Element element : other.viewPart(0, column).all()) {        setQuick(element.index(), column, element.get());    }    return this;}
95687ef4453f7375a5854c6fa51b38f6963e77319dd3f4176496189e5fd67c55
assignRow
public Matrix assignRow(int row, Vector other)
{    if (columnSize() != other.size()) {        throw new IndexException(numCols(), other.size());    }    for (int i = 0; i < row; i++) {        if (Math.abs(other.getQuick(i)) > EPSILON) {            throw new IllegalArgumentException("non-triangular source");        }    }    for (int i = row; i < rows; i++) {        setQuick(row, i, other.get(i));    }    return this;}
2c6522b72596fee44faf8115ede526839bf2d5af9991e3108783098f02a20de5
assignNonZeroElementsInRow
public Matrix assignNonZeroElementsInRow(int row, double[] other)
{    System.arraycopy(other, row, values, getL(row, row), rows - row);    return this;}
1a7b4a2d3001072b037d625fbd603f24082fad4d995e7354ef48188cd1906c22
getQuick
public double getQuick(int row, int column)
{    if (row > column) {        return 0;    }    int i = getL(row, column);    return values[i];}
18c21cb9bc8ffd44fdc81afeef77aa872137ae49133abea2d447af89d4719cfd
getL
private int getL(int row, int col)
{    /*     * each row starts with some zero elements that we don't store. this     * accumulates an offset of (row+1)*row/2     */    return col + row * numCols() - (row + 1) * row / 2;}
8ea1ca8bbfed9d923bb33b6722a3491db09837bb6812b8b8778bf2422064e0ab
like
public Matrix like()
{    return like(rowSize(), columnSize());}
f88fece6b0c6401785f452c13d8cce7ea1dc13011ee8686b08685d42b6f32638
like
public Matrix like(int rows, int columns)
{    return new DenseMatrix(rows, columns);}
c733fce42980b3396a3426c0cfb05355954939da4f722c3d81ab2555e6bd9282
setQuick
public void setQuick(int row, int column, double value)
{    values[getL(row, column)] = value;}
7714b327d86a7bf6870ba63ac39d817cef2071cb1e37ee1443f8106d3de5443a
getNumNondefaultElements
public int[] getNumNondefaultElements()
{    throw new UnsupportedOperationException();}
242adb7156cbde039fd67ab8f5ed8c9c46c199c38c6f12d05d2dbaffd8178820
viewPart
public Matrix viewPart(int[] offset, int[] size)
{    return new MatrixView(this, offset, size);}
df4aae00417f90cebf920b81ae629a96f1a158d3cc1888ca2ad1a57af294a10f
getData
public double[] getData()
{    return values;}
4f943db0f33d27c9f70c541ef27a217346904d47c0870b555f1140eebdc0f9b2
getFlavor
public MatrixFlavor getFlavor()
{        return new MatrixFlavor.FlavorImpl(BackEnum.JVMMEM, TraversingStructureEnum.VECTORBACKED, true);}
1c74626529ad4d35ba6f9e0a79a5f50183051849fa33d3288e58e0f3a3f1166b
getBestOperation
public static VectorBinaryAggregate getBestOperation(Vector x, Vector y, DoubleDoubleFunction fa, DoubleDoubleFunction fc)
{    int bestOperationIndex = -1;    double bestCost = Double.POSITIVE_INFINITY;    for (int i = 0; i < OPERATIONS.length; ++i) {        if (OPERATIONS[i].isValid(x, y, fa, fc)) {            double cost = OPERATIONS[i].estimateCost(x, y, fa, fc);            if (cost < bestCost) {                bestCost = cost;                bestOperationIndex = i;            }        }    }    return OPERATIONS[bestOperationIndex];}
e97a3528e2cb6a96345f23b2c2ea66184cee97d1ee63a7ca941e1ee15e8a6560
aggregateBest
public static double aggregateBest(Vector x, Vector y, DoubleDoubleFunction fa, DoubleDoubleFunction fc)
{    return getBestOperation(x, y, fa, fc).aggregate(x, y, fa, fc);}
a91c4ec0b3d603b6e7e1a431fdf3ffdd291dd59c6de2531d0e87d485d0dc7184
isValid
public boolean isValid(Vector x, Vector y, DoubleDoubleFunction fa, DoubleDoubleFunction fc)
{    return fa.isLikeRightPlus() && (fa.isAssociativeAndCommutative() || x.isSequentialAccess()) && fc.isLikeLeftMult();}
8336791c11285d8a5fd83bb3d155f65df2335797eab4f2bb33788a9bb297a1ef
estimateCost
public double estimateCost(Vector x, Vector y, DoubleDoubleFunction fa, DoubleDoubleFunction fc)
{    return x.getNumNondefaultElements() * x.getIteratorAdvanceCost() * y.getLookupCost();}
260bae0588278093e6f802b5ebcd1a148a0b85251d2a2f0fec25f3fb10ac757f
aggregate
public double aggregate(Vector x, Vector y, DoubleDoubleFunction fa, DoubleDoubleFunction fc)
{    Iterator<Vector.Element> xi = x.nonZeroes().iterator();    if (!xi.hasNext()) {        return 0;    }    Vector.Element xe = xi.next();    double result = fc.apply(xe.get(), y.getQuick(xe.index()));    while (xi.hasNext()) {        xe = xi.next();        result = fa.apply(result, fc.apply(xe.get(), y.getQuick(xe.index())));    }    return result;}
a91c4ec0b3d603b6e7e1a431fdf3ffdd291dd59c6de2531d0e87d485d0dc7184
isValid
public boolean isValid(Vector x, Vector y, DoubleDoubleFunction fa, DoubleDoubleFunction fc)
{    return fa.isLikeRightPlus() && (fa.isAssociativeAndCommutative() || y.isSequentialAccess()) && fc.isLikeRightMult();}
8336791c11285d8a5fd83bb3d155f65df2335797eab4f2bb33788a9bb297a1ef
estimateCost
public double estimateCost(Vector x, Vector y, DoubleDoubleFunction fa, DoubleDoubleFunction fc)
{    return y.getNumNondefaultElements() * y.getIteratorAdvanceCost() * x.getLookupCost() * x.getLookupCost();}
260bae0588278093e6f802b5ebcd1a148a0b85251d2a2f0fec25f3fb10ac757f
aggregate
public double aggregate(Vector x, Vector y, DoubleDoubleFunction fa, DoubleDoubleFunction fc)
{    Iterator<Vector.Element> yi = y.nonZeroes().iterator();    if (!yi.hasNext()) {        return 0;    }    Vector.Element ye = yi.next();    double result = fc.apply(x.getQuick(ye.index()), ye.get());    while (yi.hasNext()) {        ye = yi.next();        result = fa.apply(result, fc.apply(x.getQuick(ye.index()), ye.get()));    }    return result;}
a91c4ec0b3d603b6e7e1a431fdf3ffdd291dd59c6de2531d0e87d485d0dc7184
isValid
public boolean isValid(Vector x, Vector y, DoubleDoubleFunction fa, DoubleDoubleFunction fc)
{    return fa.isLikeRightPlus() && fc.isLikeMult() && x.isSequentialAccess() && y.isSequentialAccess();}
8336791c11285d8a5fd83bb3d155f65df2335797eab4f2bb33788a9bb297a1ef
estimateCost
public double estimateCost(Vector x, Vector y, DoubleDoubleFunction fa, DoubleDoubleFunction fc)
{    return Math.min(x.getNumNondefaultElements() * x.getIteratorAdvanceCost(), y.getNumNondefaultElements() * y.getIteratorAdvanceCost());}
260bae0588278093e6f802b5ebcd1a148a0b85251d2a2f0fec25f3fb10ac757f
aggregate
public double aggregate(Vector x, Vector y, DoubleDoubleFunction fa, DoubleDoubleFunction fc)
{    Iterator<Vector.Element> xi = x.nonZeroes().iterator();    Iterator<Vector.Element> yi = y.nonZeroes().iterator();    Vector.Element xe = null;    Vector.Element ye = null;    boolean advanceThis = true;    boolean advanceThat = true;    boolean validResult = false;    double result = 0;    while (true) {        if (advanceThis) {            if (xi.hasNext()) {                xe = xi.next();            } else {                break;            }        }        if (advanceThat) {            if (yi.hasNext()) {                ye = yi.next();            } else {                break;            }        }        if (xe.index() == ye.index()) {            double thisResult = fc.apply(xe.get(), ye.get());            if (validResult) {                result = fa.apply(result, thisResult);            } else {                result = thisResult;                validResult = true;            }            advanceThis = true;            advanceThat = true;        } else {            if (xe.index() < ye.index()) {                                advanceThis = true;                advanceThat = false;            } else {                                advanceThis = false;                advanceThat = true;            }        }    }    return result;}
a91c4ec0b3d603b6e7e1a431fdf3ffdd291dd59c6de2531d0e87d485d0dc7184
isValid
public boolean isValid(Vector x, Vector y, DoubleDoubleFunction fa, DoubleDoubleFunction fc)
{    return fa.isLikeRightPlus() && !fc.isDensifying() && x.isSequentialAccess() && y.isSequentialAccess();}
8336791c11285d8a5fd83bb3d155f65df2335797eab4f2bb33788a9bb297a1ef
estimateCost
public double estimateCost(Vector x, Vector y, DoubleDoubleFunction fa, DoubleDoubleFunction fc)
{    return Math.max(x.getNumNondefaultElements() * x.getIteratorAdvanceCost(), y.getNumNondefaultElements() * y.getIteratorAdvanceCost());}
260bae0588278093e6f802b5ebcd1a148a0b85251d2a2f0fec25f3fb10ac757f
aggregate
public double aggregate(Vector x, Vector y, DoubleDoubleFunction fa, DoubleDoubleFunction fc)
{    Iterator<Vector.Element> xi = x.nonZeroes().iterator();    Iterator<Vector.Element> yi = y.nonZeroes().iterator();    Vector.Element xe = null;    Vector.Element ye = null;    boolean advanceThis = true;    boolean advanceThat = true;    boolean validResult = false;    double result = 0;    while (true) {        if (advanceThis) {            if (xi.hasNext()) {                xe = xi.next();            } else {                xe = null;            }        }        if (advanceThat) {            if (yi.hasNext()) {                ye = yi.next();            } else {                ye = null;            }        }        double thisResult;        if (xe != null && ye != null) {                        if (xe.index() == ye.index()) {                thisResult = fc.apply(xe.get(), ye.get());                advanceThis = true;                advanceThat = true;            } else {                if (xe.index() < ye.index()) {                                        thisResult = fc.apply(xe.get(), 0);                    advanceThis = true;                    advanceThat = false;                } else {                    thisResult = fc.apply(0, ye.get());                    advanceThis = false;                    advanceThat = true;                }            }        } else if (xe != null) {                        thisResult = fc.apply(xe.get(), 0);            advanceThis = true;            advanceThat = false;        } else if (ye != null) {                        thisResult = fc.apply(0, ye.get());            advanceThis = false;            advanceThat = true;        } else {                        break;        }        if (validResult) {            result = fa.apply(result, thisResult);        } else {            result = thisResult;            validResult = true;        }    }    return result;}
a91c4ec0b3d603b6e7e1a431fdf3ffdd291dd59c6de2531d0e87d485d0dc7184
isValid
public boolean isValid(Vector x, Vector y, DoubleDoubleFunction fa, DoubleDoubleFunction fc)
{    return fa.isLikeRightPlus() && !fc.isDensifying() && (fa.isAssociativeAndCommutative() || (x.isSequentialAccess() && y.isSequentialAccess()));}
8336791c11285d8a5fd83bb3d155f65df2335797eab4f2bb33788a9bb297a1ef
estimateCost
public double estimateCost(Vector x, Vector y, DoubleDoubleFunction fa, DoubleDoubleFunction fc)
{    return Math.max(x.getNumNondefaultElements() * x.getIteratorAdvanceCost() * y.getLookupCost(), y.getNumNondefaultElements() * y.getIteratorAdvanceCost() * x.getLookupCost());}
260bae0588278093e6f802b5ebcd1a148a0b85251d2a2f0fec25f3fb10ac757f
aggregate
public double aggregate(Vector x, Vector y, DoubleDoubleFunction fa, DoubleDoubleFunction fc)
{    OpenIntHashSet visited = new OpenIntHashSet();    Iterator<Vector.Element> xi = x.nonZeroes().iterator();    boolean validResult = false;    double result = 0;    double thisResult;    while (xi.hasNext()) {        Vector.Element xe = xi.next();        thisResult = fc.apply(xe.get(), y.getQuick(xe.index()));        if (validResult) {            result = fa.apply(result, thisResult);        } else {            result = thisResult;            validResult = true;        }        visited.add(xe.index());    }    Iterator<Vector.Element> yi = y.nonZeroes().iterator();    while (yi.hasNext()) {        Vector.Element ye = yi.next();        if (!visited.contains(ye.index())) {            thisResult = fc.apply(x.getQuick(ye.index()), ye.get());            if (validResult) {                result = fa.apply(result, thisResult);            } else {                result = thisResult;                validResult = true;            }        }    }    return result;}
a91c4ec0b3d603b6e7e1a431fdf3ffdd291dd59c6de2531d0e87d485d0dc7184
isValid
public boolean isValid(Vector x, Vector y, DoubleDoubleFunction fa, DoubleDoubleFunction fc)
{    return x.isSequentialAccess() && y.isSequentialAccess() && !x.isDense() && !y.isDense();}
8336791c11285d8a5fd83bb3d155f65df2335797eab4f2bb33788a9bb297a1ef
estimateCost
public double estimateCost(Vector x, Vector y, DoubleDoubleFunction fa, DoubleDoubleFunction fc)
{    return Math.max(x.size() * x.getIteratorAdvanceCost(), y.size() * y.getIteratorAdvanceCost());}
260bae0588278093e6f802b5ebcd1a148a0b85251d2a2f0fec25f3fb10ac757f
aggregate
public double aggregate(Vector x, Vector y, DoubleDoubleFunction fa, DoubleDoubleFunction fc)
{    Iterator<Vector.Element> xi = x.all().iterator();    Iterator<Vector.Element> yi = y.all().iterator();    boolean validResult = false;    double result = 0;    while (xi.hasNext() && yi.hasNext()) {        Vector.Element xe = xi.next();        double thisResult = fc.apply(xe.get(), yi.next().get());        if (validResult) {            result = fa.apply(result, thisResult);        } else {            result = thisResult;            validResult = true;        }    }    return result;}
a91c4ec0b3d603b6e7e1a431fdf3ffdd291dd59c6de2531d0e87d485d0dc7184
isValid
public boolean isValid(Vector x, Vector y, DoubleDoubleFunction fa, DoubleDoubleFunction fc)
{    return (fa.isAssociativeAndCommutative() || x.isSequentialAccess()) && !x.isDense();}
8336791c11285d8a5fd83bb3d155f65df2335797eab4f2bb33788a9bb297a1ef
estimateCost
public double estimateCost(Vector x, Vector y, DoubleDoubleFunction fa, DoubleDoubleFunction fc)
{    return x.size() * x.getIteratorAdvanceCost() * y.getLookupCost();}
260bae0588278093e6f802b5ebcd1a148a0b85251d2a2f0fec25f3fb10ac757f
aggregate
public double aggregate(Vector x, Vector y, DoubleDoubleFunction fa, DoubleDoubleFunction fc)
{    Iterator<Vector.Element> xi = x.all().iterator();    boolean validResult = false;    double result = 0;    while (xi.hasNext()) {        Vector.Element xe = xi.next();        double thisResult = fc.apply(xe.get(), y.getQuick(xe.index()));        if (validResult) {            result = fa.apply(result, thisResult);        } else {            result = thisResult;            validResult = true;        }    }    return result;}
a91c4ec0b3d603b6e7e1a431fdf3ffdd291dd59c6de2531d0e87d485d0dc7184
isValid
public boolean isValid(Vector x, Vector y, DoubleDoubleFunction fa, DoubleDoubleFunction fc)
{    return (fa.isAssociativeAndCommutative() || y.isSequentialAccess()) && !y.isDense();}
8336791c11285d8a5fd83bb3d155f65df2335797eab4f2bb33788a9bb297a1ef
estimateCost
public double estimateCost(Vector x, Vector y, DoubleDoubleFunction fa, DoubleDoubleFunction fc)
{    return y.size() * y.getIteratorAdvanceCost() * x.getLookupCost();}
260bae0588278093e6f802b5ebcd1a148a0b85251d2a2f0fec25f3fb10ac757f
aggregate
public double aggregate(Vector x, Vector y, DoubleDoubleFunction fa, DoubleDoubleFunction fc)
{    Iterator<Vector.Element> yi = y.all().iterator();    boolean validResult = false;    double result = 0;    while (yi.hasNext()) {        Vector.Element ye = yi.next();        double thisResult = fc.apply(x.getQuick(ye.index()), ye.get());        if (validResult) {            result = fa.apply(result, thisResult);        } else {            result = thisResult;            validResult = true;        }    }    return result;}
a91c4ec0b3d603b6e7e1a431fdf3ffdd291dd59c6de2531d0e87d485d0dc7184
isValid
public boolean isValid(Vector x, Vector y, DoubleDoubleFunction fa, DoubleDoubleFunction fc)
{    return true;}
8336791c11285d8a5fd83bb3d155f65df2335797eab4f2bb33788a9bb297a1ef
estimateCost
public double estimateCost(Vector x, Vector y, DoubleDoubleFunction fa, DoubleDoubleFunction fc)
{    return x.size() * x.getLookupCost() * y.getLookupCost();}
260bae0588278093e6f802b5ebcd1a148a0b85251d2a2f0fec25f3fb10ac757f
aggregate
public double aggregate(Vector x, Vector y, DoubleDoubleFunction fa, DoubleDoubleFunction fc)
{    double result = fc.apply(x.getQuick(0), y.getQuick(0));    int s = x.size();    for (int i = 1; i < s; ++i) {        result = fa.apply(result, fc.apply(x.getQuick(i), y.getQuick(i)));    }    return result;}
3717ca0e08300dd5432008c36ba851427e1a7d2c3a914fc0b62400813cf07daf
getBestOperation
public static VectorBinaryAssign getBestOperation(Vector x, Vector y, DoubleDoubleFunction f)
{    int bestOperationIndex = -1;    double bestCost = Double.POSITIVE_INFINITY;    for (int i = 0; i < OPERATIONS.length; ++i) {        if (OPERATIONS[i].isValid(x, y, f)) {            double cost = OPERATIONS[i].estimateCost(x, y, f);            if (cost < bestCost) {                bestCost = cost;                bestOperationIndex = i;            }        }    }    return OPERATIONS[bestOperationIndex];}
ad9479256e51f34e6264c2b019a17eb50c129c8742feb62a3c5bd7ecaa2d816f
assignBest
public static Vector assignBest(Vector x, Vector y, DoubleDoubleFunction f)
{    return getBestOperation(x, y, f).assign(x, y, f);}
cabd9bf0b50c31c4bfab8a351e6d4edaaf93815dec87dbcdbb436deb1c5173e3
isValid
public boolean isValid(Vector x, Vector y, DoubleDoubleFunction f)
{    return f.isLikeLeftMult();}
0ba77039813dee5f4eab5022f8c4edd285b5f886270d5932f9f371d1335e7e4f
estimateCost
public double estimateCost(Vector x, Vector y, DoubleDoubleFunction f)
{    return x.getNumNondefaultElements() * x.getIteratorAdvanceCost() * y.getLookupCost();}
9278b6207db1bb13f98af5d949dfaaf4f5215f2275f32b734f124d35c75c34b8
assign
public Vector assign(Vector x, Vector y, DoubleDoubleFunction f)
{    for (Element xe : x.nonZeroes()) {        xe.set(f.apply(xe.get(), y.getQuick(xe.index())));    }    return x;}
cabd9bf0b50c31c4bfab8a351e6d4edaaf93815dec87dbcdbb436deb1c5173e3
isValid
public boolean isValid(Vector x, Vector y, DoubleDoubleFunction f)
{    return f.isLikeRightPlus();}
0ba77039813dee5f4eab5022f8c4edd285b5f886270d5932f9f371d1335e7e4f
estimateCost
public double estimateCost(Vector x, Vector y, DoubleDoubleFunction f)
{    return y.getNumNondefaultElements() * y.getIteratorAdvanceCost() * x.getLookupCost() * x.getLookupCost();}
9278b6207db1bb13f98af5d949dfaaf4f5215f2275f32b734f124d35c75c34b8
assign
public Vector assign(Vector x, Vector y, DoubleDoubleFunction f)
{    for (Element ye : y.nonZeroes()) {        x.setQuick(ye.index(), f.apply(x.getQuick(ye.index()), ye.get()));    }    return x;}
cabd9bf0b50c31c4bfab8a351e6d4edaaf93815dec87dbcdbb436deb1c5173e3
isValid
public boolean isValid(Vector x, Vector y, DoubleDoubleFunction f)
{    return f.isLikeRightPlus() && y.isSequentialAccess() && !x.isAddConstantTime();}
0ba77039813dee5f4eab5022f8c4edd285b5f886270d5932f9f371d1335e7e4f
estimateCost
public double estimateCost(Vector x, Vector y, DoubleDoubleFunction f)
{    return y.getNumNondefaultElements() * y.getIteratorAdvanceCost() * y.getLookupCost();}
9278b6207db1bb13f98af5d949dfaaf4f5215f2275f32b734f124d35c75c34b8
assign
public Vector assign(Vector x, Vector y, DoubleDoubleFunction f)
{    OrderedIntDoubleMapping updates = new OrderedIntDoubleMapping(false);    for (Element ye : y.nonZeroes()) {        updates.set(ye.index(), f.apply(x.getQuick(ye.index()), ye.get()));    }    x.mergeUpdates(updates);    return x;}
cabd9bf0b50c31c4bfab8a351e6d4edaaf93815dec87dbcdbb436deb1c5173e3
isValid
public boolean isValid(Vector x, Vector y, DoubleDoubleFunction f)
{    return f.isLikeLeftMult() && f.isLikeRightPlus() && x.isSequentialAccess() && y.isSequentialAccess();}
0ba77039813dee5f4eab5022f8c4edd285b5f886270d5932f9f371d1335e7e4f
estimateCost
public double estimateCost(Vector x, Vector y, DoubleDoubleFunction f)
{    return Math.min(x.getNumNondefaultElements() * x.getIteratorAdvanceCost(), y.getNumNondefaultElements() * y.getIteratorAdvanceCost());}
9278b6207db1bb13f98af5d949dfaaf4f5215f2275f32b734f124d35c75c34b8
assign
public Vector assign(Vector x, Vector y, DoubleDoubleFunction f)
{    Iterator<Vector.Element> xi = x.nonZeroes().iterator();    Iterator<Vector.Element> yi = y.nonZeroes().iterator();    Vector.Element xe = null;    Vector.Element ye = null;    boolean advanceThis = true;    boolean advanceThat = true;    while (true) {        if (advanceThis) {            if (xi.hasNext()) {                xe = xi.next();            } else {                break;            }        }        if (advanceThat) {            if (yi.hasNext()) {                ye = yi.next();            } else {                break;            }        }        if (xe.index() == ye.index()) {            xe.set(f.apply(xe.get(), ye.get()));            advanceThis = true;            advanceThat = true;        } else {            if (xe.index() < ye.index()) {                                advanceThis = true;                advanceThat = false;            } else {                                advanceThis = false;                advanceThat = true;            }        }    }    return x;}
cabd9bf0b50c31c4bfab8a351e6d4edaaf93815dec87dbcdbb436deb1c5173e3
isValid
public boolean isValid(Vector x, Vector y, DoubleDoubleFunction f)
{    return !f.isDensifying() && x.isSequentialAccess() && y.isSequentialAccess() && !x.isAddConstantTime();}
0ba77039813dee5f4eab5022f8c4edd285b5f886270d5932f9f371d1335e7e4f
estimateCost
public double estimateCost(Vector x, Vector y, DoubleDoubleFunction f)
{    return Math.max(x.getNumNondefaultElements() * x.getIteratorAdvanceCost(), y.getNumNondefaultElements() * y.getIteratorAdvanceCost());}
9278b6207db1bb13f98af5d949dfaaf4f5215f2275f32b734f124d35c75c34b8
assign
public Vector assign(Vector x, Vector y, DoubleDoubleFunction f)
{    Iterator<Vector.Element> xi = x.nonZeroes().iterator();    Iterator<Vector.Element> yi = y.nonZeroes().iterator();    Vector.Element xe = null;    Vector.Element ye = null;    boolean advanceThis = true;    boolean advanceThat = true;    OrderedIntDoubleMapping updates = new OrderedIntDoubleMapping(false);    while (true) {        if (advanceThis) {            if (xi.hasNext()) {                xe = xi.next();            } else {                xe = null;            }        }        if (advanceThat) {            if (yi.hasNext()) {                ye = yi.next();            } else {                ye = null;            }        }        if (xe != null && ye != null) {                        if (xe.index() == ye.index()) {                xe.set(f.apply(xe.get(), ye.get()));                advanceThis = true;                advanceThat = true;            } else {                if (xe.index() < ye.index()) {                                        xe.set(f.apply(xe.get(), 0));                    advanceThis = true;                    advanceThat = false;                } else {                    updates.set(ye.index(), f.apply(0, ye.get()));                    advanceThis = false;                    advanceThat = true;                }            }        } else if (xe != null) {                        xe.set(f.apply(xe.get(), 0));            advanceThis = true;            advanceThat = false;        } else if (ye != null) {                        updates.set(ye.index(), f.apply(0, ye.get()));            advanceThis = false;            advanceThat = true;        } else {                        break;        }    }    x.mergeUpdates(updates);    return x;}
cabd9bf0b50c31c4bfab8a351e6d4edaaf93815dec87dbcdbb436deb1c5173e3
isValid
public boolean isValid(Vector x, Vector y, DoubleDoubleFunction f)
{    return !f.isDensifying() && x.isSequentialAccess() && y.isSequentialAccess() && x.isAddConstantTime();}
0ba77039813dee5f4eab5022f8c4edd285b5f886270d5932f9f371d1335e7e4f
estimateCost
public double estimateCost(Vector x, Vector y, DoubleDoubleFunction f)
{    return Math.max(x.getNumNondefaultElements() * x.getIteratorAdvanceCost(), y.getNumNondefaultElements() * y.getIteratorAdvanceCost());}
9278b6207db1bb13f98af5d949dfaaf4f5215f2275f32b734f124d35c75c34b8
assign
public Vector assign(Vector x, Vector y, DoubleDoubleFunction f)
{    Iterator<Vector.Element> xi = x.nonZeroes().iterator();    Iterator<Vector.Element> yi = y.nonZeroes().iterator();    Vector.Element xe = null;    Vector.Element ye = null;    boolean advanceThis = true;    boolean advanceThat = true;    while (true) {        if (advanceThis) {            if (xi.hasNext()) {                xe = xi.next();            } else {                xe = null;            }        }        if (advanceThat) {            if (yi.hasNext()) {                ye = yi.next();            } else {                ye = null;            }        }        if (xe != null && ye != null) {                        if (xe.index() == ye.index()) {                xe.set(f.apply(xe.get(), ye.get()));                advanceThis = true;                advanceThat = true;            } else {                if (xe.index() < ye.index()) {                                        xe.set(f.apply(xe.get(), 0));                    advanceThis = true;                    advanceThat = false;                } else {                    x.setQuick(ye.index(), f.apply(0, ye.get()));                    advanceThis = false;                    advanceThat = true;                }            }        } else if (xe != null) {                        xe.set(f.apply(xe.get(), 0));            advanceThis = true;            advanceThat = false;        } else if (ye != null) {                        x.setQuick(ye.index(), f.apply(0, ye.get()));            advanceThis = false;            advanceThat = true;        } else {                        break;        }    }    return x;}
cabd9bf0b50c31c4bfab8a351e6d4edaaf93815dec87dbcdbb436deb1c5173e3
isValid
public boolean isValid(Vector x, Vector y, DoubleDoubleFunction f)
{    return !f.isDensifying() && !x.isAddConstantTime() && y.isSequentialAccess();}
0ba77039813dee5f4eab5022f8c4edd285b5f886270d5932f9f371d1335e7e4f
estimateCost
public double estimateCost(Vector x, Vector y, DoubleDoubleFunction f)
{    return Math.max(x.getNumNondefaultElements() * x.getIteratorAdvanceCost() * y.getLookupCost(), y.getNumNondefaultElements() * y.getIteratorAdvanceCost() * x.getLookupCost());}
9278b6207db1bb13f98af5d949dfaaf4f5215f2275f32b734f124d35c75c34b8
assign
public Vector assign(Vector x, Vector y, DoubleDoubleFunction f)
{    OpenIntHashSet visited = new OpenIntHashSet();    for (Element xe : x.nonZeroes()) {        xe.set(f.apply(xe.get(), y.getQuick(xe.index())));        visited.add(xe.index());    }    OrderedIntDoubleMapping updates = new OrderedIntDoubleMapping(false);    for (Element ye : y.nonZeroes()) {        if (!visited.contains(ye.index())) {            updates.set(ye.index(), f.apply(x.getQuick(ye.index()), ye.get()));        }    }    x.mergeUpdates(updates);    return x;}
cabd9bf0b50c31c4bfab8a351e6d4edaaf93815dec87dbcdbb436deb1c5173e3
isValid
public boolean isValid(Vector x, Vector y, DoubleDoubleFunction f)
{    return !f.isDensifying() && x.isAddConstantTime();}
0ba77039813dee5f4eab5022f8c4edd285b5f886270d5932f9f371d1335e7e4f
estimateCost
public double estimateCost(Vector x, Vector y, DoubleDoubleFunction f)
{    return Math.max(x.getNumNondefaultElements() * x.getIteratorAdvanceCost() * y.getLookupCost(), y.getNumNondefaultElements() * y.getIteratorAdvanceCost() * x.getLookupCost());}
9278b6207db1bb13f98af5d949dfaaf4f5215f2275f32b734f124d35c75c34b8
assign
public Vector assign(Vector x, Vector y, DoubleDoubleFunction f)
{    OpenIntHashSet visited = new OpenIntHashSet();    for (Element xe : x.nonZeroes()) {        xe.set(f.apply(xe.get(), y.getQuick(xe.index())));        visited.add(xe.index());    }    for (Element ye : y.nonZeroes()) {        if (!visited.contains(ye.index())) {            x.setQuick(ye.index(), f.apply(x.getQuick(ye.index()), ye.get()));        }    }    return x;}
cabd9bf0b50c31c4bfab8a351e6d4edaaf93815dec87dbcdbb436deb1c5173e3
isValid
public boolean isValid(Vector x, Vector y, DoubleDoubleFunction f)
{    return x.isSequentialAccess() && y.isSequentialAccess() && !x.isAddConstantTime() && !x.isDense() && !y.isDense();}
0ba77039813dee5f4eab5022f8c4edd285b5f886270d5932f9f371d1335e7e4f
estimateCost
public double estimateCost(Vector x, Vector y, DoubleDoubleFunction f)
{    return Math.max(x.size() * x.getIteratorAdvanceCost(), y.size() * y.getIteratorAdvanceCost());}
9278b6207db1bb13f98af5d949dfaaf4f5215f2275f32b734f124d35c75c34b8
assign
public Vector assign(Vector x, Vector y, DoubleDoubleFunction f)
{    Iterator<Vector.Element> xi = x.all().iterator();    Iterator<Vector.Element> yi = y.all().iterator();    OrderedIntDoubleMapping updates = new OrderedIntDoubleMapping(false);    while (xi.hasNext() && yi.hasNext()) {        Element xe = xi.next();        updates.set(xe.index(), f.apply(xe.get(), yi.next().get()));    }    x.mergeUpdates(updates);    return x;}
cabd9bf0b50c31c4bfab8a351e6d4edaaf93815dec87dbcdbb436deb1c5173e3
isValid
public boolean isValid(Vector x, Vector y, DoubleDoubleFunction f)
{    return x.isSequentialAccess() && y.isSequentialAccess() && x.isAddConstantTime() && !x.isDense() && !y.isDense();}
0ba77039813dee5f4eab5022f8c4edd285b5f886270d5932f9f371d1335e7e4f
estimateCost
public double estimateCost(Vector x, Vector y, DoubleDoubleFunction f)
{    return Math.max(x.size() * x.getIteratorAdvanceCost(), y.size() * y.getIteratorAdvanceCost());}
9278b6207db1bb13f98af5d949dfaaf4f5215f2275f32b734f124d35c75c34b8
assign
public Vector assign(Vector x, Vector y, DoubleDoubleFunction f)
{    Iterator<Vector.Element> xi = x.all().iterator();    Iterator<Vector.Element> yi = y.all().iterator();    while (xi.hasNext() && yi.hasNext()) {        Element xe = xi.next();        x.setQuick(xe.index(), f.apply(xe.get(), yi.next().get()));    }    return x;}
cabd9bf0b50c31c4bfab8a351e6d4edaaf93815dec87dbcdbb436deb1c5173e3
isValid
public boolean isValid(Vector x, Vector y, DoubleDoubleFunction f)
{    return !x.isAddConstantTime() && !x.isDense();}
0ba77039813dee5f4eab5022f8c4edd285b5f886270d5932f9f371d1335e7e4f
estimateCost
public double estimateCost(Vector x, Vector y, DoubleDoubleFunction f)
{    return x.size() * x.getIteratorAdvanceCost() * y.getLookupCost();}
9278b6207db1bb13f98af5d949dfaaf4f5215f2275f32b734f124d35c75c34b8
assign
public Vector assign(Vector x, Vector y, DoubleDoubleFunction f)
{    OrderedIntDoubleMapping updates = new OrderedIntDoubleMapping(false);    for (Element xe : x.all()) {        updates.set(xe.index(), f.apply(xe.get(), y.getQuick(xe.index())));    }    x.mergeUpdates(updates);    return x;}
cabd9bf0b50c31c4bfab8a351e6d4edaaf93815dec87dbcdbb436deb1c5173e3
isValid
public boolean isValid(Vector x, Vector y, DoubleDoubleFunction f)
{    return x.isAddConstantTime() && !x.isDense();}
0ba77039813dee5f4eab5022f8c4edd285b5f886270d5932f9f371d1335e7e4f
estimateCost
public double estimateCost(Vector x, Vector y, DoubleDoubleFunction f)
{    return x.size() * x.getIteratorAdvanceCost() * y.getLookupCost();}
9278b6207db1bb13f98af5d949dfaaf4f5215f2275f32b734f124d35c75c34b8
assign
public Vector assign(Vector x, Vector y, DoubleDoubleFunction f)
{    for (Element xe : x.all()) {        x.setQuick(xe.index(), f.apply(xe.get(), y.getQuick(xe.index())));    }    return x;}
cabd9bf0b50c31c4bfab8a351e6d4edaaf93815dec87dbcdbb436deb1c5173e3
isValid
public boolean isValid(Vector x, Vector y, DoubleDoubleFunction f)
{    return !x.isAddConstantTime() && !y.isDense();}
0ba77039813dee5f4eab5022f8c4edd285b5f886270d5932f9f371d1335e7e4f
estimateCost
public double estimateCost(Vector x, Vector y, DoubleDoubleFunction f)
{    return y.size() * y.getIteratorAdvanceCost() * x.getLookupCost();}
9278b6207db1bb13f98af5d949dfaaf4f5215f2275f32b734f124d35c75c34b8
assign
public Vector assign(Vector x, Vector y, DoubleDoubleFunction f)
{    OrderedIntDoubleMapping updates = new OrderedIntDoubleMapping(false);    for (Element ye : y.all()) {        updates.set(ye.index(), f.apply(x.getQuick(ye.index()), ye.get()));    }    x.mergeUpdates(updates);    return x;}
cabd9bf0b50c31c4bfab8a351e6d4edaaf93815dec87dbcdbb436deb1c5173e3
isValid
public boolean isValid(Vector x, Vector y, DoubleDoubleFunction f)
{    return x.isAddConstantTime() && !y.isDense();}
0ba77039813dee5f4eab5022f8c4edd285b5f886270d5932f9f371d1335e7e4f
estimateCost
public double estimateCost(Vector x, Vector y, DoubleDoubleFunction f)
{    return y.size() * y.getIteratorAdvanceCost() * x.getLookupCost();}
9278b6207db1bb13f98af5d949dfaaf4f5215f2275f32b734f124d35c75c34b8
assign
public Vector assign(Vector x, Vector y, DoubleDoubleFunction f)
{    for (Element ye : y.all()) {        x.setQuick(ye.index(), f.apply(x.getQuick(ye.index()), ye.get()));    }    return x;}
cabd9bf0b50c31c4bfab8a351e6d4edaaf93815dec87dbcdbb436deb1c5173e3
isValid
public boolean isValid(Vector x, Vector y, DoubleDoubleFunction f)
{    return !x.isAddConstantTime();}
0ba77039813dee5f4eab5022f8c4edd285b5f886270d5932f9f371d1335e7e4f
estimateCost
public double estimateCost(Vector x, Vector y, DoubleDoubleFunction f)
{    return x.size() * x.getLookupCost() * y.getLookupCost();}
9278b6207db1bb13f98af5d949dfaaf4f5215f2275f32b734f124d35c75c34b8
assign
public Vector assign(Vector x, Vector y, DoubleDoubleFunction f)
{    OrderedIntDoubleMapping updates = new OrderedIntDoubleMapping(false);    for (int i = 0; i < x.size(); ++i) {        updates.set(i, f.apply(x.getQuick(i), y.getQuick(i)));    }    x.mergeUpdates(updates);    return x;}
cabd9bf0b50c31c4bfab8a351e6d4edaaf93815dec87dbcdbb436deb1c5173e3
isValid
public boolean isValid(Vector x, Vector y, DoubleDoubleFunction f)
{    return x.isAddConstantTime();}
0ba77039813dee5f4eab5022f8c4edd285b5f886270d5932f9f371d1335e7e4f
estimateCost
public double estimateCost(Vector x, Vector y, DoubleDoubleFunction f)
{    return x.size() * x.getLookupCost() * y.getLookupCost();}
9278b6207db1bb13f98af5d949dfaaf4f5215f2275f32b734f124d35c75c34b8
assign
public Vector assign(Vector x, Vector y, DoubleDoubleFunction f)
{    for (int i = 0; i < x.size(); ++i) {        x.setQuick(i, f.apply(x.getQuick(i), y.getQuick(i)));    }    return x;}
39aa63eded95450eed8ae8438d97998d3316f664b548900552f7ffb6b0441d94
matrixLike
protected Matrix matrixLike(int rows, int columns)
{    return ((AbstractVector) vector).matrixLike(rows, columns);}
884f06bfd74abf9fcac20d7d3e56bc5f671ec9a0f686c5a89f82c391ef5b3fce
clone
public Vector clone()
{    VectorView r = (VectorView) super.clone();    r.vector = vector.clone();    r.offset = offset;    return r;}
383032e836ae8e377e669da8e774cd6f6410cb106bd66015b484c883dc1c467c
isDense
public boolean isDense()
{    return vector.isDense();}
048fcadf359a37696af85547983c8e1a90a6c62d53a2f5c66ba6b94ae1c5b98c
isSequentialAccess
public boolean isSequentialAccess()
{    return vector.isSequentialAccess();}
0b8db1738bea75663dc22a25e545f283c564a17a22f1a952086e91acc4922e3f
like
public VectorView like()
{    return new VectorView(vector.like(), offset, size());}
de7fe3d006f2cc6fa563e7089bbae0e5300ec5b2f82e856c1118dd26a5798a5f
like
public Vector like(int cardinality)
{    return vector.like(cardinality);}
2263144cad9c9fdd2eecb03c9f0c31fc79e73b974408c87f743169e8bea1c8f3
getQuick
public double getQuick(int index)
{    return vector.getQuick(offset + index);}
d90a04e96781b1eebeec5aca2a7d384a466650ea31ec4abd55dff982b7d2e12d
setQuick
public void setQuick(int index, double value)
{    vector.setQuick(offset + index, value);}
f6c83ebe319a78b7975eba92f536cfcf2e5e6786960fb07f54a0c99258711da5
getNumNondefaultElements
public int getNumNondefaultElements()
{    return size();}
652b99eb4e9a262b74a7b3cfc036effdc8dda8563fcbe31fb8a2d36911ea55fc
viewPart
public Vector viewPart(int offset, int length)
{    if (offset < 0) {        throw new IndexException(offset, size());    }    if (offset + length > size()) {        throw new IndexException(offset + length, size());    }    return new VectorView(vector, offset + this.offset, length);}
3ca34cc68560bbb119f164bd55a4e4987164509c53757264cd6f495de8e05427
isInView
private boolean isInView(int index)
{    return index >= offset && index < offset + size();}
0494c3c5bbf01f97ae3671ecd67c5586bc95bd0aa1907bd0e3ebdc94d70e1683
iterateNonZero
public Iterator<Element> iterateNonZero()
{    return new NonZeroIterator();}
ebaf88b6206d3b34b79e1287ba43a83a7321437a7f6da5136b43af17bd0a0476
iterator
public Iterator<Element> iterator()
{    return new AllIterator();}
805efeafbd5a8971b9858a258536df263d73a6d5b733043fdf392af2c4e52cbc
computeNext
protected Element computeNext()
{    while (it.hasNext()) {        Element el = it.next();        if (isInView(el.index()) && el.get() != 0) {            Element decorated = el;            /* vector.getElement(el.index()); */            return new DecoratorElement(decorated);        }    }    return endOfData();}
805efeafbd5a8971b9858a258536df263d73a6d5b733043fdf392af2c4e52cbc
computeNext
protected Element computeNext()
{    while (it.hasNext()) {        Element el = it.next();        if (isInView(el.index())) {            Element decorated = vector.getElement(el.index());            return new DecoratorElement(decorated);        }    }        return endOfData();}
6f9021560b40d5f0ea4687dcfc9163f88e04e559e2fc0af5f9a1fed73b4e4c24
get
public double get()
{    return decorated.get();}
5dd366da2313537c415c3c2ab9ed1909d1250d894a032bd02373d113516571d0
index
public int index()
{    return decorated.index() - offset;}
0ca3b3a320922927ea9a06f3def94b995d23a5eb7b95de57c7935a827c79759c
set
public void set(double value)
{    decorated.set(value);}
ad8e67cc94b6d67341e2eafa669a96e4de141addeda84e43821d24ae5aca2a5a
getLengthSquared
public double getLengthSquared()
{    double result = 0.0;    int size = size();    for (int i = 0; i < size; i++) {        double value = getQuick(i);        result += value * value;    }    return result;}
7375e752d4233bc7cb5a0df13e4653bd8767c60a41b29c64339fa5293a71d1ce
getDistanceSquared
public double getDistanceSquared(Vector v)
{    double result = 0.0;    int size = size();    for (int i = 0; i < size; i++) {        double delta = getQuick(i) - v.getQuick(i);        result += delta * delta;    }    return result;}
6b67fad6dd27aa2525cafe6cf3396d2225fbcdf57e5378ac7a3dee60e61f20e8
getLookupCost
public double getLookupCost()
{    return vector.getLookupCost();}
c79b5203142f65c96c29c2652557bad0bda511dfe38011e3b2877dd681f7c9cf
getIteratorAdvanceCost
public double getIteratorAdvanceCost()
{        return 2 * vector.getIteratorAdvanceCost();}
c5fbf138e094d3027905103c89bbab4aa48cd369c50dde054752fd31aa322767
isAddConstantTime
public boolean isAddConstantTime()
{    return vector.isAddConstantTime();}
0f2cea51f07acae4d2eb073f5151beaf6dba8920eaf21ed6212f67553909727d
mergeUpdates
public void mergeUpdates(OrderedIntDoubleMapping updates)
{    for (int i = 0; i < updates.getNumMappings(); ++i) {        updates.setIndexAt(i, updates.indexAt(i) + offset);    }    vector.mergeUpdates(updates);}
5011a76dadc871d7c7c57f97738d8c78961eae3293bb8d2fcf3b35fa77218b26
project
public static WeightedVector project(Vector v, Vector projection)
{    return project(v, projection, INVALID_INDEX);}
7ab73063333d1fe39623bc09e65ca64c0dc9ce9cdd7c5d929b3f6666881380e3
project
public static WeightedVector project(Vector v, Vector projection, int index)
{    return new WeightedVector(v, projection, index);}
4fcdc31ef95f5a8da570a554b48977aa3dd343f3820426ae37586f4231b6e321
getWeight
public double getWeight()
{    return weight;}
d4663f435afd6a88c00a18d16d8d8e2fe6c896dd995d5906395fd4ddbb8b7760
getIndex
public int getIndex()
{    return index;}
38e1854c50d22e8b35118e082095771ed706ae518a52cb9db43ea5c833f4057b
setWeight
public void setWeight(double newWeight)
{    this.weight = newWeight;}
bf7b7b2e083c7617d45cfbcae264174224fbc3ab6f0eeeae4dc50d4e3a2a584f
setIndex
public void setIndex(int index)
{    this.index = index;}
3f06e4bc1bde206fe6ac26b2e2c12970bc557eee7de0d8e8394b1f96568db34b
like
public Vector like()
{    return new WeightedVector(getVector().like(), weight, index);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return String.format("index=%d, weight=%.2f, v=%s", index, weight, getVector());}
359de4ee3da0e3b647b16cb1ddbe73fb1f99d386a69434328a0f89b383b817ec
clone
public WeightedVector clone()
{    WeightedVector v = (WeightedVector) super.clone();    v.weight = weight;    v.index = index;    return v;}
b9ee853edaf7c11de529961f9b862e612d8aa19da82ce6f49e73dcc166c72293
compare
public int compare(WeightedVector a, WeightedVector b)
{    if (a == b) {        return 0;    }    double aWeight = a.getWeight();    double bWeight = b.getWeight();    int r = Double.compare(aWeight, bWeight);    if (r != 0 && Math.abs(aWeight - bWeight) >= DOUBLE_EQUALITY_ERROR) {        return r;    }    double diff = a.minus(b).norm(1);    if (diff < 1.0e-12) {        return 0;    }    for (Vector.Element element : a.all()) {        r = Double.compare(element.get(), b.get(element.index()));        if (r != 0) {            return r;        }    }    return 0;}
6de070a13805e12451437dccb343b1f87f5dbbacc38d8cec6ffc95f710fc163f
testHashDouble
public void testHashDouble()
{    assertEquals(new Double(0.0).hashCode(), RandomUtils.hashDouble(0.0));    assertEquals(new Double(1.0).hashCode(), RandomUtils.hashDouble(1.0));    assertEquals(new Double(Double.POSITIVE_INFINITY).hashCode(), RandomUtils.hashDouble(Double.POSITIVE_INFINITY));    assertEquals(new Double(Double.NaN).hashCode(), RandomUtils.hashDouble(Double.NaN));}
b2b244672a0fca1e3f49a5dc431ae248a8254d68781961b878f197735ad1f77f
testHashFloat
public void testHashFloat()
{    assertEquals(new Float(0.0f).hashCode(), RandomUtils.hashFloat(0.0f));    assertEquals(new Float(1.0f).hashCode(), RandomUtils.hashFloat(1.0f));    assertEquals(new Float(Float.POSITIVE_INFINITY).hashCode(), RandomUtils.hashFloat(Float.POSITIVE_INFINITY));    assertEquals(new Float(Float.NaN).hashCode(), RandomUtils.hashFloat(Float.NaN));}
21ff73f99fbcd85346a2f974972780f8386555a21dccae307e72771349bfdbe2
testNextTwinPrime
public void testNextTwinPrime()
{    assertEquals(5, RandomUtils.nextTwinPrime(-1));    assertEquals(5, RandomUtils.nextTwinPrime(1));    assertEquals(5, RandomUtils.nextTwinPrime(2));    assertEquals(5, RandomUtils.nextTwinPrime(3));    assertEquals(7, RandomUtils.nextTwinPrime(4));    assertEquals(7, RandomUtils.nextTwinPrime(5));    assertEquals(13, RandomUtils.nextTwinPrime(6));    assertEquals(RandomUtils.MAX_INT_SMALLER_TWIN_PRIME + 2, RandomUtils.nextTwinPrime(RandomUtils.MAX_INT_SMALLER_TWIN_PRIME));    try {        RandomUtils.nextTwinPrime(RandomUtils.MAX_INT_SMALLER_TWIN_PRIME + 1);        fail();    } catch (IllegalArgumentException iae) {        }}
b7ac0667b74faa9a4a0416c81473aab7a7f62e804ceff8385e2ef7f8f4b37b3d
testSetSeed
public void testSetSeed()
{    Random rTest0 = RandomUtils.getRandom();    Random rTest1 = RandomUtils.getRandom();    Random r0 = RandomUtils.getRandom(0);    Random r1 = RandomUtils.getRandom(1);    long lTest0 = rTest0.nextLong();    long lTest1 = rTest1.nextLong();    long l0 = r0.nextLong();    long l1 = r1.nextLong();    assertEquals("getRandom() must match getRandom() in unit tests", lTest0, lTest1);    assertTrue("getRandom() must differ from getRandom(0)", lTest0 != l1);    assertTrue("getRandom(0) must differ from getRandom(1)", l0 != l1);}
ab75b1b334d63246a834330dc044290d9ce15af00e5ba602c508db8d2d129c18
checkIterator
private static void checkIterator(Iterator<Vector.Element> nzIter, double[] values)
{    while (nzIter.hasNext()) {        Vector.Element elt = nzIter.next();        assertEquals(elt.index() + " Value: " + values[elt.index()] + " does not equal: " + elt.get(), values[elt.index()], elt.get(), 0.0);    }}
6f7e93dfac9f7f59c0334c0cb5a61336815e9d98241b0314da79c961acb1e449
testSimpleOps
public void testSimpleOps()
{    T v0 = vectorToTest(20);    Random gen = RandomUtils.getRandom();    Vector v1 = v0.assign(new Normal(0, 1, gen));        assertEquals(v0.get(12), v1.get(12), 0);    v0.set(12, gen.nextDouble());    assertEquals(v0.get(12), v1.get(12), 0);    assertSame(v0, v1);    Vector v2 = vectorToTest(20).assign(new Normal(0, 1, gen));    Vector dv1 = new DenseVector(v1);    Vector dv2 = new DenseVector(v2);    Vector sv1 = new RandomAccessSparseVector(v1);    Vector sv2 = new RandomAccessSparseVector(v2);    assertEquals(0, dv1.plus(dv2).getDistanceSquared(v1.plus(v2)), FUZZ);    assertEquals(0, dv1.plus(dv2).getDistanceSquared(v1.plus(dv2)), FUZZ);    assertEquals(0, dv1.plus(dv2).getDistanceSquared(v1.plus(sv2)), FUZZ);    assertEquals(0, dv1.plus(dv2).getDistanceSquared(sv1.plus(v2)), FUZZ);    assertEquals(0, dv1.times(dv2).getDistanceSquared(v1.times(v2)), FUZZ);    assertEquals(0, dv1.times(dv2).getDistanceSquared(v1.times(dv2)), FUZZ);    assertEquals(0, dv1.times(dv2).getDistanceSquared(v1.times(sv2)), FUZZ);    assertEquals(0, dv1.times(dv2).getDistanceSquared(sv1.times(v2)), FUZZ);    assertEquals(0, dv1.minus(dv2).getDistanceSquared(v1.minus(v2)), FUZZ);    assertEquals(0, dv1.minus(dv2).getDistanceSquared(v1.minus(dv2)), FUZZ);    assertEquals(0, dv1.minus(dv2).getDistanceSquared(v1.minus(sv2)), FUZZ);    assertEquals(0, dv1.minus(dv2).getDistanceSquared(sv1.minus(v2)), FUZZ);    double z = gen.nextDouble();    assertEquals(0, dv1.divide(z).getDistanceSquared(v1.divide(z)), 1.0e-12);    assertEquals(0, dv1.times(z).getDistanceSquared(v1.times(z)), 1.0e-12);    assertEquals(0, dv1.plus(z).getDistanceSquared(v1.plus(z)), 1.0e-12);    assertEquals(dv1.dot(dv2), v1.dot(v2), FUZZ);    assertEquals(dv1.dot(dv2), v1.dot(dv2), FUZZ);    assertEquals(dv1.dot(dv2), v1.dot(sv2), FUZZ);    assertEquals(dv1.dot(dv2), sv1.dot(v2), FUZZ);    assertEquals(dv1.dot(dv2), dv1.dot(v2), FUZZ);        assertEquals(dv1.getDistanceSquared(dv2), v1.getDistanceSquared(v2), FUZZ);    assertEquals(dv1.getDistanceSquared(dv2), dv1.getDistanceSquared(v2), FUZZ);    assertEquals(dv1.getDistanceSquared(dv2), sv1.getDistanceSquared(v2), FUZZ);    assertEquals(dv1.getDistanceSquared(dv2), v1.getDistanceSquared(dv2), FUZZ);    assertEquals(dv1.getDistanceSquared(dv2), v1.getDistanceSquared(sv2), FUZZ);        assertEquals(dv1.getLengthSquared(), v1.getLengthSquared(), FUZZ);    assertEquals(dv1.getDistanceSquared(dv2), v1.getDistanceSquared(v2), FUZZ);    assertEquals(dv1.getDistanceSquared(dv2), dv1.getDistanceSquared(v2), FUZZ);    assertEquals(dv1.getDistanceSquared(dv2), sv1.getDistanceSquared(v2), FUZZ);    assertEquals(dv1.getDistanceSquared(dv2), v1.getDistanceSquared(dv2), FUZZ);    assertEquals(dv1.getDistanceSquared(dv2), v1.getDistanceSquared(sv2), FUZZ);    assertEquals(dv1.minValue(), v1.minValue(), FUZZ);    assertEquals(dv1.minValueIndex(), v1.minValueIndex());    assertEquals(dv1.maxValue(), v1.maxValue(), FUZZ);    assertEquals(dv1.maxValueIndex(), v1.maxValueIndex());    Vector nv1 = v1.normalize();    assertEquals(0, dv1.getDistanceSquared(v1), FUZZ);    assertEquals(1, nv1.norm(2), FUZZ);    assertEquals(0, dv1.normalize().getDistanceSquared(nv1), FUZZ);    nv1 = v1.normalize(1);    assertEquals(0, dv1.getDistanceSquared(v1), FUZZ);    assertEquals(1, nv1.norm(1), FUZZ);    assertEquals(0, dv1.normalize(1).getDistanceSquared(nv1), FUZZ);    assertEquals(dv1.norm(0), v1.norm(0), FUZZ);    assertEquals(dv1.norm(1), v1.norm(1), FUZZ);    assertEquals(dv1.norm(1.5), v1.norm(1.5), FUZZ);    assertEquals(dv1.norm(2), v1.norm(2), FUZZ);    assertEquals(dv1.zSum(), v1.zSum(), FUZZ);    assertEquals(3.1 * v1.size(), v1.assign(3.1).zSum(), FUZZ);    assertEquals(0, v1.plus(-3.1).norm(1), FUZZ);    v1.assign(dv1);    assertEquals(0, v1.getDistanceSquared(dv1), FUZZ);    assertEquals(dv1.zSum() - dv1.size() * 3.4, v1.assign(Functions.minus(3.4)).zSum(), FUZZ);    assertEquals(dv1.zSum() - dv1.size() * 4.5, v1.assign(Functions.MINUS, 1.1).zSum(), FUZZ);    v1.assign(dv1);    assertEquals(0, dv1.minus(dv2).getDistanceSquared(v1.assign(v2, Functions.MINUS)), FUZZ);    v1.assign(dv1);    assertEquals(dv1.norm(2), Math.sqrt(v1.aggregate(Functions.PLUS, Functions.pow(2))), FUZZ);    assertEquals(dv1.dot(dv2), v1.aggregate(v2, Functions.PLUS, Functions.MULT), FUZZ);    assertEquals(dv1.viewPart(5, 10).zSum(), v1.viewPart(5, 10).zSum(), FUZZ);    Vector v3 = v1.clone();        assertTrue(v0.getClass().isAssignableFrom(v3.getClass()));    assertTrue(v3.getClass().isAssignableFrom(v0.getClass()));    assertEquals(0, v1.getDistanceSquared(v3), FUZZ);    assertNotSame(v1, v3);    v3.assign(0);    assertEquals(0, dv1.getDistanceSquared(v1), FUZZ);    assertEquals(0, v3.getLengthSquared(), FUZZ);    dv1.assign(Functions.ABS);    v1.assign(Functions.ABS);    assertEquals(0, dv1.logNormalize().getDistanceSquared(v1.logNormalize()), FUZZ);    assertEquals(0, dv1.logNormalize(1.5).getDistanceSquared(v1.logNormalize(1.5)), FUZZ);    for (Vector.Element element : v1.all()) {        assertEquals(dv1.get(element.index()), element.get(), 0);        assertEquals(dv1.get(element.index()), v1.get(element.index()), 0);        assertEquals(dv1.get(element.index()), v1.getQuick(element.index()), 0);    }}
043ac0940df68cded7eff7c29812d2d90c185e845279432b3af2377541a66504
getTestVector
 Vector getTestVector()
{    return test;}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    super.setUp();    test = generateTestVector(2 * values.length + 1);    for (int i = 0; i < values.length; i++) {        test.set(2 * i + 1, values[i]);    }}
c33b5dd3bcce18c13e0fc227426607645a76017e12386af96c7a2aa83d9ee23e
testCardinality
public void testCardinality()
{    assertEquals("size", 7, test.size());}
67da42917796fb34c2430d36639acd5bccfa9735379b7ead28fbb27a007e4b32
testIterator
public void testIterator()
{    Iterator<Vector.Element> iterator = test.nonZeroes().iterator();    checkIterator(iterator, gold);    iterator = test.all().iterator();    checkIterator(iterator, gold);    double[] doubles = { 0.0, 5.0, 0, 3.0 };    RandomAccessSparseVector zeros = new RandomAccessSparseVector(doubles.length);    for (int i = 0; i < doubles.length; i++) {        zeros.setQuick(i, doubles[i]);    }    iterator = zeros.iterateNonZero();    checkIterator(iterator, doubles);    iterator = zeros.iterator();    checkIterator(iterator, doubles);    doubles = new double[] { 0.0, 0.0, 0, 0.0 };    zeros = new RandomAccessSparseVector(doubles.length);    for (int i = 0; i < doubles.length; i++) {        zeros.setQuick(i, doubles[i]);    }    iterator = zeros.iterateNonZero();    checkIterator(iterator, doubles);    iterator = zeros.iterator();    checkIterator(iterator, doubles);}
b877d4c6c5ab6497cbbb7966de4220a1314212180a819fcccf264c487f28e2de
testIteratorSet
public void testIteratorSet()
{    Vector clone = test.clone();    for (Element e : clone.nonZeroes()) {        e.set(e.get() * 2.0);    }    for (Element e : clone.nonZeroes()) {        assertEquals(test.get(e.index()) * 2.0, e.get(), EPSILON);    }    clone = test.clone();    for (Element e : clone.all()) {        e.set(e.get() * 2.0);    }    for (Element e : clone.all()) {        assertEquals(test.get(e.index()) * 2.0, e.get(), EPSILON);    }}
19ec40c009197b5a6fe460894a6d8b81a86c3a767ab9b25cf5bef672c9490804
testCopy
public void testCopy()
{    Vector copy = test.clone();    for (int i = 0; i < test.size(); i++) {        assertEquals("copy [" + i + ']', test.get(i), copy.get(i), EPSILON);    }}
eaa5dd587a1051f25f65fe1808fe232d587180e61c71e00071a4b765af52ae7a
testGet
public void testGet()
{    for (int i = 0; i < test.size(); i++) {        if (i % 2 == 0) {            assertEquals("get [" + i + ']', 0.0, test.get(i), EPSILON);        } else {            assertEquals("get [" + i + ']', values[i / 2], test.get(i), EPSILON);        }    }}
9229db13164bb08e86cb02598b2011a54d66b7fab1c0bf0fa2bb22bc33d46fbb
testGetOver
public void testGetOver()
{    test.get(test.size());}
9572d32c9389aa909c0a31eea413968054e22650fe87e93201c3828586e94b9f
testGetUnder
public void testGetUnder()
{    test.get(-1);}
ccc71e78604747a6c2ff387c36191673e2e448a9e206301aa6f8960c681f52d9
testSet
public void testSet()
{    test.set(3, 4.5);    for (int i = 0; i < test.size(); i++) {        if (i % 2 == 0) {            assertEquals("get [" + i + ']', 0.0, test.get(i), EPSILON);        } else if (i == 3) {            assertEquals("set [" + i + ']', 4.5, test.get(i), EPSILON);        } else {            assertEquals("set [" + i + ']', values[i / 2], test.get(i), EPSILON);        }    }}
4418db934d4155c558cef1530654d1053ddcdb06e41cedabef91b0a8f1be57e3
testSize
public void testSize()
{    assertEquals("size", 3, test.getNumNondefaultElements());}
1c256c64ddf7fdeeb2b34b7b41ccfce50c9ab448e937bd3fd0b1b5e12432ccee
testViewPart
public void testViewPart()
{    Vector part = test.viewPart(1, 2);    assertEquals("part size", 2, part.getNumNondefaultElements());    for (int i = 0; i < part.size(); i++) {        assertEquals("part[" + i + ']', test.get(i + 1), part.get(i), EPSILON);    }}
f0019886ff5ed5e11779d88428975b75ddcabd6dff13e51a1608a7db8dc0d48b
testViewPartUnder
public void testViewPartUnder()
{    test.viewPart(-1, values.length);}
1b268a78ded0b24aab73a67cf27dd311934d6fa15ff81170f302813f23a17dad
testViewPartOver
public void testViewPartOver()
{    test.viewPart(2, 7);}
9782d0b1be5c79cd5acde7629da4a6ced62d6962e4daf248107dc51c765b499a
testViewPartCardinality
public void testViewPartCardinality()
{    test.viewPart(1, 8);}
566c01d8343d99ce892c2a821e3914364628d0b0dfb1a69b532da74d3ff1f1cc
testSparseDoubleVectorInt
public void testSparseDoubleVectorInt()
{    Vector val = new RandomAccessSparseVector(4);    assertEquals("size", 4, val.size());    for (int i = 0; i < 4; i++) {        assertEquals("get [" + i + ']', 0.0, val.get(i), EPSILON);    }}
05ac62129204a03401bad4e74a1175321fd39d4ae00de71252c558f81faef571
testDot
public void testDot()
{    double res = test.dot(test);    double expected = 3.3 * 3.3 + 2.2 * 2.2 + 1.1 * 1.1;    assertEquals("dot", expected, res, EPSILON);}
6beb1640c961caab5b6602c461d7b643cc36a9f360b24d6871dec257d71e52a9
testDot2
public void testDot2()
{    Vector test2 = test.clone();    test2.set(1, 0.0);    test2.set(3, 0.0);    assertEquals(3.3 * 3.3, test2.dot(test), EPSILON);}
e39f1398f89b36a062ae3cd0fb3fcf0c3506df8125278244f75450c920ad1754
testDotCardinality
public void testDotCardinality()
{    test.dot(new DenseVector(test.size() + 1));}
7f658d8a59ddf1ad25e13b05df38d5af4bc2b42284ce03c0220724ce42612b9c
testNormalize
public void testNormalize()
{    Vector val = test.normalize();    double mag = Math.sqrt(1.1 * 1.1 + 2.2 * 2.2 + 3.3 * 3.3);    for (int i = 0; i < test.size(); i++) {        if (i % 2 == 0) {            assertEquals("get [" + i + ']', 0.0, val.get(i), EPSILON);        } else {            assertEquals("dot", values[i / 2] / mag, val.get(i), EPSILON);        }    }}
f7bbeaabdbf47078c5ea13f814ffb05bc9b90aeaa9fd0d89279cc6a77a196301
testMinus
public void testMinus()
{    Vector val = test.minus(test);    assertEquals("size", test.size(), val.size());    for (int i = 0; i < test.size(); i++) {        assertEquals("get [" + i + ']', 0.0, val.get(i), EPSILON);    }    val = test.minus(test).minus(test);    assertEquals("cardinality", test.size(), val.size());    for (int i = 0; i < test.size(); i++) {        assertEquals("get [" + i + ']', 0.0, val.get(i) + test.get(i), EPSILON);    }    Vector val1 = test.plus(1);    val = val1.minus(test);    for (int i = 0; i < test.size(); i++) {        assertEquals("get [" + i + ']', 1.0, val.get(i), EPSILON);    }    val1 = test.plus(-1);    val = val1.minus(test);    for (int i = 0; i < test.size(); i++) {        assertEquals("get [" + i + ']', -1.0, val.get(i), EPSILON);    }}
fa621704f0454f9b077a2d55f5b85be71984945b361fdcc96c4ad28da52d2600
testPlusDouble
public void testPlusDouble()
{    Vector val = test.plus(1);    assertEquals("size", test.size(), val.size());    for (int i = 0; i < test.size(); i++) {        if (i % 2 == 0) {            assertEquals("get [" + i + ']', 1.0, val.get(i), EPSILON);        } else {            assertEquals("get [" + i + ']', values[i / 2] + 1.0, val.get(i), EPSILON);        }    }}
8fdec5ffe71be730c00891f538aba0baa5d30cfc92aec8f99ad9c1c54dbe4a19
testPlusVector
public void testPlusVector()
{    Vector val = test.plus(test);    assertEquals("size", test.size(), val.size());    for (int i = 0; i < test.size(); i++) {        if (i % 2 == 0) {            assertEquals("get [" + i + ']', 0.0, val.get(i), EPSILON);        } else {            assertEquals("get [" + i + ']', values[i / 2] * 2.0, val.get(i), EPSILON);        }    }}
042256fe2eedc187e81662db06dfce58192fcc1227c93879e9f99751bc0c1eb7
testPlusVectorCardinality
public void testPlusVectorCardinality()
{    test.plus(new DenseVector(test.size() + 1));}
7ac04d97f6038094dd4e9d20b79a35ac5c99b4ef68908ce1d637e9f3fff7be05
testTimesDouble
public void testTimesDouble()
{    Vector val = test.times(3);    assertEquals("size", test.size(), val.size());    for (int i = 0; i < test.size(); i++) {        if (i % 2 == 0) {            assertEquals("get [" + i + ']', 0.0, val.get(i), EPSILON);        } else {            assertEquals("get [" + i + ']', values[i / 2] * 3.0, val.get(i), EPSILON);        }    }}
80d3dae53ecb2b40f87315975e62912a7f0d84b0ce31b6d12fde9eb280077cdf
testDivideDouble
public void testDivideDouble()
{    Vector val = test.divide(3);    assertEquals("size", test.size(), val.size());    for (int i = 0; i < test.size(); i++) {        if (i % 2 == 0) {            assertEquals("get [" + i + ']', 0.0, val.get(i), EPSILON);        } else {            assertEquals("get [" + i + ']', values[i / 2] / 3.0, val.get(i), EPSILON);        }    }}
e71fc094b81d5fc27610f7dbe24c334982ecd3e85db7403af01dcf02ea74d954
testTimesVector
public void testTimesVector()
{    Vector val = test.times(test);    assertEquals("size", test.size(), val.size());    for (int i = 0; i < test.size(); i++) {        if (i % 2 == 0) {            assertEquals("get [" + i + ']', 0.0, val.get(i), EPSILON);        } else {            assertEquals("get [" + i + ']', values[i / 2] * values[i / 2], val.get(i), EPSILON);        }    }}
593b488f5e3d7721549e06e56b7567ce37865ce15b5da27b347553403980eeba
testTimesVectorCardinality
public void testTimesVectorCardinality()
{    test.times(new DenseVector(test.size() + 1));}
a2f8bfe43ba8c92aee805d6750cf99adacee631d704901a4f5706f892b0c0a9c
testZSum
public void testZSum()
{    double expected = 0;    for (double value : values) {        expected += value;    }    assertEquals("wrong zSum", expected, test.zSum(), EPSILON);}
9321ebc2f8bd927e2a7d9cab80d2305cd566081648c41a93b3073b2f4008c2fa
testGetDistanceSquared
public void testGetDistanceSquared()
{    Vector other = new RandomAccessSparseVector(test.size());    other.set(1, -2);    other.set(2, -5);    other.set(3, -9);    other.set(4, 1);    double expected = test.minus(other).getLengthSquared();    assertTrue("a.getDistanceSquared(b) != a.minus(b).getLengthSquared", Math.abs(expected - test.getDistanceSquared(other)) < 10.0E-7);}
07c65eca6c2899b6c6bf730af78fe73d5534ea70fe59cbaed1a9fbe47cbe39f6
testAssignDouble
public void testAssignDouble()
{    test.assign(0);    for (int i = 0; i < values.length; i++) {        assertEquals("value[" + i + ']', 0.0, test.getQuick(i), EPSILON);    }}
4e1999433d6e78fc1bd67a7b4f784b938ee3a12345b63107cd5291ca77bdff1b
testAssignDoubleArray
public void testAssignDoubleArray()
{    double[] array = new double[test.size()];    test.assign(array);    for (int i = 0; i < values.length; i++) {        assertEquals("value[" + i + ']', 0.0, test.getQuick(i), EPSILON);    }}
aa4a43f59b15b59464a481b85eca98bb2f8d2bacddcaad401e3bfb096db39ff9
testAssignDoubleArrayCardinality
public void testAssignDoubleArrayCardinality()
{    double[] array = new double[test.size() + 1];    test.assign(array);}
591db7ea553e9247ef55bf8b4c66b916537b76a17f4e5d7830c60d578aff7a0a
testAssignVector
public void testAssignVector()
{    Vector other = new DenseVector(test.size());    test.assign(other);    for (int i = 0; i < values.length; i++) {        assertEquals("value[" + i + ']', 0.0, test.getQuick(i), EPSILON);    }}
9f6c04785ceb9b92ba1831d051918d04dcd2943e2eef562f8ae4bc9b7864772c
testAssignVectorCardinality
public void testAssignVectorCardinality()
{    Vector other = new DenseVector(test.size() - 1);    test.assign(other);}
1cd2167b68d321b67d088c7b60215582cb0567d7eecbe7f5ff1670624e9658f9
testAssignUnaryFunction
public void testAssignUnaryFunction()
{    test.assign(Functions.NEGATE);    for (int i = 1; i < values.length; i += 2) {        assertEquals("value[" + i + ']', -values[i], test.getQuick(i + 2), EPSILON);    }}
39bd4e5eb6e1ab133ed15d685855f1d8970472244dd5021a9ea3af3f427066e4
testAssignBinaryFunction
public void testAssignBinaryFunction()
{    test.assign(test, Functions.PLUS);    for (int i = 0; i < values.length; i++) {        if (i % 2 == 0) {            assertEquals("get [" + i + ']', 0.0, test.get(i), EPSILON);        } else {            assertEquals("value[" + i + ']', 2 * values[i - 1], test.getQuick(i), EPSILON);        }    }}
d8dc7488675c56b3c1a2d67eb4b32ba1d803df816aec794a5d36919c3c35c760
testAssignBinaryFunction2
public void testAssignBinaryFunction2()
{    test.assign(Functions.plus(4));    for (int i = 0; i < values.length; i++) {        if (i % 2 == 0) {            assertEquals("get [" + i + ']', 4.0, test.get(i), EPSILON);        } else {            assertEquals("value[" + i + ']', values[i - 1] + 4, test.getQuick(i), EPSILON);        }    }}
e471b8e5f5230cde337171c80679082b2328ca0a0cebdf0761d5705ad1896ea2
testAssignBinaryFunction3
public void testAssignBinaryFunction3()
{    test.assign(Functions.mult(4));    for (int i = 0; i < values.length; i++) {        if (i % 2 == 0) {            assertEquals("get [" + i + ']', 0.0, test.get(i), EPSILON);        } else {            assertEquals("value[" + i + ']', values[i - 1] * 4, test.getQuick(i), EPSILON);        }    }}
2c7b313449cf9e1b2ee07116dc147fbec7041da5bdb74d5e94517b5b4e80a41d
testLike
public void testLike()
{    Vector other = test.like();    assertTrue("not like", test.getClass().isAssignableFrom(other.getClass()));    assertEquals("size", test.size(), other.size());}
d57dcf403f9c6b82e67fd2f5a9026df7dc0857544086aaf8e1bb4840c724bbdf
testCrossProduct
public void testCrossProduct()
{    Matrix result = test.cross(test);    assertEquals("row size", test.size(), result.rowSize());    assertEquals("col size", test.size(), result.columnSize());    for (int row = 0; row < result.rowSize(); row++) {        for (int col = 0; col < result.columnSize(); col++) {            assertEquals("cross[" + row + "][" + col + ']', test.getQuick(row) * test.getQuick(col), result.getQuick(row, col), EPSILON);        }    }}
9ed9db955d8bd7517d6ba25e6e42437d8e719224bc6b561d1f580007f9eb1c75
testIterators
public void testIterators()
{    final T v0 = vectorToTest(20);    double sum = 0;    int elements = 0;    int nonZero = 0;    for (Element element : v0.all()) {        elements++;        sum += element.get();        if (element.get() != 0) {            nonZero++;        }    }    int nonZeroIterated = Iterables.size(v0.nonZeroes());    assertEquals(20, elements);    assertEquals(v0.size(), elements);    assertEquals(nonZeroIterated, nonZero);    assertEquals(v0.zSum(), sum, 0);}
337fb64c1f90f8919ea1bb740ea79aa38af9f0412c005bb20abcf7b7a57b7653
testSmallDistances
public void testSmallDistances()
{    for (double fuzz : new double[] { 1.0e-5, 1.0e-6, 1.0e-7, 1.0e-8, 1.0e-9, 1.0e-10 }) {        MultiNormal x = new MultiNormal(fuzz, new ConstantVector(0, 20));        for (int i = 0; i < 10000; i++) {            final T v1 = vectorToTest(20);            Vector v2 = v1.plus(x.sample());            if (1 + fuzz * fuzz > 1) {                String msg = String.format("fuzz = %.1g, >", fuzz);                assertTrue(msg, v1.getDistanceSquared(v2) > 0);                assertTrue(msg, v2.getDistanceSquared(v1) > 0);            } else {                String msg = String.format("fuzz = %.1g, >=", fuzz);                assertTrue(msg, v1.getDistanceSquared(v2) >= 0);                assertTrue(msg, v2.getDistanceSquared(v1) >= 0);            }        }    }}
cd89046fb8911fa4a6595be8ff9a8156398ebfad5d0c95e20ca6a68135c4b5d2
testToString
public void testToString()
{    Vector w;    w = generateTestVector(20);    w.set(0, 1.1);    w.set(13, 100500.);    w.set(19, 3.141592);    assertEquals("{0:1.1,13:100500.0,19:3.141592}", w.toString());    w = generateTestVector(12);    w.set(10, 0.1);    assertEquals("{10:0.1}", w.toString());    w = generateTestVector(12);    assertEquals("{}", w.toString());}
a1ebdb5a4a95938b25385ce3e8d0e5b80e9c43d127c5381fb8af2456842840a7
testYtY
public void testYtY()
{    double[][] testMatrix = new double[][] { new double[] { 1, 2, 3, 4, 5 }, new double[] { 1, 2, 3, 4, 5 }, new double[] { 1, 2, 3, 4, 5 }, new double[] { 1, 2, 3, 4, 5 }, new double[] { 1, 2, 3, 4, 5 } };    double[][] testMatrix2 = new double[][] { new double[] { 1, 2, 3, 4, 5, 6 }, new double[] { 5, 4, 3, 2, 1, 7 }, new double[] { 1, 2, 3, 4, 5, 8 }, new double[] { 1, 2, 3, 4, 5, 8 }, new double[] { 11, 12, 13, 20, 27, 8 } };    double[][][] testData = new double[][][] { testMatrix, testMatrix2 };    for (int i = 0; i < testData.length; i++) {        Matrix matrixToTest = new DenseMatrix(testData[i]);                for (int j = 0; j < 100; j++) {            validateYtY(matrixToTest, 4);        }                validateYtY(matrixToTest, 1);    }}
b1783394c495053a7d57f2e8720884bce6a12e17f56e3a00d2b600b2fecb97b9
validateYtY
private void validateYtY(Matrix matrixToTest, int numThreads)
{    OpenIntObjectHashMap<Vector> matrixToTestAsRowVectors = asRowVectors(matrixToTest);    ImplicitFeedbackAlternatingLeastSquaresSolver solver = new ImplicitFeedbackAlternatingLeastSquaresSolver(matrixToTest.columnSize(), 1, 1, matrixToTestAsRowVectors, numThreads);    Matrix yTy = matrixToTest.transpose().times(matrixToTest);    Matrix shouldMatchyTy = solver.getYtransposeY(matrixToTestAsRowVectors);    for (int row = 0; row < yTy.rowSize(); row++) {        for (int column = 0; column < yTy.columnSize(); column++) {            assertEquals(yTy.getQuick(row, column), shouldMatchyTy.getQuick(row, column), 0);        }    }}
e0db9573860f504573f67b0b79ccad0d699c129938ba61141bc79259ac6b5208
asRowVectors
private OpenIntObjectHashMap<Vector> asRowVectors(Matrix matrix)
{    OpenIntObjectHashMap<Vector> rows = new OpenIntObjectHashMap<>();    for (int row = 0; row < matrix.numRows(); row++) {        rows.put(row, matrix.viewRow(row).clone());    }    return rows;}
692ba4bf250c6149668534c4fe20b619ff2716417368700a41b7c06227218927
addLambdaTimesNuiTimesE
public void addLambdaTimesNuiTimesE()
{    int nui = 5;    double lambda = 0.2;    Matrix matrix = new SparseMatrix(5, 5);    AlternatingLeastSquaresSolver.addLambdaTimesNuiTimesE(matrix, lambda, nui);    for (int n = 0; n < 5; n++) {        assertEquals(1.0, matrix.getQuick(n, n), EPSILON);    }}
dc618385a657718ae6d74f4f2bfda15778abe4baf4b66a90c5966588d0711d29
createMiIi
public void createMiIi()
{    Vector f1 = new DenseVector(new double[] { 1, 2, 3 });    Vector f2 = new DenseVector(new double[] { 4, 5, 6 });    Matrix miIi = AlternatingLeastSquaresSolver.createMiIi(Arrays.asList(f1, f2), 3);    assertEquals(1.0, miIi.getQuick(0, 0), EPSILON);    assertEquals(2.0, miIi.getQuick(1, 0), EPSILON);    assertEquals(3.0, miIi.getQuick(2, 0), EPSILON);    assertEquals(4.0, miIi.getQuick(0, 1), EPSILON);    assertEquals(5.0, miIi.getQuick(1, 1), EPSILON);    assertEquals(6.0, miIi.getQuick(2, 1), EPSILON);}
c9afb86e996eea50acc7f049bf6f53945f91d9684d5d6ce236a5f38e99493d4f
createRiIiMaybeTransposed
public void createRiIiMaybeTransposed()
{    Vector ratings = new SequentialAccessSparseVector(3);    ratings.setQuick(1, 1.0);    ratings.setQuick(3, 3.0);    ratings.setQuick(5, 5.0);    Matrix riIiMaybeTransposed = AlternatingLeastSquaresSolver.createRiIiMaybeTransposed(ratings);    assertEquals(1, riIiMaybeTransposed.numCols(), 1);    assertEquals(3, riIiMaybeTransposed.numRows(), 3);    assertEquals(1.0, riIiMaybeTransposed.getQuick(0, 0), EPSILON);    assertEquals(3.0, riIiMaybeTransposed.getQuick(1, 0), EPSILON);    assertEquals(5.0, riIiMaybeTransposed.getQuick(2, 0), EPSILON);}
6bb240b9a1d948efebd1b7c3d8bc15cef8a8a7cd7183550e0044b46d5b557e01
createRiIiMaybeTransposedExceptionOnNonSequentialVector
public void createRiIiMaybeTransposedExceptionOnNonSequentialVector()
{    Vector ratings = new RandomAccessSparseVector(3);    ratings.setQuick(1, 1.0);    ratings.setQuick(3, 3.0);    ratings.setQuick(5, 5.0);    try {        AlternatingLeastSquaresSolver.createRiIiMaybeTransposed(ratings);        fail();    } catch (IllegalArgumentException e) {    }}
f6e94bb5356e2a7b0b24992fb25d48a1bc44f261fc06c82e5fe0ca2cfde49e7e
testUpdate
public void testUpdate()
{    MultiNormal f = new MultiNormal(20);    Vector a = f.sample();    Vector b = f.sample();    Vector c = f.sample();    DenseVector x = new DenseVector(a);    Centroid x1 = new Centroid(1, x);    x1.update(new Centroid(2, new DenseVector(b)));    Centroid x2 = new Centroid(x1);    x1.update(c);        Vector mean = a.plus(b).plus(c).assign(Functions.div(3));    assertEquals(0, x1.getVector().minus(mean).norm(1), 1.0e-8);    assertEquals(3, x1.getWeight(), 0);    assertEquals(0, x2.minus(a.plus(b).divide(2)).norm(1), 1.0e-8);    assertEquals(2, x2.getWeight(), 0);    assertEquals(0, new Centroid(x1.getIndex(), x1, x1.getWeight()).minus(x1).norm(1), 1.0e-8);        assertEquals(0, x.minus(x1).norm(1), 0);    assertEquals(3, x1.getWeight(), 1.0e-8);    assertEquals(1, x1.getIndex());}
4ac4df1e3931a65fa63ea20003a0678242a886cbf5145afce95b9b98839db958
vectorToTest
public Centroid vectorToTest(int size)
{    return new Centroid(new WeightedVector(new DenseVector(size), 3.15, 51));}
4418db934d4155c558cef1530654d1053ddcdb06e41cedabef91b0a8f1be57e3
testSize
public void testSize()
{    assertEquals("size", 3, getTestVector().getNumNonZeroElements());}
9d02883c369189f25b6de6a3fc270f77e8252465ca459b808cc75f7eac410ba7
generateTestVector
 Vector generateTestVector(int cardinality)
{    return new Centroid(new WeightedVector(new DenseVector(cardinality), 3.14, 53));}
38353c4d412f412fbc2be95944cad9a9b097b5188f9cfe92dff27f4300d90f62
rank1
public void rank1()
{    Matrix x = new DenseMatrix(3, 3);    x.viewRow(0).assign(new double[] { 1, 2, 3 });    x.viewRow(1).assign(new double[] { 2, 4, 6 });    x.viewRow(2).assign(new double[] { 3, 6, 9 });    CholeskyDecomposition rr = new CholeskyDecomposition(x.transpose().times(x), false);    assertEquals(0, new DenseVector(new double[] { 3.741657, 7.483315, 11.22497 }).aggregate(rr.getL().transpose().viewRow(0), Functions.PLUS, new DoubleDoubleFunction() {        @Override        public double apply(double arg1, double arg2) {            return Math.abs(arg1) - Math.abs(arg2);        }    }), 1.0e-5);    assertEquals(0, rr.getL().viewPart(0, 3, 1, 2).aggregate(Functions.PLUS, Functions.ABS), 1.0e-9);}
deeca4bb8badcf2a6323bbc5cc3391495ea6e718f5eccbfec72e46dc78ea4bdf
apply
public double apply(double arg1, double arg2)
{    return Math.abs(arg1) - Math.abs(arg2);}
7abf0d328ce79ce1022b3038a8f0282dfbe84f96d8b9575f5b1cbad75d90935c
test1
public void test1()
{    final Random rand = RandomUtils.getRandom();    Matrix z = new DenseMatrix(100, 100);    z.assign(new DoubleFunction() {        @Override        public double apply(double arg1) {            return rand.nextDouble();        }    });    Matrix A = z.times(z.transpose());    for (boolean type = false; !type; type = true) {        CholeskyDecomposition cd = new CholeskyDecomposition(A, type);        Matrix L = cd.getL();                Matrix Abar = L.times(L.transpose());        double error = A.minus(Abar).aggregate(Functions.MAX, Functions.ABS);        Assert.assertEquals("type = " + type, 0, error, 1.0e-10);                Matrix q = cd.solveLeft(z);        Matrix id = q.times(q.transpose());        for (int i = 0; i < id.columnSize(); i++) {            Assert.assertEquals("type = " + type, 1, id.get(i, i), 1.0e-9);            Assert.assertEquals("type = " + type, 1, id.viewRow(i).norm(1), 1.0e-9);        }                q = cd.solveRight(z.transpose());        id = q.transpose().times(q);        for (int i = 0; i < id.columnSize(); i++) {            Assert.assertEquals("type = " + type, 1, id.get(i, i), 1.0e-9);            Assert.assertEquals("type = " + type, 1, id.viewRow(i).norm(1), 1.0e-9);        }    }}
685ca82cead33e56c75cad5ace5f3cba2e4e471d0dcc68359527832073e7cdd4
apply
public double apply(double arg1)
{    return rand.nextDouble();}
78712b6e884411e98dd0ccae6b8bfc60be9d54435186ab560c34ad3df2e2b8b6
test2
public void test2()
{        double[][] values = new double[3][];    values[0] = new double[] { 1, -1, 1 };    values[1] = new double[] { -1, 1, -1 };    values[2] = new double[] { 1, -1, 2 };    Matrix A = new DenseMatrix(values);        CholeskyDecomposition cd = new CholeskyDecomposition(A, false);    assertEquals(0, cd.getL().times(cd.getL().transpose()).minus(A).aggregate(Functions.PLUS, Functions.ABS), 1.0e-10);        cd = new CholeskyDecomposition(A);    assertEquals(0, cd.getL().times(cd.getL().transpose()).minus(A).aggregate(Functions.PLUS, Functions.ABS), 1.0e-10);}
2556161ce3c7c3dbe012114ebf1038ae8646dc1413c8b0d0e5b5553d33ab485a
testRankDeficient
public void testRankDeficient()
{    Matrix A = rank4Matrix();    CholeskyDecomposition cd = new CholeskyDecomposition(A);    PivotedMatrix Ax = new PivotedMatrix(A, cd.getPivot());    CholeskyDecomposition cd2 = new CholeskyDecomposition(Ax, false);    assertEquals(0, cd2.getL().times(cd2.getL().transpose()).minus(Ax).aggregate(Functions.PLUS, Functions.ABS), 1.0e-10);    assertEquals(0, cd.getL().times(cd.getL().transpose()).minus(A).aggregate(Functions.PLUS, Functions.ABS), 1.0e-10);    Assert.assertFalse(cd.isPositiveDefinite());    Matrix L = cd.getL();    Matrix Abar = L.times(L.transpose());    double error = A.minus(Abar).aggregate(Functions.MAX, Functions.ABS);    Assert.assertEquals(0, error, 1.0e-10);}
9d9f1a3fd8f3ffd3dd6462daacb4f303d70302c2394eb2f179529a7f3d0bff02
rank4Matrix
private static Matrix rank4Matrix()
{    final Random rand = RandomUtils.getRandom();    Matrix u = new DenseMatrix(10, 4);    u.assign(new DoubleFunction() {        @Override        public double apply(double arg1) {            return rand.nextDouble();        }    });    Matrix v = new DenseMatrix(10, 4);    v.assign(new DoubleFunction() {        @Override        public double apply(double arg1) {            return rand.nextDouble();        }    });    Matrix z = u.times(v.transpose());    return z.times(z.transpose());}
685ca82cead33e56c75cad5ace5f3cba2e4e471d0dcc68359527832073e7cdd4
apply
public double apply(double arg1)
{    return rand.nextDouble();}
685ca82cead33e56c75cad5ace5f3cba2e4e471d0dcc68359527832073e7cdd4
apply
public double apply(double arg1)
{    return rand.nextDouble();}
64dab36b722cf18c3bfe04abc5cf90262ddb2c9627dac16f8ca0bd35f2779e1b
timeSolver
public static long timeSolver(Matrix corpus, double convergence, int maxNumPasses, TrainingState state)
{    return timeSolver(corpus, convergence, maxNumPasses, 10, state);}
6ea5d407ca5baf5da987113cc9d1a65c0531f6348b511d3bca4e3173b7ae85f5
timeSolver
public static long timeSolver(Matrix corpus, double convergence, int maxNumPasses, int desiredRank, TrainingState state)
{    HebbianUpdater updater = new HebbianUpdater();    AsyncEigenVerifier verifier = new AsyncEigenVerifier();    HebbianSolver solver = new HebbianSolver(updater, verifier, convergence, maxNumPasses);    long start = System.nanoTime();    TrainingState finalState = solver.solve(corpus, desiredRank);    assertNotNull(finalState);    state.setCurrentEigens(finalState.getCurrentEigens());    state.setCurrentEigenValues(finalState.getCurrentEigenValues());    long time = 0L;    time += System.nanoTime() - start;    verifier.close();    assertEquals(state.getCurrentEigens().numRows(), desiredRank);    return time / 1000000L;}
57ddb9eb36205700b9baf235db72bb19a49940bf59724aaa1c4521a29320d7b8
timeSolver
public static long timeSolver(Matrix corpus, TrainingState state)
{    return timeSolver(corpus, state, 10);}
1ce5150e485c79d714fe3ff3f2a29eaab074ec9ca6e0cb0031accb7db8bbcf48
timeSolver
public static long timeSolver(Matrix corpus, TrainingState state, int rank)
{    return timeSolver(corpus, 0.01, 20, rank, state);}
21c76f55c3bc0a965f6c8984ea074e0c00b3e99a13792b3ef662df982b289d42
testHebbianSolver
public void testHebbianSolver()
{    int numColumns = 800;    Matrix corpus = randomSequentialAccessSparseMatrix(1000, 900, numColumns, 30, 1.0);    int rank = 50;    Matrix eigens = new DenseMatrix(rank, numColumns);    TrainingState state = new TrainingState(eigens, null);    long optimizedTime = timeSolver(corpus, 0.00001, 5, rank, state);    eigens = state.getCurrentEigens();    assertEigen(eigens, corpus, 0.05, false);    assertOrthonormal(eigens, 1.0e-6);    System.out.println("Avg solving (Hebbian) time in ms: " + optimizedTime);}
9d5e4d21bd85f9c232fc5d8826a8c715993e4f85bad40e73dc6e064f4aaa592c
testEigenvalueCheck
public void testEigenvalueCheck() throws Exception
{    int size = 100;    Matrix m = randomHierarchicalSymmetricMatrix(size);    Vector initialVector = new DenseVector(size);    initialVector.assign(1.0 / Math.sqrt(size));    LanczosSolver solver = new LanczosSolver();    int desiredRank = 80;    LanczosState state = new LanczosState(m, desiredRank, initialVector);        solver.solve(state, desiredRank, true);    EigenDecomposition decomposition = new EigenDecomposition(m);    Vector eigenvalues = decomposition.getRealEigenvalues();    float fractionOfEigensExpectedGood = 0.6f;    for (int i = 0; i < fractionOfEigensExpectedGood * desiredRank; i++) {        double s = state.getSingularValue(i);        double e = eigenvalues.get(i);        log.info("{} : L = {}, E = {}", i, s, e);        assertTrue("Singular value differs from eigenvalue", Math.abs((s - e) / e) < ERROR_TOLERANCE);        Vector v = state.getRightSingularVector(i);        Vector v2 = decomposition.getV().viewColumn(i);        double error = 1 - Math.abs(v.dot(v2) / (v.norm(2) * v2.norm(2)));        log.info("error: {}", error);        assertTrue(i + ": 1 - cosAngle = " + error, error < ERROR_TOLERANCE);    }}
abb31b445e3c8ccc76457678017deb72cc7bae30f61a07edbe1ffa95a017823c
testLanczosSolver
public void testLanczosSolver() throws Exception
{    int numRows = 800;    int numColumns = 500;    Matrix corpus = randomHierarchicalMatrix(numRows, numColumns, false);    Vector initialVector = new DenseVector(numColumns);    initialVector.assign(1.0 / Math.sqrt(numColumns));    int rank = 50;    LanczosState state = new LanczosState(corpus, rank, initialVector);    LanczosSolver solver = new LanczosSolver();    solver.solve(state, rank, false);    assertOrthonormal(state);    for (int i = 0; i < rank / 2; i++) {        assertEigen(i, state.getRightSingularVector(i), corpus, ERROR_TOLERANCE, false);    }}
ee8cdf2b3f1155eafde1d99ac5665efb73b76a0dc06207db877f01e10bffc2f7
testLanczosSolverSymmetric
public void testLanczosSolverSymmetric() throws Exception
{    int numCols = 500;    Matrix corpus = randomHierarchicalSymmetricMatrix(numCols);    Vector initialVector = new DenseVector(numCols);    initialVector.assign(1.0 / Math.sqrt(numCols));    int rank = 30;    LanczosState state = new LanczosState(corpus, rank, initialVector);    LanczosSolver solver = new LanczosSolver();    solver.solve(state, rank, true);}
51dab3eae7fc33e0ec13edff8158fbe6576436ddf48fde2807706a33ba40dae0
assertOrthonormal
public static void assertOrthonormal(Matrix eigens)
{    assertOrthonormal(eigens, 1.0e-6);}
a3440eb8f9edf880db32da156bcab8dd2e29e4434ba05face0b5e721664033ef
assertOrthonormal
public static void assertOrthonormal(Matrix currentEigens, double errorMargin)
{    List<String> nonOrthogonals = Lists.newArrayList();    for (int i = 0; i < currentEigens.numRows(); i++) {        Vector ei = currentEigens.viewRow(i);        for (int j = 0; j <= i; j++) {            Vector ej = currentEigens.viewRow(j);            if (ei.norm(2) == 0 || ej.norm(2) == 0) {                continue;            }            double dot = ei.dot(ej);            if (i == j) {                assertTrue("not norm 1 : " + dot + " (eigen #" + i + ')', Math.abs(1.0 - dot) < errorMargin);            } else {                if (Math.abs(dot) > errorMargin) {                    log.info("not orthogonal : {} (eigens {}, {})", dot, i, j);                    nonOrthogonals.add("(" + i + ',' + j + ')');                }            }        }        log.info("{}:{}", nonOrthogonals.size(), nonOrthogonals);    }}
da8504b10ef4116c637495c22139093b2e34c2037c30a3e90b0b6456835fd28f
assertOrthonormal
public static void assertOrthonormal(LanczosState state)
{    double errorMargin = 1.0e-5;    List<String> nonOrthogonals = Lists.newArrayList();    for (int i = 0; i < state.getIterationNumber(); i++) {        Vector ei = state.getRightSingularVector(i);        for (int j = 0; j <= i; j++) {            Vector ej = state.getRightSingularVector(j);            if (ei.norm(2) == 0 || ej.norm(2) == 0) {                continue;            }            double dot = ei.dot(ej);            if (i == j) {                assertTrue("not norm 1 : " + dot + " (eigen #" + i + ')', Math.abs(1.0 - dot) < errorMargin);            } else {                if (Math.abs(dot) > errorMargin) {                    log.info("not orthogonal : {} (eigens {}, {})", dot, i, j);                    nonOrthogonals.add("(" + i + ',' + j + ')');                }            }        }        if (!nonOrthogonals.isEmpty()) {            log.info("{}:{}", nonOrthogonals.size(), nonOrthogonals);        }    }}
bc7c7ad641a95e3f814d06a1290e335c7e5e4325b75c4cf47cbf65025da61d2a
assertEigen
public static void assertEigen(Matrix eigens, VectorIterable corpus, double errorMargin, boolean isSymmetric)
{    assertEigen(eigens, corpus, eigens.numRows(), errorMargin, isSymmetric);}
3e8906d90d0ddb82ff869a5dc1953d8339d82b9106c1300a9c73b6c5ea47dd6d
assertEigen
public static void assertEigen(Matrix eigens, VectorIterable corpus, int numEigensToCheck, double errorMargin, boolean isSymmetric)
{    for (int i = 0; i < numEigensToCheck; i++) {        Vector e = eigens.viewRow(i);        assertEigen(i, e, corpus, errorMargin, isSymmetric);    }}
ad0e8a03936434fbea1b8ab3c3818f66b2bceb0226c684e00b7a023ba2b3b31c
assertEigen
public static void assertEigen(int i, Vector e, VectorIterable corpus, double errorMargin, boolean isSymmetric)
{    if (e.getLengthSquared() == 0) {        return;    }    Vector afterMultiply = isSymmetric ? corpus.times(e) : corpus.timesSquared(e);    double dot = afterMultiply.dot(e);    double afterNorm = afterMultiply.getLengthSquared();    double error = 1 - Math.abs(dot / Math.sqrt(afterNorm * e.getLengthSquared()));    log.info("the eigen-error: {} for eigen {}", error, i);    assertTrue("Error: {" + error + " too high! (for eigen " + i + ')', Math.abs(error) < errorMargin);}
dfd920ebb1d2e2fdf4853b7f8e3a3382bd635735ed67d83e89d0a2cb6011eee9
randomSequentialAccessSparseMatrix
public static Matrix randomSequentialAccessSparseMatrix(int numRows, int nonNullRows, int numCols, int entriesPerRow, double entryMean)
{    Matrix m = new SparseRowMatrix(numRows, numCols);        Random r = RandomUtils.getRandom();    for (int i = 0; i < nonNullRows; i++) {        Vector v = new SequentialAccessSparseVector(numCols);        for (int j = 0; j < entriesPerRow; j++) {            int col = r.nextInt(numCols);            double val = r.nextGaussian();            v.set(col, val * entryMean);        }        int c = r.nextInt(numRows);        if (r.nextBoolean() || numRows == nonNullRows) {            m.assignRow(numRows == nonNullRows ? i : c, v);        } else {            Vector other = m.viewRow(r.nextInt(numRows));            if (other != null && other.getLengthSquared() > 0) {                m.assignRow(c, other.clone());            }        }        }    return m;}
e00427fb38099354af220fc5de0abd987c751967c7f7d6df17dfb020cf1047d4
randomHierarchicalMatrix
public static Matrix randomHierarchicalMatrix(int numRows, int numCols, boolean symmetric)
{    Matrix matrix = new DenseMatrix(numRows, numCols);        Random r = new Random(1234L);    for (int row = 0; row < numRows; row++) {        Vector v = new DenseVector(numCols);        for (int col = 0; col < numCols; col++) {            double val = r.nextGaussian();            v.set(col, val);        }        v.assign(Functions.MULT, 1 / ((row + 1) * v.norm(2)));        matrix.assignRow(row, v);    }    if (symmetric) {        return matrix.times(matrix.transpose());    }    return matrix;}
8c3d113bd221c5731b180958bc3d393bbef4203478a7b94005aaefd2423a383b
randomHierarchicalSymmetricMatrix
public static Matrix randomHierarchicalSymmetricMatrix(int size)
{    return randomHierarchicalMatrix(size, size, true);}
0b309a742a08b61f932d92aa0ff7edc89c85d011d923a9d9fc6e79b18b165775
testBasics
public void testBasics()
{    Matrix a = new DenseSymmetricMatrix(new double[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }, false);    System.out.println(a.toString());    assertEquals(0, a.viewDiagonal().minus(new DenseVector(new double[] { 1, 5, 8, 10 })).norm(1), 1.0e-10);    assertEquals(0, a.viewPart(0, 3, 1, 3).viewDiagonal().minus(new DenseVector(new double[] { 2, 6, 9 })).norm(1), 1.0e-10);    assertEquals(4, a.get(0, 3), 1.0e-10);    System.out.println(a);    Matrix m = new DenseMatrix(4, 4).assign(a);    assertEquals(0, m.minus(a).aggregate(Functions.PLUS, Functions.ABS), 1.0e-10);    System.out.println(m);    assertEquals(0, m.transpose().times(m).minus(a.transpose().times(a)).aggregate(Functions.PLUS, Functions.ABS), 1.0e-10);    System.out.println(a.plus(a));    assertEquals(0, m.plus(m).minus(a.plus(a)).aggregate(Functions.PLUS, Functions.ABS), 1.0e-10);}
813fdaa0aa2ba12dc94150c8d18b6bb699e4f73e4333bb5d92bbc451ee3d5011
testEigen
public void testEigen()
{    Matrix a = new DenseSymmetricMatrix(new double[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }, false);    Matrix b = new DenseMatrix(a.numRows(), a.numCols());    b.assign(a);    assertEquals(0, a.minus(b).aggregate(Functions.PLUS, Functions.ABS), 1.0e-10);    EigenDecomposition edA = new EigenDecomposition(a);    EigenDecomposition edB = new EigenDecomposition(b);    System.out.println(edA.getV());    assertEquals(0, edA.getV().minus(edB.getV()).aggregate(Functions.PLUS, Functions.ABS), 1.0e-10);    assertEquals(0, edA.getRealEigenvalues().minus(edA.getRealEigenvalues()).aggregate(Functions.PLUS, Functions.ABS), 1.0e-10);}
0b309a742a08b61f932d92aa0ff7edc89c85d011d923a9d9fc6e79b18b165775
testBasics
public void testBasics()
{    DiagonalMatrix a = new DiagonalMatrix(new double[] { 1, 2, 3, 4 });    assertEquals(0, a.viewDiagonal().minus(new DenseVector(new double[] { 1, 2, 3, 4 })).norm(1), 1.0e-10);    assertEquals(0, a.viewPart(0, 3, 0, 3).viewDiagonal().minus(new DenseVector(new double[] { 1, 2, 3 })).norm(1), 1.0e-10);    assertEquals(4, a.get(3, 3), 1.0e-10);    Matrix m = new DenseMatrix(4, 4);    m.assign(a);    assertEquals(0, m.minus(a).aggregate(Functions.PLUS, Functions.ABS), 1.0e-10);    assertEquals(0, m.transpose().times(m).minus(a.transpose().times(a)).aggregate(Functions.PLUS, Functions.ABS), 1.0e-10);    assertEquals(0, m.plus(m).minus(a.plus(a)).aggregate(Functions.PLUS, Functions.ABS), 1.0e-10);    m = new DenseMatrix(new double[][] { { 1, 2, 3, 4 }, { 5, 6, 7, 8 } });    assertEquals(100, a.timesLeft(m).aggregate(Functions.PLUS, Functions.ABS), 1.0e-10);    assertEquals(100, a.times(m.transpose()).aggregate(Functions.PLUS, Functions.ABS), 1.0e-10);}
5cdcaf327e37b2590d615aebc5a8e8c0d92393beb7b0ee4fc63373d3b81813ae
testSparsity
public void testSparsity()
{    Vector d = new DenseVector(10);    for (int i = 0; i < 10; i++) {        d.set(i, i * i);    }    DiagonalMatrix m = new DiagonalMatrix(d);    Assert.assertFalse(m.viewRow(0).isDense());    Assert.assertFalse(m.viewColumn(0).isDense());    for (int i = 0; i < 10; i++) {        assertEquals(i * i, m.viewRow(i).zSum(), 0);        assertEquals(i * i, m.viewRow(i).get(i), 0);        assertEquals(i * i, m.viewColumn(i).zSum(), 0);        assertEquals(i * i, m.viewColumn(i).get(i), 0);    }    Iterator<Vector.Element> ix = m.viewRow(7).nonZeroes().iterator();    assertTrue(ix.hasNext());    Vector.Element r = ix.next();    assertEquals(7, r.index());    assertEquals(49, r.get(), 0);    assertFalse(ix.hasNext());    assertEquals(0, m.viewRow(5).get(3), 0);    assertEquals(0, m.viewColumn(8).get(3), 0);    m.viewRow(3).set(3, 1);    assertEquals(1, m.get(3, 3), 0);    for (Vector.Element element : m.viewRow(6).all()) {        if (element.index() == 6) {            assertEquals(36, element.get(), 0);        } else {            assertEquals(0, element.get(), 0);        }    }}
abbb3fa33071db4ed993a88649bd826e7ae5866a801df17c2daf8e25b4ba1baa
testBigMatrix
public void testBigMatrix() throws IOException
{        Assume.assumeNotNull(System.getProperty("runSlowTests"));    Matrix m0 = new SparseRowMatrix(ROWS, COLUMNS);    Random gen = RandomUtils.getRandom();    for (int i = 0; i < 1000; i++) {        m0.set(gen.nextInt(ROWS), gen.nextInt(COLUMNS), matrixValue(i));    }    File f = File.createTempFile("foo", ".m", getTestTempDir());    f.deleteOnExit();    System.out.printf("Starting to write to %s\n", f.getAbsolutePath());    FileBasedMatrix.writeMatrix(f, m0);    System.out.printf("done\n");    System.out.printf("File is %.1f MB\n", f.length() / 1.0e6);    FileBasedMatrix m1 = new FileBasedMatrix(ROWS, COLUMNS);    System.out.printf("Starting read\n");    m1.setData(f, false);    gen = RandomUtils.getRandom();    for (int i = 0; i < 1000; i++) {        assertEquals(matrixValue(i), m1.get(gen.nextInt(ROWS), gen.nextInt(COLUMNS)), 0.0);    }    System.out.printf("done\n");}
adb38f44a35e101122611b81a346e322a1da937b7380dbf647184f6e77ecb09b
matrixValue
private static int matrixValue(int i)
{    return (i * 88513) % 10000;}
f43991df6681373479ade5c5e91898ad2736f0dec0671c26567a107d9609c6d9
testSetData
public void testSetData() throws IOException
{    File f = File.createTempFile("matrix", ".m", getTestTempDir());    f.deleteOnExit();    Matrix m0 = new DenseMatrix(100000, 30);    MultiNormal gen = new MultiNormal(30);    for (MatrixSlice row : m0) {        row.vector().assign(gen.sample());    }    FileBasedMatrix.writeMatrix(f, m0);    FileBasedMatrix m = new FileBasedMatrix(100000, 30);    m.setData(f, true);    assertEquals(0, m0.minus(m).aggregate(Functions.MAX, Functions.ABS), 1.0e-8);    int i = 0;    for (MatrixSlice row : m) {        assertEquals(0, row.vector().minus(m0.viewRow(i++)).norm(1), 1.0e-8);    }}
f43991df6681373479ade5c5e91898ad2736f0dec0671c26567a107d9609c6d9
testSetData
public void testSetData() throws IOException
{    File f = File.createTempFile("matrix", ".m", getTestTempDir());    f.deleteOnExit();    Random gen = RandomUtils.getRandom();    Matrix m0 = new SparseRowMatrix(10, 21);    for (MatrixSlice row : m0) {        int len = (int) Math.ceil(-15 * Math.log(1 - gen.nextDouble()));        for (int i = 0; i < len; i++) {            row.vector().set(gen.nextInt(21), 1);        }    }    FileBasedSparseBinaryMatrix.writeMatrix(f, m0);    FileBasedSparseBinaryMatrix m = new FileBasedSparseBinaryMatrix(10, 21);    m.setData(f);    for (MatrixSlice row : m) {        Vector diff = row.vector().minus(m0.viewRow(row.index()));        double error = diff.norm(1);        if (error > 1.0e-14) {            System.out.printf("%s\n", diff);        }        assertEquals(0, error, 1.0e-14);    }}
47da711aa5147507955adb3a3e94cf7d0258b308904a27d5b8d5e397f4911136
generateData
public static Collection<Object[]> generateData()
{    List<Object[]> data = Lists.newArrayList();    for (Field field : Functions.class.getDeclaredFields()) {        if (field.getType().isAssignableFrom(DoubleDoubleFunction.class) && Modifier.isStatic(field.getModifiers()) && !field.getName().equals("SECOND_LEFT_ZERO")) {            try {                data.add(new Object[] { field.get(null), field.getName() });            } catch (IllegalAccessException e) {                System.out.printf("Couldn't access Functions field %s\n", field.getName());            }        }    }    return data;}
e9da5aa574f12d798bce9c2cdf9f3672221f47e2ca0c56e27b0d7968d07f9907
testIsLikeRightPlus
public void testIsLikeRightPlus()
{    if (!function.isLikeRightPlus()) {        return;    }    for (int i = 0; i < NUM_POINTS; ++i) {        double x = random.nextDouble();        assertEquals(functionName, x, function.apply(x, 0), 0);    }}
df8b82624461be612081a9beec28312f573f158107685edaa252b2cc38f56a61
testIsLikeLeftMult
public void testIsLikeLeftMult()
{    if (!function.isLikeLeftMult()) {        return;    }    for (int i = 0; i < NUM_POINTS; ++i) {        double y = random.nextDouble();        assertEquals(functionName, 0, function.apply(0, y), 0);    }}
bef29fb532448a606624cae7246dc631908d68052fbaa1779ad524c01c0fa840
testIsLikeRightMult
public void testIsLikeRightMult()
{    if (!function.isLikeRightMult()) {        return;    }    for (int i = 0; i < NUM_POINTS; ++i) {        double x = random.nextDouble();        assertEquals(functionName, 0, function.apply(x, 0), 0);    }}
4b824623cc627249ac922b3450873ebf086e421a8d45930624f5d041e3e01b49
testIsCommutative
public void testIsCommutative()
{    if (!function.isCommutative()) {        return;    }    for (int i = 0; i < NUM_POINTS; ++i) {        double x = random.nextDouble();        double y = random.nextDouble();        assertEquals(functionName, function.apply(x, y), function.apply(y, x), Constants.EPSILON);    }}
63e4e0c400eabbac251abb42567bce85db0df1a766d14584dc8c284ad3a4a5b0
testIsAssociative
public void testIsAssociative()
{    if (!function.isAssociative()) {        return;    }    for (int i = 0; i < NUM_POINTS; ++i) {        double x = random.nextDouble();        double y = random.nextDouble();        double z = random.nextDouble();        assertEquals(functionName, function.apply(x, function.apply(y, z)), function.apply(function.apply(x, y), z), Constants.EPSILON);    }}
93db301258ed21804161d2b3849da248cf4e699fa8c7012af1f41cc652b3f934
testIsDensifying
public void testIsDensifying()
{    if (!function.isDensifying()) {        assertEquals(functionName, 0, function.apply(0, 0), 0);    }}
82fa97aedbf2a7ae63d750c82c613f96553e1a358b07a719e7f5a5ec3573565d
checkDistribution
public static void checkDistribution(final AbstractContinousDistribution dist, double[] x, double offset, double scale, int n)
{    double[] xs = Arrays.copyOf(x, x.length);    for (int i = 0; i < xs.length; i++) {        xs[i] = xs[i] * scale + offset;    }    Arrays.sort(xs);        double[] y = new double[n];    for (int i = 0; i < n; i++) {        y[i] = dist.nextDouble();    }    Arrays.sort(y);        double[] p = new double[xs.length + 1];    double lastP = 0;    for (int i = 0; i < xs.length; i++) {        double thisP = dist.cdf(xs[i]);        p[i] = thisP - lastP;        lastP = thisP;    }    p[p.length - 1] = 1 - lastP;        int[] k = new int[xs.length + 1];    int lastJ = 0;    for (int i = 0; i < k.length - 1; i++) {        int j = 0;        while (j < n && y[j] < xs[i]) {            j++;        }        k[i] = j - lastJ;        lastJ = j;    }    k[k.length - 1] = n - lastJ;        UnivariateIntegrator integrator = new RombergIntegrator();    for (int i = 0; i < xs.length - 1; i++) {        double delta = integrator.integrate(1000000, new UnivariateFunction() {            @Override            public double value(double v) {                return dist.pdf(v);            }        }, xs[i], xs[i + 1]);        Assert.assertEquals(delta, p[i + 1], 1.0e-6);    }        double sum = 0;    for (int i = 0; i < k.length; i++) {        if (k[i] != 0) {            sum += k[i] * Math.log(k[i] / p[i] / n);        }    }    sum *= 2;        int dof = k.length - 1;        double z = Math.sqrt(2 * sum) - Math.sqrt(2 * dof - 1);    Assert.assertTrue(String.format("offset=%.3f scale=%.3f Z = %.1f", offset, scale, z), Math.abs(z) < 3);}
b962647da4c658ea38072a406c2fff66bf64c6a6a8b5ea13a5fe9f0bb1b7de6d
value
public double value(double v)
{    return dist.pdf(v);}
e920ccc343fee61c8f436f0c206d4c3561be30bbbf96fe8e655b18b116f922e4
checkCdf
 static void checkCdf(double offset, double scale, AbstractContinousDistribution dist, double[] breaks, double[] quantiles)
{    int i = 0;    for (double x : breaks) {        Assert.assertEquals(String.format("m=%.3f sd=%.3f x=%.3f", offset, scale, x), quantiles[i], dist.cdf(x * scale + offset), 1.0e-6);        i++;    }}
214865800fa5a361e26427bc0a2778dbfb99faeeddbb8d9908ffb7c234a560dc
toDouble
private static double toDouble(long y)
{    return (y & 0xffffffffL) * 2.3283064365386963e-10;}
0ee59bde03a93579f5795b8790370fff158e21c99d4123f6c1e023921cc7751d
test10001
public void test10001()
{    MersenneTwister r = new MersenneTwister();    r.setReferenceSeed(4357);        int i = 0;    for (long x : reference1) {        int y = r.nextInt();        assertEquals("t-ref-int-" + i, x, y);        i++;    }    r.setReferenceSeed(4357);    i = 0;    for (Double x : ref1) {        assertEquals("t-ref-double-" + i, x, toDouble(r.nextInt()), 1.0e-7);        i++;    }}
1216149c644b387ca0c53dd20809e67f088ebca1ab173ee7491d6fa781e74c8a
testRegression
public void testRegression()
{    RandomEngine r = new MersenneTwister(42);    int i = 0;    for (double x : reference3) {        assertEquals("t-regression-" + i, x, r.nextDouble(), 1.0e-7);        i++;    }}
685676ace40e597ab49e936eaa396db5e896533c1c52779544d91e721f1d641b
testDateConstructor
public void testDateConstructor()
{    RandomEngine r1 = new MersenneTwister(1275264362);    RandomEngine r2 = new MersenneTwister(new Date(1275264362));    for (int i = 0; i < 100; i++) {        assertEquals("date-" + i, r1.nextInt(), r2.nextInt());    }}
5993a64f3c27abbbe213ad4802bad07caac3cd022385fb78ccd9ad047d83ab51
consistency
public void consistency()
{    Exponential dist = new Exponential(1, RandomUtils.getRandom());        double[] breaks = { 0.1053605, 0.2231436, 0.3566749, 0.5108256, 0.6931472, 0.9162907, 1.2039728, 1.6094379, 2.3025851 };    for (double lambda : new double[] { 0.01, 0.1, 1, 2, 5, 100 }) {        dist.setState(lambda);        DistributionChecks.checkDistribution(dist, breaks, 0, 1 / lambda, 10000);    }}
27d76020e6e0d6328b0ca8493f197cdc6060578c523c193eac427cd969342d0b
testCdf
public void testCdf()
{    Exponential dist = new Exponential(5.0, RandomUtils.getRandom());    for (int i = 0; i < 1000; i++) {        double x = i / 50.0;        assertEquals(1 - Math.exp(-x * 5.0), dist.cdf(x), 1.0e-9);    }}
f5398e151574db7eb325512ad6e13077b52833823ff73ba42dc4fccae1108173
testPdf
public void testPdf()
{    checkPdf(new Exponential(13.0, null), 13.0);}
5a49bafe35789f583eab774c25cd3b5876d2d5be0a650dc0ce7a743b0ef98787
checkPdf
private static void checkPdf(Exponential dist, double lambda)
{    assertEquals(0, dist.pdf(-1), 0);    double sum = 0;    double dx = 0.001 / lambda;    for (double x = 0; x < 20 / lambda; x += dx) {        sum += x * dist.pdf(x) * dx;        assertEquals(Math.exp(-x * lambda) * lambda, dist.pdf(x), 1.0e-9);    }    assertEquals(1 / lambda, sum, 1.0e-6 / lambda);}
9328a4900c25d0d4cd0d417f0ea27138699424ff5e91ddff208dead6ef9f817a
testSetState
public void testSetState()
{    Exponential dist = new Exponential(13.0, null);    for (double lambda = 0.1; lambda < 1000; lambda *= 1.3) {        dist.setState(lambda);        checkPdf(dist, lambda);    }}
6ecd96d72c5da152749bdf351e12c9867aea13ebb04d7fa5bd9b47b7b7500373
testNextDouble
public void testNextDouble() throws Exception
{    double[] x = { -0.01, 0.1053605, 0.2231436, 0.3566749, 0.5108256, 0.6931472, 0.9162907, 1.2039728, 1.6094379, 2.3025851 };    Exponential dist = new Exponential(1, RandomUtils.getRandom());    for (double lambda : new double[] { 13.0, 0.02, 1.6 }) {        dist.setState(lambda);        checkEmpiricalDistribution(dist, 10000, lambda);        DistributionChecks.checkDistribution(dist, x, 0, 1 / lambda, 10000);    }}
38f7faca96128b3fc36c21406f7fdc8880e744fc912b831502b3a8acab655ddd
checkEmpiricalDistribution
private static void checkEmpiricalDistribution(Exponential dist, int n, double lambda)
{    double[] x = new double[n];    for (int i = 0; i < n; i++) {        x[i] = dist.nextDouble();    }    Arrays.sort(x);    for (int i = 0; i < n; i++) {        double cumulative = (double) i / (n - 1);        assertEquals(String.format("lambda = %.3f", lambda), cumulative, dist.cdf(x[i]), 0.02);    }}
cd89046fb8911fa4a6595be8ff9a8156398ebfad5d0c95e20ca6a68135c4b5d2
testToString
public void testToString()
{    assertEquals("org.apache.mahout.math.jet.random.Exponential(3.1000)", new Exponential(3.1, null).toString());    assertEquals("org.apache.mahout.math.jet.random.Exponential(3.1000)", new Exponential(3.1, null).toString());}
f56c1dc721baf4d964784211cc9f6ca9e952cbaa0e21f26752a2e61f71ef0a10
testNextDouble
public void testNextDouble()
{    double[] z = new double[100000];    Random gen = RandomUtils.getRandom();    for (double alpha : new double[] { 1, 2, 10, 0.1, 0.01, 100 }) {        Gamma g = new Gamma(alpha, 1, gen);        for (int i = 0; i < z.length; i++) {            z[i] = g.nextDouble();        }        Arrays.sort(z);                for (double q : seq(0.01, 1, 0.01)) {            double p = z[(int) (q * z.length)];            assertEquals(q, g.cdf(p), 0.01);        }    }}
27d76020e6e0d6328b0ca8493f197cdc6060578c523c193eac427cd969342d0b
testCdf
public void testCdf()
{    Random gen = RandomUtils.getRandom();        for (double beta : new double[] { 1, 0.1, 2, 100 }) {        Gamma g1 = new Gamma(1, beta, gen);        Gamma g2 = new Gamma(1, 1, gen);        for (double x : seq(0, 0.99, 0.1)) {            assertEquals(String.format(Locale.ENGLISH, "Rate invariance: x = %.4f, alpha = 1, beta = %.1f", x, beta), 1 - Math.exp(-x * beta), g1.cdf(x), 1.0e-9);            assertEquals(String.format(Locale.ENGLISH, "Rate invariance: x = %.4f, alpha = 1, beta = %.1f", x, beta), g2.cdf(beta * x), g1.cdf(x), 1.0e-9);        }    }        for (double alpha : new double[] { 0.01, 0.1, 1, 2, 10, 100, 1000 }) {        Gamma g = new Gamma(alpha, 1, gen);        for (double beta : new double[] { 0.1, 1, 2, 100 }) {            Gamma g1 = new Gamma(alpha, beta, gen);            for (double x : seq(0, 0.9999, 0.001)) {                assertEquals(String.format(Locale.ENGLISH, "Rate invariance: x = %.4f, alpha = %.2f, beta = %.1f", x, alpha, beta), g.cdf(x * beta), g1.cdf(x), 0);            }        }    }        checkGammaCdf(0.01, 1, 0.0000000, 0.9450896, 0.9516444, 0.9554919, 0.9582258, 0.9603474, 0.9620810, 0.9635462, 0.9648148, 0.9659329, 0.9669321);    checkGammaCdf(0.1, 1, 0.0000000, 0.7095387, 0.7591012, 0.7891072, 0.8107067, 0.8275518, 0.8413180, 0.8529198, 0.8629131, 0.8716623, 0.8794196);    checkGammaCdf(1, 1, 0.0000000, 0.1812692, 0.3296800, 0.4511884, 0.5506710, 0.6321206, 0.6988058, 0.7534030, 0.7981035, 0.8347011, 0.8646647);    checkGammaCdf(10, 1, 0.000000e+00, 4.649808e-05, 8.132243e-03, 8.392402e-02, 2.833757e-01, 5.420703e-01, 7.576078e-01, 8.906006e-01, 9.567017e-01, 9.846189e-01, 9.950046e-01);    checkGammaCdf(100, 1, 0.000000e+00, 3.488879e-37, 1.206254e-15, 1.481528e-06, 1.710831e-02, 5.132988e-01, 9.721363e-01, 9.998389e-01, 9.999999e-01, 1.000000e+00, 1.000000e+00);}
588c14ae5b8c1ace37f1323cfc99dd44c85d9da524687f767bfb39ec92f44d4c
checkGammaCdf
private static void checkGammaCdf(double alpha, double beta, double... values)
{    Gamma g = new Gamma(alpha, beta, RandomUtils.getRandom());    int i = 0;    for (double x : seq(0, 2 * alpha, 2 * alpha / 10)) {        assertEquals(String.format(Locale.ENGLISH, "alpha=%.2f, i=%d, x=%.2f", alpha, i, x), values[i], g.cdf(x), 1.0e-7);        i++;    }}
3c85ee4cfba2a77c8ad7b96b3869e48e99af9ca1cae21f59be65f7979a3cedf2
seq
private static double[] seq(double from, double to, double by)
{    double[] r = new double[(int) Math.ceil(0.999999 * (to - from) / by)];    int i = 0;    for (double x = from; x < to - (to - from) * 1.0e-6; x += by) {        r[i++] = x;    }    return r;}
f5398e151574db7eb325512ad6e13077b52833823ff73ba42dc4fccae1108173
testPdf
public void testPdf()
{    Random gen = RandomUtils.getRandom();    for (double alpha : new double[] { 0.01, 0.1, 1, 2, 10, 100 }) {        for (double beta : new double[] { 0.1, 1, 2, 100 }) {            Gamma g1 = new Gamma(alpha, beta, gen);            for (double x : seq(0, 0.99, 0.1)) {                double p = Math.pow(beta, alpha) * Math.pow(x, alpha - 1) * Math.exp(-beta * x - org.apache.mahout.math.jet.stat.Gamma.logGamma(alpha));                assertEquals(String.format(Locale.ENGLISH, "alpha=%.2f, beta=%.2f, x=%.2f\n", alpha, beta, x), p, g1.pdf(x), 1.0e-9);            }        }    }}
d445d039c567561f59a9679ee569a2138ebd50f9e999592fb42385b14b6a8aac
testDistributionFunctions
public void testDistributionFunctions() throws Exception
{    InputSupplier<InputStreamReader> input = Resources.newReaderSupplier(Resources.getResource("negative-binomial-test-data.csv"), Charsets.UTF_8);    boolean header = true;    for (String line : CharStreams.readLines(input)) {        if (header) {                        header = false;        } else {            Iterable<String> values = onComma.split(line);            int k = Integer.parseInt(Iterables.get(values, 0));            double p = Double.parseDouble(Iterables.get(values, 1));            int r = Integer.parseInt(Iterables.get(values, 2));            double density = Double.parseDouble(Iterables.get(values, 3));            double cume = Double.parseDouble(Iterables.get(values, 4));            NegativeBinomial nb = new NegativeBinomial(r, p, RandomUtils.getRandom());            assertEquals("cumulative " + k + ',' + p + ',' + r, cume, nb.cdf(k), cume * 1.0e-5);            assertEquals("density " + k + ',' + p + ',' + r, density, nb.pdf(k), density * 1.0e-5);        }    }}
27d76020e6e0d6328b0ca8493f197cdc6060578c523c193eac427cd969342d0b
testCdf
public void testCdf()
{    Random gen = RandomUtils.getRandom();    double offset = 0;    double scale = 1;    for (int k = 0; k < 20; k++) {        Normal dist = new Normal(offset, scale, null);        DistributionChecks.checkCdf(offset, scale, dist, breaks, quantiles);        offset = gen.nextGaussian();        scale = Math.exp(3 * gen.nextGaussian());    }}
5993a64f3c27abbbe213ad4802bad07caac3cd022385fb78ccd9ad047d83ab51
consistency
public void consistency()
{    Random gen = RandomUtils.getRandom();    double offset = 0;    double scale = 1;    Normal dist = new Normal(offset, scale, RandomUtils.getRandom());    for (int k = 0; k < 20; k++) {        dist.setState(offset, scale);        DistributionChecks.checkDistribution(dist, breaks, offset, scale, 10000);        offset = gen.nextGaussian();        scale = Math.exp(3 * gen.nextGaussian());    }}
7ef217272744b0f4a96706638e8bd1610a7340ae005b615748b57dfac260f3f1
testSetState
public void testSetState() throws Exception
{    Normal dist = new Normal(0, 1, RandomUtils.getRandom());    dist.setState(1.3, 5.9);    DistributionChecks.checkDistribution(dist, breaks, 1.3, 5.9, 10000);}
cd89046fb8911fa4a6595be8ff9a8156398ebfad5d0c95e20ca6a68135c4b5d2
testToString
public void testToString()
{    assertEquals("org.apache.mahout.math.jet.random.Normal(m=1.300000, sd=5.900000)", new Normal(1.3, 5.9, null).toString());}
4639bc81649184bf71736f1364d2c56e2ee2b3248c872cc605afb8afe62c839d
testGamma
public void testGamma()
{    double[] x = { 1, 2, 5, 10, 20, 50, 100 };    double[] expected = { 1.000000e+00, 1.000000e+00, 2.400000e+01, 3.628800e+05, 1.216451e+17, 6.082819e+62, 9.332622e+155 };    for (int i = 0; i < x.length; i++) {        assertEquals(expected[i], Gamma.gamma(x[i]), expected[i] * 1.0e-5);        assertEquals(gammaInteger(x[i]), Gamma.gamma(x[i]), expected[i] * 1.0e-5);        assertEquals(gammaInteger(x[i]), Math.exp(Gamma.logGamma(x[i])), expected[i] * 1.0e-5);    }}
ed7287da8b1ab28b1a828feb760d21ea377f9467d5ecb7eb8acb9f223a090c0b
testNegativeArgForGamma
public void testNegativeArgForGamma()
{    double[] x = { -30.3, -20.7, -10.5, -1.1, 0.5, 0.99, -0.999 };    double[] expected = { -5.243216e-33, -1.904051e-19, -2.640122e-07, 9.714806e+00, 1.772454e+00, 1.005872e+00, -1.000424e+03 };    for (int i = 0; i < x.length; i++) {        assertEquals(expected[i], Gamma.gamma(x[i]), Math.abs(expected[i] * 1.0e-5));        assertEquals(Math.abs(expected[i]), Math.abs(Math.exp(Gamma.logGamma(x[i]))), Math.abs(expected[i] * 1.0e-5));    }}
bfb39b19fdc92fed490c81eed895882f3cb1f79f08f1b6757f9d89d550aaed97
gammaInteger
private static double gammaInteger(double x)
{    double r = 1;    for (int i = 2; i < x; i++) {        r *= i;    }    return r;}
c51bd694fba12a551ae47b277b90bc9a675aec0a9327b77ebd6c225d75da9e6b
testBigX
public void testBigX()
{    assertEquals(factorial(4), 4 * 3 * 2, 0);    assertEquals(factorial(4), Gamma.gamma(5), 0);    assertEquals(factorial(14), Gamma.gamma(15), 0);    assertEquals(factorial(34), Gamma.gamma(35), 1.0e-15 * factorial(34));    assertEquals(factorial(44), Gamma.gamma(45), 1.0e-15 * factorial(44));    assertEquals(-6.884137e-40 + 3.508309e-47, Gamma.gamma(-35.1), 1.0e-52);    assertEquals(-3.915646e-41 - 3.526813e-48 - 1.172516e-55, Gamma.gamma(-35.9), 1.0e-52);    assertEquals(-2000000000.577215, Gamma.gamma(-0.5e-9), 1.0e-15 * 2000000000.577215);    assertEquals(1999999999.422784, Gamma.gamma(0.5e-9), 1.0e-15 * 1999999999.422784);    assertEquals(1.324296658017984e+252, Gamma.gamma(146.1), 1.0e-10 * 1.324296658017984e+252);    for (double x : new double[] { 5, 15, 35, 45, -35.1, -35.9, -0.5e-9, 0.5e-9, 146.1 }) {        double ref = Math.log(Math.abs(Gamma.gamma(x)));        double actual = Gamma.logGamma(x);        double diff = Math.abs(ref - actual) / ref;        assertEquals("gamma versus logGamma at " + x + " (diff = " + diff + ')', 0, (ref - actual) / ref, 1.0e-8);    }}
88e554ec1df5c0b20e2041a59b61be45c905d70686b2a7711d087675a470d425
factorial
private static double factorial(int n)
{    double r = 1;    for (int i = 2; i <= n; i++) {        r *= i;    }    return r;}
00da244c0b37575da6b2c2e04d9601db3962812aecfdfa834078c9da9d376aef
beta
public void beta()
{    Random r = RandomUtils.getRandom();    for (int i = 0; i < 200; i++) {        double alpha = -50 * Math.log1p(-r.nextDouble());        double beta = -50 * Math.log1p(-r.nextDouble());        double ref = Math.exp(Gamma.logGamma(alpha) + Gamma.logGamma(beta) - Gamma.logGamma(alpha + beta));        double actual = Gamma.beta(alpha, beta);        double err = (ref - actual) / ref;        assertEquals("beta at (" + alpha + ", " + beta + ") relative error = " + err, 0, err, 1.0e-10);    }}
48ff136c6c06235ad7f88fb93eb79d4fe6a0c8e7042462cb5ee27c512eb7cf16
incompleteBeta
public void incompleteBeta() throws IOException
{    Splitter onComma = Splitter.on(",").trimResults();    InputSupplier<InputStreamReader> input = Resources.newReaderSupplier(Resources.getResource("beta-test-data.csv"), Charsets.UTF_8);    boolean header = true;    for (String line : CharStreams.readLines(input)) {        if (header) {                        header = false;        } else {            Iterable<String> values = onComma.split(line);            double alpha = Double.parseDouble(Iterables.get(values, 0));            double beta = Double.parseDouble(Iterables.get(values, 1));            double x = Double.parseDouble(Iterables.get(values, 2));            double ref = Double.parseDouble(Iterables.get(values, 3));            double actual = Gamma.incompleteBeta(alpha, beta, x);            assertEquals(alpha + "," + beta + ',' + x, ref, actual, ref * 1.0e-5);        }    }}
f8719ebc33a23c1a8350d768b68888bc762eb4de9217fe155e66a88f5c31debb
testNormalCdf
public void testNormalCdf()
{            double[] ref = { 2.866516e-07, 4.816530e-07, 8.013697e-07, 1.320248e-06, 2.153811e-06, 3.479323e-06, 5.565743e-06, 8.816559e-06, 1.383023e-05, 2.148428e-05, 3.305072e-05, 5.035210e-05, 7.596947e-05, 1.135152e-04, 1.679855e-04, 2.462079e-04, 3.574003e-04, 5.138562e-04, 7.317683e-04, 1.032198e-03, 1.442193e-03, 1.996034e-03, 2.736602e-03, 3.716808e-03, 5.001037e-03, 6.666521e-03, 8.804535e-03, 1.152131e-02, 1.493850e-02, 1.919309e-02, 2.443656e-02, 3.083320e-02, 3.855748e-02, 4.779035e-02, 5.871452e-02, 7.150870e-02, 8.634102e-02, 1.033618e-01, 1.226957e-01, 1.444345e-01, 1.686293e-01, 1.952845e-01, 2.243525e-01, 2.557301e-01, 2.892574e-01, 3.247181e-01, 3.618436e-01, 4.003175e-01, 4.397847e-01, 4.798600e-01, 5.201400e-01, 5.602153e-01, 5.996825e-01, 6.381564e-01, 6.752819e-01, 7.107426e-01, 7.442699e-01, 7.756475e-01, 8.047155e-01, 8.313707e-01, 8.555655e-01, 8.773043e-01, 8.966382e-01, 9.136590e-01, 9.284913e-01, 9.412855e-01, 9.522096e-01, 9.614425e-01, 9.691668e-01, 9.755634e-01, 9.808069e-01, 9.850615e-01, 9.884787e-01, 9.911955e-01, 9.933335e-01, 9.949990e-01, 9.962832e-01, 9.972634e-01, 9.980040e-01, 9.985578e-01, 9.989678e-01, 9.992682e-01, 9.994861e-01, 9.996426e-01, 9.997538e-01, 9.998320e-01, 9.998865e-01, 9.999240e-01, 9.999496e-01, 9.999669e-01, 9.999785e-01, 9.999862e-01, 9.999912e-01, 9.999944e-01, 9.999965e-01, 9.999978e-01, 9.999987e-01, 9.999992e-01, 9.999995e-01, 9.999997e-01 };    assertEquals(0.682689492137 / 2 + 0.5, Probability.normal(1), 1.0e-7);    int i = 0;    for (double x = -5; x <= 5.005; x += 10.0 / 99) {        assertEquals("Test 1 cdf function at " + x, ref[i], Probability.normal(x), 1.0e-6);        assertEquals("Test 2 cdf function at " + x, ref[i], Probability.normal(12, 1, x + 12), 1.0e-6);        assertEquals("Test 3 cdf function at " + x, ref[i], Probability.normal(12, 0.25, x / 2.0 + 12), 1.0e-6);        i++;    }}
5bac8665b7cbacdaa606d60f9f214b8bf3485bcf2344038eb0b321cb91b6f167
testBetaCdf
public void testBetaCdf()
{                            double[][] ref = new double[5][];    ref[0] = new double[] { 0.00000000, 0.01010101, 0.02020202, 0.03030303, 0.04040404, 0.05050505, 0.06060606, 0.07070707, 0.08080808, 0.09090909, 0.10101010, 0.11111111, 0.12121212, 0.13131313, 0.14141414, 0.15151515, 0.16161616, 0.17171717, 0.18181818, 0.19191919, 0.20202020, 0.21212121, 0.22222222, 0.23232323, 0.24242424, 0.25252525, 0.26262626, 0.27272727, 0.28282828, 0.29292929, 0.30303030, 0.31313131, 0.32323232, 0.33333333, 0.34343434, 0.35353535, 0.36363636, 0.37373737, 0.38383838, 0.39393939, 0.40404040, 0.41414141, 0.42424242, 0.43434343, 0.44444444, 0.45454545, 0.46464646, 0.47474747, 0.48484848, 0.49494949, 0.50505051, 0.51515152, 0.52525253, 0.53535354, 0.54545455, 0.55555556, 0.56565657, 0.57575758, 0.58585859, 0.59595960, 0.60606061, 0.61616162, 0.62626263, 0.63636364, 0.64646465, 0.65656566, 0.66666667, 0.67676768, 0.68686869, 0.69696970, 0.70707071, 0.71717172, 0.72727273, 0.73737374, 0.74747475, 0.75757576, 0.76767677, 0.77777778, 0.78787879, 0.79797980, 0.80808081, 0.81818182, 0.82828283, 0.83838384, 0.84848485, 0.85858586, 0.86868687, 0.87878788, 0.88888889, 0.89898990, 0.90909091, 0.91919192, 0.92929293, 0.93939394, 0.94949495, 0.95959596, 0.96969697, 0.97979798, 0.98989899, 1.00000000 };    ref[1] = new double[] { 0.0000000000, 0.0001020304, 0.0004081216, 0.0009182736, 0.0016324865, 0.0025507601, 0.0036730946, 0.0049994898, 0.0065299459, 0.0082644628, 0.0102030405, 0.0123456790, 0.0146923783, 0.0172431385, 0.0199979594, 0.0229568411, 0.0261197837, 0.0294867871, 0.0330578512, 0.0368329762, 0.0408121620, 0.0449954086, 0.0493827160, 0.0539740843, 0.0587695133, 0.0637690032, 0.0689725538, 0.0743801653, 0.0799918376, 0.0858075707, 0.0918273646, 0.0980512193, 0.1044791348, 0.1111111111, 0.1179471483, 0.1249872462, 0.1322314050, 0.1396796245, 0.1473319049, 0.1551882461, 0.1632486481, 0.1715131109, 0.1799816345, 0.1886542190, 0.1975308642, 0.2066115702, 0.2158963371, 0.2253851648, 0.2350780533, 0.2449750026, 0.2550760127, 0.2653810836, 0.2758902153, 0.2866034078, 0.2975206612, 0.3086419753, 0.3199673503, 0.3314967860, 0.3432302826, 0.3551678400, 0.3673094582, 0.3796551372, 0.3922048771, 0.4049586777, 0.4179165391, 0.4310784614, 0.4444444444, 0.4580144883, 0.4717885930, 0.4857667585, 0.4999489848, 0.5143352719, 0.5289256198, 0.5437200286, 0.5587184981, 0.5739210285, 0.5893276196, 0.6049382716, 0.6207529844, 0.6367717580, 0.6529945924, 0.6694214876, 0.6860524436, 0.7028874605, 0.7199265381, 0.7371696766, 0.7546168758, 0.7722681359, 0.7901234568, 0.8081828385, 0.8264462810, 0.8449137843, 0.8635853484, 0.8824609734, 0.9015406591, 0.9208244057, 0.9403122130, 0.9600040812, 0.9799000102, 1.0000000000 };    ref[2] = new double[] { 0.000000000, 0.001489698, 0.005799444, 0.012698382, 0.021966298, 0.033393335, 0.046779694, 0.061935356, 0.078679798, 0.096841712, 0.116258735, 0.136777178, 0.158251755, 0.180545326, 0.203528637, 0.227080061, 0.251085352, 0.275437393, 0.300035957, 0.324787463, 0.349604743, 0.374406809, 0.399118623, 0.423670875, 0.447999763, 0.472046772, 0.495758466, 0.519086275, 0.541986291, 0.564419069, 0.586349424, 0.607746242, 0.628582288, 0.648834019, 0.668481403, 0.687507740, 0.705899486, 0.723646086, 0.740739801, 0.757175549, 0.772950746, 0.788065147, 0.802520695, 0.816321377, 0.829473074, 0.841983426, 0.853861691, 0.865118615, 0.875766302, 0.885818092, 0.895288433, 0.904192771, 0.912547431, 0.920369513, 0.927676778, 0.934487554, 0.940820632, 0.946695177, 0.952130629, 0.957146627, 0.961762916, 0.965999275, 0.969875437, 0.973411020, 0.976625460, 0.979537944, 0.982167353, 0.984532203, 0.986650598, 0.988540173, 0.990218056, 0.991700827, 0.993004475, 0.994144371, 0.995135237, 0.995991117, 0.996725360, 0.997350600, 0.997878739, 0.998320942, 0.998687627, 0.998988463, 0.999232371, 0.999427531, 0.999581387, 0.999700663, 0.999791377, 0.999858864, 0.999907798, 0.999942219, 0.999965567, 0.999980718, 0.999990021, 0.999995342, 0.999998111, 0.999999376, 0.999999851, 0.999999980, 0.999999999, 1.000000000 };    ref[3] = new double[] { 0.0000000, 0.5858072, 0.6684658, 0.7201859, 0.7578936, 0.7873991, 0.8114552, 0.8316029, 0.8487998, 0.8636849, 0.8767081, 0.8881993, 0.8984080, 0.9075280, 0.9157131, 0.9230876, 0.9297536, 0.9357958, 0.9412856, 0.9462835, 0.9508414, 0.9550044, 0.9588113, 0.9622963, 0.9654896, 0.9684178, 0.9711044, 0.9735707, 0.9758356, 0.9779161, 0.9798276, 0.9815839, 0.9831977, 0.9846805, 0.9860426, 0.9872936, 0.9884422, 0.9894965, 0.9904638, 0.9913509, 0.9921638, 0.9929085, 0.9935900, 0.9942134, 0.9947832, 0.9953034, 0.9957779, 0.9962104, 0.9966041, 0.9969621, 0.9972872, 0.9975821, 0.9978492, 0.9980907, 0.9983088, 0.9985055, 0.9986824, 0.9988414, 0.9989839, 0.9991113, 0.9992251, 0.9993265, 0.9994165, 0.9994963, 0.9995668, 0.9996288, 0.9996834, 0.9997311, 0.9997727, 0.9998089, 0.9998401, 0.9998671, 0.9998901, 0.9999098, 0.9999265, 0.9999406, 0.9999524, 0.9999622, 0.9999703, 0.9999769, 0.9999823, 0.9999866, 0.9999900, 0.9999927, 0.9999947, 0.9999963, 0.9999975, 0.9999983, 0.9999989, 0.9999993, 0.9999996, 0.9999998, 0.9999999, 0.9999999, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000, 1.0000000 };    ref[4] = new double[] { 0.00000000, 0.01908202, 0.02195656, 0.02385194, 0.02530810, 0.02650923, 0.02754205, 0.02845484, 0.02927741, 0.03002959, 0.03072522, 0.03137444, 0.03198487, 0.03256240, 0.03311171, 0.03363655, 0.03414001, 0.03462464, 0.03509259, 0.03554568, 0.03598550, 0.03641339, 0.03683054, 0.03723799, 0.03763667, 0.03802739, 0.03841091, 0.03878787, 0.03915890, 0.03952453, 0.03988529, 0.04024162, 0.04059396, 0.04094272, 0.04128827, 0.04163096, 0.04197113, 0.04230909, 0.04264515, 0.04297958, 0.04331268, 0.04364471, 0.04397592, 0.04430658, 0.04463693, 0.04496722, 0.04529770, 0.04562860, 0.04596017, 0.04629265, 0.04662629, 0.04696134, 0.04729804, 0.04763666, 0.04797747, 0.04832073, 0.04866673, 0.04901578, 0.04936816, 0.04972422, 0.05008428, 0.05044871, 0.05081789, 0.05119222, 0.05157213, 0.05195809, 0.05235059, 0.05275018, 0.05315743, 0.05357298, 0.05399753, 0.05443184, 0.05487673, 0.05533315, 0.05580212, 0.05628480, 0.05678247, 0.05729660, 0.05782885, 0.05838111, 0.05895557, 0.05955475, 0.06018161, 0.06083965, 0.06153300, 0.06226670, 0.06304685, 0.06388102, 0.06477877, 0.06575235, 0.06681788, 0.06799717, 0.06932077, 0.07083331, 0.07260394, 0.07474824, 0.07748243, 0.08129056, 0.08771055, 1.00000000 };    double[] alpha = { 1.0, 2.0, 2.0, 0.2, 0.2 };    double[] beta = { 1.0, 1.0, 5.0, 5.0, 0.01 };    for (int j = 0; j < 4; j++) {        for (int i = 0; i < 100; i++) {            double x = i / 99.0;            String p = String.format(Locale.ENGLISH, "pbeta(q=%6.4f, shape1=%5.3f shape2=%5.3f) = %.8f", x, alpha[j], beta[j], ref[j][i]);            assertEquals(p, ref[j][i], Probability.beta(alpha[j], beta[j], x), 1.0e-7);        }    }}
a1cfae0d94ae81bfe1cf8877da2f13a5f60066bda9afbe25d1028bc728f8d3d7
testLogGamma
public void testLogGamma()
{    double[] xValues = { 1.1, 2.1, 3.1, 4.1, 5.1, 20.1, 100.1, -0.9 };    double[] ref = { -0.04987244, 0.04543774, 0.78737508, 1.91877719, 3.32976417, 39.63719250, 359.59427179, 2.35807317 };    for (int i = 0; i < xValues.length; i++) {        double x = xValues[i];        assertEquals(ref[i], Gamma.logGamma(x), 1.0e-7);    }}
6479980257ced9826c4d116c0c04a4c75c55698dc78d279302d225ce229b911b
emptyOnCreation
public void emptyOnCreation()
{    ObjectArrayList<String> list = new ObjectArrayList<>();    assertTrue(list.isEmpty());    assertEquals(0, list.size());    list.add("1");    list.add("2");    list.add("3");    assertEquals(3, list.size());}
7f251fce5e015ce4392f5b12dfd8ee39d20aa364cb93ec6042edf6542e7772c4
correctSizeAfterInstantiation
public void correctSizeAfterInstantiation()
{    ObjectArrayList<String> list = new ObjectArrayList<>(100);    assertTrue(list.isEmpty());    assertEquals(0, list.size());}
24928368c8f7e855ebe33ffdf9b7f352f350409c55b62e0ac1f441728ed2b911
correctSizeAfterInstantiationWithElements
public void correctSizeAfterInstantiationWithElements()
{    ObjectArrayList<String> list = new ObjectArrayList<>(new String[] { "1", "2", "3" });    assertFalse(list.isEmpty());    assertEquals(3, list.size());}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    testTempDir = null;    RandomUtils.useTestSeed();}
c6aaebb5a52567751db8dc8e1cb9dd4a4e582ef964a374b376c6a04f741802dc
tearDown
public void tearDown() throws Exception
{    if (testTempDir != null) {        new DeletingVisitor().accept(testTempDir);    }}
0cfe39b60d6e5c171bbecbb2533284307c54c946bbe9efbc4007a4208f3edaae
getTestTempDir
protected final File getTestTempDir() throws IOException
{    if (testTempDir == null) {        String systemTmpDir = System.getProperty("mahout.test.directory");        if (systemTmpDir == null) {            systemTmpDir = "target/";            systemTmpDir += "test-data";        }        long simpleRandomLong = (long) (Long.MAX_VALUE * Math.random());        testTempDir = new File(systemTmpDir, "mahout-" + getClass().getSimpleName() + '-' + simpleRandomLong);        if (!testTempDir.mkdirs()) {            throw new IOException("Could not create " + testTempDir);        }        testTempDir.deleteOnExit();    }    return testTempDir;}
ef3362e26cf459c25449cd918c5c50456d0fe2306b48ee91215d5c5d89d7cad4
getTestTempFile
protected final File getTestTempFile(String name) throws IOException
{    return getTestTempFileOrDir(name, false);}
c55cf462942368450123a06beb48410f6f2b52b0bd99f722022a964cd840c82f
getTestTempDir
protected final File getTestTempDir(String name) throws IOException
{    return getTestTempFileOrDir(name, true);}
5d2f97027e1af8c36458c81028701c13ce0d8c31ebf77e075881dd607b873584
getTestTempFileOrDir
private File getTestTempFileOrDir(String name, boolean dir) throws IOException
{    File f = new File(getTestTempDir(), name);    f.deleteOnExit();    if (dir && !f.mkdirs()) {        throw new IOException("Could not make directory " + f);    }    return f;}
3ddf4adf2e073ddb34da50750ea2111be644970e4e68cdd43b1513e259bba38b
accept
public boolean accept(File f)
{    if (!f.isFile()) {        f.listFiles(this);    }    f.delete();    return false;}
10a3096d8ebce98db5580c967758c661e439370ac0948137e19554fae6bba99b
testFunctionalView
public void testFunctionalView()
{    Matrix m = Matrices.functionalMatrixView(5, 6, new IntIntFunction() {        @Override        public double apply(int row, int col) {            assertTrue(row < 5);            assertTrue(col < 6);            return row + col;        }    });            assertEquals(135, m.aggregate(Functions.PLUS, Functions.IDENTITY), 1e-10);}
d879330f98f62f3fb9b4c36b8d0521bc8a7204290db6966699db9e1bc0835819
apply
public double apply(int row, int col)
{    assertTrue(row < 5);    assertTrue(col < 6);    return row + col;}
0a3d971720479ea03148e3d3db1250782c3e5a6144860e16f599db26b43afe1b
testTransposeView
public void testTransposeView()
{    Matrix m = Matrices.gaussianView(5, 6, 1234L);    Matrix controlM = new DenseMatrix(5, 6).assign(m);    System.out.printf("M=\n%s\n", m);    System.out.printf("controlM=\n%s\n", controlM);    Matrix mtm = Matrices.transposedView(m).times(m);    Matrix controlMtm = controlM.transpose().times(controlM);    System.out.printf("M'M=\n%s\n", mtm);    Matrix diff = mtm.minus(controlMtm);    assertEquals(0, diff.aggregate(Functions.PLUS, Functions.ABS), 1e-10);}
2f2ff08317bb735432fb6a9170d96c41a278676dd3d4b401c76ff7d9f7c2fa93
testViewDenseSparseReporting
public void testViewDenseSparseReporting()
{    Matrix m = new SparseMatrix(1000, 1000);    m.set(1, 1, 33.0);    Matrix mt = Matrices.transposedView(m);    assertTrue(mt.viewColumn(0).isDense() == m.viewRow(0).isDense());    assertTrue(mt.viewRow(0).isDense() == m.viewColumn(0).isDense());    m = new DenseMatrix(10, 10);    m.set(1, 1, 33.0);    mt = Matrices.transposedView(m);    assertTrue(mt.viewColumn(0).isDense());    assertTrue(mt.viewRow(0).isDense());}
1bdfe0ece41ba4396ee248e03a5e48070099548db27e2e345d39b48f80c493d2
testUniformView
public void testUniformView()
{    Matrix m1 = Matrices.uniformView(5, 6, 1234);    Matrix m2 = Matrices.uniformView(5, 6, 1234);    for (int row = 0; row < m1.numRows(); row++) {        for (int col = 0; col < m1.numCols(); col++) {            assertTrue(m1.getQuick(row, col) >= 0.0);            assertTrue(m1.getQuick(row, col) < 1.0);        }    }    Matrix diff = m1.minus(m2);    assertEquals(0, diff.aggregate(Functions.PLUS, Functions.ABS), 1e-10);}
6ea12b65184299ce0d6268f1cfcfe5b87e1d09af630ca1bb43d9889292c9cb19
testSymmetricUniformView
public void testSymmetricUniformView()
{    Matrix m1 = Matrices.symmetricUniformView(5, 6, 1234);    Matrix m2 = Matrices.symmetricUniformView(5, 6, 1234);    for (int row = 0; row < m1.numRows(); row++) {        for (int col = 0; col < m1.numCols(); col++) {            assertTrue(m1.getQuick(row, col) >= -1.0);            assertTrue(m1.getQuick(row, col) < 1.0);        }    }    Matrix diff = m1.minus(m2);    assertEquals(0, diff.aggregate(Functions.PLUS, Functions.ABS), 1e-10);}
218423afa1e7c455c575794df35ca84948d34fffdaaaf15446259e6cb0885974
testGaussianView
public void testGaussianView()
{    Matrix m1 = Matrices.gaussianView(5, 6, 1234);    Matrix m2 = Matrices.gaussianView(5, 6, 1234);    Matrix diff = m1.minus(m2);    assertEquals(0, diff.aggregate(Functions.PLUS, Functions.ABS), 1e-10);}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    super.setUp();    test = matrixFactory(values);}
c33b5dd3bcce18c13e0fc227426607645a76017e12386af96c7a2aa83d9ee23e
testCardinality
public void testCardinality()
{    assertEquals("row cardinality", values.length, test.rowSize());    assertEquals("col cardinality", values[0].length, test.columnSize());}
19ec40c009197b5a6fe460894a6d8b81a86c3a767ab9b25cf5bef672c9490804
testCopy
public void testCopy()
{    Matrix copy = test.clone();    assertSame("wrong class", copy.getClass(), test.getClass());    for (int row = 0; row < test.rowSize(); row++) {        for (int col = 0; col < test.columnSize(); col++) {            assertEquals("value[" + row + "][" + col + ']', test.getQuick(row, col), copy.getQuick(row, col), EPSILON);        }    }}
96c2a1fe93d778b1d5e6b1e73fdf173e59b3a9a00d81960d19645fbb20713b7f
testClone
public void testClone()
{    double oldValue = 1.23;    double newValue = 2.34;    double[][] values = { { oldValue, 3 }, { 3, 5 }, { 7, 9 } };    Matrix matrix = matrixFactory(values);    Matrix clone = matrix.clone();    clone.set(0, 0, newValue);        assertEquals("Matrix clone is not independent of the original", oldValue, matrix.get(0, 0), EPSILON);}
febcc76e4c7f6175ca37b08e1443727e72951c1a57c5dacfb843f3f0e1d3e3f2
testIterate
public void testIterate()
{    Iterator<MatrixSlice> it = test.iterator();    MatrixSlice m;    while (it.hasNext() && (m = it.next()) != null) {        Vector v = m.vector();        Vector w = test instanceof SparseColumnMatrix ? test.viewColumn(m.index()) : test.viewRow(m.index());        assertEquals("iterator: " + v + ", randomAccess: " + w, v, w);    }}
d546c9b270424486c7e10eacc840c277a54db45a1e5176cbb35a6a0057b5f647
testGetQuick
public void testGetQuick()
{    for (int row = 0; row < test.rowSize(); row++) {        for (int col = 0; col < test.columnSize(); col++) {            assertEquals("value[" + row + "][" + col + ']', values[row][col], test.getQuick(row, col), EPSILON);        }    }}
2c7b313449cf9e1b2ee07116dc147fbec7041da5bdb74d5e94517b5b4e80a41d
testLike
public void testLike()
{    Matrix like = test.like();    assertSame("type", like.getClass(), test.getClass());    assertEquals("rows", test.rowSize(), like.rowSize());    assertEquals("columns", test.columnSize(), like.columnSize());}
617c452474198fc10ba372a3de9a46c6d8069422b50b699f84fd9e0bd9a84cb1
testLikeIntInt
public void testLikeIntInt()
{    Matrix like = test.like(4, 4);    assertSame("type", like.getClass(), test.getClass());    assertEquals("rows", 4, like.rowSize());    assertEquals("columns", 4, like.columnSize());}
18d625f42e8350d651706d856562c6afbf85dd8d877e63e3b575b06dac7d77aa
testSetQuick
public void testSetQuick()
{    for (int row = 0; row < test.rowSize(); row++) {        for (int col = 0; col < test.columnSize(); col++) {            test.setQuick(row, col, 1.23);            assertEquals("value[" + row + "][" + col + ']', 1.23, test.getQuick(row, col), EPSILON);        }    }}
4418db934d4155c558cef1530654d1053ddcdb06e41cedabef91b0a8f1be57e3
testSize
public void testSize()
{    int[] c = test.getNumNondefaultElements();    assertEquals("row size", values.length, c[ROW]);    assertEquals("col size", values[0].length, c[COL]);}
1c256c64ddf7fdeeb2b34b7b41ccfce50c9ab448e937bd3fd0b1b5e12432ccee
testViewPart
public void testViewPart()
{    int[] offset = { 1, 1 };    int[] size = { 2, 1 };    Matrix view = test.viewPart(offset, size);    assertEquals(2, view.rowSize());    assertEquals(1, view.columnSize());    for (int row = 0; row < view.rowSize(); row++) {        for (int col = 0; col < view.columnSize(); col++) {            assertEquals("value[" + row + "][" + col + ']', values[row + 1][col + 1], view.get(row, col), EPSILON);        }    }}
9782d0b1be5c79cd5acde7629da4a6ced62d6962e4daf248107dc51c765b499a
testViewPartCardinality
public void testViewPartCardinality()
{    int[] offset = { 1, 1 };    int[] size = { 3, 3 };    test.viewPart(offset, size);}
9c212b20847f8cc1441d1b885a5b038101fdd02581f706d8f6eaed41aae114a6
testViewPartIndexOver
public void testViewPartIndexOver()
{    int[] offset = { 1, 1 };    int[] size = { 2, 2 };    test.viewPart(offset, size);}
8d4a60107f5c65978ca086c14b316e967e7ce777723985b673ca1fba885351dc
testViewPartIndexUnder
public void testViewPartIndexUnder()
{    int[] offset = { -1, -1 };    int[] size = { 2, 2 };    test.viewPart(offset, size);}
07c65eca6c2899b6c6bf730af78fe73d5534ea70fe59cbaed1a9fbe47cbe39f6
testAssignDouble
public void testAssignDouble()
{    test.assign(4.53);    for (int row = 0; row < test.rowSize(); row++) {        for (int col = 0; col < test.columnSize(); col++) {            assertEquals("value[" + row + "][" + col + ']', 4.53, test.getQuick(row, col), EPSILON);        }    }}
aa599f36764ba96b6dab2f967f8f6bf7ef28272531e2e118d8c363224ef8bb9f
testAssignDoubleArrayArray
public void testAssignDoubleArrayArray()
{    test.assign(new double[3][2]);    for (int row = 0; row < test.rowSize(); row++) {        for (int col = 0; col < test.columnSize(); col++) {            assertEquals("value[" + row + "][" + col + ']', 0.0, test.getQuick(row, col), EPSILON);        }    }}
7eebb702d308132ed2b16c68e6e8c1acfb4b3c5af13db695f0da905eacee5a69
testAssignDoubleArrayArrayCardinality
public void testAssignDoubleArrayArrayCardinality()
{    test.assign(new double[test.rowSize() + 1][test.columnSize()]);}
f6050e99f6f6d19b418cad6fcb9c6d7935537242eb9a73af27327dd0946f61bd
testMatrixViewBug
public void testMatrixViewBug()
{    Matrix m = test.viewPart(0, 3, 0, 2);        m = m.viewPart(2, 1, 0, 1);    assertEquals(5.5, m.zSum(), 0);}
dba96aeb49319fcc5337e36e070d2cfa1a2523a6c0ae51378c5b349dc7829b4f
testAssignMatrixBinaryFunction
public void testAssignMatrixBinaryFunction()
{    test.assign(test, Functions.PLUS);    for (int row = 0; row < test.rowSize(); row++) {        for (int col = 0; col < test.columnSize(); col++) {            assertEquals("value[" + row + "][" + col + ']', 2 * values[row][col], test.getQuick(row, col), EPSILON);        }    }}
daf61bc655196e81fa93db84df8db2d173fefff24639d105a80a24c6ffbf362f
testAssignMatrixBinaryFunctionCardinality
public void testAssignMatrixBinaryFunctionCardinality()
{    test.assign(test.transpose(), Functions.PLUS);}
9fe3ccc6009677054e35e33afa20c4da3ce7cdf326e04b72cda9ced65fa3077b
testAssignMatrix
public void testAssignMatrix()
{    Matrix value = test.like();    value.assign(test);    for (int row = 0; row < test.rowSize(); row++) {        for (int col = 0; col < test.columnSize(); col++) {            assertEquals("value[" + row + "][" + col + ']', test.getQuick(row, col), value.getQuick(row, col), EPSILON);        }    }}
29ecf182f58280306a5f8036e84fb4e1b709d8cab8ede0ac1b2f8c6caecc1eaf
testAssignMatrixCardinality
public void testAssignMatrixCardinality()
{    test.assign(test.transpose());}
1cd2167b68d321b67d088c7b60215582cb0567d7eecbe7f5ff1670624e9658f9
testAssignUnaryFunction
public void testAssignUnaryFunction()
{    test.assign(Functions.mult(-1));    for (int row = 0; row < test.rowSize(); row++) {        for (int col = 0; col < test.columnSize(); col++) {            assertEquals("value[" + row + "][" + col + ']', -values[row][col], test.getQuick(row, col), EPSILON);        }    }}
e7aa0587f0f4eea45da626fa7f3ea527ea595516ff79c50fe9cbc0af9dbf4197
testRowView
public void testRowView()
{    assertEquals(test.columnSize(), test.viewRow(1).size());    assertEquals(test.columnSize(), test.viewRow(2).size());    Random gen = RandomUtils.getRandom();    for (int row = 0; row < test.rowSize(); row++) {        int j = gen.nextInt(test.columnSize());        double old = test.get(row, j);        double v = gen.nextGaussian();        test.viewRow(row).set(j, v);        assertEquals(v, test.get(row, j), 0);        assertEquals(v, test.viewRow(row).get(j), 0);        test.set(row, j, old);        assertEquals(old, test.get(row, j), 0);        assertEquals(old, test.viewRow(row).get(j), 0);    }}
d2a05616192df0a29003fcc6286f54dac3203b6ebe04f6d996b0eb04acbd1331
testColumnView
public void testColumnView()
{    assertEquals(test.rowSize(), test.viewColumn(0).size());    assertEquals(test.rowSize(), test.viewColumn(1).size());    Random gen = RandomUtils.getRandom();    for (int col = 0; col < test.columnSize(); col++) {        int j = gen.nextInt(test.columnSize());        double old = test.get(col, j);        double v = gen.nextGaussian();        test.viewColumn(col).set(j, v);        assertEquals(v, test.get(j, col), 0);        assertEquals(v, test.viewColumn(col).get(j), 0);        test.set(j, col, old);        assertEquals(old, test.get(j, col), 0);        assertEquals(old, test.viewColumn(col).get(j), 0);    }}
02620393b866131f2c4a67acfa9abaafc57b36042617a86b6f6a423a4b959660
testAggregateRows
public void testAggregateRows()
{    Vector v = test.aggregateRows(new VectorFunction() {        @Override        public double apply(Vector v) {            return v.zSum();        }    });    for (int i = 0; i < test.numRows(); i++) {        assertEquals(test.viewRow(i).zSum(), v.get(i), EPSILON);    }}
34458c5c4d61eeeaeb2eaf91ebf4340feeee54c6c8bea0ed7d7a4c377baca8e5
apply
public double apply(Vector v)
{    return v.zSum();}
96a9461e72ea2e0d51323fb7c1cf2ad2281d463d134289aa2eb89fc9cf72635a
testAggregateCols
public void testAggregateCols()
{    Vector v = test.aggregateColumns(new VectorFunction() {        @Override        public double apply(Vector v) {            return v.zSum();        }    });    for (int i = 0; i < test.numCols(); i++) {        assertEquals(test.viewColumn(i).zSum(), v.get(i), EPSILON);    }}
34458c5c4d61eeeaeb2eaf91ebf4340feeee54c6c8bea0ed7d7a4c377baca8e5
apply
public double apply(Vector v)
{    return v.zSum();}
d9ff32b81a7299e5dfa29603b9522f78c13e2e4453475a5415faf4269201dffb
testAggregate
public void testAggregate()
{    double total = test.aggregate(Functions.PLUS, Functions.IDENTITY);    assertEquals(test.aggregateRows(new VectorFunction() {        @Override        public double apply(Vector v) {            return v.zSum();        }    }).zSum(), total, EPSILON);}
34458c5c4d61eeeaeb2eaf91ebf4340feeee54c6c8bea0ed7d7a4c377baca8e5
apply
public double apply(Vector v)
{    return v.zSum();}
d58b51a775a3ef67416c5c0925d435d6945066f65c166f7e3a050222c3732ebf
testDivide
public void testDivide()
{    Matrix value = test.divide(4.53);    for (int row = 0; row < test.rowSize(); row++) {        for (int col = 0; col < test.columnSize(); col++) {            assertEquals("value[" + row + "][" + col + ']', values[row][col] / 4.53, value.getQuick(row, col), EPSILON);        }    }}
eaa5dd587a1051f25f65fe1808fe232d587180e61c71e00071a4b765af52ae7a
testGet
public void testGet()
{    for (int row = 0; row < test.rowSize(); row++) {        for (int col = 0; col < test.columnSize(); col++) {            assertEquals("value[" + row + "][" + col + ']', values[row][col], test.get(row, col), EPSILON);        }    }}
c367b627e534e8cb7e6132f328cfe2ec695cf29fd27042865c96f998565350b2
testGetIndexUnder
public void testGetIndexUnder()
{    for (int row = -1; row < test.rowSize(); row++) {        for (int col = 0; col < test.columnSize(); col++) {            test.get(row, col);        }    }}
f26cb64fd6ba7c58638f65a59c640002034919c8dd3d219ac2ccf90b0fff714a
testGetIndexOver
public void testGetIndexOver()
{    for (int row = 0; row < test.rowSize() + 1; row++) {        for (int col = 0; col < test.columnSize(); col++) {            test.get(row, col);        }    }}
f7bbeaabdbf47078c5ea13f814ffb05bc9b90aeaa9fd0d89279cc6a77a196301
testMinus
public void testMinus()
{    Matrix value = test.minus(test);    for (int row = 0; row < test.rowSize(); row++) {        for (int col = 0; col < test.columnSize(); col++) {            assertEquals("value[" + row + "][" + col + ']', 0.0, value.getQuick(row, col), EPSILON);        }    }}
c9604e38f754d59692ccb815a05cb033ab448d897c16ac8eacb9cb98bb9c6c84
testMinusCardinality
public void testMinusCardinality()
{    test.minus(test.transpose());}
fa621704f0454f9b077a2d55f5b85be71984945b361fdcc96c4ad28da52d2600
testPlusDouble
public void testPlusDouble()
{    Matrix value = test.plus(4.53);    for (int row = 0; row < test.rowSize(); row++) {        for (int col = 0; col < test.columnSize(); col++) {            assertEquals("value[" + row + "][" + col + ']', values[row][col] + 4.53, value.getQuick(row, col), EPSILON);        }    }}
97a899842a52c6decc58d296e9affca5e1aec84d8a2a14260f5699aae6e9e031
testPlusMatrix
public void testPlusMatrix()
{    Matrix value = test.plus(test);    for (int row = 0; row < test.rowSize(); row++) {        for (int col = 0; col < test.columnSize(); col++) {            assertEquals("value[" + row + "][" + col + ']', values[row][col] * 2, value.getQuick(row, col), EPSILON);        }    }}
db4e7a5dead61203e69f920d3d82a3036e9f0ee74bcbbdeecca5bad9bc193e5b
testPlusMatrixCardinality
public void testPlusMatrixCardinality()
{    test.plus(test.transpose());}
8cdc761982243c1ad089e1edf015e95c6bb8d239cfd02a50f8f335e2f9f7acdd
testSetUnder
public void testSetUnder()
{    for (int row = -1; row < test.rowSize(); row++) {        for (int col = 0; col < test.columnSize(); col++) {            test.set(row, col, 1.23);        }    }}
d3de7681ff613118120cf3ffb9fabfe16577c38ee5720415af9fce86dd15601b
testSetOver
public void testSetOver()
{    for (int row = 0; row < test.rowSize() + 1; row++) {        for (int col = 0; col < test.columnSize(); col++) {            test.set(row, col, 1.23);        }    }}
7ac04d97f6038094dd4e9d20b79a35ac5c99b4ef68908ce1d637e9f3fff7be05
testTimesDouble
public void testTimesDouble()
{    Matrix value = test.times(4.53);    for (int row = 0; row < test.rowSize(); row++) {        for (int col = 0; col < test.columnSize(); col++) {            assertEquals("value[" + row + "][" + col + ']', values[row][col] * 4.53, value.getQuick(row, col), EPSILON);        }    }}
4421f5a043be99bdf600e120e4b25a8b63aa3830b8587e853d7c203bf4c7ad45
testTimesMatrix
public void testTimesMatrix()
{    Matrix transpose = test.transpose();    Matrix value = test.times(transpose);    assertEquals("rows", test.rowSize(), value.rowSize());    assertEquals("cols", test.rowSize(), value.columnSize());    Matrix expected = new DenseMatrix(new double[][] { { 5.0, 11.0, 17.0 }, { 11.0, 25.0, 39.0 }, { 17.0, 39.0, 61.0 } }).times(1.21);    for (int i = 0; i < expected.numCols(); i++) {        for (int j = 0; j < expected.numRows(); j++) {            assertTrue("Matrix times transpose not correct: " + i + ", " + j + "\nexpected:\n\t" + expected + "\nactual:\n\t" + value, Math.abs(expected.get(i, j) - value.get(i, j)) < 1.0e-12);        }    }    Matrix timestest = new DenseMatrix(10, 1);    /* will throw ArrayIndexOutOfBoundsException exception without MAHOUT-26 */    timestest.transpose().times(timestest);}
e71fc094b81d5fc27610f7dbe24c334982ecd3e85db7403af01dcf02ea74d954
testTimesVector
public void testTimesVector()
{    Vector vectorA = new DenseVector(vectorAValues);    Vector testTimesVectorA = test.times(vectorA);    Vector expected = new DenseVector(new double[] { 5.0, 11.0, 17.0 });    assertTrue("Matrix times vector not equals: " + vectorA + " != " + testTimesVectorA, expected.minus(testTimesVectorA).norm(2) < 1.0e-12);    test.times(testTimesVectorA);}
2a96ad71f562d75490f0f42eadfe71bb014593fe454a53bf0aedc5723498e67a
testTimesSquaredTimesVector
public void testTimesSquaredTimesVector()
{    Vector vectorA = new DenseVector(vectorAValues);    Vector ttA = test.timesSquared(vectorA);    Vector ttASlow = test.transpose().times(test.times(vectorA));    assertTrue("M'Mv != M.timesSquared(v): " + ttA + " != " + ttASlow, ttASlow.minus(ttA).norm(2) < 1.0e-12);}
7f1a818d02a08c198b5fe40e2a71fc931ccf25e1af588a7c40efab82249ac4ba
testTimesMatrixCardinality
public void testTimesMatrixCardinality()
{    Matrix other = test.like(5, 8);    test.times(other);}
fafef026a08defa153a8269edf4c4c7d2155280cf1c5aeb987b02455a2cc494a
testTranspose
public void testTranspose()
{    Matrix transpose = test.transpose();    assertEquals("rows", test.columnSize(), transpose.rowSize());    assertEquals("cols", test.rowSize(), transpose.columnSize());    for (int row = 0; row < test.rowSize(); row++) {        for (int col = 0; col < test.columnSize(); col++) {            assertEquals("value[" + row + "][" + col + ']', test.getQuick(row, col), transpose.getQuick(col, row), EPSILON);        }    }}
a2f8bfe43ba8c92aee805d6750cf99adacee631d704901a4f5706f892b0c0a9c
testZSum
public void testZSum()
{    double sum = test.zSum();    assertEquals("zsum", 23.1, sum, EPSILON);}
e137a72d3c937dff4039d5cd2ca7137b034d48b79463711f6d06a57159280d76
testAssignRow
public void testAssignRow()
{    double[] data = { 2.1, 3.2 };    test.assignRow(1, new DenseVector(data));    assertEquals("test[1][0]", 2.1, test.getQuick(1, 0), EPSILON);    assertEquals("test[1][1]", 3.2, test.getQuick(1, 1), EPSILON);}
62db0d6bf17ea54703bf870b4b75856ff370cc676dad17967f4bf1dff31be3f0
testAssignRowCardinality
public void testAssignRowCardinality()
{    double[] data = { 2.1, 3.2, 4.3 };    test.assignRow(1, new DenseVector(data));}
fef3ffd41d0677d23db3d459bb67dd61cde1853bb44d0475db3b975cc6319545
testAssignColumn
public void testAssignColumn()
{    double[] data = { 2.1, 3.2, 4.3 };    test.assignColumn(1, new DenseVector(data));    assertEquals("test[0][1]", 2.1, test.getQuick(0, 1), EPSILON);    assertEquals("test[1][1]", 3.2, test.getQuick(1, 1), EPSILON);    assertEquals("test[2][1]", 4.3, test.getQuick(2, 1), EPSILON);}
e0c69949f5d2ce11574c10487f3ac35ce839f008ab1408525836c17da9f4a69a
testAssignColumnCardinality
public void testAssignColumnCardinality()
{    double[] data = { 2.1, 3.2 };    test.assignColumn(1, new DenseVector(data));}
82fed8001e09bf1361718b203ebead0644ffbd5850a682c65ed4be09bb2be968
testViewRow
public void testViewRow()
{    Vector row = test.viewRow(1);    assertEquals("row size", 2, row.getNumNondefaultElements());        Matrix matrix = new SparseMatrix(1, 1);    Vector view = matrix.viewRow(0);    final double value = 1.23;    view.assign(value);        assertEquals("Matrix value", view.getQuick(0), matrix.getQuick(0, 0), EPSILON);}
c39ac0b6c62c165e15ccc102242bceced40c68a9b507059ed8f0d77cfe275098
testViewRowIndexUnder
public void testViewRowIndexUnder()
{    test.viewRow(-1);}
415d4167db009dfac17c8b2278f49529048083ae96633f4c3b1b717d3f402864
testViewRowIndexOver
public void testViewRowIndexOver()
{    test.viewRow(5);}
9af236b1ba0e08c0e227303e19c7c5dece84754855f61d780d99cd9ac4cb909b
testViewColumn
public void testViewColumn()
{    Vector column = test.viewColumn(1);    assertEquals("row size", 3, column.getNumNondefaultElements());}
e4dfba9a616f6eaf01ead88686588a5f9016ea6b0dfc6ffd9e4ded098439f534
testViewColumnIndexUnder
public void testViewColumnIndexUnder()
{    test.viewColumn(-1);}
64a0b786c9d9f54e71513354cc154802ee5d8ebd496651ed33c3f923de0166cb
testViewColumnIndexOver
public void testViewColumnIndexOver()
{    test.viewColumn(5);}
4bee2fa47f362e310c95953e2fb99132072222abeba181a72a0aab4c4d56d950
testDeterminant
public void testDeterminant()
{    Matrix m = matrixFactory(new double[][] { { 1, 3, 4 }, { 5, 2, 3 }, { 1, 4, 2 } });    assertEquals("determinant", 43.0, m.determinant(), EPSILON);}
fc77973c1ff5c48602c3e4636aa4de9cc458575aeab2a93fc69fca93e0dd6f64
testLabelBindings
public void testLabelBindings()
{    Matrix m = matrixFactory(new double[][] { { 1, 3, 4 }, { 5, 2, 3 }, { 1, 4, 2 } });    assertNull("row bindings", m.getRowLabelBindings());    assertNull("col bindings", m.getColumnLabelBindings());    Map<String, Integer> rowBindings = new HashMap<>();    rowBindings.put("Fee", 0);    rowBindings.put("Fie", 1);    rowBindings.put("Foe", 2);    m.setRowLabelBindings(rowBindings);    assertEquals("row", rowBindings, m.getRowLabelBindings());    Map<String, Integer> colBindings = new HashMap<>();    colBindings.put("Foo", 0);    colBindings.put("Bar", 1);    colBindings.put("Baz", 2);    m.setColumnLabelBindings(colBindings);    assertEquals("row", rowBindings, m.getRowLabelBindings());    assertEquals("Fee", m.get(0, 1), m.get("Fee", "Bar"), EPSILON);    double[] newrow = { 9, 8, 7 };    m.set("Foe", newrow);    assertEquals("FeeBaz", m.get(0, 2), m.get("Fee", "Baz"), EPSILON);}
7ffed98d1ac13ef6dcf7d0d5b05566f77686d65f2800508a6851bbf0e1fa6c8f
testSettingLabelBindings
public void testSettingLabelBindings()
{    Matrix m = matrixFactory(new double[][] { { 1, 3, 4 }, { 5, 2, 3 }, { 1, 4, 2 } });    assertNull("row bindings", m.getRowLabelBindings());    assertNull("col bindings", m.getColumnLabelBindings());    m.set("Fee", "Foo", 1, 2, 9);    assertNotNull("row", m.getRowLabelBindings());    assertNotNull("row", m.getRowLabelBindings());    assertEquals("Fee", 1, m.getRowLabelBindings().get("Fee").intValue());    assertEquals("Fee", 2, m.getColumnLabelBindings().get("Foo").intValue());    assertEquals("FeeFoo", m.get(1, 2), m.get("Fee", "Foo"), EPSILON);    m.get("Fie", "Foe");}
1cc9da23e3645bae0099dfb7038cebd117da2e45d1db7edec02e330b9bd0c618
testLabelBindingSerialization
public void testLabelBindingSerialization()
{    Matrix m = matrixFactory(new double[][] { { 1, 3, 4 }, { 5, 2, 3 }, { 1, 4, 2 } });    assertNull("row bindings", m.getRowLabelBindings());    assertNull("col bindings", m.getColumnLabelBindings());    Map<String, Integer> rowBindings = new HashMap<>();    rowBindings.put("Fee", 0);    rowBindings.put("Fie", 1);    rowBindings.put("Foe", 2);    m.setRowLabelBindings(rowBindings);    assertEquals("row", rowBindings, m.getRowLabelBindings());    Map<String, Integer> colBindings = new HashMap<>();    colBindings.put("Foo", 0);    colBindings.put("Bar", 1);    colBindings.put("Baz", 2);    m.setColumnLabelBindings(colBindings);    assertEquals("col", colBindings, m.getColumnLabelBindings());}
d2a05616192df0a29003fcc6286f54dac3203b6ebe04f6d996b0eb04acbd1331
testColumnView
public void testColumnView()
{    Matrix matrix = new DenseMatrix(5, 3);    Vector column2 = matrix.viewColumn(2);    Matrix outerProduct = column2.cross(column2);    assertEquals(matrix.numRows(), outerProduct.numRows());    assertEquals(matrix.numRows(), outerProduct.numCols());}
59887733037493ed9e48ef720f49095e78dcd6563523ccbc5c2e7605d226b1e2
testIndexRange
public void testIndexRange()
{    Matrix m = new DenseMatrix(20, 30).assign(Functions.random());    try {        m.viewColumn(30);        fail("Should have thrown exception");    } catch (IllegalArgumentException e) {        assertTrue(e.getMessage().startsWith("Index 30 is outside allowable"));    }    try {        m.viewRow(20);        fail("Should have thrown exception");    } catch (IllegalArgumentException e) {        assertTrue(e.getMessage().startsWith("Index 20 is outside allowable"));    }}
1b9b1a338cf4f8fa397bf0b689b7f9b6ccc4914b98309ba037c222123bfdbfeb
testCorrectValues
public void testCorrectValues() throws Exception
{    byte[] bytes = "Now is the time for all good men to come to the aid of their country".getBytes("UTF-8");    int hash = 0;    for (int i = 0; i < bytes.length; i++) {        hash = hash * 31 + (bytes[i] & 0xff);        bytes[i] = (byte) hash;    }        for (int offset = 0; offset < 10; offset++) {        byte[] arr = new byte[bytes.length + offset];        System.arraycopy(bytes, 0, arr, offset, bytes.length);        for (int len = 0; len < bytes.length; len++) {            int h = MurmurHash3.murmurhash3x8632(arr, offset, len, len);            assertEquals(ANSWERS[len], h);        }    }}
f1ddd417b790f461382f7df6b1c54f85f376ea089ea3460607efb6f3a1ab5daf
testForLotsOfChange64
public void testForLotsOfChange64() throws UnsupportedEncodingException
{    long h1 = MurmurHash.hash64A("abc".getBytes(Charsets.UTF_8), 0);    long h2 = MurmurHash.hash64A("abc ".getBytes(Charsets.UTF_8), 0);    int flipCount = Long.bitCount(h1 ^ h2);    Assert.assertTrue("Small changes should result in lots of bit flips, only found " + flipCount, flipCount > 25);}
1f5058d4cc22d4101b51574ef8c05faf023e880df35efbf226d2cb13719a4535
testHash64
public void testHash64()
{        Assert.assertEquals(0x9cc9c33498a95efbL, MurmurHash.hash64A("abc".getBytes(Charsets.UTF_8), 0));    Assert.assertEquals(0xd2c8c9b470122bddL, MurmurHash.hash64A("abc def ghi jkl ".getBytes(Charsets.UTF_8), 0));    Assert.assertEquals(0xcd37895736a81cbcL, MurmurHash.hash64A("abc def ghi jkl moreGoo".getBytes(Charsets.UTF_8), 0));}
dcb47620702edadb4bd3665039884df64392276783d94fee51ccfd1b2123fccf
testForLotsOfChange32
public void testForLotsOfChange32() throws UnsupportedEncodingException
{    int h1 = MurmurHash.hash("abc".getBytes(Charsets.UTF_8), 0);    int h2 = MurmurHash.hash("abc ".getBytes(Charsets.UTF_8), 0);    int flipCount = Integer.bitCount(h1 ^ h2);    Assert.assertTrue("Small changes should result in lots of bit flips, only found " + flipCount, flipCount > 14);}
f21e1ca75375754eccd1e62f245f89ce7c89692535bb2246a9813f51edae7496
testChangingSeed
public void testChangingSeed()
{        byte[] key = { 0x4E, (byte) 0xE3, (byte) 0x91, 0x00, 0x10, (byte) 0x8F, (byte) 0xFF };    int[] expected = { 0xeef8be32, 0x8109dec6, 0x9aaf4192, 0xc1bcaf1c, 0x821d2ce4, 0xd45ed1df, 0x6c0357a7, 0x21d4e845, 0xfa97db50, 0x2f1985c8, 0x5d69782a, 0x0d6e4b85, 0xe7d9cf6b, 0x337e6b49, 0xe1606944, 0xccc18ae8 };    for (int i = 0; i < expected.length; i++) {        int expectedHash = expected[i];        int hash = MurmurHash.hash(key, i);        Assert.assertEquals("i = " + i, expectedHash, hash);    }}
da44cf2e7d54ca11981670aa2521669f0878bef4a439910fc48c55a5601a2dd2
testChangingKey
public void testChangingKey()
{    byte[] key = new byte[133];    int[] expected = { 0xd743ae0b, 0xf1b461c6, 0xa45a6ceb, 0xdb15e003, 0x877721a4, 0xc30465f1, 0xfb658ba4, 0x1adf93b2, 0xe40a7931, 0x3da52db0, 0xbf523511, 0x1efaf273, 0xe628c1dd, 0x9a0344df, 0x901c99fc, 0x5ae1aa44 };    for (int i = 0; i < 16; i++) {                setKey(key, i);        int expectedHash = expected[i];        int hash = MurmurHash.hash(key, 0x1234ABCD);        Assert.assertEquals("i = " + i, expectedHash, hash);    }}
b8fb88129007022439fc58805ebe2102882fddcd41492882ae885c9814b0dc2b
testChangingKeyLength
public void testChangingKeyLength()
{    int[] expected = { 0xa0c72f8e, 0x29c2f97e, 0x00ca8bba, 0x88387876, 0xe203ce49, 0x58d75952, 0xab84febe, 0x98153c65, 0xcbb38375, 0x6ea1a28b, 0x9afa8f55, 0xfb890eb6, 0x9516cc49, 0x6408a8eb, 0xbb12d3e6, 0x00fb7519 };        for (int i = 0; i < 16; i++) {        byte[] key = new byte[i];        setKey(key, i);        int expectedHash = expected[i];        int hash = MurmurHash.hash(key, 0x7870AAFF);        Assert.assertEquals("i = " + i, expectedHash, hash);    }}
649a48a019d634eeb63c5f2fed4f90baac0d802ea867f2c26c4438a6b15b47ed
setKey
private static void setKey(byte[] key, int start)
{    for (int i = 0; i < key.length; i++) {        key[i] = (byte) ((start + i) & 0xFF);    }}
38353c4d412f412fbc2be95944cad9a9b097b5188f9cfe92dff27f4300d90f62
rank1
public void rank1()
{    Matrix x = new DenseMatrix(3, 3);    x.viewRow(0).assign(new double[] { 1, 2, 3 });    x.viewRow(1).assign(new double[] { 2, 4, 6 });    x.viewRow(2).assign(new double[] { 3, 6, 9 });    OldQRDecomposition qr = new OldQRDecomposition(x);    assertFalse(qr.hasFullRank());    assertEquals(0, new DenseVector(new double[] { 3.741657, 7.483315, 11.22497 }).aggregate(qr.getR().viewRow(0), Functions.PLUS, new DoubleDoubleFunction() {        @Override        public double apply(double arg1, double arg2) {            return Math.abs(arg1) - Math.abs(arg2);        }    }), 1.0e-5);}
deeca4bb8badcf2a6323bbc5cc3391495ea6e718f5eccbfec72e46dc78ea4bdf
apply
public double apply(double arg1, double arg2)
{    return Math.abs(arg1) - Math.abs(arg2);}
b700f77097df042162bc76f2cee34dd14e78c75532dfb69b337c135ee62c75ca
fullRankTall
public void fullRankTall()
{    Matrix x = matrix();    OldQRDecomposition qr = new OldQRDecomposition(x);    assertTrue(qr.hasFullRank());    Matrix rRef = reshape(new double[] { -2.99129686445138, 0, 0, 0, 0, -0.0282260628674372, -2.38850244769059, 0, 0, 0, 0.733739310355871, 1.48042000631646, 2.29051263117895, 0, 0, -0.0394082168269326, 0.282829484207801, -0.00438521041803086, -2.90823198084203, 0, 0.923669647838536, 1.76679276072492, 0.637690104222683, -0.225890909498753, -1.35732293800944 }, 5, 5);    Matrix r = qr.getR();    assertEquals(rRef, r, 1.0e-8);    Matrix qRef = reshape(new double[] { -0.165178287646573, 0.0510035857637869, 0.13985915987379, -0.120173729496501, -0.453198314345324, 0.644400679630493, -0.503117990820608, 0.24968739845381, 0.323968339146224, -0.465266080134262, 0.276508948773268, -0.687909700644343, 0.0544048888907195, -0.0166677718378263, 0.171309755790717, 0.310339001630029, 0.674790532821663, 0.0058166082200493, -0.381707516461884, 0.300504956413142, -0.105751091334003, 0.410450870871096, 0.31113446615821, 0.179338172684956, 0.361951807617901, 0.763921725548796, 0.380327892605634, -0.287274944594054, 0.0311604042556675, 0.0386096858143961, 0.0387156960650472, -0.232975755728917, 0.0358178276684149, 0.173105775703199, 0.327321867815603, 0.328671945345279, -0.36015879836344, -0.444261660176044, 0.09438499563253, 0.646216148583769 }, 8, 5);    printMatrix("qRef", qRef);    Matrix q = qr.getQ();    printMatrix("q", q);    assertEquals(qRef, q, 1.0e-8);    Matrix x1 = qr.solve(reshape(new double[] { -0.0178247686747641, 0.68631714634098, -0.335464858468858, 1.50249941751569, -0.669901640772149, -0.977025038942455, -1.18857546169856, -1.24792900492054 }, 8, 1));    Matrix xref = reshape(new double[] { -0.0127440093664874, 0.655825940180799, -0.100755415991702, -0.0349559562697406, -0.190744297762028 }, 5, 1);    printMatrix("x1", x1);    printMatrix("xref", xref);    assertEquals(xref, x1, 1.0e-8);}
de3dd534ad4e468d3dcc0927166ec69d8c055ec4bce2ec38eafd2b5e8ed6ba2d
fullRankWide
public void fullRankWide()
{    Matrix x = matrix().transpose();    OldQRDecomposition qr = new OldQRDecomposition(x);    assertFalse(qr.hasFullRank());    Matrix rActual = qr.getR();    Matrix rRef = reshape(new double[] { -2.42812464965842, 0, 0, 0, 0, 0.303587286111356, -2.91663643494775, 0, 0, 0, -0.201812474153156, -0.765485720168378, 1.09989373598954, 0, 0, 1.47980701097885, -0.637545820524326, -1.55519859337935, 0.844655127991726, 0, 0.0248883129453161, 0.00115010570270549, -0.236340588891252, -0.092924118200147, 1.42910099545547, -1.1678472412429, 0.531245845248056, 0.351978196071514, -1.03241474816555, -2.20223861735426, -0.887809959067632, 0.189731251982918, -0.504321849233586, 0.490484123999836, 1.21266692336743, -0.633888169775463, 1.04738559065986, 0.284041239547031, 0.578183510077156, -0.942314870832456 }, 5, 8);    printMatrix("rRef", rRef);    printMatrix("rActual", rActual);    assertEquals(rRef, rActual, 1.0e-8);    Matrix qRef = reshape(new double[] { -0.203489262374627, 0.316761677948356, -0.784155643293468, 0.394321494579, -0.29641971170211, 0.0311283614803723, -0.34755265020736, 0.137138511478328, 0.848579887681972, 0.373287266507375, -0.39603700561249, -0.787812566647329, -0.377864833067864, -0.275080943427399, 0.0636764674878229, 0.0763976893309043, -0.318551137554327, 0.286407036668598, 0.206004127289883, -0.876482672226889, 0.89159476695423, -0.238213616975551, -0.376141107880836, -0.0794701657055114, 0.0227025098210165 }, 5, 5);    Matrix q = qr.getQ();    printMatrix("qRef", qRef);    printMatrix("q", q);    assertEquals(qRef, q, 1.0e-8);    Matrix x1 = qr.solve(b());    Matrix xRef = reshape(new double[] { -0.182580239668147, -0.437233627652114, 0.138787653097464, 0.672934739896228, -0.131420217069083, 0, 0, 0 }, 8, 1);    printMatrix("xRef", xRef);    printMatrix("x", x1);    assertEquals(xRef, x1, 1.0e-8);}
39045410ebca98a1c7ab5907e14d5959aa2843dd082afc1044815b9adb7a8c1c
assertEquals
private static void assertEquals(Matrix ref, Matrix actual, double epsilon)
{    assertEquals(0, ref.minus(actual).aggregate(Functions.MAX, Functions.ABS), epsilon);}
7ca5216066be68cd5642f0484a8ffec44d9390fffec392e028a5b7af2195bc80
printMatrix
private static void printMatrix(String name, Matrix m)
{    int rows = m.numRows();    int columns = m.numCols();    System.out.printf("%s - %d x %d\n", name, rows, columns);    for (int i = 0; i < rows; i++) {        for (int j = 0; j < columns; j++) {            System.out.printf("%10.5f", m.get(i, j));        }        System.out.printf("\n");    }    System.out.printf("\n");    System.out.printf("\n");}
d7b68c4a0d4b7ada22e4069456270685d72b332432349e8d145c8eb6e4bbd5bc
matrix
private static Matrix matrix()
{    double[] values = { 0.494097293912641, -0.152566866170993, -0.418360266395271, 0.359475300232312, 1.35565069667582, -1.92759373242903, 1.50497526839076, -0.746889132087904, -0.769136838293565, 1.10984954080986, -0.664389974392489, 1.6464660350229, -0.11715420616969, 0.0216221197371269, -0.394972730980765, -0.748293157213142, 1.90402764664962, -0.638042862848559, -0.362336344669668, -0.418261074380526, -0.494211543128429, 1.38828971158414, 0.597110366867923, 1.05341387608687, -0.957461740877418, -2.35528802598249, -1.03171458944128, 0.644319090271635, -0.0569108993041965, -0.14419465550881, -0.0456801828174936, 0.754694392571835, 0.719744008628535, -1.17873249802301, -0.155887528905918, -1.5159868405466, 0.0918931582603128, 1.42179027361583, -0.100495054250176, 0.0687986548485584 };    return reshape(values, 8, 5);}
01198f1d810eaa8b2115ec04988e4fdb219d23e21f9378a3437aa733a025a8a1
reshape
private static Matrix reshape(double[] values, int rows, int columns)
{    Matrix m = new DenseMatrix(rows, columns);    int i = 0;    for (double v : values) {        m.set(i % rows, i / rows, v);        i++;    }    return m;}
be80d004bdc442a379c2089169aa840518e0a4b0a84be18f67d2c24d8d789b8c
b
private static Matrix b()
{    return reshape(new double[] { -0.0178247686747641, 0.68631714634098, -0.335464858468858, 1.50249941751569, -0.669901640772149 }, 5, 1);}
73521b54ff80102893de786b102a76e3a12a183962a8c15991162190c4bf7f7d
testViewBasics
public void testViewBasics()
{    Vector v = randomVector();    int[] pivot = pivot();    Vector pvv = new PermutedVectorView(v, pivot);        for (int i = 0; i < 20; i++) {        assertEquals("Element " + i, v.get(pivot[i]), pvv.get(i), 0);    }        pvv.set(6, 321);    v.set(9, 512);        for (int i = 0; i < 20; i++) {        assertEquals("Element " + i, v.get(pivot[i]), pvv.get(i), 0);    }}
9ed9db955d8bd7517d6ba25e6e42437d8e719224bc6b561d1f580007f9eb1c75
testIterators
public void testIterators()
{    int[] pivot = pivot();    int[] unpivot = unpivot();    Vector v = randomVector();    PermutedVectorView pvv = new PermutedVectorView(v, pivot);        assertEquals(v.zSum(), pvv.zSum(), 0);    assertEquals(v.getNumNondefaultElements(), pvv.getNumNondefaultElements());    v.set(11, 0);    assertEquals(v.getNumNondefaultElements(), pvv.getNumNondefaultElements());    Iterator<Vector.Element> vi = pvv.iterator();    int i = 0;    while (vi.hasNext()) {        Vector.Element e = vi.next();        assertEquals("Index " + i, i, pivot[e.index()]);        assertEquals("Reverse Index " + i, unpivot[i], e.index());        assertEquals("Self-value " + i, e.get(), pvv.get(e.index()), 0);                assertEquals("Value " + i, v.get(i), e.get(), 0);        i++;    }}
96d917f96610811146d862cfb87abfd73bcb448661f1edad6dde140a3860fc2d
pivot
private static int[] pivot()
{    return new int[] { 11, 7, 10, 9, 8, 3, 17, 0, 19, 13, 12, 1, 5, 6, 16, 2, 4, 14, 18, 15 };}
26c2886f1a2de4294639606c58f7addaf75b74d6ebd4b011812fbebb0fd7ca41
unpivot
private static int[] unpivot()
{    int[] pivot = pivot();    int[] unpivot = new int[20];    for (int i = 0; i < 20; i++) {        unpivot[pivot[i]] = i;    }    return unpivot;}
a0967b90c7d428690d83e521567a8977a7f314bb0b65c698ff32957c73ba9e6f
randomVector
private static Vector randomVector()
{    Vector v = new DenseVector(20);    v.assign(new DoubleFunction() {        private final Random gen = RandomUtils.getRandom();        @Override        public double apply(double arg1) {            return gen.nextDouble();        }    });    return v;}
685ca82cead33e56c75cad5ace5f3cba2e4e471d0dcc68359527832073e7cdd4
apply
public double apply(double arg1)
{    return gen.nextDouble();}
01cf2d667d555539dc4f30cd00d8b1ec0a4b8f3dc90cba3fb4b3e603e0505350
matrixFactory
public Matrix matrixFactory(double[][] values)
{    Matrix base = new DenseMatrix(values);                PivotedMatrix pm = new PivotedMatrix(base.like());    pm.swap(0, 1);    pm.swapRows(1, 2);    pm.assign(base);    return pm;}
fb4c768ac869d5379fb69b546b0863d623fda4887d250e5810a2e4f02cd6cb7d
testSwap
public void testSwap()
{    Matrix m = new DenseMatrix(10, 10);    for (int i = 0; i < 10; i++) {        for (int j = 0; j < 10; j++) {            m.set(i, j, 10 * i + j);        }    }    PivotedMatrix pm = new PivotedMatrix(m);    pm.swap(3, 5);    assertEquals(0, pm.viewDiagonal().minus(new DenseVector(new double[] { 0, 11, 22, 55, 44, 33, 66, 77, 88, 99 })).norm(1), 1.0e-10);    pm.swap(2, 7);    assertEquals(0, pm.viewDiagonal().minus(new DenseVector(new double[] { 0, 11, 77, 55, 44, 33, 66, 22, 88, 99 })).norm(1), 1.0e-10);    pm.swap(5, 8);    assertEquals(0, pm.viewColumn(4).minus(new DenseVector(new double[] { 4.0, 14.0, 74.0, 54.0, 44.0, 84.0, 64.0, 24.0, 34.0, 94.0 })).norm(1), 1.0e-10);    assertEquals(0, pm.viewDiagonal().minus(new DenseVector(new double[] { 0, 11, 77, 55, 44, 88, 66, 22, 33, 99 })).norm(1), 1.0e-10);}
b883ea99722408dfd1d14a9b5d4283c5c39d278b713b7623af7b5a9a4a418906
randomMatrix
public void randomMatrix()
{    Matrix a = new DenseMatrix(60, 60).assign(Functions.random());    QRDecomposition qr = new QRDecomposition(a);        double maxIdent = qr.getQ().transpose().times(qr.getQ()).viewDiagonal().assign(Functions.plus(-1)).norm(1);    assertEquals(0, maxIdent, 1.0e-13);        Matrix z = qr.getQ().times(qr.getR()).minus(a);    double maxError = z.aggregate(Functions.MIN, Functions.ABS);    assertEquals(0, maxError, 1.0e-13);}
38353c4d412f412fbc2be95944cad9a9b097b5188f9cfe92dff27f4300d90f62
rank1
public void rank1()
{    Matrix x = new DenseMatrix(3, 3);    x.viewRow(0).assign(new double[] { 1, 2, 3 });    x.viewRow(1).assign(new double[] { 2, 4, 6 });    x.viewRow(2).assign(new double[] { 3, 6, 9 });    QRDecomposition qr = new QRDecomposition(x);    assertFalse(qr.hasFullRank());    assertEquals(0, new DenseVector(new double[] { 3.741657, 7.483315, 11.22497 }).aggregate(qr.getR().viewRow(0), Functions.PLUS, new DoubleDoubleFunction() {        @Override        public double apply(double arg1, double arg2) {            return Math.abs(arg1) - Math.abs(arg2);        }    }), 1.0e-5);}
deeca4bb8badcf2a6323bbc5cc3391495ea6e718f5eccbfec72e46dc78ea4bdf
apply
public double apply(double arg1, double arg2)
{    return Math.abs(arg1) - Math.abs(arg2);}
b700f77097df042162bc76f2cee34dd14e78c75532dfb69b337c135ee62c75ca
fullRankTall
public void fullRankTall()
{    Matrix x = matrix();    QRDecomposition qr = new QRDecomposition(x);    assertTrue(qr.hasFullRank());    Matrix rRef = reshape(new double[] { -2.99129686445138, 0, 0, 0, 0, -0.0282260628674372, -2.38850244769059, 0, 0, 0, 0.733739310355871, 1.48042000631646, 2.29051263117895, 0, 0, -0.0394082168269326, 0.282829484207801, -0.00438521041803086, -2.90823198084203, 0, 0.923669647838536, 1.76679276072492, 0.637690104222683, -0.225890909498753, -1.35732293800944 }, 5, 5);    Matrix r = qr.getR();        assertEquals(0, r.clone().assign(Functions.ABS).minus(rRef.clone().assign(Functions.ABS)).aggregate(Functions.PLUS, Functions.IDENTITY), 1.0e-12);    Matrix qRef = reshape(new double[] { -0.165178287646573, 0.0510035857637869, 0.13985915987379, -0.120173729496501, -0.453198314345324, 0.644400679630493, -0.503117990820608, 0.24968739845381, 0.323968339146224, -0.465266080134262, 0.276508948773268, -0.687909700644343, 0.0544048888907195, -0.0166677718378263, 0.171309755790717, 0.310339001630029, 0.674790532821663, 0.0058166082200493, -0.381707516461884, 0.300504956413142, -0.105751091334003, 0.410450870871096, 0.31113446615821, 0.179338172684956, 0.361951807617901, 0.763921725548796, 0.380327892605634, -0.287274944594054, 0.0311604042556675, 0.0386096858143961, 0.0387156960650472, -0.232975755728917, 0.0358178276684149, 0.173105775703199, 0.327321867815603, 0.328671945345279, -0.36015879836344, -0.444261660176044, 0.09438499563253, 0.646216148583769 }, 8, 5);    printMatrix("qRef", qRef);    Matrix q = qr.getQ();    printMatrix("q", q);    assertEquals(0, q.clone().assign(Functions.ABS).minus(qRef.clone().assign(Functions.ABS)).aggregate(Functions.PLUS, Functions.IDENTITY), 1.0e-12);    Matrix x1 = qr.solve(reshape(new double[] { -0.0178247686747641, 0.68631714634098, -0.335464858468858, 1.50249941751569, -0.669901640772149, -0.977025038942455, -1.18857546169856, -1.24792900492054 }, 8, 1));    Matrix xref = reshape(new double[] { -0.0127440093664874, 0.655825940180799, -0.100755415991702, -0.0349559562697406, -0.190744297762028 }, 5, 1);    printMatrix("x1", x1);    printMatrix("xref", xref);    assertEquals(xref, x1, 1.0e-8);}
de3dd534ad4e468d3dcc0927166ec69d8c055ec4bce2ec38eafd2b5e8ed6ba2d
fullRankWide
public void fullRankWide()
{    Matrix x = matrix().transpose();    QRDecomposition qr = new QRDecomposition(x);    assertTrue(qr.hasFullRank());    Matrix rActual = qr.getR();    Matrix rRef = reshape(new double[] { -2.42812464965842, 0, 0, 0, 0, 0.303587286111356, -2.91663643494775, 0, 0, 0, -0.201812474153156, -0.765485720168378, 1.09989373598954, 0, 0, 1.47980701097885, -0.637545820524326, -1.55519859337935, 0.844655127991726, 0, 0.0248883129453161, 0.00115010570270549, -0.236340588891252, -0.092924118200147, 1.42910099545547, -1.1678472412429, 0.531245845248056, 0.351978196071514, -1.03241474816555, -2.20223861735426, -0.887809959067632, 0.189731251982918, -0.504321849233586, 0.490484123999836, 1.21266692336743, -0.633888169775463, 1.04738559065986, 0.284041239547031, 0.578183510077156, -0.942314870832456 }, 5, 8);    printMatrix("rRef", rRef);    printMatrix("rActual", rActual);    assertEquals(0, rActual.clone().assign(Functions.ABS).minus(rRef.clone().assign(Functions.ABS)).aggregate(Functions.PLUS, Functions.IDENTITY), 1.0e-12);        Matrix qRef = reshape(new double[] { -0.203489262374627, 0.316761677948356, -0.784155643293468, 0.394321494579, -0.29641971170211, 0.0311283614803723, -0.34755265020736, 0.137138511478328, 0.848579887681972, 0.373287266507375, -0.39603700561249, -0.787812566647329, -0.377864833067864, -0.275080943427399, 0.0636764674878229, 0.0763976893309043, -0.318551137554327, 0.286407036668598, 0.206004127289883, -0.876482672226889, 0.89159476695423, -0.238213616975551, -0.376141107880836, -0.0794701657055114, 0.0227025098210165 }, 5, 5);    Matrix q = qr.getQ();    printMatrix("qRef", qRef);    printMatrix("q", q);    assertEquals(0, q.clone().assign(Functions.ABS).minus(qRef.clone().assign(Functions.ABS)).aggregate(Functions.PLUS, Functions.IDENTITY), 1.0e-12);        Matrix x1 = qr.solve(b());    Matrix xRef = reshape(new double[] { -0.182580239668147, -0.437233627652114, 0.138787653097464, 0.672934739896228, -0.131420217069083, 0, 0, 0 }, 8, 1);    printMatrix("xRef", xRef);    printMatrix("x", x1);    assertEquals(xRef, x1, 1.0e-8);    assertEquals(x, qr.getQ().times(qr.getR()), 1.0e-15);}
53f642e4e012b8fb9f9163858a38040e7d6965f6a2bfe5dd92b8e24b991ee951
fasterThanBefore
public void fasterThanBefore()
{    OnlineSummarizer s1 = new OnlineSummarizer();    OnlineSummarizer s2 = new OnlineSummarizer();    Matrix a = new DenseMatrix(60, 60).assign(Functions.random());    decompositionSpeedCheck(new Decomposer() {        @Override        public QR decompose(Matrix a) {            return new QRDecomposition(a);        }    }, s1, a, "new");    decompositionSpeedCheck(new Decomposer() {        @Override        public QR decompose(Matrix a) {            return new OldQRDecomposition(a);        }    }, s2, a, "old");        System.out.printf("Speedup is about %.1f times\n", s2.getMean() / s1.getMean());    assertTrue(s1.getMean() < 0.5 * s2.getMean());}
7b15ce656e55303560460aa9dd56279daf34b692a5892c5580c248252c93d976
decompose
public QR decompose(Matrix a)
{    return new QRDecomposition(a);}
7b15ce656e55303560460aa9dd56279daf34b692a5892c5580c248252c93d976
decompose
public QR decompose(Matrix a)
{    return new OldQRDecomposition(a);}
31bd6e9c595e1ec38ae5b9f4cbaa81db7a1e23a09d043ebced3898e4f646190e
decompositionSpeedCheck
private static void decompositionSpeedCheck(Decomposer qrf, OnlineSummarizer s1, Matrix a, String label)
{    int n = 0;    List<Integer> counts = Lists.newArrayList(10, 20, 50, 100, 200, 500);    for (int k : counts) {        double warmup = 0;        double other = 0;        n += k;        for (int i = 0; i < k; i++) {            QR qr = qrf.decompose(a);            warmup = Math.max(warmup, qr.getQ().transpose().times(qr.getQ()).viewDiagonal().assign(Functions.plus(-1)).norm(1));            Matrix z = qr.getQ().times(qr.getR()).minus(a);            other = Math.max(other, z.aggregate(Functions.MIN, Functions.ABS));        }        double maxIdent = 0;        double maxError = 0;        long t0 = System.nanoTime();        for (int i = 0; i < n; i++) {            QR qr = qrf.decompose(a);            maxIdent = Math.max(maxIdent, qr.getQ().transpose().times(qr.getQ()).viewDiagonal().assign(Functions.plus(-1)).norm(1));            Matrix z = qr.getQ().times(qr.getR()).minus(a);            maxError = Math.max(maxError, z.aggregate(Functions.MIN, Functions.ABS));        }        long t1 = System.nanoTime();        if (k > 100) {            s1.add(t1 - t0);        }        System.out.printf("%s %d\t%.1f\t%g\t%g\t%g\n", label, n, (t1 - t0) / 1.0e3 / n, maxIdent, maxError, warmup);    }}
39045410ebca98a1c7ab5907e14d5959aa2843dd082afc1044815b9adb7a8c1c
assertEquals
private static void assertEquals(Matrix ref, Matrix actual, double epsilon)
{    assertEquals(0, ref.minus(actual).aggregate(Functions.MAX, Functions.ABS), epsilon);}
7ca5216066be68cd5642f0484a8ffec44d9390fffec392e028a5b7af2195bc80
printMatrix
private static void printMatrix(String name, Matrix m)
{    int rows = m.numRows();    int columns = m.numCols();    System.out.printf("%s - %d x %d\n", name, rows, columns);    for (int i = 0; i < rows; i++) {        for (int j = 0; j < columns; j++) {            System.out.printf("%10.5f", m.get(i, j));        }        System.out.printf("\n");    }    System.out.printf("\n");    System.out.printf("\n");}
d7b68c4a0d4b7ada22e4069456270685d72b332432349e8d145c8eb6e4bbd5bc
matrix
private static Matrix matrix()
{    double[] values = { 0.494097293912641, -0.152566866170993, -0.418360266395271, 0.359475300232312, 1.35565069667582, -1.92759373242903, 1.50497526839076, -0.746889132087904, -0.769136838293565, 1.10984954080986, -0.664389974392489, 1.6464660350229, -0.11715420616969, 0.0216221197371269, -0.394972730980765, -0.748293157213142, 1.90402764664962, -0.638042862848559, -0.362336344669668, -0.418261074380526, -0.494211543128429, 1.38828971158414, 0.597110366867923, 1.05341387608687, -0.957461740877418, -2.35528802598249, -1.03171458944128, 0.644319090271635, -0.0569108993041965, -0.14419465550881, -0.0456801828174936, 0.754694392571835, 0.719744008628535, -1.17873249802301, -0.155887528905918, -1.5159868405466, 0.0918931582603128, 1.42179027361583, -0.100495054250176, 0.0687986548485584 };    return reshape(values, 8, 5);}
01198f1d810eaa8b2115ec04988e4fdb219d23e21f9378a3437aa733a025a8a1
reshape
private static Matrix reshape(double[] values, int rows, int columns)
{    Matrix m = new DenseMatrix(rows, columns);    int i = 0;    for (double v : values) {        m.set(i % rows, i / rows, v);        i++;    }    return m;}
be80d004bdc442a379c2089169aa840518e0a4b0a84be18f67d2c24d8d789b8c
b
private static Matrix b()
{    return reshape(new double[] { -0.0178247686747641, 0.68631714634098, -0.335464858468858, 1.50249941751569, -0.669901640772149 }, 5, 1);}
a72b97a48ef002f005a162ca0f77bd842e19f6e5e0c56359c179368819d75925
testDepth
public void testDepth()
{    List<Integer> totals = Lists.newArrayList();    for (int i = 0; i < 1000; i++) {        ChineseRestaurant x = new ChineseRestaurant(10);        Multiset<Integer> counts = HashMultiset.create();        for (int j = 0; j < 100; j++) {            counts.add(x.sample());        }        List<Integer> tmp = Lists.newArrayList();        for (Integer k : counts.elementSet()) {            tmp.add(counts.count(k));        }        Collections.sort(tmp, Collections.reverseOrder());        while (totals.size() < tmp.size()) {            totals.add(0);        }        int j = 0;        for (Integer k : tmp) {            totals.set(j, totals.get(j) + k);            j++;        }    }        assertEquals(25000.0, (double) totals.get(0), 1000);    assertEquals(24000.0, (double) totals.get(1), 1000);    assertEquals(8000.0, (double) totals.get(2), 200);    assertEquals(1000.0, (double) totals.get(15), 50);    assertEquals(1000.0, (double) totals.get(20), 40);}
7073e1f1b4c94dd0571e5903b8d8c9095b03870f10e2a11a55a4a1be9f07f436
testExtremeDiscount
public void testExtremeDiscount()
{    ChineseRestaurant x = new ChineseRestaurant(100, 1);    Multiset<Integer> counts = HashMultiset.create();    for (int i = 0; i < 10000; i++) {        counts.add(x.sample());    }    assertEquals(10000, x.size());    for (int i = 0; i < 10000; i++) {        assertEquals(1, x.count(i));    }}
54d531f91b179a16d730ffe206cbf8fe136e7b51df61ee6c528c165fe341c7b7
testGrowth
public void testGrowth()
{    ChineseRestaurant s0 = new ChineseRestaurant(10, 0.0);    ChineseRestaurant s5 = new ChineseRestaurant(10, 0.5);    ChineseRestaurant s9 = new ChineseRestaurant(10, 0.9);    Set<Double> splits = ImmutableSet.of(1.0, 1.5, 2.0, 3.0, 5.0, 8.0);    double offset0 = 0;    int k = 0;    int i = 0;    Matrix m5 = new DenseMatrix(20, 3);    Matrix m9 = new DenseMatrix(20, 3);    while (i <= 200000) {        double n = i / Math.pow(10, Math.floor(Math.log10(i)));        if (splits.contains(n)) {                        if (i > 900) {                double predict5 = predictSize(m5.viewPart(0, k, 0, 3), i, 0.5);                assertEquals(predict5, Math.log(s5.size()), 1);                double predict9 = predictSize(m9.viewPart(0, k, 0, 3), i, 0.9);                assertEquals(predict9, Math.log(s9.size()), 1);                        } else if (i > 50) {                double x = 10.5 * Math.log(i) - s0.size();                m5.viewRow(k).assign(new double[] { Math.log(s5.size()), Math.log(i), 1 });                m9.viewRow(k).assign(new double[] { Math.log(s9.size()), Math.log(i), 1 });                k++;                offset0 += (x - offset0) / k;            }            if (i > 10000) {                assertEquals(0.0, (double) hapaxCount(s0) / s0.size(), 0.25);                assertEquals(0.5, (double) hapaxCount(s5) / s5.size(), 0.1);                assertEquals(0.9, (double) hapaxCount(s9) / s9.size(), 0.05);            }        }        s0.sample();        s5.sample();        s9.sample();        i++;    }}
4f30a6d5bc1de07fdd2f9fd37fa3482369f7f57fa1752ccbd91edc82daf22673
predictSize
private static double predictSize(Matrix m, int currentIndex, double expectedCoefficient)
{    int rows = m.rowSize();    Matrix a = m.viewPart(0, rows, 1, 2);    Matrix b = m.viewPart(0, rows, 0, 1);    Matrix ata = a.transpose().times(a);    Matrix atb = a.transpose().times(b);    QRDecomposition s = new QRDecomposition(ata);    Matrix r = s.solve(atb).transpose();    assertEquals(expectedCoefficient, r.get(0, 0), 0.2);    return r.times(new DenseVector(new double[] { Math.log(currentIndex), 1 })).get(0);}
156b197229e639198745fc989582774b242eade5674e01b1bc3ee3b8f786a456
hapaxCount
private static int hapaxCount(ChineseRestaurant s)
{    int r = 0;    for (int i = 0; i < s.size(); i++) {        if (s.count(i) == 1) {            r++;        }    }    return r;}
a84f668b0e1a413e9c01fdab9f91b7d42d3a2820b84b95adbd043fdb78074620
testSimpleDist
public void testSimpleDist()
{    RandomUtils.useTestSeed();    Empirical z = new Empirical(true, true, 3, 0, 1, 0.5, 2, 1, 3.0);    List<Double> r = Lists.newArrayList();    for (int i = 0; i < 10001; i++) {        r.add(z.sample());    }    Collections.sort(r);    assertEquals(2.0, r.get(5000), 0.15);}
08e8c9fbf85147baeffdfe0fac4ea708f88ecd7df982aa36914044cbf2ac4634
testZeros
public void testZeros()
{    Empirical z = new Empirical(true, true, 3, 0, 1, 0.5, 2, 1, 3.0);    assertEquals(-16.52, z.sample(0), 1.0e-2);    assertEquals(20.47, z.sample(1), 1.0e-2);}
b072f6b694f4ad0f68f7e4c1983472fed48ac500ee060a74391bad45be04fab3
testBadArguments
public void testBadArguments()
{    try {        new Empirical(true, false, 20, 0, 1, 0.5, 2, 0.9, 9, 0.99, 10.0);        Assert.fail("Should have caught that");    } catch (IllegalArgumentException e) {    }    try {        new Empirical(false, true, 20, 0.1, 1, 0.5, 2, 0.9, 9, 1, 10.0);        Assert.fail("Should have caught that");    } catch (IllegalArgumentException e) {    }    try {        new Empirical(true, true, 20, -0.1, 1, 0.5, 2, 0.9, 9, 1, 10.0);        Assert.fail("Should have caught that");    } catch (IllegalArgumentException e) {    }    try {        new Empirical(true, true, 20, 0, 1, 0.5, 2, 0.9, 9, 1.2, 10.0);        Assert.fail("Should have caught that");    } catch (IllegalArgumentException e) {    }    try {        new Empirical(true, true, 20, 0, 1, 0.5, 2, 0.4, 9, 1, 10.0);        Assert.fail("Should have caught that");    } catch (IllegalArgumentException e) {    }}
46ae92a5432fa919dc7ec35be5498d5d56dfae2297a250a50151d198ceb3a3ff
testBasicText
public void testBasicText()
{    RandomUtils.useTestSeed();    IndianBuffet<String> sampler = IndianBuffet.createTextDocumentSampler(30);    Multiset<String> counts = HashMultiset.create();    int[] lengths = new int[100];    for (int i = 0; i < 30; i++) {        final List<String> doc = sampler.sample();        lengths[doc.size()]++;        for (String w : doc) {            counts.add(w);        }        System.out.printf("%s\n", doc);    }}
4adaefafec562702d887f5960a1408e5f9d1add92c42fab7cb857d701c42d2a2
setUp
public void setUp()
{    RandomUtils.useTestSeed();}
ed53e7b2f7dbe22c1fdd5b29a8e73ec68ec9ef2f9bce9f15002826d8f45200b2
testNoValues
public void testNoValues()
{    Multiset<String> emptySet = HashMultiset.create();    new Multinomial<>(emptySet);}
61ff885ce18a89e7a2f63c0d9ae7a0772783e2e8759818888823522f115a49e4
testSingleton
public void testSingleton()
{    Multiset<String> oneThing = HashMultiset.create();    oneThing.add("one");    Multinomial<String> s = new Multinomial<>(oneThing);    assertEquals("one", s.sample(0));    assertEquals("one", s.sample(0.1));    assertEquals("one", s.sample(1));}
71fdcaf8e1606ff90c03c1b6818bdfc2e03ea1689283c04ee8bdc0effe72d177
testEvenSplit
public void testEvenSplit()
{    Multiset<String> stuff = HashMultiset.create();    for (int i = 0; i < 5; i++) {        stuff.add(String.valueOf(i));    }    Multinomial<String> s = new Multinomial<>(stuff);    double EPSILON = 1.0e-15;    Multiset<String> cnt = HashMultiset.create();    for (int i = 0; i < 5; i++) {        cnt.add(s.sample(i * 0.2));        cnt.add(s.sample(i * 0.2 + EPSILON));        cnt.add(s.sample((i + 1) * 0.2 - EPSILON));    }    assertEquals(5, cnt.elementSet().size());    for (String v : cnt.elementSet()) {        assertEquals(3, cnt.count(v), 1.01);    }    assertTrue(cnt.contains(s.sample(1)));    assertEquals(s.sample(1 - EPSILON), s.sample(1));}
408ad490cf0e98a6e43af8a65f5b9bc31dc2a3c0fa8c7ad6f53976fe6140aaa6
testPrime
public void testPrime()
{    List<String> data = Lists.newArrayList();    for (int i = 0; i < 17; i++) {        String s = "0";        if ((i & 1) != 0) {            s = "1";        }        if ((i & 2) != 0) {            s = "2";        }        if ((i & 4) != 0) {            s = "3";        }        if ((i & 8) != 0) {            s = "4";        }        data.add(s);    }    Multiset<String> stuff = HashMultiset.create();    for (String x : data) {        stuff.add(x);    }    Multinomial<String> s0 = new Multinomial<>(stuff);    Multinomial<String> s1 = new Multinomial<>(stuff);    Multinomial<String> s2 = new Multinomial<>(stuff);    double EPSILON = 1.0e-15;    Multiset<String> cnt = HashMultiset.create();    for (int i = 0; i < 50; i++) {        double p0 = i * 0.02;        double p1 = (i + 1) * 0.02;        cnt.add(s0.sample(p0));        cnt.add(s0.sample(p0 + EPSILON));        cnt.add(s0.sample(p1 - EPSILON));        assertEquals(s0.sample(p0), s1.sample(p0));        assertEquals(s0.sample(p0 + EPSILON), s1.sample(p0 + EPSILON));        assertEquals(s0.sample(p1 - EPSILON), s1.sample(p1 - EPSILON));        assertEquals(s0.sample(p0), s2.sample(p0));        assertEquals(s0.sample(p0 + EPSILON), s2.sample(p0 + EPSILON));        assertEquals(s0.sample(p1 - EPSILON), s2.sample(p1 - EPSILON));    }    assertEquals(s0.sample(0), s1.sample(0));    assertEquals(s0.sample(0 + EPSILON), s1.sample(0 + EPSILON));    assertEquals(s0.sample(1 - EPSILON), s1.sample(1 - EPSILON));    assertEquals(s0.sample(1), s1.sample(1));    assertEquals(s0.sample(0), s2.sample(0));    assertEquals(s0.sample(0 + EPSILON), s2.sample(0 + EPSILON));    assertEquals(s0.sample(1 - EPSILON), s2.sample(1 - EPSILON));    assertEquals(s0.sample(1), s2.sample(1));    assertEquals(5, cnt.elementSet().size());            Map<String, Integer> ref = ImmutableMap.of("3", 35, "2", 18, "1", 9, "0", 16, "4", 72);    for (String v : cnt.elementSet()) {        assertTrue(Math.abs(ref.get(v) - cnt.count(v)) <= 2);    }    assertTrue(cnt.contains(s0.sample(1)));    assertEquals(s0.sample(1 - EPSILON), s0.sample(1));}
40165bf1bfc89ee85a97959b5e89d99cd33de41106390260a8684345631968ac
testInsert
public void testInsert()
{    Random rand = RandomUtils.getRandom();    Multinomial<Integer> table = new Multinomial<>();    double[] p = new double[10];    for (int i = 0; i < 10; i++) {        p[i] = rand.nextDouble();        table.add(i, p[i]);    }    checkSelfConsistent(table);    for (int i = 0; i < 10; i++) {        assertEquals(p[i], table.getWeight(i), 0);    }}
5556cbad0dbeb1dbdadb146fc7f42e24509e04d2ee020370ed5810e7b1eb964e
testSetZeroWhileIterating
public void testSetZeroWhileIterating()
{    Multinomial<Integer> table = new Multinomial<>();    for (int i = 0; i < 10000; ++i) {        table.add(i, i);    }        for (Integer sample : table) {        table.set(sample, 0);    }}
62409aeeee3ff14bd2a10a850641abaf76bc64ba865e1e7e5a65d5c2e366f552
testNoNullValuesAllowed
public void testNoNullValuesAllowed()
{    Multinomial<Integer> table = new Multinomial<>();        table.add(null, 1);}
ff0e55b68bd267dd436cecb3e3ba0526d172372f481abc7a25c429ae32d51fde
testDeleteAndUpdate
public void testDeleteAndUpdate()
{    Random rand = RandomUtils.getRandom();    Multinomial<Integer> table = new Multinomial<>();    assertEquals(0, table.getWeight(), 1.0e-9);    double total = 0;    double[] p = new double[10];    for (int i = 0; i < 10; i++) {        p[i] = rand.nextDouble();        table.add(i, p[i]);        total += p[i];        assertEquals(total, table.getWeight(), 1.0e-9);    }    assertEquals(total, table.getWeight(), 1.0e-9);    checkSelfConsistent(table);    double delta = p[7] + p[8];    table.delete(7);    p[7] = 0;    table.set(8, 0);    p[8] = 0;    total -= delta;    checkSelfConsistent(table);    assertEquals(total, table.getWeight(), 1.0e-9);    for (int i = 0; i < 10; i++) {        assertEquals(p[i], table.getWeight(i), 0);        assertEquals(p[i] / total, table.getProbability(i), 1.0e-10);    }    table.set(9, 5.1);    total -= p[9];    p[9] = 5.1;    total += 5.1;    assertEquals(total, table.getWeight(), 1.0e-9);    for (int i = 0; i < 10; i++) {        assertEquals(p[i], table.getWeight(i), 0);        assertEquals(p[i] / total, table.getProbability(i), 1.0e-10);    }    checkSelfConsistent(table);    for (int i = 0; i < 10; i++) {        assertEquals(p[i], table.getWeight(i), 0);    }}
2a55578b9b6a3ff2fa9293985d67b75193296129c8ea71663a48224de42d7cff
checkSelfConsistent
private static void checkSelfConsistent(Multinomial<Integer> table)
{    List<Double> weights = table.getWeights();    double totalWeight = table.getWeight();    double p = 0;    int[] k = new int[weights.size()];    for (double weight : weights) {        if (weight > 0) {            if (p > 0) {                k[table.sample(p - 1.0e-9)]++;            }            k[table.sample(p + 1.0e-9)]++;        }        p += weight / totalWeight;    }    k[table.sample(p - 1.0e-9)]++;    assertEquals(1, p, 1.0e-9);    for (int i = 0; i < weights.size(); i++) {        if (table.getWeight(i) > 0) {            assertEquals(2, k[i]);        } else {            assertEquals(0, k[i]);        }    }}
4adaefafec562702d887f5960a1408e5f9d1add92c42fab7cb857d701c42d2a2
setUp
public void setUp()
{    RandomUtils.useTestSeed();}
d95bd5846278804881dacbab50a6e4bb24223dc11fbd761ed7e90bb7d7c6d5df
testDiagonal
public void testDiagonal()
{    DenseVector offset = new DenseVector(new double[] { 6, 3, 0 });    MultiNormal n = new MultiNormal(new DenseVector(new double[] { 1, 2, 5 }), offset);    OnlineSummarizer[] s = { new OnlineSummarizer(), new OnlineSummarizer(), new OnlineSummarizer() };    OnlineSummarizer[] cross = { new OnlineSummarizer(), new OnlineSummarizer(), new OnlineSummarizer() };    for (int i = 0; i < 10000; i++) {        Vector v = n.sample();        for (int j = 0; j < 3; j++) {            s[j].add(v.get(j) - offset.get(j));            int k1 = j % 2;            int k2 = (j + 1) / 2 + 1;            cross[j].add((v.get(k1) - offset.get(k1)) * (v.get(k2) - offset.get(k2)));        }    }    for (int j = 0; j < 3; j++) {        assertEquals(0, s[j].getMean() / s[j].getSD(), 0.04);        assertEquals(0, cross[j].getMean() / cross[j].getSD(), 0.04);    }}
e768539b269168efa476e778e637c34e93b336788a6a402338c1638ee5032767
testRadius
public void testRadius()
{    MultiNormal gen = new MultiNormal(0.1, new DenseVector(10));    OnlineSummarizer s = new OnlineSummarizer();    for (int i = 0; i < 10000; i++) {        double x = gen.sample().norm(2) / Math.sqrt(10);        s.add(x);    }    assertEquals(0.1, s.getMean(), 0.01);}
4adaefafec562702d887f5960a1408e5f9d1add92c42fab7cb857d701c42d2a2
setUp
public void setUp()
{    RandomUtils.useTestSeed();}
67510355a409fd9517e8c79409d20839885a2c1c8856a8b881fa294ac8ff7cab
testOffset
public void testOffset()
{    OnlineSummarizer s = new OnlineSummarizer();    Sampler<Double> sampler = new Normal(2, 5);    for (int i = 0; i < 10001; i++) {        s.add(sampler.sample());    }    assertEquals(String.format("m = %.3f, sd = %.3f", s.getMean(), s.getSD()), 2, s.getMean(), 0.04 * s.getSD());    assertEquals(5, s.getSD(), 0.12);}
6debd6c0cae25268e9e899d06529ac6067cd54dda5bbc21049435ee2a2f0a5a1
testSample
public void testSample() throws Exception
{    double[] data = new double[10001];    Sampler<Double> sampler = new Normal();    for (int i = 0; i < data.length; i++) {        data[i] = sampler.sample();    }    Arrays.sort(data);    NormalDistribution reference = new NormalDistribution(RandomUtils.getRandom().getRandomGenerator(), 0, 1, NormalDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY);    assertEquals("Median", reference.inverseCumulativeProbability(0.5), data[5000], 0.04);}
4adaefafec562702d887f5960a1408e5f9d1add92c42fab7cb857d701c42d2a2
setUp
public void setUp()
{    RandomUtils.useTestSeed();}
0b309a742a08b61f932d92aa0ff7edc89c85d011d923a9d9fc6e79b18b165775
testBasics
public void testBasics()
{    for (double alpha : new double[] { 0.1, 1, 10, 100 }) {        checkDistribution(new PoissonSampler(alpha), alpha);    }}
9868aa7f90274e14c9982138bdb1a33823fa155455a004f8b1e5c1973f3671c7
checkDistribution
private static void checkDistribution(Sampler<Double> pd, double alpha)
{    int[] count = new int[(int) Math.max(10, 5 * alpha)];    for (int i = 0; i < 10000; i++) {        count[pd.sample().intValue()]++;    }    IntegerDistribution ref = new PoissonDistribution(RandomUtils.getRandom().getRandomGenerator(), alpha, PoissonDistribution.DEFAULT_EPSILON, PoissonDistribution.DEFAULT_MAX_ITERATIONS);    for (int i = 0; i < count.length; i++) {        assertEquals(ref.probability(i), count[i] / 10000.0, 2.0e-2);    }}
5e756df9553e8327d77e275278d06baa322617fa65d8cf3bffa0e093318e80cc
testAgainstReferenceOpenObjectIntHashMap
public void testAgainstReferenceOpenObjectIntHashMap()
{    OpenObjectIntHashMap<Integer> base = new OpenObjectIntHashMap<>();    Map<Integer, Integer> reference = new HashMap<>();    List<Operation> ops = Lists.newArrayList();    addOp(ops, Operation.ADD, 60);    addOp(ops, Operation.REMOVE, 30);    addOp(ops, Operation.INDEXOF, 30);    addOp(ops, Operation.CLEAR, 5);    addOp(ops, Operation.ISEMPTY, 2);    addOp(ops, Operation.SIZE, 2);    int max = randomIntBetween(1000, 20000);    for (int reps = 0; reps < max; reps++) {                int k = randomIntBetween(0, max / 4);        int v = randomInt();        switch(randomFrom(ops)) {            case ADD:                assertEquals(reference.put(k, v) == null, base.put(k, v));                break;            case REMOVE:                assertEquals(reference.remove(k) != null, base.removeKey(k));                break;            case INDEXOF:                assertEquals(reference.containsKey(k), base.containsKey(k));                break;            case CLEAR:                reference.clear();                base.clear();                break;            case ISEMPTY:                assertEquals(reference.isEmpty(), base.isEmpty());                break;            case SIZE:                assertEquals(reference.size(), base.size());                break;            default:                throw new RuntimeException();        }    }}
e944c1effd847589cf802c2ce9f0732c45a97e1d6883818700814dca3e343ea3
testAgainstReferenceOpenIntObjectHashMap
public void testAgainstReferenceOpenIntObjectHashMap()
{    OpenIntObjectHashMap<Integer> base = new OpenIntObjectHashMap<>();    Map<Integer, Integer> reference = new HashMap<>();    List<Operation> ops = Lists.newArrayList();    addOp(ops, Operation.ADD, 60);    addOp(ops, Operation.REMOVE, 30);    addOp(ops, Operation.INDEXOF, 30);    addOp(ops, Operation.CLEAR, 5);    addOp(ops, Operation.ISEMPTY, 2);    addOp(ops, Operation.SIZE, 2);    int max = randomIntBetween(1000, 20000);    for (int reps = 0; reps < max; reps++) {                int k = randomIntBetween(0, max / 4);        int v = randomInt();        switch(randomFrom(ops)) {            case ADD:                assertEquals(reference.put(k, v) == null, base.put(k, v));                break;            case REMOVE:                assertEquals(reference.remove(k) != null, base.removeKey(k));                break;            case INDEXOF:                assertEquals(reference.containsKey(k), base.containsKey(k));                break;            case CLEAR:                reference.clear();                base.clear();                break;            case ISEMPTY:                assertEquals(reference.isEmpty(), base.isEmpty());                break;            case SIZE:                assertEquals(reference.size(), base.size());                break;            default:                throw new RuntimeException();        }    }}
f5d1d256e700450d1078e9ba6a859f58a8053309c16294d39a538f6fd95e69ee
testAgainstReferenceOpenIntIntHashMap
public void testAgainstReferenceOpenIntIntHashMap()
{    OpenIntIntHashMap base = new OpenIntIntHashMap();    HashMap<Integer, Integer> reference = new HashMap<>();    List<Operation> ops = Lists.newArrayList();    addOp(ops, Operation.ADD, 60);    addOp(ops, Operation.REMOVE, 30);    addOp(ops, Operation.INDEXOF, 30);    addOp(ops, Operation.CLEAR, 5);    addOp(ops, Operation.ISEMPTY, 2);    addOp(ops, Operation.SIZE, 2);    int max = randomIntBetween(1000, 20000);    for (int reps = 0; reps < max; reps++) {                int k = randomIntBetween(0, max / 4);        int v = randomInt();        switch(randomFrom(ops)) {            case ADD:                Integer prevValue = reference.put(k, v);                if (prevValue == null) {                    assertEquals(true, base.put(k, v));                } else {                    assertEquals(prevValue.intValue(), base.get(k));                    assertEquals(false, base.put(k, v));                }                break;            case REMOVE:                assertEquals(reference.containsKey(k), base.containsKey(k));                Integer removed = reference.remove(k);                if (removed == null) {                    assertEquals(false, base.removeKey(k));                } else {                    assertEquals(removed.intValue(), base.get(k));                    assertEquals(true, base.removeKey(k));                }                break;            case INDEXOF:                assertEquals(reference.containsKey(k), base.containsKey(k));                break;            case CLEAR:                reference.clear();                base.clear();                break;            case ISEMPTY:                assertEquals(reference.isEmpty(), base.isEmpty());                break;            case SIZE:                assertEquals(reference.size(), base.size());                break;            default:                throw new RuntimeException();        }    }}
3ff99ca25cfdc3ebf43d55cbc2f470dcef2c587ffe5a1b5c347a331861620464
testAgainstReferenceOpenIntHashSet
public void testAgainstReferenceOpenIntHashSet()
{    AbstractIntSet base = new OpenIntHashSet();    HashSet<Integer> reference = Sets.newHashSet();    List<Operation> ops = Lists.newArrayList();    addOp(ops, Operation.ADD, 60);    addOp(ops, Operation.REMOVE, 30);    addOp(ops, Operation.INDEXOF, 30);    addOp(ops, Operation.CLEAR, 5);    addOp(ops, Operation.ISEMPTY, 2);    addOp(ops, Operation.SIZE, 2);    int max = randomIntBetween(1000, 20000);    for (int reps = 0; reps < max; reps++) {                int k = randomIntBetween(0, max / 4);        switch(randomFrom(ops)) {            case ADD:                assertEquals(reference.add(k), base.add(k));                break;            case REMOVE:                assertEquals(reference.remove(k), base.remove(k));                break;            case INDEXOF:                assertEquals(reference.contains(k), base.contains(k));                break;            case CLEAR:                reference.clear();                base.clear();                break;            case ISEMPTY:                assertEquals(reference.isEmpty(), base.isEmpty());                break;            case SIZE:                assertEquals(reference.size(), base.size());                break;            default:                throw new RuntimeException();        }    }}
6418895fdeaa6fdbd1ffb570013abcaad681ff35954aac4b0965f487a036175a
testAgainstReferenceOpenHashSet
public void testAgainstReferenceOpenHashSet()
{    Set<Integer> base = new OpenHashSet<>();    Set<Integer> reference = Sets.newHashSet();    List<Operation> ops = Lists.newArrayList();    addOp(ops, Operation.ADD, 60);    addOp(ops, Operation.REMOVE, 30);    addOp(ops, Operation.INDEXOF, 30);    addOp(ops, Operation.CLEAR, 5);    addOp(ops, Operation.ISEMPTY, 2);    addOp(ops, Operation.SIZE, 2);    int max = randomIntBetween(1000, 20000);    for (int reps = 0; reps < max; reps++) {                int k = randomIntBetween(0, max / 4);        switch(randomFrom(ops)) {            case ADD:                assertEquals(reference.contains(k), base.contains(k));                break;            case REMOVE:                assertEquals(reference.remove(k), base.remove(k));                break;            case INDEXOF:                assertEquals(reference.contains(k), base.contains(k));                break;            case CLEAR:                reference.clear();                base.clear();                break;            case ISEMPTY:                assertEquals(reference.isEmpty(), base.isEmpty());                break;            case SIZE:                assertEquals(reference.size(), base.size());                break;            default:                throw new RuntimeException();        }    }}
32d2c2081de824eb70f7d8b18af326f1a6607f5f23c4c999f221dd5c29896e06
testMahout1225
public void testMahout1225()
{    AbstractIntSet s = new OpenIntHashSet();    s.clear();    s.add(23);    s.add(46);    s.clear();    s.add(70);    s.add(93);    s.contains(100);}
6c523b9cef87f1c64c0e54113f4d6ad7a213bdd8eb5d145cba94e52ec7f748ec
testClearTable
public void testClearTable() throws Exception
{    OpenObjectIntHashMap<Integer> m = new OpenObjectIntHashMap<>();        m.clear();    m.put(1, 2);        m.clear();    Field tableField = m.getClass().getDeclaredField("table");    tableField.setAccessible(true);    Object[] table = (Object[]) tableField.get(m);    assertEquals(Sets.newHashSet(Arrays.asList(new Object[] { null })), Sets.newHashSet(Arrays.asList(table)));}
3f9dc33f3fe4c1905f9cfa52f5f9f7fb9757557b2c6c63aed6be743bc2e2b7b2
addOp
private static void addOp(List<Operation> ops, Operation op, int reps)
{    for (int i = 0; i < reps; i++) {        ops.add(op);    }}
b2b244672a0fca1e3f49a5dc431ae248a8254d68781961b878f197735ad1f77f
testHashFloat
public void testHashFloat()
{    Multiset<Integer> violations = HashMultiset.create();    for (int k = 0; k < 1000; k++) {        List<Float> original = Lists.newArrayList();        Random gen = RandomUtils.getRandom();        for (int i = 0; i < 10000; i++) {            float x = (float) gen.nextDouble();            original.add(x);        }        violations.add(checkCounts(original) <= 12 ? 0 : 1);    }            assertTrue(violations.count(0) >= 985);}
6de070a13805e12451437dccb343b1f87f5dbbacc38d8cec6ffc95f710fc163f
testHashDouble
public void testHashDouble()
{    List<Double> original = Lists.newArrayList();    for (int k = 0; k < 10; k++) {        Random gen = RandomUtils.getRandom();        for (int i = 0; i < 10000; i++) {            double x = gen.nextDouble();            original.add(x);        }        checkCounts(original);    }}
a3ff98480197a5bc592875c326e14050c0d647e4d1c04d8768a47a1d347cf8ed
testHashLong
public void testHashLong()
{    List<Long> original = Lists.newArrayList();    for (int k = 0; k < 10; k++) {        Random gen = RandomUtils.getRandom();        for (int i = 0; i < 10000; i++) {            long x = gen.nextLong();            original.add(x);        }        checkCounts(original);    }}
45b37c5c7d1b6fb9250c4441e4f0edde22751df90c2b480650aebff413c636dc
checkCounts
private static int checkCounts(Collection<T> original)
{    Multiset<T> hashCounts = HashMultiset.create();    for (T v : original) {        hashCounts.add(v);    }    Multiset<Integer> countCounts = HashMultiset.create();    for (T hash : hashCounts) {        countCounts.add(hashCounts.count(hash));    }    return original.size() - countCounts.count(1);}
963524c24987ba5bc1d23bf56ce2d8e8490a7d2fe33a69b8caa88a42b6f58a46
testDegenerateMatrix
public void testDegenerateMatrix()
{    double[][] m = { new double[] { 0.641284, 0.767303, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000 }, new double[] { 0.767303, 3.050159, 2.561342, 0.000000, 0.000000, 0.000000, 0.000000 }, new double[] { 0.000000, 2.561342, 5.000609, 0.810507, 0.000000, 0.000000, 0.000000 }, new double[] { 0.000000, 0.000000, 0.810507, 0.550477, 0.142853, 0.000000, 0.000000 }, new double[] { 0.000000, 0.000000, 0.000000, 0.142853, 0.254566, 0.000000, 0.000000 }, new double[] { 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.256073, 0.000000 }, new double[] { 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000 } };    Matrix x = new DenseMatrix(m);    EigenDecomposition eig = new EigenDecomposition(x, true);    Matrix d = eig.getD();    Matrix v = eig.getV();    check("EigenvalueDecomposition (evil)...", x.times(v), v.times(d));}
fdb7bbcbb8e25d969198a988b5be516f0194fb68fe713d6fa40b7a273be8ab58
testDeficientRank
public void testDeficientRank()
{    Matrix a = new DenseMatrix(10, 3).assign(new DoubleFunction() {        private final Random gen = RandomUtils.getRandom();        @Override        public double apply(double arg1) {            return gen.nextGaussian();        }    });    a = a.transpose().times(a);    EigenDecomposition eig = new EigenDecomposition(a);    Matrix d = eig.getD();    Matrix v = eig.getV();    check("EigenvalueDecomposition (rank deficient)...", a.times(v), v.times(d));    Assert.assertEquals(0, eig.getImagEigenvalues().norm(1), 1.0e-10);    Assert.assertEquals(3, eig.getRealEigenvalues().norm(0), 1.0e-10);}
685ca82cead33e56c75cad5ace5f3cba2e4e471d0dcc68359527832073e7cdd4
apply
public double apply(double arg1)
{    return gen.nextGaussian();}
813fdaa0aa2ba12dc94150c8d18b6bb699e4f73e4333bb5d92bbc451ee3d5011
testEigen
public void testEigen()
{    double[] evals = { 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 2.0e-7, 0.0, 0.0, -2.0e-7, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0 };    int i = 0;    Matrix a = new DenseMatrix(4, 4);    for (MatrixSlice row : a) {        for (Vector.Element element : row.vector().all()) {            element.set(evals[i++]);        }    }    EigenDecomposition eig = new EigenDecomposition(a);    Matrix d = eig.getD();    Matrix v = eig.getV();    check("EigenvalueDecomposition (nonsymmetric)...", a.times(v), v.times(d));}
1df42eb1ce3ac66db1ab57fae9adc743783469286267d5b21e37b9943255acb7
testSequential
public void testSequential()
{    int validld = 3;    Matrix A = new DenseMatrix(validld, validld);    double[] columnwise = { 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0 };    int i = 0;    for (MatrixSlice row : A) {        for (Vector.Element element : row.vector().all()) {            element.set(columnwise[i++]);        }    }    EigenDecomposition Eig = new EigenDecomposition(A);    Matrix D = Eig.getD();    Matrix V = Eig.getV();    check("EigenvalueDecomposition (nonsymmetric)...", A.times(V), V.times(D));    A = A.transpose().times(A);    Eig = new EigenDecomposition(A);    D = Eig.getD();    V = Eig.getV();    check("EigenvalueDecomposition (symmetric)...", A.times(V), V.times(D));}
88476df1f5813b6c06320a43b5172be7949e09960251c4130d03863a8b61199e
check
private static void check(String msg, Matrix a, Matrix b)
{    Assert.assertEquals(msg, 0, a.minus(b).aggregate(Functions.PLUS, Functions.ABS), 1.0e-10);}
7c67b2472c8f6db39d170771f0705f104ac70f2133739a01a78d2da40a67354f
basics
public void basics()
{    Matrix m = hilbert(5);        assertEquals(1, m.get(0, 0), 0);    assertEquals(0.5, m.get(0, 1), 0);    assertEquals(1 / 6.0, m.get(2, 3), 1.0e-9);    Vector x = new DenseVector(new double[] { 5, -120, 630, -1120, 630 });    Vector b = new DenseVector(5);    b.assign(1);    assertEquals(0, m.times(x).minus(b).norm(2), 1.0e-9);    LSMR r = new LSMR();    Vector x1 = r.solve(m, b);                            assertEquals(0, m.times(x1).minus(b).norm(2), 1.0e-2);    assertEquals(0, m.transpose().times(m).times(x1).minus(m.transpose().times(b)).norm(2), 1.0e-7);        assertEquals(m.times(x1).minus(b).norm(2), r.getResidualNorm(), 1.0e-5);    assertEquals(m.transpose().times(m).times(x1).minus(m.transpose().times(b)).norm(2), r.getNormalEquationResidual(), 1.0e-9);}
164bdf23a9379f30dd567d07eb25d10925d75a1e47602cc4cc32d367e5247988
random
public void random()
{    Matrix m = new DenseMatrix(200, 30).assign(Functions.random());    Vector b = new DenseVector(200).assign(1);    LSMR r = new LSMR();    Vector x1 = r.solve(m, b);        double norm = new SingularValueDecomposition(m).getS().viewDiagonal().norm(2);    double actual = m.transpose().times(m).times(x1).minus(m.transpose().times(b)).norm(2);    System.out.printf("%.4f\n", actual / norm * 1.0e6);    assertEquals(0, actual, norm * 1.0e-5);        assertEquals(m.times(x1).minus(b).norm(2), r.getResidualNorm(), 1.0e-5);    assertEquals(actual, r.getNormalEquationResidual(), 1.0e-9);}
ef4d6fd21310a8fc1087cc994bd16905d6c536ccb8134bf6753fb3fe2ad174d5
hilbert
private static Matrix hilbert(int n)
{    Matrix r = new DenseMatrix(n, n);    for (int i = 0; i < n; i++) {        for (int j = 0; j < n; j++) {            r.set(i, j, 1.0 / (i + j + 1));        }    }    return r;}
3f658817a2f80fec9fdc9e0b15dac704a45fc0f9fd407d9e4dcd5388cc01b51b
testConjugateGradientSolver
public void testConjugateGradientSolver()
{    Matrix a = getA();    Vector b = getB();    ConjugateGradientSolver solver = new ConjugateGradientSolver();    Vector x = solver.solve(a, b);    assertEquals(0.0, Math.sqrt(a.times(x).getDistanceSquared(b)), EPSILON);    assertEquals(0.0, solver.getResidualNorm(), ConjugateGradientSolver.DEFAULT_MAX_ERROR);    assertEquals(10, solver.getIterations());}
891da1366719ec7664d57fab6accb75c96f78140a0df61c1690aac84b93bcda3
testConditionedConjugateGradientSolver
public void testConditionedConjugateGradientSolver()
{    Matrix a = getIllConditionedMatrix();    Vector b = getB();    Preconditioner conditioner = new JacobiConditioner(a);    ConjugateGradientSolver solver = new ConjugateGradientSolver();    Vector x = solver.solve(a, b, null, 100, ConjugateGradientSolver.DEFAULT_MAX_ERROR);    double distance = Math.sqrt(a.times(x).getDistanceSquared(b));    assertEquals(0.0, distance, EPSILON);    assertEquals(0.0, solver.getResidualNorm(), ConjugateGradientSolver.DEFAULT_MAX_ERROR);    assertEquals(16, solver.getIterations());    Vector x2 = solver.solve(a, b, conditioner, 100, ConjugateGradientSolver.DEFAULT_MAX_ERROR);        distance = Math.sqrt(a.times(x2).getDistanceSquared(b));    assertEquals(0.0, distance, EPSILON);    assertEquals(0.0, solver.getResidualNorm(), ConjugateGradientSolver.DEFAULT_MAX_ERROR);    assertEquals(15, solver.getIterations());}
53680042fee6ef5c565881e6ebc93b00907cd4f110862c7418bc32ca55552809
testEarlyStop
public void testEarlyStop()
{    Matrix a = getA();    Vector b = getB();    ConjugateGradientSolver solver = new ConjugateGradientSolver();        Vector x = solver.solve(a, b, null, 10, 0.1);    double distance = Math.sqrt(a.times(x).getDistanceSquared(b));    assertTrue(distance > EPSILON);        assertEquals(0.0, distance, 0.1);        assertEquals(7, solver.getIterations());        x = solver.solve(a, b, null, 7, ConjugateGradientSolver.DEFAULT_MAX_ERROR);    distance = Math.sqrt(a.times(x).getDistanceSquared(b));    assertTrue(distance > EPSILON);    assertEquals(0.0, distance, 0.1);    assertEquals(7, solver.getIterations());}
053415fd5d348ff22b57aa3b9a5deec87bad185b15a83efc14704435e3812350
getA
private static Matrix getA()
{    return reshape(new double[] { 11.7155649822793997, -0.7125253363083646, 4.6473613961860183, 1.6020939468348456, -4.6789817799137134, -0.8140416763434970, -4.5995617505618345, -1.1749070042775340, -1.6747995811678336, 3.1922255171058342, -0.7125253363083646, 12.3400579683994867, -2.6498099427000645, 0.5264507222630669, 0.3783428369189767, -2.1170186159188811, 2.3695134252190528, 3.8182131490333013, 6.5285942298270347, 2.8564814419366353, 4.6473613961860183, -2.6498099427000645, 16.1317933921668484, -0.0409475448061225, 1.4805687075608227, -2.9958076484628950, -2.5288893025027264, -0.9614557539842487, -2.2974738351519077, -1.5516184284572598, 1.6020939468348456, 0.5264507222630669, -0.0409475448061225, 4.1946802122694482, -2.5210038046912198, 0.6634899962909317, 0.4036187419205338, -0.2829211393003727, -0.2283091172980954, 1.1253516563552464, -4.6789817799137134, 0.3783428369189767, 1.4805687075608227, -2.5210038046912198, 19.4307361862733430, -2.5200132222091787, 2.3748511971444510, 11.6426598443305522, -0.1508136510863874, 4.3471343888063512, -0.8140416763434970, -2.1170186159188811, -2.9958076484628950, 0.6634899962909317, -2.5200132222091787, 7.6712334419700747, -3.8687773629502851, -3.0453418711591529, -0.1155580876143619, -2.4025459467422121, -4.5995617505618345, 2.3695134252190528, -2.5288893025027264, 0.4036187419205338, 2.3748511971444510, -3.8687773629502851, 10.4681666057470082, 1.6527180866171229, 2.9341795819365384, -2.1708176372763099, -1.1749070042775340, 3.8182131490333013, -0.9614557539842487, -0.2829211393003727, 11.6426598443305522, -3.0453418711591529, 1.6527180866171229, 16.0050616934176233, 1.1689747208793086, 1.6665090945954870, -1.6747995811678336, 6.5285942298270347, -2.2974738351519077, -0.2283091172980954, -0.1508136510863874, -0.1155580876143619, 2.9341795819365384, 1.1689747208793086, 6.4794329751637481, -1.9197339981871877, 3.1922255171058342, 2.8564814419366353, -1.5516184284572598, 1.1253516563552464, 4.3471343888063512, -2.4025459467422121, -2.1708176372763099, 1.6665090945954870, -1.9197339981871877, 18.9149021356344598 }, 10, 10);}
6d522955c96962c9f12c22f8f0c0549bf5a10adab2ef7467d4b36de9ac0557a6
getB
private static Vector getB()
{    return new DenseVector(new double[] { -0.552252, 0.038430, 0.058392, -1.234496, 1.240369, 0.373649, 0.505113, 0.503723, 1.215340, -0.391908 });}
65ab7221fc798b7defbb7cc12c1d5c97e6f9eae3600252ae403446c5cda7d9e7
getIllConditionedMatrix
private static Matrix getIllConditionedMatrix()
{    return reshape(new double[] { 0.00695278043678842, 0.09911830022078683, 0.01309584636255063, 0.00652917453032394, 0.04337631487735064, 0.14232165273321387, 0.05808722912361313, -0.06591965049732287, 0.06055771542862332, 0.00577423310349649, 0.09911830022078683, 1.50071402418061428, 0.14988743575884242, 0.07195514527480981, 0.63747362341752722, 1.30711819020414688, 0.82151609385115953, -0.72616125524587938, 1.03490136002022948, 0.12800239664439328, 0.01309584636255063, 0.14988743575884242, 0.04068462583124965, 0.02147022047006482, 0.07388113580146650, 0.58070223915076002, 0.11280336266257514, -0.21690068430020618, 0.04065087561300068, -0.00876895259593769, 0.00652917453032394, 0.07195514527480981, 0.02147022047006482, 0.01140105250542524, 0.03624164348693958, 0.31291554581393255, 0.05648457235205666, -0.11507583016077780, 0.01475756130709823, -0.00584453679519805, 0.04337631487735064, 0.63747362341752722, 0.07388113580146649, 0.03624164348693959, 0.27491543200760571, 0.73410543168748121, 0.36120630002843257, -0.36583546331208316, 0.41472509341940017, 0.04581458758255480, 0.14232165273321387, 1.30711819020414666, 0.58070223915076002, 0.31291554581393255, 0.73410543168748121, 9.02536073121807014, 1.25426385582883104, -3.16186335125594642, -0.19740140818905436, -0.26613760880058035, 0.05808722912361314, 0.82151609385115953, 0.11280336266257514, 0.05648457235205667, 0.36120630002843257, 1.25426385582883126, 0.48661058451606820, -0.57030511336562195, 0.49151280464818098, 0.04428280690189127, -0.06591965049732286, -0.72616125524587938, -0.21690068430020618, -0.11507583016077781, -0.36583546331208316, -3.16186335125594642, -0.57030511336562195, 1.16270815038078945, -0.14837898963724327, 0.05917203395002889, 0.06055771542862331, 1.03490136002022926, 0.04065087561300068, 0.01475756130709823, 0.41472509341940023, -0.19740140818905436, 0.49151280464818103, -0.14837898963724327, 0.86693820682049716, 0.14089688752570340, 0.00577423310349649, 0.12800239664439328, -0.00876895259593769, -0.00584453679519805, 0.04581458758255480, -0.26613760880058035, 0.04428280690189126, 0.05917203395002889, 0.14089688752570340, 0.02901858439788401 }, 10, 10);}
01198f1d810eaa8b2115ec04988e4fdb219d23e21f9378a3437aa733a025a8a1
reshape
private static Matrix reshape(double[] values, int rows, int columns)
{    Matrix m = new DenseMatrix(rows, columns);    int i = 0;    for (double v : values) {        m.set(i % rows, i / rows, v);        i++;    }    return m;}
d479d9998692a292bd7f82fc651abf323917a3aeb0510bcd43fb9453838c18d8
testSingularValues
public void testSingularValues()
{    Matrix A = lowRankMatrix();    SequentialBigSvd s = new SequentialBigSvd(A, 8);    SingularValueDecomposition svd = new SingularValueDecomposition(A);    Vector reference = new DenseVector(svd.getSingularValues()).viewPart(0, 8);    assertEquals(reference, s.getSingularValues());    assertEquals(A, s.getU().times(new DiagonalMatrix(s.getSingularValues())).times(s.getV().transpose()));}
0eac45b6131080d987ff0f98c4047c8f31a200bd0f832fa40cfbcb367632425c
testLeftVectors
public void testLeftVectors()
{    Matrix A = lowRankMatrix();    SequentialBigSvd s = new SequentialBigSvd(A, 8);    SingularValueDecomposition svd = new SingularValueDecomposition(A);            Matrix u1 = svd.getU().viewPart(0, 20, 0, 4).assign(Functions.ABS);    Matrix u2 = s.getU().viewPart(0, 20, 0, 4).assign(Functions.ABS);    assertEquals(0, u1.minus(u2).aggregate(Functions.PLUS, Functions.ABS), 1.0e-9);}
1deab674d6b17b8c07f5684aae2564bfab75587340c4253efcc115030243e0d7
assertEquals
private static void assertEquals(Matrix u1, Matrix u2)
{    assertEquals(0, u1.minus(u2).aggregate(Functions.MAX, Functions.ABS), 1.0e-10);}
5dc4f76a49366df7a3aa5a1db1c020d904153c67c0b11db65438ad7e0b560f89
assertEquals
private static void assertEquals(Vector u1, Vector u2)
{    assertEquals(0, u1.minus(u2).aggregate(Functions.MAX, Functions.ABS), 1.0e-10);}
e01e8b22131255c3674ae0695e1e2911a3fbdb322bfc076f731f48204ee4c15b
testRightVectors
public void testRightVectors()
{    Matrix A = lowRankMatrix();    SequentialBigSvd s = new SequentialBigSvd(A, 6);    SingularValueDecomposition svd = new SingularValueDecomposition(A);    Matrix v1 = svd.getV().viewPart(0, 20, 0, 3).assign(Functions.ABS);    Matrix v2 = s.getV().viewPart(0, 20, 0, 3).assign(Functions.ABS);    assertEquals(v1, v2);}
d4f6d6066e78391c33888e638538787ce32c456827e3dfc4ae1e7da8f82e4440
lowRankMatrix
private static Matrix lowRankMatrix()
{    Matrix u = new RandomTrinaryMatrix(1, 20, 4, false);    Matrix d = new DiagonalMatrix(new double[] { 5, 3, 1, 0.5 });    Matrix v = new RandomTrinaryMatrix(2, 23, 4, false);    return u.times(d).times(v.transpose());}
b61e4a510ecc32363072248af4f881013ae13dc88209cd38fbaf337225e5c8df
testEntropy
public void testEntropy() throws Exception
{    assertEquals(1.386294, LogLikelihood.entropy(1, 1), 0.0001);    assertEquals(0.0, LogLikelihood.entropy(1), 0.0);        try {                LogLikelihood.entropy(-1, -1);        fail();    } catch (IllegalArgumentException e) {    }}
bc88ae29f0333feff8feb782cbd17010d4db33cd4c838bffa3addc7db615e20c
testLogLikelihood
public void testLogLikelihood() throws Exception
{        assertEquals(2.772589, LogLikelihood.logLikelihoodRatio(1, 0, 0, 1), 0.000001);    assertEquals(27.72589, LogLikelihood.logLikelihoodRatio(10, 0, 0, 10), 0.00001);    assertEquals(39.33052, LogLikelihood.logLikelihoodRatio(5, 1995, 0, 100000), 0.00001);    assertEquals(4730.737, LogLikelihood.logLikelihoodRatio(1000, 1995, 1000, 100000), 0.001);    assertEquals(5734.343, LogLikelihood.logLikelihoodRatio(1000, 1000, 1000, 100000), 0.001);    assertEquals(5714.932, LogLikelihood.logLikelihoodRatio(1000, 1000, 1000, 99000), 0.001);}
9461dab6893009830a2286a281504c0fe0b2e9b6cf7485dfc49ab06261636b04
testRootLogLikelihood
public void testRootLogLikelihood()
{        assertTrue(LogLikelihood.rootLogLikelihoodRatio(904, 21060, 1144, 283012) > 0.0);        assertTrue(LogLikelihood.rootLogLikelihoodRatio(36, 21928, 60280, 623876) < 0.0);    assertEquals(Math.sqrt(2.772589), LogLikelihood.rootLogLikelihoodRatio(1, 0, 0, 1), 0.000001);    assertEquals(-Math.sqrt(2.772589), LogLikelihood.rootLogLikelihoodRatio(0, 1, 1, 0), 0.000001);    assertEquals(Math.sqrt(27.72589), LogLikelihood.rootLogLikelihoodRatio(10, 0, 0, 10), 0.00001);    assertEquals(Math.sqrt(39.33052), LogLikelihood.rootLogLikelihoodRatio(5, 1995, 0, 100000), 0.00001);    assertEquals(-Math.sqrt(39.33052), LogLikelihood.rootLogLikelihoodRatio(0, 100000, 5, 1995), 0.00001);    assertEquals(Math.sqrt(4730.737), LogLikelihood.rootLogLikelihoodRatio(1000, 1995, 1000, 100000), 0.001);    assertEquals(-Math.sqrt(4730.737), LogLikelihood.rootLogLikelihoodRatio(1000, 100000, 1000, 1995), 0.001);    assertEquals(Math.sqrt(5734.343), LogLikelihood.rootLogLikelihoodRatio(1000, 1000, 1000, 100000), 0.001);    assertEquals(Math.sqrt(5714.932), LogLikelihood.rootLogLikelihoodRatio(1000, 1000, 1000, 99000), 0.001);}
b3b075b29272c90cf6b092aa715b32f0843a81a1e66c751cc32ea1876d62b8ef
testRootNegativeLLR
public void testRootNegativeLLR()
{    assertTrue(LogLikelihood.rootLogLikelihoodRatio(6, 7567, 1924, 2426487) >= 0.0);}
4902255fd3f856a3462dc9a3646995592d39b513b88a0380ff00af2e1bfa6eaa
testFrequencyComparison
public void testFrequencyComparison()
{    final Random rand = RandomUtils.getRandom();            Vector p1 = new DenseVector(25).assign(new DoubleFunction() {        @Override        public double apply(double arg1) {            return -Math.log1p(-rand.nextDouble());        }    });        Vector p2 = p1.like().assign(p1);        p1.viewPart(0, 5).assign(0);        p1.viewPart(5, 3).assign(Functions.mult(4));        p1.assign(Functions.div(p1.norm(1)));        p2.assign(Functions.div(p2.norm(1)));        Multiset<Integer> w1 = HashMultiset.create();    for (int i = 0; i < 100; i++) {        w1.add(sample(p1, rand));    }        Multiset<Integer> w2 = HashMultiset.create();    for (int i = 0; i < 1000; i++) {        w2.add(sample(p2, rand));    }        List<LogLikelihood.ScoredItem<Integer>> r = LogLikelihood.compareFrequencies(w1, w2, 8, 0);    assertTrue(r.size() <= 8);    assertFalse(r.isEmpty());    for (LogLikelihood.ScoredItem<Integer> item : r) {        assertTrue(item.getScore() >= 0);    }        assertEquals(7, (int) r.get(0).getItem());        double lastScore = r.get(0).getScore();    for (LogLikelihood.ScoredItem<Integer> item : r) {        assertTrue(item.getScore() <= lastScore);        lastScore = item.getScore();    }        r = LogLikelihood.compareFrequencies(w1, w2, 40, 1);        assertEquals(2, r.size());    assertEquals(7, (int) r.get(0).getItem());    assertEquals(6, (int) r.get(1).getItem());    r = LogLikelihood.compareFrequencies(w1, w2, 1000, -100);    Multiset<Integer> k = HashMultiset.create();    for (LogLikelihood.ScoredItem<Integer> item : r) {        k.add(item.getItem());    }    for (int i = 0; i < 25; i++) {        assertTrue("i = " + i, k.count(i) == 1 || w2.count(i) == 0);    }        assertEquals(w2.elementSet().size(), r.size());    assertEquals(7, (int) r.get(0).getItem());    assertEquals(6, (int) r.get(1).getItem());        assertTrue(r.get(r.size() - 1).getScore() < 0);        lastScore = r.get(0).getScore();    for (LogLikelihood.ScoredItem<Integer> item : r) {        assertTrue(item.getScore() <= lastScore);        lastScore = item.getScore();    }}
685ca82cead33e56c75cad5ace5f3cba2e4e471d0dcc68359527832073e7cdd4
apply
public double apply(double arg1)
{    return -Math.log1p(-rand.nextDouble());}
208d17e138e4faf1844014ff9ab8dfe911b9780280653d3ea3af1c1a41ce9114
sample
private static int sample(Vector p, Random rand)
{    double u = rand.nextDouble();        for (int i = 0; i < p.size(); i++) {        if (u <= p.get(i)) {            return i;        }        u -= p.get(i);    }    return p.size() - 1;}
291a38bf0617c147862fc084cbc82fd965ca5a08486114e141ccb538dfee1a08
testAverage
public void testAverage()
{    double[] t = { 11.35718, 21.54637, 28.91061, 33.03586, 39.57767 };    double[] x = { 1.5992071, -1.3577032, -0.3405638, 0.7048632, 0.3020558 };    double[] m = { 1.5992071, -1.0168100, -0.4797436, 0.2836447, 0.2966159 };    OnlineExponentialAverage averager = new OnlineExponentialAverage(5);    for (int i = 0; i < t.length; i++) {        averager.add(t[i], x[i]);        assertEquals("Step " + i, m[i], averager.mean(), 1.0e-6);    }}
e06bd72269e11ab26320c4efd8325a2b201d33feeee47aec56dadfdb89376848
testRate
public void testRate()
{    Random gen = RandomUtils.getRandom();    Poisson p = new Poisson(5, gen);    double lastT = 0;    double[] k = new double[1000];    double[] t = new double[1000];    for (int i = 1; i < 1000; i++) {                double dt = gen.nextDouble() * 10 + 5;        t[i] = lastT + dt;                k[i] = p.nextInt(dt * 0.2);        lastT = t[i];    }    OnlineExponentialAverage averager = new OnlineExponentialAverage(2000);    for (int i = 1; i < 1000; i++) {        averager.add(t[i], k[i]);    }    assertEquals("Expected rate", 0.2, averager.meanRate(), 0.01);}
376c06ec7f205418762dac8ab4f7dcfaad5952d8862930631a77f3c3f5265eb7
testStats
public void testStats()
{    /**     *     the reference limits here were derived using a numerical simulation where I took     *     10,000 samples from the distribution in question and computed the stats from that     *     sample to get min, 25%-ile, median and so on. I did this 1000 times to get 5% and     *     95% confidence limits for those values.     */        System.out.printf("normal\n");    check(normal(10000));        System.out.printf("exp\n");    check(exp(10000));        System.out.printf("gamma\n");    check(gamma(10000, 0.1));}
91ce06a3c9a4f496c5633bc19a88994e06d1a992cfb106feca2b4e664ec03d19
check
private static void check(double[] samples)
{    OnlineSummarizer s = new OnlineSummarizer();    double mean = 0;    double sd = 0;    int n = 1;    for (double x : samples) {        s.add(x);        double old = mean;        mean += (x - mean) / n;        sd += (x - old) * (x - mean);        n++;    }    sd = Math.sqrt(sd / samples.length);    Arrays.sort(samples);                        assertEquals("mean", s.getMean(), mean, 0);    assertEquals("sd", s.getSD(), sd, 1e-8);}
b619045d74ed29ab66d74c7846c64056e47b03adfffd9a23028da778947879b5
normal
private static double[] normal(int n)
{    double[] r = new double[n];    Random gen = RandomUtils.getRandom(1L);    for (int i = 0; i < n; i++) {        r[i] = gen.nextGaussian();    }    return r;}
926680cdfbbdd5074a9e6650c031e387cc764da16a25016a122b1b1585a2ec3b
exp
private static double[] exp(int n)
{    double[] r = new double[n];    Random gen = RandomUtils.getRandom(1L);    for (int i = 0; i < n; i++) {        r[i] = -Math.log1p(-gen.nextDouble());    }    return r;}
76d5d5788df4238e0c6e7f83db0d5aa7fc2bd79c415ecd873e534d28be8c1246
gamma
private static double[] gamma(int n, double shape)
{    double[] r = new double[n];    Random gen = RandomUtils.getRandom();    AbstractContinousDistribution gamma = new Gamma(shape, shape, gen);    for (int i = 0; i < n; i++) {        r[i] = gamma.nextDouble();    }    return r;}
01cf2d667d555539dc4f30cd00d8b1ec0a4b8f3dc90cba3fb4b3e603e0505350
matrixFactory
public Matrix matrixFactory(double[][] values)
{    return new DenseMatrix(values);}
ede5c5899c08ed5d99e54139831e4a9167b53f08938969e4e517171681c184a5
testGetValues
public void testGetValues()
{    DenseMatrix m = new DenseMatrix(10, 10);    for (int i = 0; i < 10; i++) {        for (int j = 0; j < 10; j++) {            m.set(i, j, 10 * i + j);        }    }    double[][] values = m.getBackingStructure();    Assert.assertEquals(values.length, 10);    Assert.assertEquals(values[0].length, 10);    Assert.assertEquals(values[9][9], 99.0, 0.0);}
9d02883c369189f25b6de6a3fc270f77e8252465ca459b808cc75f7eac410ba7
generateTestVector
 Vector generateTestVector(int cardinality)
{    return new DenseVector(cardinality);}
4418db934d4155c558cef1530654d1053ddcdb06e41cedabef91b0a8f1be57e3
testSize
public void testSize()
{    assertEquals("size", 3, getTestVector().getNumNonZeroElements());}
1d5219c46a787679c5bc4def2b3a7fe1ef27e7b0d22777599684c8a9ac1f6e5b
vectorToTest
public DenseVector vectorToTest(int size)
{    DenseVector r = new DenseVector(size);    r.assign(Functions.random());    return r;}
cd89046fb8911fa4a6595be8ff9a8156398ebfad5d0c95e20ca6a68135c4b5d2
testToString
public void testToString()
{    super.testToString();}
9d69bfd2a279cacda04001b1c50c6f6698b00750596931407928c5a8169d56b7
setUp
public void setUp() throws Exception
{    super.setUp();    int[] offset = { 1, 1 };    int[] card = { 3, 2 };    test = new MatrixView(new DenseMatrix(values), offset, card);}
c33b5dd3bcce18c13e0fc227426607645a76017e12386af96c7a2aa83d9ee23e
testCardinality
public void testCardinality()
{    assertEquals("row cardinality", values.length - 2, test.rowSize());    assertEquals("col cardinality", values[0].length - 1, test.columnSize());}
19ec40c009197b5a6fe460894a6d8b81a86c3a767ab9b25cf5bef672c9490804
testCopy
public void testCopy()
{    Matrix copy = test.clone();    assertTrue("wrong class", copy instanceof MatrixView);    for (int row = 0; row < test.rowSize(); row++) {        for (int col = 0; col < test.columnSize(); col++) {            assertEquals("value[" + row + "][" + col + ']', test.getQuick(row, col), copy.getQuick(row, col), EPSILON);        }    }}
d546c9b270424486c7e10eacc840c277a54db45a1e5176cbb35a6a0057b5f647
testGetQuick
public void testGetQuick()
{    for (int row = 0; row < test.rowSize(); row++) {        for (int col = 0; col < test.columnSize(); col++) {            assertEquals("value[" + row + "][" + col + ']', values[row + 1][col + 1], test.getQuick(row, col), EPSILON);        }    }}
2c7b313449cf9e1b2ee07116dc147fbec7041da5bdb74d5e94517b5b4e80a41d
testLike
public void testLike()
{    Matrix like = test.like();    assertTrue("type", like instanceof DenseMatrix);    assertEquals("rows", test.rowSize(), like.rowSize());    assertEquals("columns", test.columnSize(), like.columnSize());}
617c452474198fc10ba372a3de9a46c6d8069422b50b699f84fd9e0bd9a84cb1
testLikeIntInt
public void testLikeIntInt()
{    Matrix like = test.like(4, 4);    assertTrue("type", like instanceof DenseMatrix);    assertEquals("rows", 4, like.rowSize());    assertEquals("columns", 4, like.columnSize());}
18d625f42e8350d651706d856562c6afbf85dd8d877e63e3b575b06dac7d77aa
testSetQuick
public void testSetQuick()
{    for (int row = 0; row < test.rowSize(); row++) {        for (int col = 0; col < test.columnSize(); col++) {            test.setQuick(row, col, 1.23);            assertEquals("value[" + row + "][" + col + ']', 1.23, test.getQuick(row, col), EPSILON);        }    }}
4418db934d4155c558cef1530654d1053ddcdb06e41cedabef91b0a8f1be57e3
testSize
public void testSize()
{    assertEquals("row size", values.length - 2, test.rowSize());    assertEquals("col size", values[0].length - 1, test.columnSize());}
1c256c64ddf7fdeeb2b34b7b41ccfce50c9ab448e937bd3fd0b1b5e12432ccee
testViewPart
public void testViewPart()
{    int[] offset = { 1, 1 };    int[] size = { 2, 1 };    Matrix view = test.viewPart(offset, size);    for (int row = 0; row < view.rowSize(); row++) {        for (int col = 0; col < view.columnSize(); col++) {            assertEquals("value[" + row + "][" + col + ']', values[row + 2][col + 2], view.getQuick(row, col), EPSILON);        }    }}
9782d0b1be5c79cd5acde7629da4a6ced62d6962e4daf248107dc51c765b499a
testViewPartCardinality
public void testViewPartCardinality()
{    int[] offset = { 1, 1 };    int[] size = { 3, 3 };    test.viewPart(offset, size);}
9c212b20847f8cc1441d1b885a5b038101fdd02581f706d8f6eaed41aae114a6
testViewPartIndexOver
public void testViewPartIndexOver()
{    int[] offset = { 1, 1 };    int[] size = { 2, 2 };    test.viewPart(offset, size);}
8d4a60107f5c65978ca086c14b316e967e7ce777723985b673ca1fba885351dc
testViewPartIndexUnder
public void testViewPartIndexUnder()
{    int[] offset = { -1, -1 };    int[] size = { 2, 2 };    test.viewPart(offset, size);}
07c65eca6c2899b6c6bf730af78fe73d5534ea70fe59cbaed1a9fbe47cbe39f6
testAssignDouble
public void testAssignDouble()
{    test.assign(4.53);    for (int row = 0; row < test.rowSize(); row++) {        for (int col = 0; col < test.columnSize(); col++) {            assertEquals("value[" + row + "][" + col + ']', 4.53, test.getQuick(row, col), EPSILON);        }    }}
aa599f36764ba96b6dab2f967f8f6bf7ef28272531e2e118d8c363224ef8bb9f
testAssignDoubleArrayArray
public void testAssignDoubleArrayArray()
{    test.assign(new double[3][2]);    for (int row = 0; row < test.rowSize(); row++) {        for (int col = 0; col < test.columnSize(); col++) {            assertEquals("value[" + row + "][" + col + ']', 0.0, test.getQuick(row, col), EPSILON);        }    }}
7eebb702d308132ed2b16c68e6e8c1acfb4b3c5af13db695f0da905eacee5a69
testAssignDoubleArrayArrayCardinality
public void testAssignDoubleArrayArrayCardinality()
{    test.assign(new double[test.rowSize() + 1][test.columnSize()]);}
dba96aeb49319fcc5337e36e070d2cfa1a2523a6c0ae51378c5b349dc7829b4f
testAssignMatrixBinaryFunction
public void testAssignMatrixBinaryFunction()
{    test.assign(test, Functions.PLUS);    for (int row = 0; row < test.rowSize(); row++) {        for (int col = 0; col < test.columnSize(); col++) {            assertEquals("value[" + row + "][" + col + ']', 2 * values[row + 1][col + 1], test.getQuick(row, col), EPSILON);        }    }}
daf61bc655196e81fa93db84df8db2d173fefff24639d105a80a24c6ffbf362f
testAssignMatrixBinaryFunctionCardinality
public void testAssignMatrixBinaryFunctionCardinality()
{    test.assign(test.transpose(), Functions.PLUS);}
9fe3ccc6009677054e35e33afa20c4da3ce7cdf326e04b72cda9ced65fa3077b
testAssignMatrix
public void testAssignMatrix()
{    Matrix value = test.like();    value.assign(test);    for (int row = 0; row < test.rowSize(); row++) {        for (int col = 0; col < test.columnSize(); col++) {            assertEquals("value[" + row + "][" + col + ']', test.getQuick(row, col), value.getQuick(row, col), EPSILON);        }    }}
29ecf182f58280306a5f8036e84fb4e1b709d8cab8ede0ac1b2f8c6caecc1eaf
testAssignMatrixCardinality
public void testAssignMatrixCardinality()
{    test.assign(test.transpose());}
1cd2167b68d321b67d088c7b60215582cb0567d7eecbe7f5ff1670624e9658f9
testAssignUnaryFunction
public void testAssignUnaryFunction()
{    test.assign(Functions.NEGATE);    for (int row = 0; row < test.rowSize(); row++) {        for (int col = 0; col < test.columnSize(); col++) {            assertEquals("value[" + row + "][" + col + ']', -values[row + 1][col + 1], test.getQuick(row, col), EPSILON);        }    }}
d58b51a775a3ef67416c5c0925d435d6945066f65c166f7e3a050222c3732ebf
testDivide
public void testDivide()
{    Matrix value = test.divide(4.53);    for (int row = 0; row < test.rowSize(); row++) {        for (int col = 0; col < test.columnSize(); col++) {            assertEquals("value[" + row + "][" + col + ']', values[row + 1][col + 1] / 4.53, value.getQuick(row, col), EPSILON);        }    }}
eaa5dd587a1051f25f65fe1808fe232d587180e61c71e00071a4b765af52ae7a
testGet
public void testGet()
{    for (int row = 0; row < test.rowSize(); row++) {        for (int col = 0; col < test.columnSize(); col++) {            assertEquals("value[" + row + "][" + col + ']', values[row + 1][col + 1], test.get(row, col), EPSILON);        }    }}
c367b627e534e8cb7e6132f328cfe2ec695cf29fd27042865c96f998565350b2
testGetIndexUnder
public void testGetIndexUnder()
{    for (int row = -1; row < test.rowSize(); row++) {        for (int col = 0; col < test.columnSize(); col++) {            test.get(row, col);        }    }}
f26cb64fd6ba7c58638f65a59c640002034919c8dd3d219ac2ccf90b0fff714a
testGetIndexOver
public void testGetIndexOver()
{    for (int row = 0; row < test.rowSize() + 1; row++) {        for (int col = 0; col < test.columnSize(); col++) {            test.get(row, col);        }    }}
f7bbeaabdbf47078c5ea13f814ffb05bc9b90aeaa9fd0d89279cc6a77a196301
testMinus
public void testMinus()
{    Matrix value = test.minus(test);    for (int row = 0; row < test.rowSize(); row++) {        for (int col = 0; col < test.columnSize(); col++) {            assertEquals("value[" + row + "][" + col + ']', 0.0, value.getQuick(row, col), EPSILON);        }    }}
c9604e38f754d59692ccb815a05cb033ab448d897c16ac8eacb9cb98bb9c6c84
testMinusCardinality
public void testMinusCardinality()
{    test.minus(test.transpose());}
fa621704f0454f9b077a2d55f5b85be71984945b361fdcc96c4ad28da52d2600
testPlusDouble
public void testPlusDouble()
{    Matrix value = test.plus(4.53);    for (int row = 0; row < test.rowSize(); row++) {        for (int col = 0; col < test.columnSize(); col++) {            assertEquals("value[" + row + "][" + col + ']', values[row + 1][col + 1] + 4.53, value.getQuick(row, col), EPSILON);        }    }}
97a899842a52c6decc58d296e9affca5e1aec84d8a2a14260f5699aae6e9e031
testPlusMatrix
public void testPlusMatrix()
{    Matrix value = test.plus(test);    for (int row = 0; row < test.rowSize(); row++) {        for (int col = 0; col < test.columnSize(); col++) {            assertEquals("value[" + row + "][" + col + ']', values[row + 1][col + 1] * 2, value.getQuick(row, col), EPSILON);        }    }}
db4e7a5dead61203e69f920d3d82a3036e9f0ee74bcbbdeecca5bad9bc193e5b
testPlusMatrixCardinality
public void testPlusMatrixCardinality()
{    test.plus(test.transpose());}
8cdc761982243c1ad089e1edf015e95c6bb8d239cfd02a50f8f335e2f9f7acdd
testSetUnder
public void testSetUnder()
{    for (int row = -1; row < test.rowSize(); row++) {        for (int col = 0; col < test.columnSize(); col++) {            test.set(row, col, 1.23);        }    }}
d3de7681ff613118120cf3ffb9fabfe16577c38ee5720415af9fce86dd15601b
testSetOver
public void testSetOver()
{    for (int row = 0; row < test.rowSize() + 1; row++) {        for (int col = 0; col < test.columnSize(); col++) {            test.set(row, col, 1.23);        }    }}
7ac04d97f6038094dd4e9d20b79a35ac5c99b4ef68908ce1d637e9f3fff7be05
testTimesDouble
public void testTimesDouble()
{    Matrix value = test.times(4.53);    for (int row = 0; row < test.rowSize(); row++) {        for (int col = 0; col < test.columnSize(); col++) {            assertEquals("value[" + row + "][" + col + ']', values[row + 1][col + 1] * 4.53, value.getQuick(row, col), EPSILON);        }    }}
4421f5a043be99bdf600e120e4b25a8b63aa3830b8587e853d7c203bf4c7ad45
testTimesMatrix
public void testTimesMatrix()
{    Matrix transpose = test.transpose();    Matrix value = test.times(transpose);    assertEquals("rows", test.rowSize(), value.rowSize());    assertEquals("cols", test.rowSize(), value.columnSize());}
7f1a818d02a08c198b5fe40e2a71fc931ccf25e1af588a7c40efab82249ac4ba
testTimesMatrixCardinality
public void testTimesMatrixCardinality()
{    Matrix other = test.like(5, 8);    test.times(other);}
fafef026a08defa153a8269edf4c4c7d2155280cf1c5aeb987b02455a2cc494a
testTranspose
public void testTranspose()
{    Matrix transpose = test.transpose();    assertEquals("rows", test.columnSize(), transpose.rowSize());    assertEquals("cols", test.rowSize(), transpose.columnSize());    for (int row = 0; row < test.rowSize(); row++) {        for (int col = 0; col < test.columnSize(); col++) {            assertEquals("value[" + row + "][" + col + ']', test.getQuick(row, col), transpose.getQuick(col, row), EPSILON);        }    }}
a2f8bfe43ba8c92aee805d6750cf99adacee631d704901a4f5706f892b0c0a9c
testZSum
public void testZSum()
{    double sum = test.zSum();    assertEquals("zsum", 29.7, sum, EPSILON);}
e137a72d3c937dff4039d5cd2ca7137b034d48b79463711f6d06a57159280d76
testAssignRow
public void testAssignRow()
{    double[] data = { 2.1, 3.2 };    test.assignRow(1, new DenseVector(data));    assertEquals("test[1][0]", 2.1, test.getQuick(1, 0), EPSILON);    assertEquals("test[1][1]", 3.2, test.getQuick(1, 1), EPSILON);}
62db0d6bf17ea54703bf870b4b75856ff370cc676dad17967f4bf1dff31be3f0
testAssignRowCardinality
public void testAssignRowCardinality()
{    double[] data = { 2.1, 3.2, 4.3 };    test.assignRow(1, new DenseVector(data));}
fef3ffd41d0677d23db3d459bb67dd61cde1853bb44d0475db3b975cc6319545
testAssignColumn
public void testAssignColumn()
{    double[] data = { 2.1, 3.2, 4.3 };    test.assignColumn(1, new DenseVector(data));    assertEquals("test[0][1]", 2.1, test.getQuick(0, 1), EPSILON);    assertEquals("test[1][1]", 3.2, test.getQuick(1, 1), EPSILON);    assertEquals("test[2][1]", 4.3, test.getQuick(2, 1), EPSILON);}
e0c69949f5d2ce11574c10487f3ac35ce839f008ab1408525836c17da9f4a69a
testAssignColumnCardinality
public void testAssignColumnCardinality()
{    double[] data = { 2.1, 3.2 };    test.assignColumn(1, new DenseVector(data));}
82fed8001e09bf1361718b203ebead0644ffbd5850a682c65ed4be09bb2be968
testViewRow
public void testViewRow()
{    Vector row = test.viewRow(1);    assertEquals("row size", 2, row.getNumNondefaultElements());}
c39ac0b6c62c165e15ccc102242bceced40c68a9b507059ed8f0d77cfe275098
testViewRowIndexUnder
public void testViewRowIndexUnder()
{    test.viewRow(-1);}
415d4167db009dfac17c8b2278f49529048083ae96633f4c3b1b717d3f402864
testViewRowIndexOver
public void testViewRowIndexOver()
{    test.viewRow(5);}
9af236b1ba0e08c0e227303e19c7c5dece84754855f61d780d99cd9ac4cb909b
testViewColumn
public void testViewColumn()
{    Vector column = test.viewColumn(1);    assertEquals("row size", 3, column.getNumNondefaultElements());    int i = 0;    for (double x : new double[] { 3.3, 5.5, 7.7 }) {        assertEquals(x, column.get(i++), 0);    }}
e4dfba9a616f6eaf01ead88686588a5f9016ea6b0dfc6ffd9e4ded098439f534
testViewColumnIndexUnder
public void testViewColumnIndexUnder()
{    test.viewColumn(-1);}
64a0b786c9d9f54e71513354cc154802ee5d8ebd496651ed33c3f923de0166cb
testViewColumnIndexOver
public void testViewColumnIndexOver()
{    test.viewColumn(5);}
fc77973c1ff5c48602c3e4636aa4de9cc458575aeab2a93fc69fca93e0dd6f64
testLabelBindings
public void testLabelBindings()
{    assertNull("row bindings", test.getRowLabelBindings());    assertNull("col bindings", test.getColumnLabelBindings());    Map<String, Integer> rowBindings = Maps.newHashMap();    rowBindings.put("Fee", 0);    rowBindings.put("Fie", 1);    test.setRowLabelBindings(rowBindings);    assertEquals("row", rowBindings, test.getRowLabelBindings());    Map<String, Integer> colBindings = Maps.newHashMap();    colBindings.put("Foo", 0);    colBindings.put("Bar", 1);    test.setColumnLabelBindings(colBindings);    assertEquals("row", rowBindings, test.getRowLabelBindings());    assertEquals("Fee", test.get(0, 1), test.get("Fee", "Bar"), EPSILON);    double[] newrow = { 9, 8 };    test.set("Fie", newrow);    assertEquals("FeeBar", test.get(0, 1), test.get("Fee", "Bar"), EPSILON);}
7ffed98d1ac13ef6dcf7d0d5b05566f77686d65f2800508a6851bbf0e1fa6c8f
testSettingLabelBindings
public void testSettingLabelBindings()
{    assertNull("row bindings", test.getRowLabelBindings());    assertNull("col bindings", test.getColumnLabelBindings());    test.set("Fee", "Foo", 1, 1, 9);    assertNotNull("row", test.getRowLabelBindings());    assertNotNull("row", test.getRowLabelBindings());    assertEquals("Fee", 1, test.getRowLabelBindings().get("Fee").intValue());    assertEquals("Foo", 1, test.getColumnLabelBindings().get("Foo").intValue());    assertEquals("FeeFoo", test.get(1, 1), test.get("Fee", "Foo"), EPSILON);    test.get("Fie", "Foe");}
1cc9da23e3645bae0099dfb7038cebd117da2e45d1db7edec02e330b9bd0c618
testLabelBindingSerialization
public void testLabelBindingSerialization()
{    assertNull("row bindings", test.getRowLabelBindings());    assertNull("col bindings", test.getColumnLabelBindings());    Map<String, Integer> rowBindings = Maps.newHashMap();    rowBindings.put("Fee", 0);    rowBindings.put("Fie", 1);    rowBindings.put("Foe", 2);    test.setRowLabelBindings(rowBindings);    assertEquals("row", rowBindings, test.getRowLabelBindings());    Map<String, Integer> colBindings = Maps.newHashMap();    colBindings.put("Foo", 0);    colBindings.put("Bar", 1);    colBindings.put("Baz", 2);    test.setColumnLabelBindings(colBindings);    assertEquals("col", colBindings, test.getColumnLabelBindings());}
2417ed0a986d902851335a527fcd3730cccac0eb65f5a18e489750a2519dd385
testGetSet
public void testGetSet()
{    OrderedIntDoubleMapping mapping = new OrderedIntDoubleMapping(1);    assertEquals(0, mapping.getNumMappings());    assertEquals(0.0, mapping.get(0), EPSILON);    assertEquals(0.0, mapping.get(1), EPSILON);    mapping.set(0, 1.1);    assertEquals(1, mapping.getNumMappings());    assertEquals(1.1, mapping.get(0), EPSILON);    assertEquals(0.0, mapping.get(1), EPSILON);    mapping.set(5, 6.6);    assertEquals(2, mapping.getNumMappings());    assertEquals(1.1, mapping.get(0), EPSILON);    assertEquals(0.0, mapping.get(1), EPSILON);    assertEquals(6.6, mapping.get(5), EPSILON);    assertEquals(0.0, mapping.get(6), EPSILON);    mapping.set(0, 0.0);    assertEquals(1, mapping.getNumMappings());    assertEquals(0.0, mapping.get(0), EPSILON);    assertEquals(0.0, mapping.get(1), EPSILON);    assertEquals(6.6, mapping.get(5), EPSILON);    mapping.set(5, 0.0);    assertEquals(0, mapping.getNumMappings());    assertEquals(0.0, mapping.get(0), EPSILON);    assertEquals(0.0, mapping.get(1), EPSILON);    assertEquals(0.0, mapping.get(5), EPSILON);}
9ab337a2ce283eba0836dc4366d926e061e33dae2ba6121ea7102781506b6bdd
testClone
public void testClone() throws Exception
{    OrderedIntDoubleMapping mapping = new OrderedIntDoubleMapping(1);    mapping.set(0, 1.1);    mapping.set(5, 6.6);    OrderedIntDoubleMapping clone = mapping.clone();    assertEquals(2, clone.getNumMappings());    assertEquals(1.1, clone.get(0), EPSILON);    assertEquals(0.0, clone.get(1), EPSILON);    assertEquals(6.6, clone.get(5), EPSILON);    assertEquals(0.0, clone.get(6), EPSILON);}
e24f8b5e27bae83499bd6c3b8331feb5395bfef8059a7212a0242aac2d058629
testAddDefaultElements
public void testAddDefaultElements()
{    OrderedIntDoubleMapping mapping = new OrderedIntDoubleMapping(false);    mapping.set(1, 1.1);    assertEquals(1, mapping.getNumMappings());    mapping.set(2, 0);    assertEquals(2, mapping.getNumMappings());    mapping.set(0, 0);    assertEquals(3, mapping.getNumMappings());}
70845f6a2282cec8d2c489809703c2aa58e4e5cd1967e6a55e70d67a6e8ebc50
testMerge
public void testMerge()
{    OrderedIntDoubleMapping mappingOne = new OrderedIntDoubleMapping(false);    mappingOne.set(0, 0);    mappingOne.set(2, 2);    mappingOne.set(4, 4);    mappingOne.set(10, 10);    OrderedIntDoubleMapping mappingTwo = new OrderedIntDoubleMapping();    mappingTwo.set(1, 1);    mappingTwo.set(3, 3);    mappingTwo.set(5, 5);    mappingTwo.set(10, 20);    mappingOne.merge(mappingTwo);    assertEquals(7, mappingOne.getNumMappings());    for (int i = 0; i < 6; ++i) {        assertEquals(i, mappingOne.get(i), i);    }    assertEquals(20, mappingOne.get(10), 0);}
9d02883c369189f25b6de6a3fc270f77e8252465ca459b808cc75f7eac410ba7
generateTestVector
 Vector generateTestVector(int cardinality)
{    return new RandomAccessSparseVector(cardinality);}
6cc87262979cbd77167ae11fdff415192b557cec747bc4a866ec67401becb0ea
vectorToTest
public RandomAccessSparseVector vectorToTest(int size)
{    RandomAccessSparseVector r = new RandomAccessSparseVector(size);    Random gen = RandomUtils.getRandom();    for (int i = 0; i < 3; i++) {        r.set(gen.nextInt(r.size()), gen.nextGaussian());    }    return r;}
cd89046fb8911fa4a6595be8ff9a8156398ebfad5d0c95e20ca6a68135c4b5d2
testToString
public void testToString()
{    Vector w;    w = generateTestVector(20);    w.set(0, 1.1);    w.set(13, 100500.);    w.set(19, 3.141592);    for (String token : Splitter.on(',').split(w.toString().substring(1, w.toString().length() - 1))) {        String[] tokens = token.split(":");        assertEquals(Double.parseDouble(tokens[1]), w.get(Integer.parseInt(tokens[0])), 0.0);    }    w = generateTestVector(12);    w.set(10, 0.1);    assertEquals("{10:0.1}", w.toString());    w = generateTestVector(12);    assertEquals("{}", w.toString());}
9d02883c369189f25b6de6a3fc270f77e8252465ca459b808cc75f7eac410ba7
generateTestVector
 Vector generateTestVector(int cardinality)
{    return new SequentialAccessSparseVector(cardinality);}
e2ded64a4e440afddbed2cdf27cbc3498b4be124e1e3ad228b19be94385d2e76
testDotSuperBig
public void testDotSuperBig()
{    Vector w = new SequentialAccessSparseVector(Integer.MAX_VALUE, 12);    w.set(1, 0.4);    w.set(2, 0.4);    w.set(3, -0.666666667);    Vector v = new SequentialAccessSparseVector(Integer.MAX_VALUE, 12);    v.set(3, 1);    assertEquals("super-big", -0.666666667, v.dot(w), EPSILON);}
caf674a22391ee1a716740f661539cbf26479523a3cd9d1574138b21eda69f00
vectorToTest
public SequentialAccessSparseVector vectorToTest(int size)
{    SequentialAccessSparseVector r = new SequentialAccessSparseVector(size);    Random gen = RandomUtils.getRandom();    for (int i = 0; i < 3; i++) {        r.set(gen.nextInt(r.size()), gen.nextGaussian());    }    return r;}
cd89046fb8911fa4a6595be8ff9a8156398ebfad5d0c95e20ca6a68135c4b5d2
testToString
public void testToString()
{    super.testToString();}
f8479dbb9eed2f2605f09acef88d4043bf9cb9d279e77c257ac84a4840fdfd89
testMoreRows
public void testMoreRows()
{    double[] singularValues = { 123.456, 2.3, 1.001, 0.999 };    int rows = singularValues.length + 2;    int columns = singularValues.length;    Random r = RandomUtils.getRandom();    SingularValueDecomposition svd = new SingularValueDecomposition(createTestMatrix(r, rows, columns, singularValues));    double[] computedSV = svd.getSingularValues();    assertEquals(singularValues.length, computedSV.length);    for (int i = 0; i < singularValues.length; ++i) {        assertEquals(singularValues[i], computedSV[i], 1.0e-10);    }}
a0e816e8c5aed8cbec9538c398215afb1cadabe7fe90cc79fe2c04ca9cd939f2
testMoreColumns
public void testMoreColumns()
{    double[] singularValues = { 123.456, 2.3, 1.001, 0.999 };    int rows = singularValues.length;    int columns = singularValues.length + 2;    Random r = RandomUtils.getRandom();    SingularValueDecomposition svd = new SingularValueDecomposition(createTestMatrix(r, rows, columns, singularValues));    double[] computedSV = svd.getSingularValues();    assertEquals(singularValues.length, computedSV.length);    for (int i = 0; i < singularValues.length; ++i) {        assertEquals(singularValues[i], computedSV[i], 1.0e-10);    }}
1cc3da724d97fad7136521fd04a3484eb752023e948f6c624b3709cec9b73100
testDimensions
public void testDimensions()
{    Matrix matrix = new DenseMatrix(testSquare);    int m = matrix.numRows();    int n = matrix.numCols();    SingularValueDecomposition svd = new SingularValueDecomposition(matrix);    assertEquals(m, svd.getU().numRows());    assertEquals(m, svd.getU().numCols());    assertEquals(m, svd.getS().numCols());    assertEquals(n, svd.getS().numCols());    assertEquals(n, svd.getV().numRows());    assertEquals(n, svd.getV().numCols());}
3e12ad0e1addf35299d3bbfcf7ee8376282fc0078c8a7f39b6fa4251314091a8
testHadamard
public void testHadamard()
{    Matrix matrix = new DenseMatrix(new double[][] { { 15.0 / 2.0, 5.0 / 2.0, 9.0 / 2.0, 3.0 / 2.0 }, { 5.0 / 2.0, 15.0 / 2.0, 3.0 / 2.0, 9.0 / 2.0 }, { 9.0 / 2.0, 3.0 / 2.0, 15.0 / 2.0, 5.0 / 2.0 }, { 3.0 / 2.0, 9.0 / 2.0, 5.0 / 2.0, 15.0 / 2.0 } });    SingularValueDecomposition svd = new SingularValueDecomposition(matrix);    assertEquals(16.0, svd.getSingularValues()[0], 1.0e-14);    assertEquals(8.0, svd.getSingularValues()[1], 1.0e-14);    assertEquals(4.0, svd.getSingularValues()[2], 1.0e-14);    assertEquals(2.0, svd.getSingularValues()[3], 1.0e-14);    Matrix fullCovariance = new DenseMatrix(new double[][] { { 85.0 / 1024, -51.0 / 1024, -75.0 / 1024, 45.0 / 1024 }, { -51.0 / 1024, 85.0 / 1024, 45.0 / 1024, -75.0 / 1024 }, { -75.0 / 1024, 45.0 / 1024, 85.0 / 1024, -51.0 / 1024 }, { 45.0 / 1024, -75.0 / 1024, -51.0 / 1024, 85.0 / 1024 } });    assertEquals(0.0, Algebra.getNorm(fullCovariance.minus(svd.getCovariance(0.0))), 1.0e-14);    Matrix halfCovariance = new DenseMatrix(new double[][] { { 5.0 / 1024, -3.0 / 1024, 5.0 / 1024, -3.0 / 1024 }, { -3.0 / 1024, 5.0 / 1024, -3.0 / 1024, 5.0 / 1024 }, { 5.0 / 1024, -3.0 / 1024, 5.0 / 1024, -3.0 / 1024 }, { -3.0 / 1024, 5.0 / 1024, -3.0 / 1024, 5.0 / 1024 } });    assertEquals(0.0, Algebra.getNorm(halfCovariance.minus(svd.getCovariance(6.0))), 1.0e-14);}
0df8766d4910cea7bbd855d2194a593eedac5fd6859db3313abbd132d08ece48
testAEqualUSVt
public void testAEqualUSVt()
{    checkAEqualUSVt(new DenseMatrix(testSquare));    checkAEqualUSVt(new DenseMatrix(testNonSquare));    checkAEqualUSVt(new DenseMatrix(testNonSquare).transpose());}
1ecce4f7316eea72b64497b23179e46ad7e7fb6c3a847efd991384c400920304
checkAEqualUSVt
public static void checkAEqualUSVt(Matrix matrix)
{    SingularValueDecomposition svd = new SingularValueDecomposition(matrix);    Matrix u = svd.getU();    Matrix s = svd.getS();    Matrix v = svd.getV();        if (s.numRows() < matrix.numRows()) {        Matrix sp = new DenseMatrix(s.numRows() + 1, s.numCols());        Matrix up = new DenseMatrix(u.numRows(), u.numCols() + 1);        for (int i = 0; i < u.numRows(); i++) {            for (int j = 0; j < u.numCols(); j++) {                up.set(i, j, u.get(i, j));            }        }        for (int i = 0; i < s.numRows(); i++) {            for (int j = 0; j < s.numCols(); j++) {                sp.set(i, j, s.get(i, j));            }        }        u = up;        s = sp;    }    double norm = Algebra.getNorm(u.times(s).times(v.transpose()).minus(matrix));    assertEquals(0, norm, NORM_TOLERANCE);}
2eeb4068a9120a4734c348312fd3f902c74fd8d189fb3055873e15eb11d04787
testUOrthogonal
public void testUOrthogonal()
{    checkOrthogonal(new SingularValueDecomposition(new DenseMatrix(testSquare)).getU());    checkOrthogonal(new SingularValueDecomposition(new DenseMatrix(testNonSquare)).getU());    checkOrthogonal(new SingularValueDecomposition(new DenseMatrix(testNonSquare).transpose()).getU());}
f528a834d24a67cb24c2353514fceb30298120b809865abe93cefbf471e6775d
testVOrthogonal
public void testVOrthogonal()
{    checkOrthogonal(new SingularValueDecomposition(new DenseMatrix(testSquare)).getV());    checkOrthogonal(new SingularValueDecomposition(new DenseMatrix(testNonSquare)).getV());    checkOrthogonal(new SingularValueDecomposition(new DenseMatrix(testNonSquare).transpose()).getV());}
0dcf4c208c64611c4982ea00506ab967b58b1a5caa5e86768ad9baea32608280
checkOrthogonal
public static void checkOrthogonal(Matrix m)
{    Matrix mTm = m.transpose().times(m);    Matrix id = new DenseMatrix(mTm.numRows(), mTm.numRows());    for (int i = 0; i < mTm.numRows(); i++) {        id.set(i, i, 1);    }    assertEquals(0, Algebra.getNorm(mTm.minus(id)), NORM_TOLERANCE);}
f0c0043b26303a59a53ff68e45ed9b9ffd0a73bf8db0bbe61d2b8300ae7bfa12
testMatricesValues1
public void testMatricesValues1()
{    SingularValueDecomposition svd = new SingularValueDecomposition(new DenseMatrix(testSquare));    Matrix uRef = new DenseMatrix(new double[][] { { 3.0 / 5.0, 4.0 / 5.0 }, { 4.0 / 5.0, -3.0 / 5.0 } });    Matrix sRef = new DenseMatrix(new double[][] { { 3.0, 0.0 }, { 0.0, 1.0 } });    Matrix vRef = new DenseMatrix(new double[][] { { 4.0 / 5.0, -3.0 / 5.0 }, { 3.0 / 5.0, 4.0 / 5.0 } });        Matrix u = svd.getU();    assertEquals(0, Algebra.getNorm(u.minus(uRef)), NORM_TOLERANCE);    Matrix s = svd.getS();    assertEquals(0, Algebra.getNorm(s.minus(sRef)), NORM_TOLERANCE);    Matrix v = svd.getV();    assertEquals(0, Algebra.getNorm(v.minus(vRef)), NORM_TOLERANCE);}
6e149a8c22180bc842174897b25c79406a42385a8e6ad25b20b3efe5466cbdf6
testConditionNumber
public void testConditionNumber()
{    SingularValueDecomposition svd = new SingularValueDecomposition(new DenseMatrix(testSquare));        assertEquals(3.0, svd.cond(), 1.5e-15);}
c31126942cb8140ddde2e66d516d22f27f95d38aec276436c647790898632d95
testSvdHang
public void testSvdHang() throws IOException, InterruptedException, ExecutionException, TimeoutException
{    System.out.printf("starting hanging-svd\n");    final Matrix m = readTsv("hanging-svd.tsv");    SingularValueDecomposition svd = new SingularValueDecomposition(m);    assertEquals(0, m.minus(svd.getU().times(svd.getS()).times(svd.getV().transpose())).aggregate(Functions.PLUS, Functions.ABS), 1e-10);    System.out.printf("No hang\n");}
c120b9488cdc4e76110bf56cd9287217c44dd187bf80f8acf012af0137972349
readTsv
 Matrix readTsv(String name) throws IOException
{    Splitter onTab = Splitter.on("\t");    List<String> lines = Resources.readLines((Resources.getResource(name)), Charsets.UTF_8);    int rows = lines.size();    int columns = Iterables.size(onTab.split(lines.get(0)));    Matrix r = new DenseMatrix(rows, columns);    int row = 0;    for (String line : lines) {        Iterable<String> values = onTab.split(line);        int column = 0;        for (String value : values) {            r.set(row, column, Double.parseDouble(value));            column++;        }        row++;    }    return r;}
65e1406ec4bcf2d61d98a539f22529d99717c16eeb37f5815df216cd800ef899
createTestMatrix
private static Matrix createTestMatrix(Random r, int rows, int columns, double[] singularValues)
{    Matrix u = createOrthogonalMatrix(r, rows);    Matrix d = createDiagonalMatrix(singularValues, rows, columns);    Matrix v = createOrthogonalMatrix(r, columns);    return u.times(d).times(v);}
53c9f734c345d1794d0b8e1912a6bb0b18657c9370a8e639de540411f08c987b
createOrthogonalMatrix
public static Matrix createOrthogonalMatrix(Random r, int size)
{    double[][] data = new double[size][size];    for (int i = 0; i < size; ++i) {        double[] dataI = data[i];        double norm2;        do {                        for (int j = 0; j < size; ++j) {                dataI[j] = 2 * r.nextDouble() - 1;            }                        for (int k = 0; k < i; ++k) {                double[] dataK = data[k];                double dotProduct = 0;                for (int j = 0; j < size; ++j) {                    dotProduct += dataI[j] * dataK[j];                }                for (int j = 0; j < size; ++j) {                    dataI[j] -= dotProduct * dataK[j];                }            }                        norm2 = 0;            for (double dataIJ : dataI) {                norm2 += dataIJ * dataIJ;            }            double inv = 1.0 / Math.sqrt(norm2);            for (int j = 0; j < size; ++j) {                dataI[j] *= inv;            }        } while (norm2 * size < 0.01);    }    return new DenseMatrix(data);}
f1a7518c5a37fd4f9ec87649ddb8b0314c0677e3fec5ac8dc926c46981c21475
createDiagonalMatrix
public static Matrix createDiagonalMatrix(double[] diagonal, int rows, int columns)
{    double[][] dData = new double[rows][columns];    for (int i = 0; i < Math.min(rows, columns); ++i) {        dData[i][i] = diagonal[i];    }    return new DenseMatrix(dData);}
01cf2d667d555539dc4f30cd00d8b1ec0a4b8f3dc90cba3fb4b3e603e0505350
matrixFactory
public Matrix matrixFactory(double[][] values)
{    Matrix matrix = new SparseColumnMatrix(values.length, values[0].length);    for (int row = 0; row < matrix.rowSize(); row++) {        for (int col = 0; col < matrix.columnSize(); col++) {            matrix.setQuick(row, col, values[row][col]);        }    }    return matrix;}
febcc76e4c7f6175ca37b08e1443727e72951c1a57c5dacfb843f3f0e1d3e3f2
testIterate
public void testIterate()
{}
01cf2d667d555539dc4f30cd00d8b1ec0a4b8f3dc90cba3fb4b3e603e0505350
matrixFactory
public Matrix matrixFactory(double[][] values)
{    Matrix matrix = new SparseMatrix(values.length, values[0].length);    for (int row = 0; row < matrix.rowSize(); row++) {        for (int col = 0; col < matrix.columnSize(); col++) {            matrix.setQuick(row, col, values[row][col]);        }    }    return matrix;}
41cb0c8c2f7f08040f2100be00b422b2e260f4d203be6064832bf46078f3e213
add
public void add()
{    Matrix a = new SparseMatrix(3, 3);    a.set(0, 0, 1);    a.set(0, 2, 3);    a.set(2, 0, 1);    a.set(2, 1, 2);    Matrix b = new SparseMatrix(3, 3);    b.set(0, 0, 3);    b.set(0, 2, 1);    b.set(1, 1, 5);    b.set(2, 2, 2);    a.assign(b, Functions.PLUS);    assertEquals(4, a.getQuick(0, 0), 0.0);    assertEquals(0, a.getQuick(0, 1), 0.0);    assertEquals(4, a.getQuick(0, 2), 0.0);    assertEquals(0, a.getQuick(1, 0), 0.0);    assertEquals(5, a.getQuick(1, 1), 0.0);    assertEquals(0, a.getQuick(1, 2), 0.0);    assertEquals(1, a.getQuick(2, 0), 0.0);    assertEquals(2, a.getQuick(2, 1), 0.0);    assertEquals(2, a.getQuick(2, 2), 0.0);}
615bfe11c2dcc5a81028912571fe497fb835d6f18e0290f023ab6c9be337f325
testSparseCopy
public void testSparseCopy()
{    SparseMatrix matrix = createSparseMatrixWithEmptyRow();    Matrix copy = matrix.clone();    assertSame("wrong class", copy.getClass(), matrix.getClass());    SparseMatrix castedCopy = (SparseMatrix) copy;    Iterator<MatrixSlice> originalSlices = matrix.iterator();    Iterator<MatrixSlice> copySlices = castedCopy.iterator();    while (originalSlices.hasNext() && copySlices.hasNext()) {        MatrixSlice originalSlice = originalSlices.next();        MatrixSlice copySlice = copySlices.next();        assertEquals("Wrong row indices.", originalSlice.index(), copySlice.index());        assertEquals("Slices are not equal.", originalSlice, copySlice);    }    assertSame("Number of rows of original and copy are not equal.", originalSlices.hasNext(), copySlices.hasNext());}
848136ff0dd537610ffc108804ed0a19d99f058d7bc5e2f06d66c82260b0a1d5
createSparseMatrixWithEmptyRow
private SparseMatrix createSparseMatrixWithEmptyRow()
{    SparseMatrix result = new SparseMatrix(3, 3);    result.setQuick(0, 0, 1);    result.setQuick(1, 1, 1);    result.setQuick(1, 2, 1);    return result;}
01cf2d667d555539dc4f30cd00d8b1ec0a4b8f3dc90cba3fb4b3e603e0505350
matrixFactory
public Matrix matrixFactory(double[][] values)
{    Matrix matrix = new SparseRowMatrix(values.length, values[0].length);    for (int row = 0; row < matrix.rowSize(); row++) {        for (int col = 0; col < matrix.columnSize(); col++) {            matrix.setQuick(row, col, values[row][col]);        }    }    return matrix;}
9c59e640bfc33f8173eb708ae6779f3f7f761014d15cf714538d60225b962c81
testTimesSparseEfficiency
public void testTimesSparseEfficiency()
{    Random raw = RandomUtils.getRandom();    Gamma gen = new Gamma(0.1, 0.1, raw);        Matrix x = new SparseRowMatrix(1000, 2000, false);    for (int i = 0; i < 1000; i++) {        int[] values = new int[1000];        for (int k = 0; k < 1000; k++) {            int j = (int) Math.min(1000, gen.nextDouble());            values[j]++;        }        for (int j = 0; j < 1000; j++) {            if (values[j] > 0) {                x.set(i, j, values[j]);            }        }    }    Matrix y = new SparseRowMatrix(2000, 1000, false);    for (int i = 0; i < 2000; i++) {        int[] values = new int[1000];        for (int k = 0; k < 1000; k++) {            int j = (int) Math.min(1000, gen.nextDouble());            values[j]++;        }        for (int j = 0; j < 1000; j++) {            if (values[j] > 0) {                y.set(i, j, values[j]);            }        }    }    long t0 = System.nanoTime();    Matrix z = x.times(y);    double elapsedTime = (System.nanoTime() - t0) * 1e-6;    System.out.printf("done in %.1f ms\n", elapsedTime);    for (int k = 0; k < 1000; k++) {        int i = (int) (-10 * Math.log(raw.nextDouble()));        int j = (int) (-10 * Math.log(raw.nextDouble()));        Assert.assertEquals(x.viewRow(i).dot(y.viewColumn(j)), z.get(i, j), 1e-12);    }}
2443d1d0c4283c273cc64fada90ae9836764c80a0951c4ee07b76f8595694656
testTimesDenseEfficiency
public void testTimesDenseEfficiency()
{    Random raw = RandomUtils.getRandom();    Gamma gen = new Gamma(0.1, 0.1, raw);        Matrix x = new SparseRowMatrix(1000, 2000, false);    for (int i = 0; i < 1000; i++) {        int[] values = new int[1000];        for (int k = 0; k < 1000; k++) {            int j = (int) Math.min(1000, gen.nextDouble());            values[j]++;        }        for (int j = 0; j < 1000; j++) {            if (values[j] > 0) {                x.set(i, j, values[j]);            }        }    }    Matrix y = new DenseMatrix(2000, 20);    for (int i = 0; i < 2000; i++) {        for (int j = 0; j < 20; j++) {            y.set(i, j, raw.nextDouble());        }    }    long t0 = System.nanoTime();    Matrix z = x.times(y);    double elapsedTime = (System.nanoTime() - t0) * 1e-6;    System.out.printf("done in %.1f ms\n", elapsedTime);    for (int i = 0; i < 1000; i++) {        for (int j = 0; j < 20; j++) {            Assert.assertEquals(x.viewRow(i).dot(y.viewColumn(j)), z.get(i, j), 1e-12);        }    }}
6768376b6981e75fd162ce816f7401d70c80a25e0dadaefde46e69758b7d02bc
testTimesOtherSparseEfficiency
public void testTimesOtherSparseEfficiency()
{    Random raw = RandomUtils.getRandom();    Gamma gen = new Gamma(0.1, 0.1, raw);        Matrix x = new SparseRowMatrix(1000, 2000, false);    for (int i = 0; i < 1000; i++) {        int[] values = new int[1000];        for (int k = 0; k < 1000; k++) {            int j = (int) Math.min(1000, gen.nextDouble());            values[j]++;        }        for (int j = 0; j < 1000; j++) {            if (values[j] > 0) {                x.set(i, j, values[j]);            }        }    }    Vector d = new DenseVector(2000).assign(Functions.random());    Matrix y = new DiagonalMatrix(d);    long t0 = System.nanoTime();    Matrix z = x.times(y);    double elapsedTime = (System.nanoTime() - t0) * 1e-6;    System.out.printf("done in %.1f ms\n", elapsedTime);    for (MatrixSlice row : z) {        for (Vector.Element element : row.nonZeroes()) {            assertEquals(x.get(row.index(), element.index()) * d.get(element.index()), element.get(), 1e-12);        }    }}
892d6b3da2168706e630e044f9cd48b7267cf910839a0c03c0d7baedd94c6498
testTimesCorrect
public void testTimesCorrect()
{    Random raw = RandomUtils.getRandom();        Matrix x = new SparseRowMatrix(100, 2000, false).assign(Functions.random());    Matrix y = new SparseRowMatrix(2000, 100, false).assign(Functions.random());    Matrix xd = new DenseMatrix(100, 2000).assign(x);    Matrix yd = new DenseMatrix(2000, 100).assign(y);    assertEquals(0, xd.times(yd).minus(x.times(y)).aggregate(Functions.PLUS, Functions.ABS), 1e-15);    assertEquals(0, x.times(yd).minus(x.times(y)).aggregate(Functions.PLUS, Functions.ABS), 1e-15);    assertEquals(0, xd.times(y).minus(x.times(y)).aggregate(Functions.PLUS, Functions.ABS), 1e-15);}
c33b5dd3bcce18c13e0fc227426607645a76017e12386af96c7a2aa83d9ee23e
testCardinality
public void testCardinality()
{    assertEquals("size", 3, test.size());}
4c58aedb45e358332c19a90e461d801d4c22ca1a8dd435fc06dc2eb0aee9f9f1
testCopy
public void testCopy() throws Exception
{    Vector copy = test.clone();    for (int i = 0; i < test.size(); i++) {        assertEquals("copy [" + i + ']', test.get(i), copy.get(i), EPSILON);    }}
2036295288ae2957843d767363bfed098cb02b2bd68371306e2b5d80e5352f05
testGet
public void testGet() throws Exception
{    for (int i = 0; i < test.size(); i++) {        assertEquals("get [" + i + ']', values[i + OFFSET], test.get(i), EPSILON);    }}
9229db13164bb08e86cb02598b2011a54d66b7fab1c0bf0fa2bb22bc33d46fbb
testGetOver
public void testGetOver()
{    test.get(test.size());}
db92f1feffaee29873b6bee7ac2cc6a5b873d9733ad26e8b6fa16e5cb5362252
testIterator
public void testIterator() throws Exception
{    VectorView view = new VectorView(new DenseVector(values), OFFSET, CARDINALITY);    double[] gold = { 1.1, 2.2, 3.3 };    Iterator<Vector.Element> iter = view.iterator();    checkIterator(iter, gold);    iter = view.iterateNonZero();    checkIterator(iter, gold);    view = new VectorView(new DenseVector(values), 0, CARDINALITY);    gold = new double[] { 0.0, 1.1, 2.2 };    iter = view.iterator();    checkIterator(iter, gold);    gold = new double[] { 1.1, 2.2 };    iter = view.iterateNonZero();    checkIterator(iter, gold);}
74b8a58fe349d4d545ea4a85c75957477543c4765405aa56ec632492ad87252e
checkIterator
private static void checkIterator(Iterator<Vector.Element> iter, double[] gold)
{    int i = 0;    while (iter.hasNext()) {        Vector.Element elt = iter.next();        assertEquals(elt.index() + " Value: " + gold[i] + " does not equal: " + elt.get(), gold[i], elt.get(), 0.0);        i++;    }}
9572d32c9389aa909c0a31eea413968054e22650fe87e93201c3828586e94b9f
testGetUnder
public void testGetUnder()
{    test.get(-1);}
cec564f9b0b24c51589eb9c6500ced17a78254a77e3e7bbc24c54470d354a153
testSet
public void testSet() throws Exception
{    test.set(2, 4.5);    for (int i = 0; i < test.size(); i++) {        assertEquals("set [" + i + ']', i == 2 ? 4.5 : values[OFFSET + i], test.get(i), EPSILON);    }}
bd2fe0a135bc06ccc7f18476ef4c9de5841c2162f80fe9b37777c235f29333a3
testSize
public void testSize() throws Exception
{    assertEquals("size", 3, test.getNumNondefaultElements());}
6f7898e49041489e6eb429cc3048dd4039d09e4cf4230152853dc11976fd5ad7
testViewPart
public void testViewPart() throws Exception
{    Vector part = test.viewPart(1, 2);    assertEquals("part size", 2, part.getNumNondefaultElements());    for (int i = 0; i < part.size(); i++) {        assertEquals("part[" + i + ']', values[OFFSET + i + 1], part.get(i), EPSILON);    }}
f0019886ff5ed5e11779d88428975b75ddcabd6dff13e51a1608a7db8dc0d48b
testViewPartUnder
public void testViewPartUnder()
{    test.viewPart(-1, CARDINALITY);}
1b268a78ded0b24aab73a67cf27dd311934d6fa15ff81170f302813f23a17dad
testViewPartOver
public void testViewPartOver()
{    test.viewPart(2, CARDINALITY);}
9782d0b1be5c79cd5acde7629da4a6ced62d6962e4daf248107dc51c765b499a
testViewPartCardinality
public void testViewPartCardinality()
{    test.viewPart(1, values.length + 1);}
6b80d3ca27e569b3745286094da2b9059345ce0ffcf9aab252ace0be60e745a2
testDot
public void testDot() throws Exception
{    double res = test.dot(test);    assertEquals("dot", 1.1 * 1.1 + 2.2 * 2.2 + 3.3 * 3.3, res, EPSILON);}
e39f1398f89b36a062ae3cd0fb3fcf0c3506df8125278244f75450c920ad1754
testDotCardinality
public void testDotCardinality()
{    test.dot(new DenseVector(test.size() + 1));}
4c55db581c22b03b7e5d79e00afc0cb4cd3231ad1ff9fdd07572d231a3db9d8d
testNormalize
public void testNormalize() throws Exception
{    Vector res = test.normalize();    double mag = Math.sqrt(1.1 * 1.1 + 2.2 * 2.2 + 3.3 * 3.3);    for (int i = 0; i < test.size(); i++) {        assertEquals("dot", values[OFFSET + i] / mag, res.get(i), EPSILON);    }}
12b66739e160f2588c8c22362ca5d4f93c2b7971d8b46c4161c7f7796bfa67b1
testMinus
public void testMinus() throws Exception
{    Vector val = test.minus(test);    assertEquals("size", 3, val.size());    for (int i = 0; i < test.size(); i++) {        assertEquals("get [" + i + ']', 0.0, val.get(i), EPSILON);    }}
4f8913ec8bb0ec673cecc3d1f7e07a6258c0a63602eaebbee9f77615e68b0032
testPlusDouble
public void testPlusDouble() throws Exception
{    Vector val = test.plus(1);    assertEquals("size", 3, val.size());    for (int i = 0; i < test.size(); i++) {        assertEquals("get [" + i + ']', values[OFFSET + i] + 1, val.get(i), EPSILON);    }}
480a49fd7d116dbf25f9699a3af5601d1954eb6ccc92251116d28f60f30d7ab4
testPlusVector
public void testPlusVector() throws Exception
{    Vector val = test.plus(test);    assertEquals("size", 3, val.size());    for (int i = 0; i < test.size(); i++) {        assertEquals("get [" + i + ']', values[OFFSET + i] * 2, val.get(i), EPSILON);    }}
042256fe2eedc187e81662db06dfce58192fcc1227c93879e9f99751bc0c1eb7
testPlusVectorCardinality
public void testPlusVectorCardinality()
{    test.plus(new DenseVector(test.size() + 1));}
1d202b90d029eba1ca8a2d2a2886e75f6078715176172255edf9147c64f5c3be
testTimesDouble
public void testTimesDouble() throws Exception
{    Vector val = test.times(3);    assertEquals("size", 3, val.size());    for (int i = 0; i < test.size(); i++) {        assertEquals("get [" + i + ']', values[OFFSET + i] * 3, val.get(i), EPSILON);    }}
449722a4b8a572ef50506dcc80b87f8ed85e0db2f0389c1f752e9e3401d9cfa4
testDivideDouble
public void testDivideDouble() throws Exception
{    Vector val = test.divide(3);    assertEquals("size", 3, val.size());    for (int i = 0; i < test.size(); i++) {        assertEquals("get [" + i + ']', values[OFFSET + i] / 3, val.get(i), EPSILON);    }}
0216fd079ea53fb96e56b49fd2c92a113612a9a18afac99903e38ba1baa5b9da
testTimesVector
public void testTimesVector() throws Exception
{    Vector val = test.times(test);    assertEquals("size", 3, val.size());    for (int i = 0; i < test.size(); i++) {        assertEquals("get [" + i + ']', values[OFFSET + i] * values[OFFSET + i], val.get(i), EPSILON);    }}
593b488f5e3d7721549e06e56b7567ce37865ce15b5da27b347553403980eeba
testTimesVectorCardinality
public void testTimesVectorCardinality()
{    test.times(new DenseVector(test.size() + 1));}
a2f8bfe43ba8c92aee805d6750cf99adacee631d704901a4f5706f892b0c0a9c
testZSum
public void testZSum()
{    double expected = 0;    for (int i = OFFSET; i < OFFSET + CARDINALITY; i++) {        expected += values[i];    }    assertEquals("wrong zSum", expected, test.zSum(), EPSILON);}
07c65eca6c2899b6c6bf730af78fe73d5534ea70fe59cbaed1a9fbe47cbe39f6
testAssignDouble
public void testAssignDouble()
{    test.assign(0);    for (int i = 0; i < test.size(); i++) {        assertEquals("value[" + i + ']', 0.0, test.getQuick(i), EPSILON);    }}
2ed6cbc5bf60eb18092285226a6bc7871f7134a23ddf00472702a89bcd6f6168
testAssignDoubleArray
public void testAssignDoubleArray() throws Exception
{    double[] array = new double[test.size()];    test.assign(array);    for (int i = 0; i < test.size(); i++) {        assertEquals("value[" + i + ']', 0.0, test.getQuick(i), EPSILON);    }}
aa4a43f59b15b59464a481b85eca98bb2f8d2bacddcaad401e3bfb096db39ff9
testAssignDoubleArrayCardinality
public void testAssignDoubleArrayCardinality()
{    double[] array = new double[test.size() + 1];    test.assign(array);}
00acef909d529571f49c396e2d24f0e8da401389d9beed913ab2662356343650
testAssignVector
public void testAssignVector() throws Exception
{    Vector other = new DenseVector(test.size());    test.assign(other);    for (int i = 0; i < test.size(); i++) {        assertEquals("value[" + i + ']', 0.0, test.getQuick(i), EPSILON);    }}
9f6c04785ceb9b92ba1831d051918d04dcd2943e2eef562f8ae4bc9b7864772c
testAssignVectorCardinality
public void testAssignVectorCardinality()
{    Vector other = new DenseVector(test.size() - 1);    test.assign(other);}
1cd2167b68d321b67d088c7b60215582cb0567d7eecbe7f5ff1670624e9658f9
testAssignUnaryFunction
public void testAssignUnaryFunction()
{    test.assign(Functions.NEGATE);    for (int i = 0; i < test.size(); i++) {        assertEquals("value[" + i + ']', -values[i + 1], test.getQuick(i), EPSILON);    }}
4d07d8d4cb272923d28a57764aed7b4da8e0aafc2de3efb87c7e0a0d978490b3
testAssignBinaryFunction
public void testAssignBinaryFunction() throws Exception
{    test.assign(test, Functions.PLUS);    for (int i = 0; i < test.size(); i++) {        assertEquals("value[" + i + ']', 2 * values[i + 1], test.getQuick(i), EPSILON);    }}
6d3da9d31ca66ea0662c6dda3ac7a30a78d225a76bc154898f0334d1a91139d1
testAssignBinaryFunction2
public void testAssignBinaryFunction2() throws Exception
{    test.assign(Functions.PLUS, 4);    for (int i = 0; i < test.size(); i++) {        assertEquals("value[" + i + ']', values[i + 1] + 4, test.getQuick(i), EPSILON);    }}
2aa725ca69f487c12d46c66c100116e6306b4f9de4300d29be0756ea612e418e
testAssignBinaryFunction3
public void testAssignBinaryFunction3() throws Exception
{    test.assign(new TimesFunction(), 4);    for (int i = 0; i < test.size(); i++) {        assertEquals("value[" + i + ']', values[i + 1] * 4, test.getQuick(i), EPSILON);    }}
2c7b313449cf9e1b2ee07116dc147fbec7041da5bdb74d5e94517b5b4e80a41d
testLike
public void testLike()
{    assertTrue("not like", test.like() instanceof VectorView);}
d57dcf403f9c6b82e67fd2f5a9026df7dc0857544086aaf8e1bb4840c724bbdf
testCrossProduct
public void testCrossProduct()
{    Matrix result = test.cross(test);    assertEquals("row size", test.size(), result.rowSize());    assertEquals("col size", test.size(), result.columnSize());    for (int row = 0; row < result.rowSize(); row++) {        for (int col = 0; col < result.columnSize(); col++) {            assertEquals("cross[" + row + "][" + col + ']', test.getQuick(row) * test.getQuick(col), result.getQuick(row, col), EPSILON);        }    }}
0b309a742a08b61f932d92aa0ff7edc89c85d011d923a9d9fc6e79b18b165775
testBasics
public void testBasics()
{    Matrix a = new UpperTriangular(new double[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }, false);    assertEquals(0, a.viewDiagonal().minus(new DenseVector(new double[] { 1, 5, 8, 10 })).norm(1), 1.0e-10);    assertEquals(0, a.viewPart(0, 3, 1, 3).viewDiagonal().minus(new DenseVector(new double[] { 2, 6, 9 })).norm(1), 1.0e-10);    assertEquals(4, a.get(0, 3), 1.0e-10);    print(a);    Matrix m = new DenseMatrix(4, 4).assign(a);    assertEquals(0, m.minus(a).aggregate(Functions.PLUS, Functions.ABS), 1.0e-10);    print(m);    assertEquals(0, m.transpose().times(m).minus(a.transpose().times(a)).aggregate(Functions.PLUS, Functions.ABS), 1.0e-10);    assertEquals(0, m.plus(m).minus(a.plus(a)).aggregate(Functions.PLUS, Functions.ABS), 1.0e-10);}
4272101f19a630390f71afd391422ced3f3c67b90d59fe54216f551e02982ffa
print
private static void print(Matrix m)
{    for (int i = 0; i < m.rowSize(); i++) {        for (int j = 0; j < m.columnSize(); j++) {            if (Math.abs(m.get(i, j)) > 1.0e-10) {                System.out.printf("%10.3f ", m.get(i, j));            } else {                System.out.printf("%10s ", (i + j) % 3 == 0 ? "." : "");            }        }        System.out.printf("\n");    }    System.out.printf("\n");}
fb8d216f5d546647ad09880c665203271dddb46052a583e0f2d659d7905571cd
createStubs
private static void createStubs(Vector v, Vector realV)
{    expect(v.getLookupCost()).andStubReturn(realV instanceof SequentialAccessSparseVector ? Math.round(Math.log(1000)) : realV.getLookupCost());    expect(v.getIteratorAdvanceCost()).andStubReturn(realV.getIteratorAdvanceCost());    expect(v.isAddConstantTime()).andStubReturn(realV.isAddConstantTime());    expect(v.isSequentialAccess()).andStubReturn(realV.isSequentialAccess());    expect(v.isDense()).andStubReturn(realV.isDense());    expect(v.getNumNondefaultElements()).andStubReturn(realV.isDense() ? realV.size() : 1000);    expect(v.size()).andStubReturn(realV.size());}
a698e19dd59d9f666bc6ced26ee1b03d199f92a8c62015ffa5278c965cead41e
setUpStubs
public void setUpStubs()
{    createStubs(dense, realDense);    createStubs(sasv, realSasv);    createStubs(rasv, realRasv);}
5210a80e585ecd58207cac1ae446713ca8b07c0313b49ac23e717b7e08fad1fa
denseInteractions
public void denseInteractions()
{    replayAll();        assertEquals(VectorBinaryAggregate.AggregateNonzerosIterateThisLookupThat.class, VectorBinaryAggregate.getBestOperation(dense, dense, Functions.PLUS, Functions.MULT).getClass());        assertEquals(VectorBinaryAggregate.AggregateIterateUnionSequential.class, VectorBinaryAggregate.getBestOperation(dense, dense, Functions.MAX_ABS, Functions.MINUS).getClass());        assertEquals(VectorBinaryAggregate.AggregateIterateUnionSequential.class, VectorBinaryAggregate.getBestOperation(dense, dense, Functions.PLUS, Functions.MINUS_SQUARED).getClass());        assertEquals(VectorBinaryAggregate.AggregateIterateUnionSequential.class, VectorBinaryAggregate.getBestOperation(dense, dense, Functions.PLUS, Functions.MINUS_ABS).getClass());        assertEquals(VectorBinaryAggregate.AggregateIterateUnionSequential.class, VectorBinaryAggregate.getBestOperation(dense, dense, Functions.PLUS, Functions.minusAbsPow(1.2)).getClass());        assertEquals(VectorBinaryAggregate.AggregateNonzerosIterateThisLookupThat.class, VectorBinaryAggregate.getBestOperation(dense, dense, Functions.PLUS, Functions.MULT_SQUARE_LEFT).getClass());}
f2e4cf4efa4cbfe49cff6393687e69e004e2777503f534dbf7c69d9f7b3026b0
sasvInteractions
public void sasvInteractions()
{    replayAll();        assertEquals(VectorBinaryAggregate.AggregateIterateIntersection.class, VectorBinaryAggregate.getBestOperation(sasv, sasv, Functions.PLUS, Functions.MULT).getClass());        assertEquals(VectorBinaryAggregate.AggregateIterateUnionSequential.class, VectorBinaryAggregate.getBestOperation(sasv, sasv, Functions.MAX_ABS, Functions.MINUS).getClass());        assertEquals(VectorBinaryAggregate.AggregateIterateUnionSequential.class, VectorBinaryAggregate.getBestOperation(sasv, sasv, Functions.PLUS, Functions.MINUS_SQUARED).getClass());        assertEquals(VectorBinaryAggregate.AggregateIterateUnionSequential.class, VectorBinaryAggregate.getBestOperation(sasv, sasv, Functions.PLUS, Functions.MINUS_ABS).getClass());        assertEquals(VectorBinaryAggregate.AggregateIterateUnionSequential.class, VectorBinaryAggregate.getBestOperation(sasv, sasv, Functions.PLUS, Functions.minusAbsPow(1.2)).getClass());        assertEquals(VectorBinaryAggregate.AggregateIterateIntersection.class, VectorBinaryAggregate.getBestOperation(sasv, sasv, Functions.PLUS, Functions.MULT_SQUARE_LEFT).getClass());}
a762c9b19d23c6f9afe306445b416462ebb95420cf3beeef8ebcb7aaa49aa04a
rasvInteractions
public void rasvInteractions()
{    replayAll();        assertEquals(VectorBinaryAggregate.AggregateNonzerosIterateThisLookupThat.class, VectorBinaryAggregate.getBestOperation(rasv, rasv, Functions.PLUS, Functions.MULT).getClass());        assertEquals(VectorBinaryAggregate.AggregateIterateUnionRandom.class, VectorBinaryAggregate.getBestOperation(rasv, rasv, Functions.MAX_ABS, Functions.MINUS).getClass());        assertEquals(VectorBinaryAggregate.AggregateIterateUnionRandom.class, VectorBinaryAggregate.getBestOperation(rasv, rasv, Functions.PLUS, Functions.MINUS_SQUARED).getClass());        assertEquals(VectorBinaryAggregate.AggregateIterateUnionRandom.class, VectorBinaryAggregate.getBestOperation(rasv, rasv, Functions.PLUS, Functions.MINUS_ABS).getClass());        assertEquals(VectorBinaryAggregate.AggregateIterateUnionRandom.class, VectorBinaryAggregate.getBestOperation(rasv, rasv, Functions.PLUS, Functions.minusAbsPow(1.2)).getClass());        assertEquals(VectorBinaryAggregate.AggregateNonzerosIterateThisLookupThat.class, VectorBinaryAggregate.getBestOperation(rasv, rasv, Functions.PLUS, Functions.MULT_SQUARE_LEFT).getClass());}
cd8fd1e7d3ef6bfb24160d9f65678a4426817536a8ac7984559f621ac8d007c2
sasvDenseInteractions
public void sasvDenseInteractions()
{    replayAll();        assertEquals(VectorBinaryAggregate.AggregateNonzerosIterateThisLookupThat.class, VectorBinaryAggregate.getBestOperation(sasv, dense, Functions.PLUS, Functions.MULT).getClass());        assertEquals(VectorBinaryAggregate.AggregateIterateUnionSequential.class, VectorBinaryAggregate.getBestOperation(sasv, dense, Functions.MAX_ABS, Functions.MINUS).getClass());        assertEquals(VectorBinaryAggregate.AggregateIterateUnionSequential.class, VectorBinaryAggregate.getBestOperation(sasv, dense, Functions.PLUS, Functions.MINUS_SQUARED).getClass());        assertEquals(VectorBinaryAggregate.AggregateIterateUnionSequential.class, VectorBinaryAggregate.getBestOperation(sasv, dense, Functions.PLUS, Functions.MINUS_ABS).getClass());        assertEquals(VectorBinaryAggregate.AggregateIterateUnionSequential.class, VectorBinaryAggregate.getBestOperation(sasv, dense, Functions.PLUS, Functions.minusAbsPow(1.2)).getClass());        assertEquals(VectorBinaryAggregate.AggregateNonzerosIterateThisLookupThat.class, VectorBinaryAggregate.getBestOperation(sasv, dense, Functions.PLUS, Functions.MULT_SQUARE_LEFT).getClass());}
bb56c8e9bd04797e4bb965ce90d5b8626f778e253036df7d89dab0e1f7cdeab7
denseSasvInteractions
public void denseSasvInteractions()
{    replayAll();        assertEquals(VectorBinaryAggregate.AggregateNonzerosIterateThatLookupThis.class, VectorBinaryAggregate.getBestOperation(dense, sasv, Functions.PLUS, Functions.MULT).getClass());        assertEquals(VectorBinaryAggregate.AggregateIterateUnionSequential.class, VectorBinaryAggregate.getBestOperation(dense, sasv, Functions.MAX_ABS, Functions.MINUS).getClass());        assertEquals(VectorBinaryAggregate.AggregateIterateUnionSequential.class, VectorBinaryAggregate.getBestOperation(dense, sasv, Functions.PLUS, Functions.MINUS_SQUARED).getClass());        assertEquals(VectorBinaryAggregate.AggregateIterateUnionSequential.class, VectorBinaryAggregate.getBestOperation(dense, sasv, Functions.PLUS, Functions.MINUS_ABS).getClass());        assertEquals(VectorBinaryAggregate.AggregateIterateUnionSequential.class, VectorBinaryAggregate.getBestOperation(dense, sasv, Functions.PLUS, Functions.minusAbsPow(1.2)).getClass());        assertEquals(VectorBinaryAggregate.AggregateNonzerosIterateThatLookupThis.class, VectorBinaryAggregate.getBestOperation(dense, sasv, Functions.PLUS, Functions.MULT_SQUARE_LEFT).getClass());}
8e984e7dfa81c44b9a159515c6e28214ebf7156ce55b40f9ec9298a0af03563d
denseRasvInteractions
public void denseRasvInteractions()
{    replayAll();        assertEquals(VectorBinaryAggregate.AggregateNonzerosIterateThatLookupThis.class, VectorBinaryAggregate.getBestOperation(dense, rasv, Functions.PLUS, Functions.MULT).getClass());        assertEquals(VectorBinaryAggregate.AggregateIterateUnionRandom.class, VectorBinaryAggregate.getBestOperation(dense, rasv, Functions.MAX_ABS, Functions.MINUS).getClass());        assertEquals(VectorBinaryAggregate.AggregateIterateUnionRandom.class, VectorBinaryAggregate.getBestOperation(dense, rasv, Functions.PLUS, Functions.MINUS_SQUARED).getClass());        assertEquals(VectorBinaryAggregate.AggregateIterateUnionRandom.class, VectorBinaryAggregate.getBestOperation(dense, rasv, Functions.PLUS, Functions.MINUS_ABS).getClass());        assertEquals(VectorBinaryAggregate.AggregateIterateUnionRandom.class, VectorBinaryAggregate.getBestOperation(dense, rasv, Functions.PLUS, Functions.minusAbsPow(1.2)).getClass());        assertEquals(VectorBinaryAggregate.AggregateNonzerosIterateThatLookupThis.class, VectorBinaryAggregate.getBestOperation(dense, rasv, Functions.PLUS, Functions.MULT_SQUARE_LEFT).getClass());}
7b37f5c56f307fe0d7d793b597edfe82e25fb2e57a62309842c9f50ea22b67bd
rasvDenseInteractions
public void rasvDenseInteractions()
{    replayAll();        assertEquals(VectorBinaryAggregate.AggregateNonzerosIterateThisLookupThat.class, VectorBinaryAggregate.getBestOperation(rasv, dense, Functions.PLUS, Functions.MULT).getClass());        assertEquals(VectorBinaryAggregate.AggregateIterateUnionRandom.class, VectorBinaryAggregate.getBestOperation(rasv, dense, Functions.MAX_ABS, Functions.MINUS).getClass());        assertEquals(VectorBinaryAggregate.AggregateIterateUnionRandom.class, VectorBinaryAggregate.getBestOperation(rasv, dense, Functions.PLUS, Functions.MINUS_SQUARED).getClass());        assertEquals(VectorBinaryAggregate.AggregateIterateUnionRandom.class, VectorBinaryAggregate.getBestOperation(rasv, dense, Functions.PLUS, Functions.MINUS_ABS).getClass());        assertEquals(VectorBinaryAggregate.AggregateIterateUnionRandom.class, VectorBinaryAggregate.getBestOperation(rasv, dense, Functions.PLUS, Functions.minusAbsPow(1.2)).getClass());        assertEquals(VectorBinaryAggregate.AggregateNonzerosIterateThisLookupThat.class, VectorBinaryAggregate.getBestOperation(rasv, dense, Functions.PLUS, Functions.MULT_SQUARE_LEFT).getClass());}
1543effd8d0066fcab26bc94b13e501d1ab84ee7b9597b21f502651c6779680e
sasvRasvInteractions
public void sasvRasvInteractions()
{    replayAll();        assertEquals(VectorBinaryAggregate.AggregateNonzerosIterateThisLookupThat.class, VectorBinaryAggregate.getBestOperation(sasv, rasv, Functions.PLUS, Functions.MULT).getClass());        assertEquals(VectorBinaryAggregate.AggregateIterateUnionRandom.class, VectorBinaryAggregate.getBestOperation(sasv, rasv, Functions.MAX_ABS, Functions.MINUS).getClass());        assertEquals(VectorBinaryAggregate.AggregateIterateUnionRandom.class, VectorBinaryAggregate.getBestOperation(sasv, rasv, Functions.PLUS, Functions.MINUS_SQUARED).getClass());        assertEquals(VectorBinaryAggregate.AggregateIterateUnionRandom.class, VectorBinaryAggregate.getBestOperation(sasv, rasv, Functions.PLUS, Functions.MINUS_ABS).getClass());        assertEquals(VectorBinaryAggregate.AggregateIterateUnionRandom.class, VectorBinaryAggregate.getBestOperation(sasv, rasv, Functions.PLUS, Functions.minusAbsPow(1.2)).getClass());        assertEquals(VectorBinaryAggregate.AggregateNonzerosIterateThisLookupThat.class, VectorBinaryAggregate.getBestOperation(sasv, rasv, Functions.PLUS, Functions.MULT_SQUARE_LEFT).getClass());}
49d1a18f26287208a52300520d91a10e3bed82131eaa7c5a698e430f200c5b70
rasvSasvInteractions
public void rasvSasvInteractions()
{    replayAll();        assertEquals(VectorBinaryAggregate.AggregateNonzerosIterateThatLookupThis.class, VectorBinaryAggregate.getBestOperation(rasv, sasv, Functions.PLUS, Functions.MULT).getClass());        assertEquals(VectorBinaryAggregate.AggregateIterateUnionRandom.class, VectorBinaryAggregate.getBestOperation(rasv, sasv, Functions.MAX_ABS, Functions.MINUS).getClass());        assertEquals(VectorBinaryAggregate.AggregateIterateUnionRandom.class, VectorBinaryAggregate.getBestOperation(rasv, sasv, Functions.PLUS, Functions.MINUS_SQUARED).getClass());        assertEquals(VectorBinaryAggregate.AggregateIterateUnionRandom.class, VectorBinaryAggregate.getBestOperation(rasv, sasv, Functions.PLUS, Functions.MINUS_ABS).getClass());        assertEquals(VectorBinaryAggregate.AggregateIterateUnionRandom.class, VectorBinaryAggregate.getBestOperation(rasv, sasv, Functions.PLUS, Functions.minusAbsPow(1.2)).getClass());        assertEquals(VectorBinaryAggregate.AggregateNonzerosIterateThatLookupThis.class, VectorBinaryAggregate.getBestOperation(rasv, sasv, Functions.PLUS, Functions.MULT_SQUARE_LEFT).getClass());}
3695c6a9c3f2c2341d468696b2d893be2435b6fb5a63b06a9a1422492017e8fa
replayAll
private void replayAll()
{    replay(dense, sasv, rasv);}
47da711aa5147507955adb3a3e94cf7d0258b308904a27d5b8d5e397f4911136
generateData
public static Collection<Object[]> generateData()
{    List<Object[]> data = Lists.newArrayList();    for (List<?> entry : Sets.cartesianProduct(Lists.newArrayList(ImmutableSet.of(Functions.PLUS, Functions.PLUS_ABS, Functions.MAX), ImmutableSet.of(Functions.PLUS, Functions.PLUS_ABS, Functions.MULT, Functions.MULT_RIGHT_PLUS1, Functions.MINUS), ImmutableSet.copyOf(VectorBinaryAggregate.OPERATIONS), ImmutableSet.of(new SequentialAccessSparseVector(CARDINALITY), new RandomAccessSparseVector(CARDINALITY), new DenseVector(CARDINALITY)), ImmutableSet.of(new SequentialAccessSparseVector(CARDINALITY), new RandomAccessSparseVector(CARDINALITY), new DenseVector(CARDINALITY))))) {        data.add(entry.toArray());    }    return data;}
1481c13cdc2c630d7bd6331e9cb774dc569f829c1e23252142a9afe6d6d7e136
testSelf
public void testSelf()
{    Vector x = first.like();    Vector xBase = new DenseVector(CARDINALITY);    List<Double> items = Lists.newArrayList();    for (int i = 0; i < x.size(); ++i) {        items.add(r.nextDouble());    }    for (int i = 1; i < x.size(); ++i) {        x.setQuick(i, items.get(i));        xBase.setQuick(i, items.get(i));    }    Vector y = second.like().assign(x);    Vector yBase = new DenseVector(x);    System.out.printf("aggregator %s; combiner %s; operation %s\n", aggregator, combiner, operation);    double expectedResult = combiner.apply(0, 0);    for (int i = 1; i < x.size(); ++i) {        expectedResult = aggregator.apply(expectedResult, combiner.apply(items.get(i), items.get(i)));    }    double result = operation.aggregate(x, y, aggregator, combiner);    double resultBase = operation.aggregate(xBase, yBase, aggregator, combiner);    assertEquals(expectedResult, result, 0.0);    assertEquals(resultBase, result, 0.0);}
62fe95fe57636f0fe9838a0b38e5d3fdefcf7a655a4647d721b03405894400a6
testSeparate
public void testSeparate()
{    List<Double> items1 = Lists.newArrayList();    List<Double> items2 = Lists.newArrayList();    for (int i = 0; i < CARDINALITY; ++i) {        items1.add(r.nextDouble());        items2.add(r.nextDouble());    }    Vector x = first.like();    Vector xBase = new DenseVector(CARDINALITY);    for (int i = 0; i < x.size(); ++i) {        x.setQuick(i, items1.get(i));        xBase.setQuick(i, items1.get(i));    }    Vector y = second.like();    Vector yBase = new DenseVector(CARDINALITY);    for (int i = 0; i < y.size(); ++i) {        y.setQuick(i, items2.get(i));        yBase.setQuick(i, items2.get(i));    }    System.out.printf("aggregator %s; combiner %s; operation %s\n", aggregator, combiner, operation);    double expectedResult = combiner.apply(items1.get(0), items2.get(0));    for (int i = 1; i < x.size(); ++i) {        expectedResult = aggregator.apply(expectedResult, combiner.apply(items1.get(i), items2.get(i)));    }    double result = operation.aggregate(x, y, aggregator, combiner);    double resultBase = operation.aggregate(xBase, yBase, aggregator, combiner);    assertEquals(expectedResult, result, 0.0);    assertEquals(resultBase, result, 0.0);}
fb8d216f5d546647ad09880c665203271dddb46052a583e0f2d659d7905571cd
createStubs
private static void createStubs(Vector v, Vector realV)
{    expect(v.getLookupCost()).andStubReturn(realV instanceof SequentialAccessSparseVector ? Math.round(Math.log(1000)) : realV.getLookupCost());    expect(v.getIteratorAdvanceCost()).andStubReturn(realV.getIteratorAdvanceCost());    expect(v.isAddConstantTime()).andStubReturn(realV.isAddConstantTime());    expect(v.isSequentialAccess()).andStubReturn(realV.isSequentialAccess());    expect(v.isDense()).andStubReturn(realV.isDense());    expect(v.getNumNondefaultElements()).andStubReturn(realV.isDense() ? realV.size() : 1000);    expect(v.size()).andStubReturn(realV.size());}
a698e19dd59d9f666bc6ced26ee1b03d199f92a8c62015ffa5278c965cead41e
setUpStubs
public void setUpStubs()
{    createStubs(dense, realDense);    createStubs(sasv, realSasv);    createStubs(rasv, realRasv);}
5210a80e585ecd58207cac1ae446713ca8b07c0313b49ac23e717b7e08fad1fa
denseInteractions
public void denseInteractions()
{    replayAll();    assertEquals(VectorBinaryAssign.AssignNonzerosIterateThatLookupThisInplaceUpdates.class, VectorBinaryAssign.getBestOperation(dense, dense, Functions.PLUS).getClass());    assertEquals(VectorBinaryAssign.AssignNonzerosIterateThatLookupThisInplaceUpdates.class, VectorBinaryAssign.getBestOperation(dense, dense, Functions.MINUS).getClass());    assertEquals(VectorBinaryAssign.AssignNonzerosIterateThisLookupThat.class, VectorBinaryAssign.getBestOperation(dense, dense, Functions.MULT).getClass());    assertEquals(VectorBinaryAssign.AssignAllLoopInplaceUpdates.class, VectorBinaryAssign.getBestOperation(dense, dense, Functions.DIV).getClass());    assertEquals(VectorBinaryAssign.AssignNonzerosIterateThatLookupThisInplaceUpdates.class, VectorBinaryAssign.getBestOperation(dense, dense, Functions.SECOND_LEFT_ZERO).getClass());}
f2e4cf4efa4cbfe49cff6393687e69e004e2777503f534dbf7c69d9f7b3026b0
sasvInteractions
public void sasvInteractions()
{    replayAll();    assertEquals(VectorBinaryAssign.AssignIterateUnionSequentialMergeUpdates.class, VectorBinaryAssign.getBestOperation(sasv, sasv, Functions.PLUS).getClass());    assertEquals(VectorBinaryAssign.AssignIterateUnionSequentialMergeUpdates.class, VectorBinaryAssign.getBestOperation(sasv, sasv, Functions.MINUS).getClass());    assertEquals(VectorBinaryAssign.AssignIterateUnionSequentialMergeUpdates.class, VectorBinaryAssign.getBestOperation(sasv, sasv, Functions.MULT).getClass());    assertEquals(VectorBinaryAssign.AssignAllIterateSequentialMergeUpdates.class, VectorBinaryAssign.getBestOperation(sasv, sasv, Functions.DIV).getClass());    assertEquals(VectorBinaryAssign.AssignIterateUnionSequentialMergeUpdates.class, VectorBinaryAssign.getBestOperation(sasv, sasv, Functions.SECOND_LEFT_ZERO).getClass());}
a762c9b19d23c6f9afe306445b416462ebb95420cf3beeef8ebcb7aaa49aa04a
rasvInteractions
public void rasvInteractions()
{    replayAll();    assertEquals(VectorBinaryAssign.AssignNonzerosIterateThatLookupThisInplaceUpdates.class, VectorBinaryAssign.getBestOperation(rasv, rasv, Functions.PLUS).getClass());    assertEquals(VectorBinaryAssign.AssignNonzerosIterateThatLookupThisInplaceUpdates.class, VectorBinaryAssign.getBestOperation(rasv, rasv, Functions.MINUS).getClass());    assertEquals(VectorBinaryAssign.AssignNonzerosIterateThisLookupThat.class, VectorBinaryAssign.getBestOperation(rasv, rasv, Functions.MULT).getClass());    assertEquals(VectorBinaryAssign.AssignAllLoopInplaceUpdates.class, VectorBinaryAssign.getBestOperation(rasv, rasv, Functions.DIV).getClass());    assertEquals(VectorBinaryAssign.AssignNonzerosIterateThatLookupThisInplaceUpdates.class, VectorBinaryAssign.getBestOperation(rasv, rasv, Functions.SECOND_LEFT_ZERO).getClass());}
cd8fd1e7d3ef6bfb24160d9f65678a4426817536a8ac7984559f621ac8d007c2
sasvDenseInteractions
public void sasvDenseInteractions()
{    replayAll();    assertEquals(VectorBinaryAssign.AssignNonzerosIterateThatLookupThisMergeUpdates.class, VectorBinaryAssign.getBestOperation(sasv, dense, Functions.PLUS).getClass());    assertEquals(VectorBinaryAssign.AssignNonzerosIterateThatLookupThisMergeUpdates.class, VectorBinaryAssign.getBestOperation(sasv, dense, Functions.MINUS).getClass());    assertEquals(VectorBinaryAssign.AssignNonzerosIterateThisLookupThat.class, VectorBinaryAssign.getBestOperation(sasv, dense, Functions.MULT).getClass());    assertEquals(VectorBinaryAssign.AssignAllIterateThisLookupThatMergeUpdates.class, VectorBinaryAssign.getBestOperation(sasv, dense, Functions.DIV).getClass());    assertEquals(VectorBinaryAssign.AssignNonzerosIterateThatLookupThisMergeUpdates.class, VectorBinaryAssign.getBestOperation(sasv, dense, Functions.SECOND_LEFT_ZERO).getClass());}
bb56c8e9bd04797e4bb965ce90d5b8626f778e253036df7d89dab0e1f7cdeab7
denseSasvInteractions
public void denseSasvInteractions()
{    replayAll();    assertEquals(VectorBinaryAssign.AssignNonzerosIterateThatLookupThisInplaceUpdates.class, VectorBinaryAssign.getBestOperation(dense, sasv, Functions.PLUS).getClass());    assertEquals(VectorBinaryAssign.AssignNonzerosIterateThatLookupThisInplaceUpdates.class, VectorBinaryAssign.getBestOperation(dense, sasv, Functions.MINUS).getClass());    assertEquals(VectorBinaryAssign.AssignIterateUnionSequentialInplaceUpdates.class, VectorBinaryAssign.getBestOperation(dense, sasv, Functions.MULT).getClass());    assertEquals(VectorBinaryAssign.AssignAllIterateThatLookupThisInplaceUpdates.class, VectorBinaryAssign.getBestOperation(dense, sasv, Functions.DIV).getClass());    assertEquals(VectorBinaryAssign.AssignNonzerosIterateThatLookupThisInplaceUpdates.class, VectorBinaryAssign.getBestOperation(dense, sasv, Functions.SECOND_LEFT_ZERO).getClass());}
8e984e7dfa81c44b9a159515c6e28214ebf7156ce55b40f9ec9298a0af03563d
denseRasvInteractions
public void denseRasvInteractions()
{    replayAll();    assertEquals(VectorBinaryAssign.AssignNonzerosIterateThatLookupThisInplaceUpdates.class, VectorBinaryAssign.getBestOperation(dense, rasv, Functions.PLUS).getClass());    assertEquals(VectorBinaryAssign.AssignNonzerosIterateThatLookupThisInplaceUpdates.class, VectorBinaryAssign.getBestOperation(dense, rasv, Functions.MINUS).getClass());    assertEquals(VectorBinaryAssign.AssignNonzerosIterateThisLookupThat.class, VectorBinaryAssign.getBestOperation(dense, rasv, Functions.MULT).getClass());    assertEquals(VectorBinaryAssign.AssignAllLoopInplaceUpdates.class, VectorBinaryAssign.getBestOperation(dense, rasv, Functions.DIV).getClass());    assertEquals(VectorBinaryAssign.AssignNonzerosIterateThatLookupThisInplaceUpdates.class, VectorBinaryAssign.getBestOperation(dense, rasv, Functions.SECOND_LEFT_ZERO).getClass());}
7b37f5c56f307fe0d7d793b597edfe82e25fb2e57a62309842c9f50ea22b67bd
rasvDenseInteractions
public void rasvDenseInteractions()
{    replayAll();    assertEquals(VectorBinaryAssign.AssignNonzerosIterateThatLookupThisInplaceUpdates.class, VectorBinaryAssign.getBestOperation(rasv, dense, Functions.PLUS).getClass());    assertEquals(VectorBinaryAssign.AssignNonzerosIterateThatLookupThisInplaceUpdates.class, VectorBinaryAssign.getBestOperation(rasv, dense, Functions.MINUS).getClass());    assertEquals(VectorBinaryAssign.AssignNonzerosIterateThisLookupThat.class, VectorBinaryAssign.getBestOperation(rasv, dense, Functions.MULT).getClass());    assertEquals(VectorBinaryAssign.AssignAllLoopInplaceUpdates.class, VectorBinaryAssign.getBestOperation(rasv, dense, Functions.DIV).getClass());    assertEquals(VectorBinaryAssign.AssignNonzerosIterateThatLookupThisInplaceUpdates.class, VectorBinaryAssign.getBestOperation(rasv, dense, Functions.SECOND_LEFT_ZERO).getClass());}
1543effd8d0066fcab26bc94b13e501d1ab84ee7b9597b21f502651c6779680e
sasvRasvInteractions
public void sasvRasvInteractions()
{    replayAll();    assertEquals(VectorBinaryAssign.AssignNonzerosIterateThatLookupThisInplaceUpdates.class, VectorBinaryAssign.getBestOperation(sasv, rasv, Functions.PLUS).getClass());    assertEquals(VectorBinaryAssign.AssignNonzerosIterateThatLookupThisInplaceUpdates.class, VectorBinaryAssign.getBestOperation(sasv, rasv, Functions.MINUS).getClass());    assertEquals(VectorBinaryAssign.AssignNonzerosIterateThisLookupThat.class, VectorBinaryAssign.getBestOperation(sasv, rasv, Functions.MULT).getClass());    assertEquals(VectorBinaryAssign.AssignAllIterateThisLookupThatMergeUpdates.class, VectorBinaryAssign.getBestOperation(sasv, rasv, Functions.DIV).getClass());    assertEquals(VectorBinaryAssign.AssignNonzerosIterateThatLookupThisInplaceUpdates.class, VectorBinaryAssign.getBestOperation(sasv, rasv, Functions.SECOND_LEFT_ZERO).getClass());}
49d1a18f26287208a52300520d91a10e3bed82131eaa7c5a698e430f200c5b70
rasvSasvInteractions
public void rasvSasvInteractions()
{    replayAll();    assertEquals(VectorBinaryAssign.AssignNonzerosIterateThatLookupThisInplaceUpdates.class, VectorBinaryAssign.getBestOperation(rasv, sasv, Functions.PLUS).getClass());    assertEquals(VectorBinaryAssign.AssignNonzerosIterateThatLookupThisInplaceUpdates.class, VectorBinaryAssign.getBestOperation(rasv, sasv, Functions.MINUS).getClass());    assertEquals(VectorBinaryAssign.AssignNonzerosIterateThisLookupThat.class, VectorBinaryAssign.getBestOperation(rasv, sasv, Functions.MULT).getClass());    assertEquals(VectorBinaryAssign.AssignAllIterateThatLookupThisInplaceUpdates.class, VectorBinaryAssign.getBestOperation(rasv, sasv, Functions.DIV).getClass());    assertEquals(VectorBinaryAssign.AssignNonzerosIterateThatLookupThisInplaceUpdates.class, VectorBinaryAssign.getBestOperation(rasv, sasv, Functions.SECOND_LEFT_ZERO).getClass());}
3695c6a9c3f2c2341d468696b2d893be2435b6fb5a63b06a9a1422492017e8fa
replayAll
private void replayAll()
{    replay(dense, sasv, rasv);}
47da711aa5147507955adb3a3e94cf7d0258b308904a27d5b8d5e397f4911136
generateData
public static Collection<Object[]> generateData()
{    List<Object[]> data = Lists.newArrayList();    for (List entry : Sets.cartesianProduct(Lists.newArrayList(ImmutableSet.of(Functions.PLUS, Functions.PLUS_ABS, Functions.MULT, Functions.MULT_RIGHT_PLUS1, Functions.MINUS), ImmutableSet.copyOf(VectorBinaryAssign.OPERATIONS)))) {        data.add(entry.toArray());    }    return data;}
58432ca13dcc9a2d8f7cb0c45c65af8d99f3c1cd2607dbd6787a941ae7867341
testAll
public void testAll()
{    SequentialAccessSparseVector x = new SequentialAccessSparseVector(CARDINALITY);    for (int i = 0; i < x.size(); ++i) {        x.setQuick(i, i);    }    SequentialAccessSparseVector y = new SequentialAccessSparseVector(x);    System.out.printf("function %s; operation %s\n", function, operation);    operation.assign(x, y, function);    for (int i = 0; i < x.size(); ++i) {        assertEquals(x.getQuick(i), function.apply(i, i), 0.0);    }}
3e4ff45f585a486924d170d71bedb12fb0785fadf15f96a96da798980f05ed4f
testSparseVector
public void testSparseVector()
{    Vector vec1 = new RandomAccessSparseVector(3);    Vector vec2 = new RandomAccessSparseVector(3);    doTestVectors(vec1, vec2);}
8014e9ffa186ba18f4659e9e5445ac4c1b27023a421b32bbe513bdac44e6084e
testSparseVectorFullIteration
public void testSparseVectorFullIteration()
{    int[] index = { 0, 1, 2, 3, 4, 5 };    double[] values = { 1, 2, 3, 4, 5, 6 };    assertEquals(index.length, values.length);    int n = index.length;    Vector vector = new SequentialAccessSparseVector(n);    for (int i = 0; i < n; i++) {        vector.set(index[i], values[i]);    }    for (int i = 0; i < n; i++) {        assertEquals(vector.get(i), values[i], EPSILON);    }    int elements = 0;    for (Element ignore : vector.all()) {        elements++;    }    assertEquals(n, elements);    assertFalse(new SequentialAccessSparseVector(0).iterator().hasNext());}
b6b6ed2df887613ff81536bcf53d9d13bd6e816605a77f85a517f76b24532672
testSparseVectorSparseIteration
public void testSparseVectorSparseIteration()
{    int[] index = { 0, 1, 2, 3, 4, 5 };    double[] values = { 1, 2, 3, 4, 5, 6 };    assertEquals(index.length, values.length);    int n = index.length;    Vector vector = new SequentialAccessSparseVector(n);    for (int i = 0; i < n; i++) {        vector.set(index[i], values[i]);    }    for (int i = 0; i < n; i++) {        assertEquals(vector.get(i), values[i], EPSILON);    }    int elements = 0;    for (Element ignored : vector.nonZeroes()) {        elements++;    }    assertEquals(n, elements);    Vector empty = new SequentialAccessSparseVector(0);    assertFalse(empty.nonZeroes().iterator().hasNext());}
223b66372bdf9593f0dd82e8cfa3cab199f0ed9e96261d6d464fdf23c2d9c1d9
testEquivalent
public void testEquivalent()
{        RandomAccessSparseVector randomAccessLeft = new RandomAccessSparseVector(3);    Vector sequentialAccessLeft = new SequentialAccessSparseVector(3);    Vector right = new DenseVector(3);    randomAccessLeft.setQuick(0, 1);    randomAccessLeft.setQuick(1, 2);    randomAccessLeft.setQuick(2, 3);    sequentialAccessLeft.setQuick(0, 1);    sequentialAccessLeft.setQuick(1, 2);    sequentialAccessLeft.setQuick(2, 3);    right.setQuick(0, 1);    right.setQuick(1, 2);    right.setQuick(2, 3);    assertEquals(randomAccessLeft, right);    assertEquals(sequentialAccessLeft, right);    assertEquals(sequentialAccessLeft, randomAccessLeft);    Vector leftBar = new DenseVector(3);    leftBar.setQuick(0, 1);    leftBar.setQuick(1, 2);    leftBar.setQuick(2, 3);    assertEquals(leftBar, right);    assertEquals(randomAccessLeft, right);    assertEquals(sequentialAccessLeft, right);    Vector rightBar = new RandomAccessSparseVector(3);    rightBar.setQuick(0, 1);    rightBar.setQuick(1, 2);    rightBar.setQuick(2, 3);    assertEquals(randomAccessLeft, rightBar);    right.setQuick(2, 4);    assertFalse(randomAccessLeft.equals(right));    right = new DenseVector(4);    right.setQuick(0, 1);    right.setQuick(1, 2);    right.setQuick(2, 3);    right.setQuick(3, 3);    assertFalse(randomAccessLeft.equals(right));    randomAccessLeft = new RandomAccessSparseVector(2);    randomAccessLeft.setQuick(0, 1);    randomAccessLeft.setQuick(1, 2);    assertFalse(randomAccessLeft.equals(right));    Vector dense = new DenseVector(3);    right = new DenseVector(3);    right.setQuick(0, 1);    right.setQuick(1, 2);    right.setQuick(2, 3);    dense.setQuick(0, 1);    dense.setQuick(1, 2);    dense.setQuick(2, 3);    assertEquals(dense, right);    RandomAccessSparseVector sparse = new RandomAccessSparseVector(3);    randomAccessLeft = new RandomAccessSparseVector(3);    sparse.setQuick(0, 1);    sparse.setQuick(1, 2);    sparse.setQuick(2, 3);    randomAccessLeft.setQuick(0, 1);    randomAccessLeft.setQuick(1, 2);    randomAccessLeft.setQuick(2, 3);    assertEquals(randomAccessLeft, sparse);    Vector v1 = new VectorView(randomAccessLeft, 0, 2);    Vector v2 = new VectorView(right, 0, 2);    assertEquals(v1, v2);    sparse = new RandomAccessSparseVector(2);    sparse.setQuick(0, 1);    sparse.setQuick(1, 2);    assertEquals(v1, sparse);}
2ef6bfe77bcaac5ba8f99e811bd5eb48071269964912234b50609d79c4869461
doTestVectors
private static void doTestVectors(Vector left, Vector right)
{    left.setQuick(0, 1);    left.setQuick(1, 2);    left.setQuick(2, 3);    right.setQuick(0, 4);    right.setQuick(1, 5);    right.setQuick(2, 6);    double result = left.dot(right);    assertEquals(32.0, result, EPSILON);}
9321ebc2f8bd927e2a7d9cab80d2305cd566081648c41a93b3073b2f4008c2fa
testGetDistanceSquared
public void testGetDistanceSquared()
{    Vector v = new DenseVector(5);    Vector w = new DenseVector(5);    setUpV(v);    setUpW(w);    doTestGetDistanceSquared(v, w);    v = new RandomAccessSparseVector(5);    w = new RandomAccessSparseVector(5);    setUpV(v);    setUpW(w);    doTestGetDistanceSquared(v, w);    v = new SequentialAccessSparseVector(5);    w = new SequentialAccessSparseVector(5);    setUpV(v);    setUpW(w);    doTestGetDistanceSquared(v, w);}
5008d62c073cc93be101bf72929d7053ca7d42dcc26ffe5ff0a70bdc6de08646
testAddTo
public void testAddTo() throws Exception
{    Vector v = new DenseVector(4);    Vector w = new DenseVector(4);    v.setQuick(0, 1);    v.setQuick(1, 2);    v.setQuick(2, 0);    v.setQuick(3, 4);    w.setQuick(0, 1);    w.setQuick(1, 1);    w.setQuick(2, 1);    w.setQuick(3, 1);    w.assign(v, Functions.PLUS);    Vector gold = new DenseVector(new double[] { 2, 3, 1, 5 });    assertEquals(w, gold);    assertFalse(v.equals(gold));}
9f16f4ce7c9721aadd7807269640712ba78b89a2ad7d34f73636667391878bd4
setUpV
private static void setUpV(Vector v)
{    v.setQuick(1, 2);    v.setQuick(2, -4);    v.setQuick(3, -9);}
ece355ae5148a96a74102427dd5d5b109a14fc348cfd5dc9ac723ad1352bae3b
setUpW
private static void setUpW(Vector w)
{    w.setQuick(0, -5);    w.setQuick(1, -1);    w.setQuick(2, 9);    w.setQuick(3, 0.1);    w.setQuick(4, 2.1);}
b6409aa21894537c4c959020a594b9d760cad390d19ccd5868a879e2aea3dc1f
doTestGetDistanceSquared
private static void doTestGetDistanceSquared(Vector v, Vector w)
{    double expected = v.minus(w).getLengthSquared();    assertEquals(expected, v.getDistanceSquared(w), 1.0e-6);}
ff1bd87e003f5ba8fa450076d4912dd7108cf618e199440bea5fc8ec97f8218b
testGetLengthSquared
public void testGetLengthSquared()
{    Vector v = new DenseVector(5);    setUpV(v);    doTestGetLengthSquared(v);    v = new RandomAccessSparseVector(5);    setUpV(v);    doTestGetLengthSquared(v);    v = new SequentialAccessSparseVector(5);    setUpV(v);    doTestGetLengthSquared(v);}
51da1debd8541b40833ceb4c758ae8f3abcd8b65d734dc78362adb637ca5e2bc
lengthSquaredSlowly
public static double lengthSquaredSlowly(Vector v)
{    double d = 0.0;    for (int i = 0; i < v.size(); i++) {        double value = v.get(i);        d += value * value;    }    return d;}
2f0c94eb772d32f86de5263069c841ebd361684dae7cf3898e5448bcf1d024c8
doTestGetLengthSquared
private static void doTestGetLengthSquared(Vector v)
{    double expected = lengthSquaredSlowly(v);    assertEquals("v.getLengthSquared() != sum_of_squared_elements(v)", expected, v.getLengthSquared(), 0.0);    v.set(v.size() / 2, v.get(v.size() / 2) + 1.0);    expected = lengthSquaredSlowly(v);    assertEquals("mutation via set() fails to change lengthSquared", expected, v.getLengthSquared(), EPSILON);    v.setQuick(v.size() / 5, v.get(v.size() / 5) + 1.0);    expected = lengthSquaredSlowly(v);    assertEquals("mutation via setQuick() fails to change lengthSquared", expected, v.getLengthSquared(), EPSILON);    for (Element e : v.nonZeroes()) {        if (e.index() == v.size() - 2) {            e.set(e.get() - 5.0);        }    }    expected = lengthSquaredSlowly(v);    assertEquals("mutation via dense iterator.set fails to change lengthSquared", expected, v.getLengthSquared(), EPSILON);    int i = 0;    for (Element e : v.nonZeroes()) {        i++;        if (i == v.getNumNondefaultElements() - 1) {            e.set(e.get() - 5.0);        }    }    expected = lengthSquaredSlowly(v);    assertEquals("mutation via sparse iterator.set fails to change lengthSquared", expected, v.getLengthSquared(), EPSILON);    v.assign(3.0);    expected = lengthSquaredSlowly(v);    assertEquals("mutation via assign(double) fails to change lengthSquared", expected, v.getLengthSquared(), EPSILON);    v.assign(Functions.SQUARE);    expected = lengthSquaredSlowly(v);    assertEquals("mutation via assign(square) fails to change lengthSquared", expected, v.getLengthSquared(), EPSILON);    v.assign(new double[v.size()]);    expected = lengthSquaredSlowly(v);    assertEquals("mutation via assign(double[]) fails to change lengthSquared", expected, v.getLengthSquared(), EPSILON);    v.getElement(v.size() / 2).set(2.5);    expected = lengthSquaredSlowly(v);    assertEquals("mutation via v.getElement().set() fails to change lengthSquared", expected, v.getLengthSquared(), EPSILON);    v.normalize();    expected = lengthSquaredSlowly(v);    assertEquals("mutation via normalize() fails to change lengthSquared", expected, v.getLengthSquared(), EPSILON);    v.set(0, 1.5);    v.normalize(1.0);    expected = lengthSquaredSlowly(v);    assertEquals("mutation via normalize(double) fails to change lengthSquared", expected, v.getLengthSquared(), EPSILON);    v.times(2.0);    expected = lengthSquaredSlowly(v);    assertEquals("mutation via times(double) fails to change lengthSquared", expected, v.getLengthSquared(), EPSILON);    v.times(v);    expected = lengthSquaredSlowly(v);    assertEquals("mutation via times(vector) fails to change lengthSquared", expected, v.getLengthSquared(), EPSILON);    v.assign(Functions.POW, 3.0);    expected = lengthSquaredSlowly(v);    assertEquals("mutation via assign(pow, 3.0) fails to change lengthSquared", expected, v.getLengthSquared(), EPSILON);    v.assign(v, Functions.PLUS);    expected = lengthSquaredSlowly(v);    assertEquals("mutation via assign(v,plus) fails to change lengthSquared", expected, v.getLengthSquared(), EPSILON);}
67da42917796fb34c2430d36639acd5bccfa9735379b7ead28fbb27a007e4b32
testIterator
public void testIterator()
{    Collection<Integer> expectedIndices = Sets.newHashSet();    int i = 1;    while (i <= 20) {        expectedIndices.add(i * (i + 1) / 2);        i++;    }    Vector denseVector = new DenseVector(i * i);    for (int index : expectedIndices) {        denseVector.set(index, (double) 2 * index);    }    doTestIterators(denseVector, expectedIndices);    Vector randomAccessVector = new RandomAccessSparseVector(i * i);    for (int index : expectedIndices) {        randomAccessVector.set(index, (double) 2 * index);    }    doTestIterators(randomAccessVector, expectedIndices);    Vector sequentialVector = new SequentialAccessSparseVector(i * i);    for (int index : expectedIndices) {        sequentialVector.set(index, (double) 2 * index);    }    doTestIterators(sequentialVector, expectedIndices);}
d1a1e7a9ce19be829db3155799e1d263b2b35c472b31d57f1c26cd6dea07bf55
doTestIterators
private static void doTestIterators(Vector vector, Collection<Integer> expectedIndices)
{    expectedIndices = Sets.newHashSet(expectedIndices);    Iterator<Element> allIterator = vector.all().iterator();    int index = 0;    while (allIterator.hasNext()) {        Element element = allIterator.next();        assertEquals(index, element.index());        if (expectedIndices.contains(index)) {            assertEquals((double) index * 2, element.get(), EPSILON);        } else {            assertEquals(0.0, element.get(), EPSILON);        }        index++;    }    for (Element element : vector.nonZeroes()) {        index = element.index();        assertTrue(expectedIndices.contains(index));        assertEquals((double) index * 2, element.get(), EPSILON);        expectedIndices.remove(index);    }    assertTrue(expectedIndices.isEmpty());}
7f658d8a59ddf1ad25e13b05df38d5af4bc2b42284ce03c0220724ce42612b9c
testNormalize
public void testNormalize()
{    Vector vec1 = new RandomAccessSparseVector(3);    vec1.setQuick(0, 1);    vec1.setQuick(1, 2);    vec1.setQuick(2, 3);    Vector norm = vec1.normalize();    assertNotNull("norm1 is null and it shouldn't be", norm);    Vector vec2 = new SequentialAccessSparseVector(3);    vec2.setQuick(0, 1);    vec2.setQuick(1, 2);    vec2.setQuick(2, 3);    Vector norm2 = vec2.normalize();    assertNotNull("norm1 is null and it shouldn't be", norm2);    Vector expected = new RandomAccessSparseVector(3);    expected.setQuick(0, 0.2672612419124244);    expected.setQuick(1, 0.5345224838248488);    expected.setQuick(2, 0.8017837257372732);    assertEquals(expected, norm);    norm = vec1.normalize(2);    assertEquals(expected, norm);    norm2 = vec2.normalize(2);    assertEquals(expected, norm2);    norm = vec1.normalize(1);    norm2 = vec2.normalize(1);    expected.setQuick(0, 1.0 / 6);    expected.setQuick(1, 2.0 / 6);    expected.setQuick(2, 3.0 / 6);    assertEquals(expected, norm);    assertEquals(expected, norm2);    norm = vec1.normalize(3);                double cube = Math.pow(36, 1.0 / 3);    expected = vec1.divide(cube);    assertEquals(norm, expected);    norm = vec1.normalize(Double.POSITIVE_INFINITY);    norm2 = vec2.normalize(Double.POSITIVE_INFINITY);        expected.setQuick(0, 1.0 / 3);    expected.setQuick(1, 2.0 / 3);    expected.setQuick(2, 3.0 / 3);    assertEquals(norm, expected);    assertEquals(norm2, expected);    norm = vec1.normalize(0);        expected.setQuick(0, 1.0 / 3);    expected.setQuick(1, 2.0 / 3);    expected.setQuick(2, 3.0 / 3);    assertEquals(norm, expected);    try {        vec1.normalize(-1);        fail();    } catch (IllegalArgumentException e) {        }    try {        vec2.normalize(-1);        fail();    } catch (IllegalArgumentException e) {        }}
2f93d18cce818225333beeddfc7e7cb5b535ce1643204619b7d89ba52a85cc0d
testLogNormalize
public void testLogNormalize()
{    Vector vec1 = new RandomAccessSparseVector(3);    vec1.setQuick(0, 1);    vec1.setQuick(1, 2);    vec1.setQuick(2, 3);    Vector norm = vec1.logNormalize();    assertNotNull("norm1 is null and it shouldn't be", norm);    Vector vec2 = new SequentialAccessSparseVector(3);    vec2.setQuick(0, 1);    vec2.setQuick(1, 2);    vec2.setQuick(2, 3);    Vector norm2 = vec2.logNormalize();    assertNotNull("norm1 is null and it shouldn't be", norm2);    Vector expected = new DenseVector(new double[] { 0.2672612419124244, 0.4235990463273581, 0.5345224838248488 });    assertVectorEquals(expected, norm, 1.0e-15);    assertVectorEquals(expected, norm2, 1.0e-15);    norm = vec1.logNormalize(2);    assertVectorEquals(expected, norm, 1.0e-15);    norm2 = vec2.logNormalize(2);    assertVectorEquals(expected, norm2, 1.0e-15);    try {        vec1.logNormalize(1);        fail("Should fail with power == 1");    } catch (IllegalArgumentException e) {        }    try {        vec1.logNormalize(-1);        fail("Should fail with negative power");    } catch (IllegalArgumentException e) {        }    try {        vec2.logNormalize(Double.POSITIVE_INFINITY);        fail("Should fail with positive infinity norm");    } catch (IllegalArgumentException e) {        }}
19e303036f74d94161c5168bf963f0ff87ee4f382a4faa6e834619019ac985fe
assertVectorEquals
private static void assertVectorEquals(Vector expected, Vector actual, double epsilon)
{    assertEquals(expected.size(), actual.size());    for (Element x : expected.all()) {        assertEquals(x.get(), actual.get(x.index()), epsilon);    }}
7a330399f999b75ff93eef718d043ec185fdde006664e1521325052b3aa258e2
testMax
public void testMax()
{    Vector vec1 = new RandomAccessSparseVector(3);    vec1.setQuick(0, -1);    vec1.setQuick(1, -3);    vec1.setQuick(2, -2);    double max = vec1.maxValue();    assertEquals(-1.0, max, 0.0);    int idx = vec1.maxValueIndex();    assertEquals(0, idx);    vec1 = new RandomAccessSparseVector(3);    vec1.setQuick(0, -1);    vec1.setQuick(2, -2);    max = vec1.maxValue();    assertEquals(0.0, max, 0.0);    idx = vec1.maxValueIndex();    assertEquals(1, idx);    vec1 = new SequentialAccessSparseVector(3);    vec1.setQuick(0, -1);    vec1.setQuick(2, -2);    max = vec1.maxValue();    assertEquals(0.0, max, 0.0);    idx = vec1.maxValueIndex();    assertEquals(1, idx);    vec1 = new DenseVector(3);    vec1.setQuick(0, -1);    vec1.setQuick(2, -2);    max = vec1.maxValue();    assertEquals(0.0, max, 0.0);    idx = vec1.maxValueIndex();    assertEquals(1, idx);    vec1 = new RandomAccessSparseVector(3);    max = vec1.maxValue();    assertEquals(0.0, max, EPSILON);    vec1 = new DenseVector(3);    max = vec1.maxValue();    assertEquals(0.0, max, EPSILON);    vec1 = new SequentialAccessSparseVector(3);    max = vec1.maxValue();    assertEquals(0.0, max, EPSILON);    vec1 = new RandomAccessSparseVector(0);    max = vec1.maxValue();    assertEquals(Double.NEGATIVE_INFINITY, max, EPSILON);    vec1 = new DenseVector(0);    max = vec1.maxValue();    assertEquals(Double.NEGATIVE_INFINITY, max, EPSILON);    vec1 = new SequentialAccessSparseVector(0);    max = vec1.maxValue();    assertEquals(Double.NEGATIVE_INFINITY, max, EPSILON);}
8b1ab171891c06bcdf9ef6ec4d70aa286439e6dc26c650b992fa6c63399b793f
testMin
public void testMin()
{    Vector vec1 = new RandomAccessSparseVector(3);    vec1.setQuick(0, 1);    vec1.setQuick(1, 3);    vec1.setQuick(2, 2);    double max = vec1.minValue();    assertEquals(1.0, max, 0.0);    int idx = vec1.maxValueIndex();    assertEquals(1, idx);    vec1 = new RandomAccessSparseVector(3);    vec1.setQuick(0, -1);    vec1.setQuick(2, -2);    max = vec1.maxValue();    assertEquals(0.0, max, 0.0);    idx = vec1.maxValueIndex();    assertEquals(1, idx);    vec1 = new SequentialAccessSparseVector(3);    vec1.setQuick(0, -1);    vec1.setQuick(2, -2);    max = vec1.maxValue();    assertEquals(0.0, max, 0.0);    idx = vec1.maxValueIndex();    assertEquals(1, idx);    vec1 = new DenseVector(3);    vec1.setQuick(0, -1);    vec1.setQuick(2, -2);    max = vec1.maxValue();    assertEquals(0.0, max, 0.0);    idx = vec1.maxValueIndex();    assertEquals(1, idx);    vec1 = new RandomAccessSparseVector(3);    max = vec1.maxValue();    assertEquals(0.0, max, EPSILON);    vec1 = new DenseVector(3);    max = vec1.maxValue();    assertEquals(0.0, max, EPSILON);    vec1 = new SequentialAccessSparseVector(3);    max = vec1.maxValue();    assertEquals(0.0, max, EPSILON);    vec1 = new RandomAccessSparseVector(0);    max = vec1.maxValue();    assertEquals(Double.NEGATIVE_INFINITY, max, EPSILON);    vec1 = new DenseVector(0);    max = vec1.maxValue();    assertEquals(Double.NEGATIVE_INFINITY, max, EPSILON);    vec1 = new SequentialAccessSparseVector(0);    max = vec1.maxValue();    assertEquals(Double.NEGATIVE_INFINITY, max, EPSILON);}
f3367d5f8352c71e5f57a6f4d7d240b85bd0bc807e5fadd849ce1b92515961c6
testDenseVector
public void testDenseVector()
{    Vector vec1 = new DenseVector(3);    Vector vec2 = new DenseVector(3);    doTestVectors(vec1, vec2);}
66275375fe5e4c1366a7ee15303c467abfae349bee2b2da9827f81042b29922b
testVectorView
public void testVectorView()
{    RandomAccessSparseVector vec1 = new RandomAccessSparseVector(3);    RandomAccessSparseVector vec2 = new RandomAccessSparseVector(6);    SequentialAccessSparseVector vec3 = new SequentialAccessSparseVector(3);    SequentialAccessSparseVector vec4 = new SequentialAccessSparseVector(6);    Vector vecV1 = new VectorView(vec1, 0, 3);    Vector vecV2 = new VectorView(vec2, 2, 3);    Vector vecV3 = new VectorView(vec3, 0, 3);    Vector vecV4 = new VectorView(vec4, 2, 3);    doTestVectors(vecV1, vecV2);    doTestVectors(vecV3, vecV4);}
e9327bd644ecc906e98140e50f5f2b3432a75a83b7450328392852bbb29cdd03
doTestEnumeration
private static void doTestEnumeration(double[] apriori, Vector vector)
{    double[] test = new double[apriori.length];    for (Element e : vector.all()) {        test[e.index()] = e.get();    }    for (int i = 0; i < test.length; i++) {        assertEquals(apriori[i], test[i], EPSILON);    }}
93eca1c3616194011fc9f89ee4ab8eeab63d589f4c92225f8af0555d508a340c
testEnumeration
public void testEnumeration()
{    double[] apriori = { 0, 1, 2, 3, 4 };    doTestEnumeration(apriori, new VectorView(new DenseVector(new double[] { -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }), 2, 5));    doTestEnumeration(apriori, new DenseVector(new double[] { 0, 1, 2, 3, 4 }));    Vector sparse = new RandomAccessSparseVector(5);    sparse.set(0, 0);    sparse.set(1, 1);    sparse.set(2, 2);    sparse.set(3, 3);    sparse.set(4, 4);    doTestEnumeration(apriori, sparse);    sparse = new SequentialAccessSparseVector(5);    sparse.set(0, 0);    sparse.set(1, 1);    sparse.set(2, 2);    sparse.set(3, 3);    sparse.set(4, 4);    doTestEnumeration(apriori, sparse);}
0e6e0482cda866f34c07d6b60336680a63180efe78ff6fddea342a243eb6663d
testAggregation
public void testAggregation()
{    Vector v = new DenseVector(5);    Vector w = new DenseVector(5);    setUpFirstVector(v);    setUpSecondVector(w);    doTestAggregation(v, w);    v = new RandomAccessSparseVector(5);    w = new RandomAccessSparseVector(5);    setUpFirstVector(v);    doTestAggregation(v, w);    setUpSecondVector(w);    doTestAggregation(w, v);    v = new SequentialAccessSparseVector(5);    w = new SequentialAccessSparseVector(5);    setUpFirstVector(v);    doTestAggregation(v, w);    setUpSecondVector(w);    doTestAggregation(w, v);}
e74b5bbf951e4c210282eeca0404f87a4fa0467fe34cf36a614c2d8fa66a1d3b
doTestAggregation
private static void doTestAggregation(Vector v, Vector w)
{    assertEquals("aggregate(plus, pow(2)) not equal to " + v.getLengthSquared(), v.getLengthSquared(), v.aggregate(Functions.PLUS, Functions.pow(2)), EPSILON);    assertEquals("aggregate(plus, abs) not equal to " + v.norm(1), v.norm(1), v.aggregate(Functions.PLUS, Functions.ABS), EPSILON);    assertEquals("aggregate(max, abs) not equal to " + v.norm(Double.POSITIVE_INFINITY), v.norm(Double.POSITIVE_INFINITY), v.aggregate(Functions.MAX, Functions.ABS), EPSILON);    assertEquals("v.dot(w) != v.aggregate(w, plus, mult)", v.dot(w), v.aggregate(w, Functions.PLUS, Functions.MULT), EPSILON);    assertEquals("|(v-w)|^2 != v.aggregate(w, plus, chain(pow(2), minus))", v.minus(w).dot(v.minus(w)), v.aggregate(w, Functions.PLUS, Functions.chain(Functions.pow(2), Functions.MINUS)), EPSILON);}
eeeb47250e2c70b613be034639bf64fb8f29ab6046feb5e04509cff0c8e316d2
testEmptyAggregate1
public void testEmptyAggregate1()
{    assertEquals(1.0, new DenseVector(new double[] { 1 }).aggregate(Functions.MIN, Functions.IDENTITY), EPSILON);    assertEquals(1.0, new DenseVector(new double[] { 2, 1 }).aggregate(Functions.MIN, Functions.IDENTITY), EPSILON);    assertEquals(0, new DenseVector(new double[0]).aggregate(Functions.MIN, Functions.IDENTITY), 0);}
221a48e0dac4d74a267d1d9c7005c5fbc2028adf9f4b783887403531428e8f2c
testEmptyAggregate2
public void testEmptyAggregate2()
{    assertEquals(3.0, new DenseVector(new double[] { 1 }).aggregate(new DenseVector(new double[] { 2 }), Functions.MIN, Functions.PLUS), EPSILON);    assertEquals(0, new DenseVector(new double[0]).aggregate(new DenseVector(new double[0]), Functions.MIN, Functions.PLUS), 0);}
7b74fa1f9a8f52563f0669df27695f4b3615dc8efab980ab3c3f3a0c21389c3e
setUpFirstVector
private static void setUpFirstVector(Vector v)
{    v.setQuick(1, 2);    v.setQuick(2, 0.5);    v.setQuick(3, -5);}
c326d540e2723a39069d4f351caa6cf25543b7d8773fc364ed8134edd3be150f
setUpSecondVector
private static void setUpSecondVector(Vector v)
{    v.setQuick(0, 3);    v.setQuick(1, -1.5);    v.setQuick(2, -5);    v.setQuick(3, 2);}
6f358cbe7a3eae8f262a530d30d51ef0685538f53bae405362289f0f11c36aab
testHashCodeEquivalence
public void testHashCodeEquivalence()
{        Vector sparseLeft = new RandomAccessSparseVector(3);    Vector denseRight = new DenseVector(3);    sparseLeft.setQuick(0, 1);    sparseLeft.setQuick(1, 2);    sparseLeft.setQuick(2, 3);    denseRight.setQuick(0, 1);    denseRight.setQuick(1, 2);    denseRight.setQuick(2, 3);    assertEquals(sparseLeft, denseRight);    assertEquals(sparseLeft.hashCode(), denseRight.hashCode());    sparseLeft = new SequentialAccessSparseVector(3);    sparseLeft.setQuick(0, 1);    sparseLeft.setQuick(1, 2);    sparseLeft.setQuick(2, 3);    assertEquals(sparseLeft, denseRight);    assertEquals(sparseLeft.hashCode(), denseRight.hashCode());    Vector denseLeft = new DenseVector(3);    denseLeft.setQuick(0, 1);    denseLeft.setQuick(1, 2);    denseLeft.setQuick(2, 3);    assertEquals(denseLeft, denseRight);    assertEquals(denseLeft.hashCode(), denseRight.hashCode());    Vector sparseRight = new SequentialAccessSparseVector(3);    sparseRight.setQuick(0, 1);    sparseRight.setQuick(1, 2);    sparseRight.setQuick(2, 3);    assertEquals(sparseLeft, sparseRight);    assertEquals(sparseLeft.hashCode(), sparseRight.hashCode());    DenseVector emptyLeft = new DenseVector(0);    Vector emptyRight = new SequentialAccessSparseVector(0);    assertEquals(emptyLeft, emptyRight);    assertEquals(emptyLeft.hashCode(), emptyRight.hashCode());    emptyRight = new RandomAccessSparseVector(0);    assertEquals(emptyLeft, emptyRight);    assertEquals(emptyLeft.hashCode(), emptyRight.hashCode());}
ad6f12d30164517b5d8852c2595ff6dcc9e828122d198b1d26eaebfe2762e22e
testHashCode
public void testHashCode()
{        Vector left = new SequentialAccessSparseVector(3);    Vector right = new SequentialAccessSparseVector(3);    left.setQuick(0, 1);    left.setQuick(2, 2);    right.setQuick(0, 1);    right.setQuick(1, 2);    assertFalse(left.equals(right));    assertFalse(left.hashCode() == right.hashCode());    left = new RandomAccessSparseVector(3);    right = new RandomAccessSparseVector(3);    left.setQuick(0, 1);    left.setQuick(2, 2);    right.setQuick(0, 1);    right.setQuick(1, 2);    assertFalse(left.equals(right));    assertFalse(left.hashCode() == right.hashCode());        right = new SequentialAccessSparseVector(5);    right.setQuick(0, 1);    right.setQuick(2, 2);    assertFalse(left.equals(right));    assertFalse(left.hashCode() == right.hashCode());    right = new RandomAccessSparseVector(5);    right.setQuick(0, 1);    right.setQuick(2, 2);    assertFalse(left.equals(right));    assertFalse(left.hashCode() == right.hashCode());}
5fc652c2aef276e39908ff3dda24cab8d1b2ae527ed599cefc6074198f401f5f
testIteratorRasv
public void testIteratorRasv()
{    testIterator(new RandomAccessSparseVector(99));    testEmptyAllIterator(new RandomAccessSparseVector(0));    testExample1NonZeroIterator(new RandomAccessSparseVector(13));}
be4315d7f88772acadd1037ef006ed834b48a53b3a478b048cc1f8c82e668110
testIteratorSasv
public void testIteratorSasv()
{    testIterator(new SequentialAccessSparseVector(99));    testEmptyAllIterator(new SequentialAccessSparseVector(0));    testExample1NonZeroIterator(new SequentialAccessSparseVector(13));}
88b7b907e15d6ba8402ab3ce8d037f8c921fa07bce0d2542c434f3d87918f124
testIteratorDense
public void testIteratorDense()
{    testIterator(new DenseVector(99));    testEmptyAllIterator(new DenseVector(0));    testExample1NonZeroIterator(new DenseVector(13));}
83465997f5f4ff88d393fc8a0126359630d16e8a407313dc314ec28c4662c9db
testIterator
private static void testIterator(Vector vector)
{    testSkips(vector.like());    testSkipsLast(vector.like());    testEmptyNonZeroIterator(vector.like());    testSingleNonZeroIterator(vector.like());}
46cd2ca07c8130510d035cbb2580db05f0be01e5b6a0aab088d0de63d9d78145
testSkips
private static void testSkips(Vector vector)
{    vector.set(0, 1);    vector.set(2, 2);    vector.set(4, 3);    vector.set(6, 4);        Iterator<Element> it = vector.nonZeroes().iterator();    Element element = null;    int i = 0;    HashSet<Integer> indexes = new HashSet<>();    while (it.hasNext()) {                if (i % 2 == 0) {            element = it.next();            indexes.add(element.index());        }                assertEquals(element.get(), vector.get(element.index()), 0);        ++i;    }        assertEquals(7, i);    assertEquals(4, indexes.size());    assertTrue(indexes.contains(0));    assertTrue(indexes.contains(2));    assertTrue(indexes.contains(4));    assertTrue(indexes.contains(6));        it = vector.all().iterator();    element = null;    i = 0;    while (it.hasNext()) {                if (i % 2 == 0) {            element = it.next();        }                assertEquals(element.index(), i / 2);        assertEquals(element.get(), vector.get(i / 2), 0);        ++i;    }        assertEquals(197, i);}
bbbefcdeba2ff6508263ca375a203d2d4e925c26de10bf8b78db40f44cb68ec7
testSkipsLast
private static void testSkipsLast(Vector vector)
{    vector.set(1, 6);    vector.set(98, 6);        Iterator<Element> it = vector.nonZeroes().iterator();    int i = 0;    while (it.hasNext()) {                it.next();        ++i;    }        assertEquals(2, i);        it = vector.all().iterator();    i = 0;    while (it.hasNext()) {                Element element = it.next();        assertEquals(i, element.index());        ++i;    }    assertFalse(it.hasNext());        assertEquals(99, i);}
5fc6d722a521b89571f53b7e9501af967a973979f4848599f50d669dfcb0c037
testEmptyNonZeroIterator
private static void testEmptyNonZeroIterator(Vector vector)
{        Iterator<Element> it = vector.nonZeroes().iterator();    int i = 0;    while (it.hasNext()) {        ++i;    }    assertEquals(0, i);    it = vector.nonZeroes().iterator();    assertFalse(it.hasNext());    try {        it.next();        fail();    } catch (NoSuchElementException e) {        }}
ef8576c86ec930cf0467425cb26be2320ad44da3075c7d2f357921bf03071747
testEmptyAllIterator
private static void testEmptyAllIterator(Vector vector)
{        Iterator<Element> it = vector.all().iterator();    int i = 0;    while (it.hasNext()) {        ++i;    }    assertEquals(0, i);    it = vector.nonZeroes().iterator();    assertFalse(it.hasNext());    try {        it.next();        fail();    } catch (NoSuchElementException e) {        }    it = vector.all().iterator();    assertFalse(it.hasNext());    try {        it.next();        fail();    } catch (NoSuchElementException e) {        }}
971d93eb5b2d2e9a9e41438a55e099c3a9142efc7d946afb5826c1d20c545c79
testNumNonZerosDense
public void testNumNonZerosDense()
{    DenseVector vector = new DenseVector(10);    vector.assign(1);    vector.setQuick(3, 0);    vector.set(5, 0);    assertEquals(8, vector.getNumNonZeroElements());}
9058dcdaa160b8085d3ef1cc88654707e0c85fcfe097d86e5a15ad39e9dc0132
testNumNonZerosRandomAccessSparse
public void testNumNonZerosRandomAccessSparse()
{    RandomAccessSparseVector vector = new RandomAccessSparseVector(10);    vector.setQuick(3, 1);    vector.set(5, 1);    vector.setQuick(7, 0);    vector.set(9, 0);    assertEquals(2, vector.getNumNonZeroElements());}
86916cfe6661c7908f501d1308a7c02a880f4803485cfa2cc3f2ee15bc6d28a2
testNumNonZerosSequentialAccessSparse
public void testNumNonZerosSequentialAccessSparse()
{    SequentialAccessSparseVector vector = new SequentialAccessSparseVector(10);    vector.setQuick(3, 1);    vector.set(5, 1);    vector.setQuick(7, 0);    vector.set(9, 0);    assertEquals(2, vector.getNumNonZeroElements());}
c6953c42ee086b8b268d0dcc910aa5c354591ae24d6d81dfb0c812f158250556
testSingleNonZeroIterator
private static void testSingleNonZeroIterator(Vector vector)
{    vector.set(1, 6);        Iterator<Element> it = vector.nonZeroes().iterator();    for (int i = 0; i < 10; ++i) {        assertTrue(it.hasNext());    }    it = vector.nonZeroes().iterator();    it.next();    for (int i = 0; i < 10; ++i) {        assertFalse(it.hasNext());    }    try {        it.next();        fail();    } catch (NoSuchElementException e) {        }}
925a25e366b37ccf272b885b425e366cba20c77fdd4676bc53955447804ee65e
testExample1NonZeroIterator
private static void testExample1NonZeroIterator(Vector vector)
{    double[] val = { 0, 2, 0, 0, 8, 3, 0, 6, 0, 1, 1, 2, 1 };    for (int i = 0; i < val.length; ++i) {        vector.set(i, val[i]);    }    Set<Integer> expected = Sets.newHashSet(1, 4, 5, 7, 9, 10, 11, 12);    Set<Double> expectedValue = Sets.newHashSet(2.0, 8.0, 3.0, 6.0, 1.0);        Iterator<Element> it = vector.nonZeroes().iterator();    int i = 0;    while (it.hasNext()) {        Element e = it.next();        assertTrue(expected.contains(e.index()));        assertTrue(expectedValue.contains(e.get()));        ++i;    }    assertEquals(8, i);        assertEquals(8, vector.getNumNonZeroElements());        it = vector.nonZeroes().iterator();    i = 0;    while (it.hasNext()) {        Element e = it.next();        if (e.index() == 5) {            e.set(0.0);        }        ++i;    }    assertEquals(8, i);    assertEquals(7, vector.getNumNonZeroElements());        it = vector.nonZeroes().iterator();    i = 0;    while (it.hasNext()) {        Element e = it.next();        if (e.index() == 5) {            vector.set(5, 0.0);        }        ++i;    }        assertEquals(7, i);        assertEquals(7, vector.getNumNonZeroElements());}
7e8b62767adf1dbb03125157e87e0e79b004250def9ef0e133faa19d91fd8a91
testLength
public void testLength()
{    Vector v = new DenseVector(new double[] { 0.9921337470551008, 1.0031004325833064, 0.9963963182745947 });    Centroid c = new Centroid(3, new DenseVector(v), 2);    assertEquals(c.getVector().getLengthSquared(), c.getLengthSquared(), 1.0e-17);        c.set(0, -1);    System.out.printf("c = %.9f\nv = %.9f\n", c.getLengthSquared(), c.getVector().getLengthSquared());    assertEquals(c.getVector().getLengthSquared(), c.getLengthSquared(), 1.0e-17);}
d6a6297d6cf28dfe912c53efcbd75a946ae11735a08ba1b69910a800bce10eb0
vectorToTest
public Vector vectorToTest(int size)
{    return new WeightedVector(new DenseVector(size), 4.52, 345);}
f8b9ecb9a0e4d0d0af8efa843d5719427ee53e6c527bf295328237809eda0143
testOrdering
public void testOrdering()
{    WeightedVector v1 = new WeightedVector(new DenseVector(new double[] { 1, 2, 3 }), 5.41, 31);    WeightedVector v2 = new WeightedVector(new DenseVector(new double[] { 1, 2, 3 }), 5.00, 31);    WeightedVector v3 = new WeightedVector(new DenseVector(new double[] { 1, 3, 3 }), 5.00, 31);    WeightedVector v4 = v1.clone();    WeightedVectorComparator comparator = new WeightedVectorComparator();    assertTrue(comparator.compare(v1, v2) > 0);    assertTrue(comparator.compare(v3, v1) < 0);    assertTrue(comparator.compare(v3, v2) > 0);    assertEquals(0, comparator.compare(v4, v1));    assertEquals(0, comparator.compare(v1, v1));}
f6aa0d5c7ed0557ada7320bb986d3a26a83ff2d5cac68773ca8e4cc94bf7b86f
testProjection
public void testProjection()
{    Vector v1 = new DenseVector(10).assign(Functions.random());    WeightedVector v2 = new WeightedVector(v1, v1, 31);    assertEquals(v1.dot(v1), v2.getWeight(), 1.0e-13);    assertEquals(31, v2.getIndex());    Matrix y = new DenseMatrix(10, 4).assign(Functions.random());    Matrix q = new QRDecomposition(y.viewPart(0, 10, 0, 3)).getQ();    Vector nullSpace = y.viewColumn(3).minus(q.times(q.transpose().times(y.viewColumn(3))));    WeightedVector v3 = new WeightedVector(q.viewColumn(0).plus(q.viewColumn(1)), nullSpace, 1);    assertEquals(0, v3.getWeight(), 1.0e-13);    Vector qx = q.viewColumn(0).plus(q.viewColumn(1)).normalize();    WeightedVector v4 = new WeightedVector(qx, q.viewColumn(0), 2);    assertEquals(Math.sqrt(0.5), v4.getWeight(), 1.0e-13);    WeightedVector v5 = WeightedVector.project(q.viewColumn(0), qx);    assertEquals(Math.sqrt(0.5), v5.getWeight(), 1.0e-13);}
4418db934d4155c558cef1530654d1053ddcdb06e41cedabef91b0a8f1be57e3
testSize
public void testSize()
{    assertEquals("size", 3, getTestVector().getNumNonZeroElements());}
9d02883c369189f25b6de6a3fc270f77e8252465ca459b808cc75f7eac410ba7
generateTestVector
 Vector generateTestVector(int cardinality)
{    return new WeightedVector(new DenseVector(cardinality), 3.14, 53);}
0d8740e578e53aeea547dc5e48d2140ae0cfe2c77a3e75f0e0901e8f865dbb1a
quietClose
public static void quietClose(ResultSet closeable)
{    if (closeable != null) {        try {            closeable.close();        } catch (SQLException sqle) {            log.warn("Unexpected exception while closing; continuing", sqle);        }    }}
94365d145f25554b6a28b4aeb23fba5f2b5889e16221dc90b802e84bc23625f1
quietClose
public static void quietClose(Statement closeable)
{    if (closeable != null) {        try {            closeable.close();        } catch (SQLException sqle) {            log.warn("Unexpected exception while closing; continuing", sqle);        }    }}
b13e01d4139cad785458dfbd61d20ea7c039005a6b66db68aa3d8a6905d4626a
quietClose
public static void quietClose(Connection closeable)
{    if (closeable != null) {        try {            closeable.close();        } catch (SQLException sqle) {            log.warn("Unexpected exception while closing; continuing", sqle);        }    }}
cf154aa42ecd74d1c6c3a16606843097af19cea711872ca8f8d678e937866af7
quietClose
public static void quietClose(ResultSet resultSet, Statement statement, Connection connection)
{    quietClose(resultSet);    quietClose(statement);    quietClose(connection);}
21efe3974fb4720028a52e1c27b7b3b687659bb504a9e12794ce0e2192748717
close
public static void close(Collection<? extends Closeable> closeables) throws IOException
{    Throwable lastThr = null;    for (Closeable closeable : closeables) {        try {            closeable.close();        } catch (Throwable thr) {            log.error(thr.getMessage(), thr);            lastThr = thr;        }    }            closeables.clear();    if (lastThr != null) {        if (lastThr instanceof IOException) {            throw (IOException) lastThr;        } else if (lastThr instanceof RuntimeException) {            throw (RuntimeException) lastThr;        } else {            throw (Error) lastThr;        }    }}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    if (file.isFile()) {        file.delete();    }}
e0823f55b3a09d41a3e1e792f7e6687db9199c2db9b29e9922d93cbdc6f1284b
close
public void close() throws IOException
{    if (mo != null) {        mo.close();    }}
1ae0e7c5cd84854c48f77ffe90e2012adfc28dcc0bd72ed80884334e2dd73b46
get
public Matrix get()
{    return matrix;}
04a34a5d18730977a06e44b40878a18369dc81e1bebd3603646d7b62c29cd598
set
public void set(Matrix matrix)
{    this.matrix = matrix;}
a894510dd4db439ff8e17ae1059489dc3abc97178e5932ceed0c70c3af165401
write
public void write(DataOutput out) throws IOException
{    writeMatrix(out, matrix);}
5478cc5683f6dfd4515c383752d7c803555efc63d03fd84a03ba8dcd17eb4324
readFields
public void readFields(DataInput in) throws IOException
{    matrix = readMatrix(in);}
372db61d42e4acd2ea515c1b36934c4220e77a6f84d79fde374e54954665dc85
readLabels
public static void readLabels(DataInput in, Map<String, Integer> columnLabelBindings, Map<String, Integer> rowLabelBindings) throws IOException
{    int colSize = in.readInt();    if (colSize > 0) {        for (int i = 0; i < colSize; i++) {            columnLabelBindings.put(in.readUTF(), in.readInt());        }    }    int rowSize = in.readInt();    if (rowSize > 0) {        for (int i = 0; i < rowSize; i++) {            rowLabelBindings.put(in.readUTF(), in.readInt());        }    }}
0b7a19df31720d321caf02089e4c19dd85a49bf2bcff772c0a6d52471c1137b4
writeLabelBindings
public static void writeLabelBindings(DataOutput out, Map<String, Integer> columnLabelBindings, Map<String, Integer> rowLabelBindings) throws IOException
{    if (columnLabelBindings == null) {        out.writeInt(0);    } else {        out.writeInt(columnLabelBindings.size());        for (Map.Entry<String, Integer> stringIntegerEntry : columnLabelBindings.entrySet()) {            out.writeUTF(stringIntegerEntry.getKey());            out.writeInt(stringIntegerEntry.getValue());        }    }    if (rowLabelBindings == null) {        out.writeInt(0);    } else {        out.writeInt(rowLabelBindings.size());        for (Map.Entry<String, Integer> stringIntegerEntry : rowLabelBindings.entrySet()) {            out.writeUTF(stringIntegerEntry.getKey());            out.writeInt(stringIntegerEntry.getValue());        }    }}
15592c06496b10154d966e3c043091237adda6fa49ce058678d367272e78d318
readMatrix
public static Matrix readMatrix(DataInput in) throws IOException
{    int flags = in.readInt();    Preconditions.checkArgument(flags >> NUM_FLAGS == 0, "Unknown flags set: %d", Integer.toString(flags, 2));    boolean dense = (flags & FLAG_DENSE) != 0;    boolean sequential = (flags & FLAG_SEQUENTIAL) != 0;    boolean hasLabels = (flags & FLAG_LABELS) != 0;    boolean isSparseRowMatrix = (flags & FLAG_SPARSE_ROW) != 0;    int rows = in.readInt();    int columns = in.readInt();    byte vectorFlags = in.readByte();    Matrix matrix;    if (dense) {        matrix = new DenseMatrix(rows, columns);        for (int row = 0; row < rows; row++) {            matrix.assignRow(row, VectorWritable.readVector(in, vectorFlags, columns));        }    } else if (isSparseRowMatrix) {        Vector[] rowVectors = new Vector[rows];        for (int row = 0; row < rows; row++) {            rowVectors[row] = VectorWritable.readVector(in, vectorFlags, columns);        }        matrix = new SparseRowMatrix(rows, columns, rowVectors, true, !sequential);    } else {        matrix = new SparseMatrix(rows, columns);        int numNonZeroRows = in.readInt();        int rowsRead = 0;        while (rowsRead++ < numNonZeroRows) {            int rowIndex = in.readInt();            matrix.assignRow(rowIndex, VectorWritable.readVector(in, vectorFlags, columns));        }    }    if (hasLabels) {        Map<String, Integer> columnLabelBindings = new HashMap<>();        Map<String, Integer> rowLabelBindings = new HashMap<>();        readLabels(in, columnLabelBindings, rowLabelBindings);        if (!columnLabelBindings.isEmpty()) {            matrix.setColumnLabelBindings(columnLabelBindings);        }        if (!rowLabelBindings.isEmpty()) {            matrix.setRowLabelBindings(rowLabelBindings);        }    }    return matrix;}
cc17a42f1e21c72b743f683028fb09248316595f06e50bc1ec4000ae4a1646b7
writeMatrix
public static void writeMatrix(final DataOutput out, Matrix matrix) throws IOException
{    int flags = 0;    Vector row = matrix.viewRow(0);    boolean isDense = row.isDense();    if (isDense) {        flags |= FLAG_DENSE;    }    if (row.isSequentialAccess()) {        flags |= FLAG_SEQUENTIAL;    }    if (matrix.getRowLabelBindings() != null || matrix.getColumnLabelBindings() != null) {        flags |= FLAG_LABELS;    }    boolean isSparseRowMatrix = matrix instanceof SparseRowMatrix;    if (isSparseRowMatrix) {        flags |= FLAG_SPARSE_ROW;    }    out.writeInt(flags);    out.writeInt(matrix.rowSize());    out.writeInt(matrix.columnSize());        byte vectorFlags = VectorWritable.flags(matrix.viewRow(0), false);    out.writeByte(vectorFlags);    if (isDense || isSparseRowMatrix) {        for (int i = 0; i < matrix.rowSize(); i++) {            VectorWritable.writeVectorContents(out, matrix.viewRow(i), vectorFlags);        }    } else {        IntArrayList rowIndices = ((SparseMatrix) matrix).nonZeroRowIndices();        int numNonZeroRows = rowIndices.size();        out.writeInt(numNonZeroRows);        for (int i = 0; i < numNonZeroRows; i++) {            int rowIndex = rowIndices.getQuick(i);            out.writeInt(rowIndex);            VectorWritable.writeVectorContents(out, matrix.viewRow(rowIndex), vectorFlags);        }    }    if ((flags & FLAG_LABELS) != 0) {        writeLabelBindings(out, matrix.getColumnLabelBindings(), matrix.getRowLabelBindings());    }}
453890ffe78978bae38722201047dc35d871f0518bc0c2c4276a63b1fa100a50
writeSignedVarLong
public static void writeSignedVarLong(long value, DataOutput out) throws IOException
{        writeUnsignedVarLong((value << 1) ^ (value >> 63), out);}
93314b9caa25e3d7b78373fc155baf394c63938d90b3e226bce90d167da3bc0e
writeUnsignedVarLong
public static void writeUnsignedVarLong(long value, DataOutput out) throws IOException
{    while ((value & 0xFFFFFFFFFFFFFF80L) != 0L) {        out.writeByte(((int) value & 0x7F) | 0x80);        value >>>= 7;    }    out.writeByte((int) value & 0x7F);}
d18f4c807bd4c182f80fd9c381ed26d65bc52a5782d24e8204ab496909b51bf2
writeSignedVarInt
public static void writeSignedVarInt(int value, DataOutput out) throws IOException
{        writeUnsignedVarInt((value << 1) ^ (value >> 31), out);}
2087f8d0b54f2e7ec3877330fe98e2af3a67b93199688ae55cdfdf859b85d0c1
writeUnsignedVarInt
public static void writeUnsignedVarInt(int value, DataOutput out) throws IOException
{    while ((value & 0xFFFFFF80) != 0L) {        out.writeByte((value & 0x7F) | 0x80);        value >>>= 7;    }    out.writeByte(value & 0x7F);}
df95936a9d6e53d2df69738abecdc4d626d97c014fa5f86f826231e18e426c67
readSignedVarLong
public static long readSignedVarLong(DataInput in) throws IOException
{    long raw = readUnsignedVarLong(in);        long temp = (((raw << 63) >> 63) ^ raw) >> 1;        return temp ^ (raw & (1L << 63));}
8b4559df89c49bbd891adb6acffc66bacbd4494da93818f038b2b5c870f3e0ce
readUnsignedVarLong
public static long readUnsignedVarLong(DataInput in) throws IOException
{    long value = 0L;    int i = 0;    long b;    while (((b = in.readByte()) & 0x80L) != 0) {        value |= (b & 0x7F) << i;        i += 7;        Preconditions.checkArgument(i <= 63, "Variable length quantity is too long (must be <= 63)");    }    return value | (b << i);}
2f272f8344eaf3adfb57929730b74298fe9e96b576157cca4f5f01b414225f43
readSignedVarInt
public static int readSignedVarInt(DataInput in) throws IOException
{    int raw = readUnsignedVarInt(in);        int temp = (((raw << 31) >> 31) ^ raw) >> 1;        return temp ^ (raw & (1 << 31));}
2f26e268c9bba285a31568e9b4de329fe61e1047ef18729cfa818d52d2ae2ba3
readUnsignedVarInt
public static int readUnsignedVarInt(DataInput in) throws IOException
{    int value = 0;    int i = 0;    int b;    while (((b = in.readByte()) & 0x80) != 0) {        value |= (b & 0x7F) << i;        i += 7;        Preconditions.checkArgument(i <= 35, "Variable length quantity is too long (must be <= 35)");    }    return value | (b << i);}
8af6f6d7eefe78b1e80e17630879132b0c53eaa121aa984012f2c24b1d53f6b7
get
public int get()
{    return value;}
8f4b13248bf6f053668214408d704424f9ea410892ef6c5c3578a171a7af27fb
set
public void set(int value)
{    this.value = value;}
74e378df448c6c3cd090d6daf881cfac8957dd555869ea4c13a46bdc6cdcf9a6
equals
public boolean equals(Object other)
{    return other instanceof VarIntWritable && ((VarIntWritable) other).value == value;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return value;}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return String.valueOf(value);}
bd99371d204a111a89d4c93c96c58003ae5d592ea9d3492a917df18bc6daedbc
clone
public VarIntWritable clone()
{    return new VarIntWritable(value);}
017d81d77a567bcc86581a10773885f1188109db32d5fa4a18f0cb0d49565fa0
compareTo
public int compareTo(VarIntWritable other)
{    if (value < other.value) {        return -1;    }    if (value > other.value) {        return 1;    }    return 0;}
a894510dd4db439ff8e17ae1059489dc3abc97178e5932ceed0c70c3af165401
write
public void write(DataOutput out) throws IOException
{    Varint.writeSignedVarInt(value, out);}
5478cc5683f6dfd4515c383752d7c803555efc63d03fd84a03ba8dcd17eb4324
readFields
public void readFields(DataInput in) throws IOException
{    value = Varint.readSignedVarInt(in);}
9c296a9ae6604f1ab76b67812ec53c653913df94f0267698b3e9a72e90441ce2
get
public long get()
{    return value;}
b48c1d975bde7d2be2f8d388dd77611745c5f2fe745fd23c4e998920ab6a17d7
set
public void set(long value)
{    this.value = value;}
74e378df448c6c3cd090d6daf881cfac8957dd555869ea4c13a46bdc6cdcf9a6
equals
public boolean equals(Object other)
{    return other != null && getClass().equals(other.getClass()) && ((VarLongWritable) other).value == value;}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return Longs.hashCode(value);}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return String.valueOf(value);}
4d84af51b58eb35e6692a541e07812623224af0b4ec85971a31188e70ddda35a
compareTo
public int compareTo(VarLongWritable other)
{    if (value >= other.value) {        if (value > other.value) {            return 1;        }    } else {        return -1;    }    return 0;}
a894510dd4db439ff8e17ae1059489dc3abc97178e5932ceed0c70c3af165401
write
public void write(DataOutput out) throws IOException
{    Varint.writeSignedVarLong(value, out);}
5478cc5683f6dfd4515c383752d7c803555efc63d03fd84a03ba8dcd17eb4324
readFields
public void readFields(DataInput in) throws IOException
{    value = Varint.readSignedVarLong(in);}
3d6d4182dd8eded12b292834d179dd8a537b040c87c2b4caed8bb92d3bc59595
get
public Vector get()
{    return vector;}
95d9cb4fc0e382f9dcd484e0bd69387766041ed566cfda4f31db6eeaae5c721a
set
public void set(Vector vector)
{    this.vector = vector;}
e11813b75717b23bd82b48efe48b5d6fac2ed07d5a00ee5271ff72ffd38789e7
isWritesLaxPrecision
public boolean isWritesLaxPrecision()
{    return writesLaxPrecision;}
958e73ff74569d315bfbc542ef739819450df89df0231dc0535facd22ac966e5
setWritesLaxPrecision
public void setWritesLaxPrecision(boolean writesLaxPrecision)
{    this.writesLaxPrecision = writesLaxPrecision;}
a894510dd4db439ff8e17ae1059489dc3abc97178e5932ceed0c70c3af165401
write
public void write(DataOutput out) throws IOException
{    writeVector(out, this.vector, this.writesLaxPrecision);}
5478cc5683f6dfd4515c383752d7c803555efc63d03fd84a03ba8dcd17eb4324
readFields
public void readFields(DataInput in) throws IOException
{    int flags = in.readByte();    int size = Varint.readUnsignedVarInt(in);    readFields(in, (byte) flags, size);}
a3d29bb310b72bc6c568b1ec1655c477af029fcee9e4e78ff5963cf53a36ddfa
readFields
private void readFields(DataInput in, byte flags, int size) throws IOException
{    Preconditions.checkArgument(flags >> NUM_FLAGS == 0, "Unknown flags set: %d", Integer.toString(flags, 2));    boolean dense = (flags & FLAG_DENSE) != 0;    boolean sequential = (flags & FLAG_SEQUENTIAL) != 0;    boolean named = (flags & FLAG_NAMED) != 0;    boolean laxPrecision = (flags & FLAG_LAX_PRECISION) != 0;    Vector v;    if (dense) {        double[] values = new double[size];        for (int i = 0; i < size; i++) {            values[i] = laxPrecision ? in.readFloat() : in.readDouble();        }        v = new DenseVector(values);    } else {        int numNonDefaultElements = Varint.readUnsignedVarInt(in);        v = sequential ? new SequentialAccessSparseVector(size, numNonDefaultElements) : new RandomAccessSparseVector(size, numNonDefaultElements);        if (sequential) {            int lastIndex = 0;            for (int i = 0; i < numNonDefaultElements; i++) {                int delta = Varint.readUnsignedVarInt(in);                int index = lastIndex + delta;                lastIndex = index;                double value = laxPrecision ? in.readFloat() : in.readDouble();                v.setQuick(index, value);            }        } else {            for (int i = 0; i < numNonDefaultElements; i++) {                int index = Varint.readUnsignedVarInt(in);                double value = laxPrecision ? in.readFloat() : in.readDouble();                v.setQuick(index, value);            }        }    }    if (named) {        String name = in.readUTF();        v = new NamedVector(v, name);    }    vector = v;}
72b383f0f0a702bc49cf01a4fdb576233b0ecbc45006cdfb1c9bac8a22f6a7c3
writeVector
public static void writeVector(DataOutput out, Vector vector) throws IOException
{    writeVector(out, vector, false);}
a0e60a9a4dd57c27e4ffb423169654dd7894fb6955170bf2e0a24c1614704944
flags
public static byte flags(Vector vector, boolean laxPrecision)
{    boolean dense = vector.isDense();    boolean sequential = vector.isSequentialAccess();    boolean named = vector instanceof NamedVector;    return (byte) ((dense ? FLAG_DENSE : 0) | (sequential ? FLAG_SEQUENTIAL : 0) | (named ? FLAG_NAMED : 0) | (laxPrecision ? FLAG_LAX_PRECISION : 0));}
af11406889768f8eeb1d300b4a21bb1e1437daf2f330a0f93c34ea62dec1b4e8
writeVectorFlagsAndSize
public static void writeVectorFlagsAndSize(DataOutput out, byte flags, int size) throws IOException
{    out.writeByte(flags);    Varint.writeUnsignedVarInt(size, out);}
4099e7ab0e1493f45dce8826e28f9362900e56dc3dc2a2ecaedfd05238f6b3e5
writeVector
public static void writeVector(DataOutput out, Vector vector, boolean laxPrecision) throws IOException
{    byte flags = flags(vector, laxPrecision);    writeVectorFlagsAndSize(out, flags, vector.size());    writeVectorContents(out, vector, flags);}
a86fbb6b5851cbf8ed814a88546a771d30e5ee0363b5fa945812ce8d95becab3
writeVectorContents
public static void writeVectorContents(DataOutput out, Vector vector, byte flags) throws IOException
{    boolean dense = (flags & FLAG_DENSE) != 0;    boolean sequential = (flags & FLAG_SEQUENTIAL) != 0;    boolean named = (flags & FLAG_NAMED) != 0;    boolean laxPrecision = (flags & FLAG_LAX_PRECISION) != 0;    if (dense) {        for (Element element : vector.all()) {            if (laxPrecision) {                out.writeFloat((float) element.get());            } else {                out.writeDouble(element.get());            }        }    } else {        Varint.writeUnsignedVarInt(vector.getNumNonZeroElements(), out);        Iterator<Element> iter = vector.nonZeroes().iterator();        if (sequential) {            int lastIndex = 0;            while (iter.hasNext()) {                Element element = iter.next();                if (element.get() == 0) {                    continue;                }                int thisIndex = element.index();                                Varint.writeUnsignedVarInt(thisIndex - lastIndex, out);                lastIndex = thisIndex;                if (laxPrecision) {                    out.writeFloat((float) element.get());                } else {                    out.writeDouble(element.get());                }            }        } else {            while (iter.hasNext()) {                Element element = iter.next();                if (element.get() == 0) {                                        continue;                }                Varint.writeUnsignedVarInt(element.index(), out);                if (laxPrecision) {                    out.writeFloat((float) element.get());                } else {                    out.writeDouble(element.get());                }            }        }    }    if (named) {        String name = ((NamedVector) vector).getName();        out.writeUTF(name == null ? "" : name);    }}
79182b7132025f2fb273a93526f222fe9e7ec553cc064c5ed44a16905e8fb89b
readVector
public static Vector readVector(DataInput in) throws IOException
{    VectorWritable v = new VectorWritable();    v.readFields(in);    return v.get();}
b2b3c950bbe55b1c66076951fffaf1609886f1b8e8ba6c404d308f3df428b030
readVector
public static Vector readVector(DataInput in, byte vectorFlags, int size) throws IOException
{    VectorWritable v = new VectorWritable();    v.readFields(in, vectorFlags, size);    return v.get();}
0d4b8be64a3fe943da79f0ce3c44d375a597d872f2b065219c68cc41c7dafeb4
merge
public static VectorWritable merge(Iterator<VectorWritable> vectors)
{    return new VectorWritable(mergeToVector(vectors));}
54624f7bc4d6c2632f95e8dbce07633477fd85147676c8faeddfb77d699df622
mergeToVector
public static Vector mergeToVector(Iterator<VectorWritable> vectors)
{    Vector accumulator = vectors.next().get();    while (vectors.hasNext()) {        VectorWritable v = vectors.next();        if (v != null) {            for (Element nonZeroElement : v.get().nonZeroes()) {                accumulator.setQuick(nonZeroElement.index(), nonZeroElement.get());            }        }    }    return accumulator;}
8d37d11c7ecfc0d0589696a89cb385888c83bd3e43ea0c95a3b4ae4ef78180ce
equals
public boolean equals(Object o)
{    return o instanceof VectorWritable && vector.equals(((VectorWritable) o).get());}
0ac42bf5188762fc1283b5cbd2b3bb1031e80963813b3b310b15c3fb47050003
hashCode
public int hashCode()
{    return vector.hashCode();}
210eee3d731623cb7c6189497cc462f9c459d9c81b6e0fe12b4b36ce53a197b7
toString
public String toString()
{    return vector.toString();}
a40ddaaa201af4d62464ab8dda833bee4f4191d18bd6f923fcc4f708d729baec
testSparseMatrixWritable
public void testSparseMatrixWritable() throws Exception
{    Matrix m = new SparseMatrix(5, 5);    m.set(1, 2, 3.0);    m.set(3, 4, 5.0);    Map<String, Integer> bindings = new HashMap<>();    bindings.put("A", 0);    bindings.put("B", 1);    bindings.put("C", 2);    bindings.put("D", 3);    bindings.put("default", 4);    m.setRowLabelBindings(bindings);    m.setColumnLabelBindings(bindings);    doTestMatrixWritableEquals(m);}
392655a575a6c048f8e475e1bae88cea4f59dc8e3fffae00990e61eaa0207187
testSparseRowMatrixWritable
public void testSparseRowMatrixWritable() throws Exception
{    Matrix m = new SparseRowMatrix(5, 5);    m.set(1, 2, 3.0);    m.set(3, 4, 5.0);    Map<String, Integer> bindings = new HashMap<>();    bindings.put("A", 0);    bindings.put("B", 1);    bindings.put("C", 2);    bindings.put("D", 3);    bindings.put("default", 4);    m.setRowLabelBindings(bindings);    m.setColumnLabelBindings(bindings);    doTestMatrixWritableEquals(m);}
d9c6dbb5db418cd35136eb5fb3bc49a73a6bc7210e7fbc987d6486dc5efa0b4e
testDenseMatrixWritable
public void testDenseMatrixWritable() throws Exception
{    Matrix m = new DenseMatrix(5, 5);    m.set(1, 2, 3.0);    m.set(3, 4, 5.0);    Map<String, Integer> bindings = new HashMap<>();    bindings.put("A", 0);    bindings.put("B", 1);    bindings.put("C", 2);    bindings.put("D", 3);    bindings.put("default", 4);    m.setRowLabelBindings(bindings);    m.setColumnLabelBindings(bindings);    doTestMatrixWritableEquals(m);}
ce97016fe656a157332edfb819ffa2067414587c2df3310e0ddf698cda109421
doTestMatrixWritableEquals
private static void doTestMatrixWritableEquals(Matrix m) throws IOException
{    Writable matrixWritable = new MatrixWritable(m);    MatrixWritable matrixWritable2 = new MatrixWritable();    writeAndRead(matrixWritable, matrixWritable2);    Matrix m2 = matrixWritable2.get();    compareMatrices(m, m2);    doCheckBindings(m2.getRowLabelBindings());    doCheckBindings(m2.getColumnLabelBindings());}
d02d33e517bbe3d6548c7116cb7ec646a56e5d78aae566dbfcb86d224e3d6d55
compareMatrices
private static void compareMatrices(Matrix m, Matrix m2)
{    assertEquals(m.numRows(), m2.numRows());    assertEquals(m.numCols(), m2.numCols());    for (int r = 0; r < m.numRows(); r++) {        for (int c = 0; c < m.numCols(); c++) {            assertEquals(m.get(r, c), m2.get(r, c), EPSILON);        }    }    Map<String, Integer> bindings = m.getRowLabelBindings();    Map<String, Integer> bindings2 = m2.getRowLabelBindings();    assertEquals(bindings == null, bindings2 == null);    if (bindings != null) {        assertEquals(bindings.size(), m.numRows());        assertEquals(bindings.size(), bindings2.size());        for (Map.Entry<String, Integer> entry : bindings.entrySet()) {            assertEquals(entry.getValue(), bindings2.get(entry.getKey()));        }    }    bindings = m.getColumnLabelBindings();    bindings2 = m2.getColumnLabelBindings();    assertEquals(bindings == null, bindings2 == null);    if (bindings != null) {        assertEquals(bindings.size(), bindings2.size());        for (Map.Entry<String, Integer> entry : bindings.entrySet()) {            assertEquals(entry.getValue(), bindings2.get(entry.getKey()));        }    }}
707df75e70143d1906828618d4c83c563708da0754347717eb1bf112e9bb7a82
doCheckBindings
private static void doCheckBindings(Map<String, Integer> labels)
{    assertTrue("Missing label", labels.keySet().contains("A"));    assertTrue("Missing label", labels.keySet().contains("B"));    assertTrue("Missing label", labels.keySet().contains("C"));    assertTrue("Missing label", labels.keySet().contains("D"));    assertTrue("Missing label", labels.keySet().contains("default"));}
7398260d6fb7f330d46c79cb7dc9233e292aff8cb49c8ca7f00a0cba5c22abcf
writeAndRead
private static void writeAndRead(Writable toWrite, Writable toRead) throws IOException
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    try (DataOutputStream dos = new DataOutputStream(baos)) {        toWrite.write(dos);    }    ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());    try (DataInputStream dis = new DataInputStream(bais)) {        toRead.readFields(dis);    }}
de5a261e1e0a6c3499d2dacb6f0b497b0f4d5ba069341b9672b37c5d5f7d5c49
testUnsignedLong
public void testUnsignedLong() throws Exception
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    DataOutput out = new DataOutputStream(baos);    Varint.writeUnsignedVarLong(0L, out);    for (long i = 1L; i > 0L && i <= (1L << 62); i <<= 1) {        Varint.writeUnsignedVarLong(i - 1, out);        Varint.writeUnsignedVarLong(i, out);    }    Varint.writeUnsignedVarLong(Long.MAX_VALUE, out);    DataInput in = new DataInputStream(new ByteArrayInputStream(baos.toByteArray()));    assertEquals(0L, Varint.readUnsignedVarLong(in));    for (long i = 1L; i > 0L && i <= (1L << 62); i <<= 1) {        assertEquals(i - 1, Varint.readUnsignedVarLong(in));        assertEquals(i, Varint.readUnsignedVarLong(in));    }    assertEquals(Long.MAX_VALUE, Varint.readUnsignedVarLong(in));}
e4fb4f4a5160ab1381621e347a03aea9bb02c32933772ae0fadc45d05cac65ab
testSignedPositiveLong
public void testSignedPositiveLong() throws Exception
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    DataOutput out = new DataOutputStream(baos);    Varint.writeSignedVarLong(0L, out);    for (long i = 1L; i <= (1L << 61); i <<= 1) {        Varint.writeSignedVarLong(i - 1, out);        Varint.writeSignedVarLong(i, out);    }    Varint.writeSignedVarLong((1L << 62) - 1, out);    Varint.writeSignedVarLong((1L << 62), out);    Varint.writeSignedVarLong(Long.MAX_VALUE, out);    DataInput in = new DataInputStream(new ByteArrayInputStream(baos.toByteArray()));    assertEquals(0L, Varint.readSignedVarLong(in));    for (long i = 1L; i <= (1L << 61); i <<= 1) {        assertEquals(i - 1, Varint.readSignedVarLong(in));        assertEquals(i, Varint.readSignedVarLong(in));    }    assertEquals((1L << 62) - 1, Varint.readSignedVarLong(in));    assertEquals((1L << 62), Varint.readSignedVarLong(in));    assertEquals(Long.MAX_VALUE, Varint.readSignedVarLong(in));}
a2769ce83ecdeaf43cb42c6eca90bfdce3d763b6e95cb08056dd551c9fcc4aa9
testSignedNegativeLong
public void testSignedNegativeLong() throws Exception
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    DataOutput out = new DataOutputStream(baos);    for (long i = -1L; i >= -(1L << 62); i <<= 1) {        Varint.writeSignedVarLong(i, out);        Varint.writeSignedVarLong(i + 1, out);    }    Varint.writeSignedVarLong(Long.MIN_VALUE, out);    Varint.writeSignedVarLong(Long.MIN_VALUE + 1, out);    DataInput in = new DataInputStream(new ByteArrayInputStream(baos.toByteArray()));    for (long i = -1L; i >= -(1L << 62); i <<= 1) {        assertEquals(i, Varint.readSignedVarLong(in));        assertEquals(i + 1, Varint.readSignedVarLong(in));    }    assertEquals(Long.MIN_VALUE, Varint.readSignedVarLong(in));    assertEquals(Long.MIN_VALUE + 1, Varint.readSignedVarLong(in));}
3569d8c819ee2dc878202a712efaa2f1f7e6bab5859c069eb263fb1a06471a18
testUnsignedInt
public void testUnsignedInt() throws Exception
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    DataOutput out = new DataOutputStream(baos);    Varint.writeUnsignedVarInt(0, out);    for (int i = 1; i > 0 && i <= (1 << 30); i <<= 1) {        Varint.writeUnsignedVarLong(i - 1, out);        Varint.writeUnsignedVarLong(i, out);    }    Varint.writeUnsignedVarLong(Integer.MAX_VALUE, out);    DataInput in = new DataInputStream(new ByteArrayInputStream(baos.toByteArray()));    assertEquals(0, Varint.readUnsignedVarInt(in));    for (int i = 1; i > 0 && i <= (1 << 30); i <<= 1) {        assertEquals(i - 1, Varint.readUnsignedVarInt(in));        assertEquals(i, Varint.readUnsignedVarInt(in));    }    assertEquals(Integer.MAX_VALUE, Varint.readUnsignedVarInt(in));}
8bd0fcd1b10b2df9784c850f5db1980ba44990504edb334cf0c0c8a1a3786124
testSignedPositiveInt
public void testSignedPositiveInt() throws Exception
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    DataOutput out = new DataOutputStream(baos);    Varint.writeSignedVarInt(0, out);    for (int i = 1; i <= (1 << 29); i <<= 1) {        Varint.writeSignedVarLong(i - 1, out);        Varint.writeSignedVarLong(i, out);    }    Varint.writeSignedVarInt((1 << 30) - 1, out);    Varint.writeSignedVarInt((1 << 30), out);    Varint.writeSignedVarInt(Integer.MAX_VALUE, out);    DataInput in = new DataInputStream(new ByteArrayInputStream(baos.toByteArray()));    assertEquals(0, Varint.readSignedVarInt(in));    for (int i = 1; i <= (1 << 29); i <<= 1) {        assertEquals(i - 1, Varint.readSignedVarInt(in));        assertEquals(i, Varint.readSignedVarInt(in));    }    assertEquals((1L << 30) - 1, Varint.readSignedVarInt(in));    assertEquals((1L << 30), Varint.readSignedVarInt(in));    assertEquals(Integer.MAX_VALUE, Varint.readSignedVarInt(in));}
f5a16f0bef1de09c0e66683c868ea776187ce25533429e09222c2a2122eb9a66
testSignedNegativeInt
public void testSignedNegativeInt() throws Exception
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    DataOutput out = new DataOutputStream(baos);    for (int i = -1; i >= -(1 << 30); i <<= 1) {        Varint.writeSignedVarInt(i, out);        Varint.writeSignedVarInt(i + 1, out);    }    Varint.writeSignedVarInt(Integer.MIN_VALUE, out);    Varint.writeSignedVarInt(Integer.MIN_VALUE + 1, out);    DataInput in = new DataInputStream(new ByteArrayInputStream(baos.toByteArray()));    for (int i = -1; i >= -(1 << 30); i <<= 1) {        assertEquals(i, Varint.readSignedVarInt(in));        assertEquals(i + 1, Varint.readSignedVarInt(in));    }    assertEquals(Integer.MIN_VALUE, Varint.readSignedVarInt(in));    assertEquals(Integer.MIN_VALUE + 1, Varint.readSignedVarInt(in));}
31a85a0639786f5fa4f54eb6ddcde26b6019c671e327d98d382f16acf7983b8b
testUnsignedSize
public void testUnsignedSize() throws Exception
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    DataOutput out = new DataOutputStream(baos);    int expectedSize = 0;    for (int exponent = 0; exponent <= 62; exponent++) {        Varint.writeUnsignedVarLong(1L << exponent, out);        expectedSize += 1 + exponent / 7;        assertEquals(expectedSize, baos.size());    }}
037bcaa950a641523c2a555f2dc16e989bfe93fae7dc2b0ee8facc5cbc58eb4b
testSignedSize
public void testSignedSize() throws Exception
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    DataOutput out = new DataOutputStream(baos);    int expectedSize = 0;    for (int exponent = 0; exponent <= 61; exponent++) {        Varint.writeSignedVarLong(1L << exponent, out);        expectedSize += 1 + ((exponent + 1) / 7);        assertEquals(expectedSize, baos.size());    }    for (int exponent = 0; exponent <= 61; exponent++) {        Varint.writeSignedVarLong(-(1L << exponent) - 1, out);        expectedSize += 1 + ((exponent + 1) / 7);        assertEquals(expectedSize, baos.size());    }}
208cfb9a29623f2baf0c8da12ed591ee286fe6278baa33caf66bbc6ce26473a9
createRandom
public void createRandom(Vector v)
{    int size = randomInt(v.size() - 1);    for (int i = 0; i < size; ++i) {        v.set(randomInt(v.size() - 1), randomDouble());    }    int zeros = Math.max(2, size / 4);    for (Element e : v.nonZeroes()) {        if (e.index() % zeros == 0) {            e.set(0.0);        }    }}
a1367adfe853ddcd8f629eed1be7ef6766a47ad5901ba4c6124670667347e29c
testViewSequentialAccessSparseVectorWritable
public void testViewSequentialAccessSparseVectorWritable() throws Exception
{    Vector v = new SequentialAccessSparseVector(MAX_VECTOR_SIZE);    createRandom(v);    Vector view = new VectorView(v, 0, v.size());    doTestVectorWritableEquals(view);}
532803ff17c895aa70cdebda66de6714df4edcec4a128ec5ce6a71d53bdcd6f5
testSequentialAccessSparseVectorWritable
public void testSequentialAccessSparseVectorWritable() throws Exception
{    Vector v = new SequentialAccessSparseVector(MAX_VECTOR_SIZE);    createRandom(v);    doTestVectorWritableEquals(v);}
fe4d7b8d508a49013149f3698148f86131be3ccb55ad8848ce4940cb1f21b7a2
testRandomAccessSparseVectorWritable
public void testRandomAccessSparseVectorWritable() throws Exception
{    Vector v = new RandomAccessSparseVector(MAX_VECTOR_SIZE);    createRandom(v);    doTestVectorWritableEquals(v);}
9d6a96ce838d362620662f8981016caf374840899e498bb1ea475710c5036de3
testDenseVectorWritable
public void testDenseVectorWritable() throws Exception
{    Vector v = new DenseVector(MAX_VECTOR_SIZE);    createRandom(v);    doTestVectorWritableEquals(v);}
b9519a00fd346657be70609d4dd80d470d64226ccc65bb2dde3e4b528331e594
testNamedVectorWritable
public void testNamedVectorWritable() throws Exception
{    Vector v = new DenseVector(MAX_VECTOR_SIZE);    v = new NamedVector(v, "Victor");    createRandom(v);    doTestVectorWritableEquals(v);}
953903057f1e392962010a2b967c6c7d33b718d077b8280edd629338834e7440
doTestVectorWritableEquals
private static void doTestVectorWritableEquals(Vector v) throws IOException
{    Writable vectorWritable = new VectorWritable(v);    VectorWritable vectorWritable2 = new VectorWritable();    writeAndRead(vectorWritable, vectorWritable2);    Vector v2 = vectorWritable2.get();    if (v instanceof NamedVector) {        assertTrue(v2 instanceof NamedVector);        NamedVector nv = (NamedVector) v;        NamedVector nv2 = (NamedVector) v2;        assertEquals(nv.getName(), nv2.getName());        assertEquals("Victor", nv.getName());    }    assertEquals(v, v2);}
7398260d6fb7f330d46c79cb7dc9233e292aff8cb49c8ca7f00a0cba5c22abcf
writeAndRead
private static void writeAndRead(Writable toWrite, Writable toRead) throws IOException
{    ByteArrayOutputStream baos = new ByteArrayOutputStream();    try (DataOutputStream dos = new DataOutputStream(baos)) {        toWrite.write(dos);    }    ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());    try (DataInputStream dis = new DataInputStream(bais)) {        toRead.readFields(dis);    }}

